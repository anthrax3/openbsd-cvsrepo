head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.8
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.6
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.2
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.2.0.12
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.10
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.8
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2015.04.06.20.57.58;	author matthieu;	state Exp;
branches;
next	1.2;
commitid	L5f7tv2EiGjtzoSu;

1.2
date	2012.03.27.19.19.38;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.30.19.19.37;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@update to libX11 1.6.3
@
text
@<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
	  "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id='Keyboard_Geometry'>
<title>Keyboard Geometry</title>

<para>
The Xkb description of a keyboard includes an optional keyboard geometry that
describes the physical appearance of the keyboard. Keyboard geometry describes
the shape, location, and color of all keyboard keys or other visible keyboard
components such as indicators. The information contained in a keyboard geometry
is sufficient to allow a client program to draw an accurate two-dimensional
image of the keyboard.
</para>


<para>
You can retrieve a keyboard geometry from an X server that supports Xkb, or you
can allocate it from scratch and initialize it in a client program. The
keyboard geometry need not have any correspondence with the physical keyboard
that is connected to the X server.
</para>


<para>
Geometry measurements are specified in mm/10 units. The origin (0,0) is in the
top left corner of the keyboard image. A component’s own origin is also its
upper left corner. In some cases a component needs to be drawn rotated. For
example, a special keyboard may have a section of keys arranged in rows in a
rectangular area, but the entire rectangle may not be in alignment with the
rest of the keyboard, and instead, it is rotated from horizontal by 30°.
Rotation for a geometry object is specified in 1/10° increments about its
origin. An example of a keyboard with rotated sections is shown in <link linkend="figure13.1">Figure 13.1</link>.
</para>

<figure id='figure13.1'>
  <title>Rotated Keyboard Sections</title>
  <mediaobject>
   <imageobject> <imagedata format="SVG" fileref="XKBlib-7.svg"/>
   </imageobject>
  </mediaobject>
</figure>


<!-- <H5 CLASS="Figure">
Rotated Keyboard Sections</H5>
-->

<para>
Some geometry components include a
<structfield>priority</structfield>,
which indicates the order in which overlapping objects should be drawn.
Objects should be drawn in order from highest priority (0) to lowest (255).
</para>


<para id='XkbGeometryRec'>
<indexterm significance="preferred" zone="XkbGeometryRec">
<primary><structname>XkbGeometryRec</structname></primary></indexterm>
The keyboard geometry’s top-level description is stored in a
<structname>XkbGeometryRec</structname>
structure. This structure contains three types of information:
</para>

<orderedlist>
  <listitem>
    <para>
Lists of items, not used to draw the basic keyboard, but indexed by the
geometry descriptions that comprise the entire keyboard geometry (colors,
geometry properties, key aliases, shapes)
    </para>
  </listitem>
  <listitem>
    <para>
A number of singleton items that describe the keyboard as a whole (keyboard
name, width and height, a color for the keyboard as a whole, and a color for
keyboard key labels)
    </para>
  </listitem>
  <listitem>
    <para>
A list of the keyboard’s sections and nonkey doodads
    </para>
  </listitem>
</orderedlist>

<para>
The top-level geometry is described in more detail in the following.
</para>


<para>
The lists of items used by components of the keyboard geometry description is
as follows:
</para>

<itemizedlist>
<listitem>
  <para>
The top-level keyboard geometry description includes a list of up to
<symbol>XkbGeomMaxColors</symbol>
(32)
<firstterm>color names</firstterm>.
A color name is a string whose interpretation is not specified by Xkb. The
<structname>XkbColorRec</structname>
structure provides a field for this name as well as a pixel field. The pixel
field is a convenient place for an application to store a pixel value or color
definition, if it needs to. All other geometry data structures refer to colors
using their indices in this global list.
  </para>
</listitem>
<listitem>
  <para>
The top-level keyboard geometry description includes a list of
<firstterm>geometry properties</firstterm>.
A geometry property associates an arbitrary string with an equally arbitrary
name. Geometry properties can be used to provide hints to programs that display
images of keyboards, but they are not interpreted by Xkb. No other geometry
structures refer to geometry properties. As an example of a possible use of
<structfield>properties</structfield>,
consider the pause/break key on most PC keyboards: the <quote>break</quote>
symbol is
usually on the front of the key and is often a different color. A program might
set a property to:
  </para>
  <para>
LBL_PAUS = "{Pause/top/black,Break/front/red}"
  </para>
  <para>
and use the property information to draw the key with a front label as well as
a top label.
  </para>
</listitem>
<listitem>
  <para>
The top-level keyboard geometry description includes a list of
<firstterm>key aliases</firstterm>
(see <xref linkend="Symbolic_Names" />). Key aliases allow the keyboard layout designer to assign
multiple key names to a single key.
  </para>
<note><para>Key aliases defined in the geometry component of a keyboard mapping
override those defined in the keycodes component of the server database, which
are stored in the
<structname>XkbNamesRec</structname>

(<structfield>xkb-&gt;names</structfield>).
Therefore, consider the key aliases defined by the geometry before
considering key aliases supplied by the keycodes.</para></note>
</listitem>
<listitem>
  <para>
The top-level keyboard geometry description includes a list of
<structfield>shapes</structfield>;
other keyboard components refer to shapes by their index in this list. A
shape consists of an arbitrary name of type Atom and one or more closed-polygon
<structfield>outlines</structfield>.
All points in an outline are specified relative to the origin of its
enclosing shape, that is, whichever shape that contains this outline in its
list of outlines. One outline is the primary outline. The primary outline is by
default the first outline, or it can be optionally specified by the
<structfield>primary</structfield>
field in the
<structname>XkbShapeRec</structname>
structure. A keyboard display application can generate a simpler but still
accurate keyboard image by displaying only the primary outlines for each shape.
Nonrectangular keys must include a rectangular
<firstterm>approximation</firstterm>
as one of the outlines associated with the shape. The approximation is not
normally displayed but can be used by very simple keyboard display applications
to generate a recognizable but degraded image of the keyboard.
  </para>
</listitem>
</itemizedlist>

<para>
The
<structname>XkbGeometryRec</structname>
top-level geometry description contains the following information that
pertains to the keyboard as a whole:
</para>

<itemizedlist>
<listitem>
  <para>
A
<firstterm>keyboard symbolic name</firstterm>
of type Atom to help users identify the keyboard.
  </para>
</listitem>
<listitem>
  <para>
The
<structfield>width</structfield>
and
<structfield>height</structfield>
of the keyboard, in mm/10. For nonrectangular keyboards, the width and height
describe the smallest bounding box that encloses the outline of the keyboard.
  </para>
</listitem>
<listitem>
  <para>
The
<firstterm>base color</firstterm>
of the keyboard is the predominant color on the keyboard and is used as the
default color for any components whose color is not explicitly specified.
  </para>
</listitem>
<listitem>
  <para>
The
<firstterm>label color</firstterm>
is the color used to draw the labels on most of the keyboard keys.
  </para>
</listitem>
<listitem>
  <para>
The
<firstterm>label font</firstterm>
is a string that describes the font used to draw labels on most keys; label
fonts are arbitrary strings, because Xkb does not specify the format or name
space for font names.
  </para>
</listitem>
</itemizedlist>

<para>
The keyboard is subdivided into named
<structfield>sections</structfield>
of related keys and doodads. The sections and doodads on the keyboard are
listed in the
<structname>XkbGeometryRec</structname>
top-level keyboard geometry description. A section is composed of keys that
are physically together and logically related. <link linkend="figure13.2">Figure 13.2</link> shows a keyboard
that is divided into four sections. A
<structfield>doodad</structfield>
describes some visible aspect of the keyboard that is not a key and is not a
section.
</para>

<figure id='figure13.2'>
  <title>Keyboard with Four Sections</title>
  <mediaobject>
   <imageobject> <imagedata format="SVG" fileref="XKBlib-8.svg"/>
   </imageobject>
  </mediaobject>
</figure>

<!--
<H5 CLASS="Figure">
Keyboard with Four Sections</H5>
-->

<sect1 id='Shapes_and_Outlines'>
<title>Shapes and Outlines</title>

<para>
A
<structfield>shape</structfield>,
used to draw keyboard components and stored in a
<structname>XkbShapeRec</structname>
structure, has:
</para>

<itemizedlist>
<listitem>
  <para>
An arbitrary name of type Atom.
  </para>
</listitem>
<listitem>
  <para>
Bounds (two x and y coordinates) that describe the corners of a rectangle
containing the shape’s top surface outline.
  </para>
</listitem>
<listitem>
  <para>
A list of one or more outlines (described below).
  </para>
</listitem>
<listitem>
  <para>
Optional pointers to a primary and an approximation outline (described below).
If either of these pointers is
<symbol>NULL</symbol>,
the default primary/approximation outline is the first one in the list of
outlines for the shape.
  </para>
</listitem>
</itemizedlist>

<para>
An
<firstterm>outline</firstterm>,
stored in a
<structname>XkbOutlineRec</structname>
structure, is a list of one or more points that describes a single
closed-polygon, as follows:
</para>

<itemizedlist>
<listitem>
  <para>
A list with a single point describes a rectangle with one corner at the origin
of the shape (0,0) and the opposite corner at the specified point.
  </para>
</listitem>
<listitem>
  <para>
A list of two points describes a rectangle with one corner at the position
specified by the first point and the opposite corner at the position specified
by the second point.
  </para>
</listitem>
<listitem>
  <para>
A list of three or more points describes an arbitrary polygon. If necessary,
the polygon is automatically closed by connecting the last point in the list
with the first.
  </para>
</listitem>
<listitem>
  <para>
A nonzero value for the
<structfield>corner_radius</structfield>
field specifies that the corners of the polygon should be drawn as circles
with the specified radius.
  </para>
</listitem>
</itemizedlist>

<para>
All points in an outline are specified relative to the origin of the enclosing
shape. Points in an outline may have negative values for the X and Y coordinate.
</para>


<para>
One outline is the primary outline; a keyboard display application can generate
a simple but still accurate keyboard image by displaying only the primary
outlines for each shape. The default primary outline is the first in a
shape’s list of outlines. If the
<structfield>primary</structfield>
field of the
<structname>XkbShapeRec</structname>
structure is not
<symbol>NULL</symbol>,
it points to the primary outline. A rectangular
<firstterm>approximation</firstterm>
must be included for nonrectangular keys as one of the outlines associated
with the shape; the approximation is not normally displayed but can be used by
very simple keyboard display applications to generate a recognizable but
degraded image of the keyboard.
</para>

</sect1>
<sect1 id='Sections'>
<title>Sections</title>

<para>
As previously noted, a keyboard is subdivided into
<structfield>sections</structfield>
of related keys. Each section has its own coordinate system — if a section
is rotated, the coordinates of any components within the section are
interpreted relative to the edges that were on the top and left before
rotation. The components that make up a section, stored in a
<structname>XkbSectionRec</structname>,
include:
</para>

<itemizedlist>
<listitem>
  <para>
An arbitrary name of type Atom.
  </para>
</listitem>
<listitem>
  <para>
A priority, to indicate drawing order. 0 is the highest priority, 255 the
lowest.
  </para>
</listitem>
<listitem>
  <para>
Origin of the section, relative to the origin of the keyboard.
  </para>
</listitem>
<listitem>
  <para>
The width and height and the angle of rotation.
  </para>
</listitem>
<listitem>
  <para>
A list of
<structfield>rows</structfield>.
A row is a list of horizontally or vertically adjacent keys. Horizontal rows
parallel the (prerotation) top of the section, and vertical rows parallel the
(prerotation) left of the section. All keys in a horizontal row share a common
top coordinate; all keys in a vertical row share a left coordinate. <link linkend="figure13.3">Figure 13.3</link>
shows the alpha section from the keyboard shown in <link linkend="figure13.2">Figure 13.2</link>, divided into
rows. Rows and keys are defined below.
  </para>
</listitem>
</itemizedlist>

<figure id='figure13.3'>
  <title>Rows in a Section</title>
  <mediaobject>
    <imageobject> <imagedata format="SVG" fileref="XKBlib-9.svg"/>
    </imageobject>
  </mediaobject>
</figure>



<!--
<H5 CLASS="Figure">
Rows in a Section</H5>
-->
<itemizedlist>
<listitem>
  <para>
An optional list of
<structfield>doodads</structfield>;
any type of doodad can be enclosed within a section. Position and angle of
rotation are relative to the origin and angle of rotation of the sections that
contain them. Priority for doodads in a section is relative to the other
components of the section, not to the keyboard as a whole.
  </para>
</listitem>
<listitem>
  <para>
An optional
<firstterm>overlay</firstterm>
with a name of type Atom and a list of overlay rows (described below).
  </para>
</listitem>
<listitem>
  <para>
Bounds (two x and y coordinates) that describe the corners of a rectangle
containing the entire section.
  </para>
</listitem>
</itemizedlist>
</sect1>
<sect1 id='Rows_and_Keys'>
<title>Rows and Keys</title>

<para>
A row description
(<structname>XkbRowRec</structname>)
consists of the coordinates of its origin relative to its enclosing section,
a flag indicating whether the row is horizontal or vertical, and a list of keys
in the row.
</para>


<para>
A key description
(<structname>XkbKeyRec</structname>)
consists of a key name, a shape, a key color, and a gap. The key name should
correspond to one of the keys named in the keyboard names description, the
shape specifies the appearance of the key, and the key color specifies the
color of the key (not the label on the key; the label color is stored in the
<structname>XkbGeometryRec</structname>).
Keys are normally drawn immediately adjacent to one another from left to
right (or top to bottom) within a row. The gap field specifies the distance
between a key and its predecessor.
</para>


</sect1>
<sect1 id='Doodads'>
<title>Doodads</title>

<para>
Doodads can be global to the keyboard or part of a section. Doodads have
symbolic names of arbitrary length. The only doodad name whose interpretation
is specified by Xkb is <quote>Edges</quote>, which, if present, describes the
outline of the entire keyboard.
</para>


<para>
Each doodad’s origin is stored in fields named
<structfield>left</structfield>
and
<structfield>top</structfield>,
which are the coordinates of the doodad’s origin relative to its enclosing
object, whether it be a section or the top-level keyboard. The priority for
doodads that are listed in the top-level geometry is relative to the other
doodads listed in the top-level geometry and the sections listed in the
top-level geometry. The priority for doodads listed in a section are relative
to the other components of the section. Each doodad is stored in a structure
with a
<structfield>type</structfield>
field, which specifies the type of doodad.
</para>

<para>
Xkb supports five types of doodads:
</para>

<itemizedlist>
<listitem>
  <para>
An
<firstterm>indicator doodad</firstterm>
describes one of the physical keyboard indicators. Indicator doodads specify
the shape of the indicator, the indicator color when it is lit
(<emphasis>on_color</emphasis>)
and the indicator color when it is dark
(<emphasis>off_color</emphasis>).

  </para>
</listitem>
<listitem>
  <para>
An
<firstterm>outline doodad</firstterm>
describes some aspect of the keyboard to be drawn as one or more hollow,
closed polygons. Outline doodads specify the shape, color, and angle of
rotation about the doodad origin at which they should be drawn.
  </para>
</listitem>
<listitem>
  <para>
A
<firstterm>solid doodad</firstterm>
describes some aspect of the keyboard to be drawn as one or more filled
polygons. Solid doodads specify the shape, color, and angle of rotation about
the doodad origin at which they should be drawn.
  </para>
</listitem>
<listitem>
  <para>
A
<firstterm>text doodad</firstterm>
describes a text label somewhere on the keyboard. Text doodads specify the
label string, the font and color to use when drawing the label, and the angle
of rotation of the doodad about its origin.
  </para>
</listitem>
<listitem>
  <para>
A
<firstterm>logo doodad</firstterm>
is a catch-all, which describes some other visible element of the keyboard. A
logo doodad is essentially an outline doodad with an additional symbolic name
that describes the element to be drawn. If a keyboard display program
recognizes the symbolic name, it can draw something appropriate within the
bounding region of the shape specified in the doodad. If the symbolic name does
not describe a recognizable image, it should draw an outline using the
specified shape, outline, and angle of rotation. The Xkb extension does not
specify the interpretation of logo names.
  </para>
</listitem>
</itemizedlist>

<para>
The structures these doodads are stored in and the values of the
<structfield>type</structfield>
fields are shown in <link linkend="table13.1">Table 13.1</link>.
</para>

<table id='table13.1' frame='topbot'>
<title>Doodad Types</title>
<?dbfo keep-together="always" ?>
<tgroup cols='3' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<colspec colname='c2' colwidth='1.0*'/>
<colspec colname='c3' colwidth='1.0*'/>
<thead>
<row rowsep='1'>
  <entry>Doodad</entry>
  <entry>Structure</entry>
  <entry>Type</entry>
  </row>
</thead>
<tbody>
  <row>
    <entry>
<emphasis>indicator doodad</emphasis>
</entry>
    <entry>
<structname>XkbIndicatorDoodadRec</structname>
</entry>
    <entry>
<symbol>XkbIndicatorDoodad</symbol>
</entry>
  </row>
  <row>
    <entry>
<emphasis>outline doodad</emphasis>
</entry>
    <entry>
<structname>XkbShapeDoodadRec</structname>
</entry>
    <entry>
<symbol>XkbOutlineDoodad</symbol>
</entry>
  </row>
  <row>
    <entry>
<emphasis>solid doodad</emphasis>
</entry>
    <entry>
<structname>XkbShapeDoodadRec</structname>
</entry>
    <entry>
<symbol>XkbSolidDoodad</symbol>
</entry>
  </row>
  <row>
    <entry>
<emphasis>text doodad</emphasis>
</entry>
    <entry>
<structname>XkbTextDoodadRec</structname>
</entry>
    <entry>
<symbol>XkbTextDoodad</symbol>
</entry>
  </row>
  <row>
    <entry>
<emphasis>logo doodad</emphasis>
</entry>
    <entry>
<structname>XkbLogoDoodadRec</structname>
</entry>
    <entry>
<symbol>XkbLogoDoodad</symbol>
</entry>
  </row>
</tbody>
</tgroup>
</table>

</sect1>
<sect1 id='Overlay_Rows_and_Overlay_Keys'>
<title>Overlay Rows and Overlay Keys</title>

<para>
An
<firstterm>overlay row</firstterm>

(<structname>XkbOverlayRowRec</structname>)
contains a pointer to the row it overlays and a list of
<firstterm>overlay keys</firstterm>.
</para>


<para>
Each overlay key definition
(<structname>XkbOverlayKeyRec</structname>)
indicates a key that can yield multiple keycodes and consists of a field
named
<structfield>under</structfield>,
which specifies the primary name of the key and a field named
<structfield>over</structfield>,
which specifies the name for the key when the overlay keycode is selected.
The key specified in
<structfield>under</structfield>
must be a member of the section that contains the overlay key definition,
while the key specified in over must not be.
</para>


</sect1>
<sect1 id='Drawing_a_Keyboard_Representation'>
<title>Drawing a Keyboard Representation</title>

<para>
To draw a representation of the keyboard, draw in the following order:

<programlisting>
     Draw the top-level keyboard as a rectangle, using its width and height.
     For each component (section or doodad) of the top-level geometry, in priority order:
        If component is a section
           For each row, in the order it appears in the section
              Draw keys in the order they appear in the row
           Draw doodads within the section in priority order.
        Else draw doodad
</programlisting></para>

</sect1>
<sect1 id='Geometry_Data_Structures'>
<title>Geometry Data Structures</title>

<para>
In the following figures, a solid arrow denotes a pointer to an array of
structures or a singleton structure. A dotted arrow denotes an index or a
pointer into the array.
</para>

<!--
<MAP NAME="XKBlib-10">
</MAP>
-->
<figure id='figure13.4'>
  <title>Xkb Geometry Data Structures</title>
  <mediaobject>
   <imageobject> <imagedata format="SVG" fileref="XKBlib-10.svg"/>
   </imageobject>
  </mediaobject>
</figure>

<!--
<H5 CLASS="Figure">
Xkb Geometry Data Structures</H5>
<P CLASS="SmallBody">
&nbsp;</P>
<MAP NAME="XKBlib-11">
</MAP>
-->
<figure id='figure13.5'>
  <title>Xkb Geometry Data Structures (Doodads)</title>
  <mediaobject>
   <imageobject> <imagedata format="SVG" fileref="XKBlib-11.svg"/>
   </imageobject>
  </mediaobject>
</figure>

<!--
<H5 CLASS="Figure">
Xkb Geometry Data Structures (Doodads)</H5>
-->

<!--
<MAP NAME="XKBlib-12">
</MAP>
-->
<figure id='figure13.6'>
  <title>Xkb Geometry Data Structures (Overlays)</title>
  <mediaobject>
   <imageobject> <imagedata format="SVG" fileref="XKBlib-12.svg"/>
   </imageobject>
  </mediaobject>
</figure>

<!--
<H5 CLASS="Figure">
Xkb Geometry Data Structures (Overlays)</H5>
-->
<para><programlisting>
typedef struct _XkbGeometry {    /* top-level keyboard geometry structure */
    Atom              name;            /* keyboard name */
    unsigned short    width_mm;        /* keyboard width in <superscript>mm</superscript>/<subscript>10</subscript> */
    unsigned short    height_mm;       /* keyboard height in <superscript>mm</superscript>/<subscript>10</subscript> */
    char *            label_font;      /* font for key labels */
    XkbColorPtr       label_color;     /* color for key labels
                                          - pointer into colors array */
    XkbColorPtr       base_color;      /* color for basic keyboard
                                          - pointer into colors array */
    unsigned short    sz_properties;   /* size of properties array */
    unsigned short    sz_colors;       /* size of colors array */
    unsigned short    sz_shapes;       /* size of shapes array */
    unsigned short    sz_sections;     /* size of sections array */
    unsigned short    sz_doodads;      /* size of doodads array */
    unsigned short    sz_key_aliases;  /* size of key aliases array */
    unsigned short    num_properties;  /* number of properties in the
                                           properties array */
    unsigned short    num_colors;      /* number of colors in the
                                           colors array */
    unsigned short    num_shapes;      /* number of shapes in the
                                           shapes array */
    unsigned short    num_sections;    /* number of sections in the
                                           sections array */
    unsigned short    num_doodads;     /* number of doodads in the
                                           doodads array */
    unsigned short    num_key_aliases; /* number of key aliases in the
                                           key_aliases array */
    XkbPropertyPtr    properties;      /* properties array */
    XkbColorPtr       colors;          /* colors array */
    XkbShapePtr       shapes;          /* shapes array */
    XkbSectionPtr     sections;        /* sections array */
    XkbDoodadPtr      doodads;         /* doodads array */
    XkbKeyAliasPtr    key_aliases;     /* key aliases array */
} <structname>XkbGeometryRec</structname>, *XkbGeometryPtr;
</programlisting></para>

<para>
The
<structfield>doodads</structfield>
array is only for doodads not contained in any of the
<structfield>sections</structfield>
that has its own
<structfield>doodads</structfield>.
The key aliases contained in the
<structfield>key_aliases</structfield>
array take precedence over any defined in the keycodes component of the
keyboard description.
</para>

<para><programlisting>
typedef struct _XkbProperty {
    char *      name;                   /* property name */
    char *      value;                  /* property value */
} <structname>XkbPropertyRec</structname>, *XkbPropertyPtr;
</programlisting></para>

<para><programlisting>
typedef struct _XkbColor {
    unsigned int      pixel;            /* color */
    char *            spec;             /* color name */
} <structname>XkbColorRec</structname>, *XkbColorPtr;
</programlisting></para>

<para><programlisting>
typedef struct _XkbKeyAliasRec {
    char      real[XkbKeyNameLength];   /* real name of the key */
    char      alias[XkbKeyNameLength];  /* alias for the key */
} <structname>XkbKeyAliasRec</structname>, *XkbKeyAliasPtr;
</programlisting></para>

<para><programlisting>
typedef struct _XkbPoint {              /* x, y coordinates */
    short      x;
    short      y;
} <structname>XkbPointRec</structname>, *XkbPointPtr;
</programlisting></para>

<para><programlisting>
typedef struct _XkbOutline {
    unsigned short      num_points;     /* number of points in the outline */
    unsigned short      sz_points;      /* size of the points array */
    unsigned short      corner_radius;  /* draw corners as circles
                                           with this radius */
    XkbPointPtr         points;         /* array of points defining
                                           the outline */
} <structname>XkbOutlineRec</structname>, *XkbOutlinePtr;
</programlisting></para>

<para><programlisting>
typedef struct _XkbBounds {
    short      x1, y1;       /* upper left corner of the bounds, in <superscript>mm</superscript>/<subscript>10</subscript> */
    short      x2, y2;       /* lower right corner of the bounds, in <superscript>mm</superscript>/<subscript>10</subscript> */
} <structname>XkbBoundsRec</structname>, *XkbBoundsPtr;
</programlisting></para>

<para><programlisting>
typedef struct _XkbShape {
    Atom              name;             /* shape’s name */
    unsigned short    num_outlines;     /* number of outlines for the shape */
    unsigned short    sz_outlines;      /* size of the outlines array */
    XkbOutlinePtr     outlines;         /* array of outlines for the shape */
    XkbOutlinePtr     approx;           /* pointer into the array to the
                                           approximating outline */
    XkbOutlinePtr     primary;          /* pointer into the array to the
                                           primary outline */
    XkbBoundsRec      bounds;           /* bounding box for the shape;
                                           encompasses all outlines */
} <structname>XkbShapeRec</structname>, *XkbShapePtr;
</programlisting></para>

<para>
If
<structfield>approx</structfield>
and/or
<structfield>primary</structfield>
is
<symbol>NULL</symbol>,
the default value is used. The default primary outline is the first element
in the outlines array, as is the default approximating outline.
</para>

<para><programlisting>
typedef struct _XkbKey {           /* key in a row */
    XkbKeyNameRec    name;         /* key name */
    short            gap;          /* gap in <superscript>mm</superscript>/<subscript>10</subscript> from previous key in row */
    unsigned char    shape_ndx;    /* index of shape for key */
    unsigned char    color_ndx;    /* index of color for key body */
} <structname>XkbKeyRec</structname>, *XkbKeyPtr;
</programlisting></para>

<para><programlisting>
typedef struct _XkbRow {           /* row in a section */
    short               top;       /* top coordinate of row origin,
                                      relative to section’s origin */
    short               left;      /* left coordinate of row origin,
                                      relative to section’s origin */
    unsigned short      num_keys;  /* number of keys in the keys array */
    unsigned short      sz_keys;   /* size of the keys array */
    int                 vertical;  /* <symbol>True</symbol> &rArr;vertical row,
                                      <symbol>False</symbol> &rArr;horizontal row */
    XkbKeyPtr           keys;      /* array of keys in the row */
    XkbBoundsRec        bounds;    /* bounding box for the row */
} <structname>XkbRowRec</structname>, *XkbRowPtr;
</programlisting></para>

<para>
<structfield>top</structfield>
and
<structfield>left</structfield>
are in
<superscript>mm</superscript>/<subscript>10</subscript>.
</para>

<para><programlisting>
typedef struct _XkbOverlayRec {
    Atom              name;           /* overlay name */
    XkbSectionPtr     section_under;  /* the section under this overlay */
    unsigned short    num_rows;       /* number of rows in the rows array */
    unsigned short    sz_rows;        /* size of the rows array */
    XkbOverlayRowPtr  rows;           /* array of rows in the overlay */
    XkbBoundsPtr      bounds;         /* bounding box for the overlay */
} <structname>XkbOverlayRec</structname>, *XkbOverlayPtr;
</programlisting></para>

<para><programlisting>
typedef struct _XkbOverlayRow {
    unsigned short      row_under;    /* index into the row under this
                                         overlay row */
    unsigned short      num_keys;     /* number of keys in the keys array */
    unsigned short      sz_keys;      /* size of the keys array */
    XkbOverlayKeyPtr    keys;         /* array of keys in the overlay row */
} <structname>XkbOverlayRowRec</structname>, *XkbOverlayRowPtr;
</programlisting></para>

<para>
<structfield>row_under</structfield>
is an index into the array of
<structfield>rows</structfield>
in the section under this overlay. The section under this overlay row is the
one pointed to by
<structfield>section_under</structfield>
in this overlay row’s
<structname>XkbOverlayRec</structname>.
</para>

<para><programlisting>
typedef struct _XkbOverlayKey {
    XkbKeyNameRec      over;      /* name of this overlay key */
    XkbKeyNameRec      under;     /* name of the key under this overlay key */
} <structname>XkbOverlayKeyRec</structname>, *XkbOverlayKeyPtr;
</programlisting></para>

<para><programlisting>
typedef struct _XkbSection {
    Atom            name;          /* section name */
    unsigned char   priority;      /* drawing priority, 0&rArr;highest, 255&rArr;lowest */
    short           top;           /* top coordinate of section origin */
    short           left;          /* left coordinate of row origin */
    unsigned short  width;         /* section width, in <superscript>mm</superscript>/<subscript>10</subscript> */
    unsigned short  height;        /* section height, in <superscript>mm</superscript>/<subscript>10</subscript> */
    short           angle;         /* angle of section rotation,
                                      counterclockwise */
    unsigned short  num_rows;      /* number of rows in the rows array */
    unsigned short  num_doodads;   /* number of doodads in the doodads array */
    unsigned short  num_overlays;  /* number of overlays in the overlays array */
    unsigned short  sz_rows;       /* size of the rows array */
    unsigned short  sz_doodads;    /* size of the doodads array */
    unsigned short  sz_overlays;   /* size of the overlays array */
    XkbRowPtr       rows;          /* section rows array */
    XkbDoodadPtr    doodads;       /* section doodads array */
    XkbBoundsRec    bounds;        /* bounding box for the section,
                                      before rotation */
    XkbOverlayPtr   overlays;      /* section overlays array */
} <structname>XkbSectionRec</structname>, *XkbSectionPtr;
</programlisting></para>

<para>
<structfield>top</structfield>
and
<structfield>left</structfield>
are the origin of the section, relative to the origin of the keyboard, in
<superscript>mm</superscript>/<subscript>10</subscript>.
<structfield>angle</structfield>
is in
<superscript>1</superscript>/<subscript>10</subscript>
degrees.
</para>

<sect2 id='DoodadRec_Structures'>
<title>DoodadRec Structures</title>

<para>
The doodad arrays in the
<structname>XkbGeometryRec</structname>
and the
<structname>XkbSectionRec</structname>
may contain any of the doodad structures and types shown in
<link linkend="table13.1">Table 13.1</link>.
</para>


<para>
The doodad structures form a union:
</para>

<para><programlisting>
typedef union _XkbDoodad {
      XkbAnyDoodadRec        any;
      XkbShapeDoodadRec      shape;
      XkbTextDoodadRec       text;
      XkbIndicatorDoodadRec  indicator;
      XkbLogoDoodadRec       logo;
} <structname>XkbDoodadRec</structname>, *XkbDoodadPtr;
</programlisting></para>

<para>
The
<structfield>top</structfield>
and
<structfield>left</structfield>
coordinates of each doodad are the coordinates of the origin of the doodad
relative to the keyboard’s origin if the doodad is in the
<structname>XkbGeometryRec</structname>
doodad array, and with respect to the section’s origin if the doodad is in a
<structname>XkbSectionRec</structname>
doodad array. The
<structfield>color_ndx</structfield>
or
<structfield>on_color_ndx</structfield>
and
<structfield>off_color_ndx</structfield>
fields are color indices into the
<structname>XkbGeometryRec</structname>’s
color array and are the colors to draw the doodads with. Similarly, the
<structfield>shape_ndx</structfield>
fields are indices into the
<structname>XkbGeometryRec</structname>’s
shape array.
</para>

<para><programlisting>
typedef struct _XkbShapeDoodad {
    Atom             name;         /* doodad name */
    unsigned char    type;         /* <symbol>XkbOutlineDoodad</symbol>
                                      or <symbol>XkbSolidDoodad</symbol> */
    unsigned char    priority;     /* drawing priority,
                                       0&rArr;highest, 255&rArr;lowest */
    short            top;          /* top coordinate, in <superscript>mm</superscript>/<subscript>10</subscript> */
    short            left;         /* left coordinate, in <superscript>mm</superscript>/<subscript>10</subscript> */
    short            angle;        /* angle of rotation, clockwise,
                                      in <superscript>1</superscript>/<subscript>10</subscript> degrees */
    unsigned short   color_ndx;    /* doodad color */
    unsigned short   shape_ndx;    /* doodad shape */
} <structname>XkbShapeDoodadRec</structname>, *XkbShapeDoodadPtr;
</programlisting></para>

<para><programlisting>
typedef struct _XkbTextDoodad {
    Atom             name;         /* doodad name */
    unsigned char    type;         /* <symbol>XkbTextDoodad</symbol> */
    unsigned char    priority;     /* drawing priority,
                                     0&rArr;highest, 255&rArr;lowest */
    short            top;          /* top coordinate, in <superscript>mm</superscript>/<subscript>10</subscript> */
    short            left;         /* left coordinate, in <superscript>mm</superscript>/<subscript>10</subscript> */
    short            angle;        /* angle of rotation, clockwise,
                                      in <superscript>1</superscript>/<subscript>10</subscript> degrees */
    short            width;        /* width in <superscript>mm</superscript>/<subscript>10</subscript> */
    short            height;       /* height in <superscript>mm</superscript>/<subscript>10</subscript> */
    unsigned short   color_ndx;    /* doodad color */
    char *           text;         /* doodad text */
    char *           font;         /* arbitrary font name for doodad text */
} <structname>XkbTextDoodadRec</structname>, *XkbTextDoodadPtr;
</programlisting></para>

<para><programlisting>
typedef struct _XkbIndicatorDoodad {
    Atom             name;         /* doodad name */
    unsigned char    type;         /* <symbol>XkbIndicatorDoodad</symbol> */
    unsigned char    priority;     /* drawing priority, 0&rArr;highest, 255&rArr;lowest */
    short            top;          /* top coordinate, in <superscript>mm</superscript>/<subscript>10</subscript> */
    short            left;         /* left coordinate, in <superscript>mm</superscript>/<subscript>10</subscript> */
    short            angle;        /* angle of rotation, clockwise,
                                      in <superscript>1</superscript>/<subscript>10</subscript> degrees */
    unsigned short   shape_ndx;    /* doodad shape */
    unsigned short   on_color_ndx; /* color for doodad if indicator is on */
    unsigned short   off_color_ndx;/* color for doodad if indicator is off */
} <structname>XkbIndicatorDoodadRec</structname>, *XkbIndicatorDoodadPtr;
</programlisting></para>

<para><programlisting>
typedef struct _XkbLogoDoodad {
    Atom             name;         /* doodad name */
    unsigned char    type;         /* <symbol>XkbLogoDoodad</symbol> */
    unsigned char    priority;     /* drawing priority, 0&rArr;highest, 255&rArr;lowest */
    short            top;          /* top coordinate, in <superscript>mm</superscript>/<subscript>10</subscript> */
    short            left;         /* left coordinate, in <superscript>mm</superscript>/<subscript>10</subscript> */
    short            angle;        /* angle of rotation, clockwise,
                                      in <superscript>1</superscript>/<subscript>10</subscript> degrees */
    unsigned short   color_ndx;    /* doodad color */
    unsigned short   shape_ndx;    /* doodad shape */
    char *           logo_name;    /* text for logo */
} <structname>XkbLogoDoodadRec</structname>, *XkbLogoDoodadPtr
</programlisting></para>

</sect2>
</sect1>
<sect1 id='Getting_Keyboard_Geometry_From_the_Server'>
<title>Getting Keyboard Geometry From the Server</title>

<para>
You can load a keyboard geometry as part of the keyboard description returned
by
<function>XkbGetKeyboard</function>.
However, if a keyboard description has been previously loaded, you can
instead obtain the geometry by calling the
<function>XkbGetGeometry</function>.
In this case, the geometry returned is the one associated with the keyboard
whose device ID is contained in the keyboard description.
</para>

<para>
To load a keyboard geometry if you already have the keyboard description, use
<function>XkbGetGeometry</function>.
</para>

<indexterm significance="preferred" zone="XkbGetGeometry"><primary><function>XkbGetGeometry</function></primary></indexterm>
<funcsynopsis id="XkbGetGeometry">
  <funcprototype>
    <funcdef>Status <function>XkbGetGeometry</function></funcdef>
<!-- (
<parameter>dpy</parameter>,
<parameter>xkb</parameter>
) -->

    <paramdef>Display *<parameter>dpy</parameter></paramdef>
    <paramdef>XkbDescPtr <parameter>xkb</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>dpy</parameter>
    </term>
    <listitem>
      <para>
        connection to the X server
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>xkb</parameter>
    </term>
    <listitem>
      <para>
        keyboard description that contains the ID for the keyboard and into
        which the geometry should be loaded
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbGetGeometry</function>
can return
<errorname>BadValue</errorname>,
<errorname>BadImplementation</errorname>,
<errorname>BadName</errorname>,
<errorname>BadAlloc</errorname>,
or
<errorname>BadLength</errorname>
errors or
<symbol>Success</symbol>
if it succeeds.
</para>

<para>
It is also possible to load a keyboard geometry by name. The X server maintains
a database of keyboard components (see <xref linkend="Server_Database_of_Keyboard_Components" />). To load a keyboard geometry
description from this database by name, use
<function>XkbGetNamedGeometry</function>.
</para>

<indexterm significance="preferred" zone="XkbGetNamedGeometry"><primary><function>XkbGetNamedGeometry</function></primary></indexterm>
<funcsynopsis id="XkbGetNamedGeometry">
  <funcprototype>
    <funcdef>Status <function>XkbGetNamedGeometry</function></funcdef>
<!-- (
<parameter>dpy</parameter>,
<parameter>xkb</parameter>,
<parameter>name</parameter>
) -->

    <paramdef>Display *<parameter>dpy</parameter></paramdef>
    <paramdef>XkbDescPtr <parameter>xkb</parameter></paramdef>
    <paramdef>Atom <parameter>name</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>dpy</parameter>
    </term>
    <listitem>
      <para>
        connection to the X server
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>xkb</parameter>
    </term>
    <listitem>
      <para>
        keyboard description into which the geometry should be loaded
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>name</parameter>
    </term>
    <listitem>
      <para>
        name of the geometry to be loaded
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbGetNamedGeometry</function>
can return
<errorname>BadName</errorname>
if the
<parameter>name</parameter>
cannot be found.
</para>

</sect1>
<sect1 id='Using_Keyboard_Geometry'>
<title>Using Keyboard Geometry</title>

<para>
Xkb provides a number of convenience functions to help use a keyboard geometry.
These include functions to return the bounding box of a shape’s top surface
and to update the bounding box of a shape row or section.
</para>

<para>
A shape is made up of a number of outlines. Each outline is a polygon made up
of a number of points. The bounding box of a shape is a rectangle that contains
all the outlines of that shape.
</para>

<figure id='figure13.7'>
  <title>Key Surface, Shape Outlines, and Bounding Box</title>
  <mediaobject>
   <imageobject> <imagedata format="SVG" fileref="XKBlib-13.svg"/>
   </imageobject>
   </mediaobject>
</figure>


<!--
<H5 CLASS="Figure">
Key Surface, Shape Outlines, and Bounding Box</H5>
-->

<para>
To determine the bounding box of the top surface of a shape, use
<function>XkbComputeShapeTop</function>.
</para>

<indexterm significance="preferred" zone="XkbComputeShapeTop"><primary><function>XkbComputeShapeTop</function></primary></indexterm>
<funcsynopsis id="XkbComputeShapeTop">
  <funcprototype>
    <funcdef>Bool <function>XkbComputeShapeTop</function></funcdef>
<!-- (
<parameter>shape</parameter>,
<parameter>bounds_rtrn</parameter>
) -->

    <paramdef>XkbShapePtr <parameter>shape</parameter></paramdef>
    <paramdef>XkbBoundsPtr <parameter>bounds_rtrn</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>shape</parameter>
    </term>
    <listitem>
      <para>
        shape to be examined
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>bounds_rtrn</parameter>
    </term>
    <listitem>
      <para>
        backfilled with the bounding box for the shape
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbComputeShapeTop</function>
returns a
<structname>BoundsRec</structname>
that contains two x and y coordinates. These coordinates describe the corners
of a rectangle that contains the outline that describes the top surface of the
shape. The top surface is defined to be the approximating outline if the
<structfield>approx</structfield>
field of
<parameter>shape</parameter>
is not
<symbol>NULL</symbol>.
If
<structfield>approx</structfield>
is
<symbol>NULL</symbol>,
the top surface is defined as the last outline in the
<parameter>shape</parameter>’s
array of outlines.
<function>XkbComputeShapeTop</function>
returns
<symbol>False</symbol>
if
<parameter>shape</parameter>
is
<symbol>NULL</symbol>
or if there are no outlines for the shape; otherwise, it returns
<symbol>True</symbol>.
</para>


<para>
A
<structname>ShapeRec</structname>
contains a
<structname>BoundsRec</structname>
that describes the bounds of the shape. If you add or delete an outline to or
from a shape, the bounding box must be updated. To update the bounding box of a
shape, use <function>XkbComputeShapeBounds</function>.
</para>


<indexterm significance="preferred" zone="XkbComputeShapeBounds"><primary><function>XkbComputeShapeBounds</function></primary></indexterm>
<funcsynopsis id="XkbComputeShapeBounds">
  <funcprototype>
    <funcdef>Bool <function>XkbComputeShapeBounds</function></funcdef>
<!-- (
<parameter>shape</parameter>
) -->

    <paramdef>XkbShapePtr <parameter>shape</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>shape</parameter>
    </term>
    <listitem>
      <para>
        shape to be examined
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbComputeShapeBounds</function>
updates the
<structname>BoundsRec</structname>
contained in the
<parameter>shape</parameter>
by examining all the outlines of the shape and setting the
<structname>BoundsRec</structname>
to the minimum x and minimum y, and maximum x and maximum y values found in
those outlines.
<function>XkbComputeShapeBounds</function>
returns
<symbol>False</symbol>
if
<parameter>shape</parameter>
is
<symbol>NULL</symbol>
or if there are no outlines for the shape; otherwise, it returns
<symbol>True</symbol>.
</para>

<para>
If you add or delete a key to or from a row, or if you update the shape of one
of the keys in that row, you may need to update the bounding box of that row.
To update the bounding box of a row, use <function>XkbComputeRowBounds</function>.
</para>

<indexterm significance="preferred" zone="XkbComputeRowBounds"><primary><function>XkbComputeRowBounds</function></primary></indexterm>
<funcsynopsis id="XkbComputeRowBounds">
  <funcprototype>
    <funcdef>Bool <function>XkbComputeRowBounds</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>section</parameter>,
<parameter>row</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>XkbSectionPtr <parameter>section</parameter></paramdef>
    <paramdef>XkbRowPtr <parameter>row</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry that contains the <parameter>section</parameter>
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>section</parameter>
    </term>
    <listitem>
      <para>
        section that contains the row
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>row</parameter>
    </term>
    <listitem>
      <para>
        row to be examined and updated
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbComputeRowBounds</function>
checks the bounds of all keys in the
<parameter>row</parameter>
and updates the bounding box of the row if necessary.
<function>XkbComputeRowBounds</function>
returns
<symbol>False</symbol>
if any of the arguments is
<symbol>NULL</symbol>;
otherwise, it returns
<symbol>True</symbol>.
</para>

<para>
If you add or delete a row to or from a section, or if you change the geometry
of any of the rows in that section, you may need to update the bounding box for
that section. To update the bounding box of a section, use
<function>XkbComputeSectionBounds</function>.
</para>

<indexterm significance="preferred" zone="XkbComputeSectionBounds"><primary><function>XkbComputeSectionBounds</function></primary></indexterm>
<funcsynopsis id="XkbComputeSectionBounds">
  <funcprototype>
    <funcdef>Bool <function>XkbComputeSectionBounds</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>section</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>XkbSectionPtr <parameter>section</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry that contains the <parameter>section</parameter>
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>section</parameter>
    </term>
    <listitem>
      <para>
        section to be examined and updated
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbComputeSectionBounds</function>
examines all the rows of the
<parameter>section</parameter>
and updates the bounding box of that section so that it contains all rows.
<function>XkbComputeSectionBounds</function>
returns
<symbol>False</symbol>
if any of the arguments is
<symbol>NULL</symbol>;
otherwise, it returns
<symbol>True</symbol>.
</para>

<para>
Keys that can generate multiple keycodes may be associated with multiple names.
Such keys have a primary name and an alternate name. To find the alternate name
by using the primary name for a key that is part of an overlay, use
<function>XkbFindOverlayForKey</function>.
</para>

<indexterm significance="preferred" zone="XkbFindOverlayForKey"><primary><function>XkbFindOverlayForKey</function></primary></indexterm>
<funcsynopsis id="XkbFindOverlayForKey">
  <funcprototype>
    <funcdef>char *<function>XkbFindOverlayForKey</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>section</parameter>,
<parameter>under</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>XkbSectionPtr <parameter>section</parameter></paramdef>
    <paramdef>char *<parameter>under</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry that contains the <parameter>section</parameter>
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>section</parameter>
    </term>
    <listitem>
      <para>
        section to be searched for matching keys
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>under</parameter>
    </term>
    <listitem>
      <para>
        .primary name of the key to be considered
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbFindOverlayForKey</function>
uses the primary name of the key,
<parameter>under</parameter>,
to look up the alternate name, which it returns.
</para>


</sect1>
<sect1 id='Adding_Elements_to_a_Keyboard_Geometry'>
<title>Adding Elements to a Keyboard Geometry</title>

<para>
Xkb provides functions to add a single new element to the top-level keyboard
geometry. In each case the
<structfield>num_<replaceable>*</replaceable></structfield>
fields of the corresponding structure is incremented by 1. These functions do
not change
<structfield>sz_<replaceable>*</replaceable></structfield>
unless there is no more room in the array. Some of these functions fill in the
values of the element’s structure from the arguments. For other functions,
you must explicitly write code to fill the structure’s elements.
</para>


<para>
The top-level geometry description includes a list of
<firstterm>geometry properties</firstterm>.
A geometry property associates an arbitrary string with an equally arbitrary
name. Programs that display images of keyboards can use geometry properties as
hints, but they are not interpreted by Xkb. No other geometry structures refer
to geometry properties.
</para>


<para>
To add one property to an existing keyboard geometry description, use
<function>XkbAddGeomProperty</function>.
</para>

<indexterm significance="preferred" zone="XkbAddGeomProperty"><primary><function>XkbAddGeomProperty</function></primary></indexterm>
<funcsynopsis id="XkbAddGeomProperty">
  <funcprototype>
    <funcdef>XkbPropertyPtr <function>XkbAddGeomProperty</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>name</parameter>,
<parameter>value</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>char *<parameter>name</parameter></paramdef>
    <paramdef>char *<parameter>value</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry to be updated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>name</parameter>
    </term>
    <listitem>
      <para>
        name of the new property
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>value</parameter>
    </term>
    <listitem>
      <para>
        value for the new property
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAddGeomProperty</function>
adds one property with the specified
<parameter>name</parameter>
and
<parameter>value</parameter>
to the keyboard geometry specified by geom.
<function>XkbAddGeomProperty</function>
returns
<symbol>NULL</symbol>
if any of the parameters is empty or if it was not able to allocate space for
the property. To allocate space for an arbitrary number of properties, use the
XkbAllocGeomProps function.
</para>


<para>
To add one key alias to an existing keyboard geometry description, use
<function>XkbAddGeomKeyAlias</function>.
</para>


<indexterm significance="preferred" zone="XkbAddGeomKeyAlias"><primary><function>XkbAddGeomKeyAlias</function></primary></indexterm>
<funcsynopsis id="XkbAddGeomKeyAlias">
  <funcprototype>
    <funcdef>XkbKeyAliasPtr <function>XkbAddGeomKeyAlias</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>alias, real</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>char *<parameter>alias</parameter></paramdef>
    <paramdef>char *<parameter>real</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry to be updated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>alias</parameter>
    </term>
    <listitem>
      <para>
        alias to be added
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>real</parameter>
    </term>
    <listitem>
      <para>
        real name to be bound to the new alias
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAddGeomKeyAlias</function>
adds one key alias with the value alias to the geometry geom, and associates
it with the key whose real name is real.
<function>XkbAddGeomKeyAlias</function>
returns
<symbol>NULL</symbol>
if any of the parameters is empty or if it was not able to allocate space for
the alias. To allocate space for an arbitrary number of aliases, use the
XkbAllocGeomKeyAliases function.
</para>


<para>
To add one color name to an existing keyboard geometry description, use
<function>XkbAddGeomColor</function>.
</para>


<indexterm significance="preferred" zone="XkbAddGeomColor"><primary><function>XkbAddGeomColor</function></primary></indexterm>
<funcsynopsis id="XkbAddGeomColor">
  <funcprototype>
    <funcdef>XkbColorPtr <function>XkbAddGeomColor</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>spec</parameter>,
<parameter>pixel</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>char *<parameter>spec</parameter></paramdef>
    <paramdef>unsigned int <parameter>pixel</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry to be updated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>spec</parameter>
    </term>
    <listitem>
      <para>
        color to be added
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>pixel</parameter>
    </term>
    <listitem>
      <para>
        color to be added
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAddGeomColor</function>
adds the specified color
<structfield>name</structfield>
and
<parameter>pixel</parameter>
to the specified geometry
<parameter>geom</parameter>.
The top-level geometry description includes a list of up to
<emphasis>MaxColors</emphasis>
(32)
<emphasis>color names</emphasis>.
A color
<structfield>name</structfield>
is a string whose interpretation is not specified by Xkb and neither is the
<parameter>pixel</parameter>
value’s interpretation. All other geometry data structures refer to colors
using their indices in this global list or pointers to colors in this list.
<function>XkbAddGeomColor</function>
returns
<symbol>NULL</symbol>
if any of the parameters is empty or if it was not able to allocate space for
the color. To allocate space for an arbitrary number of colors to a geometry,
use the
<function>XkbAllocGeomColors</function>
function.
</para>

<para>
To add one outline to an existing shape, use
<function>XkbAddGeomOutline</function>.
</para>

<indexterm significance="preferred" zone="XkbAddGeomOutline"><primary><function>XkbAddGeomOutline</function></primary></indexterm>
<funcsynopsis id="XkbAddGeomOutline">
  <funcprototype>
    <funcdef>XkbOutlinePtr <function>XkbAddGeomOutline</function></funcdef>
<!-- (
<parameter>shape</parameter>,
<parameter>sz_points</parameter>
) -->

    <paramdef>XkbShapePtr <parameter>shape</parameter></paramdef>
    <paramdef>int <parameter>sz_points</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>shape</parameter>
    </term>
    <listitem>
      <para>
        shape to be updated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>sz_points</parameter>
    </term>
    <listitem>
      <para>
        number of points to be reserved
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
An outline consists of an arbitrary number of points.
<function>XkbAddGeomOutline</function>
adds an outline to the specified
<parameter>shape</parameter>
by reserving
<parameter>sz_points</parameter>
points for it. The new outline is allocated and zeroed.
<function>XkbAddGeomOutline</function>
returns
<symbol>NULL</symbol>
if any of the parameters is empty or if it was not able to allocate space. To
allocate space for an arbitrary number of outlines to a shape, use
XkbAllocGeomOutlines.
</para>


<para>
To add a shape to a keyboard geometry, use
<function>XkbAddGeomShape</function>.
</para>


<indexterm significance="preferred" zone="XkbAddGeomShape"><primary><function>XkbAddGeomShape</function></primary></indexterm>
<funcsynopsis id="XkbAddGeomShape">
  <funcprototype>
    <funcdef>XkbShapePtr <function>XkbAddGeomShape</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>name</parameter>,
<parameter>sz_outlines</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>Atom <parameter>name</parameter></paramdef>
    <paramdef>int <parameter>sz_outlines</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry to be updated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>name</parameter>
    </term>
    <listitem>
      <para>
        name of the new shape
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>sz_outlines</parameter>
    </term>
    <listitem>
      <para>
        number of outlines to be reserved
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
A geometry contains an arbitrary number of shapes, each of which is made up of
an arbitrary number of outlines.
<function>XkbAddGeomShape</function>
adds a shape to a geometry
<parameter>geom</parameter>
by allocating space for
<parameter>sz_outlines</parameter>
outlines for it and giving it the name specified by name. If a shape with name
<parameter>name</parameter>
already exists in the geometry, a pointer to the existing shape is returned.
<function>XkbAddGeomShape</function>
returns
<symbol>NULL</symbol>
if any of the parameters is empty or if it was not able to allocate space. To
allocate space for an arbitrary number of geometry shapes, use
<function>XkbAllocGeomShapes</function>.
</para>


<para>
To add one key at the end of an existing row of keys, use
<function>XkbAddGeomKey</function>.
</para>


<indexterm significance="preferred" zone="XkbAddGeomKey"><primary><function>XkbAddGeomKey</function></primary></indexterm>
<funcsynopsis id="XkbAddGeomKey">
  <funcprototype>
    <funcdef>XkbKeyPtr <function>XkbAddGeomKey</function></funcdef>
<!-- (
<parameter>row</parameter>
) -->

    <paramdef>XkbRowPtr <parameter>row</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>row</parameter>
    </term>
    <listitem>
      <para>
        row to be updated
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
Keys are grouped into rows.
<function>XkbAddGeomKey</function>
adds one key to the end of the specified
<parameter>row</parameter>.
The key is allocated and zeroed.
<function>XkbAddGeomKey</function>
returns
<symbol>NULL</symbol>
if
<parameter>row</parameter>
is empty or if it was not able to allocate space for the key. To allocate
space for an arbitrary number of keys to a row, use XkbAllocGeomKeys.
</para>


<para>
To add one section to an existing keyboard geometry, use
<function>XkbAddGeomSection</function>.
</para>


<indexterm significance="preferred" zone="XkbAddGeomSection"><primary><function>XkbAddGeomSection</function></primary></indexterm>
<funcsynopsis id="XkbAddGeomSection">
  <funcprototype>
    <funcdef>XkbSectionPtr <function>XkbAddGeomSection</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>name</parameter>,
<parameter>sz_rows</parameter>,
<parameter>sz_doodads</parameter>,
<parameter>sz_overlays</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>Atom <parameter>name</parameter></paramdef>
    <paramdef>int <parameter>sz_rows</parameter></paramdef>
    <paramdef>int <parameter>sz_doodads</parameter></paramdef>
    <paramdef>int <parameter>sz_overlays</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry to be updated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>name</parameter>
    </term>
    <listitem>
      <para>
        name of the new section
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>sz_rows</parameter>
    </term>
    <listitem>
      <para>
        number of rows to reserve in the section
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>sz_doodads</parameter>
    </term>
    <listitem>
      <para>
        number of doodads to reserve in the section
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>sz_overlays</parameter>
    </term>
    <listitem>
      <para>
        number of overlays to reserve in the section
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
A keyboard geometry contains an arbitrary number of sections.
<function>XkbAddGeomSection</function>
adds one section to an existing keyboard geometry
<parameter>geom</parameter>.
The new section contains space for the number of rows, doodads, and overlays
specified by
<parameter>sz_rows</parameter>,
<parameter>sz_doodads</parameter>,
and
<parameter>sz_overlays</parameter>.
The new section is allocated and zeroed and given the name specified by
<parameter>name</parameter>.
If a section with name
<parameter>name</parameter>
already exists in the geometry, a pointer to the existing section is
returned.
<function>XkbAddGeomSection</function>
returns
<symbol>NULL</symbol>
if any of the parameters is empty or if it was not able to allocate space for
the section. To allocate space for an arbitrary number of sections to a
geometry, use XkbAllocGeomSections.
</para>


<para>
To add a row to a section, use
<function>XkbAddGeomRow</function>.
</para>


<indexterm significance="preferred" zone="XkbAddGeomRow"><primary><function>XkbAddGeomRow</function></primary></indexterm>
<funcsynopsis id="XkbAddGeomRow">
  <funcprototype>
    <funcdef>XkbRowPtr <function>XkbAddGeomRow</function></funcdef>
<!-- (
<parameter>section</parameter>,
<parameter>sz_keys</parameter>
) -->

    <paramdef>XkbSectionPtr <parameter>section</parameter></paramdef>
    <paramdef>int <parameter>sz_keys</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>section</parameter>
    </term>
    <listitem>
      <para>
        section to be updated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>sz_keys</parameter>
    </term>
    <listitem>
      <para>
        number of keys to be reserved
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
One of the components of a keyboard geometry section is one or more rows of
keys.
<function>XkbAddGeomRow</function>
adds one row to the specified
<parameter>section</parameter>.
The newly created row contains space for the number of keys specified in
<parameter>sz_keys</parameter>.
They are allocated and zeroed, but otherwise uninitialized.
<function>XkbAddGeomRow</function>
returns
<symbol>NULL</symbol>
if any of the parameters is empty or if it was not able to allocate space for
the row. To allocate space for an arbitrary number of rows to a section, use
the XkbAllocGeomRows function.
</para>


<para>
To add one doodad to a section of a keyboard geometry or to the top-level
geometry, use
<function>XkbAddGeomDoodad</function>.
</para>


<indexterm significance="preferred" zone="XkbAddGeomDoodad"><primary><function>XkbAddGeomDoodad</function></primary></indexterm>
<funcsynopsis id="XkbAddGeomDoodad">
  <funcprototype>
    <funcdef>XkbDoodadPtr <function>XkbAddGeomDoodad</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>section</parameter>,
<parameter>name</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>XkbSectionPtr <parameter>section</parameter></paramdef>
    <paramdef>Atom <parameter>name</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry to which the doodad is added
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>section</parameter>
    </term>
    <listitem>
      <para>
        section, if any, to which the doodad is added
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>name</parameter>
    </term>
    <listitem>
      <para>
        name of the new doodad
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
A
<structfield>doodad</structfield>
describes some visible aspect of the keyboard that is not a key and is not a
section.
<function>XkbAddGeomDoodad</function>
adds a doodad with name specified by name to the geometry
<parameter>geom</parameter>
if section is
<symbol>NULL</symbol>
or to the section of the geometry specified by section if
<parameter>section</parameter>
is not
<symbol>NULL</symbol>.
<function>XkbAddGeomDoodad</function>
returns
<symbol>NULL</symbol>
if any of the parameters is empty or if it was not able to allocate space for
the doodad. If there is already a doodad with the name
<parameter>name</parameter>
in the doodad array for the geometry (if
<parameter>section</parameter>
is
<symbol>NULL</symbol>)
or the section (if
<parameter>section</parameter>
is non-
<symbol>NULL</symbol>),
a pointer to that doodad is returned. To allocate space for an arbitrary
number of doodads to a section, use the XkbAllocGeomSectionDoodads function. To
allocate space for an arbitrary number of doodads to a keyboard geometry, use
the XkbAllocGeomDoodads function.
</para>


<para>
To add one overlay to a section, use
<function>XkbAddGeomOverlay</function>.
</para>


<indexterm significance="preferred" zone="XkbAddGeomOverlay"><primary><function>XkbAddGeomOverlay</function></primary></indexterm>
<funcsynopsis id="XkbAddGeomOverlay">
  <funcprototype>
    <funcdef>XkbOverlayPtr <function>XkbAddGeomOverlay</function></funcdef>
<!-- (
<parameter>section</parameter>,
<parameter>name</parameter>,
<parameter>sz_rows</parameter>
) -->

    <paramdef>XkbSectionPtr <parameter>section</parameter></paramdef>
    <paramdef>Atom <parameter>name</parameter></paramdef>
    <paramdef>int <parameter>sz_rows</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>section</parameter>
    </term>
    <listitem>
      <para>
        section to which an overlay will be added
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>name</parameter>
    </term>
    <listitem>
      <para>
        name of the overlay
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>sz_rows</parameter>
    </term>
    <listitem>
      <para>
        number of rows to reserve in the overlay
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAddGeomOverlay</function>
adds an overlay with the specified name to the specified
<parameter>section</parameter>.
The new overlay is created with space allocated for sz_rows rows. If an
overlay with name
<parameter>name</parameter>
already exists in the section, a pointer to the existing overlay is
returned.
<function>XkbAddGeomOverlay</function>
returns
<symbol>NULL</symbol>
if any of the parameters is empty or if it was not able to allocate space for
the overlay. To allocate space for an arbitrary number of overlays to a
section, use the XkbAllocGeomOverlay function.
</para>


<para>
To add a row to an existing overlay, use
<function>XkbAddGeomOverlayRow</function>.
</para>


<indexterm significance="preferred" zone="XkbAddGeomOverlayRow"><primary><function>XkbAddGeomOverlayRow</function></primary></indexterm>
<funcsynopsis id="XkbAddGeomOverlayRow">
  <funcprototype>
    <funcdef>XkbOverlayRowPtr <function>XkbAddGeomOverlayRow</function></funcdef>
<!-- (
<parameter>overlay</parameter>,
<parameter>row_under, sz_keys</parameter>
) -->

    <paramdef>XkbOverlayPtr <parameter>overlay</parameter></paramdef>
    <paramdef>XkbRowPtr <parameter>row_under</parameter></paramdef>
    <paramdef>int <parameter>sz_keys</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>overlay</parameter>
    </term>
    <listitem>
      <para>
        overlay to be updated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>row_under</parameter>
    </term>
    <listitem>
      <para>
        row to be overlayed in the section <parameter>overlay</parameter>
         overlays
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>sz_keys</parameter>
    </term>
    <listitem>
      <para>
        number of keys to reserve in the row
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAddGeomOverlayRow</function>
adds one row to the
<parameter>overlay</parameter>.
The new row contains space for
<parameter>sz_keys</parameter>
keys. If
<parameter>row_under</parameter>
specifies a row that doesn’t exist on the underlying section,
<function>XkbAddGeomOverlayRow</function>
returns
<symbol>NULL</symbol>
and doesn’t change the overlay.
<function>XkbAddGeomOverlayRow</function>
returns
<symbol>NULL</symbol>
if any of the parameters is empty or if it was not able to allocate space for
the overlay.
</para>


<para>
To add a key to an existing overlay row, use
<function>XkbAddGeomOverlayKey</function>.
</para>


<indexterm significance="preferred" zone="XkbAddGeomOverlayKey"><primary><function>XkbAddGeomOverlayKey</function></primary></indexterm>
<funcsynopsis id="XkbAddGeomOverlayKey">
  <funcprototype>
    <funcdef>XkbOverlayKeyPtr <function>XkbAddGeomOverlayKey</function></funcdef>
<!-- (
<parameter>overlay</parameter>,
<parameter>row, under</parameter>
) -->

    <paramdef>XkbOverlayPtr <parameter>overlay</parameter></paramdef>
    <paramdef>XkbRowPtr <parameter>row</parameter></paramdef>
    <paramdef>char *<parameter>under</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>overlay</parameter>
    </term>
    <listitem>
      <para>
        overlay to be updated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>row</parameter>
    </term>
    <listitem>
      <para>
        row in overlay to be updated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>under</parameter>
    </term>
    <listitem>
      <para>
        primary name of the key to be considered
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAddGeomOverlayKey</function>
adds one key to the
<parameter>row</parameter>
in the
<parameter>overlay</parameter>.
If there is no key named
<parameter>under</parameter>
in the row of the underlying section,
<function>XkbAddGeomOverlayKey</function>
returns
<symbol>NULL</symbol>.
</para>


</sect1>
<sect1 id='Allocating_and_Freeing_Geometry_Components'>
<title>Allocating and Freeing Geometry Components</title>

<para>
Xkb provides a number of functions to allocate and free subcomponents of a
keyboard geometry. Use these functions to create or modify keyboard geometries.
Note that these functions merely allocate space for the new element(s), and it
is up to you to fill in the values explicitly in your code. These allocation
functions increase
<structfield>sz_<replaceable>*</replaceable></structfield>
but never touch
<structfield>num_<replaceable>*</replaceable></structfield>
(unless there is an allocation failure, in which case they reset both
<structfield>sz_<replaceable>*</replaceable></structfield>
and
<structfield>num_<replaceable>*</replaceable></structfield>
to zero). These functions return
<symbol>Success</symbol>
if they succeed,
<errorname>BadAlloc</errorname>
if they are not able to allocate space, or
<errorname>BadValue</errorname>
if a parameter is not as expected.
</para>


<para>
To allocate space for an arbitrary number of outlines to a shape, use
XkbAllocGeomOutlines.
</para>

<indexterm significance="preferred" zone="XkbAllocGeomOutlines"><primary><function>XkbAllocGeomOutlines</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomOutlines">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomOutlines</function></funcdef>
<!-- (
<parameter>shape</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbShapePtr <parameter>shape</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>shape</parameter>
    </term>
    <listitem>
      <para>
        shape for which outlines should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new outlines required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomOutlines</function>
allocates space for
<parameter>num_needed</parameter>
outlines in the specified
<parameter>shape</parameter>.
The outlines are not initialized.
</para>


<para>
To free geometry outlines, use
<function>XkbFreeGeomOutlines</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomOutlines"><primary><function>XkbFreeGeomOutlines</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomOutlines">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomOutlines</function></funcdef>
<!-- (
<parameter>shape</parameter>,
<parameter>first</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbShapePtr <parameter>shape</parameter></paramdef>
    <paramdef>int <parameter>first</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>shape</parameter>
    </term>
    <listitem>
      <para>
        shape in which outlines should be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>first</parameter>
    </term>
    <listitem>
      <para>
        first outline to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of outlines to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all outlines are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If free_all is
<symbol>True</symbol>,
all outlines are freed regardless of the value of first or count. Otherwise,
count outlines are freed beginning with the one specified by first.
</para>


<para>
To allocate space for an arbitrary number of keys to a row, use
XkbAllocGeomKeys.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomKeys"><primary><function>XkbAllocGeomKeys</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomKeys">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomKeys</function></funcdef>
<!-- (
<parameter>row</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbRowPtr <parameter>row</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>row</parameter>
    </term>
    <listitem>
      <para>
        row to which keys should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new keys required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomKeys</function>
allocates num_needed keys and adds them to the row. No initialization of the
keys is done.
</para>


<para>
To free geometry keys, use
<function>XkbFreeGeomKeys</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomKeys"><primary><function>XkbFreeGeomKeys</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomKeys">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomKeys</function></funcdef>
<!-- (
<parameter>row</parameter>,
<parameter>first</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbRowPtr <parameter>row</parameter></paramdef>
    <paramdef>int <parameter>first</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>row</parameter>
    </term>
    <listitem>
      <para>
        row in which keys should be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>first</parameter>
    </term>
    <listitem>
      <para>
        first key to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of keys to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all keys are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If free_all is
<symbol>True</symbol>,
all keys are freed regardless of the value of first or count. Otherwise,
count keys are freed beginning with the one specified by first.
</para>


<para>
To allocate geometry properties, use
<function>XkbAllocGeomProps</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomProps"><primary><function>XkbAllocGeomProps</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomProps">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomProps</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry for which properties should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new properties required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomProps</function>
allocates space for num_needed properties and adds them to the specified
geometry
<parameter>geom</parameter>.
No initialization of the properties is done. A geometry property associates
an arbitrary string with an equally arbitrary name. Geometry properties can be
used to provide hints to programs that display images of keyboards, but they
are not interpreted by Xkb. No other geometry structures refer to geometry
properties.
</para>


<para>
To free geometry properties, use
<function>XkbFreeGeomProperties</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomProperties"><primary><function>XkbFreeGeomProperties</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomProperties">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomProperties</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>first</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>int <parameter>first</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry in which properties should be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>first</parameter>
    </term>
    <listitem>
      <para>
        first property to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of properties to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all properties are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If free_all is
<symbol>True</symbol>,
all properties are freed regardless of the value of first or count.
Otherwise, count properties are freed beginning with the one specified by first.
</para>


<para>
To allocate geometry key aliases, use
<function>XkbAllocGeomKeyAliases</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomKeyAliases"><primary><function>XkbAllocGeomKeyAliases</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomKeyAliases">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomKeyAliases</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry for which key aliases should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new key aliases required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomKeyAliases</function>
allocates space for num_needed key aliases and adds them to the specified
geometry
<parameter>geom</parameter>.
A key alias is a pair of strings that associates an alternate name for a key
with the real name for that key.
</para>


<para>
To free geometry key aliases, use
<function>XkbFreeGeomKeyAliases</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomKeyAliases"><primary><function>XkbFreeGeomKeyAliases</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomKeyAliases">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomKeyAliases</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>first</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>int <parameter>first</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry in which key aliases should be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>first</parameter>
    </term>
    <listitem>
      <para>
        first key alias to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of key aliases to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all key aliases are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If free_all is
<symbol>True</symbol>,
all aliases in the top level of the specified geometry
<parameter>geom</parameter>
are freed regardless of the value of first or count. Otherwise, count aliases
in
<parameter>geom</parameter>
are freed beginning with the one specified by first.
</para>


<para>
To allocate geometry colors, use
<function>XkbAllocGeomColors</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomColors"><primary><function>XkbAllocGeomColors</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomColors">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomColors</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry for which colors should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new colors required.
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomColors</function>
allocates space for num_needed colors and adds them to the specified geometry
<parameter>geom</parameter>.
A color name is a string whose interpretation is not specified by Xkb. All
other geometry data structures refer to colors using their indices in this
global list or pointers to colors in this list.
</para>


<para>
To free geometry colors, use
<function>XkbFreeGeomColors</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomColors"><primary><function>XkbFreeGeomColors</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomColors">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomColors</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>first</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>int <parameter>first</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry in which colors should be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>first</parameter>
    </term>
    <listitem>
      <para>
        first color to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of colors to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all colors are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If free_all is
<symbol>True</symbol>,
all colors are freed regardless of the value of first or count. Otherwise,
count colors are freed beginning with the one specified by first.
</para>


<para>
To allocate points in an outline, use
<function>XkbAllocGeomPoints</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomPoints"><primary><function>XkbAllocGeomPoints</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomPoints">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomPoints</function></funcdef>
<!-- (
<parameter>outline</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbOutlinePtr <parameter>outline</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>outline</parameter>
    </term>
    <listitem>
      <para>
        outline for which points should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new points required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomPoints</function>
allocates space for
<parameter>num_needed</parameter>
points in the specified
<parameter>outline</parameter>.
The points are not initialized.
</para>


<para>
To free points in a outline, use
<function>XkbFreeGeomPoints</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomPoints"><primary><function>XkbFreeGeomPoints</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomPoints">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomPoints</function></funcdef>
<!-- (
<parameter>outline</parameter>,
<parameter>first</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbOutlinePtr <parameter>outline</parameter></paramdef>
    <paramdef>int <parameter>first</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>outline</parameter>
    </term>
    <listitem>
      <para>
        outline in which points should be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>first</parameter>
    </term>
    <listitem>
      <para>
        first point to be freed.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of points to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all points are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If free_all is
<symbol>True</symbol>,
all points are freed regardless of the value of first and count. Otherwise,
the number of points specified by count are freed, beginning with the point
specified by first in the specified outline.
</para>


<para>
To allocate space for an arbitrary number of geometry shapes, use
<function>XkbAllocGeomShapes</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomShapes"><primary><function>XkbAllocGeomShapes</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomShapes">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomShapes</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry for which shapes should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new shapes required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomShapes</function>
allocates space for
<parameter>num_needed</parameter>
shapes in the specified geometry
<parameter>geom</parameter>.
The shapes are not initialized.
</para>


<para>
To free geometry shapes, use
<function>XkbFreeGeomShapes</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomShapes"><primary><function>XkbFreeGeomShapes</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomShapes">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomShapes</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>first</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>int <parameter>first</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry in which shapes should be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>first</parameter>
    </term>
    <listitem>
      <para>
        first shape to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of shapes to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all shapes are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If free_all is
<symbol>True</symbol>,
all shapes in the geometry are freed regardless of the values of first and
count. Otherwise, count shapes are freed, beginning with the shape specified by
first.
</para>


<para>
To allocate geometry sections, use
<function>XkbAllocGeomSections</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomSections"><primary><function>XkbAllocGeomSections</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomSections">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomSections</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry for which sections should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new sections required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomSections</function>
allocates num_needed sections and adds them to the geometry geom. No
initialization of the sections is done.
</para>


<para>
To free geometry sections, use
<function>XkbFreeGeomSections</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomSections"><primary><function>XkbFreeGeomSections</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomSections">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomSections</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>first</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>int <parameter>first</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry in which sections should be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>first</parameter>
    </term>
    <listitem>
      <para>
        first section to be freed.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of sections to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all sections are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If free_all is
<symbol>True</symbol>,
all sections are freed regardless of the value of first and count. Otherwise,
the number of sections specified by count are freed, beginning with the section
specified by first in the specified geometry.
</para>


<para>
To allocate rows in a section, use
<function>XkbAllocGeomRows</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomRows"><primary><function>XkbAllocGeomRows</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomRows">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomRows</function></funcdef>
<!-- (
<parameter>section</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbSectionPtr <parameter>section</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>section</parameter>
    </term>
    <listitem>
      <para>
        section for which rows should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new rows required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomRows</function>
allocates num_needed rows and adds them to the section. No initialization of
the rows is done.
</para>


<para>
To free rows in a section, use
<function>XkbFreeGeomRows</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomRows"><primary><function>XkbFreeGeomRows</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomRows">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomRows</function></funcdef>
<!-- (
<parameter>section</parameter>,
<parameter>first</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbSectionPtr <parameter>section</parameter></paramdef>
    <paramdef>int <parameter>first</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>section</parameter>
    </term>
    <listitem>
      <para>
        section in which rows should be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>first</parameter>
    </term>
    <listitem>
      <para>
        first row to be freed.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of rows to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all rows are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If free_all is
<symbol>True</symbol>,
all rows are freed regardless of the value of first and count. Otherwise, the
number of rows specified by count are freed, beginning with the row specified
by first in the specified section.
</para>


<para>
To allocate overlays in a section, use
<function>XkbAllocGeomOverlays</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomOverlays"><primary><function>XkbAllocGeomOverlays</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomOverlays">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomOverlays</function></funcdef>
<!-- (
<parameter>section</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbSectionPtr <parameter>section</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>section</parameter>
    </term>
    <listitem>
      <para>
        section for which overlays should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new overlays required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomRows</function>
allocates num_needed overlays and adds them to the section. No initialization
of the overlays is done.
</para>


<para>
To free rows in an section, use
<function>XkbFreeGeomOverlays</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomOverlays"><primary><function>XkbFreeGeomOverlays</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomOverlays">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomOverlays</function></funcdef>
<!-- (
<parameter>section</parameter>,
<parameter>first</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbSectionPtr <parameter>section</parameter></paramdef>
    <paramdef>int <parameter>first</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>section</parameter>
    </term>
    <listitem>
      <para>
        section in which overlays should be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>first</parameter>
    </term>
    <listitem>
      <para>
        first overlay to be freed.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of overlays to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all overlays are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If free_all is
<symbol>True</symbol>,
all overlays are freed regardless of the value of first and count. Otherwise,
the number of overlays specified by count are freed, beginning with the overlay
specified by first in the specified section.
</para>


<para>
To allocate rows in a overlay, use
<function>XkbAllocGeomOverlayRows</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomOverlayRows"><primary><function>XkbAllocGeomOverlayRows</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomOverlayRows">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomOverlayRows</function></funcdef>
<!-- (
<parameter>overlay</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbSectionPtr <parameter>overlay</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>overlay</parameter>
    </term>
    <listitem>
      <para>
        section for which rows should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new rows required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomOverlayRows</function>
allocates num_needed rows and adds them to the overlay. No initialization of
the rows is done.
</para>


<para>
To free rows in an overlay, use
<function>XkbFreeGeomOverlayRows</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomOverlayRows"><primary><function>XkbFreeGeomOverlayRows</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomOverlayRows">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomOverlayRows</function></funcdef>
<!-- (
<parameter>overlay</parameter>,
<parameter>first</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbSectionPtr <parameter>overlay</parameter></paramdef>
    <paramdef>int <parameter>first</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>overlay</parameter>
    </term>
    <listitem>
      <para>
        section in which rows should be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>first</parameter>
    </term>
    <listitem>
      <para>
        first row to be freed.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of rows to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all rows are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If free_all is
<symbol>True</symbol>,
all rows are freed regardless of the value of first and count. Otherwise, the
number of rows specified by count are freed, beginning with the row specified
by first in the specified overlay.
</para>


<para>
To allocate keys in an overlay row, use
<function>XkbAllocGeomOverlayKeys</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomOverlayKeys"><primary><function>XkbAllocGeomOverlayKeys</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomOverlayKeys">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomOverlayKeys</function></funcdef>
<!-- (
<parameter>row</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbRowPtr <parameter>row</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>row</parameter>
    </term>
    <listitem>
      <para>
        section for which rows should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new rows required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomOverlayKeys</function>
allocates num_needed keys and adds them to the row. No initialization of the
keys is done.
</para>


<para>
To free keys in an overlay row, use
<function>XkbFreeGeomOverlayKeys</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomOverlayKeys"><primary><function>XkbFreeGeomOverlayKeys</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomOverlayKeys">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomOverlayKeys</function></funcdef>
<!-- (
<parameter>row</parameter>,
<parameter>first</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbRowPtr <parameter>row</parameter></paramdef>
    <paramdef>int <parameter>first</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>row</parameter>
    </term>
    <listitem>
      <para>
        row in which keys should be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>first</parameter>
    </term>
    <listitem>
      <para>
        first key to be freed.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of keys to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all keys are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If free_all is
<symbol>True</symbol>,
all keys are freed regardless of the value of first and count. Otherwise, the
number of keys specified by count are freed, beginning with the key specified
by first in the specified row.
</para>


<para>
To allocate doodads that are global to a keyboard geometry, use
<function>XkbAllocGeomDoodads</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomDoodads"><primary><function>XkbAllocGeomDoodads</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomDoodads">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomDoodads</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry for which doodads should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new doodads required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomDoodads</function>
allocates num_needed doodads and adds them to the specified geometry
<parameter>geom</parameter>.
No initialization of the doodads is done.
</para>


<para>
To allocate doodads that are specific to a section, use
<function>XkbAllocGeomSectionDoodads</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeomSectionDoodads"><primary><function>XkbAllocGeomSectionDoodads</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeomSectionDoodads">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeomSectionDoodads</function></funcdef>
<!-- (
<parameter>section</parameter>,
<parameter>num_needed</parameter>
) -->

    <paramdef>XkbSectionPtr <parameter>section</parameter></paramdef>
    <paramdef>int <parameter>num_needed</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>section</parameter>
    </term>
    <listitem>
      <para>
        section for which doodads should be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>num_needed</parameter>
    </term>
    <listitem>
      <para>
        number of new doodads required
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeomSectionDoodads</function>
allocates num_needed doodads and adds them to the specified
<parameter>section</parameter>.
No initialization of the doodads is done.
</para>


<para>
To free geometry doodads, use
<function>XkbFreeGeomDoodads</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeomDoodads"><primary><function>XkbFreeGeomDoodads</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeomDoodads">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeomDoodads</function></funcdef>
<!-- (
<parameter>doodads</parameter>,
<parameter>count</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbDoodadPtr <parameter>doodads</parameter></paramdef>
    <paramdef>int <parameter>count</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>doodads</parameter>
    </term>
    <listitem>
      <para>
        doodads to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>count</parameter>
    </term>
    <listitem>
      <para>
        number of doodads to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; all doodads are freed
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
If
<parameter>free_all</parameter>
is
<symbol>True</symbol>,
all doodads in the array are freed, regardless of the value of count.
Otherwise, count doodads are freed.
</para>


<para>
To allocate an entire geometry, use
<function>XkbAllocGeometry</function>.
</para>


<indexterm significance="preferred" zone="XkbAllocGeometry"><primary><function>XkbAllocGeometry</function></primary></indexterm>
<funcsynopsis id="XkbAllocGeometry">
  <funcprototype>
    <funcdef>Status <function>XkbAllocGeometry</function></funcdef>
<!-- (
<parameter>xkb</parameter>,
<parameter>sizes</parameter>
) -->

    <paramdef>XkbDescPtr <parameter>xkb</parameter></paramdef>
    <paramdef>XkbGeometrySizesPtr <parameter>sizes</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>xkb</parameter>
    </term>
    <listitem>
      <para>
        keyboard description for which geometry is to be allocated
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>sizes</parameter>
    </term>
    <listitem>
      <para>
        initial sizes for all geometry components
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
<function>XkbAllocGeometry</function>
allocates a keyboard geometry and adds it to the keyboard description
specified by xkb. The keyboard description should be obtained via the
XkbGetKeyboard or XkbAllockeyboard functions. The sizes parameter specifies the
number of elements to be reserved for the subcomponents of the keyboard
geometry and can be zero or more. These subcomponents include the properties,
colors, shapes, sections, and doodads.
</para>


<para>
To free an entire geometry, use
<function>XkbFreeGeometry</function>.
</para>


<indexterm significance="preferred" zone="XkbFreeGeometry"><primary><function>XkbFreeGeometry</function></primary></indexterm>
<funcsynopsis id="XkbFreeGeometry">
  <funcprototype>
    <funcdef>void <function>XkbFreeGeometry</function></funcdef>
<!-- (
<parameter>geom</parameter>,
<parameter>which</parameter>,
<parameter>free_all</parameter>
) -->

    <paramdef>XkbGeometryPtr <parameter>geom</parameter></paramdef>
    <paramdef>unsigned int <parameter>which</parameter></paramdef>
    <paramdef>Bool <parameter>free_all</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<variablelist>
  <varlistentry>
    <term>
      <parameter>geom</parameter>
    </term>
    <listitem>
      <para>
        geometry to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>which</parameter>
    </term>
    <listitem>
      <para>
        mask of geometry components to be freed
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>
      <parameter>free_all</parameter>
    </term>
    <listitem>
      <para>
        <symbol>True</symbol> &rArr; the entire geometry is freed.
      </para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
The values of which and free_all determine how much of the specified geometry
is freed. The valid values for which are:

<programlisting>
#define      XkbGeomPropertiesMask  (1&lt;&lt;0)
#define      XkbGeomColorsMask      (1&lt;&lt;1)
#define      XkbGeomShapesMask      (1&lt;&lt;2)
#define      XkbGeomSectionsMask    (1&lt;&lt;3)
#define      XkbGeomDoodadsMask     (1&lt;&lt;4)
#define      XkbGeomAllMask         (0x1f)
</programlisting></para>

<para>
If free_all is
<symbol>True</symbol>,
the entire geometry is freed regardless of the value of which. Otherwise, the
portions of the geometry specified by which are freed.
</para>

</sect1>
</chapter>
@


1.2
log
@Upate to libX11 1.5rc1. Tested by krw@@, mpi@@, shadchin@@.
@
text
@d1 3
d31 3
a33 4
rest of the keyboard, and instead, it is rotated from horizontal by 30<emphasis>
o</emphasis>
. Rotation for a geometry object is specified in 1/10 o increments about its
origin. An example of a keyboard with rotated sections is shown in Figure 13.1.
d36 7
a42 5
<mediaobject>
 <imageobject> <imagedata format="SVG" fileref="XKBlib-7.svg"/>
 </imageobject>
<caption>Rotated Keyboard Sections</caption>
</mediaobject>
d50 3
a52 3
Some geometry components include a <emphasis>
priority</emphasis>
, which indicates the order in which overlapping objects should be drawn.
d57 6
a62 4
<para>
The keyboard geometry’s top-level description is stored in a <emphasis>
XkbGeometryRec</emphasis>
 structure. This structure contains three types of information:
d100 7
a106 8
The top-level keyboard geometry description includes a list of up to <emphasis>
MaxColors</emphasis>
 (32) <emphasis>
color names</emphasis>
. A color name is a string whose interpretation is not specified by Xkb. The
<emphasis>
XkbColorRec</emphasis>
 structure provides a field for this name as well as a pixel field. The pixel
d114 3
a116 3
The top-level keyboard geometry description includes a list of <emphasis>
geometry properties</emphasis>
. A geometry property associates an arbitrary string with an equally arbitrary
d120 3
a122 3
<emphasis>
properties</emphasis>
, consider the pause/break key on most PC keyboards: the "break" symbol is
d136 3
a138 3
The top-level keyboard geometry description includes a list of <emphasis>
key aliases</emphasis>
 (see Chapter 18). Key aliases allow the keyboard layout designer to assign
d143 5
a147 5
are stored in the <emphasis>
XkbNamesRec</emphasis>
 (<emphasis>
xkb-&gt;names</emphasis>
). Therefore, consider the key aliases defined by the geometry before
d152 3
a154 3
The top-level keyboard geometry description includes a list of <emphasis>
shapes</emphasis>
; other keyboard components refer to shapes by their index in this list. A
d156 2
a157 3
<emphasis>
outlines</emphasis>
. All points in an outline are specified relative to the origin of its
d160 5
a164 5
default the first outline, or it can be optionally specified by the <emphasis>
primary</emphasis>
 field in the <emphasis>
XkbShapeRec</emphasis>
 structure. A keyboard display application can generate a simpler but still
d166 3
a168 3
Nonrectangular keys must include a rectangular <emphasis>
approximation</emphasis>
 as one of the outlines associated with the shape. The approximation is not
d176 3
a178 3
The <emphasis>
XkbGeometryRec</emphasis>
 top-level geometry description contains the following information that
d185 3
a187 3
A <emphasis>
keyboard symbolic name</emphasis>
 of type Atom to help users identify the keyboard.
d192 5
a196 5
The <emphasis>
width</emphasis>
 and <emphasis>
height</emphasis>
 of the keyboard, in mm/10. For nonrectangular keyboards, the width and height
d202 3
a204 3
The<emphasis>
 base color</emphasis>
 of the keyboard is the predominant color on the keyboard and is used as the
d210 3
a212 3
The <emphasis>
label color</emphasis>
 is the color used to draw the labels on most of the keyboard keys.
d217 3
a219 3
The <emphasis>
label font</emphasis>
 is a string that describes the font used to draw labels on most keys; label
d227 10
a236 10
The keyboard is subdivided into named <emphasis>
sections</emphasis>
 of related keys and doodads. The sections and doodads on the keyboard are
listed in the <emphasis>
XkbGeometryRec</emphasis>
 top-level keyboard geometry description. A section is composed of keys that
are physically together and logically related. Figure 13.2 shows a keyboard
that is divided into four sections. A <emphasis>
doodad</emphasis>
 describes some visible aspect of the keyboard that is not a key and is not a
d240 7
a246 5
<mediaobject>
 <imageobject> <imagedata format="SVG" fileref="XKBlib-8.svg"/>
 </imageobject>
<caption>Keyboard with Four Sections</caption>
</mediaobject>
d257 5
a261 5
A <emphasis>
shape</emphasis>
, used to draw keyboard components and stored in a <emphasis>
XkbShapeRec</emphasis>
 structure, has:
d284 3
a286 3
If either of these pointers is <emphasis>
NULL</emphasis>
, the default primary/approximation outline is the first one in the list of
d293 5
a297 5
An <emphasis>
outline</emphasis>
, stored in a <emphasis>
XkbOutlineRec</emphasis>
 structure, is a list of one or more points that describes a single
d324 3
a326 3
A nonzero value for the <emphasis>
corner_radius</emphasis>
 field specifies that the corners of the polygon should be drawn as circles
d342 9
a350 9
shape’s list of outlines. If the <emphasis>
primary</emphasis>
 field of the <emphasis>
XkbShapeRec</emphasis>
 structure is not <emphasis>
NULL</emphasis>
, it points to the primary outline. A rectangular <emphasis>
approximation</emphasis>
 must be included for nonrectangular keys as one of the outlines associated
d361 3
a363 3
As previously noted, a keyboard is subdivided into <emphasis>
sections</emphasis>
 of related keys. Each section has its own coordinate system — if a section
d366 3
a368 3
rotation. The components that make up a section, stored in a <emphasis>
XkbSectionRec</emphasis>
, include:
d395 3
a397 3
A list of <emphasis>
rows</emphasis>
. A row is a list of horizontally or vertically adjacent keys. Horizontal rows
d400 2
a401 2
top coordinate; all keys in a vertical row share a left coordinate. Figure 13.3
shows the alpha section from the keyboard shown in Figure 13.2, divided into
d407 7
a413 5
<mediaobject>
  <imageobject> <imagedata format="SVG" fileref="XKBlib-9.svg"/>
  </imageobject>
  <caption>Rows in a Section</caption>
</mediaobject>
d424 3
a426 3
An optional list of <emphasis>
doodads</emphasis>
; any type of doodad can be enclosed within a section. Position and angle of
d434 3
a436 3
An optional <emphasis>
overlay</emphasis>
 with a name of type Atom and a list of overlay rows (described below).
d451 3
a453 3
A row description (<emphasis>
XkbRowRec</emphasis>
) consists of the coordinates of its origin relative to its enclosing section,
d460 3
a462 3
A key description (<emphasis>
XkbKeyRec</emphasis>
) consists of a key name, a shape, a key color, and a gap. The key name should
d466 2
a467 3
<emphasis>
XkbGeometryRec</emphasis>
). Keys are normally drawn immediately adjacent to one another from left to
d480 2
a481 2
is specified by Xkb is "Edges", which, if present, describes the outline of the
entire keyboard.
d486 5
a490 5
Each doodad’s origin is stored in fields named <emphasis>
left</emphasis>
 and <emphasis>
top</emphasis>
, which are the coordinates of the doodad’s origin relative to its enclosing
d496 3
a498 3
with a <emphasis>
type</emphasis>
 field, which specifies the type of doodad.
d508 8
a515 8
An <emphasis>
indicator doodad</emphasis>
 describes one of the physical keyboard indicators. Indicator doodads specify
the shape of the indicator, the indicator color when it is lit (<emphasis>
on_color</emphasis>
) and the indicator color when it is dark (<emphasis>
off_color</emphasis>
).
d520 3
a522 3
An <emphasis>
outline doodad</emphasis>
 describes some aspect of the keyboard to be drawn as one or more hollow,
d529 3
a531 3
A <emphasis>
solid doodad</emphasis>
 describes some aspect of the keyboard to be drawn as one or more filled
d538 3
a540 3
A <emphasis>
text doodad</emphasis>
 describes a text label somewhere on the keyboard. Text doodads specify the
d547 2
a548 2
A <emphasis>
logo doodad </emphasis>
d562 3
a564 3
The structures these doodads are stored in and the values of the <emphasis>
type</emphasis>
 fields are shown in Table 13.1.
d567 1
a567 1
<table frame='topbot'>
d583 2
a584 2
    <entry><emphasis>
indicator doodad</emphasis>
d586 2
a587 2
    <entry><emphasis>
XkbIndicatorDoodadRec</emphasis>
d589 2
a590 2
    <entry><emphasis>
XkbIndicatorDoodad</emphasis>
d594 2
a595 2
    <entry><emphasis>
outline doodad</emphasis>
d597 2
a598 2
    <entry><emphasis>
XkbShapeDoodadRec</emphasis>
d600 2
a601 2
    <entry><emphasis>
XkbOutlineDoodad</emphasis>
d605 2
a606 2
    <entry><emphasis>
solid doodad</emphasis>
d608 2
a609 2
    <entry><emphasis>
XkbShapeDoodadRec</emphasis>
d611 2
a612 2
    <entry><emphasis>
XkbSolidDoodad</emphasis>
d616 2
a617 2
    <entry><emphasis>
text doodad</emphasis>
d619 2
a620 2
    <entry><emphasis>
XkbTextDoodadRec</emphasis>
d622 2
a623 2
    <entry><emphasis>
XkbTextDoodad</emphasis>
d627 2
a628 2
    <entry><emphasis>
logo doodad</emphasis>
d630 2
a631 2
    <entry><emphasis>
XkbLogoDoodadRec</emphasis>
d633 2
a634 2
    <entry><emphasis>
XkbLogoDoodad</emphasis>
d646 6
a651 7
An <emphasis>
overlay row</emphasis>
 (<emphasis>
XkbOverlayRowRec</emphasis>
) contains a pointer to the row it overlays and a list of <emphasis>
overlay keys</emphasis>
.
d656 11
a666 11
Each overlay key definition (<emphasis>
XkbOverlayKeyRec</emphasis>
) indicates a key that can yield multiple keycodes and consists of a field
named <emphasis>
under</emphasis>
, which specifies the primary name of the key and a field named <emphasis>
over</emphasis>
, which specifies the name for the key when the overlay keycode is selected.
The key specified in <emphasis>
under</emphasis>
 must be a member of the section that contains the overlay key definition,
a676 1
</para>
d678 1
a678 1
<para><programlisting>
d702 7
a708 5
<mediaobject>
 <imageobject> <imagedata format="SVG" fileref="XKBlib-10.svg"/>
 </imageobject>
<caption>Xkb Geometry Data Structures</caption>
</mediaobject>
d718 7
a724 5
<mediaobject>
 <imageobject> <imagedata format="SVG" fileref="XKBlib-11.svg"/>
 </imageobject>
<caption>Xkb Geometry Data Structures (Doodads)</caption>
</mediaobject>
d735 7
a741 5
<mediaobject>
 <imageobject> <imagedata format="SVG" fileref="XKBlib-12.svg"/>
 </imageobject>
<caption>Xkb Geometry Data Structures (Overlays)</caption>
</mediaobject>
d748 34
a781 26
typedef struct _XkbGeometry {              /* top-level keyboard geometry structure */
      Atom                name;            /* keyboard name */
      unsigned short      width_mm;        /* keyboard width in <emphasis> mm</emphasis> /<emphasis> 10</emphasis> */
      unsigned short      height_mm;       /* keyboard height in <emphasis> mm</emphasis> /<emphasis> 10</emphasis> */
      char *              label_font;      /* font for key labels */
      XkbColorPtr         label_color;     /* color for key labels - pointer into colors array */
      XkbColorPtr         base_color;      /* color for basic keyboard - pointer into colors array */
      unsigned short      sz_properties;   /* size of properties array */
      unsigned short      sz_colors;       /* size of colors array */
      unsigned short      sz_shapes;       /* size of shapes array */
      unsigned short      sz_sections;     /* size of sections array */
      unsigned short      sz_doodads;      /* size of doodads array */
      unsigned short      sz_key_aliases;  /* size of key aliases array */
      unsigned short      num_properties;  /* number of properties in the properties array */
      unsigned short      num_colors;      /* number of colors in the colors array */
      unsigned short      num_shapes;      /* number of shapes in the shapes array */
      unsigned short      num_sections;    /* number of sections in the sections array */
      unsigned short      num_doodads;     /* number of doodads in the doodads array */
      unsigned short      num_key_aliases; /* number of key aliases in the key */
      XkbPropertyPtr      properties;      /* properties array */
      XkbColorPtr         colors;          /* colors array */
      XkbShapePtr         shapes;          /* shapes array */
      XkbSectionPtr       sections;        /* sections array */
      XkbDoodadPtr        doodads;         /* doodads array */
      XkbKeyAliasPtr      key_aliases;     /* key aliases array */
} <emphasis>XkbGeometryRec</emphasis>*XkbGeometryPtr;
d785 9
a793 9
The <emphasis>
doodads</emphasis>
 array is only for doodads not contained in any of the <emphasis>
sections</emphasis>
 that has its own <emphasis>
doodads</emphasis>
. The key aliases contained in the <emphasis>
key_aliases</emphasis>
 array take precedence over any defined in the keycodes component of the
d799 3
a801 3
      char *      name;            /* property name */
      char *      value;           /* property value */
} <emphasis>XkbPropertyRec</emphasis>,*XkbPropertyPtr;
d806 3
a808 3
      unsigned int      pixel;     /* color */
      char *            spec;      /* color name */
} <emphasis>XkbColorRec</emphasis>,*XkbColorPtr;
d813 3
a815 3
      char      real[XkbKeyNameLength];   /* real name of the key */
      char      alias[XkbKeyNameLength];  /* alias for the key */
} <emphasis>XkbKeyAliasRec</emphasis>,*XkbKeyAliasPtr;
d819 4
a822 4
typedef struct _XkbPoint {                /* x,y coordinates */
      short      x;
      short      y;
} <emphasis>XkbPointRec</emphasis>, *XkbPointPtr;
d827 7
a833 5
      unsigned short      num_points;     /* number of points in the outline */
      unsigned short      sz_points;      /* size of the points array */
      unsigned short      corner_radius;  /* draw corners as circles with this radius */
      XkbPointPtr         points;         /* array of points defining the outline */
} <emphasis>XkbOutlineRec</emphasis>, *XkbOutlinePtr;
d838 3
a840 5
      short      x1,y1;            /* upper left corner of the bounds,
                                      in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
       short      x2,y2;            /* lower right corner of the bounds, in
                                      <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
} <emphasis>XkbBoundsRec</emphasis>, *XkbBoundsPtr;
d845 11
a855 8
      Atom              name;           /* shape’s name */
      unsigned short    num_outlines;   /* number of outlines for the shape */
      unsigned short    sz_outlines;    /* size of the outlines array */
      XkbOutlinePtr     outlines;       /* array of outlines for the shape */
      XkbOutlinePtr     approx;         /* pointer into the array to the approximating outline */
      XkbOutlinePtr     primary;        /* pointer into the array to the primary outline */
      XkbBoundsRec      bounds;         /* bounding box for the shape; encompasses all outlines */
} <emphasis>XkbShapeRec</emphasis>, *XkbShapePtr;
d859 7
a865 7
If <emphasis>
approx</emphasis>
 and/or <emphasis>
primary</emphasis>
 is <emphasis>
NULL</emphasis>
, the default value is used. The default primary outline is the first element
d870 6
a875 6
typedef struct _XkbKey {         /* key in a row */
      XkbKeyNameRec    name;     /* key name */
      short            gap;      /* gap in <emphasis>mm</emphasis>/<emphasis>10</emphasis> from previous key in row */
      unsigned char    shape_ndx;      /* index of shape for key */
      unsigned char    color_ndx;      /* index of color for key body */
} <emphasis>XkbKeyRec</emphasis>, *XkbKeyPtr;
d879 12
a890 10
typedef struct _XkbRow {             /* row in a section */
      short               top;       /* top coordinate of row origin, relative to section’s origin */
      short               left;      /* left coordinate of row origin, relative to section’s origin */
      unsigned short      num_keys;  /* number of keys in the keys array */
      unsigned short      sz_keys;   /* size of the keys array */
      int                 vertical;  /* <emphasis>True</emphasis> =&gt;vertical row,
                                        <emphasis> False</emphasis> =&gt;horizontal row */
      XkbKeyPtr           keys;      /* array of keys in the row*/
      XkbBoundsRec        bounds;    /* bounding box for the row */
} <emphasis>XkbRowRec</emphasis>, *XkbRowPtr;
d894 5
a898 9
<emphasis>
top</emphasis>
 and <emphasis>
left</emphasis>
 are in <emphasis>
mm</emphasis>
/<emphasis>
10</emphasis>
.
d903 7
a909 7
      Atom              name;           /* overlay name */
      XkbSectionPtr     section_under;  /* the section under this overlay */
      unsigned short    num_rows;       /* number of rows in the rows array */
      unsigned short    sz_rows;        /* size of the rows array */
      XkbOverlayRowPtr  rows;           /* array of rows in the overlay */
      XkbBoundsPtr      bounds;         /* bounding box for the overlay */
} <emphasis>XkbOverlayRec</emphasis>,*XkbOverlayPtr;
d914 6
a919 5
      unsigned short      row_under;     /* index into the row under this overlay row */
      unsigned short      num_keys;      /* number of keys in the keys array */
      unsigned short      sz_keys;       /* size of the keys array */
      XkbOverlayKeyPtr    keys;          /* array of keys in the overlay row */
} <emphasis>XkbOverlayRowRec</emphasis>,*XkbOverlayRowPtr;
d923 8
a930 10
<emphasis>
row_under</emphasis>
 is an index into the array of <emphasis>
rows</emphasis>
 in the section under this overlay. The section under this overlay row is the
one pointed to by <emphasis>
section_under</emphasis>
 in this overlay row’s <emphasis>
XkbOverlayRec</emphasis>
.
d935 3
a937 3
      XkbKeyNameRec      over;      /* name of this overlay key */
      XkbKeyNameRec      under;     /* name of the key under this overlay key */
} <emphasis>XkbOverlayKeyRec</emphasis>,*XkbOverlayKeyPtr;
d942 20
a961 18
      Atom            name;          /* section name */
      unsigned char   priority;      /* drawing priority, 0=&gt;highest, 255=&gt;lowest */
      short           top;           /* top coordinate of section origin */
      short           left;          /* left coordinate of row origin */
      unsigned short  width;         /* section width, in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
      unsigned short  height;        /* section height, in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
      short           angle;         /* angle of section rotation, counterclockwise */
      unsigned short  num_rows;      /* number of rows in the rows array */
      unsigned short  num_doodads;   /* number of doodads in the doodads array */
      unsigned short  num_overlays;  /* number of overlays in the overlays array */
      unsigned short  sz_rows;       /* size of the rows array */
      unsigned short  sz_doodads;    /* size of the doodads array */
      unsigned short  sz_overlays;   /* size of the overlays array */
      XkbRowPtr       rows;          /* section rows array */
      XkbDoodadPtr    doodads;       /* section doodads array */
      XkbBoundsRec    bounds;        /* bounding box for the section, before rotation*/
      XkbOverlayPtr   overlays;      /* section overlays array */
} <emphasis>XkbSectionRec</emphasis>, *XkbSectionPtr;
d965 9
a973 16
<emphasis>
top</emphasis>
 and <emphasis>
left</emphasis>
 are the origin of the section, relative to the origin of the keyboard, in
<emphasis>
mm</emphasis>
/<emphasis>
10</emphasis>
. <emphasis>
angle</emphasis>
 is in <emphasis>
1</emphasis>
/<emphasis>
10</emphasis>
 degrees.
d980 6
a985 5
The doodad arrays in the <emphasis>
XkbGeometryRec</emphasis>
 and the <emphasis>
XkbSectionRec</emphasis>
 may contain any of the doodad structures and types shown in Table 13.1.
d995 6
a1000 6
        XkbAnyDoodadRec        any;
        XkbShapeDoodadRec      shape;
        XkbTextDoodadRec       text;
        XkbIndicatorDoodadRec  indicator;
        XkbLogoDoodadRec       logo;
} <emphasis>XkbDoodadRec</emphasis>, *XkbDoodadPtr;
d1004 22
a1025 24
The <emphasis>
top</emphasis>
 and <emphasis>
left</emphasis>
 coordinates of each doodad are the coordinates of the origin of the doodad
relative to the keyboard’s origin if the doodad is in the <emphasis>
XkbGeometryRec</emphasis>
 doodad array, and with respect to the section’s origin if the doodad is in a
<emphasis>
XkbSectionRec</emphasis>
 doodad array. The <emphasis>
color_ndx</emphasis>
 or <emphasis>
on_color_ndx</emphasis>
 and <emphasis>
off_color_ndx</emphasis>
 fields are color indices into the <emphasis>
XkbGeometryRec</emphasis>
’s color array and are the colors to draw the doodads with. Similarly, the
<emphasis>
shape_ndx</emphasis>
 fields are indices into the <emphasis>
XkbGeometryRec</emphasis>
’s shape array.
d1030 12
a1041 11
      Atom       name;                /* doodad name */
      unsigned char      type;        /* <emphasis>XkbOutlineDoodad</emphasis>
                                         or <emphasis>XkbSolidDoodad</emphasis> */
      unsigned char      priority;    /* drawing priority,
                                         0=&gt;highest, 255=&gt;lowest */
      short      top;                 /* top coordinate, in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
      short      left;                /* left coordinate, in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
      short      angle;               /* angle of rotation, clockwise, in <emphasis>1</emphasis>/<emphasis>10</emphasis> degrees */
      unsigned short      color_ndx;  /* doodad color */
      unsigned short      shape_ndx;  /* doodad shape */
} <emphasis>XkbShapeDoodadRec</emphasis>, *XkbShapeDoodadPtr;
d1046 14
a1059 13
      Atom            name;         /* doodad name */
      unsigned char   type;         /* <emphasis> XkbTextDoodad</emphasis> */
      unsigned char   priority;     /* drawing priority,
                                       0=&gt;highest, 255=&gt;lowest */
      short           top;          /* top coordinate, in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
      short           left;         /* left coordinate, in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
      short           angle;        /* angle of rotation, clockwise, in <emphasis>1</emphasis>/<emphasis>10</emphasis> degrees */
      short           width;        /* width in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
      short           height;       /* height in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
      unsigned short  color_ndx;    /* doodad color */
      char *           text;        /* doodad text */
      char *           font;        /* arbitrary font name for doodad text */
} <emphasis>XkbTextDoodadRec</emphasis>, *XkbTextDoodadPtr;
d1064 11
a1074 10
      Atom           name;          /* doodad name */
      unsigned char  type;          /* <emphasis>XkbIndicatorDoodad</emphasis> */
      unsigned char  priority;      /* drawing priority, 0=&gt;highest, 255=&gt;lowest */
      short          top;           /* top coordinate, in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
      short          left;          /* left coordinate, in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
      short          angle;         /* angle of rotation, clockwise, in <emphasis>1</emphasis>/<emphasis>10</emphasis> degrees */
      unsigned short shape_ndx;     /* doodad shape */
      unsigned short on_color_ndx;  /* color for doodad if indicator is on */
      unsigned short off_color_ndx; /* color for doodad if indicator is off */
} <emphasis>XkbIndicatorDoodadRec</emphasis>, *XkbIndicatorDoodadPtr;
d1079 11
a1089 10
      Atom               name;        /* doodad name */
      unsigned char      type;        /* <emphasis> XkbLogoDoodad</emphasis> */
      unsigned char      priority;    /* drawing priority, 0=&gt;highest, 255=&gt;lowest */
      short              top;         /* top coordinate, in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
      short              left;        /* left coordinate, in <emphasis>mm</emphasis>/<emphasis>10</emphasis> */
      short              angle;       /* angle of rotation, clockwise, in <emphasis>1</emphasis>/<emphasis>10</emphasis> degrees */
      unsigned short      color_ndx;  /* doodad color */
      unsigned short      shape_ndx;  /* doodad shape */
      char *      logo_name;          /* text for logo */
} <emphasis>XkbLogoDoodadRec</emphasis>, *XkbLogoDoodadPtr
d1099 6
a1104 6
by <emphasis>
XkbGetKeyboard</emphasis>
. However, if a keyboard description has been previously loaded, you can
instead obtain the geometry by calling the <emphasis>
XkbGetGeometry</emphasis>
. In this case, the geometry returned is the one associated with the keyboard
d1110 1
a1110 1
<emphasis>XkbGetGeometry</emphasis>.
d1113 49
a1161 51
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbGetGeometry</emphasis>
(<emphasis>
dpy</emphasis>
,<emphasis>
 xkb</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Display *            <emphasis>
dpy</emphasis>
;      /* connection to the X server */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbDescPtr      <emphasis>
      xkb</emphasis>
;      /* keyboard description that contains the ID for the keyboard and into
which the geometry should be loaded */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbGetGeometry</emphasis>
 can return <emphasis>
BadValue</emphasis>
, <emphasis>
BadImplementation</emphasis>
, <emphasis>
BadName</emphasis>
, <emphasis>
BadAlloc,</emphasis>
 or <emphasis>
BadLength</emphasis>
 errors or <emphasis>
Success</emphasis>
 if it succeeds.
d1166 60
a1225 56
a database of keyboard components (see Chapter 20). To load a keyboard geometry
description from this database by name, use <emphasis>
XkbGetNamedGeometry</emphasis>.
</para>

<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbGetNamedGeometry</emphasis>
(<emphasis>
dpy</emphasis>
,<emphasis>
 xkb</emphasis>
,<emphasis>
 name</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Display *      <emphasis>
dpy</emphasis>
;      /* connection to the X server */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbDescPtr      <emphasis>
xkb</emphasis>
;      /* keyboard description into which the geometry should be loaded */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Atom      <emphasis>
name</emphasis>
;      /* name of the geometry to be loaded */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbGetNamedGeometry</emphasis>
 can return <emphasis>
BadName</emphasis>
 if the <emphasis>
name</emphasis>
 cannot be found.
d1244 7
a1250 5
<mediaobject>
 <imageobject> <imagedata format="SVG" fileref="XKBlib-13.svg"/>
 </imageobject>
<caption>Key Surface, Shape Outlines, and Bounding Box</caption>
 </mediaobject>
d1259 2
a1260 2
To determine the bounding box of the top surface of a shape, use <emphasis>
XkbComputeShapeTop</emphasis>.
d1263 41
a1303 40
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Bool <emphasis>
XkbComputeShapeTop</emphasis>
(<emphasis>
shape</emphasis>
,<emphasis>
 bounds_rtrn</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbShapePtr      <emphasis>
      shape</emphasis>
;      /* shape to be examined */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbBoundsPtr      <emphasis>
      bounds_rtrn</emphasis>
      /* backfilled with the bounding box for the shape */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbComputeShapeTop</emphasis>
 returns a <emphasis>
BoundsRec</emphasis>
 that contains two x and y coordinates. These coordinates describe the corners
d1306 21
a1326 22
<emphasis>
approx</emphasis>
 field of <emphasis>
shape</emphasis>
 is not <emphasis>
NULL</emphasis>
. If <emphasis>
approx</emphasis>
 is <emphasis>
NULL</emphasis>
, the top surface is defined as the last outline in the <emphasis>
shape</emphasis>
’s array of outlines. <emphasis>
XkbComputeShapeTop</emphasis>
 returns <emphasis>
False</emphasis>
 if <emphasis>
shape</emphasis>
 is <emphasis>
NULL</emphasis>
 or if there are no outlines for the shape; otherwise, it returns
<emphasis>True</emphasis>.
d1331 5
a1335 5
A <emphasis>
ShapeRec</emphasis>
 contains a <emphasis>
BoundsRec</emphasis>
 that describes the bounds of the shape. If you add or delete an outline to or
d1337 1
a1337 1
shape, use <emphasis>XkbComputeShapeBounds</emphasis>.
d1341 43
a1383 46
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Bool <emphasis>
XkbComputeShapeBounds</emphasis>
(<emphasis>
shape</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbShapePtr      <emphasis>
      shape</emphasis>
;            /* shape to be examined */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbComputeShapeBounds</emphasis>
 updates the <emphasis>
BoundsRec</emphasis>
 contained in the <emphasis>
shape</emphasis>
 by examining all the outlines of the shape and setting the <emphasis>
BoundsRec</emphasis>
 to the minimum x and minimum y, and maximum x and maximum y values found in
those outlines. <emphasis>
XkbComputeShapeBounds</emphasis>
 returns <emphasis>
False</emphasis>
 if <emphasis>
shape</emphasis>
 is <emphasis>
NULL</emphasis>
 or if there are no outlines for the shape; otherwise, it returns <emphasis>
True</emphasis>
.
d1387 1
a1387 1
 If you add or delete a key to or from a row, or if you update the shape of one
d1389 1
a1389 1
To update the bounding box of a row, use <emphasis>XkbComputeRowBounds</emphasis>.
d1392 60
a1451 59
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Bool <emphasis>
XkbComputeRowBounds</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 section</emphasis>
,<emphasis>
 row</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry that contains the <emphasis>
section</emphasis>
 */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr      <emphasis>
      section</emphasis>
;      /* section that contains the row */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbRowPtr            <emphasis>
row</emphasis>
;      /* row to be examined and updated */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbComputeRowBounds</emphasis>
 checks the bounds of all keys in the <emphasis>
row </emphasis>
and updates the bounding box of the row if necessary. <emphasis>
XkbComputeRowBounds</emphasis>
 returns <emphasis>
False</emphasis>
 if any of the arguments is <emphasis>
NULL</emphasis>
; otherwise, it returns <emphasis>
True</emphasis>
.
d1455 1
a1455 1
 If you add or delete a row to or from a section, or if you change the geometry
d1458 1
a1458 1
<emphasis>XkbComputeSectionBounds</emphasis>.
d1461 48
a1508 51
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Bool <emphasis>
XkbComputeSectionBounds</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 section</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry that contains the <emphasis>
section</emphasis>
 */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr      <emphasis>
      section</emphasis>
;      /* section to be examined and updated */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbComputeSectionBounds</emphasis>
 examines all the rows of the <emphasis>
section</emphasis>
 and updates the bounding box of that section so that it contains all rows.
<emphasis>
XkbComputeSectionBounds</emphasis>
 returns <emphasis>
False</emphasis>
 if any of the arguments is <emphasis>
NULL</emphasis>
; otherwise, it returns <emphasis>
True</emphasis>
.
d1514 2
a1515 2
by using the primary name for a key that is part of an overlay, use <emphasis>
XkbFindOverlayForKey</emphasis>.
d1518 53
a1570 51
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
char * <emphasis>
XkbFindOverlayForKey</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 section</emphasis>
,<emphasis>
 under</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry that contains the <emphasis>
section</emphasis>
 */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr      <emphasis>
      section</emphasis>
;      /* section to be searched for matching keys */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
char *      <emphasis>
      under</emphasis>
.      /* primary name of the key to be considered */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbFindOverlayForKey</emphasis>
 uses the primary name of the key, <emphasis>
under</emphasis>
, to look up the alternate name, which it returns.
d1580 6
a1585 10
geometry. In each case the <emphasis>
num_ </emphasis>
<emphasis>
*</emphasis>
 fields of the corresponding structure is incremented by 1. These functions do
not change <emphasis>
sz_</emphasis>
<emphasis>
*</emphasis>
 unless there is no more room in the array. Some of these functions fill in the
d1592 3
a1594 3
The top-level geometry description includes a list of <emphasis>
geometry properties</emphasis>
. A geometry property associates an arbitrary string with an equally arbitrary
d1602 2
a1603 3
To add one property to an existing keyboard geometry description, use <emphasis>
XkbAddGeomProperty</emphasis>
.
d1606 59
a1664 57
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
XkbPropertyPtr <emphasis>
XkbAddGeomProperty</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 name</emphasis>
,<emphasis>
 value</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry to be updated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
char *      <emphasis>
      name</emphasis>
;      /* name of the new property */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
char *      <emphasis>
      value</emphasis>
;      /* value for the new property */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAddGeomProperty</emphasis>
 adds one property with the specified <emphasis>
name</emphasis>
 and <emphasis>
value</emphasis>
 to the keyboard geometry specified by geom.<emphasis>
 </emphasis>
<emphasis>
XkbAddGeomProperty</emphasis>
 returns <emphasis>
NULL</emphasis>
 if any of the parameters is empty or if it was not able to allocate space for
d1672 1
a1672 3
<emphasis>
XkbAddGeomKeyAlias</emphasis>
.
d1676 55
a1730 50
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
XkbKeyAliasPtr <emphasis>
XkbAddGeomKeyAlias</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 alias, real</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry to be updated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
char *      <emphasis>
      alias</emphasis>
;      /* alias to be added */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
char *      <emphasis>
      real</emphasis>
;      /* real name to be bound to the new alias */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAddGeomKeyAlias</emphasis>
 adds one key alias with the value alias to the geometry geom, and associates
it with the key whose real name is real. <emphasis>
XkbAddGeomKeyAlias</emphasis>
 returns <emphasis>
NULL</emphasis>
 if any of the parameters is empty or if it was not able to allocate space for
d1738 1
a1738 3
<emphasis>
XkbAddGeomColor</emphasis>
.
d1742 65
a1806 62
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
XkbColorPtr <emphasis>
XkbAddGeomColor</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 spec</emphasis>
,<emphasis>
 pixel</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry to be updated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
char *      <emphasis>
      spec</emphasis>
;      /* color to be added */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
unsigned int      <emphasis>
      pixel</emphasis>
;      /* color to be added */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAddGeomColor</emphasis>
 adds the specified color <emphasis>
name</emphasis>
 and <emphasis>
pixel</emphasis>
 to the specified geometry <emphasis>
geom</emphasis>
. The top-level geometry description includes a list of up to <emphasis>
MaxColors</emphasis>
 (32) <emphasis>
color names</emphasis>
. A color <emphasis>
name</emphasis>
 is a string whose interpretation is not specified by Xkb and neither is the
<emphasis>
pixel</emphasis>
 value’s interpretation. All other geometry data structures refer to colors
d1808 4
a1811 5
<emphasis>
XkbAddGeomColor</emphasis>
 returns <emphasis>
NULL</emphasis>
 if any of the parameters is empty or if it was not able to allocate space for
d1813 3
a1815 8
use the <emphasis>
XkbAllocGeomColors</emphasis>
 function.
</para>

<para>
To add one outline to an existing shape, use <emphasis>
XkbAddGeomOutline</emphasis>.
a1817 34
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
XkbOutlinePtr <emphasis>
XkbAddGeomOutline</emphasis>
(<emphasis>
shape</emphasis>
,<emphasis>
 sz_points</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbShapePtr      <emphasis>
      shape</emphasis>
;      /* shape to be updated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      sz_points</emphasis>
;      /* number of points to be reserved */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

d1819 52
a1870 11
An outline consists of an arbitrary number of points. <emphasis>
XkbAddGeomOutline</emphasis>
 adds an outline to the specified <emphasis>
shape</emphasis>
 by reserving <emphasis>
sz_points</emphasis>
 points for it. The new outline is allocated and zeroed. <emphasis>
XkbAddGeomOutline</emphasis>
 returns <emphasis>
NULL</emphasis>
 if any of the parameters is empty or if it was not able to allocate space. To
d1877 2
a1878 3
To add a shape to a keyboard geometry, use <emphasis>
XkbAddGeomShape</emphasis>
.
d1882 47
a1928 42
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
XkbShapePtr <emphasis>
XkbAddGeomShape</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 name</emphasis>
,<emphasis>
 sz_outlines</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry to be updated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Atom      <emphasis>
      name</emphasis>
;      /* name of the new shape */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      sz_outlines</emphasis>
;      /* number of outlines to be reserved */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>
d1932 15
a1946 18
an arbitrary number of outlines. <emphasis>
XkbAddGeomShape</emphasis>
 adds a shape to a geometry <emphasis>
geom</emphasis>
 by allocating space for <emphasis>
sz_outlines</emphasis>
 outlines for it and giving it the name specified by name. If a shape with name
<emphasis>
name</emphasis>
 already exists in the geometry, a pointer to the existing shape is returned.
<emphasis>
XkbAddGeomShape</emphasis>
 returns <emphasis>
NULL</emphasis>
 if any of the parameters is empty or if it was not able to allocate space. To
allocate space for an arbitrary number of geometry shapes, use <emphasis>
XkbAllocGeomShapes</emphasis>
.
d1951 2
a1952 3
To add one key at the end of an existing row of keys, use <emphasis>
XkbAddGeomKey</emphasis>
.
d1956 36
a1991 37
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
XkbKeyPtr <emphasis>
XkbAddGeomKey</emphasis>
(<emphasis>
row</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbRowPtr      <emphasis>
      row</emphasis>
;      /* row to be updated */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
Keys are grouped into rows. <emphasis>
XkbAddGeomKey</emphasis>
 adds one key to the end of the specified <emphasis>
row</emphasis>
. The key is allocated and zeroed. <emphasis>
XkbAddGeomKey</emphasis>
 returns <emphasis>
NULL</emphasis>
 if <emphasis>
row</emphasis>
 is empty or if it was not able to allocate space for the key. To allocate
d1997 2
a1998 3
To add one section to an existing keyboard geometry, use <emphasis>
XkbAddGeomSection</emphasis>
.
d2002 93
a2094 84
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
XkbSectionPtr <emphasis>
XkbAddGeomSection</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 name</emphasis>
,<emphasis>
 sz_rows</emphasis>
,<emphasis>
 sz_doodads</emphasis>
,<emphasis>
 sz_overlays</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry to be updated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Atom      <emphasis>
      name</emphasis>
;      /* name of the new section */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      sz_rows</emphasis>
;      /* number of rows to reserve in the section */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      sz_doodads</emphasis>
;      /* number of doodads to reserve in the section */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      sz_overlays</emphasis>
;      /* number of overlays to reserve in the section */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
A keyboard geometry contains an arbitrary number of sections. <emphasis>
XkbAddGeomSection</emphasis>
 adds one section to an existing keyboard geometry <emphasis>
geom</emphasis>
. The new section contains space for the number of rows, doodads, and overlays
specified by <emphasis>
sz_rows</emphasis>
, <emphasis>
sz_doodads</emphasis>
, and <emphasis>
sz_overlays</emphasis>
. The new section is allocated and zeroed and given the name specified by
<emphasis>
name</emphasis>
. If a section with name <emphasis>
name</emphasis>
 already exists in the geometry, a pointer to the existing section is
returned.<emphasis>
 XkbAddGeomSection</emphasis>
 returns <emphasis>
NULL</emphasis>
 if any of the parameters is empty or if it was not able to allocate space for
d2101 2
a2102 3
To add a row to a section, use <emphasis>
XkbAddGeomRow</emphasis>
.
d2106 35
a2140 33
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
XkbRowPtr <emphasis>
XkbAddGeomRow</emphasis>
(<emphasis>
section</emphasis>
,<emphasis>
 sz_keys</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr      <emphasis>
      section</emphasis>
;      /* section to be updated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int            <emphasis>
sz_keys</emphasis>
;      /* number of keys to be reserved */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>
d2144 11
a2154 12
keys. <emphasis>
XkbAddGeomRow</emphasis>
 adds one row to the specified <emphasis>
section</emphasis>
. The newly created row contains space for the number of keys specified in
<emphasis>
sz_keys</emphasis>
. They are allocated and zeroed, but otherwise uninitialized. <emphasis>
XkbAddGeomRow</emphasis>
 returns <emphasis>
NULL</emphasis>
 if any of the parameters is empty or if it was not able to allocate space for
d2162 2
a2163 3
geometry, use <emphasis>
XkbAddGeomDoodad</emphasis>
.
d2167 77
a2243 73
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
XkbDoodadPtr <emphasis>
XkbAddGeomDoodad</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 section</emphasis>
,<emphasis>
 name</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry to which the doodad is added */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr      <emphasis>
      section</emphasis>
;      /* section, if any, to which the doodad is added */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Atom      <emphasis>
      name</emphasis>
;      /* name of the new doodad */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
A <emphasis>
doodad</emphasis>
 describes some visible aspect of the keyboard that is not a key and is not a
section. <emphasis>
XkbAddGeomDoodad</emphasis>
 adds a doodad with name specified by name to the geometry <emphasis>
geom</emphasis>
 if section is <emphasis>
NULL</emphasis>
 or to the section of the geometry specified by section if <emphasis>
section</emphasis>
 is not <emphasis>
NULL</emphasis>
. <emphasis>
XkbAddGeomDoodad</emphasis>
 returns <emphasis>
NULL</emphasis>
 if any of the parameters is empty or if it was not able to allocate space for
the doodad. If there is already a doodad with the name <emphasis>
name</emphasis>
 in the doodad array for the geometry (if <emphasis>
section</emphasis>
 is <emphasis>
NULL</emphasis>
) or the section (if <emphasis>
section</emphasis>
 is non-<emphasis>
NULL</emphasis>
), a pointer to that doodad is returned. To allocate space for an arbitrary
d2251 2
a2252 3
To add one overlay to a section, use <emphasis>
XkbAddGeomOverlay</emphasis>
.
d2256 61
a2316 57
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
XkbOverlayPtr <emphasis>
XkbAddGeomOverlay</emphasis>
(<emphasis>
section</emphasis>
,<emphasis>
 name</emphasis>
,<emphasis>
 sz_rows</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr      <emphasis>
      section</emphasis>
;      /* section to which an overlay will be added */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Atom      <emphasis>
      name</emphasis>
;      /* name of the overlay */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      sz_rows</emphasis>
;      /* number of rows to reserve in the overlay */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAddGeomOverlay</emphasis>
 adds an overlay with the specified name to the specified <emphasis>
section</emphasis>
. The new overlay is created with space allocated for sz_rows rows. If an
overlay with name <emphasis>
name</emphasis>
 already exists in the section, a pointer to the existing overlay is
returned.<emphasis>
 XkbAddGeomOverlay</emphasis>
 returns <emphasis>
NULL</emphasis>
 if any of the parameters is empty or if it was not able to allocate space for
d2323 2
a2324 3
To add a row to an existing overlay, use <emphasis>
XkbAddGeomOverlayRow</emphasis>
.
d2328 68
a2395 42
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
XkbOverlayRowPtr <emphasis>
XkbAddGeomOverlayRow</emphasis>
(<emphasis>
overlay</emphasis>
,<emphasis>
 row_under, sz_keys</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbOverlayPtr      <emphasis>
      overlay</emphasis>
;      /* overlay to be updated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbRowPtr      <emphasis>
      row_under</emphasis>
;      /* row to be overlayed in the section <emphasis>
overlay</emphasis>
 overlays */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      sz_keys</emphasis>
;      /* number of keys to reserve in the row */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>
d2398 2
a2399 18
<emphasis>
XkbAddGeomOverlayRow</emphasis>
 adds one row to the <emphasis>
overlay</emphasis>
. The new row contains space for <emphasis>
sz_keys</emphasis>
 keys. If <emphasis>
row_under</emphasis>
 specifies a row that doesn’t exist on the underlying section, <emphasis>
XkbAddGeomOverlayRow</emphasis>
 returns <emphasis>
NULL</emphasis>
 and doesn’t change the overlay.<emphasis>
 XkbAddGeomOverlayRow</emphasis>
 returns <emphasis>
NULL</emphasis>
 if any of the parameters is empty or if it was not able to allocate space for
the overlay.
d2403 59
a2461 4
<para>
To add a key to an existing overlay row, use <emphasis>
XkbAddGeomOverlayKey</emphasis>
.
d2465 8
a2472 66
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
XkbOverlayKeyPtr <emphasis>
XkbAddGeomOverlayKey</emphasis>
(<emphasis>
overlay</emphasis>
,<emphasis>
 row, under</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbOverlayPtr      <emphasis>
      overlay</emphasis>
;      /* overlay to be updated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbRowPtr      <emphasis>
      row</emphasis>
;      /* row in overlay to be updated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
char *      <emphasis>
      under</emphasis>
;      /* primary name of the key to be considered */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAddGeomOverlayKey</emphasis>
 adds one key to the <emphasis>
row</emphasis>
 in the <emphasis>
overlay</emphasis>
. If there is no key named <emphasis>
under</emphasis>
 in the row of the underlying section, <emphasis>
XkbAddGeomOverlayKey</emphasis>
 returns <emphasis>
NULL</emphasis>
.
</para>


</sect1>
<sect1 id='Allocating_and_Freeing_Geometry_Components'>
<title>Allocating and Freeing Geometry Components</title>

<para>
Xkb provides a number of functions to allocate and free subcomponents of a
keyboard geometry. Use these functions to create or modify keyboard geometries.
Note that these functions merely allocate space for the new element(s), and it
d2474 15
a2488 24
functions increase <emphasis>
sz_</emphasis>
<emphasis>
*</emphasis>
 but never touch <emphasis>
num_</emphasis>
<emphasis>
*</emphasis>
 (unless there is an allocation failure, in which case they reset both
<emphasis>
sz_</emphasis>
<emphasis>
*</emphasis>
 and <emphasis>
num_</emphasis>
<emphasis>
*</emphasis>
 to zero). These functions return <emphasis>
Success</emphasis>
 if they succeed, <emphasis>
BadAlloc</emphasis>
 if they are not able to allocate space, or <emphasis>
BadValue</emphasis>
 if a parameter is not as expected.
d2497 116
a2612 110
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomOutlines</emphasis>
(<emphasis>
shape</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbShapePtr            <emphasis>
shape</emphasis>
;      /* shape for which outlines should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new outlines required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAllocGeomOutlines</emphasis>
 allocates space for <emphasis>
num_needed</emphasis>
 outlines in the specified <emphasis>
shape</emphasis>
. The outlines are not initialized.
</para>


<para>
To free geometry outlines, use <emphasis>
XkbFreeGeomOutlines</emphasis>
.
</para>


<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomOutlines</emphasis>
(<emphasis>
shape</emphasis>
,<emphasis>
 first</emphasis>
,<emphasis>
 count</emphasis>
,<emphasis>
 free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbShapePtr      <emphasis>
      shape</emphasis>
;      /* shape in which outlines should be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      first</emphasis>
;      /* first outline to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of outlines to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all outlines are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If free_all is <emphasis>
True</emphasis>
, all outlines are freed regardless of the value of first or count. Otherwise,
d2623 35
a2657 33
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomKeys</emphasis>
(<emphasis>
row</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbRowPtr      <emphasis>
      row</emphasis>
;      /* row to which keys should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new keys required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>
d2660 2
a2661 3
<emphasis>
XkbAllocGeomKeys</emphasis>
 allocates num_needed keys and adds them to the row. No initialization of the
d2667 2
a2668 3
To free geometry keys, use <emphasis>
XkbFreeGeomKeys</emphasis>
.
d2672 64
a2735 58
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomKeys</emphasis>
(<emphasis>
row</emphasis>
,<emphasis>
 first</emphasis>
,<emphasis>
 count</emphasis>
,<emphasis>
 free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbRowPtr      <emphasis>
      row</emphasis>
;      /* row in which keys should be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      first</emphasis>
;      /* first key to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of keys to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all keys are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If free_all is <emphasis>
True</emphasis>
, all keys are freed regardless of the value of first or count. Otherwise,
d2741 2
a2742 3
To allocate geometry properties, use <emphasis>
XkbAllocGeomProps</emphasis>
.
d2746 42
a2787 41
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomProps</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry for which properties should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new properties required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAllocGeomProps</emphasis>
 allocates space for num_needed properties and adds them to the specified
geometry <emphasis>
geom</emphasis>
. No initialization of the properties is done. A geometry property associates
d2796 2
a2797 3
To free geometry properties, use <emphasis>
XkbFreeGeomProperties</emphasis>
.
d2801 64
a2864 58
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomProperties</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 first</emphasis>
,<emphasis>
 count</emphasis>
,<emphasis>
 free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry in which properties should be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      first</emphasis>
;      /* first property to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of properties to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all properties are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If free_all is <emphasis>
True</emphasis>
, all properties are freed regardless of the value of first or count.
d2870 2
a2871 3
To allocate geometry key aliases, use <emphasis>
XkbAllocGeomKeyAliases</emphasis>
.
d2875 42
a2916 41
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomKeyAliases</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry for which key aliases should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new key aliases required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAllocGeomKeyAliases</emphasis>
 allocates space for num_needed key aliases and adds them to the specified
geometry <emphasis>
geom</emphasis>
. A key alias is a pair of strings that associates an alternate name for a key
d2922 2
a2923 3
To free geometry key aliases, use <emphasis>
XkbFreeGeomKeyAliases</emphasis>
.
d2927 119
a3045 114
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomKeyAliases</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 first</emphasis>
, <emphasis>
count</emphasis>
, <emphasis>
free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry in which key aliases should be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      first</emphasis>
;      /* first key alias to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of key aliases to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all key aliases are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If free_all is <emphasis>
True</emphasis>
, all aliases in the top level of the specified geometry <emphasis>
geom</emphasis>
 are freed regardless of the value of first or count. Otherwise, count aliases
in <emphasis>
geom</emphasis>
 are freed beginning with the one specified by first.
</para>


<para>
To allocate geometry colors, use <emphasis>
XkbAllocGeomColors</emphasis>
.
</para>


<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomColors</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry for which colors should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new colors required. */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAllocGeomColors</emphasis>
 allocates space for num_needed colors and adds them to the specified geometry
<emphasis>
geom</emphasis>
. A color name is a string whose interpretation is not specified by Xkb. All
d3052 2
a3053 3
To free geometry colors, use <emphasis>
XkbFreeGeomColors</emphasis>
.
d3057 64
a3120 58
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomColors</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 first</emphasis>
,<emphasis>
 count</emphasis>
,<emphasis>
 free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry in which colors should be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      first</emphasis>
;      /* first color to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of colors to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all colors are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If free_all is <emphasis>
True</emphasis>
, all colors are freed regardless of the value of first or count. Otherwise,
d3126 2
a3127 55
To allocate points in an outline, use <emphasis>
XkbAllocGeomPoints</emphasis>
.
</para>


<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomPoints</emphasis>
(<emphasis>
outline</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbOutlinePtr      <emphasis>
      outline</emphasis>
;      /* outline for which points should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new points required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAllocGeomPoints</emphasis>
 allocates space for <emphasis>
num_needed</emphasis>
 points in the specified <emphasis>
outline</emphasis>
. The points are not initialized.
</para>


<para>
To free points in a outline, use <emphasis>
XkbFreeGeomPoints</emphasis>
.
d3131 116
a3246 58
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomPoints</emphasis>
(<emphasis>
outline</emphasis>
,<emphasis>
 first</emphasis>
,<emphasis>
 count</emphasis>
,<emphasis>
 free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbOutlinePtr      <emphasis>
      outline</emphasis>
;      /* outline in which points should be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      first</emphasis>
;      /* first point to be freed. */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of points to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all points are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If free_all is <emphasis>
True</emphasis>
, all points are freed regardless of the value of first and count. Otherwise,
d3253 2
a3254 48
To allocate space for an arbitrary number of geometry shapes, use <emphasis>
XkbAllocGeomShapes</emphasis>
.
</para>


<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomShapes</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry for which shapes should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new shapes required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAllocGeomShapes</emphasis>
 allocates space for <emphasis>
num_needed</emphasis>
 shapes in the specified geometry <emphasis>
geom</emphasis>
. The shapes are not initialized.
d3258 116
a3373 65
<para>
To free geometry shapes, use <emphasis>
XkbFreeGeomShapes</emphasis>
.
</para>


<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomShapes</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 first</emphasis>
,<emphasis>
 count</emphasis>
,<emphasis>
 f ree_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry in which shapes should be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      first</emphasis>
;      /* first shape to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of shapes to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all shapes are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If free_all is <emphasis>
True</emphasis>
, all shapes in the geometry are freed regardless of the values of first and
d3380 2
a3381 3
To allocate geometry sections, use <emphasis>
XkbAllocGeomSections</emphasis>
.
d3385 35
a3419 33
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomSections</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /*geometry for which sections should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new sections required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>
d3422 2
a3423 3
<emphasis>
XkbAllocGeomSections</emphasis>
 allocates num_needed sections and adds them to the geometry geom. No
d3429 2
a3430 3
To free geometry sections, use <emphasis>
XkbFreeGeomSections</emphasis>
.
d3434 64
a3497 58
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomSections</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 first</emphasis>
,<emphasis>
 count</emphasis>
,<emphasis>
 free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry in which sections should be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      first</emphasis>
;      /* first section to be freed. */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of sections to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all sections are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If free_all is <emphasis>
True</emphasis>
, all sections are freed regardless of the value of first and count. Otherwise,
d3504 2
a3505 3
To allocate rows in a section, use <emphasis>
XkbAllocGeomRows</emphasis>
.
d3509 35
a3543 33
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomRows</emphasis>
(<emphasis>
section</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr            <emphasis>
section</emphasis>
;      /* section for which rows should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new rows required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>
d3546 2
a3547 3
<emphasis>
XkbAllocGeomRows</emphasis>
 allocates num_needed rows and adds them to the section. No initialization of
d3553 2
a3554 3
To free rows in a section, use <emphasis>
XkbFreeGeomRows</emphasis>
.
d3558 64
a3621 58
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomRows</emphasis>
(<emphasis>
section</emphasis>
,<emphasis>
 first</emphasis>
,<emphasis>
 count</emphasis>
,<emphasis>
 free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr      <emphasis>
      section</emphasis>
;      /* section in which rows should be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      first</emphasis>
;      /* first row to be freed. */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of rows to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all rows are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If free_all is <emphasis>
True</emphasis>
, all rows are freed regardless of the value of first and count. Otherwise, the
d3628 2
a3629 3
To allocate overlays in a section, use <emphasis>
XkbAllocGeomOverlays</emphasis>
.
d3633 35
a3667 33
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomOverlays</emphasis>
(<emphasis>
section</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr            <emphasis>
section</emphasis>
;      /* section for which overlays should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new overlays required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>
d3670 2
a3671 3
<emphasis>
XkbAllocGeomRows</emphasis>
 allocates num_needed overlays and adds them to the section. No initialization
d3677 2
a3678 3
To free rows in an section, use <emphasis>
XkbFreeGeomOverlays</emphasis>
.
d3682 64
a3745 58
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomOverlays</emphasis>
(<emphasis>
section</emphasis>
,<emphasis>
 first</emphasis>
,<emphasis>
 count</emphasis>
,<emphasis>
 free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr      <emphasis>
      section</emphasis>
;      /* section in which overlays should be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      first</emphasis>
;      /* first overlay to be freed. */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of overlays to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all overlays are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If free_all is <emphasis>
True</emphasis>
, all overlays are freed regardless of the value of first and count. Otherwise,
d3752 2
a3753 3
To allocate rows in a overlay, use <emphasis>
XkbAllocGeomOverlayRows</emphasis>
.
d3757 35
a3791 33
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomOverlayRows</emphasis>
(<emphasis>
overlay</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr            <emphasis>
overlay</emphasis>
;      /* section for which rows should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new rows required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>
d3794 2
a3795 3
<emphasis>
XkbAllocGeomOverlayRows</emphasis>
 allocates num_needed rows and adds them to the overlay. No initialization of
d3801 2
a3802 3
To free rows in an overlay, use <emphasis>
XkbFreeGeomOverlayRows</emphasis>
.
d3806 64
a3869 58
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomOverlayRows</emphasis>
(<emphasis>
overlay</emphasis>
,<emphasis>
 first</emphasis>
,<emphasis>
 count</emphasis>
,<emphasis>
 free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr      <emphasis>
      overlay</emphasis>
;      /* section in which rows should be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      first</emphasis>
;      /* first row to be freed. */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of rows to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all rows are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If free_all is <emphasis>
True</emphasis>
, all rows are freed regardless of the value of first and count. Otherwise, the
d3876 2
a3877 3
To allocate keys in an overlay row, use <emphasis>
XkbAllocGeomOverlayKeys</emphasis>
.
d3881 35
a3915 33
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomOverlayKeys</emphasis>
(<emphasis>
row</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbRowPtr            <emphasis>
row</emphasis>
;      /* section for which rows should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new rows required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>
d3918 2
a3919 3
<emphasis>
XkbAllocGeomOverlayKeys</emphasis>
 allocates num_needed keys and adds them to the row. No initialization of the
d3925 2
a3926 3
To free keys in an overlay row, use <emphasis>
XkbFreeGeomOverlayKeys</emphasis>
.
d3930 64
a3993 58
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomOverlayKeys</emphasis>
(<emphasis>
row</emphasis>
,<emphasis>
 first</emphasis>
,<emphasis>
 count</emphasis>
,<emphasis>
 free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbRowPtr      <emphasis>
      row</emphasis>
;      /* row in which keys should be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      first</emphasis>
;      /* first key to be freed. */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of keys to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all keys are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If free_all is <emphasis>
True</emphasis>
, all keys are freed regardless of the value of first and count. Otherwise, the
d4000 2
a4001 53
To allocate doodads that are global to a keyboard geometry, use <emphasis>
XkbAllocGeomDoodads</emphasis>
.
</para>


<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomDoodads</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry for which doodads should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new doodads required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAllocGeomDoodads</emphasis>
 allocates num_needed doodads and adds them to the specified geometry <emphasis>
geom</emphasis>
. No initialization of the doodads is done.
</para>


<para>
To allocate doodads that are specific to a section, use <emphasis>
XkbAllocGeomSectionDoodads</emphasis>
.
d4005 154
a4158 101
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeomSectionDoodads</emphasis>
(<emphasis>
section</emphasis>
,<emphasis>
 num_needed</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbSectionPtr      <emphasis>
      section</emphasis>
;      /* section for which doodads should be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      num_needed</emphasis>
;      /* number of new doodads required */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
<emphasis>
XkbAllocGeomSectionDoodads</emphasis>
 allocates num_needed doodads and adds them to the specified <emphasis>
section</emphasis>
. No initialization of the doodads is done.
</para>


<para>
To free geometry doodads, use <emphasis>
XkbFreeGeomDoodads</emphasis>
.
</para>


<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeomDoodads</emphasis>
(<emphasis>
doodads</emphasis>
,<emphasis>
 count</emphasis>
,<emphasis>
 free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbDoodadPtr      <emphasis>
      doodads</emphasis>
;      /* doodads to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
int      <emphasis>
      count</emphasis>
;      /* number of doodads to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; all doodads are freed */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
If <emphasis>
free_all</emphasis>
 is <emphasis>
True</emphasis>
, all doodads in the array are freed, regardless of the value of count.
d4164 2
a4165 3
To allocate an entire geometry, use <emphasis>
XkbAllocGeometry</emphasis>
.
d4169 35
a4203 33
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
Status <emphasis>
XkbAllocGeometry</emphasis>
(<emphasis>
xkb</emphasis>
,<emphasis>
 sizes</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbDescPtr      <emphasis>
      xkb</emphasis>
;      /* keyboard description for which geometry is to be allocated */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometrySizesPtr<emphasis>
            sizes</emphasis>
;      /* initial sizes for all geometry components */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>
d4206 2
a4207 3
<emphasis>
XkbAllocGeometry</emphasis>
 allocates a keyboard geometry and adds it to the keyboard description
d4217 2
a4218 3
To free an entire geometry, use <emphasis>
XkbFreeGeometry</emphasis>
.
d4222 47
a4268 44
<informaltable frame='none'>
<?dbfo keep-together="always" ?>
<tgroup cols='1' align='left' colsep='0' rowsep='0'>
<colspec colname='c1' colwidth='1.0*'/>
<tbody>
  <row>
    <entry role='functiondecl'>
void <emphasis>
XkbFreeGeometry</emphasis>
(<emphasis>
geom</emphasis>
,<emphasis>
 which</emphasis>
,<emphasis>
 free_all</emphasis>
)
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
XkbGeometryPtr      <emphasis>
      geom</emphasis>
;      /* geometry to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
unsigned int      <emphasis>
      which</emphasis>
;      /* mask of geometry components to be freed */
    </entry>
  </row>
  <row>
    <entry role='functionargdecl'>
Bool      <emphasis>
      free_all;</emphasis>
      /* <emphasis>
True</emphasis>
 =&gt; the entire geometry is freed. */
    </entry>
</row>
</tbody>
</tgroup>
</informaltable>
a4272 1
</para>
d4274 1
a4274 1
<para><programlisting>
d4284 3
a4286 3
If free_all is <emphasis>
True</emphasis>
, the entire geometry is freed regardless of the value of which. Otherwise, the
@


1.1
log
@Update to libx11 1.4.2. Tested by ajacoutot@@, jasper@@ krw@@, landry@@,
shadchin@@ on various architectures.
Bump major.
@
text
@d1 1
a1 1
<chapter id='keyboard_geometry'>
d247 1
a247 1
<sect1 id='shapes_and_outlines'>
d351 1
a351 1
<sect1 id='sections'>
d439 1
a439 1
<sect1 id='rows_and_keys'>
d467 1
a467 1
<sect1 id='doodads'>
d560 1
a560 1
<table frame='none'>
d562 5
a566 2
<tgroup cols='3'>
<colspec colsep='0'/>
d568 1
a568 1
<row rowsep='0'>
d575 1
a575 1
  <row rowsep='0'>
d586 1
a586 1
  <row rowsep='0'>
d597 1
a597 1
  <row rowsep='0'>
d608 1
a608 1
  <row rowsep='0'>
d619 1
a619 1
  <row rowsep='0'>
d635 1
a635 1
<sect1 id='overlay_rows_and_overlay_keys'>
d666 1
a666 1
<sect1 id='drawing_a_keyboard_representation'>
d684 1
a684 1
<sect1 id='geometry_data_structures'>
d962 1
a962 1
<sect2 id='doodadrec_structures'>
d1077 1
a1077 1
<sect1 id='getting_keyboard_geometry_from_the_server'>
d1097 3
a1099 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1101 1
a1101 1
  <row rowsep='0'>
d1112 1
a1112 1
  <row rowsep='0'>
d1119 1
a1119 1
  <row rowsep='0'>
d1157 3
a1159 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1161 1
a1161 1
  <row rowsep='0'>
d1174 1
a1174 1
  <row rowsep='0'>
d1181 1
a1181 1
  <row rowsep='0'>
d1188 1
a1188 1
  <row rowsep='0'>
d1210 1
a1210 1
<sect1 id='using_keyboard_geometry'>
d1243 3
a1245 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1247 1
a1247 1
  <row rowsep='0'>
d1258 1
a1258 1
  <row rowsep='0'>
d1265 1
a1265 1
  <row rowsep='0'>
d1321 3
a1323 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1325 1
a1325 1
  <row rowsep='0'>
d1334 1
a1334 1
  <row rowsep='0'>
d1375 3
a1377 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1379 1
a1379 1
  <row rowsep='0'>
d1392 1
a1392 1
  <row rowsep='0'>
d1401 1
a1401 1
  <row rowsep='0'>
d1408 1
a1408 1
  <row rowsep='0'>
d1443 3
a1445 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1447 1
a1447 1
  <row rowsep='0'>
d1458 1
a1458 1
  <row rowsep='0'>
d1467 1
a1467 1
  <row rowsep='0'>
d1503 3
a1505 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1507 1
a1507 1
  <row rowsep='0'>
d1520 1
a1520 1
  <row rowsep='0'>
d1529 1
a1529 1
  <row rowsep='0'>
d1536 1
a1536 1
  <row rowsep='0'>
d1557 1
a1557 1
<sect1 id='adding_elements_to_a_keyboard_geometry'>
d1594 3
a1596 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1598 1
a1598 1
  <row rowsep='0'>
d1611 1
a1611 1
  <row rowsep='0'>
d1618 1
a1618 1
  <row rowsep='0'>
d1625 1
a1625 1
  <row rowsep='0'>
d1664 3
a1666 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1668 1
a1668 1
  <row rowsep='0'>
d1679 1
a1679 1
  <row rowsep='0'>
d1686 1
a1686 1
  <row rowsep='0'>
d1693 1
a1693 1
  <row rowsep='0'>
d1727 3
a1729 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1731 1
a1731 1
  <row rowsep='0'>
d1744 1
a1744 1
  <row rowsep='0'>
d1751 1
a1751 1
  <row rowsep='0'>
d1758 1
a1758 1
  <row rowsep='0'>
d1806 3
a1808 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1810 1
a1810 1
  <row rowsep='0'>
d1821 1
a1821 1
  <row rowsep='0'>
d1828 1
a1828 1
  <row rowsep='0'>
d1864 3
a1866 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1868 1
a1868 1
  <row rowsep='0'>
d1881 1
a1881 1
  <row rowsep='0'>
d1888 1
a1888 1
  <row rowsep='0'>
d1895 1
a1895 1
  <row rowsep='0'>
d1937 3
a1939 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1941 1
a1941 1
  <row rowsep='0'>
d1950 1
a1950 1
  <row rowsep='0'>
d1985 3
a1987 2
<tgroup cols='1'>
<colspec colsep='0'/>
d1989 1
a1989 1
  <row rowsep='0'>
d2006 1
a2006 1
  <row rowsep='0'>
d2013 1
a2013 1
  <row rowsep='0'>
d2020 1
a2020 1
  <row rowsep='0'>
d2027 1
a2027 1
  <row rowsep='0'>
d2034 1
a2034 1
  <row rowsep='0'>
d2081 3
a2083 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2085 1
a2085 1
  <row rowsep='0'>
d2096 1
a2096 1
  <row rowsep='0'>
d2103 1
a2103 1
  <row rowsep='0'>
d2142 3
a2144 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2146 1
a2146 1
  <row rowsep='0'>
d2159 1
a2159 1
  <row rowsep='0'>
d2166 1
a2166 1
  <row rowsep='0'>
d2173 1
a2173 1
  <row rowsep='0'>
d2228 3
a2230 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2232 1
a2232 1
  <row rowsep='0'>
d2245 1
a2245 1
  <row rowsep='0'>
d2252 1
a2252 1
  <row rowsep='0'>
d2259 1
a2259 1
  <row rowsep='0'>
d2297 3
a2299 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2301 1
a2301 1
  <row rowsep='0'>
d2312 1
a2312 1
  <row rowsep='0'>
d2319 1
a2319 1
  <row rowsep='0'>
d2328 1
a2328 1
  <row rowsep='0'>
d2369 3
a2371 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2373 1
a2373 1
  <row rowsep='0'>
d2384 1
a2384 1
  <row rowsep='0'>
d2391 1
a2391 1
  <row rowsep='0'>
d2398 1
a2398 1
  <row rowsep='0'>
d2427 1
a2427 1
<sect1 id='allocating_and_freeing_geometry_components'>
d2468 3
a2470 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2472 1
a2472 1
  <row rowsep='0'>
d2483 1
a2483 1
  <row rowsep='0'>
d2490 1
a2490 1
  <row rowsep='0'>
d2520 3
a2522 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2524 1
a2524 1
  <row rowsep='0'>
d2539 1
a2539 1
  <row rowsep='0'>
d2546 1
a2546 1
  <row rowsep='0'>
d2553 1
a2553 1
  <row rowsep='0'>
d2560 1
a2560 1
  <row rowsep='0'>
d2588 3
a2590 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2592 1
a2592 1
  <row rowsep='0'>
d2603 1
a2603 1
  <row rowsep='0'>
d2610 1
a2610 1
  <row rowsep='0'>
d2637 3
a2639 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2641 1
a2641 1
  <row rowsep='0'>
d2656 1
a2656 1
  <row rowsep='0'>
d2663 1
a2663 1
  <row rowsep='0'>
d2670 1
a2670 1
  <row rowsep='0'>
d2677 1
a2677 1
  <row rowsep='0'>
d2706 3
a2708 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2710 1
a2710 1
  <row rowsep='0'>
d2721 1
a2721 1
  <row rowsep='0'>
d2728 1
a2728 1
  <row rowsep='0'>
d2761 3
a2763 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2765 1
a2765 1
  <row rowsep='0'>
d2780 1
a2780 1
  <row rowsep='0'>
d2787 1
a2787 1
  <row rowsep='0'>
d2794 1
a2794 1
  <row rowsep='0'>
d2801 1
a2801 1
  <row rowsep='0'>
d2830 3
a2832 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2834 1
a2834 1
  <row rowsep='0'>
d2845 1
a2845 1
  <row rowsep='0'>
d2852 1
a2852 1
  <row rowsep='0'>
d2882 3
a2884 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2886 1
a2886 1
  <row rowsep='0'>
d2901 1
a2901 1
  <row rowsep='0'>
d2908 1
a2908 1
  <row rowsep='0'>
d2915 1
a2915 1
  <row rowsep='0'>
d2922 1
a2922 1
  <row rowsep='0'>
d2955 3
a2957 2
<tgroup cols='1'>
<colspec colsep='0'/>
d2959 1
a2959 1
  <row rowsep='0'>
d2970 1
a2970 1
  <row rowsep='0'>
d2977 1
a2977 1
  <row rowsep='0'>
d3008 3
a3010 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3012 1
a3012 1
  <row rowsep='0'>
d3027 1
a3027 1
  <row rowsep='0'>
d3034 1
a3034 1
  <row rowsep='0'>
d3041 1
a3041 1
  <row rowsep='0'>
d3048 1
a3048 1
  <row rowsep='0'>
d3077 3
a3079 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3081 1
a3081 1
  <row rowsep='0'>
d3092 1
a3092 1
  <row rowsep='0'>
d3099 1
a3099 1
  <row rowsep='0'>
d3129 3
a3131 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3133 1
a3133 1
  <row rowsep='0'>
d3148 1
a3148 1
  <row rowsep='0'>
d3155 1
a3155 1
  <row rowsep='0'>
d3162 1
a3162 1
  <row rowsep='0'>
d3169 1
a3169 1
  <row rowsep='0'>
d3199 3
a3201 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3203 1
a3203 1
  <row rowsep='0'>
d3214 1
a3214 1
  <row rowsep='0'>
d3221 1
a3221 1
  <row rowsep='0'>
d3251 3
a3253 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3255 1
a3255 1
  <row rowsep='0'>
d3270 1
a3270 1
  <row rowsep='0'>
d3277 1
a3277 1
  <row rowsep='0'>
d3284 1
a3284 1
  <row rowsep='0'>
d3291 1
a3291 1
  <row rowsep='0'>
d3321 3
a3323 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3325 1
a3325 1
  <row rowsep='0'>
d3336 1
a3336 1
  <row rowsep='0'>
d3343 1
a3343 1
  <row rowsep='0'>
d3370 3
a3372 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3374 1
a3374 1
  <row rowsep='0'>
d3389 1
a3389 1
  <row rowsep='0'>
d3396 1
a3396 1
  <row rowsep='0'>
d3403 1
a3403 1
  <row rowsep='0'>
d3410 1
a3410 1
  <row rowsep='0'>
d3440 3
a3442 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3444 1
a3444 1
  <row rowsep='0'>
d3455 1
a3455 1
  <row rowsep='0'>
d3462 1
a3462 1
  <row rowsep='0'>
d3489 3
a3491 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3493 1
a3493 1
  <row rowsep='0'>
d3508 1
a3508 1
  <row rowsep='0'>
d3515 1
a3515 1
  <row rowsep='0'>
d3522 1
a3522 1
  <row rowsep='0'>
d3529 1
a3529 1
  <row rowsep='0'>
d3559 3
a3561 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3563 1
a3563 1
  <row rowsep='0'>
d3574 1
a3574 1
  <row rowsep='0'>
d3581 1
a3581 1
  <row rowsep='0'>
d3608 3
a3610 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3612 1
a3612 1
  <row rowsep='0'>
d3627 1
a3627 1
  <row rowsep='0'>
d3634 1
a3634 1
  <row rowsep='0'>
d3641 1
a3641 1
  <row rowsep='0'>
d3648 1
a3648 1
  <row rowsep='0'>
d3678 3
a3680 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3682 1
a3682 1
  <row rowsep='0'>
d3693 1
a3693 1
  <row rowsep='0'>
d3700 1
a3700 1
  <row rowsep='0'>
d3727 3
a3729 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3731 1
a3731 1
  <row rowsep='0'>
d3746 1
a3746 1
  <row rowsep='0'>
d3753 1
a3753 1
  <row rowsep='0'>
d3760 1
a3760 1
  <row rowsep='0'>
d3767 1
a3767 1
  <row rowsep='0'>
d3797 3
a3799 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3801 1
a3801 1
  <row rowsep='0'>
d3812 1
a3812 1
  <row rowsep='0'>
d3819 1
a3819 1
  <row rowsep='0'>
d3846 3
a3848 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3850 1
a3850 1
  <row rowsep='0'>
d3865 1
a3865 1
  <row rowsep='0'>
d3872 1
a3872 1
  <row rowsep='0'>
d3879 1
a3879 1
  <row rowsep='0'>
d3886 1
a3886 1
  <row rowsep='0'>
d3916 3
a3918 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3920 1
a3920 1
  <row rowsep='0'>
d3931 1
a3931 1
  <row rowsep='0'>
d3938 1
a3938 1
  <row rowsep='0'>
d3966 3
a3968 2
<tgroup cols='1'>
<colspec colsep='0'/>
d3970 1
a3970 1
  <row rowsep='0'>
d3981 1
a3981 1
  <row rowsep='0'>
d3988 1
a3988 1
  <row rowsep='0'>
d4016 3
a4018 2
<tgroup cols='1'>
<colspec colsep='0'/>
d4020 1
a4020 1
  <row rowsep='0'>
d4033 1
a4033 1
  <row rowsep='0'>
d4040 1
a4040 1
  <row rowsep='0'>
d4047 1
a4047 1
  <row rowsep='0'>
d4078 3
a4080 2
<tgroup cols='1'>
<colspec colsep='0'/>
d4082 1
a4082 1
  <row rowsep='0'>
d4093 1
a4093 1
  <row rowsep='0'>
d4100 1
a4100 1
  <row rowsep='0'>
d4131 3
a4133 2
<tgroup cols='1'>
<colspec colsep='0'/>
d4135 1
a4135 1
  <row rowsep='0'>
d4148 1
a4148 1
  <row rowsep='0'>
d4155 1
a4155 1
  <row rowsep='0'>
d4162 1
a4162 1
  <row rowsep='0'>
@

