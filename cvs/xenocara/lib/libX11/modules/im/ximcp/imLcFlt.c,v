head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.20
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.18
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.16
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.14
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.12
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_1_3:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	v1_0_99_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.03.27.19.19.37;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.30.19.19.32;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.18.19.37.32;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.12.59.09;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.16.37.02;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.16.37.02;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Upate to libX11 1.5rc1. Tested by krw@@, mpi@@, shadchin@@.
@
text
@/******************************************************************

              Copyright 1992 by Fuji Xerox Co., Ltd.
              Copyright 1992, 1994 by FUJITSU LIMITED

Permission to use, copy, modify, distribute, and sell this software
and its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear
in supporting documentation, and that the name of Fuji Xerox,
FUJITSU LIMITED not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission. Fuji Xerox, FUJITSU LIMITED make no representations
about the suitability of this software for any purpose.
It is provided "as is" without express or implied warranty.

FUJI XEROX, FUJITSU LIMITED DISCLAIM ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJI XEROX,
FUJITSU LIMITED BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.

  Author   : Kazunori Nishihara	Fuji Xerox
  Modifier : Takashi Fujiwara   FUJITSU LIMITED
                                fujiwara@@a80.tech.yk.fujitsu.co.jp

******************************************************************/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "Xlibint.h"
#include <X11/keysym.h>
#include "Xlcint.h"
#include "Ximint.h"

Bool
_XimLocalFilter(Display *d, Window w, XEvent *ev, XPointer client_data)
{
    Xic		 ic = (Xic)client_data;
    KeySym	 keysym;
    static char	 buf[256];
    static unsigned prevcode = 0, prevstate = 0;
    unsigned    currstate;
    DefTree	*b = ic->private.local.base.tree;
    DTIndex	 t;
    Bool	 braille = False, anymodifier = False;

    if(ev->xkey.keycode == 0)
	return (False);

    XLookupString((XKeyEvent *)ev, buf, sizeof(buf), &keysym, NULL);

    if(keysym >= XK_braille_dot_1 && keysym <= XK_braille_dot_8) {
	if(ev->type == KeyPress) {
	    ic->private.local.brl_pressed |=
		1<<(keysym-XK_braille_dot_1);
	    return(True);
	} else {
	    if(!ic->private.local.brl_committing
		    || ev->xkey.time - ic->private.local.brl_release_start > 300) {
	    	ic->private.local.brl_committing = ic->private.local.brl_pressed;
		ic->private.local.brl_release_start = ev->xkey.time;
	    }
	    ic->private.local.brl_pressed &= ~(1<<(keysym-XK_braille_dot_1));
	    if(!ic->private.local.brl_pressed && ic->private.local.brl_committing) {
		/* Commited a braille pattern, let it go through compose tree */
		keysym = XK_braille_blank | ic->private.local.brl_committing;
		ev->type = KeyPress;
		braille = True;
	    } else {
	        return(True);
	    }
	}
    }

    if(((Xim)ic->core.im)->private.local.top == 0 )
	goto emit_braille;

    currstate = ev->xkey.state;
    if(ev->type == KeyPress) {
	prevcode = ev->xkey.keycode;
	prevstate = currstate;

	if(IsModifierKey(keysym))
	    return(False);
	prevcode = 0;
    } else {
	if(prevcode != ev->xkey.keycode)
	    return False;

	/* For lookup, we use the state at the time when the key was pressed, */
	/* because this state was not affected by the modifier that is mapped */
	/* to the key. */
	ev->xkey.state = prevstate;
	XLookupString((XKeyEvent *)ev, buf, sizeof(buf), &keysym, NULL);
    }

    for(t = ic->private.local.context; t; t = b[t].next) {
	if(IsModifierKey(b[t].keysym))
	    anymodifier = True;
	if(((ev->xkey.state & b[t].modifier_mask) == b[t].modifier) &&
	   (keysym == b[t].keysym))
	    break;
    }

    /* Restore the state */
    ev->xkey.state = currstate;

    if(t) { /* Matched */
	if(b[t].succession) { /* Intermediate */
	    ic->private.local.context = b[t].succession;
	    return (ev->type == KeyPress);
	} else { /* Terminate (reached to leaf) */
	    ic->private.local.composed = t;
	    ic->private.local.brl_committed = 0;
	    /* return back to client KeyPressEvent keycode == 0 */
	    ev->xkey.keycode = 0;
	    ev->xkey.type = KeyPress;
	    XPutBackEvent(d, ev);
	    if(prevcode){
		/* For modifier key releases, restore the event, as we do not */
		/* filter it.  */
		ev->xkey.type = KeyRelease;
		ev->xkey.keycode = prevcode;
	    }
	    /* initialize internal state for next key sequence */
	    ic->private.local.context = ((Xim)ic->core.im)->private.local.top;
	    return (ev->type == KeyPress);
	}
    } else { /* Unmatched */
	/* Unmatched modifier key releases abort matching only in the case that */
	/* there was any modifier that would have matched */
	if((ic->private.local.context == ((Xim)ic->core.im)->private.local.top) ||
	   (ev->type == KeyRelease && !anymodifier)) {
	    goto emit_braille;
	}
	/* Error (Sequence Unmatch occured) */
	/* initialize internal state for next key sequence */
	ic->private.local.context = ((Xim)ic->core.im)->private.local.top;
	return (ev->type == KeyPress);
    }

emit_braille:
    if(braille) {
	/* Braille pattern is not in compose tree, emit alone */
	ic->private.local.brl_committed = ic->private.local.brl_committing;
	ic->private.local.composed = 0;
	ev->xkey.keycode = 0;
	_XPutBackEvent(d, ev);
	return(True);
    }
    return(False);
}
@


1.4
log
@Update to libx11 1.4.2. Tested by ajacoutot@@, jasper@@ krw@@, landry@@,
shadchin@@ on various architectures.
Bump major.
@
text
@d46 2
d50 1
a50 1
    Bool	 braille = False;
a56 3
    if(IsModifierKey(keysym))
	return (False);

d80 1
a80 2
    if(   (ev->type != KeyPress)
       || (((Xim)ic->core.im)->private.local.top == 0 ) )
d83 19
d103 2
d110 3
d116 1
a116 1
	    return(True);
d122 1
d124 6
d132 1
a132 1
	    return(True);
d135 4
a138 1
	if(ic->private.local.context == ((Xim)ic->core.im)->private.local.top) {
d144 1
a144 1
	return(True);
@


1.3
log
@Update to libX11 1.3.3. Tested on a bulk ports build by naddy@@.
@
text
@a31 1
#define NEED_EVENTS
d48 1
d62 1
d70 7
a76 9
	    if(!ic->private.local.brl_pressed) {
		if(ic->private.local.brl_committing) {
		    ic->private.local.brl_committed =
			ic->private.local.brl_committing;
		    ic->private.local.composed = 0;
		    ev->type = KeyPress;
		    ev->xkey.keycode = 0;
		    _XPutBackEvent(d, ev);
		}
a78 1
	return(True);
d83 1
a83 1
	return(False);
d107 1
a107 1
	    return(False);
d114 11
@


1.2
log
@update to libX11 1.2.1
@
text
@a0 1
/* $Xorg: imLcFlt.c,v 1.3 2000/08/17 19:45:13 cpqbld Exp $ */
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
in supporting documentation, and that the name of Fuji Xerox, 
d28 1
a28 1
  Modifier : Takashi Fujiwara   FUJITSU LIMITED 
d43 1
a43 5
_XimLocalFilter(d, w, ev, client_data)
    Display	*d;
    Window	 w;
    XEvent	*ev;
    XPointer	 client_data;
d103 1
a103 1
	    _XPutBackEvent(d, ev);
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
