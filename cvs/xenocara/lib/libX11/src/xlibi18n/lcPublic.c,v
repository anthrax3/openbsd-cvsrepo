head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.8
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.6
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.4
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.2
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.6
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_1_3:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	v1_0_99_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.04.06.20.57.59;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	L5f7tv2EiGjtzoSu;

1.5
date	2013.09.28.17.03.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.08.27.15.34.15;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.18.19.37.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.12.59.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.16.37.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.16.37.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@update to libX11 1.6.3
@
text
@/*
 * Copyright 1992, 1993 by TOSHIBA Corp.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided
 * that the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of TOSHIBA not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. TOSHIBA make no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * TOSHIBA DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * TOSHIBA BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 *
 * Author: Katsuhisa Yano	TOSHIBA Corp.
 *			   	mopi@@osa.ilab.toshiba.co.jp
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdio.h>
#include "Xlibint.h"
#include "XlcPubI.h"

static const char *
default_string(
    XLCd lcd)
{
    return XLC_PUBLIC(lcd, default_string);
}

static XLCd create (const char *name, XLCdMethods methods);
static Bool initialize (XLCd lcd);
static void destroy (XLCd lcd);
static char *get_values (XLCd lcd, XlcArgList args, int num_args);

static XLCdPublicMethodsRec publicMethods = {
    {
	destroy,
	_XlcDefaultMapModifiers,
	NULL,
	NULL,
	_XrmDefaultInitParseInfo,
	_XmbTextPropertyToTextList,
	_XwcTextPropertyToTextList,
	_Xutf8TextPropertyToTextList,
	_XmbTextListToTextProperty,
	_XwcTextListToTextProperty,
	_Xutf8TextListToTextProperty,
	_XwcFreeStringList,
	default_string,
	NULL,
	NULL
    },
    {
	NULL,
	create,
	initialize,
	destroy,
	get_values,
	_XlcGetLocaleDataBase
    }
};

XLCdMethods _XlcPublicMethods = (XLCdMethods) &publicMethods;

static XLCd
create(
    const char *name,
    XLCdMethods methods)
{
    XLCd lcd;
    XLCdPublicMethods new;

    lcd = Xcalloc(1, sizeof(XLCdRec));
    if (lcd == NULL)
        return (XLCd) NULL;

    lcd->core = Xcalloc(1, sizeof(XLCdPublicRec));
    if (lcd->core == NULL)
	goto err;

    new = Xmalloc(sizeof(XLCdPublicMethodsRec));
    if (new == NULL)
	goto err;
    memcpy(new,methods,sizeof(XLCdPublicMethodsRec));
    lcd->methods = (XLCdMethods) new;

    return lcd;

err:
    Xfree(lcd);
    return (XLCd) NULL;
}

static Bool
load_public(
    XLCd lcd)
{
    XLCdPublicPart *pub = XLC_PUBLIC_PART(lcd);
    char **values;
    const char *str;
    int num;

    if(_XlcCreateLocaleDataBase(lcd) == NULL)
	return False;

    _XlcGetResource(lcd, "XLC_XLOCALE", "mb_cur_max", &values, &num);
    if (num > 0) {
	pub->mb_cur_max = atoi(values[0]);
	if (pub->mb_cur_max < 1)
	    pub->mb_cur_max = 1;
    } else
	pub->mb_cur_max = 1;

    _XlcGetResource(lcd, "XLC_XLOCALE", "state_depend_encoding", &values, &num);
    if (num > 0 && !_XlcCompareISOLatin1(values[0], "True"))
	pub->is_state_depend = True;
    else
	pub->is_state_depend = False;

    _XlcGetResource(lcd, "XLC_XLOCALE", "encoding_name", &values, &num);
    str = (num > 0) ? values[0] : "STRING";
    pub->encoding_name = strdup(str);
    if (pub->encoding_name == NULL)
	return False;

    return True;
}

static Bool
initialize_core(
    XLCd lcd)
{
    XLCdMethods methods = lcd->methods;
    XLCdMethods core = &publicMethods.core;

    if (methods->close == NULL)
	methods->close = core->close;

    if (methods->map_modifiers == NULL)
	methods->map_modifiers = core->map_modifiers;

    if (methods->open_om == NULL)
#ifdef USE_DYNAMIC_LC
	_XInitDefaultOM(lcd);
#else
	_XInitOM(lcd);
#endif

    if (methods->open_im == NULL)
#ifdef USE_DYNAMIC_LC
	_XInitDefaultIM(lcd);
#else
	_XInitIM(lcd);
#endif

    if (methods->init_parse_info == NULL)
	methods->init_parse_info = core->init_parse_info;

    if (methods->mb_text_prop_to_list == NULL)
	methods->mb_text_prop_to_list = core->mb_text_prop_to_list;

    if (methods->wc_text_prop_to_list == NULL)
	methods->wc_text_prop_to_list = core->wc_text_prop_to_list;

    if (methods->utf8_text_prop_to_list == NULL)
	methods->utf8_text_prop_to_list = core->utf8_text_prop_to_list;

    if (methods->mb_text_list_to_prop == NULL)
	methods->mb_text_list_to_prop = core->mb_text_list_to_prop;

    if (methods->wc_text_list_to_prop == NULL)
	methods->wc_text_list_to_prop = core->wc_text_list_to_prop;

    if (methods->utf8_text_list_to_prop == NULL)
	methods->utf8_text_list_to_prop = core->utf8_text_list_to_prop;

    if (methods->wc_free_string_list == NULL)
	methods->wc_free_string_list = core->wc_free_string_list;

    if (methods->default_string == NULL)
	methods->default_string = core->default_string;

    return True;
}

static Bool
initialize(
    XLCd lcd)
{
    XLCdPublicMethodsPart *methods = XLC_PUBLIC_METHODS(lcd);
    XLCdPublicMethodsPart *pub_methods = &publicMethods.pub;
    XLCdPublicPart *pub = XLC_PUBLIC_PART(lcd);
    char *name;
#if !defined(X_LOCALE)
    int len;
    char sinamebuf[256];
    char* siname;
#endif

    _XlcInitCTInfo();

    if (initialize_core(lcd) == False)
	return False;

    name = lcd->core->name;
#if !defined(X_LOCALE)
    /*
     * _XlMapOSLocaleName will return the same string or a substring
     * of name, so strlen(name) is okay
     */
    if ((len = strlen(name)) < sizeof sinamebuf)
        siname = sinamebuf;
    else
        siname = Xmalloc (len + 1);
    if (siname == NULL)
        return False;
    name = _XlcMapOSLocaleName(name, siname);
#endif
    /* _XlcResolveLocaleName will lookup the SI's name for the locale */
    if (_XlcResolveLocaleName(name, pub) == 0) {
#if !defined(X_LOCALE)
	if (siname != sinamebuf) Xfree (siname);
#endif
	return False;
    }
#if !defined(X_LOCALE)
    if (siname != sinamebuf)
        Xfree (siname);
#endif

    if (pub->default_string == NULL)
	pub->default_string = "";

    if (methods->get_values == NULL)
	methods->get_values = pub_methods->get_values;

    if (methods->get_resource == NULL)
	methods->get_resource = pub_methods->get_resource;

    return load_public(lcd);
}

static void
destroy_core(
    XLCd lcd)
{
    if (lcd) {
        if (lcd->core) {
            Xfree(lcd->core->name);
            Xfree(lcd->core);
        }
        Xfree(lcd->methods);
        Xfree(lcd);
    }
}

static void
destroy(
    XLCd lcd)
{
    XLCdPublicPart *pub = XLC_PUBLIC_PART(lcd);

    _XlcDestroyLocaleDataBase(lcd);

    Xfree(pub->siname);
    Xfree(pub->encoding_name);

    destroy_core(lcd);
}

static XlcResource resources[] = {
    { XlcNCodeset, NULLQUARK, sizeof(char *),
      XOffsetOf(XLCdPublicRec, pub.codeset), XlcGetMask },
    { XlcNDefaultString, NULLQUARK, sizeof(char *),
      XOffsetOf(XLCdPublicRec, pub.default_string), XlcGetMask },
    { XlcNEncodingName, NULLQUARK, sizeof(char *),
      XOffsetOf(XLCdPublicRec, pub.encoding_name), XlcGetMask },
    { XlcNLanguage, NULLQUARK, sizeof(char *),
      XOffsetOf(XLCdPublicRec, pub.language), XlcGetMask },
    { XlcNMbCurMax, NULLQUARK, sizeof(int),
      XOffsetOf(XLCdPublicRec, pub.mb_cur_max), XlcGetMask },
    { XlcNStateDependentEncoding, NULLQUARK, sizeof(Bool),
      XOffsetOf(XLCdPublicRec, pub.is_state_depend), XlcGetMask },
    { XlcNTerritory, NULLQUARK, sizeof(char *),
      XOffsetOf(XLCdPublicRec, pub.territory), XlcGetMask }
};

static char *
get_values(
    XLCd lcd,
    XlcArgList args,
    int num_args)
{
    XLCdPublic pub = (XLCdPublic) lcd->core;

    if (resources[0].xrm_name == NULLQUARK)
	_XlcCompileResourceList(resources, XlcNumber(resources));

    return _XlcGetValues((XPointer) pub, resources, XlcNumber(resources), args,
			 num_args, XlcGetMask);
}
@


1.5
log
@Update to libX11 1.6.2. No API change.
@
text
@d257 2
a258 2
    if (lcd->core) {
	if (lcd->core->name)
d260 4
a263 1
	Xfree(lcd->core);
a264 5

    if (lcd->methods)
	Xfree(lcd->methods);

    Xfree(lcd);
d275 2
a276 4
    if (pub->siname)
	Xfree(pub->siname);
    if (pub->encoding_name)
	Xfree(pub->encoding_name);
@


1.4
log
@Update to libX11 1.4.4. Tested by ajacoutot@@, shadchin@@.
@
text
@d91 1
a91 1
    new = (XLCdPublicMethods) Xmalloc(sizeof(XLCdPublicMethodsRec));
d109 2
a110 1
    char **values, *str;
@


1.3
log
@Update to libX11 1.3.3. Tested on a bulk ports build by naddy@@.
@
text
@d83 1
a83 1
    lcd = (XLCd) Xmalloc(sizeof(XLCdRec));
a85 1
    bzero((char *) lcd, sizeof(XLCdRec));
d87 1
a87 1
    lcd->core = (XLCdCore) Xmalloc(sizeof(XLCdPublicRec));
a89 1
    bzero((char *) lcd->core, sizeof(XLCdPublicRec));
d131 1
a131 1
    pub->encoding_name = (char*) Xmalloc(strlen(str) + 1);
a133 1
    strcpy(pub->encoding_name, str);
@


1.2
log
@update to libX11 1.2.1
@
text
@a0 1
/* $Xorg: lcPublic.c,v 1.4 2000/12/12 12:44:05 coskrey Exp $ */
a24 1
/* $XFree86: xc/lib/X11/lcPublic.c,v 1.11 2001/11/16 00:52:28 dawes Exp $ */
@


1.1
log
@Initial revision
@
text
@d64 1
a64 1
    }, 
d221 3
a223 3
    /* 
     * _XlMapOSLocaleName will return the same string or a substring 
     * of name, so strlen(name) is okay 
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
