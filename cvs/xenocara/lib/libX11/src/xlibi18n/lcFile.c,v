head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.10
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.2
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.6
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_1_3:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	v1_0_99_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.04.06.20.57.59;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	L5f7tv2EiGjtzoSu;

1.8
date	2013.09.28.17.03.23;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.05.23.22.42.07;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.03.27.19.19.38;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.08.27.15.34.15;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.30.19.19.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.18.19.37.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.12.59.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.16.37.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.16.37.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.30.10.13.22;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@update to libX11 1.6.3
@
text
@/*
 *
 * Copyright IBM Corporation 1993
 *
 * All Rights Reserved
 *
 * License to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of IBM not be
 * used in advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 *
 * IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS, AND
 * NONINFRINGEMENT OF THIRD PARTY RIGHTS, IN NO EVENT SHALL
 * IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 *
*/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include "Xlibint.h"
#include "XlcPubI.h"
#include <X11/Xos.h>
#include <unistd.h>

/************************************************************************/

#ifndef HAVE_SETEUID
# define seteuid setuid
#endif
#define	iscomment(ch)	((ch) == '#' || (ch) == '\0')
#if defined(WIN32)
#define isreadable(f)	(_XAccessFile(f))
#else
#define isreadable(f)	((access((f), R_OK) != -1) ? 1 : 0)
#endif

#ifndef __UNIXOS2__
#define LC_PATHDELIM ':'
#else
#define LC_PATHDELIM ';'
#endif

#define XLC_BUFSIZE 256

#include "pathmax.h"

#define NUM_LOCALEDIR	64

/* Splits a NUL terminated line into constituents, at colons and newline
   characters. Leading whitespace is removed from constituents. The
   constituents are stored at argv[0..argsize-1]. The number of stored
   constituents (<= argsize) is returned. The line is destructively
   modified. */
static int
parse_line(
    char *line,
    char **argv,
    int argsize)
{
    int argc = 0;
    char *p = line;

    while (argc < argsize) {
	while (isspace(*p)) {
	    ++p;
	}
	if (*p == '\0') {
	    break;
	}
	argv[argc++] = p;
	while (*p != ':' && *p != '\n' && *p != '\0') {
	    ++p;
	}
	if (*p == '\0') {
	    break;
	}
	*p++ = '\0';
    }

    return argc;
}

#ifdef __UNIXOS2__

/* fg021216: entries in locale files are separated by colons while under
   OS/2, path entries are separated by semicolon, so we need two functions */

static int
parse_line1(
    char *line,
    char **argv,
    int argsize)
{
    int argc = 0;
    char *p = line;

    while (argc < argsize) {
	while (isspace(*p)) {
	    ++p;
	}
	if (*p == '\0') {
	    break;
	}
	argv[argc++] = p;
	while (*p != ';' && *p != '\n' && *p != '\0') {
	    ++p;
	}
	if (*p == '\0') {
	    break;
	}
	*p++ = '\0';
    }

    return argc;
}
#elif defined(WIN32)

/* this is parse_line but skips drive letters at the beginning of the entry */
static int
parse_line1(
    char *line,
    char **argv,
    int argsize)
{
    int argc = 0;
    char *p = line;

    while (argc < argsize) {
	while (isspace(*p)) {
	    ++p;
	}
	if (*p == '\0') {
	    break;
	}
	argv[argc++] = p;
        if (isalpha(*p) && p[1] == ':') {
            p+= 2; /* skip drive letters */
        }
	while (*p != ':' && *p != '\n' && *p != '\0') {
	    ++p;
	}
	if (*p == '\0') {
	    break;
	}
	*p++ = '\0';
    }

    return argc;
}

#endif   /* __UNIXOS2__ */

/* Splits a colon separated list of directories, and returns the constituent
   paths (without trailing slash). At most argsize constituents are stored
   at argv[0..argsize-1]. The number of stored constituents is returned. */
static int
_XlcParsePath(
    char *path,
    char **argv,
    int argsize)
{
    char *p = path;
    int n, i;

#if !defined(__UNIXOS2__) && !defined(WIN32)
    n = parse_line(path, argv, argsize);
#else
    n = parse_line1(path, argv, argsize);
#endif
    for (i = 0; i < n; ++i) {
	int len;
	p = argv[i];
	len = strlen(p);
	if (len > 0 && p[len - 1] == '/') {
	    /* eliminate trailing slash */
	    p[len - 1] = '\0';
	}
    }
    return n;
}

#ifndef XLOCALEDIR
#define XLOCALEDIR "/usr/lib/X11/locale"
#endif

void
xlocaledir(
    char *buf,
    int buf_len)
{
    char *p = buf;
    int len = 0;

#ifndef NO_XLOCALEDIR
    char *dir;
    int priv = 1;

    dir = getenv("XLOCALEDIR");

    if (dir) {
#ifndef WIN32
	/*
	 * Only use the user-supplied path if the process isn't priviledged.
	 */
	if (getuid() == geteuid() && getgid() == getegid()) {
#if defined(HASSETUGID)
	    priv = issetugid();
#elif defined(HASGETRESUID)
	    {
		uid_t ruid, euid, suid;
		gid_t rgid, egid, sgid;
		if ((getresuid(&ruid, &euid, &suid) == 0) &&
		    (getresgid(&rgid, &egid, &sgid) == 0))
		    priv = (euid != suid) || (egid != sgid);
	    }
#else
	    /*
	     * If there are saved ID's the process might still be priviledged
	     * even though the above test succeeded.  If issetugid() and
	     * getresgid() aren't available, test this by trying to set
	     * euid to 0.
	     *
	     * Note: this only protects setuid-root clients.  It doesn't
	     * protect other setuid or any setgid clients.  If this tradeoff
	     * isn't acceptable, set DisableXLocaleDirEnv to YES in host.def.
	     */
	    unsigned int oldeuid;
	    oldeuid = geteuid();
	    if (seteuid(0) != 0) {
		priv = 0;
	    } else {
		if (seteuid(oldeuid) == -1) {
		    /* XXX ouch, coudn't get back to original uid
		     what can we do ??? */
		    _exit(127);
		}
		priv = 1;
	    }
#endif
	}
#else
	priv = 0;
#endif
	if (!priv) {
	    len = strlen(dir);
	    strncpy(p, dir, buf_len);
	    if (len < buf_len) {
	        p[len++] = LC_PATHDELIM;
	        p += len;
	    }
	}
    }
#endif /* NO_XLOCALEDIR */

    if (len < buf_len)
#ifndef __UNIXOS2__
      strncpy(p, XLOCALEDIR, buf_len - len);
#else
      strncpy(p,__XOS2RedirRoot(XLOCALEDIR), buf_len - len);
#endif
    buf[buf_len-1] = '\0';
}

static void
xlocalelibdir(
    char *buf,
    int buf_len)
{
    char *p = buf;
    int len = 0;

#ifndef NO_XLOCALEDIR
    char *dir;
    int priv = 1;

    dir = getenv("XLOCALELIBDIR");

    if (dir) {
#ifndef WIN32
	/*
	 * Only use the user-supplied path if the process isn't priviledged.
	 */
	if (getuid() == geteuid() && getgid() == getegid()) {
#if defined(HASSETUGID)
	    priv = issetugid();
#elif defined(HASGETRESUID)
	    {
		uid_t ruid, euid, suid;
		gid_t rgid, egid, sgid;
		if ((getresuid(&ruid, &euid, &suid) == 0) &&
		    (getresgid(&rgid, &egid, &sgid) == 0))
		    priv = (euid != suid) || (egid != sgid);
	    }
#else
	    /*
	     * If there are saved ID's the process might still be priviledged
	     * even though the above test succeeded.  If issetugid() and
	     * getresgid() aren't available, test this by trying to set
	     * euid to 0.
	     *
	     * Note: this only protects setuid-root clients.  It doesn't
	     * protect other setuid or any setgid clients.  If this tradeoff
	     * isn't acceptable, set DisableXLocaleDirEnv to YES in host.def.
	     */
	    unsigned int oldeuid;
	    oldeuid = geteuid();
	    if (seteuid(0) != 0) {
		priv = 0;
	    } else {
		if (seteuid(oldeuid) == -1) {
		    /* XXX ouch, coudn't get back to original uid
		     what can we do ??? */
		    _exit(127);
		}
		priv = 1;
	    }
#endif
	}
#else
	priv = 0;
#endif
	if (!priv) {
	    len = strlen(dir);
	    strncpy(p, dir, buf_len);
	    if (len < buf_len) {
	        p[len++] = LC_PATHDELIM;
	        p += len;
	    }
	}
    }
#endif /* NO_XLOCALEDIR */

    if (len < buf_len)
#ifndef __UNIXOS2__
      strncpy(p, XLOCALELIBDIR, buf_len - len);
#else
      strncpy(p,__XOS2RedirRoot(XLOCALELIBDIR), buf_len - len);
#endif
    buf[buf_len-1] = '\0';
}

/* Mapping direction */
typedef enum {
  LtoR,		/* Map first field to second field */
  RtoL		/* Map second field to first field */
} MapDirection;

static char *
resolve_name(
    const char *lc_name,
    char *file_name,
    MapDirection direction)
{
    FILE *fp;
    char buf[XLC_BUFSIZE], *name = NULL;

    fp = _XFopenFile (file_name, "r");
    if (fp == NULL)
	return NULL;

    while (fgets(buf, XLC_BUFSIZE, fp) != NULL) {
	char *p = buf;
	int n;
	char *args[2], *from, *to;
#ifdef __UNIXOS2__  /* Take out CR under OS/2 */
	int len;

	len = strlen(p);
	if (len > 1) {
	    if (*(p+len-2) == '\r' && *(p+len-1) == '\n') {
		*(p+len-2) = '\n';
		*(p+len-1) = '\0';
	    }
	}
#endif
	while (isspace(*p)) {
	    ++p;
	}
	if (iscomment(*p)) {
	    continue;
	}
	n = parse_line(p, args, 2);		/* get first 2 fields */
	if (n != 2) {
	    continue;
	}
	if (direction == LtoR) {
	    from = args[0], to = args[1];	/* left to right */
	} else {
	    from = args[1], to = args[0];	/* right to left */
	}
	if (! strcmp(from, lc_name)) {
	    name = strdup(to);
	    break;
	}
    }
    fclose(fp);
    return name;
}

#define	c_tolower(ch)	((ch) >= 'A' && (ch) <= 'Z' ? (ch) - 'A' + 'a' : (ch))

static char *
lowercase(
    char *dst,
    const char *src)
{
    const char *s;
    char *t;

    for (s = src, t = dst; *s; ++s, ++t)
	*t = c_tolower(*s);
    *t = '\0';
    return dst;
}

/*
 * normalize_lcname(): remove any '_' and '-' and convert any character
 * to lower case after the <language>_<territory> part. If result is identical
 * to argument, free result and
 * return NULL.
 */
static char *
normalize_lcname (const char *name)
{
    char *p, *ret;
    const char *tmp = name;

    p = ret = Xmalloc(strlen(name) + 1);
    if (!p)
	return NULL;

    if (tmp) {
	while (*tmp && *tmp != '.' && *tmp != '@@')
	    *p++ = *tmp++;
	while (*tmp) {
	    if (*tmp != '-')
		*p++ = c_tolower(*tmp);
	    tmp++;
	}
    }
    *p = '\0';

    if (strcmp(ret, name) == 0) {
	Xfree(ret);
	return NULL;
    }

    return ret;
}

/************************************************************************/
char *
_XlcFileName(
    XLCd lcd,
    const char *category)
{
    char *siname;
    char cat[XLC_BUFSIZE], dir[XLC_BUFSIZE];
    int i, n;
    char *args[NUM_LOCALEDIR];
    char *file_name = NULL;

    if (lcd == (XLCd)NULL)
	return NULL;

    siname = XLC_PUBLIC(lcd, siname);

    if (category)
	lowercase(cat, category);
    else
	cat[0] = '\0';
    xlocaledir(dir,XLC_BUFSIZE);
    n = _XlcParsePath(dir, args, NUM_LOCALEDIR);
    for (i = 0; i < n; ++i) {
	char buf[PATH_MAX], *name;

	if (args[i] == NULL)
	    continue;

	name = NULL;
	if (snprintf(buf, PATH_MAX, "%s/%s.dir", args[i], cat) < PATH_MAX) {
	    name = resolve_name(siname, buf, RtoL);
	}
	if (name == NULL) {
	    continue;
	}
	if (*name == '/') {
	    /* supposed to be absolute path name */
	    file_name = name;
	} else {
	    if (snprintf(buf, PATH_MAX, "%s/%s", args[i], name) < PATH_MAX)
		file_name = strdup(buf);
	    else
		file_name = NULL;
	    Xfree(name);
	}
	if (file_name && isreadable(file_name)) {
	    break;
	}
	Xfree(file_name);
	file_name = NULL;
	/* Then, try with next dir */
    }
    return file_name;
}

/************************************************************************/
#ifndef LOCALE_ALIAS
#define LOCALE_ALIAS    "locale.alias"
#endif

int
_XlcResolveLocaleName(
    const char* lc_name,
    XLCdPublicPart* pub)
{
    char dir[PATH_MAX], buf[PATH_MAX], *name = NULL;
    char *dst;
    int i, n, sinamelen;
    char *args[NUM_LOCALEDIR];
    static const char locale_alias[] = LOCALE_ALIAS;
    char *tmp_siname;
    char *nlc_name = NULL;

    xlocaledir (dir, PATH_MAX);
    n = _XlcParsePath(dir, args, NUM_LOCALEDIR);
    for (i = 0; i < n; ++i) {
	if (args[i] == NULL)
	    continue;

	if (snprintf (buf, PATH_MAX, "%s/%s", args[i], locale_alias)
	    < PATH_MAX) {
	    name = resolve_name (lc_name, buf, LtoR);
	    if (!name) {
		if (!nlc_name)
		    nlc_name = normalize_lcname(lc_name);
		if (nlc_name)
		    name = resolve_name (nlc_name, buf, LtoR);
	    }
	}
	if (name != NULL) {
	    break;
	}
    }
    Xfree(nlc_name);

    if (name == NULL) {
	/* vendor locale name == Xlocale name, no expansion of alias */
	pub->siname = strdup (lc_name);
    } else {
	pub->siname = name;
    }

    sinamelen = strlen (pub->siname);
    if (sinamelen == 1 && pub->siname[0] == 'C') {
	pub->language = pub->siname;
	pub->territory = pub->codeset = NULL;
	return 1;
    }

    /*
     * pub->siname is in the format <lang>_<terr>.<codeset>, typical would
     * be "en_US.ISO8859-1", "en_US.utf8", "ru_RU.KOI-8", or ja_JP.SJIS,
     * although it could be ja.SJIS too.
     */
    tmp_siname = Xrealloc (pub->siname, 2 * (sinamelen + 1));
    if (tmp_siname == NULL) {
	return 0;
    }
    pub->siname = tmp_siname;

    /* language */
    dst = &pub->siname[sinamelen + 1];
    strcpy (dst, pub->siname);
    pub->language = dst;

    /* territory */
    dst = strchr (dst, '_');
    if (dst) {
	*dst = '\0';
	pub->territory = ++dst;
    } else
	dst = &pub->siname[sinamelen + 1];

    /* codeset */
    dst = strchr (dst, '.');
    if (dst) {
	*dst = '\0';
	pub->codeset = ++dst;
    }

    return (pub->siname[0] != '\0') ? 1 : 0;
}

/************************************************************************/
int
_XlcResolveI18NPath(char *buf, int buf_len)
{
    if (buf != NULL) {
	xlocaledir(buf, buf_len);
    }
    return 1;
}

char *
_XlcLocaleDirName(char *dir_name, size_t dir_len, const char *lc_name)
{
    char dir[PATH_MAX], buf[PATH_MAX];
    int i, n;
    char *args[NUM_LOCALEDIR];
    static char locale_alias[] = LOCALE_ALIAS;
    char *target_name = NULL;
    char *target_dir = NULL;
    char *nlc_name = NULL;
    static char*  last_dir_name = 0;
    static size_t last_dir_len = 0;
    static char*  last_lc_name = 0;

    if (last_lc_name != 0 && strcmp (last_lc_name, lc_name) == 0
       && dir_len >= last_dir_len) {
        strcpy (dir_name, last_dir_name);
        return dir_name;
    }

    xlocaledir (dir, PATH_MAX);
    n = _XlcParsePath(dir, args, NUM_LOCALEDIR);
    for (i = 0; i < n; ++i) {
	char *name = NULL;

	if (args[i] == NULL)
	    continue;

	if (snprintf (buf, PATH_MAX, "%s/%s", args[i], locale_alias)
	    < PATH_MAX) {
 	    name = resolve_name(lc_name, buf, LtoR);
	    if (!name) {
		if (!nlc_name)
		    nlc_name = normalize_lcname(lc_name);
		if (nlc_name)
		    name = resolve_name (nlc_name, buf, LtoR);
	    }
 	}

 	/* look at locale.dir */

 	target_dir = args[i];
	if (snprintf(buf, PATH_MAX, "%s/locale.dir", target_dir) < PATH_MAX) {
	    /* If name is not an alias, use lc_name for locale.dir search */
	    target_name = resolve_name(name ? name : lc_name, buf, RtoL);
 	}
	Xfree(name);
	name = NULL;
 	if (target_name != NULL) {
 	    char *p = 0;
 	    if ((p = strstr(target_name, "/XLC_LOCALE"))) {
 		*p = '\0';
 		break;
 	    }
 	    Xfree(target_name);
 	    target_name = NULL;
 	}
    }
    Xfree(nlc_name);

    if (target_name == NULL)
 	/* vendor locale name == Xlocale name, no expansion of alias */
	snprintf(dir_name, dir_len, "%s/%s", args[0], lc_name);
    else
	snprintf(dir_name, dir_len, "%s/%s", target_dir, target_name);

    Xfree(target_name);
    Xfree (last_dir_name);
    Xfree (last_lc_name);

    last_dir_len = strlen (dir_name) + 1;
    last_dir_name = Xmalloc (last_dir_len);
    strcpy (last_dir_name, dir_name);
    last_lc_name = strdup (lc_name);

    return dir_name;
}

char *
_XlcLocaleLibDirName(char *dir_name, size_t dir_len, const char *lc_name)
{
    char dir[PATH_MAX], buf[PATH_MAX];
    int i, n;
    char *args[NUM_LOCALEDIR];
    static char locale_alias[] = LOCALE_ALIAS;
    char *target_name = NULL;
    char *target_dir = NULL;
    char *nlc_name = NULL;
    static char*  last_dir_name = 0;
    static size_t last_dir_len = 0;
    static char*  last_lc_name = 0;

    if (last_lc_name != 0 && strcmp (last_lc_name, lc_name) == 0
       && dir_len >= last_dir_len) {
	strcpy (dir_name, last_dir_name);
	return dir_name;
    }

    xlocalelibdir (dir, PATH_MAX);
    n = _XlcParsePath(dir, args, NUM_LOCALEDIR);
    for (i = 0; i < n; ++i) {
	char *name = NULL;

	if (args[i] == NULL)
	    continue;

	if (snprintf (buf, PATH_MAX, "%s/%s", args[i], locale_alias)
	    < PATH_MAX) {
 	    name = resolve_name(lc_name, buf, LtoR);
	    if (!name) {
		if (!nlc_name)
		    nlc_name = normalize_lcname(lc_name);
		if (nlc_name)
		    name = resolve_name (nlc_name, buf, LtoR);
	    }
 	}

 	/* look at locale.dir */

 	target_dir = args[i];
	if (snprintf(buf, PATH_MAX, "%s/locale.dir", target_dir) < PATH_MAX) {
	    /* If name is not an alias, use lc_name for locale.dir search */
	    target_name = resolve_name(name ? name : lc_name, buf, RtoL);
 	}
	Xfree(name);
	name = NULL;
 	if (target_name != NULL) {
 	    char *p = 0;
 	    if ((p = strstr(target_name, "/XLC_LOCALE"))) {
 		*p = '\0';
 		break;
 	    }
 	    Xfree(target_name);
 	    target_name = NULL;
 	}
    }
    Xfree(nlc_name);

    if (target_name == NULL)
 	/* vendor locale name == Xlocale name, no expansion of alias */
	snprintf(dir_name, dir_len, "%s/%s", args[0], lc_name);
    else
	snprintf(dir_name, dir_len, "%s/%s", target_dir, target_name);
    Xfree(target_name);
    Xfree (last_dir_name);
    Xfree (last_lc_name);

    last_dir_len = strlen (dir_name) + 1;
    last_dir_name = Xmalloc (last_dir_len);
    strcpy (last_dir_name, dir_name);
    last_lc_name = strdup (lc_name);

    return dir_name;
}
@


1.8
log
@Update to libX11 1.6.2. No API change.
@
text
@d557 1
a557 1
    if (nlc_name) Xfree(nlc_name);
d675 1
a675 1
    if (nlc_name) Xfree(nlc_name);
d682 1
d684 2
a686 4
    if (last_dir_name != 0)
	Xfree (last_dir_name);
    if (last_lc_name != 0)
	Xfree (last_lc_name);
d753 1
a753 1
    if (nlc_name) Xfree(nlc_name);
d761 2
a763 4
    if (last_dir_name != 0)
	Xfree (last_dir_name);
    if (last_lc_name != 0)
	Xfree (last_lc_name);
@


1.7
log
@Merge upstream fixes for several X libs vulnerabilities
discovered by Ilja van Sprundel.

CVE-2013-1981 X.org libX11 1.5.99.901 (1.6 RC1) integer overflows
CVE-2013-1982 X.org libXext 1.3.1 integer overflows
CVE-2013-1983 X.org libXfixes 5.0 integer overflows
CVE-2013-1984 X.org libXi 1.7.1 integer overflows
CVE-2013-1985 X.org libXinerama 1.1.2 integer overflows
CVE-2013-1986 X.org libXrandr 1.4.0 integer overflows
CVE-2013-1987 X.org libXrender 0.9.7 integer overflows
CVE-2013-1988 X.org libXRes 1.0.6 integer overflows
CVE-2013-1989 X.org libXv 1.0.7 integer overflows
CVE-2013-1990 X.org libXvMC 1.0.7 integer overflows
CVE-2013-1991 X.org libXxf86dga 1.1.3 integer overflows
CVE-2013-1992 X.org libdmx 1.1.2 integer overflows
CVE-2013-1994 X.org libchromeXvMC & libchromeXvMCPro in openChrome
0.3.2 integer overflows
CVE-2013-1995 X.org libXi 1.7.1 sign extension issues
CVE-2013-1996 X.org libFS 1.0.4 sign extension issues
CVE-2013-1997 X.org libX11 1.5.99.901 (1.6 RC1) buffer overflows
CVE-2013-1998 X.org libXi 1.7.1 buffer overflows
CVE-2013-1999 X.org libXvMC 1.0.7 buffer overflows
CVE-2013-2000 X.org libXxf86dga 1.1.3 buffer overflows
CVE-2013-2001 X.org libXxf86vm 1.1.2 buffer overflows
CVE-2013-2002 X.org libXt 1.1.3 buffer overflows
CVE-2013-2003 X.org libXcursor 1.1.13 integer overflows
CVE-2013-2004 X.org libX11 1.5.99.901 (1.6 RC1) unbounded recursion
CVE-2013-2005 X.org libXt 1.1.3 memory corruption
CVE-2013-2066 X.org libXv 1.0.7 buffer overflows
@
text
@d489 3
d493 1
a493 2
	if ((5 + (args[i] ? strlen (args[i]) : 0) + strlen(cat)) < PATH_MAX) {
	    sprintf(buf, "%s/%s.dir", args[i], cat);
d503 4
a506 4
	    file_name = Xmalloc(2 + (args[i] ? strlen (args[i]) : 0) +
				(name ? strlen (name) : 0));
	    if (file_name != NULL)
		sprintf(file_name, "%s/%s", args[i], name);
d509 1
a509 1
	if (isreadable(file_name)) {
d540 5
a544 3
	if ((2 + (args[i] ? strlen (args[i]) : 0) +
	    strlen (locale_alias)) < PATH_MAX) {
	    sprintf (buf, "%s/%s", args[i], locale_alias);
d618 1
a618 1
_XlcLocaleDirName(char *dir_name, size_t dir_len, char *lc_name)
d620 1
a620 1
    char dir[PATH_MAX], buf[PATH_MAX], *name = NULL;
d624 2
a625 2
    char *target_name = (char*)0;
    char *target_dir = (char*)0;
d638 1
a638 1
    n = _XlcParsePath(dir, args, 256);
d640 1
d642 5
a646 3
	if ((2 + (args[i] ? strlen(args[i]) : 0) +
 	     strlen(locale_alias)) < PATH_MAX) {
 	    sprintf (buf, "%s/%s", args[i], locale_alias);
a655 4
 	/* If name is not an alias, use lc_name for locale.dir search */
 	if (name == NULL)
 	    name = lc_name;

d659 3
a661 5
 	if (!target_dir) {
 	    /* something wrong */
 	    if (name != lc_name)
 		Xfree(name);
 	    continue;
d663 2
a664 6
 	if ((1 + strlen (target_dir) + strlen("locale.dir")) < PATH_MAX) {
 	    sprintf(buf, "%s/locale.dir", target_dir);
 	    target_name = resolve_name(name, buf, RtoL);
 	}
 	if (name != lc_name)
 	    Xfree(name);
a673 1
 	name = NULL;
d677 1
a677 1
    if (target_name == NULL) {
d679 4
a682 15
 	target_dir = args[0];
 	target_name = lc_name;
    }
    /* snprintf(dir_name, dir_len, "%s/%", target_dir, target_name); */
    strncpy(dir_name, target_dir, dir_len - 1);
    if (strlen(target_dir) >= dir_len - 1) {
	dir_name[dir_len - 1] = '\0';
    } else  {
	strcat(dir_name, "/");
	strncat(dir_name, target_name, dir_len - strlen(dir_name) - 1);
	if (strlen(target_name) >= dir_len - strlen(dir_name) - 1)
	    dir_name[dir_len - 1] = '\0';
    }
    if (target_name != lc_name)
 	Xfree(target_name);
d697 1
a697 1
_XlcLocaleLibDirName(char *dir_name, size_t dir_len, char *lc_name)
d699 1
a699 1
    char dir[PATH_MAX], buf[PATH_MAX], *name = NULL;
d703 2
a704 2
    char *target_name = (char*)0;
    char *target_dir = (char*)0;
d717 1
a717 1
    n = _XlcParsePath(dir, args, 256);
d719 4
d724 2
a725 3
	if ((2 + (args[i] ? strlen(args[i]) : 0) +
 	     strlen(locale_alias)) < PATH_MAX) {
 	    sprintf (buf, "%s/%s", args[i], locale_alias);
a734 4
 	/* If name is not an alias, use lc_name for locale.dir search */
 	if (name == NULL)
 	    name = lc_name;

d738 3
a740 5
 	if (!target_dir) {
 	    /* something wrong */
 	    if (name != lc_name)
 		Xfree(name);
 	    continue;
d742 2
a743 6
 	if ((1 + strlen (target_dir) + strlen("locale.dir")) < PATH_MAX) {
 	    sprintf(buf, "%s/locale.dir", target_dir);
 	    target_name = resolve_name(name, buf, RtoL);
 	}
 	if (name != lc_name)
 	    Xfree(name);
a752 1
 	name = NULL;
d756 1
a756 1
    if (target_name == NULL) {
d758 4
a761 15
 	target_dir = args[0];
 	target_name = lc_name;
    }
    /* snprintf(dir_name, dir_len, "%s/%", target_dir, target_name); */
    strncpy(dir_name, target_dir, dir_len - 1);
    if (strlen(target_dir) >= dir_len - 1) {
	dir_name[dir_len - 1] = '\0';
    } else  {
	strcat(dir_name, "/");
	strncat(dir_name, target_name, dir_len - strlen(dir_name) - 1);
	if (strlen(target_name) >= dir_len - strlen(dir_name) - 1)
	    dir_name[dir_len - 1] = '\0';
    }
    if (target_name != lc_name)
 	Xfree(target_name);
@


1.6
log
@Upate to libX11 1.5rc1. Tested by krw@@, mpi@@, shadchin@@.
@
text
@d57 1
a57 23
#ifndef X_NOT_POSIX
#ifdef _POSIX_SOURCE
#include <limits.h>
#else
#define _POSIX_SOURCE
#include <limits.h>
#undef _POSIX_SOURCE
#endif
#endif
#ifndef PATH_MAX
#ifdef WIN32
#define PATH_MAX 512
#else
#include <sys/param.h>
#endif
#ifndef PATH_MAX
#ifdef MAXPATHLEN
#define PATH_MAX MAXPATHLEN
#else
#define PATH_MAX 1024
#endif
#endif
#endif
@


1.5
log
@Update to libX11 1.4.4. Tested by ajacoutot@@, shadchin@@.
@
text
@d39 1
a39 1
#ifdef __UNIXOS2__
@


1.4
log
@Update to libx11 1.4.2. Tested by ajacoutot@@, jasper@@ krw@@, landry@@,
shadchin@@ on various architectures.
Bump major.
@
text
@d426 1
a426 4
	    name = Xmalloc(strlen(to) + 1);
	    if (name != NULL) {
		strcpy(name, to);
	    }
d579 1
a579 2
	pub->siname = Xmalloc (strlen (lc_name) + 1);
	strcpy (pub->siname, lc_name);
d728 1
a728 2
    last_lc_name = Xmalloc (strlen (lc_name) + 1);
    strcpy (last_lc_name, lc_name);
d826 1
a826 2
    last_lc_name = Xmalloc (strlen (lc_name) + 1);
    strcpy (last_lc_name, lc_name);
@


1.3
log
@Update to libX11 1.3.3. Tested on a bulk ports build by naddy@@.
@
text
@d688 1
a688 2
 	if ((1 + (target_dir ? strlen (target_dir) : 0) +
 	     strlen("locale.dir")) < PATH_MAX) {
d787 1
a787 2
 	if ((1 + (target_dir ? strlen (target_dir) : 0) +
 	     strlen("locale.dir")) < PATH_MAX) {
@


1.2
log
@update to libX11 1.2.1
@
text
@a0 1
/* $Xorg: lcFile.c,v 1.5 2000/12/12 12:44:05 coskrey Exp $ */
a24 1
/* $XFree86: xc/lib/X11/lcFile.c,v 3.32 2003/03/25 04:18:09 dawes Exp $ */
d220 1
a220 1
static void
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS, AND 
d37 1
a37 5
#if 0
#include <unistd.h>  /* in theory delivers getresuid/gid prototypes,
		      * in practice only the Linux syscall wrapper is there. */
#endif

d269 1
a269 1
		    /* XXX ouch, coudn't get back to original uid 
d347 1
a347 1
		    /* XXX ouch, coudn't get back to original uid 
d466 1
a466 1
    
d470 1
a470 1
    
d507 4
a510 1
    lowercase(cat, category);
d517 1
a517 2
	if ((5 + (args[i] ? strlen (args[i]) : 0) +
	    (cat ? strlen (cat) : 0)) < PATH_MAX) {
d565 1
a565 1
	if ((2 + (args[i] ? strlen (args[i]) : 0) + 
d597 1
a597 1
    /* 
d633 1
a633 3
_XlcResolveI18NPath(buf, buf_len)
    char *buf;
    int buf_len;
d642 1
a642 4
_XlcLocaleDirName(dir_name, dir_len, lc_name)
     char *dir_name;
     size_t dir_len;
     char *lc_name;
d664 2
a665 2
  
	if ((2 + (args[i] ? strlen(args[i]) : 0) + 
d676 1
a676 1
  
d680 1
a680 1
 
d682 1
a682 1
 
d722 1
a722 1
	if (strlen(target_name) >= dir_len - strlen(dir_name) - 1) 
d742 1
a742 4
_XlcLocaleLibDirName(dir_name, dir_len, lc_name)
     char *dir_name;
     size_t dir_len;
     char *lc_name;
d764 2
a765 2
  
	if ((2 + (args[i] ? strlen(args[i]) : 0) + 
d776 1
a776 1
  
d780 1
a780 1
 
d782 1
a782 1
 
d822 1
a822 1
	if (strlen(target_name) >= dir_len - strlen(dir_name) - 1) 
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@libX11 1.1.3
@
text
@d37 5
a41 1
#include <unistd.h>
@

