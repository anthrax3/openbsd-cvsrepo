head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.28
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.26
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.24
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.22
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.20
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.18
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.16
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.14
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.12
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.10
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.8
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_1_3:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	v1_0_99_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2010.05.18.19.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.16.37.54;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.16.37.54;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to libX11 1.3.3. Tested on a bulk ports build by naddy@@.
@
text
@
/*
 * BIG5-0 and BIG5-1
 */

/*
   BIG5 with its 13494 characters doesn't fit in a single 94x94 or 96x96
   block. Therefore Emacs/Mule developers, in a typically Japanese way of
   thinking, have developed an alternative encoding of BIG5 in two 94x94
   planes, very similar to the SHIFT_JIS encoding for JISX0208.

   Conversion between BIG5 codes (s1,s2) and BIG5-0 codes (c1,c2):
   Example. (s1,s2) = 0xA140, (c1,c2) = 0x2121.
   0xA1 <= s1 <= 0xC7, 0x40 <= s2 <= 0x7E || 0xA1 <= s2 <= 0xFE,
   0x21 <= c1 <= 0x62, 0x21 <= c2 <= 0x7E.
   Invariant:
     157*(s1-0xA1) + (s2 < 0x80 ? s2-0x40 : s2-0x62)
     = 94*(c1-0x21)+(c2-0x21)
   Conversion (s1,s2) -> (c1,c2):
     t := 157*(s1-0xA1) + (s2 < 0x80 ? s2-0x40 : s2-0x62)
     c1 := (t div 94) + 0x21
     c2 := (t mod 94) + 0x21
   Conversion (c1,c2) -> (s1,s2):
     t := 94*(c1-0x21)+(c2-0x21)
     t2 := t mod 157
     s1 := (t div 157) + 0xA1
     s2 := (t2 < 0x3F ? t2+0x40 : t2+0x62)

   Conversion between BIG5 codes (s1,s2) and BIG5-1 codes (c1,c2):
   Example. (s1,s2) = 0xC940, (c1,c2) = 0x2121.
   0xC9 <= s1 <= 0xF9, 0x40 <= s2 <= 0x7E || 0xA1 <= s2 <= 0xFE,
   0x21 <= c1 <= 0x72, 0x21 <= c2 <= 0x7E.
   Invariant:
     157*(s1-0xC9) + (s2 < 0x80 ? s2-0x40 : s2-0x62)
     = 94*(c1-0x21)+(c2-0x21)
   Conversion (s1,s2) -> (c1,c2):
     t := 157*(s1-0xC9) + (s2 < 0x80 ? s2-0x40 : s2-0x62)
     c1 := (t div 94) + 0x21
     c2 := (t mod 94) + 0x21
   Conversion (c1,c2) -> (s1,s2):
     t := 94*(c1-0x21)+(c2-0x21)
     t2 := t mod 157
     s1 := (t div 157) + 0xC9
     s2 := (t2 < 0x3F ? t2+0x40 : t2+0x62)
 */

static int
big5_0_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, int n)
{
  unsigned char c1 = s[0];
  if (c1 >= 0x21 && c1 <= 0x62) {
    if (n >= 2) {
      unsigned char c2 = s[1];
      if (c2 >= 0x21 && c2 <= 0x7e) {
        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);
        if (0) {
          /* Unoptimized. */
          unsigned char buf[2];
          buf[0] = (i / 157) + 0xa1;
          i = i % 157;
          buf[1] = i + (i < 0x3f ? 0x40 : 0x62);
          return big5_mbtowc(conv,pwc,buf,2);
        } else {
          /* Inline the implementation of big5_mbtowc. */
          if (i < 6121) {
            unsigned short wc = big5_2uni_pagea1[i];
            if (wc != 0xfffd) {
              *pwc = (ucs4_t) wc;
              return 2;
            }
          }
        }
      }
      return RET_ILSEQ;
    }
    return RET_TOOFEW(0);
  }
  return RET_ILSEQ;
}

static int
big5_1_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, int n)
{
  unsigned char c1 = s[0];
  if (c1 >= 0x21 && c1 <= 0x72) {
    if (n >= 2) {
      unsigned char c2 = s[1];
      if (c2 >= 0x21 && c2 <= 0x7e) {
        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);
        if (0) {
          /* Unoptimized. */
          unsigned char buf[2];
          buf[0] = (i / 157) + 0xc9;
          i = i % 157;
          buf[1] = i + (i < 0x3f ? 0x40 : 0x62);
          return big5_mbtowc(conv,pwc,buf,2);
        } else {
          /* Inline the implementation of big5_mbtowc. */
          if (i < 7652) {
            unsigned short wc = big5_2uni_pagec9[i];
            if (wc != 0xfffd) {
              *pwc = (ucs4_t) wc;
              return 2;
            }
          }
        }
      }
      return RET_ILSEQ;
    }
    return RET_TOOFEW(0);
  }
  return RET_ILSEQ;
}

static int
big5_0_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, int n)
{
  if (n >= 2) {
    unsigned char buf[2];
    int ret = big5_wctomb(conv,buf,wc,2);
    if (ret != RET_ILSEQ) {
      unsigned char s1, s2;
      if (ret != 2) abort();
      s1 = buf[0];
      s2 = buf[1];
      if (!(s1 >= 0xa1)) abort();
      if (!((s2 >= 0x40 && s2 <= 0x7e) || (s2 >= 0xa1 && s2 <= 0xfe))) abort();
      if (s1 < 0xc9) {
        unsigned int t = 157 * (s1 - 0xa1) + s2 - (s2 < 0x80 ? 0x40 : 0x62);
        r[0] = (t / 94) + 0x21;
        r[1] = (t % 94) + 0x21;
        return 2;
      }
    }
    return RET_ILSEQ;
  }
  return RET_TOOSMALL;
}

static int
big5_1_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, int n)
{
  if (n >= 2) {
    unsigned char buf[2];
    int ret = big5_wctomb(conv,buf,wc,2);
    if (ret != RET_ILSEQ) {
      unsigned char s1, s2;
      if (ret != 2) abort();
      s1 = buf[0];
      s2 = buf[1];
      if (!(s1 <= 0xf9)) abort();
      if (!((s2 >= 0x40 && s2 <= 0x7e) || (s2 >= 0xa1 && s2 <= 0xfe))) abort();
      if (s1 >= 0xc9) {
        unsigned int t = 157 * (s1 - 0xc9) + s2 - (s2 < 0x80 ? 0x40 : 0x62);
        r[0] = (t / 94) + 0x21;
        r[1] = (t % 94) + 0x21;
        return 2;
      }
    }
    return RET_ILSEQ;
  }
  return RET_TOOSMALL;
}
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
