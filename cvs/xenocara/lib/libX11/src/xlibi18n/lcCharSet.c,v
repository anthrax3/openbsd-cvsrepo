head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.12
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.10
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.8
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.6
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_1_3:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	v1_0_99_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.09.28.17.03.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.08.27.15.34.15;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.18.19.37.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.12.59.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.16.37.46;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.16.37.46;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to libX11 1.6.2. No API change.
@
text
@/*
 * Copyright 1992, 1993 by TOSHIBA Corp.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided
 * that the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of TOSHIBA not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. TOSHIBA make no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * TOSHIBA DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * TOSHIBA BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 *
 * Author: Katsuhisa Yano	TOSHIBA Corp.
 *			   	mopi@@osa.ilab.toshiba.co.jp
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdio.h>
#include "Xlibint.h"
#include "XlcPublic.h"
#include "XlcPubI.h"

/* The list of all known XlcCharSets. They are identified by their name. */

typedef struct _XlcCharSetListRec {
    XlcCharSet charset;
    struct _XlcCharSetListRec *next;
} XlcCharSetListRec, *XlcCharSetList;

static XlcCharSetList charset_list = NULL;

/* Returns the charset with the given name (including side suffix).
   Returns NULL if not found. */
XlcCharSet
_XlcGetCharSet(
    const char *name)
{
    XlcCharSetList list;
    XrmQuark xrm_name;

    xrm_name = XrmStringToQuark(name);

    for (list = charset_list; list; list = list->next) {
	if (xrm_name == list->charset->xrm_name)
	    return (XlcCharSet) list->charset;
    }

    return (XlcCharSet) NULL;
}

/* Returns the charset with the given encoding (no side suffix) and
   responsible for at least the given side (XlcGL or XlcGR).
   Returns NULL if not found. */
XlcCharSet
_XlcGetCharSetWithSide(
    const char *encoding_name,
    XlcSide side)
{
    XlcCharSetList list;
    XrmQuark xrm_encoding_name;

    xrm_encoding_name = XrmStringToQuark(encoding_name);

    for (list = charset_list; list; list = list->next) {
	if (list->charset->xrm_encoding_name == xrm_encoding_name
	    && (list->charset->side == XlcGLGR || list->charset->side == side))
	    return (XlcCharSet) list->charset;
    }

    return (XlcCharSet) NULL;
}

/* Registers an XlcCharSet in the list of character sets.
   Returns True if successful. */
Bool
_XlcAddCharSet(
    XlcCharSet charset)
{
    XlcCharSetList list;

    if (_XlcGetCharSet(charset->name))
	return False;

    list = Xmalloc(sizeof(XlcCharSetListRec));
    if (list == NULL)
	return False;

    list->charset = charset;
    list->next = charset_list;
    charset_list = list;

    return True;
}

/* List of resources for XlcCharSet. */
static XlcResource resources[] = {
    { XlcNName, NULLQUARK, sizeof(char *),
      XOffsetOf(XlcCharSetRec, name), XlcGetMask },
    { XlcNEncodingName, NULLQUARK, sizeof(char *),
      XOffsetOf(XlcCharSetRec, encoding_name), XlcGetMask },
    { XlcNSide, NULLQUARK, sizeof(XlcSide),
      XOffsetOf(XlcCharSetRec, side), XlcGetMask },
    { XlcNCharSize, NULLQUARK, sizeof(int),
      XOffsetOf(XlcCharSetRec, char_size), XlcGetMask },
    { XlcNSetSize, NULLQUARK, sizeof(int),
      XOffsetOf(XlcCharSetRec, set_size), XlcGetMask },
    { XlcNControlSequence, NULLQUARK, sizeof(char *),
      XOffsetOf(XlcCharSetRec, ct_sequence), XlcGetMask }
};

/* Retrieves a number of attributes of an XlcCharSet.
   Return NULL if successful, otherwise the name of the first argument
   specifiying a nonexistent attribute. */
static char *
get_values(
    XlcCharSet charset,
    XlcArgList args,
    int num_args)
{
    if (resources[0].xrm_name == NULLQUARK)
	_XlcCompileResourceList(resources, XlcNumber(resources));

    return _XlcGetValues((XPointer) charset, resources, XlcNumber(resources),
			 args, num_args, XlcGetMask);
}

/* Retrieves a number of attributes of an XlcCharSet.
   Return NULL if successful, otherwise the name of the first argument
   specifiying a nonexistent attribute. */
char *
_XlcGetCSValues(XlcCharSet charset, ...)
{
    va_list var;
    XlcArgList args;
    char *ret;
    int num_args;

    va_start(var, charset);
    _XlcCountVaList(var, &num_args);
    va_end(var);

    va_start(var, charset);
    _XlcVaToArgList(var, num_args, &args);
    va_end(var);

    if (args == (XlcArgList) NULL)
	return (char *) NULL;

    ret = get_values(charset, args, num_args);

    Xfree(args);

    return ret;
}

/* Creates a new XlcCharSet, given its name (including side suffix) and
   Compound Text ESC sequence (normally at most 4 bytes). */
XlcCharSet
_XlcCreateDefaultCharSet(
    const char *name,
    const char *ct_sequence)
{
    XlcCharSet charset;
    int name_len, ct_sequence_len;
    const char *colon;
    char *tmp;

    charset = Xcalloc(1, sizeof(XlcCharSetRec));
    if (charset == NULL)
	return (XlcCharSet) NULL;

    name_len = strlen(name);
    ct_sequence_len = strlen(ct_sequence);

    /* Fill in name and xrm_name.  */
    tmp = Xmalloc(name_len + 1 + ct_sequence_len + 1);
    if (tmp == NULL) {
	Xfree(charset);
	return (XlcCharSet) NULL;
    }
    memcpy(tmp, name, name_len+1);
    charset->name = tmp;
    charset->xrm_name = XrmStringToQuark(charset->name);

    /* Fill in encoding_name and xrm_encoding_name.  */
    if ((colon = strchr(charset->name, ':')) != NULL) {
        unsigned int length = colon - charset->name;
        char *encoding_tmp = Xmalloc(length + 1);
        if (encoding_tmp == NULL) {
            Xfree((char *) charset->name);
            Xfree(charset);
            return (XlcCharSet) NULL;
        }
        memcpy(encoding_tmp, charset->name, length);
        encoding_tmp[length] = '\0';
        charset->encoding_name = encoding_tmp;
        charset->xrm_encoding_name = XrmStringToQuark(charset->encoding_name);
    } else {
        charset->encoding_name = charset->name;
        charset->xrm_encoding_name = charset->xrm_name;
    }

    /* Fill in ct_sequence.  */
    tmp += name_len + 1;
    memcpy(tmp, ct_sequence, ct_sequence_len+1);
    charset->ct_sequence = tmp;

    /* Fill in side, char_size, set_size. */
    if (!_XlcParseCharSet(charset))
        /* If ct_sequence is not usable in Compound Text, remove it. */
        charset->ct_sequence = "";

    return (XlcCharSet) charset;
}
@


1.4
log
@Update to libX11 1.4.4. Tested by ajacoutot@@, shadchin@@.
@
text
@d95 1
a95 1
    list = (XlcCharSetList) Xmalloc(sizeof(XlcCharSetListRec));
d187 1
a187 1
    tmp = (char *) Xmalloc(name_len + 1 + ct_sequence_len + 1);
d189 1
a189 1
	Xfree((char *) charset);
d199 1
a199 1
        char *encoding_tmp = (char *) Xmalloc(length + 1);
d202 1
a202 1
            Xfree((char *) charset);
@


1.3
log
@Update to libX11 1.3.3. Tested on a bulk ports build by naddy@@.
@
text
@d179 1
a179 1
    charset = (XlcCharSet) Xmalloc(sizeof(XlcCharSetRec));
a181 1
    bzero((char *) charset, sizeof(XlcCharSetRec));
@


1.2
log
@update to libX11 1.2.1
@
text
@a0 1
/* $Xorg: lcCharSet.c,v 1.3 2000/08/17 19:45:16 cpqbld Exp $ */
a24 1
/* $XFree86: xc/lib/X11/lcCharSet.c,v 3.8 2001/01/17 19:41:53 dawes Exp $ */
@


1.1
log
@Initial revision
@
text
@d53 1
a53 1
    
d74 1
a74 1
    
d100 1
a100 1
    
d161 1
a161 1
    
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
