head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.6
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.2
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_1_3:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	v1_0_99_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.04.06.20.57.59;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	L5f7tv2EiGjtzoSu;

1.7
date	2013.09.28.17.03.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.05.23.22.42.07;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.08.27.15.34.15;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.30.19.19.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.18.19.37.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.12.59.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.16.37.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.16.37.34;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@update to libX11 1.6.3
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef DEBUG
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdio.h>
#endif

#define NEED_MAP_READERS
#include "Xlibint.h"
#include <X11/extensions/XKBgeom.h>
#include <X11/extensions/XKBproto.h>
#include "XKBlibint.h"

#ifndef MINSHORT
#define	MINSHORT	-32768
#endif
#ifndef MAXSHORT
#define	MAXSHORT	32767
#endif

/***====================================================================***/

static void
_XkbCheckBounds(XkbBoundsPtr bounds, int x, int y)
{
    if (x < bounds->x1)
        bounds->x1 = x;
    if (x > bounds->x2)
        bounds->x2 = x;
    if (y < bounds->y1)
        bounds->y1 = y;
    if (y > bounds->y2)
        bounds->y2 = y;
    return;
}

Bool
XkbComputeShapeBounds(XkbShapePtr shape)
{
    register int o, p;
    XkbOutlinePtr outline;
    XkbPointPtr pt;

    if ((!shape) || (shape->num_outlines < 1))
        return False;
    shape->bounds.x1 = shape->bounds.y1 = MAXSHORT;
    shape->bounds.x2 = shape->bounds.y2 = MINSHORT;
    for (outline = shape->outlines, o = 0; o < shape->num_outlines;
         o++, outline++) {
        for (pt = outline->points, p = 0; p < outline->num_points; p++, pt++) {
            _XkbCheckBounds(&shape->bounds, pt->x, pt->y);
        }
        if (outline->num_points < 2) {
            _XkbCheckBounds(&shape->bounds, 0, 0);
        }
    }
    return True;
}

Bool
XkbComputeShapeTop(XkbShapePtr shape, XkbBoundsPtr bounds)
{
    register int p;
    XkbOutlinePtr outline;
    XkbPointPtr pt;

    if ((!shape) || (shape->num_outlines < 1))
        return False;
    if (shape->approx)
        outline = shape->approx;
    else
        outline = &shape->outlines[shape->num_outlines - 1];
    if (outline->num_points < 2) {
        bounds->x1 = bounds->y1 = 0;
        bounds->x2 = bounds->y2 = 0;
    }
    else {
        bounds->x1 = bounds->y1 = MAXSHORT;
        bounds->x2 = bounds->y2 = MINSHORT;
    }
    for (pt = outline->points, p = 0; p < outline->num_points; p++, pt++) {
        _XkbCheckBounds(bounds, pt->x, pt->y);
    }
    return True;
}

Bool
XkbComputeRowBounds(XkbGeometryPtr geom, XkbSectionPtr section, XkbRowPtr row)
{
    register int k, pos;
    XkbKeyPtr key;
    XkbBoundsPtr bounds, sbounds;

    if ((!geom) || (!section) || (!row))
        return False;
    bounds = &row->bounds;
    bzero(bounds, sizeof(XkbBoundsRec));
    for (key = row->keys, pos = k = 0; k < row->num_keys; k++, key++) {
        sbounds = &XkbKeyShape(geom, key)->bounds;
        _XkbCheckBounds(bounds, pos, 0);
        if (!row->vertical) {
            if (key->gap != 0) {
                pos += key->gap;
                _XkbCheckBounds(bounds, pos, 0);
            }
            _XkbCheckBounds(bounds, pos + sbounds->x1, sbounds->y1);
            _XkbCheckBounds(bounds, pos + sbounds->x2, sbounds->y2);
            pos += sbounds->x2;
        }
        else {
            if (key->gap != 0) {
                pos += key->gap;
                _XkbCheckBounds(bounds, 0, pos);
            }
            _XkbCheckBounds(bounds, pos + sbounds->x1, sbounds->y1);
            _XkbCheckBounds(bounds, pos + sbounds->x2, sbounds->y2);
            pos += sbounds->y2;
        }
    }
    return True;
}

Bool
XkbComputeSectionBounds(XkbGeometryPtr geom, XkbSectionPtr section)
{
    register int i;
    XkbShapePtr shape;
    XkbRowPtr row;
    XkbDoodadPtr doodad;
    XkbBoundsPtr bounds, rbounds;

    if ((!geom) || (!section))
        return False;
    bounds = &section->bounds;
    bzero(bounds, sizeof(XkbBoundsRec));
    for (i = 0, row = section->rows; i < section->num_rows; i++, row++) {
        if (!XkbComputeRowBounds(geom, section, row))
            return False;
        rbounds = &row->bounds;
        _XkbCheckBounds(bounds, row->left + rbounds->x1,
                        row->top + rbounds->y1);
        _XkbCheckBounds(bounds, row->left + rbounds->x2,
                        row->top + rbounds->y2);
    }
    for (i = 0, doodad = section->doodads; i < section->num_doodads;
         i++, doodad++) {
        static XkbBoundsRec tbounds;

        switch (doodad->any.type) {
        case XkbOutlineDoodad:
        case XkbSolidDoodad:
            shape = XkbShapeDoodadShape(geom, &doodad->shape);
            rbounds = &shape->bounds;
            break;
        case XkbTextDoodad:
            tbounds.x1 = doodad->text.left;
            tbounds.y1 = doodad->text.top;
            tbounds.x2 = tbounds.x1 + doodad->text.width;
            tbounds.y2 = tbounds.y1 + doodad->text.height;
            rbounds = &tbounds;
            break;
        case XkbIndicatorDoodad:
            shape = XkbIndicatorDoodadShape(geom, &doodad->indicator);
            rbounds = &shape->bounds;
            break;
        case XkbLogoDoodad:
            shape = XkbLogoDoodadShape(geom, &doodad->logo);
            rbounds = &shape->bounds;
            break;
        default:
            tbounds.x1 = tbounds.x2 = doodad->any.left;
            tbounds.y1 = tbounds.y2 = doodad->any.top;
            rbounds = &tbounds;
            break;
        }
        _XkbCheckBounds(bounds, rbounds->x1, rbounds->y1);
        _XkbCheckBounds(bounds, rbounds->x2, rbounds->y2);
    }
    return True;
}

/***====================================================================***/

char *
XkbFindOverlayForKey(XkbGeometryPtr geom, XkbSectionPtr wanted, char *under)
{
    int s;
    XkbSectionPtr section;

    if ((geom == NULL) || (under == NULL) || (geom->num_sections < 1))
        return NULL;

    if (wanted)
        section = wanted;
    else
        section = geom->sections;

    for (s = 0; s < geom->num_sections; s++, section++) {
        XkbOverlayPtr ol;
        int o;

        if (section->num_overlays < 1)
            continue;
        for (o = 0, ol = section->overlays; o < section->num_overlays;
             o++, ol++) {
            XkbOverlayRowPtr row;
            int r;

            for (r = 0, row = ol->rows; r < ol->num_rows; r++, row++) {
                XkbOverlayKeyPtr key;
                int k;

                for (k = 0, key = row->keys; k < row->num_keys; k++, key++) {
                    if (strncmp(under, key->under.name, XkbKeyNameLength) == 0)
                        return key->over.name;
                }
            }
        }
        if (wanted != NULL)
            break;
    }
    return NULL;
}

/***====================================================================***/

static Status
_XkbReadGeomProperties(XkbReadBufferPtr buf,
                       XkbGeometryPtr geom,
                       xkbGetGeometryReply *rep)
{
    Status rtrn;

    if (rep->nProperties < 1)
        return Success;
    if ((rtrn = XkbAllocGeomProps(geom, rep->nProperties)) == Success) {
        register int i;
        register Bool ok = True;

        for (i = 0; (i < rep->nProperties) && ok; i++) {
            char *name = NULL;
            char *value = NULL;
            ok = _XkbGetReadBufferCountedString(buf, &name) && ok;
            ok = _XkbGetReadBufferCountedString(buf, &value) && ok;
            ok = ok && (XkbAddGeomProperty(geom, name, value) != NULL);

	    _XkbFree(name);
	    _XkbFree(value);
        }
        if (ok)
            rtrn = Success;
        else
            rtrn = BadLength;
    }
    return rtrn;
}

static Status
_XkbReadGeomKeyAliases(XkbReadBufferPtr buf,
                       XkbGeometryPtr geom,
                       xkbGetGeometryReply *rep)
{
    Status rtrn;

    if (rep->nKeyAliases < 1)
        return Success;
    if ((rtrn = XkbAllocGeomKeyAliases(geom, rep->nKeyAliases)) == Success) {
        if (!_XkbCopyFromReadBuffer(buf, (char *) geom->key_aliases,
                                    (rep->nKeyAliases * XkbKeyNameLength * 2)))
            return BadLength;
        geom->num_key_aliases = rep->nKeyAliases;
        return Success;
    }
    else {                      /* alloc failed, just skip the aliases */
        _XkbSkipReadBufferData(buf, (rep->nKeyAliases * XkbKeyNameLength * 2));
    }
    return rtrn;
}

static Status
_XkbReadGeomColors(XkbReadBufferPtr buf,
                   XkbGeometryPtr geom,
                   xkbGetGeometryReply *rep)
{
    Status rtrn;

    if (rep->nColors < 1)
        return Success;
    if ((rtrn = XkbAllocGeomColors(geom, rep->nColors)) == Success) {
        register int i;

        for (i = 0; i < rep->nColors; i++) {
            char *spec = NULL;
            if (!_XkbGetReadBufferCountedString(buf, &spec))
                rtrn = BadLength;
            else if (XkbAddGeomColor(geom, spec, geom->num_colors) == NULL)
                rtrn = BadAlloc;

            _XkbFree(spec);
            if (rtrn != Success)
                return rtrn;
        }
        return Success;
    }
    return rtrn;
}

static Status
_XkbReadGeomShapes(XkbReadBufferPtr buf,
                   XkbGeometryPtr geom,
                   xkbGetGeometryReply *rep)
{
    register int i;
    Status rtrn;

    if (rep->nShapes < 1)
        return Success;
    if ((rtrn = XkbAllocGeomShapes(geom, rep->nShapes)) != Success)
        return rtrn;
    for (i = 0; i < rep->nShapes; i++) {
        xkbShapeWireDesc *shapeWire;
        XkbShapePtr shape;
        register int o;

        shapeWire = (xkbShapeWireDesc *)
            _XkbGetReadBufferPtr(buf, SIZEOF(xkbShapeWireDesc));
        if (!shapeWire)
            return BadLength;
        shape = XkbAddGeomShape(geom, shapeWire->name, shapeWire->nOutlines);
        if (!shape)
            return BadAlloc;
        for (o = 0; o < shapeWire->nOutlines; o++) {
            xkbOutlineWireDesc *olWire;
            XkbOutlinePtr ol;
            register int p;
            XkbPointPtr pt;

            olWire = (xkbOutlineWireDesc *)
                _XkbGetReadBufferPtr(buf, SIZEOF(xkbOutlineWireDesc));
            if (!olWire)
                return BadLength;
            ol = XkbAddGeomOutline(shape, olWire->nPoints);
            if (!ol)
                return BadAlloc;
            ol->corner_radius = olWire->cornerRadius;
            for (p = 0, pt = ol->points; p < olWire->nPoints; p++, pt++) {
                xkbPointWireDesc *ptWire;

                ptWire = (xkbPointWireDesc *)
                    _XkbGetReadBufferPtr(buf, SIZEOF(xkbPointWireDesc));
                if (!ptWire)
                    return BadLength;
                pt->x = ptWire->x;
                pt->y = ptWire->y;
            }
            ol->num_points = olWire->nPoints;
        }
        if ((shapeWire->primaryNdx != XkbNoShape) &&
            (shapeWire->primaryNdx < shapeWire->nOutlines))
            shape->primary = &shape->outlines[shapeWire->primaryNdx];
        else
            shape->primary = NULL;
        if ((shapeWire->approxNdx != XkbNoShape) &&
            (shapeWire->approxNdx < shapeWire->nOutlines))
            shape->approx = &shape->outlines[shapeWire->approxNdx];
        else
            shape->approx = NULL;
        XkbComputeShapeBounds(shape);
    }
    return Success;
}

static Status
_XkbReadGeomDoodad(XkbReadBufferPtr buf,
                   XkbGeometryPtr geom,
                   XkbSectionPtr section)
{
    XkbDoodadPtr doodad;
    xkbDoodadWireDesc *doodadWire;

    doodadWire = (xkbDoodadWireDesc *)
        _XkbGetReadBufferPtr(buf, SIZEOF(xkbDoodadWireDesc));
    if (!doodadWire)
        return BadLength;
    doodad = XkbAddGeomDoodad(geom, section, doodadWire->any.name);
    if (!doodad)
        return BadAlloc;
    doodad->any.type = doodadWire->any.type;
    doodad->any.priority = doodadWire->any.priority;
    doodad->any.top = doodadWire->any.top;
    doodad->any.left = doodadWire->any.left;
    doodad->any.angle = doodadWire->any.angle;
    switch (doodad->any.type) {
    case XkbOutlineDoodad:
    case XkbSolidDoodad:
        doodad->shape.color_ndx = doodadWire->shape.colorNdx;
        doodad->shape.shape_ndx = doodadWire->shape.shapeNdx;
        break;
    case XkbTextDoodad:
        doodad->text.width = doodadWire->text.width;
        doodad->text.height = doodadWire->text.height;
        doodad->text.color_ndx = doodadWire->text.colorNdx;
        if (!_XkbGetReadBufferCountedString(buf, &doodad->text.text))
            return BadLength;
        if (!_XkbGetReadBufferCountedString(buf, &doodad->text.font))
            return BadLength;
        break;
    case XkbIndicatorDoodad:
        doodad->indicator.shape_ndx = doodadWire->indicator.shapeNdx;
        doodad->indicator.on_color_ndx = doodadWire->indicator.onColorNdx;
        doodad->indicator.off_color_ndx = doodadWire->indicator.offColorNdx;
        break;
    case XkbLogoDoodad:
        doodad->logo.color_ndx = doodadWire->logo.colorNdx;
        doodad->logo.shape_ndx = doodadWire->logo.shapeNdx;
        if (!_XkbGetReadBufferCountedString(buf, &doodad->logo.logo_name))
            return BadLength;
        break;
    default:
        return BadValue;
    }
    return Success;
}

static Status
_XkbReadGeomOverlay(XkbReadBufferPtr buf,
                    XkbGeometryPtr geom,
                    XkbSectionPtr section)
{
    XkbOverlayPtr ol;
    xkbOverlayWireDesc *olWire;
    register int r;

    olWire = (xkbOverlayWireDesc *)
        _XkbGetReadBufferPtr(buf, SIZEOF(xkbOverlayWireDesc));
    if (olWire == NULL)
        return BadLength;
    ol = XkbAddGeomOverlay(section, olWire->name, olWire->nRows);
    if (ol == NULL)
        return BadLength;
    for (r = 0; r < olWire->nRows; r++) {
        register int k;
        XkbOverlayRowPtr row;
        xkbOverlayRowWireDesc *rowWire;
        xkbOverlayKeyWireDesc *keyWire;

        rowWire = (xkbOverlayRowWireDesc *)
            _XkbGetReadBufferPtr(buf, SIZEOF(xkbOverlayRowWireDesc));
        if (rowWire == NULL)
            return BadLength;
        row = XkbAddGeomOverlayRow(ol, rowWire->rowUnder, rowWire->nKeys);
        if (!row)
            return BadAlloc;
        row->row_under = rowWire->rowUnder;
        if (rowWire->nKeys < 1)
            continue;
        keyWire = (xkbOverlayKeyWireDesc *)
            _XkbGetReadBufferPtr(buf,
                             SIZEOF(xkbOverlayKeyWireDesc) * rowWire->nKeys);
        if (keyWire == NULL)
            return BadLength;
        for (k = 0; k < rowWire->nKeys; k++, keyWire++, row->num_keys++) {
            memcpy(row->keys[row->num_keys].over.name, keyWire->over,
                   XkbKeyNameLength);
            memcpy(row->keys[row->num_keys].under.name, keyWire->under,
                   XkbKeyNameLength);
        }
    }
    return Success;
}

static Status
_XkbReadGeomSections(XkbReadBufferPtr buf,
                     XkbGeometryPtr geom,
                     xkbGetGeometryReply *rep)
{
    register int s;
    XkbSectionPtr section;
    xkbSectionWireDesc *sectionWire;
    Status rtrn;

    if (rep->nSections < 1)
        return Success;
    if ((rtrn = XkbAllocGeomSections(geom, rep->nSections)) != Success)
        return rtrn;
    for (s = 0; s < rep->nSections; s++) {
        sectionWire = (xkbSectionWireDesc *)
            _XkbGetReadBufferPtr(buf, SIZEOF(xkbSectionWireDesc));
        if (!sectionWire)
            return BadLength;
        section = XkbAddGeomSection(geom, sectionWire->name, sectionWire->nRows,
                                    sectionWire->nDoodads,
                                    sectionWire->nOverlays);
        if (!section)
            return BadAlloc;
        section->top = sectionWire->top;
        section->left = sectionWire->left;
        section->width = sectionWire->width;
        section->height = sectionWire->height;
        section->angle = sectionWire->angle;
        section->priority = sectionWire->priority;
        if (sectionWire->nRows > 0) {
            register int r;

            for (r = 0; r < sectionWire->nRows; r++) {
                XkbRowPtr row;
                xkbRowWireDesc *rowWire;

                rowWire = (xkbRowWireDesc *)
                    _XkbGetReadBufferPtr(buf, SIZEOF(xkbRowWireDesc));
                if (!rowWire)
                    return BadLength;
                row = XkbAddGeomRow(section, rowWire->nKeys);
                if (!row)
                    return BadAlloc;
                row->top = rowWire->top;
                row->left = rowWire->left;
                row->vertical = rowWire->vertical;
                if (rowWire->nKeys > 0) {
                    register int k;

                    for (k = 0; k < rowWire->nKeys; k++) {
                        XkbKeyPtr key;
                        xkbKeyWireDesc *keyWire;

                        keyWire = (xkbKeyWireDesc *)
                            _XkbGetReadBufferPtr(buf, SIZEOF(xkbKeyWireDesc));
                        if (!keyWire)
                            return BadLength;
                        key = XkbAddGeomKey(row);
                        if (!key)
                            return BadAlloc;
                        memcpy(key->name.name, keyWire->name, XkbKeyNameLength);
                        key->gap = keyWire->gap;
                        key->shape_ndx = keyWire->shapeNdx;
                        key->color_ndx = keyWire->colorNdx;
                    }
                }
            }
        }
        if (sectionWire->nDoodads > 0) {
            register int d;

            for (d = 0; d < sectionWire->nDoodads; d++) {
                if ((rtrn = _XkbReadGeomDoodad(buf, geom, section)) != Success)
                    return rtrn;
            }
        }
        if (sectionWire->nOverlays > 0) {
            register int o;

            for (o = 0; o < sectionWire->nOverlays; o++) {
                if ((rtrn = _XkbReadGeomOverlay(buf, geom, section)) != Success)
                    return rtrn;
            }
        }
    }
    return Success;
}

static Status
_XkbReadGeomDoodads(XkbReadBufferPtr buf,
                    XkbGeometryPtr geom,
                    xkbGetGeometryReply *rep)
{
    register int d;
    Status rtrn;

    if (rep->nDoodads < 1)
        return Success;
    if ((rtrn = XkbAllocGeomDoodads(geom, rep->nDoodads)) != Success)
        return rtrn;
    for (d = 0; d < rep->nDoodads; d++) {
        if ((rtrn = _XkbReadGeomDoodad(buf, geom, NULL)) != Success)
            return rtrn;
    }
    return Success;
}

Status
_XkbReadGetGeometryReply(Display *dpy,
                         xkbGetGeometryReply *rep,
                         XkbDescPtr xkb,
                         int *nread_rtrn)
{
    XkbGeometryPtr geom;

    geom = _XkbTypedCalloc(1, XkbGeometryRec);
    if (!geom)
        return BadAlloc;
    if (xkb->geom)
        XkbFreeGeometry(xkb->geom, XkbGeomAllMask, True);
    xkb->geom = geom;

    geom->name = rep->name;
    geom->width_mm = rep->widthMM;
    geom->height_mm = rep->heightMM;
    if (rep->length) {
        XkbReadBufferRec buf;
        int left;

        if (_XkbInitReadBuffer(dpy, &buf, (int) rep->length * 4)) {
            Status status = Success;

            if (nread_rtrn)
                *nread_rtrn = (int) rep->length * 4;
            if (!_XkbGetReadBufferCountedString(&buf, &geom->label_font))
                status = BadLength;
            if (status == Success)
                status = _XkbReadGeomProperties(&buf, geom, rep);
            if (status == Success)
                status = _XkbReadGeomColors(&buf, geom, rep);
            if (status == Success)
                status = _XkbReadGeomShapes(&buf, geom, rep);
            if (status == Success)
                status = _XkbReadGeomSections(&buf, geom, rep);
            if (status == Success)
                status = _XkbReadGeomDoodads(&buf, geom, rep);
            if (status == Success)
                status = _XkbReadGeomKeyAliases(&buf, geom, rep);
            left = _XkbFreeReadBuffer(&buf);
            if ((rep->baseColorNdx > geom->num_colors) ||
                (rep->labelColorNdx > geom->num_colors))
                status = BadLength;
            if ((status != Success) || left || buf.error) {
                if (status == Success)
                    status = BadLength;
                XkbFreeGeometry(geom, XkbGeomAllMask, True);
                xkb->geom = NULL;
                return status;
            }
            geom->base_color = &geom->colors[rep->baseColorNdx];
            geom->label_color = &geom->colors[rep->labelColorNdx];
        }
        else {
            XkbFreeGeometry(geom, XkbGeomAllMask, True);
            xkb->geom = NULL;
            return BadAlloc;
        }
    }
    return Success;
}

Status
XkbGetGeometry(Display *dpy, XkbDescPtr xkb)
{
    xkbGetGeometryReq *req;
    xkbGetGeometryReply rep;
    Status status;

    if ((!xkb) || (dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;

    LockDisplay(dpy);
    GetReq(kbGetGeometry, req);
    req->reqType = dpy->xkb_info->codes->major_opcode;
    req->xkbReqType = X_kbGetGeometry;
    req->deviceSpec = xkb->device_spec;
    req->name = None;
    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse))
        status = BadImplementation;
    else if (!rep.found)
        status = BadName;
    else
        status = _XkbReadGetGeometryReply(dpy, &rep, xkb, NULL);
    UnlockDisplay(dpy);
    SyncHandle();
    return status;
}

Status
XkbGetNamedGeometry(Display *dpy, XkbDescPtr xkb, Atom name)
{
    xkbGetGeometryReq *req;
    xkbGetGeometryReply rep;
    Status status;

    if ((name == None) || (dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;

    LockDisplay(dpy);
    GetReq(kbGetGeometry, req);
    req->reqType = dpy->xkb_info->codes->major_opcode;
    req->xkbReqType = X_kbGetGeometry;
    req->deviceSpec = xkb->device_spec;
    req->name = (CARD32) name;
    if ((!_XReply(dpy, (xReply *) &rep, 0, xFalse)) || (!rep.found))
        status = BadImplementation;
    else if (!rep.found)
        status = BadName;
    else
        status = _XkbReadGetGeometryReply(dpy, &rep, xkb, NULL);
    UnlockDisplay(dpy);
    SyncHandle();
    return status;
}
@


1.7
log
@Update to libX11 1.6.2. No API change.
@
text
@d272 3
a274 4
            if (name)
                _XkbFree(name);
            if (value)
                _XkbFree(value);
d324 2
a325 2
            if (spec)
                _XkbFree(spec);
a477 1
        row->row_under = rowWire->rowUnder;
d480 1
@


1.6
log
@Merge upstream fixes for several X libs vulnerabilities
discovered by Ilja van Sprundel.

CVE-2013-1981 X.org libX11 1.5.99.901 (1.6 RC1) integer overflows
CVE-2013-1982 X.org libXext 1.3.1 integer overflows
CVE-2013-1983 X.org libXfixes 5.0 integer overflows
CVE-2013-1984 X.org libXi 1.7.1 integer overflows
CVE-2013-1985 X.org libXinerama 1.1.2 integer overflows
CVE-2013-1986 X.org libXrandr 1.4.0 integer overflows
CVE-2013-1987 X.org libXrender 0.9.7 integer overflows
CVE-2013-1988 X.org libXRes 1.0.6 integer overflows
CVE-2013-1989 X.org libXv 1.0.7 integer overflows
CVE-2013-1990 X.org libXvMC 1.0.7 integer overflows
CVE-2013-1991 X.org libXxf86dga 1.1.3 integer overflows
CVE-2013-1992 X.org libdmx 1.1.2 integer overflows
CVE-2013-1994 X.org libchromeXvMC & libchromeXvMCPro in openChrome
0.3.2 integer overflows
CVE-2013-1995 X.org libXi 1.7.1 sign extension issues
CVE-2013-1996 X.org libFS 1.0.4 sign extension issues
CVE-2013-1997 X.org libX11 1.5.99.901 (1.6 RC1) buffer overflows
CVE-2013-1998 X.org libXi 1.7.1 buffer overflows
CVE-2013-1999 X.org libXvMC 1.0.7 buffer overflows
CVE-2013-2000 X.org libXxf86dga 1.1.3 buffer overflows
CVE-2013-2001 X.org libXxf86vm 1.1.2 buffer overflows
CVE-2013-2002 X.org libXt 1.1.3 buffer overflows
CVE-2013-2003 X.org libXcursor 1.1.13 integer overflows
CVE-2013-2004 X.org libX11 1.5.99.901 (1.6 RC1) unbounded recursion
CVE-2013-2005 X.org libXt 1.1.3 memory corruption
CVE-2013-2066 X.org libXv 1.0.7 buffer overflows
@
text
@d50 1
a50 1
_XkbCheckBounds(XkbBoundsPtr bounds,int	x,int y)
d52 8
a59 4
    if (x<bounds->x1)	bounds->x1= x;
    if (x>bounds->x2)	bounds->x2= x;
    if (y<bounds->y1)	bounds->y1= y;
    if (y>bounds->y2)	bounds->y2= y;
d66 15
a80 14
register int	o,p;
XkbOutlinePtr	outline;
XkbPointPtr	pt;

    if ((!shape)||(shape->num_outlines<1))
	return False;
    shape->bounds.x1= shape->bounds.y1= MAXSHORT;
    shape->bounds.x2= shape->bounds.y2= MINSHORT;
    for (outline=shape->outlines,o=0;o<shape->num_outlines;o++,outline++) {
	for (pt=outline->points,p=0;p<outline->num_points;p++,pt++) {
	    _XkbCheckBounds(&shape->bounds,pt->x,pt->y);
	}
        if (outline->num_points<2) {
            _XkbCheckBounds(&shape->bounds,0,0);
d87 1
a87 1
XkbComputeShapeTop(XkbShapePtr shape,XkbBoundsPtr bounds)
d89 13
a101 11
register int	p;
XkbOutlinePtr	outline;
XkbPointPtr	pt;

    if ((!shape)||(shape->num_outlines<1))
	return False;
    if (shape->approx)	outline= shape->approx;
    else		outline= &shape->outlines[shape->num_outlines-1];
    if (outline->num_points<2) {
	 bounds->x1= bounds->y1= 0;
	 bounds->x2= bounds->y2= 0;
d104 2
a105 2
	bounds->x1= bounds->y1= MAXSHORT;
	bounds->x2= bounds->y2= MINSHORT;
d107 2
a108 2
    for (pt=outline->points,p=0;p<outline->num_points;p++,pt++) {
	_XkbCheckBounds(bounds,pt->x,pt->y);
d114 1
a114 1
XkbComputeRowBounds(XkbGeometryPtr geom,XkbSectionPtr section,XkbRowPtr row)
d116 29
a144 29
register int	k,pos;
XkbKeyPtr	key;
XkbBoundsPtr	bounds,sbounds;

    if ((!geom)||(!section)||(!row))
	return False;
    bounds= &row->bounds;
    bzero(bounds,sizeof(XkbBoundsRec));
    for (key=row->keys,pos=k=0;k<row->num_keys;k++,key++) {
	sbounds= &XkbKeyShape(geom,key)->bounds;
	_XkbCheckBounds(bounds,pos,0);
	if (!row->vertical) {
	    if (key->gap!=0) {
		pos+= key->gap;
		_XkbCheckBounds(bounds,pos,0);
	    }
	    _XkbCheckBounds(bounds,pos+sbounds->x1,sbounds->y1);
	    _XkbCheckBounds(bounds,pos+sbounds->x2,sbounds->y2);
	    pos+= sbounds->x2;
	}
	else {
	    if (key->gap!=0) {
		pos+= key->gap;
		_XkbCheckBounds(bounds,0,pos);
	    }
	    _XkbCheckBounds(bounds,pos+sbounds->x1,sbounds->y1);
	    _XkbCheckBounds(bounds,pos+sbounds->x2,sbounds->y2);
	    pos+= sbounds->y2;
	}
d150 1
a150 1
XkbComputeSectionBounds(XkbGeometryPtr geom,XkbSectionPtr section)
d152 52
a203 48
register int	i;
XkbShapePtr	shape;
XkbRowPtr	row;
XkbDoodadPtr	doodad;
XkbBoundsPtr	bounds,rbounds;

    if ((!geom)||(!section))
	return False;
    bounds= &section->bounds;
    bzero(bounds,sizeof(XkbBoundsRec));
    for (i=0,row=section->rows;i<section->num_rows;i++,row++) {
	if (!XkbComputeRowBounds(geom,section,row))
	    return False;
	rbounds= &row->bounds;
	_XkbCheckBounds(bounds,row->left+rbounds->x1,row->top+rbounds->y1);
	_XkbCheckBounds(bounds,row->left+rbounds->x2,row->top+rbounds->y2);
    }
    for (i=0,doodad=section->doodads;i<section->num_doodads;i++,doodad++) {
	static XkbBoundsRec	tbounds;
	switch (doodad->any.type) {
	    case XkbOutlineDoodad:
	    case XkbSolidDoodad:
		shape= XkbShapeDoodadShape(geom,&doodad->shape);
		rbounds= &shape->bounds;
		break;
	    case XkbTextDoodad:
		tbounds.x1= doodad->text.left;
		tbounds.y1= doodad->text.top;
		tbounds.x2= tbounds.x1+doodad->text.width;
		tbounds.y2= tbounds.y1+doodad->text.height;
		rbounds= &tbounds;
		break;
	    case XkbIndicatorDoodad:
		shape= XkbIndicatorDoodadShape(geom,&doodad->indicator);
		rbounds= &shape->bounds;
		break;
	    case XkbLogoDoodad:
		shape= XkbLogoDoodadShape(geom,&doodad->logo);
		rbounds= &shape->bounds;
		break;
	    default:
		tbounds.x1= tbounds.x2= doodad->any.left;
		tbounds.y1= tbounds.y2= doodad->any.top;
		rbounds= &tbounds;
		break;
	}
	_XkbCheckBounds(bounds,rbounds->x1,rbounds->y1);
	_XkbCheckBounds(bounds,rbounds->x2,rbounds->y2);
d211 1
a211 1
XkbFindOverlayForKey(XkbGeometryPtr geom,XkbSectionPtr wanted,char *under)
d213 2
a214 2
int		s;
XkbSectionPtr	section;
d216 2
a217 2
    if ((geom==NULL)||(under==NULL)||(geom->num_sections<1))
	return NULL;
d220 3
a222 2
	 section= wanted;
    else section= geom->sections;
d224 23
a246 21
    for (s=0;s<geom->num_sections;s++,section++) {
	XkbOverlayPtr	ol;
	int		o;

	if (section->num_overlays<1)
	    continue;
	for (o=0,ol=section->overlays;o<section->num_overlays;o++,ol++) {
	    XkbOverlayRowPtr	row;
	    int			r;

	    for (r=0,row=ol->rows;r<ol->num_rows;r++,row++) {
		XkbOverlayKeyPtr	key;
		int			k;
		for (k=0,key=row->keys;k<row->num_keys;k++,key++) {
		    if (strncmp(under,key->under.name,XkbKeyNameLength)==0)
			return key->over.name;
		}
	    }
	}
	if (wanted!=NULL)
	    break;
d254 27
a280 26
_XkbReadGeomProperties(	XkbReadBufferPtr	buf,
			XkbGeometryPtr 		geom,
			xkbGetGeometryReply *	rep)
{
Status	rtrn;

    if (rep->nProperties<1)
	return Success;
    if ((rtrn=XkbAllocGeomProps(geom,rep->nProperties))==Success) {
	register int i;
	register Bool ok;
	char *name,*value;
	ok= True;
	for (i=0;(i<rep->nProperties)&&ok;i++) {
	    name=NULL;
	    value=NULL;
	    ok= _XkbGetReadBufferCountedString(buf,&name)&&ok;
	    ok= _XkbGetReadBufferCountedString(buf,&value)&&ok;
	    ok= ok&&(XkbAddGeomProperty(geom,name,value)!=NULL);
	    if (name)
		_XkbFree(name);
	    if (value)
		_XkbFree(value);
	}
	if (ok)	rtrn= Success;
	else	rtrn= BadLength;
d286 14
a299 14
_XkbReadGeomKeyAliases(	XkbReadBufferPtr	buf,
			XkbGeometryPtr		geom,
			xkbGetGeometryReply *	rep)
{
Status	rtrn;

    if (rep->nKeyAliases<1)
	return Success;
    if ((rtrn=XkbAllocGeomKeyAliases(geom,rep->nKeyAliases))==Success) {
	if (!_XkbCopyFromReadBuffer(buf,(char *)geom->key_aliases,
					(rep->nKeyAliases*XkbKeyNameLength*2)))
	    return BadLength;
	geom->num_key_aliases= rep->nKeyAliases;
	return Success;
d301 2
a302 2
    else { /* alloc failed, just skip the aliases */
	_XkbSkipReadBufferData(buf,(rep->nKeyAliases*XkbKeyNameLength*2));
d308 23
a330 23
_XkbReadGeomColors(	XkbReadBufferPtr	buf,
			XkbGeometryPtr		geom,
			xkbGetGeometryReply *	rep)
{
Status	rtrn;

    if (rep->nColors<1)
	return Success;
    if ((rtrn=XkbAllocGeomColors(geom,rep->nColors))==Success) {
	register int i;
	char *spec;
	for (i=0;i<rep->nColors;i++) {
	    spec = NULL;
	    if (!_XkbGetReadBufferCountedString(buf,&spec))
		rtrn = BadLength;
	    else if (XkbAddGeomColor(geom,spec,geom->num_colors)==NULL)
		rtrn = BadAlloc;
	    if (spec)
		_XkbFree(spec);
	    if (rtrn != Success)
		return rtrn;
	}
	return Success;
d336 60
a395 57
_XkbReadGeomShapes(	XkbReadBufferPtr	buf,
			XkbGeometryPtr		geom,
			xkbGetGeometryReply *	rep)
{
register int i;
Status	rtrn;

    if (rep->nShapes<1)
	return Success;
    if ((rtrn=XkbAllocGeomShapes(geom,rep->nShapes))!=Success)
	return rtrn;
    for (i=0;i<rep->nShapes;i++) {
	xkbShapeWireDesc *shapeWire;
	XkbShapePtr	 shape;
	register int	 o;
	shapeWire= (xkbShapeWireDesc *)
		   _XkbGetReadBufferPtr(buf,SIZEOF(xkbShapeWireDesc));
	if (!shapeWire)
	    return BadLength;
	shape= XkbAddGeomShape(geom,shapeWire->name,shapeWire->nOutlines);
	if (!shape)
	   return BadAlloc;
	for (o=0;o<shapeWire->nOutlines;o++) {
	    xkbOutlineWireDesc *olWire;
	    XkbOutlinePtr	ol;
	    register int	p;
	    XkbPointPtr		pt;
	    olWire=  (xkbOutlineWireDesc *)
		 _XkbGetReadBufferPtr(buf,SIZEOF(xkbOutlineWireDesc));
	    if (!olWire)
		return BadLength;
	    ol= XkbAddGeomOutline(shape,olWire->nPoints);
	    if (!ol)
		return BadAlloc;
	    ol->corner_radius=  olWire->cornerRadius;
	    for (p=0,pt=ol->points;p<olWire->nPoints;p++,pt++) {
		xkbPointWireDesc *	ptWire;
		ptWire= (xkbPointWireDesc *)
		    _XkbGetReadBufferPtr(buf,SIZEOF(xkbPointWireDesc));
		if (!ptWire)
		    return BadLength;
		pt->x= ptWire->x;
		pt->y= ptWire->y;
	    }
	    ol->num_points= olWire->nPoints;
	}
	if ((shapeWire->primaryNdx!=XkbNoShape) &&
	    (shapeWire->primaryNdx < shapeWire->nOutlines))
	     shape->primary= &shape->outlines[shapeWire->primaryNdx];
	else
	    shape->primary= NULL;
	if ((shapeWire->approxNdx!=XkbNoShape) &&
	    (shapeWire->approxNdx < shapeWire->nOutlines))
	     shape->approx= &shape->outlines[shapeWire->approxNdx];
	else
	    shape->approx= NULL;
	XkbComputeShapeBounds(shape);
d401 3
a403 3
_XkbReadGeomDoodad(	XkbReadBufferPtr 	buf,
			XkbGeometryPtr 		geom,
			XkbSectionPtr 		section)
d405 2
a406 2
XkbDoodadPtr		doodad;
xkbDoodadWireDesc *	doodadWire;
d408 2
a409 2
    doodadWire= (xkbDoodadWireDesc *)
		   _XkbGetReadBufferPtr(buf,SIZEOF(xkbDoodadWireDesc));
d411 2
a412 2
	return 	BadLength;
    doodad= XkbAddGeomDoodad(geom,section,doodadWire->any.name);
d414 6
a419 6
	return BadAlloc;
    doodad->any.type= doodadWire->any.type;
    doodad->any.priority= doodadWire->any.priority;
    doodad->any.top= doodadWire->any.top;
    doodad->any.left= doodadWire->any.left;
    doodad->any.angle= doodadWire->any.angle;
d421 27
a447 27
	case XkbOutlineDoodad:
	case XkbSolidDoodad:
	    doodad->shape.color_ndx= doodadWire->shape.colorNdx;
	    doodad->shape.shape_ndx= doodadWire->shape.shapeNdx;
	    break;
	case XkbTextDoodad:
	    doodad->text.width= doodadWire->text.width;
	    doodad->text.height= doodadWire->text.height;
	    doodad->text.color_ndx= doodadWire->text.colorNdx;
	    if (!_XkbGetReadBufferCountedString(buf,&doodad->text.text))
		return BadLength;
	    if (!_XkbGetReadBufferCountedString(buf,&doodad->text.font))
		return BadLength;
	    break;
	case XkbIndicatorDoodad:
	    doodad->indicator.shape_ndx= doodadWire->indicator.shapeNdx;
	    doodad->indicator.on_color_ndx= doodadWire->indicator.onColorNdx;
	    doodad->indicator.off_color_ndx= doodadWire->indicator.offColorNdx;
	    break;
	case XkbLogoDoodad:
	    doodad->logo.color_ndx= doodadWire->logo.colorNdx;
	    doodad->logo.shape_ndx= doodadWire->logo.shapeNdx;
	    if (!_XkbGetReadBufferCountedString(buf,&doodad->logo.logo_name))
		return BadLength;
	    break;
	default:
	    return BadValue;
d453 42
a494 41
_XkbReadGeomOverlay(	XkbReadBufferPtr	buf,
			XkbGeometryPtr		geom,
			XkbSectionPtr		section)
{
XkbOverlayPtr		ol;
xkbOverlayWireDesc *	olWire;
register int		r;

    olWire= (xkbOverlayWireDesc *)
		   _XkbGetReadBufferPtr(buf,SIZEOF(xkbOverlayWireDesc));
    if (olWire==NULL)
	return BadLength;
    ol= XkbAddGeomOverlay(section,olWire->name,olWire->nRows);
    if (ol==NULL)
	return BadLength;
    for (r=0;r<olWire->nRows;r++) {
	register int 			k;
	XkbOverlayRowPtr		row;
	xkbOverlayRowWireDesc *		rowWire;
	xkbOverlayKeyWireDesc *		keyWire;
	rowWire= (xkbOverlayRowWireDesc *)
			_XkbGetReadBufferPtr(buf,SIZEOF(xkbOverlayRowWireDesc));
	if (rowWire==NULL)
	    return BadLength;
	row= XkbAddGeomOverlayRow(ol,rowWire->rowUnder,rowWire->nKeys);
	row->row_under= rowWire->rowUnder;
	if (!row)
	    return BadAlloc;
	if (rowWire->nKeys<1)
	    continue;
	keyWire= (xkbOverlayKeyWireDesc *)
     			_XkbGetReadBufferPtr(buf,
				SIZEOF(xkbOverlayKeyWireDesc)*rowWire->nKeys);
	if (keyWire==NULL)
	    return BadLength;
	for (k=0;k<rowWire->nKeys;k++,keyWire++,row->num_keys++) {
	    memcpy(row->keys[row->num_keys].over.name,keyWire->over,
	    						XkbKeyNameLength);
	    memcpy(row->keys[row->num_keys].under.name,keyWire->under,
	    						XkbKeyNameLength);
	}
d500 84
a583 78
_XkbReadGeomSections(	XkbReadBufferPtr	buf,
			XkbGeometryPtr		geom,
			xkbGetGeometryReply *	rep)
{
register int 		s;
XkbSectionPtr		section;
xkbSectionWireDesc *	sectionWire;
Status			rtrn;

    if (rep->nSections<1)
	return Success;
    if ((rtrn=XkbAllocGeomSections(geom,rep->nSections))!=Success)
	return rtrn;
    for (s=0;s<rep->nSections;s++) {
	sectionWire= (xkbSectionWireDesc *)
			_XkbGetReadBufferPtr(buf,SIZEOF(xkbSectionWireDesc));
	if (!sectionWire)
	    return BadLength;
	section= XkbAddGeomSection(geom,sectionWire->name,sectionWire->nRows,
						sectionWire->nDoodads,
						sectionWire->nOverlays);
	if (!section)
	    return BadAlloc;
	section->top= sectionWire->top;
	section->left= sectionWire->left;
	section->width= sectionWire->width;
	section->height= sectionWire->height;
	section->angle= sectionWire->angle;
	section->priority= sectionWire->priority;
	if (sectionWire->nRows>0) {
	    register int 	r;
	    XkbRowPtr		row;
	    xkbRowWireDesc *	rowWire;
	    for (r=0;r<sectionWire->nRows;r++) {
		rowWire= (xkbRowWireDesc *)
			 _XkbGetReadBufferPtr(buf,SIZEOF(xkbRowWireDesc));
		if (!rowWire)
		    return BadLength;
		row= XkbAddGeomRow(section,rowWire->nKeys);
		if (!row)
		    return BadAlloc;
		row->top= rowWire->top;
		row->left= rowWire->left;
		row->vertical= rowWire->vertical;
		if (rowWire->nKeys>0) {
		    register int	k;
		    XkbKeyPtr		key;
		    xkbKeyWireDesc *	keyWire;
		    for (k=0;k<rowWire->nKeys;k++) {
			keyWire= (xkbKeyWireDesc *)
			      _XkbGetReadBufferPtr(buf,SIZEOF(xkbKeyWireDesc));
			if (!keyWire)
			    return BadLength;
			key= XkbAddGeomKey(row);
			if (!key)
			    return BadAlloc;
			memcpy(key->name.name,keyWire->name,XkbKeyNameLength);
			key->gap= keyWire->gap;
			key->shape_ndx= keyWire->shapeNdx;
			key->color_ndx= keyWire->colorNdx;
		    }
		}
	    }
	}
	if (sectionWire->nDoodads>0) {
	    register int d;
	    for (d=0;d<sectionWire->nDoodads;d++) {
		if ((rtrn=_XkbReadGeomDoodad(buf,geom,section))!=Success)
		    return rtrn;
	    }
	}
	if (sectionWire->nOverlays>0) {
	    register int o;
	    for (o=0;o<sectionWire->nOverlays;o++) {
		if ((rtrn=_XkbReadGeomOverlay(buf,geom,section))!=Success)
		    return rtrn;
	    }
	}
d589 14
a602 14
_XkbReadGeomDoodads(	XkbReadBufferPtr	buf,
			XkbGeometryPtr		geom,
			xkbGetGeometryReply *	rep)
{
register int d;
Status	rtrn;

    if (rep->nDoodads<1)
	return Success;
    if ((rtrn=XkbAllocGeomDoodads(geom,rep->nDoodads))!=Success)
	return rtrn;
    for (d=0;d<rep->nDoodads;d++) {
	if ((rtrn=_XkbReadGeomDoodad(buf,geom,NULL))!=Success)
	    return rtrn;
d608 4
a611 4
_XkbReadGetGeometryReply(	Display * dpy,
				xkbGetGeometryReply * rep,
				XkbDescPtr xkb,
				int * nread_rtrn)
d613 1
a613 1
XkbGeometryPtr	geom;
d615 1
a615 1
    geom= _XkbTypedCalloc(1,XkbGeometryRec);
d617 1
a617 1
	return BadAlloc;
d619 2
a620 2
	XkbFreeGeometry(xkb->geom,XkbGeomAllMask,True);
    xkb->geom= geom;
d622 3
a624 3
    geom->name= rep->name;
    geom->width_mm= rep->widthMM;
    geom->height_mm= rep->heightMM;
d626 41
a666 39
	XkbReadBufferRec	buf;
	int			left;
	if (_XkbInitReadBuffer(dpy,&buf,(int)rep->length*4)) {
	    Status status= Success;
	    if (nread_rtrn)
		*nread_rtrn= (int)rep->length*4;
	    if (!_XkbGetReadBufferCountedString(&buf,&geom->label_font))
		status= BadLength;
	    if (status==Success)
		status= _XkbReadGeomProperties(&buf,geom,rep);
	    if (status==Success)
		status= _XkbReadGeomColors(&buf,geom,rep);
	    if (status==Success)
		status= _XkbReadGeomShapes(&buf,geom,rep);
	    if (status==Success)
		status= _XkbReadGeomSections(&buf,geom,rep);
	    if (status==Success)
		status= _XkbReadGeomDoodads(&buf,geom,rep);
	    if (status==Success)
		status= _XkbReadGeomKeyAliases(&buf,geom,rep);
	    left= _XkbFreeReadBuffer(&buf);
	    if ((rep->baseColorNdx > geom->num_colors) ||
		(rep->labelColorNdx > geom->num_colors))
		status = BadLength;
	    if ((status!=Success) || left || buf.error) {
		if (status==Success)
		    status= BadLength;
		XkbFreeGeometry(geom,XkbGeomAllMask,True);
		xkb->geom= NULL;
		return status;
	    }
	    geom->base_color= &geom->colors[rep->baseColorNdx];
	    geom->label_color= &geom->colors[rep->labelColorNdx];
	}
	else {
	    XkbFreeGeometry(geom,XkbGeomAllMask,True);
	    xkb->geom= NULL;
	    return BadAlloc;
	}
d672 1
a672 1
XkbGetGeometry(Display *dpy,XkbDescPtr xkb)
d674 7
a680 7
xkbGetGeometryReq	*req;
xkbGetGeometryReply	 rep;
Status			 status;

    if ( (!xkb) || (dpy->flags & XlibDisplayNoXkb) ||
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
d687 3
a689 3
    req->name= None;
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse))
	status = BadImplementation;
d691 1
a691 1
	status = BadName;
d693 1
a693 1
	status = _XkbReadGetGeometryReply(dpy,&rep,xkb,NULL);
d700 1
a700 1
XkbGetNamedGeometry(Display *dpy,XkbDescPtr xkb,Atom name)
d702 7
a708 7
xkbGetGeometryReq	*req;
xkbGetGeometryReply	 rep;
Status			 status;

    if ( (name==None) || (dpy->flags & XlibDisplayNoXkb) ||
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)) )
	return BadAccess;
d715 3
a717 3
    req->name= (CARD32)name;
    if ((!_XReply(dpy, (xReply *)&rep, 0, xFalse))||(!rep.found))
	status = BadImplementation;
d719 1
a719 1
	status = BadName;
d721 1
a721 1
	status = _XkbReadGetGeometryReply(dpy,&rep,xkb,NULL);
a725 1

@


1.5
log
@Update to libX11 1.4.4. Tested by ajacoutot@@, shadchin@@.
@
text
@d367 2
a368 1
	if (shapeWire->primaryNdx!=XkbNoShape)
d370 4
a373 2
	else shape->primary= NULL;
	if (shapeWire->approxNdx!=XkbNoShape)
d375 2
a376 1
	else shape->approx= NULL;
d622 3
@


1.4
log
@Update to libx11 1.4.2. Tested by ajacoutot@@, jasper@@ krw@@, landry@@,
shadchin@@ on various architectures.
Bump major.
@
text
@a114 1
    pos= 0;
d149 1
a149 1
XkbBoundsPtr	bounds,rbounds=NULL;
d188 1
@


1.3
log
@Update to libX11 1.3.3. Tested on a bulk ports build by naddy@@.
@
text
@a33 2
#define NEED_EVENTS
#define NEED_REPLIES
@


1.2
log
@update to libX11 1.2.1
@
text
@a0 1
/* $Xorg: XKBGeom.c,v 1.4 2000/08/17 19:45:01 cpqbld Exp $ */
a25 1
/* $XFree86: xc/lib/X11/XKBGeom.c,v 1.5 2003/04/13 19:22:18 dawes Exp $ */
@


1.1
log
@Initial revision
@
text
@d10 2
a11 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d13 1
a13 1
Silicon Graphics makes no representation about the suitability 
d17 2
a18 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d20 3
a22 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d623 1
a623 1
		if (status==Success)	
d651 1
a651 1
    
d679 1
a679 1
    
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
