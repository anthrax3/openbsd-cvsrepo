head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.12
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.10
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.8
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.6
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.10
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.8
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_1_3:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	v1_0_99_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.09.28.17.03.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.30.19.19.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.18.19.37.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.12.59.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.16.37.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.16.37.34;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to libX11 1.6.2. No API change.
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdio.h>
#include "Xlibint.h"
#include <X11/extensions/XKBproto.h>
#include "XKBlibint.h"

static int
_XkbSizeKeyTypes(XkbDescPtr xkb, xkbSetMapReq *req)
{
    XkbKeyTypePtr map;
    int i, len;

    if (((req->present & XkbKeyTypesMask) == 0) || (req->nTypes == 0)) {
        req->present &= ~XkbKeyTypesMask;
        req->firstType = req->nTypes = 0;
        return 0;
    }
    len = 0;
    map = &xkb->map->types[req->firstType];
    for (i = 0; i < req->nTypes; i++, map++) {
        len += SIZEOF(xkbKeyTypeWireDesc);
        len += map->map_count * SIZEOF(xkbKTSetMapEntryWireDesc);
        if (map->preserve)
            len += map->map_count * SIZEOF(xkbModsWireDesc);
    }
    return len;
}

static void
_XkbWriteKeyTypes(Display *dpy, XkbDescPtr xkb, xkbSetMapReq *req)
{
    char *buf;
    XkbKeyTypePtr type;
    int i, n;
    xkbKeyTypeWireDesc *desc;

    if ((req->present & XkbKeyTypesMask) == 0)
        return;
    type = &xkb->map->types[req->firstType];
    for (i = 0; i < req->nTypes; i++, type++) {
        int sz = SIZEOF(xkbKeyTypeWireDesc);
        sz += type->map_count * SIZEOF(xkbKTSetMapEntryWireDesc);
        if (type->preserve)
            sz += type->map_count * SIZEOF(xkbModsWireDesc);
        BufAlloc(xkbKeyTypeWireDesc *, desc, sz);
        desc->mask = type->mods.mask;
        desc->realMods = type->mods.real_mods;
        desc->virtualMods = type->mods.vmods;
        desc->numLevels = type->num_levels;
        desc->nMapEntries = type->map_count;
        desc->preserve = (type->preserve != NULL);
        buf = (char *) &desc[1];
        if (desc->nMapEntries > 0) {
            xkbKTSetMapEntryWireDesc *wire = (xkbKTSetMapEntryWireDesc *) buf;

            for (n = 0; n < type->map_count; n++, wire++) {
                wire->level = type->map[n].level;
                wire->realMods = type->map[n].mods.real_mods;
                wire->virtualMods = type->map[n].mods.vmods;
            }
            buf = (char *) wire;
            if (type->preserve) {
                xkbModsWireDesc *pwire = (xkbModsWireDesc *) buf;

                for (n = 0; n < type->map_count; n++, pwire++) {
                    pwire->realMods = type->preserve[n].real_mods;
                    pwire->virtualMods = type->preserve[n].vmods;
                }
            }
        }
    }
    return;
}

static int
_XkbSizeKeySyms(XkbDescPtr xkb, xkbSetMapReq *req)
{
    int i, len;
    unsigned nSyms;

    if (((req->present & XkbKeySymsMask) == 0) || (req->nKeySyms == 0)) {
        req->present &= ~XkbKeySymsMask;
        req->firstKeySym = req->nKeySyms = 0;
        req->totalSyms = 0;
        return 0;
    }
    len = (int) (req->nKeySyms * sizeof(XkbSymMapRec));
    for (i = nSyms = 0; i < req->nKeySyms; i++) {
        nSyms += XkbKeyNumSyms(xkb, i + req->firstKeySym);
    }
    len += nSyms * sizeof(CARD32);
    req->totalSyms = nSyms;
    return len;
}

static void
_XkbWriteKeySyms(Display *dpy, XkbDescPtr xkb, xkbSetMapReq *req)
{
    register KeySym *pSym;
    CARD32 *outSym;
    XkbSymMapPtr symMap;
    xkbSymMapWireDesc *desc;
    register int i;

    if ((req->present & XkbKeySymsMask) == 0)
        return;
    symMap = &xkb->map->key_sym_map[req->firstKeySym];
    for (i = 0; i < req->nKeySyms; i++, symMap++) {
        BufAlloc(xkbSymMapWireDesc *, desc,
                 SIZEOF(xkbSymMapWireDesc) +
                 (XkbKeyNumSyms(xkb, i + req->firstKeySym) * sizeof(CARD32)));
        desc->ktIndex[0] = symMap->kt_index[0];
        desc->ktIndex[1] = symMap->kt_index[1];
        desc->ktIndex[2] = symMap->kt_index[2];
        desc->ktIndex[3] = symMap->kt_index[3];
        desc->groupInfo = symMap->group_info;
        desc->width = symMap->width;
        desc->nSyms = XkbKeyNumSyms(xkb, i + req->firstKeySym);
        outSym = (CARD32 *) &desc[1];
        if (desc->nSyms > 0) {
            pSym = XkbKeySymsPtr(xkb, i + req->firstKeySym);
            _XkbWriteCopyKeySyms(pSym, outSym, desc->nSyms);
        }
    }
    return;
}

static int
_XkbSizeKeyActions(XkbDescPtr xkb, xkbSetMapReq *req)
{
    int i, len, nActs;

    if (((req->present & XkbKeyActionsMask) == 0) || (req->nKeyActs == 0)) {
        req->present &= ~XkbKeyActionsMask;
        req->firstKeyAct = req->nKeyActs = 0;
        req->totalActs = 0;
        return 0;
    }
    for (nActs = i = 0; i < req->nKeyActs; i++) {
        if (xkb->server->key_acts[i + req->firstKeyAct] != 0)
            nActs += XkbKeyNumActions(xkb, i + req->firstKeyAct);
    }
    len = XkbPaddedSize(req->nKeyActs) + (nActs * SIZEOF(xkbActionWireDesc));
    req->totalActs = nActs;
    return len;
}

static void
_XkbWriteKeyActions(Display *dpy, XkbDescPtr xkb, xkbSetMapReq *req)
{
    register int i;
    int n;
    CARD8 *numDesc;
    XkbAction *actDesc;

    if ((req->present & XkbKeyActionsMask) == 0)
        return;
    n = XkbPaddedSize(req->nKeyActs);
    n += (req->totalActs * SIZEOF(xkbActionWireDesc));

    BufAlloc(CARD8 *, numDesc, n);
    for (i = 0; i < req->nKeyActs; i++) {
        if (xkb->server->key_acts[i + req->firstKeyAct] == 0)
            numDesc[i] = 0;
        else
            numDesc[i] = XkbKeyNumActions(xkb, (i + req->firstKeyAct));
    }
    actDesc = (XkbAction *) &numDesc[XkbPaddedSize(req->nKeyActs)];
    for (i = 0; i < req->nKeyActs; i++) {
        if (xkb->server->key_acts[i + req->firstKeyAct] != 0) {
            n = XkbKeyNumActions(xkb, (i + req->firstKeyAct));
            memcpy(actDesc, XkbKeyActionsPtr(xkb, (i + req->firstKeyAct)),
                   n * SIZEOF(xkbActionWireDesc));
            actDesc += n;
        }
    }
    return;
}

static int
_XkbSizeKeyBehaviors(XkbDescPtr xkb, xkbSetMapReq *req)
{
    register int i, first, last, nFound;

    if (((req->present & XkbKeyBehaviorsMask) == 0) || (req->nKeyBehaviors < 1)) {
        req->present &= ~XkbKeyBehaviorsMask;
        req->firstKeyBehavior = req->nKeyBehaviors = 0;
        req->totalKeyBehaviors = 0;
        return 0;
    }
    first = req->firstKeyBehavior;
    last = first + req->nKeyBehaviors - 1;
    for (i = first, nFound = 0; i <= last; i++) {
        if (xkb->server->behaviors[i].type != XkbKB_Default)
            nFound++;
    }
    req->totalKeyBehaviors = nFound;
    return (nFound * SIZEOF(xkbBehaviorWireDesc));
}

static void
_XkbWriteKeyBehaviors(Display *dpy, XkbDescPtr xkb, xkbSetMapReq *req)
{
    register int i, first, last;
    xkbBehaviorWireDesc *wire;
    char *buf;

    if ((req->present & XkbKeyBehaviorsMask) == 0)
        return;
    first = req->firstKeyBehavior;
    last = first + req->nKeyBehaviors - 1;

    i = req->totalKeyBehaviors * SIZEOF(xkbBehaviorWireDesc);
    BufAlloc(char *, buf, i);
    wire = (xkbBehaviorWireDesc *) buf;
    for (i = first; i <= last; i++) {
        if (xkb->server->behaviors[i].type != XkbKB_Default) {
            wire->key = i;
            wire->type = xkb->server->behaviors[i].type;
            wire->data = xkb->server->behaviors[i].data;
            buf += SIZEOF(xkbBehaviorWireDesc);
            wire = (xkbBehaviorWireDesc *) buf;
        }
    }
    return;
}

static unsigned
_XkbSizeVirtualMods(xkbSetMapReq *req)
{
    register int i, bit, nMods;

    if (((req->present & XkbVirtualModsMask) == 0) || (req->virtualMods == 0)) {
        req->present &= ~XkbVirtualModsMask;
        req->virtualMods = 0;
        return 0;
    }
    for (i = nMods = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
        if (req->virtualMods & bit)
            nMods++;
    }
    return XkbPaddedSize(nMods);
}

static void
_XkbWriteVirtualMods(Display *dpy,
                     XkbDescPtr xkb,
                     xkbSetMapReq *req,
                     unsigned size)
{
    register int i, bit;
    CARD8 *vmods;

    /* This was req->present&XkbVirtualModsMask==0, and '==' beats '&' */
    if (((req->present & XkbVirtualModsMask) == 0) || (size < 1))
        return;
    BufAlloc(CARD8 *, vmods, size);
    for (i = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
        if (req->virtualMods & bit)
            *vmods++ = xkb->server->vmods[i];
    }
    return;
}

static int
_XkbSizeKeyExplicit(XkbDescPtr xkb, xkbSetMapReq *req)
{
    register int i, first, last, nFound;

    if (((req->present & XkbExplicitComponentsMask) == 0) ||
        (req->nKeyExplicit == 0)) {
        req->present &= ~XkbExplicitComponentsMask;
        req->firstKeyExplicit = req->nKeyExplicit = 0;
        req->totalKeyExplicit = 0;
        return 0;
    }
    first = req->firstKeyExplicit;
    last = first + req->nKeyExplicit - 1;

    for (i = first, nFound = 0; i <= last; i++) {
        if (xkb->server->explicit[i] != 0)
            nFound++;
    }
    req->totalKeyExplicit = nFound;
    return XkbPaddedSize((nFound * 2));
}

static void
_XkbWriteKeyExplicit(Display *dpy, XkbDescPtr xkb, xkbSetMapReq *req)
{
    register int i, first, last;
    CARD8 *wire;

    if ((req->present & XkbExplicitComponentsMask) == 0)
        return;
    first = req->firstKeyExplicit;
    last = first + req->nKeyExplicit - 1;
    i = XkbPaddedSize((req->totalKeyExplicit * 2));
    BufAlloc(CARD8 *, wire, i);
    for (i = first; i <= last; i++) {
        if (xkb->server->explicit[i] != 0) {
            wire[0] = i;
            wire[1] = xkb->server->explicit[i];
            wire += 2;
        }
    }
    return;
}

static int
_XkbSizeModifierMap(XkbDescPtr xkb, xkbSetMapReq *req)
{
    register int i, first, last, nFound;

    if (((req->present & XkbModifierMapMask) == 0) || (req->nModMapKeys == 0)) {
        req->present &= ~XkbModifierMapMask;
        req->firstModMapKey = req->nModMapKeys = 0;
        req->totalModMapKeys = 0;
        return 0;
    }
    first = req->firstModMapKey;
    last = first + req->nModMapKeys - 1;

    for (i = first, nFound = 0; i <= last; i++) {
        if (xkb->map->modmap[i] != 0)
            nFound++;
    }
    req->totalModMapKeys = nFound;
    return XkbPaddedSize((nFound * 2));
}

static void
_XkbWriteModifierMap(Display *dpy, XkbDescPtr xkb, xkbSetMapReq *req)
{
    register int i, first, last;
    CARD8 *wire;

    if ((req->present & XkbModifierMapMask) == 0)
        return;
    first = req->firstModMapKey;
    last = first + req->nModMapKeys - 1;
    if (req->totalModMapKeys > 0) {
        i = XkbPaddedSize((req->totalModMapKeys * 2));
        BufAlloc(CARD8 *, wire, i);

        for (i = first; i <= last; i++) {
            if (xkb->map->modmap[i] != 0) {
                wire[0] = i;
                wire[1] = xkb->map->modmap[i];
                wire += 2;
            }
        }
    }
    return;
}

static int
_XkbSizeVirtualModMap(XkbDescPtr xkb, xkbSetMapReq *req)
{
    register int i, first, last, nFound;

    if (((req->present & XkbVirtualModMapMask) == 0) ||
        (req->nVModMapKeys == 0)) {
        req->present &= ~XkbVirtualModMapMask;
        req->firstVModMapKey = req->nVModMapKeys = 0;
        req->totalVModMapKeys = 0;
        return 0;
    }
    first = req->firstVModMapKey;
    last = first + req->nVModMapKeys - 1;

    for (i = first, nFound = 0; i <= last; i++) {
        if (xkb->server->vmodmap[i] != 0)
            nFound++;
    }
    req->totalVModMapKeys = nFound;
    return nFound * SIZEOF(xkbVModMapWireDesc);
}

static void
_XkbWriteVirtualModMap(Display *dpy, XkbDescPtr xkb, xkbSetMapReq *req)
{
    register int i, first, last;
    xkbVModMapWireDesc *wire;

    if ((req->present & XkbVirtualModMapMask) == 0)
        return;
    first = req->firstVModMapKey;
    last = first + req->nVModMapKeys - 1;
    if (req->totalVModMapKeys > 0) {
        i = req->totalVModMapKeys * SIZEOF(xkbVModMapWireDesc);
        BufAlloc(xkbVModMapWireDesc *, wire, i);
        for (i = first; i <= last; i++) {
            if (xkb->server->vmodmap[i] != 0) {
                wire->key = i;
                wire->vmods = xkb->server->vmodmap[i];
                wire++;
            }
        }
    }
    return;
}

static void
SendSetMap(Display *dpy, XkbDescPtr xkb, xkbSetMapReq *req)
{
    xkbSetMapReq tmp;
    unsigned szMods;

    req->length += _XkbSizeKeyTypes(xkb, req) / 4;
    req->length += _XkbSizeKeySyms(xkb, req) / 4;
    req->length += _XkbSizeKeyActions(xkb, req) / 4;
    req->length += _XkbSizeKeyBehaviors(xkb, req) / 4;
    szMods = _XkbSizeVirtualMods(req);
    req->length += szMods / 4;
    req->length += _XkbSizeKeyExplicit(xkb, req) / 4;
    req->length += _XkbSizeModifierMap(xkb, req) / 4;
    req->length += _XkbSizeVirtualModMap(xkb, req) / 4;

    tmp = *req;
    if (tmp.nTypes > 0)
        _XkbWriteKeyTypes(dpy, xkb, &tmp);
    if (tmp.nKeySyms > 0)
        _XkbWriteKeySyms(dpy, xkb, &tmp);
    if (tmp.nKeyActs)
        _XkbWriteKeyActions(dpy, xkb, &tmp);
    if (tmp.totalKeyBehaviors > 0)
        _XkbWriteKeyBehaviors(dpy, xkb, &tmp);
    if (tmp.virtualMods)
        _XkbWriteVirtualMods(dpy, xkb, &tmp, szMods);
    if (tmp.totalKeyExplicit > 0)
        _XkbWriteKeyExplicit(dpy, xkb, &tmp);
    if (tmp.totalModMapKeys > 0)
        _XkbWriteModifierMap(dpy, xkb, &tmp);
    if (tmp.totalVModMapKeys > 0)
        _XkbWriteVirtualModMap(dpy, xkb, &tmp);
    return;
}

Bool
XkbSetMap(Display *dpy, unsigned which, XkbDescPtr xkb)
{
    register xkbSetMapReq *req;
    XkbInfoPtr xkbi;
    XkbServerMapPtr srv;
    XkbClientMapPtr map;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)) || (!xkb))
        return False;
    map = xkb->map;
    srv = xkb->server;

    if (((which & XkbKeyTypesMask) && ((!map) || (!map->types))) ||
        ((which & XkbKeySymsMask) &&
         ((!map) || (!map->syms) || (!map->key_sym_map))) ||
        ((which & XkbKeyActionsMask) && ((!srv) || (!srv->key_acts))) ||
        ((which & XkbKeyBehaviorsMask) && ((!srv) || (!srv->behaviors))) ||
        ((which & XkbVirtualModsMask) && (!srv)) ||
        ((which & XkbExplicitComponentsMask) && ((!srv) || (!srv->explicit))) ||
        ((which & XkbModifierMapMask) && ((!map) || (!map->modmap))) ||
        ((which & XkbVirtualModMapMask) && ((!srv) || (!srv->vmodmap))))
        return False;

    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbSetMap, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbSetMap;
    req->deviceSpec = xkb->device_spec;
    req->present = which;
    req->flags = XkbSetMapAllFlags;
    req->minKeyCode = xkb->min_key_code;
    req->maxKeyCode = xkb->max_key_code;
    req->firstType = 0;
    if (which & XkbKeyTypesMask)
        req->nTypes = map->num_types;
    else
        req->nTypes = 0;
    if (which & XkbKeySymsMask) {
        req->firstKeySym = xkb->min_key_code;
        req->nKeySyms = XkbNumKeys(xkb);
    }
    if (which & XkbKeyActionsMask) {
        req->firstKeyAct = xkb->min_key_code;
        req->nKeyActs = XkbNumKeys(xkb);
    }
    if (which & XkbKeyBehaviorsMask) {
        req->firstKeyBehavior = xkb->min_key_code;
        req->nKeyBehaviors = XkbNumKeys(xkb);
    }
    if (which & XkbVirtualModsMask)
        req->virtualMods = ~0;
    if (which & XkbExplicitComponentsMask) {
        req->firstKeyExplicit = xkb->min_key_code;
        req->nKeyExplicit = XkbNumKeys(xkb);
    }
    if (which & XkbModifierMapMask) {
        req->firstModMapKey = xkb->min_key_code;
        req->nModMapKeys = XkbNumKeys(xkb);
    }
    if (which & XkbVirtualModMapMask) {
        req->firstVModMapKey = xkb->min_key_code;
        req->nVModMapKeys = XkbNumKeys(xkb);
    }
    SendSetMap(dpy, xkb, req);
    UnlockDisplay(dpy);
    SyncHandle();
    return True;
}

Bool
XkbChangeMap(Display *dpy, XkbDescPtr xkb, XkbMapChangesPtr changes)
{
    register xkbSetMapReq *req;
    XkbInfoPtr xkbi;
    XkbServerMapPtr srv;
    XkbClientMapPtr map;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)) ||
        (!xkb) || (!changes))
        return False;
    srv = xkb->server;
    map = xkb->map;

    if (((changes->changed & XkbKeyTypesMask) && ((!map) || (!map->types))) ||
        ((changes->changed & XkbKeySymsMask) && ((!map) || (!map->syms) ||
                                                 (!map->key_sym_map))) ||
        ((changes->changed & XkbKeyActionsMask) && ((!srv) || (!srv->key_acts)))
        || ((changes->changed & XkbKeyBehaviorsMask) &&
            ((!srv) || (!srv->behaviors))) ||
        ((changes->changed & XkbVirtualModsMask) && (!srv)) ||
        ((changes->changed & XkbExplicitComponentsMask) &&
         ((!srv) || (!srv->explicit))) ||
        ((changes->changed & XkbModifierMapMask) && ((!map) || (!map->modmap)))
        || ((changes->changed & XkbVirtualModMapMask) &&
            ((!srv) || (!srv->vmodmap))))
        return False;

    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbSetMap, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbSetMap;
    req->deviceSpec = xkb->device_spec;
    req->present = changes->changed;
    req->flags = XkbSetMapRecomputeActions;
    req->minKeyCode = xkb->min_key_code;
    req->maxKeyCode = xkb->max_key_code;
    req->firstType = changes->first_type;
    req->nTypes = changes->num_types;
    req->firstKeySym = changes->first_key_sym;
    req->nKeySyms = changes->num_key_syms;
    req->firstKeyAct = changes->first_key_act;
    req->nKeyActs = changes->num_key_acts;
    req->firstKeyBehavior = changes->first_key_behavior;
    req->nKeyBehaviors = changes->num_key_behaviors;
    req->virtualMods = changes->vmods;
    req->firstKeyExplicit = changes->first_key_explicit;
    req->nKeyExplicit = changes->num_key_explicit;
    req->firstModMapKey = changes->first_modmap_key;
    req->nModMapKeys = changes->num_modmap_keys;
    req->firstVModMapKey = changes->first_vmodmap_key;
    req->nVModMapKeys = changes->num_vmodmap_keys;
    SendSetMap(dpy, xkb, req);
    UnlockDisplay(dpy);
    SyncHandle();
    return True;
}
@


1.4
log
@Update to libx11 1.4.2. Tested by ajacoutot@@, jasper@@ krw@@, landry@@,
shadchin@@ on various architectures.
Bump major.
@
text
@d36 1
a36 1
_XkbSizeKeyTypes(XkbDescPtr xkb,xkbSetMapReq *req)
d38 2
a39 2
    XkbKeyTypePtr	map;
    int			i,len;
d41 12
a52 12
    if (((req->present&XkbKeyTypesMask)==0)||(req->nTypes==0)) {
	req->present&= ~XkbKeyTypesMask;
	req->firstType= req->nTypes= 0;
	return 0;
    }
    len= 0;
    map= &xkb->map->types[req->firstType];
    for (i=0;i<req->nTypes;i++,map++){
	len+= SIZEOF(xkbKeyTypeWireDesc);
	len+= map->map_count*SIZEOF(xkbKTSetMapEntryWireDesc);
	if (map->preserve)
	    len+= map->map_count*SIZEOF(xkbModsWireDesc);
d58 1
a58 1
_XkbWriteKeyTypes(Display *dpy,XkbDescPtr xkb,xkbSetMapReq *req)
d60 3
a62 3
    char *		buf;
    XkbKeyTypePtr 	type;
    int			i,n,sz;
d65 34
a98 34
    if ((req->present&XkbKeyTypesMask)==0)
	return;
    type= &xkb->map->types[req->firstType];
    for (i=0;i<req->nTypes;i++,type++) {
	sz= SIZEOF(xkbKeyTypeWireDesc);
	sz+= type->map_count*SIZEOF(xkbKTSetMapEntryWireDesc);
	if (type->preserve)
	    sz+= type->map_count*SIZEOF(xkbModsWireDesc);
	BufAlloc(xkbKeyTypeWireDesc *,desc,sz);
	desc->mask = type->mods.mask;
	desc->realMods = type->mods.real_mods;
	desc->virtualMods = type->mods.vmods;
	desc->numLevels = type->num_levels;
	desc->nMapEntries = type->map_count;
	desc->preserve = (type->preserve!=NULL);
	buf= (char *)&desc[1];
	if (desc->nMapEntries>0) {
	    xkbKTSetMapEntryWireDesc *wire;
	    wire= (xkbKTSetMapEntryWireDesc *)buf;
	    for (n=0;n<type->map_count;n++,wire++) {
		wire->level= type->map[n].level;
		wire->realMods= type->map[n].mods.real_mods;
		wire->virtualMods= type->map[n].mods.vmods;
	    }
	    buf= (char *)wire;
	    if (type->preserve) {
		xkbModsWireDesc *pwire;
		pwire= (xkbModsWireDesc *)buf;
		for (n=0;n<type->map_count;n++,pwire++) {
		    pwire->realMods= type->preserve[n].real_mods;
		    pwire->virtualMods= type->preserve[n].vmods;
		}
	    }
	}
d104 1
a104 1
_XkbSizeKeySyms(XkbDescPtr xkb,xkbSetMapReq *req)
d106 2
a107 2
    int			i,len;
    unsigned		nSyms;
d109 9
a117 9
    if (((req->present&XkbKeySymsMask)==0)||(req->nKeySyms==0)) {
	req->present&= ~XkbKeySymsMask;
	req->firstKeySym= req->nKeySyms= 0;
	req->totalSyms= 0;
	return 0;
    }
    len= (int)(req->nKeySyms*sizeof(XkbSymMapRec));
    for (i=nSyms=0;i<req->nKeySyms;i++) {
	nSyms+= XkbKeyNumSyms(xkb,i+req->firstKeySym);
d119 2
a120 2
    len+= nSyms*sizeof(CARD32);
    req->totalSyms= nSyms;
d125 1
a125 1
_XkbWriteKeySyms(Display *dpy,XkbDescPtr xkb,xkbSetMapReq *req)
d127 5
a131 5
register KeySym *	pSym;
CARD32 *		outSym;
XkbSymMapPtr		symMap;
xkbSymMapWireDesc *desc;
register int	i;
d133 2
a134 2
    if ((req->present&XkbKeySymsMask)==0)
	return;
d136 16
a151 16
    for (i=0;i<req->nKeySyms;i++,symMap++) {
	BufAlloc(xkbSymMapWireDesc *,desc,
		 SIZEOF(xkbSymMapWireDesc)+
		 (XkbKeyNumSyms(xkb,i+req->firstKeySym)*sizeof(CARD32)));
	desc->ktIndex[0] = symMap->kt_index[0];
	desc->ktIndex[1] = symMap->kt_index[1];
	desc->ktIndex[2] = symMap->kt_index[2];
	desc->ktIndex[3] = symMap->kt_index[3];
	desc->groupInfo = symMap->group_info;
	desc->width = symMap->width;
	desc->nSyms = XkbKeyNumSyms(xkb,i+req->firstKeySym);
	outSym = (CARD32 *)&desc[1];
	if (desc->nSyms>0) {
	     pSym = XkbKeySymsPtr(xkb,i+req->firstKeySym);
	    _XkbWriteCopyKeySyms(pSym,outSym,desc->nSyms);
	}
d157 1
a157 1
_XkbSizeKeyActions(XkbDescPtr xkb,xkbSetMapReq *req)
d159 1
a159 1
    int			i,len,nActs;
d161 9
a169 9
    if (((req->present&XkbKeyActionsMask)==0)||(req->nKeyActs==0)) {
	req->present&= ~XkbKeyActionsMask;
	req->firstKeyAct= req->nKeyActs= 0;
	req->totalActs= 0;
	return 0;
    }
    for (nActs=i=0;i<req->nKeyActs;i++) {
	if (xkb->server->key_acts[i+req->firstKeyAct]!=0)
	    nActs+= XkbKeyNumActions(xkb,i+req->firstKeyAct);
d171 2
a172 2
    len= XkbPaddedSize(req->nKeyActs)+(nActs*SIZEOF(xkbActionWireDesc));
    req->totalActs= nActs;
d177 1
a177 1
_XkbWriteKeyActions(Display *dpy,XkbDescPtr xkb,xkbSetMapReq *req)
d179 4
a182 4
    register int	 i;
    int	 		 n;
    CARD8		*numDesc;
    XkbAction		*actDesc;
d184 2
a185 2
    if ((req->present&XkbKeyActionsMask)==0)
	return;
d187 1
a187 1
    n+= (req->totalActs*SIZEOF(xkbActionWireDesc));
d189 15
a203 14
    BufAlloc(CARD8 *,numDesc,n);
    for (i=0;i<req->nKeyActs;i++) {
	if (xkb->server->key_acts[i+req->firstKeyAct]==0)
	     numDesc[i] = 0;
	else numDesc[i] = XkbKeyNumActions(xkb,(i+req->firstKeyAct));
    }
    actDesc = (XkbAction *)&numDesc[XkbPaddedSize(req->nKeyActs)];
    for (i=0;i<req->nKeyActs;i++) {
	if (xkb->server->key_acts[i+req->firstKeyAct]!=0) {
	    n = XkbKeyNumActions(xkb,(i+req->firstKeyAct));
	    memcpy(actDesc,XkbKeyActionsPtr(xkb,(i+req->firstKeyAct)),
                                                   n*SIZEOF(xkbActionWireDesc));
	    actDesc+= n;
	}
d209 1
a209 1
_XkbSizeKeyBehaviors(XkbDescPtr	xkb,xkbSetMapReq *req)
d211 1
a211 1
register int i,first,last,nFound;
d213 11
a223 11
    if (((req->present&XkbKeyBehaviorsMask)==0)||(req->nKeyBehaviors<1)) {
	req->present&= ~XkbKeyBehaviorsMask;
	req->firstKeyBehavior= req->nKeyBehaviors= 0;
	req->totalKeyBehaviors= 0;
	return 0;
    }
    first= req->firstKeyBehavior;
    last= first+req->nKeyBehaviors-1;
    for (i=first,nFound=0;i<=last;i++) {
	if (xkb->server->behaviors[i].type!=XkbKB_Default)
	    nFound++;
d225 2
a226 2
    req->totalKeyBehaviors= nFound;
    return (nFound*SIZEOF(xkbBehaviorWireDesc));
d230 1
a230 1
_XkbWriteKeyBehaviors(Display *dpy,XkbDescPtr xkb,xkbSetMapReq *req)
d232 20
a251 20
register int 		i,first,last;
xkbBehaviorWireDesc *	wire;
char *			buf;

    if ((req->present&XkbKeyBehaviorsMask)==0)
	return;
    first= req->firstKeyBehavior;
    last= first+req->nKeyBehaviors-1;

    i= req->totalKeyBehaviors*SIZEOF(xkbBehaviorWireDesc);
    BufAlloc(char *,buf,i);
    wire= (xkbBehaviorWireDesc *)buf;
    for (i=first;i<=last;i++) {
	if (xkb->server->behaviors[i].type!=XkbKB_Default) {
	    wire->key= i;
	    wire->type= xkb->server->behaviors[i].type;
	    wire->data= xkb->server->behaviors[i].data;
	    buf+= SIZEOF(xkbBehaviorWireDesc);
	    wire= (xkbBehaviorWireDesc *)buf;
	}
d259 1
a259 1
register int i,bit,nMods;
d261 10
a270 10
   if (((req->present&XkbVirtualModsMask)==0)||(req->virtualMods==0)) {
	req->present&= ~XkbVirtualModsMask;
	req->virtualMods= 0;
	return 0;
   }
   for (i=nMods=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (req->virtualMods&bit)
	    nMods++;
   }
   return XkbPaddedSize(nMods);
d274 4
a277 4
_XkbWriteVirtualMods(	Display *	dpy,
			XkbDescPtr 	xkb,
			xkbSetMapReq *	req,
			unsigned 	size)
d279 2
a280 2
    register int	 i,bit;
    CARD8		*vmods;
d284 5
a288 5
	return;
    BufAlloc(CARD8 *,vmods,size);
    for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (req->virtualMods&bit)
	    *vmods++= xkb->server->vmods[i];
d294 1
a294 1
_XkbSizeKeyExplicit(XkbDescPtr xkb,xkbSetMapReq *req)
d296 1
a296 10
register int i,first,last,nFound;

    if (((req->present&XkbExplicitComponentsMask)==0)||(req->nKeyExplicit==0)) {
	req->present&= ~XkbExplicitComponentsMask;
	req->firstKeyExplicit= req->nKeyExplicit= 0;
	req->totalKeyExplicit= 0;
	return 0;
    }
    first= req->firstKeyExplicit;
    last= first+req->nKeyExplicit-1;
d298 13
a310 3
    for (i=first,nFound=0;i<=last;i++) {
	if (xkb->server->explicit[i]!=0)
	    nFound++;
d312 2
a313 2
    req->totalKeyExplicit= nFound;
    return XkbPaddedSize((nFound*2));
d317 1
a317 1
_XkbWriteKeyExplicit(Display *dpy,XkbDescPtr xkb,xkbSetMapReq *req)
d319 2
a320 2
register int	i,first,last;
CARD8 *		wire;
d322 12
a333 12
    if ((req->present&XkbExplicitComponentsMask)==0)
	return;
    first= req->firstKeyExplicit;
    last= first+req->nKeyExplicit - 1;
    i= XkbPaddedSize((req->totalKeyExplicit*2));
    BufAlloc(CARD8 *,wire,i);
    for (i=first;i<=last;i++) {
	if (xkb->server->explicit[i]!=0) {
	    wire[0]= i;
	    wire[1]= xkb->server->explicit[i];
	    wire+= 2;
	}
d339 1
a339 1
_XkbSizeModifierMap(XkbDescPtr xkb,xkbSetMapReq *req)
d341 1
a341 1
register int i,first,last,nFound;
d343 5
a347 5
    if (((req->present&XkbModifierMapMask)==0)||(req->nModMapKeys==0)) {
	req->present&= ~XkbModifierMapMask;
	req->firstModMapKey= req->nModMapKeys= 0;
	req->totalModMapKeys= 0;
	return 0;
d349 2
a350 2
    first= req->firstModMapKey;
    last= first+req->nModMapKeys-1;
d352 3
a354 3
    for (i=first,nFound=0;i<=last;i++) {
	if (xkb->map->modmap[i]!=0)
	    nFound++;
d356 2
a357 2
    req->totalModMapKeys= nFound;
    return XkbPaddedSize((nFound*2));
d361 1
a361 1
_XkbWriteModifierMap(Display *dpy,XkbDescPtr xkb,xkbSetMapReq *req)
d363 2
a364 2
register int	i,first,last;
CARD8 *		wire;
d366 15
a380 14
    if ((req->present&XkbModifierMapMask)==0)
	return;
    first= req->firstModMapKey;
    last= first+req->nModMapKeys-1;
    if (req->totalModMapKeys>0) {
	i= XkbPaddedSize((req->totalModMapKeys*2));
	BufAlloc(CARD8 *,wire,i);
	for (i=first;i<=last;i++) {
	    if (xkb->map->modmap[i]!=0) {
		wire[0]= i;
		wire[1]= xkb->map->modmap[i];
		wire+= 2;
	    }
	}
d386 1
a386 1
_XkbSizeVirtualModMap(XkbDescPtr xkb,xkbSetMapReq *req)
d388 1
a388 1
register int i,first,last,nFound;
d390 13
a402 5
    if (((req->present&XkbVirtualModMapMask)==0)||(req->nVModMapKeys==0)) {
	req->present&= ~XkbVirtualModMapMask;
	req->firstVModMapKey= req->nVModMapKeys= 0;
	req->totalVModMapKeys= 0;
	return 0;
d404 2
a405 9
    first= req->firstVModMapKey;
    last= first+req->nVModMapKeys-1;

    for (i=first,nFound=0;i<=last;i++) {
	if (xkb->server->vmodmap[i]!=0)
	    nFound++;
    }
    req->totalVModMapKeys= nFound;
    return nFound*SIZEOF(xkbVModMapWireDesc);
d409 1
a409 1
_XkbWriteVirtualModMap(Display *dpy,XkbDescPtr xkb,xkbSetMapReq *req)
d411 2
a412 2
register int		i,first,last;
xkbVModMapWireDesc *	wire;
d414 14
a427 14
    if ((req->present&XkbVirtualModMapMask)==0)
	return;
    first= req->firstVModMapKey;
    last= first+req->nVModMapKeys-1;
    if (req->totalVModMapKeys>0) {
	i= req->totalVModMapKeys*SIZEOF(xkbVModMapWireDesc);
	BufAlloc(xkbVModMapWireDesc *,wire,i);
	for (i=first;i<=last;i++) {
	    if (xkb->server->vmodmap[i]!=0) {
		wire->key= i;
		wire->vmods= xkb->server->vmodmap[i];
		wire++;
	    }
	}
d433 1
a433 1
SendSetMap(Display *dpy,XkbDescPtr xkb,xkbSetMapReq *req)
d435 2
a436 2
xkbSetMapReq tmp;
unsigned szMods;
d438 27
a464 27
    req->length+= _XkbSizeKeyTypes(xkb,req)/4;
    req->length+= _XkbSizeKeySyms(xkb,req)/4;
    req->length+= _XkbSizeKeyActions(xkb,req)/4;
    req->length+= _XkbSizeKeyBehaviors(xkb,req)/4;
    szMods= _XkbSizeVirtualMods(req);
    req->length+= szMods/4;
    req->length+= _XkbSizeKeyExplicit(xkb,req)/4;
    req->length+= _XkbSizeModifierMap(xkb,req)/4;
    req->length+= _XkbSizeVirtualModMap(xkb,req)/4;

    tmp= *req;
    if ( tmp.nTypes>0 )
	_XkbWriteKeyTypes(dpy,xkb,&tmp);
    if ( tmp.nKeySyms>0 )
	_XkbWriteKeySyms(dpy,xkb,&tmp);
    if ( tmp.nKeyActs )
	_XkbWriteKeyActions(dpy,xkb,&tmp);
    if ( tmp.totalKeyBehaviors>0 )
	_XkbWriteKeyBehaviors(dpy,xkb,&tmp);
    if ( tmp.virtualMods )
	_XkbWriteVirtualMods(dpy,xkb,&tmp,szMods);
    if ( tmp.totalKeyExplicit>0)
	_XkbWriteKeyExplicit(dpy,xkb,&tmp);
    if ( tmp.totalModMapKeys>0)
	_XkbWriteModifierMap(dpy,xkb,&tmp);
    if ( tmp.totalVModMapKeys>0)
	_XkbWriteVirtualModMap(dpy,xkb,&tmp);
d469 1
a469 1
XkbSetMap(Display *dpy,unsigned which,XkbDescPtr xkb)
d471 4
a474 4
register xkbSetMapReq *	req;
XkbInfoPtr 		xkbi;
XkbServerMapPtr		srv;
XkbClientMapPtr		map;
d477 15
a491 15
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL))||
	(!xkb))
	return False;
    map= xkb->map;
    srv= xkb->server;

    if (((which&XkbKeyTypesMask)&&((!map)||(!map->types)))||
	((which&XkbKeySymsMask)&&((!map)||(!map->syms)||(!map->key_sym_map)))||
	((which&XkbKeyActionsMask)&&((!srv)||(!srv->key_acts)))||
	((which&XkbKeyBehaviorsMask)&&((!srv)||(!srv->behaviors)))||
	((which&XkbVirtualModsMask)&&(!srv))||
	((which&XkbExplicitComponentsMask)&&((!srv)||(!srv->explicit)))||
	((which&XkbModifierMapMask)&&((!map)||(!map->modmap)))||
	((which&XkbVirtualModMapMask)&&((!srv)||(!srv->vmodmap))))
	return False;
d501 2
a502 2
    req->minKeyCode= xkb->min_key_code;
    req->maxKeyCode= xkb->max_key_code;
d504 29
a532 27
    if (which&XkbKeyTypesMask)	req->nTypes = map->num_types;
    else			req->nTypes = 0;
    if (which&XkbKeySymsMask) {
	req->firstKeySym = xkb->min_key_code;
	req->nKeySyms = XkbNumKeys(xkb);
    }
    if (which&XkbKeyActionsMask) {
	req->firstKeyAct = xkb->min_key_code;
	req->nKeyActs = XkbNumKeys(xkb);
    }
    if (which&XkbKeyBehaviorsMask) {
	req->firstKeyBehavior = xkb->min_key_code;
	req->nKeyBehaviors = XkbNumKeys(xkb);
    }
    if (which&XkbVirtualModsMask)
	req->virtualMods= ~0;
    if (which&XkbExplicitComponentsMask) {
	req->firstKeyExplicit= xkb->min_key_code;
	req->nKeyExplicit = XkbNumKeys(xkb);
    }
    if (which&XkbModifierMapMask) {
	req->firstModMapKey= xkb->min_key_code;
	req->nModMapKeys = XkbNumKeys(xkb);
    }
    if (which&XkbVirtualModMapMask) {
	req->firstVModMapKey= xkb->min_key_code;
	req->nVModMapKeys = XkbNumKeys(xkb);
d534 1
a534 1
    SendSetMap(dpy,xkb,req);
d541 1
a541 1
XkbChangeMap(Display *dpy,XkbDescPtr xkb,XkbMapChangesPtr changes)
d543 4
a546 4
register xkbSetMapReq *	req;
XkbInfoPtr 		xkbi;
XkbServerMapPtr		srv;
XkbClientMapPtr		map;
d549 19
a567 17
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL))||
	(!xkb)||(!changes))
	return False;
    srv= xkb->server;
    map= xkb->map;

    if (((changes->changed&XkbKeyTypesMask)&&((!map)||(!map->types)))||
	((changes->changed&XkbKeySymsMask)&&((!map)||(!map->syms)||
				(!map->key_sym_map)))||
	((changes->changed&XkbKeyActionsMask)&&((!srv)||(!srv->key_acts)))||
	((changes->changed&XkbKeyBehaviorsMask)&&((!srv)||(!srv->behaviors)))||
	((changes->changed&XkbVirtualModsMask)&&(!srv))||
	((changes->changed&XkbExplicitComponentsMask)&&
				((!srv)||(!srv->explicit)))||
	((changes->changed&XkbModifierMapMask)&&((!map)||(!map->modmap)))||
	((changes->changed&XkbVirtualModMapMask)&&((!srv)||(!srv->vmodmap))))
	return False;
d577 2
a578 2
    req->minKeyCode= xkb->min_key_code;
    req->maxKeyCode= xkb->max_key_code;
d594 1
a594 1
    SendSetMap(dpy,xkb,req);
a598 1

@


1.3
log
@Update to libX11 1.3.3. Tested on a bulk ports build by naddy@@.
@
text
@a30 2
#define NEED_REPLIES
#define NEED_EVENTS
@


1.2
log
@update to libX11 1.2.1
@
text
@a0 1
/* $Xorg: XKBSetMap.c,v 1.4 2000/08/17 19:45:03 cpqbld Exp $ */
a25 1
/* $XFree86: xc/lib/X11/XKBSetMap.c,v 3.2 2001/01/17 19:41:49 dawes Exp $ */
@


1.1
log
@Initial revision
@
text
@d10 2
a11 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d13 1
a13 1
Silicon Graphics makes no representation about the suitability 
d17 2
a18 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d20 3
a22 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d327 1
a327 1
    last= first+req->nKeyExplicit;
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
