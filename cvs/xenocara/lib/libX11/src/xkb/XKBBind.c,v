head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.8
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.6
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.2
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.10
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.8
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_1_3:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	v1_0_99_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.04.06.20.57.59;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	L5f7tv2EiGjtzoSu;

1.6
date	2013.09.28.17.03.21;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.30.19.19.38;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.18.19.37.36;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.03.12.59.11;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.11.20.55.44;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.16.37.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.16.37.32;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@update to libX11 1.6.3
@
text
@/*

Copyright 1985, 1987, 1994, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

        /* the new monsters ate the old ones */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "XKBlib.h"
#include <X11/Xlibint.h>
#include <X11/Xutil.h>
#include <X11/keysym.h>
#include <stdio.h>
#include <ctype.h>

#include <X11/extensions/XKBproto.h>
#include "XKBlibint.h"

#define AllMods (ShiftMask|LockMask|ControlMask| \
                 Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask)

static int _XkbLoadDpy(Display *dpy);

struct _XKeytrans {
    struct _XKeytrans *next;    /* next on list */
    char *string;               /* string to return when the time comes */
    int len;                    /* length of string (since NULL is legit) */
    KeySym key;                 /* keysym rebound */
    unsigned int state;         /* modifier state */
    KeySym *modifiers;          /* modifier keysyms you want */
    int mlen;                   /* length of modifier list */
};

KeySym
XkbKeycodeToKeysym(Display *dpy,
#if NeedWidePrototypes
                   unsigned int kc,
#else
                   KeyCode kc,
#endif
                   int group,
                   int level)
{
    XkbDescRec *xkb;

    if (_XkbUnavailable(dpy))
        return NoSymbol;

    _XkbCheckPendingRefresh(dpy, dpy->xkb_info);

    xkb = dpy->xkb_info->desc;
    if ((kc < xkb->min_key_code) || (kc > xkb->max_key_code))
        return NoSymbol;

    if ((group < 0) || (level < 0) || (group >= XkbKeyNumGroups(xkb, kc)))
        return NoSymbol;
    if (level >= XkbKeyGroupWidth(xkb, kc, group)) {
        /* for compatibility with the core protocol, _always_ allow  */
        /* two symbols in the first two groups.   If either of the   */
        /* two is of type ONE_LEVEL, just replicate the first symbol */
        if ((group > XkbGroup2Index) || (XkbKeyGroupWidth(xkb, kc, group) != 1)
            || (level != 1)) {
            return NoSymbol;
        }
        level = 0;
    }
    return XkbKeySymEntry(xkb, kc, level, group);
}

KeySym
XKeycodeToKeysym(Display *dpy,
#if NeedWidePrototypes
                 unsigned int kc,
#else
                 KeyCode kc,
#endif
                 int col)
{
    XkbDescRec *xkb;

    if (_XkbUnavailable(dpy))
        return _XKeycodeToKeysym(dpy, kc, col);

    _XkbCheckPendingRefresh(dpy, dpy->xkb_info);

    xkb = dpy->xkb_info->desc;
    if ((kc < xkb->min_key_code) || (kc > xkb->max_key_code))
        return NoSymbol;

    if (col > 3) {
        int lastSym, tmp, nGrp;

        lastSym = 3;
        nGrp = XkbKeyNumGroups(xkb, kc);
        if ((nGrp > 0) &&
            ((tmp = XkbKeyGroupWidth(xkb, kc, XkbGroup1Index)) > 2)) {
            if (col <= (lastSym + tmp - 2))
                return XkbKeycodeToKeysym(dpy, kc, XkbGroup1Index,
                                          col - lastSym + 2);
            lastSym += tmp - 2;
        }
        if ((nGrp > 1) &&
            ((tmp = XkbKeyGroupWidth(xkb, kc, XkbGroup2Index)) > 2)) {
            if (col <= (lastSym + tmp - 2))
                return XkbKeycodeToKeysym(dpy, kc, XkbGroup2Index,
                                          col - lastSym + 2);
            lastSym += tmp - 2;
        }
        if (nGrp > 2) {
            tmp = XkbKeyGroupWidth(xkb, kc, XkbGroup3Index);
            if (col <= lastSym + tmp)
                return XkbKeycodeToKeysym(dpy, kc, XkbGroup3Index,
                                          col - lastSym);
            lastSym += tmp;
        }
        if (nGrp > 3) {
            tmp = XkbKeyGroupWidth(xkb, kc, XkbGroup4Index);
            if (col <= lastSym + tmp)
                return XkbKeycodeToKeysym(dpy, kc, XkbGroup4Index,
                                          col - lastSym);
        }
        return NoSymbol;
    }
    return XkbKeycodeToKeysym(dpy, kc, (col >> 1), (col & 1));
}

KeyCode
XKeysymToKeycode(Display *dpy, KeySym ks)
{
    register int i, j, gotOne;

    if (_XkbUnavailable(dpy))
        return _XKeysymToKeycode(dpy, ks);
    _XkbCheckPendingRefresh(dpy, dpy->xkb_info);

    j = 0;
    do {
        register XkbDescRec *xkb = dpy->xkb_info->desc;
        gotOne = 0;
        for (i = dpy->min_keycode; i <= dpy->max_keycode; i++) {
            if (j < (int) XkbKeyNumSyms(xkb, i)) {
                gotOne = 1;
                if ((XkbKeySym(xkb, i, j) == ks))
                    return i;
            }
        }
        j++;
    } while (gotOne);
    return 0;
}

static int
_XkbComputeModmap(Display *dpy)
{
    register XkbDescPtr xkb;

    xkb = dpy->xkb_info->desc;
    if (XkbGetUpdatedMap(dpy, XkbModifierMapMask, xkb) == Success)
        return 1;
    return 0;
}

unsigned
XkbKeysymToModifiers(Display *dpy, KeySym ks)
{
    XkbDescRec *xkb;
    register int i, j;
    register KeySym *pSyms;
    CARD8 mods;

    if (_XkbUnavailable(dpy))
        return _XKeysymToModifiers(dpy, ks);
    _XkbCheckPendingRefresh(dpy, dpy->xkb_info);

    if (_XkbNeedModmap(dpy->xkb_info) && (!_XkbComputeModmap(dpy)))
        return _XKeysymToModifiers(dpy, ks);

    xkb = dpy->xkb_info->desc;
    mods = 0;
    for (i = xkb->min_key_code; i <= (int) xkb->max_key_code; i++) {
        pSyms = XkbKeySymsPtr(xkb, i);
        for (j = XkbKeyNumSyms(xkb, i) - 1; j >= 0; j--) {
            if (pSyms[j] == ks) {
                mods |= xkb->map->modmap[i];
                break;
            }
        }
    }
    return mods;
}

KeySym
XLookupKeysym(register XKeyEvent * event, int col)
{
    Display *dpy = event->display;

    if (_XkbUnavailable(dpy))
        return _XLookupKeysym(event, col);
    _XkbCheckPendingRefresh(dpy, dpy->xkb_info);
    return XKeycodeToKeysym(dpy, event->keycode, col);
}

   /*
    * Not a public entry point -- XkbTranslateKey is an obsolete name
    * that is preserved here so that functions linked against the old
    * version will continue to work in a shared library environment.
    */
int
XkbTranslateKey(register Display *dpy,
                KeyCode key,
                register unsigned int mods,
                unsigned int *mods_rtrn,
                KeySym *keysym_rtrn);

int
XkbTranslateKey(register Display *dpy,
                KeyCode key,
                register unsigned int mods,
                unsigned int *mods_rtrn,
                KeySym *keysym_rtrn)
{
    return XkbLookupKeySym(dpy, key, mods, mods_rtrn, keysym_rtrn);
}

Bool
XkbLookupKeySym(register Display *dpy,
                KeyCode key,
                register unsigned int mods,
                unsigned int *mods_rtrn,
                KeySym *keysym_rtrn)
{
    if (_XkbUnavailable(dpy))
        return _XTranslateKey(dpy, key, mods, mods_rtrn, keysym_rtrn);
    _XkbCheckPendingRefresh(dpy, dpy->xkb_info);
    return XkbTranslateKeyCode(dpy->xkb_info->desc, key, mods, mods_rtrn,
                               keysym_rtrn);
}

Bool
XkbTranslateKeyCode(register XkbDescPtr xkb,
                    KeyCode key,
                    register unsigned int mods,
                    unsigned int *mods_rtrn,
                    KeySym *keysym_rtrn)
{
    XkbKeyTypeRec *type;
    int col, nKeyGroups;
    unsigned preserve, effectiveGroup;
    KeySym *syms;

    if (mods_rtrn != NULL)
        *mods_rtrn = 0;

    nKeyGroups = XkbKeyNumGroups(xkb, key);
    if ((!XkbKeycodeInRange(xkb, key)) || (nKeyGroups == 0)) {
        if (keysym_rtrn != NULL)
            *keysym_rtrn = NoSymbol;
        return False;
    }

    syms = XkbKeySymsPtr(xkb, key);

    /* find the offset of the effective group */
    col = 0;
    effectiveGroup = XkbGroupForCoreState(mods);
    if (effectiveGroup >= nKeyGroups) {
        unsigned groupInfo = XkbKeyGroupInfo(xkb, key);

        switch (XkbOutOfRangeGroupAction(groupInfo)) {
        default:
            effectiveGroup %= nKeyGroups;
            break;
        case XkbClampIntoRange:
            effectiveGroup = nKeyGroups - 1;
            break;
        case XkbRedirectIntoRange:
            effectiveGroup = XkbOutOfRangeGroupNumber(groupInfo);
            if (effectiveGroup >= nKeyGroups)
                effectiveGroup = 0;
            break;
        }
    }
    col = effectiveGroup * XkbKeyGroupsWidth(xkb, key);
    type = XkbKeyKeyType(xkb, key, effectiveGroup);

    preserve = 0;
    if (type->map) {  /* find the column (shift level) within the group */
        register int i;
        register XkbKTMapEntryPtr entry;

        for (i = 0, entry = type->map; i < type->map_count; i++, entry++) {
            if ((entry->active) &&
                ((mods & type->mods.mask) == entry->mods.mask)) {
                col += entry->level;
                if (type->preserve)
                    preserve = type->preserve[i].mask;
                break;
            }
        }
    }

    if (keysym_rtrn != NULL)
        *keysym_rtrn = syms[col];
    if (mods_rtrn) {
        *mods_rtrn = type->mods.mask & (~preserve);
        /* The Motif VTS doesn't get the help callback called if help
         * is bound to Shift+<whatever>, and it appears as though it
         * is XkbTranslateKeyCode that is causing the problem.  The
         * core X version of XTranslateKey always OR's in ShiftMask
         * and LockMask for mods_rtrn, so this "fix" keeps this behavior
         * and solves the VTS problem.
         */
        if ((xkb->dpy) && (xkb->dpy->xkb_info) &&
            (xkb->dpy->xkb_info->
             xlib_ctrls & XkbLC_AlwaysConsumeShiftAndLock)) {
            *mods_rtrn |= (ShiftMask | LockMask);
        }
    }
    return (syms[col] != NoSymbol);
}

Status
XkbRefreshKeyboardMapping(register XkbMapNotifyEvent * event)
{
    Display *dpy = event->display;
    XkbInfoPtr xkbi;

    if (_XkbUnavailable(dpy)) {
        _XRefreshKeyboardMapping((XMappingEvent *) event);
        return Success;
    }
    xkbi = dpy->xkb_info;

    if (((event->type & 0x7f) - xkbi->codes->first_event) != XkbEventCode)
        return BadMatch;
    if (event->xkb_type == XkbNewKeyboardNotify) {
        _XkbReloadDpy(dpy);
        return Success;
    }
    if (event->xkb_type == XkbMapNotify) {
        XkbMapChangesRec changes;
        Status rtrn;

        if (xkbi->flags & XkbMapPending)
            changes = xkbi->changes;
        else
            bzero(&changes, sizeof(changes));
        XkbNoteMapChanges(&changes, event, XKB_XLIB_MAP_MASK);
        if ((rtrn = XkbGetMapChanges(dpy, xkbi->desc, &changes)) != Success) {
#ifdef DEBUG
            fprintf(stderr, "Internal Error! XkbGetMapChanges failed:\n");
#endif
            xkbi->changes = changes;
        }
        else if (xkbi->flags & XkbMapPending) {
            xkbi->flags &= ~XkbMapPending;
            bzero(&xkbi->changes, sizeof(XkbMapChangesRec));
        }
        return rtrn;
    }
    return BadMatch;
}

int
XRefreshKeyboardMapping(register XMappingEvent * event)
{
    XkbEvent *xkbevent = (XkbEvent *) event;
    Display *dpy = event->display;
    XkbMapChangesRec changes;
    XkbInfoPtr xkbi;

    /* always do this for input methods, which still use the old keymap */
    (void) _XRefreshKeyboardMapping(event);

    if (_XkbUnavailable(dpy))
        return 1;

    xkbi = dpy->xkb_info;

    if (((event->type & 0x7f) - xkbi->codes->first_event) == XkbEventCode)
        return XkbRefreshKeyboardMapping(&xkbevent->map);

    if (xkbi->flags & XkbXlibNewKeyboard) {
        _XkbReloadDpy(dpy);
        return 1;
    }

    if ((xkbi->flags & XkbMapPending) || (event->request == MappingKeyboard)) {
        if (xkbi->flags & XkbMapPending) {
            changes = xkbi->changes;
            _XkbNoteCoreMapChanges(&changes, event, XKB_XLIB_MAP_MASK);
        }
        else {
            bzero(&changes, sizeof(changes));
            changes.changed = XkbKeySymsMask;
            if (xkbi->desc->min_key_code < xkbi->desc->max_key_code) {
                changes.first_key_sym = xkbi->desc->min_key_code;
                changes.num_key_syms = xkbi->desc->max_key_code -
                    xkbi->desc->min_key_code + 1;
            }
            else {
                changes.first_key_sym = event->first_keycode;
                changes.num_key_syms = event->count;
            }
        }

        if (XkbGetMapChanges(dpy, xkbi->desc, &changes) != Success) {
#ifdef DEBUG
            fprintf(stderr, "Internal Error! XkbGetMapChanges failed:\n");
            if (changes.changed & XkbKeyTypesMask) {
                int first = changes.first_type;
                int last = changes.first_type + changes.num_types - 1;

                fprintf(stderr, "       types:  %d..%d\n", first, last);
            }
            if (changes.changed & XkbKeySymsMask) {
                int first = changes.first_key_sym;
                int last = changes.first_key_sym + changes.num_key_syms - 1;

                fprintf(stderr, "     symbols:  %d..%d\n", first, last);
            }
            if (changes.changed & XkbKeyActionsMask) {
                int first = changes.first_key_act;
                int last = changes.first_key_act + changes.num_key_acts - 1;

                fprintf(stderr, "     acts:  %d..%d\n", first, last);
            }
            if (changes.changed & XkbKeyBehaviorsMask) {
                int first = changes.first_key_behavior;
                int last = first + changes.num_key_behaviors - 1;

                fprintf(stderr, "   behaviors:  %d..%d\n", first, last);
            }
            if (changes.changed & XkbVirtualModsMask) {
                fprintf(stderr, "virtual mods: 0x%04x\n", changes.vmods);
            }
            if (changes.changed & XkbExplicitComponentsMask) {
                int first = changes.first_key_explicit;
                int last = first + changes.num_key_explicit - 1;

                fprintf(stderr, "    explicit:  %d..%d\n", first, last);
            }
#endif
        }
        LockDisplay(dpy);
        if (xkbi->flags & XkbMapPending) {
            xkbi->flags &= ~XkbMapPending;
            bzero(&xkbi->changes, sizeof(XkbMapChangesRec));
        }
        UnlockDisplay(dpy);
    }
    if (event->request == MappingModifier) {
        LockDisplay(dpy);
        if (xkbi->desc->map->modmap) {
            _XkbFree(xkbi->desc->map->modmap);
            xkbi->desc->map->modmap = NULL;
        }
        if (dpy->key_bindings) {
            register struct _XKeytrans *p;

            for (p = dpy->key_bindings; p; p = p->next) {
                register int i;

                p->state = 0;
                if (p->mlen > 0) {
                    for (i = 0; i < p->mlen; i++) {
                        p->state |= XkbKeysymToModifiers(dpy, p->modifiers[i]);
                    }
                    if (p->state)
                        p->state &= AllMods;
                    else
                        p->state = AnyModifier;
                }
            }
        }
        UnlockDisplay(dpy);
    }
    return 1;
}

static int
_XkbLoadDpy(Display *dpy)
{
    XkbInfoPtr xkbi;
    unsigned query, oldEvents;
    XkbDescRec *desc;

    if (!XkbUseExtension(dpy, NULL, NULL))
        return 0;

    xkbi = dpy->xkb_info;
    query = XkbAllClientInfoMask;
    desc = XkbGetMap(dpy, query, XkbUseCoreKbd);
    if (!desc) {
#ifdef DEBUG
        fprintf(stderr, "Warning! XkbGetMap failed!\n");
#endif
        return 0;
    }
    LockDisplay(dpy);
    xkbi->desc = desc;

    UnlockDisplay(dpy);
    oldEvents = xkbi->selected_events;
    if (!(xkbi->xlib_ctrls & XkbLC_IgnoreNewKeyboards)) {
        XkbSelectEventDetails(dpy, xkbi->desc->device_spec,
                              XkbNewKeyboardNotify,
                              XkbNKN_KeycodesMask | XkbNKN_DeviceIDMask,
                              XkbNKN_KeycodesMask | XkbNKN_DeviceIDMask);
    }
    XkbSelectEventDetails(dpy, xkbi->desc->device_spec, XkbMapNotify,
                          XkbAllClientInfoMask, XkbAllClientInfoMask);
    LockDisplay(dpy);
    xkbi->selected_events = oldEvents;
    UnlockDisplay(dpy);
    return 1;
}

void
_XkbReloadDpy(Display *dpy)
{
    XkbInfoPtr xkbi;
    XkbDescRec *desc;
    unsigned oldDeviceID;

    if (_XkbUnavailable(dpy))
        return;

    xkbi = dpy->xkb_info;
    LockDisplay(dpy);
    if (xkbi->desc) {
        oldDeviceID = xkbi->desc->device_spec;
        XkbFreeKeyboard(xkbi->desc, XkbAllComponentsMask, True);
        xkbi->desc = NULL;
        xkbi->flags &= ~(XkbMapPending | XkbXlibNewKeyboard);
        xkbi->changes.changed = 0;
    }
    else
        oldDeviceID = XkbUseCoreKbd;
    UnlockDisplay(dpy);
    desc = XkbGetMap(dpy, XkbAllClientInfoMask, XkbUseCoreKbd);
    if (!desc)
        return;
    LockDisplay(dpy);
    xkbi->desc = desc;
    UnlockDisplay(dpy);

    if (desc->device_spec != oldDeviceID) {
        /* transfer(?) event masks here */
#ifdef NOTYET
        unsigned oldEvents;

        oldEvents = xkbi->selected_events;
        XkbSelectEventDetails(dpy, xkbi->desc->device_spec, XkbMapNotify,
                              XkbAllMapComponentsMask, XkbAllClientInfoMask);
        LockDisplay(dpy);
        xkbi->selected_events = oldEvents;
        UnlockDisplay(dpy);
#endif
    }
    return;
}

int
XkbTranslateKeySym(register Display *dpy,
                   register KeySym *sym_rtrn,
                   unsigned int mods,
                   char *buffer,
                   int nbytes,
                   int *extra_rtrn)
{
    register XkbInfoPtr xkb;
    XkbKSToMBFunc cvtr;
    XPointer priv;
    char tmp[4];
    int n;

    xkb = dpy->xkb_info;
    if (!xkb->cvt.KSToMB) {
        _XkbGetConverters(_XkbGetCharset(), &xkb->cvt);
        _XkbGetConverters("ISO8859-1", &xkb->latin1cvt);
    }

    if (extra_rtrn)
        *extra_rtrn = 0;

    if ((buffer == NULL) || (nbytes == 0)) {
        buffer = tmp;
        nbytes = 4;
    }

    /* see if symbol rebound, if so, return that string. */
    n = XkbLookupKeyBinding(dpy, *sym_rtrn, mods, buffer, nbytes, extra_rtrn);
    if (n)
        return n;

    if (nbytes > 0)
        buffer[0] = '\0';

    if (xkb->cvt.KSToUpper && (mods & LockMask)) {
        *sym_rtrn = (*xkb->cvt.KSToUpper) (*sym_rtrn);
    }
    if (xkb->xlib_ctrls & XkbLC_ForceLatin1Lookup) {
        cvtr = xkb->latin1cvt.KSToMB;
        priv = xkb->latin1cvt.KSToMBPriv;
    }
    else {
        cvtr = xkb->cvt.KSToMB;
        priv = xkb->cvt.KSToMBPriv;
    }

    n = (*cvtr) (priv, *sym_rtrn, buffer, nbytes, extra_rtrn);

    if ((!xkb->cvt.KSToUpper) && (mods & LockMask)) {
        register int i;
        int change;

        for (i = change = 0; i < n; i++) {
            char ch = toupper(buffer[i]);
            change = (change || (buffer[i] != ch));
            buffer[i] = ch;
        }
        if (change) {
            if (n == 1)
                *sym_rtrn =
                    (*xkb->cvt.MBToKS) (xkb->cvt.MBToKSPriv, buffer, n, NULL);
            else
                *sym_rtrn = NoSymbol;
        }
    }

    if (mods & ControlMask) {
        if (n == 1) {
            buffer[0] = XkbToControl(buffer[0]);
            if (nbytes > 1)
                buffer[1] = '\0';
            return 1;
        }
        if (nbytes > 0)
            buffer[0] = '\0';
        return 0;
    }
    return n;
}

int
XLookupString(register XKeyEvent *event,
              char *buffer,
              int nbytes,
              KeySym *keysym,
              XComposeStatus *status)
{
    KeySym dummy;
    int rtrnLen;
    unsigned int new_mods;
    Display *dpy = event->display;

    if (keysym == NULL)
        keysym = &dummy;
    if (!XkbLookupKeySym(dpy, event->keycode, event->state, &new_mods, keysym))
        return 0;
    new_mods = (event->state & (~new_mods));

    /* find the group where a symbol can be converted to control one */
    if (new_mods & ControlMask && *keysym > 0x7F &&
        (dpy->xkb_info->xlib_ctrls & XkbLC_ControlFallback)) {
        XKeyEvent tmp_ev = *event;
        KeySym tmp_keysym;
        unsigned int tmp_new_mods;

        if (_XkbUnavailable(dpy)) {
            tmp_ev.state = event->state ^ dpy->mode_switch;
            if (XkbLookupKeySym(dpy, tmp_ev.keycode, tmp_ev.state,
                                &tmp_new_mods, &tmp_keysym) &&
                tmp_keysym != NoSymbol && tmp_keysym < 0x80) {
                *keysym = tmp_keysym;
            }
        }
        else {
            int n = XkbKeyNumGroups(dpy->xkb_info->desc, tmp_ev.keycode);
            int i;

            for (i = 0; i < n; i++) {
                if (XkbGroupForCoreState(event->state) == i)
                    continue;
                tmp_ev.state = XkbBuildCoreState(tmp_ev.state, i);
                if (XkbLookupKeySym(dpy, tmp_ev.keycode, tmp_ev.state,
                                    &tmp_new_mods, &tmp_keysym) &&
                    tmp_keysym != NoSymbol && tmp_keysym < 0x80) {
                    *keysym = tmp_keysym;
                    new_mods = (event->state & (~tmp_new_mods));
                    break;
                }
            }
        }
    }

    /* We *should* use the new_mods (which does not contain any modifiers */
    /* that were used to compute the symbol here, but pre-XKB XLookupString */
    /* did not and we have to remain compatible.  Sigh. */
    if (_XkbUnavailable(dpy) ||
        (dpy->xkb_info->xlib_ctrls & XkbLC_ConsumeLookupMods) == 0)
        new_mods = event->state;

    rtrnLen = XkbLookupKeyBinding(dpy, *keysym, new_mods, buffer, nbytes, NULL);
    if (rtrnLen > 0)
        return rtrnLen;

    return XkbTranslateKeySym(dpy, keysym, new_mods, buffer, nbytes, NULL);
}


int
XkbLookupKeyBinding(Display *dpy,
                    register KeySym sym,
                    unsigned int mods,
                    char *buffer,
                    int nbytes,
                    int *extra_rtrn)
{
    register struct _XKeytrans *p;

    if (extra_rtrn)
        *extra_rtrn = 0;
    for (p = dpy->key_bindings; p; p = p->next) {
        if (((mods & AllMods) == p->state) && (sym == p->key)) {
            int tmp = p->len;

            if (tmp > nbytes) {
                if (extra_rtrn)
                    *extra_rtrn = (tmp - nbytes);
                tmp = nbytes;
            }
            memcpy(buffer, p->string, tmp);
            if (tmp < nbytes)
                buffer[tmp] = '\0';
            return tmp;
        }
    }
    return 0;
}

char
XkbToControl(char ch)
{
    register char c = ch;

    if ((c >= '@@' && c < '\177') || c == ' ')
        c &= 0x1F;
    else if (c == '2')
        c = '\000';
    else if (c >= '3' && c <= '7')
        c -= ('3' - '\033');
    else if (c == '8')
        c = '\177';
    else if (c == '/')
        c = '_' & 0x1F;
    return c;
}
@


1.6
log
@Update to libX11 1.6.2. No API change.
@
text
@a43 5
#ifdef USE_OWN_COMPOSE
#define COMPOSE_NO_CONST_MEMBERS
#include "imComp.h"
#endif

a721 97

#ifdef USE_OWN_COMPOSE
    if (status) {
        static int been_here = 0;

        if (!been_here) {
            XimCompInitTables();
            been_here = 1;
        }
        if (!XimCompLegalStatus(status)) {
            status->compose_ptr = NULL;
            status->chars_matched = 0;
        }
        if (((status->chars_matched > 0) && (status->compose_ptr != NULL)) ||
            XimCompIsComposeKey(*keysym, event->keycode, status)) {
            XimCompRtrn rtrn;

            switch (XimCompProcessSym(status, *keysym, &rtrn)) {
            case XIM_COMP_IGNORE:
                break;
            case XIM_COMP_IN_PROGRESS:
                if (keysym != NULL)
                    *keysym = NoSymbol;
#ifndef NO_COMPOSE_LED
                if (dpy->xkb_info->xlib_ctrls & XkbLC_ComposeLED) {
                    XkbSetNamedIndicator(dpy, dpy->xkb_info->composeLED,
                                         True, True, False, NULL);
                }
#endif
                return 0;
            case XIM_COMP_FAIL:
            {
                static Atom _ComposeFail = None;
                int n = 0, len = 0;

#ifndef NO_COMPOSE_LED
                if (dpy->xkb_info->xlib_ctrls & XkbLC_ComposeLED) {
                    XkbSetNamedIndicator(dpy, dpy->xkb_info->composeLED,
                                         True, False, False, NULL);
                }
#endif
#ifndef NO_BELL_ON_COMPOSE_FAIL
                if (dpy->xkb_info->xlib_ctrls & XkbLC_BeepOnComposeFail) {
                    if (_ComposeFail == None)
                        _ComposeFail = XInternAtom(dpy, "ComposeFail", 0);
                    XkbBell(dpy, event->window, 0, _ComposeFail);
                }
#endif
                for (n = len = 0; rtrn.sym[n] != XK_VoidSymbol; n++) {
                    if (nbytes - len > 0) {
                        len += XkbTranslateKeySym(dpy, &rtrn.sym[n], new_mods,
                                                  buffer + len, nbytes - len,
                                                  NULL);
                    }
                }
                if (keysym != NULL) {
                    if (n == 1)
                        *keysym = rtrn.sym[0];
                    else
                        *keysym = NoSymbol;
                }
                return len;
            }
            case XIM_COMP_SUCCEED:
            {
                int len, n = 0;

#ifndef NO_COMPOSE_LED
                if (dpy->xkb_info->xlib_ctrls & XkbLC_ComposeLED) {
                    XkbSetNamedIndicator(dpy, dpy->xkb_info->composeLED,
                                         True, False, False, NULL);
                }
#endif
                *keysym = rtrn.matchSym;
                if (rtrn.str[0] != '\0') {
                    strncpy(buffer, rtrn.str, nbytes - 1);
                    buffer[nbytes - 1] = '\0';
                    len = (int) strlen(buffer);
                }
                else {
                    len = XkbTranslateKeySym(dpy, keysym, new_mods,
                                             buffer, nbytes, NULL);
                }
                for (n = 0; rtrn.sym[n] != XK_VoidSymbol; n++) {
                    if (nbytes - len > 0) {
                        len += XkbTranslateKeySym(dpy, &rtrn.sym[n],
                                                  event->state,
                                                  buffer + len, nbytes - len,
                                                  NULL);
                    }
                }
                return len;
            }
            }
        }
    }
#endif
@


1.5
log
@Update to libx11 1.4.2. Tested by ajacoutot@@, jasper@@ krw@@, landry@@,
shadchin@@ on various architectures.
Bump major.
@
text
@d29 1
a29 1
	/* the new monsters ate the old ones */
d45 1
a45 1
#define	COMPOSE_NO_CONST_MEMBERS
d50 1
a50 1
		 Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask)
d52 1
a52 3
static int _XkbLoadDpy(
    Display *dpy
);
d55 7
a61 7
	struct _XKeytrans *next;/* next on list */
	char *string;		/* string to return when the time comes */
	int len;		/* length of string (since NULL is legit)*/
	KeySym key;		/* keysym rebound */
	unsigned int state;	/* modifier state */
	KeySym *modifiers;	/* modifier keysyms you want */
	int mlen;		/* length of modifier list */
d67 1
a67 1
		 unsigned int kc,
d69 1
a69 1
		 KeyCode kc,
d71 2
a72 2
		 int 	group,
		 int	level)
d74 1
a74 1
    XkbDescRec	*xkb;
d77 1
a77 1
	return NoSymbol;
d79 1
a79 1
    _XkbCheckPendingRefresh(dpy,dpy->xkb_info);
d82 2
a83 2
    if ((kc<xkb->min_key_code)||(kc>xkb->max_key_code))
	return NoSymbol;
d85 11
a95 11
    if ((group<0)||(level<0)||(group>=XkbKeyNumGroups(xkb,kc)))
	return NoSymbol;
    if (level>=XkbKeyGroupWidth(xkb,kc,group)) {
	/* for compatibility with the core protocol, _always_ allow  */
	/* two symbols in the first two groups.   If either of the   */
	/* two is of type ONE_LEVEL, just replicate the first symbol */
	if ((group>XkbGroup2Index)||(XkbKeyGroupWidth(xkb,kc,group)!=1)||
								(level!=1)) {
	    return NoSymbol;
	}
	level= 0;
d97 1
a97 1
    return XkbKeySymEntry(xkb,kc,level,group);
d103 1
a103 1
		 unsigned int kc,
d105 1
a105 1
		 KeyCode kc,
d107 1
a107 1
		 int col)
d109 1
a109 1
    XkbDescRec	*xkb;
d112 1
a112 1
	return _XKeycodeToKeysym(dpy, kc, col);
d114 1
a114 1
    _XkbCheckPendingRefresh(dpy,dpy->xkb_info);
d117 2
a118 2
    if ((kc<xkb->min_key_code)||(kc>xkb->max_key_code))
	return NoSymbol;
d120 2
a121 2
    if (col>3) {
	int lastSym,tmp,nGrp;
d123 30
a152 24
	lastSym= 3;
	nGrp= XkbKeyNumGroups(xkb,kc);
	if ((nGrp>0)&&((tmp=XkbKeyGroupWidth(xkb,kc,XkbGroup1Index))>2)) {
	    if (col<=(lastSym+tmp-2))
		return XkbKeycodeToKeysym(dpy,kc,XkbGroup1Index,col-lastSym+2);
	    lastSym+= tmp-2;
	}
	if ((nGrp>1)&&((tmp=XkbKeyGroupWidth(xkb,kc,XkbGroup2Index))>2)) {
	    if (col<=(lastSym+tmp-2))
		return XkbKeycodeToKeysym(dpy,kc,XkbGroup2Index,col-lastSym+2);
	    lastSym+= tmp-2;
	}
	if (nGrp>2) {
	    tmp= XkbKeyGroupWidth(xkb,kc,XkbGroup3Index);
	    if (col<=lastSym+tmp)
		return XkbKeycodeToKeysym(dpy,kc,XkbGroup3Index,col-lastSym);
	    lastSym+= tmp;
	}
	if (nGrp>3) {
	    tmp= XkbKeyGroupWidth(xkb,kc,XkbGroup4Index);
	    if (col<=lastSym+tmp)
		return XkbKeycodeToKeysym(dpy,kc,XkbGroup4Index,col-lastSym);
	}
	return NoSymbol;
d154 1
a154 1
    return XkbKeycodeToKeysym(dpy,kc,(col>>1),(col&1));
d163 2
a164 2
	return _XKeysymToKeycode(dpy,ks);
    _XkbCheckPendingRefresh(dpy,dpy->xkb_info);
d166 1
a166 1
    j= 0;
d168 10
a177 10
	register XkbDescRec *xkb = dpy->xkb_info->desc;
	gotOne= 0;
	for (i = dpy->min_keycode; i <= dpy->max_keycode; i++) {
	    if ( j<(int)XkbKeyNumSyms(xkb,i) ) {
		gotOne = 1;
		if ((XkbKeySym(xkb,i,j)==ks))
		    return i;
	    }
	}
	j++;
d185 1
a185 1
register XkbDescPtr xkb;
d187 3
a189 3
    xkb= dpy->xkb_info->desc;
    if (XkbGetUpdatedMap(dpy,XkbModifierMapMask,xkb)==Success)
	return 1;
d194 1
a194 1
XkbKeysymToModifiers(Display *dpy,KeySym ks)
d197 1
a197 1
    register int i,j;
d202 2
a203 2
	return _XKeysymToModifiers(dpy,ks);
    _XkbCheckPendingRefresh(dpy,dpy->xkb_info);
d205 2
a206 2
    if (_XkbNeedModmap(dpy->xkb_info)&&(!_XkbComputeModmap(dpy)))
	return _XKeysymToModifiers(dpy,ks);
d208 10
a217 10
    xkb= dpy->xkb_info->desc;
    mods= 0;
    for (i = xkb->min_key_code; i <= (int)xkb->max_key_code; i++) {
	pSyms= XkbKeySymsPtr(xkb,i);
	for (j=XkbKeyNumSyms(xkb,i)-1;j>=0;j--) {
	    if (pSyms[j]==ks) {
		mods|= xkb->map->modmap[i];
		break;
	    }
	}
d223 1
a223 1
XLookupKeysym(register XKeyEvent *event, int col)
d226 1
d228 2
a229 2
	return _XLookupKeysym(event, col);
    _XkbCheckPendingRefresh(dpy,dpy->xkb_info);
d239 6
a244 5
XkbTranslateKey(	register Display *	dpy,
			KeyCode 		key,
			register unsigned int 	mods,
			unsigned int *		mods_rtrn,
			KeySym *		keysym_rtrn);
d246 5
a250 5
XkbTranslateKey(	register Display *	dpy,
			KeyCode 		key,
			register unsigned int 	mods,
			unsigned int *		mods_rtrn,
			KeySym *		keysym_rtrn)
d252 1
a252 1
    return XkbLookupKeySym(dpy,key,mods,mods_rtrn,keysym_rtrn);
d256 5
a260 5
XkbLookupKeySym(	register Display *	dpy,
			KeyCode 		key,
			register unsigned int 	mods,
			unsigned int *		mods_rtrn,
			KeySym *		keysym_rtrn)
d263 4
a266 4
	return _XTranslateKey(dpy, key, mods, mods_rtrn, keysym_rtrn);
    _XkbCheckPendingRefresh(dpy,dpy->xkb_info);
    return XkbTranslateKeyCode(dpy->xkb_info->desc,key,mods,mods_rtrn,
								keysym_rtrn);
d270 5
a274 5
XkbTranslateKeyCode(	register XkbDescPtr	xkb,
			KeyCode 		key,
			register unsigned int 	mods,
			unsigned int *		mods_rtrn,
			KeySym *		keysym_rtrn)
d277 2
a278 2
    int col,nKeyGroups;
    unsigned preserve,effectiveGroup;
d281 2
a282 2
    if (mods_rtrn!=NULL)
	*mods_rtrn = 0;
d284 5
a288 5
    nKeyGroups= XkbKeyNumGroups(xkb,key);
    if ((!XkbKeycodeInRange(xkb,key))||(nKeyGroups==0)) {
	if (keysym_rtrn!=NULL)
	    *keysym_rtrn = NoSymbol;
	return False;
d291 1
a291 1
    syms = XkbKeySymsPtr(xkb,key);
d295 17
a311 32
    effectiveGroup= XkbGroupForCoreState(mods);
    if ( effectiveGroup>=nKeyGroups ) {
	unsigned groupInfo= XkbKeyGroupInfo(xkb,key);
	switch (XkbOutOfRangeGroupAction(groupInfo)) {
	    default:
		effectiveGroup %= nKeyGroups;
		break;
	    case XkbClampIntoRange:
		effectiveGroup = nKeyGroups-1;
		break;
	    case XkbRedirectIntoRange:
		effectiveGroup = XkbOutOfRangeGroupNumber(groupInfo);
		if (effectiveGroup>=nKeyGroups)
		    effectiveGroup= 0;
		break;
	}
    }
    col= effectiveGroup*XkbKeyGroupsWidth(xkb,key);
    type = XkbKeyKeyType(xkb,key,effectiveGroup);

    preserve= 0;
    if (type->map) { /* find the column (shift level) within the group */
	register int i;
	register XkbKTMapEntryPtr entry;
	for (i=0,entry=type->map;i<type->map_count;i++,entry++) {
	    if ((entry->active)&&((mods&type->mods.mask)==entry->mods.mask)) {
		col+= entry->level;
		if (type->preserve)
		    preserve= type->preserve[i].mask;
		break;
	    }
	}
d313 2
d316 18
a333 2
    if (keysym_rtrn!=NULL)
	*keysym_rtrn= syms[col];
d335 13
a347 12
	*mods_rtrn= type->mods.mask&(~preserve);
	/* The Motif VTS doesn't get the help callback called if help
	 * is bound to Shift+<whatever>, and it appears as though it
	 * is XkbTranslateKeyCode that is causing the problem.  The
	 * core X version of XTranslateKey always OR's in ShiftMask
	 * and LockMask for mods_rtrn, so this "fix" keeps this behavior
	 * and solves the VTS problem.
	 */
	if ((xkb->dpy)&&(xkb->dpy->xkb_info)&&
	    (xkb->dpy->xkb_info->xlib_ctrls&XkbLC_AlwaysConsumeShiftAndLock)) {
	    *mods_rtrn|= (ShiftMask|LockMask);
	}
d349 1
a349 1
    return (syms[col]!=NoSymbol);
d353 1
a353 1
XkbRefreshKeyboardMapping(register XkbMapNotifyEvent *event)
d359 2
a360 2
	_XRefreshKeyboardMapping((XMappingEvent *)event);
	return Success;
d362 1
a362 1
    xkbi= dpy->xkb_info;
d364 16
a379 15
    if (((event->type&0x7f)-xkbi->codes->first_event)!=XkbEventCode)
	return BadMatch;
    if (event->xkb_type==XkbNewKeyboardNotify) {
	_XkbReloadDpy(dpy);
	return Success;
    }
    if (event->xkb_type==XkbMapNotify) {
	XkbMapChangesRec	changes;
	Status			rtrn;

	if (xkbi->flags&XkbMapPending)
	     changes= xkbi->changes;
	else bzero(&changes,sizeof(changes));
	XkbNoteMapChanges(&changes,event,XKB_XLIB_MAP_MASK);
	if ((rtrn=XkbGetMapChanges(dpy,xkbi->desc,&changes))!=Success) {
d381 1
a381 1
	    fprintf(stderr,"Internal Error! XkbGetMapChanges failed:\n");
d383 7
a389 7
	    xkbi->changes= changes;
	}
	else if (xkbi->flags&XkbMapPending) {
	    xkbi->flags&= ~XkbMapPending;
	    bzero(&xkbi->changes,sizeof(XkbMapChangesRec));
	}
	return rtrn;
d395 1
a395 1
XRefreshKeyboardMapping(register XMappingEvent *event)
d397 1
a397 1
    XkbEvent	*xkbevent = (XkbEvent *)event;
d406 1
a406 1
	return 1;
d410 2
a411 2
    if (((event->type&0x7f)-xkbi->codes->first_event)==XkbEventCode)
	return XkbRefreshKeyboardMapping(&xkbevent->map);
d413 4
a416 23
    if (xkbi->flags&XkbXlibNewKeyboard) {
	_XkbReloadDpy(dpy);
	return 1;
    }

    if ((xkbi->flags&XkbMapPending)||(event->request==MappingKeyboard)) {
	if (xkbi->flags&XkbMapPending) {
	    changes= xkbi->changes;
	    _XkbNoteCoreMapChanges(&changes,event,XKB_XLIB_MAP_MASK);
	}
	else {
	    bzero(&changes,sizeof(changes));
	    changes.changed= XkbKeySymsMask;
	    if (xkbi->desc->min_key_code<xkbi->desc->max_key_code) {
		changes.first_key_sym= xkbi->desc->min_key_code;
		changes.num_key_syms= xkbi->desc->max_key_code-
						xkbi->desc->min_key_code+1;
	    }
	    else {
		changes.first_key_sym= event->first_keycode;
		changes.num_key_syms= event->count;
	    }
	}
d418 20
a437 1
	if (XkbGetMapChanges(dpy,xkbi->desc, &changes)!=Success) {
d439 68
a506 60
		fprintf(stderr,"Internal Error! XkbGetMapChanges failed:\n");
		if (changes.changed&XkbKeyTypesMask) {
		    int first= changes.first_type;
		    int last= changes.first_type+changes.num_types-1;
		    fprintf(stderr,"       types:  %d..%d\n",first,last);
		}
		if (changes.changed&XkbKeySymsMask) {
		    int first= changes.first_key_sym;
		    int last= changes.first_key_sym+changes.num_key_syms-1;
		    fprintf(stderr,"     symbols:  %d..%d\n",first,last);
		}
		if (changes.changed&XkbKeyActionsMask) {
		    int last,first= changes.first_key_act;
		    last= changes.first_key_act+changes.num_key_acts-1;
		    fprintf(stderr,"     acts:  %d..%d\n",first,last);
		}
		if (changes.changed&XkbKeyBehaviorsMask) {
		    int last,first= changes.first_key_behavior;
		    last= first+changes.num_key_behaviors-1;
		    fprintf(stderr,"   behaviors:  %d..%d\n",first,last);
		}
		if (changes.changed&XkbVirtualModsMask) {
		    fprintf(stderr,"virtual mods: 0x%04x\n",
					changes.vmods);
		}
		if (changes.changed&XkbExplicitComponentsMask) {
		    int last,first= changes.first_key_explicit;
		    last= first+changes.num_key_explicit-1;
		    fprintf(stderr,"    explicit:  %d..%d\n",first,last);
		}
#endif
	}
	LockDisplay(dpy);
	if (xkbi->flags&XkbMapPending) {
	    xkbi->flags&= ~XkbMapPending;
	    bzero(&xkbi->changes,sizeof(XkbMapChangesRec));
	}
	UnlockDisplay(dpy);
    }
    if (event->request==MappingModifier) {
	LockDisplay(dpy);
	if (xkbi->desc->map->modmap) {
	    _XkbFree(xkbi->desc->map->modmap);
	    xkbi->desc->map->modmap= NULL;
	}
	if (dpy->key_bindings) {
	    register struct _XKeytrans *p;
	    for (p = dpy->key_bindings; p; p = p->next) {
		register int i;
		p->state= 0;
	  	if (p->mlen>0) {
		    for (i = 0; i < p->mlen; i++) {
			p->state|= XkbKeysymToModifiers(dpy,p->modifiers[i]);
		    }
		    if (p->state)	p->state &= AllMods;
		    else		p->state = AnyModifier;
		}
	    }
	}
	UnlockDisplay(dpy);
d515 1
a515 1
    unsigned query,oldEvents;
d518 2
a519 2
    if (!XkbUseExtension(dpy,NULL,NULL))
	return 0;
d523 1
a523 1
    desc = XkbGetMap(dpy,query,XkbUseCoreKbd);
d526 1
a526 1
	fprintf(stderr,"Warning! XkbGetMap failed!\n");
d528 1
a528 1
	return 0;
d534 6
a539 5
    oldEvents= xkbi->selected_events;
    if (!(xkbi->xlib_ctrls&XkbLC_IgnoreNewKeyboards)) {
	XkbSelectEventDetails(dpy,xkbi->desc->device_spec,XkbNewKeyboardNotify,
				XkbNKN_KeycodesMask|XkbNKN_DeviceIDMask,
				XkbNKN_KeycodesMask|XkbNKN_DeviceIDMask);
d541 2
a542 2
    XkbSelectEventDetails(dpy,xkbi->desc->device_spec,XkbMapNotify,
				XkbAllClientInfoMask,XkbAllClientInfoMask);
d544 1
a544 1
    xkbi->selected_events= oldEvents;
d554 1
a554 1
    unsigned	oldDeviceID;
d557 1
a557 1
	return;
d562 5
a566 5
	oldDeviceID= xkbi->desc->device_spec;
	XkbFreeKeyboard(xkbi->desc,XkbAllComponentsMask,True);
	xkbi->desc= NULL;
	xkbi->flags&= ~(XkbMapPending|XkbXlibNewKeyboard);
	xkbi->changes.changed= 0;
d568 2
a569 1
    else oldDeviceID= XkbUseCoreKbd;
d571 1
a571 1
    desc = XkbGetMap(dpy,XkbAllClientInfoMask,XkbUseCoreKbd);
d573 1
a573 1
	return;
d578 2
a579 2
    if (desc->device_spec!=oldDeviceID) {
	/* transfer(?) event masks here */
d581 8
a588 7
	unsigned oldEvents;
	oldEvents= xkbi->selected_events;
	XkbSelectEventDetails(dpy,xkbi->desc->device_spec,XkbMapNotify,
				XkbAllMapComponentsMask,XkbAllClientInfoMask);
	LockDisplay(dpy);
	xkbi->selected_events= oldEvents;
	UnlockDisplay(dpy);
d595 6
a600 6
XkbTranslateKeySym(	register Display *	dpy,
			register KeySym *	sym_rtrn,
			unsigned int 		mods,
			char *			buffer,
			int 			nbytes,
			int *			extra_rtrn)
d602 1
a602 1
    register XkbInfoPtr	xkb;
d608 1
a608 1
    xkb= dpy->xkb_info;
d610 2
a611 2
        _XkbGetConverters(_XkbGetCharset(),&xkb->cvt);
        _XkbGetConverters("ISO8859-1",&xkb->latin1cvt);
d615 1
a615 1
	*extra_rtrn= 0;
d617 3
a619 3
    if ((buffer==NULL)||(nbytes==0)) {
	buffer= tmp;
	nbytes= 4;
d623 1
a623 1
    n = XkbLookupKeyBinding(dpy,*sym_rtrn,mods,buffer,nbytes,extra_rtrn);
d627 2
a628 2
    if ( nbytes>0 )
	buffer[0]= '\0';
d630 2
a631 2
    if ( xkb->cvt.KSToUpper && (mods&LockMask) ) {
	*sym_rtrn = (*xkb->cvt.KSToUpper)(*sym_rtrn);
d634 38
a671 35
	cvtr = xkb->latin1cvt.KSToMB;
	priv = xkb->latin1cvt.KSToMBPriv;
    } else {
	cvtr = xkb->cvt.KSToMB;
	priv = xkb->cvt.KSToMBPriv;
    }

    n = (*cvtr)(priv,*sym_rtrn,buffer,nbytes,extra_rtrn);

    if ((!xkb->cvt.KSToUpper)&&( mods&LockMask )) {
	register int i;
	int change;
	char ch;
	for (i=change=0;i<n;i++) {
	    ch= toupper(buffer[i]);
	    change= (change||(buffer[i]!=ch));
	    buffer[i] = ch;
	}
	if (change) {
	    if (n==1)
	        *sym_rtrn=(*xkb->cvt.MBToKS)(xkb->cvt.MBToKSPriv,buffer,n,NULL);
	    else *sym_rtrn= NoSymbol;
	}
    }

    if ( mods&ControlMask ) {
	if ( n==1 ) {
	    buffer[0]= XkbToControl(buffer[0]);
	    if ( nbytes>1 )
		buffer[1]= '\0';
	    return 1;
	}
	if ( nbytes > 0 )
	    buffer[0]= '\0';
	return 0;
d677 5
a681 5
XLookupString (	register XKeyEvent *	event,
		char *			buffer,
		int 			nbytes,
		KeySym *		keysym,
		XComposeStatus *	status)
d683 1
a683 1
    KeySym	dummy;
d688 5
a692 5
    if (keysym==NULL)
	keysym= &dummy;
    if (!XkbLookupKeySym(dpy,event->keycode,event->state, &new_mods,keysym))
	return 0;
    new_mods= (event->state&(~new_mods));
d695 8
a702 7
    if (new_mods&ControlMask && *keysym > 0x7F &&
	(dpy->xkb_info->xlib_ctrls & XkbLC_ControlFallback)) {
	XKeyEvent tmp_ev = *event;
	KeySym tmp_keysym;
	unsigned int tmp_new_mods;
	if (_XkbUnavailable(dpy)) {
            tmp_ev.state= event->state ^ dpy->mode_switch;
d705 1
a705 1
                tmp_keysym != NoSymbol && tmp_keysym < 0x80 ) {
d708 2
a709 1
        } else {
d712 1
d716 1
a716 1
                tmp_ev.state= XkbBuildCoreState(tmp_ev.state, i);
d718 2
a719 2
                                     &tmp_new_mods, &tmp_keysym) &&
                    tmp_keysym != NoSymbol && tmp_keysym < 0x80 ) {
d721 1
a721 1
                    new_mods= (event->state&(~tmp_new_mods));
d729 21
a749 20
    if ( status ) {
	static int been_here= 0;
	if ( !been_here ) {
	    XimCompInitTables();
	    been_here = 1;
	}
	if ( !XimCompLegalStatus(status) ) {
	    status->compose_ptr = NULL;
	    status->chars_matched = 0;
	}
	if ( ((status->chars_matched>0)&&(status->compose_ptr!=NULL)) ||
		XimCompIsComposeKey(*keysym,event->keycode,status) ) {
	    XimCompRtrn rtrn;

	    switch (XimCompProcessSym(status,*keysym,&rtrn)) {
		case XIM_COMP_IGNORE:
		    break;
		case XIM_COMP_IN_PROGRESS:
		    if ( keysym!=NULL )
			*keysym = NoSymbol;
d751 11
a761 10
		    if ( dpy->xkb_info->xlib_ctrls&XkbLC_ComposeLED ) {
			XkbSetNamedIndicator(dpy,dpy->xkb_info->composeLED,
						True,True,False,NULL);
		    }
#endif
		    return 0;
		case XIM_COMP_FAIL:
		{
		    static Atom _ComposeFail= None;
		    int n = 0, len= 0;
d763 4
a766 4
		    if ( dpy->xkb_info->xlib_ctrls&XkbLC_ComposeLED ) {
			XkbSetNamedIndicator(dpy,dpy->xkb_info->composeLED,
						True,False,False,NULL);
		    }
d769 24
a792 22
		    if (dpy->xkb_info->xlib_ctrls&XkbLC_BeepOnComposeFail) {
			if (_ComposeFail==None)
			    _ComposeFail= XInternAtom(dpy,"ComposeFail",0);
			XkbBell(dpy,event->window,0,_ComposeFail);
		    }
#endif
		    for (n=len=0;rtrn.sym[n]!=XK_VoidSymbol;n++) {
			if ( nbytes-len > 0 ) {
			    len+= XkbTranslateKeySym(dpy,&rtrn.sym[n],new_mods,
							buffer+len,nbytes-len,
							NULL);
			}
		    }
		    if ( keysym!=NULL ) {
			if ( n==1 )	*keysym = rtrn.sym[0];
			else		*keysym = NoSymbol;
		    }
		    return len;
		}
		case XIM_COMP_SUCCEED:
		{
		    int len,n = 0;
d795 27
a821 28
		    if ( dpy->xkb_info->xlib_ctrls&XkbLC_ComposeLED ) {
			XkbSetNamedIndicator(dpy,dpy->xkb_info->composeLED,
						True,False,False,NULL);
		    }
#endif
		    *keysym = rtrn.matchSym;
		    if ( rtrn.str[0]!='\0' ) {
			strncpy(buffer,rtrn.str,nbytes-1);
			buffer[nbytes-1]= '\0';
			len = (int)strlen(buffer);
		    }
		    else {
			len = XkbTranslateKeySym(dpy,keysym,new_mods,
							buffer,nbytes,
							NULL);
		    }
		    for (n=0;rtrn.sym[n]!=XK_VoidSymbol;n++) {
			if ( nbytes-len > 0 ) {
			    len+= XkbTranslateKeySym(dpy,&rtrn.sym[n],
							event->state,
							buffer+len,nbytes-len,
							NULL);
			}
		    }
		    return len;
		}
	    }
	}
d829 2
a830 2
	(dpy->xkb_info->xlib_ctrls&XkbLC_ConsumeLookupMods)==0)
	new_mods= event->state;
d832 3
a834 3
    rtrnLen= XkbLookupKeyBinding(dpy,*keysym,new_mods,buffer,nbytes,NULL);
    if (rtrnLen>0)
	return rtrnLen;
d836 1
a836 1
    return XkbTranslateKeySym(dpy,keysym,new_mods,buffer,nbytes,NULL);
d841 6
a846 6
XkbLookupKeyBinding(	Display *		dpy,
			register KeySym 	sym,
			unsigned int 		mods,
			char *			buffer,
			int 			nbytes,
			int * 			extra_rtrn)
d851 1
a851 1
	*extra_rtrn= 0;
d853 13
a865 11
	if (((mods & AllMods) == p->state) && (sym == p->key)) {
	    int tmp = p->len;
	    if (tmp > nbytes) {
		if (extra_rtrn)
		    *extra_rtrn= (tmp-nbytes);
		tmp = nbytes;
	    }
	    memcpy (buffer, p->string, tmp);
	    if (tmp < nbytes)	buffer[tmp]= '\0';
	    return tmp;
	}
d871 1
a871 1
XkbToControl( char ch )
d875 10
a884 5
    if ((c >= '@@' && c < '\177') || c == ' ') c &= 0x1F;
    else if (c == '2') c = '\000';
    else if (c >= '3' && c <= '7') c -= ('3' - '\033');
    else if (c == '8') c = '\177';
    else if (c == '/') c = '_' & 0x1F;
@


1.4
log
@Update to libX11 1.3.3. Tested on a bulk ports build by naddy@@.
@
text
@a30 1
#define NEED_EVENTS
@


1.3
log
@update to libX11 1.2.1
@
text
@a0 1
/* $Xorg: XKBBind.c,v 1.4 2001/02/09 02:03:37 xorgcvs Exp $ */
a27 1
/* $XFree86: xc/lib/X11/XKBBind.c,v 3.19 2003/05/27 22:26:25 tsi Exp $ */
@


1.2
log
@Update to libX11 1.1.4. I've carefully checked that there's no API/ABI
change in this version. Only small bug fixes, manual page fixes and
some more data in the i18n tables.
@
text
@d80 1
a80 1
    
d115 1
a115 1
    
d124 1
a124 1
    
d232 2
a233 2
    * Not a public entry point -- XkbTranslateKey is an obsolete name 
    * that is preserved here so that functions linked against the old 
d331 4
a334 4
	 * is bound to Shift+<whatever>, and it appears as though it 
	 * is XkbTranslateKeyCode that is causing the problem.  The 
	 * core X version of XTranslateKey always OR's in ShiftMask 
	 * and LockMask for mods_rtrn, so this "fix" keeps this behavior 
d635 1
a635 1
	        *sym_rtrn=(*xkb->cvt.MBToKS)(xkb->cvt.MBToKSPriv,buffer,n,0);
d701 1
a701 1
    }                  	                                	 
d714 1
a714 1
	if ( ((status->chars_matched>0)&&(status->compose_ptr!=NULL)) || 
d820 1
a820 1
    register struct _XKeytrans *p; 
d844 1
a844 1
 
@


1.1
log
@Initial revision
@
text
@a370 1
	LockDisplay(dpy);
a380 1
	UnlockDisplay(dpy);
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
