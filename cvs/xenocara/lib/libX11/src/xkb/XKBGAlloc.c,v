head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.10
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.8
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.6
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.2
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_1_3:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	v1_0_99_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.04.06.20.57.59;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	L5f7tv2EiGjtzoSu;

1.7
date	2013.09.28.17.03.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.04.28.16.55.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.08.27.15.34.15;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.30.19.19.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.18.19.37.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.12.59.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.16.37.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.16.37.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@update to libX11 1.6.3
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif


#include <stdio.h>
#include "Xlibint.h"
#include "XKBlibint.h"
#include <X11/extensions/XKBgeom.h>
#include <X11/extensions/XKBproto.h>

/***====================================================================***/

static void
_XkbFreeGeomLeafElems(Bool freeAll,
                      int first,
                      int count,
                      unsigned short *num_inout,
                      unsigned short *sz_inout,
                      char **elems,
                      unsigned int elem_sz)
{
    if ((freeAll) || (*elems == NULL)) {
        *num_inout = *sz_inout = 0;
        if (*elems != NULL) {
            _XkbFree(*elems);
            *elems = NULL;
        }
        return;
    }

    if ((first >= (*num_inout)) || (first < 0) || (count < 1))
        return;

    if (first + count >= (*num_inout)) {
        /* truncating the array is easy */
        (*num_inout) = first;
    }
    else {
        char *ptr;
        int extra;

        ptr = *elems;
        extra = ((*num_inout) - (first + count)) * elem_sz;
        if (extra > 0)
            memmove(&ptr[first * elem_sz], &ptr[(first + count) * elem_sz],
                    extra);
        (*num_inout) -= count;
    }
    return;
}

typedef void (*ContentsClearFunc) (
    char *       /* priv */
);

static void
_XkbFreeGeomNonLeafElems(Bool freeAll,
                         int first,
                         int count,
                         unsigned short *num_inout,
                         unsigned short *sz_inout,
                         char **elems,
                         unsigned int elem_sz,
                         ContentsClearFunc freeFunc)
{
    register int i;
    register char *ptr;

    if (freeAll) {
        first = 0;
        count = (*num_inout);
    }
    else if ((first >= (*num_inout)) || (first < 0) || (count < 1))
        return;
    else if (first + count > (*num_inout))
        count = (*num_inout) - first;
    if (*elems == NULL)
        return;

    if (freeFunc) {
        ptr = *elems;
        ptr += first * elem_sz;
        for (i = 0; i < count; i++) {
            (*freeFunc) (ptr);
            ptr += elem_sz;
        }
    }
    if (freeAll) {
        (*num_inout) = (*sz_inout) = 0;
        if (*elems) {
            _XkbFree(*elems);
            *elems = NULL;
        }
    }
    else if (first + count >= (*num_inout))
        *num_inout = first;
    else {
        i = ((*num_inout) - (first + count)) * elem_sz;
        ptr = *elems;
        memmove(&ptr[first * elem_sz], &ptr[(first + count) * elem_sz], i);
        (*num_inout) -= count;
    }
    return;
}

/***====================================================================***/

static void
_XkbClearProperty(char *prop_in)
{
    XkbPropertyPtr prop = (XkbPropertyPtr) prop_in;

    if (prop->name) {
        _XkbFree(prop->name);
        prop->name = NULL;
    }
    if (prop->value) {
        _XkbFree(prop->value);
        prop->value = NULL;
    }
    return;
}

void
XkbFreeGeomProperties(XkbGeometryPtr geom, int first, int count, Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll, first, count,
                             &geom->num_properties, &geom->sz_properties,
                             (char **) &geom->properties,
                             sizeof(XkbPropertyRec), _XkbClearProperty);
    return;
}

/***====================================================================***/

void
XkbFreeGeomKeyAliases(XkbGeometryPtr geom, int first, int count, Bool freeAll)
{
    _XkbFreeGeomLeafElems(freeAll, first, count,
                          &geom->num_key_aliases, &geom->sz_key_aliases,
                          (char **) &geom->key_aliases,
                          sizeof(XkbKeyAliasRec));
    return;
}

/***====================================================================***/

static void
_XkbClearColor(char *color_in)
{
    XkbColorPtr color = (XkbColorPtr) color_in;

    _XkbFree(color->spec);
    return;
}

void
XkbFreeGeomColors(XkbGeometryPtr geom, int first, int count, Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll, first, count,
                             &geom->num_colors, &geom->sz_colors,
                             (char **) &geom->colors,
                             sizeof(XkbColorRec), _XkbClearColor);
    return;
}

/***====================================================================***/

void
XkbFreeGeomPoints(XkbOutlinePtr outline, int first, int count, Bool freeAll)
{
    _XkbFreeGeomLeafElems(freeAll, first, count,
                          &outline->num_points, &outline->sz_points,
                          (char **) &outline->points,
                          sizeof(XkbPointRec));
    return;
}

/***====================================================================***/

static void
_XkbClearOutline(char *outline_in)
{
    XkbOutlinePtr outline = (XkbOutlinePtr) outline_in;

    if (outline->points != NULL)
        XkbFreeGeomPoints(outline, 0, outline->num_points, True);
    return;
}

void
XkbFreeGeomOutlines(XkbShapePtr shape, int first, int count, Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll, first, count,
                             &shape->num_outlines, &shape->sz_outlines,
                             (char **) &shape->outlines,
                             sizeof(XkbOutlineRec), _XkbClearOutline);

    return;
}

/***====================================================================***/

static void
_XkbClearShape(char *shape_in)
{
    XkbShapePtr shape = (XkbShapePtr) shape_in;

    if (shape->outlines)
        XkbFreeGeomOutlines(shape, 0, shape->num_outlines, True);
    return;
}

void
XkbFreeGeomShapes(XkbGeometryPtr geom, int first, int count, Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll, first, count,
                             &geom->num_shapes, &geom->sz_shapes,
                             (char **) &geom->shapes,
                             sizeof(XkbShapeRec), _XkbClearShape);
    return;
}

/***====================================================================***/

void
XkbFreeGeomOverlayKeys(XkbOverlayRowPtr row, int first, int count, Bool freeAll)
{
    _XkbFreeGeomLeafElems(freeAll, first, count,
                          &row->num_keys, &row->sz_keys,
                          (char **) &row->keys,
                          sizeof(XkbOverlayKeyRec));
    return;
}

/***====================================================================***/

static void
_XkbClearOverlayRow(char *row_in)
{
    XkbOverlayRowPtr row = (XkbOverlayRowPtr) row_in;

    if (row->keys != NULL)
        XkbFreeGeomOverlayKeys(row, 0, row->num_keys, True);
    return;
}

void
XkbFreeGeomOverlayRows(XkbOverlayPtr overlay, int first, int count,
                       Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll, first, count,
                             &overlay->num_rows, &overlay->sz_rows,
                             (char **) &overlay->rows,
                             sizeof(XkbOverlayRowRec), _XkbClearOverlayRow);
    return;
}

/***====================================================================***/

static void
_XkbClearOverlay(char *overlay_in)
{
    XkbOverlayPtr overlay = (XkbOverlayPtr) overlay_in;

    if (overlay->rows != NULL)
        XkbFreeGeomOverlayRows(overlay, 0, overlay->num_rows, True);
    return;
}

void
XkbFreeGeomOverlays(XkbSectionPtr section, int first, int count, Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll, first, count,
                             &section->num_overlays, &section->sz_overlays,
                             (char **) &section->overlays,
                             sizeof(XkbOverlayRec), _XkbClearOverlay);
    return;
}

/***====================================================================***/

void
XkbFreeGeomKeys(XkbRowPtr row, int first, int count, Bool freeAll)
{
    _XkbFreeGeomLeafElems(freeAll, first, count,
                          &row->num_keys, &row->sz_keys,
                          (char **) &row->keys,
                          sizeof(XkbKeyRec));
    return;
}

/***====================================================================***/

static void
_XkbClearRow(char *row_in)
{
    XkbRowPtr row = (XkbRowPtr) row_in;

    if (row->keys != NULL)
        XkbFreeGeomKeys(row, 0, row->num_keys, True);
    return;
}

void
XkbFreeGeomRows(XkbSectionPtr section, int first, int count, Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll, first, count,
                             &section->num_rows, &section->sz_rows,
                             (char **) &section->rows,
                             sizeof(XkbRowRec), _XkbClearRow);
}

/***====================================================================***/

static void
_XkbClearSection(char *section_in)
{
    XkbSectionPtr section = (XkbSectionPtr) section_in;

    if (section->rows != NULL)
        XkbFreeGeomRows(section, 0, section->num_rows, True);
    if (section->doodads != NULL) {
        XkbFreeGeomDoodads(section->doodads, section->num_doodads, True);
        section->doodads = NULL;
    }
    return;
}

void
XkbFreeGeomSections(XkbGeometryPtr geom, int first, int count, Bool freeAll)
{
    _XkbFreeGeomNonLeafElems(freeAll, first, count,
                             &geom->num_sections, &geom->sz_sections,
                             (char **) &geom->sections,
                             sizeof(XkbSectionRec), _XkbClearSection);
    return;
}

/***====================================================================***/

static void
_XkbClearDoodad(char *doodad_in)
{
    XkbDoodadPtr doodad = (XkbDoodadPtr) doodad_in;

    switch (doodad->any.type) {
    case XkbTextDoodad:
    {
        if (doodad->text.text != NULL) {
            _XkbFree(doodad->text.text);
            doodad->text.text = NULL;
        }
        if (doodad->text.font != NULL) {
            _XkbFree(doodad->text.font);
            doodad->text.font = NULL;
        }
    }
        break;
    case XkbLogoDoodad:
    {
        if (doodad->logo.logo_name != NULL) {
            _XkbFree(doodad->logo.logo_name);
            doodad->logo.logo_name = NULL;
        }
    }
        break;
    }
    return;
}

void
XkbFreeGeomDoodads(XkbDoodadPtr doodads, int nDoodads, Bool freeAll)
{
    register int i;
    register XkbDoodadPtr doodad;

    if (doodads) {
        for (i = 0, doodad = doodads; i < nDoodads; i++, doodad++) {
            _XkbClearDoodad((char *) doodad);
        }
        if (freeAll)
            _XkbFree(doodads);
    }
    return;
}

void
XkbFreeGeometry(XkbGeometryPtr geom, unsigned which, Bool freeMap)
{
    if (geom == NULL)
        return;
    if (freeMap)
        which = XkbGeomAllMask;
    if ((which & XkbGeomPropertiesMask) && (geom->properties != NULL))
        XkbFreeGeomProperties(geom, 0, geom->num_properties, True);
    if ((which & XkbGeomColorsMask) && (geom->colors != NULL))
        XkbFreeGeomColors(geom, 0, geom->num_colors, True);
    if ((which & XkbGeomShapesMask) && (geom->shapes != NULL))
        XkbFreeGeomShapes(geom, 0, geom->num_shapes, True);
    if ((which & XkbGeomSectionsMask) && (geom->sections != NULL))
        XkbFreeGeomSections(geom, 0, geom->num_sections, True);
    if ((which & XkbGeomDoodadsMask) && (geom->doodads != NULL)) {
        XkbFreeGeomDoodads(geom->doodads, geom->num_doodads, True);
        geom->doodads = NULL;
        geom->num_doodads = geom->sz_doodads = 0;
    }
    if ((which & XkbGeomKeyAliasesMask) && (geom->key_aliases != NULL))
        XkbFreeGeomKeyAliases(geom, 0, geom->num_key_aliases, True);
    if (freeMap) {
        if (geom->label_font != NULL) {
            _XkbFree(geom->label_font);
            geom->label_font = NULL;
        }
        _XkbFree(geom);
    }
    return;
}

/***====================================================================***/

static Status
_XkbGeomAlloc(XPointer *old,
              unsigned short *num,
              unsigned short *total,
              int num_new,
              size_t sz_elem)
{
    if (num_new < 1)
        return Success;
    if ((*old) == NULL)
        *num = *total = 0;

    if ((*num) + num_new <= (*total))
        return Success;

    *total = (*num) + num_new;
    if ((*old) != NULL)
        (*old) = (XPointer) _XkbRealloc((*old), (*total) * sz_elem);
    else
        (*old) = (XPointer) _XkbCalloc((*total), sz_elem);
    if ((*old) == NULL) {
        *total = *num = 0;
        return BadAlloc;
    }

    if (*num > 0) {
        char *tmp = (char *) (*old);
        bzero(&tmp[sz_elem * (*num)], (num_new * sz_elem));
    }
    return Success;
}

#define _XkbAllocProps(g, n) _XkbGeomAlloc((XPointer *)&(g)->properties, \
                                &(g)->num_properties, &(g)->sz_properties, \
                                (n), sizeof(XkbPropertyRec))
#define _XkbAllocColors(g, n) _XkbGeomAlloc((XPointer *)&(g)->colors, \
                                &(g)->num_colors, &(g)->sz_colors, \
                                (n), sizeof(XkbColorRec))
#define _XkbAllocShapes(g, n) _XkbGeomAlloc((XPointer *)&(g)->shapes, \
                                &(g)->num_shapes, &(g)->sz_shapes, \
                                (n), sizeof(XkbShapeRec))
#define _XkbAllocSections(g, n) _XkbGeomAlloc((XPointer *)&(g)->sections, \
                                &(g)->num_sections, &(g)->sz_sections, \
                                (n), sizeof(XkbSectionRec))
#define _XkbAllocDoodads(g, n) _XkbGeomAlloc((XPointer *)&(g)->doodads, \
                                &(g)->num_doodads, &(g)->sz_doodads, \
                                (n), sizeof(XkbDoodadRec))
#define _XkbAllocKeyAliases(g, n) _XkbGeomAlloc((XPointer *)&(g)->key_aliases, \
                                &(g)->num_key_aliases, &(g)->sz_key_aliases, \
                                (n), sizeof(XkbKeyAliasRec))

#define _XkbAllocOutlines(s, n) _XkbGeomAlloc((XPointer *)&(s)->outlines, \
                                &(s)->num_outlines, &(s)->sz_outlines, \
                                (n), sizeof(XkbOutlineRec))
#define _XkbAllocRows(s, n) _XkbGeomAlloc((XPointer *)&(s)->rows, \
                                &(s)->num_rows, &(s)->sz_rows, \
                                (n), sizeof(XkbRowRec))
#define _XkbAllocPoints(o, n) _XkbGeomAlloc((XPointer *)&(o)->points, \
                                &(o)->num_points, &(o)->sz_points, \
                                (n), sizeof(XkbPointRec))
#define _XkbAllocKeys(r, n) _XkbGeomAlloc((XPointer *)&(r)->keys, \
                                &(r)->num_keys, &(r)->sz_keys, \
                                (n), sizeof(XkbKeyRec))
#define _XkbAllocOverlays(s, n) _XkbGeomAlloc((XPointer *)&(s)->overlays, \
                                &(s)->num_overlays, &(s)->sz_overlays, \
                                (n), sizeof(XkbOverlayRec))
#define _XkbAllocOverlayRows(o, n) _XkbGeomAlloc((XPointer *)&(o)->rows, \
                                &(o)->num_rows, &(o)->sz_rows, \
                                (n), sizeof(XkbOverlayRowRec))
#define _XkbAllocOverlayKeys(r, n) _XkbGeomAlloc((XPointer *)&(r)->keys, \
                                &(r)->num_keys, &(r)->sz_keys, \
                                (n), sizeof(XkbOverlayKeyRec))

Status
XkbAllocGeomProps(XkbGeometryPtr geom, int nProps)
{
    return _XkbAllocProps(geom, nProps);
}

Status
XkbAllocGeomColors(XkbGeometryPtr geom, int nColors)
{
    return _XkbAllocColors(geom, nColors);
}

Status
XkbAllocGeomKeyAliases(XkbGeometryPtr geom, int nKeyAliases)
{
    return _XkbAllocKeyAliases(geom, nKeyAliases);
}

Status
XkbAllocGeomShapes(XkbGeometryPtr geom, int nShapes)
{
    return _XkbAllocShapes(geom, nShapes);
}

Status
XkbAllocGeomSections(XkbGeometryPtr geom, int nSections)
{
    return _XkbAllocSections(geom, nSections);
}

Status
XkbAllocGeomOverlays(XkbSectionPtr section, int nOverlays)
{
    return _XkbAllocOverlays(section, nOverlays);
}

Status
XkbAllocGeomOverlayRows(XkbOverlayPtr overlay, int nRows)
{
    return _XkbAllocOverlayRows(overlay, nRows);
}

Status
XkbAllocGeomOverlayKeys(XkbOverlayRowPtr row, int nKeys)
{
    return _XkbAllocOverlayKeys(row, nKeys);
}

Status
XkbAllocGeomDoodads(XkbGeometryPtr geom, int nDoodads)
{
    return _XkbAllocDoodads(geom, nDoodads);
}

Status
XkbAllocGeomSectionDoodads(XkbSectionPtr section, int nDoodads)
{
    return _XkbAllocDoodads(section, nDoodads);
}

Status
XkbAllocGeomOutlines(XkbShapePtr shape, int nOL)
{
    return _XkbAllocOutlines(shape, nOL);
}

Status
XkbAllocGeomRows(XkbSectionPtr section, int nRows)
{
    return _XkbAllocRows(section, nRows);
}

Status
XkbAllocGeomPoints(XkbOutlinePtr ol, int nPts)
{
    return _XkbAllocPoints(ol, nPts);
}

Status
XkbAllocGeomKeys(XkbRowPtr row, int nKeys)
{
    return _XkbAllocKeys(row, nKeys);
}

Status
XkbAllocGeometry(XkbDescPtr xkb, XkbGeometrySizesPtr sizes)
{
    XkbGeometryPtr geom;
    Status rtrn;

    if (xkb->geom == NULL) {
        xkb->geom = _XkbTypedCalloc(1, XkbGeometryRec);
        if (!xkb->geom)
            return BadAlloc;
    }
    geom = xkb->geom;
    if ((sizes->which & XkbGeomPropertiesMask) &&
        ((rtrn = _XkbAllocProps(geom, sizes->num_properties)) != Success)) {
        goto BAIL;
    }
    if ((sizes->which & XkbGeomColorsMask) &&
        ((rtrn = _XkbAllocColors(geom, sizes->num_colors)) != Success)) {
        goto BAIL;
    }
    if ((sizes->which & XkbGeomShapesMask) &&
        ((rtrn = _XkbAllocShapes(geom, sizes->num_shapes)) != Success)) {
        goto BAIL;
    }
    if ((sizes->which & XkbGeomSectionsMask) &&
        ((rtrn = _XkbAllocSections(geom, sizes->num_sections)) != Success)) {
        goto BAIL;
    }
    if ((sizes->which & XkbGeomDoodadsMask) &&
        ((rtrn = _XkbAllocDoodads(geom, sizes->num_doodads)) != Success)) {
        goto BAIL;
    }
    if ((sizes->which & XkbGeomKeyAliasesMask) &&
        ((rtrn = _XkbAllocKeyAliases(geom, sizes->num_key_aliases))
         != Success)) {
        goto BAIL;
    }
    return Success;
 BAIL:
    XkbFreeGeometry(geom, XkbGeomAllMask, True);
    xkb->geom = NULL;
    return rtrn;
}

/***====================================================================***/

XkbPropertyPtr
XkbAddGeomProperty(XkbGeometryPtr geom, char *name, char *value)
{
    register int i;
    register XkbPropertyPtr prop;

    if ((!geom) || (!name) || (!value))
        return NULL;
    for (i = 0, prop = geom->properties; i < geom->num_properties; i++, prop++) {
        if ((prop->name) && (strcmp(name, prop->name) == 0)) {
            _XkbFree(prop->value);
            prop->value = strdup(value);
            return prop;
        }
    }
    if ((geom->num_properties >= geom->sz_properties) &&
        (_XkbAllocProps(geom, 1) != Success)) {
        return NULL;
    }
    prop = &geom->properties[geom->num_properties];
    prop->name = strdup(name);
    if (!prop->name)
        return NULL;
    prop->value = strdup(value);
    if (!prop->value) {
        _XkbFree(prop->name);
        prop->name = NULL;
        return NULL;
    }
    geom->num_properties++;
    return prop;
}

XkbKeyAliasPtr
XkbAddGeomKeyAlias(XkbGeometryPtr geom, char *aliasStr, char *realStr)
{
    register int i;
    register XkbKeyAliasPtr alias;

    if ((!geom) || (!aliasStr) || (!realStr) || (!aliasStr[0]) || (!realStr[0]))
        return NULL;
    for (i = 0, alias = geom->key_aliases; i < geom->num_key_aliases;
         i++, alias++) {
        if (strncmp(alias->alias, aliasStr, XkbKeyNameLength) == 0) {
            bzero(alias->real, XkbKeyNameLength);
            strncpy(alias->real, realStr, XkbKeyNameLength);
            return alias;
        }
    }
    if ((geom->num_key_aliases >= geom->sz_key_aliases) &&
        (_XkbAllocKeyAliases(geom, 1) != Success)) {
        return NULL;
    }
    alias = &geom->key_aliases[geom->num_key_aliases];
    bzero(alias, sizeof(XkbKeyAliasRec));
    strncpy(alias->alias, aliasStr, XkbKeyNameLength);
    strncpy(alias->real, realStr, XkbKeyNameLength);
    geom->num_key_aliases++;
    return alias;
}

XkbColorPtr
XkbAddGeomColor(XkbGeometryPtr geom, char *spec, unsigned int pixel)
{
    register int i;
    register XkbColorPtr color;

    if ((!geom) || (!spec))
        return NULL;
    for (i = 0, color = geom->colors; i < geom->num_colors; i++, color++) {
        if ((color->spec) && (strcmp(color->spec, spec) == 0)) {
            color->pixel = pixel;
            return color;
        }
    }
    if ((geom->num_colors >= geom->sz_colors) &&
        (_XkbAllocColors(geom, 1) != Success)) {
        return NULL;
    }
    color = &geom->colors[geom->num_colors];
    color->pixel = pixel;
    color->spec = strdup(spec);
    if (!color->spec)
        return NULL;
    geom->num_colors++;
    return color;
}

XkbOutlinePtr
XkbAddGeomOutline(XkbShapePtr shape, int sz_points)
{
    XkbOutlinePtr outline;

    if ((!shape) || (sz_points < 0))
        return NULL;
    if ((shape->num_outlines >= shape->sz_outlines) &&
        (_XkbAllocOutlines(shape, 1) != Success)) {
        return NULL;
    }
    outline = &shape->outlines[shape->num_outlines];
    bzero(outline, sizeof(XkbOutlineRec));
    if ((sz_points > 0) && (_XkbAllocPoints(outline, sz_points) != Success))
        return NULL;
    shape->num_outlines++;
    return outline;
}

XkbShapePtr
XkbAddGeomShape(XkbGeometryPtr geom, Atom name, int sz_outlines)
{
    XkbShapePtr shape;
    register int i;

    if ((!geom) || (!name) || (sz_outlines < 0))
        return NULL;
    if (geom->num_shapes > 0) {
        for (shape = geom->shapes, i = 0; i < geom->num_shapes; i++, shape++) {
            if (name == shape->name)
                return shape;
        }
    }
    if ((geom->num_shapes >= geom->sz_shapes) &&
        (_XkbAllocShapes(geom, 1) != Success))
        return NULL;
    shape = &geom->shapes[geom->num_shapes];
    bzero(shape, sizeof(XkbShapeRec));
    if ((sz_outlines > 0) && (_XkbAllocOutlines(shape, sz_outlines) != Success))
        return NULL;
    shape->name = name;
    shape->primary = shape->approx = NULL;
    geom->num_shapes++;
    return shape;
}

XkbKeyPtr
XkbAddGeomKey(XkbRowPtr row)
{
    XkbKeyPtr key;

    if (!row)
        return NULL;
    if ((row->num_keys >= row->sz_keys) && (_XkbAllocKeys(row, 1) != Success))
        return NULL;
    key = &row->keys[row->num_keys++];
    bzero(key, sizeof(XkbKeyRec));
    return key;
}

XkbRowPtr
XkbAddGeomRow(XkbSectionPtr section, int sz_keys)
{
    XkbRowPtr row;

    if ((!section) || (sz_keys < 0))
        return NULL;
    if ((section->num_rows >= section->sz_rows) &&
        (_XkbAllocRows(section, 1) != Success))
        return NULL;
    row = &section->rows[section->num_rows];
    bzero(row, sizeof(XkbRowRec));
    if ((sz_keys > 0) && (_XkbAllocKeys(row, sz_keys) != Success))
        return NULL;
    section->num_rows++;
    return row;
}

XkbSectionPtr
XkbAddGeomSection(XkbGeometryPtr geom,
                  Atom name,
                  int sz_rows,
                  int sz_doodads,
                  int sz_over)
{
    register int i;
    XkbSectionPtr section;

    if ((!geom) || (name == None) || (sz_rows < 0))
        return NULL;
    for (i = 0, section = geom->sections; i < geom->num_sections;
         i++, section++) {
        if (section->name != name)
            continue;
        if (((sz_rows > 0) && (_XkbAllocRows(section, sz_rows) != Success)) ||
            ((sz_doodads > 0) &&
             (_XkbAllocDoodads(section, sz_doodads) != Success)) ||
            ((sz_over > 0) && (_XkbAllocOverlays(section, sz_over) != Success)))
            return NULL;
        return section;
    }
    if ((geom->num_sections >= geom->sz_sections) &&
        (_XkbAllocSections(geom, 1) != Success))
        return NULL;
    section = &geom->sections[geom->num_sections];
    if ((sz_rows > 0) && (_XkbAllocRows(section, sz_rows) != Success))
        return NULL;
    if ((sz_doodads > 0) && (_XkbAllocDoodads(section, sz_doodads) != Success)) {
        if (section->rows) {
            _XkbFree(section->rows);
            section->rows = NULL;
            section->sz_rows = section->num_rows = 0;
        }
        return NULL;
    }
    section->name = name;
    geom->num_sections++;
    return section;
}

XkbDoodadPtr
XkbAddGeomDoodad(XkbGeometryPtr geom, XkbSectionPtr section, Atom name)
{
    XkbDoodadPtr old, doodad;
    register int i, nDoodads;

    if ((!geom) || (name == None))
        return NULL;
    if ((section != NULL) && (section->num_doodads > 0)) {
        old = section->doodads;
        nDoodads = section->num_doodads;
    }
    else {
        old = geom->doodads;
        nDoodads = geom->num_doodads;
    }
    for (i = 0, doodad = old; i < nDoodads; i++, doodad++) {
        if (doodad->any.name == name)
            return doodad;
    }
    if (section) {
        if ((section->num_doodads >= geom->sz_doodads) &&
            (_XkbAllocDoodads(section, 1) != Success)) {
            return NULL;
        }
        doodad = &section->doodads[section->num_doodads++];
    }
    else {
        if ((geom->num_doodads >= geom->sz_doodads) &&
            (_XkbAllocDoodads(geom, 1) != Success))
            return NULL;
        doodad = &geom->doodads[geom->num_doodads++];
    }
    bzero(doodad, sizeof(XkbDoodadRec));
    doodad->any.name = name;
    return doodad;
}

XkbOverlayKeyPtr
XkbAddGeomOverlayKey(XkbOverlayPtr overlay,
                     XkbOverlayRowPtr row,
                     char *over,
                     char *under)
{
    register int i;
    XkbOverlayKeyPtr key;
    XkbSectionPtr section;
    XkbRowPtr row_under;
    Bool found;

    if ((!overlay) || (!row) || (!over) || (!under))
        return NULL;
    section = overlay->section_under;
    if (row->row_under >= section->num_rows)
        return NULL;
    row_under = &section->rows[row->row_under];
    for (i = 0, found = False; i < row_under->num_keys; i++) {
        if (strncmp(under, row_under->keys[i].name.name, XkbKeyNameLength) == 0) {
            found = True;
            break;
        }
    }
    if (!found)
        return NULL;
    if ((row->num_keys >= row->sz_keys) &&
        (_XkbAllocOverlayKeys(row, 1) != Success))
        return NULL;
    key = &row->keys[row->num_keys];
    strncpy(key->under.name, under, XkbKeyNameLength);
    strncpy(key->over.name, over, XkbKeyNameLength);
    row->num_keys++;
    return key;
}

XkbOverlayRowPtr
XkbAddGeomOverlayRow(XkbOverlayPtr overlay, int row_under, int sz_keys)
{
    register int i;
    XkbOverlayRowPtr row;

    if ((!overlay) || (sz_keys < 0))
        return NULL;
    if (row_under >= overlay->section_under->num_rows)
        return NULL;
    for (i = 0; i < overlay->num_rows; i++) {
        if (overlay->rows[i].row_under == row_under) {
            row = &overlay->rows[i];
            if ((row->sz_keys < sz_keys) &&
                (_XkbAllocOverlayKeys(row, sz_keys) != Success)) {
                return NULL;
            }
            return &overlay->rows[i];
        }
    }
    if ((overlay->num_rows >= overlay->sz_rows) &&
        (_XkbAllocOverlayRows(overlay, 1) != Success))
        return NULL;
    row = &overlay->rows[overlay->num_rows];
    bzero(row, sizeof(XkbOverlayRowRec));
    if ((sz_keys > 0) && (_XkbAllocOverlayKeys(row, sz_keys) != Success))
        return NULL;
    row->row_under = row_under;
    overlay->num_rows++;
    return row;
}

XkbOverlayPtr
XkbAddGeomOverlay(XkbSectionPtr section, Atom name, int sz_rows)
{
    register int i;
    XkbOverlayPtr overlay;

    if ((!section) || (name == None) || (sz_rows == 0))
        return NULL;

    for (i = 0, overlay = section->overlays; i < section->num_overlays;
         i++, overlay++) {
        if (overlay->name == name) {
            if ((sz_rows > 0) &&
                (_XkbAllocOverlayRows(overlay, sz_rows) != Success))
                return NULL;
            return overlay;
        }
    }
    if ((section->num_overlays >= section->sz_overlays) &&
        (_XkbAllocOverlays(section, 1) != Success))
        return NULL;
    overlay = &section->overlays[section->num_overlays];
    if ((sz_rows > 0) && (_XkbAllocOverlayRows(overlay, sz_rows) != Success))
        return NULL;
    overlay->name = name;
    overlay->section_under = section;
    section->num_overlays++;
    return overlay;
}
@


1.7
log
@Update to libX11 1.6.2. No API change.
@
text
@d180 1
a180 2
    if (color->spec)
        _XkbFree(color->spec);
d662 1
a662 2
            if (prop->value)
                _XkbFree(prop->value);
@


1.6
log
@Update to libX11 1.6RC. No bump needed.
@
text
@d27 1
a27 3
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#elif defined(HAVE_CONFIG_H)
d41 23
a63 23
_XkbFreeGeomLeafElems(	Bool			freeAll,
			int			first,
			int 			count,
			unsigned short *	num_inout,
			unsigned short *	sz_inout,
			char **			elems,
			unsigned int		elem_sz)
{
    if ((freeAll)||(*elems==NULL)) {
	*num_inout= *sz_inout= 0;
	if (*elems!=NULL) {
	    _XkbFree(*elems);
	    *elems= NULL;
	}
	return;
    }

    if ((first>=(*num_inout))||(first<0)||(count<1))
	return;

    if (first+count>=(*num_inout)) {
	/* truncating the array is easy */
	(*num_inout)= first;
d66 9
a74 7
	char *	ptr;
	int 	extra;
	ptr= *elems;
	extra= ((*num_inout)-(first+count))*elem_sz;
	if (extra>0)
	    memmove(&ptr[first*elem_sz],&ptr[(first+count)*elem_sz],extra);
	(*num_inout)-= count;
d79 2
a80 2
typedef void (*ContentsClearFunc)(
		char *		/* priv */
d84 8
a91 8
_XkbFreeGeomNonLeafElems(	Bool			freeAll,
				int			first,
				int 			count,
				unsigned short *	num_inout,
				unsigned short *	sz_inout,
				char **			elems,
				unsigned int		elem_sz,
				ContentsClearFunc	freeFunc)
d93 2
a94 2
register int i;
register char *ptr;
d97 2
a98 2
	first= 0;
	count= (*num_inout);
d100 6
a105 6
    else if ((first>=(*num_inout))||(first<0)||(count<1))
	return;
    else if (first+count>(*num_inout))
	count= (*num_inout)-first;
    if (*elems==NULL)
	return;
d108 6
a113 6
	ptr= *elems;
	ptr+= first*elem_sz;
	for (i=0;i<count;i++) {
	    (*freeFunc)(ptr);
	    ptr+= elem_sz;
	}
d116 5
a120 5
	(*num_inout)= (*sz_inout)= 0;
	if (*elems) {
	    _XkbFree(*elems);
	    *elems= NULL;
	}
d122 2
a123 2
    else if (first+count>=(*num_inout))
	*num_inout= first;
d125 4
a128 4
	i= ((*num_inout)-(first+count))*elem_sz;
	ptr= *elems;
	memmove(&ptr[first*elem_sz],&ptr[(first+count)*elem_sz],i);
	(*num_inout)-= count;
d138 1
a138 1
XkbPropertyPtr	prop= (XkbPropertyPtr)prop_in;
d141 2
a142 2
	_XkbFree(prop->name);
	prop->name= NULL;
d145 2
a146 2
	_XkbFree(prop->value);
	prop->value= NULL;
d152 1
a152 4
XkbFreeGeomProperties(	XkbGeometryPtr	geom,
			int		first,
			int		count,
			Bool		freeAll)
d154 4
a157 4
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&geom->num_properties,&geom->sz_properties,
				(char **)&geom->properties,
				sizeof(XkbPropertyRec),_XkbClearProperty);
d164 1
a164 4
XkbFreeGeomKeyAliases(	XkbGeometryPtr	geom,
			int		first,
			int		count,
			Bool		freeAll)
d166 4
a169 4
    _XkbFreeGeomLeafElems(freeAll,first,count,
				&geom->num_key_aliases,&geom->sz_key_aliases,
				(char **)&geom->key_aliases,
				sizeof(XkbKeyAliasRec));
d178 1
a178 1
XkbColorPtr	color= (XkbColorPtr)color_in;
d181 1
a181 1
	_XkbFree(color->spec);
d186 1
a186 1
XkbFreeGeomColors(XkbGeometryPtr geom,int first,int count,Bool freeAll)
d188 4
a191 4
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&geom->num_colors,&geom->sz_colors,
				(char **)&geom->colors,
				sizeof(XkbColorRec),_XkbClearColor);
d198 1
a198 1
XkbFreeGeomPoints(XkbOutlinePtr outline,int first,int count,Bool freeAll)
d200 4
a203 4
    _XkbFreeGeomLeafElems(freeAll,first,count,
				&outline->num_points,&outline->sz_points,
				(char **)&outline->points,
				sizeof(XkbPointRec));
d212 1
a212 1
XkbOutlinePtr	outline= (XkbOutlinePtr)outline_in;
d214 2
a215 2
    if (outline->points!=NULL)
	XkbFreeGeomPoints(outline,0,outline->num_points,True);
d220 1
a220 1
XkbFreeGeomOutlines(XkbShapePtr	shape,int first,int count,Bool freeAll)
d222 4
a225 4
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&shape->num_outlines,&shape->sz_outlines,
				(char **)&shape->outlines,
				sizeof(XkbOutlineRec),_XkbClearOutline);
d235 1
a235 1
XkbShapePtr	shape= (XkbShapePtr)shape_in;
d238 1
a238 1
	XkbFreeGeomOutlines(shape,0,shape->num_outlines,True);
d243 1
a243 1
XkbFreeGeomShapes(XkbGeometryPtr geom,int first,int count,Bool freeAll)
d245 4
a248 4
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&geom->num_shapes,&geom->sz_shapes,
				(char **)&geom->shapes,
				sizeof(XkbShapeRec),_XkbClearShape);
d255 1
a255 1
XkbFreeGeomOverlayKeys(XkbOverlayRowPtr row,int first,int count,Bool freeAll)
d257 4
a260 4
    _XkbFreeGeomLeafElems(freeAll,first,count,
				&row->num_keys,&row->sz_keys,
				(char **)&row->keys,
				sizeof(XkbOverlayKeyRec));
d269 1
a269 1
XkbOverlayRowPtr	row= (XkbOverlayRowPtr)row_in;
d271 2
a272 2
    if (row->keys!=NULL)
	XkbFreeGeomOverlayKeys(row,0,row->num_keys,True);
d277 2
a278 1
XkbFreeGeomOverlayRows(XkbOverlayPtr overlay,int first,int count,Bool freeAll)
d280 4
a283 4
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&overlay->num_rows,&overlay->sz_rows,
				(char **)&overlay->rows,
				sizeof(XkbOverlayRowRec),_XkbClearOverlayRow);
d292 1
a292 1
XkbOverlayPtr	overlay= (XkbOverlayPtr)overlay_in;
d294 2
a295 2
    if (overlay->rows!=NULL)
	XkbFreeGeomOverlayRows(overlay,0,overlay->num_rows,True);
d300 1
a300 1
XkbFreeGeomOverlays(XkbSectionPtr section,int first,int	count,Bool freeAll)
d302 4
a305 4
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&section->num_overlays,&section->sz_overlays,
				(char **)&section->overlays,
				sizeof(XkbOverlayRec),_XkbClearOverlay);
d312 1
a312 1
XkbFreeGeomKeys(XkbRowPtr row,int first,int count,Bool freeAll)
d314 4
a317 4
    _XkbFreeGeomLeafElems(freeAll,first,count,
				&row->num_keys,&row->sz_keys,
				(char **)&row->keys,
				sizeof(XkbKeyRec));
d326 1
a326 1
XkbRowPtr	row= (XkbRowPtr)row_in;
d328 2
a329 2
    if (row->keys!=NULL)
	XkbFreeGeomKeys(row,0,row->num_keys,True);
d334 1
a334 1
XkbFreeGeomRows(XkbSectionPtr section,int first,int count,Bool freeAll)
d336 4
a339 4
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&section->num_rows,&section->sz_rows,
				(char **)&section->rows,
				sizeof(XkbRowRec),_XkbClearRow);
d347 1
a347 1
XkbSectionPtr	section= (XkbSectionPtr)section_in;
d349 5
a353 5
    if (section->rows!=NULL)
	XkbFreeGeomRows(section,0,section->num_rows,True);
    if (section->doodads!=NULL) {
	XkbFreeGeomDoodads(section->doodads,section->num_doodads,True);
	section->doodads= NULL;
d359 1
a359 1
XkbFreeGeomSections(XkbGeometryPtr geom,int first,int count,Bool freeAll)
d361 4
a364 4
    _XkbFreeGeomNonLeafElems(freeAll,first,count,
				&geom->num_sections,&geom->sz_sections,
				(char **)&geom->sections,
				sizeof(XkbSectionRec),_XkbClearSection);
d373 1
a373 1
XkbDoodadPtr	doodad= (XkbDoodadPtr)doodad_in;
d376 20
a395 20
   	case XkbTextDoodad:
	    {
		if (doodad->text.text!=NULL) {
		    _XkbFree(doodad->text.text);
		    doodad->text.text= NULL;
		}
		if (doodad->text.font!=NULL) {
		    _XkbFree(doodad->text.font);
		    doodad->text.font= NULL;
		}
	    }
	    break;
   	case XkbLogoDoodad:
	    {
		if (doodad->logo.logo_name!=NULL) {
		    _XkbFree(doodad->logo.logo_name);
		    doodad->logo.logo_name= NULL;
		}
	    }
	    break;
d401 1
a401 1
XkbFreeGeomDoodads(XkbDoodadPtr doodads,int nDoodads,Bool freeAll)
d403 2
a404 2
register int 		i;
register XkbDoodadPtr	doodad;
d407 5
a411 5
	for (i=0,doodad= doodads;i<nDoodads;i++,doodad++) {
	    _XkbClearDoodad((char *)doodad);
	}
	if (freeAll)
	    _XkbFree(doodads);
d417 1
a417 1
XkbFreeGeometry(XkbGeometryPtr geom,unsigned which,Bool freeMap)
d419 2
a420 2
    if (geom==NULL)
	return;
d422 13
a434 13
	which= XkbGeomAllMask;
    if ((which&XkbGeomPropertiesMask)&&(geom->properties!=NULL))
	XkbFreeGeomProperties(geom,0,geom->num_properties,True);
    if ((which&XkbGeomColorsMask)&&(geom->colors!=NULL))
	XkbFreeGeomColors(geom,0,geom->num_colors,True);
    if ((which&XkbGeomShapesMask)&&(geom->shapes!=NULL))
	XkbFreeGeomShapes(geom,0,geom->num_shapes,True);
    if ((which&XkbGeomSectionsMask)&&(geom->sections!=NULL))
	XkbFreeGeomSections(geom,0,geom->num_sections,True);
    if ((which&XkbGeomDoodadsMask)&&(geom->doodads!= NULL)) {
	XkbFreeGeomDoodads(geom->doodads,geom->num_doodads,True);
	geom->doodads= NULL;
	geom->num_doodads= geom->sz_doodads= 0;
d436 2
a437 2
    if ((which&XkbGeomKeyAliasesMask)&&(geom->key_aliases!=NULL))
	XkbFreeGeomKeyAliases(geom,0,geom->num_key_aliases,True);
d439 5
a443 5
	if (geom->label_font!=NULL) {
	    _XkbFree(geom->label_font);
	    geom->label_font= NULL;
	}
	_XkbFree(geom);
d451 27
a477 26
_XkbGeomAlloc(	XPointer *		old,
		unsigned short *	num,
		unsigned short *	total,
		int			num_new,
		size_t			sz_elem)
{
    if (num_new<1)
	return Success;
    if ((*old)==NULL)
	*num= *total= 0;

    if ((*num)+num_new<=(*total))
	return Success;

    *total= (*num)+num_new;
    if ((*old)!=NULL)
	 (*old)= (XPointer)_XkbRealloc((*old),(*total)*sz_elem);
    else (*old)= (XPointer)_XkbCalloc((*total),sz_elem);
    if ((*old)==NULL) {
	*total= *num= 0;
	return BadAlloc;
    }

    if (*num>0) {
	char *tmp= (char *)(*old);
	bzero(&tmp[sz_elem*(*num)],(num_new*sz_elem));
d482 18
a499 18
#define	_XkbAllocProps(g,n) _XkbGeomAlloc((XPointer *)&(g)->properties,\
				&(g)->num_properties,&(g)->sz_properties,\
				(n),sizeof(XkbPropertyRec))
#define	_XkbAllocColors(g,n) _XkbGeomAlloc((XPointer *)&(g)->colors,\
				&(g)->num_colors,&(g)->sz_colors,\
				(n),sizeof(XkbColorRec))
#define	_XkbAllocShapes(g,n) _XkbGeomAlloc((XPointer *)&(g)->shapes,\
				&(g)->num_shapes,&(g)->sz_shapes,\
				(n),sizeof(XkbShapeRec))
#define	_XkbAllocSections(g,n) _XkbGeomAlloc((XPointer *)&(g)->sections,\
				&(g)->num_sections,&(g)->sz_sections,\
				(n),sizeof(XkbSectionRec))
#define	_XkbAllocDoodads(g,n) _XkbGeomAlloc((XPointer *)&(g)->doodads,\
				&(g)->num_doodads,&(g)->sz_doodads,\
				(n),sizeof(XkbDoodadRec))
#define	_XkbAllocKeyAliases(g,n) _XkbGeomAlloc((XPointer *)&(g)->key_aliases,\
				&(g)->num_key_aliases,&(g)->sz_key_aliases,\
				(n),sizeof(XkbKeyAliasRec))
d501 21
a521 21
#define	_XkbAllocOutlines(s,n) _XkbGeomAlloc((XPointer *)&(s)->outlines,\
				&(s)->num_outlines,&(s)->sz_outlines,\
				(n),sizeof(XkbOutlineRec))
#define	_XkbAllocRows(s,n) _XkbGeomAlloc((XPointer *)&(s)->rows,\
				&(s)->num_rows,&(s)->sz_rows,\
				(n),sizeof(XkbRowRec))
#define	_XkbAllocPoints(o,n) _XkbGeomAlloc((XPointer *)&(o)->points,\
				&(o)->num_points,&(o)->sz_points,\
				(n),sizeof(XkbPointRec))
#define	_XkbAllocKeys(r,n) _XkbGeomAlloc((XPointer *)&(r)->keys,\
				&(r)->num_keys,&(r)->sz_keys,\
				(n),sizeof(XkbKeyRec))
#define	_XkbAllocOverlays(s,n) _XkbGeomAlloc((XPointer *)&(s)->overlays,\
				&(s)->num_overlays,&(s)->sz_overlays,\
				(n),sizeof(XkbOverlayRec))
#define	_XkbAllocOverlayRows(o,n) _XkbGeomAlloc((XPointer *)&(o)->rows,\
				&(o)->num_rows,&(o)->sz_rows,\
				(n),sizeof(XkbOverlayRowRec))
#define	_XkbAllocOverlayKeys(r,n) _XkbGeomAlloc((XPointer *)&(r)->keys,\
				&(r)->num_keys,&(r)->sz_keys,\
				(n),sizeof(XkbOverlayKeyRec))
d524 1
a524 1
XkbAllocGeomProps(XkbGeometryPtr geom,int nProps)
d526 1
a526 1
    return _XkbAllocProps(geom,nProps);
d530 1
a530 1
XkbAllocGeomColors(XkbGeometryPtr geom,int nColors)
d532 1
a532 1
    return _XkbAllocColors(geom,nColors);
d536 1
a536 1
XkbAllocGeomKeyAliases(XkbGeometryPtr geom,int nKeyAliases)
d538 1
a538 1
    return _XkbAllocKeyAliases(geom,nKeyAliases);
d542 1
a542 1
XkbAllocGeomShapes(XkbGeometryPtr geom,int nShapes)
d544 1
a544 1
    return _XkbAllocShapes(geom,nShapes);
d548 1
a548 1
XkbAllocGeomSections(XkbGeometryPtr geom,int nSections)
d550 1
a550 1
    return _XkbAllocSections(geom,nSections);
d554 1
a554 1
XkbAllocGeomOverlays(XkbSectionPtr section,int nOverlays)
d556 1
a556 1
    return _XkbAllocOverlays(section,nOverlays);
d560 1
a560 1
XkbAllocGeomOverlayRows(XkbOverlayPtr overlay,int nRows)
d562 1
a562 1
    return _XkbAllocOverlayRows(overlay,nRows);
d566 1
a566 1
XkbAllocGeomOverlayKeys(XkbOverlayRowPtr row,int nKeys)
d568 1
a568 1
    return _XkbAllocOverlayKeys(row,nKeys);
d572 1
a572 1
XkbAllocGeomDoodads(XkbGeometryPtr geom,int nDoodads)
d574 1
a574 1
    return _XkbAllocDoodads(geom,nDoodads);
d578 1
a578 1
XkbAllocGeomSectionDoodads(XkbSectionPtr section,int nDoodads)
d580 1
a580 1
    return _XkbAllocDoodads(section,nDoodads);
d584 1
a584 1
XkbAllocGeomOutlines(XkbShapePtr shape,int nOL)
d586 1
a586 1
    return _XkbAllocOutlines(shape,nOL);
d590 1
a590 1
XkbAllocGeomRows(XkbSectionPtr section,int nRows)
d592 1
a592 1
    return _XkbAllocRows(section,nRows);
d596 1
a596 1
XkbAllocGeomPoints(XkbOutlinePtr ol,int nPts)
d598 1
a598 1
    return _XkbAllocPoints(ol,nPts);
d602 1
a602 1
XkbAllocGeomKeys(XkbRowPtr row,int nKeys)
d604 1
a604 1
    return _XkbAllocKeys(row,nKeys);
d608 1
a608 1
XkbAllocGeometry(XkbDescPtr xkb,XkbGeometrySizesPtr sizes)
d610 2
a611 2
XkbGeometryPtr	geom;
Status		rtrn;
d613 4
a616 4
    if (xkb->geom==NULL) {
	xkb->geom= _XkbTypedCalloc(1,XkbGeometryRec);
	if (!xkb->geom)
	    return BadAlloc;
d618 4
a621 4
    geom= xkb->geom;
    if ((sizes->which&XkbGeomPropertiesMask)&&
	((rtrn=_XkbAllocProps(geom,sizes->num_properties))!=Success)) {
	goto BAIL;
d623 3
a625 3
    if ((sizes->which&XkbGeomColorsMask)&&
	((rtrn=_XkbAllocColors(geom,sizes->num_colors))!=Success)) {
	goto BAIL;
d627 3
a629 3
    if ((sizes->which&XkbGeomShapesMask)&&
	((rtrn=_XkbAllocShapes(geom,sizes->num_shapes))!=Success)) {
	goto BAIL;
d631 3
a633 3
    if ((sizes->which&XkbGeomSectionsMask)&&
	((rtrn=_XkbAllocSections(geom,sizes->num_sections))!=Success)) {
	goto BAIL;
d635 3
a637 3
    if ((sizes->which&XkbGeomDoodadsMask)&&
	((rtrn=_XkbAllocDoodads(geom,sizes->num_doodads))!=Success)) {
	goto BAIL;
d639 4
a642 3
    if ((sizes->which&XkbGeomKeyAliasesMask)&&
	((rtrn=_XkbAllocKeyAliases(geom,sizes->num_key_aliases))!=Success)) {
	goto BAIL;
d645 3
a647 3
BAIL:
    XkbFreeGeometry(geom,XkbGeomAllMask,True);
    xkb->geom= NULL;
d654 1
a654 1
XkbAddGeomProperty(XkbGeometryPtr geom,char *name,char *value)
d656 2
a657 2
register int i;
register XkbPropertyPtr prop;
d659 13
a671 13
    if ((!geom)||(!name)||(!value))
	return NULL;
    for (i=0,prop=geom->properties;i<geom->num_properties;i++,prop++) {
	if ((prop->name)&&(strcmp(name,prop->name)==0)) {
	    if (prop->value)
		_XkbFree(prop->value);
	    prop->value= strdup(value);
	    return prop;
	}
    }
    if ((geom->num_properties>=geom->sz_properties)&&
					(_XkbAllocProps(geom,1)!=Success)) {
	return NULL;
d673 2
a674 2
    prop= &geom->properties[geom->num_properties];
    prop->name= strdup(name);
d676 2
a677 2
	return NULL;
    prop->value= strdup(value);
d679 3
a681 3
	_XkbFree(prop->name);
	prop->name= NULL;
	return NULL;
d688 1
a688 1
XkbAddGeomKeyAlias(XkbGeometryPtr geom,char *aliasStr,char *realStr)
d690 2
a691 2
register int i;
register XkbKeyAliasPtr alias;
d693 18
a710 17
    if ((!geom)||(!aliasStr)||(!realStr)||(!aliasStr[0])||(!realStr[0]))
	return NULL;
    for (i=0,alias=geom->key_aliases;i<geom->num_key_aliases;i++,alias++) {
	if (strncmp(alias->alias,aliasStr,XkbKeyNameLength)==0) {
	    bzero(alias->real,XkbKeyNameLength);
	    strncpy(alias->real,realStr,XkbKeyNameLength);
	    return alias;
	}
    }
    if ((geom->num_key_aliases>=geom->sz_key_aliases)&&
				(_XkbAllocKeyAliases(geom,1)!=Success)) {
	return NULL;
    }
    alias= &geom->key_aliases[geom->num_key_aliases];
    bzero(alias,sizeof(XkbKeyAliasRec));
    strncpy(alias->alias,aliasStr,XkbKeyNameLength);
    strncpy(alias->real,realStr,XkbKeyNameLength);
d716 1
a716 1
XkbAddGeomColor(XkbGeometryPtr geom,char *spec,unsigned int pixel)
d718 2
a719 2
register int i;
register XkbColorPtr color;
d721 15
a735 15
    if ((!geom)||(!spec))
	return NULL;
    for (i=0,color=geom->colors;i<geom->num_colors;i++,color++) {
	if ((color->spec)&&(strcmp(color->spec,spec)==0)) {
	    color->pixel= pixel;
	    return color;
	}
    }
    if ((geom->num_colors>=geom->sz_colors)&&
					(_XkbAllocColors(geom,1)!=Success)) {
	return NULL;
    }
    color= &geom->colors[geom->num_colors];
    color->pixel= pixel;
    color->spec= strdup(spec);
d737 1
a737 1
	return NULL;
d743 1
a743 1
XkbAddGeomOutline(XkbShapePtr shape,int sz_points)
d745 1
a745 1
XkbOutlinePtr	outline;
d747 10
a756 10
    if ((!shape)||(sz_points<0))
	return NULL;
    if ((shape->num_outlines>=shape->sz_outlines)&&
					(_XkbAllocOutlines(shape,1)!=Success)) {
	return NULL;
    }
    outline= &shape->outlines[shape->num_outlines];
    bzero(outline,sizeof(XkbOutlineRec));
    if ((sz_points>0)&&(_XkbAllocPoints(outline,sz_points)!=Success))
	return NULL;
d762 1
a762 1
XkbAddGeomShape(XkbGeometryPtr geom,Atom name,int sz_outlines)
d764 2
a765 2
XkbShapePtr	shape;
register int	i;
d767 17
a783 17
    if ((!geom)||(!name)||(sz_outlines<0))
	return NULL;
    if (geom->num_shapes>0) {
	for (shape=geom->shapes,i=0;i<geom->num_shapes;i++,shape++) {
	    if (name==shape->name)
		return shape;
	}
    }
    if ((geom->num_shapes>=geom->sz_shapes)&&
					(_XkbAllocShapes(geom,1)!=Success))
	return NULL;
    shape= &geom->shapes[geom->num_shapes];
    bzero(shape,sizeof(XkbShapeRec));
    if ((sz_outlines>0)&&(_XkbAllocOutlines(shape,sz_outlines)!=Success))
	return NULL;
    shape->name= name;
    shape->primary= shape->approx= NULL;
d791 2
a792 1
XkbKeyPtr	key;
d794 5
a798 5
	return NULL;
    if ((row->num_keys>=row->sz_keys)&&(_XkbAllocKeys(row,1)!=Success))
	return NULL;
    key= &row->keys[row->num_keys++];
    bzero(key,sizeof(XkbKeyRec));
d803 1
a803 1
XkbAddGeomRow(XkbSectionPtr section,int sz_keys)
d805 1
a805 1
XkbRowPtr	row;
d807 9
a815 9
    if ((!section)||(sz_keys<0))
	return NULL;
    if ((section->num_rows>=section->sz_rows)&&
    					(_XkbAllocRows(section,1)!=Success))
	return NULL;
    row= &section->rows[section->num_rows];
    bzero(row,sizeof(XkbRowRec));
    if ((sz_keys>0)&&(_XkbAllocKeys(row,sz_keys)!=Success))
	return NULL;
d821 35
a855 33
XkbAddGeomSection(	XkbGeometryPtr	geom,
			Atom		name,
			int		sz_rows,
			int		sz_doodads,
			int		sz_over)
{
register int	i;
XkbSectionPtr	section;

    if ((!geom)||(name==None)||(sz_rows<0))
	return NULL;
    for (i=0,section=geom->sections;i<geom->num_sections;i++,section++) {
	if (section->name!=name)
	    continue;
	if (((sz_rows>0)&&(_XkbAllocRows(section,sz_rows)!=Success))||
	    ((sz_doodads>0)&&(_XkbAllocDoodads(section,sz_doodads)!=Success))||
	    ((sz_over>0)&&(_XkbAllocOverlays(section,sz_over)!=Success)))
	    return NULL;
	return section;
    }
    if ((geom->num_sections>=geom->sz_sections)&&
					(_XkbAllocSections(geom,1)!=Success))
	return NULL;
    section= &geom->sections[geom->num_sections];
    if ((sz_rows>0)&&(_XkbAllocRows(section,sz_rows)!=Success))
	return NULL;
    if ((sz_doodads>0)&&(_XkbAllocDoodads(section,sz_doodads)!=Success)) {
	if (section->rows) {
	    _XkbFree(section->rows);
	    section->rows= NULL;
	    section->sz_rows= section->num_rows= 0;
	}
	return NULL;
d857 1
a857 1
    section->name= name;
d863 1
a863 1
XkbAddGeomDoodad(XkbGeometryPtr geom,XkbSectionPtr section,Atom name)
d865 2
a866 2
XkbDoodadPtr	old,doodad;
register int	i,nDoodads;
d868 5
a872 5
    if ((!geom)||(name==None))
	return NULL;
    if ((section!=NULL)&&(section->num_doodads>0)) {
	old= section->doodads;
	nDoodads= section->num_doodads;
d875 2
a876 2
	old= geom->doodads;
	nDoodads= geom->num_doodads;
d878 3
a880 3
    for (i=0,doodad=old;i<nDoodads;i++,doodad++) {
	if (doodad->any.name==name)
	    return doodad;
d883 5
a887 5
	if ((section->num_doodads>=geom->sz_doodads)&&
	    (_XkbAllocDoodads(section,1)!=Success)) {
	    return NULL;
	}
	doodad= &section->doodads[section->num_doodads++];
d890 4
a893 4
	if ((geom->num_doodads>=geom->sz_doodads)&&
					(_XkbAllocDoodads(geom,1)!=Success))
	    return NULL;
	doodad= &geom->doodads[geom->num_doodads++];
d895 2
a896 2
    bzero(doodad,sizeof(XkbDoodadRec));
    doodad->any.name= name;
d901 22
a922 22
XkbAddGeomOverlayKey(	XkbOverlayPtr		overlay,
			XkbOverlayRowPtr 	row,
			char *			over,
			char *			under)
{
register int	i;
XkbOverlayKeyPtr key;
XkbSectionPtr	section;
XkbRowPtr	row_under;
Bool		found;

    if ((!overlay)||(!row)||(!over)||(!under))
	return NULL;
    section= overlay->section_under;
    if (row->row_under>=section->num_rows)
	return NULL;
    row_under= &section->rows[row->row_under];
    for (i=0,found=False;i<row_under->num_keys;i++) {
	if (strncmp(under,row_under->keys[i].name.name,XkbKeyNameLength)==0) {
	    found= True;
	    break;
	}
d925 7
a931 6
   	return NULL;
    if ((row->num_keys>=row->sz_keys)&&(_XkbAllocOverlayKeys(row,1)!=Success))
	return NULL;
    key= &row->keys[row->num_keys];
    strncpy(key->under.name,under,XkbKeyNameLength);
    strncpy(key->over.name,over,XkbKeyNameLength);
d937 1
a937 1
XkbAddGeomOverlayRow(XkbOverlayPtr overlay,int row_under,int sz_keys)
d939 2
a940 2
register int		i;
XkbOverlayRowPtr	row;
d942 22
a963 22
    if ((!overlay)||(sz_keys<0))
	return NULL;
    if (row_under>=overlay->section_under->num_rows)
	return NULL;
    for (i=0;i<overlay->num_rows;i++) {
	if (overlay->rows[i].row_under==row_under) {
	    row= &overlay->rows[i];
	    if ((row->sz_keys<sz_keys)&&
				(_XkbAllocOverlayKeys(row,sz_keys)!=Success)) {
		return NULL;
	    }
	    return &overlay->rows[i];
	}
    }
    if ((overlay->num_rows>=overlay->sz_rows)&&
				(_XkbAllocOverlayRows(overlay,1)!=Success))
	return NULL;
    row= &overlay->rows[overlay->num_rows];
    bzero(row,sizeof(XkbOverlayRowRec));
    if ((sz_keys>0)&&(_XkbAllocOverlayKeys(row,sz_keys)!=Success))
	return NULL;
    row->row_under= row_under;
d969 1
a969 1
XkbAddGeomOverlay(XkbSectionPtr section,Atom name,int sz_rows)
d971 2
a972 2
register int	i;
XkbOverlayPtr	overlay;
d974 2
a975 2
    if ((!section)||(name==None)||(sz_rows==0))
	return NULL;
d977 17
a993 15
    for (i=0,overlay=section->overlays;i<section->num_overlays;i++,overlay++) {
	if (overlay->name==name) {
	    if ((sz_rows>0)&&(_XkbAllocOverlayRows(overlay,sz_rows)!=Success))
		return NULL;
	    return overlay;
	}
    }
    if ((section->num_overlays>=section->sz_overlays)&&
				(_XkbAllocOverlays(section,1)!=Success))
	return NULL;
    overlay= &section->overlays[section->num_overlays];
    if ((sz_rows>0)&&(_XkbAllocOverlayRows(overlay,sz_rows)!=Success))
	return NULL;
    overlay->name= name;
    overlay->section_under= section;
@


1.5
log
@Update to libX11 1.4.4. Tested by ajacoutot@@, shadchin@@.
@
text
@a32 1
#ifndef XKB_IN_SERVER
a39 18
#else

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <X11/extensions/XKBsrv.h>
#include <X11/extensions/XKBgeom.h>

#endif /* XKB_IN_SERVER */

#ifdef X_NOT_POSIX
#define Size_t unsigned int
#else
#define Size_t size_t
#endif

d460 1
a460 1
		Size_t			sz_elem)
@


1.4
log
@Update to libx11 1.4.2. Tested by ajacoutot@@, jasper@@ krw@@, landry@@,
shadchin@@ on various architectures.
Bump major.
@
text
@d687 1
a687 3
	    prop->value= (char *)_XkbAlloc(strlen(value)+1);
	    if (prop->value)
		strcpy(prop->value,value);
d696 1
a696 1
    prop->name= (char *)_XkbAlloc(strlen(name)+1);
d699 1
a699 2
    strcpy(prop->name,name);
    prop->value= (char *)_XkbAlloc(strlen(value)+1);
a704 1
    strcpy(prop->value,value);
d756 1
a756 1
    color->spec= (char *)_XkbAlloc(strlen(spec)+1);
a758 1
    strcpy(color->spec,spec);
@


1.3
log
@Update to libX11 1.3.3. Tested on a bulk ports build by naddy@@.
@
text
@a32 3
#define	NEED_EVENTS
#define	NEED_REPLIES

d699 1
a699 1
    if (!name)
d703 1
a703 1
    if (!value) {
@


1.2
log
@update to libX11 1.2.1
@
text
@a0 1
/* $Xorg: XKBGAlloc.c,v 1.3 2000/08/17 19:45:01 cpqbld Exp $ */
a25 1
/* $XFree86: xc/lib/X11/XKBGAlloc.c,v 3.4 2001/01/17 19:41:48 dawes Exp $ */
@


1.1
log
@Initial revision
@
text
@d10 2
a11 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d13 1
a13 1
Silicon Graphics makes no representation about the suitability 
d17 2
a18 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d20 3
a22 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d46 1
a46 1
#else 
d66 1
a66 1
static void 
d80 1
a80 1
	}	
d87 1
a87 1
    if (first+count>=(*num_inout)) { 
d107 1
a107 1
static void 
d195 1
a195 1
{	
d256 1
a256 1
	
d284 1
a284 1
void 
d405 1
a405 1
   	case XkbTextDoodad: 
d417 1
a417 1
   	case XkbLogoDoodad: 
d550 1
a550 1
    
d696 1
a696 1
	}    
d953 1
a953 1
   	return NULL; 
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
