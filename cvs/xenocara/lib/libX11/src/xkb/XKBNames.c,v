head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.6
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.2
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.4.0.8
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_1_3:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	v1_0_99_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.11.03.10.21.31;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	EvOPnI31yB1tDGgg;

1.8
date	2015.04.06.20.57.59;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	L5f7tv2EiGjtzoSu;

1.7
date	2013.09.28.17.03.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.05.23.22.42.07;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2013.04.28.16.55.57;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.30.19.19.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.18.19.37.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.12.59.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.16.37.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.16.37.33;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to libX11 1.6.4
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#define NEED_MAP_READERS
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "Xlibint.h"
#include <X11/extensions/XKBproto.h>
#include "XKBlibint.h"


static Status
_XkbReadAtoms(XkbReadBufferPtr buf,
              Atom *atoms,
              int maxAtoms,
              CARD32 present)
{
    register int i, bit;

    for (i = 0, bit = 1; (i < maxAtoms) && (present); i++, bit <<= 1) {
        if (present & bit) {
            if (!_XkbReadBufferCopy32(buf, (long *) &atoms[i], 1))
                return BadLength;
            present &= ~bit;
        }
    }
    return Success;
}

Status
_XkbReadGetNamesReply(Display *dpy,
                      xkbGetNamesReply *rep,
                      XkbDescPtr xkb,
                      int *nread_rtrn)
{
    int i, len;
    XkbReadBufferRec buf;
    register XkbNamesPtr names;

    if (xkb->device_spec == XkbUseCoreKbd)
        xkb->device_spec = rep->deviceID;

    if ((xkb->names == NULL) &&
        (XkbAllocNames(xkb, rep->which,
                       rep->nRadioGroups, rep->nKeyAliases) != Success)) {
        return BadAlloc;
    }
    names = xkb->names;
    if (rep->length == 0)
        return Success;

    if (!_XkbInitReadBuffer(dpy, &buf, (int) rep->length * 4))
        return BadAlloc;
    if (nread_rtrn)
        *nread_rtrn = (int) rep->length * 4;

    if ((rep->which & XkbKeycodesNameMask) &&
        (!_XkbReadBufferCopy32(&buf, (long *) &names->keycodes, 1)))
        goto BAILOUT;
    if ((rep->which & XkbGeometryNameMask) &&
        (!_XkbReadBufferCopy32(&buf, (long *) &names->geometry, 1)))
        goto BAILOUT;
    if ((rep->which & XkbSymbolsNameMask) &&
        (!_XkbReadBufferCopy32(&buf, (long *) &names->symbols, 1)))
        goto BAILOUT;
    if ((rep->which & XkbPhysSymbolsNameMask) &&
        (!_XkbReadBufferCopy32(&buf, (long *) &names->phys_symbols, 1)))
        goto BAILOUT;
    if ((rep->which & XkbTypesNameMask) &&
        (!_XkbReadBufferCopy32(&buf, (long *) &names->types, 1)))
        goto BAILOUT;
    if ((rep->which & XkbCompatNameMask) &&
        (!_XkbReadBufferCopy32(&buf, (long *) &names->compat, 1)))
        goto BAILOUT;

    if (rep->which & XkbKeyTypeNamesMask) {
        XkbClientMapPtr map = xkb->map;
        XkbKeyTypePtr type;

        len = rep->nTypes * 4;
        if (map != NULL) {
            type = map->types;
            for (i = 0; (i < map->num_types) && (i < rep->nTypes); i++, type++) {
                if (!_XkbReadBufferCopy32(&buf, (long *) &type->name, 1))
                    goto BAILOUT;
                len -= 4;
            }
        }
        if ((len > 0) && (!_XkbSkipReadBufferData(&buf, len)))
            goto BAILOUT;
    }
    if (rep->which & XkbKTLevelNamesMask) {
        CARD8 *nLevels;
        XkbClientMapPtr map = xkb->map;

        nLevels =
            (CARD8 *) _XkbGetReadBufferPtr(&buf, XkbPaddedSize(rep->nTypes));
        if (nLevels == NULL)
            goto BAILOUT;
        if (map != NULL) {
            XkbKeyTypePtr type = map->types;

            for (i = 0; i < (int) rep->nTypes; i++, type++) {
                if (i >= map->num_types) {
                    if (!_XkbSkipReadBufferData(&buf, nLevels[i] * 4))
                        goto BAILOUT;
                    continue;
                }
                if ((nLevels[i] > 0) && (nLevels[i] != type->num_levels)) {
                    goto BAILOUT;
                }

                Xfree(type->level_names);
                if (nLevels[i] == 0) {
                    type->level_names = NULL;
                    continue;
                }
                type->level_names = _XkbTypedCalloc(nLevels[i], Atom);
                if (type->level_names != NULL) {
                    if (!_XkbReadBufferCopy32(&buf, (long *) type->level_names,
                                              nLevels[i]))
                        goto BAILOUT;
                }
                else {
                    _XkbSkipReadBufferData(&buf, nLevels[i] * 4);
                }
            }
        }
        else {
            for (i = 0; i < (int) rep->nTypes; i++) {
                _XkbSkipReadBufferData(&buf, nLevels[i] * 4);
            }
        }
    }
    if (rep->which & XkbIndicatorNamesMask) {
        if (_XkbReadAtoms(&buf, names->indicators, XkbNumIndicators,
                          rep->indicators) != Success)
            goto BAILOUT;
    }
    if (rep->which & XkbVirtualModNamesMask) {
        if (_XkbReadAtoms(&buf, names->vmods, XkbNumVirtualMods,
                          (CARD32) rep->virtualMods) != Success)
            goto BAILOUT;
    }
    if (rep->which & XkbGroupNamesMask) {
        if (_XkbReadAtoms(&buf, names->groups, XkbNumKbdGroups,
                          (CARD32) rep->groupNames) != Success)
            goto BAILOUT;
    }
    if (rep->which & XkbKeyNamesMask) {
        if (names->keys == NULL) {
            int nKeys;

            if (xkb->max_key_code == 0) {
                xkb->min_key_code = rep->minKeyCode;
                xkb->max_key_code = rep->maxKeyCode;
            }
            nKeys = xkb->max_key_code + 1;
            names->keys = _XkbTypedCalloc(nKeys, XkbKeyNameRec);
        }
        if (((int) rep->firstKey + rep->nKeys) > xkb->max_key_code + 1)
            goto BAILOUT;
        if (names->keys != NULL) {
            if (!_XkbCopyFromReadBuffer(&buf,
                                        (char *) &names->keys[rep->firstKey],
                                        rep->nKeys * XkbKeyNameLength))
                goto BAILOUT;
        }
        else
            _XkbSkipReadBufferData(&buf, rep->nKeys * XkbKeyNameLength);
    }
    if (rep->which & XkbKeyAliasesMask && (rep->nKeyAliases > 0)) {
        if (XkbAllocNames(xkb, XkbKeyAliasesMask, 0, rep->nKeyAliases) !=
            Success)
            goto BAILOUT;
        if (!_XkbCopyFromReadBuffer(&buf, (char *) names->key_aliases,
                                    rep->nKeyAliases * XkbKeyNameLength * 2))
            goto BAILOUT;
    }
    if (rep->which & XkbRGNamesMask) {
        if (rep->nRadioGroups > 0) {
            Atom *rgNames;

            if (names->radio_groups == NULL)
                names->radio_groups = _XkbTypedCalloc(rep->nRadioGroups, Atom);
            else if (names->num_rg < rep->nRadioGroups) {
                names->radio_groups = _XkbTypedRealloc(names->radio_groups,
                                                       rep->nRadioGroups, Atom);
            }
            rgNames = names->radio_groups;
            if (!rgNames) {
                goto BAILOUT;
            }
            if (!_XkbReadBufferCopy32
                (&buf, (long *) rgNames, rep->nRadioGroups))
                goto BAILOUT;
            names->num_rg = rep->nRadioGroups;
        }
        else if (names->num_rg > 0) {
            names->num_rg = 0;
            Xfree(names->radio_groups);
        }
    }
    len = _XkbFreeReadBuffer(&buf);
    if (len != 0)
        return BadLength;
    else
        return Success;
 BAILOUT:
    _XkbFreeReadBuffer(&buf);
    return BadLength;
}

Status
XkbGetNames(Display *dpy, unsigned which, XkbDescPtr xkb)
{
    register xkbGetNamesReq *req;
    xkbGetNamesReply rep;
    Status status;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    if (!xkb->names) {
        xkb->names = _XkbTypedCalloc(1, XkbNamesRec);
        if (!xkb->names) {
            UnlockDisplay(dpy);
            SyncHandle();
            return BadAlloc;
        }
    }
    GetReq(kbGetNames, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbGetNames;
    req->deviceSpec = xkb->device_spec;
    req->which = which;
    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay(dpy);
        SyncHandle();
        return BadImplementation;
    }

    status = _XkbReadGetNamesReply(dpy, &rep, xkb, NULL);
    UnlockDisplay(dpy);
    SyncHandle();
    return status;
}

/***====================================================================***/

static int
_XkbCountBits(int nBitsMax, unsigned long mask)
{
    register unsigned long y, nBits;

    y = (mask >> 1) & 033333333333;
    y = mask - y - ((y >> 1) & 033333333333);
    nBits = ((unsigned int) (((y + (y >> 3)) & 030707070707) % 077));

    /* nBitsMax really means max+1 */
    return (nBits < nBitsMax) ? nBits : (nBitsMax - 1);
}

static CARD32
_XkbCountAtoms(Atom *atoms, int maxAtoms, int *count)
{
    register unsigned int i, bit, nAtoms;
    register CARD32 atomsPresent;

    for (i = nAtoms = atomsPresent = 0, bit = 1; i < maxAtoms; i++, bit <<= 1) {
        if (atoms[i] != None) {
            atomsPresent |= bit;
            nAtoms++;
        }
    }
    if (count)
        *count = nAtoms;
    return atomsPresent;
}

static void
_XkbCopyAtoms(Display *dpy, Atom *atoms, CARD32 mask, int maxAtoms)
{
    register unsigned int i, bit;

    for (i = 0, bit = 1; i < maxAtoms; i++, bit <<= 1) {
        if (mask & bit)
            Data32(dpy, &atoms[i], 4);
    }
    return;
}

Bool
XkbSetNames(Display *dpy,
            unsigned int which,
            unsigned int firstType,
            unsigned int nTypes,
            XkbDescPtr xkb)
{
    register xkbSetNamesReq *req;
    int nLvlNames = 0;
    XkbInfoPtr xkbi;
    XkbNamesPtr names;
    unsigned firstLvlType, nLvlTypes;
    int nVMods, nLEDs, nRG, nKA, nGroups;
    int nKeys = 0, firstKey = 0, nAtoms;
    CARD32 leds, vmods, groups;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    if ((!xkb) || (!xkb->names))
        return False;
    firstLvlType = firstType;
    nLvlTypes = nTypes;
    if (nTypes < 1)
        which &= ~(XkbKTLevelNamesMask | XkbKeyTypeNamesMask);
    else if (firstType <= XkbLastRequiredType) {
        int adjust;

        adjust = XkbLastRequiredType - firstType + 1;
        firstType += adjust;
        nTypes -= adjust;
        if (nTypes < 1)
            which &= ~XkbKeyTypeNamesMask;
    }
    names = xkb->names;
    if (which & (XkbKTLevelNamesMask | XkbKeyTypeNamesMask)) {
        register int i;
        XkbKeyTypePtr type;

        if ((xkb->map == NULL) || (xkb->map->types == NULL) || (nTypes == 0) ||
            (firstType + nTypes > xkb->map->num_types) ||
            (firstLvlType + nLvlTypes > xkb->map->num_types))
            return False;
        if (which & XkbKTLevelNamesMask) {
            type = &xkb->map->types[firstLvlType];
            for (i = nLvlNames = 0; i < nLvlTypes; i++, type++) {
                if (type->level_names != NULL)
                    nLvlNames += type->num_levels;
            }
        }
    }

    nVMods = nLEDs = nRG = nKA = nAtoms = nGroups = 0;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbSetNames, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbSetNames;
    req->deviceSpec = xkb->device_spec;
    req->firstType = firstType;
    req->nTypes = nTypes;
    req->firstKey = xkb->min_key_code;
    req->nKeys = xkb->max_key_code - xkb->min_key_code + 1;

    if (which & XkbKeycodesNameMask)
        nAtoms++;
    if (which & XkbGeometryNameMask)
        nAtoms++;
    if (which & XkbSymbolsNameMask)
        nAtoms++;
    if (which & XkbPhysSymbolsNameMask)
        nAtoms++;
    if (which & XkbTypesNameMask)
        nAtoms++;
    if (which & XkbCompatNameMask)
        nAtoms++;
    if (which & XkbKeyTypeNamesMask)
        nAtoms += nTypes;
    if (which & XkbKTLevelNamesMask) {
        req->firstKTLevel = firstLvlType;
        req->nKTLevels = nLvlTypes;
        req->length += XkbPaddedSize(nLvlTypes) / 4;    /* room for group widths */
        nAtoms += nLvlNames;
    }
    else
        req->firstKTLevel = req->nKTLevels = 0;

    if (which & XkbIndicatorNamesMask) {
        req->indicators = leds =
            _XkbCountAtoms(names->indicators, XkbNumIndicators, &nLEDs);
        if (nLEDs > 0)
            nAtoms += nLEDs;
        else
            which &= ~XkbIndicatorNamesMask;
    }
    else
        req->indicators = leds = 0;

    if (which & XkbVirtualModNamesMask) {
        vmods = req->virtualMods = (CARD16)
            _XkbCountAtoms(names->vmods, XkbNumVirtualMods, &nVMods);
        if (nVMods > 0)
            nAtoms += nVMods;
        else
            which &= ~XkbVirtualModNamesMask;
    }
    else
        vmods = req->virtualMods = 0;

    if (which & XkbGroupNamesMask) {
        groups = req->groupNames = (CARD8)
            _XkbCountAtoms(names->groups, XkbNumKbdGroups, &nGroups);
        if (nGroups > 0)
            nAtoms += nGroups;
        else
            which &= ~XkbGroupNamesMask;
    }
    else
        groups = req->groupNames = 0;

    if ((which & XkbKeyNamesMask) && (names->keys != NULL)) {
        firstKey = req->firstKey;
        nKeys = req->nKeys;
        nAtoms += nKeys;        /* technically not atoms, but 4 bytes wide */
    }
    else
        which &= ~XkbKeyNamesMask;

    if (which & XkbKeyAliasesMask) {
        nKA = ((names->key_aliases != NULL) ? names->num_key_aliases : 0);
        if (nKA > 0) {
            req->nKeyAliases = nKA;
            nAtoms += nKA * 2;  /* not atoms, but 8 bytes on the wire */
        }
        else {
            which &= ~XkbKeyAliasesMask;
            req->nKeyAliases = 0;
        }
    }
    else
        req->nKeyAliases = 0;

    if (which & XkbRGNamesMask) {
        nRG = names->num_rg;
        if (nRG > 0)
            nAtoms += nRG;
        else
            which &= ~XkbRGNamesMask;
    }

    req->which = which;
    req->nRadioGroups = nRG;
    req->length += (nAtoms * 4) / 4;

    if (which & XkbKeycodesNameMask)
        Data32(dpy, (long *) &names->keycodes, 4);
    if (which & XkbGeometryNameMask)
        Data32(dpy, (long *) &names->geometry, 4);
    if (which & XkbSymbolsNameMask)
        Data32(dpy, (long *) &names->symbols, 4);
    if (which & XkbPhysSymbolsNameMask)
        Data32(dpy, (long *) &names->phys_symbols, 4);
    if (which & XkbTypesNameMask)
        Data32(dpy, (long *) &names->types, 4);
    if (which & XkbCompatNameMask)
        Data32(dpy, (long *) &names->compat, 4);
    if (which & XkbKeyTypeNamesMask) {
        register int i;
        register XkbKeyTypePtr type;

        type = &xkb->map->types[firstType];
        for (i = 0; i < nTypes; i++, type++) {
            Data32(dpy, (long *) &type->name, 4);
        }
    }
    if (which & XkbKTLevelNamesMask) {
        XkbKeyTypePtr type;
        int i;
        char *tmp;

        BufAlloc(char *, tmp, XkbPaddedSize(nLvlTypes));
        type = &xkb->map->types[firstLvlType];
        for (i = 0; i < nLvlTypes; i++, type++) {
            *tmp++ = type->num_levels;
        }
        type = &xkb->map->types[firstLvlType];
        for (i = 0; i < nLvlTypes; i++, type++) {
            if (type->level_names != NULL)
                Data32(dpy, (long *) type->level_names, type->num_levels * 4);
        }
    }
    if (which & XkbIndicatorNamesMask)
        _XkbCopyAtoms(dpy, names->indicators, leds, XkbNumIndicators);
    if (which & XkbVirtualModNamesMask)
        _XkbCopyAtoms(dpy, names->vmods, vmods, XkbNumVirtualMods);
    if (which & XkbGroupNamesMask)
        _XkbCopyAtoms(dpy, names->groups, groups, XkbNumKbdGroups);
    if (which & XkbKeyNamesMask) {
        Data(dpy, (char *) &names->keys[firstKey], nKeys * XkbKeyNameLength);
    }
    if (which & XkbKeyAliasesMask) {
        Data(dpy, (char *) names->key_aliases, nKA * XkbKeyNameLength * 2);
    }
    if (which & XkbRGNamesMask) {
        Data32(dpy, (long *) names->radio_groups, nRG * 4);
    }
    UnlockDisplay(dpy);
    SyncHandle();
    return True;
}

Bool
XkbChangeNames(Display *dpy, XkbDescPtr xkb, XkbNameChangesPtr changes)
{
    register xkbSetNamesReq *req;
    int nLvlNames = 0;
    XkbInfoPtr xkbi;
    XkbNamesPtr names;
    unsigned which, firstType, nTypes;
    unsigned firstLvlType, nLvlTypes;
    int nVMods, nLEDs, nRG, nKA, nGroups;
    int nKeys = 0, firstKey = 0, nAtoms;
    CARD32 leds = 0, vmods = 0, groups = 0;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    if ((!xkb) || (!xkb->names) || (!changes))
        return False;
    which = changes->changed;
    firstType = changes->first_type;
    nTypes = changes->num_types;
    firstLvlType = changes->first_lvl;
    nLvlTypes = changes->num_lvls;
    if (which & XkbKeyTypeNamesMask) {
        if (nTypes < 1)
            which &= ~XkbKeyTypeNamesMask;
        else if (firstType <= XkbLastRequiredType) {
            int adjust;

            adjust = XkbLastRequiredType - firstType + 1;
            firstType += adjust;
            nTypes -= adjust;
            if (nTypes < 1)
                which &= ~XkbKeyTypeNamesMask;
        }
    }
    else
        firstType = nTypes = 0;

    if (which & XkbKTLevelNamesMask) {
        if (nLvlTypes < 1)
            which &= ~XkbKTLevelNamesMask;
    }
    else
        firstLvlType = nLvlTypes = 0;

    names = xkb->names;
    if (which & (XkbKTLevelNamesMask | XkbKeyTypeNamesMask)) {
        register int i;

        if ((xkb->map == NULL) || (xkb->map->types == NULL) || (nTypes == 0) ||
            (firstType + nTypes > xkb->map->num_types) ||
            (firstLvlType + nLvlTypes > xkb->map->num_types))
            return False;
        if (which & XkbKTLevelNamesMask) {
            XkbKeyTypePtr type = &xkb->map->types[firstLvlType];

            for (i = nLvlNames = 0; i < nLvlTypes; i++, type++) {
                if (type->level_names != NULL)
                    nLvlNames += type->num_levels;
            }
        }
    }

    if (changes->num_keys < 1)
        which &= ~XkbKeyNamesMask;
    if ((which & XkbKeyNamesMask) == 0)
        changes->first_key = changes->num_keys = 0;
    else if ((changes->first_key < xkb->min_key_code) ||
             (changes->first_key + changes->num_keys > xkb->max_key_code)) {
        return False;
    }

    if ((which & XkbVirtualModNamesMask) == 0)
        changes->changed_vmods = 0;
    else if (changes->changed_vmods == 0)
        which &= ~XkbVirtualModNamesMask;

    if ((which & XkbIndicatorNamesMask) == 0)
        changes->changed_indicators = 0;
    else if (changes->changed_indicators == 0)
        which &= ~XkbIndicatorNamesMask;

    if ((which & XkbGroupNamesMask) == 0)
        changes->changed_groups = 0;
    else if (changes->changed_groups == 0)
        which &= ~XkbGroupNamesMask;

    nVMods = nLEDs = nRG = nKA = nAtoms = nGroups = 0;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbSetNames, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbSetNames;
    req->deviceSpec = xkb->device_spec;
    req->firstType = firstType;
    req->nTypes = nTypes;
    req->firstKey = changes->first_key;
    req->nKeys = changes->num_keys;

    if (which & XkbKeycodesNameMask)
        nAtoms++;
    if (which & XkbGeometryNameMask)
        nAtoms++;
    if (which & XkbSymbolsNameMask)
        nAtoms++;
    if (which & XkbPhysSymbolsNameMask)
        nAtoms++;
    if (which & XkbTypesNameMask)
        nAtoms++;
    if (which & XkbCompatNameMask)
        nAtoms++;
    if (which & XkbKeyTypeNamesMask)
        nAtoms += nTypes;
    if (which & XkbKTLevelNamesMask) {
        req->firstKTLevel = firstLvlType;
        req->nKTLevels = nLvlTypes;
        req->length += XkbPaddedSize(nLvlTypes) / 4;    /* room for group widths */
        nAtoms += nLvlNames;
    }
    else
        req->firstKTLevel = req->nKTLevels = 0;

    if (which & XkbIndicatorNamesMask) {
        leds = req->indicators = (CARD32) changes->changed_indicators;
        nLEDs = _XkbCountBits(XkbNumIndicators, changes->changed_indicators);
        if (nLEDs > 0)
            nAtoms += nLEDs;
        else
            which &= ~XkbIndicatorNamesMask;
    }
    else
        req->indicators = 0;

    if (which & XkbVirtualModNamesMask) {
        vmods = req->virtualMods = changes->changed_vmods;
        nVMods = _XkbCountBits(XkbNumVirtualMods,
                               (unsigned long) changes->changed_vmods);
        if (nVMods > 0)
            nAtoms += nVMods;
        else
            which &= ~XkbVirtualModNamesMask;
    }
    else
        req->virtualMods = 0;

    if (which & XkbGroupNamesMask) {
        groups = req->groupNames = changes->changed_groups;
        nGroups = _XkbCountBits(XkbNumKbdGroups,
                                (unsigned long) changes->changed_groups);
        if (nGroups > 0)
            nAtoms += nGroups;
        else
            which &= ~XkbGroupNamesMask;
    }
    else
        req->groupNames = 0;

    if ((which & XkbKeyNamesMask) && (names->keys != NULL)) {
        firstKey = req->firstKey;
        nKeys = req->nKeys;
        nAtoms += nKeys;        /* technically not atoms, but 4 bytes wide */
    }
    else
        which &= ~XkbKeyNamesMask;

    if (which & XkbKeyAliasesMask) {
        nKA = ((names->key_aliases != NULL) ? names->num_key_aliases : 0);
        if (nKA > 0)
            nAtoms += nKA * 2;  /* not atoms, but 8 bytes on the wire */
        else
            which &= ~XkbKeyAliasesMask;
    }

    if (which & XkbRGNamesMask) {
        nRG = names->num_rg;
        if (nRG > 0)
            nAtoms += nRG;
        else
            which &= ~XkbRGNamesMask;
    }

    req->which = which;
    req->nRadioGroups = nRG;
    req->length += (nAtoms * 4) / 4;

    if (which & XkbKeycodesNameMask)
        Data32(dpy, (long *) &names->keycodes, 4);
    if (which & XkbGeometryNameMask)
        Data32(dpy, (long *) &names->geometry, 4);
    if (which & XkbSymbolsNameMask)
        Data32(dpy, (long *) &names->symbols, 4);
    if (which & XkbPhysSymbolsNameMask)
        Data32(dpy, (long *) &names->phys_symbols, 4);
    if (which & XkbTypesNameMask)
        Data32(dpy, (long *) &names->types, 4);
    if (which & XkbCompatNameMask)
        Data32(dpy, (long *) &names->compat, 4);
    if (which & XkbKeyTypeNamesMask) {
        register int i;
        register XkbKeyTypePtr type;

        type = &xkb->map->types[firstType];
        for (i = 0; i < nTypes; i++, type++) {
            Data32(dpy, (long *) &type->name, 4);
        }
    }
    if (which & XkbKTLevelNamesMask) {
        XkbKeyTypePtr type;
        int i;
        char *tmp;

        BufAlloc(char *, tmp, XkbPaddedSize(nLvlTypes));
        type = &xkb->map->types[firstLvlType];
        for (i = 0; i < nLvlTypes; i++, type++) {
            *tmp++ = type->num_levels;
        }
        type = &xkb->map->types[firstLvlType];
        for (i = 0; i < nLvlTypes; i++, type++) {
            if (type->level_names != NULL)
                Data32(dpy, (long *) type->level_names, type->num_levels * 4);
        }
    }
    if (which & XkbIndicatorNamesMask)
        _XkbCopyAtoms(dpy, names->indicators, leds, XkbNumIndicators);
    if (which & XkbVirtualModNamesMask)
        _XkbCopyAtoms(dpy, names->vmods, vmods, XkbNumVirtualMods);
    if (which & XkbGroupNamesMask)
        _XkbCopyAtoms(dpy, names->groups, groups, XkbNumKbdGroups);
    if (which & XkbKeyNamesMask) {
        Data(dpy, (char *) &names->keys[firstKey], nKeys * XkbKeyNameLength);
    }
    if (which & XkbKeyAliasesMask) {
        Data(dpy, (char *) names->key_aliases, nKA * XkbKeyNameLength * 2);
    }
    if (which & XkbRGNamesMask) {
        Data32(dpy, (long *) names->radio_groups, nRG * 4);
    }
    UnlockDisplay(dpy);
    SyncHandle();
    return True;
}

void
XkbNoteNameChanges(XkbNameChangesPtr old,
                   XkbNamesNotifyEvent *new,
                   unsigned int wanted)
{
    int first, last, old_last, new_last;

    if ((old == NULL) || (new == NULL))
        return;

    wanted &= new->changed;

    if (wanted == 0)
	return;

    if (wanted & XkbKeyTypeNamesMask) {
        if (old->changed & XkbKeyTypeNamesMask) {
            new_last = (new->first_type + new->num_types - 1);
            old_last = (old->first_type + old->num_types - 1);

            if (new->first_type < old->first_type)
                first = new->first_type;
            else
                first = old->first_type;

            if (old_last > new_last)
                last = old_last;
            else
                last = new_last;

            old->first_type = first;
            old->num_types = (last - first) + 1;
        }
        else {
            old->first_type = new->first_type;
            old->num_types = new->num_types;
        }
    }
    if (wanted & XkbKTLevelNamesMask) {
        if (old->changed & XkbKTLevelNamesMask) {
            new_last = (new->first_lvl + new->num_lvls - 1);
            old_last = (old->first_lvl + old->num_lvls - 1);

            if (new->first_lvl < old->first_lvl)
                first = new->first_lvl;
            else
                first = old->first_lvl;

            if (old_last > new_last)
                last = old_last;
            else
                last = new_last;

            old->first_lvl = first;
            old->num_lvls = (last - first) + 1;
        }
        else {
            old->first_lvl = new->first_lvl;
            old->num_lvls = new->num_lvls;
        }
    }
    if (wanted & XkbIndicatorNamesMask) {
        if (old->changed & XkbIndicatorNamesMask)
            old->changed_indicators |= new->changed_indicators;
        else
            old->changed_indicators = new->changed_indicators;
    }
    if (wanted & XkbKeyNamesMask) {
        if (old->changed & XkbKeyNamesMask) {
            new_last = (new->first_key + new->num_keys - 1);
            old_last = (old->first_key + old->num_keys - 1);

            first = old->first_key;

            if (new->first_key < old->first_key)
                first = new->first_key;
            if (old_last > new_last)
                new_last = old_last;

            old->first_key = first;
            old->num_keys = (new_last - first) + 1;
        }
        else {
            old->first_key = new->first_key;
            old->num_keys = new->num_keys;
        }
    }
    if (wanted & XkbVirtualModNamesMask) {
        if (old->changed & XkbVirtualModNamesMask)
            old->changed_vmods |= new->changed_vmods;
        else
            old->changed_vmods = new->changed_vmods;
    }
    if (wanted & XkbGroupNamesMask) {
        if (old->changed & XkbGroupNamesMask)
            old->changed_groups |= new->changed_groups;
        else
            old->changed_groups = new->changed_groups;
    }
    if (wanted & XkbRGNamesMask)
        old->num_rg = new->num_radio_groups;
    if (wanted & XkbKeyAliasesMask)
        old->num_aliases = new->num_aliases;
    old->changed |= wanted;
    return;
}
@


1.8
log
@update to libX11 1.6.3
@
text
@d552 1
a552 1
    firstLvlType = changes->first_lvl;;
@


1.7
log
@Update to libX11 1.6.2. No API change.
@
text
@d136 2
a137 2
                if (type->level_names != NULL)
                    Xfree(type->level_names);
d781 3
d785 4
a788 2
    if ((old == NULL) || (new == NULL) || (wanted == 0))
        return;
@


1.6
log
@Merge upstream fixes for several X libs vulnerabilities
discovered by Ilja van Sprundel.

CVE-2013-1981 X.org libX11 1.5.99.901 (1.6 RC1) integer overflows
CVE-2013-1982 X.org libXext 1.3.1 integer overflows
CVE-2013-1983 X.org libXfixes 5.0 integer overflows
CVE-2013-1984 X.org libXi 1.7.1 integer overflows
CVE-2013-1985 X.org libXinerama 1.1.2 integer overflows
CVE-2013-1986 X.org libXrandr 1.4.0 integer overflows
CVE-2013-1987 X.org libXrender 0.9.7 integer overflows
CVE-2013-1988 X.org libXRes 1.0.6 integer overflows
CVE-2013-1989 X.org libXv 1.0.7 integer overflows
CVE-2013-1990 X.org libXvMC 1.0.7 integer overflows
CVE-2013-1991 X.org libXxf86dga 1.1.3 integer overflows
CVE-2013-1992 X.org libdmx 1.1.2 integer overflows
CVE-2013-1994 X.org libchromeXvMC & libchromeXvMCPro in openChrome
0.3.2 integer overflows
CVE-2013-1995 X.org libXi 1.7.1 sign extension issues
CVE-2013-1996 X.org libFS 1.0.4 sign extension issues
CVE-2013-1997 X.org libX11 1.5.99.901 (1.6 RC1) buffer overflows
CVE-2013-1998 X.org libXi 1.7.1 buffer overflows
CVE-2013-1999 X.org libXvMC 1.0.7 buffer overflows
CVE-2013-2000 X.org libXxf86dga 1.1.3 buffer overflows
CVE-2013-2001 X.org libXxf86vm 1.1.2 buffer overflows
CVE-2013-2002 X.org libXt 1.1.3 buffer overflows
CVE-2013-2003 X.org libXcursor 1.1.13 integer overflows
CVE-2013-2004 X.org libX11 1.5.99.901 (1.6 RC1) unbounded recursion
CVE-2013-2005 X.org libXt 1.1.3 memory corruption
CVE-2013-2066 X.org libXv 1.0.7 buffer overflows
@
text
@d37 4
a40 4
_XkbReadAtoms(	XkbReadBufferPtr	buf,
		Atom *			atoms,
		int			maxAtoms,
		CARD32		 	present)
d42 1
a42 1
register int i,bit;
d44 6
a49 6
    for (i=0,bit=1;(i<maxAtoms)&&(present);i++,bit<<=1) {
	if (present&bit) {
	    if (!_XkbReadBufferCopy32(buf,(long *)&atoms[i],1))
		return BadLength;
	    present&= ~bit;
	}
d55 4
a58 4
_XkbReadGetNamesReply(	Display *		dpy,
			xkbGetNamesReply *	rep,
			XkbDescPtr 		xkb,
			int *			nread_rtrn)
d60 15
a74 15
    int				 i,len;
    XkbReadBufferRec		 buf;
    register XkbNamesPtr	 names;

    if ( xkb->device_spec == XkbUseCoreKbd )
	xkb->device_spec = rep->deviceID;

    if ((xkb->names==NULL)&&
	(XkbAllocNames(xkb,rep->which,
				rep->nRadioGroups,rep->nKeyAliases)!=Success)) {
	return BadAlloc;
    }
    names= xkb->names;
    if (rep->length==0)
	return Success;
d76 2
a77 2
    if (!_XkbInitReadBuffer(dpy,&buf,(int)rep->length*4))
	return BadAlloc;
d79 1
a79 1
	*nread_rtrn= (int)rep->length*4;
d81 77
a157 76
    if ((rep->which&XkbKeycodesNameMask)&&
	(!_XkbReadBufferCopy32(&buf,(long *)&names->keycodes,1)))
	    goto BAILOUT;
    if ((rep->which&XkbGeometryNameMask)&&
	(!_XkbReadBufferCopy32(&buf,(long *)&names->geometry,1)))
	    goto BAILOUT;
    if ((rep->which&XkbSymbolsNameMask)&&
	(!_XkbReadBufferCopy32(&buf,(long *)&names->symbols,1)))
	    goto BAILOUT;
    if ((rep->which&XkbPhysSymbolsNameMask)&&
	(!_XkbReadBufferCopy32(&buf,(long *)&names->phys_symbols,1)))
	    goto BAILOUT;
    if ((rep->which&XkbTypesNameMask)&&
	(!_XkbReadBufferCopy32(&buf,(long *)&names->types,1)))
	    goto BAILOUT;
    if ((rep->which&XkbCompatNameMask)&&
	(!_XkbReadBufferCopy32(&buf,(long *)&names->compat,1)))
	    goto BAILOUT;

    if ( rep->which & XkbKeyTypeNamesMask ) {
	XkbClientMapPtr	map= xkb->map;
	XkbKeyTypePtr	type;

	len= rep->nTypes*4;
	if (map!=NULL) {
	    type= map->types;
	    for (i=0;(i<map->num_types)&&(i<rep->nTypes);i++,type++) {
		if (!_XkbReadBufferCopy32(&buf,(long *)&type->name,1))
		    goto BAILOUT;
		len-= 4;
	    }
	}
	if ((len>0)&&(!_XkbSkipReadBufferData(&buf,len)))
	    goto BAILOUT;
    }
    if ( rep->which&XkbKTLevelNamesMask ) {
	CARD8 *nLevels;
	XkbClientMapPtr	map= xkb->map;
	XkbKeyTypePtr	type;

	nLevels=(CARD8*)_XkbGetReadBufferPtr(&buf,XkbPaddedSize(rep->nTypes));
	if (nLevels==NULL)
	    goto BAILOUT;
	if (map!=NULL) {
	    type= map->types;
	    for (i=0;i<(int)rep->nTypes;i++,type++) {
		if (i>=map->num_types) {
		    if (!_XkbSkipReadBufferData(&buf,nLevels[i]*4))
			goto BAILOUT;
		    continue;
		}
		if ((nLevels[i]>0)&&(nLevels[i]!=type->num_levels)) {
		    goto BAILOUT;
		}
		if (type->level_names!=NULL)
		    Xfree(type->level_names);
		if (nLevels[i]==0) {
		    type->level_names= NULL;
		    continue;
		}
		type->level_names= _XkbTypedCalloc(nLevels[i],Atom);
		if (type->level_names!=NULL) {
		    if (!_XkbReadBufferCopy32(&buf,(long *)type->level_names,
								nLevels[i]))
			goto BAILOUT;
		}
		else {
		    _XkbSkipReadBufferData(&buf,nLevels[i]*4);
		}
	    }
	}
	else {
	    for (i=0;i<(int)rep->nTypes;i++) {
		_XkbSkipReadBufferData(&buf,nLevels[i]*4);
	    }
	}
d160 74
a233 69
	if (_XkbReadAtoms(&buf,names->indicators,XkbNumIndicators,
						rep->indicators)!=Success)
	    goto BAILOUT;
    }
    if ( rep->which&XkbVirtualModNamesMask ) {
	if (_XkbReadAtoms(&buf,names->vmods,XkbNumVirtualMods,
					(CARD32)rep->virtualMods)!=Success)
	    goto BAILOUT;
    }
    if ( rep->which&XkbGroupNamesMask ) {
	if (_XkbReadAtoms(&buf,names->groups,XkbNumKbdGroups,
					(CARD32)rep->groupNames)!=Success)
	    goto BAILOUT;
    }
    if ( rep->which&XkbKeyNamesMask ) {
	if (names->keys==NULL) {
	    int nKeys;
	    if (xkb->max_key_code==0) {
		xkb->min_key_code= rep->minKeyCode;
		xkb->max_key_code= rep->maxKeyCode;
	    }
	    nKeys= xkb->max_key_code+1;
	    names->keys= _XkbTypedCalloc(nKeys,XkbKeyNameRec);
	}
	if ( ((int)rep->firstKey + rep->nKeys) > xkb->max_key_code + 1)
	    goto BAILOUT;
	if (names->keys!=NULL) {
	    if (!_XkbCopyFromReadBuffer(&buf,
					(char *)&names->keys[rep->firstKey],
					rep->nKeys*XkbKeyNameLength))
		goto BAILOUT;
	}
	else _XkbSkipReadBufferData(&buf,rep->nKeys*XkbKeyNameLength);
    }
    if ( rep->which&XkbKeyAliasesMask && (rep->nKeyAliases>0) ) {
	if (XkbAllocNames(xkb,XkbKeyAliasesMask,0,rep->nKeyAliases)!=Success)
	    goto BAILOUT;
	if (!_XkbCopyFromReadBuffer(&buf,(char *)names->key_aliases,
				rep->nKeyAliases*XkbKeyNameLength*2))
	    goto BAILOUT;
    }
    if ( rep->which&XkbRGNamesMask ) {
	if (rep->nRadioGroups>0) {
	    Atom *rgNames;

	    if (names->radio_groups==NULL)
		names->radio_groups = _XkbTypedCalloc(rep->nRadioGroups,Atom);
	    else if (names->num_rg<rep->nRadioGroups) {
		names->radio_groups = _XkbTypedRealloc(names->radio_groups,
							rep->nRadioGroups,
							Atom);
	    }
	    rgNames= names->radio_groups;
	    if (!rgNames) {
		goto BAILOUT;
	    }
	    if (!_XkbReadBufferCopy32(&buf,(long *)rgNames,rep->nRadioGroups))
		goto BAILOUT;
	    names->num_rg= rep->nRadioGroups;
	}
	else if (names->num_rg>0) {
	    names->num_rg= 0;
	    Xfree(names->radio_groups);
	}
    }
    len= _XkbFreeReadBuffer(&buf);
    if (len!=0) 	return BadLength;
    else		return Success;
BAILOUT:
d239 1
a239 1
XkbGetNames(Display *dpy,unsigned which,XkbDescPtr xkb)
d242 2
a243 2
    xkbGetNamesReply	     rep;
    Status		     status;
d247 2
a248 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
d252 6
a257 6
	xkb->names = _XkbTypedCalloc(1,XkbNamesRec);
	if (!xkb->names) {
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return BadAlloc;
	}
d264 4
a267 4
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	UnlockDisplay(dpy);
	SyncHandle();
	return BadImplementation;
d270 1
a270 1
    status = _XkbReadGetNamesReply(dpy,&rep,xkb,NULL);
d279 1
a279 1
_XkbCountBits(int nBitsMax,unsigned long mask)
d281 1
a281 1
register unsigned long y, nBits;
d283 2
a284 2
    y = (mask >> 1) &033333333333;
    y = mask - y - ((y >>1) & 033333333333);
d292 1
a292 1
_XkbCountAtoms(Atom *atoms,int maxAtoms,int *count)
d294 2
a295 2
register unsigned int i,bit,nAtoms;
register CARD32 atomsPresent;
d297 3
a299 3
    for (i=nAtoms=atomsPresent=0,bit=1;i<maxAtoms;i++,bit<<=1) {
        if (atoms[i]!=None) {
            atomsPresent|= bit;
d304 1
a304 1
        *count= nAtoms;
d309 1
a309 1
_XkbCopyAtoms(Display *dpy,Atom *atoms,CARD32 mask,int maxAtoms)
d311 1
a311 1
register unsigned int i,bit;
d313 3
a315 3
    for (i=0,bit=1;i<maxAtoms;i++,bit<<=1) {
        if (mask&bit)
	    Data32(dpy,&atoms[i],4);
d321 5
a325 5
XkbSetNames(	Display *	dpy,
		unsigned int 	which,
		unsigned int 	firstType,
		unsigned int 	nTypes,
		XkbDescPtr 	xkb)
d328 1
a328 1
    int  nLvlNames = 0;
d331 4
a334 4
    unsigned firstLvlType,nLvlTypes;
    int	nVMods,nLEDs,nRG,nKA,nGroups;
    int nKeys=0,firstKey=0,nAtoms;
    CARD32 leds,vmods,groups;
d337 33
a369 31
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
    if ((!xkb)||(!xkb->names))
	return False;
    firstLvlType= firstType;
    nLvlTypes= nTypes;
    if (nTypes<1)
	which&= ~(XkbKTLevelNamesMask|XkbKeyTypeNamesMask);
    else if (firstType<=XkbLastRequiredType) {
	int	adjust;
	adjust= XkbLastRequiredType-firstType+1;
	firstType+= adjust;
	nTypes-= adjust;
	if (nTypes<1)
	    which&= ~XkbKeyTypeNamesMask;
    }
    names= xkb->names;
    if (which&(XkbKTLevelNamesMask|XkbKeyTypeNamesMask)) {
	register int	i;
	XkbKeyTypePtr	type;
	if((xkb->map==NULL)||(xkb->map->types==NULL)||(nTypes==0)||
				(firstType+nTypes>xkb->map->num_types)||
				(firstLvlType+nLvlTypes>xkb->map->num_types))
	    return False;
	if (which&XkbKTLevelNamesMask) {
	    type= &xkb->map->types[firstLvlType];
	    for (i=nLvlNames=0;i<nLvlTypes;i++,type++) {
		if (type->level_names!=NULL)
		    nLvlNames+= type->num_levels;
	    }
	}
d372 1
a372 1
    nVMods= nLEDs= nRG= nKA= nAtoms= nGroups= 0;
d382 1
a382 1
    req->nKeys = xkb->max_key_code-xkb->min_key_code+1;
d384 74
a457 124
    if (which&XkbKeycodesNameMask)
	nAtoms++;
    if (which&XkbGeometryNameMask)
	nAtoms++;
    if (which&XkbSymbolsNameMask)
	nAtoms++;
    if (which&XkbPhysSymbolsNameMask)
	nAtoms++;
    if (which&XkbTypesNameMask)
	nAtoms++;
    if (which&XkbCompatNameMask)
	nAtoms++;
    if (which&XkbKeyTypeNamesMask)
	nAtoms+= nTypes;
    if (which&XkbKTLevelNamesMask) {
	req->firstKTLevel= firstLvlType;
	req->nKTLevels= nLvlTypes;
	req->length+= XkbPaddedSize(nLvlTypes)/4; /* room for group widths */
	nAtoms+= nLvlNames;
    }
    else req->firstKTLevel= req->nKTLevels= 0;

    if (which&XkbIndicatorNamesMask) {
	req->indicators= leds=
		_XkbCountAtoms(names->indicators,XkbNumIndicators,&nLEDs);
	if (nLEDs>0)
	     nAtoms+= nLEDs;
	else which&= ~XkbIndicatorNamesMask;
    }
    else req->indicators= leds= 0;

    if (which&XkbVirtualModNamesMask) {
	vmods= req->virtualMods= (CARD16)
		_XkbCountAtoms(names->vmods,XkbNumVirtualMods,&nVMods);
	if (nVMods>0)
	     nAtoms+= nVMods;
	else which&= ~XkbVirtualModNamesMask;
    }
    else vmods= req->virtualMods= 0;

    if (which&XkbGroupNamesMask) {
	groups= req->groupNames= (CARD8)
		_XkbCountAtoms(names->groups,XkbNumKbdGroups,&nGroups);
	if (nGroups>0)
	     nAtoms+= nGroups;
	else which&= ~XkbGroupNamesMask;
    }
    else groups= req->groupNames= 0;

    if ((which&XkbKeyNamesMask)&&(names->keys!=NULL)) {
	firstKey= req->firstKey;
	nKeys= req->nKeys;
	nAtoms+= nKeys;	/* technically not atoms, but 4 bytes wide */
    }
    else which&= ~XkbKeyNamesMask;

    if (which&XkbKeyAliasesMask) {
	nKA= ((names->key_aliases!=NULL)?names->num_key_aliases:0);
	if (nKA>0) {
	    req->nKeyAliases= nKA;
	    nAtoms+= nKA*2; /* not atoms, but 8 bytes on the wire */
	}
	else {
	    which&= ~XkbKeyAliasesMask;
	    req->nKeyAliases = 0;
	}
    }
    else req->nKeyAliases= 0;

    if (which&XkbRGNamesMask) {
	nRG= names->num_rg;
	if (nRG>0)
	     nAtoms+= nRG;
	else which&= ~XkbRGNamesMask;
    }

    req->which= which;
    req->nRadioGroups= nRG;
    req->length+= (nAtoms*4)/4;

    if (which&XkbKeycodesNameMask)
	Data32(dpy,(long *)&names->keycodes,4);
    if (which&XkbGeometryNameMask)
	Data32(dpy,(long *)&names->geometry,4);
    if (which&XkbSymbolsNameMask)
	Data32(dpy,(long *)&names->symbols,4);
    if (which&XkbPhysSymbolsNameMask)
	Data32(dpy,(long *)&names->phys_symbols,4);
    if (which&XkbTypesNameMask)
	Data32(dpy,(long *)&names->types,4);
    if (which&XkbCompatNameMask)
	Data32(dpy,(long *)&names->compat,4);
    if (which&XkbKeyTypeNamesMask) {
	register int 		i;
	register XkbKeyTypePtr	type;
	type= &xkb->map->types[firstType];
	for (i=0;i<nTypes;i++,type++) {
	    Data32(dpy,(long *)&type->name,4);
	}
    }
    if (which&XkbKTLevelNamesMask) {
	XkbKeyTypePtr type;
	int i;
	char *tmp;

	BufAlloc(char *,tmp,XkbPaddedSize(nLvlTypes));
	type = &xkb->map->types[firstLvlType];
	for (i=0;i<nLvlTypes;i++,type++) {
	    *tmp++ = type->num_levels;
	}
	type = &xkb->map->types[firstLvlType];
	for (i=0;i<nLvlTypes;i++,type++) {
	    if (type->level_names!=NULL)
		Data32(dpy,(long *)type->level_names,type->num_levels*4);
	}
    }
    if (which&XkbIndicatorNamesMask)
	_XkbCopyAtoms(dpy,names->indicators,leds,XkbNumIndicators);
    if (which&XkbVirtualModNamesMask)
	_XkbCopyAtoms(dpy,names->vmods,vmods,XkbNumVirtualMods);
    if (which&XkbGroupNamesMask)
	_XkbCopyAtoms(dpy,names->groups,groups,XkbNumKbdGroups);
    if (which&XkbKeyNamesMask) {
	Data(dpy,(char *)&names->keys[firstKey],nKeys*XkbKeyNameLength);
d459 9
a467 2
    if (which&XkbKeyAliasesMask) {
	Data(dpy,(char *)names->key_aliases,nKA*XkbKeyNameLength*2);
d469 56
a524 2
    if (which&XkbRGNamesMask) {
	Data32(dpy,(long *)names->radio_groups,nRG*4);
d532 1
a532 1
XkbChangeNames(Display *dpy,XkbDescPtr xkb,XkbNameChangesPtr changes)
d535 1
a535 1
    int  nLvlNames = 0;
d538 5
a542 5
    unsigned which,firstType,nTypes;
    unsigned firstLvlType,nLvlTypes;
    int	nVMods,nLEDs,nRG,nKA,nGroups;
    int nKeys=0,firstKey=0,nAtoms;
    CARD32 leds=0,vmods=0,groups=0;
d545 49
a593 69
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
    if ((!xkb)||(!xkb->names)||(!changes))
	return False;
    which= changes->changed;
    firstType= changes->first_type;
    nTypes= changes->num_types;
    firstLvlType= changes->first_lvl;;
    nLvlTypes= changes->num_lvls;
    if (which&XkbKeyTypeNamesMask) {
	if (nTypes<1)
	    which&= ~XkbKeyTypeNamesMask;
	else if (firstType<=XkbLastRequiredType) {
	    int	adjust;
	    adjust= XkbLastRequiredType-firstType+1;
	    firstType+= adjust;
	    nTypes-= adjust;
	    if (nTypes<1)
		which&= ~XkbKeyTypeNamesMask;
	}
    }
    else firstType= nTypes= 0;

    if (which&XkbKTLevelNamesMask) {
	if (nLvlTypes<1)
	    which&= ~XkbKTLevelNamesMask;
    }
    else firstLvlType= nLvlTypes= 0;

    names= xkb->names;
    if (which&(XkbKTLevelNamesMask|XkbKeyTypeNamesMask)) {
	register int	i;
	XkbKeyTypePtr	type;
	if((xkb->map==NULL)||(xkb->map->types==NULL)||(nTypes==0)||
				(firstType+nTypes>xkb->map->num_types)||
				(firstLvlType+nLvlTypes>xkb->map->num_types))
	    return False;
	if (which&XkbKTLevelNamesMask) {
	    type= &xkb->map->types[firstLvlType];
	    for (i=nLvlNames=0;i<nLvlTypes;i++,type++) {
		if (type->level_names!=NULL)
		    nLvlNames+= type->num_levels;
	    }
	}
    }

    if (changes->num_keys<1)
	which&= ~XkbKeyNamesMask;
    if ((which&XkbKeyNamesMask)==0)
	changes->first_key= changes->num_keys= 0;
    else if ((changes->first_key<xkb->min_key_code)||
	     (changes->first_key+changes->num_keys>xkb->max_key_code)) {
	return False;
    }

    if ((which&XkbVirtualModNamesMask)==0)
	changes->changed_vmods= 0;
    else if (changes->changed_vmods==0)
	which&= ~XkbVirtualModNamesMask;

    if ((which&XkbIndicatorNamesMask)==0)
	changes->changed_indicators= 0;
    else if (changes->changed_indicators==0)
	which&= ~XkbIndicatorNamesMask;

    if ((which&XkbGroupNamesMask)==0)
	changes->changed_groups= 0;
    else if (changes->changed_groups==0)
	which&= ~XkbGroupNamesMask;
d595 25
a619 1
    nVMods= nLEDs= nRG= nKA= nAtoms= nGroups= 0;
d631 122
a752 120
    if (which&XkbKeycodesNameMask)
	nAtoms++;
    if (which&XkbGeometryNameMask)
	nAtoms++;
    if (which&XkbSymbolsNameMask)
	nAtoms++;
    if (which&XkbPhysSymbolsNameMask)
	nAtoms++;
    if (which&XkbTypesNameMask)
	nAtoms++;
    if (which&XkbCompatNameMask)
	nAtoms++;
    if (which&XkbKeyTypeNamesMask)
	nAtoms+= nTypes;
    if (which&XkbKTLevelNamesMask) {
	req->firstKTLevel= firstLvlType;
	req->nKTLevels= nLvlTypes;
	req->length+= XkbPaddedSize(nLvlTypes)/4; /* room for group widths */
	nAtoms+= nLvlNames;
    }
    else req->firstKTLevel= req->nKTLevels= 0;

    if (which&XkbIndicatorNamesMask) {
	leds= req->indicators= (CARD32)changes->changed_indicators;
	nLEDs= _XkbCountBits(XkbNumIndicators,changes->changed_indicators);
	if (nLEDs>0)
	     nAtoms+= nLEDs;
	else which&= ~XkbIndicatorNamesMask;
    }
    else req->indicators= 0;

    if (which&XkbVirtualModNamesMask) {
	vmods= req->virtualMods= changes->changed_vmods;
	nVMods= _XkbCountBits(XkbNumVirtualMods,
					(unsigned long)changes->changed_vmods);
	if (nVMods>0)
	     nAtoms+= nVMods;
	else which&= ~XkbVirtualModNamesMask;
    }
    else req->virtualMods= 0;

    if (which&XkbGroupNamesMask) {
	groups= req->groupNames= changes->changed_groups;
	nGroups= _XkbCountBits(XkbNumKbdGroups,
					(unsigned long)changes->changed_groups);
	if (nGroups>0)
	     nAtoms+= nGroups;
	else which&= ~XkbGroupNamesMask;
    }
    else req->groupNames= 0;

    if ((which&XkbKeyNamesMask)&&(names->keys!=NULL)) {
	firstKey= req->firstKey;
	nKeys= req->nKeys;
	nAtoms+= nKeys;	/* technically not atoms, but 4 bytes wide */
    }
    else which&= ~XkbKeyNamesMask;

    if (which&XkbKeyAliasesMask) {
	nKA= ((names->key_aliases!=NULL)?names->num_key_aliases:0);
	if (nKA>0)
	    nAtoms+= nKA*2; /* not atoms, but 8 bytes on the wire */
	else which&= ~XkbKeyAliasesMask;
    }

    if (which&XkbRGNamesMask) {
	nRG= names->num_rg;
	if (nRG>0)
	     nAtoms+= nRG;
	else which&= ~XkbRGNamesMask;
    }

    req->which= which;
    req->nRadioGroups= nRG;
    req->length+= (nAtoms*4)/4;

    if (which&XkbKeycodesNameMask)
	Data32(dpy,(long *)&names->keycodes,4);
    if (which&XkbGeometryNameMask)
	Data32(dpy,(long *)&names->geometry,4);
    if (which&XkbSymbolsNameMask)
	Data32(dpy,(long *)&names->symbols,4);
    if (which&XkbPhysSymbolsNameMask)
	Data32(dpy,(long *)&names->phys_symbols,4);
    if (which&XkbTypesNameMask)
	Data32(dpy,(long *)&names->types,4);
    if (which&XkbCompatNameMask)
	Data32(dpy,(long *)&names->compat,4);
    if (which&XkbKeyTypeNamesMask) {
	register int 		i;
	register XkbKeyTypePtr	type;
	type= &xkb->map->types[firstType];
	for (i=0;i<nTypes;i++,type++) {
	    Data32(dpy,(long *)&type->name,4);
	}
    }
    if (which&XkbKTLevelNamesMask) {
	XkbKeyTypePtr type;
	int i;
	char *tmp;

	BufAlloc(char *,tmp,XkbPaddedSize(nLvlTypes));
	type = &xkb->map->types[firstLvlType];
	for (i=0;i<nLvlTypes;i++,type++) {
	    *tmp++ = type->num_levels;
	}
	type = &xkb->map->types[firstLvlType];
	for (i=0;i<nLvlTypes;i++,type++) {
	    if (type->level_names!=NULL)
		Data32(dpy,(long *)type->level_names,type->num_levels*4);
	}
    }
    if (which&XkbIndicatorNamesMask)
	_XkbCopyAtoms(dpy,names->indicators,leds,XkbNumIndicators);
    if (which&XkbVirtualModNamesMask)
	_XkbCopyAtoms(dpy,names->vmods,vmods,XkbNumVirtualMods);
    if (which&XkbGroupNamesMask)
	_XkbCopyAtoms(dpy,names->groups,groups,XkbNumKbdGroups);
    if (which&XkbKeyNamesMask) {
	Data(dpy,(char *)&names->keys[firstKey],nKeys*XkbKeyNameLength);
d754 8
a761 2
    if (which&XkbKeyAliasesMask) {
	Data(dpy,(char *)names->key_aliases,nKA*XkbKeyNameLength*2);
d763 5
a767 2
    if (which&XkbRGNamesMask) {
	Data32(dpy,(long *)names->radio_groups,nRG*4);
d775 3
a777 3
XkbNoteNameChanges(	XkbNameChangesPtr	old,
			XkbNamesNotifyEvent *	new,
			unsigned int	 	wanted)
d779 19
a797 1
int	first,last,old_last,new_last;
d799 74
a872 85
    wanted&= new->changed;
    if ((old==NULL)||(new==NULL)||(wanted==0))
	return;
    if (wanted&XkbKeyTypeNamesMask) {
	if (old->changed&XkbKeyTypeNamesMask) {
	    new_last= (new->first_type+new->num_types-1);
	    old_last= (old->first_type+old->num_types-1);

	    if (new->first_type<old->first_type)
		 first= new->first_type;
	    else first= old->first_type;

	    if (old_last>new_last)
		 last= old_last;
	    else last= new_last;

	    old->first_type= first;
	    old->num_types= (last-first)+1;
	}
	else {
	    old->first_type= new->first_type;
	    old->num_types= new->num_types;
	}
    }
    if (wanted&XkbKTLevelNamesMask) {
	if (old->changed&XkbKTLevelNamesMask) {
	    new_last= (new->first_lvl+new->num_lvls-1);
	    old_last= (old->first_lvl+old->num_lvls-1);

	    if (new->first_lvl<old->first_lvl)
		 first= new->first_lvl;
	    else first= old->first_lvl;

	    if (old_last>new_last)
		 last= old_last;
	    else last= new_last;

	    old->first_lvl= first;
	    old->num_lvls= (last-first)+1;
	}
	else {
	    old->first_lvl= new->first_lvl;
	    old->num_lvls= new->num_lvls;
	}
    }
    if (wanted&XkbIndicatorNamesMask) {
	if (old->changed&XkbIndicatorNamesMask)
	     old->changed_indicators|= new->changed_indicators;
	else old->changed_indicators=  new->changed_indicators;
    }
    if (wanted&XkbKeyNamesMask) {
	if (old->changed&XkbKeyNamesMask) {
	    new_last= (new->first_key+new->num_keys-1);
	    old_last= (old->first_key+old->num_keys-1);

	    first= old->first_key;

	    if (new->first_key<old->first_key)
		first= new->first_key;
	    if (old_last>new_last)
		new_last= old_last;

	    old->first_key= first;
	    old->num_keys= (new_last-first)+1;
	}
	else {
	    old->first_key= new->first_key;
	    old->num_keys= new->num_keys;
	}
    }
    if (wanted&XkbVirtualModNamesMask) {
	if (old->changed&XkbVirtualModNamesMask)
	     old->changed_vmods|= new->changed_vmods;
	else old->changed_vmods=  new->changed_vmods;
    }
    if (wanted&XkbGroupNamesMask) {
	if (old->changed&XkbGroupNamesMask)
	     old->changed_groups|= new->changed_groups;
	else old->changed_groups=  new->changed_groups;
    }
    if (wanted&XkbRGNamesMask)
	old->num_rg= new->num_radio_groups;
    if (wanted&XkbKeyAliasesMask)
	old->num_aliases= new->num_aliases;
    old->changed|= wanted;
@


1.5
log
@Update to libX11 1.6RC. No bump needed.
@
text
@d183 2
@


1.4
log
@Update to libx11 1.4.2. Tested by ajacoutot@@, jasper@@ krw@@, landry@@,
shadchin@@ on various architectures.
Bump major.
@
text
@a496 11
#ifdef WORD64
	char *tmp;
	register int i;
	BufAlloc(char *,tmp,nKeys*XkbKeyNameLength);
	for (i=0;i<nKeys;i++,tmp+= XkbKeyNameLength) {
	    tmp[0]= names->keys[firstKey+i].name[0];
	    tmp[1]= names->keys[firstKey+i].name[1];
	    tmp[2]= names->keys[firstKey+i].name[2];
	    tmp[3]= names->keys[firstKey+i].name[3];
	}
#else
a497 1
#endif
a499 15
#ifdef WORD64
	char *tmp;
	register int i;
	BufAlloc(char *,tmp,nKA*XkbKeyNameLength*2);
	for (i=0;i<nKeys;i++,tmp+= 2*XkbKeyNameLength) {
	    tmp[0]= names->key_aliases[i].real[0];
	    tmp[1]= names->key_aliases[i].real[1];
	    tmp[2]= names->key_aliases[i].real[2];
	    tmp[3]= names->key_aliases[i].real[3];
	    tmp[4]= names->key_aliases[i].alias[0];
	    tmp[5]= names->key_aliases[i].alias[1];
	    tmp[6]= names->key_aliases[i].alias[2];
	    tmp[7]= names->key_aliases[i].alias[3];
	}
#else
a500 1
#endif
a724 11
#ifdef WORD64
	char *tmp;
	register int i;
	BufAlloc(char *,tmp,nKeys*4);
	for (i=0;i<nKeys;i++,tmp+= 4) {
	    tmp[0]= names->keys[firstKey+i].name[0];
	    tmp[1]= names->keys[firstKey+i].name[1];
	    tmp[2]= names->keys[firstKey+i].name[2];
	    tmp[3]= names->keys[firstKey+i].name[3];
	}
#else
a725 1
#endif
a727 15
#ifdef WORD64
	char *tmp;
	register int i;
	BufAlloc(char *,tmp,nKA*XkbKeyNameLength*2);
	for (i=0;i<nKeys;i++,tmp+= 2*XkbKeyNameLength) {
	    tmp[0]= names->key_aliases[i].real[0];
	    tmp[1]= names->key_aliases[i].real[1];
	    tmp[2]= names->key_aliases[i].real[2];
	    tmp[3]= names->key_aliases[i].real[3];
	    tmp[4]= names->key_aliases[i].alias[0];
	    tmp[5]= names->key_aliases[i].alias[1];
	    tmp[6]= names->key_aliases[i].alias[2];
	    tmp[7]= names->key_aliases[i].alias[3];
	}
#else
a728 1
#endif
@


1.3
log
@Update to libX11 1.3.3. Tested on a bulk ports build by naddy@@.
@
text
@a26 2
#define NEED_REPLIES
#define NEED_EVENTS
@


1.2
log
@update to libX11 1.2.1
@
text
@a0 1
/* $Xorg: XKBNames.c,v 1.3 2000/08/17 19:45:02 cpqbld Exp $ */
a25 1
/* $XFree86: xc/lib/X11/XKBNames.c,v 1.5 2003/04/13 19:22:18 dawes Exp $ */
@


1.1
log
@Initial revision
@
text
@d10 2
a11 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d13 1
a13 1
Silicon Graphics makes no representation about the suitability 
d17 2
a18 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d20 3
a22 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d365 1
a365 1
 
d410 1
a410 1
	vmods= req->virtualMods= (CARD16) 
d566 1
a566 1
	if (nTypes<1)	
d625 1
a625 1
 
d885 1
a885 1
    if (wanted&XkbRGNamesMask) 
d887 1
a887 1
    if (wanted&XkbKeyAliasesMask) 
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
