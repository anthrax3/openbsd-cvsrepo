head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.6
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.4
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.2
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.6
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.10
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.8
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_1_3:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	v1_0_99_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.04.06.20.57.59;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	L5f7tv2EiGjtzoSu;

1.5
date	2013.09.28.17.03.21;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.30.19.19.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.18.19.37.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.12.59.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.16.37.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.16.37.32;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@update to libX11 1.6.3
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdio.h>
#include "Xlibint.h"
#include <X11/extensions/XKBproto.h>
#include "XKBlibint.h"

XkbInternAtomFunc       _XkbInternAtomFunc  = XInternAtom;
XkbGetAtomNameFunc      _XkbGetAtomNameFunc = XGetAtomName;

Bool
XkbQueryExtension(Display *dpy,
                  int *opcodeReturn,
                  int *eventBaseReturn,
                  int *errorBaseReturn,
                  int *majorReturn,
                  int *minorReturn)
{
    if (!XkbUseExtension(dpy, majorReturn, minorReturn))
        return False;
    if (opcodeReturn)
        *opcodeReturn = dpy->xkb_info->codes->major_opcode;
    if (eventBaseReturn)
        *eventBaseReturn = dpy->xkb_info->codes->first_event;
    if (errorBaseReturn)
        *errorBaseReturn = dpy->xkb_info->codes->first_error;
    if (majorReturn)
        *majorReturn = dpy->xkb_info->srv_major;
    if (minorReturn)
        *minorReturn = dpy->xkb_info->srv_minor;
    return True;
}

Bool
XkbLibraryVersion(int *libMajorRtrn, int *libMinorRtrn)
{
    int supported;

    if (*libMajorRtrn != XkbMajorVersion) {
        /* version 0.65 is (almost) compatible with 1.00 */
        if ((XkbMajorVersion == 1) &&
            (((*libMajorRtrn) == 0) && ((*libMinorRtrn) == 65)))
            supported = True;
        else
            supported = False;
    }
    else {
        supported = True;
    }

    *libMajorRtrn = XkbMajorVersion;
    *libMinorRtrn = XkbMinorVersion;
    return supported;
}

Bool
XkbSelectEvents(Display *dpy,
                unsigned int deviceSpec,
                unsigned int affect,
                unsigned int selectAll)
{
    register xkbSelectEventsReq *req;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    xkbi->selected_events &= ~affect;
    xkbi->selected_events |= (affect & selectAll);
    GetReq(kbSelectEvents, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbSelectEvents;
    req->deviceSpec = deviceSpec;
    req->affectWhich = (CARD16) affect;
    req->clear = affect & (~selectAll);
    req->selectAll = affect & selectAll;
    if (affect & XkbMapNotifyMask) {
        req->affectMap = XkbAllMapComponentsMask;
        /* the implicit support needs the client info */
        /* even if the client itself doesn't want it */
        if (selectAll & XkbMapNotifyMask)
            req->map = XkbAllMapEventsMask;
        else
            req->map = XkbAllClientInfoMask;
        if (selectAll & XkbMapNotifyMask)
            xkbi->selected_map_details = XkbAllMapEventsMask;
        else
            xkbi->selected_map_details = 0;
    }
    if (affect & XkbNewKeyboardNotifyMask) {
        if (selectAll & XkbNewKeyboardNotifyMask)
            xkbi->selected_nkn_details = XkbAllNewKeyboardEventsMask;
        else
            xkbi->selected_nkn_details = 0;
        if (!(xkbi->xlib_ctrls & XkbLC_IgnoreNewKeyboards)) {
            /* we want it, even if the client doesn't.  Don't mess */
            /* around with details -- ask for all of them and throw */
            /* away the ones we don't need */
            req->selectAll |= XkbNewKeyboardNotifyMask;
        }
    }
    UnlockDisplay(dpy);
    SyncHandle();
    return True;
}

Bool
XkbSelectEventDetails(Display *dpy,
                      unsigned deviceSpec,
                      unsigned eventType,
                      unsigned long int affect,
                      unsigned long int details)
{
    register xkbSelectEventsReq *req;
    XkbInfoPtr  xkbi;
    int         size = 0;
    char        *out;
    union {
        CARD8   *c8;
        CARD16  *c16;
        CARD32  *c32;
    } u;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    if (affect & details)
        xkbi->selected_events |= (1 << eventType);
    else
        xkbi->selected_events &= ~(1 << eventType);
    GetReq(kbSelectEvents, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbSelectEvents;
    req->deviceSpec = deviceSpec;
    req->clear = req->selectAll = 0;
    if (eventType == XkbMapNotify) {
        /* we need all of the client info, even if the application */
        /* doesn't.   Make sure that we always request the stuff */
        /* that the implicit support needs, and just filter out anything */
        /* the client doesn't want later */
        req->affectMap = (CARD16) affect;
        req->map = (CARD16) details | (XkbAllClientInfoMask & affect);
        req->affectWhich = XkbMapNotifyMask;
        xkbi->selected_map_details &= ~affect;
        xkbi->selected_map_details |= (details & affect);
    }
    else {
        req->affectMap = req->map = 0;
        req->affectWhich = (1 << eventType);
        switch (eventType) {
        case XkbNewKeyboardNotify:
            xkbi->selected_nkn_details &= ~affect;
            xkbi->selected_nkn_details |= (details & affect);
            if (!(xkbi->xlib_ctrls & XkbLC_IgnoreNewKeyboards))
                details = (affect & XkbAllNewKeyboardEventsMask);
        case XkbStateNotify:
        case XkbNamesNotify:
        case XkbAccessXNotify:
        case XkbExtensionDeviceNotify:
            size = 2;
            req->length += 1;
            break;
        case XkbControlsNotify:
        case XkbIndicatorStateNotify:
        case XkbIndicatorMapNotify:
            size = 4;
            req->length += 2;
            break;
        case XkbBellNotify:
        case XkbActionMessage:
        case XkbCompatMapNotify:
            size = 1;
            req->length += 1;
            break;
        }
        BufAlloc(char *, out, (((size * 2) + (unsigned) 3) / 4) * 4);

        u.c8 = (CARD8 *) out;
        if (size == 2) {
            u.c16[0] = (CARD16) affect;
            u.c16[1] = (CARD16) details;
        }
        else if (size == 4) {
            u.c32[0] = (CARD32) affect;
            u.c32[1] = (CARD32) details;
        }
        else {
            u.c8[0] = (CARD8) affect;
            u.c8[1] = (CARD8) details;
        }
    }
    UnlockDisplay(dpy);
    SyncHandle();
    return True;
}

Bool
XkbLockModifiers(Display *dpy,
                 unsigned int deviceSpec,
                 unsigned int affect,
                 unsigned int values)
{
    register xkbLatchLockStateReq *req;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbLatchLockState, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbLatchLockState;
    req->deviceSpec = deviceSpec;
    req->affectModLocks = affect;
    req->modLocks = values;
    req->lockGroup = False;
    req->groupLock = 0;

    req->affectModLatches = req->modLatches = 0;
    req->latchGroup = False;
    req->groupLatch = 0;
    UnlockDisplay(dpy);
    SyncHandle();
    return True;
}

Bool
XkbLatchModifiers(Display *dpy,
                  unsigned int deviceSpec,
                  unsigned int affect,
                  unsigned int values)
{
    register xkbLatchLockStateReq *req;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbLatchLockState, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbLatchLockState;
    req->deviceSpec = deviceSpec;

    req->affectModLatches = affect;
    req->modLatches = values;
    req->latchGroup = False;
    req->groupLatch = 0;

    req->affectModLocks = req->modLocks = 0;
    req->lockGroup = False;
    req->groupLock = 0;

    UnlockDisplay(dpy);
    SyncHandle();
    return True;
}

Bool
XkbLockGroup(Display *dpy, unsigned int deviceSpec, unsigned int group)
{
    register xkbLatchLockStateReq *req;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbLatchLockState, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbLatchLockState;
    req->deviceSpec = deviceSpec;
    req->affectModLocks = 0;
    req->modLocks = 0;
    req->lockGroup = True;
    req->groupLock = group;

    req->affectModLatches = req->modLatches = 0;
    req->latchGroup = False;
    req->groupLatch = 0;
    UnlockDisplay(dpy);
    SyncHandle();
    return True;
}

Bool
XkbLatchGroup(Display *dpy, unsigned int deviceSpec, unsigned int group)
{
    register xkbLatchLockStateReq *req;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbLatchLockState, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbLatchLockState;
    req->deviceSpec = deviceSpec;

    req->affectModLatches = 0;
    req->modLatches = 0;
    req->latchGroup = True;
    req->groupLatch = group;

    req->affectModLocks = req->modLocks = 0;
    req->lockGroup = False;
    req->groupLock = 0;

    UnlockDisplay(dpy);
    SyncHandle();
    return True;
}

unsigned
XkbSetXlibControls(Display *dpy, unsigned affect, unsigned values)
{
    if (!dpy->xkb_info)
        XkbUseExtension(dpy, NULL, NULL);
    if (!dpy->xkb_info)
        return 0;
    affect &= XkbLC_AllControls;
    dpy->xkb_info->xlib_ctrls &= ~affect;
    dpy->xkb_info->xlib_ctrls |= (affect & values);
    return dpy->xkb_info->xlib_ctrls;
}

unsigned
XkbGetXlibControls(Display *dpy)
{
    if (!dpy->xkb_info)
        XkbUseExtension(dpy, NULL, NULL);
    if (!dpy->xkb_info)
        return 0;
    return dpy->xkb_info->xlib_ctrls;
}

unsigned int
XkbXlibControlsImplemented(void)
{
#ifdef __sgi
    return XkbLC_AllControls;
#else
    return XkbLC_AllControls & ~XkbLC_AllComposeControls;
#endif
}

Bool
XkbSetDebuggingFlags(Display *dpy,
                     unsigned int mask,
                     unsigned int flags,
                     char *msg,
                     unsigned int ctrls_mask,
                     unsigned int ctrls,
                     unsigned int *rtrn_flags,
                     unsigned int *rtrn_ctrls)
{
    register xkbSetDebuggingFlagsReq *req;
    xkbSetDebuggingFlagsReply rep;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbSetDebuggingFlags, req);
    req->reqType        = xkbi->codes->major_opcode;
    req->xkbReqType     = X_kbSetDebuggingFlags;
    req->affectFlags    = mask;
    req->flags          = flags;
    req->affectCtrls    = ctrls_mask;
    req->ctrls          = ctrls;

    if (msg) {
        char *out;

        req->msgLength = (unsigned short) strlen(msg) + 1;
        req->length += (req->msgLength + (unsigned) 3) >> 2;
        BufAlloc(char *, out, ((req->msgLength + (unsigned) 3) / 4) * 4);
        memcpy(out, msg, req->msgLength);
    }
    else
        req->msgLength = 0;
    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay(dpy);
        SyncHandle();
        return False;
    }
    if (rtrn_flags)
        *rtrn_flags = rep.currentFlags;
    if (rtrn_ctrls)
        *rtrn_ctrls = rep.currentCtrls;
    UnlockDisplay(dpy);
    SyncHandle();
    return True;
}

Bool
XkbComputeEffectiveMap(XkbDescPtr xkb,
                       XkbKeyTypePtr type,
                       unsigned char *map_rtrn)
{
    register int i;
    unsigned tmp;
    XkbKTMapEntryPtr entry = NULL;

    if ((!xkb) || (!type) || (!xkb->server))
        return False;

    if (type->mods.vmods != 0) {
        if (!XkbVirtualModsToReal(xkb, type->mods.vmods, &tmp))
            return False;

        type->mods.mask = tmp | type->mods.real_mods;
        entry = type->map;
        for (i = 0; i < type->map_count; i++, entry++) {
            tmp = 0;
            if (entry->mods.vmods != 0) {
                if (!XkbVirtualModsToReal(xkb, entry->mods.vmods, &tmp))
                    return False;
                if (tmp == 0) {
                    entry->active = False;
                    continue;
                }
            }
            entry->active = True;
            entry->mods.mask = (entry->mods.real_mods | tmp) & type->mods.mask;
        }
    }
    else {
        type->mods.mask = type->mods.real_mods;
    }
    if (map_rtrn != NULL) {
        bzero(map_rtrn, type->mods.mask + 1);
        for (i = 0; i < type->map_count; i++) {
            if (entry && entry->active) {
                map_rtrn[type->map[i].mods.mask] = type->map[i].level;
            }
        }
    }
    return True;
}

Status
XkbGetState(Display *dpy, unsigned deviceSpec, XkbStatePtr rtrn)
{
    register xkbGetStateReq *req;
    xkbGetStateReply rep;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbGetState, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbGetState;
    req->deviceSpec = deviceSpec;
    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay(dpy);
        SyncHandle();
        return BadImplementation;
    }
    rtrn->mods                  = rep.mods;
    rtrn->base_mods             = rep.baseMods;
    rtrn->latched_mods          = rep.latchedMods;
    rtrn->locked_mods           = rep.lockedMods;
    rtrn->group                 = rep.group;
    rtrn->base_group            = rep.baseGroup;
    rtrn->latched_group         = rep.latchedGroup;
    rtrn->locked_group          = rep.lockedGroup;
    rtrn->compat_state          = rep.compatState;
    rtrn->grab_mods             = rep.grabMods;
    rtrn->compat_grab_mods      = rep.compatGrabMods;
    rtrn->lookup_mods           = rep.lookupMods;
    rtrn->compat_lookup_mods    = rep.compatLookupMods;
    rtrn->ptr_buttons           = rep.ptrBtnState;
    UnlockDisplay(dpy);
    SyncHandle();
    return Success;
}

Bool
XkbSetDetectableAutoRepeat(Display *dpy, Bool detectable, Bool *supported)
{
    register xkbPerClientFlagsReq *req;
    xkbPerClientFlagsReply rep;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbPerClientFlags, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbPerClientFlags;
    req->deviceSpec = XkbUseCoreKbd;
    req->change = XkbPCF_DetectableAutoRepeatMask;
    if (detectable)
        req->value = XkbPCF_DetectableAutoRepeatMask;
    else
        req->value = 0;
    req->ctrlsToChange = req->autoCtrls = req->autoCtrlValues = 0;
    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay(dpy);
        SyncHandle();
        return False;
    }
    UnlockDisplay(dpy);
    SyncHandle();
    if (supported != NULL)
        *supported = ((rep.supported & XkbPCF_DetectableAutoRepeatMask) != 0);
    return ((rep.value & XkbPCF_DetectableAutoRepeatMask) != 0);
}

Bool
XkbGetDetectableAutoRepeat(Display *dpy, Bool *supported)
{
    register xkbPerClientFlagsReq *req;
    xkbPerClientFlagsReply rep;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbPerClientFlags, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbPerClientFlags;
    req->deviceSpec = XkbUseCoreKbd;
    req->change = 0;
    req->value = 0;
    req->ctrlsToChange = req->autoCtrls = req->autoCtrlValues = 0;
    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay(dpy);
        SyncHandle();
        return False;
    }
    UnlockDisplay(dpy);
    SyncHandle();
    if (supported != NULL)
        *supported = ((rep.supported & XkbPCF_DetectableAutoRepeatMask) != 0);
    return ((rep.value & XkbPCF_DetectableAutoRepeatMask) != 0);
}

Bool
XkbSetAutoResetControls(Display *dpy,
                        unsigned changes,
                        unsigned *auto_ctrls,
                        unsigned *auto_values)
{
    register xkbPerClientFlagsReq *req;
    xkbPerClientFlagsReply rep;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbPerClientFlags, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbPerClientFlags;
    req->change = XkbPCF_AutoResetControlsMask;
    req->deviceSpec = XkbUseCoreKbd;
    req->value = XkbPCF_AutoResetControlsMask;
    req->ctrlsToChange = changes;
    req->autoCtrls = *auto_ctrls;
    req->autoCtrlValues = *auto_values;
    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay(dpy);
        SyncHandle();
        return False;
    }
    UnlockDisplay(dpy);
    SyncHandle();
    *auto_ctrls = rep.autoCtrls;
    *auto_values = rep.autoCtrlValues;
    return ((rep.value & XkbPCF_AutoResetControlsMask) != 0);
}

Bool
XkbGetAutoResetControls(Display *dpy,
                        unsigned *auto_ctrls,
                        unsigned *auto_ctrl_values)
{
    register xkbPerClientFlagsReq *req;
    xkbPerClientFlagsReply rep;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbPerClientFlags, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbPerClientFlags;
    req->deviceSpec = XkbUseCoreKbd;
    req->change = 0;
    req->value = 0;
    req->ctrlsToChange = req->autoCtrls = req->autoCtrlValues = 0;
    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay(dpy);
        SyncHandle();
        return False;
    }
    UnlockDisplay(dpy);
    SyncHandle();
    if (auto_ctrls)
        *auto_ctrls = rep.autoCtrls;
    if (auto_ctrl_values)
        *auto_ctrl_values = rep.autoCtrlValues;
    return ((rep.value & XkbPCF_AutoResetControlsMask) != 0);
}

Bool
XkbSetPerClientControls(Display *dpy, unsigned change, unsigned *values)
{
    register xkbPerClientFlagsReq *req;
    xkbPerClientFlagsReply rep;
    XkbInfoPtr xkbi;
    unsigned value_hold = *values;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)) ||
        (change & ~(XkbPCF_GrabsUseXKBStateMask |
                    XkbPCF_LookupStateWhenGrabbed |
                    XkbPCF_SendEventUsesXKBState)))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbPerClientFlags, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbPerClientFlags;
    req->change = change;
    req->deviceSpec = XkbUseCoreKbd;
    req->value = *values;
    req->ctrlsToChange = req->autoCtrls = req->autoCtrlValues = 0;
    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay(dpy);
        SyncHandle();
        return False;
    }
    UnlockDisplay(dpy);
    SyncHandle();
    *values = rep.value;
    return ((rep.value & value_hold) != 0);
}

Bool
XkbGetPerClientControls(Display *dpy, unsigned *ctrls)
{
    register xkbPerClientFlagsReq *req;
    xkbPerClientFlagsReply rep;
    XkbInfoPtr xkbi;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)) ||
        (ctrls == NULL))
        return False;
    LockDisplay(dpy);
    xkbi = dpy->xkb_info;
    GetReq(kbPerClientFlags, req);
    req->reqType = xkbi->codes->major_opcode;
    req->xkbReqType = X_kbPerClientFlags;
    req->deviceSpec = XkbUseCoreKbd;
    req->change = 0;
    req->value = 0;
    req->ctrlsToChange = req->autoCtrls = req->autoCtrlValues = 0;
    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay(dpy);
        SyncHandle();
        return False;
    }
    UnlockDisplay(dpy);
    SyncHandle();
    *ctrls = (rep.value & (XkbPCF_GrabsUseXKBStateMask |
                           XkbPCF_LookupStateWhenGrabbed |
                           XkbPCF_SendEventUsesXKBState));
    return (True);
}

Display *
XkbOpenDisplay(char *name,
               int *ev_rtrn,
               int *err_rtrn,
               int *major_rtrn,
               int *minor_rtrn,
               int *reason)
{
    Display *dpy;
    int major_num, minor_num;

    if ((major_rtrn != NULL) && (minor_rtrn != NULL)) {
        if (!XkbLibraryVersion(major_rtrn, minor_rtrn)) {
            if (reason != NULL)
                *reason = XkbOD_BadLibraryVersion;
            return NULL;
        }
    }
    else {
        major_num = XkbMajorVersion;
        minor_num = XkbMinorVersion;
        major_rtrn = &major_num;
        minor_rtrn = &minor_num;
    }
    dpy = XOpenDisplay(name);
    if (dpy == NULL) {
        if (reason != NULL)
            *reason = XkbOD_ConnectionRefused;
        return NULL;
    }
    if (!XkbQueryExtension(dpy, NULL, ev_rtrn, err_rtrn,
                           major_rtrn, minor_rtrn)) {
        if (reason != NULL) {
            if ((*major_rtrn != 0) || (*minor_rtrn != 0))
                *reason = XkbOD_BadServerVersion;
            else
                *reason = XkbOD_NonXkbServer;
        }
        XCloseDisplay(dpy);
        return NULL;
    }
    if (reason != NULL)
        *reason = XkbOD_Success;
    return dpy;
}

void
XkbSetAtomFuncs(XkbInternAtomFunc getAtom, XkbGetAtomNameFunc getName)
{
    _XkbInternAtomFunc = (getAtom ? getAtom : XInternAtom);
    _XkbGetAtomNameFunc = (getName ? getName : XGetAtomName);
    return;
}
@


1.5
log
@Update to libX11 1.6.2. No API change.
@
text
@a171 3
        req->affectWhich = 0;
        req->selectAll = 0;
        req->clear = 0;
d699 1
a699 3
        (*ctrls & ~(XkbPCF_GrabsUseXKBStateMask |
                    XkbPCF_LookupStateWhenGrabbed |
                    XkbPCF_SendEventUsesXKBState)))
d717 3
a719 4
    if (ctrls)
        *ctrls = (rep.value & (XkbPCF_GrabsUseXKBStateMask |
                               XkbPCF_LookupStateWhenGrabbed |
                               XkbPCF_SendEventUsesXKBState));
@


1.4
log
@Update to libx11 1.4.2. Tested by ajacoutot@@, jasper@@ krw@@, landry@@,
shadchin@@ on various architectures.
Bump major.
@
text
@d35 2
a36 2
XkbInternAtomFunc	_XkbInternAtomFunc= XInternAtom;
XkbGetAtomNameFunc	_XkbGetAtomNameFunc= XGetAtomName;
d39 6
a44 6
XkbQueryExtension(	Display *dpy,
			int *	opcodeReturn,
			int *	eventBaseReturn,
			int *	errorBaseReturn,
			int *	majorReturn,
			int *	minorReturn)
d46 2
a47 2
    if (!XkbUseExtension(dpy,majorReturn,minorReturn))
	return False;
d49 1
a49 1
	*opcodeReturn = dpy->xkb_info->codes->major_opcode;
d51 1
a51 1
	*eventBaseReturn = dpy->xkb_info->codes->first_event;
d53 1
a53 1
	*errorBaseReturn = dpy->xkb_info->codes->first_error;
d55 1
a55 1
	*majorReturn = dpy->xkb_info->srv_major;
d57 1
a57 1
	*minorReturn = dpy->xkb_info->srv_minor;
d62 1
a62 1
XkbLibraryVersion(int *libMajorRtrn,int *libMinorRtrn)
d64 1
a64 1
int supported;
d67 6
a72 4
	/* version 0.65 is (almost) compatible with 1.00 */
	if ((XkbMajorVersion==1)&&(((*libMajorRtrn)==0)&&((*libMinorRtrn)==65)))
	     supported= True;
	else supported= False;
d75 1
a75 1
	supported = True;
d84 4
a87 4
XkbSelectEvents(	Display *	dpy,
			unsigned int 	deviceSpec,
			unsigned int 	affect,
			unsigned int 	selectAll)
d93 2
a94 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
d97 2
a98 2
    xkbi->selected_events&= ~affect;
    xkbi->selected_events|= (affect&selectAll);
d103 27
a129 24
    req->affectWhich = (CARD16)affect;
    req->clear = affect&(~selectAll);
    req->selectAll = affect&selectAll;
    if (affect&XkbMapNotifyMask) {
	req->affectMap= XkbAllMapComponentsMask;
	/* the implicit support needs the client info */
	/* even if the client itself doesn't want it */
	if (selectAll&XkbMapNotifyMask)
	     req->map= XkbAllMapEventsMask;
	else req->map= XkbAllClientInfoMask;
	if (selectAll&XkbMapNotifyMask)
	     xkbi->selected_map_details= XkbAllMapEventsMask;
	else xkbi->selected_map_details= 0;
    }
    if (affect&XkbNewKeyboardNotifyMask) {
	if (selectAll&XkbNewKeyboardNotifyMask)
	     xkbi->selected_nkn_details= XkbAllNewKeyboardEventsMask;
	else xkbi->selected_nkn_details= 0;
	if (!(xkbi->xlib_ctrls&XkbLC_IgnoreNewKeyboards)) {
	    /* we want it, even if the client doesn't.  Don't mess */
	    /* around with details -- ask for all of them and throw */
	    /* away the ones we don't need */
	    req->selectAll|= XkbNewKeyboardNotifyMask;
	}
d137 5
a141 5
XkbSelectEventDetails(	Display *		dpy,
			unsigned 		deviceSpec,
			unsigned 		eventType,
			unsigned long int 	affect,
			unsigned long int 	details)
d144 3
a146 3
    XkbInfoPtr xkbi;
    int	     size = 0;
    char     *out;
d148 3
a150 3
	CARD8	*c8;
	CARD16	*c16;
	CARD32	*c32;
d154 2
a155 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
d158 4
a161 2
    if (affect&details)	xkbi->selected_events|= (1<<eventType);
    else		xkbi->selected_events&= ~(1<<eventType);
d166 14
a179 14
    req->clear= req->selectAll= 0;
    if (eventType==XkbMapNotify) {
	/* we need all of the client info, even if the application */
	/* doesn't.   Make sure that we always request the stuff */
	/* that the implicit support needs, and just filter out anything */
	/* the client doesn't want later */
	req->affectWhich = 0;
	req->selectAll = 0;
	req->clear = 0;
	req->affectMap = (CARD16)affect;
	req->map = (CARD16)details|(XkbAllClientInfoMask&affect);
	req->affectWhich = XkbMapNotifyMask;
	xkbi->selected_map_details&= ~affect;
	xkbi->selected_map_details|=  (details&affect);
d182 43
a224 42
	req->affectMap = req->map = 0;
	req->affectWhich= (1<<eventType);
	switch (eventType) {
	    case XkbNewKeyboardNotify:
		xkbi->selected_nkn_details&= ~affect;
		xkbi->selected_nkn_details|= (details&affect);
		if (!(xkbi->xlib_ctrls&XkbLC_IgnoreNewKeyboards))
		    details= (affect&XkbAllNewKeyboardEventsMask);
	    case XkbStateNotify:
	    case XkbNamesNotify:
	    case XkbAccessXNotify:
	    case XkbExtensionDeviceNotify:
		size= 2;
		req->length+= 1;
		break;
	    case XkbControlsNotify:
	    case XkbIndicatorStateNotify:
	    case XkbIndicatorMapNotify:
		size= 4;
		req->length+= 2;
		break;
	    case XkbBellNotify:
	    case XkbActionMessage:
	    case XkbCompatMapNotify:
		size= 1;
		req->length+= 1;
		break;
	}
	BufAlloc(char *,out,(((size*2)+(unsigned)3)/4)*4);
	u.c8= (CARD8 *)out;
	if (size==2) {
	    u.c16[0]= (CARD16)affect;
	    u.c16[1]= (CARD16)details;
	}
	else if (size==4) {
	    u.c32[0]= (CARD32)affect;
	    u.c32[1]= (CARD32)details;
	}
	else {
	    u.c8[0]= (CARD8)affect;
	    u.c8[1]= (CARD8)details;
	}
d232 4
a235 4
XkbLockModifiers(	Display *	dpy,
			unsigned int 	deviceSpec,
			unsigned int 	affect,
			unsigned int 	values)
d241 2
a242 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
d249 1
a249 1
    req->affectModLocks= affect;
d263 4
a266 4
XkbLatchModifiers(	Display *	dpy,
			unsigned int	deviceSpec,
			unsigned int	affect,
			unsigned int	values)
d272 2
a273 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
d281 1
a281 1
    req->affectModLatches= affect;
d296 1
a296 1
XkbLockGroup(Display *dpy,unsigned int deviceSpec,unsigned int group)
d302 2
a303 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
d310 1
a310 1
    req->affectModLocks= 0;
d324 1
a324 1
XkbLatchGroup(Display *dpy,unsigned int deviceSpec,unsigned int group)
d330 2
a331 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
d339 1
a339 1
    req->affectModLatches= 0;
d354 1
a354 1
XkbSetXlibControls(Display *dpy,unsigned affect,unsigned values)
d357 1
a357 1
	XkbUseExtension(dpy,NULL,NULL);
d359 4
a362 4
	return 0;
    affect&= XkbLC_AllControls;
    dpy->xkb_info->xlib_ctrls&= ~affect;
    dpy->xkb_info->xlib_ctrls|= (affect&values);
d370 1
a370 1
	XkbUseExtension(dpy,NULL,NULL);
d372 1
a372 1
	return 0;
d382 1
a382 1
    return XkbLC_AllControls&~XkbLC_AllComposeControls;
d387 8
a394 8
XkbSetDebuggingFlags(	Display *	dpy,
			unsigned int 	mask,
			unsigned int 	flags,
			char *		msg,
			unsigned int	ctrls_mask,
			unsigned int	ctrls,
			unsigned int *	rtrn_flags,
			unsigned int *	rtrn_ctrls)
d401 2
a402 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
d406 6
a411 6
    req->reqType= 	xkbi->codes->major_opcode;
    req->xkbReqType=	X_kbSetDebuggingFlags;
    req->affectFlags=	mask;
    req->flags= 	flags;
    req->affectCtrls=	ctrls_mask;
    req->ctrls= 	ctrls;
d414 13
a426 11
	char *out;
	req->msgLength= (unsigned short)strlen(msg)+1;
	req->length+= (req->msgLength+(unsigned)3)>>2;
	BufAlloc(char *,out,((req->msgLength+(unsigned)3)/4)*4);
	memcpy(out,msg,req->msgLength);
    }
    else req->msgLength= 0;
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	UnlockDisplay(dpy);
	SyncHandle();
	return False;
d429 1
a429 1
	*rtrn_flags= rep.currentFlags;
d431 1
a431 1
	*rtrn_ctrls= rep.currentCtrls;
d438 30
a467 30
XkbComputeEffectiveMap(	XkbDescPtr 	xkb,
			XkbKeyTypePtr 	type,
			unsigned char *	map_rtrn)
{
register int 		i;
unsigned     		tmp;
XkbKTMapEntryPtr	entry = NULL;

    if ((!xkb)||(!type)||(!xkb->server))
	return False;

    if (type->mods.vmods!=0) {
	if (!XkbVirtualModsToReal(xkb,type->mods.vmods,&tmp))
	    return False;

	type->mods.mask= tmp|type->mods.real_mods;
	entry= type->map;
	for (i=0;i<type->map_count;i++,entry++) {
	    tmp= 0;
	    if (entry->mods.vmods!=0) {
		if (!XkbVirtualModsToReal(xkb,entry->mods.vmods,&tmp))
		    return False;
		if (tmp==0) {
		    entry->active= False;
		    continue;
		}
	    }
	    entry->active= True;
	    entry->mods.mask= (entry->mods.real_mods|tmp)&type->mods.mask;
	}
d470 1
a470 1
	type->mods.mask= type->mods.real_mods;
d472 7
a478 7
    if (map_rtrn!=NULL) {
	bzero(map_rtrn,type->mods.mask+1);
	for (i=0;i<type->map_count;i++) {
	    if (entry && entry->active) {
		map_rtrn[type->map[i].mods.mask]= type->map[i].level;
	    }
	}
d484 1
a484 1
XkbGetState(Display *dpy,unsigned deviceSpec,XkbStatePtr rtrn)
d486 1
a486 1
    register xkbGetStateReq	*req;
d491 2
a492 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
d499 19
a517 19
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	UnlockDisplay(dpy);
	SyncHandle();
	return BadImplementation;
    }
    rtrn->mods= 		rep.mods;
    rtrn->base_mods= 		rep.baseMods;
    rtrn->latched_mods= 	rep.latchedMods;
    rtrn->locked_mods= 		rep.lockedMods;
    rtrn->group= 		rep.group;
    rtrn->base_group= 		rep.baseGroup;
    rtrn->latched_group= 	rep.latchedGroup;
    rtrn->locked_group= 	rep.lockedGroup;
    rtrn->compat_state= 	rep.compatState;
    rtrn->grab_mods=		rep.grabMods;
    rtrn->compat_grab_mods=	rep.compatGrabMods;
    rtrn->lookup_mods=		rep.lookupMods;
    rtrn->compat_lookup_mods=	rep.compatLookupMods;
    rtrn->ptr_buttons=		rep.ptrBtnState;
d524 1
a524 1
XkbSetDetectableAutoRepeat(Display *dpy,Bool detectable,Bool *supported)
d526 3
a528 3
register xkbPerClientFlagsReq *	req;
xkbPerClientFlagsReply 		rep;
XkbInfoPtr 			xkbi;
d531 2
a532 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
d541 8
a548 7
	 req->value = XkbPCF_DetectableAutoRepeatMask;
    else req->value = 0;
    req->ctrlsToChange = req->autoCtrls= req->autoCtrlValues= 0;
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	UnlockDisplay(dpy);
	SyncHandle();
	return False;
d552 3
a554 3
    if (supported!=NULL)
	*supported= ((rep.supported&XkbPCF_DetectableAutoRepeatMask)!=0);
    return ((rep.value&XkbPCF_DetectableAutoRepeatMask)!=0);
d558 1
a558 1
XkbGetDetectableAutoRepeat(Display *dpy,Bool *supported)
d560 3
a562 3
register xkbPerClientFlagsReq *	req;
xkbPerClientFlagsReply 		rep;
XkbInfoPtr 			xkbi;
d565 2
a566 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
d575 5
a579 5
    req->ctrlsToChange = req->autoCtrls= req->autoCtrlValues= 0;
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	UnlockDisplay(dpy);
	SyncHandle();
	return False;
d583 3
a585 3
    if (supported!=NULL)
	*supported= ((rep.supported&XkbPCF_DetectableAutoRepeatMask)!=0);
    return ((rep.value&XkbPCF_DetectableAutoRepeatMask)!=0);
d589 4
a592 4
XkbSetAutoResetControls(	Display *	dpy,
				unsigned 	changes,
				unsigned *	auto_ctrls,
				unsigned *	auto_values)
d594 3
a596 3
register xkbPerClientFlagsReq *	req;
xkbPerClientFlagsReply 		rep;
XkbInfoPtr 			xkbi;
d599 2
a600 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
d609 7
a615 7
    req->ctrlsToChange= changes;
    req->autoCtrls= *auto_ctrls;
    req->autoCtrlValues= *auto_values;
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	UnlockDisplay(dpy);
	SyncHandle();
	return False;
d619 3
a621 3
    *auto_ctrls= rep.autoCtrls;
    *auto_values= rep.autoCtrlValues;
    return ((rep.value&XkbPCF_AutoResetControlsMask)!=0);
d625 3
a627 3
XkbGetAutoResetControls(	Display *	dpy,
				unsigned *	auto_ctrls,
				unsigned *	auto_ctrl_values)
d629 3
a631 3
register xkbPerClientFlagsReq *	req;
xkbPerClientFlagsReply 		rep;
XkbInfoPtr 			xkbi;
d634 2
a635 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return False;
d644 5
a648 5
    req->ctrlsToChange = req->autoCtrls= req->autoCtrlValues= 0;
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	UnlockDisplay(dpy);
	SyncHandle();
	return False;
d653 1
a653 1
	*auto_ctrls= rep.autoCtrls;
d655 2
a656 2
	*auto_ctrl_values= rep.autoCtrlValues;
    return ((rep.value&XkbPCF_AutoResetControlsMask)!=0);
d660 1
a660 3
XkbSetPerClientControls(	Display *	dpy,
				unsigned 	change,
				unsigned *	values)
d662 4
a665 4
register xkbPerClientFlagsReq *	req;
xkbPerClientFlagsReply 		rep;
XkbInfoPtr 			xkbi;
unsigned			value_hold = *values;
d668 5
a672 3
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)) ||
	(change & ~(XkbPCF_GrabsUseXKBStateMask|XkbPCF_LookupStateWhenGrabbed|XkbPCF_SendEventUsesXKBState)))
	return False;
d681 5
a685 5
    req->ctrlsToChange = req->autoCtrls = req->autoCtrlValues= 0;
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	UnlockDisplay(dpy);
	SyncHandle();
	return False;
d690 1
a690 1
    return ((rep.value&value_hold)!=0);
d694 1
a694 2
XkbGetPerClientControls(	Display *	dpy,
				unsigned *	ctrls)
d696 3
a698 3
register xkbPerClientFlagsReq *	req;
xkbPerClientFlagsReply 		rep;
XkbInfoPtr 			xkbi;
d701 5
a705 3
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)) ||
	(*ctrls & ~(XkbPCF_GrabsUseXKBStateMask|XkbPCF_LookupStateWhenGrabbed|XkbPCF_SendEventUsesXKBState)))
	return False;
d714 5
a718 5
    req->ctrlsToChange = req->autoCtrls= req->autoCtrlValues= 0;
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	UnlockDisplay(dpy);
	SyncHandle();
	return False;
d723 3
a725 3
	*ctrls= (rep.value & (XkbPCF_GrabsUseXKBStateMask |
		 XkbPCF_LookupStateWhenGrabbed |
		 XkbPCF_SendEventUsesXKBState));
d730 16
a745 16
XkbOpenDisplay(	char *	name,
		int *	ev_rtrn,
		int *	err_rtrn,
		int *	major_rtrn,
		int *	minor_rtrn,
		int *	reason)
{
    Display* dpy;
    int	 major_num,minor_num;

    if ((major_rtrn!=NULL) && (minor_rtrn!=NULL)) {
	if (!XkbLibraryVersion(major_rtrn,minor_rtrn)) {
	    if (reason!=NULL)
		*reason= XkbOD_BadLibraryVersion;
	    return NULL;
	}
d748 21
a768 19
	major_num= XkbMajorVersion;
	minor_num= XkbMinorVersion;
	major_rtrn= &major_num;
	minor_rtrn= &minor_num;
    }
    dpy= XOpenDisplay(name);
    if (dpy==NULL) {
	if (reason!=NULL)
	    *reason= XkbOD_ConnectionRefused;
	return NULL;
    }
    if (!XkbQueryExtension(dpy,NULL,ev_rtrn,err_rtrn,major_rtrn,minor_rtrn)) {
	if (reason!=NULL) {
	    if ((*major_rtrn!=0)||(*minor_rtrn!=0))
		 *reason= XkbOD_BadServerVersion;
	    else *reason= XkbOD_NonXkbServer;
	}
	XCloseDisplay(dpy);
	return NULL;
d770 2
a771 2
    if (reason!=NULL)
	*reason= XkbOD_Success;
d776 1
a776 1
XkbSetAtomFuncs(XkbInternAtomFunc getAtom,XkbGetAtomNameFunc getName)
d778 2
a779 2
    _XkbInternAtomFunc= (getAtom?getAtom:XInternAtom);
    _XkbGetAtomNameFunc= (getName?getName:XGetAtomName);
@


1.3
log
@Update to libX11 1.3.3. Tested on a bulk ports build by naddy@@.
@
text
@a30 2
#define NEED_REPLIES
#define NEED_EVENTS
d465 1
a465 1
	    if (entry->active) {
@


1.2
log
@update to libX11 1.2.1
@
text
@a0 1
/* $Xorg: XKB.c,v 1.3 2000/08/17 19:44:59 cpqbld Exp $ */
a25 1
/* $XFree86: xc/lib/X11/XKB.c,v 1.9 2003/04/17 02:06:31 dawes Exp $ */
@


1.1
log
@Initial revision
@
text
@d10 2
a11 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d13 1
a13 1
Silicon Graphics makes no representation about the suitability 
d17 2
a18 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d20 3
a22 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d42 1
a42 1
Bool 
d65 1
a65 1
Bool 
d76 1
a76 1
    else { 
d120 1
a120 1
	if (selectAll&XkbNewKeyboardNotifyMask) 
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
