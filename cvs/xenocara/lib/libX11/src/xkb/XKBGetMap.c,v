head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.12
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.10
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.4.0.8
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_1_3:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	v1_0_99_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.09.28.17.03.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.05.31.21.17.14;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2013.05.23.22.42.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.30.19.19.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.18.19.37.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.12.59.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.16.37.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.16.37.33;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to libX11 1.6.2. No API change.
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#define	NEED_MAP_READERS
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "Xlibint.h"
#include <X11/extensions/XKBproto.h>
#include "XKBlibint.h"

static Status
_XkbReadKeyTypes(XkbReadBufferPtr buf, XkbDescPtr xkb, xkbGetMapReply *rep)
{
    int i, n, lastMapCount;
    XkbKeyTypePtr type;

    if (rep->nTypes > 0) {
        n = rep->firstType + rep->nTypes;
        if (xkb->map->num_types >= n)
            n = xkb->map->num_types;
        else if (XkbAllocClientMap(xkb, XkbKeyTypesMask, n) != Success)
            return BadAlloc;

        type = &xkb->map->types[rep->firstType];
        for (i = 0; i < (int) rep->nTypes; i++, type++) {
            xkbKeyTypeWireDesc *desc;
            register int ndx;

            ndx = i + rep->firstType;
            if (ndx >= xkb->map->num_types)
                xkb->map->num_types = ndx + 1;

            desc = (xkbKeyTypeWireDesc *)
                _XkbGetReadBufferPtr(buf, SIZEOF(xkbKeyTypeWireDesc));
            if (desc == NULL)
                return BadLength;

            lastMapCount = type->map_count;
            if (desc->nMapEntries > 0) {
                if ((type->map == NULL) ||
                    (desc->nMapEntries > type->map_count)) {
                    XkbKTMapEntryRec *prev_map = type->map;

                    type->map = _XkbTypedRealloc(type->map, desc->nMapEntries,
                                                 XkbKTMapEntryRec);
                    if (type->map == NULL) {
                        _XkbFree(prev_map);
                        return BadAlloc;
                    }
                }
            }
            else if (type->map != NULL) {
                Xfree(type->map);
                type->map_count = 0;
                type->map = NULL;
            }

            if (desc->preserve && (desc->nMapEntries > 0)) {
                if ((!type->preserve) || (desc->nMapEntries > lastMapCount)) {
                    XkbModsRec *prev_preserve = type->preserve;

                    type->preserve = _XkbTypedRealloc(type->preserve,
                                                      desc->nMapEntries,
                                                      XkbModsRec);
                    if (type->preserve == NULL) {
                        _XkbFree(prev_preserve);
                        return BadAlloc;
                    }
                }
            }
            else if (type->preserve != NULL) {
                Xfree(type->preserve);
                type->preserve = NULL;
            }

            type->mods.mask = desc->mask;
            type->mods.real_mods = desc->realMods;
            type->mods.vmods = desc->virtualMods;
            type->num_levels = desc->numLevels;
            type->map_count = desc->nMapEntries;
            if (desc->nMapEntries > 0) {
                register xkbKTMapEntryWireDesc *wire;
                register XkbKTMapEntryPtr entry;
                register int size;

                size = type->map_count * SIZEOF(xkbKTMapEntryWireDesc);
                wire =
                    (xkbKTMapEntryWireDesc *) _XkbGetReadBufferPtr(buf, size);
                if (wire == NULL)
                    return BadLength;
                entry = type->map;
                for (n = 0; n < type->map_count; n++, wire++, entry++) {
                    entry->active = wire->active;
                    entry->level = wire->level;
                    entry->mods.mask = wire->mask;
                    entry->mods.real_mods = wire->realMods;
                    entry->mods.vmods = wire->virtualMods;
                }

                if (desc->preserve) {
                    register xkbModsWireDesc *pwire;
                    register XkbModsPtr preserve;
                    register int sz;

                    sz = desc->nMapEntries * SIZEOF(xkbModsWireDesc);
                    pwire = (xkbModsWireDesc *) _XkbGetReadBufferPtr(buf, sz);
                    if (pwire == NULL)
                        return BadLength;
                    preserve = type->preserve;
                    for (n = 0; n < desc->nMapEntries; n++, pwire++, preserve++) {
                        preserve->mask = pwire->mask;
                        preserve->vmods = pwire->virtualMods;
                        preserve->real_mods = pwire->realMods;
                    }
                }
            }
        }
    }
    return Success;
}

static Status
_XkbReadKeySyms(XkbReadBufferPtr buf, XkbDescPtr xkb, xkbGetMapReply *rep)
{
    register int i;
    XkbClientMapPtr map;
    int size = xkb->max_key_code + 1;

    if (((unsigned short) rep->firstKeySym + rep->nKeySyms) > size)
        return BadLength;

    map = xkb->map;
    if (map->key_sym_map == NULL) {
        register int offset;
        XkbSymMapPtr oldMap;
        xkbSymMapWireDesc *newMap;

        map->key_sym_map = _XkbTypedCalloc(size, XkbSymMapRec);
        if (map->key_sym_map == NULL)
            return BadAlloc;
        if (map->syms == NULL) {
            int sz;

            sz = (rep->totalSyms * 12) / 10;
            sz = ((sz + (unsigned) 128) / 128) * 128;
            map->syms = _XkbTypedCalloc(sz, KeySym);
            if (map->syms == NULL)
                return BadAlloc;
            map->size_syms = sz;
        }
        offset = 1;
        oldMap = &map->key_sym_map[rep->firstKeySym];
        for (i = 0; i < (int) rep->nKeySyms; i++, oldMap++) {
            newMap = (xkbSymMapWireDesc *)
                _XkbGetReadBufferPtr(buf, SIZEOF(xkbSymMapWireDesc));
            if (newMap == NULL)
                return BadLength;
            oldMap->kt_index[0] = newMap->ktIndex[0];
            oldMap->kt_index[1] = newMap->ktIndex[1];
            oldMap->kt_index[2] = newMap->ktIndex[2];
            oldMap->kt_index[3] = newMap->ktIndex[3];
            oldMap->group_info = newMap->groupInfo;
            oldMap->width = newMap->width;
            oldMap->offset = offset;
            if (offset + newMap->nSyms >= map->size_syms) {
                register int sz;
                KeySym *prev_syms = map->syms;

                sz = map->size_syms + 128;
                map->syms = _XkbTypedRealloc(map->syms, sz, KeySym);
                if (map->syms == NULL) {
                    _XkbFree(prev_syms);
                    map->size_syms = 0;
                    return BadAlloc;
                }
                map->size_syms = sz;
            }
            if (newMap->nSyms > 0) {
                _XkbReadBufferCopyKeySyms(buf, (KeySym *) &map->syms[offset],
                                          newMap->nSyms);
                offset += newMap->nSyms;
            }
            else {
                map->syms[offset] = 0;
            }
        }
        map->num_syms = offset;
    }
    else {
        XkbSymMapPtr oldMap = &map->key_sym_map[rep->firstKeySym];

        for (i = 0; i < (int) rep->nKeySyms; i++, oldMap++) {
            xkbSymMapWireDesc *newMap;
            KeySym *newSyms;
            int tmp;

            newMap = (xkbSymMapWireDesc *)
                _XkbGetReadBufferPtr(buf, SIZEOF(xkbSymMapWireDesc));
            if (newMap == NULL)
                return BadLength;

            if (newMap->nSyms > 0)
                tmp = newMap->nSyms;
            else
                tmp = 0;

            newSyms = XkbResizeKeySyms(xkb, i + rep->firstKeySym, tmp);
            if (newSyms == NULL)
                return BadAlloc;
            if (newMap->nSyms > 0)
                _XkbReadBufferCopyKeySyms(buf, newSyms, newMap->nSyms);
            else
                newSyms[0] = NoSymbol;
            oldMap->kt_index[0] = newMap->ktIndex[0];
            oldMap->kt_index[1] = newMap->ktIndex[1];
            oldMap->kt_index[2] = newMap->ktIndex[2];
            oldMap->kt_index[3] = newMap->ktIndex[3];
            oldMap->group_info = newMap->groupInfo;
            oldMap->width = newMap->width;
        }
    }
    return Success;
}

static Status
_XkbReadKeyActions(XkbReadBufferPtr buf, XkbDescPtr info, xkbGetMapReply *rep)
{
    int i;
    CARD8 numDescBuf[248];
    CARD8 *numDesc = NULL;
    register int nKeyActs;
    Status ret = Success;

    if ((nKeyActs = rep->nKeyActs) > 0) {
        XkbSymMapPtr symMap;

        if (nKeyActs < sizeof numDescBuf)
            numDesc = numDescBuf;
        else
            numDesc = Xmalloc(nKeyActs * sizeof(CARD8));

        if (!_XkbCopyFromReadBuffer(buf, (char *) numDesc, nKeyActs)) {
            ret = BadLength;
            goto done;
        }
        i = XkbPaddedSize(nKeyActs) - nKeyActs;
        if ((i > 0) && (!_XkbSkipReadBufferData(buf, i))) {
            ret = BadLength;
            goto done;
        }
        symMap = &info->map->key_sym_map[rep->firstKeyAct];
        for (i = 0; i < (int) rep->nKeyActs; i++, symMap++) {
            if (numDesc[i] == 0) {
                if ((i + rep->firstKeyAct) > (info->max_key_code + 1)) {
                    ret = BadLength;
                    goto done;
                }
                info->server->key_acts[i + rep->firstKeyAct] = 0;
            }
            else {
                XkbAction *newActs;

                /* 8/16/93 (ef) -- XXX! Verify size here (numdesc must be */
                /*                 either zero or XkbKeyNumSyms(info,key) */
                newActs = XkbResizeKeyActions(info, i + rep->firstKeyAct,
                                              numDesc[i]);
                if (newActs == NULL) {
                    ret = BadAlloc;
                    goto done;
                }
                if (!_XkbCopyFromReadBuffer(buf, (char *) newActs,
                            (int) (numDesc[i] * sizeof(XkbAction)))) {
                    ret = BadLength;
                    goto done;
                }
            }
        }
    }
 done:
    if (numDesc != NULL && numDesc != numDescBuf)
        Xfree(numDesc);
    return ret;
}

static Status
_XkbReadKeyBehaviors(XkbReadBufferPtr buf, XkbDescPtr xkb, xkbGetMapReply *rep)
{
    register int i;

    if (rep->totalKeyBehaviors > 0) {
        int size = xkb->max_key_code + 1;

        if (((int) rep->firstKeyBehavior + rep->nKeyBehaviors) > size)
            return BadLength;
        if (xkb->server->behaviors == NULL) {
            xkb->server->behaviors = _XkbTypedCalloc(size, XkbBehavior);
            if (xkb->server->behaviors == NULL)
                return BadAlloc;
        }
        else {
            bzero(&xkb->server->behaviors[rep->firstKeyBehavior],
                  (rep->nKeyBehaviors * sizeof(XkbBehavior)));
        }
        for (i = 0; i < rep->totalKeyBehaviors; i++) {
            xkbBehaviorWireDesc *wire;

            wire = (xkbBehaviorWireDesc *) _XkbGetReadBufferPtr(buf,
                                               SIZEOF(xkbBehaviorWireDesc));
            if (wire == NULL || wire->key >= size)
                return BadLength;
            xkb->server->behaviors[wire->key].type = wire->type;
            xkb->server->behaviors[wire->key].data = wire->data;
        }
    }
    return Success;
}

static Status
_XkbReadVirtualMods(XkbReadBufferPtr buf, XkbDescPtr xkb, xkbGetMapReply *rep)
{
    if (rep->virtualMods) {
        register int i, bit, nVMods;
        register char *data;

        for (i = nVMods = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
            if (rep->virtualMods & bit)
                nVMods++;
        }
        data = _XkbGetReadBufferPtr(buf, XkbPaddedSize(nVMods));
        if (data == NULL)
            return BadLength;
        for (i = 0, bit = 1; (i < XkbNumVirtualMods) && (nVMods > 0);
             i++, bit <<= 1) {
            if (rep->virtualMods & bit) {
                xkb->server->vmods[i] = *data++;
                nVMods--;
            }
        }
    }
    return Success;
}

static Status
_XkbReadExplicitComponents(XkbReadBufferPtr buf,
                           XkbDescPtr xkb,
                           xkbGetMapReply *rep)
{
    register int i;
    unsigned char *wire;

    if (rep->totalKeyExplicit > 0) {
        int size = xkb->max_key_code + 1;

        if (((int) rep->firstKeyExplicit + rep->nKeyExplicit) > size)
            return BadLength;
        if (xkb->server->explicit == NULL) {
            xkb->server->explicit = _XkbTypedCalloc(size, unsigned char);

            if (xkb->server->explicit == NULL)
                return BadAlloc;
        }
        else {
            bzero(&xkb->server->explicit[rep->firstKeyExplicit],
                  rep->nKeyExplicit);
        }
        i = XkbPaddedSize(2 * rep->totalKeyExplicit);
        wire = (unsigned char *) _XkbGetReadBufferPtr(buf, i);
        if (!wire)
            return BadLength;
        for (i = 0; i < rep->totalKeyExplicit; i++, wire += 2) {
            if (wire[0] > xkb->max_key_code || wire[1] > xkb->max_key_code)
                return BadLength;
            xkb->server->explicit[wire[0]] = wire[1];
        }
    }
    return Success;
}

static Status
_XkbReadModifierMap(XkbReadBufferPtr buf, XkbDescPtr xkb, xkbGetMapReply *rep)
{
    register int i;
    unsigned char *wire;

    if (rep->totalModMapKeys > 0) {
        if (((int) rep->firstModMapKey + rep->nModMapKeys) >
            (xkb->max_key_code + 1))
            return BadLength;
        if ((xkb->map->modmap == NULL) &&
            (XkbAllocClientMap(xkb, XkbModifierMapMask, 0) != Success)) {
            return BadAlloc;
        }
        else {
            bzero(&xkb->map->modmap[rep->firstModMapKey], rep->nModMapKeys);
        }
        i = XkbPaddedSize(2 * rep->totalModMapKeys);
        wire = (unsigned char *) _XkbGetReadBufferPtr(buf, i);
        if (!wire)
            return BadLength;
        for (i = 0; i < rep->totalModMapKeys; i++, wire += 2) {
            if (wire[0] > xkb->max_key_code || wire[1] > xkb->max_key_code)
                return BadLength;
            xkb->map->modmap[wire[0]] = wire[1];
        }
    }
    return Success;
}

static Status
_XkbReadVirtualModMap(XkbReadBufferPtr buf,
                      XkbDescPtr xkb,
                      xkbGetMapReply *rep)
{
    register int i;
    xkbVModMapWireDesc *wire;
    XkbServerMapPtr srv;

    if (rep->totalVModMapKeys > 0) {
        if (((int) rep->firstVModMapKey + rep->nVModMapKeys)
            > xkb->max_key_code + 1)
            return BadLength;
        if (((xkb->server == NULL) || (xkb->server->vmodmap == NULL)) &&
            (XkbAllocServerMap(xkb, XkbVirtualModMapMask, 0) != Success)) {
            return BadAlloc;
        }
        else {
            srv = xkb->server;
            if (rep->nVModMapKeys > rep->firstVModMapKey)
                bzero((char *) &srv->vmodmap[rep->firstVModMapKey],
                      (rep->nVModMapKeys - rep->firstVModMapKey) *
                      sizeof(unsigned short));
        }
        srv = xkb->server;
        i = rep->totalVModMapKeys * SIZEOF(xkbVModMapWireDesc);
        wire = (xkbVModMapWireDesc *) _XkbGetReadBufferPtr(buf, i);
        if (!wire)
            return BadLength;
        for (i = 0; i < rep->totalVModMapKeys; i++, wire++) {
            if ((wire->key >= xkb->min_key_code) &&
                (wire->key <= xkb->max_key_code))
                srv->vmodmap[wire->key] = wire->vmods;
        }
    }
    return Success;
}

static xkbGetMapReq *
_XkbGetGetMapReq(Display *dpy, XkbDescPtr xkb)
{
    xkbGetMapReq *req;

    GetReq(kbGetMap, req);
    req->reqType = dpy->xkb_info->codes->major_opcode;
    req->xkbReqType = X_kbGetMap;
    req->deviceSpec = xkb->device_spec;
    req->full = req->partial = 0;
    req->firstType = req->nTypes = 0;
    req->firstKeySym = req->nKeySyms = 0;
    req->firstKeyAct = req->nKeyActs = 0;
    req->firstKeyBehavior = req->nKeyBehaviors = 0;
    req->virtualMods = 0;
    req->firstKeyExplicit = req->nKeyExplicit = 0;
    req->firstModMapKey = req->nModMapKeys = 0;
    req->firstVModMapKey = req->nVModMapKeys = 0;
    return req;
}

Status
_XkbReadGetMapReply(Display *dpy,
                    xkbGetMapReply *rep,
                    XkbDescPtr xkb,
                    int *nread_rtrn)
{
    int extraData;
    unsigned mask;

    if (xkb->device_spec == XkbUseCoreKbd)
        xkb->device_spec = rep->deviceID;
    if (rep->maxKeyCode < rep->minKeyCode)
        return BadImplementation;
    xkb->min_key_code = rep->minKeyCode;
    xkb->max_key_code = rep->maxKeyCode;

    if (!xkb->map) {
        mask = rep->present & XkbAllClientInfoMask;
        if (mask && (XkbAllocClientMap(xkb, mask, rep->nTypes) != Success))
            return BadAlloc;
    }
    if (!xkb->server) {
        mask = rep->present & XkbAllServerInfoMask;
        if (mask && (XkbAllocServerMap(xkb, mask, rep->totalActs) != Success))
            return BadAlloc;
    }
    extraData = (int) (rep->length * 4);
    extraData -= (SIZEOF(xkbGetMapReply) - SIZEOF(xGenericReply));
    if (rep->length) {
        XkbReadBufferRec buf;
        int left;

        if (_XkbInitReadBuffer(dpy, &buf, extraData)) {
            Status status = Success;

            if (nread_rtrn != NULL)
                *nread_rtrn = extraData;
            if (status == Success)
                status = _XkbReadKeyTypes(&buf, xkb, rep);
            if (status == Success)
                status = _XkbReadKeySyms(&buf, xkb, rep);
            if (status == Success)
                status = _XkbReadKeyActions(&buf, xkb, rep);
            if (status == Success)
                status = _XkbReadKeyBehaviors(&buf, xkb, rep);
            if (status == Success)
                status = _XkbReadVirtualMods(&buf, xkb, rep);
            if (status == Success)
                status = _XkbReadExplicitComponents(&buf, xkb, rep);
            if (status == Success)
                status = _XkbReadModifierMap(&buf, xkb, rep);
            if (status == Success)
                status = _XkbReadVirtualModMap(&buf, xkb, rep);
            left = _XkbFreeReadBuffer(&buf);
            if (status != Success)
                return status;
            else if (left || buf.error)
                return BadLength;
        }
        else
            return BadAlloc;
    }
    return Success;
}

static Status
_XkbHandleGetMapReply(Display *dpy, XkbDescPtr xkb)
{
    xkbGetMapReply rep;

    if (!_XReply(dpy, (xReply *) &rep,
                 ((SIZEOF(xkbGetMapReply) - SIZEOF(xGenericReply)) >> 2),
                 xFalse)) {
        return BadImplementation;
    }
    return _XkbReadGetMapReply(dpy, &rep, xkb, NULL);
}

Status
XkbGetUpdatedMap(Display *dpy, unsigned which, XkbDescPtr xkb)
{
    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;
    if (which) {
        register xkbGetMapReq *req;
        Status status;

        LockDisplay(dpy);

        req = _XkbGetGetMapReq(dpy, xkb);
        req->full = which;
        status = _XkbHandleGetMapReply(dpy, xkb);

        UnlockDisplay(dpy);
        SyncHandle();
        return status;
    }
    return Success;
}

XkbDescPtr
XkbGetMap(Display *dpy, unsigned which, unsigned deviceSpec)
{
    XkbDescPtr xkb;

    xkb = _XkbTypedCalloc(1, XkbDescRec);
    if (xkb) {
        xkb->device_spec = deviceSpec;
        xkb->map = _XkbTypedCalloc(1, XkbClientMapRec);
        if ((xkb->map == NULL) ||
            ((which) && (XkbGetUpdatedMap(dpy, which, xkb) != Success))) {
            if (xkb->map) {
                Xfree(xkb->map);
                xkb->map = NULL;
            }
            Xfree(xkb);
            return NULL;
        }
        xkb->dpy = dpy;
    }
    return xkb;
}

Status
XkbGetKeyTypes(Display *dpy, unsigned first, unsigned num, XkbDescPtr xkb)
{
    register xkbGetMapReq *req;
    Status status;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;
    if ((num < 1) || (num > XkbMaxKeyTypes))
        return BadValue;

    LockDisplay(dpy);

    req = _XkbGetGetMapReq(dpy, xkb);
    req->firstType = first;
    req->nTypes = num;
    status = _XkbHandleGetMapReply(dpy, xkb);

    UnlockDisplay(dpy);
    SyncHandle();
    return status;
}

Status
XkbGetKeyActions(Display *dpy, unsigned first, unsigned num, XkbDescPtr xkb)
{
    register xkbGetMapReq *req;
    Status status;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;

    if ((num < 1) || (num > XkbMaxKeyCount))
        return BadValue;

    LockDisplay(dpy);

    req = _XkbGetGetMapReq(dpy, xkb);
    req->firstKeyAct = first;
    req->nKeyActs = num;
    status = _XkbHandleGetMapReply(dpy, xkb);

    UnlockDisplay(dpy);
    SyncHandle();
    return status;
}

Status
XkbGetKeySyms(Display *dpy, unsigned first, unsigned num, XkbDescPtr xkb)
{
    register xkbGetMapReq *req;
    Status status;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;

    if ((num < 1) || (num > XkbMaxKeyCount))
        return BadValue;

    LockDisplay(dpy);

    req = _XkbGetGetMapReq(dpy, xkb);
    req->firstKeySym = first;
    req->nKeySyms = num;
    status = _XkbHandleGetMapReply(dpy, xkb);

    UnlockDisplay(dpy);
    SyncHandle();

    return status;
}

Status
XkbGetKeyBehaviors(Display *dpy, unsigned first, unsigned num, XkbDescPtr xkb)
{
    register xkbGetMapReq *req;
    Status status;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;

    if ((num < 1) || (num > XkbMaxKeyCount))
        return BadValue;

    LockDisplay(dpy);

    req = _XkbGetGetMapReq(dpy, xkb);
    req->firstKeyBehavior = first;
    req->nKeyBehaviors = num;
    status = _XkbHandleGetMapReply(dpy, xkb);

    UnlockDisplay(dpy);
    SyncHandle();
    return status;
}

Status
XkbGetVirtualMods(Display *dpy, unsigned which, XkbDescPtr xkb)
{
    register xkbGetMapReq *req;
    Status status;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;

    LockDisplay(dpy);

    req = _XkbGetGetMapReq(dpy, xkb);
    req->virtualMods = which;
    status = _XkbHandleGetMapReply(dpy, xkb);

    UnlockDisplay(dpy);
    SyncHandle();
    return status;
}

Status
XkbGetKeyExplicitComponents(Display *dpy,
                            unsigned first,
                            unsigned num,
                            XkbDescPtr xkb)
{
    register xkbGetMapReq *req;
    Status status;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;

    if ((num < 1) || (num > XkbMaxKeyCount))
        return BadValue;

    LockDisplay(dpy);

    req = _XkbGetGetMapReq(dpy, xkb);
    req->firstKeyExplicit = first;
    req->nKeyExplicit = num;
    if ((xkb != NULL) && (xkb->server != NULL) &&
        (xkb->server->explicit != NULL)) {
        if ((num > 0) && (first >= xkb->min_key_code) &&
            (first + num <= xkb->max_key_code))
            bzero(&xkb->server->explicit[first], num);
    }
    if (xkb)
        status = _XkbHandleGetMapReply(dpy, xkb);
    else
        status = BadMatch;

    UnlockDisplay(dpy);
    SyncHandle();
    return status;
}

Status
XkbGetKeyModifierMap(Display *dpy,
                     unsigned first,
                     unsigned num,
                     XkbDescPtr xkb)
{
    register xkbGetMapReq *req;
    Status status;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;

    if ((num < 1) || (num > XkbMaxKeyCount))
        return BadValue;

    LockDisplay(dpy);

    req = _XkbGetGetMapReq(dpy, xkb);
    req->firstModMapKey = first;
    req->nModMapKeys = num;
    if ((xkb != NULL) && (xkb->map != NULL) && (xkb->map->modmap != NULL)) {
        if ((num > 0) && (first >= xkb->min_key_code) &&
            (first + num <= xkb->max_key_code))
            bzero(&xkb->map->modmap[first], num);
    }
    if (xkb)
        status = _XkbHandleGetMapReply(dpy, xkb);
    else
        status = BadMatch;

    UnlockDisplay(dpy);
    SyncHandle();
    return status;
}

Status
XkbGetKeyVirtualModMap(Display *dpy, unsigned first, unsigned num,
                       XkbDescPtr xkb)
{
    register xkbGetMapReq *req;
    Status status;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;

    if ((num < 1) || (num > XkbMaxKeyCount))
        return BadValue;

    LockDisplay(dpy);

    req = _XkbGetGetMapReq(dpy, xkb);
    req->firstVModMapKey = first;
    req->nVModMapKeys = num;
    if ((xkb != NULL) && (xkb->map != NULL) && (xkb->map->modmap != NULL)) {
        if ((num > 0) && (first >= xkb->min_key_code) &&
            (first + num <= xkb->max_key_code))
            bzero(&xkb->server->vmodmap[first], num * sizeof(unsigned short));
    }

    if (xkb)
        status = _XkbHandleGetMapReply(dpy, xkb);
    else
        status = BadMatch;

    UnlockDisplay(dpy);
    SyncHandle();
    return status;
}

Status
XkbGetMapChanges(Display *dpy, XkbDescPtr xkb, XkbMapChangesPtr changes)
{
    xkbGetMapReq *req;

    if ((dpy->flags & XlibDisplayNoXkb) ||
        (!dpy->xkb_info && !XkbUseExtension(dpy, NULL, NULL)))
        return BadAccess;
    LockDisplay(dpy);
    if (changes->changed) {
        Status status = Success;

        req = _XkbGetGetMapReq(dpy, xkb);
        req->full = 0;
        req->partial = changes->changed;
        req->firstType = changes->first_type;
        req->nTypes = changes->num_types;
        req->firstKeySym = changes->first_key_sym;
        req->nKeySyms = changes->num_key_syms;
        req->firstKeyAct = changes->first_key_act;
        req->nKeyActs = changes->num_key_acts;
        req->firstKeyBehavior = changes->first_key_behavior;
        req->nKeyBehaviors = changes->num_key_behaviors;
        req->virtualMods = changes->vmods;
        req->firstKeyExplicit = changes->first_key_explicit;
        req->nKeyExplicit = changes->num_key_explicit;
        req->firstModMapKey = changes->first_modmap_key;
        req->nModMapKeys = changes->num_modmap_keys;
        req->firstVModMapKey = changes->first_vmodmap_key;
        req->nVModMapKeys = changes->num_vmodmap_keys;
        status = _XkbHandleGetMapReply(dpy, xkb);
        UnlockDisplay(dpy);
        SyncHandle();
        return status;
    }
    UnlockDisplay(dpy);
    return Success;
}
@


1.6
log
@Update to libX11 1.5.99.902 aka 1.6rc2
@
text
@d36 1
a36 1
_XkbReadKeyTypes(XkbReadBufferPtr buf,XkbDescPtr xkb,xkbGetMapReply *rep)
d38 2
a39 2
int		 i,n,lastMapCount;
XkbKeyTypePtr	type;
d41 101
a141 100
    if ( rep->nTypes>0 ) {
	n = rep->firstType+rep->nTypes;
	if (xkb->map->num_types>=n)
	    n= xkb->map->num_types;
	else if (XkbAllocClientMap(xkb,XkbKeyTypesMask,n)!=Success)
	    return BadAlloc;

	type = &xkb->map->types[rep->firstType];
	for (i=0;i<(int)rep->nTypes;i++,type++) {
	    xkbKeyTypeWireDesc	*desc;
	    register int ndx;

	    ndx= i+rep->firstType;
	    if (ndx>=xkb->map->num_types)
		xkb->map->num_types= ndx+1;

	    desc= (xkbKeyTypeWireDesc *)_XkbGetReadBufferPtr(buf,
						SIZEOF(xkbKeyTypeWireDesc));
	    if (desc==NULL)
		return BadLength;

	    lastMapCount= type->map_count;
	    if ( desc->nMapEntries>0 ) {
		if ((type->map==NULL)||(desc->nMapEntries>type->map_count)) {
		    XkbKTMapEntryRec *prev_map = type->map;

		    type->map= _XkbTypedRealloc(type->map,desc->nMapEntries,
							      XkbKTMapEntryRec);
		    if (type->map==NULL) {
			_XkbFree(prev_map);
			return BadAlloc;
		    }
		}
	    }
	    else if (type->map!=NULL) {
		Xfree(type->map);
		type->map_count= 0;
		type->map= NULL;
	    }

	    if ( desc->preserve && (desc->nMapEntries>0) ) {
		if ((!type->preserve)||
		    (desc->nMapEntries>lastMapCount)) {
		    XkbModsRec *prev_preserve = type->preserve;

		    type->preserve= _XkbTypedRealloc(type->preserve,
							desc->nMapEntries,
							XkbModsRec);
		    if (type->preserve==NULL) {
			_XkbFree(prev_preserve);
			return BadAlloc;
		    }
		}
	    }
	    else if (type->preserve!=NULL) {
		Xfree(type->preserve);
		type->preserve= NULL;
	    }

	    type->mods.mask = desc->mask;
	    type->mods.real_mods = desc->realMods;
	    type->mods.vmods = desc->virtualMods;
	    type->num_levels = desc->numLevels;
	    type->map_count = desc->nMapEntries;
	    if (desc->nMapEntries>0) {
		register xkbKTMapEntryWireDesc *wire;
		register XkbKTMapEntryPtr	entry;
		register int size;

		size= type->map_count*SIZEOF(xkbKTMapEntryWireDesc);
		wire= (xkbKTMapEntryWireDesc *)_XkbGetReadBufferPtr(buf,size);
		if (wire==NULL)
		    return BadLength;
		entry= type->map;
		for (n=0;n<type->map_count;n++,wire++,entry++) {
		    entry->active= wire->active;
		    entry->level= wire->level;
		    entry->mods.mask= wire->mask;
		    entry->mods.real_mods= wire->realMods;
		    entry->mods.vmods= wire->virtualMods;
		}

	 	if (desc->preserve) {
		    register xkbModsWireDesc *	pwire;
		    register XkbModsPtr		preserve;
		    register int sz;

		    sz= desc->nMapEntries*SIZEOF(xkbModsWireDesc);
		    pwire=(xkbModsWireDesc *)_XkbGetReadBufferPtr(buf,sz);
		    if (pwire==NULL)
			return BadLength;
		    preserve= type->preserve;
		    for (n=0;n<desc->nMapEntries;n++,pwire++,preserve++) {
			preserve->mask=  pwire->mask;
			preserve->vmods=  pwire->virtualMods;
			preserve->real_mods= pwire->realMods;
		    }
		}
	    }
	}
d147 1
a147 1
_XkbReadKeySyms(XkbReadBufferPtr buf,XkbDescPtr xkb,xkbGetMapReply *rep)
d149 63
a211 60
register int i;
XkbClientMapPtr	map;

    map= xkb->map;
    if (map->key_sym_map==NULL) {
	register int offset;
	int size = xkb->max_key_code + 1;
	XkbSymMapPtr	oldMap;
	xkbSymMapWireDesc *newMap;
	if (((unsigned short)rep->firstKeySym + rep->nKeySyms) > size)
	    return BadLength;
	map->key_sym_map= _XkbTypedCalloc(size,XkbSymMapRec);
	if (map->key_sym_map==NULL)
	    return BadAlloc;
	if (map->syms==NULL) {
	    int sz;
	    sz= (rep->totalSyms*12)/10;
	    sz= ((sz+(unsigned)128)/128)*128;
	    map->syms = _XkbTypedCalloc(sz,KeySym);
	    if (map->syms==NULL)
		return BadAlloc;
	    map->size_syms = sz;
	}
	offset = 1;
	oldMap = &map->key_sym_map[rep->firstKeySym];
	for (i=0;i<(int)rep->nKeySyms;i++,oldMap++) {
	    newMap= (xkbSymMapWireDesc *)
			_XkbGetReadBufferPtr(buf,SIZEOF(xkbSymMapWireDesc));
	    if (newMap==NULL)
		return BadLength;
	    oldMap->kt_index[0]= newMap->ktIndex[0];
	    oldMap->kt_index[1]= newMap->ktIndex[1];
	    oldMap->kt_index[2]= newMap->ktIndex[2];
	    oldMap->kt_index[3]= newMap->ktIndex[3];
	    oldMap->group_info= newMap->groupInfo;
	    oldMap->width= newMap->width;
	    oldMap->offset= offset;
	    if (offset+newMap->nSyms>=map->size_syms) {
		register int sz;
		KeySym *prev_syms = map->syms;

		sz= map->size_syms+128;
		map->syms= _XkbTypedRealloc(map->syms,sz,KeySym);
		if (map->syms==NULL) {
		    _XkbFree(prev_syms);
		    map->size_syms= 0;
		    return BadAlloc;
		}
		map->size_syms= sz;
	    }
	    if (newMap->nSyms>0) {
		_XkbReadBufferCopyKeySyms(buf,(KeySym *)&map->syms[offset],
							newMap->nSyms);
		offset+= newMap->nSyms;
	    }
	    else {
		map->syms[offset]= 0;
	    }
	}
	map->num_syms= offset;
d214 31
a244 31
	xkbSymMapWireDesc *	newMap;
	XkbSymMapPtr		oldMap;
	KeySym *		newSyms;
	int			tmp;

	if (((unsigned short)rep->firstKeySym + rep->nKeySyms) > map->num_syms)
	    return BadLength;
	oldMap = &map->key_sym_map[rep->firstKeySym];
	for (i=0;i<(int)rep->nKeySyms;i++,oldMap++) {
	    newMap= (xkbSymMapWireDesc *)
			_XkbGetReadBufferPtr(buf,SIZEOF(xkbSymMapWireDesc));
	    if (newMap==NULL)
		return BadLength;

	    if (newMap->nSyms>0)
		 tmp= newMap->nSyms;
	    else tmp= 0;

	    newSyms = XkbResizeKeySyms(xkb,i+rep->firstKeySym,tmp);
	    if (newSyms==NULL)
		return BadAlloc;
	    if (newMap->nSyms>0)
		_XkbReadBufferCopyKeySyms(buf,newSyms,newMap->nSyms);
	    else newSyms[0]= NoSymbol;
	    oldMap->kt_index[0] = newMap->ktIndex[0];
	    oldMap->kt_index[1] = newMap->ktIndex[1];
	    oldMap->kt_index[2] = newMap->ktIndex[2];
	    oldMap->kt_index[3] = newMap->ktIndex[3];
	    oldMap->group_info = newMap->groupInfo;
	    oldMap->width = newMap->width;
	}
d250 1
a250 1
_XkbReadKeyActions(XkbReadBufferPtr buf,XkbDescPtr info,xkbGetMapReply *rep)
d252 54
a305 50
int		i;
CARD8		numDescBuf[248];
CARD8*		numDesc = NULL;
register int	nKeyActs;
Status		ret = Success;

    if ( (nKeyActs=rep->nKeyActs)>0 ) {
	XkbSymMapPtr	symMap;

	if (nKeyActs < sizeof numDescBuf) numDesc = numDescBuf;
	else numDesc = Xmalloc (nKeyActs * sizeof(CARD8));

	if (!_XkbCopyFromReadBuffer(buf, (char *)numDesc, nKeyActs)) {
	    ret = BadLength;
	    goto done;
	}
	i= XkbPaddedSize(nKeyActs)-nKeyActs;
	if ((i>0)&&(!_XkbSkipReadBufferData(buf,i))) {
	    ret = BadLength;
	    goto done;
	}
	symMap = &info->map->key_sym_map[rep->firstKeyAct];
	for (i=0;i<(int)rep->nKeyActs;i++,symMap++) {
	    if (numDesc[i]==0) {
		if ((i + rep->firstKeyAct) > (info->max_key_code + 1)) {
		    ret = BadLength;
		    goto done;
		}
		info->server->key_acts[i+rep->firstKeyAct]= 0;
	    }
	    else {
		XkbAction *newActs;
		/* 8/16/93 (ef) -- XXX! Verify size here (numdesc must be */
		/*                 either zero or XkbKeyNumSyms(info,key) */
		newActs=XkbResizeKeyActions(info,i+rep->firstKeyAct,
								numDesc[i]);
		if (newActs==NULL) {
		    ret = BadAlloc;
		    goto done;
		}
		if (!_XkbCopyFromReadBuffer(buf,(char *)newActs,
					(int)(numDesc[i]*sizeof(XkbAction)))) {
		    ret = BadLength;
		    goto done;
		}
	    }
	}
    }
done:
    if (numDesc != NULL && numDesc != numDescBuf) Xfree (numDesc);
d310 1
a310 1
_XkbReadKeyBehaviors(XkbReadBufferPtr buf,XkbDescPtr xkb,xkbGetMapReply *rep)
d312 1
a312 2
register int i;
xkbBehaviorWireDesc	*wire;
d314 24
a337 21
    if ( rep->totalKeyBehaviors>0 ) {
	int size = xkb->max_key_code + 1;
	if ( ((int) rep->firstKeyBehavior + rep->nKeyBehaviors) > size)
	    return BadLength;
	if ( xkb->server->behaviors == NULL ) {
	    xkb->server->behaviors = _XkbTypedCalloc(size,XkbBehavior);
	    if (xkb->server->behaviors==NULL)
		return BadAlloc;
	}
	else {
	    bzero(&xkb->server->behaviors[rep->firstKeyBehavior],
	    		(rep->nKeyBehaviors*sizeof(XkbBehavior)));
	}
	for (i=0;i<rep->totalKeyBehaviors;i++) {
	    wire= (xkbBehaviorWireDesc *)_XkbGetReadBufferPtr(buf,
						SIZEOF(xkbBehaviorWireDesc));
	    if (wire==NULL || wire->key >= size)
		return BadLength;
	    xkb->server->behaviors[wire->key].type= wire->type;
	    xkb->server->behaviors[wire->key].data= wire->data;
	}
d343 1
a343 1
_XkbReadVirtualMods(XkbReadBufferPtr buf,XkbDescPtr xkb,xkbGetMapReply *rep)
d345 18
a362 17
    if ( rep->virtualMods ) {
	register int i,bit,nVMods;
	register char *data;

	for (i=nVMods=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	    if (rep->virtualMods&bit)
		nVMods++;
	}
	data= _XkbGetReadBufferPtr(buf,XkbPaddedSize(nVMods));
	if (data==NULL)
	    return BadLength;
	for (i=0,bit=1;(i<XkbNumVirtualMods)&&(nVMods>0);i++,bit<<=1) {
	    if (rep->virtualMods&bit) {
		xkb->server->vmods[i]= *data++;
		nVMods--;
	    }
	}
d368 31
a398 29
_XkbReadExplicitComponents(	XkbReadBufferPtr	buf,
				XkbDescPtr 		xkb,
				xkbGetMapReply *	rep)
{
register int i;
unsigned char *wire;

    if ( rep->totalKeyExplicit>0 ) {
	int size = xkb->max_key_code + 1;
	if ( ((int) rep->firstKeyExplicit + rep->nKeyExplicit) > size)
	    return BadLength;
	if ( xkb->server->explicit == NULL ) {
	    xkb->server->explicit = _XkbTypedCalloc(size,unsigned char);
	    if (xkb->server->explicit==NULL)
		return BadAlloc;
	}
	else {
	    bzero(&xkb->server->explicit[rep->firstKeyExplicit],
	    						rep->nKeyExplicit);
	}
	i= XkbPaddedSize(2*rep->totalKeyExplicit);
	wire=(unsigned char *)_XkbGetReadBufferPtr(buf,i);
	if (!wire)
	    return BadLength;
	for (i=0;i<rep->totalKeyExplicit;i++,wire+=2) {
	    if (wire[0] > xkb->max_key_code || wire[1] > xkb->max_key_code)
		return BadLength;
	    xkb->server->explicit[wire[0]]= wire[1];
	}
d404 1
a404 1
_XkbReadModifierMap(XkbReadBufferPtr buf,XkbDescPtr xkb,xkbGetMapReply *rep)
d406 2
a407 2
register int i;
unsigned char *wire;
d409 20
a428 20
    if ( rep->totalModMapKeys>0 ) {
	if ( ((int)rep->firstModMapKey + rep->nModMapKeys) >
	     (xkb->max_key_code + 1))
	    return BadLength;
	if ((xkb->map->modmap==NULL)&&
	    (XkbAllocClientMap(xkb,XkbModifierMapMask,0)!=Success)) {
	    return BadAlloc;
	}
	else {
	    bzero(&xkb->map->modmap[rep->firstModMapKey],rep->nModMapKeys);
	}
	i= XkbPaddedSize(2*rep->totalModMapKeys);
	wire=(unsigned char *)_XkbGetReadBufferPtr(buf,i);
	if (!wire)
	    return BadLength;
	for (i=0;i<rep->totalModMapKeys;i++,wire+=2) {
	    if (wire[0] > xkb->max_key_code || wire[1] > xkb->max_key_code)
		return BadLength;
	    xkb->map->modmap[wire[0]]= wire[1];
	}
d434 33
a466 30
_XkbReadVirtualModMap(XkbReadBufferPtr buf,XkbDescPtr xkb,xkbGetMapReply *rep)
{
register int 		i;
xkbVModMapWireDesc *	wire;
XkbServerMapPtr		srv;

    if ( rep->totalVModMapKeys>0 ) {
	if (((int) rep->firstVModMapKey + rep->nVModMapKeys)
	     > xkb->max_key_code + 1)
	    return BadLength;
	if (((xkb->server==NULL)||(xkb->server->vmodmap==NULL))&&
	    (XkbAllocServerMap(xkb,XkbVirtualModMapMask,0)!=Success)) {
	    return BadAlloc;
	}
	else {
	    srv= xkb->server;
	    if (rep->nVModMapKeys > rep->firstVModMapKey)
		bzero((char *)&srv->vmodmap[rep->firstVModMapKey],
		      (rep->nVModMapKeys - rep->firstVModMapKey) *
		      sizeof(unsigned short));
	}
	srv= xkb->server;
	i= rep->totalVModMapKeys*SIZEOF(xkbVModMapWireDesc);
	wire=(xkbVModMapWireDesc *)_XkbGetReadBufferPtr(buf,i);
	if (!wire)
	    return BadLength;
	for (i=0;i<rep->totalVModMapKeys;i++,wire++) {
	    if ((wire->key>=xkb->min_key_code)&&(wire->key<=xkb->max_key_code))
		srv->vmodmap[wire->key]= wire->vmods;
	}
d472 1
a472 1
_XkbGetGetMapReq(Display *dpy,XkbDescPtr xkb)
d474 1
a474 1
xkbGetMapReq *req;
d493 12
a504 12
_XkbReadGetMapReply(	Display *	dpy,
			xkbGetMapReply *rep,
			XkbDescPtr	xkb,
			int *		nread_rtrn)
{
int		extraData;
unsigned	mask;

    if ( xkb->device_spec == XkbUseCoreKbd )
	xkb->device_spec= rep->deviceID;
    if ( rep->maxKeyCode < rep->minKeyCode )
	return BadImplementation;
d509 3
a511 3
	mask= rep->present&XkbAllClientInfoMask;
	if (mask&&(XkbAllocClientMap(xkb,mask,rep->nTypes)!=Success))
	    return BadAlloc;
d514 3
a516 3
	mask= rep->present&XkbAllServerInfoMask;
	if (mask&&(XkbAllocServerMap(xkb,mask,rep->totalActs)!=Success))
	    return BadAlloc;
d518 2
a519 2
    extraData= (int)(rep->length*4);
    extraData-= (SIZEOF(xkbGetMapReply)-SIZEOF(xGenericReply));
d521 32
a552 27
	XkbReadBufferRec	buf;
	int			left;
	if (_XkbInitReadBuffer(dpy,&buf,extraData)) {
	    Status status= Success;
	    if (nread_rtrn!=NULL)
		*nread_rtrn= extraData;
	    if (status==Success)
		status= _XkbReadKeyTypes(&buf,xkb,rep);
	    if (status==Success)
		status= _XkbReadKeySyms(&buf,xkb,rep);
	    if (status==Success)
		status= _XkbReadKeyActions(&buf,xkb,rep);
	    if (status==Success)
		status= _XkbReadKeyBehaviors(&buf,xkb,rep);
	    if (status==Success)
		status= _XkbReadVirtualMods(&buf,xkb,rep);
	    if (status==Success)
		status= _XkbReadExplicitComponents(&buf,xkb,rep);
	    if (status==Success)
		status= _XkbReadModifierMap(&buf,xkb,rep);
	    if (status==Success)
		status= _XkbReadVirtualModMap(&buf,xkb,rep);
	    left= _XkbFreeReadBuffer(&buf);
	    if (status!=Success)		return status;
	    else if ( left || buf.error )	return BadLength;
	}
	else return BadAlloc;
d558 1
a558 1
_XkbHandleGetMapReply(Display *dpy,XkbDescPtr xkb)
d560 1
a560 1
xkbGetMapReply	rep;
d562 4
a565 4
    if (!_XReply(dpy, (xReply *)&rep,
    		 ( (SIZEOF(xkbGetMapReply)-SIZEOF(xGenericReply)) >> 2 ),
		 xFalse)) {
	return BadImplementation;
d567 1
a567 1
    return _XkbReadGetMapReply(dpy,&rep,xkb,NULL);
d571 1
a571 1
XkbGetUpdatedMap(Display *dpy,unsigned which,XkbDescPtr xkb)
d574 2
a575 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
d577 2
a578 2
	register xkbGetMapReq *req;
	Status status;
d580 1
a580 1
	LockDisplay(dpy);
d582 7
a588 7
	req = _XkbGetGetMapReq(dpy, xkb);
	req->full = which;
	status= _XkbHandleGetMapReply(dpy, xkb);

	UnlockDisplay(dpy);
	SyncHandle();
	return status;
d594 1
a594 1
XkbGetMap(Display *dpy,unsigned which,unsigned deviceSpec)
d596 1
a596 1
XkbDescPtr xkb;
d598 1
a598 1
    xkb = _XkbTypedCalloc(1,XkbDescRec);
d600 12
a611 12
	xkb->device_spec = deviceSpec;
	xkb->map = _XkbTypedCalloc(1,XkbClientMapRec);
	if ((xkb->map==NULL)||
	    ((which)&&(XkbGetUpdatedMap(dpy,which,xkb)!=Success))) {
	    if (xkb->map) {
		Xfree(xkb->map);
		xkb->map= NULL;
	    }
	    Xfree(xkb);
	    return NULL;
	}
	xkb->dpy= dpy;
d617 1
a617 1
XkbGetKeyTypes(Display *dpy,unsigned first,unsigned num,XkbDescPtr xkb)
d623 4
a626 4
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
    if ((num<1)||(num>XkbMaxKeyTypes))
	return BadValue;
d633 1
a633 1
    status= _XkbHandleGetMapReply(dpy, xkb);
d641 1
a641 1
XkbGetKeyActions(Display *dpy,unsigned first,unsigned num,XkbDescPtr xkb)
d647 2
a648 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
d650 2
a651 2
    if ((num<1)||(num>XkbMaxKeyCount))
	return BadValue;
d658 1
a658 1
    status= _XkbHandleGetMapReply(dpy, xkb);
d666 1
a666 1
XkbGetKeySyms(Display *dpy,unsigned first,unsigned num,XkbDescPtr xkb)
d672 2
a673 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
d675 2
a676 2
    if ((num<1)||(num>XkbMaxKeyCount))
	return BadValue;
d683 1
a683 1
    status= _XkbHandleGetMapReply(dpy, xkb);
d692 1
a692 1
XkbGetKeyBehaviors(Display *dpy,unsigned first,unsigned num,XkbDescPtr xkb)
d698 2
a699 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
d701 2
a702 2
    if ((num<1)||(num>XkbMaxKeyCount))
	return BadValue;
d709 1
a709 1
    status= _XkbHandleGetMapReply(dpy, xkb);
d717 1
a717 1
XkbGetVirtualMods(Display *dpy,unsigned which,XkbDescPtr xkb)
d723 2
a724 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
d730 1
a730 1
    status= _XkbHandleGetMapReply(dpy, xkb);
d738 4
a741 4
XkbGetKeyExplicitComponents(	Display *	dpy,
				unsigned	first,
				unsigned 	num,
				XkbDescPtr	xkb)
d747 2
a748 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
d750 2
a751 2
    if ((num<1)||(num>XkbMaxKeyCount))
	return BadValue;
d758 5
a762 3
    if ((xkb!=NULL) && (xkb->server!=NULL) && (xkb->server->explicit!=NULL)) {
	if ((num>0)&&(first>=xkb->min_key_code)&&(first+num<=xkb->max_key_code))
	    bzero(&xkb->server->explicit[first],num);
d765 1
a765 1
        status= _XkbHandleGetMapReply(dpy, xkb);
d775 4
a778 1
XkbGetKeyModifierMap(Display *dpy,unsigned first,unsigned num,XkbDescPtr xkb)
d784 2
a785 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
d787 2
a788 2
    if ((num<1)||(num>XkbMaxKeyCount))
	return BadValue;
d795 4
a798 3
    if ((xkb!=NULL) && (xkb->map!=NULL) && (xkb->map->modmap!=NULL)) {
	if ((num>0)&&(first>=xkb->min_key_code)&&(first+num<=xkb->max_key_code))
	    bzero(&xkb->map->modmap[first],num);
d801 1
a801 1
        status= _XkbHandleGetMapReply(dpy, xkb);
d811 2
a812 1
XkbGetKeyVirtualModMap(Display *dpy,unsigned first,unsigned num,XkbDescPtr xkb)
d818 2
a819 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
d821 2
a822 2
    if ((num<1)||(num>XkbMaxKeyCount))
	return BadValue;
d829 4
a832 3
    if ((xkb!=NULL) && (xkb->map!=NULL) && (xkb->map->modmap!=NULL)) {
	if ((num>0)&&(first>=xkb->min_key_code)&&(first+num<=xkb->max_key_code))
	    bzero(&xkb->server->vmodmap[first],num*sizeof(unsigned short));
d836 1
a836 1
        status= _XkbHandleGetMapReply(dpy, xkb);
d846 1
a846 1
XkbGetMapChanges(Display *dpy,XkbDescPtr xkb,XkbMapChangesPtr changes)
d851 2
a852 2
	(!dpy->xkb_info && !XkbUseExtension(dpy,NULL,NULL)))
	return BadAccess;
d855 24
a878 23
	Status status= Success;
	req = _XkbGetGetMapReq(dpy, xkb);
	req->full = 0;
	req->partial = changes->changed;
	req->firstType = changes->first_type;
	req->nTypes = changes->num_types;
	req->firstKeySym = changes->first_key_sym;
	req->nKeySyms = changes->num_key_syms;
	req->firstKeyAct = changes->first_key_act;
	req->nKeyActs = changes->num_key_acts;
	req->firstKeyBehavior = changes->first_key_behavior;
	req->nKeyBehaviors = changes->num_key_behaviors;
	req->virtualMods = changes->vmods;
	req->firstKeyExplicit = changes->first_key_explicit;
	req->nKeyExplicit = changes->num_key_explicit;
	req->firstModMapKey = changes->first_modmap_key;
	req->nModMapKeys = changes->num_modmap_keys;
	req->firstVModMapKey = changes->first_vmodmap_key;
	req->nVModMapKeys = changes->num_vmodmap_keys;
	status= _XkbHandleGetMapReply(dpy, xkb);
	UnlockDisplay(dpy);
	SyncHandle();
	return status;
a882 1

@


1.5
log
@Merge upstream fixes for several X libs vulnerabilities
discovered by Ilja van Sprundel.

CVE-2013-1981 X.org libX11 1.5.99.901 (1.6 RC1) integer overflows
CVE-2013-1982 X.org libXext 1.3.1 integer overflows
CVE-2013-1983 X.org libXfixes 5.0 integer overflows
CVE-2013-1984 X.org libXi 1.7.1 integer overflows
CVE-2013-1985 X.org libXinerama 1.1.2 integer overflows
CVE-2013-1986 X.org libXrandr 1.4.0 integer overflows
CVE-2013-1987 X.org libXrender 0.9.7 integer overflows
CVE-2013-1988 X.org libXRes 1.0.6 integer overflows
CVE-2013-1989 X.org libXv 1.0.7 integer overflows
CVE-2013-1990 X.org libXvMC 1.0.7 integer overflows
CVE-2013-1991 X.org libXxf86dga 1.1.3 integer overflows
CVE-2013-1992 X.org libdmx 1.1.2 integer overflows
CVE-2013-1994 X.org libchromeXvMC & libchromeXvMCPro in openChrome
0.3.2 integer overflows
CVE-2013-1995 X.org libXi 1.7.1 sign extension issues
CVE-2013-1996 X.org libFS 1.0.4 sign extension issues
CVE-2013-1997 X.org libX11 1.5.99.901 (1.6 RC1) buffer overflows
CVE-2013-1998 X.org libXi 1.7.1 buffer overflows
CVE-2013-1999 X.org libXvMC 1.0.7 buffer overflows
CVE-2013-2000 X.org libXxf86dga 1.1.3 buffer overflows
CVE-2013-2001 X.org libXxf86vm 1.1.2 buffer overflows
CVE-2013-2002 X.org libXt 1.1.3 buffer overflows
CVE-2013-2003 X.org libXcursor 1.1.13 integer overflows
CVE-2013-2004 X.org libX11 1.5.99.901 (1.6 RC1) unbounded recursion
CVE-2013-2005 X.org libXt 1.1.3 memory corruption
CVE-2013-2066 X.org libXv 1.0.7 buffer overflows
@
text
@d487 2
@


1.4
log
@Update to libx11 1.4.2. Tested by ajacoutot@@, jasper@@ krw@@, landry@@,
shadchin@@ on various architectures.
Bump major.
@
text
@d154 1
d157 3
a159 1
	map->key_sym_map= _XkbTypedCalloc((xkb->max_key_code+1),XkbSymMapRec);
d215 2
d272 4
d308 3
a311 1
	    int size = xkb->max_key_code+1;
d323 1
a323 1
	    if (wire==NULL)
d365 3
a368 1
	    int size = xkb->max_key_code+1;
d382 2
d397 3
d412 2
d428 3
@


1.3
log
@Update to libX11 1.3.3. Tested on a bulk ports build by naddy@@.
@
text
@a26 3

#define NEED_REPLIES
#define NEED_EVENTS
@


1.2
log
@update to libX11 1.2.1
@
text
@a0 1
/* $Xorg: XKBGetMap.c,v 1.4 2000/08/17 19:45:02 cpqbld Exp $ */
a26 1
/* $XFree86: xc/lib/X11/XKBGetMap.c,v 1.9 2003/04/17 02:06:31 dawes Exp $ */
@


1.1
log
@Initial revision
@
text
@d10 2
a11 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d13 1
a13 1
Silicon Graphics makes no representation about the suitability 
d17 2
a18 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d20 3
a22 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d111 1
a111 1
		register xkbKTMapEntryWireDesc *wire; 
d129 1
a129 1
		    register xkbModsWireDesc *	pwire; 
d522 1
a522 1
    		 ( (SIZEOF(xkbGetMapReply)-SIZEOF(xGenericReply)) >> 2 ), 
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
