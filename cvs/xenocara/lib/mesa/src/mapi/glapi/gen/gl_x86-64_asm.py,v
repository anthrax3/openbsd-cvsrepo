head	1.2;
access;
symbols
	mesa-17_1_6:1.1.1.3
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	mesa-13_0_6:1.1.1.2
	mesa-13_0_5:1.1.1.2
	mesa-13_0_3:1.1.1.2
	mesa-13_0_2:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2017.08.26.16.59.35;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.46.22;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.46.22;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.22.27;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2017.08.14.09.31.58;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@#!/usr/bin/env python

# (C) Copyright IBM Corporation 2005
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# on the rights to use, copy, modify, merge, publish, distribute, sub
# license, and/or sell copies of the Software, and to permit persons to whom
# the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
# IBM AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
# Authors:
#    Ian Romanick <idr@@us.ibm.com>

import argparse
import copy

import license
import gl_XML, glX_XML

def should_use_push(registers):
    for [reg, offset] in registers:
        if reg[1:4] == "xmm":
            return 0

    N = len(registers)
    return (N & 1) != 0


def local_size(registers):
    # The x86-64 ABI says "the value (%rsp - 8) is always a multiple of
    # 16 when control is transfered to the function entry point."  This
    # means that the local stack usage must be (16*N)+8 for some value
    # of N.  (16*N)+8 = (8*(2N))+8 = 8*(2N+1).  As long as N is odd, we
    # meet this requirement.

    N = (len(registers) | 1)
    return 8*N


def save_all_regs(registers):
    adjust_stack = 0
    if not should_use_push(registers):
        adjust_stack = local_size(registers)
        print '\tsubq\t$%u, %%rsp' % (adjust_stack)

    for [reg, stack_offset] in registers:
        save_reg( reg, stack_offset, adjust_stack )
    return


def restore_all_regs(registers):
    adjust_stack = 0
    if not should_use_push(registers):
        adjust_stack = local_size(registers)

    temp = copy.deepcopy(registers)
    while len(temp):
        [reg, stack_offset] = temp.pop()
        restore_reg(reg, stack_offset, adjust_stack)

    if adjust_stack:
        print '\taddq\t$%u, %%rsp' % (adjust_stack)
    return


def save_reg(reg, offset, use_move):
    if use_move:
        if offset == 0:
            print '\tmovq\t%s, (%%rsp)' % (reg)
        else:
            print '\tmovq\t%s, %u(%%rsp)' % (reg, offset)
    else:
        print '\tpushq\t%s' % (reg)

    return


def restore_reg(reg, offset, use_move):
    if use_move:
        if offset == 0:
            print '\tmovq\t(%%rsp), %s' % (reg)
        else:
            print '\tmovq\t%u(%%rsp), %s' % (offset, reg)
    else:
        print '\tpopq\t%s' % (reg)

    return


class PrintGenericStubs(gl_XML.gl_print_base):

    def __init__(self):
        gl_XML.gl_print_base.__init__(self)

        self.name = "gl_x86-64_asm.py (from Mesa)"
        self.license = license.bsd_license_template % ("(C) Copyright IBM Corporation 2005", "IBM")
        return


    def get_stack_size(self, f):
        size = 0
        for p in f.parameterIterator():
            size += p.get_stack_size()

        return size


    def printRealHeader(self):
        print "/* If we build with gcc's -fvisibility=hidden flag, we'll need to change"
        print " * the symbol visibility mode to 'default'."
        print ' */'
        print ''
        print '#include "x86/assyntax.h"'
        print ''
        print '#ifdef __GNUC__'
        print '#  pragma GCC visibility push(default)'
        print '#  define HIDDEN(x) .hidden x'
        print '#else'
        print '#  define HIDDEN(x)'
        print '#endif'
        print ''
        print '# if defined(USE_MGL_NAMESPACE)'
        print '#  define GL_PREFIX(n) GLNAME(CONCAT(mgl,n))'
        print '#  define _glapi_Dispatch _mglapi_Dispatch'
        print '# else'
        print '#  define GL_PREFIX(n) GLNAME(CONCAT(gl,n))'
        print '# endif'
        print ''
        print '\t.text'
        print ''
        print '#ifdef GLX_USE_TLS'
        print ''
        print '_x86_64_get_dispatch:'
        print '\tmovq\t_glapi_tls_Dispatch@@GOTTPOFF(%rip), %rax'
        print '\tmovq\t%fs:(%rax), %rax'
        print '\tret'
        print '\t.size\t_x86_64_get_dispatch, .-_x86_64_get_dispatch'
        print ''
        print '#elif defined(HAVE_PTHREAD)'
        print ''
        print '\t.extern\t_glapi_Dispatch'
        print '\t.extern\t_gl_DispatchTSD'
        print '\t.extern\tpthread_getspecific'
        print ''
        print '\t.p2align\t4,,15'
        print '_x86_64_get_dispatch:'
        print '\tmovq\t_gl_DispatchTSD@@GOTPCREL(%rip), %rax'
        print '\tmovl\t(%rax), %edi'
        print '\tjmp\tpthread_getspecific@@PLT'
        print ''
        print '#else'
        print ''
        print '\t.extern\t_glapi_get_dispatch'
        print ''
        print '#endif'
        print ''
        return


    def printRealFooter(self):
        print ''
        print '#if defined (__ELF__) && defined (__linux__)'
        print '	.section .note.GNU-stack,"",%progbits'
        print '#endif'
        return


    def printFunction(self, f):

        # The x86-64 ABI divides function parameters into a couple
        # classes.  For the OpenGL interface, the only ones that are
        # relevant are INTEGER and SSE.  Basically, the first 8
        # GLfloat or GLdouble parameters are placed in %xmm0 - %xmm7,
        # the first 6 non-GLfloat / non-GLdouble parameters are placed
        # in registers listed in int_parameters.
        #
        # If more parameters than that are required, they are passed
        # on the stack.  Therefore, we just have to make sure that
        # %esp hasn't changed when we jump to the actual function.
        # Since we're jumping to the function (and not calling it), we
        # have to make sure of that anyway!

        int_parameters = ["%rdi", "%rsi", "%rdx", "%rcx", "%r8", "%r9"]

        int_class = 0
        sse_class = 0
        stack_offset = 0
        registers = []
        for p in f.parameterIterator():
            type_name = p.get_base_type_string()

            if p.is_pointer() or (type_name != "GLfloat" and type_name != "GLdouble"):
                if int_class < 6:
                    registers.append( [int_parameters[int_class], stack_offset] )
                    int_class += 1
                    stack_offset += 8
            else:
                if sse_class < 8:
                    registers.append( ["%%xmm%u" % (sse_class), stack_offset] )
                    sse_class += 1
                    stack_offset += 8

        if ((int_class & 1) == 0) and (sse_class == 0):
            registers.append( ["%rbp", 0] )


        name = f.dispatch_name()

        print '\t.p2align\t4,,15'
        print '\t.globl\tGL_PREFIX(%s)' % (name)
        print '\t.type\tGL_PREFIX(%s), @@function' % (name)
        if not f.is_static_entry_point(f.name):
            print '\tHIDDEN(GL_PREFIX(%s))' % (name)
        print 'GL_PREFIX(%s):' % (name)
        print '#if defined(GLX_USE_TLS)'
        print '\tcall\t_x86_64_get_dispatch@@PLT'
        print '\tmovq\t%u(%%rax), %%r11' % (f.offset * 8)
        print '\tjmp\t*%r11'
        print '#elif defined(HAVE_PTHREAD)'

        save_all_regs(registers)
        print '\tcall\t_x86_64_get_dispatch@@PLT'
        restore_all_regs(registers)

        if f.offset == 0:
            print '\tmovq\t(%rax), %r11'
        else:
            print '\tmovq\t%u(%%rax), %%r11' % (f.offset * 8)

        print '\tjmp\t*%r11'

        print '#else'
        print '\tmovq\t_glapi_Dispatch(%rip), %rax'
        print '\ttestq\t%rax, %rax'
        print '\tje\t1f'
        print '\tmovq\t%u(%%rax), %%r11' % (f.offset * 8)
        print '\tjmp\t*%r11'
        print '1:'

        save_all_regs(registers)
        print '\tcall\t_glapi_get_dispatch'
        restore_all_regs(registers)

        print '\tmovq\t%u(%%rax), %%r11' % (f.offset * 8)
        print '\tjmp\t*%r11'
        print '#endif /* defined(GLX_USE_TLS) */'

        print '\t.size\tGL_PREFIX(%s), .-GL_PREFIX(%s)' % (name, name)
        print ''
        return


    def printBody(self, api):
        for f in api.functionIterateByOffset():
            self.printFunction(f)


        for f in api.functionIterateByOffset():
            dispatch = f.dispatch_name()
            for n in f.entry_points:
                if n != f.name:
                    if f.is_static_entry_point(n):
                        text = '\t.globl GL_PREFIX(%s) ; .set GL_PREFIX(%s), GL_PREFIX(%s)' % (n, n, dispatch)

                        if f.has_different_protocol(n):
                            print '#ifndef GLX_INDIRECT_RENDERING'
                            print text
                            print '#endif'
                        else:
                            print text

        return


def _parser():
    """Parse arguments and return a namespace."""
    parser = argparse.ArgumentParser()
    parser.add_argument('-f',
                        default='gl_API.xml',
                        dest='filename',
                        help='An XML file describing an API')
    return parser.parse_args()


def main():
    """Main file."""
    args = _parser()
    printer = PrintGenericStubs()
    api = gl_XML.parse_GL_API(args.filename, glX_XML.glx_item_factory())

    printer.Print(api)


if __name__ == '__main__':
    main()
@


1.1
log
@Initial revision
@
text
@a146 6
        print '\t.globl _x86_64_get_get_dispatch; HIDDEN(_x86_64_get_get_dispatch)'
        print '_x86_64_get_get_dispatch:'
        print '\tlea\t_x86_64_get_dispatch(%rip), %rax'
        print '\tret'
        print ''
        print '\t.p2align\t4,,15'
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d147 6
@


1.1.1.3
log
@Import Mesa 17.1.6
@
text
@d1 1
@


