head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.44.29;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.29;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.20.04;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.28.10;	author jsg;	state Exp;
branches;
next	;
commitid	uuv5VTS15jglEDZU;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright 2010 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#include <stdio.h>
#include <errno.h>
#include "pipe/p_defines.h"
#include "pipe/p_state.h"
#include "pipe/p_context.h"
#include "pipe/p_screen.h"
#include "util/u_memory.h"
#include "util/u_inlines.h"
#include "util/u_transfer.h"

static void noop_draw_vbo(struct pipe_context *ctx, const struct pipe_draw_info *info)
{
}

static void noop_set_blend_color(struct pipe_context *ctx,
					const struct pipe_blend_color *state)
{
}

static void *noop_create_blend_state(struct pipe_context *ctx,
					const struct pipe_blend_state *state)
{
	struct pipe_blend_state *nstate = CALLOC_STRUCT(pipe_blend_state);

	if (nstate == NULL) {
		return NULL;
	}
	*nstate = *state;
	return nstate;
}

static void *noop_create_dsa_state(struct pipe_context *ctx,
				   const struct pipe_depth_stencil_alpha_state *state)
{
	struct pipe_depth_stencil_alpha_state *nstate = CALLOC_STRUCT(pipe_depth_stencil_alpha_state);

	if (nstate == NULL) {
		return NULL;
	}
	*nstate = *state;
	return nstate;
}

static void *noop_create_rs_state(struct pipe_context *ctx,
					const struct pipe_rasterizer_state *state)
{
	struct pipe_rasterizer_state *nstate = CALLOC_STRUCT(pipe_rasterizer_state);

	if (nstate == NULL) {
		return NULL;
	}
	*nstate = *state;
	return nstate;
}

static void *noop_create_sampler_state(struct pipe_context *ctx,
					const struct pipe_sampler_state *state)
{
	struct pipe_sampler_state *nstate = CALLOC_STRUCT(pipe_sampler_state);

	if (nstate == NULL) {
		return NULL;
	}
	*nstate = *state;
	return nstate;
}

static struct pipe_sampler_view *noop_create_sampler_view(struct pipe_context *ctx,
							struct pipe_resource *texture,
							const struct pipe_sampler_view *state)
{
	struct pipe_sampler_view *sampler_view = CALLOC_STRUCT(pipe_sampler_view);

	if (sampler_view == NULL)
		return NULL;
	/* initialize base object */
	pipe_resource_reference(&sampler_view->texture, texture);
	pipe_reference_init(&sampler_view->reference, 1);
	sampler_view->context = ctx;
	return sampler_view;
}

static struct pipe_surface *noop_create_surface(struct pipe_context *ctx,
						struct pipe_resource *texture,
						const struct pipe_surface *surf_tmpl)
{
	struct pipe_surface *surface = CALLOC_STRUCT(pipe_surface);

	if (surface == NULL)
		return NULL;
	pipe_reference_init(&surface->reference, 1);
	pipe_resource_reference(&surface->texture, texture);
	surface->context = ctx;
	surface->format = surf_tmpl->format;
	surface->width = texture->width0;
	surface->height = texture->height0;
	surface->texture = texture;
	surface->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
	surface->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
	surface->u.tex.level = surf_tmpl->u.tex.level;

	return surface;
}

static void noop_set_sampler_views(struct pipe_context *ctx, unsigned shader,
                                   unsigned start, unsigned count,
                                   struct pipe_sampler_view **views)
{
}

static void noop_bind_sampler_states(struct pipe_context *ctx, unsigned shader,
                                     unsigned start, unsigned count,
                                     void **states)
{
}

static void noop_set_clip_state(struct pipe_context *ctx,
				const struct pipe_clip_state *state)
{
}

static void noop_set_polygon_stipple(struct pipe_context *ctx,
					 const struct pipe_poly_stipple *state)
{
}

static void noop_set_sample_mask(struct pipe_context *pipe, unsigned sample_mask)
{
}

static void noop_set_scissor_states(struct pipe_context *ctx,
                                    unsigned start_slot,
                                    unsigned num_scissors,
                                    const struct pipe_scissor_state *state)
{
}

static void noop_set_stencil_ref(struct pipe_context *ctx,
				const struct pipe_stencil_ref *state)
{
}

static void noop_set_viewport_states(struct pipe_context *ctx,
                                     unsigned start_slot,
                                     unsigned num_viewports,
                                     const struct pipe_viewport_state *state)
{
}

static void noop_set_framebuffer_state(struct pipe_context *ctx,
					const struct pipe_framebuffer_state *state)
{
}

static void noop_set_constant_buffer(struct pipe_context *ctx,
					uint shader, uint index,
					struct pipe_constant_buffer *cb)
{
}


static void noop_sampler_view_destroy(struct pipe_context *ctx,
				struct pipe_sampler_view *state)
{
	pipe_resource_reference(&state->texture, NULL);
	FREE(state);
}


static void noop_surface_destroy(struct pipe_context *ctx,
				 struct pipe_surface *surface)
{
	pipe_resource_reference(&surface->texture, NULL);
	FREE(surface);
}

static void noop_bind_state(struct pipe_context *ctx, void *state)
{
}

static void noop_delete_state(struct pipe_context *ctx, void *state)
{
	FREE(state);
}

static void noop_delete_vertex_element(struct pipe_context *ctx, void *state)
{
	FREE(state);
}


static void noop_set_index_buffer(struct pipe_context *ctx,
					const struct pipe_index_buffer *ib)
{
}

static void noop_set_vertex_buffers(struct pipe_context *ctx,
				    unsigned start_slot, unsigned count,
				    const struct pipe_vertex_buffer *buffers)
{
}

static void *noop_create_vertex_elements(struct pipe_context *ctx,
					unsigned count,
					const struct pipe_vertex_element *state)
{
	struct pipe_vertex_element *nstate = CALLOC_STRUCT(pipe_vertex_element);

	if (nstate == NULL) {
		return NULL;
	}
	*nstate = *state;
	return nstate;
}

static void *noop_create_shader_state(struct pipe_context *ctx,
					const struct pipe_shader_state *state)
{
	struct pipe_shader_state *nstate = CALLOC_STRUCT(pipe_shader_state);

	if (nstate == NULL) {
		return NULL;
	}
	*nstate = *state;
	return nstate;
}

static struct pipe_stream_output_target *noop_create_stream_output_target(
      struct pipe_context *ctx,
      struct pipe_resource *res,
      unsigned buffer_offset,
      unsigned buffer_size)
{
   struct pipe_stream_output_target *t = CALLOC_STRUCT(pipe_stream_output_target);
   if (!t)
      return NULL;

   pipe_reference_init(&t->reference, 1);
   pipe_resource_reference(&t->buffer, res);
   t->buffer_offset = buffer_offset;
   t->buffer_size = buffer_size;
   return t;
}

static void noop_stream_output_target_destroy(struct pipe_context *ctx,
                                      struct pipe_stream_output_target *t)
{
   pipe_resource_reference(&t->buffer, NULL);
   FREE(t);
}

static void noop_set_stream_output_targets(struct pipe_context *ctx,
                           unsigned num_targets,
                           struct pipe_stream_output_target **targets,
                           const unsigned *offsets)
{
}

void noop_init_state_functions(struct pipe_context *ctx);

void noop_init_state_functions(struct pipe_context *ctx)
{
	ctx->create_blend_state = noop_create_blend_state;
	ctx->create_depth_stencil_alpha_state = noop_create_dsa_state;
	ctx->create_fs_state = noop_create_shader_state;
	ctx->create_rasterizer_state = noop_create_rs_state;
	ctx->create_sampler_state = noop_create_sampler_state;
	ctx->create_sampler_view = noop_create_sampler_view;
	ctx->create_surface = noop_create_surface;
	ctx->create_vertex_elements_state = noop_create_vertex_elements;
	ctx->create_vs_state = noop_create_shader_state;
	ctx->bind_blend_state = noop_bind_state;
	ctx->bind_depth_stencil_alpha_state = noop_bind_state;
	ctx->bind_sampler_states = noop_bind_sampler_states;
	ctx->bind_fs_state = noop_bind_state;
	ctx->bind_rasterizer_state = noop_bind_state;
	ctx->bind_vertex_elements_state = noop_bind_state;
	ctx->bind_vs_state = noop_bind_state;
	ctx->delete_blend_state = noop_delete_state;
	ctx->delete_depth_stencil_alpha_state = noop_delete_state;
	ctx->delete_fs_state = noop_delete_state;
	ctx->delete_rasterizer_state = noop_delete_state;
	ctx->delete_sampler_state = noop_delete_state;
	ctx->delete_vertex_elements_state = noop_delete_vertex_element;
	ctx->delete_vs_state = noop_delete_state;
	ctx->set_blend_color = noop_set_blend_color;
	ctx->set_clip_state = noop_set_clip_state;
	ctx->set_constant_buffer = noop_set_constant_buffer;
	ctx->set_sampler_views = noop_set_sampler_views;
	ctx->set_framebuffer_state = noop_set_framebuffer_state;
	ctx->set_polygon_stipple = noop_set_polygon_stipple;
	ctx->set_sample_mask = noop_set_sample_mask;
	ctx->set_scissor_states = noop_set_scissor_states;
	ctx->set_stencil_ref = noop_set_stencil_ref;
	ctx->set_vertex_buffers = noop_set_vertex_buffers;
	ctx->set_index_buffer = noop_set_index_buffer;
	ctx->set_viewport_states = noop_set_viewport_states;
	ctx->sampler_view_destroy = noop_sampler_view_destroy;
	ctx->surface_destroy = noop_surface_destroy;
	ctx->draw_vbo = noop_draw_vbo;
	ctx->create_stream_output_target = noop_create_stream_output_target;
	ctx->stream_output_target_destroy = noop_stream_output_target_destroy;
	ctx->set_stream_output_targets = noop_set_stream_output_targets;
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d47 1
a47 1
	if (!nstate) {
d59 1
a59 1
	if (!nstate) {
d71 1
a71 1
	if (!nstate) {
d83 1
a83 1
	if (!nstate) {
d96 1
a96 1
	if (!sampler_view)
d111 1
a111 1
	if (!surface)
d231 1
a231 1
	if (!nstate) {
d243 1
a243 1
	if (!nstate) {
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@a36 5
static void noop_launch_grid(struct pipe_context *ctx,
                             const struct pipe_grid_info *info)
{
}

d38 1
a38 1
                                 const struct pipe_blend_color *state)
d43 1
a43 1
                                     const struct pipe_blend_state *state)
d45 7
a51 1
   return MALLOC(1);
d55 1
a55 1
                                   const struct pipe_depth_stencil_alpha_state *state)
d57 7
a63 1
   return MALLOC(1);
d67 1
a67 1
                                  const struct pipe_rasterizer_state *state)
d69 7
a75 1
   return MALLOC(1);
d79 1
a79 1
                                       const struct pipe_sampler_state *state)
d81 7
a87 1
   return MALLOC(1);
d91 2
a92 2
                                                          struct pipe_resource *texture,
                                                          const struct pipe_sampler_view *state)
d94 1
a94 1
   struct pipe_sampler_view *sampler_view = CALLOC_STRUCT(pipe_sampler_view);
d96 7
a102 7
   if (!sampler_view)
      return NULL;
   /* initialize base object */
   pipe_resource_reference(&sampler_view->texture, texture);
   pipe_reference_init(&sampler_view->reference, 1);
   sampler_view->context = ctx;
   return sampler_view;
d106 2
a107 2
                                                struct pipe_resource *texture,
                                                const struct pipe_surface *surf_tmpl)
d109 1
a109 1
   struct pipe_surface *surface = CALLOC_STRUCT(pipe_surface);
d111 12
a122 12
   if (!surface)
      return NULL;
   pipe_reference_init(&surface->reference, 1);
   pipe_resource_reference(&surface->texture, texture);
   surface->context = ctx;
   surface->format = surf_tmpl->format;
   surface->width = texture->width0;
   surface->height = texture->height0;
   surface->texture = texture;
   surface->u.tex.first_layer = surf_tmpl->u.tex.first_layer;
   surface->u.tex.last_layer = surf_tmpl->u.tex.last_layer;
   surface->u.tex.level = surf_tmpl->u.tex.level;
d124 1
a124 1
   return surface;
d127 1
a127 2
static void noop_set_sampler_views(struct pipe_context *ctx,
                                   enum pipe_shader_type shader,
d133 1
a133 2
static void noop_bind_sampler_states(struct pipe_context *ctx,
                                     enum pipe_shader_type shader,
d140 1
a140 1
                                const struct pipe_clip_state *state)
d145 1
a145 1
                                     const struct pipe_poly_stipple *state)
d161 1
a161 1
                                 const struct pipe_stencil_ref *state)
d173 1
a173 1
                                       const struct pipe_framebuffer_state *state)
d178 2
a179 2
                                     uint shader, uint index,
                                     const struct pipe_constant_buffer *cb)
d185 1
a185 1
                                      struct pipe_sampler_view *state)
d187 2
a188 2
   pipe_resource_reference(&state->texture, NULL);
   FREE(state);
d193 1
a193 1
                                 struct pipe_surface *surface)
d195 2
a196 2
   pipe_resource_reference(&surface->texture, NULL);
   FREE(surface);
d205 6
a210 1
   FREE(state);
d213 1
d215 1
a215 1
                                  const struct pipe_index_buffer *ib)
d220 2
a221 2
                                    unsigned start_slot, unsigned count,
                                    const struct pipe_vertex_buffer *buffers)
d226 2
a227 2
                                         unsigned count,
                                         const struct pipe_vertex_element *state)
d229 7
a235 1
   return MALLOC(1);
d239 1
a239 1
                                      const struct pipe_shader_state *state)
d241 1
a241 2
   return MALLOC(1);
}
d243 5
a247 4
static void *noop_create_compute_state(struct pipe_context *ctx,
                                       const struct pipe_compute_state *state)
{
   return MALLOC(1);
d268 1
a268 1
                                              struct pipe_stream_output_target *t)
d275 3
a277 3
                                           unsigned num_targets,
                                           struct pipe_stream_output_target **targets,
                                           const unsigned *offsets)
d285 41
a325 54
   ctx->create_blend_state = noop_create_blend_state;
   ctx->create_depth_stencil_alpha_state = noop_create_dsa_state;
   ctx->create_fs_state = noop_create_shader_state;
   ctx->create_rasterizer_state = noop_create_rs_state;
   ctx->create_sampler_state = noop_create_sampler_state;
   ctx->create_sampler_view = noop_create_sampler_view;
   ctx->create_surface = noop_create_surface;
   ctx->create_vertex_elements_state = noop_create_vertex_elements;
   ctx->create_compute_state = noop_create_compute_state;
   ctx->create_tcs_state = noop_create_shader_state;
   ctx->create_tes_state = noop_create_shader_state;
   ctx->create_gs_state = noop_create_shader_state;
   ctx->create_vs_state = noop_create_shader_state;
   ctx->bind_blend_state = noop_bind_state;
   ctx->bind_depth_stencil_alpha_state = noop_bind_state;
   ctx->bind_sampler_states = noop_bind_sampler_states;
   ctx->bind_fs_state = noop_bind_state;
   ctx->bind_rasterizer_state = noop_bind_state;
   ctx->bind_vertex_elements_state = noop_bind_state;
   ctx->bind_compute_state = noop_bind_state;
   ctx->bind_tcs_state = noop_bind_state;
   ctx->bind_tes_state = noop_bind_state;
   ctx->bind_gs_state = noop_bind_state;
   ctx->bind_vs_state = noop_bind_state;
   ctx->delete_blend_state = noop_delete_state;
   ctx->delete_depth_stencil_alpha_state = noop_delete_state;
   ctx->delete_fs_state = noop_delete_state;
   ctx->delete_rasterizer_state = noop_delete_state;
   ctx->delete_sampler_state = noop_delete_state;
   ctx->delete_vertex_elements_state = noop_delete_state;
   ctx->delete_compute_state = noop_delete_state;
   ctx->delete_tcs_state = noop_delete_state;
   ctx->delete_tes_state = noop_delete_state;
   ctx->delete_gs_state = noop_delete_state;
   ctx->delete_vs_state = noop_delete_state;
   ctx->set_blend_color = noop_set_blend_color;
   ctx->set_clip_state = noop_set_clip_state;
   ctx->set_constant_buffer = noop_set_constant_buffer;
   ctx->set_sampler_views = noop_set_sampler_views;
   ctx->set_framebuffer_state = noop_set_framebuffer_state;
   ctx->set_polygon_stipple = noop_set_polygon_stipple;
   ctx->set_sample_mask = noop_set_sample_mask;
   ctx->set_scissor_states = noop_set_scissor_states;
   ctx->set_stencil_ref = noop_set_stencil_ref;
   ctx->set_vertex_buffers = noop_set_vertex_buffers;
   ctx->set_index_buffer = noop_set_index_buffer;
   ctx->set_viewport_states = noop_set_viewport_states;
   ctx->sampler_view_destroy = noop_sampler_view_destroy;
   ctx->surface_destroy = noop_surface_destroy;
   ctx->draw_vbo = noop_draw_vbo;
   ctx->launch_grid = noop_launch_grid;
   ctx->create_stream_output_target = noop_create_stream_output_target;
   ctx->stream_output_target_destroy = noop_stream_output_target_destroy;
   ctx->set_stream_output_targets = noop_set_stream_output_targets;
@


