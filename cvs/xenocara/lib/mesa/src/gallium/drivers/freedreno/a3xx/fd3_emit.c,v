head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	mesa-17_1_6:1.1.1.4
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.24;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.45.21;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.45.21;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.21.02;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.29.56;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.08.14.09.34.30;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/* -*- mode: C; c-file-style: "k&r"; tab-width 4; indent-tabs-mode: t; -*- */

/*
 * Copyright (C) 2013 Rob Clark <robclark@@freedesktop.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Rob Clark <robclark@@freedesktop.org>
 */

#include "pipe/p_state.h"
#include "util/u_string.h"
#include "util/u_memory.h"
#include "util/u_helpers.h"
#include "util/u_format.h"
#include "util/u_viewport.h"

#include "freedreno_resource.h"
#include "freedreno_query_hw.h"

#include "fd3_emit.h"
#include "fd3_blend.h"
#include "fd3_context.h"
#include "fd3_program.h"
#include "fd3_rasterizer.h"
#include "fd3_texture.h"
#include "fd3_format.h"
#include "fd3_zsa.h"

static const enum adreno_state_block sb[] = {
	[SHADER_VERTEX]   = SB_VERT_SHADER,
	[SHADER_FRAGMENT] = SB_FRAG_SHADER,
};

/* regid:          base const register
 * prsc or dwords: buffer containing constant values
 * sizedwords:     size of const value buffer
 */
void
fd3_emit_const(struct fd_ringbuffer *ring, enum shader_t type,
		uint32_t regid, uint32_t offset, uint32_t sizedwords,
		const uint32_t *dwords, struct pipe_resource *prsc)
{
	uint32_t i, sz;
	enum adreno_state_src src;

	debug_assert((regid % 4) == 0);
	debug_assert((sizedwords % 4) == 0);

	if (prsc) {
		sz = 0;
		src = SS_INDIRECT;
	} else {
		sz = sizedwords;
		src = SS_DIRECT;
	}

	OUT_PKT3(ring, CP_LOAD_STATE, 2 + sz);
	OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(regid/2) |
			CP_LOAD_STATE_0_STATE_SRC(src) |
			CP_LOAD_STATE_0_STATE_BLOCK(sb[type]) |
			CP_LOAD_STATE_0_NUM_UNIT(sizedwords/2));
	if (prsc) {
		struct fd_bo *bo = fd_resource(prsc)->bo;
		OUT_RELOC(ring, bo, offset,
				CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS), 0);
	} else {
		OUT_RING(ring, CP_LOAD_STATE_1_EXT_SRC_ADDR(0) |
				CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS));
		dwords = (uint32_t *)&((uint8_t *)dwords)[offset];
	}
	for (i = 0; i < sz; i++) {
		OUT_RING(ring, dwords[i]);
	}
}

static void
fd3_emit_const_bo(struct fd_ringbuffer *ring, enum shader_t type, boolean write,
		uint32_t regid, uint32_t num, struct pipe_resource **prscs, uint32_t *offsets)
{
	uint32_t i;

	debug_assert((regid % 4) == 0);
	debug_assert((num % 4) == 0);

	OUT_PKT3(ring, CP_LOAD_STATE, 2 + num);
	OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(regid/2) |
			CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
			CP_LOAD_STATE_0_STATE_BLOCK(sb[type]) |
			CP_LOAD_STATE_0_NUM_UNIT(num/2));
	OUT_RING(ring, CP_LOAD_STATE_1_EXT_SRC_ADDR(0) |
			CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS));

	for (i = 0; i < num; i++) {
		if (prscs[i]) {
			if (write) {
				OUT_RELOCW(ring, fd_resource(prscs[i])->bo, offsets[i], 0, 0);
			} else {
				OUT_RELOC(ring, fd_resource(prscs[i])->bo, offsets[i], 0, 0);
			}
		} else {
			OUT_RING(ring, 0xbad00000 | (i << 16));
		}
	}
}

#define VERT_TEX_OFF    0
#define FRAG_TEX_OFF    16
#define BASETABLE_SZ    A3XX_MAX_MIP_LEVELS

static void
emit_textures(struct fd_context *ctx, struct fd_ringbuffer *ring,
		enum adreno_state_block sb, struct fd_texture_stateobj *tex)
{
	static const unsigned tex_off[] = {
			[SB_VERT_TEX] = VERT_TEX_OFF,
			[SB_FRAG_TEX] = FRAG_TEX_OFF,
	};
	static const enum adreno_state_block mipaddr[] = {
			[SB_VERT_TEX] = SB_VERT_MIPADDR,
			[SB_FRAG_TEX] = SB_FRAG_MIPADDR,
	};
	static const uint32_t bcolor_reg[] = {
			[SB_VERT_TEX] = REG_A3XX_TPL1_TP_VS_BORDER_COLOR_BASE_ADDR,
			[SB_FRAG_TEX] = REG_A3XX_TPL1_TP_FS_BORDER_COLOR_BASE_ADDR,
	};
	struct fd3_context *fd3_ctx = fd3_context(ctx);
	bool needs_border = false;
	unsigned i, j;

	if (tex->num_samplers > 0) {
		/* output sampler state: */
		OUT_PKT3(ring, CP_LOAD_STATE, 2 + (2 * tex->num_samplers));
		OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(tex_off[sb]) |
				CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
				CP_LOAD_STATE_0_STATE_BLOCK(sb) |
				CP_LOAD_STATE_0_NUM_UNIT(tex->num_samplers));
		OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_SHADER) |
				CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
		for (i = 0; i < tex->num_samplers; i++) {
			static const struct fd3_sampler_stateobj dummy_sampler = {};
			const struct fd3_sampler_stateobj *sampler = tex->samplers[i] ?
					fd3_sampler_stateobj(tex->samplers[i]) :
					&dummy_sampler;

			OUT_RING(ring, sampler->texsamp0);
			OUT_RING(ring, sampler->texsamp1);

			needs_border |= sampler->needs_border;
		}
	}

	if (tex->num_textures > 0) {
		/* emit texture state: */
		OUT_PKT3(ring, CP_LOAD_STATE, 2 + (4 * tex->num_textures));
		OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(tex_off[sb]) |
				CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
				CP_LOAD_STATE_0_STATE_BLOCK(sb) |
				CP_LOAD_STATE_0_NUM_UNIT(tex->num_textures));
		OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS) |
				CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
		for (i = 0; i < tex->num_textures; i++) {
			static const struct fd3_pipe_sampler_view dummy_view = {};
			const struct fd3_pipe_sampler_view *view = tex->textures[i] ?
					fd3_pipe_sampler_view(tex->textures[i]) :
					&dummy_view;
			OUT_RING(ring, view->texconst0);
			OUT_RING(ring, view->texconst1);
			OUT_RING(ring, view->texconst2 |
					A3XX_TEX_CONST_2_INDX(BASETABLE_SZ * i));
			OUT_RING(ring, view->texconst3);
		}

		/* emit mipaddrs: */
		OUT_PKT3(ring, CP_LOAD_STATE, 2 + (BASETABLE_SZ * tex->num_textures));
		OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(BASETABLE_SZ * tex_off[sb]) |
				CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
				CP_LOAD_STATE_0_STATE_BLOCK(mipaddr[sb]) |
				CP_LOAD_STATE_0_NUM_UNIT(BASETABLE_SZ * tex->num_textures));
		OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS) |
				CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
		for (i = 0; i < tex->num_textures; i++) {
			static const struct fd3_pipe_sampler_view dummy_view = {
					.base.target = PIPE_TEXTURE_1D, /* anything !PIPE_BUFFER */
					.base.u.tex.first_level = 1,
			};
			const struct fd3_pipe_sampler_view *view = tex->textures[i] ?
					fd3_pipe_sampler_view(tex->textures[i]) :
					&dummy_view;
			struct fd_resource *rsc = fd_resource(view->base.texture);
			if (rsc && rsc->base.b.target == PIPE_BUFFER) {
				OUT_RELOC(ring, rsc->bo, view->base.u.buf.offset, 0, 0);
				j = 1;
			} else {
				unsigned start = fd_sampler_first_level(&view->base);
				unsigned end   = fd_sampler_last_level(&view->base);

				for (j = 0; j < (end - start + 1); j++) {
					struct fd_resource_slice *slice =
						fd_resource_slice(rsc, j + start);
					OUT_RELOC(ring, rsc->bo, slice->offset, 0, 0);
				}
			}

			/* pad the remaining entries w/ null: */
			for (; j < BASETABLE_SZ; j++) {
				OUT_RING(ring, 0x00000000);
			}
		}
	}

	if (needs_border) {
		unsigned off;
		void *ptr;

		u_upload_alloc(fd3_ctx->border_color_uploader,
				0, BORDER_COLOR_UPLOAD_SIZE,
			       BORDER_COLOR_UPLOAD_SIZE, &off,
				&fd3_ctx->border_color_buf,
				&ptr);

		fd_setup_border_colors(tex, ptr, tex_off[sb]);

		OUT_PKT0(ring, bcolor_reg[sb], 1);
		OUT_RELOC(ring, fd_resource(fd3_ctx->border_color_buf)->bo, off, 0, 0);

		u_upload_unmap(fd3_ctx->border_color_uploader);
	}
}

/* emit texture state for mem->gmem restore operation.. eventually it would
 * be good to get rid of this and use normal CSO/etc state for more of these
 * special cases, but for now the compiler is not sufficient..
 *
 * Also, for using normal state, not quite sure how to handle the special
 * case format (fd3_gmem_restore_format()) stuff for restoring depth/stencil.
 */
void
fd3_emit_gmem_restore_tex(struct fd_ringbuffer *ring,
						  struct pipe_surface **psurf,
						  int bufs)
{
	int i, j;

	/* output sampler state: */
	OUT_PKT3(ring, CP_LOAD_STATE, 2 + 2 * bufs);
	OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(FRAG_TEX_OFF) |
			CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
			CP_LOAD_STATE_0_STATE_BLOCK(SB_FRAG_TEX) |
			CP_LOAD_STATE_0_NUM_UNIT(bufs));
	OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_SHADER) |
			CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
	for (i = 0; i < bufs; i++) {
		OUT_RING(ring, A3XX_TEX_SAMP_0_XY_MAG(A3XX_TEX_NEAREST) |
				 A3XX_TEX_SAMP_0_XY_MIN(A3XX_TEX_NEAREST) |
				 A3XX_TEX_SAMP_0_WRAP_S(A3XX_TEX_CLAMP_TO_EDGE) |
				 A3XX_TEX_SAMP_0_WRAP_T(A3XX_TEX_CLAMP_TO_EDGE) |
				 A3XX_TEX_SAMP_0_WRAP_R(A3XX_TEX_REPEAT));
		OUT_RING(ring, 0x00000000);
	}

	/* emit texture state: */
	OUT_PKT3(ring, CP_LOAD_STATE, 2 + 4 * bufs);
	OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(FRAG_TEX_OFF) |
			CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
			CP_LOAD_STATE_0_STATE_BLOCK(SB_FRAG_TEX) |
			CP_LOAD_STATE_0_NUM_UNIT(bufs));
	OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS) |
			CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
	for (i = 0; i < bufs; i++) {
		if (!psurf[i]) {
			OUT_RING(ring, A3XX_TEX_CONST_0_TYPE(A3XX_TEX_2D) |
				A3XX_TEX_CONST_0_SWIZ_X(A3XX_TEX_ONE) |
				A3XX_TEX_CONST_0_SWIZ_Y(A3XX_TEX_ONE) |
				A3XX_TEX_CONST_0_SWIZ_Z(A3XX_TEX_ONE) |
				A3XX_TEX_CONST_0_SWIZ_W(A3XX_TEX_ONE));
			OUT_RING(ring, 0x00000000);
			OUT_RING(ring, A3XX_TEX_CONST_2_INDX(BASETABLE_SZ * i));
			OUT_RING(ring, 0x00000000);
			continue;
		}

		struct fd_resource *rsc = fd_resource(psurf[i]->texture);
		enum pipe_format format = fd3_gmem_restore_format(psurf[i]->format);
		/* The restore blit_zs shader expects stencil in sampler 0, and depth
		 * in sampler 1
		 */
		if (rsc->stencil && i == 0) {
			rsc = rsc->stencil;
			format = fd3_gmem_restore_format(rsc->base.b.format);
		}

		/* note: PIPE_BUFFER disallowed for surfaces */
		unsigned lvl = psurf[i]->u.tex.level;
		struct fd_resource_slice *slice = fd_resource_slice(rsc, lvl);

		debug_assert(psurf[i]->u.tex.first_layer == psurf[i]->u.tex.last_layer);

		OUT_RING(ring, A3XX_TEX_CONST_0_FMT(fd3_pipe2tex(format)) |
				 A3XX_TEX_CONST_0_TYPE(A3XX_TEX_2D) |
				 fd3_tex_swiz(format,  PIPE_SWIZZLE_X, PIPE_SWIZZLE_Y,
							  PIPE_SWIZZLE_Z, PIPE_SWIZZLE_W));
		OUT_RING(ring, A3XX_TEX_CONST_1_FETCHSIZE(TFETCH_DISABLE) |
				 A3XX_TEX_CONST_1_WIDTH(psurf[i]->width) |
				 A3XX_TEX_CONST_1_HEIGHT(psurf[i]->height));
		OUT_RING(ring, A3XX_TEX_CONST_2_PITCH(slice->pitch * rsc->cpp) |
				 A3XX_TEX_CONST_2_INDX(BASETABLE_SZ * i));
		OUT_RING(ring, 0x00000000);
	}

	/* emit mipaddrs: */
	OUT_PKT3(ring, CP_LOAD_STATE, 2 + BASETABLE_SZ * bufs);
	OUT_RING(ring, CP_LOAD_STATE_0_DST_OFF(BASETABLE_SZ * FRAG_TEX_OFF) |
			CP_LOAD_STATE_0_STATE_SRC(SS_DIRECT) |
			CP_LOAD_STATE_0_STATE_BLOCK(SB_FRAG_MIPADDR) |
			CP_LOAD_STATE_0_NUM_UNIT(BASETABLE_SZ * bufs));
	OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS) |
			CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
	for (i = 0; i < bufs; i++) {
		if (psurf[i]) {
			struct fd_resource *rsc = fd_resource(psurf[i]->texture);
			/* Matches above logic for blit_zs shader */
			if (rsc->stencil && i == 0)
				rsc = rsc->stencil;
			unsigned lvl = psurf[i]->u.tex.level;
			uint32_t offset = fd_resource_offset(rsc, lvl, psurf[i]->u.tex.first_layer);
			OUT_RELOC(ring, rsc->bo, offset, 0, 0);
		} else {
			OUT_RING(ring, 0x00000000);
		}

		/* pad the remaining entries w/ null: */
		for (j = 1; j < BASETABLE_SZ; j++) {
			OUT_RING(ring, 0x00000000);
		}
	}
}

void
fd3_emit_vertex_bufs(struct fd_ringbuffer *ring, struct fd3_emit *emit)
{
	int32_t i, j, last = -1;
	uint32_t total_in = 0;
	const struct fd_vertex_state *vtx = emit->vtx;
	const struct ir3_shader_variant *vp = fd3_emit_get_vp(emit);
	unsigned vertex_regid = regid(63, 0);
	unsigned instance_regid = regid(63, 0);
	unsigned vtxcnt_regid = regid(63, 0);

	/* Note that sysvals come *after* normal inputs: */
	for (i = 0; i < vp->inputs_count; i++) {
		if (!vp->inputs[i].compmask)
			continue;
		if (vp->inputs[i].sysval) {
			switch(vp->inputs[i].slot) {
			case SYSTEM_VALUE_BASE_VERTEX:
				/* handled elsewhere */
				break;
			case SYSTEM_VALUE_VERTEX_ID_ZERO_BASE:
				vertex_regid = vp->inputs[i].regid;
				break;
			case SYSTEM_VALUE_INSTANCE_ID:
				instance_regid = vp->inputs[i].regid;
				break;
			case SYSTEM_VALUE_VERTEX_CNT:
				vtxcnt_regid = vp->inputs[i].regid;
				break;
			default:
				unreachable("invalid system value");
				break;
			}
		} else if (i < vtx->vtx->num_elements) {
			last = i;
		}
	}

	for (i = 0, j = 0; i <= last; i++) {
		assert(!vp->inputs[i].sysval);
		if (vp->inputs[i].compmask) {
			struct pipe_vertex_element *elem = &vtx->vtx->pipe[i];
			const struct pipe_vertex_buffer *vb =
					&vtx->vertexbuf.vb[elem->vertex_buffer_index];
			struct fd_resource *rsc = fd_resource(vb->buffer);
			enum pipe_format pfmt = elem->src_format;
			enum a3xx_vtx_fmt fmt = fd3_pipe2vtx(pfmt);
			bool switchnext = (i != last) ||
					(vertex_regid != regid(63, 0)) ||
					(instance_regid != regid(63, 0)) ||
					(vtxcnt_regid != regid(63, 0));
			bool isint = util_format_is_pure_integer(pfmt);
			uint32_t fs = util_format_get_blocksize(pfmt);

			debug_assert(fmt != ~0);

			OUT_PKT0(ring, REG_A3XX_VFD_FETCH(j), 2);
			OUT_RING(ring, A3XX_VFD_FETCH_INSTR_0_FETCHSIZE(fs - 1) |
					A3XX_VFD_FETCH_INSTR_0_BUFSTRIDE(vb->stride) |
					COND(switchnext, A3XX_VFD_FETCH_INSTR_0_SWITCHNEXT) |
					A3XX_VFD_FETCH_INSTR_0_INDEXCODE(j) |
					COND(elem->instance_divisor, A3XX_VFD_FETCH_INSTR_0_INSTANCED) |
					A3XX_VFD_FETCH_INSTR_0_STEPRATE(MAX2(1, elem->instance_divisor)));
			OUT_RELOC(ring, rsc->bo, vb->buffer_offset + elem->src_offset, 0, 0);

			OUT_PKT0(ring, REG_A3XX_VFD_DECODE_INSTR(j), 1);
			OUT_RING(ring, A3XX_VFD_DECODE_INSTR_CONSTFILL |
					A3XX_VFD_DECODE_INSTR_WRITEMASK(vp->inputs[i].compmask) |
					A3XX_VFD_DECODE_INSTR_FORMAT(fmt) |
					A3XX_VFD_DECODE_INSTR_SWAP(fd3_pipe2swap(pfmt)) |
					A3XX_VFD_DECODE_INSTR_REGID(vp->inputs[i].regid) |
					A3XX_VFD_DECODE_INSTR_SHIFTCNT(fs) |
					A3XX_VFD_DECODE_INSTR_LASTCOMPVALID |
					COND(isint, A3XX_VFD_DECODE_INSTR_INT) |
					COND(switchnext, A3XX_VFD_DECODE_INSTR_SWITCHNEXT));

			total_in += vp->inputs[i].ncomp;
			j++;
		}
	}

	/* hw doesn't like to be configured for zero vbo's, it seems: */
	if (last < 0) {
		/* just recycle the shader bo, we just need to point to *something*
		 * valid:
		 */
		struct fd_bo *dummy_vbo = vp->bo;
		bool switchnext = (vertex_regid != regid(63, 0)) ||
				(instance_regid != regid(63, 0)) ||
				(vtxcnt_regid != regid(63, 0));

		OUT_PKT0(ring, REG_A3XX_VFD_FETCH(0), 2);
		OUT_RING(ring, A3XX_VFD_FETCH_INSTR_0_FETCHSIZE(0) |
				A3XX_VFD_FETCH_INSTR_0_BUFSTRIDE(0) |
				COND(switchnext, A3XX_VFD_FETCH_INSTR_0_SWITCHNEXT) |
				A3XX_VFD_FETCH_INSTR_0_INDEXCODE(0) |
				A3XX_VFD_FETCH_INSTR_0_STEPRATE(1));
		OUT_RELOC(ring, dummy_vbo, 0, 0, 0);

		OUT_PKT0(ring, REG_A3XX_VFD_DECODE_INSTR(0), 1);
		OUT_RING(ring, A3XX_VFD_DECODE_INSTR_CONSTFILL |
				A3XX_VFD_DECODE_INSTR_WRITEMASK(0x1) |
				A3XX_VFD_DECODE_INSTR_FORMAT(VFMT_8_UNORM) |
				A3XX_VFD_DECODE_INSTR_SWAP(XYZW) |
				A3XX_VFD_DECODE_INSTR_REGID(regid(0,0)) |
				A3XX_VFD_DECODE_INSTR_SHIFTCNT(1) |
				A3XX_VFD_DECODE_INSTR_LASTCOMPVALID |
				COND(switchnext, A3XX_VFD_DECODE_INSTR_SWITCHNEXT));

		total_in = 1;
		j = 1;
	}

	OUT_PKT0(ring, REG_A3XX_VFD_CONTROL_0, 2);
	OUT_RING(ring, A3XX_VFD_CONTROL_0_TOTALATTRTOVS(total_in) |
			A3XX_VFD_CONTROL_0_PACKETSIZE(2) |
			A3XX_VFD_CONTROL_0_STRMDECINSTRCNT(j) |
			A3XX_VFD_CONTROL_0_STRMFETCHINSTRCNT(j));
	OUT_RING(ring, A3XX_VFD_CONTROL_1_MAXSTORAGE(1) | // XXX
			A3XX_VFD_CONTROL_1_REGID4VTX(vertex_regid) |
			A3XX_VFD_CONTROL_1_REGID4INST(instance_regid));

	OUT_PKT0(ring, REG_A3XX_VFD_VS_THREADING_THRESHOLD, 1);
	OUT_RING(ring, A3XX_VFD_VS_THREADING_THRESHOLD_REGID_THRESHOLD(15) |
			A3XX_VFD_VS_THREADING_THRESHOLD_REGID_VTXCNT(vtxcnt_regid));
}

void
fd3_emit_state(struct fd_context *ctx, struct fd_ringbuffer *ring,
		struct fd3_emit *emit)
{
	const struct ir3_shader_variant *vp = fd3_emit_get_vp(emit);
	const struct ir3_shader_variant *fp = fd3_emit_get_fp(emit);
	uint32_t dirty = emit->dirty;

	emit_marker(ring, 5);

	if (dirty & FD_DIRTY_SAMPLE_MASK) {
		OUT_PKT0(ring, REG_A3XX_RB_MSAA_CONTROL, 1);
		OUT_RING(ring, A3XX_RB_MSAA_CONTROL_DISABLE |
				A3XX_RB_MSAA_CONTROL_SAMPLES(MSAA_ONE) |
				A3XX_RB_MSAA_CONTROL_SAMPLE_MASK(ctx->sample_mask));
	}

	if ((dirty & (FD_DIRTY_ZSA | FD_DIRTY_PROG | FD_DIRTY_BLEND_DUAL)) &&
		!emit->key.binning_pass) {
		uint32_t val = fd3_zsa_stateobj(ctx->zsa)->rb_render_control |
			fd3_blend_stateobj(ctx->blend)->rb_render_control;

		val |= COND(fp->frag_face, A3XX_RB_RENDER_CONTROL_FACENESS);
		val |= COND(fp->frag_coord, A3XX_RB_RENDER_CONTROL_XCOORD |
				A3XX_RB_RENDER_CONTROL_YCOORD |
				A3XX_RB_RENDER_CONTROL_ZCOORD |
				A3XX_RB_RENDER_CONTROL_WCOORD);

		/* I suppose if we needed to (which I don't *think* we need
		 * to), we could emit this for binning pass too.  But we
		 * would need to keep a different patch-list for binning
		 * vs render pass.
		 */

		OUT_PKT0(ring, REG_A3XX_RB_RENDER_CONTROL, 1);
		OUT_RINGP(ring, val, &ctx->batch->rbrc_patches);
	}

	if (dirty & (FD_DIRTY_ZSA | FD_DIRTY_STENCIL_REF)) {
		struct fd3_zsa_stateobj *zsa = fd3_zsa_stateobj(ctx->zsa);
		struct pipe_stencil_ref *sr = &ctx->stencil_ref;

		OUT_PKT0(ring, REG_A3XX_RB_ALPHA_REF, 1);
		OUT_RING(ring, zsa->rb_alpha_ref);

		OUT_PKT0(ring, REG_A3XX_RB_STENCIL_CONTROL, 1);
		OUT_RING(ring, zsa->rb_stencil_control);

		OUT_PKT0(ring, REG_A3XX_RB_STENCILREFMASK, 2);
		OUT_RING(ring, zsa->rb_stencilrefmask |
				A3XX_RB_STENCILREFMASK_STENCILREF(sr->ref_value[0]));
		OUT_RING(ring, zsa->rb_stencilrefmask_bf |
				A3XX_RB_STENCILREFMASK_BF_STENCILREF(sr->ref_value[1]));
	}

	if (dirty & (FD_DIRTY_ZSA | FD_DIRTY_RASTERIZER | FD_DIRTY_PROG)) {
		uint32_t val = fd3_zsa_stateobj(ctx->zsa)->rb_depth_control;
		if (fp->writes_pos) {
			val |= A3XX_RB_DEPTH_CONTROL_FRAG_WRITES_Z;
			val |= A3XX_RB_DEPTH_CONTROL_EARLY_Z_DISABLE;
		}
		if (fp->has_kill) {
			val |= A3XX_RB_DEPTH_CONTROL_EARLY_Z_DISABLE;
		}
		if (!ctx->rasterizer->depth_clip) {
			val |= A3XX_RB_DEPTH_CONTROL_Z_CLAMP_ENABLE;
		}
		OUT_PKT0(ring, REG_A3XX_RB_DEPTH_CONTROL, 1);
		OUT_RING(ring, val);
	}

	if (dirty & FD_DIRTY_RASTERIZER) {
		struct fd3_rasterizer_stateobj *rasterizer =
				fd3_rasterizer_stateobj(ctx->rasterizer);

		OUT_PKT0(ring, REG_A3XX_GRAS_SU_MODE_CONTROL, 1);
		OUT_RING(ring, rasterizer->gras_su_mode_control);

		OUT_PKT0(ring, REG_A3XX_GRAS_SU_POINT_MINMAX, 2);
		OUT_RING(ring, rasterizer->gras_su_point_minmax);
		OUT_RING(ring, rasterizer->gras_su_point_size);

		OUT_PKT0(ring, REG_A3XX_GRAS_SU_POLY_OFFSET_SCALE, 2);
		OUT_RING(ring, rasterizer->gras_su_poly_offset_scale);
		OUT_RING(ring, rasterizer->gras_su_poly_offset_offset);
	}

	if (dirty & (FD_DIRTY_RASTERIZER | FD_DIRTY_PROG)) {
		uint32_t val = fd3_rasterizer_stateobj(ctx->rasterizer)
				->gras_cl_clip_cntl;
		uint8_t planes = ctx->rasterizer->clip_plane_enable;
		val |= COND(fp->writes_pos, A3XX_GRAS_CL_CLIP_CNTL_ZCLIP_DISABLE);
		val |= COND(fp->frag_coord, A3XX_GRAS_CL_CLIP_CNTL_ZCOORD |
				A3XX_GRAS_CL_CLIP_CNTL_WCOORD);
		if (!emit->key.ucp_enables)
			val |= A3XX_GRAS_CL_CLIP_CNTL_NUM_USER_CLIP_PLANES(
					MIN2(util_bitcount(planes), 6));
		OUT_PKT0(ring, REG_A3XX_GRAS_CL_CLIP_CNTL, 1);
		OUT_RING(ring, val);
	}

	if (dirty & (FD_DIRTY_RASTERIZER | FD_DIRTY_PROG | FD_DIRTY_UCP)) {
		uint32_t planes = ctx->rasterizer->clip_plane_enable;
		int count = 0;

		if (emit->key.ucp_enables)
			planes = 0;

		while (planes && count < 6) {
			int i = ffs(planes) - 1;

			planes &= ~(1U << i);
			fd_wfi(ctx->batch, ring);
			OUT_PKT0(ring, REG_A3XX_GRAS_CL_USER_PLANE(count++), 4);
			OUT_RING(ring, fui(ctx->ucp.ucp[i][0]));
			OUT_RING(ring, fui(ctx->ucp.ucp[i][1]));
			OUT_RING(ring, fui(ctx->ucp.ucp[i][2]));
			OUT_RING(ring, fui(ctx->ucp.ucp[i][3]));
		}
	}

	/* NOTE: since primitive_restart is not actually part of any
	 * state object, we need to make sure that we always emit
	 * PRIM_VTX_CNTL.. either that or be more clever and detect
	 * when it changes.
	 */
	if (emit->info) {
		const struct pipe_draw_info *info = emit->info;
		uint32_t val = fd3_rasterizer_stateobj(ctx->rasterizer)
				->pc_prim_vtx_cntl;

		if (!emit->key.binning_pass) {
			uint32_t stride_in_vpc = align(fp->total_in, 4) / 4;
			if (stride_in_vpc > 0)
				stride_in_vpc = MAX2(stride_in_vpc, 2);
			val |= A3XX_PC_PRIM_VTX_CNTL_STRIDE_IN_VPC(stride_in_vpc);
		}

		if (info->indexed && info->primitive_restart) {
			val |= A3XX_PC_PRIM_VTX_CNTL_PRIMITIVE_RESTART;
		}

		val |= COND(vp->writes_psize, A3XX_PC_PRIM_VTX_CNTL_PSIZE);

		OUT_PKT0(ring, REG_A3XX_PC_PRIM_VTX_CNTL, 1);
		OUT_RING(ring, val);
	}

	if (dirty & (FD_DIRTY_SCISSOR | FD_DIRTY_RASTERIZER | FD_DIRTY_VIEWPORT)) {
		struct pipe_scissor_state *scissor = fd_context_get_scissor(ctx);
		int minx = scissor->minx;
		int miny = scissor->miny;
		int maxx = scissor->maxx;
		int maxy = scissor->maxy;

		/* Unfortunately there is no separate depth clip disable, only an all
		 * or nothing deal. So when we disable clipping, we must handle the
		 * viewport clip via scissors.
		 */
		if (!ctx->rasterizer->depth_clip) {
			struct pipe_viewport_state *vp = &ctx->viewport;
			minx = MAX2(minx, (int)floorf(vp->translate[0] - fabsf(vp->scale[0])));
			miny = MAX2(miny, (int)floorf(vp->translate[1] - fabsf(vp->scale[1])));
			maxx = MIN2(maxx, (int)ceilf(vp->translate[0] + fabsf(vp->scale[0])));
			maxy = MIN2(maxy, (int)ceilf(vp->translate[1] + fabsf(vp->scale[1])));
		}

		OUT_PKT0(ring, REG_A3XX_GRAS_SC_WINDOW_SCISSOR_TL, 2);
		OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_TL_X(minx) |
				A3XX_GRAS_SC_WINDOW_SCISSOR_TL_Y(miny));
		OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_BR_X(maxx - 1) |
				A3XX_GRAS_SC_WINDOW_SCISSOR_BR_Y(maxy - 1));

		ctx->batch->max_scissor.minx = MIN2(ctx->batch->max_scissor.minx, minx);
		ctx->batch->max_scissor.miny = MIN2(ctx->batch->max_scissor.miny, miny);
		ctx->batch->max_scissor.maxx = MAX2(ctx->batch->max_scissor.maxx, maxx);
		ctx->batch->max_scissor.maxy = MAX2(ctx->batch->max_scissor.maxy, maxy);
	}

	if (dirty & FD_DIRTY_VIEWPORT) {
		fd_wfi(ctx->batch, ring);
		OUT_PKT0(ring, REG_A3XX_GRAS_CL_VPORT_XOFFSET, 6);
		OUT_RING(ring, A3XX_GRAS_CL_VPORT_XOFFSET(ctx->viewport.translate[0] - 0.5));
		OUT_RING(ring, A3XX_GRAS_CL_VPORT_XSCALE(ctx->viewport.scale[0]));
		OUT_RING(ring, A3XX_GRAS_CL_VPORT_YOFFSET(ctx->viewport.translate[1] - 0.5));
		OUT_RING(ring, A3XX_GRAS_CL_VPORT_YSCALE(ctx->viewport.scale[1]));
		OUT_RING(ring, A3XX_GRAS_CL_VPORT_ZOFFSET(ctx->viewport.translate[2]));
		OUT_RING(ring, A3XX_GRAS_CL_VPORT_ZSCALE(ctx->viewport.scale[2]));
	}

	if (dirty & (FD_DIRTY_VIEWPORT | FD_DIRTY_RASTERIZER | FD_DIRTY_FRAMEBUFFER)) {
		float zmin, zmax;
		int depth = 24;
		if (ctx->batch->framebuffer.zsbuf) {
			depth = util_format_get_component_bits(
					pipe_surface_format(ctx->batch->framebuffer.zsbuf),
					UTIL_FORMAT_COLORSPACE_ZS, 0);
		}
		util_viewport_zmin_zmax(&ctx->viewport, ctx->rasterizer->clip_halfz,
								&zmin, &zmax);

		OUT_PKT0(ring, REG_A3XX_RB_Z_CLAMP_MIN, 2);
		if (depth == 32) {
			OUT_RING(ring, (uint32_t)(zmin * 0xffffffff));
			OUT_RING(ring, (uint32_t)(zmax * 0xffffffff));
		} else if (depth == 16) {
			OUT_RING(ring, (uint32_t)(zmin * 0xffff));
			OUT_RING(ring, (uint32_t)(zmax * 0xffff));
		} else {
			OUT_RING(ring, (uint32_t)(zmin * 0xffffff));
			OUT_RING(ring, (uint32_t)(zmax * 0xffffff));
		}
	}

	if (dirty & (FD_DIRTY_PROG | FD_DIRTY_FRAMEBUFFER | FD_DIRTY_BLEND_DUAL)) {
		struct pipe_framebuffer_state *pfb = &ctx->batch->framebuffer;
		int nr_cbufs = pfb->nr_cbufs;
		if (fd3_blend_stateobj(ctx->blend)->rb_render_control &
			A3XX_RB_RENDER_CONTROL_DUAL_COLOR_IN_ENABLE)
			nr_cbufs++;
		fd3_program_emit(ring, emit, nr_cbufs, pfb->cbufs);
	}

	/* TODO we should not need this or fd_wfi() before emit_constants():
	 */
	OUT_PKT3(ring, CP_EVENT_WRITE, 1);
	OUT_RING(ring, HLSQ_FLUSH);

	if (emit->prog == &ctx->prog) { /* evil hack to deal sanely with clear path */
		ir3_emit_consts(vp, ring, ctx, emit->info, dirty);
		if (!emit->key.binning_pass)
			ir3_emit_consts(fp, ring, ctx, emit->info, dirty);
	}

	if (dirty & (FD_DIRTY_BLEND | FD_DIRTY_FRAMEBUFFER)) {
		struct fd3_blend_stateobj *blend = fd3_blend_stateobj(ctx->blend);
		uint32_t i;

		for (i = 0; i < ARRAY_SIZE(blend->rb_mrt); i++) {
			enum pipe_format format =
				pipe_surface_format(ctx->batch->framebuffer.cbufs[i]);
			const struct util_format_description *desc =
				util_format_description(format);
			bool is_float = util_format_is_float(format);
			bool is_int = util_format_is_pure_integer(format);
			bool has_alpha = util_format_has_alpha(format);
			uint32_t control = blend->rb_mrt[i].control;
			uint32_t blend_control = blend->rb_mrt[i].blend_control_alpha;

			if (is_int) {
				control &= (A3XX_RB_MRT_CONTROL_COMPONENT_ENABLE__MASK |
							A3XX_RB_MRT_CONTROL_DITHER_MODE__MASK);
				control |= A3XX_RB_MRT_CONTROL_ROP_CODE(ROP_COPY);
			}

			if (format == PIPE_FORMAT_NONE)
				control &= ~A3XX_RB_MRT_CONTROL_COMPONENT_ENABLE__MASK;

			if (has_alpha) {
				blend_control |= blend->rb_mrt[i].blend_control_rgb;
			} else {
				blend_control |= blend->rb_mrt[i].blend_control_no_alpha_rgb;
				control &= ~A3XX_RB_MRT_CONTROL_BLEND2;
			}

			if (format && util_format_get_component_bits(
						format, UTIL_FORMAT_COLORSPACE_RGB, 0) < 8) {
				const struct pipe_rt_blend_state *rt;
				if (ctx->blend->independent_blend_enable)
					rt = &ctx->blend->rt[i];
				else
					rt = &ctx->blend->rt[0];

				if (!util_format_colormask_full(desc, rt->colormask))
					control |= A3XX_RB_MRT_CONTROL_READ_DEST_ENABLE;
			}

			OUT_PKT0(ring, REG_A3XX_RB_MRT_CONTROL(i), 1);
			OUT_RING(ring, control);

			OUT_PKT0(ring, REG_A3XX_RB_MRT_BLEND_CONTROL(i), 1);
			OUT_RING(ring, blend_control |
					COND(!is_float, A3XX_RB_MRT_BLEND_CONTROL_CLAMP_ENABLE));
		}
	}

	if (dirty & FD_DIRTY_BLEND_COLOR) {
		struct pipe_blend_color *bcolor = &ctx->blend_color;
		OUT_PKT0(ring, REG_A3XX_RB_BLEND_RED, 4);
		OUT_RING(ring, A3XX_RB_BLEND_RED_UINT(bcolor->color[0] * 255.0) |
				A3XX_RB_BLEND_RED_FLOAT(bcolor->color[0]));
		OUT_RING(ring, A3XX_RB_BLEND_GREEN_UINT(bcolor->color[1] * 255.0) |
				A3XX_RB_BLEND_GREEN_FLOAT(bcolor->color[1]));
		OUT_RING(ring, A3XX_RB_BLEND_BLUE_UINT(bcolor->color[2] * 255.0) |
				A3XX_RB_BLEND_BLUE_FLOAT(bcolor->color[2]));
		OUT_RING(ring, A3XX_RB_BLEND_ALPHA_UINT(bcolor->color[3] * 255.0) |
				A3XX_RB_BLEND_ALPHA_FLOAT(bcolor->color[3]));
	}

	if (dirty & (FD_DIRTY_VERTTEX | FD_DIRTY_FRAGTEX))
		fd_wfi(ctx->batch, ring);

	if (dirty & FD_DIRTY_VERTTEX) {
		if (vp->has_samp)
			emit_textures(ctx, ring, SB_VERT_TEX, &ctx->verttex);
		else
			dirty &= ~FD_DIRTY_VERTTEX;
	}

	if (dirty & FD_DIRTY_FRAGTEX) {
		if (fp->has_samp)
			emit_textures(ctx, ring, SB_FRAG_TEX, &ctx->fragtex);
		else
			dirty &= ~FD_DIRTY_FRAGTEX;
	}

	ctx->dirty &= ~dirty;
}

/* emit setup at begin of new cmdstream buffer (don't rely on previous
 * state, there could have been a context switch between ioctls):
 */
void
fd3_emit_restore(struct fd_batch *batch, struct fd_ringbuffer *ring)
{
	struct fd_context *ctx = batch->ctx;
	struct fd3_context *fd3_ctx = fd3_context(ctx);
	int i;

	if (ctx->screen->gpu_id == 320) {
		OUT_PKT3(ring, CP_REG_RMW, 3);
		OUT_RING(ring, REG_A3XX_RBBM_CLOCK_CTL);
		OUT_RING(ring, 0xfffcffff);
		OUT_RING(ring, 0x00000000);
	}

	fd_wfi(batch, ring);
	OUT_PKT3(ring, CP_INVALIDATE_STATE, 1);
	OUT_RING(ring, 0x00007fff);

	OUT_PKT0(ring, REG_A3XX_SP_VS_PVT_MEM_PARAM_REG, 3);
	OUT_RING(ring, 0x08000001);                  /* SP_VS_PVT_MEM_CTRL_REG */
	OUT_RELOC(ring, fd3_ctx->vs_pvt_mem, 0,0,0); /* SP_VS_PVT_MEM_ADDR_REG */
	OUT_RING(ring, 0x00000000);                  /* SP_VS_PVT_MEM_SIZE_REG */

	OUT_PKT0(ring, REG_A3XX_SP_FS_PVT_MEM_PARAM_REG, 3);
	OUT_RING(ring, 0x08000001);                  /* SP_FS_PVT_MEM_CTRL_REG */
	OUT_RELOC(ring, fd3_ctx->fs_pvt_mem, 0,0,0); /* SP_FS_PVT_MEM_ADDR_REG */
	OUT_RING(ring, 0x00000000);                  /* SP_FS_PVT_MEM_SIZE_REG */

	OUT_PKT0(ring, REG_A3XX_PC_VERTEX_REUSE_BLOCK_CNTL, 1);
	OUT_RING(ring, 0x0000000b);                  /* PC_VERTEX_REUSE_BLOCK_CNTL */

	OUT_PKT0(ring, REG_A3XX_GRAS_SC_CONTROL, 1);
	OUT_RING(ring, A3XX_GRAS_SC_CONTROL_RENDER_MODE(RB_RENDERING_PASS) |
			A3XX_GRAS_SC_CONTROL_MSAA_SAMPLES(MSAA_ONE) |
			A3XX_GRAS_SC_CONTROL_RASTER_MODE(0));

	OUT_PKT0(ring, REG_A3XX_RB_MSAA_CONTROL, 2);
	OUT_RING(ring, A3XX_RB_MSAA_CONTROL_DISABLE |
			A3XX_RB_MSAA_CONTROL_SAMPLES(MSAA_ONE) |
			A3XX_RB_MSAA_CONTROL_SAMPLE_MASK(0xffff));
	OUT_RING(ring, 0x00000000);        /* RB_ALPHA_REF */

	OUT_PKT0(ring, REG_A3XX_GRAS_CL_GB_CLIP_ADJ, 1);
	OUT_RING(ring, A3XX_GRAS_CL_GB_CLIP_ADJ_HORZ(0) |
			A3XX_GRAS_CL_GB_CLIP_ADJ_VERT(0));

	OUT_PKT0(ring, REG_A3XX_GRAS_TSE_DEBUG_ECO, 1);
	OUT_RING(ring, 0x00000001);        /* GRAS_TSE_DEBUG_ECO */

	OUT_PKT0(ring, REG_A3XX_TPL1_TP_VS_TEX_OFFSET, 1);
	OUT_RING(ring, A3XX_TPL1_TP_VS_TEX_OFFSET_SAMPLEROFFSET(VERT_TEX_OFF) |
			A3XX_TPL1_TP_VS_TEX_OFFSET_MEMOBJOFFSET(VERT_TEX_OFF) |
			A3XX_TPL1_TP_VS_TEX_OFFSET_BASETABLEPTR(BASETABLE_SZ * VERT_TEX_OFF));

	OUT_PKT0(ring, REG_A3XX_TPL1_TP_FS_TEX_OFFSET, 1);
	OUT_RING(ring, A3XX_TPL1_TP_FS_TEX_OFFSET_SAMPLEROFFSET(FRAG_TEX_OFF) |
			A3XX_TPL1_TP_FS_TEX_OFFSET_MEMOBJOFFSET(FRAG_TEX_OFF) |
			A3XX_TPL1_TP_FS_TEX_OFFSET_BASETABLEPTR(BASETABLE_SZ * FRAG_TEX_OFF));

	OUT_PKT0(ring, REG_A3XX_VPC_VARY_CYLWRAP_ENABLE_0, 2);
	OUT_RING(ring, 0x00000000);        /* VPC_VARY_CYLWRAP_ENABLE_0 */
	OUT_RING(ring, 0x00000000);        /* VPC_VARY_CYLWRAP_ENABLE_1 */

	OUT_PKT0(ring, REG_A3XX_UNKNOWN_0E43, 1);
	OUT_RING(ring, 0x00000001);        /* UNKNOWN_0E43 */

	OUT_PKT0(ring, REG_A3XX_UNKNOWN_0F03, 1);
	OUT_RING(ring, 0x00000001);        /* UNKNOWN_0F03 */

	OUT_PKT0(ring, REG_A3XX_UNKNOWN_0EE0, 1);
	OUT_RING(ring, 0x00000003);        /* UNKNOWN_0EE0 */

	OUT_PKT0(ring, REG_A3XX_UNKNOWN_0C3D, 1);
	OUT_RING(ring, 0x00000001);        /* UNKNOWN_0C3D */

	OUT_PKT0(ring, REG_A3XX_HLSQ_PERFCOUNTER0_SELECT, 1);
	OUT_RING(ring, 0x00000000);        /* HLSQ_PERFCOUNTER0_SELECT */

	OUT_PKT0(ring, REG_A3XX_HLSQ_CONST_VSPRESV_RANGE_REG, 2);
	OUT_RING(ring, A3XX_HLSQ_CONST_VSPRESV_RANGE_REG_STARTENTRY(0) |
			A3XX_HLSQ_CONST_VSPRESV_RANGE_REG_ENDENTRY(0));
	OUT_RING(ring, A3XX_HLSQ_CONST_FSPRESV_RANGE_REG_STARTENTRY(0) |
			A3XX_HLSQ_CONST_FSPRESV_RANGE_REG_ENDENTRY(0));

	fd3_emit_cache_flush(batch, ring);

	OUT_PKT0(ring, REG_A3XX_GRAS_CL_CLIP_CNTL, 1);
	OUT_RING(ring, 0x00000000);                  /* GRAS_CL_CLIP_CNTL */

	OUT_PKT0(ring, REG_A3XX_GRAS_SU_POINT_MINMAX, 2);
	OUT_RING(ring, 0xffc00010);        /* GRAS_SU_POINT_MINMAX */
	OUT_RING(ring, 0x00000008);        /* GRAS_SU_POINT_SIZE */

	OUT_PKT0(ring, REG_A3XX_PC_RESTART_INDEX, 1);
	OUT_RING(ring, 0xffffffff);        /* PC_RESTART_INDEX */

	OUT_PKT0(ring, REG_A3XX_RB_WINDOW_OFFSET, 1);
	OUT_RING(ring, A3XX_RB_WINDOW_OFFSET_X(0) |
			A3XX_RB_WINDOW_OFFSET_Y(0));

	OUT_PKT0(ring, REG_A3XX_RB_BLEND_RED, 4);
	OUT_RING(ring, A3XX_RB_BLEND_RED_UINT(0) |
			A3XX_RB_BLEND_RED_FLOAT(0.0));
	OUT_RING(ring, A3XX_RB_BLEND_GREEN_UINT(0) |
			A3XX_RB_BLEND_GREEN_FLOAT(0.0));
	OUT_RING(ring, A3XX_RB_BLEND_BLUE_UINT(0) |
			A3XX_RB_BLEND_BLUE_FLOAT(0.0));
	OUT_RING(ring, A3XX_RB_BLEND_ALPHA_UINT(0xff) |
			A3XX_RB_BLEND_ALPHA_FLOAT(1.0));

	for (i = 0; i < 6; i++) {
		OUT_PKT0(ring, REG_A3XX_GRAS_CL_USER_PLANE(i), 4);
		OUT_RING(ring, 0x00000000);    /* GRAS_CL_USER_PLANE[i].X */
		OUT_RING(ring, 0x00000000);    /* GRAS_CL_USER_PLANE[i].Y */
		OUT_RING(ring, 0x00000000);    /* GRAS_CL_USER_PLANE[i].Z */
		OUT_RING(ring, 0x00000000);    /* GRAS_CL_USER_PLANE[i].W */
	}

	OUT_PKT0(ring, REG_A3XX_PC_VSTREAM_CONTROL, 1);
	OUT_RING(ring, 0x00000000);

	fd_event_write(batch, ring, CACHE_FLUSH);

	if (is_a3xx_p0(ctx->screen)) {
		OUT_PKT3(ring, CP_DRAW_INDX, 3);
		OUT_RING(ring, 0x00000000);
		OUT_RING(ring, DRAW(1, DI_SRC_SEL_AUTO_INDEX,
							INDEX_SIZE_IGN, IGNORE_VISIBILITY, 0));
		OUT_RING(ring, 0);					/* NumIndices */
	}

	OUT_PKT3(ring, CP_NOP, 4);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);
	OUT_RING(ring, 0x00000000);

	fd_wfi(batch, ring);

	fd_hw_query_enable(batch, ring);
}

static void
fd3_emit_ib(struct fd_ringbuffer *ring, struct fd_ringbuffer *target)
{
	__OUT_IB(ring, true, target);
}

void
fd3_emit_init(struct pipe_context *pctx)
{
	struct fd_context *ctx = fd_context(pctx);
	ctx->emit_const = fd3_emit_const;
	ctx->emit_const_bo = fd3_emit_const_bo;
	ctx->emit_ib = fd3_emit_ib;
}
@


1.1
log
@Initial revision
@
text
@d34 1
d37 1
d97 1
a97 1
		uint32_t regid, uint32_t num, struct fd_bo **bos, uint32_t *offsets)
d113 1
a113 1
		if (bos[i]) {
d115 1
a115 1
				OUT_RELOCW(ring, bos[i], offsets[i], 0, 0);
d117 1
a117 1
				OUT_RELOC(ring, bos[i], offsets[i], 0, 0);
d146 2
a147 7
	unsigned i, j, off;
	void *ptr;

	u_upload_alloc(fd3_ctx->border_color_uploader,
			0, 2 * PIPE_MAX_SAMPLERS * BORDERCOLOR_SIZE, &off,
			&fd3_ctx->border_color_buf,
			&ptr);
a162 51
			uint16_t *bcolor = (uint16_t *)((uint8_t *)ptr +
					(BORDERCOLOR_SIZE * tex_off[sb]) +
					(BORDERCOLOR_SIZE * i));
			uint32_t *bcolor32 = (uint32_t *)&bcolor[16];

			/*
			 * XXX HACK ALERT XXX
			 *
			 * The border colors need to be swizzled in a particular
			 * format-dependent order. Even though samplers don't know about
			 * formats, we can assume that with a GL state tracker, there's a
			 * 1:1 correspondence between sampler and texture. Take advantage
			 * of that knowledge.
			 */
			if (i < tex->num_textures && tex->textures[i]) {
				const struct util_format_description *desc =
					util_format_description(tex->textures[i]->format);
				for (j = 0; j < 4; j++) {
					if (desc->swizzle[j] >= 4)
						continue;

					const struct util_format_channel_description *chan =
						&desc->channel[desc->swizzle[j]];
					int size = chan->size;

					/* The Z16 texture format we use seems to look in the
					 * 32-bit border color slots
					 */
					if (desc->colorspace == UTIL_FORMAT_COLORSPACE_ZS)
						size = 32;

					/* Formats like R11G11B10 or RGB9_E5 don't specify
					 * per-channel sizes properly.
					 */
					if (desc->layout == UTIL_FORMAT_LAYOUT_OTHER)
						size = 16;

					if (chan->pure_integer && size > 16)
						bcolor32[desc->swizzle[j] + 4] =
							sampler->base.border_color.i[j];
					else if (size > 16)
						bcolor32[desc->swizzle[j]] =
							fui(sampler->base.border_color.f[j]);
					else if (chan->pure_integer)
						bcolor[desc->swizzle[j] + 8] =
							sampler->base.border_color.i[j];
					else
						bcolor[desc->swizzle[j]] =
							util_float_to_half(sampler->base.border_color.f[j]);
				}
			}
d166 2
d209 6
a214 2
			unsigned start = fd_sampler_first_level(&view->base);
			unsigned end   = fd_sampler_last_level(&view->base);;
d216 2
a217 2
			for (j = 0; j < (end - start + 1); j++) {
				struct fd_resource_slice *slice =
d219 2
a220 1
				OUT_RELOC(ring, rsc->bo, slice->offset, 0, 0);
d230 14
a243 2
	OUT_PKT0(ring, bcolor_reg[sb], 1);
	OUT_RELOC(ring, fd_resource(fd3_ctx->border_color_buf)->bo, off, 0, 0);
d245 2
a246 1
	u_upload_unmap(fd3_ctx->border_color_uploader);
d319 2
a320 2
				 fd3_tex_swiz(format,  PIPE_SWIZZLE_RED, PIPE_SWIZZLE_GREEN,
							  PIPE_SWIZZLE_BLUE, PIPE_SWIZZLE_ALPHA));
d363 1
a363 1
	struct ir3_shader_variant *vp = fd3_emit_get_vp(emit);
d368 1
d370 21
a390 8
		uint8_t semantic = sem2name(vp->inputs[i].semantic);
		if (semantic == TGSI_SEMANTIC_VERTEXID_NOBASE)
			vertex_regid = vp->inputs[i].regid;
		else if (semantic == TGSI_SEMANTIC_INSTANCEID)
			instance_regid = vp->inputs[i].regid;
		else if (semantic == IR3_SEMANTIC_VTXCNT)
			vtxcnt_regid = vp->inputs[i].regid;
		else if (i < vtx->vtx->num_elements && vp->inputs[i].compmask)
d392 1
a394 7
	/* hw doesn't like to be configured for zero vbo's, it seems: */
	if ((vtx->vtx->num_elements == 0) &&
			(vertex_regid == regid(63, 0)) &&
			(instance_regid == regid(63, 0)) &&
			(vtxcnt_regid == regid(63, 0)))
		return;

d396 1
a396 1
		assert(sem2name(vp->inputs[i].semantic) == 0);
d438 32
d488 2
a489 2
	struct ir3_shader_variant *vp = fd3_emit_get_vp(emit);
	struct ir3_shader_variant *fp = fd3_emit_get_fp(emit);
d501 4
a504 2
	if ((dirty & (FD_DIRTY_ZSA | FD_DIRTY_PROG)) && !emit->key.binning_pass) {
		uint32_t val = fd3_zsa_stateobj(ctx->zsa)->rb_render_control;
d519 1
a519 1
		OUT_RINGP(ring, val, &fd3_context(ctx)->rbrc_patches);
d539 1
a539 1
	if (dirty & (FD_DIRTY_ZSA | FD_DIRTY_PROG)) {
d548 3
d574 1
d578 3
a580 2
		/* TODO only use if prog doesn't use clipvertex/clipdist */
		val |= MIN2(util_bitcount(ctx->rasterizer->clip_plane_enable), 6) << 26;
d585 1
a585 1
	if (dirty & (FD_DIRTY_RASTERIZER | FD_DIRTY_UCP)) {
d589 3
d596 1
a596 1
			fd_wfi(ctx, ring);
d632 1
a632 1
	if (dirty & FD_DIRTY_SCISSOR) {
d634 16
d652 9
a660 9
		OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_TL_X(scissor->minx) |
				A3XX_GRAS_SC_WINDOW_SCISSOR_TL_Y(scissor->miny));
		OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_BR_X(scissor->maxx - 1) |
				A3XX_GRAS_SC_WINDOW_SCISSOR_BR_Y(scissor->maxy - 1));

		ctx->max_scissor.minx = MIN2(ctx->max_scissor.minx, scissor->minx);
		ctx->max_scissor.miny = MIN2(ctx->max_scissor.miny, scissor->miny);
		ctx->max_scissor.maxx = MAX2(ctx->max_scissor.maxx, scissor->maxx);
		ctx->max_scissor.maxy = MAX2(ctx->max_scissor.maxy, scissor->maxy);
d664 1
a664 1
		fd_wfi(ctx, ring);
d674 31
a704 3
	if (dirty & (FD_DIRTY_PROG | FD_DIRTY_FRAMEBUFFER)) {
		struct pipe_framebuffer_state *pfb = &ctx->framebuffer;
		fd3_program_emit(ring, emit, pfb->nr_cbufs, pfb->cbufs);
d713 1
a713 1
		ir3_emit_consts(vp, ring, emit->info, dirty);
d715 1
a715 3
			ir3_emit_consts(fp, ring, emit->info, dirty);
		/* mark clean after emitting consts: */
		ctx->prog.dirty = 0;
d718 1
a718 1
	if ((dirty & (FD_DIRTY_BLEND | FD_DIRTY_FRAMEBUFFER)) && ctx->blend) {
d723 2
a724 1
			enum pipe_format format = pipe_surface_format(ctx->framebuffer.cbufs[i]);
d784 1
a784 1
		fd_wfi(ctx, ring);
d807 1
a807 1
fd3_emit_restore(struct fd_context *ctx)
d809 1
a810 1
	struct fd_ringbuffer *ring = ctx->ring;
d820 1
a820 1
	fd_wfi(ctx, ring);
d890 1
a890 1
	fd3_emit_cache_flush(ctx, ring);
d927 1
a927 1
	fd_event_write(ctx, ring, CACHE_FLUSH);
d943 1
a943 1
	fd_wfi(ctx, ring);
d945 7
a951 1
	ctx->needs_rb_fbd = true;
d960 1
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@a35 1
#include "freedreno_query_hw.h"
d148 1
a148 2
			0, BORDER_COLOR_UPLOAD_SIZE,
		       BORDER_COLOR_UPLOAD_SIZE, &off,
a151 2
	fd_setup_border_colors(tex, ptr, tex_off[sb]);

d166 51
d261 2
a262 7
			if (rsc && rsc->base.b.target == PIPE_BUFFER) {
				OUT_RELOC(ring, rsc->bo, view->base.u.buf.first_element *
						  util_format_get_blocksize(view->base.format), 0, 0);
				j = 1;
			} else {
				unsigned start = fd_sampler_first_level(&view->base);
				unsigned end   = fd_sampler_last_level(&view->base);;
d264 2
a265 2
				for (j = 0; j < (end - start + 1); j++) {
					struct fd_resource_slice *slice =
d267 1
a267 2
					OUT_RELOC(ring, rsc->bo, slice->offset, 0, 0);
				}
a401 1
	/* Note that sysvals come *after* normal inputs: */
d403 8
a410 21
		if (!vp->inputs[i].compmask)
			continue;
		if (vp->inputs[i].sysval) {
			switch(vp->inputs[i].slot) {
			case SYSTEM_VALUE_BASE_VERTEX:
				/* handled elsewhere */
				break;
			case SYSTEM_VALUE_VERTEX_ID_ZERO_BASE:
				vertex_regid = vp->inputs[i].regid;
				break;
			case SYSTEM_VALUE_INSTANCE_ID:
				instance_regid = vp->inputs[i].regid;
				break;
			case SYSTEM_VALUE_VERTEX_CNT:
				vtxcnt_regid = vp->inputs[i].regid;
				break;
			default:
				unreachable("invalid system value");
				break;
			}
		} else if (i < vtx->vtx->num_elements) {
a411 1
		}
d414 7
d422 1
a422 1
		assert(!vp->inputs[i].sysval);
a463 32
	/* hw doesn't like to be configured for zero vbo's, it seems: */
	if (last < 0) {
		/* just recycle the shader bo, we just need to point to *something*
		 * valid:
		 */
		struct fd_bo *dummy_vbo = vp->bo;
		bool switchnext = (vertex_regid != regid(63, 0)) ||
				(instance_regid != regid(63, 0)) ||
				(vtxcnt_regid != regid(63, 0));

		OUT_PKT0(ring, REG_A3XX_VFD_FETCH(0), 2);
		OUT_RING(ring, A3XX_VFD_FETCH_INSTR_0_FETCHSIZE(0) |
				A3XX_VFD_FETCH_INSTR_0_BUFSTRIDE(0) |
				COND(switchnext, A3XX_VFD_FETCH_INSTR_0_SWITCHNEXT) |
				A3XX_VFD_FETCH_INSTR_0_INDEXCODE(0) |
				A3XX_VFD_FETCH_INSTR_0_STEPRATE(1));
		OUT_RELOC(ring, dummy_vbo, 0, 0, 0);

		OUT_PKT0(ring, REG_A3XX_VFD_DECODE_INSTR(0), 1);
		OUT_RING(ring, A3XX_VFD_DECODE_INSTR_CONSTFILL |
				A3XX_VFD_DECODE_INSTR_WRITEMASK(0x1) |
				A3XX_VFD_DECODE_INSTR_FORMAT(VFMT_8_UNORM) |
				A3XX_VFD_DECODE_INSTR_SWAP(XYZW) |
				A3XX_VFD_DECODE_INSTR_REGID(regid(0,0)) |
				A3XX_VFD_DECODE_INSTR_SHIFTCNT(1) |
				A3XX_VFD_DECODE_INSTR_LASTCOMPVALID |
				COND(switchnext, A3XX_VFD_DECODE_INSTR_SWITCHNEXT));

		total_in = 1;
		j = 1;
	}

d495 2
a496 4
	if ((dirty & (FD_DIRTY_ZSA | FD_DIRTY_PROG | FD_DIRTY_BLEND_DUAL)) &&
		!emit->key.binning_pass) {
		uint32_t val = fd3_zsa_stateobj(ctx->zsa)->rb_render_control |
			fd3_blend_stateobj(ctx->blend)->rb_render_control;
d567 1
a567 2
		val |= A3XX_GRAS_CL_CLIP_CNTL_NUM_USER_CLIP_PLANES(
				MIN2(util_bitcount(ctx->rasterizer->clip_plane_enable), 6));
d642 1
a642 1
	if (dirty & (FD_DIRTY_PROG | FD_DIRTY_FRAMEBUFFER | FD_DIRTY_BLEND_DUAL)) {
d644 1
a644 5
		int nr_cbufs = pfb->nr_cbufs;
		if (fd3_blend_stateobj(ctx->blend)->rb_render_control &
			A3XX_RB_RENDER_CONTROL_DUAL_COLOR_IN_ENABLE)
			nr_cbufs++;
		fd3_program_emit(ring, emit, nr_cbufs, pfb->cbufs);
d660 1
a660 1
	if (dirty & (FD_DIRTY_BLEND | FD_DIRTY_FRAMEBUFFER)) {
a885 2
	fd_hw_query_enable(ctx, ring);

a888 7
static void
fd3_emit_ib(struct fd_ringbuffer *ring, struct fd_ringmarker *start,
		struct fd_ringmarker *end)
{
	__OUT_IB(ring, true, start, end);
}

a894 1
	ctx->emit_ib = fd3_emit_ib;
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@a33 1
#include "util/u_viewport.h"
d96 1
a96 1
		uint32_t regid, uint32_t num, struct pipe_resource **prscs, uint32_t *offsets)
d112 1
a112 1
		if (prscs[i]) {
d114 1
a114 1
				OUT_RELOCW(ring, fd_resource(prscs[i])->bo, offsets[i], 0, 0);
d116 1
a116 1
				OUT_RELOC(ring, fd_resource(prscs[i])->bo, offsets[i], 0, 0);
d145 10
a154 2
	bool needs_border = false;
	unsigned i, j;
a172 2

			needs_border |= sampler->needs_border;
d215 2
a216 1
				OUT_RELOC(ring, rsc->bo, view->base.u.buf.offset, 0, 0);
d220 1
a220 1
				unsigned end   = fd_sampler_last_level(&view->base);
d236 2
a237 11
	if (needs_border) {
		unsigned off;
		void *ptr;

		u_upload_alloc(fd3_ctx->border_color_uploader,
				0, BORDER_COLOR_UPLOAD_SIZE,
			       BORDER_COLOR_UPLOAD_SIZE, &off,
				&fd3_ctx->border_color_buf,
				&ptr);

		fd_setup_border_colors(tex, ptr, tex_off[sb]);
d239 1
a239 5
		OUT_PKT0(ring, bcolor_reg[sb], 1);
		OUT_RELOC(ring, fd_resource(fd3_ctx->border_color_buf)->bo, off, 0, 0);

		u_upload_unmap(fd3_ctx->border_color_uploader);
	}
d312 2
a313 2
				 fd3_tex_swiz(format,  PIPE_SWIZZLE_X, PIPE_SWIZZLE_Y,
							  PIPE_SWIZZLE_Z, PIPE_SWIZZLE_W));
d356 1
a356 1
	const struct ir3_shader_variant *vp = fd3_emit_get_vp(emit);
d481 2
a482 2
	const struct ir3_shader_variant *vp = fd3_emit_get_vp(emit);
	const struct ir3_shader_variant *fp = fd3_emit_get_fp(emit);
d512 1
a512 1
		OUT_RINGP(ring, val, &ctx->batch->rbrc_patches);
d532 1
a532 1
	if (dirty & (FD_DIRTY_ZSA | FD_DIRTY_RASTERIZER | FD_DIRTY_PROG)) {
a540 3
		if (!ctx->rasterizer->depth_clip) {
			val |= A3XX_RB_DEPTH_CONTROL_Z_CLAMP_ENABLE;
		}
a563 1
		uint8_t planes = ctx->rasterizer->clip_plane_enable;
d567 3
a569 3
		if (!emit->key.ucp_enables)
			val |= A3XX_GRAS_CL_CLIP_CNTL_NUM_USER_CLIP_PLANES(
					MIN2(util_bitcount(planes), 6));
d574 1
a574 1
	if (dirty & (FD_DIRTY_RASTERIZER | FD_DIRTY_PROG | FD_DIRTY_UCP)) {
a577 3
		if (emit->key.ucp_enables)
			planes = 0;

d582 1
a582 1
			fd_wfi(ctx->batch, ring);
d618 1
a618 1
	if (dirty & (FD_DIRTY_SCISSOR | FD_DIRTY_RASTERIZER | FD_DIRTY_VIEWPORT)) {
a619 16
		int minx = scissor->minx;
		int miny = scissor->miny;
		int maxx = scissor->maxx;
		int maxy = scissor->maxy;

		/* Unfortunately there is no separate depth clip disable, only an all
		 * or nothing deal. So when we disable clipping, we must handle the
		 * viewport clip via scissors.
		 */
		if (!ctx->rasterizer->depth_clip) {
			struct pipe_viewport_state *vp = &ctx->viewport;
			minx = MAX2(minx, (int)floorf(vp->translate[0] - fabsf(vp->scale[0])));
			miny = MAX2(miny, (int)floorf(vp->translate[1] - fabsf(vp->scale[1])));
			maxx = MIN2(maxx, (int)ceilf(vp->translate[0] + fabsf(vp->scale[0])));
			maxy = MIN2(maxy, (int)ceilf(vp->translate[1] + fabsf(vp->scale[1])));
		}
d622 9
a630 9
		OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_TL_X(minx) |
				A3XX_GRAS_SC_WINDOW_SCISSOR_TL_Y(miny));
		OUT_RING(ring, A3XX_GRAS_SC_WINDOW_SCISSOR_BR_X(maxx - 1) |
				A3XX_GRAS_SC_WINDOW_SCISSOR_BR_Y(maxy - 1));

		ctx->batch->max_scissor.minx = MIN2(ctx->batch->max_scissor.minx, minx);
		ctx->batch->max_scissor.miny = MIN2(ctx->batch->max_scissor.miny, miny);
		ctx->batch->max_scissor.maxx = MAX2(ctx->batch->max_scissor.maxx, maxx);
		ctx->batch->max_scissor.maxy = MAX2(ctx->batch->max_scissor.maxy, maxy);
d634 1
a634 1
		fd_wfi(ctx->batch, ring);
a643 24
	if (dirty & (FD_DIRTY_VIEWPORT | FD_DIRTY_RASTERIZER | FD_DIRTY_FRAMEBUFFER)) {
		float zmin, zmax;
		int depth = 24;
		if (ctx->batch->framebuffer.zsbuf) {
			depth = util_format_get_component_bits(
					pipe_surface_format(ctx->batch->framebuffer.zsbuf),
					UTIL_FORMAT_COLORSPACE_ZS, 0);
		}
		util_viewport_zmin_zmax(&ctx->viewport, ctx->rasterizer->clip_halfz,
								&zmin, &zmax);

		OUT_PKT0(ring, REG_A3XX_RB_Z_CLAMP_MIN, 2);
		if (depth == 32) {
			OUT_RING(ring, (uint32_t)(zmin * 0xffffffff));
			OUT_RING(ring, (uint32_t)(zmax * 0xffffffff));
		} else if (depth == 16) {
			OUT_RING(ring, (uint32_t)(zmin * 0xffff));
			OUT_RING(ring, (uint32_t)(zmax * 0xffff));
		} else {
			OUT_RING(ring, (uint32_t)(zmin * 0xffffff));
			OUT_RING(ring, (uint32_t)(zmax * 0xffffff));
		}
	}

d645 1
a645 1
		struct pipe_framebuffer_state *pfb = &ctx->batch->framebuffer;
d659 1
a659 1
		ir3_emit_consts(vp, ring, ctx, emit->info, dirty);
d661 3
a663 1
			ir3_emit_consts(fp, ring, ctx, emit->info, dirty);
d671 1
a671 2
			enum pipe_format format =
				pipe_surface_format(ctx->batch->framebuffer.cbufs[i]);
d731 1
a731 1
		fd_wfi(ctx->batch, ring);
d754 1
a754 1
fd3_emit_restore(struct fd_batch *batch, struct fd_ringbuffer *ring)
a755 1
	struct fd_context *ctx = batch->ctx;
d757 1
d767 1
a767 1
	fd_wfi(batch, ring);
d837 1
a837 1
	fd3_emit_cache_flush(batch, ring);
d874 1
a874 1
	fd_event_write(batch, ring, CACHE_FLUSH);
d890 3
a892 1
	fd_wfi(batch, ring);
d894 1
a894 1
	fd_hw_query_enable(batch, ring);
d898 2
a899 1
fd3_emit_ib(struct fd_ringbuffer *ring, struct fd_ringbuffer *target)
d901 1
a901 1
	__OUT_IB(ring, true, target);
@


1.1.1.4
log
@Import Mesa 17.1.6
@
text
@d57 1
a57 1
static void
a98 1
	uint32_t anum = align(num, 4);
d102 1
d104 1
a104 1
	OUT_PKT3(ring, CP_LOAD_STATE, 2 + anum);
d108 1
a108 1
			CP_LOAD_STATE_0_NUM_UNIT(anum/2));
a122 3

	for (; i < anum; i++)
		OUT_RING(ring, 0xffffffff);
d302 1
a302 1
		enum pipe_format format = fd_gmem_restore_format(psurf[i]->format);
d308 1
a308 1
			format = fd_gmem_restore_format(rsc->base.b.format);
@


