head	1.1;
branch	1.1.1;
access;
symbols
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.45.27;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.45.27;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.21.11;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.29.39;	author jsg;	state Exp;
branches;
next	;
commitid	uuv5VTS15jglEDZU;


desc
@@


1.1
log
@Initial revision
@
text
@/**********************************************************
 * Copyright 2008-2009 VMware, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 **********************************************************/

#include "util/u_inlines.h"
#include "pipe/p_defines.h"
#include "util/u_format.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_bitmask.h"
#include "translate/translate.h"
#include "tgsi/tgsi_ureg.h"

#include "svga_context.h"
#include "svga_state.h"
#include "svga_cmd.h"
#include "svga_shader.h"
#include "svga_tgsi.h"

#include "svga_hw_reg.h"


static inline int
compare_vs_keys(const struct svga_vs_compile_key *a,
                const struct svga_vs_compile_key *b)
{
   unsigned keysize = svga_vs_key_size( a );
   return memcmp( a, b, keysize );
}


/** Search for a vertex shader variant */
static struct svga_shader_variant *
search_vs_key(const struct svga_vertex_shader *vs,
              const struct svga_vs_compile_key *key)
{
   struct svga_shader_variant *variant = vs->base.variants;

   assert(key);

   for ( ; variant; variant = variant->next) {
      if (compare_vs_keys( key, &variant->key.vkey ) == 0)
         return variant;
   }
   
   return NULL;
}


/**
 * If we fail to compile a vertex shader we'll use a dummy/fallback shader
 * that simply emits a (0,0,0,1) vertex position.
 */
static const struct tgsi_token *
get_dummy_vertex_shader(void)
{
   static const float zero[4] = { 0.0, 0.0, 0.0, 1.0 };
   struct ureg_program *ureg;
   const struct tgsi_token *tokens;
   struct ureg_src src;
   struct ureg_dst dst;
   unsigned num_tokens;

   ureg = ureg_create(TGSI_PROCESSOR_VERTEX);
   if (!ureg)
      return NULL;

   dst = ureg_DECL_output(ureg, TGSI_SEMANTIC_POSITION, 0);
   src = ureg_DECL_immediate(ureg, zero, 4);
   ureg_MOV(ureg, dst, src);
   ureg_END(ureg);

   tokens = ureg_get_tokens(ureg, &num_tokens);

   ureg_destroy(ureg);

   return tokens;
}


/**
 * Replace the given shader's instruction with a simple / dummy shader.
 * We use this when normal shader translation fails.
 */
static struct svga_shader_variant *
get_compiled_dummy_vertex_shader(struct svga_vertex_shader *vs,
                                 const struct svga_vs_compile_key *key)
{
   const struct tgsi_token *dummy = get_dummy_vertex_shader();
   struct svga_shader_variant *variant;

   if (!dummy) {
      return NULL;
   }

   FREE((void *) vs->base.tokens);
   vs->base.tokens = dummy;

   variant = svga_translate_vertex_program(vs, key);
   return variant;
}


/**
 * Translate TGSI shader into an svga shader variant.
 */
static enum pipe_error
compile_vs(struct svga_context *svga,
           struct svga_vertex_shader *vs,
           const struct svga_vs_compile_key *key,
           struct svga_shader_variant **out_variant)
{
   struct svga_shader_variant *variant;
   enum pipe_error ret = PIPE_ERROR;

   variant = svga_translate_vertex_program( vs, key );
   if (variant == NULL) {
      /* some problem during translation, try the dummy shader */
      variant = get_compiled_dummy_vertex_shader(vs, key);
      if (!variant) {
         ret = PIPE_ERROR;
         goto fail;
      }
   }

   if (svga_shader_too_large(svga, variant)) {
      /* too big, use dummy shader */
      debug_printf("Shader too large (%lu bytes),"
                   " using dummy shader instead.\n",
                   (unsigned long ) variant->nr_tokens
                   * sizeof(variant->tokens[0]));
      variant = get_compiled_dummy_vertex_shader(vs, key);
      if (!variant) {
         ret = PIPE_ERROR;
         goto fail;
      }
   }

   ret = svga_define_shader(svga, SVGA3D_SHADERTYPE_VS, variant);
   if (ret != PIPE_OK)
      goto fail;

   *out_variant = variant;

   /* insert variants at head of linked list */
   variant->next = vs->base.variants;
   vs->base.variants = variant;

   return PIPE_OK;

fail:
   if (variant) {
      svga_destroy_shader_variant(svga, SVGA3D_SHADERTYPE_VS, variant);
   }
   return ret;
}

/* SVGA_NEW_PRESCALE, SVGA_NEW_RAST, SVGA_NEW_FS
 */
static void
make_vs_key(struct svga_context *svga, struct svga_vs_compile_key *key)
{
   memset(key, 0, sizeof *key);
   key->need_prescale = svga->state.hw_clear.prescale.enabled;
   key->allow_psiz = svga->curr.rast->templ.point_size_per_vertex;

   /* SVGA_NEW_FS */
   key->fs_generic_inputs = svga->curr.fs->generic_inputs;

   /* SVGA_NEW_VELEMENT */
   key->adjust_attrib_range = svga->curr.velems->adjust_attrib_range;
   key->adjust_attrib_w_1 = svga->curr.velems->adjust_attrib_w_1;
}


/**
 * svga_reemit_vs_bindings - Reemit the vertex shader bindings
 */
enum pipe_error
svga_reemit_vs_bindings(struct svga_context *svga)
{
   enum pipe_error ret;
   struct svga_winsys_gb_shader *gbshader =
      svga->state.hw_draw.vs ? svga->state.hw_draw.vs->gb_shader : NULL;

   assert(svga->rebind.vs);
   assert(svga_have_gb_objects(svga));

   ret = SVGA3D_SetGBShader(svga->swc, SVGA3D_SHADERTYPE_VS, gbshader);
   if (ret != PIPE_OK)
      return ret;

   svga->rebind.vs = FALSE;
   return PIPE_OK;
}


static enum pipe_error
emit_hw_vs(struct svga_context *svga, unsigned dirty)
{
   struct svga_shader_variant *variant = NULL;
   enum pipe_error ret = PIPE_OK;

   /* SVGA_NEW_NEED_SWTNL */
   if (!svga->state.sw.need_swtnl) {
      struct svga_vertex_shader *vs = svga->curr.vs;
      struct svga_vs_compile_key key;

      make_vs_key( svga, &key );

      variant = search_vs_key( vs, &key );
      if (!variant) {
         ret = compile_vs( svga, vs, &key, &variant );
         if (ret != PIPE_OK)
            return ret;
      }

      assert(variant);
   }

   if (variant != svga->state.hw_draw.vs) {
      if (svga_have_gb_objects(svga)) {
         struct svga_winsys_gb_shader *gbshader =
            variant ? variant->gb_shader : NULL;
         ret = SVGA3D_SetGBShader(svga->swc, SVGA3D_SHADERTYPE_VS, gbshader);
         if (ret != PIPE_OK)
            return ret;

         svga->rebind.vs = FALSE;
      }
      else {
         unsigned id = variant ? variant->id : SVGA_ID_INVALID;
         ret = SVGA3D_SetShader(svga->swc, SVGA3D_SHADERTYPE_VS, id);
         if (ret != PIPE_OK)
            return ret;
      }

      svga->dirty |= SVGA_NEW_VS_VARIANT;
      svga->state.hw_draw.vs = variant;      
   }

   return PIPE_OK;
}

struct svga_tracked_state svga_hw_vs = 
{
   "vertex shader (hwtnl)",
   (SVGA_NEW_VS |
    SVGA_NEW_FS |
    SVGA_NEW_PRESCALE |
    SVGA_NEW_VELEMENT |
    SVGA_NEW_NEED_SWTNL),
   emit_hw_vs
};
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d28 1
d44 27
a101 16
static struct svga_shader_variant *
translate_vertex_program(struct svga_context *svga,
                         const struct svga_vertex_shader *vs,
                         const struct svga_compile_key *key)
{
   if (svga_have_vgpu10(svga)) {
      return svga_tgsi_vgpu10_translate(svga, &vs->base, key,
                                        PIPE_SHADER_VERTEX);
   }
   else {
      return svga_tgsi_vgpu9_translate(svga, &vs->base, key,
                                       PIPE_SHADER_VERTEX);
   }
}


d107 2
a108 3
get_compiled_dummy_vertex_shader(struct svga_context *svga,
                                 struct svga_vertex_shader *vs,
                                 const struct svga_compile_key *key)
d120 1
a120 1
   variant = translate_vertex_program(svga, vs, key);
d131 1
a131 1
           const struct svga_compile_key *key,
d137 1
a137 1
   variant = translate_vertex_program(svga, vs, key);
d139 6
a144 3
      debug_printf("Failed to compile vertex shader,"
                   " using dummy shader instead.\n");
      variant = get_compiled_dummy_vertex_shader(svga, vs, key);
d146 2
a147 1
   else if (svga_shader_too_large(svga, variant)) {
d149 1
a149 1
      debug_printf("Shader too large (%u bytes),"
d151 7
a157 10
                   (unsigned) (variant->nr_tokens
                               * sizeof(variant->tokens[0])));
      /* Free the too-large variant */
      svga_destroy_shader_variant(svga, SVGA3D_SHADERTYPE_VS, variant);
      /* Use simple pass-through shader instead */
      variant = get_compiled_dummy_vertex_shader(svga, vs, key);
   }

   if (!variant) {
      return PIPE_ERROR;
d161 2
a162 4
   if (ret != PIPE_OK) {
      svga_destroy_shader_variant(svga, SVGA3D_SHADERTYPE_VS, variant);
      return ret;
   }
d166 4
d171 6
a178 1

d182 1
a182 1
make_vs_key(struct svga_context *svga, struct svga_compile_key *key)
a183 2
   const unsigned shader = PIPE_SHADER_VERTEX;

d185 2
a186 14

   if (svga->state.sw.need_swtnl && svga_have_vgpu10(svga)) {
      /* Set both of these flags, to match compile_passthrough_vs() */
      key->vs.passthrough = 1;
      key->vs.undo_viewport = 1;
      return;
   }

   /* SVGA_NEW_PRESCALE */
   key->vs.need_prescale = svga->state.hw_clear.prescale.enabled &&
                           (svga->curr.gs == NULL);

   /* SVGA_NEW_RAST */
   key->vs.allow_psiz = svga->curr.rast->templ.point_size_per_vertex;
d189 1
a189 3
   key->vs.fs_generic_inputs = svga->curr.fs->generic_inputs;

   svga_remap_generics(key->vs.fs_generic_inputs, key->generic_remap_table);
d192 2
a193 15
   key->vs.adjust_attrib_range = svga->curr.velems->adjust_attrib_range;
   key->vs.adjust_attrib_w_1 = svga->curr.velems->adjust_attrib_w_1;
   key->vs.attrib_is_pure_int = svga->curr.velems->attrib_is_pure_int;
   key->vs.adjust_attrib_itof = svga->curr.velems->adjust_attrib_itof;
   key->vs.adjust_attrib_utof = svga->curr.velems->adjust_attrib_utof;
   key->vs.attrib_is_bgra = svga->curr.velems->attrib_is_bgra;
   key->vs.attrib_puint_to_snorm = svga->curr.velems->attrib_puint_to_snorm;
   key->vs.attrib_puint_to_uscaled = svga->curr.velems->attrib_puint_to_uscaled;
   key->vs.attrib_puint_to_sscaled = svga->curr.velems->attrib_puint_to_sscaled;

   /* SVGA_NEW_TEXTURE_BINDING | SVGA_NEW_SAMPLER */
   svga_init_shader_key_common(svga, shader, key);

   /* SVGA_NEW_RAST */
   key->clip_plane_enable = svga->curr.rast->templ.clip_plane_enable;
d204 2
a205 2
   struct svga_winsys_gb_shader *gbshader = NULL;
   SVGA3dShaderId shaderId = SVGA3D_INVALID_ID;
d207 1
a207 1
   assert(svga->rebind.flags.vs);
d210 1
a210 18
   if (svga->state.hw_draw.vs) {
      gbshader = svga->state.hw_draw.vs->gb_shader;
      shaderId = svga->state.hw_draw.vs->id;
   }

   if (!svga_need_to_rebind_resources(svga)) {
      ret =  svga->swc->resource_rebind(svga->swc, NULL, gbshader,
                                        SVGA_RELOC_READ);
      goto out;
   }

   if (svga_have_vgpu10(svga))
      ret = SVGA3D_vgpu10_SetShader(svga->swc, SVGA3D_SHADERTYPE_VS,
                                    gbshader, shaderId);
   else
      ret = SVGA3D_SetGBShader(svga->swc, SVGA3D_SHADERTYPE_VS, gbshader);

 out:
d214 1
a214 1
   svga->rebind.flags.vs = FALSE;
a218 7
/**
 * The current vertex shader is already executed by the 'draw'
 * module, so we just need to generate a simple vertex shader
 * to pass through all those VS outputs that will
 * be consumed by the fragment shader.
 * Used when we employ the 'draw' module.
 */
d220 1
a220 4
compile_passthrough_vs(struct svga_context *svga,
                       struct svga_vertex_shader *vs,
                       struct svga_fragment_shader *fs,
                       struct svga_shader_variant **out_variant)
a222 86
   unsigned num_inputs;
   unsigned i;
   unsigned num_elements;
   struct svga_vertex_shader new_vs;
   struct ureg_src src[PIPE_MAX_SHADER_INPUTS];
   struct ureg_dst dst[PIPE_MAX_SHADER_OUTPUTS];
   struct ureg_program *ureg;
   unsigned num_tokens;
   struct svga_compile_key key;
   enum pipe_error ret;

   assert(svga_have_vgpu10(svga));
   assert(fs);

   num_inputs = fs->base.info.num_inputs;

   ureg = ureg_create(TGSI_PROCESSOR_VERTEX);
   if (!ureg)
      return PIPE_ERROR_OUT_OF_MEMORY;

   /* draw will always add position */
   dst[0] = ureg_DECL_output(ureg, TGSI_SEMANTIC_POSITION, 0);
   src[0] = ureg_DECL_vs_input(ureg, 0);
   num_elements = 1;

   /**
    * swtnl backend redefines the input layout based on the
    * fragment shader's inputs. So we only need to passthrough
    * those inputs that will be consumed by the fragment shader.
    * Note: DX10 requires the number of vertex elements
    * specified in the input layout to be no less than the
    * number of inputs to the vertex shader.
    */
   for (i = 0; i < num_inputs; i++) {
      switch (fs->base.info.input_semantic_name[i]) {
      case TGSI_SEMANTIC_COLOR:
      case TGSI_SEMANTIC_GENERIC:
      case TGSI_SEMANTIC_FOG:
         dst[num_elements] = ureg_DECL_output(ureg,
                                fs->base.info.input_semantic_name[i],
                                fs->base.info.input_semantic_index[i]);
         src[num_elements] = ureg_DECL_vs_input(ureg, num_elements);
         num_elements++;
         break;
      default:
         break;
      }
   }

   for (i = 0; i < num_elements; i++) {
      ureg_MOV(ureg, dst[i], src[i]);
   }

   ureg_END(ureg);

   memset(&new_vs, 0, sizeof(new_vs));
   new_vs.base.tokens = ureg_get_tokens(ureg, &num_tokens);
   tgsi_scan_shader(new_vs.base.tokens, &new_vs.base.info);

   memset(&key, 0, sizeof(key));
   key.vs.undo_viewport = 1;

   ret = compile_vs(svga, &new_vs, &key, &variant);
   if (ret != PIPE_OK)
      return ret;

   ureg_free_tokens(new_vs.base.tokens);
   ureg_destroy(ureg);

   /* Overwrite the variant key to indicate it's a pass-through VS */
   memset(&variant->key, 0, sizeof(variant->key));
   variant->key.vs.passthrough = 1;
   variant->key.vs.undo_viewport = 1;

   *out_variant = variant;

   return PIPE_OK;
}


static enum pipe_error
emit_hw_vs(struct svga_context *svga, unsigned dirty)
{
   struct svga_shader_variant *variant;
   struct svga_vertex_shader *vs = svga->curr.vs;
   struct svga_fragment_shader *fs = svga->curr.fs;
a223 16
   struct svga_compile_key key;

   /* If there is an active geometry shader, and it has stream output
    * defined, then we will skip the stream output from the vertex shader
    */
   if (!svga_have_gs_streamout(svga)) {
      /* No GS stream out */
      if (svga_have_vs_streamout(svga)) {
         /* Set VS stream out */
         svga_set_stream_output(svga, vs->base.stream_output);
      }
      else {
         /* turn off stream out */
         svga_set_stream_output(svga, NULL);
      }
   }
d226 3
a228 6
   if (svga->state.sw.need_swtnl && !svga_have_vgpu10(svga)) {
      /* No vertex shader is needed */
      variant = NULL;
   }
   else {
      make_vs_key(svga, &key);
d230 1
a230 2
      /* See if we already have a VS variant that matches the key */
      variant = svga_search_shader_key(&vs->base, &key);
d232 1
d234 1
a234 7
         /* Create VS variant now */
         if (key.vs.passthrough) {
            ret = compile_passthrough_vs(svga, vs, fs, &variant);
         }
         else {
            ret = compile_vs(svga, vs, &key, &variant);
         }
d237 1
d239 1
a239 5
         /* insert the new variant at head of linked list */
         assert(variant);
         variant->next = vs->base.variants;
         vs->base.variants = variant;
      }
d243 12
a254 3
      /* Bind the new variant */
      if (variant) {
         ret = svga_set_shader(svga, SVGA3D_SHADERTYPE_VS, variant);
a256 1
         svga->rebind.flags.vs = FALSE;
d260 1
a260 1
      svga->state.hw_draw.vs = variant;
a270 3
    SVGA_NEW_TEXTURE_BINDING |
    SVGA_NEW_SAMPLER |
    SVGA_NEW_RAST |
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d57 1
a57 1
   ureg = ureg_create(PIPE_SHADER_VERTEX);
d165 1
a165 1
   const enum pipe_shader_type shader = PIPE_SHADER_VERTEX;
d276 1
a276 1
   ureg = ureg_create(PIPE_SHADER_VERTEX);
a348 2
   SVGA_STATS_TIME_PUSH(svga_sws(svga), SVGA_STATS_TIME_EMITVS);

d384 1
a384 1
            goto done;
d398 1
a398 1
            goto done;
d406 1
a406 3
done:
   SVGA_STATS_TIME_POP(svga_sws(svga));
   return ret;
@


