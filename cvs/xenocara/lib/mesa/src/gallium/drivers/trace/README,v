head	1.1;
branch	1.1.1;
access;
symbols
	mesa-17_1_6:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.4
	OPENBSD_6_1_BASE:1.1.1.1
	mesa-13_0_6:1.1.1.1
	mesa-13_0_5:1.1.1.1
	mesa-13_0_3:1.1.1.1
	mesa-13_0_2:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.6
	OPENBSD_6_0_BASE:1.1.1.1
	mesa-11_2_2:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2015.11.22.02.44.30;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.30;	author jsg;	state Exp;
branches;
next	;
commitid	bJUptkbooQfJPk5r;


desc
@@


1.1
log
@Initial revision
@
text
@                             TRACE PIPE DRIVER


= About =

This directory contains a Gallium3D trace debugger pipe driver.
It can traces all incoming calls.


= Usage =

== Tracing ==

For tracing then do

 GALLIUM_TRACE=tri.trace trivial/tri

which should create a tri.trace file, which is an XML file. You can view copying 
trace.xsl to the same directory, and opening with a XSLT capable browser such as 
Firefox or Internet Explorer.

For long traces you can use the

  src/gallium/tools/trace/dump.py tri.trace | less -R


== Remote debugging ==

For remote debugging see:

  src/gallium/drivers/rbug/README


= Integrating =

You can integrate the trace pipe driver either inside the state tracker or the 
target. The procedure on both cases is the same. Let's assume you have a 
pipe_screen obtained by the usual means (variable and function names are just
for illustration purposes):

  real_screen = real_screen_create(...);
  
The trace screen is then created by doing

  trace_screen = trace_screen_create(real_screen);

You can then simply use trace_screen instead of real_screen.

You can create as many contexts you wish from trace_screen::context_create they
are automatically wrapped by trace_screen.


--
Jose Fonseca <jfonseca@@vmware.com>
Jakob Bornecrantz <jakob@@vmware.com>
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@
