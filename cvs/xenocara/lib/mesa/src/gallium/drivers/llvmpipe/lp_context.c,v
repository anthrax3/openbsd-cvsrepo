head	1.2;
access;
symbols
	mesa-17_1_6:1.1.1.4
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.25;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.44.04;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.04;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.19.39;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.27.50;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.08.14.09.32.34;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * Copyright 2008 VMware, Inc.  All rights reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/* Author:
 *    Keith Whitwell <keithw@@vmware.com>
 */

#include "draw/draw_context.h"
#include "draw/draw_vbuf.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/simple_list.h"
#include "lp_clear.h"
#include "lp_context.h"
#include "lp_flush.h"
#include "lp_perf.h"
#include "lp_state.h"
#include "lp_surface.h"
#include "lp_query.h"
#include "lp_setup.h"

/* This is only safe if there's just one concurrent context */
#ifdef PIPE_SUBSYSTEM_EMBEDDED
#define USE_GLOBAL_LLVM_CONTEXT
#endif

static void llvmpipe_destroy( struct pipe_context *pipe )
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context( pipe );
   uint i, j;

   lp_print_counters();

   if (llvmpipe->blitter) {
      util_blitter_destroy(llvmpipe->blitter);
   }

   /* This will also destroy llvmpipe->setup:
    */
   if (llvmpipe->draw)
      draw_destroy( llvmpipe->draw );

   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
      pipe_surface_reference(&llvmpipe->framebuffer.cbufs[i], NULL);
   }

   pipe_surface_reference(&llvmpipe->framebuffer.zsbuf, NULL);

   for (i = 0; i < ARRAY_SIZE(llvmpipe->sampler_views[0]); i++) {
      pipe_sampler_view_reference(&llvmpipe->sampler_views[PIPE_SHADER_FRAGMENT][i], NULL);
   }

   for (i = 0; i < ARRAY_SIZE(llvmpipe->sampler_views[0]); i++) {
      pipe_sampler_view_reference(&llvmpipe->sampler_views[PIPE_SHADER_VERTEX][i], NULL);
   }

   for (i = 0; i < ARRAY_SIZE(llvmpipe->sampler_views[0]); i++) {
      pipe_sampler_view_reference(&llvmpipe->sampler_views[PIPE_SHADER_GEOMETRY][i], NULL);
   }

   for (i = 0; i < ARRAY_SIZE(llvmpipe->constants); i++) {
      for (j = 0; j < ARRAY_SIZE(llvmpipe->constants[i]); j++) {
         pipe_resource_reference(&llvmpipe->constants[i][j].buffer, NULL);
      }
   }

   for (i = 0; i < llvmpipe->num_vertex_buffers; i++) {
      pipe_resource_reference(&llvmpipe->vertex_buffer[i].buffer, NULL);
   }

   lp_delete_setup_variants(llvmpipe);

#ifndef USE_GLOBAL_LLVM_CONTEXT
   LLVMContextDispose(llvmpipe->context);
#endif
   llvmpipe->context = NULL;

   align_free( llvmpipe );
}

static void
do_flush( struct pipe_context *pipe,
          struct pipe_fence_handle **fence,
          unsigned flags)
{
   llvmpipe_flush(pipe, fence, __FUNCTION__);
}


static void
llvmpipe_render_condition ( struct pipe_context *pipe,
                            struct pipe_query *query,
                            boolean condition,
                            uint mode )
{
   struct llvmpipe_context *llvmpipe = llvmpipe_context( pipe );

   llvmpipe->render_cond_query = query;
   llvmpipe->render_cond_mode = mode;
   llvmpipe->render_cond_cond = condition;
}

struct pipe_context *
llvmpipe_create_context(struct pipe_screen *screen, void *priv,
                        unsigned flags)
{
   struct llvmpipe_context *llvmpipe;

   llvmpipe = align_malloc(sizeof(struct llvmpipe_context), 16);
   if (!llvmpipe)
      return NULL;

   util_init_math();

   memset(llvmpipe, 0, sizeof *llvmpipe);

   make_empty_list(&llvmpipe->fs_variants_list);

   make_empty_list(&llvmpipe->setup_variants_list);


   llvmpipe->pipe.screen = screen;
   llvmpipe->pipe.priv = priv;

   /* Init the pipe context methods */
   llvmpipe->pipe.destroy = llvmpipe_destroy;
   llvmpipe->pipe.set_framebuffer_state = llvmpipe_set_framebuffer_state;
   llvmpipe->pipe.clear = llvmpipe_clear;
   llvmpipe->pipe.flush = do_flush;

   llvmpipe->pipe.render_condition = llvmpipe_render_condition;

   llvmpipe_init_blend_funcs(llvmpipe);
   llvmpipe_init_clip_funcs(llvmpipe);
   llvmpipe_init_draw_funcs(llvmpipe);
   llvmpipe_init_sampler_funcs(llvmpipe);
   llvmpipe_init_query_funcs( llvmpipe );
   llvmpipe_init_vertex_funcs(llvmpipe);
   llvmpipe_init_so_funcs(llvmpipe);
   llvmpipe_init_fs_funcs(llvmpipe);
   llvmpipe_init_vs_funcs(llvmpipe);
   llvmpipe_init_gs_funcs(llvmpipe);
   llvmpipe_init_rasterizer_funcs(llvmpipe);
   llvmpipe_init_context_resource_funcs( &llvmpipe->pipe );
   llvmpipe_init_surface_functions(llvmpipe);

#ifdef USE_GLOBAL_LLVM_CONTEXT
   llvmpipe->context = LLVMGetGlobalContext();
#else
   llvmpipe->context = LLVMContextCreate();
#endif

   if (!llvmpipe->context)
      goto fail;

   /*
    * Create drawing context and plug our rendering stage into it.
    */
   llvmpipe->draw = draw_create_with_llvm_context(&llvmpipe->pipe,
                                                  llvmpipe->context);
   if (!llvmpipe->draw)
      goto fail;

   /* FIXME: devise alternative to draw_texture_samplers */

   llvmpipe->setup = lp_setup_create( &llvmpipe->pipe,
                                      llvmpipe->draw );
   if (!llvmpipe->setup)
      goto fail;

   llvmpipe->blitter = util_blitter_create(&llvmpipe->pipe);
   if (!llvmpipe->blitter) {
      goto fail;
   }

   /* must be done before installing Draw stages */
   util_blitter_cache_all_shaders(llvmpipe->blitter);

   /* plug in AA line/point stages */
   draw_install_aaline_stage(llvmpipe->draw, &llvmpipe->pipe);
   draw_install_aapoint_stage(llvmpipe->draw, &llvmpipe->pipe);
   draw_install_pstipple_stage(llvmpipe->draw, &llvmpipe->pipe);

   /* convert points and lines into triangles: 
    * (otherwise, draw points and lines natively)
    */
   draw_wide_point_sprites(llvmpipe->draw, FALSE);
   draw_enable_point_sprites(llvmpipe->draw, FALSE);
   draw_wide_point_threshold(llvmpipe->draw, 10000.0);
   draw_wide_line_threshold(llvmpipe->draw, 10000.0);

   lp_reset_counters();

   return &llvmpipe->pipe;

 fail:
   llvmpipe_destroy(&llvmpipe->pipe);
   return NULL;
}

@


1.1
log
@Initial revision
@
text
@d76 1
a76 1
   for (i = 0; i < Elements(llvmpipe->sampler_views[0]); i++) {
d80 1
a80 1
   for (i = 0; i < Elements(llvmpipe->sampler_views[0]); i++) {
d84 1
a84 1
   for (i = 0; i < Elements(llvmpipe->sampler_views[0]); i++) {
d88 2
a89 2
   for (i = 0; i < Elements(llvmpipe->constants); i++) {
      for (j = 0; j < Elements(llvmpipe->constants[i]); j++) {
d131 2
a132 1
llvmpipe_create_context( struct pipe_screen *screen, void *priv )
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d131 1
a131 2
llvmpipe_create_context(struct pipe_screen *screen, void *priv,
                        unsigned flags)
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d76 1
a76 1
   for (i = 0; i < ARRAY_SIZE(llvmpipe->sampler_views[0]); i++) {
d80 1
a80 1
   for (i = 0; i < ARRAY_SIZE(llvmpipe->sampler_views[0]); i++) {
d84 1
a84 1
   for (i = 0; i < ARRAY_SIZE(llvmpipe->sampler_views[0]); i++) {
d88 2
a89 2
   for (i = 0; i < ARRAY_SIZE(llvmpipe->constants); i++) {
      for (j = 0; j < ARRAY_SIZE(llvmpipe->constants[i]); j++) {
@


1.1.1.4
log
@Import Mesa 17.1.6
@
text
@a39 1
#include "util/u_upload_mgr.h"
a64 3
   if (llvmpipe->pipe.stream_uploader)
      u_upload_destroy(llvmpipe->pipe.stream_uploader);

a196 5

   llvmpipe->pipe.stream_uploader = u_upload_create_default(&llvmpipe->pipe);
   if (!llvmpipe->pipe.stream_uploader)
      goto fail;
   llvmpipe->pipe.const_uploader = llvmpipe->pipe.stream_uploader;
@


