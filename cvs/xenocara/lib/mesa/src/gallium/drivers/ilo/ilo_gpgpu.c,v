head	1.3;
access;
symbols
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	mesa-13_0_6:1.1.1.2
	mesa-13_0_5:1.1.1.2
	mesa-13_0_3:1.1.1.2
	mesa-13_0_2:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2017.08.26.16.59.24;	author jsg;	state Exp;
branches;
next	1.2;
commitid	D0k2io1oY8gcsQ2S;

1.2
date	2017.08.14.09.57.58;	author jsg;	state dead;
branches;
next	1.1;
commitid	bC4bLqwWTo4kLw82;

1.1
date	2015.11.22.02.43.29;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.43.29;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.19.02;	author jsg;	state Exp;
branches;
next	;
commitid	OwGfrJACrYJkCVJ4;


desc
@@


1.3
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2012-2013 LunarG, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Chia-I Wu <olv@@lunarg.com>
 */

#include "util/u_upload_mgr.h"
#include "ilo_context.h"
#include "ilo_render.h"
#include "ilo_shader.h"
#include "ilo_gpgpu.h"

static void
launch_grid(struct ilo_context *ilo,
            const uint *block_layout, const uint *grid_layout,
            const struct pipe_constant_buffer *input, uint32_t pc)
{
   const unsigned grid_offset[3] = { 0, 0, 0 };
   const unsigned thread_group_size =
      block_layout[0] * block_layout[1] * block_layout[2];
   int max_len, before_space;

   ilo_cp_set_owner(ilo->cp, INTEL_RING_RENDER, NULL);

   max_len = ilo_render_get_launch_grid_len(ilo->render, &ilo->state_vector);
   max_len += ilo_render_get_flush_len(ilo->render) * 2;

   if (max_len > ilo_cp_space(ilo->cp)) {
      ilo_cp_submit(ilo->cp, "out of space");
      assert(max_len <= ilo_cp_space(ilo->cp));
   }

   before_space = ilo_cp_space(ilo->cp);

   while (true) {
      struct ilo_builder_snapshot snapshot;

      ilo_builder_batch_snapshot(&ilo->cp->builder, &snapshot);

      ilo_render_emit_launch_grid(ilo->render, &ilo->state_vector,
            grid_offset, grid_layout, thread_group_size, input, pc);

      if (!ilo_builder_validate(&ilo->cp->builder, 0, NULL)) {
         ilo_builder_batch_restore(&ilo->cp->builder, &snapshot);

         /* flush and try again */
         if (ilo_builder_batch_used(&ilo->cp->builder)) {
            ilo_cp_submit(ilo->cp, "out of aperture");
            continue;
         }
      }

      break;
   }

   /* sanity check size estimation */
   assert(before_space - ilo_cp_space(ilo->cp) <= max_len);
}

static void
ilo_launch_grid(struct pipe_context *pipe, const struct pipe_grid_info *info)
{
   struct ilo_context *ilo = ilo_context(pipe);
   struct ilo_shader_state *cs = ilo->state_vector.cs;
   struct pipe_constant_buffer input_buf;

   memset(&input_buf, 0, sizeof(input_buf));

   input_buf.buffer_size =
      ilo_shader_get_kernel_param(cs, ILO_KERNEL_CS_INPUT_SIZE);
   if (input_buf.buffer_size) {
      u_upload_data(ilo->uploader, 0, input_buf.buffer_size, 16, info->input,
            &input_buf.buffer_offset, &input_buf.buffer);
   }

   ilo_shader_cache_upload(ilo->shader_cache, &ilo->cp->builder);

   launch_grid(ilo, info->block, info->grid, &input_buf, info->pc);

   ilo_render_invalidate_hw(ilo->render);

   if (ilo_debug & ILO_DEBUG_NOCACHE)
      ilo_render_emit_flush(ilo->render);

   if (input_buf.buffer_size)
      pipe_resource_reference(&input_buf.buffer, NULL);
}

/**
 * Initialize GPGPU-related functions.
 */
void
ilo_init_gpgpu_functions(struct ilo_context *ilo)
{
   ilo->base.launch_grid = ilo_launch_grid;
}
@


1.2
log
@Merge Mesa 17.1.6
@
text
@d82 1
a82 3
ilo_launch_grid(struct pipe_context *pipe,
                const uint *block_layout, const uint *grid_layout,
                uint32_t pc, const void *input)
d93 1
a93 1
      u_upload_data(ilo->uploader, 0, input_buf.buffer_size, input,
d99 1
a99 1
   launch_grid(ilo, block_layout, grid_layout, &input_buf, pc);
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d82 3
a84 1
ilo_launch_grid(struct pipe_context *pipe, const struct pipe_grid_info *info)
d95 1
a95 1
      u_upload_data(ilo->uploader, 0, input_buf.buffer_size, 16, info->input,
d101 1
a101 1
   launch_grid(ilo, info->block, info->grid, &input_buf, info->pc);
@

