head	1.2;
access;
symbols
	mesa-17_1_6:1.1.1.2
	OPENBSD_6_1:1.1.1.1.0.2
	OPENBSD_6_1_BASE:1.1.1.1
	mesa-13_0_6:1.1.1.1
	mesa-13_0_5:1.1.1.1
	mesa-13_0_3:1.1.1.1
	mesa-13_0_2:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.2
date	2017.08.26.16.59.27;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2016.12.11.08.29.10;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	uuv5VTS15jglEDZU;

1.1.1.1
date	2016.12.11.08.29.10;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	uuv5VTS15jglEDZU;

1.1.1.2
date	2017.08.14.09.33.38;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/****************************************************************************
 * Copyright (C) 2015 Intel Corporation.   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 ***************************************************************************/

#include "swr_context.h"
#include "swr_query.h"

static void
swr_clear(struct pipe_context *pipe,
          unsigned buffers,
          const union pipe_color_union *color,
          double depth,
          unsigned stencil)
{
   struct swr_context *ctx = swr_context(pipe);
   struct pipe_framebuffer_state *fb = &ctx->framebuffer;

   UINT clearMask = 0;

   if (!swr_check_render_cond(pipe))
      return;

   if (ctx->dirty)
      swr_update_derived(pipe);

/* Update clearMask/targetMask */
#if 0 /* XXX SWR currently only clears SWR_ATTACHMENT_COLOR0, don't bother   \
         checking others yet. */
   if (buffers & PIPE_CLEAR_COLOR && fb->nr_cbufs) {
      UINT i;
      for (i = 0; i < fb->nr_cbufs; ++i)
         if (fb->cbufs[i])
            clearMask |= (SWR_CLEAR_COLOR0 << i);
   }
#else
   if (buffers & PIPE_CLEAR_COLOR && fb->cbufs[0])
      clearMask |= SWR_CLEAR_COLOR;
#endif

   if (buffers & PIPE_CLEAR_DEPTH && fb->zsbuf)
      clearMask |= SWR_CLEAR_DEPTH;

   if (buffers & PIPE_CLEAR_STENCIL && fb->zsbuf)
      clearMask |= SWR_CLEAR_STENCIL;

#if 0 // XXX HACK, override clear color alpha. On ubuntu, clears are
      // transparent.
   ((union pipe_color_union *)color)->f[3] = 1.0; /* cast off your const'd-ness */
#endif

   swr_update_draw_context(ctx);
   SwrClearRenderTarget(ctx->swrContext, clearMask, color->f, depth, stencil,
                        ctx->swr_scissor);
}


#if 0 // XXX, these don't get called. how to get these called?  Do we need
      // them?  Docs?
static void
swr_clear_render_target(struct pipe_context *pipe, struct pipe_surface *ps,
                        const union pipe_color_union *color,
                        unsigned x, unsigned y, unsigned w, unsigned h,
                        bool render_condition_enabled)
{
   struct swr_context *ctx = swr_context(pipe);
   fprintf(stderr, "SWR swr_clear_render_target!\n");

   ctx->dirty |= SWR_NEW_FRAMEBUFFER | SWR_NEW_SCISSOR;
}

static void
swr_clear_depth_stencil(struct pipe_context *pipe, struct pipe_surface *ps,
                        unsigned buffers, double depth, unsigned stencil,
                        unsigned x, unsigned y, unsigned w, unsigned h,
                        bool render_condition_enabled)
{
   struct swr_context *ctx = swr_context(pipe);
   fprintf(stderr, "SWR swr_clear_depth_stencil!\n");

   ctx->dirty |= SWR_NEW_FRAMEBUFFER | SWR_NEW_SCISSOR;
}

static void
swr_clear_buffer(struct pipe_context *pipe,
                 struct pipe_resource *res,
                 unsigned offset, unsigned size,
                 const void *data, int data_size)
{
   fprintf(stderr, "SWR swr_clear_buffer!\n");
   struct swr_context *ctx = swr_context(pipe);
   struct swr_resource *buf = swr_resource(res);
   union pipe_color_union color;
   enum pipe_format dst_fmt;
   unsigned width, height, elements;

   assert(res->target == PIPE_BUFFER);
   assert(buf);
   assert(size % data_size == 0);

   SWR_SURFACE_STATE &swr_buffer = buf->swr;

   ctx->dirty |= SWR_NEW_FRAMEBUFFER | SWR_NEW_SCISSOR;
}
#endif


void
swr_clear_init(struct pipe_context *pipe)
{
   pipe->clear = swr_clear;
#if 0 // XXX, these don't get called. how to get these called?  Do we need
      // them?  Docs?
   pipe->clear_render_target = swr_clear_render_target;
   pipe->clear_depth_stencil = swr_clear_depth_stencil;
   pipe->clear_buffer = swr_clear_buffer;
#endif
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 13.0.2
@
text
@@


1.1.1.2
log
@Import Mesa 17.1.6
@
text
@a37 1
   unsigned layers = 0;
d42 2
a43 1
   swr_update_derived(pipe);
d45 3
d49 4
a52 6
      for (unsigned i = 0; i < fb->nr_cbufs; ++i)
         if (fb->cbufs[i] && (buffers & (PIPE_CLEAR_COLOR0 << i))) {
            clearMask |= (SWR_ATTACHMENT_COLOR0_BIT << i);
            layers = std::max(layers, fb->cbufs[i]->u.tex.last_layer -
                                      fb->cbufs[i]->u.tex.first_layer + 1u);
         }
d54 4
d59 2
a60 5
   if (buffers & PIPE_CLEAR_DEPTH && fb->zsbuf) {
      clearMask |= SWR_ATTACHMENT_DEPTH_BIT;
      layers = std::max(layers, fb->zsbuf->u.tex.last_layer -
                                fb->zsbuf->u.tex.first_layer + 1u);
   }
d62 2
a63 5
   if (buffers & PIPE_CLEAR_STENCIL && fb->zsbuf) {
      clearMask |= SWR_ATTACHMENT_STENCIL_BIT;
      layers = std::max(layers, fb->zsbuf->u.tex.last_layer -
                                fb->zsbuf->u.tex.first_layer + 1u);
   }
d70 3
a72 16
   for (unsigned i = 0; i < layers; ++i) {
      swr_update_draw_context(ctx);
      SwrClearRenderTarget(ctx->swrContext, clearMask, i,
                           color->f, depth, stencil,
                           ctx->swr_scissor);

      // Mask out the attachments that are out of layers.
      if (fb->zsbuf &&
          (fb->zsbuf->u.tex.last_layer <= fb->zsbuf->u.tex.first_layer + i))
         clearMask &= ~(SWR_ATTACHMENT_DEPTH_BIT | SWR_ATTACHMENT_STENCIL_BIT);
      for (unsigned c = 0; c < fb->nr_cbufs; ++c) {
         const struct pipe_surface *sf = fb->cbufs[c];
         if (sf && (sf->u.tex.last_layer <= sf->u.tex.first_layer + i))
            clearMask &= ~(SWR_ATTACHMENT_COLOR0_BIT << c);
      }
   }
@

