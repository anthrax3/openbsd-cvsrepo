head	1.2;
access;
symbols
	mesa-17_1_6:1.1.1.2
	OPENBSD_6_1:1.1.1.1.0.2
	OPENBSD_6_1_BASE:1.1.1.1
	mesa-13_0_6:1.1.1.1
	mesa-13_0_5:1.1.1.1
	mesa-13_0_3:1.1.1.1
	mesa-13_0_2:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.08.26.16.59.28;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2016.12.11.08.29.15;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	uuv5VTS15jglEDZU;

1.1.1.1
date	2016.12.11.08.29.15;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	uuv5VTS15jglEDZU;

1.1.1.2
date	2017.08.14.09.33.44;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/****************************************************************************
* Copyright (C) 2014-2015 Intel Corporation.   All Rights Reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a
* copy of this software and associated documentation files (the "Software"),
* to deal in the Software without restriction, including without limitation
* the rights to use, copy, modify, merge, publish, distribute, sublicense,
* and/or sell copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice (including the next
* paragraph) shall be included in all copies or substantial portions of the
* Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*
* @@file multisample.h
*
******************************************************************************/

#pragma once

#include "context.h"
#include "format_traits.h"

//////////////////////////////////////////////////////////////////////////
/// @@brief convenience typedef for testing for single sample case
typedef std::integral_constant<int, 1> SingleSampleT;

INLINE
uint32_t GetNumSamples(SWR_MULTISAMPLE_COUNT sampleCount)
{
    static const uint32_t sampleCountLUT[SWR_MULTISAMPLE_TYPE_COUNT] {1, 2, 4, 8, 16};
    assert(sampleCount < SWR_MULTISAMPLE_TYPE_COUNT);
    return sampleCountLUT[sampleCount];
}

INLINE
SWR_MULTISAMPLE_COUNT GetSampleCount(uint32_t numSamples)
{
    switch(numSamples)
    {
    case 1: return SWR_MULTISAMPLE_1X;
    case 2: return SWR_MULTISAMPLE_2X;
    case 4: return SWR_MULTISAMPLE_4X;
    case 8: return SWR_MULTISAMPLE_8X;
    case 16: return SWR_MULTISAMPLE_16X;
    default: assert(0); return SWR_MULTISAMPLE_1X;
    }
}

// hardcoded offsets based on Direct3d standard multisample positions
// 8 x 8 pixel grid ranging from (0, 0) to (15, 15), with (0, 0) = UL pixel corner
// coords are 0.8 fixed point offsets from (0, 0)
template<SWR_MULTISAMPLE_COUNT sampleCount, SWR_MSAA_SAMPLE_PATTERN samplePattern = SWR_MSAA_STANDARD_PATTERN>
struct MultisampleTraits
{
    INLINE static __m128i vXi(uint32_t sampleNum) = delete;
    INLINE static __m128i vYi(uint32_t sampleNum) = delete;
    INLINE static simdscalar vX(uint32_t sampleNum) = delete;
    INLINE static simdscalar vY(uint32_t sampleNum) = delete;
    INLINE static float X(uint32_t sampleNum) = delete;
    INLINE static float Y(uint32_t sampleNum) = delete;
    INLINE static __m128i TileSampleOffsetsX() = delete;
    INLINE static __m128i TileSampleOffsetsY() = delete;
    INLINE static simdscalari FullSampleMask() = delete;

    static const uint32_t numSamples = 0;
};

template<>
struct MultisampleTraits<SWR_MULTISAMPLE_1X, SWR_MSAA_STANDARD_PATTERN>
{
    INLINE static __m128i vXi(uint32_t sampleNum)
    {
        static const __m128i X = _mm_set1_epi32(samplePosXi);
        return X;
    }

    INLINE static __m128i vYi(uint32_t sampleNum)
    {
        static const __m128i Y = _mm_set1_epi32(samplePosYi);
        return Y;
    }

    INLINE static simdscalar vX(uint32_t sampleNum)
    {
        static const simdscalar X = _simd_set1_ps(0.5f);
        return X;
    }

    INLINE static simdscalar vY(uint32_t sampleNum)
    {
        static const simdscalar Y = _simd_set1_ps(0.5f);
        return Y;
    }

    INLINE static float X(uint32_t sampleNum) {return samplePosX;};
    INLINE static float Y(uint32_t sampleNum) {return samplePosY;};

    INLINE static __m128i TileSampleOffsetsX()
    {
        static const uint32_t bboxLeftEdge = 0x80;
        static const uint32_t bboxRightEdge = 0x80;
                                                            // BR,            BL,           UR,            UL
        static const __m128i tileSampleOffsetX = _mm_set_epi32(bboxRightEdge, bboxLeftEdge, bboxRightEdge, bboxLeftEdge);
        return tileSampleOffsetX;
    }

    INLINE static __m128i TileSampleOffsetsY()
    {
        static const uint32_t bboxTopEdge = 0x80;
        static const uint32_t bboxBottomEdge = 0x80;
                                                            // BR,             BL,             UR,          UL
        static const __m128i tileSampleOffsetY = _mm_set_epi32(bboxBottomEdge, bboxBottomEdge, bboxTopEdge, bboxTopEdge);
        return tileSampleOffsetY;
    }

    INLINE static simdscalari FullSampleMask(){return _simd_set1_epi32(0x1);};

    static const uint32_t samplePosXi;
    static const uint32_t samplePosYi;
    static const float samplePosX;
    static const float samplePosY;
    static const uint32_t numSamples = 1;
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_1X;
    static const uint32_t numCoverageSamples = 1; 
};

template<>
struct MultisampleTraits<SWR_MULTISAMPLE_1X, SWR_MSAA_CENTER_PATTERN>
{
    INLINE static __m128i vXi(uint32_t sampleNum)
    {
        return _mm_set1_epi32(0x80);
    }

    INLINE static __m128i vYi(uint32_t sampleNum)
    {
        return _mm_set1_epi32(0x80);
    }

    INLINE static simdscalar vX(uint32_t sampleNum)
    {
        return _simd_set1_ps(0.5f);
    }

    INLINE static simdscalar vY(uint32_t sampleNum)
    {
        return _simd_set1_ps(0.5f);
    }

    INLINE static float X(uint32_t sampleNum) {return 0.5f;};
    INLINE static float Y(uint32_t sampleNum) {return 0.5f;};

    INLINE static __m128i TileSampleOffsetsX()
    {
        // BR,            BL,           UR,            UL
        return _mm_set1_epi32(0x80);
    }

    INLINE static __m128i TileSampleOffsetsY()
    {
        // BR,             BL,             UR,          UL
        return _mm_set1_epi32(0x80);
    }

    INLINE static simdscalari FullSampleMask(){return _simd_set1_epi32(0x1);};
    
    static const uint32_t numSamples = 1;
    static const float samplePosX;
    static const float samplePosY;
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_1X;
    static const uint32_t numCoverageSamples = 1;
};

template<>
struct MultisampleTraits<SWR_MULTISAMPLE_2X, SWR_MSAA_STANDARD_PATTERN>
{
    INLINE static __m128i vXi(uint32_t sampleNum)
    {
        SWR_ASSERT(sampleNum < numSamples);
        static const __m128i X[numSamples] {_mm_set1_epi32(samplePosXi[0]), _mm_set1_epi32(samplePosXi[1])};
        return X[sampleNum];
    }

    INLINE static __m128i vYi(uint32_t sampleNum)
    {
        SWR_ASSERT(sampleNum < numSamples);
        static const __m128i Y[numSamples] {_mm_set1_epi32(samplePosYi[0]), _mm_set1_epi32(samplePosYi[1])};
        return Y[sampleNum];
    }

    INLINE static simdscalar vX(uint32_t sampleNum)
    {
        static const simdscalar X[numSamples] {_simd_set1_ps(0.75f), _simd_set1_ps(0.25f)};
        assert(sampleNum < numSamples);
        return X[sampleNum];
    }

    INLINE static simdscalar vY(uint32_t sampleNum)
    {
        static const simdscalar Y[numSamples] {_simd_set1_ps(0.75f), _simd_set1_ps(0.25f)};
        assert(sampleNum < numSamples);
        return Y[sampleNum];
    }

    INLINE static float X(uint32_t sampleNum) { SWR_ASSERT(sampleNum < numSamples); return samplePosX[sampleNum]; };
    INLINE static float Y(uint32_t sampleNum) { SWR_ASSERT(sampleNum < numSamples); return samplePosY[sampleNum]; };

    INLINE static __m128i TileSampleOffsetsX()
    {
        static const uint32_t bboxLeftEdge = 0x40;
        static const uint32_t bboxRightEdge = 0xC0;
                                                            // BR,            BL,           UR,            UL
        static const __m128i tileSampleOffsetX = _mm_set_epi32(bboxRightEdge, bboxLeftEdge, bboxRightEdge, bboxLeftEdge);
        return tileSampleOffsetX;
    }

    INLINE static __m128i TileSampleOffsetsY()
    {
        static const uint32_t bboxTopEdge = 0x40;
        static const uint32_t bboxBottomEdge = 0xC0;
                                                            // BR,             BL,             UR,          UL
        static const __m128i tileSampleOffsetY = _mm_set_epi32(bboxBottomEdge, bboxBottomEdge, bboxTopEdge, bboxTopEdge);
        return tileSampleOffsetY;
    }

    INLINE static simdscalari FullSampleMask()
    {
         static const simdscalari mask =_simd_set1_epi32(0x3);
         return mask;
    }

    static const uint32_t samplePosXi[2];
    static const uint32_t samplePosYi[2];
    static const float samplePosX[2];
    static const float samplePosY[2];
    static const uint32_t numSamples = 2;
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_2X;
    static const uint32_t numCoverageSamples = 2;
};

template<>
struct MultisampleTraits<SWR_MULTISAMPLE_2X, SWR_MSAA_CENTER_PATTERN>
{
    INLINE static __m128i vXi(uint32_t sampleNum)
    {
        return _mm_set1_epi32(0x80);
    }

    INLINE static __m128i vYi(uint32_t sampleNum)
    {
        return _mm_set1_epi32(0x80);
    }

    INLINE static simdscalar vX(uint32_t sampleNum)
    {
        return _simd_set1_ps(0.5f);
    }

    INLINE static simdscalar vY(uint32_t sampleNum)
    {
        return _simd_set1_ps(0.5f);
    }

    INLINE static float X(uint32_t sampleNum) {return 0.5f;};
    INLINE static float Y(uint32_t sampleNum) {return 0.5f;};

    INLINE static __m128i TileSampleOffsetsX()
    {
        // BR,            BL,           UR,            UL
        return _mm_set1_epi32(0x80);
    }

    INLINE static __m128i TileSampleOffsetsY()
    {
        // BR,             BL,             UR,          UL
        return _mm_set1_epi32(0x80);
    }

    INLINE static simdscalari FullSampleMask()
    {
         static const simdscalari mask =_simd_set1_epi32(0x3);
         return mask;
    }
    static const uint32_t numSamples = 2;
    static const float samplePosX[2];
    static const float samplePosY[2];
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_2X;
    static const uint32_t numCoverageSamples = 1;
};

template<>
struct MultisampleTraits<SWR_MULTISAMPLE_4X, SWR_MSAA_STANDARD_PATTERN>
{
    INLINE static __m128i vXi(uint32_t sampleNum)
    {
        static const __m128i X[numSamples]
        {_mm_set1_epi32(samplePosXi[0]), _mm_set1_epi32(samplePosXi[1]), _mm_set1_epi32(samplePosXi[2]), _mm_set1_epi32(samplePosXi[3])};
        SWR_ASSERT(sampleNum < numSamples);
        return X[sampleNum];
    }

    INLINE static __m128i vYi(uint32_t sampleNum)
    {
        static const __m128i Y[numSamples]
        {_mm_set1_epi32(samplePosYi[0]), _mm_set1_epi32(samplePosYi[1]), _mm_set1_epi32(samplePosYi[2]), _mm_set1_epi32(samplePosYi[3])};
        SWR_ASSERT(sampleNum < numSamples);
        return Y[sampleNum];
    }

    INLINE static simdscalar vX(uint32_t sampleNum)
    {
        static const simdscalar X[numSamples] 
        {_simd_set1_ps(0.375f), _simd_set1_ps(0.875), _simd_set1_ps(0.125), _simd_set1_ps(0.625)};
        assert(sampleNum < numSamples);
        return X[sampleNum];
    }

    INLINE static simdscalar vY(uint32_t sampleNum)
    {
        static const simdscalar Y[numSamples]
        {_simd_set1_ps(0.125), _simd_set1_ps(0.375f), _simd_set1_ps(0.625), _simd_set1_ps(0.875)};
        assert(sampleNum < numSamples);
        return Y[sampleNum];
    }
    
    INLINE static float X(uint32_t sampleNum) { SWR_ASSERT(sampleNum < numSamples); return samplePosX[sampleNum]; };
    INLINE static float Y(uint32_t sampleNum) { SWR_ASSERT(sampleNum < numSamples); return samplePosY[sampleNum]; };

    INLINE static __m128i TileSampleOffsetsX()
    {
        static const uint32_t bboxLeftEdge = 0x20;
        static const uint32_t bboxRightEdge = 0xE0;
                                                            // BR,            BL,           UR,            UL
        static const __m128i tileSampleOffsetX = _mm_set_epi32(bboxRightEdge, bboxLeftEdge, bboxRightEdge, bboxLeftEdge);
        return tileSampleOffsetX;
    }

    INLINE static __m128i TileSampleOffsetsY()
    {
        static const uint32_t bboxTopEdge = 0x20;
        static const uint32_t bboxBottomEdge = 0xE0;
                                                            // BR,             BL,             UR,          UL
        static const __m128i tileSampleOffsetY = _mm_set_epi32(bboxBottomEdge, bboxBottomEdge, bboxTopEdge, bboxTopEdge);
        return tileSampleOffsetY;
    }

    INLINE static simdscalari FullSampleMask()
    {
        static const simdscalari mask = _simd_set1_epi32(0xF);
        return mask;
    }

    static const uint32_t samplePosXi[4];
    static const uint32_t samplePosYi[4];
    static const float samplePosX[4];
    static const float samplePosY[4];
    static const uint32_t numSamples = 4;
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_4X;
    static const uint32_t numCoverageSamples = 4;
};

template<>
struct MultisampleTraits<SWR_MULTISAMPLE_4X, SWR_MSAA_CENTER_PATTERN>
{
    INLINE static __m128i vXi(uint32_t sampleNum)
    {
        return _mm_set1_epi32(0x80);
    }

    INLINE static __m128i vYi(uint32_t sampleNum)
    {
        return _mm_set1_epi32(0x80);
    }

    INLINE static simdscalar vX(uint32_t sampleNum)
    {
        return _simd_set1_ps(0.5f);
    }

    INLINE static simdscalar vY(uint32_t sampleNum)
    {
        return _simd_set1_ps(0.5f);
    }

    INLINE static float X(uint32_t sampleNum) {return 0.5f;};
    INLINE static float Y(uint32_t sampleNum) {return 0.5f;};

    INLINE static __m128i TileSampleOffsetsX()
    {
        // BR,            BL,           UR,            UL
        return _mm_set1_epi32(0x80);
    }

    INLINE static __m128i TileSampleOffsetsY()
    {
        // BR,             BL,             UR,          UL
        return _mm_set1_epi32(0x80);
    }

    INLINE static simdscalari FullSampleMask()
    {
        static const simdscalari mask = _simd_set1_epi32(0xF);
        return mask;
    }
    static const uint32_t numSamples = 4;
    static const float samplePosX[4];
    static const float samplePosY[4];
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_4X;
    static const uint32_t numCoverageSamples = 1;
};

template<>
struct MultisampleTraits<SWR_MULTISAMPLE_8X, SWR_MSAA_STANDARD_PATTERN>
{
    INLINE static __m128i vXi(uint32_t sampleNum)
    {
        static const __m128i X[numSamples]
        {_mm_set1_epi32(samplePosXi[0]), _mm_set1_epi32(samplePosXi[1]), _mm_set1_epi32(samplePosXi[2]), _mm_set1_epi32(samplePosXi[3]), 
         _mm_set1_epi32(samplePosXi[4]), _mm_set1_epi32(samplePosXi[5]), _mm_set1_epi32(samplePosXi[6]), _mm_set1_epi32(samplePosXi[7])};
        SWR_ASSERT(sampleNum < numSamples);
        return X[sampleNum];
    }

    INLINE static __m128i vYi(uint32_t sampleNum)
    {
        static const __m128i Y[numSamples]
        {_mm_set1_epi32(samplePosYi[0]), _mm_set1_epi32(samplePosYi[1]), _mm_set1_epi32(samplePosYi[2]), _mm_set1_epi32(samplePosYi[3]), 
         _mm_set1_epi32(samplePosYi[4]), _mm_set1_epi32(samplePosYi[5]), _mm_set1_epi32(samplePosYi[6]), _mm_set1_epi32(samplePosYi[7])};
        SWR_ASSERT(sampleNum < numSamples);
        return Y[sampleNum];
    }

    INLINE static simdscalar vX(uint32_t sampleNum)
    {
        static const simdscalar X[numSamples]
        {_simd_set1_ps(0.5625), _simd_set1_ps(0.4375), _simd_set1_ps(0.8125), _simd_set1_ps(0.3125),
         _simd_set1_ps(0.1875), _simd_set1_ps(0.0625), _simd_set1_ps(0.6875), _simd_set1_ps(0.9375)};
        assert(sampleNum < numSamples);
        return X[sampleNum];
    }

    INLINE static simdscalar vY(uint32_t sampleNum)
    {
        static const simdscalar Y[numSamples]
        {_simd_set1_ps(0.3125), _simd_set1_ps(0.6875), _simd_set1_ps(0.5625), _simd_set1_ps(0.1875),
         _simd_set1_ps(0.8125), _simd_set1_ps(0.4375), _simd_set1_ps(0.9375), _simd_set1_ps(0.0625)};
        assert(sampleNum < numSamples);
        return Y[sampleNum];
    }

    INLINE static float X(uint32_t sampleNum) { SWR_ASSERT(sampleNum < numSamples); return samplePosX[sampleNum]; };
    INLINE static float Y(uint32_t sampleNum) { SWR_ASSERT(sampleNum < numSamples); return samplePosY[sampleNum]; };

    INLINE static __m128i TileSampleOffsetsX()
    {
        static const uint32_t bboxLeftEdge = 0x10;
        static const uint32_t bboxRightEdge = 0xF0;
                                                            // BR,            BL,           UR,            UL
        static const __m128i tileSampleOffsetX = _mm_set_epi32(bboxRightEdge, bboxLeftEdge, bboxRightEdge, bboxLeftEdge);
        return tileSampleOffsetX;
    }

    INLINE static __m128i TileSampleOffsetsY()
    {
        static const uint32_t bboxTopEdge = 0x10;
        static const uint32_t bboxBottomEdge = 0xF0;
                                                            // BR,             BL,             UR,          UL
        static const __m128i tileSampleOffsetY = _mm_set_epi32(bboxBottomEdge, bboxBottomEdge, bboxTopEdge, bboxTopEdge);
        return tileSampleOffsetY;
    }

    INLINE static simdscalari FullSampleMask()
    {
        static const simdscalari mask = _simd_set1_epi32(0xFF);
        return mask;
    }

    static const uint32_t samplePosXi[8];
    static const uint32_t samplePosYi[8];
    static const float samplePosX[8];
    static const float samplePosY[8];
    static const uint32_t numSamples = 8;
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_8X;
    static const uint32_t numCoverageSamples = 8;
};

template<>
struct MultisampleTraits<SWR_MULTISAMPLE_8X, SWR_MSAA_CENTER_PATTERN>
{
    INLINE static __m128i vXi(uint32_t sampleNum)
    {
        return _mm_set1_epi32(0x80);
    }

    INLINE static __m128i vYi(uint32_t sampleNum)
    {
        return _mm_set1_epi32(0x80);
    }

    INLINE static simdscalar vX(uint32_t sampleNum)
    {
        return _simd_set1_ps(0.5f);
    }

    INLINE static simdscalar vY(uint32_t sampleNum)
    {
        return _simd_set1_ps(0.5f);
    }

    INLINE static float X(uint32_t sampleNum) {return 0.5f;};
    INLINE static float Y(uint32_t sampleNum) {return 0.5f;};

    INLINE static __m128i TileSampleOffsetsX()
    {
        // BR,            BL,           UR,            UL
        return _mm_set1_epi32(0x80);
    }

    INLINE static __m128i TileSampleOffsetsY()
    {
        // BR,             BL,             UR,          UL
        return _mm_set1_epi32(0x80);
    }

    INLINE static simdscalari FullSampleMask()
    {
        static const simdscalari mask = _simd_set1_epi32(0xFF);
        return mask;
    }
    static const uint32_t numSamples = 8;
    static const float samplePosX[8];
    static const float samplePosY[8];
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_8X;
    static const uint32_t numCoverageSamples = 1;
};

template<>
struct MultisampleTraits<SWR_MULTISAMPLE_16X, SWR_MSAA_STANDARD_PATTERN>
{
    INLINE static __m128i vXi(uint32_t sampleNum)
    {
        static const __m128i X[numSamples]
        {_mm_set1_epi32(samplePosXi[0]), _mm_set1_epi32(samplePosXi[1]), _mm_set1_epi32(samplePosXi[2]), _mm_set1_epi32(samplePosXi[3]), 
         _mm_set1_epi32(samplePosXi[4]), _mm_set1_epi32(samplePosXi[5]), _mm_set1_epi32(samplePosXi[6]), _mm_set1_epi32(samplePosXi[7]), 
         _mm_set1_epi32(samplePosXi[8]), _mm_set1_epi32(samplePosXi[9]), _mm_set1_epi32(samplePosXi[10]), _mm_set1_epi32(samplePosXi[11]), 
         _mm_set1_epi32(samplePosXi[12]), _mm_set1_epi32(samplePosXi[13]), _mm_set1_epi32(samplePosXi[14]), _mm_set1_epi32(samplePosXi[15])};
        SWR_ASSERT(sampleNum < numSamples);
        return X[sampleNum];
    }

    INLINE static __m128i vYi(uint32_t sampleNum)
    {
        static const __m128i Y[numSamples]
        {_mm_set1_epi32(samplePosYi[0]), _mm_set1_epi32(samplePosYi[1]), _mm_set1_epi32(samplePosYi[2]), _mm_set1_epi32(samplePosYi[3]), 
         _mm_set1_epi32(samplePosYi[4]), _mm_set1_epi32(samplePosYi[5]), _mm_set1_epi32(samplePosYi[6]), _mm_set1_epi32(samplePosYi[7]), 
         _mm_set1_epi32(samplePosYi[8]), _mm_set1_epi32(samplePosYi[9]), _mm_set1_epi32(samplePosYi[10]), _mm_set1_epi32(samplePosYi[11]), 
         _mm_set1_epi32(samplePosYi[12]), _mm_set1_epi32(samplePosYi[13]), _mm_set1_epi32(samplePosYi[14]), _mm_set1_epi32(samplePosYi[15])};
        SWR_ASSERT(sampleNum < numSamples);
        return Y[sampleNum];
    }

    INLINE static simdscalar vX(uint32_t sampleNum)
    {
        static const simdscalar X[numSamples]
        {_simd_set1_ps(0.5625), _simd_set1_ps(0.4375), _simd_set1_ps(0.3125), _simd_set1_ps(0.7500),
         _simd_set1_ps(0.1875), _simd_set1_ps(0.6250), _simd_set1_ps(0.8125), _simd_set1_ps(0.6875),
         _simd_set1_ps(0.3750), _simd_set1_ps(0.5000), _simd_set1_ps(0.2500), _simd_set1_ps(0.1250),
         _simd_set1_ps(0.0000), _simd_set1_ps(0.9375), _simd_set1_ps(0.8750), _simd_set1_ps(0.0625)};
        assert(sampleNum < numSamples);
        return X[sampleNum];
    }

    INLINE static simdscalar vY(uint32_t sampleNum)
    {
        static const simdscalar Y[numSamples]
        {_simd_set1_ps(0.5625), _simd_set1_ps(0.3125), _simd_set1_ps(0.6250), _simd_set1_ps(0.4375),
         _simd_set1_ps(0.3750), _simd_set1_ps(0.8125), _simd_set1_ps(0.6875), _simd_set1_ps(0.1875),
         _simd_set1_ps(0.8750), _simd_set1_ps(0.0625), _simd_set1_ps(0.1250), _simd_set1_ps(0.7500),
         _simd_set1_ps(0.5000), _simd_set1_ps(0.2500), _simd_set1_ps(0.9375), _simd_set1_ps(0.0000)};
        assert(sampleNum < numSamples);
        return Y[sampleNum];
    }

    INLINE static float X(uint32_t sampleNum) { SWR_ASSERT(sampleNum < numSamples); return samplePosX[sampleNum]; };
    INLINE static float Y(uint32_t sampleNum) { SWR_ASSERT(sampleNum < numSamples); return samplePosY[sampleNum]; };

    INLINE static __m128i TileSampleOffsetsX()
    {
        static const uint32_t bboxLeftEdge = 0x00;
        static const uint32_t bboxRightEdge = 0xF0;
                                                            // BR,            BL,           UR,            UL
        static const __m128i tileSampleOffsetX = _mm_set_epi32(bboxRightEdge, bboxLeftEdge, bboxRightEdge, bboxLeftEdge);
        return tileSampleOffsetX;
    }

    INLINE static __m128i TileSampleOffsetsY()
    {
        static const uint32_t bboxTopEdge = 0x00;
        static const uint32_t bboxBottomEdge = 0xF0;
                                                            // BR,             BL,             UR,          UL
        static const __m128i tileSampleOffsetY = _mm_set_epi32(bboxBottomEdge, bboxBottomEdge, bboxTopEdge, bboxTopEdge);
        return tileSampleOffsetY;
    }

    INLINE static simdscalari FullSampleMask()
    {
        static const simdscalari mask = _simd_set1_epi32(0xFFFF);
        return mask;
    }

    static const uint32_t samplePosXi[16];
    static const uint32_t samplePosYi[16];
    static const float samplePosX[16];
    static const float samplePosY[16];
    static const uint32_t numSamples = 16;
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_16X;
    static const uint32_t numCoverageSamples = 16;
};

template<>
struct MultisampleTraits<SWR_MULTISAMPLE_16X, SWR_MSAA_CENTER_PATTERN>
{
    INLINE static __m128i vXi(uint32_t sampleNum)
    {
        return _mm_set1_epi32(0x80);
    }

    INLINE static __m128i vYi(uint32_t sampleNum)
    {
        return _mm_set1_epi32(0x80);
    }

    INLINE static simdscalar vX(uint32_t sampleNum)
    {
        return _simd_set1_ps(0.5f);
    }

    INLINE static simdscalar vY(uint32_t sampleNum)
    {
        return _simd_set1_ps(0.5f);
    }

    INLINE static float X(uint32_t sampleNum) {return 0.5f;};
    INLINE static float Y(uint32_t sampleNum) {return 0.5f;};

    INLINE static __m128i TileSampleOffsetsX()
    {
        // BR,            BL,           UR,            UL
        return _mm_set1_epi32(0x80);
    }

    INLINE static __m128i TileSampleOffsetsY()
    {
        // BR,             BL,             UR,          UL
        return _mm_set1_epi32(0x80);
    }
    
    INLINE static simdscalari FullSampleMask()
    {
        static const simdscalari mask = _simd_set1_epi32(0xFFFF);
        return mask;
    }
    static const uint32_t numSamples = 16;
    static const float samplePosX[16];
    static const float samplePosY[16];
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_16X;
    static const uint32_t numCoverageSamples = 1;
};
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 13.0.2
@
text
@@


1.1.1.2
log
@Import Mesa 17.1.6
@
text
@d61 1
a61 1
template<SWR_MULTISAMPLE_COUNT sampleCount, bool isCenter = false>
d64 4
d70 2
d78 1
a78 1
struct MultisampleTraits<SWR_MULTISAMPLE_1X, false>
d80 45
a124 2
    INLINE static float X(uint32_t sampleNum) {return samplePosX[sampleNum];};
    INLINE static float Y(uint32_t sampleNum) {return samplePosY[sampleNum];};
d127 4
a131 1
    static const uint32_t numCoverageSamples = 1;
d133 1
a133 4
    static constexpr uint32_t samplePosXi[1] = { 0x80 };
    static constexpr uint32_t samplePosYi[1] = { 0x80 };
    static constexpr float samplePosX[1] = { 0.5f };
    static constexpr float samplePosY[1] = { 0.5f };
d137 1
a137 1
struct MultisampleTraits<SWR_MULTISAMPLE_1X, true>
d139 20
d161 13
d177 3
a180 5
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_1X;
    static constexpr uint32_t samplePosXi[1] = { 0x80 };
    static constexpr uint32_t samplePosYi[1] = { 0x80 };
    static constexpr float samplePosX[1] = { 0.5f };
    static constexpr float samplePosY[1] = { 0.5f };
d184 1
a184 1
struct MultisampleTraits<SWR_MULTISAMPLE_2X, false>
d186 28
d216 19
d241 4
d246 1
a247 5
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_2X;
    static constexpr uint32_t samplePosXi[2] = { 0xC0, 0x40 };
    static constexpr uint32_t samplePosYi[2] = { 0xC0, 0x40 };
    static constexpr float samplePosX[2] = {0.75f, 0.25f};
    static constexpr float samplePosY[2] = {0.75f, 0.25f};
d251 1
a251 1
struct MultisampleTraits<SWR_MULTISAMPLE_2X, true>
d253 20
d275 13
d294 3
a297 5
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_2X;
    static constexpr uint32_t samplePosXi[2] = { 0x80 , 0x80 };
    static constexpr uint32_t samplePosYi[2] = { 0x80 , 0x80 };
    static constexpr float samplePosX[2] = { 0.5f, 0.5f };
    static constexpr float samplePosY[2] = { 0.5f, 0.5f };
d301 1
a301 1
struct MultisampleTraits<SWR_MULTISAMPLE_4X, false>
d303 32
d337 19
d362 4
d367 1
a368 5
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_4X;
    static constexpr uint32_t samplePosXi[4] = { 0x60, 0xE0, 0x20, 0xA0 };
    static constexpr uint32_t samplePosYi[4] = { 0x20, 0x60, 0xA0, 0xE0 };
    static constexpr float samplePosX[4] = { 0.375f, 0.875f, 0.125f, 0.625f };
    static constexpr float samplePosY[4] = { 0.125f, 0.375f, 0.625f, 0.875f };
d372 1
a372 1
struct MultisampleTraits<SWR_MULTISAMPLE_4X, true>
d374 20
d396 13
a413 1

d415 3
a418 5
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_4X;
    static constexpr uint32_t samplePosXi[4] = { 0x80, 0x80, 0x80, 0x80 };
    static constexpr uint32_t samplePosYi[4] = { 0x80, 0x80, 0x80, 0x80 };
    static constexpr float samplePosX[4] = { 0.5f, 0.5f, 0.5f, 0.5f };
    static constexpr float samplePosY[4] = { 0.5f, 0.5f, 0.5f, 0.5f };
d422 1
a422 1
struct MultisampleTraits<SWR_MULTISAMPLE_8X, false>
d424 36
d462 19
d487 4
d492 1
a493 5
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_8X;
    static constexpr uint32_t samplePosXi[8] = { 0x90, 0x70, 0xD0, 0x50, 0x30, 0x10, 0xB0, 0xF0 };
    static constexpr uint32_t samplePosYi[8] = { 0x50, 0xB0, 0x90, 0x30, 0xD0, 0x70, 0xF0, 0x10 };
    static constexpr float samplePosX[8] = { 0.5625f, 0.4375f, 0.8125f, 0.3125f, 0.1875f, 0.0625f, 0.6875f, 0.9375f };
    static constexpr float samplePosY[8] = { 0.3125f, 0.6875f, 0.5625f, 0.1875f, 0.8125f, 0.4375f, 0.9375f, 0.0625f };
d497 1
a497 1
struct MultisampleTraits<SWR_MULTISAMPLE_8X, true>
d499 20
d521 13
d540 3
a543 5
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_8X;
    static constexpr uint32_t samplePosXi[8] = { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 };
    static constexpr uint32_t samplePosYi[8] = { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 };
    static constexpr float samplePosX[8] = { 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f };
    static constexpr float samplePosY[8] = { 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f };
d547 1
a547 1
struct MultisampleTraits<SWR_MULTISAMPLE_16X, false>
d549 44
d595 19
d620 4
d625 1
a626 5
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_16X;
    static constexpr uint32_t samplePosXi[16] = { 0x90, 0x70, 0x50, 0xC0, 0x30, 0xA0, 0xD0, 0xB0, 0x60, 0x80, 0x40, 0x20, 0x00, 0xF0, 0xE0, 0x10 };
    static constexpr uint32_t samplePosYi[16] = { 0x90, 0x50, 0xA0, 0x70, 0x60, 0xD0, 0xB0, 0x30, 0xE0, 0x10, 0x20, 0xC0, 0x80, 0x40, 0xF0, 0x00 };
    static constexpr float samplePosX[16] = { 0.5625f, 0.4375f, 0.3125f, 0.7500f, 0.1875f, 0.6250f, 0.8125f, 0.6875f, 0.3750f, 0.5000f, 0.2500f, 0.1250f, 0.0000f, 0.9375f, 0.8750f, 0.0625f };
    static constexpr float samplePosY[16] = { 0.5625f, 0.3125f, 0.6250f, 0.4375f, 0.3750f, 0.8125f, 0.6875f, 0.1875f, 0.8750f, 0.0625f, 0.1250f, 0.7500f, 0.5000f, 0.2500f, 0.9375f, 0.0000f };
d630 1
a630 1
struct MultisampleTraits<SWR_MULTISAMPLE_16X, true>
d632 20
d654 13
d673 3
d677 1
a677 53
    static const SWR_MULTISAMPLE_COUNT sampleCount = SWR_MULTISAMPLE_16X;
    static constexpr uint32_t samplePosXi[16] = { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 };
    static constexpr uint32_t samplePosYi[16] = { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 };
    static constexpr float samplePosX[16] = { 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f };
    static constexpr float samplePosY[16] = { 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f };
};

INLINE
bool isNonStandardPattern(const SWR_MULTISAMPLE_COUNT sampleCount, const SWR_MULTISAMPLE_POS& samplePos)
{
    // detect if we're using standard or center sample patterns
    const uint32_t *standardPosX, *standardPosY;
    switch(sampleCount)
    {
    case SWR_MULTISAMPLE_1X:
        standardPosX = MultisampleTraits<SWR_MULTISAMPLE_1X>::samplePosXi;
        standardPosY = MultisampleTraits<SWR_MULTISAMPLE_1X>::samplePosYi;
        break;
    case SWR_MULTISAMPLE_2X:
        standardPosX = MultisampleTraits<SWR_MULTISAMPLE_2X>::samplePosXi;
        standardPosY = MultisampleTraits<SWR_MULTISAMPLE_2X>::samplePosYi;
        break;
    case SWR_MULTISAMPLE_4X:
        standardPosX = MultisampleTraits<SWR_MULTISAMPLE_4X>::samplePosXi;
        standardPosY = MultisampleTraits<SWR_MULTISAMPLE_4X>::samplePosYi;
        break;
    case SWR_MULTISAMPLE_8X:
        standardPosX = MultisampleTraits<SWR_MULTISAMPLE_8X>::samplePosXi;
        standardPosY = MultisampleTraits<SWR_MULTISAMPLE_8X>::samplePosYi;
        break;
    case SWR_MULTISAMPLE_16X:
        standardPosX = MultisampleTraits<SWR_MULTISAMPLE_16X>::samplePosXi;
        standardPosY = MultisampleTraits<SWR_MULTISAMPLE_16X>::samplePosYi;
        break;
    default:
        break;
    }

    // scan sample pattern for standard or center
    uint32_t numSamples = GetNumSamples(sampleCount);
    bool bIsStandard = true;
    if(numSamples > 1)
    {
        for(uint32_t i = 0; i < numSamples; i++)
        {
            bIsStandard = (standardPosX[i] == samplePos.Xi(i)) ||
                (standardPosY[i] == samplePos.Yi(i));
            if(!bIsStandard)
                break;
        }
    }
    return !bIsStandard;
}@

