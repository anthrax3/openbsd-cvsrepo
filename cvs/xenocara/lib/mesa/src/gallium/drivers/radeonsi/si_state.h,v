head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.44.32;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.32;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.20.11;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.28.14;	author jsg;	state Exp;
branches;
next	;
commitid	uuv5VTS15jglEDZU;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright 2012 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *      Christian KÃ¶nig <christian.koenig@@amd.com>
 */

#ifndef SI_STATE_H
#define SI_STATE_H

#include "si_pm4.h"
#include "radeon/r600_pipe_common.h"

#define SI_NUM_SHADERS (PIPE_SHADER_TESS_EVAL+1)

struct si_screen;
struct si_shader;

struct si_state_blend {
	struct si_pm4_state	pm4;
	uint32_t		cb_target_mask;
	bool			alpha_to_one;
	bool			dual_src_blend;
};

struct si_state_sample_mask {
	struct si_pm4_state	pm4;
	uint16_t		sample_mask;
};

struct si_state_scissor {
	struct si_pm4_state		pm4;
	struct pipe_scissor_state	scissor;
};

struct si_state_viewport {
	struct si_pm4_state		pm4;
	struct pipe_viewport_state	viewport;
};

struct si_state_rasterizer {
	struct si_pm4_state	pm4;
	bool			flatshade;
	bool			two_side;
	bool			multisample_enable;
	bool			line_stipple_enable;
	unsigned		sprite_coord_enable;
	unsigned		pa_sc_line_stipple;
	unsigned		pa_cl_clip_cntl;
	unsigned		clip_plane_enable;
	float			offset_units;
	float			offset_scale;
	bool			poly_stipple_enable;
	bool			line_smooth;
	bool			poly_smooth;
};

struct si_state_dsa {
	struct si_pm4_state	pm4;
	unsigned		alpha_func;
	uint8_t			valuemask[2];
	uint8_t			writemask[2];
};

struct si_vertex_element
{
	unsigned			count;
	uint32_t			rsrc_word3[PIPE_MAX_ATTRIBS];
	uint32_t			format_size[PIPE_MAX_ATTRIBS];
	struct pipe_vertex_element	elements[PIPE_MAX_ATTRIBS];
};

union si_state {
	struct {
		struct si_state_blend		*blend;
		struct si_pm4_state		*blend_color;
		struct si_pm4_state		*clip;
		struct si_state_sample_mask	*sample_mask;
		struct si_state_scissor		*scissor[16];
		struct si_state_viewport	*viewport[16];
		struct si_state_rasterizer	*rasterizer;
		struct si_state_dsa		*dsa;
		struct si_pm4_state		*fb_rs;
		struct si_pm4_state		*fb_blend;
		struct si_pm4_state		*dsa_stencil_ref;
		struct si_pm4_state		*ta_bordercolor_base;
		struct si_pm4_state		*ls;
		struct si_pm4_state		*hs;
		struct si_pm4_state		*es;
		struct si_pm4_state		*gs;
		struct si_pm4_state		*gs_rings;
		struct si_pm4_state		*tf_ring;
		struct si_pm4_state		*vgt_shader_config;
		struct si_pm4_state		*vs;
		struct si_pm4_state		*ps;
		struct si_pm4_state		*spi;
	} named;
	struct si_pm4_state	*array[0];
};

struct si_shader_data {
	struct r600_atom	atom;
	uint32_t		sh_base[SI_NUM_SHADERS];
};

#define SI_NUM_USER_SAMPLERS            16 /* AKA OpenGL textures units per shader */
#define SI_POLY_STIPPLE_SAMPLER         SI_NUM_USER_SAMPLERS
#define SI_NUM_SAMPLERS                 (SI_POLY_STIPPLE_SAMPLER + 1)

/* User sampler views:   0..15
 * Polygon stipple tex:  16
 * FMASK sampler views:  17..33 (no sampler states)
 */
#define SI_FMASK_TEX_OFFSET		SI_NUM_SAMPLERS
#define SI_NUM_SAMPLER_VIEWS		(SI_FMASK_TEX_OFFSET + SI_NUM_SAMPLERS)
#define SI_NUM_SAMPLER_STATES		SI_NUM_SAMPLERS

/* User constant buffers:   0..15
 * Driver state constants:  16
 */
#define SI_NUM_USER_CONST_BUFFERS	16
#define SI_DRIVER_STATE_CONST_BUF	SI_NUM_USER_CONST_BUFFERS
#define SI_NUM_CONST_BUFFERS		(SI_DRIVER_STATE_CONST_BUF + 1)

/* Read-write buffer slots.
 *
 * Ring buffers:        0..1
 * Streamout buffers:   2..5
 */
#define SI_RING_TESS_FACTOR	0 /* for HS (TCS)  */
#define SI_RING_ESGS		0 /* for ES, GS */
#define SI_RING_GSVS		1 /* for GS, VS */
#define SI_RING_GSVS_1		2 /* 1, 2, 3 for GS */
#define SI_RING_GSVS_2		3
#define SI_RING_GSVS_3		4
#define SI_NUM_RING_BUFFERS	5
#define SI_SO_BUF_OFFSET	SI_NUM_RING_BUFFERS
#define SI_NUM_RW_BUFFERS	(SI_SO_BUF_OFFSET + 4)

#define SI_NUM_VERTEX_BUFFERS	16


/* This represents descriptors in memory, such as buffer resources,
 * image resources, and sampler states.
 */
struct si_descriptors {
	/* The list of descriptors in malloc'd memory. */
	uint32_t *list;
	/* The size of one descriptor. */
	unsigned element_dw_size;
	/* The maximum number of descriptors. */
	unsigned num_elements;
	/* Whether the list has been changed and should be re-uploaded. */
	bool list_dirty;

	/* The buffer where the descriptors have been uploaded. */
	struct r600_resource *buffer;
	unsigned buffer_offset;

	/* The i-th bit is set if that element is enabled (non-NULL resource). */
	uint64_t enabled_mask;

	/* The shader userdata offset within a shader where the 64-bit pointer to the descriptor
	 * array will be stored. */
	unsigned shader_userdata_offset;
	/* Whether the pointer should be re-emitted. */
	bool pointer_dirty;
};

struct si_sampler_views {
	struct si_descriptors		desc;
	struct pipe_sampler_view	*views[SI_NUM_SAMPLER_VIEWS];
};

struct si_sampler_states {
	struct si_descriptors		desc;
	void				*saved_states[2]; /* saved for u_blitter */
};

struct si_buffer_resources {
	struct si_descriptors		desc;
	enum radeon_bo_usage		shader_usage; /* READ, WRITE, or READWRITE */
	enum radeon_bo_priority		priority;
	struct pipe_resource		**buffers; /* this has num_buffers elements */
};

#define si_pm4_block_idx(member) \
	(offsetof(union si_state, named.member) / sizeof(struct si_pm4_state *))

#define si_pm4_state_changed(sctx, member) \
	((sctx)->queued.named.member != (sctx)->emitted.named.member)

#define si_pm4_bind_state(sctx, member, value) \
	do { \
		(sctx)->queued.named.member = (value); \
	} while(0)

#define si_pm4_delete_state(sctx, member, value) \
	do { \
		if ((sctx)->queued.named.member == (value)) { \
			(sctx)->queued.named.member = NULL; \
		} \
		si_pm4_free_state(sctx, (struct si_pm4_state *)(value), \
				  si_pm4_block_idx(member)); \
	} while(0)

#define si_pm4_set_state(sctx, member, value) \
	do { \
		if ((sctx)->queued.named.member != (value)) { \
			si_pm4_free_state(sctx, \
				(struct si_pm4_state *)(sctx)->queued.named.member, \
				si_pm4_block_idx(member)); \
			(sctx)->queued.named.member = (value); \
		} \
	} while(0)

/* si_descriptors.c */
void si_set_sampler_descriptors(struct si_context *sctx, unsigned shader,
				unsigned start, unsigned count, void **states);
void si_set_ring_buffer(struct pipe_context *ctx, uint shader, uint slot,
			struct pipe_resource *buffer,
			unsigned stride, unsigned num_records,
			bool add_tid, bool swizzle,
			unsigned element_size, unsigned index_stride, uint64_t offset);
void si_init_all_descriptors(struct si_context *sctx);
bool si_upload_shader_descriptors(struct si_context *sctx);
void si_release_all_descriptors(struct si_context *sctx);
void si_all_descriptors_begin_new_cs(struct si_context *sctx);
void si_upload_const_buffer(struct si_context *sctx, struct r600_resource **rbuffer,
			    const uint8_t *ptr, unsigned size, uint32_t *const_offset);
void si_shader_change_notify(struct si_context *sctx);

/* si_state.c */
struct si_shader_selector;

void si_update_fb_blend_state(struct si_context *sctx);
boolean si_is_format_supported(struct pipe_screen *screen,
                               enum pipe_format format,
                               enum pipe_texture_target target,
                               unsigned sample_count,
                               unsigned usage);
void si_init_state_functions(struct si_context *sctx);
unsigned cik_bank_wh(unsigned bankwh);
unsigned cik_db_pipe_config(struct si_screen *sscreen, unsigned tile_mode);
unsigned cik_macro_tile_aspect(unsigned macro_tile_aspect);
unsigned cik_tile_split(unsigned tile_split);
unsigned si_array_mode(unsigned mode);
uint32_t si_num_banks(struct si_screen *sscreen, struct r600_texture *tex);
unsigned si_tile_mode_index(struct r600_texture *rtex, unsigned level, bool stencil);
struct pipe_sampler_view *
si_create_sampler_view_custom(struct pipe_context *ctx,
			      struct pipe_resource *texture,
			      const struct pipe_sampler_view *state,
			      unsigned width0, unsigned height0,
			      unsigned force_level);

/* si_state_shader.c */
bool si_update_shaders(struct si_context *sctx);
void si_init_shader_functions(struct si_context *sctx);

/* si_state_draw.c */
extern const struct r600_atom si_atom_cache_flush;
extern const struct r600_atom si_atom_msaa_sample_locs;
extern const struct r600_atom si_atom_msaa_config;
void si_emit_cache_flush(struct r600_common_context *sctx, struct r600_atom *atom);
void si_draw_vbo(struct pipe_context *ctx, const struct pipe_draw_info *dinfo);

/* si_commands.c */
void si_cmd_context_control(struct si_pm4_state *pm4);

#endif
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@a33 1
#define SI_MAX_ATTRIBS 16
a40 1
	bool			alpha_to_coverage;
d43 15
a57 5
	/* Set 0xf or 0x0 (4 bits) per render target if the following is
	 * true. ANDed with spi_shader_col_format.
	 */
	unsigned		blend_enable_4bit;
	unsigned		need_src_alpha_4bit;
a61 2
	/* poly offset states for 16-bit, 24-bit, and 32-bit zbuffers */
	struct si_pm4_state	pm4_poly_offset[3];
a64 1
	bool			force_persample_interp;
d70 2
a74 3
	bool			uses_poly_offset;
	bool			clamp_fragment_color;
	bool			rasterizer_discard;
d77 3
a79 1
struct si_dsa_stencil_ref_part {
a83 12
struct si_state_dsa {
	struct si_pm4_state		pm4;
	unsigned			alpha_func;
	struct si_dsa_stencil_ref_part	stencil_ref;
};

struct si_stencil_ref {
	struct r600_atom		atom;
	struct pipe_stencil_ref		state;
	struct si_dsa_stencil_ref_part	dsa_part;
};

d87 3
a89 3
	uint32_t			rsrc_word3[SI_MAX_ATTRIBS];
	uint32_t			format_size[SI_MAX_ATTRIBS];
	struct pipe_vertex_element	elements[SI_MAX_ATTRIBS];
d95 5
d102 4
a105 1
		struct si_pm4_state		*poly_offset;
d110 2
d115 1
a119 27
union si_state_atoms {
	struct {
		/* The order matters. */
		struct r600_atom *cache_flush;
		struct r600_atom *render_cond;
		struct r600_atom *streamout_begin;
		struct r600_atom *streamout_enable; /* must be after streamout_begin */
		struct r600_atom *framebuffer;
		struct r600_atom *msaa_sample_locs;
		struct r600_atom *db_render_state;
		struct r600_atom *msaa_config;
		struct r600_atom *sample_mask;
		struct r600_atom *cb_render_state;
		struct r600_atom *blend_color;
		struct r600_atom *clip_regs;
		struct r600_atom *clip_state;
		struct r600_atom *shader_userdata;
		struct r600_atom *scissors;
		struct r600_atom *viewports;
		struct r600_atom *stencil_ref;
		struct r600_atom *spi_map;
	} s;
	struct r600_atom *array[0];
};

#define SI_NUM_ATOMS (sizeof(union si_state_atoms)/sizeof(struct r600_atom*))

d125 4
d131 1
d133 3
a135 3
#define SI_NUM_USER_SAMPLERS            16 /* AKA OpenGL textures units per shader */
#define SI_POLY_STIPPLE_SAMPLER         SI_NUM_USER_SAMPLERS
#define SI_NUM_SAMPLERS                 (SI_POLY_STIPPLE_SAMPLER + 1)
d159 1
a159 1
#define SI_NUM_VERTEX_BUFFERS	SI_MAX_ATTRIBS
d191 6
a196 2
	struct pipe_sampler_view	*views[SI_NUM_SAMPLERS];
	void				*sampler_states[SI_NUM_SAMPLERS];
d226 10
d237 2
a250 1
void si_emit_shader_userdata(struct si_context *sctx, struct r600_atom *atom);
d255 1
a255 3
void si_init_atom(struct si_context *sctx, struct r600_atom *atom,
		  struct r600_atom **list_elem,
		  void (*emit_func)(struct si_context *ctx, struct r600_atom *state));
a278 2
bool si_init_shader_cache(struct si_screen *sscreen);
void si_destroy_shader_cache(struct si_screen *sscreen);
d281 4
a284 1
void si_emit_cache_flush(struct si_context *sctx, struct r600_atom *atom);
d286 3
a288 1
void si_trace_emit(struct si_context *sctx);
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d33 2
a34 9
#define SI_NUM_GRAPHICS_SHADERS (PIPE_SHADER_TESS_EVAL+1)
#define SI_NUM_SHADERS (PIPE_SHADER_COMPUTE+1)

#define SI_MAX_ATTRIBS			16
#define SI_NUM_VERTEX_BUFFERS		SI_MAX_ATTRIBS
#define SI_NUM_SAMPLERS			32 /* OpenGL textures units per shader */
#define SI_NUM_CONST_BUFFERS		16
#define SI_NUM_IMAGES			16
#define SI_NUM_SHADER_BUFFERS		16
a70 2
	bool			scissor_enable;
	bool			clip_halfz;
d118 1
d147 6
a152 23
/* Private read-write buffer slots. */
enum {
	SI_HS_RING_TESS_FACTOR,
	SI_HS_RING_TESS_OFFCHIP,

	SI_ES_RING_ESGS,
	SI_GS_RING_ESGS,

	SI_GS_RING_GSVS0,
	SI_GS_RING_GSVS1,
	SI_GS_RING_GSVS2,
	SI_GS_RING_GSVS3,
	SI_VS_RING_GSVS,

	SI_VS_STREAMOUT_BUF0,
	SI_VS_STREAMOUT_BUF1,
	SI_VS_STREAMOUT_BUF2,
	SI_VS_STREAMOUT_BUF3,

	SI_HS_CONST_DEFAULT_TESS_LEVELS,
	SI_VS_CONST_CLIP_PLANES,
	SI_PS_CONST_POLY_STIPPLE,
	SI_PS_CONST_SAMPLE_POSITIONS,
d154 6
a159 2
	SI_NUM_RW_BUFFERS,
};
d161 1
a161 2
/* Indices into sctx->descriptors, laid out so that gfx and compute pipelines
 * are contiguous:
d163 2
a164 8
 *  0 - rw buffers
 *  1 - vertex const buffers
 *  2 - vertex shader buffers
 *   ...
 *  5 - fragment const buffers
 *   ...
 *  21 - compute const buffers
 *   ...
d166 12
a177 12
#define SI_SHADER_DESCS_CONST_BUFFERS  0
#define SI_SHADER_DESCS_SHADER_BUFFERS 1
#define SI_SHADER_DESCS_SAMPLERS       2
#define SI_SHADER_DESCS_IMAGES         3
#define SI_NUM_SHADER_DESCS            4

#define SI_DESCS_RW_BUFFERS            0
#define SI_DESCS_FIRST_SHADER          1
#define SI_DESCS_FIRST_COMPUTE         (SI_DESCS_FIRST_SHADER + \
                                        PIPE_SHADER_COMPUTE * SI_NUM_SHADER_DESCS)
#define SI_NUM_DESCS                   (SI_DESCS_FIRST_SHADER + \
                                        SI_NUM_SHADERS * SI_NUM_SHADER_DESCS)
d189 2
d196 2
a197 9
	/* Offset in CE RAM */
	unsigned ce_offset;

	/* elements of the list that are changed and need to be uploaded */
	unsigned dirty_mask;

	/* Whether the CE ram is dirty and needs to be reinitialized entirely
	 * before we can do partial updates. */
	bool ce_ram_dirty;
d207 1
a209 3

	/* The i-th bit is set if that element is enabled (non-NULL resource). */
	unsigned			enabled_mask;
d213 1
a216 3

	/* The i-th bit is set if that element is enabled (non-NULL resource). */
	unsigned			enabled_mask;
d240 1
a240 13
void si_ce_reinitialize_all_descriptors(struct si_context *sctx);
void si_ce_enable_loads(struct radeon_winsys_cs *ib);
void si_set_mutable_tex_desc_fields(struct r600_texture *tex,
				    const struct radeon_surf_level *base_level_info,
				    unsigned base_level, unsigned first_level,
				    unsigned block_width, bool is_stencil,
				    uint32_t *state);
void si_get_pipe_constant_buffer(struct si_context *sctx, uint shader,
				 uint slot, struct pipe_constant_buffer *cbuf);
void si_get_shader_buffers(struct si_context *sctx, uint shader,
			   uint start_slot, uint count,
			   struct pipe_shader_buffer *sbuf);
void si_set_ring_buffer(struct pipe_context *ctx, uint slot,
d246 1
a246 3
bool si_upload_vertex_buffer_descriptors(struct si_context *sctx);
bool si_upload_graphics_shader_descriptors(struct si_context *sctx);
bool si_upload_compute_shader_descriptors(struct si_context *sctx);
a250 1
void si_update_all_texture_descriptors(struct si_context *sctx);
d252 2
a253 6
void si_update_compressed_colortex_masks(struct si_context *sctx);
void si_emit_graphics_shader_userdata(struct si_context *sctx,
                                      struct r600_atom *atom);
void si_emit_compute_shader_userdata(struct si_context *sctx);
void si_set_rw_buffer(struct si_context *sctx,
		      uint slot, const struct pipe_constant_buffer *input);
d260 5
d266 7
a272 18
void si_init_screen_state_functions(struct si_screen *sscreen);
void
si_make_buffer_descriptor(struct si_screen *screen, struct r600_resource *buf,
			  enum pipe_format format,
			  unsigned offset, unsigned size,
			  uint32_t *state);
void
si_make_texture_descriptor(struct si_screen *screen,
			   struct r600_texture *tex,
			   bool sampler,
			   enum pipe_texture_target target,
			   enum pipe_format pipe_format,
			   const unsigned char state_swizzle[4],
			   unsigned first_level, unsigned last_level,
			   unsigned first_layer, unsigned last_layer,
			   unsigned width, unsigned height, unsigned depth,
			   uint32_t *state,
			   uint32_t *fmask_state);
a284 1
void si_init_shader_selector_async(void *job, int thread_index);
d287 1
a287 3
void si_emit_cache_flush(struct si_context *sctx);
void si_ce_pre_draw_synchronization(struct si_context *sctx);
void si_ce_post_draw_synchronization(struct si_context *sctx);
a289 10


static inline unsigned
si_tile_mode_index(struct r600_texture *rtex, unsigned level, bool stencil)
{
	if (stencil)
		return rtex->surface.stencil_tiling_index[level];
	else
		return rtex->surface.tiling_index[level];
}
@


