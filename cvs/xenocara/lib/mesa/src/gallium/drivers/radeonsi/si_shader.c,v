head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	mesa-17_1_6:1.1.1.8
	OPENBSD_6_1:1.1.1.7.0.2
	OPENBSD_6_1_BASE:1.1.1.7
	mesa-13_0_6:1.1.1.7
	mesa-13_0_5:1.1.1.6
	mesa-13_0_3:1.1.1.5
	mesa-13_0_2:1.1.1.4
	OPENBSD_6_0:1.1.1.3.0.4
	OPENBSD_6_0_BASE:1.1.1.3
	mesa-11_2_2:1.1.1.3
	OPENBSD_5_9:1.1.1.2.0.2
	OPENBSD_5_9_BASE:1.1.1.2
	mesa-11_0_9:1.1.1.2
	mesa-11_0_8:1.1.1.2
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.26;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.44.33;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.33;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2015.12.23.13.26.30;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	bCnCUEGWDw3j16Q3;

1.1.1.3
date	2016.05.29.10.20.12;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.4
date	2016.12.11.08.28.20;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	uuv5VTS15jglEDZU;

1.1.1.5
date	2017.01.19.05.39.48;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	vYSESphXPMoytdgU;

1.1.1.6
date	2017.02.26.12.08.54;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	xZcdklZavddTKAf1;

1.1.1.7
date	2017.03.25.00.07.54;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	YgkKuQ9hssScckR1;

1.1.1.8
date	2017.08.14.09.33.04;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Copyright 2012 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *	Tom Stellard <thomas.stellard@@amd.com>
 *	Michel Dänzer <michel.daenzer@@amd.com>
 *      Christian König <christian.koenig@@amd.com>
 */

#include "gallivm/lp_bld_const.h"
#include "gallivm/lp_bld_gather.h"
#include "gallivm/lp_bld_intr.h"
#include "gallivm/lp_bld_logic.h"
#include "gallivm/lp_bld_arit.h"
#include "gallivm/lp_bld_flow.h"
#include "gallivm/lp_bld_misc.h"
#include "radeon/radeon_elf_util.h"
#include "util/u_memory.h"
#include "util/u_string.h"
#include "tgsi/tgsi_build.h"
#include "tgsi/tgsi_util.h"
#include "tgsi/tgsi_dump.h"

#include "si_shader_internal.h"
#include "si_pipe.h"
#include "sid.h"


static const char *scratch_rsrc_dword0_symbol =
	"SCRATCH_RSRC_DWORD0";

static const char *scratch_rsrc_dword1_symbol =
	"SCRATCH_RSRC_DWORD1";

struct si_shader_output_values
{
	LLVMValueRef values[4];
	unsigned name;
	unsigned sid;
};

static void si_init_shader_ctx(struct si_shader_context *ctx,
			       struct si_screen *sscreen,
			       struct si_shader *shader,
			       LLVMTargetMachineRef tm);

static void si_llvm_emit_barrier(const struct lp_build_tgsi_action *action,
				 struct lp_build_tgsi_context *bld_base,
				 struct lp_build_emit_data *emit_data);

static void si_dump_shader_key(unsigned shader, union si_shader_key *key,
			       FILE *f);

/* Ideally pass the sample mask input to the PS epilog as v13, which
 * is its usual location, so that the shader doesn't have to add v_mov.
 */
#define PS_EPILOG_SAMPLEMASK_MIN_LOC 13

/* The VS location of the PrimitiveID input is the same in the epilog,
 * so that the main shader part doesn't have to move it.
 */
#define VS_EPILOG_PRIMID_LOC 2

enum {
	CONST_ADDR_SPACE = 2,
	LOCAL_ADDR_SPACE = 3,
};

#define SENDMSG_GS 2
#define SENDMSG_GS_DONE 3

#define SENDMSG_GS_OP_NOP      (0 << 4)
#define SENDMSG_GS_OP_CUT      (1 << 4)
#define SENDMSG_GS_OP_EMIT     (2 << 4)
#define SENDMSG_GS_OP_EMIT_CUT (3 << 4)

/**
 * Returns a unique index for a semantic name and index. The index must be
 * less than 64, so that a 64-bit bitmask of used inputs or outputs can be
 * calculated.
 */
unsigned si_shader_io_get_unique_index(unsigned semantic_name, unsigned index)
{
	switch (semantic_name) {
	case TGSI_SEMANTIC_POSITION:
		return 0;
	case TGSI_SEMANTIC_PSIZE:
		return 1;
	case TGSI_SEMANTIC_CLIPDIST:
		assert(index <= 1);
		return 2 + index;
	case TGSI_SEMANTIC_GENERIC:
		if (index <= 63-4)
			return 4 + index;
		else
			/* same explanation as in the default statement,
			 * the only user hitting this is st/nine.
			 */
			return 0;

	/* patch indices are completely separate and thus start from 0 */
	case TGSI_SEMANTIC_TESSOUTER:
		return 0;
	case TGSI_SEMANTIC_TESSINNER:
		return 1;
	case TGSI_SEMANTIC_PATCH:
		return 2 + index;

	default:
		/* Don't fail here. The result of this function is only used
		 * for LS, TCS, TES, and GS, where legacy GL semantics can't
		 * occur, but this function is called for all vertex shaders
		 * before it's known whether LS will be compiled or not.
		 */
		return 0;
	}
}

/**
 * Get the value of a shader input parameter and extract a bitfield.
 */
static LLVMValueRef unpack_param(struct si_shader_context *ctx,
				 unsigned param, unsigned rshift,
				 unsigned bitwidth)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef value = LLVMGetParam(ctx->main_fn,
					  param);

	if (LLVMGetTypeKind(LLVMTypeOf(value)) == LLVMFloatTypeKind)
		value = bitcast(&ctx->soa.bld_base,
				TGSI_TYPE_UNSIGNED, value);

	if (rshift)
		value = LLVMBuildLShr(gallivm->builder, value,
				      lp_build_const_int32(gallivm, rshift), "");

	if (rshift + bitwidth < 32) {
		unsigned mask = (1 << bitwidth) - 1;
		value = LLVMBuildAnd(gallivm->builder, value,
				     lp_build_const_int32(gallivm, mask), "");
	}

	return value;
}

static LLVMValueRef get_rel_patch_id(struct si_shader_context *ctx)
{
	switch (ctx->type) {
	case PIPE_SHADER_TESS_CTRL:
		return unpack_param(ctx, SI_PARAM_REL_IDS, 0, 8);

	case PIPE_SHADER_TESS_EVAL:
		return LLVMGetParam(ctx->main_fn,
				    ctx->param_tes_rel_patch_id);

	default:
		assert(0);
		return NULL;
	}
}

/* Tessellation shaders pass outputs to the next shader using LDS.
 *
 * LS outputs = TCS inputs
 * TCS outputs = TES inputs
 *
 * The LDS layout is:
 * - TCS inputs for patch 0
 * - TCS inputs for patch 1
 * - TCS inputs for patch 2		= get_tcs_in_current_patch_offset (if RelPatchID==2)
 * - ...
 * - TCS outputs for patch 0            = get_tcs_out_patch0_offset
 * - Per-patch TCS outputs for patch 0  = get_tcs_out_patch0_patch_data_offset
 * - TCS outputs for patch 1
 * - Per-patch TCS outputs for patch 1
 * - TCS outputs for patch 2            = get_tcs_out_current_patch_offset (if RelPatchID==2)
 * - Per-patch TCS outputs for patch 2  = get_tcs_out_current_patch_data_offset (if RelPatchID==2)
 * - ...
 *
 * All three shaders VS(LS), TCS, TES share the same LDS space.
 */

static LLVMValueRef
get_tcs_in_patch_stride(struct si_shader_context *ctx)
{
	if (ctx->type == PIPE_SHADER_VERTEX)
		return unpack_param(ctx, SI_PARAM_LS_OUT_LAYOUT, 0, 13);
	else if (ctx->type == PIPE_SHADER_TESS_CTRL)
		return unpack_param(ctx, SI_PARAM_TCS_IN_LAYOUT, 0, 13);
	else {
		assert(0);
		return NULL;
	}
}

static LLVMValueRef
get_tcs_out_patch_stride(struct si_shader_context *ctx)
{
	return unpack_param(ctx, SI_PARAM_TCS_OUT_LAYOUT, 0, 13);
}

static LLVMValueRef
get_tcs_out_patch0_offset(struct si_shader_context *ctx)
{
	return lp_build_mul_imm(&ctx->soa.bld_base.uint_bld,
				unpack_param(ctx,
					     SI_PARAM_TCS_OUT_OFFSETS,
					     0, 16),
				4);
}

static LLVMValueRef
get_tcs_out_patch0_patch_data_offset(struct si_shader_context *ctx)
{
	return lp_build_mul_imm(&ctx->soa.bld_base.uint_bld,
				unpack_param(ctx,
					     SI_PARAM_TCS_OUT_OFFSETS,
					     16, 16),
				4);
}

static LLVMValueRef
get_tcs_in_current_patch_offset(struct si_shader_context *ctx)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef patch_stride = get_tcs_in_patch_stride(ctx);
	LLVMValueRef rel_patch_id = get_rel_patch_id(ctx);

	return LLVMBuildMul(gallivm->builder, patch_stride, rel_patch_id, "");
}

static LLVMValueRef
get_tcs_out_current_patch_offset(struct si_shader_context *ctx)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef patch0_offset = get_tcs_out_patch0_offset(ctx);
	LLVMValueRef patch_stride = get_tcs_out_patch_stride(ctx);
	LLVMValueRef rel_patch_id = get_rel_patch_id(ctx);

	return LLVMBuildAdd(gallivm->builder, patch0_offset,
			    LLVMBuildMul(gallivm->builder, patch_stride,
					 rel_patch_id, ""),
			    "");
}

static LLVMValueRef
get_tcs_out_current_patch_data_offset(struct si_shader_context *ctx)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef patch0_patch_data_offset =
		get_tcs_out_patch0_patch_data_offset(ctx);
	LLVMValueRef patch_stride = get_tcs_out_patch_stride(ctx);
	LLVMValueRef rel_patch_id = get_rel_patch_id(ctx);

	return LLVMBuildAdd(gallivm->builder, patch0_patch_data_offset,
			    LLVMBuildMul(gallivm->builder, patch_stride,
					 rel_patch_id, ""),
			    "");
}

static LLVMValueRef build_gep0(struct si_shader_context *ctx,
			       LLVMValueRef base_ptr, LLVMValueRef index)
{
	LLVMValueRef indices[2] = {
		LLVMConstInt(ctx->i32, 0, 0),
		index,
	};
	return LLVMBuildGEP(ctx->gallivm.builder, base_ptr,
			    indices, 2, "");
}

static void build_indexed_store(struct si_shader_context *ctx,
				LLVMValueRef base_ptr, LLVMValueRef index,
				LLVMValueRef value)
{
	struct lp_build_tgsi_context *bld_base = &ctx->soa.bld_base;
	struct gallivm_state *gallivm = bld_base->base.gallivm;

	LLVMBuildStore(gallivm->builder, value,
		       build_gep0(ctx, base_ptr, index));
}

/**
 * Build an LLVM bytecode indexed load using LLVMBuildGEP + LLVMBuildLoad.
 * It's equivalent to doing a load from &base_ptr[index].
 *
 * \param base_ptr  Where the array starts.
 * \param index     The element index into the array.
 * \param uniform   Whether the base_ptr and index can be assumed to be
 *                  dynamically uniform
 */
static LLVMValueRef build_indexed_load(struct si_shader_context *ctx,
				       LLVMValueRef base_ptr, LLVMValueRef index,
				       bool uniform)
{
	struct lp_build_tgsi_context *bld_base = &ctx->soa.bld_base;
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef pointer;

	pointer = build_gep0(ctx, base_ptr, index);
	if (uniform)
		LLVMSetMetadata(pointer, ctx->uniform_md_kind, ctx->empty_md);
	return LLVMBuildLoad(gallivm->builder, pointer, "");
}

/**
 * Do a load from &base_ptr[index], but also add a flag that it's loading
 * a constant from a dynamically uniform index.
 */
static LLVMValueRef build_indexed_load_const(
	struct si_shader_context *ctx,
	LLVMValueRef base_ptr, LLVMValueRef index)
{
	LLVMValueRef result = build_indexed_load(ctx, base_ptr, index, true);
	LLVMSetMetadata(result, ctx->invariant_load_md_kind, ctx->empty_md);
	return result;
}

static LLVMValueRef get_instance_index_for_fetch(
	struct si_shader_context *radeon_bld,
	unsigned param_start_instance, unsigned divisor)
{
	struct si_shader_context *ctx =
		si_shader_context(&radeon_bld->soa.bld_base);
	struct gallivm_state *gallivm = radeon_bld->soa.bld_base.base.gallivm;

	LLVMValueRef result = LLVMGetParam(radeon_bld->main_fn,
					   ctx->param_instance_id);

	/* The division must be done before START_INSTANCE is added. */
	if (divisor > 1)
		result = LLVMBuildUDiv(gallivm->builder, result,
				lp_build_const_int32(gallivm, divisor), "");

	return LLVMBuildAdd(gallivm->builder, result,
			    LLVMGetParam(radeon_bld->main_fn, param_start_instance), "");
}

static void declare_input_vs(
	struct si_shader_context *radeon_bld,
	unsigned input_index,
	const struct tgsi_full_declaration *decl,
	LLVMValueRef out[4])
{
	struct lp_build_context *base = &radeon_bld->soa.bld_base.base;
	struct gallivm_state *gallivm = base->gallivm;
	struct si_shader_context *ctx =
		si_shader_context(&radeon_bld->soa.bld_base);
	unsigned divisor =
		ctx->shader->key.vs.prolog.instance_divisors[input_index];

	unsigned chan;

	LLVMValueRef t_list_ptr;
	LLVMValueRef t_offset;
	LLVMValueRef t_list;
	LLVMValueRef attribute_offset;
	LLVMValueRef buffer_index;
	LLVMValueRef args[3];
	LLVMValueRef input;

	/* Load the T list */
	t_list_ptr = LLVMGetParam(ctx->main_fn, SI_PARAM_VERTEX_BUFFERS);

	t_offset = lp_build_const_int32(gallivm, input_index);

	t_list = build_indexed_load_const(ctx, t_list_ptr, t_offset);

	/* Build the attribute offset */
	attribute_offset = lp_build_const_int32(gallivm, 0);

	if (!ctx->is_monolithic) {
		buffer_index = LLVMGetParam(radeon_bld->main_fn,
					    ctx->param_vertex_index0 +
					    input_index);
	} else if (divisor) {
		/* Build index from instance ID, start instance and divisor */
		ctx->shader->info.uses_instanceid = true;
		buffer_index = get_instance_index_for_fetch(ctx,
							    SI_PARAM_START_INSTANCE,
							    divisor);
	} else {
		/* Load the buffer index for vertices. */
		LLVMValueRef vertex_id = LLVMGetParam(ctx->main_fn,
						      ctx->param_vertex_id);
		LLVMValueRef base_vertex = LLVMGetParam(radeon_bld->main_fn,
							SI_PARAM_BASE_VERTEX);
		buffer_index = LLVMBuildAdd(gallivm->builder, base_vertex, vertex_id, "");
	}

	args[0] = t_list;
	args[1] = attribute_offset;
	args[2] = buffer_index;
	input = lp_build_intrinsic(gallivm->builder,
		"llvm.SI.vs.load.input", ctx->v4f32, args, 3,
		LLVMReadNoneAttribute);

	/* Break up the vec4 into individual components */
	for (chan = 0; chan < 4; chan++) {
		LLVMValueRef llvm_chan = lp_build_const_int32(gallivm, chan);
		out[chan] = LLVMBuildExtractElement(gallivm->builder,
						    input, llvm_chan, "");
	}
}

static LLVMValueRef get_primitive_id(struct lp_build_tgsi_context *bld_base,
				     unsigned swizzle)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);

	if (swizzle > 0)
		return bld_base->uint_bld.zero;

	switch (ctx->type) {
	case PIPE_SHADER_VERTEX:
		return LLVMGetParam(ctx->main_fn,
				    ctx->param_vs_prim_id);
	case PIPE_SHADER_TESS_CTRL:
		return LLVMGetParam(ctx->main_fn,
				    SI_PARAM_PATCH_ID);
	case PIPE_SHADER_TESS_EVAL:
		return LLVMGetParam(ctx->main_fn,
				    ctx->param_tes_patch_id);
	case PIPE_SHADER_GEOMETRY:
		return LLVMGetParam(ctx->main_fn,
				    SI_PARAM_PRIMITIVE_ID);
	default:
		assert(0);
		return bld_base->uint_bld.zero;
	}
}

/**
 * Return the value of tgsi_ind_register for indexing.
 * This is the indirect index with the constant offset added to it.
 */
static LLVMValueRef get_indirect_index(struct si_shader_context *ctx,
				       const struct tgsi_ind_register *ind,
				       int rel_index)
{
	struct gallivm_state *gallivm = ctx->soa.bld_base.base.gallivm;
	LLVMValueRef result;

	result = ctx->soa.addr[ind->Index][ind->Swizzle];
	result = LLVMBuildLoad(gallivm->builder, result, "");
	result = LLVMBuildAdd(gallivm->builder, result,
			      lp_build_const_int32(gallivm, rel_index), "");
	return result;
}

/**
 * Like get_indirect_index, but restricts the return value to a (possibly
 * undefined) value inside [0..num).
 */
static LLVMValueRef get_bounded_indirect_index(struct si_shader_context *ctx,
					       const struct tgsi_ind_register *ind,
					       int rel_index, unsigned num)
{
	LLVMValueRef result = get_indirect_index(ctx, ind, rel_index);

	/* LLVM 3.8: If indirect resource indexing is used:
	 * - SI & CIK hang
	 * - VI crashes
	 */
	if (HAVE_LLVM <= 0x0308)
		return LLVMGetUndef(ctx->i32);

	return si_llvm_bound_index(ctx, result, num);
}


/**
 * Calculate a dword address given an input or output register and a stride.
 */
static LLVMValueRef get_dw_address(struct si_shader_context *ctx,
				   const struct tgsi_full_dst_register *dst,
				   const struct tgsi_full_src_register *src,
				   LLVMValueRef vertex_dw_stride,
				   LLVMValueRef base_addr)
{
	struct gallivm_state *gallivm = ctx->soa.bld_base.base.gallivm;
	struct tgsi_shader_info *info = &ctx->shader->selector->info;
	ubyte *name, *index, *array_first;
	int first, param;
	struct tgsi_full_dst_register reg;

	/* Set the register description. The address computation is the same
	 * for sources and destinations. */
	if (src) {
		reg.Register.File = src->Register.File;
		reg.Register.Index = src->Register.Index;
		reg.Register.Indirect = src->Register.Indirect;
		reg.Register.Dimension = src->Register.Dimension;
		reg.Indirect = src->Indirect;
		reg.Dimension = src->Dimension;
		reg.DimIndirect = src->DimIndirect;
	} else
		reg = *dst;

	/* If the register is 2-dimensional (e.g. an array of vertices
	 * in a primitive), calculate the base address of the vertex. */
	if (reg.Register.Dimension) {
		LLVMValueRef index;

		if (reg.Dimension.Indirect)
			index = get_indirect_index(ctx, &reg.DimIndirect,
						   reg.Dimension.Index);
		else
			index = lp_build_const_int32(gallivm, reg.Dimension.Index);

		base_addr = LLVMBuildAdd(gallivm->builder, base_addr,
					 LLVMBuildMul(gallivm->builder, index,
						      vertex_dw_stride, ""), "");
	}

	/* Get information about the register. */
	if (reg.Register.File == TGSI_FILE_INPUT) {
		name = info->input_semantic_name;
		index = info->input_semantic_index;
		array_first = info->input_array_first;
	} else if (reg.Register.File == TGSI_FILE_OUTPUT) {
		name = info->output_semantic_name;
		index = info->output_semantic_index;
		array_first = info->output_array_first;
	} else {
		assert(0);
		return NULL;
	}

	if (reg.Register.Indirect) {
		/* Add the relative address of the element. */
		LLVMValueRef ind_index;

		if (reg.Indirect.ArrayID)
			first = array_first[reg.Indirect.ArrayID];
		else
			first = reg.Register.Index;

		ind_index = get_indirect_index(ctx, &reg.Indirect,
					   reg.Register.Index - first);

		base_addr = LLVMBuildAdd(gallivm->builder, base_addr,
				    LLVMBuildMul(gallivm->builder, ind_index,
						 lp_build_const_int32(gallivm, 4), ""), "");

		param = si_shader_io_get_unique_index(name[first], index[first]);
	} else {
		param = si_shader_io_get_unique_index(name[reg.Register.Index],
						      index[reg.Register.Index]);
	}

	/* Add the base address of the element. */
	return LLVMBuildAdd(gallivm->builder, base_addr,
			    lp_build_const_int32(gallivm, param * 4), "");
}

/* The offchip buffer layout for TCS->TES is
 *
 * - attribute 0 of patch 0 vertex 0
 * - attribute 0 of patch 0 vertex 1
 * - attribute 0 of patch 0 vertex 2
 *   ...
 * - attribute 0 of patch 1 vertex 0
 * - attribute 0 of patch 1 vertex 1
 *   ...
 * - attribute 1 of patch 0 vertex 0
 * - attribute 1 of patch 0 vertex 1
 *   ...
 * - per patch attribute 0 of patch 0
 * - per patch attribute 0 of patch 1
 *   ...
 *
 * Note that every attribute has 4 components.
 */
static LLVMValueRef get_tcs_tes_buffer_address(struct si_shader_context *ctx,
                                               LLVMValueRef vertex_index,
                                               LLVMValueRef param_index)
{
	struct gallivm_state *gallivm = ctx->soa.bld_base.base.gallivm;
	LLVMValueRef base_addr, vertices_per_patch, num_patches, total_vertices;
	LLVMValueRef param_stride, constant16;

	vertices_per_patch = unpack_param(ctx, SI_PARAM_TCS_OFFCHIP_LAYOUT, 9, 6);
	num_patches = unpack_param(ctx, SI_PARAM_TCS_OFFCHIP_LAYOUT, 0, 9);
	total_vertices = LLVMBuildMul(gallivm->builder, vertices_per_patch,
	                              num_patches, "");

	constant16 = lp_build_const_int32(gallivm, 16);
	if (vertex_index) {
		base_addr = LLVMBuildMul(gallivm->builder, get_rel_patch_id(ctx),
		                         vertices_per_patch, "");

		base_addr = LLVMBuildAdd(gallivm->builder, base_addr,
		                         vertex_index, "");

		param_stride = total_vertices;
	} else {
		base_addr = get_rel_patch_id(ctx);
		param_stride = num_patches;
	}

	base_addr = LLVMBuildAdd(gallivm->builder, base_addr,
	                         LLVMBuildMul(gallivm->builder, param_index,
	                                      param_stride, ""), "");

	base_addr = LLVMBuildMul(gallivm->builder, base_addr, constant16, "");

	if (!vertex_index) {
		LLVMValueRef patch_data_offset =
		           unpack_param(ctx, SI_PARAM_TCS_OFFCHIP_LAYOUT, 16, 16);

		base_addr = LLVMBuildAdd(gallivm->builder, base_addr,
		                         patch_data_offset, "");
	}
	return base_addr;
}

static LLVMValueRef get_tcs_tes_buffer_address_from_reg(
                                       struct si_shader_context *ctx,
                                       const struct tgsi_full_dst_register *dst,
                                       const struct tgsi_full_src_register *src)
{
	struct gallivm_state *gallivm = ctx->soa.bld_base.base.gallivm;
	struct tgsi_shader_info *info = &ctx->shader->selector->info;
	ubyte *name, *index, *array_first;
	struct tgsi_full_src_register reg;
	LLVMValueRef vertex_index = NULL;
	LLVMValueRef param_index = NULL;
	unsigned param_index_base, param_base;

	reg = src ? *src : tgsi_full_src_register_from_dst(dst);

	if (reg.Register.Dimension) {

		if (reg.Dimension.Indirect)
			vertex_index = get_indirect_index(ctx, &reg.DimIndirect,
			                                  reg.Dimension.Index);
		else
			vertex_index = lp_build_const_int32(gallivm,
			                                    reg.Dimension.Index);
	}

	/* Get information about the register. */
	if (reg.Register.File == TGSI_FILE_INPUT) {
		name = info->input_semantic_name;
		index = info->input_semantic_index;
		array_first = info->input_array_first;
	} else if (reg.Register.File == TGSI_FILE_OUTPUT) {
		name = info->output_semantic_name;
		index = info->output_semantic_index;
		array_first = info->output_array_first;
	} else {
		assert(0);
		return NULL;
	}

	if (reg.Register.Indirect) {
		if (reg.Indirect.ArrayID)
			param_base = array_first[reg.Indirect.ArrayID];
		else
			param_base = reg.Register.Index;

		param_index = get_indirect_index(ctx, &reg.Indirect,
		                                 reg.Register.Index - param_base);

	} else {
		param_base = reg.Register.Index;
		param_index = lp_build_const_int32(gallivm, 0);
	}

	param_index_base = si_shader_io_get_unique_index(name[param_base],
	                                                 index[param_base]);

	param_index = LLVMBuildAdd(gallivm->builder, param_index,
	                           lp_build_const_int32(gallivm, param_index_base),
	                           "");

	return get_tcs_tes_buffer_address(ctx, vertex_index, param_index);
}

/* TBUFFER_STORE_FORMAT_{X,XY,XYZ,XYZW} <- the suffix is selected by num_channels=1..4.
 * The type of vdata must be one of i32 (num_channels=1), v2i32 (num_channels=2),
 * or v4i32 (num_channels=3,4). */
static void build_tbuffer_store(struct si_shader_context *ctx,
				LLVMValueRef rsrc,
				LLVMValueRef vdata,
				unsigned num_channels,
				LLVMValueRef vaddr,
				LLVMValueRef soffset,
				unsigned inst_offset,
				unsigned dfmt,
				unsigned nfmt,
				unsigned offen,
				unsigned idxen,
				unsigned glc,
				unsigned slc,
				unsigned tfe)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef args[] = {
		rsrc,
		vdata,
		LLVMConstInt(ctx->i32, num_channels, 0),
		vaddr,
		soffset,
		LLVMConstInt(ctx->i32, inst_offset, 0),
		LLVMConstInt(ctx->i32, dfmt, 0),
		LLVMConstInt(ctx->i32, nfmt, 0),
		LLVMConstInt(ctx->i32, offen, 0),
		LLVMConstInt(ctx->i32, idxen, 0),
		LLVMConstInt(ctx->i32, glc, 0),
		LLVMConstInt(ctx->i32, slc, 0),
		LLVMConstInt(ctx->i32, tfe, 0)
	};

	/* The instruction offset field has 12 bits */
	assert(offen || inst_offset < (1 << 12));

	/* The intrinsic is overloaded, we need to add a type suffix for overloading to work. */
	unsigned func = CLAMP(num_channels, 1, 3) - 1;
	const char *types[] = {"i32", "v2i32", "v4i32"};
	char name[256];
	snprintf(name, sizeof(name), "llvm.SI.tbuffer.store.%s", types[func]);

	lp_build_intrinsic(gallivm->builder, name, ctx->voidt,
			   args, ARRAY_SIZE(args), 0);
}

static void build_tbuffer_store_dwords(struct si_shader_context *ctx,
				     LLVMValueRef rsrc,
				     LLVMValueRef vdata,
				     unsigned num_channels,
				     LLVMValueRef vaddr,
				     LLVMValueRef soffset,
				     unsigned inst_offset)
{
	static unsigned dfmt[] = {
		V_008F0C_BUF_DATA_FORMAT_32,
		V_008F0C_BUF_DATA_FORMAT_32_32,
		V_008F0C_BUF_DATA_FORMAT_32_32_32,
		V_008F0C_BUF_DATA_FORMAT_32_32_32_32
	};
	assert(num_channels >= 1 && num_channels <= 4);

	build_tbuffer_store(ctx, rsrc, vdata, num_channels, vaddr, soffset,
			    inst_offset, dfmt[num_channels-1],
			    V_008F0C_BUF_NUM_FORMAT_UINT, 1, 0, 1, 1, 0);
}

static LLVMValueRef build_buffer_load(struct si_shader_context *ctx,
                                      LLVMValueRef rsrc,
                                      int num_channels,
                                      LLVMValueRef vindex,
                                      LLVMValueRef voffset,
                                      LLVMValueRef soffset,
                                      unsigned inst_offset,
                                      unsigned glc,
                                      unsigned slc)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	unsigned func = CLAMP(num_channels, 1, 3) - 1;

	if (HAVE_LLVM >= 0x309) {
		LLVMValueRef args[] = {
			LLVMBuildBitCast(gallivm->builder, rsrc, ctx->v4i32, ""),
			vindex ? vindex : LLVMConstInt(ctx->i32, 0, 0),
			LLVMConstInt(ctx->i32, inst_offset, 0),
			LLVMConstInt(ctx->i1, glc, 0),
			LLVMConstInt(ctx->i1, slc, 0)
		};

		LLVMTypeRef types[] = {ctx->f32, LLVMVectorType(ctx->f32, 2),
		                       ctx->v4f32};
		const char *type_names[] = {"f32", "v2f32", "v4f32"};
		char name[256];

		if (voffset) {
			args[2] = LLVMBuildAdd(gallivm->builder, args[2], voffset,
			                       "");
		}

		if (soffset) {
			args[2] = LLVMBuildAdd(gallivm->builder, args[2], soffset,
			                       "");
		}

		snprintf(name, sizeof(name), "llvm.amdgcn.buffer.load.%s",
		         type_names[func]);

		return lp_build_intrinsic(gallivm->builder, name, types[func], args,
		                          ARRAY_SIZE(args), LLVMReadOnlyAttribute);
	} else {
		LLVMValueRef args[] = {
			LLVMBuildBitCast(gallivm->builder, rsrc, ctx->v16i8, ""),
			voffset ? voffset : vindex,
			soffset,
			LLVMConstInt(ctx->i32, inst_offset, 0),
			LLVMConstInt(ctx->i32, voffset ? 1 : 0, 0), // offen
			LLVMConstInt(ctx->i32, vindex ? 1 : 0, 0), //idxen
			LLVMConstInt(ctx->i32, glc, 0),
			LLVMConstInt(ctx->i32, slc, 0),
			LLVMConstInt(ctx->i32, 0, 0), // TFE
		};

		LLVMTypeRef types[] = {ctx->i32, LLVMVectorType(ctx->i32, 2),
		                       ctx->v4i32};
		const char *type_names[] = {"i32", "v2i32", "v4i32"};
		const char *arg_type = "i32";
		char name[256];

		if (voffset && vindex) {
			LLVMValueRef vaddr[] = {vindex, voffset};

			arg_type = "v2i32";
			args[1] = lp_build_gather_values(gallivm, vaddr, 2);
		}

		snprintf(name, sizeof(name), "llvm.SI.buffer.load.dword.%s.%s",
		         type_names[func], arg_type);

		return lp_build_intrinsic(gallivm->builder, name, types[func], args,
		                          ARRAY_SIZE(args), LLVMReadOnlyAttribute);
	}
}

static LLVMValueRef buffer_load(struct lp_build_tgsi_context *bld_base,
                                enum tgsi_opcode_type type, unsigned swizzle,
                                LLVMValueRef buffer, LLVMValueRef offset,
                                LLVMValueRef base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef value, value2;
	LLVMTypeRef llvm_type = tgsi2llvmtype(bld_base, type);
	LLVMTypeRef vec_type = LLVMVectorType(llvm_type, 4);

	if (swizzle == ~0) {
		value = build_buffer_load(ctx, buffer, 4, NULL, base, offset,
		                          0, 1, 0);

		return LLVMBuildBitCast(gallivm->builder, value, vec_type, "");
	}

	if (!tgsi_type_is_64bit(type)) {
		value = build_buffer_load(ctx, buffer, 4, NULL, base, offset,
		                          0, 1, 0);

		value = LLVMBuildBitCast(gallivm->builder, value, vec_type, "");
		return LLVMBuildExtractElement(gallivm->builder, value,
		                    lp_build_const_int32(gallivm, swizzle), "");
	}

	value = build_buffer_load(ctx, buffer, 1, NULL, base, offset,
	                          swizzle * 4, 1, 0);

	value2 = build_buffer_load(ctx, buffer, 1, NULL, base, offset,
	                           swizzle * 4 + 4, 1, 0);

	return si_llvm_emit_fetch_64bit(bld_base, type, value, value2);
}

/**
 * Load from LDS.
 *
 * \param type		output value type
 * \param swizzle	offset (typically 0..3); it can be ~0, which loads a vec4
 * \param dw_addr	address in dwords
 */
static LLVMValueRef lds_load(struct lp_build_tgsi_context *bld_base,
			     enum tgsi_opcode_type type, unsigned swizzle,
			     LLVMValueRef dw_addr)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef value;

	if (swizzle == ~0) {
		LLVMValueRef values[TGSI_NUM_CHANNELS];

		for (unsigned chan = 0; chan < TGSI_NUM_CHANNELS; chan++)
			values[chan] = lds_load(bld_base, type, chan, dw_addr);

		return lp_build_gather_values(bld_base->base.gallivm, values,
					      TGSI_NUM_CHANNELS);
	}

	dw_addr = lp_build_add(&bld_base->uint_bld, dw_addr,
			    lp_build_const_int32(gallivm, swizzle));

	value = build_indexed_load(ctx, ctx->lds, dw_addr, false);
	if (tgsi_type_is_64bit(type)) {
		LLVMValueRef value2;
		dw_addr = lp_build_add(&bld_base->uint_bld, dw_addr,
				       lp_build_const_int32(gallivm, 1));
		value2 = build_indexed_load(ctx, ctx->lds, dw_addr, false);
		return si_llvm_emit_fetch_64bit(bld_base, type, value, value2);
	}

	return LLVMBuildBitCast(gallivm->builder, value,
				tgsi2llvmtype(bld_base, type), "");
}

/**
 * Store to LDS.
 *
 * \param swizzle	offset (typically 0..3)
 * \param dw_addr	address in dwords
 * \param value		value to store
 */
static void lds_store(struct lp_build_tgsi_context *bld_base,
		      unsigned swizzle, LLVMValueRef dw_addr,
		      LLVMValueRef value)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;

	dw_addr = lp_build_add(&bld_base->uint_bld, dw_addr,
			    lp_build_const_int32(gallivm, swizzle));

	value = LLVMBuildBitCast(gallivm->builder, value, ctx->i32, "");
	build_indexed_store(ctx, ctx->lds,
			    dw_addr, value);
}

static LLVMValueRef fetch_input_tcs(
	struct lp_build_tgsi_context *bld_base,
	const struct tgsi_full_src_register *reg,
	enum tgsi_opcode_type type, unsigned swizzle)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	LLVMValueRef dw_addr, stride;

	stride = unpack_param(ctx, SI_PARAM_TCS_IN_LAYOUT, 13, 8);
	dw_addr = get_tcs_in_current_patch_offset(ctx);
	dw_addr = get_dw_address(ctx, NULL, reg, stride, dw_addr);

	return lds_load(bld_base, type, swizzle, dw_addr);
}

static LLVMValueRef fetch_output_tcs(
		struct lp_build_tgsi_context *bld_base,
		const struct tgsi_full_src_register *reg,
		enum tgsi_opcode_type type, unsigned swizzle)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	LLVMValueRef dw_addr, stride;

	if (reg->Register.Dimension) {
		stride = unpack_param(ctx, SI_PARAM_TCS_OUT_LAYOUT, 13, 8);
		dw_addr = get_tcs_out_current_patch_offset(ctx);
		dw_addr = get_dw_address(ctx, NULL, reg, stride, dw_addr);
	} else {
		dw_addr = get_tcs_out_current_patch_data_offset(ctx);
		dw_addr = get_dw_address(ctx, NULL, reg, NULL, dw_addr);
	}

	return lds_load(bld_base, type, swizzle, dw_addr);
}

static LLVMValueRef fetch_input_tes(
	struct lp_build_tgsi_context *bld_base,
	const struct tgsi_full_src_register *reg,
	enum tgsi_opcode_type type, unsigned swizzle)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef rw_buffers, buffer, base, addr;

	rw_buffers = LLVMGetParam(ctx->main_fn,
				  SI_PARAM_RW_BUFFERS);
	buffer = build_indexed_load_const(ctx, rw_buffers,
			lp_build_const_int32(gallivm, SI_HS_RING_TESS_OFFCHIP));

	base = LLVMGetParam(ctx->main_fn, ctx->param_oc_lds);
	addr = get_tcs_tes_buffer_address_from_reg(ctx, NULL, reg);

	return buffer_load(bld_base, type, swizzle, buffer, base, addr);
}

static void store_output_tcs(struct lp_build_tgsi_context *bld_base,
			     const struct tgsi_full_instruction *inst,
			     const struct tgsi_opcode_info *info,
			     LLVMValueRef dst[4])
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	const struct tgsi_full_dst_register *reg = &inst->Dst[0];
	unsigned chan_index;
	LLVMValueRef dw_addr, stride;
	LLVMValueRef rw_buffers, buffer, base, buf_addr;
	LLVMValueRef values[4];

	/* Only handle per-patch and per-vertex outputs here.
	 * Vectors will be lowered to scalars and this function will be called again.
	 */
	if (reg->Register.File != TGSI_FILE_OUTPUT ||
	    (dst[0] && LLVMGetTypeKind(LLVMTypeOf(dst[0])) == LLVMVectorTypeKind)) {
		si_llvm_emit_store(bld_base, inst, info, dst);
		return;
	}

	if (reg->Register.Dimension) {
		stride = unpack_param(ctx, SI_PARAM_TCS_OUT_LAYOUT, 13, 8);
		dw_addr = get_tcs_out_current_patch_offset(ctx);
		dw_addr = get_dw_address(ctx, reg, NULL, stride, dw_addr);
	} else {
		dw_addr = get_tcs_out_current_patch_data_offset(ctx);
		dw_addr = get_dw_address(ctx, reg, NULL, NULL, dw_addr);
	}

	rw_buffers = LLVMGetParam(ctx->main_fn,
				  SI_PARAM_RW_BUFFERS);
	buffer = build_indexed_load_const(ctx, rw_buffers,
			lp_build_const_int32(gallivm, SI_HS_RING_TESS_OFFCHIP));

	base = LLVMGetParam(ctx->main_fn, ctx->param_oc_lds);
	buf_addr = get_tcs_tes_buffer_address_from_reg(ctx, reg, NULL);


	TGSI_FOR_EACH_DST0_ENABLED_CHANNEL(inst, chan_index) {
		LLVMValueRef value = dst[chan_index];

		if (inst->Instruction.Saturate)
			value = si_llvm_saturate(bld_base, value);

		lds_store(bld_base, chan_index, dw_addr, value);

		value = LLVMBuildBitCast(gallivm->builder, value, ctx->i32, "");
		values[chan_index] = value;

		if (inst->Dst[0].Register.WriteMask != 0xF) {
			build_tbuffer_store_dwords(ctx, buffer, value, 1,
			                           buf_addr, base,
			                           4 * chan_index);
		}
	}

	if (inst->Dst[0].Register.WriteMask == 0xF) {
		LLVMValueRef value = lp_build_gather_values(bld_base->base.gallivm,
		                                            values, 4);
		build_tbuffer_store_dwords(ctx, buffer, value, 4, buf_addr,
		                           base, 0);
	}
}

static LLVMValueRef fetch_input_gs(
	struct lp_build_tgsi_context *bld_base,
	const struct tgsi_full_src_register *reg,
	enum tgsi_opcode_type type,
	unsigned swizzle)
{
	struct lp_build_context *base = &bld_base->base;
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct si_shader *shader = ctx->shader;
	struct lp_build_context *uint =	&ctx->soa.bld_base.uint_bld;
	struct gallivm_state *gallivm = base->gallivm;
	LLVMValueRef vtx_offset;
	LLVMValueRef args[9];
	unsigned vtx_offset_param;
	struct tgsi_shader_info *info = &shader->selector->info;
	unsigned semantic_name = info->input_semantic_name[reg->Register.Index];
	unsigned semantic_index = info->input_semantic_index[reg->Register.Index];
	unsigned param;
	LLVMValueRef value;

	if (swizzle != ~0 && semantic_name == TGSI_SEMANTIC_PRIMID)
		return get_primitive_id(bld_base, swizzle);

	if (!reg->Register.Dimension)
		return NULL;

	if (swizzle == ~0) {
		LLVMValueRef values[TGSI_NUM_CHANNELS];
		unsigned chan;
		for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
			values[chan] = fetch_input_gs(bld_base, reg, type, chan);
		}
		return lp_build_gather_values(bld_base->base.gallivm, values,
					      TGSI_NUM_CHANNELS);
	}

	/* Get the vertex offset parameter */
	vtx_offset_param = reg->Dimension.Index;
	if (vtx_offset_param < 2) {
		vtx_offset_param += SI_PARAM_VTX0_OFFSET;
	} else {
		assert(vtx_offset_param < 6);
		vtx_offset_param += SI_PARAM_VTX2_OFFSET - 2;
	}
	vtx_offset = lp_build_mul_imm(uint,
				      LLVMGetParam(ctx->main_fn,
						   vtx_offset_param),
				      4);

	param = si_shader_io_get_unique_index(semantic_name, semantic_index);
	args[0] = ctx->esgs_ring;
	args[1] = vtx_offset;
	args[2] = lp_build_const_int32(gallivm, (param * 4 + swizzle) * 256);
	args[3] = uint->zero;
	args[4] = uint->one;  /* OFFEN */
	args[5] = uint->zero; /* IDXEN */
	args[6] = uint->one;  /* GLC */
	args[7] = uint->zero; /* SLC */
	args[8] = uint->zero; /* TFE */

	value = lp_build_intrinsic(gallivm->builder,
				   "llvm.SI.buffer.load.dword.i32.i32",
				   ctx->i32, args, 9,
				   LLVMReadOnlyAttribute);
	if (tgsi_type_is_64bit(type)) {
		LLVMValueRef value2;
		args[2] = lp_build_const_int32(gallivm, (param * 4 + swizzle + 1) * 256);
		value2 = lp_build_intrinsic(gallivm->builder,
					    "llvm.SI.buffer.load.dword.i32.i32",
					    ctx->i32, args, 9,
					    LLVMReadOnlyAttribute);
		return si_llvm_emit_fetch_64bit(bld_base, type,
						value, value2);
	}
	return LLVMBuildBitCast(gallivm->builder,
				value,
				tgsi2llvmtype(bld_base, type), "");
}

static int lookup_interp_param_index(unsigned interpolate, unsigned location)
{
	switch (interpolate) {
	case TGSI_INTERPOLATE_CONSTANT:
		return 0;

	case TGSI_INTERPOLATE_LINEAR:
		if (location == TGSI_INTERPOLATE_LOC_SAMPLE)
			return SI_PARAM_LINEAR_SAMPLE;
		else if (location == TGSI_INTERPOLATE_LOC_CENTROID)
			return SI_PARAM_LINEAR_CENTROID;
		else
			return SI_PARAM_LINEAR_CENTER;
		break;
	case TGSI_INTERPOLATE_COLOR:
	case TGSI_INTERPOLATE_PERSPECTIVE:
		if (location == TGSI_INTERPOLATE_LOC_SAMPLE)
			return SI_PARAM_PERSP_SAMPLE;
		else if (location == TGSI_INTERPOLATE_LOC_CENTROID)
			return SI_PARAM_PERSP_CENTROID;
		else
			return SI_PARAM_PERSP_CENTER;
		break;
	default:
		fprintf(stderr, "Warning: Unhandled interpolation mode.\n");
		return -1;
	}
}

/* This shouldn't be used by explicit INTERP opcodes. */
static unsigned select_interp_param(struct si_shader_context *ctx,
				    unsigned param)
{
	if (!ctx->is_monolithic)
		return param;

	if (ctx->shader->key.ps.prolog.force_persp_sample_interp) {
		switch (param) {
		case SI_PARAM_PERSP_CENTROID:
		case SI_PARAM_PERSP_CENTER:
			return SI_PARAM_PERSP_SAMPLE;
		}
	}
	if (ctx->shader->key.ps.prolog.force_linear_sample_interp) {
		switch (param) {
		case SI_PARAM_LINEAR_CENTROID:
		case SI_PARAM_LINEAR_CENTER:
			return SI_PARAM_LINEAR_SAMPLE;
		}
	}
	if (ctx->shader->key.ps.prolog.force_persp_center_interp) {
		switch (param) {
		case SI_PARAM_PERSP_CENTROID:
		case SI_PARAM_PERSP_SAMPLE:
			return SI_PARAM_PERSP_CENTER;
		}
	}
	if (ctx->shader->key.ps.prolog.force_linear_center_interp) {
		switch (param) {
		case SI_PARAM_LINEAR_CENTROID:
		case SI_PARAM_LINEAR_SAMPLE:
			return SI_PARAM_LINEAR_CENTER;
		}
	}

	return param;
}

/**
 * Interpolate a fragment shader input.
 *
 * @@param ctx		context
 * @@param input_index		index of the input in hardware
 * @@param semantic_name		TGSI_SEMANTIC_*
 * @@param semantic_index	semantic index
 * @@param num_interp_inputs	number of all interpolated inputs (= BCOLOR offset)
 * @@param colors_read_mask	color components read (4 bits for each color, 8 bits in total)
 * @@param interp_param		interpolation weights (i,j)
 * @@param prim_mask		SI_PARAM_PRIM_MASK
 * @@param face			SI_PARAM_FRONT_FACE
 * @@param result		the return value (4 components)
 */
static void interp_fs_input(struct si_shader_context *ctx,
			    unsigned input_index,
			    unsigned semantic_name,
			    unsigned semantic_index,
			    unsigned num_interp_inputs,
			    unsigned colors_read_mask,
			    LLVMValueRef interp_param,
			    LLVMValueRef prim_mask,
			    LLVMValueRef face,
			    LLVMValueRef result[4])
{
	struct lp_build_context *base = &ctx->soa.bld_base.base;
	struct lp_build_context *uint =	&ctx->soa.bld_base.uint_bld;
	struct gallivm_state *gallivm = base->gallivm;
	const char *intr_name;
	LLVMValueRef attr_number;

	unsigned chan;

	attr_number = lp_build_const_int32(gallivm, input_index);

	/* fs.constant returns the param from the middle vertex, so it's not
	 * really useful for flat shading. It's meant to be used for custom
	 * interpolation (but the intrinsic can't fetch from the other two
	 * vertices).
	 *
	 * Luckily, it doesn't matter, because we rely on the FLAT_SHADE state
	 * to do the right thing. The only reason we use fs.constant is that
	 * fs.interp cannot be used on integers, because they can be equal
	 * to NaN.
	 */
	intr_name = interp_param ? "llvm.SI.fs.interp" : "llvm.SI.fs.constant";

	if (semantic_name == TGSI_SEMANTIC_COLOR &&
	    ctx->shader->key.ps.prolog.color_two_side) {
		LLVMValueRef args[4];
		LLVMValueRef is_face_positive;
		LLVMValueRef back_attr_number;

		/* If BCOLOR0 is used, BCOLOR1 is at offset "num_inputs + 1",
		 * otherwise it's at offset "num_inputs".
		 */
		unsigned back_attr_offset = num_interp_inputs;
		if (semantic_index == 1 && colors_read_mask & 0xf)
			back_attr_offset += 1;

		back_attr_number = lp_build_const_int32(gallivm, back_attr_offset);

		is_face_positive = LLVMBuildICmp(gallivm->builder, LLVMIntNE,
						 face, uint->zero, "");

		args[2] = prim_mask;
		args[3] = interp_param;
		for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
			LLVMValueRef llvm_chan = lp_build_const_int32(gallivm, chan);
			LLVMValueRef front, back;

			args[0] = llvm_chan;
			args[1] = attr_number;
			front = lp_build_intrinsic(gallivm->builder, intr_name,
						ctx->f32, args, args[3] ? 4 : 3,
						LLVMReadNoneAttribute);

			args[1] = back_attr_number;
			back = lp_build_intrinsic(gallivm->builder, intr_name,
					       ctx->f32, args, args[3] ? 4 : 3,
					       LLVMReadNoneAttribute);

			result[chan] = LLVMBuildSelect(gallivm->builder,
						is_face_positive,
						front,
						back,
						"");
		}
	} else if (semantic_name == TGSI_SEMANTIC_FOG) {
		LLVMValueRef args[4];

		args[0] = uint->zero;
		args[1] = attr_number;
		args[2] = prim_mask;
		args[3] = interp_param;
		result[0] = lp_build_intrinsic(gallivm->builder, intr_name,
					ctx->f32, args, args[3] ? 4 : 3,
					LLVMReadNoneAttribute);
		result[1] =
		result[2] = lp_build_const_float(gallivm, 0.0f);
		result[3] = lp_build_const_float(gallivm, 1.0f);
	} else {
		for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
			LLVMValueRef args[4];
			LLVMValueRef llvm_chan = lp_build_const_int32(gallivm, chan);

			args[0] = llvm_chan;
			args[1] = attr_number;
			args[2] = prim_mask;
			args[3] = interp_param;
			result[chan] = lp_build_intrinsic(gallivm->builder, intr_name,
						ctx->f32, args, args[3] ? 4 : 3,
						LLVMReadNoneAttribute);
		}
	}
}

/* LLVMGetParam with bc_optimize resolved. */
static LLVMValueRef get_interp_param(struct si_shader_context *ctx,
				     int interp_param_idx)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMValueRef main_fn = ctx->main_fn;
	LLVMValueRef param = NULL;

	/* Handle PRIM_MASK[31] (bc_optimize). */
	if (ctx->is_monolithic &&
	    ((ctx->shader->key.ps.prolog.bc_optimize_for_persp &&
	      interp_param_idx == SI_PARAM_PERSP_CENTROID) ||
	     (ctx->shader->key.ps.prolog.bc_optimize_for_linear &&
	      interp_param_idx == SI_PARAM_LINEAR_CENTROID))) {
		/* The shader should do: if (PRIM_MASK[31]) CENTROID = CENTER;
		 * The hw doesn't compute CENTROID if the whole wave only
		 * contains fully-covered quads.
		 */
		LLVMValueRef bc_optimize =
			LLVMGetParam(main_fn, SI_PARAM_PRIM_MASK);
		bc_optimize = LLVMBuildLShr(builder,
					    bc_optimize,
					    LLVMConstInt(ctx->i32, 31, 0), "");
		bc_optimize = LLVMBuildTrunc(builder, bc_optimize, ctx->i1, "");

		if (ctx->shader->key.ps.prolog.bc_optimize_for_persp &&
		    interp_param_idx == SI_PARAM_PERSP_CENTROID) {
			param = LLVMBuildSelect(builder, bc_optimize,
						LLVMGetParam(main_fn,
							     SI_PARAM_PERSP_CENTER),
						LLVMGetParam(main_fn,
							     SI_PARAM_PERSP_CENTROID),
						"");
		}
		if (ctx->shader->key.ps.prolog.bc_optimize_for_linear &&
		    interp_param_idx == SI_PARAM_LINEAR_CENTROID) {
			param = LLVMBuildSelect(builder, bc_optimize,
						LLVMGetParam(main_fn,
							     SI_PARAM_LINEAR_CENTER),
						LLVMGetParam(main_fn,
							     SI_PARAM_LINEAR_CENTROID),
						"");
		}
	}

	if (!param)
		param = LLVMGetParam(main_fn, interp_param_idx);
	return param;
}

static void declare_input_fs(
	struct si_shader_context *radeon_bld,
	unsigned input_index,
	const struct tgsi_full_declaration *decl,
	LLVMValueRef out[4])
{
	struct lp_build_context *base = &radeon_bld->soa.bld_base.base;
	struct si_shader_context *ctx =
		si_shader_context(&radeon_bld->soa.bld_base);
	struct si_shader *shader = ctx->shader;
	LLVMValueRef main_fn = radeon_bld->main_fn;
	LLVMValueRef interp_param = NULL;
	int interp_param_idx;

	/* Get colors from input VGPRs (set by the prolog). */
	if (!ctx->is_monolithic &&
	    decl->Semantic.Name == TGSI_SEMANTIC_COLOR) {
		unsigned i = decl->Semantic.Index;
		unsigned colors_read = shader->selector->info.colors_read;
		unsigned mask = colors_read >> (i * 4);
		unsigned offset = SI_PARAM_POS_FIXED_PT + 1 +
				  (i ? util_bitcount(colors_read & 0xf) : 0);

		out[0] = mask & 0x1 ? LLVMGetParam(main_fn, offset++) : base->undef;
		out[1] = mask & 0x2 ? LLVMGetParam(main_fn, offset++) : base->undef;
		out[2] = mask & 0x4 ? LLVMGetParam(main_fn, offset++) : base->undef;
		out[3] = mask & 0x8 ? LLVMGetParam(main_fn, offset++) : base->undef;
		return;
	}

	interp_param_idx = lookup_interp_param_index(decl->Interp.Interpolate,
						     decl->Interp.Location);
	if (interp_param_idx == -1)
		return;
	else if (interp_param_idx) {
		interp_param_idx = select_interp_param(ctx,
						       interp_param_idx);
		interp_param = get_interp_param(ctx, interp_param_idx);
	}

	if (decl->Semantic.Name == TGSI_SEMANTIC_COLOR &&
	    decl->Interp.Interpolate == TGSI_INTERPOLATE_COLOR &&
	    ctx->shader->key.ps.prolog.flatshade_colors)
		interp_param = NULL; /* load the constant color */

	interp_fs_input(ctx, input_index, decl->Semantic.Name,
			decl->Semantic.Index, shader->selector->info.num_inputs,
			shader->selector->info.colors_read, interp_param,
			LLVMGetParam(main_fn, SI_PARAM_PRIM_MASK),
			LLVMGetParam(main_fn, SI_PARAM_FRONT_FACE),
			&out[0]);
}

static LLVMValueRef get_sample_id(struct si_shader_context *radeon_bld)
{
	return unpack_param(si_shader_context(&radeon_bld->soa.bld_base),
			    SI_PARAM_ANCILLARY, 8, 4);
}

/**
 * Set range metadata on an instruction.  This can only be used on load and
 * call instructions.  If you know an instruction can only produce the values
 * 0, 1, 2, you would do set_range_metadata(value, 0, 3);
 * \p lo is the minimum value inclusive.
 * \p hi is the maximum value exclusive.
 */
static void set_range_metadata(struct si_shader_context *ctx,
			       LLVMValueRef value, unsigned lo, unsigned hi)
{
	LLVMValueRef range_md, md_args[2];
	LLVMTypeRef type = LLVMTypeOf(value);
	LLVMContextRef context = LLVMGetTypeContext(type);

	md_args[0] = LLVMConstInt(type, lo, false);
	md_args[1] = LLVMConstInt(type, hi, false);
	range_md = LLVMMDNodeInContext(context, md_args, 2);
	LLVMSetMetadata(value, ctx->range_md_kind, range_md);
}

static LLVMValueRef get_thread_id(struct si_shader_context *ctx)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef tid;

	if (HAVE_LLVM < 0x0308) {
		tid = lp_build_intrinsic(gallivm->builder, "llvm.SI.tid",
				ctx->i32,   NULL, 0, LLVMReadNoneAttribute);
	} else {
		LLVMValueRef tid_args[2];
		tid_args[0] = lp_build_const_int32(gallivm, 0xffffffff);
		tid_args[1] = lp_build_const_int32(gallivm, 0);
		tid_args[1] = lp_build_intrinsic(gallivm->builder,
					"llvm.amdgcn.mbcnt.lo", ctx->i32,
					tid_args, 2, LLVMReadNoneAttribute);

		tid = lp_build_intrinsic(gallivm->builder,
					"llvm.amdgcn.mbcnt.hi", ctx->i32,
					tid_args, 2, LLVMReadNoneAttribute);
	}
	set_range_metadata(ctx, tid, 0, 64);
	return tid;
}

/**
 * Load a dword from a constant buffer.
 */
static LLVMValueRef buffer_load_const(struct si_shader_context *ctx,
				      LLVMValueRef resource,
				      LLVMValueRef offset)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMValueRef args[2] = {resource, offset};

	return lp_build_intrinsic(builder, "llvm.SI.load.const", ctx->f32, args, 2,
			       LLVMReadNoneAttribute);
}

static LLVMValueRef load_sample_position(struct si_shader_context *radeon_bld, LLVMValueRef sample_id)
{
	struct si_shader_context *ctx =
		si_shader_context(&radeon_bld->soa.bld_base);
	struct lp_build_context *uint_bld = &radeon_bld->soa.bld_base.uint_bld;
	struct gallivm_state *gallivm = &radeon_bld->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	LLVMValueRef desc = LLVMGetParam(ctx->main_fn, SI_PARAM_RW_BUFFERS);
	LLVMValueRef buf_index = lp_build_const_int32(gallivm, SI_PS_CONST_SAMPLE_POSITIONS);
	LLVMValueRef resource = build_indexed_load_const(ctx, desc, buf_index);

	/* offset = sample_id * 8  (8 = 2 floats containing samplepos.xy) */
	LLVMValueRef offset0 = lp_build_mul_imm(uint_bld, sample_id, 8);
	LLVMValueRef offset1 = LLVMBuildAdd(builder, offset0, lp_build_const_int32(gallivm, 4), "");

	LLVMValueRef pos[4] = {
		buffer_load_const(ctx, resource, offset0),
		buffer_load_const(ctx, resource, offset1),
		lp_build_const_float(gallivm, 0),
		lp_build_const_float(gallivm, 0)
	};

	return lp_build_gather_values(gallivm, pos, 4);
}

static void declare_system_value(
	struct si_shader_context *radeon_bld,
	unsigned index,
	const struct tgsi_full_declaration *decl)
{
	struct si_shader_context *ctx =
		si_shader_context(&radeon_bld->soa.bld_base);
	struct lp_build_context *bld = &radeon_bld->soa.bld_base.base;
	struct gallivm_state *gallivm = &radeon_bld->gallivm;
	LLVMValueRef value = 0;

	switch (decl->Semantic.Name) {
	case TGSI_SEMANTIC_INSTANCEID:
		value = LLVMGetParam(radeon_bld->main_fn,
				     ctx->param_instance_id);
		break;

	case TGSI_SEMANTIC_VERTEXID:
		value = LLVMBuildAdd(gallivm->builder,
				     LLVMGetParam(radeon_bld->main_fn,
						  ctx->param_vertex_id),
				     LLVMGetParam(radeon_bld->main_fn,
						  SI_PARAM_BASE_VERTEX), "");
		break;

	case TGSI_SEMANTIC_VERTEXID_NOBASE:
		value = LLVMGetParam(radeon_bld->main_fn,
				     ctx->param_vertex_id);
		break;

	case TGSI_SEMANTIC_BASEVERTEX:
		value = LLVMGetParam(radeon_bld->main_fn,
				     SI_PARAM_BASE_VERTEX);
		break;

	case TGSI_SEMANTIC_BASEINSTANCE:
		value = LLVMGetParam(radeon_bld->main_fn,
				     SI_PARAM_START_INSTANCE);
		break;

	case TGSI_SEMANTIC_DRAWID:
		value = LLVMGetParam(radeon_bld->main_fn,
				     SI_PARAM_DRAWID);
		break;

	case TGSI_SEMANTIC_INVOCATIONID:
		if (ctx->type == PIPE_SHADER_TESS_CTRL)
			value = unpack_param(ctx, SI_PARAM_REL_IDS, 8, 5);
		else if (ctx->type == PIPE_SHADER_GEOMETRY)
			value = LLVMGetParam(radeon_bld->main_fn,
					     SI_PARAM_GS_INSTANCE_ID);
		else
			assert(!"INVOCATIONID not implemented");
		break;

	case TGSI_SEMANTIC_POSITION:
	{
		LLVMValueRef pos[4] = {
			LLVMGetParam(radeon_bld->main_fn, SI_PARAM_POS_X_FLOAT),
			LLVMGetParam(radeon_bld->main_fn, SI_PARAM_POS_Y_FLOAT),
			LLVMGetParam(radeon_bld->main_fn, SI_PARAM_POS_Z_FLOAT),
			lp_build_emit_llvm_unary(&radeon_bld->soa.bld_base, TGSI_OPCODE_RCP,
						 LLVMGetParam(radeon_bld->main_fn,
							      SI_PARAM_POS_W_FLOAT)),
		};
		value = lp_build_gather_values(gallivm, pos, 4);
		break;
	}

	case TGSI_SEMANTIC_FACE:
		value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_FRONT_FACE);
		break;

	case TGSI_SEMANTIC_SAMPLEID:
		value = get_sample_id(radeon_bld);
		break;

	case TGSI_SEMANTIC_SAMPLEPOS: {
		LLVMValueRef pos[4] = {
			LLVMGetParam(radeon_bld->main_fn, SI_PARAM_POS_X_FLOAT),
			LLVMGetParam(radeon_bld->main_fn, SI_PARAM_POS_Y_FLOAT),
			lp_build_const_float(gallivm, 0),
			lp_build_const_float(gallivm, 0)
		};
		pos[0] = lp_build_emit_llvm_unary(&radeon_bld->soa.bld_base,
						  TGSI_OPCODE_FRC, pos[0]);
		pos[1] = lp_build_emit_llvm_unary(&radeon_bld->soa.bld_base,
						  TGSI_OPCODE_FRC, pos[1]);
		value = lp_build_gather_values(gallivm, pos, 4);
		break;
	}

	case TGSI_SEMANTIC_SAMPLEMASK:
		/* This can only occur with the OpenGL Core profile, which
		 * doesn't support smoothing.
		 */
		value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_SAMPLE_COVERAGE);
		break;

	case TGSI_SEMANTIC_TESSCOORD:
	{
		LLVMValueRef coord[4] = {
			LLVMGetParam(radeon_bld->main_fn, ctx->param_tes_u),
			LLVMGetParam(radeon_bld->main_fn, ctx->param_tes_v),
			bld->zero,
			bld->zero
		};

		/* For triangles, the vector should be (u, v, 1-u-v). */
		if (ctx->shader->selector->info.properties[TGSI_PROPERTY_TES_PRIM_MODE] ==
		    PIPE_PRIM_TRIANGLES)
			coord[2] = lp_build_sub(bld, bld->one,
						lp_build_add(bld, coord[0], coord[1]));

		value = lp_build_gather_values(gallivm, coord, 4);
		break;
	}

	case TGSI_SEMANTIC_VERTICESIN:
		if (ctx->type == PIPE_SHADER_TESS_CTRL)
			value = unpack_param(ctx, SI_PARAM_TCS_OUT_LAYOUT, 26, 6);
		else if (ctx->type == PIPE_SHADER_TESS_EVAL)
			value = unpack_param(ctx, SI_PARAM_TCS_OFFCHIP_LAYOUT, 9, 7);
		else
			assert(!"invalid shader stage for TGSI_SEMANTIC_VERTICESIN");
		break;

	case TGSI_SEMANTIC_TESSINNER:
	case TGSI_SEMANTIC_TESSOUTER:
	{
		LLVMValueRef rw_buffers, buffer, base, addr;
		int param = si_shader_io_get_unique_index(decl->Semantic.Name, 0);

		rw_buffers = LLVMGetParam(ctx->main_fn,
					SI_PARAM_RW_BUFFERS);
		buffer = build_indexed_load_const(ctx, rw_buffers,
		        lp_build_const_int32(gallivm, SI_HS_RING_TESS_OFFCHIP));

		base = LLVMGetParam(ctx->main_fn, ctx->param_oc_lds);
		addr = get_tcs_tes_buffer_address(ctx, NULL,
		                          lp_build_const_int32(gallivm, param));

		value = buffer_load(&radeon_bld->soa.bld_base, TGSI_TYPE_FLOAT,
		                    ~0, buffer, base, addr);

		break;
	}

	case TGSI_SEMANTIC_DEFAULT_TESSOUTER_SI:
	case TGSI_SEMANTIC_DEFAULT_TESSINNER_SI:
	{
		LLVMValueRef buf, slot, val[4];
		int i, offset;

		slot = lp_build_const_int32(gallivm, SI_HS_CONST_DEFAULT_TESS_LEVELS);
		buf = LLVMGetParam(ctx->main_fn, SI_PARAM_RW_BUFFERS);
		buf = build_indexed_load_const(ctx, buf, slot);
		offset = decl->Semantic.Name == TGSI_SEMANTIC_DEFAULT_TESSINNER_SI ? 4 : 0;

		for (i = 0; i < 4; i++)
			val[i] = buffer_load_const(ctx, buf,
						   lp_build_const_int32(gallivm, (offset + i) * 4));
		value = lp_build_gather_values(gallivm, val, 4);
		break;
	}

	case TGSI_SEMANTIC_PRIMID:
		value = get_primitive_id(&radeon_bld->soa.bld_base, 0);
		break;

	case TGSI_SEMANTIC_GRID_SIZE:
		value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_GRID_SIZE);
		break;

	case TGSI_SEMANTIC_BLOCK_SIZE:
	{
		LLVMValueRef values[3];
		unsigned i;
		unsigned *properties = ctx->shader->selector->info.properties;

		if (properties[TGSI_PROPERTY_CS_FIXED_BLOCK_WIDTH] != 0) {
			unsigned sizes[3] = {
				properties[TGSI_PROPERTY_CS_FIXED_BLOCK_WIDTH],
				properties[TGSI_PROPERTY_CS_FIXED_BLOCK_HEIGHT],
				properties[TGSI_PROPERTY_CS_FIXED_BLOCK_DEPTH]
			};

			for (i = 0; i < 3; ++i)
				values[i] = lp_build_const_int32(gallivm, sizes[i]);

			value = lp_build_gather_values(gallivm, values, 3);
		} else {
			value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_BLOCK_SIZE);
		}
		break;
	}

	case TGSI_SEMANTIC_BLOCK_ID:
		value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_BLOCK_ID);
		break;

	case TGSI_SEMANTIC_THREAD_ID:
		value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_THREAD_ID);
		break;

#if HAVE_LLVM >= 0x0309
	case TGSI_SEMANTIC_HELPER_INVOCATION:
		value = lp_build_intrinsic(gallivm->builder,
					   "llvm.amdgcn.ps.live",
					   ctx->i1, NULL, 0,
					   LLVMReadNoneAttribute);
		value = LLVMBuildNot(gallivm->builder, value, "");
		value = LLVMBuildSExt(gallivm->builder, value, ctx->i32, "");
		break;
#endif

	default:
		assert(!"unknown system value");
		return;
	}

	radeon_bld->system_values[index] = value;
}

static void declare_compute_memory(struct si_shader_context *radeon_bld,
                                   const struct tgsi_full_declaration *decl)
{
	struct si_shader_context *ctx =
		si_shader_context(&radeon_bld->soa.bld_base);
	struct si_shader_selector *sel = ctx->shader->selector;
	struct gallivm_state *gallivm = &radeon_bld->gallivm;

	LLVMTypeRef i8p = LLVMPointerType(ctx->i8, LOCAL_ADDR_SPACE);
	LLVMValueRef var;

	assert(decl->Declaration.MemType == TGSI_MEMORY_TYPE_SHARED);
	assert(decl->Range.First == decl->Range.Last);
	assert(!ctx->shared_memory);

	var = LLVMAddGlobalInAddressSpace(gallivm->module,
	                                  LLVMArrayType(ctx->i8, sel->local_size),
	                                  "compute_lds",
	                                  LOCAL_ADDR_SPACE);
	LLVMSetAlignment(var, 4);

	ctx->shared_memory = LLVMBuildBitCast(gallivm->builder, var, i8p, "");
}

static LLVMValueRef load_const_buffer_desc(struct si_shader_context *ctx, int i)
{
	LLVMValueRef list_ptr = LLVMGetParam(ctx->main_fn,
					     SI_PARAM_CONST_BUFFERS);

	return build_indexed_load_const(ctx, list_ptr,
					LLVMConstInt(ctx->i32, i, 0));
}

static LLVMValueRef fetch_constant(
	struct lp_build_tgsi_context *bld_base,
	const struct tgsi_full_src_register *reg,
	enum tgsi_opcode_type type,
	unsigned swizzle)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct lp_build_context *base = &bld_base->base;
	const struct tgsi_ind_register *ireg = &reg->Indirect;
	unsigned buf, idx;

	LLVMValueRef addr, bufp;
	LLVMValueRef result;

	if (swizzle == LP_CHAN_ALL) {
		unsigned chan;
		LLVMValueRef values[4];
		for (chan = 0; chan < TGSI_NUM_CHANNELS; ++chan)
			values[chan] = fetch_constant(bld_base, reg, type, chan);

		return lp_build_gather_values(bld_base->base.gallivm, values, 4);
	}

	buf = reg->Register.Dimension ? reg->Dimension.Index : 0;
	idx = reg->Register.Index * 4 + swizzle;

	if (reg->Register.Dimension && reg->Dimension.Indirect) {
		LLVMValueRef ptr = LLVMGetParam(ctx->main_fn, SI_PARAM_CONST_BUFFERS);
		LLVMValueRef index;
		index = get_bounded_indirect_index(ctx, &reg->DimIndirect,
						   reg->Dimension.Index,
						   SI_NUM_CONST_BUFFERS);
		bufp = build_indexed_load_const(ctx, ptr, index);
	} else
		bufp = load_const_buffer_desc(ctx, buf);

	if (reg->Register.Indirect) {
		addr = ctx->soa.addr[ireg->Index][ireg->Swizzle];
		addr = LLVMBuildLoad(base->gallivm->builder, addr, "load addr reg");
		addr = lp_build_mul_imm(&bld_base->uint_bld, addr, 16);
		addr = lp_build_add(&bld_base->uint_bld, addr,
				    lp_build_const_int32(base->gallivm, idx * 4));
	} else {
		addr = LLVMConstInt(ctx->i32, idx * 4, 0);
	}

	result = buffer_load_const(ctx, bufp, addr);

	if (!tgsi_type_is_64bit(type))
		result = bitcast(bld_base, type, result);
	else {
		LLVMValueRef addr2, result2;

		addr2 = lp_build_add(&bld_base->uint_bld, addr,
				     LLVMConstInt(ctx->i32, 4, 0));
		result2 = buffer_load_const(ctx, bufp, addr2);

		result = si_llvm_emit_fetch_64bit(bld_base, type,
						  result, result2);
	}
	return result;
}

/* Upper 16 bits must be zero. */
static LLVMValueRef si_llvm_pack_two_int16(struct gallivm_state *gallivm,
					   LLVMValueRef val[2])
{
	return LLVMBuildOr(gallivm->builder, val[0],
			   LLVMBuildShl(gallivm->builder, val[1],
					lp_build_const_int32(gallivm, 16),
					""), "");
}

/* Upper 16 bits are ignored and will be dropped. */
static LLVMValueRef si_llvm_pack_two_int32_as_int16(struct gallivm_state *gallivm,
						    LLVMValueRef val[2])
{
	LLVMValueRef v[2] = {
		LLVMBuildAnd(gallivm->builder, val[0],
			     lp_build_const_int32(gallivm, 0xffff), ""),
		val[1],
	};
	return si_llvm_pack_two_int16(gallivm, v);
}

/* Initialize arguments for the shader export intrinsic */
static void si_llvm_init_export_args(struct lp_build_tgsi_context *bld_base,
				     LLVMValueRef *values,
				     unsigned target,
				     LLVMValueRef *args)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct lp_build_context *uint =
				&ctx->soa.bld_base.uint_bld;
	struct lp_build_context *base = &bld_base->base;
	struct gallivm_state *gallivm = base->gallivm;
	LLVMBuilderRef builder = base->gallivm->builder;
	LLVMValueRef val[4];
	unsigned spi_shader_col_format = V_028714_SPI_SHADER_32_ABGR;
	unsigned chan;
	bool is_int8, is_int10;

	/* Default is 0xf. Adjusted below depending on the format. */
	args[0] = lp_build_const_int32(base->gallivm, 0xf); /* writemask */

	/* Specify whether the EXEC mask represents the valid mask */
	args[1] = uint->zero;

	/* Specify whether this is the last export */
	args[2] = uint->zero;

	/* Specify the target we are exporting */
	args[3] = lp_build_const_int32(base->gallivm, target);

	if (ctx->type == PIPE_SHADER_FRAGMENT) {
		const union si_shader_key *key = &ctx->shader->key;
		unsigned col_formats = key->ps.epilog.spi_shader_col_format;
		int cbuf = target - V_008DFC_SQ_EXP_MRT;

		assert(cbuf >= 0 && cbuf < 8);
		spi_shader_col_format = (col_formats >> (cbuf * 4)) & 0xf;
		is_int8 = (key->ps.epilog.color_is_int8 >> cbuf) & 0x1;
		is_int10 = (key->ps.epilog.color_is_int10 >> cbuf) & 0x1;
	}

	args[4] = uint->zero; /* COMPR flag */
	args[5] = base->undef;
	args[6] = base->undef;
	args[7] = base->undef;
	args[8] = base->undef;

	switch (spi_shader_col_format) {
	case V_028714_SPI_SHADER_ZERO:
		args[0] = uint->zero; /* writemask */
		args[3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_NULL);
		break;

	case V_028714_SPI_SHADER_32_R:
		args[0] = uint->one; /* writemask */
		args[5] = values[0];
		break;

	case V_028714_SPI_SHADER_32_GR:
		args[0] = lp_build_const_int32(base->gallivm, 0x3); /* writemask */
		args[5] = values[0];
		args[6] = values[1];
		break;

	case V_028714_SPI_SHADER_32_AR:
		args[0] = lp_build_const_int32(base->gallivm, 0x9); /* writemask */
		args[5] = values[0];
		args[8] = values[3];
		break;

	case V_028714_SPI_SHADER_FP16_ABGR:
		args[4] = uint->one; /* COMPR flag */

		for (chan = 0; chan < 2; chan++) {
			LLVMValueRef pack_args[2] = {
				values[2 * chan],
				values[2 * chan + 1]
			};
			LLVMValueRef packed;

			packed = lp_build_intrinsic(base->gallivm->builder,
						    "llvm.SI.packf16",
						    ctx->i32, pack_args, 2,
						    LLVMReadNoneAttribute);
			args[chan + 5] =
				LLVMBuildBitCast(base->gallivm->builder,
						 packed, ctx->f32, "");
		}
		break;

	case V_028714_SPI_SHADER_UNORM16_ABGR:
		for (chan = 0; chan < 4; chan++) {
			val[chan] = si_llvm_saturate(bld_base, values[chan]);
			val[chan] = LLVMBuildFMul(builder, val[chan],
						  lp_build_const_float(gallivm, 65535), "");
			val[chan] = LLVMBuildFAdd(builder, val[chan],
						  lp_build_const_float(gallivm, 0.5), "");
			val[chan] = LLVMBuildFPToUI(builder, val[chan],
						    ctx->i32, "");
		}

		args[4] = uint->one; /* COMPR flag */
		args[5] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int16(gallivm, val));
		args[6] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int16(gallivm, val+2));
		break;

	case V_028714_SPI_SHADER_SNORM16_ABGR:
		for (chan = 0; chan < 4; chan++) {
			/* Clamp between [-1, 1]. */
			val[chan] = lp_build_emit_llvm_binary(bld_base, TGSI_OPCODE_MIN,
							      values[chan],
							      lp_build_const_float(gallivm, 1));
			val[chan] = lp_build_emit_llvm_binary(bld_base, TGSI_OPCODE_MAX,
							      val[chan],
							      lp_build_const_float(gallivm, -1));
			/* Convert to a signed integer in [-32767, 32767]. */
			val[chan] = LLVMBuildFMul(builder, val[chan],
						  lp_build_const_float(gallivm, 32767), "");
			/* If positive, add 0.5, else add -0.5. */
			val[chan] = LLVMBuildFAdd(builder, val[chan],
					LLVMBuildSelect(builder,
						LLVMBuildFCmp(builder, LLVMRealOGE,
							      val[chan], base->zero, ""),
						lp_build_const_float(gallivm, 0.5),
						lp_build_const_float(gallivm, -0.5), ""), "");
			val[chan] = LLVMBuildFPToSI(builder, val[chan], ctx->i32, "");
		}

		args[4] = uint->one; /* COMPR flag */
		args[5] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int32_as_int16(gallivm, val));
		args[6] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int32_as_int16(gallivm, val+2));
		break;

	case V_028714_SPI_SHADER_UINT16_ABGR: {
		LLVMValueRef max_rgb = lp_build_const_int32(gallivm,
			is_int8 ? 255 : is_int10 ? 1023 : 65535);
		LLVMValueRef max_alpha =
			!is_int10 ? max_rgb : lp_build_const_int32(gallivm, 3);

		/* Clamp. */
		for (chan = 0; chan < 4; chan++) {
			val[chan] = bitcast(bld_base, TGSI_TYPE_UNSIGNED, values[chan]);
			val[chan] = lp_build_emit_llvm_binary(bld_base, TGSI_OPCODE_UMIN,
					val[chan],
					chan == 3 ? max_alpha : max_rgb);
		}

		args[4] = uint->one; /* COMPR flag */
		args[5] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int16(gallivm, val));
		args[6] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int16(gallivm, val+2));
		break;
	}

	case V_028714_SPI_SHADER_SINT16_ABGR: {
		LLVMValueRef max_rgb = lp_build_const_int32(gallivm,
			is_int8 ? 127 : is_int10 ? 511 : 32767);
		LLVMValueRef min_rgb = lp_build_const_int32(gallivm,
			is_int8 ? -128 : is_int10 ? -512 : -32768);
		LLVMValueRef max_alpha =
			!is_int10 ? max_rgb : lp_build_const_int32(gallivm, 1);
		LLVMValueRef min_alpha =
			!is_int10 ? min_rgb : lp_build_const_int32(gallivm, -2);

		/* Clamp. */
		for (chan = 0; chan < 4; chan++) {
			val[chan] = bitcast(bld_base, TGSI_TYPE_UNSIGNED, values[chan]);
			val[chan] = lp_build_emit_llvm_binary(bld_base,
					TGSI_OPCODE_IMIN,
					val[chan], chan == 3 ? max_alpha : max_rgb);
			val[chan] = lp_build_emit_llvm_binary(bld_base,
					TGSI_OPCODE_IMAX,
					val[chan], chan == 3 ? min_alpha : min_rgb);
		}

		args[4] = uint->one; /* COMPR flag */
		args[5] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int32_as_int16(gallivm, val));
		args[6] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int32_as_int16(gallivm, val+2));
		break;
	}

	case V_028714_SPI_SHADER_32_ABGR:
		memcpy(&args[5], values, sizeof(values[0]) * 4);
		break;
	}
}

static void si_alpha_test(struct lp_build_tgsi_context *bld_base,
			  LLVMValueRef alpha)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;

	if (ctx->shader->key.ps.epilog.alpha_func != PIPE_FUNC_NEVER) {
		LLVMValueRef alpha_ref = LLVMGetParam(ctx->main_fn,
				SI_PARAM_ALPHA_REF);

		LLVMValueRef alpha_pass =
			lp_build_cmp(&bld_base->base,
				     ctx->shader->key.ps.epilog.alpha_func,
				     alpha, alpha_ref);
		LLVMValueRef arg =
			lp_build_select(&bld_base->base,
					alpha_pass,
					lp_build_const_float(gallivm, 1.0f),
					lp_build_const_float(gallivm, -1.0f));

		lp_build_intrinsic(gallivm->builder, "llvm.AMDGPU.kill",
				   ctx->voidt, &arg, 1, 0);
	} else {
		lp_build_intrinsic(gallivm->builder, "llvm.AMDGPU.kilp",
				   ctx->voidt, NULL, 0, 0);
	}
}

static LLVMValueRef si_scale_alpha_by_sample_mask(struct lp_build_tgsi_context *bld_base,
						  LLVMValueRef alpha,
						  unsigned samplemask_param)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef coverage;

	/* alpha = alpha * popcount(coverage) / SI_NUM_SMOOTH_AA_SAMPLES */
	coverage = LLVMGetParam(ctx->main_fn,
				samplemask_param);
	coverage = bitcast(bld_base, TGSI_TYPE_SIGNED, coverage);

	coverage = lp_build_intrinsic(gallivm->builder, "llvm.ctpop.i32",
				   ctx->i32,
				   &coverage, 1, LLVMReadNoneAttribute);

	coverage = LLVMBuildUIToFP(gallivm->builder, coverage,
				   ctx->f32, "");

	coverage = LLVMBuildFMul(gallivm->builder, coverage,
				 lp_build_const_float(gallivm,
					1.0 / SI_NUM_SMOOTH_AA_SAMPLES), "");

	return LLVMBuildFMul(gallivm->builder, alpha, coverage, "");
}

static void si_llvm_emit_clipvertex(struct lp_build_tgsi_context *bld_base,
				    LLVMValueRef (*pos)[9], LLVMValueRef *out_elts)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct lp_build_context *base = &bld_base->base;
	struct lp_build_context *uint = &ctx->soa.bld_base.uint_bld;
	unsigned reg_index;
	unsigned chan;
	unsigned const_chan;
	LLVMValueRef base_elt;
	LLVMValueRef ptr = LLVMGetParam(ctx->main_fn, SI_PARAM_RW_BUFFERS);
	LLVMValueRef constbuf_index = lp_build_const_int32(base->gallivm,
							   SI_VS_CONST_CLIP_PLANES);
	LLVMValueRef const_resource = build_indexed_load_const(ctx, ptr, constbuf_index);

	for (reg_index = 0; reg_index < 2; reg_index ++) {
		LLVMValueRef *args = pos[2 + reg_index];

		args[5] =
		args[6] =
		args[7] =
		args[8] = lp_build_const_float(base->gallivm, 0.0f);

		/* Compute dot products of position and user clip plane vectors */
		for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
			for (const_chan = 0; const_chan < TGSI_NUM_CHANNELS; const_chan++) {
				args[1] = lp_build_const_int32(base->gallivm,
							       ((reg_index * 4 + chan) * 4 +
								const_chan) * 4);
				base_elt = buffer_load_const(ctx, const_resource,
							     args[1]);
				args[5 + chan] =
					lp_build_add(base, args[5 + chan],
						     lp_build_mul(base, base_elt,
								  out_elts[const_chan]));
			}
		}

		args[0] = lp_build_const_int32(base->gallivm, 0xf);
		args[1] = uint->zero;
		args[2] = uint->zero;
		args[3] = lp_build_const_int32(base->gallivm,
					       V_008DFC_SQ_EXP_POS + 2 + reg_index);
		args[4] = uint->zero;
	}
}

static void si_dump_streamout(struct pipe_stream_output_info *so)
{
	unsigned i;

	if (so->num_outputs)
		fprintf(stderr, "STREAMOUT\n");

	for (i = 0; i < so->num_outputs; i++) {
		unsigned mask = ((1 << so->output[i].num_components) - 1) <<
				so->output[i].start_component;
		fprintf(stderr, "  %i: BUF%i[%i..%i] <- OUT[%i].%s%s%s%s\n",
			i, so->output[i].output_buffer,
			so->output[i].dst_offset, so->output[i].dst_offset + so->output[i].num_components - 1,
			so->output[i].register_index,
			mask & 1 ? "x" : "",
		        mask & 2 ? "y" : "",
		        mask & 4 ? "z" : "",
		        mask & 8 ? "w" : "");
	}
}

/* On SI, the vertex shader is responsible for writing streamout data
 * to buffers. */
static void si_llvm_emit_streamout(struct si_shader_context *ctx,
				   struct si_shader_output_values *outputs,
				   unsigned noutput)
{
	struct pipe_stream_output_info *so = &ctx->shader->selector->so;
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	int i, j;
	struct lp_build_if_state if_ctx;
	LLVMValueRef so_buffers[4];
	LLVMValueRef buf_ptr = LLVMGetParam(ctx->main_fn,
					    SI_PARAM_RW_BUFFERS);

	/* Load the descriptors. */
	for (i = 0; i < 4; ++i) {
		if (ctx->shader->selector->so.stride[i]) {
			LLVMValueRef offset = lp_build_const_int32(gallivm,
								   SI_VS_STREAMOUT_BUF0 + i);

			so_buffers[i] = build_indexed_load_const(ctx, buf_ptr, offset);
		}
	}

	/* Get bits [22:16], i.e. (so_param >> 16) & 127; */
	LLVMValueRef so_vtx_count =
		unpack_param(ctx, ctx->param_streamout_config, 16, 7);

	LLVMValueRef tid = get_thread_id(ctx);

	/* can_emit = tid < so_vtx_count; */
	LLVMValueRef can_emit =
		LLVMBuildICmp(builder, LLVMIntULT, tid, so_vtx_count, "");

	LLVMValueRef stream_id =
		unpack_param(ctx, ctx->param_streamout_config, 24, 2);

	/* Emit the streamout code conditionally. This actually avoids
	 * out-of-bounds buffer access. The hw tells us via the SGPR
	 * (so_vtx_count) which threads are allowed to emit streamout data. */
	lp_build_if(&if_ctx, gallivm, can_emit);
	{
		/* The buffer offset is computed as follows:
		 *   ByteOffset = streamout_offset[buffer_id]*4 +
		 *                (streamout_write_index + thread_id)*stride[buffer_id] +
		 *                attrib_offset
                 */

		LLVMValueRef so_write_index =
			LLVMGetParam(ctx->main_fn,
				     ctx->param_streamout_write_index);

		/* Compute (streamout_write_index + thread_id). */
		so_write_index = LLVMBuildAdd(builder, so_write_index, tid, "");

		/* Compute the write offset for each enabled buffer. */
		LLVMValueRef so_write_offset[4] = {};
		for (i = 0; i < 4; i++) {
			if (!so->stride[i])
				continue;

			LLVMValueRef so_offset = LLVMGetParam(ctx->main_fn,
							      ctx->param_streamout_offset[i]);
			so_offset = LLVMBuildMul(builder, so_offset, LLVMConstInt(ctx->i32, 4, 0), "");

			so_write_offset[i] = LLVMBuildMul(builder, so_write_index,
							  LLVMConstInt(ctx->i32, so->stride[i]*4, 0), "");
			so_write_offset[i] = LLVMBuildAdd(builder, so_write_offset[i], so_offset, "");
		}

		/* Write streamout data. */
		for (i = 0; i < so->num_outputs; i++) {
			unsigned buf_idx = so->output[i].output_buffer;
			unsigned reg = so->output[i].register_index;
			unsigned start = so->output[i].start_component;
			unsigned num_comps = so->output[i].num_components;
			unsigned stream = so->output[i].stream;
			LLVMValueRef out[4];
			struct lp_build_if_state if_ctx_stream;

			assert(num_comps && num_comps <= 4);
			if (!num_comps || num_comps > 4)
				continue;

			if (reg >= noutput)
				continue;

			/* Load the output as int. */
			for (j = 0; j < num_comps; j++) {
				out[j] = LLVMBuildBitCast(builder,
							  outputs[reg].values[start+j],
						ctx->i32, "");
			}

			/* Pack the output. */
			LLVMValueRef vdata = NULL;

			switch (num_comps) {
			case 1: /* as i32 */
				vdata = out[0];
				break;
			case 2: /* as v2i32 */
			case 3: /* as v4i32 (aligned to 4) */
			case 4: /* as v4i32 */
				vdata = LLVMGetUndef(LLVMVectorType(ctx->i32, util_next_power_of_two(num_comps)));
				for (j = 0; j < num_comps; j++) {
					vdata = LLVMBuildInsertElement(builder, vdata, out[j],
								       LLVMConstInt(ctx->i32, j, 0), "");
				}
				break;
			}

			LLVMValueRef can_emit_stream =
				LLVMBuildICmp(builder, LLVMIntEQ,
					      stream_id,
					      lp_build_const_int32(gallivm, stream), "");

			lp_build_if(&if_ctx_stream, gallivm, can_emit_stream);
			build_tbuffer_store_dwords(ctx, so_buffers[buf_idx],
						   vdata, num_comps,
						   so_write_offset[buf_idx],
						   LLVMConstInt(ctx->i32, 0, 0),
						   so->output[i].dst_offset*4);
			lp_build_endif(&if_ctx_stream);
		}
	}
	lp_build_endif(&if_ctx);
}


/* Generate export instructions for hardware VS shader stage */
static void si_llvm_export_vs(struct lp_build_tgsi_context *bld_base,
			      struct si_shader_output_values *outputs,
			      unsigned noutput)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct si_shader *shader = ctx->shader;
	struct lp_build_context *base = &bld_base->base;
	struct lp_build_context *uint =
				&ctx->soa.bld_base.uint_bld;
	LLVMValueRef args[9];
	LLVMValueRef pos_args[4][9] = { { 0 } };
	LLVMValueRef psize_value = NULL, edgeflag_value = NULL, layer_value = NULL, viewport_index_value = NULL;
	unsigned semantic_name, semantic_index;
	unsigned target;
	unsigned param_count = 0;
	unsigned pos_idx;
	int i;

	if (outputs && ctx->shader->selector->so.num_outputs) {
		si_llvm_emit_streamout(ctx, outputs, noutput);
	}

	for (i = 0; i < noutput; i++) {
		semantic_name = outputs[i].name;
		semantic_index = outputs[i].sid;

handle_semantic:
		/* Select the correct target */
		switch(semantic_name) {
		case TGSI_SEMANTIC_PSIZE:
			psize_value = outputs[i].values[0];
			continue;
		case TGSI_SEMANTIC_EDGEFLAG:
			edgeflag_value = outputs[i].values[0];
			continue;
		case TGSI_SEMANTIC_LAYER:
			layer_value = outputs[i].values[0];
			semantic_name = TGSI_SEMANTIC_GENERIC;
			goto handle_semantic;
		case TGSI_SEMANTIC_VIEWPORT_INDEX:
			viewport_index_value = outputs[i].values[0];
			semantic_name = TGSI_SEMANTIC_GENERIC;
			goto handle_semantic;
		case TGSI_SEMANTIC_POSITION:
			target = V_008DFC_SQ_EXP_POS;
			break;
		case TGSI_SEMANTIC_COLOR:
		case TGSI_SEMANTIC_BCOLOR:
			target = V_008DFC_SQ_EXP_PARAM + param_count;
			assert(i < ARRAY_SIZE(shader->info.vs_output_param_offset));
			shader->info.vs_output_param_offset[i] = param_count;
			param_count++;
			break;
		case TGSI_SEMANTIC_CLIPDIST:
			target = V_008DFC_SQ_EXP_POS + 2 + semantic_index;
			break;
		case TGSI_SEMANTIC_CLIPVERTEX:
			si_llvm_emit_clipvertex(bld_base, pos_args, outputs[i].values);
			continue;
		case TGSI_SEMANTIC_PRIMID:
		case TGSI_SEMANTIC_FOG:
		case TGSI_SEMANTIC_TEXCOORD:
		case TGSI_SEMANTIC_GENERIC:
			target = V_008DFC_SQ_EXP_PARAM + param_count;
			assert(i < ARRAY_SIZE(shader->info.vs_output_param_offset));
			shader->info.vs_output_param_offset[i] = param_count;
			param_count++;
			break;
		default:
			target = 0;
			fprintf(stderr,
				"Warning: SI unhandled vs output type:%d\n",
				semantic_name);
		}

		si_llvm_init_export_args(bld_base, outputs[i].values, target, args);

		if (target >= V_008DFC_SQ_EXP_POS &&
		    target <= (V_008DFC_SQ_EXP_POS + 3)) {
			memcpy(pos_args[target - V_008DFC_SQ_EXP_POS],
			       args, sizeof(args));
		} else {
			lp_build_intrinsic(base->gallivm->builder,
					   "llvm.SI.export", ctx->voidt,
					   args, 9, 0);
		}

		if (semantic_name == TGSI_SEMANTIC_CLIPDIST) {
			semantic_name = TGSI_SEMANTIC_GENERIC;
			goto handle_semantic;
		}
	}

	shader->info.nr_param_exports = param_count;

	/* We need to add the position output manually if it's missing. */
	if (!pos_args[0][0]) {
		pos_args[0][0] = lp_build_const_int32(base->gallivm, 0xf); /* writemask */
		pos_args[0][1] = uint->zero; /* EXEC mask */
		pos_args[0][2] = uint->zero; /* last export? */
		pos_args[0][3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_POS);
		pos_args[0][4] = uint->zero; /* COMPR flag */
		pos_args[0][5] = base->zero; /* X */
		pos_args[0][6] = base->zero; /* Y */
		pos_args[0][7] = base->zero; /* Z */
		pos_args[0][8] = base->one;  /* W */
	}

	/* Write the misc vector (point size, edgeflag, layer, viewport). */
	if (shader->selector->info.writes_psize ||
	    shader->selector->info.writes_edgeflag ||
	    shader->selector->info.writes_viewport_index ||
	    shader->selector->info.writes_layer) {
		pos_args[1][0] = lp_build_const_int32(base->gallivm, /* writemask */
						      shader->selector->info.writes_psize |
						      (shader->selector->info.writes_edgeflag << 1) |
						      (shader->selector->info.writes_layer << 2) |
						      (shader->selector->info.writes_viewport_index << 3));
		pos_args[1][1] = uint->zero; /* EXEC mask */
		pos_args[1][2] = uint->zero; /* last export? */
		pos_args[1][3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_POS + 1);
		pos_args[1][4] = uint->zero; /* COMPR flag */
		pos_args[1][5] = base->zero; /* X */
		pos_args[1][6] = base->zero; /* Y */
		pos_args[1][7] = base->zero; /* Z */
		pos_args[1][8] = base->zero; /* W */

		if (shader->selector->info.writes_psize)
			pos_args[1][5] = psize_value;

		if (shader->selector->info.writes_edgeflag) {
			/* The output is a float, but the hw expects an integer
			 * with the first bit containing the edge flag. */
			edgeflag_value = LLVMBuildFPToUI(base->gallivm->builder,
							 edgeflag_value,
							 ctx->i32, "");
			edgeflag_value = lp_build_min(&bld_base->int_bld,
						      edgeflag_value,
						      bld_base->int_bld.one);

			/* The LLVM intrinsic expects a float. */
			pos_args[1][6] = LLVMBuildBitCast(base->gallivm->builder,
							  edgeflag_value,
							  ctx->f32, "");
		}

		if (shader->selector->info.writes_layer)
			pos_args[1][7] = layer_value;

		if (shader->selector->info.writes_viewport_index)
			pos_args[1][8] = viewport_index_value;
	}

	for (i = 0; i < 4; i++)
		if (pos_args[i][0])
			shader->info.nr_pos_exports++;

	pos_idx = 0;
	for (i = 0; i < 4; i++) {
		if (!pos_args[i][0])
			continue;

		/* Specify the target we are exporting */
		pos_args[i][3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_POS + pos_idx++);

		if (pos_idx == shader->info.nr_pos_exports)
			/* Specify that this is the last export */
			pos_args[i][2] = uint->one;

		lp_build_intrinsic(base->gallivm->builder, "llvm.SI.export",
				   ctx->voidt, pos_args[i], 9, 0);
	}
}

static void si_copy_tcs_inputs(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef invocation_id, rw_buffers, buffer, buffer_offset;
	LLVMValueRef lds_vertex_stride, lds_vertex_offset, lds_base;
	uint64_t inputs;

	invocation_id = unpack_param(ctx, SI_PARAM_REL_IDS, 8, 5);

	rw_buffers = LLVMGetParam(ctx->main_fn, SI_PARAM_RW_BUFFERS);
	buffer = build_indexed_load_const(ctx, rw_buffers,
	                lp_build_const_int32(gallivm, SI_HS_RING_TESS_OFFCHIP));

	buffer_offset = LLVMGetParam(ctx->main_fn, ctx->param_oc_lds);

	lds_vertex_stride = unpack_param(ctx, SI_PARAM_TCS_IN_LAYOUT, 13, 8);
	lds_vertex_offset = LLVMBuildMul(gallivm->builder, invocation_id,
	                                 lds_vertex_stride, "");
	lds_base = get_tcs_in_current_patch_offset(ctx);
	lds_base = LLVMBuildAdd(gallivm->builder, lds_base, lds_vertex_offset, "");

	inputs = ctx->shader->key.tcs.epilog.inputs_to_copy;
	while (inputs) {
		unsigned i = u_bit_scan64(&inputs);

		LLVMValueRef lds_ptr = LLVMBuildAdd(gallivm->builder, lds_base,
		                            lp_build_const_int32(gallivm, 4 * i),
		                             "");

		LLVMValueRef buffer_addr = get_tcs_tes_buffer_address(ctx,
		                              invocation_id,
		                              lp_build_const_int32(gallivm, i));

		LLVMValueRef value = lds_load(bld_base, TGSI_TYPE_SIGNED, ~0,
		                              lds_ptr);

		build_tbuffer_store_dwords(ctx, buffer, value, 4, buffer_addr,
		                           buffer_offset, 0);
	}
}

static void si_write_tess_factors(struct lp_build_tgsi_context *bld_base,
				  LLVMValueRef rel_patch_id,
				  LLVMValueRef invocation_id,
				  LLVMValueRef tcs_out_current_patch_data_offset)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	struct si_shader *shader = ctx->shader;
	unsigned tess_inner_index, tess_outer_index;
	LLVMValueRef lds_base, lds_inner, lds_outer, byteoffset, buffer;
	LLVMValueRef out[6], vec0, vec1, rw_buffers, tf_base;
	unsigned stride, outer_comps, inner_comps, i;
	struct lp_build_if_state if_ctx, inner_if_ctx;

	si_llvm_emit_barrier(NULL, bld_base, NULL);

	/* Do this only for invocation 0, because the tess levels are per-patch,
	 * not per-vertex.
	 *
	 * This can't jump, because invocation 0 executes this. It should
	 * at least mask out the loads and stores for other invocations.
	 */
	lp_build_if(&if_ctx, gallivm,
		    LLVMBuildICmp(gallivm->builder, LLVMIntEQ,
				  invocation_id, bld_base->uint_bld.zero, ""));

	/* Determine the layout of one tess factor element in the buffer. */
	switch (shader->key.tcs.epilog.prim_mode) {
	case PIPE_PRIM_LINES:
		stride = 2; /* 2 dwords, 1 vec2 store */
		outer_comps = 2;
		inner_comps = 0;
		break;
	case PIPE_PRIM_TRIANGLES:
		stride = 4; /* 4 dwords, 1 vec4 store */
		outer_comps = 3;
		inner_comps = 1;
		break;
	case PIPE_PRIM_QUADS:
		stride = 6; /* 6 dwords, 2 stores (vec4 + vec2) */
		outer_comps = 4;
		inner_comps = 2;
		break;
	default:
		assert(0);
		return;
	}

	/* Load tess_inner and tess_outer from LDS.
	 * Any invocation can write them, so we can't get them from a temporary.
	 */
	tess_inner_index = si_shader_io_get_unique_index(TGSI_SEMANTIC_TESSINNER, 0);
	tess_outer_index = si_shader_io_get_unique_index(TGSI_SEMANTIC_TESSOUTER, 0);

	lds_base = tcs_out_current_patch_data_offset;
	lds_inner = LLVMBuildAdd(gallivm->builder, lds_base,
				 lp_build_const_int32(gallivm,
						      tess_inner_index * 4), "");
	lds_outer = LLVMBuildAdd(gallivm->builder, lds_base,
				 lp_build_const_int32(gallivm,
						      tess_outer_index * 4), "");

	if (shader->key.tcs.epilog.prim_mode == PIPE_PRIM_LINES) {
		/* For isolines, the hardware expects tess factors in the
		 * reverse order from what GLSL / TGSI specify.
		 */
		out[0] = lds_load(bld_base, TGSI_TYPE_SIGNED, 1, lds_outer);
		out[1] = lds_load(bld_base, TGSI_TYPE_SIGNED, 0, lds_outer);
	} else {
		for (i = 0; i < outer_comps; i++)
			out[i] = lds_load(bld_base, TGSI_TYPE_SIGNED, i, lds_outer);
		for (i = 0; i < inner_comps; i++)
			out[outer_comps+i] = lds_load(bld_base, TGSI_TYPE_SIGNED, i, lds_inner);
	}

	/* Convert the outputs to vectors for stores. */
	vec0 = lp_build_gather_values(gallivm, out, MIN2(stride, 4));
	vec1 = NULL;

	if (stride > 4)
		vec1 = lp_build_gather_values(gallivm, out+4, stride - 4);

	/* Get the buffer. */
	rw_buffers = LLVMGetParam(ctx->main_fn,
				  SI_PARAM_RW_BUFFERS);
	buffer = build_indexed_load_const(ctx, rw_buffers,
			lp_build_const_int32(gallivm, SI_HS_RING_TESS_FACTOR));

	/* Get the offset. */
	tf_base = LLVMGetParam(ctx->main_fn,
			       SI_PARAM_TESS_FACTOR_OFFSET);
	byteoffset = LLVMBuildMul(gallivm->builder, rel_patch_id,
				  lp_build_const_int32(gallivm, 4 * stride), "");

	lp_build_if(&inner_if_ctx, gallivm,
		    LLVMBuildICmp(gallivm->builder, LLVMIntEQ,
				  rel_patch_id, bld_base->uint_bld.zero, ""));

	/* Store the dynamic HS control word. */
	build_tbuffer_store_dwords(ctx, buffer,
	                           lp_build_const_int32(gallivm, 0x80000000),
	                           1, lp_build_const_int32(gallivm, 0), tf_base, 0);

	lp_build_endif(&inner_if_ctx);

	/* Store the tessellation factors. */
	build_tbuffer_store_dwords(ctx, buffer, vec0,
				   MIN2(stride, 4), byteoffset, tf_base, 4);
	if (vec1)
		build_tbuffer_store_dwords(ctx, buffer, vec1,
					   stride - 4, byteoffset, tf_base, 20);
	lp_build_endif(&if_ctx);
}

/* This only writes the tessellation factor levels. */
static void si_llvm_emit_tcs_epilogue(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	LLVMValueRef rel_patch_id, invocation_id, tf_lds_offset;

	rel_patch_id = get_rel_patch_id(ctx);
	invocation_id = unpack_param(ctx, SI_PARAM_REL_IDS, 8, 5);
	tf_lds_offset = get_tcs_out_current_patch_data_offset(ctx);

	if (!ctx->is_monolithic) {
		/* Return epilog parameters from this function. */
		LLVMBuilderRef builder = bld_base->base.gallivm->builder;
		LLVMValueRef ret = ctx->return_value;
		LLVMValueRef rw_buffers, rw0, rw1, tf_soffset;
		unsigned vgpr;

		/* RW_BUFFERS pointer */
		rw_buffers = LLVMGetParam(ctx->main_fn,
					  SI_PARAM_RW_BUFFERS);
		rw_buffers = LLVMBuildPtrToInt(builder, rw_buffers, ctx->i64, "");
		rw_buffers = LLVMBuildBitCast(builder, rw_buffers, ctx->v2i32, "");
		rw0 = LLVMBuildExtractElement(builder, rw_buffers,
					      bld_base->uint_bld.zero, "");
		rw1 = LLVMBuildExtractElement(builder, rw_buffers,
					      bld_base->uint_bld.one, "");
		ret = LLVMBuildInsertValue(builder, ret, rw0, 0, "");
		ret = LLVMBuildInsertValue(builder, ret, rw1, 1, "");

		/* Tess factor buffer soffset is after user SGPRs. */
		tf_soffset = LLVMGetParam(ctx->main_fn,
					  SI_PARAM_TESS_FACTOR_OFFSET);
		ret = LLVMBuildInsertValue(builder, ret, tf_soffset,
					   SI_TCS_NUM_USER_SGPR + 1, "");

		/* VGPRs */
		rel_patch_id = bitcast(bld_base, TGSI_TYPE_FLOAT, rel_patch_id);
		invocation_id = bitcast(bld_base, TGSI_TYPE_FLOAT, invocation_id);
		tf_lds_offset = bitcast(bld_base, TGSI_TYPE_FLOAT, tf_lds_offset);

		vgpr = SI_TCS_NUM_USER_SGPR + 2;
		ret = LLVMBuildInsertValue(builder, ret, rel_patch_id, vgpr++, "");
		ret = LLVMBuildInsertValue(builder, ret, invocation_id, vgpr++, "");
		ret = LLVMBuildInsertValue(builder, ret, tf_lds_offset, vgpr++, "");
		ctx->return_value = ret;
		return;
	}

	si_copy_tcs_inputs(bld_base);
	si_write_tess_factors(bld_base, rel_patch_id, invocation_id, tf_lds_offset);
}

static void si_llvm_emit_ls_epilogue(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct si_shader *shader = ctx->shader;
	struct tgsi_shader_info *info = &shader->selector->info;
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	unsigned i, chan;
	LLVMValueRef vertex_id = LLVMGetParam(ctx->main_fn,
					      ctx->param_rel_auto_id);
	LLVMValueRef vertex_dw_stride =
		unpack_param(ctx, SI_PARAM_LS_OUT_LAYOUT, 13, 8);
	LLVMValueRef base_dw_addr = LLVMBuildMul(gallivm->builder, vertex_id,
						 vertex_dw_stride, "");

	/* Write outputs to LDS. The next shader (TCS aka HS) will read
	 * its inputs from it. */
	for (i = 0; i < info->num_outputs; i++) {
		LLVMValueRef *out_ptr = ctx->soa.outputs[i];
		unsigned name = info->output_semantic_name[i];
		unsigned index = info->output_semantic_index[i];
		int param = si_shader_io_get_unique_index(name, index);
		LLVMValueRef dw_addr = LLVMBuildAdd(gallivm->builder, base_dw_addr,
					lp_build_const_int32(gallivm, param * 4), "");

		for (chan = 0; chan < 4; chan++) {
			lds_store(bld_base, chan, dw_addr,
				  LLVMBuildLoad(gallivm->builder, out_ptr[chan], ""));
		}
	}
}

static void si_llvm_emit_es_epilogue(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	struct si_shader *es = ctx->shader;
	struct tgsi_shader_info *info = &es->selector->info;
	LLVMValueRef soffset = LLVMGetParam(ctx->main_fn,
					    ctx->param_es2gs_offset);
	unsigned chan;
	int i;

	for (i = 0; i < info->num_outputs; i++) {
		LLVMValueRef *out_ptr =
			ctx->soa.outputs[i];
		int param_index;

		if (info->output_semantic_name[i] == TGSI_SEMANTIC_VIEWPORT_INDEX ||
		    info->output_semantic_name[i] == TGSI_SEMANTIC_LAYER)
			continue;

		param_index = si_shader_io_get_unique_index(info->output_semantic_name[i],
							    info->output_semantic_index[i]);

		for (chan = 0; chan < 4; chan++) {
			LLVMValueRef out_val = LLVMBuildLoad(gallivm->builder, out_ptr[chan], "");
			out_val = LLVMBuildBitCast(gallivm->builder, out_val, ctx->i32, "");

			build_tbuffer_store(ctx,
					    ctx->esgs_ring,
					    out_val, 1,
					    LLVMGetUndef(ctx->i32), soffset,
					    (4 * param_index + chan) * 4,
					    V_008F0C_BUF_DATA_FORMAT_32,
					    V_008F0C_BUF_NUM_FORMAT_UINT,
					    0, 0, 1, 1, 0);
		}
	}
}

static void si_llvm_emit_gs_epilogue(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef args[2];

	args[0] = lp_build_const_int32(gallivm,	SENDMSG_GS_OP_NOP | SENDMSG_GS_DONE);
	args[1] = LLVMGetParam(ctx->main_fn, SI_PARAM_GS_WAVE_ID);
	lp_build_intrinsic(gallivm->builder, "llvm.SI.sendmsg",
			   ctx->voidt, args, 2, 0);
}

static void si_llvm_emit_vs_epilogue(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	struct tgsi_shader_info *info = &ctx->shader->selector->info;
	struct si_shader_output_values *outputs = NULL;
	int i,j;

	assert(!ctx->is_gs_copy_shader);

	outputs = MALLOC((info->num_outputs + 1) * sizeof(outputs[0]));

	/* Vertex color clamping.
	 *
	 * This uses a state constant loaded in a user data SGPR and
	 * an IF statement is added that clamps all colors if the constant
	 * is true.
	 */
	if (ctx->type == PIPE_SHADER_VERTEX) {
		struct lp_build_if_state if_ctx;
		LLVMValueRef cond = NULL;
		LLVMValueRef addr, val;

		for (i = 0; i < info->num_outputs; i++) {
			if (info->output_semantic_name[i] != TGSI_SEMANTIC_COLOR &&
			    info->output_semantic_name[i] != TGSI_SEMANTIC_BCOLOR)
				continue;

			/* We've found a color. */
			if (!cond) {
				/* The state is in the first bit of the user SGPR. */
				cond = LLVMGetParam(ctx->main_fn,
						    SI_PARAM_VS_STATE_BITS);
				cond = LLVMBuildTrunc(gallivm->builder, cond,
						      ctx->i1, "");
				lp_build_if(&if_ctx, gallivm, cond);
			}

			for (j = 0; j < 4; j++) {
				addr = ctx->soa.outputs[i][j];
				val = LLVMBuildLoad(gallivm->builder, addr, "");
				val = si_llvm_saturate(bld_base, val);
				LLVMBuildStore(gallivm->builder, val, addr);
			}
		}

		if (cond)
			lp_build_endif(&if_ctx);
	}

	for (i = 0; i < info->num_outputs; i++) {
		outputs[i].name = info->output_semantic_name[i];
		outputs[i].sid = info->output_semantic_index[i];

		for (j = 0; j < 4; j++)
			outputs[i].values[j] =
				LLVMBuildLoad(gallivm->builder,
					      ctx->soa.outputs[i][j],
					      "");
	}

	if (ctx->is_monolithic) {
		/* Export PrimitiveID when PS needs it. */
		if (si_vs_exports_prim_id(ctx->shader)) {
			outputs[i].name = TGSI_SEMANTIC_PRIMID;
			outputs[i].sid = 0;
			outputs[i].values[0] = bitcast(bld_base, TGSI_TYPE_FLOAT,
						       get_primitive_id(bld_base, 0));
			outputs[i].values[1] = bld_base->base.undef;
			outputs[i].values[2] = bld_base->base.undef;
			outputs[i].values[3] = bld_base->base.undef;
			i++;
		}
	} else {
		/* Return the primitive ID from the LLVM function. */
		ctx->return_value =
			LLVMBuildInsertValue(gallivm->builder,
					     ctx->return_value,
					     bitcast(bld_base, TGSI_TYPE_FLOAT,
						     get_primitive_id(bld_base, 0)),
					     VS_EPILOG_PRIMID_LOC, "");
	}

	si_llvm_export_vs(bld_base, outputs, i);
	FREE(outputs);
}

struct si_ps_exports {
	unsigned num;
	LLVMValueRef args[10][9];
};

unsigned si_get_spi_shader_z_format(bool writes_z, bool writes_stencil,
				    bool writes_samplemask)
{
	if (writes_z) {
		/* Z needs 32 bits. */
		if (writes_samplemask)
			return V_028710_SPI_SHADER_32_ABGR;
		else if (writes_stencil)
			return V_028710_SPI_SHADER_32_GR;
		else
			return V_028710_SPI_SHADER_32_R;
	} else if (writes_stencil || writes_samplemask) {
		/* Both stencil and sample mask need only 16 bits. */
		return V_028710_SPI_SHADER_UINT16_ABGR;
	} else {
		return V_028710_SPI_SHADER_ZERO;
	}
}

static void si_export_mrt_z(struct lp_build_tgsi_context *bld_base,
			    LLVMValueRef depth, LLVMValueRef stencil,
			    LLVMValueRef samplemask, struct si_ps_exports *exp)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct lp_build_context *base = &bld_base->base;
	struct lp_build_context *uint = &bld_base->uint_bld;
	LLVMValueRef args[9];
	unsigned mask = 0;
	unsigned format = si_get_spi_shader_z_format(depth != NULL,
						     stencil != NULL,
						     samplemask != NULL);

	assert(depth || stencil || samplemask);

	args[1] = uint->one; /* whether the EXEC mask is valid */
	args[2] = uint->one; /* DONE bit */

	/* Specify the target we are exporting */
	args[3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_MRTZ);

	args[4] = uint->zero; /* COMP flag */
	args[5] = base->undef; /* R, depth */
	args[6] = base->undef; /* G, stencil test value[0:7], stencil op value[8:15] */
	args[7] = base->undef; /* B, sample mask */
	args[8] = base->undef; /* A, alpha to mask */

	if (format == V_028710_SPI_SHADER_UINT16_ABGR) {
		assert(!depth);
		args[4] = uint->one; /* COMPR flag */

		if (stencil) {
			/* Stencil should be in X[23:16]. */
			stencil = bitcast(bld_base, TGSI_TYPE_UNSIGNED, stencil);
			stencil = LLVMBuildShl(base->gallivm->builder, stencil,
					       LLVMConstInt(ctx->i32, 16, 0), "");
			args[5] = bitcast(bld_base, TGSI_TYPE_FLOAT, stencil);
			mask |= 0x3;
		}
		if (samplemask) {
			/* SampleMask should be in Y[15:0]. */
			args[6] = samplemask;
			mask |= 0xc;
		}
	} else {
		if (depth) {
			args[5] = depth;
			mask |= 0x1;
		}
		if (stencil) {
			args[6] = stencil;
			mask |= 0x2;
		}
		if (samplemask) {
			args[7] = samplemask;
			mask |= 0x4;
		}
	}

	/* SI (except OLAND) has a bug that it only looks
	 * at the X writemask component. */
	if (ctx->screen->b.chip_class == SI &&
	    ctx->screen->b.family != CHIP_OLAND)
		mask |= 0x1;

	/* Specify which components to enable */
	args[0] = lp_build_const_int32(base->gallivm, mask);

	memcpy(exp->args[exp->num++], args, sizeof(args));
}

static void si_export_mrt_color(struct lp_build_tgsi_context *bld_base,
				LLVMValueRef *color, unsigned index,
				unsigned samplemask_param,
				bool is_last, struct si_ps_exports *exp)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct lp_build_context *base = &bld_base->base;
	int i;

	/* Clamp color */
	if (ctx->shader->key.ps.epilog.clamp_color)
		for (i = 0; i < 4; i++)
			color[i] = si_llvm_saturate(bld_base, color[i]);

	/* Alpha to one */
	if (ctx->shader->key.ps.epilog.alpha_to_one)
		color[3] = base->one;

	/* Alpha test */
	if (index == 0 &&
	    ctx->shader->key.ps.epilog.alpha_func != PIPE_FUNC_ALWAYS)
		si_alpha_test(bld_base, color[3]);

	/* Line & polygon smoothing */
	if (ctx->shader->key.ps.epilog.poly_line_smoothing)
		color[3] = si_scale_alpha_by_sample_mask(bld_base, color[3],
							 samplemask_param);

	/* If last_cbuf > 0, FS_COLOR0_WRITES_ALL_CBUFS is true. */
	if (ctx->shader->key.ps.epilog.last_cbuf > 0) {
		LLVMValueRef args[8][9];
		int c, last = -1;

		/* Get the export arguments, also find out what the last one is. */
		for (c = 0; c <= ctx->shader->key.ps.epilog.last_cbuf; c++) {
			si_llvm_init_export_args(bld_base, color,
						 V_008DFC_SQ_EXP_MRT + c, args[c]);
			if (args[c][0] != bld_base->uint_bld.zero)
				last = c;
		}

		/* Emit all exports. */
		for (c = 0; c <= ctx->shader->key.ps.epilog.last_cbuf; c++) {
			if (is_last && last == c) {
				args[c][1] = bld_base->uint_bld.one; /* whether the EXEC mask is valid */
				args[c][2] = bld_base->uint_bld.one; /* DONE bit */
			} else if (args[c][0] == bld_base->uint_bld.zero)
				continue; /* unnecessary NULL export */

			memcpy(exp->args[exp->num++], args[c], sizeof(args[c]));
		}
	} else {
		LLVMValueRef args[9];

		/* Export */
		si_llvm_init_export_args(bld_base, color, V_008DFC_SQ_EXP_MRT + index,
					 args);
		if (is_last) {
			args[1] = bld_base->uint_bld.one; /* whether the EXEC mask is valid */
			args[2] = bld_base->uint_bld.one; /* DONE bit */
		} else if (args[0] == bld_base->uint_bld.zero)
			return; /* unnecessary NULL export */

		memcpy(exp->args[exp->num++], args, sizeof(args));
	}
}

static void si_emit_ps_exports(struct si_shader_context *ctx,
			       struct si_ps_exports *exp)
{
	for (unsigned i = 0; i < exp->num; i++)
		lp_build_intrinsic(ctx->gallivm.builder,
				   "llvm.SI.export", ctx->voidt,
				   exp->args[i], 9, 0);
}

static void si_export_null(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct lp_build_context *base = &bld_base->base;
	struct lp_build_context *uint = &bld_base->uint_bld;
	LLVMValueRef args[9];

	args[0] = lp_build_const_int32(base->gallivm, 0x0); /* enabled channels */
	args[1] = uint->one; /* whether the EXEC mask is valid */
	args[2] = uint->one; /* DONE bit */
	args[3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_NULL);
	args[4] = uint->zero; /* COMPR flag (0 = 32-bit export) */
	args[5] = base->undef; /* R */
	args[6] = base->undef; /* G */
	args[7] = base->undef; /* B */
	args[8] = base->undef; /* A */

	lp_build_intrinsic(base->gallivm->builder, "llvm.SI.export",
			   ctx->voidt, args, 9, 0);
}

static void si_llvm_emit_fs_epilogue(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct si_shader *shader = ctx->shader;
	struct lp_build_context *base = &bld_base->base;
	struct tgsi_shader_info *info = &shader->selector->info;
	LLVMBuilderRef builder = base->gallivm->builder;
	LLVMValueRef depth = NULL, stencil = NULL, samplemask = NULL;
	int last_color_export = -1;
	int i;
	struct si_ps_exports exp = {};

	/* Determine the last export. If MRTZ is present, it's always last.
	 * Otherwise, find the last color export.
	 */
	if (!info->writes_z && !info->writes_stencil && !info->writes_samplemask) {
		unsigned spi_format = shader->key.ps.epilog.spi_shader_col_format;

		/* Don't export NULL and return if alpha-test is enabled. */
		if (shader->key.ps.epilog.alpha_func != PIPE_FUNC_ALWAYS &&
		    shader->key.ps.epilog.alpha_func != PIPE_FUNC_NEVER &&
		    (spi_format & 0xf) == 0)
			spi_format |= V_028714_SPI_SHADER_32_AR;

		for (i = 0; i < info->num_outputs; i++) {
			unsigned index = info->output_semantic_index[i];

			if (info->output_semantic_name[i] != TGSI_SEMANTIC_COLOR)
				continue;

			/* If last_cbuf > 0, FS_COLOR0_WRITES_ALL_CBUFS is true. */
			if (shader->key.ps.epilog.last_cbuf > 0) {
				/* Just set this if any of the colorbuffers are enabled. */
				if (spi_format &
				    ((1llu << (4 * (shader->key.ps.epilog.last_cbuf + 1))) - 1))
					last_color_export = i;
				continue;
			}

			if ((spi_format >> (index * 4)) & 0xf)
				last_color_export = i;
		}

		/* If there are no outputs, export NULL. */
		if (last_color_export == -1) {
			si_export_null(bld_base);
			return;
		}
	}

	for (i = 0; i < info->num_outputs; i++) {
		unsigned semantic_name = info->output_semantic_name[i];
		unsigned semantic_index = info->output_semantic_index[i];
		unsigned j;
		LLVMValueRef color[4] = {};

		/* Select the correct target */
		switch (semantic_name) {
		case TGSI_SEMANTIC_POSITION:
			depth = LLVMBuildLoad(builder,
					      ctx->soa.outputs[i][2], "");
			break;
		case TGSI_SEMANTIC_STENCIL:
			stencil = LLVMBuildLoad(builder,
						ctx->soa.outputs[i][1], "");
			break;
		case TGSI_SEMANTIC_SAMPLEMASK:
			samplemask = LLVMBuildLoad(builder,
						   ctx->soa.outputs[i][0], "");
			break;
		case TGSI_SEMANTIC_COLOR:
			for (j = 0; j < 4; j++)
				color[j] = LLVMBuildLoad(builder,
							 ctx->soa.outputs[i][j], "");

			si_export_mrt_color(bld_base, color, semantic_index,
					    SI_PARAM_SAMPLE_COVERAGE,
					    last_color_export == i, &exp);
			break;
		default:
			fprintf(stderr,
				"Warning: SI unhandled fs output type:%d\n",
				semantic_name);
		}
	}

	if (depth || stencil || samplemask)
		si_export_mrt_z(bld_base, depth, stencil, samplemask, &exp);

	si_emit_ps_exports(ctx, &exp);
}

/**
 * Return PS outputs in this order:
 *
 * v[0:3] = color0.xyzw
 * v[4:7] = color1.xyzw
 * ...
 * vN+0 = Depth
 * vN+1 = Stencil
 * vN+2 = SampleMask
 * vN+3 = SampleMaskIn (used for OpenGL smoothing)
 *
 * The alpha-ref SGPR is returned via its original location.
 */
static void si_llvm_return_fs_outputs(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct si_shader *shader = ctx->shader;
	struct lp_build_context *base = &bld_base->base;
	struct tgsi_shader_info *info = &shader->selector->info;
	LLVMBuilderRef builder = base->gallivm->builder;
	unsigned i, j, first_vgpr, vgpr;

	LLVMValueRef color[8][4] = {};
	LLVMValueRef depth = NULL, stencil = NULL, samplemask = NULL;
	LLVMValueRef ret;

	/* Read the output values. */
	for (i = 0; i < info->num_outputs; i++) {
		unsigned semantic_name = info->output_semantic_name[i];
		unsigned semantic_index = info->output_semantic_index[i];

		switch (semantic_name) {
		case TGSI_SEMANTIC_COLOR:
			assert(semantic_index < 8);
			for (j = 0; j < 4; j++) {
				LLVMValueRef ptr = ctx->soa.outputs[i][j];
				LLVMValueRef result = LLVMBuildLoad(builder, ptr, "");
				color[semantic_index][j] = result;
			}
			break;
		case TGSI_SEMANTIC_POSITION:
			depth = LLVMBuildLoad(builder,
					      ctx->soa.outputs[i][2], "");
			break;
		case TGSI_SEMANTIC_STENCIL:
			stencil = LLVMBuildLoad(builder,
						ctx->soa.outputs[i][1], "");
			break;
		case TGSI_SEMANTIC_SAMPLEMASK:
			samplemask = LLVMBuildLoad(builder,
						   ctx->soa.outputs[i][0], "");
			break;
		default:
			fprintf(stderr, "Warning: SI unhandled fs output type:%d\n",
				semantic_name);
		}
	}

	/* Fill the return structure. */
	ret = ctx->return_value;

	/* Set SGPRs. */
	ret = LLVMBuildInsertValue(builder, ret,
				   bitcast(bld_base, TGSI_TYPE_SIGNED,
					   LLVMGetParam(ctx->main_fn,
							SI_PARAM_ALPHA_REF)),
				   SI_SGPR_ALPHA_REF, "");

	/* Set VGPRs */
	first_vgpr = vgpr = SI_SGPR_ALPHA_REF + 1;
	for (i = 0; i < ARRAY_SIZE(color); i++) {
		if (!color[i][0])
			continue;

		for (j = 0; j < 4; j++)
			ret = LLVMBuildInsertValue(builder, ret, color[i][j], vgpr++, "");
	}
	if (depth)
		ret = LLVMBuildInsertValue(builder, ret, depth, vgpr++, "");
	if (stencil)
		ret = LLVMBuildInsertValue(builder, ret, stencil, vgpr++, "");
	if (samplemask)
		ret = LLVMBuildInsertValue(builder, ret, samplemask, vgpr++, "");

	/* Add the input sample mask for smoothing at the end. */
	if (vgpr < first_vgpr + PS_EPILOG_SAMPLEMASK_MIN_LOC)
		vgpr = first_vgpr + PS_EPILOG_SAMPLEMASK_MIN_LOC;
	ret = LLVMBuildInsertValue(builder, ret,
				   LLVMGetParam(ctx->main_fn,
						SI_PARAM_SAMPLE_COVERAGE), vgpr++, "");

	ctx->return_value = ret;
}

/**
 * Given a v8i32 resource descriptor for a buffer, extract the size of the
 * buffer in number of elements and return it as an i32.
 */
static LLVMValueRef get_buffer_size(
	struct lp_build_tgsi_context *bld_base,
	LLVMValueRef descriptor)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	LLVMValueRef size =
		LLVMBuildExtractElement(builder, descriptor,
					lp_build_const_int32(gallivm, 6), "");

	if (ctx->screen->b.chip_class >= VI) {
		/* On VI, the descriptor contains the size in bytes,
		 * but TXQ must return the size in elements.
		 * The stride is always non-zero for resources using TXQ.
		 */
		LLVMValueRef stride =
			LLVMBuildExtractElement(builder, descriptor,
						lp_build_const_int32(gallivm, 5), "");
		stride = LLVMBuildLShr(builder, stride,
				       lp_build_const_int32(gallivm, 16), "");
		stride = LLVMBuildAnd(builder, stride,
				      lp_build_const_int32(gallivm, 0x3FFF), "");

		size = LLVMBuildUDiv(builder, size, stride, "");
	}

	return size;
}

/**
 * Given the i32 or vNi32 \p type, generate the textual name (e.g. for use with
 * intrinsic names).
 */
static void build_type_name_for_intr(
	LLVMTypeRef type,
	char *buf, unsigned bufsize)
{
	LLVMTypeRef elem_type = type;

	assert(bufsize >= 8);

	if (LLVMGetTypeKind(type) == LLVMVectorTypeKind) {
		int ret = snprintf(buf, bufsize, "v%u",
					LLVMGetVectorSize(type));
		if (ret < 0) {
			char *type_name = LLVMPrintTypeToString(type);
			fprintf(stderr, "Error building type name for: %s\n",
				type_name);
			return;
		}
		elem_type = LLVMGetElementType(type);
		buf += ret;
		bufsize -= ret;
	}
	switch (LLVMGetTypeKind(elem_type)) {
	default: break;
	case LLVMIntegerTypeKind:
		snprintf(buf, bufsize, "i%d", LLVMGetIntTypeWidth(elem_type));
		break;
	case LLVMFloatTypeKind:
		snprintf(buf, bufsize, "f32");
		break;
	case LLVMDoubleTypeKind:
		snprintf(buf, bufsize, "f64");
		break;
	}
}

static void build_tex_intrinsic(const struct lp_build_tgsi_action *action,
				struct lp_build_tgsi_context *bld_base,
				struct lp_build_emit_data *emit_data);

/* Prevent optimizations (at least of memory accesses) across the current
 * point in the program by emitting empty inline assembly that is marked as
 * having side effects.
 */
#if 0 /* unused currently */
static void emit_optimization_barrier(struct si_shader_context *ctx)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMTypeRef ftype = LLVMFunctionType(ctx->voidt, NULL, 0, false);
	LLVMValueRef inlineasm = LLVMConstInlineAsm(ftype, "", "", true, false);
	LLVMBuildCall(builder, inlineasm, NULL, 0, "");
}
#endif

/* Combine these with & instead of |. */
#define NOOP_WAITCNT 0xf7f
#define LGKM_CNT 0x07f
#define VM_CNT 0xf70

static void emit_waitcnt(struct si_shader_context *ctx, unsigned simm16)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	LLVMValueRef args[1] = {
		lp_build_const_int32(gallivm, simm16)
	};
	lp_build_intrinsic(builder, "llvm.amdgcn.s.waitcnt",
			   ctx->voidt, args, 1, 0);
}

static void membar_emit(
		const struct lp_build_tgsi_action *action,
		struct lp_build_tgsi_context *bld_base,
		struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	LLVMValueRef src0 = lp_build_emit_fetch(bld_base, emit_data->inst, 0, 0);
	unsigned flags = LLVMConstIntGetZExtValue(src0);
	unsigned waitcnt = NOOP_WAITCNT;

	if (flags & TGSI_MEMBAR_THREAD_GROUP)
		waitcnt &= VM_CNT & LGKM_CNT;

	if (flags & (TGSI_MEMBAR_ATOMIC_BUFFER |
		     TGSI_MEMBAR_SHADER_BUFFER |
		     TGSI_MEMBAR_SHADER_IMAGE))
		waitcnt &= VM_CNT;

	if (flags & TGSI_MEMBAR_SHARED)
		waitcnt &= LGKM_CNT;

	if (waitcnt != NOOP_WAITCNT)
		emit_waitcnt(ctx, waitcnt);
}

static LLVMValueRef
shader_buffer_fetch_rsrc(struct si_shader_context *ctx,
			 const struct tgsi_full_src_register *reg)
{
	LLVMValueRef index;
	LLVMValueRef rsrc_ptr = LLVMGetParam(ctx->main_fn,
					     SI_PARAM_SHADER_BUFFERS);

	if (!reg->Register.Indirect)
		index = LLVMConstInt(ctx->i32, reg->Register.Index, 0);
	else
		index = get_bounded_indirect_index(ctx, &reg->Indirect,
						   reg->Register.Index,
						   SI_NUM_SHADER_BUFFERS);

	return build_indexed_load_const(ctx, rsrc_ptr, index);
}

static bool tgsi_is_array_sampler(unsigned target)
{
	return target == TGSI_TEXTURE_1D_ARRAY ||
	       target == TGSI_TEXTURE_SHADOW1D_ARRAY ||
	       target == TGSI_TEXTURE_2D_ARRAY ||
	       target == TGSI_TEXTURE_SHADOW2D_ARRAY ||
	       target == TGSI_TEXTURE_CUBE_ARRAY ||
	       target == TGSI_TEXTURE_SHADOWCUBE_ARRAY ||
	       target == TGSI_TEXTURE_2D_ARRAY_MSAA;
}

static bool tgsi_is_array_image(unsigned target)
{
	return target == TGSI_TEXTURE_3D ||
	       target == TGSI_TEXTURE_CUBE ||
	       target == TGSI_TEXTURE_1D_ARRAY ||
	       target == TGSI_TEXTURE_2D_ARRAY ||
	       target == TGSI_TEXTURE_CUBE_ARRAY ||
	       target == TGSI_TEXTURE_2D_ARRAY_MSAA;
}

/**
 * Given a 256-bit resource descriptor, force the DCC enable bit to off.
 *
 * At least on Tonga, executing image stores on images with DCC enabled and
 * non-trivial can eventually lead to lockups. This can occur when an
 * application binds an image as read-only but then uses a shader that writes
 * to it. The OpenGL spec allows almost arbitrarily bad behavior (including
 * program termination) in this case, but it doesn't cost much to be a bit
 * nicer: disabling DCC in the shader still leads to undefined results but
 * avoids the lockup.
 */
static LLVMValueRef force_dcc_off(struct si_shader_context *ctx,
				  LLVMValueRef rsrc)
{
	if (ctx->screen->b.chip_class <= CIK) {
		return rsrc;
	} else {
		LLVMBuilderRef builder = ctx->gallivm.builder;
		LLVMValueRef i32_6 = LLVMConstInt(ctx->i32, 6, 0);
		LLVMValueRef i32_C = LLVMConstInt(ctx->i32, C_008F28_COMPRESSION_EN, 0);
		LLVMValueRef tmp;

		tmp = LLVMBuildExtractElement(builder, rsrc, i32_6, "");
		tmp = LLVMBuildAnd(builder, tmp, i32_C, "");
		return LLVMBuildInsertElement(builder, rsrc, tmp, i32_6, "");
	}
}

/**
 * Load the resource descriptor for \p image.
 */
static void
image_fetch_rsrc(
	struct lp_build_tgsi_context *bld_base,
	const struct tgsi_full_src_register *image,
	bool dcc_off,
	LLVMValueRef *rsrc)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	LLVMValueRef rsrc_ptr = LLVMGetParam(ctx->main_fn,
					     SI_PARAM_IMAGES);
	LLVMValueRef index, tmp;

	assert(image->Register.File == TGSI_FILE_IMAGE);

	if (!image->Register.Indirect) {
		const struct tgsi_shader_info *info = bld_base->info;

		index = LLVMConstInt(ctx->i32, image->Register.Index, 0);

		if (info->images_writemask & (1 << image->Register.Index) &&
		    !(info->images_buffers & (1 << image->Register.Index)))
			dcc_off = true;
	} else {
		/* From the GL_ARB_shader_image_load_store extension spec:
		 *
		 *    If a shader performs an image load, store, or atomic
		 *    operation using an image variable declared as an array,
		 *    and if the index used to select an individual element is
		 *    negative or greater than or equal to the size of the
		 *    array, the results of the operation are undefined but may
		 *    not lead to termination.
		 */
		index = get_bounded_indirect_index(ctx, &image->Indirect,
						   image->Register.Index,
						   SI_NUM_IMAGES);
	}

	tmp = build_indexed_load_const(ctx, rsrc_ptr, index);
	if (dcc_off)
		tmp = force_dcc_off(ctx, tmp);
	*rsrc = tmp;
}

static LLVMValueRef image_fetch_coords(
		struct lp_build_tgsi_context *bld_base,
		const struct tgsi_full_instruction *inst,
		unsigned src)
{
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	unsigned target = inst->Memory.Texture;
	unsigned num_coords = tgsi_util_get_texture_coord_dim(target);
	LLVMValueRef coords[4];
	LLVMValueRef tmp;
	int chan;

	for (chan = 0; chan < num_coords; ++chan) {
		tmp = lp_build_emit_fetch(bld_base, inst, src, chan);
		tmp = LLVMBuildBitCast(builder, tmp, bld_base->uint_bld.elem_type, "");
		coords[chan] = tmp;
	}

	if (num_coords == 1)
		return coords[0];

	if (num_coords == 3) {
		/* LLVM has difficulties lowering 3-element vectors. */
		coords[3] = bld_base->uint_bld.undef;
		num_coords = 4;
	}

	return lp_build_gather_values(gallivm, coords, num_coords);
}

/**
 * Append the extra mode bits that are used by image load and store.
 */
static void image_append_args(
		struct si_shader_context *ctx,
		struct lp_build_emit_data * emit_data,
		unsigned target,
		bool atomic,
		bool force_glc)
{
	const struct tgsi_full_instruction *inst = emit_data->inst;
	LLVMValueRef i1false = LLVMConstInt(ctx->i1, 0, 0);
	LLVMValueRef i1true = LLVMConstInt(ctx->i1, 1, 0);
	LLVMValueRef r128 = i1false;
	LLVMValueRef da = tgsi_is_array_image(target) ? i1true : i1false;
	LLVMValueRef glc =
		force_glc ||
		inst->Memory.Qualifier & (TGSI_MEMORY_COHERENT | TGSI_MEMORY_VOLATILE) ?
		i1true : i1false;
	LLVMValueRef slc = i1false;
	LLVMValueRef lwe = i1false;

	if (atomic || (HAVE_LLVM <= 0x0309)) {
		emit_data->args[emit_data->arg_count++] = r128;
		emit_data->args[emit_data->arg_count++] = da;
		if (!atomic) {
			emit_data->args[emit_data->arg_count++] = glc;
		}
		emit_data->args[emit_data->arg_count++] = slc;
		return;
	}

	/* HAVE_LLVM >= 0x0400 */
	emit_data->args[emit_data->arg_count++] = glc;
	emit_data->args[emit_data->arg_count++] = slc;
	emit_data->args[emit_data->arg_count++] = lwe;
	emit_data->args[emit_data->arg_count++] = da;
}

/**
 * Given a 256 bit resource, extract the top half (which stores the buffer
 * resource in the case of textures and images).
 */
static LLVMValueRef extract_rsrc_top_half(
		struct si_shader_context *ctx,
		LLVMValueRef rsrc)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx->soa.bld_base;
	LLVMTypeRef v2i128 = LLVMVectorType(ctx->i128, 2);

	rsrc = LLVMBuildBitCast(gallivm->builder, rsrc, v2i128, "");
	rsrc = LLVMBuildExtractElement(gallivm->builder, rsrc, bld_base->uint_bld.one, "");
	rsrc = LLVMBuildBitCast(gallivm->builder, rsrc, ctx->v4i32, "");

	return rsrc;
}

/**
 * Append the resource and indexing arguments for buffer intrinsics.
 *
 * \param rsrc the v4i32 buffer resource
 * \param index index into the buffer (stride-based)
 * \param offset byte offset into the buffer
 */
static void buffer_append_args(
		struct si_shader_context *ctx,
		struct lp_build_emit_data *emit_data,
		LLVMValueRef rsrc,
		LLVMValueRef index,
		LLVMValueRef offset,
		bool atomic,
		bool force_glc)
{
	const struct tgsi_full_instruction *inst = emit_data->inst;
	LLVMValueRef i1false = LLVMConstInt(ctx->i1, 0, 0);
	LLVMValueRef i1true = LLVMConstInt(ctx->i1, 1, 0);

	emit_data->args[emit_data->arg_count++] = rsrc;
	emit_data->args[emit_data->arg_count++] = index; /* vindex */
	emit_data->args[emit_data->arg_count++] = offset; /* voffset */
	if (!atomic) {
		emit_data->args[emit_data->arg_count++] =
			force_glc ||
			inst->Memory.Qualifier & (TGSI_MEMORY_COHERENT | TGSI_MEMORY_VOLATILE) ?
			i1true : i1false; /* glc */
	}
	emit_data->args[emit_data->arg_count++] = i1false; /* slc */
}

static void load_fetch_args(
		struct lp_build_tgsi_context * bld_base,
		struct lp_build_emit_data * emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	unsigned target = inst->Memory.Texture;
	LLVMValueRef rsrc;

	emit_data->dst_type = LLVMVectorType(bld_base->base.elem_type, 4);

	if (inst->Src[0].Register.File == TGSI_FILE_BUFFER) {
		LLVMBuilderRef builder = gallivm->builder;
		LLVMValueRef offset;
		LLVMValueRef tmp;

		rsrc = shader_buffer_fetch_rsrc(ctx, &inst->Src[0]);

		tmp = lp_build_emit_fetch(bld_base, inst, 1, 0);
		offset = LLVMBuildBitCast(builder, tmp, bld_base->uint_bld.elem_type, "");

		buffer_append_args(ctx, emit_data, rsrc, bld_base->uint_bld.zero,
				   offset, false, false);
	} else if (inst->Src[0].Register.File == TGSI_FILE_IMAGE) {
		LLVMValueRef coords;

		image_fetch_rsrc(bld_base, &inst->Src[0], false, &rsrc);
		coords = image_fetch_coords(bld_base, inst, 1);

		if (target == TGSI_TEXTURE_BUFFER) {
			rsrc = extract_rsrc_top_half(ctx, rsrc);
			buffer_append_args(ctx, emit_data, rsrc, coords,
					   bld_base->uint_bld.zero, false, false);
		} else {
			emit_data->args[0] = coords;
			emit_data->args[1] = rsrc;
			emit_data->args[2] = lp_build_const_int32(gallivm, 15); /* dmask */
			emit_data->arg_count = 3;

			image_append_args(ctx, emit_data, target, false, false);
		}
	}
}

static void load_emit_buffer(struct si_shader_context *ctx,
			     struct lp_build_emit_data *emit_data)
{
	const struct tgsi_full_instruction *inst = emit_data->inst;
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	uint writemask = inst->Dst[0].Register.WriteMask;
	uint count = util_last_bit(writemask);
	const char *intrinsic_name;
	LLVMTypeRef dst_type;

	switch (count) {
	case 1:
		intrinsic_name = "llvm.amdgcn.buffer.load.f32";
		dst_type = ctx->f32;
		break;
	case 2:
		intrinsic_name = "llvm.amdgcn.buffer.load.v2f32";
		dst_type = LLVMVectorType(ctx->f32, 2);
		break;
	default: // 3 & 4
		intrinsic_name = "llvm.amdgcn.buffer.load.v4f32";
		dst_type = ctx->v4f32;
		count = 4;
	}

	emit_data->output[emit_data->chan] = lp_build_intrinsic(
			builder, intrinsic_name, dst_type,
			emit_data->args, emit_data->arg_count,
			LLVMReadOnlyAttribute);
}

static LLVMValueRef get_memory_ptr(struct si_shader_context *ctx,
                                   const struct tgsi_full_instruction *inst,
                                   LLVMTypeRef type, int arg)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	LLVMValueRef offset, ptr;
	int addr_space;

	offset = lp_build_emit_fetch(&ctx->soa.bld_base, inst, arg, 0);
	offset = LLVMBuildBitCast(builder, offset, ctx->i32, "");

	ptr = ctx->shared_memory;
	ptr = LLVMBuildGEP(builder, ptr, &offset, 1, "");
	addr_space = LLVMGetPointerAddressSpace(LLVMTypeOf(ptr));
	ptr = LLVMBuildBitCast(builder, ptr, LLVMPointerType(type, addr_space), "");

	return ptr;
}

static void load_emit_memory(
		struct si_shader_context *ctx,
		struct lp_build_emit_data *emit_data)
{
	const struct tgsi_full_instruction *inst = emit_data->inst;
	struct lp_build_context *base = &ctx->soa.bld_base.base;
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	unsigned writemask = inst->Dst[0].Register.WriteMask;
	LLVMValueRef channels[4], ptr, derived_ptr, index;
	int chan;

	ptr = get_memory_ptr(ctx, inst, base->elem_type, 1);

	for (chan = 0; chan < 4; ++chan) {
		if (!(writemask & (1 << chan))) {
			channels[chan] = LLVMGetUndef(base->elem_type);
			continue;
		}

		index = lp_build_const_int32(gallivm, chan);
		derived_ptr = LLVMBuildGEP(builder, ptr, &index, 1, "");
		channels[chan] = LLVMBuildLoad(builder, derived_ptr, "");
	}
	emit_data->output[emit_data->chan] = lp_build_gather_values(gallivm, channels, 4);
}

static void get_image_intr_name(const char *base_name,
				LLVMTypeRef data_type,
				LLVMTypeRef coords_type,
				LLVMTypeRef rsrc_type,
				char *out_name, unsigned out_len)
{
	char coords_type_name[8];

	build_type_name_for_intr(coords_type, coords_type_name,
			    sizeof(coords_type_name));

	if (HAVE_LLVM <= 0x0309) {
		snprintf(out_name, out_len, "%s.%s", base_name, coords_type_name);
	} else {
		char data_type_name[8];
		char rsrc_type_name[8];

		build_type_name_for_intr(data_type, data_type_name,
					sizeof(data_type_name));
		build_type_name_for_intr(rsrc_type, rsrc_type_name,
					sizeof(rsrc_type_name));
		snprintf(out_name, out_len, "%s.%s.%s.%s", base_name,
			 data_type_name, coords_type_name, rsrc_type_name);
	}
}

static void load_emit(
		const struct lp_build_tgsi_action *action,
		struct lp_build_tgsi_context *bld_base,
		struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	char intrinsic_name[64];

	if (inst->Src[0].Register.File == TGSI_FILE_MEMORY) {
		load_emit_memory(ctx, emit_data);
		return;
	}

	if (inst->Memory.Qualifier & TGSI_MEMORY_VOLATILE)
		emit_waitcnt(ctx, VM_CNT);

	if (inst->Src[0].Register.File == TGSI_FILE_BUFFER) {
		load_emit_buffer(ctx, emit_data);
		return;
	}

	if (inst->Memory.Texture == TGSI_TEXTURE_BUFFER) {
		emit_data->output[emit_data->chan] =
			lp_build_intrinsic(
				builder, "llvm.amdgcn.buffer.load.format.v4f32", emit_data->dst_type,
				emit_data->args, emit_data->arg_count,
				LLVMReadOnlyAttribute);
	} else {
		get_image_intr_name("llvm.amdgcn.image.load",
				emit_data->dst_type,		/* vdata */
				LLVMTypeOf(emit_data->args[0]), /* coords */
				LLVMTypeOf(emit_data->args[1]), /* rsrc */
				intrinsic_name, sizeof(intrinsic_name));

		emit_data->output[emit_data->chan] =
			lp_build_intrinsic(
				builder, intrinsic_name, emit_data->dst_type,
				emit_data->args, emit_data->arg_count,
				LLVMReadOnlyAttribute);
	}
}

static void store_fetch_args(
		struct lp_build_tgsi_context * bld_base,
		struct lp_build_emit_data * emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	struct tgsi_full_src_register memory;
	LLVMValueRef chans[4];
	LLVMValueRef data;
	LLVMValueRef rsrc;
	unsigned chan;

	emit_data->dst_type = LLVMVoidTypeInContext(gallivm->context);

	for (chan = 0; chan < 4; ++chan) {
		chans[chan] = lp_build_emit_fetch(bld_base, inst, 1, chan);
	}
	data = lp_build_gather_values(gallivm, chans, 4);

	emit_data->args[emit_data->arg_count++] = data;

	memory = tgsi_full_src_register_from_dst(&inst->Dst[0]);

	if (inst->Dst[0].Register.File == TGSI_FILE_BUFFER) {
		LLVMValueRef offset;
		LLVMValueRef tmp;

		rsrc = shader_buffer_fetch_rsrc(ctx, &memory);

		tmp = lp_build_emit_fetch(bld_base, inst, 0, 0);
		offset = LLVMBuildBitCast(builder, tmp, bld_base->uint_bld.elem_type, "");

		buffer_append_args(ctx, emit_data, rsrc, bld_base->uint_bld.zero,
				   offset, false, false);
	} else if (inst->Dst[0].Register.File == TGSI_FILE_IMAGE) {
		unsigned target = inst->Memory.Texture;
		LLVMValueRef coords;

		/* 8bit/16bit TC L1 write corruption bug on SI.
		 * All store opcodes not aligned to a dword are affected.
		 *
		 * The only way to get unaligned stores in radeonsi is through
		 * shader images.
		 */
		bool force_glc = ctx->screen->b.chip_class == SI;

		coords = image_fetch_coords(bld_base, inst, 0);

		if (target == TGSI_TEXTURE_BUFFER) {
			image_fetch_rsrc(bld_base, &memory, false, &rsrc);

			rsrc = extract_rsrc_top_half(ctx, rsrc);
			buffer_append_args(ctx, emit_data, rsrc, coords,
					   bld_base->uint_bld.zero, false, force_glc);
		} else {
			emit_data->args[1] = coords;
			image_fetch_rsrc(bld_base, &memory, true, &emit_data->args[2]);
			emit_data->args[3] = lp_build_const_int32(gallivm, 15); /* dmask */
			emit_data->arg_count = 4;

			image_append_args(ctx, emit_data, target, false, force_glc);
		}
	}
}

static void store_emit_buffer(
		struct si_shader_context *ctx,
		struct lp_build_emit_data *emit_data)
{
	const struct tgsi_full_instruction *inst = emit_data->inst;
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	struct lp_build_context *uint_bld = &ctx->soa.bld_base.uint_bld;
	LLVMValueRef base_data = emit_data->args[0];
	LLVMValueRef base_offset = emit_data->args[3];
	unsigned writemask = inst->Dst[0].Register.WriteMask;

	while (writemask) {
		int start, count;
		const char *intrinsic_name;
		LLVMValueRef data;
		LLVMValueRef offset;
		LLVMValueRef tmp;

		u_bit_scan_consecutive_range(&writemask, &start, &count);

		/* Due to an LLVM limitation, split 3-element writes
		 * into a 2-element and a 1-element write. */
		if (count == 3) {
			writemask |= 1 << (start + 2);
			count = 2;
		}

		if (count == 4) {
			data = base_data;
			intrinsic_name = "llvm.amdgcn.buffer.store.v4f32";
		} else if (count == 2) {
			LLVMTypeRef v2f32 = LLVMVectorType(ctx->f32, 2);

			tmp = LLVMBuildExtractElement(
				builder, base_data,
				lp_build_const_int32(gallivm, start), "");
			data = LLVMBuildInsertElement(
				builder, LLVMGetUndef(v2f32), tmp,
				uint_bld->zero, "");

			tmp = LLVMBuildExtractElement(
				builder, base_data,
				lp_build_const_int32(gallivm, start + 1), "");
			data = LLVMBuildInsertElement(
				builder, data, tmp, uint_bld->one, "");

			intrinsic_name = "llvm.amdgcn.buffer.store.v2f32";
		} else {
			assert(count == 1);
			data = LLVMBuildExtractElement(
				builder, base_data,
				lp_build_const_int32(gallivm, start), "");
			intrinsic_name = "llvm.amdgcn.buffer.store.f32";
		}

		offset = base_offset;
		if (start != 0) {
			offset = LLVMBuildAdd(
				builder, offset,
				lp_build_const_int32(gallivm, start * 4), "");
		}

		emit_data->args[0] = data;
		emit_data->args[3] = offset;

		lp_build_intrinsic(
			builder, intrinsic_name, emit_data->dst_type,
			emit_data->args, emit_data->arg_count, 0);
	}
}

static void store_emit_memory(
		struct si_shader_context *ctx,
		struct lp_build_emit_data *emit_data)
{
	const struct tgsi_full_instruction *inst = emit_data->inst;
	struct gallivm_state *gallivm = &ctx->gallivm;
	struct lp_build_context *base = &ctx->soa.bld_base.base;
	LLVMBuilderRef builder = gallivm->builder;
	unsigned writemask = inst->Dst[0].Register.WriteMask;
	LLVMValueRef ptr, derived_ptr, data, index;
	int chan;

	ptr = get_memory_ptr(ctx, inst, base->elem_type, 0);

	for (chan = 0; chan < 4; ++chan) {
		if (!(writemask & (1 << chan))) {
			continue;
		}
		data = lp_build_emit_fetch(&ctx->soa.bld_base, inst, 1, chan);
		index = lp_build_const_int32(gallivm, chan);
		derived_ptr = LLVMBuildGEP(builder, ptr, &index, 1, "");
		LLVMBuildStore(builder, data, derived_ptr);
	}
}

static void store_emit(
		const struct lp_build_tgsi_action *action,
		struct lp_build_tgsi_context *bld_base,
		struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	unsigned target = inst->Memory.Texture;
	char intrinsic_name[64];

	if (inst->Dst[0].Register.File == TGSI_FILE_MEMORY) {
		store_emit_memory(ctx, emit_data);
		return;
	}

	if (inst->Memory.Qualifier & TGSI_MEMORY_VOLATILE)
		emit_waitcnt(ctx, VM_CNT);

	if (inst->Dst[0].Register.File == TGSI_FILE_BUFFER) {
		store_emit_buffer(ctx, emit_data);
		return;
	}

	if (target == TGSI_TEXTURE_BUFFER) {
		emit_data->output[emit_data->chan] = lp_build_intrinsic(
			builder, "llvm.amdgcn.buffer.store.format.v4f32",
			emit_data->dst_type, emit_data->args,
			emit_data->arg_count, 0);
	} else {
		get_image_intr_name("llvm.amdgcn.image.store",
				LLVMTypeOf(emit_data->args[0]), /* vdata */
				LLVMTypeOf(emit_data->args[1]), /* coords */
				LLVMTypeOf(emit_data->args[2]), /* rsrc */
				intrinsic_name, sizeof(intrinsic_name));

		emit_data->output[emit_data->chan] =
			lp_build_intrinsic(
				builder, intrinsic_name, emit_data->dst_type,
				emit_data->args, emit_data->arg_count, 0);
	}
}

static void atomic_fetch_args(
		struct lp_build_tgsi_context * bld_base,
		struct lp_build_emit_data * emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	LLVMValueRef data1, data2;
	LLVMValueRef rsrc;
	LLVMValueRef tmp;

	emit_data->dst_type = bld_base->base.elem_type;

	tmp = lp_build_emit_fetch(bld_base, inst, 2, 0);
	data1 = LLVMBuildBitCast(builder, tmp, bld_base->uint_bld.elem_type, "");

	if (inst->Instruction.Opcode == TGSI_OPCODE_ATOMCAS) {
		tmp = lp_build_emit_fetch(bld_base, inst, 3, 0);
		data2 = LLVMBuildBitCast(builder, tmp, bld_base->uint_bld.elem_type, "");
	}

	/* llvm.amdgcn.image/buffer.atomic.cmpswap reflect the hardware order
	 * of arguments, which is reversed relative to TGSI (and GLSL)
	 */
	if (inst->Instruction.Opcode == TGSI_OPCODE_ATOMCAS)
		emit_data->args[emit_data->arg_count++] = data2;
	emit_data->args[emit_data->arg_count++] = data1;

	if (inst->Src[0].Register.File == TGSI_FILE_BUFFER) {
		LLVMValueRef offset;

		rsrc = shader_buffer_fetch_rsrc(ctx, &inst->Src[0]);

		tmp = lp_build_emit_fetch(bld_base, inst, 1, 0);
		offset = LLVMBuildBitCast(builder, tmp, bld_base->uint_bld.elem_type, "");

		buffer_append_args(ctx, emit_data, rsrc, bld_base->uint_bld.zero,
				   offset, true, false);
	} else if (inst->Src[0].Register.File == TGSI_FILE_IMAGE) {
		unsigned target = inst->Memory.Texture;
		LLVMValueRef coords;

		image_fetch_rsrc(bld_base, &inst->Src[0],
				 target != TGSI_TEXTURE_BUFFER, &rsrc);
		coords = image_fetch_coords(bld_base, inst, 1);

		if (target == TGSI_TEXTURE_BUFFER) {
			rsrc = extract_rsrc_top_half(ctx, rsrc);
			buffer_append_args(ctx, emit_data, rsrc, coords,
					   bld_base->uint_bld.zero, true, false);
		} else {
			emit_data->args[emit_data->arg_count++] = coords;
			emit_data->args[emit_data->arg_count++] = rsrc;

			image_append_args(ctx, emit_data, target, true, false);
		}
	}
}

static void atomic_emit_memory(struct si_shader_context *ctx,
                               struct lp_build_emit_data *emit_data) {
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	LLVMValueRef ptr, result, arg;

	ptr = get_memory_ptr(ctx, inst, ctx->i32, 1);

	arg = lp_build_emit_fetch(&ctx->soa.bld_base, inst, 2, 0);
	arg = LLVMBuildBitCast(builder, arg, ctx->i32, "");

	if (inst->Instruction.Opcode == TGSI_OPCODE_ATOMCAS) {
		LLVMValueRef new_data;
		new_data = lp_build_emit_fetch(&ctx->soa.bld_base,
		                               inst, 3, 0);

		new_data = LLVMBuildBitCast(builder, new_data, ctx->i32, "");

#if HAVE_LLVM >= 0x309
		result = LLVMBuildAtomicCmpXchg(builder, ptr, arg, new_data,
		                       LLVMAtomicOrderingSequentiallyConsistent,
		                       LLVMAtomicOrderingSequentiallyConsistent,
		                       false);
#endif

		result = LLVMBuildExtractValue(builder, result, 0, "");
	} else {
		LLVMAtomicRMWBinOp op;

		switch(inst->Instruction.Opcode) {
			case TGSI_OPCODE_ATOMUADD:
				op = LLVMAtomicRMWBinOpAdd;
				break;
			case TGSI_OPCODE_ATOMXCHG:
				op = LLVMAtomicRMWBinOpXchg;
				break;
			case TGSI_OPCODE_ATOMAND:
				op = LLVMAtomicRMWBinOpAnd;
				break;
			case TGSI_OPCODE_ATOMOR:
				op = LLVMAtomicRMWBinOpOr;
				break;
			case TGSI_OPCODE_ATOMXOR:
				op = LLVMAtomicRMWBinOpXor;
				break;
			case TGSI_OPCODE_ATOMUMIN:
				op = LLVMAtomicRMWBinOpUMin;
				break;
			case TGSI_OPCODE_ATOMUMAX:
				op = LLVMAtomicRMWBinOpUMax;
				break;
			case TGSI_OPCODE_ATOMIMIN:
				op = LLVMAtomicRMWBinOpMin;
				break;
			case TGSI_OPCODE_ATOMIMAX:
				op = LLVMAtomicRMWBinOpMax;
				break;
			default:
				unreachable("unknown atomic opcode");
		}

		result = LLVMBuildAtomicRMW(builder, op, ptr, arg,
		                       LLVMAtomicOrderingSequentiallyConsistent,
		                       false);
	}
	emit_data->output[emit_data->chan] = LLVMBuildBitCast(builder, result, emit_data->dst_type, "");
}

static void atomic_emit(
		const struct lp_build_tgsi_action *action,
		struct lp_build_tgsi_context *bld_base,
		struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	char intrinsic_name[40];
	LLVMValueRef tmp;

	if (inst->Src[0].Register.File == TGSI_FILE_MEMORY) {
		atomic_emit_memory(ctx, emit_data);
		return;
	}

	if (inst->Src[0].Register.File == TGSI_FILE_BUFFER ||
	    inst->Memory.Texture == TGSI_TEXTURE_BUFFER) {
		snprintf(intrinsic_name, sizeof(intrinsic_name),
			 "llvm.amdgcn.buffer.atomic.%s", action->intr_name);
	} else {
		LLVMValueRef coords;
		char coords_type[8];

		if (inst->Instruction.Opcode == TGSI_OPCODE_ATOMCAS)
			coords = emit_data->args[2];
		else
			coords = emit_data->args[1];

		build_type_name_for_intr(LLVMTypeOf(coords), coords_type, sizeof(coords_type));
		snprintf(intrinsic_name, sizeof(intrinsic_name),
			 "llvm.amdgcn.image.atomic.%s.%s",
			 action->intr_name, coords_type);
	}

	tmp = lp_build_intrinsic(
		builder, intrinsic_name, bld_base->uint_bld.elem_type,
		emit_data->args, emit_data->arg_count, 0);
	emit_data->output[emit_data->chan] =
		LLVMBuildBitCast(builder, tmp, bld_base->base.elem_type, "");
}

static void resq_fetch_args(
		struct lp_build_tgsi_context * bld_base,
		struct lp_build_emit_data * emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	const struct tgsi_full_instruction *inst = emit_data->inst;
	const struct tgsi_full_src_register *reg = &inst->Src[0];

	emit_data->dst_type = ctx->v4i32;

	if (reg->Register.File == TGSI_FILE_BUFFER) {
		emit_data->args[0] = shader_buffer_fetch_rsrc(ctx, reg);
		emit_data->arg_count = 1;
	} else if (inst->Memory.Texture == TGSI_TEXTURE_BUFFER) {
		image_fetch_rsrc(bld_base, reg, false, &emit_data->args[0]);
		emit_data->arg_count = 1;
	} else {
		emit_data->args[0] = bld_base->uint_bld.zero; /* mip level */
		image_fetch_rsrc(bld_base, reg, false, &emit_data->args[1]);
		emit_data->args[2] = lp_build_const_int32(gallivm, 15); /* dmask */
		emit_data->args[3] = bld_base->uint_bld.zero; /* unorm */
		emit_data->args[4] = bld_base->uint_bld.zero; /* r128 */
		emit_data->args[5] = tgsi_is_array_image(inst->Memory.Texture) ?
			bld_base->uint_bld.one : bld_base->uint_bld.zero; /* da */
		emit_data->args[6] = bld_base->uint_bld.zero; /* glc */
		emit_data->args[7] = bld_base->uint_bld.zero; /* slc */
		emit_data->args[8] = bld_base->uint_bld.zero; /* tfe */
		emit_data->args[9] = bld_base->uint_bld.zero; /* lwe */
		emit_data->arg_count = 10;
	}
}

static void resq_emit(
		const struct lp_build_tgsi_action *action,
		struct lp_build_tgsi_context *bld_base,
		struct lp_build_emit_data *emit_data)
{
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction *inst = emit_data->inst;
	LLVMValueRef out;

	if (inst->Src[0].Register.File == TGSI_FILE_BUFFER) {
		out = LLVMBuildExtractElement(builder, emit_data->args[0],
					      lp_build_const_int32(gallivm, 2), "");
	} else if (inst->Memory.Texture == TGSI_TEXTURE_BUFFER) {
		out = get_buffer_size(bld_base, emit_data->args[0]);
	} else {
		out = lp_build_intrinsic(
			builder, "llvm.SI.getresinfo.i32", emit_data->dst_type,
			emit_data->args, emit_data->arg_count,
			LLVMReadNoneAttribute);

		/* Divide the number of layers by 6 to get the number of cubes. */
		if (inst->Memory.Texture == TGSI_TEXTURE_CUBE_ARRAY) {
			LLVMValueRef imm2 = lp_build_const_int32(gallivm, 2);
			LLVMValueRef imm6 = lp_build_const_int32(gallivm, 6);

			LLVMValueRef z = LLVMBuildExtractElement(builder, out, imm2, "");
			z = LLVMBuildSDiv(builder, z, imm6, "");
			out = LLVMBuildInsertElement(builder, out, z, imm2, "");
		}
	}

	emit_data->output[emit_data->chan] = out;
}

static void set_tex_fetch_args(struct si_shader_context *ctx,
			       struct lp_build_emit_data *emit_data,
			       unsigned opcode, unsigned target,
			       LLVMValueRef res_ptr, LLVMValueRef samp_ptr,
			       LLVMValueRef *param, unsigned count,
			       unsigned dmask)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	unsigned num_args;
	unsigned is_rect = target == TGSI_TEXTURE_RECT;

	/* Pad to power of two vector */
	while (count < util_next_power_of_two(count))
		param[count++] = LLVMGetUndef(ctx->i32);

	/* Texture coordinates. */
	if (count > 1)
		emit_data->args[0] = lp_build_gather_values(gallivm, param, count);
	else
		emit_data->args[0] = param[0];

	/* Resource. */
	emit_data->args[1] = res_ptr;
	num_args = 2;

	if (opcode == TGSI_OPCODE_TXF || opcode == TGSI_OPCODE_TXQ)
		emit_data->dst_type = ctx->v4i32;
	else {
		emit_data->dst_type = ctx->v4f32;

		emit_data->args[num_args++] = samp_ptr;
	}

	emit_data->args[num_args++] = lp_build_const_int32(gallivm, dmask);
	emit_data->args[num_args++] = lp_build_const_int32(gallivm, is_rect); /* unorm */
	emit_data->args[num_args++] = lp_build_const_int32(gallivm, 0); /* r128 */
	emit_data->args[num_args++] = lp_build_const_int32(gallivm,
					tgsi_is_array_sampler(target)); /* da */
	emit_data->args[num_args++] = lp_build_const_int32(gallivm, 0); /* glc */
	emit_data->args[num_args++] = lp_build_const_int32(gallivm, 0); /* slc */
	emit_data->args[num_args++] = lp_build_const_int32(gallivm, 0); /* tfe */
	emit_data->args[num_args++] = lp_build_const_int32(gallivm, 0); /* lwe */

	emit_data->arg_count = num_args;
}

static const struct lp_build_tgsi_action tex_action;

enum desc_type {
	DESC_IMAGE,
	DESC_FMASK,
	DESC_SAMPLER
};

static LLVMTypeRef const_array(LLVMTypeRef elem_type, int num_elements)
{
	return LLVMPointerType(LLVMArrayType(elem_type, num_elements),
			       CONST_ADDR_SPACE);
}

/**
 * Load an image view, fmask view. or sampler state descriptor.
 */
static LLVMValueRef load_sampler_desc_custom(struct si_shader_context *ctx,
					     LLVMValueRef list, LLVMValueRef index,
					     enum desc_type type)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;

	switch (type) {
	case DESC_IMAGE:
		/* The image is at [0:7]. */
		index = LLVMBuildMul(builder, index, LLVMConstInt(ctx->i32, 2, 0), "");
		break;
	case DESC_FMASK:
		/* The FMASK is at [8:15]. */
		index = LLVMBuildMul(builder, index, LLVMConstInt(ctx->i32, 2, 0), "");
		index = LLVMBuildAdd(builder, index, LLVMConstInt(ctx->i32, 1, 0), "");
		break;
	case DESC_SAMPLER:
		/* The sampler state is at [12:15]. */
		index = LLVMBuildMul(builder, index, LLVMConstInt(ctx->i32, 4, 0), "");
		index = LLVMBuildAdd(builder, index, LLVMConstInt(ctx->i32, 3, 0), "");
		list = LLVMBuildPointerCast(builder, list,
					    const_array(ctx->v4i32, 0), "");
		break;
	}

	return build_indexed_load_const(ctx, list, index);
}

static LLVMValueRef load_sampler_desc(struct si_shader_context *ctx,
				     LLVMValueRef index, enum desc_type type)
{
	LLVMValueRef list = LLVMGetParam(ctx->main_fn,
					 SI_PARAM_SAMPLERS);

	return load_sampler_desc_custom(ctx, list, index, type);
}

/* Disable anisotropic filtering if BASE_LEVEL == LAST_LEVEL.
 *
 * SI-CI:
 *   If BASE_LEVEL == LAST_LEVEL, the shader must disable anisotropic
 *   filtering manually. The driver sets img7 to a mask clearing
 *   MAX_ANISO_RATIO if BASE_LEVEL == LAST_LEVEL. The shader must do:
 *     s_and_b32 samp0, samp0, img7
 *
 * VI:
 *   The ANISO_OVERRIDE sampler field enables this fix in TA.
 */
static LLVMValueRef sici_fix_sampler_aniso(struct si_shader_context *ctx,
					   LLVMValueRef res, LLVMValueRef samp)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMValueRef img7, samp0;

	if (ctx->screen->b.chip_class >= VI)
		return samp;

	img7 = LLVMBuildExtractElement(builder, res,
				       LLVMConstInt(ctx->i32, 7, 0), "");
	samp0 = LLVMBuildExtractElement(builder, samp,
					LLVMConstInt(ctx->i32, 0, 0), "");
	samp0 = LLVMBuildAnd(builder, samp0, img7, "");
	return LLVMBuildInsertElement(builder, samp, samp0,
				      LLVMConstInt(ctx->i32, 0, 0), "");
}

static void tex_fetch_ptrs(
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data,
	LLVMValueRef *res_ptr, LLVMValueRef *samp_ptr, LLVMValueRef *fmask_ptr)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	const struct tgsi_full_instruction *inst = emit_data->inst;
	unsigned target = inst->Texture.Texture;
	unsigned sampler_src;
	unsigned sampler_index;
	LLVMValueRef index;

	sampler_src = emit_data->inst->Instruction.NumSrcRegs - 1;
	sampler_index = emit_data->inst->Src[sampler_src].Register.Index;

	if (emit_data->inst->Src[sampler_src].Register.Indirect) {
		const struct tgsi_full_src_register *reg = &emit_data->inst->Src[sampler_src];

		index = get_bounded_indirect_index(ctx,
						   &reg->Indirect,
						   reg->Register.Index,
						   SI_NUM_SAMPLERS);
	} else {
		index = LLVMConstInt(ctx->i32, sampler_index, 0);
	}

	*res_ptr = load_sampler_desc(ctx, index, DESC_IMAGE);

	if (target == TGSI_TEXTURE_2D_MSAA ||
	    target == TGSI_TEXTURE_2D_ARRAY_MSAA) {
		if (samp_ptr)
			*samp_ptr = NULL;
		if (fmask_ptr)
			*fmask_ptr = load_sampler_desc(ctx, index, DESC_FMASK);
	} else {
		if (samp_ptr) {
			*samp_ptr = load_sampler_desc(ctx, index, DESC_SAMPLER);
			*samp_ptr = sici_fix_sampler_aniso(ctx, *res_ptr, *samp_ptr);
		}
		if (fmask_ptr)
			*fmask_ptr = NULL;
	}
}

static void txq_fetch_args(
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction *inst = emit_data->inst;
	unsigned target = inst->Texture.Texture;
	LLVMValueRef res_ptr;
	LLVMValueRef address;

	tex_fetch_ptrs(bld_base, emit_data, &res_ptr, NULL, NULL);

	if (target == TGSI_TEXTURE_BUFFER) {
		/* Read the size from the buffer descriptor directly. */
		LLVMValueRef res = LLVMBuildBitCast(builder, res_ptr, ctx->v8i32, "");
		emit_data->args[0] = get_buffer_size(bld_base, res);
		return;
	}

	/* Textures - set the mip level. */
	address = lp_build_emit_fetch(bld_base, inst, 0, TGSI_CHAN_X);

	set_tex_fetch_args(ctx, emit_data, TGSI_OPCODE_TXQ, target, res_ptr,
			   NULL, &address, 1, 0xf);
}

static void txq_emit(const struct lp_build_tgsi_action *action,
		     struct lp_build_tgsi_context *bld_base,
		     struct lp_build_emit_data *emit_data)
{
	struct lp_build_context *base = &bld_base->base;
	unsigned target = emit_data->inst->Texture.Texture;

	if (target == TGSI_TEXTURE_BUFFER) {
		/* Just return the buffer size. */
		emit_data->output[emit_data->chan] = emit_data->args[0];
		return;
	}

	emit_data->output[emit_data->chan] = lp_build_intrinsic(
		base->gallivm->builder, "llvm.SI.getresinfo.i32",
		emit_data->dst_type, emit_data->args, emit_data->arg_count,
		LLVMReadNoneAttribute);

	/* Divide the number of layers by 6 to get the number of cubes. */
	if (target == TGSI_TEXTURE_CUBE_ARRAY ||
	    target == TGSI_TEXTURE_SHADOWCUBE_ARRAY) {
		LLVMBuilderRef builder = bld_base->base.gallivm->builder;
		LLVMValueRef two = lp_build_const_int32(bld_base->base.gallivm, 2);
		LLVMValueRef six = lp_build_const_int32(bld_base->base.gallivm, 6);

		LLVMValueRef v4 = emit_data->output[emit_data->chan];
		LLVMValueRef z = LLVMBuildExtractElement(builder, v4, two, "");
		z = LLVMBuildSDiv(builder, z, six, "");

		emit_data->output[emit_data->chan] =
			LLVMBuildInsertElement(builder, v4, z, two, "");
	}
}

static void tex_fetch_args(
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	const struct tgsi_full_instruction *inst = emit_data->inst;
	unsigned opcode = inst->Instruction.Opcode;
	unsigned target = inst->Texture.Texture;
	LLVMValueRef coords[5], derivs[6];
	LLVMValueRef address[16];
	unsigned num_coords = tgsi_util_get_texture_coord_dim(target);
	int ref_pos = tgsi_util_get_shadow_ref_src_index(target);
	unsigned count = 0;
	unsigned chan;
	unsigned num_deriv_channels = 0;
	bool has_offset = inst->Texture.NumOffsets > 0;
	LLVMValueRef res_ptr, samp_ptr, fmask_ptr = NULL;
	unsigned dmask = 0xf;

	tex_fetch_ptrs(bld_base, emit_data, &res_ptr, &samp_ptr, &fmask_ptr);

	if (target == TGSI_TEXTURE_BUFFER) {
		LLVMTypeRef v2i128 = LLVMVectorType(ctx->i128, 2);

		/* Bitcast and truncate v8i32 to v16i8. */
		LLVMValueRef res = res_ptr;
		res = LLVMBuildBitCast(gallivm->builder, res, v2i128, "");
		res = LLVMBuildExtractElement(gallivm->builder, res, bld_base->uint_bld.one, "");
		res = LLVMBuildBitCast(gallivm->builder, res, ctx->v16i8, "");

		emit_data->dst_type = ctx->v4f32;
		emit_data->args[0] = res;
		emit_data->args[1] = bld_base->uint_bld.zero;
		emit_data->args[2] = lp_build_emit_fetch(bld_base, emit_data->inst, 0, TGSI_CHAN_X);
		emit_data->arg_count = 3;
		return;
	}

	/* Fetch and project texture coordinates */
	coords[3] = lp_build_emit_fetch(bld_base, emit_data->inst, 0, TGSI_CHAN_W);
	for (chan = 0; chan < 3; chan++ ) {
		coords[chan] = lp_build_emit_fetch(bld_base,
						   emit_data->inst, 0,
						   chan);
		if (opcode == TGSI_OPCODE_TXP)
			coords[chan] = lp_build_emit_llvm_binary(bld_base,
								 TGSI_OPCODE_DIV,
								 coords[chan],
								 coords[3]);
	}

	if (opcode == TGSI_OPCODE_TXP)
		coords[3] = bld_base->base.one;

	/* Pack offsets. */
	if (has_offset && opcode != TGSI_OPCODE_TXF) {
		/* The offsets are six-bit signed integers packed like this:
		 *   X=[5:0], Y=[13:8], and Z=[21:16].
		 */
		LLVMValueRef offset[3], pack;

		assert(inst->Texture.NumOffsets == 1);

		for (chan = 0; chan < 3; chan++) {
			offset[chan] = lp_build_emit_fetch_texoffset(bld_base,
								     emit_data->inst, 0, chan);
			offset[chan] = LLVMBuildAnd(gallivm->builder, offset[chan],
						    lp_build_const_int32(gallivm, 0x3f), "");
			if (chan)
				offset[chan] = LLVMBuildShl(gallivm->builder, offset[chan],
							    lp_build_const_int32(gallivm, chan*8), "");
		}

		pack = LLVMBuildOr(gallivm->builder, offset[0], offset[1], "");
		pack = LLVMBuildOr(gallivm->builder, pack, offset[2], "");
		address[count++] = pack;
	}

	/* Pack LOD bias value */
	if (opcode == TGSI_OPCODE_TXB)
		address[count++] = coords[3];
	if (opcode == TGSI_OPCODE_TXB2)
		address[count++] = lp_build_emit_fetch(bld_base, inst, 1, TGSI_CHAN_X);

	/* Pack depth comparison value */
	if (tgsi_is_shadow_target(target) && opcode != TGSI_OPCODE_LODQ) {
		LLVMValueRef z;

		if (target == TGSI_TEXTURE_SHADOWCUBE_ARRAY) {
			z = lp_build_emit_fetch(bld_base, inst, 1, TGSI_CHAN_X);
		} else {
			assert(ref_pos >= 0);
			z = coords[ref_pos];
		}

		/* TC-compatible HTILE promotes Z16 and Z24 to Z32_FLOAT,
		 * so the depth comparison value isn't clamped for Z16 and
		 * Z24 anymore. Do it manually here.
		 *
		 * It's unnecessary if the original texture format was
		 * Z32_FLOAT, but we don't know that here.
		 */
		if (ctx->screen->b.chip_class == VI)
			z = si_llvm_saturate(bld_base, z);

		address[count++] = z;
	}

	/* Pack user derivatives */
	if (opcode == TGSI_OPCODE_TXD) {
		int param, num_src_deriv_channels;

		switch (target) {
		case TGSI_TEXTURE_3D:
			num_src_deriv_channels = 3;
			num_deriv_channels = 3;
			break;
		case TGSI_TEXTURE_2D:
		case TGSI_TEXTURE_SHADOW2D:
		case TGSI_TEXTURE_RECT:
		case TGSI_TEXTURE_SHADOWRECT:
		case TGSI_TEXTURE_2D_ARRAY:
		case TGSI_TEXTURE_SHADOW2D_ARRAY:
			num_src_deriv_channels = 2;
			num_deriv_channels = 2;
			break;
		case TGSI_TEXTURE_CUBE:
		case TGSI_TEXTURE_SHADOWCUBE:
		case TGSI_TEXTURE_CUBE_ARRAY:
		case TGSI_TEXTURE_SHADOWCUBE_ARRAY:
			/* Cube derivatives will be converted to 2D. */
			num_src_deriv_channels = 3;
			num_deriv_channels = 2;
			break;
		case TGSI_TEXTURE_1D:
		case TGSI_TEXTURE_SHADOW1D:
		case TGSI_TEXTURE_1D_ARRAY:
		case TGSI_TEXTURE_SHADOW1D_ARRAY:
			num_src_deriv_channels = 1;
			num_deriv_channels = 1;
			break;
		default:
			unreachable("invalid target");
		}

		for (param = 0; param < 2; param++)
			for (chan = 0; chan < num_src_deriv_channels; chan++)
				derivs[param * num_src_deriv_channels + chan] =
					lp_build_emit_fetch(bld_base, inst, param+1, chan);
	}

	if (target == TGSI_TEXTURE_CUBE ||
	    target == TGSI_TEXTURE_CUBE_ARRAY ||
	    target == TGSI_TEXTURE_SHADOWCUBE ||
	    target == TGSI_TEXTURE_SHADOWCUBE_ARRAY)
		si_prepare_cube_coords(bld_base, emit_data, coords, derivs);

	if (opcode == TGSI_OPCODE_TXD)
		for (int i = 0; i < num_deriv_channels * 2; i++)
			address[count++] = derivs[i];

	/* Pack texture coordinates */
	address[count++] = coords[0];
	if (num_coords > 1)
		address[count++] = coords[1];
	if (num_coords > 2)
		address[count++] = coords[2];

	/* Pack LOD or sample index */
	if (opcode == TGSI_OPCODE_TXL || opcode == TGSI_OPCODE_TXF)
		address[count++] = coords[3];
	else if (opcode == TGSI_OPCODE_TXL2)
		address[count++] = lp_build_emit_fetch(bld_base, inst, 1, TGSI_CHAN_X);

	if (count > 16) {
		assert(!"Cannot handle more than 16 texture address parameters");
		count = 16;
	}

	for (chan = 0; chan < count; chan++ ) {
		address[chan] = LLVMBuildBitCast(gallivm->builder,
						 address[chan], ctx->i32, "");
	}

	/* Adjust the sample index according to FMASK.
	 *
	 * For uncompressed MSAA surfaces, FMASK should return 0x76543210,
	 * which is the identity mapping. Each nibble says which physical sample
	 * should be fetched to get that sample.
	 *
	 * For example, 0x11111100 means there are only 2 samples stored and
	 * the second sample covers 3/4 of the pixel. When reading samples 0
	 * and 1, return physical sample 0 (determined by the first two 0s
	 * in FMASK), otherwise return physical sample 1.
	 *
	 * The sample index should be adjusted as follows:
	 *   sample_index = (fmask >> (sample_index * 4)) & 0xF;
	 */
	if (target == TGSI_TEXTURE_2D_MSAA ||
	    target == TGSI_TEXTURE_2D_ARRAY_MSAA) {
		struct lp_build_context *uint_bld = &bld_base->uint_bld;
		struct lp_build_emit_data txf_emit_data = *emit_data;
		LLVMValueRef txf_address[4];
		unsigned txf_count = count;
		struct tgsi_full_instruction inst = {};

		memcpy(txf_address, address, sizeof(txf_address));

		if (target == TGSI_TEXTURE_2D_MSAA) {
			txf_address[2] = bld_base->uint_bld.zero;
		}
		txf_address[3] = bld_base->uint_bld.zero;

		/* Read FMASK using TXF. */
		inst.Instruction.Opcode = TGSI_OPCODE_TXF;
		inst.Texture.Texture = target;
		txf_emit_data.inst = &inst;
		txf_emit_data.chan = 0;
		set_tex_fetch_args(ctx, &txf_emit_data, TGSI_OPCODE_TXF,
				   target, fmask_ptr, NULL,
				   txf_address, txf_count, 0xf);
		build_tex_intrinsic(&tex_action, bld_base, &txf_emit_data);

		/* Initialize some constants. */
		LLVMValueRef four = LLVMConstInt(ctx->i32, 4, 0);
		LLVMValueRef F = LLVMConstInt(ctx->i32, 0xF, 0);

		/* Apply the formula. */
		LLVMValueRef fmask =
			LLVMBuildExtractElement(gallivm->builder,
						txf_emit_data.output[0],
						uint_bld->zero, "");

		unsigned sample_chan = target == TGSI_TEXTURE_2D_MSAA ? 2 : 3;

		LLVMValueRef sample_index4 =
			LLVMBuildMul(gallivm->builder, address[sample_chan], four, "");

		LLVMValueRef shifted_fmask =
			LLVMBuildLShr(gallivm->builder, fmask, sample_index4, "");

		LLVMValueRef final_sample =
			LLVMBuildAnd(gallivm->builder, shifted_fmask, F, "");

		/* Don't rewrite the sample index if WORD1.DATA_FORMAT of the FMASK
		 * resource descriptor is 0 (invalid),
		 */
		LLVMValueRef fmask_desc =
			LLVMBuildBitCast(gallivm->builder, fmask_ptr,
					 ctx->v8i32, "");

		LLVMValueRef fmask_word1 =
			LLVMBuildExtractElement(gallivm->builder, fmask_desc,
						uint_bld->one, "");

		LLVMValueRef word1_is_nonzero =
			LLVMBuildICmp(gallivm->builder, LLVMIntNE,
				      fmask_word1, uint_bld->zero, "");

		/* Replace the MSAA sample index. */
		address[sample_chan] =
			LLVMBuildSelect(gallivm->builder, word1_is_nonzero,
					final_sample, address[sample_chan], "");
	}

	if (opcode == TGSI_OPCODE_TXF) {
		/* add tex offsets */
		if (inst->Texture.NumOffsets) {
			struct lp_build_context *uint_bld = &bld_base->uint_bld;
			struct lp_build_tgsi_soa_context *bld = lp_soa_context(bld_base);
			const struct tgsi_texture_offset *off = inst->TexOffsets;

			assert(inst->Texture.NumOffsets == 1);

			switch (target) {
			case TGSI_TEXTURE_3D:
				address[2] = lp_build_add(uint_bld, address[2],
						bld->immediates[off->Index][off->SwizzleZ]);
				/* fall through */
			case TGSI_TEXTURE_2D:
			case TGSI_TEXTURE_SHADOW2D:
			case TGSI_TEXTURE_RECT:
			case TGSI_TEXTURE_SHADOWRECT:
			case TGSI_TEXTURE_2D_ARRAY:
			case TGSI_TEXTURE_SHADOW2D_ARRAY:
				address[1] =
					lp_build_add(uint_bld, address[1],
						bld->immediates[off->Index][off->SwizzleY]);
				/* fall through */
			case TGSI_TEXTURE_1D:
			case TGSI_TEXTURE_SHADOW1D:
			case TGSI_TEXTURE_1D_ARRAY:
			case TGSI_TEXTURE_SHADOW1D_ARRAY:
				address[0] =
					lp_build_add(uint_bld, address[0],
						bld->immediates[off->Index][off->SwizzleX]);
				break;
				/* texture offsets do not apply to other texture targets */
			}
		}
	}

	if (opcode == TGSI_OPCODE_TG4) {
		unsigned gather_comp = 0;

		/* DMASK was repurposed for GATHER4. 4 components are always
		 * returned and DMASK works like a swizzle - it selects
		 * the component to fetch. The only valid DMASK values are
		 * 1=red, 2=green, 4=blue, 8=alpha. (e.g. 1 returns
		 * (red,red,red,red) etc.) The ISA document doesn't mention
		 * this.
		 */

		/* Get the component index from src1.x for Gather4. */
		if (!tgsi_is_shadow_target(target)) {
			LLVMValueRef (*imms)[4] = lp_soa_context(bld_base)->immediates;
			LLVMValueRef comp_imm;
			struct tgsi_src_register src1 = inst->Src[1].Register;

			assert(src1.File == TGSI_FILE_IMMEDIATE);

			comp_imm = imms[src1.Index][src1.SwizzleX];
			gather_comp = LLVMConstIntGetZExtValue(comp_imm);
			gather_comp = CLAMP(gather_comp, 0, 3);
		}

		dmask = 1 << gather_comp;
	}

	set_tex_fetch_args(ctx, emit_data, opcode, target, res_ptr,
			   samp_ptr, address, count, dmask);
}

/* Gather4 should follow the same rules as bilinear filtering, but the hardware
 * incorrectly forces nearest filtering if the texture format is integer.
 * The only effect it has on Gather4, which always returns 4 texels for
 * bilinear filtering, is that the final coordinates are off by 0.5 of
 * the texel size.
 *
 * The workaround is to subtract 0.5 from the unnormalized coordinates,
 * or (0.5 / size) from the normalized coordinates.
 */
static void si_lower_gather4_integer(struct si_shader_context *ctx,
				     struct lp_build_emit_data *emit_data,
				     const char *intr_name,
				     unsigned coord_vgpr_index)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMValueRef coord = emit_data->args[0];
	LLVMValueRef half_texel[2];
	int c;

	if (emit_data->inst->Texture.Texture == TGSI_TEXTURE_RECT ||
	    emit_data->inst->Texture.Texture == TGSI_TEXTURE_SHADOWRECT) {
		half_texel[0] = half_texel[1] = LLVMConstReal(ctx->f32, -0.5);
	} else {
		struct tgsi_full_instruction txq_inst = {};
		struct lp_build_emit_data txq_emit_data = {};

		/* Query the texture size. */
		txq_inst.Texture.Texture = emit_data->inst->Texture.Texture;
		txq_emit_data.inst = &txq_inst;
		txq_emit_data.dst_type = ctx->v4i32;
		set_tex_fetch_args(ctx, &txq_emit_data, TGSI_OPCODE_TXQ,
				   txq_inst.Texture.Texture,
				   emit_data->args[1], NULL,
				   &ctx->soa.bld_base.uint_bld.zero,
				   1, 0xf);
		txq_emit(NULL, &ctx->soa.bld_base, &txq_emit_data);

		/* Compute -0.5 / size. */
		for (c = 0; c < 2; c++) {
			half_texel[c] =
				LLVMBuildExtractElement(builder, txq_emit_data.output[0],
							LLVMConstInt(ctx->i32, c, 0), "");
			half_texel[c] = LLVMBuildUIToFP(builder, half_texel[c], ctx->f32, "");
			half_texel[c] =
				lp_build_emit_llvm_unary(&ctx->soa.bld_base,
							 TGSI_OPCODE_RCP, half_texel[c]);
			half_texel[c] = LLVMBuildFMul(builder, half_texel[c],
						      LLVMConstReal(ctx->f32, -0.5), "");
		}
	}

	for (c = 0; c < 2; c++) {
		LLVMValueRef tmp;
		LLVMValueRef index = LLVMConstInt(ctx->i32, coord_vgpr_index + c, 0);

		tmp = LLVMBuildExtractElement(builder, coord, index, "");
		tmp = LLVMBuildBitCast(builder, tmp, ctx->f32, "");
		tmp = LLVMBuildFAdd(builder, tmp, half_texel[c], "");
		tmp = LLVMBuildBitCast(builder, tmp, ctx->i32, "");
		coord = LLVMBuildInsertElement(builder, coord, tmp, index, "");
	}

	emit_data->args[0] = coord;
	emit_data->output[emit_data->chan] =
		lp_build_intrinsic(builder, intr_name, emit_data->dst_type,
				   emit_data->args, emit_data->arg_count,
				   LLVMReadNoneAttribute);
}

static void build_tex_intrinsic(const struct lp_build_tgsi_action *action,
				struct lp_build_tgsi_context *bld_base,
				struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct lp_build_context *base = &bld_base->base;
	const struct tgsi_full_instruction *inst = emit_data->inst;
	unsigned opcode = inst->Instruction.Opcode;
	unsigned target = inst->Texture.Texture;
	char intr_name[127];
	bool has_offset = inst->Texture.NumOffsets > 0;
	bool is_shadow = tgsi_is_shadow_target(target);
	char type[64];
	const char *name = "llvm.SI.image.sample";
	const char *infix = "";

	if (target == TGSI_TEXTURE_BUFFER) {
		emit_data->output[emit_data->chan] = lp_build_intrinsic(
			base->gallivm->builder,
			"llvm.SI.vs.load.input", emit_data->dst_type,
			emit_data->args, emit_data->arg_count,
			LLVMReadNoneAttribute);
		return;
	}

	switch (opcode) {
	case TGSI_OPCODE_TXF:
		name = target == TGSI_TEXTURE_2D_MSAA ||
		       target == TGSI_TEXTURE_2D_ARRAY_MSAA ?
			       "llvm.SI.image.load" :
			       "llvm.SI.image.load.mip";
		is_shadow = false;
		has_offset = false;
		break;
	case TGSI_OPCODE_LODQ:
		name = "llvm.SI.getlod";
		is_shadow = false;
		has_offset = false;
		break;
	case TGSI_OPCODE_TEX:
	case TGSI_OPCODE_TEX2:
	case TGSI_OPCODE_TXP:
		if (ctx->type != PIPE_SHADER_FRAGMENT)
			infix = ".lz";
		break;
	case TGSI_OPCODE_TXB:
	case TGSI_OPCODE_TXB2:
		assert(ctx->type == PIPE_SHADER_FRAGMENT);
		infix = ".b";
		break;
	case TGSI_OPCODE_TXL:
	case TGSI_OPCODE_TXL2:
		infix = ".l";
		break;
	case TGSI_OPCODE_TXD:
		infix = ".d";
		break;
	case TGSI_OPCODE_TG4:
		name = "llvm.SI.gather4";
		infix = ".lz";
		break;
	default:
		assert(0);
		return;
	}

	/* Add the type and suffixes .c, .o if needed. */
	build_type_name_for_intr(LLVMTypeOf(emit_data->args[0]), type, sizeof(type));
	sprintf(intr_name, "%s%s%s%s.%s",
		name, is_shadow ? ".c" : "", infix,
		has_offset ? ".o" : "", type);

	/* The hardware needs special lowering for Gather4 with integer formats. */
	if (opcode == TGSI_OPCODE_TG4) {
		struct tgsi_shader_info *info = &ctx->shader->selector->info;
		/* This will also work with non-constant indexing because of how
		 * glsl_to_tgsi works and we intent to preserve that behavior.
		 */
		const unsigned src_idx = 2;
		unsigned sampler = inst->Src[src_idx].Register.Index;

		assert(inst->Src[src_idx].Register.File == TGSI_FILE_SAMPLER);

		if (info->sampler_type[sampler] == TGSI_RETURN_TYPE_SINT ||
		    info->sampler_type[sampler] == TGSI_RETURN_TYPE_UINT) {
			/* Texture coordinates start after:
			 *   {offset, bias, z-compare, derivatives}
			 * Only the offset and z-compare can occur here.
			 */
			si_lower_gather4_integer(ctx, emit_data, intr_name,
						 (int)has_offset + (int)is_shadow);
			return;
		}
	}

	emit_data->output[emit_data->chan] = lp_build_intrinsic(
		base->gallivm->builder, intr_name, emit_data->dst_type,
		emit_data->args, emit_data->arg_count,
		LLVMReadNoneAttribute);
}

static void si_llvm_emit_txqs(
	const struct lp_build_tgsi_action *action,
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	LLVMValueRef res, samples;
	LLVMValueRef res_ptr, samp_ptr, fmask_ptr = NULL;

	tex_fetch_ptrs(bld_base, emit_data, &res_ptr, &samp_ptr, &fmask_ptr);


	/* Read the samples from the descriptor directly. */
	res = LLVMBuildBitCast(builder, res_ptr, ctx->v8i32, "");
	samples = LLVMBuildExtractElement(
		builder, res,
		lp_build_const_int32(gallivm, 3), "");
	samples = LLVMBuildLShr(builder, samples,
				lp_build_const_int32(gallivm, 16), "");
	samples = LLVMBuildAnd(builder, samples,
			       lp_build_const_int32(gallivm, 0xf), "");
	samples = LLVMBuildShl(builder, lp_build_const_int32(gallivm, 1),
			       samples, "");

	emit_data->output[emit_data->chan] = samples;
}

/*
 * SI implements derivatives using the local data store (LDS)
 * All writes to the LDS happen in all executing threads at
 * the same time. TID is the Thread ID for the current
 * thread and is a value between 0 and 63, representing
 * the thread's position in the wavefront.
 *
 * For the pixel shader threads are grouped into quads of four pixels.
 * The TIDs of the pixels of a quad are:
 *
 *  +------+------+
 *  |4n + 0|4n + 1|
 *  +------+------+
 *  |4n + 2|4n + 3|
 *  +------+------+
 *
 * So, masking the TID with 0xfffffffc yields the TID of the top left pixel
 * of the quad, masking with 0xfffffffd yields the TID of the top pixel of
 * the current pixel's column, and masking with 0xfffffffe yields the TID
 * of the left pixel of the current pixel's row.
 *
 * Adding 1 yields the TID of the pixel to the right of the left pixel, and
 * adding 2 yields the TID of the pixel below the top pixel.
 */
/* masks for thread ID. */
#define TID_MASK_TOP_LEFT 0xfffffffc
#define TID_MASK_TOP      0xfffffffd
#define TID_MASK_LEFT     0xfffffffe

static void si_llvm_emit_ddxy(
	const struct lp_build_tgsi_action *action,
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	unsigned opcode = emit_data->info->opcode;
	LLVMValueRef thread_id, tl, trbl, tl_tid, trbl_tid, val, args[2];
	int idx;
	unsigned mask;

	thread_id = get_thread_id(ctx);

	if (opcode == TGSI_OPCODE_DDX_FINE)
		mask = TID_MASK_LEFT;
	else if (opcode == TGSI_OPCODE_DDY_FINE)
		mask = TID_MASK_TOP;
	else
		mask = TID_MASK_TOP_LEFT;

	tl_tid = LLVMBuildAnd(gallivm->builder, thread_id,
				lp_build_const_int32(gallivm, mask), "");

	/* for DDX we want to next X pixel, DDY next Y pixel. */
	idx = (opcode == TGSI_OPCODE_DDX || opcode == TGSI_OPCODE_DDX_FINE) ? 1 : 2;
	trbl_tid = LLVMBuildAdd(gallivm->builder, tl_tid,
				  lp_build_const_int32(gallivm, idx), "");

	val = LLVMBuildBitCast(gallivm->builder, emit_data->args[0], ctx->i32, "");

	if (ctx->screen->has_ds_bpermute) {
		args[0] = LLVMBuildMul(gallivm->builder, tl_tid,
				       lp_build_const_int32(gallivm, 4), "");
		args[1] = val;
		tl = lp_build_intrinsic(gallivm->builder,
					"llvm.amdgcn.ds.bpermute", ctx->i32,
					args, 2, LLVMReadNoneAttribute);

		args[0] = LLVMBuildMul(gallivm->builder, trbl_tid,
				       lp_build_const_int32(gallivm, 4), "");
		trbl = lp_build_intrinsic(gallivm->builder,
					  "llvm.amdgcn.ds.bpermute", ctx->i32,
					  args, 2, LLVMReadNoneAttribute);
	} else {
		LLVMValueRef store_ptr, load_ptr0, load_ptr1;

		store_ptr = build_gep0(ctx, ctx->lds, thread_id);
		load_ptr0 = build_gep0(ctx, ctx->lds, tl_tid);
		load_ptr1 = build_gep0(ctx, ctx->lds, trbl_tid);

		LLVMBuildStore(gallivm->builder, val, store_ptr);
		tl = LLVMBuildLoad(gallivm->builder, load_ptr0, "");
		trbl = LLVMBuildLoad(gallivm->builder, load_ptr1, "");
	}

	tl = LLVMBuildBitCast(gallivm->builder, tl, ctx->f32, "");
	trbl = LLVMBuildBitCast(gallivm->builder, trbl,	ctx->f32, "");

	emit_data->output[emit_data->chan] =
		LLVMBuildFSub(gallivm->builder, trbl, tl, "");
}

/*
 * this takes an I,J coordinate pair,
 * and works out the X and Y derivatives.
 * it returns DDX(I), DDX(J), DDY(I), DDY(J).
 */
static LLVMValueRef si_llvm_emit_ddxy_interp(
	struct lp_build_tgsi_context *bld_base,
	LLVMValueRef interp_ij)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef result[4], a;
	unsigned i;

	for (i = 0; i < 2; i++) {
		a = LLVMBuildExtractElement(gallivm->builder, interp_ij,
					    LLVMConstInt(ctx->i32, i, 0), "");
		result[i] = lp_build_emit_llvm_unary(bld_base, TGSI_OPCODE_DDX, a);
		result[2+i] = lp_build_emit_llvm_unary(bld_base, TGSI_OPCODE_DDY, a);
	}

	return lp_build_gather_values(gallivm, result, 4);
}

static void interp_fetch_args(
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	const struct tgsi_full_instruction *inst = emit_data->inst;

	if (inst->Instruction.Opcode == TGSI_OPCODE_INTERP_OFFSET) {
		/* offset is in second src, first two channels */
		emit_data->args[0] = lp_build_emit_fetch(bld_base,
							 emit_data->inst, 1,
							 TGSI_CHAN_X);
		emit_data->args[1] = lp_build_emit_fetch(bld_base,
							 emit_data->inst, 1,
							 TGSI_CHAN_Y);
		emit_data->arg_count = 2;
	} else if (inst->Instruction.Opcode == TGSI_OPCODE_INTERP_SAMPLE) {
		LLVMValueRef sample_position;
		LLVMValueRef sample_id;
		LLVMValueRef halfval = lp_build_const_float(gallivm, 0.5f);

		/* fetch sample ID, then fetch its sample position,
		 * and place into first two channels.
		 */
		sample_id = lp_build_emit_fetch(bld_base,
						emit_data->inst, 1, TGSI_CHAN_X);
		sample_id = LLVMBuildBitCast(gallivm->builder, sample_id,
					     ctx->i32, "");
		sample_position = load_sample_position(ctx, sample_id);

		emit_data->args[0] = LLVMBuildExtractElement(gallivm->builder,
							     sample_position,
							     lp_build_const_int32(gallivm, 0), "");

		emit_data->args[0] = LLVMBuildFSub(gallivm->builder, emit_data->args[0], halfval, "");
		emit_data->args[1] = LLVMBuildExtractElement(gallivm->builder,
							     sample_position,
							     lp_build_const_int32(gallivm, 1), "");
		emit_data->args[1] = LLVMBuildFSub(gallivm->builder, emit_data->args[1], halfval, "");
		emit_data->arg_count = 2;
	}
}

static void build_interp_intrinsic(const struct lp_build_tgsi_action *action,
				struct lp_build_tgsi_context *bld_base,
				struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct si_shader *shader = ctx->shader;
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef interp_param;
	const struct tgsi_full_instruction *inst = emit_data->inst;
	const char *intr_name;
	int input_index = inst->Src[0].Register.Index;
	int chan;
	int i;
	LLVMValueRef attr_number;
	LLVMValueRef params = LLVMGetParam(ctx->main_fn, SI_PARAM_PRIM_MASK);
	int interp_param_idx;
	unsigned interp = shader->selector->info.input_interpolate[input_index];
	unsigned location;

	assert(inst->Src[0].Register.File == TGSI_FILE_INPUT);

	if (inst->Instruction.Opcode == TGSI_OPCODE_INTERP_OFFSET ||
	    inst->Instruction.Opcode == TGSI_OPCODE_INTERP_SAMPLE)
		location = TGSI_INTERPOLATE_LOC_CENTER;
	else
		location = TGSI_INTERPOLATE_LOC_CENTROID;

	interp_param_idx = lookup_interp_param_index(interp, location);
	if (interp_param_idx == -1)
		return;
	else if (interp_param_idx)
		interp_param = get_interp_param(ctx, interp_param_idx);
	else
		interp_param = NULL;

	attr_number = lp_build_const_int32(gallivm, input_index);

	if (inst->Instruction.Opcode == TGSI_OPCODE_INTERP_OFFSET ||
	    inst->Instruction.Opcode == TGSI_OPCODE_INTERP_SAMPLE) {
		LLVMValueRef ij_out[2];
		LLVMValueRef ddxy_out = si_llvm_emit_ddxy_interp(bld_base, interp_param);

		/*
		 * take the I then J parameters, and the DDX/Y for it, and
		 * calculate the IJ inputs for the interpolator.
		 * temp1 = ddx * offset/sample.x + I;
		 * interp_param.I = ddy * offset/sample.y + temp1;
		 * temp1 = ddx * offset/sample.x + J;
		 * interp_param.J = ddy * offset/sample.y + temp1;
		 */
		for (i = 0; i < 2; i++) {
			LLVMValueRef ix_ll = lp_build_const_int32(gallivm, i);
			LLVMValueRef iy_ll = lp_build_const_int32(gallivm, i + 2);
			LLVMValueRef ddx_el = LLVMBuildExtractElement(gallivm->builder,
								      ddxy_out, ix_ll, "");
			LLVMValueRef ddy_el = LLVMBuildExtractElement(gallivm->builder,
								      ddxy_out, iy_ll, "");
			LLVMValueRef interp_el = LLVMBuildExtractElement(gallivm->builder,
									 interp_param, ix_ll, "");
			LLVMValueRef temp1, temp2;

			interp_el = LLVMBuildBitCast(gallivm->builder, interp_el,
						     ctx->f32, "");

			temp1 = LLVMBuildFMul(gallivm->builder, ddx_el, emit_data->args[0], "");

			temp1 = LLVMBuildFAdd(gallivm->builder, temp1, interp_el, "");

			temp2 = LLVMBuildFMul(gallivm->builder, ddy_el, emit_data->args[1], "");

			temp2 = LLVMBuildFAdd(gallivm->builder, temp2, temp1, "");

			ij_out[i] = LLVMBuildBitCast(gallivm->builder,
						     temp2, ctx->i32, "");
		}
		interp_param = lp_build_gather_values(bld_base->base.gallivm, ij_out, 2);
	}

	intr_name = interp_param ? "llvm.SI.fs.interp" : "llvm.SI.fs.constant";
	for (chan = 0; chan < 4; chan++) {
		LLVMValueRef args[4];
		LLVMValueRef llvm_chan;
		unsigned schan;

		schan = tgsi_util_get_full_src_register_swizzle(&inst->Src[0], chan);
		llvm_chan = lp_build_const_int32(gallivm, schan);

		args[0] = llvm_chan;
		args[1] = attr_number;
		args[2] = params;
		args[3] = interp_param;

		emit_data->output[chan] =
			lp_build_intrinsic(gallivm->builder, intr_name,
					   ctx->f32, args, args[3] ? 4 : 3,
					   LLVMReadNoneAttribute);
	}
}

static unsigned si_llvm_get_stream(struct lp_build_tgsi_context *bld_base,
				       struct lp_build_emit_data *emit_data)
{
	LLVMValueRef (*imms)[4] = lp_soa_context(bld_base)->immediates;
	struct tgsi_src_register src0 = emit_data->inst->Src[0].Register;
	unsigned stream;

	assert(src0.File == TGSI_FILE_IMMEDIATE);

	stream = LLVMConstIntGetZExtValue(imms[src0.Index][src0.SwizzleX]) & 0x3;
	return stream;
}

/* Emit one vertex from the geometry shader */
static void si_llvm_emit_vertex(
	const struct lp_build_tgsi_action *action,
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct lp_build_context *uint = &bld_base->uint_bld;
	struct si_shader *shader = ctx->shader;
	struct tgsi_shader_info *info = &shader->selector->info;
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	struct lp_build_if_state if_state;
	LLVMValueRef soffset = LLVMGetParam(ctx->main_fn,
					    SI_PARAM_GS2VS_OFFSET);
	LLVMValueRef gs_next_vertex;
	LLVMValueRef can_emit, kill;
	LLVMValueRef args[2];
	unsigned chan;
	int i;
	unsigned stream;

	stream = si_llvm_get_stream(bld_base, emit_data);

	/* Write vertex attribute values to GSVS ring */
	gs_next_vertex = LLVMBuildLoad(gallivm->builder,
				       ctx->gs_next_vertex[stream],
				       "");

	/* If this thread has already emitted the declared maximum number of
	 * vertices, skip the write: excessive vertex emissions are not
	 * supposed to have any effect.
	 *
	 * If the shader has no writes to memory, kill it instead. This skips
	 * further memory loads and may allow LLVM to skip to the end
	 * altogether.
	 */
	can_emit = LLVMBuildICmp(gallivm->builder, LLVMIntULT, gs_next_vertex,
				 lp_build_const_int32(gallivm,
						      shader->selector->gs_max_out_vertices), "");

	bool use_kill = !info->writes_memory;
	if (use_kill) {
		kill = lp_build_select(&bld_base->base, can_emit,
				       lp_build_const_float(gallivm, 1.0f),
				       lp_build_const_float(gallivm, -1.0f));

		lp_build_intrinsic(gallivm->builder, "llvm.AMDGPU.kill",
				   ctx->voidt, &kill, 1, 0);
	} else {
		lp_build_if(&if_state, gallivm, can_emit);
	}

	for (i = 0; i < info->num_outputs; i++) {
		LLVMValueRef *out_ptr =
			ctx->soa.outputs[i];

		for (chan = 0; chan < 4; chan++) {
			LLVMValueRef out_val = LLVMBuildLoad(gallivm->builder, out_ptr[chan], "");
			LLVMValueRef voffset =
				lp_build_const_int32(gallivm, (i * 4 + chan) *
						     shader->selector->gs_max_out_vertices);

			voffset = lp_build_add(uint, voffset, gs_next_vertex);
			voffset = lp_build_mul_imm(uint, voffset, 4);

			out_val = LLVMBuildBitCast(gallivm->builder, out_val, ctx->i32, "");

			build_tbuffer_store(ctx,
					    ctx->gsvs_ring[stream],
					    out_val, 1,
					    voffset, soffset, 0,
					    V_008F0C_BUF_DATA_FORMAT_32,
					    V_008F0C_BUF_NUM_FORMAT_UINT,
					    1, 0, 1, 1, 0);
		}
	}

	gs_next_vertex = lp_build_add(uint, gs_next_vertex,
				      lp_build_const_int32(gallivm, 1));

	LLVMBuildStore(gallivm->builder, gs_next_vertex, ctx->gs_next_vertex[stream]);

	/* Signal vertex emission */
	args[0] = lp_build_const_int32(gallivm, SENDMSG_GS_OP_EMIT | SENDMSG_GS | (stream << 8));
	args[1] = LLVMGetParam(ctx->main_fn, SI_PARAM_GS_WAVE_ID);
	lp_build_intrinsic(gallivm->builder, "llvm.SI.sendmsg",
			   ctx->voidt, args, 2, 0);

	if (!use_kill)
		lp_build_endif(&if_state);
}

/* Cut one primitive from the geometry shader */
static void si_llvm_emit_primitive(
	const struct lp_build_tgsi_action *action,
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef args[2];
	unsigned stream;

	/* Signal primitive cut */
	stream = si_llvm_get_stream(bld_base, emit_data);
	args[0] = lp_build_const_int32(gallivm,	SENDMSG_GS_OP_CUT | SENDMSG_GS | (stream << 8));
	args[1] = LLVMGetParam(ctx->main_fn, SI_PARAM_GS_WAVE_ID);
	lp_build_intrinsic(gallivm->builder, "llvm.SI.sendmsg",
			   ctx->voidt, args, 2, 0);
}

static void si_llvm_emit_barrier(const struct lp_build_tgsi_action *action,
				 struct lp_build_tgsi_context *bld_base,
				 struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;

	/* SI only (thanks to a hw bug workaround):
	 * The real barrier instruction isn’t needed, because an entire patch
	 * always fits into a single wave.
	 */
	if (HAVE_LLVM >= 0x0309 &&
	    ctx->screen->b.chip_class == SI &&
	    ctx->type == PIPE_SHADER_TESS_CTRL) {
		emit_waitcnt(ctx, LGKM_CNT & VM_CNT);
		return;
	}

	lp_build_intrinsic(gallivm->builder,
			   HAVE_LLVM >= 0x0309 ? "llvm.amdgcn.s.barrier"
					       : "llvm.AMDGPU.barrier.local",
			   ctx->voidt, NULL, 0, 0);
}

static const struct lp_build_tgsi_action tex_action = {
	.fetch_args = tex_fetch_args,
	.emit = build_tex_intrinsic,
};

static const struct lp_build_tgsi_action interp_action = {
	.fetch_args = interp_fetch_args,
	.emit = build_interp_intrinsic,
};

static void si_create_function(struct si_shader_context *ctx,
			       LLVMTypeRef *returns, unsigned num_returns,
			       LLVMTypeRef *params, unsigned num_params,
			       int last_sgpr)
{
	int i;

	si_llvm_create_func(ctx, returns, num_returns,
			    params, num_params);
	si_llvm_shader_type(ctx->main_fn, ctx->type);
	ctx->return_value = LLVMGetUndef(ctx->return_type);

	for (i = 0; i <= last_sgpr; ++i) {
		LLVMValueRef P = LLVMGetParam(ctx->main_fn, i);

		/* The combination of:
		 * - ByVal
		 * - dereferenceable
		 * - invariant.load
		 * allows the optimization passes to move loads and reduces
		 * SGPR spilling significantly.
		 */
		if (LLVMGetTypeKind(LLVMTypeOf(P)) == LLVMPointerTypeKind) {
			LLVMAddAttribute(P, LLVMByValAttribute);
			lp_add_attr_dereferenceable(P, UINT64_MAX);
		} else
			LLVMAddAttribute(P, LLVMInRegAttribute);
	}

	if (ctx->screen->b.debug_flags & DBG_UNSAFE_MATH) {
		/* These were copied from some LLVM test. */
		LLVMAddTargetDependentFunctionAttr(ctx->main_fn,
						   "less-precise-fpmad",
						   "true");
		LLVMAddTargetDependentFunctionAttr(ctx->main_fn,
						   "no-infs-fp-math",
						   "true");
		LLVMAddTargetDependentFunctionAttr(ctx->main_fn,
						   "no-nans-fp-math",
						   "true");
		LLVMAddTargetDependentFunctionAttr(ctx->main_fn,
						   "unsafe-fp-math",
						   "true");
	}
}

static void create_meta_data(struct si_shader_context *ctx)
{
	struct gallivm_state *gallivm = ctx->soa.bld_base.base.gallivm;

	ctx->invariant_load_md_kind = LLVMGetMDKindIDInContext(gallivm->context,
							       "invariant.load", 14);
	ctx->range_md_kind = LLVMGetMDKindIDInContext(gallivm->context,
						     "range", 5);
	ctx->uniform_md_kind = LLVMGetMDKindIDInContext(gallivm->context,
							"amdgpu.uniform", 14);

	ctx->empty_md = LLVMMDNodeInContext(gallivm->context, NULL, 0);
}

static void declare_streamout_params(struct si_shader_context *ctx,
				     struct pipe_stream_output_info *so,
				     LLVMTypeRef *params, LLVMTypeRef i32,
				     unsigned *num_params)
{
	int i;

	/* Streamout SGPRs. */
	if (so->num_outputs) {
		if (ctx->type != PIPE_SHADER_TESS_EVAL)
			params[ctx->param_streamout_config = (*num_params)++] = i32;
		else
			ctx->param_streamout_config = ctx->param_tess_offchip;

		params[ctx->param_streamout_write_index = (*num_params)++] = i32;
	}
	/* A streamout buffer offset is loaded if the stride is non-zero. */
	for (i = 0; i < 4; i++) {
		if (!so->stride[i])
			continue;

		params[ctx->param_streamout_offset[i] = (*num_params)++] = i32;
	}
}

static unsigned llvm_get_type_size(LLVMTypeRef type)
{
	LLVMTypeKind kind = LLVMGetTypeKind(type);

	switch (kind) {
	case LLVMIntegerTypeKind:
		return LLVMGetIntTypeWidth(type) / 8;
	case LLVMFloatTypeKind:
		return 4;
	case LLVMPointerTypeKind:
		return 8;
	case LLVMVectorTypeKind:
		return LLVMGetVectorSize(type) *
		       llvm_get_type_size(LLVMGetElementType(type));
	default:
		assert(0);
		return 0;
	}
}

static void declare_tess_lds(struct si_shader_context *ctx)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx->soa.bld_base;
	struct lp_build_context *uint = &bld_base->uint_bld;

	unsigned lds_size = ctx->screen->b.chip_class >= CIK ? 65536 : 32768;
	ctx->lds = LLVMBuildIntToPtr(gallivm->builder, uint->zero,
		LLVMPointerType(LLVMArrayType(ctx->i32, lds_size / 4), LOCAL_ADDR_SPACE),
		"tess_lds");
}

static unsigned si_get_max_workgroup_size(struct si_shader *shader)
{
	const unsigned *properties = shader->selector->info.properties;
	unsigned max_work_group_size =
	               properties[TGSI_PROPERTY_CS_FIXED_BLOCK_WIDTH] *
	               properties[TGSI_PROPERTY_CS_FIXED_BLOCK_HEIGHT] *
	               properties[TGSI_PROPERTY_CS_FIXED_BLOCK_DEPTH];

	if (!max_work_group_size) {
		/* This is a variable group size compute shader,
		 * compile it for the maximum possible group size.
		 */
		max_work_group_size = SI_MAX_VARIABLE_THREADS_PER_BLOCK;
	}
	return max_work_group_size;
}

static void create_function(struct si_shader_context *ctx)
{
	struct lp_build_tgsi_context *bld_base = &ctx->soa.bld_base;
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	struct si_shader *shader = ctx->shader;
	LLVMTypeRef params[SI_NUM_PARAMS + SI_NUM_VERTEX_BUFFERS], v3i32;
	LLVMTypeRef returns[16+32*4];
	unsigned i, last_sgpr, num_params, num_return_sgprs;
	unsigned num_returns = 0;

	v3i32 = LLVMVectorType(ctx->i32, 3);

	params[SI_PARAM_RW_BUFFERS] = const_array(ctx->v16i8, SI_NUM_RW_BUFFERS);
	params[SI_PARAM_CONST_BUFFERS] = const_array(ctx->v16i8, SI_NUM_CONST_BUFFERS);
	params[SI_PARAM_SAMPLERS] = const_array(ctx->v8i32, SI_NUM_SAMPLERS);
	params[SI_PARAM_IMAGES] = const_array(ctx->v8i32, SI_NUM_IMAGES);
	params[SI_PARAM_SHADER_BUFFERS] = const_array(ctx->v4i32, SI_NUM_SHADER_BUFFERS);

	switch (ctx->type) {
	case PIPE_SHADER_VERTEX:
		params[SI_PARAM_VERTEX_BUFFERS] = const_array(ctx->v16i8, SI_NUM_VERTEX_BUFFERS);
		params[SI_PARAM_BASE_VERTEX] = ctx->i32;
		params[SI_PARAM_START_INSTANCE] = ctx->i32;
		params[SI_PARAM_DRAWID] = ctx->i32;
		num_params = SI_PARAM_DRAWID+1;

		if (shader->key.vs.as_es) {
			params[ctx->param_es2gs_offset = num_params++] = ctx->i32;
		} else if (shader->key.vs.as_ls) {
			params[SI_PARAM_LS_OUT_LAYOUT] = ctx->i32;
			num_params = SI_PARAM_LS_OUT_LAYOUT+1;
		} else {
			if (ctx->is_gs_copy_shader) {
				num_params = SI_PARAM_RW_BUFFERS+1;
			} else {
				params[SI_PARAM_VS_STATE_BITS] = ctx->i32;
				num_params = SI_PARAM_VS_STATE_BITS+1;
			}

			/* The locations of the other parameters are assigned dynamically. */
			declare_streamout_params(ctx, &shader->selector->so,
						 params, ctx->i32, &num_params);
		}

		last_sgpr = num_params-1;

		/* VGPRs */
		params[ctx->param_vertex_id = num_params++] = ctx->i32;
		params[ctx->param_rel_auto_id = num_params++] = ctx->i32;
		params[ctx->param_vs_prim_id = num_params++] = ctx->i32;
		params[ctx->param_instance_id = num_params++] = ctx->i32;

		if (!ctx->is_monolithic &&
		    !ctx->is_gs_copy_shader) {
			/* Vertex load indices. */
			ctx->param_vertex_index0 = num_params;

			for (i = 0; i < shader->selector->info.num_inputs; i++)
				params[num_params++] = ctx->i32;

			/* PrimitiveID output. */
			if (!shader->key.vs.as_es && !shader->key.vs.as_ls)
				for (i = 0; i <= VS_EPILOG_PRIMID_LOC; i++)
					returns[num_returns++] = ctx->f32;
		}
		break;

	case PIPE_SHADER_TESS_CTRL:
		params[SI_PARAM_TCS_OFFCHIP_LAYOUT] = ctx->i32;
		params[SI_PARAM_TCS_OUT_OFFSETS] = ctx->i32;
		params[SI_PARAM_TCS_OUT_LAYOUT] = ctx->i32;
		params[SI_PARAM_TCS_IN_LAYOUT] = ctx->i32;
		params[ctx->param_oc_lds = SI_PARAM_TCS_OC_LDS] = ctx->i32;
		params[SI_PARAM_TESS_FACTOR_OFFSET] = ctx->i32;
		last_sgpr = SI_PARAM_TESS_FACTOR_OFFSET;

		/* VGPRs */
		params[SI_PARAM_PATCH_ID] = ctx->i32;
		params[SI_PARAM_REL_IDS] = ctx->i32;
		num_params = SI_PARAM_REL_IDS+1;

		if (!ctx->is_monolithic) {
			/* SI_PARAM_TCS_OC_LDS and PARAM_TESS_FACTOR_OFFSET are
			 * placed after the user SGPRs.
			 */
			for (i = 0; i < SI_TCS_NUM_USER_SGPR + 2; i++)
				returns[num_returns++] = ctx->i32; /* SGPRs */

			for (i = 0; i < 3; i++)
				returns[num_returns++] = ctx->f32; /* VGPRs */
		}
		break;

	case PIPE_SHADER_TESS_EVAL:
		params[SI_PARAM_TCS_OFFCHIP_LAYOUT] = ctx->i32;
		num_params = SI_PARAM_TCS_OFFCHIP_LAYOUT+1;

		if (shader->key.tes.as_es) {
			params[ctx->param_oc_lds = num_params++] = ctx->i32;
			params[ctx->param_tess_offchip = num_params++] = ctx->i32;
			params[ctx->param_es2gs_offset = num_params++] = ctx->i32;
		} else {
			params[ctx->param_tess_offchip = num_params++] = ctx->i32;
			declare_streamout_params(ctx, &shader->selector->so,
						 params, ctx->i32, &num_params);
			params[ctx->param_oc_lds = num_params++] = ctx->i32;
		}
		last_sgpr = num_params - 1;

		/* VGPRs */
		params[ctx->param_tes_u = num_params++] = ctx->f32;
		params[ctx->param_tes_v = num_params++] = ctx->f32;
		params[ctx->param_tes_rel_patch_id = num_params++] = ctx->i32;
		params[ctx->param_tes_patch_id = num_params++] = ctx->i32;

		/* PrimitiveID output. */
		if (!ctx->is_monolithic && !shader->key.tes.as_es)
			for (i = 0; i <= VS_EPILOG_PRIMID_LOC; i++)
				returns[num_returns++] = ctx->f32;
		break;

	case PIPE_SHADER_GEOMETRY:
		params[SI_PARAM_GS2VS_OFFSET] = ctx->i32;
		params[SI_PARAM_GS_WAVE_ID] = ctx->i32;
		last_sgpr = SI_PARAM_GS_WAVE_ID;

		/* VGPRs */
		params[SI_PARAM_VTX0_OFFSET] = ctx->i32;
		params[SI_PARAM_VTX1_OFFSET] = ctx->i32;
		params[SI_PARAM_PRIMITIVE_ID] = ctx->i32;
		params[SI_PARAM_VTX2_OFFSET] = ctx->i32;
		params[SI_PARAM_VTX3_OFFSET] = ctx->i32;
		params[SI_PARAM_VTX4_OFFSET] = ctx->i32;
		params[SI_PARAM_VTX5_OFFSET] = ctx->i32;
		params[SI_PARAM_GS_INSTANCE_ID] = ctx->i32;
		num_params = SI_PARAM_GS_INSTANCE_ID+1;
		break;

	case PIPE_SHADER_FRAGMENT:
		params[SI_PARAM_ALPHA_REF] = ctx->f32;
		params[SI_PARAM_PRIM_MASK] = ctx->i32;
		last_sgpr = SI_PARAM_PRIM_MASK;
		params[SI_PARAM_PERSP_SAMPLE] = ctx->v2i32;
		params[SI_PARAM_PERSP_CENTER] = ctx->v2i32;
		params[SI_PARAM_PERSP_CENTROID] = ctx->v2i32;
		params[SI_PARAM_PERSP_PULL_MODEL] = v3i32;
		params[SI_PARAM_LINEAR_SAMPLE] = ctx->v2i32;
		params[SI_PARAM_LINEAR_CENTER] = ctx->v2i32;
		params[SI_PARAM_LINEAR_CENTROID] = ctx->v2i32;
		params[SI_PARAM_LINE_STIPPLE_TEX] = ctx->f32;
		params[SI_PARAM_POS_X_FLOAT] = ctx->f32;
		params[SI_PARAM_POS_Y_FLOAT] = ctx->f32;
		params[SI_PARAM_POS_Z_FLOAT] = ctx->f32;
		params[SI_PARAM_POS_W_FLOAT] = ctx->f32;
		params[SI_PARAM_FRONT_FACE] = ctx->i32;
		params[SI_PARAM_ANCILLARY] = ctx->i32;
		params[SI_PARAM_SAMPLE_COVERAGE] = ctx->f32;
		params[SI_PARAM_POS_FIXED_PT] = ctx->i32;
		num_params = SI_PARAM_POS_FIXED_PT+1;

		if (!ctx->is_monolithic) {
			/* Color inputs from the prolog. */
			if (shader->selector->info.colors_read) {
				unsigned num_color_elements =
					util_bitcount(shader->selector->info.colors_read);

				assert(num_params + num_color_elements <= ARRAY_SIZE(params));
				for (i = 0; i < num_color_elements; i++)
					params[num_params++] = ctx->f32;
			}

			/* Outputs for the epilog. */
			num_return_sgprs = SI_SGPR_ALPHA_REF + 1;
			num_returns =
				num_return_sgprs +
				util_bitcount(shader->selector->info.colors_written) * 4 +
				shader->selector->info.writes_z +
				shader->selector->info.writes_stencil +
				shader->selector->info.writes_samplemask +
				1 /* SampleMaskIn */;

			num_returns = MAX2(num_returns,
					   num_return_sgprs +
					   PS_EPILOG_SAMPLEMASK_MIN_LOC + 1);

			for (i = 0; i < num_return_sgprs; i++)
				returns[i] = ctx->i32;
			for (; i < num_returns; i++)
				returns[i] = ctx->f32;
		}
		break;

	case PIPE_SHADER_COMPUTE:
		params[SI_PARAM_GRID_SIZE] = v3i32;
		params[SI_PARAM_BLOCK_SIZE] = v3i32;
		params[SI_PARAM_BLOCK_ID] = v3i32;
		last_sgpr = SI_PARAM_BLOCK_ID;

		params[SI_PARAM_THREAD_ID] = v3i32;
		num_params = SI_PARAM_THREAD_ID + 1;
		break;
	default:
		assert(0 && "unimplemented shader");
		return;
	}

	assert(num_params <= ARRAY_SIZE(params));

	si_create_function(ctx, returns, num_returns, params,
			   num_params, last_sgpr);

	/* Reserve register locations for VGPR inputs the PS prolog may need. */
	if (ctx->type == PIPE_SHADER_FRAGMENT &&
	    !ctx->is_monolithic) {
		si_llvm_add_attribute(ctx->main_fn,
				      "InitialPSInputAddr",
				      S_0286D0_PERSP_SAMPLE_ENA(1) |
				      S_0286D0_PERSP_CENTER_ENA(1) |
				      S_0286D0_PERSP_CENTROID_ENA(1) |
				      S_0286D0_LINEAR_SAMPLE_ENA(1) |
				      S_0286D0_LINEAR_CENTER_ENA(1) |
				      S_0286D0_LINEAR_CENTROID_ENA(1) |
				      S_0286D0_FRONT_FACE_ENA(1) |
				      S_0286D0_POS_FIXED_PT_ENA(1));
	} else if (ctx->type == PIPE_SHADER_COMPUTE) {
		si_llvm_add_attribute(ctx->main_fn,
				      "amdgpu-max-work-group-size",
				      si_get_max_workgroup_size(shader));
	}

	shader->info.num_input_sgprs = 0;
	shader->info.num_input_vgprs = 0;

	for (i = 0; i <= last_sgpr; ++i)
		shader->info.num_input_sgprs += llvm_get_type_size(params[i]) / 4;

	/* Unused fragment shader inputs are eliminated by the compiler,
	 * so we don't know yet how many there will be.
	 */
	if (ctx->type != PIPE_SHADER_FRAGMENT)
		for (; i < num_params; ++i)
			shader->info.num_input_vgprs += llvm_get_type_size(params[i]) / 4;

	if (!ctx->screen->has_ds_bpermute &&
	    bld_base->info &&
	    (bld_base->info->opcode_count[TGSI_OPCODE_DDX] > 0 ||
	     bld_base->info->opcode_count[TGSI_OPCODE_DDY] > 0 ||
	     bld_base->info->opcode_count[TGSI_OPCODE_DDX_FINE] > 0 ||
	     bld_base->info->opcode_count[TGSI_OPCODE_DDY_FINE] > 0 ||
	     bld_base->info->opcode_count[TGSI_OPCODE_INTERP_OFFSET] > 0 ||
	     bld_base->info->opcode_count[TGSI_OPCODE_INTERP_SAMPLE] > 0))
		ctx->lds =
			LLVMAddGlobalInAddressSpace(gallivm->module,
						    LLVMArrayType(ctx->i32, 64),
						    "ddxy_lds",
						    LOCAL_ADDR_SPACE);

	if ((ctx->type == PIPE_SHADER_VERTEX && shader->key.vs.as_ls) ||
	    ctx->type == PIPE_SHADER_TESS_CTRL ||
	    ctx->type == PIPE_SHADER_TESS_EVAL)
		declare_tess_lds(ctx);
}

/**
 * Load ESGS and GSVS ring buffer resource descriptors and save the variables
 * for later use.
 */
static void preload_ring_buffers(struct si_shader_context *ctx)
{
	struct gallivm_state *gallivm =
		ctx->soa.bld_base.base.gallivm;

	LLVMValueRef buf_ptr = LLVMGetParam(ctx->main_fn,
					    SI_PARAM_RW_BUFFERS);

	if ((ctx->type == PIPE_SHADER_VERTEX &&
	     ctx->shader->key.vs.as_es) ||
	    (ctx->type == PIPE_SHADER_TESS_EVAL &&
	     ctx->shader->key.tes.as_es) ||
	    ctx->type == PIPE_SHADER_GEOMETRY) {
		unsigned ring =
			ctx->type == PIPE_SHADER_GEOMETRY ? SI_GS_RING_ESGS
							     : SI_ES_RING_ESGS;
		LLVMValueRef offset = lp_build_const_int32(gallivm, ring);

		ctx->esgs_ring =
			build_indexed_load_const(ctx, buf_ptr, offset);
	}

	if (ctx->is_gs_copy_shader) {
		LLVMValueRef offset = lp_build_const_int32(gallivm, SI_VS_RING_GSVS);

		ctx->gsvs_ring[0] =
			build_indexed_load_const(ctx, buf_ptr, offset);
	}
	if (ctx->type == PIPE_SHADER_GEOMETRY) {
		int i;
		for (i = 0; i < 4; i++) {
			LLVMValueRef offset = lp_build_const_int32(gallivm, SI_GS_RING_GSVS0 + i);

			ctx->gsvs_ring[i] =
				build_indexed_load_const(ctx, buf_ptr, offset);
		}
	}
}

static void si_llvm_emit_polygon_stipple(struct si_shader_context *ctx,
					 LLVMValueRef param_rw_buffers,
					 unsigned param_pos_fixed_pt)
{
	struct lp_build_tgsi_context *bld_base =
		&ctx->soa.bld_base;
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	LLVMValueRef slot, desc, offset, row, bit, address[2];

	/* Use the fixed-point gl_FragCoord input.
	 * Since the stipple pattern is 32x32 and it repeats, just get 5 bits
	 * per coordinate to get the repeating effect.
	 */
	address[0] = unpack_param(ctx, param_pos_fixed_pt, 0, 5);
	address[1] = unpack_param(ctx, param_pos_fixed_pt, 16, 5);

	/* Load the buffer descriptor. */
	slot = lp_build_const_int32(gallivm, SI_PS_CONST_POLY_STIPPLE);
	desc = build_indexed_load_const(ctx, param_rw_buffers, slot);

	/* The stipple pattern is 32x32, each row has 32 bits. */
	offset = LLVMBuildMul(builder, address[1],
			      LLVMConstInt(ctx->i32, 4, 0), "");
	row = buffer_load_const(ctx, desc, offset);
	row = LLVMBuildBitCast(builder, row, ctx->i32, "");
	bit = LLVMBuildLShr(builder, row, address[0], "");
	bit = LLVMBuildTrunc(builder, bit, ctx->i1, "");

	/* The intrinsic kills the thread if arg < 0. */
	bit = LLVMBuildSelect(builder, bit, LLVMConstReal(ctx->f32, 0),
			      LLVMConstReal(ctx->f32, -1), "");
	lp_build_intrinsic(builder, "llvm.AMDGPU.kill", ctx->voidt, &bit, 1, 0);
}

void si_shader_binary_read_config(struct radeon_shader_binary *binary,
				  struct si_shader_config *conf,
				  unsigned symbol_offset)
{
	unsigned i;
	const unsigned char *config =
		radeon_shader_binary_config_start(binary, symbol_offset);
	bool really_needs_scratch = false;

	/* LLVM adds SGPR spills to the scratch size.
	 * Find out if we really need the scratch buffer.
	 */
	for (i = 0; i < binary->reloc_count; i++) {
		const struct radeon_shader_reloc *reloc = &binary->relocs[i];

		if (!strcmp(scratch_rsrc_dword0_symbol, reloc->name) ||
		    !strcmp(scratch_rsrc_dword1_symbol, reloc->name)) {
			really_needs_scratch = true;
			break;
		}
	}

	/* XXX: We may be able to emit some of these values directly rather than
	 * extracting fields to be emitted later.
	 */

	for (i = 0; i < binary->config_size_per_symbol; i+= 8) {
		unsigned reg = util_le32_to_cpu(*(uint32_t*)(config + i));
		unsigned value = util_le32_to_cpu(*(uint32_t*)(config + i + 4));
		switch (reg) {
		case R_00B028_SPI_SHADER_PGM_RSRC1_PS:
		case R_00B128_SPI_SHADER_PGM_RSRC1_VS:
		case R_00B228_SPI_SHADER_PGM_RSRC1_GS:
		case R_00B848_COMPUTE_PGM_RSRC1:
			conf->num_sgprs = MAX2(conf->num_sgprs, (G_00B028_SGPRS(value) + 1) * 8);
			conf->num_vgprs = MAX2(conf->num_vgprs, (G_00B028_VGPRS(value) + 1) * 4);
			conf->float_mode =  G_00B028_FLOAT_MODE(value);
			conf->rsrc1 = value;
			break;
		case R_00B02C_SPI_SHADER_PGM_RSRC2_PS:
			conf->lds_size = MAX2(conf->lds_size, G_00B02C_EXTRA_LDS_SIZE(value));
			break;
		case R_00B84C_COMPUTE_PGM_RSRC2:
			conf->lds_size = MAX2(conf->lds_size, G_00B84C_LDS_SIZE(value));
			conf->rsrc2 = value;
			break;
		case R_0286CC_SPI_PS_INPUT_ENA:
			conf->spi_ps_input_ena = value;
			break;
		case R_0286D0_SPI_PS_INPUT_ADDR:
			conf->spi_ps_input_addr = value;
			break;
		case R_0286E8_SPI_TMPRING_SIZE:
		case R_00B860_COMPUTE_TMPRING_SIZE:
			/* WAVESIZE is in units of 256 dwords. */
			if (really_needs_scratch)
				conf->scratch_bytes_per_wave =
					G_00B860_WAVESIZE(value) * 256 * 4;
			break;
		case 0x4: /* SPILLED_SGPRS */
			conf->spilled_sgprs = value;
			break;
		case 0x8: /* SPILLED_VGPRS */
			conf->spilled_vgprs = value;
			break;
		default:
			{
				static bool printed;

				if (!printed) {
					fprintf(stderr, "Warning: LLVM emitted unknown "
						"config register: 0x%x\n", reg);
					printed = true;
				}
			}
			break;
		}
	}

	if (!conf->spi_ps_input_addr)
		conf->spi_ps_input_addr = conf->spi_ps_input_ena;
}

void si_shader_apply_scratch_relocs(struct si_context *sctx,
			struct si_shader *shader,
			struct si_shader_config *config,
			uint64_t scratch_va)
{
	unsigned i;
	uint32_t scratch_rsrc_dword0 = scratch_va;
	uint32_t scratch_rsrc_dword1 =
		S_008F04_BASE_ADDRESS_HI(scratch_va >> 32);

	/* Enable scratch coalescing if LLVM sets ELEMENT_SIZE & INDEX_STRIDE
	 * correctly.
	 */
	if (HAVE_LLVM >= 0x0309)
		scratch_rsrc_dword1 |= S_008F04_SWIZZLE_ENABLE(1);
	else
		scratch_rsrc_dword1 |=
			S_008F04_STRIDE(config->scratch_bytes_per_wave / 64);

	for (i = 0 ; i < shader->binary.reloc_count; i++) {
		const struct radeon_shader_reloc *reloc =
					&shader->binary.relocs[i];
		if (!strcmp(scratch_rsrc_dword0_symbol, reloc->name)) {
			util_memcpy_cpu_to_le32(shader->binary.code + reloc->offset,
			&scratch_rsrc_dword0, 4);
		} else if (!strcmp(scratch_rsrc_dword1_symbol, reloc->name)) {
			util_memcpy_cpu_to_le32(shader->binary.code + reloc->offset,
			&scratch_rsrc_dword1, 4);
		}
	}
}

static unsigned si_get_shader_binary_size(struct si_shader *shader)
{
	unsigned size = shader->binary.code_size;

	if (shader->prolog)
		size += shader->prolog->binary.code_size;
	if (shader->epilog)
		size += shader->epilog->binary.code_size;
	return size;
}

int si_shader_binary_upload(struct si_screen *sscreen, struct si_shader *shader)
{
	const struct radeon_shader_binary *prolog =
		shader->prolog ? &shader->prolog->binary : NULL;
	const struct radeon_shader_binary *epilog =
		shader->epilog ? &shader->epilog->binary : NULL;
	const struct radeon_shader_binary *mainb = &shader->binary;
	unsigned bo_size = si_get_shader_binary_size(shader) +
			   (!epilog ? mainb->rodata_size : 0);
	unsigned char *ptr;

	assert(!prolog || !prolog->rodata_size);
	assert((!prolog && !epilog) || !mainb->rodata_size);
	assert(!epilog || !epilog->rodata_size);

	r600_resource_reference(&shader->bo, NULL);
	shader->bo = si_resource_create_custom(&sscreen->b.b,
					       PIPE_USAGE_IMMUTABLE,
					       bo_size);
	if (!shader->bo)
		return -ENOMEM;

	/* Upload. */
	ptr = sscreen->b.ws->buffer_map(shader->bo->buf, NULL,
					PIPE_TRANSFER_READ_WRITE);

	if (prolog) {
		util_memcpy_cpu_to_le32(ptr, prolog->code, prolog->code_size);
		ptr += prolog->code_size;
	}

	util_memcpy_cpu_to_le32(ptr, mainb->code, mainb->code_size);
	ptr += mainb->code_size;

	if (epilog)
		util_memcpy_cpu_to_le32(ptr, epilog->code, epilog->code_size);
	else if (mainb->rodata_size > 0)
		util_memcpy_cpu_to_le32(ptr, mainb->rodata, mainb->rodata_size);

	sscreen->b.ws->buffer_unmap(shader->bo->buf);
	return 0;
}

static void si_shader_dump_disassembly(const struct radeon_shader_binary *binary,
				       struct pipe_debug_callback *debug,
				       const char *name, FILE *file)
{
	char *line, *p;
	unsigned i, count;

	if (binary->disasm_string) {
		fprintf(file, "Shader %s disassembly:\n", name);
		fprintf(file, "%s", binary->disasm_string);

		if (debug && debug->debug_message) {
			/* Very long debug messages are cut off, so send the
			 * disassembly one line at a time. This causes more
			 * overhead, but on the plus side it simplifies
			 * parsing of resulting logs.
			 */
			pipe_debug_message(debug, SHADER_INFO,
					   "Shader Disassembly Begin");

			line = binary->disasm_string;
			while (*line) {
				p = util_strchrnul(line, '\n');
				count = p - line;

				if (count) {
					pipe_debug_message(debug, SHADER_INFO,
							   "%.*s", count, line);
				}

				if (!*p)
					break;
				line = p + 1;
			}

			pipe_debug_message(debug, SHADER_INFO,
					   "Shader Disassembly End");
		}
	} else {
		fprintf(file, "Shader %s binary:\n", name);
		for (i = 0; i < binary->code_size; i += 4) {
			fprintf(file, "@@0x%x: %02x%02x%02x%02x\n", i,
				binary->code[i + 3], binary->code[i + 2],
				binary->code[i + 1], binary->code[i]);
		}
	}
}

static void si_shader_dump_stats(struct si_screen *sscreen,
			         struct si_shader_config *conf,
				 unsigned num_inputs,
				 unsigned code_size,
			         struct pipe_debug_callback *debug,
			         unsigned processor,
				 FILE *file)
{
	unsigned lds_increment = sscreen->b.chip_class >= CIK ? 512 : 256;
	unsigned lds_per_wave = 0;
	unsigned max_simd_waves = 10;

	/* Compute LDS usage for PS. */
	if (processor == PIPE_SHADER_FRAGMENT) {
		/* The minimum usage per wave is (num_inputs * 48). The maximum
		 * usage is (num_inputs * 48 * 16).
		 * We can get anything in between and it varies between waves.
		 *
		 * The 48 bytes per input for a single primitive is equal to
		 * 4 bytes/component * 4 components/input * 3 points.
		 *
		 * Other stages don't know the size at compile time or don't
		 * allocate LDS per wave, but instead they do it per thread group.
		 */
		lds_per_wave = conf->lds_size * lds_increment +
			       align(num_inputs * 48, lds_increment);
	}

	/* Compute the per-SIMD wave counts. */
	if (conf->num_sgprs) {
		if (sscreen->b.chip_class >= VI)
			max_simd_waves = MIN2(max_simd_waves, 800 / conf->num_sgprs);
		else
			max_simd_waves = MIN2(max_simd_waves, 512 / conf->num_sgprs);
	}

	if (conf->num_vgprs)
		max_simd_waves = MIN2(max_simd_waves, 256 / conf->num_vgprs);

	/* LDS is 64KB per CU (4 SIMDs), divided into 16KB blocks per SIMD
	 * that PS can use.
	 */
	if (lds_per_wave)
		max_simd_waves = MIN2(max_simd_waves, 16384 / lds_per_wave);

	if (file != stderr ||
	    r600_can_dump_shader(&sscreen->b, processor)) {
		if (processor == PIPE_SHADER_FRAGMENT) {
			fprintf(file, "*** SHADER CONFIG ***\n"
				"SPI_PS_INPUT_ADDR = 0x%04x\n"
				"SPI_PS_INPUT_ENA  = 0x%04x\n",
				conf->spi_ps_input_addr, conf->spi_ps_input_ena);
		}

		fprintf(file, "*** SHADER STATS ***\n"
			"SGPRS: %d\n"
			"VGPRS: %d\n"
		        "Spilled SGPRs: %d\n"
			"Spilled VGPRs: %d\n"
			"Code Size: %d bytes\n"
			"LDS: %d blocks\n"
			"Scratch: %d bytes per wave\n"
			"Max Waves: %d\n"
			"********************\n\n\n",
			conf->num_sgprs, conf->num_vgprs,
			conf->spilled_sgprs, conf->spilled_vgprs, code_size,
			conf->lds_size, conf->scratch_bytes_per_wave,
			max_simd_waves);
	}

	pipe_debug_message(debug, SHADER_INFO,
			   "Shader Stats: SGPRS: %d VGPRS: %d Code Size: %d "
			   "LDS: %d Scratch: %d Max Waves: %d Spilled SGPRs: %d "
			   "Spilled VGPRs: %d",
			   conf->num_sgprs, conf->num_vgprs, code_size,
			   conf->lds_size, conf->scratch_bytes_per_wave,
			   max_simd_waves, conf->spilled_sgprs,
			   conf->spilled_vgprs);
}

static const char *si_get_shader_name(struct si_shader *shader,
				      unsigned processor)
{
	switch (processor) {
	case PIPE_SHADER_VERTEX:
		if (shader->key.vs.as_es)
			return "Vertex Shader as ES";
		else if (shader->key.vs.as_ls)
			return "Vertex Shader as LS";
		else
			return "Vertex Shader as VS";
	case PIPE_SHADER_TESS_CTRL:
		return "Tessellation Control Shader";
	case PIPE_SHADER_TESS_EVAL:
		if (shader->key.tes.as_es)
			return "Tessellation Evaluation Shader as ES";
		else
			return "Tessellation Evaluation Shader as VS";
	case PIPE_SHADER_GEOMETRY:
		if (shader->gs_copy_shader == NULL)
			return "GS Copy Shader as VS";
		else
			return "Geometry Shader";
	case PIPE_SHADER_FRAGMENT:
		return "Pixel Shader";
	case PIPE_SHADER_COMPUTE:
		return "Compute Shader";
	default:
		return "Unknown Shader";
	}
}

void si_shader_dump(struct si_screen *sscreen, struct si_shader *shader,
		    struct pipe_debug_callback *debug, unsigned processor,
		    FILE *file)
{
	if (file != stderr ||
	    r600_can_dump_shader(&sscreen->b, processor))
		si_dump_shader_key(processor, &shader->key, file);

	if (file != stderr && shader->binary.llvm_ir_string) {
		fprintf(file, "\n%s - main shader part - LLVM IR:\n\n",
			si_get_shader_name(shader, processor));
		fprintf(file, "%s\n", shader->binary.llvm_ir_string);
	}

	if (file != stderr ||
	    (r600_can_dump_shader(&sscreen->b, processor) &&
	     !(sscreen->b.debug_flags & DBG_NO_ASM))) {
		fprintf(file, "\n%s:\n", si_get_shader_name(shader, processor));

		if (shader->prolog)
			si_shader_dump_disassembly(&shader->prolog->binary,
						   debug, "prolog", file);

		si_shader_dump_disassembly(&shader->binary, debug, "main", file);

		if (shader->epilog)
			si_shader_dump_disassembly(&shader->epilog->binary,
						   debug, "epilog", file);
		fprintf(file, "\n");
	}

	si_shader_dump_stats(sscreen, &shader->config,
			     shader->selector ? shader->selector->info.num_inputs : 0,
			     si_get_shader_binary_size(shader), debug, processor,
			     file);
}

int si_compile_llvm(struct si_screen *sscreen,
		    struct radeon_shader_binary *binary,
		    struct si_shader_config *conf,
		    LLVMTargetMachineRef tm,
		    LLVMModuleRef mod,
		    struct pipe_debug_callback *debug,
		    unsigned processor,
		    const char *name)
{
	int r = 0;
	unsigned count = p_atomic_inc_return(&sscreen->b.num_compilations);

	if (r600_can_dump_shader(&sscreen->b, processor)) {
		fprintf(stderr, "radeonsi: Compiling shader %d\n", count);

		if (!(sscreen->b.debug_flags & (DBG_NO_IR | DBG_PREOPT_IR))) {
			fprintf(stderr, "%s LLVM IR:\n\n", name);
			LLVMDumpModule(mod);
			fprintf(stderr, "\n");
		}
	}

	if (sscreen->record_llvm_ir) {
		char *ir = LLVMPrintModuleToString(mod);
		binary->llvm_ir_string = strdup(ir);
		LLVMDisposeMessage(ir);
	}

	if (!si_replace_shader(count, binary)) {
		r = si_llvm_compile(mod, binary, tm, debug);
		if (r)
			return r;
	}

	si_shader_binary_read_config(binary, conf, 0);

	/* Enable 64-bit and 16-bit denormals, because there is no performance
	 * cost.
	 *
	 * If denormals are enabled, all floating-point output modifiers are
	 * ignored.
	 *
	 * Don't enable denormals for 32-bit floats, because:
	 * - Floating-point output modifiers would be ignored by the hw.
	 * - Some opcodes don't support denormals, such as v_mad_f32. We would
	 *   have to stop using those.
	 * - SI & CI would be very slow.
	 */
	conf->float_mode |= V_00B028_FP_64_DENORMS;

	FREE(binary->config);
	FREE(binary->global_symbol_offsets);
	binary->config = NULL;
	binary->global_symbol_offsets = NULL;

	/* Some shaders can't have rodata because their binaries can be
	 * concatenated.
	 */
	if (binary->rodata_size &&
	    (processor == PIPE_SHADER_VERTEX ||
	     processor == PIPE_SHADER_TESS_CTRL ||
	     processor == PIPE_SHADER_TESS_EVAL ||
	     processor == PIPE_SHADER_FRAGMENT)) {
		fprintf(stderr, "radeonsi: The shader can't have rodata.");
		return -EINVAL;
	}

	return r;
}

static void si_llvm_build_ret(struct si_shader_context *ctx, LLVMValueRef ret)
{
	if (LLVMGetTypeKind(LLVMTypeOf(ret)) == LLVMVoidTypeKind)
		LLVMBuildRetVoid(ctx->gallivm.builder);
	else
		LLVMBuildRet(ctx->gallivm.builder, ret);
}

/* Generate code for the hardware VS shader stage to go with a geometry shader */
static int si_generate_gs_copy_shader(struct si_screen *sscreen,
				      struct si_shader_context *ctx,
				      struct si_shader *gs,
				      struct pipe_debug_callback *debug)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx->soa.bld_base;
	struct lp_build_context *uint = &bld_base->uint_bld;
	struct si_shader_output_values *outputs;
	struct tgsi_shader_info *gsinfo = &gs->selector->info;
	LLVMValueRef args[9];
	int i, r;

	outputs = MALLOC(gsinfo->num_outputs * sizeof(outputs[0]));

	si_init_shader_ctx(ctx, sscreen, ctx->shader, ctx->tm);
	ctx->type = PIPE_SHADER_VERTEX;
	ctx->is_gs_copy_shader = true;

	create_meta_data(ctx);
	create_function(ctx);
	preload_ring_buffers(ctx);

	args[0] = ctx->gsvs_ring[0];
	args[1] = lp_build_mul_imm(uint,
				   LLVMGetParam(ctx->main_fn,
						ctx->param_vertex_id),
				   4);
	args[3] = uint->zero;
	args[4] = uint->one;  /* OFFEN */
	args[5] = uint->zero; /* IDXEN */
	args[6] = uint->one;  /* GLC */
	args[7] = uint->one;  /* SLC */
	args[8] = uint->zero; /* TFE */

	/* Fetch vertex data from GSVS ring */
	for (i = 0; i < gsinfo->num_outputs; ++i) {
		unsigned chan;

		outputs[i].name = gsinfo->output_semantic_name[i];
		outputs[i].sid = gsinfo->output_semantic_index[i];

		for (chan = 0; chan < 4; chan++) {
			args[2] = lp_build_const_int32(gallivm,
						       (i * 4 + chan) *
						       gs->selector->gs_max_out_vertices * 16 * 4);

			outputs[i].values[chan] =
				LLVMBuildBitCast(gallivm->builder,
						 lp_build_intrinsic(gallivm->builder,
								 "llvm.SI.buffer.load.dword.i32.i32",
								 ctx->i32, args, 9,
								 LLVMReadOnlyAttribute),
						 ctx->f32, "");
		}
	}

	si_llvm_export_vs(bld_base, outputs, gsinfo->num_outputs);

	LLVMBuildRetVoid(gallivm->builder);

	/* Dump LLVM IR before any optimization passes */
	if (sscreen->b.debug_flags & DBG_PREOPT_IR &&
	    r600_can_dump_shader(&sscreen->b, PIPE_SHADER_GEOMETRY))
		LLVMDumpModule(bld_base->base.gallivm->module);

	si_llvm_finalize_module(ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_GEOMETRY));

	r = si_compile_llvm(sscreen, &ctx->shader->binary,
			    &ctx->shader->config, ctx->tm,
			    bld_base->base.gallivm->module,
			    debug, PIPE_SHADER_GEOMETRY,
			    "GS Copy Shader");
	if (!r) {
		if (r600_can_dump_shader(&sscreen->b, PIPE_SHADER_GEOMETRY))
			fprintf(stderr, "GS Copy Shader:\n");
		si_shader_dump(sscreen, ctx->shader, debug,
			       PIPE_SHADER_GEOMETRY, stderr);
		r = si_shader_binary_upload(sscreen, ctx->shader);
	}

	si_llvm_dispose(ctx);

	FREE(outputs);
	return r;
}

static void si_dump_shader_key(unsigned shader, union si_shader_key *key,
			       FILE *f)
{
	int i;

	fprintf(f, "SHADER KEY\n");

	switch (shader) {
	case PIPE_SHADER_VERTEX:
		fprintf(f, "  instance_divisors = {");
		for (i = 0; i < ARRAY_SIZE(key->vs.prolog.instance_divisors); i++)
			fprintf(f, !i ? "%u" : ", %u",
				key->vs.prolog.instance_divisors[i]);
		fprintf(f, "}\n");
		fprintf(f, "  as_es = %u\n", key->vs.as_es);
		fprintf(f, "  as_ls = %u\n", key->vs.as_ls);
		fprintf(f, "  export_prim_id = %u\n", key->vs.epilog.export_prim_id);
		break;

	case PIPE_SHADER_TESS_CTRL:
		fprintf(f, "  prim_mode = %u\n", key->tcs.epilog.prim_mode);
		break;

	case PIPE_SHADER_TESS_EVAL:
		fprintf(f, "  as_es = %u\n", key->tes.as_es);
		fprintf(f, "  export_prim_id = %u\n", key->tes.epilog.export_prim_id);
		break;

	case PIPE_SHADER_GEOMETRY:
	case PIPE_SHADER_COMPUTE:
		break;

	case PIPE_SHADER_FRAGMENT:
		fprintf(f, "  prolog.color_two_side = %u\n", key->ps.prolog.color_two_side);
		fprintf(f, "  prolog.flatshade_colors = %u\n", key->ps.prolog.flatshade_colors);
		fprintf(f, "  prolog.poly_stipple = %u\n", key->ps.prolog.poly_stipple);
		fprintf(f, "  prolog.force_persp_sample_interp = %u\n", key->ps.prolog.force_persp_sample_interp);
		fprintf(f, "  prolog.force_linear_sample_interp = %u\n", key->ps.prolog.force_linear_sample_interp);
		fprintf(f, "  prolog.force_persp_center_interp = %u\n", key->ps.prolog.force_persp_center_interp);
		fprintf(f, "  prolog.force_linear_center_interp = %u\n", key->ps.prolog.force_linear_center_interp);
		fprintf(f, "  prolog.bc_optimize_for_persp = %u\n", key->ps.prolog.bc_optimize_for_persp);
		fprintf(f, "  prolog.bc_optimize_for_linear = %u\n", key->ps.prolog.bc_optimize_for_linear);
		fprintf(f, "  epilog.spi_shader_col_format = 0x%x\n", key->ps.epilog.spi_shader_col_format);
		fprintf(f, "  epilog.color_is_int8 = 0x%X\n", key->ps.epilog.color_is_int8);
		fprintf(f, "  epilog.color_is_int10 = 0x%X\n", key->ps.epilog.color_is_int10);
		fprintf(f, "  epilog.last_cbuf = %u\n", key->ps.epilog.last_cbuf);
		fprintf(f, "  epilog.alpha_func = %u\n", key->ps.epilog.alpha_func);
		fprintf(f, "  epilog.alpha_to_one = %u\n", key->ps.epilog.alpha_to_one);
		fprintf(f, "  epilog.poly_line_smoothing = %u\n", key->ps.epilog.poly_line_smoothing);
		fprintf(f, "  epilog.clamp_color = %u\n", key->ps.epilog.clamp_color);
		break;

	default:
		assert(0);
	}
}

static void si_init_shader_ctx(struct si_shader_context *ctx,
			       struct si_screen *sscreen,
			       struct si_shader *shader,
			       LLVMTargetMachineRef tm)
{
	struct lp_build_tgsi_context *bld_base;
	struct lp_build_tgsi_action tmpl = {};

	memset(ctx, 0, sizeof(*ctx));
	si_llvm_context_init(
		ctx, "amdgcn--",
		(shader && shader->selector) ? &shader->selector->info : NULL,
		(shader && shader->selector) ? shader->selector->tokens : NULL);
	si_shader_context_init_alu(&ctx->soa.bld_base);
	ctx->tm = tm;
	ctx->screen = sscreen;
	if (shader && shader->selector)
		ctx->type = shader->selector->info.processor;
	else
		ctx->type = -1;
	ctx->shader = shader;

	ctx->voidt = LLVMVoidTypeInContext(ctx->gallivm.context);
	ctx->i1 = LLVMInt1TypeInContext(ctx->gallivm.context);
	ctx->i8 = LLVMInt8TypeInContext(ctx->gallivm.context);
	ctx->i32 = LLVMInt32TypeInContext(ctx->gallivm.context);
	ctx->i64 = LLVMInt64TypeInContext(ctx->gallivm.context);
	ctx->i128 = LLVMIntTypeInContext(ctx->gallivm.context, 128);
	ctx->f32 = LLVMFloatTypeInContext(ctx->gallivm.context);
	ctx->v16i8 = LLVMVectorType(ctx->i8, 16);
	ctx->v2i32 = LLVMVectorType(ctx->i32, 2);
	ctx->v4i32 = LLVMVectorType(ctx->i32, 4);
	ctx->v4f32 = LLVMVectorType(ctx->f32, 4);
	ctx->v8i32 = LLVMVectorType(ctx->i32, 8);

	bld_base = &ctx->soa.bld_base;
	bld_base->emit_fetch_funcs[TGSI_FILE_CONSTANT] = fetch_constant;

	bld_base->op_actions[TGSI_OPCODE_INTERP_CENTROID] = interp_action;
	bld_base->op_actions[TGSI_OPCODE_INTERP_SAMPLE] = interp_action;
	bld_base->op_actions[TGSI_OPCODE_INTERP_OFFSET] = interp_action;

	bld_base->op_actions[TGSI_OPCODE_TEX] = tex_action;
	bld_base->op_actions[TGSI_OPCODE_TEX2] = tex_action;
	bld_base->op_actions[TGSI_OPCODE_TXB] = tex_action;
	bld_base->op_actions[TGSI_OPCODE_TXB2] = tex_action;
	bld_base->op_actions[TGSI_OPCODE_TXD] = tex_action;
	bld_base->op_actions[TGSI_OPCODE_TXF] = tex_action;
	bld_base->op_actions[TGSI_OPCODE_TXL] = tex_action;
	bld_base->op_actions[TGSI_OPCODE_TXL2] = tex_action;
	bld_base->op_actions[TGSI_OPCODE_TXP] = tex_action;
	bld_base->op_actions[TGSI_OPCODE_TXQ].fetch_args = txq_fetch_args;
	bld_base->op_actions[TGSI_OPCODE_TXQ].emit = txq_emit;
	bld_base->op_actions[TGSI_OPCODE_TG4] = tex_action;
	bld_base->op_actions[TGSI_OPCODE_LODQ] = tex_action;
	bld_base->op_actions[TGSI_OPCODE_TXQS].emit = si_llvm_emit_txqs;

	bld_base->op_actions[TGSI_OPCODE_LOAD].fetch_args = load_fetch_args;
	bld_base->op_actions[TGSI_OPCODE_LOAD].emit = load_emit;
	bld_base->op_actions[TGSI_OPCODE_STORE].fetch_args = store_fetch_args;
	bld_base->op_actions[TGSI_OPCODE_STORE].emit = store_emit;
	bld_base->op_actions[TGSI_OPCODE_RESQ].fetch_args = resq_fetch_args;
	bld_base->op_actions[TGSI_OPCODE_RESQ].emit = resq_emit;

	tmpl.fetch_args = atomic_fetch_args;
	tmpl.emit = atomic_emit;
	bld_base->op_actions[TGSI_OPCODE_ATOMUADD] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMUADD].intr_name = "add";
	bld_base->op_actions[TGSI_OPCODE_ATOMXCHG] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMXCHG].intr_name = "swap";
	bld_base->op_actions[TGSI_OPCODE_ATOMCAS] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMCAS].intr_name = "cmpswap";
	bld_base->op_actions[TGSI_OPCODE_ATOMAND] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMAND].intr_name = "and";
	bld_base->op_actions[TGSI_OPCODE_ATOMOR] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMOR].intr_name = "or";
	bld_base->op_actions[TGSI_OPCODE_ATOMXOR] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMXOR].intr_name = "xor";
	bld_base->op_actions[TGSI_OPCODE_ATOMUMIN] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMUMIN].intr_name = "umin";
	bld_base->op_actions[TGSI_OPCODE_ATOMUMAX] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMUMAX].intr_name = "umax";
	bld_base->op_actions[TGSI_OPCODE_ATOMIMIN] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMIMIN].intr_name = "smin";
	bld_base->op_actions[TGSI_OPCODE_ATOMIMAX] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMIMAX].intr_name = "smax";

	bld_base->op_actions[TGSI_OPCODE_MEMBAR].emit = membar_emit;

	bld_base->op_actions[TGSI_OPCODE_DDX].emit = si_llvm_emit_ddxy;
	bld_base->op_actions[TGSI_OPCODE_DDY].emit = si_llvm_emit_ddxy;
	bld_base->op_actions[TGSI_OPCODE_DDX_FINE].emit = si_llvm_emit_ddxy;
	bld_base->op_actions[TGSI_OPCODE_DDY_FINE].emit = si_llvm_emit_ddxy;

	bld_base->op_actions[TGSI_OPCODE_EMIT].emit = si_llvm_emit_vertex;
	bld_base->op_actions[TGSI_OPCODE_ENDPRIM].emit = si_llvm_emit_primitive;
	bld_base->op_actions[TGSI_OPCODE_BARRIER].emit = si_llvm_emit_barrier;
}

int si_compile_tgsi_shader(struct si_screen *sscreen,
			   LLVMTargetMachineRef tm,
			   struct si_shader *shader,
			   bool is_monolithic,
			   struct pipe_debug_callback *debug)
{
	struct si_shader_selector *sel = shader->selector;
	struct si_shader_context ctx;
	struct lp_build_tgsi_context *bld_base;
	LLVMModuleRef mod;
	int r = 0;

	/* Dump TGSI code before doing TGSI->LLVM conversion in case the
	 * conversion fails. */
	if (r600_can_dump_shader(&sscreen->b, sel->info.processor) &&
	    !(sscreen->b.debug_flags & DBG_NO_TGSI)) {
		tgsi_dump(sel->tokens, 0);
		si_dump_streamout(&sel->so);
	}

	si_init_shader_ctx(&ctx, sscreen, shader, tm);
	ctx.is_monolithic = is_monolithic;

	shader->info.uses_instanceid = sel->info.uses_instanceid;

	bld_base = &ctx.soa.bld_base;
	ctx.load_system_value = declare_system_value;

	switch (ctx.type) {
	case PIPE_SHADER_VERTEX:
		ctx.load_input = declare_input_vs;
		if (shader->key.vs.as_ls)
			bld_base->emit_epilogue = si_llvm_emit_ls_epilogue;
		else if (shader->key.vs.as_es)
			bld_base->emit_epilogue = si_llvm_emit_es_epilogue;
		else
			bld_base->emit_epilogue = si_llvm_emit_vs_epilogue;
		break;
	case PIPE_SHADER_TESS_CTRL:
		bld_base->emit_fetch_funcs[TGSI_FILE_INPUT] = fetch_input_tcs;
		bld_base->emit_fetch_funcs[TGSI_FILE_OUTPUT] = fetch_output_tcs;
		bld_base->emit_store = store_output_tcs;
		bld_base->emit_epilogue = si_llvm_emit_tcs_epilogue;
		break;
	case PIPE_SHADER_TESS_EVAL:
		bld_base->emit_fetch_funcs[TGSI_FILE_INPUT] = fetch_input_tes;
		if (shader->key.tes.as_es)
			bld_base->emit_epilogue = si_llvm_emit_es_epilogue;
		else
			bld_base->emit_epilogue = si_llvm_emit_vs_epilogue;
		break;
	case PIPE_SHADER_GEOMETRY:
		bld_base->emit_fetch_funcs[TGSI_FILE_INPUT] = fetch_input_gs;
		bld_base->emit_epilogue = si_llvm_emit_gs_epilogue;
		break;
	case PIPE_SHADER_FRAGMENT:
		ctx.load_input = declare_input_fs;
		if (is_monolithic)
			bld_base->emit_epilogue = si_llvm_emit_fs_epilogue;
		else
			bld_base->emit_epilogue = si_llvm_return_fs_outputs;
		break;
	case PIPE_SHADER_COMPUTE:
		ctx.declare_memory_region = declare_compute_memory;
		break;
	default:
		assert(!"Unsupported shader type");
		return -1;
	}

	create_meta_data(&ctx);
	create_function(&ctx);
	preload_ring_buffers(&ctx);

	if (ctx.is_monolithic && sel->type == PIPE_SHADER_FRAGMENT &&
	    shader->key.ps.prolog.poly_stipple) {
		LLVMValueRef list = LLVMGetParam(ctx.main_fn,
						 SI_PARAM_RW_BUFFERS);
		si_llvm_emit_polygon_stipple(&ctx, list,
					     SI_PARAM_POS_FIXED_PT);
	}

	if (ctx.type == PIPE_SHADER_GEOMETRY) {
		int i;
		for (i = 0; i < 4; i++) {
			ctx.gs_next_vertex[i] =
				lp_build_alloca(bld_base->base.gallivm,
						ctx.i32, "");
		}
	}

	if (!lp_build_tgsi_llvm(bld_base, sel->tokens)) {
		fprintf(stderr, "Failed to translate shader from TGSI to LLVM\n");
		goto out;
	}

	si_llvm_build_ret(&ctx, ctx.return_value);
	mod = bld_base->base.gallivm->module;

	/* Dump LLVM IR before any optimization passes */
	if (sscreen->b.debug_flags & DBG_PREOPT_IR &&
	    r600_can_dump_shader(&sscreen->b, ctx.type))
		LLVMDumpModule(mod);

	si_llvm_finalize_module(&ctx,
				    r600_extra_shader_checks(&sscreen->b, ctx.type));

	r = si_compile_llvm(sscreen, &shader->binary, &shader->config, tm,
			    mod, debug, ctx.type, "TGSI shader");
	if (r) {
		fprintf(stderr, "LLVM failed to compile shader\n");
		goto out;
	}

	si_llvm_dispose(&ctx);

	/* Validate SGPR and VGPR usage for compute to detect compiler bugs.
	 * LLVM 3.9svn has this bug.
	 */
	if (sel->type == PIPE_SHADER_COMPUTE) {
		unsigned wave_size = 64;
		unsigned max_vgprs = 256;
		unsigned max_sgprs = sscreen->b.chip_class >= VI ? 800 : 512;
		unsigned max_sgprs_per_wave = 128;
		unsigned max_block_threads = si_get_max_workgroup_size(shader);
		unsigned min_waves_per_cu = DIV_ROUND_UP(max_block_threads, wave_size);
		unsigned min_waves_per_simd = DIV_ROUND_UP(min_waves_per_cu, 4);

		max_vgprs = max_vgprs / min_waves_per_simd;
		max_sgprs = MIN2(max_sgprs / min_waves_per_simd, max_sgprs_per_wave);

		if (shader->config.num_sgprs > max_sgprs ||
		    shader->config.num_vgprs > max_vgprs) {
			fprintf(stderr, "LLVM failed to compile a shader correctly: "
				"SGPR:VGPR usage is %u:%u, but the hw limit is %u:%u\n",
				shader->config.num_sgprs, shader->config.num_vgprs,
				max_sgprs, max_vgprs);

			/* Just terminate the process, because dependent
			 * shaders can hang due to bad input data, but use
			 * the env var to allow shader-db to work.
			 */
			if (!debug_get_bool_option("SI_PASS_BAD_SHADERS", false))
				abort();
		}
	}

	/* Add the scratch offset to input SGPRs. */
	if (shader->config.scratch_bytes_per_wave)
		shader->info.num_input_sgprs += 1; /* scratch byte offset */

	/* Calculate the number of fragment input VGPRs. */
	if (ctx.type == PIPE_SHADER_FRAGMENT) {
		shader->info.num_input_vgprs = 0;
		shader->info.face_vgpr_index = -1;

		if (G_0286CC_PERSP_SAMPLE_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 2;
		if (G_0286CC_PERSP_CENTER_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 2;
		if (G_0286CC_PERSP_CENTROID_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 2;
		if (G_0286CC_PERSP_PULL_MODEL_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 3;
		if (G_0286CC_LINEAR_SAMPLE_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 2;
		if (G_0286CC_LINEAR_CENTER_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 2;
		if (G_0286CC_LINEAR_CENTROID_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 2;
		if (G_0286CC_LINE_STIPPLE_TEX_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_POS_X_FLOAT_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_POS_Y_FLOAT_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_POS_Z_FLOAT_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_POS_W_FLOAT_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_FRONT_FACE_ENA(shader->config.spi_ps_input_addr)) {
			shader->info.face_vgpr_index = shader->info.num_input_vgprs;
			shader->info.num_input_vgprs += 1;
		}
		if (G_0286CC_ANCILLARY_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_SAMPLE_COVERAGE_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_POS_FIXED_PT_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
	}

	if (ctx.type == PIPE_SHADER_GEOMETRY) {
		shader->gs_copy_shader = CALLOC_STRUCT(si_shader);
		shader->gs_copy_shader->selector = shader->selector;
		ctx.shader = shader->gs_copy_shader;
		if ((r = si_generate_gs_copy_shader(sscreen, &ctx,
						    shader, debug))) {
			free(shader->gs_copy_shader);
			shader->gs_copy_shader = NULL;
			goto out;
		}
	}

out:
	return r;
}

/**
 * Create, compile and return a shader part (prolog or epilog).
 *
 * \param sscreen	screen
 * \param list		list of shader parts of the same category
 * \param key		shader part key
 * \param tm		LLVM target machine
 * \param debug		debug callback
 * \param compile	the callback responsible for compilation
 * \return		non-NULL on success
 */
static struct si_shader_part *
si_get_shader_part(struct si_screen *sscreen,
		   struct si_shader_part **list,
		   union si_shader_part_key *key,
		   LLVMTargetMachineRef tm,
		   struct pipe_debug_callback *debug,
		   bool (*compile)(struct si_screen *,
				   LLVMTargetMachineRef,
				   struct pipe_debug_callback *,
				   struct si_shader_part *))
{
	struct si_shader_part *result;

	pipe_mutex_lock(sscreen->shader_parts_mutex);

	/* Find existing. */
	for (result = *list; result; result = result->next) {
		if (memcmp(&result->key, key, sizeof(*key)) == 0) {
			pipe_mutex_unlock(sscreen->shader_parts_mutex);
			return result;
		}
	}

	/* Compile a new one. */
	result = CALLOC_STRUCT(si_shader_part);
	result->key = *key;
	if (!compile(sscreen, tm, debug, result)) {
		FREE(result);
		pipe_mutex_unlock(sscreen->shader_parts_mutex);
		return NULL;
	}

	result->next = *list;
	*list = result;
	pipe_mutex_unlock(sscreen->shader_parts_mutex);
	return result;
}

/**
 * Create a vertex shader prolog.
 *
 * The inputs are the same as VS (a lot of SGPRs and 4 VGPR system values).
 * All inputs are returned unmodified. The vertex load indices are
 * stored after them, which will used by the API VS for fetching inputs.
 *
 * For example, the expected outputs for instance_divisors[] = {0, 1, 2} are:
 *   input_v0,
 *   input_v1,
 *   input_v2,
 *   input_v3,
 *   (VertexID + BaseVertex),
 *   (InstanceID + StartInstance),
 *   (InstanceID / 2 + StartInstance)
 */
static bool si_compile_vs_prolog(struct si_screen *sscreen,
				 LLVMTargetMachineRef tm,
				 struct pipe_debug_callback *debug,
				 struct si_shader_part *out)
{
	union si_shader_part_key *key = &out->key;
	struct si_shader shader = {};
	struct si_shader_context ctx;
	struct gallivm_state *gallivm = &ctx.gallivm;
	LLVMTypeRef *params, *returns;
	LLVMValueRef ret, func;
	int last_sgpr, num_params, num_returns, i;
	bool status = true;

	si_init_shader_ctx(&ctx, sscreen, &shader, tm);
	ctx.type = PIPE_SHADER_VERTEX;
	ctx.param_vertex_id = key->vs_prolog.num_input_sgprs;
	ctx.param_instance_id = key->vs_prolog.num_input_sgprs + 3;

	/* 4 preloaded VGPRs + vertex load indices as prolog outputs */
	params = alloca((key->vs_prolog.num_input_sgprs + 4) *
			sizeof(LLVMTypeRef));
	returns = alloca((key->vs_prolog.num_input_sgprs + 4 +
			  key->vs_prolog.last_input + 1) *
			 sizeof(LLVMTypeRef));
	num_params = 0;
	num_returns = 0;

	/* Declare input and output SGPRs. */
	num_params = 0;
	for (i = 0; i < key->vs_prolog.num_input_sgprs; i++) {
		params[num_params++] = ctx.i32;
		returns[num_returns++] = ctx.i32;
	}
	last_sgpr = num_params - 1;

	/* 4 preloaded VGPRs (outputs must be floats) */
	for (i = 0; i < 4; i++) {
		params[num_params++] = ctx.i32;
		returns[num_returns++] = ctx.f32;
	}

	/* Vertex load indices. */
	for (i = 0; i <= key->vs_prolog.last_input; i++)
		returns[num_returns++] = ctx.f32;

	/* Create the function. */
	si_create_function(&ctx, returns, num_returns, params,
			   num_params, last_sgpr);
	func = ctx.main_fn;

	/* Copy inputs to outputs. This should be no-op, as the registers match,
	 * but it will prevent the compiler from overwriting them unintentionally.
	 */
	ret = ctx.return_value;
	for (i = 0; i < key->vs_prolog.num_input_sgprs; i++) {
		LLVMValueRef p = LLVMGetParam(func, i);
		ret = LLVMBuildInsertValue(gallivm->builder, ret, p, i, "");
	}
	for (i = num_params - 4; i < num_params; i++) {
		LLVMValueRef p = LLVMGetParam(func, i);
		p = LLVMBuildBitCast(gallivm->builder, p, ctx.f32, "");
		ret = LLVMBuildInsertValue(gallivm->builder, ret, p, i, "");
	}

	/* Compute vertex load indices from instance divisors. */
	for (i = 0; i <= key->vs_prolog.last_input; i++) {
		unsigned divisor = key->vs_prolog.states.instance_divisors[i];
		LLVMValueRef index;

		if (divisor) {
			/* InstanceID / Divisor + StartInstance */
			index = get_instance_index_for_fetch(&ctx,
							     SI_SGPR_START_INSTANCE,
							     divisor);
		} else {
			/* VertexID + BaseVertex */
			index = LLVMBuildAdd(gallivm->builder,
					     LLVMGetParam(func, ctx.param_vertex_id),
					     LLVMGetParam(func, SI_SGPR_BASE_VERTEX), "");
		}

		index = LLVMBuildBitCast(gallivm->builder, index, ctx.f32, "");
		ret = LLVMBuildInsertValue(gallivm->builder, ret, index,
					   num_params++, "");
	}

	/* Compile. */
	si_llvm_build_ret(&ctx, ret);
	si_llvm_finalize_module(&ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_VERTEX));

	if (si_compile_llvm(sscreen, &out->binary, &out->config, tm,
			    gallivm->module, debug, ctx.type,
			    "Vertex Shader Prolog"))
		status = false;

	si_llvm_dispose(&ctx);
	return status;
}

/**
 * Compile the vertex shader epilog. This is also used by the tessellation
 * evaluation shader compiled as VS.
 *
 * The input is PrimitiveID.
 *
 * If PrimitiveID is required by the pixel shader, export it.
 * Otherwise, do nothing.
 */
static bool si_compile_vs_epilog(struct si_screen *sscreen,
				 LLVMTargetMachineRef tm,
				 struct pipe_debug_callback *debug,
				 struct si_shader_part *out)
{
	union si_shader_part_key *key = &out->key;
	struct si_shader_context ctx;
	struct gallivm_state *gallivm = &ctx.gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx.soa.bld_base;
	LLVMTypeRef params[5];
	int num_params, i;
	bool status = true;

	si_init_shader_ctx(&ctx, sscreen, NULL, tm);
	ctx.type = PIPE_SHADER_VERTEX;

	/* Declare input VGPRs. */
	num_params = key->vs_epilog.states.export_prim_id ?
			   (VS_EPILOG_PRIMID_LOC + 1) : 0;
	assert(num_params <= ARRAY_SIZE(params));

	for (i = 0; i < num_params; i++)
		params[i] = ctx.f32;

	/* Create the function. */
	si_create_function(&ctx, NULL, 0, params, num_params, -1);

	/* Emit exports. */
	if (key->vs_epilog.states.export_prim_id) {
		struct lp_build_context *base = &bld_base->base;
		struct lp_build_context *uint = &bld_base->uint_bld;
		LLVMValueRef args[9];

		args[0] = lp_build_const_int32(base->gallivm, 0x0); /* enabled channels */
		args[1] = uint->zero; /* whether the EXEC mask is valid */
		args[2] = uint->zero; /* DONE bit */
		args[3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_PARAM +
					       key->vs_epilog.prim_id_param_offset);
		args[4] = uint->zero; /* COMPR flag (0 = 32-bit export) */
		args[5] = LLVMGetParam(ctx.main_fn,
				       VS_EPILOG_PRIMID_LOC); /* X */
		args[6] = uint->undef; /* Y */
		args[7] = uint->undef; /* Z */
		args[8] = uint->undef; /* W */

		lp_build_intrinsic(base->gallivm->builder, "llvm.SI.export",
				   LLVMVoidTypeInContext(base->gallivm->context),
				   args, 9, 0);
	}

	/* Compile. */
	LLVMBuildRetVoid(gallivm->builder);
	si_llvm_finalize_module(&ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_VERTEX));

	if (si_compile_llvm(sscreen, &out->binary, &out->config, tm,
			    gallivm->module, debug, ctx.type,
			    "Vertex Shader Epilog"))
		status = false;

	si_llvm_dispose(&ctx);
	return status;
}

/**
 * Create & compile a vertex shader epilog. This a helper used by VS and TES.
 */
static bool si_get_vs_epilog(struct si_screen *sscreen,
			     LLVMTargetMachineRef tm,
		             struct si_shader *shader,
		             struct pipe_debug_callback *debug,
			     struct si_vs_epilog_bits *states)
{
	union si_shader_part_key epilog_key;

	memset(&epilog_key, 0, sizeof(epilog_key));
	epilog_key.vs_epilog.states = *states;

	/* Set up the PrimitiveID output. */
	if (shader->key.vs.epilog.export_prim_id) {
		unsigned index = shader->selector->info.num_outputs;
		unsigned offset = shader->info.nr_param_exports++;

		epilog_key.vs_epilog.prim_id_param_offset = offset;
		assert(index < ARRAY_SIZE(shader->info.vs_output_param_offset));
		shader->info.vs_output_param_offset[index] = offset;
	}

	shader->epilog = si_get_shader_part(sscreen, &sscreen->vs_epilogs,
					    &epilog_key, tm, debug,
					    si_compile_vs_epilog);
	return shader->epilog != NULL;
}

/**
 * Select and compile (or reuse) vertex shader parts (prolog & epilog).
 */
static bool si_shader_select_vs_parts(struct si_screen *sscreen,
				      LLVMTargetMachineRef tm,
				      struct si_shader *shader,
				      struct pipe_debug_callback *debug)
{
	struct tgsi_shader_info *info = &shader->selector->info;
	union si_shader_part_key prolog_key;
	unsigned i;

	/* Get the prolog. */
	memset(&prolog_key, 0, sizeof(prolog_key));
	prolog_key.vs_prolog.states = shader->key.vs.prolog;
	prolog_key.vs_prolog.num_input_sgprs = shader->info.num_input_sgprs;
	prolog_key.vs_prolog.last_input = MAX2(1, info->num_inputs) - 1;

	/* The prolog is a no-op if there are no inputs. */
	if (info->num_inputs) {
		shader->prolog =
			si_get_shader_part(sscreen, &sscreen->vs_prologs,
					   &prolog_key, tm, debug,
					   si_compile_vs_prolog);
		if (!shader->prolog)
			return false;
	}

	/* Get the epilog. */
	if (!shader->key.vs.as_es && !shader->key.vs.as_ls &&
	    !si_get_vs_epilog(sscreen, tm, shader, debug,
			      &shader->key.vs.epilog))
		return false;

	/* Set the instanceID flag. */
	for (i = 0; i < info->num_inputs; i++)
		if (prolog_key.vs_prolog.states.instance_divisors[i])
			shader->info.uses_instanceid = true;

	return true;
}

/**
 * Select and compile (or reuse) TES parts (epilog).
 */
static bool si_shader_select_tes_parts(struct si_screen *sscreen,
				       LLVMTargetMachineRef tm,
				       struct si_shader *shader,
				       struct pipe_debug_callback *debug)
{
	if (shader->key.tes.as_es)
		return true;

	/* TES compiled as VS. */
	return si_get_vs_epilog(sscreen, tm, shader, debug,
				&shader->key.tes.epilog);
}

/**
 * Compile the TCS epilog. This writes tesselation factors to memory based on
 * the output primitive type of the tesselator (determined by TES).
 */
static bool si_compile_tcs_epilog(struct si_screen *sscreen,
				  LLVMTargetMachineRef tm,
				  struct pipe_debug_callback *debug,
				  struct si_shader_part *out)
{
	union si_shader_part_key *key = &out->key;
	struct si_shader shader = {};
	struct si_shader_context ctx;
	struct gallivm_state *gallivm = &ctx.gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx.soa.bld_base;
	LLVMTypeRef params[16];
	LLVMValueRef func;
	int last_sgpr, num_params;
	bool status = true;

	si_init_shader_ctx(&ctx, sscreen, &shader, tm);
	ctx.type = PIPE_SHADER_TESS_CTRL;
	shader.key.tcs.epilog = key->tcs_epilog.states;

	/* Declare inputs. Only RW_BUFFERS and TESS_FACTOR_OFFSET are used. */
	params[SI_PARAM_RW_BUFFERS] = const_array(ctx.v16i8, SI_NUM_RW_BUFFERS);
	params[SI_PARAM_CONST_BUFFERS] = ctx.i64;
	params[SI_PARAM_SAMPLERS] = ctx.i64;
	params[SI_PARAM_IMAGES] = ctx.i64;
	params[SI_PARAM_SHADER_BUFFERS] = ctx.i64;
	params[SI_PARAM_TCS_OFFCHIP_LAYOUT] = ctx.i32;
	params[SI_PARAM_TCS_OUT_OFFSETS] = ctx.i32;
	params[SI_PARAM_TCS_OUT_LAYOUT] = ctx.i32;
	params[SI_PARAM_TCS_IN_LAYOUT] = ctx.i32;
	params[ctx.param_oc_lds = SI_PARAM_TCS_OC_LDS] = ctx.i32;
	params[SI_PARAM_TESS_FACTOR_OFFSET] = ctx.i32;
	last_sgpr = SI_PARAM_TESS_FACTOR_OFFSET;
	num_params = last_sgpr + 1;

	params[num_params++] = ctx.i32; /* patch index within the wave (REL_PATCH_ID) */
	params[num_params++] = ctx.i32; /* invocation ID within the patch */
	params[num_params++] = ctx.i32; /* LDS offset where tess factors should be loaded from */

	/* Create the function. */
	si_create_function(&ctx, NULL, 0, params, num_params, last_sgpr);
	declare_tess_lds(&ctx);
	func = ctx.main_fn;

	si_write_tess_factors(bld_base,
			      LLVMGetParam(func, last_sgpr + 1),
			      LLVMGetParam(func, last_sgpr + 2),
			      LLVMGetParam(func, last_sgpr + 3));

	/* Compile. */
	LLVMBuildRetVoid(gallivm->builder);
	si_llvm_finalize_module(&ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_TESS_CTRL));

	if (si_compile_llvm(sscreen, &out->binary, &out->config, tm,
			    gallivm->module, debug, ctx.type,
			    "Tessellation Control Shader Epilog"))
		status = false;

	si_llvm_dispose(&ctx);
	return status;
}

/**
 * Select and compile (or reuse) TCS parts (epilog).
 */
static bool si_shader_select_tcs_parts(struct si_screen *sscreen,
				       LLVMTargetMachineRef tm,
				       struct si_shader *shader,
				       struct pipe_debug_callback *debug)
{
	union si_shader_part_key epilog_key;

	/* Get the epilog. */
	memset(&epilog_key, 0, sizeof(epilog_key));
	epilog_key.tcs_epilog.states = shader->key.tcs.epilog;

	shader->epilog = si_get_shader_part(sscreen, &sscreen->tcs_epilogs,
					    &epilog_key, tm, debug,
					    si_compile_tcs_epilog);
	return shader->epilog != NULL;
}

/**
 * Compile the pixel shader prolog. This handles:
 * - two-side color selection and interpolation
 * - overriding interpolation parameters for the API PS
 * - polygon stippling
 *
 * All preloaded SGPRs and VGPRs are passed through unmodified unless they are
 * overriden by other states. (e.g. per-sample interpolation)
 * Interpolated colors are stored after the preloaded VGPRs.
 */
static bool si_compile_ps_prolog(struct si_screen *sscreen,
				 LLVMTargetMachineRef tm,
				 struct pipe_debug_callback *debug,
				 struct si_shader_part *out)
{
	union si_shader_part_key *key = &out->key;
	struct si_shader shader = {};
	struct si_shader_context ctx;
	struct gallivm_state *gallivm = &ctx.gallivm;
	LLVMTypeRef *params;
	LLVMValueRef ret, func;
	int last_sgpr, num_params, num_returns, i, num_color_channels;
	bool status = true;

	si_init_shader_ctx(&ctx, sscreen, &shader, tm);
	ctx.type = PIPE_SHADER_FRAGMENT;
	shader.key.ps.prolog = key->ps_prolog.states;

	/* Number of inputs + 8 color elements. */
	params = alloca((key->ps_prolog.num_input_sgprs +
			 key->ps_prolog.num_input_vgprs + 8) *
			sizeof(LLVMTypeRef));

	/* Declare inputs. */
	num_params = 0;
	for (i = 0; i < key->ps_prolog.num_input_sgprs; i++)
		params[num_params++] = ctx.i32;
	last_sgpr = num_params - 1;

	for (i = 0; i < key->ps_prolog.num_input_vgprs; i++)
		params[num_params++] = ctx.f32;

	/* Declare outputs (same as inputs + add colors if needed) */
	num_returns = num_params;
	num_color_channels = util_bitcount(key->ps_prolog.colors_read);
	for (i = 0; i < num_color_channels; i++)
		params[num_returns++] = ctx.f32;

	/* Create the function. */
	si_create_function(&ctx, params, num_returns, params,
			   num_params, last_sgpr);
	func = ctx.main_fn;

	/* Copy inputs to outputs. This should be no-op, as the registers match,
	 * but it will prevent the compiler from overwriting them unintentionally.
	 */
	ret = ctx.return_value;
	for (i = 0; i < num_params; i++) {
		LLVMValueRef p = LLVMGetParam(func, i);
		ret = LLVMBuildInsertValue(gallivm->builder, ret, p, i, "");
	}

	/* Polygon stippling. */
	if (key->ps_prolog.states.poly_stipple) {
		/* POS_FIXED_PT is always last. */
		unsigned pos = key->ps_prolog.num_input_sgprs +
			       key->ps_prolog.num_input_vgprs - 1;
		LLVMValueRef ptr[2], list;

		/* Get the pointer to rw buffers. */
		ptr[0] = LLVMGetParam(func, SI_SGPR_RW_BUFFERS);
		ptr[1] = LLVMGetParam(func, SI_SGPR_RW_BUFFERS_HI);
		list = lp_build_gather_values(gallivm, ptr, 2);
		list = LLVMBuildBitCast(gallivm->builder, list, ctx.i64, "");
		list = LLVMBuildIntToPtr(gallivm->builder, list,
					  const_array(ctx.v16i8, SI_NUM_RW_BUFFERS), "");

		si_llvm_emit_polygon_stipple(&ctx, list, pos);
	}

	if (key->ps_prolog.states.bc_optimize_for_persp ||
	    key->ps_prolog.states.bc_optimize_for_linear) {
		unsigned i, base = key->ps_prolog.num_input_sgprs;
		LLVMValueRef center[2], centroid[2], tmp, bc_optimize;

		/* The shader should do: if (PRIM_MASK[31]) CENTROID = CENTER;
		 * The hw doesn't compute CENTROID if the whole wave only
		 * contains fully-covered quads.
		 *
		 * PRIM_MASK is after user SGPRs.
		 */
		bc_optimize = LLVMGetParam(func, SI_PS_NUM_USER_SGPR);
		bc_optimize = LLVMBuildLShr(gallivm->builder, bc_optimize,
					    LLVMConstInt(ctx.i32, 31, 0), "");
		bc_optimize = LLVMBuildTrunc(gallivm->builder, bc_optimize,
					     ctx.i1, "");

		if (key->ps_prolog.states.bc_optimize_for_persp) {
			/* Read PERSP_CENTER. */
			for (i = 0; i < 2; i++)
				center[i] = LLVMGetParam(func, base + 2 + i);
			/* Read PERSP_CENTROID. */
			for (i = 0; i < 2; i++)
				centroid[i] = LLVMGetParam(func, base + 4 + i);
			/* Select PERSP_CENTROID. */
			for (i = 0; i < 2; i++) {
				tmp = LLVMBuildSelect(gallivm->builder, bc_optimize,
						      center[i], centroid[i], "");
				ret = LLVMBuildInsertValue(gallivm->builder, ret,
							   tmp, base + 4 + i, "");
			}
		}
		if (key->ps_prolog.states.bc_optimize_for_linear) {
			/* Read LINEAR_CENTER. */
			for (i = 0; i < 2; i++)
				center[i] = LLVMGetParam(func, base + 8 + i);
			/* Read LINEAR_CENTROID. */
			for (i = 0; i < 2; i++)
				centroid[i] = LLVMGetParam(func, base + 10 + i);
			/* Select LINEAR_CENTROID. */
			for (i = 0; i < 2; i++) {
				tmp = LLVMBuildSelect(gallivm->builder, bc_optimize,
						      center[i], centroid[i], "");
				ret = LLVMBuildInsertValue(gallivm->builder, ret,
							   tmp, base + 10 + i, "");
			}
		}
	}

	/* Force per-sample interpolation. */
	if (key->ps_prolog.states.force_persp_sample_interp) {
		unsigned i, base = key->ps_prolog.num_input_sgprs;
		LLVMValueRef persp_sample[2];

		/* Read PERSP_SAMPLE. */
		for (i = 0; i < 2; i++)
			persp_sample[i] = LLVMGetParam(func, base + i);
		/* Overwrite PERSP_CENTER. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   persp_sample[i], base + 2 + i, "");
		/* Overwrite PERSP_CENTROID. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   persp_sample[i], base + 4 + i, "");
	}
	if (key->ps_prolog.states.force_linear_sample_interp) {
		unsigned i, base = key->ps_prolog.num_input_sgprs;
		LLVMValueRef linear_sample[2];

		/* Read LINEAR_SAMPLE. */
		for (i = 0; i < 2; i++)
			linear_sample[i] = LLVMGetParam(func, base + 6 + i);
		/* Overwrite LINEAR_CENTER. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   linear_sample[i], base + 8 + i, "");
		/* Overwrite LINEAR_CENTROID. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   linear_sample[i], base + 10 + i, "");
	}

	/* Force center interpolation. */
	if (key->ps_prolog.states.force_persp_center_interp) {
		unsigned i, base = key->ps_prolog.num_input_sgprs;
		LLVMValueRef persp_center[2];

		/* Read PERSP_CENTER. */
		for (i = 0; i < 2; i++)
			persp_center[i] = LLVMGetParam(func, base + 2 + i);
		/* Overwrite PERSP_SAMPLE. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   persp_center[i], base + i, "");
		/* Overwrite PERSP_CENTROID. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   persp_center[i], base + 4 + i, "");
	}
	if (key->ps_prolog.states.force_linear_center_interp) {
		unsigned i, base = key->ps_prolog.num_input_sgprs;
		LLVMValueRef linear_center[2];

		/* Read LINEAR_CENTER. */
		for (i = 0; i < 2; i++)
			linear_center[i] = LLVMGetParam(func, base + 8 + i);
		/* Overwrite LINEAR_SAMPLE. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   linear_center[i], base + 6 + i, "");
		/* Overwrite LINEAR_CENTROID. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   linear_center[i], base + 10 + i, "");
	}

	/* Interpolate colors. */
	for (i = 0; i < 2; i++) {
		unsigned writemask = (key->ps_prolog.colors_read >> (i * 4)) & 0xf;
		unsigned face_vgpr = key->ps_prolog.num_input_sgprs +
				     key->ps_prolog.face_vgpr_index;
		LLVMValueRef interp[2], color[4];
		LLVMValueRef interp_ij = NULL, prim_mask = NULL, face = NULL;

		if (!writemask)
			continue;

		/* If the interpolation qualifier is not CONSTANT (-1). */
		if (key->ps_prolog.color_interp_vgpr_index[i] != -1) {
			unsigned interp_vgpr = key->ps_prolog.num_input_sgprs +
					       key->ps_prolog.color_interp_vgpr_index[i];

			/* Get the (i,j) updated by bc_optimize handling. */
			interp[0] = LLVMBuildExtractValue(gallivm->builder, ret,
							  interp_vgpr, "");
			interp[1] = LLVMBuildExtractValue(gallivm->builder, ret,
							  interp_vgpr + 1, "");
			interp_ij = lp_build_gather_values(gallivm, interp, 2);
			interp_ij = LLVMBuildBitCast(gallivm->builder, interp_ij,
						     ctx.v2i32, "");
		}

		/* Use the absolute location of the input. */
		prim_mask = LLVMGetParam(func, SI_PS_NUM_USER_SGPR);

		if (key->ps_prolog.states.color_two_side) {
			face = LLVMGetParam(func, face_vgpr);
			face = LLVMBuildBitCast(gallivm->builder, face, ctx.i32, "");
		}

		interp_fs_input(&ctx,
				key->ps_prolog.color_attr_index[i],
				TGSI_SEMANTIC_COLOR, i,
				key->ps_prolog.num_interp_inputs,
				key->ps_prolog.colors_read, interp_ij,
				prim_mask, face, color);

		while (writemask) {
			unsigned chan = u_bit_scan(&writemask);
			ret = LLVMBuildInsertValue(gallivm->builder, ret, color[chan],
						   num_params++, "");
		}
	}

	/* Tell LLVM to insert WQM instruction sequence when needed. */
	if (key->ps_prolog.wqm) {
		LLVMAddTargetDependentFunctionAttr(func,
						   "amdgpu-ps-wqm-outputs", "");
	}

	/* Compile. */
	si_llvm_build_ret(&ctx, ret);
	si_llvm_finalize_module(&ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_FRAGMENT));

	if (si_compile_llvm(sscreen, &out->binary, &out->config, tm,
			    gallivm->module, debug, ctx.type,
			    "Fragment Shader Prolog"))
		status = false;

	si_llvm_dispose(&ctx);
	return status;
}

/**
 * Compile the pixel shader epilog. This handles everything that must be
 * emulated for pixel shader exports. (alpha-test, format conversions, etc)
 */
static bool si_compile_ps_epilog(struct si_screen *sscreen,
				 LLVMTargetMachineRef tm,
				 struct pipe_debug_callback *debug,
				 struct si_shader_part *out)
{
	union si_shader_part_key *key = &out->key;
	struct si_shader shader = {};
	struct si_shader_context ctx;
	struct gallivm_state *gallivm = &ctx.gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx.soa.bld_base;
	LLVMTypeRef params[16+8*4+3];
	LLVMValueRef depth = NULL, stencil = NULL, samplemask = NULL;
	int last_sgpr, num_params, i;
	bool status = true;
	struct si_ps_exports exp = {};

	si_init_shader_ctx(&ctx, sscreen, &shader, tm);
	ctx.type = PIPE_SHADER_FRAGMENT;
	shader.key.ps.epilog = key->ps_epilog.states;

	/* Declare input SGPRs. */
	params[SI_PARAM_RW_BUFFERS] = ctx.i64;
	params[SI_PARAM_CONST_BUFFERS] = ctx.i64;
	params[SI_PARAM_SAMPLERS] = ctx.i64;
	params[SI_PARAM_IMAGES] = ctx.i64;
	params[SI_PARAM_SHADER_BUFFERS] = ctx.i64;
	params[SI_PARAM_ALPHA_REF] = ctx.f32;
	last_sgpr = SI_PARAM_ALPHA_REF;

	/* Declare input VGPRs. */
	num_params = (last_sgpr + 1) +
		     util_bitcount(key->ps_epilog.colors_written) * 4 +
		     key->ps_epilog.writes_z +
		     key->ps_epilog.writes_stencil +
		     key->ps_epilog.writes_samplemask;

	num_params = MAX2(num_params,
			  last_sgpr + 1 + PS_EPILOG_SAMPLEMASK_MIN_LOC + 1);

	assert(num_params <= ARRAY_SIZE(params));

	for (i = last_sgpr + 1; i < num_params; i++)
		params[i] = ctx.f32;

	/* Create the function. */
	si_create_function(&ctx, NULL, 0, params, num_params, last_sgpr);
	/* Disable elimination of unused inputs. */
	si_llvm_add_attribute(ctx.main_fn,
				  "InitialPSInputAddr", 0xffffff);

	/* Process colors. */
	unsigned vgpr = last_sgpr + 1;
	unsigned colors_written = key->ps_epilog.colors_written;
	int last_color_export = -1;

	/* Find the last color export. */
	if (!key->ps_epilog.writes_z &&
	    !key->ps_epilog.writes_stencil &&
	    !key->ps_epilog.writes_samplemask) {
		unsigned spi_format = key->ps_epilog.states.spi_shader_col_format;

		/* If last_cbuf > 0, FS_COLOR0_WRITES_ALL_CBUFS is true. */
		if (colors_written == 0x1 && key->ps_epilog.states.last_cbuf > 0) {
			/* Just set this if any of the colorbuffers are enabled. */
			if (spi_format &
			    ((1llu << (4 * (key->ps_epilog.states.last_cbuf + 1))) - 1))
				last_color_export = 0;
		} else {
			for (i = 0; i < 8; i++)
				if (colors_written & (1 << i) &&
				    (spi_format >> (i * 4)) & 0xf)
					last_color_export = i;
		}
	}

	while (colors_written) {
		LLVMValueRef color[4];
		int mrt = u_bit_scan(&colors_written);

		for (i = 0; i < 4; i++)
			color[i] = LLVMGetParam(ctx.main_fn, vgpr++);

		si_export_mrt_color(bld_base, color, mrt,
				    num_params - 1,
				    mrt == last_color_export, &exp);
	}

	/* Process depth, stencil, samplemask. */
	if (key->ps_epilog.writes_z)
		depth = LLVMGetParam(ctx.main_fn, vgpr++);
	if (key->ps_epilog.writes_stencil)
		stencil = LLVMGetParam(ctx.main_fn, vgpr++);
	if (key->ps_epilog.writes_samplemask)
		samplemask = LLVMGetParam(ctx.main_fn, vgpr++);

	if (depth || stencil || samplemask)
		si_export_mrt_z(bld_base, depth, stencil, samplemask, &exp);
	else if (last_color_export == -1)
		si_export_null(bld_base);

	if (exp.num)
		si_emit_ps_exports(&ctx, &exp);

	/* Compile. */
	LLVMBuildRetVoid(gallivm->builder);
	si_llvm_finalize_module(&ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_FRAGMENT));

	if (si_compile_llvm(sscreen, &out->binary, &out->config, tm,
			    gallivm->module, debug, ctx.type,
			    "Fragment Shader Epilog"))
		status = false;

	si_llvm_dispose(&ctx);
	return status;
}

/**
 * Select and compile (or reuse) pixel shader parts (prolog & epilog).
 */
static bool si_shader_select_ps_parts(struct si_screen *sscreen,
				      LLVMTargetMachineRef tm,
				      struct si_shader *shader,
				      struct pipe_debug_callback *debug)
{
	struct tgsi_shader_info *info = &shader->selector->info;
	union si_shader_part_key prolog_key;
	union si_shader_part_key epilog_key;
	unsigned i;

	/* Get the prolog. */
	memset(&prolog_key, 0, sizeof(prolog_key));
	prolog_key.ps_prolog.states = shader->key.ps.prolog;
	prolog_key.ps_prolog.colors_read = info->colors_read;
	prolog_key.ps_prolog.num_input_sgprs = shader->info.num_input_sgprs;
	prolog_key.ps_prolog.num_input_vgprs = shader->info.num_input_vgprs;
	prolog_key.ps_prolog.wqm = info->uses_derivatives &&
		(prolog_key.ps_prolog.colors_read ||
		 prolog_key.ps_prolog.states.force_persp_sample_interp ||
		 prolog_key.ps_prolog.states.force_linear_sample_interp ||
		 prolog_key.ps_prolog.states.force_persp_center_interp ||
		 prolog_key.ps_prolog.states.force_linear_center_interp ||
		 prolog_key.ps_prolog.states.bc_optimize_for_persp ||
		 prolog_key.ps_prolog.states.bc_optimize_for_linear);

	if (info->colors_read) {
		unsigned *color = shader->selector->color_attr_index;

		if (shader->key.ps.prolog.color_two_side) {
			/* BCOLORs are stored after the last input. */
			prolog_key.ps_prolog.num_interp_inputs = info->num_inputs;
			prolog_key.ps_prolog.face_vgpr_index = shader->info.face_vgpr_index;
			shader->config.spi_ps_input_ena |= S_0286CC_FRONT_FACE_ENA(1);
		}

		for (i = 0; i < 2; i++) {
			unsigned interp = info->input_interpolate[color[i]];
			unsigned location = info->input_interpolate_loc[color[i]];

			if (!(info->colors_read & (0xf << i*4)))
				continue;

			prolog_key.ps_prolog.color_attr_index[i] = color[i];

			if (shader->key.ps.prolog.flatshade_colors &&
			    interp == TGSI_INTERPOLATE_COLOR)
				interp = TGSI_INTERPOLATE_CONSTANT;

			switch (interp) {
			case TGSI_INTERPOLATE_CONSTANT:
				prolog_key.ps_prolog.color_interp_vgpr_index[i] = -1;
				break;
			case TGSI_INTERPOLATE_PERSPECTIVE:
			case TGSI_INTERPOLATE_COLOR:
				/* Force the interpolation location for colors here. */
				if (shader->key.ps.prolog.force_persp_sample_interp)
					location = TGSI_INTERPOLATE_LOC_SAMPLE;
				if (shader->key.ps.prolog.force_persp_center_interp)
					location = TGSI_INTERPOLATE_LOC_CENTER;

				switch (location) {
				case TGSI_INTERPOLATE_LOC_SAMPLE:
					prolog_key.ps_prolog.color_interp_vgpr_index[i] = 0;
					shader->config.spi_ps_input_ena |=
						S_0286CC_PERSP_SAMPLE_ENA(1);
					break;
				case TGSI_INTERPOLATE_LOC_CENTER:
					prolog_key.ps_prolog.color_interp_vgpr_index[i] = 2;
					shader->config.spi_ps_input_ena |=
						S_0286CC_PERSP_CENTER_ENA(1);
					break;
				case TGSI_INTERPOLATE_LOC_CENTROID:
					prolog_key.ps_prolog.color_interp_vgpr_index[i] = 4;
					shader->config.spi_ps_input_ena |=
						S_0286CC_PERSP_CENTROID_ENA(1);
					break;
				default:
					assert(0);
				}
				break;
			case TGSI_INTERPOLATE_LINEAR:
				/* Force the interpolation location for colors here. */
				if (shader->key.ps.prolog.force_linear_sample_interp)
					location = TGSI_INTERPOLATE_LOC_SAMPLE;
				if (shader->key.ps.prolog.force_linear_center_interp)
					location = TGSI_INTERPOLATE_LOC_CENTER;

				switch (location) {
				case TGSI_INTERPOLATE_LOC_SAMPLE:
					prolog_key.ps_prolog.color_interp_vgpr_index[i] = 6;
					shader->config.spi_ps_input_ena |=
						S_0286CC_LINEAR_SAMPLE_ENA(1);
					break;
				case TGSI_INTERPOLATE_LOC_CENTER:
					prolog_key.ps_prolog.color_interp_vgpr_index[i] = 8;
					shader->config.spi_ps_input_ena |=
						S_0286CC_LINEAR_CENTER_ENA(1);
					break;
				case TGSI_INTERPOLATE_LOC_CENTROID:
					prolog_key.ps_prolog.color_interp_vgpr_index[i] = 10;
					shader->config.spi_ps_input_ena |=
						S_0286CC_LINEAR_CENTROID_ENA(1);
					break;
				default:
					assert(0);
				}
				break;
			default:
				assert(0);
			}
		}
	}

	/* The prolog is a no-op if these aren't set. */
	if (prolog_key.ps_prolog.colors_read ||
	    prolog_key.ps_prolog.states.force_persp_sample_interp ||
	    prolog_key.ps_prolog.states.force_linear_sample_interp ||
	    prolog_key.ps_prolog.states.force_persp_center_interp ||
	    prolog_key.ps_prolog.states.force_linear_center_interp ||
	    prolog_key.ps_prolog.states.bc_optimize_for_persp ||
	    prolog_key.ps_prolog.states.bc_optimize_for_linear ||
	    prolog_key.ps_prolog.states.poly_stipple) {
		shader->prolog =
			si_get_shader_part(sscreen, &sscreen->ps_prologs,
					   &prolog_key, tm, debug,
					   si_compile_ps_prolog);
		if (!shader->prolog)
			return false;
	}

	/* Get the epilog. */
	memset(&epilog_key, 0, sizeof(epilog_key));
	epilog_key.ps_epilog.colors_written = info->colors_written;
	epilog_key.ps_epilog.writes_z = info->writes_z;
	epilog_key.ps_epilog.writes_stencil = info->writes_stencil;
	epilog_key.ps_epilog.writes_samplemask = info->writes_samplemask;
	epilog_key.ps_epilog.states = shader->key.ps.epilog;

	shader->epilog =
		si_get_shader_part(sscreen, &sscreen->ps_epilogs,
				   &epilog_key, tm, debug,
				   si_compile_ps_epilog);
	if (!shader->epilog)
		return false;

	/* Enable POS_FIXED_PT if polygon stippling is enabled. */
	if (shader->key.ps.prolog.poly_stipple) {
		shader->config.spi_ps_input_ena |= S_0286CC_POS_FIXED_PT_ENA(1);
		assert(G_0286CC_POS_FIXED_PT_ENA(shader->config.spi_ps_input_addr));
	}

	/* Set up the enable bits for per-sample shading if needed. */
	if (shader->key.ps.prolog.force_persp_sample_interp &&
	    (G_0286CC_PERSP_CENTER_ENA(shader->config.spi_ps_input_ena) ||
	     G_0286CC_PERSP_CENTROID_ENA(shader->config.spi_ps_input_ena))) {
		shader->config.spi_ps_input_ena &= C_0286CC_PERSP_CENTER_ENA;
		shader->config.spi_ps_input_ena &= C_0286CC_PERSP_CENTROID_ENA;
		shader->config.spi_ps_input_ena |= S_0286CC_PERSP_SAMPLE_ENA(1);
	}
	if (shader->key.ps.prolog.force_linear_sample_interp &&
	    (G_0286CC_LINEAR_CENTER_ENA(shader->config.spi_ps_input_ena) ||
	     G_0286CC_LINEAR_CENTROID_ENA(shader->config.spi_ps_input_ena))) {
		shader->config.spi_ps_input_ena &= C_0286CC_LINEAR_CENTER_ENA;
		shader->config.spi_ps_input_ena &= C_0286CC_LINEAR_CENTROID_ENA;
		shader->config.spi_ps_input_ena |= S_0286CC_LINEAR_SAMPLE_ENA(1);
	}
	if (shader->key.ps.prolog.force_persp_center_interp &&
	    (G_0286CC_PERSP_SAMPLE_ENA(shader->config.spi_ps_input_ena) ||
	     G_0286CC_PERSP_CENTROID_ENA(shader->config.spi_ps_input_ena))) {
		shader->config.spi_ps_input_ena &= C_0286CC_PERSP_SAMPLE_ENA;
		shader->config.spi_ps_input_ena &= C_0286CC_PERSP_CENTROID_ENA;
		shader->config.spi_ps_input_ena |= S_0286CC_PERSP_CENTER_ENA(1);
	}
	if (shader->key.ps.prolog.force_linear_center_interp &&
	    (G_0286CC_LINEAR_SAMPLE_ENA(shader->config.spi_ps_input_ena) ||
	     G_0286CC_LINEAR_CENTROID_ENA(shader->config.spi_ps_input_ena))) {
		shader->config.spi_ps_input_ena &= C_0286CC_LINEAR_SAMPLE_ENA;
		shader->config.spi_ps_input_ena &= C_0286CC_LINEAR_CENTROID_ENA;
		shader->config.spi_ps_input_ena |= S_0286CC_LINEAR_CENTER_ENA(1);
	}

	/* POW_W_FLOAT requires that one of the perspective weights is enabled. */
	if (G_0286CC_POS_W_FLOAT_ENA(shader->config.spi_ps_input_ena) &&
	    !(shader->config.spi_ps_input_ena & 0xf)) {
		shader->config.spi_ps_input_ena |= S_0286CC_PERSP_CENTER_ENA(1);
		assert(G_0286CC_PERSP_CENTER_ENA(shader->config.spi_ps_input_addr));
	}

	/* At least one pair of interpolation weights must be enabled. */
	if (!(shader->config.spi_ps_input_ena & 0x7f)) {
		shader->config.spi_ps_input_ena |= S_0286CC_LINEAR_CENTER_ENA(1);
		assert(G_0286CC_LINEAR_CENTER_ENA(shader->config.spi_ps_input_addr));
	}

	/* The sample mask input is always enabled, because the API shader always
	 * passes it through to the epilog. Disable it here if it's unused.
	 */
	if (!shader->key.ps.epilog.poly_line_smoothing &&
	    !shader->selector->info.reads_samplemask)
		shader->config.spi_ps_input_ena &= C_0286CC_SAMPLE_COVERAGE_ENA;

	return true;
}

void si_multiwave_lds_size_workaround(struct si_screen *sscreen,
				      unsigned *lds_size)
{
	/* SPI barrier management bug:
	 *   Make sure we have at least 4k of LDS in use to avoid the bug.
	 *   It applies to workgroup sizes of more than one wavefront.
	 */
	if (sscreen->b.family == CHIP_BONAIRE ||
	    sscreen->b.family == CHIP_KABINI ||
	    sscreen->b.family == CHIP_MULLINS)
		*lds_size = MAX2(*lds_size, 8);
}

static void si_fix_resource_usage(struct si_screen *sscreen,
				  struct si_shader *shader)
{
	unsigned min_sgprs = shader->info.num_input_sgprs + 2; /* VCC */

	shader->config.num_sgprs = MAX2(shader->config.num_sgprs, min_sgprs);

	if (shader->selector->type == PIPE_SHADER_COMPUTE &&
	    si_get_max_workgroup_size(shader) > 64) {
		si_multiwave_lds_size_workaround(sscreen,
						 &shader->config.lds_size);
	}
}

int si_shader_create(struct si_screen *sscreen, LLVMTargetMachineRef tm,
		     struct si_shader *shader,
		     struct pipe_debug_callback *debug)
{
	struct si_shader_selector *sel = shader->selector;
	struct si_shader *mainp = sel->main_shader_part;
	int r;

	/* LS, ES, VS are compiled on demand if the main part hasn't been
	 * compiled for that stage.
	 */
	if (!mainp ||
	    (sel->type == PIPE_SHADER_VERTEX &&
	     (shader->key.vs.as_es != mainp->key.vs.as_es ||
	      shader->key.vs.as_ls != mainp->key.vs.as_ls)) ||
	    (sel->type == PIPE_SHADER_TESS_EVAL &&
	     shader->key.tes.as_es != mainp->key.tes.as_es) ||
	    (sel->type == PIPE_SHADER_TESS_CTRL &&
	     shader->key.tcs.epilog.inputs_to_copy) ||
	    sel->type == PIPE_SHADER_COMPUTE) {
		/* Monolithic shader (compiled as a whole, has many variants,
		 * may take a long time to compile).
		 */
		r = si_compile_tgsi_shader(sscreen, tm, shader, true, debug);
		if (r)
			return r;
	} else {
		/* The shader consists of 2-3 parts:
		 *
		 * - the middle part is the user shader, it has 1 variant only
		 *   and it was compiled during the creation of the shader
		 *   selector
		 * - the prolog part is inserted at the beginning
		 * - the epilog part is inserted at the end
		 *
		 * The prolog and epilog have many (but simple) variants.
		 */

		/* Copy the compiled TGSI shader data over. */
		shader->is_binary_shared = true;
		shader->binary = mainp->binary;
		shader->config = mainp->config;
		shader->info.num_input_sgprs = mainp->info.num_input_sgprs;
		shader->info.num_input_vgprs = mainp->info.num_input_vgprs;
		shader->info.face_vgpr_index = mainp->info.face_vgpr_index;
		memcpy(shader->info.vs_output_param_offset,
		       mainp->info.vs_output_param_offset,
		       sizeof(mainp->info.vs_output_param_offset));
		shader->info.uses_instanceid = mainp->info.uses_instanceid;
		shader->info.nr_pos_exports = mainp->info.nr_pos_exports;
		shader->info.nr_param_exports = mainp->info.nr_param_exports;

		/* Select prologs and/or epilogs. */
		switch (sel->type) {
		case PIPE_SHADER_VERTEX:
			if (!si_shader_select_vs_parts(sscreen, tm, shader, debug))
				return -1;
			break;
		case PIPE_SHADER_TESS_CTRL:
			if (!si_shader_select_tcs_parts(sscreen, tm, shader, debug))
				return -1;
			break;
		case PIPE_SHADER_TESS_EVAL:
			if (!si_shader_select_tes_parts(sscreen, tm, shader, debug))
				return -1;
			break;
		case PIPE_SHADER_FRAGMENT:
			if (!si_shader_select_ps_parts(sscreen, tm, shader, debug))
				return -1;

			/* Make sure we have at least as many VGPRs as there
			 * are allocated inputs.
			 */
			shader->config.num_vgprs = MAX2(shader->config.num_vgprs,
							shader->info.num_input_vgprs);
			break;
		}

		/* Update SGPR and VGPR counts. */
		if (shader->prolog) {
			shader->config.num_sgprs = MAX2(shader->config.num_sgprs,
							shader->prolog->config.num_sgprs);
			shader->config.num_vgprs = MAX2(shader->config.num_vgprs,
							shader->prolog->config.num_vgprs);
		}
		if (shader->epilog) {
			shader->config.num_sgprs = MAX2(shader->config.num_sgprs,
							shader->epilog->config.num_sgprs);
			shader->config.num_vgprs = MAX2(shader->config.num_vgprs,
							shader->epilog->config.num_vgprs);
		}
	}

	si_fix_resource_usage(sscreen, shader);
	si_shader_dump(sscreen, shader, debug, sel->info.processor,
		       stderr);

	/* Upload. */
	r = si_shader_binary_upload(sscreen, shader);
	if (r) {
		fprintf(stderr, "LLVM failed to upload shader\n");
		return r;
	}

	return 0;
}

void si_shader_destroy(struct si_shader *shader)
{
	if (shader->gs_copy_shader) {
		si_shader_destroy(shader->gs_copy_shader);
		FREE(shader->gs_copy_shader);
	}

	if (shader->scratch_bo)
		r600_resource_reference(&shader->scratch_bo, NULL);

	r600_resource_reference(&shader->bo, NULL);

	if (!shader->is_binary_shared)
		radeon_shader_binary_clean(&shader->binary);

	free(shader->shader_log);
}
@


1.1
log
@Initial revision
@
text
@a33 1
#include "gallivm/lp_bld_bitarit.h"
d35 1
a35 2
#include "radeon/r600_cs.h"
#include "radeon/radeon_llvm.h"
a36 1
#include "radeon/radeon_llvm_emit.h"
d38 2
a39 2
#include "util/u_pstipple.h"
#include "tgsi/tgsi_parse.h"
d43 1
a44 1
#include "si_shader.h"
a46 1
#include <errno.h>
d61 4
a64 30
struct si_shader_context
{
	struct radeon_llvm_context radeon_bld;
	struct si_shader *shader;
	struct si_screen *screen;
	unsigned type; /* TGSI_PROCESSOR_* specifies the type of shader. */
	int param_streamout_config;
	int param_streamout_write_index;
	int param_streamout_offset[4];
	int param_vertex_id;
	int param_rel_auto_id;
	int param_vs_prim_id;
	int param_instance_id;
	int param_tes_u;
	int param_tes_v;
	int param_tes_rel_patch_id;
	int param_tes_patch_id;
	int param_es2gs_offset;
	LLVMTargetMachineRef tm;
	LLVMValueRef const_md;
	LLVMValueRef const_resource[SI_NUM_CONST_BUFFERS];
	LLVMValueRef lds;
	LLVMValueRef *constants[SI_NUM_CONST_BUFFERS];
	LLVMValueRef resources[SI_NUM_SAMPLER_VIEWS];
	LLVMValueRef samplers[SI_NUM_SAMPLER_STATES];
	LLVMValueRef so_buffers[4];
	LLVMValueRef esgs_ring;
	LLVMValueRef gsvs_ring[4];
	LLVMValueRef gs_next_vertex[4];
};
d66 3
a68 5
static struct si_shader_context * si_shader_context(
	struct lp_build_tgsi_context * bld_base)
{
	return (struct si_shader_context *)bld_base;
}
d70 2
d73 4
a76 2
#define PERSPECTIVE_BASE 0
#define LINEAR_BASE 9
d78 4
a81 8
#define SAMPLE_OFFSET 0
#define CENTER_OFFSET 2
#define CENTROID_OFSET 4

#define USE_SGPR_MAX_SUFFIX_LEN 5
#define CONST_ADDR_SPACE 2
#define LOCAL_ADDR_SPACE 3
#define USER_SGPR_ADDR_SPACE 8
d83 4
a138 43
 * Given a semantic name and index of a parameter and a mask of used parameters
 * (inputs or outputs), return the index of the parameter in the list of all
 * used parameters.
 *
 * For example, assume this list of parameters:
 *   POSITION, PSIZE, GENERIC0, GENERIC2
 * which has the mask:
 *   11000000000101
 * Then:
 *   querying POSITION returns 0,
 *   querying PSIZE returns 1,
 *   querying GENERIC0 returns 2,
 *   querying GENERIC2 returns 3.
 *
 * Which can be used as an offset to a parameter buffer in units of vec4s.
 */
static int get_param_index(unsigned semantic_name, unsigned index,
			   uint64_t mask)
{
	unsigned unique_index = si_shader_io_get_unique_index(semantic_name, index);
	int i, param_index = 0;

	/* If not present... */
	if (!((1llu << unique_index) & mask))
		return -1;

	for (i = 0; mask; i++) {
		uint64_t bit = 1llu << i;

		if (bit & mask) {
			if (i == unique_index)
				return param_index;

			mask &= ~bit;
			param_index++;
		}
	}

	assert(!"unreachable");
	return -1;
}

/**
d141 1
a141 1
static LLVMValueRef unpack_param(struct si_shader_context *si_shader_ctx,
d145 2
a146 2
	struct gallivm_state *gallivm = &si_shader_ctx->radeon_bld.gallivm;
	LLVMValueRef value = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
d149 4
d166 1
a166 1
static LLVMValueRef get_rel_patch_id(struct si_shader_context *si_shader_ctx)
d168 7
a174 7
	switch (si_shader_ctx->type) {
	case TGSI_PROCESSOR_TESS_CTRL:
		return unpack_param(si_shader_ctx, SI_PARAM_REL_IDS, 0, 8);

	case TGSI_PROCESSOR_TESS_EVAL:
		return LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
				    si_shader_ctx->param_tes_rel_patch_id);
d204 1
a204 1
get_tcs_in_patch_stride(struct si_shader_context *si_shader_ctx)
d206 4
a209 4
	if (si_shader_ctx->type == TGSI_PROCESSOR_VERTEX)
		return unpack_param(si_shader_ctx, SI_PARAM_LS_OUT_LAYOUT, 0, 13);
	else if (si_shader_ctx->type == TGSI_PROCESSOR_TESS_CTRL)
		return unpack_param(si_shader_ctx, SI_PARAM_TCS_IN_LAYOUT, 0, 13);
d217 1
a217 1
get_tcs_out_patch_stride(struct si_shader_context *si_shader_ctx)
d219 1
a219 1
	return unpack_param(si_shader_ctx, SI_PARAM_TCS_OUT_LAYOUT, 0, 13);
d223 1
a223 1
get_tcs_out_patch0_offset(struct si_shader_context *si_shader_ctx)
d225 2
a226 2
	return lp_build_mul_imm(&si_shader_ctx->radeon_bld.soa.bld_base.uint_bld,
				unpack_param(si_shader_ctx,
d233 1
a233 1
get_tcs_out_patch0_patch_data_offset(struct si_shader_context *si_shader_ctx)
d235 2
a236 2
	return lp_build_mul_imm(&si_shader_ctx->radeon_bld.soa.bld_base.uint_bld,
				unpack_param(si_shader_ctx,
d243 1
a243 1
get_tcs_in_current_patch_offset(struct si_shader_context *si_shader_ctx)
d245 3
a247 3
	struct gallivm_state *gallivm = &si_shader_ctx->radeon_bld.gallivm;
	LLVMValueRef patch_stride = get_tcs_in_patch_stride(si_shader_ctx);
	LLVMValueRef rel_patch_id = get_rel_patch_id(si_shader_ctx);
d253 1
a253 1
get_tcs_out_current_patch_offset(struct si_shader_context *si_shader_ctx)
d255 4
a258 4
	struct gallivm_state *gallivm = &si_shader_ctx->radeon_bld.gallivm;
	LLVMValueRef patch0_offset = get_tcs_out_patch0_offset(si_shader_ctx);
	LLVMValueRef patch_stride = get_tcs_out_patch_stride(si_shader_ctx);
	LLVMValueRef rel_patch_id = get_rel_patch_id(si_shader_ctx);
d267 1
a267 1
get_tcs_out_current_patch_data_offset(struct si_shader_context *si_shader_ctx)
d269 1
a269 1
	struct gallivm_state *gallivm = &si_shader_ctx->radeon_bld.gallivm;
d271 3
a273 3
		get_tcs_out_patch0_patch_data_offset(si_shader_ctx);
	LLVMValueRef patch_stride = get_tcs_out_patch_stride(si_shader_ctx);
	LLVMValueRef rel_patch_id = get_rel_patch_id(si_shader_ctx);
d281 12
a292 1
static void build_indexed_store(struct si_shader_context *si_shader_ctx,
d296 1
a296 1
	struct lp_build_tgsi_context *bld_base = &si_shader_ctx->radeon_bld.soa.bld_base;
a297 1
	LLVMValueRef indices[2], pointer;
d299 2
a300 5
	indices[0] = bld_base->uint_bld.zero;
	indices[1] = index;

	pointer = LLVMBuildGEP(gallivm->builder, base_ptr, indices, 2, "");
	LLVMBuildStore(gallivm->builder, value, pointer);
d309 2
d312 3
a314 2
static LLVMValueRef build_indexed_load(struct si_shader_context *si_shader_ctx,
				       LLVMValueRef base_ptr, LLVMValueRef index)
d316 1
a316 1
	struct lp_build_tgsi_context *bld_base = &si_shader_ctx->radeon_bld.soa.bld_base;
d318 1
a318 4
	LLVMValueRef indices[2], pointer;

	indices[0] = bld_base->uint_bld.zero;
	indices[1] = index;
d320 3
a322 1
	pointer = LLVMBuildGEP(gallivm->builder, base_ptr, indices, 2, "");
d328 1
a328 1
 * a constant.
d331 1
a331 1
	struct si_shader_context * si_shader_ctx,
d334 2
a335 2
	LLVMValueRef result = build_indexed_load(si_shader_ctx, base_ptr, index);
	LLVMSetMetadata(result, 1, si_shader_ctx->const_md);
d340 2
a341 2
	struct radeon_llvm_context * radeon_bld,
	unsigned divisor)
d343 1
a343 1
	struct si_shader_context *si_shader_ctx =
d345 1
a345 1
	struct gallivm_state * gallivm = radeon_bld->soa.bld_base.base.gallivm;
d348 1
a348 1
					   si_shader_ctx->param_instance_id);
d355 2
a356 2
	return LLVMBuildAdd(gallivm->builder, result, LLVMGetParam(
			radeon_bld->main_fn, SI_PARAM_START_INSTANCE), "");
d360 1
a360 1
	struct radeon_llvm_context *radeon_bld,
d362 2
a363 1
	const struct tgsi_full_declaration *decl)
d367 1
a367 1
	struct si_shader_context *si_shader_ctx =
d369 2
a370 1
	unsigned divisor = si_shader_ctx->shader->key.vs.instance_divisors[input_index];
a379 1
	LLVMTypeRef vec4_type;
d383 1
a383 1
	t_list_ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_VERTEX_BUFFER);
d387 1
a387 1
	t_list = build_indexed_load_const(si_shader_ctx, t_list_ptr, t_offset);
d392 5
a396 1
	if (divisor) {
d398 4
a401 2
		si_shader_ctx->shader->uses_instanceid = true;
		buffer_index = get_instance_index_for_fetch(&si_shader_ctx->radeon_bld, divisor);
d404 2
a405 2
		LLVMValueRef vertex_id = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
						      si_shader_ctx->param_vertex_id);
a410 1
	vec4_type = LLVMVectorType(base->elem_type, 4);
d415 2
a416 2
		"llvm.SI.vs.load.input", vec4_type, args, 3,
		LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
d421 2
a422 5
		/* XXX: Use a helper function for this.  There is one in
 		 * tgsi_llvm.c. */
		si_shader_ctx->radeon_bld.inputs[radeon_llvm_reg_index_soa(input_index, chan)] =
				LLVMBuildExtractElement(gallivm->builder,
				input, llvm_chan, "");
d429 1
a429 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d434 6
a439 6
	switch (si_shader_ctx->type) {
	case TGSI_PROCESSOR_VERTEX:
		return LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
				    si_shader_ctx->param_vs_prim_id);
	case TGSI_PROCESSOR_TESS_CTRL:
		return LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
d441 5
a445 5
	case TGSI_PROCESSOR_TESS_EVAL:
		return LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
				    si_shader_ctx->param_tes_patch_id);
	case TGSI_PROCESSOR_GEOMETRY:
		return LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
d457 1
a457 1
static LLVMValueRef get_indirect_index(struct si_shader_context *si_shader_ctx,
d461 1
a461 1
	struct gallivm_state *gallivm = si_shader_ctx->radeon_bld.soa.bld_base.base.gallivm;
d464 1
a464 1
	result = si_shader_ctx->radeon_bld.soa.addr[ind->Index][ind->Swizzle];
d472 21
d495 1
a495 1
static LLVMValueRef get_dw_address(struct si_shader_context *si_shader_ctx,
d501 2
a502 2
	struct gallivm_state *gallivm = si_shader_ctx->radeon_bld.soa.bld_base.base.gallivm;
	struct tgsi_shader_info *info = &si_shader_ctx->shader->selector->info;
d526 1
a526 1
			index = get_indirect_index(si_shader_ctx, &reg.DimIndirect,
d559 1
a559 1
		ind_index = get_indirect_index(si_shader_ctx, &reg.Indirect,
d577 305
d893 1
a893 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d910 9
a918 1
	value = build_indexed_load(si_shader_ctx, si_shader_ctx->lds, dw_addr);
d930 1
a930 1
static void lds_store(struct lp_build_tgsi_context * bld_base,
d934 1
a934 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d940 2
a941 3
	value = LLVMBuildBitCast(gallivm->builder, value,
				 LLVMInt32TypeInContext(gallivm->context), "");
	build_indexed_store(si_shader_ctx, si_shader_ctx->lds,
d950 1
a950 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d953 3
a955 3
	stride = unpack_param(si_shader_ctx, SI_PARAM_TCS_IN_LAYOUT, 13, 8);
	dw_addr = get_tcs_in_current_patch_offset(si_shader_ctx);
	dw_addr = get_dw_address(si_shader_ctx, NULL, reg, stride, dw_addr);
d965 1
a965 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d969 3
a971 3
		stride = unpack_param(si_shader_ctx, SI_PARAM_TCS_OUT_LAYOUT, 13, 8);
		dw_addr = get_tcs_out_current_patch_offset(si_shader_ctx);
		dw_addr = get_dw_address(si_shader_ctx, NULL, reg, stride, dw_addr);
d973 2
a974 2
		dw_addr = get_tcs_out_current_patch_data_offset(si_shader_ctx);
		dw_addr = get_dw_address(si_shader_ctx, NULL, reg, NULL, dw_addr);
d985 8
a992 2
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
	LLVMValueRef dw_addr, stride;
d994 2
a995 8
	if (reg->Register.Dimension) {
		stride = unpack_param(si_shader_ctx, SI_PARAM_TCS_OUT_LAYOUT, 13, 8);
		dw_addr = get_tcs_out_current_patch_offset(si_shader_ctx);
		dw_addr = get_dw_address(si_shader_ctx, NULL, reg, stride, dw_addr);
	} else {
		dw_addr = get_tcs_out_current_patch_data_offset(si_shader_ctx);
		dw_addr = get_dw_address(si_shader_ctx, NULL, reg, NULL, dw_addr);
	}
d997 1
a997 1
	return lds_load(bld_base, type, swizzle, dw_addr);
d1000 3
a1002 3
static void store_output_tcs(struct lp_build_tgsi_context * bld_base,
			     const struct tgsi_full_instruction * inst,
			     const struct tgsi_opcode_info * info,
d1005 2
a1006 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d1010 2
d1018 1
a1018 1
		radeon_llvm_emit_store(bld_base, inst, info, dst);
d1023 3
a1025 3
		stride = unpack_param(si_shader_ctx, SI_PARAM_TCS_OUT_LAYOUT, 13, 8);
		dw_addr = get_tcs_out_current_patch_offset(si_shader_ctx);
		dw_addr = get_dw_address(si_shader_ctx, reg, NULL, stride, dw_addr);
d1027 2
a1028 2
		dw_addr = get_tcs_out_current_patch_data_offset(si_shader_ctx);
		dw_addr = get_dw_address(si_shader_ctx, reg, NULL, NULL, dw_addr);
d1031 9
d1044 1
a1044 1
			value = radeon_llvm_saturate(bld_base, value);
d1047 16
d1073 3
a1075 3
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
	struct si_shader *shader = si_shader_ctx->shader;
	struct lp_build_context *uint =	&si_shader_ctx->radeon_bld.soa.bld_base.uint_bld;
a1076 1
	LLVMTypeRef i32 = LLVMInt32TypeInContext(gallivm->context);
d1083 2
d1111 1
a1111 1
				      LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
d1115 2
a1116 1
	args[0] = si_shader_ctx->esgs_ring;
d1118 1
a1118 4
	args[2] = lp_build_const_int32(gallivm,
				       (get_param_index(semantic_name, semantic_index,
							shader->selector->inputs_read) * 4 +
					swizzle) * 256);
d1126 14
d1141 1
a1141 4
				lp_build_intrinsic(gallivm->builder,
						"llvm.SI.buffer.load.dword.i32.i32",
						i32, args, 9,
						LLVMReadOnlyAttribute | LLVMNoUnwindAttribute),
d1174 63
a1236 4
static void declare_input_fs(
	struct radeon_llvm_context *radeon_bld,
	unsigned input_index,
	const struct tgsi_full_declaration *decl)
d1238 2
a1239 5
	struct lp_build_context *base = &radeon_bld->soa.bld_base.base;
	struct si_shader_context *si_shader_ctx =
		si_shader_context(&radeon_bld->soa.bld_base);
	struct si_shader *shader = si_shader_ctx->shader;
	struct lp_build_context *uint =	&radeon_bld->soa.bld_base.uint_bld;
d1241 4
a1244 2
	LLVMTypeRef input_type = LLVMFloatTypeInContext(gallivm->context);
	LLVMValueRef main_fn = radeon_bld->main_fn;
d1246 1
a1246 3
	LLVMValueRef interp_param = NULL;
	int interp_param_idx;
	const char * intr_name;
d1248 4
a1251 5
	/* This value is:
	 * [15:0] NewPrimMask (Bit mask for each quad.  It is set it the
	 *                     quad begins a new primitive.  Bit 0 always needs
	 *                     to be unset)
	 * [32:16] ParamOffset
d1253 4
d1258 1
a1258 2
	LLVMValueRef params = LLVMGetParam(main_fn, SI_PARAM_PRIM_MASK);
	LLVMValueRef attr_number;
d1260 5
a1264 1
	unsigned chan;
d1266 6
a1271 29
	if (decl->Semantic.Name == TGSI_SEMANTIC_POSITION) {
		for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
			unsigned soa_index =
				radeon_llvm_reg_index_soa(input_index, chan);
			radeon_bld->inputs[soa_index] =
				LLVMGetParam(main_fn, SI_PARAM_POS_X_FLOAT + chan);

			if (chan == 3)
				/* RCP for fragcoord.w */
				radeon_bld->inputs[soa_index] =
					LLVMBuildFDiv(gallivm->builder,
						      lp_build_const_float(gallivm, 1.0f),
						      radeon_bld->inputs[soa_index],
						      "");
		}
		return;
	}

	if (decl->Semantic.Name == TGSI_SEMANTIC_FACE) {
		radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 0)] =
			LLVMGetParam(main_fn, SI_PARAM_FRONT_FACE);
		radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 1)] =
		radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 2)] =
			lp_build_const_float(gallivm, 0.0f);
		radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 3)] =
			lp_build_const_float(gallivm, 1.0f);

		return;
	}
d1273 1
a1273 23
	shader->ps_input_param_offset[input_index] = shader->nparam++;
	attr_number = lp_build_const_int32(gallivm,
					   shader->ps_input_param_offset[input_index]);

	shader->ps_input_interpolate[input_index] = decl->Interp.Interpolate;
	interp_param_idx = lookup_interp_param_index(decl->Interp.Interpolate,
						     decl->Interp.Location);
	if (interp_param_idx == -1)
		return;
	else if (interp_param_idx)
		interp_param = LLVMGetParam(main_fn, interp_param_idx);

	/* fs.constant returns the param from the middle vertex, so it's not
	 * really useful for flat shading. It's meant to be used for custom
	 * interpolation (but the intrinsic can't fetch from the other two
	 * vertices).
	 *
	 * Luckily, it doesn't matter, because we rely on the FLAT_SHADE state
	 * to do the right thing. The only reason we use fs.constant is that
	 * fs.interp cannot be used on integers, because they can be equal
	 * to NaN.
	 */
	intr_name = interp_param ? "llvm.SI.fs.interp" : "llvm.SI.fs.constant";
d1275 2
a1276 14
	if (decl->Semantic.Name == TGSI_SEMANTIC_COLOR &&
	    si_shader_ctx->shader->key.ps.color_two_side) {
		LLVMValueRef args[4];
		LLVMValueRef face, is_face_positive;
		LLVMValueRef back_attr_number =
			lp_build_const_int32(gallivm,
					     shader->ps_input_param_offset[input_index] + 1);

		face = LLVMGetParam(main_fn, SI_PARAM_FRONT_FACE);

		is_face_positive = LLVMBuildFCmp(gallivm->builder,
						 LLVMRealOGT, face,
						 lp_build_const_float(gallivm, 0.0f),
						 "");
d1278 1
a1278 1
		args[2] = params;
a1281 1
			unsigned soa_index = radeon_llvm_reg_index_soa(input_index, chan);
d1287 2
a1288 2
						input_type, args, args[3] ? 4 : 3,
						LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
d1292 2
a1293 2
					       input_type, args, args[3] ? 4 : 3,
					       LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
d1295 1
a1295 2
			radeon_bld->inputs[soa_index] =
				LLVMBuildSelect(gallivm->builder,
d1301 1
a1301 3

		shader->nparam++;
	} else if (decl->Semantic.Name == TGSI_SEMANTIC_FOG) {
d1306 1
a1306 1
		args[2] = params;
d1308 6
a1313 9
		radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 0)] =
			lp_build_intrinsic(gallivm->builder, intr_name,
					input_type, args, args[3] ? 4 : 3,
					LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
		radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 1)] =
		radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 2)] =
			lp_build_const_float(gallivm, 0.0f);
		radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 3)] =
			lp_build_const_float(gallivm, 1.0f);
d1318 1
a1318 1
			unsigned soa_index = radeon_llvm_reg_index_soa(input_index, chan);
d1321 1
a1321 1
			args[2] = params;
d1323 49
a1371 4
			radeon_bld->inputs[soa_index] =
				lp_build_intrinsic(gallivm->builder, intr_name,
						input_type, args, args[3] ? 4 : 3,
						LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
d1374 57
d1433 1
a1433 1
static LLVMValueRef get_sample_id(struct radeon_llvm_context *radeon_bld)
d1440 44
d1486 3
a1488 2
static LLVMValueRef buffer_load_const(LLVMBuilderRef builder, LLVMValueRef resource,
				      LLVMValueRef offset, LLVMTypeRef return_type)
d1490 1
d1493 2
a1494 2
	return lp_build_intrinsic(builder, "llvm.SI.load.const", return_type, args, 2,
			       LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
d1497 1
a1497 1
static LLVMValueRef load_sample_position(struct radeon_llvm_context *radeon_bld, LLVMValueRef sample_id)
d1499 1
a1499 1
	struct si_shader_context *si_shader_ctx =
d1504 3
a1506 3
	LLVMValueRef desc = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_CONST);
	LLVMValueRef buf_index = lp_build_const_int32(gallivm, SI_DRIVER_STATE_CONST_BUF);
	LLVMValueRef resource = build_indexed_load_const(si_shader_ctx, desc, buf_index);
d1513 2
a1514 2
		buffer_load_const(builder, resource, offset0, radeon_bld->soa.bld_base.base.elem_type),
		buffer_load_const(builder, resource, offset1, radeon_bld->soa.bld_base.base.elem_type),
d1523 1
a1523 1
	struct radeon_llvm_context * radeon_bld,
d1527 1
a1527 1
	struct si_shader_context *si_shader_ctx =
a1529 1
	struct lp_build_context *uint_bld = &radeon_bld->soa.bld_base.uint_bld;
d1536 1
a1536 1
				     si_shader_ctx->param_instance_id);
d1542 1
a1542 1
						  si_shader_ctx->param_vertex_id),
d1549 1
a1549 1
				     si_shader_ctx->param_vertex_id);
d1557 10
d1568 3
a1570 3
		if (si_shader_ctx->type == TGSI_PROCESSOR_TESS_CTRL)
			value = unpack_param(si_shader_ctx, SI_PARAM_REL_IDS, 8, 5);
		else if (si_shader_ctx->type == TGSI_PROCESSOR_GEOMETRY)
d1577 18
d1599 12
a1610 2
	case TGSI_SEMANTIC_SAMPLEPOS:
		value = load_sample_position(radeon_bld, get_sample_id(radeon_bld));
d1612 1
d1615 4
a1618 6
		/* Smoothing isn't MSAA in GL, but it's MSAA in hardware.
		 * Therefore, force gl_SampleMaskIn to 1 for GL. */
		if (si_shader_ctx->shader->key.ps.poly_line_smoothing)
			value = uint_bld->one;
		else
			value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_SAMPLE_COVERAGE);
d1624 2
a1625 2
			LLVMGetParam(radeon_bld->main_fn, si_shader_ctx->param_tes_u),
			LLVMGetParam(radeon_bld->main_fn, si_shader_ctx->param_tes_v),
d1631 1
a1631 1
		if (si_shader_ctx->shader->selector->info.properties[TGSI_PROPERTY_TES_PRIM_MODE] ==
d1641 6
a1646 1
		value = unpack_param(si_shader_ctx, SI_PARAM_TCS_OUT_LAYOUT, 26, 6);
d1652 1
a1652 1
		LLVMValueRef dw_addr;
d1655 11
a1665 3
		dw_addr = get_tcs_out_current_patch_data_offset(si_shader_ctx);
		dw_addr = LLVMBuildAdd(gallivm->builder, dw_addr,
				       lp_build_const_int32(gallivm, param * 4), "");
d1667 18
a1684 2
		value = lds_load(&radeon_bld->soa.bld_base, TGSI_TYPE_FLOAT,
				 ~0, dw_addr);
d1692 46
d1746 33
d1780 1
a1780 1
	struct lp_build_tgsi_context * bld_base,
d1785 2
a1786 2
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
	struct lp_build_context * base = &bld_base->base;
a1804 10
	if (!reg->Register.Indirect && !reg->Dimension.Indirect) {
		if (type != TGSI_TYPE_DOUBLE)
			return bitcast(bld_base, type, si_shader_ctx->constants[buf][idx]);
		else {
			return radeon_llvm_emit_fetch_double(bld_base,
							     si_shader_ctx->constants[buf][idx],
							     si_shader_ctx->constants[buf][idx + 1]);
		}
	}

d1806 1
a1806 1
		LLVMValueRef ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_CONST);
d1808 4
a1811 3
		index = get_indirect_index(si_shader_ctx, &reg->DimIndirect,
						   reg->Dimension.Index);
		bufp = build_indexed_load_const(si_shader_ctx, ptr, index);
d1813 1
a1813 1
		bufp = si_shader_ctx->const_resource[buf];
d1815 9
a1823 5
	addr = si_shader_ctx->radeon_bld.soa.addr[ireg->Index][ireg->Swizzle];
	addr = LLVMBuildLoad(base->gallivm->builder, addr, "load addr reg");
	addr = lp_build_mul_imm(&bld_base->uint_bld, addr, 16);
	addr = lp_build_add(&bld_base->uint_bld, addr,
			    lp_build_const_int32(base->gallivm, idx * 4));
d1825 1
a1825 2
	result = buffer_load_const(base->gallivm->builder, bufp,
				   addr, bld_base->base.elem_type);
d1827 1
a1827 1
	if (type != TGSI_TYPE_DOUBLE)
a1830 5
		addr2 = si_shader_ctx->radeon_bld.soa.addr[ireg->Index][ireg->Swizzle + 1];
		addr2 = LLVMBuildLoad(base->gallivm->builder, addr2, "load addr reg2");
		addr2 = lp_build_mul_imm(&bld_base->uint_bld, addr2, 16);
		addr2 = lp_build_add(&bld_base->uint_bld, addr2,
				     lp_build_const_int32(base->gallivm, idx * 4));
d1832 3
a1834 2
		result2 = buffer_load_const(base->gallivm->builder, si_shader_ctx->const_resource[buf],
				   addr2, bld_base->base.elem_type);
d1836 2
a1837 2
		result = radeon_llvm_emit_fetch_double(bld_base,
					               result, result2);
d1842 22
d1870 1
a1870 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d1872 1
a1872 1
				&si_shader_ctx->radeon_bld.soa.bld_base.uint_bld;
d1874 4
a1877 1
	unsigned compressed = 0;
d1879 4
d1884 12
a1895 1
	if (si_shader_ctx->type == TGSI_PROCESSOR_FRAGMENT) {
d1898 28
a1925 2
		if (cbuf >= 0 && cbuf < 8) {
			compressed = (si_shader_ctx->shader->key.ps.export_16bpc >> cbuf) & 0x1;
d1927 5
a1931 6
			if (compressed)
				si_shader_ctx->shader->spi_shader_col_format |=
					V_028714_SPI_SHADER_FP16_ABGR << (4 * cbuf);
			else
				si_shader_ctx->shader->spi_shader_col_format |=
					V_028714_SPI_SHADER_32_ABGR << (4 * cbuf);
d1933 2
a1934 3
			si_shader_ctx->shader->cb_shader_mask |= 0xf << (4 * cbuf);
		}
	}
d1936 11
a1946 5
	if (compressed) {
		/* Pixel shader needs to pack output values before export */
		for (chan = 0; chan < 2; chan++ ) {
			args[0] = values[2 * chan];
			args[1] = values[2 * chan + 1];
a1947 6
				lp_build_intrinsic(base->gallivm->builder,
						"llvm.SI.packf16",
						LLVMInt32TypeInContext(base->gallivm->context),
						args, 2,
						LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
			args[chan + 7] = args[chan + 5] =
d1949 1
a1949 3
						 args[chan + 5],
						 LLVMFloatTypeInContext(base->gallivm->context),
						 "");
d1951 1
d1953 10
a1962 7
		/* Set COMPR flag */
		args[4] = uint->one;
	} else {
		for (chan = 0; chan < 4; chan++ )
			/* +5 because the first output value will be
			 * the 6th argument to the intrinsic. */
			args[chan + 5] = values[chan];
d1964 6
a1969 3
		/* Clear COMPR flag */
		args[4] = uint->zero;
	}
d1971 28
a1998 6
	/* XXX: This controls which components of the output
	 * registers actually get exported. (e.g bit 0 means export
	 * X component, bit 1 means export Y component, etc.)  I'm
	 * hard coding this to 0xf for now.  In the future, we might
	 * want to do something else. */
	args[0] = lp_build_const_int32(base->gallivm, 0xf);
d2000 5
a2004 2
	/* Specify whether the EXEC mask represents the valid mask */
	args[1] = uint->zero;
d2006 7
a2012 2
	/* Specify whether this is the last export */
	args[2] = uint->zero;
d2014 7
a2020 2
	/* Specify the target we are exporting */
	args[3] = lp_build_const_int32(base->gallivm, target);
d2022 9
a2030 4
	/* XXX: We probably need to keep track of the output
	 * values, so we know what we are passing to the next
	 * stage. */
}
d2032 10
a2041 9
/* Load from output pointers and initialize arguments for the shader export intrinsic */
static void si_llvm_init_export_args_load(struct lp_build_tgsi_context *bld_base,
					  LLVMValueRef *out_ptr,
					  unsigned target,
					  LLVMValueRef *args)
{
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef values[4];
	int i;
d2043 7
a2049 2
	for (i = 0; i < 4; i++)
		values[i] = LLVMBuildLoad(gallivm->builder, out_ptr[i], "");
d2051 4
a2054 1
	si_llvm_init_export_args(bld_base, values, target, args);
d2058 1
a2058 1
			  LLVMValueRef alpha_ptr)
d2060 1
a2060 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d2063 2
a2064 2
	if (si_shader_ctx->shader->key.ps.alpha_func != PIPE_FUNC_NEVER) {
		LLVMValueRef alpha_ref = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
d2069 2
a2070 3
				     si_shader_ctx->shader->key.ps.alpha_func,
				     LLVMBuildLoad(gallivm->builder, alpha_ptr, ""),
				     alpha_ref);
d2077 2
a2078 4
		lp_build_intrinsic(gallivm->builder,
				"llvm.AMDGPU.kill",
				LLVMVoidTypeInContext(gallivm->context),
				&arg, 1, 0);
d2080 2
a2081 4
		lp_build_intrinsic(gallivm->builder,
				"llvm.AMDGPU.kilp",
				LLVMVoidTypeInContext(gallivm->context),
				NULL, 0, 0);
a2082 2

	si_shader_ctx->shader->db_shader_control |= S_02880C_KILL_ENABLE(1);
d2085 3
a2087 2
static void si_scale_alpha_by_sample_mask(struct lp_build_tgsi_context *bld_base,
					  LLVMValueRef alpha_ptr)
d2089 1
a2089 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d2091 1
a2091 1
	LLVMValueRef coverage, alpha;
d2094 2
a2095 2
	coverage = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
				SI_PARAM_SAMPLE_COVERAGE);
d2099 1
a2099 1
				   bld_base->int_bld.elem_type,
d2103 1
a2103 1
				   bld_base->base.elem_type, "");
d2109 1
a2109 3
	alpha = LLVMBuildLoad(gallivm->builder, alpha_ptr, "");
	alpha = LLVMBuildFMul(gallivm->builder, alpha, coverage, "");
	LLVMBuildStore(gallivm->builder, alpha, alpha_ptr);
d2112 1
a2112 1
static void si_llvm_emit_clipvertex(struct lp_build_tgsi_context * bld_base,
d2115 1
a2115 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d2117 1
a2117 1
	struct lp_build_context *uint = &si_shader_ctx->radeon_bld.soa.bld_base.uint_bld;
d2122 4
a2125 3
	LLVMValueRef ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_CONST);
	LLVMValueRef constbuf_index = lp_build_const_int32(base->gallivm, SI_DRIVER_STATE_CONST_BUF);
	LLVMValueRef const_resource = build_indexed_load_const(si_shader_ctx, ptr, constbuf_index);
d2141 2
a2142 2
				base_elt = buffer_load_const(base->gallivm->builder, const_resource,
						      args[1], base->elem_type);
a2179 71
/* TBUFFER_STORE_FORMAT_{X,XY,XYZ,XYZW} <- the suffix is selected by num_channels=1..4.
 * The type of vdata must be one of i32 (num_channels=1), v2i32 (num_channels=2),
 * or v4i32 (num_channels=3,4). */
static void build_tbuffer_store(struct si_shader_context *shader,
				LLVMValueRef rsrc,
				LLVMValueRef vdata,
				unsigned num_channels,
				LLVMValueRef vaddr,
				LLVMValueRef soffset,
				unsigned inst_offset,
				unsigned dfmt,
				unsigned nfmt,
				unsigned offen,
				unsigned idxen,
				unsigned glc,
				unsigned slc,
				unsigned tfe)
{
	struct gallivm_state *gallivm = &shader->radeon_bld.gallivm;
	LLVMTypeRef i32 = LLVMInt32TypeInContext(gallivm->context);
	LLVMValueRef args[] = {
		rsrc,
		vdata,
		LLVMConstInt(i32, num_channels, 0),
		vaddr,
		soffset,
		LLVMConstInt(i32, inst_offset, 0),
		LLVMConstInt(i32, dfmt, 0),
		LLVMConstInt(i32, nfmt, 0),
		LLVMConstInt(i32, offen, 0),
		LLVMConstInt(i32, idxen, 0),
		LLVMConstInt(i32, glc, 0),
		LLVMConstInt(i32, slc, 0),
		LLVMConstInt(i32, tfe, 0)
	};

	/* The instruction offset field has 12 bits */
	assert(offen || inst_offset < (1 << 12));

	/* The intrinsic is overloaded, we need to add a type suffix for overloading to work. */
	unsigned func = CLAMP(num_channels, 1, 3) - 1;
	const char *types[] = {"i32", "v2i32", "v4i32"};
	char name[256];
	snprintf(name, sizeof(name), "llvm.SI.tbuffer.store.%s", types[func]);

	lp_build_intrinsic(gallivm->builder, name,
			   LLVMVoidTypeInContext(gallivm->context),
			   args, Elements(args), 0);
}

static void build_tbuffer_store_dwords(struct si_shader_context *shader,
				     LLVMValueRef rsrc,
				     LLVMValueRef vdata,
				     unsigned num_channels,
				     LLVMValueRef vaddr,
				     LLVMValueRef soffset,
				     unsigned inst_offset)
{
	static unsigned dfmt[] = {
		V_008F0C_BUF_DATA_FORMAT_32,
		V_008F0C_BUF_DATA_FORMAT_32_32,
		V_008F0C_BUF_DATA_FORMAT_32_32_32,
		V_008F0C_BUF_DATA_FORMAT_32_32_32_32
	};
	assert(num_channels >= 1 && num_channels <= 4);

	build_tbuffer_store(shader, rsrc, vdata, num_channels, vaddr, soffset,
			    inst_offset, dfmt[num_channels-1],
			    V_008F0C_BUF_NUM_FORMAT_UINT, 1, 0, 1, 1, 0);
}

d2182 1
a2182 1
static void si_llvm_emit_streamout(struct si_shader_context *shader,
d2186 2
a2187 2
	struct pipe_stream_output_info *so = &shader->shader->selector->so;
	struct gallivm_state *gallivm = &shader->radeon_bld.gallivm;
d2191 9
d2201 3
a2203 1
	LLVMTypeRef i32 = LLVMInt32TypeInContext(gallivm->context);
d2207 1
a2207 1
		unpack_param(shader, shader->param_streamout_config, 16, 7);
d2209 1
a2209 2
	LLVMValueRef tid = lp_build_intrinsic(builder, "llvm.SI.tid", i32,
					   NULL, 0, LLVMReadNoneAttribute);
d2216 1
a2216 1
		unpack_param(shader, shader->param_streamout_config, 24, 2);
d2230 2
a2231 2
			LLVMGetParam(shader->radeon_bld.main_fn,
				     shader->param_streamout_write_index);
d2242 3
a2244 3
			LLVMValueRef so_offset = LLVMGetParam(shader->radeon_bld.main_fn,
							      shader->param_streamout_offset[i]);
			so_offset = LLVMBuildMul(builder, so_offset, LLVMConstInt(i32, 4, 0), "");
d2247 1
a2247 1
							  LLVMConstInt(i32, so->stride[i]*4, 0), "");
d2272 1
a2272 1
						i32, "");
d2285 1
a2285 1
				vdata = LLVMGetUndef(LLVMVectorType(i32, util_next_power_of_two(num_comps)));
d2288 1
a2288 1
								       LLVMConstInt(i32, j, 0), "");
d2299 1
a2299 1
			build_tbuffer_store_dwords(shader, shader->so_buffers[buf_idx],
d2302 1
a2302 1
						   LLVMConstInt(i32, 0, 0),
d2316 5
a2320 5
	struct si_shader_context * si_shader_ctx = si_shader_context(bld_base);
	struct si_shader * shader = si_shader_ctx->shader;
	struct lp_build_context * base = &bld_base->base;
	struct lp_build_context * uint =
				&si_shader_ctx->radeon_bld.soa.bld_base.uint_bld;
d2330 2
a2331 2
	if (outputs && si_shader_ctx->shader->selector->so.num_outputs) {
		si_llvm_emit_streamout(si_shader_ctx, outputs, noutput);
d2361 2
a2362 1
			shader->vs_output_param_offset[i] = param_count;
d2376 2
a2377 1
			shader->vs_output_param_offset[i] = param_count;
d2395 1
a2395 2
					   "llvm.SI.export",
					   LLVMVoidTypeInContext(base->gallivm->context),
d2405 1
a2405 1
	shader->nr_param_exports = param_count;
d2447 1
a2447 1
							 bld_base->uint_bld.elem_type, "");
d2455 1
a2455 1
							  base->elem_type, "");
d2467 1
a2467 1
			shader->nr_pos_exports++;
d2477 1
a2477 1
		if (pos_idx == shader->nr_pos_exports)
d2481 44
a2524 4
		lp_build_intrinsic(base->gallivm->builder,
				   "llvm.SI.export",
				   LLVMVoidTypeInContext(base->gallivm->context),
				   pos_args[i], 9, 0);
d2528 4
a2531 2
/* This only writes the tessellation factor levels. */
static void si_llvm_emit_tcs_epilogue(struct lp_build_tgsi_context *bld_base)
d2533 1
a2533 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d2535 1
a2535 1
	struct si_shader *shader = si_shader_ctx->shader;
d2537 2
a2538 3
	LLVMValueRef lds_base, lds_inner, lds_outer;
	LLVMValueRef tf_base, rel_patch_id, byteoffset, buffer, rw_buffers;
	LLVMValueRef out[6], vec0, vec1, invocation_id;
d2540 1
a2540 1
	struct lp_build_if_state if_ctx;
d2542 1
a2542 1
	invocation_id = unpack_param(si_shader_ctx, SI_PARAM_REL_IDS, 8, 5);
d2555 1
a2555 1
	switch (shader->key.tcs.prim_mode) {
d2582 1
a2582 1
	lds_base = get_tcs_out_current_patch_data_offset(si_shader_ctx);
d2590 12
a2601 4
	for (i = 0; i < outer_comps; i++)
		out[i] = lds_load(bld_base, TGSI_TYPE_SIGNED, i, lds_outer);
	for (i = 0; i < inner_comps; i++)
		out[outer_comps+i] = lds_load(bld_base, TGSI_TYPE_SIGNED, i, lds_inner);
d2611 1
a2611 1
	rw_buffers = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
d2613 2
a2614 2
	buffer = build_indexed_load_const(si_shader_ctx, rw_buffers,
			lp_build_const_int32(gallivm, SI_RING_TESS_FACTOR));
d2617 1
a2617 1
	tf_base = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
a2618 1
	rel_patch_id = get_rel_patch_id(si_shader_ctx);
d2622 14
a2635 3
	/* Store the outputs. */
	build_tbuffer_store_dwords(si_shader_ctx, buffer, vec0,
				   MIN2(stride, 4), byteoffset, tf_base, 0);
d2637 2
a2638 2
		build_tbuffer_store_dwords(si_shader_ctx, buffer, vec1,
					   stride - 4, byteoffset, tf_base, 16);
d2642 53
a2694 1
static void si_llvm_emit_ls_epilogue(struct lp_build_tgsi_context * bld_base)
d2696 2
a2697 2
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
	struct si_shader *shader = si_shader_ctx->shader;
d2701 2
a2702 2
	LLVMValueRef vertex_id = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
					      si_shader_ctx->param_rel_auto_id);
d2704 1
a2704 1
		unpack_param(si_shader_ctx, SI_PARAM_LS_OUT_LAYOUT, 13, 8);
d2711 1
a2711 1
		LLVMValueRef *out_ptr = si_shader_ctx->radeon_bld.soa.outputs[i];
d2725 1
a2725 1
static void si_llvm_emit_es_epilogue(struct lp_build_tgsi_context * bld_base)
d2727 1
a2727 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d2729 1
a2729 1
	struct si_shader *es = si_shader_ctx->shader;
d2731 2
a2732 6
	LLVMTypeRef i32 = LLVMInt32TypeInContext(gallivm->context);
	LLVMValueRef soffset = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
					    si_shader_ctx->param_es2gs_offset);
	uint64_t enabled_outputs = si_shader_ctx->type == TGSI_PROCESSOR_TESS_EVAL ?
					   es->key.tes.es_enabled_outputs :
					   es->key.vs.es_enabled_outputs;
d2738 1
a2738 1
			si_shader_ctx->radeon_bld.soa.outputs[i];
d2745 2
a2746 5
		param_index = get_param_index(info->output_semantic_name[i],
					      info->output_semantic_index[i],
					      enabled_outputs);
		if (param_index < 0)
			continue;
d2750 1
a2750 1
			out_val = LLVMBuildBitCast(gallivm->builder, out_val, i32, "");
d2752 2
a2753 2
			build_tbuffer_store(si_shader_ctx,
					    si_shader_ctx->esgs_ring,
d2755 1
a2755 1
					    LLVMGetUndef(i32), soffset,
d2766 1
a2766 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d2771 1
a2771 1
	args[1] = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_GS_WAVE_ID);
d2773 1
a2773 2
			LLVMVoidTypeInContext(gallivm->context), args, 2,
			LLVMNoUnwindAttribute);
d2776 1
a2776 1
static void si_llvm_emit_vs_epilogue(struct lp_build_tgsi_context * bld_base)
d2778 1
a2778 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d2780 1
a2780 1
	struct tgsi_shader_info *info = &si_shader_ctx->shader->selector->info;
d2784 2
d2788 38
d2833 1
a2833 1
					      si_shader_ctx->radeon_bld.soa.outputs[i][j],
d2837 20
a2856 10
	/* Export PrimitiveID when PS needs it. */
	if (si_vs_exports_prim_id(si_shader_ctx->shader)) {
		outputs[i].name = TGSI_SEMANTIC_PRIMID;
		outputs[i].sid = 0;
		outputs[i].values[0] = bitcast(bld_base, TGSI_TYPE_FLOAT,
					       get_primitive_id(bld_base, 0));
		outputs[i].values[1] = bld_base->base.undef;
		outputs[i].values[2] = bld_base->base.undef;
		outputs[i].values[3] = bld_base->base.undef;
		i++;
d2863 193
a3055 1
static void si_llvm_emit_fs_epilogue(struct lp_build_tgsi_context * bld_base)
d3057 3
a3059 4
	struct si_shader_context * si_shader_ctx = si_shader_context(bld_base);
	struct si_shader * shader = si_shader_ctx->shader;
	struct lp_build_context * base = &bld_base->base;
	struct lp_build_context * uint = &bld_base->uint_bld;
d3061 3
a3063 3
	LLVMValueRef args[9];
	LLVMValueRef last_args[9] = { 0 };
	int depth_index = -1, stencil_index = -1, samplemask_index = -1;
d3065 39
d3108 2
a3109 2
		unsigned target;
		LLVMValueRef alpha_ptr;
d3114 3
a3116 2
			depth_index = i;
			continue;
d3118 3
a3120 2
			stencil_index = i;
			continue;
d3122 3
a3124 2
			samplemask_index = i;
			continue;
d3126 7
a3132 13
			target = V_008DFC_SQ_EXP_MRT + semantic_index;
			alpha_ptr = si_shader_ctx->radeon_bld.soa.outputs[i][3];

			if (si_shader_ctx->shader->key.ps.alpha_to_one)
				LLVMBuildStore(base->gallivm->builder,
					       base->one, alpha_ptr);

			if (semantic_index == 0 &&
			    si_shader_ctx->shader->key.ps.alpha_func != PIPE_FUNC_ALWAYS)
				si_alpha_test(bld_base, alpha_ptr);

			if (si_shader_ctx->shader->key.ps.poly_line_smoothing)
				si_scale_alpha_by_sample_mask(bld_base, alpha_ptr);
a3134 1
			target = 0;
d3139 29
d3169 3
a3171 12
		si_llvm_init_export_args_load(bld_base,
					      si_shader_ctx->radeon_bld.soa.outputs[i],
					      target, args);

		if (semantic_name == TGSI_SEMANTIC_COLOR) {
			/* If there is an export instruction waiting to be emitted, do so now. */
			if (last_args[0]) {
				lp_build_intrinsic(base->gallivm->builder,
						   "llvm.SI.export",
						   LLVMVoidTypeInContext(base->gallivm->context),
						   last_args, 9, 0);
			}
d3173 4
a3176 2
			/* This instruction will be emitted at the end of the shader. */
			memcpy(last_args, args, sizeof(args));
d3178 7
a3184 13
			/* Handle FS_COLOR0_WRITES_ALL_CBUFS. */
			if (shader->selector->info.properties[TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS] &&
			    semantic_index == 0 &&
			    si_shader_ctx->shader->key.ps.last_cbuf > 0) {
				for (int c = 1; c <= si_shader_ctx->shader->key.ps.last_cbuf; c++) {
					si_llvm_init_export_args_load(bld_base,
								      si_shader_ctx->radeon_bld.soa.outputs[i],
								      V_008DFC_SQ_EXP_MRT + c, args);
					lp_build_intrinsic(base->gallivm->builder,
							   "llvm.SI.export",
							   LLVMVoidTypeInContext(base->gallivm->context),
							   args, 9, 0);
				}
d3186 16
a3201 5
		} else {
			lp_build_intrinsic(base->gallivm->builder,
					   "llvm.SI.export",
					   LLVMVoidTypeInContext(base->gallivm->context),
					   args, 9, 0);
d3205 15
a3219 3
	if (depth_index >= 0 || stencil_index >= 0 || samplemask_index >= 0) {
		LLVMValueRef out_ptr;
		unsigned mask = 0;
d3221 16
a3236 2
		/* Specify the target we are exporting */
		args[3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_MRTZ);
d3238 2
a3239 11
		args[5] = base->zero; /* R, depth */
		args[6] = base->zero; /* G, stencil test value[0:7], stencil op value[8:15] */
		args[7] = base->zero; /* B, sample mask */
		args[8] = base->zero; /* A, alpha to mask */

		if (depth_index >= 0) {
			out_ptr = si_shader_ctx->radeon_bld.soa.outputs[depth_index][2];
			args[5] = LLVMBuildLoad(base->gallivm->builder, out_ptr, "");
			mask |= 0x1;
			si_shader_ctx->shader->db_shader_control |= S_02880C_Z_EXPORT_ENABLE(1);
		}
d3241 27
a3267 7
		if (stencil_index >= 0) {
			out_ptr = si_shader_ctx->radeon_bld.soa.outputs[stencil_index][1];
			args[6] = LLVMBuildLoad(base->gallivm->builder, out_ptr, "");
			mask |= 0x2;
			si_shader_ctx->shader->db_shader_control |=
				S_02880C_STENCIL_TEST_VAL_EXPORT_ENABLE(1);
		}
d3269 2
a3270 6
		if (samplemask_index >= 0) {
			out_ptr = si_shader_ctx->radeon_bld.soa.outputs[samplemask_index][0];
			args[7] = LLVMBuildLoad(base->gallivm->builder, out_ptr, "");
			mask |= 0x4;
			si_shader_ctx->shader->db_shader_control |= S_02880C_MASK_EXPORT_ENABLE(1);
		}
d3272 2
a3273 5
		/* SI (except OLAND) has a bug that it only looks
		 * at the X writemask component. */
		if (si_shader_ctx->screen->b.chip_class == SI &&
		    si_shader_ctx->screen->b.family != CHIP_OLAND)
			mask |= 0x1;
d3275 38
a3312 6
		if (samplemask_index >= 0)
			si_shader_ctx->shader->spi_shader_z_format = V_028710_SPI_SHADER_32_ABGR;
		else if (stencil_index >= 0)
			si_shader_ctx->shader->spi_shader_z_format = V_028710_SPI_SHADER_32_GR;
		else
			si_shader_ctx->shader->spi_shader_z_format = V_028710_SPI_SHADER_32_R;
d3314 3
a3316 2
		/* Specify which components to enable */
		args[0] = lp_build_const_int32(base->gallivm, mask);
d3318 13
a3330 3
		args[1] =
		args[2] =
		args[4] = uint->zero;
d3332 4
a3335 8
		if (last_args[0])
			lp_build_intrinsic(base->gallivm->builder,
					   "llvm.SI.export",
					   LLVMVoidTypeInContext(base->gallivm->context),
					   args, 9, 0);
		else
			memcpy(last_args, args, sizeof(args));
	}
d3337 10
a3346 3
	if (!last_args[0]) {
		/* Specify which components to enable */
		last_args[0] = lp_build_const_int32(base->gallivm, 0x0);
d3348 17
a3364 2
		/* Specify the target we are exporting */
		last_args[3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_MRT);
d3366 2
a3367 2
		/* Set COMPR flag to zero to export data as 32-bit */
		last_args[4] = uint->zero;
d3369 3
a3371 6
		/* dummy bits */
		last_args[5]= uint->zero;
		last_args[6]= uint->zero;
		last_args[7]= uint->zero;
		last_args[8]= uint->zero;
	}
d3373 7
a3379 2
	/* Specify whether the EXEC mask represents the valid mask */
	last_args[1] = uint->one;
d3381 6
a3386 2
	/* Specify that this is the last export */
	last_args[2] = lp_build_const_int32(base->gallivm, 1);
d3388 1
a3388 4
	lp_build_intrinsic(base->gallivm->builder,
			   "llvm.SI.export",
			   LLVMVoidTypeInContext(base->gallivm->context),
			   last_args, 9, 0);
d3391 1
a3391 5
static void build_tex_intrinsic(const struct lp_build_tgsi_action * action,
				struct lp_build_tgsi_context * bld_base,
				struct lp_build_emit_data * emit_data);

static bool tgsi_is_shadow_sampler(unsigned target)
d3393 1
a3393 1
	return target == TGSI_TEXTURE_SHADOW1D ||
d3395 1
a3395 1
	       target == TGSI_TEXTURE_SHADOW2D ||
d3397 1
a3397 1
	       target == TGSI_TEXTURE_SHADOWCUBE ||
d3399 1
a3399 1
	       target == TGSI_TEXTURE_SHADOWRECT;
d3402 9
a3410 1
static const struct lp_build_tgsi_action tex_action;
d3412 13
a3424 3
static void tex_fetch_args(
	struct lp_build_tgsi_context * bld_base,
	struct lp_build_emit_data * emit_data)
d3426 13
a3438 16
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	unsigned opcode = inst->Instruction.Opcode;
	unsigned target = inst->Texture.Texture;
	LLVMValueRef coords[5], derivs[6];
	LLVMValueRef address[16];
	int ref_pos;
	unsigned num_coords = tgsi_util_get_texture_coord_dim(target, &ref_pos);
	unsigned count = 0;
	unsigned chan;
	unsigned sampler_src;
	unsigned sampler_index;
	unsigned num_deriv_channels = 0;
	bool has_offset = HAVE_LLVM >= 0x0305 ? inst->Texture.NumOffsets > 0 : false;
	LLVMValueRef res_ptr, samp_ptr, fmask_ptr = NULL;
d3440 14
a3453 6
	sampler_src = emit_data->inst->Instruction.NumSrcRegs - 1;
	sampler_index = emit_data->inst->Src[sampler_src].Register.Index;

	if (emit_data->inst->Src[sampler_src].Register.Indirect) {
		const struct tgsi_full_src_register *reg = &emit_data->inst->Src[sampler_src];
		LLVMValueRef ind_index;
d3455 1
a3455 1
		ind_index = get_indirect_index(si_shader_ctx, &reg->Indirect, reg->Register.Index);
d3457 2
a3458 2
		res_ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_RESOURCE);
		res_ptr = build_indexed_load_const(si_shader_ctx, res_ptr, ind_index);
d3460 1
a3460 2
		samp_ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_SAMPLER);
		samp_ptr = build_indexed_load_const(si_shader_ctx, samp_ptr, ind_index);
d3462 3
a3464 8
		if (target == TGSI_TEXTURE_2D_MSAA ||
		    target == TGSI_TEXTURE_2D_ARRAY_MSAA) {
			ind_index = LLVMBuildAdd(gallivm->builder, ind_index,
						 lp_build_const_int32(gallivm,
								      SI_FMASK_TEX_OFFSET), "");
			fmask_ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_RESOURCE);
			fmask_ptr = build_indexed_load_const(si_shader_ctx, fmask_ptr, ind_index);
		}
d3466 12
a3477 3
		res_ptr = si_shader_ctx->resources[sampler_index];
		samp_ptr = si_shader_ctx->samplers[sampler_index];
		fmask_ptr = si_shader_ctx->resources[SI_FMASK_TEX_OFFSET + sampler_index];
d3480 1030
a4509 5
	if (target == TGSI_TEXTURE_BUFFER) {
		LLVMTypeRef i128 = LLVMIntTypeInContext(gallivm->context, 128);
		LLVMTypeRef v2i128 = LLVMVectorType(i128, 2);
		LLVMTypeRef i8 = LLVMInt8TypeInContext(gallivm->context);
		LLVMTypeRef v16i8 = LLVMVectorType(i8, 16);
d4515 1
a4515 1
		res = LLVMBuildBitCast(gallivm->builder, res, v16i8, "");
d4517 1
a4517 1
		emit_data->dst_type = LLVMVectorType(bld_base->base.elem_type, 4);
d4520 1
a4520 1
		emit_data->args[2] = lp_build_emit_fetch(bld_base, emit_data->inst, 0, 0);
d4569 1
a4569 1
		address[count++] = lp_build_emit_fetch(bld_base, inst, 1, 0);
d4572 3
a4574 1
	if (tgsi_is_shadow_sampler(target) && opcode != TGSI_OPCODE_LODQ) {
d4576 1
a4576 1
			address[count++] = lp_build_emit_fetch(bld_base, inst, 1, 0);
d4579 1
a4579 1
			address[count++] = coords[ref_pos];
d4581 12
d4629 1
a4629 1
			assert(0); /* no other targets are valid here */
d4642 1
a4642 1
		radeon_llvm_emit_prepare_cube_coords(bld_base, emit_data, coords, derivs);
d4659 1
a4659 1
		address[count++] = lp_build_emit_fetch(bld_base, inst, 1, 0);
d4668 1
a4668 3
						 address[chan],
						 LLVMInt32TypeInContext(gallivm->context),
						 "");
a4699 4
		/* Pad to a power-of-two size. */
		while (txf_count < util_next_power_of_two(txf_count))
			txf_address[txf_count++] = LLVMGetUndef(LLVMInt32TypeInContext(gallivm->context));

d4702 1
a4702 1
		inst.Texture.Texture = target == TGSI_TEXTURE_2D_MSAA ? TGSI_TEXTURE_2D : TGSI_TEXTURE_2D_ARRAY;
d4705 3
a4707 7
		txf_emit_data.dst_type = LLVMVectorType(
			LLVMInt32TypeInContext(gallivm->context), 4);
		txf_emit_data.args[0] = lp_build_gather_values(gallivm, txf_address, txf_count);
		txf_emit_data.args[1] = fmask_ptr;
		txf_emit_data.args[2] = lp_build_const_int32(gallivm, inst.Texture.Texture);
		txf_emit_data.arg_count = 3;

d4711 2
a4712 2
		LLVMValueRef four = LLVMConstInt(uint_bld->elem_type, 4, 0);
		LLVMValueRef F = LLVMConstInt(uint_bld->elem_type, 0xF, 0);
d4736 1
a4736 1
					 LLVMVectorType(uint_bld->elem_type, 8), "");
a4751 3
	/* Resource */
	emit_data->args[1] = res_ptr;

d4757 1
a4757 1
			const struct tgsi_texture_offset * off = inst->TexOffsets;
d4787 4
d4792 7
a4798 2
		emit_data->args[2] = lp_build_const_int32(gallivm, target);
		emit_data->arg_count = 3;
d4800 5
a4804 25
		emit_data->dst_type = LLVMVectorType(
			LLVMInt32TypeInContext(gallivm->context),
			4);
	} else if (opcode == TGSI_OPCODE_TG4 ||
		   opcode == TGSI_OPCODE_LODQ ||
		   has_offset) {
		unsigned is_array = target == TGSI_TEXTURE_1D_ARRAY ||
				    target == TGSI_TEXTURE_SHADOW1D_ARRAY ||
				    target == TGSI_TEXTURE_2D_ARRAY ||
				    target == TGSI_TEXTURE_SHADOW2D_ARRAY ||
				    target == TGSI_TEXTURE_CUBE_ARRAY ||
				    target == TGSI_TEXTURE_SHADOWCUBE_ARRAY;
		unsigned is_rect = target == TGSI_TEXTURE_RECT;
		unsigned dmask = 0xf;

		if (opcode == TGSI_OPCODE_TG4) {
			unsigned gather_comp = 0;

			/* DMASK was repurposed for GATHER4. 4 components are always
			 * returned and DMASK works like a swizzle - it selects
			 * the component to fetch. The only valid DMASK values are
			 * 1=red, 2=green, 4=blue, 8=alpha. (e.g. 1 returns
			 * (red,red,red,red) etc.) The ISA document doesn't mention
			 * this.
			 */
d4806 1
a4806 12
			/* Get the component index from src1.x for Gather4. */
			if (!tgsi_is_shadow_sampler(target)) {
				LLVMValueRef (*imms)[4] = lp_soa_context(bld_base)->immediates;
				LLVMValueRef comp_imm;
				struct tgsi_src_register src1 = inst->Src[1].Register;

				assert(src1.File == TGSI_FILE_IMMEDIATE);

				comp_imm = imms[src1.Index][src1.SwizzleX];
				gather_comp = LLVMConstIntGetZExtValue(comp_imm);
				gather_comp = CLAMP(gather_comp, 0, 3);
			}
d4808 3
a4810 1
			dmask = 1 << gather_comp;
d4813 1
a4813 23
		emit_data->args[2] = samp_ptr;
		emit_data->args[3] = lp_build_const_int32(gallivm, dmask);
		emit_data->args[4] = lp_build_const_int32(gallivm, is_rect); /* unorm */
		emit_data->args[5] = lp_build_const_int32(gallivm, 0); /* r128 */
		emit_data->args[6] = lp_build_const_int32(gallivm, is_array); /* da */
		emit_data->args[7] = lp_build_const_int32(gallivm, 0); /* glc */
		emit_data->args[8] = lp_build_const_int32(gallivm, 0); /* slc */
		emit_data->args[9] = lp_build_const_int32(gallivm, 0); /* tfe */
		emit_data->args[10] = lp_build_const_int32(gallivm, 0); /* lwe */

		emit_data->arg_count = 11;

		emit_data->dst_type = LLVMVectorType(
			LLVMFloatTypeInContext(gallivm->context),
			4);
	} else {
		emit_data->args[2] = samp_ptr;
		emit_data->args[3] = lp_build_const_int32(gallivm, target);
		emit_data->arg_count = 4;

		emit_data->dst_type = LLVMVectorType(
			LLVMFloatTypeInContext(gallivm->context),
			4);
d4816 29
a4844 6
	/* The fetch opcode has been converted to a 2D array fetch.
	 * This simplifies the LLVM backend. */
	if (target == TGSI_TEXTURE_CUBE_ARRAY)
		target = TGSI_TEXTURE_2D_ARRAY;
	else if (target == TGSI_TEXTURE_SHADOWCUBE_ARRAY)
		target = TGSI_TEXTURE_SHADOW2D_ARRAY;
d4846 24
a4869 3
	/* Pad to power of two vector */
	while (count < util_next_power_of_two(count))
		address[count++] = LLVMGetUndef(LLVMInt32TypeInContext(gallivm->context));
d4871 16
a4886 1
	emit_data->args[0] = lp_build_gather_values(gallivm, address, count);
d4889 3
a4891 3
static void build_tex_intrinsic(const struct lp_build_tgsi_action * action,
				struct lp_build_tgsi_context * bld_base,
				struct lp_build_emit_data * emit_data)
d4893 5
a4897 3
	struct lp_build_context * base = &bld_base->base;
	unsigned opcode = emit_data->inst->Instruction.Opcode;
	unsigned target = emit_data->inst->Texture.Texture;
d4899 5
a4903 2
	bool has_offset = HAVE_LLVM >= 0x0305 ?
				emit_data->inst->Texture.NumOffsets > 0 : false;
d4910 1
a4910 1
			LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
d4914 40
a4953 35
	if (opcode == TGSI_OPCODE_TG4 ||
	    opcode == TGSI_OPCODE_LODQ ||
	    (opcode != TGSI_OPCODE_TXF && has_offset)) {
		bool is_shadow = tgsi_is_shadow_sampler(target);
		const char *name = "llvm.SI.image.sample";
		const char *infix = "";

		switch (opcode) {
		case TGSI_OPCODE_TEX:
		case TGSI_OPCODE_TEX2:
		case TGSI_OPCODE_TXP:
			break;
		case TGSI_OPCODE_TXB:
		case TGSI_OPCODE_TXB2:
			infix = ".b";
			break;
		case TGSI_OPCODE_TXL:
		case TGSI_OPCODE_TXL2:
			infix = ".l";
			break;
		case TGSI_OPCODE_TXD:
			infix = ".d";
			break;
		case TGSI_OPCODE_TG4:
			name = "llvm.SI.gather4";
			break;
		case TGSI_OPCODE_LODQ:
			name = "llvm.SI.getlod";
			is_shadow = false;
			has_offset = false;
			break;
		default:
			assert(0);
			return;
		}
d4955 14
a4968 4
		/* Add the type and suffixes .c, .o if needed. */
		sprintf(intr_name, "%s%s%s%s.v%ui32", name,
			is_shadow ? ".c" : "", infix, has_offset ? ".o" : "",
			LLVMGetVectorSize(LLVMTypeOf(emit_data->args[0])));
d4970 1
a4970 7
		emit_data->output[emit_data->chan] = lp_build_intrinsic(
			base->gallivm->builder, intr_name, emit_data->dst_type,
			emit_data->args, emit_data->arg_count,
			LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
	} else {
		LLVMTypeRef i8, v16i8, v32i8;
		const char *name;
d4972 8
a4979 22
		switch (opcode) {
		case TGSI_OPCODE_TEX:
		case TGSI_OPCODE_TEX2:
		case TGSI_OPCODE_TXP:
			name = "llvm.SI.sample";
			break;
		case TGSI_OPCODE_TXB:
		case TGSI_OPCODE_TXB2:
			name = "llvm.SI.sampleb";
			break;
		case TGSI_OPCODE_TXD:
			name = "llvm.SI.sampled";
			break;
		case TGSI_OPCODE_TXF:
			name = "llvm.SI.imageload";
			break;
		case TGSI_OPCODE_TXL:
		case TGSI_OPCODE_TXL2:
			name = "llvm.SI.samplel";
			break;
		default:
			assert(0);
d4982 1
d4984 4
a4987 19
		i8 = LLVMInt8TypeInContext(base->gallivm->context);
		v16i8 = LLVMVectorType(i8, 16);
		v32i8 = LLVMVectorType(i8, 32);

		emit_data->args[1] = LLVMBuildBitCast(base->gallivm->builder,
						emit_data->args[1], v32i8, "");
		if (opcode != TGSI_OPCODE_TXF) {
			emit_data->args[2] = LLVMBuildBitCast(base->gallivm->builder,
						emit_data->args[2], v16i8, "");
		}

		sprintf(intr_name, "%s.v%ui32", name,
			LLVMGetVectorSize(LLVMTypeOf(emit_data->args[0])));

		emit_data->output[emit_data->chan] = lp_build_intrinsic(
			base->gallivm->builder, intr_name, emit_data->dst_type,
			emit_data->args, emit_data->arg_count,
			LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
	}
d4990 4
a4993 3
static void txq_fetch_args(
	struct lp_build_tgsi_context * bld_base,
	struct lp_build_emit_data * emit_data)
d4995 1
a4995 2
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
	const struct tgsi_full_instruction *inst = emit_data->inst;
d4998 2
a4999 76
	unsigned target = inst->Texture.Texture;
	LLVMValueRef res_ptr;

	if (inst->Src[1].Register.Indirect) {
		const struct tgsi_full_src_register *reg = &inst->Src[1];
		LLVMValueRef ind_index;

		ind_index = get_indirect_index(si_shader_ctx, &reg->Indirect, reg->Register.Index);

		res_ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_RESOURCE);
		res_ptr = build_indexed_load_const(si_shader_ctx, res_ptr,
						   ind_index);
	} else
		res_ptr = si_shader_ctx->resources[inst->Src[1].Register.Index];

	if (target == TGSI_TEXTURE_BUFFER) {
		LLVMTypeRef i32 = LLVMInt32TypeInContext(gallivm->context);
		LLVMTypeRef v8i32 = LLVMVectorType(i32, 8);

		/* Read the size from the buffer descriptor directly. */
		LLVMValueRef res = LLVMBuildBitCast(builder, res_ptr, v8i32, "");
		LLVMValueRef size = LLVMBuildExtractElement(builder, res,
						lp_build_const_int32(gallivm, 6), "");

		if (si_shader_ctx->screen->b.chip_class >= VI) {
			/* On VI, the descriptor contains the size in bytes,
			 * but TXQ must return the size in elements.
			 * The stride is always non-zero for resources using TXQ.
			 */
			LLVMValueRef stride =
				LLVMBuildExtractElement(builder, res,
							lp_build_const_int32(gallivm, 5), "");
			stride = LLVMBuildLShr(builder, stride,
					       lp_build_const_int32(gallivm, 16), "");
			stride = LLVMBuildAnd(builder, stride,
					      lp_build_const_int32(gallivm, 0x3FFF), "");

			size = LLVMBuildUDiv(builder, size, stride, "");
		}

		emit_data->args[0] = size;
		return;
	}

	/* Mip level */
	emit_data->args[0] = lp_build_emit_fetch(bld_base, inst, 0, TGSI_CHAN_X);

	/* Resource */
	emit_data->args[1] = res_ptr;

	/* Texture target */
	if (target == TGSI_TEXTURE_CUBE_ARRAY ||
	    target == TGSI_TEXTURE_SHADOWCUBE_ARRAY)
		target = TGSI_TEXTURE_2D_ARRAY;

	emit_data->args[2] = lp_build_const_int32(bld_base->base.gallivm,
						  target);

	emit_data->arg_count = 3;

	emit_data->dst_type = LLVMVectorType(
		LLVMInt32TypeInContext(bld_base->base.gallivm->context),
		4);
}

static void build_txq_intrinsic(const struct lp_build_tgsi_action * action,
				struct lp_build_tgsi_context * bld_base,
				struct lp_build_emit_data * emit_data)
{
	unsigned target = emit_data->inst->Texture.Texture;

	if (target == TGSI_TEXTURE_BUFFER) {
		/* Just return the buffer size. */
		emit_data->output[emit_data->chan] = emit_data->args[0];
		return;
	}
d5001 1
a5001 1
	build_tgsi_intrinsic_nomem(action, bld_base, emit_data);
a5002 6
	/* Divide the number of layers by 6 to get the number of cubes. */
	if (target == TGSI_TEXTURE_CUBE_ARRAY ||
	    target == TGSI_TEXTURE_SHADOWCUBE_ARRAY) {
		LLVMBuilderRef builder = bld_base->base.gallivm->builder;
		LLVMValueRef two = lp_build_const_int32(bld_base->base.gallivm, 2);
		LLVMValueRef six = lp_build_const_int32(bld_base->base.gallivm, 6);
d5004 11
a5014 3
		LLVMValueRef v4 = emit_data->output[emit_data->chan];
		LLVMValueRef z = LLVMBuildExtractElement(builder, v4, two, "");
		z = LLVMBuildSDiv(builder, z, six, "");
d5016 1
a5016 3
		emit_data->output[emit_data->chan] =
			LLVMBuildInsertElement(builder, v4, z, two, "");
	}
d5049 3
a5051 3
	const struct lp_build_tgsi_action * action,
	struct lp_build_tgsi_context * bld_base,
	struct lp_build_emit_data * emit_data)
d5053 1
a5053 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d5055 2
a5056 9
	struct lp_build_context * base = &bld_base->base;
	const struct tgsi_full_instruction *inst = emit_data->inst;
	unsigned opcode = inst->Instruction.Opcode;
	LLVMValueRef indices[2];
	LLVMValueRef store_ptr, load_ptr0, load_ptr1;
	LLVMValueRef tl, trbl, result[4];
	LLVMTypeRef i32;
	unsigned swizzle[4];
	unsigned c;
d5060 1
a5060 7
	i32 = LLVMInt32TypeInContext(gallivm->context);

	indices[0] = bld_base->uint_bld.zero;
	indices[1] = lp_build_intrinsic(gallivm->builder, "llvm.SI.tid", i32,
				     NULL, 0, LLVMReadNoneAttribute);
	store_ptr = LLVMBuildGEP(gallivm->builder, si_shader_ctx->lds,
				 indices, 2, "");
d5069 2
a5070 4
	indices[1] = LLVMBuildAnd(gallivm->builder, indices[1],
				  lp_build_const_int32(gallivm, mask), "");
	load_ptr0 = LLVMBuildGEP(gallivm->builder, si_shader_ctx->lds,
				 indices, 2, "");
d5074 1
a5074 1
	indices[1] = LLVMBuildAdd(gallivm->builder, indices[1],
a5075 2
	load_ptr1 = LLVMBuildGEP(gallivm->builder, si_shader_ctx->lds,
				 indices, 2, "");
d5077 1
a5077 2
	for (c = 0; c < 4; ++c) {
		unsigned i;
d5079 15
a5093 9
		swizzle[c] = tgsi_util_get_full_src_register_swizzle(&inst->Src[0], c);
		for (i = 0; i < c; ++i) {
			if (swizzle[i] == swizzle[c]) {
				result[c] = result[i];
				break;
			}
		}
		if (i != c)
			continue;
d5095 3
a5097 5
		LLVMBuildStore(gallivm->builder,
			       LLVMBuildBitCast(gallivm->builder,
						lp_build_emit_fetch(bld_base, inst, 0, c),
						i32, ""),
			       store_ptr);
d5099 1
a5100 2
		tl = LLVMBuildBitCast(gallivm->builder, tl, base->elem_type, "");

d5102 1
a5102 1
		trbl = LLVMBuildBitCast(gallivm->builder, trbl,	base->elem_type, "");
d5104 2
a5105 2
		result[c] = LLVMBuildFSub(gallivm->builder, trbl, tl, "");
	}
d5107 2
a5108 1
	emit_data->output[0] = lp_build_gather_values(gallivm, result, 4);
d5120 1
a5120 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d5122 2
a5123 54
	struct lp_build_context *base = &bld_base->base;
	LLVMValueRef indices[2];
	LLVMValueRef store_ptr, load_ptr_x, load_ptr_y, load_ptr_ddx, load_ptr_ddy, temp, temp2;
	LLVMValueRef tl, tr, bl, result[4];
	LLVMTypeRef i32;
	unsigned c;

	i32 = LLVMInt32TypeInContext(gallivm->context);

	indices[0] = bld_base->uint_bld.zero;
	indices[1] = lp_build_intrinsic(gallivm->builder, "llvm.SI.tid", i32,
					NULL, 0, LLVMReadNoneAttribute);
	store_ptr = LLVMBuildGEP(gallivm->builder, si_shader_ctx->lds,
				 indices, 2, "");

	temp = LLVMBuildAnd(gallivm->builder, indices[1],
			    lp_build_const_int32(gallivm, TID_MASK_LEFT), "");

	temp2 = LLVMBuildAnd(gallivm->builder, indices[1],
			     lp_build_const_int32(gallivm, TID_MASK_TOP), "");

	indices[1] = temp;
	load_ptr_x = LLVMBuildGEP(gallivm->builder, si_shader_ctx->lds,
				  indices, 2, "");

	indices[1] = temp2;
	load_ptr_y = LLVMBuildGEP(gallivm->builder, si_shader_ctx->lds,
				  indices, 2, "");

	indices[1] = LLVMBuildAdd(gallivm->builder, temp,
				  lp_build_const_int32(gallivm, 1), "");
	load_ptr_ddx = LLVMBuildGEP(gallivm->builder, si_shader_ctx->lds,
				   indices, 2, "");

	indices[1] = LLVMBuildAdd(gallivm->builder, temp2,
				  lp_build_const_int32(gallivm, 2), "");
	load_ptr_ddy = LLVMBuildGEP(gallivm->builder, si_shader_ctx->lds,
				   indices, 2, "");

	for (c = 0; c < 2; ++c) {
		LLVMValueRef store_val;
		LLVMValueRef c_ll = lp_build_const_int32(gallivm, c);

		store_val = LLVMBuildExtractElement(gallivm->builder,
						    interp_ij, c_ll, "");
		LLVMBuildStore(gallivm->builder,
			       store_val,
			       store_ptr);

		tl = LLVMBuildLoad(gallivm->builder, load_ptr_x, "");
		tl = LLVMBuildBitCast(gallivm->builder, tl, base->elem_type, "");

		tr = LLVMBuildLoad(gallivm->builder, load_ptr_ddx, "");
		tr = LLVMBuildBitCast(gallivm->builder, tr, base->elem_type, "");
d5125 5
a5129 9
		result[c] = LLVMBuildFSub(gallivm->builder, tr, tl, "");

		tl = LLVMBuildLoad(gallivm->builder, load_ptr_y, "");
		tl = LLVMBuildBitCast(gallivm->builder, tl, base->elem_type, "");

		bl = LLVMBuildLoad(gallivm->builder, load_ptr_ddy, "");
		bl = LLVMBuildBitCast(gallivm->builder, bl, base->elem_type, "");

		result[c + 2] = LLVMBuildFSub(gallivm->builder, bl, tl, "");
d5139 1
a5139 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d5147 1
a5147 1
							 0);
d5150 1
a5150 1
							 1);
d5161 1
a5161 1
						emit_data->inst, 1, 0);
d5163 2
a5164 3
					     LLVMInt32TypeInContext(gallivm->context),
					     "");
		sample_position = load_sample_position(&si_shader_ctx->radeon_bld, sample_id);
d5183 2
a5184 2
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
	struct si_shader *shader = si_shader_ctx->shader;
d5189 1
a5189 1
	int input_index;
d5193 1
a5193 2
	LLVMTypeRef input_type = LLVMFloatTypeInContext(gallivm->context);
	LLVMValueRef params = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_PRIM_MASK);
d5195 1
a5198 1
	input_index = inst->Src[0].Register.Index;
d5206 1
a5206 2
	interp_param_idx = lookup_interp_param_index(shader->ps_input_interpolate[input_index],
						     location);
d5210 1
a5210 1
		interp_param = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, interp_param_idx);
d5214 1
a5214 2
	attr_number = lp_build_const_int32(gallivm,
					   shader->ps_input_param_offset[input_index]);
d5241 1
a5241 1
						     LLVMFloatTypeInContext(gallivm->context), "");
d5252 1
a5252 2
						     temp2,
						     LLVMIntTypeInContext(gallivm->context, 32), "");
d5258 1
a5258 1
	for (chan = 0; chan < 2; chan++) {
d5273 2
a5274 2
					   input_type, args, args[3] ? 4 : 3,
					   LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
d5297 1
a5297 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d5299 1
a5299 1
	struct si_shader *shader = si_shader_ctx->shader;
d5302 2
a5303 2
	LLVMTypeRef i32 = LLVMInt32TypeInContext(gallivm->context);
	LLVMValueRef soffset = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
d5316 1
a5316 1
				       si_shader_ctx->gs_next_vertex[stream],
d5320 6
a5325 3
	 * vertices, kill it: excessive vertex emissions are not supposed to
	 * have any effect, and GS threads have no externally observable
	 * effects other than emitting vertices.
d5327 1
a5327 1
	can_emit = LLVMBuildICmp(gallivm->builder, LLVMIntULE, gs_next_vertex,
a5329 3
	kill = lp_build_select(&bld_base->base, can_emit,
			       lp_build_const_float(gallivm, 1.0f),
			       lp_build_const_float(gallivm, -1.0f));
d5331 11
a5341 2
	lp_build_intrinsic(gallivm->builder, "llvm.AMDGPU.kill",
			   LLVMVoidTypeInContext(gallivm->context), &kill, 1, 0);
d5345 1
a5345 1
			si_shader_ctx->radeon_bld.soa.outputs[i];
d5356 1
a5356 1
			out_val = LLVMBuildBitCast(gallivm->builder, out_val, i32, "");
d5358 2
a5359 2
			build_tbuffer_store(si_shader_ctx,
					    si_shader_ctx->gsvs_ring[stream],
d5367 1
d5371 1
a5371 1
	LLVMBuildStore(gallivm->builder, gs_next_vertex, si_shader_ctx->gs_next_vertex[stream]);
d5375 1
a5375 1
	args[1] = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_GS_WAVE_ID);
d5377 4
a5380 2
			LLVMVoidTypeInContext(gallivm->context), args, 2,
			LLVMNoUnwindAttribute);
d5389 1
a5389 1
	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
d5397 1
a5397 1
	args[1] = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_GS_WAVE_ID);
d5399 1
a5399 2
			LLVMVoidTypeInContext(gallivm->context), args, 2,
			LLVMNoUnwindAttribute);
d5406 1
d5409 15
a5423 3
	lp_build_intrinsic(gallivm->builder, "llvm.AMDGPU.barrier.local",
			LLVMVoidTypeInContext(gallivm->context), NULL, 0,
			LLVMNoUnwindAttribute);
a5430 6
static const struct lp_build_tgsi_action txq_action = {
	.fetch_args = txq_fetch_args,
	.emit = build_txq_intrinsic,
	.intr_name = "llvm.SI.resinfo"
};

d5436 4
a5439 1
static void create_meta_data(struct si_shader_context *si_shader_ctx)
d5441 9
a5449 2
	struct gallivm_state *gallivm = si_shader_ctx->radeon_bld.soa.bld_base.base.gallivm;
	LLVMValueRef args[3];
d5451 13
a5463 3
	args[0] = LLVMMDStringInContext(gallivm->context, "const", 5);
	args[1] = 0;
	args[2] = lp_build_const_int32(gallivm, 1);
d5465 15
a5479 1
	si_shader_ctx->const_md = LLVMMDNodeInContext(gallivm->context, args, 3);
d5482 12
a5493 4
static LLVMTypeRef const_array(LLVMTypeRef elem_type, int num_elements)
{
	return LLVMPointerType(LLVMArrayType(elem_type, num_elements),
			       CONST_ADDR_SPACE);
d5496 1
a5496 1
static void declare_streamout_params(struct si_shader_context *si_shader_ctx,
d5505 6
a5510 2
		params[si_shader_ctx->param_streamout_config = (*num_params)++] = i32;
		params[si_shader_ctx->param_streamout_write_index = (*num_params)++] = i32;
d5517 49
a5565 1
		params[si_shader_ctx->param_streamout_offset[i] = (*num_params)++] = i32;
d5567 1
d5570 1
a5570 1
static void create_function(struct si_shader_context *si_shader_ctx)
d5572 1
a5572 1
	struct lp_build_tgsi_context *bld_base = &si_shader_ctx->radeon_bld.soa.bld_base;
d5574 21
a5594 26
	struct si_shader *shader = si_shader_ctx->shader;
	LLVMTypeRef params[SI_NUM_PARAMS], f32, i8, i32, v2i32, v3i32, v16i8, v4i32, v8i32;
	unsigned i, last_array_pointer, last_sgpr, num_params;

	i8 = LLVMInt8TypeInContext(gallivm->context);
	i32 = LLVMInt32TypeInContext(gallivm->context);
	f32 = LLVMFloatTypeInContext(gallivm->context);
	v2i32 = LLVMVectorType(i32, 2);
	v3i32 = LLVMVectorType(i32, 3);
	v4i32 = LLVMVectorType(i32, 4);
	v8i32 = LLVMVectorType(i32, 8);
	v16i8 = LLVMVectorType(i8, 16);

	params[SI_PARAM_RW_BUFFERS] = const_array(v16i8, SI_NUM_RW_BUFFERS);
	params[SI_PARAM_CONST] = const_array(v16i8, SI_NUM_CONST_BUFFERS);
	params[SI_PARAM_SAMPLER] = const_array(v4i32, SI_NUM_SAMPLER_STATES);
	params[SI_PARAM_RESOURCE] = const_array(v8i32, SI_NUM_SAMPLER_VIEWS);
	last_array_pointer = SI_PARAM_RESOURCE;

	switch (si_shader_ctx->type) {
	case TGSI_PROCESSOR_VERTEX:
		params[SI_PARAM_VERTEX_BUFFER] = const_array(v16i8, SI_NUM_VERTEX_BUFFERS);
		last_array_pointer = SI_PARAM_VERTEX_BUFFER;
		params[SI_PARAM_BASE_VERTEX] = i32;
		params[SI_PARAM_START_INSTANCE] = i32;
		num_params = SI_PARAM_START_INSTANCE+1;
d5597 1
a5597 1
			params[si_shader_ctx->param_es2gs_offset = num_params++] = i32;
d5599 1
a5599 1
			params[SI_PARAM_LS_OUT_LAYOUT] = i32;
d5602 5
a5606 3
			if (shader->is_gs_copy_shader) {
				last_array_pointer = SI_PARAM_CONST;
				num_params = SI_PARAM_CONST+1;
d5610 2
a5611 2
			declare_streamout_params(si_shader_ctx, &shader->selector->so,
						 params, i32, &num_params);
d5617 18
a5634 4
		params[si_shader_ctx->param_vertex_id = num_params++] = i32;
		params[si_shader_ctx->param_rel_auto_id = num_params++] = i32;
		params[si_shader_ctx->param_vs_prim_id = num_params++] = i32;
		params[si_shader_ctx->param_instance_id = num_params++] = i32;
d5637 7
a5643 5
	case TGSI_PROCESSOR_TESS_CTRL:
		params[SI_PARAM_TCS_OUT_OFFSETS] = i32;
		params[SI_PARAM_TCS_OUT_LAYOUT] = i32;
		params[SI_PARAM_TCS_IN_LAYOUT] = i32;
		params[SI_PARAM_TESS_FACTOR_OFFSET] = i32;
d5647 2
a5648 2
		params[SI_PARAM_PATCH_ID] = i32;
		params[SI_PARAM_REL_IDS] = i32;
d5650 11
d5663 3
a5665 4
	case TGSI_PROCESSOR_TESS_EVAL:
		params[SI_PARAM_TCS_OUT_OFFSETS] = i32;
		params[SI_PARAM_TCS_OUT_LAYOUT] = i32;
		num_params = SI_PARAM_TCS_OUT_LAYOUT+1;
d5668 3
a5670 1
			params[si_shader_ctx->param_es2gs_offset = num_params++] = i32;
d5672 4
a5675 2
			declare_streamout_params(si_shader_ctx, &shader->selector->so,
						 params, i32, &num_params);
d5680 9
a5688 4
		params[si_shader_ctx->param_tes_u = num_params++] = f32;
		params[si_shader_ctx->param_tes_v = num_params++] = f32;
		params[si_shader_ctx->param_tes_rel_patch_id = num_params++] = i32;
		params[si_shader_ctx->param_tes_patch_id = num_params++] = i32;
d5691 3
a5693 3
	case TGSI_PROCESSOR_GEOMETRY:
		params[SI_PARAM_GS2VS_OFFSET] = i32;
		params[SI_PARAM_GS_WAVE_ID] = i32;
d5697 8
a5704 8
		params[SI_PARAM_VTX0_OFFSET] = i32;
		params[SI_PARAM_VTX1_OFFSET] = i32;
		params[SI_PARAM_PRIMITIVE_ID] = i32;
		params[SI_PARAM_VTX2_OFFSET] = i32;
		params[SI_PARAM_VTX3_OFFSET] = i32;
		params[SI_PARAM_VTX4_OFFSET] = i32;
		params[SI_PARAM_VTX5_OFFSET] = i32;
		params[SI_PARAM_GS_INSTANCE_ID] = i32;
d5708 3
a5710 3
	case TGSI_PROCESSOR_FRAGMENT:
		params[SI_PARAM_ALPHA_REF] = f32;
		params[SI_PARAM_PRIM_MASK] = i32;
d5712 3
a5714 3
		params[SI_PARAM_PERSP_SAMPLE] = v2i32;
		params[SI_PARAM_PERSP_CENTER] = v2i32;
		params[SI_PARAM_PERSP_CENTROID] = v2i32;
d5716 12
a5727 12
		params[SI_PARAM_LINEAR_SAMPLE] = v2i32;
		params[SI_PARAM_LINEAR_CENTER] = v2i32;
		params[SI_PARAM_LINEAR_CENTROID] = v2i32;
		params[SI_PARAM_LINE_STIPPLE_TEX] = f32;
		params[SI_PARAM_POS_X_FLOAT] = f32;
		params[SI_PARAM_POS_Y_FLOAT] = f32;
		params[SI_PARAM_POS_Z_FLOAT] = f32;
		params[SI_PARAM_POS_W_FLOAT] = f32;
		params[SI_PARAM_FRONT_FACE] = f32;
		params[SI_PARAM_ANCILLARY] = i32;
		params[SI_PARAM_SAMPLE_COVERAGE] = f32;
		params[SI_PARAM_POS_FIXED_PT] = f32;
d5729 31
d5762 9
d5776 1
a5776 7
	assert(num_params <= Elements(params));
	radeon_llvm_create_func(&si_shader_ctx->radeon_bld, params, num_params);
	radeon_llvm_shader_type(si_shader_ctx->radeon_bld.main_fn, si_shader_ctx->type);

	if (shader->dx10_clamp_mode)
		LLVMAddTargetDependentFunctionAttr(si_shader_ctx->radeon_bld.main_fn,
						   "enable-no-nans-fp-math", "true");
d5778 2
a5779 2
	for (i = 0; i <= last_sgpr; ++i) {
		LLVMValueRef P = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, i);
d5781 17
a5797 6
		/* We tell llvm that array inputs are passed by value to allow Sinking pass
		 * to move load. Inputs are constant so this is fine. */
		if (i <= last_array_pointer)
			LLVMAddAttribute(P, LLVMByValAttribute);
		else
			LLVMAddAttribute(P, LLVMInRegAttribute);
d5800 15
a5814 1
	if (bld_base->info &&
d5821 1
a5821 1
		si_shader_ctx->lds =
d5823 1
a5823 1
						    LLVMArrayType(i32, 64),
d5827 4
a5830 115
	if ((si_shader_ctx->type == TGSI_PROCESSOR_VERTEX && shader->key.vs.as_ls) ||
	    si_shader_ctx->type == TGSI_PROCESSOR_TESS_CTRL ||
	    si_shader_ctx->type == TGSI_PROCESSOR_TESS_EVAL) {
		/* This is the upper bound, maximum is 32 inputs times 32 vertices */
		unsigned vertex_data_dw_size = 32*32*4;
		unsigned patch_data_dw_size = 32*4;
		/* The formula is: TCS inputs + TCS outputs + TCS patch outputs. */
		unsigned patch_dw_size = vertex_data_dw_size*2 + patch_data_dw_size;
		unsigned lds_dwords = patch_dw_size;

		/* The actual size is computed outside of the shader to reduce
		 * the number of shader variants. */
		si_shader_ctx->lds =
			LLVMAddGlobalInAddressSpace(gallivm->module,
						    LLVMArrayType(i32, lds_dwords),
						    "tess_lds",
						    LOCAL_ADDR_SPACE);
	}
}

static void preload_constants(struct si_shader_context *si_shader_ctx)
{
	struct lp_build_tgsi_context * bld_base = &si_shader_ctx->radeon_bld.soa.bld_base;
	struct gallivm_state * gallivm = bld_base->base.gallivm;
	const struct tgsi_shader_info * info = bld_base->info;
	unsigned buf;
	LLVMValueRef ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_CONST);

	for (buf = 0; buf < SI_NUM_CONST_BUFFERS; buf++) {
		unsigned i, num_const = info->const_file_max[buf] + 1;

		if (num_const == 0)
			continue;

		/* Allocate space for the constant values */
		si_shader_ctx->constants[buf] = CALLOC(num_const * 4, sizeof(LLVMValueRef));

		/* Load the resource descriptor */
		si_shader_ctx->const_resource[buf] =
			build_indexed_load_const(si_shader_ctx, ptr, lp_build_const_int32(gallivm, buf));

		/* Load the constants, we rely on the code sinking to do the rest */
		for (i = 0; i < num_const * 4; ++i) {
			si_shader_ctx->constants[buf][i] =
				buffer_load_const(gallivm->builder,
					si_shader_ctx->const_resource[buf],
					lp_build_const_int32(gallivm, i * 4),
					bld_base->base.elem_type);
		}
	}
}

static void preload_samplers(struct si_shader_context *si_shader_ctx)
{
	struct lp_build_tgsi_context * bld_base = &si_shader_ctx->radeon_bld.soa.bld_base;
	struct gallivm_state * gallivm = bld_base->base.gallivm;
	const struct tgsi_shader_info * info = bld_base->info;

	unsigned i, num_samplers = info->file_max[TGSI_FILE_SAMPLER] + 1;

	LLVMValueRef res_ptr, samp_ptr;
	LLVMValueRef offset;

	if (num_samplers == 0)
		return;

	res_ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_RESOURCE);
	samp_ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_SAMPLER);

	/* Load the resources and samplers, we rely on the code sinking to do the rest */
	for (i = 0; i < num_samplers; ++i) {
		/* Resource */
		offset = lp_build_const_int32(gallivm, i);
		si_shader_ctx->resources[i] = build_indexed_load_const(si_shader_ctx, res_ptr, offset);

		/* Sampler */
		offset = lp_build_const_int32(gallivm, i);
		si_shader_ctx->samplers[i] = build_indexed_load_const(si_shader_ctx, samp_ptr, offset);

		/* FMASK resource */
		if (info->is_msaa_sampler[i]) {
			offset = lp_build_const_int32(gallivm, SI_FMASK_TEX_OFFSET + i);
			si_shader_ctx->resources[SI_FMASK_TEX_OFFSET + i] =
				build_indexed_load_const(si_shader_ctx, res_ptr, offset);
		}
	}
}

static void preload_streamout_buffers(struct si_shader_context *si_shader_ctx)
{
	struct lp_build_tgsi_context * bld_base = &si_shader_ctx->radeon_bld.soa.bld_base;
	struct gallivm_state * gallivm = bld_base->base.gallivm;
	unsigned i;

	/* Streamout can only be used if the shader is compiled as VS. */
	if (!si_shader_ctx->shader->selector->so.num_outputs ||
	    (si_shader_ctx->type == TGSI_PROCESSOR_VERTEX &&
	     (si_shader_ctx->shader->key.vs.as_es ||
	      si_shader_ctx->shader->key.vs.as_ls)) ||
	    (si_shader_ctx->type == TGSI_PROCESSOR_TESS_EVAL &&
	     si_shader_ctx->shader->key.tes.as_es))
		return;

	LLVMValueRef buf_ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
					    SI_PARAM_RW_BUFFERS);

	/* Load the resources, we rely on the code sinking to do the rest */
	for (i = 0; i < 4; ++i) {
		if (si_shader_ctx->shader->selector->so.stride[i]) {
			LLVMValueRef offset = lp_build_const_int32(gallivm,
								   SI_SO_BUF_OFFSET + i);

			si_shader_ctx->so_buffers[i] = build_indexed_load_const(si_shader_ctx, buf_ptr, offset);
		}
	}
d5837 1
a5837 1
static void preload_ring_buffers(struct si_shader_context *si_shader_ctx)
d5840 1
a5840 1
		si_shader_ctx->radeon_bld.soa.bld_base.base.gallivm;
d5842 1
a5842 1
	LLVMValueRef buf_ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
d5845 12
a5856 9
	if ((si_shader_ctx->type == TGSI_PROCESSOR_VERTEX &&
	     si_shader_ctx->shader->key.vs.as_es) ||
	    (si_shader_ctx->type == TGSI_PROCESSOR_TESS_EVAL &&
	     si_shader_ctx->shader->key.tes.as_es) ||
	    si_shader_ctx->type == TGSI_PROCESSOR_GEOMETRY) {
		LLVMValueRef offset = lp_build_const_int32(gallivm, SI_RING_ESGS);

		si_shader_ctx->esgs_ring =
			build_indexed_load_const(si_shader_ctx, buf_ptr, offset);
d5859 2
a5860 2
	if (si_shader_ctx->shader->is_gs_copy_shader) {
		LLVMValueRef offset = lp_build_const_int32(gallivm, SI_RING_GSVS);
d5862 2
a5863 2
		si_shader_ctx->gsvs_ring[0] =
			build_indexed_load_const(si_shader_ctx, buf_ptr, offset);
d5865 1
a5865 1
	if (si_shader_ctx->type == TGSI_PROCESSOR_GEOMETRY) {
d5868 1
a5868 1
			LLVMValueRef offset = lp_build_const_int32(gallivm, SI_RING_GSVS + i);
d5870 2
a5871 2
			si_shader_ctx->gsvs_ring[i] =
				build_indexed_load_const(si_shader_ctx, buf_ptr, offset);
d5876 38
a5913 3
void si_shader_binary_read_config(const struct si_screen *sscreen,
				struct si_shader *shader,
				unsigned symbol_offset)
d5917 15
a5931 2
		radeon_shader_binary_config_start(&shader->binary,
						symbol_offset);
d5937 1
a5937 1
	for (i = 0; i < shader->binary.config_size_per_symbol; i+= 8) {
d5945 4
a5948 3
			shader->num_sgprs = MAX2(shader->num_sgprs, (G_00B028_SGPRS(value) + 1) * 8);
			shader->num_vgprs = MAX2(shader->num_vgprs, (G_00B028_VGPRS(value) + 1) * 4);
			shader->float_mode =  G_00B028_FLOAT_MODE(value);
d5951 1
a5951 1
			shader->lds_size = MAX2(shader->lds_size, G_00B02C_EXTRA_LDS_SIZE(value));
d5954 2
a5955 1
			shader->lds_size = MAX2(shader->lds_size, G_00B84C_LDS_SIZE(value));
d5958 4
a5961 1
			shader->spi_ps_input_ena = value;
d5966 9
a5974 2
			shader->scratch_bytes_per_wave =
				G_00B860_WAVESIZE(value) * 256 * 4 * 1;
d5977 9
a5985 2
			fprintf(stderr, "Warning: Compiler emitted unknown "
				"config register: 0x%x\n", reg);
d5989 3
d5996 1
d6000 1
a6000 1
	uint32_t scratch_rsrc_dword0 = scratch_va & 0xffffffff;
d6002 10
a6011 2
		S_008F04_BASE_ADDRESS_HI(scratch_va >> 32)
		|  S_008F04_STRIDE(shader->scratch_bytes_per_wave / 64);
d6026 11
d6039 7
a6045 2
	const struct radeon_shader_binary *binary = &shader->binary;
	unsigned code_size = binary->code_size + binary->rodata_size;
d6048 4
d6055 1
a6055 1
					       code_size);
d6059 2
a6060 1
	ptr = sscreen->b.ws->buffer_map(shader->bo->cs_buf, NULL,
d6062 4
a6065 5
	util_memcpy_cpu_to_le32(ptr, binary->code, binary->code_size);
	if (binary->rodata_size > 0) {
		ptr += binary->code_size;
		util_memcpy_cpu_to_le32(ptr, binary->rodata,
					binary->rodata_size);
d6068 9
a6076 1
	sscreen->b.ws->buffer_unmap(shader->bo->cs_buf);
d6080 19
a6098 7
int si_shader_binary_read(struct si_screen *sscreen, struct si_shader *shader)
{
	const struct radeon_shader_binary *binary = &shader->binary;
	unsigned i;
	int r;
	bool dump  = r600_can_dump_shader(&sscreen->b,
		shader->selector ? shader->selector->tokens : NULL);
d6100 9
a6108 4
	si_shader_binary_read_config(sscreen, shader, 0);
	r = si_shader_binary_upload(sscreen, shader);
	if (r)
		return r;
d6110 3
a6112 12
	if (dump) {
		if (!(sscreen->b.debug_flags & DBG_NO_ASM)) {
			if (binary->disasm_string) {
				fprintf(stderr, "\nShader Disassembly:\n\n");
				fprintf(stderr, "%s\n", binary->disasm_string);
			} else {
				fprintf(stderr, "SI CODE:\n");
				for (i = 0; i < binary->code_size; i+=4 ) {
					fprintf(stderr, "@@0x%x: %02x%02x%02x%02x\n", i, binary->code[i + 3],
					binary->code[i + 2], binary->code[i + 1],
					binary->code[i]);
				}
d6114 3
d6118 146
d6265 4
a6268 5
		fprintf(stderr, "*** SHADER STATS ***\n"
			"SGPRS: %d\nVGPRS: %d\nCode Size: %d bytes\nLDS: %d blocks\n"
			"Scratch: %d bytes per wave\n********************\n",
			shader->num_sgprs, shader->num_vgprs, binary->code_size,
			shader->lds_size, shader->scratch_bytes_per_wave);
d6270 5
a6274 1
	return 0;
d6277 8
a6284 2
int si_compile_llvm(struct si_screen *sscreen, struct si_shader *shader,
		    LLVMTargetMachineRef tm, LLVMModuleRef mod)
d6287 39
a6325 8
	bool dump_asm = r600_can_dump_shader(&sscreen->b,
				shader->selector ? shader->selector->tokens : NULL);
	bool dump_ir = dump_asm && !(sscreen->b.debug_flags & DBG_NO_IR);

	r = radeon_llvm_compile(mod, &shader->binary,
		r600_get_llvm_processor_name(sscreen->b.family), dump_ir, dump_asm, tm);
	if (r)
		return r;
d6327 4
a6330 1
	r = si_shader_binary_read(sscreen, shader);
d6332 10
a6341 8
	FREE(shader->binary.config);
	FREE(shader->binary.rodata);
	FREE(shader->binary.global_symbol_offsets);
	if (shader->scratch_bytes_per_wave == 0) {
		FREE(shader->binary.code);
		FREE(shader->binary.relocs);
		memset(&shader->binary, 0,
		       offsetof(struct radeon_shader_binary, disasm_string));
d6343 1
d6347 8
d6357 3
a6359 2
				      struct si_shader_context *si_shader_ctx,
				      struct si_shader *gs, bool dump)
d6361 2
a6362 3
	struct gallivm_state *gallivm = &si_shader_ctx->radeon_bld.gallivm;
	struct lp_build_tgsi_context *bld_base = &si_shader_ctx->radeon_bld.soa.bld_base;
	struct lp_build_context *base = &bld_base->base;
a6363 1
	struct si_shader *shader = si_shader_ctx->shader;
d6371 7
a6377 4
	si_shader_ctx->type = TGSI_PROCESSOR_VERTEX;
	shader->is_gs_copy_shader = true;

	radeon_llvm_context_init(&si_shader_ctx->radeon_bld);
d6379 1
a6379 6
	create_meta_data(si_shader_ctx);
	create_function(si_shader_ctx);
	preload_streamout_buffers(si_shader_ctx);
	preload_ring_buffers(si_shader_ctx);

	args[0] = si_shader_ctx->gsvs_ring[0];
d6381 2
a6382 2
				   LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
						si_shader_ctx->param_vertex_id),
d6407 3
a6409 4
								 LLVMInt32TypeInContext(gallivm->context),
								 args, 9,
								 LLVMReadOnlyAttribute | LLVMNoUnwindAttribute),
						 base->elem_type, "");
d6415 1
a6415 1
	radeon_llvm_finalize_module(&si_shader_ctx->radeon_bld);
d6417 20
a6436 2
	if (dump)
		fprintf(stderr, "Copy Vertex Shader for Geometry Shader:\n\n");
d6438 1
a6438 4
	r = si_compile_llvm(sscreen, si_shader_ctx->shader,
			    si_shader_ctx->tm, bld_base->base.gallivm->module);

	radeon_llvm_dispose(&si_shader_ctx->radeon_bld);
d6444 2
a6445 1
static void si_dump_key(unsigned shader, union si_shader_key *key)
d6449 1
a6449 1
	fprintf(stderr, "SHADER KEY\n");
d6453 8
a6460 11
		fprintf(stderr, "  instance_divisors = {");
		for (i = 0; i < Elements(key->vs.instance_divisors); i++)
			fprintf(stderr, !i ? "%u" : ", %u",
				key->vs.instance_divisors[i]);
		fprintf(stderr, "}\n");

		if (key->vs.as_es)
			fprintf(stderr, "  es_enabled_outputs = 0x%"PRIx64"\n",
				key->vs.es_enabled_outputs);
		fprintf(stderr, "  as_es = %u\n", key->vs.as_es);
		fprintf(stderr, "  as_ls = %u\n", key->vs.as_ls);
d6464 1
a6464 1
		fprintf(stderr, "  prim_mode = %u\n", key->tcs.prim_mode);
d6468 2
a6469 4
		if (key->tes.as_es)
			fprintf(stderr, "  es_enabled_outputs = 0x%"PRIx64"\n",
				key->tes.es_enabled_outputs);
		fprintf(stderr, "  as_es = %u\n", key->tes.as_es);
d6473 1
d6477 17
a6493 6
		fprintf(stderr, "  export_16bpc = 0x%X\n", key->ps.export_16bpc);
		fprintf(stderr, "  last_cbuf = %u\n", key->ps.last_cbuf);
		fprintf(stderr, "  color_two_side = %u\n", key->ps.color_two_side);
		fprintf(stderr, "  alpha_func = %u\n", key->ps.alpha_func);
		fprintf(stderr, "  alpha_to_one = %u\n", key->ps.alpha_to_one);
		fprintf(stderr, "  poly_stipple = %u\n", key->ps.poly_stipple);
d6501 21
a6521 29
int si_shader_create(struct si_screen *sscreen, LLVMTargetMachineRef tm,
		     struct si_shader *shader)
{
	struct si_shader_selector *sel = shader->selector;
	struct tgsi_token *tokens = sel->tokens;
	struct si_shader_context si_shader_ctx;
	struct lp_build_tgsi_context * bld_base;
	struct tgsi_shader_info stipple_shader_info;
	LLVMModuleRef mod;
	int r = 0;
	bool poly_stipple = sel->type == PIPE_SHADER_FRAGMENT &&
			    shader->key.ps.poly_stipple;
	bool dump = r600_can_dump_shader(&sscreen->b, sel->tokens);

	if (poly_stipple) {
		tokens = util_pstipple_create_fragment_shader(tokens, NULL,
						SI_POLY_STIPPLE_SAMPLER);
		tgsi_scan_shader(tokens, &stipple_shader_info);
	}

	/* Dump TGSI code before doing TGSI->LLVM conversion in case the
	 * conversion fails. */
	if (dump && !(sscreen->b.debug_flags & DBG_NO_TGSI)) {
		si_dump_key(sel->type, &shader->key);
		tgsi_dump(tokens, 0);
		si_dump_streamout(&sel->so);
	}

	assert(shader->nparam == 0);
d6523 12
a6534 3
	memset(&si_shader_ctx, 0, sizeof(si_shader_ctx));
	radeon_llvm_context_init(&si_shader_ctx.radeon_bld);
	bld_base = &si_shader_ctx.radeon_bld.soa.bld_base;
d6536 1
a6536 8
	if (sel->type != PIPE_SHADER_COMPUTE)
		shader->dx10_clamp_mode = true;

	if (sel->info.uses_kill)
		shader->db_shader_control |= S_02880C_KILL_ENABLE(1);

	shader->uses_instanceid = sel->info.uses_instanceid;
	bld_base->info = poly_stipple ? &stipple_shader_info : &sel->info;
d6552 2
a6553 1
	bld_base->op_actions[TGSI_OPCODE_TXQ] = txq_action;
d6556 33
d6598 24
d6623 8
a6630 16
	if (HAVE_LLVM >= 0x0306) {
		bld_base->op_actions[TGSI_OPCODE_MAX].emit = build_tgsi_intrinsic_nomem;
		bld_base->op_actions[TGSI_OPCODE_MAX].intr_name = "llvm.maxnum.f32";
		bld_base->op_actions[TGSI_OPCODE_MIN].emit = build_tgsi_intrinsic_nomem;
		bld_base->op_actions[TGSI_OPCODE_MIN].intr_name = "llvm.minnum.f32";
	}

	si_shader_ctx.radeon_bld.load_system_value = declare_system_value;
	si_shader_ctx.shader = shader;
	si_shader_ctx.type = tgsi_get_processor_type(tokens);
	si_shader_ctx.screen = sscreen;
	si_shader_ctx.tm = tm;

	switch (si_shader_ctx.type) {
	case TGSI_PROCESSOR_VERTEX:
		si_shader_ctx.radeon_bld.load_input = declare_input_vs;
d6638 1
a6638 1
	case TGSI_PROCESSOR_TESS_CTRL:
d6644 1
a6644 1
	case TGSI_PROCESSOR_TESS_EVAL:
d6651 1
a6651 1
	case TGSI_PROCESSOR_GEOMETRY:
d6655 9
a6663 14
	case TGSI_PROCESSOR_FRAGMENT:
		si_shader_ctx.radeon_bld.load_input = declare_input_fs;
		bld_base->emit_epilogue = si_llvm_emit_fs_epilogue;

		switch (sel->info.properties[TGSI_PROPERTY_FS_DEPTH_LAYOUT]) {
		case TGSI_FS_DEPTH_LAYOUT_GREATER:
			shader->db_shader_control |=
				S_02880C_CONSERVATIVE_Z_EXPORT(V_02880C_EXPORT_GREATER_THAN_Z);
			break;
		case TGSI_FS_DEPTH_LAYOUT_LESS:
			shader->db_shader_control |=
				S_02880C_CONSERVATIVE_Z_EXPORT(V_02880C_EXPORT_LESS_THAN_Z);
			break;
		}
d6670 11
a6680 6
	create_meta_data(&si_shader_ctx);
	create_function(&si_shader_ctx);
	preload_constants(&si_shader_ctx);
	preload_samplers(&si_shader_ctx);
	preload_streamout_buffers(&si_shader_ctx);
	preload_ring_buffers(&si_shader_ctx);
d6682 1
a6682 1
	if (si_shader_ctx.type == TGSI_PROCESSOR_GEOMETRY) {
d6685 1
a6685 1
			si_shader_ctx.gs_next_vertex[i] =
d6687 1
a6687 1
						bld_base->uint_bld.elem_type, "");
d6691 1
a6691 1
	if (!lp_build_tgsi_llvm(bld_base, tokens)) {
d6696 10
a6705 1
	radeon_llvm_finalize_module(&si_shader_ctx.radeon_bld);
d6707 2
a6708 2
	mod = bld_base->base.gallivm->module;
	r = si_compile_llvm(sscreen, shader, tm, mod);
d6714 77
a6790 1
	radeon_llvm_dispose(&si_shader_ctx.radeon_bld);
d6792 1
a6792 1
	if (si_shader_ctx.type == TGSI_PROCESSOR_GEOMETRY) {
d6795 3
a6797 4
		shader->gs_copy_shader->key = shader->key;
		si_shader_ctx.shader = shader->gs_copy_shader;
		if ((r = si_generate_gs_copy_shader(sscreen, &si_shader_ctx,
						    shader, dump))) {
a6804 4
	for (int i = 0; i < SI_NUM_CONST_BUFFERS; i++)
		FREE(si_shader_ctx.constants[i]);
	if (poly_stipple)
		tgsi_free_tokens(tokens);
d6808 1141
a7948 1
void si_shader_destroy(struct pipe_context *ctx, struct si_shader *shader)
d7951 1
a7951 1
		si_shader_destroy(ctx, shader->gs_copy_shader);
d7960 4
a7963 3
	FREE(shader->binary.code);
	FREE(shader->binary.relocs);
	FREE(shader->binary.disasm_string);
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.0.8

This seems to fix some of the problems with clutter/gnome reported to
occur on r600 with 11.0.6
@
text
@a639 8
	if (type == TGSI_TYPE_DOUBLE) {
		LLVMValueRef value2;
		dw_addr = lp_build_add(&bld_base->uint_bld, dw_addr,
				       lp_build_const_int32(gallivm, swizzle + 1));
		value2 = build_indexed_load(si_shader_ctx, si_shader_ctx->lds, dw_addr);
		return radeon_llvm_emit_fetch_double(bld_base, value, value2);
	}

a3754 1
			shader->rsrc1 = value;
a3760 1
			shader->rsrc2 = value;
@


1.1.1.3
log
@Import Mesa 11.2.2
@
text
@a41 1
#include "util/u_string.h"
a69 1

a70 7
	bool is_gs_copy_shader;

	/* Whether to generate the optimized shader variant compiled as a whole
	 * (without a prolog and epilog)
	 */
	bool is_monolithic;

a77 1
	int param_vertex_index0;
a82 1

a83 1

d85 1
a85 1
	LLVMValueRef const_buffers[SI_NUM_CONST_BUFFERS];
d88 2
a89 3
	LLVMValueRef sampler_views[SI_NUM_SAMPLERS];
	LLVMValueRef sampler_states[SI_NUM_SAMPLERS];
	LLVMValueRef fmasks[SI_NUM_USER_SAMPLERS];
a93 14
	LLVMValueRef return_value;

	LLVMTypeRef voidt;
	LLVMTypeRef i1;
	LLVMTypeRef i8;
	LLVMTypeRef i32;
	LLVMTypeRef i64;
	LLVMTypeRef i128;
	LLVMTypeRef f32;
	LLVMTypeRef v16i8;
	LLVMTypeRef v2i32;
	LLVMTypeRef v4i32;
	LLVMTypeRef v4f32;
	LLVMTypeRef v8i32;
d96 2
a97 2
static struct si_shader_context *si_shader_context(
	struct lp_build_tgsi_context *bld_base)
a101 14
static void si_init_shader_ctx(struct si_shader_context *ctx,
			       struct si_screen *sscreen,
			       struct si_shader *shader,
			       LLVMTargetMachineRef tm);

/* Ideally pass the sample mask input to the PS epilog as v13, which
 * is its usual location, so that the shader doesn't have to add v_mov.
 */
#define PS_EPILOG_SAMPLEMASK_MIN_LOC 13

/* The VS location of the PrimitiveID input is the same in the epilog,
 * so that the main shader part doesn't have to move it.
 */
#define VS_EPILOG_PRIMID_LOC 2
d167 43
d212 1
a212 1
static LLVMValueRef unpack_param(struct si_shader_context *ctx,
d216 2
a217 2
	struct gallivm_state *gallivm = &ctx->radeon_bld.gallivm;
	LLVMValueRef value = LLVMGetParam(ctx->radeon_bld.main_fn,
a219 4
	if (LLVMGetTypeKind(LLVMTypeOf(value)) == LLVMFloatTypeKind)
		value = bitcast(&ctx->radeon_bld.soa.bld_base,
				TGSI_TYPE_UNSIGNED, value);

d233 1
a233 1
static LLVMValueRef get_rel_patch_id(struct si_shader_context *ctx)
d235 1
a235 1
	switch (ctx->type) {
d237 1
a237 1
		return unpack_param(ctx, SI_PARAM_REL_IDS, 0, 8);
d240 2
a241 2
		return LLVMGetParam(ctx->radeon_bld.main_fn,
				    ctx->param_tes_rel_patch_id);
d271 1
a271 1
get_tcs_in_patch_stride(struct si_shader_context *ctx)
d273 4
a276 4
	if (ctx->type == TGSI_PROCESSOR_VERTEX)
		return unpack_param(ctx, SI_PARAM_LS_OUT_LAYOUT, 0, 13);
	else if (ctx->type == TGSI_PROCESSOR_TESS_CTRL)
		return unpack_param(ctx, SI_PARAM_TCS_IN_LAYOUT, 0, 13);
d284 1
a284 1
get_tcs_out_patch_stride(struct si_shader_context *ctx)
d286 1
a286 1
	return unpack_param(ctx, SI_PARAM_TCS_OUT_LAYOUT, 0, 13);
d290 1
a290 1
get_tcs_out_patch0_offset(struct si_shader_context *ctx)
d292 2
a293 2
	return lp_build_mul_imm(&ctx->radeon_bld.soa.bld_base.uint_bld,
				unpack_param(ctx,
d300 1
a300 1
get_tcs_out_patch0_patch_data_offset(struct si_shader_context *ctx)
d302 2
a303 2
	return lp_build_mul_imm(&ctx->radeon_bld.soa.bld_base.uint_bld,
				unpack_param(ctx,
d310 1
a310 1
get_tcs_in_current_patch_offset(struct si_shader_context *ctx)
d312 3
a314 3
	struct gallivm_state *gallivm = &ctx->radeon_bld.gallivm;
	LLVMValueRef patch_stride = get_tcs_in_patch_stride(ctx);
	LLVMValueRef rel_patch_id = get_rel_patch_id(ctx);
d320 1
a320 1
get_tcs_out_current_patch_offset(struct si_shader_context *ctx)
d322 4
a325 4
	struct gallivm_state *gallivm = &ctx->radeon_bld.gallivm;
	LLVMValueRef patch0_offset = get_tcs_out_patch0_offset(ctx);
	LLVMValueRef patch_stride = get_tcs_out_patch_stride(ctx);
	LLVMValueRef rel_patch_id = get_rel_patch_id(ctx);
d334 1
a334 1
get_tcs_out_current_patch_data_offset(struct si_shader_context *ctx)
d336 1
a336 1
	struct gallivm_state *gallivm = &ctx->radeon_bld.gallivm;
d338 3
a340 3
		get_tcs_out_patch0_patch_data_offset(ctx);
	LLVMValueRef patch_stride = get_tcs_out_patch_stride(ctx);
	LLVMValueRef rel_patch_id = get_rel_patch_id(ctx);
d348 1
a348 1
static void build_indexed_store(struct si_shader_context *ctx,
d352 1
a352 1
	struct lp_build_tgsi_context *bld_base = &ctx->radeon_bld.soa.bld_base;
d370 1
a370 1
static LLVMValueRef build_indexed_load(struct si_shader_context *ctx,
d373 1
a373 1
	struct lp_build_tgsi_context *bld_base = &ctx->radeon_bld.soa.bld_base;
d389 1
a389 1
	struct si_shader_context *ctx,
d392 2
a393 2
	LLVMValueRef result = build_indexed_load(ctx, base_ptr, index);
	LLVMSetMetadata(result, 1, ctx->const_md);
d398 2
a399 2
	struct radeon_llvm_context *radeon_bld,
	unsigned param_start_instance, unsigned divisor)
d401 1
a401 1
	struct si_shader_context *ctx =
d403 1
a403 1
	struct gallivm_state *gallivm = radeon_bld->soa.bld_base.base.gallivm;
d406 1
a406 1
					   ctx->param_instance_id);
d413 2
a414 2
	return LLVMBuildAdd(gallivm->builder, result,
			    LLVMGetParam(radeon_bld->main_fn, param_start_instance), "");
d424 1
a424 1
	struct si_shader_context *ctx =
d426 1
a426 2
	unsigned divisor =
		ctx->shader->key.vs.prolog.instance_divisors[input_index];
d436 1
d440 1
a440 1
	t_list_ptr = LLVMGetParam(ctx->radeon_bld.main_fn, SI_PARAM_VERTEX_BUFFERS);
d444 1
a444 1
	t_list = build_indexed_load_const(ctx, t_list_ptr, t_offset);
d449 1
a449 5
	if (!ctx->is_monolithic) {
		buffer_index = LLVMGetParam(radeon_bld->main_fn,
					    ctx->param_vertex_index0 +
					    input_index);
	} else if (divisor) {
d451 2
a452 4
		ctx->shader->info.uses_instanceid = true;
		buffer_index = get_instance_index_for_fetch(&ctx->radeon_bld,
							    SI_PARAM_START_INSTANCE,
							    divisor);
d455 2
a456 2
		LLVMValueRef vertex_id = LLVMGetParam(ctx->radeon_bld.main_fn,
						      ctx->param_vertex_id);
d462 1
d467 1
a467 1
		"llvm.SI.vs.load.input", ctx->v4f32, args, 3,
d475 1
a475 1
		ctx->radeon_bld.inputs[radeon_llvm_reg_index_soa(input_index, chan)] =
d484 1
a484 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d489 1
a489 1
	switch (ctx->type) {
d491 2
a492 2
		return LLVMGetParam(ctx->radeon_bld.main_fn,
				    ctx->param_vs_prim_id);
d494 1
a494 1
		return LLVMGetParam(ctx->radeon_bld.main_fn,
d497 2
a498 2
		return LLVMGetParam(ctx->radeon_bld.main_fn,
				    ctx->param_tes_patch_id);
d500 1
a500 1
		return LLVMGetParam(ctx->radeon_bld.main_fn,
d512 1
a512 1
static LLVMValueRef get_indirect_index(struct si_shader_context *ctx,
d516 1
a516 1
	struct gallivm_state *gallivm = ctx->radeon_bld.soa.bld_base.base.gallivm;
d519 1
a519 1
	result = ctx->radeon_bld.soa.addr[ind->Index][ind->Swizzle];
d529 1
a529 1
static LLVMValueRef get_dw_address(struct si_shader_context *ctx,
d535 2
a536 2
	struct gallivm_state *gallivm = ctx->radeon_bld.soa.bld_base.base.gallivm;
	struct tgsi_shader_info *info = &ctx->shader->selector->info;
d560 1
a560 1
			index = get_indirect_index(ctx, &reg.DimIndirect,
d593 1
a593 1
		ind_index = get_indirect_index(ctx, &reg.Indirect,
d622 1
a622 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d639 1
a639 1
	value = build_indexed_load(ctx, ctx->lds, dw_addr);
d644 1
a644 1
		value2 = build_indexed_load(ctx, ctx->lds, dw_addr);
d659 1
a659 1
static void lds_store(struct lp_build_tgsi_context *bld_base,
d663 1
a663 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d669 3
a671 2
	value = LLVMBuildBitCast(gallivm->builder, value, ctx->i32, "");
	build_indexed_store(ctx, ctx->lds,
d680 1
a680 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d683 3
a685 3
	stride = unpack_param(ctx, SI_PARAM_TCS_IN_LAYOUT, 13, 8);
	dw_addr = get_tcs_in_current_patch_offset(ctx);
	dw_addr = get_dw_address(ctx, NULL, reg, stride, dw_addr);
d695 1
a695 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d699 3
a701 3
		stride = unpack_param(ctx, SI_PARAM_TCS_OUT_LAYOUT, 13, 8);
		dw_addr = get_tcs_out_current_patch_offset(ctx);
		dw_addr = get_dw_address(ctx, NULL, reg, stride, dw_addr);
d703 2
a704 2
		dw_addr = get_tcs_out_current_patch_data_offset(ctx);
		dw_addr = get_dw_address(ctx, NULL, reg, NULL, dw_addr);
d715 1
a715 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d719 3
a721 3
		stride = unpack_param(ctx, SI_PARAM_TCS_OUT_LAYOUT, 13, 8);
		dw_addr = get_tcs_out_current_patch_offset(ctx);
		dw_addr = get_dw_address(ctx, NULL, reg, stride, dw_addr);
d723 2
a724 2
		dw_addr = get_tcs_out_current_patch_data_offset(ctx);
		dw_addr = get_dw_address(ctx, NULL, reg, NULL, dw_addr);
d730 3
a732 3
static void store_output_tcs(struct lp_build_tgsi_context *bld_base,
			     const struct tgsi_full_instruction *inst,
			     const struct tgsi_opcode_info *info,
d735 1
a735 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d750 3
a752 3
		stride = unpack_param(ctx, SI_PARAM_TCS_OUT_LAYOUT, 13, 8);
		dw_addr = get_tcs_out_current_patch_offset(ctx);
		dw_addr = get_dw_address(ctx, reg, NULL, stride, dw_addr);
d754 2
a755 2
		dw_addr = get_tcs_out_current_patch_data_offset(ctx);
		dw_addr = get_dw_address(ctx, reg, NULL, NULL, dw_addr);
d775 3
a777 3
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct si_shader *shader = ctx->shader;
	struct lp_build_context *uint =	&ctx->radeon_bld.soa.bld_base.uint_bld;
d779 1
a785 2
	unsigned param;
	LLVMValueRef value;
d812 1
a812 1
				      LLVMGetParam(ctx->radeon_bld.main_fn,
d816 1
a816 2
	param = si_shader_io_get_unique_index(semantic_name, semantic_index);
	args[0] = ctx->esgs_ring;
d818 4
a821 1
	args[2] = lp_build_const_int32(gallivm, (param * 4 + swizzle) * 256);
a828 14
	value = lp_build_intrinsic(gallivm->builder,
				   "llvm.SI.buffer.load.dword.i32.i32",
				   ctx->i32, args, 9,
				   LLVMReadOnlyAttribute | LLVMNoUnwindAttribute);
	if (type == TGSI_TYPE_DOUBLE) {
		LLVMValueRef value2;
		args[2] = lp_build_const_int32(gallivm, (param * 4 + swizzle + 1) * 256);
		value2 = lp_build_intrinsic(gallivm->builder,
					    "llvm.SI.buffer.load.dword.i32.i32",
					    ctx->i32, args, 9,
					    LLVMReadOnlyAttribute | LLVMNoUnwindAttribute);
		return radeon_llvm_emit_fetch_double(bld_base,
						     value, value2);
	}
d830 4
a833 1
				value,
d866 17
a882 7
/* This shouldn't be used by explicit INTERP opcodes. */
static unsigned select_interp_param(struct si_shader_context *ctx,
				    unsigned param)
{
	if (!ctx->shader->key.ps.prolog.force_persample_interp ||
	    !ctx->is_monolithic)
		return param;
d884 5
a888 1
	/* If the shader doesn't use center/centroid, just return the parameter.
a889 2
	 * If the shader only uses one set of (i,j), "si_emit_spi_ps_input" can
	 * switch between center/centroid and sample without shader changes.
d891 4
a894 8
	switch (param) {
	case SI_PARAM_PERSP_CENTROID:
	case SI_PARAM_PERSP_CENTER:
		return SI_PARAM_PERSP_SAMPLE;

	case SI_PARAM_LINEAR_CENTROID:
	case SI_PARAM_LINEAR_CENTER:
		return SI_PARAM_LINEAR_SAMPLE;
d896 16
a911 2
	default:
		return param;
a912 1
}
d914 11
a924 30
/**
 * Interpolate a fragment shader input.
 *
 * @@param ctx		context
 * @@param input_index		index of the input in hardware
 * @@param semantic_name		TGSI_SEMANTIC_*
 * @@param semantic_index	semantic index
 * @@param num_interp_inputs	number of all interpolated inputs (= BCOLOR offset)
 * @@param colors_read_mask	color components read (4 bits for each color, 8 bits in total)
 * @@param interp_param		interpolation weights (i,j)
 * @@param prim_mask		SI_PARAM_PRIM_MASK
 * @@param face			SI_PARAM_FRONT_FACE
 * @@param result		the return value (4 components)
 */
static void interp_fs_input(struct si_shader_context *ctx,
			    unsigned input_index,
			    unsigned semantic_name,
			    unsigned semantic_index,
			    unsigned num_interp_inputs,
			    unsigned colors_read_mask,
			    LLVMValueRef interp_param,
			    LLVMValueRef prim_mask,
			    LLVMValueRef face,
			    LLVMValueRef result[4])
{
	struct lp_build_context *base = &ctx->radeon_bld.soa.bld_base.base;
	struct lp_build_context *uint =	&ctx->radeon_bld.soa.bld_base.uint_bld;
	struct gallivm_state *gallivm = base->gallivm;
	const char *intr_name;
	LLVMValueRef attr_number;
d926 3
a928 1
	unsigned chan;
d930 7
a936 1
	attr_number = lp_build_const_int32(gallivm, input_index);
d950 2
a951 2
	if (semantic_name == TGSI_SEMANTIC_COLOR &&
	    ctx->shader->key.ps.prolog.color_two_side) {
d953 11
a963 2
		LLVMValueRef is_face_positive;
		LLVMValueRef back_attr_number;
d965 1
a965 13
		/* If BCOLOR0 is used, BCOLOR1 is at offset "num_inputs + 1",
		 * otherwise it's at offset "num_inputs".
		 */
		unsigned back_attr_offset = num_interp_inputs;
		if (semantic_index == 1 && colors_read_mask & 0xf)
			back_attr_offset += 1;

		back_attr_number = lp_build_const_int32(gallivm, back_attr_offset);

		is_face_positive = LLVMBuildICmp(gallivm->builder, LLVMIntNE,
						 face, uint->zero, "");

		args[2] = prim_mask;
d969 1
d975 1
a975 1
						ctx->f32, args, args[3] ? 4 : 3,
d980 1
a980 1
					       ctx->f32, args, args[3] ? 4 : 3,
d983 2
a984 1
			result[chan] = LLVMBuildSelect(gallivm->builder,
d990 3
a992 1
	} else if (semantic_name == TGSI_SEMANTIC_FOG) {
d997 1
a997 1
		args[2] = prim_mask;
d999 3
a1001 2
		result[0] = lp_build_intrinsic(gallivm->builder, intr_name,
					ctx->f32, args, args[3] ? 4 : 3,
d1003 5
a1007 3
		result[1] =
		result[2] = lp_build_const_float(gallivm, 0.0f);
		result[3] = lp_build_const_float(gallivm, 1.0f);
d1012 1
a1012 1

d1015 1
a1015 1
			args[2] = prim_mask;
d1017 3
a1019 2
			result[chan] = lp_build_intrinsic(gallivm->builder, intr_name,
						ctx->f32, args, args[3] ? 4 : 3,
a1024 51
static void declare_input_fs(
	struct radeon_llvm_context *radeon_bld,
	unsigned input_index,
	const struct tgsi_full_declaration *decl)
{
	struct lp_build_context *base = &radeon_bld->soa.bld_base.base;
	struct si_shader_context *ctx =
		si_shader_context(&radeon_bld->soa.bld_base);
	struct si_shader *shader = ctx->shader;
	LLVMValueRef main_fn = radeon_bld->main_fn;
	LLVMValueRef interp_param = NULL;
	int interp_param_idx;

	/* Get colors from input VGPRs (set by the prolog). */
	if (!ctx->is_monolithic &&
	    decl->Semantic.Name == TGSI_SEMANTIC_COLOR) {
		unsigned i = decl->Semantic.Index;
		unsigned colors_read = shader->selector->info.colors_read;
		unsigned mask = colors_read >> (i * 4);
		unsigned offset = SI_PARAM_POS_FIXED_PT + 1 +
				  (i ? util_bitcount(colors_read & 0xf) : 0);

		radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 0)] =
			mask & 0x1 ? LLVMGetParam(main_fn, offset++) : base->undef;
		radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 1)] =
			mask & 0x2 ? LLVMGetParam(main_fn, offset++) : base->undef;
		radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 2)] =
			mask & 0x4 ? LLVMGetParam(main_fn, offset++) : base->undef;
		radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 3)] =
			mask & 0x8 ? LLVMGetParam(main_fn, offset++) : base->undef;
		return;
	}

	interp_param_idx = lookup_interp_param_index(decl->Interp.Interpolate,
						     decl->Interp.Location);
	if (interp_param_idx == -1)
		return;
	else if (interp_param_idx) {
		interp_param_idx = select_interp_param(ctx,
						       interp_param_idx);
		interp_param = LLVMGetParam(main_fn, interp_param_idx);
	}

	interp_fs_input(ctx, input_index, decl->Semantic.Name,
			decl->Semantic.Index, shader->selector->info.num_inputs,
			shader->selector->info.colors_read, interp_param,
			LLVMGetParam(main_fn, SI_PARAM_PRIM_MASK),
			LLVMGetParam(main_fn, SI_PARAM_FRONT_FACE),
			&radeon_bld->inputs[radeon_llvm_reg_index_soa(input_index, 0)]);
}

d1045 1
a1045 1
	struct si_shader_context *ctx =
d1050 1
a1050 1
	LLVMValueRef desc = LLVMGetParam(ctx->radeon_bld.main_fn, SI_PARAM_CONST_BUFFERS);
d1052 1
a1052 1
	LLVMValueRef resource = build_indexed_load_const(ctx, desc, buf_index);
d1059 2
a1060 2
		buffer_load_const(builder, resource, offset0, ctx->f32),
		buffer_load_const(builder, resource, offset1, ctx->f32),
d1069 1
a1069 1
	struct radeon_llvm_context *radeon_bld,
d1073 1
a1073 1
	struct si_shader_context *ctx =
d1076 1
d1083 1
a1083 1
				     ctx->param_instance_id);
d1089 1
a1089 1
						  ctx->param_vertex_id),
d1096 1
a1096 1
				     ctx->param_vertex_id);
d1105 3
a1107 3
		if (ctx->type == TGSI_PROCESSOR_TESS_CTRL)
			value = unpack_param(ctx, SI_PARAM_REL_IDS, 8, 5);
		else if (ctx->type == TGSI_PROCESSOR_GEOMETRY)
a1113 18
	case TGSI_SEMANTIC_POSITION:
	{
		LLVMValueRef pos[4] = {
			LLVMGetParam(radeon_bld->main_fn, SI_PARAM_POS_X_FLOAT),
			LLVMGetParam(radeon_bld->main_fn, SI_PARAM_POS_Y_FLOAT),
			LLVMGetParam(radeon_bld->main_fn, SI_PARAM_POS_Z_FLOAT),
			lp_build_emit_llvm_unary(&radeon_bld->soa.bld_base, TGSI_OPCODE_RCP,
						 LLVMGetParam(radeon_bld->main_fn,
							      SI_PARAM_POS_W_FLOAT)),
		};
		value = lp_build_gather_values(gallivm, pos, 4);
		break;
	}

	case TGSI_SEMANTIC_FACE:
		value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_FRONT_FACE);
		break;

d1118 2
a1119 12
	case TGSI_SEMANTIC_SAMPLEPOS: {
		LLVMValueRef pos[4] = {
			LLVMGetParam(radeon_bld->main_fn, SI_PARAM_POS_X_FLOAT),
			LLVMGetParam(radeon_bld->main_fn, SI_PARAM_POS_Y_FLOAT),
			lp_build_const_float(gallivm, 0),
			lp_build_const_float(gallivm, 0)
		};
		pos[0] = lp_build_emit_llvm_unary(&radeon_bld->soa.bld_base,
						  TGSI_OPCODE_FRC, pos[0]);
		pos[1] = lp_build_emit_llvm_unary(&radeon_bld->soa.bld_base,
						  TGSI_OPCODE_FRC, pos[1]);
		value = lp_build_gather_values(gallivm, pos, 4);
a1120 1
	}
d1123 6
a1128 4
		/* This can only occur with the OpenGL Core profile, which
		 * doesn't support smoothing.
		 */
		value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_SAMPLE_COVERAGE);
d1134 2
a1135 2
			LLVMGetParam(radeon_bld->main_fn, ctx->param_tes_u),
			LLVMGetParam(radeon_bld->main_fn, ctx->param_tes_v),
d1141 1
a1141 1
		if (ctx->shader->selector->info.properties[TGSI_PROPERTY_TES_PRIM_MODE] ==
d1151 1
a1151 1
		value = unpack_param(ctx, SI_PARAM_TCS_OUT_LAYOUT, 26, 6);
d1160 1
a1160 1
		dw_addr = get_tcs_out_current_patch_data_offset(ctx);
d1182 1
a1182 1
	struct lp_build_tgsi_context *bld_base,
d1187 2
a1188 2
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct lp_build_context *base = &bld_base->base;
d1209 1
a1209 1
			return bitcast(bld_base, type, ctx->constants[buf][idx]);
d1212 2
a1213 2
							     ctx->constants[buf][idx],
							     ctx->constants[buf][idx + 1]);
d1218 1
a1218 1
		LLVMValueRef ptr = LLVMGetParam(ctx->radeon_bld.main_fn, SI_PARAM_CONST_BUFFERS);
d1220 1
a1220 1
		index = get_indirect_index(ctx, &reg->DimIndirect,
d1222 1
a1222 1
		bufp = build_indexed_load_const(ctx, ptr, index);
d1224 1
a1224 1
		bufp = ctx->const_buffers[buf];
d1226 1
a1226 1
	addr = ctx->radeon_bld.soa.addr[ireg->Index][ireg->Swizzle];
d1233 1
a1233 1
				   addr, ctx->f32);
d1239 1
a1239 1
		addr2 = ctx->radeon_bld.soa.addr[ireg->Index][ireg->Swizzle + 1];
d1245 2
a1246 2
		result2 = buffer_load_const(base->gallivm->builder, ctx->const_buffers[buf],
				   addr2, ctx->f32);
a1253 22
/* Upper 16 bits must be zero. */
static LLVMValueRef si_llvm_pack_two_int16(struct gallivm_state *gallivm,
					   LLVMValueRef val[2])
{
	return LLVMBuildOr(gallivm->builder, val[0],
			   LLVMBuildShl(gallivm->builder, val[1],
					lp_build_const_int32(gallivm, 16),
					""), "");
}

/* Upper 16 bits are ignored and will be dropped. */
static LLVMValueRef si_llvm_pack_two_int32_as_int16(struct gallivm_state *gallivm,
						    LLVMValueRef val[2])
{
	LLVMValueRef v[2] = {
		LLVMBuildAnd(gallivm->builder, val[0],
			     lp_build_const_int32(gallivm, 0xffff), ""),
		val[1],
	};
	return si_llvm_pack_two_int16(gallivm, v);
}

d1260 1
a1260 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d1262 1
a1262 1
				&ctx->radeon_bld.soa.bld_base.uint_bld;
d1264 1
a1264 4
	struct gallivm_state *gallivm = base->gallivm;
	LLVMBuilderRef builder = base->gallivm->builder;
	LLVMValueRef val[4];
	unsigned spi_shader_col_format = V_028714_SPI_SHADER_32_ABGR;
a1265 1
	bool is_int8;
d1267 2
a1268 2
	/* Default is 0xf. Adjusted below depending on the format. */
	args[0] = lp_build_const_int32(base->gallivm, 0xf); /* writemask */
d1270 2
a1271 5
	/* Specify whether the EXEC mask represents the valid mask */
	args[1] = uint->zero;

	/* Specify whether this is the last export */
	args[2] = uint->zero;
d1273 6
a1278 2
	/* Specify the target we are exporting */
	args[3] = lp_build_const_int32(base->gallivm, target);
d1280 2
a1281 8
	if (ctx->type == TGSI_PROCESSOR_FRAGMENT) {
		const union si_shader_key *key = &ctx->shader->key;
		unsigned col_formats = key->ps.epilog.spi_shader_col_format;
		int cbuf = target - V_008DFC_SQ_EXP_MRT;

		assert(cbuf >= 0 && cbuf < 8);
		spi_shader_col_format = (col_formats >> (cbuf * 4)) & 0xf;
		is_int8 = (key->ps.epilog.color_is_int8 >> cbuf) & 0x1;
d1284 5
a1288 43
	args[4] = uint->zero; /* COMPR flag */
	args[5] = base->undef;
	args[6] = base->undef;
	args[7] = base->undef;
	args[8] = base->undef;

	switch (spi_shader_col_format) {
	case V_028714_SPI_SHADER_ZERO:
		args[0] = uint->zero; /* writemask */
		args[3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_NULL);
		break;

	case V_028714_SPI_SHADER_32_R:
		args[0] = uint->one; /* writemask */
		args[5] = values[0];
		break;

	case V_028714_SPI_SHADER_32_GR:
		args[0] = lp_build_const_int32(base->gallivm, 0x3); /* writemask */
		args[5] = values[0];
		args[6] = values[1];
		break;

	case V_028714_SPI_SHADER_32_AR:
		args[0] = lp_build_const_int32(base->gallivm, 0x9); /* writemask */
		args[5] = values[0];
		args[8] = values[3];
		break;

	case V_028714_SPI_SHADER_FP16_ABGR:
		args[4] = uint->one; /* COMPR flag */

		for (chan = 0; chan < 2; chan++) {
			LLVMValueRef pack_args[2] = {
				values[2 * chan],
				values[2 * chan + 1]
			};
			LLVMValueRef packed;

			packed = lp_build_intrinsic(base->gallivm->builder,
						    "llvm.SI.packf16",
						    ctx->i32, pack_args, 2,
						    LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
d1290 6
d1297 3
a1299 1
						 packed, ctx->f32, "");
a1300 1
		break;
d1302 18
a1319 10
	case V_028714_SPI_SHADER_UNORM16_ABGR:
		for (chan = 0; chan < 4; chan++) {
			val[chan] = radeon_llvm_saturate(bld_base, values[chan]);
			val[chan] = LLVMBuildFMul(builder, val[chan],
						  lp_build_const_float(gallivm, 65535), "");
			val[chan] = LLVMBuildFAdd(builder, val[chan],
						  lp_build_const_float(gallivm, 0.5), "");
			val[chan] = LLVMBuildFPToUI(builder, val[chan],
						    ctx->i32, "");
		}
d1321 2
a1322 6
		args[4] = uint->one; /* COMPR flag */
		args[5] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int16(gallivm, val));
		args[6] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int16(gallivm, val+2));
		break;
d1324 2
a1325 28
	case V_028714_SPI_SHADER_SNORM16_ABGR:
		for (chan = 0; chan < 4; chan++) {
			/* Clamp between [-1, 1]. */
			val[chan] = lp_build_emit_llvm_binary(bld_base, TGSI_OPCODE_MIN,
							      values[chan],
							      lp_build_const_float(gallivm, 1));
			val[chan] = lp_build_emit_llvm_binary(bld_base, TGSI_OPCODE_MAX,
							      val[chan],
							      lp_build_const_float(gallivm, -1));
			/* Convert to a signed integer in [-32767, 32767]. */
			val[chan] = LLVMBuildFMul(builder, val[chan],
						  lp_build_const_float(gallivm, 32767), "");
			/* If positive, add 0.5, else add -0.5. */
			val[chan] = LLVMBuildFAdd(builder, val[chan],
					LLVMBuildSelect(builder,
						LLVMBuildFCmp(builder, LLVMRealOGE,
							      val[chan], base->zero, ""),
						lp_build_const_float(gallivm, 0.5),
						lp_build_const_float(gallivm, -0.5), ""), "");
			val[chan] = LLVMBuildFPToSI(builder, val[chan], ctx->i32, "");
		}

		args[4] = uint->one; /* COMPR flag */
		args[5] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int32_as_int16(gallivm, val));
		args[6] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int32_as_int16(gallivm, val+2));
		break;
d1327 2
a1328 9
	case V_028714_SPI_SHADER_UINT16_ABGR: {
		LLVMValueRef max = lp_build_const_int32(gallivm, is_int8 ?
							255 : 65535);
		/* Clamp. */
		for (chan = 0; chan < 4; chan++) {
			val[chan] = bitcast(bld_base, TGSI_TYPE_UNSIGNED, values[chan]);
			val[chan] = lp_build_emit_llvm_binary(bld_base, TGSI_OPCODE_UMIN,
							      val[chan], max);
		}
d1330 4
a1333 7
		args[4] = uint->one; /* COMPR flag */
		args[5] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int16(gallivm, val));
		args[6] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int16(gallivm, val+2));
		break;
	}
d1335 9
a1343 15
	case V_028714_SPI_SHADER_SINT16_ABGR: {
		LLVMValueRef max = lp_build_const_int32(gallivm, is_int8 ?
							127 : 32767);
		LLVMValueRef min = lp_build_const_int32(gallivm, is_int8 ?
							-128 : -32768);
		/* Clamp. */
		for (chan = 0; chan < 4; chan++) {
			val[chan] = bitcast(bld_base, TGSI_TYPE_UNSIGNED, values[chan]);
			val[chan] = lp_build_emit_llvm_binary(bld_base,
							      TGSI_OPCODE_IMIN,
							      val[chan], max);
			val[chan] = lp_build_emit_llvm_binary(bld_base,
							      TGSI_OPCODE_IMAX,
							      val[chan], min);
		}
d1345 2
a1346 7
		args[4] = uint->one; /* COMPR flag */
		args[5] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int32_as_int16(gallivm, val));
		args[6] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int32_as_int16(gallivm, val+2));
		break;
	}
d1348 1
a1348 4
	case V_028714_SPI_SHADER_32_ABGR:
		memcpy(&args[5], values, sizeof(values[0]) * 4);
		break;
	}
d1352 1
a1352 1
			  LLVMValueRef alpha)
d1354 1
a1354 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d1357 2
a1358 2
	if (ctx->shader->key.ps.epilog.alpha_func != PIPE_FUNC_NEVER) {
		LLVMValueRef alpha_ref = LLVMGetParam(ctx->radeon_bld.main_fn,
d1363 3
a1365 2
				     ctx->shader->key.ps.epilog.alpha_func,
				     alpha, alpha_ref);
d1372 4
a1375 2
		lp_build_intrinsic(gallivm->builder, "llvm.AMDGPU.kill",
				   ctx->voidt, &arg, 1, 0);
d1377 4
a1380 2
		lp_build_intrinsic(gallivm->builder, "llvm.AMDGPU.kilp",
				   ctx->voidt, NULL, 0, 0);
d1382 2
d1386 2
a1387 3
static LLVMValueRef si_scale_alpha_by_sample_mask(struct lp_build_tgsi_context *bld_base,
						  LLVMValueRef alpha,
						  unsigned samplemask_param)
d1389 1
a1389 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d1391 1
a1391 1
	LLVMValueRef coverage;
d1394 2
a1395 2
	coverage = LLVMGetParam(ctx->radeon_bld.main_fn,
				samplemask_param);
d1399 1
a1399 1
				   ctx->i32,
d1403 1
a1403 1
				   ctx->f32, "");
d1409 3
a1411 1
	return LLVMBuildFMul(gallivm->builder, alpha, coverage, "");
d1414 1
a1414 1
static void si_llvm_emit_clipvertex(struct lp_build_tgsi_context *bld_base,
d1417 1
a1417 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d1419 1
a1419 1
	struct lp_build_context *uint = &ctx->radeon_bld.soa.bld_base.uint_bld;
d1424 1
a1424 1
	LLVMValueRef ptr = LLVMGetParam(ctx->radeon_bld.main_fn, SI_PARAM_CONST_BUFFERS);
d1426 1
a1426 1
	LLVMValueRef const_resource = build_indexed_load_const(ctx, ptr, constbuf_index);
d1443 1
a1443 1
						      args[1], ctx->f32);
d1484 1
a1484 1
static void build_tbuffer_store(struct si_shader_context *ctx,
d1499 2
a1500 1
	struct gallivm_state *gallivm = &ctx->radeon_bld.gallivm;
d1504 1
a1504 1
		LLVMConstInt(ctx->i32, num_channels, 0),
d1507 8
a1514 8
		LLVMConstInt(ctx->i32, inst_offset, 0),
		LLVMConstInt(ctx->i32, dfmt, 0),
		LLVMConstInt(ctx->i32, nfmt, 0),
		LLVMConstInt(ctx->i32, offen, 0),
		LLVMConstInt(ctx->i32, idxen, 0),
		LLVMConstInt(ctx->i32, glc, 0),
		LLVMConstInt(ctx->i32, slc, 0),
		LLVMConstInt(ctx->i32, tfe, 0)
d1526 2
a1527 1
	lp_build_intrinsic(gallivm->builder, name, ctx->voidt,
d1531 1
a1531 1
static void build_tbuffer_store_dwords(struct si_shader_context *ctx,
d1547 1
a1547 1
	build_tbuffer_store(ctx, rsrc, vdata, num_channels, vaddr, soffset,
d1554 1
a1554 1
static void si_llvm_emit_streamout(struct si_shader_context *ctx,
d1558 2
a1559 2
	struct pipe_stream_output_info *so = &ctx->shader->selector->so;
	struct gallivm_state *gallivm = &ctx->radeon_bld.gallivm;
d1564 2
d1568 1
a1568 1
		unpack_param(ctx, ctx->param_streamout_config, 16, 7);
d1570 1
a1570 1
	LLVMValueRef tid = lp_build_intrinsic(builder, "llvm.SI.tid", ctx->i32,
d1578 1
a1578 1
		unpack_param(ctx, ctx->param_streamout_config, 24, 2);
d1592 2
a1593 2
			LLVMGetParam(ctx->radeon_bld.main_fn,
				     ctx->param_streamout_write_index);
d1604 3
a1606 3
			LLVMValueRef so_offset = LLVMGetParam(ctx->radeon_bld.main_fn,
							      ctx->param_streamout_offset[i]);
			so_offset = LLVMBuildMul(builder, so_offset, LLVMConstInt(ctx->i32, 4, 0), "");
d1609 1
a1609 1
							  LLVMConstInt(ctx->i32, so->stride[i]*4, 0), "");
d1634 1
a1634 1
						ctx->i32, "");
d1647 1
a1647 1
				vdata = LLVMGetUndef(LLVMVectorType(ctx->i32, util_next_power_of_two(num_comps)));
d1650 1
a1650 1
								       LLVMConstInt(ctx->i32, j, 0), "");
d1661 1
a1661 1
			build_tbuffer_store_dwords(ctx, ctx->so_buffers[buf_idx],
d1664 1
a1664 1
						   LLVMConstInt(ctx->i32, 0, 0),
d1678 5
a1682 5
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct si_shader *shader = ctx->shader;
	struct lp_build_context *base = &bld_base->base;
	struct lp_build_context *uint =
				&ctx->radeon_bld.soa.bld_base.uint_bld;
d1692 2
a1693 2
	if (outputs && ctx->shader->selector->so.num_outputs) {
		si_llvm_emit_streamout(ctx, outputs, noutput);
d1723 1
a1723 2
			assert(i < ARRAY_SIZE(shader->info.vs_output_param_offset));
			shader->info.vs_output_param_offset[i] = param_count;
d1737 1
a1737 2
			assert(i < ARRAY_SIZE(shader->info.vs_output_param_offset));
			shader->info.vs_output_param_offset[i] = param_count;
d1755 2
a1756 1
					   "llvm.SI.export", ctx->voidt,
d1766 1
a1766 1
	shader->info.nr_param_exports = param_count;
d1808 1
a1808 1
							 ctx->i32, "");
d1816 1
a1816 1
							  ctx->f32, "");
d1828 1
a1828 1
			shader->info.nr_pos_exports++;
d1838 1
a1838 1
		if (pos_idx == shader->info.nr_pos_exports)
d1842 4
a1845 2
		lp_build_intrinsic(base->gallivm->builder, "llvm.SI.export",
				   ctx->voidt, pos_args[i], 9, 0);
d1849 2
a1850 4
static void si_write_tess_factors(struct lp_build_tgsi_context *bld_base,
				  LLVMValueRef rel_patch_id,
				  LLVMValueRef invocation_id,
				  LLVMValueRef tcs_out_current_patch_data_offset)
d1852 1
a1852 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d1854 1
a1854 1
	struct si_shader *shader = ctx->shader;
d1856 3
a1858 2
	LLVMValueRef lds_base, lds_inner, lds_outer, byteoffset, buffer;
	LLVMValueRef out[6], vec0, vec1, rw_buffers, tf_base;
d1862 2
d1875 1
a1875 1
	switch (shader->key.tcs.epilog.prim_mode) {
d1902 1
a1902 1
	lds_base = tcs_out_current_patch_data_offset;
d1923 1
a1923 1
	rw_buffers = LLVMGetParam(ctx->radeon_bld.main_fn,
d1925 1
a1925 1
	buffer = build_indexed_load_const(ctx, rw_buffers,
d1929 1
a1929 1
	tf_base = LLVMGetParam(ctx->radeon_bld.main_fn,
d1931 1
d1936 1
a1936 1
	build_tbuffer_store_dwords(ctx, buffer, vec0,
d1939 1
a1939 1
		build_tbuffer_store_dwords(ctx, buffer, vec1,
d1944 1
a1944 52
/* This only writes the tessellation factor levels. */
static void si_llvm_emit_tcs_epilogue(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	LLVMValueRef rel_patch_id, invocation_id, tf_lds_offset;

	rel_patch_id = get_rel_patch_id(ctx);
	invocation_id = unpack_param(ctx, SI_PARAM_REL_IDS, 8, 5);
	tf_lds_offset = get_tcs_out_current_patch_data_offset(ctx);

	if (!ctx->is_monolithic) {
		/* Return epilog parameters from this function. */
		LLVMBuilderRef builder = bld_base->base.gallivm->builder;
		LLVMValueRef ret = ctx->return_value;
		LLVMValueRef rw_buffers, rw0, rw1, tf_soffset;
		unsigned vgpr;

		/* RW_BUFFERS pointer */
		rw_buffers = LLVMGetParam(ctx->radeon_bld.main_fn,
					  SI_PARAM_RW_BUFFERS);
		rw_buffers = LLVMBuildPtrToInt(builder, rw_buffers, ctx->i64, "");
		rw_buffers = LLVMBuildBitCast(builder, rw_buffers, ctx->v2i32, "");
		rw0 = LLVMBuildExtractElement(builder, rw_buffers,
					      bld_base->uint_bld.zero, "");
		rw1 = LLVMBuildExtractElement(builder, rw_buffers,
					      bld_base->uint_bld.one, "");
		ret = LLVMBuildInsertValue(builder, ret, rw0, 0, "");
		ret = LLVMBuildInsertValue(builder, ret, rw1, 1, "");

		/* Tess factor buffer soffset is after user SGPRs. */
		tf_soffset = LLVMGetParam(ctx->radeon_bld.main_fn,
					  SI_PARAM_TESS_FACTOR_OFFSET);
		ret = LLVMBuildInsertValue(builder, ret, tf_soffset,
					   SI_TCS_NUM_USER_SGPR, "");

		/* VGPRs */
		rel_patch_id = bitcast(bld_base, TGSI_TYPE_FLOAT, rel_patch_id);
		invocation_id = bitcast(bld_base, TGSI_TYPE_FLOAT, invocation_id);
		tf_lds_offset = bitcast(bld_base, TGSI_TYPE_FLOAT, tf_lds_offset);

		vgpr = SI_TCS_NUM_USER_SGPR + 1;
		ret = LLVMBuildInsertValue(builder, ret, rel_patch_id, vgpr++, "");
		ret = LLVMBuildInsertValue(builder, ret, invocation_id, vgpr++, "");
		ret = LLVMBuildInsertValue(builder, ret, tf_lds_offset, vgpr++, "");
		ctx->return_value = ret;
		return;
	}

	si_write_tess_factors(bld_base, rel_patch_id, invocation_id, tf_lds_offset);
}

static void si_llvm_emit_ls_epilogue(struct lp_build_tgsi_context *bld_base)
d1946 2
a1947 2
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct si_shader *shader = ctx->shader;
d1951 2
a1952 2
	LLVMValueRef vertex_id = LLVMGetParam(ctx->radeon_bld.main_fn,
					      ctx->param_rel_auto_id);
d1954 1
a1954 1
		unpack_param(ctx, SI_PARAM_LS_OUT_LAYOUT, 13, 8);
d1961 1
a1961 1
		LLVMValueRef *out_ptr = ctx->radeon_bld.soa.outputs[i];
d1975 1
a1975 1
static void si_llvm_emit_es_epilogue(struct lp_build_tgsi_context *bld_base)
d1977 1
a1977 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d1979 1
a1979 1
	struct si_shader *es = ctx->shader;
d1981 6
a1986 2
	LLVMValueRef soffset = LLVMGetParam(ctx->radeon_bld.main_fn,
					    ctx->param_es2gs_offset);
d1992 1
a1992 1
			ctx->radeon_bld.soa.outputs[i];
d1999 5
a2003 2
		param_index = si_shader_io_get_unique_index(info->output_semantic_name[i],
							    info->output_semantic_index[i]);
d2007 1
a2007 1
			out_val = LLVMBuildBitCast(gallivm->builder, out_val, ctx->i32, "");
d2009 2
a2010 2
			build_tbuffer_store(ctx,
					    ctx->esgs_ring,
d2012 1
a2012 1
					    LLVMGetUndef(ctx->i32), soffset,
d2023 1
a2023 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d2028 1
a2028 1
	args[1] = LLVMGetParam(ctx->radeon_bld.main_fn, SI_PARAM_GS_WAVE_ID);
d2030 2
a2031 1
			   ctx->voidt, args, 2, LLVMNoUnwindAttribute);
d2034 1
a2034 1
static void si_llvm_emit_vs_epilogue(struct lp_build_tgsi_context *bld_base)
d2036 1
a2036 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d2038 1
a2038 1
	struct tgsi_shader_info *info = &ctx->shader->selector->info;
a2041 2
	assert(!ctx->is_gs_copy_shader);

a2043 38
	/* Vertex color clamping.
	 *
	 * This uses a state constant loaded in a user data SGPR and
	 * an IF statement is added that clamps all colors if the constant
	 * is true.
	 */
	if (ctx->type == TGSI_PROCESSOR_VERTEX) {
		struct lp_build_if_state if_ctx;
		LLVMValueRef cond = NULL;
		LLVMValueRef addr, val;

		for (i = 0; i < info->num_outputs; i++) {
			if (info->output_semantic_name[i] != TGSI_SEMANTIC_COLOR &&
			    info->output_semantic_name[i] != TGSI_SEMANTIC_BCOLOR)
				continue;

			/* We've found a color. */
			if (!cond) {
				/* The state is in the first bit of the user SGPR. */
				cond = LLVMGetParam(ctx->radeon_bld.main_fn,
						    SI_PARAM_VS_STATE_BITS);
				cond = LLVMBuildTrunc(gallivm->builder, cond,
						      ctx->i1, "");
				lp_build_if(&if_ctx, gallivm, cond);
			}

			for (j = 0; j < 4; j++) {
				addr = ctx->radeon_bld.soa.outputs[i][j];
				val = LLVMBuildLoad(gallivm->builder, addr, "");
				val = radeon_llvm_saturate(bld_base, val);
				LLVMBuildStore(gallivm->builder, val, addr);
			}
		}

		if (cond)
			lp_build_endif(&if_ctx);
	}

d2051 1
a2051 1
					      ctx->radeon_bld.soa.outputs[i][j],
d2055 10
a2064 20
	if (ctx->is_monolithic) {
		/* Export PrimitiveID when PS needs it. */
		if (si_vs_exports_prim_id(ctx->shader)) {
			outputs[i].name = TGSI_SEMANTIC_PRIMID;
			outputs[i].sid = 0;
			outputs[i].values[0] = bitcast(bld_base, TGSI_TYPE_FLOAT,
						       get_primitive_id(bld_base, 0));
			outputs[i].values[1] = bld_base->base.undef;
			outputs[i].values[2] = bld_base->base.undef;
			outputs[i].values[3] = bld_base->base.undef;
			i++;
		}
	} else {
		/* Return the primitive ID from the LLVM function. */
		ctx->return_value =
			LLVMBuildInsertValue(gallivm->builder,
					     ctx->return_value,
					     bitcast(bld_base, TGSI_TYPE_FLOAT,
						     get_primitive_id(bld_base, 0)),
					     VS_EPILOG_PRIMID_LOC, "");
d2071 1
a2071 3
static void si_export_mrt_z(struct lp_build_tgsi_context *bld_base,
			   LLVMValueRef depth, LLVMValueRef stencil,
			   LLVMValueRef samplemask)
d2073 5
a2077 3
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct lp_build_context *base = &bld_base->base;
	struct lp_build_context *uint = &bld_base->uint_bld;
d2079 3
a2081 1
	unsigned mask = 0;
d2083 5
a2087 1
	assert(depth || stencil || samplemask);
d2089 14
a2102 2
	args[1] = uint->one; /* whether the EXEC mask is valid */
	args[2] = uint->one; /* DONE bit */
d2104 7
a2110 2
	/* Specify the target we are exporting */
	args[3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_MRTZ);
d2112 9
a2120 5
	args[4] = uint->zero; /* COMP flag */
	args[5] = base->undef; /* R, depth */
	args[6] = base->undef; /* G, stencil test value[0:7], stencil op value[8:15] */
	args[7] = base->undef; /* B, sample mask */
	args[8] = base->undef; /* A, alpha to mask */
d2122 12
a2133 4
	if (depth) {
		args[5] = depth;
		mask |= 0x1;
	}
d2135 2
a2136 4
	if (stencil) {
		args[6] = stencil;
		mask |= 0x2;
	}
d2138 19
a2156 69
	if (samplemask) {
		args[7] = samplemask;
		mask |= 0x4;
	}

	/* SI (except OLAND) has a bug that it only looks
	 * at the X writemask component. */
	if (ctx->screen->b.chip_class == SI &&
	    ctx->screen->b.family != CHIP_OLAND)
		mask |= 0x1;

	/* Specify which components to enable */
	args[0] = lp_build_const_int32(base->gallivm, mask);

	lp_build_intrinsic(base->gallivm->builder, "llvm.SI.export",
			   ctx->voidt, args, 9, 0);
}

static void si_export_mrt_color(struct lp_build_tgsi_context *bld_base,
				LLVMValueRef *color, unsigned index,
				unsigned samplemask_param,
				bool is_last)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct lp_build_context *base = &bld_base->base;
	int i;

	/* Clamp color */
	if (ctx->shader->key.ps.epilog.clamp_color)
		for (i = 0; i < 4; i++)
			color[i] = radeon_llvm_saturate(bld_base, color[i]);

	/* Alpha to one */
	if (ctx->shader->key.ps.epilog.alpha_to_one)
		color[3] = base->one;

	/* Alpha test */
	if (index == 0 &&
	    ctx->shader->key.ps.epilog.alpha_func != PIPE_FUNC_ALWAYS)
		si_alpha_test(bld_base, color[3]);

	/* Line & polygon smoothing */
	if (ctx->shader->key.ps.epilog.poly_line_smoothing)
		color[3] = si_scale_alpha_by_sample_mask(bld_base, color[3],
							 samplemask_param);

	/* If last_cbuf > 0, FS_COLOR0_WRITES_ALL_CBUFS is true. */
	if (ctx->shader->key.ps.epilog.last_cbuf > 0) {
		LLVMValueRef args[8][9];
		int c, last = -1;

		/* Get the export arguments, also find out what the last one is. */
		for (c = 0; c <= ctx->shader->key.ps.epilog.last_cbuf; c++) {
			si_llvm_init_export_args(bld_base, color,
						 V_008DFC_SQ_EXP_MRT + c, args[c]);
			if (args[c][0] != bld_base->uint_bld.zero)
				last = c;
		}

		/* Emit all exports. */
		for (c = 0; c <= ctx->shader->key.ps.epilog.last_cbuf; c++) {
			if (is_last && last == c) {
				args[c][1] = bld_base->uint_bld.one; /* whether the EXEC mask is valid */
				args[c][2] = bld_base->uint_bld.one; /* DONE bit */
			} else if (args[c][0] == bld_base->uint_bld.zero)
				continue; /* unnecessary NULL export */

			lp_build_intrinsic(base->gallivm->builder, "llvm.SI.export",
					   ctx->voidt, args[c], 9, 0);
a2157 14
	} else {
		LLVMValueRef args[9];

		/* Export */
		si_llvm_init_export_args(bld_base, color, V_008DFC_SQ_EXP_MRT + index,
					 args);
		if (is_last) {
			args[1] = bld_base->uint_bld.one; /* whether the EXEC mask is valid */
			args[2] = bld_base->uint_bld.one; /* DONE bit */
		} else if (args[0] == bld_base->uint_bld.zero)
			return; /* unnecessary NULL export */

		lp_build_intrinsic(base->gallivm->builder, "llvm.SI.export",
				   ctx->voidt, args, 9, 0);
a2158 1
}
d2160 3
a2162 6
static void si_export_null(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct lp_build_context *base = &bld_base->base;
	struct lp_build_context *uint = &bld_base->uint_bld;
	LLVMValueRef args[9];
d2164 2
a2165 9
	args[0] = lp_build_const_int32(base->gallivm, 0x0); /* enabled channels */
	args[1] = uint->one; /* whether the EXEC mask is valid */
	args[2] = uint->one; /* DONE bit */
	args[3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_NULL);
	args[4] = uint->zero; /* COMPR flag (0 = 32-bit export) */
	args[5] = uint->undef; /* R */
	args[6] = uint->undef; /* G */
	args[7] = uint->undef; /* B */
	args[8] = uint->undef; /* A */
d2167 39
a2205 3
	lp_build_intrinsic(base->gallivm->builder, "llvm.SI.export",
			   ctx->voidt, args, 9, 0);
}
d2207 2
a2208 10
static void si_llvm_emit_fs_epilogue(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct si_shader *shader = ctx->shader;
	struct lp_build_context *base = &bld_base->base;
	struct tgsi_shader_info *info = &shader->selector->info;
	LLVMBuilderRef builder = base->gallivm->builder;
	LLVMValueRef depth = NULL, stencil = NULL, samplemask = NULL;
	int last_color_export = -1;
	int i;
d2210 3
a2212 5
	/* Determine the last export. If MRTZ is present, it's always last.
	 * Otherwise, find the last color export.
	 */
	if (!info->writes_z && !info->writes_stencil && !info->writes_samplemask) {
		unsigned spi_format = shader->key.ps.epilog.spi_shader_col_format;
d2214 7
a2220 30
		/* Don't export NULL and return if alpha-test is enabled. */
		if (shader->key.ps.epilog.alpha_func != PIPE_FUNC_ALWAYS &&
		    shader->key.ps.epilog.alpha_func != PIPE_FUNC_NEVER &&
		    (spi_format & 0xf) == 0)
			spi_format |= V_028714_SPI_SHADER_32_AR;

		for (i = 0; i < info->num_outputs; i++) {
			unsigned index = info->output_semantic_index[i];

			if (info->output_semantic_name[i] != TGSI_SEMANTIC_COLOR)
				continue;

			/* If last_cbuf > 0, FS_COLOR0_WRITES_ALL_CBUFS is true. */
			if (shader->key.ps.epilog.last_cbuf > 0) {
				/* Just set this if any of the colorbuffers are enabled. */
				if (spi_format &
				    ((1llu << (4 * (shader->key.ps.epilog.last_cbuf + 1))) - 1))
					last_color_export = i;
				continue;
			}

			if ((spi_format >> (index * 4)) & 0xf)
				last_color_export = i;
		}

		/* If there are no outputs, export NULL. */
		if (last_color_export == -1) {
			si_export_null(bld_base);
			return;
		}
d2223 3
a2225 5
	for (i = 0; i < info->num_outputs; i++) {
		unsigned semantic_name = info->output_semantic_name[i];
		unsigned semantic_index = info->output_semantic_index[i];
		unsigned j;
		LLVMValueRef color[4] = {};
d2227 2
a2228 29
		/* Select the correct target */
		switch (semantic_name) {
		case TGSI_SEMANTIC_POSITION:
			depth = LLVMBuildLoad(builder,
					      ctx->radeon_bld.soa.outputs[i][2], "");
			break;
		case TGSI_SEMANTIC_STENCIL:
			stencil = LLVMBuildLoad(builder,
						ctx->radeon_bld.soa.outputs[i][1], "");
			break;
		case TGSI_SEMANTIC_SAMPLEMASK:
			samplemask = LLVMBuildLoad(builder,
						   ctx->radeon_bld.soa.outputs[i][0], "");
			break;
		case TGSI_SEMANTIC_COLOR:
			for (j = 0; j < 4; j++)
				color[j] = LLVMBuildLoad(builder,
							 ctx->radeon_bld.soa.outputs[i][j], "");

			si_export_mrt_color(bld_base, color, semantic_index,
					    SI_PARAM_SAMPLE_COVERAGE,
					    last_color_export == i);
			break;
		default:
			fprintf(stderr,
				"Warning: SI unhandled fs output type:%d\n",
				semantic_name);
		}
	}
d2230 2
a2231 34
	if (depth || stencil || samplemask)
		si_export_mrt_z(bld_base, depth, stencil, samplemask);
}

/**
 * Return PS outputs in this order:
 *
 * v[0:3] = color0.xyzw
 * v[4:7] = color1.xyzw
 * ...
 * vN+0 = Depth
 * vN+1 = Stencil
 * vN+2 = SampleMask
 * vN+3 = SampleMaskIn (used for OpenGL smoothing)
 *
 * The alpha-ref SGPR is returned via its original location.
 */
static void si_llvm_return_fs_outputs(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct si_shader *shader = ctx->shader;
	struct lp_build_context *base = &bld_base->base;
	struct tgsi_shader_info *info = &shader->selector->info;
	LLVMBuilderRef builder = base->gallivm->builder;
	unsigned i, j, first_vgpr, vgpr;

	LLVMValueRef color[8][4] = {};
	LLVMValueRef depth = NULL, stencil = NULL, samplemask = NULL;
	LLVMValueRef ret;

	/* Read the output values. */
	for (i = 0; i < info->num_outputs; i++) {
		unsigned semantic_name = info->output_semantic_name[i];
		unsigned semantic_index = info->output_semantic_index[i];
d2233 5
a2237 25
		switch (semantic_name) {
		case TGSI_SEMANTIC_COLOR:
			assert(semantic_index < 8);
			for (j = 0; j < 4; j++) {
				LLVMValueRef ptr = ctx->radeon_bld.soa.outputs[i][j];
				LLVMValueRef result = LLVMBuildLoad(builder, ptr, "");
				color[semantic_index][j] = result;
			}
			break;
		case TGSI_SEMANTIC_POSITION:
			depth = LLVMBuildLoad(builder,
					      ctx->radeon_bld.soa.outputs[i][2], "");
			break;
		case TGSI_SEMANTIC_STENCIL:
			stencil = LLVMBuildLoad(builder,
						ctx->radeon_bld.soa.outputs[i][1], "");
			break;
		case TGSI_SEMANTIC_SAMPLEMASK:
			samplemask = LLVMBuildLoad(builder,
						   ctx->radeon_bld.soa.outputs[i][0], "");
			break;
		default:
			fprintf(stderr, "Warning: SI unhandled fs output type:%d\n",
				semantic_name);
		}
d2240 2
a2241 2
	/* Fill the return structure. */
	ret = ctx->return_value;
d2243 2
a2244 29
	/* Set SGPRs. */
	ret = LLVMBuildInsertValue(builder, ret,
				   bitcast(bld_base, TGSI_TYPE_SIGNED,
					   LLVMGetParam(ctx->radeon_bld.main_fn,
							SI_PARAM_ALPHA_REF)),
				   SI_SGPR_ALPHA_REF, "");

	/* Set VGPRs */
	first_vgpr = vgpr = SI_SGPR_ALPHA_REF + 1;
	for (i = 0; i < ARRAY_SIZE(color); i++) {
		if (!color[i][0])
			continue;

		for (j = 0; j < 4; j++)
			ret = LLVMBuildInsertValue(builder, ret, color[i][j], vgpr++, "");
	}
	if (depth)
		ret = LLVMBuildInsertValue(builder, ret, depth, vgpr++, "");
	if (stencil)
		ret = LLVMBuildInsertValue(builder, ret, stencil, vgpr++, "");
	if (samplemask)
		ret = LLVMBuildInsertValue(builder, ret, samplemask, vgpr++, "");

	/* Add the input sample mask for smoothing at the end. */
	if (vgpr < first_vgpr + PS_EPILOG_SAMPLEMASK_MIN_LOC)
		vgpr = first_vgpr + PS_EPILOG_SAMPLEMASK_MIN_LOC;
	ret = LLVMBuildInsertValue(builder, ret,
				   LLVMGetParam(ctx->radeon_bld.main_fn,
						SI_PARAM_SAMPLE_COVERAGE), vgpr++, "");
d2246 4
a2249 1
	ctx->return_value = ret;
d2252 3
a2254 3
static void build_tex_intrinsic(const struct lp_build_tgsi_action *action,
				struct lp_build_tgsi_context *bld_base,
				struct lp_build_emit_data *emit_data);
d2256 1
a2256 1
static bool tgsi_is_array_sampler(unsigned target)
d2258 1
a2258 1
	return target == TGSI_TEXTURE_1D_ARRAY ||
d2260 1
a2260 1
	       target == TGSI_TEXTURE_2D_ARRAY ||
d2262 1
a2262 1
	       target == TGSI_TEXTURE_CUBE_ARRAY ||
d2264 1
a2264 47
	       target == TGSI_TEXTURE_2D_ARRAY_MSAA;
}

static void set_tex_fetch_args(struct si_shader_context *ctx,
			       struct lp_build_emit_data *emit_data,
			       unsigned opcode, unsigned target,
			       LLVMValueRef res_ptr, LLVMValueRef samp_ptr,
			       LLVMValueRef *param, unsigned count,
			       unsigned dmask)
{
	struct gallivm_state *gallivm = &ctx->radeon_bld.gallivm;
	unsigned num_args;
	unsigned is_rect = target == TGSI_TEXTURE_RECT;

	/* Pad to power of two vector */
	while (count < util_next_power_of_two(count))
		param[count++] = LLVMGetUndef(ctx->i32);

	/* Texture coordinates. */
	if (count > 1)
		emit_data->args[0] = lp_build_gather_values(gallivm, param, count);
	else
		emit_data->args[0] = param[0];

	/* Resource. */
	emit_data->args[1] = res_ptr;
	num_args = 2;

	if (opcode == TGSI_OPCODE_TXF || opcode == TGSI_OPCODE_TXQ)
		emit_data->dst_type = ctx->v4i32;
	else {
		emit_data->dst_type = ctx->v4f32;

		emit_data->args[num_args++] = samp_ptr;
	}

	emit_data->args[num_args++] = lp_build_const_int32(gallivm, dmask);
	emit_data->args[num_args++] = lp_build_const_int32(gallivm, is_rect); /* unorm */
	emit_data->args[num_args++] = lp_build_const_int32(gallivm, 0); /* r128 */
	emit_data->args[num_args++] = lp_build_const_int32(gallivm,
					tgsi_is_array_sampler(target)); /* da */
	emit_data->args[num_args++] = lp_build_const_int32(gallivm, 0); /* glc */
	emit_data->args[num_args++] = lp_build_const_int32(gallivm, 0); /* slc */
	emit_data->args[num_args++] = lp_build_const_int32(gallivm, 0); /* tfe */
	emit_data->args[num_args++] = lp_build_const_int32(gallivm, 0); /* lwe */

	emit_data->arg_count = num_args;
a2268 90
enum desc_type {
	DESC_IMAGE,
	DESC_FMASK,
	DESC_SAMPLER
};

static LLVMTypeRef const_array(LLVMTypeRef elem_type, int num_elements)
{
	return LLVMPointerType(LLVMArrayType(elem_type, num_elements),
			       CONST_ADDR_SPACE);
}

/**
 * Load an image view, fmask view. or sampler state descriptor.
 */
static LLVMValueRef get_sampler_desc_custom(struct si_shader_context *ctx,
					    LLVMValueRef list, LLVMValueRef index,
					    enum desc_type type)
{
	struct gallivm_state *gallivm = &ctx->radeon_bld.gallivm;
	LLVMBuilderRef builder = gallivm->builder;

	switch (type) {
	case DESC_IMAGE:
		/* The image is at [0:7]. */
		index = LLVMBuildMul(builder, index, LLVMConstInt(ctx->i32, 2, 0), "");
		break;
	case DESC_FMASK:
		/* The FMASK is at [8:15]. */
		index = LLVMBuildMul(builder, index, LLVMConstInt(ctx->i32, 2, 0), "");
		index = LLVMBuildAdd(builder, index, LLVMConstInt(ctx->i32, 1, 0), "");
		break;
	case DESC_SAMPLER:
		/* The sampler state is at [12:15]. */
		index = LLVMBuildMul(builder, index, LLVMConstInt(ctx->i32, 4, 0), "");
		index = LLVMBuildAdd(builder, index, LLVMConstInt(ctx->i32, 3, 0), "");
		list = LLVMBuildPointerCast(builder, list,
					    const_array(ctx->v4i32, 0), "");
		break;
	}

	return build_indexed_load_const(ctx, list, index);
}

static LLVMValueRef get_sampler_desc(struct si_shader_context *ctx,
				     LLVMValueRef index, enum desc_type type)
{
	LLVMValueRef list = LLVMGetParam(ctx->radeon_bld.main_fn,
					 SI_PARAM_SAMPLERS);

	return get_sampler_desc_custom(ctx, list, index, type);
}

static void tex_fetch_ptrs(
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data,
	LLVMValueRef *res_ptr, LLVMValueRef *samp_ptr, LLVMValueRef *fmask_ptr)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	const struct tgsi_full_instruction *inst = emit_data->inst;
	unsigned target = inst->Texture.Texture;
	unsigned sampler_src;
	unsigned sampler_index;

	sampler_src = emit_data->inst->Instruction.NumSrcRegs - 1;
	sampler_index = emit_data->inst->Src[sampler_src].Register.Index;

	if (emit_data->inst->Src[sampler_src].Register.Indirect) {
		const struct tgsi_full_src_register *reg = &emit_data->inst->Src[sampler_src];
		LLVMValueRef ind_index;

		ind_index = get_indirect_index(ctx, &reg->Indirect, reg->Register.Index);

		*res_ptr = get_sampler_desc(ctx, ind_index, DESC_IMAGE);

		if (target == TGSI_TEXTURE_2D_MSAA ||
		    target == TGSI_TEXTURE_2D_ARRAY_MSAA) {
			*samp_ptr = NULL;
			*fmask_ptr = get_sampler_desc(ctx, ind_index, DESC_FMASK);
		} else {
			*samp_ptr = get_sampler_desc(ctx, ind_index, DESC_SAMPLER);
			*fmask_ptr = NULL;
		}
	} else {
		*res_ptr = ctx->sampler_views[sampler_index];
		*samp_ptr = ctx->sampler_states[sampler_index];
		*fmask_ptr = ctx->fmasks[sampler_index];
	}
}

d2270 2
a2271 2
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
d2273 1
a2273 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d2275 1
a2275 2
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction *inst = emit_data->inst;
d2284 2
d2287 1
a2287 1
	bool has_offset = inst->Texture.NumOffsets > 0;
a2288 1
	unsigned dmask = 0xf;
d2290 2
a2291 1
	tex_fetch_ptrs(bld_base, emit_data, &res_ptr, &samp_ptr, &fmask_ptr);
d2293 3
a2295 19
	if (opcode == TGSI_OPCODE_TXQ) {
		if (target == TGSI_TEXTURE_BUFFER) {
			/* Read the size from the buffer descriptor directly. */
			LLVMValueRef res = LLVMBuildBitCast(builder, res_ptr, ctx->v8i32, "");
			LLVMValueRef size = LLVMBuildExtractElement(builder, res,
							lp_build_const_int32(gallivm, 6), "");

			if (ctx->screen->b.chip_class >= VI) {
				/* On VI, the descriptor contains the size in bytes,
				 * but TXQ must return the size in elements.
				 * The stride is always non-zero for resources using TXQ.
				 */
				LLVMValueRef stride =
					LLVMBuildExtractElement(builder, res,
								lp_build_const_int32(gallivm, 5), "");
				stride = LLVMBuildLShr(builder, stride,
						       lp_build_const_int32(gallivm, 16), "");
				stride = LLVMBuildAnd(builder, stride,
						      lp_build_const_int32(gallivm, 0x3FFF), "");
d2297 1
a2297 2
				size = LLVMBuildUDiv(builder, size, stride, "");
			}
d2299 2
a2300 3
			emit_data->args[0] = size;
			return;
		}
d2302 2
a2303 2
		/* Textures - set the mip level. */
		address[count++] = lp_build_emit_fetch(bld_base, inst, 0, TGSI_CHAN_X);
d2305 12
a2316 3
		set_tex_fetch_args(ctx, emit_data, opcode, target, res_ptr,
				   NULL, address, count, 0xf);
		return;
d2320 4
a2323 1
		LLVMTypeRef v2i128 = LLVMVectorType(ctx->i128, 2);
d2329 1
a2329 1
		res = LLVMBuildBitCast(gallivm->builder, res, ctx->v16i8, "");
d2331 1
a2331 1
		emit_data->dst_type = ctx->v4f32;
d2334 1
a2334 1
		emit_data->args[2] = lp_build_emit_fetch(bld_base, emit_data->inst, 0, TGSI_CHAN_X);
d2383 1
a2383 1
		address[count++] = lp_build_emit_fetch(bld_base, inst, 1, TGSI_CHAN_X);
d2386 1
a2386 1
	if (tgsi_is_shadow_target(target) && opcode != TGSI_OPCODE_LODQ) {
d2388 1
a2388 1
			address[count++] = lp_build_emit_fetch(bld_base, inst, 1, TGSI_CHAN_X);
d2429 1
a2429 1
			unreachable("invalid target");
d2459 1
a2459 1
		address[count++] = lp_build_emit_fetch(bld_base, inst, 1, TGSI_CHAN_X);
d2468 3
a2470 1
						 address[chan], ctx->i32, "");
d2502 4
d2508 1
a2508 1
		inst.Texture.Texture = target;
d2511 7
a2517 3
		set_tex_fetch_args(ctx, &txf_emit_data, TGSI_OPCODE_TXF,
				   target, fmask_ptr, NULL,
				   txf_address, txf_count, 0xf);
d2521 2
a2522 2
		LLVMValueRef four = LLVMConstInt(ctx->i32, 4, 0);
		LLVMValueRef F = LLVMConstInt(ctx->i32, 0xF, 0);
d2546 1
a2546 1
					 ctx->v8i32, "");
d2562 3
d2570 1
a2570 1
			const struct tgsi_texture_offset *off = inst->TexOffsets;
a2599 1
	}
d2601 2
a2602 2
	if (opcode == TGSI_OPCODE_TG4) {
		unsigned gather_comp = 0;
d2604 25
a2628 7
		/* DMASK was repurposed for GATHER4. 4 components are always
		 * returned and DMASK works like a swizzle - it selects
		 * the component to fetch. The only valid DMASK values are
		 * 1=red, 2=green, 4=blue, 8=alpha. (e.g. 1 returns
		 * (red,red,red,red) etc.) The ISA document doesn't mention
		 * this.
		 */
d2630 12
a2641 5
		/* Get the component index from src1.x for Gather4. */
		if (!tgsi_is_shadow_target(target)) {
			LLVMValueRef (*imms)[4] = lp_soa_context(bld_base)->immediates;
			LLVMValueRef comp_imm;
			struct tgsi_src_register src1 = inst->Src[1].Register;
d2643 1
a2643 5
			assert(src1.File == TGSI_FILE_IMMEDIATE);

			comp_imm = imms[src1.Index][src1.SwizzleX];
			gather_comp = LLVMConstIntGetZExtValue(comp_imm);
			gather_comp = CLAMP(gather_comp, 0, 3);
d2646 23
a2668 1
		dmask = 1 << gather_comp;
d2671 12
a2682 2
	set_tex_fetch_args(ctx, emit_data, opcode, target, res_ptr,
			   samp_ptr, address, count, dmask);
d2685 3
a2687 3
static void build_tex_intrinsic(const struct lp_build_tgsi_action *action,
				struct lp_build_tgsi_context *bld_base,
				struct lp_build_emit_data *emit_data)
d2689 1
a2689 1
	struct lp_build_context *base = &bld_base->base;
d2693 2
a2694 11
	bool has_offset = emit_data->inst->Texture.NumOffsets > 0;
	bool is_shadow = tgsi_is_shadow_target(target);
	char type[64];
	const char *name = "llvm.SI.image.sample";
	const char *infix = "";

	if (opcode == TGSI_OPCODE_TXQ && target == TGSI_TEXTURE_BUFFER) {
		/* Just return the buffer size. */
		emit_data->output[emit_data->chan] = emit_data->args[0];
		return;
	}
d2705 35
a2739 41
	switch (opcode) {
	case TGSI_OPCODE_TXF:
		name = target == TGSI_TEXTURE_2D_MSAA ||
		       target == TGSI_TEXTURE_2D_ARRAY_MSAA ?
			       "llvm.SI.image.load" :
			       "llvm.SI.image.load.mip";
		is_shadow = false;
		has_offset = false;
		break;
	case TGSI_OPCODE_TXQ:
		name = "llvm.SI.getresinfo";
		is_shadow = false;
		has_offset = false;
		break;
	case TGSI_OPCODE_LODQ:
		name = "llvm.SI.getlod";
		is_shadow = false;
		has_offset = false;
		break;
	case TGSI_OPCODE_TEX:
	case TGSI_OPCODE_TEX2:
	case TGSI_OPCODE_TXP:
		break;
	case TGSI_OPCODE_TXB:
	case TGSI_OPCODE_TXB2:
		infix = ".b";
		break;
	case TGSI_OPCODE_TXL:
	case TGSI_OPCODE_TXL2:
		infix = ".l";
		break;
	case TGSI_OPCODE_TXD:
		infix = ".d";
		break;
	case TGSI_OPCODE_TG4:
		name = "llvm.SI.gather4";
		break;
	default:
		assert(0);
		return;
	}
d2741 3
a2743 2
	if (LLVMGetTypeKind(LLVMTypeOf(emit_data->args[0])) == LLVMVectorTypeKind)
		sprintf(type, ".v%ui32",
a2744 2
	else
		strcpy(type, ".i32");
d2746 32
a2777 9
	/* Add the type and suffixes .c, .o if needed. */
	sprintf(intr_name, "%s%s%s%s%s",
		name, is_shadow ? ".c" : "", infix,
		has_offset ? ".o" : "", type);

	emit_data->output[emit_data->chan] = lp_build_intrinsic(
		base->gallivm->builder, intr_name, emit_data->dst_type,
		emit_data->args, emit_data->arg_count,
		LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
d2779 10
a2788 7
	/* Divide the number of layers by 6 to get the number of cubes. */
	if (opcode == TGSI_OPCODE_TXQ &&
	    (target == TGSI_TEXTURE_CUBE_ARRAY ||
	     target == TGSI_TEXTURE_SHADOWCUBE_ARRAY)) {
		LLVMBuilderRef builder = bld_base->base.gallivm->builder;
		LLVMValueRef two = lp_build_const_int32(bld_base->base.gallivm, 2);
		LLVMValueRef six = lp_build_const_int32(bld_base->base.gallivm, 6);
d2790 2
a2791 3
		LLVMValueRef v4 = emit_data->output[emit_data->chan];
		LLVMValueRef z = LLVMBuildExtractElement(builder, v4, two, "");
		z = LLVMBuildSDiv(builder, z, six, "");
d2793 4
a2796 2
		emit_data->output[emit_data->chan] =
			LLVMBuildInsertElement(builder, v4, z, two, "");
d2800 3
a2802 4
static void si_llvm_emit_txqs(
	const struct lp_build_tgsi_action *action,
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
d2804 2
a2805 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d2808 70
a2877 2
	LLVMValueRef res, samples;
	LLVMValueRef res_ptr, samp_ptr, fmask_ptr = NULL;
d2879 5
a2883 1
	tex_fetch_ptrs(bld_base, emit_data, &res_ptr, &samp_ptr, &fmask_ptr);
d2885 1
d2887 6
a2892 11
	/* Read the samples from the descriptor directly. */
	res = LLVMBuildBitCast(builder, res_ptr, ctx->v8i32, "");
	samples = LLVMBuildExtractElement(
		builder, res,
		lp_build_const_int32(gallivm, 3), "");
	samples = LLVMBuildLShr(builder, samples,
				lp_build_const_int32(gallivm, 16), "");
	samples = LLVMBuildAnd(builder, samples,
			       lp_build_const_int32(gallivm, 0xf), "");
	samples = LLVMBuildShl(builder, lp_build_const_int32(gallivm, 1),
			       samples, "");
d2894 7
a2900 1
	emit_data->output[emit_data->chan] = samples;
d2933 3
a2935 3
	const struct lp_build_tgsi_action *action,
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
d2937 1
a2937 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d2939 1
d2945 1
d2951 2
d2954 1
a2954 1
	indices[1] = lp_build_intrinsic(gallivm->builder, "llvm.SI.tid", ctx->i32,
d2956 1
a2956 1
	store_ptr = LLVMBuildGEP(gallivm->builder, ctx->lds,
d2968 1
a2968 1
	load_ptr0 = LLVMBuildGEP(gallivm->builder, ctx->lds,
d2975 1
a2975 1
	load_ptr1 = LLVMBuildGEP(gallivm->builder, ctx->lds,
d2994 1
a2994 1
						ctx->i32, ""),
d2998 1
a2998 1
		tl = LLVMBuildBitCast(gallivm->builder, tl, ctx->f32, "");
d3001 1
a3001 1
		trbl = LLVMBuildBitCast(gallivm->builder, trbl,	ctx->f32, "");
d3018 1
a3018 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d3020 1
d3024 1
d3027 2
d3030 1
a3030 1
	indices[1] = lp_build_intrinsic(gallivm->builder, "llvm.SI.tid", ctx->i32,
d3032 1
a3032 1
	store_ptr = LLVMBuildGEP(gallivm->builder, ctx->lds,
d3042 1
a3042 1
	load_ptr_x = LLVMBuildGEP(gallivm->builder, ctx->lds,
d3046 1
a3046 1
	load_ptr_y = LLVMBuildGEP(gallivm->builder, ctx->lds,
d3051 1
a3051 1
	load_ptr_ddx = LLVMBuildGEP(gallivm->builder, ctx->lds,
d3056 1
a3056 1
	load_ptr_ddy = LLVMBuildGEP(gallivm->builder, ctx->lds,
d3070 1
a3070 1
		tl = LLVMBuildBitCast(gallivm->builder, tl, ctx->f32, "");
d3073 1
a3073 1
		tr = LLVMBuildBitCast(gallivm->builder, tr, ctx->f32, "");
d3078 1
a3078 1
		tl = LLVMBuildBitCast(gallivm->builder, tl, ctx->f32, "");
d3081 1
a3081 1
		bl = LLVMBuildBitCast(gallivm->builder, bl, ctx->f32, "");
d3093 1
a3093 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d3101 1
a3101 1
							 TGSI_CHAN_X);
d3104 1
a3104 1
							 TGSI_CHAN_Y);
d3115 1
a3115 1
						emit_data->inst, 1, TGSI_CHAN_X);
d3117 3
a3119 2
					     ctx->i32, "");
		sample_position = load_sample_position(&ctx->radeon_bld, sample_id);
d3138 2
a3139 2
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct si_shader *shader = ctx->shader;
d3144 1
a3144 1
	int input_index = inst->Src[0].Register.Index;
d3148 2
a3149 1
	LLVMValueRef params = LLVMGetParam(ctx->radeon_bld.main_fn, SI_PARAM_PRIM_MASK);
a3150 1
	unsigned interp = shader->selector->info.input_interpolate[input_index];
d3154 1
d3162 2
a3163 1
	interp_param_idx = lookup_interp_param_index(interp, location);
d3167 1
a3167 1
		interp_param = LLVMGetParam(ctx->radeon_bld.main_fn, interp_param_idx);
d3171 2
a3172 1
	attr_number = lp_build_const_int32(gallivm, input_index);
d3199 1
a3199 1
						     ctx->f32, "");
d3210 2
a3211 1
						     temp2, ctx->i32, "");
d3232 1
a3232 1
					   ctx->f32, args, args[3] ? 4 : 3,
d3256 1
a3256 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d3258 1
a3258 1
	struct si_shader *shader = ctx->shader;
d3261 2
a3262 1
	LLVMValueRef soffset = LLVMGetParam(ctx->radeon_bld.main_fn,
d3275 1
a3275 1
				       ctx->gs_next_vertex[stream],
d3291 1
a3291 1
			   ctx->voidt, &kill, 1, 0);
d3295 1
a3295 1
			ctx->radeon_bld.soa.outputs[i];
d3306 1
a3306 1
			out_val = LLVMBuildBitCast(gallivm->builder, out_val, ctx->i32, "");
d3308 2
a3309 2
			build_tbuffer_store(ctx,
					    ctx->gsvs_ring[stream],
d3320 1
a3320 1
	LLVMBuildStore(gallivm->builder, gs_next_vertex, ctx->gs_next_vertex[stream]);
d3324 1
a3324 1
	args[1] = LLVMGetParam(ctx->radeon_bld.main_fn, SI_PARAM_GS_WAVE_ID);
d3326 2
a3327 1
			   ctx->voidt, args, 2, LLVMNoUnwindAttribute);
d3336 1
a3336 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d3344 1
a3344 1
	args[1] = LLVMGetParam(ctx->radeon_bld.main_fn, SI_PARAM_GS_WAVE_ID);
d3346 2
a3347 1
			   ctx->voidt, args, 2, LLVMNoUnwindAttribute);
a3353 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d3356 3
a3358 4
	lp_build_intrinsic(gallivm->builder,
			   HAVE_LLVM >= 0x0309 ? "llvm.amdgcn.s.barrier"
					       : "llvm.AMDGPU.barrier.local",
			   ctx->voidt, NULL, 0, LLVMNoUnwindAttribute);
d3366 6
d3377 1
a3377 25
static void si_create_function(struct si_shader_context *ctx,
			       LLVMTypeRef *returns, unsigned num_returns,
			       LLVMTypeRef *params, unsigned num_params,
			       int last_array_pointer, int last_sgpr)
{
	int i;

	radeon_llvm_create_func(&ctx->radeon_bld, returns, num_returns,
				params, num_params);
	radeon_llvm_shader_type(ctx->radeon_bld.main_fn, ctx->type);
	ctx->return_value = LLVMGetUndef(ctx->radeon_bld.return_type);

	for (i = 0; i <= last_sgpr; ++i) {
		LLVMValueRef P = LLVMGetParam(ctx->radeon_bld.main_fn, i);

		/* We tell llvm that array inputs are passed by value to allow Sinking pass
		 * to move load. Inputs are constant so this is fine. */
		if (i <= last_array_pointer)
			LLVMAddAttribute(P, LLVMByValAttribute);
		else
			LLVMAddAttribute(P, LLVMInRegAttribute);
	}
}

static void create_meta_data(struct si_shader_context *ctx)
d3379 1
a3379 1
	struct gallivm_state *gallivm = ctx->radeon_bld.soa.bld_base.base.gallivm;
d3386 1
a3386 1
	ctx->const_md = LLVMMDNodeInContext(gallivm->context, args, 3);
d3389 7
a3395 1
static void declare_streamout_params(struct si_shader_context *ctx,
d3404 2
a3405 2
		params[ctx->param_streamout_config = (*num_params)++] = i32;
		params[ctx->param_streamout_write_index = (*num_params)++] = i32;
d3412 1
a3412 1
		params[ctx->param_streamout_offset[i] = (*num_params)++] = i32;
d3416 1
a3416 1
static unsigned llvm_get_type_size(LLVMTypeRef type)
d3418 1
a3418 42
	LLVMTypeKind kind = LLVMGetTypeKind(type);

	switch (kind) {
	case LLVMIntegerTypeKind:
		return LLVMGetIntTypeWidth(type) / 8;
	case LLVMFloatTypeKind:
		return 4;
	case LLVMPointerTypeKind:
		return 8;
	case LLVMVectorTypeKind:
		return LLVMGetVectorSize(type) *
		       llvm_get_type_size(LLVMGetElementType(type));
	default:
		assert(0);
		return 0;
	}
}

static void declare_tess_lds(struct si_shader_context *ctx)
{
	struct gallivm_state *gallivm = &ctx->radeon_bld.gallivm;
	LLVMTypeRef i32 = ctx->radeon_bld.soa.bld_base.uint_bld.elem_type;

	/* This is the upper bound, maximum is 32 inputs times 32 vertices */
	unsigned vertex_data_dw_size = 32*32*4;
	unsigned patch_data_dw_size = 32*4;
	/* The formula is: TCS inputs + TCS outputs + TCS patch outputs. */
	unsigned patch_dw_size = vertex_data_dw_size*2 + patch_data_dw_size;
	unsigned lds_dwords = patch_dw_size;

	/* The actual size is computed outside of the shader to reduce
	 * the number of shader variants. */
	ctx->lds =
		LLVMAddGlobalInAddressSpace(gallivm->module,
					    LLVMArrayType(i32, lds_dwords),
					    "tess_lds",
					    LOCAL_ADDR_SPACE);
}

static void create_function(struct si_shader_context *ctx)
{
	struct lp_build_tgsi_context *bld_base = &ctx->radeon_bld.soa.bld_base;
d3420 18
a3437 13
	struct si_shader *shader = ctx->shader;
	LLVMTypeRef params[SI_NUM_PARAMS + SI_NUM_VERTEX_BUFFERS], v3i32;
	LLVMTypeRef returns[16+32*4];
	unsigned i, last_array_pointer, last_sgpr, num_params, num_return_sgprs;
	unsigned num_returns = 0;

	v3i32 = LLVMVectorType(ctx->i32, 3);

	params[SI_PARAM_RW_BUFFERS] = const_array(ctx->v16i8, SI_NUM_RW_BUFFERS);
	params[SI_PARAM_CONST_BUFFERS] = const_array(ctx->v16i8, SI_NUM_CONST_BUFFERS);
	params[SI_PARAM_SAMPLERS] = const_array(ctx->v8i32, SI_NUM_SAMPLERS);
	params[SI_PARAM_UNUSED] = LLVMPointerType(ctx->i32, CONST_ADDR_SPACE);
	last_array_pointer = SI_PARAM_UNUSED;
d3439 1
a3439 1
	switch (ctx->type) {
d3441 4
a3444 4
		params[SI_PARAM_VERTEX_BUFFERS] = const_array(ctx->v16i8, SI_NUM_VERTEX_BUFFERS);
		last_array_pointer = SI_PARAM_VERTEX_BUFFERS;
		params[SI_PARAM_BASE_VERTEX] = ctx->i32;
		params[SI_PARAM_START_INSTANCE] = ctx->i32;
d3448 1
a3448 1
			params[ctx->param_es2gs_offset = num_params++] = ctx->i32;
d3450 1
a3450 1
			params[SI_PARAM_LS_OUT_LAYOUT] = ctx->i32;
d3453 3
a3455 6
			if (ctx->is_gs_copy_shader) {
				last_array_pointer = SI_PARAM_CONST_BUFFERS;
				num_params = SI_PARAM_CONST_BUFFERS+1;
			} else {
				params[SI_PARAM_VS_STATE_BITS] = ctx->i32;
				num_params = SI_PARAM_VS_STATE_BITS+1;
d3459 2
a3460 2
			declare_streamout_params(ctx, &shader->selector->so,
						 params, ctx->i32, &num_params);
d3466 4
a3469 18
		params[ctx->param_vertex_id = num_params++] = ctx->i32;
		params[ctx->param_rel_auto_id = num_params++] = ctx->i32;
		params[ctx->param_vs_prim_id = num_params++] = ctx->i32;
		params[ctx->param_instance_id = num_params++] = ctx->i32;

		if (!ctx->is_monolithic &&
		    !ctx->is_gs_copy_shader) {
			/* Vertex load indices. */
			ctx->param_vertex_index0 = num_params;

			for (i = 0; i < shader->selector->info.num_inputs; i++)
				params[num_params++] = ctx->i32;

			/* PrimitiveID output. */
			if (!shader->key.vs.as_es && !shader->key.vs.as_ls)
				for (i = 0; i <= VS_EPILOG_PRIMID_LOC; i++)
					returns[num_returns++] = ctx->f32;
		}
d3473 4
a3476 4
		params[SI_PARAM_TCS_OUT_OFFSETS] = ctx->i32;
		params[SI_PARAM_TCS_OUT_LAYOUT] = ctx->i32;
		params[SI_PARAM_TCS_IN_LAYOUT] = ctx->i32;
		params[SI_PARAM_TESS_FACTOR_OFFSET] = ctx->i32;
d3480 2
a3481 2
		params[SI_PARAM_PATCH_ID] = ctx->i32;
		params[SI_PARAM_REL_IDS] = ctx->i32;
a3482 9

		if (!ctx->is_monolithic) {
			/* PARAM_TESS_FACTOR_OFFSET is after user SGPRs. */
			for (i = 0; i <= SI_TCS_NUM_USER_SGPR; i++)
				returns[num_returns++] = ctx->i32; /* SGPRs */

			for (i = 0; i < 3; i++)
				returns[num_returns++] = ctx->f32; /* VGPRs */
		}
d3486 2
a3487 2
		params[SI_PARAM_TCS_OUT_OFFSETS] = ctx->i32;
		params[SI_PARAM_TCS_OUT_LAYOUT] = ctx->i32;
d3491 1
a3491 1
			params[ctx->param_es2gs_offset = num_params++] = ctx->i32;
d3493 2
a3494 2
			declare_streamout_params(ctx, &shader->selector->so,
						 params, ctx->i32, &num_params);
d3499 4
a3502 9
		params[ctx->param_tes_u = num_params++] = ctx->f32;
		params[ctx->param_tes_v = num_params++] = ctx->f32;
		params[ctx->param_tes_rel_patch_id = num_params++] = ctx->i32;
		params[ctx->param_tes_patch_id = num_params++] = ctx->i32;

		/* PrimitiveID output. */
		if (!ctx->is_monolithic && !shader->key.tes.as_es)
			for (i = 0; i <= VS_EPILOG_PRIMID_LOC; i++)
				returns[num_returns++] = ctx->f32;
d3506 2
a3507 2
		params[SI_PARAM_GS2VS_OFFSET] = ctx->i32;
		params[SI_PARAM_GS_WAVE_ID] = ctx->i32;
d3511 8
a3518 8
		params[SI_PARAM_VTX0_OFFSET] = ctx->i32;
		params[SI_PARAM_VTX1_OFFSET] = ctx->i32;
		params[SI_PARAM_PRIMITIVE_ID] = ctx->i32;
		params[SI_PARAM_VTX2_OFFSET] = ctx->i32;
		params[SI_PARAM_VTX3_OFFSET] = ctx->i32;
		params[SI_PARAM_VTX4_OFFSET] = ctx->i32;
		params[SI_PARAM_VTX5_OFFSET] = ctx->i32;
		params[SI_PARAM_GS_INSTANCE_ID] = ctx->i32;
d3523 2
a3524 2
		params[SI_PARAM_ALPHA_REF] = ctx->f32;
		params[SI_PARAM_PRIM_MASK] = ctx->i32;
d3526 3
a3528 3
		params[SI_PARAM_PERSP_SAMPLE] = ctx->v2i32;
		params[SI_PARAM_PERSP_CENTER] = ctx->v2i32;
		params[SI_PARAM_PERSP_CENTROID] = ctx->v2i32;
d3530 12
a3541 12
		params[SI_PARAM_LINEAR_SAMPLE] = ctx->v2i32;
		params[SI_PARAM_LINEAR_CENTER] = ctx->v2i32;
		params[SI_PARAM_LINEAR_CENTROID] = ctx->v2i32;
		params[SI_PARAM_LINE_STIPPLE_TEX] = ctx->f32;
		params[SI_PARAM_POS_X_FLOAT] = ctx->f32;
		params[SI_PARAM_POS_Y_FLOAT] = ctx->f32;
		params[SI_PARAM_POS_Z_FLOAT] = ctx->f32;
		params[SI_PARAM_POS_W_FLOAT] = ctx->f32;
		params[SI_PARAM_FRONT_FACE] = ctx->i32;
		params[SI_PARAM_ANCILLARY] = ctx->i32;
		params[SI_PARAM_SAMPLE_COVERAGE] = ctx->f32;
		params[SI_PARAM_POS_FIXED_PT] = ctx->i32;
a3542 31

		if (!ctx->is_monolithic) {
			/* Color inputs from the prolog. */
			if (shader->selector->info.colors_read) {
				unsigned num_color_elements =
					util_bitcount(shader->selector->info.colors_read);

				assert(num_params + num_color_elements <= ARRAY_SIZE(params));
				for (i = 0; i < num_color_elements; i++)
					params[num_params++] = ctx->f32;
			}

			/* Outputs for the epilog. */
			num_return_sgprs = SI_SGPR_ALPHA_REF + 1;
			num_returns =
				num_return_sgprs +
				util_bitcount(shader->selector->info.colors_written) * 4 +
				shader->selector->info.writes_z +
				shader->selector->info.writes_stencil +
				shader->selector->info.writes_samplemask +
				1 /* SampleMaskIn */;

			num_returns = MAX2(num_returns,
					   num_return_sgprs +
					   PS_EPILOG_SAMPLEMASK_MIN_LOC + 1);

			for (i = 0; i < num_return_sgprs; i++)
				returns[i] = ctx->i32;
			for (; i < num_returns; i++)
				returns[i] = ctx->f32;
		}
d3551 2
d3554 3
a3556 2
	si_create_function(ctx, returns, num_returns, params,
			   num_params, last_array_pointer, last_sgpr);
d3558 9
a3566 13
	/* Reserve register locations for VGPR inputs the PS prolog may need. */
	if (ctx->type == TGSI_PROCESSOR_FRAGMENT &&
	    !ctx->is_monolithic) {
		radeon_llvm_add_attribute(ctx->radeon_bld.main_fn,
					  "InitialPSInputAddr",
					  S_0286D0_PERSP_SAMPLE_ENA(1) |
					  S_0286D0_PERSP_CENTER_ENA(1) |
					  S_0286D0_PERSP_CENTROID_ENA(1) |
					  S_0286D0_LINEAR_SAMPLE_ENA(1) |
					  S_0286D0_LINEAR_CENTER_ENA(1) |
					  S_0286D0_LINEAR_CENTROID_ENA(1) |
					  S_0286D0_FRONT_FACE_ENA(1) |
					  S_0286D0_POS_FIXED_PT_ENA(1));
a3568 13
	shader->info.num_input_sgprs = 0;
	shader->info.num_input_vgprs = 0;

	for (i = 0; i <= last_sgpr; ++i)
		shader->info.num_input_sgprs += llvm_get_type_size(params[i]) / 4;

	/* Unused fragment shader inputs are eliminated by the compiler,
	 * so we don't know yet how many there will be.
	 */
	if (ctx->type != TGSI_PROCESSOR_FRAGMENT)
		for (; i < num_params; ++i)
			shader->info.num_input_vgprs += llvm_get_type_size(params[i]) / 4;

d3576 1
a3576 1
		ctx->lds =
d3578 1
a3578 1
						    LLVMArrayType(ctx->i32, 64),
d3582 18
a3599 4
	if ((ctx->type == TGSI_PROCESSOR_VERTEX && shader->key.vs.as_ls) ||
	    ctx->type == TGSI_PROCESSOR_TESS_CTRL ||
	    ctx->type == TGSI_PROCESSOR_TESS_EVAL)
		declare_tess_lds(ctx);
d3602 1
a3602 1
static void preload_constants(struct si_shader_context *ctx)
d3604 3
a3606 3
	struct lp_build_tgsi_context *bld_base = &ctx->radeon_bld.soa.bld_base;
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	const struct tgsi_shader_info *info = bld_base->info;
d3608 1
a3608 1
	LLVMValueRef ptr = LLVMGetParam(ctx->radeon_bld.main_fn, SI_PARAM_CONST_BUFFERS);
d3617 1
a3617 1
		ctx->constants[buf] = CALLOC(num_const * 4, sizeof(LLVMValueRef));
d3620 2
a3621 2
		ctx->const_buffers[buf] =
			build_indexed_load_const(ctx, ptr, lp_build_const_int32(gallivm, buf));
d3625 1
a3625 1
			ctx->constants[buf][i] =
d3627 1
a3627 1
					ctx->const_buffers[buf],
d3629 1
a3629 1
					ctx->f32);
d3634 1
a3634 1
static void preload_samplers(struct si_shader_context *ctx)
d3636 4
a3639 3
	struct lp_build_tgsi_context *bld_base = &ctx->radeon_bld.soa.bld_base;
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	const struct tgsi_shader_info *info = bld_base->info;
d3641 2
d3648 3
d3655 5
a3659 2
		ctx->sampler_views[i] =
			get_sampler_desc(ctx, offset, DESC_IMAGE);
d3662 5
a3666 6
		if (info->is_msaa_sampler[i])
			ctx->fmasks[i] =
				get_sampler_desc(ctx, offset, DESC_FMASK);
		else
			ctx->sampler_states[i] =
				get_sampler_desc(ctx, offset, DESC_SAMPLER);
d3670 1
a3670 1
static void preload_streamout_buffers(struct si_shader_context *ctx)
d3672 2
a3673 2
	struct lp_build_tgsi_context *bld_base = &ctx->radeon_bld.soa.bld_base;
	struct gallivm_state *gallivm = bld_base->base.gallivm;
d3677 6
a3682 6
	if (!ctx->shader->selector->so.num_outputs ||
	    (ctx->type == TGSI_PROCESSOR_VERTEX &&
	     (ctx->shader->key.vs.as_es ||
	      ctx->shader->key.vs.as_ls)) ||
	    (ctx->type == TGSI_PROCESSOR_TESS_EVAL &&
	     ctx->shader->key.tes.as_es))
d3685 1
a3685 1
	LLVMValueRef buf_ptr = LLVMGetParam(ctx->radeon_bld.main_fn,
d3690 1
a3690 1
		if (ctx->shader->selector->so.stride[i]) {
d3694 1
a3694 1
			ctx->so_buffers[i] = build_indexed_load_const(ctx, buf_ptr, offset);
d3703 1
a3703 1
static void preload_ring_buffers(struct si_shader_context *ctx)
d3706 1
a3706 1
		ctx->radeon_bld.soa.bld_base.base.gallivm;
d3708 1
a3708 1
	LLVMValueRef buf_ptr = LLVMGetParam(ctx->radeon_bld.main_fn,
d3711 5
a3715 5
	if ((ctx->type == TGSI_PROCESSOR_VERTEX &&
	     ctx->shader->key.vs.as_es) ||
	    (ctx->type == TGSI_PROCESSOR_TESS_EVAL &&
	     ctx->shader->key.tes.as_es) ||
	    ctx->type == TGSI_PROCESSOR_GEOMETRY) {
d3718 2
a3719 2
		ctx->esgs_ring =
			build_indexed_load_const(ctx, buf_ptr, offset);
d3722 1
a3722 1
	if (ctx->is_gs_copy_shader) {
d3725 2
a3726 2
		ctx->gsvs_ring[0] =
			build_indexed_load_const(ctx, buf_ptr, offset);
d3728 1
a3728 1
	if (ctx->type == TGSI_PROCESSOR_GEOMETRY) {
d3733 2
a3734 2
			ctx->gsvs_ring[i] =
				build_indexed_load_const(ctx, buf_ptr, offset);
d3739 3
a3741 46
static void si_llvm_emit_polygon_stipple(struct si_shader_context *ctx,
					 LLVMValueRef param_sampler_views,
					 unsigned param_pos_fixed_pt)
{
	struct lp_build_tgsi_context *bld_base =
		&ctx->radeon_bld.soa.bld_base;
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	struct lp_build_emit_data result = {};
	struct tgsi_full_instruction inst = {};
	LLVMValueRef desc, sampler_index, address[2], pix;

	/* Use the fixed-point gl_FragCoord input.
	 * Since the stipple pattern is 32x32 and it repeats, just get 5 bits
	 * per coordinate to get the repeating effect.
	 */
	address[0] = unpack_param(ctx, param_pos_fixed_pt, 0, 5);
	address[1] = unpack_param(ctx, param_pos_fixed_pt, 16, 5);

	/* Load the sampler view descriptor. */
	sampler_index = lp_build_const_int32(gallivm, SI_POLY_STIPPLE_SAMPLER);
	desc = get_sampler_desc_custom(ctx, param_sampler_views,
				       sampler_index, DESC_IMAGE);

	/* Load the texel. */
	inst.Instruction.Opcode = TGSI_OPCODE_TXF;
	inst.Texture.Texture = TGSI_TEXTURE_2D_MSAA; /* = use load, not load_mip */
	result.inst = &inst;
	set_tex_fetch_args(ctx, &result, TGSI_OPCODE_TXF,
			   inst.Texture.Texture,
			   desc, NULL, address, ARRAY_SIZE(address), 0xf);
	build_tex_intrinsic(&tex_action, bld_base, &result);

	/* Kill the thread accordingly. */
	pix = LLVMBuildExtractElement(gallivm->builder, result.output[0],
				      lp_build_const_int32(gallivm, 3), "");
	pix = bitcast(bld_base, TGSI_TYPE_FLOAT, pix);
	pix = LLVMBuildFNeg(gallivm->builder, pix, "");

	lp_build_intrinsic(gallivm->builder, "llvm.AMDGPU.kill",
			   LLVMVoidTypeInContext(gallivm->context),
			   &pix, 1, 0);
}

void si_shader_binary_read_config(struct radeon_shader_binary *binary,
				  struct si_shader_config *conf,
				  unsigned symbol_offset)
d3745 2
a3746 1
		radeon_shader_binary_config_start(binary, symbol_offset);
d3752 1
a3752 1
	for (i = 0; i < binary->config_size_per_symbol; i+= 8) {
d3760 4
a3763 4
			conf->num_sgprs = MAX2(conf->num_sgprs, (G_00B028_SGPRS(value) + 1) * 8);
			conf->num_vgprs = MAX2(conf->num_vgprs, (G_00B028_VGPRS(value) + 1) * 4);
			conf->float_mode =  G_00B028_FLOAT_MODE(value);
			conf->rsrc1 = value;
d3766 1
a3766 1
			conf->lds_size = MAX2(conf->lds_size, G_00B02C_EXTRA_LDS_SIZE(value));
d3769 2
a3770 2
			conf->lds_size = MAX2(conf->lds_size, G_00B84C_LDS_SIZE(value));
			conf->rsrc2 = value;
d3773 1
a3773 4
			conf->spi_ps_input_ena = value;
			break;
		case R_0286D0_SPI_PS_INPUT_ADDR:
			conf->spi_ps_input_addr = value;
d3778 1
a3778 1
			conf->scratch_bytes_per_wave =
d3782 2
a3783 9
			{
				static bool printed;

				if (!printed) {
					fprintf(stderr, "Warning: LLVM emitted unknown "
						"config register: 0x%x\n", reg);
					printed = true;
				}
			}
a3785 3

		if (!conf->spi_ps_input_addr)
			conf->spi_ps_input_addr = conf->spi_ps_input_ena;
d3794 1
a3794 1
	uint32_t scratch_rsrc_dword0 = scratch_va;
d3797 1
a3797 1
		|  S_008F04_STRIDE(shader->config.scratch_bytes_per_wave / 64);
a3811 11
static unsigned si_get_shader_binary_size(struct si_shader *shader)
{
	unsigned size = shader->binary.code_size;

	if (shader->prolog)
		size += shader->prolog->binary.code_size;
	if (shader->epilog)
		size += shader->epilog->binary.code_size;
	return size;
}

d3814 2
a3815 7
	const struct radeon_shader_binary *prolog =
		shader->prolog ? &shader->prolog->binary : NULL;
	const struct radeon_shader_binary *epilog =
		shader->epilog ? &shader->epilog->binary : NULL;
	const struct radeon_shader_binary *mainb = &shader->binary;
	unsigned bo_size = si_get_shader_binary_size(shader) +
			   (!epilog ? mainb->rodata_size : 0);
a3817 4
	assert(!prolog || !prolog->rodata_size);
	assert((!prolog && !epilog) || !mainb->rodata_size);
	assert(!epilog || !epilog->rodata_size);

d3821 1
a3821 1
					       bo_size);
d3825 1
a3825 2
	/* Upload. */
	ptr = sscreen->b.ws->buffer_map(shader->bo->buf, NULL,
d3827 5
a3831 4

	if (prolog) {
		util_memcpy_cpu_to_le32(ptr, prolog->code, prolog->code_size);
		ptr += prolog->code_size;
d3834 1
a3834 9
	util_memcpy_cpu_to_le32(ptr, mainb->code, mainb->code_size);
	ptr += mainb->code_size;

	if (epilog)
		util_memcpy_cpu_to_le32(ptr, epilog->code, epilog->code_size);
	else if (mainb->rodata_size > 0)
		util_memcpy_cpu_to_le32(ptr, mainb->rodata, mainb->rodata_size);

	sscreen->b.ws->buffer_unmap(shader->bo->buf);
d3838 12
a3849 19
static void si_shader_dump_disassembly(const struct radeon_shader_binary *binary,
				       struct pipe_debug_callback *debug,
				       const char *name)
{
	char *line, *p;
	unsigned i, count;

	if (binary->disasm_string) {
		fprintf(stderr, "Shader %s disassembly:\n", name);
		fprintf(stderr, "%s", binary->disasm_string);

		if (debug && debug->debug_message) {
			/* Very long debug messages are cut off, so send the
			 * disassembly one line at a time. This causes more
			 * overhead, but on the plus side it simplifies
			 * parsing of resulting logs.
			 */
			pipe_debug_message(debug, SHADER_INFO,
					   "Shader Disassembly Begin");
d3851 11
a3861 8
			line = binary->disasm_string;
			while (*line) {
				p = util_strchrnul(line, '\n');
				count = p - line;

				if (count) {
					pipe_debug_message(debug, SHADER_INFO,
							   "%.*s", count, line);
a3862 4

				if (!*p)
					break;
				line = p + 1;
a3863 61

			pipe_debug_message(debug, SHADER_INFO,
					   "Shader Disassembly End");
		}
	} else {
		fprintf(stderr, "Shader %s binary:\n", name);
		for (i = 0; i < binary->code_size; i += 4) {
			fprintf(stderr, "@@0x%x: %02x%02x%02x%02x\n", i,
				binary->code[i + 3], binary->code[i + 2],
				binary->code[i + 1], binary->code[i]);
		}
	}
}

static void si_shader_dump_stats(struct si_screen *sscreen,
			         struct si_shader_config *conf,
				 unsigned num_inputs,
				 unsigned code_size,
			         struct pipe_debug_callback *debug,
			         unsigned processor)
{
	unsigned lds_increment = sscreen->b.chip_class >= CIK ? 512 : 256;
	unsigned lds_per_wave = 0;
	unsigned max_simd_waves = 10;

	/* Compute LDS usage for PS. */
	if (processor == TGSI_PROCESSOR_FRAGMENT) {
		/* The minimum usage per wave is (num_inputs * 36). The maximum
		 * usage is (num_inputs * 36 * 16).
		 * We can get anything in between and it varies between waves.
		 *
		 * Other stages don't know the size at compile time or don't
		 * allocate LDS per wave, but instead they do it per thread group.
		 */
		lds_per_wave = conf->lds_size * lds_increment +
			       align(num_inputs * 36, lds_increment);
	}

	/* Compute the per-SIMD wave counts. */
	if (conf->num_sgprs) {
		if (sscreen->b.chip_class >= VI)
			max_simd_waves = MIN2(max_simd_waves, 800 / conf->num_sgprs);
		else
			max_simd_waves = MIN2(max_simd_waves, 512 / conf->num_sgprs);
	}

	if (conf->num_vgprs)
		max_simd_waves = MIN2(max_simd_waves, 256 / conf->num_vgprs);

	/* LDS is 64KB per CU (4 SIMDs), divided into 16KB blocks per SIMD
	 * that PS can use.
	 */
	if (lds_per_wave)
		max_simd_waves = MIN2(max_simd_waves, 16384 / lds_per_wave);

	if (r600_can_dump_shader(&sscreen->b, processor)) {
		if (processor == TGSI_PROCESSOR_FRAGMENT) {
			fprintf(stderr, "*** SHADER CONFIG ***\n"
				"SPI_PS_INPUT_ADDR = 0x%04x\n"
				"SPI_PS_INPUT_ENA  = 0x%04x\n",
				conf->spi_ps_input_addr, conf->spi_ps_input_ena);
d3867 4
a3870 49
			"SGPRS: %d\n"
			"VGPRS: %d\n"
			"Code Size: %d bytes\n"
			"LDS: %d blocks\n"
			"Scratch: %d bytes per wave\n"
			"Max Waves: %d\n"
			"********************\n",
			conf->num_sgprs, conf->num_vgprs, code_size,
			conf->lds_size, conf->scratch_bytes_per_wave,
			max_simd_waves);
	}

	pipe_debug_message(debug, SHADER_INFO,
			   "Shader Stats: SGPRS: %d VGPRS: %d Code Size: %d "
			   "LDS: %d Scratch: %d Max Waves: %d",
			   conf->num_sgprs, conf->num_vgprs, code_size,
			   conf->lds_size, conf->scratch_bytes_per_wave,
			   max_simd_waves);
}

static const char *si_get_shader_name(struct si_shader *shader,
				      unsigned processor)
{
	switch (processor) {
	case TGSI_PROCESSOR_VERTEX:
		if (shader->key.vs.as_es)
			return "Vertex Shader as ES";
		else if (shader->key.vs.as_ls)
			return "Vertex Shader as LS";
		else
			return "Vertex Shader as VS";
	case TGSI_PROCESSOR_TESS_CTRL:
		return "Tessellation Control Shader";
	case TGSI_PROCESSOR_TESS_EVAL:
		if (shader->key.tes.as_es)
			return "Tessellation Evaluation Shader as ES";
		else
			return "Tessellation Evaluation Shader as VS";
	case TGSI_PROCESSOR_GEOMETRY:
		if (shader->gs_copy_shader == NULL)
			return "GS Copy Shader as VS";
		else
			return "Geometry Shader";
	case TGSI_PROCESSOR_FRAGMENT:
		return "Pixel Shader";
	case TGSI_PROCESSOR_COMPUTE:
		return "Compute Shader";
	default:
		return "Unknown Shader";
d3872 1
d3875 2
a3876 32
void si_shader_dump(struct si_screen *sscreen, struct si_shader *shader,
		    struct pipe_debug_callback *debug, unsigned processor)
{
	if (r600_can_dump_shader(&sscreen->b, processor) &&
	    !(sscreen->b.debug_flags & DBG_NO_ASM)) {
		fprintf(stderr, "\n%s:\n", si_get_shader_name(shader, processor));

		if (shader->prolog)
			si_shader_dump_disassembly(&shader->prolog->binary,
						   debug, "prolog");

		si_shader_dump_disassembly(&shader->binary, debug, "main");

		if (shader->epilog)
			si_shader_dump_disassembly(&shader->epilog->binary,
						   debug, "epilog");
		fprintf(stderr, "\n");
	}

	si_shader_dump_stats(sscreen, &shader->config,
			     shader->selector ? shader->selector->info.num_inputs : 0,
			     si_get_shader_binary_size(shader), debug, processor);
}

int si_compile_llvm(struct si_screen *sscreen,
		    struct radeon_shader_binary *binary,
		    struct si_shader_config *conf,
		    LLVMTargetMachineRef tm,
		    LLVMModuleRef mod,
		    struct pipe_debug_callback *debug,
		    unsigned processor,
		    const char *name)
d3879 8
a3886 1
	unsigned count = p_atomic_inc_return(&sscreen->b.num_compilations);
d3888 1
a3888 2
	if (r600_can_dump_shader(&sscreen->b, processor)) {
		fprintf(stderr, "radeonsi: Compiling shader %d\n", count);
d3890 8
a3897 5
		if (!(sscreen->b.debug_flags & (DBG_NO_IR | DBG_PREOPT_IR))) {
			fprintf(stderr, "%s LLVM IR:\n\n", name);
			LLVMDumpModule(mod);
			fprintf(stderr, "\n");
		}
a3898 42

	if (!si_replace_shader(count, binary)) {
		r = radeon_llvm_compile(mod, binary,
			r600_get_llvm_processor_name(sscreen->b.family), tm,
			debug);
		if (r)
			return r;
	}

	si_shader_binary_read_config(binary, conf, 0);

	/* Enable 64-bit and 16-bit denormals, because there is no performance
	 * cost.
	 *
	 * If denormals are enabled, all floating-point output modifiers are
	 * ignored.
	 *
	 * Don't enable denormals for 32-bit floats, because:
	 * - Floating-point output modifiers would be ignored by the hw.
	 * - Some opcodes don't support denormals, such as v_mad_f32. We would
	 *   have to stop using those.
	 * - SI & CI would be very slow.
	 */
	conf->float_mode |= V_00B028_FP_64_DENORMS;

	FREE(binary->config);
	FREE(binary->global_symbol_offsets);
	binary->config = NULL;
	binary->global_symbol_offsets = NULL;

	/* Some shaders can't have rodata because their binaries can be
	 * concatenated.
	 */
	if (binary->rodata_size &&
	    (processor == TGSI_PROCESSOR_VERTEX ||
	     processor == TGSI_PROCESSOR_TESS_CTRL ||
	     processor == TGSI_PROCESSOR_TESS_EVAL ||
	     processor == TGSI_PROCESSOR_FRAGMENT)) {
		fprintf(stderr, "radeonsi: The shader can't have rodata.");
		return -EINVAL;
	}

d3904 2
a3905 3
				      struct si_shader_context *ctx,
				      struct si_shader *gs,
				      struct pipe_debug_callback *debug)
d3907 3
a3909 2
	struct gallivm_state *gallivm = &ctx->radeon_bld.gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx->radeon_bld.soa.bld_base;
d3911 1
d3919 4
a3922 8
	si_init_shader_ctx(ctx, sscreen, ctx->shader, ctx->tm);
	ctx->type = TGSI_PROCESSOR_VERTEX;
	ctx->is_gs_copy_shader = true;

	create_meta_data(ctx);
	create_function(ctx);
	preload_streamout_buffers(ctx);
	preload_ring_buffers(ctx);
d3924 6
a3929 1
	args[0] = ctx->gsvs_ring[0];
d3931 2
a3932 2
				   LLVMGetParam(ctx->radeon_bld.main_fn,
						ctx->param_vertex_id),
d3957 2
a3958 1
								 ctx->i32, args, 9,
d3960 1
a3960 1
						 ctx->f32, "");
d3966 4
a3969 1
	LLVMBuildRet(gallivm->builder, ctx->return_value);
d3971 2
a3972 19
	/* Dump LLVM IR before any optimization passes */
	if (sscreen->b.debug_flags & DBG_PREOPT_IR &&
	    r600_can_dump_shader(&sscreen->b, TGSI_PROCESSOR_GEOMETRY))
		LLVMDumpModule(bld_base->base.gallivm->module);

	radeon_llvm_finalize_module(&ctx->radeon_bld);

	r = si_compile_llvm(sscreen, &ctx->shader->binary,
			    &ctx->shader->config, ctx->tm,
			    bld_base->base.gallivm->module,
			    debug, TGSI_PROCESSOR_GEOMETRY,
			    "GS Copy Shader");
	if (!r) {
		if (r600_can_dump_shader(&sscreen->b, TGSI_PROCESSOR_GEOMETRY))
			fprintf(stderr, "GS Copy Shader:\n");
		si_shader_dump(sscreen, ctx->shader, debug,
			       TGSI_PROCESSOR_GEOMETRY);
		r = si_shader_binary_upload(sscreen, ctx->shader);
	}
d3974 1
a3974 1
	radeon_llvm_dispose(&ctx->radeon_bld);
d3980 1
a3980 1
void si_dump_shader_key(unsigned shader, union si_shader_key *key, FILE *f)
d3984 1
a3984 1
	fprintf(f, "SHADER KEY\n");
d3988 11
a3998 8
		fprintf(f, "  instance_divisors = {");
		for (i = 0; i < Elements(key->vs.prolog.instance_divisors); i++)
			fprintf(f, !i ? "%u" : ", %u",
				key->vs.prolog.instance_divisors[i]);
		fprintf(f, "}\n");
		fprintf(f, "  as_es = %u\n", key->vs.as_es);
		fprintf(f, "  as_ls = %u\n", key->vs.as_ls);
		fprintf(f, "  export_prim_id = %u\n", key->vs.epilog.export_prim_id);
d4002 1
a4002 1
		fprintf(f, "  prim_mode = %u\n", key->tcs.epilog.prim_mode);
d4006 4
a4009 2
		fprintf(f, "  as_es = %u\n", key->tes.as_es);
		fprintf(f, "  export_prim_id = %u\n", key->tes.epilog.export_prim_id);
d4016 6
a4021 10
		fprintf(f, "  prolog.color_two_side = %u\n", key->ps.prolog.color_two_side);
		fprintf(f, "  prolog.poly_stipple = %u\n", key->ps.prolog.poly_stipple);
		fprintf(f, "  prolog.force_persample_interp = %u\n", key->ps.prolog.force_persample_interp);
		fprintf(f, "  epilog.spi_shader_col_format = 0x%x\n", key->ps.epilog.spi_shader_col_format);
		fprintf(f, "  epilog.color_is_int8 = 0x%X\n", key->ps.epilog.color_is_int8);
		fprintf(f, "  epilog.last_cbuf = %u\n", key->ps.epilog.last_cbuf);
		fprintf(f, "  epilog.alpha_func = %u\n", key->ps.epilog.alpha_func);
		fprintf(f, "  epilog.alpha_to_one = %u\n", key->ps.epilog.alpha_to_one);
		fprintf(f, "  epilog.poly_line_smoothing = %u\n", key->ps.epilog.poly_line_smoothing);
		fprintf(f, "  epilog.clamp_color = %u\n", key->ps.epilog.clamp_color);
d4029 39
a4067 16
static void si_init_shader_ctx(struct si_shader_context *ctx,
			       struct si_screen *sscreen,
			       struct si_shader *shader,
			       LLVMTargetMachineRef tm)
{
	struct lp_build_tgsi_context *bld_base;

	memset(ctx, 0, sizeof(*ctx));
	radeon_llvm_context_init(&ctx->radeon_bld, "amdgcn--");
	ctx->tm = tm;
	ctx->screen = sscreen;
	if (shader && shader->selector)
		ctx->type = shader->selector->info.processor;
	else
		ctx->type = -1;
	ctx->shader = shader;
d4069 2
a4070 16
	ctx->voidt = LLVMVoidTypeInContext(ctx->radeon_bld.gallivm.context);
	ctx->i1 = LLVMInt1TypeInContext(ctx->radeon_bld.gallivm.context);
	ctx->i8 = LLVMInt8TypeInContext(ctx->radeon_bld.gallivm.context);
	ctx->i32 = LLVMInt32TypeInContext(ctx->radeon_bld.gallivm.context);
	ctx->i64 = LLVMInt64TypeInContext(ctx->radeon_bld.gallivm.context);
	ctx->i128 = LLVMIntTypeInContext(ctx->radeon_bld.gallivm.context, 128);
	ctx->f32 = LLVMFloatTypeInContext(ctx->radeon_bld.gallivm.context);
	ctx->v16i8 = LLVMVectorType(ctx->i8, 16);
	ctx->v2i32 = LLVMVectorType(ctx->i32, 2);
	ctx->v4i32 = LLVMVectorType(ctx->i32, 4);
	ctx->v4f32 = LLVMVectorType(ctx->f32, 4);
	ctx->v8i32 = LLVMVectorType(ctx->i32, 8);

	bld_base = &ctx->radeon_bld.soa.bld_base;
	if (shader && shader->selector)
		bld_base->info = &shader->selector->info;
d4086 1
a4086 1
	bld_base->op_actions[TGSI_OPCODE_TXQ] = tex_action;
a4088 1
	bld_base->op_actions[TGSI_OPCODE_TXQS].emit = si_llvm_emit_txqs;
d4099 5
a4103 25
	bld_base->op_actions[TGSI_OPCODE_MAX].emit = build_tgsi_intrinsic_nomem;
	bld_base->op_actions[TGSI_OPCODE_MAX].intr_name = "llvm.maxnum.f32";
	bld_base->op_actions[TGSI_OPCODE_MIN].emit = build_tgsi_intrinsic_nomem;
	bld_base->op_actions[TGSI_OPCODE_MIN].intr_name = "llvm.minnum.f32";
}

int si_compile_tgsi_shader(struct si_screen *sscreen,
			   LLVMTargetMachineRef tm,
			   struct si_shader *shader,
			   bool is_monolithic,
			   struct pipe_debug_callback *debug)
{
	struct si_shader_selector *sel = shader->selector;
	struct si_shader_context ctx;
	struct lp_build_tgsi_context *bld_base;
	LLVMModuleRef mod;
	int r = 0;

	/* Dump TGSI code before doing TGSI->LLVM conversion in case the
	 * conversion fails. */
	if (r600_can_dump_shader(&sscreen->b, sel->info.processor) &&
	    !(sscreen->b.debug_flags & DBG_NO_TGSI)) {
		si_dump_shader_key(sel->type, &shader->key, stderr);
		tgsi_dump(sel->tokens, 0);
		si_dump_streamout(&sel->so);
d4106 5
a4110 7
	si_init_shader_ctx(&ctx, sscreen, shader, tm);
	ctx.is_monolithic = is_monolithic;

	shader->info.uses_instanceid = sel->info.uses_instanceid;

	bld_base = &ctx.radeon_bld.soa.bld_base;
	ctx.radeon_bld.load_system_value = declare_system_value;
d4112 1
a4112 1
	switch (ctx.type) {
d4114 1
a4114 1
		ctx.radeon_bld.load_input = declare_input_vs;
d4140 13
a4152 5
		ctx.radeon_bld.load_input = declare_input_fs;
		if (is_monolithic)
			bld_base->emit_epilogue = si_llvm_emit_fs_epilogue;
		else
			bld_base->emit_epilogue = si_llvm_return_fs_outputs;
d4159 6
a4164 14
	create_meta_data(&ctx);
	create_function(&ctx);
	preload_constants(&ctx);
	preload_samplers(&ctx);
	preload_streamout_buffers(&ctx);
	preload_ring_buffers(&ctx);

	if (ctx.is_monolithic && sel->type == PIPE_SHADER_FRAGMENT &&
	    shader->key.ps.prolog.poly_stipple) {
		LLVMValueRef views = LLVMGetParam(ctx.radeon_bld.main_fn,
						  SI_PARAM_SAMPLERS);
		si_llvm_emit_polygon_stipple(&ctx, views,
					     SI_PARAM_POS_FIXED_PT);
	}
d4166 1
a4166 1
	if (ctx.type == TGSI_PROCESSOR_GEOMETRY) {
d4169 1
a4169 1
			ctx.gs_next_vertex[i] =
d4171 1
a4171 1
						ctx.i32, "");
d4175 1
a4175 1
	if (!lp_build_tgsi_llvm(bld_base, sel->tokens)) {
d4180 2
a4181 1
	LLVMBuildRet(bld_base->base.gallivm->builder, ctx.return_value);
d4183 1
a4183 10

	/* Dump LLVM IR before any optimization passes */
	if (sscreen->b.debug_flags & DBG_PREOPT_IR &&
	    r600_can_dump_shader(&sscreen->b, ctx.type))
		LLVMDumpModule(mod);

	radeon_llvm_finalize_module(&ctx.radeon_bld);

	r = si_compile_llvm(sscreen, &shader->binary, &shader->config, tm,
			    mod, debug, ctx.type, "TGSI shader");
d4189 1
a4189 42
	radeon_llvm_dispose(&ctx.radeon_bld);

	/* Calculate the number of fragment input VGPRs. */
	if (ctx.type == TGSI_PROCESSOR_FRAGMENT) {
		shader->info.num_input_vgprs = 0;
		shader->info.face_vgpr_index = -1;

		if (G_0286CC_PERSP_SAMPLE_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 2;
		if (G_0286CC_PERSP_CENTER_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 2;
		if (G_0286CC_PERSP_CENTROID_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 2;
		if (G_0286CC_PERSP_PULL_MODEL_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 3;
		if (G_0286CC_LINEAR_SAMPLE_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 2;
		if (G_0286CC_LINEAR_CENTER_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 2;
		if (G_0286CC_LINEAR_CENTROID_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 2;
		if (G_0286CC_LINE_STIPPLE_TEX_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_POS_X_FLOAT_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_POS_Y_FLOAT_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_POS_Z_FLOAT_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_POS_W_FLOAT_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_FRONT_FACE_ENA(shader->config.spi_ps_input_addr)) {
			shader->info.face_vgpr_index = shader->info.num_input_vgprs;
			shader->info.num_input_vgprs += 1;
		}
		if (G_0286CC_ANCILLARY_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_SAMPLE_COVERAGE_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
		if (G_0286CC_POS_FIXED_PT_ENA(shader->config.spi_ps_input_addr))
			shader->info.num_input_vgprs += 1;
	}
d4191 1
a4191 1
	if (ctx.type == TGSI_PROCESSOR_GEOMETRY) {
d4194 4
a4197 3
		ctx.shader = shader->gs_copy_shader;
		if ((r = si_generate_gs_copy_shader(sscreen, &ctx,
						    shader, debug))) {
d4206 3
a4208 1
		FREE(ctx.constants[i]);
d4212 1
a4212 960
/**
 * Create, compile and return a shader part (prolog or epilog).
 *
 * \param sscreen	screen
 * \param list		list of shader parts of the same category
 * \param key		shader part key
 * \param tm		LLVM target machine
 * \param debug		debug callback
 * \param compile	the callback responsible for compilation
 * \return		non-NULL on success
 */
static struct si_shader_part *
si_get_shader_part(struct si_screen *sscreen,
		   struct si_shader_part **list,
		   union si_shader_part_key *key,
		   LLVMTargetMachineRef tm,
		   struct pipe_debug_callback *debug,
		   bool (*compile)(struct si_screen *,
				   LLVMTargetMachineRef,
				   struct pipe_debug_callback *,
				   struct si_shader_part *))
{
	struct si_shader_part *result;

	pipe_mutex_lock(sscreen->shader_parts_mutex);

	/* Find existing. */
	for (result = *list; result; result = result->next) {
		if (memcmp(&result->key, key, sizeof(*key)) == 0) {
			pipe_mutex_unlock(sscreen->shader_parts_mutex);
			return result;
		}
	}

	/* Compile a new one. */
	result = CALLOC_STRUCT(si_shader_part);
	result->key = *key;
	if (!compile(sscreen, tm, debug, result)) {
		FREE(result);
		pipe_mutex_unlock(sscreen->shader_parts_mutex);
		return NULL;
	}

	result->next = *list;
	*list = result;
	pipe_mutex_unlock(sscreen->shader_parts_mutex);
	return result;
}

/**
 * Create a vertex shader prolog.
 *
 * The inputs are the same as VS (a lot of SGPRs and 4 VGPR system values).
 * All inputs are returned unmodified. The vertex load indices are
 * stored after them, which will used by the API VS for fetching inputs.
 *
 * For example, the expected outputs for instance_divisors[] = {0, 1, 2} are:
 *   input_v0,
 *   input_v1,
 *   input_v2,
 *   input_v3,
 *   (VertexID + BaseVertex),
 *   (InstanceID + StartInstance),
 *   (InstanceID / 2 + StartInstance)
 */
static bool si_compile_vs_prolog(struct si_screen *sscreen,
				 LLVMTargetMachineRef tm,
				 struct pipe_debug_callback *debug,
				 struct si_shader_part *out)
{
	union si_shader_part_key *key = &out->key;
	struct si_shader shader = {};
	struct si_shader_context ctx;
	struct gallivm_state *gallivm = &ctx.radeon_bld.gallivm;
	LLVMTypeRef *params, *returns;
	LLVMValueRef ret, func;
	int last_sgpr, num_params, num_returns, i;
	bool status = true;

	si_init_shader_ctx(&ctx, sscreen, &shader, tm);
	ctx.type = TGSI_PROCESSOR_VERTEX;
	ctx.param_vertex_id = key->vs_prolog.num_input_sgprs;
	ctx.param_instance_id = key->vs_prolog.num_input_sgprs + 3;

	/* 4 preloaded VGPRs + vertex load indices as prolog outputs */
	params = alloca((key->vs_prolog.num_input_sgprs + 4) *
			sizeof(LLVMTypeRef));
	returns = alloca((key->vs_prolog.num_input_sgprs + 4 +
			  key->vs_prolog.last_input + 1) *
			 sizeof(LLVMTypeRef));
	num_params = 0;
	num_returns = 0;

	/* Declare input and output SGPRs. */
	num_params = 0;
	for (i = 0; i < key->vs_prolog.num_input_sgprs; i++) {
		params[num_params++] = ctx.i32;
		returns[num_returns++] = ctx.i32;
	}
	last_sgpr = num_params - 1;

	/* 4 preloaded VGPRs (outputs must be floats) */
	for (i = 0; i < 4; i++) {
		params[num_params++] = ctx.i32;
		returns[num_returns++] = ctx.f32;
	}

	/* Vertex load indices. */
	for (i = 0; i <= key->vs_prolog.last_input; i++)
		returns[num_returns++] = ctx.f32;

	/* Create the function. */
	si_create_function(&ctx, returns, num_returns, params,
			   num_params, -1, last_sgpr);
	func = ctx.radeon_bld.main_fn;

	/* Copy inputs to outputs. This should be no-op, as the registers match,
	 * but it will prevent the compiler from overwriting them unintentionally.
	 */
	ret = ctx.return_value;
	for (i = 0; i < key->vs_prolog.num_input_sgprs; i++) {
		LLVMValueRef p = LLVMGetParam(func, i);
		ret = LLVMBuildInsertValue(gallivm->builder, ret, p, i, "");
	}
	for (i = num_params - 4; i < num_params; i++) {
		LLVMValueRef p = LLVMGetParam(func, i);
		p = LLVMBuildBitCast(gallivm->builder, p, ctx.f32, "");
		ret = LLVMBuildInsertValue(gallivm->builder, ret, p, i, "");
	}

	/* Compute vertex load indices from instance divisors. */
	for (i = 0; i <= key->vs_prolog.last_input; i++) {
		unsigned divisor = key->vs_prolog.states.instance_divisors[i];
		LLVMValueRef index;

		if (divisor) {
			/* InstanceID / Divisor + StartInstance */
			index = get_instance_index_for_fetch(&ctx.radeon_bld,
							     SI_SGPR_START_INSTANCE,
							     divisor);
		} else {
			/* VertexID + BaseVertex */
			index = LLVMBuildAdd(gallivm->builder,
					     LLVMGetParam(func, ctx.param_vertex_id),
					     LLVMGetParam(func, SI_SGPR_BASE_VERTEX), "");
		}

		index = LLVMBuildBitCast(gallivm->builder, index, ctx.f32, "");
		ret = LLVMBuildInsertValue(gallivm->builder, ret, index,
					   num_params++, "");
	}

	/* Compile. */
	LLVMBuildRet(gallivm->builder, ret);
	radeon_llvm_finalize_module(&ctx.radeon_bld);

	if (si_compile_llvm(sscreen, &out->binary, &out->config, tm,
			    gallivm->module, debug, ctx.type,
			    "Vertex Shader Prolog"))
		status = false;

	radeon_llvm_dispose(&ctx.radeon_bld);
	return status;
}

/**
 * Compile the vertex shader epilog. This is also used by the tessellation
 * evaluation shader compiled as VS.
 *
 * The input is PrimitiveID.
 *
 * If PrimitiveID is required by the pixel shader, export it.
 * Otherwise, do nothing.
 */
static bool si_compile_vs_epilog(struct si_screen *sscreen,
				 LLVMTargetMachineRef tm,
				 struct pipe_debug_callback *debug,
				 struct si_shader_part *out)
{
	union si_shader_part_key *key = &out->key;
	struct si_shader_context ctx;
	struct gallivm_state *gallivm = &ctx.radeon_bld.gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx.radeon_bld.soa.bld_base;
	LLVMTypeRef params[5];
	int num_params, i;
	bool status = true;

	si_init_shader_ctx(&ctx, sscreen, NULL, tm);
	ctx.type = TGSI_PROCESSOR_VERTEX;

	/* Declare input VGPRs. */
	num_params = key->vs_epilog.states.export_prim_id ?
			   (VS_EPILOG_PRIMID_LOC + 1) : 0;
	assert(num_params <= ARRAY_SIZE(params));

	for (i = 0; i < num_params; i++)
		params[i] = ctx.f32;

	/* Create the function. */
	si_create_function(&ctx, NULL, 0, params, num_params,
			   -1, -1);

	/* Emit exports. */
	if (key->vs_epilog.states.export_prim_id) {
		struct lp_build_context *base = &bld_base->base;
		struct lp_build_context *uint = &bld_base->uint_bld;
		LLVMValueRef args[9];

		args[0] = lp_build_const_int32(base->gallivm, 0x0); /* enabled channels */
		args[1] = uint->zero; /* whether the EXEC mask is valid */
		args[2] = uint->zero; /* DONE bit */
		args[3] = lp_build_const_int32(base->gallivm, V_008DFC_SQ_EXP_PARAM +
					       key->vs_epilog.prim_id_param_offset);
		args[4] = uint->zero; /* COMPR flag (0 = 32-bit export) */
		args[5] = LLVMGetParam(ctx.radeon_bld.main_fn,
				       VS_EPILOG_PRIMID_LOC); /* X */
		args[6] = uint->undef; /* Y */
		args[7] = uint->undef; /* Z */
		args[8] = uint->undef; /* W */

		lp_build_intrinsic(base->gallivm->builder, "llvm.SI.export",
				   LLVMVoidTypeInContext(base->gallivm->context),
				   args, 9, 0);
	}

	/* Compile. */
	LLVMBuildRet(gallivm->builder, ctx.return_value);
	radeon_llvm_finalize_module(&ctx.radeon_bld);

	if (si_compile_llvm(sscreen, &out->binary, &out->config, tm,
			    gallivm->module, debug, ctx.type,
			    "Vertex Shader Epilog"))
		status = false;

	radeon_llvm_dispose(&ctx.radeon_bld);
	return status;
}

/**
 * Create & compile a vertex shader epilog. This a helper used by VS and TES.
 */
static bool si_get_vs_epilog(struct si_screen *sscreen,
			     LLVMTargetMachineRef tm,
		             struct si_shader *shader,
		             struct pipe_debug_callback *debug,
			     struct si_vs_epilog_bits *states)
{
	union si_shader_part_key epilog_key;

	memset(&epilog_key, 0, sizeof(epilog_key));
	epilog_key.vs_epilog.states = *states;

	/* Set up the PrimitiveID output. */
	if (shader->key.vs.epilog.export_prim_id) {
		unsigned index = shader->selector->info.num_outputs;
		unsigned offset = shader->info.nr_param_exports++;

		epilog_key.vs_epilog.prim_id_param_offset = offset;
		assert(index < ARRAY_SIZE(shader->info.vs_output_param_offset));
		shader->info.vs_output_param_offset[index] = offset;
	}

	shader->epilog = si_get_shader_part(sscreen, &sscreen->vs_epilogs,
					    &epilog_key, tm, debug,
					    si_compile_vs_epilog);
	return shader->epilog != NULL;
}

/**
 * Select and compile (or reuse) vertex shader parts (prolog & epilog).
 */
static bool si_shader_select_vs_parts(struct si_screen *sscreen,
				      LLVMTargetMachineRef tm,
				      struct si_shader *shader,
				      struct pipe_debug_callback *debug)
{
	struct tgsi_shader_info *info = &shader->selector->info;
	union si_shader_part_key prolog_key;
	unsigned i;

	/* Get the prolog. */
	memset(&prolog_key, 0, sizeof(prolog_key));
	prolog_key.vs_prolog.states = shader->key.vs.prolog;
	prolog_key.vs_prolog.num_input_sgprs = shader->info.num_input_sgprs;
	prolog_key.vs_prolog.last_input = MAX2(1, info->num_inputs) - 1;

	/* The prolog is a no-op if there are no inputs. */
	if (info->num_inputs) {
		shader->prolog =
			si_get_shader_part(sscreen, &sscreen->vs_prologs,
					   &prolog_key, tm, debug,
					   si_compile_vs_prolog);
		if (!shader->prolog)
			return false;
	}

	/* Get the epilog. */
	if (!shader->key.vs.as_es && !shader->key.vs.as_ls &&
	    !si_get_vs_epilog(sscreen, tm, shader, debug,
			      &shader->key.vs.epilog))
		return false;

	/* Set the instanceID flag. */
	for (i = 0; i < info->num_inputs; i++)
		if (prolog_key.vs_prolog.states.instance_divisors[i])
			shader->info.uses_instanceid = true;

	return true;
}

/**
 * Select and compile (or reuse) TES parts (epilog).
 */
static bool si_shader_select_tes_parts(struct si_screen *sscreen,
				       LLVMTargetMachineRef tm,
				       struct si_shader *shader,
				       struct pipe_debug_callback *debug)
{
	if (shader->key.tes.as_es)
		return true;

	/* TES compiled as VS. */
	return si_get_vs_epilog(sscreen, tm, shader, debug,
				&shader->key.tes.epilog);
}

/**
 * Compile the TCS epilog. This writes tesselation factors to memory based on
 * the output primitive type of the tesselator (determined by TES).
 */
static bool si_compile_tcs_epilog(struct si_screen *sscreen,
				  LLVMTargetMachineRef tm,
				  struct pipe_debug_callback *debug,
				  struct si_shader_part *out)
{
	union si_shader_part_key *key = &out->key;
	struct si_shader shader = {};
	struct si_shader_context ctx;
	struct gallivm_state *gallivm = &ctx.radeon_bld.gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx.radeon_bld.soa.bld_base;
	LLVMTypeRef params[16];
	LLVMValueRef func;
	int last_array_pointer, last_sgpr, num_params;
	bool status = true;

	si_init_shader_ctx(&ctx, sscreen, &shader, tm);
	ctx.type = TGSI_PROCESSOR_TESS_CTRL;
	shader.key.tcs.epilog = key->tcs_epilog.states;

	/* Declare inputs. Only RW_BUFFERS and TESS_FACTOR_OFFSET are used. */
	params[SI_PARAM_RW_BUFFERS] = const_array(ctx.v16i8, SI_NUM_RW_BUFFERS);
	last_array_pointer = SI_PARAM_RW_BUFFERS;
	params[SI_PARAM_CONST_BUFFERS] = ctx.i64;
	params[SI_PARAM_SAMPLERS] = ctx.i64;
	params[SI_PARAM_UNUSED] = ctx.i64;
	params[SI_PARAM_TCS_OUT_OFFSETS] = ctx.i32;
	params[SI_PARAM_TCS_OUT_LAYOUT] = ctx.i32;
	params[SI_PARAM_TCS_IN_LAYOUT] = ctx.i32;
	params[SI_PARAM_TESS_FACTOR_OFFSET] = ctx.i32;
	last_sgpr = SI_PARAM_TESS_FACTOR_OFFSET;
	num_params = last_sgpr + 1;

	params[num_params++] = ctx.i32; /* patch index within the wave (REL_PATCH_ID) */
	params[num_params++] = ctx.i32; /* invocation ID within the patch */
	params[num_params++] = ctx.i32; /* LDS offset where tess factors should be loaded from */

	/* Create the function. */
	si_create_function(&ctx, NULL, 0, params, num_params,
			   last_array_pointer, last_sgpr);
	declare_tess_lds(&ctx);
	func = ctx.radeon_bld.main_fn;

	si_write_tess_factors(bld_base,
			      LLVMGetParam(func, last_sgpr + 1),
			      LLVMGetParam(func, last_sgpr + 2),
			      LLVMGetParam(func, last_sgpr + 3));

	/* Compile. */
	LLVMBuildRet(gallivm->builder, ctx.return_value);
	radeon_llvm_finalize_module(&ctx.radeon_bld);

	if (si_compile_llvm(sscreen, &out->binary, &out->config, tm,
			    gallivm->module, debug, ctx.type,
			    "Tessellation Control Shader Epilog"))
		status = false;

	radeon_llvm_dispose(&ctx.radeon_bld);
	return status;
}

/**
 * Select and compile (or reuse) TCS parts (epilog).
 */
static bool si_shader_select_tcs_parts(struct si_screen *sscreen,
				       LLVMTargetMachineRef tm,
				       struct si_shader *shader,
				       struct pipe_debug_callback *debug)
{
	union si_shader_part_key epilog_key;

	/* Get the epilog. */
	memset(&epilog_key, 0, sizeof(epilog_key));
	epilog_key.tcs_epilog.states = shader->key.tcs.epilog;

	shader->epilog = si_get_shader_part(sscreen, &sscreen->tcs_epilogs,
					    &epilog_key, tm, debug,
					    si_compile_tcs_epilog);
	return shader->epilog != NULL;
}

/**
 * Compile the pixel shader prolog. This handles:
 * - two-side color selection and interpolation
 * - overriding interpolation parameters for the API PS
 * - polygon stippling
 *
 * All preloaded SGPRs and VGPRs are passed through unmodified unless they are
 * overriden by other states. (e.g. per-sample interpolation)
 * Interpolated colors are stored after the preloaded VGPRs.
 */
static bool si_compile_ps_prolog(struct si_screen *sscreen,
				 LLVMTargetMachineRef tm,
				 struct pipe_debug_callback *debug,
				 struct si_shader_part *out)
{
	union si_shader_part_key *key = &out->key;
	struct si_shader shader = {};
	struct si_shader_context ctx;
	struct gallivm_state *gallivm = &ctx.radeon_bld.gallivm;
	LLVMTypeRef *params;
	LLVMValueRef ret, func;
	int last_sgpr, num_params, num_returns, i, num_color_channels;
	bool status = true;

	si_init_shader_ctx(&ctx, sscreen, &shader, tm);
	ctx.type = TGSI_PROCESSOR_FRAGMENT;
	shader.key.ps.prolog = key->ps_prolog.states;

	/* Number of inputs + 8 color elements. */
	params = alloca((key->ps_prolog.num_input_sgprs +
			 key->ps_prolog.num_input_vgprs + 8) *
			sizeof(LLVMTypeRef));

	/* Declare inputs. */
	num_params = 0;
	for (i = 0; i < key->ps_prolog.num_input_sgprs; i++)
		params[num_params++] = ctx.i32;
	last_sgpr = num_params - 1;

	for (i = 0; i < key->ps_prolog.num_input_vgprs; i++)
		params[num_params++] = ctx.f32;

	/* Declare outputs (same as inputs + add colors if needed) */
	num_returns = num_params;
	num_color_channels = util_bitcount(key->ps_prolog.colors_read);
	for (i = 0; i < num_color_channels; i++)
		params[num_returns++] = ctx.f32;

	/* Create the function. */
	si_create_function(&ctx, params, num_returns, params,
			   num_params, -1, last_sgpr);
	func = ctx.radeon_bld.main_fn;

	/* Copy inputs to outputs. This should be no-op, as the registers match,
	 * but it will prevent the compiler from overwriting them unintentionally.
	 */
	ret = ctx.return_value;
	for (i = 0; i < num_params; i++) {
		LLVMValueRef p = LLVMGetParam(func, i);
		ret = LLVMBuildInsertValue(gallivm->builder, ret, p, i, "");
	}

	/* Polygon stippling. */
	if (key->ps_prolog.states.poly_stipple) {
		/* POS_FIXED_PT is always last. */
		unsigned pos = key->ps_prolog.num_input_sgprs +
			       key->ps_prolog.num_input_vgprs - 1;
		LLVMValueRef ptr[2], views;

		/* Get the pointer to sampler views. */
		ptr[0] = LLVMGetParam(func, SI_SGPR_SAMPLERS);
		ptr[1] = LLVMGetParam(func, SI_SGPR_SAMPLERS+1);
		views = lp_build_gather_values(gallivm, ptr, 2);
		views = LLVMBuildBitCast(gallivm->builder, views, ctx.i64, "");
		views = LLVMBuildIntToPtr(gallivm->builder, views,
					  const_array(ctx.v8i32, SI_NUM_SAMPLERS), "");

		si_llvm_emit_polygon_stipple(&ctx, views, pos);
	}

	/* Interpolate colors. */
	for (i = 0; i < 2; i++) {
		unsigned writemask = (key->ps_prolog.colors_read >> (i * 4)) & 0xf;
		unsigned face_vgpr = key->ps_prolog.num_input_sgprs +
				     key->ps_prolog.face_vgpr_index;
		LLVMValueRef interp[2], color[4];
		LLVMValueRef interp_ij = NULL, prim_mask = NULL, face = NULL;

		if (!writemask)
			continue;

		/* If the interpolation qualifier is not CONSTANT (-1). */
		if (key->ps_prolog.color_interp_vgpr_index[i] != -1) {
			unsigned interp_vgpr = key->ps_prolog.num_input_sgprs +
					       key->ps_prolog.color_interp_vgpr_index[i];

			interp[0] = LLVMGetParam(func, interp_vgpr);
			interp[1] = LLVMGetParam(func, interp_vgpr + 1);
			interp_ij = lp_build_gather_values(gallivm, interp, 2);
			interp_ij = LLVMBuildBitCast(gallivm->builder, interp_ij,
						     ctx.v2i32, "");
		}

		/* Use the absolute location of the input. */
		prim_mask = LLVMGetParam(func, SI_PS_NUM_USER_SGPR);

		if (key->ps_prolog.states.color_two_side) {
			face = LLVMGetParam(func, face_vgpr);
			face = LLVMBuildBitCast(gallivm->builder, face, ctx.i32, "");
		}

		interp_fs_input(&ctx,
				key->ps_prolog.color_attr_index[i],
				TGSI_SEMANTIC_COLOR, i,
				key->ps_prolog.num_interp_inputs,
				key->ps_prolog.colors_read, interp_ij,
				prim_mask, face, color);

		while (writemask) {
			unsigned chan = u_bit_scan(&writemask);
			ret = LLVMBuildInsertValue(gallivm->builder, ret, color[chan],
						   num_params++, "");
		}
	}

	/* Force per-sample interpolation. */
	if (key->ps_prolog.states.force_persample_interp) {
		unsigned i, base = key->ps_prolog.num_input_sgprs;
		LLVMValueRef persp_sample[2], linear_sample[2];

		/* Read PERSP_SAMPLE. */
		for (i = 0; i < 2; i++)
			persp_sample[i] = LLVMGetParam(func, base + i);
		/* Overwrite PERSP_CENTER. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   persp_sample[i], base + 2 + i, "");
		/* Overwrite PERSP_CENTROID. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   persp_sample[i], base + 4 + i, "");
		/* Read LINEAR_SAMPLE. */
		for (i = 0; i < 2; i++)
			linear_sample[i] = LLVMGetParam(func, base + 6 + i);
		/* Overwrite LINEAR_CENTER. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   linear_sample[i], base + 8 + i, "");
		/* Overwrite LINEAR_CENTROID. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   linear_sample[i], base + 10 + i, "");
	}

	/* Compile. */
	LLVMBuildRet(gallivm->builder, ret);
	radeon_llvm_finalize_module(&ctx.radeon_bld);

	if (si_compile_llvm(sscreen, &out->binary, &out->config, tm,
			    gallivm->module, debug, ctx.type,
			    "Fragment Shader Prolog"))
		status = false;

	radeon_llvm_dispose(&ctx.radeon_bld);
	return status;
}

/**
 * Compile the pixel shader epilog. This handles everything that must be
 * emulated for pixel shader exports. (alpha-test, format conversions, etc)
 */
static bool si_compile_ps_epilog(struct si_screen *sscreen,
				 LLVMTargetMachineRef tm,
				 struct pipe_debug_callback *debug,
				 struct si_shader_part *out)
{
	union si_shader_part_key *key = &out->key;
	struct si_shader shader = {};
	struct si_shader_context ctx;
	struct gallivm_state *gallivm = &ctx.radeon_bld.gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx.radeon_bld.soa.bld_base;
	LLVMTypeRef params[16+8*4+3];
	LLVMValueRef depth = NULL, stencil = NULL, samplemask = NULL;
	int last_array_pointer, last_sgpr, num_params, i;
	bool status = true;

	si_init_shader_ctx(&ctx, sscreen, &shader, tm);
	ctx.type = TGSI_PROCESSOR_FRAGMENT;
	shader.key.ps.epilog = key->ps_epilog.states;

	/* Declare input SGPRs. */
	params[SI_PARAM_RW_BUFFERS] = ctx.i64;
	params[SI_PARAM_CONST_BUFFERS] = ctx.i64;
	params[SI_PARAM_SAMPLERS] = ctx.i64;
	params[SI_PARAM_UNUSED] = ctx.i64;
	params[SI_PARAM_ALPHA_REF] = ctx.f32;
	last_array_pointer = -1;
	last_sgpr = SI_PARAM_ALPHA_REF;

	/* Declare input VGPRs. */
	num_params = (last_sgpr + 1) +
		     util_bitcount(key->ps_epilog.colors_written) * 4 +
		     key->ps_epilog.writes_z +
		     key->ps_epilog.writes_stencil +
		     key->ps_epilog.writes_samplemask;

	num_params = MAX2(num_params,
			  last_sgpr + 1 + PS_EPILOG_SAMPLEMASK_MIN_LOC + 1);

	assert(num_params <= ARRAY_SIZE(params));

	for (i = last_sgpr + 1; i < num_params; i++)
		params[i] = ctx.f32;

	/* Create the function. */
	si_create_function(&ctx, NULL, 0, params, num_params,
			   last_array_pointer, last_sgpr);
	/* Disable elimination of unused inputs. */
	radeon_llvm_add_attribute(ctx.radeon_bld.main_fn,
				  "InitialPSInputAddr", 0xffffff);

	/* Process colors. */
	unsigned vgpr = last_sgpr + 1;
	unsigned colors_written = key->ps_epilog.colors_written;
	int last_color_export = -1;

	/* Find the last color export. */
	if (!key->ps_epilog.writes_z &&
	    !key->ps_epilog.writes_stencil &&
	    !key->ps_epilog.writes_samplemask) {
		unsigned spi_format = key->ps_epilog.states.spi_shader_col_format;

		/* If last_cbuf > 0, FS_COLOR0_WRITES_ALL_CBUFS is true. */
		if (colors_written == 0x1 && key->ps_epilog.states.last_cbuf > 0) {
			/* Just set this if any of the colorbuffers are enabled. */
			if (spi_format &
			    ((1llu << (4 * (key->ps_epilog.states.last_cbuf + 1))) - 1))
				last_color_export = 0;
		} else {
			for (i = 0; i < 8; i++)
				if (colors_written & (1 << i) &&
				    (spi_format >> (i * 4)) & 0xf)
					last_color_export = i;
		}
	}

	while (colors_written) {
		LLVMValueRef color[4];
		int mrt = u_bit_scan(&colors_written);

		for (i = 0; i < 4; i++)
			color[i] = LLVMGetParam(ctx.radeon_bld.main_fn, vgpr++);

		si_export_mrt_color(bld_base, color, mrt,
				    num_params - 1,
				    mrt == last_color_export);
	}

	/* Process depth, stencil, samplemask. */
	if (key->ps_epilog.writes_z)
		depth = LLVMGetParam(ctx.radeon_bld.main_fn, vgpr++);
	if (key->ps_epilog.writes_stencil)
		stencil = LLVMGetParam(ctx.radeon_bld.main_fn, vgpr++);
	if (key->ps_epilog.writes_samplemask)
		samplemask = LLVMGetParam(ctx.radeon_bld.main_fn, vgpr++);

	if (depth || stencil || samplemask)
		si_export_mrt_z(bld_base, depth, stencil, samplemask);
	else if (last_color_export == -1)
		si_export_null(bld_base);

	/* Compile. */
	LLVMBuildRetVoid(gallivm->builder);
	radeon_llvm_finalize_module(&ctx.radeon_bld);

	if (si_compile_llvm(sscreen, &out->binary, &out->config, tm,
			    gallivm->module, debug, ctx.type,
			    "Fragment Shader Epilog"))
		status = false;

	radeon_llvm_dispose(&ctx.radeon_bld);
	return status;
}

/**
 * Select and compile (or reuse) pixel shader parts (prolog & epilog).
 */
static bool si_shader_select_ps_parts(struct si_screen *sscreen,
				      LLVMTargetMachineRef tm,
				      struct si_shader *shader,
				      struct pipe_debug_callback *debug)
{
	struct tgsi_shader_info *info = &shader->selector->info;
	union si_shader_part_key prolog_key;
	union si_shader_part_key epilog_key;
	unsigned i;

	/* Get the prolog. */
	memset(&prolog_key, 0, sizeof(prolog_key));
	prolog_key.ps_prolog.states = shader->key.ps.prolog;
	prolog_key.ps_prolog.colors_read = info->colors_read;
	prolog_key.ps_prolog.num_input_sgprs = shader->info.num_input_sgprs;
	prolog_key.ps_prolog.num_input_vgprs = shader->info.num_input_vgprs;

	if (info->colors_read) {
		unsigned *color = shader->selector->color_attr_index;

		if (shader->key.ps.prolog.color_two_side) {
			/* BCOLORs are stored after the last input. */
			prolog_key.ps_prolog.num_interp_inputs = info->num_inputs;
			prolog_key.ps_prolog.face_vgpr_index = shader->info.face_vgpr_index;
			shader->config.spi_ps_input_ena |= S_0286CC_FRONT_FACE_ENA(1);
		}

		for (i = 0; i < 2; i++) {
			unsigned location = info->input_interpolate_loc[color[i]];

			if (!(info->colors_read & (0xf << i*4)))
				continue;

			prolog_key.ps_prolog.color_attr_index[i] = color[i];

			/* Force per-sample interpolation for the colors here. */
			if (shader->key.ps.prolog.force_persample_interp)
				location = TGSI_INTERPOLATE_LOC_SAMPLE;

			switch (info->input_interpolate[color[i]]) {
			case TGSI_INTERPOLATE_CONSTANT:
				prolog_key.ps_prolog.color_interp_vgpr_index[i] = -1;
				break;
			case TGSI_INTERPOLATE_PERSPECTIVE:
			case TGSI_INTERPOLATE_COLOR:
				switch (location) {
				case TGSI_INTERPOLATE_LOC_SAMPLE:
					prolog_key.ps_prolog.color_interp_vgpr_index[i] = 0;
					shader->config.spi_ps_input_ena |=
						S_0286CC_PERSP_SAMPLE_ENA(1);
					break;
				case TGSI_INTERPOLATE_LOC_CENTER:
					prolog_key.ps_prolog.color_interp_vgpr_index[i] = 2;
					shader->config.spi_ps_input_ena |=
						S_0286CC_PERSP_CENTER_ENA(1);
					break;
				case TGSI_INTERPOLATE_LOC_CENTROID:
					prolog_key.ps_prolog.color_interp_vgpr_index[i] = 4;
					shader->config.spi_ps_input_ena |=
						S_0286CC_PERSP_CENTROID_ENA(1);
					break;
				default:
					assert(0);
				}
				break;
			case TGSI_INTERPOLATE_LINEAR:
				switch (location) {
				case TGSI_INTERPOLATE_LOC_SAMPLE:
					prolog_key.ps_prolog.color_interp_vgpr_index[i] = 6;
					shader->config.spi_ps_input_ena |=
						S_0286CC_LINEAR_SAMPLE_ENA(1);
					break;
				case TGSI_INTERPOLATE_LOC_CENTER:
					prolog_key.ps_prolog.color_interp_vgpr_index[i] = 8;
					shader->config.spi_ps_input_ena |=
						S_0286CC_LINEAR_CENTER_ENA(1);
					break;
				case TGSI_INTERPOLATE_LOC_CENTROID:
					prolog_key.ps_prolog.color_interp_vgpr_index[i] = 10;
					shader->config.spi_ps_input_ena |=
						S_0286CC_LINEAR_CENTROID_ENA(1);
					break;
				default:
					assert(0);
				}
				break;
			default:
				assert(0);
			}
		}
	}

	/* The prolog is a no-op if these aren't set. */
	if (prolog_key.ps_prolog.colors_read ||
	    prolog_key.ps_prolog.states.force_persample_interp ||
	    prolog_key.ps_prolog.states.poly_stipple) {
		shader->prolog =
			si_get_shader_part(sscreen, &sscreen->ps_prologs,
					   &prolog_key, tm, debug,
					   si_compile_ps_prolog);
		if (!shader->prolog)
			return false;
	}

	/* Get the epilog. */
	memset(&epilog_key, 0, sizeof(epilog_key));
	epilog_key.ps_epilog.colors_written = info->colors_written;
	epilog_key.ps_epilog.writes_z = info->writes_z;
	epilog_key.ps_epilog.writes_stencil = info->writes_stencil;
	epilog_key.ps_epilog.writes_samplemask = info->writes_samplemask;
	epilog_key.ps_epilog.states = shader->key.ps.epilog;

	shader->epilog =
		si_get_shader_part(sscreen, &sscreen->ps_epilogs,
				   &epilog_key, tm, debug,
				   si_compile_ps_epilog);
	if (!shader->epilog)
		return false;

	/* Enable POS_FIXED_PT if polygon stippling is enabled. */
	if (shader->key.ps.prolog.poly_stipple) {
		shader->config.spi_ps_input_ena |= S_0286CC_POS_FIXED_PT_ENA(1);
		assert(G_0286CC_POS_FIXED_PT_ENA(shader->config.spi_ps_input_addr));
	}

	/* Set up the enable bits for per-sample shading if needed. */
	if (shader->key.ps.prolog.force_persample_interp) {
		if (G_0286CC_PERSP_CENTER_ENA(shader->config.spi_ps_input_ena) ||
		    G_0286CC_PERSP_CENTROID_ENA(shader->config.spi_ps_input_ena)) {
			shader->config.spi_ps_input_ena &= C_0286CC_PERSP_CENTER_ENA;
			shader->config.spi_ps_input_ena &= C_0286CC_PERSP_CENTROID_ENA;
			shader->config.spi_ps_input_ena |= S_0286CC_PERSP_SAMPLE_ENA(1);
		}
		if (G_0286CC_LINEAR_CENTER_ENA(shader->config.spi_ps_input_ena) ||
		    G_0286CC_LINEAR_CENTROID_ENA(shader->config.spi_ps_input_ena)) {
			shader->config.spi_ps_input_ena &= C_0286CC_LINEAR_CENTER_ENA;
			shader->config.spi_ps_input_ena &= C_0286CC_LINEAR_CENTROID_ENA;
			shader->config.spi_ps_input_ena |= S_0286CC_LINEAR_SAMPLE_ENA(1);
		}
	}

	/* POW_W_FLOAT requires that one of the perspective weights is enabled. */
	if (G_0286CC_POS_W_FLOAT_ENA(shader->config.spi_ps_input_ena) &&
	    !(shader->config.spi_ps_input_ena & 0xf)) {
		shader->config.spi_ps_input_ena |= S_0286CC_PERSP_CENTER_ENA(1);
		assert(G_0286CC_PERSP_CENTER_ENA(shader->config.spi_ps_input_addr));
	}

	/* At least one pair of interpolation weights must be enabled. */
	if (!(shader->config.spi_ps_input_ena & 0x7f)) {
		shader->config.spi_ps_input_ena |= S_0286CC_LINEAR_CENTER_ENA(1);
		assert(G_0286CC_LINEAR_CENTER_ENA(shader->config.spi_ps_input_addr));
	}

	/* The sample mask input is always enabled, because the API shader always
	 * passes it through to the epilog. Disable it here if it's unused.
	 */
	if (!shader->key.ps.epilog.poly_line_smoothing &&
	    !shader->selector->info.reads_samplemask)
		shader->config.spi_ps_input_ena &= C_0286CC_SAMPLE_COVERAGE_ENA;

	return true;
}

int si_shader_create(struct si_screen *sscreen, LLVMTargetMachineRef tm,
		     struct si_shader *shader,
		     struct pipe_debug_callback *debug)
{
	struct si_shader *mainp = shader->selector->main_shader_part;
	int r;

	/* LS and ES are always compiled on demand. */
	if (!mainp ||
	    (shader->selector->type == PIPE_SHADER_VERTEX &&
	     (shader->key.vs.as_es || shader->key.vs.as_ls)) ||
	    (shader->selector->type == PIPE_SHADER_TESS_EVAL &&
	     shader->key.tes.as_es)) {
		/* Monolithic shader (compiled as a whole, has many variants,
		 * may take a long time to compile).
		 */
		r = si_compile_tgsi_shader(sscreen, tm, shader, true, debug);
		if (r)
			return r;
	} else {
		/* The shader consists of 2-3 parts:
		 *
		 * - the middle part is the user shader, it has 1 variant only
		 *   and it was compiled during the creation of the shader
		 *   selector
		 * - the prolog part is inserted at the beginning
		 * - the epilog part is inserted at the end
		 *
		 * The prolog and epilog have many (but simple) variants.
		 */

		/* Copy the compiled TGSI shader data over. */
		shader->is_binary_shared = true;
		shader->binary = mainp->binary;
		shader->config = mainp->config;
		shader->info.num_input_sgprs = mainp->info.num_input_sgprs;
		shader->info.num_input_vgprs = mainp->info.num_input_vgprs;
		shader->info.face_vgpr_index = mainp->info.face_vgpr_index;
		memcpy(shader->info.vs_output_param_offset,
		       mainp->info.vs_output_param_offset,
		       sizeof(mainp->info.vs_output_param_offset));
		shader->info.uses_instanceid = mainp->info.uses_instanceid;
		shader->info.nr_pos_exports = mainp->info.nr_pos_exports;
		shader->info.nr_param_exports = mainp->info.nr_param_exports;

		/* Select prologs and/or epilogs. */
		switch (shader->selector->type) {
		case PIPE_SHADER_VERTEX:
			if (!si_shader_select_vs_parts(sscreen, tm, shader, debug))
				return -1;
			break;
		case PIPE_SHADER_TESS_CTRL:
			if (!si_shader_select_tcs_parts(sscreen, tm, shader, debug))
				return -1;
			break;
		case PIPE_SHADER_TESS_EVAL:
			if (!si_shader_select_tes_parts(sscreen, tm, shader, debug))
				return -1;
			break;
		case PIPE_SHADER_FRAGMENT:
			if (!si_shader_select_ps_parts(sscreen, tm, shader, debug))
				return -1;

			/* Make sure we have at least as many VGPRs as there
			 * are allocated inputs.
			 */
			shader->config.num_vgprs = MAX2(shader->config.num_vgprs,
							shader->info.num_input_vgprs);
			break;
		}

		/* Update SGPR and VGPR counts. */
		if (shader->prolog) {
			shader->config.num_sgprs = MAX2(shader->config.num_sgprs,
							shader->prolog->config.num_sgprs);
			shader->config.num_vgprs = MAX2(shader->config.num_vgprs,
							shader->prolog->config.num_vgprs);
		}
		if (shader->epilog) {
			shader->config.num_sgprs = MAX2(shader->config.num_sgprs,
							shader->epilog->config.num_sgprs);
			shader->config.num_vgprs = MAX2(shader->config.num_vgprs,
							shader->epilog->config.num_vgprs);
		}
	}

	si_shader_dump(sscreen, shader, debug, shader->selector->info.processor);

	/* Upload. */
	r = si_shader_binary_upload(sscreen, shader);
	if (r) {
		fprintf(stderr, "LLVM failed to upload shader\n");
		return r;
	}

	return 0;
}

void si_shader_destroy(struct si_shader *shader)
d4215 1
a4215 1
		si_shader_destroy(shader->gs_copy_shader);
d4224 3
a4226 2
	if (!shader->is_binary_shared)
		radeon_shader_binary_clean(&shader->binary);
@


1.1.1.4
log
@Import Mesa 13.0.2
@
text
@d34 1
d36 2
a37 1
#include "gallivm/lp_bld_misc.h"
d39 1
d41 1
d43 1
a43 1
#include "tgsi/tgsi_build.h"
a46 1
#include "si_shader_internal.h"
d48 1
d51 1
d66 63
a133 7
static void si_llvm_emit_barrier(const struct lp_build_tgsi_action *action,
				 struct lp_build_tgsi_context *bld_base,
				 struct lp_build_emit_data *emit_data);

static void si_dump_shader_key(unsigned shader, union si_shader_key *key,
			       FILE *f);

d144 12
a155 4
enum {
	CONST_ADDR_SPACE = 2,
	LOCAL_ADDR_SPACE = 3,
};
d214 2
a215 2
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef value = LLVMGetParam(ctx->main_fn,
d219 1
a219 1
		value = bitcast(&ctx->soa.bld_base,
d238 1
a238 1
	case PIPE_SHADER_TESS_CTRL:
d241 2
a242 2
	case PIPE_SHADER_TESS_EVAL:
		return LLVMGetParam(ctx->main_fn,
d275 1
a275 1
	if (ctx->type == PIPE_SHADER_VERTEX)
d277 1
a277 1
	else if (ctx->type == PIPE_SHADER_TESS_CTRL)
d294 1
a294 1
	return lp_build_mul_imm(&ctx->soa.bld_base.uint_bld,
d304 1
a304 1
	return lp_build_mul_imm(&ctx->soa.bld_base.uint_bld,
d314 1
a314 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d324 1
a324 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d338 1
a338 1
	struct gallivm_state *gallivm = &ctx->gallivm;
a349 11
static LLVMValueRef build_gep0(struct si_shader_context *ctx,
			       LLVMValueRef base_ptr, LLVMValueRef index)
{
	LLVMValueRef indices[2] = {
		LLVMConstInt(ctx->i32, 0, 0),
		index,
	};
	return LLVMBuildGEP(ctx->gallivm.builder, base_ptr,
			    indices, 2, "");
}

d354 1
a354 1
	struct lp_build_tgsi_context *bld_base = &ctx->soa.bld_base;
d356 1
d358 5
a362 2
	LLVMBuildStore(gallivm->builder, value,
		       build_gep0(ctx, base_ptr, index));
a370 2
 * \param uniform   Whether the base_ptr and index can be assumed to be
 *                  dynamically uniform
d373 1
a373 2
				       LLVMValueRef base_ptr, LLVMValueRef index,
				       bool uniform)
d375 1
a375 1
	struct lp_build_tgsi_context *bld_base = &ctx->soa.bld_base;
d377 4
a380 1
	LLVMValueRef pointer;
d382 1
a382 3
	pointer = build_gep0(ctx, base_ptr, index);
	if (uniform)
		LLVMSetMetadata(pointer, ctx->uniform_md_kind, ctx->empty_md);
d388 1
a388 1
 * a constant from a dynamically uniform index.
d394 2
a395 2
	LLVMValueRef result = build_indexed_load(ctx, base_ptr, index, true);
	LLVMSetMetadata(result, ctx->invariant_load_md_kind, ctx->empty_md);
d400 1
a400 1
	struct si_shader_context *radeon_bld,
d420 1
a420 1
	struct si_shader_context *radeon_bld,
d422 1
a422 2
	const struct tgsi_full_declaration *decl,
	LLVMValueRef out[4])
d442 1
a442 1
	t_list_ptr = LLVMGetParam(ctx->main_fn, SI_PARAM_VERTEX_BUFFERS);
d458 1
a458 1
		buffer_index = get_instance_index_for_fetch(ctx,
d463 1
a463 1
		LLVMValueRef vertex_id = LLVMGetParam(ctx->main_fn,
d475 1
a475 1
		LLVMReadNoneAttribute);
d480 5
a484 2
		out[chan] = LLVMBuildExtractElement(gallivm->builder,
						    input, llvm_chan, "");
d497 2
a498 2
	case PIPE_SHADER_VERTEX:
		return LLVMGetParam(ctx->main_fn,
d500 2
a501 2
	case PIPE_SHADER_TESS_CTRL:
		return LLVMGetParam(ctx->main_fn,
d503 2
a504 2
	case PIPE_SHADER_TESS_EVAL:
		return LLVMGetParam(ctx->main_fn,
d506 2
a507 2
	case PIPE_SHADER_GEOMETRY:
		return LLVMGetParam(ctx->main_fn,
d523 1
a523 1
	struct gallivm_state *gallivm = ctx->soa.bld_base.base.gallivm;
d526 1
a526 1
	result = ctx->soa.addr[ind->Index][ind->Swizzle];
a533 21
 * Like get_indirect_index, but restricts the return value to a (possibly
 * undefined) value inside [0..num).
 */
static LLVMValueRef get_bounded_indirect_index(struct si_shader_context *ctx,
					       const struct tgsi_ind_register *ind,
					       int rel_index, unsigned num)
{
	LLVMValueRef result = get_indirect_index(ctx, ind, rel_index);

	/* LLVM 3.8: If indirect resource indexing is used:
	 * - SI & CIK hang
	 * - VI crashes
	 */
	if (HAVE_LLVM <= 0x0308)
		return LLVMGetUndef(ctx->i32);

	return si_llvm_bound_index(ctx, result, num);
}


/**
d542 1
a542 1
	struct gallivm_state *gallivm = ctx->soa.bld_base.base.gallivm;
a617 305
/* The offchip buffer layout for TCS->TES is
 *
 * - attribute 0 of patch 0 vertex 0
 * - attribute 0 of patch 0 vertex 1
 * - attribute 0 of patch 0 vertex 2
 *   ...
 * - attribute 0 of patch 1 vertex 0
 * - attribute 0 of patch 1 vertex 1
 *   ...
 * - attribute 1 of patch 0 vertex 0
 * - attribute 1 of patch 0 vertex 1
 *   ...
 * - per patch attribute 0 of patch 0
 * - per patch attribute 0 of patch 1
 *   ...
 *
 * Note that every attribute has 4 components.
 */
static LLVMValueRef get_tcs_tes_buffer_address(struct si_shader_context *ctx,
                                               LLVMValueRef vertex_index,
                                               LLVMValueRef param_index)
{
	struct gallivm_state *gallivm = ctx->soa.bld_base.base.gallivm;
	LLVMValueRef base_addr, vertices_per_patch, num_patches, total_vertices;
	LLVMValueRef param_stride, constant16;

	vertices_per_patch = unpack_param(ctx, SI_PARAM_TCS_OFFCHIP_LAYOUT, 9, 6);
	num_patches = unpack_param(ctx, SI_PARAM_TCS_OFFCHIP_LAYOUT, 0, 9);
	total_vertices = LLVMBuildMul(gallivm->builder, vertices_per_patch,
	                              num_patches, "");

	constant16 = lp_build_const_int32(gallivm, 16);
	if (vertex_index) {
		base_addr = LLVMBuildMul(gallivm->builder, get_rel_patch_id(ctx),
		                         vertices_per_patch, "");

		base_addr = LLVMBuildAdd(gallivm->builder, base_addr,
		                         vertex_index, "");

		param_stride = total_vertices;
	} else {
		base_addr = get_rel_patch_id(ctx);
		param_stride = num_patches;
	}

	base_addr = LLVMBuildAdd(gallivm->builder, base_addr,
	                         LLVMBuildMul(gallivm->builder, param_index,
	                                      param_stride, ""), "");

	base_addr = LLVMBuildMul(gallivm->builder, base_addr, constant16, "");

	if (!vertex_index) {
		LLVMValueRef patch_data_offset =
		           unpack_param(ctx, SI_PARAM_TCS_OFFCHIP_LAYOUT, 16, 16);

		base_addr = LLVMBuildAdd(gallivm->builder, base_addr,
		                         patch_data_offset, "");
	}
	return base_addr;
}

static LLVMValueRef get_tcs_tes_buffer_address_from_reg(
                                       struct si_shader_context *ctx,
                                       const struct tgsi_full_dst_register *dst,
                                       const struct tgsi_full_src_register *src)
{
	struct gallivm_state *gallivm = ctx->soa.bld_base.base.gallivm;
	struct tgsi_shader_info *info = &ctx->shader->selector->info;
	ubyte *name, *index, *array_first;
	struct tgsi_full_src_register reg;
	LLVMValueRef vertex_index = NULL;
	LLVMValueRef param_index = NULL;
	unsigned param_index_base, param_base;

	reg = src ? *src : tgsi_full_src_register_from_dst(dst);

	if (reg.Register.Dimension) {

		if (reg.Dimension.Indirect)
			vertex_index = get_indirect_index(ctx, &reg.DimIndirect,
			                                  reg.Dimension.Index);
		else
			vertex_index = lp_build_const_int32(gallivm,
			                                    reg.Dimension.Index);
	}

	/* Get information about the register. */
	if (reg.Register.File == TGSI_FILE_INPUT) {
		name = info->input_semantic_name;
		index = info->input_semantic_index;
		array_first = info->input_array_first;
	} else if (reg.Register.File == TGSI_FILE_OUTPUT) {
		name = info->output_semantic_name;
		index = info->output_semantic_index;
		array_first = info->output_array_first;
	} else {
		assert(0);
		return NULL;
	}

	if (reg.Register.Indirect) {
		if (reg.Indirect.ArrayID)
			param_base = array_first[reg.Indirect.ArrayID];
		else
			param_base = reg.Register.Index;

		param_index = get_indirect_index(ctx, &reg.Indirect,
		                                 reg.Register.Index - param_base);

	} else {
		param_base = reg.Register.Index;
		param_index = lp_build_const_int32(gallivm, 0);
	}

	param_index_base = si_shader_io_get_unique_index(name[param_base],
	                                                 index[param_base]);

	param_index = LLVMBuildAdd(gallivm->builder, param_index,
	                           lp_build_const_int32(gallivm, param_index_base),
	                           "");

	return get_tcs_tes_buffer_address(ctx, vertex_index, param_index);
}

/* TBUFFER_STORE_FORMAT_{X,XY,XYZ,XYZW} <- the suffix is selected by num_channels=1..4.
 * The type of vdata must be one of i32 (num_channels=1), v2i32 (num_channels=2),
 * or v4i32 (num_channels=3,4). */
static void build_tbuffer_store(struct si_shader_context *ctx,
				LLVMValueRef rsrc,
				LLVMValueRef vdata,
				unsigned num_channels,
				LLVMValueRef vaddr,
				LLVMValueRef soffset,
				unsigned inst_offset,
				unsigned dfmt,
				unsigned nfmt,
				unsigned offen,
				unsigned idxen,
				unsigned glc,
				unsigned slc,
				unsigned tfe)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef args[] = {
		rsrc,
		vdata,
		LLVMConstInt(ctx->i32, num_channels, 0),
		vaddr,
		soffset,
		LLVMConstInt(ctx->i32, inst_offset, 0),
		LLVMConstInt(ctx->i32, dfmt, 0),
		LLVMConstInt(ctx->i32, nfmt, 0),
		LLVMConstInt(ctx->i32, offen, 0),
		LLVMConstInt(ctx->i32, idxen, 0),
		LLVMConstInt(ctx->i32, glc, 0),
		LLVMConstInt(ctx->i32, slc, 0),
		LLVMConstInt(ctx->i32, tfe, 0)
	};

	/* The instruction offset field has 12 bits */
	assert(offen || inst_offset < (1 << 12));

	/* The intrinsic is overloaded, we need to add a type suffix for overloading to work. */
	unsigned func = CLAMP(num_channels, 1, 3) - 1;
	const char *types[] = {"i32", "v2i32", "v4i32"};
	char name[256];
	snprintf(name, sizeof(name), "llvm.SI.tbuffer.store.%s", types[func]);

	lp_build_intrinsic(gallivm->builder, name, ctx->voidt,
			   args, ARRAY_SIZE(args), 0);
}

static void build_tbuffer_store_dwords(struct si_shader_context *ctx,
				     LLVMValueRef rsrc,
				     LLVMValueRef vdata,
				     unsigned num_channels,
				     LLVMValueRef vaddr,
				     LLVMValueRef soffset,
				     unsigned inst_offset)
{
	static unsigned dfmt[] = {
		V_008F0C_BUF_DATA_FORMAT_32,
		V_008F0C_BUF_DATA_FORMAT_32_32,
		V_008F0C_BUF_DATA_FORMAT_32_32_32,
		V_008F0C_BUF_DATA_FORMAT_32_32_32_32
	};
	assert(num_channels >= 1 && num_channels <= 4);

	build_tbuffer_store(ctx, rsrc, vdata, num_channels, vaddr, soffset,
			    inst_offset, dfmt[num_channels-1],
			    V_008F0C_BUF_NUM_FORMAT_UINT, 1, 0, 1, 1, 0);
}

static LLVMValueRef build_buffer_load(struct si_shader_context *ctx,
                                      LLVMValueRef rsrc,
                                      int num_channels,
                                      LLVMValueRef vindex,
                                      LLVMValueRef voffset,
                                      LLVMValueRef soffset,
                                      unsigned inst_offset,
                                      unsigned glc,
                                      unsigned slc)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	unsigned func = CLAMP(num_channels, 1, 3) - 1;

	if (HAVE_LLVM >= 0x309) {
		LLVMValueRef args[] = {
			LLVMBuildBitCast(gallivm->builder, rsrc, ctx->v4i32, ""),
			vindex ? vindex : LLVMConstInt(ctx->i32, 0, 0),
			LLVMConstInt(ctx->i32, inst_offset, 0),
			LLVMConstInt(ctx->i1, glc, 0),
			LLVMConstInt(ctx->i1, slc, 0)
		};

		LLVMTypeRef types[] = {ctx->f32, LLVMVectorType(ctx->f32, 2),
		                       ctx->v4f32};
		const char *type_names[] = {"f32", "v2f32", "v4f32"};
		char name[256];

		if (voffset) {
			args[2] = LLVMBuildAdd(gallivm->builder, args[2], voffset,
			                       "");
		}

		if (soffset) {
			args[2] = LLVMBuildAdd(gallivm->builder, args[2], soffset,
			                       "");
		}

		snprintf(name, sizeof(name), "llvm.amdgcn.buffer.load.%s",
		         type_names[func]);

		return lp_build_intrinsic(gallivm->builder, name, types[func], args,
		                          ARRAY_SIZE(args), LLVMReadOnlyAttribute);
	} else {
		LLVMValueRef args[] = {
			LLVMBuildBitCast(gallivm->builder, rsrc, ctx->v16i8, ""),
			voffset ? voffset : vindex,
			soffset,
			LLVMConstInt(ctx->i32, inst_offset, 0),
			LLVMConstInt(ctx->i32, voffset ? 1 : 0, 0), // offen
			LLVMConstInt(ctx->i32, vindex ? 1 : 0, 0), //idxen
			LLVMConstInt(ctx->i32, glc, 0),
			LLVMConstInt(ctx->i32, slc, 0),
			LLVMConstInt(ctx->i32, 0, 0), // TFE
		};

		LLVMTypeRef types[] = {ctx->i32, LLVMVectorType(ctx->i32, 2),
		                       ctx->v4i32};
		const char *type_names[] = {"i32", "v2i32", "v4i32"};
		const char *arg_type = "i32";
		char name[256];

		if (voffset && vindex) {
			LLVMValueRef vaddr[] = {vindex, voffset};

			arg_type = "v2i32";
			args[1] = lp_build_gather_values(gallivm, vaddr, 2);
		}

		snprintf(name, sizeof(name), "llvm.SI.buffer.load.dword.%s.%s",
		         type_names[func], arg_type);

		return lp_build_intrinsic(gallivm->builder, name, types[func], args,
		                          ARRAY_SIZE(args), LLVMReadOnlyAttribute);
	}
}

static LLVMValueRef buffer_load(struct lp_build_tgsi_context *bld_base,
                                enum tgsi_opcode_type type, unsigned swizzle,
                                LLVMValueRef buffer, LLVMValueRef offset,
                                LLVMValueRef base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef value, value2;
	LLVMTypeRef llvm_type = tgsi2llvmtype(bld_base, type);
	LLVMTypeRef vec_type = LLVMVectorType(llvm_type, 4);

	if (swizzle == ~0) {
		value = build_buffer_load(ctx, buffer, 4, NULL, base, offset,
		                          0, 1, 0);

		return LLVMBuildBitCast(gallivm->builder, value, vec_type, "");
	}

	if (!tgsi_type_is_64bit(type)) {
		value = build_buffer_load(ctx, buffer, 4, NULL, base, offset,
		                          0, 1, 0);

		value = LLVMBuildBitCast(gallivm->builder, value, vec_type, "");
		return LLVMBuildExtractElement(gallivm->builder, value,
		                    lp_build_const_int32(gallivm, swizzle), "");
	}

	value = build_buffer_load(ctx, buffer, 1, NULL, base, offset,
	                          swizzle * 4, 1, 0);

	value2 = build_buffer_load(ctx, buffer, 1, NULL, base, offset,
	                           swizzle * 4 + 4, 1, 0);

	return si_llvm_emit_fetch_64bit(bld_base, type, value, value2);
}

d646 2
a647 2
	value = build_indexed_load(ctx, ctx->lds, dw_addr, false);
	if (tgsi_type_is_64bit(type)) {
d650 3
a652 3
				       lp_build_const_int32(gallivm, 1));
		value2 = build_indexed_load(ctx, ctx->lds, dw_addr, false);
		return si_llvm_emit_fetch_64bit(bld_base, type, value, value2);
d722 1
a722 2
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef rw_buffers, buffer, base, addr;
d724 8
a731 4
	rw_buffers = LLVMGetParam(ctx->main_fn,
				  SI_PARAM_RW_BUFFERS);
	buffer = build_indexed_load_const(ctx, rw_buffers,
			lp_build_const_int32(gallivm, SI_HS_RING_TESS_OFFCHIP));
d733 1
a733 4
	base = LLVMGetParam(ctx->main_fn, ctx->param_oc_lds);
	addr = get_tcs_tes_buffer_address_from_reg(ctx, NULL, reg);

	return buffer_load(bld_base, type, swizzle, buffer, base, addr);
a741 1
	struct gallivm_state *gallivm = bld_base->base.gallivm;
a744 2
	LLVMValueRef rw_buffers, buffer, base, buf_addr;
	LLVMValueRef values[4];
d751 1
a751 1
		si_llvm_emit_store(bld_base, inst, info, dst);
a763 9
	rw_buffers = LLVMGetParam(ctx->main_fn,
				  SI_PARAM_RW_BUFFERS);
	buffer = build_indexed_load_const(ctx, rw_buffers,
			lp_build_const_int32(gallivm, SI_HS_RING_TESS_OFFCHIP));

	base = LLVMGetParam(ctx->main_fn, ctx->param_oc_lds);
	buf_addr = get_tcs_tes_buffer_address_from_reg(ctx, reg, NULL);


d768 1
a768 1
			value = si_llvm_saturate(bld_base, value);
a770 16

		value = LLVMBuildBitCast(gallivm->builder, value, ctx->i32, "");
		values[chan_index] = value;

		if (inst->Dst[0].Register.WriteMask != 0xF) {
			build_tbuffer_store_dwords(ctx, buffer, value, 1,
			                           buf_addr, base,
			                           4 * chan_index);
		}
	}

	if (inst->Dst[0].Register.WriteMask == 0xF) {
		LLVMValueRef value = lp_build_gather_values(bld_base->base.gallivm,
		                                            values, 4);
		build_tbuffer_store_dwords(ctx, buffer, value, 4, buf_addr,
		                           base, 0);
d783 1
a783 1
	struct lp_build_context *uint =	&ctx->soa.bld_base.uint_bld;
d819 1
a819 1
				      LLVMGetParam(ctx->main_fn,
d837 2
a838 2
				   LLVMReadOnlyAttribute);
	if (tgsi_type_is_64bit(type)) {
d844 3
a846 3
					    LLVMReadOnlyAttribute);
		return si_llvm_emit_fetch_64bit(bld_base, type,
						value, value2);
d886 2
a887 1
	if (!ctx->is_monolithic)
d890 16
a905 27
	if (ctx->shader->key.ps.prolog.force_persp_sample_interp) {
		switch (param) {
		case SI_PARAM_PERSP_CENTROID:
		case SI_PARAM_PERSP_CENTER:
			return SI_PARAM_PERSP_SAMPLE;
		}
	}
	if (ctx->shader->key.ps.prolog.force_linear_sample_interp) {
		switch (param) {
		case SI_PARAM_LINEAR_CENTROID:
		case SI_PARAM_LINEAR_CENTER:
			return SI_PARAM_LINEAR_SAMPLE;
		}
	}
	if (ctx->shader->key.ps.prolog.force_persp_center_interp) {
		switch (param) {
		case SI_PARAM_PERSP_CENTROID:
		case SI_PARAM_PERSP_SAMPLE:
			return SI_PARAM_PERSP_CENTER;
		}
	}
	if (ctx->shader->key.ps.prolog.force_linear_center_interp) {
		switch (param) {
		case SI_PARAM_LINEAR_CENTROID:
		case SI_PARAM_LINEAR_SAMPLE:
			return SI_PARAM_LINEAR_CENTER;
		}
a906 2

	return param;
d934 2
a935 2
	struct lp_build_context *base = &ctx->soa.bld_base.base;
	struct lp_build_context *uint =	&ctx->soa.bld_base.uint_bld;
d984 1
a984 1
						LLVMReadNoneAttribute);
d989 1
a989 1
					       LLVMReadNoneAttribute);
d1006 1
a1006 1
					LLVMReadNoneAttribute);
d1021 1
a1021 47
						LLVMReadNoneAttribute);
		}
	}
}

/* LLVMGetParam with bc_optimize resolved. */
static LLVMValueRef get_interp_param(struct si_shader_context *ctx,
				     int interp_param_idx)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMValueRef main_fn = ctx->main_fn;
	LLVMValueRef param = NULL;

	/* Handle PRIM_MASK[31] (bc_optimize). */
	if (ctx->is_monolithic &&
	    ((ctx->shader->key.ps.prolog.bc_optimize_for_persp &&
	      interp_param_idx == SI_PARAM_PERSP_CENTROID) ||
	     (ctx->shader->key.ps.prolog.bc_optimize_for_linear &&
	      interp_param_idx == SI_PARAM_LINEAR_CENTROID))) {
		/* The shader should do: if (PRIM_MASK[31]) CENTROID = CENTER;
		 * The hw doesn't compute CENTROID if the whole wave only
		 * contains fully-covered quads.
		 */
		LLVMValueRef bc_optimize =
			LLVMGetParam(main_fn, SI_PARAM_PRIM_MASK);
		bc_optimize = LLVMBuildLShr(builder,
					    bc_optimize,
					    LLVMConstInt(ctx->i32, 31, 0), "");
		bc_optimize = LLVMBuildTrunc(builder, bc_optimize, ctx->i1, "");

		if (ctx->shader->key.ps.prolog.bc_optimize_for_persp &&
		    interp_param_idx == SI_PARAM_PERSP_CENTROID) {
			param = LLVMBuildSelect(builder, bc_optimize,
						LLVMGetParam(main_fn,
							     SI_PARAM_PERSP_CENTER),
						LLVMGetParam(main_fn,
							     SI_PARAM_PERSP_CENTROID),
						"");
		}
		if (ctx->shader->key.ps.prolog.bc_optimize_for_linear &&
		    interp_param_idx == SI_PARAM_LINEAR_CENTROID) {
			param = LLVMBuildSelect(builder, bc_optimize,
						LLVMGetParam(main_fn,
							     SI_PARAM_LINEAR_CENTER),
						LLVMGetParam(main_fn,
							     SI_PARAM_LINEAR_CENTROID),
						"");
a1023 4

	if (!param)
		param = LLVMGetParam(main_fn, interp_param_idx);
	return param;
d1027 1
a1027 1
	struct si_shader_context *radeon_bld,
d1029 1
a1029 2
	const struct tgsi_full_declaration *decl,
	LLVMValueRef out[4])
d1048 8
a1055 4
		out[0] = mask & 0x1 ? LLVMGetParam(main_fn, offset++) : base->undef;
		out[1] = mask & 0x2 ? LLVMGetParam(main_fn, offset++) : base->undef;
		out[2] = mask & 0x4 ? LLVMGetParam(main_fn, offset++) : base->undef;
		out[3] = mask & 0x8 ? LLVMGetParam(main_fn, offset++) : base->undef;
d1066 1
a1066 1
		interp_param = get_interp_param(ctx, interp_param_idx);
a1068 5
	if (decl->Semantic.Name == TGSI_SEMANTIC_COLOR &&
	    decl->Interp.Interpolate == TGSI_INTERPOLATE_COLOR &&
	    ctx->shader->key.ps.prolog.flatshade_colors)
		interp_param = NULL; /* load the constant color */

d1074 1
a1074 1
			&out[0]);
d1077 1
a1077 1
static LLVMValueRef get_sample_id(struct si_shader_context *radeon_bld)
d1084 1
a1084 5
 * Set range metadata on an instruction.  This can only be used on load and
 * call instructions.  If you know an instruction can only produce the values
 * 0, 1, 2, you would do set_range_metadata(value, 0, 3);
 * \p lo is the minimum value inclusive.
 * \p hi is the maximum value exclusive.
d1086 2
a1087 2
static void set_range_metadata(struct si_shader_context *ctx,
			       LLVMValueRef value, unsigned lo, unsigned hi)
d1089 1
a1089 3
	LLVMValueRef range_md, md_args[2];
	LLVMTypeRef type = LLVMTypeOf(value);
	LLVMContextRef context = LLVMGetTypeContext(type);
d1091 2
a1092 4
	md_args[0] = LLVMConstInt(type, lo, false);
	md_args[1] = LLVMConstInt(type, hi, false);
	range_md = LLVMMDNodeInContext(context, md_args, 2);
	LLVMSetMetadata(value, ctx->range_md_kind, range_md);
d1095 1
a1095 1
static LLVMValueRef get_thread_id(struct si_shader_context *ctx)
d1097 3
a1099 41
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef tid;

	if (HAVE_LLVM < 0x0308) {
		tid = lp_build_intrinsic(gallivm->builder, "llvm.SI.tid",
				ctx->i32,   NULL, 0, LLVMReadNoneAttribute);
	} else {
		LLVMValueRef tid_args[2];
		tid_args[0] = lp_build_const_int32(gallivm, 0xffffffff);
		tid_args[1] = lp_build_const_int32(gallivm, 0);
		tid_args[1] = lp_build_intrinsic(gallivm->builder,
					"llvm.amdgcn.mbcnt.lo", ctx->i32,
					tid_args, 2, LLVMReadNoneAttribute);

		tid = lp_build_intrinsic(gallivm->builder,
					"llvm.amdgcn.mbcnt.hi", ctx->i32,
					tid_args, 2, LLVMReadNoneAttribute);
	}
	set_range_metadata(ctx, tid, 0, 64);
	return tid;
}

/**
 * Load a dword from a constant buffer.
 */
static LLVMValueRef buffer_load_const(struct si_shader_context *ctx,
				      LLVMValueRef resource,
				      LLVMValueRef offset)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMValueRef args[2] = {resource, offset};

	return lp_build_intrinsic(builder, "llvm.SI.load.const", ctx->f32, args, 2,
			       LLVMReadNoneAttribute);
}

static LLVMValueRef load_sample_position(struct si_shader_context *radeon_bld, LLVMValueRef sample_id)
{
	struct si_shader_context *ctx =
		si_shader_context(&radeon_bld->soa.bld_base);
	struct lp_build_context *uint_bld = &radeon_bld->soa.bld_base.uint_bld;
d1102 2
a1103 2
	LLVMValueRef desc = LLVMGetParam(ctx->main_fn, SI_PARAM_RW_BUFFERS);
	LLVMValueRef buf_index = lp_build_const_int32(gallivm, SI_PS_CONST_SAMPLE_POSITIONS);
d1111 2
a1112 2
		buffer_load_const(ctx, resource, offset0),
		buffer_load_const(ctx, resource, offset1),
d1121 1
a1121 1
	struct si_shader_context *radeon_bld,
a1154 10
	case TGSI_SEMANTIC_BASEINSTANCE:
		value = LLVMGetParam(radeon_bld->main_fn,
				     SI_PARAM_START_INSTANCE);
		break;

	case TGSI_SEMANTIC_DRAWID:
		value = LLVMGetParam(radeon_bld->main_fn,
				     SI_PARAM_DRAWID);
		break;

d1156 1
a1156 1
		if (ctx->type == PIPE_SHADER_TESS_CTRL)
d1158 1
a1158 1
		else if (ctx->type == PIPE_SHADER_GEOMETRY)
d1229 1
a1229 6
		if (ctx->type == PIPE_SHADER_TESS_CTRL)
			value = unpack_param(ctx, SI_PARAM_TCS_OUT_LAYOUT, 26, 6);
		else if (ctx->type == PIPE_SHADER_TESS_EVAL)
			value = unpack_param(ctx, SI_PARAM_TCS_OFFCHIP_LAYOUT, 9, 7);
		else
			assert(!"invalid shader stage for TGSI_SEMANTIC_VERTICESIN");
d1235 1
a1235 1
		LLVMValueRef rw_buffers, buffer, base, addr;
d1238 3
a1240 20
		rw_buffers = LLVMGetParam(ctx->main_fn,
					SI_PARAM_RW_BUFFERS);
		buffer = build_indexed_load_const(ctx, rw_buffers,
		        lp_build_const_int32(gallivm, SI_HS_RING_TESS_OFFCHIP));

		base = LLVMGetParam(ctx->main_fn, ctx->param_oc_lds);
		addr = get_tcs_tes_buffer_address(ctx, NULL,
		                          lp_build_const_int32(gallivm, param));

		value = buffer_load(&radeon_bld->soa.bld_base, TGSI_TYPE_FLOAT,
		                    ~0, buffer, base, addr);

		break;
	}

	case TGSI_SEMANTIC_DEFAULT_TESSOUTER_SI:
	case TGSI_SEMANTIC_DEFAULT_TESSINNER_SI:
	{
		LLVMValueRef buf, slot, val[4];
		int i, offset;
d1242 2
a1243 9
		slot = lp_build_const_int32(gallivm, SI_HS_CONST_DEFAULT_TESS_LEVELS);
		buf = LLVMGetParam(ctx->main_fn, SI_PARAM_RW_BUFFERS);
		buf = build_indexed_load_const(ctx, buf, slot);
		offset = decl->Semantic.Name == TGSI_SEMANTIC_DEFAULT_TESSINNER_SI ? 4 : 0;

		for (i = 0; i < 4; i++)
			val[i] = buffer_load_const(ctx, buf,
						   lp_build_const_int32(gallivm, (offset + i) * 4));
		value = lp_build_gather_values(gallivm, val, 4);
a1250 46
	case TGSI_SEMANTIC_GRID_SIZE:
		value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_GRID_SIZE);
		break;

	case TGSI_SEMANTIC_BLOCK_SIZE:
	{
		LLVMValueRef values[3];
		unsigned i;
		unsigned *properties = ctx->shader->selector->info.properties;

		if (properties[TGSI_PROPERTY_CS_FIXED_BLOCK_WIDTH] != 0) {
			unsigned sizes[3] = {
				properties[TGSI_PROPERTY_CS_FIXED_BLOCK_WIDTH],
				properties[TGSI_PROPERTY_CS_FIXED_BLOCK_HEIGHT],
				properties[TGSI_PROPERTY_CS_FIXED_BLOCK_DEPTH]
			};

			for (i = 0; i < 3; ++i)
				values[i] = lp_build_const_int32(gallivm, sizes[i]);

			value = lp_build_gather_values(gallivm, values, 3);
		} else {
			value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_BLOCK_SIZE);
		}
		break;
	}

	case TGSI_SEMANTIC_BLOCK_ID:
		value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_BLOCK_ID);
		break;

	case TGSI_SEMANTIC_THREAD_ID:
		value = LLVMGetParam(radeon_bld->main_fn, SI_PARAM_THREAD_ID);
		break;

#if HAVE_LLVM >= 0x0309
	case TGSI_SEMANTIC_HELPER_INVOCATION:
		value = lp_build_intrinsic(gallivm->builder,
					   "llvm.amdgcn.ps.live",
					   ctx->i1, NULL, 0,
					   LLVMReadNoneAttribute);
		value = LLVMBuildNot(gallivm->builder, value, "");
		value = LLVMBuildSExt(gallivm->builder, value, ctx->i32, "");
		break;
#endif

a1258 33
static void declare_compute_memory(struct si_shader_context *radeon_bld,
                                   const struct tgsi_full_declaration *decl)
{
	struct si_shader_context *ctx =
		si_shader_context(&radeon_bld->soa.bld_base);
	struct si_shader_selector *sel = ctx->shader->selector;
	struct gallivm_state *gallivm = &radeon_bld->gallivm;

	LLVMTypeRef i8p = LLVMPointerType(ctx->i8, LOCAL_ADDR_SPACE);
	LLVMValueRef var;

	assert(decl->Declaration.MemType == TGSI_MEMORY_TYPE_SHARED);
	assert(decl->Range.First == decl->Range.Last);
	assert(!ctx->shared_memory);

	var = LLVMAddGlobalInAddressSpace(gallivm->module,
	                                  LLVMArrayType(ctx->i8, sel->local_size),
	                                  "compute_lds",
	                                  LOCAL_ADDR_SPACE);
	LLVMSetAlignment(var, 4);

	ctx->shared_memory = LLVMBuildBitCast(gallivm->builder, var, i8p, "");
}

static LLVMValueRef load_const_buffer_desc(struct si_shader_context *ctx, int i)
{
	LLVMValueRef list_ptr = LLVMGetParam(ctx->main_fn,
					     SI_PARAM_CONST_BUFFERS);

	return build_indexed_load_const(ctx, list_ptr,
					LLVMConstInt(ctx->i32, i, 0));
}

d1285 10
d1296 1
a1296 1
		LLVMValueRef ptr = LLVMGetParam(ctx->main_fn, SI_PARAM_CONST_BUFFERS);
d1298 2
a1299 3
		index = get_bounded_indirect_index(ctx, &reg->DimIndirect,
						   reg->Dimension.Index,
						   SI_NUM_CONST_BUFFERS);
d1302 1
a1302 1
		bufp = load_const_buffer_desc(ctx, buf);
d1304 5
a1308 9
	if (reg->Register.Indirect) {
		addr = ctx->soa.addr[ireg->Index][ireg->Swizzle];
		addr = LLVMBuildLoad(base->gallivm->builder, addr, "load addr reg");
		addr = lp_build_mul_imm(&bld_base->uint_bld, addr, 16);
		addr = lp_build_add(&bld_base->uint_bld, addr,
				    lp_build_const_int32(base->gallivm, idx * 4));
	} else {
		addr = LLVMConstInt(ctx->i32, idx * 4, 0);
	}
d1310 2
a1311 1
	result = buffer_load_const(ctx, bufp, addr);
d1313 1
a1313 1
	if (!tgsi_type_is_64bit(type))
d1317 5
d1323 2
a1324 3
		addr2 = lp_build_add(&bld_base->uint_bld, addr,
				     LLVMConstInt(ctx->i32, 4, 0));
		result2 = buffer_load_const(ctx, bufp, addr2);
d1326 2
a1327 2
		result = si_llvm_emit_fetch_64bit(bld_base, type,
						  result, result2);
d1362 1
a1362 1
				&ctx->soa.bld_base.uint_bld;
d1383 1
a1383 1
	if (ctx->type == PIPE_SHADER_FRAGMENT) {
d1435 1
a1435 1
						    LLVMReadNoneAttribute);
d1444 1
a1444 1
			val[chan] = si_llvm_saturate(bld_base, values[chan]);
d1544 1
a1544 1
		LLVMValueRef alpha_ref = LLVMGetParam(ctx->main_fn,
d1574 1
a1574 1
	coverage = LLVMGetParam(ctx->main_fn,
d1597 1
a1597 1
	struct lp_build_context *uint = &ctx->soa.bld_base.uint_bld;
d1602 2
a1603 3
	LLVMValueRef ptr = LLVMGetParam(ctx->main_fn, SI_PARAM_RW_BUFFERS);
	LLVMValueRef constbuf_index = lp_build_const_int32(base->gallivm,
							   SI_VS_CONST_CLIP_PLANES);
d1620 2
a1621 2
				base_elt = buffer_load_const(ctx, const_resource,
							     args[1]);
d1659 69
d1735 1
a1735 1
	struct gallivm_state *gallivm = &ctx->gallivm;
a1738 13
	LLVMValueRef so_buffers[4];
	LLVMValueRef buf_ptr = LLVMGetParam(ctx->main_fn,
					    SI_PARAM_RW_BUFFERS);

	/* Load the descriptors. */
	for (i = 0; i < 4; ++i) {
		if (ctx->shader->selector->so.stride[i]) {
			LLVMValueRef offset = lp_build_const_int32(gallivm,
								   SI_VS_STREAMOUT_BUF0 + i);

			so_buffers[i] = build_indexed_load_const(ctx, buf_ptr, offset);
		}
	}
d1744 2
a1745 1
	LLVMValueRef tid = get_thread_id(ctx);
d1766 1
a1766 1
			LLVMGetParam(ctx->main_fn,
d1778 1
a1778 1
			LLVMValueRef so_offset = LLVMGetParam(ctx->main_fn,
d1835 1
a1835 1
			build_tbuffer_store_dwords(ctx, so_buffers[buf_idx],
d1856 1
a1856 1
				&ctx->soa.bld_base.uint_bld;
a2021 42
static void si_copy_tcs_inputs(struct lp_build_tgsi_context *bld_base)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMValueRef invocation_id, rw_buffers, buffer, buffer_offset;
	LLVMValueRef lds_vertex_stride, lds_vertex_offset, lds_base;
	uint64_t inputs;

	invocation_id = unpack_param(ctx, SI_PARAM_REL_IDS, 8, 5);

	rw_buffers = LLVMGetParam(ctx->main_fn, SI_PARAM_RW_BUFFERS);
	buffer = build_indexed_load_const(ctx, rw_buffers,
	                lp_build_const_int32(gallivm, SI_HS_RING_TESS_OFFCHIP));

	buffer_offset = LLVMGetParam(ctx->main_fn, ctx->param_oc_lds);

	lds_vertex_stride = unpack_param(ctx, SI_PARAM_TCS_IN_LAYOUT, 13, 8);
	lds_vertex_offset = LLVMBuildMul(gallivm->builder, invocation_id,
	                                 lds_vertex_stride, "");
	lds_base = get_tcs_in_current_patch_offset(ctx);
	lds_base = LLVMBuildAdd(gallivm->builder, lds_base, lds_vertex_offset, "");

	inputs = ctx->shader->key.tcs.epilog.inputs_to_copy;
	while (inputs) {
		unsigned i = u_bit_scan64(&inputs);

		LLVMValueRef lds_ptr = LLVMBuildAdd(gallivm->builder, lds_base,
		                            lp_build_const_int32(gallivm, 4 * i),
		                             "");

		LLVMValueRef buffer_addr = get_tcs_tes_buffer_address(ctx,
		                              invocation_id,
		                              lp_build_const_int32(gallivm, i));

		LLVMValueRef value = lds_load(bld_base, TGSI_TYPE_SIGNED, ~0,
		                              lds_ptr);

		build_tbuffer_store_dwords(ctx, buffer, value, 4, buffer_addr,
		                           buffer_offset, 0);
	}
}

d2034 1
a2034 3
	struct lp_build_if_state if_ctx, inner_if_ctx;

	si_llvm_emit_barrier(NULL, bld_base, NULL);
d2095 1
a2095 1
	rw_buffers = LLVMGetParam(ctx->main_fn,
d2098 1
a2098 1
			lp_build_const_int32(gallivm, SI_HS_RING_TESS_FACTOR));
d2101 1
a2101 1
	tf_base = LLVMGetParam(ctx->main_fn,
d2106 1
a2106 12
	lp_build_if(&inner_if_ctx, gallivm,
		    LLVMBuildICmp(gallivm->builder, LLVMIntEQ,
				  rel_patch_id, bld_base->uint_bld.zero, ""));

	/* Store the dynamic HS control word. */
	build_tbuffer_store_dwords(ctx, buffer,
	                           lp_build_const_int32(gallivm, 0x80000000),
	                           1, lp_build_const_int32(gallivm, 0), tf_base, 0);

	lp_build_endif(&inner_if_ctx);

	/* Store the tessellation factors. */
d2108 1
a2108 1
				   MIN2(stride, 4), byteoffset, tf_base, 4);
d2111 1
a2111 1
					   stride - 4, byteoffset, tf_base, 20);
d2133 1
a2133 1
		rw_buffers = LLVMGetParam(ctx->main_fn,
d2145 1
a2145 1
		tf_soffset = LLVMGetParam(ctx->main_fn,
d2148 1
a2148 1
					   SI_TCS_NUM_USER_SGPR + 1, "");
d2155 1
a2155 1
		vgpr = SI_TCS_NUM_USER_SGPR + 2;
a2162 1
	si_copy_tcs_inputs(bld_base);
d2173 1
a2173 1
	LLVMValueRef vertex_id = LLVMGetParam(ctx->main_fn,
d2183 1
a2183 1
		LLVMValueRef *out_ptr = ctx->soa.outputs[i];
d2203 1
a2203 1
	LLVMValueRef soffset = LLVMGetParam(ctx->main_fn,
d2210 1
a2210 1
			ctx->soa.outputs[i];
d2243 1
a2243 1
	args[1] = LLVMGetParam(ctx->main_fn, SI_PARAM_GS_WAVE_ID);
d2245 1
a2245 1
			   ctx->voidt, args, 2, 0);
d2266 1
a2266 1
	if (ctx->type == PIPE_SHADER_VERTEX) {
d2279 1
a2279 1
				cond = LLVMGetParam(ctx->main_fn,
d2287 1
a2287 1
				addr = ctx->soa.outputs[i][j];
d2289 1
a2289 1
				val = si_llvm_saturate(bld_base, val);
d2305 1
a2305 1
					      ctx->soa.outputs[i][j],
a2334 24
struct si_ps_exports {
	unsigned num;
	LLVMValueRef args[10][9];
};

unsigned si_get_spi_shader_z_format(bool writes_z, bool writes_stencil,
				    bool writes_samplemask)
{
	if (writes_z) {
		/* Z needs 32 bits. */
		if (writes_samplemask)
			return V_028710_SPI_SHADER_32_ABGR;
		else if (writes_stencil)
			return V_028710_SPI_SHADER_32_GR;
		else
			return V_028710_SPI_SHADER_32_R;
	} else if (writes_stencil || writes_samplemask) {
		/* Both stencil and sample mask need only 16 bits. */
		return V_028710_SPI_SHADER_UINT16_ABGR;
	} else {
		return V_028710_SPI_SHADER_ZERO;
	}
}

d2336 2
a2337 2
			    LLVMValueRef depth, LLVMValueRef stencil,
			    LLVMValueRef samplemask, struct si_ps_exports *exp)
a2343 3
	unsigned format = si_get_spi_shader_z_format(depth != NULL,
						     stencil != NULL,
						     samplemask != NULL);
d2359 9
a2367 3
	if (format == V_028710_SPI_SHADER_UINT16_ABGR) {
		assert(!depth);
		args[4] = uint->one; /* COMPR flag */
d2369 3
a2371 26
		if (stencil) {
			/* Stencil should be in X[23:16]. */
			stencil = bitcast(bld_base, TGSI_TYPE_UNSIGNED, stencil);
			stencil = LLVMBuildShl(base->gallivm->builder, stencil,
					       LLVMConstInt(ctx->i32, 16, 0), "");
			args[5] = bitcast(bld_base, TGSI_TYPE_FLOAT, stencil);
			mask |= 0x3;
		}
		if (samplemask) {
			/* SampleMask should be in Y[15:0]. */
			args[6] = samplemask;
			mask |= 0xc;
		}
	} else {
		if (depth) {
			args[5] = depth;
			mask |= 0x1;
		}
		if (stencil) {
			args[6] = stencil;
			mask |= 0x2;
		}
		if (samplemask) {
			args[7] = samplemask;
			mask |= 0x4;
		}
d2383 2
a2384 1
	memcpy(exp->args[exp->num++], args, sizeof(args));
d2390 1
a2390 1
				bool is_last, struct si_ps_exports *exp)
d2399 1
a2399 1
			color[i] = si_llvm_saturate(bld_base, color[i]);
d2436 2
a2437 1
			memcpy(exp->args[exp->num++], args[c], sizeof(args[c]));
d2451 2
a2452 1
		memcpy(exp->args[exp->num++], args, sizeof(args));
a2455 9
static void si_emit_ps_exports(struct si_shader_context *ctx,
			       struct si_ps_exports *exp)
{
	for (unsigned i = 0; i < exp->num; i++)
		lp_build_intrinsic(ctx->gallivm.builder,
				   "llvm.SI.export", ctx->voidt,
				   exp->args[i], 9, 0);
}

d2468 4
a2471 4
	args[5] = base->undef; /* R */
	args[6] = base->undef; /* G */
	args[7] = base->undef; /* B */
	args[8] = base->undef; /* A */
a2486 1
	struct si_ps_exports exp = {};
d2536 1
a2536 1
					      ctx->soa.outputs[i][2], "");
d2540 1
a2540 1
						ctx->soa.outputs[i][1], "");
d2544 1
a2544 1
						   ctx->soa.outputs[i][0], "");
d2549 1
a2549 1
							 ctx->soa.outputs[i][j], "");
d2553 1
a2553 1
					    last_color_export == i, &exp);
d2563 1
a2563 3
		si_export_mrt_z(bld_base, depth, stencil, samplemask, &exp);

	si_emit_ps_exports(ctx, &exp);
d2601 1
a2601 1
				LLVMValueRef ptr = ctx->soa.outputs[i][j];
d2608 1
a2608 1
					      ctx->soa.outputs[i][2], "");
d2612 1
a2612 1
						ctx->soa.outputs[i][1], "");
d2616 1
a2616 1
						   ctx->soa.outputs[i][0], "");
d2630 1
a2630 1
					   LLVMGetParam(ctx->main_fn,
d2654 1
a2654 1
				   LLVMGetParam(ctx->main_fn,
a2659 73
/**
 * Given a v8i32 resource descriptor for a buffer, extract the size of the
 * buffer in number of elements and return it as an i32.
 */
static LLVMValueRef get_buffer_size(
	struct lp_build_tgsi_context *bld_base,
	LLVMValueRef descriptor)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	LLVMValueRef size =
		LLVMBuildExtractElement(builder, descriptor,
					lp_build_const_int32(gallivm, 6), "");

	if (ctx->screen->b.chip_class >= VI) {
		/* On VI, the descriptor contains the size in bytes,
		 * but TXQ must return the size in elements.
		 * The stride is always non-zero for resources using TXQ.
		 */
		LLVMValueRef stride =
			LLVMBuildExtractElement(builder, descriptor,
						lp_build_const_int32(gallivm, 5), "");
		stride = LLVMBuildLShr(builder, stride,
				       lp_build_const_int32(gallivm, 16), "");
		stride = LLVMBuildAnd(builder, stride,
				      lp_build_const_int32(gallivm, 0x3FFF), "");

		size = LLVMBuildUDiv(builder, size, stride, "");
	}

	return size;
}

/**
 * Given the i32 or vNi32 \p type, generate the textual name (e.g. for use with
 * intrinsic names).
 */
static void build_type_name_for_intr(
	LLVMTypeRef type,
	char *buf, unsigned bufsize)
{
	LLVMTypeRef elem_type = type;

	assert(bufsize >= 8);

	if (LLVMGetTypeKind(type) == LLVMVectorTypeKind) {
		int ret = snprintf(buf, bufsize, "v%u",
					LLVMGetVectorSize(type));
		if (ret < 0) {
			char *type_name = LLVMPrintTypeToString(type);
			fprintf(stderr, "Error building type name for: %s\n",
				type_name);
			return;
		}
		elem_type = LLVMGetElementType(type);
		buf += ret;
		bufsize -= ret;
	}
	switch (LLVMGetTypeKind(elem_type)) {
	default: break;
	case LLVMIntegerTypeKind:
		snprintf(buf, bufsize, "i%d", LLVMGetIntTypeWidth(elem_type));
		break;
	case LLVMFloatTypeKind:
		snprintf(buf, bufsize, "f32");
		break;
	case LLVMDoubleTypeKind:
		snprintf(buf, bufsize, "f64");
		break;
	}
}

a2663 51
/* Prevent optimizations (at least of memory accesses) across the current
 * point in the program by emitting empty inline assembly that is marked as
 * having side effects.
 */
static void emit_optimization_barrier(struct si_shader_context *ctx)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMTypeRef ftype = LLVMFunctionType(ctx->voidt, NULL, 0, false);
	LLVMValueRef inlineasm = LLVMConstInlineAsm(ftype, "", "", true, false);
	LLVMBuildCall(builder, inlineasm, NULL, 0, "");
}

static void emit_waitcnt(struct si_shader_context *ctx)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	LLVMValueRef args[1] = {
		lp_build_const_int32(gallivm, 0xf70)
	};
	lp_build_intrinsic(builder, "llvm.amdgcn.s.waitcnt",
			   ctx->voidt, args, 1, 0);
}

static void membar_emit(
		const struct lp_build_tgsi_action *action,
		struct lp_build_tgsi_context *bld_base,
		struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);

	emit_waitcnt(ctx);
}

static LLVMValueRef
shader_buffer_fetch_rsrc(struct si_shader_context *ctx,
			 const struct tgsi_full_src_register *reg)
{
	LLVMValueRef index;
	LLVMValueRef rsrc_ptr = LLVMGetParam(ctx->main_fn,
					     SI_PARAM_SHADER_BUFFERS);

	if (!reg->Register.Indirect)
		index = LLVMConstInt(ctx->i32, reg->Register.Index, 0);
	else
		index = get_bounded_indirect_index(ctx, &reg->Indirect,
						   reg->Register.Index,
						   SI_NUM_SHADER_BUFFERS);

	return build_indexed_load_const(ctx, rsrc_ptr, index);
}

d2675 6
a2680 1
static bool tgsi_is_array_image(unsigned target)
d2682 3
a2684 7
	return target == TGSI_TEXTURE_3D ||
	       target == TGSI_TEXTURE_CUBE ||
	       target == TGSI_TEXTURE_1D_ARRAY ||
	       target == TGSI_TEXTURE_2D_ARRAY ||
	       target == TGSI_TEXTURE_CUBE_ARRAY ||
	       target == TGSI_TEXTURE_2D_ARRAY_MSAA;
}
d2686 1
a2686 838
/**
 * Given a 256-bit resource descriptor, force the DCC enable bit to off.
 *
 * At least on Tonga, executing image stores on images with DCC enabled and
 * non-trivial can eventually lead to lockups. This can occur when an
 * application binds an image as read-only but then uses a shader that writes
 * to it. The OpenGL spec allows almost arbitrarily bad behavior (including
 * program termination) in this case, but it doesn't cost much to be a bit
 * nicer: disabling DCC in the shader still leads to undefined results but
 * avoids the lockup.
 */
static LLVMValueRef force_dcc_off(struct si_shader_context *ctx,
				  LLVMValueRef rsrc)
{
	if (ctx->screen->b.chip_class <= CIK) {
		return rsrc;
	} else {
		LLVMBuilderRef builder = ctx->gallivm.builder;
		LLVMValueRef i32_6 = LLVMConstInt(ctx->i32, 6, 0);
		LLVMValueRef i32_C = LLVMConstInt(ctx->i32, C_008F28_COMPRESSION_EN, 0);
		LLVMValueRef tmp;

		tmp = LLVMBuildExtractElement(builder, rsrc, i32_6, "");
		tmp = LLVMBuildAnd(builder, tmp, i32_C, "");
		return LLVMBuildInsertElement(builder, rsrc, tmp, i32_6, "");
	}
}

/**
 * Load the resource descriptor for \p image.
 */
static void
image_fetch_rsrc(
	struct lp_build_tgsi_context *bld_base,
	const struct tgsi_full_src_register *image,
	bool dcc_off,
	LLVMValueRef *rsrc)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	LLVMValueRef rsrc_ptr = LLVMGetParam(ctx->main_fn,
					     SI_PARAM_IMAGES);
	LLVMValueRef index, tmp;

	assert(image->Register.File == TGSI_FILE_IMAGE);

	if (!image->Register.Indirect) {
		const struct tgsi_shader_info *info = bld_base->info;

		index = LLVMConstInt(ctx->i32, image->Register.Index, 0);

		if (info->images_writemask & (1 << image->Register.Index) &&
		    !(info->images_buffers & (1 << image->Register.Index)))
			dcc_off = true;
	} else {
		/* From the GL_ARB_shader_image_load_store extension spec:
		 *
		 *    If a shader performs an image load, store, or atomic
		 *    operation using an image variable declared as an array,
		 *    and if the index used to select an individual element is
		 *    negative or greater than or equal to the size of the
		 *    array, the results of the operation are undefined but may
		 *    not lead to termination.
		 */
		index = get_bounded_indirect_index(ctx, &image->Indirect,
						   image->Register.Index,
						   SI_NUM_IMAGES);
	}

	tmp = build_indexed_load_const(ctx, rsrc_ptr, index);
	if (dcc_off)
		tmp = force_dcc_off(ctx, tmp);
	*rsrc = tmp;
}

static LLVMValueRef image_fetch_coords(
		struct lp_build_tgsi_context *bld_base,
		const struct tgsi_full_instruction *inst,
		unsigned src)
{
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	unsigned target = inst->Memory.Texture;
	unsigned num_coords = tgsi_util_get_texture_coord_dim(target);
	LLVMValueRef coords[4];
	LLVMValueRef tmp;
	int chan;

	for (chan = 0; chan < num_coords; ++chan) {
		tmp = lp_build_emit_fetch(bld_base, inst, src, chan);
		tmp = LLVMBuildBitCast(builder, tmp, bld_base->uint_bld.elem_type, "");
		coords[chan] = tmp;
	}

	if (num_coords == 1)
		return coords[0];

	if (num_coords == 3) {
		/* LLVM has difficulties lowering 3-element vectors. */
		coords[3] = bld_base->uint_bld.undef;
		num_coords = 4;
	}

	return lp_build_gather_values(gallivm, coords, num_coords);
}

/**
 * Append the extra mode bits that are used by image load and store.
 */
static void image_append_args(
		struct si_shader_context *ctx,
		struct lp_build_emit_data * emit_data,
		unsigned target,
		bool atomic)
{
	const struct tgsi_full_instruction *inst = emit_data->inst;
	LLVMValueRef i1false = LLVMConstInt(ctx->i1, 0, 0);
	LLVMValueRef i1true = LLVMConstInt(ctx->i1, 1, 0);
	LLVMValueRef r128 = i1false;
	LLVMValueRef da = tgsi_is_array_image(target) ? i1true : i1false;
	LLVMValueRef glc =
		inst->Memory.Qualifier & (TGSI_MEMORY_COHERENT | TGSI_MEMORY_VOLATILE) ?
		i1true : i1false;
	LLVMValueRef slc = i1false;
	LLVMValueRef lwe = i1false;

	if (atomic || (HAVE_LLVM <= 0x0309)) {
		emit_data->args[emit_data->arg_count++] = r128;
		emit_data->args[emit_data->arg_count++] = da;
		if (!atomic) {
			emit_data->args[emit_data->arg_count++] = glc;
		}
		emit_data->args[emit_data->arg_count++] = slc;
		return;
	}

	/* HAVE_LLVM >= 0x0400 */
	emit_data->args[emit_data->arg_count++] = glc;
	emit_data->args[emit_data->arg_count++] = slc;
	emit_data->args[emit_data->arg_count++] = lwe;
	emit_data->args[emit_data->arg_count++] = da;
}

/**
 * Given a 256 bit resource, extract the top half (which stores the buffer
 * resource in the case of textures and images).
 */
static LLVMValueRef extract_rsrc_top_half(
		struct si_shader_context *ctx,
		LLVMValueRef rsrc)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx->soa.bld_base;
	LLVMTypeRef v2i128 = LLVMVectorType(ctx->i128, 2);

	rsrc = LLVMBuildBitCast(gallivm->builder, rsrc, v2i128, "");
	rsrc = LLVMBuildExtractElement(gallivm->builder, rsrc, bld_base->uint_bld.one, "");
	rsrc = LLVMBuildBitCast(gallivm->builder, rsrc, ctx->v4i32, "");

	return rsrc;
}

/**
 * Append the resource and indexing arguments for buffer intrinsics.
 *
 * \param rsrc the v4i32 buffer resource
 * \param index index into the buffer (stride-based)
 * \param offset byte offset into the buffer
 */
static void buffer_append_args(
		struct si_shader_context *ctx,
		struct lp_build_emit_data *emit_data,
		LLVMValueRef rsrc,
		LLVMValueRef index,
		LLVMValueRef offset,
		bool atomic)
{
	const struct tgsi_full_instruction *inst = emit_data->inst;
	LLVMValueRef i1false = LLVMConstInt(ctx->i1, 0, 0);
	LLVMValueRef i1true = LLVMConstInt(ctx->i1, 1, 0);

	emit_data->args[emit_data->arg_count++] = rsrc;
	emit_data->args[emit_data->arg_count++] = index; /* vindex */
	emit_data->args[emit_data->arg_count++] = offset; /* voffset */
	if (!atomic) {
		emit_data->args[emit_data->arg_count++] =
			inst->Memory.Qualifier & (TGSI_MEMORY_COHERENT | TGSI_MEMORY_VOLATILE) ?
			i1true : i1false; /* glc */
	}
	emit_data->args[emit_data->arg_count++] = i1false; /* slc */
}

static void load_fetch_args(
		struct lp_build_tgsi_context * bld_base,
		struct lp_build_emit_data * emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	unsigned target = inst->Memory.Texture;
	LLVMValueRef rsrc;

	emit_data->dst_type = LLVMVectorType(bld_base->base.elem_type, 4);

	if (inst->Src[0].Register.File == TGSI_FILE_BUFFER) {
		LLVMBuilderRef builder = gallivm->builder;
		LLVMValueRef offset;
		LLVMValueRef tmp;

		rsrc = shader_buffer_fetch_rsrc(ctx, &inst->Src[0]);

		tmp = lp_build_emit_fetch(bld_base, inst, 1, 0);
		offset = LLVMBuildBitCast(builder, tmp, bld_base->uint_bld.elem_type, "");

		buffer_append_args(ctx, emit_data, rsrc, bld_base->uint_bld.zero,
				   offset, false);
	} else if (inst->Src[0].Register.File == TGSI_FILE_IMAGE) {
		LLVMValueRef coords;

		image_fetch_rsrc(bld_base, &inst->Src[0], false, &rsrc);
		coords = image_fetch_coords(bld_base, inst, 1);

		if (target == TGSI_TEXTURE_BUFFER) {
			rsrc = extract_rsrc_top_half(ctx, rsrc);
			buffer_append_args(ctx, emit_data, rsrc, coords,
					bld_base->uint_bld.zero, false);
		} else {
			emit_data->args[0] = coords;
			emit_data->args[1] = rsrc;
			emit_data->args[2] = lp_build_const_int32(gallivm, 15); /* dmask */
			emit_data->arg_count = 3;

			image_append_args(ctx, emit_data, target, false);
		}
	}
}

static void load_emit_buffer(struct si_shader_context *ctx,
			     struct lp_build_emit_data *emit_data)
{
	const struct tgsi_full_instruction *inst = emit_data->inst;
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	uint writemask = inst->Dst[0].Register.WriteMask;
	uint count = util_last_bit(writemask);
	const char *intrinsic_name;
	LLVMTypeRef dst_type;

	switch (count) {
	case 1:
		intrinsic_name = "llvm.amdgcn.buffer.load.f32";
		dst_type = ctx->f32;
		break;
	case 2:
		intrinsic_name = "llvm.amdgcn.buffer.load.v2f32";
		dst_type = LLVMVectorType(ctx->f32, 2);
		break;
	default: // 3 & 4
		intrinsic_name = "llvm.amdgcn.buffer.load.v4f32";
		dst_type = ctx->v4f32;
		count = 4;
	}

	emit_data->output[emit_data->chan] = lp_build_intrinsic(
			builder, intrinsic_name, dst_type,
			emit_data->args, emit_data->arg_count,
			LLVMReadOnlyAttribute);
}

static LLVMValueRef get_memory_ptr(struct si_shader_context *ctx,
                                   const struct tgsi_full_instruction *inst,
                                   LLVMTypeRef type, int arg)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	LLVMValueRef offset, ptr;
	int addr_space;

	offset = lp_build_emit_fetch(&ctx->soa.bld_base, inst, arg, 0);
	offset = LLVMBuildBitCast(builder, offset, ctx->i32, "");

	ptr = ctx->shared_memory;
	ptr = LLVMBuildGEP(builder, ptr, &offset, 1, "");
	addr_space = LLVMGetPointerAddressSpace(LLVMTypeOf(ptr));
	ptr = LLVMBuildBitCast(builder, ptr, LLVMPointerType(type, addr_space), "");

	return ptr;
}

static void load_emit_memory(
		struct si_shader_context *ctx,
		struct lp_build_emit_data *emit_data)
{
	const struct tgsi_full_instruction *inst = emit_data->inst;
	struct lp_build_context *base = &ctx->soa.bld_base.base;
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	unsigned writemask = inst->Dst[0].Register.WriteMask;
	LLVMValueRef channels[4], ptr, derived_ptr, index;
	int chan;

	ptr = get_memory_ptr(ctx, inst, base->elem_type, 1);

	for (chan = 0; chan < 4; ++chan) {
		if (!(writemask & (1 << chan))) {
			channels[chan] = LLVMGetUndef(base->elem_type);
			continue;
		}

		index = lp_build_const_int32(gallivm, chan);
		derived_ptr = LLVMBuildGEP(builder, ptr, &index, 1, "");
		channels[chan] = LLVMBuildLoad(builder, derived_ptr, "");
	}
	emit_data->output[emit_data->chan] = lp_build_gather_values(gallivm, channels, 4);
}

static void get_image_intr_name(const char *base_name,
				LLVMTypeRef data_type,
				LLVMTypeRef coords_type,
				LLVMTypeRef rsrc_type,
				char *out_name, unsigned out_len)
{
	char coords_type_name[8];

	build_type_name_for_intr(coords_type, coords_type_name,
			    sizeof(coords_type_name));

	if (HAVE_LLVM <= 0x0309) {
		snprintf(out_name, out_len, "%s.%s", base_name, coords_type_name);
	} else {
		char data_type_name[8];
		char rsrc_type_name[8];

		build_type_name_for_intr(data_type, data_type_name,
					sizeof(data_type_name));
		build_type_name_for_intr(rsrc_type, rsrc_type_name,
					sizeof(rsrc_type_name));
		snprintf(out_name, out_len, "%s.%s.%s.%s", base_name,
			 data_type_name, coords_type_name, rsrc_type_name);
	}
}

static void load_emit(
		const struct lp_build_tgsi_action *action,
		struct lp_build_tgsi_context *bld_base,
		struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	char intrinsic_name[64];

	if (inst->Src[0].Register.File == TGSI_FILE_MEMORY) {
		load_emit_memory(ctx, emit_data);
		return;
	}

	if (inst->Memory.Qualifier & TGSI_MEMORY_VOLATILE)
		emit_waitcnt(ctx);

	if (inst->Src[0].Register.File == TGSI_FILE_BUFFER) {
		load_emit_buffer(ctx, emit_data);
		return;
	}

	if (inst->Memory.Texture == TGSI_TEXTURE_BUFFER) {
		emit_data->output[emit_data->chan] =
			lp_build_intrinsic(
				builder, "llvm.amdgcn.buffer.load.format.v4f32", emit_data->dst_type,
				emit_data->args, emit_data->arg_count,
				LLVMReadOnlyAttribute);
	} else {
		get_image_intr_name("llvm.amdgcn.image.load",
				emit_data->dst_type,		/* vdata */
				LLVMTypeOf(emit_data->args[0]), /* coords */
				LLVMTypeOf(emit_data->args[1]), /* rsrc */
				intrinsic_name, sizeof(intrinsic_name));

		emit_data->output[emit_data->chan] =
			lp_build_intrinsic(
				builder, intrinsic_name, emit_data->dst_type,
				emit_data->args, emit_data->arg_count,
				LLVMReadOnlyAttribute);
	}
}

static void store_fetch_args(
		struct lp_build_tgsi_context * bld_base,
		struct lp_build_emit_data * emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	struct tgsi_full_src_register memory;
	LLVMValueRef chans[4];
	LLVMValueRef data;
	LLVMValueRef rsrc;
	unsigned chan;

	emit_data->dst_type = LLVMVoidTypeInContext(gallivm->context);

	for (chan = 0; chan < 4; ++chan) {
		chans[chan] = lp_build_emit_fetch(bld_base, inst, 1, chan);
	}
	data = lp_build_gather_values(gallivm, chans, 4);

	emit_data->args[emit_data->arg_count++] = data;

	memory = tgsi_full_src_register_from_dst(&inst->Dst[0]);

	if (inst->Dst[0].Register.File == TGSI_FILE_BUFFER) {
		LLVMValueRef offset;
		LLVMValueRef tmp;

		rsrc = shader_buffer_fetch_rsrc(ctx, &memory);

		tmp = lp_build_emit_fetch(bld_base, inst, 0, 0);
		offset = LLVMBuildBitCast(builder, tmp, bld_base->uint_bld.elem_type, "");

		buffer_append_args(ctx, emit_data, rsrc, bld_base->uint_bld.zero,
				   offset, false);
	} else if (inst->Dst[0].Register.File == TGSI_FILE_IMAGE) {
		unsigned target = inst->Memory.Texture;
		LLVMValueRef coords;

		coords = image_fetch_coords(bld_base, inst, 0);

		if (target == TGSI_TEXTURE_BUFFER) {
			image_fetch_rsrc(bld_base, &memory, false, &rsrc);

			rsrc = extract_rsrc_top_half(ctx, rsrc);
			buffer_append_args(ctx, emit_data, rsrc, coords,
					bld_base->uint_bld.zero, false);
		} else {
			emit_data->args[1] = coords;
			image_fetch_rsrc(bld_base, &memory, true, &emit_data->args[2]);
			emit_data->args[3] = lp_build_const_int32(gallivm, 15); /* dmask */
			emit_data->arg_count = 4;

			image_append_args(ctx, emit_data, target, false);
		}
	}
}

static void store_emit_buffer(
		struct si_shader_context *ctx,
		struct lp_build_emit_data *emit_data)
{
	const struct tgsi_full_instruction *inst = emit_data->inst;
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	struct lp_build_context *uint_bld = &ctx->soa.bld_base.uint_bld;
	LLVMValueRef base_data = emit_data->args[0];
	LLVMValueRef base_offset = emit_data->args[3];
	unsigned writemask = inst->Dst[0].Register.WriteMask;

	while (writemask) {
		int start, count;
		const char *intrinsic_name;
		LLVMValueRef data;
		LLVMValueRef offset;
		LLVMValueRef tmp;

		u_bit_scan_consecutive_range(&writemask, &start, &count);

		/* Due to an LLVM limitation, split 3-element writes
		 * into a 2-element and a 1-element write. */
		if (count == 3) {
			writemask |= 1 << (start + 2);
			count = 2;
		}

		if (count == 4) {
			data = base_data;
			intrinsic_name = "llvm.amdgcn.buffer.store.v4f32";
		} else if (count == 2) {
			LLVMTypeRef v2f32 = LLVMVectorType(ctx->f32, 2);

			tmp = LLVMBuildExtractElement(
				builder, base_data,
				lp_build_const_int32(gallivm, start), "");
			data = LLVMBuildInsertElement(
				builder, LLVMGetUndef(v2f32), tmp,
				uint_bld->zero, "");

			tmp = LLVMBuildExtractElement(
				builder, base_data,
				lp_build_const_int32(gallivm, start + 1), "");
			data = LLVMBuildInsertElement(
				builder, data, tmp, uint_bld->one, "");

			intrinsic_name = "llvm.amdgcn.buffer.store.v2f32";
		} else {
			assert(count == 1);
			data = LLVMBuildExtractElement(
				builder, base_data,
				lp_build_const_int32(gallivm, start), "");
			intrinsic_name = "llvm.amdgcn.buffer.store.f32";
		}

		offset = base_offset;
		if (start != 0) {
			offset = LLVMBuildAdd(
				builder, offset,
				lp_build_const_int32(gallivm, start * 4), "");
		}

		emit_data->args[0] = data;
		emit_data->args[3] = offset;

		lp_build_intrinsic(
			builder, intrinsic_name, emit_data->dst_type,
			emit_data->args, emit_data->arg_count, 0);
	}
}

static void store_emit_memory(
		struct si_shader_context *ctx,
		struct lp_build_emit_data *emit_data)
{
	const struct tgsi_full_instruction *inst = emit_data->inst;
	struct gallivm_state *gallivm = &ctx->gallivm;
	struct lp_build_context *base = &ctx->soa.bld_base.base;
	LLVMBuilderRef builder = gallivm->builder;
	unsigned writemask = inst->Dst[0].Register.WriteMask;
	LLVMValueRef ptr, derived_ptr, data, index;
	int chan;

	ptr = get_memory_ptr(ctx, inst, base->elem_type, 0);

	for (chan = 0; chan < 4; ++chan) {
		if (!(writemask & (1 << chan))) {
			continue;
		}
		data = lp_build_emit_fetch(&ctx->soa.bld_base, inst, 1, chan);
		index = lp_build_const_int32(gallivm, chan);
		derived_ptr = LLVMBuildGEP(builder, ptr, &index, 1, "");
		LLVMBuildStore(builder, data, derived_ptr);
	}
}

static void store_emit(
		const struct lp_build_tgsi_action *action,
		struct lp_build_tgsi_context *bld_base,
		struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	unsigned target = inst->Memory.Texture;
	char intrinsic_name[64];

	if (inst->Dst[0].Register.File == TGSI_FILE_MEMORY) {
		store_emit_memory(ctx, emit_data);
		return;
	}

	if (inst->Memory.Qualifier & TGSI_MEMORY_VOLATILE)
		emit_waitcnt(ctx);

	if (inst->Dst[0].Register.File == TGSI_FILE_BUFFER) {
		store_emit_buffer(ctx, emit_data);
		return;
	}

	if (target == TGSI_TEXTURE_BUFFER) {
		emit_data->output[emit_data->chan] = lp_build_intrinsic(
			builder, "llvm.amdgcn.buffer.store.format.v4f32",
			emit_data->dst_type, emit_data->args,
			emit_data->arg_count, 0);
	} else {
		get_image_intr_name("llvm.amdgcn.image.store",
				LLVMTypeOf(emit_data->args[0]), /* vdata */
				LLVMTypeOf(emit_data->args[1]), /* coords */
				LLVMTypeOf(emit_data->args[2]), /* rsrc */
				intrinsic_name, sizeof(intrinsic_name));

		emit_data->output[emit_data->chan] =
			lp_build_intrinsic(
				builder, intrinsic_name, emit_data->dst_type,
				emit_data->args, emit_data->arg_count, 0);
	}
}

static void atomic_fetch_args(
		struct lp_build_tgsi_context * bld_base,
		struct lp_build_emit_data * emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	LLVMValueRef data1, data2;
	LLVMValueRef rsrc;
	LLVMValueRef tmp;

	emit_data->dst_type = bld_base->base.elem_type;

	tmp = lp_build_emit_fetch(bld_base, inst, 2, 0);
	data1 = LLVMBuildBitCast(builder, tmp, bld_base->uint_bld.elem_type, "");

	if (inst->Instruction.Opcode == TGSI_OPCODE_ATOMCAS) {
		tmp = lp_build_emit_fetch(bld_base, inst, 3, 0);
		data2 = LLVMBuildBitCast(builder, tmp, bld_base->uint_bld.elem_type, "");
	}

	/* llvm.amdgcn.image/buffer.atomic.cmpswap reflect the hardware order
	 * of arguments, which is reversed relative to TGSI (and GLSL)
	 */
	if (inst->Instruction.Opcode == TGSI_OPCODE_ATOMCAS)
		emit_data->args[emit_data->arg_count++] = data2;
	emit_data->args[emit_data->arg_count++] = data1;

	if (inst->Src[0].Register.File == TGSI_FILE_BUFFER) {
		LLVMValueRef offset;

		rsrc = shader_buffer_fetch_rsrc(ctx, &inst->Src[0]);

		tmp = lp_build_emit_fetch(bld_base, inst, 1, 0);
		offset = LLVMBuildBitCast(builder, tmp, bld_base->uint_bld.elem_type, "");

		buffer_append_args(ctx, emit_data, rsrc, bld_base->uint_bld.zero,
				   offset, true);
	} else if (inst->Src[0].Register.File == TGSI_FILE_IMAGE) {
		unsigned target = inst->Memory.Texture;
		LLVMValueRef coords;

		image_fetch_rsrc(bld_base, &inst->Src[0],
				 target != TGSI_TEXTURE_BUFFER, &rsrc);
		coords = image_fetch_coords(bld_base, inst, 1);

		if (target == TGSI_TEXTURE_BUFFER) {
			rsrc = extract_rsrc_top_half(ctx, rsrc);
			buffer_append_args(ctx, emit_data, rsrc, coords,
					   bld_base->uint_bld.zero, true);
		} else {
			emit_data->args[emit_data->arg_count++] = coords;
			emit_data->args[emit_data->arg_count++] = rsrc;

			image_append_args(ctx, emit_data, target, true);
		}
	}
}

static void atomic_emit_memory(struct si_shader_context *ctx,
                               struct lp_build_emit_data *emit_data) {
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	LLVMValueRef ptr, result, arg;

	ptr = get_memory_ptr(ctx, inst, ctx->i32, 1);

	arg = lp_build_emit_fetch(&ctx->soa.bld_base, inst, 2, 0);
	arg = LLVMBuildBitCast(builder, arg, ctx->i32, "");

	if (inst->Instruction.Opcode == TGSI_OPCODE_ATOMCAS) {
		LLVMValueRef new_data;
		new_data = lp_build_emit_fetch(&ctx->soa.bld_base,
		                               inst, 3, 0);

		new_data = LLVMBuildBitCast(builder, new_data, ctx->i32, "");

#if HAVE_LLVM >= 0x309
		result = LLVMBuildAtomicCmpXchg(builder, ptr, arg, new_data,
		                       LLVMAtomicOrderingSequentiallyConsistent,
		                       LLVMAtomicOrderingSequentiallyConsistent,
		                       false);
#endif

		result = LLVMBuildExtractValue(builder, result, 0, "");
	} else {
		LLVMAtomicRMWBinOp op;

		switch(inst->Instruction.Opcode) {
			case TGSI_OPCODE_ATOMUADD:
				op = LLVMAtomicRMWBinOpAdd;
				break;
			case TGSI_OPCODE_ATOMXCHG:
				op = LLVMAtomicRMWBinOpXchg;
				break;
			case TGSI_OPCODE_ATOMAND:
				op = LLVMAtomicRMWBinOpAnd;
				break;
			case TGSI_OPCODE_ATOMOR:
				op = LLVMAtomicRMWBinOpOr;
				break;
			case TGSI_OPCODE_ATOMXOR:
				op = LLVMAtomicRMWBinOpXor;
				break;
			case TGSI_OPCODE_ATOMUMIN:
				op = LLVMAtomicRMWBinOpUMin;
				break;
			case TGSI_OPCODE_ATOMUMAX:
				op = LLVMAtomicRMWBinOpUMax;
				break;
			case TGSI_OPCODE_ATOMIMIN:
				op = LLVMAtomicRMWBinOpMin;
				break;
			case TGSI_OPCODE_ATOMIMAX:
				op = LLVMAtomicRMWBinOpMax;
				break;
			default:
				unreachable("unknown atomic opcode");
		}

		result = LLVMBuildAtomicRMW(builder, op, ptr, arg,
		                       LLVMAtomicOrderingSequentiallyConsistent,
		                       false);
	}
	emit_data->output[emit_data->chan] = LLVMBuildBitCast(builder, result, emit_data->dst_type, "");
}

static void atomic_emit(
		const struct lp_build_tgsi_action *action,
		struct lp_build_tgsi_context *bld_base,
		struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction * inst = emit_data->inst;
	char intrinsic_name[40];
	LLVMValueRef tmp;

	if (inst->Src[0].Register.File == TGSI_FILE_MEMORY) {
		atomic_emit_memory(ctx, emit_data);
		return;
	}

	if (inst->Src[0].Register.File == TGSI_FILE_BUFFER ||
	    inst->Memory.Texture == TGSI_TEXTURE_BUFFER) {
		snprintf(intrinsic_name, sizeof(intrinsic_name),
			 "llvm.amdgcn.buffer.atomic.%s", action->intr_name);
	} else {
		LLVMValueRef coords;
		char coords_type[8];

		if (inst->Instruction.Opcode == TGSI_OPCODE_ATOMCAS)
			coords = emit_data->args[2];
		else
			coords = emit_data->args[1];

		build_type_name_for_intr(LLVMTypeOf(coords), coords_type, sizeof(coords_type));
		snprintf(intrinsic_name, sizeof(intrinsic_name),
			 "llvm.amdgcn.image.atomic.%s.%s",
			 action->intr_name, coords_type);
	}

	tmp = lp_build_intrinsic(
		builder, intrinsic_name, bld_base->uint_bld.elem_type,
		emit_data->args, emit_data->arg_count, 0);
	emit_data->output[emit_data->chan] =
		LLVMBuildBitCast(builder, tmp, bld_base->base.elem_type, "");
}

static void resq_fetch_args(
		struct lp_build_tgsi_context * bld_base,
		struct lp_build_emit_data * emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	const struct tgsi_full_instruction *inst = emit_data->inst;
	const struct tgsi_full_src_register *reg = &inst->Src[0];

	emit_data->dst_type = ctx->v4i32;

	if (reg->Register.File == TGSI_FILE_BUFFER) {
		emit_data->args[0] = shader_buffer_fetch_rsrc(ctx, reg);
		emit_data->arg_count = 1;
	} else if (inst->Memory.Texture == TGSI_TEXTURE_BUFFER) {
		image_fetch_rsrc(bld_base, reg, false, &emit_data->args[0]);
		emit_data->arg_count = 1;
	} else {
		emit_data->args[0] = bld_base->uint_bld.zero; /* mip level */
		image_fetch_rsrc(bld_base, reg, false, &emit_data->args[1]);
		emit_data->args[2] = lp_build_const_int32(gallivm, 15); /* dmask */
		emit_data->args[3] = bld_base->uint_bld.zero; /* unorm */
		emit_data->args[4] = bld_base->uint_bld.zero; /* r128 */
		emit_data->args[5] = tgsi_is_array_image(inst->Memory.Texture) ?
			bld_base->uint_bld.one : bld_base->uint_bld.zero; /* da */
		emit_data->args[6] = bld_base->uint_bld.zero; /* glc */
		emit_data->args[7] = bld_base->uint_bld.zero; /* slc */
		emit_data->args[8] = bld_base->uint_bld.zero; /* tfe */
		emit_data->args[9] = bld_base->uint_bld.zero; /* lwe */
		emit_data->arg_count = 10;
	}
}

static void resq_emit(
		const struct lp_build_tgsi_action *action,
		struct lp_build_tgsi_context *bld_base,
		struct lp_build_emit_data *emit_data)
{
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	const struct tgsi_full_instruction *inst = emit_data->inst;
	LLVMValueRef out;

	if (inst->Src[0].Register.File == TGSI_FILE_BUFFER) {
		out = LLVMBuildExtractElement(builder, emit_data->args[0],
					      lp_build_const_int32(gallivm, 2), "");
	} else if (inst->Memory.Texture == TGSI_TEXTURE_BUFFER) {
		out = get_buffer_size(bld_base, emit_data->args[0]);
	} else {
		out = lp_build_intrinsic(
			builder, "llvm.SI.getresinfo.i32", emit_data->dst_type,
			emit_data->args, emit_data->arg_count,
			LLVMReadNoneAttribute);

		/* Divide the number of layers by 6 to get the number of cubes. */
		if (inst->Memory.Texture == TGSI_TEXTURE_CUBE_ARRAY) {
			LLVMValueRef imm2 = lp_build_const_int32(gallivm, 2);
			LLVMValueRef imm6 = lp_build_const_int32(gallivm, 6);

			LLVMValueRef z = LLVMBuildExtractElement(builder, out, imm2, "");
			z = LLVMBuildSDiv(builder, z, imm6, "");
			out = LLVMBuildInsertElement(builder, out, z, imm2, "");
		}
	}

	emit_data->output[emit_data->chan] = out;
}

static void set_tex_fetch_args(struct si_shader_context *ctx,
			       struct lp_build_emit_data *emit_data,
			       unsigned opcode, unsigned target,
			       LLVMValueRef res_ptr, LLVMValueRef samp_ptr,
			       LLVMValueRef *param, unsigned count,
			       unsigned dmask)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	unsigned num_args;
	unsigned is_rect = target == TGSI_TEXTURE_RECT;

	/* Pad to power of two vector */
d2738 3
a2740 3
static LLVMValueRef load_sampler_desc_custom(struct si_shader_context *ctx,
					     LLVMValueRef list, LLVMValueRef index,
					     enum desc_type type)
d2742 1
a2742 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d2767 1
a2767 1
static LLVMValueRef load_sampler_desc(struct si_shader_context *ctx,
d2770 1
a2770 1
	LLVMValueRef list = LLVMGetParam(ctx->main_fn,
d2773 1
a2773 30
	return load_sampler_desc_custom(ctx, list, index, type);
}

/* Disable anisotropic filtering if BASE_LEVEL == LAST_LEVEL.
 *
 * SI-CI:
 *   If BASE_LEVEL == LAST_LEVEL, the shader must disable anisotropic
 *   filtering manually. The driver sets img7 to a mask clearing
 *   MAX_ANISO_RATIO if BASE_LEVEL == LAST_LEVEL. The shader must do:
 *     s_and_b32 samp0, samp0, img7
 *
 * VI:
 *   The ANISO_OVERRIDE sampler field enables this fix in TA.
 */
static LLVMValueRef sici_fix_sampler_aniso(struct si_shader_context *ctx,
					   LLVMValueRef res, LLVMValueRef samp)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMValueRef img7, samp0;

	if (ctx->screen->b.chip_class >= VI)
		return samp;

	img7 = LLVMBuildExtractElement(builder, res,
				       LLVMConstInt(ctx->i32, 7, 0), "");
	samp0 = LLVMBuildExtractElement(builder, samp,
					LLVMConstInt(ctx->i32, 0, 0), "");
	samp0 = LLVMBuildAnd(builder, samp0, img7, "");
	return LLVMBuildInsertElement(builder, samp, samp0,
				      LLVMConstInt(ctx->i32, 0, 0), "");
a2785 1
	LLVMValueRef index;
d2792 1
d2794 1
a2794 7
		index = get_bounded_indirect_index(ctx,
						   &reg->Indirect,
						   reg->Register.Index,
						   SI_NUM_SAMPLERS);
	} else {
		index = LLVMConstInt(ctx->i32, sampler_index, 0);
	}
d2796 1
a2796 1
	*res_ptr = load_sampler_desc(ctx, index, DESC_IMAGE);
d2798 2
a2799 3
	if (target == TGSI_TEXTURE_2D_MSAA ||
	    target == TGSI_TEXTURE_2D_ARRAY_MSAA) {
		if (samp_ptr)
d2801 5
a2805 2
		if (fmask_ptr)
			*fmask_ptr = load_sampler_desc(ctx, index, DESC_FMASK);
d2807 3
a2809 6
		if (samp_ptr) {
			*samp_ptr = load_sampler_desc(ctx, index, DESC_SAMPLER);
			*samp_ptr = sici_fix_sampler_aniso(ctx, *res_ptr, *samp_ptr);
		}
		if (fmask_ptr)
			*fmask_ptr = NULL;
d2813 1
a2813 1
static void txq_fetch_args(
a2820 61
	unsigned target = inst->Texture.Texture;
	LLVMValueRef res_ptr;
	LLVMValueRef address;

	tex_fetch_ptrs(bld_base, emit_data, &res_ptr, NULL, NULL);

	if (target == TGSI_TEXTURE_BUFFER) {
		/* Read the size from the buffer descriptor directly. */
		LLVMValueRef res = LLVMBuildBitCast(builder, res_ptr, ctx->v8i32, "");
		emit_data->args[0] = get_buffer_size(bld_base, res);
		return;
	}

	/* Textures - set the mip level. */
	address = lp_build_emit_fetch(bld_base, inst, 0, TGSI_CHAN_X);

	set_tex_fetch_args(ctx, emit_data, TGSI_OPCODE_TXQ, target, res_ptr,
			   NULL, &address, 1, 0xf);
}

static void txq_emit(const struct lp_build_tgsi_action *action,
		     struct lp_build_tgsi_context *bld_base,
		     struct lp_build_emit_data *emit_data)
{
	struct lp_build_context *base = &bld_base->base;
	unsigned target = emit_data->inst->Texture.Texture;

	if (target == TGSI_TEXTURE_BUFFER) {
		/* Just return the buffer size. */
		emit_data->output[emit_data->chan] = emit_data->args[0];
		return;
	}

	emit_data->output[emit_data->chan] = lp_build_intrinsic(
		base->gallivm->builder, "llvm.SI.getresinfo.i32",
		emit_data->dst_type, emit_data->args, emit_data->arg_count,
		LLVMReadNoneAttribute);

	/* Divide the number of layers by 6 to get the number of cubes. */
	if (target == TGSI_TEXTURE_CUBE_ARRAY ||
	    target == TGSI_TEXTURE_SHADOWCUBE_ARRAY) {
		LLVMBuilderRef builder = bld_base->base.gallivm->builder;
		LLVMValueRef two = lp_build_const_int32(bld_base->base.gallivm, 2);
		LLVMValueRef six = lp_build_const_int32(bld_base->base.gallivm, 6);

		LLVMValueRef v4 = emit_data->output[emit_data->chan];
		LLVMValueRef z = LLVMBuildExtractElement(builder, v4, two, "");
		z = LLVMBuildSDiv(builder, z, six, "");

		emit_data->output[emit_data->chan] =
			LLVMBuildInsertElement(builder, v4, z, two, "");
	}
}

static void tex_fetch_args(
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = bld_base->base.gallivm;
	const struct tgsi_full_instruction *inst = emit_data->inst;
d2825 2
a2826 2
	unsigned num_coords = tgsi_util_get_texture_coord_dim(target);
	int ref_pos = tgsi_util_get_shadow_ref_src_index(target);
d2836 35
a2935 2
		LLVMValueRef z;

d2937 1
a2937 1
			z = lp_build_emit_fetch(bld_base, inst, 1, TGSI_CHAN_X);
d2940 1
a2940 1
			z = coords[ref_pos];
a2941 12

		/* TC-compatible HTILE promotes Z16 and Z24 to Z32_FLOAT,
		 * so the depth comparison value isn't clamped for Z16 and
		 * Z24 anymore. Do it manually here.
		 *
		 * It's unnecessary if the original texture format was
		 * Z32_FLOAT, but we don't know that here.
		 */
		if (ctx->screen->b.chip_class == VI)
			z = si_llvm_saturate(bld_base, z);

		address[count++] = z;
d2991 1
a2991 1
		si_prepare_cube_coords(bld_base, emit_data, coords, derivs);
a3168 69
/* Gather4 should follow the same rules as bilinear filtering, but the hardware
 * incorrectly forces nearest filtering if the texture format is integer.
 * The only effect it has on Gather4, which always returns 4 texels for
 * bilinear filtering, is that the final coordinates are off by 0.5 of
 * the texel size.
 *
 * The workaround is to subtract 0.5 from the unnormalized coordinates,
 * or (0.5 / size) from the normalized coordinates.
 */
static void si_lower_gather4_integer(struct si_shader_context *ctx,
				     struct lp_build_emit_data *emit_data,
				     const char *intr_name,
				     unsigned coord_vgpr_index)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMValueRef coord = emit_data->args[0];
	LLVMValueRef half_texel[2];
	int c;

	if (emit_data->inst->Texture.Texture == TGSI_TEXTURE_RECT ||
	    emit_data->inst->Texture.Texture == TGSI_TEXTURE_SHADOWRECT) {
		half_texel[0] = half_texel[1] = LLVMConstReal(ctx->f32, -0.5);
	} else {
		struct tgsi_full_instruction txq_inst = {};
		struct lp_build_emit_data txq_emit_data = {};

		/* Query the texture size. */
		txq_inst.Texture.Texture = emit_data->inst->Texture.Texture;
		txq_emit_data.inst = &txq_inst;
		txq_emit_data.dst_type = ctx->v4i32;
		set_tex_fetch_args(ctx, &txq_emit_data, TGSI_OPCODE_TXQ,
				   txq_inst.Texture.Texture,
				   emit_data->args[1], NULL,
				   &ctx->soa.bld_base.uint_bld.zero,
				   1, 0xf);
		txq_emit(NULL, &ctx->soa.bld_base, &txq_emit_data);

		/* Compute -0.5 / size. */
		for (c = 0; c < 2; c++) {
			half_texel[c] =
				LLVMBuildExtractElement(builder, txq_emit_data.output[0],
							LLVMConstInt(ctx->i32, c, 0), "");
			half_texel[c] = LLVMBuildUIToFP(builder, half_texel[c], ctx->f32, "");
			half_texel[c] =
				lp_build_emit_llvm_unary(&ctx->soa.bld_base,
							 TGSI_OPCODE_RCP, half_texel[c]);
			half_texel[c] = LLVMBuildFMul(builder, half_texel[c],
						      LLVMConstReal(ctx->f32, -0.5), "");
		}
	}

	for (c = 0; c < 2; c++) {
		LLVMValueRef tmp;
		LLVMValueRef index = LLVMConstInt(ctx->i32, coord_vgpr_index + c, 0);

		tmp = LLVMBuildExtractElement(builder, coord, index, "");
		tmp = LLVMBuildBitCast(builder, tmp, ctx->f32, "");
		tmp = LLVMBuildFAdd(builder, tmp, half_texel[c], "");
		tmp = LLVMBuildBitCast(builder, tmp, ctx->i32, "");
		coord = LLVMBuildInsertElement(builder, coord, tmp, index, "");
	}

	emit_data->args[0] = coord;
	emit_data->output[emit_data->chan] =
		lp_build_intrinsic(builder, intr_name, emit_data->dst_type,
				   emit_data->args, emit_data->arg_count,
				   LLVMReadNoneAttribute);
}

a3172 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
d3174 2
a3175 3
	const struct tgsi_full_instruction *inst = emit_data->inst;
	unsigned opcode = inst->Instruction.Opcode;
	unsigned target = inst->Texture.Texture;
d3177 1
a3177 1
	bool has_offset = inst->Texture.NumOffsets > 0;
d3183 6
d3194 1
a3194 1
			LLVMReadNoneAttribute);
d3207 5
a3219 2
		if (ctx->type != PIPE_SHADER_FRAGMENT)
			infix = ".lz";
a3222 1
		assert(ctx->type == PIPE_SHADER_FRAGMENT);
a3233 1
		infix = ".lz";
d3240 6
d3247 1
a3247 2
	build_type_name_for_intr(LLVMTypeOf(emit_data->args[0]), type, sizeof(type));
	sprintf(intr_name, "%s%s%s%s.%s",
d3251 12
a3262 8
	/* The hardware needs special lowering for Gather4 with integer formats. */
	if (opcode == TGSI_OPCODE_TG4) {
		struct tgsi_shader_info *info = &ctx->shader->selector->info;
		/* This will also work with non-constant indexing because of how
		 * glsl_to_tgsi works and we intent to preserve that behavior.
		 */
		const unsigned src_idx = 2;
		unsigned sampler = inst->Src[src_idx].Register.Index;
d3264 3
a3266 1
		assert(inst->Src[src_idx].Register.File == TGSI_FILE_SAMPLER);
d3268 2
a3269 10
		if (info->sampler_type[sampler] == TGSI_RETURN_TYPE_SINT ||
		    info->sampler_type[sampler] == TGSI_RETURN_TYPE_UINT) {
			/* Texture coordinates start after:
			 *   {offset, bias, z-compare, derivatives}
			 * Only the offset and z-compare can occur here.
			 */
			si_lower_gather4_integer(ctx, emit_data, intr_name,
						 (int)has_offset + (int)is_shadow);
			return;
		}
a3270 5

	emit_data->output[emit_data->chan] = lp_build_intrinsic(
		base->gallivm->builder, intr_name, emit_data->dst_type,
		emit_data->args, emit_data->arg_count,
		LLVMReadNoneAttribute);
d3338 7
a3344 2
	unsigned opcode = emit_data->info->opcode;
	LLVMValueRef thread_id, tl, trbl, tl_tid, trbl_tid, val, args[2];
d3348 5
a3352 1
	thread_id = get_thread_id(ctx);
d3361 4
a3364 2
	tl_tid = LLVMBuildAnd(gallivm->builder, thread_id,
				lp_build_const_int32(gallivm, mask), "");
d3368 1
a3368 1
	trbl_tid = LLVMBuildAdd(gallivm->builder, tl_tid,
d3370 2
d3373 2
a3374 1
	val = LLVMBuildBitCast(gallivm->builder, emit_data->args[0], ctx->i32, "");
d3376 9
a3384 15
	if (ctx->screen->has_ds_bpermute) {
		args[0] = LLVMBuildMul(gallivm->builder, tl_tid,
				       lp_build_const_int32(gallivm, 4), "");
		args[1] = val;
		tl = lp_build_intrinsic(gallivm->builder,
					"llvm.amdgcn.ds.bpermute", ctx->i32,
					args, 2, LLVMReadNoneAttribute);

		args[0] = LLVMBuildMul(gallivm->builder, trbl_tid,
				       lp_build_const_int32(gallivm, 4), "");
		trbl = lp_build_intrinsic(gallivm->builder,
					  "llvm.amdgcn.ds.bpermute", ctx->i32,
					  args, 2, LLVMReadNoneAttribute);
	} else {
		LLVMValueRef store_ptr, load_ptr0, load_ptr1;
d3386 5
a3390 3
		store_ptr = build_gep0(ctx, ctx->lds, thread_id);
		load_ptr0 = build_gep0(ctx, ctx->lds, tl_tid);
		load_ptr1 = build_gep0(ctx, ctx->lds, trbl_tid);
a3391 1
		LLVMBuildStore(gallivm->builder, val, store_ptr);
d3393 2
d3396 3
d3401 1
a3401 5
	tl = LLVMBuildBitCast(gallivm->builder, tl, ctx->f32, "");
	trbl = LLVMBuildBitCast(gallivm->builder, trbl,	ctx->f32, "");

	emit_data->output[emit_data->chan] =
		LLVMBuildFSub(gallivm->builder, trbl, tl, "");
d3415 58
a3472 2
	LLVMValueRef result[4], a;
	unsigned i;
d3474 1
a3474 5
	for (i = 0; i < 2; i++) {
		a = LLVMBuildExtractElement(gallivm->builder, interp_ij,
					    LLVMConstInt(ctx->i32, i, 0), "");
		result[i] = lp_build_emit_llvm_unary(bld_base, TGSI_OPCODE_DDX, a);
		result[2+i] = lp_build_emit_llvm_unary(bld_base, TGSI_OPCODE_DDY, a);
d3509 1
a3509 1
		sample_position = load_sample_position(ctx, sample_id);
d3538 1
a3538 1
	LLVMValueRef params = LLVMGetParam(ctx->main_fn, SI_PARAM_PRIM_MASK);
d3555 1
a3555 1
		interp_param = get_interp_param(ctx, interp_param_idx);
d3603 1
a3603 1
	for (chan = 0; chan < 4; chan++) {
d3619 1
a3619 1
					   LLVMReadNoneAttribute);
d3647 1
a3647 1
	LLVMValueRef soffset = LLVMGetParam(ctx->main_fn,
d3680 1
a3680 1
			ctx->soa.outputs[i];
d3709 1
a3709 1
	args[1] = LLVMGetParam(ctx->main_fn, SI_PARAM_GS_WAVE_ID);
d3711 1
a3711 1
			   ctx->voidt, args, 2, 0);
d3728 1
a3728 1
	args[1] = LLVMGetParam(ctx->main_fn, SI_PARAM_GS_WAVE_ID);
d3730 1
a3730 1
			   ctx->voidt, args, 2, 0);
a3739 8
	/* The real barrier instruction isn’t needed, because an entire patch
	 * always fits into a single wave.
	 */
	if (ctx->type == PIPE_SHADER_TESS_CTRL) {
		emit_optimization_barrier(ctx);
		return;
	}

d3743 1
a3743 1
			   ctx->voidt, NULL, 0, 0);
d3759 1
a3759 1
			       int last_sgpr)
d3763 4
a3766 4
	si_llvm_create_func(ctx, returns, num_returns,
			    params, num_params);
	si_llvm_shader_type(ctx->main_fn, ctx->type);
	ctx->return_value = LLVMGetUndef(ctx->return_type);
d3769 1
a3769 1
		LLVMValueRef P = LLVMGetParam(ctx->main_fn, i);
d3771 3
a3773 8
		/* The combination of:
		 * - ByVal
		 * - dereferenceable
		 * - invariant.load
		 * allows the optimization passes to move loads and reduces
		 * SGPR spilling significantly.
		 */
		if (LLVMGetTypeKind(LLVMTypeOf(P)) == LLVMPointerTypeKind) {
d3775 1
a3775 2
			lp_add_attr_dereferenceable(P, UINT64_MAX);
		} else
a3777 16

	if (ctx->screen->b.debug_flags & DBG_UNSAFE_MATH) {
		/* These were copied from some LLVM test. */
		LLVMAddTargetDependentFunctionAttr(ctx->main_fn,
						   "less-precise-fpmad",
						   "true");
		LLVMAddTargetDependentFunctionAttr(ctx->main_fn,
						   "no-infs-fp-math",
						   "true");
		LLVMAddTargetDependentFunctionAttr(ctx->main_fn,
						   "no-nans-fp-math",
						   "true");
		LLVMAddTargetDependentFunctionAttr(ctx->main_fn,
						   "unsafe-fp-math",
						   "true");
	}
d3782 2
a3783 1
	struct gallivm_state *gallivm = ctx->soa.bld_base.base.gallivm;
d3785 3
a3787 6
	ctx->invariant_load_md_kind = LLVMGetMDKindIDInContext(gallivm->context,
							       "invariant.load", 14);
	ctx->range_md_kind = LLVMGetMDKindIDInContext(gallivm->context,
						     "range", 5);
	ctx->uniform_md_kind = LLVMGetMDKindIDInContext(gallivm->context,
							"amdgpu.uniform", 14);
d3789 1
a3789 1
	ctx->empty_md = LLVMMDNodeInContext(gallivm->context, NULL, 0);
d3801 1
a3801 5
		if (ctx->type != PIPE_SHADER_TESS_EVAL)
			params[ctx->param_streamout_config = (*num_params)++] = i32;
		else
			ctx->param_streamout_config = ctx->param_tess_offchip;

d3835 2
a3836 3
	struct gallivm_state *gallivm = &ctx->gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx->soa.bld_base;
	struct lp_build_context *uint = &bld_base->uint_bld;
d3838 14
a3851 4
	unsigned lds_size = ctx->screen->b.chip_class >= CIK ? 65536 : 32768;
	ctx->lds = LLVMBuildIntToPtr(gallivm->builder, uint->zero,
		LLVMPointerType(LLVMArrayType(ctx->i32, lds_size / 4), LOCAL_ADDR_SPACE),
		"tess_lds");
d3856 1
a3856 1
	struct lp_build_tgsi_context *bld_base = &ctx->soa.bld_base;
d3861 1
a3861 1
	unsigned i, last_sgpr, num_params, num_return_sgprs;
d3869 2
a3870 2
	params[SI_PARAM_IMAGES] = const_array(ctx->v8i32, SI_NUM_IMAGES);
	params[SI_PARAM_SHADER_BUFFERS] = const_array(ctx->v4i32, SI_NUM_SHADER_BUFFERS);
d3873 1
a3873 1
	case PIPE_SHADER_VERTEX:
d3875 1
d3878 1
a3878 2
		params[SI_PARAM_DRAWID] = ctx->i32;
		num_params = SI_PARAM_DRAWID+1;
d3887 2
a3888 1
				num_params = SI_PARAM_RW_BUFFERS+1;
d3922 1
a3922 2
	case PIPE_SHADER_TESS_CTRL:
		params[SI_PARAM_TCS_OFFCHIP_LAYOUT] = ctx->i32;
a3925 1
		params[ctx->param_oc_lds = SI_PARAM_TCS_OC_LDS] = ctx->i32;
d3935 2
a3936 4
			/* SI_PARAM_TCS_OC_LDS and PARAM_TESS_FACTOR_OFFSET are
			 * placed after the user SGPRs.
			 */
			for (i = 0; i < SI_TCS_NUM_USER_SGPR + 2; i++)
d3944 4
a3947 3
	case PIPE_SHADER_TESS_EVAL:
		params[SI_PARAM_TCS_OFFCHIP_LAYOUT] = ctx->i32;
		num_params = SI_PARAM_TCS_OFFCHIP_LAYOUT+1;
a3949 2
			params[ctx->param_oc_lds = num_params++] = ctx->i32;
			params[ctx->param_tess_offchip = num_params++] = ctx->i32;
a3951 1
			params[ctx->param_tess_offchip = num_params++] = ctx->i32;
a3953 1
			params[ctx->param_oc_lds = num_params++] = ctx->i32;
d3969 1
a3969 1
	case PIPE_SHADER_GEOMETRY:
d3986 1
a3986 1
	case PIPE_SHADER_FRAGMENT:
a4039 9
	case PIPE_SHADER_COMPUTE:
		params[SI_PARAM_GRID_SIZE] = v3i32;
		params[SI_PARAM_BLOCK_SIZE] = v3i32;
		params[SI_PARAM_BLOCK_ID] = v3i32;
		last_sgpr = SI_PARAM_BLOCK_ID;

		params[SI_PARAM_THREAD_ID] = v3i32;
		num_params = SI_PARAM_THREAD_ID + 1;
		break;
d4045 1
a4045 1
	assert(num_params <= ARRAY_SIZE(params));
d4048 1
a4048 1
			   num_params, last_sgpr);
d4051 1
a4051 1
	if (ctx->type == PIPE_SHADER_FRAGMENT &&
d4053 10
a4062 27
		si_llvm_add_attribute(ctx->main_fn,
				      "InitialPSInputAddr",
				      S_0286D0_PERSP_SAMPLE_ENA(1) |
				      S_0286D0_PERSP_CENTER_ENA(1) |
				      S_0286D0_PERSP_CENTROID_ENA(1) |
				      S_0286D0_LINEAR_SAMPLE_ENA(1) |
				      S_0286D0_LINEAR_CENTER_ENA(1) |
				      S_0286D0_LINEAR_CENTROID_ENA(1) |
				      S_0286D0_FRONT_FACE_ENA(1) |
				      S_0286D0_POS_FIXED_PT_ENA(1));
	} else if (ctx->type == PIPE_SHADER_COMPUTE) {
		const unsigned *properties = shader->selector->info.properties;
		unsigned max_work_group_size =
		               properties[TGSI_PROPERTY_CS_FIXED_BLOCK_WIDTH] *
		               properties[TGSI_PROPERTY_CS_FIXED_BLOCK_HEIGHT] *
		               properties[TGSI_PROPERTY_CS_FIXED_BLOCK_DEPTH];

		if (!max_work_group_size) {
			/* This is a variable group size compute shader,
			 * compile it for the maximum possible group size.
			 */
			max_work_group_size = SI_MAX_VARIABLE_THREADS_PER_BLOCK;
		}

		si_llvm_add_attribute(ctx->main_fn,
				      "amdgpu-max-work-group-size",
				      max_work_group_size);
d4074 1
a4074 1
	if (ctx->type != PIPE_SHADER_FRAGMENT)
d4078 1
a4078 2
	if (!ctx->screen->has_ds_bpermute &&
	    bld_base->info &&
d4091 3
a4093 3
	if ((ctx->type == PIPE_SHADER_VERTEX && shader->key.vs.as_ls) ||
	    ctx->type == PIPE_SHADER_TESS_CTRL ||
	    ctx->type == PIPE_SHADER_TESS_EVAL)
d4097 89
d4193 1
a4193 1
		ctx->soa.bld_base.base.gallivm;
d4195 1
a4195 1
	LLVMValueRef buf_ptr = LLVMGetParam(ctx->main_fn,
d4198 1
a4198 1
	if ((ctx->type == PIPE_SHADER_VERTEX &&
d4200 1
a4200 1
	    (ctx->type == PIPE_SHADER_TESS_EVAL &&
d4202 2
a4203 5
	    ctx->type == PIPE_SHADER_GEOMETRY) {
		unsigned ring =
			ctx->type == PIPE_SHADER_GEOMETRY ? SI_GS_RING_ESGS
							     : SI_ES_RING_ESGS;
		LLVMValueRef offset = lp_build_const_int32(gallivm, ring);
d4210 1
a4210 1
		LLVMValueRef offset = lp_build_const_int32(gallivm, SI_VS_RING_GSVS);
d4215 1
a4215 1
	if (ctx->type == PIPE_SHADER_GEOMETRY) {
d4218 1
a4218 1
			LLVMValueRef offset = lp_build_const_int32(gallivm, SI_GS_RING_GSVS0 + i);
d4227 1
a4227 1
					 LLVMValueRef param_rw_buffers,
d4231 1
a4231 1
		&ctx->soa.bld_base;
d4233 3
a4235 2
	LLVMBuilderRef builder = gallivm->builder;
	LLVMValueRef slot, desc, offset, row, bit, address[2];
d4244 23
a4266 16
	/* Load the buffer descriptor. */
	slot = lp_build_const_int32(gallivm, SI_PS_CONST_POLY_STIPPLE);
	desc = build_indexed_load_const(ctx, param_rw_buffers, slot);

	/* The stipple pattern is 32x32, each row has 32 bits. */
	offset = LLVMBuildMul(builder, address[1],
			      LLVMConstInt(ctx->i32, 4, 0), "");
	row = buffer_load_const(ctx, desc, offset);
	row = LLVMBuildBitCast(builder, row, ctx->i32, "");
	bit = LLVMBuildLShr(builder, row, address[0], "");
	bit = LLVMBuildTrunc(builder, bit, ctx->i1, "");

	/* The intrinsic kills the thread if arg < 0. */
	bit = LLVMBuildSelect(builder, bit, LLVMConstReal(ctx->f32, 0),
			      LLVMConstReal(ctx->f32, -1), "");
	lp_build_intrinsic(builder, "llvm.AMDGPU.kill", ctx->voidt, &bit, 1, 0);
a4275 14
	bool really_needs_scratch = false;

	/* LLVM adds SGPR spills to the scratch size.
	 * Find out if we really need the scratch buffer.
	 */
	for (i = 0; i < binary->reloc_count; i++) {
		const struct radeon_shader_reloc *reloc = &binary->relocs[i];

		if (!strcmp(scratch_rsrc_dword0_symbol, reloc->name) ||
		    !strcmp(scratch_rsrc_dword1_symbol, reloc->name)) {
			really_needs_scratch = true;
			break;
		}
	}
d4310 2
a4311 9
			if (really_needs_scratch)
				conf->scratch_bytes_per_wave =
					G_00B860_WAVESIZE(value) * 256 * 4;
			break;
		case 0x4: /* SPILLED_SGPRS */
			conf->spilled_sgprs = value;
			break;
		case 0x8: /* SPILLED_VGPRS */
			conf->spilled_vgprs = value;
d4325 3
a4328 3

	if (!conf->spi_ps_input_addr)
		conf->spi_ps_input_addr = conf->spi_ps_input_ena;
a4332 1
			struct si_shader_config *config,
d4338 2
a4339 10
		S_008F04_BASE_ADDRESS_HI(scratch_va >> 32);

	/* Enable scratch coalescing if LLVM sets ELEMENT_SIZE & INDEX_STRIDE
	 * correctly.
	 */
	if (HAVE_LLVM >= 0x0309)
		scratch_rsrc_dword1 |= S_008F04_SWIZZLE_ENABLE(1);
	else
		scratch_rsrc_dword1 |=
			S_008F04_STRIDE(config->scratch_bytes_per_wave / 64);
d4410 1
a4410 1
				       const char *name, FILE *file)
d4416 2
a4417 2
		fprintf(file, "Shader %s disassembly:\n", name);
		fprintf(file, "%s", binary->disasm_string);
d4447 1
a4447 1
		fprintf(file, "Shader %s binary:\n", name);
d4449 1
a4449 1
			fprintf(file, "@@0x%x: %02x%02x%02x%02x\n", i,
d4461 1
a4461 2
			         unsigned processor,
				 FILE *file)
d4468 3
a4470 3
	if (processor == PIPE_SHADER_FRAGMENT) {
		/* The minimum usage per wave is (num_inputs * 48). The maximum
		 * usage is (num_inputs * 48 * 16).
a4472 3
		 * The 48 bytes per input for a single primitive is equal to
		 * 4 bytes/component * 4 components/input * 3 points.
		 *
d4477 1
a4477 1
			       align(num_inputs * 48, lds_increment);
d4497 3
a4499 4
	if (file != stderr ||
	    r600_can_dump_shader(&sscreen->b, processor)) {
		if (processor == PIPE_SHADER_FRAGMENT) {
			fprintf(file, "*** SHADER CONFIG ***\n"
d4505 1
a4505 1
		fprintf(file, "*** SHADER STATS ***\n"
a4507 2
		        "Spilled SGPRs: %d\n"
			"Spilled VGPRs: %d\n"
d4512 2
a4513 3
			"********************\n\n\n",
			conf->num_sgprs, conf->num_vgprs,
			conf->spilled_sgprs, conf->spilled_vgprs, code_size,
d4520 1
a4520 2
			   "LDS: %d Scratch: %d Max Waves: %d Spilled SGPRs: %d "
			   "Spilled VGPRs: %d",
d4523 1
a4523 2
			   max_simd_waves, conf->spilled_sgprs,
			   conf->spilled_vgprs);
d4530 1
a4530 1
	case PIPE_SHADER_VERTEX:
d4537 1
a4537 1
	case PIPE_SHADER_TESS_CTRL:
d4539 1
a4539 1
	case PIPE_SHADER_TESS_EVAL:
d4544 1
a4544 1
	case PIPE_SHADER_GEOMETRY:
d4549 1
a4549 1
	case PIPE_SHADER_FRAGMENT:
d4551 1
a4551 1
	case PIPE_SHADER_COMPUTE:
d4559 1
a4559 2
		    struct pipe_debug_callback *debug, unsigned processor,
		    FILE *file)
d4561 3
a4563 14
	if (file != stderr ||
	    r600_can_dump_shader(&sscreen->b, processor))
		si_dump_shader_key(processor, &shader->key, file);

	if (file != stderr && shader->binary.llvm_ir_string) {
		fprintf(file, "\n%s - main shader part - LLVM IR:\n\n",
			si_get_shader_name(shader, processor));
		fprintf(file, "%s\n", shader->binary.llvm_ir_string);
	}

	if (file != stderr ||
	    (r600_can_dump_shader(&sscreen->b, processor) &&
	     !(sscreen->b.debug_flags & DBG_NO_ASM))) {
		fprintf(file, "\n%s:\n", si_get_shader_name(shader, processor));
d4567 1
a4567 1
						   debug, "prolog", file);
d4569 1
a4569 1
		si_shader_dump_disassembly(&shader->binary, debug, "main", file);
d4573 2
a4574 2
						   debug, "epilog", file);
		fprintf(file, "\n");
d4579 1
a4579 2
			     si_get_shader_binary_size(shader), debug, processor,
			     file);
a4603 6
	if (sscreen->record_llvm_ir) {
		char *ir = LLVMPrintModuleToString(mod);
		binary->llvm_ir_string = strdup(ir);
		LLVMDisposeMessage(ir);
	}

d4605 3
a4607 1
		r = si_llvm_compile(mod, binary, tm, debug);
d4637 4
a4640 4
	    (processor == PIPE_SHADER_VERTEX ||
	     processor == PIPE_SHADER_TESS_CTRL ||
	     processor == PIPE_SHADER_TESS_EVAL ||
	     processor == PIPE_SHADER_FRAGMENT)) {
a4647 8
static void si_llvm_build_ret(struct si_shader_context *ctx, LLVMValueRef ret)
{
	if (LLVMGetTypeKind(LLVMTypeOf(ret)) == LLVMVoidTypeKind)
		LLVMBuildRetVoid(ctx->gallivm.builder);
	else
		LLVMBuildRet(ctx->gallivm.builder, ret);
}

d4654 2
a4655 2
	struct gallivm_state *gallivm = &ctx->gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx->soa.bld_base;
d4665 1
a4665 1
	ctx->type = PIPE_SHADER_VERTEX;
d4670 1
d4675 1
a4675 1
				   LLVMGetParam(ctx->main_fn,
d4702 1
a4702 1
								 LLVMReadOnlyAttribute),
d4709 1
a4709 1
	LLVMBuildRetVoid(gallivm->builder);
d4713 1
a4713 1
	    r600_can_dump_shader(&sscreen->b, PIPE_SHADER_GEOMETRY))
d4716 1
a4716 2
	si_llvm_finalize_module(ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_GEOMETRY));
d4721 1
a4721 1
			    debug, PIPE_SHADER_GEOMETRY,
d4724 1
a4724 1
		if (r600_can_dump_shader(&sscreen->b, PIPE_SHADER_GEOMETRY))
d4727 1
a4727 1
			       PIPE_SHADER_GEOMETRY, stderr);
d4731 1
a4731 1
	si_llvm_dispose(ctx);
d4737 1
a4737 2
static void si_dump_shader_key(unsigned shader, union si_shader_key *key,
			       FILE *f)
d4746 1
a4746 1
		for (i = 0; i < ARRAY_SIZE(key->vs.prolog.instance_divisors); i++)
a4764 1
	case PIPE_SHADER_COMPUTE:
a4768 1
		fprintf(f, "  prolog.flatshade_colors = %u\n", key->ps.prolog.flatshade_colors);
d4770 1
a4770 6
		fprintf(f, "  prolog.force_persp_sample_interp = %u\n", key->ps.prolog.force_persp_sample_interp);
		fprintf(f, "  prolog.force_linear_sample_interp = %u\n", key->ps.prolog.force_linear_sample_interp);
		fprintf(f, "  prolog.force_persp_center_interp = %u\n", key->ps.prolog.force_persp_center_interp);
		fprintf(f, "  prolog.force_linear_center_interp = %u\n", key->ps.prolog.force_linear_center_interp);
		fprintf(f, "  prolog.bc_optimize_for_persp = %u\n", key->ps.prolog.bc_optimize_for_persp);
		fprintf(f, "  prolog.bc_optimize_for_linear = %u\n", key->ps.prolog.bc_optimize_for_linear);
a4790 1
	struct lp_build_tgsi_action tmpl = {};
d4793 1
a4793 5
	si_llvm_context_init(
		ctx, "amdgcn--",
		(shader && shader->selector) ? &shader->selector->info : NULL,
		(shader && shader->selector) ? shader->selector->tokens : NULL);
	si_shader_context_init_alu(&ctx->soa.bld_base);
d4802 7
a4808 7
	ctx->voidt = LLVMVoidTypeInContext(ctx->gallivm.context);
	ctx->i1 = LLVMInt1TypeInContext(ctx->gallivm.context);
	ctx->i8 = LLVMInt8TypeInContext(ctx->gallivm.context);
	ctx->i32 = LLVMInt32TypeInContext(ctx->gallivm.context);
	ctx->i64 = LLVMInt64TypeInContext(ctx->gallivm.context);
	ctx->i128 = LLVMIntTypeInContext(ctx->gallivm.context, 128);
	ctx->f32 = LLVMFloatTypeInContext(ctx->gallivm.context);
d4815 3
a4817 1
	bld_base = &ctx->soa.bld_base;
d4833 1
a4833 2
	bld_base->op_actions[TGSI_OPCODE_TXQ].fetch_args = txq_fetch_args;
	bld_base->op_actions[TGSI_OPCODE_TXQ].emit = txq_emit;
a4837 32
	bld_base->op_actions[TGSI_OPCODE_LOAD].fetch_args = load_fetch_args;
	bld_base->op_actions[TGSI_OPCODE_LOAD].emit = load_emit;
	bld_base->op_actions[TGSI_OPCODE_STORE].fetch_args = store_fetch_args;
	bld_base->op_actions[TGSI_OPCODE_STORE].emit = store_emit;
	bld_base->op_actions[TGSI_OPCODE_RESQ].fetch_args = resq_fetch_args;
	bld_base->op_actions[TGSI_OPCODE_RESQ].emit = resq_emit;

	tmpl.fetch_args = atomic_fetch_args;
	tmpl.emit = atomic_emit;
	bld_base->op_actions[TGSI_OPCODE_ATOMUADD] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMUADD].intr_name = "add";
	bld_base->op_actions[TGSI_OPCODE_ATOMXCHG] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMXCHG].intr_name = "swap";
	bld_base->op_actions[TGSI_OPCODE_ATOMCAS] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMCAS].intr_name = "cmpswap";
	bld_base->op_actions[TGSI_OPCODE_ATOMAND] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMAND].intr_name = "and";
	bld_base->op_actions[TGSI_OPCODE_ATOMOR] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMOR].intr_name = "or";
	bld_base->op_actions[TGSI_OPCODE_ATOMXOR] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMXOR].intr_name = "xor";
	bld_base->op_actions[TGSI_OPCODE_ATOMUMIN] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMUMIN].intr_name = "umin";
	bld_base->op_actions[TGSI_OPCODE_ATOMUMAX] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMUMAX].intr_name = "umax";
	bld_base->op_actions[TGSI_OPCODE_ATOMIMIN] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMIMIN].intr_name = "smin";
	bld_base->op_actions[TGSI_OPCODE_ATOMIMAX] = tmpl;
	bld_base->op_actions[TGSI_OPCODE_ATOMIMAX].intr_name = "smax";

	bld_base->op_actions[TGSI_OPCODE_MEMBAR].emit = membar_emit;

d4846 5
d4869 1
d4879 2
a4880 2
	bld_base = &ctx.soa.bld_base;
	ctx.load_system_value = declare_system_value;
d4883 2
a4884 2
	case PIPE_SHADER_VERTEX:
		ctx.load_input = declare_input_vs;
d4892 1
a4892 1
	case PIPE_SHADER_TESS_CTRL:
d4898 1
a4898 1
	case PIPE_SHADER_TESS_EVAL:
d4905 1
a4905 1
	case PIPE_SHADER_GEOMETRY:
d4909 2
a4910 2
	case PIPE_SHADER_FRAGMENT:
		ctx.load_input = declare_input_fs;
a4915 3
	case PIPE_SHADER_COMPUTE:
		ctx.declare_memory_region = declare_compute_memory;
		break;
d4923 3
d4930 3
a4932 3
		LLVMValueRef list = LLVMGetParam(ctx.main_fn,
						 SI_PARAM_RW_BUFFERS);
		si_llvm_emit_polygon_stipple(&ctx, list,
d4936 1
a4936 1
	if (ctx.type == PIPE_SHADER_GEOMETRY) {
d4950 1
a4950 1
	si_llvm_build_ret(&ctx, ctx.return_value);
d4958 1
a4958 2
	si_llvm_finalize_module(&ctx,
				    r600_extra_shader_checks(&sscreen->b, ctx.type));
d4967 1
a4967 45
	si_llvm_dispose(&ctx);

	/* Validate SGPR and VGPR usage for compute to detect compiler bugs.
	 * LLVM 3.9svn has this bug.
	 */
	if (sel->type == PIPE_SHADER_COMPUTE) {
		unsigned *props = sel->info.properties;
		unsigned wave_size = 64;
		unsigned max_vgprs = 256;
		unsigned max_sgprs = sscreen->b.chip_class >= VI ? 800 : 512;
		unsigned max_sgprs_per_wave = 128;
		unsigned max_block_threads;

		if (props[TGSI_PROPERTY_CS_FIXED_BLOCK_WIDTH])
			max_block_threads = props[TGSI_PROPERTY_CS_FIXED_BLOCK_WIDTH] *
					    props[TGSI_PROPERTY_CS_FIXED_BLOCK_HEIGHT] *
					    props[TGSI_PROPERTY_CS_FIXED_BLOCK_DEPTH];
		else
			max_block_threads = SI_MAX_VARIABLE_THREADS_PER_BLOCK;

		unsigned min_waves_per_cu = DIV_ROUND_UP(max_block_threads, wave_size);
		unsigned min_waves_per_simd = DIV_ROUND_UP(min_waves_per_cu, 4);

		max_vgprs = max_vgprs / min_waves_per_simd;
		max_sgprs = MIN2(max_sgprs / min_waves_per_simd, max_sgprs_per_wave);

		if (shader->config.num_sgprs > max_sgprs ||
		    shader->config.num_vgprs > max_vgprs) {
			fprintf(stderr, "LLVM failed to compile a shader correctly: "
				"SGPR:VGPR usage is %u:%u, but the hw limit is %u:%u\n",
				shader->config.num_sgprs, shader->config.num_vgprs,
				max_sgprs, max_vgprs);

			/* Just terminate the process, because dependent
			 * shaders can hang due to bad input data, but use
			 * the env var to allow shader-db to work.
			 */
			if (!debug_get_bool_option("SI_PASS_BAD_SHADERS", false))
				abort();
		}
	}

	/* Add the scratch offset to input SGPRs. */
	if (shader->config.scratch_bytes_per_wave)
		shader->info.num_input_sgprs += 1; /* scratch byte offset */
d4970 1
a4970 1
	if (ctx.type == PIPE_SHADER_FRAGMENT) {
d5010 1
a5010 1
	if (ctx.type == PIPE_SHADER_GEOMETRY) {
d5023 2
d5101 1
a5101 1
	struct gallivm_state *gallivm = &ctx.gallivm;
d5108 1
a5108 1
	ctx.type = PIPE_SHADER_VERTEX;
d5141 2
a5142 2
			   num_params, last_sgpr);
	func = ctx.main_fn;
d5165 1
a5165 1
			index = get_instance_index_for_fetch(&ctx,
d5181 2
a5182 3
	si_llvm_build_ret(&ctx, ret);
	si_llvm_finalize_module(&ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_VERTEX));
d5189 1
a5189 1
	si_llvm_dispose(&ctx);
d5209 2
a5210 2
	struct gallivm_state *gallivm = &ctx.gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx.soa.bld_base;
d5216 1
a5216 1
	ctx.type = PIPE_SHADER_VERTEX;
d5227 2
a5228 1
	si_create_function(&ctx, NULL, 0, params, num_params, -1);
d5242 1
a5242 1
		args[5] = LLVMGetParam(ctx.main_fn,
d5254 2
a5255 3
	LLVMBuildRetVoid(gallivm->builder);
	si_llvm_finalize_module(&ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_VERTEX));
d5262 1
a5262 1
	si_llvm_dispose(&ctx);
d5366 2
a5367 2
	struct gallivm_state *gallivm = &ctx.gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx.soa.bld_base;
d5370 1
a5370 1
	int last_sgpr, num_params;
d5374 1
a5374 1
	ctx.type = PIPE_SHADER_TESS_CTRL;
d5379 1
d5382 1
a5382 3
	params[SI_PARAM_IMAGES] = ctx.i64;
	params[SI_PARAM_SHADER_BUFFERS] = ctx.i64;
	params[SI_PARAM_TCS_OFFCHIP_LAYOUT] = ctx.i32;
a5385 1
	params[ctx.param_oc_lds = SI_PARAM_TCS_OC_LDS] = ctx.i32;
d5395 2
a5396 1
	si_create_function(&ctx, NULL, 0, params, num_params, last_sgpr);
d5398 1
a5398 1
	func = ctx.main_fn;
d5406 2
a5407 3
	LLVMBuildRetVoid(gallivm->builder);
	si_llvm_finalize_module(&ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_TESS_CTRL));
d5414 1
a5414 1
	si_llvm_dispose(&ctx);
d5456 1
a5456 1
	struct gallivm_state *gallivm = &ctx.gallivm;
d5463 1
a5463 1
	ctx.type = PIPE_SHADER_FRAGMENT;
d5488 2
a5489 2
			   num_params, last_sgpr);
	func = ctx.main_fn;
d5505 1
a5505 100
		LLVMValueRef ptr[2], list;

		/* Get the pointer to rw buffers. */
		ptr[0] = LLVMGetParam(func, SI_SGPR_RW_BUFFERS);
		ptr[1] = LLVMGetParam(func, SI_SGPR_RW_BUFFERS_HI);
		list = lp_build_gather_values(gallivm, ptr, 2);
		list = LLVMBuildBitCast(gallivm->builder, list, ctx.i64, "");
		list = LLVMBuildIntToPtr(gallivm->builder, list,
					  const_array(ctx.v16i8, SI_NUM_RW_BUFFERS), "");

		si_llvm_emit_polygon_stipple(&ctx, list, pos);
	}

	if (key->ps_prolog.states.bc_optimize_for_persp ||
	    key->ps_prolog.states.bc_optimize_for_linear) {
		unsigned i, base = key->ps_prolog.num_input_sgprs;
		LLVMValueRef center[2], centroid[2], tmp, bc_optimize;

		/* The shader should do: if (PRIM_MASK[31]) CENTROID = CENTER;
		 * The hw doesn't compute CENTROID if the whole wave only
		 * contains fully-covered quads.
		 *
		 * PRIM_MASK is after user SGPRs.
		 */
		bc_optimize = LLVMGetParam(func, SI_PS_NUM_USER_SGPR);
		bc_optimize = LLVMBuildLShr(gallivm->builder, bc_optimize,
					    LLVMConstInt(ctx.i32, 31, 0), "");
		bc_optimize = LLVMBuildTrunc(gallivm->builder, bc_optimize,
					     ctx.i1, "");

		if (key->ps_prolog.states.bc_optimize_for_persp) {
			/* Read PERSP_CENTER. */
			for (i = 0; i < 2; i++)
				center[i] = LLVMGetParam(func, base + 2 + i);
			/* Read PERSP_CENTROID. */
			for (i = 0; i < 2; i++)
				centroid[i] = LLVMGetParam(func, base + 4 + i);
			/* Select PERSP_CENTROID. */
			for (i = 0; i < 2; i++) {
				tmp = LLVMBuildSelect(gallivm->builder, bc_optimize,
						      center[i], centroid[i], "");
				ret = LLVMBuildInsertValue(gallivm->builder, ret,
							   tmp, base + 4 + i, "");
			}
		}
		if (key->ps_prolog.states.bc_optimize_for_linear) {
			/* Read LINEAR_CENTER. */
			for (i = 0; i < 2; i++)
				center[i] = LLVMGetParam(func, base + 8 + i);
			/* Read LINEAR_CENTROID. */
			for (i = 0; i < 2; i++)
				centroid[i] = LLVMGetParam(func, base + 10 + i);
			/* Select LINEAR_CENTROID. */
			for (i = 0; i < 2; i++) {
				tmp = LLVMBuildSelect(gallivm->builder, bc_optimize,
						      center[i], centroid[i], "");
				ret = LLVMBuildInsertValue(gallivm->builder, ret,
							   tmp, base + 10 + i, "");
			}
		}
	}

	/* Force per-sample interpolation. */
	if (key->ps_prolog.states.force_persp_sample_interp) {
		unsigned i, base = key->ps_prolog.num_input_sgprs;
		LLVMValueRef persp_sample[2];

		/* Read PERSP_SAMPLE. */
		for (i = 0; i < 2; i++)
			persp_sample[i] = LLVMGetParam(func, base + i);
		/* Overwrite PERSP_CENTER. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   persp_sample[i], base + 2 + i, "");
		/* Overwrite PERSP_CENTROID. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   persp_sample[i], base + 4 + i, "");
	}
	if (key->ps_prolog.states.force_linear_sample_interp) {
		unsigned i, base = key->ps_prolog.num_input_sgprs;
		LLVMValueRef linear_sample[2];

		/* Read LINEAR_SAMPLE. */
		for (i = 0; i < 2; i++)
			linear_sample[i] = LLVMGetParam(func, base + 6 + i);
		/* Overwrite LINEAR_CENTER. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   linear_sample[i], base + 8 + i, "");
		/* Overwrite LINEAR_CENTROID. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   linear_sample[i], base + 10 + i, "");
	}

	/* Force center interpolation. */
	if (key->ps_prolog.states.force_persp_center_interp) {
		unsigned i, base = key->ps_prolog.num_input_sgprs;
		LLVMValueRef persp_center[2];
d5507 7
a5513 15
		/* Read PERSP_CENTER. */
		for (i = 0; i < 2; i++)
			persp_center[i] = LLVMGetParam(func, base + 2 + i);
		/* Overwrite PERSP_SAMPLE. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   persp_center[i], base + i, "");
		/* Overwrite PERSP_CENTROID. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   persp_center[i], base + 4 + i, "");
	}
	if (key->ps_prolog.states.force_linear_center_interp) {
		unsigned i, base = key->ps_prolog.num_input_sgprs;
		LLVMValueRef linear_center[2];
d5515 1
a5515 11
		/* Read LINEAR_CENTER. */
		for (i = 0; i < 2; i++)
			linear_center[i] = LLVMGetParam(func, base + 8 + i);
		/* Overwrite LINEAR_SAMPLE. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   linear_center[i], base + 6 + i, "");
		/* Overwrite LINEAR_CENTROID. */
		for (i = 0; i < 2; i++)
			ret = LLVMBuildInsertValue(gallivm->builder, ret,
						   linear_center[i], base + 10 + i, "");
d5534 2
a5535 5
			/* Get the (i,j) updated by bc_optimize handling. */
			interp[0] = LLVMBuildExtractValue(gallivm->builder, ret,
							  interp_vgpr, "");
			interp[1] = LLVMBuildExtractValue(gallivm->builder, ret,
							  interp_vgpr + 1, "");
d5563 27
a5589 4
	/* Tell LLVM to insert WQM instruction sequence when needed. */
	if (key->ps_prolog.wqm) {
		LLVMAddTargetDependentFunctionAttr(func,
						   "amdgpu-ps-wqm-outputs", "");
d5593 2
a5594 3
	si_llvm_build_ret(&ctx, ret);
	si_llvm_finalize_module(&ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_FRAGMENT));
d5601 1
a5601 1
	si_llvm_dispose(&ctx);
d5617 2
a5618 2
	struct gallivm_state *gallivm = &ctx.gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx.soa.bld_base;
d5621 1
a5621 1
	int last_sgpr, num_params, i;
a5622 1
	struct si_ps_exports exp = {};
d5625 1
a5625 1
	ctx.type = PIPE_SHADER_FRAGMENT;
d5632 1
a5632 2
	params[SI_PARAM_IMAGES] = ctx.i64;
	params[SI_PARAM_SHADER_BUFFERS] = ctx.i64;
d5634 1
d5653 2
a5654 1
	si_create_function(&ctx, NULL, 0, params, num_params, last_sgpr);
d5656 1
a5656 1
	si_llvm_add_attribute(ctx.main_fn,
d5689 1
a5689 1
			color[i] = LLVMGetParam(ctx.main_fn, vgpr++);
d5693 1
a5693 1
				    mrt == last_color_export, &exp);
d5698 1
a5698 1
		depth = LLVMGetParam(ctx.main_fn, vgpr++);
d5700 1
a5700 1
		stencil = LLVMGetParam(ctx.main_fn, vgpr++);
d5702 1
a5702 1
		samplemask = LLVMGetParam(ctx.main_fn, vgpr++);
d5705 1
a5705 1
		si_export_mrt_z(bld_base, depth, stencil, samplemask, &exp);
a5708 3
	if (exp.num)
		si_emit_ps_exports(&ctx, &exp);

d5711 1
a5711 2
	si_llvm_finalize_module(&ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_FRAGMENT));
d5718 1
a5718 1
	si_llvm_dispose(&ctx);
a5740 8
	prolog_key.ps_prolog.wqm = info->uses_derivatives &&
		(prolog_key.ps_prolog.colors_read ||
		 prolog_key.ps_prolog.states.force_persp_sample_interp ||
		 prolog_key.ps_prolog.states.force_linear_sample_interp ||
		 prolog_key.ps_prolog.states.force_persp_center_interp ||
		 prolog_key.ps_prolog.states.force_linear_center_interp ||
		 prolog_key.ps_prolog.states.bc_optimize_for_persp ||
		 prolog_key.ps_prolog.states.bc_optimize_for_linear);
a5752 1
			unsigned interp = info->input_interpolate[color[i]];
d5760 3
a5762 3
			if (shader->key.ps.prolog.flatshade_colors &&
			    interp == TGSI_INTERPOLATE_COLOR)
				interp = TGSI_INTERPOLATE_CONSTANT;
d5764 1
a5764 1
			switch (interp) {
a5769 6
				/* Force the interpolation location for colors here. */
				if (shader->key.ps.prolog.force_persp_sample_interp)
					location = TGSI_INTERPOLATE_LOC_SAMPLE;
				if (shader->key.ps.prolog.force_persp_center_interp)
					location = TGSI_INTERPOLATE_LOC_CENTER;

a5790 6
				/* Force the interpolation location for colors here. */
				if (shader->key.ps.prolog.force_linear_sample_interp)
					location = TGSI_INTERPOLATE_LOC_SAMPLE;
				if (shader->key.ps.prolog.force_linear_center_interp)
					location = TGSI_INTERPOLATE_LOC_CENTER;

d5819 1
a5819 6
	    prolog_key.ps_prolog.states.force_persp_sample_interp ||
	    prolog_key.ps_prolog.states.force_linear_sample_interp ||
	    prolog_key.ps_prolog.states.force_persp_center_interp ||
	    prolog_key.ps_prolog.states.force_linear_center_interp ||
	    prolog_key.ps_prolog.states.bc_optimize_for_persp ||
	    prolog_key.ps_prolog.states.bc_optimize_for_linear ||
d5851 13
a5863 27
	if (shader->key.ps.prolog.force_persp_sample_interp &&
	    (G_0286CC_PERSP_CENTER_ENA(shader->config.spi_ps_input_ena) ||
	     G_0286CC_PERSP_CENTROID_ENA(shader->config.spi_ps_input_ena))) {
		shader->config.spi_ps_input_ena &= C_0286CC_PERSP_CENTER_ENA;
		shader->config.spi_ps_input_ena &= C_0286CC_PERSP_CENTROID_ENA;
		shader->config.spi_ps_input_ena |= S_0286CC_PERSP_SAMPLE_ENA(1);
	}
	if (shader->key.ps.prolog.force_linear_sample_interp &&
	    (G_0286CC_LINEAR_CENTER_ENA(shader->config.spi_ps_input_ena) ||
	     G_0286CC_LINEAR_CENTROID_ENA(shader->config.spi_ps_input_ena))) {
		shader->config.spi_ps_input_ena &= C_0286CC_LINEAR_CENTER_ENA;
		shader->config.spi_ps_input_ena &= C_0286CC_LINEAR_CENTROID_ENA;
		shader->config.spi_ps_input_ena |= S_0286CC_LINEAR_SAMPLE_ENA(1);
	}
	if (shader->key.ps.prolog.force_persp_center_interp &&
	    (G_0286CC_PERSP_SAMPLE_ENA(shader->config.spi_ps_input_ena) ||
	     G_0286CC_PERSP_CENTROID_ENA(shader->config.spi_ps_input_ena))) {
		shader->config.spi_ps_input_ena &= C_0286CC_PERSP_SAMPLE_ENA;
		shader->config.spi_ps_input_ena &= C_0286CC_PERSP_CENTROID_ENA;
		shader->config.spi_ps_input_ena |= S_0286CC_PERSP_CENTER_ENA(1);
	}
	if (shader->key.ps.prolog.force_linear_center_interp &&
	    (G_0286CC_LINEAR_SAMPLE_ENA(shader->config.spi_ps_input_ena) ||
	     G_0286CC_LINEAR_CENTROID_ENA(shader->config.spi_ps_input_ena))) {
		shader->config.spi_ps_input_ena &= C_0286CC_LINEAR_SAMPLE_ENA;
		shader->config.spi_ps_input_ena &= C_0286CC_LINEAR_CENTROID_ENA;
		shader->config.spi_ps_input_ena |= S_0286CC_LINEAR_CENTER_ENA(1);
a5888 7
static void si_fix_num_sgprs(struct si_shader *shader)
{
	unsigned min_sgprs = shader->info.num_input_sgprs + 2; /* VCC */

	shader->config.num_sgprs = MAX2(shader->config.num_sgprs, min_sgprs);
}

d5893 1
a5893 2
	struct si_shader_selector *sel = shader->selector;
	struct si_shader *mainp = sel->main_shader_part;
d5896 1
a5896 3
	/* LS, ES, VS are compiled on demand if the main part hasn't been
	 * compiled for that stage.
	 */
d5898 4
a5901 8
	    (sel->type == PIPE_SHADER_VERTEX &&
	     (shader->key.vs.as_es != mainp->key.vs.as_es ||
	      shader->key.vs.as_ls != mainp->key.vs.as_ls)) ||
	    (sel->type == PIPE_SHADER_TESS_EVAL &&
	     shader->key.tes.as_es != mainp->key.tes.as_es) ||
	    (sel->type == PIPE_SHADER_TESS_CTRL &&
	     shader->key.tcs.epilog.inputs_to_copy) ||
	    sel->type == PIPE_SHADER_COMPUTE) {
d5935 1
a5935 1
		switch (sel->type) {
d5975 1
a5975 3
	si_fix_num_sgprs(shader);
	si_shader_dump(sscreen, shader, debug, sel->info.processor,
		       stderr);
a6000 2

	free(shader->shader_log);
@


1.1.1.5
log
@Import Mesa 13.0.3
@
text
@d2580 4
a2583 12
	if (shader->key.tcs.epilog.prim_mode == PIPE_PRIM_LINES) {
		/* For isolines, the hardware expects tess factors in the
		 * reverse order from what GLSL / TGSI specify.
		 */
		out[0] = lds_load(bld_base, TGSI_TYPE_SIGNED, 1, lds_outer);
		out[1] = lds_load(bld_base, TGSI_TYPE_SIGNED, 0, lds_outer);
	} else {
		for (i = 0; i < outer_comps; i++)
			out[i] = lds_load(bld_base, TGSI_TYPE_SIGNED, i, lds_outer);
		for (i = 0; i < inner_comps; i++)
			out[outer_comps+i] = lds_load(bld_base, TGSI_TYPE_SIGNED, i, lds_inner);
	}
a3303 1
#if 0 /* unused currently */
a3310 1
#endif
d3312 1
a3312 6
/* Combine these with & instead of |. */
#define NOOP_WAITCNT 0xf7f
#define LGKM_CNT 0x07f
#define VM_CNT 0xf70

static void emit_waitcnt(struct si_shader_context *ctx, unsigned simm16)
d3317 1
a3317 1
		lp_build_const_int32(gallivm, simm16)
a3328 14
	LLVMValueRef src0 = lp_build_emit_fetch(bld_base, emit_data->inst, 0, 0);
	unsigned flags = LLVMConstIntGetZExtValue(src0);
	unsigned waitcnt = NOOP_WAITCNT;

	if (flags & TGSI_MEMBAR_THREAD_GROUP)
		waitcnt &= VM_CNT & LGKM_CNT;

	if (flags & (TGSI_MEMBAR_ATOMIC_BUFFER |
		     TGSI_MEMBAR_SHADER_BUFFER |
		     TGSI_MEMBAR_SHADER_IMAGE))
		waitcnt &= VM_CNT;

	if (flags & TGSI_MEMBAR_SHARED)
		waitcnt &= LGKM_CNT;
d3330 1
a3330 2
	if (waitcnt != NOOP_WAITCNT)
		emit_waitcnt(ctx, waitcnt);
d3484 1
a3484 2
		bool atomic,
		bool force_glc)
a3491 1
		force_glc ||
d3546 1
a3546 2
		bool atomic,
		bool force_glc)
a3556 1
			force_glc ||
d3586 1
a3586 1
				   offset, false, false);
d3596 1
a3596 1
					   bld_base->uint_bld.zero, false, false);
d3603 1
a3603 1
			image_append_args(ctx, emit_data, target, false, false);
d3730 1
a3730 1
		emit_waitcnt(ctx, VM_CNT);
d3793 1
a3793 1
				   offset, false, false);
a3797 8
		/* 8bit/16bit TC L1 write corruption bug on SI.
		 * All store opcodes not aligned to a dword are affected.
		 *
		 * The only way to get unaligned stores in radeonsi is through
		 * shader images.
		 */
		bool force_glc = ctx->screen->b.chip_class == SI;

d3805 1
a3805 1
					   bld_base->uint_bld.zero, false, force_glc);
d3812 1
a3812 1
			image_append_args(ctx, emit_data, target, false, force_glc);
d3932 1
a3932 1
		emit_waitcnt(ctx, VM_CNT);
d3996 1
a3996 1
				   offset, true, false);
d4008 1
a4008 1
					   bld_base->uint_bld.zero, true, false);
d4013 1
a4013 1
			image_append_args(ctx, emit_data, target, true, false);
a5249 1
	struct lp_build_if_state if_state;
d5267 3
a5269 6
	 * vertices, skip the write: excessive vertex emissions are not
	 * supposed to have any effect.
	 *
	 * If the shader has no writes to memory, kill it instead. This skips
	 * further memory loads and may allow LLVM to skip to the end
	 * altogether.
d5271 1
a5271 1
	can_emit = LLVMBuildICmp(gallivm->builder, LLVMIntULT, gs_next_vertex,
d5274 3
d5278 2
a5279 11
	bool use_kill = !info->writes_memory;
	if (use_kill) {
		kill = lp_build_select(&bld_base->base, can_emit,
				       lp_build_const_float(gallivm, 1.0f),
				       lp_build_const_float(gallivm, -1.0f));

		lp_build_intrinsic(gallivm->builder, "llvm.AMDGPU.kill",
				   ctx->voidt, &kill, 1, 0);
	} else {
		lp_build_if(&if_state, gallivm, can_emit);
	}
a5304 1

a5314 3

	if (!use_kill)
		lp_build_endif(&if_state);
d5347 1
a5347 1
		emit_waitcnt(ctx, LGKM_CNT & VM_CNT);
a5483 17
static unsigned si_get_max_workgroup_size(struct si_shader *shader)
{
	const unsigned *properties = shader->selector->info.properties;
	unsigned max_work_group_size =
	               properties[TGSI_PROPERTY_CS_FIXED_BLOCK_WIDTH] *
	               properties[TGSI_PROPERTY_CS_FIXED_BLOCK_HEIGHT] *
	               properties[TGSI_PROPERTY_CS_FIXED_BLOCK_DEPTH];

	if (!max_work_group_size) {
		/* This is a variable group size compute shader,
		 * compile it for the maximum possible group size.
		 */
		max_work_group_size = SI_MAX_VARIABLE_THREADS_PER_BLOCK;
	}
	return max_work_group_size;
}

d5709 13
d5724 1
a5724 1
				      si_get_max_workgroup_size(shader));
d6646 1
d6651 9
a6659 1
		unsigned max_block_threads = si_get_max_workgroup_size(shader);
d7749 1
a7749 15
void si_multiwave_lds_size_workaround(struct si_screen *sscreen,
				      unsigned *lds_size)
{
	/* SPI barrier management bug:
	 *   Make sure we have at least 4k of LDS in use to avoid the bug.
	 *   It applies to workgroup sizes of more than one wavefront.
	 */
	if (sscreen->b.family == CHIP_BONAIRE ||
	    sscreen->b.family == CHIP_KABINI ||
	    sscreen->b.family == CHIP_MULLINS)
		*lds_size = MAX2(*lds_size, 8);
}

static void si_fix_resource_usage(struct si_screen *sscreen,
				  struct si_shader *shader)
a7753 6

	if (shader->selector->type == PIPE_SHADER_COMPUTE &&
	    si_get_max_workgroup_size(shader) > 64) {
		si_multiwave_lds_size_workaround(sscreen,
						 &shader->config.lds_size);
	}
d7849 1
a7849 1
	si_fix_resource_usage(sscreen, shader);
@


1.1.1.6
log
@Import Mesa 13.0.5
@
text
@d5399 1
a5399 2
	/* SI only (thanks to a hw bug workaround):
	 * The real barrier instruction isn’t needed, because an entire patch
d5402 1
a5402 3
	if (HAVE_LLVM >= 0x0309 &&
	    ctx->screen->b.chip_class == SI &&
	    ctx->type == PIPE_SHADER_TESS_CTRL) {
@


1.1.1.7
log
@Import Mesa 13.0.6
@
text
@d1879 1
a1879 1
	bool is_int8, is_int10;
a1900 1
		is_int10 = (key->ps.epilog.color_is_int10 >> cbuf) & 0x1;
d2000 2
a2001 5
		LLVMValueRef max_rgb = lp_build_const_int32(gallivm,
			is_int8 ? 255 : is_int10 ? 1023 : 65535);
		LLVMValueRef max_alpha =
			!is_int10 ? max_rgb : lp_build_const_int32(gallivm, 3);

d2006 1
a2006 2
					val[chan],
					chan == 3 ? max_alpha : max_rgb);
d2018 4
a2021 9
		LLVMValueRef max_rgb = lp_build_const_int32(gallivm,
			is_int8 ? 127 : is_int10 ? 511 : 32767);
		LLVMValueRef min_rgb = lp_build_const_int32(gallivm,
			is_int8 ? -128 : is_int10 ? -512 : -32768);
		LLVMValueRef max_alpha =
			!is_int10 ? max_rgb : lp_build_const_int32(gallivm, 1);
		LLVMValueRef min_alpha =
			!is_int10 ? min_rgb : lp_build_const_int32(gallivm, -2);

d2026 2
a2027 2
					TGSI_OPCODE_IMIN,
					val[chan], chan == 3 ? max_alpha : max_rgb);
d2029 2
a2030 2
					TGSI_OPCODE_IMAX,
					val[chan], chan == 3 ? min_alpha : min_rgb);
a6477 1
		fprintf(f, "  epilog.color_is_int10 = 0x%X\n", key->ps.epilog.color_is_int10);
@


1.1.1.8
log
@Import Mesa 17.1.6
@
text
@d36 1
a42 2
#include "ac_binary.h"
#include "ac_llvm_util.h"
d57 2
a58 3
	unsigned semantic_name;
	unsigned semantic_index;
	ubyte vertex_stream[4];
d70 1
a70 1
static void si_dump_shader_key(unsigned shader, struct si_shader_key *key,
a72 13
static unsigned llvm_get_type_size(LLVMTypeRef type);

static void si_build_vs_prolog_function(struct si_shader_context *ctx,
					union si_shader_part_key *key);
static void si_build_vs_epilog_function(struct si_shader_context *ctx,
					union si_shader_part_key *key);
static void si_build_tcs_epilog_function(struct si_shader_context *ctx,
					 union si_shader_part_key *key);
static void si_build_ps_prolog_function(struct si_shader_context *ctx,
					union si_shader_part_key *key);
static void si_build_ps_epilog_function(struct si_shader_context *ctx,
					union si_shader_part_key *key);

d88 8
d114 5
a118 3

		assert(!"invalid generic index");
		return 0;
d129 5
a133 23
		assert(!"invalid semantic name");
		return 0;
	}
}

unsigned si_shader_io_get_unique_index2(unsigned name, unsigned index)
{
	switch (name) {
	case TGSI_SEMANTIC_FOG:
		return 0;
	case TGSI_SEMANTIC_LAYER:
		return 1;
	case TGSI_SEMANTIC_VIEWPORT_INDEX:
		return 2;
	case TGSI_SEMANTIC_PRIMID:
		return 3;
	case TGSI_SEMANTIC_COLOR: /* these alias */
	case TGSI_SEMANTIC_BCOLOR:
		return 4 + index;
	case TGSI_SEMANTIC_TEXCOORD:
		return 6 + index;
	default:
		assert(!"invalid semantic name");
d150 1
a150 1
		value = bitcast(&ctx->bld_base,
d155 1
a155 1
				      LLVMConstInt(ctx->i32, rshift, 0), "");
d160 1
a160 1
				     LLVMConstInt(ctx->i32, mask, 0), "");
d207 1
a207 1
		return unpack_param(ctx, SI_PARAM_VS_STATE_BITS, 8, 13);
d209 1
a209 1
		return unpack_param(ctx, SI_PARAM_TCS_IN_LAYOUT, 8, 13);
d225 1
a225 1
	return lp_build_mul_imm(&ctx->bld_base.uint_bld,
d235 1
a235 1
	return lp_build_mul_imm(&ctx->bld_base.uint_bld,
d281 58
d340 1
a340 1
	struct si_shader_context *ctx,
d343 3
a345 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d347 1
a347 1
	LLVMValueRef result = LLVMGetParam(ctx->main_fn,
d353 1
a353 1
				LLVMConstInt(ctx->i32, divisor, 0), "");
d356 1
a356 16
			    LLVMGetParam(ctx->main_fn, param_start_instance), "");
}

/* Bitcast <4 x float> to <2 x double>, extract the component, and convert
 * to float. */
static LLVMValueRef extract_double_to_float(struct si_shader_context *ctx,
					    LLVMValueRef vec4,
					    unsigned double_index)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMTypeRef f64 = LLVMDoubleTypeInContext(ctx->gallivm.context);
	LLVMValueRef dvec2 = LLVMBuildBitCast(builder, vec4,
					      LLVMVectorType(f64, 2), "");
	LLVMValueRef index = LLVMConstInt(ctx->i32, double_index, 0);
	LLVMValueRef value = LLVMBuildExtractElement(builder, dvec2, index, "");
	return LLVMBuildFPTrunc(builder, value, ctx->f32, "");
d360 1
a360 1
	struct si_shader_context *ctx,
d365 6
a370 1
	struct gallivm_state *gallivm = &ctx->gallivm;
a372 3
	unsigned fix_fetch;
	unsigned num_fetches;
	unsigned fetch_stride;
d377 4
a380 2
	LLVMValueRef vertex_index;
	LLVMValueRef input[3];
d385 3
a387 1
	t_offset = LLVMConstInt(ctx->i32, input_index, 0);
d389 2
a390 1
	t_list = ac_build_indexed_load_const(&ctx->ac, t_list_ptr, t_offset);
d392 17
a408 29
	vertex_index = LLVMGetParam(ctx->main_fn,
				    ctx->param_vertex_index0 +
				    input_index);

	fix_fetch = ctx->shader->key.mono.vs.fix_fetch[input_index];

	/* Do multiple loads for special formats. */
	switch (fix_fetch) {
	case SI_FIX_FETCH_RGB_64_FLOAT:
		num_fetches = 3; /* 3 2-dword loads */
		fetch_stride = 8;
		break;
	case SI_FIX_FETCH_RGBA_64_FLOAT:
		num_fetches = 2; /* 2 4-dword loads */
		fetch_stride = 16;
		break;
	case SI_FIX_FETCH_RGB_8:
	case SI_FIX_FETCH_RGB_8_INT:
		num_fetches = 3;
		fetch_stride = 1;
		break;
	case SI_FIX_FETCH_RGB_16:
	case SI_FIX_FETCH_RGB_16_INT:
		num_fetches = 3;
		fetch_stride = 2;
		break;
	default:
		num_fetches = 1;
		fetch_stride = 0;
d411 6
a416 7
	for (unsigned i = 0; i < num_fetches; i++) {
		LLVMValueRef voffset = LLVMConstInt(ctx->i32, fetch_stride * i, 0);

		input[i] = ac_build_buffer_load_format(&ctx->ac, t_list,
						       vertex_index, voffset,
						       true);
	}
d420 1
a420 1
		LLVMValueRef llvm_chan = LLVMConstInt(ctx->i32, chan, 0);
d422 1
a422 134
						    input[0], llvm_chan, "");
	}

	switch (fix_fetch) {
	case SI_FIX_FETCH_A2_SNORM:
	case SI_FIX_FETCH_A2_SSCALED:
	case SI_FIX_FETCH_A2_SINT: {
		/* The hardware returns an unsigned value; convert it to a
		 * signed one.
		 */
		LLVMValueRef tmp = out[3];
		LLVMValueRef c30 = LLVMConstInt(ctx->i32, 30, 0);

		/* First, recover the sign-extended signed integer value. */
		if (fix_fetch == SI_FIX_FETCH_A2_SSCALED)
			tmp = LLVMBuildFPToUI(gallivm->builder, tmp, ctx->i32, "");
		else
			tmp = LLVMBuildBitCast(gallivm->builder, tmp, ctx->i32, "");

		/* For the integer-like cases, do a natural sign extension.
		 *
		 * For the SNORM case, the values are 0.0, 0.333, 0.666, 1.0
		 * and happen to contain 0, 1, 2, 3 as the two LSBs of the
		 * exponent.
		 */
		tmp = LLVMBuildShl(gallivm->builder, tmp,
				   fix_fetch == SI_FIX_FETCH_A2_SNORM ?
				   LLVMConstInt(ctx->i32, 7, 0) : c30, "");
		tmp = LLVMBuildAShr(gallivm->builder, tmp, c30, "");

		/* Convert back to the right type. */
		if (fix_fetch == SI_FIX_FETCH_A2_SNORM) {
			LLVMValueRef clamp;
			LLVMValueRef neg_one = LLVMConstReal(ctx->f32, -1.0);
			tmp = LLVMBuildSIToFP(gallivm->builder, tmp, ctx->f32, "");
			clamp = LLVMBuildFCmp(gallivm->builder, LLVMRealULT, tmp, neg_one, "");
			tmp = LLVMBuildSelect(gallivm->builder, clamp, neg_one, tmp, "");
		} else if (fix_fetch == SI_FIX_FETCH_A2_SSCALED) {
			tmp = LLVMBuildSIToFP(gallivm->builder, tmp, ctx->f32, "");
		}

		out[3] = tmp;
		break;
	}
	case SI_FIX_FETCH_RGBA_32_UNORM:
	case SI_FIX_FETCH_RGBX_32_UNORM:
		for (chan = 0; chan < 4; chan++) {
			out[chan] = LLVMBuildBitCast(gallivm->builder, out[chan],
						     ctx->i32, "");
			out[chan] = LLVMBuildUIToFP(gallivm->builder,
						    out[chan], ctx->f32, "");
			out[chan] = LLVMBuildFMul(gallivm->builder, out[chan],
						  LLVMConstReal(ctx->f32, 1.0 / UINT_MAX), "");
		}
		/* RGBX UINT returns 1 in alpha, which would be rounded to 0 by normalizing. */
		if (fix_fetch == SI_FIX_FETCH_RGBX_32_UNORM)
			out[3] = LLVMConstReal(ctx->f32, 1);
		break;
	case SI_FIX_FETCH_RGBA_32_SNORM:
	case SI_FIX_FETCH_RGBX_32_SNORM:
	case SI_FIX_FETCH_RGBA_32_FIXED:
	case SI_FIX_FETCH_RGBX_32_FIXED: {
		double scale;
		if (fix_fetch >= SI_FIX_FETCH_RGBA_32_FIXED)
			scale = 1.0 / 0x10000;
		else
			scale = 1.0 / INT_MAX;

		for (chan = 0; chan < 4; chan++) {
			out[chan] = LLVMBuildBitCast(gallivm->builder, out[chan],
						     ctx->i32, "");
			out[chan] = LLVMBuildSIToFP(gallivm->builder,
						    out[chan], ctx->f32, "");
			out[chan] = LLVMBuildFMul(gallivm->builder, out[chan],
						  LLVMConstReal(ctx->f32, scale), "");
		}
		/* RGBX SINT returns 1 in alpha, which would be rounded to 0 by normalizing. */
		if (fix_fetch == SI_FIX_FETCH_RGBX_32_SNORM ||
		    fix_fetch == SI_FIX_FETCH_RGBX_32_FIXED)
			out[3] = LLVMConstReal(ctx->f32, 1);
		break;
	}
	case SI_FIX_FETCH_RGBA_32_USCALED:
		for (chan = 0; chan < 4; chan++) {
			out[chan] = LLVMBuildBitCast(gallivm->builder, out[chan],
						     ctx->i32, "");
			out[chan] = LLVMBuildUIToFP(gallivm->builder,
						    out[chan], ctx->f32, "");
		}
		break;
	case SI_FIX_FETCH_RGBA_32_SSCALED:
		for (chan = 0; chan < 4; chan++) {
			out[chan] = LLVMBuildBitCast(gallivm->builder, out[chan],
						     ctx->i32, "");
			out[chan] = LLVMBuildSIToFP(gallivm->builder,
						    out[chan], ctx->f32, "");
		}
		break;
	case SI_FIX_FETCH_RG_64_FLOAT:
		for (chan = 0; chan < 2; chan++)
			out[chan] = extract_double_to_float(ctx, input[0], chan);

		out[2] = LLVMConstReal(ctx->f32, 0);
		out[3] = LLVMConstReal(ctx->f32, 1);
		break;
	case SI_FIX_FETCH_RGB_64_FLOAT:
		for (chan = 0; chan < 3; chan++)
			out[chan] = extract_double_to_float(ctx, input[chan], 0);

		out[3] = LLVMConstReal(ctx->f32, 1);
		break;
	case SI_FIX_FETCH_RGBA_64_FLOAT:
		for (chan = 0; chan < 4; chan++) {
			out[chan] = extract_double_to_float(ctx, input[chan / 2],
							    chan % 2);
		}
		break;
	case SI_FIX_FETCH_RGB_8:
	case SI_FIX_FETCH_RGB_8_INT:
	case SI_FIX_FETCH_RGB_16:
	case SI_FIX_FETCH_RGB_16_INT:
		for (chan = 0; chan < 3; chan++) {
			out[chan] = LLVMBuildExtractElement(gallivm->builder,
							    input[chan],
							    ctx->i32_0, "");
		}
		if (fix_fetch == SI_FIX_FETCH_RGB_8 ||
		    fix_fetch == SI_FIX_FETCH_RGB_16) {
			out[3] = LLVMConstReal(ctx->f32, 1);
		} else {
			out[3] = LLVMBuildBitCast(gallivm->builder, ctx->i32_1,
						  ctx->f32, "");
		}
		break;
d432 1
a432 1
		return ctx->i32_0;
d449 1
a449 1
		return ctx->i32_0;
d461 1
a461 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d464 1
a464 1
	result = ctx->addrs[ind->Index][ind->Swizzle];
d467 1
a467 1
			      LLVMConstInt(ctx->i32, rel_index, 0), "");
d485 1
a485 1
	if (HAVE_LLVM == 0x0308)
d501 1
a501 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d529 1
a529 1
			index = LLVMConstInt(ctx->i32, reg.Dimension.Index, 0);
d564 1
a564 1
						 LLVMConstInt(ctx->i32, 4, 0), ""), "");
d574 1
a574 1
			    LLVMConstInt(ctx->i32, param * 4, 0), "");
a595 1
					       LLVMValueRef rel_patch_id,
d599 1
a599 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d608 1
a608 1
	constant16 = LLVMConstInt(ctx->i32, 16, 0);
d610 1
a610 1
		base_addr = LLVMBuildMul(gallivm->builder, rel_patch_id,
d618 1
a618 1
		base_addr = rel_patch_id;
d643 1
a643 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d659 2
a660 1
			vertex_index = LLVMConstInt(ctx->i32, reg.Dimension.Index, 0);
d688 1
a688 1
		param_index = ctx->i32_0;
d695 1
a695 1
	                           LLVMConstInt(ctx->i32, param_index_base, 0),
d698 146
a843 2
	return get_tcs_tes_buffer_address(ctx, get_rel_patch_id(ctx),
					  vertex_index, param_index);
d849 1
a849 1
                                LLVMValueRef base, bool readonly_memory)
d852 1
a852 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d858 2
a859 2
		value = ac_build_buffer_load(&ctx->ac, buffer, 4, NULL, base, offset,
					     0, 1, 0, readonly_memory);
d865 2
a866 2
		value = ac_build_buffer_load(&ctx->ac, buffer, 4, NULL, base, offset,
					     0, 1, 0, readonly_memory);
d870 1
a870 1
		                    LLVMConstInt(ctx->i32, swizzle, 0), "");
d873 2
a874 2
	value = ac_build_buffer_load(&ctx->ac, buffer, 1, NULL, base, offset,
	                          swizzle * 4, 1, 0, readonly_memory);
d876 2
a877 2
	value2 = ac_build_buffer_load(&ctx->ac, buffer, 1, NULL, base, offset,
	                           swizzle * 4 + 4, 1, 0, readonly_memory);
d894 1
a894 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d903 1
a903 1
		return lp_build_gather_values(gallivm, values,
d908 1
a908 1
			    LLVMConstInt(ctx->i32, swizzle, 0));
d910 1
a910 1
	value = ac_build_indexed_load(&ctx->ac, ctx->lds, dw_addr, false);
d914 2
a915 2
				       ctx->i32_1);
		value2 = ac_build_indexed_load(&ctx->ac, ctx->lds, dw_addr, false);
d935 1
a935 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d938 1
a938 1
			    LLVMConstInt(ctx->i32, swizzle, 0));
d941 2
a942 2
	ac_build_indexed_store(&ctx->ac, ctx->lds,
			       dw_addr, value);
d953 1
a953 1
	stride = unpack_param(ctx, SI_PARAM_TCS_IN_LAYOUT, 24, 8);
d986 1
d991 2
a992 2
	buffer = ac_build_indexed_load_const(&ctx->ac, rw_buffers,
			LLVMConstInt(ctx->i32, SI_HS_RING_TESS_OFFCHIP, 0));
d997 1
a997 1
	return buffer_load(bld_base, type, swizzle, buffer, base, addr, true);
d1006 1
a1006 1
	struct gallivm_state *gallivm = &ctx->gallivm;
a1007 1
	const struct tgsi_shader_info *sh_info = &ctx->shader->selector->info;
a1011 2
	bool skip_lds_store;
	bool is_tess_factor = false;
a1025 1
		skip_lds_store = !sh_info->reads_pervertex_outputs;
a1028 12
		skip_lds_store = !sh_info->reads_perpatch_outputs;

		if (!reg->Register.Indirect) {
			int name = sh_info->output_semantic_name[reg->Register.Index];

			/* Always write tess factors into LDS for the TCS epilog. */
			if (name == TGSI_SEMANTIC_TESSINNER ||
			    name == TGSI_SEMANTIC_TESSOUTER) {
				skip_lds_store = false;
				is_tess_factor = true;
			}
		}
d1033 2
a1034 2
	buffer = ac_build_indexed_load_const(&ctx->ac, rw_buffers,
			LLVMConstInt(ctx->i32, SI_HS_RING_TESS_OFFCHIP, 0));
d1044 1
a1044 1
			value = ac_build_clamp(&ctx->ac, value);
d1046 1
a1046 3
		/* Skip LDS stores if there is no LDS read of this output. */
		if (!skip_lds_store)
			lds_store(bld_base, chan_index, dw_addr, value);
d1051 4
a1054 4
		if (inst->Dst[0].Register.WriteMask != 0xF && !is_tess_factor) {
			ac_build_buffer_store_dword(&ctx->ac, buffer, value, 1,
						    buf_addr, base,
						    4 * chan_index, 1, 0, true, false);
d1058 2
a1059 2
	if (inst->Dst[0].Register.WriteMask == 0xF && !is_tess_factor) {
		LLVMValueRef value = lp_build_gather_values(gallivm,
d1061 2
a1062 2
		ac_build_buffer_store_dword(&ctx->ac, buffer, value, 4, buf_addr,
					    base, 0, 1, 0, true, false);
d1072 1
d1075 4
a1078 3
	struct lp_build_context *uint =	&ctx->bld_base.uint_bld;
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef vtx_offset, soffset;
d1098 1
a1098 1
		return lp_build_gather_values(gallivm, values,
d1116 14
a1129 4
	soffset = LLVMConstInt(ctx->i32, (param * 4 + swizzle) * 256, 0);

	value = ac_build_buffer_load(&ctx->ac, ctx->esgs_ring, 1, ctx->i32_0,
				     vtx_offset, soffset, 0, 1, 0, true);
d1132 5
a1136 5
		soffset = LLVMConstInt(ctx->i32, (param * 4 + swizzle + 1) * 256, 0);

		value2 = ac_build_buffer_load(&ctx->ac, ctx->esgs_ring, 1,
					      ctx->i32_0, vtx_offset, soffset,
					      0, 1, 0, true);
d1174 39
d1238 4
a1241 1
	struct gallivm_state *gallivm = &ctx->gallivm;
a1242 1
	LLVMValueRef i, j;
d1246 2
a1256 3
	 *
	 * When interp is false we will use fs.constant or for newer llvm,
         * amdgcn.interp.mov.
d1258 1
a1258 13
	bool interp = interp_param != NULL;

	attr_number = LLVMConstInt(ctx->i32, input_index, 0);

	if (interp) {
		interp_param = LLVMBuildBitCast(gallivm->builder, interp_param,
						LLVMVectorType(ctx->f32, 2), "");

		i = LLVMBuildExtractElement(gallivm->builder, interp_param,
						ctx->i32_0, "");
		j = LLVMBuildExtractElement(gallivm->builder, interp_param,
						ctx->i32_1, "");
	}
d1261 2
a1262 1
	    ctx->shader->key.part.ps.prolog.color_two_side) {
d1273 1
a1273 1
		back_attr_number = LLVMConstInt(ctx->i32, back_attr_offset, 0);
d1276 1
a1276 1
						 face, ctx->i32_0, "");
d1278 2
d1281 1
a1281 1
			LLVMValueRef llvm_chan = LLVMConstInt(ctx->i32, chan, 0);
d1284 10
a1293 15
			if (interp) {
				front = ac_build_fs_interp(&ctx->ac, llvm_chan,
							attr_number, prim_mask,
							i, j);
				back = ac_build_fs_interp(&ctx->ac, llvm_chan,
							back_attr_number, prim_mask,
							i, j);
			} else {
				front = ac_build_fs_interp_mov(&ctx->ac,
					LLVMConstInt(ctx->i32, 2, 0), /* P0 */
					llvm_chan, attr_number, prim_mask);
				back = ac_build_fs_interp_mov(&ctx->ac,
					LLVMConstInt(ctx->i32, 2, 0), /* P0 */
					llvm_chan, back_attr_number, prim_mask);
			}
d1302 9
a1310 8
		if (interp) {
			result[0] = ac_build_fs_interp(&ctx->ac, ctx->i32_0,
						       attr_number, prim_mask, i, j);
		} else {
			result[0] = ac_build_fs_interp_mov(&ctx->ac, ctx->i32_0,
							   LLVMConstInt(ctx->i32, 2, 0), /* P0 */
							   attr_number, prim_mask);
		}
d1312 2
a1313 2
		result[2] = LLVMConstReal(ctx->f32, 0.0f);
		result[3] = LLVMConstReal(ctx->f32, 1.0f);
d1316 21
a1336 1
			LLVMValueRef llvm_chan = LLVMConstInt(ctx->i32, chan, 0);
d1338 34
a1371 8
			if (interp) {
				result[chan] = ac_build_fs_interp(&ctx->ac,
					llvm_chan, attr_number, prim_mask, i, j);
			} else {
				result[chan] = ac_build_fs_interp_mov(&ctx->ac,
					LLVMConstInt(ctx->i32, 2, 0), /* P0 */
					llvm_chan, attr_number, prim_mask);
			}
d1374 4
d1381 1
a1381 1
	struct si_shader_context *ctx,
d1386 3
a1388 1
	struct lp_build_context *base = &ctx->bld_base.base;
d1390 1
a1390 1
	LLVMValueRef main_fn = ctx->main_fn;
d1395 2
a1396 1
	if (decl->Semantic.Name == TGSI_SEMANTIC_COLOR) {
d1415 3
a1417 1
		interp_param = LLVMGetParam(ctx->main_fn, interp_param_idx);
d1422 1
a1422 1
	    ctx->shader->key.part.ps.prolog.flatshade_colors)
d1433 15
a1447 1
static LLVMValueRef get_sample_id(struct si_shader_context *ctx)
d1449 8
a1456 1
	return unpack_param(ctx, SI_PARAM_ANCILLARY, 8, 4);
d1459 23
d1494 1
a1494 2
				  LP_FUNC_ATTR_READNONE |
				  LP_FUNC_ATTR_LEGACY);
d1497 1
a1497 1
static LLVMValueRef load_sample_position(struct si_shader_context *ctx, LLVMValueRef sample_id)
d1499 4
a1502 2
	struct lp_build_context *uint_bld = &ctx->bld_base.uint_bld;
	struct gallivm_state *gallivm = &ctx->gallivm;
d1505 2
a1506 2
	LLVMValueRef buf_index = LLVMConstInt(ctx->i32, SI_PS_CONST_SAMPLE_POSITIONS, 0);
	LLVMValueRef resource = ac_build_indexed_load_const(&ctx->ac, desc, buf_index);
d1510 1
a1510 1
	LLVMValueRef offset1 = LLVMBuildAdd(builder, offset0, LLVMConstInt(ctx->i32, 4, 0), "");
d1515 2
a1516 2
		LLVMConstReal(ctx->f32, 0),
		LLVMConstReal(ctx->f32, 0)
d1522 9
a1530 6
static void declare_system_value(struct si_shader_context *ctx,
				 unsigned index,
				 const struct tgsi_full_declaration *decl)
{
	struct lp_build_context *bld = &ctx->bld_base.base;
	struct gallivm_state *gallivm = &ctx->gallivm;
a1532 2
	assert(index < RADEON_LLVM_MAX_SYSTEM_VALUES);

d1535 1
a1535 1
		value = LLVMGetParam(ctx->main_fn,
d1541 1
a1541 1
				     LLVMGetParam(ctx->main_fn,
d1543 1
a1543 1
				     LLVMGetParam(ctx->main_fn,
d1548 2
a1549 3
		/* Unused. Clarify the meaning in indexed vs. non-indexed
		 * draws if this is ever used again. */
		assert(false);
d1553 2
a1554 14
	{
		/* For non-indexed draws, the base vertex set by the driver
		 * (for direct draws) or the CP (for indirect draws) is the
		 * first vertex ID, but GLSL expects 0 to be returned.
		 */
		LLVMValueRef vs_state = LLVMGetParam(ctx->main_fn, SI_PARAM_VS_STATE_BITS);
		LLVMValueRef indexed;

		indexed = LLVMBuildLShr(gallivm->builder, vs_state, ctx->i32_1, "");
		indexed = LLVMBuildTrunc(gallivm->builder, indexed, ctx->i1, "");

		value = LLVMBuildSelect(gallivm->builder, indexed,
					LLVMGetParam(ctx->main_fn, SI_PARAM_BASE_VERTEX),
					ctx->i32_0, "");
a1555 1
	}
d1558 1
a1558 1
		value = LLVMGetParam(ctx->main_fn,
d1563 1
a1563 1
		value = LLVMGetParam(ctx->main_fn,
d1571 1
a1571 1
			value = LLVMGetParam(ctx->main_fn,
d1580 5
a1584 5
			LLVMGetParam(ctx->main_fn, SI_PARAM_POS_X_FLOAT),
			LLVMGetParam(ctx->main_fn, SI_PARAM_POS_Y_FLOAT),
			LLVMGetParam(ctx->main_fn, SI_PARAM_POS_Z_FLOAT),
			lp_build_emit_llvm_unary(&ctx->bld_base, TGSI_OPCODE_RCP,
						 LLVMGetParam(ctx->main_fn,
d1592 1
a1592 1
		value = LLVMGetParam(ctx->main_fn, SI_PARAM_FRONT_FACE);
d1596 1
a1596 1
		value = get_sample_id(ctx);
d1601 4
a1604 4
			LLVMGetParam(ctx->main_fn, SI_PARAM_POS_X_FLOAT),
			LLVMGetParam(ctx->main_fn, SI_PARAM_POS_Y_FLOAT),
			LLVMConstReal(ctx->f32, 0),
			LLVMConstReal(ctx->f32, 0)
d1606 1
a1606 1
		pos[0] = lp_build_emit_llvm_unary(&ctx->bld_base,
d1608 1
a1608 1
		pos[1] = lp_build_emit_llvm_unary(&ctx->bld_base,
d1618 1
a1618 1
		value = LLVMGetParam(ctx->main_fn, SI_PARAM_SAMPLE_COVERAGE);
d1624 2
a1625 2
			LLVMGetParam(ctx->main_fn, ctx->param_tes_u),
			LLVMGetParam(ctx->main_fn, ctx->param_tes_v),
d1657 2
a1658 2
		buffer = ac_build_indexed_load_const(&ctx->ac, rw_buffers,
		        LLVMConstInt(ctx->i32, SI_HS_RING_TESS_OFFCHIP, 0));
d1661 2
a1662 2
		addr = get_tcs_tes_buffer_address(ctx, get_rel_patch_id(ctx), NULL,
		                          LLVMConstInt(ctx->i32, param, 0));
d1664 2
a1665 2
		value = buffer_load(&ctx->bld_base, TGSI_TYPE_FLOAT,
		                    ~0, buffer, base, addr, true);
d1676 1
a1676 1
		slot = LLVMConstInt(ctx->i32, SI_HS_CONST_DEFAULT_TESS_LEVELS, 0);
d1678 1
a1678 1
		buf = ac_build_indexed_load_const(&ctx->ac, buf, slot);
d1683 1
a1683 1
						   LLVMConstInt(ctx->i32, (offset + i) * 4, 0));
d1689 1
a1689 1
		value = get_primitive_id(&ctx->bld_base, 0);
d1693 1
a1693 1
		value = LLVMGetParam(ctx->main_fn, SI_PARAM_GRID_SIZE);
d1710 1
a1710 1
				values[i] = LLVMConstInt(ctx->i32, sizes[i], 0);
d1714 1
a1714 1
			value = LLVMGetParam(ctx->main_fn, SI_PARAM_BLOCK_SIZE);
d1720 1
a1720 1
		value = LLVMGetParam(ctx->main_fn, SI_PARAM_BLOCK_ID);
d1724 1
a1724 1
		value = LLVMGetParam(ctx->main_fn, SI_PARAM_THREAD_ID);
d1727 1
d1729 6
a1734 11
		if (HAVE_LLVM >= 0x0309) {
			value = lp_build_intrinsic(gallivm->builder,
						   "llvm.amdgcn.ps.live",
						   ctx->i1, NULL, 0,
						   LP_FUNC_ATTR_READNONE);
			value = LLVMBuildNot(gallivm->builder, value, "");
			value = LLVMBuildSExt(gallivm->builder, value, ctx->i32, "");
		} else {
			assert(!"TGSI_SEMANTIC_HELPER_INVOCATION unsupported");
			return;
		}
d1736 1
a1736 40

	case TGSI_SEMANTIC_SUBGROUP_SIZE:
		value = LLVMConstInt(ctx->i32, 64, 0);
		break;

	case TGSI_SEMANTIC_SUBGROUP_INVOCATION:
		value = ac_get_thread_id(&ctx->ac);
		break;

	case TGSI_SEMANTIC_SUBGROUP_EQ_MASK:
	{
		LLVMValueRef id = ac_get_thread_id(&ctx->ac);
		id = LLVMBuildZExt(gallivm->builder, id, ctx->i64, "");
		value = LLVMBuildShl(gallivm->builder, LLVMConstInt(ctx->i64, 1, 0), id, "");
		value = LLVMBuildBitCast(gallivm->builder, value, ctx->v2i32, "");
		break;
	}

	case TGSI_SEMANTIC_SUBGROUP_GE_MASK:
	case TGSI_SEMANTIC_SUBGROUP_GT_MASK:
	case TGSI_SEMANTIC_SUBGROUP_LE_MASK:
	case TGSI_SEMANTIC_SUBGROUP_LT_MASK:
	{
		LLVMValueRef id = ac_get_thread_id(&ctx->ac);
		if (decl->Semantic.Name == TGSI_SEMANTIC_SUBGROUP_GT_MASK ||
		    decl->Semantic.Name == TGSI_SEMANTIC_SUBGROUP_LE_MASK) {
			/* All bits set except LSB */
			value = LLVMConstInt(ctx->i64, -2, 0);
		} else {
			/* All bits set */
			value = LLVMConstInt(ctx->i64, -1, 0);
		}
		id = LLVMBuildZExt(gallivm->builder, id, ctx->i64, "");
		value = LLVMBuildShl(gallivm->builder, value, id, "");
		if (decl->Semantic.Name == TGSI_SEMANTIC_SUBGROUP_LE_MASK ||
		    decl->Semantic.Name == TGSI_SEMANTIC_SUBGROUP_LT_MASK)
			value = LLVMBuildNot(gallivm->builder, value, "");
		value = LLVMBuildBitCast(gallivm->builder, value, ctx->v2i32, "");
		break;
	}
d1743 1
a1743 1
	ctx->system_values[index] = value;
d1746 1
a1746 1
static void declare_compute_memory(struct si_shader_context *ctx,
d1749 2
d1752 1
a1752 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d1775 1
a1775 1
	return ac_build_indexed_load_const(&ctx->ac, list_ptr,
d1799 1
a1799 1
		return lp_build_gather_values(&ctx->gallivm, values, 4);
d1811 1
a1811 1
		bufp = ac_build_indexed_load_const(&ctx->ac, ptr, index);
d1816 1
a1816 1
		addr = ctx->addrs[ireg->Index][ireg->Swizzle];
d1820 1
a1820 1
				    LLVMConstInt(ctx->i32, idx * 4, 0));
d1843 1
a1843 1
static LLVMValueRef si_llvm_pack_two_int16(struct si_shader_context *ctx,
d1846 3
a1848 3
	return LLVMBuildOr(ctx->gallivm.builder, val[0],
			   LLVMBuildShl(ctx->gallivm.builder, val[1],
					LLVMConstInt(ctx->i32, 16, 0),
d1853 1
a1853 1
static LLVMValueRef si_llvm_pack_two_int32_as_int16(struct si_shader_context *ctx,
d1857 2
a1858 2
		LLVMBuildAnd(ctx->gallivm.builder, val[0],
			     LLVMConstInt(ctx->i32, 0xffff, 0), ""),
d1861 1
a1861 1
	return si_llvm_pack_two_int16(ctx, v);
d1868 1
a1868 1
				     struct ac_export_args *args)
d1871 2
d1874 2
a1875 1
	LLVMBuilderRef builder = ctx->gallivm.builder;
d1882 1
a1882 1
	args->enabled_channels = 0xf; /* writemask */
d1885 1
a1885 1
	args->valid_mask = 0;
d1888 1
a1888 1
	args->done = 0;
d1891 1
a1891 1
	args->target = target;
d1894 2
a1895 2
		const struct si_shader_key *key = &ctx->shader->key;
		unsigned col_formats = key->part.ps.epilog.spi_shader_col_format;
d1900 2
a1901 2
		is_int8 = (key->part.ps.epilog.color_is_int8 >> cbuf) & 0x1;
		is_int10 = (key->part.ps.epilog.color_is_int10 >> cbuf) & 0x1;
d1904 5
a1908 5
	args->compr = false;
	args->out[0] = base->undef;
	args->out[1] = base->undef;
	args->out[2] = base->undef;
	args->out[3] = base->undef;
d1912 2
a1913 2
		args->enabled_channels = 0; /* writemask */
		args->target = V_008DFC_SQ_EXP_NULL;
d1917 2
a1918 2
		args->enabled_channels = 1; /* writemask */
		args->out[0] = values[0];
d1922 3
a1924 3
		args->enabled_channels = 0x3; /* writemask */
		args->out[0] = values[0];
		args->out[1] = values[1];
d1928 3
a1930 3
		args->enabled_channels = 0x9; /* writemask */
		args->out[0] = values[0];
		args->out[3] = values[3];
d1934 1
a1934 1
		args->compr = 1; /* COMPR flag */
d1943 6
a1948 3
			packed = ac_build_cvt_pkrtz_f16(&ctx->ac, pack_args);
			args->out[chan] =
				LLVMBuildBitCast(ctx->gallivm.builder,
d1955 1
a1955 1
			val[chan] = ac_build_clamp(&ctx->ac, values[chan]);
d1957 1
a1957 1
						  LLVMConstReal(ctx->f32, 65535), "");
d1959 1
a1959 1
						  LLVMConstReal(ctx->f32, 0.5), "");
d1964 5
a1968 5
		args->compr = 1; /* COMPR flag */
		args->out[0] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int16(ctx, val));
		args->out[1] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int16(ctx, val+2));
d1976 1
a1976 1
							      LLVMConstReal(ctx->f32, 1));
d1979 1
a1979 1
							      LLVMConstReal(ctx->f32, -1));
d1982 1
a1982 1
						  LLVMConstReal(ctx->f32, 32767), "");
d1988 2
a1989 2
						LLVMConstReal(ctx->f32, 0.5),
						LLVMConstReal(ctx->f32, -0.5), ""), "");
d1993 5
a1997 5
		args->compr = 1; /* COMPR flag */
		args->out[0] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int32_as_int16(ctx, val));
		args->out[1] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int32_as_int16(ctx, val+2));
d2001 2
a2002 2
		LLVMValueRef max_rgb = LLVMConstInt(ctx->i32,
			is_int8 ? 255 : is_int10 ? 1023 : 65535, 0);
d2004 1
a2004 1
			!is_int10 ? max_rgb : LLVMConstInt(ctx->i32, 3, 0);
d2014 5
a2018 5
		args->compr = 1; /* COMPR flag */
		args->out[0] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int16(ctx, val));
		args->out[1] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int16(ctx, val+2));
d2023 4
a2026 4
		LLVMValueRef max_rgb = LLVMConstInt(ctx->i32,
			is_int8 ? 127 : is_int10 ? 511 : 32767, 0);
		LLVMValueRef min_rgb = LLVMConstInt(ctx->i32,
			is_int8 ? -128 : is_int10 ? -512 : -32768, 0);
d2028 1
a2028 1
			!is_int10 ? max_rgb : ctx->i32_1;
d2030 1
a2030 1
			!is_int10 ? min_rgb : LLVMConstInt(ctx->i32, -2, 0);
d2043 5
a2047 5
		args->compr = 1; /* COMPR flag */
		args->out[0] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int32_as_int16(ctx, val));
		args->out[1] = bitcast(bld_base, TGSI_TYPE_FLOAT,
				  si_llvm_pack_two_int32_as_int16(ctx, val+2));
d2052 1
a2052 1
		memcpy(&args->out[0], values, sizeof(values[0]) * 4);
d2061 1
d2063 1
a2063 1
	if (ctx->shader->key.part.ps.epilog.alpha_func != PIPE_FUNC_NEVER) {
d2069 1
a2069 1
				     ctx->shader->key.part.ps.epilog.alpha_func,
d2074 2
a2075 2
					LLVMConstReal(ctx->f32, 1.0f),
					LLVMConstReal(ctx->f32, -1.0f));
d2077 2
a2078 1
		ac_build_kill(&ctx->ac, arg);
d2080 2
a2081 1
		ac_build_kill(&ctx->ac, NULL);
d2090 1
a2090 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d2100 1
a2100 1
				   &coverage, 1, LP_FUNC_ATTR_READNONE);
d2106 1
a2106 1
				 LLVMConstReal(ctx->f32,
d2113 1
a2113 1
				    struct ac_export_args *pos, LLVMValueRef *out_elts)
d2117 1
d2123 3
a2125 3
	LLVMValueRef constbuf_index = LLVMConstInt(ctx->i32,
						   SI_VS_CONST_CLIP_PLANES, 0);
	LLVMValueRef const_resource = ac_build_indexed_load_const(&ctx->ac, ptr, constbuf_index);
d2128 1
a2128 1
		struct ac_export_args *args = &pos[2 + reg_index];
d2130 4
a2133 4
		args->out[0] =
		args->out[1] =
		args->out[2] =
		args->out[3] = LLVMConstReal(ctx->f32, 0.0f);
d2138 3
a2140 3
				LLVMValueRef addr =
					LLVMConstInt(ctx->i32, ((reg_index * 4 + chan) * 4 +
								const_chan) * 4, 0);
d2142 3
a2144 3
							     addr);
				args->out[chan] =
					lp_build_add(base, args->out[chan],
d2150 6
a2155 5
		args->enabled_channels = 0xf;
		args->valid_mask = 0;
		args->done = 0;
		args->target = V_008DFC_SQ_EXP_POS + 2 + reg_index;
		args->compr = 0;
d2180 5
a2184 5
static void emit_streamout_output(struct si_shader_context *ctx,
				  LLVMValueRef const *so_buffers,
				  LLVMValueRef const *so_write_offsets,
				  struct pipe_stream_output *stream_out,
				  struct si_shader_output_values *shader_out)
d2186 1
d2189 5
a2193 12
	unsigned buf_idx = stream_out->output_buffer;
	unsigned start = stream_out->start_component;
	unsigned num_comps = stream_out->num_components;
	LLVMValueRef out[4];

	assert(num_comps && num_comps <= 4);
	if (!num_comps || num_comps > 4)
		return;

	/* Load the output as int. */
	for (int j = 0; j < num_comps; j++) {
		assert(stream_out->stream == shader_out->vertex_stream[start + j]);
d2195 5
a2199 7
		out[j] = LLVMBuildBitCast(builder,
					  shader_out->values[start + j],
				ctx->i32, "");
	}

	/* Pack the output. */
	LLVMValueRef vdata = NULL;
d2201 1
a2201 11
	switch (num_comps) {
	case 1: /* as i32 */
		vdata = out[0];
		break;
	case 2: /* as v2i32 */
	case 3: /* as v4i32 (aligned to 4) */
	case 4: /* as v4i32 */
		vdata = LLVMGetUndef(LLVMVectorType(ctx->i32, util_next_power_of_two(num_comps)));
		for (int j = 0; j < num_comps; j++) {
			vdata = LLVMBuildInsertElement(builder, vdata, out[j],
						       LLVMConstInt(ctx->i32, j, 0), "");
a2202 1
		break;
a2204 22
	ac_build_buffer_store_dword(&ctx->ac, so_buffers[buf_idx],
				    vdata, num_comps,
				    so_write_offsets[buf_idx],
				    ctx->i32_0,
				    stream_out->dst_offset * 4, 1, 1, true, false);
}

/**
 * Write streamout data to buffers for vertex stream @@p stream (different
 * vertex streams can occur for GS copy shaders).
 */
static void si_llvm_emit_streamout(struct si_shader_context *ctx,
				   struct si_shader_output_values *outputs,
				   unsigned noutput, unsigned stream)
{
	struct si_shader_selector *sel = ctx->shader->selector;
	struct pipe_stream_output_info *so = &sel->so;
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	int i;
	struct lp_build_if_state if_ctx;

d2209 1
a2209 1
	LLVMValueRef tid = ac_get_thread_id(&ctx->ac);
d2215 3
d2236 1
a2236 2
		/* Load the descriptor and compute the write offset for each
		 * enabled buffer. */
a2237 4
		LLVMValueRef so_buffers[4];
		LLVMValueRef buf_ptr = LLVMGetParam(ctx->main_fn,
						    SI_PARAM_RW_BUFFERS);

a2241 5
			LLVMValueRef offset = LLVMConstInt(ctx->i32,
							   SI_VS_STREAMOUT_BUF0 + i, 0);

			so_buffers[i] = ac_build_indexed_load_const(&ctx->ac, buf_ptr, offset);

d2253 1
d2255 9
d2268 24
a2291 2
			if (stream != so->output[i].stream)
				continue;
d2293 12
a2304 2
			emit_streamout_output(ctx, so_buffers, so_write_offset,
					      &so->output[i], &outputs[reg]);
d2319 4
a2322 1
	struct ac_export_args args, pos_args[4] = {};
d2330 4
d2335 2
a2336 28
		semantic_name = outputs[i].semantic_name;
		semantic_index = outputs[i].semantic_index;
		bool export_param = true;

		switch (semantic_name) {
		case TGSI_SEMANTIC_POSITION: /* ignore these */
		case TGSI_SEMANTIC_PSIZE:
		case TGSI_SEMANTIC_CLIPVERTEX:
		case TGSI_SEMANTIC_EDGEFLAG:
			break;
		case TGSI_SEMANTIC_GENERIC:
		case TGSI_SEMANTIC_CLIPDIST:
			if (shader->key.opt.hw_vs.kill_outputs &
			    (1ull << si_shader_io_get_unique_index(semantic_name, semantic_index)))
				export_param = false;
			break;
		default:
			if (shader->key.opt.hw_vs.kill_outputs2 &
			    (1u << si_shader_io_get_unique_index2(semantic_name, semantic_index)))
				export_param = false;
			break;
		}

		if (outputs[i].vertex_stream[0] != 0 &&
		    outputs[i].vertex_stream[1] != 0 &&
		    outputs[i].vertex_stream[2] != 0 &&
		    outputs[i].vertex_stream[3] != 0)
			export_param = false;
d2358 7
a2365 4
			if (shader->key.opt.hw_vs.clip_disable) {
				semantic_name = TGSI_SEMANTIC_GENERIC;
				goto handle_semantic;
			}
a2368 2
			if (shader->key.opt.hw_vs.clip_disable)
				continue;
a2370 2
		case TGSI_SEMANTIC_COLOR:
		case TGSI_SEMANTIC_BCOLOR:
a2374 2
			if (!export_param)
				continue;
d2387 1
a2387 1
		si_llvm_init_export_args(bld_base, outputs[i].values, target, &args);
d2391 2
a2392 2
			memcpy(&pos_args[target - V_008DFC_SQ_EXP_POS],
			       &args, sizeof(args));
d2394 3
a2396 1
			ac_build_export(&ctx->ac, &args);
d2408 10
a2417 10
	if (!pos_args[0].out[0]) {
		pos_args[0].enabled_channels = 0xf; /* writemask */
		pos_args[0].valid_mask = 0; /* EXEC mask */
		pos_args[0].done = 0; /* last export? */
		pos_args[0].target = V_008DFC_SQ_EXP_POS;
		pos_args[0].compr = 0; /* COMPR flag */
		pos_args[0].out[0] = base->zero; /* X */
		pos_args[0].out[1] = base->zero; /* Y */
		pos_args[0].out[2] = base->zero; /* Z */
		pos_args[0].out[3] = base->one;  /* W */
d2425 13
a2437 12
		pos_args[1].enabled_channels = shader->selector->info.writes_psize |
					       (shader->selector->info.writes_edgeflag << 1) |
					       (shader->selector->info.writes_layer << 2);

		pos_args[1].valid_mask = 0; /* EXEC mask */
		pos_args[1].done = 0; /* last export? */
		pos_args[1].target = V_008DFC_SQ_EXP_POS + 1;
		pos_args[1].compr = 0; /* COMPR flag */
		pos_args[1].out[0] = base->zero; /* X */
		pos_args[1].out[1] = base->zero; /* Y */
		pos_args[1].out[2] = base->zero; /* Z */
		pos_args[1].out[3] = base->zero; /* W */
d2440 1
a2440 1
			pos_args[1].out[0] = psize_value;
d2445 1
a2445 1
			edgeflag_value = LLVMBuildFPToUI(ctx->gallivm.builder,
d2450 1
a2450 1
						      ctx->i32_1);
d2453 1
a2453 1
			pos_args[1].out[1] = LLVMBuildBitCast(ctx->gallivm.builder,
d2458 2
a2459 22
		if (ctx->screen->b.chip_class >= GFX9) {
			/* GFX9 has the layer in out.z[10:0] and the viewport
			 * index in out.z[19:16].
			 */
			if (shader->selector->info.writes_layer)
				pos_args[1].out[2] = layer_value;

			if (shader->selector->info.writes_viewport_index) {
				LLVMValueRef v = viewport_index_value;

				v = bitcast(bld_base, TGSI_TYPE_UNSIGNED, v);
				v = LLVMBuildShl(ctx->gallivm.builder, v,
						 LLVMConstInt(ctx->i32, 16, 0), "");
				v = LLVMBuildOr(ctx->gallivm.builder, v,
						bitcast(bld_base, TGSI_TYPE_UNSIGNED,
						        pos_args[1].out[2]), "");
				pos_args[1].out[2] = bitcast(bld_base, TGSI_TYPE_FLOAT, v);
				pos_args[1].enabled_channels |= 1 << 2;
			}
		} else {
			if (shader->selector->info.writes_layer)
				pos_args[1].out[2] = layer_value;
d2461 2
a2462 5
			if (shader->selector->info.writes_viewport_index) {
				pos_args[1].out[3] = viewport_index_value;
				pos_args[1].enabled_channels |= 1 << 3;
			}
		}
d2466 1
a2466 1
		if (pos_args[i].out[0])
d2471 1
a2471 1
		if (!pos_args[i].out[0])
d2475 1
a2475 1
		pos_args[i].target = V_008DFC_SQ_EXP_POS + pos_idx++;
d2479 1
a2479 1
			pos_args[i].done = 1;
d2481 2
a2482 1
		ac_build_export(&ctx->ac, &pos_args[i]);
a2485 4
/**
 * Forward all outputs from the vertex shader to the TES. This is only used
 * for the fixed function TCS.
 */
d2489 1
a2489 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d2497 2
a2498 2
	buffer = ac_build_indexed_load_const(&ctx->ac, rw_buffers,
	                LLVMConstInt(ctx->i32, SI_HS_RING_TESS_OFFCHIP, 0));
d2502 1
a2502 1
	lds_vertex_stride = unpack_param(ctx, SI_PARAM_TCS_IN_LAYOUT, 24, 8);
d2508 1
a2508 1
	inputs = ctx->shader->key.mono.tcs.inputs_to_copy;
d2513 1
a2513 1
		                            LLVMConstInt(ctx->i32, 4 * i, 0),
a2516 1
					      get_rel_patch_id(ctx),
d2518 1
a2518 1
		                              LLVMConstInt(ctx->i32, i, 0));
d2523 2
a2524 2
		ac_build_buffer_store_dword(&ctx->ac, buffer, value, 4, buffer_addr,
					    buffer_offset, 0, 1, 0, true, false);
d2534 1
a2534 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d2538 1
a2538 1
	LLVMValueRef out[6], vec0, vec1, rw_buffers, tf_base, inner[4], outer[4];
d2552 1
a2552 1
				  invocation_id, ctx->i32_0, ""));
d2555 1
a2555 1
	switch (shader->key.part.tcs.epilog.prim_mode) {
d2584 2
a2585 2
				 LLVMConstInt(ctx->i32,
					      tess_inner_index * 4, 0), "");
d2587 2
a2588 7
				 LLVMConstInt(ctx->i32,
					      tess_outer_index * 4, 0), "");

	for (i = 0; i < 4; i++) {
		inner[i] = LLVMGetUndef(ctx->i32);
		outer[i] = LLVMGetUndef(ctx->i32);
	}
d2590 1
a2590 1
	if (shader->key.part.tcs.epilog.prim_mode == PIPE_PRIM_LINES) {
d2594 2
a2595 2
		outer[0] = out[1] = lds_load(bld_base, TGSI_TYPE_SIGNED, 0, lds_outer);
		outer[1] = out[0] = lds_load(bld_base, TGSI_TYPE_SIGNED, 1, lds_outer);
d2597 4
a2600 8
		for (i = 0; i < outer_comps; i++) {
			outer[i] = out[i] =
				lds_load(bld_base, TGSI_TYPE_SIGNED, i, lds_outer);
		}
		for (i = 0; i < inner_comps; i++) {
			inner[i] = out[outer_comps+i] =
				lds_load(bld_base, TGSI_TYPE_SIGNED, i, lds_inner);
		}
d2613 2
a2614 2
	buffer = ac_build_indexed_load_const(&ctx->ac, rw_buffers,
			LLVMConstInt(ctx->i32, SI_HS_RING_TESS_FACTOR, 0));
d2620 1
a2620 1
				  LLVMConstInt(ctx->i32, 4 * stride, 0), "");
d2624 1
a2624 1
				  rel_patch_id, ctx->i32_0, ""));
d2627 3
a2629 4
	ac_build_buffer_store_dword(&ctx->ac, buffer,
				    LLVMConstInt(ctx->i32, 0x80000000, 0),
				    1, ctx->i32_0, tf_base,
				    0, 1, 0, true, false);
d2634 2
a2635 3
	ac_build_buffer_store_dword(&ctx->ac, buffer, vec0,
				    MIN2(stride, 4), byteoffset, tf_base,
				    4, 1, 0, true, false);
d2637 2
a2638 39
		ac_build_buffer_store_dword(&ctx->ac, buffer, vec1,
					    stride - 4, byteoffset, tf_base,
					    20, 1, 0, true, false);

	/* Store the tess factors into the offchip buffer if TES reads them. */
	if (shader->key.part.tcs.epilog.tes_reads_tess_factors) {
		LLVMValueRef buf, base, inner_vec, outer_vec, tf_outer_offset;
		LLVMValueRef tf_inner_offset;
		unsigned param_outer, param_inner;

		buf = ac_build_indexed_load_const(&ctx->ac, rw_buffers,
				LLVMConstInt(ctx->i32, SI_HS_RING_TESS_OFFCHIP, 0));
		base = LLVMGetParam(ctx->main_fn, ctx->param_oc_lds);

		param_outer = si_shader_io_get_unique_index(
				      TGSI_SEMANTIC_TESSOUTER, 0);
		tf_outer_offset = get_tcs_tes_buffer_address(ctx, rel_patch_id, NULL,
					LLVMConstInt(ctx->i32, param_outer, 0));

		outer_vec = lp_build_gather_values(gallivm, outer,
						   util_next_power_of_two(outer_comps));

		ac_build_buffer_store_dword(&ctx->ac, buf, outer_vec,
					    outer_comps, tf_outer_offset,
					    base, 0, 1, 0, true, false);
		if (inner_comps) {
			param_inner = si_shader_io_get_unique_index(
					      TGSI_SEMANTIC_TESSINNER, 0);
			tf_inner_offset = get_tcs_tes_buffer_address(ctx, rel_patch_id, NULL,
					LLVMConstInt(ctx->i32, param_inner, 0));

			inner_vec = inner_comps == 1 ? inner[0] :
				    lp_build_gather_values(gallivm, inner, inner_comps);
			ac_build_buffer_store_dword(&ctx->ac, buf, inner_vec,
						    inner_comps, tf_inner_offset,
						    base, 0, 1, 0, true, false);
		}
	}

a2646 3
	LLVMValueRef offchip_soffset, offchip_layout;

	si_copy_tcs_inputs(bld_base);
d2652 37
a2688 5
	/* Return epilog parameters from this function. */
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMValueRef ret = ctx->return_value;
	LLVMValueRef rw_buffers, rw0, rw1, tf_soffset;
	unsigned vgpr;
d2690 2
a2691 35
	/* RW_BUFFERS pointer */
	rw_buffers = LLVMGetParam(ctx->main_fn,
				  SI_PARAM_RW_BUFFERS);
	rw_buffers = LLVMBuildPtrToInt(builder, rw_buffers, ctx->i64, "");
	rw_buffers = LLVMBuildBitCast(builder, rw_buffers, ctx->v2i32, "");
	rw0 = LLVMBuildExtractElement(builder, rw_buffers,
				      ctx->i32_0, "");
	rw1 = LLVMBuildExtractElement(builder, rw_buffers,
				      ctx->i32_1, "");
	ret = LLVMBuildInsertValue(builder, ret, rw0, 0, "");
	ret = LLVMBuildInsertValue(builder, ret, rw1, 1, "");

	/* Tess offchip and factor buffer soffset are after user SGPRs. */
	offchip_layout = LLVMGetParam(ctx->main_fn,
				      SI_PARAM_TCS_OFFCHIP_LAYOUT);
	offchip_soffset = LLVMGetParam(ctx->main_fn, ctx->param_oc_lds);
	tf_soffset = LLVMGetParam(ctx->main_fn,
				  SI_PARAM_TESS_FACTOR_OFFSET);
	ret = LLVMBuildInsertValue(builder, ret, offchip_layout,
				   SI_SGPR_TCS_OFFCHIP_LAYOUT, "");
	ret = LLVMBuildInsertValue(builder, ret, offchip_soffset,
				   SI_TCS_NUM_USER_SGPR, "");
	ret = LLVMBuildInsertValue(builder, ret, tf_soffset,
				   SI_TCS_NUM_USER_SGPR + 1, "");

	/* VGPRs */
	rel_patch_id = bitcast(bld_base, TGSI_TYPE_FLOAT, rel_patch_id);
	invocation_id = bitcast(bld_base, TGSI_TYPE_FLOAT, invocation_id);
	tf_lds_offset = bitcast(bld_base, TGSI_TYPE_FLOAT, tf_lds_offset);

	vgpr = SI_TCS_NUM_USER_SGPR + 2;
	ret = LLVMBuildInsertValue(builder, ret, rel_patch_id, vgpr++, "");
	ret = LLVMBuildInsertValue(builder, ret, invocation_id, vgpr++, "");
	ret = LLVMBuildInsertValue(builder, ret, tf_lds_offset, vgpr++, "");
	ctx->return_value = ret;
d2699 1
a2699 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d2704 1
a2704 1
		unpack_param(ctx, SI_PARAM_VS_STATE_BITS, 24, 8);
d2711 1
a2711 1
		LLVMValueRef *out_ptr = ctx->outputs[i];
a2713 20

		/* The ARB_shader_viewport_layer_array spec contains the
		 * following issue:
		 *
		 *    2) What happens if gl_ViewportIndex or gl_Layer is
		 *    written in the vertex shader and a geometry shader is
		 *    present?
		 *
		 *    RESOLVED: The value written by the last vertex processing
		 *    stage is used. If the last vertex processing stage
		 *    (vertex, tessellation evaluation or geometry) does not
		 *    statically assign to gl_ViewportIndex or gl_Layer, index
		 *    or layer zero is assumed.
		 *
		 * So writes to those outputs in VS-as-LS are simply ignored.
		 */
		if (name == TGSI_SEMANTIC_LAYER ||
		    name == TGSI_SEMANTIC_VIEWPORT_INDEX)
			continue;

d2716 1
a2716 1
					LLVMConstInt(ctx->i32, param * 4, 0), "");
d2728 1
a2728 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d2737 2
a2738 1
		LLVMValueRef *out_ptr = ctx->outputs[i];
d2752 8
a2759 5
			ac_build_buffer_store_dword(&ctx->ac,
						    ctx->esgs_ring,
						    out_val, 1, NULL, soffset,
						    (4 * param_index + chan) * 4,
						    1, 1, true, true);
d2767 2
d2770 4
a2773 2
	ac_build_sendmsg(&ctx->ac, AC_SENDMSG_GS_OP_NOP | AC_SENDMSG_GS_DONE,
			 LLVMGetParam(ctx->main_fn, SI_PARAM_GS_WAVE_ID));
d2779 1
a2779 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d2784 1
a2784 1
	assert(!ctx->shader->is_gs_copy_shader);
d2815 1
a2815 1
				addr = ctx->outputs[i][j];
d2817 1
a2817 1
				val = ac_build_clamp(&ctx->ac, val);
d2827 2
a2828 2
		outputs[i].semantic_name = info->output_semantic_name[i];
		outputs[i].semantic_index = info->output_semantic_index[i];
d2830 1
a2830 1
		for (j = 0; j < 4; j++) {
d2833 1
a2833 1
					      ctx->outputs[i][j],
d2835 13
a2847 2
			outputs[i].vertex_stream[j] =
				(info->output_streams[i] >> (2 * j)) & 3;
d2849 8
a2856 1

a2858 10
	/* Return the primitive ID from the LLVM function. */
	ctx->return_value =
		LLVMBuildInsertValue(gallivm->builder,
				     ctx->return_value,
				     bitcast(bld_base, TGSI_TYPE_FLOAT,
					     get_primitive_id(bld_base, 0)),
				     VS_EPILOG_PRIMID_LOC, "");

	if (ctx->shader->selector->so.num_outputs)
		si_llvm_emit_streamout(ctx, outputs, i, 0);
d2865 1
a2865 1
	struct ac_export_args args[10];
d2893 2
a2894 1
	struct ac_export_args args;
d2902 2
a2903 2
	args.valid_mask = 1; /* whether the EXEC mask is valid */
	args.done = 1; /* DONE bit */
d2906 1
a2906 1
	args.target = V_008DFC_SQ_EXP_MRTZ;
d2908 5
a2912 5
	args.compr = 0; /* COMP flag */
	args.out[0] = base->undef; /* R, depth */
	args.out[1] = base->undef; /* G, stencil test value[0:7], stencil op value[8:15] */
	args.out[2] = base->undef; /* B, sample mask */
	args.out[3] = base->undef; /* A, alpha to mask */
d2916 1
a2916 1
		args.compr = 1; /* COMPR flag */
d2921 1
a2921 1
			stencil = LLVMBuildShl(ctx->gallivm.builder, stencil,
d2923 1
a2923 1
			args.out[0] = bitcast(bld_base, TGSI_TYPE_FLOAT, stencil);
d2928 1
a2928 1
			args.out[1] = samplemask;
d2933 1
a2933 1
			args.out[0] = depth;
d2937 1
a2937 1
			args.out[1] = stencil;
d2941 1
a2941 1
			args.out[2] = samplemask;
d2946 1
a2946 1
	/* SI (except OLAND and HAINAN) has a bug that it only looks
d2949 1
a2949 2
	    ctx->screen->b.family != CHIP_OLAND &&
	    ctx->screen->b.family != CHIP_HAINAN)
d2953 1
a2953 1
	args.enabled_channels = mask;
d2955 1
a2955 1
	memcpy(&exp->args[exp->num++], &args, sizeof(args));
d2968 1
a2968 1
	if (ctx->shader->key.part.ps.epilog.clamp_color)
d2970 1
a2970 1
			color[i] = ac_build_clamp(&ctx->ac, color[i]);
d2973 1
a2973 1
	if (ctx->shader->key.part.ps.epilog.alpha_to_one)
d2978 1
a2978 1
	    ctx->shader->key.part.ps.epilog.alpha_func != PIPE_FUNC_ALWAYS)
d2982 1
a2982 1
	if (ctx->shader->key.part.ps.epilog.poly_line_smoothing)
d2987 2
a2988 2
	if (ctx->shader->key.part.ps.epilog.last_cbuf > 0) {
		struct ac_export_args args[8];
d2992 1
a2992 1
		for (c = 0; c <= ctx->shader->key.part.ps.epilog.last_cbuf; c++) {
d2994 2
a2995 2
						 V_008DFC_SQ_EXP_MRT + c, &args[c]);
			if (args[c].enabled_channels)
d3000 1
a3000 1
		for (c = 0; c <= ctx->shader->key.part.ps.epilog.last_cbuf; c++) {
d3002 3
a3004 3
				args[c].valid_mask = 1; /* whether the EXEC mask is valid */
				args[c].done = 1; /* DONE bit */
			} else if (!args[c].enabled_channels)
d3007 1
a3007 1
			memcpy(&exp->args[exp->num++], &args[c], sizeof(args[c]));
d3010 1
a3010 1
		struct ac_export_args args;
d3014 1
a3014 1
					 &args);
d3016 3
a3018 3
			args.valid_mask = 1; /* whether the EXEC mask is valid */
			args.done = 1; /* DONE bit */
		} else if (!args.enabled_channels)
d3021 1
a3021 1
		memcpy(&exp->args[exp->num++], &args, sizeof(args));
d3029 3
a3031 1
		ac_build_export(&ctx->ac, &exp->args[i]);
d3038 102
a3139 1
	struct ac_export_args args;
d3141 2
a3142 9
	args.enabled_channels = 0x0; /* enabled channels */
	args.valid_mask = 1; /* whether the EXEC mask is valid */
	args.done = 1; /* DONE bit */
	args.target = V_008DFC_SQ_EXP_NULL;
	args.compr = 0; /* COMPR flag (0 = 32-bit export) */
	args.out[0] = base->undef; /* R */
	args.out[1] = base->undef; /* G */
	args.out[2] = base->undef; /* B */
	args.out[3] = base->undef; /* A */
d3144 1
a3144 1
	ac_build_export(&ctx->ac, &args);
d3164 1
d3166 1
a3166 1
	LLVMBuilderRef builder = ctx->gallivm.builder;
d3182 1
a3182 1
				LLVMValueRef ptr = ctx->outputs[i][j];
d3189 1
a3189 1
					      ctx->outputs[i][2], "");
d3193 1
a3193 1
						ctx->outputs[i][1], "");
d3197 1
a3197 1
						   ctx->outputs[i][0], "");
d3250 1
a3250 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d3254 1
a3254 1
					LLVMConstInt(ctx->i32, 2, 0), "");
d3256 1
a3256 1
	if (ctx->screen->b.chip_class == VI) {
d3263 1
a3263 1
						ctx->i32_1, "");
d3265 1
a3265 1
				       LLVMConstInt(ctx->i32, 16, 0), "");
d3267 1
a3267 1
				      LLVMConstInt(ctx->i32, 0x3FFF, 0), "");
d3275 39
a3320 3
 *
 * Optionally, a value can be passed through the inline assembly to prevent
 * LLVM from hoisting calls to ReadNone functions.
d3322 2
a3323 2
static void emit_optimization_barrier(struct si_shader_context *ctx,
				      LLVMValueRef *pvgpr)
a3324 2
	static int counter = 0;

d3326 3
a3328 26
	char code[16];

	snprintf(code, sizeof(code), "; %d", p_atomic_inc_return(&counter));

	if (!pvgpr) {
		LLVMTypeRef ftype = LLVMFunctionType(ctx->voidt, NULL, 0, false);
		LLVMValueRef inlineasm = LLVMConstInlineAsm(ftype, code, "", true, false);
		LLVMBuildCall(builder, inlineasm, NULL, 0, "");
	} else {
		LLVMTypeRef ftype = LLVMFunctionType(ctx->i32, &ctx->i32, 1, false);
		LLVMValueRef inlineasm = LLVMConstInlineAsm(ftype, code, "=v,0", true, false);
		LLVMValueRef vgpr = *pvgpr;
		LLVMTypeRef vgpr_type = LLVMTypeOf(vgpr);
		unsigned vgpr_size = llvm_get_type_size(vgpr_type);
		LLVMValueRef vgpr0;

		assert(vgpr_size % 4 == 0);

		vgpr = LLVMBuildBitCast(builder, vgpr, LLVMVectorType(ctx->i32, vgpr_size / 4), "");
		vgpr0 = LLVMBuildExtractElement(builder, vgpr, ctx->i32_0, "");
		vgpr0 = LLVMBuildCall(builder, inlineasm, &vgpr0, 1, "");
		vgpr = LLVMBuildInsertElement(builder, vgpr, vgpr0, ctx->i32_0, "");
		vgpr = LLVMBuildBitCast(builder, vgpr, vgpr_type, "");

		*pvgpr = vgpr;
	}
d3330 1
d3342 1
a3342 1
		LLVMConstInt(ctx->i32, simm16, 0)
a3372 19
static void clock_emit(
		const struct lp_build_tgsi_action *action,
		struct lp_build_tgsi_context *bld_base,
		struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef tmp;

	tmp = lp_build_intrinsic(gallivm->builder, "llvm.readcyclecounter",
				 ctx->i64, NULL, 0, 0);
	tmp = LLVMBuildBitCast(gallivm->builder, tmp, ctx->v2i32, "");

	emit_data->output[0] =
		LLVMBuildExtractElement(gallivm->builder, tmp, ctx->i32_0, "");
	emit_data->output[1] =
		LLVMBuildExtractElement(gallivm->builder, tmp, ctx->i32_1, "");
}

d3388 1
a3388 1
	return ac_build_indexed_load_const(&ctx->ac, rsrc_ptr, index);
a3439 24
static LLVMTypeRef const_array(LLVMTypeRef elem_type, int num_elements)
{
	return LLVMPointerType(LLVMArrayType(elem_type, num_elements),
			       CONST_ADDR_SPACE);
}

static LLVMValueRef load_image_desc(struct si_shader_context *ctx,
				    LLVMValueRef list, LLVMValueRef index,
				    unsigned target)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;

	if (target == TGSI_TEXTURE_BUFFER) {
		index = LLVMBuildMul(builder, index,
				     LLVMConstInt(ctx->i32, 2, 0), "");
		index = LLVMBuildAdd(builder, index,
				     ctx->i32_1, "");
		list = LLVMBuildPointerCast(builder, list,
					    const_array(ctx->v4i32, 0), "");
	}

	return ac_build_indexed_load_const(&ctx->ac, list, index);
}

d3447 1
a3447 1
	bool is_store, unsigned target,
d3453 1
a3453 2
	LLVMValueRef index;
	bool dcc_off = is_store;
a3458 2
		unsigned images_writemask = info->images_store |
					    info->images_atomic;
d3462 2
a3463 1
		if (images_writemask & (1 << image->Register.Index))
d3480 4
a3483 3
	*rsrc = load_image_desc(ctx, rsrc_ptr, index, target);
	if (dcc_off && target != TGSI_TEXTURE_BUFFER)
		*rsrc = force_dcc_off(ctx, *rsrc);
d3489 1
a3489 1
		unsigned src, LLVMValueRef desc)
d3491 1
a3491 2
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = &ctx->gallivm;
d3501 1
a3501 1
		tmp = LLVMBuildBitCast(builder, tmp, ctx->i32, "");
a3504 27
	if (ctx->screen->b.chip_class >= GFX9) {
		/* 1D textures are allocated and used as 2D on GFX9. */
		if (target == TGSI_TEXTURE_1D) {
			coords[1] = ctx->i32_0;
			num_coords++;
		} else if (target == TGSI_TEXTURE_1D_ARRAY) {
			coords[2] = coords[1];
			coords[1] = ctx->i32_0;
			num_coords++;
		} else if (target == TGSI_TEXTURE_2D) {
			/* The hw can't bind a slice of a 3D image as a 2D
			 * image, because it ignores BASE_ARRAY if the target
			 * is 3D. The workaround is to read BASE_ARRAY and set
			 * it as the 3rd address operand for all 2D images.
			 */
			LLVMValueRef first_layer, const5, mask;

			const5 = LLVMConstInt(ctx->i32, 5, 0);
			mask = LLVMConstInt(ctx->i32, S_008F24_BASE_ARRAY(~0), 0);
			first_layer = LLVMBuildExtractElement(builder, desc, const5, "");
			first_layer = LLVMBuildAnd(builder, first_layer, mask, "");

			coords[2] = first_layer;
			num_coords++;
		}
	}

d3557 19
d3612 1
a3612 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d3617 1
a3617 1
	emit_data->dst_type = ctx->v4f32;
d3627 1
a3627 1
		offset = LLVMBuildBitCast(builder, tmp, ctx->i32, "");
d3629 1
a3629 1
		buffer_append_args(ctx, emit_data, rsrc, ctx->i32_0,
d3634 2
a3635 2
		image_fetch_rsrc(bld_base, &inst->Src[0], false, target, &rsrc);
		coords = image_fetch_coords(bld_base, inst, 1, rsrc);
d3638 1
d3640 1
a3640 1
					   ctx->i32_0, false, false);
d3644 1
a3644 1
			emit_data->args[2] = LLVMConstInt(ctx->i32, 15, 0); /* dmask */
a3651 16
static unsigned get_load_intr_attribs(bool readonly_memory)
{
	/* READNONE means writes can't affect it, while READONLY means that
	 * writes can affect it. */
	return readonly_memory && HAVE_LLVM >= 0x0400 ?
				 LP_FUNC_ATTR_READNONE :
				 LP_FUNC_ATTR_READONLY;
}

static unsigned get_store_intr_attribs(bool writeonly_memory)
{
	return writeonly_memory && HAVE_LLVM >= 0x0400 ?
				  LP_FUNC_ATTR_INACCESSIBLE_MEM_ONLY :
				  LP_FUNC_ATTR_WRITEONLY;
}

d3653 1
a3653 2
			     struct lp_build_emit_data *emit_data,
			     bool readonly_memory)
d3681 1
a3681 1
			get_load_intr_attribs(readonly_memory));
d3693 1
a3693 1
	offset = lp_build_emit_fetch(&ctx->bld_base, inst, arg, 0);
d3709 1
d3716 1
a3716 1
	ptr = get_memory_ptr(ctx, inst, ctx->f32, 1);
d3720 1
a3720 1
			channels[chan] = LLVMGetUndef(ctx->f32);
d3724 1
a3724 1
		index = LLVMConstInt(ctx->i32, chan, 0);
d3731 7
a3737 30
/**
 * Return true if the memory accessed by a LOAD or STORE instruction is
 * read-only or write-only, respectively.
 *
 * \param shader_buffers_reverse_access_mask
 *	For LOAD, set this to (store | atomic) slot usage in the shader.
 *	For STORE, set this to (load | atomic) slot usage in the shader.
 * \param images_reverse_access_mask  Same as above, but for images.
 */
static bool is_oneway_access_only(const struct tgsi_full_instruction *inst,
				  const struct tgsi_shader_info *info,
				  unsigned shader_buffers_reverse_access_mask,
				  unsigned images_reverse_access_mask)
{
	/* RESTRICT means NOALIAS.
	 * If there are no writes, we can assume the accessed memory is read-only.
	 * If there are no reads, we can assume the accessed memory is write-only.
	 */
	if (inst->Memory.Qualifier & TGSI_MEMORY_RESTRICT) {
		unsigned reverse_access_mask;

		if (inst->Src[0].Register.File == TGSI_FILE_BUFFER) {
			reverse_access_mask = shader_buffers_reverse_access_mask;
		} else if (inst->Memory.Texture == TGSI_TEXTURE_BUFFER) {
			reverse_access_mask = info->images_buffers &
					      images_reverse_access_mask;
		} else {
			reverse_access_mask = ~info->images_buffers &
					      images_reverse_access_mask;
		}
d3739 2
a3740 9
		if (inst->Src[0].Register.Indirect) {
			if (!reverse_access_mask)
				return true;
		} else {
			if (!(reverse_access_mask &
			      (1u << inst->Src[0].Register.Index)))
				return true;
		}
	}
d3742 2
a3743 14
	/* If there are no buffer writes (for both shader buffers & image
	 * buffers), it implies that buffer memory is read-only.
	 * If there are no buffer reads (for both shader buffers & image
	 * buffers), it implies that buffer memory is write-only.
	 *
	 * Same for the case when there are no writes/reads for non-buffer
	 * images.
	 */
	if (inst->Src[0].Register.File == TGSI_FILE_BUFFER ||
	    (inst->Src[0].Register.File == TGSI_FILE_IMAGE &&
	     inst->Memory.Texture == TGSI_TEXTURE_BUFFER)) {
		if (!shader_buffers_reverse_access_mask &&
		    !(info->images_buffers & images_reverse_access_mask))
			return true;
d3745 9
a3753 2
		if (!(~info->images_buffers & images_reverse_access_mask))
			return true;
a3754 1
	return false;
d3763 1
a3763 1
	struct gallivm_state *gallivm = &ctx->gallivm;
a3765 1
	const struct tgsi_shader_info *info = &ctx->shader->selector->info;
a3766 1
	bool readonly_memory = false;
a3775 7
	readonly_memory = !(inst->Memory.Qualifier & TGSI_MEMORY_VOLATILE) &&
			  is_oneway_access_only(inst, info,
						info->shader_buffers_store |
						info->shader_buffers_atomic,
						info->images_store |
						info->images_atomic);

d3777 1
a3777 1
		load_emit_buffer(ctx, emit_data, readonly_memory);
d3786 1
a3786 1
				get_load_intr_attribs(readonly_memory));
d3788 5
a3792 5
		ac_get_image_intr_name("llvm.amdgcn.image.load",
				       emit_data->dst_type,		/* vdata */
				       LLVMTypeOf(emit_data->args[0]), /* coords */
				       LLVMTypeOf(emit_data->args[1]), /* rsrc */
				       intrinsic_name, sizeof(intrinsic_name));
d3798 1
a3798 1
				get_load_intr_attribs(readonly_memory));
d3807 1
a3807 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d3834 1
a3834 1
		offset = LLVMBuildBitCast(builder, tmp, ctx->i32, "");
d3836 1
a3836 1
		buffer_append_args(ctx, emit_data, rsrc, ctx->i32_0,
d3850 1
a3850 2
		image_fetch_rsrc(bld_base, &memory, true, target, &rsrc);
		coords = image_fetch_coords(bld_base, inst, 0, rsrc);
d3853 3
d3857 1
a3857 1
					   ctx->i32_0, false, force_glc);
d3860 2
a3861 2
			emit_data->args[2] = rsrc;
			emit_data->args[3] = LLVMConstInt(ctx->i32, 15, 0); /* dmask */
d3871 1
a3871 2
		struct lp_build_emit_data *emit_data,
		bool writeonly_memory)
d3876 1
d3905 1
a3905 1
				LLVMConstInt(ctx->i32, start, 0), "");
d3908 1
a3908 1
				ctx->i32_0, "");
d3912 1
a3912 1
				LLVMConstInt(ctx->i32, start + 1, 0), "");
d3914 1
a3914 1
				builder, data, tmp, ctx->i32_1, "");
d3921 1
a3921 1
				LLVMConstInt(ctx->i32, start, 0), "");
d3929 1
a3929 1
				LLVMConstInt(ctx->i32, start * 4, 0), "");
d3937 1
a3937 2
			emit_data->args, emit_data->arg_count,
			get_store_intr_attribs(writeonly_memory));
d3947 1
d3953 1
a3953 1
	ptr = get_memory_ptr(ctx, inst, ctx->f32, 0);
d3959 2
a3960 2
		data = lp_build_emit_fetch(&ctx->bld_base, inst, 1, chan);
		index = LLVMConstInt(ctx->i32, chan, 0);
d3972 1
a3972 1
	struct gallivm_state *gallivm = &ctx->gallivm;
a3974 1
	const struct tgsi_shader_info *info = &ctx->shader->selector->info;
a3976 1
	bool writeonly_memory = false;
a3985 6
	writeonly_memory = is_oneway_access_only(inst, info,
						 info->shader_buffers_load |
						 info->shader_buffers_atomic,
						 info->images_load |
						 info->images_atomic);

d3987 1
a3987 1
		store_emit_buffer(ctx, emit_data, writeonly_memory);
d3995 1
a3995 2
			emit_data->arg_count,
			get_store_intr_attribs(writeonly_memory));
d3997 5
a4001 5
		ac_get_image_intr_name("llvm.amdgcn.image.store",
				       LLVMTypeOf(emit_data->args[0]), /* vdata */
				       LLVMTypeOf(emit_data->args[1]), /* coords */
				       LLVMTypeOf(emit_data->args[2]), /* rsrc */
				       intrinsic_name, sizeof(intrinsic_name));
d4006 1
a4006 2
				emit_data->args, emit_data->arg_count,
				get_store_intr_attribs(writeonly_memory));
d4015 1
a4015 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d4022 1
a4022 1
	emit_data->dst_type = ctx->f32;
d4025 1
a4025 1
	data1 = LLVMBuildBitCast(builder, tmp, ctx->i32, "");
d4029 1
a4029 1
		data2 = LLVMBuildBitCast(builder, tmp, ctx->i32, "");
d4045 1
a4045 1
		offset = LLVMBuildBitCast(builder, tmp, ctx->i32, "");
d4047 1
a4047 1
		buffer_append_args(ctx, emit_data, rsrc, ctx->i32_0,
d4053 3
a4055 2
		image_fetch_rsrc(bld_base, &inst->Src[0], true, target, &rsrc);
		coords = image_fetch_coords(bld_base, inst, 1, rsrc);
d4058 1
d4060 1
a4060 1
					   ctx->i32_0, true, false);
d4079 1
a4079 1
	arg = lp_build_emit_fetch(&ctx->bld_base, inst, 2, 0);
d4084 1
a4084 1
		new_data = lp_build_emit_fetch(&ctx->bld_base,
d4145 1
a4145 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d4169 1
a4169 1
		ac_build_type_name_for_intr(LLVMTypeOf(coords), coords_type, sizeof(coords_type));
d4176 1
a4176 1
		builder, intrinsic_name, ctx->i32,
d4179 1
a4179 1
		LLVMBuildBitCast(builder, tmp, ctx->f32, "");
d4182 3
a4184 6
static void set_tex_fetch_args(struct si_shader_context *ctx,
			       struct lp_build_emit_data *emit_data,
			       unsigned target,
			       LLVMValueRef res_ptr, LLVMValueRef samp_ptr,
			       LLVMValueRef *param, unsigned count,
			       unsigned dmask)
d4186 4
a4189 2
	struct gallivm_state *gallivm = &ctx->gallivm;
	struct ac_image_args args = {};
d4191 1
a4191 3
	/* Pad to power of two vector */
	while (count < util_next_power_of_two(count))
		param[count++] = LLVMGetUndef(ctx->i32);
d4193 5
a4197 62
	if (count > 1)
		args.addr = lp_build_gather_values(gallivm, param, count);
	else
		args.addr = param[0];

	args.resource = res_ptr;
	args.sampler = samp_ptr;
	args.dmask = dmask;
	args.unorm = target == TGSI_TEXTURE_RECT ||
		     target == TGSI_TEXTURE_SHADOWRECT;
	args.da = tgsi_is_array_sampler(target);

	/* Ugly, but we seem to have no other choice right now. */
	STATIC_ASSERT(sizeof(args) <= sizeof(emit_data->args));
	memcpy(emit_data->args, &args, sizeof(args));
}

static LLVMValueRef fix_resinfo(struct si_shader_context *ctx,
				unsigned target, LLVMValueRef out)
{
	LLVMBuilderRef builder = ctx->gallivm.builder;

	/* 1D textures are allocated and used as 2D on GFX9. */
        if (ctx->screen->b.chip_class >= GFX9 &&
	    (target == TGSI_TEXTURE_1D_ARRAY ||
	     target == TGSI_TEXTURE_SHADOW1D_ARRAY)) {
		LLVMValueRef layers =
			LLVMBuildExtractElement(builder, out,
						LLVMConstInt(ctx->i32, 2, 0), "");
		out = LLVMBuildInsertElement(builder, out, layers,
					     ctx->i32_1, "");
	}

	/* Divide the number of layers by 6 to get the number of cubes. */
	if (target == TGSI_TEXTURE_CUBE_ARRAY ||
	    target == TGSI_TEXTURE_SHADOWCUBE_ARRAY) {
		LLVMValueRef imm2 = LLVMConstInt(ctx->i32, 2, 0);

		LLVMValueRef z = LLVMBuildExtractElement(builder, out, imm2, "");
		z = LLVMBuildSDiv(builder, z, LLVMConstInt(ctx->i32, 6, 0), "");

		out = LLVMBuildInsertElement(builder, out, z, imm2, "");
	}
	return out;
}

static void resq_fetch_args(
		struct lp_build_tgsi_context * bld_base,
		struct lp_build_emit_data * emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	const struct tgsi_full_instruction *inst = emit_data->inst;
	const struct tgsi_full_src_register *reg = &inst->Src[0];

	emit_data->dst_type = ctx->v4i32;

	if (reg->Register.File == TGSI_FILE_BUFFER) {
		emit_data->args[0] = shader_buffer_fetch_rsrc(ctx, reg);
		emit_data->arg_count = 1;
	} else if (inst->Memory.Texture == TGSI_TEXTURE_BUFFER) {
		image_fetch_rsrc(bld_base, reg, false, inst->Memory.Texture,
				 &emit_data->args[0]);
d4200 12
a4211 13
		LLVMValueRef res_ptr;
		unsigned image_target;

		if (inst->Memory.Texture == TGSI_TEXTURE_3D)
			image_target = TGSI_TEXTURE_2D_ARRAY;
		else
			image_target = inst->Memory.Texture;

		image_fetch_rsrc(bld_base, reg, false, inst->Memory.Texture,
				 &res_ptr);
		set_tex_fetch_args(ctx, emit_data, image_target,
				   res_ptr, NULL, &ctx->i32_0, 1,
				   0xf);
d4220 1
a4220 2
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = &ctx->gallivm;
d4227 1
a4227 1
					      LLVMConstInt(ctx->i32, 2, 0), "");
d4231 33
a4263 1
		struct ac_image_args args;
d4265 14
a4278 3
		memcpy(&args, emit_data->args, sizeof(args)); /* ugly */
		args.opcode = ac_image_get_resinfo;
		out = ac_build_image_opcode(&ctx->ac, &args);
d4280 1
a4280 1
		out = fix_resinfo(ctx, inst->Memory.Texture, out);
d4283 11
a4293 1
	emit_data->output[emit_data->chan] = out;
a4299 1
	DESC_BUFFER,
d4301 1
a4301 1
	DESC_SAMPLER,
d4304 6
d4313 3
a4315 3
static LLVMValueRef load_sampler_desc(struct si_shader_context *ctx,
				      LLVMValueRef list, LLVMValueRef index,
				      enum desc_type type)
a4324 7
	case DESC_BUFFER:
		/* The buffer is in [4:7]. */
		index = LLVMBuildMul(builder, index, LLVMConstInt(ctx->i32, 4, 0), "");
		index = LLVMBuildAdd(builder, index, ctx->i32_1, "");
		list = LLVMBuildPointerCast(builder, list,
					    const_array(ctx->v4i32, 0), "");
		break;
d4328 1
a4328 1
		index = LLVMBuildAdd(builder, index, ctx->i32_1, "");
d4339 10
a4348 1
	return ac_build_indexed_load_const(&ctx->ac, list, index);
d4374 1
a4374 1
					ctx->i32_0, "");
d4377 1
a4377 1
				      ctx->i32_0, "");
a4385 1
	LLVMValueRef list = LLVMGetParam(ctx->main_fn, SI_PARAM_SAMPLERS);
a4386 1
	const struct tgsi_full_src_register *reg;
d4389 1
d4393 4
a4396 1
	reg = &emit_data->inst->Src[sampler_src];
a4397 1
	if (reg->Register.Indirect) {
d4403 1
a4403 1
		index = LLVMConstInt(ctx->i32, reg->Register.Index, 0);
d4406 1
a4406 9
	if (target == TGSI_TEXTURE_BUFFER)
		*res_ptr = load_sampler_desc(ctx, list, index, DESC_BUFFER);
	else
		*res_ptr = load_sampler_desc(ctx, list, index, DESC_IMAGE);

	if (samp_ptr)
		*samp_ptr = NULL;
	if (fmask_ptr)
		*fmask_ptr = NULL;
d4410 2
d4413 2
a4414 3
			*fmask_ptr = load_sampler_desc(ctx, list, index,
						       DESC_FMASK);
	} else if (target != TGSI_TEXTURE_BUFFER) {
d4416 1
a4416 2
			*samp_ptr = load_sampler_desc(ctx, list, index,
						      DESC_SAMPLER);
d4419 2
d4429 2
d4440 2
a4441 1
		emit_data->args[0] = get_buffer_size(bld_base, res_ptr);
d4448 1
a4448 1
	set_tex_fetch_args(ctx, emit_data, target, res_ptr,
d4456 1
a4456 2
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct ac_image_args args;
d4465 4
a4468 1
	memcpy(&args, emit_data->args, sizeof(args)); /* ugly */
d4470 10
a4479 2
	args.opcode = ac_image_get_resinfo;
	LLVMValueRef result = ac_build_image_opcode(&ctx->ac, &args);
d4481 3
a4483 1
	emit_data->output[emit_data->chan] = fix_resinfo(ctx, target, result);
d4491 1
a4491 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d4509 8
d4518 2
a4519 3
		emit_data->args[0] = LLVMBuildBitCast(gallivm->builder, res_ptr,
						      ctx->v16i8, "");
		emit_data->args[1] = ctx->i32_0;
d4542 1
a4542 3
	if (has_offset &&
	    opcode != TGSI_OPCODE_TXF &&
	    opcode != TGSI_OPCODE_TXF_LZ) {
d4554 1
a4554 1
						    LLVMConstInt(ctx->i32, 0x3f, 0), "");
d4557 1
a4557 1
							    LLVMConstInt(ctx->i32, chan*8, 0), "");
d4590 1
a4590 1
			z = ac_build_clamp(&ctx->ac, z);
d4597 1
a4597 1
		int param, num_src_deriv_channels, num_dst_deriv_channels;
a4601 1
			num_dst_deriv_channels = 3;
a4610 1
			num_dst_deriv_channels = 2;
a4618 1
			num_dst_deriv_channels = 3;
d4626 1
a4626 9

			/* 1D textures are allocated and used as 2D on GFX9. */
			if (ctx->screen->b.chip_class >= GFX9) {
				num_dst_deriv_channels = 2;
				num_deriv_channels = 2;
			} else {
				num_dst_deriv_channels = 1;
				num_deriv_channels = 1;
			}
d4632 1
a4632 1
		for (param = 0; param < 2; param++) {
d4634 1
a4634 1
				derivs[param * num_dst_deriv_channels + chan] =
a4635 7

			/* Fill in the rest with zeros. */
			for (chan = num_src_deriv_channels;
			     chan < num_dst_deriv_channels; chan++)
				derivs[param * num_dst_deriv_channels + chan] =
					bld_base->base.zero;
		}
d4642 1
a4642 5
		ac_prepare_cube_coords(&ctx->ac,
				       opcode == TGSI_OPCODE_TXD,
				       target == TGSI_TEXTURE_CUBE_ARRAY ||
				       target == TGSI_TEXTURE_SHADOWCUBE_ARRAY,
				       coords, derivs);
a4654 21
	/* 1D textures are allocated and used as 2D on GFX9. */
	if (ctx->screen->b.chip_class >= GFX9) {
		LLVMValueRef filler;

		/* Use 0.5, so that we don't sample the border color. */
		if (opcode == TGSI_OPCODE_TXF)
			filler = ctx->i32_0;
		else
			filler = LLVMConstReal(ctx->f32, 0.5);

		if (target == TGSI_TEXTURE_1D ||
		    target == TGSI_TEXTURE_SHADOW1D) {
			address[count++] = filler;
		} else if (target == TGSI_TEXTURE_1D_ARRAY ||
			   target == TGSI_TEXTURE_SHADOW1D_ARRAY) {
			address[count] = address[count - 1];
			address[count - 1] = filler;
			count++;
		}
	}

d4687 1
d4690 1
a4690 2
		/* We only need .xy for non-arrays, and .xyz for arrays. */
		unsigned txf_count = target == TGSI_TEXTURE_2D_MSAA ? 2 : 3;
d4695 7
a4701 2
		/* Read FMASK using TXF_LZ. */
		inst.Instruction.Opcode = TGSI_OPCODE_TXF_LZ;
d4705 1
a4705 1
		set_tex_fetch_args(ctx, &txf_emit_data,
d4718 1
a4718 1
						ctx->i32_0, "");
d4720 1
a4720 1
		unsigned sample_chan = txf_count; /* the sample index is last */
d4740 1
a4740 1
						ctx->i32_1, "");
d4744 1
a4744 1
				      fmask_word1, ctx->i32_0, "");
d4752 1
a4752 2
	if (opcode == TGSI_OPCODE_TXF ||
	    opcode == TGSI_OPCODE_TXF_LZ) {
d4756 1
d4764 1
a4764 1
						ctx->imms[off->Index * TGSI_NUM_CHANNELS + off->SwizzleZ]);
d4774 1
a4774 1
						ctx->imms[off->Index * TGSI_NUM_CHANNELS + off->SwizzleY]);
d4782 1
a4782 1
						ctx->imms[off->Index * TGSI_NUM_CHANNELS + off->SwizzleX]);
d4802 1
d4808 1
a4808 1
			comp_imm = ctx->imms[src1.Index * TGSI_NUM_CHANNELS + src1.SwizzleX];
d4816 1
a4816 1
	set_tex_fetch_args(ctx, emit_data, target, res_ptr,
d4830 3
a4832 2
				     struct ac_image_args *args,
				     unsigned target)
d4835 1
a4835 1
	LLVMValueRef coord = args->addr;
a4836 5
	/* Texture coordinates start after:
	 *   {offset, bias, z-compare, derivatives}
	 * Only the offset and z-compare can occur here.
	 */
	unsigned coord_vgpr_index = (int)args->offset + (int)args->compare;
d4839 2
a4840 2
	if (target == TGSI_TEXTURE_RECT ||
	    target == TGSI_TEXTURE_SHADOWRECT) {
d4847 1
a4847 1
		txq_inst.Texture.Texture = target;
d4850 4
a4853 2
		set_tex_fetch_args(ctx, &txq_emit_data, target,
				   args->resource, NULL, &ctx->i32_0,
d4855 1
a4855 1
		txq_emit(NULL, &ctx->bld_base, &txq_emit_data);
d4864 1
a4864 1
				lp_build_emit_llvm_unary(&ctx->bld_base,
d4882 5
a4886 1
	args->addr = coord;
d4894 1
a4895 1
	struct ac_image_args args;
d4898 6
d4906 5
a4910 6
		emit_data->output[emit_data->chan] =
			ac_build_buffer_load_format(&ctx->ac,
						    emit_data->args[0],
						    emit_data->args[2],
						    emit_data->args[1],
						    true);
a4913 6
	memcpy(&args, emit_data->args, sizeof(args)); /* ugly */

	args.opcode = ac_image_sample;
	args.compare = tgsi_is_shadow_target(target);
	args.offset = inst->Texture.NumOffsets > 0;

d4916 6
a4921 7
	case TGSI_OPCODE_TXF_LZ:
		args.opcode = opcode == TGSI_OPCODE_TXF_LZ ||
			      target == TGSI_TEXTURE_2D_MSAA ||
			      target == TGSI_TEXTURE_2D_ARRAY_MSAA ?
				      ac_image_load : ac_image_load_mip;
		args.compare = false;
		args.offset = false;
d4924 3
a4926 3
		args.opcode = ac_image_get_lod;
		args.compare = false;
		args.offset = false;
d4932 1
a4932 4
			args.level_zero = true;
		break;
	case TGSI_OPCODE_TEX_LZ:
		args.level_zero = true;
d4937 1
a4937 1
		args.bias = true;
d4941 1
a4941 1
		args.lod = true;
d4944 1
a4944 1
		args.deriv = true;
d4947 2
a4948 2
		args.opcode = ac_image_gather4;
		args.level_zero = true;
d4955 6
d4962 1
a4962 2
	if (ctx->screen->b.chip_class <= VI &&
	    opcode == TGSI_OPCODE_TG4) {
d4973 9
a4981 2
		    info->sampler_type[sampler] == TGSI_RETURN_TYPE_UINT)
			si_lower_gather4_integer(ctx, &args, target);
d4984 4
a4987 2
	emit_data->output[emit_data->chan] =
		ac_build_image_opcode(&ctx->ac, &args);
d4996 1
a4996 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d5008 1
a5008 1
		LLVMConstInt(ctx->i32, 3, 0), "");
d5010 1
a5010 1
				LLVMConstInt(ctx->i32, 16, 0), "");
d5012 2
a5013 2
			       LLVMConstInt(ctx->i32, 0xf, 0), "");
	samples = LLVMBuildShl(builder, ctx->i32_1,
d5019 29
d5054 1
a5054 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d5056 1
a5056 1
	LLVMValueRef val;
d5060 2
d5063 1
a5063 1
		mask = AC_TID_MASK_LEFT;
d5065 1
a5065 1
		mask = AC_TID_MASK_TOP;
d5067 4
a5070 1
		mask = AC_TID_MASK_TOP_LEFT;
d5074 2
d5078 31
a5108 3
	val = ac_build_ddxy(&ctx->ac, ctx->screen->has_ds_bpermute,
			    mask, idx, ctx->lds, val);
	emit_data->output[emit_data->chan] = val;
d5121 1
a5121 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d5140 1
a5140 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d5155 1
a5155 1
		LLVMValueRef halfval = LLVMConstReal(ctx->f32, 0.5f);
d5168 1
a5168 1
							     ctx->i32_0, "");
d5173 1
a5173 1
							     ctx->i32_1, "");
d5185 1
a5185 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d5188 1
d5210 1
a5210 1
		interp_param = LLVMGetParam(ctx->main_fn, interp_param_idx);
d5214 1
a5214 1
	attr_number = LLVMConstInt(ctx->i32, input_index, 0);
d5230 2
a5231 2
			LLVMValueRef ix_ll = LLVMConstInt(ctx->i32, i, 0);
			LLVMValueRef iy_ll = LLVMConstInt(ctx->i32, i + 2, 0);
d5249 4
a5252 1
			ij_out[i] = LLVMBuildFAdd(gallivm->builder, temp2, temp1, "");
d5254 1
a5254 1
		interp_param = lp_build_gather_values(gallivm, ij_out, 2);
d5257 1
d5259 1
d5264 1
a5264 140
		llvm_chan = LLVMConstInt(ctx->i32, schan, 0);

		if (interp_param) {
			interp_param = LLVMBuildBitCast(gallivm->builder,
				interp_param, LLVMVectorType(ctx->f32, 2), "");
			LLVMValueRef i = LLVMBuildExtractElement(
				gallivm->builder, interp_param, ctx->i32_0, "");
			LLVMValueRef j = LLVMBuildExtractElement(
				gallivm->builder, interp_param, ctx->i32_1, "");
			emit_data->output[chan] = ac_build_fs_interp(&ctx->ac,
				llvm_chan, attr_number, params,
				i, j);
		} else {
			emit_data->output[chan] = ac_build_fs_interp_mov(&ctx->ac,
				LLVMConstInt(ctx->i32, 2, 0), /* P0 */
				llvm_chan, attr_number, params);
		}
	}
}

static LLVMValueRef si_emit_ballot(struct si_shader_context *ctx,
				   LLVMValueRef value)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef args[3] = {
		value,
		ctx->i32_0,
		LLVMConstInt(ctx->i32, LLVMIntNE, 0)
	};

	/* We currently have no other way to prevent LLVM from lifting the icmp
	 * calls to a dominating basic block.
	 */
	emit_optimization_barrier(ctx, &args[0]);

	if (LLVMTypeOf(args[0]) != ctx->i32)
		args[0] = LLVMBuildBitCast(gallivm->builder, args[0], ctx->i32, "");

	return lp_build_intrinsic(gallivm->builder,
				  "llvm.amdgcn.icmp.i32",
				  ctx->i64, args, 3,
				  LP_FUNC_ATTR_NOUNWIND |
				  LP_FUNC_ATTR_READNONE |
				  LP_FUNC_ATTR_CONVERGENT);
}

static void vote_all_emit(
	const struct lp_build_tgsi_action *action,
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef active_set, vote_set;
	LLVMValueRef tmp;

	active_set = si_emit_ballot(ctx, ctx->i32_1);
	vote_set = si_emit_ballot(ctx, emit_data->args[0]);

	tmp = LLVMBuildICmp(gallivm->builder, LLVMIntEQ, vote_set, active_set, "");
	emit_data->output[emit_data->chan] =
		LLVMBuildSExt(gallivm->builder, tmp, ctx->i32, "");
}

static void vote_any_emit(
	const struct lp_build_tgsi_action *action,
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef vote_set;
	LLVMValueRef tmp;

	vote_set = si_emit_ballot(ctx, emit_data->args[0]);

	tmp = LLVMBuildICmp(gallivm->builder, LLVMIntNE,
			    vote_set, LLVMConstInt(ctx->i64, 0, 0), "");
	emit_data->output[emit_data->chan] =
		LLVMBuildSExt(gallivm->builder, tmp, ctx->i32, "");
}

static void vote_eq_emit(
	const struct lp_build_tgsi_action *action,
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMValueRef active_set, vote_set;
	LLVMValueRef all, none, tmp;

	active_set = si_emit_ballot(ctx, ctx->i32_1);
	vote_set = si_emit_ballot(ctx, emit_data->args[0]);

	all = LLVMBuildICmp(gallivm->builder, LLVMIntEQ, vote_set, active_set, "");
	none = LLVMBuildICmp(gallivm->builder, LLVMIntEQ,
			     vote_set, LLVMConstInt(ctx->i64, 0, 0), "");
	tmp = LLVMBuildOr(gallivm->builder, all, none, "");
	emit_data->output[emit_data->chan] =
		LLVMBuildSExt(gallivm->builder, tmp, ctx->i32, "");
}

static void ballot_emit(
	const struct lp_build_tgsi_action *action,
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	LLVMBuilderRef builder = ctx->gallivm.builder;
	LLVMValueRef tmp;

	tmp = lp_build_emit_fetch(bld_base, emit_data->inst, 0, TGSI_CHAN_X);
	tmp = si_emit_ballot(ctx, tmp);
	tmp = LLVMBuildBitCast(builder, tmp, ctx->v2i32, "");

	emit_data->output[0] = LLVMBuildExtractElement(builder, tmp, ctx->i32_0, "");
	emit_data->output[1] = LLVMBuildExtractElement(builder, tmp, ctx->i32_1, "");
}

static void read_invoc_fetch_args(
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	emit_data->args[0] = lp_build_emit_fetch(bld_base, emit_data->inst,
						 0, emit_data->src_chan);

	/* Always read the source invocation (= lane) from the X channel. */
	emit_data->args[1] = lp_build_emit_fetch(bld_base, emit_data->inst,
						 1, TGSI_CHAN_X);
	emit_data->arg_count = 2;
}

static void read_lane_emit(
	const struct lp_build_tgsi_action *action,
	struct lp_build_tgsi_context *bld_base,
	struct lp_build_emit_data *emit_data)
{
	struct si_shader_context *ctx = si_shader_context(bld_base);
	LLVMBuilderRef builder = ctx->gallivm.builder;
d5266 9
a5274 8
	/* We currently have no other way to prevent LLVM from lifting the icmp
	 * calls to a dominating basic block.
	 */
	emit_optimization_barrier(ctx, &emit_data->args[0]);

	for (unsigned i = 0; i < emit_data->arg_count; ++i) {
		emit_data->args[i] = LLVMBuildBitCast(builder, emit_data->args[i],
						      ctx->i32, "");
a5275 6

	emit_data->output[emit_data->chan] =
		ac_build_intrinsic(&ctx->ac, action->intr_name,
				   ctx->i32, emit_data->args, emit_data->arg_count,
				   AC_FUNC_ATTR_READNONE |
				   AC_FUNC_ATTR_CONVERGENT);
d5281 1
a5281 1
	struct si_shader_context *ctx = si_shader_context(bld_base);
a5282 1
	LLVMValueRef imm;
d5287 1
a5287 2
	imm = ctx->imms[src0.Index * TGSI_NUM_CHANNELS + src0.SwizzleX];
	stream = LLVMConstIntGetZExtValue(imm) & 0x3;
d5301 1
a5301 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d5307 2
a5308 1
	unsigned chan, offset;
d5328 2
a5329 2
				 LLVMConstInt(ctx->i32,
					      shader->selector->gs_max_out_vertices, 0), "");
d5334 2
a5335 2
				       LLVMConstReal(ctx->f32, 1.0f),
				       LLVMConstReal(ctx->f32, -1.0f));
d5337 2
a5338 1
		ac_build_kill(&ctx->ac, kill);
a5342 1
	offset = 0;
d5344 2
a5345 1
		LLVMValueRef *out_ptr = ctx->outputs[i];
a5347 4
			if (!(info->output_usagemask[i] & (1 << chan)) ||
			    ((info->output_streams[i] >> (2 * chan)) & 3) != stream)
				continue;

d5350 2
a5351 3
				LLVMConstInt(ctx->i32, offset *
					     shader->selector->gs_max_out_vertices, 0);
			offset++;
d5358 7
a5364 5
			ac_build_buffer_store_dword(&ctx->ac,
						    ctx->gsvs_ring[stream],
						    out_val, 1,
						    voffset, soffset, 0,
						    1, 1, true, true);
d5369 1
a5369 1
				      ctx->i32_1);
d5374 5
a5378 2
	ac_build_sendmsg(&ctx->ac, AC_SENDMSG_GS_OP_EMIT | AC_SENDMSG_GS | (stream << 8),
			 LLVMGetParam(ctx->main_fn, SI_PARAM_GS_WAVE_ID));
d5390 2
d5396 4
a5399 2
	ac_build_sendmsg(&ctx->ac, AC_SENDMSG_GS_OP_CUT | AC_SENDMSG_GS | (stream << 8),
			 LLVMGetParam(ctx->main_fn, SI_PARAM_GS_WAVE_ID));
d5407 1
a5407 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d5423 1
a5423 1
			   ctx->voidt, NULL, 0, LP_FUNC_ATTR_CONVERGENT);
a5436 1
			       const char *name,
d5443 1
a5443 1
	si_llvm_create_func(ctx, name, returns, num_returns,
d5459 2
a5460 3
			lp_add_function_attr(ctx->main_fn, i + 1, LP_FUNC_ATTR_BYVAL);
			lp_add_function_attr(ctx->main_fn, i + 1, LP_FUNC_ATTR_NOALIAS);
			ac_add_attr_dereferenceable(P, UINT64_MAX);
d5462 1
a5462 1
			lp_add_function_attr(ctx->main_fn, i + 1, LP_FUNC_ATTR_INREG);
a5464 4
	LLVMAddTargetDependentFunctionAttr(ctx->main_fn,
					   "no-signed-zeros-fp-math",
					   "true");

d5482 14
d5508 1
a5508 1
			ctx->param_streamout_config = *num_params - 1;
a5534 3
	case LLVMArrayTypeKind:
		return LLVMGetArrayLength(type) *
		       llvm_get_type_size(LLVMGetElementType(type));
d5544 2
d5548 1
a5548 1
	ctx->lds = LLVMBuildIntToPtr(gallivm->builder, ctx->i32_0,
d5572 2
a5573 2
	struct lp_build_tgsi_context *bld_base = &ctx->bld_base;
	struct gallivm_state *gallivm = &ctx->gallivm;
d5575 1
a5575 1
	LLVMTypeRef params[SI_NUM_PARAMS + SI_MAX_ATTRIBS], v3i32;
a5578 1
	unsigned num_prolog_vgprs = 0;
d5590 1
a5590 1
		params[SI_PARAM_VERTEX_BUFFERS] = const_array(ctx->v16i8, SI_MAX_ATTRIBS);
d5594 1
a5594 2
		params[SI_PARAM_VS_STATE_BITS] = ctx->i32;
		num_params = SI_PARAM_VS_STATE_BITS+1;
d5596 1
a5596 1
		if (shader->key.as_es) {
d5598 3
a5600 2
		} else if (shader->key.as_ls) {
			/* no extra parameters */
d5602 1
a5602 1
			if (shader->is_gs_copy_shader) {
d5604 3
d5622 2
a5623 1
		if (!shader->is_gs_copy_shader) {
a5629 2
			num_prolog_vgprs += shader->selector->info.num_inputs;

d5631 1
a5631 1
			if (!shader->key.as_es && !shader->key.as_ls)
d5651 6
a5656 5
		/* SI_PARAM_TCS_OC_LDS and PARAM_TESS_FACTOR_OFFSET are
		 * placed after the user SGPRs.
		 */
		for (i = 0; i < SI_TCS_NUM_USER_SGPR + 2; i++)
			returns[num_returns++] = ctx->i32; /* SGPRs */
d5658 3
a5660 2
		for (i = 0; i < 3; i++)
			returns[num_returns++] = ctx->f32; /* VGPRs */
d5667 1
a5667 1
		if (shader->key.as_es) {
d5669 1
a5669 1
			params[num_params++] = ctx->i32;
d5672 1
a5672 1
			params[num_params++] = ctx->i32;
d5686 1
a5686 1
		if (!shader->key.as_es)
a5724 1
		shader->info.face_vgpr_index = 20;
d5730 30
a5759 30
		/* Color inputs from the prolog. */
		if (shader->selector->info.colors_read) {
			unsigned num_color_elements =
				util_bitcount(shader->selector->info.colors_read);

			assert(num_params + num_color_elements <= ARRAY_SIZE(params));
			for (i = 0; i < num_color_elements; i++)
				params[num_params++] = ctx->f32;

			num_prolog_vgprs += num_color_elements;
		}

		/* Outputs for the epilog. */
		num_return_sgprs = SI_SGPR_ALPHA_REF + 1;
		num_returns =
			num_return_sgprs +
			util_bitcount(shader->selector->info.colors_written) * 4 +
			shader->selector->info.writes_z +
			shader->selector->info.writes_stencil +
			shader->selector->info.writes_samplemask +
			1 /* SampleMaskIn */;

		num_returns = MAX2(num_returns,
				   num_return_sgprs +
				   PS_EPILOG_SAMPLEMASK_MIN_LOC + 1);

		for (i = 0; i < num_return_sgprs; i++)
			returns[i] = ctx->i32;
		for (; i < num_returns; i++)
			returns[i] = ctx->f32;
d5778 1
a5778 1
	si_create_function(ctx, "main", returns, num_returns, params,
d5783 1
a5783 1
	    ctx->separate_prolog) {
d5806 6
a5811 5
	for (; i < num_params; ++i)
		shader->info.num_input_vgprs += llvm_get_type_size(params[i]) / 4;

	assert(shader->info.num_input_vgprs >= num_prolog_vgprs);
	shader->info.num_input_vgprs -= num_prolog_vgprs;
d5827 3
a5829 2
	if ((ctx->type == PIPE_SHADER_VERTEX && shader->key.as_ls) ||
	    ctx->type == PIPE_SHADER_TESS_CTRL)
d5839 2
a5840 2
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
d5846 1
a5846 1
	     ctx->shader->key.as_es) ||
d5848 1
a5848 1
	     ctx->shader->key.as_es) ||
d5853 1
a5853 1
		LLVMValueRef offset = LLVMConstInt(ctx->i32, ring, 0);
d5856 1
a5856 1
			ac_build_indexed_load_const(&ctx->ac, buf_ptr, offset);
d5859 2
a5860 2
	if (ctx->shader->is_gs_copy_shader) {
		LLVMValueRef offset = LLVMConstInt(ctx->i32, SI_RING_GSVS, 0);
d5863 6
a5868 68
			ac_build_indexed_load_const(&ctx->ac, buf_ptr, offset);
	} else if (ctx->type == PIPE_SHADER_GEOMETRY) {
		const struct si_shader_selector *sel = ctx->shader->selector;
		LLVMValueRef offset = LLVMConstInt(ctx->i32, SI_RING_GSVS, 0);
		LLVMValueRef base_ring;

		base_ring = ac_build_indexed_load_const(&ctx->ac, buf_ptr, offset);

		/* The conceptual layout of the GSVS ring is
		 *   v0c0 .. vLv0 v0c1 .. vLc1 ..
		 * but the real memory layout is swizzled across
		 * threads:
		 *   t0v0c0 .. t15v0c0 t0v1c0 .. t15v1c0 ... t15vLcL
		 *   t16v0c0 ..
		 * Override the buffer descriptor accordingly.
		 */
		LLVMTypeRef v2i64 = LLVMVectorType(ctx->i64, 2);
		uint64_t stream_offset = 0;

		for (unsigned stream = 0; stream < 4; ++stream) {
			unsigned num_components;
			unsigned stride;
			unsigned num_records;
			LLVMValueRef ring, tmp;

			num_components = sel->info.num_stream_output_components[stream];
			if (!num_components)
				continue;

			stride = 4 * num_components * sel->gs_max_out_vertices;

			/* Limit on the stride field for <= CIK. */
			assert(stride < (1 << 14));

			num_records = 64;

			ring = LLVMBuildBitCast(builder, base_ring, v2i64, "");
			tmp = LLVMBuildExtractElement(builder, ring, ctx->i32_0, "");
			tmp = LLVMBuildAdd(builder, tmp,
					   LLVMConstInt(ctx->i64,
							stream_offset, 0), "");
			stream_offset += stride * 64;

			ring = LLVMBuildInsertElement(builder, ring, tmp, ctx->i32_0, "");
			ring = LLVMBuildBitCast(builder, ring, ctx->v4i32, "");
			tmp = LLVMBuildExtractElement(builder, ring, ctx->i32_1, "");
			tmp = LLVMBuildOr(builder, tmp,
				LLVMConstInt(ctx->i32,
					     S_008F04_STRIDE(stride) |
					     S_008F04_SWIZZLE_ENABLE(1), 0), "");
			ring = LLVMBuildInsertElement(builder, ring, tmp, ctx->i32_1, "");
			ring = LLVMBuildInsertElement(builder, ring,
					LLVMConstInt(ctx->i32, num_records, 0),
					LLVMConstInt(ctx->i32, 2, 0), "");
			ring = LLVMBuildInsertElement(builder, ring,
				LLVMConstInt(ctx->i32,
					     S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) |
					     S_008F0C_DST_SEL_Y(V_008F0C_SQ_SEL_Y) |
					     S_008F0C_DST_SEL_Z(V_008F0C_SQ_SEL_Z) |
					     S_008F0C_DST_SEL_W(V_008F0C_SQ_SEL_W) |
					     S_008F0C_NUM_FORMAT(V_008F0C_BUF_NUM_FORMAT_FLOAT) |
					     S_008F0C_DATA_FORMAT(V_008F0C_BUF_DATA_FORMAT_32) |
					     S_008F0C_ELEMENT_SIZE(1) | /* element_size = 4 (bytes) */
					     S_008F0C_INDEX_STRIDE(1) | /* index_stride = 16 (elements) */
					     S_008F0C_ADD_TID_ENABLE(1),
					     0),
				LLVMConstInt(ctx->i32, 3, 0), "");
			ring = LLVMBuildBitCast(builder, ring, ctx->v16i8, "");
d5870 2
a5871 1
			ctx->gsvs_ring[stream] = ring;
d5880 3
a5882 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d5894 2
a5895 2
	slot = LLVMConstInt(ctx->i32, SI_PS_CONST_POLY_STIPPLE, 0);
	desc = ac_build_indexed_load_const(&ctx->ac, param_rw_buffers, slot);
d5908 1
a5908 1
	ac_build_kill(&ctx->ac, bit);
d5911 1
a5911 1
void si_shader_binary_read_config(struct ac_shader_binary *binary,
d5917 1
a5917 1
		ac_shader_binary_config_start(binary, symbol_offset);
d5924 1
a5924 1
		const struct ac_shader_reloc *reloc = &binary->relocs[i];
d6014 1
a6014 1
		const struct ac_shader_reloc *reloc =
d6039 1
a6039 1
	const struct ac_shader_binary *prolog =
d6041 1
a6041 1
	const struct ac_shader_binary *epilog =
d6043 1
a6043 1
	const struct ac_shader_binary *mainb = &shader->binary;
a6051 6
	/* GFX9 can fetch at most 128 bytes past the end of the shader.
	 * Prevent VM faults.
	 */
	if (sscreen->b.chip_class >= GFX9)
		bo_size += 128;

d6053 3
a6055 4
	shader->bo = (struct r600_resource*)
		     pipe_buffer_create(&sscreen->b.b, 0,
					PIPE_USAGE_IMMUTABLE,
					align(bo_size, SI_CPDMA_ALIGNMENT));
d6080 1
a6080 1
static void si_shader_dump_disassembly(const struct ac_shader_binary *binary,
d6129 3
a6131 1
				 struct si_shader *shader,
d6134 1
a6134 2
				 FILE *file,
				 bool check_debug_option)
a6135 3
	struct si_shader_config *conf = &shader->config;
	unsigned num_inputs = shader->selector ? shader->selector->info.num_inputs : 0;
	unsigned code_size = si_get_shader_binary_size(shader);
d6141 1
a6141 2
	switch (processor) {
	case PIPE_SHADER_FRAGMENT:
a6153 9
		break;
	case PIPE_SHADER_COMPUTE:
		if (shader->selector) {
			unsigned max_workgroup_size =
				si_get_max_workgroup_size(shader);
			lds_per_wave = (conf->lds_size * lds_increment) /
				       DIV_ROUND_UP(max_workgroup_size, 64);
		}
		break;
d6167 3
a6169 2
	/* LDS is 64KB per CU (4 SIMDs), which is 16KB per SIMD (usage above
	 * 16KB makes some SIMDs unoccupied). */
d6173 1
a6173 1
	if (!check_debug_option ||
a6186 1
			"Private memory VGPRs: %d\n"
d6193 1
a6193 2
			conf->spilled_sgprs, conf->spilled_vgprs,
			conf->private_mem_vgprs, code_size,
d6201 1
a6201 1
			   "Spilled VGPRs: %d PrivMem VGPRs: %d",
d6205 1
a6205 1
			   conf->spilled_vgprs, conf->private_mem_vgprs);
d6208 2
a6209 1
const char *si_get_shader_name(struct si_shader *shader, unsigned processor)
d6213 1
a6213 1
		if (shader->key.as_es)
d6215 1
a6215 1
		else if (shader->key.as_ls)
d6222 1
a6222 1
		if (shader->key.as_es)
d6227 1
a6227 1
		if (shader->is_gs_copy_shader)
d6242 1
a6242 1
		    FILE *file, bool check_debug_option)
d6244 1
a6244 1
	if (!check_debug_option ||
d6248 1
a6248 1
	if (!check_debug_option && shader->binary.llvm_ir_string) {
d6254 1
a6254 1
	if (!check_debug_option ||
d6271 4
a6274 2
	si_shader_dump_stats(sscreen, shader, debug, processor, file,
			     check_debug_option);
d6278 1
a6278 1
		    struct ac_shader_binary *binary,
d6294 1
a6294 1
			ac_dump_module(mod);
d6356 4
a6359 5
struct si_shader *
si_generate_gs_copy_shader(struct si_screen *sscreen,
			   LLVMTargetMachineRef tm,
			   struct si_shader_selector *gs_selector,
			   struct pipe_debug_callback *debug)
d6361 2
a6362 5
	struct si_shader_context ctx;
	struct si_shader *shader;
	struct gallivm_state *gallivm = &ctx.gallivm;
	LLVMBuilderRef builder;
	struct lp_build_tgsi_context *bld_base = &ctx.bld_base;
d6365 2
a6366 1
	struct tgsi_shader_info *gsinfo = &gs_selector->info;
d6371 3
a6373 2
	if (!outputs)
		return NULL;
d6375 3
a6377 5
	shader = CALLOC_STRUCT(si_shader);
	if (!shader) {
		FREE(outputs);
		return NULL;
	}
d6379 11
d6391 1
a6391 24
	shader->selector = gs_selector;
	shader->is_gs_copy_shader = true;

	si_init_shader_ctx(&ctx, sscreen, shader, tm);
	ctx.type = PIPE_SHADER_VERTEX;

	builder = gallivm->builder;

	create_function(&ctx);
	preload_ring_buffers(&ctx);

	LLVMValueRef voffset =
		lp_build_mul_imm(uint, LLVMGetParam(ctx.main_fn,
						    ctx.param_vertex_id), 4);

	/* Fetch the vertex stream ID.*/
	LLVMValueRef stream_id;

	if (gs_selector->so.num_outputs)
		stream_id = unpack_param(&ctx, ctx.param_streamout_config, 24, 2);
	else
		stream_id = ctx.i32_0;

	/* Fill in output information. */
d6393 1
a6393 8
		outputs[i].semantic_name = gsinfo->output_semantic_name[i];
		outputs[i].semantic_index = gsinfo->output_semantic_index[i];

		for (int chan = 0; chan < 4; chan++) {
			outputs[i].vertex_stream[chan] =
				(gsinfo->output_streams[i] >> (2 * chan)) & 3;
		}
	}
d6395 2
a6396 2
	LLVMBasicBlockRef end_bb;
	LLVMValueRef switch_inst;
d6398 4
a6401 38
	end_bb = LLVMAppendBasicBlockInContext(gallivm->context, ctx.main_fn, "end");
	switch_inst = LLVMBuildSwitch(builder, stream_id, end_bb, 4);

	for (int stream = 0; stream < 4; stream++) {
		LLVMBasicBlockRef bb;
		unsigned offset;

		if (!gsinfo->num_stream_output_components[stream])
			continue;

		if (stream > 0 && !gs_selector->so.num_outputs)
			continue;

		bb = LLVMInsertBasicBlockInContext(gallivm->context, end_bb, "out");
		LLVMAddCase(switch_inst, LLVMConstInt(ctx.i32, stream, 0), bb);
		LLVMPositionBuilderAtEnd(builder, bb);

		/* Fetch vertex data from GSVS ring */
		offset = 0;
		for (i = 0; i < gsinfo->num_outputs; ++i) {
			for (unsigned chan = 0; chan < 4; chan++) {
				if (!(gsinfo->output_usagemask[i] & (1 << chan)) ||
				    outputs[i].vertex_stream[chan] != stream) {
					outputs[i].values[chan] = ctx.bld_base.base.undef;
					continue;
				}

				LLVMValueRef soffset = LLVMConstInt(ctx.i32,
					offset * gs_selector->gs_max_out_vertices * 16 * 4, 0);
				offset++;

				outputs[i].values[chan] =
					ac_build_buffer_load(&ctx.ac,
							     ctx.gsvs_ring[0], 1,
							     ctx.i32_0, voffset,
							     soffset, 0, 1, 1, true);
			}
		}
d6403 7
a6409 5
		/* Streamout and exports. */
		if (gs_selector->so.num_outputs) {
			si_llvm_emit_streamout(&ctx, outputs,
					       gsinfo->num_outputs,
					       stream);
a6410 5

		if (stream == 0)
			si_llvm_export_vs(bld_base, outputs, gsinfo->num_outputs);

		LLVMBuildBr(builder, end_bb);
d6413 1
a6413 1
	LLVMPositionBuilderAtEnd(builder, end_bb);
d6420 1
a6420 1
		ac_dump_module(ctx.gallivm.module);
d6422 1
a6422 1
	si_llvm_finalize_module(&ctx,
d6425 3
a6427 3
	r = si_compile_llvm(sscreen, &ctx.shader->binary,
			    &ctx.shader->config, ctx.tm,
			    ctx.gallivm.module,
d6433 3
a6435 3
		si_shader_dump(sscreen, ctx.shader, debug,
			       PIPE_SHADER_GEOMETRY, stderr, true);
		r = si_shader_binary_upload(sscreen, ctx.shader);
d6438 1
a6438 1
	si_llvm_dispose(&ctx);
d6441 1
a6441 6

	if (r != 0) {
		FREE(shader);
		shader = NULL;
	}
	return shader;
d6444 1
a6444 1
static void si_dump_shader_key(unsigned shader, struct si_shader_key *key,
d6453 2
a6454 2
		fprintf(f, "  part.vs.prolog.instance_divisors = {");
		for (i = 0; i < ARRAY_SIZE(key->part.vs.prolog.instance_divisors); i++)
d6456 1
a6456 9
				key->part.vs.prolog.instance_divisors[i]);
		fprintf(f, "}\n");
		fprintf(f, "  part.vs.epilog.export_prim_id = %u\n", key->part.vs.epilog.export_prim_id);
		fprintf(f, "  as_es = %u\n", key->as_es);
		fprintf(f, "  as_ls = %u\n", key->as_ls);

		fprintf(f, "  mono.vs.fix_fetch = {");
		for (i = 0; i < SI_MAX_ATTRIBS; i++)
			fprintf(f, !i ? "%u" : ", %u", key->mono.vs.fix_fetch[i]);
d6458 3
d6464 1
a6464 2
		fprintf(f, "  part.tcs.epilog.prim_mode = %u\n", key->part.tcs.epilog.prim_mode);
		fprintf(f, "  mono.tcs.inputs_to_copy = 0x%"PRIx64"\n", key->mono.tcs.inputs_to_copy);
d6468 2
a6469 2
		fprintf(f, "  part.tes.epilog.export_prim_id = %u\n", key->part.tes.epilog.export_prim_id);
		fprintf(f, "  as_es = %u\n", key->as_es);
a6472 3
		fprintf(f, "  part.gs.prolog.tri_strip_adj_fix = %u\n", key->part.gs.prolog.tri_strip_adj_fix);
		break;

d6477 17
a6493 17
		fprintf(f, "  part.ps.prolog.color_two_side = %u\n", key->part.ps.prolog.color_two_side);
		fprintf(f, "  part.ps.prolog.flatshade_colors = %u\n", key->part.ps.prolog.flatshade_colors);
		fprintf(f, "  part.ps.prolog.poly_stipple = %u\n", key->part.ps.prolog.poly_stipple);
		fprintf(f, "  part.ps.prolog.force_persp_sample_interp = %u\n", key->part.ps.prolog.force_persp_sample_interp);
		fprintf(f, "  part.ps.prolog.force_linear_sample_interp = %u\n", key->part.ps.prolog.force_linear_sample_interp);
		fprintf(f, "  part.ps.prolog.force_persp_center_interp = %u\n", key->part.ps.prolog.force_persp_center_interp);
		fprintf(f, "  part.ps.prolog.force_linear_center_interp = %u\n", key->part.ps.prolog.force_linear_center_interp);
		fprintf(f, "  part.ps.prolog.bc_optimize_for_persp = %u\n", key->part.ps.prolog.bc_optimize_for_persp);
		fprintf(f, "  part.ps.prolog.bc_optimize_for_linear = %u\n", key->part.ps.prolog.bc_optimize_for_linear);
		fprintf(f, "  part.ps.epilog.spi_shader_col_format = 0x%x\n", key->part.ps.epilog.spi_shader_col_format);
		fprintf(f, "  part.ps.epilog.color_is_int8 = 0x%X\n", key->part.ps.epilog.color_is_int8);
		fprintf(f, "  part.ps.epilog.color_is_int10 = 0x%X\n", key->part.ps.epilog.color_is_int10);
		fprintf(f, "  part.ps.epilog.last_cbuf = %u\n", key->part.ps.epilog.last_cbuf);
		fprintf(f, "  part.ps.epilog.alpha_func = %u\n", key->part.ps.epilog.alpha_func);
		fprintf(f, "  part.ps.epilog.alpha_to_one = %u\n", key->part.ps.epilog.alpha_to_one);
		fprintf(f, "  part.ps.epilog.poly_line_smoothing = %u\n", key->part.ps.epilog.poly_line_smoothing);
		fprintf(f, "  part.ps.epilog.clamp_color = %u\n", key->part.ps.epilog.clamp_color);
a6498 9

	if ((shader == PIPE_SHADER_GEOMETRY ||
	     shader == PIPE_SHADER_TESS_EVAL ||
	     shader == PIPE_SHADER_VERTEX) &&
	    !key->as_es && !key->as_ls) {
		fprintf(f, "  opt.hw_vs.kill_outputs = 0x%"PRIx64"\n", key->opt.hw_vs.kill_outputs);
		fprintf(f, "  opt.hw_vs.kill_outputs2 = 0x%x\n", key->opt.hw_vs.kill_outputs2);
		fprintf(f, "  opt.hw_vs.clip_disable = %u\n", key->opt.hw_vs.clip_disable);
	}
d6509 3
a6511 1
	si_llvm_context_init(ctx, sscreen, shader, tm,
d6514 21
d6536 1
a6536 1
	bld_base = &ctx->bld_base;
a6543 1
	bld_base->op_actions[TGSI_OPCODE_TEX_LZ] = tex_action;
a6548 1
	bld_base->op_actions[TGSI_OPCODE_TXF_LZ] = tex_action;
a6589 2
	bld_base->op_actions[TGSI_OPCODE_CLOCK].emit = clock_emit;

a6594 10
	bld_base->op_actions[TGSI_OPCODE_VOTE_ALL].emit = vote_all_emit;
	bld_base->op_actions[TGSI_OPCODE_VOTE_ANY].emit = vote_any_emit;
	bld_base->op_actions[TGSI_OPCODE_VOTE_EQ].emit = vote_eq_emit;
	bld_base->op_actions[TGSI_OPCODE_BALLOT].emit = ballot_emit;
	bld_base->op_actions[TGSI_OPCODE_READ_FIRST].intr_name = "llvm.amdgcn.readfirstlane";
	bld_base->op_actions[TGSI_OPCODE_READ_FIRST].emit = read_lane_emit;
	bld_base->op_actions[TGSI_OPCODE_READ_INVOC].intr_name = "llvm.amdgcn.readlane";
	bld_base->op_actions[TGSI_OPCODE_READ_INVOC].fetch_args = read_invoc_fetch_args;
	bld_base->op_actions[TGSI_OPCODE_READ_INVOC].emit = read_lane_emit;

d6600 5
a6604 6
#define EXP_TARGET (HAVE_LLVM >= 0x0500 ? 0 : 3)
#define EXP_OUT0 (HAVE_LLVM >= 0x0500 ? 2 : 5)

/* Return true if the PARAM export has been eliminated. */
static bool si_eliminate_const_output(struct si_shader_context *ctx,
				      LLVMValueRef inst, unsigned offset)
d6606 5
a6610 4
	struct si_shader *shader = ctx->shader;
	unsigned num_outputs = shader->selector->info.num_outputs;
	unsigned i, default_val; /* SPI_PS_INPUT_CNTL_i.DEFAULT_VAL */
	bool is_zero[4] = {}, is_one[4] = {};
d6612 6
a6617 19
	for (i = 0; i < 4; i++) {
		LLVMBool loses_info;
		LLVMValueRef p = LLVMGetOperand(inst, EXP_OUT0 + i);

		/* It's a constant expression. Undef outputs are eliminated too. */
		if (LLVMIsUndef(p)) {
			is_zero[i] = true;
			is_one[i] = true;
		} else if (LLVMIsAConstantFP(p)) {
			double a = LLVMConstRealGetDouble(p, &loses_info);

			if (a == 0)
				is_zero[i] = true;
			else if (a == 1)
				is_one[i] = true;
			else
				return false; /* other constant */
		} else
			return false;
d6620 2
a6621 7
	/* Only certain combinations of 0 and 1 can be eliminated. */
	if (is_zero[0] && is_zero[1] && is_zero[2])
		default_val = is_zero[3] ? 0 : 1;
	else if (is_one[0] && is_one[1] && is_one[2])
		default_val = is_zero[3] ? 2 : 3;
	else
		return false;
d6623 1
a6623 2
	/* The PARAM export can be represented as DEFAULT_VAL. Kill it. */
	LLVMInstructionEraseFromParent(inst);
d6625 2
a6626 121
	/* Change OFFSET to DEFAULT_VAL. */
	for (i = 0; i < num_outputs; i++) {
		if (shader->info.vs_output_param_offset[i] == offset) {
			shader->info.vs_output_param_offset[i] =
				EXP_PARAM_DEFAULT_VAL_0000 + default_val;
			break;
		}
	}
	return true;
}

struct si_vs_exports {
	unsigned num;
	unsigned offset[SI_MAX_VS_OUTPUTS];
	LLVMValueRef inst[SI_MAX_VS_OUTPUTS];
};

static void si_eliminate_const_vs_outputs(struct si_shader_context *ctx)
{
	struct si_shader *shader = ctx->shader;
	struct tgsi_shader_info *info = &shader->selector->info;
	LLVMBasicBlockRef bb;
	struct si_vs_exports exports;
	bool removed_any = false;

	exports.num = 0;

	if (ctx->type == PIPE_SHADER_FRAGMENT ||
	    ctx->type == PIPE_SHADER_COMPUTE ||
	    shader->key.as_es ||
	    shader->key.as_ls)
		return;

	/* Process all LLVM instructions. */
	bb = LLVMGetFirstBasicBlock(ctx->main_fn);
	while (bb) {
		LLVMValueRef inst = LLVMGetFirstInstruction(bb);

		while (inst) {
			LLVMValueRef cur = inst;
			inst = LLVMGetNextInstruction(inst);

			if (LLVMGetInstructionOpcode(cur) != LLVMCall)
				continue;

			LLVMValueRef callee = lp_get_called_value(cur);

			if (!lp_is_function(callee))
				continue;

			const char *name = LLVMGetValueName(callee);
			unsigned num_args = LLVMCountParams(callee);

			/* Check if this is an export instruction. */
			if ((num_args != 9 && num_args != 8) ||
			    (strcmp(name, "llvm.SI.export") &&
			     strcmp(name, "llvm.amdgcn.exp.f32")))
				continue;

			LLVMValueRef arg = LLVMGetOperand(cur, EXP_TARGET);
			unsigned target = LLVMConstIntGetZExtValue(arg);

			if (target < V_008DFC_SQ_EXP_PARAM)
				continue;

			target -= V_008DFC_SQ_EXP_PARAM;

			/* Eliminate constant value PARAM exports. */
			if (si_eliminate_const_output(ctx, cur, target)) {
				removed_any = true;
			} else {
				exports.offset[exports.num] = target;
				exports.inst[exports.num] = cur;
				exports.num++;
			}
		}
		bb = LLVMGetNextBasicBlock(bb);
	}

	/* Remove holes in export memory due to removed PARAM exports.
	 * This is done by renumbering all PARAM exports.
	 */
	if (removed_any) {
		ubyte current_offset[SI_MAX_VS_OUTPUTS];
		unsigned new_count = 0;
		unsigned out, i;

		/* Make a copy of the offsets. We need the old version while
		 * we are modifying some of them. */
		assert(sizeof(current_offset) ==
		       sizeof(shader->info.vs_output_param_offset));
		memcpy(current_offset, shader->info.vs_output_param_offset,
		       sizeof(current_offset));

		for (i = 0; i < exports.num; i++) {
			unsigned offset = exports.offset[i];

			for (out = 0; out < info->num_outputs; out++) {
				if (current_offset[out] != offset)
					continue;

				LLVMSetOperand(exports.inst[i], EXP_TARGET,
					       LLVMConstInt(ctx->i32,
							    V_008DFC_SQ_EXP_PARAM + new_count, 0));
				shader->info.vs_output_param_offset[out] = new_count;
				new_count++;
				break;
			}
		}
		shader->info.nr_param_exports = new_count;
	}
}

static void si_count_scratch_private_memory(struct si_shader_context *ctx)
{
	ctx->shader->config.private_mem_vgprs = 0;

	/* Process all LLVM instructions. */
	LLVMBasicBlockRef bb = LLVMGetFirstBasicBlock(ctx->main_fn);
	while (bb) {
		LLVMValueRef next = LLVMGetFirstInstruction(bb);
d6628 1
a6628 24
		while (next) {
			LLVMValueRef inst = next;
			next = LLVMGetNextInstruction(next);

			if (LLVMGetInstructionOpcode(inst) != LLVMAlloca)
				continue;

			LLVMTypeRef type = LLVMGetElementType(LLVMTypeOf(inst));
			/* No idea why LLVM aligns allocas to 4 elements. */
			unsigned alignment = LLVMGetAlignment(inst);
			unsigned dw_size = align(llvm_get_type_size(type) / 4, alignment);
			ctx->shader->config.private_mem_vgprs += dw_size;
		}
		bb = LLVMGetNextBasicBlock(bb);
	}
}

static bool si_compile_tgsi_main(struct si_shader_context *ctx,
				 struct si_shader *shader)
{
	struct si_shader_selector *sel = shader->selector;
	struct lp_build_tgsi_context *bld_base = &ctx->bld_base;

	switch (ctx->type) {
d6630 2
a6631 2
		ctx->load_input = declare_input_vs;
		if (shader->key.as_ls)
d6633 1
a6633 1
		else if (shader->key.as_es)
d6646 1
a6646 1
		if (shader->key.as_es)
d6656 5
a6660 2
		ctx->load_input = declare_input_fs;
		bld_base->emit_epilogue = si_llvm_return_fs_outputs;
d6663 1
a6663 1
		ctx->declare_memory_region = declare_compute_memory;
d6667 1
a6667 499
		return false;
	}

	create_function(ctx);
	preload_ring_buffers(ctx);

	if (ctx->type == PIPE_SHADER_GEOMETRY) {
		int i;
		for (i = 0; i < 4; i++) {
			ctx->gs_next_vertex[i] =
				lp_build_alloca(&ctx->gallivm,
						ctx->i32, "");
		}
	}

	if (!lp_build_tgsi_llvm(bld_base, sel->tokens)) {
		fprintf(stderr, "Failed to translate shader from TGSI to LLVM\n");
		return false;
	}

	si_llvm_build_ret(ctx, ctx->return_value);
	return true;
}

/**
 * Compute the VS prolog key, which contains all the information needed to
 * build the VS prolog function, and set shader->info bits where needed.
 */
static void si_get_vs_prolog_key(struct si_shader *shader,
				 union si_shader_part_key *key)
{
	struct tgsi_shader_info *info = &shader->selector->info;

	memset(key, 0, sizeof(*key));
	key->vs_prolog.states = shader->key.part.vs.prolog;
	key->vs_prolog.num_input_sgprs = shader->info.num_input_sgprs;
	key->vs_prolog.last_input = MAX2(1, info->num_inputs) - 1;

	/* Set the instanceID flag. */
	for (unsigned i = 0; i < info->num_inputs; i++)
		if (key->vs_prolog.states.instance_divisors[i])
			shader->info.uses_instanceid = true;
}

/**
 * Compute the VS epilog key, which contains all the information needed to
 * build the VS epilog function, and set the PrimitiveID output offset.
 */
static void si_get_vs_epilog_key(struct si_shader *shader,
				 struct si_vs_epilog_bits *states,
				 union si_shader_part_key *key)
{
	memset(key, 0, sizeof(*key));
	key->vs_epilog.states = *states;

	/* Set up the PrimitiveID output. */
	if (shader->key.part.vs.epilog.export_prim_id) {
		unsigned index = shader->selector->info.num_outputs;
		unsigned offset = shader->info.nr_param_exports++;

		key->vs_epilog.prim_id_param_offset = offset;
		assert(index < ARRAY_SIZE(shader->info.vs_output_param_offset));
		shader->info.vs_output_param_offset[index] = offset;
	}
}

/**
 * Compute the PS prolog key, which contains all the information needed to
 * build the PS prolog function, and set related bits in shader->config.
 */
static void si_get_ps_prolog_key(struct si_shader *shader,
				 union si_shader_part_key *key,
				 bool separate_prolog)
{
	struct tgsi_shader_info *info = &shader->selector->info;

	memset(key, 0, sizeof(*key));
	key->ps_prolog.states = shader->key.part.ps.prolog;
	key->ps_prolog.colors_read = info->colors_read;
	key->ps_prolog.num_input_sgprs = shader->info.num_input_sgprs;
	key->ps_prolog.num_input_vgprs = shader->info.num_input_vgprs;
	key->ps_prolog.wqm = info->uses_derivatives &&
		(key->ps_prolog.colors_read ||
		 key->ps_prolog.states.force_persp_sample_interp ||
		 key->ps_prolog.states.force_linear_sample_interp ||
		 key->ps_prolog.states.force_persp_center_interp ||
		 key->ps_prolog.states.force_linear_center_interp ||
		 key->ps_prolog.states.bc_optimize_for_persp ||
		 key->ps_prolog.states.bc_optimize_for_linear);

	if (info->colors_read) {
		unsigned *color = shader->selector->color_attr_index;

		if (shader->key.part.ps.prolog.color_two_side) {
			/* BCOLORs are stored after the last input. */
			key->ps_prolog.num_interp_inputs = info->num_inputs;
			key->ps_prolog.face_vgpr_index = shader->info.face_vgpr_index;
			shader->config.spi_ps_input_ena |= S_0286CC_FRONT_FACE_ENA(1);
		}

		for (unsigned i = 0; i < 2; i++) {
			unsigned interp = info->input_interpolate[color[i]];
			unsigned location = info->input_interpolate_loc[color[i]];

			if (!(info->colors_read & (0xf << i*4)))
				continue;

			key->ps_prolog.color_attr_index[i] = color[i];

			if (shader->key.part.ps.prolog.flatshade_colors &&
			    interp == TGSI_INTERPOLATE_COLOR)
				interp = TGSI_INTERPOLATE_CONSTANT;

			switch (interp) {
			case TGSI_INTERPOLATE_CONSTANT:
				key->ps_prolog.color_interp_vgpr_index[i] = -1;
				break;
			case TGSI_INTERPOLATE_PERSPECTIVE:
			case TGSI_INTERPOLATE_COLOR:
				/* Force the interpolation location for colors here. */
				if (shader->key.part.ps.prolog.force_persp_sample_interp)
					location = TGSI_INTERPOLATE_LOC_SAMPLE;
				if (shader->key.part.ps.prolog.force_persp_center_interp)
					location = TGSI_INTERPOLATE_LOC_CENTER;

				switch (location) {
				case TGSI_INTERPOLATE_LOC_SAMPLE:
					key->ps_prolog.color_interp_vgpr_index[i] = 0;
					shader->config.spi_ps_input_ena |=
						S_0286CC_PERSP_SAMPLE_ENA(1);
					break;
				case TGSI_INTERPOLATE_LOC_CENTER:
					key->ps_prolog.color_interp_vgpr_index[i] = 2;
					shader->config.spi_ps_input_ena |=
						S_0286CC_PERSP_CENTER_ENA(1);
					break;
				case TGSI_INTERPOLATE_LOC_CENTROID:
					key->ps_prolog.color_interp_vgpr_index[i] = 4;
					shader->config.spi_ps_input_ena |=
						S_0286CC_PERSP_CENTROID_ENA(1);
					break;
				default:
					assert(0);
				}
				break;
			case TGSI_INTERPOLATE_LINEAR:
				/* Force the interpolation location for colors here. */
				if (shader->key.part.ps.prolog.force_linear_sample_interp)
					location = TGSI_INTERPOLATE_LOC_SAMPLE;
				if (shader->key.part.ps.prolog.force_linear_center_interp)
					location = TGSI_INTERPOLATE_LOC_CENTER;

				/* The VGPR assignment for non-monolithic shaders
				 * works because InitialPSInputAddr is set on the
				 * main shader and PERSP_PULL_MODEL is never used.
				 */
				switch (location) {
				case TGSI_INTERPOLATE_LOC_SAMPLE:
					key->ps_prolog.color_interp_vgpr_index[i] =
						separate_prolog ? 6 : 9;
					shader->config.spi_ps_input_ena |=
						S_0286CC_LINEAR_SAMPLE_ENA(1);
					break;
				case TGSI_INTERPOLATE_LOC_CENTER:
					key->ps_prolog.color_interp_vgpr_index[i] =
						separate_prolog ? 8 : 11;
					shader->config.spi_ps_input_ena |=
						S_0286CC_LINEAR_CENTER_ENA(1);
					break;
				case TGSI_INTERPOLATE_LOC_CENTROID:
					key->ps_prolog.color_interp_vgpr_index[i] =
						separate_prolog ? 10 : 13;
					shader->config.spi_ps_input_ena |=
						S_0286CC_LINEAR_CENTROID_ENA(1);
					break;
				default:
					assert(0);
				}
				break;
			default:
				assert(0);
			}
		}
	}
}

/**
 * Check whether a PS prolog is required based on the key.
 */
static bool si_need_ps_prolog(const union si_shader_part_key *key)
{
	return key->ps_prolog.colors_read ||
	       key->ps_prolog.states.force_persp_sample_interp ||
	       key->ps_prolog.states.force_linear_sample_interp ||
	       key->ps_prolog.states.force_persp_center_interp ||
	       key->ps_prolog.states.force_linear_center_interp ||
	       key->ps_prolog.states.bc_optimize_for_persp ||
	       key->ps_prolog.states.bc_optimize_for_linear ||
	       key->ps_prolog.states.poly_stipple;
}

/**
 * Compute the PS epilog key, which contains all the information needed to
 * build the PS epilog function.
 */
static void si_get_ps_epilog_key(struct si_shader *shader,
				 union si_shader_part_key *key)
{
	struct tgsi_shader_info *info = &shader->selector->info;
	memset(key, 0, sizeof(*key));
	key->ps_epilog.colors_written = info->colors_written;
	key->ps_epilog.writes_z = info->writes_z;
	key->ps_epilog.writes_stencil = info->writes_stencil;
	key->ps_epilog.writes_samplemask = info->writes_samplemask;
	key->ps_epilog.states = shader->key.part.ps.epilog;
}

/**
 * Build the GS prolog function. Rotate the input vertices for triangle strips
 * with adjacency.
 */
static void si_build_gs_prolog_function(struct si_shader_context *ctx,
					union si_shader_part_key *key)
{
	const unsigned num_sgprs = SI_GS_NUM_USER_SGPR + 2;
	const unsigned num_vgprs = 8;
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = gallivm->builder;
	LLVMTypeRef params[32];
	LLVMTypeRef returns[32];
	LLVMValueRef func, ret;

	for (unsigned i = 0; i < num_sgprs; ++i) {
		params[i] = ctx->i32;
		returns[i] = ctx->i32;
	}

	for (unsigned i = 0; i < num_vgprs; ++i) {
		params[num_sgprs + i] = ctx->i32;
		returns[num_sgprs + i] = ctx->f32;
	}

	/* Create the function. */
	si_create_function(ctx, "gs_prolog", returns, num_sgprs + num_vgprs,
			   params, num_sgprs + num_vgprs, num_sgprs - 1);
	func = ctx->main_fn;

	/* Copy inputs to outputs. This should be no-op, as the registers match,
	 * but it will prevent the compiler from overwriting them unintentionally.
	 */
	ret = ctx->return_value;
	for (unsigned i = 0; i < num_sgprs; i++) {
		LLVMValueRef p = LLVMGetParam(func, i);
		ret = LLVMBuildInsertValue(builder, ret, p, i, "");
	}
	for (unsigned i = 0; i < num_vgprs; i++) {
		LLVMValueRef p = LLVMGetParam(func, num_sgprs + i);
		p = LLVMBuildBitCast(builder, p, ctx->f32, "");
		ret = LLVMBuildInsertValue(builder, ret, p, num_sgprs + i, "");
	}

	if (key->gs_prolog.states.tri_strip_adj_fix) {
		/* Remap the input vertices for every other primitive. */
		const unsigned vtx_params[6] = {
			num_sgprs,
			num_sgprs + 1,
			num_sgprs + 3,
			num_sgprs + 4,
			num_sgprs + 5,
			num_sgprs + 6
		};
		LLVMValueRef prim_id, rotate;

		prim_id = LLVMGetParam(func, num_sgprs + 2);
		rotate = LLVMBuildTrunc(builder, prim_id, ctx->i1, "");

		for (unsigned i = 0; i < 6; ++i) {
			LLVMValueRef base, rotated, actual;
			base = LLVMGetParam(func, vtx_params[i]);
			rotated = LLVMGetParam(func, vtx_params[(i + 4) % 6]);
			actual = LLVMBuildSelect(builder, rotate, rotated, base, "");
			actual = LLVMBuildBitCast(builder, actual, ctx->f32, "");
			ret = LLVMBuildInsertValue(builder, ret, actual, vtx_params[i], "");
		}
	}

	LLVMBuildRet(builder, ret);
}

/**
 * Given a list of shader part functions, build a wrapper function that
 * runs them in sequence to form a monolithic shader.
 */
static void si_build_wrapper_function(struct si_shader_context *ctx,
				      LLVMValueRef *parts,
				      unsigned num_parts,
				      unsigned main_part)
{
	struct gallivm_state *gallivm = &ctx->gallivm;
	LLVMBuilderRef builder = ctx->gallivm.builder;
	/* PS epilog has one arg per color component */
	LLVMTypeRef param_types[64];
	LLVMValueRef out[64];
	LLVMTypeRef function_type;
	unsigned num_params;
	unsigned num_out;
	MAYBE_UNUSED unsigned num_out_sgpr; /* used in debug checks */
	unsigned num_sgprs, num_vgprs;
	unsigned last_sgpr_param;
	unsigned gprs;

	for (unsigned i = 0; i < num_parts; ++i) {
		lp_add_function_attr(parts[i], -1, LP_FUNC_ATTR_ALWAYSINLINE);
		LLVMSetLinkage(parts[i], LLVMPrivateLinkage);
	}

	/* The parameters of the wrapper function correspond to those of the
	 * first part in terms of SGPRs and VGPRs, but we use the types of the
	 * main part to get the right types. This is relevant for the
	 * dereferenceable attribute on descriptor table pointers.
	 */
	num_sgprs = 0;
	num_vgprs = 0;

	function_type = LLVMGetElementType(LLVMTypeOf(parts[0]));
	num_params = LLVMCountParamTypes(function_type);

	for (unsigned i = 0; i < num_params; ++i) {
		LLVMValueRef param = LLVMGetParam(parts[0], i);

		if (ac_is_sgpr_param(param)) {
			assert(num_vgprs == 0);
			num_sgprs += llvm_get_type_size(LLVMTypeOf(param)) / 4;
		} else {
			num_vgprs += llvm_get_type_size(LLVMTypeOf(param)) / 4;
		}
	}
	assert(num_vgprs + num_sgprs <= ARRAY_SIZE(param_types));

	num_params = 0;
	last_sgpr_param = 0;
	gprs = 0;
	while (gprs < num_sgprs + num_vgprs) {
		LLVMValueRef param = LLVMGetParam(parts[main_part], num_params);
		unsigned size;

		param_types[num_params] = LLVMTypeOf(param);
		if (gprs < num_sgprs)
			last_sgpr_param = num_params;
		size = llvm_get_type_size(param_types[num_params]) / 4;
		num_params++;

		assert(ac_is_sgpr_param(param) == (gprs < num_sgprs));
		assert(gprs + size <= num_sgprs + num_vgprs &&
		       (gprs >= num_sgprs || gprs + size <= num_sgprs));

		gprs += size;
	}

	si_create_function(ctx, "wrapper", NULL, 0, param_types, num_params, last_sgpr_param);

	/* Record the arguments of the function as if they were an output of
	 * a previous part.
	 */
	num_out = 0;
	num_out_sgpr = 0;

	for (unsigned i = 0; i < num_params; ++i) {
		LLVMValueRef param = LLVMGetParam(ctx->main_fn, i);
		LLVMTypeRef param_type = LLVMTypeOf(param);
		LLVMTypeRef out_type = i <= last_sgpr_param ? ctx->i32 : ctx->f32;
		unsigned size = llvm_get_type_size(param_type) / 4;

		if (size == 1) {
			if (param_type != out_type)
				param = LLVMBuildBitCast(builder, param, out_type, "");
			out[num_out++] = param;
		} else {
			LLVMTypeRef vector_type = LLVMVectorType(out_type, size);

			if (LLVMGetTypeKind(param_type) == LLVMPointerTypeKind) {
				param = LLVMBuildPtrToInt(builder, param, ctx->i64, "");
				param_type = ctx->i64;
			}

			if (param_type != vector_type)
				param = LLVMBuildBitCast(builder, param, vector_type, "");

			for (unsigned j = 0; j < size; ++j)
				out[num_out++] = LLVMBuildExtractElement(
					builder, param, LLVMConstInt(ctx->i32, j, 0), "");
		}

		if (i <= last_sgpr_param)
			num_out_sgpr = num_out;
	}

	/* Now chain the parts. */
	for (unsigned part = 0; part < num_parts; ++part) {
		LLVMValueRef in[48];
		LLVMValueRef ret;
		LLVMTypeRef ret_type;
		unsigned out_idx = 0;

		num_params = LLVMCountParams(parts[part]);
		assert(num_params <= ARRAY_SIZE(param_types));

		/* Derive arguments for the next part from outputs of the
		 * previous one.
		 */
		for (unsigned param_idx = 0; param_idx < num_params; ++param_idx) {
			LLVMValueRef param;
			LLVMTypeRef param_type;
			bool is_sgpr;
			unsigned param_size;
			LLVMValueRef arg = NULL;

			param = LLVMGetParam(parts[part], param_idx);
			param_type = LLVMTypeOf(param);
			param_size = llvm_get_type_size(param_type) / 4;
			is_sgpr = ac_is_sgpr_param(param);

			if (is_sgpr) {
#if HAVE_LLVM < 0x0400
				LLVMRemoveAttribute(param, LLVMByValAttribute);
#else
				unsigned kind_id = LLVMGetEnumAttributeKindForName("byval", 5);
				LLVMRemoveEnumAttributeAtIndex(parts[part], param_idx + 1, kind_id);
#endif
				lp_add_function_attr(parts[part], param_idx + 1, LP_FUNC_ATTR_INREG);
			}

			assert(out_idx + param_size <= (is_sgpr ? num_out_sgpr : num_out));
			assert(is_sgpr || out_idx >= num_out_sgpr);

			if (param_size == 1)
				arg = out[out_idx];
			else
				arg = lp_build_gather_values(gallivm, &out[out_idx], param_size);

			if (LLVMTypeOf(arg) != param_type) {
				if (LLVMGetTypeKind(param_type) == LLVMPointerTypeKind) {
					arg = LLVMBuildBitCast(builder, arg, ctx->i64, "");
					arg = LLVMBuildIntToPtr(builder, arg, param_type, "");
				} else {
					arg = LLVMBuildBitCast(builder, arg, param_type, "");
				}
			}

			in[param_idx] = arg;
			out_idx += param_size;
		}

		ret = LLVMBuildCall(builder, parts[part], in, num_params, "");
		ret_type = LLVMTypeOf(ret);

		/* Extract the returned GPRs. */
		num_out = 0;
		num_out_sgpr = 0;

		if (LLVMGetTypeKind(ret_type) != LLVMVoidTypeKind) {
			assert(LLVMGetTypeKind(ret_type) == LLVMStructTypeKind);

			unsigned ret_size = LLVMCountStructElementTypes(ret_type);

			for (unsigned i = 0; i < ret_size; ++i) {
				LLVMValueRef val =
					LLVMBuildExtractValue(builder, ret, i, "");

				assert(num_out < ARRAY_SIZE(out));
				out[num_out++] = val;

				if (LLVMTypeOf(val) == ctx->i32) {
					assert(num_out_sgpr + 1 == num_out);
					num_out_sgpr = num_out;
				}
			}
		}
	}

	LLVMBuildRetVoid(builder);
}

int si_compile_tgsi_shader(struct si_screen *sscreen,
			   LLVMTargetMachineRef tm,
			   struct si_shader *shader,
			   bool is_monolithic,
			   struct pipe_debug_callback *debug)
{
	struct si_shader_selector *sel = shader->selector;
	struct si_shader_context ctx;
	int r = -1;

	/* Dump TGSI code before doing TGSI->LLVM conversion in case the
	 * conversion fails. */
	if (r600_can_dump_shader(&sscreen->b, sel->info.processor) &&
	    !(sscreen->b.debug_flags & DBG_NO_TGSI)) {
		tgsi_dump(sel->tokens, 0);
		si_dump_streamout(&sel->so);
d6670 3
a6672 2
	si_init_shader_ctx(&ctx, sscreen, shader, tm);
	ctx.separate_prolog = !is_monolithic;
d6674 6
a6679 10
	memset(shader->info.vs_output_param_offset, EXP_PARAM_UNDEFINED,
	       sizeof(shader->info.vs_output_param_offset));

	shader->info.uses_instanceid = sel->info.uses_instanceid;

	ctx.load_system_value = declare_system_value;

	if (!si_compile_tgsi_main(&ctx, shader)) {
		si_llvm_dispose(&ctx);
		return -1;
d6682 6
a6687 15
	if (is_monolithic && ctx.type == PIPE_SHADER_VERTEX) {
		LLVMValueRef parts[3];
		bool need_prolog;
		bool need_epilog;

		need_prolog = sel->vs_needs_prolog;
		need_epilog = !shader->key.as_es && !shader->key.as_ls;

		parts[need_prolog ? 1 : 0] = ctx.main_fn;

		if (need_prolog) {
			union si_shader_part_key prolog_key;
			si_get_vs_prolog_key(shader, &prolog_key);
			si_build_vs_prolog_function(&ctx, &prolog_key);
			parts[0] = ctx.main_fn;
d6689 1
d6691 4
a6694 36
		if (need_epilog) {
			union si_shader_part_key epilog_key;
			si_get_vs_epilog_key(shader, &shader->key.part.vs.epilog, &epilog_key);
			si_build_vs_epilog_function(&ctx, &epilog_key);
			parts[need_prolog ? 2 : 1] = ctx.main_fn;
		}

		si_build_wrapper_function(&ctx, parts, 1 + need_prolog + need_epilog,
					  need_prolog ? 1 : 0);
	} else if (is_monolithic && ctx.type == PIPE_SHADER_TESS_CTRL) {
		LLVMValueRef parts[2];
		union si_shader_part_key epilog_key;

		parts[0] = ctx.main_fn;

		memset(&epilog_key, 0, sizeof(epilog_key));
		epilog_key.tcs_epilog.states = shader->key.part.tcs.epilog;
		si_build_tcs_epilog_function(&ctx, &epilog_key);
		parts[1] = ctx.main_fn;

		si_build_wrapper_function(&ctx, parts, 2, 0);
	} else if (is_monolithic && ctx.type == PIPE_SHADER_TESS_EVAL &&
		   !shader->key.as_es) {
		LLVMValueRef parts[2];
		union si_shader_part_key epilog_key;

		parts[0] = ctx.main_fn;

		si_get_vs_epilog_key(shader, &shader->key.part.tes.epilog, &epilog_key);
		si_build_vs_epilog_function(&ctx, &epilog_key);
		parts[1] = ctx.main_fn;

		si_build_wrapper_function(&ctx, parts, 2, 0);
	} else if (is_monolithic && ctx.type == PIPE_SHADER_GEOMETRY) {
		LLVMValueRef parts[2];
		union si_shader_part_key prolog_key;
d6696 2
a6697 30
		parts[1] = ctx.main_fn;

		memset(&prolog_key, 0, sizeof(prolog_key));
		prolog_key.gs_prolog.states = shader->key.part.gs.prolog;
		si_build_gs_prolog_function(&ctx, &prolog_key);
		parts[0] = ctx.main_fn;

		si_build_wrapper_function(&ctx, parts, 2, 1);
	} else if (is_monolithic && ctx.type == PIPE_SHADER_FRAGMENT) {
		LLVMValueRef parts[3];
		union si_shader_part_key prolog_key;
		union si_shader_part_key epilog_key;
		bool need_prolog;

		si_get_ps_prolog_key(shader, &prolog_key, false);
		need_prolog = si_need_ps_prolog(&prolog_key);

		parts[need_prolog ? 1 : 0] = ctx.main_fn;

		if (need_prolog) {
			si_build_ps_prolog_function(&ctx, &prolog_key);
			parts[0] = ctx.main_fn;
		}

		si_get_ps_epilog_key(shader, &epilog_key);
		si_build_ps_epilog_function(&ctx, &epilog_key);
		parts[need_prolog ? 2 : 1] = ctx.main_fn;

		si_build_wrapper_function(&ctx, parts, need_prolog ? 3 : 2, need_prolog ? 1 : 0);
	}
d6702 1
a6702 1
		LLVMDumpModule(ctx.gallivm.module);
a6706 8
	/* Post-optimization transformations and analysis. */
	si_eliminate_const_vs_outputs(&ctx);

	if ((debug && debug->debug_message) ||
	    r600_can_dump_shader(&sscreen->b, ctx.type))
		si_count_scratch_private_memory(&ctx);

	/* Compile to bytecode. */
d6708 1
a6708 2
			    ctx.gallivm.module, debug, ctx.type, "TGSI shader");
	si_llvm_dispose(&ctx);
d6711 1
a6711 1
		return r;
d6714 2
d6792 14
a6805 1
	return 0;
a6812 1
 * \param type		shader type
a6813 1
 * \param prolog	whether the part being requested is a prolog
d6816 1
a6816 1
 * \param build		the callback responsible for building the main function
a6821 2
		   enum pipe_shader_type type,
		   bool prolog,
d6825 4
a6828 3
		   void (*build)(struct si_shader_context *,
				 union si_shader_part_key *),
		   const char *name)
d6832 1
a6832 1
	mtx_lock(&sscreen->shader_parts_mutex);
d6837 1
a6837 1
			mtx_unlock(&sscreen->shader_parts_mutex);
d6845 1
a6845 36

	struct si_shader shader = {};
	struct si_shader_context ctx;
	struct gallivm_state *gallivm = &ctx.gallivm;

	si_init_shader_ctx(&ctx, sscreen, &shader, tm);
	ctx.type = type;

	switch (type) {
	case PIPE_SHADER_VERTEX:
		break;
	case PIPE_SHADER_TESS_CTRL:
		assert(!prolog);
		shader.key.part.tcs.epilog = key->tcs_epilog.states;
		break;
	case PIPE_SHADER_GEOMETRY:
		assert(prolog);
		break;
	case PIPE_SHADER_FRAGMENT:
		if (prolog)
			shader.key.part.ps.prolog = key->ps_prolog.states;
		else
			shader.key.part.ps.epilog = key->ps_epilog.states;
		break;
	default:
		unreachable("bad shader part");
	}

	build(&ctx, key);

	/* Compile. */
	si_llvm_finalize_module(&ctx,
		r600_extra_shader_checks(&sscreen->b, PIPE_SHADER_FRAGMENT));

	if (si_compile_llvm(sscreen, &result->binary, &result->config, tm,
			    gallivm->module, debug, ctx.type, name)) {
d6847 2
a6848 2
		result = NULL;
		goto out;
d6853 1
a6853 4

out:
	si_llvm_dispose(&ctx);
	mtx_unlock(&sscreen->shader_parts_mutex);
d6858 1
a6858 1
 * Build the vertex shader prolog function.
d6862 1
a6862 1
 * stored after them, which will be used by the API VS for fetching inputs.
d6873 4
a6876 2
static void si_build_vs_prolog_function(struct si_shader_context *ctx,
					union si_shader_part_key *key)
d6878 4
a6881 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d6885 1
d6887 4
a6890 2
	ctx->param_vertex_id = key->vs_prolog.num_input_sgprs;
	ctx->param_instance_id = key->vs_prolog.num_input_sgprs + 3;
d6904 2
a6905 2
		params[num_params++] = ctx->i32;
		returns[num_returns++] = ctx->i32;
d6911 2
a6912 2
		params[num_params++] = ctx->i32;
		returns[num_returns++] = ctx->f32;
d6917 1
a6917 1
		returns[num_returns++] = ctx->f32;
d6920 1
a6920 1
	si_create_function(ctx, "vs_prolog", returns, num_returns, params,
d6922 1
a6922 1
	func = ctx->main_fn;
d6927 1
a6927 1
	ret = ctx->return_value;
d6934 1
a6934 1
		p = LLVMBuildBitCast(gallivm->builder, p, ctx->f32, "");
d6945 1
a6945 1
			index = get_instance_index_for_fetch(ctx,
d6951 1
a6951 1
					     LLVMGetParam(func, ctx->param_vertex_id),
d6955 1
a6955 1
		index = LLVMBuildBitCast(gallivm->builder, index, ctx->f32, "");
d6960 12
a6971 1
	si_llvm_build_ret(ctx, ret);
d6975 1
a6975 1
 * Build the vertex shader epilog function. This is also used by the tessellation
d6983 4
a6986 2
static void si_build_vs_epilog_function(struct si_shader_context *ctx,
					union si_shader_part_key *key)
d6988 4
a6991 2
	struct gallivm_state *gallivm = &ctx->gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx->bld_base;
d6994 4
d7005 1
a7005 1
		params[i] = ctx->f32;
d7008 1
a7008 1
	si_create_function(ctx, "vs_epilog", NULL, 0, params, num_params, -1);
d7013 2
a7014 1
		struct ac_export_args args;
d7016 7
a7022 7
		args.enabled_channels = 0x1; /* enabled channels */
		args.valid_mask = 0; /* whether the EXEC mask is valid */
		args.done = 0; /* DONE bit */
		args.target = V_008DFC_SQ_EXP_PARAM +
			      key->vs_epilog.prim_id_param_offset;
		args.compr = 0; /* COMPR flag (0 = 32-bit export) */
		args.out[0] = LLVMGetParam(ctx->main_fn,
d7024 7
a7030 5
		args.out[1] = base->undef; /* Y */
		args.out[2] = base->undef; /* Z */
		args.out[3] = base->undef; /* W */

		ac_build_export(&ctx->ac, &args);
d7033 1
d7035 10
d7058 12
a7069 1
	si_get_vs_epilog_key(shader, states, &epilog_key);
a7071 1
					    PIPE_SHADER_VERTEX, true,
d7073 1
a7073 2
					    si_build_vs_epilog_function,
					    "Vertex Shader Epilog");
d7085 3
a7087 2
	if (shader->selector->vs_needs_prolog) {
		union si_shader_part_key prolog_key;
d7089 5
a7093 2
		/* Get the prolog. */
		si_get_vs_prolog_key(shader, &prolog_key);
d7095 2
a7098 1
					   PIPE_SHADER_VERTEX, true,
d7100 1
a7100 2
					   si_build_vs_prolog_function,
					   "Vertex Shader Prolog");
d7106 1
a7106 1
	if (!shader->key.as_es && !shader->key.as_ls &&
d7108 1
a7108 1
			      &shader->key.part.vs.epilog))
d7111 5
d7127 1
a7127 1
	if (shader->key.as_es)
d7132 1
a7132 1
				&shader->key.part.tes.epilog);
d7136 2
a7137 2
 * Compile the TCS epilog function. This writes tesselation factors to memory
 * based on the output primitive type of the tesselator (determined by TES).
d7139 4
a7142 2
static void si_build_tcs_epilog_function(struct si_shader_context *ctx,
					 union si_shader_part_key *key)
d7144 5
a7148 2
	struct gallivm_state *gallivm = &ctx->gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx->bld_base;
d7152 5
d7159 11
a7169 11
	params[SI_PARAM_RW_BUFFERS] = const_array(ctx->v16i8, SI_NUM_RW_BUFFERS);
	params[SI_PARAM_CONST_BUFFERS] = ctx->i64;
	params[SI_PARAM_SAMPLERS] = ctx->i64;
	params[SI_PARAM_IMAGES] = ctx->i64;
	params[SI_PARAM_SHADER_BUFFERS] = ctx->i64;
	params[SI_PARAM_TCS_OFFCHIP_LAYOUT] = ctx->i32;
	params[SI_PARAM_TCS_OUT_OFFSETS] = ctx->i32;
	params[SI_PARAM_TCS_OUT_LAYOUT] = ctx->i32;
	params[SI_PARAM_TCS_IN_LAYOUT] = ctx->i32;
	params[ctx->param_oc_lds = SI_PARAM_TCS_OC_LDS] = ctx->i32;
	params[SI_PARAM_TESS_FACTOR_OFFSET] = ctx->i32;
d7173 3
a7175 3
	params[num_params++] = ctx->i32; /* patch index within the wave (REL_PATCH_ID) */
	params[num_params++] = ctx->i32; /* invocation ID within the patch */
	params[num_params++] = ctx->i32; /* LDS offset where tess factors should be loaded from */
d7178 3
a7180 3
	si_create_function(ctx, "tcs_epilog", NULL, 0, params, num_params, last_sgpr);
	declare_tess_lds(ctx);
	func = ctx->main_fn;
d7187 1
d7189 10
d7213 1
a7213 1
	epilog_key.tcs_epilog.states = shader->key.part.tcs.epilog;
a7215 1
					    PIPE_SHADER_TESS_CTRL, false,
d7217 1
a7217 2
					    si_build_tcs_epilog_function,
					    "Tessellation Control Shader Epilog");
d7222 1
a7222 25
 * Select and compile (or reuse) GS parts (prolog).
 */
static bool si_shader_select_gs_parts(struct si_screen *sscreen,
				      LLVMTargetMachineRef tm,
				      struct si_shader *shader,
				      struct pipe_debug_callback *debug)
{
	union si_shader_part_key prolog_key;

	if (!shader->key.part.gs.prolog.tri_strip_adj_fix)
		return true;

	memset(&prolog_key, 0, sizeof(prolog_key));
	prolog_key.gs_prolog.states = shader->key.part.gs.prolog;

	shader->prolog = si_get_shader_part(sscreen, &sscreen->gs_prologs,
					    PIPE_SHADER_GEOMETRY, true,
					    &prolog_key, tm, debug,
					    si_build_gs_prolog_function,
					    "Geometry Shader Prolog");
	return shader->prolog != NULL;
}

/**
 * Build the pixel shader prolog function. This handles:
d7231 4
a7234 2
static void si_build_ps_prolog_function(struct si_shader_context *ctx,
					union si_shader_part_key *key)
d7236 4
a7239 1
	struct gallivm_state *gallivm = &ctx->gallivm;
d7243 1
d7245 3
a7247 1
	assert(si_need_ps_prolog(key));
d7257 1
a7257 1
		params[num_params++] = ctx->i32;
d7261 1
a7261 1
		params[num_params++] = ctx->f32;
d7267 1
a7267 1
		params[num_returns++] = ctx->f32;
d7270 1
a7270 1
	si_create_function(ctx, "ps_prolog", params, num_returns, params,
d7272 1
a7272 1
	func = ctx->main_fn;
d7277 1
a7277 1
	ret = ctx->return_value;
d7294 1
a7294 1
		list = LLVMBuildBitCast(gallivm->builder, list, ctx->i64, "");
d7296 1
a7296 1
					  const_array(ctx->v16i8, SI_NUM_RW_BUFFERS), "");
d7298 1
a7298 1
		si_llvm_emit_polygon_stipple(ctx, list, pos);
d7314 1
a7314 1
					    LLVMConstInt(ctx->i32, 31, 0), "");
d7316 1
a7316 1
					     ctx->i1, "");
d7440 2
d7449 1
a7449 1
			face = LLVMBuildBitCast(gallivm->builder, face, ctx->i32, "");
d7452 1
a7452 1
		interp_fs_input(ctx,
d7472 12
a7483 1
	si_llvm_build_ret(ctx, ret);
d7487 1
a7487 1
 * Build the pixel shader epilog function. This handles everything that must be
d7490 4
a7493 2
static void si_build_ps_epilog_function(struct si_shader_context *ctx,
					union si_shader_part_key *key)
d7495 5
a7499 2
	struct gallivm_state *gallivm = &ctx->gallivm;
	struct lp_build_tgsi_context *bld_base = &ctx->bld_base;
d7503 1
d7506 4
d7511 6
a7516 6
	params[SI_PARAM_RW_BUFFERS] = ctx->i64;
	params[SI_PARAM_CONST_BUFFERS] = ctx->i64;
	params[SI_PARAM_SAMPLERS] = ctx->i64;
	params[SI_PARAM_IMAGES] = ctx->i64;
	params[SI_PARAM_SHADER_BUFFERS] = ctx->i64;
	params[SI_PARAM_ALPHA_REF] = ctx->f32;
d7532 1
a7532 1
		params[i] = ctx->f32;
d7535 1
a7535 1
	si_create_function(ctx, "ps_epilog", NULL, 0, params, num_params, last_sgpr);
d7537 1
a7537 1
	si_llvm_add_attribute(ctx->main_fn,
d7570 1
a7570 1
			color[i] = LLVMGetParam(ctx->main_fn, vgpr++);
d7579 1
a7579 1
		depth = LLVMGetParam(ctx->main_fn, vgpr++);
d7581 1
a7581 1
		stencil = LLVMGetParam(ctx->main_fn, vgpr++);
d7583 1
a7583 1
		samplemask = LLVMGetParam(ctx->main_fn, vgpr++);
d7591 1
a7591 1
		si_emit_ps_exports(ctx, &exp);
d7595 10
d7615 1
d7618 1
d7621 101
a7721 1
	si_get_ps_prolog_key(shader, &prolog_key, true);
d7724 8
a7731 1
	if (si_need_ps_prolog(&prolog_key)) {
a7733 1
					   PIPE_SHADER_FRAGMENT, true,
d7735 1
a7735 2
					   si_build_ps_prolog_function,
					   "Fragment Shader Prolog");
d7741 6
a7746 1
	si_get_ps_epilog_key(shader, &epilog_key);
a7749 1
				   PIPE_SHADER_FRAGMENT, false,
d7751 1
a7751 2
				   si_build_ps_epilog_function,
				   "Fragment Shader Epilog");
d7756 1
a7756 1
	if (shader->key.part.ps.prolog.poly_stipple) {
d7762 1
a7762 1
	if (shader->key.part.ps.prolog.force_persp_sample_interp &&
d7769 1
a7769 1
	if (shader->key.part.ps.prolog.force_linear_sample_interp &&
d7776 1
a7776 1
	if (shader->key.part.ps.prolog.force_persp_center_interp &&
d7783 1
a7783 1
	if (shader->key.part.ps.prolog.force_linear_center_interp &&
d7807 1
a7807 1
	if (!shader->key.part.ps.epilog.poly_line_smoothing &&
d7846 1
a7846 1
	struct si_shader *mainp = *si_get_main_shader_part(sel, &shader->key);
a7850 3
	 *
	 * Vertex shaders are compiled on demand when a vertex fetch
	 * workaround must be applied.
d7852 9
a7860 1
	if (shader->is_monolithic) {
a7906 4
		case PIPE_SHADER_GEOMETRY:
			if (!si_shader_select_gs_parts(sscreen, tm, shader, debug))
				return -1;
			break;
d7936 1
a7936 1
		       stderr, true);
d7950 5
@


