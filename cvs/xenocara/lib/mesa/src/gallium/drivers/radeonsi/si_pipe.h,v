head	1.2;
access;
symbols
	mesa-17_1_6:1.1.1.5
	OPENBSD_6_1:1.1.1.4.0.2
	OPENBSD_6_1_BASE:1.1.1.4
	mesa-13_0_6:1.1.1.4
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.26;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.44.33;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.33;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.20.12;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.28.21;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.03.25.00.07.55;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	YgkKuQ9hssScckR1;

1.1.1.5
date	2017.08.14.09.33.05;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Copyright 2010 Jerome Glisse <glisse@@freedesktop.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *      Jerome Glisse
 */
#ifndef SI_PIPE_H
#define SI_PIPE_H

#include "si_shader.h"

#ifdef PIPE_ARCH_BIG_ENDIAN
#define SI_BIG_ENDIAN 1
#else
#define SI_BIG_ENDIAN 0
#endif

/* The base vertex and primitive restart can be any number, but we must pick
 * one which will mean "unknown" for the purpose of state tracking and
 * the number shouldn't be a commonly-used one. */
#define SI_BASE_VERTEX_UNKNOWN INT_MIN
#define SI_RESTART_INDEX_UNKNOWN INT_MIN
#define SI_NUM_SMOOTH_AA_SAMPLES 8
#define SI_GS_PER_ES 128

/* Instruction cache. */
#define SI_CONTEXT_INV_ICACHE		(R600_CONTEXT_PRIVATE_FLAG << 0)
/* SMEM L1, other names: KCACHE, constant cache, DCACHE, data cache */
#define SI_CONTEXT_INV_SMEM_L1		(R600_CONTEXT_PRIVATE_FLAG << 1)
/* VMEM L1 can optionally be bypassed (GLC=1). Other names: TC L1 */
#define SI_CONTEXT_INV_VMEM_L1		(R600_CONTEXT_PRIVATE_FLAG << 2)
/* Used by everything except CB/DB, can be bypassed (SLC=1). Other names: TC L2 */
#define SI_CONTEXT_INV_GLOBAL_L2	(R600_CONTEXT_PRIVATE_FLAG << 3)
/* Write dirty L2 lines back to memory (shader and CP DMA stores), but don't
 * invalidate L2. SI-CIK can't do it, so they will do complete invalidation. */
#define SI_CONTEXT_WRITEBACK_GLOBAL_L2	(R600_CONTEXT_PRIVATE_FLAG << 4)
/* Framebuffer caches. */
#define SI_CONTEXT_FLUSH_AND_INV_CB_META (R600_CONTEXT_PRIVATE_FLAG << 5)
#define SI_CONTEXT_FLUSH_AND_INV_DB_META (R600_CONTEXT_PRIVATE_FLAG << 6)
#define SI_CONTEXT_FLUSH_AND_INV_DB	(R600_CONTEXT_PRIVATE_FLAG << 7)
#define SI_CONTEXT_FLUSH_AND_INV_CB	(R600_CONTEXT_PRIVATE_FLAG << 8)
/* Engine synchronization. */
#define SI_CONTEXT_VS_PARTIAL_FLUSH	(R600_CONTEXT_PRIVATE_FLAG << 9)
#define SI_CONTEXT_PS_PARTIAL_FLUSH	(R600_CONTEXT_PRIVATE_FLAG << 10)
#define SI_CONTEXT_CS_PARTIAL_FLUSH	(R600_CONTEXT_PRIVATE_FLAG << 11)
#define SI_CONTEXT_VGT_FLUSH		(R600_CONTEXT_PRIVATE_FLAG << 12)
#define SI_CONTEXT_VGT_STREAMOUT_SYNC	(R600_CONTEXT_PRIVATE_FLAG << 13)

#define SI_CONTEXT_FLUSH_AND_INV_FRAMEBUFFER (SI_CONTEXT_FLUSH_AND_INV_CB | \
					      SI_CONTEXT_FLUSH_AND_INV_CB_META | \
					      SI_CONTEXT_FLUSH_AND_INV_DB | \
					      SI_CONTEXT_FLUSH_AND_INV_DB_META)

#define SI_ENCODE_TRACE_POINT(id)	(0xcafe0000 | ((id) & 0xffff))
#define SI_IS_TRACE_POINT(x)		(((x) & 0xcafe0000) == 0xcafe0000)
#define SI_GET_TRACE_POINT_ID(x)	((x) & 0xffff)

#define SI_MAX_BORDER_COLORS	4096

struct si_compute;
struct hash_table;
struct u_suballocator;

struct si_screen {
	struct r600_common_screen	b;
	unsigned			gs_table_depth;
	unsigned			tess_offchip_block_dw_size;
	bool				has_distributed_tess;
	bool				has_draw_indirect_multi;
	bool				has_ds_bpermute;

	/* Whether shaders are monolithic (1-part) or separate (3-part). */
	bool				use_monolithic_shaders;
	bool				record_llvm_ir;

	pipe_mutex			shader_parts_mutex;
	struct si_shader_part		*vs_prologs;
	struct si_shader_part		*vs_epilogs;
	struct si_shader_part		*tcs_epilogs;
	struct si_shader_part		*ps_prologs;
	struct si_shader_part		*ps_epilogs;

	/* Shader cache in memory.
	 *
	 * Design & limitations:
	 * - The shader cache is per screen (= per process), never saved to
	 *   disk, and skips redundant shader compilations from TGSI to bytecode.
	 * - It can only be used with one-variant-per-shader support, in which
	 *   case only the main (typically middle) part of shaders is cached.
	 * - Only VS, TCS, TES, PS are cached, out of which only the hw VS
	 *   variants of VS and TES are cached, so LS and ES aren't.
	 * - GS and CS aren't cached, but it's certainly possible to cache
	 *   those as well.
	 */
	pipe_mutex			shader_cache_mutex;
	struct hash_table		*shader_cache;

	/* Shader compiler queue for multithreaded compilation. */
	struct util_queue		shader_compiler_queue;
	LLVMTargetMachineRef		tm[4]; /* used by the queue only */
};

struct si_blend_color {
	struct r600_atom		atom;
	struct pipe_blend_color		state;
};

struct si_sampler_view {
	struct pipe_sampler_view	base;
        /* [0..7] = image descriptor
         * [4..7] = buffer descriptor */
	uint32_t			state[8];
	uint32_t			fmask_state[8];
	const struct radeon_surf_level	*base_level_info;
	unsigned			base_level;
	unsigned			block_width;
	bool is_stencil_sampler;
};

struct si_sampler_state {
	uint32_t			val[4];
};

struct si_cs_shader_state {
	struct si_compute		*program;
	struct si_compute		*emitted_program;
	unsigned			offset;
	bool				initialized;
	bool				uses_scratch;
};

struct si_textures_info {
	struct si_sampler_views		views;
	uint32_t			depth_texture_mask; /* which textures are depth */
	uint32_t			compressed_colortex_mask;
};

struct si_images_info {
	struct pipe_image_view		views[SI_NUM_IMAGES];
	uint32_t			compressed_colortex_mask;
	unsigned			enabled_mask;
};

struct si_framebuffer {
	struct r600_atom		atom;
	struct pipe_framebuffer_state	state;
	unsigned			nr_samples;
	unsigned			log_samples;
	unsigned			compressed_cb_mask;
	unsigned			spi_shader_col_format;
	unsigned			spi_shader_col_format_alpha;
	unsigned			spi_shader_col_format_blend;
	unsigned			spi_shader_col_format_blend_alpha;
	unsigned			color_is_int8;
	unsigned			color_is_int10;
	unsigned			dirty_cbufs;
	bool				dirty_zsbuf;
	bool				any_dst_linear;
};

struct si_clip_state {
	struct r600_atom		atom;
	struct pipe_clip_state		state;
};

struct si_sample_locs {
	struct r600_atom	atom;
	unsigned		nr_samples;
};

struct si_sample_mask {
	struct r600_atom	atom;
	uint16_t		sample_mask;
};

/* A shader state consists of the shader selector, which is a constant state
 * object shared by multiple contexts and shouldn't be modified, and
 * the current shader variant selected for this context.
 */
struct si_shader_ctx_state {
	struct si_shader_selector	*cso;
	struct si_shader		*current;
};

struct si_context {
	struct r600_common_context	b;
	struct blitter_context		*blitter;
	void				*custom_dsa_flush;
	void				*custom_blend_resolve;
	void				*custom_blend_decompress;
	void				*custom_blend_fastclear;
	void				*custom_blend_dcc_decompress;
	struct si_screen		*screen;

	struct radeon_winsys_cs		*ce_ib;
	struct radeon_winsys_cs		*ce_preamble_ib;
	bool				ce_need_synchronization;
	struct u_suballocator		*ce_suballocator;

	struct si_shader_ctx_state	fixed_func_tcs_shader;
	LLVMTargetMachineRef		tm; /* only non-threaded compilation */
	bool				gfx_flush_in_progress;
	bool				compute_is_busy;

	/* Atoms (direct states). */
	union si_state_atoms		atoms;
	unsigned			dirty_atoms; /* mask */
	/* PM4 states (precomputed immutable states) */
	union si_state			queued;
	union si_state			emitted;

	/* Atom declarations. */
	struct si_framebuffer		framebuffer;
	struct si_sample_locs		msaa_sample_locs;
	struct r600_atom		db_render_state;
	struct r600_atom		msaa_config;
	struct si_sample_mask		sample_mask;
	struct r600_atom		cb_render_state;
	struct si_blend_color		blend_color;
	struct r600_atom		clip_regs;
	struct si_clip_state		clip_state;
	struct si_shader_data		shader_userdata;
	struct si_stencil_ref		stencil_ref;
	struct r600_atom		spi_map;

	/* Precomputed states. */
	struct si_pm4_state		*init_config;
	struct si_pm4_state		*init_config_gs_rings;
	bool				init_config_has_vgt_flush;
	struct si_pm4_state		*vgt_shader_config[4];

	/* shaders */
	struct si_shader_ctx_state	ps_shader;
	struct si_shader_ctx_state	gs_shader;
	struct si_shader_ctx_state	vs_shader;
	struct si_shader_ctx_state	tcs_shader;
	struct si_shader_ctx_state	tes_shader;
	struct si_cs_shader_state	cs_shader_state;

	/* shader information */
	struct si_vertex_element	*vertex_elements;
	unsigned			sprite_coord_enable;
	bool				flatshade;
	bool				do_update_shaders;

	/* shader descriptors */
	struct si_descriptors		vertex_buffers;
	struct si_descriptors		descriptors[SI_NUM_DESCS];
	unsigned			descriptors_dirty;
	struct si_buffer_resources	rw_buffers;
	struct si_buffer_resources	const_buffers[SI_NUM_SHADERS];
	struct si_buffer_resources	shader_buffers[SI_NUM_SHADERS];
	struct si_textures_info		samplers[SI_NUM_SHADERS];
	struct si_images_info		images[SI_NUM_SHADERS];

	/* other shader resources */
	struct pipe_constant_buffer	null_const_buf; /* used for set_constant_buffer(NULL) on CIK */
	struct pipe_resource		*esgs_ring;
	struct pipe_resource		*gsvs_ring;
	struct pipe_resource		*tf_ring;
	struct pipe_resource		*tess_offchip_ring;
	union pipe_color_union		*border_color_table; /* in CPU memory, any endian */
	struct r600_resource		*border_color_buffer;
	union pipe_color_union		*border_color_map; /* in VRAM (slow access), little endian */
	unsigned			border_color_count;

	/* Vertex and index buffers. */
	bool				vertex_buffers_dirty;
	struct pipe_index_buffer	index_buffer;
	struct pipe_vertex_buffer	vertex_buffer[SI_NUM_VERTEX_BUFFERS];

	/* MSAA config state. */
	int				ps_iter_samples;
	bool				smoothing_enabled;

	/* DB render state. */
	bool			dbcb_depth_copy_enabled;
	bool			dbcb_stencil_copy_enabled;
	unsigned		dbcb_copy_sample;
	bool			db_flush_depth_inplace;
	bool			db_flush_stencil_inplace;
	bool			db_depth_clear;
	bool			db_depth_disable_expclear;
	bool			db_stencil_clear;
	bool			db_stencil_disable_expclear;
	unsigned		ps_db_shader_control;
	bool			occlusion_queries_disabled;

	/* Emitted draw state. */
	int			last_index_size;
	int			last_base_vertex;
	int			last_start_instance;
	int			last_drawid;
	int			last_sh_base_reg;
	int			last_primitive_restart_en;
	int			last_restart_index;
	int			last_gs_out_prim;
	int			last_prim;
	int			last_multi_vgt_param;
	int			last_rast_prim;
	unsigned		last_sc_line_stipple;
	int			last_vtx_reuse_depth;
	int			current_rast_prim; /* primitive type after TES, GS */
	unsigned		last_gsvs_itemsize;

	/* Scratch buffer */
	struct r600_resource	*scratch_buffer;
	bool			emit_scratch_reloc;
	unsigned		scratch_waves;
	unsigned		spi_tmpring_size;

	struct r600_resource	*compute_scratch_buffer;

	/* Emitted derived tessellation state. */
	struct si_shader	*last_ls; /* local shader (VS) */
	struct si_shader_selector *last_tcs;
	int			last_num_tcs_input_cp;
	int			last_tes_sh_base;

	/* Debug state. */
	bool			is_debug;
	struct radeon_saved_cs	last_gfx;
	struct r600_resource	*last_trace_buf;
	struct r600_resource	*trace_buf;
	unsigned		trace_id;
	uint64_t		dmesg_timestamp;
	unsigned		apitrace_call_number;

	/* Other state */
	bool need_check_render_feedback;
};

/* cik_sdma.c */
void cik_init_sdma_functions(struct si_context *sctx);

/* si_blit.c */
void si_init_blit_functions(struct si_context *sctx);
void si_decompress_graphics_textures(struct si_context *sctx);
void si_decompress_compute_textures(struct si_context *sctx);
void si_resource_copy_region(struct pipe_context *ctx,
			     struct pipe_resource *dst,
			     unsigned dst_level,
			     unsigned dstx, unsigned dsty, unsigned dstz,
			     struct pipe_resource *src,
			     unsigned src_level,
			     const struct pipe_box *src_box);

/* si_cp_dma.c */
void si_copy_buffer(struct si_context *sctx,
		    struct pipe_resource *dst, struct pipe_resource *src,
		    uint64_t dst_offset, uint64_t src_offset, unsigned size);
void si_init_cp_dma_functions(struct si_context *sctx);

/* si_debug.c */
void si_init_debug_functions(struct si_context *sctx);
void si_check_vm_faults(struct r600_common_context *ctx,
			struct radeon_saved_cs *saved, enum ring_type ring);
bool si_replace_shader(unsigned num, struct radeon_shader_binary *binary);

/* si_dma.c */
void si_init_dma_functions(struct si_context *sctx);

/* si_hw_context.c */
void si_context_gfx_flush(void *context, unsigned flags,
			  struct pipe_fence_handle **fence);
void si_begin_new_cs(struct si_context *ctx);
void si_need_cs_space(struct si_context *ctx);

/* si_compute.c */
void si_init_compute_functions(struct si_context *sctx);

/* si_perfcounters.c */
void si_init_perfcounters(struct si_screen *screen);

/* si_uvd.c */
struct pipe_video_codec *si_uvd_create_decoder(struct pipe_context *context,
					       const struct pipe_video_codec *templ);

struct pipe_video_buffer *si_video_buffer_create(struct pipe_context *pipe,
						 const struct pipe_video_buffer *tmpl);

/*
 * common helpers
 */

static inline struct r600_resource *
si_resource_create_custom(struct pipe_screen *screen,
			  unsigned usage, unsigned size)
{
	assert(size);
	return r600_resource(pipe_buffer_create(screen,
		PIPE_BIND_CUSTOM, usage, size));
}

static inline void
si_invalidate_draw_sh_constants(struct si_context *sctx)
{
	sctx->last_base_vertex = SI_BASE_VERTEX_UNKNOWN;
}

static inline void
si_set_atom_dirty(struct si_context *sctx,
		  struct r600_atom *atom, bool dirty)
{
	unsigned bit = 1 << (atom->id - 1);

	if (dirty)
		sctx->dirty_atoms |= bit;
	else
		sctx->dirty_atoms &= ~bit;
}

static inline bool
si_is_atom_dirty(struct si_context *sctx,
		  struct r600_atom *atom)
{
	unsigned bit = 1 << (atom->id - 1);

	return sctx->dirty_atoms & bit;
}

static inline void
si_mark_atom_dirty(struct si_context *sctx,
		   struct r600_atom *atom)
{
	si_set_atom_dirty(sctx, atom, true);
}

static inline struct tgsi_shader_info *si_get_vs_info(struct si_context *sctx)
{
	if (sctx->gs_shader.cso)
		return &sctx->gs_shader.cso->info;
	else if (sctx->tes_shader.cso)
		return &sctx->tes_shader.cso->info;
	else if (sctx->vs_shader.cso)
		return &sctx->vs_shader.cso->info;
	else
		return NULL;
}

static inline struct si_shader* si_get_vs_state(struct si_context *sctx)
{
	if (sctx->gs_shader.current)
		return sctx->gs_shader.current->gs_copy_shader;
	else if (sctx->tes_shader.current)
		return sctx->tes_shader.current;
	else
		return sctx->vs_shader.current;
}

static inline bool si_vs_exports_prim_id(struct si_shader *shader)
{
	if (shader->selector->type == PIPE_SHADER_VERTEX)
		return shader->key.vs.epilog.export_prim_id;
	else if (shader->selector->type == PIPE_SHADER_TESS_EVAL)
		return shader->key.tes.epilog.export_prim_id;
	else
		return false;
}

#endif
@


1.1
log
@Initial revision
@
text
@d29 1
a29 3
#include "si_state.h"

#include <llvm-c/TargetMachine.h>
d43 1
a43 8

#define SI_TRACE_CS 0
#define SI_TRACE_CS_DWORDS		6

#define SI_MAX_DRAW_CS_DWORDS \
	(/*scratch:*/ 3 + /*derived prim state:*/ 3 + \
	 /*draw regs:*/ 18 + /*draw packets:*/ 31 +\
	 /*derived tess state:*/ 19)
d47 9
a55 9
/* Cache used by scalar memory (SMEM) instructions. They also use TC
 * as a second level cache, which isn't flushed by this.
 * Other names: constant cache, data cache, DCACHE */
#define SI_CONTEXT_INV_KCACHE		(R600_CONTEXT_PRIVATE_FLAG << 1)
/* Caches used by vector memory (VMEM) instructions.
 * L1 can optionally be bypassed (GLC=1) and can only be used by shaders.
 * L2 is used by shaders and can be used by other blocks (CP, sDMA). */
#define SI_CONTEXT_INV_TC_L1		(R600_CONTEXT_PRIVATE_FLAG << 2)
#define SI_CONTEXT_INV_TC_L2		(R600_CONTEXT_PRIVATE_FLAG << 3)
d57 4
a60 4
#define SI_CONTEXT_FLUSH_AND_INV_CB_META (R600_CONTEXT_PRIVATE_FLAG << 4)
#define SI_CONTEXT_FLUSH_AND_INV_DB_META (R600_CONTEXT_PRIVATE_FLAG << 5)
#define SI_CONTEXT_FLUSH_AND_INV_DB	(R600_CONTEXT_PRIVATE_FLAG << 6)
#define SI_CONTEXT_FLUSH_AND_INV_CB	(R600_CONTEXT_PRIVATE_FLAG << 7)
d62 5
a66 8
#define SI_CONTEXT_VS_PARTIAL_FLUSH	(R600_CONTEXT_PRIVATE_FLAG << 8)
#define SI_CONTEXT_PS_PARTIAL_FLUSH	(R600_CONTEXT_PRIVATE_FLAG << 9)
#define SI_CONTEXT_CS_PARTIAL_FLUSH	(R600_CONTEXT_PRIVATE_FLAG << 10)
#define SI_CONTEXT_VGT_FLUSH		(R600_CONTEXT_PRIVATE_FLAG << 11)
#define SI_CONTEXT_VGT_STREAMOUT_SYNC	(R600_CONTEXT_PRIVATE_FLAG << 12)
/* Compute only. */
#define SI_CONTEXT_FLUSH_WITH_INV_L2	(R600_CONTEXT_PRIVATE_FLAG << 13) /* TODO: merge with TC? */
#define SI_CONTEXT_FLAG_COMPUTE		(R600_CONTEXT_PRIVATE_FLAG << 14)
d73 6
d80 2
d85 40
a128 2
	struct list_head		list;
	struct r600_resource		*resource;
d133 4
a140 1
	uint32_t			border_color[4];
d145 4
a152 1
	struct si_sampler_states	states;
d157 6
a167 1
	unsigned			cb0_is_integer;
d169 24
a192 1
	unsigned			export_16bpc;
d195 8
a202 1
#define SI_NUM_ATOMS(sctx) (sizeof((sctx)->atoms)/sizeof((sctx)->atoms.array[0]))
d211 1
a211 1
	void				*pstipple_sampler_state;
a212 3
	struct si_pm4_state		*init_config;
	struct pipe_fence_handle	*last_gfx_fence;
	struct si_shader_selector	*fixed_func_tcs_shader;
d214 16
a229 15
	union {
		struct {
			/* The order matters. */
			struct r600_atom *cache_flush;
			struct r600_atom *streamout_begin;
			struct r600_atom *streamout_enable; /* must be after streamout_begin */
			struct r600_atom *framebuffer;
			struct r600_atom *msaa_sample_locs;
			struct r600_atom *db_render_state;
			struct r600_atom *msaa_config;
			struct r600_atom *clip_regs;
			struct r600_atom *shader_userdata;
		} s;
		struct r600_atom *array[0];
	} atoms;
d231 1
d233 18
a250 3
	struct si_vertex_element	*vertex_elements;
	/* for saving when using blitter */
	struct pipe_stencil_ref		stencil_ref;
d252 5
a256 5
	struct si_shader_selector	*ps_shader;
	struct si_shader_selector	*gs_shader;
	struct si_shader_selector	*vs_shader;
	struct si_shader_selector	*tcs_shader;
	struct si_shader_selector	*tes_shader;
d258 1
a258 1
	struct si_shader_data		shader_userdata;
d260 1
d263 3
d267 3
d271 1
a271 1
	struct si_buffer_resources	rw_buffers[SI_NUM_SHADERS];
d273 17
a289 3
	struct r600_resource		*scratch_buffer;
	struct r600_resource		*border_color_table;
	unsigned			border_color_offset;
d291 1
a291 3
	struct r600_atom		clip_regs;
	struct r600_atom		msaa_sample_locs;
	struct r600_atom		msaa_config;
a294 25
	/* Vertex and index buffers. */
	bool			vertex_buffers_dirty;
	struct pipe_index_buffer index_buffer;
	struct pipe_vertex_buffer vertex_buffer[SI_NUM_VERTEX_BUFFERS];

	/* With rasterizer discard, there doesn't have to be a pixel shader.
	 * In that case, we bind this one: */
	void			*dummy_pixel_shader;
	struct r600_atom	cache_flush;
	struct pipe_constant_buffer null_const_buf; /* used for set_constant_buffer(NULL) on CIK */

	/* VGT states. */
	struct si_pm4_state	*vgt_shader_config[4];
	struct si_pm4_state	*gs_rings;
	struct pipe_resource	*esgs_ring;
	struct pipe_resource	*gsvs_ring;
	struct si_pm4_state	*tf_state;
	struct pipe_resource	*tf_ring;

	LLVMTargetMachineRef		tm;

	/* SI state handling */
	union si_state	queued;
	union si_state	emitted;

a295 1
	struct r600_atom	db_render_state;
d299 2
a300 1
	bool			db_inplace_flush_enabled;
d303 2
d306 1
d309 1
d312 1
a318 1
	int			last_ls_hs_config;
d321 1
d323 1
d326 2
a327 1
	boolean                 emit_scratch_reloc;
d331 2
d338 12
d353 1
a353 7
void cik_sdma_copy(struct pipe_context *ctx,
		   struct pipe_resource *dst,
		   unsigned dst_level,
		   unsigned dstx, unsigned dsty, unsigned dstz,
		   struct pipe_resource *src,
		   unsigned src_level,
		   const struct pipe_box *src_box);
d357 2
a358 4
void si_flush_depth_textures(struct si_context *sctx,
			     struct si_textures_info *textures);
void si_decompress_color_textures(struct si_context *sctx,
				  struct si_textures_info *textures);
d370 1
a370 2
		    uint64_t dst_offset, uint64_t src_offset, unsigned size,
		    bool is_framebuffer);
d373 6
d380 1
a380 7
void si_dma_copy(struct pipe_context *ctx,
		 struct pipe_resource *dst,
		 unsigned dst_level,
		 unsigned dstx, unsigned dsty, unsigned dstz,
		 struct pipe_resource *src,
		 unsigned src_level,
		 const struct pipe_box *src_box);
d386 1
a386 5
void si_need_cs_space(struct si_context *ctx, unsigned num_dw, boolean count_draw_in);

#if SI_TRACE_CS
void si_trace_emit(struct si_context *sctx);
#endif
d391 3
a417 2
	sctx->last_start_instance = -1; /* reset to an unknown value */
	sctx->last_sh_base_reg = -1; /* reset to an unknown value */
d424 15
a438 1
	atom->dirty = dirty;
d446 32
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d45 8
a52 1
#define SI_GS_PER_ES 128
d56 9
a64 6
/* SMEM L1, other names: KCACHE, constant cache, DCACHE, data cache */
#define SI_CONTEXT_INV_SMEM_L1		(R600_CONTEXT_PRIVATE_FLAG << 1)
/* VMEM L1 can optionally be bypassed (GLC=1). Other names: TC L1 */
#define SI_CONTEXT_INV_VMEM_L1		(R600_CONTEXT_PRIVATE_FLAG << 2)
/* Used by everything except CB/DB, can be bypassed (SLC=1). Other names: TC L2 */
#define SI_CONTEXT_INV_GLOBAL_L2	(R600_CONTEXT_PRIVATE_FLAG << 3)
a84 7
#define SI_ENCODE_TRACE_POINT(id)	(0xcafe0000 | ((id) & 0xffff))
#define SI_IS_TRACE_POINT(x)		(((x) & 0xcafe0000) == 0xcafe0000)
#define SI_GET_TRACE_POINT_ID(x)	((x) & 0xffff)

#define SI_MAX_VIEWPORTS	16
#define SI_MAX_BORDER_COLORS	4096

a85 1
struct hash_table;
a88 31
	unsigned			gs_table_depth;

	/* Whether shaders are monolithic (1-part) or separate (3-part). */
	bool				use_monolithic_shaders;

	pipe_mutex			shader_parts_mutex;
	struct si_shader_part		*vs_prologs;
	struct si_shader_part		*vs_epilogs;
	struct si_shader_part		*tcs_epilogs;
	struct si_shader_part		*ps_prologs;
	struct si_shader_part		*ps_epilogs;

	/* Shader cache in memory.
	 *
	 * Design & limitations:
	 * - The shader cache is per screen (= per process), never saved to
	 *   disk, and skips redundant shader compilations from TGSI to bytecode.
	 * - It can only be used with one-variant-per-shader support, in which
	 *   case only the main (typically middle) part of shaders is cached.
	 * - Only VS, TCS, TES, PS are cached, out of which only the hw VS
	 *   variants of VS and TES are cached, so LS and ES aren't.
	 * - GS and CS aren't cached, but it's certainly possible to cache
	 *   those as well.
	 */
	pipe_mutex			shader_cache_mutex;
	struct hash_table		*shader_cache;
};

struct si_blend_color {
	struct r600_atom		atom;
	struct pipe_blend_color		state;
a94 1
	struct r600_resource		*dcc_buffer;
a98 1
	bool is_stencil_sampler;
d103 1
d112 1
d124 1
a124 12
	unsigned			spi_shader_col_format;
	unsigned			spi_shader_col_format_alpha;
	unsigned			spi_shader_col_format_blend;
	unsigned			spi_shader_col_format_blend_alpha;
	unsigned			color_is_int8; /* bitmask */
	unsigned			dirty_cbufs;
	bool				dirty_zsbuf;
};

struct si_clip_state {
	struct r600_atom		atom;
	struct pipe_clip_state		state;
d127 1
a127 25
struct si_sample_mask {
	struct r600_atom	atom;
	uint16_t		sample_mask;
};

struct si_scissors {
	struct r600_atom		atom;
	unsigned			dirty_mask;
	struct pipe_scissor_state	states[SI_MAX_VIEWPORTS];
};

struct si_viewports {
	struct r600_atom		atom;
	unsigned			dirty_mask;
	struct pipe_viewport_state	states[SI_MAX_VIEWPORTS];
};

/* A shader state consists of the shader selector, which is a constant state
 * object shared by multiple contexts and shouldn't be modified, and
 * the current shader variant selected for this context.
 */
struct si_shader_ctx_state {
	struct si_shader_selector	*cso;
	struct si_shader		*current;
};
d138 1
d140 1
a140 3
	struct si_shader_ctx_state	fixed_func_tcs_shader;
	LLVMTargetMachineRef		tm;
	bool				gfx_flush_in_progress;
d142 15
a156 6
	/* Atoms (direct states). */
	union si_state_atoms		atoms;
	unsigned			dirty_atoms; /* mask */
	/* PM4 states (precomputed immutable states) */
	union si_state			queued;
	union si_state			emitted;
a157 2
	/* Atom declarations. */
	struct r600_atom		cache_flush;
d159 3
a161 20
	struct r600_atom		msaa_sample_locs;
	struct r600_atom		db_render_state;
	struct r600_atom		msaa_config;
	struct si_sample_mask		sample_mask;
	struct r600_atom		cb_render_state;
	struct si_blend_color		blend_color;
	struct r600_atom		clip_regs;
	struct si_clip_state		clip_state;
	struct si_shader_data		shader_userdata;
	struct si_scissors		scissors;
	struct si_viewports		viewports;
	struct si_stencil_ref		stencil_ref;
	struct r600_atom		spi_map;

	/* Precomputed states. */
	struct si_pm4_state		*init_config;
	struct si_pm4_state		*init_config_gs_rings;
	bool				init_config_has_vgt_flush;
	struct si_pm4_state		*vgt_shader_config[4];

d163 5
a167 5
	struct si_shader_ctx_state	ps_shader;
	struct si_shader_ctx_state	gs_shader;
	struct si_shader_ctx_state	vs_shader;
	struct si_shader_ctx_state	tcs_shader;
	struct si_shader_ctx_state	tes_shader;
d169 1
a169 1

a170 1
	struct si_vertex_element	*vertex_elements;
a172 2

	/* shader descriptors */
d177 3
d181 5
a185 9
	/* other shader resources */
	struct pipe_constant_buffer	null_const_buf; /* used for set_constant_buffer(NULL) on CIK */
	struct pipe_resource		*esgs_ring;
	struct pipe_resource		*gsvs_ring;
	struct pipe_resource		*tf_ring;
	union pipe_color_union		*border_color_table; /* in CPU memory, any endian */
	struct r600_resource		*border_color_buffer;
	union pipe_color_union		*border_color_map; /* in VRAM (slow access), little endian */
	unsigned			border_color_count;
d188 17
a204 3
	bool				vertex_buffers_dirty;
	struct pipe_index_buffer	index_buffer;
	struct pipe_vertex_buffer	vertex_buffer[SI_NUM_VERTEX_BUFFERS];
d206 5
a210 3
	/* MSAA config state. */
	int				ps_iter_samples;
	bool				smoothing_enabled;
d213 1
d217 1
a217 2
	bool			db_flush_depth_inplace;
	bool			db_flush_stencil_inplace;
a219 2
	bool			db_stencil_clear;
	bool			db_stencil_disable_expclear;
a234 1
	unsigned		last_gsvs_itemsize;
a236 1
	struct r600_resource	*scratch_buffer;
a245 11

	/* Debug state. */
	bool			is_debug;
	uint32_t		*last_ib;
	unsigned		last_ib_dw_size;
	struct r600_resource	*last_trace_buf;
	struct r600_resource	*trace_buf;
	unsigned		trace_id;
	uint64_t		dmesg_timestamp;
	unsigned		last_bo_count;
	struct radeon_bo_list_item *last_bo_list;
a277 5
/* si_debug.c */
void si_init_debug_functions(struct si_context *sctx);
void si_check_vm_faults(struct si_context *sctx);
bool si_replace_shader(unsigned num, struct radeon_shader_binary *binary);

d291 5
a295 1
void si_need_cs_space(struct si_context *ctx);
a299 3
/* si_perfcounters.c */
void si_init_perfcounters(struct si_screen *screen);

d332 1
a332 6
	unsigned bit = 1 << (atom->id - 1);

	if (dirty)
		sctx->dirty_atoms |= bit;
	else
		sctx->dirty_atoms &= ~bit;
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d29 3
a31 1
#include "si_shader.h"
a54 3
/* Write dirty L2 lines back to memory (shader and CP DMA stores), but don't
 * invalidate L2. SI-CIK can't do it, so they will do complete invalidation. */
#define SI_CONTEXT_WRITEBACK_GLOBAL_L2	(R600_CONTEXT_PRIVATE_FLAG << 4)
d56 4
a59 4
#define SI_CONTEXT_FLUSH_AND_INV_CB_META (R600_CONTEXT_PRIVATE_FLAG << 5)
#define SI_CONTEXT_FLUSH_AND_INV_DB_META (R600_CONTEXT_PRIVATE_FLAG << 6)
#define SI_CONTEXT_FLUSH_AND_INV_DB	(R600_CONTEXT_PRIVATE_FLAG << 7)
#define SI_CONTEXT_FLUSH_AND_INV_CB	(R600_CONTEXT_PRIVATE_FLAG << 8)
d61 8
a68 5
#define SI_CONTEXT_VS_PARTIAL_FLUSH	(R600_CONTEXT_PRIVATE_FLAG << 9)
#define SI_CONTEXT_PS_PARTIAL_FLUSH	(R600_CONTEXT_PRIVATE_FLAG << 10)
#define SI_CONTEXT_CS_PARTIAL_FLUSH	(R600_CONTEXT_PRIVATE_FLAG << 11)
#define SI_CONTEXT_VGT_FLUSH		(R600_CONTEXT_PRIVATE_FLAG << 12)
#define SI_CONTEXT_VGT_STREAMOUT_SYNC	(R600_CONTEXT_PRIVATE_FLAG << 13)
d79 1
a83 1
struct u_suballocator;
a87 4
	unsigned			tess_offchip_block_dw_size;
	bool				has_distributed_tess;
	bool				has_draw_indirect_multi;
	bool				has_ds_bpermute;
a90 1
	bool				record_llvm_ir;
a112 4

	/* Shader compiler queue for multithreaded compilation. */
	struct util_queue		shader_compiler_queue;
	LLVMTargetMachineRef		tm[4]; /* used by the queue only */
d122 3
a128 3
	const struct radeon_surf_level	*base_level_info;
	unsigned			base_level;
	unsigned			block_width;
a137 4
	struct si_compute		*emitted_program;
	unsigned			offset;
	bool				initialized;
	bool				uses_scratch;
a145 6
struct si_images_info {
	struct pipe_image_view		views[SI_NUM_IMAGES];
	uint32_t			compressed_colortex_mask;
	unsigned			enabled_mask;
};

d151 1
a159 1
	bool				any_dst_linear;
d167 1
a167 1
struct si_sample_locs {
d169 7
a175 1
	unsigned		nr_samples;
d178 4
a181 3
struct si_sample_mask {
	struct r600_atom	atom;
	uint16_t		sample_mask;
d200 1
a200 1
	void				*custom_blend_dcc_decompress;
d202 1
a202 6

	struct radeon_winsys_cs		*ce_ib;
	struct radeon_winsys_cs		*ce_preamble_ib;
	bool				ce_need_synchronization;
	struct u_suballocator		*ce_suballocator;

d204 1
a204 1
	LLVMTargetMachineRef		tm; /* only non-threaded compilation */
a205 1
	bool				compute_is_busy;
d215 1
d217 1
a217 1
	struct si_sample_locs		msaa_sample_locs;
d226 2
a248 1
	bool				do_update_shaders;
a251 3
	struct si_descriptors		descriptors[SI_NUM_DESCS];
	unsigned			descriptors_dirty;
	struct si_buffer_resources	rw_buffers;
d253 1
a253 1
	struct si_buffer_resources	shader_buffers[SI_NUM_SHADERS];
a254 1
	struct si_images_info		images[SI_NUM_SHADERS];
a260 1
	struct pipe_resource		*tess_offchip_ring;
a285 1
	bool			occlusion_queries_disabled;
a287 1
	int			last_index_size;
a289 1
	int			last_drawid;
d296 1
a298 1
	int			last_vtx_reuse_depth;
d304 1
a304 1
	bool			emit_scratch_reloc;
a307 2
	struct r600_resource	*compute_scratch_buffer;

d316 2
a317 1
	struct radeon_saved_cs	last_gfx;
d322 2
a323 4
	unsigned		apitrace_call_number;

	/* Other state */
	bool need_check_render_feedback;
d327 7
a333 1
void cik_init_sdma_functions(struct si_context *sctx);
d337 4
a340 2
void si_decompress_graphics_textures(struct si_context *sctx);
void si_decompress_compute_textures(struct si_context *sctx);
d352 2
a353 1
		    uint64_t dst_offset, uint64_t src_offset, unsigned size);
d358 1
a358 2
void si_check_vm_faults(struct r600_common_context *ctx,
			struct radeon_saved_cs *saved, enum ring_type ring);
d362 7
a368 1
void si_init_dma_functions(struct si_context *sctx);
d406 2
a421 9
static inline bool
si_is_atom_dirty(struct si_context *sctx,
		  struct r600_atom *atom)
{
	unsigned bit = 1 << (atom->id - 1);

	return sctx->dirty_atoms & bit;
}

a426 32
}

static inline struct tgsi_shader_info *si_get_vs_info(struct si_context *sctx)
{
	if (sctx->gs_shader.cso)
		return &sctx->gs_shader.cso->info;
	else if (sctx->tes_shader.cso)
		return &sctx->tes_shader.cso->info;
	else if (sctx->vs_shader.cso)
		return &sctx->vs_shader.cso->info;
	else
		return NULL;
}

static inline struct si_shader* si_get_vs_state(struct si_context *sctx)
{
	if (sctx->gs_shader.current)
		return sctx->gs_shader.current->gs_copy_shader;
	else if (sctx->tes_shader.current)
		return sctx->tes_shader.current;
	else
		return sctx->vs_shader.current;
}

static inline bool si_vs_exports_prim_id(struct si_shader *shader)
{
	if (shader->selector->type == PIPE_SHADER_VERTEX)
		return shader->key.vs.epilog.export_prim_id;
	else if (shader->selector->type == PIPE_SHADER_TESS_EVAL)
		return shader->key.tes.epilog.export_prim_id;
	else
		return false;
@


1.1.1.4
log
@Import Mesa 13.0.6
@
text
@d173 1
a173 2
	unsigned			color_is_int8;
	unsigned			color_is_int10;
@


1.1.1.5
log
@Import Mesa 17.1.6
@
text
@a43 2
/* Alignment for optimal CP DMA performance. */
#define SI_CPDMA_ALIGNMENT	32
a55 1
/* gaps */
d57 2
d68 9
a89 1
	bool				has_msaa_sample_loc_bug;
d95 1
a95 1
	mtx_t			shader_parts_mutex;
a98 1
	struct si_shader_part		*gs_prologs;
d114 1
a114 1
	mtx_t			shader_cache_mutex;
d133 1
a133 1
	const struct legacy_surf_level	*base_level_info;
a136 1
	bool dcc_incompatible;
a138 2
#define SI_SAMPLER_STATE_MAGIC 0x34f1c35a

a139 3
#ifdef DEBUG
	unsigned			magic;
#endif
a168 1
	unsigned			colorbuf_enabled_4bit;
a177 1
	bool				do_update_surf_dirtiness;
a203 22
#define SI_NUM_VGT_PARAM_KEY_BITS 12
#define SI_NUM_VGT_PARAM_STATES (1 << SI_NUM_VGT_PARAM_KEY_BITS)

/* The IA_MULTI_VGT_PARAM key used to index the table of precomputed values.
 * Some fields are set by state-change calls, most are set by draw_vbo.
 */
union si_vgt_param_key {
	struct {
		unsigned prim:4;
		unsigned uses_instancing:1;
		unsigned multi_instances_smaller_than_primgroup:1;
		unsigned primitive_restart:1;
		unsigned count_from_stream_output:1;
		unsigned line_stipple_enabled:1;
		unsigned uses_tess:1;
		unsigned tcs_tes_uses_prim_id:1;
		unsigned uses_gs:1;
		unsigned _pad:32 - SI_NUM_VGT_PARAM_KEY_BITS;
	} u;
	uint32_t index;
};

a227 1
	unsigned			dirty_states;
a231 1
	struct r600_atom		prefetch_L2;
a237 1
	unsigned			last_cb_target_mask;
a268 2
	unsigned			shader_pointers_dirty;
	unsigned			compressed_tex_shader_mask;
a287 1
	bool				vertex_buffer_pointer_dirty;
d321 3
a323 4
	unsigned		current_vs_state;
	unsigned		last_vs_state;
	enum pipe_prim_type	current_rast_prim; /* primitive type after TES, GS */
	bool			gs_tri_strip_adj_fix;
a325 1
	struct r600_atom	scratch_state;
d327 1
a337 2
	bool			last_tess_uses_primid;
	unsigned		last_num_patches;
a349 4

	/* Precomputed IA_MULTI_VGT_PARAM */
	union si_vgt_param_key  ia_multi_vgt_param_key;
	unsigned		ia_multi_vgt_param[SI_NUM_VGT_PARAM_STATES];
a367 11
#define SI_CPDMA_SKIP_CHECK_CS_SPACE	(1 << 0) /* don't call need_cs_space */
#define SI_CPDMA_SKIP_SYNC_AFTER	(1 << 1) /* don't wait for DMA after the copy */
#define SI_CPDMA_SKIP_SYNC_BEFORE	(1 << 2) /* don't wait for DMA before the copy (RAW hazards) */
#define SI_CPDMA_SKIP_GFX_SYNC		(1 << 3) /* don't flush caches and don't wait for PS/CS */
#define SI_CPDMA_SKIP_BO_LIST_UPDATE	(1 << 4) /* don't update the BO list */
#define SI_CPDMA_SKIP_ALL (SI_CPDMA_SKIP_CHECK_CS_SPACE | \
			   SI_CPDMA_SKIP_SYNC_AFTER | \
			   SI_CPDMA_SKIP_SYNC_BEFORE | \
			   SI_CPDMA_SKIP_GFX_SYNC | \
			   SI_CPDMA_SKIP_BO_LIST_UPDATE)

d370 1
a370 4
		    uint64_t dst_offset, uint64_t src_offset, unsigned size,
		    unsigned user_flags);
void cik_prefetch_TC_L2_async(struct si_context *sctx, struct pipe_resource *buf,
			      uint64_t offset, unsigned size);
d377 1
a377 1
bool si_replace_shader(unsigned num, struct ac_shader_binary *binary);
d405 9
d424 1
a424 1
	unsigned bit = 1 << atom->id;
d436 1
a436 1
	unsigned bit = 1 << atom->id;
d463 1
a463 1
		return sctx->gs_shader.cso->gs_copy_shader;
d473 1
a473 1
		return shader->key.part.vs.epilog.export_prim_id;
d475 1
a475 1
		return shader->key.part.tes.epilog.export_prim_id;
a477 15
}

static inline unsigned
si_optimal_tcc_alignment(struct si_context *sctx, unsigned upload_size)
{
	unsigned alignment, tcc_cache_line_size;

	/* If the upload size is less than the cache line size (e.g. 16, 32),
	 * the whole thing will fit into a cache line if we align it to its size.
	 * The idea is that multiple small uploads can share a cache line.
	 * If the upload size is greater, align it to the cache line size.
	 */
	alignment = util_next_power_of_two(upload_size);
	tcc_cache_line_size = sctx->screen->b.info.tcc_cache_line_size;
	return MIN2(alignment, tcc_cache_line_size);
@


