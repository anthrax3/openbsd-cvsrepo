head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.44.31;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.31;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.20.10;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.28.21;	author jsg;	state Exp;
branches;
next	;
commitid	uuv5VTS15jglEDZU;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright 2010 Jerome Glisse <glisse@@freedesktop.org>
 * Copyright 2014,2015 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *      Jerome Glisse
 */

#include "sid.h"
#include "si_pipe.h"
#include "radeon/r600_cs.h"

#include "util/u_format.h"

static uint32_t cik_micro_tile_mode(struct si_screen *sscreen, unsigned tile_mode)
{
	if (sscreen->b.info.si_tile_mode_array_valid) {
		uint32_t gb_tile_mode = sscreen->b.info.si_tile_mode_array[tile_mode];

		return G_009910_MICRO_TILE_MODE_NEW(gb_tile_mode);
	}

	/* The kernel cannod return the tile mode array. Guess? */
	return V_009910_ADDR_SURF_THIN_MICRO_TILING;
}

static void cik_sdma_do_copy_buffer(struct si_context *ctx,
				    struct pipe_resource *dst,
				    struct pipe_resource *src,
				    uint64_t dst_offset,
				    uint64_t src_offset,
				    uint64_t size)
{
	struct radeon_winsys_cs *cs = ctx->b.rings.dma.cs;
	unsigned i, ncopy, csize;
	struct r600_resource *rdst = (struct r600_resource*)dst;
	struct r600_resource *rsrc = (struct r600_resource*)src;

	dst_offset += r600_resource(dst)->gpu_address;
	src_offset += r600_resource(src)->gpu_address;

	ncopy = (size + CIK_SDMA_COPY_MAX_SIZE - 1) / CIK_SDMA_COPY_MAX_SIZE;
	r600_need_dma_space(&ctx->b, ncopy * 7);

	r600_context_bo_reloc(&ctx->b, &ctx->b.rings.dma, rsrc, RADEON_USAGE_READ,
			      RADEON_PRIO_MIN);
	r600_context_bo_reloc(&ctx->b, &ctx->b.rings.dma, rdst, RADEON_USAGE_WRITE,
			      RADEON_PRIO_MIN);

	for (i = 0; i < ncopy; i++) {
		csize = size < CIK_SDMA_COPY_MAX_SIZE ? size : CIK_SDMA_COPY_MAX_SIZE;
		cs->buf[cs->cdw++] = CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY,
						     CIK_SDMA_COPY_SUB_OPCODE_LINEAR,
						     0);
		cs->buf[cs->cdw++] = csize;
		cs->buf[cs->cdw++] = 0; /* src/dst endian swap */
		cs->buf[cs->cdw++] = src_offset;
		cs->buf[cs->cdw++] = src_offset >> 32;
		cs->buf[cs->cdw++] = dst_offset;
		cs->buf[cs->cdw++] = dst_offset >> 32;
		dst_offset += csize;
		src_offset += csize;
		size -= csize;
	}
}

static void cik_sdma_copy_buffer(struct si_context *ctx,
				 struct pipe_resource *dst,
				 struct pipe_resource *src,
				 uint64_t dst_offset,
				 uint64_t src_offset,
				 uint64_t size)
{
	struct r600_resource *rdst = (struct r600_resource*)dst;

	/* Mark the buffer range of destination as valid (initialized),
	 * so that transfer_map knows it should wait for the GPU when mapping
	 * that range. */
	util_range_add(&rdst->valid_buffer_range, dst_offset,
		       dst_offset + size);

	cik_sdma_do_copy_buffer(ctx, dst, src, dst_offset, src_offset, size);
}

static void cik_sdma_copy_tile(struct si_context *ctx,
			       struct pipe_resource *dst,
			       unsigned dst_level,
			       struct pipe_resource *src,
			       unsigned src_level,
			       unsigned y,
			       unsigned copy_height,
			       unsigned y_align,
			       unsigned pitch,
			       unsigned bpe)
{
	struct radeon_winsys_cs *cs = ctx->b.rings.dma.cs;
	struct si_screen *sscreen = ctx->screen;
	struct r600_texture *rsrc = (struct r600_texture*)src;
	struct r600_texture *rdst = (struct r600_texture*)dst;
	struct r600_texture *rlinear, *rtiled;
	unsigned linear_lvl, tiled_lvl;
	unsigned array_mode, lbpe, pitch_tile_max, slice_tile_max, size;
	unsigned ncopy, height, cheight, detile, i, src_mode, dst_mode;
	unsigned sub_op, bank_h, bank_w, mt_aspect, nbanks, tile_split, mt;
	uint64_t base, addr;
	unsigned pipe_config, tile_mode_index;

	dst_mode = rdst->surface.level[dst_level].mode;
	src_mode = rsrc->surface.level[src_level].mode;
	/* downcast linear aligned to linear to simplify test */
	src_mode = src_mode == RADEON_SURF_MODE_LINEAR_ALIGNED ? RADEON_SURF_MODE_LINEAR : src_mode;
	dst_mode = dst_mode == RADEON_SURF_MODE_LINEAR_ALIGNED ? RADEON_SURF_MODE_LINEAR : dst_mode;
	assert(dst_mode != src_mode);
	assert(src_mode == RADEON_SURF_MODE_LINEAR || dst_mode == RADEON_SURF_MODE_LINEAR);

	sub_op = CIK_SDMA_COPY_SUB_OPCODE_TILED;
	lbpe = util_logbase2(bpe);
	pitch_tile_max = ((pitch / bpe) / 8) - 1;

	detile = dst_mode == RADEON_SURF_MODE_LINEAR;
	rlinear = detile ? rdst : rsrc;
	rtiled = detile ? rsrc : rdst;
	linear_lvl = detile ? dst_level : src_level;
	tiled_lvl = detile ? src_level : dst_level;

	assert(!util_format_is_depth_and_stencil(rtiled->resource.b.b.format));

	array_mode = si_array_mode(rtiled->surface.level[tiled_lvl].mode);
	slice_tile_max = (rtiled->surface.level[tiled_lvl].nblk_x *
			  rtiled->surface.level[tiled_lvl].nblk_y) / (8*8) - 1;
	height = rlinear->surface.level[linear_lvl].nblk_y;
	base = rtiled->surface.level[tiled_lvl].offset;
	addr = rlinear->surface.level[linear_lvl].offset;
	bank_h = cik_bank_wh(rtiled->surface.bankh);
	bank_w = cik_bank_wh(rtiled->surface.bankw);
	mt_aspect = cik_macro_tile_aspect(rtiled->surface.mtilea);
	tile_split = cik_tile_split(rtiled->surface.tile_split);
	tile_mode_index = si_tile_mode_index(rtiled, tiled_lvl, false);
	nbanks = si_num_banks(sscreen, rtiled);
	base += rtiled->resource.gpu_address;
	addr += rlinear->resource.gpu_address;

	pipe_config = cik_db_pipe_config(sscreen, tile_mode_index);
	mt = cik_micro_tile_mode(sscreen, tile_mode_index);

	size = (copy_height * pitch) / 4;
	cheight = copy_height;
	if (((cheight * pitch) / 4) > CIK_SDMA_COPY_MAX_SIZE) {
		cheight = (CIK_SDMA_COPY_MAX_SIZE * 4) / pitch;
		cheight &= ~(y_align - 1);
	}
	ncopy = (copy_height + cheight - 1) / cheight;
	r600_need_dma_space(&ctx->b, ncopy * 12);

	r600_context_bo_reloc(&ctx->b, &ctx->b.rings.dma, &rsrc->resource,
			      RADEON_USAGE_READ, RADEON_PRIO_MIN);
	r600_context_bo_reloc(&ctx->b, &ctx->b.rings.dma, &rdst->resource,
			      RADEON_USAGE_WRITE, RADEON_PRIO_MIN);

	copy_height = size * 4 / pitch;
	for (i = 0; i < ncopy; i++) {
		cheight = copy_height;
		if (((cheight * pitch) / 4) > CIK_SDMA_COPY_MAX_SIZE) {
			cheight = (CIK_SDMA_COPY_MAX_SIZE * 4) / pitch;
			cheight &= ~(y_align - 1);
		}
		size = (cheight * pitch) / 4;

		cs->buf[cs->cdw++] = CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY,
						     sub_op, detile << 15);
		cs->buf[cs->cdw++] = base;
		cs->buf[cs->cdw++] = base >> 32;
		cs->buf[cs->cdw++] = ((height - 1) << 16) | pitch_tile_max;
		cs->buf[cs->cdw++] = slice_tile_max;
		cs->buf[cs->cdw++] = (pipe_config << 26) | (mt_aspect << 24) |
			(nbanks << 21) | (bank_h << 18) | (bank_w << 15) |
			(tile_split << 11) | (mt << 8) | (array_mode << 3) |
			lbpe;
		cs->buf[cs->cdw++] = y << 16; /* | x */
		cs->buf[cs->cdw++] = 0; /* z */;
		cs->buf[cs->cdw++] = addr & 0xfffffffc;
		cs->buf[cs->cdw++] = addr >> 32;
		cs->buf[cs->cdw++] = (pitch / bpe) - 1;
		cs->buf[cs->cdw++] = size;

		copy_height -= cheight;
		y += cheight;
	}
}

void cik_sdma_copy(struct pipe_context *ctx,
		   struct pipe_resource *dst,
		   unsigned dst_level,
		   unsigned dstx, unsigned dsty, unsigned dstz,
		   struct pipe_resource *src,
		   unsigned src_level,
		   const struct pipe_box *src_box)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct r600_texture *rsrc = (struct r600_texture*)src;
	struct r600_texture *rdst = (struct r600_texture*)dst;
	unsigned dst_pitch, src_pitch, bpe, dst_mode, src_mode;
	unsigned src_w, dst_w;
	unsigned src_x, src_y;
	unsigned copy_height, y_align;
	unsigned dst_x = dstx, dst_y = dsty, dst_z = dstz;

	if (sctx->b.rings.dma.cs == NULL) {
		goto fallback;
	}

	if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
		cik_sdma_copy_buffer(sctx, dst, src, dst_x, src_box->x, src_box->width);
		return;
	}

	/* Before re-enabling this, please make sure you can hit all newly
	 * enabled paths in your testing, preferably with both piglit (in
	 * particular the streaming-texture-leak test) and real world apps
	 * (e.g. the UE4 Elemental demo).
	 */
	goto fallback;

	if (src->format != dst->format ||
	    rdst->surface.nsamples > 1 || rsrc->surface.nsamples > 1 ||
	    rdst->dirty_level_mask & (1 << dst_level)) {
		goto fallback;
	}

	if (rsrc->dirty_level_mask & (1 << src_level)) {
		if (rsrc->htile_buffer)
			goto fallback;

		ctx->flush_resource(ctx, src);
	}

	src_x = util_format_get_nblocksx(src->format, src_box->x);
	dst_x = util_format_get_nblocksx(src->format, dst_x);
	src_y = util_format_get_nblocksy(src->format, src_box->y);
	dst_y = util_format_get_nblocksy(src->format, dst_y);

	dst_pitch = rdst->surface.level[dst_level].pitch_bytes;
	src_pitch = rsrc->surface.level[src_level].pitch_bytes;
	src_w = rsrc->surface.level[src_level].npix_x;
	dst_w = rdst->surface.level[dst_level].npix_x;

	if (src_pitch != dst_pitch || src_box->x || dst_x || src_w != dst_w ||
	    src_box->width != src_w ||
	    rsrc->surface.level[src_level].nblk_y !=
	    rdst->surface.level[dst_level].nblk_y) {
		/* FIXME CIK can do partial blit */
		goto fallback;
	}

	bpe = rdst->surface.bpe;
	copy_height = src_box->height / rsrc->surface.blk_h;
	dst_mode = rdst->surface.level[dst_level].mode;
	src_mode = rsrc->surface.level[src_level].mode;
	/* downcast linear aligned to linear to simplify test */
	src_mode = src_mode == RADEON_SURF_MODE_LINEAR_ALIGNED ? RADEON_SURF_MODE_LINEAR : src_mode;
	dst_mode = dst_mode == RADEON_SURF_MODE_LINEAR_ALIGNED ? RADEON_SURF_MODE_LINEAR : dst_mode;

	/* Dimensions must be aligned to (macro)tiles */
	switch (src_mode == RADEON_SURF_MODE_LINEAR ? dst_mode : src_mode) {
	case RADEON_SURF_MODE_1D:
		if ((src_x % 8) || (src_y % 8) || (dst_x % 8) || (dst_y % 8) ||
		    (copy_height % 8))
			goto fallback;
		y_align = 8;
		break;
	case RADEON_SURF_MODE_2D: {
		unsigned mtilew, mtileh, num_banks;

			switch (si_num_banks(sctx->screen, rsrc)) {
			case V_02803C_ADDR_SURF_2_BANK:
			default:
				num_banks = 2;
				break;
			case V_02803C_ADDR_SURF_4_BANK:
				num_banks = 4;
				break;
			case V_02803C_ADDR_SURF_8_BANK:
				num_banks = 8;
				break;
			case V_02803C_ADDR_SURF_16_BANK:
				num_banks = 16;
				break;
			}

			mtilew = (8 * rsrc->surface.bankw *
				  sctx->screen->b.tiling_info.num_channels) *
				rsrc->surface.mtilea;
			assert(!(mtilew & (mtilew - 1)));
			mtileh = (8 * rsrc->surface.bankh * num_banks) /
				rsrc->surface.mtilea;
			assert(!(mtileh & (mtileh - 1)));

			if ((src_x & (mtilew - 1)) || (src_y & (mtileh - 1)) ||
			    (dst_x & (mtilew - 1)) || (dst_y & (mtileh - 1)) ||
			    (copy_height & (mtileh - 1)))
				goto fallback;

			y_align = mtileh;
			break;
	}
	default:
		y_align = 1;
	}

	if (src_mode == dst_mode) {
		uint64_t dst_offset, src_offset;
		unsigned src_h, dst_h;

		src_h = rsrc->surface.level[src_level].npix_y;
		dst_h = rdst->surface.level[dst_level].npix_y;

		if (src_box->depth > 1 &&
		    (src_y || dst_y || src_h != dst_h || src_box->height != src_h))
			goto fallback;

		/* simple dma blit would do NOTE code here assume :
		 *   dst_pitch == src_pitch
		 */
		src_offset= rsrc->surface.level[src_level].offset;
		src_offset += rsrc->surface.level[src_level].slice_size * src_box->z;
		src_offset += src_y * src_pitch + src_x * bpe;
		dst_offset = rdst->surface.level[dst_level].offset;
		dst_offset += rdst->surface.level[dst_level].slice_size * dst_z;
		dst_offset += dst_y * dst_pitch + dst_x * bpe;
		cik_sdma_do_copy_buffer(sctx, dst, src, dst_offset, src_offset,
					src_box->depth *
					rsrc->surface.level[src_level].slice_size);
	} else {
		if (dst_y != src_y || src_box->depth > 1 || src_box->z || dst_z)
			goto fallback;

		cik_sdma_copy_tile(sctx, dst, dst_level, src, src_level,
				   src_y, copy_height, y_align, dst_pitch, bpe);
	}
	return;

fallback:
	si_resource_copy_region(ctx, dst, dst_level, dstx, dsty, dstz,
				src, src_level, src_box);
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d53 1
a53 1
	struct radeon_winsys_cs *cs = ctx->b.dma.cs;
d64 4
a67 4
	radeon_add_to_buffer_list(&ctx->b, &ctx->b.dma, rsrc, RADEON_USAGE_READ,
			      RADEON_PRIO_SDMA_BUFFER);
	radeon_add_to_buffer_list(&ctx->b, &ctx->b.dma, rdst, RADEON_USAGE_WRITE,
			      RADEON_PRIO_SDMA_BUFFER);
d115 1
a115 1
	struct radeon_winsys_cs *cs = ctx->b.dma.cs;
d174 4
a177 4
	radeon_add_to_buffer_list(&ctx->b, &ctx->b.dma, &rsrc->resource,
			      RADEON_USAGE_READ, RADEON_PRIO_SDMA_TEXTURE);
	radeon_add_to_buffer_list(&ctx->b, &ctx->b.dma, &rdst->resource,
			      RADEON_USAGE_WRITE, RADEON_PRIO_SDMA_TEXTURE);
d199 1
a199 1
		cs->buf[cs->cdw++] = 0; /* z */
d227 1
a227 1
	if (sctx->b.dma.cs == NULL) {
d245 1
a245 2
	    (rdst->dirty_level_mask | rdst->stencil_dirty_level_mask) & (1 << dst_level) ||
	    rdst->dcc_buffer || rsrc->dcc_buffer) {
d310 1
a310 1
				  sctx->screen->b.info.num_tile_pipes) *
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d30 15
d61 7
a67 2
	ncopy = DIV_ROUND_UP(size, CIK_SDMA_COPY_MAX_SIZE);
	r600_need_dma_space(&ctx->b, ncopy * 7, rdst, rsrc);
d70 10
a79 10
		csize = MIN2(size, CIK_SDMA_COPY_MAX_SIZE);
		radeon_emit(cs, CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY,
						CIK_SDMA_COPY_SUB_OPCODE_LINEAR,
						0));
		radeon_emit(cs, csize);
		radeon_emit(cs, 0); /* src/dst endian swap */
		radeon_emit(cs, src_offset);
		radeon_emit(cs, src_offset >> 32);
		radeon_emit(cs, dst_offset);
		radeon_emit(cs, dst_offset >> 32);
a101 1
	r600_dma_emit_wait_idle(&ctx->b);
d104 10
a113 1
static unsigned minify_as_blocks(unsigned width, unsigned level, unsigned blk_w)
d115 2
a116 35
	width = u_minify(width, level);
	return DIV_ROUND_UP(width, blk_w);
}

static unsigned encode_tile_info(struct si_context *sctx,
				 struct r600_texture *tex, unsigned level,
				 bool set_bpp)
{
	struct radeon_info *info = &sctx->screen->b.info;
	unsigned tile_index = tex->surface.tiling_index[level];
	unsigned macro_tile_index = tex->surface.macro_tile_index;
	unsigned tile_mode = info->si_tile_mode_array[tile_index];
	unsigned macro_tile_mode = info->cik_macrotile_mode_array[macro_tile_index];

	return (set_bpp ? util_logbase2(tex->surface.bpe) : 0) |
		(G_009910_ARRAY_MODE(tile_mode) << 3) |
		(G_009910_MICRO_TILE_MODE_NEW(tile_mode) << 8) |
		/* Non-depth modes don't have TILE_SPLIT set. */
		((util_logbase2(tex->surface.tile_split >> 6)) << 11) |
		(G_009990_BANK_WIDTH(macro_tile_mode) << 15) |
		(G_009990_BANK_HEIGHT(macro_tile_mode) << 18) |
		(G_009990_NUM_BANKS(macro_tile_mode) << 21) |
		(G_009990_MACRO_TILE_ASPECT(macro_tile_mode) << 24) |
		(G_009910_PIPE_CONFIG(tile_mode) << 26);
}

static bool cik_sdma_copy_texture(struct si_context *sctx,
				  struct pipe_resource *dst,
				  unsigned dst_level,
				  unsigned dstx, unsigned dsty, unsigned dstz,
				  struct pipe_resource *src,
				  unsigned src_level,
				  const struct pipe_box *src_box)
{
	struct radeon_info *info = &sctx->screen->b.info;
d119 51
a169 108
	unsigned bpp = rdst->surface.bpe;
	uint64_t dst_address = rdst->resource.gpu_address +
			       rdst->surface.level[dst_level].offset;
	uint64_t src_address = rsrc->resource.gpu_address +
			       rsrc->surface.level[src_level].offset;
	unsigned dst_mode = rdst->surface.level[dst_level].mode;
	unsigned src_mode = rsrc->surface.level[src_level].mode;
	unsigned dst_tile_index = rdst->surface.tiling_index[dst_level];
	unsigned src_tile_index = rsrc->surface.tiling_index[src_level];
	unsigned dst_tile_mode = info->si_tile_mode_array[dst_tile_index];
	unsigned src_tile_mode = info->si_tile_mode_array[src_tile_index];
	unsigned dst_micro_mode = G_009910_MICRO_TILE_MODE_NEW(dst_tile_mode);
	unsigned src_micro_mode = G_009910_MICRO_TILE_MODE_NEW(src_tile_mode);
	unsigned dst_pitch = rdst->surface.level[dst_level].pitch_bytes / bpp;
	unsigned src_pitch = rsrc->surface.level[src_level].pitch_bytes / bpp;
	uint64_t dst_slice_pitch = rdst->surface.level[dst_level].slice_size / bpp;
	uint64_t src_slice_pitch = rsrc->surface.level[src_level].slice_size / bpp;
	unsigned dst_width = minify_as_blocks(rdst->resource.b.b.width0,
					      dst_level, rdst->surface.blk_w);
	unsigned src_width = minify_as_blocks(rsrc->resource.b.b.width0,
					      src_level, rsrc->surface.blk_w);
	unsigned dst_height = minify_as_blocks(rdst->resource.b.b.height0,
					       dst_level, rdst->surface.blk_h);
	unsigned src_height = minify_as_blocks(rsrc->resource.b.b.height0,
					       src_level, rsrc->surface.blk_h);
	unsigned srcx = src_box->x / rsrc->surface.blk_w;
	unsigned srcy = src_box->y / rsrc->surface.blk_h;
	unsigned srcz = src_box->z;
	unsigned copy_width = DIV_ROUND_UP(src_box->width, rsrc->surface.blk_w);
	unsigned copy_height = DIV_ROUND_UP(src_box->height, rsrc->surface.blk_h);
	unsigned copy_depth = src_box->depth;

	assert(src_level <= src->last_level);
	assert(dst_level <= dst->last_level);
	assert(rdst->surface.level[dst_level].offset +
	       dst_slice_pitch * bpp * (dstz + src_box->depth) <=
	       rdst->resource.buf->size);
	assert(rsrc->surface.level[src_level].offset +
	       src_slice_pitch * bpp * (srcz + src_box->depth) <=
	       rsrc->resource.buf->size);

	/* Test CIK with radeon and amdgpu before enabling this. */
	if (sctx->b.chip_class == CIK)
		return false;

	if (!r600_prepare_for_dma_blit(&sctx->b, rdst, dst_level, dstx, dsty,
					dstz, rsrc, src_level, src_box))
		return false;

	dstx /= rdst->surface.blk_w;
	dsty /= rdst->surface.blk_h;

	if (srcx >= (1 << 14) ||
	    srcy >= (1 << 14) ||
	    srcz >= (1 << 11) ||
	    dstx >= (1 << 14) ||
	    dsty >= (1 << 14) ||
	    dstz >= (1 << 11))
		return false;

	/* Linear -> linear sub-window copy. */
	if (dst_mode == RADEON_SURF_MODE_LINEAR_ALIGNED &&
	    src_mode == RADEON_SURF_MODE_LINEAR_ALIGNED &&
	    /* check if everything fits into the bitfields */
	    src_pitch <= (1 << 14) &&
	    dst_pitch <= (1 << 14) &&
	    src_slice_pitch <= (1 << 28) &&
	    dst_slice_pitch <= (1 << 28) &&
	    copy_width <= (1 << 14) &&
	    copy_height <= (1 << 14) &&
	    copy_depth <= (1 << 11) &&
	    /* HW limitation - CIK: */
	    (sctx->b.chip_class != CIK ||
	     (copy_width < (1 << 14) &&
	      copy_height < (1 << 14) &&
	      copy_depth < (1 << 11))) &&
	    /* HW limitation - some CIK parts: */
	    ((sctx->b.family != CHIP_BONAIRE &&
	      sctx->b.family != CHIP_KAVERI) ||
	     (srcx + copy_width != (1 << 14) &&
	      srcy + copy_height != (1 << 14)))) {
		struct radeon_winsys_cs *cs = sctx->b.dma.cs;

		r600_need_dma_space(&sctx->b, 13, &rdst->resource, &rsrc->resource);

		radeon_emit(cs, CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY,
						CIK_SDMA_COPY_SUB_OPCODE_LINEAR_SUB_WINDOW, 0) |
			    (util_logbase2(bpp) << 29));
		radeon_emit(cs, src_address);
		radeon_emit(cs, src_address >> 32);
		radeon_emit(cs, srcx | (srcy << 16));
		radeon_emit(cs, srcz | ((src_pitch - 1) << 16));
		radeon_emit(cs, src_slice_pitch - 1);
		radeon_emit(cs, dst_address);
		radeon_emit(cs, dst_address >> 32);
		radeon_emit(cs, dstx | (dsty << 16));
		radeon_emit(cs, dstz | ((dst_pitch - 1) << 16));
		radeon_emit(cs, dst_slice_pitch - 1);
		if (sctx->b.chip_class == CIK) {
			radeon_emit(cs, copy_width | (copy_height << 16));
			radeon_emit(cs, copy_depth);
		} else {
			radeon_emit(cs, (copy_width - 1) | ((copy_height - 1) << 16));
			radeon_emit(cs, (copy_depth - 1));
		}

		r600_dma_emit_wait_idle(&sctx->b);
		return true;
d171 2
d174 4
a177 70
	/* Tiled <-> linear sub-window copy. */
	if ((src_mode >= RADEON_SURF_MODE_1D) != (dst_mode >= RADEON_SURF_MODE_1D)) {
		struct r600_texture *tiled = src_mode >= RADEON_SURF_MODE_1D ? rsrc : rdst;
		struct r600_texture *linear = tiled == rsrc ? rdst : rsrc;
		unsigned tiled_level =	tiled	== rsrc ? src_level : dst_level;
		unsigned linear_level =	linear	== rsrc ? src_level : dst_level;
		unsigned tiled_x =	tiled	== rsrc ? srcx : dstx;
		unsigned linear_x =	linear  == rsrc ? srcx : dstx;
		unsigned tiled_y =	tiled	== rsrc ? srcy : dsty;
		unsigned linear_y =	linear  == rsrc ? srcy : dsty;
		unsigned tiled_z =	tiled	== rsrc ? srcz : dstz;
		unsigned linear_z =	linear  == rsrc ? srcz : dstz;
		unsigned tiled_width =	tiled	== rsrc ? src_width : dst_width;
		unsigned linear_width =	linear	== rsrc ? src_width : dst_width;
		unsigned tiled_pitch =	tiled	== rsrc ? src_pitch : dst_pitch;
		unsigned linear_pitch =	linear	== rsrc ? src_pitch : dst_pitch;
		unsigned tiled_slice_pitch  = tiled  == rsrc ? src_slice_pitch : dst_slice_pitch;
		unsigned linear_slice_pitch = linear == rsrc ? src_slice_pitch : dst_slice_pitch;
		uint64_t tiled_address =  tiled  == rsrc ? src_address : dst_address;
		uint64_t linear_address = linear == rsrc ? src_address : dst_address;
		unsigned tiled_micro_mode = tiled == rsrc ? src_micro_mode : dst_micro_mode;

		assert(tiled_pitch % 8 == 0);
		assert(tiled_slice_pitch % 64 == 0);
		unsigned pitch_tile_max = tiled_pitch / 8 - 1;
		unsigned slice_tile_max = tiled_slice_pitch / 64 - 1;
		unsigned xalign = MAX2(1, 4 / bpp);
		unsigned copy_width_aligned = copy_width;

		/* If the region ends at the last pixel and is unaligned, we
		 * can copy the remainder of the line that is not visible to
		 * make it aligned.
		 */
		if (copy_width % xalign != 0 &&
		    linear_x + copy_width == linear_width &&
		    tiled_x  + copy_width == tiled_width &&
		    linear_x + align(copy_width, xalign) <= linear_pitch &&
		    tiled_x  + align(copy_width, xalign) <= tiled_pitch)
			copy_width_aligned = align(copy_width, xalign);

		/* HW limitations. */
		if ((sctx->b.family == CHIP_BONAIRE ||
		     sctx->b.family == CHIP_KAVERI) &&
		    linear_pitch - 1 == 0x3fff &&
		    bpp == 16)
			return false;

		if (sctx->b.chip_class == CIK &&
		    (copy_width_aligned == (1 << 14) ||
		     copy_height == (1 << 14) ||
		     copy_depth == (1 << 11)))
			return false;

		if ((sctx->b.family == CHIP_BONAIRE ||
		     sctx->b.family == CHIP_KAVERI ||
		     sctx->b.family == CHIP_KABINI ||
		     sctx->b.family == CHIP_MULLINS) &&
		    (tiled_x + copy_width == (1 << 14) ||
		     tiled_y + copy_height == (1 << 14)))
			return false;

		/* The hw can read outside of the given linear buffer bounds,
		 * or access those pages but not touch the memory in case
		 * of writes. (it still causes a VM fault)
		 *
		 * Out-of-bounds memory access or page directory access must
		 * be prevented.
		 */
		int64_t start_linear_address, end_linear_address;
		unsigned granularity;
d179 6
a184 20
		/* Deduce the size of reads from the linear surface. */
		switch (tiled_micro_mode) {
		case V_009910_ADDR_SURF_DISPLAY_MICRO_TILING:
			granularity = bpp == 1 ? 64 / (8*bpp) :
						 128 / (8*bpp);
			break;
		case V_009910_ADDR_SURF_THIN_MICRO_TILING:
		case V_009910_ADDR_SURF_DEPTH_MICRO_TILING:
			if (0 /* TODO: THICK microtiling */)
				granularity = bpp == 1 ? 32 / (8*bpp) :
					      bpp == 2 ? 64 / (8*bpp) :
					      bpp <= 8 ? 128 / (8*bpp) :
							 256 / (8*bpp);
			else
				granularity = bpp <= 2 ? 64 / (8*bpp) :
					      bpp <= 8 ? 128 / (8*bpp) :
							 256 / (8*bpp);
			break;
		default:
			return false;
d186 1
d188 16
a203 166
		/* The linear reads start at tiled_x & ~(granularity - 1).
		 * If linear_x == 0 && tiled_x % granularity != 0, the hw
		 * starts reading from an address preceding linear_address!!!
		 */
		start_linear_address =
			linear->surface.level[linear_level].offset +
			bpp * (linear_z * linear_slice_pitch +
			       linear_y * linear_pitch +
			       linear_x);
		start_linear_address -= (int)(bpp * (tiled_x % granularity));

		end_linear_address =
			linear->surface.level[linear_level].offset +
			bpp * ((linear_z + copy_depth - 1) * linear_slice_pitch +
			       (linear_y + copy_height - 1) * linear_pitch +
			       (linear_x + copy_width));

		if ((tiled_x + copy_width) % granularity)
			end_linear_address += granularity -
					      (tiled_x + copy_width) % granularity;

		if (start_linear_address < 0 ||
		    end_linear_address > linear->surface.bo_size)
			return false;

		/* Check requirements. */
		if (tiled_address % 256 == 0 &&
		    linear_address % 4 == 0 &&
		    linear_pitch % xalign == 0 &&
		    linear_x % xalign == 0 &&
		    tiled_x % xalign == 0 &&
		    copy_width_aligned % xalign == 0 &&
		    tiled_micro_mode != V_009910_ADDR_SURF_ROTATED_MICRO_TILING &&
		    /* check if everything fits into the bitfields */
		    tiled->surface.tile_split <= 4096 &&
		    pitch_tile_max < (1 << 11) &&
		    slice_tile_max < (1 << 22) &&
		    linear_pitch <= (1 << 14) &&
		    linear_slice_pitch <= (1 << 28) &&
		    copy_width_aligned <= (1 << 14) &&
		    copy_height <= (1 << 14) &&
		    copy_depth <= (1 << 11)) {
			struct radeon_winsys_cs *cs = sctx->b.dma.cs;
			uint32_t direction = linear == rdst ? 1u << 31 : 0;

			r600_need_dma_space(&sctx->b, 14, &rdst->resource, &rsrc->resource);

			radeon_emit(cs, CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY,
							CIK_SDMA_COPY_SUB_OPCODE_TILED_SUB_WINDOW, 0) |
					direction);
			radeon_emit(cs, tiled_address);
			radeon_emit(cs, tiled_address >> 32);
			radeon_emit(cs, tiled_x | (tiled_y << 16));
			radeon_emit(cs, tiled_z | (pitch_tile_max << 16));
			radeon_emit(cs, slice_tile_max);
			radeon_emit(cs, encode_tile_info(sctx, tiled, tiled_level, true));
			radeon_emit(cs, linear_address);
			radeon_emit(cs, linear_address >> 32);
			radeon_emit(cs, linear_x | (linear_y << 16));
			radeon_emit(cs, linear_z | ((linear_pitch - 1) << 16));
			radeon_emit(cs, linear_slice_pitch - 1);
			if (sctx->b.chip_class == CIK) {
				radeon_emit(cs, copy_width_aligned | (copy_height << 16));
				radeon_emit(cs, copy_depth);
			} else {
				radeon_emit(cs, (copy_width_aligned - 1) | ((copy_height - 1) << 16));
				radeon_emit(cs, (copy_depth - 1));
			}

			r600_dma_emit_wait_idle(&sctx->b);
			return true;
		}
	}

	/* Tiled -> Tiled sub-window copy. */
	if (dst_mode >= RADEON_SURF_MODE_1D &&
	    src_mode >= RADEON_SURF_MODE_1D &&
	    /* check if these fit into the bitfields */
	    src_address % 256 == 0 &&
	    dst_address % 256 == 0 &&
	    rsrc->surface.tile_split <= 4096 &&
	    rdst->surface.tile_split <= 4096 &&
	    dstx % 8 == 0 &&
	    dsty % 8 == 0 &&
	    srcx % 8 == 0 &&
	    srcy % 8 == 0 &&
	    /* this can either be equal, or display->rotated (VI only) */
	    (src_micro_mode == dst_micro_mode ||
	     (sctx->b.chip_class == VI &&
	      src_micro_mode == V_009910_ADDR_SURF_DISPLAY_MICRO_TILING &&
	      dst_micro_mode == V_009910_ADDR_SURF_ROTATED_MICRO_TILING))) {
		assert(src_pitch % 8 == 0);
		assert(dst_pitch % 8 == 0);
		assert(src_slice_pitch % 64 == 0);
		assert(dst_slice_pitch % 64 == 0);
		unsigned src_pitch_tile_max = src_pitch / 8 - 1;
		unsigned dst_pitch_tile_max = dst_pitch / 8 - 1;
		unsigned src_slice_tile_max = src_slice_pitch / 64 - 1;
		unsigned dst_slice_tile_max = dst_slice_pitch / 64 - 1;
		unsigned copy_width_aligned = copy_width;
		unsigned copy_height_aligned = copy_height;

		/* If the region ends at the last pixel and is unaligned, we
		 * can copy the remainder of the tile that is not visible to
		 * make it aligned.
		 */
		if (copy_width % 8 != 0 &&
		    srcx + copy_width == src_width &&
		    dstx + copy_width == dst_width)
			copy_width_aligned = align(copy_width, 8);

		if (copy_height % 8 != 0 &&
		    srcy + copy_height == src_height &&
		    dsty + copy_height == dst_height)
			copy_height_aligned = align(copy_height, 8);

		/* check if these fit into the bitfields */
		if (src_pitch_tile_max < (1 << 11) &&
		    dst_pitch_tile_max < (1 << 11) &&
		    src_slice_tile_max < (1 << 22) &&
		    dst_slice_tile_max < (1 << 22) &&
		    copy_width_aligned <= (1 << 14) &&
		    copy_height_aligned <= (1 << 14) &&
		    copy_depth <= (1 << 11) &&
		    copy_width_aligned % 8 == 0 &&
		    copy_height_aligned % 8 == 0 &&
		    /* HW limitation - CIK: */
		    (sctx->b.chip_class != CIK ||
		     (copy_width_aligned < (1 << 14) &&
		      copy_height_aligned < (1 << 14) &&
		      copy_depth < (1 << 11))) &&
		    /* HW limitation - some CIK parts: */
		    ((sctx->b.family != CHIP_BONAIRE &&
		      sctx->b.family != CHIP_KAVERI &&
		      sctx->b.family != CHIP_KABINI &&
		      sctx->b.family != CHIP_MULLINS) ||
		     (srcx + copy_width_aligned != (1 << 14) &&
		      srcy + copy_height_aligned != (1 << 14) &&
		      dstx + copy_width != (1 << 14)))) {
			struct radeon_winsys_cs *cs = sctx->b.dma.cs;

			r600_need_dma_space(&sctx->b, 15, &rdst->resource, &rsrc->resource);

			radeon_emit(cs, CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY,
							CIK_SDMA_COPY_SUB_OPCODE_T2T_SUB_WINDOW, 0));
			radeon_emit(cs, src_address);
			radeon_emit(cs, src_address >> 32);
			radeon_emit(cs, srcx | (srcy << 16));
			radeon_emit(cs, srcz | (src_pitch_tile_max << 16));
			radeon_emit(cs, src_slice_tile_max);
			radeon_emit(cs, encode_tile_info(sctx, rsrc, src_level, true));
			radeon_emit(cs, dst_address);
			radeon_emit(cs, dst_address >> 32);
			radeon_emit(cs, dstx | (dsty << 16));
			radeon_emit(cs, dstz | (dst_pitch_tile_max << 16));
			radeon_emit(cs, dst_slice_tile_max);
			radeon_emit(cs, encode_tile_info(sctx, rdst, dst_level, false));
			if (sctx->b.chip_class == CIK) {
				radeon_emit(cs, copy_width_aligned |
						(copy_height_aligned << 16));
				radeon_emit(cs, copy_depth);
			} else {
				radeon_emit(cs, (copy_width_aligned - 8) |
						((copy_height_aligned - 8) << 16));
				radeon_emit(cs, (copy_depth - 1));
			}
d205 2
a206 3
			r600_dma_emit_wait_idle(&sctx->b);
			return true;
		}
a207 2

	return false;
d210 7
a216 7
static void cik_sdma_copy(struct pipe_context *ctx,
			  struct pipe_resource *dst,
			  unsigned dst_level,
			  unsigned dstx, unsigned dsty, unsigned dstz,
			  struct pipe_resource *src,
			  unsigned src_level,
			  const struct pipe_box *src_box)
d219 7
d227 1
a227 1
	if (!sctx->b.dma.cs)
d229 1
d232 1
a232 1
		cik_sdma_copy_buffer(sctx, dst, src, dstx, src_box->x, src_box->width);
d236 4
a239 2
	/* Carrizo SDMA texture copying is very broken for some users.
	 * https://bugs.freedesktop.org/show_bug.cgi?id=97029
d241 6
a246 1
	if (sctx->b.family == CHIP_CARRIZO)
d248 1
d250 111
a360 3
	if (cik_sdma_copy_texture(sctx, dst, dst_level, dstx, dsty, dstz,
				  src, src_level, src_box))
		return;
a364 5
}

void cik_init_sdma_functions(struct si_context *sctx)
{
	sctx->b.dma_copy = cik_sdma_copy;
@


