head	1.1;
branch	1.1.1;
access;
symbols
	mesa-17_1_6:1.1.1.5
	OPENBSD_6_1:1.1.1.4.0.2
	OPENBSD_6_1_BASE:1.1.1.4
	mesa-13_0_6:1.1.1.4
	mesa-13_0_5:1.1.1.4
	mesa-13_0_3:1.1.1.4
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.44.43;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.43;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.20.20;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.28.13;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.01.19.05.39.45;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	vYSESphXPMoytdgU;

1.1.1.5
date	2017.08.14.09.32.59;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright 2010 Jerome Glisse <glisse@@freedesktop.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include "si_pipe.h"
#include "si_public.h"
#include "sid.h"

#include "radeon/radeon_llvm_emit.h"
#include "radeon/radeon_uvd.h"
#include "util/u_memory.h"
#include "vl/vl_decoder.h"

/*
 * pipe_context
 */
static void si_destroy_context(struct pipe_context *context)
{
	struct si_context *sctx = (struct si_context *)context;
	int i;

	si_release_all_descriptors(sctx);

	pipe_resource_reference(&sctx->esgs_ring, NULL);
	pipe_resource_reference(&sctx->gsvs_ring, NULL);
	pipe_resource_reference(&sctx->tf_ring, NULL);
	pipe_resource_reference(&sctx->null_const_buf.buffer, NULL);
	r600_resource_reference(&sctx->border_color_table, NULL);
	r600_resource_reference(&sctx->scratch_buffer, NULL);
	sctx->b.ws->fence_reference(&sctx->last_gfx_fence, NULL);

	si_pm4_free_state(sctx, sctx->init_config, ~0);
	si_pm4_delete_state(sctx, gs_rings, sctx->gs_rings);
	si_pm4_delete_state(sctx, tf_ring, sctx->tf_state);
	for (i = 0; i < Elements(sctx->vgt_shader_config); i++)
		si_pm4_delete_state(sctx, vgt_shader_config, sctx->vgt_shader_config[i]);

	if (sctx->pstipple_sampler_state)
		sctx->b.b.delete_sampler_state(&sctx->b.b, sctx->pstipple_sampler_state);
	if (sctx->dummy_pixel_shader)
		sctx->b.b.delete_fs_state(&sctx->b.b, sctx->dummy_pixel_shader);
	if (sctx->fixed_func_tcs_shader)
		sctx->b.b.delete_tcs_state(&sctx->b.b, sctx->fixed_func_tcs_shader);
	if (sctx->custom_dsa_flush)
		sctx->b.b.delete_depth_stencil_alpha_state(&sctx->b.b, sctx->custom_dsa_flush);
	if (sctx->custom_blend_resolve)
		sctx->b.b.delete_blend_state(&sctx->b.b, sctx->custom_blend_resolve);
	if (sctx->custom_blend_decompress)
		sctx->b.b.delete_blend_state(&sctx->b.b, sctx->custom_blend_decompress);
	if (sctx->custom_blend_fastclear)
		sctx->b.b.delete_blend_state(&sctx->b.b, sctx->custom_blend_fastclear);
	util_unreference_framebuffer_state(&sctx->framebuffer.state);

	if (sctx->blitter)
		util_blitter_destroy(sctx->blitter);

	si_pm4_cleanup(sctx);

	r600_common_context_cleanup(&sctx->b);

#if HAVE_LLVM >= 0x0306
	LLVMDisposeTargetMachine(sctx->tm);
#endif

	FREE(sctx);
}

static enum pipe_reset_status
si_amdgpu_get_reset_status(struct pipe_context *ctx)
{
	struct si_context *sctx = (struct si_context *)ctx;

	return sctx->b.ws->ctx_query_reset_status(sctx->b.ctx);
}

static struct pipe_context *si_create_context(struct pipe_screen *screen, void *priv)
{
	struct si_context *sctx = CALLOC_STRUCT(si_context);
	struct si_screen* sscreen = (struct si_screen *)screen;
	struct radeon_winsys *ws = sscreen->b.ws;
	LLVMTargetRef r600_target;
#if HAVE_LLVM >= 0x0306
	const char *triple = "amdgcn--";
#endif
	int shader, i;

	if (sctx == NULL)
		return NULL;

	sctx->b.b.screen = screen; /* this must be set first */
	sctx->b.b.priv = priv;
	sctx->b.b.destroy = si_destroy_context;
	sctx->b.set_atom_dirty = (void *)si_set_atom_dirty;
	sctx->screen = sscreen; /* Easy accessing of screen/winsys. */

	if (!r600_common_context_init(&sctx->b, &sscreen->b))
		goto fail;

	if (sscreen->b.info.drm_major == 3)
		sctx->b.b.get_device_reset_status = si_amdgpu_get_reset_status;

	si_init_blit_functions(sctx);
	si_init_compute_functions(sctx);
	si_init_cp_dma_functions(sctx);

	if (sscreen->b.info.has_uvd) {
		sctx->b.b.create_video_codec = si_uvd_create_decoder;
		sctx->b.b.create_video_buffer = si_video_buffer_create;
	} else {
		sctx->b.b.create_video_codec = vl_create_decoder;
		sctx->b.b.create_video_buffer = vl_video_buffer_create;
	}

	sctx->b.rings.gfx.cs = ws->cs_create(sctx->b.ctx, RING_GFX, si_context_gfx_flush,
					     sctx, sscreen->b.trace_bo ?
						sscreen->b.trace_bo->cs_buf : NULL);
	sctx->b.rings.gfx.flush = si_context_gfx_flush;

	si_init_all_descriptors(sctx);

	/* Initialize cache_flush. */
	sctx->cache_flush = si_atom_cache_flush;
	sctx->atoms.s.cache_flush = &sctx->cache_flush;

	sctx->msaa_sample_locs = si_atom_msaa_sample_locs;
	sctx->atoms.s.msaa_sample_locs = &sctx->msaa_sample_locs;

	sctx->msaa_config = si_atom_msaa_config;
	sctx->atoms.s.msaa_config = &sctx->msaa_config;

	sctx->atoms.s.streamout_begin = &sctx->b.streamout.begin_atom;
	sctx->atoms.s.streamout_enable = &sctx->b.streamout.enable_atom;

	si_init_state_functions(sctx);
	si_init_shader_functions(sctx);

	if (sscreen->b.debug_flags & DBG_FORCE_DMA)
		sctx->b.b.resource_copy_region = sctx->b.dma_copy;

	sctx->blitter = util_blitter_create(&sctx->b.b);
	if (sctx->blitter == NULL)
		goto fail;
	sctx->blitter->draw_rectangle = r600_draw_rectangle;

	/* these must be last */
	si_begin_new_cs(sctx);
	r600_query_init_backend_mask(&sctx->b); /* this emits commands and must be last */

	/* CIK cannot unbind a constant buffer (S_BUFFER_LOAD is buggy
	 * with a NULL buffer). We need to use a dummy buffer instead. */
	if (sctx->b.chip_class == CIK) {
		sctx->null_const_buf.buffer = pipe_buffer_create(screen, PIPE_BIND_CONSTANT_BUFFER,
								 PIPE_USAGE_DEFAULT, 16);
		if (!sctx->null_const_buf.buffer)
			goto fail;
		sctx->null_const_buf.buffer_size = sctx->null_const_buf.buffer->width0;

		for (shader = 0; shader < SI_NUM_SHADERS; shader++) {
			for (i = 0; i < SI_NUM_CONST_BUFFERS; i++) {
				sctx->b.b.set_constant_buffer(&sctx->b.b, shader, i,
							      &sctx->null_const_buf);
			}
		}

		/* Clear the NULL constant buffer, because loads should return zeros. */
		sctx->b.clear_buffer(&sctx->b.b, sctx->null_const_buf.buffer, 0,
				     sctx->null_const_buf.buffer->width0, 0, false);
	}

	/* XXX: This is the maximum value allowed.  I'm not sure how to compute
	 * this for non-cs shaders.  Using the wrong value here can result in
	 * GPU lockups, but the maximum value seems to always work.
	 */
	sctx->scratch_waves = 32 * sscreen->b.info.max_compute_units;

#if HAVE_LLVM >= 0x0306
	/* Initialize LLVM TargetMachine */
	r600_target = radeon_llvm_get_r600_target(triple);
	sctx->tm = LLVMCreateTargetMachine(r600_target, triple,
					   r600_get_llvm_processor_name(sscreen->b.family),
					   "+DumpCode,+vgpr-spilling",
					   LLVMCodeGenLevelDefault,
					   LLVMRelocDefault,
					   LLVMCodeModelDefault);
#endif

	return &sctx->b.b;
fail:
	si_destroy_context(&sctx->b.b);
	return NULL;
}

/*
 * pipe_screen
 */

static int si_get_param(struct pipe_screen* pscreen, enum pipe_cap param)
{
	struct si_screen *sscreen = (struct si_screen *)pscreen;

	switch (param) {
	/* Supported features (boolean caps). */
	case PIPE_CAP_TWO_SIDED_STENCIL:
	case PIPE_CAP_MAX_DUAL_SOURCE_RENDER_TARGETS:
	case PIPE_CAP_ANISOTROPIC_FILTER:
	case PIPE_CAP_POINT_SPRITE:
	case PIPE_CAP_OCCLUSION_QUERY:
	case PIPE_CAP_TEXTURE_SHADOW_MAP:
	case PIPE_CAP_TEXTURE_MIRROR_CLAMP:
	case PIPE_CAP_BLEND_EQUATION_SEPARATE:
	case PIPE_CAP_TEXTURE_SWIZZLE:
	case PIPE_CAP_DEPTH_CLIP_DISABLE:
	case PIPE_CAP_SHADER_STENCIL_EXPORT:
	case PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR:
	case PIPE_CAP_MIXED_COLORBUFFER_FORMATS:
	case PIPE_CAP_TGSI_FS_COORD_ORIGIN_UPPER_LEFT:
	case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_HALF_INTEGER:
	case PIPE_CAP_TGSI_FS_COORD_PIXEL_CENTER_INTEGER:
	case PIPE_CAP_SM3:
	case PIPE_CAP_SEAMLESS_CUBE_MAP:
	case PIPE_CAP_PRIMITIVE_RESTART:
	case PIPE_CAP_CONDITIONAL_RENDER:
	case PIPE_CAP_TEXTURE_BARRIER:
	case PIPE_CAP_INDEP_BLEND_ENABLE:
	case PIPE_CAP_INDEP_BLEND_FUNC:
	case PIPE_CAP_SEAMLESS_CUBE_MAP_PER_TEXTURE:
	case PIPE_CAP_VERTEX_COLOR_UNCLAMPED:
	case PIPE_CAP_VERTEX_BUFFER_OFFSET_4BYTE_ALIGNED_ONLY:
	case PIPE_CAP_VERTEX_BUFFER_STRIDE_4BYTE_ALIGNED_ONLY:
	case PIPE_CAP_VERTEX_ELEMENT_SRC_OFFSET_4BYTE_ALIGNED_ONLY:
	case PIPE_CAP_USER_INDEX_BUFFERS:
	case PIPE_CAP_USER_CONSTANT_BUFFERS:
	case PIPE_CAP_START_INSTANCE:
	case PIPE_CAP_NPOT_TEXTURES:
	case PIPE_CAP_MIXED_FRAMEBUFFER_SIZES:
        case PIPE_CAP_PREFER_BLIT_BASED_TEXTURE_TRANSFER:
	case PIPE_CAP_TGSI_INSTANCEID:
	case PIPE_CAP_COMPUTE:
	case PIPE_CAP_TEXTURE_BUFFER_OBJECTS:
        case PIPE_CAP_TGSI_VS_LAYER_VIEWPORT:
	case PIPE_CAP_QUERY_PIPELINE_STATISTICS:
	case PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT:
	case PIPE_CAP_CUBE_MAP_ARRAY:
	case PIPE_CAP_SAMPLE_SHADING:
	case PIPE_CAP_DRAW_INDIRECT:
	case PIPE_CAP_CLIP_HALFZ:
	case PIPE_CAP_TGSI_VS_WINDOW_SPACE_POSITION:
	case PIPE_CAP_POLYGON_OFFSET_CLAMP:
	case PIPE_CAP_MULTISAMPLE_Z_RESOLVE:
	case PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION:
	case PIPE_CAP_TGSI_TEXCOORD:
	case PIPE_CAP_TGSI_FS_FINE_DERIVATIVE:
	case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
	case PIPE_CAP_TEXTURE_FLOAT_LINEAR:
	case PIPE_CAP_TEXTURE_HALF_FLOAT_LINEAR:
	case PIPE_CAP_DEPTH_BOUNDS_TEST:
		return 1;

	case PIPE_CAP_RESOURCE_FROM_USER_MEMORY:
		return !SI_BIG_ENDIAN && sscreen->b.info.has_userptr;

	case PIPE_CAP_DEVICE_RESET_STATUS_QUERY:
		return (sscreen->b.info.drm_major == 2 &&
			sscreen->b.info.drm_minor >= 43) ||
		       sscreen->b.info.drm_major == 3;

	case PIPE_CAP_TEXTURE_MULTISAMPLE:
		/* 2D tiling on CIK is supported since DRM 2.35.0 */
		return sscreen->b.chip_class < CIK ||
		       (sscreen->b.info.drm_major == 2 &&
			sscreen->b.info.drm_minor >= 35) ||
		       sscreen->b.info.drm_major == 3;

        case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
                return R600_MAP_BUFFER_ALIGNMENT;

	case PIPE_CAP_CONSTANT_BUFFER_OFFSET_ALIGNMENT:
	case PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT:
		return 4;

	case PIPE_CAP_GLSL_FEATURE_LEVEL:
		return HAVE_LLVM >= 0x0307 ? 410 : 330;

	case PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE:
		return MIN2(sscreen->b.info.vram_size, 0xFFFFFFFF);

	case PIPE_CAP_TEXTURE_QUERY_LOD:
	case PIPE_CAP_TEXTURE_GATHER_SM5:
		return HAVE_LLVM >= 0x0305;
	case PIPE_CAP_MAX_TEXTURE_GATHER_COMPONENTS:
		return HAVE_LLVM >= 0x0305 ? 4 : 0;

	/* Unsupported features. */
	case PIPE_CAP_TGSI_FS_COORD_ORIGIN_LOWER_LEFT:
	case PIPE_CAP_TGSI_CAN_COMPACT_CONSTANTS:
	case PIPE_CAP_FRAGMENT_COLOR_CLAMPED:
	case PIPE_CAP_VERTEX_COLOR_CLAMPED:
	case PIPE_CAP_USER_VERTEX_BUFFERS:
	case PIPE_CAP_FAKE_SW_MSAA:
	case PIPE_CAP_TEXTURE_GATHER_OFFSETS:
	case PIPE_CAP_SAMPLER_VIEW_TARGET:
	case PIPE_CAP_VERTEXID_NOBASE:
		return 0;

	case PIPE_CAP_MAX_SHADER_PATCH_VARYINGS:
		return 30;

	case PIPE_CAP_TEXTURE_BORDER_COLOR_QUIRK:
		return PIPE_QUIRK_TEXTURE_BORDER_COLOR_SWIZZLE_R600;

	/* Stream output. */
	case PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS:
		return sscreen->b.has_streamout ? 4 : 0;
	case PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME:
		return sscreen->b.has_streamout ? 1 : 0;
	case PIPE_CAP_MAX_STREAM_OUTPUT_SEPARATE_COMPONENTS:
	case PIPE_CAP_MAX_STREAM_OUTPUT_INTERLEAVED_COMPONENTS:
		return sscreen->b.has_streamout ? 32*4 : 0;

	/* Geometry shader output. */
	case PIPE_CAP_MAX_GEOMETRY_OUTPUT_VERTICES:
		return 1024;
	case PIPE_CAP_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS:
		return 4095;
	case PIPE_CAP_MAX_VERTEX_STREAMS:
		return 4;

	case PIPE_CAP_MAX_VERTEX_ATTRIB_STRIDE:
		return 2048;

	/* Texturing. */
	case PIPE_CAP_MAX_TEXTURE_2D_LEVELS:
	case PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS:
		return 15; /* 16384 */
	case PIPE_CAP_MAX_TEXTURE_3D_LEVELS:
		/* textures support 8192, but layered rendering supports 2048 */
		return 12;
	case PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS:
		/* textures support 8192, but layered rendering supports 2048 */
		return 2048;

	/* Render targets. */
	case PIPE_CAP_MAX_RENDER_TARGETS:
		return 8;

	case PIPE_CAP_MAX_VIEWPORTS:
		return 16;

	/* Timer queries, present when the clock frequency is non zero. */
	case PIPE_CAP_QUERY_TIMESTAMP:
	case PIPE_CAP_QUERY_TIME_ELAPSED:
		return sscreen->b.info.r600_clock_crystal_freq != 0;

 	case PIPE_CAP_MIN_TEXTURE_GATHER_OFFSET:
	case PIPE_CAP_MIN_TEXEL_OFFSET:
		return -32;

 	case PIPE_CAP_MAX_TEXTURE_GATHER_OFFSET:
	case PIPE_CAP_MAX_TEXEL_OFFSET:
		return 31;

	case PIPE_CAP_ENDIANNESS:
		return PIPE_ENDIAN_LITTLE;

	case PIPE_CAP_VENDOR_ID:
		return 0x1002;
	case PIPE_CAP_DEVICE_ID:
		return sscreen->b.info.pci_id;
	case PIPE_CAP_ACCELERATED:
		return 1;
	case PIPE_CAP_VIDEO_MEMORY:
		return sscreen->b.info.vram_size >> 20;
	case PIPE_CAP_UMA:
		return 0;
	}
	return 0;
}

static int si_get_shader_param(struct pipe_screen* pscreen, unsigned shader, enum pipe_shader_cap param)
{
	switch(shader)
	{
	case PIPE_SHADER_FRAGMENT:
	case PIPE_SHADER_VERTEX:
	case PIPE_SHADER_GEOMETRY:
		break;
	case PIPE_SHADER_TESS_CTRL:
	case PIPE_SHADER_TESS_EVAL:
		/* LLVM 3.6.2 is required for tessellation because of bug fixes there */
		if (HAVE_LLVM < 0x0306 ||
		    (HAVE_LLVM == 0x0306 && MESA_LLVM_VERSION_PATCH < 2))
			return 0;
		break;
	case PIPE_SHADER_COMPUTE:
		switch (param) {
		case PIPE_SHADER_CAP_PREFERRED_IR:
#if HAVE_LLVM < 0x0306
			return PIPE_SHADER_IR_LLVM;
#else
			return PIPE_SHADER_IR_NATIVE;
#endif
		case PIPE_SHADER_CAP_DOUBLES:
			return HAVE_LLVM >= 0x0307;

		case PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE: {
			uint64_t max_const_buffer_size;
			pscreen->get_compute_param(pscreen,
				PIPE_COMPUTE_CAP_MAX_MEM_ALLOC_SIZE,
				&max_const_buffer_size);
			return max_const_buffer_size;
		}
		default:
			/* If compute shaders don't require a special value
			 * for this cap, we can return the same value we
			 * do for other shader types. */
			break;
		}
		break;
	default:
		return 0;
	}

	switch (param) {
	case PIPE_SHADER_CAP_MAX_INSTRUCTIONS:
	case PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS:
	case PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS:
	case PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS:
		return 16384;
	case PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH:
		return 32;
	case PIPE_SHADER_CAP_MAX_INPUTS:
		return shader == PIPE_SHADER_VERTEX ? SI_NUM_VERTEX_BUFFERS : 32;
	case PIPE_SHADER_CAP_MAX_OUTPUTS:
		return shader == PIPE_SHADER_FRAGMENT ? 8 : 32;
	case PIPE_SHADER_CAP_MAX_TEMPS:
		return 256; /* Max native temporaries. */
	case PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE:
		return 4096 * sizeof(float[4]); /* actually only memory limits this */
	case PIPE_SHADER_CAP_MAX_CONST_BUFFERS:
		return SI_NUM_USER_CONST_BUFFERS;
	case PIPE_SHADER_CAP_MAX_PREDS:
		return 0; /* FIXME */
	case PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED:
		return 1;
	case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
		return 1;
	case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR:
		/* Indirection of geometry shader input dimension is not
		 * handled yet
		 */
		return shader != PIPE_SHADER_GEOMETRY;
	case PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR:
	case PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR:
	case PIPE_SHADER_CAP_INDIRECT_CONST_ADDR:
		return 1;
	case PIPE_SHADER_CAP_INTEGERS:
		return 1;
	case PIPE_SHADER_CAP_SUBROUTINES:
		return 0;
	case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
	case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
		return 16;
	case PIPE_SHADER_CAP_PREFERRED_IR:
		return PIPE_SHADER_IR_TGSI;
	case PIPE_SHADER_CAP_DOUBLES:
		return HAVE_LLVM >= 0x0307;
	case PIPE_SHADER_CAP_TGSI_DROUND_SUPPORTED:
	case PIPE_SHADER_CAP_TGSI_DFRACEXP_DLDEXP_SUPPORTED:
		return 0;
	case PIPE_SHADER_CAP_TGSI_FMA_SUPPORTED:
	case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
		return 1;
	case PIPE_SHADER_CAP_MAX_UNROLL_ITERATIONS_HINT:
		return 32;
	}
	return 0;
}

static void si_destroy_screen(struct pipe_screen* pscreen)
{
	struct si_screen *sscreen = (struct si_screen *)pscreen;

	if (sscreen == NULL)
		return;

	if (!sscreen->b.ws->unref(sscreen->b.ws))
		return;

	r600_destroy_common_screen(&sscreen->b);
}

#define SI_TILE_MODE_COLOR_2D_8BPP  14

/* Initialize pipe config. This is especially important for GPUs
 * with 16 pipes and more where it's initialized incorrectly by
 * the TILING_CONFIG ioctl. */
static bool si_initialize_pipe_config(struct si_screen *sscreen)
{
	unsigned mode2d;

	/* This is okay, because there can be no 2D tiling without
	 * the tile mode array, so we won't need the pipe config.
	 * Return "success".
	 */
	if (!sscreen->b.info.si_tile_mode_array_valid)
		return true;

	/* The same index is used for the 2D mode on CIK too. */
	mode2d = sscreen->b.info.si_tile_mode_array[SI_TILE_MODE_COLOR_2D_8BPP];

	switch (G_009910_PIPE_CONFIG(mode2d)) {
	case V_02803C_ADDR_SURF_P2:
		sscreen->b.tiling_info.num_channels = 2;
		break;
	case V_02803C_X_ADDR_SURF_P4_8X16:
	case V_02803C_X_ADDR_SURF_P4_16X16:
	case V_02803C_X_ADDR_SURF_P4_16X32:
	case V_02803C_X_ADDR_SURF_P4_32X32:
		sscreen->b.tiling_info.num_channels = 4;
		break;
	case V_02803C_X_ADDR_SURF_P8_16X16_8X16:
	case V_02803C_X_ADDR_SURF_P8_16X32_8X16:
	case V_02803C_X_ADDR_SURF_P8_32X32_8X16:
	case V_02803C_X_ADDR_SURF_P8_16X32_16X16:
	case V_02803C_X_ADDR_SURF_P8_32X32_16X16:
	case V_02803C_X_ADDR_SURF_P8_32X32_16X32:
	case V_02803C_X_ADDR_SURF_P8_32X64_32X32:
		sscreen->b.tiling_info.num_channels = 8;
		break;
	case V_02803C_X_ADDR_SURF_P16_32X32_8X16:
	case V_02803C_X_ADDR_SURF_P16_32X32_16X16:
		sscreen->b.tiling_info.num_channels = 16;
		break;
	default:
		assert(0);
		fprintf(stderr, "radeonsi: Unknown pipe config %i.\n",
			G_009910_PIPE_CONFIG(mode2d));
		return false;
	}
	return true;
}

struct pipe_screen *radeonsi_screen_create(struct radeon_winsys *ws)
{
	struct si_screen *sscreen = CALLOC_STRUCT(si_screen);

	if (sscreen == NULL) {
		return NULL;
	}

	/* Set functions first. */
	sscreen->b.b.context_create = si_create_context;
	sscreen->b.b.destroy = si_destroy_screen;
	sscreen->b.b.get_param = si_get_param;
	sscreen->b.b.get_shader_param = si_get_shader_param;
	sscreen->b.b.is_format_supported = si_is_format_supported;
	sscreen->b.b.resource_create = r600_resource_create_common;

	if (!r600_common_screen_init(&sscreen->b, ws) ||
	    !si_initialize_pipe_config(sscreen)) {
		FREE(sscreen);
		return NULL;
	}

	sscreen->b.has_cp_dma = true;
	sscreen->b.has_streamout = true;

	if (debug_get_bool_option("RADEON_DUMP_SHADERS", FALSE))
		sscreen->b.debug_flags |= DBG_FS | DBG_VS | DBG_GS | DBG_PS | DBG_CS;

	/* Create the auxiliary context. This must be done last. */
	sscreen->b.aux_context = sscreen->b.b.context_create(&sscreen->b.b, NULL);

	return &sscreen->b.b;
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@a24 1
#include "si_shader.h"
d47 1
a47 2
	r600_resource_reference(&sctx->border_color_buffer, NULL);
	free(sctx->border_color_table);
d52 2
a53 2
	if (sctx->init_config_gs_rings)
		si_pm4_free_state(sctx, sctx->init_config_gs_rings, ~0);
d59 4
a62 2
	if (sctx->fixed_func_tcs_shader.cso)
		sctx->b.b.delete_tcs_state(&sctx->b.b, sctx->fixed_func_tcs_shader.cso);
d76 2
d80 1
d82 1
a83 8
	r600_resource_reference(&sctx->trace_buf, NULL);
	r600_resource_reference(&sctx->last_trace_buf, NULL);
	free(sctx->last_ib);
	if (sctx->last_bo_list) {
		for (i = 0; i < sctx->last_bo_count; i++)
			pb_reference(&sctx->last_bo_list[i].buf, NULL);
		free(sctx->last_bo_list);
	}
d95 1
a95 2
static struct pipe_context *si_create_context(struct pipe_screen *screen,
                                              void *priv, unsigned flags)
d101 1
d103 1
d106 1
a106 1
	if (!sctx)
a108 3
	if (sscreen->b.debug_flags & DBG_CHECK_VM)
		flags |= PIPE_CONTEXT_DEBUG;

a113 1
	sctx->is_debug = (flags & PIPE_CONTEXT_DEBUG) != 0;
a123 1
	si_init_debug_functions(sctx);
d133 13
a145 10
	sctx->b.gfx.cs = ws->cs_create(sctx->b.ctx, RING_GFX, si_context_gfx_flush,
				       sctx, sscreen->b.trace_bo ?
					       sscreen->b.trace_bo->buf : NULL);
	sctx->b.gfx.flush = si_context_gfx_flush;

	/* Border colors. */
	sctx->border_color_table = malloc(SI_MAX_BORDER_COLORS *
					  sizeof(*sctx->border_color_table));
	if (!sctx->border_color_table)
		goto fail;
d147 2
a148 6
	sctx->border_color_buffer = (struct r600_resource*)
		pipe_buffer_create(screen, PIPE_BIND_CUSTOM, PIPE_USAGE_DEFAULT,
				   SI_MAX_BORDER_COLORS *
				   sizeof(*sctx->border_color_table));
	if (!sctx->border_color_buffer)
		goto fail;
d150 2
a151 5
	sctx->border_color_map =
		ws->buffer_map(sctx->border_color_buffer->buf,
			       NULL, PIPE_TRANSFER_WRITE);
	if (!sctx->border_color_map)
		goto fail;
a152 1
	si_init_all_descriptors(sctx);
a163 2
	sctx->sample_mask.sample_mask = 0xffff;

d193 1
a193 1
	sctx->scratch_waves = 32 * sscreen->b.info.num_good_compute_units;
d195 1
d200 1
a200 5
#if HAVE_LLVM >= 0x0308
					   sscreen->b.debug_flags & DBG_SI_SCHED ?
					   	"+DumpCode,+vgpr-spilling,+si-scheduler" :
#endif
					   	"+DumpCode,+vgpr-spilling",
d204 1
a207 1
	fprintf(stderr, "radeonsi: Failed to create a context.\n");
a254 2
	case PIPE_CAP_VERTEX_COLOR_CLAMPED:
	case PIPE_CAP_FRAGMENT_COLOR_CLAMPED:
a274 1
	case PIPE_CAP_SHAREABLE_SHADERS:
a275 12
	case PIPE_CAP_SAMPLER_VIEW_TARGET:
	case PIPE_CAP_TEXTURE_QUERY_LOD:
	case PIPE_CAP_TEXTURE_GATHER_SM5:
	case PIPE_CAP_TGSI_TXQS:
	case PIPE_CAP_FORCE_PERSAMPLE_INTERP:
	case PIPE_CAP_COPY_BETWEEN_COMPRESSED_AND_PLAIN_FORMATS:
	case PIPE_CAP_TGSI_FS_POSITION_IS_SYSVAL:
	case PIPE_CAP_TGSI_FS_FACE_IS_INTEGER_SYSVAL:
	case PIPE_CAP_INVALIDATE_BUFFER:
	case PIPE_CAP_SURFACE_REINTERPRET_BLOCKS:
	case PIPE_CAP_QUERY_MEMORY_INFO:
	case PIPE_CAP_TGSI_PACK_HALF_FLOAT:
a297 1
	case PIPE_CAP_MAX_TEXTURE_GATHER_COMPONENTS:
d306 5
a310 2
	case PIPE_CAP_BUFFER_SAMPLER_VIEW_RGBA_ONLY:
		return 0;
d315 2
d320 1
a321 8
	case PIPE_CAP_CLEAR_TEXTURE:
	case PIPE_CAP_DRAW_PARAMETERS:
	case PIPE_CAP_MULTI_DRAW_INDIRECT:
	case PIPE_CAP_MULTI_DRAW_INDIRECT_PARAMS:
	case PIPE_CAP_SHADER_BUFFER_OFFSET_ALIGNMENT:
	case PIPE_CAP_GENERATE_MIPMAP:
	case PIPE_CAP_STRING_MARKER:
	case PIPE_CAP_QUERY_BUFFER_OBJECT:
d366 1
a366 1
		return SI_MAX_VIEWPORTS;
d371 1
a371 1
		return sscreen->b.info.clock_crystal_freq != 0;
d409 2
a410 1
		if (HAVE_LLVM == 0x0306 && MESA_LLVM_VERSION_PATCH < 2)
d416 3
d420 1
a420 4

		case PIPE_SHADER_CAP_SUPPORTED_IRS:
			return 0;

a483 2
	case PIPE_SHADER_CAP_SUPPORTED_IRS:
		return 0;
a493 3
	case PIPE_SHADER_CAP_MAX_SHADER_BUFFERS:
	case PIPE_SHADER_CAP_MAX_SHADER_IMAGES:
		return 0;
a500 8
	struct si_shader_part *parts[] = {
		sscreen->vs_prologs,
		sscreen->vs_epilogs,
		sscreen->tcs_epilogs,
		sscreen->ps_prologs,
		sscreen->ps_epilogs
	};
	unsigned i;
d502 1
a502 1
	if (!sscreen)
a507 12
	/* Free shader parts. */
	for (i = 0; i < ARRAY_SIZE(parts); i++) {
		while (parts[i]) {
			struct si_shader_part *part = parts[i];

			parts[i] = part->next;
			radeon_shader_binary_clean(&part->binary);
			FREE(part);
		}
	}
	pipe_mutex_destroy(sscreen->shader_parts_mutex);
	si_destroy_shader_cache(sscreen);
d511 6
a516 1
static bool si_init_gs_info(struct si_screen *sscreen)
d518 7
a524 19
	switch (sscreen->b.family) {
	case CHIP_OLAND:
	case CHIP_HAINAN:
	case CHIP_KAVERI:
	case CHIP_KABINI:
	case CHIP_MULLINS:
	case CHIP_ICELAND:
	case CHIP_CARRIZO:
	case CHIP_STONEY:
		sscreen->gs_table_depth = 16;
		return true;
	case CHIP_TAHITI:
	case CHIP_PITCAIRN:
	case CHIP_VERDE:
	case CHIP_BONAIRE:
	case CHIP_HAWAII:
	case CHIP_TONGA:
	case CHIP_FIJI:
		sscreen->gs_table_depth = 32;
d526 27
d554 3
d559 1
d566 1
a566 1
	if (!sscreen) {
d579 1
a579 2
	    !si_init_gs_info(sscreen) ||
	    !si_init_shader_cache(sscreen)) {
a583 3
	if (!debug_get_bool_option("RADEON_DISABLE_PERFCOUNTERS", FALSE))
		si_init_perfcounters(sscreen);

a585 4
	pipe_mutex_init(sscreen->shader_parts_mutex);
	sscreen->use_monolithic_shaders =
		HAVE_LLVM < 0x0308 ||
		(sscreen->b.debug_flags & DBG_MONOLITHIC_SHADERS) != 0;
d591 1
a591 1
	sscreen->b.aux_context = sscreen->b.b.context_create(&sscreen->b.b, NULL, 0);
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d25 1
a26 1
#include "si_shader_internal.h"
d29 1
a31 1
#include "util/u_suballoc.h"
a32 4
#include "../ddebug/dd_util.h"

#define SI_LLVM_DEFAULT_FEATURES \
	"+DumpCode,+vgpr-spilling,-fp32-denormals,+fp64-denormals"
a41 6
	/* Unreference the framebuffer normally to disable related logic
	 * properly.
	 */
	struct pipe_framebuffer_state fb = {};
	context->set_framebuffer_state(context, &fb);

a43 3
	if (sctx->ce_suballocator)
		u_suballocator_destroy(sctx->ce_suballocator);

a46 1
	pipe_resource_reference(&sctx->tess_offchip_ring, NULL);
d51 1
a51 1
	r600_resource_reference(&sctx->compute_scratch_buffer, NULL);
d56 1
a56 1
	for (i = 0; i < ARRAY_SIZE(sctx->vgt_shader_config); i++)
d59 2
d71 1
a71 2
	if (sctx->custom_blend_dcc_decompress)
		sctx->b.b.delete_blend_state(&sctx->b.b, sctx->custom_blend_dcc_decompress);
d82 6
a87 2
	radeon_clear_saved_cs(&sctx->last_gfx);

a98 33
/* Apitrace profiling:
 *   1) qapitrace : Tools -> Profile: Measure CPU & GPU times
 *   2) In the middle panel, zoom in (mouse wheel) on some bad draw call
 *      and remember its number.
 *   3) In Mesa, enable queries and performance counters around that draw
 *      call and print the results.
 *   4) glretrace --benchmark --markers ..
 */
static void si_emit_string_marker(struct pipe_context *ctx,
				  const char *string, int len)
{
	struct si_context *sctx = (struct si_context *)ctx;

	dd_parse_apitrace_marker(string, len, &sctx->apitrace_call_number);
}

static LLVMTargetMachineRef
si_create_llvm_target_machine(struct si_screen *sscreen)
{
	const char *triple = "amdgcn--";

	return LLVMCreateTargetMachine(si_llvm_get_amdgpu_target(triple), triple,
				       r600_get_llvm_processor_name(sscreen->b.family),
#if HAVE_LLVM >= 0x0308
				       sscreen->b.debug_flags & DBG_SI_SCHED ?
					       SI_LLVM_DEFAULT_FEATURES ",+si-scheduler" :
#endif
					       SI_LLVM_DEFAULT_FEATURES,
				       LLVMCodeGenLevelDefault,
				       LLVMRelocDefault,
				       LLVMCodeModelDefault);
}

d105 2
a114 3
	if (flags & PIPE_CONTEXT_DEBUG)
		sscreen->record_llvm_ir = true; /* racy but not critical */

a117 1
	sctx->b.b.emit_string_marker = si_emit_string_marker;
d122 1
a122 1
	if (!r600_common_context_init(&sctx->b, &sscreen->b, flags))
d141 3
a143 26
	sctx->b.gfx.cs = ws->cs_create(sctx->b.ctx, RING_GFX,
				       si_context_gfx_flush, sctx);

	/* SI + AMDGPU + CE = GPU hang */
	if (!(sscreen->b.debug_flags & DBG_NO_CE) && ws->cs_add_const_ib &&
	    sscreen->b.chip_class != SI) {
		sctx->ce_ib = ws->cs_add_const_ib(sctx->b.gfx.cs);
		if (!sctx->ce_ib)
			goto fail;

		if (ws->cs_add_const_preamble_ib) {
			sctx->ce_preamble_ib =
			           ws->cs_add_const_preamble_ib(sctx->b.gfx.cs);

			if (!sctx->ce_preamble_ib)
				goto fail;
		}

		sctx->ce_suballocator =
				u_suballocator_create(&sctx->b.b, 1024 * 1024,
						      PIPE_BIND_CUSTOM,
						      PIPE_USAGE_DEFAULT, false);
		if (!sctx->ce_suballocator)
			goto fail;
	}

a168 5
	if (sctx->b.chip_class >= CIK)
		cik_init_sdma_functions(sctx);
	else
		si_init_dma_functions(sctx);

d183 2
a184 2
	/* CIK cannot unbind a constant buffer (S_BUFFER_LOAD doesn't skip loads
	 * if NUM_RECORDS == 0). We need to use a dummy buffer instead. */
a198 9
		si_set_rw_buffer(sctx, SI_HS_CONST_DEFAULT_TESS_LEVELS,
				 &sctx->null_const_buf);
		si_set_rw_buffer(sctx, SI_VS_CONST_CLIP_PLANES,
				 &sctx->null_const_buf);
		si_set_rw_buffer(sctx, SI_PS_CONST_POLY_STIPPLE,
				 &sctx->null_const_buf);
		si_set_rw_buffer(sctx, SI_PS_CONST_SAMPLE_POSITIONS,
				 &sctx->null_const_buf);

d201 1
a201 2
				     sctx->null_const_buf.buffer->width0, 0,
				     R600_COHERENCY_SHADER);
d204 3
a206 16
	uint64_t max_threads_per_block;
	screen->get_compute_param(screen, PIPE_SHADER_IR_TGSI,
				  PIPE_COMPUTE_CAP_MAX_THREADS_PER_BLOCK,
				  &max_threads_per_block);

	/* The maximum number of scratch waves. Scratch space isn't divided
	 * evenly between CUs. The number is only a function of the number of CUs.
	 * We can decrease the constant to decrease the scratch buffer size.
	 *
	 * sctx->scratch_waves must be >= the maximum posible size of
	 * 1 threadgroup, so that the hw doesn't hang from being unable
	 * to start any.
	 *
	 * The recommended value is 4 per CU at most. Higher numbers don't
	 * bring much benefit, but they still occupy chip resources (think
	 * async compute). I've seen ~2% performance difference between 4 and 32.
d208 1
a208 2
	sctx->scratch_waves = MAX2(32 * sscreen->b.info.num_good_compute_units,
				   max_threads_per_block / 64);
d210 12
a221 1
	sctx->tm = si_create_llvm_target_machine(sscreen);
a232 10
static bool si_have_tgsi_compute(struct si_screen *sscreen)
{
	/* Old kernels disallowed some register writes for SI
	 * that are used for indirect dispatches. */
	return HAVE_LLVM >= 0x309 &&
	       (sscreen->b.chip_class >= CIK ||
		sscreen->b.info.drm_major == 3 ||
		(sscreen->b.info.drm_major == 2 &&
		 sscreen->b.info.drm_minor >= 45));
}
a272 1
	case PIPE_CAP_MIXED_COLOR_DEPTH_BITS:
a308 8
	case PIPE_CAP_FRAMEBUFFER_NO_ATTACHMENT:
	case PIPE_CAP_ROBUST_BUFFER_ACCESS_BEHAVIOR:
	case PIPE_CAP_GENERATE_MIPMAP:
	case PIPE_CAP_POLYGON_OFFSET_UNITS_UNSCALED:
	case PIPE_CAP_STRING_MARKER:
	case PIPE_CAP_CLEAR_TEXTURE:
	case PIPE_CAP_CULL_DISTANCE:
	case PIPE_CAP_TGSI_ARRAY_COMPONENTS:
a332 2
	case PIPE_CAP_SHADER_BUFFER_OFFSET_ALIGNMENT:
		return HAVE_LLVM >= 0x0309 ? 4 : 0;
d335 1
a335 4
		if (si_have_tgsi_compute(sscreen))
			return 430;
		return HAVE_LLVM >= 0x0309 ? 420 :
		       HAVE_LLVM >= 0x0307 ? 410 : 330;
d338 1
a338 1
		return MIN2(sscreen->b.info.max_alloc_size, INT_MAX);
d350 1
a350 8
	case PIPE_CAP_PRIMITIVE_RESTART_FOR_PATCHES:
	case PIPE_CAP_TGSI_VOTE:
	case PIPE_CAP_MAX_WINDOW_RECTANGLES:
		return 0;

	case PIPE_CAP_QUERY_BUFFER_OBJECT:
		return si_have_tgsi_compute(sscreen);

d354 5
a358 1
		return sscreen->has_draw_indirect_multi;
d402 1
a402 3
		return R600_MAX_VIEWPORTS;
	case PIPE_CAP_VIEWPORT_SUBPIXEL_BITS:
		return 8;
d421 1
a421 1
		return ATI_VENDOR_ID;
a429 8
	case PIPE_CAP_PCI_GROUP:
		return sscreen->b.info.pci_domain;
	case PIPE_CAP_PCI_BUS:
		return sscreen->b.info.pci_bus;
	case PIPE_CAP_PCI_DEVICE:
		return sscreen->b.info.pci_dev;
	case PIPE_CAP_PCI_FUNCTION:
		return sscreen->b.info.pci_func;
a435 2
	struct si_screen *sscreen = (struct si_screen *)pscreen;

d453 2
a454 5
		case PIPE_SHADER_CAP_SUPPORTED_IRS: {
			int ir = 1 << PIPE_SHADER_IR_NATIVE;

			if (si_have_tgsi_compute(sscreen))
				ir |= 1 << PIPE_SHADER_IR_TGSI;
a455 2
			return ir;
		}
d461 1
a461 1
			pscreen->get_compute_param(pscreen, PIPE_SHADER_IR_TGSI,
d464 1
a464 1
			return MIN2(max_const_buffer_size, INT_MAX);
d494 1
a494 1
		return SI_NUM_CONST_BUFFERS;
d516 1
a516 1
		return SI_NUM_SAMPLERS;
a531 1
		return HAVE_LLVM >= 0x0309 ? SI_NUM_SHADER_BUFFERS : 0;
d533 1
a533 1
		return HAVE_LLVM >= 0x0309 ? SI_NUM_IMAGES : 0;
a555 7
	if (util_queue_is_initialized(&sscreen->shader_compiler_queue))
		util_queue_destroy(&sscreen->shader_compiler_queue);

	for (i = 0; i < ARRAY_SIZE(sscreen->tm); i++)
		if (sscreen->tm[i])
			LLVMDisposeTargetMachine(sscreen->tm[i]);

a590 2
	case CHIP_POLARIS10:
	case CHIP_POLARIS11:
a597 30
static void si_handle_env_var_force_family(struct si_screen *sscreen)
{
	const char *family = debug_get_option("SI_FORCE_FAMILY", NULL);
	unsigned i;

	if (!family)
		return;

	for (i = CHIP_TAHITI; i < CHIP_LAST; i++) {
		if (!strcmp(family, r600_get_llvm_processor_name(i))) {
			/* Override family and chip_class. */
			sscreen->b.family = sscreen->b.info.family = i;

			if (i >= CHIP_TONGA)
				sscreen->b.chip_class = sscreen->b.info.chip_class = VI;
			else if (i >= CHIP_BONAIRE)
				sscreen->b.chip_class = sscreen->b.info.chip_class = CIK;
			else
				sscreen->b.chip_class = sscreen->b.info.chip_class = SI;

			/* Don't submit any IBs. */
			setenv("RADEON_NOOP", "1", 1);
			return;
		}
	}

	fprintf(stderr, "radeonsi: Unknown family: %s\n", family);
	exit(1);
}

a600 1
	unsigned num_cpus, num_compiler_threads, i;
d611 1
a613 2
	si_init_screen_state_functions(sscreen);

d621 1
a621 3
	si_handle_env_var_force_family(sscreen);

	if (!debug_get_bool_option("RADEON_DISABLE_PERFCOUNTERS", false))
a623 25
	/* Hawaii has a bug with offchip buffers > 256 that can be worked
	 * around by setting 4K granularity.
	 */
	sscreen->tess_offchip_block_dw_size =
		sscreen->b.family == CHIP_HAWAII ? 4096 : 8192;

	sscreen->has_distributed_tess =
		sscreen->b.chip_class >= VI &&
		sscreen->b.info.max_se >= 2;

	sscreen->has_draw_indirect_multi =
		(sscreen->b.family >= CHIP_POLARIS10) ||
		(sscreen->b.chip_class == VI &&
		 sscreen->b.info.pfp_fw_version >= 121 &&
		 sscreen->b.info.me_fw_version >= 87) ||
		(sscreen->b.chip_class == CIK &&
		 sscreen->b.info.pfp_fw_version >= 211 &&
		 sscreen->b.info.me_fw_version >= 173) ||
		(sscreen->b.chip_class == SI &&
		 sscreen->b.info.pfp_fw_version >= 121 &&
		 sscreen->b.info.me_fw_version >= 87);

	sscreen->has_ds_bpermute = HAVE_LLVM >= 0x0309 &&
				   sscreen->b.chip_class >= VI;

d631 1
a631 6
	sscreen->b.barrier_flags.cp_to_L2 = SI_CONTEXT_INV_SMEM_L1 |
					    SI_CONTEXT_INV_VMEM_L1 |
					    SI_CONTEXT_INV_GLOBAL_L2;
	sscreen->b.barrier_flags.compute_to_L2 = SI_CONTEXT_CS_PARTIAL_FLUSH;

	if (debug_get_bool_option("RADEON_DUMP_SHADERS", false))
a633 10
	/* Only enable as many threads as we have target machines and CPUs. */
	num_cpus = sysconf(_SC_NPROCESSORS_ONLN);
	num_compiler_threads = MIN2(num_cpus, ARRAY_SIZE(sscreen->tm));

	for (i = 0; i < num_compiler_threads; i++)
		sscreen->tm[i] = si_create_llvm_target_machine(sscreen);

	util_queue_init(&sscreen->shader_compiler_queue, "si_shader",
                        32, num_compiler_threads);

a635 3

	if (sscreen->b.debug_flags & DBG_TEST_DMA)
		r600_test_dma(&sscreen->b);
@


1.1.1.4
log
@Import Mesa 13.0.3
@
text
@d190 1
a190 4
	    sscreen->b.chip_class != SI &&
	    /* These can't use CE due to a power gating bug in the kernel. */
	    sscreen->b.family != CHIP_CARRIZO &&
	    sscreen->b.family != CHIP_STONEY) {
@


1.1.1.5
log
@Import Mesa 17.1.6
@
text
@a31 1
#include "util/u_tests.h"
d35 3
a127 6
	char features[256];

	snprintf(features, sizeof(features),
		 "+DumpCode,+vgpr-spilling,-fp32-denormals,+fp64-denormals%s%s",
		 sscreen->b.chip_class >= GFX9 ? ",+xnack" : ",-xnack",
		 sscreen->b.debug_flags & DBG_SI_SCHED ? ",+si-scheduler" : "");
d131 5
a135 1
				       features,
d193 1
a193 4
	    sscreen->b.family != CHIP_STONEY &&
	    /* Some CE bug is causing green screen corruption w/ MPV video
	     * playback and occasional corruption w/ 3D. */
	    sscreen->b.chip_class != GFX9) {
d207 3
a209 3
			u_suballocator_create(&sctx->b.b, 1024 * 1024, 0,
					      PIPE_USAGE_DEFAULT,
					      R600_RESOURCE_FLAG_UNMAPPABLE, false);
d223 1
a223 1
		pipe_buffer_create(screen, 0, PIPE_USAGE_DEFAULT,
a237 1
	si_init_ia_multi_vgt_param_table(sctx);
d256 1
d261 2
a262 5
		sctx->null_const_buf.buffer =
			r600_aligned_buffer_create(screen,
						   R600_RESOURCE_FLAG_UNMAPPABLE,
						   PIPE_USAGE_DEFAULT, 16,
						   sctx->screen->b.info.tcc_cache_line_size);
a337 1
	case PIPE_CAP_ACCELERATED:
d363 4
a415 7
	case PIPE_CAP_TGSI_CAN_READ_OUTPUTS:
	case PIPE_CAP_GLSL_OPTIMIZE_CONSERVATIVELY:
	case PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME:
	case PIPE_CAP_STREAM_OUTPUT_INTERLEAVE_BUFFERS:
	case PIPE_CAP_DOUBLES:
	case PIPE_CAP_TGSI_TEX_TXF_LZ:
	case PIPE_CAP_TGSI_TES_LAYER_VIEWPORT:
a417 11
	case PIPE_CAP_INT64:
	case PIPE_CAP_INT64_DIVMOD:
	case PIPE_CAP_TGSI_CLOCK:
		return HAVE_LLVM >= 0x0309;

	case PIPE_CAP_TGSI_VOTE:
		return HAVE_LLVM >= 0x0400;

	case PIPE_CAP_TGSI_BALLOT:
		return HAVE_LLVM >= 0x0500;

a438 2
	case PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS:
	case PIPE_CAP_MAX_VERTEX_STREAMS:
a439 1

a443 2
		if (sscreen->b.chip_class >= GFX9)
			return 140;
d445 3
a447 2
			return 450;
		return HAVE_LLVM >= 0x0309 ? 420 : 410;
d452 1
a452 17
	case PIPE_CAP_VERTEX_BUFFER_OFFSET_4BYTE_ALIGNED_ONLY:
	case PIPE_CAP_VERTEX_BUFFER_STRIDE_4BYTE_ALIGNED_ONLY:
	case PIPE_CAP_VERTEX_ELEMENT_SRC_OFFSET_4BYTE_ALIGNED_ONLY:
		/* SI doesn't support unaligned loads.
		 * CIK needs DRM 2.50.0 on radeon. */
		return sscreen->b.chip_class == SI ||
		       (sscreen->b.info.drm_major == 2 &&
			sscreen->b.info.drm_minor < 50);

	case PIPE_CAP_SPARSE_BUFFER_PAGE_SIZE:
		/* Disable on SI due to VM faults in CP DMA. Enable once these
		 * faults are mitigated in software.
		 */
		if (sscreen->b.chip_class >= CIK &&
		    sscreen->b.info.drm_major == 3 &&
		    sscreen->b.info.drm_minor >= 13)
			return RADEON_SPARSE_PAGE_SIZE;
a455 1
	case PIPE_CAP_BUFFER_SAMPLER_VIEW_RGBA_ONLY:
d463 1
a464 5
	case PIPE_CAP_NATIVE_FENCE_FD:
	case PIPE_CAP_TGSI_FS_FBFETCH:
	case PIPE_CAP_TGSI_MUL_ZERO_WINS:
	case PIPE_CAP_UMA:
	case PIPE_CAP_POLYGON_MODE_FILL_RECTANGLE:
d479 1
a479 2
		return sscreen->b.chip_class <= VI ?
			PIPE_QUIRK_TEXTURE_BORDER_COLOR_SWIZZLE_R600 : 0;
d482 4
d488 1
a488 1
		return 32*4;
d495 2
d512 4
a515 1
	/* Viewports and render targets. */
a518 1
	case PIPE_CAP_MAX_RENDER_TARGETS:
d541 2
d545 2
d559 1
a559 3
static int si_get_shader_param(struct pipe_screen* pscreen,
			       enum pipe_shader_type shader,
			       enum pipe_shader_cap param)
d567 1
a568 1
	case PIPE_SHADER_GEOMETRY:
d571 2
a572 1
		if (sscreen->b.chip_class >= GFX9)
d588 2
a609 1
	/* Shader limits. */
d614 1
d616 1
a616 1
		return 16384;
d618 1
a618 1
		return shader == PIPE_SHADER_VERTEX ? SI_MAX_ATTRIBS : 32;
d627 2
a628 15
	case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
	case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
		return SI_NUM_SAMPLERS;
	case PIPE_SHADER_CAP_MAX_SHADER_BUFFERS:
		return HAVE_LLVM >= 0x0309 ? SI_NUM_SHADER_BUFFERS : 0;
	case PIPE_SHADER_CAP_MAX_SHADER_IMAGES:
		return HAVE_LLVM >= 0x0309 ? SI_NUM_IMAGES : 0;
	case PIPE_SHADER_CAP_MAX_UNROLL_ITERATIONS_HINT:
		return 32;
	case PIPE_SHADER_CAP_PREFERRED_IR:
		return PIPE_SHADER_IR_TGSI;
	case PIPE_SHADER_CAP_LOWER_IF_THRESHOLD:
		return 3;

	/* Supported boolean features. */
d630 1
d632 6
d641 1
a642 2
	case PIPE_SHADER_CAP_TGSI_FMA_SUPPORTED:
	case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
a643 8

	case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR:
		/* TODO: Indirection of geometry shader input dimension is not
		 * handled yet
		 */
		return shader != PIPE_SHADER_GEOMETRY;

	/* Unsupported boolean features. */
d645 6
d652 3
d658 9
a677 1
		sscreen->gs_prologs,
d683 3
d689 2
a690 1
	util_queue_destroy(&sscreen->shader_compiler_queue);
d706 1
a706 1
	mtx_destroy(&sscreen->shader_parts_mutex);
a732 3
	case CHIP_POLARIS12:
	case CHIP_VEGA10:
	case CHIP_RAVEN:
d753 1
a753 3
			if (i >= CHIP_VEGA10)
				sscreen->b.chip_class = sscreen->b.info.chip_class = GFX9;
			else if (i >= CHIP_TONGA)
a769 31
static void si_test_vmfault(struct si_screen *sscreen)
{
	struct pipe_context *ctx = sscreen->b.aux_context;
	struct si_context *sctx = (struct si_context *)ctx;
	struct pipe_resource *buf =
		pipe_buffer_create(&sscreen->b.b, 0, PIPE_USAGE_DEFAULT, 64);

	if (!buf) {
		puts("Buffer allocation failed.");
		exit(1);
	}

	r600_resource(buf)->gpu_address = 0; /* cause a VM fault */

	if (sscreen->b.debug_flags & DBG_TEST_VMFAULT_CP) {
		si_copy_buffer(sctx, buf, buf, 0, 4, 4, 0);
		ctx->flush(ctx, NULL, 0);
		puts("VM fault test: CP - done.");
	}
	if (sscreen->b.debug_flags & DBG_TEST_VMFAULT_SDMA) {
		sctx->b.dma_clear_buffer(ctx, buf, 0, 4, 0);
		ctx->flush(ctx, NULL, 0);
		puts("VM fault test: SDMA - done.");
	}
	if (sscreen->b.debug_flags & DBG_TEST_VMFAULT_SHADER) {
		util_test_constant_buffer(ctx, buf);
		puts("VM fault test: Shader - done.");
	}
	exit(0);
}

a794 11
	/* Only enable as many threads as we have target machines and CPUs. */
	num_cpus = sysconf(_SC_NPROCESSORS_ONLN);
	num_compiler_threads = MIN2(num_cpus, ARRAY_SIZE(sscreen->tm));

	if (!util_queue_init(&sscreen->shader_compiler_queue, "si_shader",
			     32, num_compiler_threads)) {
		si_destroy_shader_cache(sscreen);
		FREE(sscreen);
		return NULL;
	}

d819 2
a820 2
		 sscreen->b.info.pfp_fw_version >= 79 &&
		 sscreen->b.info.me_fw_version >= 142);
a824 5
	sscreen->has_msaa_sample_loc_bug = (sscreen->b.family >= CHIP_POLARIS10 &&
					    sscreen->b.family <= CHIP_POLARIS12) ||
					   sscreen->b.family == CHIP_VEGA10 ||
					   sscreen->b.family == CHIP_RAVEN;

d827 1
a827 15

	/* Some chips have RB+ registers, but don't support RB+. Those must
	 * always disable it.
	 */
	if (sscreen->b.family == CHIP_STONEY ||
	    sscreen->b.chip_class >= GFX9) {
		sscreen->b.has_rbplus = true;

		sscreen->b.rbplus_allowed =
			!(sscreen->b.debug_flags & DBG_NO_RB_PLUS) &&
			(sscreen->b.family == CHIP_STONEY ||
			 sscreen->b.family == CHIP_RAVEN);
	}

	(void) mtx_init(&sscreen->shader_parts_mutex, mtx_plain);
d829 1
d840 4
d847 3
a854 5

	if (sscreen->b.debug_flags & (DBG_TEST_VMFAULT_CP |
				      DBG_TEST_VMFAULT_SDMA |
				      DBG_TEST_VMFAULT_SHADER))
		si_test_vmfault(sscreen);
@


