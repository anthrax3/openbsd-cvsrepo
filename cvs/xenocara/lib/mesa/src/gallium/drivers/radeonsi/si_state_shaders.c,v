head	1.1;
branch	1.1.1;
access;
symbols
	mesa-17_1_6:1.1.1.8
	OPENBSD_6_1:1.1.1.7.0.2
	OPENBSD_6_1_BASE:1.1.1.7
	mesa-13_0_6:1.1.1.7
	mesa-13_0_5:1.1.1.6
	mesa-13_0_3:1.1.1.6
	mesa-13_0_2:1.1.1.5
	OPENBSD_6_0:1.1.1.4.0.4
	OPENBSD_6_0_BASE:1.1.1.4
	mesa-11_2_2:1.1.1.4
	OPENBSD_5_9:1.1.1.3.0.2
	OPENBSD_5_9_BASE:1.1.1.3
	mesa-11_0_9:1.1.1.3
	mesa-11_0_8:1.1.1.2
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.44.31;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.31;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2015.12.23.13.26.27;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	bCnCUEGWDw3j16Q3;

1.1.1.3
date	2016.01.24.01.07.12;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	RyA9f3MEvZ0C08g3;

1.1.1.4
date	2016.05.29.10.20.06;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.5
date	2016.12.11.08.28.14;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	uuv5VTS15jglEDZU;

1.1.1.6
date	2017.01.19.05.39.46;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	vYSESphXPMoytdgU;

1.1.1.7
date	2017.03.25.00.07.48;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	YgkKuQ9hssScckR1;

1.1.1.8
date	2017.08.14.09.33.00;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright 2012 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *      Christian König <christian.koenig@@amd.com>
 *      Marek Olšák <maraeo@@gmail.com>
 */

#include "si_pipe.h"
#include "si_shader.h"
#include "sid.h"

#include "tgsi/tgsi_parse.h"
#include "tgsi/tgsi_ureg.h"
#include "util/u_memory.h"
#include "util/u_simple_shaders.h"

static void si_set_tesseval_regs(struct si_shader *shader,
				 struct si_pm4_state *pm4)
{
	struct tgsi_shader_info *info = &shader->selector->info;
	unsigned tes_prim_mode = info->properties[TGSI_PROPERTY_TES_PRIM_MODE];
	unsigned tes_spacing = info->properties[TGSI_PROPERTY_TES_SPACING];
	bool tes_vertex_order_cw = info->properties[TGSI_PROPERTY_TES_VERTEX_ORDER_CW];
	bool tes_point_mode = info->properties[TGSI_PROPERTY_TES_POINT_MODE];
	unsigned type, partitioning, topology;

	switch (tes_prim_mode) {
	case PIPE_PRIM_LINES:
		type = V_028B6C_TESS_ISOLINE;
		break;
	case PIPE_PRIM_TRIANGLES:
		type = V_028B6C_TESS_TRIANGLE;
		break;
	case PIPE_PRIM_QUADS:
		type = V_028B6C_TESS_QUAD;
		break;
	default:
		assert(0);
		return;
	}

	switch (tes_spacing) {
	case PIPE_TESS_SPACING_FRACTIONAL_ODD:
		partitioning = V_028B6C_PART_FRAC_ODD;
		break;
	case PIPE_TESS_SPACING_FRACTIONAL_EVEN:
		partitioning = V_028B6C_PART_FRAC_EVEN;
		break;
	case PIPE_TESS_SPACING_EQUAL:
		partitioning = V_028B6C_PART_INTEGER;
		break;
	default:
		assert(0);
		return;
	}

	if (tes_point_mode)
		topology = V_028B6C_OUTPUT_POINT;
	else if (tes_prim_mode == PIPE_PRIM_LINES)
		topology = V_028B6C_OUTPUT_LINE;
	else if (tes_vertex_order_cw)
		/* for some reason, this must be the other way around */
		topology = V_028B6C_OUTPUT_TRIANGLE_CCW;
	else
		topology = V_028B6C_OUTPUT_TRIANGLE_CW;

	si_pm4_set_reg(pm4, R_028B6C_VGT_TF_PARAM,
		       S_028B6C_TYPE(type) |
		       S_028B6C_PARTITIONING(partitioning) |
		       S_028B6C_TOPOLOGY(topology));
}

static void si_shader_ls(struct si_shader *shader)
{
	struct si_pm4_state *pm4;
	unsigned num_sgprs, num_user_sgprs;
	unsigned vgpr_comp_cnt;
	uint64_t va;

	pm4 = shader->pm4 = CALLOC_STRUCT(si_pm4_state);
	if (pm4 == NULL)
		return;

	va = shader->bo->gpu_address;
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_DATA);

	/* We need at least 2 components for LS.
	 * VGPR0-3: (VertexID, RelAutoindex, ???, InstanceID). */
	vgpr_comp_cnt = shader->uses_instanceid ? 3 : 1;

	num_user_sgprs = SI_LS_NUM_USER_SGPR;
	num_sgprs = shader->num_sgprs;
	if (num_user_sgprs > num_sgprs) {
		/* Last 2 reserved SGPRs are used for VCC */
		num_sgprs = num_user_sgprs + 2;
	}
	assert(num_sgprs <= 104);

	si_pm4_set_reg(pm4, R_00B520_SPI_SHADER_PGM_LO_LS, va >> 8);
	si_pm4_set_reg(pm4, R_00B524_SPI_SHADER_PGM_HI_LS, va >> 40);

	shader->ls_rsrc1 = S_00B528_VGPRS((shader->num_vgprs - 1) / 4) |
			   S_00B528_SGPRS((num_sgprs - 1) / 8) |
		           S_00B528_VGPR_COMP_CNT(vgpr_comp_cnt);
	shader->ls_rsrc2 = S_00B52C_USER_SGPR(num_user_sgprs) |
			   S_00B52C_SCRATCH_EN(shader->scratch_bytes_per_wave > 0);
}

static void si_shader_hs(struct si_shader *shader)
{
	struct si_pm4_state *pm4;
	unsigned num_sgprs, num_user_sgprs;
	uint64_t va;

	pm4 = shader->pm4 = CALLOC_STRUCT(si_pm4_state);
	if (pm4 == NULL)
		return;

	va = shader->bo->gpu_address;
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_DATA);

	num_user_sgprs = SI_TCS_NUM_USER_SGPR;
	num_sgprs = shader->num_sgprs;
	/* One SGPR after user SGPRs is pre-loaded with tessellation factor
	 * buffer offset. */
	if ((num_user_sgprs + 1) > num_sgprs) {
		/* Last 2 reserved SGPRs are used for VCC */
		num_sgprs = num_user_sgprs + 1 + 2;
	}
	assert(num_sgprs <= 104);

	si_pm4_set_reg(pm4, R_00B420_SPI_SHADER_PGM_LO_HS, va >> 8);
	si_pm4_set_reg(pm4, R_00B424_SPI_SHADER_PGM_HI_HS, va >> 40);
	si_pm4_set_reg(pm4, R_00B428_SPI_SHADER_PGM_RSRC1_HS,
		       S_00B428_VGPRS((shader->num_vgprs - 1) / 4) |
		       S_00B428_SGPRS((num_sgprs - 1) / 8));
	si_pm4_set_reg(pm4, R_00B42C_SPI_SHADER_PGM_RSRC2_HS,
		       S_00B42C_USER_SGPR(num_user_sgprs) |
		       S_00B42C_SCRATCH_EN(shader->scratch_bytes_per_wave > 0));
}

static void si_shader_es(struct si_shader *shader)
{
	struct si_pm4_state *pm4;
	unsigned num_sgprs, num_user_sgprs;
	unsigned vgpr_comp_cnt;
	uint64_t va;

	pm4 = shader->pm4 = CALLOC_STRUCT(si_pm4_state);

	if (pm4 == NULL)
		return;

	va = shader->bo->gpu_address;
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_DATA);

	if (shader->selector->type == PIPE_SHADER_VERTEX) {
		vgpr_comp_cnt = shader->uses_instanceid ? 3 : 0;
		num_user_sgprs = SI_VS_NUM_USER_SGPR;
	} else if (shader->selector->type == PIPE_SHADER_TESS_EVAL) {
		vgpr_comp_cnt = 3; /* all components are needed for TES */
		num_user_sgprs = SI_TES_NUM_USER_SGPR;
	} else
		assert(0);

	num_sgprs = shader->num_sgprs;
	/* One SGPR after user SGPRs is pre-loaded with es2gs_offset */
	if ((num_user_sgprs + 1) > num_sgprs) {
		/* Last 2 reserved SGPRs are used for VCC */
		num_sgprs = num_user_sgprs + 1 + 2;
	}
	assert(num_sgprs <= 104);

	si_pm4_set_reg(pm4, R_00B320_SPI_SHADER_PGM_LO_ES, va >> 8);
	si_pm4_set_reg(pm4, R_00B324_SPI_SHADER_PGM_HI_ES, va >> 40);
	si_pm4_set_reg(pm4, R_00B328_SPI_SHADER_PGM_RSRC1_ES,
		       S_00B328_VGPRS((shader->num_vgprs - 1) / 4) |
		       S_00B328_SGPRS((num_sgprs - 1) / 8) |
		       S_00B328_VGPR_COMP_CNT(vgpr_comp_cnt) |
		       S_00B328_DX10_CLAMP(shader->dx10_clamp_mode));
	si_pm4_set_reg(pm4, R_00B32C_SPI_SHADER_PGM_RSRC2_ES,
		       S_00B32C_USER_SGPR(num_user_sgprs) |
		       S_00B32C_SCRATCH_EN(shader->scratch_bytes_per_wave > 0));

	if (shader->selector->type == PIPE_SHADER_TESS_EVAL)
		si_set_tesseval_regs(shader, pm4);
}

static unsigned si_gs_get_max_stream(struct si_shader *shader)
{
	struct pipe_stream_output_info *so = &shader->selector->so;
	unsigned max_stream = 0, i;

	if (so->num_outputs == 0)
		return 0;

	for (i = 0; i < so->num_outputs; i++) {
		if (so->output[i].stream > max_stream)
			max_stream = so->output[i].stream;
	}
	return max_stream;
}

static void si_shader_gs(struct si_shader *shader)
{
	unsigned gs_vert_itemsize = shader->selector->info.num_outputs * 16;
	unsigned gs_max_vert_out = shader->selector->gs_max_out_vertices;
	unsigned gsvs_itemsize = (gs_vert_itemsize * gs_max_vert_out) >> 2;
	unsigned gs_num_invocations = shader->selector->gs_num_invocations;
	unsigned cut_mode;
	struct si_pm4_state *pm4;
	unsigned num_sgprs, num_user_sgprs;
	uint64_t va;
	unsigned max_stream = si_gs_get_max_stream(shader);

	/* The GSVS_RING_ITEMSIZE register takes 15 bits */
	assert(gsvs_itemsize < (1 << 15));

	pm4 = shader->pm4 = CALLOC_STRUCT(si_pm4_state);

	if (pm4 == NULL)
		return;

	if (gs_max_vert_out <= 128) {
		cut_mode = V_028A40_GS_CUT_128;
	} else if (gs_max_vert_out <= 256) {
		cut_mode = V_028A40_GS_CUT_256;
	} else if (gs_max_vert_out <= 512) {
		cut_mode = V_028A40_GS_CUT_512;
	} else {
		assert(gs_max_vert_out <= 1024);
		cut_mode = V_028A40_GS_CUT_1024;
	}

	si_pm4_set_reg(pm4, R_028A40_VGT_GS_MODE,
		       S_028A40_MODE(V_028A40_GS_SCENARIO_G) |
		       S_028A40_CUT_MODE(cut_mode)|
		       S_028A40_ES_WRITE_OPTIMIZE(1) |
		       S_028A40_GS_WRITE_OPTIMIZE(1));

	si_pm4_set_reg(pm4, R_028A60_VGT_GSVS_RING_OFFSET_1, gsvs_itemsize);
	si_pm4_set_reg(pm4, R_028A64_VGT_GSVS_RING_OFFSET_2, gsvs_itemsize * ((max_stream >= 2) ? 2 : 1));
	si_pm4_set_reg(pm4, R_028A68_VGT_GSVS_RING_OFFSET_3, gsvs_itemsize * ((max_stream >= 3) ? 3 : 1));

	si_pm4_set_reg(pm4, R_028AAC_VGT_ESGS_RING_ITEMSIZE,
		       util_bitcount64(shader->selector->inputs_read) * (16 >> 2));
	si_pm4_set_reg(pm4, R_028AB0_VGT_GSVS_RING_ITEMSIZE, gsvs_itemsize * (max_stream + 1));

	si_pm4_set_reg(pm4, R_028B38_VGT_GS_MAX_VERT_OUT, gs_max_vert_out);

	si_pm4_set_reg(pm4, R_028B5C_VGT_GS_VERT_ITEMSIZE, gs_vert_itemsize >> 2);
	si_pm4_set_reg(pm4, R_028B60_VGT_GS_VERT_ITEMSIZE_1, (max_stream >= 1) ? gs_vert_itemsize >> 2 : 0);
	si_pm4_set_reg(pm4, R_028B64_VGT_GS_VERT_ITEMSIZE_2, (max_stream >= 2) ? gs_vert_itemsize >> 2 : 0);
	si_pm4_set_reg(pm4, R_028B68_VGT_GS_VERT_ITEMSIZE_3, (max_stream >= 3) ? gs_vert_itemsize >> 2 : 0);

	si_pm4_set_reg(pm4, R_028B90_VGT_GS_INSTANCE_CNT,
		       S_028B90_CNT(MIN2(gs_num_invocations, 127)) |
		       S_028B90_ENABLE(gs_num_invocations > 0));

	va = shader->bo->gpu_address;
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_DATA);
	si_pm4_set_reg(pm4, R_00B220_SPI_SHADER_PGM_LO_GS, va >> 8);
	si_pm4_set_reg(pm4, R_00B224_SPI_SHADER_PGM_HI_GS, va >> 40);

	num_user_sgprs = SI_GS_NUM_USER_SGPR;
	num_sgprs = shader->num_sgprs;
	/* Two SGPRs after user SGPRs are pre-loaded with gs2vs_offset, gs_wave_id */
	if ((num_user_sgprs + 2) > num_sgprs) {
		/* Last 2 reserved SGPRs are used for VCC */
		num_sgprs = num_user_sgprs + 2 + 2;
	}
	assert(num_sgprs <= 104);

	si_pm4_set_reg(pm4, R_00B228_SPI_SHADER_PGM_RSRC1_GS,
		       S_00B228_VGPRS((shader->num_vgprs - 1) / 4) |
		       S_00B228_SGPRS((num_sgprs - 1) / 8) |
		       S_00B228_DX10_CLAMP(shader->dx10_clamp_mode));
	si_pm4_set_reg(pm4, R_00B22C_SPI_SHADER_PGM_RSRC2_GS,
		       S_00B22C_USER_SGPR(num_user_sgprs) |
		       S_00B22C_SCRATCH_EN(shader->scratch_bytes_per_wave > 0));
}

static void si_shader_vs(struct si_shader *shader)
{
	struct si_pm4_state *pm4;
	unsigned num_sgprs, num_user_sgprs;
	unsigned nparams, vgpr_comp_cnt;
	uint64_t va;
	unsigned window_space =
	   shader->selector->info.properties[TGSI_PROPERTY_VS_WINDOW_SPACE_POSITION];
	bool enable_prim_id = si_vs_exports_prim_id(shader);

	pm4 = shader->pm4 = CALLOC_STRUCT(si_pm4_state);

	if (pm4 == NULL)
		return;

	/* If this is the GS copy shader, the GS state writes this register.
	 * Otherwise, the VS state writes it.
	 */
	if (!shader->is_gs_copy_shader) {
		si_pm4_set_reg(pm4, R_028A40_VGT_GS_MODE,
			       S_028A40_MODE(enable_prim_id ? V_028A40_GS_SCENARIO_A : 0));
		si_pm4_set_reg(pm4, R_028A84_VGT_PRIMITIVEID_EN, enable_prim_id);
	} else
		si_pm4_set_reg(pm4, R_028A84_VGT_PRIMITIVEID_EN, 0);

	va = shader->bo->gpu_address;
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_DATA);

	if (shader->is_gs_copy_shader) {
		vgpr_comp_cnt = 0; /* only VertexID is needed for GS-COPY. */
		num_user_sgprs = SI_GSCOPY_NUM_USER_SGPR;
	} else if (shader->selector->type == PIPE_SHADER_VERTEX) {
		vgpr_comp_cnt = shader->uses_instanceid ? 3 : (enable_prim_id ? 2 : 0);
		num_user_sgprs = SI_VS_NUM_USER_SGPR;
	} else if (shader->selector->type == PIPE_SHADER_TESS_EVAL) {
		vgpr_comp_cnt = 3; /* all components are needed for TES */
		num_user_sgprs = SI_TES_NUM_USER_SGPR;
	} else
		assert(0);

	num_sgprs = shader->num_sgprs;
	if (num_user_sgprs > num_sgprs) {
		/* Last 2 reserved SGPRs are used for VCC */
		num_sgprs = num_user_sgprs + 2;
	}
	assert(num_sgprs <= 104);

	/* VS is required to export at least one param. */
	nparams = MAX2(shader->nr_param_exports, 1);
	si_pm4_set_reg(pm4, R_0286C4_SPI_VS_OUT_CONFIG,
		       S_0286C4_VS_EXPORT_COUNT(nparams - 1));

	si_pm4_set_reg(pm4, R_02870C_SPI_SHADER_POS_FORMAT,
		       S_02870C_POS0_EXPORT_FORMAT(V_02870C_SPI_SHADER_4COMP) |
		       S_02870C_POS1_EXPORT_FORMAT(shader->nr_pos_exports > 1 ?
						   V_02870C_SPI_SHADER_4COMP :
						   V_02870C_SPI_SHADER_NONE) |
		       S_02870C_POS2_EXPORT_FORMAT(shader->nr_pos_exports > 2 ?
						   V_02870C_SPI_SHADER_4COMP :
						   V_02870C_SPI_SHADER_NONE) |
		       S_02870C_POS3_EXPORT_FORMAT(shader->nr_pos_exports > 3 ?
						   V_02870C_SPI_SHADER_4COMP :
						   V_02870C_SPI_SHADER_NONE));

	si_pm4_set_reg(pm4, R_00B120_SPI_SHADER_PGM_LO_VS, va >> 8);
	si_pm4_set_reg(pm4, R_00B124_SPI_SHADER_PGM_HI_VS, va >> 40);
	si_pm4_set_reg(pm4, R_00B128_SPI_SHADER_PGM_RSRC1_VS,
		       S_00B128_VGPRS((shader->num_vgprs - 1) / 4) |
		       S_00B128_SGPRS((num_sgprs - 1) / 8) |
		       S_00B128_VGPR_COMP_CNT(vgpr_comp_cnt) |
		       S_00B128_DX10_CLAMP(shader->dx10_clamp_mode));
	si_pm4_set_reg(pm4, R_00B12C_SPI_SHADER_PGM_RSRC2_VS,
		       S_00B12C_USER_SGPR(num_user_sgprs) |
		       S_00B12C_SO_BASE0_EN(!!shader->selector->so.stride[0]) |
		       S_00B12C_SO_BASE1_EN(!!shader->selector->so.stride[1]) |
		       S_00B12C_SO_BASE2_EN(!!shader->selector->so.stride[2]) |
		       S_00B12C_SO_BASE3_EN(!!shader->selector->so.stride[3]) |
		       S_00B12C_SO_EN(!!shader->selector->so.num_outputs) |
		       S_00B12C_SCRATCH_EN(shader->scratch_bytes_per_wave > 0));
	if (window_space)
		si_pm4_set_reg(pm4, R_028818_PA_CL_VTE_CNTL,
			       S_028818_VTX_XY_FMT(1) | S_028818_VTX_Z_FMT(1));
	else
		si_pm4_set_reg(pm4, R_028818_PA_CL_VTE_CNTL,
			       S_028818_VTX_W0_FMT(1) |
			       S_028818_VPORT_X_SCALE_ENA(1) | S_028818_VPORT_X_OFFSET_ENA(1) |
			       S_028818_VPORT_Y_SCALE_ENA(1) | S_028818_VPORT_Y_OFFSET_ENA(1) |
			       S_028818_VPORT_Z_SCALE_ENA(1) | S_028818_VPORT_Z_OFFSET_ENA(1));

	if (shader->selector->type == PIPE_SHADER_TESS_EVAL)
		si_set_tesseval_regs(shader, pm4);
}

static void si_shader_ps(struct si_shader *shader)
{
	struct tgsi_shader_info *info = &shader->selector->info;
	struct si_pm4_state *pm4;
	unsigned i, spi_ps_in_control;
	unsigned num_sgprs, num_user_sgprs;
	unsigned spi_baryc_cntl = 0, spi_ps_input_ena;
	uint64_t va;

	pm4 = shader->pm4 = CALLOC_STRUCT(si_pm4_state);

	if (pm4 == NULL)
		return;

	for (i = 0; i < info->num_inputs; i++) {
		switch (info->input_semantic_name[i]) {
		case TGSI_SEMANTIC_POSITION:
			/* SPI_BARYC_CNTL.POS_FLOAT_LOCATION
			 * Possible vaules:
			 * 0 -> Position = pixel center (default)
			 * 1 -> Position = pixel centroid
			 * 2 -> Position = at sample position
			 */
			switch (info->input_interpolate_loc[i]) {
			case TGSI_INTERPOLATE_LOC_CENTROID:
				spi_baryc_cntl |= S_0286E0_POS_FLOAT_LOCATION(1);
				break;
			case TGSI_INTERPOLATE_LOC_SAMPLE:
				spi_baryc_cntl |= S_0286E0_POS_FLOAT_LOCATION(2);
				break;
			}

			if (info->properties[TGSI_PROPERTY_FS_COORD_PIXEL_CENTER] ==
			    TGSI_FS_COORD_PIXEL_CENTER_INTEGER)
				spi_baryc_cntl |= S_0286E0_POS_FLOAT_ULC(1);
			break;
		}
	}

	spi_ps_in_control = S_0286D8_NUM_INTERP(shader->nparam) |
		S_0286D8_BC_OPTIMIZE_DISABLE(1);

	si_pm4_set_reg(pm4, R_0286E0_SPI_BARYC_CNTL, spi_baryc_cntl);
	spi_ps_input_ena = shader->spi_ps_input_ena;
	/* we need to enable at least one of them, otherwise we hang the GPU */
	assert(G_0286CC_PERSP_SAMPLE_ENA(spi_ps_input_ena) ||
	    G_0286CC_PERSP_CENTER_ENA(spi_ps_input_ena) ||
	    G_0286CC_PERSP_CENTROID_ENA(spi_ps_input_ena) ||
	    G_0286CC_PERSP_PULL_MODEL_ENA(spi_ps_input_ena) ||
	    G_0286CC_LINEAR_SAMPLE_ENA(spi_ps_input_ena) ||
	    G_0286CC_LINEAR_CENTER_ENA(spi_ps_input_ena) ||
	    G_0286CC_LINEAR_CENTROID_ENA(spi_ps_input_ena) ||
	    G_0286CC_LINE_STIPPLE_TEX_ENA(spi_ps_input_ena));

	si_pm4_set_reg(pm4, R_0286CC_SPI_PS_INPUT_ENA, spi_ps_input_ena);
	si_pm4_set_reg(pm4, R_0286D0_SPI_PS_INPUT_ADDR, spi_ps_input_ena);
	si_pm4_set_reg(pm4, R_0286D8_SPI_PS_IN_CONTROL, spi_ps_in_control);

	si_pm4_set_reg(pm4, R_028710_SPI_SHADER_Z_FORMAT, shader->spi_shader_z_format);
	si_pm4_set_reg(pm4, R_028714_SPI_SHADER_COL_FORMAT,
		       shader->spi_shader_col_format);
	si_pm4_set_reg(pm4, R_02823C_CB_SHADER_MASK, shader->cb_shader_mask);

	va = shader->bo->gpu_address;
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_DATA);
	si_pm4_set_reg(pm4, R_00B020_SPI_SHADER_PGM_LO_PS, va >> 8);
	si_pm4_set_reg(pm4, R_00B024_SPI_SHADER_PGM_HI_PS, va >> 40);

	num_user_sgprs = SI_PS_NUM_USER_SGPR;
	num_sgprs = shader->num_sgprs;
	/* One SGPR after user SGPRs is pre-loaded with {prim_mask, lds_offset} */
	if ((num_user_sgprs + 1) > num_sgprs) {
		/* Last 2 reserved SGPRs are used for VCC */
		num_sgprs = num_user_sgprs + 1 + 2;
	}
	assert(num_sgprs <= 104);

	si_pm4_set_reg(pm4, R_00B028_SPI_SHADER_PGM_RSRC1_PS,
		       S_00B028_VGPRS((shader->num_vgprs - 1) / 4) |
		       S_00B028_SGPRS((num_sgprs - 1) / 8) |
		       S_00B028_DX10_CLAMP(shader->dx10_clamp_mode));
	si_pm4_set_reg(pm4, R_00B02C_SPI_SHADER_PGM_RSRC2_PS,
		       S_00B02C_EXTRA_LDS_SIZE(shader->lds_size) |
		       S_00B02C_USER_SGPR(num_user_sgprs) |
		       S_00B32C_SCRATCH_EN(shader->scratch_bytes_per_wave > 0));
}

static void si_shader_init_pm4_state(struct si_shader *shader)
{

	if (shader->pm4)
		si_pm4_free_state_simple(shader->pm4);

	switch (shader->selector->type) {
	case PIPE_SHADER_VERTEX:
		if (shader->key.vs.as_ls)
			si_shader_ls(shader);
		else if (shader->key.vs.as_es)
			si_shader_es(shader);
		else
			si_shader_vs(shader);
		break;
	case PIPE_SHADER_TESS_CTRL:
		si_shader_hs(shader);
		break;
	case PIPE_SHADER_TESS_EVAL:
		if (shader->key.tes.as_es)
			si_shader_es(shader);
		else
			si_shader_vs(shader);
		break;
	case PIPE_SHADER_GEOMETRY:
		si_shader_gs(shader);
		si_shader_vs(shader->gs_copy_shader);
		break;
	case PIPE_SHADER_FRAGMENT:
		si_shader_ps(shader);
		break;
	default:
		assert(0);
	}
}

/* Compute the key for the hw shader variant */
static inline void si_shader_selector_key(struct pipe_context *ctx,
					  struct si_shader_selector *sel,
					  union si_shader_key *key)
{
	struct si_context *sctx = (struct si_context *)ctx;
	unsigned i;

	memset(key, 0, sizeof(*key));

	switch (sel->type) {
	case PIPE_SHADER_VERTEX:
		if (sctx->vertex_elements)
			for (i = 0; i < sctx->vertex_elements->count; ++i)
				key->vs.instance_divisors[i] =
					sctx->vertex_elements->elements[i].instance_divisor;

		if (sctx->tes_shader)
			key->vs.as_ls = 1;
		else if (sctx->gs_shader) {
			key->vs.as_es = 1;
			key->vs.es_enabled_outputs = sctx->gs_shader->inputs_read;
		}

		if (!sctx->gs_shader && sctx->ps_shader &&
		    sctx->ps_shader->info.uses_primid)
			key->vs.export_prim_id = 1;
		break;
	case PIPE_SHADER_TESS_CTRL:
		key->tcs.prim_mode =
			sctx->tes_shader->info.properties[TGSI_PROPERTY_TES_PRIM_MODE];
		break;
	case PIPE_SHADER_TESS_EVAL:
		if (sctx->gs_shader) {
			key->tes.as_es = 1;
			key->tes.es_enabled_outputs = sctx->gs_shader->inputs_read;
		} else if (sctx->ps_shader && sctx->ps_shader->info.uses_primid)
			key->tes.export_prim_id = 1;
		break;
	case PIPE_SHADER_GEOMETRY:
		break;
	case PIPE_SHADER_FRAGMENT: {
		struct si_state_rasterizer *rs = sctx->queued.named.rasterizer;

		if (sel->info.properties[TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS])
			key->ps.last_cbuf = MAX2(sctx->framebuffer.state.nr_cbufs, 1) - 1;
		key->ps.export_16bpc = sctx->framebuffer.export_16bpc;

		if (rs) {
			bool is_poly = (sctx->current_rast_prim >= PIPE_PRIM_TRIANGLES &&
					sctx->current_rast_prim <= PIPE_PRIM_POLYGON) ||
				       sctx->current_rast_prim >= PIPE_PRIM_TRIANGLES_ADJACENCY;
			bool is_line = !is_poly && sctx->current_rast_prim != PIPE_PRIM_POINTS;

			key->ps.color_two_side = rs->two_side;

			if (sctx->queued.named.blend) {
				key->ps.alpha_to_one = sctx->queued.named.blend->alpha_to_one &&
						       rs->multisample_enable &&
						       !sctx->framebuffer.cb0_is_integer;
			}

			key->ps.poly_stipple = rs->poly_stipple_enable && is_poly;
			key->ps.poly_line_smoothing = ((is_poly && rs->poly_smooth) ||
						       (is_line && rs->line_smooth)) &&
						      sctx->framebuffer.nr_samples <= 1;
		}

		key->ps.alpha_func = PIPE_FUNC_ALWAYS;
		/* Alpha-test should be disabled if colorbuffer 0 is integer. */
		if (sctx->queued.named.dsa &&
		    !sctx->framebuffer.cb0_is_integer)
			key->ps.alpha_func = sctx->queued.named.dsa->alpha_func;
		break;
	}
	default:
		assert(0);
	}
}

/* Select the hw shader variant depending on the current state. */
static int si_shader_select(struct pipe_context *ctx,
			    struct si_shader_selector *sel)
{
	struct si_context *sctx = (struct si_context *)ctx;
	union si_shader_key key;
	struct si_shader * shader = NULL;
	int r;

	si_shader_selector_key(ctx, sel, &key);

	/* Check if we don't need to change anything.
	 * This path is also used for most shaders that don't need multiple
	 * variants, it will cost just a computation of the key and this
	 * test. */
	if (likely(sel->current && memcmp(&sel->current->key, &key, sizeof(key)) == 0)) {
		return 0;
	}

	/* lookup if we have other variants in the list */
	if (sel->num_shaders > 1) {
		struct si_shader *p = sel->current, *c = p->next_variant;

		while (c && memcmp(&c->key, &key, sizeof(key)) != 0) {
			p = c;
			c = c->next_variant;
		}

		if (c) {
			p->next_variant = c->next_variant;
			shader = c;
		}
	}

	if (shader) {
		shader->next_variant = sel->current;
		sel->current = shader;
	} else {
		shader = CALLOC(1, sizeof(struct si_shader));
		shader->selector = sel;
		shader->key = key;

		shader->next_variant = sel->current;
		sel->current = shader;
		r = si_shader_create((struct si_screen*)ctx->screen, sctx->tm,
				     shader);
		if (unlikely(r)) {
			R600_ERR("Failed to build shader variant (type=%u) %d\n",
				 sel->type, r);
			sel->current = NULL;
			FREE(shader);
			return r;
		}
		si_shader_init_pm4_state(shader);
		sel->num_shaders++;
		p_atomic_inc(&sctx->screen->b.num_compilations);
	}

	return 0;
}

static void *si_create_shader_state(struct pipe_context *ctx,
				    const struct pipe_shader_state *state,
				    unsigned pipe_shader_type)
{
	struct si_screen *sscreen = (struct si_screen *)ctx->screen;
	struct si_shader_selector *sel = CALLOC_STRUCT(si_shader_selector);
	int i;

	if (!sel)
		return NULL;

	sel->type = pipe_shader_type;
	sel->tokens = tgsi_dup_tokens(state->tokens);
	if (!sel->tokens) {
		FREE(sel);
		return NULL;
	}

	sel->so = state->stream_output;
	tgsi_scan_shader(state->tokens, &sel->info);
	p_atomic_inc(&sscreen->b.num_shaders_created);

	switch (pipe_shader_type) {
	case PIPE_SHADER_GEOMETRY:
		sel->gs_output_prim =
			sel->info.properties[TGSI_PROPERTY_GS_OUTPUT_PRIM];
		sel->gs_max_out_vertices =
			sel->info.properties[TGSI_PROPERTY_GS_MAX_OUTPUT_VERTICES];
		sel->gs_num_invocations =
			sel->info.properties[TGSI_PROPERTY_GS_INVOCATIONS];

		for (i = 0; i < sel->info.num_inputs; i++) {
			unsigned name = sel->info.input_semantic_name[i];
			unsigned index = sel->info.input_semantic_index[i];

			switch (name) {
			case TGSI_SEMANTIC_PRIMID:
				break;
			default:
				sel->inputs_read |=
					1llu << si_shader_io_get_unique_index(name, index);
			}
		}
		break;

	case PIPE_SHADER_VERTEX:
	case PIPE_SHADER_TESS_CTRL:
		for (i = 0; i < sel->info.num_outputs; i++) {
			unsigned name = sel->info.output_semantic_name[i];
			unsigned index = sel->info.output_semantic_index[i];

			switch (name) {
			case TGSI_SEMANTIC_TESSINNER:
			case TGSI_SEMANTIC_TESSOUTER:
			case TGSI_SEMANTIC_PATCH:
				sel->patch_outputs_written |=
					1llu << si_shader_io_get_unique_index(name, index);
				break;
			default:
				sel->outputs_written |=
					1llu << si_shader_io_get_unique_index(name, index);
			}
		}
		break;
	case PIPE_SHADER_FRAGMENT:
		for (i = 0; i < sel->info.num_outputs; i++) {
			unsigned name = sel->info.output_semantic_name[i];
			unsigned index = sel->info.output_semantic_index[i];

			if (name == TGSI_SEMANTIC_COLOR)
				sel->ps_colors_written |= 1 << index;
		}
		break;
	}

	if (sscreen->b.debug_flags & DBG_PRECOMPILE)
		if (si_shader_select(ctx, sel)) {
			fprintf(stderr, "radeonsi: can't create a shader\n");
			tgsi_free_tokens(sel->tokens);
			FREE(sel);
			return NULL;
		}

	return sel;
}

static void *si_create_fs_state(struct pipe_context *ctx,
				const struct pipe_shader_state *state)
{
	return si_create_shader_state(ctx, state, PIPE_SHADER_FRAGMENT);
}

static void *si_create_gs_state(struct pipe_context *ctx,
				const struct pipe_shader_state *state)
{
	return si_create_shader_state(ctx, state, PIPE_SHADER_GEOMETRY);
}

static void *si_create_vs_state(struct pipe_context *ctx,
				const struct pipe_shader_state *state)
{
	return si_create_shader_state(ctx, state, PIPE_SHADER_VERTEX);
}

static void *si_create_tcs_state(struct pipe_context *ctx,
				 const struct pipe_shader_state *state)
{
	return si_create_shader_state(ctx, state, PIPE_SHADER_TESS_CTRL);
}

static void *si_create_tes_state(struct pipe_context *ctx,
				 const struct pipe_shader_state *state)
{
	return si_create_shader_state(ctx, state, PIPE_SHADER_TESS_EVAL);
}

static void si_bind_vs_shader(struct pipe_context *ctx, void *state)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_shader_selector *sel = state;

	if (sctx->vs_shader == sel || !sel)
		return;

	sctx->vs_shader = sel;
	si_mark_atom_dirty(sctx, &sctx->clip_regs);
}

static void si_bind_gs_shader(struct pipe_context *ctx, void *state)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_shader_selector *sel = state;
	bool enable_changed = !!sctx->gs_shader != !!sel;

	if (sctx->gs_shader == sel)
		return;

	sctx->gs_shader = sel;
	si_mark_atom_dirty(sctx, &sctx->clip_regs);
	sctx->last_rast_prim = -1; /* reset this so that it gets updated */

	if (enable_changed)
		si_shader_change_notify(sctx);
}

static void si_bind_tcs_shader(struct pipe_context *ctx, void *state)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_shader_selector *sel = state;
	bool enable_changed = !!sctx->tcs_shader != !!sel;

	if (sctx->tcs_shader == sel)
		return;

	sctx->tcs_shader = sel;

	if (enable_changed)
		sctx->last_tcs = NULL; /* invalidate derived tess state */
}

static void si_bind_tes_shader(struct pipe_context *ctx, void *state)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_shader_selector *sel = state;
	bool enable_changed = !!sctx->tes_shader != !!sel;

	if (sctx->tes_shader == sel)
		return;

	sctx->tes_shader = sel;
	si_mark_atom_dirty(sctx, &sctx->clip_regs);
	sctx->last_rast_prim = -1; /* reset this so that it gets updated */

	if (enable_changed) {
		si_shader_change_notify(sctx);
		sctx->last_tes_sh_base = -1; /* invalidate derived tess state */
	}
}

static void si_make_dummy_ps(struct si_context *sctx)
{
	if (!sctx->dummy_pixel_shader) {
		sctx->dummy_pixel_shader =
			util_make_fragment_cloneinput_shader(&sctx->b.b, 0,
							     TGSI_SEMANTIC_GENERIC,
							     TGSI_INTERPOLATE_CONSTANT);
	}
}

static void si_bind_ps_shader(struct pipe_context *ctx, void *state)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_shader_selector *sel = state;

	/* skip if supplied shader is one already in use */
	if (sctx->ps_shader == sel)
		return;

	/* use a dummy shader if binding a NULL shader */
	if (!sel) {
		si_make_dummy_ps(sctx);
		sel = sctx->dummy_pixel_shader;
	}

	sctx->ps_shader = sel;
	si_update_fb_blend_state(sctx);
}

static void si_delete_shader_selector(struct pipe_context *ctx,
				      struct si_shader_selector *sel)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_shader *p = sel->current, *c;

	while (p) {
		c = p->next_variant;
		switch (sel->type) {
		case PIPE_SHADER_VERTEX:
			if (p->key.vs.as_ls)
				si_pm4_delete_state(sctx, ls, p->pm4);
			else if (p->key.vs.as_es)
				si_pm4_delete_state(sctx, es, p->pm4);
			else
				si_pm4_delete_state(sctx, vs, p->pm4);
			break;
		case PIPE_SHADER_TESS_CTRL:
			si_pm4_delete_state(sctx, hs, p->pm4);
			break;
		case PIPE_SHADER_TESS_EVAL:
			if (p->key.tes.as_es)
				si_pm4_delete_state(sctx, es, p->pm4);
			else
				si_pm4_delete_state(sctx, vs, p->pm4);
			break;
		case PIPE_SHADER_GEOMETRY:
			si_pm4_delete_state(sctx, gs, p->pm4);
			si_pm4_delete_state(sctx, vs, p->gs_copy_shader->pm4);
			break;
		case PIPE_SHADER_FRAGMENT:
			si_pm4_delete_state(sctx, ps, p->pm4);
			break;
		}

		si_shader_destroy(ctx, p);
		free(p);
		p = c;
	}

	free(sel->tokens);
	free(sel);
}

static void si_delete_vs_shader(struct pipe_context *ctx, void *state)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_shader_selector *sel = (struct si_shader_selector *)state;

	if (sctx->vs_shader == sel) {
		sctx->vs_shader = NULL;
	}

	si_delete_shader_selector(ctx, sel);
}

static void si_delete_gs_shader(struct pipe_context *ctx, void *state)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_shader_selector *sel = (struct si_shader_selector *)state;

	if (sctx->gs_shader == sel) {
		sctx->gs_shader = NULL;
	}

	si_delete_shader_selector(ctx, sel);
}

static void si_delete_ps_shader(struct pipe_context *ctx, void *state)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_shader_selector *sel = (struct si_shader_selector *)state;

	if (sctx->ps_shader == sel) {
		sctx->ps_shader = NULL;
	}

	si_delete_shader_selector(ctx, sel);
}

static void si_delete_tcs_shader(struct pipe_context *ctx, void *state)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_shader_selector *sel = (struct si_shader_selector *)state;

	if (sctx->tcs_shader == sel) {
		sctx->tcs_shader = NULL;
	}

	si_delete_shader_selector(ctx, sel);
}

static void si_delete_tes_shader(struct pipe_context *ctx, void *state)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_shader_selector *sel = (struct si_shader_selector *)state;

	if (sctx->tes_shader == sel) {
		sctx->tes_shader = NULL;
	}

	si_delete_shader_selector(ctx, sel);
}

static void si_update_spi_map(struct si_context *sctx)
{
	struct si_shader *ps = sctx->ps_shader->current;
	struct si_shader *vs = si_get_vs_state(sctx);
	struct tgsi_shader_info *psinfo = &ps->selector->info;
	struct tgsi_shader_info *vsinfo = &vs->selector->info;
	struct si_pm4_state *pm4 = CALLOC_STRUCT(si_pm4_state);
	unsigned i, j, tmp;

	for (i = 0; i < psinfo->num_inputs; i++) {
		unsigned name = psinfo->input_semantic_name[i];
		unsigned index = psinfo->input_semantic_index[i];
		unsigned interpolate = psinfo->input_interpolate[i];
		unsigned param_offset = ps->ps_input_param_offset[i];

		if (name == TGSI_SEMANTIC_POSITION ||
		    name == TGSI_SEMANTIC_FACE)
			/* Read from preloaded VGPRs, not parameters */
			continue;

bcolor:
		tmp = 0;

		if (interpolate == TGSI_INTERPOLATE_CONSTANT ||
		    (interpolate == TGSI_INTERPOLATE_COLOR && sctx->flatshade))
			tmp |= S_028644_FLAT_SHADE(1);

		if (name == TGSI_SEMANTIC_PCOORD ||
		    (name == TGSI_SEMANTIC_TEXCOORD &&
		     sctx->sprite_coord_enable & (1 << index))) {
			tmp |= S_028644_PT_SPRITE_TEX(1);
		}

		for (j = 0; j < vsinfo->num_outputs; j++) {
			if (name == vsinfo->output_semantic_name[j] &&
			    index == vsinfo->output_semantic_index[j]) {
				tmp |= S_028644_OFFSET(vs->vs_output_param_offset[j]);
				break;
			}
		}

		if (name == TGSI_SEMANTIC_PRIMID)
			/* PrimID is written after the last output. */
			tmp |= S_028644_OFFSET(vs->vs_output_param_offset[vsinfo->num_outputs]);
		else if (j == vsinfo->num_outputs && !G_028644_PT_SPRITE_TEX(tmp)) {
			/* No corresponding output found, load defaults into input.
			 * Don't set any other bits.
			 * (FLAT_SHADE=1 completely changes behavior) */
			tmp = S_028644_OFFSET(0x20);
		}

		si_pm4_set_reg(pm4,
			       R_028644_SPI_PS_INPUT_CNTL_0 + param_offset * 4,
			       tmp);

		if (name == TGSI_SEMANTIC_COLOR &&
		    ps->key.ps.color_two_side) {
			name = TGSI_SEMANTIC_BCOLOR;
			param_offset++;
			goto bcolor;
		}
	}

	si_pm4_set_state(sctx, spi, pm4);
}

/* Initialize state related to ESGS / GSVS ring buffers */
static void si_init_gs_rings(struct si_context *sctx)
{
	unsigned esgs_ring_size = 128 * 1024;
	unsigned gsvs_ring_size = 60 * 1024 * 1024;

	assert(!sctx->gs_rings);
	sctx->gs_rings = CALLOC_STRUCT(si_pm4_state);

	if (!sctx->gs_rings)
		return;

	sctx->esgs_ring = pipe_buffer_create(sctx->b.b.screen, PIPE_BIND_CUSTOM,
				       PIPE_USAGE_DEFAULT, esgs_ring_size);
	if (!sctx->esgs_ring) {
		FREE(sctx->gs_rings);
		return;
	}

	sctx->gsvs_ring = pipe_buffer_create(sctx->b.b.screen, PIPE_BIND_CUSTOM,
					     PIPE_USAGE_DEFAULT, gsvs_ring_size);
	if (!sctx->gsvs_ring) {
		pipe_resource_reference(&sctx->esgs_ring, NULL);
		FREE(sctx->gs_rings);
		return;
	}

	if (sctx->b.chip_class >= CIK) {
		if (sctx->b.chip_class >= VI) {
			/* The maximum sizes are 63.999 MB on VI, because
			 * the register fields only have 18 bits. */
			assert(esgs_ring_size / 256 < (1 << 18));
			assert(gsvs_ring_size / 256 < (1 << 18));
		}
		si_pm4_set_reg(sctx->gs_rings, R_030900_VGT_ESGS_RING_SIZE,
			       esgs_ring_size / 256);
		si_pm4_set_reg(sctx->gs_rings, R_030904_VGT_GSVS_RING_SIZE,
			       gsvs_ring_size / 256);
	} else {
		si_pm4_set_reg(sctx->gs_rings, R_0088C8_VGT_ESGS_RING_SIZE,
			       esgs_ring_size / 256);
		si_pm4_set_reg(sctx->gs_rings, R_0088CC_VGT_GSVS_RING_SIZE,
			       gsvs_ring_size / 256);
	}

	si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_VERTEX, SI_RING_ESGS,
			   sctx->esgs_ring, 0, esgs_ring_size,
			   true, true, 4, 64, 0);
	si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_GEOMETRY, SI_RING_ESGS,
			   sctx->esgs_ring, 0, esgs_ring_size,
			   false, false, 0, 0, 0);
	si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_VERTEX, SI_RING_GSVS,
			   sctx->gsvs_ring, 0, gsvs_ring_size,
			   false, false, 0, 0, 0);
}

static void si_update_gs_rings(struct si_context *sctx)
{
	unsigned gs_vert_itemsize = sctx->gs_shader->info.num_outputs * 16;
	unsigned gs_max_vert_out = sctx->gs_shader->gs_max_out_vertices;
	unsigned gsvs_itemsize = gs_vert_itemsize * gs_max_vert_out;
	uint64_t offset;

	si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_GEOMETRY, SI_RING_GSVS,
			   sctx->gsvs_ring, gsvs_itemsize,
			   64, true, true, 4, 16, 0);

	offset = gsvs_itemsize * 64;
	si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_GEOMETRY, SI_RING_GSVS_1,
			   sctx->gsvs_ring, gsvs_itemsize,
			   64, true, true, 4, 16, offset);

	offset = (gsvs_itemsize * 2) * 64;
	si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_GEOMETRY, SI_RING_GSVS_2,
			   sctx->gsvs_ring, gsvs_itemsize,
			   64, true, true, 4, 16, offset);

	offset = (gsvs_itemsize * 3) * 64;
	si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_GEOMETRY, SI_RING_GSVS_3,
			   sctx->gsvs_ring, gsvs_itemsize,
			   64, true, true, 4, 16, offset);

}
/**
 * @@returns 1 if \p sel has been updated to use a new scratch buffer
 *          0 if not
 *          < 0 if there was a failure
 */
static int si_update_scratch_buffer(struct si_context *sctx,
				    struct si_shader_selector *sel)
{
	struct si_shader *shader;
	uint64_t scratch_va = sctx->scratch_buffer->gpu_address;
	int r;

	if (!sel)
		return 0;

	shader = sel->current;

	/* This shader doesn't need a scratch buffer */
	if (shader->scratch_bytes_per_wave == 0)
		return 0;

	/* This shader is already configured to use the current
	 * scratch buffer. */
	if (shader->scratch_bo == sctx->scratch_buffer)
		return 0;

	assert(sctx->scratch_buffer);

	si_shader_apply_scratch_relocs(sctx, shader, scratch_va);

	/* Replace the shader bo with a new bo that has the relocs applied. */
	r = si_shader_binary_upload(sctx->screen, shader);
	if (r)
		return r;

	/* Update the shader state to use the new shader bo. */
	si_shader_init_pm4_state(shader);

	r600_resource_reference(&shader->scratch_bo, sctx->scratch_buffer);

	return 1;
}

static unsigned si_get_current_scratch_buffer_size(struct si_context *sctx)
{
	if (!sctx->scratch_buffer)
		return 0;

	return sctx->scratch_buffer->b.b.width0;
}

static unsigned si_get_scratch_buffer_bytes_per_wave(struct si_context *sctx,
					struct si_shader_selector *sel)
{
	if (!sel)
		return 0;

	return sel->current->scratch_bytes_per_wave;
}

static unsigned si_get_max_scratch_bytes_per_wave(struct si_context *sctx)
{
	unsigned bytes = 0;

	bytes = MAX2(bytes, si_get_scratch_buffer_bytes_per_wave(sctx, sctx->ps_shader));
	bytes = MAX2(bytes, si_get_scratch_buffer_bytes_per_wave(sctx, sctx->gs_shader));
	bytes = MAX2(bytes, si_get_scratch_buffer_bytes_per_wave(sctx, sctx->vs_shader));
	bytes = MAX2(bytes, si_get_scratch_buffer_bytes_per_wave(sctx, sctx->tcs_shader));
	bytes = MAX2(bytes, si_get_scratch_buffer_bytes_per_wave(sctx, sctx->tes_shader));
	return bytes;
}

static bool si_update_spi_tmpring_size(struct si_context *sctx)
{
	unsigned current_scratch_buffer_size =
		si_get_current_scratch_buffer_size(sctx);
	unsigned scratch_bytes_per_wave =
		si_get_max_scratch_bytes_per_wave(sctx);
	unsigned scratch_needed_size = scratch_bytes_per_wave *
		sctx->scratch_waves;
	int r;

	if (scratch_needed_size > 0) {

		if (scratch_needed_size > current_scratch_buffer_size) {
			/* Create a bigger scratch buffer */
			pipe_resource_reference(
					(struct pipe_resource**)&sctx->scratch_buffer,
					NULL);

			sctx->scratch_buffer =
					si_resource_create_custom(&sctx->screen->b.b,
	                                PIPE_USAGE_DEFAULT, scratch_needed_size);
			if (!sctx->scratch_buffer)
				return false;
			sctx->emit_scratch_reloc = true;
		}

		/* Update the shaders, so they are using the latest scratch.  The
		 * scratch buffer may have been changed since these shaders were
		 * last used, so we still need to try to update them, even if
		 * they require scratch buffers smaller than the current size.
		 */
		r = si_update_scratch_buffer(sctx, sctx->ps_shader);
		if (r < 0)
			return false;
		if (r == 1)
			si_pm4_bind_state(sctx, ps, sctx->ps_shader->current->pm4);

		r = si_update_scratch_buffer(sctx, sctx->gs_shader);
		if (r < 0)
			return false;
		if (r == 1)
			si_pm4_bind_state(sctx, gs, sctx->gs_shader->current->pm4);

		r = si_update_scratch_buffer(sctx, sctx->tcs_shader);
		if (r < 0)
			return false;
		if (r == 1)
			si_pm4_bind_state(sctx, hs, sctx->tcs_shader->current->pm4);

		/* VS can be bound as LS, ES, or VS. */
		if (sctx->tes_shader) {
			r = si_update_scratch_buffer(sctx, sctx->vs_shader);
			if (r < 0)
				return false;
			if (r == 1)
				si_pm4_bind_state(sctx, ls, sctx->vs_shader->current->pm4);
		} else if (sctx->gs_shader) {
			r = si_update_scratch_buffer(sctx, sctx->vs_shader);
			if (r < 0)
				return false;
			if (r == 1)
				si_pm4_bind_state(sctx, es, sctx->vs_shader->current->pm4);
		} else {
			r = si_update_scratch_buffer(sctx, sctx->vs_shader);
			if (r < 0)
				return false;
			if (r == 1)
				si_pm4_bind_state(sctx, vs, sctx->vs_shader->current->pm4);
		}

		/* TES can be bound as ES or VS. */
		if (sctx->gs_shader) {
			r = si_update_scratch_buffer(sctx, sctx->tes_shader);
			if (r < 0)
				return false;
			if (r == 1)
				si_pm4_bind_state(sctx, es, sctx->tes_shader->current->pm4);
		} else {
			r = si_update_scratch_buffer(sctx, sctx->tes_shader);
			if (r < 0)
				return false;
			if (r == 1)
				si_pm4_bind_state(sctx, vs, sctx->tes_shader->current->pm4);
		}
	}

	/* The LLVM shader backend should be reporting aligned scratch_sizes. */
	assert((scratch_needed_size & ~0x3FF) == scratch_needed_size &&
		"scratch size should already be aligned correctly.");

	sctx->spi_tmpring_size = S_0286E8_WAVES(sctx->scratch_waves) |
				S_0286E8_WAVESIZE(scratch_bytes_per_wave >> 10);
	return true;
}

static void si_init_tess_factor_ring(struct si_context *sctx)
{
	assert(!sctx->tf_state);
	sctx->tf_state = CALLOC_STRUCT(si_pm4_state);

	if (!sctx->tf_state)
		return;

	sctx->tf_ring = pipe_buffer_create(sctx->b.b.screen, PIPE_BIND_CUSTOM,
					   PIPE_USAGE_DEFAULT,
					   32768 * sctx->screen->b.info.max_se);
	if (!sctx->tf_ring) {
		FREE(sctx->tf_state);
		return;
	}

	sctx->b.clear_buffer(&sctx->b.b, sctx->tf_ring, 0,
			     sctx->tf_ring->width0, fui(0), false);

	assert(((sctx->tf_ring->width0 / 4) & C_030938_SIZE) == 0);

	if (sctx->b.chip_class >= CIK) {
		si_pm4_set_reg(sctx->tf_state, R_030938_VGT_TF_RING_SIZE,
			       S_030938_SIZE(sctx->tf_ring->width0 / 4));
		si_pm4_set_reg(sctx->tf_state, R_030940_VGT_TF_MEMORY_BASE,
			       r600_resource(sctx->tf_ring)->gpu_address >> 8);
	} else {
		si_pm4_set_reg(sctx->tf_state, R_008988_VGT_TF_RING_SIZE,
			       S_008988_SIZE(sctx->tf_ring->width0 / 4));
		si_pm4_set_reg(sctx->tf_state, R_0089B8_VGT_TF_MEMORY_BASE,
			       r600_resource(sctx->tf_ring)->gpu_address >> 8);
	}
	si_pm4_add_bo(sctx->tf_state, r600_resource(sctx->tf_ring),
		      RADEON_USAGE_READWRITE, RADEON_PRIO_SHADER_RESOURCE_RW);
	si_pm4_bind_state(sctx, tf_ring, sctx->tf_state);

	si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_TESS_CTRL,
			   SI_RING_TESS_FACTOR, sctx->tf_ring, 0,
			   sctx->tf_ring->width0, false, false, 0, 0, 0);

	sctx->b.flags |= SI_CONTEXT_VGT_FLUSH;
}

/**
 * This is used when TCS is NULL in the VS->TCS->TES chain. In this case,
 * VS passes its outputs to TES directly, so the fixed-function shader only
 * has to write TESSOUTER and TESSINNER.
 */
static void si_generate_fixed_func_tcs(struct si_context *sctx)
{
	struct ureg_src const0, const1;
	struct ureg_dst tessouter, tessinner;
	struct ureg_program *ureg = ureg_create(TGSI_PROCESSOR_TESS_CTRL);

	if (!ureg)
		return; /* if we get here, we're screwed */

	assert(!sctx->fixed_func_tcs_shader);

	ureg_DECL_constant2D(ureg, 0, 1, SI_DRIVER_STATE_CONST_BUF);
	const0 = ureg_src_dimension(ureg_src_register(TGSI_FILE_CONSTANT, 0),
				    SI_DRIVER_STATE_CONST_BUF);
	const1 = ureg_src_dimension(ureg_src_register(TGSI_FILE_CONSTANT, 1),
				    SI_DRIVER_STATE_CONST_BUF);

	tessouter = ureg_DECL_output(ureg, TGSI_SEMANTIC_TESSOUTER, 0);
	tessinner = ureg_DECL_output(ureg, TGSI_SEMANTIC_TESSINNER, 0);

	ureg_MOV(ureg, tessouter, const0);
	ureg_MOV(ureg, tessinner, const1);
	ureg_END(ureg);

	sctx->fixed_func_tcs_shader =
		ureg_create_shader_and_destroy(ureg, &sctx->b.b);
}

static void si_update_vgt_shader_config(struct si_context *sctx)
{
	/* Calculate the index of the config.
	 * 0 = VS, 1 = VS+GS, 2 = VS+Tess, 3 = VS+Tess+GS */
	unsigned index = 2*!!sctx->tes_shader + !!sctx->gs_shader;
	struct si_pm4_state **pm4 = &sctx->vgt_shader_config[index];

	if (!*pm4) {
		uint32_t stages = 0;

		*pm4 = CALLOC_STRUCT(si_pm4_state);

		if (sctx->tes_shader) {
			stages |= S_028B54_LS_EN(V_028B54_LS_STAGE_ON) |
				  S_028B54_HS_EN(1);

			if (sctx->gs_shader)
				stages |= S_028B54_ES_EN(V_028B54_ES_STAGE_DS) |
					  S_028B54_GS_EN(1) |
				          S_028B54_VS_EN(V_028B54_VS_STAGE_COPY_SHADER);
			else
				stages |= S_028B54_VS_EN(V_028B54_VS_STAGE_DS);
		} else if (sctx->gs_shader) {
			stages |= S_028B54_ES_EN(V_028B54_ES_STAGE_REAL) |
				  S_028B54_GS_EN(1) |
			          S_028B54_VS_EN(V_028B54_VS_STAGE_COPY_SHADER);
		}

		si_pm4_set_reg(*pm4, R_028B54_VGT_SHADER_STAGES_EN, stages);
	}
	si_pm4_bind_state(sctx, vgt_shader_config, *pm4);
}

static void si_update_so(struct si_context *sctx, struct si_shader_selector *shader)
{
	struct pipe_stream_output_info *so = &shader->so;
	uint32_t enabled_stream_buffers_mask = 0;
	int i;

	for (i = 0; i < so->num_outputs; i++)
		enabled_stream_buffers_mask |= (1 << so->output[i].output_buffer) << (so->output[i].stream * 4);
	sctx->b.streamout.enabled_stream_buffers_mask = enabled_stream_buffers_mask;
	sctx->b.streamout.stride_in_dw = shader->so.stride;
}

bool si_update_shaders(struct si_context *sctx)
{
	struct pipe_context *ctx = (struct pipe_context*)sctx;
	struct si_state_rasterizer *rs = sctx->queued.named.rasterizer;
	int r;

	/* Update stages before GS. */
	if (sctx->tes_shader) {
		if (!sctx->tf_state) {
			si_init_tess_factor_ring(sctx);
			if (!sctx->tf_state)
				return false;
		}

		/* VS as LS */
		r = si_shader_select(ctx, sctx->vs_shader);
		if (r)
			return false;
		si_pm4_bind_state(sctx, ls, sctx->vs_shader->current->pm4);

		if (sctx->tcs_shader) {
			r = si_shader_select(ctx, sctx->tcs_shader);
			if (r)
				return false;
			si_pm4_bind_state(sctx, hs, sctx->tcs_shader->current->pm4);
		} else {
			if (!sctx->fixed_func_tcs_shader) {
				si_generate_fixed_func_tcs(sctx);
				if (!sctx->fixed_func_tcs_shader)
					return false;
			}

			r = si_shader_select(ctx, sctx->fixed_func_tcs_shader);
			if (r)
				return false;
			si_pm4_bind_state(sctx, hs,
					  sctx->fixed_func_tcs_shader->current->pm4);
		}

		r = si_shader_select(ctx, sctx->tes_shader);
		if (r)
			return false;

		if (sctx->gs_shader) {
			/* TES as ES */
			si_pm4_bind_state(sctx, es, sctx->tes_shader->current->pm4);
		} else {
			/* TES as VS */
			si_pm4_bind_state(sctx, vs, sctx->tes_shader->current->pm4);
			si_update_so(sctx, sctx->tes_shader);
		}
	} else if (sctx->gs_shader) {
		/* VS as ES */
		r = si_shader_select(ctx, sctx->vs_shader);
		if (r)
			return false;
		si_pm4_bind_state(sctx, es, sctx->vs_shader->current->pm4);
	} else {
		/* VS as VS */
		r = si_shader_select(ctx, sctx->vs_shader);
		if (r)
			return false;
		si_pm4_bind_state(sctx, vs, sctx->vs_shader->current->pm4);
		si_update_so(sctx, sctx->vs_shader);
	}

	/* Update GS. */
	if (sctx->gs_shader) {
		r = si_shader_select(ctx, sctx->gs_shader);
		if (r)
			return false;
		si_pm4_bind_state(sctx, gs, sctx->gs_shader->current->pm4);
		si_pm4_bind_state(sctx, vs, sctx->gs_shader->current->gs_copy_shader->pm4);
		si_update_so(sctx, sctx->gs_shader);

		if (!sctx->gs_rings) {
			si_init_gs_rings(sctx);
			if (!sctx->gs_rings)
				return false;
		}

		if (sctx->emitted.named.gs_rings != sctx->gs_rings)
			sctx->b.flags |= SI_CONTEXT_VGT_FLUSH;
		si_pm4_bind_state(sctx, gs_rings, sctx->gs_rings);

		si_update_gs_rings(sctx);
	} else {
		si_pm4_bind_state(sctx, gs_rings, NULL);
		si_pm4_bind_state(sctx, gs, NULL);
		si_pm4_bind_state(sctx, es, NULL);
	}

	si_update_vgt_shader_config(sctx);

	r = si_shader_select(ctx, sctx->ps_shader);
	if (r)
		return false;
	si_pm4_bind_state(sctx, ps, sctx->ps_shader->current->pm4);

	if (si_pm4_state_changed(sctx, ps) || si_pm4_state_changed(sctx, vs) ||
	    sctx->sprite_coord_enable != rs->sprite_coord_enable ||
	    sctx->flatshade != rs->flatshade) {
		sctx->sprite_coord_enable = rs->sprite_coord_enable;
		sctx->flatshade = rs->flatshade;
		si_update_spi_map(sctx);
	}

	if (si_pm4_state_changed(sctx, ls) ||
	    si_pm4_state_changed(sctx, hs) ||
	    si_pm4_state_changed(sctx, es) ||
	    si_pm4_state_changed(sctx, gs) ||
	    si_pm4_state_changed(sctx, vs) ||
	    si_pm4_state_changed(sctx, ps)) {
		if (!si_update_spi_tmpring_size(sctx))
			return false;
	}

	if (sctx->ps_db_shader_control != sctx->ps_shader->current->db_shader_control) {
		sctx->ps_db_shader_control = sctx->ps_shader->current->db_shader_control;
		si_mark_atom_dirty(sctx, &sctx->db_render_state);
	}

	if (sctx->smoothing_enabled != sctx->ps_shader->current->key.ps.poly_line_smoothing) {
		sctx->smoothing_enabled = sctx->ps_shader->current->key.ps.poly_line_smoothing;
		si_mark_atom_dirty(sctx, &sctx->msaa_config);

		if (sctx->b.chip_class == SI)
			si_mark_atom_dirty(sctx, &sctx->db_render_state);
	}
	return true;
}

void si_init_shader_functions(struct si_context *sctx)
{
	sctx->b.b.create_vs_state = si_create_vs_state;
	sctx->b.b.create_tcs_state = si_create_tcs_state;
	sctx->b.b.create_tes_state = si_create_tes_state;
	sctx->b.b.create_gs_state = si_create_gs_state;
	sctx->b.b.create_fs_state = si_create_fs_state;

	sctx->b.b.bind_vs_state = si_bind_vs_shader;
	sctx->b.b.bind_tcs_state = si_bind_tcs_shader;
	sctx->b.b.bind_tes_state = si_bind_tes_shader;
	sctx->b.b.bind_gs_state = si_bind_gs_shader;
	sctx->b.b.bind_fs_state = si_bind_ps_shader;

	sctx->b.b.delete_vs_state = si_delete_vs_shader;
	sctx->b.b.delete_tcs_state = si_delete_tcs_shader;
	sctx->b.b.delete_tes_state = si_delete_tes_shader;
	sctx->b.b.delete_gs_state = si_delete_gs_shader;
	sctx->b.b.delete_fs_state = si_delete_ps_shader;
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.0.8

This seems to fix some of the problems with clutter/gnome reported to
occur on r600 with 11.0.6
@
text
@d122 1
a122 1
	shader->rsrc1 = S_00B528_VGPRS((shader->num_vgprs - 1) / 4) |
d125 1
a125 1
	shader->rsrc2 = S_00B52C_USER_SGPR(num_user_sgprs) |
@


1.1.1.3
log
@Import Mesa 11.0.9
@
text
@a1200 1
	unsigned spi_tmpring_size;
d1283 2
a1284 6
	spi_tmpring_size = S_0286E8_WAVES(sctx->scratch_waves) |
			   S_0286E8_WAVESIZE(scratch_bytes_per_wave >> 10);
	if (spi_tmpring_size != sctx->spi_tmpring_size) {
		sctx->spi_tmpring_size = spi_tmpring_size;
		sctx->emit_scratch_reloc = true;
	}
@


1.1.1.4
log
@Import Mesa 11.2.2
@
text
@a30 1
#include "radeon/r600_cs.h"
a33 2
#include "util/hash_table.h"
#include "util/u_hash.h"
a34 1
#include "util/u_prim.h"
a36 209
/* SHADER_CACHE */

/**
 * Return the TGSI binary in a buffer. The first 4 bytes contain its size as
 * integer.
 */
static void *si_get_tgsi_binary(struct si_shader_selector *sel)
{
	unsigned tgsi_size = tgsi_num_tokens(sel->tokens) *
			     sizeof(struct tgsi_token);
	unsigned size = 4 + tgsi_size + sizeof(sel->so);
	char *result = (char*)MALLOC(size);

	if (!result)
		return NULL;

	*((uint32_t*)result) = size;
	memcpy(result + 4, sel->tokens, tgsi_size);
	memcpy(result + 4 + tgsi_size, &sel->so, sizeof(sel->so));
	return result;
}

/** Copy "data" to "ptr" and return the next dword following copied data. */
static uint32_t *write_data(uint32_t *ptr, const void *data, unsigned size)
{
	memcpy(ptr, data, size);
	ptr += DIV_ROUND_UP(size, 4);
	return ptr;
}

/** Read data from "ptr". Return the next dword following the data. */
static uint32_t *read_data(uint32_t *ptr, void *data, unsigned size)
{
	memcpy(data, ptr, size);
	ptr += DIV_ROUND_UP(size, 4);
	return ptr;
}

/**
 * Write the size as uint followed by the data. Return the next dword
 * following the copied data.
 */
static uint32_t *write_chunk(uint32_t *ptr, const void *data, unsigned size)
{
	*ptr++ = size;
	return write_data(ptr, data, size);
}

/**
 * Read the size as uint followed by the data. Return both via parameters.
 * Return the next dword following the data.
 */
static uint32_t *read_chunk(uint32_t *ptr, void **data, unsigned *size)
{
	*size = *ptr++;
	assert(*data == NULL);
	*data = malloc(*size);
	return read_data(ptr, *data, *size);
}

/**
 * Return the shader binary in a buffer. The first 4 bytes contain its size
 * as integer.
 */
static void *si_get_shader_binary(struct si_shader *shader)
{
	/* There is always a size of data followed by the data itself. */
	unsigned relocs_size = shader->binary.reloc_count *
			       sizeof(shader->binary.relocs[0]);
	unsigned disasm_size = strlen(shader->binary.disasm_string) + 1;
	unsigned size =
		4 + /* total size */
		4 + /* CRC32 of the data below */
		align(sizeof(shader->config), 4) +
		align(sizeof(shader->info), 4) +
		4 + align(shader->binary.code_size, 4) +
		4 + align(shader->binary.rodata_size, 4) +
		4 + align(relocs_size, 4) +
		4 + align(disasm_size, 4);
	void *buffer = CALLOC(1, size);
	uint32_t *ptr = (uint32_t*)buffer;

	if (!buffer)
		return NULL;

	*ptr++ = size;
	ptr++; /* CRC32 is calculated at the end. */

	ptr = write_data(ptr, &shader->config, sizeof(shader->config));
	ptr = write_data(ptr, &shader->info, sizeof(shader->info));
	ptr = write_chunk(ptr, shader->binary.code, shader->binary.code_size);
	ptr = write_chunk(ptr, shader->binary.rodata, shader->binary.rodata_size);
	ptr = write_chunk(ptr, shader->binary.relocs, relocs_size);
	ptr = write_chunk(ptr, shader->binary.disasm_string, disasm_size);
	assert((char *)ptr - (char *)buffer == size);

	/* Compute CRC32. */
	ptr = (uint32_t*)buffer;
	ptr++;
	*ptr = util_hash_crc32(ptr + 1, size - 8);

	return buffer;
}

static bool si_load_shader_binary(struct si_shader *shader, void *binary)
{
	uint32_t *ptr = (uint32_t*)binary;
	uint32_t size = *ptr++;
	uint32_t crc32 = *ptr++;
	unsigned chunk_size;

	if (util_hash_crc32(ptr, size - 8) != crc32) {
		fprintf(stderr, "radeonsi: binary shader has invalid CRC32\n");
		return false;
	}

	ptr = read_data(ptr, &shader->config, sizeof(shader->config));
	ptr = read_data(ptr, &shader->info, sizeof(shader->info));
	ptr = read_chunk(ptr, (void**)&shader->binary.code,
			 &shader->binary.code_size);
	ptr = read_chunk(ptr, (void**)&shader->binary.rodata,
			 &shader->binary.rodata_size);
	ptr = read_chunk(ptr, (void**)&shader->binary.relocs, &chunk_size);
	shader->binary.reloc_count = chunk_size / sizeof(shader->binary.relocs[0]);
	ptr = read_chunk(ptr, (void**)&shader->binary.disasm_string, &chunk_size);

	return true;
}

/**
 * Insert a shader into the cache. It's assumed the shader is not in the cache.
 * Use si_shader_cache_load_shader before calling this.
 *
 * Returns false on failure, in which case the tgsi_binary should be freed.
 */
static bool si_shader_cache_insert_shader(struct si_screen *sscreen,
					  void *tgsi_binary,
					  struct si_shader *shader)
{
	void *hw_binary = si_get_shader_binary(shader);

	if (!hw_binary)
		return false;

	if (_mesa_hash_table_insert(sscreen->shader_cache, tgsi_binary,
				    hw_binary) == NULL) {
		FREE(hw_binary);
		return false;
	}

	return true;
}

static bool si_shader_cache_load_shader(struct si_screen *sscreen,
					void *tgsi_binary,
				        struct si_shader *shader)
{
	struct hash_entry *entry =
		_mesa_hash_table_search(sscreen->shader_cache, tgsi_binary);
	if (!entry)
		return false;

	return si_load_shader_binary(shader, entry->data);
}

static uint32_t si_shader_cache_key_hash(const void *key)
{
	/* The first dword is the key size. */
	return util_hash_crc32(key, *(uint32_t*)key);
}

static bool si_shader_cache_key_equals(const void *a, const void *b)
{
	uint32_t *keya = (uint32_t*)a;
	uint32_t *keyb = (uint32_t*)b;

	/* The first dword is the key size. */
	if (*keya != *keyb)
		return false;

	return memcmp(keya, keyb, *keya) == 0;
}

static void si_destroy_shader_cache_entry(struct hash_entry *entry)
{
	FREE((void*)entry->key);
	FREE(entry->data);
}

bool si_init_shader_cache(struct si_screen *sscreen)
{
	pipe_mutex_init(sscreen->shader_cache_mutex);
	sscreen->shader_cache =
		_mesa_hash_table_create(NULL,
					si_shader_cache_key_hash,
					si_shader_cache_key_equals);
	return sscreen->shader_cache != NULL;
}

void si_destroy_shader_cache(struct si_screen *sscreen)
{
	if (sscreen->shader_cache)
		_mesa_hash_table_destroy(sscreen->shader_cache,
					 si_destroy_shader_cache_entry);
	pipe_mutex_destroy(sscreen->shader_cache_mutex);
}

/* SHADER STATES */

d101 1
a101 1
	if (!pm4)
d105 1
a105 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_USER_SHADER);
d109 1
a109 1
	vgpr_comp_cnt = shader->info.uses_instanceid ? 3 : 1;
d112 1
a112 1
	num_sgprs = shader->config.num_sgprs;
d122 1
a122 1
	shader->config.rsrc1 = S_00B528_VGPRS((shader->config.num_vgprs - 1) / 4) |
d124 3
a126 5
		           S_00B528_VGPR_COMP_CNT(vgpr_comp_cnt) |
			   S_00B528_DX10_CLAMP(1) |
			   S_00B528_FLOAT_MODE(shader->config.float_mode);
	shader->config.rsrc2 = S_00B52C_USER_SGPR(num_user_sgprs) |
			   S_00B52C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0);
d136 1
a136 1
	if (!pm4)
d140 1
a140 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_USER_SHADER);
d143 1
a143 1
	num_sgprs = shader->config.num_sgprs;
d155 2
a156 4
		       S_00B428_VGPRS((shader->config.num_vgprs - 1) / 4) |
		       S_00B428_SGPRS((num_sgprs - 1) / 8) |
		       S_00B428_DX10_CLAMP(1) |
		       S_00B428_FLOAT_MODE(shader->config.float_mode));
d159 1
a159 1
		       S_00B42C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0));
d171 1
a171 1
	if (!pm4)
d175 1
a175 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_USER_SHADER);
d178 2
a179 2
		vgpr_comp_cnt = shader->info.uses_instanceid ? 3 : 0;
		num_user_sgprs = SI_ES_NUM_USER_SGPR;
d184 1
a184 1
		unreachable("invalid shader selector type");
d186 1
a186 1
	num_sgprs = shader->config.num_sgprs;
a193 2
	si_pm4_set_reg(pm4, R_028AAC_VGT_ESGS_RING_ITEMSIZE,
		       shader->selector->esgs_itemsize / 4);
d197 1
a197 1
		       S_00B328_VGPRS((shader->config.num_vgprs - 1) / 4) |
d200 1
a200 2
		       S_00B328_DX10_CLAMP(1) |
		       S_00B328_FLOAT_MODE(shader->config.float_mode));
d203 1
a203 1
		       S_00B32C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0));
d209 1
a209 5
/**
 * Calculate the appropriate setting of VGT_GS_MODE when \p shader is a
 * geometry shader.
 */
static uint32_t si_vgt_gs_mode(struct si_shader *shader)
d211 5
a215 2
	unsigned gs_max_vert_out = shader->selector->gs_max_out_vertices;
	unsigned cut_mode;
d217 3
a219 9
	if (gs_max_vert_out <= 128) {
		cut_mode = V_028A40_GS_CUT_128;
	} else if (gs_max_vert_out <= 256) {
		cut_mode = V_028A40_GS_CUT_256;
	} else if (gs_max_vert_out <= 512) {
		cut_mode = V_028A40_GS_CUT_512;
	} else {
		assert(gs_max_vert_out <= 1024);
		cut_mode = V_028A40_GS_CUT_1024;
d221 1
a221 5

	return S_028A40_MODE(V_028A40_GS_SCENARIO_G) |
	       S_028A40_CUT_MODE(cut_mode)|
	       S_028A40_ES_WRITE_OPTIMIZE(1) |
	       S_028A40_GS_WRITE_OPTIMIZE(1);
d226 3
a228 2
	unsigned gs_vert_itemsize = shader->selector->gsvs_vertex_size;
	unsigned gsvs_itemsize = shader->selector->max_gsvs_emit_size >> 2;
d230 1
d234 1
a234 1
	unsigned max_stream = shader->selector->max_gs_stream;
d241 1
a241 1
	if (!pm4)
d244 16
a259 1
	si_pm4_set_reg(pm4, R_028A40_VGT_GS_MODE, si_vgt_gs_mode(shader));
d265 2
d269 1
a269 1
	si_pm4_set_reg(pm4, R_028B38_VGT_GS_MAX_VERT_OUT, shader->selector->gs_max_out_vertices);
d281 1
a281 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_USER_SHADER);
d286 1
a286 1
	num_sgprs = shader->config.num_sgprs;
d295 1
a295 1
		       S_00B228_VGPRS((shader->config.num_vgprs - 1) / 4) |
d297 1
a297 2
		       S_00B228_DX10_CLAMP(1) |
		       S_00B228_FLOAT_MODE(shader->config.float_mode));
d300 1
a300 1
		       S_00B22C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0));
d303 1
a303 8
/**
 * Compute the state for \p shader, which will run as a vertex shader on the
 * hardware.
 *
 * If \p gs is non-NULL, it points to the geometry shader for which this shader
 * is the copy shader.
 */
static void si_shader_vs(struct si_shader *shader, struct si_shader *gs)
d315 1
a315 1
	if (!pm4)
d318 2
a319 6
	/* We always write VGT_GS_MODE in the VS state, because every switch
	 * between different shader pipelines involving a different GS or no
	 * GS at all involves a switch of the VS (different GS use different
	 * copy shaders). On the other hand, when the API switches from a GS to
	 * no GS and then back to the same GS used originally, the GS state is
	 * not sent again.
d321 1
a321 1
	if (!gs) {
d325 1
a325 2
	} else {
		si_pm4_set_reg(pm4, R_028A40_VGT_GS_MODE, si_vgt_gs_mode(gs));
a326 1
	}
d329 1
a329 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_USER_SHADER);
d331 1
a331 1
	if (gs) {
d335 1
a335 1
		vgpr_comp_cnt = shader->info.uses_instanceid ? 3 : (enable_prim_id ? 2 : 0);
d341 1
a341 1
		unreachable("invalid shader selector type");
d343 1
a343 1
	num_sgprs = shader->config.num_sgprs;
d351 1
a351 1
	nparams = MAX2(shader->info.nr_param_exports, 1);
d357 1
a357 1
		       S_02870C_POS1_EXPORT_FORMAT(shader->info.nr_pos_exports > 1 ?
d360 1
a360 1
		       S_02870C_POS2_EXPORT_FORMAT(shader->info.nr_pos_exports > 2 ?
d363 1
a363 1
		       S_02870C_POS3_EXPORT_FORMAT(shader->info.nr_pos_exports > 3 ?
d370 1
a370 1
		       S_00B128_VGPRS((shader->config.num_vgprs - 1) / 4) |
d373 1
a373 2
		       S_00B128_DX10_CLAMP(1) |
		       S_00B128_FLOAT_MODE(shader->config.float_mode));
d381 1
a381 1
		       S_00B12C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0));
a395 59
static unsigned si_get_ps_num_interp(struct si_shader *ps)
{
	struct tgsi_shader_info *info = &ps->selector->info;
	unsigned num_colors = !!(info->colors_read & 0x0f) +
			      !!(info->colors_read & 0xf0);
	unsigned num_interp = ps->selector->info.num_inputs +
			      (ps->key.ps.prolog.color_two_side ? num_colors : 0);

	assert(num_interp <= 32);
	return MIN2(num_interp, 32);
}

static unsigned si_get_spi_shader_col_format(struct si_shader *shader)
{
	unsigned value = shader->key.ps.epilog.spi_shader_col_format;
	unsigned i, num_targets = (util_last_bit(value) + 3) / 4;

	/* If the i-th target format is set, all previous target formats must
	 * be non-zero to avoid hangs.
	 */
	for (i = 0; i < num_targets; i++)
		if (!(value & (0xf << (i * 4))))
			value |= V_028714_SPI_SHADER_32_R << (i * 4);

	return value;
}

static unsigned si_get_cb_shader_mask(unsigned spi_shader_col_format)
{
	unsigned i, cb_shader_mask = 0;

	for (i = 0; i < 8; i++) {
		switch ((spi_shader_col_format >> (i * 4)) & 0xf) {
		case V_028714_SPI_SHADER_ZERO:
			break;
		case V_028714_SPI_SHADER_32_R:
			cb_shader_mask |= 0x1 << (i * 4);
			break;
		case V_028714_SPI_SHADER_32_GR:
			cb_shader_mask |= 0x3 << (i * 4);
			break;
		case V_028714_SPI_SHADER_32_AR:
			cb_shader_mask |= 0x9 << (i * 4);
			break;
		case V_028714_SPI_SHADER_FP16_ABGR:
		case V_028714_SPI_SHADER_UNORM16_ABGR:
		case V_028714_SPI_SHADER_SNORM16_ABGR:
		case V_028714_SPI_SHADER_UINT16_ABGR:
		case V_028714_SPI_SHADER_SINT16_ABGR:
		case V_028714_SPI_SHADER_32_ABGR:
			cb_shader_mask |= 0xf << (i * 4);
			break;
		default:
			assert(0);
		}
	}
	return cb_shader_mask;
}

d400 1
a400 1
	unsigned spi_ps_in_control, spi_shader_col_format, cb_shader_mask;
d402 1
a402 1
	unsigned spi_baryc_cntl = S_0286E0_FRONT_FACE_ALL_BITS(1);
a403 12
	bool has_centroid;
	unsigned input_ena = shader->config.spi_ps_input_ena;

	/* we need to enable at least one of them, otherwise we hang the GPU */
	assert(G_0286CC_PERSP_SAMPLE_ENA(input_ena) ||
	       G_0286CC_PERSP_CENTER_ENA(input_ena) ||
	       G_0286CC_PERSP_CENTROID_ENA(input_ena) ||
	       G_0286CC_PERSP_PULL_MODEL_ENA(input_ena) ||
	       G_0286CC_LINEAR_SAMPLE_ENA(input_ena) ||
	       G_0286CC_LINEAR_CENTER_ENA(input_ena) ||
	       G_0286CC_LINEAR_CENTROID_ENA(input_ena) ||
	       G_0286CC_LINE_STIPPLE_TEX_ENA(input_ena));
d407 1
a407 1
	if (!pm4)
d410 17
a426 19
	/* SPI_BARYC_CNTL.POS_FLOAT_LOCATION
	 * Possible vaules:
	 * 0 -> Position = pixel center
	 * 1 -> Position = pixel centroid
	 * 2 -> Position = at sample position
	 *
	 * From GLSL 4.5 specification, section 7.1:
	 *   "The variable gl_FragCoord is available as an input variable from
	 *    within fragment shaders and it holds the window relative coordinates
	 *    (x, y, z, 1/w) values for the fragment. If multi-sampling, this
	 *    value can be for any location within the pixel, or one of the
	 *    fragment samples. The use of centroid does not further restrict
	 *    this value to be inside the current primitive."
	 *
	 * Meaning that centroid has no effect and we can return anything within
	 * the pixel. Thus, return the value at sample position, because that's
	 * the most accurate one shaders can get.
	 */
	spi_baryc_cntl |= S_0286E0_POS_FLOAT_LOCATION(2);
d428 6
a433 24
	if (info->properties[TGSI_PROPERTY_FS_COORD_PIXEL_CENTER] ==
	    TGSI_FS_COORD_PIXEL_CENTER_INTEGER)
		spi_baryc_cntl |= S_0286E0_POS_FLOAT_ULC(1);

	spi_shader_col_format = si_get_spi_shader_col_format(shader);
	cb_shader_mask = si_get_cb_shader_mask(spi_shader_col_format);

	/* This must be non-zero for alpha-test/kill to work.
	 * The hardware ignores the EXEC mask if no export memory is allocated.
	 * Don't add this to CB_SHADER_MASK.
	 */
	if (!spi_shader_col_format &&
	    !info->writes_z && !info->writes_stencil && !info->writes_samplemask &&
	    (shader->selector->info.uses_kill ||
	     shader->key.ps.epilog.alpha_func != PIPE_FUNC_ALWAYS))
		spi_shader_col_format = V_028714_SPI_SHADER_32_R;

	si_pm4_set_reg(pm4, R_0286CC_SPI_PS_INPUT_ENA, input_ena);
	si_pm4_set_reg(pm4, R_0286D0_SPI_PS_INPUT_ADDR,
		       shader->config.spi_ps_input_addr);

	/* Set interpolation controls. */
	has_centroid = G_0286CC_PERSP_CENTROID_ENA(shader->config.spi_ps_input_ena) ||
		       G_0286CC_LINEAR_CENTROID_ENA(shader->config.spi_ps_input_ena);
d435 2
a436 2
	spi_ps_in_control = S_0286D8_NUM_INTERP(si_get_ps_num_interp(shader)) |
			    S_0286D8_BC_OPTIMIZE_DISABLE(has_centroid);
a437 1
	/* Set registers. */
d439 13
d454 4
a457 8
	si_pm4_set_reg(pm4, R_028710_SPI_SHADER_Z_FORMAT,
		       info->writes_samplemask ? V_028710_SPI_SHADER_32_ABGR :
		       info->writes_stencil ? V_028710_SPI_SHADER_32_GR :
		       info->writes_z ? V_028710_SPI_SHADER_32_R :
		       V_028710_SPI_SHADER_ZERO);

	si_pm4_set_reg(pm4, R_028714_SPI_SHADER_COL_FORMAT, spi_shader_col_format);
	si_pm4_set_reg(pm4, R_02823C_CB_SHADER_MASK, cb_shader_mask);
d460 1
a460 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_USER_SHADER);
d465 1
a465 1
	num_sgprs = shader->config.num_sgprs;
d474 1
a474 1
		       S_00B028_VGPRS((shader->config.num_vgprs - 1) / 4) |
d476 1
a476 2
		       S_00B028_DX10_CLAMP(1) |
		       S_00B028_FLOAT_MODE(shader->config.float_mode));
d478 1
a478 1
		       S_00B02C_EXTRA_LDS_SIZE(shader->config.lds_size) |
d480 1
a480 1
		       S_00B32C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0));
d496 1
a496 1
			si_shader_vs(shader, NULL);
d505 1
a505 1
			si_shader_vs(shader, NULL);
d509 1
a509 1
		si_shader_vs(shader->gs_copy_shader, shader);
a518 10
static unsigned si_get_alpha_test_func(struct si_context *sctx)
{
	/* Alpha-test should be disabled if colorbuffer 0 is integer. */
	if (sctx->queued.named.dsa &&
	    !sctx->framebuffer.cb0_is_integer)
		return sctx->queued.named.dsa->alpha_func;

	return PIPE_FUNC_ALWAYS;
}

d531 3
a533 5
		if (sctx->vertex_elements) {
			unsigned count = MIN2(sel->info.num_inputs,
					      sctx->vertex_elements->count);
			for (i = 0; i < count; ++i)
				key->vs.prolog.instance_divisors[i] =
d535 2
a536 2
		}
		if (sctx->tes_shader.cso)
d538 1
a538 1
		else if (sctx->gs_shader.cso)
d540 2
d543 3
a545 3
		if (!sctx->gs_shader.cso && sctx->ps_shader.cso &&
		    sctx->ps_shader.cso->info.uses_primid)
			key->vs.epilog.export_prim_id = 1;
d548 2
a549 2
		key->tcs.epilog.prim_mode =
			sctx->tes_shader.cso->info.properties[TGSI_PROPERTY_TES_PRIM_MODE];
d552 1
a552 1
		if (sctx->gs_shader.cso)
d554 3
a556 2
		else if (sctx->ps_shader.cso && sctx->ps_shader.cso->info.uses_primid)
			key->tes.epilog.export_prim_id = 1;
a561 1
		struct si_state_blend *blend = sctx->queued.named.blend;
d563 3
a565 39
		if (sel->info.properties[TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS] &&
		    sel->info.colors_written == 0x1)
			key->ps.epilog.last_cbuf = MAX2(sctx->framebuffer.state.nr_cbufs, 1) - 1;

		if (blend) {
			/* Select the shader color format based on whether
			 * blending or alpha are needed.
			 */
			key->ps.epilog.spi_shader_col_format =
				(blend->blend_enable_4bit & blend->need_src_alpha_4bit &
				 sctx->framebuffer.spi_shader_col_format_blend_alpha) |
				(blend->blend_enable_4bit & ~blend->need_src_alpha_4bit &
				 sctx->framebuffer.spi_shader_col_format_blend) |
				(~blend->blend_enable_4bit & blend->need_src_alpha_4bit &
				 sctx->framebuffer.spi_shader_col_format_alpha) |
				(~blend->blend_enable_4bit & ~blend->need_src_alpha_4bit &
				 sctx->framebuffer.spi_shader_col_format);
		} else
			key->ps.epilog.spi_shader_col_format = sctx->framebuffer.spi_shader_col_format;

		/* If alpha-to-coverage is enabled, we have to export alpha
		 * even if there is no color buffer.
		 */
		if (!(key->ps.epilog.spi_shader_col_format & 0xf) &&
		    blend && blend->alpha_to_coverage)
			key->ps.epilog.spi_shader_col_format |= V_028710_SPI_SHADER_32_AR;

		/* On SI and CIK except Hawaii, the CB doesn't clamp outputs
		 * to the range supported by the type if a channel has less
		 * than 16 bits and the export format is 16_ABGR.
		 */
		if (sctx->b.chip_class <= CIK && sctx->b.family != CHIP_HAWAII)
			key->ps.epilog.color_is_int8 = sctx->framebuffer.color_is_int8;

		/* Disable unwritten outputs (if WRITE_ALL_CBUFS isn't enabled). */
		if (!key->ps.epilog.last_cbuf) {
			key->ps.epilog.spi_shader_col_format &= sel->colors_written_4bit;
			key->ps.epilog.color_is_int8 &= sel->info.colors_written;
		}
d573 1
a573 1
			key->ps.prolog.color_two_side = rs->two_side && sel->info.colors_read;
d576 3
a578 3
				key->ps.epilog.alpha_to_one = sctx->queued.named.blend->alpha_to_one &&
							      rs->multisample_enable &&
							      !sctx->framebuffer.cb0_is_integer;
d581 4
a584 15
			key->ps.prolog.poly_stipple = rs->poly_stipple_enable && is_poly;
			key->ps.epilog.poly_line_smoothing = ((is_poly && rs->poly_smooth) ||
							      (is_line && rs->line_smooth)) &&
							     sctx->framebuffer.nr_samples <= 1;
			key->ps.epilog.clamp_color = rs->clamp_fragment_color;

			key->ps.prolog.force_persample_interp =
				rs->force_persample_interp &&
				rs->multisample_enable &&
				sctx->framebuffer.nr_samples > 1 &&
				sctx->ps_iter_samples > 1 &&
				(sel->info.uses_persp_center ||
				 sel->info.uses_persp_centroid ||
				 sel->info.uses_linear_center ||
				 sel->info.uses_linear_centroid);
d587 5
a591 1
		key->ps.epilog.alpha_func = si_get_alpha_test_func(sctx);
d600 2
a601 3
static int si_shader_select_with_key(struct pipe_context *ctx,
				     struct si_shader_ctx_state *state,
				     union si_shader_key *key)
d604 2
a605 3
	struct si_shader_selector *sel = state->cso;
	struct si_shader *current = state->current;
	struct si_shader *iter, *shader = NULL;
d608 2
d614 1
a614 1
	if (likely(current && memcmp(&current->key, key, sizeof(*key)) == 0))
d616 1
d618 3
a620 1
	pipe_mutex_lock(sel->mutex);
d622 3
a624 8
	/* Find the shader variant. */
	for (iter = sel->first_variant; iter; iter = iter->next_variant) {
		/* Don't check the "current" shader. We checked it above. */
		if (current != iter &&
		    memcmp(&iter->key, key, sizeof(*key)) == 0) {
			state->current = iter;
			pipe_mutex_unlock(sel->mutex);
			return 0;
a625 1
	}
d627 4
a630 16
	/* Build a new shader. */
	shader = CALLOC_STRUCT(si_shader);
	if (!shader) {
		pipe_mutex_unlock(sel->mutex);
		return -ENOMEM;
	}
	shader->selector = sel;
	shader->key = *key;

	r = si_shader_create(sctx->screen, sctx->tm, shader, &sctx->b.debug);
	if (unlikely(r)) {
		R600_ERR("Failed to build shader variant (type=%u) %d\n",
			 sel->type, r);
		FREE(shader);
		pipe_mutex_unlock(sel->mutex);
		return r;
a631 1
	si_shader_init_pm4_state(shader);
d633 3
a635 3
	if (!sel->last_variant) {
		sel->first_variant = shader;
		sel->last_variant = shader;
d637 18
a654 2
		sel->last_variant->next_variant = shader;
		sel->last_variant = shader;
d656 1
a656 2
	state->current = shader;
	pipe_mutex_unlock(sel->mutex);
d660 3
a662 11
static int si_shader_select(struct pipe_context *ctx,
			    struct si_shader_ctx_state *state)
{
	union si_shader_key key;

	si_shader_selector_key(ctx, state->cso, &key);
	return si_shader_select_with_key(ctx, state, &key);
}

static void *si_create_shader_selector(struct pipe_context *ctx,
				       const struct pipe_shader_state *state)
a664 1
	struct si_context *sctx = (struct si_context*)ctx;
d671 1
a679 1
	sel->type = util_pipe_shader_from_tgsi_processor(sel->info.processor);
d682 1
a682 16
	/* Set which opcode uses which (i,j) pair. */
	if (sel->info.uses_persp_opcode_interp_centroid)
		sel->info.uses_persp_centroid = true;

	if (sel->info.uses_linear_opcode_interp_centroid)
		sel->info.uses_linear_centroid = true;

	if (sel->info.uses_persp_opcode_interp_offset ||
	    sel->info.uses_persp_opcode_interp_sample)
		sel->info.uses_persp_center = true;

	if (sel->info.uses_linear_opcode_interp_offset ||
	    sel->info.uses_linear_opcode_interp_sample)
		sel->info.uses_linear_center = true;

	switch (sel->type) {
a689 8
		sel->gsvs_vertex_size = sel->info.num_outputs * 16;
		sel->max_gsvs_emit_size = sel->gsvs_vertex_size *
					  sel->gs_max_out_vertices;

		sel->max_gs_stream = 0;
		for (i = 0; i < sel->so.num_outputs; i++)
			sel->max_gs_stream = MAX2(sel->max_gs_stream,
						  sel->so.output[i].stream);
d691 12
a702 2
		sel->gs_input_verts_per_prim =
			u_vertices_per_prim(sel->info.properties[TGSI_PROPERTY_GS_INPUT_PRIM]);
a706 1
	case PIPE_SHADER_TESS_EVAL:
a722 1
		sel->esgs_itemsize = util_last_bit64(sel->outputs_written) * 16;
a723 1

d725 3
a727 3
		for (i = 0; i < 8; i++)
			if (sel->info.colors_written & (1 << i))
				sel->colors_written_4bit |= 0xf << (4 * i);
d729 2
a730 5
		for (i = 0; i < sel->info.num_inputs; i++) {
			if (sel->info.input_semantic_name[i] == TGSI_SEMANTIC_COLOR) {
				int index = sel->info.input_semantic_index[i];
				sel->color_attr_index[index] = i;
			}
d735 6
a740 50
	/* DB_SHADER_CONTROL */
	sel->db_shader_control =
		S_02880C_Z_EXPORT_ENABLE(sel->info.writes_z) |
		S_02880C_STENCIL_TEST_VAL_EXPORT_ENABLE(sel->info.writes_stencil) |
		S_02880C_MASK_EXPORT_ENABLE(sel->info.writes_samplemask) |
		S_02880C_KILL_ENABLE(sel->info.uses_kill);

	switch (sel->info.properties[TGSI_PROPERTY_FS_DEPTH_LAYOUT]) {
	case TGSI_FS_DEPTH_LAYOUT_GREATER:
		sel->db_shader_control |=
			S_02880C_CONSERVATIVE_Z_EXPORT(V_02880C_EXPORT_GREATER_THAN_Z);
		break;
	case TGSI_FS_DEPTH_LAYOUT_LESS:
		sel->db_shader_control |=
			S_02880C_CONSERVATIVE_Z_EXPORT(V_02880C_EXPORT_LESS_THAN_Z);
		break;
	}

	/* Compile the main shader part for use with a prolog and/or epilog. */
	if (sel->type != PIPE_SHADER_GEOMETRY &&
	    !sscreen->use_monolithic_shaders) {
		struct si_shader *shader = CALLOC_STRUCT(si_shader);
		void *tgsi_binary;

		if (!shader)
			goto error;

		shader->selector = sel;

		tgsi_binary = si_get_tgsi_binary(sel);

		/* Try to load the shader from the shader cache. */
		pipe_mutex_lock(sscreen->shader_cache_mutex);

		if (tgsi_binary &&
		    si_shader_cache_load_shader(sscreen, tgsi_binary, shader)) {
			FREE(tgsi_binary);
		} else {
			/* Compile the shader if it hasn't been loaded from the cache. */
			if (si_compile_tgsi_shader(sscreen, sctx->tm, shader, false,
						   &sctx->b.debug) != 0) {
				FREE(shader);
				FREE(tgsi_binary);
				pipe_mutex_unlock(sscreen->shader_cache_mutex);
				goto error;
			}

			if (tgsi_binary &&
			    !si_shader_cache_insert_shader(sscreen, tgsi_binary, shader))
				FREE(tgsi_binary);
a741 1
		pipe_mutex_unlock(sscreen->shader_cache_mutex);
d743 2
a744 2
		sel->main_shader_part = shader;
	}
d746 5
a750 5
	/* Pre-compilation. */
	if (sel->type == PIPE_SHADER_GEOMETRY ||
	    sscreen->b.debug_flags & DBG_PRECOMPILE) {
		struct si_shader_ctx_state state = {sel};
		union si_shader_key key;
d752 5
a756 1
		memset(&key, 0, sizeof(key));
d758 5
a762 15
		/* Set reasonable defaults, so that the shader key doesn't
		 * cause any code to be eliminated.
		 */
		switch (sel->type) {
		case PIPE_SHADER_TESS_CTRL:
			key.tcs.epilog.prim_mode = PIPE_PRIM_TRIANGLES;
			break;
		case PIPE_SHADER_FRAGMENT:
			key.ps.epilog.alpha_func = PIPE_FUNC_ALWAYS;
			for (i = 0; i < 8; i++)
				if (sel->info.colors_written & (1 << i))
					key.ps.epilog.spi_shader_col_format |=
						V_028710_SPI_SHADER_FP16_ABGR << (i * 4);
			break;
		}
d764 4
a767 12
		if (si_shader_select_with_key(ctx, &state, &key))
			goto error;
	}

	pipe_mutex_init(sel->mutex);
	return sel;

error:
	fprintf(stderr, "radeonsi: can't create a shader\n");
	tgsi_free_tokens(sel->tokens);
	FREE(sel);
	return NULL;
d770 2
a771 7
/**
 * Normally, we only emit 1 viewport and 1 scissor if no shader is using
 * the VIEWPORT_INDEX output, and emitting the other viewports and scissors
 * is delayed. When a shader with VIEWPORT_INDEX appears, this should be
 * called to emit the rest.
 */
static void si_update_viewports_and_scissors(struct si_context *sctx)
d773 1
a773 9
	struct tgsi_shader_info *info = si_get_vs_info(sctx);

	if (!info || !info->writes_viewport_index)
		return;

	if (sctx->scissors.dirty_mask)
	    si_mark_atom_dirty(sctx, &sctx->scissors.atom);
	if (sctx->viewports.dirty_mask)
	    si_mark_atom_dirty(sctx, &sctx->viewports.atom);
d781 1
a781 1
	if (sctx->vs_shader.cso == sel)
d784 1
a784 2
	sctx->vs_shader.cso = sel;
	sctx->vs_shader.current = sel ? sel->first_variant : NULL;
a785 1
	si_update_viewports_and_scissors(sctx);
d792 1
a792 1
	bool enable_changed = !!sctx->gs_shader.cso != !!sel;
d794 1
a794 1
	if (sctx->gs_shader.cso == sel)
d797 1
a797 2
	sctx->gs_shader.cso = sel;
	sctx->gs_shader.current = sel ? sel->first_variant : NULL;
a802 1
	si_update_viewports_and_scissors(sctx);
d809 1
a809 1
	bool enable_changed = !!sctx->tcs_shader.cso != !!sel;
d811 1
a811 1
	if (sctx->tcs_shader.cso == sel)
d814 1
a814 2
	sctx->tcs_shader.cso = sel;
	sctx->tcs_shader.current = sel ? sel->first_variant : NULL;
d824 1
a824 1
	bool enable_changed = !!sctx->tes_shader.cso != !!sel;
d826 1
a826 1
	if (sctx->tes_shader.cso == sel)
d829 1
a829 2
	sctx->tes_shader.cso = sel;
	sctx->tes_shader.current = sel ? sel->first_variant : NULL;
d837 10
a846 1
	si_update_viewports_and_scissors(sctx);
d855 1
a855 1
	if (sctx->ps_shader.cso == sel)
d858 8
a865 3
	sctx->ps_shader.cso = sel;
	sctx->ps_shader.current = sel ? sel->first_variant : NULL;
	si_mark_atom_dirty(sctx, &sctx->cb_render_state);
d868 2
a869 1
static void si_delete_shader(struct si_context *sctx, struct si_shader *shader)
d871 6
a876 2
	if (shader->pm4) {
		switch (shader->selector->type) {
d878 4
a881 4
			if (shader->key.vs.as_ls)
				si_pm4_delete_state(sctx, ls, shader->pm4);
			else if (shader->key.vs.as_es)
				si_pm4_delete_state(sctx, es, shader->pm4);
d883 1
a883 1
				si_pm4_delete_state(sctx, vs, shader->pm4);
d886 1
a886 1
			si_pm4_delete_state(sctx, hs, shader->pm4);
d889 2
a890 2
			if (shader->key.tes.as_es)
				si_pm4_delete_state(sctx, es, shader->pm4);
d892 1
a892 1
				si_pm4_delete_state(sctx, vs, shader->pm4);
d895 2
a896 2
			si_pm4_delete_state(sctx, gs, shader->pm4);
			si_pm4_delete_state(sctx, vs, shader->gs_copy_shader->pm4);
d899 1
a899 1
			si_pm4_delete_state(sctx, ps, shader->pm4);
d902 4
d908 2
a909 2
	si_shader_destroy(shader);
	free(shader);
d912 1
a912 1
static void si_delete_shader_selector(struct pipe_context *ctx, void *state)
d916 3
a918 12
	struct si_shader *p = sel->first_variant, *c;
	struct si_shader_ctx_state *current_shader[SI_NUM_SHADERS] = {
		[PIPE_SHADER_VERTEX] = &sctx->vs_shader,
		[PIPE_SHADER_TESS_CTRL] = &sctx->tcs_shader,
		[PIPE_SHADER_TESS_EVAL] = &sctx->tes_shader,
		[PIPE_SHADER_GEOMETRY] = &sctx->gs_shader,
		[PIPE_SHADER_FRAGMENT] = &sctx->ps_shader,
	};

	if (current_shader[sel->type]->cso == sel) {
		current_shader[sel->type]->cso = NULL;
		current_shader[sel->type]->current = NULL;
d921 10
a930 4
	while (p) {
		c = p->next_variant;
		si_delete_shader(sctx, p);
		p = c;
d933 11
a943 2
	if (sel->main_shader_part)
		si_delete_shader(sctx, sel->main_shader_part);
d945 1
a945 3
	pipe_mutex_destroy(sel->mutex);
	free(sel->tokens);
	free(sel);
d948 1
a948 3
static unsigned si_get_ps_input_cntl(struct si_context *sctx,
				     struct si_shader *vs, unsigned name,
				     unsigned index, unsigned interpolate)
d950 2
a951 2
	struct tgsi_shader_info *vsinfo = &vs->selector->info;
	unsigned j, ps_input_cntl = 0;
d953 2
a954 16
	if (interpolate == TGSI_INTERPOLATE_CONSTANT ||
	    (interpolate == TGSI_INTERPOLATE_COLOR && sctx->flatshade))
		ps_input_cntl |= S_028644_FLAT_SHADE(1);

	if (name == TGSI_SEMANTIC_PCOORD ||
	    (name == TGSI_SEMANTIC_TEXCOORD &&
	     sctx->sprite_coord_enable & (1 << index))) {
		ps_input_cntl |= S_028644_PT_SPRITE_TEX(1);
	}

	for (j = 0; j < vsinfo->num_outputs; j++) {
		if (name == vsinfo->output_semantic_name[j] &&
		    index == vsinfo->output_semantic_index[j]) {
			ps_input_cntl |= S_028644_OFFSET(vs->info.vs_output_param_offset[j]);
			break;
		}
d957 10
a966 8
	if (name == TGSI_SEMANTIC_PRIMID)
		/* PrimID is written after the last output. */
		ps_input_cntl |= S_028644_OFFSET(vs->info.vs_output_param_offset[vsinfo->num_outputs]);
	else if (j == vsinfo->num_outputs && !G_028644_PT_SPRITE_TEX(ps_input_cntl)) {
		/* No corresponding output found, load defaults into input.
		 * Don't set any other bits.
		 * (FLAT_SHADE=1 completely changes behavior) */
		ps_input_cntl = S_028644_OFFSET(0x20);
d968 2
a969 1
	return ps_input_cntl;
d972 1
a972 1
static void si_emit_spi_map(struct si_context *sctx, struct r600_atom *atom)
d974 1
a974 2
	struct radeon_winsys_cs *cs = sctx->b.gfx.cs;
	struct si_shader *ps = sctx->ps_shader.current;
d976 4
a979 9
	struct tgsi_shader_info *psinfo = ps ? &ps->selector->info : NULL;
	unsigned i, num_interp, num_written = 0, bcol_interp[2];

	if (!ps || !ps->selector->info.num_inputs)
		return;

	num_interp = si_get_ps_num_interp(ps);
	assert(num_interp > 0);
	radeon_set_context_reg_seq(cs, R_028644_SPI_PS_INPUT_CNTL_0, num_interp);
d985 1
d987 25
a1011 3
		radeon_emit(cs, si_get_ps_input_cntl(sctx, vs, name, index,
						     interpolate));
		num_written++;
d1013 8
a1020 3
		if (name == TGSI_SEMANTIC_COLOR) {
			assert(index < ARRAY_SIZE(bcol_interp));
			bcol_interp[index] = interpolate;
a1021 4
	}

	if (ps->key.ps.prolog.color_two_side) {
		unsigned bcol = TGSI_SEMANTIC_BCOLOR;
d1023 3
a1025 3
		for (i = 0; i < 2; i++) {
			if (!(psinfo->colors_read & (0xf << (i * 4))))
				continue;
d1027 5
a1031 3
			radeon_emit(cs, si_get_ps_input_cntl(sctx, vs, bcol,
							     i, bcol_interp[i]));
			num_written++;
a1033 10
	assert(num_interp == num_written);
}

/**
 * Writing CONFIG or UCONFIG VGT registers requires VGT_FLUSH before that.
 */
static void si_init_config_add_vgt_flush(struct si_context *sctx)
{
	if (sctx->init_config_has_vgt_flush)
		return;
d1035 1
a1035 5
	/* VGT_FLUSH is required even if VGT is idle. It resets VGT pointers. */
	si_pm4_cmd_begin(sctx->init_config, PKT3_EVENT_WRITE);
	si_pm4_cmd_add(sctx->init_config, EVENT_TYPE(V_028A90_VGT_FLUSH) | EVENT_INDEX(0));
	si_pm4_cmd_end(sctx->init_config, false);
	sctx->init_config_has_vgt_flush = true;
d1039 1
a1039 1
static bool si_update_gs_ring_buffers(struct si_context *sctx)
d1041 2
a1042 4
	struct si_shader_selector *es =
		sctx->tes_shader.cso ? sctx->tes_shader.cso : sctx->vs_shader.cso;
	struct si_shader_selector *gs = sctx->gs_shader.cso;
	struct si_pm4_state *pm4;
d1044 2
a1045 22
	/* Chip constants. */
	unsigned num_se = sctx->screen->b.info.max_se;
	unsigned wave_size = 64;
	unsigned max_gs_waves = 32 * num_se; /* max 32 per SE on GCN */
	unsigned gs_vertex_reuse = 16 * num_se; /* GS_VERTEX_REUSE register (per SE) */
	unsigned alignment = 256 * num_se;
	/* The maximum size is 63.999 MB per SE. */
	unsigned max_size = ((unsigned)(63.999 * 1024 * 1024) & ~255) * num_se;

	/* Calculate the minimum size. */
	unsigned min_esgs_ring_size = align(es->esgs_itemsize * gs_vertex_reuse *
					    wave_size, alignment);

	/* These are recommended sizes, not minimum sizes. */
	unsigned esgs_ring_size = max_gs_waves * 2 * wave_size *
				  es->esgs_itemsize * gs->gs_input_verts_per_prim;
	unsigned gsvs_ring_size = max_gs_waves * 2 * wave_size *
				  gs->max_gsvs_emit_size * (gs->max_gs_stream + 1);

	min_esgs_ring_size = align(min_esgs_ring_size, alignment);
	esgs_ring_size = align(esgs_ring_size, alignment);
	gsvs_ring_size = align(gsvs_ring_size, alignment);
d1047 2
a1048 2
	esgs_ring_size = CLAMP(esgs_ring_size, min_esgs_ring_size, max_size);
	gsvs_ring_size = MIN2(gsvs_ring_size, max_size);
d1050 6
a1055 9
	/* Some rings don't have to be allocated if shaders don't use them.
	 * (e.g. no varyings between ES and GS or GS and VS)
	 */
	bool update_esgs = esgs_ring_size &&
			   (!sctx->esgs_ring ||
			    sctx->esgs_ring->width0 < esgs_ring_size);
	bool update_gsvs = gsvs_ring_size &&
			   (!sctx->gsvs_ring ||
			    sctx->gsvs_ring->width0 < gsvs_ring_size);
d1057 3
a1059 4
	if (!update_esgs && !update_gsvs)
		return true;

	if (update_esgs) {
d1061 2
a1062 14
		sctx->esgs_ring = pipe_buffer_create(sctx->b.b.screen, PIPE_BIND_CUSTOM,
						     PIPE_USAGE_DEFAULT,
						     esgs_ring_size);
		if (!sctx->esgs_ring)
			return false;
	}

	if (update_gsvs) {
		pipe_resource_reference(&sctx->gsvs_ring, NULL);
		sctx->gsvs_ring = pipe_buffer_create(sctx->b.b.screen, PIPE_BIND_CUSTOM,
						     PIPE_USAGE_DEFAULT,
						     gsvs_ring_size);
		if (!sctx->gsvs_ring)
			return false;
a1064 5
	/* Create the "init_config_gs_rings" state. */
	pm4 = CALLOC_STRUCT(si_pm4_state);
	if (!pm4)
		return false;

d1066 10
a1075 6
		if (sctx->esgs_ring)
			si_pm4_set_reg(pm4, R_030900_VGT_ESGS_RING_SIZE,
				       sctx->esgs_ring->width0 / 256);
		if (sctx->gsvs_ring)
			si_pm4_set_reg(pm4, R_030904_VGT_GSVS_RING_SIZE,
				       sctx->gsvs_ring->width0 / 256);
d1077 22
a1098 41
		if (sctx->esgs_ring)
			si_pm4_set_reg(pm4, R_0088C8_VGT_ESGS_RING_SIZE,
				       sctx->esgs_ring->width0 / 256);
		if (sctx->gsvs_ring)
			si_pm4_set_reg(pm4, R_0088CC_VGT_GSVS_RING_SIZE,
				       sctx->gsvs_ring->width0 / 256);
	}

	/* Set the state. */
	if (sctx->init_config_gs_rings)
		si_pm4_free_state(sctx, sctx->init_config_gs_rings, ~0);
	sctx->init_config_gs_rings = pm4;

	if (!sctx->init_config_has_vgt_flush) {
		si_init_config_add_vgt_flush(sctx);
		si_pm4_upload_indirect_buffer(sctx, sctx->init_config);
	}

	/* Flush the context to re-emit both init_config states. */
	sctx->b.initial_gfx_cs_size = 0; /* force flush */
	si_context_gfx_flush(sctx, RADEON_FLUSH_ASYNC, NULL);

	/* Set ring bindings. */
	if (sctx->esgs_ring) {
		si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_VERTEX, SI_RING_ESGS,
				   sctx->esgs_ring, 0, sctx->esgs_ring->width0,
				   true, true, 4, 64, 0);
		si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_GEOMETRY, SI_RING_ESGS,
				   sctx->esgs_ring, 0, sctx->esgs_ring->width0,
				   false, false, 0, 0, 0);
	}
	if (sctx->gsvs_ring)
		si_set_ring_buffer(&sctx->b.b, PIPE_SHADER_VERTEX, SI_RING_GSVS,
				   sctx->gsvs_ring, 0, sctx->gsvs_ring->width0,
				   false, false, 0, 0, 0);
	return true;
}

static void si_update_gsvs_ring_bindings(struct si_context *sctx)
{
	unsigned gsvs_itemsize = sctx->gs_shader.cso->max_gsvs_emit_size;
a1100 5
	if (!sctx->gsvs_ring || gsvs_itemsize == sctx->last_gsvs_itemsize)
		return;

	sctx->last_gsvs_itemsize = gsvs_itemsize;

d1119 1
a1120 1

d1127 1
a1127 1
				    struct si_shader *shader)
d1129 1
d1133 1
a1133 1
	if (!shader)
d1136 2
d1139 1
a1139 1
	if (shader->config.scratch_bytes_per_wave == 0)
d1166 4
a1169 1
	return sctx->scratch_buffer ? sctx->scratch_buffer->b.b.width0 : 0;
d1172 2
a1173 1
static unsigned si_get_scratch_buffer_bytes_per_wave(struct si_shader *shader)
d1175 4
a1178 1
	return shader ? shader->config.scratch_bytes_per_wave : 0;
d1185 5
a1189 5
	bytes = MAX2(bytes, si_get_scratch_buffer_bytes_per_wave(sctx->ps_shader.current));
	bytes = MAX2(bytes, si_get_scratch_buffer_bytes_per_wave(sctx->gs_shader.current));
	bytes = MAX2(bytes, si_get_scratch_buffer_bytes_per_wave(sctx->vs_shader.current));
	bytes = MAX2(bytes, si_get_scratch_buffer_bytes_per_wave(sctx->tcs_shader.current));
	bytes = MAX2(bytes, si_get_scratch_buffer_bytes_per_wave(sctx->tes_shader.current));
d1205 1
d1225 1
a1225 1
		r = si_update_scratch_buffer(sctx, sctx->ps_shader.current);
d1229 1
a1229 1
			si_pm4_bind_state(sctx, ps, sctx->ps_shader.current->pm4);
d1231 1
a1231 1
		r = si_update_scratch_buffer(sctx, sctx->gs_shader.current);
d1235 1
a1235 1
			si_pm4_bind_state(sctx, gs, sctx->gs_shader.current->pm4);
d1237 1
a1237 1
		r = si_update_scratch_buffer(sctx, sctx->tcs_shader.current);
d1241 1
a1241 1
			si_pm4_bind_state(sctx, hs, sctx->tcs_shader.current->pm4);
d1244 18
a1261 10
		r = si_update_scratch_buffer(sctx, sctx->vs_shader.current);
		if (r < 0)
			return false;
		if (r == 1) {
			if (sctx->tes_shader.current)
				si_pm4_bind_state(sctx, ls, sctx->vs_shader.current->pm4);
			else if (sctx->gs_shader.current)
				si_pm4_bind_state(sctx, es, sctx->vs_shader.current->pm4);
			else
				si_pm4_bind_state(sctx, vs, sctx->vs_shader.current->pm4);
d1265 12
a1276 8
		r = si_update_scratch_buffer(sctx, sctx->tes_shader.current);
		if (r < 0)
			return false;
		if (r == 1) {
			if (sctx->gs_shader.current)
				si_pm4_bind_state(sctx, es, sctx->tes_shader.current->pm4);
			else
				si_pm4_bind_state(sctx, vs, sctx->tes_shader.current->pm4);
d1295 5
a1299 1
	assert(!sctx->tf_ring);
d1304 2
a1305 1
	if (!sctx->tf_ring)
d1307 4
a1313 3
	si_init_config_add_vgt_flush(sctx);

	/* Append these registers to the init config state. */
d1315 1
a1315 1
		si_pm4_set_reg(sctx->init_config, R_030938_VGT_TF_RING_SIZE,
d1317 1
a1317 1
		si_pm4_set_reg(sctx->init_config, R_030940_VGT_TF_MEMORY_BASE,
d1320 1
a1320 1
		si_pm4_set_reg(sctx->init_config, R_008988_VGT_TF_RING_SIZE,
d1322 1
a1322 1
		si_pm4_set_reg(sctx->init_config, R_0089B8_VGT_TF_MEMORY_BASE,
d1325 3
a1327 7

	/* Flush the context to re-emit the init_config state.
	 * This is done only once in a lifetime of a context.
	 */
	si_pm4_upload_indirect_buffer(sctx, sctx->init_config);
	sctx->b.initial_gfx_cs_size = 0; /* force flush */
	si_context_gfx_flush(sctx, RADEON_FLUSH_ASYNC, NULL);
d1332 2
d1350 1
a1350 1
	assert(!sctx->fixed_func_tcs_shader.cso);
d1365 1
a1365 1
	sctx->fixed_func_tcs_shader.cso =
d1373 1
a1373 1
	unsigned index = 2*!!sctx->tes_shader.cso + !!sctx->gs_shader.cso;
d1381 1
a1381 1
		if (sctx->tes_shader.cso) {
d1385 1
a1385 1
			if (sctx->gs_shader.cso)
d1391 1
a1391 1
		} else if (sctx->gs_shader.cso) {
d1421 2
a1422 2
	if (sctx->tes_shader.cso) {
		if (!sctx->tf_ring) {
d1424 1
a1424 1
			if (!sctx->tf_ring)
d1429 1
a1429 1
		r = si_shader_select(ctx, &sctx->vs_shader);
d1432 1
a1432 1
		si_pm4_bind_state(sctx, ls, sctx->vs_shader.current->pm4);
d1434 2
a1435 2
		if (sctx->tcs_shader.cso) {
			r = si_shader_select(ctx, &sctx->tcs_shader);
d1438 1
a1438 1
			si_pm4_bind_state(sctx, hs, sctx->tcs_shader.current->pm4);
d1440 1
a1440 1
			if (!sctx->fixed_func_tcs_shader.cso) {
d1442 1
a1442 1
				if (!sctx->fixed_func_tcs_shader.cso)
d1446 1
a1446 1
			r = si_shader_select(ctx, &sctx->fixed_func_tcs_shader);
d1450 1
a1450 1
					  sctx->fixed_func_tcs_shader.current->pm4);
d1453 1
a1453 1
		r = si_shader_select(ctx, &sctx->tes_shader);
d1457 1
a1457 1
		if (sctx->gs_shader.cso) {
d1459 1
a1459 1
			si_pm4_bind_state(sctx, es, sctx->tes_shader.current->pm4);
d1462 2
a1463 2
			si_pm4_bind_state(sctx, vs, sctx->tes_shader.current->pm4);
			si_update_so(sctx, sctx->tes_shader.cso);
d1465 1
a1465 1
	} else if (sctx->gs_shader.cso) {
d1467 1
a1467 1
		r = si_shader_select(ctx, &sctx->vs_shader);
d1470 1
a1470 1
		si_pm4_bind_state(sctx, es, sctx->vs_shader.current->pm4);
d1473 1
a1473 1
		r = si_shader_select(ctx, &sctx->vs_shader);
d1476 2
a1477 2
		si_pm4_bind_state(sctx, vs, sctx->vs_shader.current->pm4);
		si_update_so(sctx, sctx->vs_shader.cso);
d1481 2
a1482 2
	if (sctx->gs_shader.cso) {
		r = si_shader_select(ctx, &sctx->gs_shader);
d1485 9
a1493 3
		si_pm4_bind_state(sctx, gs, sctx->gs_shader.current->pm4);
		si_pm4_bind_state(sctx, vs, sctx->gs_shader.current->gs_copy_shader->pm4);
		si_update_so(sctx, sctx->gs_shader.cso);
d1495 3
a1497 2
		if (!si_update_gs_ring_buffers(sctx))
			return false;
d1499 1
a1499 1
		si_update_gsvs_ring_bindings(sctx);
d1501 1
d1508 4
a1511 20
	if (sctx->ps_shader.cso) {
		unsigned db_shader_control =
			sctx->ps_shader.cso->db_shader_control |
			S_02880C_KILL_ENABLE(si_get_alpha_test_func(sctx) != PIPE_FUNC_ALWAYS);

		r = si_shader_select(ctx, &sctx->ps_shader);
		if (r)
			return false;
		si_pm4_bind_state(sctx, ps, sctx->ps_shader.current->pm4);

		if (si_pm4_state_changed(sctx, ps) || si_pm4_state_changed(sctx, vs) ||
		    sctx->sprite_coord_enable != rs->sprite_coord_enable ||
		    sctx->flatshade != rs->flatshade) {
			sctx->sprite_coord_enable = rs->sprite_coord_enable;
			sctx->flatshade = rs->flatshade;
			si_mark_atom_dirty(sctx, &sctx->spi_map);
		}

		if (sctx->b.family == CHIP_STONEY && si_pm4_state_changed(sctx, ps))
			si_mark_atom_dirty(sctx, &sctx->cb_render_state);
d1513 6
a1518 12
		if (sctx->ps_db_shader_control != db_shader_control) {
			sctx->ps_db_shader_control = db_shader_control;
			si_mark_atom_dirty(sctx, &sctx->db_render_state);
		}

		if (sctx->smoothing_enabled != sctx->ps_shader.current->key.ps.epilog.poly_line_smoothing) {
			sctx->smoothing_enabled = sctx->ps_shader.current->key.ps.epilog.poly_line_smoothing;
			si_mark_atom_dirty(sctx, &sctx->msaa_config);

			if (sctx->b.chip_class == SI)
				si_mark_atom_dirty(sctx, &sctx->db_render_state);
		}
d1530 13
d1548 5
a1552 7
	si_init_atom(sctx, &sctx->spi_map, &sctx->atoms.s.spi_map, si_emit_spi_map);

	sctx->b.b.create_vs_state = si_create_shader_selector;
	sctx->b.b.create_tcs_state = si_create_shader_selector;
	sctx->b.b.create_tes_state = si_create_shader_selector;
	sctx->b.b.create_gs_state = si_create_shader_selector;
	sctx->b.b.create_fs_state = si_create_shader_selector;
d1560 5
a1564 5
	sctx->b.b.delete_vs_state = si_delete_shader_selector;
	sctx->b.b.delete_tcs_state = si_delete_shader_selector;
	sctx->b.b.delete_tes_state = si_delete_shader_selector;
	sctx->b.b.delete_gs_state = si_delete_shader_selector;
	sctx->b.b.delete_fs_state = si_delete_shader_selector;
@


1.1.1.5
log
@Import Mesa 13.0.2
@
text
@d29 1
d39 1
d66 1
a66 3
	/* data may be NULL if size == 0 */
	if (size)
		memcpy(ptr, data, size);
a96 2
	if (!*size)
		return ptr;
a110 2
	unsigned llvm_ir_size = shader->binary.llvm_ir_string ?
				strlen(shader->binary.llvm_ir_string) + 1 : 0;
d119 1
a119 2
		4 + align(disasm_size, 4) +
		4 + align(llvm_ir_size, 4);
a134 1
	ptr = write_chunk(ptr, shader->binary.llvm_ir_string, llvm_ir_size);
a165 1
	ptr = read_chunk(ptr, (void**)&shader->binary.llvm_ir_string, &chunk_size);
d180 1
a180 2
	void *hw_binary;
	struct hash_entry *entry;
a181 5
	entry = _mesa_hash_table_search(sscreen->shader_cache, tgsi_binary);
	if (entry)
		return false; /* already added */

	hw_binary = si_get_shader_binary(shader);
d250 1
a250 2
static void si_set_tesseval_regs(struct si_screen *sscreen,
				 struct si_shader *shader,
d258 1
a258 1
	unsigned type, partitioning, topology, distribution_mode;
a299 9
	if (sscreen->has_distributed_tess) {
		if (sscreen->b.family == CHIP_FIJI ||
		    sscreen->b.family >= CHIP_POLARIS10)
			distribution_mode = V_028B6C_DISTRIBUTION_MODE_TRAPEZOIDS;
		else
			distribution_mode = V_028B6C_DISTRIBUTION_MODE_DONUTS;
	} else
		distribution_mode = V_028B6C_DISTRIBUTION_MODE_NO_DIST;

d303 1
a303 12
		       S_028B6C_TOPOLOGY(topology) |
		       S_028B6C_DISTRIBUTION_MODE(distribution_mode));
}

static struct si_pm4_state *si_get_shader_pm4_state(struct si_shader *shader)
{
	if (shader->pm4)
		si_pm4_clear_state(shader->pm4);
	else
		shader->pm4 = CALLOC_STRUCT(si_pm4_state);

	return shader->pm4;
d309 1
d313 1
a313 1
	pm4 = si_get_shader_pm4_state(shader);
d318 1
a318 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_BINARY);
d324 8
d336 1
a336 1
			   S_00B528_SGPRS((shader->config.num_sgprs - 1) / 8) |
d340 1
a340 1
	shader->config.rsrc2 = S_00B52C_USER_SGPR(SI_LS_NUM_USER_SGPR) |
d347 1
d350 1
a350 1
	pm4 = si_get_shader_pm4_state(shader);
d355 11
a365 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_BINARY);
d371 1
a371 1
		       S_00B428_SGPRS((shader->config.num_sgprs - 1) / 8) |
d375 1
a375 2
		       S_00B42C_USER_SGPR(SI_TCS_NUM_USER_SGPR) |
		       S_00B42C_OC_LDS_EN(1) |
d379 1
a379 1
static void si_shader_es(struct si_screen *sscreen, struct si_shader *shader)
d382 1
a382 1
	unsigned num_user_sgprs;
a384 1
	unsigned oc_lds_en;
d386 2
a387 1
	pm4 = si_get_shader_pm4_state(shader);
d392 1
a392 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_BINARY);
d403 7
a409 1
	oc_lds_en = shader->selector->type == PIPE_SHADER_TESS_EVAL ? 1 : 0;
d417 1
a417 1
		       S_00B328_SGPRS((shader->config.num_sgprs - 1) / 8) |
a422 1
		       S_00B32C_OC_LDS_EN(oc_lds_en) |
d426 1
a426 1
		si_set_tesseval_regs(sscreen, shader, pm4);
d461 1
d468 2
a469 1
	pm4 = si_get_shader_pm4_state(shader);
d493 1
a493 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_BINARY);
d497 9
d508 1
a508 1
		       S_00B228_SGPRS((shader->config.num_sgprs - 1) / 8) |
d512 1
a512 1
		       S_00B22C_USER_SGPR(SI_GS_NUM_USER_SGPR) |
d523 1
a523 2
static void si_shader_vs(struct si_screen *sscreen, struct si_shader *shader,
                         struct si_shader *gs)
d526 1
a526 1
	unsigned num_user_sgprs;
a528 1
	unsigned oc_lds_en;
d533 2
a534 1
	pm4 = si_get_shader_pm4_state(shader);
d555 1
a555 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_BINARY);
d569 7
a592 2
	oc_lds_en = shader->selector->type == PIPE_SHADER_TESS_EVAL ? 1 : 0;

d597 1
a597 1
		       S_00B128_SGPRS((shader->config.num_sgprs - 1) / 8) |
a602 1
		       S_00B12C_OC_LDS_EN(oc_lds_en) |
d620 1
a620 1
		si_set_tesseval_regs(sscreen, shader, pm4);
d687 1
d690 1
a701 6
	/* POS_W_FLOAT_ENA requires one of the perspective weights. */
	assert(!G_0286CC_POS_W_FLOAT_ENA(input_ena) ||
	       G_0286CC_PERSP_SAMPLE_ENA(input_ena) ||
	       G_0286CC_PERSP_CENTER_ENA(input_ena) ||
	       G_0286CC_PERSP_CENTROID_ENA(input_ena) ||
	       G_0286CC_PERSP_PULL_MODEL_ENA(input_ena));
d703 1
a703 27
	/* Validate interpolation optimization flags (read as implications). */
	assert(!shader->key.ps.prolog.bc_optimize_for_persp ||
	       (G_0286CC_PERSP_CENTER_ENA(input_ena) &&
		G_0286CC_PERSP_CENTROID_ENA(input_ena)));
	assert(!shader->key.ps.prolog.bc_optimize_for_linear ||
	       (G_0286CC_LINEAR_CENTER_ENA(input_ena) &&
		G_0286CC_LINEAR_CENTROID_ENA(input_ena)));
	assert(!shader->key.ps.prolog.force_persp_center_interp ||
	       (!G_0286CC_PERSP_SAMPLE_ENA(input_ena) &&
		!G_0286CC_PERSP_CENTROID_ENA(input_ena)));
	assert(!shader->key.ps.prolog.force_linear_center_interp ||
	       (!G_0286CC_LINEAR_SAMPLE_ENA(input_ena) &&
		!G_0286CC_LINEAR_CENTROID_ENA(input_ena)));
	assert(!shader->key.ps.prolog.force_persp_sample_interp ||
	       (!G_0286CC_PERSP_CENTER_ENA(input_ena) &&
		!G_0286CC_PERSP_CENTROID_ENA(input_ena)));
	assert(!shader->key.ps.prolog.force_linear_sample_interp ||
	       (!G_0286CC_LINEAR_CENTER_ENA(input_ena) &&
		!G_0286CC_LINEAR_CENTROID_ENA(input_ena)));

	/* Validate cases when the optimizations are off (read as implications). */
	assert(shader->key.ps.prolog.bc_optimize_for_persp ||
	       !G_0286CC_PERSP_CENTER_ENA(input_ena) ||
	       !G_0286CC_PERSP_CENTROID_ENA(input_ena));
	assert(shader->key.ps.prolog.bc_optimize_for_linear ||
	       !G_0286CC_LINEAR_CENTER_ENA(input_ena) ||
	       !G_0286CC_LINEAR_CENTROID_ENA(input_ena));
a704 1
	pm4 = si_get_shader_pm4_state(shader);
d735 2
a736 9
	/* Ensure that some export memory is always allocated, for two reasons:
	 *
	 * 1) Correctness: The hardware ignores the EXEC mask if no export
	 *    memory is allocated, so KILL and alpha test do not work correctly
	 *    without this.
	 * 2) Performance: Every shader needs at least a NULL export, even when
	 *    it writes no color/depth output. The NULL export instruction
	 *    stalls without this setting.
	 *
d740 3
a742 1
	    !info->writes_z && !info->writes_stencil && !info->writes_samplemask)
d750 5
a754 1
	spi_ps_in_control = S_0286D8_NUM_INTERP(si_get_ps_num_interp(shader));
d761 4
a764 3
		       si_get_spi_shader_z_format(info->writes_z,
						  info->writes_stencil,
						  info->writes_samplemask));
d770 1
a770 1
	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ, RADEON_PRIO_SHADER_BINARY);
d774 9
d785 1
a785 1
		       S_00B028_SGPRS((shader->config.num_sgprs - 1) / 8) |
d790 1
a790 1
		       S_00B02C_USER_SGPR(SI_PS_NUM_USER_SGPR) |
d794 1
a794 2
static void si_shader_init_pm4_state(struct si_screen *sscreen,
                                     struct si_shader *shader)
d796 4
d805 1
a805 1
			si_shader_es(sscreen, shader);
d807 1
a807 1
			si_shader_vs(sscreen, shader, NULL);
d814 1
a814 1
			si_shader_es(sscreen, shader);
d816 1
a816 1
			si_shader_vs(sscreen, shader, NULL);
d820 1
a820 1
		si_shader_vs(sscreen, shader->gs_copy_shader, shader);
d833 2
a834 1
	if (sctx->queued.named.dsa)
a870 3

		if (sel == sctx->fixed_func_tcs_shader.cso)
			key->tcs.epilog.inputs_to_copy = sctx->vs_shader.cso->outputs_written;
a900 7

			/* The output for dual source blending should have
			 * the same format as the first output.
			 */
			if (blend->dual_src_blend)
				key->ps.epilog.spi_shader_col_format |=
					(key->ps.epilog.spi_shader_col_format & 0xf) << 4;
a930 1
			key->ps.prolog.flatshade_colors = rs->flatshade && sel->info.colors_read;
d934 2
a935 1
							      rs->multisample_enable;
d944 9
a952 32
			if (rs->force_persample_interp &&
			    rs->multisample_enable &&
			    sctx->framebuffer.nr_samples > 1 &&
			    sctx->ps_iter_samples > 1) {
				key->ps.prolog.force_persp_sample_interp =
					sel->info.uses_persp_center ||
					sel->info.uses_persp_centroid;

				key->ps.prolog.force_linear_sample_interp =
					sel->info.uses_linear_center ||
					sel->info.uses_linear_centroid;
			} else if (rs->multisample_enable &&
				   sctx->framebuffer.nr_samples > 1) {
				key->ps.prolog.bc_optimize_for_persp =
					sel->info.uses_persp_center &&
					sel->info.uses_persp_centroid;
				key->ps.prolog.bc_optimize_for_linear =
					sel->info.uses_linear_center &&
					sel->info.uses_linear_centroid;
			} else {
				/* Make sure SPI doesn't compute more than 1 pair
				 * of (i,j), which is the optimization here. */
				key->ps.prolog.force_persp_center_interp =
					sel->info.uses_persp_center +
					sel->info.uses_persp_centroid +
					sel->info.uses_persp_sample > 1;

				key->ps.prolog.force_linear_center_interp =
					sel->info.uses_linear_center +
					sel->info.uses_linear_centroid +
					sel->info.uses_linear_sample > 1;
			}
d964 1
a964 1
static int si_shader_select_with_key(struct si_screen *sscreen,
d966 1
a966 5
				     union si_shader_key *key,
				     LLVMTargetMachineRef tm,
				     struct pipe_debug_callback *debug,
				     bool wait,
				     bool is_debug_context)
d968 1
a980 7
	/* This must be done before the mutex is locked, because async GS
	 * compilation calls this function too, and therefore must enter
	 * the mutex first.
	 */
	if (wait)
		util_queue_job_wait(&sel->ready);

d1003 1
a1003 1
	r = si_shader_create(sscreen, tm, shader, debug);
d1011 1
a1011 11

	if (is_debug_context) {
		FILE *f = open_memstream(&shader->shader_log,
					 &shader->shader_log_size);
		if (f) {
			si_shader_dump(sscreen, shader, NULL, sel->type, f);
			fclose(f);
		}
	}

	si_shader_init_pm4_state(sscreen, shader);
a1027 1
	struct si_context *sctx = (struct si_context *)ctx;
d1031 1
a1031 136
	return si_shader_select_with_key(sctx->screen, state, &key,
					 sctx->tm, &sctx->b.debug, true,
					 sctx->is_debug);
}

static void si_parse_next_shader_property(const struct tgsi_shader_info *info,
					  union si_shader_key *key)
{
	unsigned next_shader = info->properties[TGSI_PROPERTY_NEXT_SHADER];

	switch (info->processor) {
	case PIPE_SHADER_VERTEX:
		switch (next_shader) {
		case PIPE_SHADER_GEOMETRY:
			key->vs.as_es = 1;
			break;
		case PIPE_SHADER_TESS_CTRL:
		case PIPE_SHADER_TESS_EVAL:
			key->vs.as_ls = 1;
			break;
		}
		break;

	case PIPE_SHADER_TESS_EVAL:
		if (next_shader == PIPE_SHADER_GEOMETRY)
			key->tes.as_es = 1;
		break;
	}
}

/**
 * Compile the main shader part or the monolithic shader as part of
 * si_shader_selector initialization. Since it can be done asynchronously,
 * there is no way to report compile failures to applications.
 */
void si_init_shader_selector_async(void *job, int thread_index)
{
	struct si_shader_selector *sel = (struct si_shader_selector *)job;
	struct si_screen *sscreen = sel->screen;
	LLVMTargetMachineRef tm;
	struct pipe_debug_callback *debug = &sel->debug;
	unsigned i;

	if (thread_index >= 0) {
		assert(thread_index < ARRAY_SIZE(sscreen->tm));
		tm = sscreen->tm[thread_index];
		if (!debug->async)
			debug = NULL;
	} else {
		tm = sel->tm;
	}

	/* Compile the main shader part for use with a prolog and/or epilog.
	 * If this fails, the driver will try to compile a monolithic shader
	 * on demand.
	 */
	if (sel->type != PIPE_SHADER_GEOMETRY &&
	    !sscreen->use_monolithic_shaders) {
		struct si_shader *shader = CALLOC_STRUCT(si_shader);
		void *tgsi_binary;

		if (!shader) {
			fprintf(stderr, "radeonsi: can't allocate a main shader part\n");
			return;
		}

		shader->selector = sel;
		si_parse_next_shader_property(&sel->info, &shader->key);

		tgsi_binary = si_get_tgsi_binary(sel);

		/* Try to load the shader from the shader cache. */
		pipe_mutex_lock(sscreen->shader_cache_mutex);

		if (tgsi_binary &&
		    si_shader_cache_load_shader(sscreen, tgsi_binary, shader)) {
			FREE(tgsi_binary);
			pipe_mutex_unlock(sscreen->shader_cache_mutex);
		} else {
			pipe_mutex_unlock(sscreen->shader_cache_mutex);

			/* Compile the shader if it hasn't been loaded from the cache. */
			if (si_compile_tgsi_shader(sscreen, tm, shader, false,
						   debug) != 0) {
				FREE(shader);
				FREE(tgsi_binary);
				fprintf(stderr, "radeonsi: can't compile a main shader part\n");
				return;
			}

			if (tgsi_binary) {
				pipe_mutex_lock(sscreen->shader_cache_mutex);
				if (!si_shader_cache_insert_shader(sscreen, tgsi_binary, shader))
					FREE(tgsi_binary);
				pipe_mutex_unlock(sscreen->shader_cache_mutex);
			}
		}

		sel->main_shader_part = shader;
	}

	/* Pre-compilation. */
	if (sel->type == PIPE_SHADER_GEOMETRY ||
	    sscreen->b.debug_flags & DBG_PRECOMPILE) {
		struct si_shader_ctx_state state = {sel};
		union si_shader_key key;

		memset(&key, 0, sizeof(key));
		si_parse_next_shader_property(&sel->info, &key);

		/* Set reasonable defaults, so that the shader key doesn't
		 * cause any code to be eliminated.
		 */
		switch (sel->type) {
		case PIPE_SHADER_TESS_CTRL:
			key.tcs.epilog.prim_mode = PIPE_PRIM_TRIANGLES;
			break;
		case PIPE_SHADER_FRAGMENT:
			key.ps.prolog.bc_optimize_for_persp =
				sel->info.uses_persp_center &&
				sel->info.uses_persp_centroid;
			key.ps.prolog.bc_optimize_for_linear =
				sel->info.uses_linear_center &&
				sel->info.uses_linear_centroid;
			key.ps.epilog.alpha_func = PIPE_FUNC_ALWAYS;
			for (i = 0; i < 8; i++)
				if (sel->info.colors_written & (1 << i))
					key.ps.epilog.spi_shader_col_format |=
						V_028710_SPI_SHADER_FP16_ABGR << (i * 4);
			break;
		}

		if (si_shader_select_with_key(sscreen, &state, &key, tm, debug,
					      false, sel->is_debug_context))
			fprintf(stderr, "radeonsi: can't create a monolithic shader\n");
	}
a1044 4
	sel->screen = sscreen;
	sel->tm = sctx->tm;
	sel->debug = sctx->b.debug;
	sel->is_debug_context = sctx->is_debug;
d1053 1
a1053 1
	sel->type = sel->info.processor;
d1092 1
a1093 6
		/* Always reserve space for these. */
		sel->patch_outputs_written |=
			(1llu << si_shader_io_get_unique_index(TGSI_SEMANTIC_TESSINNER, 0)) |
			(1llu << si_shader_io_get_unique_index(TGSI_SEMANTIC_TESSOUTER, 0));
		/* fall through */
	case PIPE_SHADER_VERTEX:
d1146 64
a1209 30
	/* Z_ORDER, EXEC_ON_HIER_FAIL and EXEC_ON_NOOP should be set as following:
	 *
	 *   | early Z/S | writes_mem | allow_ReZ? |      Z_ORDER       | EXEC_ON_HIER_FAIL | EXEC_ON_NOOP
	 * --|-----------|------------|------------|--------------------|-------------------|-------------
	 * 1a|   false   |   false    |   true     | EarlyZ_Then_ReZ    |         0         |     0
	 * 1b|   false   |   false    |   false    | EarlyZ_Then_LateZ  |         0         |     0
	 * 2 |   false   |   true     |   n/a      |       LateZ        |         1         |     0
	 * 3 |   true    |   false    |   n/a      | EarlyZ_Then_LateZ  |         0         |     0
	 * 4 |   true    |   true     |   n/a      | EarlyZ_Then_LateZ  |         0         |     1
	 *
	 * In cases 3 and 4, HW will force Z_ORDER to EarlyZ regardless of what's set in the register.
	 * In case 2, NOOP_CULL is a don't care field. In case 2, 3 and 4, ReZ doesn't make sense.
	 *
	 * Don't use ReZ without profiling !!!
	 *
	 * ReZ decreases performance by 15% in DiRT: Showdown on Ultra settings, which has pretty complex
	 * shaders.
	 */
	if (sel->info.properties[TGSI_PROPERTY_FS_EARLY_DEPTH_STENCIL]) {
		/* Cases 3, 4. */
		sel->db_shader_control |= S_02880C_DEPTH_BEFORE_SHADER(1) |
					  S_02880C_Z_ORDER(V_02880C_EARLY_Z_THEN_LATE_Z) |
					  S_02880C_EXEC_ON_NOOP(sel->info.writes_memory);
	} else if (sel->info.writes_memory) {
		/* Case 2. */
		sel->db_shader_control |= S_02880C_Z_ORDER(V_02880C_LATE_Z) |
					  S_02880C_EXEC_ON_HIER_FAIL(1);
	} else {
		/* Case 1. */
		sel->db_shader_control |= S_02880C_Z_ORDER(V_02880C_EARLY_Z_THEN_LATE_Z);
d1213 8
a1220 1
	util_queue_fence_init(&sel->ready);
d1222 12
a1233 9
	if ((sctx->b.debug.debug_message && !sctx->b.debug.async) ||
	    sctx->is_debug ||
	    r600_can_dump_shader(&sscreen->b, sel->info.processor) ||
	    !util_queue_is_initialized(&sscreen->shader_compiler_queue))
		si_init_shader_selector_async(sel, -1);
	else
		util_queue_add_job(&sscreen->shader_compiler_queue, sel,
                                   &sel->ready, si_init_shader_selector_async,
                                   NULL);
d1235 4
a1238 1
	return sel;
a1250 1
	sctx->do_update_shaders = true;
d1252 1
a1252 1
	r600_update_vs_writes_viewport_index(&sctx->b, si_get_vs_info(sctx));
a1265 1
	sctx->do_update_shaders = true;
d1271 1
a1271 1
	r600_update_vs_writes_viewport_index(&sctx->b, si_get_vs_info(sctx));
a1284 1
	sctx->do_update_shaders = true;
a1300 1
	sctx->do_update_shaders = true;
d1308 1
a1308 1
	r600_update_vs_writes_viewport_index(&sctx->b, si_get_vs_info(sctx));
a1321 1
	sctx->do_update_shaders = true;
a1372 2
	util_queue_job_wait(&sel->ready);

a1386 1
	util_queue_fence_destroy(&sel->ready);
a1424 3
		/* D3D 9 behaviour. GL is undefined */
		if (name == TGSI_SEMANTIC_COLOR && index == 0)
			ps_input_cntl |= S_028644_DEFAULT_VAL(3);
a1481 6
	/* Done by Vulkan before VGT_FLUSH. */
	si_pm4_cmd_begin(sctx->init_config, PKT3_EVENT_WRITE);
	si_pm4_cmd_add(sctx->init_config,
		       EVENT_TYPE(V_028A90_VS_PARTIAL_FLUSH) | EVENT_INDEX(4));
	si_pm4_cmd_end(sctx->init_config, false);

d1591 1
a1591 1
		si_set_ring_buffer(&sctx->b.b, SI_ES_RING_ESGS,
d1594 1
a1594 1
		si_set_ring_buffer(&sctx->b.b, SI_GS_RING_ESGS,
d1599 1
a1599 1
		si_set_ring_buffer(&sctx->b.b, SI_VS_RING_GSVS,
d1615 1
a1615 1
	si_set_ring_buffer(&sctx->b.b, SI_GS_RING_GSVS0,
d1620 1
a1620 1
	si_set_ring_buffer(&sctx->b.b, SI_GS_RING_GSVS1,
d1625 1
a1625 1
	si_set_ring_buffer(&sctx->b.b, SI_GS_RING_GSVS2,
d1630 1
a1630 1
	si_set_ring_buffer(&sctx->b.b, SI_GS_RING_GSVS3,
d1660 1
a1660 1
	si_shader_apply_scratch_relocs(sctx, shader, &shader->config, scratch_va);
d1668 1
a1668 1
	si_shader_init_pm4_state(sctx->screen, shader);
d1711 3
a1713 1
			r600_resource_reference(&sctx->scratch_buffer, NULL);
d1786 1
a1786 5
	bool double_offchip_buffers = sctx->b.chip_class >= CIK;
	unsigned max_offchip_buffers_per_se = double_offchip_buffers ? 128 : 64;
	unsigned max_offchip_buffers = max_offchip_buffers_per_se *
				       sctx->screen->b.info.max_se;
	unsigned offchip_granularity;
a1787 26
	switch (sctx->screen->tess_offchip_block_dw_size) {
	default:
		assert(0);
		/* fall through */
	case 8192:
		offchip_granularity = V_03093C_X_8K_DWORDS;
		break;
	case 4096:
		offchip_granularity = V_03093C_X_4K_DWORDS;
		break;
	}

	switch (sctx->b.chip_class) {
	case SI:
		max_offchip_buffers = MIN2(max_offchip_buffers, 126);
		break;
	case CIK:
		max_offchip_buffers = MIN2(max_offchip_buffers, 508);
		break;
	case VI:
	default:
		max_offchip_buffers = MIN2(max_offchip_buffers, 512);
		break;
	}

	assert(!sctx->tf_ring);
a1795 8
	sctx->tess_offchip_ring = pipe_buffer_create(sctx->b.b.screen,
	                                             PIPE_BIND_CUSTOM,
	                                             PIPE_USAGE_DEFAULT,
	                                             max_offchip_buffers *
	                                             sctx->screen->tess_offchip_block_dw_size * 4);
	if (!sctx->tess_offchip_ring)
		return;

a1799 3
		if (sctx->b.chip_class >= VI)
			--max_offchip_buffers;

a1803 3
		si_pm4_set_reg(sctx->init_config, R_03093C_VGT_HS_OFFCHIP_PARAM,
		             S_03093C_OFFCHIP_BUFFERING(max_offchip_buffers) |
		             S_03093C_OFFCHIP_GRANULARITY(offchip_granularity));
a1804 1
		assert(offchip_granularity == V_03093C_X_8K_DWORDS);
a1808 2
		si_pm4_set_reg(sctx->init_config, R_0089B0_VGT_HS_OFFCHIP_PARAM,
		               S_0089B0_OFFCHIP_BUFFERING(max_offchip_buffers));
d1818 3
a1820 6
	si_set_ring_buffer(&sctx->b.b, SI_HS_RING_TESS_FACTOR, sctx->tf_ring,
			   0, sctx->tf_ring->width0, false, false, 0, 0, 0);

	si_set_ring_buffer(&sctx->b.b, SI_HS_RING_TESS_OFFCHIP,
	                   sctx->tess_offchip_ring, 0,
	                   sctx->tess_offchip_ring->width0, false, false, 0, 0, 0);
d1830 1
a1830 1
	struct ureg_src outer, inner;
d1832 1
a1832 1
	struct ureg_program *ureg = ureg_create(PIPE_SHADER_TESS_CTRL);
d1839 5
a1843 4
	outer = ureg_DECL_system_value(ureg,
				       TGSI_SEMANTIC_DEFAULT_TESSOUTER_SI, 0);
	inner = ureg_DECL_system_value(ureg,
				       TGSI_SEMANTIC_DEFAULT_TESSINNER_SI, 0);
d1848 2
a1849 2
	ureg_MOV(ureg, tessouter, outer);
	ureg_MOV(ureg, tessinner, inner);
d1870 1
a1870 1
				  S_028B54_HS_EN(1) | S_028B54_DYNAMIC_HS(1);
d1988 3
a1990 1
		unsigned db_shader_control;
a1996 4
		db_shader_control =
			sctx->ps_shader.cso->db_shader_control |
			S_02880C_KILL_ENABLE(si_get_alpha_test_func(sctx) != PIPE_FUNC_ALWAYS);

a2018 3

			if (sctx->framebuffer.nr_samples <= 1)
				si_mark_atom_dirty(sctx, &sctx->msaa_sample_locs.atom);
a2030 2

	sctx->do_update_shaders = false;
@


1.1.1.6
log
@Import Mesa 13.0.3
@
text
@d1780 1
a1780 1
	if (sctx->gsvs_ring) {
a1783 5

		/* Also update SI_GS_RING_GSVSi descriptors. */
		sctx->last_gsvs_itemsize = 0;
	}

@


1.1.1.7
log
@Import Mesa 13.0.6
@
text
@d939 1
a939 1
		if (sctx->b.chip_class <= CIK && sctx->b.family != CHIP_HAWAII) {
d941 5
a945 1
			key->ps.epilog.color_is_int10 = sctx->framebuffer.color_is_int10;
d1971 1
a1971 3
	bool double_offchip_buffers = sctx->b.chip_class >= CIK &&
				      sctx->b.family != CHIP_CARRIZO &&
				      sctx->b.family != CHIP_STONEY;
@


1.1.1.8
log
@Import Mesa 17.1.6
@
text
@a29 1
#include "gfx9d.h"
d35 1
a35 1
#include "util/crc32.h"
a38 3
#include "util/disk_cache.h"
#include "util/mesa-sha1.h"

d112 1
a112 2
	unsigned disasm_size = shader->binary.disasm_string ?
			       strlen(shader->binary.disasm_string) + 1 : 0;
d185 1
a185 2
					  struct si_shader *shader,
					  bool insert_into_disk_cache)
a188 1
	uint8_t key[CACHE_KEY_SIZE];
a203 7
	if (sscreen->b.disk_shader_cache && insert_into_disk_cache) {
		disk_cache_compute_key(sscreen->b.disk_shader_cache, tgsi_binary,
				       *((uint32_t *)tgsi_binary), key);
		disk_cache_put(sscreen->b.disk_shader_cache, key, hw_binary,
			       *((uint32_t *) hw_binary));
	}

d213 2
a214 30
	if (!entry) {
		if (sscreen->b.disk_shader_cache) {
			unsigned char sha1[CACHE_KEY_SIZE];
			size_t tg_size = *((uint32_t *) tgsi_binary);

			disk_cache_compute_key(sscreen->b.disk_shader_cache,
					       tgsi_binary, tg_size, sha1);

			size_t binary_size;
			uint8_t *buffer =
				disk_cache_get(sscreen->b.disk_shader_cache,
					       sha1, &binary_size);
			if (!buffer)
				return false;

			if (binary_size < sizeof(uint32_t) ||
			    *((uint32_t*)buffer) != binary_size) {
				 /* Something has gone wrong discard the item
				  * from the cache and rebuild/link from
				  * source.
				  */
				assert(!"Invalid radeonsi shader disk cache "
				       "item!");

				disk_cache_remove(sscreen->b.disk_shader_cache,
						  sha1);
				free(buffer);

				return false;
			}
d216 1
a216 20
			if (!si_load_shader_binary(shader, buffer)) {
				free(buffer);
				return false;
			}
			free(buffer);

			if (!si_shader_cache_insert_shader(sscreen, tgsi_binary,
							   shader, false))
				FREE(tgsi_binary);
		} else {
			return false;
		}
	} else {
		if (si_load_shader_binary(shader, entry->data))
			FREE(tgsi_binary);
		else
			return false;
	}
	p_atomic_inc(&sscreen->b.num_shader_cache_hits);
	return true;
d245 1
a245 1
	(void) mtx_init(&sscreen->shader_cache_mutex, mtx_plain);
a249 1

d258 1
a258 1
	mtx_destroy(&sscreen->shader_cache_mutex);
a329 39
/* Polaris needs different VTX_REUSE_DEPTH settings depending on
 * whether the "fractional odd" tessellation spacing is used.
 *
 * Possible VGT configurations and which state should set the register:
 *
 *   Reg set in | VGT shader configuration   | Value
 * ------------------------------------------------------
 *     VS as VS | VS                         | 30
 *     VS as ES | ES -> GS -> VS             | 30
 *    TES as VS | LS -> HS -> VS             | 14 or 30
 *    TES as ES | LS -> HS -> ES -> GS -> VS | 14 or 30
 */
static void polaris_set_vgt_vertex_reuse(struct si_screen *sscreen,
					 struct si_shader *shader,
					 struct si_pm4_state *pm4)
{
	unsigned type = shader->selector->type;

	if (sscreen->b.family < CHIP_POLARIS10)
		return;

	/* VS as VS, or VS as ES: */
	if ((type == PIPE_SHADER_VERTEX &&
	     !shader->key.as_ls &&
	     !shader->is_gs_copy_shader) ||
	    /* TES as VS, or TES as ES: */
	    type == PIPE_SHADER_TESS_EVAL) {
		unsigned vtx_reuse_depth = 30;

		if (type == PIPE_SHADER_TESS_EVAL &&
		    shader->selector->info.properties[TGSI_PROPERTY_TES_SPACING] ==
		    PIPE_TESS_SPACING_FRACTIONAL_ODD)
			vtx_reuse_depth = 14;

		si_pm4_set_reg(pm4, R_028C58_VGT_VERTEX_REUSE_BLOCK_CNTL,
			       vtx_reuse_depth);
	}
}

d340 1
a340 1
static void si_shader_ls(struct si_screen *sscreen, struct si_shader *shader)
a345 2
	assert(sscreen->b.chip_class <= VI);

d365 1
a365 1
	shader->config.rsrc2 = S_00B52C_USER_SGPR(SI_VS_NUM_USER_SGPR) |
d369 1
a369 1
static void si_shader_hs(struct si_screen *sscreen, struct si_shader *shader)
d390 1
a390 1
		       S_00B42C_OC_LDS_EN(sscreen->b.chip_class <= VI) |
a401 2
	assert(sscreen->b.chip_class <= VI);

d411 1
a411 1
		num_user_sgprs = SI_VS_NUM_USER_SGPR;
a436 2

	polaris_set_vgt_vertex_reuse(sscreen, shader, pm4);
d443 1
a443 1
static uint32_t si_vgt_gs_mode(struct si_shader_selector *sel)
d445 1
a445 1
	unsigned gs_max_vert_out = sel->gs_max_out_vertices;
d467 3
a469 3
	struct si_shader_selector *sel = shader->selector;
	const ubyte *num_components = sel->info.num_stream_output_components;
	unsigned gs_num_invocations = sel->gs_num_invocations;
d472 4
a475 2
	unsigned max_stream = sel->max_gs_stream;
	unsigned offset;
d481 5
a485 11
	offset = num_components[0] * sel->gs_max_out_vertices;
	si_pm4_set_reg(pm4, R_028A60_VGT_GSVS_RING_OFFSET_1, offset);
	if (max_stream >= 1)
		offset += num_components[1] * sel->gs_max_out_vertices;
	si_pm4_set_reg(pm4, R_028A64_VGT_GSVS_RING_OFFSET_2, offset);
	if (max_stream >= 2)
		offset += num_components[2] * sel->gs_max_out_vertices;
	si_pm4_set_reg(pm4, R_028A68_VGT_GSVS_RING_OFFSET_3, offset);
	if (max_stream >= 3)
		offset += num_components[3] * sel->gs_max_out_vertices;
	si_pm4_set_reg(pm4, R_028AB0_VGT_GSVS_RING_ITEMSIZE, offset);
d487 1
a487 2
	/* The GSVS_RING_ITEMSIZE register takes 15 bits */
	assert(offset < (1 << 15));
d491 4
a494 4
	si_pm4_set_reg(pm4, R_028B5C_VGT_GS_VERT_ITEMSIZE, num_components[0]);
	si_pm4_set_reg(pm4, R_028B60_VGT_GS_VERT_ITEMSIZE_1, (max_stream >= 1) ? num_components[1] : 0);
	si_pm4_set_reg(pm4, R_028B64_VGT_GS_VERT_ITEMSIZE_2, (max_stream >= 2) ? num_components[2] : 0);
	si_pm4_set_reg(pm4, R_028B68_VGT_GS_VERT_ITEMSIZE_3, (max_stream >= 3) ? num_components[3] : 0);
d523 1
a523 1
                         struct si_shader_selector *gs)
d546 2
a547 11
		unsigned mode = 0;

		/* PrimID needs GS scenario A.
		 * GFX9 also needs it when ViewportIndex is enabled.
		 */
		if (enable_prim_id ||
		    (sscreen->b.chip_class >= GFX9 &&
		     shader->selector->info.writes_viewport_index))
			mode = V_028A40_GS_SCENARIO_A;

		si_pm4_set_reg(pm4, R_028A40_VGT_GS_MODE, S_028A40_MODE(mode));
a616 2

	polaris_set_vgt_vertex_reuse(sscreen, shader, pm4);
d625 1
a625 1
			      (ps->key.part.ps.prolog.color_two_side ? num_colors : 0);
d633 1
a633 1
	unsigned value = shader->key.part.ps.epilog.spi_shader_col_format;
d704 1
a704 1
	assert(!shader->key.part.ps.prolog.bc_optimize_for_persp ||
d707 1
a707 1
	assert(!shader->key.part.ps.prolog.bc_optimize_for_linear ||
d710 1
a710 1
	assert(!shader->key.part.ps.prolog.force_persp_center_interp ||
d713 1
a713 1
	assert(!shader->key.part.ps.prolog.force_linear_center_interp ||
d716 1
a716 1
	assert(!shader->key.part.ps.prolog.force_persp_sample_interp ||
d719 1
a719 1
	assert(!shader->key.part.ps.prolog.force_linear_sample_interp ||
d724 1
a724 1
	assert(shader->key.part.ps.prolog.bc_optimize_for_persp ||
d727 1
a727 1
	assert(shader->key.part.ps.prolog.bc_optimize_for_linear ||
d817 3
a819 3
		if (shader->key.as_ls)
			si_shader_ls(sscreen, shader);
		else if (shader->key.as_es)
d825 1
a825 1
		si_shader_hs(sscreen, shader);
d828 1
a828 1
		if (shader->key.as_es)
d835 1
a853 52
static void si_shader_selector_key_hw_vs(struct si_context *sctx,
					 struct si_shader_selector *vs,
					 struct si_shader_key *key)
{
	struct si_shader_selector *ps = sctx->ps_shader.cso;

	key->opt.hw_vs.clip_disable =
		sctx->queued.named.rasterizer->clip_plane_enable == 0 &&
		(vs->info.clipdist_writemask ||
		 vs->info.writes_clipvertex) &&
		!vs->info.culldist_writemask;

	/* Find out if PS is disabled. */
	bool ps_disabled = true;
	if (ps) {
		bool ps_modifies_zs = ps->info.uses_kill ||
				      ps->info.writes_z ||
				      ps->info.writes_stencil ||
				      ps->info.writes_samplemask ||
				      si_get_alpha_test_func(sctx) != PIPE_FUNC_ALWAYS;

		unsigned ps_colormask = sctx->framebuffer.colorbuf_enabled_4bit &
					sctx->queued.named.blend->cb_target_mask;
		if (!ps->info.properties[TGSI_PROPERTY_FS_COLOR0_WRITES_ALL_CBUFS])
			ps_colormask &= ps->colors_written_4bit;

		ps_disabled = sctx->queued.named.rasterizer->rasterizer_discard ||
			      (!ps_colormask &&
			       !ps_modifies_zs &&
			       !ps->info.writes_memory);
	}

	/* Find out which VS outputs aren't used by the PS. */
	uint64_t outputs_written = vs->outputs_written;
	uint32_t outputs_written2 = vs->outputs_written2;
	uint64_t inputs_read = 0;
	uint32_t inputs_read2 = 0;

	outputs_written &= ~0x3; /* ignore POSITION, PSIZE */

	if (!ps_disabled) {
		inputs_read = ps->inputs_read;
		inputs_read2 = ps->inputs_read2;
	}

	uint64_t linked = outputs_written & inputs_read;
	uint32_t linked2 = outputs_written2 & inputs_read2;

	key->opt.hw_vs.kill_outputs = ~linked & outputs_written;
	key->opt.hw_vs.kill_outputs2 = ~linked2 & outputs_written2;
}

d857 1
a857 1
					  struct si_shader_key *key)
d870 1
a870 1
				key->part.vs.prolog.instance_divisors[i] =
a871 3

			memcpy(key->mono.vs.fix_fetch,
			       sctx->vertex_elements->fix_fetch, count);
d874 1
a874 1
			key->as_ls = 1;
d876 1
a876 3
			key->as_es = 1;
		else {
			si_shader_selector_key_hw_vs(sctx, sel, key);
d878 3
a880 3
			if (sctx->ps_shader.cso && sctx->ps_shader.cso->info.uses_primid)
				key->part.vs.epilog.export_prim_id = 1;
		}
d883 1
a883 1
		key->part.tcs.epilog.prim_mode =
a884 2
		key->part.tcs.epilog.tes_reads_tess_factors =
			sctx->tes_shader.cso->info.reads_tess_factors;
d887 1
a887 1
			key->mono.tcs.inputs_to_copy = sctx->vs_shader.cso->outputs_written;
d891 3
a893 7
			key->as_es = 1;
		else {
			si_shader_selector_key_hw_vs(sctx, sel, key);

			if (sctx->ps_shader.cso && sctx->ps_shader.cso->info.uses_primid)
				key->part.tes.epilog.export_prim_id = 1;
		}
a895 1
		key->part.gs.prolog.tri_strip_adj_fix = sctx->gs_tri_strip_adj_fix;
d903 1
a903 1
			key->part.ps.epilog.last_cbuf = MAX2(sctx->framebuffer.state.nr_cbufs, 1) - 1;
d909 1
a909 1
			key->part.ps.epilog.spi_shader_col_format =
d923 2
a924 2
				key->part.ps.epilog.spi_shader_col_format |=
					(key->part.ps.epilog.spi_shader_col_format & 0xf) << 4;
d926 1
a926 1
			key->part.ps.epilog.spi_shader_col_format = sctx->framebuffer.spi_shader_col_format;
d931 1
a931 1
		if (!(key->part.ps.epilog.spi_shader_col_format & 0xf) &&
d933 1
a933 1
			key->part.ps.epilog.spi_shader_col_format |= V_028710_SPI_SHADER_32_AR;
d940 2
a941 9
			key->part.ps.epilog.color_is_int8 = sctx->framebuffer.color_is_int8;
			key->part.ps.epilog.color_is_int10 = sctx->framebuffer.color_is_int10;
		}

		/* Disable unwritten outputs (if WRITE_ALL_CBUFS isn't enabled). */
		if (!key->part.ps.epilog.last_cbuf) {
			key->part.ps.epilog.spi_shader_col_format &= sel->colors_written_4bit;
			key->part.ps.epilog.color_is_int8 &= sel->info.colors_written;
			key->part.ps.epilog.color_is_int10 &= sel->info.colors_written;
d950 2
a951 2
			key->part.ps.prolog.color_two_side = rs->two_side && sel->info.colors_read;
			key->part.ps.prolog.flatshade_colors = rs->flatshade && sel->info.colors_read;
d954 1
a954 1
				key->part.ps.epilog.alpha_to_one = sctx->queued.named.blend->alpha_to_one &&
d958 2
a959 2
			key->part.ps.prolog.poly_stipple = rs->poly_stipple_enable && is_poly;
			key->part.ps.epilog.poly_line_smoothing = ((is_poly && rs->poly_smooth) ||
d962 1
a962 1
			key->part.ps.epilog.clamp_color = rs->clamp_fragment_color;
d968 1
a968 1
				key->part.ps.prolog.force_persp_sample_interp =
d972 1
a972 1
				key->part.ps.prolog.force_linear_sample_interp =
d977 1
a977 1
				key->part.ps.prolog.bc_optimize_for_persp =
d980 1
a980 1
				key->part.ps.prolog.bc_optimize_for_linear =
d986 1
a986 1
				key->part.ps.prolog.force_persp_center_interp =
d991 1
a991 1
				key->part.ps.prolog.force_linear_center_interp =
d998 1
a998 1
		key->part.ps.epilog.alpha_func = si_get_alpha_test_func(sctx);
a1005 38
static void si_build_shader_variant(void *job, int thread_index)
{
	struct si_shader *shader = (struct si_shader *)job;
	struct si_shader_selector *sel = shader->selector;
	struct si_screen *sscreen = sel->screen;
	LLVMTargetMachineRef tm;
	struct pipe_debug_callback *debug = &shader->compiler_ctx_state.debug;
	int r;

	if (thread_index >= 0) {
		assert(thread_index < ARRAY_SIZE(sscreen->tm));
		tm = sscreen->tm[thread_index];
		if (!debug->async)
			debug = NULL;
	} else {
		tm = shader->compiler_ctx_state.tm;
	}

	r = si_shader_create(sscreen, tm, shader, debug);
	if (unlikely(r)) {
		R600_ERR("Failed to build shader variant (type=%u) %d\n",
			 sel->type, r);
		shader->compilation_failed = true;
		return;
	}

	if (shader->compiler_ctx_state.is_debug_context) {
		FILE *f = open_memstream(&shader->shader_log,
					 &shader->shader_log_size);
		if (f) {
			si_shader_dump(sscreen, shader, NULL, sel->type, f, false);
			fclose(f);
		}
	}

	si_shader_init_pm4_state(sscreen, shader);
}

d1009 5
a1013 3
				     struct si_compiler_ctx_state *compiler_state,
				     struct si_shader_key *key,
				     int thread_index)
a1014 1
	static const struct si_shader_key zeroed;
d1018 1
a1019 5
	if (unlikely(sscreen->b.debug_flags & DBG_NO_OPT_VARIANT)) {
		memset(&key->opt, 0, sizeof(key->opt));
	}

again:
d1024 2
a1025 5
	if (likely(current &&
		   memcmp(&current->key, key, sizeof(*key)) == 0 &&
		   (!current->is_optimized ||
		    util_queue_fence_is_signalled(&current->optimized_ready))))
		return current->compilation_failed ? -1 : 0;
a1029 3
	 *
	 * Only wait if we are in a draw call. Don't wait if we are
	 * in a compiler thread.
d1031 2
a1032 2
	if (thread_index < 0)
		util_queue_fence_wait(&sel->ready);
d1034 1
a1034 1
	mtx_lock(&sel->mutex);
a1040 16
			/* If it's an optimized shader and its compilation has
			 * been started but isn't done, use the unoptimized
			 * shader so as not to cause a stall due to compilation.
			 */
			if (iter->is_optimized &&
			    !util_queue_fence_is_signalled(&iter->optimized_ready)) {
				memset(&key->opt, 0, sizeof(key->opt));
				mtx_unlock(&sel->mutex);
				goto again;
			}

			if (iter->compilation_failed) {
				mtx_unlock(&sel->mutex);
				return -1; /* skip the draw call */
			}

d1042 1
a1042 1
			mtx_unlock(&sel->mutex);
d1050 1
a1050 1
		mtx_unlock(&sel->mutex);
a1054 1
	shader->compiler_ctx_state = *compiler_state;
d1056 19
a1074 42
	/* Compile the main shader part if it doesn't exist. This can happen
	 * if the initial guess was wrong. */
	struct si_shader **mainp = si_get_main_shader_part(sel, key);
	bool is_pure_monolithic =
		sscreen->use_monolithic_shaders ||
		memcmp(&key->mono, &zeroed.mono, sizeof(key->mono)) != 0;

	if (!*mainp && !is_pure_monolithic) {
		struct si_shader *main_part = CALLOC_STRUCT(si_shader);

		if (!main_part) {
			FREE(shader);
			mtx_unlock(&sel->mutex);
			return -ENOMEM; /* skip the draw call */
		}

		main_part->selector = sel;
		main_part->key.as_es = key->as_es;
		main_part->key.as_ls = key->as_ls;

		if (si_compile_tgsi_shader(sscreen, compiler_state->tm,
					   main_part, false,
					   &compiler_state->debug) != 0) {
			FREE(main_part);
			FREE(shader);
			mtx_unlock(&sel->mutex);
			return -ENOMEM; /* skip the draw call */
		}
		*mainp = main_part;
	}

	/* Monolithic-only shaders don't make a distinction between optimized
	 * and unoptimized. */
	shader->is_monolithic =
		is_pure_monolithic ||
		memcmp(&key->opt, &zeroed.opt, sizeof(key->opt)) != 0;

	shader->is_optimized =
		!is_pure_monolithic &&
		memcmp(&key->opt, &zeroed.opt, sizeof(key->opt)) != 0;
	if (shader->is_optimized)
		util_queue_fence_init(&shader->optimized_ready);
d1083 3
a1085 24

	/* If it's an optimized shader, compile it asynchronously. */
	if (shader->is_optimized &&
	    !is_pure_monolithic &&
	    thread_index < 0) {
		/* Compile it asynchronously. */
		util_queue_add_job(&sscreen->shader_compiler_queue,
				   shader, &shader->optimized_ready,
				   si_build_shader_variant, NULL);

		/* Use the default (unoptimized) shader for now. */
		memset(&key->opt, 0, sizeof(key->opt));
		mtx_unlock(&sel->mutex);
		goto again;
	}

	assert(!shader->is_optimized);
	si_build_shader_variant(shader, thread_index);

	if (!shader->compilation_failed)
		state->current = shader;

	mtx_unlock(&sel->mutex);
	return shader->compilation_failed ? -1 : 0;
d1089 1
a1089 2
			    struct si_shader_ctx_state *state,
			    struct si_compiler_ctx_state *compiler_state)
d1092 1
a1092 1
	struct si_shader_key key;
d1095 3
a1097 2
	return si_shader_select_with_key(sctx->screen, state, compiler_state,
					 &key, -1);
d1101 1
a1101 1
					  struct si_shader_key *key)
d1109 1
a1109 1
			key->as_es = 1;
d1113 1
a1113 1
			key->as_ls = 1;
a1114 7
		default:
			/* If POSITION isn't written, it can't be a HW VS.
			 * Assume that it's a HW LS. (the next shader is TCS)
			 * This heuristic is needed for separate shader objects.
			 */
			if (!info->writes_position)
				key->as_ls = 1;
d1119 2
a1120 3
		if (next_shader == PIPE_SHADER_GEOMETRY ||
		    !info->writes_position)
			key->as_es = 1;
d1135 1
a1135 1
	struct pipe_debug_callback *debug = &sel->compiler_ctx_state.debug;
d1144 1
a1144 1
		tm = sel->compiler_ctx_state.tm;
d1151 2
a1152 1
	if (!sscreen->use_monolithic_shaders) {
d1167 1
a1167 1
		mtx_lock(&sscreen->shader_cache_mutex);
d1171 2
a1172 1
			mtx_unlock(&sscreen->shader_cache_mutex);
d1174 1
a1174 1
			mtx_unlock(&sscreen->shader_cache_mutex);
d1186 2
a1187 2
				mtx_lock(&sscreen->shader_cache_mutex);
				if (!si_shader_cache_insert_shader(sscreen, tgsi_binary, shader, true))
d1189 1
a1189 1
				mtx_unlock(&sscreen->shader_cache_mutex);
d1193 1
a1193 46
		*si_get_main_shader_part(sel, &shader->key) = shader;

		/* Unset "outputs_written" flags for outputs converted to
		 * DEFAULT_VAL, so that later inter-shader optimizations don't
		 * try to eliminate outputs that don't exist in the final
		 * shader.
		 *
		 * This is only done if non-monolithic shaders are enabled.
		 */
		if ((sel->type == PIPE_SHADER_VERTEX ||
		     sel->type == PIPE_SHADER_TESS_EVAL) &&
		    !shader->key.as_ls &&
		    !shader->key.as_es) {
			unsigned i;

			for (i = 0; i < sel->info.num_outputs; i++) {
				unsigned offset = shader->info.vs_output_param_offset[i];

				if (offset <= EXP_PARAM_OFFSET_31)
					continue;

				unsigned name = sel->info.output_semantic_name[i];
				unsigned index = sel->info.output_semantic_index[i];
				unsigned id;

				switch (name) {
				case TGSI_SEMANTIC_GENERIC:
					/* don't process indices the function can't handle */
					if (index >= 60)
						break;
					/* fall through */
				case TGSI_SEMANTIC_CLIPDIST:
					id = si_shader_io_get_unique_index(name, index);
					sel->outputs_written &= ~(1ull << id);
					break;
				case TGSI_SEMANTIC_POSITION: /* ignore these */
				case TGSI_SEMANTIC_PSIZE:
				case TGSI_SEMANTIC_CLIPVERTEX:
				case TGSI_SEMANTIC_EDGEFLAG:
					break;
				default:
					id = si_shader_io_get_unique_index2(name, index);
					sel->outputs_written2 &= ~(1u << id);
				}
			}
		}
d1197 2
a1198 1
	if (sscreen->b.debug_flags & DBG_PRECOMPILE) {
d1200 1
a1200 1
		struct si_shader_key key;
d1210 1
a1210 1
			key.part.tcs.epilog.prim_mode = PIPE_PRIM_TRIANGLES;
d1213 1
a1213 1
			key.part.ps.prolog.bc_optimize_for_persp =
d1216 1
a1216 1
			key.part.ps.prolog.bc_optimize_for_linear =
d1219 1
a1219 1
			key.part.ps.epilog.alpha_func = PIPE_FUNC_ALWAYS;
d1222 1
a1222 1
					key.part.ps.epilog.spi_shader_col_format |=
d1227 2
a1228 3
		if (si_shader_select_with_key(sscreen, &state,
					      &sel->compiler_ctx_state, &key,
					      thread_index))
a1230 11

	/* The GS copy shader is always pre-compiled. */
	if (sel->type == PIPE_SHADER_GEOMETRY) {
		sel->gs_copy_shader = si_generate_gs_copy_shader(sscreen, tm, sel, debug);
		if (!sel->gs_copy_shader) {
			fprintf(stderr, "radeonsi: can't create GS copy shader\n");
			return;
		}

		si_shader_vs(sscreen, sel->gs_copy_shader, sel);
	}
d1245 3
a1247 3
	sel->compiler_ctx_state.tm = sctx->tm;
	sel->compiler_ctx_state.debug = sctx->b.debug;
	sel->compiler_ctx_state.is_debug_context = sctx->is_debug;
a1258 4
	/* The prolog is a no-op if there are no inputs. */
	sel->vs_needs_prolog = sel->type == PIPE_SHADER_VERTEX &&
			       sel->info.num_inputs;

d1314 1
a1314 9

			case TGSI_SEMANTIC_GENERIC:
				/* don't process indices the function can't handle */
				if (index >= 60)
					break;
				/* fall through */
			case TGSI_SEMANTIC_POSITION:
			case TGSI_SEMANTIC_PSIZE:
			case TGSI_SEMANTIC_CLIPDIST:
a1316 7
				break;
			case TGSI_SEMANTIC_CLIPVERTEX: /* ignore these */
			case TGSI_SEMANTIC_EDGEFLAG:
				break;
			default:
				sel->outputs_written2 |=
					1u << si_shader_io_get_unique_index2(name, index);
a1322 18
		for (i = 0; i < sel->info.num_inputs; i++) {
			unsigned name = sel->info.input_semantic_name[i];
			unsigned index = sel->info.input_semantic_index[i];

			switch (name) {
			case TGSI_SEMANTIC_CLIPDIST:
			case TGSI_SEMANTIC_GENERIC:
				sel->inputs_read |=
					1llu << si_shader_io_get_unique_index(name, index);
				break;
			case TGSI_SEMANTIC_PCOORD: /* ignore this */
				break;
			default:
				sel->inputs_read2 |=
					1u << si_shader_io_get_unique_index2(name, index);
			}
		}

d1386 1
a1386 1
	(void) mtx_init(&sel->mutex, mtx_plain);
d1391 2
a1392 1
	    r600_can_dump_shader(&sscreen->b, sel->info.processor))
a1416 13
static void si_update_tcs_tes_uses_prim_id(struct si_context *sctx)
{
	sctx->ia_multi_vgt_param_key.u.tcs_tes_uses_prim_id =
		(sctx->tes_shader.cso &&
		 sctx->tes_shader.cso->info.uses_primid) ||
		(sctx->tcs_shader.cso &&
		 sctx->tcs_shader.cso->info.uses_primid) ||
		(sctx->gs_shader.cso &&
		 sctx->gs_shader.cso->info.uses_primid) ||
		(sctx->ps_shader.cso && !sctx->gs_shader.cso &&
		 sctx->ps_shader.cso->info.uses_primid);
}

a1427 1
	sctx->ia_multi_vgt_param_key.u.uses_gs = sel != NULL;
d1432 1
a1432 1
	if (enable_changed) {
a1433 3
		if (sctx->ia_multi_vgt_param_key.u.uses_tess)
			si_update_tcs_tes_uses_prim_id(sctx);
	}
a1447 1
	si_update_tcs_tes_uses_prim_id(sctx);
a1464 2
	sctx->ia_multi_vgt_param_key.u.uses_tess = sel != NULL;
	si_update_tcs_tes_uses_prim_id(sctx);
a1487 2
	if (sel && sctx->ia_multi_vgt_param_key.u.uses_tess)
		si_update_tcs_tes_uses_prim_id(sctx);
a1492 5
	if (shader->is_optimized) {
		util_queue_fence_wait(&shader->optimized_ready);
		util_queue_fence_destroy(&shader->optimized_ready);
	}

d1496 1
a1496 2
			if (shader->key.as_ls) {
				assert(sctx->b.chip_class <= VI);
d1498 1
a1498 2
			} else if (shader->key.as_es) {
				assert(sctx->b.chip_class <= VI);
d1500 1
a1500 1
			} else {
a1501 1
			}
d1507 1
a1507 2
			if (shader->key.as_es) {
				assert(sctx->b.chip_class <= VI);
d1509 1
a1509 1
			} else {
a1510 1
			}
d1513 2
a1514 4
			if (shader->is_gs_copy_shader)
				si_pm4_delete_state(sctx, vs, shader->pm4);
			else
				si_pm4_delete_state(sctx, gs, shader->pm4);
d1539 1
a1539 1
	util_queue_fence_wait(&sel->ready);
a1553 6
	if (sel->main_shader_part_ls)
		si_delete_shader(sctx, sel->main_shader_part_ls);
	if (sel->main_shader_part_es)
		si_delete_shader(sctx, sel->main_shader_part_es);
	if (sel->gs_copy_shader)
		si_delete_shader(sctx, sel->gs_copy_shader);
d1556 1
a1556 1
	mtx_destroy(&sel->mutex);
d1566 1
a1566 1
	unsigned j, offset, ps_input_cntl = 0;
d1581 1
a1581 19
			offset = vs->info.vs_output_param_offset[j];

			if (offset <= EXP_PARAM_OFFSET_31) {
				/* The input is loaded from parameter memory. */
				ps_input_cntl |= S_028644_OFFSET(offset);
			} else if (!G_028644_PT_SPRITE_TEX(ps_input_cntl)) {
				if (offset == EXP_PARAM_UNDEFINED) {
					/* This can happen with depth-only rendering. */
					offset = 0;
				} else {
					/* The input is a DEFAULT_VAL constant. */
					assert(offset >= EXP_PARAM_DEFAULT_VAL_0000 &&
					       offset <= EXP_PARAM_DEFAULT_VAL_1111);
					offset -= EXP_PARAM_DEFAULT_VAL_0000;
				}

				ps_input_cntl = S_028644_OFFSET(0x20) |
						S_028644_DEFAULT_VAL(offset);
			}
d1631 1
a1631 1
	if (ps->key.part.ps.prolog.color_two_side) {
d1679 1
a1679 4
	/* On SI-CI, the value comes from VGT_GS_VERTEX_REUSE = 16.
	 * On VI+, the value comes from VGT_VERTEX_REUSE_BLOCK_CNTL = 30 (+2).
	 */
	unsigned gs_vertex_reuse = (sctx->b.chip_class >= VI ? 32 : 16) * num_se;
d1692 1
a1692 1
				  gs->max_gsvs_emit_size;
a1702 2
	 *
	 * GFX9 doesn't have the ESGS ring.
d1704 1
a1704 2
	bool update_esgs = sctx->b.chip_class <= VI &&
			   esgs_ring_size &&
d1716 3
a1718 5
		sctx->esgs_ring =
			r600_aligned_buffer_create(sctx->b.b.screen,
						   R600_RESOURCE_FLAG_UNMAPPABLE,
						   PIPE_USAGE_DEFAULT,
						   esgs_ring_size, alignment);
d1725 3
a1727 5
		sctx->gsvs_ring =
			r600_aligned_buffer_create(sctx->b.b.screen,
						   R600_RESOURCE_FLAG_UNMAPPABLE,
						   PIPE_USAGE_DEFAULT,
						   gsvs_ring_size, alignment);
d1738 1
a1738 2
		if (sctx->esgs_ring) {
			assert(sctx->b.chip_class <= VI);
a1740 1
		}
a1768 1
		assert(sctx->b.chip_class <= VI);
d1777 1
a1777 1
		si_set_ring_buffer(&sctx->b.b, SI_RING_GSVS,
d1780 3
d1788 30
d1896 3
a1898 5
			sctx->scratch_buffer = (struct r600_resource*)
				r600_aligned_buffer_create(&sctx->screen->b.b,
							   R600_RESOURCE_FLAG_UNMAPPABLE,
							   PIPE_USAGE_DEFAULT,
							   scratch_needed_size, 256);
d1901 1
a1901 4

			si_mark_atom_dirty(sctx, &sctx->scratch_state);
			r600_context_add_resource_size(&sctx->b.b,
						       &sctx->scratch_buffer->b.b);
d1960 1
a1960 1
		si_mark_atom_dirty(sctx, &sctx->scratch_state);
a1991 2
	case VI:
	case GFX9:
d1994 1
d1996 2
a1997 2
		assert(0);
		return;
d2001 3
a2003 5
	sctx->tf_ring = r600_aligned_buffer_create(sctx->b.b.screen,
						   R600_RESOURCE_FLAG_UNMAPPABLE,
						   PIPE_USAGE_DEFAULT,
						   32768 * sctx->screen->b.info.max_se,
						   256);
d2009 5
a2013 7
	sctx->tess_offchip_ring =
		r600_aligned_buffer_create(sctx->b.b.screen,
					   R600_RESOURCE_FLAG_UNMAPPABLE,
					   PIPE_USAGE_DEFAULT,
					   max_offchip_buffers *
					   sctx->screen->tess_offchip_block_dw_size * 4,
					   256);
a2027 3
		if (sctx->b.chip_class >= GFX9)
			si_pm4_set_reg(sctx->init_config, R_030944_VGT_TF_MEMORY_BASE_HI,
				       r600_resource(sctx->tf_ring)->gpu_address >> 40);
a2115 3
		if (sctx->b.chip_class >= GFX9)
			stages |= S_028B54_MAX_PRIMGRP_IN_WAVE(2);

a2135 1
	struct si_compiler_ctx_state compiler_state;
a2136 2
	struct si_shader *old_vs = si_get_vs_state(sctx);
	bool old_clip_disable = old_vs ? old_vs->key.opt.hw_vs.clip_disable : false;
a2138 4
	compiler_state.tm = sctx->tm;
	compiler_state.debug = sctx->b.debug;
	compiler_state.is_debug_context = sctx->is_debug;

d2148 4
a2151 7
		if (sctx->b.chip_class <= VI) {
			r = si_shader_select(ctx, &sctx->vs_shader,
					     &compiler_state);
			if (r)
				return false;
			si_pm4_bind_state(sctx, ls, sctx->vs_shader.current->pm4);
		}
d2154 1
a2154 2
			r = si_shader_select(ctx, &sctx->tcs_shader,
					     &compiler_state);
d2165 1
a2165 2
			r = si_shader_select(ctx, &sctx->fixed_func_tcs_shader,
					     &compiler_state);
d2172 4
d2178 1
a2178 7
			if (sctx->b.chip_class <= VI) {
				r = si_shader_select(ctx, &sctx->tes_shader,
						     &compiler_state);
				if (r)
					return false;
				si_pm4_bind_state(sctx, es, sctx->tes_shader.current->pm4);
			}
a2180 4
			r = si_shader_select(ctx, &sctx->tes_shader,
					     &compiler_state);
			if (r)
				return false;
d2185 5
a2189 11
		if (sctx->b.chip_class <= VI) {
			/* VS as ES */
			r = si_shader_select(ctx, &sctx->vs_shader,
					     &compiler_state);
			if (r)
				return false;
			si_pm4_bind_state(sctx, es, sctx->vs_shader.current->pm4);

			si_pm4_bind_state(sctx, ls, NULL);
			si_pm4_bind_state(sctx, hs, NULL);
		}
d2192 1
a2192 1
		r = si_shader_select(ctx, &sctx->vs_shader, &compiler_state);
a2196 3

		si_pm4_bind_state(sctx, ls, NULL);
		si_pm4_bind_state(sctx, hs, NULL);
d2201 1
a2201 1
		r = si_shader_select(ctx, &sctx->gs_shader, &compiler_state);
d2205 1
a2205 1
		si_pm4_bind_state(sctx, vs, sctx->gs_shader.cso->gs_copy_shader->pm4);
d2210 2
d2214 1
a2214 2
		if (sctx->b.chip_class <= VI)
			si_pm4_bind_state(sctx, es, NULL);
a2218 3
	if (old_clip_disable != si_get_vs_state(sctx)->key.opt.hw_vs.clip_disable)
		si_mark_atom_dirty(sctx, &sctx->clip_regs);

d2222 1
a2222 1
		r = si_shader_select(ctx, &sctx->ps_shader, &compiler_state);
d2239 1
a2239 1
		if (sctx->screen->b.rbplus_allowed && si_pm4_state_changed(sctx, ps))
d2247 2
a2248 2
		if (sctx->smoothing_enabled != sctx->ps_shader.current->key.part.ps.epilog.poly_line_smoothing) {
			sctx->smoothing_enabled = sctx->ps_shader.current->key.part.ps.epilog.poly_line_smoothing;
a2268 3
	if (sctx->b.chip_class >= CIK)
		si_mark_atom_dirty(sctx, &sctx->prefetch_L2);

a2272 15
static void si_emit_scratch_state(struct si_context *sctx,
				  struct r600_atom *atom)
{
	struct radeon_winsys_cs *cs = sctx->b.gfx.cs;

	radeon_set_context_reg(cs, R_0286E8_SPI_TMPRING_SIZE,
			       sctx->spi_tmpring_size);

	if (sctx->scratch_buffer) {
		radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
				      sctx->scratch_buffer, RADEON_USAGE_READWRITE,
				      RADEON_PRIO_SCRATCH_BUFFER);
	}
}

a2275 2
	si_init_atom(sctx, &sctx->scratch_state, &sctx->atoms.s.scratch_state,
		     si_emit_scratch_state);
@


