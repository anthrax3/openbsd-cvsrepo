head	1.1;
branch	1.1.1;
access;
symbols
	mesa-17_1_6:1.1.1.4
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.44.33;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.33;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.20.13;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.28.10;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.08.14.09.32.56;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright 2010 Jerome Glisse <glisse@@freedesktop.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *      Jerome Glisse
 */

#include "sid.h"
#include "si_pipe.h"
#include "radeon/r600_cs.h"

#include "util/u_format.h"

static uint32_t si_micro_tile_mode(struct si_screen *sscreen, unsigned tile_mode)
{
	if (sscreen->b.info.si_tile_mode_array_valid) {
		uint32_t gb_tile_mode = sscreen->b.info.si_tile_mode_array[tile_mode];

		return G_009910_MICRO_TILE_MODE(gb_tile_mode);
	}

	/* The kernel cannod return the tile mode array. Guess? */
	return V_009910_ADDR_SURF_THIN_MICRO_TILING;
}

static void si_dma_copy_buffer(struct si_context *ctx,
				struct pipe_resource *dst,
				struct pipe_resource *src,
				uint64_t dst_offset,
				uint64_t src_offset,
				uint64_t size)
{
	struct radeon_winsys_cs *cs = ctx->b.rings.dma.cs;
	unsigned i, ncopy, csize, max_csize, sub_cmd, shift;
	struct r600_resource *rdst = (struct r600_resource*)dst;
	struct r600_resource *rsrc = (struct r600_resource*)src;

	/* Mark the buffer range of destination as valid (initialized),
	 * so that transfer_map knows it should wait for the GPU when mapping
	 * that range. */
	util_range_add(&rdst->valid_buffer_range, dst_offset,
		       dst_offset + size);

	dst_offset += rdst->gpu_address;
	src_offset += rsrc->gpu_address;

	/* see if we use dword or byte copy */
	if (!(dst_offset % 4) && !(src_offset % 4) && !(size % 4)) {
		size >>= 2;
		sub_cmd = SI_DMA_COPY_DWORD_ALIGNED;
		shift = 2;
		max_csize = SI_DMA_COPY_MAX_SIZE_DW;
	} else {
		sub_cmd = SI_DMA_COPY_BYTE_ALIGNED;
		shift = 0;
		max_csize = SI_DMA_COPY_MAX_SIZE;
	}
	ncopy = (size / max_csize) + !!(size % max_csize);

	r600_need_dma_space(&ctx->b, ncopy * 5);

	r600_context_bo_reloc(&ctx->b, &ctx->b.rings.dma, rsrc, RADEON_USAGE_READ,
			      RADEON_PRIO_MIN);
	r600_context_bo_reloc(&ctx->b, &ctx->b.rings.dma, rdst, RADEON_USAGE_WRITE,
			      RADEON_PRIO_MIN);

	for (i = 0; i < ncopy; i++) {
		csize = size < max_csize ? size : max_csize;
		cs->buf[cs->cdw++] = SI_DMA_PACKET(SI_DMA_PACKET_COPY, sub_cmd, csize);
		cs->buf[cs->cdw++] = dst_offset & 0xffffffff;
		cs->buf[cs->cdw++] = src_offset & 0xffffffff;
		cs->buf[cs->cdw++] = (dst_offset >> 32UL) & 0xff;
		cs->buf[cs->cdw++] = (src_offset >> 32UL) & 0xff;
		dst_offset += csize << shift;
		src_offset += csize << shift;
		size -= csize;
	}
}

static void si_dma_copy_tile(struct si_context *ctx,
			     struct pipe_resource *dst,
			     unsigned dst_level,
			     unsigned dst_x,
			     unsigned dst_y,
			     unsigned dst_z,
			     struct pipe_resource *src,
			     unsigned src_level,
			     unsigned src_x,
			     unsigned src_y,
			     unsigned src_z,
			     unsigned copy_height,
			     unsigned pitch,
			     unsigned bpp)
{
	struct radeon_winsys_cs *cs = ctx->b.rings.dma.cs;
	struct si_screen *sscreen = ctx->screen;
	struct r600_texture *rsrc = (struct r600_texture*)src;
	struct r600_texture *rdst = (struct r600_texture*)dst;
	struct r600_texture *rlinear, *rtiled;
	unsigned linear_lvl, tiled_lvl;
	unsigned array_mode, lbpp, pitch_tile_max, slice_tile_max, size;
	unsigned ncopy, height, cheight, detile, i, src_mode, dst_mode;
	unsigned linear_x, linear_y, linear_z,  tiled_x, tiled_y, tiled_z;
	unsigned sub_cmd, bank_h, bank_w, mt_aspect, nbanks, tile_split, mt;
	uint64_t base, addr;
	unsigned pipe_config, tile_mode_index;

	dst_mode = rdst->surface.level[dst_level].mode;
	src_mode = rsrc->surface.level[src_level].mode;
	/* downcast linear aligned to linear to simplify test */
	src_mode = src_mode == RADEON_SURF_MODE_LINEAR_ALIGNED ? RADEON_SURF_MODE_LINEAR : src_mode;
	dst_mode = dst_mode == RADEON_SURF_MODE_LINEAR_ALIGNED ? RADEON_SURF_MODE_LINEAR : dst_mode;
	assert(dst_mode != src_mode);

	sub_cmd = SI_DMA_COPY_TILED;
	lbpp = util_logbase2(bpp);
	pitch_tile_max = ((pitch / bpp) / 8) - 1;

	detile = dst_mode == RADEON_SURF_MODE_LINEAR;
	rlinear = detile ? rdst : rsrc;
	rtiled = detile ? rsrc : rdst;
	linear_lvl = detile ? dst_level : src_level;
	tiled_lvl = detile ? src_level : dst_level;
	linear_x = detile ? dst_x : src_x;
	linear_y = detile ? dst_y : src_y;
	linear_z = detile ? dst_z : src_z;
	tiled_x = detile ? src_x : dst_x;
	tiled_y = detile ? src_y : dst_y;
	tiled_z = detile ? src_z : dst_z;

	assert(!util_format_is_depth_and_stencil(rtiled->resource.b.b.format));

	array_mode = si_array_mode(rtiled->surface.level[tiled_lvl].mode);
	slice_tile_max = (rtiled->surface.level[tiled_lvl].nblk_x *
			  rtiled->surface.level[tiled_lvl].nblk_y) / (8*8) - 1;
	/* linear height must be the same as the slice tile max height, it's ok even
	 * if the linear destination/source have smaller heigh as the size of the
	 * dma packet will be using the copy_height which is always smaller or equal
	 * to the linear height
	 */
	height = rtiled->surface.level[tiled_lvl].nblk_y;
	base = rtiled->surface.level[tiled_lvl].offset;
	addr = rlinear->surface.level[linear_lvl].offset;
	addr += rlinear->surface.level[linear_lvl].slice_size * linear_z;
	addr += linear_y * pitch + linear_x * bpp;
	bank_h = cik_bank_wh(rtiled->surface.bankh);
	bank_w = cik_bank_wh(rtiled->surface.bankw);
	mt_aspect = cik_macro_tile_aspect(rtiled->surface.mtilea);
	tile_split = cik_tile_split(rtiled->surface.tile_split);
	tile_mode_index = si_tile_mode_index(rtiled, tiled_lvl, false);
	nbanks = si_num_banks(sscreen, rtiled);
	base += rtiled->resource.gpu_address;
	addr += rlinear->resource.gpu_address;

	pipe_config = cik_db_pipe_config(sscreen, tile_mode_index);
	mt = si_micro_tile_mode(sscreen, tile_mode_index);
	size = (copy_height * pitch) / 4;
	ncopy = (size / SI_DMA_COPY_MAX_SIZE_DW) + !!(size % SI_DMA_COPY_MAX_SIZE_DW);
	r600_need_dma_space(&ctx->b, ncopy * 9);

	r600_context_bo_reloc(&ctx->b, &ctx->b.rings.dma, &rsrc->resource,
			      RADEON_USAGE_READ, RADEON_PRIO_MIN);
	r600_context_bo_reloc(&ctx->b, &ctx->b.rings.dma, &rdst->resource,
			      RADEON_USAGE_WRITE, RADEON_PRIO_MIN);

	for (i = 0; i < ncopy; i++) {
		cheight = copy_height;
		if (((cheight * pitch) / 4) > SI_DMA_COPY_MAX_SIZE_DW) {
			cheight = (SI_DMA_COPY_MAX_SIZE_DW * 4) / pitch;
		}
		size = (cheight * pitch) / 4;
		cs->buf[cs->cdw++] = SI_DMA_PACKET(SI_DMA_PACKET_COPY, sub_cmd, size);
		cs->buf[cs->cdw++] = base >> 8;
		cs->buf[cs->cdw++] = (detile << 31) | (array_mode << 27) |
					(lbpp << 24) | (bank_h << 21) |
					(bank_w << 18) | (mt_aspect << 16);
		cs->buf[cs->cdw++] = (pitch_tile_max << 0) | ((height - 1) << 16);
		cs->buf[cs->cdw++] = (slice_tile_max << 0) | (pipe_config << 26);
		cs->buf[cs->cdw++] = (tiled_x << 0) | (tiled_z << 18);
		cs->buf[cs->cdw++] = (tiled_y << 0) | (tile_split << 21) | (nbanks << 25) | (mt << 27);
		cs->buf[cs->cdw++] = addr & 0xfffffffc;
		cs->buf[cs->cdw++] = (addr >> 32UL) & 0xff;
		copy_height -= cheight;
		addr += cheight * pitch;
		tiled_y += cheight;
	}
}

void si_dma_copy(struct pipe_context *ctx,
		 struct pipe_resource *dst,
		 unsigned dst_level,
		 unsigned dstx, unsigned dsty, unsigned dstz,
		 struct pipe_resource *src,
		 unsigned src_level,
		 const struct pipe_box *src_box)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct r600_texture *rsrc = (struct r600_texture*)src;
	struct r600_texture *rdst = (struct r600_texture*)dst;
	unsigned dst_pitch, src_pitch, bpp, dst_mode, src_mode;
	unsigned src_w, dst_w;
	unsigned src_x, src_y;
	unsigned dst_x = dstx, dst_y = dsty, dst_z = dstz;

	if (sctx->b.rings.dma.cs == NULL) {
		goto fallback;
	}

	if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
		si_dma_copy_buffer(sctx, dst, src, dst_x, src_box->x, src_box->width);
		return;
	}

	/* XXX: Using the asynchronous DMA engine for multi-dimensional
	 * operations seems to cause random GPU lockups for various people.
	 * While the root cause for this might need to be fixed in the kernel,
	 * let's disable it for now.
	 *
	 * Before re-enabling this, please make sure you can hit all newly
	 * enabled paths in your testing, preferably with both piglit and real
	 * world apps, and get in touch with people on the bug reports below
	 * for stability testing.
	 *
	 * https://bugs.freedesktop.org/show_bug.cgi?id=85647
	 * https://bugs.freedesktop.org/show_bug.cgi?id=83500
	 */
	goto fallback;

	if (src->format != dst->format || src_box->depth > 1 ||
	    rdst->dirty_level_mask != 0 ||
	    rdst->cmask.size || rdst->fmask.size ||
	    rsrc->cmask.size || rsrc->fmask.size) {
		goto fallback;
	}

	if (rsrc->dirty_level_mask) {
		ctx->flush_resource(ctx, src);
	}

	src_x = util_format_get_nblocksx(src->format, src_box->x);
	dst_x = util_format_get_nblocksx(src->format, dst_x);
	src_y = util_format_get_nblocksy(src->format, src_box->y);
	dst_y = util_format_get_nblocksy(src->format, dst_y);

	bpp = rdst->surface.bpe;
	dst_pitch = rdst->surface.level[dst_level].pitch_bytes;
	src_pitch = rsrc->surface.level[src_level].pitch_bytes;
	src_w = rsrc->surface.level[src_level].npix_x;
	dst_w = rdst->surface.level[dst_level].npix_x;

	dst_mode = rdst->surface.level[dst_level].mode;
	src_mode = rsrc->surface.level[src_level].mode;
	/* downcast linear aligned to linear to simplify test */
	src_mode = src_mode == RADEON_SURF_MODE_LINEAR_ALIGNED ? RADEON_SURF_MODE_LINEAR : src_mode;
	dst_mode = dst_mode == RADEON_SURF_MODE_LINEAR_ALIGNED ? RADEON_SURF_MODE_LINEAR : dst_mode;

	if (src_pitch != dst_pitch || src_box->x || dst_x || src_w != dst_w ||
	    src_box->width != src_w ||
	    src_box->height != rsrc->surface.level[src_level].npix_y ||
	    src_box->height != rdst->surface.level[dst_level].npix_y ||
	    rsrc->surface.level[src_level].nblk_y !=
	    rdst->surface.level[dst_level].nblk_y) {
		/* FIXME si can do partial blit */
		goto fallback;
	}
	/* the x test here are currently useless (because we don't support partial blit)
	 * but keep them around so we don't forget about those
	 */
	if ((src_pitch % 8) || (src_box->x % 8) || (dst_x % 8) ||
	    (src_box->y % 8) || (dst_y % 8) || (src_box->height % 8)) {
		goto fallback;
	}

	if (src_mode == dst_mode) {
		uint64_t dst_offset, src_offset;
		/* simple dma blit would do NOTE code here assume :
		 *   src_box.x/y == 0
		 *   dst_x/y == 0
		 *   dst_pitch == src_pitch
		 */
		src_offset= rsrc->surface.level[src_level].offset;
		src_offset += rsrc->surface.level[src_level].slice_size * src_box->z;
		src_offset += src_y * src_pitch + src_x * bpp;
		dst_offset = rdst->surface.level[dst_level].offset;
		dst_offset += rdst->surface.level[dst_level].slice_size * dst_z;
		dst_offset += dst_y * dst_pitch + dst_x * bpp;
		si_dma_copy_buffer(sctx, dst, src, dst_offset, src_offset,
				   rsrc->surface.level[src_level].slice_size);
	} else {
		si_dma_copy_tile(sctx, dst, dst_level, dst_x, dst_y, dst_z,
				 src, src_level, src_x, src_y, src_box->z,
				 src_box->height / rsrc->surface.blk_h,
				 dst_pitch, bpp);
	}
	return;

fallback:
	si_resource_copy_region(ctx, dst, dst_level, dstx, dsty, dstz,
				src, src_level, src_box);
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d52 1
a52 1
	struct radeon_winsys_cs *cs = ctx->b.dma.cs;
d81 4
a84 4
	radeon_add_to_buffer_list(&ctx->b, &ctx->b.dma, rsrc, RADEON_USAGE_READ,
			      RADEON_PRIO_SDMA_BUFFER);
	radeon_add_to_buffer_list(&ctx->b, &ctx->b.dma, rdst, RADEON_USAGE_WRITE,
			      RADEON_PRIO_SDMA_BUFFER);
d89 2
a90 2
		cs->buf[cs->cdw++] = dst_offset;
		cs->buf[cs->cdw++] = src_offset;
d114 1
a114 1
	struct radeon_winsys_cs *cs = ctx->b.dma.cs;
d180 4
a183 4
	radeon_add_to_buffer_list(&ctx->b, &ctx->b.dma, &rsrc->resource,
			      RADEON_USAGE_READ, RADEON_PRIO_SDMA_TEXTURE);
	radeon_add_to_buffer_list(&ctx->b, &ctx->b.dma, &rdst->resource,
			      RADEON_USAGE_WRITE, RADEON_PRIO_SDMA_TEXTURE);
d224 1
a224 1
	if (sctx->b.dma.cs == NULL) {
d249 1
a249 1
	    (rdst->dirty_level_mask | rdst->stencil_dirty_level_mask) & (1 << dst_level) ||
d251 1
a251 2
	    rsrc->cmask.size || rsrc->fmask.size ||
	    rdst->dcc_buffer || rsrc->dcc_buffer) {
d255 1
a255 1
	if (rsrc->dirty_level_mask & (1 << src_level)) {
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d29 1
d33 12
d79 6
a84 1
	r600_need_dma_space(&ctx->b, ncopy * 5, rdst, rsrc);
d88 5
a92 5
		radeon_emit(cs, SI_DMA_PACKET(SI_DMA_PACKET_COPY, sub_cmd, csize));
		radeon_emit(cs, dst_offset);
		radeon_emit(cs, src_offset);
		radeon_emit(cs, (dst_offset >> 32UL) & 0xff);
		radeon_emit(cs, (src_offset >> 32UL) & 0xff);
a96 1
	r600_dma_emit_wait_idle(&ctx->b);
d115 1
d118 2
a119 10
	unsigned dst_mode = rdst->surface.level[dst_level].mode;
	unsigned src_mode = rsrc->surface.level[src_level].mode;
	bool detile = dst_mode == RADEON_SURF_MODE_LINEAR_ALIGNED;
	struct r600_texture *rlinear = detile ? rdst : rsrc;
	struct r600_texture *rtiled = detile ? rsrc : rdst;
	unsigned linear_lvl = detile ? dst_level : src_level;
	unsigned tiled_lvl = detile ? src_level : dst_level;
	struct radeon_info *info = &ctx->screen->b.info;
	unsigned index = rtiled->surface.tiling_index[tiled_lvl];
	unsigned tile_mode = info->si_tile_mode_array[index];
d121 1
a121 1
	unsigned ncopy, height, cheight, i;
d125 1
a125 1
	unsigned pipe_config;
d127 5
d138 5
d152 1
a152 1
	array_mode = G_009910_ARRAY_MODE(tile_mode);
d165 6
a170 6
	bank_h = G_009910_BANK_HEIGHT(tile_mode);
	bank_w = G_009910_BANK_WIDTH(tile_mode);
	mt_aspect = G_009910_MACRO_TILE_ASPECT(tile_mode);
	/* Non-depth modes don't have TILE_SPLIT set. */
	tile_split = util_logbase2(rtiled->surface.tile_split >> 6);
	nbanks = G_009910_NUM_BANKS(tile_mode);
d174 2
a175 2
	pipe_config = G_009910_PIPE_CONFIG(tile_mode);
	mt = G_009910_MICRO_TILE_MODE(tile_mode);
d178 6
a183 1
	r600_need_dma_space(&ctx->b, ncopy * 9, &rdst->resource, &rsrc->resource);
d191 11
a201 11
		radeon_emit(cs, SI_DMA_PACKET(SI_DMA_PACKET_COPY, sub_cmd, size));
		radeon_emit(cs, base >> 8);
		radeon_emit(cs, (detile << 31) | (array_mode << 27) |
				(lbpp << 24) | (bank_h << 21) |
				(bank_w << 18) | (mt_aspect << 16));
		radeon_emit(cs, (pitch_tile_max << 0) | ((height - 1) << 16));
		radeon_emit(cs, (slice_tile_max << 0) | (pipe_config << 26));
		radeon_emit(cs, (tiled_x << 0) | (tiled_z << 18));
		radeon_emit(cs, (tiled_y << 0) | (tile_split << 21) | (nbanks << 25) | (mt << 27));
		radeon_emit(cs, addr & 0xfffffffc);
		radeon_emit(cs, (addr >> 32UL) & 0xff);
a205 1
	r600_dma_emit_wait_idle(&ctx->b);
d208 7
a214 7
static void si_dma_copy(struct pipe_context *ctx,
			struct pipe_resource *dst,
			unsigned dst_level,
			unsigned dstx, unsigned dsty, unsigned dstz,
			struct pipe_resource *src,
			unsigned src_level,
			const struct pipe_box *src_box)
d248 5
a252 3
	if (src_box->depth > 1 ||
	    !r600_prepare_for_dma_blit(&sctx->b, rdst, dst_level, dstx, dsty,
					dstz, rsrc, src_level, src_box))
d254 5
d273 3
a319 5
}

void si_init_dma_functions(struct si_context *sctx)
{
	sctx->b.dma_copy = si_dma_copy;
@


1.1.1.4
log
@Import Mesa 17.1.6
@
text
@d40 1
a40 1
	unsigned i, ncopy, count, max_size, sub_cmd, shift;
d53 1
a53 1
	/* see whether we should use the dword-aligned or byte-aligned copy */
d55 1
d58 1
a58 1
		max_size = SI_DMA_COPY_MAX_DWORD_ALIGNED_SIZE;
d62 1
a62 1
		max_size = SI_DMA_COPY_MAX_BYTE_ALIGNED_SIZE;
d64 1
a65 1
	ncopy = DIV_ROUND_UP(size, max_size);
d69 2
a70 3
		count = MIN2(size, max_size);
		radeon_emit(cs, SI_DMA_PACKET(SI_DMA_PACKET_COPY, sub_cmd,
					      count >> shift));
d75 2
a76 42
		dst_offset += count;
		src_offset += count;
		size -= count;
	}
}

static void si_dma_clear_buffer(struct pipe_context *ctx,
				struct pipe_resource *dst,
				uint64_t offset,
				uint64_t size,
				unsigned clear_value)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct radeon_winsys_cs *cs = sctx->b.dma.cs;
	unsigned i, ncopy, csize;
	struct r600_resource *rdst = r600_resource(dst);

	if (!cs || offset % 4 != 0 || size % 4 != 0 ||
	    dst->flags & PIPE_RESOURCE_FLAG_SPARSE) {
		ctx->clear_buffer(ctx, dst, offset, size, &clear_value, 4);
		return;
	}

	/* Mark the buffer range of destination as valid (initialized),
	 * so that transfer_map knows it should wait for the GPU when mapping
	 * that range. */
	util_range_add(&rdst->valid_buffer_range, offset, offset + size);

	offset += rdst->gpu_address;

	/* the same maximum size as for copying */
	ncopy = DIV_ROUND_UP(size, SI_DMA_COPY_MAX_DWORD_ALIGNED_SIZE);
	r600_need_dma_space(&sctx->b, ncopy * 4, rdst, NULL);

	for (i = 0; i < ncopy; i++) {
		csize = MIN2(size, SI_DMA_COPY_MAX_DWORD_ALIGNED_SIZE);
		radeon_emit(cs, SI_DMA_PACKET(SI_DMA_PACKET_CONSTANT_FILL, 0,
					      csize / 4));
		radeon_emit(cs, offset);
		radeon_emit(cs, clear_value);
		radeon_emit(cs, (offset >> 32) << 16);
		offset += csize;
d79 1
d100 2
a101 1
	unsigned dst_mode = rdst->surface.u.legacy.level[dst_level].mode;
d108 1
a108 1
	unsigned index = rtiled->surface.u.legacy.tiling_index[tiled_lvl];
d117 1
a117 1
	assert(dst_mode != rsrc->surface.u.legacy.level[src_level].mode);
d133 2
a134 2
	slice_tile_max = (rtiled->surface.u.legacy.level[tiled_lvl].nblk_x *
			  rtiled->surface.u.legacy.level[tiled_lvl].nblk_y) / (8*8) - 1;
d140 4
a143 4
	height = rtiled->surface.u.legacy.level[tiled_lvl].nblk_y;
	base = rtiled->surface.u.legacy.level[tiled_lvl].offset;
	addr = rlinear->surface.u.legacy.level[linear_lvl].offset;
	addr += rlinear->surface.u.legacy.level[linear_lvl].slice_size * linear_z;
d149 1
a149 1
	tile_split = util_logbase2(rtiled->surface.u.legacy.tile_split >> 6);
d156 2
a157 2
	size = copy_height * pitch;
	ncopy = DIV_ROUND_UP(size, SI_DMA_COPY_MAX_DWORD_ALIGNED_SIZE);
d162 2
a163 2
		if (cheight * pitch > SI_DMA_COPY_MAX_DWORD_ALIGNED_SIZE) {
			cheight = SI_DMA_COPY_MAX_DWORD_ALIGNED_SIZE / pitch;
d165 2
a166 2
		size = cheight * pitch;
		radeon_emit(cs, SI_DMA_PACKET(SI_DMA_PACKET_COPY, sub_cmd, size / 4));
d181 1
d200 1
a200 3
	if (sctx->b.dma.cs == NULL ||
	    src->flags & PIPE_RESOURCE_FLAG_SPARSE ||
	    dst->flags & PIPE_RESOURCE_FLAG_SPARSE) {
d235 4
a238 4
	dst_pitch = rdst->surface.u.legacy.level[dst_level].nblk_x * rdst->surface.bpe;
	src_pitch = rsrc->surface.u.legacy.level[src_level].nblk_x * rsrc->surface.bpe;
	src_w = u_minify(rsrc->resource.b.b.width0, src_level);
	dst_w = u_minify(rdst->resource.b.b.width0, dst_level);
d240 2
a241 2
	dst_mode = rdst->surface.u.legacy.level[dst_level].mode;
	src_mode = rsrc->surface.u.legacy.level[src_level].mode;
d245 4
a248 4
	    src_box->height != u_minify(rsrc->resource.b.b.height0, src_level) ||
	    src_box->height != u_minify(rdst->resource.b.b.height0, dst_level) ||
	    rsrc->surface.u.legacy.level[src_level].nblk_y !=
	    rdst->surface.u.legacy.level[dst_level].nblk_y) {
d267 2
a268 2
		src_offset= rsrc->surface.u.legacy.level[src_level].offset;
		src_offset += rsrc->surface.u.legacy.level[src_level].slice_size * src_box->z;
d270 2
a271 2
		dst_offset = rdst->surface.u.legacy.level[dst_level].offset;
		dst_offset += rdst->surface.u.legacy.level[dst_level].slice_size * dst_z;
d274 1
a274 1
				   rsrc->surface.u.legacy.level[src_level].slice_size);
a290 1
	sctx->b.dma_clear_buffer = si_dma_clear_buffer;
@


