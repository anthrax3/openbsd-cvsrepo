head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.6.0.2
	OPENBSD_6_1_BASE:1.1.1.6
	mesa-13_0_6:1.1.1.6
	mesa-13_0_5:1.1.1.5
	mesa-13_0_3:1.1.1.4
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.44.32;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.32;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.20.10;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.28.11;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.01.19.05.39.44;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	vYSESphXPMoytdgU;

1.1.1.5
date	2017.02.26.12.08.45;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	xZcdklZavddTKAf1;

1.1.1.6
date	2017.03.25.00.07.45;	author jsg;	state Exp;
branches;
next	;
commitid	YgkKuQ9hssScckR1;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright 2013 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *      Marek Olšák <marek.olsak@@amd.com>
 */

/* Resource binding slots and sampler states (each described with 8 or
 * 4 dwords) are stored in lists in memory which is accessed by shaders
 * using scalar load instructions.
 *
 * This file is responsible for managing such lists. It keeps a copy of all
 * descriptors in CPU memory and re-uploads a whole list if some slots have
 * been changed.
 *
 * This code is also reponsible for updating shader pointers to those lists.
 *
 * Note that CP DMA can't be used for updating the lists, because a GPU hang
 * could leave the list in a mid-IB state and the next IB would get wrong
 * descriptors and the whole context would be unusable at that point.
 * (Note: The register shadowing can't be used due to the same reason)
 *
 * Also, uploading descriptors to newly allocated memory doesn't require
 * a KCACHE flush.
 */

#include "radeon/r600_cs.h"
#include "si_pipe.h"
#include "si_shader.h"
#include "sid.h"

#include "util/u_memory.h"
#include "util/u_upload_mgr.h"


/* NULL image and buffer descriptor.
 *
 * For images, all fields must be zero except for the swizzle, which
 * supports arbitrary combinations of 0s and 1s. The texture type must be
 * any valid type (e.g. 1D). If the texture type isn't set, the hw hangs.
 *
 * For buffers, all fields must be zero. If they are not, the hw hangs.
 *
 * This is the only reason why the buffer descriptor must be in words [4:7].
 */
static uint32_t null_descriptor[8] = {
	0,
	0,
	0,
	S_008F1C_DST_SEL_W(V_008F1C_SQ_SEL_1) |
	S_008F1C_TYPE(V_008F1C_SQ_RSRC_IMG_1D)
	/* the rest must contain zeros, which is also used by the buffer
	 * descriptor */
};

static void si_init_descriptors(struct si_descriptors *desc,
				unsigned shader_userdata_index,
				unsigned element_dw_size,
				unsigned num_elements)
{
	int i;

	assert(num_elements <= sizeof(desc->enabled_mask)*8);

	desc->list = CALLOC(num_elements, element_dw_size * 4);
	desc->element_dw_size = element_dw_size;
	desc->num_elements = num_elements;
	desc->list_dirty = true; /* upload the list before the next draw */
	desc->shader_userdata_offset = shader_userdata_index * 4;

	/* Initialize the array to NULL descriptors if the element size is 8. */
	if (element_dw_size == 8)
		for (i = 0; i < num_elements; i++)
			memcpy(desc->list + i*element_dw_size, null_descriptor,
			       sizeof(null_descriptor));
}

static void si_release_descriptors(struct si_descriptors *desc)
{
	pipe_resource_reference((struct pipe_resource**)&desc->buffer, NULL);
	FREE(desc->list);
}

static bool si_upload_descriptors(struct si_context *sctx,
				  struct si_descriptors *desc)
{
	unsigned list_size = desc->num_elements * desc->element_dw_size * 4;
	void *ptr;

	if (!desc->list_dirty)
		return true;

	u_upload_alloc(sctx->b.uploader, 0, list_size,
		       &desc->buffer_offset,
		       (struct pipe_resource**)&desc->buffer, &ptr);
	if (!desc->buffer)
		return false; /* skip the draw call */

	util_memcpy_cpu_to_le32(ptr, desc->list, list_size);

	r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx, desc->buffer,
			      RADEON_USAGE_READ, RADEON_PRIO_SHADER_DATA);

	desc->list_dirty = false;
	desc->pointer_dirty = true;
	si_mark_atom_dirty(sctx, &sctx->shader_userdata.atom);
	return true;
}

/* SAMPLER VIEWS */

static void si_release_sampler_views(struct si_sampler_views *views)
{
	int i;

	for (i = 0; i < Elements(views->views); i++) {
		pipe_sampler_view_reference(&views->views[i], NULL);
	}
	si_release_descriptors(&views->desc);
}

static enum radeon_bo_priority si_get_resource_ro_priority(struct r600_resource *res)
{
	if (res->b.b.target == PIPE_BUFFER)
		return RADEON_PRIO_SHADER_BUFFER_RO;

	if (res->b.b.nr_samples > 1)
		return RADEON_PRIO_SHADER_TEXTURE_MSAA;

	return RADEON_PRIO_SHADER_TEXTURE_RO;
}

static void si_sampler_views_begin_new_cs(struct si_context *sctx,
					  struct si_sampler_views *views)
{
	uint64_t mask = views->desc.enabled_mask;

	/* Add relocations to the CS. */
	while (mask) {
		int i = u_bit_scan64(&mask);
		struct si_sampler_view *rview =
			(struct si_sampler_view*)views->views[i];

		if (!rview->resource)
			continue;

		r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
				      rview->resource, RADEON_USAGE_READ,
				      si_get_resource_ro_priority(rview->resource));
	}

	if (!views->desc.buffer)
		return;
	r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx, views->desc.buffer,
			      RADEON_USAGE_READWRITE, RADEON_PRIO_SHADER_DATA);
}

static void si_set_sampler_view(struct si_context *sctx, unsigned shader,
				unsigned slot, struct pipe_sampler_view *view,
				unsigned *view_desc)
{
	struct si_sampler_views *views = &sctx->samplers[shader].views;

	if (views->views[slot] == view)
		return;

	if (view) {
		struct si_sampler_view *rview =
			(struct si_sampler_view*)view;

		if (rview->resource)
			r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
				rview->resource, RADEON_USAGE_READ,
				si_get_resource_ro_priority(rview->resource));

		pipe_sampler_view_reference(&views->views[slot], view);
		memcpy(views->desc.list + slot*8, view_desc, 8*4);
		views->desc.enabled_mask |= 1llu << slot;
	} else {
		pipe_sampler_view_reference(&views->views[slot], NULL);
		memcpy(views->desc.list + slot*8, null_descriptor, 8*4);
		views->desc.enabled_mask &= ~(1llu << slot);
	}

	views->desc.list_dirty = true;
}

static void si_set_sampler_views(struct pipe_context *ctx,
				 unsigned shader, unsigned start,
                                 unsigned count,
				 struct pipe_sampler_view **views)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_textures_info *samplers = &sctx->samplers[shader];
	struct si_sampler_view **rviews = (struct si_sampler_view **)views;
	int i;

	if (!count || shader >= SI_NUM_SHADERS)
		return;

	for (i = 0; i < count; i++) {
		unsigned slot = start + i;

		if (!views || !views[i]) {
			samplers->depth_texture_mask &= ~(1 << slot);
			samplers->compressed_colortex_mask &= ~(1 << slot);
			si_set_sampler_view(sctx, shader, slot, NULL, NULL);
			si_set_sampler_view(sctx, shader, SI_FMASK_TEX_OFFSET + slot,
					    NULL, NULL);
			continue;
		}

		si_set_sampler_view(sctx, shader, slot, views[i], rviews[i]->state);

		if (views[i]->texture && views[i]->texture->target != PIPE_BUFFER) {
			struct r600_texture *rtex =
				(struct r600_texture*)views[i]->texture;

			if (rtex->is_depth && !rtex->is_flushing_texture) {
				samplers->depth_texture_mask |= 1 << slot;
			} else {
				samplers->depth_texture_mask &= ~(1 << slot);
			}
			if (rtex->cmask.size || rtex->fmask.size) {
				samplers->compressed_colortex_mask |= 1 << slot;
			} else {
				samplers->compressed_colortex_mask &= ~(1 << slot);
			}

			if (rtex->fmask.size) {
				si_set_sampler_view(sctx, shader, SI_FMASK_TEX_OFFSET + slot,
						    views[i], rviews[i]->fmask_state);
			} else {
				si_set_sampler_view(sctx, shader, SI_FMASK_TEX_OFFSET + slot,
						    NULL, NULL);
			}
		} else {
			samplers->depth_texture_mask &= ~(1 << slot);
			samplers->compressed_colortex_mask &= ~(1 << slot);
			si_set_sampler_view(sctx, shader, SI_FMASK_TEX_OFFSET + slot,
					    NULL, NULL);
		}
	}
}

/* SAMPLER STATES */

static void si_sampler_states_begin_new_cs(struct si_context *sctx,
					   struct si_sampler_states *states)
{
	if (!states->desc.buffer)
		return;
	r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx, states->desc.buffer,
			      RADEON_USAGE_READWRITE, RADEON_PRIO_SHADER_DATA);
}

void si_set_sampler_descriptors(struct si_context *sctx, unsigned shader,
				unsigned start, unsigned count, void **states)
{
	struct si_sampler_states *samplers = &sctx->samplers[shader].states;
	struct si_sampler_state **sstates = (struct si_sampler_state**)states;
	int i;

	if (start == 0)
		samplers->saved_states[0] = states[0];
	if (start == 1)
		samplers->saved_states[1] = states[0];
	else if (start == 0 && count >= 2)
		samplers->saved_states[1] = states[1];

	for (i = 0; i < count; i++) {
		unsigned slot = start + i;

		if (!sstates[i])
			continue;

		memcpy(samplers->desc.list + slot*4, sstates[i]->val, 4*4);
		samplers->desc.list_dirty = true;
	}
}

/* BUFFER RESOURCES */

static void si_init_buffer_resources(struct si_buffer_resources *buffers,
				     unsigned num_buffers,
				     unsigned shader_userdata_index,
				     enum radeon_bo_usage shader_usage,
				     enum radeon_bo_priority priority)
{
	buffers->shader_usage = shader_usage;
	buffers->priority = priority;
	buffers->buffers = CALLOC(num_buffers, sizeof(struct pipe_resource*));

	si_init_descriptors(&buffers->desc, shader_userdata_index, 4,
			    num_buffers);
}

static void si_release_buffer_resources(struct si_buffer_resources *buffers)
{
	int i;

	for (i = 0; i < buffers->desc.num_elements; i++) {
		pipe_resource_reference(&buffers->buffers[i], NULL);
	}

	FREE(buffers->buffers);
	si_release_descriptors(&buffers->desc);
}

static void si_buffer_resources_begin_new_cs(struct si_context *sctx,
					     struct si_buffer_resources *buffers)
{
	uint64_t mask = buffers->desc.enabled_mask;

	/* Add relocations to the CS. */
	while (mask) {
		int i = u_bit_scan64(&mask);

		r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
				      (struct r600_resource*)buffers->buffers[i],
				      buffers->shader_usage, buffers->priority);
	}

	if (!buffers->desc.buffer)
		return;
	r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
			      buffers->desc.buffer, RADEON_USAGE_READWRITE,
			      RADEON_PRIO_SHADER_DATA);
}

/* VERTEX BUFFERS */

static void si_vertex_buffers_begin_new_cs(struct si_context *sctx)
{
	struct si_descriptors *desc = &sctx->vertex_buffers;
	int count = sctx->vertex_elements ? sctx->vertex_elements->count : 0;
	int i;

	for (i = 0; i < count; i++) {
		int vb = sctx->vertex_elements->elements[i].vertex_buffer_index;

		if (vb >= Elements(sctx->vertex_buffer))
			continue;
		if (!sctx->vertex_buffer[vb].buffer)
			continue;

		r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
				      (struct r600_resource*)sctx->vertex_buffer[vb].buffer,
				      RADEON_USAGE_READ, RADEON_PRIO_SHADER_BUFFER_RO);
	}

	if (!desc->buffer)
		return;
	r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
			      desc->buffer, RADEON_USAGE_READ,
			      RADEON_PRIO_SHADER_DATA);
}

static bool si_upload_vertex_buffer_descriptors(struct si_context *sctx)
{
	struct si_descriptors *desc = &sctx->vertex_buffers;
	bool bound[SI_NUM_VERTEX_BUFFERS] = {};
	unsigned i, count = sctx->vertex_elements->count;
	uint64_t va;
	uint32_t *ptr;

	if (!sctx->vertex_buffers_dirty)
		return true;
	if (!count || !sctx->vertex_elements)
		return true;

	/* Vertex buffer descriptors are the only ones which are uploaded
	 * directly through a staging buffer and don't go through
	 * the fine-grained upload path.
	 */
	u_upload_alloc(sctx->b.uploader, 0, count * 16, &desc->buffer_offset,
		       (struct pipe_resource**)&desc->buffer, (void**)&ptr);
	if (!desc->buffer)
		return false;

	r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
			      desc->buffer, RADEON_USAGE_READ,
			      RADEON_PRIO_SHADER_DATA);

	assert(count <= SI_NUM_VERTEX_BUFFERS);

	for (i = 0; i < count; i++) {
		struct pipe_vertex_element *ve = &sctx->vertex_elements->elements[i];
		struct pipe_vertex_buffer *vb;
		struct r600_resource *rbuffer;
		unsigned offset;
		uint32_t *desc = &ptr[i*4];

		if (ve->vertex_buffer_index >= Elements(sctx->vertex_buffer)) {
			memset(desc, 0, 16);
			continue;
		}

		vb = &sctx->vertex_buffer[ve->vertex_buffer_index];
		rbuffer = (struct r600_resource*)vb->buffer;
		if (rbuffer == NULL) {
			memset(desc, 0, 16);
			continue;
		}

		offset = vb->buffer_offset + ve->src_offset;
		va = rbuffer->gpu_address + offset;

		/* Fill in T# buffer resource description */
		desc[0] = va & 0xFFFFFFFF;
		desc[1] = S_008F04_BASE_ADDRESS_HI(va >> 32) |
			  S_008F04_STRIDE(vb->stride);

		if (sctx->b.chip_class <= CIK && vb->stride)
			/* Round up by rounding down and adding 1 */
			desc[2] = (vb->buffer->width0 - offset -
				   sctx->vertex_elements->format_size[i]) /
				  vb->stride + 1;
		else
			desc[2] = vb->buffer->width0 - offset;

		desc[3] = sctx->vertex_elements->rsrc_word3[i];

		if (!bound[ve->vertex_buffer_index]) {
			r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
					      (struct r600_resource*)vb->buffer,
					      RADEON_USAGE_READ, RADEON_PRIO_SHADER_BUFFER_RO);
			bound[ve->vertex_buffer_index] = true;
		}
	}

	/* Don't flush the const cache. It would have a very negative effect
	 * on performance (confirmed by testing). New descriptors are always
	 * uploaded to a fresh new buffer, so I don't think flushing the const
	 * cache is needed. */
	desc->pointer_dirty = true;
	si_mark_atom_dirty(sctx, &sctx->shader_userdata.atom);
	sctx->vertex_buffers_dirty = false;
	return true;
}


/* CONSTANT BUFFERS */

void si_upload_const_buffer(struct si_context *sctx, struct r600_resource **rbuffer,
			    const uint8_t *ptr, unsigned size, uint32_t *const_offset)
{
	void *tmp;

	u_upload_alloc(sctx->b.uploader, 0, size, const_offset,
		       (struct pipe_resource**)rbuffer, &tmp);
	if (rbuffer)
		util_memcpy_cpu_to_le32(tmp, ptr, size);
}

static void si_set_constant_buffer(struct pipe_context *ctx, uint shader, uint slot,
				   struct pipe_constant_buffer *input)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_buffer_resources *buffers = &sctx->const_buffers[shader];

	if (shader >= SI_NUM_SHADERS)
		return;

	assert(slot < buffers->desc.num_elements);
	pipe_resource_reference(&buffers->buffers[slot], NULL);

	/* CIK cannot unbind a constant buffer (S_BUFFER_LOAD is buggy
	 * with a NULL buffer). We need to use a dummy buffer instead. */
	if (sctx->b.chip_class == CIK &&
	    (!input || (!input->buffer && !input->user_buffer)))
		input = &sctx->null_const_buf;

	if (input && (input->buffer || input->user_buffer)) {
		struct pipe_resource *buffer = NULL;
		uint64_t va;

		/* Upload the user buffer if needed. */
		if (input->user_buffer) {
			unsigned buffer_offset;

			si_upload_const_buffer(sctx,
					       (struct r600_resource**)&buffer, input->user_buffer,
					       input->buffer_size, &buffer_offset);
			if (!buffer) {
				/* Just unbind on failure. */
				si_set_constant_buffer(ctx, shader, slot, NULL);
				return;
			}
			va = r600_resource(buffer)->gpu_address + buffer_offset;
		} else {
			pipe_resource_reference(&buffer, input->buffer);
			va = r600_resource(buffer)->gpu_address + input->buffer_offset;
		}

		/* Set the descriptor. */
		uint32_t *desc = buffers->desc.list + slot*4;
		desc[0] = va;
		desc[1] = S_008F04_BASE_ADDRESS_HI(va >> 32) |
			  S_008F04_STRIDE(0);
		desc[2] = input->buffer_size;
		desc[3] = S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) |
			  S_008F0C_DST_SEL_Y(V_008F0C_SQ_SEL_Y) |
			  S_008F0C_DST_SEL_Z(V_008F0C_SQ_SEL_Z) |
			  S_008F0C_DST_SEL_W(V_008F0C_SQ_SEL_W) |
			  S_008F0C_NUM_FORMAT(V_008F0C_BUF_NUM_FORMAT_FLOAT) |
			  S_008F0C_DATA_FORMAT(V_008F0C_BUF_DATA_FORMAT_32);

		buffers->buffers[slot] = buffer;
		r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
				      (struct r600_resource*)buffer,
				      buffers->shader_usage, buffers->priority);
		buffers->desc.enabled_mask |= 1llu << slot;
	} else {
		/* Clear the descriptor. */
		memset(buffers->desc.list + slot*4, 0, sizeof(uint32_t) * 4);
		buffers->desc.enabled_mask &= ~(1llu << slot);
	}

	buffers->desc.list_dirty = true;
}

/* RING BUFFERS */

void si_set_ring_buffer(struct pipe_context *ctx, uint shader, uint slot,
			struct pipe_resource *buffer,
			unsigned stride, unsigned num_records,
			bool add_tid, bool swizzle,
			unsigned element_size, unsigned index_stride, uint64_t offset)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_buffer_resources *buffers = &sctx->rw_buffers[shader];

	if (shader >= SI_NUM_SHADERS)
		return;

	/* The stride field in the resource descriptor has 14 bits */
	assert(stride < (1 << 14));

	assert(slot < buffers->desc.num_elements);
	pipe_resource_reference(&buffers->buffers[slot], NULL);

	if (buffer) {
		uint64_t va;

		va = r600_resource(buffer)->gpu_address + offset;

		switch (element_size) {
		default:
			assert(!"Unsupported ring buffer element size");
		case 0:
		case 2:
			element_size = 0;
			break;
		case 4:
			element_size = 1;
			break;
		case 8:
			element_size = 2;
			break;
		case 16:
			element_size = 3;
			break;
		}

		switch (index_stride) {
		default:
			assert(!"Unsupported ring buffer index stride");
		case 0:
		case 8:
			index_stride = 0;
			break;
		case 16:
			index_stride = 1;
			break;
		case 32:
			index_stride = 2;
			break;
		case 64:
			index_stride = 3;
			break;
		}

		if (sctx->b.chip_class >= VI && stride)
			num_records *= stride;

		/* Set the descriptor. */
		uint32_t *desc = buffers->desc.list + slot*4;
		desc[0] = va;
		desc[1] = S_008F04_BASE_ADDRESS_HI(va >> 32) |
			  S_008F04_STRIDE(stride) |
			  S_008F04_SWIZZLE_ENABLE(swizzle);
		desc[2] = num_records;
		desc[3] = S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) |
			  S_008F0C_DST_SEL_Y(V_008F0C_SQ_SEL_Y) |
			  S_008F0C_DST_SEL_Z(V_008F0C_SQ_SEL_Z) |
			  S_008F0C_DST_SEL_W(V_008F0C_SQ_SEL_W) |
			  S_008F0C_NUM_FORMAT(V_008F0C_BUF_NUM_FORMAT_FLOAT) |
			  S_008F0C_DATA_FORMAT(V_008F0C_BUF_DATA_FORMAT_32) |
			  S_008F0C_ELEMENT_SIZE(element_size) |
			  S_008F0C_INDEX_STRIDE(index_stride) |
			  S_008F0C_ADD_TID_ENABLE(add_tid);

		pipe_resource_reference(&buffers->buffers[slot], buffer);
		r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
				      (struct r600_resource*)buffer,
				      buffers->shader_usage, buffers->priority);
		buffers->desc.enabled_mask |= 1llu << slot;
	} else {
		/* Clear the descriptor. */
		memset(buffers->desc.list + slot*4, 0, sizeof(uint32_t) * 4);
		buffers->desc.enabled_mask &= ~(1llu << slot);
	}

	buffers->desc.list_dirty = true;
}

/* STREAMOUT BUFFERS */

static void si_set_streamout_targets(struct pipe_context *ctx,
				     unsigned num_targets,
				     struct pipe_stream_output_target **targets,
				     const unsigned *offsets)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_buffer_resources *buffers = &sctx->rw_buffers[PIPE_SHADER_VERTEX];
	unsigned old_num_targets = sctx->b.streamout.num_targets;
	unsigned i, bufidx;

	/* We are going to unbind the buffers. Mark which caches need to be flushed. */
	if (sctx->b.streamout.num_targets && sctx->b.streamout.begin_emitted) {
		/* Since streamout uses vector writes which go through TC L2
		 * and most other clients can use TC L2 as well, we don't need
		 * to flush it.
		 *
		 * The only case which requires flushing it is VGT DMA index
		 * fetching, which is a rare case. Thus, flag the TC L2
		 * dirtiness in the resource and handle it when index fetching
		 * is used.
		 */
		for (i = 0; i < sctx->b.streamout.num_targets; i++)
			if (sctx->b.streamout.targets[i])
				r600_resource(sctx->b.streamout.targets[i]->b.buffer)->TC_L2_dirty = true;

		/* Invalidate the scalar cache in case a streamout buffer is
		 * going to be used as a constant buffer.
		 *
		 * Invalidate TC L1, because streamout bypasses it (done by
		 * setting GLC=1 in the store instruction), but it can contain
		 * outdated data of streamout buffers.
		 *
		 * VS_PARTIAL_FLUSH is required if the buffers are going to be
		 * used as an input immediately.
		 */
		sctx->b.flags |= SI_CONTEXT_INV_KCACHE |
				 SI_CONTEXT_INV_TC_L1 |
				 SI_CONTEXT_VS_PARTIAL_FLUSH;
	}

	/* Streamout buffers must be bound in 2 places:
	 * 1) in VGT by setting the VGT_STRMOUT registers
	 * 2) as shader resources
	 */

	/* Set the VGT regs. */
	r600_set_streamout_targets(ctx, num_targets, targets, offsets);

	/* Set the shader resources.*/
	for (i = 0; i < num_targets; i++) {
		bufidx = SI_SO_BUF_OFFSET + i;

		if (targets[i]) {
			struct pipe_resource *buffer = targets[i]->buffer;
			uint64_t va = r600_resource(buffer)->gpu_address;

			/* Set the descriptor.
			 *
			 * On VI, the format must be non-INVALID, otherwise
			 * the buffer will be considered not bound and store
			 * instructions will be no-ops.
			 */
			uint32_t *desc = buffers->desc.list + bufidx*4;
			desc[0] = va;
			desc[1] = S_008F04_BASE_ADDRESS_HI(va >> 32);
			desc[2] = 0xffffffff;
			desc[3] = S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) |
				  S_008F0C_DST_SEL_Y(V_008F0C_SQ_SEL_Y) |
				  S_008F0C_DST_SEL_Z(V_008F0C_SQ_SEL_Z) |
				  S_008F0C_DST_SEL_W(V_008F0C_SQ_SEL_W) |
				  S_008F0C_DATA_FORMAT(V_008F0C_BUF_DATA_FORMAT_32);

			/* Set the resource. */
			pipe_resource_reference(&buffers->buffers[bufidx],
						buffer);
			r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
					      (struct r600_resource*)buffer,
					      buffers->shader_usage, buffers->priority);
			buffers->desc.enabled_mask |= 1llu << bufidx;
		} else {
			/* Clear the descriptor and unset the resource. */
			memset(buffers->desc.list + bufidx*4, 0,
			       sizeof(uint32_t) * 4);
			pipe_resource_reference(&buffers->buffers[bufidx],
						NULL);
			buffers->desc.enabled_mask &= ~(1llu << bufidx);
		}
	}
	for (; i < old_num_targets; i++) {
		bufidx = SI_SO_BUF_OFFSET + i;
		/* Clear the descriptor and unset the resource. */
		memset(buffers->desc.list + bufidx*4, 0, sizeof(uint32_t) * 4);
		pipe_resource_reference(&buffers->buffers[bufidx], NULL);
		buffers->desc.enabled_mask &= ~(1llu << bufidx);
	}

	buffers->desc.list_dirty = true;
}

static void si_desc_reset_buffer_offset(struct pipe_context *ctx,
					uint32_t *desc, uint64_t old_buf_va,
					struct pipe_resource *new_buf)
{
	/* Retrieve the buffer offset from the descriptor. */
	uint64_t old_desc_va =
		desc[0] | ((uint64_t)G_008F04_BASE_ADDRESS_HI(desc[1]) << 32);

	assert(old_buf_va <= old_desc_va);
	uint64_t offset_within_buffer = old_desc_va - old_buf_va;

	/* Update the descriptor. */
	uint64_t va = r600_resource(new_buf)->gpu_address + offset_within_buffer;

	desc[0] = va;
	desc[1] = (desc[1] & C_008F04_BASE_ADDRESS_HI) |
		  S_008F04_BASE_ADDRESS_HI(va >> 32);
}

/* BUFFER DISCARD/INVALIDATION */

/* Reallocate a buffer a update all resource bindings where the buffer is
 * bound.
 *
 * This is used to avoid CPU-GPU synchronizations, because it makes the buffer
 * idle by discarding its contents. Apps usually tell us when to do this using
 * map_buffer flags, for example.
 */
static void si_invalidate_buffer(struct pipe_context *ctx, struct pipe_resource *buf)
{
	struct si_context *sctx = (struct si_context*)ctx;
	struct r600_resource *rbuffer = r600_resource(buf);
	unsigned i, shader, alignment = rbuffer->buf->alignment;
	uint64_t old_va = rbuffer->gpu_address;
	unsigned num_elems = sctx->vertex_elements ?
				       sctx->vertex_elements->count : 0;
	struct si_sampler_view *view;

	/* Reallocate the buffer in the same pipe_resource. */
	r600_init_resource(&sctx->screen->b, rbuffer, rbuffer->b.b.width0,
			   alignment, TRUE);

	/* We changed the buffer, now we need to bind it where the old one
	 * was bound. This consists of 2 things:
	 *   1) Updating the resource descriptor and dirtying it.
	 *   2) Adding a relocation to the CS, so that it's usable.
	 */

	/* Vertex buffers. */
	for (i = 0; i < num_elems; i++) {
		int vb = sctx->vertex_elements->elements[i].vertex_buffer_index;

		if (vb >= Elements(sctx->vertex_buffer))
			continue;
		if (!sctx->vertex_buffer[vb].buffer)
			continue;

		if (sctx->vertex_buffer[vb].buffer == buf) {
			sctx->vertex_buffers_dirty = true;
			break;
		}
	}

	/* Read/Write buffers. */
	for (shader = 0; shader < SI_NUM_SHADERS; shader++) {
		struct si_buffer_resources *buffers = &sctx->rw_buffers[shader];
		uint64_t mask = buffers->desc.enabled_mask;

		while (mask) {
			i = u_bit_scan64(&mask);
			if (buffers->buffers[i] == buf) {
				si_desc_reset_buffer_offset(ctx, buffers->desc.list + i*4,
							    old_va, buf);
				buffers->desc.list_dirty = true;

				r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
						      rbuffer, buffers->shader_usage,
						      buffers->priority);

				if (i >= SI_SO_BUF_OFFSET && shader == PIPE_SHADER_VERTEX) {
					/* Update the streamout state. */
					if (sctx->b.streamout.begin_emitted) {
						r600_emit_streamout_end(&sctx->b);
					}
					sctx->b.streamout.append_bitmask =
						sctx->b.streamout.enabled_mask;
					r600_streamout_buffers_dirty(&sctx->b);
				}
			}
		}
	}

	/* Constant buffers. */
	for (shader = 0; shader < SI_NUM_SHADERS; shader++) {
		struct si_buffer_resources *buffers = &sctx->const_buffers[shader];
		uint64_t mask = buffers->desc.enabled_mask;

		while (mask) {
			unsigned i = u_bit_scan64(&mask);
			if (buffers->buffers[i] == buf) {
				si_desc_reset_buffer_offset(ctx, buffers->desc.list + i*4,
							    old_va, buf);
				buffers->desc.list_dirty = true;

				r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
						      rbuffer, buffers->shader_usage,
						      buffers->priority);
			}
		}
	}

	/* Texture buffers - update virtual addresses in sampler view descriptors. */
	LIST_FOR_EACH_ENTRY(view, &sctx->b.texture_buffers, list) {
		if (view->base.texture == buf) {
			si_desc_reset_buffer_offset(ctx, &view->state[4], old_va, buf);
		}
	}
	/* Texture buffers - update bindings. */
	for (shader = 0; shader < SI_NUM_SHADERS; shader++) {
		struct si_sampler_views *views = &sctx->samplers[shader].views;
		uint64_t mask = views->desc.enabled_mask;

		while (mask) {
			unsigned i = u_bit_scan64(&mask);
			if (views->views[i]->texture == buf) {
				si_desc_reset_buffer_offset(ctx, views->desc.list + i*8+4,
							    old_va, buf);
				views->desc.list_dirty = true;

				r600_context_bo_reloc(&sctx->b, &sctx->b.rings.gfx,
						      rbuffer, RADEON_USAGE_READ,
						      RADEON_PRIO_SHADER_BUFFER_RO);
			}
		}
	}
}

/* SHADER USER DATA */

static void si_mark_shader_pointers_dirty(struct si_context *sctx,
					  unsigned shader)
{
	sctx->const_buffers[shader].desc.pointer_dirty = true;
	sctx->rw_buffers[shader].desc.pointer_dirty = true;
	sctx->samplers[shader].views.desc.pointer_dirty = true;
	sctx->samplers[shader].states.desc.pointer_dirty = true;

	if (shader == PIPE_SHADER_VERTEX)
		sctx->vertex_buffers.pointer_dirty = true;

	si_mark_atom_dirty(sctx, &sctx->shader_userdata.atom);
}

static void si_shader_userdata_begin_new_cs(struct si_context *sctx)
{
	int i;

	for (i = 0; i < SI_NUM_SHADERS; i++) {
		si_mark_shader_pointers_dirty(sctx, i);
	}
}

/* Set a base register address for user data constants in the given shader.
 * This assigns a mapping from PIPE_SHADER_* to SPI_SHADER_USER_DATA_*.
 */
static void si_set_user_data_base(struct si_context *sctx,
				  unsigned shader, uint32_t new_base)
{
	uint32_t *base = &sctx->shader_userdata.sh_base[shader];

	if (*base != new_base) {
		*base = new_base;

		if (new_base)
			si_mark_shader_pointers_dirty(sctx, shader);
	}
}

/* This must be called when these shaders are changed from non-NULL to NULL
 * and vice versa:
 * - geometry shader
 * - tessellation control shader
 * - tessellation evaluation shader
 */
void si_shader_change_notify(struct si_context *sctx)
{
	/* VS can be bound as VS, ES, or LS. */
	if (sctx->tes_shader)
		si_set_user_data_base(sctx, PIPE_SHADER_VERTEX,
				      R_00B530_SPI_SHADER_USER_DATA_LS_0);
	else if (sctx->gs_shader)
		si_set_user_data_base(sctx, PIPE_SHADER_VERTEX,
				      R_00B330_SPI_SHADER_USER_DATA_ES_0);
	else
		si_set_user_data_base(sctx, PIPE_SHADER_VERTEX,
				      R_00B130_SPI_SHADER_USER_DATA_VS_0);

	/* TES can be bound as ES, VS, or not bound. */
	if (sctx->tes_shader) {
		if (sctx->gs_shader)
			si_set_user_data_base(sctx, PIPE_SHADER_TESS_EVAL,
					      R_00B330_SPI_SHADER_USER_DATA_ES_0);
		else
			si_set_user_data_base(sctx, PIPE_SHADER_TESS_EVAL,
					      R_00B130_SPI_SHADER_USER_DATA_VS_0);
	} else {
		si_set_user_data_base(sctx, PIPE_SHADER_TESS_EVAL, 0);
	}
}

static void si_emit_shader_pointer(struct si_context *sctx,
				   struct si_descriptors *desc,
				   unsigned sh_base, bool keep_dirty)
{
	struct radeon_winsys_cs *cs = sctx->b.rings.gfx.cs;
	uint64_t va;

	if (!desc->pointer_dirty || !desc->buffer)
		return;

	va = desc->buffer->gpu_address +
	     desc->buffer_offset;

	radeon_emit(cs, PKT3(PKT3_SET_SH_REG, 2, 0));
	radeon_emit(cs, (sh_base + desc->shader_userdata_offset - SI_SH_REG_OFFSET) >> 2);
	radeon_emit(cs, va);
	radeon_emit(cs, va >> 32);

	desc->pointer_dirty = keep_dirty;
}

static void si_emit_shader_userdata(struct si_context *sctx,
				    struct r600_atom *atom)
{
	unsigned i;
	uint32_t *sh_base = sctx->shader_userdata.sh_base;

	if (sctx->gs_shader) {
		/* The VS copy shader needs these for clipping, streamout, and rings. */
		unsigned vs_base = R_00B130_SPI_SHADER_USER_DATA_VS_0;
		unsigned i = PIPE_SHADER_VERTEX;

		si_emit_shader_pointer(sctx, &sctx->const_buffers[i].desc, vs_base, true);
		si_emit_shader_pointer(sctx, &sctx->rw_buffers[i].desc, vs_base, true);

		/* The TESSEVAL shader needs this for the ESGS ring buffer. */
		si_emit_shader_pointer(sctx, &sctx->rw_buffers[i].desc,
				       R_00B330_SPI_SHADER_USER_DATA_ES_0, true);
	} else if (sctx->tes_shader) {
		/* The TESSEVAL shader needs this for streamout. */
		si_emit_shader_pointer(sctx, &sctx->rw_buffers[PIPE_SHADER_VERTEX].desc,
				       R_00B130_SPI_SHADER_USER_DATA_VS_0, true);
	}

	for (i = 0; i < SI_NUM_SHADERS; i++) {
		unsigned base = sh_base[i];

		if (!base)
			continue;

		if (i != PIPE_SHADER_TESS_EVAL)
			si_emit_shader_pointer(sctx, &sctx->rw_buffers[i].desc, base, false);

		si_emit_shader_pointer(sctx, &sctx->const_buffers[i].desc, base, false);
		si_emit_shader_pointer(sctx, &sctx->samplers[i].views.desc, base, false);
		si_emit_shader_pointer(sctx, &sctx->samplers[i].states.desc, base, false);
	}
	si_emit_shader_pointer(sctx, &sctx->vertex_buffers, sh_base[PIPE_SHADER_VERTEX], false);
}

/* INIT/DEINIT/UPLOAD */

void si_init_all_descriptors(struct si_context *sctx)
{
	int i;

	for (i = 0; i < SI_NUM_SHADERS; i++) {
		si_init_buffer_resources(&sctx->const_buffers[i],
					 SI_NUM_CONST_BUFFERS, SI_SGPR_CONST,
					 RADEON_USAGE_READ, RADEON_PRIO_SHADER_BUFFER_RO);
		si_init_buffer_resources(&sctx->rw_buffers[i],
					 SI_NUM_RW_BUFFERS, SI_SGPR_RW_BUFFERS,
					 RADEON_USAGE_READWRITE, RADEON_PRIO_SHADER_RESOURCE_RW);

		si_init_descriptors(&sctx->samplers[i].views.desc,
				    SI_SGPR_RESOURCE, 8, SI_NUM_SAMPLER_VIEWS);
		si_init_descriptors(&sctx->samplers[i].states.desc,
				    SI_SGPR_SAMPLER, 4, SI_NUM_SAMPLER_STATES);
	}

	si_init_descriptors(&sctx->vertex_buffers, SI_SGPR_VERTEX_BUFFER,
			    4, SI_NUM_VERTEX_BUFFERS);

	/* Set pipe_context functions. */
	sctx->b.b.set_constant_buffer = si_set_constant_buffer;
	sctx->b.b.set_sampler_views = si_set_sampler_views;
	sctx->b.b.set_stream_output_targets = si_set_streamout_targets;
	sctx->b.invalidate_buffer = si_invalidate_buffer;

	/* Shader user data. */
	sctx->atoms.s.shader_userdata = &sctx->shader_userdata.atom;
	sctx->shader_userdata.atom.emit = (void*)si_emit_shader_userdata;

	/* Upper bound, 4 pointers per shader, +1 for vertex buffers, +2 for the VS copy shader. */
	sctx->shader_userdata.atom.num_dw = (SI_NUM_SHADERS * 4 + 1 + 2) * 4;

	/* Set default and immutable mappings. */
	si_set_user_data_base(sctx, PIPE_SHADER_VERTEX, R_00B130_SPI_SHADER_USER_DATA_VS_0);
	si_set_user_data_base(sctx, PIPE_SHADER_TESS_CTRL, R_00B430_SPI_SHADER_USER_DATA_HS_0);
	si_set_user_data_base(sctx, PIPE_SHADER_GEOMETRY, R_00B230_SPI_SHADER_USER_DATA_GS_0);
	si_set_user_data_base(sctx, PIPE_SHADER_FRAGMENT, R_00B030_SPI_SHADER_USER_DATA_PS_0);
}

bool si_upload_shader_descriptors(struct si_context *sctx)
{
	int i;

	for (i = 0; i < SI_NUM_SHADERS; i++) {
		if (!si_upload_descriptors(sctx, &sctx->const_buffers[i].desc) ||
		    !si_upload_descriptors(sctx, &sctx->rw_buffers[i].desc) ||
		    !si_upload_descriptors(sctx, &sctx->samplers[i].views.desc) ||
		    !si_upload_descriptors(sctx, &sctx->samplers[i].states.desc))
			return false;
	}
	return si_upload_vertex_buffer_descriptors(sctx);
}

void si_release_all_descriptors(struct si_context *sctx)
{
	int i;

	for (i = 0; i < SI_NUM_SHADERS; i++) {
		si_release_buffer_resources(&sctx->const_buffers[i]);
		si_release_buffer_resources(&sctx->rw_buffers[i]);
		si_release_sampler_views(&sctx->samplers[i].views);
		si_release_descriptors(&sctx->samplers[i].states.desc);
	}
	si_release_descriptors(&sctx->vertex_buffers);
}

void si_all_descriptors_begin_new_cs(struct si_context *sctx)
{
	int i;

	for (i = 0; i < SI_NUM_SHADERS; i++) {
		si_buffer_resources_begin_new_cs(sctx, &sctx->const_buffers[i]);
		si_buffer_resources_begin_new_cs(sctx, &sctx->rw_buffers[i]);
		si_sampler_views_begin_new_cs(sctx, &sctx->samplers[i].views);
		si_sampler_states_begin_new_cs(sctx, &sctx->samplers[i].states);
	}
	si_vertex_buffers_begin_new_cs(sctx);
	si_shader_userdata_begin_new_cs(sctx);
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@a43 12
 *
 *
 * Possible scenarios for one 16 dword image+sampler slot:
 *
 *       | Image        | w/ FMASK   | Buffer       | NULL
 * [ 0: 3] Image[0:3]   | Image[0:3] | Null[0:3]    | Null[0:3]
 * [ 4: 7] Image[4:7]   | Image[4:7] | Buffer[0:3]  | 0
 * [ 8:11] Null[0:3]    | Fmask[0:3] | Null[0:3]    | Null[0:3]
 * [12:15] Sampler[0:3] | Fmask[4:7] | Sampler[0:3] | Sampler[0:3]
 *
 * FMASK implies MSAA, therefore no sampler state.
 * Sampler states are never unbound except when FMASK is bound.
d91 3
a93 3
	if (element_dw_size % 8 == 0)
		for (i = 0; i < num_elements * element_dw_size / 8; i++)
			memcpy(desc->list + i*8, null_descriptor,
d112 1
a112 1
	u_upload_alloc(sctx->b.uploader, 0, list_size, 256,
d120 2
a121 2
	radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx, desc->buffer,
			      RADEON_USAGE_READ, RADEON_PRIO_DESCRIPTORS);
d141 1
a141 2
static void si_sampler_view_add_buffers(struct si_context *sctx,
					struct si_sampler_view *rview)
d143 5
a147 5
	if (rview->resource) {
		radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
			rview->resource, RADEON_USAGE_READ,
			r600_get_sampler_view_priority(rview->resource));
	}
d149 1
a149 5
	if (rview->dcc_buffer && rview->dcc_buffer != rview->resource) {
		radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
			rview->dcc_buffer, RADEON_USAGE_READ,
			RADEON_PRIO_DCC);
	}
d157 1
a157 1
	/* Add buffers to the CS. */
d163 6
a168 1
		si_sampler_view_add_buffers(sctx, rview);
d173 2
a174 2
	radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx, views->desc.buffer,
			      RADEON_USAGE_READWRITE, RADEON_PRIO_DESCRIPTORS);
d177 3
a179 3
static void si_set_sampler_view(struct si_context *sctx,
				struct si_sampler_views *views,
				unsigned slot, struct pipe_sampler_view *view)
d181 2
a188 1
		struct r600_texture *rtex = (struct r600_texture*)view->texture;
d190 4
a193 1
		si_sampler_view_add_buffers(sctx, rview);
d196 1
a196 16
		memcpy(views->desc.list + slot * 16, rview->state, 8*4);

		if (view->texture && view->texture->target != PIPE_BUFFER &&
		    rtex->fmask.size) {
			memcpy(views->desc.list + slot*16 + 8,
			       rview->fmask_state, 8*4);
		} else {
			/* Disable FMASK and bind sampler state in [12:15]. */
			memcpy(views->desc.list + slot*16 + 8,
			       null_descriptor, 4*4);

			if (views->sampler_states[slot])
				memcpy(views->desc.list + slot*16 + 12,
				       views->sampler_states[slot], 4*4);
		}

d200 1
a200 3
		memcpy(views->desc.list + slot*16, null_descriptor, 8*4);
		/* Only clear the lower dwords of FMASK. */
		memcpy(views->desc.list + slot*16 + 8, null_descriptor, 4*4);
d214 1
d226 3
a228 1
			si_set_sampler_view(sctx, &samplers->views, slot, NULL);
d232 1
a232 1
		si_set_sampler_view(sctx, &samplers->views, slot, views[i]);
d243 1
a243 2
			if (rtex->cmask.size || rtex->fmask.size ||
			    (rtex->dcc_buffer && rtex->dirty_level_mask)) {
d248 8
d259 2
d267 11
a277 2
static void si_bind_sampler_states(struct pipe_context *ctx, unsigned shader,
                                   unsigned start, unsigned count, void **states)
d279 1
a279 3
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_textures_info *samplers = &sctx->samplers[shader];
	struct si_descriptors *desc = &samplers->views.desc;
d283 6
a288 2
	if (!count || shader >= SI_NUM_SHADERS)
		return;
d293 1
a293 13
		if (!sstates[i] ||
		    sstates[i] == samplers->views.sampler_states[slot])
			continue;

		samplers->views.sampler_states[slot] = sstates[i];

		/* If FMASK is bound, don't overwrite it.
		 * The sampler state will be set after FMASK is unbound.
		 */
		if (samplers->views.views[i] &&
		    samplers->views.views[i]->texture &&
		    samplers->views.views[i]->texture->target != PIPE_BUFFER &&
		    ((struct r600_texture*)samplers->views.views[i]->texture)->fmask.size)
d296 2
a297 2
		memcpy(desc->list + slot * 16 + 12, sstates[i]->val, 4*4);
		desc->list_dirty = true;
d334 1
a334 1
	/* Add buffers to the CS. */
d338 1
a338 1
		radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
d345 1
a345 1
	radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
d347 1
a347 1
			      RADEON_PRIO_DESCRIPTORS);
d366 1
a366 1
		radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
d368 1
a368 1
				      RADEON_USAGE_READ, RADEON_PRIO_VERTEX_BUFFER);
d373 1
a373 1
	radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
d375 1
a375 1
			      RADEON_PRIO_DESCRIPTORS);
d395 1
a395 1
	u_upload_alloc(sctx->b.uploader, 0, count * 16, 256, &desc->buffer_offset,
d400 1
a400 1
	radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
d402 1
a402 1
			      RADEON_PRIO_DESCRIPTORS);
d420 1
a420 1
		if (!rbuffer) {
d429 1
a429 1
		desc[0] = va;
d444 1
a444 1
			radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
d446 1
a446 1
					      RADEON_USAGE_READ, RADEON_PRIO_VERTEX_BUFFER);
d469 1
a469 1
	u_upload_alloc(sctx->b.uploader, 0, size, 256, const_offset,
d471 1
a471 1
	if (*rbuffer)
d529 1
a529 1
		radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
d624 1
a624 1
		radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
d674 2
a675 2
		sctx->b.flags |= SI_CONTEXT_INV_SMEM_L1 |
				 SI_CONTEXT_INV_VMEM_L1 |
d714 1
a714 1
			radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
d813 1
a813 1
				radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
d842 1
a842 1
				radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
d863 1
a863 3
				si_desc_reset_buffer_offset(ctx,
							    views->desc.list +
							    i * 16 + 4,
d867 1
a867 1
				radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx,
d869 1
a869 1
						      RADEON_PRIO_SAMPLER_BUFFER);
d883 1
d925 1
a925 1
	if (sctx->tes_shader.cso)
d928 1
a928 1
	else if (sctx->gs_shader.cso)
d936 2
a937 2
	if (sctx->tes_shader.cso) {
		if (sctx->gs_shader.cso)
d952 1
a952 1
	struct radeon_winsys_cs *cs = sctx->b.gfx.cs;
d969 2
a970 1
void si_emit_shader_userdata(struct si_context *sctx, struct r600_atom *atom)
d975 1
a975 1
	if (sctx->gs_shader.cso) {
d983 4
a986 6
		if (sctx->tes_shader.cso) {
			/* The TESSEVAL shader needs this for the ESGS ring buffer. */
			si_emit_shader_pointer(sctx, &sctx->rw_buffers[i].desc,
					       R_00B330_SPI_SHADER_USER_DATA_ES_0, true);
		}
	} else if (sctx->tes_shader.cso) {
d1003 1
d1016 2
a1017 2
					 SI_NUM_CONST_BUFFERS, SI_SGPR_CONST_BUFFERS,
					 RADEON_USAGE_READ, RADEON_PRIO_CONST_BUFFER);
d1020 1
a1020 1
					 RADEON_USAGE_READWRITE, RADEON_PRIO_RINGS_STREAMOUT);
d1023 3
a1025 1
				    SI_SGPR_SAMPLERS, 16, SI_NUM_SAMPLERS);
d1028 1
a1028 1
	si_init_descriptors(&sctx->vertex_buffers, SI_SGPR_VERTEX_BUFFERS,
a1031 1
	sctx->b.b.bind_sampler_states = si_bind_sampler_states;
d1038 5
a1042 2
	si_init_atom(sctx, &sctx->shader_userdata.atom, &sctx->atoms.s.shader_userdata,
		     si_emit_shader_userdata);
d1058 2
a1059 1
		    !si_upload_descriptors(sctx, &sctx->samplers[i].views.desc))
d1073 1
d1086 1
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d60 1
a62 1
#include "util/u_format.h"
d67 1
a67 2
/* NULL image and buffer descriptor for textures (alpha = 1) and images
 * (alpha = 0).
d77 1
a77 1
static uint32_t null_texture_descriptor[8] = {
a86 9
static uint32_t null_image_descriptor[8] = {
	0,
	0,
	0,
	S_008F1C_TYPE(V_008F1C_SQ_RSRC_IMG_1D)
	/* the rest must contain zeros, which is also used by the buffer
	 * descriptor */
};

d90 1
a90 3
				unsigned num_elements,
				const uint32_t *null_descriptor,
				unsigned *ce_offset)
d94 1
a94 1
	assert(num_elements <= sizeof(desc->dirty_mask)*8);
d99 1
a99 1
	desc->dirty_mask = num_elements == 32 ? ~0u : (1u << num_elements) - 1;
a101 7
	if (ce_offset) {
		desc->ce_offset = *ce_offset;

		/* make sure that ce_offset stays 32 byte aligned */
		*ce_offset += align(element_dw_size * num_elements * 4, 32);
	}

d103 1
a103 2
	if (null_descriptor) {
		assert(element_dw_size % 8 == 0);
d105 2
a106 3
			memcpy(desc->list + i * 8, null_descriptor,
			       8 * 4);
	}
d111 1
a111 1
	r600_resource_reference(&desc->buffer, NULL);
a114 66
static bool si_ce_upload(struct si_context *sctx, unsigned ce_offset, unsigned size,
			 unsigned *out_offset, struct r600_resource **out_buf) {
	uint64_t va;

	u_suballocator_alloc(sctx->ce_suballocator, size, 64, out_offset,
			     (struct pipe_resource**)out_buf);
	if (!out_buf)
			return false;

	va = (*out_buf)->gpu_address + *out_offset;

	radeon_emit(sctx->ce_ib, PKT3(PKT3_DUMP_CONST_RAM, 3, 0));
	radeon_emit(sctx->ce_ib, ce_offset);
	radeon_emit(sctx->ce_ib, size / 4);
	radeon_emit(sctx->ce_ib, va);
	radeon_emit(sctx->ce_ib, va >> 32);

	radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx, *out_buf,
	                       RADEON_USAGE_READWRITE, RADEON_PRIO_DESCRIPTORS);

	sctx->ce_need_synchronization = true;
	return true;
}

static void si_ce_reinitialize_descriptors(struct si_context *sctx,
                                           struct si_descriptors *desc)
{
	if (desc->buffer) {
		struct r600_resource *buffer = (struct r600_resource*)desc->buffer;
		unsigned list_size = desc->num_elements * desc->element_dw_size * 4;
		uint64_t va = buffer->gpu_address + desc->buffer_offset;
		struct radeon_winsys_cs *ib = sctx->ce_preamble_ib;

		if (!ib)
			ib = sctx->ce_ib;

		list_size = align(list_size, 32);

		radeon_emit(ib, PKT3(PKT3_LOAD_CONST_RAM, 3, 0));
		radeon_emit(ib, va);
		radeon_emit(ib, va >> 32);
		radeon_emit(ib, list_size / 4);
		radeon_emit(ib, desc->ce_offset);

		radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx, desc->buffer,
		                    RADEON_USAGE_READ, RADEON_PRIO_DESCRIPTORS);
	}
	desc->ce_ram_dirty = false;
}

void si_ce_reinitialize_all_descriptors(struct si_context *sctx)
{
	int i;

	for (i = 0; i < SI_NUM_DESCS; ++i)
		si_ce_reinitialize_descriptors(sctx, &sctx->descriptors[i]);
}

void si_ce_enable_loads(struct radeon_winsys_cs *ib)
{
	radeon_emit(ib, PKT3(PKT3_CONTEXT_CONTROL, 1, 0));
	radeon_emit(ib, CONTEXT_CONTROL_LOAD_ENABLE(1) |
	                CONTEXT_CONTROL_LOAD_CE_RAM(1));
	radeon_emit(ib, CONTEXT_CONTROL_SHADOW_ENABLE(1));
}

d116 1
a116 2
				  struct si_descriptors *desc,
				  struct r600_atom * atom)
d119 1
d121 1
a121 1
	if (!desc->dirty_mask)
d124 5
a128 2
	if (sctx->ce_ib) {
		uint32_t const* list = (uint32_t const*)desc->list;
d130 1
a130 2
		if (desc->ce_ram_dirty)
			si_ce_reinitialize_descriptors(sctx, desc);
d132 2
a133 27
		while(desc->dirty_mask) {
			int begin, count;
			u_bit_scan_consecutive_range(&desc->dirty_mask, &begin,
						     &count);

			begin *= desc->element_dw_size;
			count *= desc->element_dw_size;

			radeon_emit(sctx->ce_ib,
			            PKT3(PKT3_WRITE_CONST_RAM, count, 0));
			radeon_emit(sctx->ce_ib, desc->ce_offset + begin * 4);
			radeon_emit_array(sctx->ce_ib, list + begin, count);
		}

		if (!si_ce_upload(sctx, desc->ce_offset, list_size,
		                           &desc->buffer_offset, &desc->buffer))
			return false;
	} else {
		void *ptr;

		u_upload_alloc(sctx->b.uploader, 0, list_size, 256,
			&desc->buffer_offset,
			(struct pipe_resource**)&desc->buffer, &ptr);
		if (!desc->buffer)
			return false; /* skip the draw call */

		util_memcpy_cpu_to_le32(ptr, desc->list, list_size);
d135 1
a135 3
		radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx, desc->buffer,
	                            RADEON_USAGE_READ, RADEON_PRIO_DESCRIPTORS);
	}
d137 1
a137 5
	desc->dirty_mask = 0;

	if (atom)
		si_mark_atom_dirty(sctx, atom);

a140 12
static void
si_descriptors_begin_new_cs(struct si_context *sctx, struct si_descriptors *desc)
{
	desc->ce_ram_dirty = true;

	if (!desc->buffer)
		return;

	radeon_add_to_buffer_list(&sctx->b, &sctx->b.gfx, desc->buffer,
				  RADEON_USAGE_READ, RADEON_PRIO_DESCRIPTORS);
}

a142 13
static unsigned
si_sampler_descriptors_idx(unsigned shader)
{
	return SI_DESCS_FIRST_SHADER + shader * SI_NUM_SHADER_DESCS +
	       SI_SHADER_DESCS_SAMPLERS;
}

static struct si_descriptors *
si_sampler_descriptors(struct si_context *sctx, unsigned shader)
{
	return &sctx->descriptors[si_sampler_descriptors_idx(shader)];
}

d147 1
a147 1
	for (i = 0; i < ARRAY_SIZE(views->views); i++) {
d150 1
d153 8
a160 9
static void si_sampler_view_add_buffer(struct si_context *sctx,
				       struct pipe_resource *resource,
				       enum radeon_bo_usage usage,
				       bool is_stencil_sampler,
				       bool check_mem)
{
	struct r600_resource *rres;
	struct r600_texture *rtex;
	enum radeon_bo_priority priority;
d162 4
a165 8
	if (!resource)
		return;

	if (resource->target != PIPE_BUFFER) {
		struct r600_texture *tex = (struct r600_texture*)resource;

		if (tex->is_depth && !r600_can_sample_zs(tex, is_stencil_sampler))
			resource = &tex->flushed_depth_texture->resource.b.b;
a166 19

	rres = (struct r600_resource*)resource;
	priority = r600_get_sampler_view_priority(rres);

	radeon_add_to_buffer_list_check_mem(&sctx->b, &sctx->b.gfx,
					    rres, usage, priority,
					    check_mem);

	if (resource->target == PIPE_BUFFER)
		return;

	/* Now add separate DCC if it's present. */
	rtex = (struct r600_texture*)resource;
	if (!rtex->dcc_separate_buffer)
		return;

	radeon_add_to_buffer_list_check_mem(&sctx->b, &sctx->b.gfx,
					    rtex->dcc_separate_buffer, usage,
					    RADEON_PRIO_DCC, check_mem);
d172 1
a172 1
	unsigned mask = views->enabled_mask;
d176 3
a178 2
		int i = u_bit_scan(&mask);
		struct si_sampler_view *sview = (struct si_sampler_view *)views->views[i];
d180 1
a180 3
		si_sampler_view_add_buffer(sctx, sview->base.texture,
					   RADEON_USAGE_READ,
					   sview->is_stencil_sampler, false);
a181 1
}
d183 4
a186 9
/* Set buffer descriptor fields that can be changed by reallocations. */
static void si_set_buf_desc_address(struct r600_resource *buf,
				    uint64_t offset, uint32_t *state)
{
	uint64_t va = buf->gpu_address + offset;

	state[0] = va;
	state[1] &= C_008F04_BASE_ADDRESS_HI;
	state[1] |= S_008F04_BASE_ADDRESS_HI(va >> 32);
d189 3
a191 15
/* Set texture descriptor fields that can be changed by reallocations.
 *
 * \param tex			texture
 * \param base_level_info	information of the level of BASE_ADDRESS
 * \param base_level		the level of BASE_ADDRESS
 * \param first_level		pipe_sampler_view.u.tex.first_level
 * \param block_width		util_format_get_blockwidth()
 * \param is_stencil		select between separate Z & Stencil
 * \param state			descriptor to update
 */
void si_set_mutable_tex_desc_fields(struct r600_texture *tex,
				    const struct radeon_surf_level *base_level_info,
				    unsigned base_level, unsigned first_level,
				    unsigned block_width, bool is_stencil,
				    uint32_t *state)
d193 1
a193 42
	uint64_t va;
	unsigned pitch = base_level_info->nblk_x * block_width;

	if (tex->is_depth && !r600_can_sample_zs(tex, is_stencil)) {
		tex = tex->flushed_depth_texture;
		is_stencil = false;
	}

	va = tex->resource.gpu_address + base_level_info->offset;

	state[1] &= C_008F14_BASE_ADDRESS_HI;
	state[3] &= C_008F1C_TILING_INDEX;
	state[4] &= C_008F20_PITCH;
	state[6] &= C_008F28_COMPRESSION_EN;

	state[0] = va >> 8;
	state[1] |= S_008F14_BASE_ADDRESS_HI(va >> 40);
	state[3] |= S_008F1C_TILING_INDEX(si_tile_mode_index(tex, base_level,
							     is_stencil));
	state[4] |= S_008F20_PITCH(pitch - 1);

	if (tex->dcc_offset && tex->surface.level[first_level].dcc_enabled) {
		state[6] |= S_008F28_COMPRESSION_EN(1);
		state[7] = ((!tex->dcc_separate_buffer ? tex->resource.gpu_address : 0) +
			    tex->dcc_offset +
			    base_level_info->dcc_offset) >> 8;
	} else if (tex->tc_compatible_htile) {
		state[6] |= S_008F28_COMPRESSION_EN(1);
		state[7] = tex->htile_buffer->gpu_address >> 8;
	}
}

static void si_set_sampler_view(struct si_context *sctx,
				unsigned shader,
				unsigned slot, struct pipe_sampler_view *view,
				bool disallow_early_out)
{
	struct si_sampler_views *views = &sctx->samplers[shader].views;
	struct si_sampler_view *rview = (struct si_sampler_view*)view;
	struct si_descriptors *descs = si_sampler_descriptors(sctx, shader);

	if (views->views[slot] == view && !disallow_early_out)
d197 5
a201 2
		struct r600_texture *rtex = (struct r600_texture *)view->texture;
		uint32_t *desc = descs->list + slot * 16;
a202 1
		assert(rtex); /* views with texture == NULL aren't supported */
d204 1
a204 21
		memcpy(desc, rview->state, 8*4);

		if (rtex->resource.b.b.target == PIPE_BUFFER) {
			rtex->resource.bind_history |= PIPE_BIND_SAMPLER_VIEW;

			si_set_buf_desc_address(&rtex->resource,
						view->u.buf.offset,
						desc + 4);
		} else {
			bool is_separate_stencil =
				rtex->db_compatible &&
				rview->is_stencil_sampler;

			si_set_mutable_tex_desc_fields(rtex,
						       rview->base_level_info,
						       rview->base_level,
						       rview->base.u.tex.first_level,
						       rview->block_width,
						       is_separate_stencil,
						       desc);
		}
d206 1
a206 1
		if (rtex->resource.b.b.target != PIPE_BUFFER &&
d208 1
a208 1
			memcpy(desc + 8,
d212 2
a213 2
			memcpy(desc + 8,
			       null_texture_descriptor, 4*4);
d216 1
a216 1
				memcpy(desc + 12,
d220 1
a220 7
		views->enabled_mask |= 1u << slot;

		/* Since this can flush, it must be done after enabled_mask is
		 * updated. */
		si_sampler_view_add_buffer(sctx, view->texture,
					   RADEON_USAGE_READ,
					   rview->is_stencil_sampler, true);
d223 1
a223 1
		memcpy(descs->list + slot*16, null_texture_descriptor, 8*4);
d225 2
a226 2
		memcpy(descs->list + slot*16 + 8, null_texture_descriptor, 4*4);
		views->enabled_mask &= ~(1u << slot);
d229 1
a229 8
	descs->dirty_mask |= 1u << slot;
	sctx->descriptors_dirty |= 1u << si_sampler_descriptors_idx(shader);
}

static bool is_compressed_colortex(struct r600_texture *rtex)
{
	return rtex->cmask.size || rtex->fmask.size ||
	       (rtex->dcc_offset && rtex->dirty_level_mask);
d233 1
a233 1
				 enum pipe_shader_type shader, unsigned start,
d248 3
a250 3
			samplers->depth_texture_mask &= ~(1u << slot);
			samplers->compressed_colortex_mask &= ~(1u << slot);
			si_set_sampler_view(sctx, shader, slot, NULL, false);
d254 1
a254 1
		si_set_sampler_view(sctx, shader, slot, views[i], false);
a258 1
			struct si_sampler_view *rview = (struct si_sampler_view *)views[i];
d260 2
a261 3
			if (rtex->db_compatible &&
			    (!rtex->tc_compatible_htile || rview->is_stencil_sampler)) {
				samplers->depth_texture_mask |= 1u << slot;
d263 1
a263 1
				samplers->depth_texture_mask &= ~(1u << slot);
d265 3
a267 2
			if (is_compressed_colortex(rtex)) {
				samplers->compressed_colortex_mask |= 1u << slot;
d269 1
a269 1
				samplers->compressed_colortex_mask &= ~(1u << slot);
a270 165

			if (rtex->dcc_offset &&
			    p_atomic_read(&rtex->framebuffers_bound))
				sctx->need_check_render_feedback = true;
		} else {
			samplers->depth_texture_mask &= ~(1u << slot);
			samplers->compressed_colortex_mask &= ~(1u << slot);
		}
	}
}

static void
si_samplers_update_compressed_colortex_mask(struct si_textures_info *samplers)
{
	unsigned mask = samplers->views.enabled_mask;

	while (mask) {
		int i = u_bit_scan(&mask);
		struct pipe_resource *res = samplers->views.views[i]->texture;

		if (res && res->target != PIPE_BUFFER) {
			struct r600_texture *rtex = (struct r600_texture *)res;

			if (is_compressed_colortex(rtex)) {
				samplers->compressed_colortex_mask |= 1u << i;
			} else {
				samplers->compressed_colortex_mask &= ~(1u << i);
			}
		}
	}
}

/* IMAGE VIEWS */

static unsigned
si_image_descriptors_idx(unsigned shader)
{
	return SI_DESCS_FIRST_SHADER + shader * SI_NUM_SHADER_DESCS +
	       SI_SHADER_DESCS_IMAGES;
}

static struct si_descriptors*
si_image_descriptors(struct si_context *sctx, unsigned shader)
{
	return &sctx->descriptors[si_image_descriptors_idx(shader)];
}

static void
si_release_image_views(struct si_images_info *images)
{
	unsigned i;

	for (i = 0; i < SI_NUM_IMAGES; ++i) {
		struct pipe_image_view *view = &images->views[i];

		pipe_resource_reference(&view->resource, NULL);
	}
}

static void
si_image_views_begin_new_cs(struct si_context *sctx, struct si_images_info *images)
{
	uint mask = images->enabled_mask;

	/* Add buffers to the CS. */
	while (mask) {
		int i = u_bit_scan(&mask);
		struct pipe_image_view *view = &images->views[i];

		assert(view->resource);

		si_sampler_view_add_buffer(sctx, view->resource,
					   RADEON_USAGE_READWRITE, false, false);
	}
}

static void
si_disable_shader_image(struct si_context *ctx, unsigned shader, unsigned slot)
{
	struct si_images_info *images = &ctx->images[shader];

	if (images->enabled_mask & (1u << slot)) {
		struct si_descriptors *descs = si_image_descriptors(ctx, shader);

		pipe_resource_reference(&images->views[slot].resource, NULL);
		images->compressed_colortex_mask &= ~(1 << slot);

		memcpy(descs->list + slot*8, null_image_descriptor, 8*4);
		images->enabled_mask &= ~(1u << slot);
		descs->dirty_mask |= 1u << slot;
		ctx->descriptors_dirty |= 1u << si_image_descriptors_idx(shader);
	}
}

static void
si_mark_image_range_valid(const struct pipe_image_view *view)
{
	struct r600_resource *res = (struct r600_resource *)view->resource;

	assert(res && res->b.b.target == PIPE_BUFFER);

	util_range_add(&res->valid_buffer_range,
		       view->u.buf.offset,
		       view->u.buf.offset + view->u.buf.size);
}

static void si_set_shader_image(struct si_context *ctx,
				unsigned shader,
				unsigned slot, const struct pipe_image_view *view)
{
	struct si_screen *screen = ctx->screen;
	struct si_images_info *images = &ctx->images[shader];
	struct si_descriptors *descs = si_image_descriptors(ctx, shader);
	struct r600_resource *res;
	uint32_t *desc = descs->list + slot * 8;

	if (!view || !view->resource) {
		si_disable_shader_image(ctx, shader, slot);
		return;
	}

	res = (struct r600_resource *)view->resource;

	if (&images->views[slot] != view)
		util_copy_image_view(&images->views[slot], view);

	if (res->b.b.target == PIPE_BUFFER) {
		if (view->access & PIPE_IMAGE_ACCESS_WRITE)
			si_mark_image_range_valid(view);

		si_make_buffer_descriptor(screen, res,
					  view->format,
					  view->u.buf.offset,
					  view->u.buf.size,
					  descs->list + slot * 8);
		si_set_buf_desc_address(res, view->u.buf.offset, desc + 4);

		images->compressed_colortex_mask &= ~(1 << slot);
		res->bind_history |= PIPE_BIND_SHADER_IMAGE;
	} else {
		static const unsigned char swizzle[4] = { 0, 1, 2, 3 };
		struct r600_texture *tex = (struct r600_texture *)res;
		unsigned level = view->u.tex.level;
		unsigned width, height, depth;
		bool uses_dcc = tex->dcc_offset &&
				tex->surface.level[level].dcc_enabled;

		assert(!tex->is_depth);
		assert(tex->fmask.size == 0);

		if (uses_dcc &&
		    (view->access & PIPE_IMAGE_ACCESS_WRITE ||
		     !vi_dcc_formats_compatible(res->b.b.format, view->format))) {
			/* If DCC can't be disabled, at least decompress it.
			 * The decompression is relatively cheap if the surface
			 * has been decompressed already.
			 */
			if (r600_texture_disable_dcc(&ctx->b, tex))
				uses_dcc = false;
			else
				ctx->b.decompress_dcc(&ctx->b.b, tex);
		}

		if (is_compressed_colortex(tex)) {
			images->compressed_colortex_mask |= 1 << slot;
d272 2
a273 82
			images->compressed_colortex_mask &= ~(1 << slot);
		}

		if (uses_dcc &&
		    p_atomic_read(&tex->framebuffers_bound))
			ctx->need_check_render_feedback = true;

		/* Always force the base level to the selected level.
		 *
		 * This is required for 3D textures, where otherwise
		 * selecting a single slice for non-layered bindings
		 * fails. It doesn't hurt the other targets.
		 */
		width = u_minify(res->b.b.width0, level);
		height = u_minify(res->b.b.height0, level);
		depth = u_minify(res->b.b.depth0, level);

		si_make_texture_descriptor(screen, tex,
					   false, res->b.b.target,
					   view->format, swizzle,
					   0, 0,
					   view->u.tex.first_layer,
					   view->u.tex.last_layer,
					   width, height, depth,
					   desc, NULL);
		si_set_mutable_tex_desc_fields(tex, &tex->surface.level[level],
					       level, level,
					       util_format_get_blockwidth(view->format),
					       false, desc);
	}

	images->enabled_mask |= 1u << slot;
	descs->dirty_mask |= 1u << slot;
	ctx->descriptors_dirty |= 1u << si_image_descriptors_idx(shader);

	/* Since this can flush, it must be done after enabled_mask is updated. */
	si_sampler_view_add_buffer(ctx, &res->b.b,
				   RADEON_USAGE_READWRITE, false, true);
}

static void
si_set_shader_images(struct pipe_context *pipe,
		     enum pipe_shader_type shader,
		     unsigned start_slot, unsigned count,
		     const struct pipe_image_view *views)
{
	struct si_context *ctx = (struct si_context *)pipe;
	unsigned i, slot;

	assert(shader < SI_NUM_SHADERS);

	if (!count)
		return;

	assert(start_slot + count <= SI_NUM_IMAGES);

	if (views) {
		for (i = 0, slot = start_slot; i < count; ++i, ++slot)
			si_set_shader_image(ctx, shader, slot, &views[i]);
	} else {
		for (i = 0, slot = start_slot; i < count; ++i, ++slot)
			si_set_shader_image(ctx, shader, slot, NULL);
	}
}

static void
si_images_update_compressed_colortex_mask(struct si_images_info *images)
{
	unsigned mask = images->enabled_mask;

	while (mask) {
		int i = u_bit_scan(&mask);
		struct pipe_resource *res = images->views[i].resource;

		if (res && res->target != PIPE_BUFFER) {
			struct r600_texture *rtex = (struct r600_texture *)res;

			if (is_compressed_colortex(rtex)) {
				images->compressed_colortex_mask |= 1 << i;
			} else {
				images->compressed_colortex_mask &= ~(1 << i);
			}
d280 1
a280 2
static void si_bind_sampler_states(struct pipe_context *ctx,
                                   enum pipe_shader_type shader,
d285 1
a285 1
	struct si_descriptors *desc = si_sampler_descriptors(sctx, shader);
d311 1
a311 2
		desc->dirty_mask |= 1u << slot;
		sctx->descriptors_dirty |= 1u << si_sampler_descriptors_idx(shader);
a317 1
				     struct si_descriptors *descs,
d321 1
a321 2
				     enum radeon_bo_priority priority,
				     unsigned *ce_offset)
d327 2
a328 2
	si_init_descriptors(descs, shader_userdata_index, 4,
			    num_buffers, NULL, ce_offset);
d331 1
a331 2
static void si_release_buffer_resources(struct si_buffer_resources *buffers,
					struct si_descriptors *descs)
d335 1
a335 1
	for (i = 0; i < descs->num_elements; i++) {
d340 1
d346 1
a346 1
	unsigned mask = buffers->enabled_mask;
d350 1
a350 1
		int i = u_bit_scan(&mask);
a355 1
}
d357 5
a361 19
static void si_get_buffer_from_descriptors(struct si_buffer_resources *buffers,
					   struct si_descriptors *descs,
					   unsigned idx, struct pipe_resource **buf,
					   unsigned *offset, unsigned *size)
{
	pipe_resource_reference(buf, buffers->buffers[idx]);
	if (*buf) {
		struct r600_resource *res = r600_resource(*buf);
		const uint32_t *desc = descs->list + idx * 4;
		uint64_t va;

		*size = desc[2];

		assert(G_008F04_STRIDE(desc[1]) == 0);
		va = ((uint64_t)desc[1] << 32) | desc[0];

		assert(va >= res->gpu_address && va + *size <= res->gpu_address + res->bo_size);
		*offset = va - res->gpu_address;
	}
d375 1
a375 1
		if (vb >= ARRAY_SIZE(sctx->vertex_buffer))
d392 1
a392 1
bool si_upload_vertex_buffer_descriptors(struct si_context *sctx)
d427 1
a427 1
		if (ve->vertex_buffer_index >= ARRAY_SIZE(sctx->vertex_buffer)) {
a477 13
static unsigned
si_const_buffer_descriptors_idx(unsigned shader)
{
	return SI_DESCS_FIRST_SHADER + shader * SI_NUM_SHADER_DESCS +
	       SI_SHADER_DESCS_CONST_BUFFERS;
}

static struct si_descriptors *
si_const_buffer_descriptors(struct si_context *sctx, unsigned shader)
{
	return &sctx->descriptors[si_const_buffer_descriptors_idx(shader)];
}

d489 2
a490 4
static void si_set_constant_buffer(struct si_context *sctx,
				   struct si_buffer_resources *buffers,
				   unsigned descriptors_idx,
				   uint slot, const struct pipe_constant_buffer *input)
d492 7
a498 2
	struct si_descriptors *descs = &sctx->descriptors[descriptors_idx];
	assert(slot < descs->num_elements);
d520 1
a520 1
				si_set_constant_buffer(sctx, buffers, descriptors_idx, slot, NULL);
a526 2
			/* Only track usage for non-user buffers. */
			r600_resource(buffer)->bind_history |= PIPE_BIND_CONSTANT_BUFFER;
d530 1
a530 1
		uint32_t *desc = descs->list + slot*4;
d543 4
a546 5
		radeon_add_to_buffer_list_check_mem(&sctx->b, &sctx->b.gfx,
						    (struct r600_resource*)buffer,
						    buffers->shader_usage,
						    buffers->priority, true);
		buffers->enabled_mask |= 1u << slot;
d549 2
a550 108
		memset(descs->list + slot*4, 0, sizeof(uint32_t) * 4);
		buffers->enabled_mask &= ~(1u << slot);
	}

	descs->dirty_mask |= 1u << slot;
	sctx->descriptors_dirty |= 1u << descriptors_idx;
}

void si_set_rw_buffer(struct si_context *sctx,
		      uint slot, const struct pipe_constant_buffer *input)
{
	si_set_constant_buffer(sctx, &sctx->rw_buffers,
			                        SI_DESCS_RW_BUFFERS, slot, input);
}

static void si_pipe_set_constant_buffer(struct pipe_context *ctx,
					uint shader, uint slot,
					const struct pipe_constant_buffer *input)
{
	struct si_context *sctx = (struct si_context *)ctx;

	if (shader >= SI_NUM_SHADERS)
		return;

	si_set_constant_buffer(sctx, &sctx->const_buffers[shader],
			       si_const_buffer_descriptors_idx(shader),
			       slot, input);
}

void si_get_pipe_constant_buffer(struct si_context *sctx, uint shader,
				 uint slot, struct pipe_constant_buffer *cbuf)
{
	cbuf->user_buffer = NULL;
	si_get_buffer_from_descriptors(
		&sctx->const_buffers[shader],
		si_const_buffer_descriptors(sctx, shader),
		slot, &cbuf->buffer, &cbuf->buffer_offset, &cbuf->buffer_size);
}

/* SHADER BUFFERS */

static unsigned
si_shader_buffer_descriptors_idx(enum pipe_shader_type shader)
{
	return SI_DESCS_FIRST_SHADER + shader * SI_NUM_SHADER_DESCS +
	       SI_SHADER_DESCS_SHADER_BUFFERS;
}

static struct si_descriptors *
si_shader_buffer_descriptors(struct si_context *sctx,
				  enum pipe_shader_type shader)
{
	return &sctx->descriptors[si_shader_buffer_descriptors_idx(shader)];
}

static void si_set_shader_buffers(struct pipe_context *ctx,
				  enum pipe_shader_type shader,
				  unsigned start_slot, unsigned count,
				  const struct pipe_shader_buffer *sbuffers)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct si_buffer_resources *buffers = &sctx->shader_buffers[shader];
	struct si_descriptors *descs = si_shader_buffer_descriptors(sctx, shader);
	unsigned i;

	assert(start_slot + count <= SI_NUM_SHADER_BUFFERS);

	for (i = 0; i < count; ++i) {
		const struct pipe_shader_buffer *sbuffer = sbuffers ? &sbuffers[i] : NULL;
		struct r600_resource *buf;
		unsigned slot = start_slot + i;
		uint32_t *desc = descs->list + slot * 4;
		uint64_t va;

		if (!sbuffer || !sbuffer->buffer) {
			pipe_resource_reference(&buffers->buffers[slot], NULL);
			memset(desc, 0, sizeof(uint32_t) * 4);
			buffers->enabled_mask &= ~(1u << slot);
			descs->dirty_mask |= 1u << slot;
			sctx->descriptors_dirty |=
				1u << si_shader_buffer_descriptors_idx(shader);
			continue;
		}

		buf = (struct r600_resource *)sbuffer->buffer;
		va = buf->gpu_address + sbuffer->buffer_offset;

		desc[0] = va;
		desc[1] = S_008F04_BASE_ADDRESS_HI(va >> 32) |
			  S_008F04_STRIDE(0);
		desc[2] = sbuffer->buffer_size;
		desc[3] = S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) |
			  S_008F0C_DST_SEL_Y(V_008F0C_SQ_SEL_Y) |
			  S_008F0C_DST_SEL_Z(V_008F0C_SQ_SEL_Z) |
			  S_008F0C_DST_SEL_W(V_008F0C_SQ_SEL_W) |
			  S_008F0C_NUM_FORMAT(V_008F0C_BUF_NUM_FORMAT_FLOAT) |
			  S_008F0C_DATA_FORMAT(V_008F0C_BUF_DATA_FORMAT_32);

		pipe_resource_reference(&buffers->buffers[slot], &buf->b.b);
		radeon_add_to_buffer_list_check_mem(&sctx->b, &sctx->b.gfx, buf,
						    buffers->shader_usage,
						    buffers->priority, true);
		buf->bind_history |= PIPE_BIND_SHADER_BUFFER;

		buffers->enabled_mask |= 1u << slot;
		descs->dirty_mask |= 1u << slot;
		sctx->descriptors_dirty |=
			1u << si_shader_buffer_descriptors_idx(shader);
a551 1
}
d553 1
a553 13
void si_get_shader_buffers(struct si_context *sctx, uint shader,
			   uint start_slot, uint count,
			   struct pipe_shader_buffer *sbuf)
{
	struct si_buffer_resources *buffers = &sctx->shader_buffers[shader];
	struct si_descriptors *descs = si_shader_buffer_descriptors(sctx, shader);

	for (unsigned i = 0; i < count; ++i) {
		si_get_buffer_from_descriptors(
			buffers, descs, start_slot + i,
			&sbuf[i].buffer, &sbuf[i].buffer_offset,
			&sbuf[i].buffer_size);
	}
d558 1
a558 1
void si_set_ring_buffer(struct pipe_context *ctx, uint slot,
d565 4
a568 2
	struct si_buffer_resources *buffers = &sctx->rw_buffers;
	struct si_descriptors *descs = &sctx->descriptors[SI_DESCS_RW_BUFFERS];
d573 1
a573 1
	assert(slot < descs->num_elements);
d621 1
a621 1
		uint32_t *desc = descs->list + slot*4;
d641 1
a641 1
		buffers->enabled_mask |= 1u << slot;
d644 2
a645 2
		memset(descs->list + slot*4, 0, sizeof(uint32_t) * 4);
		buffers->enabled_mask &= ~(1u << slot);
d648 1
a648 2
	descs->dirty_mask |= 1u << slot;
	sctx->descriptors_dirty |= 1u << SI_DESCS_RW_BUFFERS;
d659 1
a659 2
	struct si_buffer_resources *buffers = &sctx->rw_buffers;
	struct si_descriptors *descs = &sctx->descriptors[SI_DESCS_RW_BUFFERS];
d669 4
a672 4
		 * The only cases which requires flushing it is VGT DMA index
		 * fetching (on <= CIK) and indirect draw data, which are rare
		 * cases. Thus, flag the TC L2 dirtiness in the resource and
		 * handle it at draw call time.
a692 7
	/* All readers of the streamout targets need to be finished before we can
	 * start writing to the targets.
	 */
	if (num_targets)
		sctx->b.flags |= SI_CONTEXT_PS_PARTIAL_FLUSH |
		                 SI_CONTEXT_CS_PARTIAL_FLUSH;

d703 1
a703 1
		bufidx = SI_VS_STREAMOUT_BUF0 + i;
d715 1
a715 1
			uint32_t *desc = descs->list + bufidx*4;
d728 4
a731 8
			radeon_add_to_buffer_list_check_mem(&sctx->b, &sctx->b.gfx,
							    (struct r600_resource*)buffer,
							    buffers->shader_usage,
							    RADEON_PRIO_SHADER_RW_BUFFER,
							    true);
			r600_resource(buffer)->bind_history |= PIPE_BIND_STREAM_OUTPUT;

			buffers->enabled_mask |= 1u << bufidx;
d734 1
a734 1
			memset(descs->list + bufidx*4, 0,
d738 1
a738 1
			buffers->enabled_mask &= ~(1u << bufidx);
a739 1
		descs->dirty_mask |= 1u << bufidx;
d742 1
a742 1
		bufidx = SI_VS_STREAMOUT_BUF0 + i;
d744 1
a744 1
		memset(descs->list + bufidx*4, 0, sizeof(uint32_t) * 4);
d746 1
a746 2
		buffers->enabled_mask &= ~(1u << bufidx);
		descs->dirty_mask |= 1u << bufidx;
d749 1
a749 1
	sctx->descriptors_dirty |= 1u << SI_DESCS_RW_BUFFERS;
d764 1
a764 16
	si_set_buf_desc_address(r600_resource(new_buf), offset_within_buffer,
				desc);
}

/* INTERNAL CONST BUFFERS */

static void si_set_polygon_stipple(struct pipe_context *ctx,
				   const struct pipe_poly_stipple *state)
{
	struct si_context *sctx = (struct si_context *)ctx;
	struct pipe_constant_buffer cb = {};
	unsigned stipple[32];
	int i;

	for (i = 0; i < 32; i++)
		stipple[i] = util_bitreverse(state->stipple[i]);
d766 3
a768 18
	cb.user_buffer = stipple;
	cb.buffer_size = sizeof(stipple);

	si_set_rw_buffer(sctx, SI_PS_CONST_POLY_STIPPLE, &cb);
}

/* TEXTURE METADATA ENABLE/DISABLE */

/* CMASK can be enabled (for fast clear) and disabled (for texture export)
 * while the texture is bound, possibly by a different context. In that case,
 * call this function to update compressed_colortex_masks.
 */
void si_update_compressed_colortex_masks(struct si_context *sctx)
{
	for (int i = 0; i < SI_NUM_SHADERS; ++i) {
		si_samplers_update_compressed_colortex_mask(&sctx->samplers[i]);
		si_images_update_compressed_colortex_mask(&sctx->images[i]);
	}
a772 27
/** Reset descriptors of buffer resources after \p buf has been invalidated. */
static void si_reset_buffer_resources(struct si_context *sctx,
				      struct si_buffer_resources *buffers,
				      unsigned descriptors_idx,
				      struct pipe_resource *buf,
				      uint64_t old_va)
{
	struct si_descriptors *descs = &sctx->descriptors[descriptors_idx];
	unsigned mask = buffers->enabled_mask;

	while (mask) {
		unsigned i = u_bit_scan(&mask);
		if (buffers->buffers[i] == buf) {
			si_desc_reset_buffer_offset(&sctx->b.b,
						    descs->list + i*4,
						    old_va, buf);
			descs->dirty_mask |= 1u << i;
			sctx->descriptors_dirty |= 1u << descriptors_idx;

			radeon_add_to_buffer_list_check_mem(&sctx->b, &sctx->b.gfx,
							    (struct r600_resource *)buf,
							    buffers->shader_usage,
							    buffers->priority, true);
		}
	}
}

d784 1
a784 1
	unsigned i, shader;
d788 1
d791 2
a792 1
	r600_alloc_resource(&sctx->screen->b, rbuffer);
d801 7
a807 15
	if (rbuffer->bind_history & PIPE_BIND_VERTEX_BUFFER) {
		for (i = 0; i < num_elems; i++) {
			int vb = sctx->vertex_elements->elements[i].vertex_buffer_index;

			if (vb >= ARRAY_SIZE(sctx->vertex_buffer))
				continue;
			if (!sctx->vertex_buffer[vb].buffer)
				continue;

			if (sctx->vertex_buffer[vb].buffer == buf) {
				sctx->vertex_buffers_dirty = true;
				break;
			}
		}
	}
d809 3
a811 26
	/* Streamout buffers. (other internal buffers can't be invalidated) */
	if (rbuffer->bind_history & PIPE_BIND_STREAM_OUTPUT) {
		for (i = SI_VS_STREAMOUT_BUF0; i <= SI_VS_STREAMOUT_BUF3; i++) {
			struct si_buffer_resources *buffers = &sctx->rw_buffers;
			struct si_descriptors *descs =
				&sctx->descriptors[SI_DESCS_RW_BUFFERS];

			if (buffers->buffers[i] != buf)
				continue;

			si_desc_reset_buffer_offset(ctx, descs->list + i*4,
						    old_va, buf);
			descs->dirty_mask |= 1u << i;
			sctx->descriptors_dirty |= 1u << SI_DESCS_RW_BUFFERS;

			radeon_add_to_buffer_list_check_mem(&sctx->b, &sctx->b.gfx,
							    rbuffer, buffers->shader_usage,
							    RADEON_PRIO_SHADER_RW_BUFFER,
							    true);

			/* Update the streamout state. */
			if (sctx->b.streamout.begin_emitted)
				r600_emit_streamout_end(&sctx->b);
			sctx->b.streamout.append_bitmask =
					sctx->b.streamout.enabled_mask;
			r600_streamout_buffers_dirty(&sctx->b);
d815 4
a818 42
	/* Constant and shader buffers. */
	if (rbuffer->bind_history & PIPE_BIND_CONSTANT_BUFFER) {
		for (shader = 0; shader < SI_NUM_SHADERS; shader++)
			si_reset_buffer_resources(sctx, &sctx->const_buffers[shader],
						  si_const_buffer_descriptors_idx(shader),
						  buf, old_va);
	}

	if (rbuffer->bind_history & PIPE_BIND_SHADER_BUFFER) {
		for (shader = 0; shader < SI_NUM_SHADERS; shader++)
			si_reset_buffer_resources(sctx, &sctx->shader_buffers[shader],
						  si_shader_buffer_descriptors_idx(shader),
						  buf, old_va);
	}

	if (rbuffer->bind_history & PIPE_BIND_SAMPLER_VIEW) {
		/* Texture buffers - update bindings. */
		for (shader = 0; shader < SI_NUM_SHADERS; shader++) {
			struct si_sampler_views *views = &sctx->samplers[shader].views;
			struct si_descriptors *descs =
				si_sampler_descriptors(sctx, shader);
			unsigned mask = views->enabled_mask;

			while (mask) {
				unsigned i = u_bit_scan(&mask);
				if (views->views[i]->texture == buf) {
					si_desc_reset_buffer_offset(ctx,
								    descs->list +
								    i * 16 + 4,
								    old_va, buf);
					descs->dirty_mask |= 1u << i;
					sctx->descriptors_dirty |=
						1u << si_sampler_descriptors_idx(shader);

					radeon_add_to_buffer_list_check_mem(&sctx->b, &sctx->b.gfx,
									    rbuffer, RADEON_USAGE_READ,
									    RADEON_PRIO_SAMPLER_BUFFER,
									    true);
				}
			}
		}
	}
d820 19
a838 26
	/* Shader images */
	if (rbuffer->bind_history & PIPE_BIND_SHADER_IMAGE) {
		for (shader = 0; shader < SI_NUM_SHADERS; ++shader) {
			struct si_images_info *images = &sctx->images[shader];
			struct si_descriptors *descs =
				si_image_descriptors(sctx, shader);
			unsigned mask = images->enabled_mask;

			while (mask) {
				unsigned i = u_bit_scan(&mask);

				if (images->views[i].resource == buf) {
					if (images->views[i].access & PIPE_IMAGE_ACCESS_WRITE)
						si_mark_image_range_valid(&images->views[i]);

					si_desc_reset_buffer_offset(
						ctx, descs->list + i * 8 + 4,
						old_va, buf);
					descs->dirty_mask |= 1u << i;
					sctx->descriptors_dirty |=
						1u << si_image_descriptors_idx(shader);

					radeon_add_to_buffer_list_check_mem(
						&sctx->b, &sctx->b.gfx, rbuffer,
						RADEON_USAGE_READWRITE,
						RADEON_PRIO_SAMPLER_BUFFER, true);
a842 6
}

/* Update mutable image descriptor fields of all bound textures. */
void si_update_all_texture_descriptors(struct si_context *sctx)
{
	unsigned shader;
d844 1
d846 2
a847 3
		struct si_sampler_views *samplers = &sctx->samplers[shader].views;
		struct si_images_info *images = &sctx->images[shader];
		unsigned mask;
a848 2
		/* Images. */
		mask = images->enabled_mask;
d850 12
a861 2
			unsigned i = u_bit_scan(&mask);
			struct pipe_image_view *view = &images->views[i];
d863 4
a866 5
			if (!view->resource ||
			    view->resource->target == PIPE_BUFFER)
				continue;

			si_set_shader_image(sctx, shader, i, view);
d868 5
a873 2
		/* Sampler views. */
		mask = samplers->enabled_mask;
d875 12
a886 10
			unsigned i = u_bit_scan(&mask);
			struct pipe_sampler_view *view = samplers->views[i];

			if (!view ||
			    !view->texture ||
			    view->texture->target == PIPE_BUFFER)
				continue;

			si_set_sampler_view(sctx, shader, i,
					    samplers->views[i], true);
d896 3
a898 5
	struct si_descriptors *descs =
		&sctx->descriptors[SI_DESCS_FIRST_SHADER + shader * SI_NUM_SHADER_DESCS];

	for (unsigned i = 0; i < SI_NUM_SHADER_DESCS; ++i, ++descs)
		descs->pointer_dirty = true;
a912 1
	sctx->descriptors[SI_DESCS_RW_BUFFERS].pointer_dirty = true;
d984 1
a984 2
void si_emit_graphics_shader_userdata(struct si_context *sctx,
                                      struct r600_atom *atom)
d986 1
a986 1
	unsigned shader;
a987 1
	struct si_descriptors *descs;
d989 16
a1004 6
	descs = &sctx->descriptors[SI_DESCS_RW_BUFFERS];

	if (descs->pointer_dirty) {
		si_emit_shader_pointer(sctx, descs,
				       R_00B030_SPI_SHADER_USER_DATA_PS_0, true);
		si_emit_shader_pointer(sctx, descs,
a1005 7
		si_emit_shader_pointer(sctx, descs,
				       R_00B230_SPI_SHADER_USER_DATA_GS_0, true);
		si_emit_shader_pointer(sctx, descs,
				       R_00B330_SPI_SHADER_USER_DATA_ES_0, true);
		si_emit_shader_pointer(sctx, descs,
				       R_00B430_SPI_SHADER_USER_DATA_HS_0, true);
		descs->pointer_dirty = false;
d1008 2
a1009 5
	descs = &sctx->descriptors[SI_DESCS_FIRST_SHADER];

	for (shader = 0; shader < SI_NUM_GRAPHICS_SHADERS; shader++) {
		unsigned base = sh_base[shader];
		unsigned i;
d1014 5
a1018 2
		for (i = 0; i < SI_NUM_SHADER_DESCS; i++, descs++)
			si_emit_shader_pointer(sctx, descs, base, false);
a1022 9
void si_emit_compute_shader_userdata(struct si_context *sctx)
{
	unsigned base = R_00B900_COMPUTE_USER_DATA_0;
	struct si_descriptors *descs = &sctx->descriptors[SI_DESCS_FIRST_COMPUTE];

	for (unsigned i = 0; i < SI_NUM_SHADER_DESCS; ++i, ++descs)
		si_emit_shader_pointer(sctx, descs, base, false);
}

a1027 1
	unsigned ce_offset = 0;
a1030 1
					 si_const_buffer_descriptors(sctx, i),
d1032 4
a1035 24
					 RADEON_USAGE_READ, RADEON_PRIO_CONST_BUFFER,
					 &ce_offset);
		si_init_buffer_resources(&sctx->shader_buffers[i],
					 si_shader_buffer_descriptors(sctx, i),
					 SI_NUM_SHADER_BUFFERS, SI_SGPR_SHADER_BUFFERS,
					 RADEON_USAGE_READWRITE, RADEON_PRIO_SHADER_RW_BUFFER,
					 &ce_offset);

		si_init_descriptors(si_sampler_descriptors(sctx, i),
				    SI_SGPR_SAMPLERS, 16, SI_NUM_SAMPLERS,
				    null_texture_descriptor, &ce_offset);

		si_init_descriptors(si_image_descriptors(sctx, i),
				    SI_SGPR_IMAGES, 8, SI_NUM_IMAGES,
				    null_image_descriptor, &ce_offset);
	}

	si_init_buffer_resources(&sctx->rw_buffers,
				 &sctx->descriptors[SI_DESCS_RW_BUFFERS],
				 SI_NUM_RW_BUFFERS, SI_SGPR_RW_BUFFERS,
				 RADEON_USAGE_READWRITE, RADEON_PRIO_SHADER_RINGS,
				 &ce_offset);
	si_init_descriptors(&sctx->vertex_buffers, SI_SGPR_VERTEX_BUFFERS,
			    4, SI_NUM_VERTEX_BUFFERS, NULL, NULL);
d1037 3
a1039 1
	sctx->descriptors_dirty = u_bit_consecutive(0, SI_NUM_DESCS);
d1041 2
a1042 1
	assert(ce_offset <= 32768);
d1046 1
a1046 4
	sctx->b.b.set_shader_images = si_set_shader_images;
	sctx->b.b.set_constant_buffer = si_pipe_set_constant_buffer;
	sctx->b.b.set_polygon_stipple = si_set_polygon_stipple;
	sctx->b.b.set_shader_buffers = si_set_shader_buffers;
d1053 1
a1053 1
		     si_emit_graphics_shader_userdata);
d1062 1
a1062 1
bool si_upload_graphics_shader_descriptors(struct si_context *sctx)
d1064 1
a1064 2
	const unsigned mask = u_bit_consecutive(0, SI_DESCS_FIRST_COMPUTE);
	unsigned dirty = sctx->descriptors_dirty & mask;
d1066 4
a1069 5
	while (dirty) {
		unsigned i = u_bit_scan(&dirty);

		if (!si_upload_descriptors(sctx, &sctx->descriptors[i],
					   &sctx->shader_userdata.atom))
d1072 1
a1072 24

	sctx->descriptors_dirty &= ~mask;
	return true;
}

bool si_upload_compute_shader_descriptors(struct si_context *sctx)
{
	/* Does not update rw_buffers as that is not needed for compute shaders
	 * and the input buffer is using the same SGPR's anyway.
	 */
	const unsigned mask = u_bit_consecutive(SI_DESCS_FIRST_COMPUTE,
						SI_NUM_DESCS - SI_DESCS_FIRST_COMPUTE);
	unsigned dirty = sctx->descriptors_dirty & mask;

	while (dirty) {
		unsigned i = u_bit_scan(&dirty);

		if (!si_upload_descriptors(sctx, &sctx->descriptors[i], NULL))
			return false;
	}

	sctx->descriptors_dirty &= ~mask;

	return true;
d1080 2
a1081 4
		si_release_buffer_resources(&sctx->const_buffers[i],
					    si_const_buffer_descriptors(sctx, i));
		si_release_buffer_resources(&sctx->shader_buffers[i],
					    si_shader_buffer_descriptors(sctx, i));
a1082 1
		si_release_image_views(&sctx->images[i]);
a1083 5
	si_release_buffer_resources(&sctx->rw_buffers,
				    &sctx->descriptors[SI_DESCS_RW_BUFFERS]);

	for (i = 0; i < SI_NUM_DESCS; ++i)
		si_release_descriptors(&sctx->descriptors[i]);
d1093 1
a1093 1
		si_buffer_resources_begin_new_cs(sctx, &sctx->shader_buffers[i]);
a1094 1
		si_image_views_begin_new_cs(sctx, &sctx->images[i]);
a1095 1
	si_buffer_resources_begin_new_cs(sctx, &sctx->rw_buffers);
a1096 4

	for (i = 0; i < SI_NUM_DESCS; ++i)
		si_descriptors_begin_new_cs(sctx, &sctx->descriptors[i]);

@


1.1.1.4
log
@Import Mesa 13.0.3
@
text
@a415 1
	uint32_t *desc = descs->list + slot * 16;
d422 1
d471 1
a471 1
		memcpy(desc, null_texture_descriptor, 8*4);
d473 1
a473 6
		memcpy(desc + 8, null_texture_descriptor, 4*4);
		/* Re-set the sampler state if we are transitioning from FMASK. */
		if (views->sampler_states[slot])
			memcpy(desc + 12,
			       views->sampler_states[slot], 4*4);

d806 4
a809 4
		if (samplers->views.views[slot] &&
		    samplers->views.views[slot]->texture &&
		    samplers->views.views[slot]->texture->target != PIPE_BUFFER &&
		    ((struct r600_texture*)samplers->views.views[slot]->texture)->fmask.size)
@


1.1.1.5
log
@Import Mesa 13.0.5
@
text
@d323 1
a323 1
	/* Now add separate DCC or HTILE. */
d325 2
a326 5
	if (rtex->dcc_separate_buffer) {
		radeon_add_to_buffer_list_check_mem(&sctx->b, &sctx->b.gfx,
						    rtex->dcc_separate_buffer, usage,
						    RADEON_PRIO_DCC, check_mem);
	}
d328 3
a330 7
	if (rtex->htile_buffer &&
	    rtex->tc_compatible_htile &&
	    !is_stencil_sampler) {
		radeon_add_to_buffer_list_check_mem(&sctx->b, &sctx->b.gfx,
						    rtex->htile_buffer, usage,
						    RADEON_PRIO_HTILE, check_mem);
	}
@


1.1.1.6
log
@Import Mesa 13.0.6
@
text
@d647 1
a647 2
				unsigned slot, const struct pipe_image_view *view,
				bool skip_decompress)
d689 1
a689 1
		if (uses_dcc && !skip_decompress &&
d763 1
a763 1
			si_set_shader_image(ctx, shader, slot, &views[i], false);
d766 1
a766 1
			si_set_shader_image(ctx, shader, slot, NULL, false);
a1201 3

		util_range_add(&buf->valid_buffer_range, sbuffer->buffer_offset,
			       sbuffer->buffer_offset + sbuffer->buffer_size);
d1673 1
a1673 1
			si_set_shader_image(sctx, shader, i, view, true);
@


