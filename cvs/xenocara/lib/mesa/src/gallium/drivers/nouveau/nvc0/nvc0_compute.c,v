head	1.1;
branch	1.1.1;
access;
symbols
	mesa-17_1_6:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.45.06;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.45.06;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.20.46;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.30.19;	author jsg;	state Exp;
branches;
next	;
commitid	uuv5VTS15jglEDZU;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright 2013 Nouveau Project
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors: Christoph Bumiller, Samuel Pitoiset
 */

#include "nvc0/nvc0_context.h"
#include "nvc0/nvc0_compute.h"

int
nvc0_screen_compute_setup(struct nvc0_screen *screen,
                          struct nouveau_pushbuf *push)
{
   struct nouveau_object *chan = screen->base.channel;
   struct nouveau_device *dev = screen->base.device;
   uint32_t obj_class;
   int ret;
   int i;

   switch (dev->chipset & ~0xf) {
   case 0xc0:
      if (dev->chipset == 0xc8)
         obj_class = NVC8_COMPUTE_CLASS;
      else
         obj_class = NVC0_COMPUTE_CLASS;
      break;
   case 0xd0:
      obj_class = NVC0_COMPUTE_CLASS;
      break;
   default:
      NOUVEAU_ERR("unsupported chipset: NV%02x\n", dev->chipset);
      return -1;
   }

   ret = nouveau_object_new(chan, 0xbeef90c0, obj_class, NULL, 0,
                            &screen->compute);
   if (ret) {
      NOUVEAU_ERR("Failed to allocate compute object: %d\n", ret);
      return ret;
   }

   ret = nouveau_bo_new(dev, NV_VRAM_DOMAIN(&screen->base), 0, 1 << 12, NULL,
                        &screen->parm);
   if (ret)
      return ret;

   BEGIN_NVC0(push, SUBC_COMPUTE(NV01_SUBCHAN_OBJECT), 1);
   PUSH_DATA (push, screen->compute->oclass);

   /* hardware limit */
   BEGIN_NVC0(push, NVC0_COMPUTE(MP_LIMIT), 1);
   PUSH_DATA (push, screen->mp_count);
   BEGIN_NVC0(push, NVC0_COMPUTE(CALL_LIMIT_LOG), 1);
   PUSH_DATA (push, 0xf);

   BEGIN_NVC0(push, SUBC_COMPUTE(0x02a0), 1);
   PUSH_DATA (push, 0x8000);

   /* global memory setup */
   BEGIN_NVC0(push, SUBC_COMPUTE(0x02c4), 1);
   PUSH_DATA (push, 0);
   BEGIN_NIC0(push, NVC0_COMPUTE(GLOBAL_BASE), 0x100);
   for (i = 0; i <= 0xff; i++)
      PUSH_DATA (push, (0xc << 28) | (i << 16) | i);
   BEGIN_NVC0(push, SUBC_COMPUTE(0x02c4), 1);
   PUSH_DATA (push, 1);

   /* local memory and cstack setup */
   BEGIN_NVC0(push, NVC0_COMPUTE(TEMP_ADDRESS_HIGH), 2);
   PUSH_DATAh(push, screen->tls->offset);
   PUSH_DATA (push, screen->tls->offset);
   BEGIN_NVC0(push, NVC0_COMPUTE(TEMP_SIZE_HIGH), 2);
   PUSH_DATAh(push, screen->tls->size);
   PUSH_DATA (push, screen->tls->size);
   BEGIN_NVC0(push, NVC0_COMPUTE(WARP_TEMP_ALLOC), 1);
   PUSH_DATA (push, 0);
   BEGIN_NVC0(push, NVC0_COMPUTE(LOCAL_BASE), 1);
   PUSH_DATA (push, 1 << 24);

   /* shared memory setup */
   BEGIN_NVC0(push, NVC0_COMPUTE(CACHE_SPLIT), 1);
   PUSH_DATA (push, NVC0_COMPUTE_CACHE_SPLIT_48K_SHARED_16K_L1);
   BEGIN_NVC0(push, NVC0_COMPUTE(SHARED_BASE), 1);
   PUSH_DATA (push, 2 << 24);
   BEGIN_NVC0(push, NVC0_COMPUTE(SHARED_SIZE), 1);
   PUSH_DATA (push, 0);

   /* code segment setup */
   BEGIN_NVC0(push, NVC0_COMPUTE(CODE_ADDRESS_HIGH), 2);
   PUSH_DATAh(push, screen->text->offset);
   PUSH_DATA (push, screen->text->offset);

   /* bind parameters buffer */
   BEGIN_NVC0(push, NVC0_COMPUTE(CB_SIZE), 3);
   PUSH_DATA (push, screen->parm->size);
   PUSH_DATAh(push, screen->parm->offset);
   PUSH_DATA (push, screen->parm->offset);
   BEGIN_NVC0(push, NVC0_COMPUTE(CB_BIND), 1);
   PUSH_DATA (push, (0 << 8) | 1);

   /* TODO: textures & samplers */

   return 0;
}

bool
nvc0_compute_validate_program(struct nvc0_context *nvc0)
{
   struct nvc0_program *prog = nvc0->compprog;

   if (prog->mem)
      return true;

   if (!prog->translated) {
      prog->translated = nvc0_program_translate(
         prog, nvc0->screen->base.device->chipset);
      if (!prog->translated)
         return false;
   }
   if (unlikely(!prog->code_size))
      return false;

   if (likely(prog->code_size)) {
      if (nvc0_program_upload_code(nvc0, prog)) {
         struct nouveau_pushbuf *push = nvc0->base.pushbuf;
         BEGIN_NVC0(push, NVC0_COMPUTE(FLUSH), 1);
         PUSH_DATA (push, NVC0_COMPUTE_FLUSH_CODE);
         return true;
      }
   }
   return false;
}

static bool
nvc0_compute_state_validate(struct nvc0_context *nvc0)
{
   if (!nvc0_compute_validate_program(nvc0))
      return false;

   /* TODO: textures, samplers, surfaces, global memory buffers */

   nvc0_bufctx_fence(nvc0, nvc0->bufctx_cp, false);

   nouveau_pushbuf_bufctx(nvc0->base.pushbuf, nvc0->bufctx_cp);
   if (unlikely(nouveau_pushbuf_validate(nvc0->base.pushbuf)))
      return false;
   if (unlikely(nvc0->state.flushed))
      nvc0_bufctx_fence(nvc0, nvc0->bufctx_cp, true);

   return true;

}

static void
nvc0_compute_upload_input(struct nvc0_context *nvc0, const void *input)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct nvc0_screen *screen = nvc0->screen;
   struct nvc0_program *cp = nvc0->compprog;

   if (cp->parm_size) {
      BEGIN_NVC0(push, NVC0_COMPUTE(CB_SIZE), 3);
      PUSH_DATA (push, align(cp->parm_size, 0x100));
      PUSH_DATAh(push, screen->parm->offset);
      PUSH_DATA (push, screen->parm->offset);
      BEGIN_NVC0(push, NVC0_COMPUTE(CB_BIND), 1);
      PUSH_DATA (push, (0 << 8) | 1);
      /* NOTE: size is limited to 4 KiB, which is < NV04_PFIFO_MAX_PACKET_LEN */
      BEGIN_1IC0(push, NVC0_COMPUTE(CB_POS), 1 + cp->parm_size / 4);
      PUSH_DATA (push, 0);
      PUSH_DATAp(push, input, cp->parm_size / 4);

      BEGIN_NVC0(push, NVC0_COMPUTE(FLUSH), 1);
      PUSH_DATA (push, NVC0_COMPUTE_FLUSH_CB);
   }
}

void
nvc0_launch_grid(struct pipe_context *pipe,
                 const uint *block_layout, const uint *grid_layout,
                 uint32_t label,
                 const void *input)
{
   struct nvc0_context *nvc0 = nvc0_context(pipe);
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct nvc0_program *cp = nvc0->compprog;
   unsigned s, i;
   int ret;

   ret = !nvc0_compute_state_validate(nvc0);
   if (ret)
      goto out;

   nvc0_compute_upload_input(nvc0, input);

   BEGIN_NVC0(push, NVC0_COMPUTE(CP_START_ID), 1);
   PUSH_DATA (push, nvc0_program_symbol_offset(cp, label));

   BEGIN_NVC0(push, NVC0_COMPUTE(LOCAL_POS_ALLOC), 3);
   PUSH_DATA (push, align(cp->cp.lmem_size, 0x10));
   PUSH_DATA (push, 0);
   PUSH_DATA (push, 0x800); /* WARP_CSTACK_SIZE */

   BEGIN_NVC0(push, NVC0_COMPUTE(SHARED_SIZE), 3);
   PUSH_DATA (push, align(cp->cp.smem_size, 0x100));
   PUSH_DATA (push, block_layout[0] * block_layout[1] * block_layout[2]);
   PUSH_DATA (push, cp->num_barriers);
   BEGIN_NVC0(push, NVC0_COMPUTE(CP_GPR_ALLOC), 1);
   PUSH_DATA (push, cp->num_gprs);

   /* grid/block setup */
   BEGIN_NVC0(push, NVC0_COMPUTE(GRIDDIM_YX), 2);
   PUSH_DATA (push, (grid_layout[1] << 16) | grid_layout[0]);
   PUSH_DATA (push, grid_layout[2]);
   BEGIN_NVC0(push, NVC0_COMPUTE(BLOCKDIM_YX), 2);
   PUSH_DATA (push, (block_layout[1] << 16) | block_layout[0]);
   PUSH_DATA (push, block_layout[2]);

   /* launch preliminary setup */
   BEGIN_NVC0(push, NVC0_COMPUTE(GRIDID), 1);
   PUSH_DATA (push, 0x1);
   BEGIN_NVC0(push, SUBC_COMPUTE(0x036c), 1);
   PUSH_DATA (push, 0);
   BEGIN_NVC0(push, NVC0_COMPUTE(FLUSH), 1);
   PUSH_DATA (push, NVC0_COMPUTE_FLUSH_GLOBAL | NVC0_COMPUTE_FLUSH_UNK8);

   /* kernel launching */
   BEGIN_NVC0(push, NVC0_COMPUTE(COMPUTE_BEGIN), 1);
   PUSH_DATA (push, 0);
   BEGIN_NVC0(push, SUBC_COMPUTE(0x0a08), 1);
   PUSH_DATA (push, 0);
   BEGIN_NVC0(push, NVC0_COMPUTE(LAUNCH), 1);
   PUSH_DATA (push, 0x1000);
   BEGIN_NVC0(push, NVC0_COMPUTE(COMPUTE_END), 1);
   PUSH_DATA (push, 0);
   BEGIN_NVC0(push, SUBC_COMPUTE(0x0360), 1);
   PUSH_DATA (push, 0x1);

   /* rebind all the 3D constant buffers
    * (looks like binding a CB on COMPUTE clobbers 3D state) */
   nvc0->dirty |= NVC0_NEW_CONSTBUF;
   for (s = 0; s < 6; s++) {
      for (i = 0; i < NVC0_MAX_PIPE_CONSTBUFS; i++)
         if (nvc0->constbuf[s][i].u.buf)
            nvc0->constbuf_dirty[s] |= 1 << i;
   }
   memset(nvc0->state.uniform_buffer_bound, 0,
          sizeof(nvc0->state.uniform_buffer_bound));

out:
   if (ret)
      NOUVEAU_ERR("Failed to launch grid !\n");
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d40 5
a45 2
      /* In theory, GF110+ should also support NVC8_COMPUTE_CLASS but,
       * in practice, a ILLEGAL_CLASS dmesg fail appears when using it. */
d96 1
a96 1
   PUSH_DATA (push, 0xff << 24);
d102 1
a102 1
   PUSH_DATA (push, 0xfe << 24);
d111 9
a119 11
   /* textures */
   BEGIN_NVC0(push, NVC0_COMPUTE(TIC_ADDRESS_HIGH), 3);
   PUSH_DATAh(push, screen->txc->offset);
   PUSH_DATA (push, screen->txc->offset);
   PUSH_DATA (push, NVC0_TIC_MAX_ENTRIES - 1);

   /* samplers */
   BEGIN_NVC0(push, NVC0_COMPUTE(TSC_ADDRESS_HIGH), 3);
   PUSH_DATAh(push, screen->txc->offset + 65536);
   PUSH_DATA (push, screen->txc->offset + 65536);
   PUSH_DATA (push, NVC0_TSC_MAX_ENTRIES - 1);
d134 1
a134 1
         prog, nvc0->screen->base.device->chipset, &nvc0->base.debug);
a151 126
static void
nvc0_compute_validate_samplers(struct nvc0_context *nvc0)
{
   bool need_flush = nvc0_validate_tsc(nvc0, 5);
   if (need_flush) {
      BEGIN_NVC0(nvc0->base.pushbuf, NVC0_COMPUTE(TSC_FLUSH), 1);
      PUSH_DATA (nvc0->base.pushbuf, 0);
   }
}

static void
nvc0_compute_validate_textures(struct nvc0_context *nvc0)
{
   bool need_flush = nvc0_validate_tic(nvc0, 5);
   if (need_flush) {
      BEGIN_NVC0(nvc0->base.pushbuf, NVC0_COMPUTE(TIC_FLUSH), 1);
      PUSH_DATA (nvc0->base.pushbuf, 0);
   }
}

static void
nvc0_compute_validate_constbufs(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   const int s = 5;

   while (nvc0->constbuf_dirty[s]) {
      int i = ffs(nvc0->constbuf_dirty[s]) - 1;
      nvc0->constbuf_dirty[s] &= ~(1 << i);

      if (nvc0->constbuf[s][i].user) {
         struct nouveau_bo *bo = nvc0->screen->uniform_bo;
         const unsigned base = s << 16;
         const unsigned size = nvc0->constbuf[s][0].size;
         assert(i == 0); /* we really only want OpenGL uniforms here */
         assert(nvc0->constbuf[s][0].u.data);

         if (nvc0->state.uniform_buffer_bound[s] < size) {
            nvc0->state.uniform_buffer_bound[s] = align(size, 0x100);

            BEGIN_NVC0(push, NVC0_COMPUTE(CB_SIZE), 3);
            PUSH_DATA (push, nvc0->state.uniform_buffer_bound[s]);
            PUSH_DATAh(push, bo->offset + base);
            PUSH_DATA (push, bo->offset + base);
            BEGIN_NVC0(push, NVC0_COMPUTE(CB_BIND), 1);
            PUSH_DATA (push, (0 << 8) | 1);
         }
         nvc0_cb_bo_push(&nvc0->base, bo, NV_VRAM_DOMAIN(&nvc0->screen->base),
                         base, nvc0->state.uniform_buffer_bound[s],
                         0, (size + 3) / 4,
                         nvc0->constbuf[s][0].u.data);
      } else {
         struct nv04_resource *res =
            nv04_resource(nvc0->constbuf[s][i].u.buf);
         if (res) {
            BEGIN_NVC0(push, NVC0_COMPUTE(CB_SIZE), 3);
            PUSH_DATA (push, nvc0->constbuf[s][i].size);
            PUSH_DATAh(push, res->address + nvc0->constbuf[s][i].offset);
            PUSH_DATA (push, res->address + nvc0->constbuf[s][i].offset);
            BEGIN_NVC0(push, NVC0_COMPUTE(CB_BIND), 1);
            PUSH_DATA (push, (i << 8) | 1);

            BCTX_REFN(nvc0->bufctx_cp, CP_CB(i), res, RD);

            res->cb_bindings[s] |= 1 << i;
         } else {
            BEGIN_NVC0(push, NVC0_COMPUTE(CB_BIND), 1);
            PUSH_DATA (push, (i << 8) | 0);
         }
         if (i == 0)
            nvc0->state.uniform_buffer_bound[s] = 0;
      }
   }

   BEGIN_NVC0(push, NVC0_COMPUTE(FLUSH), 1);
   PUSH_DATA (push, NVC0_COMPUTE_FLUSH_CB);
}

static void
nvc0_compute_validate_driverconst(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   struct nvc0_screen *screen = nvc0->screen;

   BEGIN_NVC0(push, NVC0_COMPUTE(CB_SIZE), 3);
   PUSH_DATA (push, 1024);
   PUSH_DATAh(push, screen->uniform_bo->offset + (6 << 16) + (5 << 10));
   PUSH_DATA (push, screen->uniform_bo->offset + (6 << 16) + (5 << 10));
   BEGIN_NVC0(push, NVC0_COMPUTE(CB_BIND), 1);
   PUSH_DATA (push, (15 << 8) | 1);

   nvc0->dirty |= NVC0_NEW_DRIVERCONST;
}

static void
nvc0_compute_validate_buffers(struct nvc0_context *nvc0)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   const int s = 5;
   int i;

   BEGIN_NVC0(push, NVC0_COMPUTE(CB_SIZE), 3);
   PUSH_DATA (push, 1024);
   PUSH_DATAh(push, nvc0->screen->uniform_bo->offset + (6 << 16) + (s << 10));
   PUSH_DATA (push, nvc0->screen->uniform_bo->offset + (6 << 16) + (s << 10));
   BEGIN_1IC0(push, NVC0_COMPUTE(CB_POS), 1 + 4 * NVC0_MAX_BUFFERS);
   PUSH_DATA (push, 512);

   for (i = 0; i < NVC0_MAX_BUFFERS; i++) {
      if (nvc0->buffers[s][i].buffer) {
         struct nv04_resource *res =
            nv04_resource(nvc0->buffers[s][i].buffer);
         PUSH_DATA (push, res->address + nvc0->buffers[s][i].buffer_offset);
         PUSH_DATAh(push, res->address + nvc0->buffers[s][i].buffer_offset);
         PUSH_DATA (push, nvc0->buffers[s][i].buffer_size);
         PUSH_DATA (push, 0);
         BCTX_REFN(nvc0->bufctx_cp, CP_BUF, res, RDWR);
      } else {
         PUSH_DATA (push, 0);
         PUSH_DATA (push, 0);
         PUSH_DATA (push, 0);
         PUSH_DATA (push, 0);
      }
   }
}

a156 10
   if (nvc0->dirty_cp & NVC0_NEW_CP_CONSTBUF)
      nvc0_compute_validate_constbufs(nvc0);
   if (nvc0->dirty_cp & NVC0_NEW_CP_DRIVERCONST)
      nvc0_compute_validate_driverconst(nvc0);
   if (nvc0->dirty_cp & NVC0_NEW_CP_BUFFERS)
      nvc0_compute_validate_buffers(nvc0);
   if (nvc0->dirty_cp & NVC0_NEW_CP_TEXTURES)
      nvc0_compute_validate_textures(nvc0);
   if (nvc0->dirty_cp & NVC0_NEW_CP_SAMPLERS)
      nvc0_compute_validate_samplers(nvc0);
d158 1
a158 1
   /* TODO: surfaces, global memory buffers */
d197 4
a200 1
nvc0_launch_grid(struct pipe_context *pipe, const struct pipe_grid_info *info)
d205 1
a205 1
   unsigned s;
d209 2
a210 4
   if (ret) {
      NOUVEAU_ERR("Failed to launch grid !\n");
      return;
   }
d212 1
a212 1
   nvc0_compute_upload_input(nvc0, info->input);
d215 1
a215 1
   PUSH_DATA (push, nvc0_program_symbol_offset(cp, info->pc));
d224 1
a224 1
   PUSH_DATA (push, info->block[0] * info->block[1] * info->block[2]);
d229 8
d245 11
a255 4
   /* block setup */
   BEGIN_NVC0(push, NVC0_COMPUTE(BLOCKDIM_YX), 2);
   PUSH_DATA (push, (info->block[1] << 16) | info->block[0]);
   PUSH_DATA (push, info->block[2]);
d257 7
a263 27
   if (unlikely(info->indirect)) {
      struct nv04_resource *res = nv04_resource(info->indirect);
      uint32_t offset = res->offset + info->indirect_offset;
      unsigned macro = NVC0_COMPUTE_MACRO_LAUNCH_GRID_INDIRECT;

      nouveau_pushbuf_space(push, 16, 0, 1);
      PUSH_REFN(push, res->bo, NOUVEAU_BO_RD | res->domain);
      PUSH_DATA(push, NVC0_FIFO_PKHDR_1I(1, macro, 3));
      nouveau_pushbuf_data(push, res->bo, offset,
                           NVC0_IB_ENTRY_1_NO_PREFETCH | 3 * 4);
   } else {
      /* grid setup */
      BEGIN_NVC0(push, NVC0_COMPUTE(GRIDDIM_YX), 2);
      PUSH_DATA (push, (info->grid[1] << 16) | info->grid[0]);
      PUSH_DATA (push, info->grid[2]);

      /* kernel launching */
      BEGIN_NVC0(push, NVC0_COMPUTE(COMPUTE_BEGIN), 1);
      PUSH_DATA (push, 0);
      BEGIN_NVC0(push, SUBC_COMPUTE(0x0a08), 1);
      PUSH_DATA (push, 0);
      BEGIN_NVC0(push, NVC0_COMPUTE(LAUNCH), 1);
      PUSH_DATA (push, 0x1000);
      BEGIN_NVC0(push, NVC0_COMPUTE(COMPUTE_END), 1);
      PUSH_DATA (push, 0);
      BEGIN_NVC0(push, SUBC_COMPUTE(0x0360), 1);
      PUSH_DATA (push, 0x1);
d265 2
d268 3
a270 6
   /* Invalidate all 3D constbufs because they are aliased with COMPUTE. */
   nvc0->dirty |= NVC0_NEW_CONSTBUF;
   for (s = 0; s < 5; s++) {
      nvc0->constbuf_dirty[s] |= nvc0->constbuf_valid[s];
      nvc0->state.uniform_buffer_bound[s] = 0;
   }
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d26 1
a26 2

#include "nvc0/nvc0_compute.xml.h"
d57 6
a62 1
   BEGIN_NVC0(push, SUBC_CP(NV01_SUBCHAN_OBJECT), 1);
d66 1
a66 1
   BEGIN_NVC0(push, NVC0_CP(MP_LIMIT), 1);
d68 1
a68 1
   BEGIN_NVC0(push, NVC0_CP(CALL_LIMIT_LOG), 1);
d71 1
a71 1
   BEGIN_NVC0(push, SUBC_CP(0x02a0), 1);
d75 1
a75 1
   BEGIN_NVC0(push, SUBC_CP(0x02c4), 1);
d77 1
a77 1
   BEGIN_NIC0(push, NVC0_CP(GLOBAL_BASE), 0x100);
d80 1
a80 1
   BEGIN_NVC0(push, SUBC_CP(0x02c4), 1);
d84 1
a84 1
   BEGIN_NVC0(push, NVC0_CP(TEMP_ADDRESS_HIGH), 2);
d87 1
a87 1
   BEGIN_NVC0(push, NVC0_CP(TEMP_SIZE_HIGH), 2);
d90 1
a90 1
   BEGIN_NVC0(push, NVC0_CP(WARP_TEMP_ALLOC), 1);
d92 1
a92 1
   BEGIN_NVC0(push, NVC0_CP(LOCAL_BASE), 1);
d96 1
a96 1
   BEGIN_NVC0(push, NVC0_CP(CACHE_SPLIT), 1);
d98 1
a98 1
   BEGIN_NVC0(push, NVC0_CP(SHARED_BASE), 1);
d100 1
a100 1
   BEGIN_NVC0(push, NVC0_CP(SHARED_SIZE), 1);
d104 1
a104 1
   BEGIN_NVC0(push, NVC0_CP(CODE_ADDRESS_HIGH), 2);
d109 1
a109 1
   BEGIN_NVC0(push, NVC0_CP(TIC_ADDRESS_HIGH), 3);
d115 1
a115 1
   BEGIN_NVC0(push, NVC0_CP(TSC_ADDRESS_HIGH), 3);
d120 10
a129 23
   /* MS sample coordinate offsets */
   BEGIN_NVC0(push, NVC0_CP(CB_SIZE), 3);
   PUSH_DATA (push, NVC0_CB_AUX_SIZE);
   PUSH_DATAh(push, screen->uniform_bo->offset + NVC0_CB_AUX_INFO(5));
   PUSH_DATA (push, screen->uniform_bo->offset + NVC0_CB_AUX_INFO(5));
   BEGIN_1IC0(push, NVC0_CP(CB_POS), 1 + 2 * 8);
   PUSH_DATA (push, NVC0_CB_AUX_MS_INFO);
   PUSH_DATA (push, 0); /* 0 */
   PUSH_DATA (push, 0);
   PUSH_DATA (push, 1); /* 1 */
   PUSH_DATA (push, 0);
   PUSH_DATA (push, 0); /* 2 */
   PUSH_DATA (push, 1);
   PUSH_DATA (push, 1); /* 3 */
   PUSH_DATA (push, 1);
   PUSH_DATA (push, 2); /* 4 */
   PUSH_DATA (push, 0);
   PUSH_DATA (push, 3); /* 5 */
   PUSH_DATA (push, 0);
   PUSH_DATA (push, 2); /* 6 */
   PUSH_DATA (push, 1);
   PUSH_DATA (push, 3); /* 7 */
   PUSH_DATA (push, 1);
d131 18
a148 1
   return 0;
d156 1
a156 1
      BEGIN_NVC0(nvc0->base.pushbuf, NVC0_CP(TSC_FLUSH), 1);
a158 5

   /* Invalidate all 3D samplers because they are aliased. */
   for (int s = 0; s < 5; s++)
      nvc0->samplers_dirty[s] = ~0;
   nvc0->dirty_3d |= NVC0_NEW_3D_SAMPLERS;
d166 1
a166 1
      BEGIN_NVC0(nvc0->base.pushbuf, NVC0_CP(TIC_FLUSH), 1);
a168 21

   /* Invalidate all 3D textures because they are aliased. */
   for (int s = 0; s < 5; s++) {
      for (int i = 0; i < nvc0->num_textures[s]; i++)
         nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_3D_TEX(s, i));
      nvc0->textures_dirty[s] = ~0;
   }
   nvc0->dirty_3d |= NVC0_NEW_3D_TEXTURES;
}

static inline void
nvc0_compute_invalidate_constbufs(struct nvc0_context *nvc0)
{
   int s;

   /* Invalidate all 3D constbufs because they are aliased with COMPUTE. */
   for (s = 0; s < 5; s++) {
      nvc0->constbuf_dirty[s] |= nvc0->constbuf_valid[s];
      nvc0->state.uniform_buffer_bound[s] = 0;
   }
   nvc0->dirty_3d |= NVC0_NEW_3D_CONSTBUF;
d183 1
a183 1
         const unsigned base = NVC0_CB_USR_INFO(s);
d191 1
a191 1
            BEGIN_NVC0(push, NVC0_CP(CB_SIZE), 3);
d195 1
a195 1
            BEGIN_NVC0(push, NVC0_CP(CB_BIND), 1);
d206 1
a206 1
            BEGIN_NVC0(push, NVC0_CP(CB_SIZE), 3);
d210 1
a210 1
            BEGIN_NVC0(push, NVC0_CP(CB_BIND), 1);
d217 1
a217 1
            BEGIN_NVC0(push, NVC0_CP(CB_BIND), 1);
d225 1
a225 3
   nvc0_compute_invalidate_constbufs(nvc0);

   BEGIN_NVC0(push, NVC0_CP(FLUSH), 1);
d235 5
a239 5
   BEGIN_NVC0(push, NVC0_CP(CB_SIZE), 3);
   PUSH_DATA (push, NVC0_CB_AUX_SIZE);
   PUSH_DATAh(push, screen->uniform_bo->offset + NVC0_CB_AUX_INFO(5));
   PUSH_DATA (push, screen->uniform_bo->offset + NVC0_CB_AUX_INFO(5));
   BEGIN_NVC0(push, NVC0_CP(CB_BIND), 1);
d242 1
a242 1
   nvc0->dirty_3d |= NVC0_NEW_3D_DRIVERCONST;
a248 1
   struct nvc0_screen *screen = nvc0->screen;
d252 6
a257 6
   BEGIN_NVC0(push, NVC0_CP(CB_SIZE), 3);
   PUSH_DATA (push, NVC0_CB_AUX_SIZE);
   PUSH_DATAh(push, screen->uniform_bo->offset + NVC0_CB_AUX_INFO(s));
   PUSH_DATA (push, screen->uniform_bo->offset + NVC0_CB_AUX_INFO(s));
   BEGIN_1IC0(push, NVC0_CP(CB_POS), 1 + 4 * NVC0_MAX_BUFFERS);
   PUSH_DATA (push, NVC0_CB_AUX_BUF_INFO(0));
a267 4
         util_range_add(&res->valid_buffer_range,
                        nvc0->buffers[s][i].buffer_offset,
                        nvc0->buffers[s][i].buffer_offset +
                        nvc0->buffers[s][i].buffer_size);
a276 67
void
nvc0_compute_validate_globals(struct nvc0_context *nvc0)
{
   unsigned i;

   for (i = 0; i < nvc0->global_residents.size / sizeof(struct pipe_resource *);
        ++i) {
      struct pipe_resource *res = *util_dynarray_element(
         &nvc0->global_residents, struct pipe_resource *, i);
      if (res)
         nvc0_add_resident(nvc0->bufctx_cp, NVC0_BIND_CP_GLOBAL,
                           nv04_resource(res), NOUVEAU_BO_RDWR);
   }
}

static inline void
nvc0_compute_invalidate_surfaces(struct nvc0_context *nvc0, const int s)
{
   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
   int i;

   for (i = 0; i < NVC0_MAX_IMAGES; ++i) {
      if (s == 5)
         BEGIN_NVC0(push, NVC0_CP(IMAGE(i)), 6);
      else
         BEGIN_NVC0(push, NVC0_3D(IMAGE(i)), 6);
      PUSH_DATA(push, 0);
      PUSH_DATA(push, 0);
      PUSH_DATA(push, 0);
      PUSH_DATA(push, 0);
      PUSH_DATA(push, 0x14000);
      PUSH_DATA(push, 0);
   }
}

static void
nvc0_compute_validate_surfaces(struct nvc0_context *nvc0)
{
   /* TODO: Invalidating both 3D and CP surfaces before validating surfaces for
    * compute is probably not really necessary, but we didn't find any better
    * solutions for now. This fixes some invalidation issues when compute and
    * fragment shaders are used inside the same context. Anyway, we definitely
    * have invalidation issues between 3D and CP for other resources like SSBO
    * and atomic counters. */
   nvc0_compute_invalidate_surfaces(nvc0, 4);
   nvc0_compute_invalidate_surfaces(nvc0, 5);

   nvc0_validate_suf(nvc0, 5);

   /* Invalidate all FRAGMENT images because they are aliased with COMPUTE. */
   nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_3D_SUF);
   nvc0->dirty_3d |= NVC0_NEW_3D_SURFACES;
   nvc0->images_dirty[4] |= nvc0->images_valid[4];
}

static struct nvc0_state_validate
validate_list_cp[] = {
   { nvc0_compprog_validate,              NVC0_NEW_CP_PROGRAM     },
   { nvc0_compute_validate_constbufs,     NVC0_NEW_CP_CONSTBUF    },
   { nvc0_compute_validate_driverconst,   NVC0_NEW_CP_DRIVERCONST },
   { nvc0_compute_validate_buffers,       NVC0_NEW_CP_BUFFERS     },
   { nvc0_compute_validate_textures,      NVC0_NEW_CP_TEXTURES    },
   { nvc0_compute_validate_samplers,      NVC0_NEW_CP_SAMPLERS    },
   { nvc0_compute_validate_globals,       NVC0_NEW_CP_GLOBALS     },
   { nvc0_compute_validate_surfaces,      NVC0_NEW_CP_SURFACES    },
};

d278 1
a278 1
nvc0_state_validate_cp(struct nvc0_context *nvc0, uint32_t mask)
d280 22
a301 1
   bool ret;
d303 1
a303 3
   ret = nvc0_state_validate(nvc0, mask, validate_list_cp,
                             ARRAY_SIZE(validate_list_cp), &nvc0->dirty_cp,
                             nvc0->bufctx_cp);
a304 3
   if (unlikely(nvc0->state.flushed))
      nvc0_bufctx_fence(nvc0, nvc0->bufctx_cp, true);
   return ret;
d308 1
a308 2
nvc0_compute_upload_input(struct nvc0_context *nvc0,
                          const struct pipe_grid_info *info)
d315 1
a315 4
      struct nouveau_bo *bo = screen->uniform_bo;
      const unsigned base = NVC0_CB_USR_INFO(5);

      BEGIN_NVC0(push, NVC0_CP(CB_SIZE), 3);
d317 3
a319 3
      PUSH_DATAh(push, bo->offset + base);
      PUSH_DATA (push, bo->offset + base);
      BEGIN_NVC0(push, NVC0_CP(CB_BIND), 1);
d322 1
a322 1
      BEGIN_1IC0(push, NVC0_CP(CB_POS), 1 + cp->parm_size / 4);
d324 1
a324 1
      PUSH_DATAp(push, info->input, cp->parm_size / 4);
d326 2
a327 1
      nvc0_compute_invalidate_constbufs(nvc0);
a328 13

   BEGIN_NVC0(push, NVC0_CP(CB_SIZE), 3);
   PUSH_DATA (push, NVC0_CB_AUX_SIZE);
   PUSH_DATAh(push, screen->uniform_bo->offset + NVC0_CB_AUX_INFO(5));
   PUSH_DATA (push, screen->uniform_bo->offset + NVC0_CB_AUX_INFO(5));

   BEGIN_1IC0(push, NVC0_CP(CB_POS), 1 + 1);
   /* (7) as we only upload work_dim on nvc0, the rest uses special regs */
   PUSH_DATA (push, NVC0_CB_AUX_GRID_INFO(7));
   PUSH_DATA (push, info->work_dim);

   BEGIN_NVC0(push, NVC0_CP(FLUSH), 1);
   PUSH_DATA (push, NVC0_COMPUTE_FLUSH_CB);
d337 1
d340 1
a340 1
   ret = !nvc0_state_validate_cp(nvc0, ~0);
d346 1
a346 1
   nvc0_compute_upload_input(nvc0, info);
d348 1
a348 1
   BEGIN_NVC0(push, NVC0_CP(CP_START_ID), 1);
d351 2
a352 2
   BEGIN_NVC0(push, NVC0_CP(LOCAL_POS_ALLOC), 3);
   PUSH_DATA (push, (cp->hdr[1] & 0xfffff0) + align(cp->cp.lmem_size, 0x10));
d356 1
a356 1
   BEGIN_NVC0(push, NVC0_CP(SHARED_SIZE), 3);
d360 1
a360 1
   BEGIN_NVC0(push, NVC0_CP(CP_GPR_ALLOC), 1);
d364 1
a364 1
   BEGIN_NVC0(push, NVC0_CP(GRIDID), 1);
d366 1
a366 1
   BEGIN_NVC0(push, SUBC_CP(0x036c), 1);
d368 1
a368 1
   BEGIN_NVC0(push, NVC0_CP(FLUSH), 1);
d372 1
a372 1
   BEGIN_NVC0(push, NVC0_CP(BLOCKDIM_YX), 2);
d379 1
a379 1
      unsigned macro = NVC0_CP_MACRO_LAUNCH_GRID_INDIRECT;
d388 1
a388 1
      BEGIN_NVC0(push, NVC0_CP(GRIDDIM_YX), 2);
d393 1
a393 1
      BEGIN_NVC0(push, NVC0_CP(COMPUTE_BEGIN), 1);
d395 1
a395 1
      BEGIN_NVC0(push, SUBC_CP(0x0a08), 1);
d397 1
a397 1
      BEGIN_NVC0(push, NVC0_CP(LAUNCH), 1);
d399 1
a399 1
      BEGIN_NVC0(push, NVC0_CP(COMPUTE_END), 1);
d401 1
a401 1
      BEGIN_NVC0(push, SUBC_CP(0x0360), 1);
d405 6
a410 5
   /* TODO: Not sure if this is really necessary. */
   nvc0_compute_invalidate_surfaces(nvc0, 5);
   nouveau_bufctx_reset(nvc0->bufctx_cp, NVC0_BIND_CP_SUF);
   nvc0->dirty_cp |= NVC0_NEW_CP_SURFACES;
   nvc0->images_dirty[5] |= nvc0->images_valid[5];
@


