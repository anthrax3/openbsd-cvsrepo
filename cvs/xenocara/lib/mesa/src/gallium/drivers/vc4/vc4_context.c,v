head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	mesa-17_1_6:1.1.1.4
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.28;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.44.23;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.23;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.19.58;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.27.37;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.08.14.09.32.19;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Copyright Â© 2014 Broadcom
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include <xf86drm.h>
#include <err.h>

#include "pipe/p_defines.h"
#include "util/ralloc.h"
#include "util/u_inlines.h"
#include "util/u_memory.h"
#include "util/u_blitter.h"
#include "util/u_upload_mgr.h"
#include "indices/u_primconvert.h"
#include "pipe/p_screen.h"

#include "vc4_screen.h"
#include "vc4_context.h"
#include "vc4_resource.h"

void
vc4_flush(struct pipe_context *pctx)
{
        struct vc4_context *vc4 = vc4_context(pctx);

        struct hash_entry *entry;
        hash_table_foreach(vc4->jobs, entry) {
                struct vc4_job *job = entry->data;
                vc4_job_submit(vc4, job);
        }
}

static void
vc4_pipe_flush(struct pipe_context *pctx, struct pipe_fence_handle **fence,
               unsigned flags)
{
        struct vc4_context *vc4 = vc4_context(pctx);

        vc4_flush(pctx);

        if (fence) {
                struct pipe_screen *screen = pctx->screen;
                struct vc4_fence *f = vc4_fence_create(vc4->screen,
                                                       vc4->last_emit_seqno);
                screen->fence_reference(screen, fence, NULL);
                *fence = (struct pipe_fence_handle *)f;
        }
}

static void
vc4_invalidate_resource(struct pipe_context *pctx, struct pipe_resource *prsc)
{
        struct vc4_context *vc4 = vc4_context(pctx);
        struct vc4_resource *rsc = vc4_resource(prsc);

        rsc->initialized_buffers = 0;

        struct hash_entry *entry = _mesa_hash_table_search(vc4->write_jobs,
                                                           prsc);
        if (!entry)
                return;

        struct vc4_job *job = entry->data;
        if (job->key.zsbuf && job->key.zsbuf->texture == prsc)
                job->resolve &= ~(PIPE_CLEAR_DEPTH | PIPE_CLEAR_STENCIL);
}

static void
vc4_context_destroy(struct pipe_context *pctx)
{
        struct vc4_context *vc4 = vc4_context(pctx);

        vc4_flush(pctx);

        if (vc4->blitter)
                util_blitter_destroy(vc4->blitter);

        if (vc4->primconvert)
                util_primconvert_destroy(vc4->primconvert);

        if (vc4->uploader)
                u_upload_destroy(vc4->uploader);

        slab_destroy_child(&vc4->transfer_pool);

        pipe_surface_reference(&vc4->framebuffer.cbufs[0], NULL);
        pipe_surface_reference(&vc4->framebuffer.zsbuf, NULL);

        vc4_program_fini(pctx);

        ralloc_free(vc4);
}

struct pipe_context *
vc4_context_create(struct pipe_screen *pscreen, void *priv, unsigned flags)
{
        struct vc4_screen *screen = vc4_screen(pscreen);
        struct vc4_context *vc4;

        /* Prevent dumping of the shaders built during context setup. */
        uint32_t saved_shaderdb_flag = vc4_debug & VC4_DEBUG_SHADERDB;
        vc4_debug &= ~VC4_DEBUG_SHADERDB;

        vc4 = rzalloc(NULL, struct vc4_context);
        if (!vc4)
                return NULL;
        struct pipe_context *pctx = &vc4->base;

        vc4->screen = screen;

        pctx->screen = pscreen;
        pctx->priv = priv;
        pctx->destroy = vc4_context_destroy;
        pctx->flush = vc4_pipe_flush;
        pctx->invalidate_resource = vc4_invalidate_resource;

        vc4_draw_init(pctx);
        vc4_state_init(pctx);
        vc4_program_init(pctx);
        vc4_query_init(pctx);
        vc4_resource_context_init(pctx);

        vc4_job_init(vc4);

        vc4->fd = screen->fd;

        slab_create_child(&vc4->transfer_pool, &screen->transfer_pool);
        vc4->blitter = util_blitter_create(pctx);
        if (!vc4->blitter)
                goto fail;

        vc4->primconvert = util_primconvert_create(pctx,
                                                   (1 << PIPE_PRIM_QUADS) - 1);
        if (!vc4->primconvert)
                goto fail;

        vc4->uploader = u_upload_create(pctx, 16 * 1024,
                                        PIPE_BIND_INDEX_BUFFER,
                                        PIPE_USAGE_STREAM);

        vc4_debug |= saved_shaderdb_flag;

        vc4->sample_mask = (1 << VC4_MAX_SAMPLES) - 1;

        return &vc4->base;

fail:
        pctx->destroy(pctx);
        return NULL;
}
@


1.1
log
@Initial revision
@
text
@a43 2
        struct pipe_surface *cbuf = vc4->framebuffer.cbufs[0];
        struct pipe_surface *zsbuf = vc4->framebuffer.zsbuf;
d45 4
a48 47
        if (!vc4->needs_flush)
                return;

        /* The RCL setup would choke if the draw bounds cause no drawing, so
         * just drop the drawing if that's the case.
         */
        if (vc4->draw_max_x <= vc4->draw_min_x ||
            vc4->draw_max_y <= vc4->draw_min_y) {
                vc4_job_reset(vc4);
                return;
        }

        /* Increment the semaphore indicating that binning is done and
         * unblocking the render thread.  Note that this doesn't act until the
         * FLUSH completes.
         */
        cl_ensure_space(&vc4->bcl, 8);
        struct vc4_cl_out *bcl = cl_start(&vc4->bcl);
        cl_u8(&bcl, VC4_PACKET_INCREMENT_SEMAPHORE);
        /* The FLUSH caps all of our bin lists with a VC4_PACKET_RETURN. */
        cl_u8(&bcl, VC4_PACKET_FLUSH);
        cl_end(&vc4->bcl, bcl);

        if (cbuf && (vc4->resolve & PIPE_CLEAR_COLOR0)) {
                pipe_surface_reference(&vc4->color_write, cbuf);
                if (!(vc4->cleared & PIPE_CLEAR_COLOR0)) {
                        pipe_surface_reference(&vc4->color_read, cbuf);
                } else {
                        pipe_surface_reference(&vc4->color_read, NULL);
                }

        } else {
                pipe_surface_reference(&vc4->color_write, NULL);
                pipe_surface_reference(&vc4->color_read, NULL);
        }

        if (vc4->framebuffer.zsbuf &&
            (vc4->resolve & (PIPE_CLEAR_DEPTH | PIPE_CLEAR_STENCIL))) {
                pipe_surface_reference(&vc4->zs_write, zsbuf);
                if (!(vc4->cleared & (PIPE_CLEAR_DEPTH | PIPE_CLEAR_STENCIL))) {
                        pipe_surface_reference(&vc4->zs_read, zsbuf);
                } else {
                        pipe_surface_reference(&vc4->zs_read, NULL);
                }
        } else {
                pipe_surface_reference(&vc4->zs_write, NULL);
                pipe_surface_reference(&vc4->zs_read, NULL);
a49 2

        vc4_job_submit(vc4);
d69 2
a70 7
/**
 * Flushes the current command lists if they reference the given BO.
 *
 * This helps avoid flushing the command buffers when unnecessary.
 */
bool
vc4_cl_references_bo(struct pipe_context *pctx, struct vc4_bo *bo)
d73 1
d75 1
a75 2
        if (!vc4->needs_flush)
                return false;
d77 4
a80 29
        /* Walk all the referenced BOs in the drawing command list to see if
         * they match.
         */
        struct vc4_bo **referenced_bos = vc4->bo_pointers.base;
        for (int i = 0; i < cl_offset(&vc4->bo_handles) / 4; i++) {
                if (referenced_bos[i] == bo) {
                        return true;
                }
        }

        /* Also check for the Z/color buffers, since the references to those
         * are only added immediately before submit.
         */
        struct vc4_surface *csurf = vc4_surface(vc4->framebuffer.cbufs[0]);
        if (csurf) {
                struct vc4_resource *ctex = vc4_resource(csurf->base.texture);
                if (ctex->bo == bo) {
                        return true;
                }
        }

        struct vc4_surface *zsurf = vc4_surface(vc4->framebuffer.zsbuf);
        if (zsurf) {
                struct vc4_resource *ztex =
                        vc4_resource(zsurf->base.texture);
                if (ztex->bo == bo) {
                        return true;
                }
        }
d82 3
a84 1
        return false;
d88 1
a88 1
vc4_invalidate_resource(struct pipe_context *pctx, struct pipe_resource *prsc)
a90 1
        struct pipe_surface *zsurf = vc4->framebuffer.zsbuf;
d92 1
a92 8
        if (zsurf && zsurf->texture == prsc)
                vc4->resolve &= ~(PIPE_CLEAR_DEPTH | PIPE_CLEAR_STENCIL);
}

static void
vc4_context_destroy(struct pipe_context *pctx)
{
        struct vc4_context *vc4 = vc4_context(pctx);
d103 1
a103 1
        util_slab_destroy(&vc4->transfer_pool);
d114 1
a114 1
vc4_context_create(struct pipe_screen *pscreen, void *priv)
d124 1
a124 1
        if (vc4 == NULL)
d146 1
a146 2
        util_slab_create(&vc4->transfer_pool, sizeof(struct vc4_transfer),
                         16, UTIL_SLAB_SINGLETHREADED);
d156 3
a158 2
        vc4->uploader = u_upload_create(pctx, 16 * 1024, 4,
                                        PIPE_BIND_INDEX_BUFFER);
d161 2
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d71 1
a71 7
                pipe_surface_reference(&vc4->color_write,
                                       cbuf->texture->nr_samples > 1 ?
                                       NULL : cbuf);
                pipe_surface_reference(&vc4->msaa_color_write,
                                       cbuf->texture->nr_samples > 1 ?
                                       cbuf : NULL);

a80 1
                pipe_surface_reference(&vc4->msaa_color_write, NULL);
d85 1
a85 7
                pipe_surface_reference(&vc4->zs_write,
                                       zsbuf->texture->nr_samples > 1 ?
                                       NULL : zsbuf);
                pipe_surface_reference(&vc4->msaa_zs_write,
                                       zsbuf->texture->nr_samples > 1 ?
                                       zsbuf : NULL);

a93 1
                pipe_surface_reference(&vc4->msaa_zs_write, NULL);
a190 3
        pipe_surface_reference(&vc4->color_write, NULL);
        pipe_surface_reference(&vc4->color_read, NULL);

d197 1
a197 1
vc4_context_create(struct pipe_screen *pscreen, void *priv, unsigned flags)
d207 1
a207 1
        if (!vc4)
d240 2
a241 3
        vc4->uploader = u_upload_create(pctx, 16 * 1024,
                                        PIPE_BIND_INDEX_BUFFER,
                                        PIPE_USAGE_STREAM);
a243 2

        vc4->sample_mask = (1 << VC4_MAX_SAMPLES) - 1;
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d44 2
d47 61
a107 4
        struct hash_entry *entry;
        hash_table_foreach(vc4->jobs, entry) {
                struct vc4_job *job = entry->data;
                vc4_job_submit(vc4, job);
d109 2
d130 46
d180 1
a180 1
        struct vc4_resource *rsc = vc4_resource(prsc);
d182 2
a183 10
        rsc->initialized_buffers = 0;

        struct hash_entry *entry = _mesa_hash_table_search(vc4->write_jobs,
                                                           prsc);
        if (!entry)
                return;

        struct vc4_job *job = entry->data;
        if (job->key.zsbuf && job->key.zsbuf->texture == prsc)
                job->resolve &= ~(PIPE_CLEAR_DEPTH | PIPE_CLEAR_STENCIL);
a190 2
        vc4_flush(pctx);

d200 1
a200 1
        slab_destroy_child(&vc4->transfer_pool);
d205 3
d246 2
a247 1
        slab_create_child(&vc4->transfer_pool, &screen->transfer_pool);
@


1.1.1.4
log
@Import Mesa 17.1.6
@
text
@d147 1
a147 6

	vc4->uploader = u_upload_create_default(&vc4->base);
	vc4->base.stream_uploader = vc4->uploader;
	vc4->base.const_uploader = vc4->uploader;

	vc4->blitter = util_blitter_create(pctx);
d155 4
@


