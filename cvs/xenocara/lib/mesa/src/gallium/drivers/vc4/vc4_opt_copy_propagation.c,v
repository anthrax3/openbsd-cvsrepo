head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	mesa-17_1_6:1.1.1.4
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.28;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.44.24;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.44.24;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.19.59;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.27.37;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.08.14.09.32.18;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Copyright Â© 2014 Broadcom
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

/**
 * @@file vc4_opt_copy_propagation.c
 *
 * This implements simple copy propagation for QIR without control flow.
 *
 * For each temp, it keeps a qreg of which source it was MOVed from, if it
 * was.  If we see that used later, we can just reuse the source value, since
 * we know we don't have control flow, and we have SSA for our values so
 * there's no killing to worry about.
 */

#include "vc4_qir.h"

static bool
is_copy_mov(struct qinst *inst)
{
        if (!inst)
                return false;

        if (inst->op != QOP_MOV &&
            inst->op != QOP_FMOV &&
            inst->op != QOP_MMOV) {
                return false;
        }

        if (inst->dst.file != QFILE_TEMP)
                return false;

        if (inst->src[0].file != QFILE_TEMP &&
            inst->src[0].file != QFILE_UNIF) {
                return false;
        }

        if (inst->dst.pack || inst->cond != QPU_COND_ALWAYS)
                return false;

        return true;

}

static bool
try_copy_prop(struct vc4_compile *c, struct qinst *inst, struct qinst **movs)
{
        bool debug = false;
        bool progress = false;

	for (int i = 0; i < qir_get_op_nsrc(inst->op); i++) {
                if (inst->src[i].file != QFILE_TEMP)
                        continue;

                /* We have two ways of finding MOVs we can copy propagate
                 * from.  One is if it's an SSA def: then we can reuse it from
                 * any block in the program, as long as its source is also an
                 * SSA def.  Alternatively, if it's in the "movs" array
                 * tracked within the block, then we know the sources for it
                 * haven't been changed since we saw the instruction within
                 * our block.
                 */
                struct qinst *mov = movs[inst->src[i].index];
                if (!mov) {
                        if (!is_copy_mov(c->defs[inst->src[i].index]))
                                continue;
                        mov = c->defs[inst->src[i].index];

                        if (mov->src[0].file == QFILE_TEMP &&
                            !c->defs[mov->src[0].index])
                                continue;
                }

                /* Mul rotation's source needs to be in an r0-r3 accumulator,
                 * so no uniforms or regfile-a/r4 unpacking allowed.
                 */
                if (inst->op == QOP_ROT_MUL &&
                    (mov->src[0].file != QFILE_TEMP ||
                     mov->src[0].pack))
                        continue;

                uint8_t unpack;
                if (mov->src[0].pack) {
                        /* Make sure that the meaning of the unpack
                         * would be the same between the two
                         * instructions.
                         */
                        if (qir_is_float_input(inst) !=
                            qir_is_float_input(mov)) {
                                continue;
                        }

                        /* There's only one unpack field, so make sure
                         * this instruction doesn't already use it.
                         */
                        bool already_has_unpack = false;
                        for (int j = 0; j < qir_get_op_nsrc(inst->op); j++) {
                                if (inst->src[j].pack)
                                        already_has_unpack = true;
                        }
                        if (already_has_unpack)
                                continue;

                        /* A destination pack requires the PM bit to
                         * be set to a specific value already, which
                         * may be different from ours.
                         */
                        if (inst->dst.pack)
                                continue;

                        unpack = mov->src[0].pack;
                } else {
                        unpack = inst->src[i].pack;
                }

                if (debug) {
                        fprintf(stderr, "Copy propagate: ");
                        qir_dump_inst(c, inst);
                        fprintf(stderr, "\n");
                }

                inst->src[i] = mov->src[0];
                inst->src[i].pack = unpack;

                if (debug) {
                        fprintf(stderr, "to: ");
                        qir_dump_inst(c, inst);
                        fprintf(stderr, "\n");
                }

                progress = true;
        }

        return progress;
}

static void
apply_kills(struct vc4_compile *c, struct qinst **movs, struct qinst *inst)
{
        if (inst->dst.file != QFILE_TEMP)
                return;

        for (int i = 0; i < c->num_temps; i++) {
                if (movs[i] &&
                    (movs[i]->dst.index == inst->dst.index ||
                     (movs[i]->src[0].file == QFILE_TEMP &&
                      movs[i]->src[0].index == inst->dst.index))) {
                        movs[i] = NULL;
                }
        }
}

bool
qir_opt_copy_propagation(struct vc4_compile *c)
{
        bool progress = false;
        struct qinst **movs;

        movs = ralloc_array(c, struct qinst *, c->num_temps);
        if (!movs)
                return false;

        qir_for_each_block(block, c) {
                /* The MOVs array tracks only available movs within the
                 * block.
                 */
                memset(movs, 0, sizeof(struct qinst *) * c->num_temps);

                qir_for_each_inst(inst, block) {
                        progress = try_copy_prop(c, inst, movs) || progress;

                        apply_kills(c, movs, inst);

                        if (is_copy_mov(inst))
                                movs[inst->dst.index] = inst;
                }
        }

        ralloc_free(movs);

        return progress;
}
@


1.1
log
@Initial revision
@
text
@d37 135
d176 14
a189 1
        bool debug = false;
d191 1
a191 26
        list_for_each_entry(struct qinst, inst, &c->instructions, link) {
                for (int i = 0; i < qir_get_op_nsrc(inst->op); i++) {
                        int index = inst->src[i].index;
                        if (inst->src[i].file == QFILE_TEMP &&
                            c->defs[index] &&
                            c->defs[index]->op == QOP_MOV &&
                            (c->defs[index]->src[0].file == QFILE_TEMP ||
                             c->defs[index]->src[0].file == QFILE_UNIF)) {
                                /* If it has a pack, it shouldn't be an SSA
                                 * def.
                                 */
                                assert(!c->defs[index]->dst.pack);

                                if (debug) {
                                        fprintf(stderr, "Copy propagate: ");
                                        qir_dump_inst(c, inst);
                                        fprintf(stderr, "\n");
                                }

                                inst->src[i] = c->defs[index]->src[0];

                                if (debug) {
                                        fprintf(stderr, "to: ");
                                        qir_dump_inst(c, inst);
                                        fprintf(stderr, "\n");
                                }
d193 2
a194 2
                                progress = true;
                        }
d197 3
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d44 9
a52 26
                int nsrc = qir_get_op_nsrc(inst->op);
                for (int i = 0; i < nsrc; i++) {
                        if (inst->src[i].file != QFILE_TEMP)
                                continue;

                        struct qinst *mov = c->defs[inst->src[i].index];
                        if (!mov ||
                            (mov->op != QOP_MOV &&
                             mov->op != QOP_FMOV &&
                             mov->op != QOP_MMOV)) {
                                continue;
                        }

                        if (mov->src[0].file != QFILE_TEMP &&
                            mov->src[0].file != QFILE_UNIF) {
                                continue;
                        }

                        if (mov->dst.pack)
                                continue;

                        uint8_t unpack;
                        if (mov->src[0].pack) {
                                /* Make sure that the meaning of the unpack
                                 * would be the same between the two
                                 * instructions.
d54 1
a54 4
                                if (qir_is_float_input(inst) !=
                                    qir_is_float_input(mov)) {
                                        continue;
                                }
d56 4
a59 7
                                /* There's only one unpack field, so make sure
                                 * this instruction doesn't already use it.
                                 */
                                bool already_has_unpack = false;
                                for (int j = 0; j < nsrc; j++) {
                                        if (inst->src[j].pack)
                                                already_has_unpack = true;
a60 2
                                if (already_has_unpack)
                                        continue;
d62 1
a62 6
                                /* A destination pack requires the PM bit to
                                 * be set to a specific value already, which
                                 * may be different from ours.
                                 */
                                if (inst->dst.pack)
                                        continue;
d64 5
a68 4
                                unpack = mov->src[0].pack;
                        } else {
                                unpack = inst->src[i].pack;
                        }
d70 1
a70 4
                        if (debug) {
                                fprintf(stderr, "Copy propagate: ");
                                qir_dump_inst(c, inst);
                                fprintf(stderr, "\n");
a71 11

                        inst->src[i] = mov->src[0];
                        inst->src[i].pack = unpack;

                        if (debug) {
                                fprintf(stderr, "to: ");
                                qir_dump_inst(c, inst);
                                fprintf(stderr, "\n");
                        }

                        progress = true;
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d37 2
a38 29
static bool
is_copy_mov(struct qinst *inst)
{
        if (!inst)
                return false;

        if (inst->op != QOP_MOV &&
            inst->op != QOP_FMOV &&
            inst->op != QOP_MMOV) {
                return false;
        }

        if (inst->dst.file != QFILE_TEMP)
                return false;

        if (inst->src[0].file != QFILE_TEMP &&
            inst->src[0].file != QFILE_UNIF) {
                return false;
        }

        if (inst->dst.pack || inst->cond != QPU_COND_ALWAYS)
                return false;

        return true;

}

static bool
try_copy_prop(struct vc4_compile *c, struct qinst *inst, struct qinst **movs)
d40 1
a41 1
        bool progress = false;
d43 4
a46 15
	for (int i = 0; i < qir_get_op_nsrc(inst->op); i++) {
                if (inst->src[i].file != QFILE_TEMP)
                        continue;

                /* We have two ways of finding MOVs we can copy propagate
                 * from.  One is if it's an SSA def: then we can reuse it from
                 * any block in the program, as long as its source is also an
                 * SSA def.  Alternatively, if it's in the "movs" array
                 * tracked within the block, then we know the sources for it
                 * haven't been changed since we saw the instruction within
                 * our block.
                 */
                struct qinst *mov = movs[inst->src[i].index];
                if (!mov) {
                        if (!is_copy_mov(c->defs[inst->src[i].index]))
a47 1
                        mov = c->defs[inst->src[i].index];
d49 5
a53 2
                        if (mov->src[0].file == QFILE_TEMP &&
                            !c->defs[mov->src[0].index])
d55 1
a55 1
                }
d57 2
a58 16
                /* Mul rotation's source needs to be in an r0-r3 accumulator,
                 * so no uniforms or regfile-a/r4 unpacking allowed.
                 */
                if (inst->op == QOP_ROT_MUL &&
                    (mov->src[0].file != QFILE_TEMP ||
                     mov->src[0].pack))
                        continue;

                uint8_t unpack;
                if (mov->src[0].pack) {
                        /* Make sure that the meaning of the unpack
                         * would be the same between the two
                         * instructions.
                         */
                        if (qir_is_float_input(inst) !=
                            qir_is_float_input(mov)) {
d62 1
a62 9
                        /* There's only one unpack field, so make sure
                         * this instruction doesn't already use it.
                         */
                        bool already_has_unpack = false;
                        for (int j = 0; j < qir_get_op_nsrc(inst->op); j++) {
                                if (inst->src[j].pack)
                                        already_has_unpack = true;
                        }
                        if (already_has_unpack)
d65 33
a97 6
                        /* A destination pack requires the PM bit to
                         * be set to a specific value already, which
                         * may be different from ours.
                         */
                        if (inst->dst.pack)
                                continue;
d99 5
a103 10
                        unpack = mov->src[0].pack;
                } else {
                        unpack = inst->src[i].pack;
                }

                if (debug) {
                        fprintf(stderr, "Copy propagate: ");
                        qir_dump_inst(c, inst);
                        fprintf(stderr, "\n");
                }
d105 2
a106 2
                inst->src[i] = mov->src[0];
                inst->src[i].pack = unpack;
d108 5
a112 27
                if (debug) {
                        fprintf(stderr, "to: ");
                        qir_dump_inst(c, inst);
                        fprintf(stderr, "\n");
                }

                progress = true;
        }

        return progress;
}

static void
apply_kills(struct vc4_compile *c, struct qinst **movs, struct qinst *inst)
{
        if (inst->dst.file != QFILE_TEMP)
                return;

        for (int i = 0; i < c->num_temps; i++) {
                if (movs[i] &&
                    (movs[i]->dst.index == inst->dst.index ||
                     (movs[i]->src[0].file == QFILE_TEMP &&
                      movs[i]->src[0].index == inst->dst.index))) {
                        movs[i] = NULL;
                }
        }
}
d114 1
a114 23
bool
qir_opt_copy_propagation(struct vc4_compile *c)
{
        bool progress = false;
        struct qinst **movs;

        movs = ralloc_array(c, struct qinst *, c->num_temps);
        if (!movs)
                return false;

        qir_for_each_block(block, c) {
                /* The MOVs array tracks only available movs within the
                 * block.
                 */
                memset(movs, 0, sizeof(struct qinst *) * c->num_temps);

                qir_for_each_inst(inst, block) {
                        progress = try_copy_prop(c, inst, movs) || progress;

                        apply_kills(c, movs, inst);

                        if (is_copy_mov(inst))
                                movs[inst->dst.index] = inst;
a116 3

        ralloc_free(movs);

@


1.1.1.4
log
@Import Mesa 17.1.6
@
text
@d70 1
a70 1
	for (int i = 0; i < qir_get_nsrc(inst); i++) {
d116 1
a116 1
                        for (int j = 0; j < qir_get_nsrc(inst); j++) {
@


