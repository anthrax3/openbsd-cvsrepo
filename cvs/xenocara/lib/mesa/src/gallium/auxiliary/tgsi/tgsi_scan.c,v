head	1.2;
access;
symbols
	mesa-17_1_6:1.1.1.5
	OPENBSD_6_1:1.1.1.4.0.2
	OPENBSD_6_1_BASE:1.1.1.4
	mesa-13_0_6:1.1.1.4
	mesa-13_0_5:1.1.1.4
	mesa-13_0_3:1.1.1.4
	mesa-13_0_2:1.1.1.4
	OPENBSD_6_0:1.1.1.3.0.4
	OPENBSD_6_0_BASE:1.1.1.3
	mesa-11_2_2:1.1.1.3
	OPENBSD_5_9:1.1.1.2.0.2
	OPENBSD_5_9_BASE:1.1.1.2
	mesa-11_0_9:1.1.1.2
	mesa-11_0_8:1.1.1.2
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.23;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.42.33;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.42.33;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2015.12.23.13.24.34;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	bCnCUEGWDw3j16Q3;

1.1.1.3
date	2016.05.29.10.18.05;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.4
date	2016.12.11.08.31.45;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	uuv5VTS15jglEDZU;

1.1.1.5
date	2017.08.14.09.36.23;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/**************************************************************************
 * 
 * Copyright 2008 VMware, Inc.
 * All Rights Reserved.
 * Copyright 2008 VMware, Inc.  All rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * TGSI program scan utility.
 * Used to determine which registers and instructions are used by a shader.
 *
 * Authors:  Brian Paul
 */


#include "util/u_debug.h"
#include "util/u_math.h"
#include "util/u_memory.h"
#include "util/u_prim.h"
#include "tgsi/tgsi_info.h"
#include "tgsi/tgsi_parse.h"
#include "tgsi/tgsi_util.h"
#include "tgsi/tgsi_scan.h"


static bool
is_memory_file(unsigned file)
{
   return file == TGSI_FILE_SAMPLER ||
          file == TGSI_FILE_SAMPLER_VIEW ||
          file == TGSI_FILE_IMAGE ||
          file == TGSI_FILE_BUFFER;
}


/**
 * Is the opcode a "true" texture instruction which samples from a
 * texture map?
 */
static bool
is_texture_inst(unsigned opcode)
{
   return (opcode != TGSI_OPCODE_TXQ &&
           opcode != TGSI_OPCODE_TXQS &&
           opcode != TGSI_OPCODE_TXQ_LZ &&
           opcode != TGSI_OPCODE_LODQ &&
           tgsi_get_opcode_info(opcode)->is_tex);
}


/**
 * Is the opcode an instruction which computes a derivative explicitly or
 * implicitly?
 */
static bool
computes_derivative(unsigned opcode)
{
   if (tgsi_get_opcode_info(opcode)->is_tex) {
      return opcode != TGSI_OPCODE_TG4 &&
             opcode != TGSI_OPCODE_TXD &&
             opcode != TGSI_OPCODE_TXF &&
             opcode != TGSI_OPCODE_TXL &&
             opcode != TGSI_OPCODE_TXL2 &&
             opcode != TGSI_OPCODE_TXQ &&
             opcode != TGSI_OPCODE_TXQ_LZ &&
             opcode != TGSI_OPCODE_TXQS;
   }

   return opcode == TGSI_OPCODE_DDX || opcode == TGSI_OPCODE_DDX_FINE ||
          opcode == TGSI_OPCODE_DDY || opcode == TGSI_OPCODE_DDY_FINE ||
          opcode == TGSI_OPCODE_SAMPLE ||
          opcode == TGSI_OPCODE_SAMPLE_B ||
          opcode == TGSI_OPCODE_SAMPLE_C;
}


static void
scan_instruction(struct tgsi_shader_info *info,
                 const struct tgsi_full_instruction *fullinst,
                 unsigned *current_depth)
{
   unsigned i;
   bool is_mem_inst = false;
   bool is_interp_instruction = false;

   assert(fullinst->Instruction.Opcode < TGSI_OPCODE_LAST);
   info->opcode_count[fullinst->Instruction.Opcode]++;

   switch (fullinst->Instruction.Opcode) {
   case TGSI_OPCODE_IF:
   case TGSI_OPCODE_UIF:
   case TGSI_OPCODE_BGNLOOP:
      (*current_depth)++;
      info->max_depth = MAX2(info->max_depth, *current_depth);
      break;
   case TGSI_OPCODE_ENDIF:
   case TGSI_OPCODE_ENDLOOP:
      (*current_depth)--;
      break;
   default:
      break;
   }

   if (fullinst->Instruction.Opcode == TGSI_OPCODE_INTERP_CENTROID ||
       fullinst->Instruction.Opcode == TGSI_OPCODE_INTERP_OFFSET ||
       fullinst->Instruction.Opcode == TGSI_OPCODE_INTERP_SAMPLE) {
      const struct tgsi_full_src_register *src0 = &fullinst->Src[0];
      unsigned input;

      is_interp_instruction = true;

      if (src0->Register.Indirect && src0->Indirect.ArrayID)
         input = info->input_array_first[src0->Indirect.ArrayID];
      else
         input = src0->Register.Index;

      /* For the INTERP opcodes, the interpolation is always
       * PERSPECTIVE unless LINEAR is specified.
       */
      switch (info->input_interpolate[input]) {
      case TGSI_INTERPOLATE_COLOR:
      case TGSI_INTERPOLATE_CONSTANT:
      case TGSI_INTERPOLATE_PERSPECTIVE:
         switch (fullinst->Instruction.Opcode) {
         case TGSI_OPCODE_INTERP_CENTROID:
            info->uses_persp_opcode_interp_centroid = TRUE;
            break;
         case TGSI_OPCODE_INTERP_OFFSET:
            info->uses_persp_opcode_interp_offset = TRUE;
            break;
         case TGSI_OPCODE_INTERP_SAMPLE:
            info->uses_persp_opcode_interp_sample = TRUE;
            break;
         }
         break;

      case TGSI_INTERPOLATE_LINEAR:
         switch (fullinst->Instruction.Opcode) {
         case TGSI_OPCODE_INTERP_CENTROID:
            info->uses_linear_opcode_interp_centroid = TRUE;
            break;
         case TGSI_OPCODE_INTERP_OFFSET:
            info->uses_linear_opcode_interp_offset = TRUE;
            break;
         case TGSI_OPCODE_INTERP_SAMPLE:
            info->uses_linear_opcode_interp_sample = TRUE;
            break;
         }
         break;
      }
   }

   if (fullinst->Instruction.Opcode >= TGSI_OPCODE_F2D &&
       fullinst->Instruction.Opcode <= TGSI_OPCODE_DSSG)
      info->uses_doubles = TRUE;

   for (i = 0; i < fullinst->Instruction.NumSrcRegs; i++) {
      const struct tgsi_full_src_register *src = &fullinst->Src[i];
      int ind = src->Register.Index;

      /* Mark which inputs are effectively used */
      if (src->Register.File == TGSI_FILE_INPUT) {
         unsigned usage_mask;
         usage_mask = tgsi_util_get_inst_usage_mask(fullinst, i);
         if (src->Register.Indirect) {
            for (ind = 0; ind < info->num_inputs; ++ind) {
               info->input_usage_mask[ind] |= usage_mask;
            }
         } else {
            assert(ind >= 0);
            assert(ind < PIPE_MAX_SHADER_INPUTS);
            info->input_usage_mask[ind] |= usage_mask;
         }

         if (info->processor == PIPE_SHADER_FRAGMENT) {
            unsigned name, index, input;

            if (src->Register.Indirect && src->Indirect.ArrayID)
               input = info->input_array_first[src->Indirect.ArrayID];
            else
               input = src->Register.Index;

            name = info->input_semantic_name[input];
            index = info->input_semantic_index[input];

            if (name == TGSI_SEMANTIC_POSITION &&
                (src->Register.SwizzleX == TGSI_SWIZZLE_Z ||
                 src->Register.SwizzleY == TGSI_SWIZZLE_Z ||
                 src->Register.SwizzleZ == TGSI_SWIZZLE_Z ||
                 src->Register.SwizzleW == TGSI_SWIZZLE_Z))
               info->reads_z = TRUE;

            if (name == TGSI_SEMANTIC_COLOR) {
               unsigned mask =
                  (1 << src->Register.SwizzleX) |
                  (1 << src->Register.SwizzleY) |
                  (1 << src->Register.SwizzleZ) |
                  (1 << src->Register.SwizzleW);

               info->colors_read |= mask << (index * 4);
            }

            /* Process only interpolated varyings. Don't include POSITION.
             * Don't include integer varyings, because they are not
             * interpolated. Don't process inputs interpolated by INTERP
             * opcodes. Those are tracked separately.
             */
            if ((!is_interp_instruction || i != 0) &&
                (name == TGSI_SEMANTIC_GENERIC ||
                 name == TGSI_SEMANTIC_TEXCOORD ||
                 name == TGSI_SEMANTIC_COLOR ||
                 name == TGSI_SEMANTIC_BCOLOR ||
                 name == TGSI_SEMANTIC_FOG ||
                 name == TGSI_SEMANTIC_CLIPDIST)) {
               switch (info->input_interpolate[input]) {
               case TGSI_INTERPOLATE_COLOR:
               case TGSI_INTERPOLATE_PERSPECTIVE:
                  switch (info->input_interpolate_loc[input]) {
                  case TGSI_INTERPOLATE_LOC_CENTER:
                     info->uses_persp_center = TRUE;
                     break;
                  case TGSI_INTERPOLATE_LOC_CENTROID:
                     info->uses_persp_centroid = TRUE;
                     break;
                  case TGSI_INTERPOLATE_LOC_SAMPLE:
                     info->uses_persp_sample = TRUE;
                     break;
                  }
                  break;
               case TGSI_INTERPOLATE_LINEAR:
                  switch (info->input_interpolate_loc[input]) {
                  case TGSI_INTERPOLATE_LOC_CENTER:
                     info->uses_linear_center = TRUE;
                     break;
                  case TGSI_INTERPOLATE_LOC_CENTROID:
                     info->uses_linear_centroid = TRUE;
                     break;
                  case TGSI_INTERPOLATE_LOC_SAMPLE:
                     info->uses_linear_sample = TRUE;
                     break;
                  }
                  break;
                  /* TGSI_INTERPOLATE_CONSTANT doesn't do any interpolation. */
               }
            }
         }
      }

      /* check for indirect register reads */
      if (src->Register.Indirect) {
         info->indirect_files |= (1 << src->Register.File);
         info->indirect_files_read |= (1 << src->Register.File);
      }

      /* Texture samplers */
      if (src->Register.File == TGSI_FILE_SAMPLER) {
         const unsigned index = src->Register.Index;

         assert(fullinst->Instruction.Texture);
         assert(index < ARRAY_SIZE(info->is_msaa_sampler));
         assert(index < PIPE_MAX_SAMPLERS);

         if (is_texture_inst(fullinst->Instruction.Opcode)) {
            const unsigned target = fullinst->Texture.Texture;
            assert(target < TGSI_TEXTURE_UNKNOWN);
            /* for texture instructions, check that the texture instruction
             * target matches the previous sampler view declaration (if there
             * was one.)
             */
            if (info->sampler_targets[index] == TGSI_TEXTURE_UNKNOWN) {
               /* probably no sampler view declaration */
               info->sampler_targets[index] = target;
            } else {
               /* Make sure the texture instruction's sampler/target info
                * agrees with the sampler view declaration.
                */
               assert(info->sampler_targets[index] == target);
            }
            /* MSAA samplers */
            if (target == TGSI_TEXTURE_2D_MSAA ||
                target == TGSI_TEXTURE_2D_ARRAY_MSAA) {
               info->is_msaa_sampler[src->Register.Index] = TRUE;
            }
         }
      }

      if (is_memory_file(src->Register.File)) {
         is_mem_inst = true;

         if (tgsi_get_opcode_info(fullinst->Instruction.Opcode)->is_store) {
            info->writes_memory = TRUE;

            if (src->Register.File == TGSI_FILE_IMAGE &&
                !src->Register.Indirect)
               info->images_writemask |= 1 << src->Register.Index;
         }
      }
   }

   /* check for indirect register writes */
   for (i = 0; i < fullinst->Instruction.NumDstRegs; i++) {
      const struct tgsi_full_dst_register *dst = &fullinst->Dst[i];
      if (dst->Register.Indirect) {
         info->indirect_files |= (1 << dst->Register.File);
         info->indirect_files_written |= (1 << dst->Register.File);
      }

      if (is_memory_file(dst->Register.File)) {
         assert(fullinst->Instruction.Opcode == TGSI_OPCODE_STORE);

         is_mem_inst = true;
         info->writes_memory = TRUE;

         if (dst->Register.File == TGSI_FILE_IMAGE &&
             !dst->Register.Indirect)
            info->images_writemask |= 1 << dst->Register.Index;
      }
   }

   if (is_mem_inst)
      info->num_memory_instructions++;

   if (computes_derivative(fullinst->Instruction.Opcode))
      info->uses_derivatives = true;

   info->num_instructions++;
}
     

static void
scan_declaration(struct tgsi_shader_info *info,
                 const struct tgsi_full_declaration *fulldecl)
{
   const uint file = fulldecl->Declaration.File;
   const unsigned procType = info->processor;
   uint reg;

   if (fulldecl->Declaration.Array) {
      unsigned array_id = fulldecl->Array.ArrayID;

      switch (file) {
      case TGSI_FILE_INPUT:
         assert(array_id < ARRAY_SIZE(info->input_array_first));
         info->input_array_first[array_id] = fulldecl->Range.First;
         info->input_array_last[array_id] = fulldecl->Range.Last;
         break;
      case TGSI_FILE_OUTPUT:
         assert(array_id < ARRAY_SIZE(info->output_array_first));
         info->output_array_first[array_id] = fulldecl->Range.First;
         info->output_array_last[array_id] = fulldecl->Range.Last;
         break;
      }
      info->array_max[file] = MAX2(info->array_max[file], array_id);
   }

   for (reg = fulldecl->Range.First; reg <= fulldecl->Range.Last; reg++) {
      unsigned semName = fulldecl->Semantic.Name;
      unsigned semIndex = fulldecl->Semantic.Index +
         (reg - fulldecl->Range.First);

      /* only first 32 regs will appear in this bitfield */
      info->file_mask[file] |= (1 << reg);
      info->file_count[file]++;
      info->file_max[file] = MAX2(info->file_max[file], (int)reg);

      if (file == TGSI_FILE_CONSTANT) {
         int buffer = 0;

         if (fulldecl->Declaration.Dimension)
            buffer = fulldecl->Dim.Index2D;

         info->const_file_max[buffer] =
            MAX2(info->const_file_max[buffer], (int)reg);
      }
      else if (file == TGSI_FILE_INPUT) {
         info->input_semantic_name[reg] = (ubyte) semName;
         info->input_semantic_index[reg] = (ubyte) semIndex;
         info->input_interpolate[reg] = (ubyte)fulldecl->Interp.Interpolate;
         info->input_interpolate_loc[reg] = (ubyte)fulldecl->Interp.Location;
         info->input_cylindrical_wrap[reg] = (ubyte)fulldecl->Interp.CylindricalWrap;

         /* Vertex shaders can have inputs with holes between them. */
         info->num_inputs = MAX2(info->num_inputs, reg + 1);

         if (semName == TGSI_SEMANTIC_PRIMID)
            info->uses_primid = TRUE;
         else if (procType == PIPE_SHADER_FRAGMENT) {
            if (semName == TGSI_SEMANTIC_POSITION)
               info->reads_position = TRUE;
            else if (semName == TGSI_SEMANTIC_FACE)
               info->uses_frontface = TRUE;
         }
      }
      else if (file == TGSI_FILE_SYSTEM_VALUE) {
         unsigned index = fulldecl->Range.First;

         info->system_value_semantic_name[index] = semName;
         info->num_system_values = MAX2(info->num_system_values, index + 1);

         switch (semName) {
         case TGSI_SEMANTIC_INSTANCEID:
            info->uses_instanceid = TRUE;
            break;
         case TGSI_SEMANTIC_VERTEXID:
            info->uses_vertexid = TRUE;
            break;
         case TGSI_SEMANTIC_VERTEXID_NOBASE:
            info->uses_vertexid_nobase = TRUE;
            break;
         case TGSI_SEMANTIC_BASEVERTEX:
            info->uses_basevertex = TRUE;
            break;
         case TGSI_SEMANTIC_PRIMID:
            info->uses_primid = TRUE;
            break;
         case TGSI_SEMANTIC_INVOCATIONID:
            info->uses_invocationid = TRUE;
            break;
         case TGSI_SEMANTIC_POSITION:
            info->reads_position = TRUE;
            break;
         case TGSI_SEMANTIC_FACE:
            info->uses_frontface = TRUE;
            break;
         case TGSI_SEMANTIC_SAMPLEMASK:
            info->reads_samplemask = TRUE;
            break;
         }
      }
      else if (file == TGSI_FILE_OUTPUT) {
         info->output_semantic_name[reg] = (ubyte) semName;
         info->output_semantic_index[reg] = (ubyte) semIndex;
         info->num_outputs = MAX2(info->num_outputs, reg + 1);

         if (semName == TGSI_SEMANTIC_COLOR)
            info->colors_written |= 1 << semIndex;

         if (procType == PIPE_SHADER_VERTEX ||
             procType == PIPE_SHADER_GEOMETRY ||
             procType == PIPE_SHADER_TESS_CTRL ||
             procType == PIPE_SHADER_TESS_EVAL) {
            switch (semName) {
            case TGSI_SEMANTIC_VIEWPORT_INDEX:
               info->writes_viewport_index = TRUE;
               break;
            case TGSI_SEMANTIC_LAYER:
               info->writes_layer = TRUE;
               break;
            case TGSI_SEMANTIC_PSIZE:
               info->writes_psize = TRUE;
               break;
            case TGSI_SEMANTIC_CLIPVERTEX:
               info->writes_clipvertex = TRUE;
               break;
            }
         }

         if (procType == PIPE_SHADER_FRAGMENT) {
            switch (semName) {
            case TGSI_SEMANTIC_POSITION:
               info->writes_z = TRUE;
               break;
            case TGSI_SEMANTIC_STENCIL:
               info->writes_stencil = TRUE;
               break;
            case TGSI_SEMANTIC_SAMPLEMASK:
               info->writes_samplemask = TRUE;
               break;
            }
         }

         if (procType == PIPE_SHADER_VERTEX) {
            if (semName == TGSI_SEMANTIC_EDGEFLAG) {
               info->writes_edgeflag = TRUE;
            }
         }
      } else if (file == TGSI_FILE_SAMPLER) {
         STATIC_ASSERT(sizeof(info->samplers_declared) * 8 >= PIPE_MAX_SAMPLERS);
         info->samplers_declared |= 1u << reg;
      } else if (file == TGSI_FILE_SAMPLER_VIEW) {
         unsigned target = fulldecl->SamplerView.Resource;
         unsigned type = fulldecl->SamplerView.ReturnTypeX;

         assert(target < TGSI_TEXTURE_UNKNOWN);
         if (info->sampler_targets[reg] == TGSI_TEXTURE_UNKNOWN) {
            /* Save sampler target for this sampler index */
            info->sampler_targets[reg] = target;
            info->sampler_type[reg] = type;
         } else {
            /* if previously declared, make sure targets agree */
            assert(info->sampler_targets[reg] == target);
            assert(info->sampler_type[reg] == type);
         }
      } else if (file == TGSI_FILE_IMAGE) {
         if (fulldecl->Image.Resource == TGSI_TEXTURE_BUFFER)
            info->images_buffers |= 1 << reg;
      }
   }
}


static void
scan_immediate(struct tgsi_shader_info *info)
{
   uint reg = info->immediate_count++;
   uint file = TGSI_FILE_IMMEDIATE;

   info->file_mask[file] |= (1 << reg);
   info->file_count[file]++;
   info->file_max[file] = MAX2(info->file_max[file], (int)reg);
}


static void
scan_property(struct tgsi_shader_info *info,
              const struct tgsi_full_property *fullprop)
{
   unsigned name = fullprop->Property.PropertyName;
   unsigned value = fullprop->u[0].Data;

   assert(name < ARRAY_SIZE(info->properties));
   info->properties[name] = value;

   switch (name) {
   case TGSI_PROPERTY_NUM_CLIPDIST_ENABLED:
      info->num_written_clipdistance = value;
      info->clipdist_writemask |= (1 << value) - 1;
      break;
   case TGSI_PROPERTY_NUM_CULLDIST_ENABLED:
      info->num_written_culldistance = value;
      info->culldist_writemask |= (1 << value) - 1;
      break;
   }
}


/**
 * Scan the given TGSI shader to collect information such as number of
 * registers used, special instructions used, etc.
 * \return info  the result of the scan
 */
void
tgsi_scan_shader(const struct tgsi_token *tokens,
                 struct tgsi_shader_info *info)
{
   uint procType, i;
   struct tgsi_parse_context parse;
   unsigned current_depth = 0;

   memset(info, 0, sizeof(*info));
   for (i = 0; i < TGSI_FILE_COUNT; i++)
      info->file_max[i] = -1;
   for (i = 0; i < ARRAY_SIZE(info->const_file_max); i++)
      info->const_file_max[i] = -1;
   info->properties[TGSI_PROPERTY_GS_INVOCATIONS] = 1;
   for (i = 0; i < ARRAY_SIZE(info->sampler_targets); i++)
      info->sampler_targets[i] = TGSI_TEXTURE_UNKNOWN;

   /**
    ** Setup to begin parsing input shader
    **/
   if (tgsi_parse_init( &parse, tokens ) != TGSI_PARSE_OK) {
      debug_printf("tgsi_parse_init() failed in tgsi_scan_shader()!\n");
      return;
   }
   procType = parse.FullHeader.Processor.Processor;
   assert(procType == PIPE_SHADER_FRAGMENT ||
          procType == PIPE_SHADER_VERTEX ||
          procType == PIPE_SHADER_GEOMETRY ||
          procType == PIPE_SHADER_TESS_CTRL ||
          procType == PIPE_SHADER_TESS_EVAL ||
          procType == PIPE_SHADER_COMPUTE);
   info->processor = procType;

   /**
    ** Loop over incoming program tokens/instructions
    */
   while (!tgsi_parse_end_of_tokens(&parse)) {
      info->num_tokens++;

      tgsi_parse_token( &parse );

      switch( parse.FullToken.Token.Type ) {
      case TGSI_TOKEN_TYPE_INSTRUCTION:
         scan_instruction(info, &parse.FullToken.FullInstruction,
                          &current_depth);
         break;
      case TGSI_TOKEN_TYPE_DECLARATION:
         scan_declaration(info, &parse.FullToken.FullDeclaration);
         break;
      case TGSI_TOKEN_TYPE_IMMEDIATE:
         scan_immediate(info);
         break;
      case TGSI_TOKEN_TYPE_PROPERTY:
         scan_property(info, &parse.FullToken.FullProperty);
         break;
      default:
         assert(!"Unexpected TGSI token type");
      }
   }

   info->uses_kill = (info->opcode_count[TGSI_OPCODE_KILL_IF] ||
                      info->opcode_count[TGSI_OPCODE_KILL]);

   /* The dimensions of the IN decleration in geometry shader have
    * to be deduced from the type of the input primitive.
    */
   if (procType == PIPE_SHADER_GEOMETRY) {
      unsigned input_primitive =
            info->properties[TGSI_PROPERTY_GS_INPUT_PRIM];
      int num_verts = u_vertices_per_prim(input_primitive);
      int j;
      info->file_count[TGSI_FILE_INPUT] = num_verts;
      info->file_max[TGSI_FILE_INPUT] =
            MAX2(info->file_max[TGSI_FILE_INPUT], num_verts - 1);
      for (j = 0; j < num_verts; ++j) {
         info->file_mask[TGSI_FILE_INPUT] |= (1 << j);
      }
   }

   tgsi_parse_free(&parse);
}

/**
 * Collect information about the arrays of a given register file.
 *
 * @@param tokens TGSI shader
 * @@param file the register file to scan through
 * @@param max_array_id number of entries in @@p arrays; should be equal to the
 *                     highest array id, i.e. tgsi_shader_info::array_max[file].
 * @@param arrays info for array of each ID will be written to arrays[ID - 1].
 */
void
tgsi_scan_arrays(const struct tgsi_token *tokens,
                 unsigned file,
                 unsigned max_array_id,
                 struct tgsi_array_info *arrays)
{
   struct tgsi_parse_context parse;

   if (tgsi_parse_init(&parse, tokens) != TGSI_PARSE_OK) {
      debug_printf("tgsi_parse_init() failed in tgsi_scan_arrays()!\n");
      return;
   }

   memset(arrays, 0, sizeof(arrays[0]) * max_array_id);

   while (!tgsi_parse_end_of_tokens(&parse)) {
      struct tgsi_full_instruction *inst;

      tgsi_parse_token(&parse);

      if (parse.FullToken.Token.Type == TGSI_TOKEN_TYPE_DECLARATION) {
         struct tgsi_full_declaration *decl = &parse.FullToken.FullDeclaration;

         if (decl->Declaration.Array && decl->Declaration.File == file &&
             decl->Array.ArrayID > 0 && decl->Array.ArrayID <= max_array_id) {
            struct tgsi_array_info *array = &arrays[decl->Array.ArrayID - 1];
            assert(!array->declared);
            array->declared = true;
            array->range = decl->Range;
         }
      }

      if (parse.FullToken.Token.Type != TGSI_TOKEN_TYPE_INSTRUCTION)
         continue;

      inst = &parse.FullToken.FullInstruction;
      for (unsigned i = 0; i < inst->Instruction.NumDstRegs; i++) {
         const struct tgsi_full_dst_register *dst = &inst->Dst[i];
         if (dst->Register.File != file)
            continue;

         if (dst->Register.Indirect) {
            if (dst->Indirect.ArrayID > 0 &&
                dst->Indirect.ArrayID <= max_array_id) {
               arrays[dst->Indirect.ArrayID - 1].writemask |= dst->Register.WriteMask;
            } else {
               /* Indirect writes without an ArrayID can write anywhere. */
               for (unsigned j = 0; j < max_array_id; ++j)
                  arrays[j].writemask |= dst->Register.WriteMask;
            }
         } else {
            /* Check whether the write falls into any of the arrays anyway. */
            for (unsigned j = 0; j < max_array_id; ++j) {
               struct tgsi_array_info *array = &arrays[j];
               if (array->declared &&
                   dst->Register.Index >= array->range.First &&
                   dst->Register.Index <= array->range.Last)
                  array->writemask |= dst->Register.WriteMask;
            }
         }
      }
   }

   tgsi_parse_free(&parse);

   return;
}


/**
 * Check if the given shader is a "passthrough" shader consisting of only
 * MOV instructions of the form:  MOV OUT[n], IN[n]
 *  
 */
boolean
tgsi_is_passthrough_shader(const struct tgsi_token *tokens)
{
   struct tgsi_parse_context parse;

   /**
    ** Setup to begin parsing input shader
    **/
   if (tgsi_parse_init(&parse, tokens) != TGSI_PARSE_OK) {
      debug_printf("tgsi_parse_init() failed in tgsi_is_passthrough_shader()!\n");
      return FALSE;
   }

   /**
    ** Loop over incoming program tokens/instructions
    */
   while (!tgsi_parse_end_of_tokens(&parse)) {

      tgsi_parse_token(&parse);

      switch (parse.FullToken.Token.Type) {
      case TGSI_TOKEN_TYPE_INSTRUCTION:
         {
            struct tgsi_full_instruction *fullinst =
               &parse.FullToken.FullInstruction;
            const struct tgsi_full_src_register *src =
               &fullinst->Src[0];
            const struct tgsi_full_dst_register *dst =
               &fullinst->Dst[0];

            /* Do a whole bunch of checks for a simple move */
            if (fullinst->Instruction.Opcode != TGSI_OPCODE_MOV ||
                (src->Register.File != TGSI_FILE_INPUT &&
                 src->Register.File != TGSI_FILE_SYSTEM_VALUE) ||
                dst->Register.File != TGSI_FILE_OUTPUT ||
                src->Register.Index != dst->Register.Index ||

                src->Register.Negate ||
                src->Register.Absolute ||

                src->Register.SwizzleX != TGSI_SWIZZLE_X ||
                src->Register.SwizzleY != TGSI_SWIZZLE_Y ||
                src->Register.SwizzleZ != TGSI_SWIZZLE_Z ||
                src->Register.SwizzleW != TGSI_SWIZZLE_W ||

                dst->Register.WriteMask != TGSI_WRITEMASK_XYZW)
            {
               tgsi_parse_free(&parse);
               return FALSE;
            }
         }
         break;

      case TGSI_TOKEN_TYPE_DECLARATION:
         /* fall-through */
      case TGSI_TOKEN_TYPE_IMMEDIATE:
         /* fall-through */
      case TGSI_TOKEN_TYPE_PROPERTY:
         /* fall-through */
      default:
         ; /* no-op */
      }
   }

   tgsi_parse_free(&parse);

   /* if we get here, it's a pass-through shader */
   return TRUE;
}
@


1.1
log
@Initial revision
@
text
@d41 1
d47 509
d569 1
d574 1
a574 1
   for (i = 0; i < Elements(info->const_file_max); i++)
d577 2
d588 6
a593 6
   assert(procType == TGSI_PROCESSOR_FRAGMENT ||
          procType == TGSI_PROCESSOR_VERTEX ||
          procType == TGSI_PROCESSOR_GEOMETRY ||
          procType == TGSI_PROCESSOR_TESS_CTRL ||
          procType == TGSI_PROCESSOR_TESS_EVAL ||
          procType == TGSI_PROCESSOR_COMPUTE);
a595 1

d599 1
a599 2
   while( !tgsi_parse_end_of_tokens( &parse ) ) {

d606 2
a607 68
         {
            const struct tgsi_full_instruction *fullinst
               = &parse.FullToken.FullInstruction;
            uint i;

            assert(fullinst->Instruction.Opcode < TGSI_OPCODE_LAST);
            info->opcode_count[fullinst->Instruction.Opcode]++;

            for (i = 0; i < fullinst->Instruction.NumSrcRegs; i++) {
               const struct tgsi_full_src_register *src =
                  &fullinst->Src[i];
               int ind = src->Register.Index;

               /* Mark which inputs are effectively used */
               if (src->Register.File == TGSI_FILE_INPUT) {
                  unsigned usage_mask;
                  usage_mask = tgsi_util_get_inst_usage_mask(fullinst, i);
                  if (src->Register.Indirect) {
                     for (ind = 0; ind < info->num_inputs; ++ind) {
                        info->input_usage_mask[ind] |= usage_mask;
                     }
                  } else {
                     assert(ind >= 0);
                     assert(ind < PIPE_MAX_SHADER_INPUTS);
                     info->input_usage_mask[ind] |= usage_mask;
                  }

                  if (procType == TGSI_PROCESSOR_FRAGMENT &&
                      info->reads_position &&
                      src->Register.Index == 0 &&
                      (src->Register.SwizzleX == TGSI_SWIZZLE_Z ||
                       src->Register.SwizzleY == TGSI_SWIZZLE_Z ||
                       src->Register.SwizzleZ == TGSI_SWIZZLE_Z ||
                       src->Register.SwizzleW == TGSI_SWIZZLE_Z)) {
                     info->reads_z = TRUE;
                  }
               }

               /* check for indirect register reads */
               if (src->Register.Indirect) {
                  info->indirect_files |= (1 << src->Register.File);
                  info->indirect_files_read |= (1 << src->Register.File);
               }

               /* MSAA samplers */
               if (src->Register.File == TGSI_FILE_SAMPLER) {
                  assert(fullinst->Instruction.Texture);
                  assert(src->Register.Index < Elements(info->is_msaa_sampler));

                  if (fullinst->Instruction.Texture &&
                      (fullinst->Texture.Texture == TGSI_TEXTURE_2D_MSAA ||
                       fullinst->Texture.Texture == TGSI_TEXTURE_2D_ARRAY_MSAA)) {
                     info->is_msaa_sampler[src->Register.Index] = TRUE;
                  }
               }
            }

            /* check for indirect register writes */
            for (i = 0; i < fullinst->Instruction.NumDstRegs; i++) {
               const struct tgsi_full_dst_register *dst = &fullinst->Dst[i];
               if (dst->Register.Indirect) {
                  info->indirect_files |= (1 << dst->Register.File);
                  info->indirect_files_written |= (1 << dst->Register.File);
               }
            }

            info->num_instructions++;
         }
a608 1

d610 1
a610 142
         {
            const struct tgsi_full_declaration *fulldecl
               = &parse.FullToken.FullDeclaration;
            const uint file = fulldecl->Declaration.File;
            uint reg;

            if (fulldecl->Declaration.Array) {
               unsigned array_id = fulldecl->Array.ArrayID;

               switch (file) {
               case TGSI_FILE_INPUT:
                  assert(array_id < ARRAY_SIZE(info->input_array_first));
                  info->input_array_first[array_id] = fulldecl->Range.First;
                  info->input_array_last[array_id] = fulldecl->Range.Last;
                  break;
               case TGSI_FILE_OUTPUT:
                  assert(array_id < ARRAY_SIZE(info->output_array_first));
                  info->output_array_first[array_id] = fulldecl->Range.First;
                  info->output_array_last[array_id] = fulldecl->Range.Last;
                  break;
               }
               info->array_max[file] = MAX2(info->array_max[file], array_id);
            }

            for (reg = fulldecl->Range.First;
                 reg <= fulldecl->Range.Last;
                 reg++) {
               unsigned semName = fulldecl->Semantic.Name;
               unsigned semIndex =
                  fulldecl->Semantic.Index + (reg - fulldecl->Range.First);

               /* only first 32 regs will appear in this bitfield */
               info->file_mask[file] |= (1 << reg);
               info->file_count[file]++;
               info->file_max[file] = MAX2(info->file_max[file], (int)reg);

               if (file == TGSI_FILE_CONSTANT) {
                  int buffer = 0;

                  if (fulldecl->Declaration.Dimension)
                     buffer = fulldecl->Dim.Index2D;

                  info->const_file_max[buffer] =
                        MAX2(info->const_file_max[buffer], (int)reg);
               }
               else if (file == TGSI_FILE_INPUT) {
                  info->input_semantic_name[reg] = (ubyte) semName;
                  info->input_semantic_index[reg] = (ubyte) semIndex;
                  info->input_interpolate[reg] = (ubyte)fulldecl->Interp.Interpolate;
                  info->input_interpolate_loc[reg] = (ubyte)fulldecl->Interp.Location;
                  info->input_cylindrical_wrap[reg] = (ubyte)fulldecl->Interp.CylindricalWrap;
                  info->num_inputs++;

                  if (fulldecl->Interp.Location == TGSI_INTERPOLATE_LOC_CENTROID)
                     info->uses_centroid = TRUE;

                  if (semName == TGSI_SEMANTIC_PRIMID)
                     info->uses_primid = TRUE;
                  else if (procType == TGSI_PROCESSOR_FRAGMENT) {
                     if (semName == TGSI_SEMANTIC_POSITION)
                        info->reads_position = TRUE;
                     else if (semName == TGSI_SEMANTIC_FACE)
                        info->uses_frontface = TRUE;
                  }
               }
               else if (file == TGSI_FILE_SYSTEM_VALUE) {
                  unsigned index = fulldecl->Range.First;

                  info->system_value_semantic_name[index] = semName;
                  info->num_system_values = MAX2(info->num_system_values,
                                                 index + 1);

                  if (semName == TGSI_SEMANTIC_INSTANCEID) {
                     info->uses_instanceid = TRUE;
                  }
                  else if (semName == TGSI_SEMANTIC_VERTEXID) {
                     info->uses_vertexid = TRUE;
                  }
                  else if (semName == TGSI_SEMANTIC_VERTEXID_NOBASE) {
                     info->uses_vertexid_nobase = TRUE;
                  }
                  else if (semName == TGSI_SEMANTIC_BASEVERTEX) {
                     info->uses_basevertex = TRUE;
                  }
                  else if (semName == TGSI_SEMANTIC_PRIMID) {
                     info->uses_primid = TRUE;
                  } else if (semName == TGSI_SEMANTIC_INVOCATIONID) {
                     info->uses_invocationid = TRUE;
                  }
               }
               else if (file == TGSI_FILE_OUTPUT) {
                  info->output_semantic_name[reg] = (ubyte) semName;
                  info->output_semantic_index[reg] = (ubyte) semIndex;
                  info->num_outputs++;

                  if (procType == TGSI_PROCESSOR_VERTEX ||
                      procType == TGSI_PROCESSOR_GEOMETRY ||
                      procType == TGSI_PROCESSOR_TESS_CTRL ||
                      procType == TGSI_PROCESSOR_TESS_EVAL) {
                     if (semName == TGSI_SEMANTIC_CLIPDIST) {
                        info->num_written_clipdistance +=
                           util_bitcount(fulldecl->Declaration.UsageMask);
                        info->clipdist_writemask |=
                           fulldecl->Declaration.UsageMask << (semIndex*4);
                     }
                     else if (semName == TGSI_SEMANTIC_CULLDIST) {
                        info->num_written_culldistance +=
                           util_bitcount(fulldecl->Declaration.UsageMask);
                        info->culldist_writemask |=
                           fulldecl->Declaration.UsageMask << (semIndex*4);
                     }
                     else if (semName == TGSI_SEMANTIC_VIEWPORT_INDEX) {
                        info->writes_viewport_index = TRUE;
                     }
                     else if (semName == TGSI_SEMANTIC_LAYER) {
                        info->writes_layer = TRUE;
                     }
                     else if (semName == TGSI_SEMANTIC_PSIZE) {
                        info->writes_psize = TRUE;
                     }
                     else if (semName == TGSI_SEMANTIC_CLIPVERTEX) {
                        info->writes_clipvertex = TRUE;
                     }
                  }

                  if (procType == TGSI_PROCESSOR_FRAGMENT) {
                     if (semName == TGSI_SEMANTIC_POSITION) {
                        info->writes_z = TRUE;
                     }
                     else if (semName == TGSI_SEMANTIC_STENCIL) {
                        info->writes_stencil = TRUE;
                     }
                  }

                  if (procType == TGSI_PROCESSOR_VERTEX) {
                     if (semName == TGSI_SEMANTIC_EDGEFLAG) {
                        info->writes_edgeflag = TRUE;
                     }
                  }
               }
            }
         }
a611 1

d613 1
a613 8
         {
            uint reg = info->immediate_count++;
            uint file = TGSI_FILE_IMMEDIATE;

            info->file_mask[file] |= (1 << reg);
            info->file_count[file]++;
            info->file_max[file] = MAX2(info->file_max[file], (int)reg);
         }
a614 1

d616 1
a616 8
         {
            const struct tgsi_full_property *fullprop
               = &parse.FullToken.FullProperty;
            unsigned name = fullprop->Property.PropertyName;

            assert(name < Elements(info->properties));
            info->properties[name] = fullprop->u[0].Data;
         }
a617 1

d619 1
a619 1
         assert( 0 );
d629 1
a629 1
   if (procType == TGSI_PROCESSOR_GEOMETRY) {
d642 1
a642 1
   tgsi_parse_free (&parse);
d645 76
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.0.8

This seems to fix some of the problems with clutter/gnome reported to
occur on r600 with 11.0.6
@
text
@a260 3
                  if (semName == TGSI_SEMANTIC_COLOR)
                     info->colors_written |= 1 << semIndex;

@


1.1.1.3
log
@Import Mesa 11.2.2
@
text
@a46 389
static void
scan_instruction(struct tgsi_shader_info *info,
                 const struct tgsi_full_instruction *fullinst,
                 unsigned *current_depth)
{
   unsigned i;

   assert(fullinst->Instruction.Opcode < TGSI_OPCODE_LAST);
   info->opcode_count[fullinst->Instruction.Opcode]++;

   switch (fullinst->Instruction.Opcode) {
   case TGSI_OPCODE_IF:
   case TGSI_OPCODE_UIF:
   case TGSI_OPCODE_BGNLOOP:
      (*current_depth)++;
      info->max_depth = MAX2(info->max_depth, *current_depth);
      break;
   case TGSI_OPCODE_ENDIF:
   case TGSI_OPCODE_ENDLOOP:
      (*current_depth)--;
      break;
   default:
      break;
   }

   if (fullinst->Instruction.Opcode == TGSI_OPCODE_INTERP_CENTROID ||
       fullinst->Instruction.Opcode == TGSI_OPCODE_INTERP_OFFSET ||
       fullinst->Instruction.Opcode == TGSI_OPCODE_INTERP_SAMPLE) {
      const struct tgsi_full_src_register *src0 = &fullinst->Src[0];
      unsigned input;

      if (src0->Register.Indirect && src0->Indirect.ArrayID)
         input = info->input_array_first[src0->Indirect.ArrayID];
      else
         input = src0->Register.Index;

      /* For the INTERP opcodes, the interpolation is always
       * PERSPECTIVE unless LINEAR is specified.
       */
      switch (info->input_interpolate[input]) {
      case TGSI_INTERPOLATE_COLOR:
      case TGSI_INTERPOLATE_CONSTANT:
      case TGSI_INTERPOLATE_PERSPECTIVE:
         switch (fullinst->Instruction.Opcode) {
         case TGSI_OPCODE_INTERP_CENTROID:
            info->uses_persp_opcode_interp_centroid = TRUE;
            break;
         case TGSI_OPCODE_INTERP_OFFSET:
            info->uses_persp_opcode_interp_offset = TRUE;
            break;
         case TGSI_OPCODE_INTERP_SAMPLE:
            info->uses_persp_opcode_interp_sample = TRUE;
            break;
         }
         break;

      case TGSI_INTERPOLATE_LINEAR:
         switch (fullinst->Instruction.Opcode) {
         case TGSI_OPCODE_INTERP_CENTROID:
            info->uses_linear_opcode_interp_centroid = TRUE;
            break;
         case TGSI_OPCODE_INTERP_OFFSET:
            info->uses_linear_opcode_interp_offset = TRUE;
            break;
         case TGSI_OPCODE_INTERP_SAMPLE:
            info->uses_linear_opcode_interp_sample = TRUE;
            break;
         }
         break;
      }
   }

   if (fullinst->Instruction.Opcode >= TGSI_OPCODE_F2D &&
       fullinst->Instruction.Opcode <= TGSI_OPCODE_DSSG)
      info->uses_doubles = TRUE;

   for (i = 0; i < fullinst->Instruction.NumSrcRegs; i++) {
      const struct tgsi_full_src_register *src = &fullinst->Src[i];
      int ind = src->Register.Index;

      /* Mark which inputs are effectively used */
      if (src->Register.File == TGSI_FILE_INPUT) {
         unsigned usage_mask;
         usage_mask = tgsi_util_get_inst_usage_mask(fullinst, i);
         if (src->Register.Indirect) {
            for (ind = 0; ind < info->num_inputs; ++ind) {
               info->input_usage_mask[ind] |= usage_mask;
            }
         } else {
            assert(ind >= 0);
            assert(ind < PIPE_MAX_SHADER_INPUTS);
            info->input_usage_mask[ind] |= usage_mask;
         }

         if (info->processor == TGSI_PROCESSOR_FRAGMENT &&
             !src->Register.Indirect) {
            unsigned name =
               info->input_semantic_name[src->Register.Index];
            unsigned index =
               info->input_semantic_index[src->Register.Index];

            if (name == TGSI_SEMANTIC_POSITION &&
                (src->Register.SwizzleX == TGSI_SWIZZLE_Z ||
                 src->Register.SwizzleY == TGSI_SWIZZLE_Z ||
                 src->Register.SwizzleZ == TGSI_SWIZZLE_Z ||
                 src->Register.SwizzleW == TGSI_SWIZZLE_Z))
               info->reads_z = TRUE;

            if (name == TGSI_SEMANTIC_COLOR) {
               unsigned mask =
                  (1 << src->Register.SwizzleX) |
                  (1 << src->Register.SwizzleY) |
                  (1 << src->Register.SwizzleZ) |
                  (1 << src->Register.SwizzleW);

               info->colors_read |= mask << (index * 4);
            }
         }
      }

      /* check for indirect register reads */
      if (src->Register.Indirect) {
         info->indirect_files |= (1 << src->Register.File);
         info->indirect_files_read |= (1 << src->Register.File);
      }

      /* MSAA samplers */
      if (src->Register.File == TGSI_FILE_SAMPLER) {
         assert(fullinst->Instruction.Texture);
         assert(src->Register.Index < Elements(info->is_msaa_sampler));

         if (fullinst->Instruction.Texture &&
             (fullinst->Texture.Texture == TGSI_TEXTURE_2D_MSAA ||
              fullinst->Texture.Texture == TGSI_TEXTURE_2D_ARRAY_MSAA)) {
            info->is_msaa_sampler[src->Register.Index] = TRUE;
         }
      }
   }

   /* check for indirect register writes */
   for (i = 0; i < fullinst->Instruction.NumDstRegs; i++) {
      const struct tgsi_full_dst_register *dst = &fullinst->Dst[i];
      if (dst->Register.Indirect) {
         info->indirect_files |= (1 << dst->Register.File);
         info->indirect_files_written |= (1 << dst->Register.File);
      }
   }

   info->num_instructions++;
}
     

static void
scan_declaration(struct tgsi_shader_info *info,
                 const struct tgsi_full_declaration *fulldecl)
{
   const uint file = fulldecl->Declaration.File;
   const unsigned procType = info->processor;
   uint reg;

   if (fulldecl->Declaration.Array) {
      unsigned array_id = fulldecl->Array.ArrayID;

      switch (file) {
      case TGSI_FILE_INPUT:
         assert(array_id < ARRAY_SIZE(info->input_array_first));
         info->input_array_first[array_id] = fulldecl->Range.First;
         info->input_array_last[array_id] = fulldecl->Range.Last;
         break;
      case TGSI_FILE_OUTPUT:
         assert(array_id < ARRAY_SIZE(info->output_array_first));
         info->output_array_first[array_id] = fulldecl->Range.First;
         info->output_array_last[array_id] = fulldecl->Range.Last;
         break;
      }
      info->array_max[file] = MAX2(info->array_max[file], array_id);
   }

   for (reg = fulldecl->Range.First; reg <= fulldecl->Range.Last; reg++) {
      unsigned semName = fulldecl->Semantic.Name;
      unsigned semIndex = fulldecl->Semantic.Index +
         (reg - fulldecl->Range.First);

      /* only first 32 regs will appear in this bitfield */
      info->file_mask[file] |= (1 << reg);
      info->file_count[file]++;
      info->file_max[file] = MAX2(info->file_max[file], (int)reg);

      if (file == TGSI_FILE_CONSTANT) {
         int buffer = 0;

         if (fulldecl->Declaration.Dimension)
            buffer = fulldecl->Dim.Index2D;

         info->const_file_max[buffer] =
            MAX2(info->const_file_max[buffer], (int)reg);
      }
      else if (file == TGSI_FILE_INPUT) {
         info->input_semantic_name[reg] = (ubyte) semName;
         info->input_semantic_index[reg] = (ubyte) semIndex;
         info->input_interpolate[reg] = (ubyte)fulldecl->Interp.Interpolate;
         info->input_interpolate_loc[reg] = (ubyte)fulldecl->Interp.Location;
         info->input_cylindrical_wrap[reg] = (ubyte)fulldecl->Interp.CylindricalWrap;

         /* Vertex shaders can have inputs with holes between them. */
         if (info->processor == TGSI_PROCESSOR_VERTEX)
            info->num_inputs = MAX2(info->num_inputs, reg + 1);
         else {
            info->num_inputs++;
            assert(reg < info->num_inputs);
         }

         /* Only interpolated varyings. Don't include POSITION.
          * Don't include integer varyings, because they are not
          * interpolated.
          */
         if (semName == TGSI_SEMANTIC_GENERIC ||
             semName == TGSI_SEMANTIC_TEXCOORD ||
             semName == TGSI_SEMANTIC_COLOR ||
             semName == TGSI_SEMANTIC_BCOLOR ||
             semName == TGSI_SEMANTIC_FOG ||
             semName == TGSI_SEMANTIC_CLIPDIST ||
             semName == TGSI_SEMANTIC_CULLDIST) {
            switch (fulldecl->Interp.Interpolate) {
            case TGSI_INTERPOLATE_COLOR:
            case TGSI_INTERPOLATE_PERSPECTIVE:
               switch (fulldecl->Interp.Location) {
               case TGSI_INTERPOLATE_LOC_CENTER:
                  info->uses_persp_center = TRUE;
                  break;
               case TGSI_INTERPOLATE_LOC_CENTROID:
                  info->uses_persp_centroid = TRUE;
                  break;
               case TGSI_INTERPOLATE_LOC_SAMPLE:
                  info->uses_persp_sample = TRUE;
                  break;
               }
               break;
            case TGSI_INTERPOLATE_LINEAR:
               switch (fulldecl->Interp.Location) {
               case TGSI_INTERPOLATE_LOC_CENTER:
                  info->uses_linear_center = TRUE;
                  break;
               case TGSI_INTERPOLATE_LOC_CENTROID:
                  info->uses_linear_centroid = TRUE;
                  break;
               case TGSI_INTERPOLATE_LOC_SAMPLE:
                  info->uses_linear_sample = TRUE;
                  break;
               }
               break;
               /* TGSI_INTERPOLATE_CONSTANT doesn't do any interpolation. */
            }
         }

         if (semName == TGSI_SEMANTIC_PRIMID)
            info->uses_primid = TRUE;
         else if (procType == TGSI_PROCESSOR_FRAGMENT) {
            if (semName == TGSI_SEMANTIC_POSITION)
               info->reads_position = TRUE;
            else if (semName == TGSI_SEMANTIC_FACE)
               info->uses_frontface = TRUE;
         }
      }
      else if (file == TGSI_FILE_SYSTEM_VALUE) {
         unsigned index = fulldecl->Range.First;

         info->system_value_semantic_name[index] = semName;
         info->num_system_values = MAX2(info->num_system_values, index + 1);

         switch (semName) {
         case TGSI_SEMANTIC_INSTANCEID:
            info->uses_instanceid = TRUE;
            break;
         case TGSI_SEMANTIC_VERTEXID:
            info->uses_vertexid = TRUE;
            break;
         case TGSI_SEMANTIC_VERTEXID_NOBASE:
            info->uses_vertexid_nobase = TRUE;
            break;
         case TGSI_SEMANTIC_BASEVERTEX:
            info->uses_basevertex = TRUE;
            break;
         case TGSI_SEMANTIC_PRIMID:
            info->uses_primid = TRUE;
            break;
         case TGSI_SEMANTIC_INVOCATIONID:
            info->uses_invocationid = TRUE;
            break;
         case TGSI_SEMANTIC_POSITION:
            info->reads_position = TRUE;
            break;
         case TGSI_SEMANTIC_FACE:
            info->uses_frontface = TRUE;
            break;
         case TGSI_SEMANTIC_SAMPLEMASK:
            info->reads_samplemask = TRUE;
            break;
         }
      }
      else if (file == TGSI_FILE_OUTPUT) {
         info->output_semantic_name[reg] = (ubyte) semName;
         info->output_semantic_index[reg] = (ubyte) semIndex;
         info->num_outputs++;
         assert(reg < info->num_outputs);

         if (semName == TGSI_SEMANTIC_COLOR)
            info->colors_written |= 1 << semIndex;

         if (procType == TGSI_PROCESSOR_VERTEX ||
             procType == TGSI_PROCESSOR_GEOMETRY ||
             procType == TGSI_PROCESSOR_TESS_CTRL ||
             procType == TGSI_PROCESSOR_TESS_EVAL) {
            switch (semName) {
            case TGSI_SEMANTIC_VIEWPORT_INDEX:
               info->writes_viewport_index = TRUE;
               break;
            case TGSI_SEMANTIC_LAYER:
               info->writes_layer = TRUE;
               break;
            case TGSI_SEMANTIC_PSIZE:
               info->writes_psize = TRUE;
               break;
            case TGSI_SEMANTIC_CLIPVERTEX:
               info->writes_clipvertex = TRUE;
               break;
            }
         }

         if (procType == TGSI_PROCESSOR_FRAGMENT) {
            switch (semName) {
            case TGSI_SEMANTIC_POSITION:
               info->writes_z = TRUE;
               break;
            case TGSI_SEMANTIC_STENCIL:
               info->writes_stencil = TRUE;
               break;
            case TGSI_SEMANTIC_SAMPLEMASK:
               info->writes_samplemask = TRUE;
               break;
            }
         }

         if (procType == TGSI_PROCESSOR_VERTEX) {
            if (semName == TGSI_SEMANTIC_EDGEFLAG) {
               info->writes_edgeflag = TRUE;
            }
         }
      } else if (file == TGSI_FILE_SAMPLER) {
         info->samplers_declared |= 1 << reg;
      }
   }
}


static void
scan_immediate(struct tgsi_shader_info *info)
{
   uint reg = info->immediate_count++;
   uint file = TGSI_FILE_IMMEDIATE;

   info->file_mask[file] |= (1 << reg);
   info->file_count[file]++;
   info->file_max[file] = MAX2(info->file_max[file], (int)reg);
}


static void
scan_property(struct tgsi_shader_info *info,
              const struct tgsi_full_property *fullprop)
{
   unsigned name = fullprop->Property.PropertyName;
   unsigned value = fullprop->u[0].Data;

   assert(name < Elements(info->properties));
   info->properties[name] = value;

   switch (name) {
   case TGSI_PROPERTY_NUM_CLIPDIST_ENABLED:
      info->num_written_clipdistance = value;
      info->clipdist_writemask |= (1 << value) - 1;
      break;
   case TGSI_PROPERTY_NUM_CULLDIST_ENABLED:
      info->num_written_culldistance = value;
      info->culldist_writemask |= (1 << value) - 1;
      break;
   }
}

a58 1
   unsigned current_depth = 0;
d83 1
d87 2
a88 1
   while (!tgsi_parse_end_of_tokens(&parse)) {
d95 68
a162 2
         scan_instruction(info, &parse.FullToken.FullInstruction,
                          &current_depth);
d164 1
d166 145
a310 1
         scan_declaration(info, &parse.FullToken.FullDeclaration);
d312 1
d314 8
a321 1
         scan_immediate(info);
d323 1
d325 8
a332 1
         scan_property(info, &parse.FullToken.FullProperty);
d334 1
d336 1
a336 1
         assert(!"Unexpected TGSI token type");
d359 1
a359 1
   tgsi_parse_free(&parse);
@


1.1.1.4
log
@Import Mesa 13.0.2
@
text
@a40 1
#include "tgsi/tgsi_info.h"
a45 50
static bool
is_memory_file(unsigned file)
{
   return file == TGSI_FILE_SAMPLER ||
          file == TGSI_FILE_SAMPLER_VIEW ||
          file == TGSI_FILE_IMAGE ||
          file == TGSI_FILE_BUFFER;
}


/**
 * Is the opcode a "true" texture instruction which samples from a
 * texture map?
 */
static bool
is_texture_inst(unsigned opcode)
{
   return (opcode != TGSI_OPCODE_TXQ &&
           opcode != TGSI_OPCODE_TXQS &&
           opcode != TGSI_OPCODE_TXQ_LZ &&
           opcode != TGSI_OPCODE_LODQ &&
           tgsi_get_opcode_info(opcode)->is_tex);
}


/**
 * Is the opcode an instruction which computes a derivative explicitly or
 * implicitly?
 */
static bool
computes_derivative(unsigned opcode)
{
   if (tgsi_get_opcode_info(opcode)->is_tex) {
      return opcode != TGSI_OPCODE_TG4 &&
             opcode != TGSI_OPCODE_TXD &&
             opcode != TGSI_OPCODE_TXF &&
             opcode != TGSI_OPCODE_TXL &&
             opcode != TGSI_OPCODE_TXL2 &&
             opcode != TGSI_OPCODE_TXQ &&
             opcode != TGSI_OPCODE_TXQ_LZ &&
             opcode != TGSI_OPCODE_TXQS;
   }

   return opcode == TGSI_OPCODE_DDX || opcode == TGSI_OPCODE_DDX_FINE ||
          opcode == TGSI_OPCODE_DDY || opcode == TGSI_OPCODE_DDY_FINE ||
          opcode == TGSI_OPCODE_SAMPLE ||
          opcode == TGSI_OPCODE_SAMPLE_B ||
          opcode == TGSI_OPCODE_SAMPLE_C;
}

a52 2
   bool is_mem_inst = false;
   bool is_interp_instruction = false;
a77 2
      is_interp_instruction = true;

d141 6
a146 10
         if (info->processor == PIPE_SHADER_FRAGMENT) {
            unsigned name, index, input;

            if (src->Register.Indirect && src->Indirect.ArrayID)
               input = info->input_array_first[src->Indirect.ArrayID];
            else
               input = src->Register.Index;

            name = info->input_semantic_name[input];
            index = info->input_semantic_index[input];
a163 44

            /* Process only interpolated varyings. Don't include POSITION.
             * Don't include integer varyings, because they are not
             * interpolated. Don't process inputs interpolated by INTERP
             * opcodes. Those are tracked separately.
             */
            if ((!is_interp_instruction || i != 0) &&
                (name == TGSI_SEMANTIC_GENERIC ||
                 name == TGSI_SEMANTIC_TEXCOORD ||
                 name == TGSI_SEMANTIC_COLOR ||
                 name == TGSI_SEMANTIC_BCOLOR ||
                 name == TGSI_SEMANTIC_FOG ||
                 name == TGSI_SEMANTIC_CLIPDIST)) {
               switch (info->input_interpolate[input]) {
               case TGSI_INTERPOLATE_COLOR:
               case TGSI_INTERPOLATE_PERSPECTIVE:
                  switch (info->input_interpolate_loc[input]) {
                  case TGSI_INTERPOLATE_LOC_CENTER:
                     info->uses_persp_center = TRUE;
                     break;
                  case TGSI_INTERPOLATE_LOC_CENTROID:
                     info->uses_persp_centroid = TRUE;
                     break;
                  case TGSI_INTERPOLATE_LOC_SAMPLE:
                     info->uses_persp_sample = TRUE;
                     break;
                  }
                  break;
               case TGSI_INTERPOLATE_LINEAR:
                  switch (info->input_interpolate_loc[input]) {
                  case TGSI_INTERPOLATE_LOC_CENTER:
                     info->uses_linear_center = TRUE;
                     break;
                  case TGSI_INTERPOLATE_LOC_CENTROID:
                     info->uses_linear_centroid = TRUE;
                     break;
                  case TGSI_INTERPOLATE_LOC_SAMPLE:
                     info->uses_linear_sample = TRUE;
                     break;
                  }
                  break;
                  /* TGSI_INTERPOLATE_CONSTANT doesn't do any interpolation. */
               }
            }
d173 1
a173 1
      /* Texture samplers */
a174 2
         const unsigned index = src->Register.Index;

d176 1
a176 32
         assert(index < ARRAY_SIZE(info->is_msaa_sampler));
         assert(index < PIPE_MAX_SAMPLERS);

         if (is_texture_inst(fullinst->Instruction.Opcode)) {
            const unsigned target = fullinst->Texture.Texture;
            assert(target < TGSI_TEXTURE_UNKNOWN);
            /* for texture instructions, check that the texture instruction
             * target matches the previous sampler view declaration (if there
             * was one.)
             */
            if (info->sampler_targets[index] == TGSI_TEXTURE_UNKNOWN) {
               /* probably no sampler view declaration */
               info->sampler_targets[index] = target;
            } else {
               /* Make sure the texture instruction's sampler/target info
                * agrees with the sampler view declaration.
                */
               assert(info->sampler_targets[index] == target);
            }
            /* MSAA samplers */
            if (target == TGSI_TEXTURE_2D_MSAA ||
                target == TGSI_TEXTURE_2D_ARRAY_MSAA) {
               info->is_msaa_sampler[src->Register.Index] = TRUE;
            }
         }
      }

      if (is_memory_file(src->Register.File)) {
         is_mem_inst = true;

         if (tgsi_get_opcode_info(fullinst->Instruction.Opcode)->is_store) {
            info->writes_memory = TRUE;
d178 4
a181 3
            if (src->Register.File == TGSI_FILE_IMAGE &&
                !src->Register.Indirect)
               info->images_writemask |= 1 << src->Register.Index;
a192 11

      if (is_memory_file(dst->Register.File)) {
         assert(fullinst->Instruction.Opcode == TGSI_OPCODE_STORE);

         is_mem_inst = true;
         info->writes_memory = TRUE;

         if (dst->Register.File == TGSI_FILE_IMAGE &&
             !dst->Register.Indirect)
            info->images_writemask |= 1 << dst->Register.Index;
      }
a194 6
   if (is_mem_inst)
      info->num_memory_instructions++;

   if (computes_derivative(fullinst->Instruction.Opcode))
      info->uses_derivatives = true;

d252 49
a300 1
         info->num_inputs = MAX2(info->num_inputs, reg + 1);
d304 1
a304 1
         else if (procType == PIPE_SHADER_FRAGMENT) {
d350 2
a351 1
         info->num_outputs = MAX2(info->num_outputs, reg + 1);
d356 4
a359 4
         if (procType == PIPE_SHADER_VERTEX ||
             procType == PIPE_SHADER_GEOMETRY ||
             procType == PIPE_SHADER_TESS_CTRL ||
             procType == PIPE_SHADER_TESS_EVAL) {
d376 1
a376 1
         if (procType == PIPE_SHADER_FRAGMENT) {
d390 1
a390 1
         if (procType == PIPE_SHADER_VERTEX) {
d396 1
a396 19
         STATIC_ASSERT(sizeof(info->samplers_declared) * 8 >= PIPE_MAX_SAMPLERS);
         info->samplers_declared |= 1u << reg;
      } else if (file == TGSI_FILE_SAMPLER_VIEW) {
         unsigned target = fulldecl->SamplerView.Resource;
         unsigned type = fulldecl->SamplerView.ReturnTypeX;

         assert(target < TGSI_TEXTURE_UNKNOWN);
         if (info->sampler_targets[reg] == TGSI_TEXTURE_UNKNOWN) {
            /* Save sampler target for this sampler index */
            info->sampler_targets[reg] = target;
            info->sampler_type[reg] = type;
         } else {
            /* if previously declared, make sure targets agree */
            assert(info->sampler_targets[reg] == target);
            assert(info->sampler_type[reg] == type);
         }
      } else if (file == TGSI_FILE_IMAGE) {
         if (fulldecl->Image.Resource == TGSI_TEXTURE_BUFFER)
            info->images_buffers |= 1 << reg;
d421 1
a421 1
   assert(name < ARRAY_SIZE(info->properties));
d453 1
a453 1
   for (i = 0; i < ARRAY_SIZE(info->const_file_max); i++)
a455 2
   for (i = 0; i < ARRAY_SIZE(info->sampler_targets); i++)
      info->sampler_targets[i] = TGSI_TEXTURE_UNKNOWN;
d465 6
a470 6
   assert(procType == PIPE_SHADER_FRAGMENT ||
          procType == PIPE_SHADER_VERTEX ||
          procType == PIPE_SHADER_GEOMETRY ||
          procType == PIPE_SHADER_TESS_CTRL ||
          procType == PIPE_SHADER_TESS_EVAL ||
          procType == PIPE_SHADER_COMPUTE);
d506 1
a506 1
   if (procType == PIPE_SHADER_GEOMETRY) {
a521 76
/**
 * Collect information about the arrays of a given register file.
 *
 * @@param tokens TGSI shader
 * @@param file the register file to scan through
 * @@param max_array_id number of entries in @@p arrays; should be equal to the
 *                     highest array id, i.e. tgsi_shader_info::array_max[file].
 * @@param arrays info for array of each ID will be written to arrays[ID - 1].
 */
void
tgsi_scan_arrays(const struct tgsi_token *tokens,
                 unsigned file,
                 unsigned max_array_id,
                 struct tgsi_array_info *arrays)
{
   struct tgsi_parse_context parse;

   if (tgsi_parse_init(&parse, tokens) != TGSI_PARSE_OK) {
      debug_printf("tgsi_parse_init() failed in tgsi_scan_arrays()!\n");
      return;
   }

   memset(arrays, 0, sizeof(arrays[0]) * max_array_id);

   while (!tgsi_parse_end_of_tokens(&parse)) {
      struct tgsi_full_instruction *inst;

      tgsi_parse_token(&parse);

      if (parse.FullToken.Token.Type == TGSI_TOKEN_TYPE_DECLARATION) {
         struct tgsi_full_declaration *decl = &parse.FullToken.FullDeclaration;

         if (decl->Declaration.Array && decl->Declaration.File == file &&
             decl->Array.ArrayID > 0 && decl->Array.ArrayID <= max_array_id) {
            struct tgsi_array_info *array = &arrays[decl->Array.ArrayID - 1];
            assert(!array->declared);
            array->declared = true;
            array->range = decl->Range;
         }
      }

      if (parse.FullToken.Token.Type != TGSI_TOKEN_TYPE_INSTRUCTION)
         continue;

      inst = &parse.FullToken.FullInstruction;
      for (unsigned i = 0; i < inst->Instruction.NumDstRegs; i++) {
         const struct tgsi_full_dst_register *dst = &inst->Dst[i];
         if (dst->Register.File != file)
            continue;

         if (dst->Register.Indirect) {
            if (dst->Indirect.ArrayID > 0 &&
                dst->Indirect.ArrayID <= max_array_id) {
               arrays[dst->Indirect.ArrayID - 1].writemask |= dst->Register.WriteMask;
            } else {
               /* Indirect writes without an ArrayID can write anywhere. */
               for (unsigned j = 0; j < max_array_id; ++j)
                  arrays[j].writemask |= dst->Register.WriteMask;
            }
         } else {
            /* Check whether the write falls into any of the arrays anyway. */
            for (unsigned j = 0; j < max_array_id; ++j) {
               struct tgsi_array_info *array = &arrays[j];
               if (array->declared &&
                   dst->Register.Index >= array->range.First &&
                   dst->Register.Index <= array->range.Last)
                  array->writemask |= dst->Register.WriteMask;
            }
         }
      }
   }

   tgsi_parse_free(&parse);

   return;
}
@


1.1.1.5
log
@Import Mesa 17.1.6
@
text
@a56 10
static bool
is_mem_query_inst(unsigned opcode)
{
   return opcode == TGSI_OPCODE_RESQ ||
          opcode == TGSI_OPCODE_TXQ ||
          opcode == TGSI_OPCODE_TXQS ||
          opcode == TGSI_OPCODE_TXQ_LZ ||
          opcode == TGSI_OPCODE_LODQ;
}

d64 4
a67 1
   return (!is_mem_query_inst(opcode) &&
a82 2
             opcode != TGSI_OPCODE_TXF_LZ &&
             opcode != TGSI_OPCODE_TEX_LZ &&
a98 207
scan_src_operand(struct tgsi_shader_info *info,
                 const struct tgsi_full_instruction *fullinst,
                 const struct tgsi_full_src_register *src,
                 unsigned src_index,
                 unsigned usage_mask,
                 bool is_interp_instruction,
                 bool *is_mem_inst)
{
   int ind = src->Register.Index;

   /* Mark which inputs are effectively used */
   if (src->Register.File == TGSI_FILE_INPUT) {
      if (src->Register.Indirect) {
         for (ind = 0; ind < info->num_inputs; ++ind) {
            info->input_usage_mask[ind] |= usage_mask;
         }
      } else {
         assert(ind >= 0);
         assert(ind < PIPE_MAX_SHADER_INPUTS);
         info->input_usage_mask[ind] |= usage_mask;
      }

      if (info->processor == PIPE_SHADER_FRAGMENT) {
         unsigned name, index, input;

         if (src->Register.Indirect && src->Indirect.ArrayID)
            input = info->input_array_first[src->Indirect.ArrayID];
         else
            input = src->Register.Index;

         name = info->input_semantic_name[input];
         index = info->input_semantic_index[input];

         if (name == TGSI_SEMANTIC_POSITION &&
             (src->Register.SwizzleX == TGSI_SWIZZLE_Z ||
              src->Register.SwizzleY == TGSI_SWIZZLE_Z ||
              src->Register.SwizzleZ == TGSI_SWIZZLE_Z ||
              src->Register.SwizzleW == TGSI_SWIZZLE_Z))
            info->reads_z = TRUE;

         if (name == TGSI_SEMANTIC_COLOR) {
            unsigned mask =
               (1 << src->Register.SwizzleX) |
               (1 << src->Register.SwizzleY) |
               (1 << src->Register.SwizzleZ) |
               (1 << src->Register.SwizzleW);

            info->colors_read |= mask << (index * 4);
         }

         /* Process only interpolated varyings. Don't include POSITION.
          * Don't include integer varyings, because they are not
          * interpolated. Don't process inputs interpolated by INTERP
          * opcodes. Those are tracked separately.
          */
         if ((!is_interp_instruction || src_index != 0) &&
             (name == TGSI_SEMANTIC_GENERIC ||
              name == TGSI_SEMANTIC_TEXCOORD ||
              name == TGSI_SEMANTIC_COLOR ||
              name == TGSI_SEMANTIC_BCOLOR ||
              name == TGSI_SEMANTIC_FOG ||
              name == TGSI_SEMANTIC_CLIPDIST)) {
            switch (info->input_interpolate[input]) {
            case TGSI_INTERPOLATE_COLOR:
            case TGSI_INTERPOLATE_PERSPECTIVE:
               switch (info->input_interpolate_loc[input]) {
               case TGSI_INTERPOLATE_LOC_CENTER:
                  info->uses_persp_center = TRUE;
                  break;
               case TGSI_INTERPOLATE_LOC_CENTROID:
                  info->uses_persp_centroid = TRUE;
                  break;
               case TGSI_INTERPOLATE_LOC_SAMPLE:
                  info->uses_persp_sample = TRUE;
                  break;
               }
               break;
            case TGSI_INTERPOLATE_LINEAR:
               switch (info->input_interpolate_loc[input]) {
               case TGSI_INTERPOLATE_LOC_CENTER:
                  info->uses_linear_center = TRUE;
                  break;
               case TGSI_INTERPOLATE_LOC_CENTROID:
                  info->uses_linear_centroid = TRUE;
                  break;
               case TGSI_INTERPOLATE_LOC_SAMPLE:
                  info->uses_linear_sample = TRUE;
                  break;
               }
               break;
               /* TGSI_INTERPOLATE_CONSTANT doesn't do any interpolation. */
            }
         }
      }
   }

   if (info->processor == PIPE_SHADER_TESS_CTRL &&
       src->Register.File == TGSI_FILE_OUTPUT) {
      unsigned input;

      if (src->Register.Indirect && src->Indirect.ArrayID)
         input = info->output_array_first[src->Indirect.ArrayID];
      else
         input = src->Register.Index;

      switch (info->output_semantic_name[input]) {
      case TGSI_SEMANTIC_PATCH:
         info->reads_perpatch_outputs = true;
         break;
      case TGSI_SEMANTIC_TESSINNER:
      case TGSI_SEMANTIC_TESSOUTER:
         info->reads_tessfactor_outputs = true;
         break;
      default:
         info->reads_pervertex_outputs = true;
      }
   }

   /* check for indirect register reads */
   if (src->Register.Indirect) {
      info->indirect_files |= (1 << src->Register.File);
      info->indirect_files_read |= (1 << src->Register.File);

      /* record indirect constant buffer indexing */
      if (src->Register.File == TGSI_FILE_CONSTANT) {
         if (src->Register.Dimension) {
            if (src->Dimension.Indirect)
               info->const_buffers_indirect = info->const_buffers_declared;
            else
               info->const_buffers_indirect |= 1u << src->Dimension.Index;
         } else {
            info->const_buffers_indirect |= 1;
         }
      }
   }

   if (src->Register.Dimension && src->Dimension.Indirect)
      info->dim_indirect_files |= 1u << src->Register.File;

   /* Texture samplers */
   if (src->Register.File == TGSI_FILE_SAMPLER) {
      const unsigned index = src->Register.Index;

      assert(fullinst->Instruction.Texture);
      assert(index < ARRAY_SIZE(info->is_msaa_sampler));
      assert(index < PIPE_MAX_SAMPLERS);

      if (is_texture_inst(fullinst->Instruction.Opcode)) {
         const unsigned target = fullinst->Texture.Texture;
         assert(target < TGSI_TEXTURE_UNKNOWN);
         /* for texture instructions, check that the texture instruction
          * target matches the previous sampler view declaration (if there
          * was one.)
          */
         if (info->sampler_targets[index] == TGSI_TEXTURE_UNKNOWN) {
            /* probably no sampler view declaration */
            info->sampler_targets[index] = target;
         } else {
            /* Make sure the texture instruction's sampler/target info
             * agrees with the sampler view declaration.
             */
            assert(info->sampler_targets[index] == target);
         }
         /* MSAA samplers */
         if (target == TGSI_TEXTURE_2D_MSAA ||
             target == TGSI_TEXTURE_2D_ARRAY_MSAA) {
            info->is_msaa_sampler[src->Register.Index] = TRUE;
         }
      }
   }

   if (is_memory_file(src->Register.File) &&
       !is_mem_query_inst(fullinst->Instruction.Opcode)) {
      *is_mem_inst = true;

      if (tgsi_get_opcode_info(fullinst->Instruction.Opcode)->is_store) {
         info->writes_memory = TRUE;

         if (src->Register.File == TGSI_FILE_IMAGE) {
            if (src->Register.Indirect)
               info->images_atomic = info->images_declared;
            else
               info->images_atomic |= 1 << src->Register.Index;
         } else if (src->Register.File == TGSI_FILE_BUFFER) {
            if (src->Register.Indirect)
               info->shader_buffers_atomic = info->shader_buffers_declared;
            else
               info->shader_buffers_atomic |= 1 << src->Register.Index;
         }
      } else {
         if (src->Register.File == TGSI_FILE_IMAGE) {
            if (src->Register.Indirect)
               info->images_load = info->images_declared;
            else
               info->images_load |= 1 << src->Register.Index;
         } else if (src->Register.File == TGSI_FILE_BUFFER) {
            if (src->Register.Indirect)
               info->shader_buffers_load = info->shader_buffers_declared;
            else
               info->shader_buffers_load |= 1 << src->Register.Index;
         }
      }
   }
}


static void
d179 134
a312 4
      scan_src_operand(info, fullinst, &fullinst->Src[i], i,
                       tgsi_util_get_inst_usage_mask(fullinst, i),
                       is_interp_instruction, &is_mem_inst);
   }
d314 4
a317 13
   if (fullinst->Instruction.Texture) {
      for (i = 0; i < fullinst->Texture.NumOffsets; i++) {
         struct tgsi_full_src_register src = {{0}};

         src.Register.File = fullinst->TexOffsets[i].File;
         src.Register.Index = fullinst->TexOffsets[i].Index;
         src.Register.SwizzleX = fullinst->TexOffsets[i].SwizzleX;
         src.Register.SwizzleY = fullinst->TexOffsets[i].SwizzleY;
         src.Register.SwizzleZ = fullinst->TexOffsets[i].SwizzleZ;

         /* The usage mask is suboptimal but should be safe. */
         scan_src_operand(info, fullinst, &src, 0, TGSI_WRITEMASK_XYZ,
                          false, &is_mem_inst);
a328 3
      if (dst->Register.Dimension && dst->Dimension.Indirect)
         info->dim_indirect_files |= 1u << dst->Register.File;

d335 3
a337 11
         if (dst->Register.File == TGSI_FILE_IMAGE) {
            if (dst->Register.Indirect)
               info->images_store = info->images_declared;
            else
               info->images_store |= 1 << dst->Register.Index;
         } else if (dst->Register.File == TGSI_FILE_BUFFER) {
            if (dst->Register.Indirect)
               info->shader_buffers_store = info->shader_buffers_declared;
            else
               info->shader_buffers_store |= 1 << dst->Register.Index;
         }
a380 2
      int buffer;
      unsigned index, target, type;
d387 2
a388 3
      switch (file) {
      case TGSI_FILE_CONSTANT:
         buffer = 0;
d395 2
a396 14
         info->const_buffers_declared |= 1u << buffer;
         break;

      case TGSI_FILE_IMAGE:
         info->images_declared |= 1u << reg;
         if (fulldecl->Image.Resource == TGSI_TEXTURE_BUFFER)
            info->images_buffers |= 1 << reg;
         break;

      case TGSI_FILE_BUFFER:
         info->shader_buffers_declared |= 1u << reg;
         break;

      case TGSI_FILE_INPUT:
d414 3
a416 4
         break;

      case TGSI_FILE_SYSTEM_VALUE:
         index = fulldecl->Range.First;
a448 4
         case TGSI_SEMANTIC_TESSINNER:
         case TGSI_SEMANTIC_TESSOUTER:
            info->reads_tess_factors = true;
            break;
d450 2
a451 3
         break;

      case TGSI_FILE_OUTPUT:
a453 1
         info->output_usagemask[reg] |= fulldecl->Declaration.UsageMask;
d456 21
a476 15
         if (fulldecl->Declaration.UsageMask & TGSI_WRITEMASK_X) {
            info->output_streams[reg] |= (ubyte)fulldecl->Semantic.StreamX;
            info->num_stream_output_components[fulldecl->Semantic.StreamX]++;
         }
         if (fulldecl->Declaration.UsageMask & TGSI_WRITEMASK_Y) {
            info->output_streams[reg] |= (ubyte)fulldecl->Semantic.StreamY << 2;
            info->num_stream_output_components[fulldecl->Semantic.StreamY]++;
         }
         if (fulldecl->Declaration.UsageMask & TGSI_WRITEMASK_Z) {
            info->output_streams[reg] |= (ubyte)fulldecl->Semantic.StreamZ << 4;
            info->num_stream_output_components[fulldecl->Semantic.StreamZ]++;
         }
         if (fulldecl->Declaration.UsageMask & TGSI_WRITEMASK_W) {
            info->output_streams[reg] |= (ubyte)fulldecl->Semantic.StreamW << 6;
            info->num_stream_output_components[fulldecl->Semantic.StreamW]++;
d479 12
a490 34
         switch (semName) {
         case TGSI_SEMANTIC_PRIMID:
            info->writes_primid = true;
            break;
         case TGSI_SEMANTIC_VIEWPORT_INDEX:
            info->writes_viewport_index = true;
            break;
         case TGSI_SEMANTIC_LAYER:
            info->writes_layer = true;
            break;
         case TGSI_SEMANTIC_PSIZE:
            info->writes_psize = true;
            break;
         case TGSI_SEMANTIC_CLIPVERTEX:
            info->writes_clipvertex = true;
            break;
         case TGSI_SEMANTIC_COLOR:
            info->colors_written |= 1 << semIndex;
            break;
         case TGSI_SEMANTIC_STENCIL:
            info->writes_stencil = true;
            break;
         case TGSI_SEMANTIC_SAMPLEMASK:
            info->writes_samplemask = true;
            break;
         case TGSI_SEMANTIC_EDGEFLAG:
            info->writes_edgeflag = true;
            break;
         case TGSI_SEMANTIC_POSITION:
            if (procType == PIPE_SHADER_FRAGMENT)
               info->writes_z = true;
            else
               info->writes_position = true;
            break;
a491 1
         break;
d493 6
a498 1
      case TGSI_FILE_SAMPLER:
d501 3
a503 5
         break;

      case TGSI_FILE_SAMPLER_VIEW:
         target = fulldecl->SamplerView.Resource;
         type = fulldecl->SamplerView.ReturnTypeX;
d515 3
a517 1
         break;
@


