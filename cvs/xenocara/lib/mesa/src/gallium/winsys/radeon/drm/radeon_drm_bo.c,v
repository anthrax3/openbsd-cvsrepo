head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.41.40;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.41.40;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.17.07;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.31.19;	author jsg;	state Exp;
branches;
next	;
commitid	uuv5VTS15jglEDZU;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright © 2011 Marek Olšák <maraeo@@gmail.com>
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
 * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 */

#include "radeon_drm_cs.h"

#include "util/u_hash_table.h"
#include "util/u_memory.h"
#include "util/simple_list.h"
#include "util/list.h"
#include "os/os_thread.h"
#include "os/os_mman.h"
#include "os/os_time.h"

#include "state_tracker/drm_driver.h"

#include <sys/ioctl.h>
#include <xf86drm.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>

static const struct pb_vtbl radeon_bo_vtbl;

static inline struct radeon_bo *radeon_bo(struct pb_buffer *bo)
{
    assert(bo->vtbl == &radeon_bo_vtbl);
    return (struct radeon_bo *)bo;
}

struct radeon_bo_va_hole {
    struct list_head list;
    uint64_t         offset;
    uint64_t         size;
};

struct radeon_bomgr {
    /* Base class. */
    struct pb_manager base;

    /* Winsys. */
    struct radeon_drm_winsys *rws;

    /* List of buffer GEM names. Protected by bo_handles_mutex. */
    struct util_hash_table *bo_names;
    /* List of buffer handles. Protectded by bo_handles_mutex. */
    struct util_hash_table *bo_handles;
    /* List of buffer virtual memory ranges. Protectded by bo_handles_mutex. */
    struct util_hash_table *bo_vas;
    pipe_mutex bo_handles_mutex;
    pipe_mutex bo_va_mutex;

    /* is virtual address supported */
    bool va;
    uint64_t va_offset;
    struct list_head va_holes;

    /* BO size alignment */
    unsigned size_align;
};

static inline struct radeon_bomgr *radeon_bomgr(struct pb_manager *mgr)
{
    return (struct radeon_bomgr *)mgr;
}

static struct radeon_bo *get_radeon_bo(struct pb_buffer *_buf)
{
    struct radeon_bo *bo = NULL;

    if (_buf->vtbl == &radeon_bo_vtbl) {
        bo = radeon_bo(_buf);
    } else {
        struct pb_buffer *base_buf;
        pb_size offset;
        pb_get_base_buffer(_buf, &base_buf, &offset);

        if (base_buf->vtbl == &radeon_bo_vtbl)
            bo = radeon_bo(base_buf);
    }

    return bo;
}

static bool radeon_bo_wait(struct pb_buffer *_buf, uint64_t timeout,
                           enum radeon_bo_usage usage)
{
   struct radeon_bo *bo = get_radeon_bo(_buf);

   /* Wait if any ioctl is being submitted with this buffer. */
   if (!os_wait_until_zero(&bo->num_active_ioctls, timeout))
      return false;

   /* TODO: handle arbitrary timeout */
    if (!timeout) {
        struct drm_radeon_gem_busy args = {0};

        args.handle = bo->handle;
        return drmCommandWriteRead(bo->rws->fd, DRM_RADEON_GEM_BUSY,
                                   &args, sizeof(args)) == 0;
    } else {
        struct drm_radeon_gem_wait_idle args = {0};

        args.handle = bo->handle;
        while (drmCommandWrite(bo->rws->fd, DRM_RADEON_GEM_WAIT_IDLE,
                               &args, sizeof(args)) == -EBUSY);
        return true;
    }
}

static enum radeon_bo_domain get_valid_domain(enum radeon_bo_domain domain)
{
    /* Zero domains the driver doesn't understand. */
    domain &= RADEON_DOMAIN_VRAM_GTT;

    /* If no domain is set, we must set something... */
    if (!domain)
        domain = RADEON_DOMAIN_VRAM_GTT;

    return domain;
}

static enum radeon_bo_domain radeon_bo_get_initial_domain(
		struct radeon_winsys_cs_handle *buf)
{
    struct radeon_bo *bo = (struct radeon_bo*)buf;
    struct drm_radeon_gem_op args;

    if (bo->rws->info.drm_minor < 38)
        return RADEON_DOMAIN_VRAM_GTT;

    memset(&args, 0, sizeof(args));
    args.handle = bo->handle;
    args.op = RADEON_GEM_OP_GET_INITIAL_DOMAIN;

    drmCommandWriteRead(bo->rws->fd, DRM_RADEON_GEM_OP,
                        &args, sizeof(args));

    /* GEM domains and winsys domains are defined the same. */
    return get_valid_domain(args.value);
}

static uint64_t radeon_bomgr_find_va(struct radeon_bomgr *mgr, uint64_t size, uint64_t alignment)
{
    struct radeon_bo_va_hole *hole, *n;
    uint64_t offset = 0, waste = 0;

    /* All VM address space holes will implicitly start aligned to the
     * size alignment, so we don't need to sanitize the alignment here
     */
    size = align(size, mgr->size_align);

    pipe_mutex_lock(mgr->bo_va_mutex);
    /* first look for a hole */
    LIST_FOR_EACH_ENTRY_SAFE(hole, n, &mgr->va_holes, list) {
        offset = hole->offset;
        waste = offset % alignment;
        waste = waste ? alignment - waste : 0;
        offset += waste;
        if (offset >= (hole->offset + hole->size)) {
            continue;
        }
        if (!waste && hole->size == size) {
            offset = hole->offset;
            list_del(&hole->list);
            FREE(hole);
            pipe_mutex_unlock(mgr->bo_va_mutex);
            return offset;
        }
        if ((hole->size - waste) > size) {
            if (waste) {
                n = CALLOC_STRUCT(radeon_bo_va_hole);
                n->size = waste;
                n->offset = hole->offset;
                list_add(&n->list, &hole->list);
            }
            hole->size -= (size + waste);
            hole->offset += size + waste;
            pipe_mutex_unlock(mgr->bo_va_mutex);
            return offset;
        }
        if ((hole->size - waste) == size) {
            hole->size = waste;
            pipe_mutex_unlock(mgr->bo_va_mutex);
            return offset;
        }
    }

    offset = mgr->va_offset;
    waste = offset % alignment;
    waste = waste ? alignment - waste : 0;
    if (waste) {
        n = CALLOC_STRUCT(radeon_bo_va_hole);
        n->size = waste;
        n->offset = offset;
        list_add(&n->list, &mgr->va_holes);
    }
    offset += waste;
    mgr->va_offset += size + waste;
    pipe_mutex_unlock(mgr->bo_va_mutex);
    return offset;
}

static void radeon_bomgr_free_va(struct radeon_bomgr *mgr, uint64_t va, uint64_t size)
{
    struct radeon_bo_va_hole *hole;

    size = align(size, mgr->size_align);

    pipe_mutex_lock(mgr->bo_va_mutex);
    if ((va + size) == mgr->va_offset) {
        mgr->va_offset = va;
        /* Delete uppermost hole if it reaches the new top */
        if (!LIST_IS_EMPTY(&mgr->va_holes)) {
            hole = container_of(mgr->va_holes.next, hole, list);
            if ((hole->offset + hole->size) == va) {
                mgr->va_offset = hole->offset;
                list_del(&hole->list);
                FREE(hole);
            }
        }
    } else {
        struct radeon_bo_va_hole *next;

        hole = container_of(&mgr->va_holes, hole, list);
        LIST_FOR_EACH_ENTRY(next, &mgr->va_holes, list) {
	    if (next->offset < va)
	        break;
            hole = next;
        }

        if (&hole->list != &mgr->va_holes) {
            /* Grow upper hole if it's adjacent */
            if (hole->offset == (va + size)) {
                hole->offset = va;
                hole->size += size;
                /* Merge lower hole if it's adjacent */
                if (next != hole && &next->list != &mgr->va_holes &&
                    (next->offset + next->size) == va) {
                    next->size += hole->size;
                    list_del(&hole->list);
                    FREE(hole);
                }
                goto out;
            }
        }

        /* Grow lower hole if it's adjacent */
        if (next != hole && &next->list != &mgr->va_holes &&
            (next->offset + next->size) == va) {
            next->size += size;
            goto out;
        }

        /* FIXME on allocation failure we just lose virtual address space
         * maybe print a warning
         */
        next = CALLOC_STRUCT(radeon_bo_va_hole);
        if (next) {
            next->size = size;
            next->offset = va;
            list_add(&next->list, &hole->list);
        }
    }
out:
    pipe_mutex_unlock(mgr->bo_va_mutex);
}

static void radeon_bo_destroy(struct pb_buffer *_buf)
{
    struct radeon_bo *bo = radeon_bo(_buf);
    struct radeon_bomgr *mgr = bo->mgr;
    struct drm_gem_close args;

    memset(&args, 0, sizeof(args));

    pipe_mutex_lock(bo->mgr->bo_handles_mutex);
    util_hash_table_remove(bo->mgr->bo_handles, (void*)(uintptr_t)bo->handle);
    if (bo->flink_name) {
        util_hash_table_remove(bo->mgr->bo_names,
                               (void*)(uintptr_t)bo->flink_name);
    }
    pipe_mutex_unlock(bo->mgr->bo_handles_mutex);

    if (bo->ptr)
        os_munmap(bo->ptr, bo->base.size);

    if (mgr->va) {
        if (bo->rws->va_unmap_working) {
            struct drm_radeon_gem_va va;

            va.handle = bo->handle;
            va.vm_id = 0;
            va.operation = RADEON_VA_UNMAP;
            va.flags = RADEON_VM_PAGE_READABLE |
                       RADEON_VM_PAGE_WRITEABLE |
                       RADEON_VM_PAGE_SNOOPED;
            va.offset = bo->va;

            if (drmCommandWriteRead(bo->rws->fd, DRM_RADEON_GEM_VA, &va,
				    sizeof(va)) != 0 &&
		va.operation == RADEON_VA_RESULT_ERROR) {
                fprintf(stderr, "radeon: Failed to deallocate virtual address for buffer:\n");
                fprintf(stderr, "radeon:    size      : %d bytes\n", bo->base.size);
                fprintf(stderr, "radeon:    va        : 0x%016llx\n", (unsigned long long)bo->va);
            }
	}

	radeon_bomgr_free_va(mgr, bo->va, bo->base.size);
    }

    /* Close object. */
    args.handle = bo->handle;
    drmIoctl(bo->rws->fd, DRM_IOCTL_GEM_CLOSE, &args);

    pipe_mutex_destroy(bo->map_mutex);

    if (bo->initial_domain & RADEON_DOMAIN_VRAM)
        bo->rws->allocated_vram -= align(bo->base.size, mgr->size_align);
    else if (bo->initial_domain & RADEON_DOMAIN_GTT)
        bo->rws->allocated_gtt -= align(bo->base.size, mgr->size_align);
    FREE(bo);
}

void *radeon_bo_do_map(struct radeon_bo *bo)
{
    struct drm_radeon_gem_mmap args = {0};
    void *ptr;

    /* If the buffer is created from user memory, return the user pointer. */
    if (bo->user_ptr)
        return bo->user_ptr;

    /* Map the buffer. */
    pipe_mutex_lock(bo->map_mutex);
    /* Return the pointer if it's already mapped. */
    if (bo->ptr) {
        bo->map_count++;
        pipe_mutex_unlock(bo->map_mutex);
        return bo->ptr;
    }
    args.handle = bo->handle;
    args.offset = 0;
    args.size = (uint64_t)bo->base.size;
    if (drmCommandWriteRead(bo->rws->fd,
                            DRM_RADEON_GEM_MMAP,
                            &args,
                            sizeof(args))) {
        pipe_mutex_unlock(bo->map_mutex);
        fprintf(stderr, "radeon: gem_mmap failed: %p 0x%08X\n",
                bo, bo->handle);
        return NULL;
    }

    ptr = os_mmap(0, args.size, PROT_READ|PROT_WRITE, MAP_SHARED,
               bo->rws->fd, args.addr_ptr);
    if (ptr == MAP_FAILED) {
        pipe_mutex_unlock(bo->map_mutex);
        fprintf(stderr, "radeon: mmap failed, errno: %i\n", errno);
        return NULL;
    }
    bo->ptr = ptr;
    bo->map_count = 1;
    pipe_mutex_unlock(bo->map_mutex);

    return bo->ptr;
}

static void *radeon_bo_map(struct radeon_winsys_cs_handle *buf,
                           struct radeon_winsys_cs *rcs,
                           enum pipe_transfer_usage usage)
{
    struct radeon_bo *bo = (struct radeon_bo*)buf;
    struct radeon_drm_cs *cs = (struct radeon_drm_cs*)rcs;

    /* If it's not unsynchronized bo_map, flush CS if needed and then wait. */
    if (!(usage & PIPE_TRANSFER_UNSYNCHRONIZED)) {
        /* DONTBLOCK doesn't make sense with UNSYNCHRONIZED. */
        if (usage & PIPE_TRANSFER_DONTBLOCK) {
            if (!(usage & PIPE_TRANSFER_WRITE)) {
                /* Mapping for read.
                 *
                 * Since we are mapping for read, we don't need to wait
                 * if the GPU is using the buffer for read too
                 * (neither one is changing it).
                 *
                 * Only check whether the buffer is being used for write. */
                if (cs && radeon_bo_is_referenced_by_cs_for_write(cs, bo)) {
                    cs->flush_cs(cs->flush_data, RADEON_FLUSH_ASYNC, NULL);
                    return NULL;
                }

                if (!radeon_bo_wait((struct pb_buffer*)bo, 0,
                                    RADEON_USAGE_WRITE)) {
                    return NULL;
                }
            } else {
                if (cs && radeon_bo_is_referenced_by_cs(cs, bo)) {
                    cs->flush_cs(cs->flush_data, RADEON_FLUSH_ASYNC, NULL);
                    return NULL;
                }

                if (!radeon_bo_wait((struct pb_buffer*)bo, 0,
                                    RADEON_USAGE_READWRITE)) {
                    return NULL;
                }
            }
        } else {
            uint64_t time = os_time_get_nano();

            if (!(usage & PIPE_TRANSFER_WRITE)) {
                /* Mapping for read.
                 *
                 * Since we are mapping for read, we don't need to wait
                 * if the GPU is using the buffer for read too
                 * (neither one is changing it).
                 *
                 * Only check whether the buffer is being used for write. */
                if (cs && radeon_bo_is_referenced_by_cs_for_write(cs, bo)) {
                    cs->flush_cs(cs->flush_data, 0, NULL);
                }
                radeon_bo_wait((struct pb_buffer*)bo, PIPE_TIMEOUT_INFINITE,
                               RADEON_USAGE_WRITE);
            } else {
                /* Mapping for write. */
                if (cs) {
                    if (radeon_bo_is_referenced_by_cs(cs, bo)) {
                        cs->flush_cs(cs->flush_data, 0, NULL);
                    } else {
                        /* Try to avoid busy-waiting in radeon_bo_wait. */
                        if (p_atomic_read(&bo->num_active_ioctls))
                            radeon_drm_cs_sync_flush(rcs);
                    }
                }

                radeon_bo_wait((struct pb_buffer*)bo, PIPE_TIMEOUT_INFINITE,
                               RADEON_USAGE_READWRITE);
            }

            bo->mgr->rws->buffer_wait_time += os_time_get_nano() - time;
        }
    }

    return radeon_bo_do_map(bo);
}

static void radeon_bo_unmap(struct radeon_winsys_cs_handle *_buf)
{
    struct radeon_bo *bo = (struct radeon_bo*)_buf;

    if (bo->user_ptr)
        return;

    pipe_mutex_lock(bo->map_mutex);
    if (!bo->ptr) {
        pipe_mutex_unlock(bo->map_mutex);
        return; /* it's not been mapped */
    }

    assert(bo->map_count);
    if (--bo->map_count) {
        pipe_mutex_unlock(bo->map_mutex);
        return; /* it's been mapped multiple times */
    }

    os_munmap(bo->ptr, bo->base.size);
    bo->ptr = NULL;
    pipe_mutex_unlock(bo->map_mutex);
}

static void radeon_bo_get_base_buffer(struct pb_buffer *buf,
                                      struct pb_buffer **base_buf,
                                      unsigned *offset)
{
    *base_buf = buf;
    *offset = 0;
}

static enum pipe_error radeon_bo_validate(struct pb_buffer *_buf,
                                          struct pb_validate *vl,
                                          unsigned flags)
{
    /* Always pinned */
    return PIPE_OK;
}

static void radeon_bo_fence(struct pb_buffer *buf,
                            struct pipe_fence_handle *fence)
{
}

static const struct pb_vtbl radeon_bo_vtbl = {
    radeon_bo_destroy,
    NULL, /* never called */
    NULL, /* never called */
    radeon_bo_validate,
    radeon_bo_fence,
    radeon_bo_get_base_buffer,
};

#ifndef RADEON_GEM_GTT_WC
#define RADEON_GEM_GTT_WC		(1 << 2)
#endif
#ifndef RADEON_GEM_CPU_ACCESS
/* BO is expected to be accessed by the CPU */
#define RADEON_GEM_CPU_ACCESS		(1 << 3)
#endif
#ifndef RADEON_GEM_NO_CPU_ACCESS
/* CPU access is not expected to work for this BO */
#define RADEON_GEM_NO_CPU_ACCESS	(1 << 4)
#endif

static struct pb_buffer *radeon_bomgr_create_bo(struct pb_manager *_mgr,
                                                pb_size size,
                                                const struct pb_desc *desc)
{
    struct radeon_bomgr *mgr = radeon_bomgr(_mgr);
    struct radeon_drm_winsys *rws = mgr->rws;
    struct radeon_bo *bo;
    struct drm_radeon_gem_create args;
    struct radeon_bo_desc *rdesc = (struct radeon_bo_desc*)desc;
    int r;

    memset(&args, 0, sizeof(args));

    assert(rdesc->initial_domains);
    assert((rdesc->initial_domains &
            ~(RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM)) == 0);

    args.size = size;
    args.alignment = desc->alignment;
    args.initial_domain = rdesc->initial_domains;
    args.flags = 0;

    if (rdesc->flags & RADEON_FLAG_GTT_WC)
        args.flags |= RADEON_GEM_GTT_WC;
    if (rdesc->flags & RADEON_FLAG_CPU_ACCESS)
        args.flags |= RADEON_GEM_CPU_ACCESS;
    if (rdesc->flags & RADEON_FLAG_NO_CPU_ACCESS)
        args.flags |= RADEON_GEM_NO_CPU_ACCESS;

    if (drmCommandWriteRead(rws->fd, DRM_RADEON_GEM_CREATE,
                            &args, sizeof(args))) {
        fprintf(stderr, "radeon: Failed to allocate a buffer:\n");
        fprintf(stderr, "radeon:    size      : %d bytes\n", size);
        fprintf(stderr, "radeon:    alignment : %d bytes\n", desc->alignment);
        fprintf(stderr, "radeon:    domains   : %d\n", args.initial_domain);
        fprintf(stderr, "radeon:    flags     : %d\n", args.flags);
        return NULL;
    }

    bo = CALLOC_STRUCT(radeon_bo);
    if (!bo)
        return NULL;

    pipe_reference_init(&bo->base.reference, 1);
    bo->base.alignment = desc->alignment;
    bo->base.usage = desc->usage;
    bo->base.size = size;
    bo->base.vtbl = &radeon_bo_vtbl;
    bo->mgr = mgr;
    bo->rws = mgr->rws;
    bo->handle = args.handle;
    bo->va = 0;
    bo->initial_domain = rdesc->initial_domains;
    pipe_mutex_init(bo->map_mutex);

    if (mgr->va) {
        struct drm_radeon_gem_va va;

        bo->va = radeon_bomgr_find_va(mgr, size, desc->alignment);

        va.handle = bo->handle;
        va.vm_id = 0;
        va.operation = RADEON_VA_MAP;
        va.flags = RADEON_VM_PAGE_READABLE |
                   RADEON_VM_PAGE_WRITEABLE |
                   RADEON_VM_PAGE_SNOOPED;
        va.offset = bo->va;
        r = drmCommandWriteRead(rws->fd, DRM_RADEON_GEM_VA, &va, sizeof(va));
        if (r && va.operation == RADEON_VA_RESULT_ERROR) {
            fprintf(stderr, "radeon: Failed to allocate virtual address for buffer:\n");
            fprintf(stderr, "radeon:    size      : %d bytes\n", size);
            fprintf(stderr, "radeon:    alignment : %d bytes\n", desc->alignment);
            fprintf(stderr, "radeon:    domains   : %d\n", args.initial_domain);
            fprintf(stderr, "radeon:    va        : 0x%016llx\n", (unsigned long long)bo->va);
            radeon_bo_destroy(&bo->base);
            return NULL;
        }
        pipe_mutex_lock(mgr->bo_handles_mutex);
        if (va.operation == RADEON_VA_RESULT_VA_EXIST) {
            struct pb_buffer *b = &bo->base;
            struct radeon_bo *old_bo =
                util_hash_table_get(mgr->bo_vas, (void*)(uintptr_t)va.offset);

            pipe_mutex_unlock(mgr->bo_handles_mutex);
            pb_reference(&b, &old_bo->base);
            return b;
        }

        util_hash_table_set(mgr->bo_vas, (void*)(uintptr_t)bo->va, bo);
        pipe_mutex_unlock(mgr->bo_handles_mutex);
    }

    if (rdesc->initial_domains & RADEON_DOMAIN_VRAM)
        rws->allocated_vram += align(size, mgr->size_align);
    else if (rdesc->initial_domains & RADEON_DOMAIN_GTT)
        rws->allocated_gtt += align(size, mgr->size_align);

    return &bo->base;
}

static void radeon_bomgr_flush(struct pb_manager *mgr)
{
    /* NOP */
}

/* This is for the cache bufmgr. */
static boolean radeon_bomgr_is_buffer_busy(struct pb_manager *_mgr,
                                           struct pb_buffer *_buf)
{
   struct radeon_bo *bo = radeon_bo(_buf);

   if (radeon_bo_is_referenced_by_any_cs(bo)) {
       return TRUE;
   }

   if (!radeon_bo_wait((struct pb_buffer*)bo, 0, RADEON_USAGE_READWRITE)) {
       return TRUE;
   }

   return FALSE;
}

static void radeon_bomgr_destroy(struct pb_manager *_mgr)
{
    struct radeon_bomgr *mgr = radeon_bomgr(_mgr);
    util_hash_table_destroy(mgr->bo_names);
    util_hash_table_destroy(mgr->bo_handles);
    util_hash_table_destroy(mgr->bo_vas);
    pipe_mutex_destroy(mgr->bo_handles_mutex);
    pipe_mutex_destroy(mgr->bo_va_mutex);
    FREE(mgr);
}

#define PTR_TO_UINT(x) ((unsigned)((intptr_t)(x)))

static unsigned handle_hash(void *key)
{
    return PTR_TO_UINT(key);
}

static int handle_compare(void *key1, void *key2)
{
    return PTR_TO_UINT(key1) != PTR_TO_UINT(key2);
}

struct pb_manager *radeon_bomgr_create(struct radeon_drm_winsys *rws)
{
    struct radeon_bomgr *mgr;

    mgr = CALLOC_STRUCT(radeon_bomgr);
    if (!mgr)
        return NULL;

    mgr->base.destroy = radeon_bomgr_destroy;
    mgr->base.create_buffer = radeon_bomgr_create_bo;
    mgr->base.flush = radeon_bomgr_flush;
    mgr->base.is_buffer_busy = radeon_bomgr_is_buffer_busy;

    mgr->rws = rws;
    mgr->bo_names = util_hash_table_create(handle_hash, handle_compare);
    mgr->bo_handles = util_hash_table_create(handle_hash, handle_compare);
    mgr->bo_vas = util_hash_table_create(handle_hash, handle_compare);
    pipe_mutex_init(mgr->bo_handles_mutex);
    pipe_mutex_init(mgr->bo_va_mutex);

    mgr->va = rws->info.r600_virtual_address;
    mgr->va_offset = rws->va_start;
    list_inithead(&mgr->va_holes);

    /* TTM aligns the BO size to the CPU page size */
    mgr->size_align = sysconf(_SC_PAGESIZE);

    return &mgr->base;
}

static unsigned eg_tile_split(unsigned tile_split)
{
    switch (tile_split) {
    case 0:     tile_split = 64;    break;
    case 1:     tile_split = 128;   break;
    case 2:     tile_split = 256;   break;
    case 3:     tile_split = 512;   break;
    default:
    case 4:     tile_split = 1024;  break;
    case 5:     tile_split = 2048;  break;
    case 6:     tile_split = 4096;  break;
    }
    return tile_split;
}

static unsigned eg_tile_split_rev(unsigned eg_tile_split)
{
    switch (eg_tile_split) {
    case 64:    return 0;
    case 128:   return 1;
    case 256:   return 2;
    case 512:   return 3;
    default:
    case 1024:  return 4;
    case 2048:  return 5;
    case 4096:  return 6;
    }
}

static void radeon_bo_get_tiling(struct pb_buffer *_buf,
                                 enum radeon_bo_layout *microtiled,
                                 enum radeon_bo_layout *macrotiled,
                                 unsigned *bankw, unsigned *bankh,
                                 unsigned *tile_split,
                                 unsigned *stencil_tile_split,
                                 unsigned *mtilea,
                                 bool *scanout)
{
    struct radeon_bo *bo = get_radeon_bo(_buf);
    struct drm_radeon_gem_set_tiling args;

    memset(&args, 0, sizeof(args));

    args.handle = bo->handle;

    drmCommandWriteRead(bo->rws->fd,
                        DRM_RADEON_GEM_GET_TILING,
                        &args,
                        sizeof(args));

    *microtiled = RADEON_LAYOUT_LINEAR;
    *macrotiled = RADEON_LAYOUT_LINEAR;
    if (args.tiling_flags & RADEON_TILING_MICRO)
        *microtiled = RADEON_LAYOUT_TILED;
    else if (args.tiling_flags & RADEON_TILING_MICRO_SQUARE)
        *microtiled = RADEON_LAYOUT_SQUARETILED;

    if (args.tiling_flags & RADEON_TILING_MACRO)
        *macrotiled = RADEON_LAYOUT_TILED;
    if (bankw && tile_split && stencil_tile_split && mtilea && tile_split) {
        *bankw = (args.tiling_flags >> RADEON_TILING_EG_BANKW_SHIFT) & RADEON_TILING_EG_BANKW_MASK;
        *bankh = (args.tiling_flags >> RADEON_TILING_EG_BANKH_SHIFT) & RADEON_TILING_EG_BANKH_MASK;
        *tile_split = (args.tiling_flags >> RADEON_TILING_EG_TILE_SPLIT_SHIFT) & RADEON_TILING_EG_TILE_SPLIT_MASK;
        *stencil_tile_split = (args.tiling_flags >> RADEON_TILING_EG_STENCIL_TILE_SPLIT_SHIFT) & RADEON_TILING_EG_STENCIL_TILE_SPLIT_MASK;
        *mtilea = (args.tiling_flags >> RADEON_TILING_EG_MACRO_TILE_ASPECT_SHIFT) & RADEON_TILING_EG_MACRO_TILE_ASPECT_MASK;
        *tile_split = eg_tile_split(*tile_split);
    }
    if (scanout)
        *scanout = bo->rws->gen >= DRV_SI && !(args.tiling_flags & RADEON_TILING_R600_NO_SCANOUT);
}

static void radeon_bo_set_tiling(struct pb_buffer *_buf,
                                 struct radeon_winsys_cs *rcs,
                                 enum radeon_bo_layout microtiled,
                                 enum radeon_bo_layout macrotiled,
                                 unsigned pipe_config,
                                 unsigned bankw, unsigned bankh,
                                 unsigned tile_split,
                                 unsigned stencil_tile_split,
                                 unsigned mtilea, unsigned num_banks,
                                 uint32_t pitch,
                                 bool scanout)
{
    struct radeon_bo *bo = get_radeon_bo(_buf);
    struct radeon_drm_cs *cs = radeon_drm_cs(rcs);
    struct drm_radeon_gem_set_tiling args;

    memset(&args, 0, sizeof(args));

    /* Tiling determines how DRM treats the buffer data.
     * We must flush CS when changing it if the buffer is referenced. */
    if (cs && radeon_bo_is_referenced_by_cs(cs, bo)) {
        cs->flush_cs(cs->flush_data, 0, NULL);
    }

    os_wait_until_zero(&bo->num_active_ioctls, PIPE_TIMEOUT_INFINITE);

    if (microtiled == RADEON_LAYOUT_TILED)
        args.tiling_flags |= RADEON_TILING_MICRO;
    else if (microtiled == RADEON_LAYOUT_SQUARETILED)
        args.tiling_flags |= RADEON_TILING_MICRO_SQUARE;

    if (macrotiled == RADEON_LAYOUT_TILED)
        args.tiling_flags |= RADEON_TILING_MACRO;

    args.tiling_flags |= (bankw & RADEON_TILING_EG_BANKW_MASK) <<
        RADEON_TILING_EG_BANKW_SHIFT;
    args.tiling_flags |= (bankh & RADEON_TILING_EG_BANKH_MASK) <<
        RADEON_TILING_EG_BANKH_SHIFT;
    if (tile_split) {
	args.tiling_flags |= (eg_tile_split_rev(tile_split) &
			      RADEON_TILING_EG_TILE_SPLIT_MASK) <<
	    RADEON_TILING_EG_TILE_SPLIT_SHIFT;
    }
    args.tiling_flags |= (stencil_tile_split &
			  RADEON_TILING_EG_STENCIL_TILE_SPLIT_MASK) <<
        RADEON_TILING_EG_STENCIL_TILE_SPLIT_SHIFT;
    args.tiling_flags |= (mtilea & RADEON_TILING_EG_MACRO_TILE_ASPECT_MASK) <<
        RADEON_TILING_EG_MACRO_TILE_ASPECT_SHIFT;

    if (bo->rws->gen >= DRV_SI && !scanout)
        args.tiling_flags |= RADEON_TILING_R600_NO_SCANOUT;

    args.handle = bo->handle;
    args.pitch = pitch;

    drmCommandWriteRead(bo->rws->fd,
                        DRM_RADEON_GEM_SET_TILING,
                        &args,
                        sizeof(args));
}

static struct radeon_winsys_cs_handle *radeon_drm_get_cs_handle(struct pb_buffer *_buf)
{
    /* return radeon_bo. */
    return (struct radeon_winsys_cs_handle*)get_radeon_bo(_buf);
}

static struct pb_buffer *
radeon_winsys_bo_create(struct radeon_winsys *rws,
                        unsigned size,
                        unsigned alignment,
                        boolean use_reusable_pool,
                        enum radeon_bo_domain domain,
                        enum radeon_bo_flag flags)
{
    struct radeon_drm_winsys *ws = radeon_drm_winsys(rws);
    struct radeon_bomgr *mgr = radeon_bomgr(ws->kman);
    struct radeon_bo_desc desc;
    struct pb_manager *provider;
    struct pb_buffer *buffer;

    memset(&desc, 0, sizeof(desc));
    desc.base.alignment = alignment;

    /* Align size to page size. This is the minimum alignment for normal
     * BOs. Aligning this here helps the cached bufmgr. Especially small BOs,
     * like constant/uniform buffers, can benefit from better and more reuse.
     */
    size = align(size, mgr->size_align);

    /* Only set one usage bit each for domains and flags, or the cache manager
     * might consider different sets of domains / flags compatible
     */
    if (domain == RADEON_DOMAIN_VRAM_GTT)
        desc.base.usage = 1 << 2;
    else
        desc.base.usage = domain >> 1;
    assert(flags < sizeof(desc.base.usage) * 8 - 3);
    desc.base.usage |= 1 << (flags + 3);

    desc.initial_domains = domain;
    desc.flags = flags;

    /* Assign a buffer manager. */
    if (use_reusable_pool)
        provider = ws->cman;
    else
        provider = ws->kman;

    buffer = provider->create_buffer(provider, size, &desc.base);
    if (!buffer)
        return NULL;

    pipe_mutex_lock(mgr->bo_handles_mutex);
    util_hash_table_set(mgr->bo_handles, (void*)(uintptr_t)get_radeon_bo(buffer)->handle, buffer);
    pipe_mutex_unlock(mgr->bo_handles_mutex);

    return (struct pb_buffer*)buffer;
}

static struct pb_buffer *radeon_winsys_bo_from_ptr(struct radeon_winsys *rws,
                                                   void *pointer, unsigned size)
{
    struct radeon_drm_winsys *ws = radeon_drm_winsys(rws);
    struct radeon_bomgr *mgr = radeon_bomgr(ws->kman);
    struct drm_radeon_gem_userptr args;
    struct radeon_bo *bo;
    int r;

    bo = CALLOC_STRUCT(radeon_bo);
    if (!bo)
        return NULL;

    memset(&args, 0, sizeof(args));
    args.addr = (uintptr_t)pointer;
    args.size = align(size, sysconf(_SC_PAGE_SIZE));
    args.flags = RADEON_GEM_USERPTR_ANONONLY |
        RADEON_GEM_USERPTR_VALIDATE |
        RADEON_GEM_USERPTR_REGISTER;
    if (drmCommandWriteRead(ws->fd, DRM_RADEON_GEM_USERPTR,
                            &args, sizeof(args))) {
        FREE(bo);
        return NULL;
    }

    pipe_mutex_lock(mgr->bo_handles_mutex);

    /* Initialize it. */
    pipe_reference_init(&bo->base.reference, 1);
    bo->handle = args.handle;
    bo->base.alignment = 0;
    bo->base.usage = PB_USAGE_GPU_WRITE | PB_USAGE_GPU_READ;
    bo->base.size = size;
    bo->base.vtbl = &radeon_bo_vtbl;
    bo->mgr = mgr;
    bo->rws = mgr->rws;
    bo->user_ptr = pointer;
    bo->va = 0;
    bo->initial_domain = RADEON_DOMAIN_GTT;
    pipe_mutex_init(bo->map_mutex);

    util_hash_table_set(mgr->bo_handles, (void*)(uintptr_t)bo->handle, bo);

    pipe_mutex_unlock(mgr->bo_handles_mutex);

    if (mgr->va) {
        struct drm_radeon_gem_va va;

        bo->va = radeon_bomgr_find_va(mgr, bo->base.size, 1 << 20);

        va.handle = bo->handle;
        va.operation = RADEON_VA_MAP;
        va.vm_id = 0;
        va.offset = bo->va;
        va.flags = RADEON_VM_PAGE_READABLE |
                   RADEON_VM_PAGE_WRITEABLE |
                   RADEON_VM_PAGE_SNOOPED;
        va.offset = bo->va;
        r = drmCommandWriteRead(ws->fd, DRM_RADEON_GEM_VA, &va, sizeof(va));
        if (r && va.operation == RADEON_VA_RESULT_ERROR) {
            fprintf(stderr, "radeon: Failed to assign virtual address space\n");
            radeon_bo_destroy(&bo->base);
            return NULL;
        }
        pipe_mutex_lock(mgr->bo_handles_mutex);
        if (va.operation == RADEON_VA_RESULT_VA_EXIST) {
            struct pb_buffer *b = &bo->base;
            struct radeon_bo *old_bo =
                util_hash_table_get(mgr->bo_vas, (void*)(uintptr_t)va.offset);

            pipe_mutex_unlock(mgr->bo_handles_mutex);
            pb_reference(&b, &old_bo->base);
            return b;
        }

        util_hash_table_set(mgr->bo_vas, (void*)(uintptr_t)bo->va, bo);
        pipe_mutex_unlock(mgr->bo_handles_mutex);
    }

    ws->allocated_gtt += align(bo->base.size, mgr->size_align);

    return (struct pb_buffer*)bo;
}

static struct pb_buffer *radeon_winsys_bo_from_handle(struct radeon_winsys *rws,
                                                      struct winsys_handle *whandle,
                                                      unsigned *stride)
{
    struct radeon_drm_winsys *ws = radeon_drm_winsys(rws);
    struct radeon_bo *bo;
    struct radeon_bomgr *mgr = radeon_bomgr(ws->kman);
    int r;
    unsigned handle;
    uint64_t size = 0;

    /* We must maintain a list of pairs <handle, bo>, so that we always return
     * the same BO for one particular handle. If we didn't do that and created
     * more than one BO for the same handle and then relocated them in a CS,
     * we would hit a deadlock in the kernel.
     *
     * The list of pairs is guarded by a mutex, of course. */
    pipe_mutex_lock(mgr->bo_handles_mutex);

    if (whandle->type == DRM_API_HANDLE_TYPE_SHARED) {
        /* First check if there already is an existing bo for the handle. */
        bo = util_hash_table_get(mgr->bo_names, (void*)(uintptr_t)whandle->handle);
    } else if (whandle->type == DRM_API_HANDLE_TYPE_FD) {
        /* We must first get the GEM handle, as fds are unreliable keys */
        r = drmPrimeFDToHandle(ws->fd, whandle->handle, &handle);
        if (r)
            goto fail;
        bo = util_hash_table_get(mgr->bo_handles, (void*)(uintptr_t)handle);
    } else {
        /* Unknown handle type */
        goto fail;
    }

    if (bo) {
        /* Increase the refcount. */
        struct pb_buffer *b = NULL;
        pb_reference(&b, &bo->base);
        goto done;
    }

    /* There isn't, create a new one. */
    bo = CALLOC_STRUCT(radeon_bo);
    if (!bo) {
        goto fail;
    }

    if (whandle->type == DRM_API_HANDLE_TYPE_SHARED) {
        struct drm_gem_open open_arg = {};
        memset(&open_arg, 0, sizeof(open_arg));
        /* Open the BO. */
        open_arg.name = whandle->handle;
        if (drmIoctl(ws->fd, DRM_IOCTL_GEM_OPEN, &open_arg)) {
            FREE(bo);
            goto fail;
        }
        handle = open_arg.handle;
        size = open_arg.size;
        bo->flink_name = whandle->handle;
    } else if (whandle->type == DRM_API_HANDLE_TYPE_FD) {
        size = lseek(whandle->handle, 0, SEEK_END);
        /* 
         * Could check errno to determine whether the kernel is new enough, but
         * it doesn't really matter why this failed, just that it failed.
         */
        if (size == (off_t)-1) {
            FREE(bo);
            goto fail;
        }
        lseek(whandle->handle, 0, SEEK_SET);
    }

    bo->handle = handle;

    /* Initialize it. */
    pipe_reference_init(&bo->base.reference, 1);
    bo->base.alignment = 0;
    bo->base.usage = PB_USAGE_GPU_WRITE | PB_USAGE_GPU_READ;
    bo->base.size = (unsigned) size;
    bo->base.vtbl = &radeon_bo_vtbl;
    bo->mgr = mgr;
    bo->rws = mgr->rws;
    bo->va = 0;
    pipe_mutex_init(bo->map_mutex);

    if (bo->flink_name)
        util_hash_table_set(mgr->bo_names, (void*)(uintptr_t)bo->flink_name, bo);

    util_hash_table_set(mgr->bo_handles, (void*)(uintptr_t)bo->handle, bo);

done:
    pipe_mutex_unlock(mgr->bo_handles_mutex);

    if (stride)
        *stride = whandle->stride;

    if (mgr->va && !bo->va) {
        struct drm_radeon_gem_va va;

        bo->va = radeon_bomgr_find_va(mgr, bo->base.size, 1 << 20);

        va.handle = bo->handle;
        va.operation = RADEON_VA_MAP;
        va.vm_id = 0;
        va.offset = bo->va;
        va.flags = RADEON_VM_PAGE_READABLE |
                   RADEON_VM_PAGE_WRITEABLE |
                   RADEON_VM_PAGE_SNOOPED;
        va.offset = bo->va;
        r = drmCommandWriteRead(ws->fd, DRM_RADEON_GEM_VA, &va, sizeof(va));
        if (r && va.operation == RADEON_VA_RESULT_ERROR) {
            fprintf(stderr, "radeon: Failed to assign virtual address space\n");
            radeon_bo_destroy(&bo->base);
            return NULL;
        }
        pipe_mutex_lock(mgr->bo_handles_mutex);
        if (va.operation == RADEON_VA_RESULT_VA_EXIST) {
            struct pb_buffer *b = &bo->base;
            struct radeon_bo *old_bo =
                util_hash_table_get(mgr->bo_vas, (void*)(uintptr_t)va.offset);

            pipe_mutex_unlock(mgr->bo_handles_mutex);
            pb_reference(&b, &old_bo->base);
            return b;
        }

        util_hash_table_set(mgr->bo_vas, (void*)(uintptr_t)bo->va, bo);
        pipe_mutex_unlock(mgr->bo_handles_mutex);
    }

    bo->initial_domain = radeon_bo_get_initial_domain((void*)bo);

    if (bo->initial_domain & RADEON_DOMAIN_VRAM)
        ws->allocated_vram += align(bo->base.size, mgr->size_align);
    else if (bo->initial_domain & RADEON_DOMAIN_GTT)
        ws->allocated_gtt += align(bo->base.size, mgr->size_align);

    return (struct pb_buffer*)bo;

fail:
    pipe_mutex_unlock(mgr->bo_handles_mutex);
    return NULL;
}

static boolean radeon_winsys_bo_get_handle(struct pb_buffer *buffer,
                                           unsigned stride,
                                           struct winsys_handle *whandle)
{
    struct drm_gem_flink flink;
    struct radeon_bo *bo = get_radeon_bo(buffer);

    memset(&flink, 0, sizeof(flink));

    if ((void*)bo != (void*)buffer)
       pb_cache_manager_remove_buffer(buffer);

    if (whandle->type == DRM_API_HANDLE_TYPE_SHARED) {
        if (!bo->flink_name) {
            flink.handle = bo->handle;

            if (ioctl(bo->rws->fd, DRM_IOCTL_GEM_FLINK, &flink)) {
                return FALSE;
            }

            bo->flink_name = flink.name;

            pipe_mutex_lock(bo->mgr->bo_handles_mutex);
            util_hash_table_set(bo->mgr->bo_names, (void*)(uintptr_t)bo->flink_name, bo);
            pipe_mutex_unlock(bo->mgr->bo_handles_mutex);
        }
        whandle->handle = bo->flink_name;
    } else if (whandle->type == DRM_API_HANDLE_TYPE_KMS) {
        whandle->handle = bo->handle;
    } else if (whandle->type == DRM_API_HANDLE_TYPE_FD) {
        if (drmPrimeHandleToFD(bo->rws->fd, bo->handle, DRM_CLOEXEC, (int*)&whandle->handle))
            return FALSE;
    }

    whandle->stride = stride;
    return TRUE;
}

static uint64_t radeon_winsys_bo_va(struct radeon_winsys_cs_handle *buf)
{
    return ((struct radeon_bo*)buf)->va;
}

void radeon_bomgr_init_functions(struct radeon_drm_winsys *ws)
{
    ws->base.buffer_get_cs_handle = radeon_drm_get_cs_handle;
    ws->base.buffer_set_tiling = radeon_bo_set_tiling;
    ws->base.buffer_get_tiling = radeon_bo_get_tiling;
    ws->base.buffer_map = radeon_bo_map;
    ws->base.buffer_unmap = radeon_bo_unmap;
    ws->base.buffer_wait = radeon_bo_wait;
    ws->base.buffer_create = radeon_winsys_bo_create;
    ws->base.buffer_from_handle = radeon_winsys_bo_from_handle;
    ws->base.buffer_from_ptr = radeon_winsys_bo_from_ptr;
    ws->base.buffer_get_handle = radeon_winsys_bo_get_handle;
    ws->base.buffer_get_virtual_address = radeon_winsys_bo_va;
    ws->base.buffer_get_initial_domain = radeon_bo_get_initial_domain;
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d32 1
d45 2
d49 1
d59 26
a84 1
static bool radeon_bo_is_busy(struct radeon_bo *bo)
d86 1
a86 5
    struct drm_radeon_gem_busy args = {0};

    args.handle = bo->handle;
    return drmCommandWriteRead(bo->rws->fd, DRM_RADEON_GEM_BUSY,
                               &args, sizeof(args)) != 0;
d89 1
a89 1
static void radeon_bo_wait_idle(struct radeon_bo *bo)
d91 1
a91 1
    struct drm_radeon_gem_wait_idle args = {0};
d93 12
a104 3
    args.handle = bo->handle;
    while (drmCommandWrite(bo->rws->fd, DRM_RADEON_GEM_WAIT_IDLE,
                           &args, sizeof(args)) == -EBUSY);
d110 1
a110 2
    struct radeon_bo *bo = radeon_bo(_buf);
    int64_t abs_timeout;
d112 3
a114 3
    /* No timeout. Just query. */
    if (timeout == 0)
        return !bo->num_active_ioctls && !radeon_bo_is_busy(bo);
d116 9
a124 5
    abs_timeout = os_time_get_absolute_timeout(timeout);

    /* Wait if any ioctl is being submitted with this buffer. */
    if (!os_wait_until_zero_abs_timeout(&bo->num_active_ioctls, abs_timeout))
        return false;
d126 3
a128 3
    /* Infinite timeout. */
    if (abs_timeout == PIPE_TIMEOUT_INFINITE) {
        radeon_bo_wait_idle(bo);
a130 9

    /* Other timeouts need to be emulated with a loop. */
    while (radeon_bo_is_busy(bo)) {
       if (os_time_get_nano() >= abs_timeout)
          return false;
       os_time_sleep(10);
    }

    return true;
d146 1
a146 1
		struct pb_buffer *buf)
d165 1
a165 2
static uint64_t radeon_bomgr_find_va(struct radeon_drm_winsys *rws,
                                     uint64_t size, uint64_t alignment)
d173 1
a173 1
    size = align(size, rws->size_align);
d175 1
a175 1
    pipe_mutex_lock(rws->bo_va_mutex);
d177 1
a177 1
    LIST_FOR_EACH_ENTRY_SAFE(hole, n, &rws->va_holes, list) {
d189 1
a189 1
            pipe_mutex_unlock(rws->bo_va_mutex);
d201 1
a201 1
            pipe_mutex_unlock(rws->bo_va_mutex);
d206 1
a206 1
            pipe_mutex_unlock(rws->bo_va_mutex);
d211 1
a211 1
    offset = rws->va_offset;
d218 1
a218 1
        list_add(&n->list, &rws->va_holes);
d221 2
a222 2
    rws->va_offset += size + waste;
    pipe_mutex_unlock(rws->bo_va_mutex);
d226 1
a226 2
static void radeon_bomgr_free_va(struct radeon_drm_winsys *rws,
                                 uint64_t va, uint64_t size)
d230 1
a230 1
    size = align(size, rws->size_align);
d232 3
a234 3
    pipe_mutex_lock(rws->bo_va_mutex);
    if ((va + size) == rws->va_offset) {
        rws->va_offset = va;
d236 2
a237 2
        if (!LIST_IS_EMPTY(&rws->va_holes)) {
            hole = container_of(rws->va_holes.next, hole, list);
d239 1
a239 1
                rws->va_offset = hole->offset;
d247 2
a248 2
        hole = container_of(&rws->va_holes, hole, list);
        LIST_FOR_EACH_ENTRY(next, &rws->va_holes, list) {
d254 1
a254 1
        if (&hole->list != &rws->va_holes) {
d260 1
a260 1
                if (next != hole && &next->list != &rws->va_holes &&
d271 1
a271 1
        if (next != hole && &next->list != &rws->va_holes &&
d288 1
a288 1
    pipe_mutex_unlock(rws->bo_va_mutex);
d291 1
a291 1
void radeon_bo_destroy(struct pb_buffer *_buf)
d294 1
a294 1
    struct radeon_drm_winsys *rws = bo->rws;
d299 2
a300 2
    pipe_mutex_lock(rws->bo_handles_mutex);
    util_hash_table_remove(rws->bo_handles, (void*)(uintptr_t)bo->handle);
d302 1
a302 1
        util_hash_table_remove(rws->bo_names,
d305 1
a305 1
    pipe_mutex_unlock(rws->bo_handles_mutex);
d310 2
a311 2
    if (rws->info.has_virtual_memory) {
        if (rws->va_unmap_working) {
d322 1
a322 1
            if (drmCommandWriteRead(rws->fd, DRM_RADEON_GEM_VA, &va,
d331 1
a331 1
	radeon_bomgr_free_va(rws, bo->va, bo->base.size);
d336 1
a336 1
    drmIoctl(rws->fd, DRM_IOCTL_GEM_CLOSE, &args);
d341 1
a341 1
        rws->allocated_vram -= align(bo->base.size, rws->size_align);
d343 1
a343 1
        rws->allocated_gtt -= align(bo->base.size, rws->size_align);
a346 10
static void radeon_bo_destroy_or_cache(struct pb_buffer *_buf)
{
   struct radeon_bo *bo = radeon_bo(_buf);

   if (bo->use_reusable_pool)
      pb_cache_add_buffer(&bo->cache_entry);
   else
      radeon_bo_destroy(_buf);
}

d380 3
a382 10
        /* Clear the cache and try again. */
        pb_cache_release_all_buffers(&bo->rws->bo_cache);

        ptr = os_mmap(0, args.size, PROT_READ|PROT_WRITE, MAP_SHARED,
                      bo->rws->fd, args.addr_ptr);
        if (ptr == MAP_FAILED) {
            pipe_mutex_unlock(bo->map_mutex);
            fprintf(stderr, "radeon: mmap failed, errno: %i\n", errno);
            return NULL;
        }
d391 1
a391 1
static void *radeon_bo_map(struct pb_buffer *buf,
d462 1
a462 1
            bo->rws->buffer_wait_time += os_time_get_nano() - time;
d469 1
a469 1
static void radeon_bo_unmap(struct pb_buffer *_buf)
d493 21
d515 6
a520 2
    radeon_bo_destroy_or_cache
    /* other functions are never called */
d535 3
a537 5
static struct radeon_bo *radeon_create_bo(struct radeon_drm_winsys *rws,
                                          unsigned size, unsigned alignment,
                                          unsigned usage,
                                          unsigned initial_domains,
                                          unsigned flags)
d539 2
d543 1
d548 2
a549 2
    assert(initial_domains);
    assert((initial_domains &
d553 2
a554 2
    args.alignment = alignment;
    args.initial_domain = initial_domains;
d557 1
a557 1
    if (flags & RADEON_FLAG_GTT_WC)
d559 1
a559 1
    if (flags & RADEON_FLAG_CPU_ACCESS)
d561 1
a561 1
    if (flags & RADEON_FLAG_NO_CPU_ACCESS)
d568 1
a568 1
        fprintf(stderr, "radeon:    alignment : %d bytes\n", alignment);
d579 2
a580 2
    bo->base.alignment = alignment;
    bo->base.usage = usage;
d583 2
a584 1
    bo->rws = rws;
d587 1
a587 1
    bo->initial_domain = initial_domains;
a588 1
    pb_cache_init_entry(&rws->bo_cache, &bo->cache_entry, &bo->base);
d590 1
a590 1
    if (rws->info.has_virtual_memory) {
d593 1
a593 1
        bo->va = radeon_bomgr_find_va(rws, size, alignment);
d606 1
a606 1
            fprintf(stderr, "radeon:    alignment : %d bytes\n", alignment);
d612 1
a612 1
        pipe_mutex_lock(rws->bo_handles_mutex);
d616 1
a616 1
                util_hash_table_get(rws->bo_vas, (void*)(uintptr_t)va.offset);
d618 1
a618 1
            pipe_mutex_unlock(rws->bo_handles_mutex);
d620 1
a620 1
            return radeon_bo(b);
d623 2
a624 2
        util_hash_table_set(rws->bo_vas, (void*)(uintptr_t)bo->va, bo);
        pipe_mutex_unlock(rws->bo_handles_mutex);
d627 4
a630 4
    if (initial_domains & RADEON_DOMAIN_VRAM)
        rws->allocated_vram += align(size, rws->size_align);
    else if (initial_domains & RADEON_DOMAIN_GTT)
        rws->allocated_gtt += align(size, rws->size_align);
d632 6
a637 1
    return bo;
d640 3
a642 1
bool radeon_bo_can_reclaim(struct pb_buffer *_buf)
d646 60
a705 2
   if (radeon_bo_is_referenced_by_any_cs(bo))
      return false;
d707 1
a707 1
   return radeon_bo_wait(_buf, 0, RADEON_USAGE_READWRITE);
d748 1
a748 1
    struct radeon_bo *bo = radeon_bo(_buf);
d793 1
a793 1
    struct radeon_bo *bo = radeon_bo(_buf);
d842 6
d857 7
a863 2
    struct radeon_bo *bo;
    unsigned usage = 0;
d869 1
a869 1
    size = align(size, ws->size_align);
d875 1
a875 1
        usage = 1 << 2;
d877 12
a888 3
        usage = domain >> 1;
    assert(flags < sizeof(usage) * 8 - 3);
    usage |= 1 << (flags + 3);
d890 3
a892 14
    if (use_reusable_pool) {
        bo = radeon_bo(pb_cache_reclaim_buffer(&ws->bo_cache, size, alignment, usage));
        if (bo)
            return &bo->base;
    }

    bo = radeon_create_bo(ws, size, alignment, usage, domain, flags);
    if (!bo) {
        /* Clear the cache and try again. */
        pb_cache_release_all_buffers(&ws->bo_cache);
        bo = radeon_create_bo(ws, size, alignment, usage, domain, flags);
        if (!bo)
            return NULL;
    }
d894 3
a896 1
    bo->use_reusable_pool = use_reusable_pool;
d898 1
a898 5
    pipe_mutex_lock(ws->bo_handles_mutex);
    util_hash_table_set(ws->bo_handles, (void*)(uintptr_t)bo->handle, bo);
    pipe_mutex_unlock(ws->bo_handles_mutex);

    return &bo->base;
d905 1
d926 1
a926 1
    pipe_mutex_lock(ws->bo_handles_mutex);
d935 2
a936 1
    bo->rws = ws;
d942 1
a942 1
    util_hash_table_set(ws->bo_handles, (void*)(uintptr_t)bo->handle, bo);
d944 1
a944 1
    pipe_mutex_unlock(ws->bo_handles_mutex);
d946 1
a946 1
    if (ws->info.has_virtual_memory) {
d949 1
a949 1
        bo->va = radeon_bomgr_find_va(ws, bo->base.size, 1 << 20);
d965 1
a965 1
        pipe_mutex_lock(ws->bo_handles_mutex);
d969 1
a969 1
                util_hash_table_get(ws->bo_vas, (void*)(uintptr_t)va.offset);
d971 1
a971 1
            pipe_mutex_unlock(ws->bo_handles_mutex);
d976 2
a977 2
        util_hash_table_set(ws->bo_vas, (void*)(uintptr_t)bo->va, bo);
        pipe_mutex_unlock(ws->bo_handles_mutex);
d980 1
a980 1
    ws->allocated_gtt += align(bo->base.size, ws->size_align);
d991 1
d1002 1
a1002 1
    pipe_mutex_lock(ws->bo_handles_mutex);
d1006 1
a1006 1
        bo = util_hash_table_get(ws->bo_names, (void*)(uintptr_t)whandle->handle);
d1012 1
a1012 1
        bo = util_hash_table_get(ws->bo_handles, (void*)(uintptr_t)handle);
d1064 2
a1065 1
    bo->rws = ws;
d1070 1
a1070 1
        util_hash_table_set(ws->bo_names, (void*)(uintptr_t)bo->flink_name, bo);
d1072 1
a1072 1
    util_hash_table_set(ws->bo_handles, (void*)(uintptr_t)bo->handle, bo);
d1075 1
a1075 1
    pipe_mutex_unlock(ws->bo_handles_mutex);
d1080 1
a1080 1
    if (ws->info.has_virtual_memory && !bo->va) {
d1083 1
a1083 1
        bo->va = radeon_bomgr_find_va(ws, bo->base.size, 1 << 20);
d1099 1
a1099 1
        pipe_mutex_lock(ws->bo_handles_mutex);
d1103 1
a1103 1
                util_hash_table_get(ws->bo_vas, (void*)(uintptr_t)va.offset);
d1105 1
a1105 1
            pipe_mutex_unlock(ws->bo_handles_mutex);
d1110 2
a1111 2
        util_hash_table_set(ws->bo_vas, (void*)(uintptr_t)bo->va, bo);
        pipe_mutex_unlock(ws->bo_handles_mutex);
d1117 1
a1117 1
        ws->allocated_vram += align(bo->base.size, ws->size_align);
d1119 1
a1119 1
        ws->allocated_gtt += align(bo->base.size, ws->size_align);
d1124 1
a1124 1
    pipe_mutex_unlock(ws->bo_handles_mutex);
d1133 1
a1133 2
    struct radeon_bo *bo = radeon_bo(buffer);
    struct radeon_drm_winsys *ws = bo->rws;
d1137 2
a1138 1
    bo->use_reusable_pool = false;
d1144 1
a1144 1
            if (ioctl(ws->fd, DRM_IOCTL_GEM_FLINK, &flink)) {
d1150 3
a1152 3
            pipe_mutex_lock(ws->bo_handles_mutex);
            util_hash_table_set(ws->bo_names, (void*)(uintptr_t)bo->flink_name, bo);
            pipe_mutex_unlock(ws->bo_handles_mutex);
d1158 1
a1158 1
        if (drmPrimeHandleToFD(ws->fd, bo->handle, DRM_CLOEXEC, (int*)&whandle->handle))
d1166 1
a1166 6
static bool radeon_winsys_bo_is_user_ptr(struct pb_buffer *buf)
{
   return ((struct radeon_bo*)buf)->user_ptr != NULL;
}

static uint64_t radeon_winsys_bo_va(struct pb_buffer *buf)
d1171 1
a1171 1
void radeon_drm_bo_init_functions(struct radeon_drm_winsys *ws)
d1173 1
a1181 1
    ws->base.buffer_is_user_ptr = radeon_winsys_bo_is_user_ptr;
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@a42 8
#include <inttypes.h>

static struct pb_buffer *
radeon_winsys_bo_create(struct radeon_winsys *rws,
                        uint64_t size,
                        unsigned alignment,
                        enum radeon_bo_domain domain,
                        enum radeon_bo_flag flags);
d55 1
a55 1
static bool radeon_real_bo_is_busy(struct radeon_bo *bo)
d64 1
a64 25
static bool radeon_bo_is_busy(struct radeon_bo *bo)
{
    unsigned num_idle;
    bool busy = false;

    if (bo->handle)
        return radeon_real_bo_is_busy(bo);

    pipe_mutex_lock(bo->rws->bo_fence_lock);
    for (num_idle = 0; num_idle < bo->u.slab.num_fences; ++num_idle) {
        if (radeon_real_bo_is_busy(bo->u.slab.fences[num_idle])) {
            busy = true;
            break;
        }
        radeon_bo_reference(&bo->u.slab.fences[num_idle], NULL);
    }
    memmove(&bo->u.slab.fences[0], &bo->u.slab.fences[num_idle],
            (bo->u.slab.num_fences - num_idle) * sizeof(bo->u.slab.fences[0]));
    bo->u.slab.num_fences -= num_idle;
    pipe_mutex_unlock(bo->rws->bo_fence_lock);

    return busy;
}

static void radeon_real_bo_wait_idle(struct radeon_bo *bo)
a72 27
static void radeon_bo_wait_idle(struct radeon_bo *bo)
{
    if (bo->handle) {
        radeon_real_bo_wait_idle(bo);
    } else {
        pipe_mutex_lock(bo->rws->bo_fence_lock);
        while (bo->u.slab.num_fences) {
            struct radeon_bo *fence = NULL;
            radeon_bo_reference(&fence, bo->u.slab.fences[0]);
            pipe_mutex_unlock(bo->rws->bo_fence_lock);

            /* Wait without holding the fence lock. */
            radeon_real_bo_wait_idle(fence);

            pipe_mutex_lock(bo->rws->bo_fence_lock);
            if (bo->u.slab.num_fences && fence == bo->u.slab.fences[0]) {
                radeon_bo_reference(&bo->u.slab.fences[0], NULL);
                memmove(&bo->u.slab.fences[0], &bo->u.slab.fences[1],
                        (bo->u.slab.num_fences - 1) * sizeof(bo->u.slab.fences[0]));
                bo->u.slab.num_fences--;
            }
            radeon_bo_reference(&fence, NULL);
        }
        pipe_mutex_unlock(bo->rws->bo_fence_lock);
    }
}

d146 1
a146 1
    size = align(size, rws->info.gart_page_size);
d204 1
a204 1
    size = align(size, rws->info.gart_page_size);
a270 2
    assert(bo->handle && "must not be called for slab entries");

d281 2
a282 2
    if (bo->u.real.ptr)
        os_munmap(bo->u.real.ptr, bo->base.size);
d300 2
a301 2
                fprintf(stderr, "radeon:    size      : %"PRIu64" bytes\n", bo->base.size);
                fprintf(stderr, "radeon:    va        : 0x%"PRIx64"\n", bo->va);
d312 1
a312 1
    pipe_mutex_destroy(bo->u.real.map_mutex);
d315 1
a315 1
        rws->allocated_vram -= align(bo->base.size, rws->info.gart_page_size);
d317 1
a317 9
        rws->allocated_gtt -= align(bo->base.size, rws->info.gart_page_size);

    if (bo->u.real.map_count >= 1) {
        if (bo->initial_domain & RADEON_DOMAIN_VRAM)
            bo->rws->mapped_vram -= bo->base.size;
        else
            bo->rws->mapped_gtt -= bo->base.size;
    }

d325 2
a326 4
    assert(bo->handle && "must not be called for slab entries");

   if (bo->u.real.use_reusable_pool)
      pb_cache_add_buffer(&bo->u.real.cache_entry);
a334 1
    unsigned offset;
a339 7
    if (bo->handle) {
        offset = 0;
    } else {
        offset = bo->va - bo->u.slab.real->va;
        bo = bo->u.slab.real;
    }

d341 1
a341 1
    pipe_mutex_lock(bo->u.real.map_mutex);
d343 4
a346 4
    if (bo->u.real.ptr) {
        bo->u.real.map_count++;
        pipe_mutex_unlock(bo->u.real.map_mutex);
        return (uint8_t*)bo->u.real.ptr + offset;
d355 1
a355 1
        pipe_mutex_unlock(bo->u.real.map_mutex);
d370 1
a370 1
            pipe_mutex_unlock(bo->u.real.map_mutex);
d375 3
a377 7
    bo->u.real.ptr = ptr;
    bo->u.real.map_count = 1;

    if (bo->initial_domain & RADEON_DOMAIN_VRAM)
       bo->rws->mapped_vram += bo->base.size;
    else
       bo->rws->mapped_gtt += bo->base.size;
d379 1
a379 2
    pipe_mutex_unlock(bo->u.real.map_mutex);
    return (uint8_t*)bo->u.real.ptr + offset;
d467 3
a469 6
    if (!bo->handle)
        bo = bo->u.slab.real;

    pipe_mutex_lock(bo->u.real.map_mutex);
    if (!bo->u.real.ptr) {
        pipe_mutex_unlock(bo->u.real.map_mutex);
d473 3
a475 3
    assert(bo->u.real.map_count);
    if (--bo->u.real.map_count) {
        pipe_mutex_unlock(bo->u.real.map_mutex);
d479 3
a481 9
    os_munmap(bo->u.real.ptr, bo->base.size);
    bo->u.real.ptr = NULL;

    if (bo->initial_domain & RADEON_DOMAIN_VRAM)
       bo->rws->mapped_vram -= bo->base.size;
    else
       bo->rws->mapped_gtt -= bo->base.size;

    pipe_mutex_unlock(bo->u.real.map_mutex);
d505 1
a505 2
                                          unsigned flags,
                                          unsigned pb_cache_bucket)
d532 4
a535 4
        fprintf(stderr, "radeon:    size      : %u bytes\n", size);
        fprintf(stderr, "radeon:    alignment : %u bytes\n", alignment);
        fprintf(stderr, "radeon:    domains   : %u\n", args.initial_domain);
        fprintf(stderr, "radeon:    flags     : %u\n", args.flags);
a538 2
    assert(args.handle != 0);

d552 2
a553 4
    bo->hash = __sync_fetch_and_add(&rws->next_bo_hash, 1);
    pipe_mutex_init(bo->u.real.map_mutex);
    pb_cache_init_entry(&rws->bo_cache, &bo->u.real.cache_entry, &bo->base,
                        pb_cache_bucket);
a556 1
        unsigned va_gap_size;
d558 1
a558 2
        va_gap_size = rws->check_vm ? MAX2(4 * alignment, 64 * 1024) : 0;
        bo->va = radeon_bomgr_find_va(rws, size + va_gap_size, alignment);
d593 1
a593 1
        rws->allocated_vram += align(size, rws->info.gart_page_size);
d595 1
a595 1
        rws->allocated_gtt += align(size, rws->info.gart_page_size);
a609 114
bool radeon_bo_can_reclaim_slab(void *priv, struct pb_slab_entry *entry)
{
    struct radeon_bo *bo = NULL; /* fix container_of */
    bo = container_of(entry, bo, u.slab.entry);

    return radeon_bo_can_reclaim(&bo->base);
}

static void radeon_bo_slab_destroy(struct pb_buffer *_buf)
{
    struct radeon_bo *bo = radeon_bo(_buf);

    assert(!bo->handle);

    pb_slab_free(&bo->rws->bo_slabs, &bo->u.slab.entry);
}

static const struct pb_vtbl radeon_winsys_bo_slab_vtbl = {
    radeon_bo_slab_destroy
    /* other functions are never called */
};

struct pb_slab *radeon_bo_slab_alloc(void *priv, unsigned heap,
                                     unsigned entry_size,
                                     unsigned group_index)
{
    struct radeon_drm_winsys *ws = priv;
    struct radeon_slab *slab = CALLOC_STRUCT(radeon_slab);
    enum radeon_bo_domain domains;
    enum radeon_bo_flag flags = 0;
    unsigned base_hash;

    if (!slab)
        return NULL;

    if (heap & 1)
        flags |= RADEON_FLAG_GTT_WC;
    if (heap & 2)
        flags |= RADEON_FLAG_CPU_ACCESS;

    switch (heap >> 2) {
    case 0:
        domains = RADEON_DOMAIN_VRAM;
        break;
    default:
    case 1:
        domains = RADEON_DOMAIN_VRAM_GTT;
        break;
    case 2:
        domains = RADEON_DOMAIN_GTT;
        break;
    }

    slab->buffer = radeon_bo(radeon_winsys_bo_create(&ws->base,
                                                     64 * 1024, 64 * 1024,
                                                     domains, flags));
    if (!slab->buffer)
        goto fail;

    assert(slab->buffer->handle);

    slab->base.num_entries = slab->buffer->base.size / entry_size;
    slab->base.num_free = slab->base.num_entries;
    slab->entries = CALLOC(slab->base.num_entries, sizeof(*slab->entries));
    if (!slab->entries)
        goto fail_buffer;

    LIST_INITHEAD(&slab->base.free);

    base_hash = __sync_fetch_and_add(&ws->next_bo_hash, slab->base.num_entries);

    for (unsigned i = 0; i < slab->base.num_entries; ++i) {
        struct radeon_bo *bo = &slab->entries[i];

        bo->base.alignment = entry_size;
        bo->base.usage = slab->buffer->base.usage;
        bo->base.size = entry_size;
        bo->base.vtbl = &radeon_winsys_bo_slab_vtbl;
        bo->rws = ws;
        bo->va = slab->buffer->va + i * entry_size;
        bo->initial_domain = domains;
        bo->hash = base_hash + i;
        bo->u.slab.entry.slab = &slab->base;
        bo->u.slab.entry.group_index = group_index;
        bo->u.slab.real = slab->buffer;

        LIST_ADDTAIL(&bo->u.slab.entry.head, &slab->base.free);
    }

    return &slab->base;

fail_buffer:
    radeon_bo_reference(&slab->buffer, NULL);
fail:
    FREE(slab);
    return NULL;
}

void radeon_bo_slab_free(void *priv, struct pb_slab *pslab)
{
    struct radeon_slab *slab = (struct radeon_slab *)pslab;

    for (unsigned i = 0; i < slab->base.num_entries; ++i) {
        struct radeon_bo *bo = &slab->entries[i];
        for (unsigned j = 0; j < bo->u.slab.num_fences; ++j)
            radeon_bo_reference(&bo->u.slab.fences[j], NULL);
        FREE(bo->u.slab.fences);
    }

    FREE(slab->entries);
    radeon_bo_reference(&slab->buffer, NULL);
    FREE(slab);
}

d639 8
a646 2
static void radeon_bo_get_metadata(struct pb_buffer *_buf,
				   struct radeon_bo_metadata *md)
a650 2
    assert(bo->handle && "must not be called for slab entries");

d660 2
a661 2
    md->microtile = RADEON_LAYOUT_LINEAR;
    md->macrotile = RADEON_LAYOUT_LINEAR;
d663 1
a663 1
        md->microtile = RADEON_LAYOUT_TILED;
d665 1
a665 1
        md->microtile = RADEON_LAYOUT_SQUARETILED;
d668 24
a691 12
        md->macrotile = RADEON_LAYOUT_TILED;

    md->bankw = (args.tiling_flags >> RADEON_TILING_EG_BANKW_SHIFT) & RADEON_TILING_EG_BANKW_MASK;
    md->bankh = (args.tiling_flags >> RADEON_TILING_EG_BANKH_SHIFT) & RADEON_TILING_EG_BANKH_MASK;
    md->tile_split = (args.tiling_flags >> RADEON_TILING_EG_TILE_SPLIT_SHIFT) & RADEON_TILING_EG_TILE_SPLIT_MASK;
    md->mtilea = (args.tiling_flags >> RADEON_TILING_EG_MACRO_TILE_ASPECT_SHIFT) & RADEON_TILING_EG_MACRO_TILE_ASPECT_MASK;
    md->tile_split = eg_tile_split(md->tile_split);
    md->scanout = bo->rws->gen >= DRV_SI && !(args.tiling_flags & RADEON_TILING_R600_NO_SCANOUT);
}

static void radeon_bo_set_metadata(struct pb_buffer *_buf,
                                   struct radeon_bo_metadata *md)
d694 1
d697 1
a697 1
    assert(bo->handle && "must not be called for slab entries");
d699 5
a703 1
    memset(&args, 0, sizeof(args));
d707 1
a707 1
    if (md->microtile == RADEON_LAYOUT_TILED)
d709 1
a709 1
    else if (md->microtile == RADEON_LAYOUT_SQUARETILED)
d712 1
a712 1
    if (md->macrotile == RADEON_LAYOUT_TILED)
d715 1
a715 1
    args.tiling_flags |= (md->bankw & RADEON_TILING_EG_BANKW_MASK) <<
d717 1
a717 1
    args.tiling_flags |= (md->bankh & RADEON_TILING_EG_BANKH_MASK) <<
d719 2
a720 2
    if (md->tile_split) {
	args.tiling_flags |= (eg_tile_split_rev(md->tile_split) &
d724 4
a727 1
    args.tiling_flags |= (md->mtilea & RADEON_TILING_EG_MACRO_TILE_ASPECT_MASK) <<
d730 1
a730 1
    if (bo->rws->gen >= DRV_SI && !md->scanout)
d734 1
a734 1
    args.pitch = md->stride;
d744 1
a744 1
                        uint64_t size,
d746 1
d752 1
a752 56
    unsigned usage = 0, pb_cache_bucket;

    /* Only 32-bit sizes are supported. */
    if (size > UINT_MAX)
        return NULL;

    /* Sub-allocate small buffers from slabs. */
    if (!(flags & RADEON_FLAG_HANDLE) &&
        size <= (1 << RADEON_SLAB_MAX_SIZE_LOG2) &&
        ws->info.has_virtual_memory &&
        alignment <= MAX2(1 << RADEON_SLAB_MIN_SIZE_LOG2, util_next_power_of_two(size))) {
        struct pb_slab_entry *entry;
        unsigned heap = 0;

        if (flags & RADEON_FLAG_GTT_WC)
            heap |= 1;
        if (flags & RADEON_FLAG_CPU_ACCESS)
            heap |= 2;
        if (flags & ~(RADEON_FLAG_GTT_WC | RADEON_FLAG_CPU_ACCESS))
            goto no_slab;

        switch (domain) {
        case RADEON_DOMAIN_VRAM:
            heap |= 0 * 4;
            break;
        case RADEON_DOMAIN_VRAM_GTT:
            heap |= 1 * 4;
            break;
        case RADEON_DOMAIN_GTT:
            heap |= 2 * 4;
            break;
        default:
            goto no_slab;
        }

        entry = pb_slab_alloc(&ws->bo_slabs, size, heap);
        if (!entry) {
            /* Clear the cache and try again. */
            pb_cache_release_all_buffers(&ws->bo_cache);

            entry = pb_slab_alloc(&ws->bo_slabs, size, heap);
        }
        if (!entry)
            return NULL;

        bo = NULL;
        bo = container_of(entry, bo, u.slab.entry);

        pipe_reference_init(&bo->base.reference, 1);

        return &bo->base;
    }
no_slab:

    /* This flag is irrelevant for the cache. */
    flags &= ~RADEON_FLAG_HANDLE;
d758 1
a758 2
    size = align(size, ws->info.gart_page_size);
    alignment = align(alignment, ws->info.gart_page_size);
d766 1
a766 1
        usage = (unsigned)domain >> 1;
d770 5
a774 12
    /* Determine the pb_cache bucket for minimizing pb_cache misses. */
    pb_cache_bucket = 0;
    if (domain & RADEON_DOMAIN_VRAM) /* VRAM or VRAM+GTT */
       pb_cache_bucket += 1;
    if (flags == RADEON_FLAG_GTT_WC) /* WC */
       pb_cache_bucket += 2;
    assert(pb_cache_bucket < ARRAY_SIZE(ws->bo_cache.buckets));

    bo = radeon_bo(pb_cache_reclaim_buffer(&ws->bo_cache, size, alignment,
                                           usage, pb_cache_bucket));
    if (bo)
        return &bo->base;
d776 1
a776 2
    bo = radeon_create_bo(ws, size, alignment, usage, domain, flags,
                          pb_cache_bucket);
a778 1
        pb_slabs_reclaim(&ws->bo_slabs);
d780 1
a780 2
        bo = radeon_create_bo(ws, size, alignment, usage, domain, flags,
                              pb_cache_bucket);
d785 1
a785 1
    bo->u.real.use_reusable_pool = true;
d795 1
a795 1
                                                   void *pointer, uint64_t size)
d808 1
a808 1
    args.size = align(size, ws->info.gart_page_size);
a817 2
    assert(args.handle != 0);

d824 1
d831 1
a831 2
    bo->hash = __sync_fetch_and_add(&ws->next_bo_hash, 1);
    pipe_mutex_init(bo->u.real.map_mutex);
d871 1
a871 1
    ws->allocated_gtt += align(bo->base.size, ws->info.gart_page_size);
d878 1
a878 2
                                                      unsigned *stride,
                                                      unsigned *offset)
a885 6
    if (!offset && whandle->offset != 0) {
        fprintf(stderr, "attempt to import unsupported winsys offset %u\n",
                whandle->offset);
        return NULL;
    }

a945 2
    assert(handle != 0);

d951 1
d956 1
a956 2
    bo->hash = __sync_fetch_and_add(&ws->next_bo_hash, 1);
    pipe_mutex_init(bo->u.real.map_mutex);
a967 2
    if (offset)
        *offset = whandle->offset;
d1006 1
a1006 1
        ws->allocated_vram += align(bo->base.size, ws->info.gart_page_size);
d1008 1
a1008 1
        ws->allocated_gtt += align(bo->base.size, ws->info.gart_page_size);
d1017 3
a1019 4
static bool radeon_winsys_bo_get_handle(struct pb_buffer *buffer,
                                        unsigned stride, unsigned offset,
                                        unsigned slice_size,
                                        struct winsys_handle *whandle)
a1024 5
    if (!bo->handle) {
        offset += bo->va - bo->u.slab.real->va;
        bo = bo->u.slab.real;
    }

d1027 1
a1027 1
    bo->u.real.use_reusable_pool = false;
d1034 1
a1034 1
                return false;
d1048 1
a1048 1
            return false;
d1052 1
a1052 4
    whandle->offset = offset;
    whandle->offset += slice_size * whandle->layer;

    return true;
a1064 10
static unsigned radeon_winsys_bo_get_reloc_offset(struct pb_buffer *buf)
{
    struct radeon_bo *bo = radeon_bo(buf);

    if (bo->handle)
        return 0;

    return bo->va - bo->u.slab.real->va;
}

d1067 2
a1068 2
    ws->base.buffer_set_metadata = radeon_bo_set_metadata;
    ws->base.buffer_get_metadata = radeon_bo_get_metadata;
a1077 1
    ws->base.buffer_get_reloc_offset = radeon_winsys_bo_get_reloc_offset;
@


