head	1.1;
branch	1.1.1;
access;
symbols
	mesa-17_1_6:1.1.1.4
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.41.41;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.41.41;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.17.07;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.31.23;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.08.14.09.36.02;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright © 2008 Jérôme Glisse
 * Copyright © 2010 Marek Olšák <maraeo@@gmail.com>
 * Copyright © 2015 Advanced Micro Devices, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
 * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 */
/*
 * Authors:
 *      Marek Olšák <maraeo@@gmail.com>
 */

#include "amdgpu_cs.h"
#include "os/os_time.h"
#include <stdio.h>
#include <amdgpu_drm.h>


/* FENCES */

static struct pipe_fence_handle *
amdgpu_fence_create(struct amdgpu_ctx *ctx, unsigned ip_type,
                    unsigned ip_instance, unsigned ring)
{
   struct amdgpu_fence *fence = CALLOC_STRUCT(amdgpu_fence);

   fence->reference.count = 1;
   fence->ctx = ctx;
   fence->fence.context = ctx->ctx;
   fence->fence.ip_type = ip_type;
   fence->fence.ip_instance = ip_instance;
   fence->fence.ring = ring;
   p_atomic_inc(&ctx->refcount);
   return (struct pipe_fence_handle *)fence;
}

static void amdgpu_fence_submitted(struct pipe_fence_handle *fence,
				struct amdgpu_cs_request* request,
				uint64_t *user_fence_cpu_address)
{
   struct amdgpu_fence *rfence = (struct amdgpu_fence*)fence;

   rfence->fence.fence = request->seq_no;
   rfence->user_fence_cpu_address = user_fence_cpu_address;
}

static void amdgpu_fence_signalled(struct pipe_fence_handle *fence)
{
   struct amdgpu_fence *rfence = (struct amdgpu_fence*)fence;

   rfence->signalled = true;
}

bool amdgpu_fence_wait(struct pipe_fence_handle *fence, uint64_t timeout,
                       bool absolute)
{
   struct amdgpu_fence *rfence = (struct amdgpu_fence*)fence;
   uint32_t expired;
   int64_t abs_timeout;
   uint64_t *user_fence_cpu;
   int r;

   if (rfence->signalled)
      return true;

   if (absolute)
      abs_timeout = timeout;
   else
      abs_timeout = os_time_get_absolute_timeout(timeout);

   user_fence_cpu = rfence->user_fence_cpu_address;
   if (user_fence_cpu && *user_fence_cpu >= rfence->fence.fence) {
	rfence->signalled = true;
	return true;
   }
   /* Now use the libdrm query. */
   r = amdgpu_cs_query_fence_status(&rfence->fence,
				    abs_timeout,
				    AMDGPU_QUERY_FENCE_TIMEOUT_IS_ABSOLUTE,
				    &expired);
   if (r) {
      fprintf(stderr, "amdgpu: amdgpu_cs_query_fence_status failed.\n");
      return FALSE;
   }

   if (expired) {
      /* This variable can only transition from false to true, so it doesn't
       * matter if threads race for it. */
      rfence->signalled = true;
      return true;
   }
   return false;
}

static bool amdgpu_fence_wait_rel_timeout(struct radeon_winsys *rws,
                                          struct pipe_fence_handle *fence,
                                          uint64_t timeout)
{
   return amdgpu_fence_wait(fence, timeout, false);
}

/* CONTEXTS */

static struct radeon_winsys_ctx *amdgpu_ctx_create(struct radeon_winsys *ws)
{
   struct amdgpu_ctx *ctx = CALLOC_STRUCT(amdgpu_ctx);
   int r;
   struct amdgpu_bo_alloc_request alloc_buffer = {};
   amdgpu_bo_handle buf_handle;

   ctx->ws = amdgpu_winsys(ws);
   ctx->refcount = 1;

   r = amdgpu_cs_ctx_create(ctx->ws->dev, &ctx->ctx);
   if (r) {
      fprintf(stderr, "amdgpu: amdgpu_cs_ctx_create failed. (%i)\n", r);
      FREE(ctx);
      return NULL;
   }

   alloc_buffer.alloc_size = 4 * 1024;
   alloc_buffer.phys_alignment = 4 *1024;
   alloc_buffer.preferred_heap = AMDGPU_GEM_DOMAIN_GTT;

   r = amdgpu_bo_alloc(ctx->ws->dev, &alloc_buffer, &buf_handle);
   if (r) {
      fprintf(stderr, "amdgpu: amdgpu_bo_alloc failed. (%i)\n", r);
      amdgpu_cs_ctx_free(ctx->ctx);
      FREE(ctx);
      return NULL;
   }

   r = amdgpu_bo_cpu_map(buf_handle, (void**)&ctx->user_fence_cpu_address_base);
   if (r) {
      fprintf(stderr, "amdgpu: amdgpu_bo_cpu_map failed. (%i)\n", r);
      amdgpu_bo_free(buf_handle);
      amdgpu_cs_ctx_free(ctx->ctx);
      FREE(ctx);
      return NULL;
   }

   memset(ctx->user_fence_cpu_address_base, 0, alloc_buffer.alloc_size);
   ctx->user_fence_bo = buf_handle;

   return (struct radeon_winsys_ctx*)ctx;
}

static void amdgpu_ctx_destroy(struct radeon_winsys_ctx *rwctx)
{
   amdgpu_ctx_unref((struct amdgpu_ctx*)rwctx);
}

static enum pipe_reset_status
amdgpu_ctx_query_reset_status(struct radeon_winsys_ctx *rwctx)
{
   struct amdgpu_ctx *ctx = (struct amdgpu_ctx*)rwctx;
   uint32_t result, hangs;
   int r;

   r = amdgpu_cs_query_reset_state(ctx->ctx, &result, &hangs);
   if (r) {
      fprintf(stderr, "amdgpu: amdgpu_cs_query_reset_state failed. (%i)\n", r);
      return PIPE_NO_RESET;
   }

   switch (result) {
   case AMDGPU_CTX_GUILTY_RESET:
      return PIPE_GUILTY_CONTEXT_RESET;
   case AMDGPU_CTX_INNOCENT_RESET:
      return PIPE_INNOCENT_CONTEXT_RESET;
   case AMDGPU_CTX_UNKNOWN_RESET:
      return PIPE_UNKNOWN_CONTEXT_RESET;
   case AMDGPU_CTX_NO_RESET:
   default:
      return PIPE_NO_RESET;
   }
}

/* COMMAND SUBMISSION */

static bool amdgpu_get_new_ib(struct amdgpu_cs *cs)
{
   /* The maximum size is 4MB - 1B, which is unaligned.
    * Use aligned size 4MB - 16B. */
   const unsigned max_ib_size = (1024 * 1024 - 16) * 4;
   const unsigned min_ib_size = 24 * 1024 * 4;

   cs->base.cdw = 0;
   cs->base.buf = NULL;

   /* Allocate a new buffer for IBs if the current buffer is all used. */
   if (!cs->big_ib_buffer ||
       cs->used_ib_space + min_ib_size > cs->big_ib_buffer->size) {
      struct radeon_winsys *ws = &cs->ctx->ws->base;
      struct radeon_winsys_cs_handle *winsys_bo;

      pb_reference(&cs->big_ib_buffer, NULL);
      cs->big_ib_winsys_buffer = NULL;
      cs->ib_mapped = NULL;
      cs->used_ib_space = 0;

      cs->big_ib_buffer = ws->buffer_create(ws, max_ib_size,
                                            4096, true,
                                            RADEON_DOMAIN_GTT,
                                            RADEON_FLAG_CPU_ACCESS);
      if (!cs->big_ib_buffer)
         return false;

      winsys_bo = ws->buffer_get_cs_handle(cs->big_ib_buffer);

      cs->ib_mapped = ws->buffer_map(winsys_bo, NULL, PIPE_TRANSFER_WRITE);
      if (!cs->ib_mapped) {
         pb_reference(&cs->big_ib_buffer, NULL);
         return false;
      }

      cs->big_ib_winsys_buffer = (struct amdgpu_winsys_bo*)winsys_bo;
   }

   cs->ib.ib_mc_address = cs->big_ib_winsys_buffer->va + cs->used_ib_space;
   cs->base.buf = (uint32_t*)(cs->ib_mapped + cs->used_ib_space);
   cs->base.max_dw = (cs->big_ib_buffer->size - cs->used_ib_space) / 4;
   return true;
}

static boolean amdgpu_init_cs_context(struct amdgpu_cs *cs,
                                      enum ring_type ring_type)
{
   int i;

   switch (ring_type) {
   case RING_DMA:
      cs->request.ip_type = AMDGPU_HW_IP_DMA;
      break;

   case RING_UVD:
      cs->request.ip_type = AMDGPU_HW_IP_UVD;
      break;

   case RING_VCE:
      cs->request.ip_type = AMDGPU_HW_IP_VCE;
      break;

   case RING_COMPUTE:
      cs->request.ip_type = AMDGPU_HW_IP_COMPUTE;
      break;

   default:
   case RING_GFX:
      cs->request.ip_type = AMDGPU_HW_IP_GFX;
      break;
   }

   cs->request.number_of_ibs = 1;
   cs->request.ibs = &cs->ib;

   cs->max_num_buffers = 512;
   cs->buffers = (struct amdgpu_cs_buffer*)
                  CALLOC(1, cs->max_num_buffers * sizeof(struct amdgpu_cs_buffer));
   if (!cs->buffers) {
      return FALSE;
   }

   cs->handles = CALLOC(1, cs->max_num_buffers * sizeof(amdgpu_bo_handle));
   if (!cs->handles) {
      FREE(cs->buffers);
      return FALSE;
   }

   cs->flags = CALLOC(1, cs->max_num_buffers);
   if (!cs->flags) {
      FREE(cs->handles);
      FREE(cs->buffers);
      return FALSE;
   }

   for (i = 0; i < Elements(cs->buffer_indices_hashlist); i++) {
      cs->buffer_indices_hashlist[i] = -1;
   }
   return TRUE;
}

static void amdgpu_cs_context_cleanup(struct amdgpu_cs *cs)
{
   unsigned i;

   for (i = 0; i < cs->num_buffers; i++) {
      p_atomic_dec(&cs->buffers[i].bo->num_cs_references);
      amdgpu_winsys_bo_reference(&cs->buffers[i].bo, NULL);
      cs->handles[i] = NULL;
      cs->flags[i] = 0;
   }

   cs->num_buffers = 0;
   cs->used_gart = 0;
   cs->used_vram = 0;

   for (i = 0; i < Elements(cs->buffer_indices_hashlist); i++) {
      cs->buffer_indices_hashlist[i] = -1;
   }
}

static void amdgpu_destroy_cs_context(struct amdgpu_cs *cs)
{
   amdgpu_cs_context_cleanup(cs);
   FREE(cs->flags);
   FREE(cs->buffers);
   FREE(cs->handles);
   FREE(cs->request.dependencies);
}


static struct radeon_winsys_cs *
amdgpu_cs_create(struct radeon_winsys_ctx *rwctx,
                 enum ring_type ring_type,
                 void (*flush)(void *ctx, unsigned flags,
                               struct pipe_fence_handle **fence),
                 void *flush_ctx,
                 struct radeon_winsys_cs_handle *trace_buf)
{
   struct amdgpu_ctx *ctx = (struct amdgpu_ctx*)rwctx;
   struct amdgpu_cs *cs;

   cs = CALLOC_STRUCT(amdgpu_cs);
   if (!cs) {
      return NULL;
   }

   cs->ctx = ctx;
   cs->flush_cs = flush;
   cs->flush_data = flush_ctx;
   cs->base.ring_type = ring_type;

   if (!amdgpu_init_cs_context(cs, ring_type)) {
      FREE(cs);
      return NULL;
   }

   if (!amdgpu_get_new_ib(cs)) {
      amdgpu_destroy_cs_context(cs);
      FREE(cs);
      return NULL;
   }

   p_atomic_inc(&ctx->ws->num_cs);
   return &cs->base;
}

#define OUT_CS(cs, value) (cs)->buf[(cs)->cdw++] = (value)

int amdgpu_get_reloc(struct amdgpu_cs *cs, struct amdgpu_winsys_bo *bo)
{
   unsigned hash = bo->unique_id & (Elements(cs->buffer_indices_hashlist)-1);
   int i = cs->buffer_indices_hashlist[hash];

   /* not found or found */
   if (i == -1 || cs->buffers[i].bo == bo)
      return i;

   /* Hash collision, look for the BO in the list of relocs linearly. */
   for (i = cs->num_buffers - 1; i >= 0; i--) {
      if (cs->buffers[i].bo == bo) {
         /* Put this reloc in the hash list.
          * This will prevent additional hash collisions if there are
          * several consecutive get_reloc calls for the same buffer.
          *
          * Example: Assuming buffers A,B,C collide in the hash list,
          * the following sequence of relocs:
          *         AAAAAAAAAAABBBBBBBBBBBBBBCCCCCCCC
          * will collide here: ^ and here:   ^,
          * meaning that we should get very few collisions in the end. */
         cs->buffer_indices_hashlist[hash] = i;
         return i;
      }
   }
   return -1;
}

static unsigned amdgpu_add_reloc(struct amdgpu_cs *cs,
                                 struct amdgpu_winsys_bo *bo,
                                 enum radeon_bo_usage usage,
                                 enum radeon_bo_domain domains,
                                 unsigned priority,
                                 enum radeon_bo_domain *added_domains)
{
   struct amdgpu_cs_buffer *reloc;
   unsigned hash = bo->unique_id & (Elements(cs->buffer_indices_hashlist)-1);
   int i = -1;

   priority = MIN2(priority, 15);
   *added_domains = 0;

   i = amdgpu_get_reloc(cs, bo);

   if (i >= 0) {
      reloc = &cs->buffers[i];
      reloc->usage |= usage;
      *added_domains = domains & ~reloc->domains;
      reloc->domains |= domains;
      cs->flags[i] = MAX2(cs->flags[i], priority);
      return i;
   }

   /* New relocation, check if the backing array is large enough. */
   if (cs->num_buffers >= cs->max_num_buffers) {
      uint32_t size;
      cs->max_num_buffers += 10;

      size = cs->max_num_buffers * sizeof(struct amdgpu_cs_buffer);
      cs->buffers = realloc(cs->buffers, size);

      size = cs->max_num_buffers * sizeof(amdgpu_bo_handle);
      cs->handles = realloc(cs->handles, size);

      cs->flags = realloc(cs->flags, cs->max_num_buffers);
   }

   /* Initialize the new relocation. */
   cs->buffers[cs->num_buffers].bo = NULL;
   amdgpu_winsys_bo_reference(&cs->buffers[cs->num_buffers].bo, bo);
   cs->handles[cs->num_buffers] = bo->bo;
   cs->flags[cs->num_buffers] = priority;
   p_atomic_inc(&bo->num_cs_references);
   reloc = &cs->buffers[cs->num_buffers];
   reloc->bo = bo;
   reloc->usage = usage;
   reloc->domains = domains;

   cs->buffer_indices_hashlist[hash] = cs->num_buffers;

   *added_domains = domains;
   return cs->num_buffers++;
}

static unsigned amdgpu_cs_add_reloc(struct radeon_winsys_cs *rcs,
                                    struct radeon_winsys_cs_handle *buf,
                                    enum radeon_bo_usage usage,
                                    enum radeon_bo_domain domains,
                                    enum radeon_bo_priority priority)
{
   /* Don't use the "domains" parameter. Amdgpu doesn't support changing
    * the buffer placement during command submission.
    */
   struct amdgpu_cs *cs = amdgpu_cs(rcs);
   struct amdgpu_winsys_bo *bo = (struct amdgpu_winsys_bo*)buf;
   enum radeon_bo_domain added_domains;
   unsigned index = amdgpu_add_reloc(cs, bo, usage, bo->initial_domain,
                                     priority, &added_domains);

   if (added_domains & RADEON_DOMAIN_GTT)
      cs->used_gart += bo->base.size;
   if (added_domains & RADEON_DOMAIN_VRAM)
      cs->used_vram += bo->base.size;

   return index;
}

static int amdgpu_cs_get_reloc(struct radeon_winsys_cs *rcs,
                               struct radeon_winsys_cs_handle *buf)
{
   struct amdgpu_cs *cs = amdgpu_cs(rcs);

   return amdgpu_get_reloc(cs, (struct amdgpu_winsys_bo*)buf);
}

static boolean amdgpu_cs_validate(struct radeon_winsys_cs *rcs)
{
   return TRUE;
}

static boolean amdgpu_cs_memory_below_limit(struct radeon_winsys_cs *rcs, uint64_t vram, uint64_t gtt)
{
   struct amdgpu_cs *cs = amdgpu_cs(rcs);
   boolean status =
         (cs->used_gart + gtt) < cs->ctx->ws->info.gart_size * 0.7 &&
         (cs->used_vram + vram) < cs->ctx->ws->info.vram_size * 0.7;

   return status;
}

static void amdgpu_cs_do_submission(struct amdgpu_cs *cs,
                                    struct pipe_fence_handle **out_fence)
{
   struct amdgpu_winsys *ws = cs->ctx->ws;
   struct pipe_fence_handle *fence;
   int i, j, r;

   /* Create a fence. */
   fence = amdgpu_fence_create(cs->ctx,
                               cs->request.ip_type,
                               cs->request.ip_instance,
                               cs->request.ring);
   if (out_fence)
      amdgpu_fence_reference(out_fence, fence);

   cs->request.number_of_dependencies = 0;

   /* Since the kernel driver doesn't synchronize execution between different
    * rings automatically, we have to add fence dependencies manually. */
   pipe_mutex_lock(ws->bo_fence_lock);
   for (i = 0; i < cs->num_buffers; i++) {
      for (j = 0; j < RING_LAST; j++) {
         struct amdgpu_cs_fence *dep;
         unsigned idx;

         struct amdgpu_fence *bo_fence = (void *)cs->buffers[i].bo->fence[j];
         if (!bo_fence)
            continue;

         if (bo_fence->ctx == cs->ctx &&
             bo_fence->fence.ip_type == cs->request.ip_type &&
             bo_fence->fence.ip_instance == cs->request.ip_instance &&
             bo_fence->fence.ring == cs->request.ring)
            continue;

         if (amdgpu_fence_wait((void *)bo_fence, 0, false))
            continue;

         idx = cs->request.number_of_dependencies++;
         if (idx >= cs->max_dependencies) {
            unsigned size;

            cs->max_dependencies = idx + 8;
            size = cs->max_dependencies * sizeof(struct amdgpu_cs_fence);
            cs->request.dependencies = realloc(cs->request.dependencies, size);
         }

         dep = &cs->request.dependencies[idx];
         memcpy(dep, &bo_fence->fence, sizeof(*dep));
      }
   }

   cs->request.fence_info.handle = NULL;
   if (cs->request.ip_type != AMDGPU_HW_IP_UVD && cs->request.ip_type != AMDGPU_HW_IP_VCE) {
	cs->request.fence_info.handle = cs->ctx->user_fence_bo;
	cs->request.fence_info.offset = cs->base.ring_type;
   }

   r = amdgpu_cs_submit(cs->ctx->ctx, 0, &cs->request, 1);
   if (r) {
      if (r == -ENOMEM)
         fprintf(stderr, "amdgpu: Not enough memory for command submission.\n");
      else
         fprintf(stderr, "amdgpu: The CS has been rejected, "
                 "see dmesg for more information.\n");

      amdgpu_fence_signalled(fence);
   } else {
      /* Success. */
      uint64_t *user_fence = NULL;
      if (cs->request.ip_type != AMDGPU_HW_IP_UVD && cs->request.ip_type != AMDGPU_HW_IP_VCE)
         user_fence = cs->ctx->user_fence_cpu_address_base +
                      cs->request.fence_info.offset;
      amdgpu_fence_submitted(fence, &cs->request, user_fence);

      for (i = 0; i < cs->num_buffers; i++)
         amdgpu_fence_reference(&cs->buffers[i].bo->fence[cs->base.ring_type],
                                fence);
   }
   pipe_mutex_unlock(ws->bo_fence_lock);
   amdgpu_fence_reference(&fence, NULL);
}

static void amdgpu_cs_sync_flush(struct radeon_winsys_cs *rcs)
{
   /* no-op */
}

DEBUG_GET_ONCE_BOOL_OPTION(noop, "RADEON_NOOP", FALSE)

static void amdgpu_cs_flush(struct radeon_winsys_cs *rcs,
                            unsigned flags,
                            struct pipe_fence_handle **fence,
                            uint32_t cs_trace_id)
{
   struct amdgpu_cs *cs = amdgpu_cs(rcs);
   struct amdgpu_winsys *ws = cs->ctx->ws;

   switch (cs->base.ring_type) {
   case RING_DMA:
      /* pad DMA ring to 8 DWs */
      if (ws->info.chip_class <= SI) {
         while (rcs->cdw & 7)
            OUT_CS(&cs->base, 0xf0000000); /* NOP packet */
      } else {
         while (rcs->cdw & 7)
            OUT_CS(&cs->base, 0x00000000); /* NOP packet */
      }
      break;
   case RING_GFX:
      /* pad DMA ring to 8 DWs to meet CP fetch alignment requirements
             * r6xx, requires at least 4 dw alignment to avoid a hw bug.
             */
      if (ws->info.chip_class <= SI) {
         while (rcs->cdw & 7)
            OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
      } else {
         while (rcs->cdw & 7)
            OUT_CS(&cs->base, 0xffff1000); /* type3 nop packet */
      }
      break;
   case RING_UVD:
      while (rcs->cdw & 15)
         OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
      break;
   default:
      break;
   }

   if (rcs->cdw > rcs->max_dw) {
      fprintf(stderr, "amdgpu: command stream overflowed\n");
   }

   amdgpu_cs_add_reloc(rcs, (void*)cs->big_ib_winsys_buffer,
		       RADEON_USAGE_READ, 0, RADEON_PRIO_MIN);

   /* If the CS is not empty or overflowed.... */
   if (cs->base.cdw && cs->base.cdw <= cs->base.max_dw && !debug_get_option_noop()) {
      int r;

      r = amdgpu_bo_list_create(ws->dev, cs->num_buffers,
                                cs->handles, cs->flags,
                                &cs->request.resources);

      if (r) {
         fprintf(stderr, "amdgpu: resource list creation failed (%d)\n", r);
         cs->request.resources = NULL;
	 goto cleanup;
      }

      cs->ib.size = cs->base.cdw;
      cs->used_ib_space += cs->base.cdw * 4;

      amdgpu_cs_do_submission(cs, fence);

      /* Cleanup. */
      if (cs->request.resources)
         amdgpu_bo_list_destroy(cs->request.resources);
   }

cleanup:
   amdgpu_cs_context_cleanup(cs);
   amdgpu_get_new_ib(cs);

   ws->num_cs_flushes++;
}

static void amdgpu_cs_destroy(struct radeon_winsys_cs *rcs)
{
   struct amdgpu_cs *cs = amdgpu_cs(rcs);

   amdgpu_destroy_cs_context(cs);
   p_atomic_dec(&cs->ctx->ws->num_cs);
   pb_reference(&cs->big_ib_buffer, NULL);
   FREE(cs);
}

static boolean amdgpu_bo_is_referenced(struct radeon_winsys_cs *rcs,
                                       struct radeon_winsys_cs_handle *_buf,
                                       enum radeon_bo_usage usage)
{
   struct amdgpu_cs *cs = amdgpu_cs(rcs);
   struct amdgpu_winsys_bo *bo = (struct amdgpu_winsys_bo*)_buf;

   return amdgpu_bo_is_referenced_by_cs_with_usage(cs, bo, usage);
}

void amdgpu_cs_init_functions(struct amdgpu_winsys *ws)
{
   ws->base.ctx_create = amdgpu_ctx_create;
   ws->base.ctx_destroy = amdgpu_ctx_destroy;
   ws->base.ctx_query_reset_status = amdgpu_ctx_query_reset_status;
   ws->base.cs_create = amdgpu_cs_create;
   ws->base.cs_destroy = amdgpu_cs_destroy;
   ws->base.cs_add_reloc = amdgpu_cs_add_reloc;
   ws->base.cs_get_reloc = amdgpu_cs_get_reloc;
   ws->base.cs_validate = amdgpu_cs_validate;
   ws->base.cs_memory_below_limit = amdgpu_cs_memory_below_limit;
   ws->base.cs_flush = amdgpu_cs_flush;
   ws->base.cs_is_buffer_referenced = amdgpu_bo_is_referenced;
   ws->base.cs_sync_flush = amdgpu_cs_sync_flush;
   ws->base.fence_wait = amdgpu_fence_wait_rel_timeout;
   ws->base.fence_reference = amdgpu_fence_reference;
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d203 4
a206 6
   /* Small IBs are better than big IBs, because the GPU goes idle quicker
    * and there is less waiting for buffers and fences. Proof:
    *   http://www.phoronix.com/scan.php?page=article&item=mesa-111-si&num=1
    */
   const unsigned buffer_size = 128 * 1024 * 4;
   const unsigned ib_size = 20 * 1024 * 4;
d213 1
a213 1
       cs->used_ib_space + ib_size > cs->big_ib_buffer->size) {
d215 1
d222 1
a222 1
      cs->big_ib_buffer = ws->buffer_create(ws, buffer_size,
d229 3
a231 2
      cs->ib_mapped = ws->buffer_map(cs->big_ib_buffer, NULL,
                                     PIPE_TRANSFER_WRITE);
d237 1
a237 1
      cs->big_ib_winsys_buffer = (struct amdgpu_winsys_bo*)cs->big_ib_buffer;
d242 1
a242 1
   cs->base.max_dw = ib_size / 4;
d339 1
a339 1
                 struct pb_buffer *trace_buf)
d371 1
a371 1
int amdgpu_lookup_buffer(struct amdgpu_cs *cs, struct amdgpu_winsys_bo *bo)
d380 1
a380 1
   /* Hash collision, look for the BO in the list of buffers linearly. */
d383 1
a383 1
         /* Put this buffer in the hash list.
d385 1
a385 1
          * several consecutive lookup_buffer calls for the same buffer.
d388 1
a388 1
          * the following sequence of buffers:
d399 1
a399 1
static unsigned amdgpu_add_buffer(struct amdgpu_cs *cs,
d406 1
a406 1
   struct amdgpu_cs_buffer *buffer;
d410 1
a410 1
   assert(priority < 64);
d413 1
a413 1
   i = amdgpu_lookup_buffer(cs, bo);
d416 5
a420 6
      buffer = &cs->buffers[i];
      buffer->priority_usage |= 1llu << priority;
      buffer->usage |= usage;
      *added_domains = domains & ~buffer->domains;
      buffer->domains |= domains;
      cs->flags[i] = MAX2(cs->flags[i], priority / 4);
d424 1
a424 1
   /* New buffer, check if the backing array is large enough. */
d438 1
a438 1
   /* Initialize the new buffer. */
d442 1
a442 1
   cs->flags[cs->num_buffers] = priority / 4;
d444 4
a447 5
   buffer = &cs->buffers[cs->num_buffers];
   buffer->bo = bo;
   buffer->priority_usage = 1llu << priority;
   buffer->usage = usage;
   buffer->domains = domains;
d455 2
a456 2
static unsigned amdgpu_cs_add_buffer(struct radeon_winsys_cs *rcs,
                                    struct pb_buffer *buf,
d467 1
a467 1
   unsigned index = amdgpu_add_buffer(cs, bo, usage, bo->initial_domain,
d478 2
a479 2
static int amdgpu_cs_lookup_buffer(struct radeon_winsys_cs *rcs,
                               struct pb_buffer *buf)
d483 1
a483 1
   return amdgpu_lookup_buffer(cs, (struct amdgpu_winsys_bo*)buf);
a500 16
static unsigned amdgpu_cs_get_buffer_list(struct radeon_winsys_cs *rcs,
                                          struct radeon_bo_list_item *list)
{
    struct amdgpu_cs *cs = amdgpu_cs(rcs);
    int i;

    if (list) {
        for (i = 0; i < cs->num_buffers; i++) {
            pb_reference(&list[i].buf, &cs->buffers[i].bo->base);
            list[i].vm_address = cs->buffers[i].bo->va;
            list[i].priority_usage = cs->buffers[i].priority_usage;
        }
    }
    return cs->num_buffers;
}

a589 1
DEBUG_GET_ONCE_BOOL_OPTION(all_bos, "RADEON_ALL_BOS", FALSE)
d602 7
a608 2
      while (rcs->cdw & 7)
         OUT_CS(&cs->base, 0x00000000); /* NOP packet */
d611 10
a620 3
      /* pad GFX ring to 8 DWs to meet CP fetch alignment requirements */
      while (rcs->cdw & 7)
         OUT_CS(&cs->base, 0xffff1000); /* type3 nop packet */
d634 2
a635 2
   amdgpu_cs_add_buffer(rcs, (void*)cs->big_ib_winsys_buffer,
		       RADEON_USAGE_READ, 0, RADEON_PRIO_IB1);
d641 3
a643 29
      /* Use a buffer list containing all allocated buffers if requested. */
      if (debug_get_option_all_bos()) {
         struct amdgpu_winsys_bo *bo;
         amdgpu_bo_handle *handles;
         unsigned num = 0;

         pipe_mutex_lock(ws->global_bo_list_lock);

         handles = malloc(sizeof(handles[0]) * ws->num_buffers);
         if (!handles) {
            pipe_mutex_unlock(ws->global_bo_list_lock);
            goto cleanup;
         }

         LIST_FOR_EACH_ENTRY(bo, &ws->global_bo_list, global_list_item) {
            assert(num < ws->num_buffers);
            handles[num++] = bo->bo;
         }

         r = amdgpu_bo_list_create(ws->dev, ws->num_buffers,
                                   handles, NULL,
                                   &cs->request.resources);
         free(handles);
         pipe_mutex_unlock(ws->global_bo_list_lock);
      } else {
         r = amdgpu_bo_list_create(ws->dev, cs->num_buffers,
                                   cs->handles, cs->flags,
                                   &cs->request.resources);
      }
d679 1
a679 1
                                       struct pb_buffer *_buf,
d695 2
a696 2
   ws->base.cs_add_buffer = amdgpu_cs_add_buffer;
   ws->base.cs_lookup_buffer = amdgpu_cs_lookup_buffer;
a698 1
   ws->base.cs_get_buffer_list = amdgpu_cs_get_buffer_list;
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@a37 3
#include "amd/common/sid.h"

DEBUG_GET_ONCE_BOOL_OPTION(noop, "RADEON_NOOP", false)
a52 1
   fence->submission_in_progress = true;
a64 1
   rfence->submission_in_progress = false;
a71 1
   rfence->submission_in_progress = false;
a90 7
   /* The fence might not have a number assigned if its IB is being
    * submitted in the other thread right now. Wait until the submission
    * is done. */
   if (!os_wait_until_zero_abs_timeout(&rfence->submission_in_progress,
                                       abs_timeout))
      return false;

d92 3
a94 9
   if (user_fence_cpu) {
      if (*user_fence_cpu >= rfence->fence.fence) {
         rfence->signalled = true;
         return true;
      }

      /* No timeout, just query: no need for the ioctl. */
      if (!absolute && !timeout)
         return false;
a95 1

d103 1
a103 1
      return false;
a121 25
static struct pipe_fence_handle *
amdgpu_cs_get_next_fence(struct radeon_winsys_cs *rcs)
{
   struct amdgpu_cs *cs = amdgpu_cs(rcs);
   struct pipe_fence_handle *fence = NULL;

   if (debug_get_option_noop())
      return NULL;

   if (cs->next_fence) {
      amdgpu_fence_reference(&fence, cs->next_fence);
      return fence;
   }

   fence = amdgpu_fence_create(cs->ctx,
                               cs->csc->request.ip_type,
                               cs->csc->request.ip_instance,
                               cs->csc->request.ring);
   if (!fence)
      return NULL;

   amdgpu_fence_reference(&cs->next_fence, fence);
   return fence;
}

a130 3
   if (!ctx)
      return NULL;

d137 2
a138 1
      goto error_create;
d141 2
a142 2
   alloc_buffer.alloc_size = ctx->ws->info.gart_page_size;
   alloc_buffer.phys_alignment = ctx->ws->info.gart_page_size;
d148 3
a150 1
      goto error_user_fence_alloc;
d156 4
a159 1
      goto error_user_fence_map;
a165 8

error_user_fence_map:
   amdgpu_bo_free(buf_handle);
error_user_fence_alloc:
   amdgpu_cs_ctx_free(ctx->ctx);
error_create:
   FREE(ctx);
   return NULL;
d201 1
a201 126
static bool amdgpu_cs_has_user_fence(struct amdgpu_cs_context *cs)
{
   return cs->request.ip_type != AMDGPU_HW_IP_UVD &&
          cs->request.ip_type != AMDGPU_HW_IP_VCE;
}

static bool amdgpu_cs_has_chaining(struct amdgpu_cs *cs)
{
   return cs->ctx->ws->info.chip_class >= CIK &&
          cs->ring_type == RING_GFX;
}

static unsigned amdgpu_cs_epilog_dws(enum ring_type ring_type)
{
   if (ring_type == RING_GFX)
      return 4; /* for chaining */

   return 0;
}

int amdgpu_lookup_buffer(struct amdgpu_cs_context *cs, struct amdgpu_winsys_bo *bo)
{
   unsigned hash = bo->unique_id & (ARRAY_SIZE(cs->buffer_indices_hashlist)-1);
   int i = cs->buffer_indices_hashlist[hash];
   struct amdgpu_cs_buffer *buffers;
   int num_buffers;

   if (bo->bo) {
      buffers = cs->real_buffers;
      num_buffers = cs->num_real_buffers;
   } else {
      buffers = cs->slab_buffers;
      num_buffers = cs->num_slab_buffers;
   }

   /* not found or found */
   if (i < 0 || (i < num_buffers && buffers[i].bo == bo))
      return i;

   /* Hash collision, look for the BO in the list of buffers linearly. */
   for (i = num_buffers - 1; i >= 0; i--) {
      if (buffers[i].bo == bo) {
         /* Put this buffer in the hash list.
          * This will prevent additional hash collisions if there are
          * several consecutive lookup_buffer calls for the same buffer.
          *
          * Example: Assuming buffers A,B,C collide in the hash list,
          * the following sequence of buffers:
          *         AAAAAAAAAAABBBBBBBBBBBBBBCCCCCCCC
          * will collide here: ^ and here:   ^,
          * meaning that we should get very few collisions in the end. */
         cs->buffer_indices_hashlist[hash] = i;
         return i;
      }
   }
   return -1;
}

static int
amdgpu_lookup_or_add_real_buffer(struct amdgpu_cs *acs, struct amdgpu_winsys_bo *bo)
{
   struct amdgpu_cs_context *cs = acs->csc;
   struct amdgpu_cs_buffer *buffer;
   unsigned hash;
   int idx = amdgpu_lookup_buffer(cs, bo);

   if (idx >= 0)
      return idx;

   /* New buffer, check if the backing array is large enough. */
   if (cs->num_real_buffers >= cs->max_real_buffers) {
      unsigned new_max =
         MAX2(cs->max_real_buffers + 16, (unsigned)(cs->max_real_buffers * 1.3));
      struct amdgpu_cs_buffer *new_buffers;
      amdgpu_bo_handle *new_handles;
      uint8_t *new_flags;

      new_buffers = MALLOC(new_max * sizeof(*new_buffers));
      new_handles = MALLOC(new_max * sizeof(*new_handles));
      new_flags = MALLOC(new_max * sizeof(*new_flags));

      if (!new_buffers || !new_handles || !new_flags) {
         fprintf(stderr, "amdgpu_lookup_or_add_buffer: allocation failed\n");
         FREE(new_buffers);
         FREE(new_handles);
         FREE(new_flags);
         return -1;
      }

      memcpy(new_buffers, cs->real_buffers, cs->num_real_buffers * sizeof(*new_buffers));
      memcpy(new_handles, cs->handles, cs->num_real_buffers * sizeof(*new_handles));
      memcpy(new_flags, cs->flags, cs->num_real_buffers * sizeof(*new_flags));

      FREE(cs->real_buffers);
      FREE(cs->handles);
      FREE(cs->flags);

      cs->max_real_buffers = new_max;
      cs->real_buffers = new_buffers;
      cs->handles = new_handles;
      cs->flags = new_flags;
   }

   idx = cs->num_real_buffers;
   buffer = &cs->real_buffers[idx];

   memset(buffer, 0, sizeof(*buffer));
   amdgpu_winsys_bo_reference(&buffer->bo, bo);
   cs->handles[idx] = bo->bo;
   cs->flags[idx] = 0;
   p_atomic_inc(&bo->num_cs_references);
   cs->num_real_buffers++;

   hash = bo->unique_id & (ARRAY_SIZE(cs->buffer_indices_hashlist)-1);
   cs->buffer_indices_hashlist[hash] = idx;

   if (bo->initial_domain & RADEON_DOMAIN_VRAM)
      acs->main.base.used_vram += bo->base.size;
   else if (bo->initial_domain & RADEON_DOMAIN_GTT)
      acs->main.base.used_gart += bo->base.size;

   return idx;
}

static int amdgpu_lookup_or_add_slab_buffer(struct amdgpu_cs *acs,
                                            struct amdgpu_winsys_bo *bo)
a202 164
   struct amdgpu_cs_context *cs = acs->csc;
   struct amdgpu_cs_buffer *buffer;
   unsigned hash;
   int idx = amdgpu_lookup_buffer(cs, bo);
   int real_idx;

   if (idx >= 0)
      return idx;

   real_idx = amdgpu_lookup_or_add_real_buffer(acs, bo->u.slab.real);
   if (real_idx < 0)
      return -1;

   /* New buffer, check if the backing array is large enough. */
   if (cs->num_slab_buffers >= cs->max_slab_buffers) {
      unsigned new_max =
         MAX2(cs->max_slab_buffers + 16, (unsigned)(cs->max_slab_buffers * 1.3));
      struct amdgpu_cs_buffer *new_buffers;

      new_buffers = REALLOC(cs->slab_buffers,
                            cs->max_slab_buffers * sizeof(*new_buffers),
                            new_max * sizeof(*new_buffers));
      if (!new_buffers) {
         fprintf(stderr, "amdgpu_lookup_or_add_slab_buffer: allocation failed\n");
         return -1;
      }

      cs->max_slab_buffers = new_max;
      cs->slab_buffers = new_buffers;
   }

   idx = cs->num_slab_buffers;
   buffer = &cs->slab_buffers[idx];

   memset(buffer, 0, sizeof(*buffer));
   amdgpu_winsys_bo_reference(&buffer->bo, bo);
   buffer->u.slab.real_idx = real_idx;
   p_atomic_inc(&bo->num_cs_references);
   cs->num_slab_buffers++;

   hash = bo->unique_id & (ARRAY_SIZE(cs->buffer_indices_hashlist)-1);
   cs->buffer_indices_hashlist[hash] = idx;

   return idx;
}

static unsigned amdgpu_cs_add_buffer(struct radeon_winsys_cs *rcs,
                                    struct pb_buffer *buf,
                                    enum radeon_bo_usage usage,
                                    enum radeon_bo_domain domains,
                                    enum radeon_bo_priority priority)
{
   /* Don't use the "domains" parameter. Amdgpu doesn't support changing
    * the buffer placement during command submission.
    */
   struct amdgpu_cs *acs = amdgpu_cs(rcs);
   struct amdgpu_cs_context *cs = acs->csc;
   struct amdgpu_winsys_bo *bo = (struct amdgpu_winsys_bo*)buf;
   struct amdgpu_cs_buffer *buffer;
   int index;

   if (!bo->bo) {
      index = amdgpu_lookup_or_add_slab_buffer(acs, bo);
      if (index < 0)
         return 0;

      buffer = &cs->slab_buffers[index];
      buffer->usage |= usage;

      usage &= ~RADEON_USAGE_SYNCHRONIZED;
      index = buffer->u.slab.real_idx;
   } else {
      index = amdgpu_lookup_or_add_real_buffer(acs, bo);
      if (index < 0)
         return 0;
   }

   buffer = &cs->real_buffers[index];
   buffer->u.real.priority_usage |= 1llu << priority;
   buffer->usage |= usage;
   cs->flags[index] = MAX2(cs->flags[index], priority / 4);
   return index;
}

static bool amdgpu_ib_new_buffer(struct amdgpu_winsys *ws, struct amdgpu_ib *ib)
{
   struct pb_buffer *pb;
   uint8_t *mapped;
   unsigned buffer_size;

   /* Always create a buffer that is at least as large as the maximum seen IB
    * size, aligned to a power of two (and multiplied by 4 to reduce internal
    * fragmentation if chaining is not available). Limit to 512k dwords, which
    * is the largest power of two that fits into the size field of the
    * INDIRECT_BUFFER packet.
    */
   if (amdgpu_cs_has_chaining(amdgpu_cs_from_ib(ib)))
      buffer_size = 4 *util_next_power_of_two(ib->max_ib_size);
   else
      buffer_size = 4 *util_next_power_of_two(4 * ib->max_ib_size);

   buffer_size = MIN2(buffer_size, 4 * 512 * 1024);

   switch (ib->ib_type) {
   case IB_CONST_PREAMBLE:
      buffer_size = MAX2(buffer_size, 4 * 1024);
      break;
   case IB_CONST:
      buffer_size = MAX2(buffer_size, 16 * 1024 * 4);
      break;
   case IB_MAIN:
      buffer_size = MAX2(buffer_size, 8 * 1024 * 4);
      break;
   default:
      unreachable("unhandled IB type");
   }

   pb = ws->base.buffer_create(&ws->base, buffer_size,
                               ws->info.gart_page_size,
                               RADEON_DOMAIN_GTT,
                               RADEON_FLAG_CPU_ACCESS);
   if (!pb)
      return false;

   mapped = ws->base.buffer_map(pb, NULL, PIPE_TRANSFER_WRITE);
   if (!mapped) {
      pb_reference(&pb, NULL);
      return false;
   }

   pb_reference(&ib->big_ib_buffer, pb);
   pb_reference(&pb, NULL);

   ib->ib_mapped = mapped;
   ib->used_ib_space = 0;

   return true;
}

static unsigned amdgpu_ib_max_submit_dwords(enum ib_type ib_type)
{
   switch (ib_type) {
   case IB_MAIN:
      /* Smaller submits means the GPU gets busy sooner and there is less
       * waiting for buffers and fences. Proof:
       *   http://www.phoronix.com/scan.php?page=article&item=mesa-111-si&num=1
       */
      return 20 * 1024;
   case IB_CONST_PREAMBLE:
   case IB_CONST:
      /* There isn't really any reason to limit CE IB size beyond the natural
       * limit implied by the main IB, except perhaps GTT size. Just return
       * an extremely large value that we never get anywhere close to.
       */
      return 16 * 1024 * 1024;
   default:
      unreachable("bad ib_type");
   }
}

static bool amdgpu_get_new_ib(struct radeon_winsys *ws, struct amdgpu_cs *cs,
                              enum ib_type ib_type)
{
   struct amdgpu_winsys *aws = (struct amdgpu_winsys*)ws;
d207 2
a208 20
   struct amdgpu_ib *ib = NULL;
   struct amdgpu_cs_ib_info *info = &cs->csc->ib[ib_type];
   unsigned ib_size = 0;

   switch (ib_type) {
   case IB_CONST_PREAMBLE:
      ib = &cs->const_preamble_ib;
      ib_size = 256 * 4;
      break;
   case IB_CONST:
      ib = &cs->const_ib;
      ib_size = 8 * 1024 * 4;
      break;
   case IB_MAIN:
      ib = &cs->main;
      ib_size = 4 * 1024 * 4;
      break;
   default:
      unreachable("unhandled IB type");
   }
d210 2
a211 12
   if (!amdgpu_cs_has_chaining(cs)) {
      ib_size = MAX2(ib_size,
                     4 * MIN2(util_next_power_of_two(ib->max_ib_size),
                              amdgpu_ib_max_submit_dwords(ib_type)));
   }

   ib->max_ib_size = ib->max_ib_size - ib->max_ib_size / 32;

   ib->base.prev_dw = 0;
   ib->base.num_prev = 0;
   ib->base.current.cdw = 0;
   ib->base.current.buf = NULL;
d214 14
a227 3
   if (!ib->big_ib_buffer ||
       ib->used_ib_space + ib_size > ib->big_ib_buffer->size) {
      if (!amdgpu_ib_new_buffer(aws, ib))
a228 1
   }
d230 6
a235 4
   info->ib_mc_address = amdgpu_winsys_bo(ib->big_ib_buffer)->va +
                         ib->used_ib_space;
   info->size = 0;
   ib->ptr_ib_size = &info->size;
d237 2
a238 4
   amdgpu_cs_add_buffer(&cs->main.base, ib->big_ib_buffer,
                        RADEON_USAGE_READ, 0, RADEON_PRIO_IB1);

   ib->base.current.buf = (uint32_t*)(ib->ib_mapped + ib->used_ib_space);
d240 3
a242 2
   ib_size = ib->big_ib_buffer->size - ib->used_ib_space;
   ib->base.current.max_dw = ib_size / 4 - amdgpu_cs_epilog_dws(cs->ring_type);
d246 2
a247 9
static void amdgpu_ib_finalize(struct amdgpu_ib *ib)
{
   *ib->ptr_ib_size |= ib->base.current.cdw;
   ib->used_ib_space += ib->base.current.cdw * 4;
   ib->max_ib_size = MAX2(ib->max_ib_size, ib->base.prev_dw + ib->base.current.cdw);
}

static bool amdgpu_init_cs_context(struct amdgpu_cs_context *cs,
                                   enum ring_type ring_type)
d274 8
a281 2
   for (i = 0; i < ARRAY_SIZE(cs->buffer_indices_hashlist); i++) {
      cs->buffer_indices_hashlist[i] = -1;
d284 5
a288 2
   cs->request.number_of_ibs = 1;
   cs->request.ibs = &cs->ib[IB_MAIN];
d290 6
a295 3
   cs->ib[IB_CONST].flags = AMDGPU_IB_FLAG_CE;
   cs->ib[IB_CONST_PREAMBLE].flags = AMDGPU_IB_FLAG_CE |
                                     AMDGPU_IB_FLAG_PREAMBLE;
d297 4
a300 1
   return true;
d303 1
a303 1
static void amdgpu_cs_context_cleanup(struct amdgpu_cs_context *cs)
d307 5
a311 7
   for (i = 0; i < cs->num_real_buffers; i++) {
      p_atomic_dec(&cs->real_buffers[i].bo->num_cs_references);
      amdgpu_winsys_bo_reference(&cs->real_buffers[i].bo, NULL);
   }
   for (i = 0; i < cs->num_slab_buffers; i++) {
      p_atomic_dec(&cs->slab_buffers[i].bo->num_cs_references);
      amdgpu_winsys_bo_reference(&cs->slab_buffers[i].bo, NULL);
d314 3
a316 3
   cs->num_real_buffers = 0;
   cs->num_slab_buffers = 0;
   amdgpu_fence_reference(&cs->fence, NULL);
d318 1
a318 1
   for (i = 0; i < ARRAY_SIZE(cs->buffer_indices_hashlist); i++) {
d323 1
a323 1
static void amdgpu_destroy_cs_context(struct amdgpu_cs_context *cs)
d327 1
a327 1
   FREE(cs->real_buffers);
a328 1
   FREE(cs->slab_buffers);
d338 2
a339 1
                 void *flush_ctx)
a348 2
   util_queue_fence_init(&cs->flush_completed);

d352 1
a352 10
   cs->ring_type = ring_type;

   cs->main.ib_type = IB_MAIN;
   cs->const_ib.ib_type = IB_CONST;
   cs->const_preamble_ib.ib_type = IB_CONST_PREAMBLE;

   if (!amdgpu_init_cs_context(&cs->csc1, ring_type)) {
      FREE(cs);
      return NULL;
   }
d354 1
a354 2
   if (!amdgpu_init_cs_context(&cs->csc2, ring_type)) {
      amdgpu_destroy_cs_context(&cs->csc1);
d359 2
a360 7
   /* Set the first submission context as current. */
   cs->csc = &cs->csc1;
   cs->cst = &cs->csc2;

   if (!amdgpu_get_new_ib(&ctx->ws->base, cs, IB_MAIN)) {
      amdgpu_destroy_cs_context(&cs->csc2);
      amdgpu_destroy_cs_context(&cs->csc1);
d366 1
a366 1
   return &cs->main.base;
d369 1
a369 12
static struct radeon_winsys_cs *
amdgpu_cs_add_const_ib(struct radeon_winsys_cs *rcs)
{
   struct amdgpu_cs *cs = (struct amdgpu_cs*)rcs;
   struct amdgpu_winsys *ws = cs->ctx->ws;

   /* only one const IB can be added */
   if (cs->ring_type != RING_GFX || cs->const_ib.ib_mapped)
      return NULL;

   if (!amdgpu_get_new_ib(&ws->base, cs, IB_CONST))
      return NULL;
d371 1
a371 11
   cs->csc->request.number_of_ibs = 2;
   cs->csc->request.ibs = &cs->csc->ib[IB_CONST];

   cs->cst->request.number_of_ibs = 2;
   cs->cst->request.ibs = &cs->cst->ib[IB_CONST];

   return &cs->const_ib.base;
}

static struct radeon_winsys_cs *
amdgpu_cs_add_const_preamble_ib(struct radeon_winsys_cs *rcs)
d373 2
a374 2
   struct amdgpu_cs *cs = (struct amdgpu_cs*)rcs;
   struct amdgpu_winsys *ws = cs->ctx->ws;
d376 3
a378 5
   /* only one const preamble IB can be added and only when the const IB has
    * also been mapped */
   if (cs->ring_type != RING_GFX || !cs->const_ib.ib_mapped ||
       cs->const_preamble_ib.ib_mapped)
      return NULL;
d380 17
a396 10
   if (!amdgpu_get_new_ib(&ws->base, cs, IB_CONST_PREAMBLE))
      return NULL;

   cs->csc->request.number_of_ibs = 3;
   cs->csc->request.ibs = &cs->csc->ib[IB_CONST_PREAMBLE];

   cs->cst->request.number_of_ibs = 3;
   cs->cst->request.ibs = &cs->cst->ib[IB_CONST_PREAMBLE];

   return &cs->const_preamble_ib.base;
d399 6
a404 1
static bool amdgpu_cs_validate(struct radeon_winsys_cs *rcs)
d406 3
a408 10
   return true;
}

static bool amdgpu_cs_check_space(struct radeon_winsys_cs *rcs, unsigned dw)
{
   struct amdgpu_ib *ib = amdgpu_ib(rcs);
   struct amdgpu_cs *cs = amdgpu_cs_from_ib(ib);
   unsigned requested_size = rcs->prev_dw + rcs->current.cdw + dw;
   uint64_t va;
   uint32_t *new_ptr_ib_size;
d410 2
a411 1
   assert(rcs->current.cdw <= rcs->current.max_dw);
d413 1
a413 2
   if (requested_size > amdgpu_ib_max_submit_dwords(ib->ib_type))
      return false;
d415 9
a423 1
   ib->max_ib_size = MAX2(ib->max_ib_size, requested_size);
d425 4
a428 2
   if (rcs->current.max_dw - rcs->current.cdw >= dw)
      return true;
d430 2
a431 2
   if (!amdgpu_cs_has_chaining(cs))
      return false;
d433 2
a434 10
   /* Allocate a new chunk */
   if (rcs->num_prev >= rcs->max_prev) {
      unsigned new_max_prev = MAX2(1, 2 * rcs->max_prev);
      struct radeon_winsys_cs_chunk *new_prev;

      new_prev = REALLOC(rcs->prev,
                         sizeof(*new_prev) * rcs->max_prev,
                         sizeof(*new_prev) * new_max_prev);
      if (!new_prev)
         return false;
d436 1
a436 2
      rcs->prev = new_prev;
      rcs->max_prev = new_max_prev;
d439 11
a449 2
   if (!amdgpu_ib_new_buffer(cs->ctx->ws, ib))
      return false;
d451 1
a451 2
   assert(ib->used_ib_space == 0);
   va = amdgpu_winsys_bo(ib->big_ib_buffer)->va;
d453 3
a455 3
   /* This space was originally reserved. */
   rcs->current.max_dw += 4;
   assert(ib->used_ib_space + 4 * rcs->current.max_dw <= ib->big_ib_buffer->size);
d457 19
a475 3
   /* Pad with NOPs and add INDIRECT_BUFFER packet */
   while ((rcs->current.cdw & 7) != 4)
      radeon_emit(rcs, 0xffff1000); /* type3 nop packet */
d477 2
a478 6
   radeon_emit(rcs, PKT3(ib->ib_type == IB_MAIN ? PKT3_INDIRECT_BUFFER_CIK
                                           : PKT3_INDIRECT_BUFFER_CONST, 2, 0));
   radeon_emit(rcs, va);
   radeon_emit(rcs, va >> 32);
   new_ptr_ib_size = &rcs->current.buf[rcs->current.cdw];
   radeon_emit(rcs, S_3F2_CHAIN(1) | S_3F2_VALID(1));
d480 4
a483 2
   assert((rcs->current.cdw & 7) == 0);
   assert(rcs->current.cdw <= rcs->current.max_dw);
d485 2
a486 2
   *ib->ptr_ib_size |= rcs->current.cdw;
   ib->ptr_ib_size = new_ptr_ib_size;
d488 4
a491 5
   /* Hook up the new chunk */
   rcs->prev[rcs->num_prev].buf = rcs->current.buf;
   rcs->prev[rcs->num_prev].cdw = rcs->current.cdw;
   rcs->prev[rcs->num_prev].max_dw = rcs->current.cdw; /* no modifications */
   rcs->num_prev++;
d493 6
a498 2
   ib->base.prev_dw += ib->base.current.cdw;
   ib->base.current.cdw = 0;
d500 1
a500 7
   ib->base.current.buf = (uint32_t*)(ib->ib_mapped + ib->used_ib_space);
   ib->base.current.max_dw = ib->big_ib_buffer->size / 4 - amdgpu_cs_epilog_dws(cs->ring_type);

   amdgpu_cs_add_buffer(&cs->main.base, ib->big_ib_buffer,
                        RADEON_USAGE_READ, 0, RADEON_PRIO_IB1);

   return true;
d506 1
a506 1
    struct amdgpu_cs_context *cs = amdgpu_cs(rcs)->csc;
d510 4
a513 4
        for (i = 0; i < cs->num_real_buffers; i++) {
            list[i].bo_size = cs->real_buffers[i].bo->base.size;
            list[i].vm_address = cs->real_buffers[i].bo->va;
            list[i].priority_usage = cs->real_buffers[i].u.real.priority_usage;
d516 1
a516 1
    return cs->num_real_buffers;
d519 2
a520 4
DEBUG_GET_ONCE_BOOL_OPTION(all_bos, "RADEON_ALL_BOS", false)

static void amdgpu_add_fence_dependency(struct amdgpu_cs *acs,
                                        struct amdgpu_cs_buffer *buffer)
d522 3
a524 4
   struct amdgpu_cs_context *cs = acs->csc;
   struct amdgpu_winsys_bo *bo = buffer->bo;
   struct amdgpu_cs_fence *dep;
   unsigned new_num_fences = 0;
d526 7
a532 49
   for (unsigned j = 0; j < bo->num_fences; ++j) {
      struct amdgpu_fence *bo_fence = (void *)bo->fences[j];
      unsigned idx;

      if (bo_fence->ctx == acs->ctx &&
         bo_fence->fence.ip_type == cs->request.ip_type &&
         bo_fence->fence.ip_instance == cs->request.ip_instance &&
         bo_fence->fence.ring == cs->request.ring)
         continue;

      if (amdgpu_fence_wait((void *)bo_fence, 0, false))
         continue;

      amdgpu_fence_reference(&bo->fences[new_num_fences], bo->fences[j]);
      new_num_fences++;

      if (!(buffer->usage & RADEON_USAGE_SYNCHRONIZED))
         continue;

      if (bo_fence->submission_in_progress)
         os_wait_until_zero(&bo_fence->submission_in_progress,
                            PIPE_TIMEOUT_INFINITE);

      idx = cs->request.number_of_dependencies++;
      if (idx >= cs->max_dependencies) {
         unsigned size;

         cs->max_dependencies = idx + 8;
         size = cs->max_dependencies * sizeof(struct amdgpu_cs_fence);
         cs->request.dependencies = realloc(cs->request.dependencies, size);
      }

      dep = &cs->request.dependencies[idx];
      memcpy(dep, &bo_fence->fence, sizeof(*dep));
   }

   for (unsigned j = new_num_fences; j < bo->num_fences; ++j)
      amdgpu_fence_reference(&bo->fences[j], NULL);

   bo->num_fences = new_num_fences;
}

/* Since the kernel driver doesn't synchronize execution between different
 * rings automatically, we have to add fence dependencies manually.
 */
static void amdgpu_add_fence_dependencies(struct amdgpu_cs *acs)
{
   struct amdgpu_cs_context *cs = acs->csc;
   int i;
d536 29
a564 22
   for (i = 0; i < cs->num_real_buffers; i++)
      amdgpu_add_fence_dependency(acs, &cs->real_buffers[i]);
   for (i = 0; i < cs->num_slab_buffers; i++)
      amdgpu_add_fence_dependency(acs, &cs->slab_buffers[i]);
}

static void amdgpu_add_fence(struct amdgpu_winsys_bo *bo,
                             struct pipe_fence_handle *fence)
{
   if (bo->num_fences >= bo->max_fences) {
      unsigned new_max_fences = MAX2(1, bo->max_fences * 2);
      struct pipe_fence_handle **new_fences =
         REALLOC(bo->fences,
                 bo->num_fences * sizeof(*new_fences),
                 new_max_fences * sizeof(*new_fences));
      if (new_fences) {
         bo->fences = new_fences;
         bo->max_fences = new_max_fences;
      } else {
         fprintf(stderr, "amdgpu_add_fence: allocation failure, dropping fence\n");
         if (!bo->num_fences)
            return;
d566 2
a567 2
         bo->num_fences--; /* prefer to keep a more recent fence if possible */
         amdgpu_fence_reference(&bo->fences[bo->num_fences], NULL);
a570 12
   bo->fences[bo->num_fences] = NULL;
   amdgpu_fence_reference(&bo->fences[bo->num_fences], fence);
   bo->num_fences++;
}

void amdgpu_cs_submit_ib(void *job, int thread_index)
{
   struct amdgpu_cs *acs = (struct amdgpu_cs*)job;
   struct amdgpu_winsys *ws = acs->ctx->ws;
   struct amdgpu_cs_context *cs = acs->cst;
   int i, r;

d572 3
a574 37
   if (amdgpu_cs_has_user_fence(cs)) {
	cs->request.fence_info.handle = acs->ctx->user_fence_bo;
	cs->request.fence_info.offset = acs->ring_type;
   }

   /* Create the buffer list.
    * Use a buffer list containing all allocated buffers if requested.
    */
   if (debug_get_option_all_bos()) {
      struct amdgpu_winsys_bo *bo;
      amdgpu_bo_handle *handles;
      unsigned num = 0;

      pipe_mutex_lock(ws->global_bo_list_lock);

      handles = malloc(sizeof(handles[0]) * ws->num_buffers);
      if (!handles) {
         pipe_mutex_unlock(ws->global_bo_list_lock);
         amdgpu_cs_context_cleanup(cs);
         cs->error_code = -ENOMEM;
         return;
      }

      LIST_FOR_EACH_ENTRY(bo, &ws->global_bo_list, u.real.global_list_item) {
         assert(num < ws->num_buffers);
         handles[num++] = bo->bo;
      }

      r = amdgpu_bo_list_create(ws->dev, ws->num_buffers,
                                handles, NULL,
                                &cs->request.resources);
      free(handles);
      pipe_mutex_unlock(ws->global_bo_list_lock);
   } else {
      r = amdgpu_bo_list_create(ws->dev, cs->num_real_buffers,
                                cs->handles, cs->flags,
                                &cs->request.resources);
d577 1
a577 10
   if (r) {
      fprintf(stderr, "amdgpu: buffer list creation failed (%d)\n", r);
      cs->request.resources = NULL;
      amdgpu_fence_signalled(cs->fence);
      cs->error_code = r;
      goto cleanup;
   }

   r = amdgpu_cs_submit(acs->ctx->ctx, 0, &cs->request, 1);
   cs->error_code = r;
d583 1
a583 1
                 "see dmesg for more information (%i).\n", r);
d585 1
a585 1
      amdgpu_fence_signalled(cs->fence);
d589 2
a590 2
      if (amdgpu_cs_has_user_fence(cs))
         user_fence = acs->ctx->user_fence_cpu_address_base +
d592 5
a596 1
      amdgpu_fence_submitted(cs->fence, &cs->request, user_fence);
d598 2
a599 12

   /* Cleanup. */
   if (cs->request.resources)
      amdgpu_bo_list_destroy(cs->request.resources);

cleanup:
   for (i = 0; i < cs->num_real_buffers; i++)
      p_atomic_dec(&cs->real_buffers[i].bo->num_active_ioctls);
   for (i = 0; i < cs->num_slab_buffers; i++)
      p_atomic_dec(&cs->slab_buffers[i].bo->num_active_ioctls);

   amdgpu_cs_context_cleanup(cs);
d602 1
a602 2
/* Make sure the previous submission is completed. */
void amdgpu_cs_sync_flush(struct radeon_winsys_cs *rcs)
d604 2
a605 2
   struct amdgpu_cs *cs = amdgpu_cs(rcs);
   struct amdgpu_winsys *ws = cs->ctx->ws;
d607 2
a608 4
   /* Wait for any pending ioctl of this CS to complete. */
   if (util_queue_is_initialized(&ws->cs_queue))
      util_queue_job_wait(&cs->flush_completed);
}
d610 4
a613 3
static int amdgpu_cs_flush(struct radeon_winsys_cs *rcs,
                           unsigned flags,
                           struct pipe_fence_handle **fence)
a616 1
   int error_code = 0;
d618 1
a618 3
   rcs->current.max_dw += amdgpu_cs_epilog_dws(cs->ring_type);

   switch (cs->ring_type) {
d621 2
a622 7
      if (ws->info.chip_class <= SI) {
         while (rcs->current.cdw & 7)
            radeon_emit(rcs, 0xf0000000); /* NOP packet */
      } else {
         while (rcs->current.cdw & 7)
            radeon_emit(rcs, 0x00000000); /* NOP packet */
      }
d626 2
a627 16
      if (ws->info.gfx_ib_pad_with_type2) {
         while (rcs->current.cdw & 7)
            radeon_emit(rcs, 0x80000000); /* type2 nop packet */
      } else {
         while (rcs->current.cdw & 7)
            radeon_emit(rcs, 0xffff1000); /* type3 nop packet */
      }

      /* Also pad the const IB. */
      if (cs->const_ib.ib_mapped)
         while (!cs->const_ib.base.current.cdw || (cs->const_ib.base.current.cdw & 7))
            radeon_emit(&cs->const_ib.base, 0xffff1000); /* type3 nop packet */

      if (cs->const_preamble_ib.ib_mapped)
         while (!cs->const_preamble_ib.base.current.cdw || (cs->const_preamble_ib.base.current.cdw & 7))
            radeon_emit(&cs->const_preamble_ib.base, 0xffff1000);
d630 2
a631 2
      while (rcs->current.cdw & 15)
         radeon_emit(rcs, 0x80000000); /* type2 nop packet */
d637 1
a637 1
   if (rcs->current.cdw > rcs->current.max_dw) {
d641 3
d645 27
a671 21
   if (radeon_emitted(&cs->main.base, 0) &&
       cs->main.base.current.cdw <= cs->main.base.current.max_dw &&
       !debug_get_option_noop()) {
      struct amdgpu_cs_context *cur = cs->csc;
      unsigned i, num_buffers;

      /* Set IB sizes. */
      amdgpu_ib_finalize(&cs->main);

      if (cs->const_ib.ib_mapped)
         amdgpu_ib_finalize(&cs->const_ib);

      if (cs->const_preamble_ib.ib_mapped)
         amdgpu_ib_finalize(&cs->const_preamble_ib);

      /* Create a fence. */
      amdgpu_fence_reference(&cur->fence, NULL);
      if (cs->next_fence) {
         /* just move the reference */
         cur->fence = cs->next_fence;
         cs->next_fence = NULL;
d673 3
a675 4
         cur->fence = amdgpu_fence_create(cs->ctx,
                                          cur->request.ip_type,
                                          cur->request.ip_instance,
                                          cur->request.ring);
a676 2
      if (fence)
         amdgpu_fence_reference(fence, cur->fence);
d678 4
a681 9
      /* Prepare buffers. */
      pipe_mutex_lock(ws->bo_fence_lock);
      amdgpu_add_fence_dependencies(cs);

      num_buffers = cur->num_real_buffers;
      for (i = 0; i < num_buffers; i++) {
         struct amdgpu_winsys_bo *bo = cur->real_buffers[i].bo;
         p_atomic_inc(&bo->num_active_ioctls);
         amdgpu_add_fence(bo, cur->fence);
d684 2
a685 7
      num_buffers = cur->num_slab_buffers;
      for (i = 0; i < num_buffers; i++) {
         struct amdgpu_winsys_bo *bo = cur->slab_buffers[i].bo;
         p_atomic_inc(&bo->num_active_ioctls);
         amdgpu_add_fence(bo, cur->fence);
      }
      pipe_mutex_unlock(ws->bo_fence_lock);
d687 1
a687 1
      amdgpu_cs_sync_flush(rcs);
d689 3
a691 15
      /* Swap command streams. "cst" is going to be submitted. */
      cs->csc = cs->cst;
      cs->cst = cur;

      /* Submit. */
      if ((flags & RADEON_FLUSH_ASYNC) &&
          util_queue_is_initialized(&ws->cs_queue)) {
         util_queue_add_job(&ws->cs_queue, cs, &cs->flush_completed,
                            amdgpu_cs_submit_ib, NULL);
      } else {
         amdgpu_cs_submit_ib(cs, 0);
         error_code = cs->cst->error_code;
      }
   } else {
      amdgpu_cs_context_cleanup(cs->csc);
d694 3
a696 8
   amdgpu_get_new_ib(&ws->base, cs, IB_MAIN);
   if (cs->const_ib.ib_mapped)
      amdgpu_get_new_ib(&ws->base, cs, IB_CONST);
   if (cs->const_preamble_ib.ib_mapped)
      amdgpu_get_new_ib(&ws->base, cs, IB_CONST_PREAMBLE);

   cs->main.base.used_gart = 0;
   cs->main.base.used_vram = 0;
a698 1
   return error_code;
d705 1
a705 2
   amdgpu_cs_sync_flush(rcs);
   util_queue_fence_destroy(&cs->flush_completed);
d707 1
a707 9
   pb_reference(&cs->main.big_ib_buffer, NULL);
   FREE(cs->main.base.prev);
   pb_reference(&cs->const_ib.big_ib_buffer, NULL);
   FREE(cs->const_ib.base.prev);
   pb_reference(&cs->const_preamble_ib.big_ib_buffer, NULL);
   FREE(cs->const_preamble_ib.base.prev);
   amdgpu_destroy_cs_context(&cs->csc1);
   amdgpu_destroy_cs_context(&cs->csc2);
   amdgpu_fence_reference(&cs->next_fence, NULL);
d711 3
a713 3
static bool amdgpu_bo_is_referenced(struct radeon_winsys_cs *rcs,
                                    struct pb_buffer *_buf,
                                    enum radeon_bo_usage usage)
a726 2
   ws->base.cs_add_const_ib = amdgpu_cs_add_const_ib;
   ws->base.cs_add_const_preamble_ib = amdgpu_cs_add_const_preamble_ib;
d729 1
d731 1
a731 1
   ws->base.cs_check_space = amdgpu_cs_check_space;
a733 1
   ws->base.cs_get_next_fence = amdgpu_cs_get_next_fence;
@


1.1.1.4
log
@Import Mesa 17.1.6
@
text
@a180 1
   ctx->initial_num_total_rejected_cs = ctx->ws->num_total_rejected_cs;
a229 7
   /* Return a failure due to a rejected command submission. */
   if (ctx->ws->num_total_rejected_cs > ctx->initial_num_total_rejected_cs) {
      return ctx->num_rejected_cs ? PIPE_GUILTY_CONTEXT_RESET :
                                    PIPE_INNOCENT_CONTEXT_RESET;
   }

   /* Return a failure due to a GPU hang. */
d281 1
a281 1
   } else if (!bo->sparse) {
a283 3
   } else {
      buffers = cs->sparse_buffers;
      num_buffers = cs->num_sparse_buffers;
d310 1
a310 1
amdgpu_do_add_real_buffer(struct amdgpu_cs_context *cs, struct amdgpu_winsys_bo *bo)
d312 1
d314 5
a318 1
   int idx;
d325 2
d329 2
d332 2
a333 2
      if (!new_buffers) {
         fprintf(stderr, "amdgpu_do_add_buffer: allocation failed\n");
d335 2
d341 2
d345 2
d350 2
d359 2
a363 15
   return idx;
}

static int
amdgpu_lookup_or_add_real_buffer(struct amdgpu_cs *acs, struct amdgpu_winsys_bo *bo)
{
   struct amdgpu_cs_context *cs = acs->csc;
   unsigned hash;
   int idx = amdgpu_lookup_buffer(cs, bo);

   if (idx >= 0)
      return idx;

   idx = amdgpu_do_add_real_buffer(cs, bo);

a423 57
static int amdgpu_lookup_or_add_sparse_buffer(struct amdgpu_cs *acs,
                                              struct amdgpu_winsys_bo *bo)
{
   struct amdgpu_cs_context *cs = acs->csc;
   struct amdgpu_cs_buffer *buffer;
   unsigned hash;
   int idx = amdgpu_lookup_buffer(cs, bo);

   if (idx >= 0)
      return idx;

   /* New buffer, check if the backing array is large enough. */
   if (cs->num_sparse_buffers >= cs->max_sparse_buffers) {
      unsigned new_max =
         MAX2(cs->max_sparse_buffers + 16, (unsigned)(cs->max_sparse_buffers * 1.3));
      struct amdgpu_cs_buffer *new_buffers;

      new_buffers = REALLOC(cs->sparse_buffers,
                            cs->max_sparse_buffers * sizeof(*new_buffers),
                            new_max * sizeof(*new_buffers));
      if (!new_buffers) {
         fprintf(stderr, "amdgpu_lookup_or_add_sparse_buffer: allocation failed\n");
         return -1;
      }

      cs->max_sparse_buffers = new_max;
      cs->sparse_buffers = new_buffers;
   }

   idx = cs->num_sparse_buffers;
   buffer = &cs->sparse_buffers[idx];

   memset(buffer, 0, sizeof(*buffer));
   amdgpu_winsys_bo_reference(&buffer->bo, bo);
   p_atomic_inc(&bo->num_cs_references);
   cs->num_sparse_buffers++;

   hash = bo->unique_id & (ARRAY_SIZE(cs->buffer_indices_hashlist)-1);
   cs->buffer_indices_hashlist[hash] = idx;

   /* We delay adding the backing buffers until we really have to. However,
    * we cannot delay accounting for memory use.
    */
   mtx_lock(&bo->u.sparse.commit_lock);

   list_for_each_entry(struct amdgpu_sparse_backing, backing, &bo->u.sparse.backing, list) {
      if (bo->initial_domain & RADEON_DOMAIN_VRAM)
         acs->main.base.used_vram += backing->bo->base.size;
      else if (bo->initial_domain & RADEON_DOMAIN_GTT)
         acs->main.base.used_gart += backing->bo->base.size;
   }

   mtx_unlock(&bo->u.sparse.commit_lock);

   return idx;
}

d439 4
a442 14
   /* Fast exit for no-op calls.
    * This is very effective with suballocators and linear uploaders that
    * are outside of the winsys.
    */
   if (bo == cs->last_added_bo &&
       (usage & cs->last_added_bo_usage) == usage &&
       (1ull << priority) & cs->last_added_bo_priority_usage)
      return cs->last_added_bo_index;

   if (!bo->sparse) {
      if (!bo->bo) {
         index = amdgpu_lookup_or_add_slab_buffer(acs, bo);
         if (index < 0)
            return 0;
d444 2
a445 10
         buffer = &cs->slab_buffers[index];
         buffer->usage |= usage;

         usage &= ~RADEON_USAGE_SYNCHRONIZED;
         index = buffer->u.slab.real_idx;
      } else {
         index = amdgpu_lookup_or_add_real_buffer(acs, bo);
         if (index < 0)
            return 0;
      }
d447 2
a448 1
      buffer = &cs->real_buffers[index];
d450 1
a450 1
      index = amdgpu_lookup_or_add_sparse_buffer(acs, bo);
a452 2

      buffer = &cs->sparse_buffers[index];
d455 1
d458 1
a458 5

   cs->last_added_bo = bo;
   cs->last_added_bo_index = index;
   cs->last_added_bo_usage = buffer->usage;
   cs->last_added_bo_priority_usage = buffer->u.real.priority_usage;
d612 2
d637 3
a639 2
   memset(cs->buffer_indices_hashlist, -1, sizeof(cs->buffer_indices_hashlist));
   cs->last_added_bo = NULL;
a662 6
   for (i = 0; i < cs->num_sparse_buffers; i++) {
      p_atomic_dec(&cs->sparse_buffers[i].bo->num_cs_references);
      amdgpu_winsys_bo_reference(&cs->sparse_buffers[i].bo, NULL);
   }
   for (i = 0; i < cs->num_fence_dependencies; i++)
      amdgpu_fence_reference(&cs->fence_dependencies[i], NULL);
a665 2
   cs->num_sparse_buffers = 0;
   cs->num_fence_dependencies = 0;
d668 3
a670 2
   memset(cs->buffer_indices_hashlist, -1, sizeof(cs->buffer_indices_hashlist));
   cs->last_added_bo = NULL;
d680 1
a680 2
   FREE(cs->sparse_buffers);
   FREE(cs->fence_dependencies);
d891 1
d913 6
a918 2
      idx = cs->num_fence_dependencies++;
      if (idx >= cs->max_fence_dependencies) {
a919 1
         const unsigned increment = 8;
d921 3
a923 6
         cs->max_fence_dependencies = idx + increment;
         size = cs->max_fence_dependencies * sizeof(cs->fence_dependencies[0]);
         cs->fence_dependencies = realloc(cs->fence_dependencies, size);
         /* Clear the newly-allocated elements. */
         memset(cs->fence_dependencies + idx, 0,
                increment * sizeof(cs->fence_dependencies[0]));
d926 2
a927 2
      amdgpu_fence_reference(&cs->fence_dependencies[idx],
                             (struct pipe_fence_handle*)bo_fence);
d936 2
a937 3
/* Add the given list of fences to the buffer's fence list.
 *
 * Must be called with the winsys bo_fence_lock held.
d939 15
a953 3
void amdgpu_add_fences(struct amdgpu_winsys_bo *bo,
                       unsigned num_fences,
                       struct pipe_fence_handle **fences)
d955 2
a956 2
   if (bo->num_fences + num_fences > bo->max_fences) {
      unsigned new_max_fences = MAX2(bo->num_fences + num_fences, bo->max_fences * 2);
d961 1
a961 1
      if (likely(new_fences)) {
d965 1
a965 3
         unsigned drop;

         fprintf(stderr, "amdgpu_add_fences: allocation failure, dropping fence(s)\n");
d969 1
a969 1
         bo->num_fences--; /* prefer to keep the most recent fence if possible */
a970 4

         drop = bo->num_fences + num_fences - bo->max_fences;
         num_fences -= drop;
         fences += drop;
d974 3
a976 69
   for (unsigned i = 0; i < num_fences; ++i) {
      bo->fences[bo->num_fences] = NULL;
      amdgpu_fence_reference(&bo->fences[bo->num_fences], fences[i]);
      bo->num_fences++;
   }
}

static void amdgpu_add_fence_dependencies_list(struct amdgpu_cs *acs,
                                               struct pipe_fence_handle *fence,
                                               unsigned num_buffers,
                                               struct amdgpu_cs_buffer *buffers)
{
   for (unsigned i = 0; i < num_buffers; i++) {
      struct amdgpu_cs_buffer *buffer = &buffers[i];
      struct amdgpu_winsys_bo *bo = buffer->bo;

      amdgpu_add_fence_dependency(acs, buffer);
      p_atomic_inc(&bo->num_active_ioctls);
      amdgpu_add_fences(bo, 1, &fence);
   }
}

/* Since the kernel driver doesn't synchronize execution between different
 * rings automatically, we have to add fence dependencies manually.
 */
static void amdgpu_add_fence_dependencies(struct amdgpu_cs *acs)
{
   struct amdgpu_cs_context *cs = acs->csc;

   cs->num_fence_dependencies = 0;

   amdgpu_add_fence_dependencies_list(acs, cs->fence, cs->num_real_buffers, cs->real_buffers);
   amdgpu_add_fence_dependencies_list(acs, cs->fence, cs->num_slab_buffers, cs->slab_buffers);
   amdgpu_add_fence_dependencies_list(acs, cs->fence, cs->num_sparse_buffers, cs->sparse_buffers);
}

/* Add backing of sparse buffers to the buffer list.
 *
 * This is done late, during submission, to keep the buffer list short before
 * submit, and to avoid managing fences for the backing buffers.
 */
static bool amdgpu_add_sparse_backing_buffers(struct amdgpu_cs_context *cs)
{
   for (unsigned i = 0; i < cs->num_sparse_buffers; ++i) {
      struct amdgpu_cs_buffer *buffer = &cs->sparse_buffers[i];
      struct amdgpu_winsys_bo *bo = buffer->bo;

      mtx_lock(&bo->u.sparse.commit_lock);

      list_for_each_entry(struct amdgpu_sparse_backing, backing, &bo->u.sparse.backing, list) {
         /* We can directly add the buffer here, because we know that each
          * backing buffer occurs only once.
          */
         int idx = amdgpu_do_add_real_buffer(cs, backing->bo);
         if (idx < 0) {
            fprintf(stderr, "%s: failed to add buffer\n", __FUNCTION__);
            mtx_unlock(&bo->u.sparse.commit_lock);
            return false;
         }

         cs->real_buffers[idx].usage = buffer->usage & ~RADEON_USAGE_SYNCHRONIZED;
         cs->real_buffers[idx].u.real.priority_usage = buffer->u.real.priority_usage;
         p_atomic_inc(&backing->bo->num_active_ioctls);
      }

      mtx_unlock(&bo->u.sparse.commit_lock);
   }

   return true;
a984 22
   struct amdgpu_cs_fence *dependencies = NULL;

   /* Set dependencies (input fences). */
   if (cs->num_fence_dependencies) {
      dependencies = alloca(sizeof(dependencies[0]) *
                            cs->num_fence_dependencies);
      unsigned num = 0;

      for (i = 0; i < cs->num_fence_dependencies; i++) {
         struct amdgpu_fence *fence =
            (struct amdgpu_fence*)cs->fence_dependencies[i];

         /* Past fences can't be unsubmitted because we have only 1 CS thread. */
         assert(!fence->submission_in_progress);
         memcpy(&dependencies[num++], &fence->fence, sizeof(dependencies[0]));
      }
      cs->request.dependencies = dependencies;
      cs->request.number_of_dependencies = num;
   } else {
      cs->request.dependencies = NULL;
      cs->request.number_of_dependencies = 0;
   }
a985 1
   /* Set the output fence. */
d1000 1
a1000 1
      mtx_lock(&ws->global_bo_list_lock);
d1004 1
a1004 1
         mtx_unlock(&ws->global_bo_list_lock);
d1019 1
a1019 1
      mtx_unlock(&ws->global_bo_list_lock);
a1020 28
      if (!amdgpu_add_sparse_backing_buffers(cs)) {
         r = -ENOMEM;
         goto bo_list_error;
      }

      if (cs->max_real_submit < cs->num_real_buffers) {
         FREE(cs->handles);
         FREE(cs->flags);

         cs->handles = MALLOC(sizeof(*cs->handles) * cs->num_real_buffers);
         cs->flags = MALLOC(sizeof(*cs->flags) * cs->num_real_buffers);

         if (!cs->handles || !cs->flags) {
            cs->max_real_submit = 0;
            r = -ENOMEM;
            goto bo_list_error;
         }
      }

      for (i = 0; i < cs->num_real_buffers; ++i) {
         struct amdgpu_cs_buffer *buffer = &cs->real_buffers[i];

         assert(buffer->u.real.priority_usage != 0);

         cs->handles[i] = buffer->bo->bo;
         cs->flags[i] = (util_last_bit64(buffer->u.real.priority_usage) - 1) / 4;
      }

a1024 1
bo_list_error:
d1034 1
a1034 5
   if (acs->ctx->num_rejected_cs)
      r = -ECANCELED;
   else
      r = amdgpu_cs_submit(acs->ctx->ctx, 0, &cs->request, 1);

a1038 2
      else if (r == -ECANCELED)
         fprintf(stderr, "amdgpu: The CS has been cancelled because the context is lost.\n");
a1043 3

      acs->ctx->num_rejected_cs++;
      ws->num_total_rejected_cs++;
a1061 2
   for (i = 0; i < cs->num_sparse_buffers; i++)
      p_atomic_dec(&cs->sparse_buffers[i].bo->num_active_ioctls);
d1070 1
d1073 2
a1074 1
   util_queue_fence_wait(&cs->flush_completed);
d1130 1
a1130 1
   if (likely(radeon_emitted(&cs->main.base, 0) &&
d1132 1
a1132 1
       !debug_get_option_noop())) {
d1134 1
d1160 19
a1180 9
      /* Prepare buffers.
       *
       * This fence must be held until the submission is queued to ensure
       * that the order of fence dependency updates matches the order of
       * submissions.
       */
      mtx_lock(&ws->bo_fence_lock);
      amdgpu_add_fence_dependencies(cs);

d1186 7
a1192 8
      util_queue_add_job(&ws->cs_queue, cs, &cs->flush_completed,
                         amdgpu_cs_submit_ib, NULL);
      /* The submission has been queued, unlock the fence now. */
      mtx_unlock(&ws->bo_fence_lock);

      if (!(flags & RADEON_FLUSH_ASYNC)) {
         amdgpu_cs_sync_flush(rcs);
         error_code = cur->error_code;
d1207 1
a1207 5
   if (cs->ring_type == RING_GFX)
      ws->num_gfx_IBs++;
   else if (cs->ring_type == RING_DMA)
      ws->num_sdma_IBs++;

@


