head	1.2;
access;
symbols
	mesa-17_1_6:1.1.1.4
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.31;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.41.40;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.41.40;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.17.07;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.31.23;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.08.14.09.36.03;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Copyright © 2011 Red Hat All Rights Reserved.
 * Copyright © 2014 Advanced Micro Devices, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
 * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 */

/* Contact:
 *     Marek Olšák <maraeo@@gmail.com>
 */

#include "amdgpu_winsys.h"

#ifndef NO_ENTRIES
#define NO_ENTRIES 32
#endif

#ifndef NO_MACRO_ENTRIES
#define NO_MACRO_ENTRIES 16
#endif

#ifndef CIASICIDGFXENGINE_SOUTHERNISLAND
#define CIASICIDGFXENGINE_SOUTHERNISLAND 0x0000000A
#endif


static int amdgpu_surface_sanity(const struct radeon_surf *surf)
{
   unsigned type = RADEON_SURF_GET(surf->flags, TYPE);

   if (!(surf->flags & RADEON_SURF_HAS_TILE_MODE_INDEX))
      return -EINVAL;

   /* all dimension must be at least 1 ! */
   if (!surf->npix_x || !surf->npix_y || !surf->npix_z ||
       !surf->array_size)
      return -EINVAL;

   if (!surf->blk_w || !surf->blk_h || !surf->blk_d)
      return -EINVAL;

   switch (surf->nsamples) {
   case 1:
   case 2:
   case 4:
   case 8:
      break;
   default:
      return -EINVAL;
   }

   switch (type) {
   case RADEON_SURF_TYPE_1D:
      if (surf->npix_y > 1)
         return -EINVAL;
      /* fall through */
   case RADEON_SURF_TYPE_2D:
   case RADEON_SURF_TYPE_CUBEMAP:
      if (surf->npix_z > 1 || surf->array_size > 1)
         return -EINVAL;
      break;
   case RADEON_SURF_TYPE_3D:
      if (surf->array_size > 1)
         return -EINVAL;
      break;
   case RADEON_SURF_TYPE_1D_ARRAY:
      if (surf->npix_y > 1)
         return -EINVAL;
      /* fall through */
   case RADEON_SURF_TYPE_2D_ARRAY:
      if (surf->npix_z > 1)
         return -EINVAL;
      break;
   default:
      return -EINVAL;
   }
   return 0;
}

static void *ADDR_API allocSysMem(const ADDR_ALLOCSYSMEM_INPUT * pInput)
{
   return malloc(pInput->sizeInBytes);
}

static ADDR_E_RETURNCODE ADDR_API freeSysMem(const ADDR_FREESYSMEM_INPUT * pInput)
{
   free(pInput->pVirtAddr);
   return ADDR_OK;
}

ADDR_HANDLE amdgpu_addr_create(struct amdgpu_winsys *ws)
{
   ADDR_CREATE_INPUT addrCreateInput = {0};
   ADDR_CREATE_OUTPUT addrCreateOutput = {0};
   ADDR_REGISTER_VALUE regValue = {0};
   ADDR_CREATE_FLAGS createFlags = {{0}};
   ADDR_E_RETURNCODE addrRet;

   addrCreateInput.size = sizeof(ADDR_CREATE_INPUT);
   addrCreateOutput.size = sizeof(ADDR_CREATE_OUTPUT);

   regValue.noOfBanks = ws->amdinfo.mc_arb_ramcfg & 0x3;
   regValue.gbAddrConfig = ws->amdinfo.gb_addr_cfg;
   regValue.noOfRanks = (ws->amdinfo.mc_arb_ramcfg & 0x4) >> 2;

   regValue.backendDisables = ws->amdinfo.backend_disable[0];
   regValue.pTileConfig = ws->amdinfo.gb_tile_mode;
   regValue.noOfEntries = ARRAY_SIZE(ws->amdinfo.gb_tile_mode);
   if (ws->info.chip_class == SI) {
      regValue.pMacroTileConfig = NULL;
      regValue.noOfMacroEntries = 0;
   } else {
      regValue.pMacroTileConfig = ws->amdinfo.gb_macro_tile_mode;
      regValue.noOfMacroEntries = ARRAY_SIZE(ws->amdinfo.gb_macro_tile_mode);
   }

   createFlags.value = 0;
   createFlags.useTileIndex = 1;
   createFlags.degradeBaseLevel = 1;
   createFlags.useHtileSliceAlign = 1;

   addrCreateInput.chipEngine = CIASICIDGFXENGINE_SOUTHERNISLAND;
   addrCreateInput.chipFamily = ws->family;
   addrCreateInput.chipRevision = ws->rev_id;
   addrCreateInput.createFlags = createFlags;
   addrCreateInput.callbacks.allocSysMem = allocSysMem;
   addrCreateInput.callbacks.freeSysMem = freeSysMem;
   addrCreateInput.callbacks.debugPrint = 0;
   addrCreateInput.regValue = regValue;

   addrRet = AddrCreate(&addrCreateInput, &addrCreateOutput);
   if (addrRet != ADDR_OK)
      return NULL;

   return addrCreateOutput.hLib;
}

static int compute_level(struct amdgpu_winsys *ws,
                         struct radeon_surf *surf, bool is_stencil,
                         unsigned level, unsigned type, bool compressed,
                         ADDR_COMPUTE_SURFACE_INFO_INPUT *AddrSurfInfoIn,
                         ADDR_COMPUTE_SURFACE_INFO_OUTPUT *AddrSurfInfoOut,
                         ADDR_COMPUTE_DCCINFO_INPUT *AddrDccIn,
                         ADDR_COMPUTE_DCCINFO_OUTPUT *AddrDccOut,
                         ADDR_COMPUTE_HTILE_INFO_INPUT *AddrHtileIn,
                         ADDR_COMPUTE_HTILE_INFO_OUTPUT *AddrHtileOut)
{
   struct radeon_surf_level *surf_level;
   ADDR_E_RETURNCODE ret;

   AddrSurfInfoIn->mipLevel = level;
   AddrSurfInfoIn->width = u_minify(surf->npix_x, level);
   AddrSurfInfoIn->height = u_minify(surf->npix_y, level);

   if (type == RADEON_SURF_TYPE_3D)
      AddrSurfInfoIn->numSlices = u_minify(surf->npix_z, level);
   else if (type == RADEON_SURF_TYPE_CUBEMAP)
      AddrSurfInfoIn->numSlices = 6;
   else
      AddrSurfInfoIn->numSlices = surf->array_size;

   if (level > 0) {
      /* Set the base level pitch. This is needed for calculation
       * of non-zero levels. */
      if (is_stencil)
         AddrSurfInfoIn->basePitch = surf->stencil_level[0].nblk_x;
      else
         AddrSurfInfoIn->basePitch = surf->level[0].nblk_x;

      /* Convert blocks to pixels for compressed formats. */
      if (compressed)
         AddrSurfInfoIn->basePitch *= surf->blk_w;
   }

   ret = AddrComputeSurfaceInfo(ws->addrlib,
                                AddrSurfInfoIn,
                                AddrSurfInfoOut);
   if (ret != ADDR_OK) {
      return ret;
   }

   surf_level = is_stencil ? &surf->stencil_level[level] : &surf->level[level];
   surf_level->offset = align64(surf->bo_size, AddrSurfInfoOut->baseAlign);
   surf_level->slice_size = AddrSurfInfoOut->sliceSize;
   surf_level->pitch_bytes = AddrSurfInfoOut->pitch * (is_stencil ? 1 : surf->bpe);
   surf_level->npix_x = u_minify(surf->npix_x, level);
   surf_level->npix_y = u_minify(surf->npix_y, level);
   surf_level->npix_z = u_minify(surf->npix_z, level);
   surf_level->nblk_x = AddrSurfInfoOut->pitch;
   surf_level->nblk_y = AddrSurfInfoOut->height;
   if (type == RADEON_SURF_TYPE_3D)
      surf_level->nblk_z = AddrSurfInfoOut->depth;
   else
      surf_level->nblk_z = 1;

   switch (AddrSurfInfoOut->tileMode) {
   case ADDR_TM_LINEAR_ALIGNED:
      surf_level->mode = RADEON_SURF_MODE_LINEAR_ALIGNED;
      break;
   case ADDR_TM_1D_TILED_THIN1:
      surf_level->mode = RADEON_SURF_MODE_1D;
      break;
   case ADDR_TM_2D_TILED_THIN1:
      surf_level->mode = RADEON_SURF_MODE_2D;
      break;
   default:
      assert(0);
   }

   if (is_stencil)
      surf->stencil_tiling_index[level] = AddrSurfInfoOut->tileIndex;
   else
      surf->tiling_index[level] = AddrSurfInfoOut->tileIndex;

   surf->bo_size = surf_level->offset + AddrSurfInfoOut->surfSize;

   /* Clear DCC fields at the beginning. */
   surf_level->dcc_offset = 0;
   surf_level->dcc_enabled = false;

   /* The previous level's flag tells us if we can use DCC for this level. */
   if (AddrSurfInfoIn->flags.dccCompatible &&
       (level == 0 || AddrDccOut->subLvlCompressible)) {
      AddrDccIn->colorSurfSize = AddrSurfInfoOut->surfSize;
      AddrDccIn->tileMode = AddrSurfInfoOut->tileMode;
      AddrDccIn->tileInfo = *AddrSurfInfoOut->pTileInfo;
      AddrDccIn->tileIndex = AddrSurfInfoOut->tileIndex;
      AddrDccIn->macroModeIndex = AddrSurfInfoOut->macroModeIndex;

      ret = AddrComputeDccInfo(ws->addrlib,
                               AddrDccIn,
                               AddrDccOut);

      if (ret == ADDR_OK) {
         surf_level->dcc_offset = surf->dcc_size;
         surf_level->dcc_fast_clear_size = AddrDccOut->dccFastClearSize;
         surf_level->dcc_enabled = true;
         surf->dcc_size = surf_level->dcc_offset + AddrDccOut->dccRamSize;
         surf->dcc_alignment = MAX2(surf->dcc_alignment, AddrDccOut->dccRamBaseAlign);
      }
   }

   /* TC-compatible HTILE. */
   if (!is_stencil &&
       AddrSurfInfoIn->flags.depth &&
       AddrSurfInfoIn->flags.tcCompatible &&
       surf_level->mode == RADEON_SURF_MODE_2D &&
       level == 0) {
      AddrHtileIn->flags.tcCompatible = 1;
      AddrHtileIn->pitch = AddrSurfInfoOut->pitch;
      AddrHtileIn->height = AddrSurfInfoOut->height;
      AddrHtileIn->numSlices = AddrSurfInfoOut->depth;
      AddrHtileIn->blockWidth = ADDR_HTILE_BLOCKSIZE_8;
      AddrHtileIn->blockHeight = ADDR_HTILE_BLOCKSIZE_8;
      AddrHtileIn->pTileInfo = AddrSurfInfoOut->pTileInfo;
      AddrHtileIn->tileIndex = AddrSurfInfoOut->tileIndex;
      AddrHtileIn->macroModeIndex = AddrSurfInfoOut->macroModeIndex;

      ret = AddrComputeHtileInfo(ws->addrlib,
                                 AddrHtileIn,
                                 AddrHtileOut);

      if (ret == ADDR_OK) {
         surf->htile_size = AddrHtileOut->htileBytes;
         surf->htile_alignment = AddrHtileOut->baseAlign;
      }
   }

   return 0;
}

#define   G_009910_MICRO_TILE_MODE(x)          (((x) >> 0) & 0x03)
#define   G_009910_MICRO_TILE_MODE_NEW(x)      (((x) >> 22) & 0x07)

static void set_micro_tile_mode(struct radeon_surf *surf,
                                struct radeon_info *info)
{
   uint32_t tile_mode = info->si_tile_mode_array[surf->tiling_index[0]];

   if (info->chip_class >= CIK)
      surf->micro_tile_mode = G_009910_MICRO_TILE_MODE_NEW(tile_mode);
   else
      surf->micro_tile_mode = G_009910_MICRO_TILE_MODE(tile_mode);
}

static unsigned cik_get_macro_tile_index(struct radeon_surf *surf)
{
	unsigned index, tileb;

	tileb = 8 * 8 * surf->bpe;
	tileb = MIN2(surf->tile_split, tileb);

	for (index = 0; tileb > 64; index++)
		tileb >>= 1;

	assert(index < 16);
	return index;
}

static int amdgpu_surface_init(struct radeon_winsys *rws,
                               struct radeon_surf *surf)
{
   struct amdgpu_winsys *ws = (struct amdgpu_winsys*)rws;
   unsigned level, mode, type;
   bool compressed;
   ADDR_COMPUTE_SURFACE_INFO_INPUT AddrSurfInfoIn = {0};
   ADDR_COMPUTE_SURFACE_INFO_OUTPUT AddrSurfInfoOut = {0};
   ADDR_COMPUTE_DCCINFO_INPUT AddrDccIn = {0};
   ADDR_COMPUTE_DCCINFO_OUTPUT AddrDccOut = {0};
   ADDR_COMPUTE_HTILE_INFO_INPUT AddrHtileIn = {0};
   ADDR_COMPUTE_HTILE_INFO_OUTPUT AddrHtileOut = {0};
   ADDR_TILEINFO AddrTileInfoIn = {0};
   ADDR_TILEINFO AddrTileInfoOut = {0};
   int r;

   r = amdgpu_surface_sanity(surf);
   if (r)
      return r;

   AddrSurfInfoIn.size = sizeof(ADDR_COMPUTE_SURFACE_INFO_INPUT);
   AddrSurfInfoOut.size = sizeof(ADDR_COMPUTE_SURFACE_INFO_OUTPUT);
   AddrDccIn.size = sizeof(ADDR_COMPUTE_DCCINFO_INPUT);
   AddrDccOut.size = sizeof(ADDR_COMPUTE_DCCINFO_OUTPUT);
   AddrHtileIn.size = sizeof(ADDR_COMPUTE_HTILE_INFO_INPUT);
   AddrHtileOut.size = sizeof(ADDR_COMPUTE_HTILE_INFO_OUTPUT);
   AddrSurfInfoOut.pTileInfo = &AddrTileInfoOut;

   type = RADEON_SURF_GET(surf->flags, TYPE);
   mode = RADEON_SURF_GET(surf->flags, MODE);
   compressed = surf->blk_w == 4 && surf->blk_h == 4;

   /* MSAA and FMASK require 2D tiling. */
   if (surf->nsamples > 1 ||
       (surf->flags & RADEON_SURF_FMASK))
      mode = RADEON_SURF_MODE_2D;

   /* DB doesn't support linear layouts. */
   if (surf->flags & (RADEON_SURF_Z_OR_SBUFFER) &&
       mode < RADEON_SURF_MODE_1D)
      mode = RADEON_SURF_MODE_1D;

   /* Set the requested tiling mode. */
   switch (mode) {
   case RADEON_SURF_MODE_LINEAR_ALIGNED:
      AddrSurfInfoIn.tileMode = ADDR_TM_LINEAR_ALIGNED;
      break;
   case RADEON_SURF_MODE_1D:
      AddrSurfInfoIn.tileMode = ADDR_TM_1D_TILED_THIN1;
      break;
   case RADEON_SURF_MODE_2D:
      AddrSurfInfoIn.tileMode = ADDR_TM_2D_TILED_THIN1;
      break;
   default:
      assert(0);
   }

   /* The format must be set correctly for the allocation of compressed
    * textures to work. In other cases, setting the bpp is sufficient. */
   if (compressed) {
      switch (surf->bpe) {
      case 8:
         AddrSurfInfoIn.format = ADDR_FMT_BC1;
         break;
      case 16:
         AddrSurfInfoIn.format = ADDR_FMT_BC3;
         break;
      default:
         assert(0);
      }
   }
   else {
      AddrDccIn.bpp = AddrSurfInfoIn.bpp = surf->bpe * 8;
   }

   AddrDccIn.numSamples = AddrSurfInfoIn.numSamples = surf->nsamples;
   AddrSurfInfoIn.tileIndex = -1;

   /* Set the micro tile type. */
   if (surf->flags & RADEON_SURF_SCANOUT)
      AddrSurfInfoIn.tileType = ADDR_DISPLAYABLE;
   else if (surf->flags & RADEON_SURF_Z_OR_SBUFFER)
      AddrSurfInfoIn.tileType = ADDR_DEPTH_SAMPLE_ORDER;
   else
      AddrSurfInfoIn.tileType = ADDR_NON_DISPLAYABLE;

   AddrSurfInfoIn.flags.color = !(surf->flags & RADEON_SURF_Z_OR_SBUFFER);
   AddrSurfInfoIn.flags.depth = (surf->flags & RADEON_SURF_ZBUFFER) != 0;
   AddrSurfInfoIn.flags.cube = type == RADEON_SURF_TYPE_CUBEMAP;
   AddrSurfInfoIn.flags.display = (surf->flags & RADEON_SURF_SCANOUT) != 0;
   AddrSurfInfoIn.flags.pow2Pad = surf->last_level > 0;
   AddrSurfInfoIn.flags.tcCompatible = (surf->flags & RADEON_SURF_TC_COMPATIBLE_HTILE) != 0;

   /* Only degrade the tile mode for space if TC-compatible HTILE hasn't been
    * requested, because TC-compatible HTILE requires 2D tiling.
    */
   AddrSurfInfoIn.flags.degrade4Space = !AddrSurfInfoIn.flags.tcCompatible;

   /* DCC notes:
    * - If we add MSAA support, keep in mind that CB can't decompress 8bpp
    *   with samples >= 4.
    * - Mipmapped array textures have low performance (discovered by a closed
    *   driver team).
    */
   AddrSurfInfoIn.flags.dccCompatible = ws->info.chip_class >= VI &&
                                        !(surf->flags & RADEON_SURF_Z_OR_SBUFFER) &&
                                        !(surf->flags & RADEON_SURF_DISABLE_DCC) &&
                                        !compressed && AddrDccIn.numSamples <= 1 &&
                                        ((surf->array_size == 1 && surf->npix_z == 1) ||
                                         surf->last_level == 0);

   AddrSurfInfoIn.flags.noStencil = (surf->flags & RADEON_SURF_SBUFFER) == 0;
   AddrSurfInfoIn.flags.compressZ = AddrSurfInfoIn.flags.depth;

   /* noStencil = 0 can result in a depth part that is incompatible with
    * mipmapped texturing. So set noStencil = 1 when mipmaps are requested (in
    * this case, we may end up setting stencil_adjusted).
    *
    * TODO: update addrlib to a newer version, remove this, and
    * use flags.matchStencilTileCfg = 1 as an alternative fix.
    */
  if (surf->last_level > 0)
      AddrSurfInfoIn.flags.noStencil = 1;

   /* Set preferred macrotile parameters. This is usually required
    * for shared resources. This is for 2D tiling only. */
   if (AddrSurfInfoIn.tileMode >= ADDR_TM_2D_TILED_THIN1 &&
       surf->bankw && surf->bankh && surf->mtilea && surf->tile_split) {
      /* If any of these parameters are incorrect, the calculation
       * will fail. */
      AddrTileInfoIn.banks = surf->num_banks;
      AddrTileInfoIn.bankWidth = surf->bankw;
      AddrTileInfoIn.bankHeight = surf->bankh;
      AddrTileInfoIn.macroAspectRatio = surf->mtilea;
      AddrTileInfoIn.tileSplitBytes = surf->tile_split;
      AddrTileInfoIn.pipeConfig = surf->pipe_config + 1; /* +1 compared to GB_TILE_MODE */
      AddrSurfInfoIn.flags.degrade4Space = 0;
      AddrSurfInfoIn.pTileInfo = &AddrTileInfoIn;

      /* If AddrSurfInfoIn.pTileInfo is set, Addrlib doesn't set
       * the tile index, because we are expected to know it if
       * we know the other parameters.
       *
       * This is something that can easily be fixed in Addrlib.
       * For now, just figure it out here.
       * Note that only 2D_TILE_THIN1 is handled here.
       */
      assert(!(surf->flags & RADEON_SURF_Z_OR_SBUFFER));
      assert(AddrSurfInfoIn.tileMode == ADDR_TM_2D_TILED_THIN1);

      if (ws->info.chip_class == SI) {
         if (AddrSurfInfoIn.tileType == ADDR_DISPLAYABLE) {
            if (surf->bpe == 2)
               AddrSurfInfoIn.tileIndex = 11; /* 16bpp */
            else
               AddrSurfInfoIn.tileIndex = 12; /* 32bpp */
         } else {
            if (surf->bpe == 1)
               AddrSurfInfoIn.tileIndex = 14; /* 8bpp */
            else if (surf->bpe == 2)
               AddrSurfInfoIn.tileIndex = 15; /* 16bpp */
            else if (surf->bpe == 4)
               AddrSurfInfoIn.tileIndex = 16; /* 32bpp */
            else
               AddrSurfInfoIn.tileIndex = 17; /* 64bpp (and 128bpp) */
         }
      } else {
         /* CIK - VI */
         if (AddrSurfInfoIn.tileType == ADDR_DISPLAYABLE)
            AddrSurfInfoIn.tileIndex = 10; /* 2D displayable */
         else
            AddrSurfInfoIn.tileIndex = 14; /* 2D non-displayable */

         /* Addrlib doesn't set this if tileIndex is forced like above. */
         AddrSurfInfoOut.macroModeIndex = cik_get_macro_tile_index(surf);
      }
   }

   surf->bo_size = 0;
   surf->dcc_size = 0;
   surf->dcc_alignment = 1;
   surf->htile_size = 0;
   surf->htile_alignment = 1;

   /* Calculate texture layout information. */
   for (level = 0; level <= surf->last_level; level++) {
      r = compute_level(ws, surf, false, level, type, compressed,
                        &AddrSurfInfoIn, &AddrSurfInfoOut,
                        &AddrDccIn, &AddrDccOut, &AddrHtileIn, &AddrHtileOut);
      if (r)
         return r;

      if (level == 0) {
         surf->bo_alignment = AddrSurfInfoOut.baseAlign;
         surf->pipe_config = AddrSurfInfoOut.pTileInfo->pipeConfig - 1;
         set_micro_tile_mode(surf, &ws->info);

         /* For 2D modes only. */
         if (AddrSurfInfoOut.tileMode >= ADDR_TM_2D_TILED_THIN1) {
            surf->bankw = AddrSurfInfoOut.pTileInfo->bankWidth;
            surf->bankh = AddrSurfInfoOut.pTileInfo->bankHeight;
            surf->mtilea = AddrSurfInfoOut.pTileInfo->macroAspectRatio;
            surf->tile_split = AddrSurfInfoOut.pTileInfo->tileSplitBytes;
            surf->num_banks = AddrSurfInfoOut.pTileInfo->banks;
            surf->macro_tile_index = AddrSurfInfoOut.macroModeIndex;
         } else {
            surf->macro_tile_index = 0;
         }
      }
   }

   /* Calculate texture layout information for stencil. */
   if (surf->flags & RADEON_SURF_SBUFFER) {
      AddrSurfInfoIn.bpp = 8;
      AddrSurfInfoIn.flags.depth = 0;
      AddrSurfInfoIn.flags.stencil = 1;
      AddrSurfInfoIn.flags.tcCompatible = 0;
      /* This will be ignored if AddrSurfInfoIn.pTileInfo is NULL. */
      AddrTileInfoIn.tileSplitBytes = surf->stencil_tile_split;

      for (level = 0; level <= surf->last_level; level++) {
         r = compute_level(ws, surf, true, level, type, compressed,
                           &AddrSurfInfoIn, &AddrSurfInfoOut, &AddrDccIn, &AddrDccOut,
                           NULL, NULL);
         if (r)
            return r;

         /* DB uses the depth pitch for both stencil and depth. */
         if (surf->stencil_level[level].nblk_x != surf->level[level].nblk_x)
            surf->stencil_adjusted = true;

         if (level == 0) {
            /* For 2D modes only. */
            if (AddrSurfInfoOut.tileMode >= ADDR_TM_2D_TILED_THIN1) {
               surf->stencil_tile_split =
                     AddrSurfInfoOut.pTileInfo->tileSplitBytes;
            }
         }
      }
   }

   /* Recalculate the whole DCC miptree size including disabled levels.
    * This is what addrlib does, but calling addrlib would be a lot more
    * complicated.
    */
   if (surf->dcc_size && surf->last_level > 0) {
      surf->dcc_size = align64(surf->bo_size >> 8,
                               ws->info.pipe_interleave_bytes *
                               ws->info.num_tile_pipes);
   }

   /* Make sure HTILE covers the whole miptree, because the shader reads
    * TC-compatible HTILE even for levels where it's disabled by DB.
    */
   if (surf->htile_size && surf->last_level)
	   surf->htile_size *= 2;

   return 0;
}

static int amdgpu_surface_best(struct radeon_winsys *rws,
                               struct radeon_surf *surf)
{
   return 0;
}

void amdgpu_surface_init_functions(struct amdgpu_winsys *ws)
{
   ws->base.surface_init = amdgpu_surface_init;
   ws->base.surface_best = amdgpu_surface_best;
}
@


1.1
log
@Initial revision
@
text
@a110 20
/**
 * This returns the number of banks for the surface.
 * Possible values: 2, 4, 8, 16.
 */
static uint32_t cik_num_banks(struct amdgpu_winsys *ws,
                              struct radeon_surf *surf)
{
   unsigned index, tileb;

   tileb = 8 * 8 * surf->bpe;
   tileb = MIN2(surf->tile_split, tileb);

   for (index = 0; tileb > 64; index++) {
      tileb >>= 1;
   }
   assert(index < 16);

   return 2 << ((ws->amdinfo.gb_macro_tile_mode[index] >> 6) & 0x3);
}

d128 8
a135 5
   regValue.noOfEntries = sizeof(ws->amdinfo.gb_tile_mode) /
                          sizeof(ws->amdinfo.gb_tile_mode[0]);
   regValue.pMacroTileConfig = ws->amdinfo.gb_macro_tile_mode;
   regValue.noOfMacroEntries = sizeof(ws->amdinfo.gb_macro_tile_mode) /
                               sizeof(ws->amdinfo.gb_macro_tile_mode[0]);
d140 1
d162 5
a166 1
                         ADDR_COMPUTE_SURFACE_INFO_OUTPUT *AddrSurfInfoOut)
d203 1
a203 1
   surf_level->offset = align(surf->bo_size, AddrSurfInfoOut->baseAlign);
a216 3
   case ADDR_TM_LINEAR_GENERAL:
      surf_level->mode = RADEON_SURF_MODE_LINEAR;
      break;
d236 53
d292 28
d328 4
d342 4
a363 3
   case RADEON_SURF_MODE_LINEAR:
      AddrSurfInfoIn.tileMode = ADDR_TM_LINEAR_GENERAL;
      break;
d392 1
a392 1
      AddrSurfInfoIn.bpp = surf->bpe * 8;
d395 1
a395 1
   AddrSurfInfoIn.numSamples = surf->nsamples;
a407 1
   AddrSurfInfoIn.flags.stencil = (surf->flags & RADEON_SURF_SBUFFER) != 0;
d411 1
a411 1
   AddrSurfInfoIn.flags.degrade4Space = 1;
d413 30
a442 2
   /* This disables incorrect calculations (hacks) in addrlib. */
   AddrSurfInfoIn.flags.noStencil = 1;
d450 1
a450 1
      AddrTileInfoIn.banks = cik_num_banks(ws, surf);
d455 1
d470 26
a495 4
      if (AddrSurfInfoIn.tileType == ADDR_DISPLAYABLE)
         AddrSurfInfoIn.tileIndex = 10; /* 2D displayable */
      else
         AddrSurfInfoIn.tileIndex = 14; /* 2D non-displayable */
d499 4
d507 2
a508 1
                        &AddrSurfInfoIn, &AddrSurfInfoOut);
d515 1
d524 3
d534 3
d542 2
a543 1
                           &AddrSurfInfoIn, &AddrSurfInfoOut);
d547 4
a551 2
            surf->stencil_offset = surf->stencil_level[0].offset;

d560 16
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d148 2
a149 1
   regValue.noOfEntries = ARRAY_SIZE(ws->amdinfo.gb_tile_mode);
d151 2
a152 1
   regValue.noOfMacroEntries = ARRAY_SIZE(ws->amdinfo.gb_macro_tile_mode);
d178 1
a178 3
                         ADDR_COMPUTE_SURFACE_INFO_OUTPUT *AddrSurfInfoOut,
                         ADDR_COMPUTE_DCCINFO_INPUT *AddrDccIn,
                         ADDR_COMPUTE_DCCINFO_OUTPUT *AddrDccOut)
a250 25

   if (AddrSurfInfoIn->flags.dccCompatible) {
      AddrDccIn->colorSurfSize = AddrSurfInfoOut->surfSize;
      AddrDccIn->tileMode = AddrSurfInfoOut->tileMode;
      AddrDccIn->tileInfo = *AddrSurfInfoOut->pTileInfo;
      AddrDccIn->tileIndex = AddrSurfInfoOut->tileIndex;
      AddrDccIn->macroModeIndex = AddrSurfInfoOut->macroModeIndex;

      ret = AddrComputeDccInfo(ws->addrlib,
                               AddrDccIn,
                               AddrDccOut);

      if (ret == ADDR_OK) {
         surf_level->dcc_offset = surf->dcc_size;
         surf->dcc_size = surf_level->dcc_offset + AddrDccOut->dccRamSize;
         surf->dcc_alignment = MAX2(surf->dcc_alignment, AddrDccOut->dccRamBaseAlign);
      } else {
         surf->dcc_size = 0;
         surf_level->dcc_offset = 0;
      }
   } else {
      surf->dcc_size = 0;
      surf_level->dcc_offset = 0;
   }

a261 2
   ADDR_COMPUTE_DCCINFO_INPUT AddrDccIn = {0};
   ADDR_COMPUTE_DCCINFO_OUTPUT AddrDccOut = {0};
a271 2
   AddrDccIn.size = sizeof(ADDR_COMPUTE_DCCINFO_INPUT);
   AddrDccOut.size = sizeof(ADDR_COMPUTE_DCCINFO_OUTPUT);
d321 1
a321 1
      AddrDccIn.bpp = AddrSurfInfoIn.bpp = surf->bpe * 8;
d324 1
a324 1
   AddrDccIn.numSamples = AddrSurfInfoIn.numSamples = surf->nsamples;
a341 3
   AddrSurfInfoIn.flags.dccCompatible = !(surf->flags & RADEON_SURF_Z_OR_SBUFFER) &&
                                        !(surf->flags & RADEON_SURF_SCANOUT) &&
                                        !compressed && AddrDccIn.numSamples <= 1;
a377 2
   surf->dcc_size = 0;
   surf->dcc_alignment = 1;
d382 1
a382 1
                        &AddrSurfInfoIn, &AddrSurfInfoOut, &AddrDccIn, &AddrDccOut);
d409 1
a409 1
                           &AddrSurfInfoIn, &AddrSurfInfoOut, &AddrDccIn, &AddrDccOut);
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d111 20
d149 2
a150 7
   if (ws->info.chip_class == SI) {
      regValue.pMacroTileConfig = NULL;
      regValue.noOfMacroEntries = 0;
   } else {
      regValue.pMacroTileConfig = ws->amdinfo.gb_macro_tile_mode;
      regValue.noOfMacroEntries = ARRAY_SIZE(ws->amdinfo.gb_macro_tile_mode);
   }
a154 1
   createFlags.useHtileSliceAlign = 1;
d178 1
a178 3
                         ADDR_COMPUTE_DCCINFO_OUTPUT *AddrDccOut,
                         ADDR_COMPUTE_HTILE_INFO_INPUT *AddrHtileIn,
                         ADDR_COMPUTE_HTILE_INFO_OUTPUT *AddrHtileOut)
d215 1
a215 1
   surf_level->offset = align64(surf->bo_size, AddrSurfInfoOut->baseAlign);
d229 3
d252 1
a252 7
   /* Clear DCC fields at the beginning. */
   surf_level->dcc_offset = 0;
   surf_level->dcc_enabled = false;

   /* The previous level's flag tells us if we can use DCC for this level. */
   if (AddrSurfInfoIn->flags.dccCompatible &&
       (level == 0 || AddrDccOut->subLvlCompressible)) {
a264 2
         surf_level->dcc_fast_clear_size = AddrDccOut->dccFastClearSize;
         surf_level->dcc_enabled = true;
d267 3
d271 3
a273 26
   }

   /* TC-compatible HTILE. */
   if (!is_stencil &&
       AddrSurfInfoIn->flags.depth &&
       AddrSurfInfoIn->flags.tcCompatible &&
       surf_level->mode == RADEON_SURF_MODE_2D &&
       level == 0) {
      AddrHtileIn->flags.tcCompatible = 1;
      AddrHtileIn->pitch = AddrSurfInfoOut->pitch;
      AddrHtileIn->height = AddrSurfInfoOut->height;
      AddrHtileIn->numSlices = AddrSurfInfoOut->depth;
      AddrHtileIn->blockWidth = ADDR_HTILE_BLOCKSIZE_8;
      AddrHtileIn->blockHeight = ADDR_HTILE_BLOCKSIZE_8;
      AddrHtileIn->pTileInfo = AddrSurfInfoOut->pTileInfo;
      AddrHtileIn->tileIndex = AddrSurfInfoOut->tileIndex;
      AddrHtileIn->macroModeIndex = AddrSurfInfoOut->macroModeIndex;

      ret = AddrComputeHtileInfo(ws->addrlib,
                                 AddrHtileIn,
                                 AddrHtileOut);

      if (ret == ADDR_OK) {
         surf->htile_size = AddrHtileOut->htileBytes;
         surf->htile_alignment = AddrHtileOut->baseAlign;
      }
a278 28
#define   G_009910_MICRO_TILE_MODE(x)          (((x) >> 0) & 0x03)
#define   G_009910_MICRO_TILE_MODE_NEW(x)      (((x) >> 22) & 0x07)

static void set_micro_tile_mode(struct radeon_surf *surf,
                                struct radeon_info *info)
{
   uint32_t tile_mode = info->si_tile_mode_array[surf->tiling_index[0]];

   if (info->chip_class >= CIK)
      surf->micro_tile_mode = G_009910_MICRO_TILE_MODE_NEW(tile_mode);
   else
      surf->micro_tile_mode = G_009910_MICRO_TILE_MODE(tile_mode);
}

static unsigned cik_get_macro_tile_index(struct radeon_surf *surf)
{
	unsigned index, tileb;

	tileb = 8 * 8 * surf->bpe;
	tileb = MIN2(surf->tile_split, tileb);

	for (index = 0; tileb > 64; index++)
		tileb >>= 1;

	assert(index < 16);
	return index;
}

a288 2
   ADDR_COMPUTE_HTILE_INFO_INPUT AddrHtileIn = {0};
   ADDR_COMPUTE_HTILE_INFO_OUTPUT AddrHtileOut = {0};
a300 2
   AddrHtileIn.size = sizeof(ADDR_COMPUTE_HTILE_INFO_INPUT);
   AddrHtileOut.size = sizeof(ADDR_COMPUTE_HTILE_INFO_OUTPUT);
d319 3
d366 1
d370 4
a373 1
   AddrSurfInfoIn.flags.tcCompatible = (surf->flags & RADEON_SURF_TC_COMPATIBLE_HTILE) != 0;
d375 2
a376 30
   /* Only degrade the tile mode for space if TC-compatible HTILE hasn't been
    * requested, because TC-compatible HTILE requires 2D tiling.
    */
   AddrSurfInfoIn.flags.degrade4Space = !AddrSurfInfoIn.flags.tcCompatible;

   /* DCC notes:
    * - If we add MSAA support, keep in mind that CB can't decompress 8bpp
    *   with samples >= 4.
    * - Mipmapped array textures have low performance (discovered by a closed
    *   driver team).
    */
   AddrSurfInfoIn.flags.dccCompatible = ws->info.chip_class >= VI &&
                                        !(surf->flags & RADEON_SURF_Z_OR_SBUFFER) &&
                                        !(surf->flags & RADEON_SURF_DISABLE_DCC) &&
                                        !compressed && AddrDccIn.numSamples <= 1 &&
                                        ((surf->array_size == 1 && surf->npix_z == 1) ||
                                         surf->last_level == 0);

   AddrSurfInfoIn.flags.noStencil = (surf->flags & RADEON_SURF_SBUFFER) == 0;
   AddrSurfInfoIn.flags.compressZ = AddrSurfInfoIn.flags.depth;

   /* noStencil = 0 can result in a depth part that is incompatible with
    * mipmapped texturing. So set noStencil = 1 when mipmaps are requested (in
    * this case, we may end up setting stencil_adjusted).
    *
    * TODO: update addrlib to a newer version, remove this, and
    * use flags.matchStencilTileCfg = 1 as an alternative fix.
    */
  if (surf->last_level > 0)
      AddrSurfInfoIn.flags.noStencil = 1;
d384 1
a384 1
      AddrTileInfoIn.banks = surf->num_banks;
a388 1
      AddrTileInfoIn.pipeConfig = surf->pipe_config + 1; /* +1 compared to GB_TILE_MODE */
d403 4
a406 26
      if (ws->info.chip_class == SI) {
         if (AddrSurfInfoIn.tileType == ADDR_DISPLAYABLE) {
            if (surf->bpe == 2)
               AddrSurfInfoIn.tileIndex = 11; /* 16bpp */
            else
               AddrSurfInfoIn.tileIndex = 12; /* 32bpp */
         } else {
            if (surf->bpe == 1)
               AddrSurfInfoIn.tileIndex = 14; /* 8bpp */
            else if (surf->bpe == 2)
               AddrSurfInfoIn.tileIndex = 15; /* 16bpp */
            else if (surf->bpe == 4)
               AddrSurfInfoIn.tileIndex = 16; /* 32bpp */
            else
               AddrSurfInfoIn.tileIndex = 17; /* 64bpp (and 128bpp) */
         }
      } else {
         /* CIK - VI */
         if (AddrSurfInfoIn.tileType == ADDR_DISPLAYABLE)
            AddrSurfInfoIn.tileIndex = 10; /* 2D displayable */
         else
            AddrSurfInfoIn.tileIndex = 14; /* 2D non-displayable */

         /* Addrlib doesn't set this if tileIndex is forced like above. */
         AddrSurfInfoOut.macroModeIndex = cik_get_macro_tile_index(surf);
      }
a411 2
   surf->htile_size = 0;
   surf->htile_alignment = 1;
d416 1
a416 2
                        &AddrSurfInfoIn, &AddrSurfInfoOut,
                        &AddrDccIn, &AddrDccOut, &AddrHtileIn, &AddrHtileOut);
a422 1
         set_micro_tile_mode(surf, &ws->info);
a430 3
            surf->macro_tile_index = AddrSurfInfoOut.macroModeIndex;
         } else {
            surf->macro_tile_index = 0;
a437 3
      AddrSurfInfoIn.flags.depth = 0;
      AddrSurfInfoIn.flags.stencil = 1;
      AddrSurfInfoIn.flags.tcCompatible = 0;
d443 1
a443 2
                           &AddrSurfInfoIn, &AddrSurfInfoOut, &AddrDccIn, &AddrDccOut,
                           NULL, NULL);
d447 2
a448 3
         /* DB uses the depth pitch for both stencil and depth. */
         if (surf->stencil_level[level].nblk_x != surf->level[level].nblk_x)
            surf->stencil_adjusted = true;
a449 1
         if (level == 0) {
a457 16

   /* Recalculate the whole DCC miptree size including disabled levels.
    * This is what addrlib does, but calling addrlib would be a lot more
    * complicated.
    */
   if (surf->dcc_size && surf->last_level > 0) {
      surf->dcc_size = align64(surf->bo_size >> 8,
                               ws->info.pipe_interleave_bytes *
                               ws->info.num_tile_pipes);
   }

   /* Make sure HTILE covers the whole miptree, because the shader reads
    * TC-compatible HTILE even for levels where it's disabled by DB.
    */
   if (surf->htile_size && surf->last_level)
	   surf->htile_size *= 2;
@


1.1.1.4
log
@Import Mesa 17.1.6
@
text
@d33 8
a40 1
#include "util/u_format.h"
a45 3
#ifndef CIASICIDGFXENGINE_ARCTICISLAND
#define CIASICIDGFXENGINE_ARCTICISLAND 0x0000000D
#endif
d47 1
a47 1
static int amdgpu_surface_sanity(const struct pipe_resource *tex)
d49 5
d55 2
a56 2
   if (!tex->width0 || !tex->height0 || !tex->depth0 ||
       !tex->array_size)
d59 4
a62 2
   switch (tex->nr_samples) {
   case 0:
d72 3
a74 3
   switch (tex->target) {
   case PIPE_TEXTURE_1D:
      if (tex->height0 > 1)
d77 3
a79 3
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_RECT:
      if (tex->depth0 > 1 || tex->array_size > 1)
d82 2
a83 2
   case PIPE_TEXTURE_3D:
      if (tex->array_size > 1)
d86 2
a87 2
   case PIPE_TEXTURE_1D_ARRAY:
      if (tex->height0 > 1)
d90 2
a91 4
   case PIPE_TEXTURE_CUBE:
   case PIPE_TEXTURE_2D_ARRAY:
   case PIPE_TEXTURE_CUBE_ARRAY:
      if (tex->depth0 > 1)
d122 1
d124 1
a124 1
   createFlags.value = 0;
d126 6
a131 3
   if (ws->info.chip_class >= GFX9) {
      addrCreateInput.chipEngine = CIASICIDGFXENGINE_ARCTICISLAND;
      regValue.blockVarSizeLog2 = 0;
d133 3
a135 2
      regValue.noOfBanks = ws->amdinfo.mc_arb_ramcfg & 0x3;
      regValue.noOfRanks = (ws->amdinfo.mc_arb_ramcfg & 0x4) >> 2;
d137 4
a140 18
      regValue.backendDisables = ws->amdinfo.enabled_rb_pipes_mask;
      regValue.pTileConfig = ws->amdinfo.gb_tile_mode;
      regValue.noOfEntries = ARRAY_SIZE(ws->amdinfo.gb_tile_mode);
      if (ws->info.chip_class == SI) {
         regValue.pMacroTileConfig = NULL;
         regValue.noOfMacroEntries = 0;
      } else {
         regValue.pMacroTileConfig = ws->amdinfo.gb_macro_tile_mode;
         regValue.noOfMacroEntries = ARRAY_SIZE(ws->amdinfo.gb_macro_tile_mode);
      }

      createFlags.useTileIndex = 1;
      createFlags.useHtileSliceAlign = 1;

      addrCreateInput.chipEngine = CIASICIDGFXENGINE_SOUTHERNISLAND;
      addrCreateInput.chipFamily = ws->family;
      addrCreateInput.chipRevision = ws->rev_id;
   }
d142 1
d145 1
a148 1
   addrCreateInput.createFlags = createFlags;
d158 9
a166 10
static int gfx6_compute_level(struct amdgpu_winsys *ws,
                              const struct pipe_resource *tex,
                              struct radeon_surf *surf, bool is_stencil,
                              unsigned level, bool compressed,
                              ADDR_COMPUTE_SURFACE_INFO_INPUT *AddrSurfInfoIn,
                              ADDR_COMPUTE_SURFACE_INFO_OUTPUT *AddrSurfInfoOut,
                              ADDR_COMPUTE_DCCINFO_INPUT *AddrDccIn,
                              ADDR_COMPUTE_DCCINFO_OUTPUT *AddrDccOut,
                              ADDR_COMPUTE_HTILE_INFO_INPUT *AddrHtileIn,
                              ADDR_COMPUTE_HTILE_INFO_OUTPUT *AddrHtileOut)
d168 1
a168 1
   struct legacy_surf_level *surf_level;
d172 2
a173 2
   AddrSurfInfoIn->width = u_minify(tex->width0, level);
   AddrSurfInfoIn->height = u_minify(tex->height0, level);
d175 3
a177 3
   if (tex->target == PIPE_TEXTURE_3D)
      AddrSurfInfoIn->numSlices = u_minify(tex->depth0, level);
   else if (tex->target == PIPE_TEXTURE_CUBE)
d180 1
a180 1
      AddrSurfInfoIn->numSlices = tex->array_size;
d186 1
a186 1
         AddrSurfInfoIn->basePitch = surf->u.legacy.stencil_level[0].nblk_x;
d188 1
a188 1
         AddrSurfInfoIn->basePitch = surf->u.legacy.level[0].nblk_x;
d202 2
a203 2
   surf_level = is_stencil ? &surf->u.legacy.stencil_level[level] : &surf->u.legacy.level[level];
   surf_level->offset = align64(surf->surf_size, AddrSurfInfoOut->baseAlign);
d205 4
d211 4
d231 1
a231 1
      surf->u.legacy.stencil_tiling_index[level] = AddrSurfInfoOut->tileIndex;
d233 1
a233 1
      surf->u.legacy.tiling_index[level] = AddrSurfInfoOut->tileIndex;
d235 1
a235 1
   surf->surf_size = surf_level->offset + AddrSurfInfoOut->surfSize;
d239 1
d257 1
a257 1
         surf->num_dcc_levels = level + 1;
d295 2
a296 2
static void gfx6_set_micro_tile_mode(struct radeon_surf *surf,
                                     struct radeon_info *info)
d298 1
a298 1
   uint32_t tile_mode = info->si_tile_mode_array[surf->u.legacy.tiling_index[0]];
d311 1
a311 1
	tileb = MIN2(surf->u.legacy.tile_split, tileb);
d320 2
a321 5
static int gfx6_surface_init(struct radeon_winsys *rws,
                             const struct pipe_resource *tex,
                             unsigned flags, unsigned bpe,
                             enum radeon_surf_mode mode,
                             struct radeon_surf *surf)
d324 1
a324 1
   unsigned level;
d336 1
a336 1
   r = amdgpu_surface_sanity(tex);
d348 2
a349 5
   surf->blk_w = util_format_get_blockwidth(tex->format);
   surf->blk_h = util_format_get_blockheight(tex->format);
   surf->bpe = bpe;
   surf->flags = flags;

d353 2
a354 2
   if (tex->nr_samples > 1 ||
       (flags & RADEON_SURF_FMASK))
d358 1
a358 1
   if (flags & (RADEON_SURF_Z_OR_SBUFFER) &&
d380 1
a380 1
      switch (bpe) {
d392 1
a392 1
      AddrDccIn.bpp = AddrSurfInfoIn.bpp = bpe * 8;
d395 1
a395 2
   AddrDccIn.numSamples = AddrSurfInfoIn.numSamples =
      tex->nr_samples ? tex->nr_samples : 1;
d399 1
a399 1
   if (flags & RADEON_SURF_SCANOUT)
d401 1
a401 1
   else if (flags & (RADEON_SURF_Z_OR_SBUFFER | RADEON_SURF_FMASK))
d406 6
a411 7
   AddrSurfInfoIn.flags.color = !(flags & RADEON_SURF_Z_OR_SBUFFER);
   AddrSurfInfoIn.flags.depth = (flags & RADEON_SURF_ZBUFFER) != 0;
   AddrSurfInfoIn.flags.cube = tex->target == PIPE_TEXTURE_CUBE;
   AddrSurfInfoIn.flags.fmask = (flags & RADEON_SURF_FMASK) != 0;
   AddrSurfInfoIn.flags.display = (flags & RADEON_SURF_SCANOUT) != 0;
   AddrSurfInfoIn.flags.pow2Pad = tex->last_level > 0;
   AddrSurfInfoIn.flags.tcCompatible = (flags & RADEON_SURF_TC_COMPATIBLE_HTILE) != 0;
d416 1
a416 4
   AddrSurfInfoIn.flags.opt4Space = !AddrSurfInfoIn.flags.tcCompatible &&
                                    !AddrSurfInfoIn.flags.fmask &&
                                    tex->nr_samples <= 1 &&
                                    (flags & RADEON_SURF_OPTIMIZE_FOR_SPACE);
d425 2
a426 2
                                        !(flags & RADEON_SURF_Z_OR_SBUFFER) &&
                                        !(flags & RADEON_SURF_DISABLE_DCC) &&
d428 2
a429 2
                                        ((tex->array_size == 1 && tex->depth0 == 1) ||
                                         tex->last_level == 0);
d431 1
a431 1
   AddrSurfInfoIn.flags.noStencil = (flags & RADEON_SURF_SBUFFER) == 0;
d441 1
a441 1
  if (tex->last_level > 0)
d447 1
a447 4
       surf->u.legacy.bankw && surf->u.legacy.bankh &&
       surf->u.legacy.mtilea && surf->u.legacy.tile_split) {
      assert(!(flags & RADEON_SURF_FMASK));

d450 7
a456 7
      AddrTileInfoIn.banks = surf->u.legacy.num_banks;
      AddrTileInfoIn.bankWidth = surf->u.legacy.bankw;
      AddrTileInfoIn.bankHeight = surf->u.legacy.bankh;
      AddrTileInfoIn.macroAspectRatio = surf->u.legacy.mtilea;
      AddrTileInfoIn.tileSplitBytes = surf->u.legacy.tile_split;
      AddrTileInfoIn.pipeConfig = surf->u.legacy.pipe_config + 1; /* +1 compared to GB_TILE_MODE */
      AddrSurfInfoIn.flags.opt4Space = 0;
d467 1
a467 1
      assert(!(flags & RADEON_SURF_Z_OR_SBUFFER));
d472 1
a472 1
            if (bpe == 2)
d477 1
a477 1
            if (bpe == 1)
d479 1
a479 1
            else if (bpe == 2)
d481 1
a481 1
            else if (bpe == 4)
d498 1
a498 2
   surf->num_dcc_levels = 0;
   surf->surf_size = 0;
d505 4
a508 4
   for (level = 0; level <= tex->last_level; level++) {
      r = gfx6_compute_level(ws, tex, surf, false, level, compressed,
                             &AddrSurfInfoIn, &AddrSurfInfoOut,
                             &AddrDccIn, &AddrDccOut, &AddrHtileIn, &AddrHtileOut);
d513 3
a515 3
         surf->surf_alignment = AddrSurfInfoOut.baseAlign;
         surf->u.legacy.pipe_config = AddrSurfInfoOut.pTileInfo->pipeConfig - 1;
         gfx6_set_micro_tile_mode(surf, &ws->info);
d519 6
a524 6
            surf->u.legacy.bankw = AddrSurfInfoOut.pTileInfo->bankWidth;
            surf->u.legacy.bankh = AddrSurfInfoOut.pTileInfo->bankHeight;
            surf->u.legacy.mtilea = AddrSurfInfoOut.pTileInfo->macroAspectRatio;
            surf->u.legacy.tile_split = AddrSurfInfoOut.pTileInfo->tileSplitBytes;
            surf->u.legacy.num_banks = AddrSurfInfoOut.pTileInfo->banks;
            surf->u.legacy.macro_tile_index = AddrSurfInfoOut.macroModeIndex;
d526 1
a526 1
            surf->u.legacy.macro_tile_index = 0;
d532 1
a532 1
   if (flags & RADEON_SURF_SBUFFER) {
d538 1
a538 1
      AddrTileInfoIn.tileSplitBytes = surf->u.legacy.stencil_tile_split;
d540 4
a543 5
      for (level = 0; level <= tex->last_level; level++) {
         r = gfx6_compute_level(ws, tex, surf, true, level, compressed,
                                &AddrSurfInfoIn, &AddrSurfInfoOut,
                                &AddrDccIn, &AddrDccOut,
                                NULL, NULL);
d548 2
a549 2
         if (surf->u.legacy.stencil_level[level].nblk_x != surf->u.legacy.level[level].nblk_x)
            surf->u.legacy.stencil_adjusted = true;
d554 1
a554 1
               surf->u.legacy.stencil_tile_split =
d565 2
a566 2
   if (surf->dcc_size && tex->last_level > 0) {
      surf->dcc_size = align64(surf->surf_size >> 8,
d574 1
a574 1
   if (surf->htile_size && tex->last_level)
a576 217
   surf->is_linear = surf->u.legacy.level[0].mode == RADEON_SURF_MODE_LINEAR_ALIGNED;
   return 0;
}

/* This is only called when expecting a tiled layout. */
static int
gfx9_get_preferred_swizzle_mode(struct amdgpu_winsys *ws,
                                ADDR2_COMPUTE_SURFACE_INFO_INPUT *in,
                                bool is_fmask, AddrSwizzleMode *swizzle_mode)
{
   ADDR_E_RETURNCODE ret;
   ADDR2_GET_PREFERRED_SURF_SETTING_INPUT sin = {0};
   ADDR2_GET_PREFERRED_SURF_SETTING_OUTPUT sout = {0};

   sin.size = sizeof(ADDR2_GET_PREFERRED_SURF_SETTING_INPUT);
   sout.size = sizeof(ADDR2_GET_PREFERRED_SURF_SETTING_OUTPUT);

   sin.flags = in->flags;
   sin.resourceType = in->resourceType;
   sin.format = in->format;
   sin.resourceLoction = ADDR_RSRC_LOC_INVIS;
   /* TODO: We could allow some of these: */
   sin.forbiddenBlock.micro = 1; /* don't allow the 256B swizzle modes */
   sin.forbiddenBlock.var = 1; /* don't allow the variable-sized swizzle modes */
   sin.forbiddenBlock.linear = 1; /* don't allow linear swizzle modes */
   sin.bpp = in->bpp;
   sin.width = in->width;
   sin.height = in->height;
   sin.numSlices = in->numSlices;
   sin.numMipLevels = in->numMipLevels;
   sin.numSamples = in->numSamples;
   sin.numFrags = in->numFrags;

   if (is_fmask) {
      sin.flags.color = 0;
      sin.flags.fmask = 1;
   }

   ret = Addr2GetPreferredSurfaceSetting(ws->addrlib, &sin, &sout);
   if (ret != ADDR_OK)
      return ret;

   *swizzle_mode = sout.swizzleMode;
   return 0;
}

static int gfx9_compute_miptree(struct amdgpu_winsys *ws,
                                struct radeon_surf *surf, bool compressed,
                                ADDR2_COMPUTE_SURFACE_INFO_INPUT *in)
{
   ADDR2_MIP_INFO mip_info[RADEON_SURF_MAX_LEVELS] = {};
   ADDR2_COMPUTE_SURFACE_INFO_OUTPUT out = {0};
   ADDR_E_RETURNCODE ret;

   out.size = sizeof(ADDR2_COMPUTE_SURFACE_INFO_OUTPUT);
   out.pMipInfo = mip_info;

   ret = Addr2ComputeSurfaceInfo(ws->addrlib, in, &out);
   if (ret != ADDR_OK)
      return ret;

   if (in->flags.stencil) {
      surf->u.gfx9.stencil.swizzle_mode = in->swizzleMode;
      surf->u.gfx9.stencil.epitch = out.epitchIsHeight ? out.mipChainHeight - 1 :
                                                         out.mipChainPitch - 1;
      surf->surf_alignment = MAX2(surf->surf_alignment, out.baseAlign);
      surf->u.gfx9.stencil_offset = align(surf->surf_size, out.baseAlign);
      surf->surf_size = surf->u.gfx9.stencil_offset + out.surfSize;
      return 0;
   }

   surf->u.gfx9.surf.swizzle_mode = in->swizzleMode;
   surf->u.gfx9.surf.epitch = out.epitchIsHeight ? out.mipChainHeight - 1 :
                                                   out.mipChainPitch - 1;

   /* CMASK fast clear uses these even if FMASK isn't allocated.
    * FMASK only supports the Z swizzle modes, whose numbers are multiples of 4.
    */
   surf->u.gfx9.fmask.swizzle_mode = surf->u.gfx9.surf.swizzle_mode & ~0x3;
   surf->u.gfx9.fmask.epitch = surf->u.gfx9.surf.epitch;

   surf->u.gfx9.surf_slice_size = out.sliceSize;
   surf->u.gfx9.surf_pitch = out.pitch;
   surf->u.gfx9.surf_height = out.height;
   surf->surf_size = out.surfSize;
   surf->surf_alignment = out.baseAlign;

   if (in->swizzleMode == ADDR_SW_LINEAR) {
      for (unsigned i = 0; i < in->numMipLevels; i++)
         surf->u.gfx9.offset[i] = mip_info[i].offset;
   }

   if (in->flags.depth) {
      assert(in->swizzleMode != ADDR_SW_LINEAR);

      /* HTILE */
      ADDR2_COMPUTE_HTILE_INFO_INPUT hin = {0};
      ADDR2_COMPUTE_HTILE_INFO_OUTPUT hout = {0};

      hin.size = sizeof(ADDR2_COMPUTE_HTILE_INFO_INPUT);
      hout.size = sizeof(ADDR2_COMPUTE_HTILE_INFO_OUTPUT);

      hin.hTileFlags.pipeAligned = 1;
      hin.hTileFlags.rbAligned = 1;
      hin.depthFlags = in->flags;
      hin.swizzleMode = in->swizzleMode;
      hin.unalignedWidth = in->width;
      hin.unalignedHeight = in->height;
      hin.numSlices = in->numSlices;
      hin.numMipLevels = in->numMipLevels;

      ret = Addr2ComputeHtileInfo(ws->addrlib, &hin, &hout);
      if (ret != ADDR_OK)
         return ret;

      surf->u.gfx9.htile.rb_aligned = hin.hTileFlags.rbAligned;
      surf->u.gfx9.htile.pipe_aligned = hin.hTileFlags.pipeAligned;
      surf->htile_size = hout.htileBytes;
      surf->htile_alignment = hout.baseAlign;
   } else {
      /* DCC */
      if (!(surf->flags & RADEON_SURF_DISABLE_DCC) &&
          !(surf->flags & RADEON_SURF_SCANOUT) &&
          !compressed &&
          in->swizzleMode != ADDR_SW_LINEAR &&
          /* TODO: We could support DCC with MSAA. */
          in->numSamples == 1) {
         ADDR2_COMPUTE_DCCINFO_INPUT din = {0};
         ADDR2_COMPUTE_DCCINFO_OUTPUT dout = {0};

         din.size = sizeof(ADDR2_COMPUTE_DCCINFO_INPUT);
         dout.size = sizeof(ADDR2_COMPUTE_DCCINFO_OUTPUT);

         din.dccKeyFlags.pipeAligned = 1;
         din.dccKeyFlags.rbAligned = 1;
         din.colorFlags = in->flags;
         din.resourceType = in->resourceType;
         din.swizzleMode = in->swizzleMode;
         din.bpp = in->bpp;
         din.unalignedWidth = in->width;
         din.unalignedHeight = in->height;
         din.numSlices = in->numSlices;
         din.numFrags = in->numFrags;
         din.numMipLevels = in->numMipLevels;
         din.dataSurfaceSize = out.surfSize;

         ret = Addr2ComputeDccInfo(ws->addrlib, &din, &dout);
         if (ret != ADDR_OK)
            return ret;

         surf->u.gfx9.dcc.rb_aligned = din.dccKeyFlags.rbAligned;
         surf->u.gfx9.dcc.pipe_aligned = din.dccKeyFlags.pipeAligned;
         surf->u.gfx9.dcc_pitch_max = dout.pitch - 1;
         surf->dcc_size = dout.dccRamSize;
         surf->dcc_alignment = dout.dccRamBaseAlign;
      }

      /* FMASK */
      if (in->numSamples > 1) {
         ADDR2_COMPUTE_FMASK_INFO_INPUT fin = {0};
         ADDR2_COMPUTE_FMASK_INFO_OUTPUT fout = {0};

         fin.size = sizeof(ADDR2_COMPUTE_FMASK_INFO_INPUT);
         fout.size = sizeof(ADDR2_COMPUTE_FMASK_INFO_OUTPUT);

         ret = gfx9_get_preferred_swizzle_mode(ws, in, true, &fin.swizzleMode);
         if (ret != ADDR_OK)
            return ret;

         fin.unalignedWidth = in->width;
         fin.unalignedHeight = in->height;
         fin.numSlices = in->numSlices;
         fin.numSamples = in->numSamples;
         fin.numFrags = in->numFrags;

         ret = Addr2ComputeFmaskInfo(ws->addrlib, &fin, &fout);
         if (ret != ADDR_OK)
            return ret;

         surf->u.gfx9.fmask.swizzle_mode = fin.swizzleMode;
         surf->u.gfx9.fmask.epitch = fout.pitch - 1;
         surf->u.gfx9.fmask_size = fout.fmaskBytes;
         surf->u.gfx9.fmask_alignment = fout.baseAlign;
      }

      /* CMASK */
      if (in->swizzleMode != ADDR_SW_LINEAR) {
         ADDR2_COMPUTE_CMASK_INFO_INPUT cin = {0};
         ADDR2_COMPUTE_CMASK_INFO_OUTPUT cout = {0};

         cin.size = sizeof(ADDR2_COMPUTE_CMASK_INFO_INPUT);
         cout.size = sizeof(ADDR2_COMPUTE_CMASK_INFO_OUTPUT);

         cin.cMaskFlags.pipeAligned = 1;
         cin.cMaskFlags.rbAligned = 1;
         cin.colorFlags = in->flags;
         cin.resourceType = in->resourceType;
         cin.unalignedWidth = in->width;
         cin.unalignedHeight = in->height;
         cin.numSlices = in->numSlices;

         if (in->numSamples > 1)
            cin.swizzleMode = surf->u.gfx9.fmask.swizzle_mode;
         else
            cin.swizzleMode = in->swizzleMode;

         ret = Addr2ComputeCmaskInfo(ws->addrlib, &cin, &cout);
         if (ret != ADDR_OK)
            return ret;

         surf->u.gfx9.cmask.rb_aligned = cin.cMaskFlags.rbAligned;
         surf->u.gfx9.cmask.pipe_aligned = cin.cMaskFlags.pipeAligned;
         surf->u.gfx9.cmask_size = cout.cmaskBytes;
         surf->u.gfx9.cmask_alignment = cout.baseAlign;
      }
   }

d580 2
a581 5
static int gfx9_surface_init(struct radeon_winsys *rws,
                             const struct pipe_resource *tex,
                             unsigned flags, unsigned bpe,
                             enum radeon_surf_mode mode,
                             struct radeon_surf *surf)
a582 180
   struct amdgpu_winsys *ws = (struct amdgpu_winsys*)rws;
   bool compressed;
   ADDR2_COMPUTE_SURFACE_INFO_INPUT AddrSurfInfoIn = {0};
   int r;

   assert(!(flags & RADEON_SURF_FMASK));

   r = amdgpu_surface_sanity(tex);
   if (r)
      return r;

   AddrSurfInfoIn.size = sizeof(ADDR2_COMPUTE_SURFACE_INFO_INPUT);

   surf->blk_w = util_format_get_blockwidth(tex->format);
   surf->blk_h = util_format_get_blockheight(tex->format);
   surf->bpe = bpe;
   surf->flags = flags;

   compressed = surf->blk_w == 4 && surf->blk_h == 4;

   /* The format must be set correctly for the allocation of compressed
    * textures to work. In other cases, setting the bpp is sufficient. */
   if (compressed) {
      switch (bpe) {
      case 8:
         AddrSurfInfoIn.format = ADDR_FMT_BC1;
         break;
      case 16:
         AddrSurfInfoIn.format = ADDR_FMT_BC3;
         break;
      default:
         assert(0);
      }
   } else {
      AddrSurfInfoIn.bpp = bpe * 8;
   }

   AddrSurfInfoIn.flags.color = !(flags & RADEON_SURF_Z_OR_SBUFFER);
   AddrSurfInfoIn.flags.depth = (flags & RADEON_SURF_ZBUFFER) != 0;
   AddrSurfInfoIn.flags.display = (flags & RADEON_SURF_SCANOUT) != 0;
   AddrSurfInfoIn.flags.texture = 1;
   AddrSurfInfoIn.flags.opt4space = 1;

   AddrSurfInfoIn.numMipLevels = tex->last_level + 1;
   AddrSurfInfoIn.numSamples = tex->nr_samples ? tex->nr_samples : 1;
   AddrSurfInfoIn.numFrags = AddrSurfInfoIn.numSamples;

   switch (tex->target) {
   /* GFX9 doesn't support 1D depth textures, so allocate all 1D textures
    * as 2D to avoid having shader variants for 1D vs 2D, so all shaders
    * must sample 1D textures as 2D. */
   case PIPE_TEXTURE_1D:
   case PIPE_TEXTURE_1D_ARRAY:
   case PIPE_TEXTURE_2D:
   case PIPE_TEXTURE_2D_ARRAY:
   case PIPE_TEXTURE_RECT:
   case PIPE_TEXTURE_CUBE:
   case PIPE_TEXTURE_CUBE_ARRAY:
   case PIPE_TEXTURE_3D:
      if (tex->target == PIPE_TEXTURE_3D)
         AddrSurfInfoIn.resourceType = ADDR_RSRC_TEX_3D;
      else
         AddrSurfInfoIn.resourceType = ADDR_RSRC_TEX_2D;

      AddrSurfInfoIn.width = tex->width0;
      AddrSurfInfoIn.height = tex->height0;

      if (tex->target == PIPE_TEXTURE_3D)
         AddrSurfInfoIn.numSlices = tex->depth0;
      else if (tex->target == PIPE_TEXTURE_CUBE)
         AddrSurfInfoIn.numSlices = 6;
      else
         AddrSurfInfoIn.numSlices = tex->array_size;

      switch (mode) {
      case RADEON_SURF_MODE_LINEAR_ALIGNED:
         assert(tex->nr_samples <= 1);
         assert(!(flags & RADEON_SURF_Z_OR_SBUFFER));
         AddrSurfInfoIn.swizzleMode = ADDR_SW_LINEAR;
         break;

      case RADEON_SURF_MODE_1D:
      case RADEON_SURF_MODE_2D:
         r = gfx9_get_preferred_swizzle_mode(ws, &AddrSurfInfoIn, false,
                                             &AddrSurfInfoIn.swizzleMode);
         if (r)
            return r;
         break;

      default:
         assert(0);
      }
      break;

   default:
      assert(0);
   }

   surf->u.gfx9.resource_type = AddrSurfInfoIn.resourceType;

   surf->surf_size = 0;
   surf->dcc_size = 0;
   surf->htile_size = 0;
   surf->u.gfx9.surf_offset = 0;
   surf->u.gfx9.stencil_offset = 0;
   surf->u.gfx9.fmask_size = 0;
   surf->u.gfx9.cmask_size = 0;

   /* Calculate texture layout information. */
   r = gfx9_compute_miptree(ws, surf, compressed, &AddrSurfInfoIn);
   if (r)
      return r;

   /* Calculate texture layout information for stencil. */
   if (flags & RADEON_SURF_SBUFFER) {
      AddrSurfInfoIn.bpp = 8;
      AddrSurfInfoIn.flags.depth = 0;
      AddrSurfInfoIn.flags.stencil = 1;

      r = gfx9_compute_miptree(ws, surf, compressed, &AddrSurfInfoIn);
      if (r)
         return r;
   }

   surf->is_linear = surf->u.gfx9.surf.swizzle_mode == ADDR_SW_LINEAR;
   surf->num_dcc_levels = surf->dcc_size ? tex->last_level + 1 : 0;

   switch (surf->u.gfx9.surf.swizzle_mode) {
   /* S = standard. */
   case ADDR_SW_256B_S:
   case ADDR_SW_4KB_S:
   case ADDR_SW_64KB_S:
   case ADDR_SW_VAR_S:
   case ADDR_SW_64KB_S_T:
   case ADDR_SW_4KB_S_X:
   case ADDR_SW_64KB_S_X:
   case ADDR_SW_VAR_S_X:
      surf->micro_tile_mode = RADEON_MICRO_MODE_THIN;
      break;

   /* D = display. */
   case ADDR_SW_LINEAR:
   case ADDR_SW_256B_D:
   case ADDR_SW_4KB_D:
   case ADDR_SW_64KB_D:
   case ADDR_SW_VAR_D:
   case ADDR_SW_64KB_D_T:
   case ADDR_SW_4KB_D_X:
   case ADDR_SW_64KB_D_X:
   case ADDR_SW_VAR_D_X:
      surf->micro_tile_mode = RADEON_MICRO_MODE_DISPLAY;
      break;

   /* R = rotated. */
   case ADDR_SW_256B_R:
   case ADDR_SW_4KB_R:
   case ADDR_SW_64KB_R:
   case ADDR_SW_VAR_R:
   case ADDR_SW_64KB_R_T:
   case ADDR_SW_4KB_R_X:
   case ADDR_SW_64KB_R_X:
   case ADDR_SW_VAR_R_X:
      surf->micro_tile_mode = RADEON_MICRO_MODE_ROTATED;
      break;

   /* Z = depth. */
   case ADDR_SW_4KB_Z:
   case ADDR_SW_64KB_Z:
   case ADDR_SW_VAR_Z:
   case ADDR_SW_64KB_Z_T:
   case ADDR_SW_4KB_Z_X:
   case ADDR_SW_64KB_Z_X:
   case ADDR_SW_VAR_Z_X:
      surf->micro_tile_mode = RADEON_MICRO_MODE_DEPTH;
      break;

   default:
      assert(0);
   }

d588 2
a589 4
   if (ws->info.chip_class >= GFX9)
      ws->base.surface_init = gfx9_surface_init;
   else
      ws->base.surface_init = gfx6_surface_init;
@


