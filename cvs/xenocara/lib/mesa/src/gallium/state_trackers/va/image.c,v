head	1.2;
access;
symbols
	mesa-17_1_6:1.1.1.4
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.30;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.41.55;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.41.55;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.17.23;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.31.01;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.08.14.09.35.39;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/**************************************************************************
 *
 * Copyright 2010 Thomas Balling SÃ¸rensen & Orasanu Lucian.
 * Copyright 2014 Advanced Micro Devices, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "pipe/p_screen.h"

#include "util/u_memory.h"
#include "util/u_handle_table.h"
#include "util/u_surface.h"
#include "util/u_video.h"

#include "vl/vl_winsys.h"
#include "vl/vl_video_buffer.h"

#include "va_private.h"

static const VAImageFormat formats[] =
{
   {VA_FOURCC('N','V','1','2')},
   {VA_FOURCC('I','4','2','0')},
   {VA_FOURCC('Y','V','1','2')},
   {VA_FOURCC('Y','U','Y','V')},
   {VA_FOURCC('U','Y','V','Y')},
   {.fourcc = VA_FOURCC('B','G','R','A'), .byte_order = VA_LSB_FIRST, 32, 32,
    0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000},
   {.fourcc = VA_FOURCC('R','G','B','A'), .byte_order = VA_LSB_FIRST, 32, 32,
    0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000},
   {.fourcc = VA_FOURCC('B','G','R','X'), .byte_order = VA_LSB_FIRST, 32, 24,
    0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000},
   {.fourcc = VA_FOURCC('R','G','B','X'), .byte_order = VA_LSB_FIRST, 32, 24,
    0x000000ff, 0x0000ff00, 0x00ff0000, 0x00000000}
};

static void
vlVaVideoSurfaceSize(vlVaSurface *p_surf, int component,
                     unsigned *width, unsigned *height)
{
   *width = p_surf->templat.width;
   *height = p_surf->templat.height;

   vl_video_buffer_adjust_size(width, height, component,
                               p_surf->templat.chroma_format,
                               p_surf->templat.interlaced);
}

VAStatus
vlVaQueryImageFormats(VADriverContextP ctx, VAImageFormat *format_list, int *num_formats)
{
   struct pipe_screen *pscreen;
   enum pipe_format format;
   int i;

   STATIC_ASSERT(ARRAY_SIZE(formats) == VL_VA_MAX_IMAGE_FORMATS);

   if (!ctx)
      return VA_STATUS_ERROR_INVALID_CONTEXT;

   if (!(format_list && num_formats))
      return VA_STATUS_ERROR_INVALID_PARAMETER;

   *num_formats = 0;
   pscreen = VL_VA_PSCREEN(ctx);
   for (i = 0; i < ARRAY_SIZE(formats); ++i) {
      format = VaFourccToPipeFormat(formats[i].fourcc);
      if (pscreen->is_video_format_supported(pscreen, format,
          PIPE_VIDEO_PROFILE_UNKNOWN,
          PIPE_VIDEO_ENTRYPOINT_BITSTREAM))
         format_list[(*num_formats)++] = formats[i];
   }

   return VA_STATUS_SUCCESS;
}

VAStatus
vlVaCreateImage(VADriverContextP ctx, VAImageFormat *format, int width, int height, VAImage *image)
{
   VAStatus status;
   vlVaDriver *drv;
   VAImage *img;
   int w, h;

   if (!ctx)
      return VA_STATUS_ERROR_INVALID_CONTEXT;

   if (!(format && image && width && height))
      return VA_STATUS_ERROR_INVALID_PARAMETER;

   drv = VL_VA_DRIVER(ctx);

   img = CALLOC(1, sizeof(VAImage));
   if (!img)
      return VA_STATUS_ERROR_ALLOCATION_FAILED;
   pipe_mutex_lock(drv->mutex);
   img->image_id = handle_table_add(drv->htab, img);
   pipe_mutex_unlock(drv->mutex);

   img->format = *format;
   img->width = width;
   img->height = height;
   w = align(width, 2);
   h = align(height, 2);

   switch (format->fourcc) {
   case VA_FOURCC('N','V','1','2'):
      img->num_planes = 2;
      img->pitches[0] = w;
      img->offsets[0] = 0;
      img->pitches[1] = w;
      img->offsets[1] = w * h;
      img->data_size  = w * h * 3 / 2;
      break;

   case VA_FOURCC('I','4','2','0'):
   case VA_FOURCC('Y','V','1','2'):
      img->num_planes = 3;
      img->pitches[0] = w;
      img->offsets[0] = 0;
      img->pitches[1] = w / 2;
      img->offsets[1] = w * h;
      img->pitches[2] = w / 2;
      img->offsets[2] = w * h * 5 / 4;
      img->data_size  = w * h * 3 / 2;
      break;

   case VA_FOURCC('U','Y','V','Y'):
   case VA_FOURCC('Y','U','Y','V'):
      img->num_planes = 1;
      img->pitches[0] = w * 2;
      img->offsets[0] = 0;
      img->data_size  = w * h * 2;
      break;

   case VA_FOURCC('B','G','R','A'):
   case VA_FOURCC('R','G','B','A'):
   case VA_FOURCC('B','G','R','X'):
   case VA_FOURCC('R','G','B','X'):
      img->num_planes = 1;
      img->pitches[0] = w * 4;
      img->offsets[0] = 0;
      img->data_size  = w * h * 4;
      break;

   default:
      return VA_STATUS_ERROR_INVALID_IMAGE_FORMAT;
   }

   status =  vlVaCreateBuffer(ctx, 0, VAImageBufferType,
                           align(img->data_size, 16),
                           1, NULL, &img->buf);
   if (status != VA_STATUS_SUCCESS)
      return status;
   *image = *img;

   return status;
}

VAStatus
vlVaDeriveImage(VADriverContextP ctx, VASurfaceID surface, VAImage *image)
{
   vlVaDriver *drv;
   vlVaSurface *surf;
   vlVaBuffer *img_buf;
   VAImage *img;
   struct pipe_surface **surfaces;
   int w;
   int h;
   int i;

   if (!ctx)
      return VA_STATUS_ERROR_INVALID_CONTEXT;

   drv = VL_VA_DRIVER(ctx);

   if (!drv)
      return VA_STATUS_ERROR_INVALID_CONTEXT;

   surf = handle_table_get(drv->htab, surface);

   if (!surf || !surf->buffer || surf->buffer->interlaced)
      return VA_STATUS_ERROR_INVALID_SURFACE;

   surfaces = surf->buffer->get_surfaces(surf->buffer);
   if (!surfaces || !surfaces[0]->texture)
      return VA_STATUS_ERROR_ALLOCATION_FAILED;

   img = CALLOC(1, sizeof(VAImage));
   if (!img)
      return VA_STATUS_ERROR_ALLOCATION_FAILED;

   img->format.fourcc = PipeFormatToVaFourcc(surf->buffer->buffer_format);
   img->buf = VA_INVALID_ID;
   img->width = surf->buffer->width;
   img->height = surf->buffer->height;
   img->num_palette_entries = 0;
   img->entry_bytes = 0;
   w = align(surf->buffer->width, 2);
   h = align(surf->buffer->height, 2);

   for (i = 0; i < ARRAY_SIZE(formats); ++i) {
      if (img->format.fourcc == formats[i].fourcc) {
         img->format = formats[i];
         break;
      }
   }

   switch (img->format.fourcc) {
   case VA_FOURCC('U','Y','V','Y'):
   case VA_FOURCC('Y','U','Y','V'):
      img->num_planes = 1;
      img->pitches[0] = w * 2;
      img->offsets[0] = 0;
      img->data_size  = w * h * 2;
      break;

   case VA_FOURCC('B','G','R','A'):
   case VA_FOURCC('R','G','B','A'):
   case VA_FOURCC('B','G','R','X'):
   case VA_FOURCC('R','G','B','X'):
      img->num_planes = 1;
      img->pitches[0] = w * 4;
      img->offsets[0] = 0;
      img->data_size  = w * h * 4;
      break;

   default:
      /* VaDeriveImage is designed for contiguous planes. */
      FREE(img);
      return VA_STATUS_ERROR_INVALID_IMAGE_FORMAT;
   }

   img_buf = CALLOC(1, sizeof(vlVaBuffer));
   if (!img_buf) {
      FREE(img);
      return VA_STATUS_ERROR_ALLOCATION_FAILED;
   }

   pipe_mutex_lock(drv->mutex);
   img->image_id = handle_table_add(drv->htab, img);

   img_buf->type = VAImageBufferType;
   img_buf->size = img->data_size;
   img_buf->num_elements = 1;

   pipe_resource_reference(&img_buf->derived_surface.resource, surfaces[0]->texture);

   img->buf = handle_table_add(VL_VA_DRIVER(ctx)->htab, img_buf);
   pipe_mutex_unlock(drv->mutex);

   *image = *img;

   return VA_STATUS_SUCCESS;
}

VAStatus
vlVaDestroyImage(VADriverContextP ctx, VAImageID image)
{
   vlVaDriver *drv;
   VAImage  *vaimage;
   VAStatus status;

   if (!ctx)
      return VA_STATUS_ERROR_INVALID_CONTEXT;

   drv = VL_VA_DRIVER(ctx);
   pipe_mutex_lock(drv->mutex);
   vaimage = handle_table_get(drv->htab, image);
   if (!vaimage) {
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_INVALID_IMAGE;
   }

   handle_table_remove(VL_VA_DRIVER(ctx)->htab, image);
   pipe_mutex_unlock(drv->mutex);
   status = vlVaDestroyBuffer(ctx, vaimage->buf);
   FREE(vaimage);
   return status;
}

VAStatus
vlVaSetImagePalette(VADriverContextP ctx, VAImageID image, unsigned char *palette)
{
   if (!ctx)
      return VA_STATUS_ERROR_INVALID_CONTEXT;

   return VA_STATUS_ERROR_UNIMPLEMENTED;
}

VAStatus
vlVaGetImage(VADriverContextP ctx, VASurfaceID surface, int x, int y,
             unsigned int width, unsigned int height, VAImageID image)
{
   vlVaDriver *drv;
   vlVaSurface *surf;
   vlVaBuffer *img_buf;
   VAImage *vaimage;
   struct pipe_sampler_view **views;
   enum pipe_format format;
   bool convert = false;
   void *data[3];
   unsigned pitches[3], i, j;

   if (!ctx)
      return VA_STATUS_ERROR_INVALID_CONTEXT;

   drv = VL_VA_DRIVER(ctx);

   pipe_mutex_lock(drv->mutex);
   surf = handle_table_get(drv->htab, surface);
   if (!surf || !surf->buffer) {
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_INVALID_SURFACE;
   }

   vaimage = handle_table_get(drv->htab, image);
   if (!vaimage) {
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_INVALID_IMAGE;
   }

   img_buf = handle_table_get(drv->htab, vaimage->buf);
   if (!img_buf) {
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_INVALID_BUFFER;
   }

   format = VaFourccToPipeFormat(vaimage->format.fourcc);
   if (format == PIPE_FORMAT_NONE) {
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_OPERATION_FAILED;
   }

   if (format != surf->buffer->buffer_format) {
      /* support NV12 to YV12 and IYUV conversion now only */
      if ((format == PIPE_FORMAT_YV12 &&
          surf->buffer->buffer_format == PIPE_FORMAT_NV12) ||
          (format == PIPE_FORMAT_IYUV &&
          surf->buffer->buffer_format == PIPE_FORMAT_NV12))
         convert = true;
      else {
         pipe_mutex_unlock(drv->mutex);
         return VA_STATUS_ERROR_OPERATION_FAILED;
      }
   }

   views = surf->buffer->get_sampler_view_planes(surf->buffer);
   if (!views) {
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_OPERATION_FAILED;
   }

   for (i = 0; i < vaimage->num_planes; i++) {
      data[i] = img_buf->data + vaimage->offsets[i];
      pitches[i] = vaimage->pitches[i];
   }
   if (vaimage->format.fourcc == VA_FOURCC('I','4','2','0')) {
      void *tmp_d;
      unsigned tmp_p;
      tmp_d  = data[1];
      data[1] = data[2];
      data[2] = tmp_d;
      tmp_p = pitches[1];
      pitches[1] = pitches[2];
      pitches[2] = tmp_p;
   }

   for (i = 0; i < vaimage->num_planes; i++) {
      unsigned width, height;
      if (!views[i]) continue;
      vlVaVideoSurfaceSize(surf, i, &width, &height);
      for (j = 0; j < views[i]->texture->array_size; ++j) {
         struct pipe_box box = {0, 0, j, width, height, 1};
         struct pipe_transfer *transfer;
         uint8_t *map;
         map = drv->pipe->transfer_map(drv->pipe, views[i]->texture, 0,
                  PIPE_TRANSFER_READ, &box, &transfer);
         if (!map) {
            pipe_mutex_unlock(drv->mutex);
            return VA_STATUS_ERROR_OPERATION_FAILED;
         }

         if (i == 1 && convert) {
            u_copy_nv12_to_yv12(data, pitches, i, j,
               transfer->stride, views[i]->texture->array_size,
               map, box.width, box.height);
         } else {
            util_copy_rect(data[i] + pitches[i] * j,
               views[i]->texture->format,
               pitches[i] * views[i]->texture->array_size, 0, 0,
               box.width, box.height, map, transfer->stride, 0, 0);
         }
         pipe_transfer_unmap(drv->pipe, transfer);
      }
   }
   pipe_mutex_unlock(drv->mutex);

   return VA_STATUS_SUCCESS;
}

VAStatus
vlVaPutImage(VADriverContextP ctx, VASurfaceID surface, VAImageID image,
             int src_x, int src_y, unsigned int src_width, unsigned int src_height,
             int dest_x, int dest_y, unsigned int dest_width, unsigned int dest_height)
{
   vlVaDriver *drv;
   vlVaSurface *surf;
   vlVaBuffer *img_buf;
   VAImage *vaimage;
   struct pipe_sampler_view **views;
   enum pipe_format format;
   void *data[3];
   unsigned pitches[3], i, j;

   if (!ctx)
      return VA_STATUS_ERROR_INVALID_CONTEXT;

   drv = VL_VA_DRIVER(ctx);
   pipe_mutex_lock(drv->mutex);

   surf = handle_table_get(drv->htab, surface);
   if (!surf || !surf->buffer) {
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_INVALID_SURFACE;
   }

   vaimage = handle_table_get(drv->htab, image);
   if (!vaimage) {
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_INVALID_IMAGE;
   }

   img_buf = handle_table_get(drv->htab, vaimage->buf);
   if (!img_buf) {
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_INVALID_BUFFER;
   }

   if (img_buf->derived_surface.resource) {
      /* Attempting to transfer derived image to surface */
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_UNIMPLEMENTED;
   }

   format = VaFourccToPipeFormat(vaimage->format.fourcc);

   if (format == PIPE_FORMAT_NONE) {
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_OPERATION_FAILED;
   }

   if ((format != surf->buffer->buffer_format) &&
         ((format != PIPE_FORMAT_YV12) || (surf->buffer->buffer_format != PIPE_FORMAT_NV12)) &&
         ((format != PIPE_FORMAT_IYUV) || (surf->buffer->buffer_format != PIPE_FORMAT_NV12))) {
      struct pipe_video_buffer *tmp_buf;
      struct pipe_video_buffer templat = surf->templat;

      templat.buffer_format = format;
      tmp_buf = drv->pipe->create_video_buffer(drv->pipe, &templat);

      if (!tmp_buf) {
         pipe_mutex_unlock(drv->mutex);
         return VA_STATUS_ERROR_ALLOCATION_FAILED;
      }

      surf->buffer->destroy(surf->buffer);
      surf->buffer = tmp_buf;
      surf->templat.buffer_format = format;
   }

   views = surf->buffer->get_sampler_view_planes(surf->buffer);
   if (!views) {
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_OPERATION_FAILED;
   }

   for (i = 0; i < vaimage->num_planes; i++) {
      data[i] = img_buf->data + vaimage->offsets[i];
      pitches[i] = vaimage->pitches[i];
   }
   if (vaimage->format.fourcc == VA_FOURCC('I','4','2','0')) {
      void *tmp_d;
      unsigned tmp_p;
      tmp_d  = data[1];
      data[1] = data[2];
      data[2] = tmp_d;
      tmp_p = pitches[1];
      pitches[1] = pitches[2];
      pitches[2] = tmp_p;
   }

   for (i = 0; i < vaimage->num_planes; ++i) {
      unsigned width, height;
      if (!views[i]) continue;
      vlVaVideoSurfaceSize(surf, i, &width, &height);
      if (((format == PIPE_FORMAT_YV12) || (format == PIPE_FORMAT_IYUV)) &&
            (surf->buffer->buffer_format == PIPE_FORMAT_NV12)) {
         struct pipe_transfer *transfer = NULL;
         uint8_t *map = NULL;
         struct pipe_box dst_box_1 = {0, 0, 0, width, height, 1};
         map = drv->pipe->transfer_map(drv->pipe,
                                       views[i]->texture,
                                       0,
                                       PIPE_TRANSFER_DISCARD_RANGE,
                                       &dst_box_1, &transfer);
         if (map == NULL)
            return VA_STATUS_ERROR_OPERATION_FAILED;

         u_copy_yv12_img_to_nv12_surf ((ubyte * const*)data, map, width, height,
				       pitches[i], transfer->stride, i);
         pipe_transfer_unmap(drv->pipe, transfer);
      } else {
         for (j = 0; j < views[i]->texture->array_size; ++j) {
            struct pipe_box dst_box = {0, 0, j, width, height, 1};
            drv->pipe->texture_subdata(drv->pipe, views[i]->texture, 0,
                                       PIPE_TRANSFER_WRITE, &dst_box,
                                       data[i] + pitches[i] * j,
                                       pitches[i] * views[i]->texture->array_size, 0);
         }
      }
   }
   pipe_mutex_unlock(drv->mutex);

   return VA_STATUS_SUCCESS;
}
@


1.1
log
@Initial revision
@
text
@d37 1
d41 1
a41 1
static const VAImageFormat formats[VL_VA_MAX_IMAGE_FORMATS] =
d48 8
a55 1
   {VA_FOURCC('B','G','R','A')}
d65 3
a67 9
   if (component > 0) {
      if (p_surf->templat.chroma_format == PIPE_VIDEO_CHROMA_FORMAT_420) {
         *width /= 2;
         *height /= 2;
      } else if (p_surf->templat.chroma_format == PIPE_VIDEO_CHROMA_FORMAT_422)
         *width /= 2;
   }
   if (p_surf->templat.interlaced)
      *height /= 2;
d77 2
d87 2
a88 2
   for (i = 0; i < VL_VA_MAX_IMAGE_FORMATS; ++i) {
      format = YCbCrToPipe(formats[i].fourcc);
d117 1
d119 1
d158 3
d184 9
d196 80
a275 1
   return VA_STATUS_ERROR_UNIMPLEMENTED;
d281 1
d283 1
d288 5
a292 2
   vaimage = handle_table_get(VL_VA_DRIVER(ctx)->htab, image);
   if (!vaimage)
d294 1
d297 2
d300 1
a300 1
   return vlVaDestroyBuffer(ctx, vaimage->buf);
d331 1
d333 2
a334 1
   if (!surf || !surf->buffer)
d336 1
d339 2
a340 1
   if (!vaimage)
d342 1
d345 2
a346 1
   if (!img_buf)
d348 1
d350 3
a352 2
   format = YCbCrToPipe(vaimage->format.fourcc);
   if (format == PIPE_FORMAT_NONE)
d354 1
d357 5
a361 3
      /* support NV12 to YV12 conversion now only */
      if (format == PIPE_FORMAT_YV12 &&
          surf->buffer->buffer_format == PIPE_FORMAT_NV12)
d363 2
a364 1
      else
d366 1
d370 2
a371 1
   if (!views)
d373 1
d400 2
a401 1
         if (!map)
d403 1
d418 1
d441 1
d444 2
a445 1
   if (!surf || !surf->buffer)
d447 1
d450 2
a451 1
   if (!vaimage)
d453 1
d456 2
a457 1
   if (!img_buf)
d459 9
d469 2
a470 2
   format = YCbCrToPipe(vaimage->format.fourcc);
   if (format == PIPE_FORMAT_NONE)
d472 1
d474 3
a476 1
   if (format != surf->buffer->buffer_format) {
d478 1
a478 1
      enum pipe_format old_surf_format = surf->templat.buffer_format;
d480 2
a481 2
      surf->templat.buffer_format = format;
      tmp_buf = drv->pipe->create_video_buffer(drv->pipe, &surf->templat);
d484 2
a485 2
          surf->templat.buffer_format = old_surf_format;
          return VA_STATUS_ERROR_ALLOCATION_FAILED;
d490 1
d494 2
a495 1
   if (!views)
d497 1
d518 24
a541 6
      for (j = 0; j < views[i]->texture->array_size; ++j) {
         struct pipe_box dst_box = {0, 0, j, width, height, 1};
         drv->pipe->transfer_inline_write(drv->pipe, views[i]->texture, 0,
            PIPE_TRANSFER_WRITE, &dst_box,
            data[i] + pitches[i] * j,
            pitches[i] * views[i]->texture->array_size, 0);
d544 1
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@a36 1
#include "vl/vl_video_buffer.h"
d40 1
a40 1
static const VAImageFormat formats[] =
d47 1
a47 8
   {.fourcc = VA_FOURCC('B','G','R','A'), .byte_order = VA_LSB_FIRST, 32, 32,
    0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000},
   {.fourcc = VA_FOURCC('R','G','B','A'), .byte_order = VA_LSB_FIRST, 32, 32,
    0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000},
   {.fourcc = VA_FOURCC('B','G','R','X'), .byte_order = VA_LSB_FIRST, 32, 24,
    0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000},
   {.fourcc = VA_FOURCC('R','G','B','X'), .byte_order = VA_LSB_FIRST, 32, 24,
    0x000000ff, 0x0000ff00, 0x00ff0000, 0x00000000}
d57 9
a65 3
   vl_video_buffer_adjust_size(width, height, component,
                               p_surf->templat.chroma_format,
                               p_surf->templat.interlaced);
a74 2
   STATIC_ASSERT(ARRAY_SIZE(formats) == VL_VA_MAX_IMAGE_FORMATS);

d83 2
a84 2
   for (i = 0; i < ARRAY_SIZE(formats); ++i) {
      format = VaFourccToPipeFormat(formats[i].fourcc);
a112 1
   pipe_mutex_lock(drv->mutex);
a113 1
   pipe_mutex_unlock(drv->mutex);
a151 3
   case VA_FOURCC('R','G','B','A'):
   case VA_FOURCC('B','G','R','X'):
   case VA_FOURCC('R','G','B','X'):
a174 9
   vlVaDriver *drv;
   vlVaSurface *surf;
   vlVaBuffer *img_buf;
   VAImage *img;
   struct pipe_surface **surfaces;
   int w;
   int h;
   int i;

d178 1
a178 80
   drv = VL_VA_DRIVER(ctx);

   if (!drv)
      return VA_STATUS_ERROR_INVALID_CONTEXT;

   surf = handle_table_get(drv->htab, surface);

   if (!surf || !surf->buffer || surf->buffer->interlaced)
      return VA_STATUS_ERROR_INVALID_SURFACE;

   surfaces = surf->buffer->get_surfaces(surf->buffer);
   if (!surfaces || !surfaces[0]->texture)
      return VA_STATUS_ERROR_ALLOCATION_FAILED;

   img = CALLOC(1, sizeof(VAImage));
   if (!img)
      return VA_STATUS_ERROR_ALLOCATION_FAILED;

   img->format.fourcc = PipeFormatToVaFourcc(surf->buffer->buffer_format);
   img->buf = VA_INVALID_ID;
   img->width = surf->buffer->width;
   img->height = surf->buffer->height;
   img->num_palette_entries = 0;
   img->entry_bytes = 0;
   w = align(surf->buffer->width, 2);
   h = align(surf->buffer->height, 2);

   for (i = 0; i < ARRAY_SIZE(formats); ++i) {
      if (img->format.fourcc == formats[i].fourcc) {
         img->format = formats[i];
         break;
      }
   }

   switch (img->format.fourcc) {
   case VA_FOURCC('U','Y','V','Y'):
   case VA_FOURCC('Y','U','Y','V'):
      img->num_planes = 1;
      img->pitches[0] = w * 2;
      img->offsets[0] = 0;
      img->data_size  = w * h * 2;
      break;

   case VA_FOURCC('B','G','R','A'):
   case VA_FOURCC('R','G','B','A'):
   case VA_FOURCC('B','G','R','X'):
   case VA_FOURCC('R','G','B','X'):
      img->num_planes = 1;
      img->pitches[0] = w * 4;
      img->offsets[0] = 0;
      img->data_size  = w * h * 4;
      break;

   default:
      /* VaDeriveImage is designed for contiguous planes. */
      FREE(img);
      return VA_STATUS_ERROR_INVALID_IMAGE_FORMAT;
   }

   img_buf = CALLOC(1, sizeof(vlVaBuffer));
   if (!img_buf) {
      FREE(img);
      return VA_STATUS_ERROR_ALLOCATION_FAILED;
   }

   pipe_mutex_lock(drv->mutex);
   img->image_id = handle_table_add(drv->htab, img);

   img_buf->type = VAImageBufferType;
   img_buf->size = img->data_size;
   img_buf->num_elements = 1;

   pipe_resource_reference(&img_buf->derived_surface.resource, surfaces[0]->texture);

   img->buf = handle_table_add(VL_VA_DRIVER(ctx)->htab, img_buf);
   pipe_mutex_unlock(drv->mutex);

   *image = *img;

   return VA_STATUS_SUCCESS;
a183 1
   vlVaDriver *drv;
a184 1
   VAStatus status;
d189 2
a190 5
   drv = VL_VA_DRIVER(ctx);
   pipe_mutex_lock(drv->mutex);
   vaimage = handle_table_get(drv->htab, image);
   if (!vaimage) {
      pipe_mutex_unlock(drv->mutex);
a191 1
   }
a193 2
   pipe_mutex_unlock(drv->mutex);
   status = vlVaDestroyBuffer(ctx, vaimage->buf);
d195 1
a195 1
   return status;
a225 1
   pipe_mutex_lock(drv->mutex);
d227 1
a227 2
   if (!surf || !surf->buffer) {
      pipe_mutex_unlock(drv->mutex);
a228 1
   }
d231 1
a231 2
   if (!vaimage) {
      pipe_mutex_unlock(drv->mutex);
a232 1
   }
d235 1
a235 2
   if (!img_buf) {
      pipe_mutex_unlock(drv->mutex);
a236 1
   }
d238 2
a239 3
   format = VaFourccToPipeFormat(vaimage->format.fourcc);
   if (format == PIPE_FORMAT_NONE) {
      pipe_mutex_unlock(drv->mutex);
a240 1
   }
d243 3
a245 5
      /* support NV12 to YV12 and IYUV conversion now only */
      if ((format == PIPE_FORMAT_YV12 &&
          surf->buffer->buffer_format == PIPE_FORMAT_NV12) ||
          (format == PIPE_FORMAT_IYUV &&
          surf->buffer->buffer_format == PIPE_FORMAT_NV12))
d247 1
a247 2
      else {
         pipe_mutex_unlock(drv->mutex);
a248 1
      }
d252 1
a252 2
   if (!views) {
      pipe_mutex_unlock(drv->mutex);
a253 1
   }
d280 1
a280 2
         if (!map) {
            pipe_mutex_unlock(drv->mutex);
a281 1
         }
a295 1
   pipe_mutex_unlock(drv->mutex);
a317 1
   pipe_mutex_lock(drv->mutex);
d320 1
a320 2
   if (!surf || !surf->buffer) {
      pipe_mutex_unlock(drv->mutex);
a321 1
   }
d324 1
a324 2
   if (!vaimage) {
      pipe_mutex_unlock(drv->mutex);
a325 1
   }
d328 1
a328 2
   if (!img_buf) {
      pipe_mutex_unlock(drv->mutex);
a329 1
   }
d331 2
a332 10
   if (img_buf->derived_surface.resource) {
      /* Attempting to transfer derived image to surface */
      pipe_mutex_unlock(drv->mutex);
      return VA_STATUS_ERROR_UNIMPLEMENTED;
   }

   format = VaFourccToPipeFormat(vaimage->format.fourcc);

   if (format == PIPE_FORMAT_NONE) {
      pipe_mutex_unlock(drv->mutex);
a333 1
   }
d343 2
a344 3
         surf->templat.buffer_format = old_surf_format;
         pipe_mutex_unlock(drv->mutex);
         return VA_STATUS_ERROR_ALLOCATION_FAILED;
d352 1
a352 2
   if (!views) {
      pipe_mutex_unlock(drv->mutex);
a353 1
   }
a381 1
   pipe_mutex_unlock(drv->mutex);
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d474 1
a474 3
   if ((format != surf->buffer->buffer_format) &&
         ((format != PIPE_FORMAT_YV12) || (surf->buffer->buffer_format != PIPE_FORMAT_NV12)) &&
         ((format != PIPE_FORMAT_IYUV) || (surf->buffer->buffer_format != PIPE_FORMAT_NV12))) {
d476 1
a476 1
      struct pipe_video_buffer templat = surf->templat;
d478 2
a479 2
      templat.buffer_format = format;
      tmp_buf = drv->pipe->create_video_buffer(drv->pipe, &templat);
d482 1
a488 1
      surf->templat.buffer_format = format;
d516 6
a521 24
      if (((format == PIPE_FORMAT_YV12) || (format == PIPE_FORMAT_IYUV)) &&
            (surf->buffer->buffer_format == PIPE_FORMAT_NV12)) {
         struct pipe_transfer *transfer = NULL;
         uint8_t *map = NULL;
         struct pipe_box dst_box_1 = {0, 0, 0, width, height, 1};
         map = drv->pipe->transfer_map(drv->pipe,
                                       views[i]->texture,
                                       0,
                                       PIPE_TRANSFER_DISCARD_RANGE,
                                       &dst_box_1, &transfer);
         if (map == NULL)
            return VA_STATUS_ERROR_OPERATION_FAILED;

         u_copy_yv12_img_to_nv12_surf ((ubyte * const*)data, map, width, height,
				       pitches[i], transfer->stride, i);
         pipe_transfer_unmap(drv->pipe, transfer);
      } else {
         for (j = 0; j < views[i]->texture->array_size; ++j) {
            struct pipe_box dst_box = {0, 0, j, width, height, 1};
            drv->pipe->texture_subdata(drv->pipe, views[i]->texture, 0,
                                       PIPE_TRANSFER_WRITE, &dst_box,
                                       data[i] + pitches[i] * j,
                                       pitches[i] * views[i]->texture->array_size, 0);
         }
@


1.1.1.4
log
@Import Mesa 17.1.6
@
text
@a43 2
   {VA_FOURCC('P','0','1','0')},
   {VA_FOURCC('P','0','1','6')},
d117 1
a117 1
   mtx_lock(&drv->mutex);
d119 1
a119 1
   mtx_unlock(&drv->mutex);
a136 10
   case VA_FOURCC('P','0','1','0'):
   case VA_FOURCC('P','0','1','6'):
      img->num_planes = 2;
      img->pitches[0] = w * 2;
      img->offsets[0] = 0;
      img->pitches[1] = w * 2;
      img->offsets[1] = w * h * 2;
      img->data_size  = w * h * 3;
      break;

d261 1
a261 1
   mtx_lock(&drv->mutex);
d271 1
a271 1
   mtx_unlock(&drv->mutex);
d289 1
a289 1
   mtx_lock(&drv->mutex);
d292 1
a292 1
      mtx_unlock(&drv->mutex);
d297 1
a297 1
   mtx_unlock(&drv->mutex);
d331 1
a331 1
   mtx_lock(&drv->mutex);
d334 1
a334 1
      mtx_unlock(&drv->mutex);
d340 1
a340 1
      mtx_unlock(&drv->mutex);
d346 1
a346 1
      mtx_unlock(&drv->mutex);
d352 1
a352 1
      mtx_unlock(&drv->mutex);
d364 1
a364 1
         mtx_unlock(&drv->mutex);
d371 1
a371 1
      mtx_unlock(&drv->mutex);
d401 1
a401 1
            mtx_unlock(&drv->mutex);
d418 1
a418 1
   mtx_unlock(&drv->mutex);
d441 1
a441 1
   mtx_lock(&drv->mutex);
d445 1
a445 1
      mtx_unlock(&drv->mutex);
d451 1
a451 1
      mtx_unlock(&drv->mutex);
d457 1
a457 1
      mtx_unlock(&drv->mutex);
d463 1
a463 1
      mtx_unlock(&drv->mutex);
d470 1
a470 1
      mtx_unlock(&drv->mutex);
d484 1
a484 1
         mtx_unlock(&drv->mutex);
d495 1
a495 1
      mtx_unlock(&drv->mutex);
a515 2
      struct pipe_resource *tex;

a516 2
      tex = views[i]->texture;

d518 12
a529 2
      for (j = 0; j < tex->array_size; ++j) {
         struct pipe_box dst_box = {0, 0, j, width, height, 1};
d531 7
a537 21
         if (((format == PIPE_FORMAT_YV12) || (format == PIPE_FORMAT_IYUV))
             && (surf->buffer->buffer_format == PIPE_FORMAT_NV12)
             && i == 1) {
            struct pipe_transfer *transfer = NULL;
            uint8_t *map = NULL;

            map = drv->pipe->transfer_map(drv->pipe,
                                          tex,
                                          0,
                                          PIPE_TRANSFER_WRITE |
                                          PIPE_TRANSFER_DISCARD_RANGE,
                                          &dst_box, &transfer);
            if (map == NULL)
               return VA_STATUS_ERROR_OPERATION_FAILED;

            u_copy_nv12_from_yv12((const void * const*) data, pitches, i, j,
                                  transfer->stride, tex->array_size,
                                  map, dst_box.width, dst_box.height);
            pipe_transfer_unmap(drv->pipe, transfer);
         } else {
            drv->pipe->texture_subdata(drv->pipe, tex, 0,
d544 1
a544 1
   mtx_unlock(&drv->mutex);
@


