head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	mesa-17_1_6:1.1.1.4
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.30;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.42.15;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.42.15;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.17.45;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.31.05;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.08.14.09.35.44;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Copyright 2011 Joakim Sindholt <opensource@@zhasha.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include "stateblock9.h"
#include "device9.h"
#include "basetexture9.h"
#include "nine_helpers.h"
#include "vertexdeclaration9.h"

#define DBG_CHANNEL DBG_STATEBLOCK

/* XXX TODO: handling of lights is broken */

#define VS_CONST_I_SIZE(device) (device->may_swvp ? (NINE_MAX_CONST_I_SWVP * sizeof(int[4])) : (NINE_MAX_CONST_I * sizeof(int[4])))
#define VS_CONST_B_SIZE(device) (device->may_swvp ? (NINE_MAX_CONST_B_SWVP * sizeof(BOOL)) : (NINE_MAX_CONST_B * sizeof(BOOL)))
#define VS_CONST_F_SWVP_SIZE    (NINE_MAX_CONST_F_SWVP * sizeof(float[4]))

HRESULT
NineStateBlock9_ctor( struct NineStateBlock9 *This,
                      struct NineUnknownParams *pParams,
                      enum nine_stateblock_type type )
{
    HRESULT hr = NineUnknown_ctor(&This->base, pParams);

    DBG("This=%p pParams=%p type=%d\n", This, pParams, type);

    if (FAILED(hr))
        return hr;

    This->type = type;

    This->state.vs_const_f = MALLOC(This->base.device->vs_const_size);
    This->state.ps_const_f = MALLOC(This->base.device->ps_const_size);
    This->state.vs_const_i = MALLOC(VS_CONST_I_SIZE(This->base.device));
    This->state.vs_const_b = MALLOC(VS_CONST_B_SIZE(This->base.device));
    if (!This->state.vs_const_f || !This->state.ps_const_f ||
        !This->state.vs_const_i || !This->state.vs_const_b)
        return E_OUTOFMEMORY;

    if (This->base.device->may_swvp) {
        This->state.vs_const_f_swvp = MALLOC(VS_CONST_F_SWVP_SIZE);
        if (!This->state.vs_const_f_swvp)
            return E_OUTOFMEMORY;
    } else
        This->state.vs_const_f_swvp = NULL;

    return D3D_OK;
}

void
NineStateBlock9_dtor( struct NineStateBlock9 *This )
{
    struct nine_state *state = &This->state;
    struct nine_range *r;
    struct nine_range_pool *pool = &This->base.device->range_pool;

    nine_state_clear(state, FALSE);

    FREE(state->vs_const_f);
    FREE(state->ps_const_f);
    FREE(state->vs_const_i);
    FREE(state->vs_const_b);
    FREE(state->vs_const_f_swvp);

    FREE(state->ff.light);

    FREE(state->ff.transform);

    if (This->state.changed.ps_const_f) {
        for (r = This->state.changed.ps_const_f; r->next; r = r->next);
        nine_range_pool_put_chain(pool, This->state.changed.ps_const_f, r);
    }
    if (This->state.changed.vs_const_f) {
        for (r = This->state.changed.vs_const_f; r->next; r = r->next);
        nine_range_pool_put_chain(pool, This->state.changed.vs_const_f, r);
    }
    if (This->state.changed.vs_const_i) {
        for (r = This->state.changed.vs_const_i; r->next; r = r->next);
        nine_range_pool_put_chain(pool, This->state.changed.vs_const_i, r);
    }
    if (This->state.changed.vs_const_b) {
        for (r = This->state.changed.vs_const_b; r->next; r = r->next);
        nine_range_pool_put_chain(pool, This->state.changed.vs_const_b, r);
    }

    NineUnknown_dtor(&This->base);
}

/* Copy state marked changed in @@mask from @@src to @@dst.
 * If @@apply is false, updating dst->changed can be omitted.
 * TODO: compare ?
 */
static void
nine_state_copy_common(struct NineDevice9 *device,
                       struct nine_state *dst,
                       struct nine_state *src,
                       struct nine_state *mask, /* aliases either src or dst */
                       const boolean apply,
                       struct nine_range_pool *pool)
{
    unsigned i, s;

    if (apply)
       dst->changed.group |= mask->changed.group;

    if (mask->changed.group & NINE_STATE_VIEWPORT)
        dst->viewport = src->viewport;
    if (mask->changed.group & NINE_STATE_SCISSOR)
        dst->scissor = src->scissor;

    if (mask->changed.group & NINE_STATE_VS)
        nine_bind(&dst->vs, src->vs);
    if (mask->changed.group & NINE_STATE_PS)
        nine_bind(&dst->ps, src->ps);

    /* Vertex constants.
     *
     * Various possibilities for optimization here, like creating a per-SB
     * constant buffer, or memcmp'ing for changes.
     * Will do that later depending on what works best for specific apps.
     */
    if (mask->changed.group & NINE_STATE_VS_CONST) {
        struct nine_range *r;
        if (device->may_swvp) {
            for (r = mask->changed.vs_const_f; r; r = r->next) {
                int bgn = r->bgn;
                int end = r->end;
                memcpy(&dst->vs_const_f_swvp[bgn * 4],
                       &src->vs_const_f_swvp[bgn * 4],
                       (end - bgn) * 4 * sizeof(float));
                if (apply)
                    nine_ranges_insert(&dst->changed.vs_const_f, bgn, end,
                                       pool);
                if (bgn < device->max_vs_const_f) {
                    end = MIN2(end, device->max_vs_const_f);
                    memcpy(&dst->vs_const_f[bgn * 4],
                           &src->vs_const_f[bgn * 4],
                           (end - bgn) * 4 * sizeof(float));
                }
            }
        } else {
            for (r = mask->changed.vs_const_f; r; r = r->next) {
                memcpy(&dst->vs_const_f[r->bgn * 4],
                       &src->vs_const_f[r->bgn * 4],
                       (r->end - r->bgn) * 4 * sizeof(float));
                if (apply)
                    nine_ranges_insert(&dst->changed.vs_const_f, r->bgn, r->end,
                                       pool);
            }
        }
        for (r = mask->changed.vs_const_i; r; r = r->next) {
            memcpy(&dst->vs_const_i[r->bgn * 4],
                   &src->vs_const_i[r->bgn * 4],
                   (r->end - r->bgn) * 4 * sizeof(int));
            if (apply)
                nine_ranges_insert(&dst->changed.vs_const_i, r->bgn, r->end,
                                   pool);
        }
        for (r = mask->changed.vs_const_b; r; r = r->next) {
            memcpy(&dst->vs_const_b[r->bgn],
                   &src->vs_const_b[r->bgn],
                   (r->end - r->bgn) * sizeof(int));
            if (apply)
                nine_ranges_insert(&dst->changed.vs_const_b, r->bgn, r->end,
                                   pool);
        }
    }

    /* Pixel constants. */
    if (mask->changed.group & NINE_STATE_PS_CONST) {
        struct nine_range *r;
        for (r = mask->changed.ps_const_f; r; r = r->next) {
            memcpy(&dst->ps_const_f[r->bgn * 4],
                   &src->ps_const_f[r->bgn * 4],
                   (r->end - r->bgn) * 4 * sizeof(float));
            if (apply)
                nine_ranges_insert(&dst->changed.ps_const_f, r->bgn, r->end,
                                   pool);
        }
        if (mask->changed.ps_const_i) {
            uint16_t m = mask->changed.ps_const_i;
            for (i = ffs(m) - 1, m >>= i; m; ++i, m >>= 1)
                if (m & 1)
                    memcpy(dst->ps_const_i[i], src->ps_const_i[i], 4 * sizeof(int));
            if (apply)
                dst->changed.ps_const_i |= mask->changed.ps_const_i;
        }
        if (mask->changed.ps_const_b) {
            uint16_t m = mask->changed.ps_const_b;
            for (i = ffs(m) - 1, m >>= i; m; ++i, m >>= 1)
                if (m & 1)
                    dst->ps_const_b[i] = src->ps_const_b[i];
            if (apply)
                dst->changed.ps_const_b |= mask->changed.ps_const_b;
        }
    }

    /* Render states.
     * TODO: Maybe build a list ?
     */
    for (i = 0; i < ARRAY_SIZE(dst->changed.rs); ++i) {
        uint32_t m = mask->changed.rs[i];
        if (apply)
            dst->changed.rs[i] |= m;
        while (m) {
            const int r = ffs(m) - 1;
            m &= ~(1 << r);
            dst->rs[i * 32 + r] = src->rs[i * 32 + r];
            dst->rs_advertised[i * 32 + r] = src->rs_advertised[i * 32 + r];
        }
    }


    /* Clip planes. */
    if (mask->changed.ucp) {
        for (i = 0; i < PIPE_MAX_CLIP_PLANES; ++i)
            if (mask->changed.ucp & (1 << i))
                memcpy(dst->clip.ucp[i],
                       src->clip.ucp[i], sizeof(src->clip.ucp[0]));
        if (apply)
           dst->changed.ucp |= mask->changed.ucp;
    }

    /* Sampler state. */
    if (mask->changed.group & NINE_STATE_SAMPLER) {
        for (s = 0; s < NINE_MAX_SAMPLERS; ++s) {
            if (mask->changed.sampler[s] == 0x3ffe) {
                memcpy(&dst->samp[s], &src->samp[s], sizeof(dst->samp[s]));
            } else {
                uint32_t m = mask->changed.sampler[s];
                while (m) {
                    const int i = ffs(m) - 1;
                    m &= ~(1 << i);
                    dst->samp[s][i] = src->samp[s][i];
                }
            }
            if (apply)
                dst->changed.sampler[s] |= mask->changed.sampler[s];
        }
    }

    /* Index buffer. */
    if (mask->changed.group & NINE_STATE_IDXBUF)
        nine_bind(&dst->idxbuf, src->idxbuf);

    /* Vertex streams. */
    if (mask->changed.vtxbuf | mask->changed.stream_freq) {
        uint32_t m = mask->changed.vtxbuf | mask->changed.stream_freq;
        for (i = 0; m; ++i, m >>= 1) {
            if (mask->changed.vtxbuf & (1 << i)) {
                nine_bind(&dst->stream[i], src->stream[i]);
                if (src->stream[i]) {
                    dst->vtxbuf[i].buffer_offset = src->vtxbuf[i].buffer_offset;
                    pipe_resource_reference(&dst->vtxbuf[i].buffer, src->vtxbuf[i].buffer);
                    dst->vtxbuf[i].stride = src->vtxbuf[i].stride;
                }
            }
            if (mask->changed.stream_freq & (1 << i))
                dst->stream_freq[i] = src->stream_freq[i];
        }
        dst->stream_instancedata_mask &= ~mask->changed.stream_freq;
        dst->stream_instancedata_mask |=
            src->stream_instancedata_mask & mask->changed.stream_freq;
        if (apply) {
            dst->changed.vtxbuf |= mask->changed.vtxbuf;
            dst->changed.stream_freq |= mask->changed.stream_freq;
        }
    }

    if (!(mask->changed.group & NINE_STATE_FF))
        return;
    WARN_ONCE("Fixed function state not handled properly by StateBlocks.\n");

    /* Fixed function state. */
    if (apply)
        dst->ff.changed.group |= src->ff.changed.group;

    if (mask->changed.group & NINE_STATE_FF_MATERIAL)
        dst->ff.material = src->ff.material;

    if (mask->changed.group & NINE_STATE_FF_PSSTAGES) {
        for (s = 0; s < NINE_MAX_TEXTURE_STAGES; ++s) {
            for (i = 0; i < NINED3DTSS_COUNT; ++i)
                if (mask->ff.changed.tex_stage[s][i / 32] & (1 << (i % 32)))
                    dst->ff.tex_stage[s][i] = src->ff.tex_stage[s][i];
            if (apply) {
                /* TODO: it's 32 exactly, just offset by 1 as 0 is unused */
                dst->ff.changed.tex_stage[s][0] |=
                    mask->ff.changed.tex_stage[s][0];
                dst->ff.changed.tex_stage[s][1] |=
                    mask->ff.changed.tex_stage[s][1];
            }
        }
    }
    if (mask->changed.group & NINE_STATE_FF_LIGHTING) {
        unsigned num_lights = MAX2(dst->ff.num_lights, src->ff.num_lights);
        /* Can happen in Capture() if device state has created new lights after
         * the stateblock was created.
         * Can happen in Apply() if the stateblock had recorded the creation of
         * new lights. */
        if (dst->ff.num_lights < num_lights) {
            dst->ff.light = REALLOC(dst->ff.light,
                                    dst->ff.num_lights * sizeof(D3DLIGHT9),
                                    num_lights * sizeof(D3DLIGHT9));
            memset(&dst->ff.light[dst->ff.num_lights], 0, (num_lights - dst->ff.num_lights) * sizeof(D3DLIGHT9));
            /* if mask == dst, a Type of 0 will trigger
             * "dst->ff.light[i] = src->ff.light[i];" later,
             * which is what we want in that case. */
            if (mask != dst) {
                for (i = src->ff.num_lights; i < num_lights; ++i)
                    src->ff.light[i].Type = (D3DLIGHTTYPE)NINED3DLIGHT_INVALID;
            }
            dst->ff.num_lights = num_lights;
        }
        /* Can happen in Capture() if the stateblock had recorded the creation of
         * new lights.
         * Can happen in Apply() if device state has created new lights after
         * the stateblock was created. */
        if (src->ff.num_lights < num_lights) {
            src->ff.light = REALLOC(src->ff.light,
                                    src->ff.num_lights * sizeof(D3DLIGHT9),
                                    num_lights * sizeof(D3DLIGHT9));
            memset(&src->ff.light[src->ff.num_lights], 0, (num_lights - src->ff.num_lights) * sizeof(D3DLIGHT9));
            for (i = src->ff.num_lights; i < num_lights; ++i)
                src->ff.light[i].Type = (D3DLIGHTTYPE)NINED3DLIGHT_INVALID;
            src->ff.num_lights = num_lights;
        }
        /* Note: mask is either src or dst, so at this point src, dst and mask
         * have num_lights lights. */
        for (i = 0; i < num_lights; ++i)
            if (mask->ff.light[i].Type != NINED3DLIGHT_INVALID)
                dst->ff.light[i] = src->ff.light[i];

        memcpy(dst->ff.active_light, src->ff.active_light, sizeof(src->ff.active_light) );
        dst->ff.num_lights_active = src->ff.num_lights_active;
    }
    if (mask->changed.group & NINE_STATE_FF_VSTRANSF) {
        for (i = 0; i < ARRAY_SIZE(mask->ff.changed.transform); ++i) {
            if (!mask->ff.changed.transform[i])
                continue;
            for (s = i * 32; s < (i * 32 + 32); ++s) {
                if (!(mask->ff.changed.transform[i] & (1 << (s % 32))))
                    continue;
                *nine_state_access_transform(dst, s, TRUE) =
                    *nine_state_access_transform( /* const because !alloc */
                        (struct nine_state *)src, s, FALSE);
            }
            if (apply)
                dst->ff.changed.transform[i] |= mask->ff.changed.transform[i];
        }
    }
}

static void
nine_state_copy_common_all(struct NineDevice9 *device,
                           struct nine_state *dst,
                           const struct nine_state *src,
                           struct nine_state *help,
                           const boolean apply,
                           struct nine_range_pool *pool,
                           const int MaxStreams)
{
    unsigned i;

    if (apply)
       dst->changed.group |= src->changed.group;

    dst->viewport = src->viewport;
    dst->scissor = src->scissor;

    nine_bind(&dst->vs, src->vs);
    nine_bind(&dst->ps, src->ps);

    /* Vertex constants.
     *
     * Various possibilities for optimization here, like creating a per-SB
     * constant buffer, or memcmp'ing for changes.
     * Will do that later depending on what works best for specific apps.
     */
    if (1) {
        struct nine_range *r = help->changed.vs_const_f;
        memcpy(&dst->vs_const_f[0],
               &src->vs_const_f[0], device->max_vs_const_f * 4 * sizeof(float));
        if (device->may_swvp)
            memcpy(dst->vs_const_f_swvp,
                   src->vs_const_f_swvp, VS_CONST_F_SWVP_SIZE);
        if (apply)
            nine_ranges_insert(&dst->changed.vs_const_f, r->bgn, r->end, pool);

        memcpy(dst->vs_const_i, src->vs_const_i, VS_CONST_I_SIZE(device));
        memcpy(dst->vs_const_b, src->vs_const_b, VS_CONST_B_SIZE(device));
        if (apply) {
            r = help->changed.vs_const_i;
            nine_ranges_insert(&dst->changed.vs_const_i, r->bgn, r->end, pool);
            r = help->changed.vs_const_b;
            nine_ranges_insert(&dst->changed.vs_const_b, r->bgn, r->end, pool);
        }
    }

    /* Pixel constants. */
    if (1) {
        struct nine_range *r = help->changed.ps_const_f;
        memcpy(&dst->ps_const_f[0],
               &src->ps_const_f[0], (r->end - r->bgn) * 4 * sizeof(float));
        if (apply)
            nine_ranges_insert(&dst->changed.ps_const_f, r->bgn, r->end, pool);

        memcpy(dst->ps_const_i, src->ps_const_i, sizeof(dst->ps_const_i));
        memcpy(dst->ps_const_b, src->ps_const_b, sizeof(dst->ps_const_b));
        if (apply) {
            dst->changed.ps_const_i |= src->changed.ps_const_i;
            dst->changed.ps_const_b |= src->changed.ps_const_b;
        }
    }

    /* Render states. */
    memcpy(dst->rs, src->rs, sizeof(dst->rs));
    memcpy(dst->rs_advertised, src->rs_advertised, sizeof(dst->rs_advertised));
    if (apply)
        memcpy(dst->changed.rs, src->changed.rs, sizeof(dst->changed.rs));


    /* Clip planes. */
    memcpy(&dst->clip, &src->clip, sizeof(dst->clip));
    if (apply)
        dst->changed.ucp = src->changed.ucp;

    /* Sampler state. */
    memcpy(dst->samp, src->samp, sizeof(dst->samp));
    if (apply)
        memcpy(dst->changed.sampler,
               src->changed.sampler, sizeof(dst->changed.sampler));

    /* Index buffer. */
    nine_bind(&dst->idxbuf, src->idxbuf);

    /* Vertex streams. */
    if (1) {
        for (i = 0; i < ARRAY_SIZE(dst->stream); ++i) {
            nine_bind(&dst->stream[i], src->stream[i]);
            if (src->stream[i]) {
                dst->vtxbuf[i].buffer_offset = src->vtxbuf[i].buffer_offset;
                pipe_resource_reference(&dst->vtxbuf[i].buffer, src->vtxbuf[i].buffer);
                dst->vtxbuf[i].stride = src->vtxbuf[i].stride;
            }
            dst->stream_freq[i] = src->stream_freq[i];
        }
        dst->stream_instancedata_mask = src->stream_instancedata_mask;
        if (apply) {
            dst->changed.vtxbuf = (1ULL << MaxStreams) - 1;
            dst->changed.stream_freq = (1ULL << MaxStreams) - 1;
        }
    }

    /* keep this check in case we want to disable FF */
    if (!(help->changed.group & NINE_STATE_FF))
        return;
    WARN_ONCE("Fixed function state not handled properly by StateBlocks.\n");

    /* Fixed function state. */
    if (apply)
        dst->ff.changed.group = src->ff.changed.group;

    dst->ff.material = src->ff.material;

    memcpy(dst->ff.tex_stage, src->ff.tex_stage, sizeof(dst->ff.tex_stage));
    if (apply) /* TODO: memset */
        memcpy(dst->ff.changed.tex_stage,
               src->ff.changed.tex_stage, sizeof(dst->ff.changed.tex_stage));

    /* Lights. */
    if (1) {
        if (dst->ff.num_lights < src->ff.num_lights) {
            dst->ff.light = REALLOC(dst->ff.light,
                                    dst->ff.num_lights * sizeof(D3DLIGHT9),
                                    src->ff.num_lights * sizeof(D3DLIGHT9));
            dst->ff.num_lights = src->ff.num_lights;
        }
        memcpy(dst->ff.light,
               src->ff.light, src->ff.num_lights * sizeof(dst->ff.light[0]));

        memcpy(dst->ff.active_light, src->ff.active_light, sizeof(src->ff.active_light) );
        dst->ff.num_lights_active = src->ff.num_lights_active;
    }

    /* Transforms. */
    if (1) {
        if (dst->ff.num_transforms < src->ff.num_transforms) {
            dst->ff.transform = REALLOC(dst->ff.transform,
                dst->ff.num_transforms * sizeof(dst->ff.transform[0]),
                src->ff.num_transforms * sizeof(src->ff.transform[0]));
            dst->ff.num_transforms = src->ff.num_transforms;
        }
        memcpy(dst->ff.transform,
               src->ff.transform, src->ff.num_transforms * sizeof(D3DMATRIX));
        if (apply) /* TODO: memset */
            memcpy(dst->ff.changed.transform,
                   src->ff.changed.transform, sizeof(dst->ff.changed.transform));
    }
}

/* Capture those bits of current device state that have been changed between
 * BeginStateBlock and EndStateBlock.
 */
HRESULT NINE_WINAPI
NineStateBlock9_Capture( struct NineStateBlock9 *This )
{
    struct NineDevice9 *device = This->base.device;
    struct nine_state *dst = &This->state;
    struct nine_state *src = &device->state;
    const int MaxStreams = device->caps.MaxStreams;
    unsigned s;

    DBG("This=%p\n", This);

    if (This->type == NINESBT_ALL)
        nine_state_copy_common_all(device, dst, src, dst, FALSE, NULL, MaxStreams);
    else
        nine_state_copy_common(device, dst, src, dst, FALSE, NULL);

    if (dst->changed.group & NINE_STATE_VDECL)
        nine_bind(&dst->vdecl, src->vdecl);

    /* Textures */
    if (dst->changed.texture) {
        uint32_t m = dst->changed.texture;
        for (s = 0; m; ++s, m >>= 1)
            if (m & 1)
                nine_bind(&dst->texture[s], src->texture[s]);
    }

    return D3D_OK;
}

/* Set state managed by this StateBlock as current device state. */
HRESULT NINE_WINAPI
NineStateBlock9_Apply( struct NineStateBlock9 *This )
{
    struct NineDevice9 *device = This->base.device;
    struct nine_state *dst = &device->state;
    struct nine_state *src = &This->state;
    struct nine_range_pool *pool = &device->range_pool;
    const int MaxStreams = device->caps.MaxStreams;
    unsigned s;

    DBG("This=%p\n", This);

    if (This->type == NINESBT_ALL)
        nine_state_copy_common_all(device, dst, src, src, TRUE, pool, MaxStreams);
    else
        nine_state_copy_common(device, dst, src, src, TRUE, pool);

    if ((src->changed.group & NINE_STATE_VDECL) && src->vdecl)
        NineDevice9_SetVertexDeclaration(This->base.device, (IDirect3DVertexDeclaration9 *)src->vdecl);

    /* Recomputing it is needed if we changed vs but not vdecl */
    dst->programmable_vs = dst->vs && !(dst->vdecl && dst->vdecl->position_t);

    /* Textures */
    if (src->changed.texture) {
        uint32_t m = src->changed.texture;
        dst->changed.texture |= m;

        dst->samplers_shadow &= ~m;

        for (s = 0; m; ++s, m >>= 1) {
            struct NineBaseTexture9 *tex = src->texture[s];
            if (!(m & 1))
                continue;
            if (tex) {
                tex->bind_count++;
                if ((tex->managed.dirty | tex->dirty_mip) && LIST_IS_EMPTY(&tex->list))
                    list_add(&tex->list, &This->base.device->update_textures);
                dst->samplers_shadow |= tex->shadow << s;
            }
            if (src->texture[s])
                src->texture[s]->bind_count--;
            nine_bind(&dst->texture[s], src->texture[s]);
        }
    }

    return D3D_OK;
}

IDirect3DStateBlock9Vtbl NineStateBlock9_vtable = {
    (void *)NineUnknown_QueryInterface,
    (void *)NineUnknown_AddRef,
    (void *)NineUnknown_Release,
    (void *)NineUnknown_GetDevice, /* actually part of StateBlock9 iface */
    (void *)NineStateBlock9_Capture,
    (void *)NineStateBlock9_Apply
};

static const GUID *NineStateBlock9_IIDs[] = {
    &IID_IDirect3DStateBlock9,
    &IID_IUnknown,
    NULL
};

HRESULT
NineStateBlock9_new( struct NineDevice9 *pDevice,
                     struct NineStateBlock9 **ppOut,
                     enum nine_stateblock_type type)
{
    NINE_DEVICE_CHILD_NEW(StateBlock9, ppOut, pDevice, type);
}
@


1.1
log
@Initial revision
@
text
@d27 1
d33 4
d53 4
a56 1
    if (!This->state.vs_const_f || !This->state.ps_const_f)
d59 7
d80 3
d96 8
d113 3
a115 2
nine_state_copy_common(struct nine_state *dst,
                       const struct nine_state *src,
d143 31
a173 4
        for (r = mask->changed.vs_const_f; r; r = r->next) {
            memcpy(&dst->vs_const_f[r->bgn * 4],
                   &src->vs_const_f[r->bgn * 4],
                   (r->end - r->bgn) * 4 * sizeof(float));
d175 1
a175 1
                nine_ranges_insert(&dst->changed.vs_const_f, r->bgn, r->end,
d178 4
a181 5
        if (mask->changed.vs_const_i) {
            uint16_t m = mask->changed.vs_const_i;
            for (i = ffs(m) - 1, m >>= i; m; ++i, m >>= 1)
                if (m & 1)
                    memcpy(dst->vs_const_i[i], src->vs_const_i[i], 4 * sizeof(int));
d183 2
a184 9
                dst->changed.vs_const_i |= mask->changed.vs_const_i;
        }
        if (mask->changed.vs_const_b) {
            uint16_t m = mask->changed.vs_const_b;
            for (i = ffs(m) - 1, m >>= i; m; ++i, m >>= 1)
                if (m & 1)
                    dst->vs_const_b[i] = src->vs_const_b[i];
            if (apply)
                dst->changed.vs_const_b |= mask->changed.vs_const_b;
d220 1
a220 1
    for (i = 0; i < Elements(dst->changed.rs); ++i) {
d228 1
d273 1
a273 1
                    dst->vtxbuf[i].buffer = src->vtxbuf[i].buffer;
d315 6
a320 1
        if (dst->ff.num_lights < mask->ff.num_lights) {
d323 10
a332 2
                                    mask->ff.num_lights * sizeof(D3DLIGHT9));
            dst->ff.num_lights = mask->ff.num_lights;
d334 16
a349 1
        for (i = 0; i < mask->ff.num_lights; ++i)
d357 1
a357 1
        for (i = 0; i < Elements(mask->ff.changed.transform); ++i) {
d374 2
a375 1
nine_state_copy_common_all(struct nine_state *dst,
d402 4
a405 1
               &src->vs_const_f[0], (r->end - r->bgn) * 4 * sizeof(float));
d409 2
a410 2
        memcpy(dst->vs_const_i, src->vs_const_i, sizeof(dst->vs_const_i));
        memcpy(dst->vs_const_b, src->vs_const_b, sizeof(dst->vs_const_b));
d412 4
a415 2
            dst->changed.vs_const_i |= src->changed.vs_const_i;
            dst->changed.vs_const_b |= src->changed.vs_const_b;
d437 1
d458 1
a458 1
        for (i = 0; i < Elements(dst->stream); ++i) {
d462 1
a462 1
                dst->vtxbuf[i].buffer = src->vtxbuf[i].buffer;
d524 1
a524 1
HRESULT WINAPI
d527 1
d529 2
a530 2
    struct nine_state *src = &This->base.device->state;
    const int MaxStreams = This->base.device->caps.MaxStreams;
d536 1
a536 1
        nine_state_copy_common_all(dst, src, dst, FALSE, NULL, MaxStreams);
d538 1
a538 1
        nine_state_copy_common(dst, src, dst, FALSE, NULL);
d555 1
a555 1
HRESULT WINAPI
d558 2
a559 1
    struct nine_state *dst = &This->base.device->state;
d561 2
a562 2
    struct nine_range_pool *pool = &This->base.device->range_pool;
    const int MaxStreams = This->base.device->caps.MaxStreams;
d568 1
a568 1
        nine_state_copy_common_all(dst, src, src, TRUE, pool, MaxStreams);
d570 1
a570 1
        nine_state_copy_common(dst, src, src, TRUE, pool);
d573 4
a576 1
        nine_bind(&dst->vdecl, src->vdecl);
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@a26 1
#include "vertexdeclaration9.h"
d88 1
a88 1
                       struct nine_state *src,
a181 1
            dst->rs_advertised[i * 32 + r] = src->rs_advertised[i * 32 + r];
d226 1
a226 1
                    pipe_resource_reference(&dst->vtxbuf[i].buffer, src->vtxbuf[i].buffer);
d268 1
a268 6
        unsigned num_lights = MAX2(dst->ff.num_lights, src->ff.num_lights);
        /* Can happen in Capture() if device state has created new lights after
         * the stateblock was created.
         * Can happen in Apply() if the stateblock had recorded the creation of
         * new lights. */
        if (dst->ff.num_lights < num_lights) {
d271 2
a272 10
                                    num_lights * sizeof(D3DLIGHT9));
            memset(&dst->ff.light[dst->ff.num_lights], 0, (num_lights - dst->ff.num_lights) * sizeof(D3DLIGHT9));
            /* if mask == dst, a Type of 0 will trigger
             * "dst->ff.light[i] = src->ff.light[i];" later,
             * which is what we want in that case. */
            if (mask != dst) {
                for (i = src->ff.num_lights; i < num_lights; ++i)
                    src->ff.light[i].Type = (D3DLIGHTTYPE)NINED3DLIGHT_INVALID;
            }
            dst->ff.num_lights = num_lights;
d274 1
a274 16
        /* Can happen in Capture() if the stateblock had recorded the creation of
         * new lights.
         * Can happen in Apply() if device state has created new lights after
         * the stateblock was created. */
        if (src->ff.num_lights < num_lights) {
            src->ff.light = REALLOC(src->ff.light,
                                    src->ff.num_lights * sizeof(D3DLIGHT9),
                                    num_lights * sizeof(D3DLIGHT9));
            memset(&src->ff.light[src->ff.num_lights], 0, (num_lights - src->ff.num_lights) * sizeof(D3DLIGHT9));
            for (i = src->ff.num_lights; i < num_lights; ++i)
                src->ff.light[i].Type = (D3DLIGHTTYPE)NINED3DLIGHT_INVALID;
            src->ff.num_lights = num_lights;
        }
        /* Note: mask is either src or dst, so at this point src, dst and mask
         * have num_lights lights. */
        for (i = 0; i < num_lights; ++i)
a355 1
    memcpy(dst->rs_advertised, src->rs_advertised, sizeof(dst->rs_advertised));
d380 1
a380 1
                pipe_resource_reference(&dst->vtxbuf[i].buffer, src->vtxbuf[i].buffer);
d442 1
a442 1
HRESULT NINE_WINAPI
d472 1
a472 1
HRESULT NINE_WINAPI
d489 1
a489 4
        NineDevice9_SetVertexDeclaration(This->base.device, (IDirect3DVertexDeclaration9 *)src->vdecl);

    /* Recomputing it is needed if we changed vs but not vdecl */
    dst->programmable_vs = dst->vs && !(dst->vdecl && dst->vdecl->position_t);
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@a32 4
#define VS_CONST_I_SIZE(device) (device->may_swvp ? (NINE_MAX_CONST_I_SWVP * sizeof(int[4])) : (NINE_MAX_CONST_I * sizeof(int[4])))
#define VS_CONST_B_SIZE(device) (device->may_swvp ? (NINE_MAX_CONST_B_SWVP * sizeof(BOOL)) : (NINE_MAX_CONST_B * sizeof(BOOL)))
#define VS_CONST_F_SWVP_SIZE    (NINE_MAX_CONST_F_SWVP * sizeof(float[4]))

d49 1
a49 4
    This->state.vs_const_i = MALLOC(VS_CONST_I_SIZE(This->base.device));
    This->state.vs_const_b = MALLOC(VS_CONST_B_SIZE(This->base.device));
    if (!This->state.vs_const_f || !This->state.ps_const_f ||
        !This->state.vs_const_i || !This->state.vs_const_b)
a51 7
    if (This->base.device->may_swvp) {
        This->state.vs_const_f_swvp = MALLOC(VS_CONST_F_SWVP_SIZE);
        if (!This->state.vs_const_f_swvp)
            return E_OUTOFMEMORY;
    } else
        This->state.vs_const_f_swvp = NULL;

a65 3
    FREE(state->vs_const_i);
    FREE(state->vs_const_b);
    FREE(state->vs_const_f_swvp);
a78 8
    if (This->state.changed.vs_const_i) {
        for (r = This->state.changed.vs_const_i; r->next; r = r->next);
        nine_range_pool_put_chain(pool, This->state.changed.vs_const_i, r);
    }
    if (This->state.changed.vs_const_b) {
        for (r = This->state.changed.vs_const_b; r->next; r = r->next);
        nine_range_pool_put_chain(pool, This->state.changed.vs_const_b, r);
    }
d88 1
a88 2
nine_state_copy_common(struct NineDevice9 *device,
                       struct nine_state *dst,
d117 7
a123 26
        if (device->may_swvp) {
            for (r = mask->changed.vs_const_f; r; r = r->next) {
                int bgn = r->bgn;
                int end = r->end;
                memcpy(&dst->vs_const_f_swvp[bgn * 4],
                       &src->vs_const_f_swvp[bgn * 4],
                       (end - bgn) * 4 * sizeof(float));
                if (apply)
                    nine_ranges_insert(&dst->changed.vs_const_f, bgn, end,
                                       pool);
                if (bgn < device->max_vs_const_f) {
                    end = MIN2(end, device->max_vs_const_f);
                    memcpy(&dst->vs_const_f[bgn * 4],
                           &src->vs_const_f[bgn * 4],
                           (end - bgn) * 4 * sizeof(float));
                }
            }
        } else {
            for (r = mask->changed.vs_const_f; r; r = r->next) {
                memcpy(&dst->vs_const_f[r->bgn * 4],
                       &src->vs_const_f[r->bgn * 4],
                       (r->end - r->bgn) * 4 * sizeof(float));
                if (apply)
                    nine_ranges_insert(&dst->changed.vs_const_f, r->bgn, r->end,
                                       pool);
            }
d125 5
a129 4
        for (r = mask->changed.vs_const_i; r; r = r->next) {
            memcpy(&dst->vs_const_i[r->bgn * 4],
                   &src->vs_const_i[r->bgn * 4],
                   (r->end - r->bgn) * 4 * sizeof(int));
d131 1
a131 2
                nine_ranges_insert(&dst->changed.vs_const_i, r->bgn, r->end,
                                   pool);
d133 5
a137 4
        for (r = mask->changed.vs_const_b; r; r = r->next) {
            memcpy(&dst->vs_const_b[r->bgn],
                   &src->vs_const_b[r->bgn],
                   (r->end - r->bgn) * sizeof(int));
d139 1
a139 2
                nine_ranges_insert(&dst->changed.vs_const_b, r->bgn, r->end,
                                   pool);
d175 1
a175 1
    for (i = 0; i < ARRAY_SIZE(dst->changed.rs); ++i) {
d312 1
a312 1
        for (i = 0; i < ARRAY_SIZE(mask->ff.changed.transform); ++i) {
d329 1
a329 2
nine_state_copy_common_all(struct NineDevice9 *device,
                           struct nine_state *dst,
d356 1
a356 4
               &src->vs_const_f[0], device->max_vs_const_f * 4 * sizeof(float));
        if (device->may_swvp)
            memcpy(dst->vs_const_f_swvp,
                   src->vs_const_f_swvp, VS_CONST_F_SWVP_SIZE);
d360 2
a361 2
        memcpy(dst->vs_const_i, src->vs_const_i, VS_CONST_I_SIZE(device));
        memcpy(dst->vs_const_b, src->vs_const_b, VS_CONST_B_SIZE(device));
d363 2
a364 4
            r = help->changed.vs_const_i;
            nine_ranges_insert(&dst->changed.vs_const_i, r->bgn, r->end, pool);
            r = help->changed.vs_const_b;
            nine_ranges_insert(&dst->changed.vs_const_b, r->bgn, r->end, pool);
d407 1
a407 1
        for (i = 0; i < ARRAY_SIZE(dst->stream); ++i) {
a475 1
    struct NineDevice9 *device = This->base.device;
d477 2
a478 2
    struct nine_state *src = &device->state;
    const int MaxStreams = device->caps.MaxStreams;
d484 1
a484 1
        nine_state_copy_common_all(device, dst, src, dst, FALSE, NULL, MaxStreams);
d486 1
a486 1
        nine_state_copy_common(device, dst, src, dst, FALSE, NULL);
d506 1
a506 2
    struct NineDevice9 *device = This->base.device;
    struct nine_state *dst = &device->state;
d508 2
a509 2
    struct nine_range_pool *pool = &device->range_pool;
    const int MaxStreams = device->caps.MaxStreams;
d515 1
a515 1
        nine_state_copy_common_all(device, dst, src, src, TRUE, pool, MaxStreams);
d517 1
a517 1
        nine_state_copy_common(device, dst, src, src, TRUE, pool);
@


1.1.1.4
log
@Import Mesa 17.1.6
@
text
@a27 2
#include "vertexbuffer9.h"
#include "indexbuffer9.h"
d33 4
d51 1
a51 1
    This->state.vs_const_f = MALLOC(VS_CONST_F_SIZE(This->base.device));
d59 7
d76 1
a76 1
    nine_state_clear(state, false);
d82 1
a107 24
static void
NineStateBlock9_BindBuffer( struct NineDevice9 *device,
                            boolean applyToDevice,
                            struct NineBuffer9 **slot,
                            struct NineBuffer9 *buf )
{
    if (applyToDevice)
        NineBindBufferToDevice(device, slot, buf);
    else
        nine_bind(slot, buf);
}

static void
NineStateBlock9_BindTexture( struct NineDevice9 *device,
                             boolean applyToDevice,
                             struct NineBaseTexture9 **slot,
                             struct NineBaseTexture9 *tex )
{
    if (applyToDevice)
        NineBindTextureToDevice(device, slot, tex);
    else
        nine_bind(slot, tex);
}

a121 1
    DBG("apply:%d changed.group: %x\n", (int)apply, (int)mask->changed.group );
a139 5
     *
     * Note: Currently when we apply stateblocks, it's always on the device state.
     * Should it affect recording stateblocks ? Since it's on device state, there
     * is no need to copy which ranges are dirty. If it turns out we should affect
     * recording stateblocks, the info should be copied.
d143 26
a168 4
        for (r = mask->changed.vs_const_f; r; r = r->next) {
            memcpy(&dst->vs_const_f[r->bgn * 4],
                   &src->vs_const_f[r->bgn * 4],
                   (r->end - r->bgn) * 4 * sizeof(float));
d174 3
d182 3
d195 3
d204 2
d212 2
d227 1
a227 1
            DBG("State %d %s = %d\n", i * 32 + r, nine_d3drs_to_string(i * 32 + r), (int)src->rs_advertised[i * 32 + r]);
a234 1
        DBG("ucp: %x\n", mask->changed.ucp);
d247 1
a247 1
                memcpy(&dst->samp_advertised[s], &src->samp_advertised[s], sizeof(dst->samp_advertised[s]));
a249 1
                DBG("samp %d: changed = %x\n", i, (int)m);
d253 1
a253 1
                    dst->samp_advertised[s][i] = src->samp_advertised[s][i];
d263 1
a263 4
        NineStateBlock9_BindBuffer(device,
                                   apply,
                                   (struct NineBuffer9 **)&dst->idxbuf,
                                   (struct NineBuffer9 *)src->idxbuf);
a266 1
        DBG("vtxbuf/stream_freq: %x/%x\n", mask->changed.vtxbuf, mask->changed.stream_freq);
d270 1
a270 4
                NineStateBlock9_BindBuffer(device,
                                           apply,
                                           (struct NineBuffer9 **)&dst->stream[i],
                                           (struct NineBuffer9 *)src->stream[i]);
d273 1
d280 3
a288 8
    /* Textures */
    if (mask->changed.texture) {
        uint32_t m = mask->changed.texture;
        for (s = 0; m; ++s, m >>= 1)
            if (m & 1)
                NineStateBlock9_BindTexture(device, apply, &dst->texture[s], src->texture[s]);
    }

d294 2
d329 2
a330 2
                for (i = dst->ff.num_lights; i < num_lights; ++i)
                    dst->ff.light[i].Type = (D3DLIGHTTYPE)NINED3DLIGHT_INVALID;
d363 1
a363 1
                *nine_state_access_transform(&dst->ff, s, TRUE) =
d365 1
a365 1
                        (struct nine_ff_state *)&src->ff, s, FALSE);
d400 1
d402 6
a407 1
               &src->vs_const_f[0], VS_CONST_F_SIZE(device));
d411 6
d424 2
d429 4
d436 1
d448 1
a448 1
    memcpy(dst->samp_advertised, src->samp_advertised, sizeof(dst->samp_advertised));
d454 1
a454 4
    NineStateBlock9_BindBuffer(device,
                               apply,
                               (struct NineBuffer9 **)&dst->idxbuf,
                               (struct NineBuffer9 *)src->idxbuf);
d459 1
a459 4
            NineStateBlock9_BindBuffer(device,
                                       apply,
                                       (struct NineBuffer9 **)&dst->stream[i],
                                       (struct NineBuffer9 *)src->stream[i]);
d462 1
d467 1
a473 6
    /* Textures */
    if (1) {
        for (i = 0; i < device->caps.MaxSimultaneousTextures; i++)
            NineStateBlock9_BindTexture(device, apply, &dst->texture[i], src->texture[i]);
    }

d480 3
d531 1
d543 8
d563 1
d572 5
a576 1
    nine_context_apply_stateblock(device, src);
d578 22
a599 2
    if ((src->changed.group & NINE_STATE_VDECL) && src->vdecl)
        nine_bind(&dst->vdecl, src->vdecl);
@


