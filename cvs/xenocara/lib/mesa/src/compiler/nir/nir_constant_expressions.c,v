head	1.1;
branch	1.1.1;
access;
symbols
	mesa-13_0_6:1.1.1.2
	mesa-13_0_5:1.1.1.2
	mesa-13_0_3:1.1.1.2
	mesa-13_0_2:1.1.1.2
	OPENBSD_6_0:1.1.1.1.0.4
	OPENBSD_6_0_BASE:1.1.1.1
	mesa-11_2_2:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2016.05.29.10.16.33;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.1
date	2016.05.29.10.16.33;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.2
date	2016.12.11.08.33.49;	author jsg;	state Exp;
branches;
next	;
commitid	uuv5VTS15jglEDZU;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (C) 2014 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Jason Ekstrand (jason@@jlekstrand.net)
 */

#include <math.h>
#include "main/core.h"
#include "util/rounding.h" /* for _mesa_roundeven */
#include "util/half_float.h"
#include "nir_constant_expressions.h"

/**
 * Evaluate one component of packSnorm4x8.
 */
static uint8_t
pack_snorm_1x8(float x)
{
    /* From section 8.4 of the GLSL 4.30 spec:
     *
     *    packSnorm4x8
     *    ------------
     *    The conversion for component c of v to fixed point is done as
     *    follows:
     *
     *      packSnorm4x8: round(clamp(c, -1, +1) * 127.0)
     *
     * We must first cast the float to an int, because casting a negative
     * float to a uint is undefined.
     */
   return (uint8_t) (int)
          _mesa_roundevenf(CLAMP(x, -1.0f, +1.0f) * 127.0f);
}

/**
 * Evaluate one component of packSnorm2x16.
 */
static uint16_t
pack_snorm_1x16(float x)
{
    /* From section 8.4 of the GLSL ES 3.00 spec:
     *
     *    packSnorm2x16
     *    -------------
     *    The conversion for component c of v to fixed point is done as
     *    follows:
     *
     *      packSnorm2x16: round(clamp(c, -1, +1) * 32767.0)
     *
     * We must first cast the float to an int, because casting a negative
     * float to a uint is undefined.
     */
   return (uint16_t) (int)
          _mesa_roundevenf(CLAMP(x, -1.0f, +1.0f) * 32767.0f);
}

/**
 * Evaluate one component of unpackSnorm4x8.
 */
static float
unpack_snorm_1x8(uint8_t u)
{
    /* From section 8.4 of the GLSL 4.30 spec:
     *
     *    unpackSnorm4x8
     *    --------------
     *    The conversion for unpacked fixed-point value f to floating point is
     *    done as follows:
     *
     *       unpackSnorm4x8: clamp(f / 127.0, -1, +1)
     */
   return CLAMP((int8_t) u / 127.0f, -1.0f, +1.0f);
}

/**
 * Evaluate one component of unpackSnorm2x16.
 */
static float
unpack_snorm_1x16(uint16_t u)
{
    /* From section 8.4 of the GLSL ES 3.00 spec:
     *
     *    unpackSnorm2x16
     *    ---------------
     *    The conversion for unpacked fixed-point value f to floating point is
     *    done as follows:
     *
     *       unpackSnorm2x16: clamp(f / 32767.0, -1, +1)
     */
   return CLAMP((int16_t) u / 32767.0f, -1.0f, +1.0f);
}

/**
 * Evaluate one component packUnorm4x8.
 */
static uint8_t
pack_unorm_1x8(float x)
{
    /* From section 8.4 of the GLSL 4.30 spec:
     *
     *    packUnorm4x8
     *    ------------
     *    The conversion for component c of v to fixed point is done as
     *    follows:
     *
     *       packUnorm4x8: round(clamp(c, 0, +1) * 255.0)
     */
   return (uint8_t) (int)
          _mesa_roundevenf(CLAMP(x, 0.0f, 1.0f) * 255.0f);
}

/**
 * Evaluate one component packUnorm2x16.
 */
static uint16_t
pack_unorm_1x16(float x)
{
    /* From section 8.4 of the GLSL ES 3.00 spec:
     *
     *    packUnorm2x16
     *    -------------
     *    The conversion for component c of v to fixed point is done as
     *    follows:
     *
     *       packUnorm2x16: round(clamp(c, 0, +1) * 65535.0)
     */
   return (uint16_t) (int)
          _mesa_roundevenf(CLAMP(x, 0.0f, 1.0f) * 65535.0f);
}

/**
 * Evaluate one component of unpackUnorm4x8.
 */
static float
unpack_unorm_1x8(uint8_t u)
{
    /* From section 8.4 of the GLSL 4.30 spec:
     *
     *    unpackUnorm4x8
     *    --------------
     *    The conversion for unpacked fixed-point value f to floating point is
     *    done as follows:
     *
     *       unpackUnorm4x8: f / 255.0
     */
   return (float) u / 255.0f;
}

/**
 * Evaluate one component of unpackUnorm2x16.
 */
static float
unpack_unorm_1x16(uint16_t u)
{
    /* From section 8.4 of the GLSL ES 3.00 spec:
     *
     *    unpackUnorm2x16
     *    ---------------
     *    The conversion for unpacked fixed-point value f to floating point is
     *    done as follows:
     *
     *       unpackUnorm2x16: f / 65535.0
     */
   return (float) u / 65535.0f;
}

/**
 * Evaluate one component of packHalf2x16.
 */
static uint16_t
pack_half_1x16(float x)
{
   return _mesa_float_to_half(x);
}

/**
 * Evaluate one component of unpackHalf2x16.
 */
static float
unpack_half_1x16(uint16_t u)
{
   return _mesa_half_to_float(u);
}

/* Some typed vector structures to make things like src0.y work */
struct float_vec {
   float x;
   float y;
   float z;
   float w;
};
struct int_vec {
   int x;
   int y;
   int z;
   int w;
};
struct uint_vec {
   uint x;
   uint y;
   uint z;
   uint w;
};
struct bool_vec {
   bool x;
   bool y;
   bool z;
   bool w;
};

static nir_const_value
evaluate_b2f(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               bool src0 = _src[0].u[_i] != 0;

            float dst = src0 ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_b2i(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               bool src0 = _src[0].u[_i] != 0;

            int dst = src0 ? 1 : 0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ball_fequal2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_ball_fequal3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_ball_fequal4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_ball_iequal2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct int_vec src0 = {
            _src[0].i[0],
            _src[0].i[1],
      };

      struct int_vec src1 = {
            _src[1].i[0],
            _src[1].i[1],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_ball_iequal3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct int_vec src0 = {
            _src[0].i[0],
            _src[0].i[1],
            _src[0].i[2],
      };

      struct int_vec src1 = {
            _src[1].i[0],
            _src[1].i[1],
            _src[1].i[2],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_ball_iequal4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct int_vec src0 = {
            _src[0].i[0],
            _src[0].i[1],
            _src[0].i[2],
            _src[0].i[3],
      };

      struct int_vec src1 = {
            _src[1].i[0],
            _src[1].i[1],
            _src[1].i[2],
            _src[1].i[3],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bany_fnequal2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bany_fnequal3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bany_fnequal4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bany_inequal2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct int_vec src0 = {
            _src[0].i[0],
            _src[0].i[1],
      };

      struct int_vec src1 = {
            _src[1].i[0],
            _src[1].i[1],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bany_inequal3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct int_vec src0 = {
            _src[0].i[0],
            _src[0].i[1],
            _src[0].i[2],
      };

      struct int_vec src1 = {
            _src[1].i[0],
            _src[1].i[1],
            _src[1].i[2],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bany_inequal4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct int_vec src0 = {
            _src[0].i[0],
            _src[0].i[1],
            _src[0].i[2],
            _src[0].i[3],
      };

      struct int_vec src1 = {
            _src[1].i[0],
            _src[1].i[1],
            _src[1].i[2],
            _src[1].i[3],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bcsel(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               bool src0 = _src[0].u[_i] != 0;
               uint src1 = _src[1].u[_i];
               uint src2 = _src[2].u[_i];

            uint dst = src0 ? src1 : src2;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_bfi(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];
               uint src2 = _src[2].u[_i];

            uint dst;
            
unsigned mask = src0, insert = src1, base = src2;
if (mask == 0) {
   dst = base;
} else {
   unsigned tmp = mask;
   while (!(tmp & 1)) {
      tmp >>= 1;
      insert <<= 1;
   }
   dst = (base & ~mask) | (insert & mask);
}


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_bfm(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            uint dst;
            
int bits = src0, offset = src1;
if (offset < 0 || bits < 0 || offset > 31 || bits > 31 || offset + bits > 32)
   dst = 0; /* undefined */
else
   dst = ((1u << bits) - 1) << offset;


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_bit_count(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];

            uint dst;
            
dst = 0;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1)
      dst++;
}


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_bitfield_insert(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                                    
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];
               int src2 = _src[2].i[_i];
               int src3 = _src[3].i[_i];

            uint dst;
            
unsigned base = src0, insert = src1;
int offset = src2, bits = src3;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || bits + offset > 32) {
   dst = 0;
} else {
   unsigned mask = ((1ull << bits) - 1) << offset;
   dst = (base & ~mask) | ((insert << bits) & mask);
}


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_bitfield_reverse(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];

            uint dst;
            
/* we're not winning any awards for speed here, but that's ok */
dst = 0;
for (unsigned bit = 0; bit < 32; bit++)
   dst |= ((src0 >> bit) & 1) << (31 - bit);


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_extract_i16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = (int16_t)(src0 >> (src1 * 16));

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_extract_i8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = (int8_t)(src0 >> (src1 * 8));

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_extract_u16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = (uint16_t)(src0 >> (src1 * 16));

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_extract_u8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = (uint8_t)(src0 >> (src1 * 8));

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_f2b(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            bool dst = src0 != 0.0f;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_f2i(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            int dst = src0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_f2u(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            uint dst = src0;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fabs(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = fabsf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fadd(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = src0 + src1;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fall_equal2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y)) ? 1.0f : 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fall_equal3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z)) ? 1.0f : 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fall_equal4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w)) ? 1.0f : 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fand(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = ((src0 != 0.0f) && (src1 != 0.0f)) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fany_nequal2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y)) ? 1.0f : 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fany_nequal3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z)) ? 1.0f : 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fany_nequal4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w)) ? 1.0f : 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fceil(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = ceilf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fcos(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = cosf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fcsel(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];
               float src2 = _src[2].f[_i];

            float dst = (src0 != 0.0f) ? src1 : src2;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fddx(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float dst = 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fddx_coarse(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float dst = 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fddx_fine(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float dst = 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fddy(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float dst = 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fddy_coarse(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float dst = 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fddy_fine(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float dst = 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fdiv(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = src0 / src1;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fdot2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fdot3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fdot4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fdot_replicated2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fdot_replicated3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fdot_replicated4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fdph(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fdph_replicated(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_feq(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            bool dst = src0 == src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fexp2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = exp2f(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ffloor(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = floorf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ffma(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];
               float src2 = _src[2].f[_i];

            float dst = src0 * src1 + src2;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ffract(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = src0 - floorf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fge(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            bool dst = src0 >= src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_find_lsb(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst;
            
dst = -1;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1) {
      dst = bit;
      break;
   }
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_flog2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = log2f(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_flrp(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];
               float src2 = _src[2].f[_i];

            float dst = src0 * (1 - src2) + src1 * src2;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_flt(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            bool dst = src0 < src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fmax(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = fmaxf(src0, src1);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fmin(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = fminf(src0, src1);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fmod(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = src0 - src1 * floorf(src0 / src1);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fmov(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = src0;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fmul(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = src0 * src1;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fne(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            bool dst = src0 != src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fneg(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = -src0;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_1(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_1(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_1(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_1(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fnot(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = (src0 == 0.0f) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_for(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = ((src0 != 0.0f) || (src1 != 0.0f)) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fpow(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = powf(src0, src1);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_frcp(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = 1.0f / src0;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fround_even(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = _mesa_roundevenf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_frsq(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = 1.0f / sqrtf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fsat(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = (src0 > 1.0f) ? 1.0f : ((src0 <= 0.0f) ? 0.0f : src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fsign(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = (src0 == 0.0f) ? 0.0f : ((src0 > 0.0f) ? 1.0f : -1.0f);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fsin(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = sinf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fsqrt(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = sqrtf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fsub(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = src0 - src1;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ftrunc(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = truncf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fxor(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = (src0 != 0.0f && src1 == 0.0f) || (src0 == 0.0f && src1 != 0.0f) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_i2b(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            bool dst = src0 != 0;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_i2f(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            float dst = src0;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_iabs(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst = (src0 < 0) ? -src0 : src0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_iadd(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src0 + src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_iand(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 & src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ibfe(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];
               int src2 = _src[2].i[_i];

            int dst;
            
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ibitfield_extract(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];
               int src2 = _src[2].i[_i];

            int dst;
            
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || offset + bits > 32) {
   dst = 0;
} else {
   dst = (base << (32 - offset - bits)) >> offset; /* use sign-extending shift */
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_idiv(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src0 / src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ieq(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            bool dst = src0 == src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ifind_msb(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst;
            
dst = -1;
for (int bit = 31; bit >= 0; bit--) {
   /* If src0 < 0, we're looking for the first 0 bit.
    * if src0 >= 0, we're looking for the first 1 bit.
    */
   if ((((src0 >> bit) & 1) && (src0 >= 0)) ||
      (!((src0 >> bit) & 1) && (src0 < 0))) {
      dst = bit;
      break;
   }
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ige(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            bool dst = src0 >= src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ilt(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            bool dst = src0 < src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_imax(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src1 > src0 ? src1 : src0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_imin(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src1 > src0 ? src0 : src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_imov(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst = src0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_imul(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src0 * src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_imul_high(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = (int32_t)(((int64_t) src0 * (int64_t) src1) >> 32);

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ine(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            bool dst = src0 != src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ineg(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst = -src0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_inot(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst = ~src0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ior(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 | src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ishl(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src0 << src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ishr(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src0 >> src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_isign(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst = (src0 == 0) ? 0 : ((src0 > 0) ? 1 : -1);

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_isub(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src0 - src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ixor(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 ^ src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ldexp(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               int src1 = _src[1].i[_i];

            float dst;
            
dst = ldexpf(src0, src1);
/* flush denormals to zero. */
if (!isnormal(dst))
   dst = copysignf(0.0f, src0);


            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_pack_half_2x16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct uint_vec dst;

         
dst.x = (uint32_t) pack_half_1x16(src0.x);
dst.x |= ((uint32_t) pack_half_1x16(src0.y)) << 16;


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_half_2x16_split(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
      };

      struct float_vec src1 = {
            _src[1].f[0],
      };

      struct uint_vec dst;

         dst.x = dst.y = dst.z = dst.w = pack_half_1x16(src0.x) | (pack_half_1x16(src1.x) << 16);

            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_snorm_2x16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct uint_vec dst;

         
dst.x = (uint32_t) pack_snorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x16(src0.y)) << 16;


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_snorm_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct uint_vec dst;

         
dst.x = (uint32_t) pack_snorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.w)) << 24;


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_unorm_2x16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct uint_vec dst;

         
dst.x = (uint32_t) pack_unorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x16(src0.y)) << 16;


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_unorm_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct uint_vec dst;

         
dst.x = (uint32_t) pack_unorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.w)) << 24;


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_uvec2_to_uint(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
            _src[0].u[1],
      };

      struct uint_vec dst;

         
dst.x = (src0.x & 0xffff) | (src0.y >> 16);


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_uvec4_to_uint(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
            _src[0].u[1],
            _src[0].u[2],
            _src[0].u[3],
      };

      struct uint_vec dst;

         
dst.x = (src0.x <<  0) |
        (src0.y <<  8) |
        (src0.z << 16) |
        (src0.w << 24);


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_seq(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = (src0 == src1) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_sge(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = (src0 >= src1) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_slt(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = (src0 < src1) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_sne(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = (src0 != src1) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_u2f(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];

            float dst = src0;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_uadd_carry(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 + src1 < src0;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ubfe(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               int src1 = _src[1].i[_i];
               int src2 = _src[2].i[_i];

            uint dst;
            
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ubitfield_extract(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               int src1 = _src[1].i[_i];
               int src2 = _src[2].i[_i];

            uint dst;
            
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0 || offset + bits > 32) {
   dst = 0; /* undefined per the spec */
} else {
   dst = (base >> offset) & ((1ull << bits) - 1);
}


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_udiv(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 / src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ufind_msb(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];

            int dst;
            
dst = -1;
for (int bit = 31; bit > 0; bit--) {
   if ((src0 >> bit) & 1) {
      dst = bit;
      break;
   }
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_uge(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            bool dst = src0 >= src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ult(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            bool dst = src0 < src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umax(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src1 > src0 ? src1 : src0;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umax_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst;
            
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MAX2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umin(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src1 > src0 ? src0 : src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umin_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst;
            
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MIN2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umod(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src1 == 0 ? 0 : src0 % src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umul_high(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = (uint32_t)(((uint64_t) src0 * (uint64_t) src1) >> 32);

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umul_unorm_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst;
            
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   dst |= ((src0_chan * src1_chan) / 255) << i;
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_unpack_half_2x16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         
dst.x = unpack_half_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_half_1x16((uint16_t)(src0.x << 16));


            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_unpack_half_2x16_split_x(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x & 0xffff));

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_unpack_half_2x16_split_y(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x >> 16));

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_unpack_snorm_2x16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         
dst.x = unpack_snorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_snorm_1x16((uint16_t)(src0.x << 16));


            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_unpack_snorm_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         
dst.x = unpack_snorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_snorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_snorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_snorm_1x8((uint8_t)(src0.x >> 24));


            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_unpack_unorm_2x16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         
dst.x = unpack_unorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_unorm_1x16((uint16_t)(src0.x << 16));


            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_unpack_unorm_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         
dst.x = unpack_unorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_unorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_unorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_unorm_1x8((uint8_t)(src0.x >> 24));


            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_usadd_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst;
            
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MIN2(((src0 >> i) & 0xff) + ((src1 >> i) & 0xff), 0xff) << i;
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ushr(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 >> src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ussub_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst;
            
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   if (src0_chan > src1_chan)
      dst |= (src0_chan - src1_chan) << i;
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_usub_borrow(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 < src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_vec2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct uint_vec src1 = {
            _src[1].u[0],
      };

      struct uint_vec dst;

         
dst.x = src0.x;
dst.y = src1.x;


            _dst_val.u[0] = dst.x;
            _dst_val.u[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_vec3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct uint_vec src1 = {
            _src[1].u[0],
      };

      struct uint_vec src2 = {
            _src[2].u[0],
      };

      struct uint_vec dst;

         
dst.x = src0.x;
dst.y = src1.x;
dst.z = src2.x;


            _dst_val.u[0] = dst.x;
            _dst_val.u[1] = dst.y;
            _dst_val.u[2] = dst.z;

   return _dst_val;
}
static nir_const_value
evaluate_vec4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct uint_vec src1 = {
            _src[1].u[0],
      };

      struct uint_vec src2 = {
            _src[2].u[0],
      };

      struct uint_vec src3 = {
            _src[3].u[0],
      };

      struct uint_vec dst;

         
dst.x = src0.x;
dst.y = src1.x;
dst.z = src2.x;
dst.w = src3.x;


            _dst_val.u[0] = dst.x;
            _dst_val.u[1] = dst.y;
            _dst_val.u[2] = dst.z;
            _dst_val.u[3] = dst.w;

   return _dst_val;
}

nir_const_value
nir_eval_const_opcode(nir_op op, unsigned num_components,
                      nir_const_value *src)
{
   switch (op) {
   case nir_op_b2f: {
      return evaluate_b2f(num_components, src);
      break;
   }
   case nir_op_b2i: {
      return evaluate_b2i(num_components, src);
      break;
   }
   case nir_op_ball_fequal2: {
      return evaluate_ball_fequal2(num_components, src);
      break;
   }
   case nir_op_ball_fequal3: {
      return evaluate_ball_fequal3(num_components, src);
      break;
   }
   case nir_op_ball_fequal4: {
      return evaluate_ball_fequal4(num_components, src);
      break;
   }
   case nir_op_ball_iequal2: {
      return evaluate_ball_iequal2(num_components, src);
      break;
   }
   case nir_op_ball_iequal3: {
      return evaluate_ball_iequal3(num_components, src);
      break;
   }
   case nir_op_ball_iequal4: {
      return evaluate_ball_iequal4(num_components, src);
      break;
   }
   case nir_op_bany_fnequal2: {
      return evaluate_bany_fnequal2(num_components, src);
      break;
   }
   case nir_op_bany_fnequal3: {
      return evaluate_bany_fnequal3(num_components, src);
      break;
   }
   case nir_op_bany_fnequal4: {
      return evaluate_bany_fnequal4(num_components, src);
      break;
   }
   case nir_op_bany_inequal2: {
      return evaluate_bany_inequal2(num_components, src);
      break;
   }
   case nir_op_bany_inequal3: {
      return evaluate_bany_inequal3(num_components, src);
      break;
   }
   case nir_op_bany_inequal4: {
      return evaluate_bany_inequal4(num_components, src);
      break;
   }
   case nir_op_bcsel: {
      return evaluate_bcsel(num_components, src);
      break;
   }
   case nir_op_bfi: {
      return evaluate_bfi(num_components, src);
      break;
   }
   case nir_op_bfm: {
      return evaluate_bfm(num_components, src);
      break;
   }
   case nir_op_bit_count: {
      return evaluate_bit_count(num_components, src);
      break;
   }
   case nir_op_bitfield_insert: {
      return evaluate_bitfield_insert(num_components, src);
      break;
   }
   case nir_op_bitfield_reverse: {
      return evaluate_bitfield_reverse(num_components, src);
      break;
   }
   case nir_op_extract_i16: {
      return evaluate_extract_i16(num_components, src);
      break;
   }
   case nir_op_extract_i8: {
      return evaluate_extract_i8(num_components, src);
      break;
   }
   case nir_op_extract_u16: {
      return evaluate_extract_u16(num_components, src);
      break;
   }
   case nir_op_extract_u8: {
      return evaluate_extract_u8(num_components, src);
      break;
   }
   case nir_op_f2b: {
      return evaluate_f2b(num_components, src);
      break;
   }
   case nir_op_f2i: {
      return evaluate_f2i(num_components, src);
      break;
   }
   case nir_op_f2u: {
      return evaluate_f2u(num_components, src);
      break;
   }
   case nir_op_fabs: {
      return evaluate_fabs(num_components, src);
      break;
   }
   case nir_op_fadd: {
      return evaluate_fadd(num_components, src);
      break;
   }
   case nir_op_fall_equal2: {
      return evaluate_fall_equal2(num_components, src);
      break;
   }
   case nir_op_fall_equal3: {
      return evaluate_fall_equal3(num_components, src);
      break;
   }
   case nir_op_fall_equal4: {
      return evaluate_fall_equal4(num_components, src);
      break;
   }
   case nir_op_fand: {
      return evaluate_fand(num_components, src);
      break;
   }
   case nir_op_fany_nequal2: {
      return evaluate_fany_nequal2(num_components, src);
      break;
   }
   case nir_op_fany_nequal3: {
      return evaluate_fany_nequal3(num_components, src);
      break;
   }
   case nir_op_fany_nequal4: {
      return evaluate_fany_nequal4(num_components, src);
      break;
   }
   case nir_op_fceil: {
      return evaluate_fceil(num_components, src);
      break;
   }
   case nir_op_fcos: {
      return evaluate_fcos(num_components, src);
      break;
   }
   case nir_op_fcsel: {
      return evaluate_fcsel(num_components, src);
      break;
   }
   case nir_op_fddx: {
      return evaluate_fddx(num_components, src);
      break;
   }
   case nir_op_fddx_coarse: {
      return evaluate_fddx_coarse(num_components, src);
      break;
   }
   case nir_op_fddx_fine: {
      return evaluate_fddx_fine(num_components, src);
      break;
   }
   case nir_op_fddy: {
      return evaluate_fddy(num_components, src);
      break;
   }
   case nir_op_fddy_coarse: {
      return evaluate_fddy_coarse(num_components, src);
      break;
   }
   case nir_op_fddy_fine: {
      return evaluate_fddy_fine(num_components, src);
      break;
   }
   case nir_op_fdiv: {
      return evaluate_fdiv(num_components, src);
      break;
   }
   case nir_op_fdot2: {
      return evaluate_fdot2(num_components, src);
      break;
   }
   case nir_op_fdot3: {
      return evaluate_fdot3(num_components, src);
      break;
   }
   case nir_op_fdot4: {
      return evaluate_fdot4(num_components, src);
      break;
   }
   case nir_op_fdot_replicated2: {
      return evaluate_fdot_replicated2(num_components, src);
      break;
   }
   case nir_op_fdot_replicated3: {
      return evaluate_fdot_replicated3(num_components, src);
      break;
   }
   case nir_op_fdot_replicated4: {
      return evaluate_fdot_replicated4(num_components, src);
      break;
   }
   case nir_op_fdph: {
      return evaluate_fdph(num_components, src);
      break;
   }
   case nir_op_fdph_replicated: {
      return evaluate_fdph_replicated(num_components, src);
      break;
   }
   case nir_op_feq: {
      return evaluate_feq(num_components, src);
      break;
   }
   case nir_op_fexp2: {
      return evaluate_fexp2(num_components, src);
      break;
   }
   case nir_op_ffloor: {
      return evaluate_ffloor(num_components, src);
      break;
   }
   case nir_op_ffma: {
      return evaluate_ffma(num_components, src);
      break;
   }
   case nir_op_ffract: {
      return evaluate_ffract(num_components, src);
      break;
   }
   case nir_op_fge: {
      return evaluate_fge(num_components, src);
      break;
   }
   case nir_op_find_lsb: {
      return evaluate_find_lsb(num_components, src);
      break;
   }
   case nir_op_flog2: {
      return evaluate_flog2(num_components, src);
      break;
   }
   case nir_op_flrp: {
      return evaluate_flrp(num_components, src);
      break;
   }
   case nir_op_flt: {
      return evaluate_flt(num_components, src);
      break;
   }
   case nir_op_fmax: {
      return evaluate_fmax(num_components, src);
      break;
   }
   case nir_op_fmin: {
      return evaluate_fmin(num_components, src);
      break;
   }
   case nir_op_fmod: {
      return evaluate_fmod(num_components, src);
      break;
   }
   case nir_op_fmov: {
      return evaluate_fmov(num_components, src);
      break;
   }
   case nir_op_fmul: {
      return evaluate_fmul(num_components, src);
      break;
   }
   case nir_op_fne: {
      return evaluate_fne(num_components, src);
      break;
   }
   case nir_op_fneg: {
      return evaluate_fneg(num_components, src);
      break;
   }
   case nir_op_fnoise1_1: {
      return evaluate_fnoise1_1(num_components, src);
      break;
   }
   case nir_op_fnoise1_2: {
      return evaluate_fnoise1_2(num_components, src);
      break;
   }
   case nir_op_fnoise1_3: {
      return evaluate_fnoise1_3(num_components, src);
      break;
   }
   case nir_op_fnoise1_4: {
      return evaluate_fnoise1_4(num_components, src);
      break;
   }
   case nir_op_fnoise2_1: {
      return evaluate_fnoise2_1(num_components, src);
      break;
   }
   case nir_op_fnoise2_2: {
      return evaluate_fnoise2_2(num_components, src);
      break;
   }
   case nir_op_fnoise2_3: {
      return evaluate_fnoise2_3(num_components, src);
      break;
   }
   case nir_op_fnoise2_4: {
      return evaluate_fnoise2_4(num_components, src);
      break;
   }
   case nir_op_fnoise3_1: {
      return evaluate_fnoise3_1(num_components, src);
      break;
   }
   case nir_op_fnoise3_2: {
      return evaluate_fnoise3_2(num_components, src);
      break;
   }
   case nir_op_fnoise3_3: {
      return evaluate_fnoise3_3(num_components, src);
      break;
   }
   case nir_op_fnoise3_4: {
      return evaluate_fnoise3_4(num_components, src);
      break;
   }
   case nir_op_fnoise4_1: {
      return evaluate_fnoise4_1(num_components, src);
      break;
   }
   case nir_op_fnoise4_2: {
      return evaluate_fnoise4_2(num_components, src);
      break;
   }
   case nir_op_fnoise4_3: {
      return evaluate_fnoise4_3(num_components, src);
      break;
   }
   case nir_op_fnoise4_4: {
      return evaluate_fnoise4_4(num_components, src);
      break;
   }
   case nir_op_fnot: {
      return evaluate_fnot(num_components, src);
      break;
   }
   case nir_op_for: {
      return evaluate_for(num_components, src);
      break;
   }
   case nir_op_fpow: {
      return evaluate_fpow(num_components, src);
      break;
   }
   case nir_op_frcp: {
      return evaluate_frcp(num_components, src);
      break;
   }
   case nir_op_fround_even: {
      return evaluate_fround_even(num_components, src);
      break;
   }
   case nir_op_frsq: {
      return evaluate_frsq(num_components, src);
      break;
   }
   case nir_op_fsat: {
      return evaluate_fsat(num_components, src);
      break;
   }
   case nir_op_fsign: {
      return evaluate_fsign(num_components, src);
      break;
   }
   case nir_op_fsin: {
      return evaluate_fsin(num_components, src);
      break;
   }
   case nir_op_fsqrt: {
      return evaluate_fsqrt(num_components, src);
      break;
   }
   case nir_op_fsub: {
      return evaluate_fsub(num_components, src);
      break;
   }
   case nir_op_ftrunc: {
      return evaluate_ftrunc(num_components, src);
      break;
   }
   case nir_op_fxor: {
      return evaluate_fxor(num_components, src);
      break;
   }
   case nir_op_i2b: {
      return evaluate_i2b(num_components, src);
      break;
   }
   case nir_op_i2f: {
      return evaluate_i2f(num_components, src);
      break;
   }
   case nir_op_iabs: {
      return evaluate_iabs(num_components, src);
      break;
   }
   case nir_op_iadd: {
      return evaluate_iadd(num_components, src);
      break;
   }
   case nir_op_iand: {
      return evaluate_iand(num_components, src);
      break;
   }
   case nir_op_ibfe: {
      return evaluate_ibfe(num_components, src);
      break;
   }
   case nir_op_ibitfield_extract: {
      return evaluate_ibitfield_extract(num_components, src);
      break;
   }
   case nir_op_idiv: {
      return evaluate_idiv(num_components, src);
      break;
   }
   case nir_op_ieq: {
      return evaluate_ieq(num_components, src);
      break;
   }
   case nir_op_ifind_msb: {
      return evaluate_ifind_msb(num_components, src);
      break;
   }
   case nir_op_ige: {
      return evaluate_ige(num_components, src);
      break;
   }
   case nir_op_ilt: {
      return evaluate_ilt(num_components, src);
      break;
   }
   case nir_op_imax: {
      return evaluate_imax(num_components, src);
      break;
   }
   case nir_op_imin: {
      return evaluate_imin(num_components, src);
      break;
   }
   case nir_op_imov: {
      return evaluate_imov(num_components, src);
      break;
   }
   case nir_op_imul: {
      return evaluate_imul(num_components, src);
      break;
   }
   case nir_op_imul_high: {
      return evaluate_imul_high(num_components, src);
      break;
   }
   case nir_op_ine: {
      return evaluate_ine(num_components, src);
      break;
   }
   case nir_op_ineg: {
      return evaluate_ineg(num_components, src);
      break;
   }
   case nir_op_inot: {
      return evaluate_inot(num_components, src);
      break;
   }
   case nir_op_ior: {
      return evaluate_ior(num_components, src);
      break;
   }
   case nir_op_ishl: {
      return evaluate_ishl(num_components, src);
      break;
   }
   case nir_op_ishr: {
      return evaluate_ishr(num_components, src);
      break;
   }
   case nir_op_isign: {
      return evaluate_isign(num_components, src);
      break;
   }
   case nir_op_isub: {
      return evaluate_isub(num_components, src);
      break;
   }
   case nir_op_ixor: {
      return evaluate_ixor(num_components, src);
      break;
   }
   case nir_op_ldexp: {
      return evaluate_ldexp(num_components, src);
      break;
   }
   case nir_op_pack_half_2x16: {
      return evaluate_pack_half_2x16(num_components, src);
      break;
   }
   case nir_op_pack_half_2x16_split: {
      return evaluate_pack_half_2x16_split(num_components, src);
      break;
   }
   case nir_op_pack_snorm_2x16: {
      return evaluate_pack_snorm_2x16(num_components, src);
      break;
   }
   case nir_op_pack_snorm_4x8: {
      return evaluate_pack_snorm_4x8(num_components, src);
      break;
   }
   case nir_op_pack_unorm_2x16: {
      return evaluate_pack_unorm_2x16(num_components, src);
      break;
   }
   case nir_op_pack_unorm_4x8: {
      return evaluate_pack_unorm_4x8(num_components, src);
      break;
   }
   case nir_op_pack_uvec2_to_uint: {
      return evaluate_pack_uvec2_to_uint(num_components, src);
      break;
   }
   case nir_op_pack_uvec4_to_uint: {
      return evaluate_pack_uvec4_to_uint(num_components, src);
      break;
   }
   case nir_op_seq: {
      return evaluate_seq(num_components, src);
      break;
   }
   case nir_op_sge: {
      return evaluate_sge(num_components, src);
      break;
   }
   case nir_op_slt: {
      return evaluate_slt(num_components, src);
      break;
   }
   case nir_op_sne: {
      return evaluate_sne(num_components, src);
      break;
   }
   case nir_op_u2f: {
      return evaluate_u2f(num_components, src);
      break;
   }
   case nir_op_uadd_carry: {
      return evaluate_uadd_carry(num_components, src);
      break;
   }
   case nir_op_ubfe: {
      return evaluate_ubfe(num_components, src);
      break;
   }
   case nir_op_ubitfield_extract: {
      return evaluate_ubitfield_extract(num_components, src);
      break;
   }
   case nir_op_udiv: {
      return evaluate_udiv(num_components, src);
      break;
   }
   case nir_op_ufind_msb: {
      return evaluate_ufind_msb(num_components, src);
      break;
   }
   case nir_op_uge: {
      return evaluate_uge(num_components, src);
      break;
   }
   case nir_op_ult: {
      return evaluate_ult(num_components, src);
      break;
   }
   case nir_op_umax: {
      return evaluate_umax(num_components, src);
      break;
   }
   case nir_op_umax_4x8: {
      return evaluate_umax_4x8(num_components, src);
      break;
   }
   case nir_op_umin: {
      return evaluate_umin(num_components, src);
      break;
   }
   case nir_op_umin_4x8: {
      return evaluate_umin_4x8(num_components, src);
      break;
   }
   case nir_op_umod: {
      return evaluate_umod(num_components, src);
      break;
   }
   case nir_op_umul_high: {
      return evaluate_umul_high(num_components, src);
      break;
   }
   case nir_op_umul_unorm_4x8: {
      return evaluate_umul_unorm_4x8(num_components, src);
      break;
   }
   case nir_op_unpack_half_2x16: {
      return evaluate_unpack_half_2x16(num_components, src);
      break;
   }
   case nir_op_unpack_half_2x16_split_x: {
      return evaluate_unpack_half_2x16_split_x(num_components, src);
      break;
   }
   case nir_op_unpack_half_2x16_split_y: {
      return evaluate_unpack_half_2x16_split_y(num_components, src);
      break;
   }
   case nir_op_unpack_snorm_2x16: {
      return evaluate_unpack_snorm_2x16(num_components, src);
      break;
   }
   case nir_op_unpack_snorm_4x8: {
      return evaluate_unpack_snorm_4x8(num_components, src);
      break;
   }
   case nir_op_unpack_unorm_2x16: {
      return evaluate_unpack_unorm_2x16(num_components, src);
      break;
   }
   case nir_op_unpack_unorm_4x8: {
      return evaluate_unpack_unorm_4x8(num_components, src);
      break;
   }
   case nir_op_usadd_4x8: {
      return evaluate_usadd_4x8(num_components, src);
      break;
   }
   case nir_op_ushr: {
      return evaluate_ushr(num_components, src);
      break;
   }
   case nir_op_ussub_4x8: {
      return evaluate_ussub_4x8(num_components, src);
      break;
   }
   case nir_op_usub_borrow: {
      return evaluate_usub_borrow(num_components, src);
      break;
   }
   case nir_op_vec2: {
      return evaluate_vec2(num_components, src);
      break;
   }
   case nir_op_vec3: {
      return evaluate_vec3(num_components, src);
      break;
   }
   case nir_op_vec4: {
      return evaluate_vec4(num_components, src);
      break;
   }
   default:
      unreachable("shouldn't get here");
   }
}
@


1.1.1.1
log
@Import Mesa 11.2.2
@
text
@@


1.1.1.2
log
@Import Mesa 13.0.2
@
text
@d206 5
a210 8
typedef float float32_t;
typedef double float64_t;
typedef bool bool32_t;
struct float32_vec {
   float32_t x;
   float32_t y;
   float32_t z;
   float32_t w;
d212 5
a216 5
struct float64_vec {
   float64_t x;
   float64_t y;
   float64_t z;
   float64_t w;
d218 5
a222 5
struct int32_vec {
   int32_t x;
   int32_t y;
   int32_t z;
   int32_t w;
d224 5
a228 24
struct int64_vec {
   int64_t x;
   int64_t y;
   int64_t z;
   int64_t w;
};
struct uint32_vec {
   uint32_t x;
   uint32_t y;
   uint32_t z;
   uint32_t w;
};
struct uint64_vec {
   uint64_t x;
   uint64_t y;
   uint64_t z;
   uint64_t w;
};

struct bool32_vec {
    bool x;
    bool y;
    bool z;
    bool w;
d232 1
a232 2
evaluate_b2f(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d234 1
a234 1
   nir_const_value _dst_val = { {0, } };
d236 3
a238 3
   switch (bit_size) {
   case 32: {
      
d240 1
a240 3
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  bool src0 = _src[0].u32[_i] != 0;
d242 2
a243 1
               float32_t dst = src0 ? 1.0f : 0.0f;
d245 6
a250 7
               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      
d252 3
a254 5
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  bool src0 = _src[0].u32[_i] != 0;

               float32_t dst = src0 ? 1.0f : 0.0f;
d256 1
a256 5
               _dst_val.f32[_i] = dst;
         }

      break;
   }
d258 2
a259 3
   default:
      unreachable("unknown bit width");
   }
d264 1
a264 2
evaluate_b2i(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d266 1
a266 11
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  bool src0 = _src[0].u32[_i] != 0;

               int32_t dst = src0 ? 1 : 0;
a267 7
               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      
d269 4
a272 3
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  bool src0 = _src[0].u32[_i] != 0;
d274 4
a277 1
               int32_t dst = src0 ? 1 : 0;
d279 1
a279 2
               _dst_val.i32[_i] = dst;
         }
d281 1
a281 2
      break;
   }
d283 1
a283 3
   default:
      unreachable("unknown bit width");
   }
d288 1
a288 2
evaluate_ball_fequal2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d290 1
a290 1
   nir_const_value _dst_val = { {0, } };
a291 3
   switch (bit_size) {
   case 32: {
      
d293 5
d299 5
a303 4
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };
d305 1
a305 4
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };
d307 1
a307 1
         struct bool32_vec dst;
d309 1
a309 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));
d311 6
a316 6
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
   case 64: {
      
d319 6
a324 4
         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
         };
d326 6
a331 4
         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
         };
d333 1
a333 1
         struct bool32_vec dst;
d335 1
a335 6
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));

               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
d337 1
a337 3
   default:
      unreachable("unknown bit width");
   }
d342 1
a342 2
evaluate_ball_fequal3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d344 1
a344 1
   nir_const_value _dst_val = { {0, } };
a345 3
   switch (bit_size) {
   case 32: {
      
d347 4
d352 4
a355 5
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };
d357 1
a357 5
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };
d359 1
a359 1
         struct bool32_vec dst;
d361 1
a361 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));
d363 6
a368 6
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
   case 64: {
      
d371 5
a375 5
         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
         };
d377 5
a381 5
         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
         };
d383 1
a383 1
         struct bool32_vec dst;
d385 1
a385 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));
d387 1
a387 8
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }

   default:
      unreachable("unknown bit width");
   }
d392 1
a392 2
evaluate_ball_fequal4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d394 1
a394 1
   nir_const_value _dst_val = { {0, } };
a395 3
   switch (bit_size) {
   case 32: {
      
d397 6
d404 6
a409 6
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };
d411 1
a411 6
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };
d413 1
a413 1
         struct bool32_vec dst;
d415 1
a415 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));
d417 6
a422 6
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
   case 64: {
      
d425 4
a428 6
         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
               _src[0].f64[3],
         };
d430 4
a433 6
         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
               _src[1].f64[3],
         };
d435 1
a435 1
         struct bool32_vec dst;
d437 1
a437 6
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));

               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
d439 1
a439 3
   default:
      unreachable("unknown bit width");
   }
d444 1
a444 2
evaluate_ball_iequal2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d446 1
a446 1
   nir_const_value _dst_val = { {0, } };
a447 3
   switch (bit_size) {
   case 32: {
      
d449 5
d455 5
a459 4
         struct int32_vec src0 = {
               _src[0].i32[0],
               _src[0].i32[1],
         };
d461 1
a461 4
         struct int32_vec src1 = {
               _src[1].i32[0],
               _src[1].i32[1],
         };
d463 1
a463 1
         struct bool32_vec dst;
d465 1
a465 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));
d467 6
a472 6
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
   case 64: {
      
d475 6
a480 4
         struct int64_vec src0 = {
               _src[0].i64[0],
               _src[0].i64[1],
         };
d482 6
a487 4
         struct int64_vec src1 = {
               _src[1].i64[0],
               _src[1].i64[1],
         };
d489 1
a489 1
         struct bool32_vec dst;
d491 1
a491 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));
d493 1
a493 8
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }

   default:
      unreachable("unknown bit width");
   }
d498 1
a498 2
evaluate_ball_iequal3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d500 1
a500 1
   nir_const_value _dst_val = { {0, } };
a501 3
   switch (bit_size) {
   case 32: {
      
d503 4
d508 4
a511 5
         struct int32_vec src0 = {
               _src[0].i32[0],
               _src[0].i32[1],
               _src[0].i32[2],
         };
d513 1
a513 5
         struct int32_vec src1 = {
               _src[1].i32[0],
               _src[1].i32[1],
               _src[1].i32[2],
         };
d515 1
a515 1
         struct bool32_vec dst;
d517 1
a517 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));
d519 6
a524 6
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
   case 64: {
      
d527 5
a531 5
         struct int64_vec src0 = {
               _src[0].i64[0],
               _src[0].i64[1],
               _src[0].i64[2],
         };
d533 5
a537 5
         struct int64_vec src1 = {
               _src[1].i64[0],
               _src[1].i64[1],
               _src[1].i64[2],
         };
d539 1
a539 1
         struct bool32_vec dst;
d541 1
a541 6
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));

               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
d543 1
a543 3
   default:
      unreachable("unknown bit width");
   }
d548 1
a548 2
evaluate_ball_iequal4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d550 1
a550 1
   nir_const_value _dst_val = { {0, } };
a551 3
   switch (bit_size) {
   case 32: {
      
d553 6
d560 6
a565 6
         struct int32_vec src0 = {
               _src[0].i32[0],
               _src[0].i32[1],
               _src[0].i32[2],
               _src[0].i32[3],
         };
d567 1
a567 6
         struct int32_vec src1 = {
               _src[1].i32[0],
               _src[1].i32[1],
               _src[1].i32[2],
               _src[1].i32[3],
         };
d569 1
a569 1
         struct bool32_vec dst;
d571 1
a571 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));
d573 6
a578 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d580 5
a584 4
      break;
   }
   case 64: {
      
d586 1
d588 2
a589 6
         struct int64_vec src0 = {
               _src[0].i64[0],
               _src[0].i64[1],
               _src[0].i64[2],
               _src[0].i64[3],
         };
d591 6
a596 6
         struct int64_vec src1 = {
               _src[1].i64[0],
               _src[1].i64[1],
               _src[1].i64[2],
               _src[1].i64[3],
         };
d598 5
a602 1
         struct bool32_vec dst;
d604 13
a616 3
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));

               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
a617 2
      break;
   }
d619 2
a620 3
   default:
      unreachable("unknown bit width");
   }
d625 1
a625 2
evaluate_bany_fnequal2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d627 1
a627 1
   nir_const_value _dst_val = { {0, } };
d629 4
a632 3
   switch (bit_size) {
   case 32: {
      
d634 7
a641 4
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };
d643 2
a644 4
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };
d646 6
a651 1
         struct bool32_vec dst;
d653 3
a655 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));
d657 7
a663 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
a664 4
      break;
   }
   case 64: {
      
d666 2
d669 6
a674 4
         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
         };
d676 6
a681 4
         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
         };
d683 12
a694 5
         struct bool32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));

               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
a695 2
      break;
   }
d697 2
a698 3
   default:
      unreachable("unknown bit width");
   }
d703 1
a703 2
evaluate_bany_fnequal3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d705 1
a705 1
   nir_const_value _dst_val = { {0, } };
d707 3
a709 3
   switch (bit_size) {
   case 32: {
      
d711 6
a717 5
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };
d719 2
a720 5
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };
d722 6
a727 1
         struct bool32_vec dst;
d729 4
a732 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
d734 1
a734 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d736 2
a737 4
      break;
   }
   case 64: {
      
d739 6
d746 4
a749 5
         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
         };
d751 1
a751 5
         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
         };
d753 2
a754 1
         struct bool32_vec dst;
d756 6
a761 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
d763 4
a766 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d768 1
a768 2
      break;
   }
d770 2
a771 3
   default:
      unreachable("unknown bit width");
   }
d776 1
a776 2
evaluate_bany_fnequal4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d778 1
a778 1
   nir_const_value _dst_val = { {0, } };
d780 4
a783 3
   switch (bit_size) {
   case 32: {
      
d785 1
d787 2
a788 6
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };
d790 6
a795 6
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };
d797 3
a799 1
         struct bool32_vec dst;
d801 1
a801 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));
d803 2
a804 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d806 6
a811 4
      break;
   }
   case 64: {
      
d813 3
d817 1
a817 6
         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
               _src[0].f64[3],
         };
d819 2
a820 6
         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
               _src[1].f64[3],
         };
d822 6
a827 3
         struct bool32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));
d829 3
a831 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d833 1
a833 2
      break;
   }
d835 2
a836 3
   default:
      unreachable("unknown bit width");
   }
d841 1
a841 2
evaluate_bany_inequal2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d843 1
a843 1
   nir_const_value _dst_val = { {0, } };
d845 3
a847 3
   switch (bit_size) {
   case 32: {
      
d849 1
d851 2
a852 4
         struct int32_vec src0 = {
               _src[0].i32[0],
               _src[0].i32[1],
         };
d854 6
a859 4
         struct int32_vec src1 = {
               _src[1].i32[0],
               _src[1].i32[1],
         };
d861 4
a864 1
         struct bool32_vec dst;
d866 1
a866 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));
d868 2
a869 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d871 6
a876 10
      break;
   }
   case 64: {
      


         struct int64_vec src0 = {
               _src[0].i64[0],
               _src[0].i64[1],
         };
a877 4
         struct int64_vec src1 = {
               _src[1].i64[0],
               _src[1].i64[1],
         };
d879 4
a882 1
         struct bool32_vec dst;
d884 4
a887 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));
d889 1
a889 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d891 1
a891 2
      break;
   }
d893 1
a893 3
   default:
      unreachable("unknown bit width");
   }
d898 1
a898 2
evaluate_bany_inequal3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d900 2
a901 1
   nir_const_value _dst_val = { {0, } };
d903 5
a907 3
   switch (bit_size) {
   case 32: {
      
d909 5
d915 1
a915 5
         struct int32_vec src0 = {
               _src[0].i32[0],
               _src[0].i32[1],
               _src[0].i32[2],
         };
d917 1
a917 5
         struct int32_vec src1 = {
               _src[1].i32[0],
               _src[1].i32[1],
               _src[1].i32[2],
         };
d919 1
a919 1
         struct bool32_vec dst;
d921 6
a926 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
a927 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d929 6
a934 4
      break;
   }
   case 64: {
      
d936 6
d943 1
a943 5
         struct int64_vec src0 = {
               _src[0].i64[0],
               _src[0].i64[1],
               _src[0].i64[2],
         };
d945 1
a945 5
         struct int64_vec src1 = {
               _src[1].i64[0],
               _src[1].i64[1],
               _src[1].i64[2],
         };
d947 1
a947 1
         struct bool32_vec dst;
d949 6
a954 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
d956 4
a959 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d961 1
a961 2
      break;
   }
d963 2
a964 3
   default:
      unreachable("unknown bit width");
   }
d969 1
a969 2
evaluate_bany_inequal4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d971 1
a971 1
   nir_const_value _dst_val = { {0, } };
a972 3
   switch (bit_size) {
   case 32: {
      
d974 4
d979 4
a982 6
         struct int32_vec src0 = {
               _src[0].i32[0],
               _src[0].i32[1],
               _src[0].i32[2],
               _src[0].i32[3],
         };
d984 1
a984 6
         struct int32_vec src1 = {
               _src[1].i32[0],
               _src[1].i32[1],
               _src[1].i32[2],
               _src[1].i32[3],
         };
d986 1
a986 1
         struct bool32_vec dst;
d988 1
a988 8
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));

               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
   case 64: {
      
d990 6
a996 6
         struct int64_vec src0 = {
               _src[0].i64[0],
               _src[0].i64[1],
               _src[0].i64[2],
               _src[0].i64[3],
         };
d998 5
a1002 6
         struct int64_vec src1 = {
               _src[1].i64[0],
               _src[1].i64[1],
               _src[1].i64[2],
               _src[1].i64[3],
         };
d1004 5
a1008 1
         struct bool32_vec dst;
d1010 1
a1010 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));
d1012 1
a1012 4
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
d1014 1
a1014 3
   default:
      unreachable("unknown bit width");
   }
d1019 1
a1019 2
evaluate_bcsel(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1021 1
a1021 1
   nir_const_value _dst_val = { {0, } };
a1022 3
   switch (bit_size) {
   case 32: {
      
d1024 6
a1029 7
                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  bool src0 = _src[0].u32[_i] != 0;
                  uint32_t src1 =
                     _src[1].u32[_i];
                  uint32_t src2 =
                     _src[2].u32[_i];
d1031 6
a1036 1
               uint32_t dst = src0 ? src1 : src2;
d1038 1
a1038 2
               _dst_val.u32[_i] = dst;
         }
d1040 1
a1040 4
      break;
   }
   case 64: {
      
d1042 1
a1042 7
                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  bool src0 = _src[0].u32[_i] != 0;
                  uint64_t src1 =
                     _src[1].u64[_i];
                  uint64_t src2 =
                     _src[2].u64[_i];
d1044 6
a1049 1
               uint64_t dst = src0 ? src1 : src2;
d1051 3
a1053 2
               _dst_val.u64[_i] = dst;
         }
d1055 1
a1055 2
      break;
   }
d1057 2
a1058 3
   default:
      unreachable("unknown bit width");
   }
d1063 1
a1063 2
evaluate_bfi(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1065 5
a1069 1
   nir_const_value _dst_val = { {0, } };
d1071 1
a1071 3
   switch (bit_size) {
   case 32: {
      
d1073 2
a1074 8
                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
                  uint32_t src2 =
                     _src[2].u32[_i];
d1076 1
a1076 12
               uint32_t dst;
               
unsigned mask = src0, insert = src1, base = src2;
if (mask == 0) {
   dst = base;
} else {
   unsigned tmp = mask;
   while (!(tmp & 1)) {
      tmp >>= 1;
      insert <<= 1;
   }
   dst = (base & ~mask) | (insert & mask);
d1078 4
d1083 5
d1089 1
a1089 2
               _dst_val.u32[_i] = dst;
         }
d1091 2
a1092 4
      break;
   }
   case 64: {
      
d1094 6
a1099 8
                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
                  uint32_t src2 =
                     _src[2].u32[_i];
d1101 2
a1102 1
               uint32_t dst;
d1104 1
a1104 11
unsigned mask = src0, insert = src1, base = src2;
if (mask == 0) {
   dst = base;
} else {
   unsigned tmp = mask;
   while (!(tmp & 1)) {
      tmp >>= 1;
      insert <<= 1;
   }
   dst = (base & ~mask) | (insert & mask);
}
d1106 2
d1109 6
a1114 2
               _dst_val.u32[_i] = dst;
         }
d1116 4
a1119 2
      break;
   }
d1121 2
a1122 3
   default:
      unreachable("unknown bit width");
   }
d1127 1
a1127 2
evaluate_bfm(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1129 1
a1129 5
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      
d1131 2
a1132 8
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               uint32_t dst;
d1134 1
a1134 5
int bits = src0, offset = src1;
if (offset < 0 || bits < 0 || offset > 31 || bits > 31 || offset + bits > 32)
   dst = 0; /* undefined */
else
   dst = ((1u << bits) - 1) << offset;
d1136 2
d1139 6
a1144 14
               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d1146 2
a1147 1
               uint32_t dst;
d1149 1
a1149 5
int bits = src0, offset = src1;
if (offset < 0 || bits < 0 || offset > 31 || bits > 31 || offset + bits > 32)
   dst = 0; /* undefined */
else
   dst = ((1u << bits) - 1) << offset;
d1151 2
d1154 6
a1159 2
               _dst_val.u32[_i] = dst;
         }
d1161 4
a1164 2
      break;
   }
d1166 2
a1167 3
   default:
      unreachable("unknown bit width");
   }
d1172 1
a1172 2
evaluate_bit_count(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1174 1
a1174 1
   nir_const_value _dst_val = { {0, } };
d1176 4
a1179 3
   switch (bit_size) {
   case 32: {
      
d1181 2
a1182 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
d1184 1
a1184 6
               uint32_t dst;
               
dst = 0;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1)
      dst++;
d1186 9
d1196 1
d1198 2
a1199 2
               _dst_val.u32[_i] = dst;
         }
d1201 6
a1206 4
      break;
   }
   case 64: {
      
a1207 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
d1209 4
a1212 7
               uint32_t dst;
               
dst = 0;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1)
      dst++;
}
d1214 4
d1219 1
a1219 2
               _dst_val.u32[_i] = dst;
         }
d1221 1
a1221 2
      break;
   }
d1223 1
a1223 3
   default:
      unreachable("unknown bit width");
   }
d1228 1
a1228 2
evaluate_bitfield_insert(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1230 2
a1231 1
   nir_const_value _dst_val = { {0, } };
d1233 5
a1237 3
   switch (bit_size) {
   case 32: {
      
d1239 5
a1243 10
                                                
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];
                  int32_t src3 =
                     _src[3].i32[_i];
d1245 1
a1245 12
               uint32_t dst;
               
unsigned base = src0, insert = src1;
int offset = src2, bits = src3;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || bits + offset > 32) {
   dst = 0;
} else {
   unsigned mask = ((1ull << bits) - 1) << offset;
   dst = (base & ~mask) | ((insert << bits) & mask);
}
d1247 1
d1249 1
a1249 2
               _dst_val.u32[_i] = dst;
         }
d1251 6
a1256 4
      break;
   }
   case 64: {
      
a1257 10
                                                
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];
                  int32_t src3 =
                     _src[3].i32[_i];
d1259 6
a1264 12
               uint32_t dst;
               
unsigned base = src0, insert = src1;
int offset = src2, bits = src3;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || bits + offset > 32) {
   dst = 0;
} else {
   unsigned mask = ((1ull << bits) - 1) << offset;
   dst = (base & ~mask) | ((insert << bits) & mask);
}
d1266 6
d1273 1
a1273 2
               _dst_val.u32[_i] = dst;
         }
d1275 1
a1275 2
      break;
   }
d1277 1
a1277 3
   default:
      unreachable("unknown bit width");
   }
d1282 1
a1282 2
evaluate_bitfield_reverse(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1284 2
a1285 1
   nir_const_value _dst_val = { {0, } };
d1287 4
a1290 3
   switch (bit_size) {
   case 32: {
      
d1292 4
a1295 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
d1297 1
a1297 6
               uint32_t dst;
               
/* we're not winning any awards for speed here, but that's ok */
dst = 0;
for (unsigned bit = 0; bit < 32; bit++)
   dst |= ((src0 >> bit) & 1) << (31 - bit);
d1299 1
d1301 4
a1304 2
               _dst_val.u32[_i] = dst;
         }
d1306 6
a1311 4
      break;
   }
   case 64: {
      
a1312 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
d1314 5
a1318 6
               uint32_t dst;
               
/* we're not winning any awards for speed here, but that's ok */
dst = 0;
for (unsigned bit = 0; bit < 32; bit++)
   dst |= ((src0 >> bit) & 1) << (31 - bit);
d1320 5
d1326 1
a1326 2
               _dst_val.u32[_i] = dst;
         }
d1328 1
a1328 2
      break;
   }
d1330 4
a1333 3
   default:
      unreachable("unknown bit width");
   }
d1338 1
a1338 2
evaluate_d2b(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1340 16
a1355 1
   nir_const_value _dst_val = { {0, } };
d1357 1
a1357 3
   switch (bit_size) {
   case 32: {
      
d1359 1
a1359 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1361 4
a1364 1
               bool32_t dst = src0 != 0.0;
d1366 6
a1371 2
               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }
a1372 4
      break;
   }
   case 64: {
      
d1374 5
a1378 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1380 6
a1385 1
               bool32_t dst = src0 != 0.0;
d1387 1
a1387 2
               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }
d1389 1
a1389 2
      break;
   }
d1391 1
a1391 3
   default:
      unreachable("unknown bit width");
   }
d1396 1
a1396 2
evaluate_d2f(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1398 1
a1398 1
   nir_const_value _dst_val = { {0, } };
a1399 3
   switch (bit_size) {
   case 32: {
      
d1401 5
a1405 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1407 6
a1412 1
               float32_t dst = src0;
d1414 1
a1414 2
               _dst_val.f32[_i] = dst;
         }
d1416 1
a1416 4
      break;
   }
   case 64: {
      
d1418 4
a1421 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1423 6
a1428 1
               float32_t dst = src0;
d1430 4
a1433 2
               _dst_val.f32[_i] = dst;
         }
d1435 1
a1435 2
      break;
   }
d1437 2
a1438 3
   default:
      unreachable("unknown bit width");
   }
d1443 1
a1443 2
evaluate_d2i(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1445 5
a1449 1
   nir_const_value _dst_val = { {0, } };
d1451 1
a1451 3
   switch (bit_size) {
   case 32: {
      
d1453 2
a1454 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1456 6
a1461 1
               int32_t dst = src0;
d1463 3
a1465 2
               _dst_val.i32[_i] = dst;
         }
d1467 1
a1467 4
      break;
   }
   case 64: {
      
d1469 2
a1470 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1472 6
a1477 1
               int32_t dst = src0;
d1479 5
a1483 2
               _dst_val.i32[_i] = dst;
         }
d1485 1
a1485 2
      break;
   }
d1487 2
a1488 3
   default:
      unreachable("unknown bit width");
   }
d1493 1
a1493 2
evaluate_d2u(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1495 5
a1499 1
   nir_const_value _dst_val = { {0, } };
d1501 1
a1501 3
   switch (bit_size) {
   case 32: {
      
d1503 2
a1504 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1506 6
a1511 1
               uint32_t dst = src0;
d1513 4
a1516 2
               _dst_val.u32[_i] = dst;
         }
d1518 1
a1518 4
      break;
   }
   case 64: {
      
d1520 2
a1521 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1523 6
a1528 1
               uint32_t dst = src0;
d1530 3
a1532 2
               _dst_val.u32[_i] = dst;
         }
d1534 6
d1542 2
d1545 2
a1546 3
   default:
      unreachable("unknown bit width");
   }
d1551 1
a1551 2
evaluate_extract_i16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1553 5
a1557 1
   nir_const_value _dst_val = { {0, } };
d1559 1
a1559 3
   switch (bit_size) {
   case 32: {
      
d1561 2
a1562 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d1564 6
a1569 1
               int32_t dst = (int16_t)(src0 >> (src1 * 16));
d1571 5
a1575 2
               _dst_val.i32[_i] = dst;
         }
d1577 1
a1577 4
      break;
   }
   case 64: {
      
d1579 2
a1580 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];
d1582 6
a1587 1
               int64_t dst = (int16_t)(src0 >> (src1 * 16));
d1589 4
a1592 2
               _dst_val.i64[_i] = dst;
         }
d1594 1
a1594 2
      break;
   }
d1596 2
a1597 3
   default:
      unreachable("unknown bit width");
   }
d1602 1
a1602 2
evaluate_extract_i8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1604 1
a1604 1
   nir_const_value _dst_val = { {0, } };
d1606 4
a1609 3
   switch (bit_size) {
   case 32: {
      
d1611 1
a1611 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d1613 2
a1614 1
               int32_t dst = (int8_t)(src0 >> (src1 * 8));
d1616 6
a1621 2
               _dst_val.i32[_i] = dst;
         }
d1623 4
a1626 4
      break;
   }
   case 64: {
      
d1628 1
a1628 14
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = (int8_t)(src0 >> (src1 * 8));

               _dst_val.i64[_i] = dst;
         }

      break;
   }
d1630 2
a1631 3
   default:
      unreachable("unknown bit width");
   }
d1636 1
a1636 2
evaluate_extract_u16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1638 1
a1638 1
   nir_const_value _dst_val = { {0, } };
d1640 4
a1643 3
   switch (bit_size) {
   case 32: {
      
d1645 1
a1645 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d1647 2
a1648 1
               uint32_t dst = (uint16_t)(src0 >> (src1 * 16));
d1650 6
a1655 16
               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = (uint16_t)(src0 >> (src1 * 16));
d1657 3
a1659 2
               _dst_val.u64[_i] = dst;
         }
d1661 1
a1661 2
      break;
   }
d1663 2
a1664 3
   default:
      unreachable("unknown bit width");
   }
d1669 1
a1669 2
evaluate_extract_u8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1671 1
a1671 1
   nir_const_value _dst_val = { {0, } };
d1673 4
a1676 3
   switch (bit_size) {
   case 32: {
      
d1678 1
a1678 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d1680 2
a1681 1
               uint32_t dst = (uint8_t)(src0 >> (src1 * 8));
d1683 6
a1688 2
               _dst_val.u32[_i] = dst;
         }
d1690 6
a1695 4
      break;
   }
   case 64: {
      
d1697 2
a1698 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];
d1700 6
a1705 1
               uint64_t dst = (uint8_t)(src0 >> (src1 * 8));
d1707 3
a1709 2
               _dst_val.u64[_i] = dst;
         }
d1711 1
a1711 2
      break;
   }
d1713 2
a1714 3
   default:
      unreachable("unknown bit width");
   }
d1719 1
a1719 2
evaluate_f2b(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1721 4
a1724 1
   nir_const_value _dst_val = { {0, } };
d1726 1
a1726 3
   switch (bit_size) {
   case 32: {
      
d1728 1
a1728 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1730 6
a1735 1
               bool32_t dst = src0 != 0.0f;
d1737 2
a1738 2
               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }
d1740 1
a1740 4
      break;
   }
   case 64: {
      
d1742 1
a1742 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1744 6
a1749 1
               bool32_t dst = src0 != 0.0f;
d1751 2
a1752 2
               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }
d1754 1
a1754 2
      break;
   }
d1756 1
a1756 3
   default:
      unreachable("unknown bit width");
   }
d1761 1
a1761 2
evaluate_f2d(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1763 1
a1763 5
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      
d1765 2
a1766 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1768 1
a1768 1
               float64_t dst = src0;
d1770 1
a1770 2
               _dst_val.f64[_i] = dst;
         }
d1772 6
a1777 11
      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float64_t dst = src0;
d1779 2
a1780 2
               _dst_val.f64[_i] = dst;
         }
d1782 1
a1782 2
      break;
   }
d1784 2
a1785 3
   default:
      unreachable("unknown bit width");
   }
d1790 1
a1790 2
evaluate_f2i(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1792 1
a1792 1
   nir_const_value _dst_val = { {0, } };
d1794 2
a1795 3
   switch (bit_size) {
   case 32: {
      
d1797 1
a1797 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1799 2
a1800 1
               int32_t dst = src0;
d1802 6
a1807 14
               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               int32_t dst = src0;
d1809 2
a1810 2
               _dst_val.i32[_i] = dst;
         }
d1812 1
a1812 2
      break;
   }
d1814 2
a1815 3
   default:
      unreachable("unknown bit width");
   }
d1820 1
a1820 2
evaluate_f2u(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1822 1
a1822 1
   nir_const_value _dst_val = { {0, } };
d1824 2
a1825 3
   switch (bit_size) {
   case 32: {
      
d1827 1
a1827 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1829 2
a1830 1
               uint32_t dst = src0;
d1832 6
a1837 2
               _dst_val.u32[_i] = dst;
         }
d1839 2
a1840 9
      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1842 1
a1842 7
               uint32_t dst = src0;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
d1844 3
a1846 3
   default:
      unreachable("unknown bit width");
   }
d1851 1
a1851 2
evaluate_fabs(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1853 1
a1853 1
   nir_const_value _dst_val = { {0, } };
d1855 2
a1856 3
   switch (bit_size) {
   case 32: {
      
d1858 1
a1858 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1860 3
a1862 1
               float32_t dst = bit_size == 64 ? fabs(src0) : fabsf(src0);
d1864 6
a1869 14
               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? fabs(src0) : fabsf(src0);
d1871 2
a1872 2
               _dst_val.f64[_i] = dst;
         }
d1874 1
a1874 2
      break;
   }
d1876 3
a1878 3
   default:
      unreachable("unknown bit width");
   }
d1883 1
a1883 2
evaluate_fadd(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1885 1
a1885 1
   nir_const_value _dst_val = { {0, } };
d1887 2
a1888 3
   switch (bit_size) {
   case 32: {
      
d1890 1
a1890 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];
d1892 3
a1894 1
               float32_t dst = src0 + src1;
d1896 6
a1901 16
               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = src0 + src1;
d1903 2
a1904 2
               _dst_val.f64[_i] = dst;
         }
d1906 1
a1906 2
      break;
   }
d1908 4
a1911 3
   default:
      unreachable("unknown bit width");
   }
d1916 1
a1916 2
evaluate_fall_equal2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1918 1
a1918 1
   nir_const_value _dst_val = { {0, } };
d1920 2
a1921 3
   switch (bit_size) {
   case 32: {
      
d1923 1
d1925 4
a1928 4
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };
d1930 6
a1935 4
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };
d1937 2
a1938 1
         struct float32_vec dst;
d1940 1
a1940 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y)) ? 1.0f : 0.0f;
d1942 4
a1945 1
               _dst_val.f32[0] = dst.x;
d1947 6
a1952 4
      break;
   }
   case 64: {
      
d1954 2
d1957 1
a1957 4
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };
d1959 4
a1962 4
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };
d1964 6
a1969 3
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y)) ? 1.0f : 0.0f;
d1971 3
a1973 1
               _dst_val.f32[0] = dst.x;
d1975 1
a1975 2
      break;
   }
d1977 2
a1978 3
   default:
      unreachable("unknown bit width");
   }
d1983 1
a1983 2
evaluate_fall_equal3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1985 1
a1985 1
   nir_const_value _dst_val = { {0, } };
d1987 4
a1990 3
   switch (bit_size) {
   case 32: {
      
d1992 1
d1994 2
a1995 5
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };
d1997 6
a2002 5
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };
d2004 4
a2007 1
         struct float32_vec dst;
d2009 1
a2009 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z)) ? 1.0f : 0.0f;
d2011 2
a2012 1
               _dst_val.f32[0] = dst.x;
d2014 6
a2019 4
      break;
   }
   case 64: {
      
d2021 3
d2025 1
a2025 5
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };
d2027 2
a2028 5
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };
d2030 6
a2035 3
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z)) ? 1.0f : 0.0f;
d2037 3
a2039 1
               _dst_val.f32[0] = dst.x;
d2041 1
a2041 2
      break;
   }
d2043 2
a2044 3
   default:
      unreachable("unknown bit width");
   }
d2049 1
a2049 2
evaluate_fall_equal4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2051 1
a2051 1
   nir_const_value _dst_val = { {0, } };
d2053 3
a2055 3
   switch (bit_size) {
   case 32: {
      
d2057 1
d2059 2
a2060 6
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };
d2062 6
a2067 6
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };
d2069 3
a2071 1
         struct float32_vec dst;
d2073 1
a2073 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w)) ? 1.0f : 0.0f;
d2075 2
a2076 1
               _dst_val.f32[0] = dst.x;
d2078 6
a2083 4
      break;
   }
   case 64: {
      
d2085 3
d2089 1
a2089 6
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };
d2091 2
a2092 6
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };
d2094 6
a2099 3
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w)) ? 1.0f : 0.0f;
d2101 3
a2103 1
               _dst_val.f32[0] = dst.x;
d2105 1
a2105 2
      break;
   }
d2107 2
a2108 3
   default:
      unreachable("unknown bit width");
   }
d2113 1
a2113 2
evaluate_fand(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2115 1
a2115 1
   nir_const_value _dst_val = { {0, } };
d2117 3
a2119 3
   switch (bit_size) {
   case 32: {
      
d2121 1
a2121 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];
d2123 2
a2124 1
               float32_t dst = ((src0 != 0.0f) && (src1 != 0.0f)) ? 1.0f : 0.0f;
d2126 6
a2131 2
               _dst_val.f32[_i] = dst;
         }
d2133 4
a2136 13
      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = ((src0 != 0.0f) && (src1 != 0.0f)) ? 1.0f : 0.0f;
d2138 1
a2138 2
               _dst_val.f32[_i] = dst;
         }
d2140 2
a2141 6
      break;
   }

   default:
      unreachable("unknown bit width");
   }
d2146 1
a2146 2
evaluate_fany_nequal2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2148 1
a2148 1
   nir_const_value _dst_val = { {0, } };
d2150 3
a2152 3
   switch (bit_size) {
   case 32: {
      
d2154 1
d2156 2
a2157 4
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };
d2159 6
a2164 4
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };
d2166 4
a2169 1
         struct float32_vec dst;
d2171 1
a2171 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y)) ? 1.0f : 0.0f;
d2173 2
a2174 1
               _dst_val.f32[0] = dst.x;
d2176 6
a2181 4
      break;
   }
   case 64: {
      
d2183 3
d2187 1
a2187 4
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };
d2189 2
a2190 4
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };
d2192 6
a2197 3
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y)) ? 1.0f : 0.0f;
d2199 3
a2201 1
               _dst_val.f32[0] = dst.x;
d2203 1
a2203 2
      break;
   }
d2205 2
a2206 3
   default:
      unreachable("unknown bit width");
   }
d2211 1
a2211 2
evaluate_fany_nequal3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2213 1
a2213 1
   nir_const_value _dst_val = { {0, } };
d2215 3
a2217 3
   switch (bit_size) {
   case 32: {
      
d2219 1
d2221 2
a2222 5
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };
d2224 6
a2229 5
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };
d2231 4
a2234 1
         struct float32_vec dst;
d2236 1
a2236 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z)) ? 1.0f : 0.0f;
d2238 2
a2239 1
               _dst_val.f32[0] = dst.x;
d2241 6
a2246 4
      break;
   }
   case 64: {
      
d2248 4
d2253 1
a2253 5
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };
d2255 2
a2256 5
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };
d2258 6
a2263 1
         struct float32_vec dst;
d2265 5
a2269 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z)) ? 1.0f : 0.0f;
d2271 13
a2283 1
               _dst_val.f32[0] = dst.x;
a2284 2
      break;
   }
d2286 2
a2287 3
   default:
      unreachable("unknown bit width");
   }
d2292 1
a2292 2
evaluate_fany_nequal4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2294 1
a2294 1
   nir_const_value _dst_val = { {0, } };
d2296 5
a2300 3
   switch (bit_size) {
   case 32: {
      
d2302 11
a2313 6
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };
d2315 2
a2316 6
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };
d2318 6
a2323 1
         struct float32_vec dst;
d2325 4
a2328 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w)) ? 1.0f : 0.0f;
d2330 1
a2330 1
               _dst_val.f32[0] = dst.x;
d2332 2
a2333 4
      break;
   }
   case 64: {
      
d2335 6
d2342 4
a2345 6
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };
d2347 1
a2347 6
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };
d2349 2
a2350 1
         struct float32_vec dst;
d2352 6
a2357 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w)) ? 1.0f : 0.0f;
d2359 3
a2361 1
               _dst_val.f32[0] = dst.x;
d2363 10
d2375 1
d2377 3
a2379 3
   default:
      unreachable("unknown bit width");
   }
d2384 1
a2384 2
evaluate_fceil(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2386 1
a2386 1
   nir_const_value _dst_val = { {0, } };
d2388 4
a2391 67
   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? ceil(src0) : ceilf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? ceil(src0) : ceilf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fcos(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? cos(src0) : cosf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d2393 1
a2393 1
               float64_t dst = bit_size == 64 ? cos(src0) : cosf(src0);
d2395 2
a2396 61
               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fcsel(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];
                  float32_t src2 =
                     _src[2].f32[_i];

               float32_t dst = (src0 != 0.0f) ? src1 : src2;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];
                  float32_t src2 =
                     _src[2].f32[_i];

               float32_t dst = (src0 != 0.0f) ? src1 : src2;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }
d2401 1
a2401 2
evaluate_fddx(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2403 1
a2403 13
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float32_t dst = 0.0;

               _dst_val.f32[_i] = dst;
         }
a2404 7
      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
d2406 3
a2408 1
               float64_t dst = 0.0;
d2410 1
a2410 2
               _dst_val.f64[_i] = dst;
         }
d2412 2
a2413 6
      break;
   }

   default:
      unreachable("unknown bit width");
   }
d2418 1
a2418 2
evaluate_fddx_coarse(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2420 1
a2420 18
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float32_t dst = 0.0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      
a2421 2
            
         for (unsigned _i = 0; _i < num_components; _i++) {
d2423 3
a2425 4
               float64_t dst = 0.0;

               _dst_val.f64[_i] = dst;
         }
d2427 1
a2427 2
      break;
   }
d2429 2
a2430 3
   default:
      unreachable("unknown bit width");
   }
d2435 1
a2435 2
evaluate_fddx_fine(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2437 1
a2437 18
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float32_t dst = 0.0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      
a2438 2
            
         for (unsigned _i = 0; _i < num_components; _i++) {
d2440 3
a2442 1
               float64_t dst = 0.0;
d2444 1
a2444 5
               _dst_val.f64[_i] = dst;
         }

      break;
   }
d2446 2
a2447 3
   default:
      unreachable("unknown bit width");
   }
d2452 1
a2452 2
evaluate_fddy(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2454 1
a2454 23
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float32_t dst = 0.0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float64_t dst = 0.0;
d2456 3
a2458 2
               _dst_val.f64[_i] = dst;
         }
d2460 1
a2460 2
      break;
   }
d2462 2
a2463 3
   default:
      unreachable("unknown bit width");
   }
d2468 1
a2468 2
evaluate_fddy_coarse(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2470 1
a2470 1
   nir_const_value _dst_val = { {0, } };
a2471 19
   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float32_t dst = 0.0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
d2473 3
a2475 4
               float64_t dst = 0.0;

               _dst_val.f64[_i] = dst;
         }
d2477 1
a2477 2
      break;
   }
d2479 2
a2480 3
   default:
      unreachable("unknown bit width");
   }
d2485 1
a2485 2
evaluate_fddy_fine(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2487 1
a2487 18
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float32_t dst = 0.0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      
a2488 2
            
         for (unsigned _i = 0; _i < num_components; _i++) {
d2490 3
a2492 293
               float64_t dst = 0.0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdiv(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = src0 / src1;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = src0 / src1;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdot2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdot3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdot4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
               _src[0].f64[3],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
               _src[1].f64[3],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdot_replicated2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
         };
d2494 1
a2494 5364
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdot_replicated3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdot_replicated4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
               _src[0].f64[3],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
               _src[1].f64[3],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdph(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
               _src[1].f64[3],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdph_replicated(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
               _src[1].f64[3],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_feq(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               bool32_t dst = src0 == src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               bool32_t dst = src0 == src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fexp2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = exp2f(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = exp2f(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ffloor(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? floor(src0) : floorf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? floor(src0) : floorf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ffma(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];
                  float32_t src2 =
                     _src[2].f32[_i];

               float32_t dst = src0 * src1 + src2;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];
                  float64_t src2 =
                     _src[2].f64[_i];

               float64_t dst = src0 * src1 + src2;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ffract(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = src0 - (bit_size == 64 ? floor(src0) : floorf(src0));

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = src0 - (bit_size == 64 ? floor(src0) : floorf(src0));

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fge(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               bool32_t dst = src0 >= src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               bool32_t dst = src0 >= src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_find_lsb(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst;
               
dst = -1;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1) {
      dst = bit;
      break;
   }
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst;
               
dst = -1;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1) {
      dst = bit;
      break;
   }
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_flog2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = log2f(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = log2f(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_flrp(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];
                  float32_t src2 =
                     _src[2].f32[_i];

               float32_t dst = src0 * (1 - src2) + src1 * src2;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];
                  float64_t src2 =
                     _src[2].f64[_i];

               float64_t dst = src0 * (1 - src2) + src1 * src2;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_flt(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               bool32_t dst = src0 < src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               bool32_t dst = src0 < src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fmax(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = fmaxf(src0, src1);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = fmaxf(src0, src1);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fmin(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = fminf(src0, src1);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = fminf(src0, src1);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fmod(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = src0 - src1 * floorf(src0 / src1);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = src0 - src1 * floorf(src0 / src1);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fmov(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fmul(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = src0 * src1;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = src0 * src1;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fne(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               bool32_t dst = src0 != src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               bool32_t dst = src0 != src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fneg(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = -src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = -src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_1(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_1(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_1(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_1(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnot(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? ((src0 == 0.0) ? 1.0 : 0.0f) : ((src0 == 0.0f) ? 1.0f : 0.0f);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? ((src0 == 0.0) ? 1.0 : 0.0f) : ((src0 == 0.0f) ? 1.0f : 0.0f);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_for(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = ((src0 != 0.0f) || (src1 != 0.0f)) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = ((src0 != 0.0f) || (src1 != 0.0f)) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fpow(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = bit_size == 64 ? powf(src0, src1) : pow(src0, src1);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = bit_size == 64 ? powf(src0, src1) : pow(src0, src1);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fquantize2f16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = (fabs(src0) < ldexpf(1.0, -14)) ? copysignf(0.0f, src0) : _mesa_half_to_float(_mesa_float_to_half(src0));

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = (fabs(src0) < ldexpf(1.0, -14)) ? copysignf(0.0f, src0) : _mesa_half_to_float(_mesa_float_to_half(src0));

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_frcp(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? 1.0 / src0 : 1.0f / src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? 1.0 / src0 : 1.0f / src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_frem(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = src0 - src1 * truncf(src0 / src1);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = src0 - src1 * truncf(src0 / src1);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fround_even(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? _mesa_roundeven(src0) : _mesa_roundevenf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? _mesa_roundeven(src0) : _mesa_roundevenf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_frsq(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? 1.0 / sqrt(src0) : 1.0f / sqrtf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? 1.0 / sqrt(src0) : 1.0f / sqrtf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fsat(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? ((src0 > 1.0) ? 1.0 : ((src0 <= 0.0) ? 0.0 : src0)) : ((src0 > 1.0f) ? 1.0f : ((src0 <= 0.0f) ? 0.0f : src0));

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? ((src0 > 1.0) ? 1.0 : ((src0 <= 0.0) ? 0.0 : src0)) : ((src0 > 1.0f) ? 1.0f : ((src0 <= 0.0f) ? 0.0f : src0));

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fsign(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? ((src0 == 0.0) ? 0.0 : ((src0 > 0.0) ? 1.0 : -1.0)) : ((src0 == 0.0f) ? 0.0f : ((src0 > 0.0f) ? 1.0f : -1.0f));

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? ((src0 == 0.0) ? 0.0 : ((src0 > 0.0) ? 1.0 : -1.0)) : ((src0 == 0.0f) ? 0.0f : ((src0 > 0.0f) ? 1.0f : -1.0f));

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fsin(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? sin(src0) : sinf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? sin(src0) : sinf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fsqrt(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? sqrt(src0) : sqrtf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? sqrt(src0) : sqrtf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fsub(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = src0 - src1;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = src0 - src1;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ftrunc(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? trunc(src0) : truncf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? trunc(src0) : truncf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fxor(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 != 0.0f && src1 == 0.0f) || (src0 == 0.0f && src1 != 0.0f) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 != 0.0f && src1 == 0.0f) || (src0 == 0.0f && src1 != 0.0f) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_i2b(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               bool32_t dst = src0 != 0;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               bool32_t dst = src0 != 0;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_i2d(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               float64_t dst = src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               float64_t dst = src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_i2f(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               float32_t dst = src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               float32_t dst = src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_iabs(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst = (src0 < 0) ? -src0 : src0;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];

               int64_t dst = (src0 < 0) ? -src0 : src0;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_iadd(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src0 + src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src0 + src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_iand(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src0 & src1;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src0 & src1;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ibfe(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               int32_t dst;
               
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               int32_t dst;
               
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ibitfield_extract(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               int32_t dst;
               
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || offset + bits > 32) {
   dst = 0;
} else {
   dst = (base << (32 - offset - bits)) >> offset; /* use sign-extending shift */
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               int32_t dst;
               
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || offset + bits > 32) {
   dst = 0;
} else {
   dst = (base << (32 - offset - bits)) >> offset; /* use sign-extending shift */
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_idiv(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src0 / src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src0 / src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ieq(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               bool32_t dst = src0 == src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               bool32_t dst = src0 == src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ifind_msb(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst;
               
dst = -1;
for (int bit = 31; bit >= 0; bit--) {
   /* If src0 < 0, we're looking for the first 0 bit.
    * if src0 >= 0, we're looking for the first 1 bit.
    */
   if ((((src0 >> bit) & 1) && (src0 >= 0)) ||
      (!((src0 >> bit) & 1) && (src0 < 0))) {
      dst = bit;
      break;
   }
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst;
               
dst = -1;
for (int bit = 31; bit >= 0; bit--) {
   /* If src0 < 0, we're looking for the first 0 bit.
    * if src0 >= 0, we're looking for the first 1 bit.
    */
   if ((((src0 >> bit) & 1) && (src0 >= 0)) ||
      (!((src0 >> bit) & 1) && (src0 < 0))) {
      dst = bit;
      break;
   }
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ige(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               bool32_t dst = src0 >= src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               bool32_t dst = src0 >= src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ilt(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               bool32_t dst = src0 < src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               bool32_t dst = src0 < src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_imax(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src1 > src0 ? src1 : src0;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src1 > src0 ? src1 : src0;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_imin(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src1 > src0 ? src0 : src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src1 > src0 ? src0 : src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_imod(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src1 == 0 ? 0 : ((src0 % src1 == 0 || (src0 >= 0) == (src1 >= 0)) ?                 src0 % src1 : src0 % src1 + src1);

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src1 == 0 ? 0 : ((src0 % src1 == 0 || (src0 >= 0) == (src1 >= 0)) ?                 src0 % src1 : src0 % src1 + src1);

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_imov(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst = src0;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];

               int64_t dst = src0;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_imul(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src0 * src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src0 * src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_imul_high(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = (int32_t)(((int64_t) src0 * (int64_t) src1) >> 32);

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = (int32_t)(((int64_t) src0 * (int64_t) src1) >> 32);

               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ine(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               bool32_t dst = src0 != src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               bool32_t dst = src0 != src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ineg(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst = -src0;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];

               int64_t dst = -src0;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_inot(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst = ~src0;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];

               int64_t dst = ~src0;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ior(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src0 | src1;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src0 | src1;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_irem(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src1 == 0 ? 0 : src0 % src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src1 == 0 ? 0 : src0 % src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ishl(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src0 << src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src0 << src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ishr(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src0 >> src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src0 >> src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_isign(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst = (src0 == 0) ? 0 : ((src0 > 0) ? 1 : -1);

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];

               int64_t dst = (src0 == 0) ? 0 : ((src0 > 0) ? 1 : -1);

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_isub(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src0 - src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src0 - src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ixor(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src0 ^ src1;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src0 ^ src1;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ldexp(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               float32_t dst;
               
dst = (bit_size == 64) ? ldexp(src0, src1) : ldexpf(src0, src1);
/* flush denormals to zero. */
if (!isnormal(dst))
   dst = copysignf(0.0f, src0);


               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               float64_t dst;
               
dst = (bit_size == 64) ? ldexp(src0, src1) : ldexpf(src0, src1);
/* flush denormals to zero. */
if (!isnormal(dst))
   dst = copysignf(0.0f, src0);


               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_double_2x32(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
               _src[0].u32[1],
         };

         struct uint64_vec dst;

            dst.x = src0.x | ((uint64_t)src0.y << 32);

               _dst_val.u64[0] = dst.x;

      break;
   }
   case 64: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
               _src[0].u32[1],
         };

         struct uint64_vec dst;

            dst.x = src0.x | ((uint64_t)src0.y << 32);

               _dst_val.u64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_double_2x32_split(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint64_t dst = src0 | ((uint64_t)src1 << 32);

               _dst_val.u64[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint64_t dst = src0 | ((uint64_t)src1 << 32);

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_half_2x16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_half_1x16(src0.x);
dst.x |= ((uint32_t) pack_half_1x16(src0.y)) << 16;


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_half_1x16(src0.x);
dst.x |= ((uint32_t) pack_half_1x16(src0.y)) << 16;


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_half_2x16_split(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
         };

         struct uint32_vec dst;

            dst.x = dst.y = dst.z = dst.w = pack_half_1x16(src0.x) | (pack_half_1x16(src1.x) << 16);

               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
         };

         struct uint32_vec dst;

            dst.x = dst.y = dst.z = dst.w = pack_half_1x16(src0.x) | (pack_half_1x16(src1.x) << 16);

               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_snorm_2x16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_snorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x16(src0.y)) << 16;


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_snorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x16(src0.y)) << 16;


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_snorm_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_snorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.w)) << 24;


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_snorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.w)) << 24;


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_unorm_2x16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_unorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x16(src0.y)) << 16;


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_unorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x16(src0.y)) << 16;


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_unorm_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_unorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.w)) << 24;


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_unorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.w)) << 24;


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_uvec2_to_uint(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
               _src[0].u32[1],
         };

         struct uint32_vec dst;

            
dst.x = (src0.x & 0xffff) | (src0.y << 16);


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
               _src[0].u32[1],
         };

         struct uint32_vec dst;

            
dst.x = (src0.x & 0xffff) | (src0.y << 16);


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_uvec4_to_uint(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
               _src[0].u32[1],
               _src[0].u32[2],
               _src[0].u32[3],
         };

         struct uint32_vec dst;

            
dst.x = (src0.x <<  0) |
        (src0.y <<  8) |
        (src0.z << 16) |
        (src0.w << 24);


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
               _src[0].u32[1],
               _src[0].u32[2],
               _src[0].u32[3],
         };

         struct uint32_vec dst;

            
dst.x = (src0.x <<  0) |
        (src0.y <<  8) |
        (src0.z << 16) |
        (src0.w << 24);


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_seq(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 == src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 == src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_sge(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 >= src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 >= src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_slt(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 < src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 < src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_sne(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 != src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 != src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_u2d(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];

               float64_t dst = src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];

               float64_t dst = src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_u2f(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];

               float32_t dst = src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];

               float32_t dst = src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_uadd_carry(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src0 + src1 < src0;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src0 + src1 < src0;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ubfe(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               uint32_t dst;
               
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}


               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               uint32_t dst;
               
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}


               _dst_val.u32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ubitfield_extract(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               uint32_t dst;
               
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0 || offset + bits > 32) {
   dst = 0; /* undefined per the spec */
} else {
   dst = (base >> offset) & ((1ull << bits) - 1);
}


               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               uint32_t dst;
               
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0 || offset + bits > 32) {
   dst = 0; /* undefined per the spec */
} else {
   dst = (base >> offset) & ((1ull << bits) - 1);
}


               _dst_val.u32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_udiv(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src0 / src1;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src0 / src1;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ufind_msb(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];

               int32_t dst;
               
dst = -1;
for (int bit = 31; bit > 0; bit--) {
   if ((src0 >> bit) & 1) {
      dst = bit;
      break;
   }
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];

               int32_t dst;
               
dst = -1;
for (int bit = 31; bit > 0; bit--) {
   if ((src0 >> bit) & 1) {
      dst = bit;
      break;
   }
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_uge(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               bool32_t dst = src0 >= src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               bool32_t dst = src0 >= src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ult(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               bool32_t dst = src0 < src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               bool32_t dst = src0 < src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_umax(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src1 > src0 ? src1 : src0;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src1 > src0 ? src1 : src0;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_umax_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MAX2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MAX2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_umin(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src1 > src0 ? src0 : src1;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src1 > src0 ? src0 : src1;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_umin_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MIN2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      
d2496 2
a2497 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d2499 1
a2499 5
               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MIN2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
d2501 4
d2506 4
d2511 1
a2511 5
               _dst_val.i32[_i] = dst;
         }

      break;
   }
d2513 2
a2514 3
   default:
      unreachable("unknown bit width");
   }
d2519 1
a2519 2
evaluate_umod(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2521 5
a2525 1
   nir_const_value _dst_val = { {0, } };
d2527 1
a2527 3
   switch (bit_size) {
   case 32: {
      
d2529 2
a2530 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d2532 6
a2537 1
               uint32_t dst = src1 == 0 ? 0 : src0 % src1;
d2539 3
a2541 2
               _dst_val.u32[_i] = dst;
         }
d2543 1
a2543 4
      break;
   }
   case 64: {
      
d2545 2
a2546 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];
d2548 6
a2553 1
               uint64_t dst = src1 == 0 ? 0 : src0 % src1;
d2555 4
a2558 2
               _dst_val.u64[_i] = dst;
         }
d2560 1
a2560 2
      break;
   }
d2562 2
a2563 3
   default:
      unreachable("unknown bit width");
   }
d2568 1
a2568 2
evaluate_umul_high(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2570 1
a2570 1
   nir_const_value _dst_val = { {0, } };
d2572 6
a2577 3
   switch (bit_size) {
   case 32: {
      
d2579 2
a2580 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d2582 6
a2587 1
               uint32_t dst = (uint32_t)(((uint64_t) src0 * (uint64_t) src1) >> 32);
d2589 4
a2592 2
               _dst_val.u32[_i] = dst;
         }
d2594 1
a2594 4
      break;
   }
   case 64: {
      
d2596 2
a2597 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d2599 6
a2604 1
               uint32_t dst = (uint32_t)(((uint64_t) src0 * (uint64_t) src1) >> 32);
d2606 3
a2608 2
               _dst_val.u32[_i] = dst;
         }
d2610 1
a2610 2
      break;
   }
d2612 2
a2613 3
   default:
      unreachable("unknown bit width");
   }
d2618 1
a2618 2
evaluate_umul_unorm_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2620 1
a2620 1
   nir_const_value _dst_val = { {0, } };
d2622 6
a2627 3
   switch (bit_size) {
   case 32: {
      
d2629 2
a2630 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d2632 1
a2632 7
               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   dst |= ((src0_chan * src1_chan) / 255) << i;
d2634 4
d2639 4
d2644 1
a2644 2
               _dst_val.i32[_i] = dst;
         }
d2646 2
a2647 4
      break;
   }
   case 64: {
      
d2649 1
a2649 14
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   dst |= ((src0_chan * src1_chan) / 255) << i;
d2651 4
d2656 4
d2661 6
a2666 2
               _dst_val.i32[_i] = dst;
         }
a2667 2
      break;
   }
d2669 2
a2670 3
   default:
      unreachable("unknown bit width");
   }
d2675 1
a2675 2
evaluate_unpack_double_2x32(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2677 1
a2677 1
   nir_const_value _dst_val = { {0, } };
a2678 3
   switch (bit_size) {
   case 32: {
      
d2680 4
d2685 1
a2685 3
         struct uint64_vec src0 = {
               _src[0].u64[0],
         };
d2687 3
a2689 1
         struct uint32_vec dst;
a2690 1
            dst.x = src0.x; dst.y = src0.x >> 32;
d2692 1
a2692 2
               _dst_val.u32[0] = dst.x;
               _dst_val.u32[1] = dst.y;
d2694 6
a2699 4
      break;
   }
   case 64: {
      
d2702 3
a2704 3
         struct uint64_vec src0 = {
               _src[0].u64[0],
         };
d2706 3
a2708 1
         struct uint32_vec dst;
d2710 1
a2710 1
            dst.x = src0.x; dst.y = src0.x >> 32;
d2712 1
a2712 2
               _dst_val.u32[0] = dst.x;
               _dst_val.u32[1] = dst.y;
d2714 1
a2714 6
      break;
   }

   default:
      unreachable("unknown bit width");
   }
d2719 1
a2719 2
evaluate_unpack_double_2x32_split_x(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2721 1
a2721 1
   nir_const_value _dst_val = { {0, } };
a2722 3
   switch (bit_size) {
   case 32: {
      
d2724 11
a2734 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
d2736 1
a2736 1
               uint32_t dst = src0;
d2738 6
a2743 2
               _dst_val.u32[_i] = dst;
         }
a2744 4
      break;
   }
   case 64: {
      
d2746 6
a2751 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
d2753 1
a2753 1
               uint32_t dst = src0;
d2755 5
a2759 2
               _dst_val.u32[_i] = dst;
         }
a2760 2
      break;
   }
d2762 1
a2762 3
   default:
      unreachable("unknown bit width");
   }
d2767 1
a2767 2
evaluate_unpack_double_2x32_split_y(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2769 1
a2769 1
   nir_const_value _dst_val = { {0, } };
a2770 3
   switch (bit_size) {
   case 32: {
      
d2772 4
a2775 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
d2777 1
a2777 1
               uint32_t dst = src0 >> 32;
d2779 3
a2781 12
               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
a2782 7
               uint32_t dst = src0 >> 32;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
d2784 1
a2784 3
   default:
      unreachable("unknown bit width");
   }
d2789 1
a2789 2
evaluate_unpack_half_2x16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2791 1
a2791 1
   nir_const_value _dst_val = { {0, } };
a2792 3
   switch (bit_size) {
   case 32: {
      
d2794 6
d2801 1
a2801 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d2803 5
a2807 5
         struct float32_vec dst;

            
dst.x = unpack_half_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_half_1x16((uint16_t)(src0.x << 16));
d2810 1
a2810 7
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;

      break;
   }
   case 64: {
      
d2812 6
a2818 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d2820 4
a2823 5
         struct float32_vec dst;

            
dst.x = unpack_half_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_half_1x16((uint16_t)(src0.x << 16));
d2825 1
d2827 2
a2828 2
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
a2829 2
      break;
   }
d2831 1
a2831 3
   default:
      unreachable("unknown bit width");
   }
d2836 1
a2836 2
evaluate_unpack_half_2x16_split_x(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2838 1
a2838 1
   nir_const_value _dst_val = { {0, } };
a2839 3
   switch (bit_size) {
   case 32: {
      
d2841 6
d2848 1
a2848 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d2850 5
a2854 1
         struct float32_vec dst;
a2855 1
            dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x & 0xffff));
d2857 1
a2857 1
               _dst_val.f32[0] = dst.x;
d2859 6
a2864 4
      break;
   }
   case 64: {
      
d2866 4
d2871 1
a2871 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d2873 2
a2874 1
         struct float32_vec dst;
d2876 6
a2881 1
            dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x & 0xffff));
d2883 4
a2886 1
               _dst_val.f32[0] = dst.x;
d2888 1
a2888 2
      break;
   }
d2890 2
a2891 3
   default:
      unreachable("unknown bit width");
   }
d2896 1
a2896 2
evaluate_unpack_half_2x16_split_y(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2898 6
a2903 1
   nir_const_value _dst_val = { {0, } };
d2905 1
a2905 3
   switch (bit_size) {
   case 32: {
      
d2907 2
d2910 6
a2915 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d2917 4
a2920 1
         struct float32_vec dst;
d2922 1
a2922 1
            dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x >> 16));
d2924 2
a2925 1
               _dst_val.f32[0] = dst.x;
d2927 6
a2932 4
      break;
   }
   case 64: {
      
d2934 3
d2938 1
a2938 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d2940 2
a2941 1
         struct float32_vec dst;
d2943 6
a2948 1
            dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x >> 16));
d2950 4
a2953 1
               _dst_val.f32[0] = dst.x;
d2955 1
a2955 2
      break;
   }
d2957 2
a2958 3
   default:
      unreachable("unknown bit width");
   }
d2963 1
a2963 2
evaluate_unpack_snorm_2x16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2965 1
a2965 5
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      
d2967 5
d2973 1
a2973 6
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };

         struct float32_vec dst;

d2975 11
a2985 2
dst.x = unpack_snorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_snorm_1x16((uint16_t)(src0.x << 16));
d2988 2
a2989 2
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
d2991 6
a2996 4
      break;
   }
   case 64: {
      
d2998 5
d3004 11
a3014 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
a3015 1
         struct float32_vec dst;
d3017 2
a3018 3
            
dst.x = unpack_snorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_snorm_1x16((uint16_t)(src0.x << 16));
d3020 6
d3027 4
a3030 2
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
d3032 1
a3032 2
      break;
   }
d3034 2
a3035 3
   default:
      unreachable("unknown bit width");
   }
d3040 1
a3040 2
evaluate_unpack_snorm_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3042 1
a3042 6
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

d3044 3
a3046 5
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };

         struct float32_vec dst;
d3048 1
d3050 4
a3053 11
dst.x = unpack_snorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_snorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_snorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_snorm_1x8((uint8_t)(src0.x >> 24));


               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

d3056 1
a3056 2
   case 64: {
      
d3059 2
a3060 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d3062 6
a3067 7
         struct float32_vec dst;

            
dst.x = unpack_snorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_snorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_snorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_snorm_1x8((uint8_t)(src0.x >> 24));
d3069 4
d3074 1
a3074 4
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;
d3076 2
a3077 6
      break;
   }

   default:
      unreachable("unknown bit width");
   }
d3082 1
a3082 2
evaluate_unpack_unorm_2x16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3084 1
a3084 1
   nir_const_value _dst_val = { {0, } };
d3086 4
a3089 3
   switch (bit_size) {
   case 32: {
      
d3091 1
d3093 2
a3094 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d3096 6
a3101 1
         struct float32_vec dst;
d3103 4
a3106 3
            
dst.x = unpack_unorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_unorm_1x16((uint16_t)(src0.x << 16));
d3108 1
d3110 2
a3111 2
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
d3113 6
a3118 4
      break;
   }
   case 64: {
      
d3120 4
d3125 6
a3130 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
a3131 1
         struct float32_vec dst;
d3133 2
a3134 3
            
dst.x = unpack_unorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_unorm_1x16((uint16_t)(src0.x << 16));
d3136 6
d3143 4
a3146 2
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
d3148 1
a3148 2
      break;
   }
d3150 2
a3151 3
   default:
      unreachable("unknown bit width");
   }
d3156 1
a3156 2
evaluate_unpack_unorm_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3158 1
a3158 1
   nir_const_value _dst_val = { {0, } };
d3160 4
a3163 10
   switch (bit_size) {
   case 32: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
         };

         struct float32_vec dst;
d3165 1
d3167 4
a3170 4
dst.x = unpack_unorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_unorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_unorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_unorm_1x8((uint8_t)(src0.x >> 24));
d3173 2
a3174 4
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;
d3176 6
a3181 4
      break;
   }
   case 64: {
      
d3183 4
d3188 1
a3188 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d3190 2
a3191 1
         struct float32_vec dst;
d3193 6
a3198 5
            
dst.x = unpack_unorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_unorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_unorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_unorm_1x8((uint8_t)(src0.x >> 24));
d3200 4
d3205 1
a3205 7
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
d3207 2
a3208 3
   default:
      unreachable("unknown bit width");
   }
d3213 1
a3213 2
evaluate_usadd_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3215 1
a3215 1
   nir_const_value _dst_val = { {0, } };
d3217 4
a3220 3
   switch (bit_size) {
   case 32: {
      
d3222 2
a3223 9
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst;
               
d3226 3
a3228 1
   dst |= MIN2(((src0 >> i) & 0xff) + ((src1 >> i) & 0xff), 0xff) << i;
d3232 2
a3233 2
               _dst_val.i32[_i] = dst;
         }
d3235 6
a3240 4
      break;
   }
   case 64: {
      
a3241 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d3243 3
a3245 6
               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MIN2(((src0 >> i) & 0xff) + ((src1 >> i) & 0xff), 0xff) << i;
}
d3247 1
d3249 3
a3251 2
               _dst_val.i32[_i] = dst;
         }
a3252 2
      break;
   }
d3254 2
a3255 3
   default:
      unreachable("unknown bit width");
   }
d3260 1
a3260 2
evaluate_ushr(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3262 2
a3263 1
   nir_const_value _dst_val = { {0, } };
d3265 3
a3267 3
   switch (bit_size) {
   case 32: {
      
d3269 1
a3269 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d3271 1
a3271 1
               uint32_t dst = src0 >> src1;
d3273 1
a3273 2
               _dst_val.u32[_i] = dst;
         }
d3275 6
a3280 4
      break;
   }
   case 64: {
      
a3281 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];
d3283 3
a3285 1
               uint64_t dst = src0 >> src1;
d3287 1
a3287 2
               _dst_val.u64[_i] = dst;
         }
d3289 1
a3289 2
      break;
   }
d3291 1
a3291 3
   default:
      unreachable("unknown bit width");
   }
d3296 1
a3296 2
evaluate_ussub_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3298 2
a3299 1
   nir_const_value _dst_val = { {0, } };
d3301 3
a3303 3
   switch (bit_size) {
   case 32: {
      
d3305 1
a3305 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d3307 3
a3309 9
               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   if (src0_chan > src1_chan)
      dst |= (src0_chan - src1_chan) << i;
}
d3312 2
a3313 2
               _dst_val.i32[_i] = dst;
         }
d3315 6
a3320 4
      break;
   }
   case 64: {
      
a3321 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d3323 3
a3325 9
               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   if (src0_chan > src1_chan)
      dst |= (src0_chan - src1_chan) << i;
}
d3327 1
d3329 5
a3333 2
               _dst_val.i32[_i] = dst;
         }
a3334 2
      break;
   }
d3336 4
a3339 3
   default:
      unreachable("unknown bit width");
   }
d3344 1
a3344 2
evaluate_usub_borrow(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3346 1
a3346 1
   nir_const_value _dst_val = { {0, } };
a3347 3
   switch (bit_size) {
   case 32: {
      
d3349 3
a3351 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d3353 1
a3353 1
               uint32_t dst = src0 < src1;
d3355 3
a3357 7
               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      
a3358 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];
d3360 2
a3361 11
               uint64_t dst = src0 < src1;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }
d3366 1
a3366 2
evaluate_vec2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3368 1
a3368 1
   nir_const_value _dst_val = { {0, } };
a3369 3
   switch (bit_size) {
   case 32: {
      
d3371 3
d3375 1
a3375 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d3377 5
a3381 3
         struct uint32_vec src1 = {
               _src[1].u32[0],
         };
a3382 1
         struct uint32_vec dst;
d3384 4
a3387 3
            
dst.x = src0.x;
dst.y = src1.x;
d3389 6
d3396 4
a3399 2
               _dst_val.u32[0] = dst.x;
               _dst_val.u32[1] = dst.y;
d3401 6
a3406 4
      break;
   }
   case 64: {
      
d3409 2
a3410 3
         struct uint64_vec src0 = {
               _src[0].u64[0],
         };
d3412 6
a3417 3
         struct uint64_vec src1 = {
               _src[1].u64[0],
         };
d3419 4
a3422 9
         struct uint64_vec dst;

            
dst.x = src0.x;
dst.y = src1.x;


               _dst_val.u64[0] = dst.x;
               _dst_val.u64[1] = dst.y;
d3424 1
a3424 2
      break;
   }
d3426 2
a3427 3
   default:
      unreachable("unknown bit width");
   }
d3432 1
a3432 2
evaluate_vec3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3434 1
a3434 1
   nir_const_value _dst_val = { {0, } };
d3436 4
a3439 3
   switch (bit_size) {
   case 32: {
      
d3441 9
a3450 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d3452 2
a3453 3
         struct uint32_vec src1 = {
               _src[1].u32[0],
         };
d3455 6
a3460 3
         struct uint32_vec src2 = {
               _src[2].u32[0],
         };
d3462 4
a3465 6
         struct uint32_vec dst;

            
dst.x = src0.x;
dst.y = src1.x;
dst.z = src2.x;
d3467 1
d3469 2
a3470 3
               _dst_val.u32[0] = dst.x;
               _dst_val.u32[1] = dst.y;
               _dst_val.u32[2] = dst.z;
d3472 6
a3477 4
      break;
   }
   case 64: {
      
d3480 3
a3482 3
         struct uint64_vec src0 = {
               _src[0].u64[0],
         };
d3484 3
a3486 3
         struct uint64_vec src1 = {
               _src[1].u64[0],
         };
d3488 1
a3488 3
         struct uint64_vec src2 = {
               _src[2].u64[0],
         };
d3490 1
a3490 3
         struct uint64_vec dst;

            
a3492 2
dst.z = src2.x;

a3493 3
               _dst_val.u64[0] = dst.x;
               _dst_val.u64[1] = dst.y;
               _dst_val.u64[2] = dst.z;
d3495 2
a3496 6
      break;
   }

   default:
      unreachable("unknown bit width");
   }
d3501 1
a3501 2
evaluate_vec4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3503 1
a3503 1
   nir_const_value _dst_val = { {0, } };
a3504 3
   switch (bit_size) {
   case 32: {
      
d3506 3
d3510 3
a3512 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d3514 3
a3516 3
         struct uint32_vec src1 = {
               _src[1].u32[0],
         };
d3518 1
a3518 3
         struct uint32_vec src2 = {
               _src[2].u32[0],
         };
d3520 1
a3520 7
         struct uint32_vec src3 = {
               _src[3].u32[0],
         };

         struct uint32_vec dst;

            
a3523 1
dst.w = src3.x;
d3526 3
a3528 4
               _dst_val.u32[0] = dst.x;
               _dst_val.u32[1] = dst.y;
               _dst_val.u32[2] = dst.z;
               _dst_val.u32[3] = dst.w;
d3530 6
a3535 4
      break;
   }
   case 64: {
      
d3538 3
a3540 3
         struct uint64_vec src0 = {
               _src[0].u64[0],
         };
d3542 3
a3544 3
         struct uint64_vec src1 = {
               _src[1].u64[0],
         };
d3546 3
a3548 3
         struct uint64_vec src2 = {
               _src[2].u64[0],
         };
d3550 3
a3552 3
         struct uint64_vec src3 = {
               _src[3].u64[0],
         };
d3554 1
a3554 1
         struct uint64_vec dst;
d3556 1
a3556 1
            
d3563 4
a3566 11
               _dst_val.u64[0] = dst.x;
               _dst_val.u64[1] = dst.y;
               _dst_val.u64[2] = dst.z;
               _dst_val.u64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }
d3573 1
a3573 1
                      unsigned bit_width, nir_const_value *src)
d3577 1
a3577 1
      return evaluate_b2f(num_components, bit_width, src);
d3581 1
a3581 1
      return evaluate_b2i(num_components, bit_width, src);
d3585 1
a3585 1
      return evaluate_ball_fequal2(num_components, bit_width, src);
d3589 1
a3589 1
      return evaluate_ball_fequal3(num_components, bit_width, src);
d3593 1
a3593 1
      return evaluate_ball_fequal4(num_components, bit_width, src);
d3597 1
a3597 1
      return evaluate_ball_iequal2(num_components, bit_width, src);
d3601 1
a3601 1
      return evaluate_ball_iequal3(num_components, bit_width, src);
d3605 1
a3605 1
      return evaluate_ball_iequal4(num_components, bit_width, src);
d3609 1
a3609 1
      return evaluate_bany_fnequal2(num_components, bit_width, src);
d3613 1
a3613 1
      return evaluate_bany_fnequal3(num_components, bit_width, src);
d3617 1
a3617 1
      return evaluate_bany_fnequal4(num_components, bit_width, src);
d3621 1
a3621 1
      return evaluate_bany_inequal2(num_components, bit_width, src);
d3625 1
a3625 1
      return evaluate_bany_inequal3(num_components, bit_width, src);
d3629 1
a3629 1
      return evaluate_bany_inequal4(num_components, bit_width, src);
d3633 1
a3633 1
      return evaluate_bcsel(num_components, bit_width, src);
d3637 1
a3637 1
      return evaluate_bfi(num_components, bit_width, src);
d3641 1
a3641 1
      return evaluate_bfm(num_components, bit_width, src);
d3645 1
a3645 1
      return evaluate_bit_count(num_components, bit_width, src);
d3649 1
a3649 1
      return evaluate_bitfield_insert(num_components, bit_width, src);
d3653 1
a3653 17
      return evaluate_bitfield_reverse(num_components, bit_width, src);
      break;
   }
   case nir_op_d2b: {
      return evaluate_d2b(num_components, bit_width, src);
      break;
   }
   case nir_op_d2f: {
      return evaluate_d2f(num_components, bit_width, src);
      break;
   }
   case nir_op_d2i: {
      return evaluate_d2i(num_components, bit_width, src);
      break;
   }
   case nir_op_d2u: {
      return evaluate_d2u(num_components, bit_width, src);
d3657 1
a3657 1
      return evaluate_extract_i16(num_components, bit_width, src);
d3661 1
a3661 1
      return evaluate_extract_i8(num_components, bit_width, src);
d3665 1
a3665 1
      return evaluate_extract_u16(num_components, bit_width, src);
d3669 1
a3669 1
      return evaluate_extract_u8(num_components, bit_width, src);
d3673 1
a3673 5
      return evaluate_f2b(num_components, bit_width, src);
      break;
   }
   case nir_op_f2d: {
      return evaluate_f2d(num_components, bit_width, src);
d3677 1
a3677 1
      return evaluate_f2i(num_components, bit_width, src);
d3681 1
a3681 1
      return evaluate_f2u(num_components, bit_width, src);
d3685 1
a3685 1
      return evaluate_fabs(num_components, bit_width, src);
d3689 1
a3689 1
      return evaluate_fadd(num_components, bit_width, src);
d3693 1
a3693 1
      return evaluate_fall_equal2(num_components, bit_width, src);
d3697 1
a3697 1
      return evaluate_fall_equal3(num_components, bit_width, src);
d3701 1
a3701 1
      return evaluate_fall_equal4(num_components, bit_width, src);
d3705 1
a3705 1
      return evaluate_fand(num_components, bit_width, src);
d3709 1
a3709 1
      return evaluate_fany_nequal2(num_components, bit_width, src);
d3713 1
a3713 1
      return evaluate_fany_nequal3(num_components, bit_width, src);
d3717 1
a3717 1
      return evaluate_fany_nequal4(num_components, bit_width, src);
d3721 1
a3721 1
      return evaluate_fceil(num_components, bit_width, src);
d3725 1
a3725 1
      return evaluate_fcos(num_components, bit_width, src);
d3729 1
a3729 1
      return evaluate_fcsel(num_components, bit_width, src);
d3733 1
a3733 1
      return evaluate_fddx(num_components, bit_width, src);
d3737 1
a3737 1
      return evaluate_fddx_coarse(num_components, bit_width, src);
d3741 1
a3741 1
      return evaluate_fddx_fine(num_components, bit_width, src);
d3745 1
a3745 1
      return evaluate_fddy(num_components, bit_width, src);
d3749 1
a3749 1
      return evaluate_fddy_coarse(num_components, bit_width, src);
d3753 1
a3753 1
      return evaluate_fddy_fine(num_components, bit_width, src);
d3757 1
a3757 1
      return evaluate_fdiv(num_components, bit_width, src);
d3761 1
a3761 1
      return evaluate_fdot2(num_components, bit_width, src);
d3765 1
a3765 1
      return evaluate_fdot3(num_components, bit_width, src);
d3769 1
a3769 1
      return evaluate_fdot4(num_components, bit_width, src);
d3773 1
a3773 1
      return evaluate_fdot_replicated2(num_components, bit_width, src);
d3777 1
a3777 1
      return evaluate_fdot_replicated3(num_components, bit_width, src);
d3781 1
a3781 1
      return evaluate_fdot_replicated4(num_components, bit_width, src);
d3785 1
a3785 1
      return evaluate_fdph(num_components, bit_width, src);
d3789 1
a3789 1
      return evaluate_fdph_replicated(num_components, bit_width, src);
d3793 1
a3793 1
      return evaluate_feq(num_components, bit_width, src);
d3797 1
a3797 1
      return evaluate_fexp2(num_components, bit_width, src);
d3801 1
a3801 1
      return evaluate_ffloor(num_components, bit_width, src);
d3805 1
a3805 1
      return evaluate_ffma(num_components, bit_width, src);
d3809 1
a3809 1
      return evaluate_ffract(num_components, bit_width, src);
d3813 1
a3813 1
      return evaluate_fge(num_components, bit_width, src);
d3817 1
a3817 1
      return evaluate_find_lsb(num_components, bit_width, src);
d3821 1
a3821 1
      return evaluate_flog2(num_components, bit_width, src);
d3825 1
a3825 1
      return evaluate_flrp(num_components, bit_width, src);
d3829 1
a3829 1
      return evaluate_flt(num_components, bit_width, src);
d3833 1
a3833 1
      return evaluate_fmax(num_components, bit_width, src);
d3837 1
a3837 1
      return evaluate_fmin(num_components, bit_width, src);
d3841 1
a3841 1
      return evaluate_fmod(num_components, bit_width, src);
d3845 1
a3845 1
      return evaluate_fmov(num_components, bit_width, src);
d3849 1
a3849 1
      return evaluate_fmul(num_components, bit_width, src);
d3853 1
a3853 1
      return evaluate_fne(num_components, bit_width, src);
d3857 1
a3857 1
      return evaluate_fneg(num_components, bit_width, src);
d3861 1
a3861 1
      return evaluate_fnoise1_1(num_components, bit_width, src);
d3865 1
a3865 1
      return evaluate_fnoise1_2(num_components, bit_width, src);
d3869 1
a3869 1
      return evaluate_fnoise1_3(num_components, bit_width, src);
d3873 1
a3873 1
      return evaluate_fnoise1_4(num_components, bit_width, src);
d3877 1
a3877 1
      return evaluate_fnoise2_1(num_components, bit_width, src);
d3881 1
a3881 1
      return evaluate_fnoise2_2(num_components, bit_width, src);
d3885 1
a3885 1
      return evaluate_fnoise2_3(num_components, bit_width, src);
d3889 1
a3889 1
      return evaluate_fnoise2_4(num_components, bit_width, src);
d3893 1
a3893 1
      return evaluate_fnoise3_1(num_components, bit_width, src);
d3897 1
a3897 1
      return evaluate_fnoise3_2(num_components, bit_width, src);
d3901 1
a3901 1
      return evaluate_fnoise3_3(num_components, bit_width, src);
d3905 1
a3905 1
      return evaluate_fnoise3_4(num_components, bit_width, src);
d3909 1
a3909 1
      return evaluate_fnoise4_1(num_components, bit_width, src);
d3913 1
a3913 1
      return evaluate_fnoise4_2(num_components, bit_width, src);
d3917 1
a3917 1
      return evaluate_fnoise4_3(num_components, bit_width, src);
d3921 1
a3921 1
      return evaluate_fnoise4_4(num_components, bit_width, src);
d3925 1
a3925 1
      return evaluate_fnot(num_components, bit_width, src);
d3929 1
a3929 1
      return evaluate_for(num_components, bit_width, src);
d3933 1
a3933 5
      return evaluate_fpow(num_components, bit_width, src);
      break;
   }
   case nir_op_fquantize2f16: {
      return evaluate_fquantize2f16(num_components, bit_width, src);
d3937 1
a3937 5
      return evaluate_frcp(num_components, bit_width, src);
      break;
   }
   case nir_op_frem: {
      return evaluate_frem(num_components, bit_width, src);
d3941 1
a3941 1
      return evaluate_fround_even(num_components, bit_width, src);
d3945 1
a3945 1
      return evaluate_frsq(num_components, bit_width, src);
d3949 1
a3949 1
      return evaluate_fsat(num_components, bit_width, src);
d3953 1
a3953 1
      return evaluate_fsign(num_components, bit_width, src);
d3957 1
a3957 1
      return evaluate_fsin(num_components, bit_width, src);
d3961 1
a3961 1
      return evaluate_fsqrt(num_components, bit_width, src);
d3965 1
a3965 1
      return evaluate_fsub(num_components, bit_width, src);
d3969 1
a3969 1
      return evaluate_ftrunc(num_components, bit_width, src);
d3973 1
a3973 1
      return evaluate_fxor(num_components, bit_width, src);
d3977 1
a3977 5
      return evaluate_i2b(num_components, bit_width, src);
      break;
   }
   case nir_op_i2d: {
      return evaluate_i2d(num_components, bit_width, src);
d3981 1
a3981 1
      return evaluate_i2f(num_components, bit_width, src);
d3985 1
a3985 1
      return evaluate_iabs(num_components, bit_width, src);
d3989 1
a3989 1
      return evaluate_iadd(num_components, bit_width, src);
d3993 1
a3993 1
      return evaluate_iand(num_components, bit_width, src);
d3997 1
a3997 1
      return evaluate_ibfe(num_components, bit_width, src);
d4001 1
a4001 1
      return evaluate_ibitfield_extract(num_components, bit_width, src);
d4005 1
a4005 1
      return evaluate_idiv(num_components, bit_width, src);
d4009 1
a4009 1
      return evaluate_ieq(num_components, bit_width, src);
d4013 1
a4013 1
      return evaluate_ifind_msb(num_components, bit_width, src);
d4017 1
a4017 1
      return evaluate_ige(num_components, bit_width, src);
d4021 1
a4021 1
      return evaluate_ilt(num_components, bit_width, src);
d4025 1
a4025 1
      return evaluate_imax(num_components, bit_width, src);
d4029 1
a4029 5
      return evaluate_imin(num_components, bit_width, src);
      break;
   }
   case nir_op_imod: {
      return evaluate_imod(num_components, bit_width, src);
d4033 1
a4033 1
      return evaluate_imov(num_components, bit_width, src);
d4037 1
a4037 1
      return evaluate_imul(num_components, bit_width, src);
d4041 1
a4041 1
      return evaluate_imul_high(num_components, bit_width, src);
d4045 1
a4045 1
      return evaluate_ine(num_components, bit_width, src);
d4049 1
a4049 1
      return evaluate_ineg(num_components, bit_width, src);
d4053 1
a4053 1
      return evaluate_inot(num_components, bit_width, src);
d4057 1
a4057 5
      return evaluate_ior(num_components, bit_width, src);
      break;
   }
   case nir_op_irem: {
      return evaluate_irem(num_components, bit_width, src);
d4061 1
a4061 1
      return evaluate_ishl(num_components, bit_width, src);
d4065 1
a4065 1
      return evaluate_ishr(num_components, bit_width, src);
d4069 1
a4069 1
      return evaluate_isign(num_components, bit_width, src);
d4073 1
a4073 1
      return evaluate_isub(num_components, bit_width, src);
d4077 1
a4077 1
      return evaluate_ixor(num_components, bit_width, src);
d4081 1
a4081 9
      return evaluate_ldexp(num_components, bit_width, src);
      break;
   }
   case nir_op_pack_double_2x32: {
      return evaluate_pack_double_2x32(num_components, bit_width, src);
      break;
   }
   case nir_op_pack_double_2x32_split: {
      return evaluate_pack_double_2x32_split(num_components, bit_width, src);
d4085 1
a4085 1
      return evaluate_pack_half_2x16(num_components, bit_width, src);
d4089 1
a4089 1
      return evaluate_pack_half_2x16_split(num_components, bit_width, src);
d4093 1
a4093 1
      return evaluate_pack_snorm_2x16(num_components, bit_width, src);
d4097 1
a4097 1
      return evaluate_pack_snorm_4x8(num_components, bit_width, src);
d4101 1
a4101 1
      return evaluate_pack_unorm_2x16(num_components, bit_width, src);
d4105 1
a4105 1
      return evaluate_pack_unorm_4x8(num_components, bit_width, src);
d4109 1
a4109 1
      return evaluate_pack_uvec2_to_uint(num_components, bit_width, src);
d4113 1
a4113 1
      return evaluate_pack_uvec4_to_uint(num_components, bit_width, src);
d4117 1
a4117 1
      return evaluate_seq(num_components, bit_width, src);
d4121 1
a4121 1
      return evaluate_sge(num_components, bit_width, src);
d4125 1
a4125 1
      return evaluate_slt(num_components, bit_width, src);
d4129 1
a4129 5
      return evaluate_sne(num_components, bit_width, src);
      break;
   }
   case nir_op_u2d: {
      return evaluate_u2d(num_components, bit_width, src);
d4133 1
a4133 1
      return evaluate_u2f(num_components, bit_width, src);
d4137 1
a4137 1
      return evaluate_uadd_carry(num_components, bit_width, src);
d4141 1
a4141 1
      return evaluate_ubfe(num_components, bit_width, src);
d4145 1
a4145 1
      return evaluate_ubitfield_extract(num_components, bit_width, src);
d4149 1
a4149 1
      return evaluate_udiv(num_components, bit_width, src);
d4153 1
a4153 1
      return evaluate_ufind_msb(num_components, bit_width, src);
d4157 1
a4157 1
      return evaluate_uge(num_components, bit_width, src);
d4161 1
a4161 1
      return evaluate_ult(num_components, bit_width, src);
d4165 1
a4165 1
      return evaluate_umax(num_components, bit_width, src);
d4169 1
a4169 1
      return evaluate_umax_4x8(num_components, bit_width, src);
d4173 1
a4173 1
      return evaluate_umin(num_components, bit_width, src);
d4177 1
a4177 1
      return evaluate_umin_4x8(num_components, bit_width, src);
d4181 1
a4181 1
      return evaluate_umod(num_components, bit_width, src);
d4185 1
a4185 1
      return evaluate_umul_high(num_components, bit_width, src);
d4189 1
a4189 13
      return evaluate_umul_unorm_4x8(num_components, bit_width, src);
      break;
   }
   case nir_op_unpack_double_2x32: {
      return evaluate_unpack_double_2x32(num_components, bit_width, src);
      break;
   }
   case nir_op_unpack_double_2x32_split_x: {
      return evaluate_unpack_double_2x32_split_x(num_components, bit_width, src);
      break;
   }
   case nir_op_unpack_double_2x32_split_y: {
      return evaluate_unpack_double_2x32_split_y(num_components, bit_width, src);
d4193 1
a4193 1
      return evaluate_unpack_half_2x16(num_components, bit_width, src);
d4197 1
a4197 1
      return evaluate_unpack_half_2x16_split_x(num_components, bit_width, src);
d4201 1
a4201 1
      return evaluate_unpack_half_2x16_split_y(num_components, bit_width, src);
d4205 1
a4205 1
      return evaluate_unpack_snorm_2x16(num_components, bit_width, src);
d4209 1
a4209 1
      return evaluate_unpack_snorm_4x8(num_components, bit_width, src);
d4213 1
a4213 1
      return evaluate_unpack_unorm_2x16(num_components, bit_width, src);
d4217 1
a4217 1
      return evaluate_unpack_unorm_4x8(num_components, bit_width, src);
d4221 1
a4221 1
      return evaluate_usadd_4x8(num_components, bit_width, src);
d4225 1
a4225 1
      return evaluate_ushr(num_components, bit_width, src);
d4229 1
a4229 1
      return evaluate_ussub_4x8(num_components, bit_width, src);
d4233 1
a4233 1
      return evaluate_usub_borrow(num_components, bit_width, src);
d4237 1
a4237 1
      return evaluate_vec2(num_components, bit_width, src);
d4241 1
a4241 1
      return evaluate_vec3(num_components, bit_width, src);
d4245 1
a4245 1
      return evaluate_vec4(num_components, bit_width, src);
@

