head	1.1;
branch	1.1.1;
access;
symbols
	mesa-17_1_6:1.1.1.3
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	mesa-13_0_6:1.1.1.2
	mesa-13_0_5:1.1.1.2
	mesa-13_0_3:1.1.1.2
	mesa-13_0_2:1.1.1.2
	OPENBSD_6_0:1.1.1.1.0.4
	OPENBSD_6_0_BASE:1.1.1.1
	mesa-11_2_2:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2016.05.29.10.16.33;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.1
date	2016.05.29.10.16.33;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.2
date	2016.12.11.08.33.49;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	uuv5VTS15jglEDZU;

1.1.1.3
date	2017.08.14.09.38.35;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (C) 2014 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Jason Ekstrand (jason@@jlekstrand.net)
 */

#include <math.h>
#include "main/core.h"
#include "util/rounding.h" /* for _mesa_roundeven */
#include "util/half_float.h"
#include "nir_constant_expressions.h"

/**
 * Evaluate one component of packSnorm4x8.
 */
static uint8_t
pack_snorm_1x8(float x)
{
    /* From section 8.4 of the GLSL 4.30 spec:
     *
     *    packSnorm4x8
     *    ------------
     *    The conversion for component c of v to fixed point is done as
     *    follows:
     *
     *      packSnorm4x8: round(clamp(c, -1, +1) * 127.0)
     *
     * We must first cast the float to an int, because casting a negative
     * float to a uint is undefined.
     */
   return (uint8_t) (int)
          _mesa_roundevenf(CLAMP(x, -1.0f, +1.0f) * 127.0f);
}

/**
 * Evaluate one component of packSnorm2x16.
 */
static uint16_t
pack_snorm_1x16(float x)
{
    /* From section 8.4 of the GLSL ES 3.00 spec:
     *
     *    packSnorm2x16
     *    -------------
     *    The conversion for component c of v to fixed point is done as
     *    follows:
     *
     *      packSnorm2x16: round(clamp(c, -1, +1) * 32767.0)
     *
     * We must first cast the float to an int, because casting a negative
     * float to a uint is undefined.
     */
   return (uint16_t) (int)
          _mesa_roundevenf(CLAMP(x, -1.0f, +1.0f) * 32767.0f);
}

/**
 * Evaluate one component of unpackSnorm4x8.
 */
static float
unpack_snorm_1x8(uint8_t u)
{
    /* From section 8.4 of the GLSL 4.30 spec:
     *
     *    unpackSnorm4x8
     *    --------------
     *    The conversion for unpacked fixed-point value f to floating point is
     *    done as follows:
     *
     *       unpackSnorm4x8: clamp(f / 127.0, -1, +1)
     */
   return CLAMP((int8_t) u / 127.0f, -1.0f, +1.0f);
}

/**
 * Evaluate one component of unpackSnorm2x16.
 */
static float
unpack_snorm_1x16(uint16_t u)
{
    /* From section 8.4 of the GLSL ES 3.00 spec:
     *
     *    unpackSnorm2x16
     *    ---------------
     *    The conversion for unpacked fixed-point value f to floating point is
     *    done as follows:
     *
     *       unpackSnorm2x16: clamp(f / 32767.0, -1, +1)
     */
   return CLAMP((int16_t) u / 32767.0f, -1.0f, +1.0f);
}

/**
 * Evaluate one component packUnorm4x8.
 */
static uint8_t
pack_unorm_1x8(float x)
{
    /* From section 8.4 of the GLSL 4.30 spec:
     *
     *    packUnorm4x8
     *    ------------
     *    The conversion for component c of v to fixed point is done as
     *    follows:
     *
     *       packUnorm4x8: round(clamp(c, 0, +1) * 255.0)
     */
   return (uint8_t) (int)
          _mesa_roundevenf(CLAMP(x, 0.0f, 1.0f) * 255.0f);
}

/**
 * Evaluate one component packUnorm2x16.
 */
static uint16_t
pack_unorm_1x16(float x)
{
    /* From section 8.4 of the GLSL ES 3.00 spec:
     *
     *    packUnorm2x16
     *    -------------
     *    The conversion for component c of v to fixed point is done as
     *    follows:
     *
     *       packUnorm2x16: round(clamp(c, 0, +1) * 65535.0)
     */
   return (uint16_t) (int)
          _mesa_roundevenf(CLAMP(x, 0.0f, 1.0f) * 65535.0f);
}

/**
 * Evaluate one component of unpackUnorm4x8.
 */
static float
unpack_unorm_1x8(uint8_t u)
{
    /* From section 8.4 of the GLSL 4.30 spec:
     *
     *    unpackUnorm4x8
     *    --------------
     *    The conversion for unpacked fixed-point value f to floating point is
     *    done as follows:
     *
     *       unpackUnorm4x8: f / 255.0
     */
   return (float) u / 255.0f;
}

/**
 * Evaluate one component of unpackUnorm2x16.
 */
static float
unpack_unorm_1x16(uint16_t u)
{
    /* From section 8.4 of the GLSL ES 3.00 spec:
     *
     *    unpackUnorm2x16
     *    ---------------
     *    The conversion for unpacked fixed-point value f to floating point is
     *    done as follows:
     *
     *       unpackUnorm2x16: f / 65535.0
     */
   return (float) u / 65535.0f;
}

/**
 * Evaluate one component of packHalf2x16.
 */
static uint16_t
pack_half_1x16(float x)
{
   return _mesa_float_to_half(x);
}

/**
 * Evaluate one component of unpackHalf2x16.
 */
static float
unpack_half_1x16(uint16_t u)
{
   return _mesa_half_to_float(u);
}

/* Some typed vector structures to make things like src0.y work */
struct float_vec {
   float x;
   float y;
   float z;
   float w;
};
struct int_vec {
   int x;
   int y;
   int z;
   int w;
};
struct uint_vec {
   uint x;
   uint y;
   uint z;
   uint w;
};
struct bool_vec {
   bool x;
   bool y;
   bool z;
   bool w;
};

static nir_const_value
evaluate_b2f(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               bool src0 = _src[0].u[_i] != 0;

            float dst = src0 ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_b2i(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               bool src0 = _src[0].u[_i] != 0;

            int dst = src0 ? 1 : 0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ball_fequal2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_ball_fequal3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_ball_fequal4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_ball_iequal2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct int_vec src0 = {
            _src[0].i[0],
            _src[0].i[1],
      };

      struct int_vec src1 = {
            _src[1].i[0],
            _src[1].i[1],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_ball_iequal3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct int_vec src0 = {
            _src[0].i[0],
            _src[0].i[1],
            _src[0].i[2],
      };

      struct int_vec src1 = {
            _src[1].i[0],
            _src[1].i[1],
            _src[1].i[2],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_ball_iequal4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct int_vec src0 = {
            _src[0].i[0],
            _src[0].i[1],
            _src[0].i[2],
            _src[0].i[3],
      };

      struct int_vec src1 = {
            _src[1].i[0],
            _src[1].i[1],
            _src[1].i[2],
            _src[1].i[3],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bany_fnequal2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bany_fnequal3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bany_fnequal4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bany_inequal2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct int_vec src0 = {
            _src[0].i[0],
            _src[0].i[1],
      };

      struct int_vec src1 = {
            _src[1].i[0],
            _src[1].i[1],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bany_inequal3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct int_vec src0 = {
            _src[0].i[0],
            _src[0].i[1],
            _src[0].i[2],
      };

      struct int_vec src1 = {
            _src[1].i[0],
            _src[1].i[1],
            _src[1].i[2],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bany_inequal4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct int_vec src0 = {
            _src[0].i[0],
            _src[0].i[1],
            _src[0].i[2],
            _src[0].i[3],
      };

      struct int_vec src1 = {
            _src[1].i[0],
            _src[1].i[1],
            _src[1].i[2],
            _src[1].i[3],
      };

      struct bool_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));

            _dst_val.u[0] = dst.x ? NIR_TRUE : NIR_FALSE;

   return _dst_val;
}
static nir_const_value
evaluate_bcsel(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               bool src0 = _src[0].u[_i] != 0;
               uint src1 = _src[1].u[_i];
               uint src2 = _src[2].u[_i];

            uint dst = src0 ? src1 : src2;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_bfi(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];
               uint src2 = _src[2].u[_i];

            uint dst;
            
unsigned mask = src0, insert = src1, base = src2;
if (mask == 0) {
   dst = base;
} else {
   unsigned tmp = mask;
   while (!(tmp & 1)) {
      tmp >>= 1;
      insert <<= 1;
   }
   dst = (base & ~mask) | (insert & mask);
}


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_bfm(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            uint dst;
            
int bits = src0, offset = src1;
if (offset < 0 || bits < 0 || offset > 31 || bits > 31 || offset + bits > 32)
   dst = 0; /* undefined */
else
   dst = ((1u << bits) - 1) << offset;


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_bit_count(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];

            uint dst;
            
dst = 0;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1)
      dst++;
}


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_bitfield_insert(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                                    
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];
               int src2 = _src[2].i[_i];
               int src3 = _src[3].i[_i];

            uint dst;
            
unsigned base = src0, insert = src1;
int offset = src2, bits = src3;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || bits + offset > 32) {
   dst = 0;
} else {
   unsigned mask = ((1ull << bits) - 1) << offset;
   dst = (base & ~mask) | ((insert << bits) & mask);
}


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_bitfield_reverse(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];

            uint dst;
            
/* we're not winning any awards for speed here, but that's ok */
dst = 0;
for (unsigned bit = 0; bit < 32; bit++)
   dst |= ((src0 >> bit) & 1) << (31 - bit);


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_extract_i16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = (int16_t)(src0 >> (src1 * 16));

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_extract_i8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = (int8_t)(src0 >> (src1 * 8));

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_extract_u16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = (uint16_t)(src0 >> (src1 * 16));

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_extract_u8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = (uint8_t)(src0 >> (src1 * 8));

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_f2b(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            bool dst = src0 != 0.0f;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_f2i(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            int dst = src0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_f2u(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            uint dst = src0;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fabs(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = fabsf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fadd(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = src0 + src1;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fall_equal2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y)) ? 1.0f : 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fall_equal3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z)) ? 1.0f : 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fall_equal4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w)) ? 1.0f : 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fand(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = ((src0 != 0.0f) && (src1 != 0.0f)) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fany_nequal2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y)) ? 1.0f : 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fany_nequal3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z)) ? 1.0f : 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fany_nequal4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w)) ? 1.0f : 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fceil(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = ceilf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fcos(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = cosf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fcsel(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];
               float src2 = _src[2].f[_i];

            float dst = (src0 != 0.0f) ? src1 : src2;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fddx(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float dst = 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fddx_coarse(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float dst = 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fddx_fine(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float dst = 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fddy(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float dst = 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fddy_coarse(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float dst = 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fddy_fine(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float dst = 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fdiv(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = src0 / src1;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fdot2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fdot3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fdot4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fdot_replicated2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fdot_replicated3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fdot_replicated4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fdph(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fdph_replicated(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
      };

      struct float_vec src1 = {
            _src[1].f[0],
            _src[1].f[1],
            _src[1].f[2],
            _src[1].f[3],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_feq(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            bool dst = src0 == src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fexp2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = exp2f(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ffloor(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = floorf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ffma(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];
               float src2 = _src[2].f[_i];

            float dst = src0 * src1 + src2;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ffract(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = src0 - floorf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fge(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            bool dst = src0 >= src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_find_lsb(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst;
            
dst = -1;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1) {
      dst = bit;
      break;
   }
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_flog2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = log2f(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_flrp(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];
               float src2 = _src[2].f[_i];

            float dst = src0 * (1 - src2) + src1 * src2;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_flt(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            bool dst = src0 < src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fmax(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = fmaxf(src0, src1);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fmin(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = fminf(src0, src1);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fmod(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = src0 - src1 * floorf(src0 / src1);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fmov(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = src0;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fmul(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = src0 * src1;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fne(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            bool dst = src0 != src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fneg(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = -src0;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_1(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_1(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_1(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_1(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_fnot(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = (src0 == 0.0f) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_for(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = ((src0 != 0.0f) || (src1 != 0.0f)) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fpow(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = powf(src0, src1);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_frcp(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = 1.0f / src0;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fround_even(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = _mesa_roundevenf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_frsq(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = 1.0f / sqrtf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fsat(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = (src0 > 1.0f) ? 1.0f : ((src0 <= 0.0f) ? 0.0f : src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fsign(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = (src0 == 0.0f) ? 0.0f : ((src0 > 0.0f) ? 1.0f : -1.0f);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fsin(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = sinf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fsqrt(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = sqrtf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fsub(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = src0 - src1;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ftrunc(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];

            float dst = truncf(src0);

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_fxor(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = (src0 != 0.0f && src1 == 0.0f) || (src0 == 0.0f && src1 != 0.0f) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_i2b(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            bool dst = src0 != 0;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_i2f(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            float dst = src0;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_iabs(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst = (src0 < 0) ? -src0 : src0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_iadd(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src0 + src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_iand(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 & src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ibfe(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];
               int src2 = _src[2].i[_i];

            int dst;
            
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ibitfield_extract(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];
               int src2 = _src[2].i[_i];

            int dst;
            
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || offset + bits > 32) {
   dst = 0;
} else {
   dst = (base << (32 - offset - bits)) >> offset; /* use sign-extending shift */
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_idiv(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src0 / src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ieq(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            bool dst = src0 == src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ifind_msb(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst;
            
dst = -1;
for (int bit = 31; bit >= 0; bit--) {
   /* If src0 < 0, we're looking for the first 0 bit.
    * if src0 >= 0, we're looking for the first 1 bit.
    */
   if ((((src0 >> bit) & 1) && (src0 >= 0)) ||
      (!((src0 >> bit) & 1) && (src0 < 0))) {
      dst = bit;
      break;
   }
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ige(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            bool dst = src0 >= src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ilt(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            bool dst = src0 < src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_imax(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src1 > src0 ? src1 : src0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_imin(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src1 > src0 ? src0 : src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_imov(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst = src0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_imul(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src0 * src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_imul_high(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = (int32_t)(((int64_t) src0 * (int64_t) src1) >> 32);

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ine(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            bool dst = src0 != src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ineg(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst = -src0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_inot(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst = ~src0;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ior(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 | src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ishl(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src0 << src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ishr(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src0 >> src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_isign(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];

            int dst = (src0 == 0) ? 0 : ((src0 > 0) ? 1 : -1);

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_isub(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst = src0 - src1;

            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ixor(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 ^ src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ldexp(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               int src1 = _src[1].i[_i];

            float dst;
            
dst = ldexpf(src0, src1);
/* flush denormals to zero. */
if (!isnormal(dst))
   dst = copysignf(0.0f, src0);


            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_pack_half_2x16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct uint_vec dst;

         
dst.x = (uint32_t) pack_half_1x16(src0.x);
dst.x |= ((uint32_t) pack_half_1x16(src0.y)) << 16;


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_half_2x16_split(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
      };

      struct float_vec src1 = {
            _src[1].f[0],
      };

      struct uint_vec dst;

         dst.x = dst.y = dst.z = dst.w = pack_half_1x16(src0.x) | (pack_half_1x16(src1.x) << 16);

            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_snorm_2x16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct uint_vec dst;

         
dst.x = (uint32_t) pack_snorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x16(src0.y)) << 16;


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_snorm_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct uint_vec dst;

         
dst.x = (uint32_t) pack_snorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.w)) << 24;


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_unorm_2x16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
      };

      struct uint_vec dst;

         
dst.x = (uint32_t) pack_unorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x16(src0.y)) << 16;


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_unorm_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct float_vec src0 = {
            _src[0].f[0],
            _src[0].f[1],
            _src[0].f[2],
            _src[0].f[3],
      };

      struct uint_vec dst;

         
dst.x = (uint32_t) pack_unorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.w)) << 24;


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_uvec2_to_uint(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
            _src[0].u[1],
      };

      struct uint_vec dst;

         
dst.x = (src0.x & 0xffff) | (src0.y >> 16);


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_pack_uvec4_to_uint(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
            _src[0].u[1],
            _src[0].u[2],
            _src[0].u[3],
      };

      struct uint_vec dst;

         
dst.x = (src0.x <<  0) |
        (src0.y <<  8) |
        (src0.z << 16) |
        (src0.w << 24);


            _dst_val.u[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_seq(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = (src0 == src1) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_sge(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = (src0 >= src1) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_slt(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = (src0 < src1) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_sne(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               float src0 = _src[0].f[_i];
               float src1 = _src[1].f[_i];

            float dst = (src0 != src1) ? 1.0f : 0.0f;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_u2f(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];

            float dst = src0;

            _dst_val.f[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_uadd_carry(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 + src1 < src0;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ubfe(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               int src1 = _src[1].i[_i];
               int src2 = _src[2].i[_i];

            uint dst;
            
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ubitfield_extract(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               int src1 = _src[1].i[_i];
               int src2 = _src[2].i[_i];

            uint dst;
            
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0 || offset + bits > 32) {
   dst = 0; /* undefined per the spec */
} else {
   dst = (base >> offset) & ((1ull << bits) - 1);
}


            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_udiv(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 / src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ufind_msb(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];

            int dst;
            
dst = -1;
for (int bit = 31; bit > 0; bit--) {
   if ((src0 >> bit) & 1) {
      dst = bit;
      break;
   }
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_uge(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            bool dst = src0 >= src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ult(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            bool dst = src0 < src1;

            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umax(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src1 > src0 ? src1 : src0;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umax_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst;
            
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MAX2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umin(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src1 > src0 ? src0 : src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umin_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst;
            
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MIN2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umod(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src1 == 0 ? 0 : src0 % src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umul_high(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = (uint32_t)(((uint64_t) src0 * (uint64_t) src1) >> 32);

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_umul_unorm_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst;
            
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   dst |= ((src0_chan * src1_chan) / 255) << i;
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_unpack_half_2x16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         
dst.x = unpack_half_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_half_1x16((uint16_t)(src0.x << 16));


            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_unpack_half_2x16_split_x(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x & 0xffff));

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_unpack_half_2x16_split_y(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x >> 16));

            _dst_val.f[0] = dst.x;

   return _dst_val;
}
static nir_const_value
evaluate_unpack_snorm_2x16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         
dst.x = unpack_snorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_snorm_1x16((uint16_t)(src0.x << 16));


            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_unpack_snorm_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         
dst.x = unpack_snorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_snorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_snorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_snorm_1x8((uint8_t)(src0.x >> 24));


            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_unpack_unorm_2x16(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         
dst.x = unpack_unorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_unorm_1x16((uint16_t)(src0.x << 16));


            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_unpack_unorm_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct float_vec dst;

         
dst.x = unpack_unorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_unorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_unorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_unorm_1x8((uint8_t)(src0.x >> 24));


            _dst_val.f[0] = dst.x;
            _dst_val.f[1] = dst.y;
            _dst_val.f[2] = dst.z;
            _dst_val.f[3] = dst.w;

   return _dst_val;
}
static nir_const_value
evaluate_usadd_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst;
            
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MIN2(((src0 >> i) & 0xff) + ((src1 >> i) & 0xff), 0xff) << i;
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ushr(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 >> src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_ussub_4x8(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               int src0 = _src[0].i[_i];
               int src1 = _src[1].i[_i];

            int dst;
            
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   if (src0_chan > src1_chan)
      dst |= (src0_chan - src1_chan) << i;
}


            _dst_val.i[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_usub_borrow(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               uint src0 = _src[0].u[_i];
               uint src1 = _src[1].u[_i];

            uint dst = src0 < src1;

            _dst_val.u[_i] = dst;
      }

   return _dst_val;
}
static nir_const_value
evaluate_vec2(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct uint_vec src1 = {
            _src[1].u[0],
      };

      struct uint_vec dst;

         
dst.x = src0.x;
dst.y = src1.x;


            _dst_val.u[0] = dst.x;
            _dst_val.u[1] = dst.y;

   return _dst_val;
}
static nir_const_value
evaluate_vec3(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct uint_vec src1 = {
            _src[1].u[0],
      };

      struct uint_vec src2 = {
            _src[2].u[0],
      };

      struct uint_vec dst;

         
dst.x = src0.x;
dst.y = src1.x;
dst.z = src2.x;


            _dst_val.u[0] = dst.x;
            _dst_val.u[1] = dst.y;
            _dst_val.u[2] = dst.z;

   return _dst_val;
}
static nir_const_value
evaluate_vec4(unsigned num_components, nir_const_value *_src)
{
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };


      struct uint_vec src0 = {
            _src[0].u[0],
      };

      struct uint_vec src1 = {
            _src[1].u[0],
      };

      struct uint_vec src2 = {
            _src[2].u[0],
      };

      struct uint_vec src3 = {
            _src[3].u[0],
      };

      struct uint_vec dst;

         
dst.x = src0.x;
dst.y = src1.x;
dst.z = src2.x;
dst.w = src3.x;


            _dst_val.u[0] = dst.x;
            _dst_val.u[1] = dst.y;
            _dst_val.u[2] = dst.z;
            _dst_val.u[3] = dst.w;

   return _dst_val;
}

nir_const_value
nir_eval_const_opcode(nir_op op, unsigned num_components,
                      nir_const_value *src)
{
   switch (op) {
   case nir_op_b2f: {
      return evaluate_b2f(num_components, src);
      break;
   }
   case nir_op_b2i: {
      return evaluate_b2i(num_components, src);
      break;
   }
   case nir_op_ball_fequal2: {
      return evaluate_ball_fequal2(num_components, src);
      break;
   }
   case nir_op_ball_fequal3: {
      return evaluate_ball_fequal3(num_components, src);
      break;
   }
   case nir_op_ball_fequal4: {
      return evaluate_ball_fequal4(num_components, src);
      break;
   }
   case nir_op_ball_iequal2: {
      return evaluate_ball_iequal2(num_components, src);
      break;
   }
   case nir_op_ball_iequal3: {
      return evaluate_ball_iequal3(num_components, src);
      break;
   }
   case nir_op_ball_iequal4: {
      return evaluate_ball_iequal4(num_components, src);
      break;
   }
   case nir_op_bany_fnequal2: {
      return evaluate_bany_fnequal2(num_components, src);
      break;
   }
   case nir_op_bany_fnequal3: {
      return evaluate_bany_fnequal3(num_components, src);
      break;
   }
   case nir_op_bany_fnequal4: {
      return evaluate_bany_fnequal4(num_components, src);
      break;
   }
   case nir_op_bany_inequal2: {
      return evaluate_bany_inequal2(num_components, src);
      break;
   }
   case nir_op_bany_inequal3: {
      return evaluate_bany_inequal3(num_components, src);
      break;
   }
   case nir_op_bany_inequal4: {
      return evaluate_bany_inequal4(num_components, src);
      break;
   }
   case nir_op_bcsel: {
      return evaluate_bcsel(num_components, src);
      break;
   }
   case nir_op_bfi: {
      return evaluate_bfi(num_components, src);
      break;
   }
   case nir_op_bfm: {
      return evaluate_bfm(num_components, src);
      break;
   }
   case nir_op_bit_count: {
      return evaluate_bit_count(num_components, src);
      break;
   }
   case nir_op_bitfield_insert: {
      return evaluate_bitfield_insert(num_components, src);
      break;
   }
   case nir_op_bitfield_reverse: {
      return evaluate_bitfield_reverse(num_components, src);
      break;
   }
   case nir_op_extract_i16: {
      return evaluate_extract_i16(num_components, src);
      break;
   }
   case nir_op_extract_i8: {
      return evaluate_extract_i8(num_components, src);
      break;
   }
   case nir_op_extract_u16: {
      return evaluate_extract_u16(num_components, src);
      break;
   }
   case nir_op_extract_u8: {
      return evaluate_extract_u8(num_components, src);
      break;
   }
   case nir_op_f2b: {
      return evaluate_f2b(num_components, src);
      break;
   }
   case nir_op_f2i: {
      return evaluate_f2i(num_components, src);
      break;
   }
   case nir_op_f2u: {
      return evaluate_f2u(num_components, src);
      break;
   }
   case nir_op_fabs: {
      return evaluate_fabs(num_components, src);
      break;
   }
   case nir_op_fadd: {
      return evaluate_fadd(num_components, src);
      break;
   }
   case nir_op_fall_equal2: {
      return evaluate_fall_equal2(num_components, src);
      break;
   }
   case nir_op_fall_equal3: {
      return evaluate_fall_equal3(num_components, src);
      break;
   }
   case nir_op_fall_equal4: {
      return evaluate_fall_equal4(num_components, src);
      break;
   }
   case nir_op_fand: {
      return evaluate_fand(num_components, src);
      break;
   }
   case nir_op_fany_nequal2: {
      return evaluate_fany_nequal2(num_components, src);
      break;
   }
   case nir_op_fany_nequal3: {
      return evaluate_fany_nequal3(num_components, src);
      break;
   }
   case nir_op_fany_nequal4: {
      return evaluate_fany_nequal4(num_components, src);
      break;
   }
   case nir_op_fceil: {
      return evaluate_fceil(num_components, src);
      break;
   }
   case nir_op_fcos: {
      return evaluate_fcos(num_components, src);
      break;
   }
   case nir_op_fcsel: {
      return evaluate_fcsel(num_components, src);
      break;
   }
   case nir_op_fddx: {
      return evaluate_fddx(num_components, src);
      break;
   }
   case nir_op_fddx_coarse: {
      return evaluate_fddx_coarse(num_components, src);
      break;
   }
   case nir_op_fddx_fine: {
      return evaluate_fddx_fine(num_components, src);
      break;
   }
   case nir_op_fddy: {
      return evaluate_fddy(num_components, src);
      break;
   }
   case nir_op_fddy_coarse: {
      return evaluate_fddy_coarse(num_components, src);
      break;
   }
   case nir_op_fddy_fine: {
      return evaluate_fddy_fine(num_components, src);
      break;
   }
   case nir_op_fdiv: {
      return evaluate_fdiv(num_components, src);
      break;
   }
   case nir_op_fdot2: {
      return evaluate_fdot2(num_components, src);
      break;
   }
   case nir_op_fdot3: {
      return evaluate_fdot3(num_components, src);
      break;
   }
   case nir_op_fdot4: {
      return evaluate_fdot4(num_components, src);
      break;
   }
   case nir_op_fdot_replicated2: {
      return evaluate_fdot_replicated2(num_components, src);
      break;
   }
   case nir_op_fdot_replicated3: {
      return evaluate_fdot_replicated3(num_components, src);
      break;
   }
   case nir_op_fdot_replicated4: {
      return evaluate_fdot_replicated4(num_components, src);
      break;
   }
   case nir_op_fdph: {
      return evaluate_fdph(num_components, src);
      break;
   }
   case nir_op_fdph_replicated: {
      return evaluate_fdph_replicated(num_components, src);
      break;
   }
   case nir_op_feq: {
      return evaluate_feq(num_components, src);
      break;
   }
   case nir_op_fexp2: {
      return evaluate_fexp2(num_components, src);
      break;
   }
   case nir_op_ffloor: {
      return evaluate_ffloor(num_components, src);
      break;
   }
   case nir_op_ffma: {
      return evaluate_ffma(num_components, src);
      break;
   }
   case nir_op_ffract: {
      return evaluate_ffract(num_components, src);
      break;
   }
   case nir_op_fge: {
      return evaluate_fge(num_components, src);
      break;
   }
   case nir_op_find_lsb: {
      return evaluate_find_lsb(num_components, src);
      break;
   }
   case nir_op_flog2: {
      return evaluate_flog2(num_components, src);
      break;
   }
   case nir_op_flrp: {
      return evaluate_flrp(num_components, src);
      break;
   }
   case nir_op_flt: {
      return evaluate_flt(num_components, src);
      break;
   }
   case nir_op_fmax: {
      return evaluate_fmax(num_components, src);
      break;
   }
   case nir_op_fmin: {
      return evaluate_fmin(num_components, src);
      break;
   }
   case nir_op_fmod: {
      return evaluate_fmod(num_components, src);
      break;
   }
   case nir_op_fmov: {
      return evaluate_fmov(num_components, src);
      break;
   }
   case nir_op_fmul: {
      return evaluate_fmul(num_components, src);
      break;
   }
   case nir_op_fne: {
      return evaluate_fne(num_components, src);
      break;
   }
   case nir_op_fneg: {
      return evaluate_fneg(num_components, src);
      break;
   }
   case nir_op_fnoise1_1: {
      return evaluate_fnoise1_1(num_components, src);
      break;
   }
   case nir_op_fnoise1_2: {
      return evaluate_fnoise1_2(num_components, src);
      break;
   }
   case nir_op_fnoise1_3: {
      return evaluate_fnoise1_3(num_components, src);
      break;
   }
   case nir_op_fnoise1_4: {
      return evaluate_fnoise1_4(num_components, src);
      break;
   }
   case nir_op_fnoise2_1: {
      return evaluate_fnoise2_1(num_components, src);
      break;
   }
   case nir_op_fnoise2_2: {
      return evaluate_fnoise2_2(num_components, src);
      break;
   }
   case nir_op_fnoise2_3: {
      return evaluate_fnoise2_3(num_components, src);
      break;
   }
   case nir_op_fnoise2_4: {
      return evaluate_fnoise2_4(num_components, src);
      break;
   }
   case nir_op_fnoise3_1: {
      return evaluate_fnoise3_1(num_components, src);
      break;
   }
   case nir_op_fnoise3_2: {
      return evaluate_fnoise3_2(num_components, src);
      break;
   }
   case nir_op_fnoise3_3: {
      return evaluate_fnoise3_3(num_components, src);
      break;
   }
   case nir_op_fnoise3_4: {
      return evaluate_fnoise3_4(num_components, src);
      break;
   }
   case nir_op_fnoise4_1: {
      return evaluate_fnoise4_1(num_components, src);
      break;
   }
   case nir_op_fnoise4_2: {
      return evaluate_fnoise4_2(num_components, src);
      break;
   }
   case nir_op_fnoise4_3: {
      return evaluate_fnoise4_3(num_components, src);
      break;
   }
   case nir_op_fnoise4_4: {
      return evaluate_fnoise4_4(num_components, src);
      break;
   }
   case nir_op_fnot: {
      return evaluate_fnot(num_components, src);
      break;
   }
   case nir_op_for: {
      return evaluate_for(num_components, src);
      break;
   }
   case nir_op_fpow: {
      return evaluate_fpow(num_components, src);
      break;
   }
   case nir_op_frcp: {
      return evaluate_frcp(num_components, src);
      break;
   }
   case nir_op_fround_even: {
      return evaluate_fround_even(num_components, src);
      break;
   }
   case nir_op_frsq: {
      return evaluate_frsq(num_components, src);
      break;
   }
   case nir_op_fsat: {
      return evaluate_fsat(num_components, src);
      break;
   }
   case nir_op_fsign: {
      return evaluate_fsign(num_components, src);
      break;
   }
   case nir_op_fsin: {
      return evaluate_fsin(num_components, src);
      break;
   }
   case nir_op_fsqrt: {
      return evaluate_fsqrt(num_components, src);
      break;
   }
   case nir_op_fsub: {
      return evaluate_fsub(num_components, src);
      break;
   }
   case nir_op_ftrunc: {
      return evaluate_ftrunc(num_components, src);
      break;
   }
   case nir_op_fxor: {
      return evaluate_fxor(num_components, src);
      break;
   }
   case nir_op_i2b: {
      return evaluate_i2b(num_components, src);
      break;
   }
   case nir_op_i2f: {
      return evaluate_i2f(num_components, src);
      break;
   }
   case nir_op_iabs: {
      return evaluate_iabs(num_components, src);
      break;
   }
   case nir_op_iadd: {
      return evaluate_iadd(num_components, src);
      break;
   }
   case nir_op_iand: {
      return evaluate_iand(num_components, src);
      break;
   }
   case nir_op_ibfe: {
      return evaluate_ibfe(num_components, src);
      break;
   }
   case nir_op_ibitfield_extract: {
      return evaluate_ibitfield_extract(num_components, src);
      break;
   }
   case nir_op_idiv: {
      return evaluate_idiv(num_components, src);
      break;
   }
   case nir_op_ieq: {
      return evaluate_ieq(num_components, src);
      break;
   }
   case nir_op_ifind_msb: {
      return evaluate_ifind_msb(num_components, src);
      break;
   }
   case nir_op_ige: {
      return evaluate_ige(num_components, src);
      break;
   }
   case nir_op_ilt: {
      return evaluate_ilt(num_components, src);
      break;
   }
   case nir_op_imax: {
      return evaluate_imax(num_components, src);
      break;
   }
   case nir_op_imin: {
      return evaluate_imin(num_components, src);
      break;
   }
   case nir_op_imov: {
      return evaluate_imov(num_components, src);
      break;
   }
   case nir_op_imul: {
      return evaluate_imul(num_components, src);
      break;
   }
   case nir_op_imul_high: {
      return evaluate_imul_high(num_components, src);
      break;
   }
   case nir_op_ine: {
      return evaluate_ine(num_components, src);
      break;
   }
   case nir_op_ineg: {
      return evaluate_ineg(num_components, src);
      break;
   }
   case nir_op_inot: {
      return evaluate_inot(num_components, src);
      break;
   }
   case nir_op_ior: {
      return evaluate_ior(num_components, src);
      break;
   }
   case nir_op_ishl: {
      return evaluate_ishl(num_components, src);
      break;
   }
   case nir_op_ishr: {
      return evaluate_ishr(num_components, src);
      break;
   }
   case nir_op_isign: {
      return evaluate_isign(num_components, src);
      break;
   }
   case nir_op_isub: {
      return evaluate_isub(num_components, src);
      break;
   }
   case nir_op_ixor: {
      return evaluate_ixor(num_components, src);
      break;
   }
   case nir_op_ldexp: {
      return evaluate_ldexp(num_components, src);
      break;
   }
   case nir_op_pack_half_2x16: {
      return evaluate_pack_half_2x16(num_components, src);
      break;
   }
   case nir_op_pack_half_2x16_split: {
      return evaluate_pack_half_2x16_split(num_components, src);
      break;
   }
   case nir_op_pack_snorm_2x16: {
      return evaluate_pack_snorm_2x16(num_components, src);
      break;
   }
   case nir_op_pack_snorm_4x8: {
      return evaluate_pack_snorm_4x8(num_components, src);
      break;
   }
   case nir_op_pack_unorm_2x16: {
      return evaluate_pack_unorm_2x16(num_components, src);
      break;
   }
   case nir_op_pack_unorm_4x8: {
      return evaluate_pack_unorm_4x8(num_components, src);
      break;
   }
   case nir_op_pack_uvec2_to_uint: {
      return evaluate_pack_uvec2_to_uint(num_components, src);
      break;
   }
   case nir_op_pack_uvec4_to_uint: {
      return evaluate_pack_uvec4_to_uint(num_components, src);
      break;
   }
   case nir_op_seq: {
      return evaluate_seq(num_components, src);
      break;
   }
   case nir_op_sge: {
      return evaluate_sge(num_components, src);
      break;
   }
   case nir_op_slt: {
      return evaluate_slt(num_components, src);
      break;
   }
   case nir_op_sne: {
      return evaluate_sne(num_components, src);
      break;
   }
   case nir_op_u2f: {
      return evaluate_u2f(num_components, src);
      break;
   }
   case nir_op_uadd_carry: {
      return evaluate_uadd_carry(num_components, src);
      break;
   }
   case nir_op_ubfe: {
      return evaluate_ubfe(num_components, src);
      break;
   }
   case nir_op_ubitfield_extract: {
      return evaluate_ubitfield_extract(num_components, src);
      break;
   }
   case nir_op_udiv: {
      return evaluate_udiv(num_components, src);
      break;
   }
   case nir_op_ufind_msb: {
      return evaluate_ufind_msb(num_components, src);
      break;
   }
   case nir_op_uge: {
      return evaluate_uge(num_components, src);
      break;
   }
   case nir_op_ult: {
      return evaluate_ult(num_components, src);
      break;
   }
   case nir_op_umax: {
      return evaluate_umax(num_components, src);
      break;
   }
   case nir_op_umax_4x8: {
      return evaluate_umax_4x8(num_components, src);
      break;
   }
   case nir_op_umin: {
      return evaluate_umin(num_components, src);
      break;
   }
   case nir_op_umin_4x8: {
      return evaluate_umin_4x8(num_components, src);
      break;
   }
   case nir_op_umod: {
      return evaluate_umod(num_components, src);
      break;
   }
   case nir_op_umul_high: {
      return evaluate_umul_high(num_components, src);
      break;
   }
   case nir_op_umul_unorm_4x8: {
      return evaluate_umul_unorm_4x8(num_components, src);
      break;
   }
   case nir_op_unpack_half_2x16: {
      return evaluate_unpack_half_2x16(num_components, src);
      break;
   }
   case nir_op_unpack_half_2x16_split_x: {
      return evaluate_unpack_half_2x16_split_x(num_components, src);
      break;
   }
   case nir_op_unpack_half_2x16_split_y: {
      return evaluate_unpack_half_2x16_split_y(num_components, src);
      break;
   }
   case nir_op_unpack_snorm_2x16: {
      return evaluate_unpack_snorm_2x16(num_components, src);
      break;
   }
   case nir_op_unpack_snorm_4x8: {
      return evaluate_unpack_snorm_4x8(num_components, src);
      break;
   }
   case nir_op_unpack_unorm_2x16: {
      return evaluate_unpack_unorm_2x16(num_components, src);
      break;
   }
   case nir_op_unpack_unorm_4x8: {
      return evaluate_unpack_unorm_4x8(num_components, src);
      break;
   }
   case nir_op_usadd_4x8: {
      return evaluate_usadd_4x8(num_components, src);
      break;
   }
   case nir_op_ushr: {
      return evaluate_ushr(num_components, src);
      break;
   }
   case nir_op_ussub_4x8: {
      return evaluate_ussub_4x8(num_components, src);
      break;
   }
   case nir_op_usub_borrow: {
      return evaluate_usub_borrow(num_components, src);
      break;
   }
   case nir_op_vec2: {
      return evaluate_vec2(num_components, src);
      break;
   }
   case nir_op_vec3: {
      return evaluate_vec3(num_components, src);
      break;
   }
   case nir_op_vec4: {
      return evaluate_vec4(num_components, src);
      break;
   }
   default:
      unreachable("shouldn't get here");
   }
}
@


1.1.1.1
log
@Import Mesa 11.2.2
@
text
@@


1.1.1.2
log
@Import Mesa 13.0.2
@
text
@d206 5
a210 8
typedef float float32_t;
typedef double float64_t;
typedef bool bool32_t;
struct float32_vec {
   float32_t x;
   float32_t y;
   float32_t z;
   float32_t w;
d212 5
a216 5
struct float64_vec {
   float64_t x;
   float64_t y;
   float64_t z;
   float64_t w;
d218 5
a222 5
struct int32_vec {
   int32_t x;
   int32_t y;
   int32_t z;
   int32_t w;
d224 5
a228 24
struct int64_vec {
   int64_t x;
   int64_t y;
   int64_t z;
   int64_t w;
};
struct uint32_vec {
   uint32_t x;
   uint32_t y;
   uint32_t z;
   uint32_t w;
};
struct uint64_vec {
   uint64_t x;
   uint64_t y;
   uint64_t z;
   uint64_t w;
};

struct bool32_vec {
    bool x;
    bool y;
    bool z;
    bool w;
d232 1
a232 2
evaluate_b2f(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d234 1
a234 1
   nir_const_value _dst_val = { {0, } };
d236 3
a238 3
   switch (bit_size) {
   case 32: {
      
d240 1
a240 3
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  bool src0 = _src[0].u32[_i] != 0;
d242 2
a243 1
               float32_t dst = src0 ? 1.0f : 0.0f;
d245 6
a250 7
               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      
d252 3
a254 5
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  bool src0 = _src[0].u32[_i] != 0;

               float32_t dst = src0 ? 1.0f : 0.0f;
d256 1
a256 5
               _dst_val.f32[_i] = dst;
         }

      break;
   }
d258 2
a259 3
   default:
      unreachable("unknown bit width");
   }
d264 1
a264 2
evaluate_b2i(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d266 1
a266 11
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  bool src0 = _src[0].u32[_i] != 0;

               int32_t dst = src0 ? 1 : 0;
a267 7
               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      
d269 4
a272 3
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  bool src0 = _src[0].u32[_i] != 0;
d274 4
a277 1
               int32_t dst = src0 ? 1 : 0;
d279 1
a279 2
               _dst_val.i32[_i] = dst;
         }
d281 1
a281 2
      break;
   }
d283 1
a283 3
   default:
      unreachable("unknown bit width");
   }
d288 1
a288 2
evaluate_ball_fequal2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d290 1
a290 1
   nir_const_value _dst_val = { {0, } };
a291 3
   switch (bit_size) {
   case 32: {
      
d293 5
d299 5
a303 4
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };
d305 1
a305 4
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };
d307 1
a307 1
         struct bool32_vec dst;
d309 1
a309 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));
d311 6
a316 6
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
   case 64: {
      
d319 6
a324 4
         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
         };
d326 6
a331 4
         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
         };
d333 1
a333 1
         struct bool32_vec dst;
d335 1
a335 6
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));

               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
d337 1
a337 3
   default:
      unreachable("unknown bit width");
   }
d342 1
a342 2
evaluate_ball_fequal3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d344 1
a344 1
   nir_const_value _dst_val = { {0, } };
a345 3
   switch (bit_size) {
   case 32: {
      
d347 4
d352 4
a355 5
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };
d357 1
a357 5
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };
d359 1
a359 1
         struct bool32_vec dst;
d361 1
a361 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));
d363 6
a368 6
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
   case 64: {
      
d371 5
a375 5
         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
         };
d377 5
a381 5
         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
         };
d383 1
a383 1
         struct bool32_vec dst;
d385 1
a385 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));
d387 1
a387 8
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }

   default:
      unreachable("unknown bit width");
   }
d392 1
a392 2
evaluate_ball_fequal4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d394 1
a394 1
   nir_const_value _dst_val = { {0, } };
a395 3
   switch (bit_size) {
   case 32: {
      
d397 6
d404 6
a409 6
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };
d411 1
a411 6
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };
d413 1
a413 1
         struct bool32_vec dst;
d415 1
a415 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));
d417 6
a422 6
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
   case 64: {
      
d425 4
a428 6
         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
               _src[0].f64[3],
         };
d430 4
a433 6
         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
               _src[1].f64[3],
         };
d435 1
a435 1
         struct bool32_vec dst;
d437 1
a437 6
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));

               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
d439 1
a439 3
   default:
      unreachable("unknown bit width");
   }
d444 1
a444 2
evaluate_ball_iequal2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d446 1
a446 1
   nir_const_value _dst_val = { {0, } };
a447 3
   switch (bit_size) {
   case 32: {
      
d449 5
d455 5
a459 4
         struct int32_vec src0 = {
               _src[0].i32[0],
               _src[0].i32[1],
         };
d461 1
a461 4
         struct int32_vec src1 = {
               _src[1].i32[0],
               _src[1].i32[1],
         };
d463 1
a463 1
         struct bool32_vec dst;
d465 1
a465 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));
d467 6
a472 6
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
   case 64: {
      
d475 6
a480 4
         struct int64_vec src0 = {
               _src[0].i64[0],
               _src[0].i64[1],
         };
d482 6
a487 4
         struct int64_vec src1 = {
               _src[1].i64[0],
               _src[1].i64[1],
         };
d489 1
a489 1
         struct bool32_vec dst;
d491 1
a491 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));
d493 1
a493 8
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }

   default:
      unreachable("unknown bit width");
   }
d498 1
a498 2
evaluate_ball_iequal3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d500 1
a500 1
   nir_const_value _dst_val = { {0, } };
a501 3
   switch (bit_size) {
   case 32: {
      
d503 4
d508 4
a511 5
         struct int32_vec src0 = {
               _src[0].i32[0],
               _src[0].i32[1],
               _src[0].i32[2],
         };
d513 1
a513 5
         struct int32_vec src1 = {
               _src[1].i32[0],
               _src[1].i32[1],
               _src[1].i32[2],
         };
d515 1
a515 1
         struct bool32_vec dst;
d517 1
a517 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));
d519 6
a524 6
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
   case 64: {
      
d527 5
a531 5
         struct int64_vec src0 = {
               _src[0].i64[0],
               _src[0].i64[1],
               _src[0].i64[2],
         };
d533 5
a537 5
         struct int64_vec src1 = {
               _src[1].i64[0],
               _src[1].i64[1],
               _src[1].i64[2],
         };
d539 1
a539 1
         struct bool32_vec dst;
d541 1
a541 6
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));

               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
d543 1
a543 3
   default:
      unreachable("unknown bit width");
   }
d548 1
a548 2
evaluate_ball_iequal4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d550 1
a550 1
   nir_const_value _dst_val = { {0, } };
a551 3
   switch (bit_size) {
   case 32: {
      
d553 6
d560 6
a565 6
         struct int32_vec src0 = {
               _src[0].i32[0],
               _src[0].i32[1],
               _src[0].i32[2],
               _src[0].i32[3],
         };
d567 1
a567 6
         struct int32_vec src1 = {
               _src[1].i32[0],
               _src[1].i32[1],
               _src[1].i32[2],
               _src[1].i32[3],
         };
d569 1
a569 1
         struct bool32_vec dst;
d571 1
a571 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));
d573 6
a578 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d580 5
a584 4
      break;
   }
   case 64: {
      
d586 1
d588 2
a589 6
         struct int64_vec src0 = {
               _src[0].i64[0],
               _src[0].i64[1],
               _src[0].i64[2],
               _src[0].i64[3],
         };
d591 6
a596 6
         struct int64_vec src1 = {
               _src[1].i64[0],
               _src[1].i64[1],
               _src[1].i64[2],
               _src[1].i64[3],
         };
d598 5
a602 1
         struct bool32_vec dst;
d604 13
a616 3
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));

               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
a617 2
      break;
   }
d619 2
a620 3
   default:
      unreachable("unknown bit width");
   }
d625 1
a625 2
evaluate_bany_fnequal2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d627 1
a627 1
   nir_const_value _dst_val = { {0, } };
d629 4
a632 3
   switch (bit_size) {
   case 32: {
      
d634 7
a641 4
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };
d643 2
a644 4
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };
d646 6
a651 1
         struct bool32_vec dst;
d653 3
a655 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));
d657 7
a663 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
a664 4
      break;
   }
   case 64: {
      
d666 2
d669 6
a674 4
         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
         };
d676 6
a681 4
         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
         };
d683 12
a694 5
         struct bool32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));

               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
a695 2
      break;
   }
d697 2
a698 3
   default:
      unreachable("unknown bit width");
   }
d703 1
a703 2
evaluate_bany_fnequal3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d705 1
a705 1
   nir_const_value _dst_val = { {0, } };
d707 3
a709 3
   switch (bit_size) {
   case 32: {
      
d711 6
a717 5
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };
d719 2
a720 5
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };
d722 6
a727 1
         struct bool32_vec dst;
d729 4
a732 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
d734 1
a734 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d736 2
a737 4
      break;
   }
   case 64: {
      
d739 6
d746 4
a749 5
         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
         };
d751 1
a751 5
         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
         };
d753 2
a754 1
         struct bool32_vec dst;
d756 6
a761 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
d763 4
a766 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d768 1
a768 2
      break;
   }
d770 2
a771 3
   default:
      unreachable("unknown bit width");
   }
d776 1
a776 2
evaluate_bany_fnequal4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d778 1
a778 1
   nir_const_value _dst_val = { {0, } };
d780 4
a783 3
   switch (bit_size) {
   case 32: {
      
d785 1
d787 2
a788 6
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };
d790 6
a795 6
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };
d797 3
a799 1
         struct bool32_vec dst;
d801 1
a801 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));
d803 2
a804 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d806 6
a811 4
      break;
   }
   case 64: {
      
d813 3
d817 1
a817 6
         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
               _src[0].f64[3],
         };
d819 2
a820 6
         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
               _src[1].f64[3],
         };
d822 6
a827 3
         struct bool32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));
d829 3
a831 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d833 1
a833 2
      break;
   }
d835 2
a836 3
   default:
      unreachable("unknown bit width");
   }
d841 1
a841 2
evaluate_bany_inequal2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d843 1
a843 1
   nir_const_value _dst_val = { {0, } };
d845 3
a847 3
   switch (bit_size) {
   case 32: {
      
d849 1
d851 2
a852 4
         struct int32_vec src0 = {
               _src[0].i32[0],
               _src[0].i32[1],
         };
d854 6
a859 4
         struct int32_vec src1 = {
               _src[1].i32[0],
               _src[1].i32[1],
         };
d861 4
a864 1
         struct bool32_vec dst;
d866 1
a866 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));
d868 2
a869 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d871 6
a876 10
      break;
   }
   case 64: {
      


         struct int64_vec src0 = {
               _src[0].i64[0],
               _src[0].i64[1],
         };
a877 4
         struct int64_vec src1 = {
               _src[1].i64[0],
               _src[1].i64[1],
         };
d879 4
a882 1
         struct bool32_vec dst;
d884 4
a887 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));
d889 1
a889 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d891 1
a891 2
      break;
   }
d893 1
a893 3
   default:
      unreachable("unknown bit width");
   }
d898 1
a898 2
evaluate_bany_inequal3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d900 2
a901 1
   nir_const_value _dst_val = { {0, } };
d903 5
a907 3
   switch (bit_size) {
   case 32: {
      
d909 5
d915 1
a915 5
         struct int32_vec src0 = {
               _src[0].i32[0],
               _src[0].i32[1],
               _src[0].i32[2],
         };
d917 1
a917 5
         struct int32_vec src1 = {
               _src[1].i32[0],
               _src[1].i32[1],
               _src[1].i32[2],
         };
d919 1
a919 1
         struct bool32_vec dst;
d921 6
a926 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
a927 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d929 6
a934 4
      break;
   }
   case 64: {
      
d936 6
d943 1
a943 5
         struct int64_vec src0 = {
               _src[0].i64[0],
               _src[0].i64[1],
               _src[0].i64[2],
         };
d945 1
a945 5
         struct int64_vec src1 = {
               _src[1].i64[0],
               _src[1].i64[1],
               _src[1].i64[2],
         };
d947 1
a947 1
         struct bool32_vec dst;
d949 6
a954 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
d956 4
a959 1
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d961 1
a961 2
      break;
   }
d963 2
a964 3
   default:
      unreachable("unknown bit width");
   }
d969 1
a969 2
evaluate_bany_inequal4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d971 1
a971 1
   nir_const_value _dst_val = { {0, } };
a972 3
   switch (bit_size) {
   case 32: {
      
d974 4
d979 4
a982 6
         struct int32_vec src0 = {
               _src[0].i32[0],
               _src[0].i32[1],
               _src[0].i32[2],
               _src[0].i32[3],
         };
d984 1
a984 6
         struct int32_vec src1 = {
               _src[1].i32[0],
               _src[1].i32[1],
               _src[1].i32[2],
               _src[1].i32[3],
         };
d986 1
a986 1
         struct bool32_vec dst;
d988 1
a988 8
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));

               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
   case 64: {
      
d990 6
a996 6
         struct int64_vec src0 = {
               _src[0].i64[0],
               _src[0].i64[1],
               _src[0].i64[2],
               _src[0].i64[3],
         };
d998 5
a1002 6
         struct int64_vec src1 = {
               _src[1].i64[0],
               _src[1].i64[1],
               _src[1].i64[2],
               _src[1].i64[3],
         };
d1004 5
a1008 1
         struct bool32_vec dst;
d1010 1
a1010 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));
d1012 1
a1012 4
               _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

      break;
   }
d1014 1
a1014 3
   default:
      unreachable("unknown bit width");
   }
d1019 1
a1019 2
evaluate_bcsel(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1021 1
a1021 1
   nir_const_value _dst_val = { {0, } };
a1022 3
   switch (bit_size) {
   case 32: {
      
d1024 6
a1029 7
                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  bool src0 = _src[0].u32[_i] != 0;
                  uint32_t src1 =
                     _src[1].u32[_i];
                  uint32_t src2 =
                     _src[2].u32[_i];
d1031 6
a1036 1
               uint32_t dst = src0 ? src1 : src2;
d1038 1
a1038 2
               _dst_val.u32[_i] = dst;
         }
d1040 1
a1040 4
      break;
   }
   case 64: {
      
d1042 1
a1042 7
                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  bool src0 = _src[0].u32[_i] != 0;
                  uint64_t src1 =
                     _src[1].u64[_i];
                  uint64_t src2 =
                     _src[2].u64[_i];
d1044 6
a1049 1
               uint64_t dst = src0 ? src1 : src2;
d1051 3
a1053 2
               _dst_val.u64[_i] = dst;
         }
d1055 1
a1055 2
      break;
   }
d1057 2
a1058 3
   default:
      unreachable("unknown bit width");
   }
d1063 1
a1063 2
evaluate_bfi(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1065 5
a1069 1
   nir_const_value _dst_val = { {0, } };
d1071 1
a1071 3
   switch (bit_size) {
   case 32: {
      
d1073 2
a1074 8
                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
                  uint32_t src2 =
                     _src[2].u32[_i];
d1076 1
a1076 12
               uint32_t dst;
               
unsigned mask = src0, insert = src1, base = src2;
if (mask == 0) {
   dst = base;
} else {
   unsigned tmp = mask;
   while (!(tmp & 1)) {
      tmp >>= 1;
      insert <<= 1;
   }
   dst = (base & ~mask) | (insert & mask);
d1078 4
d1083 5
d1089 1
a1089 2
               _dst_val.u32[_i] = dst;
         }
d1091 2
a1092 4
      break;
   }
   case 64: {
      
d1094 6
a1099 8
                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
                  uint32_t src2 =
                     _src[2].u32[_i];
d1101 2
a1102 1
               uint32_t dst;
d1104 1
a1104 11
unsigned mask = src0, insert = src1, base = src2;
if (mask == 0) {
   dst = base;
} else {
   unsigned tmp = mask;
   while (!(tmp & 1)) {
      tmp >>= 1;
      insert <<= 1;
   }
   dst = (base & ~mask) | (insert & mask);
}
d1106 2
d1109 6
a1114 2
               _dst_val.u32[_i] = dst;
         }
d1116 4
a1119 2
      break;
   }
d1121 2
a1122 3
   default:
      unreachable("unknown bit width");
   }
d1127 1
a1127 2
evaluate_bfm(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1129 1
a1129 5
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      
d1131 2
a1132 8
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               uint32_t dst;
d1134 1
a1134 5
int bits = src0, offset = src1;
if (offset < 0 || bits < 0 || offset > 31 || bits > 31 || offset + bits > 32)
   dst = 0; /* undefined */
else
   dst = ((1u << bits) - 1) << offset;
d1136 2
d1139 6
a1144 14
               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d1146 2
a1147 1
               uint32_t dst;
d1149 1
a1149 5
int bits = src0, offset = src1;
if (offset < 0 || bits < 0 || offset > 31 || bits > 31 || offset + bits > 32)
   dst = 0; /* undefined */
else
   dst = ((1u << bits) - 1) << offset;
d1151 2
d1154 6
a1159 2
               _dst_val.u32[_i] = dst;
         }
d1161 4
a1164 2
      break;
   }
d1166 2
a1167 3
   default:
      unreachable("unknown bit width");
   }
d1172 1
a1172 2
evaluate_bit_count(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1174 1
a1174 1
   nir_const_value _dst_val = { {0, } };
d1176 4
a1179 3
   switch (bit_size) {
   case 32: {
      
d1181 2
a1182 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
d1184 1
a1184 6
               uint32_t dst;
               
dst = 0;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1)
      dst++;
d1186 9
d1196 1
d1198 2
a1199 2
               _dst_val.u32[_i] = dst;
         }
d1201 6
a1206 4
      break;
   }
   case 64: {
      
a1207 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
d1209 4
a1212 7
               uint32_t dst;
               
dst = 0;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1)
      dst++;
}
d1214 4
d1219 1
a1219 2
               _dst_val.u32[_i] = dst;
         }
d1221 1
a1221 2
      break;
   }
d1223 1
a1223 3
   default:
      unreachable("unknown bit width");
   }
d1228 1
a1228 2
evaluate_bitfield_insert(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1230 2
a1231 1
   nir_const_value _dst_val = { {0, } };
d1233 5
a1237 3
   switch (bit_size) {
   case 32: {
      
d1239 5
a1243 10
                                                
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];
                  int32_t src3 =
                     _src[3].i32[_i];
d1245 1
a1245 12
               uint32_t dst;
               
unsigned base = src0, insert = src1;
int offset = src2, bits = src3;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || bits + offset > 32) {
   dst = 0;
} else {
   unsigned mask = ((1ull << bits) - 1) << offset;
   dst = (base & ~mask) | ((insert << bits) & mask);
}
d1247 1
d1249 1
a1249 2
               _dst_val.u32[_i] = dst;
         }
d1251 6
a1256 4
      break;
   }
   case 64: {
      
a1257 10
                                                
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];
                  int32_t src3 =
                     _src[3].i32[_i];
d1259 6
a1264 12
               uint32_t dst;
               
unsigned base = src0, insert = src1;
int offset = src2, bits = src3;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || bits + offset > 32) {
   dst = 0;
} else {
   unsigned mask = ((1ull << bits) - 1) << offset;
   dst = (base & ~mask) | ((insert << bits) & mask);
}
d1266 6
d1273 1
a1273 2
               _dst_val.u32[_i] = dst;
         }
d1275 1
a1275 2
      break;
   }
d1277 1
a1277 3
   default:
      unreachable("unknown bit width");
   }
d1282 1
a1282 2
evaluate_bitfield_reverse(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1284 2
a1285 1
   nir_const_value _dst_val = { {0, } };
d1287 4
a1290 3
   switch (bit_size) {
   case 32: {
      
d1292 4
a1295 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
d1297 1
a1297 6
               uint32_t dst;
               
/* we're not winning any awards for speed here, but that's ok */
dst = 0;
for (unsigned bit = 0; bit < 32; bit++)
   dst |= ((src0 >> bit) & 1) << (31 - bit);
d1299 1
d1301 4
a1304 2
               _dst_val.u32[_i] = dst;
         }
d1306 6
a1311 4
      break;
   }
   case 64: {
      
a1312 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
d1314 5
a1318 6
               uint32_t dst;
               
/* we're not winning any awards for speed here, but that's ok */
dst = 0;
for (unsigned bit = 0; bit < 32; bit++)
   dst |= ((src0 >> bit) & 1) << (31 - bit);
d1320 5
d1326 1
a1326 2
               _dst_val.u32[_i] = dst;
         }
d1328 1
a1328 2
      break;
   }
d1330 4
a1333 3
   default:
      unreachable("unknown bit width");
   }
d1338 1
a1338 2
evaluate_d2b(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1340 16
a1355 1
   nir_const_value _dst_val = { {0, } };
d1357 1
a1357 3
   switch (bit_size) {
   case 32: {
      
d1359 1
a1359 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1361 4
a1364 1
               bool32_t dst = src0 != 0.0;
d1366 6
a1371 2
               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }
a1372 4
      break;
   }
   case 64: {
      
d1374 5
a1378 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1380 6
a1385 1
               bool32_t dst = src0 != 0.0;
d1387 1
a1387 2
               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }
d1389 1
a1389 2
      break;
   }
d1391 1
a1391 3
   default:
      unreachable("unknown bit width");
   }
d1396 1
a1396 2
evaluate_d2f(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1398 1
a1398 1
   nir_const_value _dst_val = { {0, } };
a1399 3
   switch (bit_size) {
   case 32: {
      
d1401 5
a1405 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1407 6
a1412 1
               float32_t dst = src0;
d1414 1
a1414 2
               _dst_val.f32[_i] = dst;
         }
d1416 1
a1416 4
      break;
   }
   case 64: {
      
d1418 4
a1421 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1423 6
a1428 1
               float32_t dst = src0;
d1430 4
a1433 2
               _dst_val.f32[_i] = dst;
         }
d1435 1
a1435 2
      break;
   }
d1437 2
a1438 3
   default:
      unreachable("unknown bit width");
   }
d1443 1
a1443 2
evaluate_d2i(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1445 5
a1449 1
   nir_const_value _dst_val = { {0, } };
d1451 1
a1451 3
   switch (bit_size) {
   case 32: {
      
d1453 2
a1454 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1456 6
a1461 1
               int32_t dst = src0;
d1463 3
a1465 2
               _dst_val.i32[_i] = dst;
         }
d1467 1
a1467 4
      break;
   }
   case 64: {
      
d1469 2
a1470 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1472 6
a1477 1
               int32_t dst = src0;
d1479 5
a1483 2
               _dst_val.i32[_i] = dst;
         }
d1485 1
a1485 2
      break;
   }
d1487 2
a1488 3
   default:
      unreachable("unknown bit width");
   }
d1493 1
a1493 2
evaluate_d2u(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1495 5
a1499 1
   nir_const_value _dst_val = { {0, } };
d1501 1
a1501 3
   switch (bit_size) {
   case 32: {
      
d1503 2
a1504 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1506 6
a1511 1
               uint32_t dst = src0;
d1513 4
a1516 2
               _dst_val.u32[_i] = dst;
         }
d1518 1
a1518 4
      break;
   }
   case 64: {
      
d1520 2
a1521 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d1523 6
a1528 1
               uint32_t dst = src0;
d1530 3
a1532 2
               _dst_val.u32[_i] = dst;
         }
d1534 6
d1542 2
d1545 2
a1546 3
   default:
      unreachable("unknown bit width");
   }
d1551 1
a1551 2
evaluate_extract_i16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1553 5
a1557 1
   nir_const_value _dst_val = { {0, } };
d1559 1
a1559 3
   switch (bit_size) {
   case 32: {
      
d1561 2
a1562 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d1564 6
a1569 1
               int32_t dst = (int16_t)(src0 >> (src1 * 16));
d1571 5
a1575 2
               _dst_val.i32[_i] = dst;
         }
d1577 1
a1577 4
      break;
   }
   case 64: {
      
d1579 2
a1580 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];
d1582 6
a1587 1
               int64_t dst = (int16_t)(src0 >> (src1 * 16));
d1589 4
a1592 2
               _dst_val.i64[_i] = dst;
         }
d1594 1
a1594 2
      break;
   }
d1596 2
a1597 3
   default:
      unreachable("unknown bit width");
   }
d1602 1
a1602 2
evaluate_extract_i8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1604 1
a1604 1
   nir_const_value _dst_val = { {0, } };
d1606 4
a1609 3
   switch (bit_size) {
   case 32: {
      
d1611 1
a1611 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d1613 2
a1614 1
               int32_t dst = (int8_t)(src0 >> (src1 * 8));
d1616 6
a1621 2
               _dst_val.i32[_i] = dst;
         }
d1623 4
a1626 4
      break;
   }
   case 64: {
      
d1628 1
a1628 14
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = (int8_t)(src0 >> (src1 * 8));

               _dst_val.i64[_i] = dst;
         }

      break;
   }
d1630 2
a1631 3
   default:
      unreachable("unknown bit width");
   }
d1636 1
a1636 2
evaluate_extract_u16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1638 1
a1638 1
   nir_const_value _dst_val = { {0, } };
d1640 4
a1643 3
   switch (bit_size) {
   case 32: {
      
d1645 1
a1645 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d1647 2
a1648 1
               uint32_t dst = (uint16_t)(src0 >> (src1 * 16));
d1650 6
a1655 16
               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = (uint16_t)(src0 >> (src1 * 16));
d1657 3
a1659 2
               _dst_val.u64[_i] = dst;
         }
d1661 1
a1661 2
      break;
   }
d1663 2
a1664 3
   default:
      unreachable("unknown bit width");
   }
d1669 1
a1669 2
evaluate_extract_u8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1671 1
a1671 1
   nir_const_value _dst_val = { {0, } };
d1673 4
a1676 3
   switch (bit_size) {
   case 32: {
      
d1678 1
a1678 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d1680 2
a1681 1
               uint32_t dst = (uint8_t)(src0 >> (src1 * 8));
d1683 6
a1688 2
               _dst_val.u32[_i] = dst;
         }
d1690 6
a1695 4
      break;
   }
   case 64: {
      
d1697 2
a1698 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];
d1700 6
a1705 1
               uint64_t dst = (uint8_t)(src0 >> (src1 * 8));
d1707 3
a1709 2
               _dst_val.u64[_i] = dst;
         }
d1711 1
a1711 2
      break;
   }
d1713 2
a1714 3
   default:
      unreachable("unknown bit width");
   }
d1719 1
a1719 2
evaluate_f2b(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1721 4
a1724 1
   nir_const_value _dst_val = { {0, } };
d1726 1
a1726 3
   switch (bit_size) {
   case 32: {
      
d1728 1
a1728 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1730 6
a1735 1
               bool32_t dst = src0 != 0.0f;
d1737 2
a1738 2
               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }
d1740 1
a1740 4
      break;
   }
   case 64: {
      
d1742 1
a1742 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1744 6
a1749 1
               bool32_t dst = src0 != 0.0f;
d1751 2
a1752 2
               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }
d1754 1
a1754 2
      break;
   }
d1756 1
a1756 3
   default:
      unreachable("unknown bit width");
   }
d1761 1
a1761 2
evaluate_f2d(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1763 1
a1763 5
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      
d1765 2
a1766 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1768 1
a1768 1
               float64_t dst = src0;
d1770 1
a1770 2
               _dst_val.f64[_i] = dst;
         }
d1772 6
a1777 11
      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float64_t dst = src0;
d1779 2
a1780 2
               _dst_val.f64[_i] = dst;
         }
d1782 1
a1782 2
      break;
   }
d1784 2
a1785 3
   default:
      unreachable("unknown bit width");
   }
d1790 1
a1790 2
evaluate_f2i(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1792 1
a1792 1
   nir_const_value _dst_val = { {0, } };
d1794 2
a1795 3
   switch (bit_size) {
   case 32: {
      
d1797 1
a1797 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1799 2
a1800 1
               int32_t dst = src0;
d1802 6
a1807 14
               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               int32_t dst = src0;
d1809 2
a1810 2
               _dst_val.i32[_i] = dst;
         }
d1812 1
a1812 2
      break;
   }
d1814 2
a1815 3
   default:
      unreachable("unknown bit width");
   }
d1820 1
a1820 2
evaluate_f2u(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1822 1
a1822 1
   nir_const_value _dst_val = { {0, } };
d1824 2
a1825 3
   switch (bit_size) {
   case 32: {
      
d1827 1
a1827 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1829 2
a1830 1
               uint32_t dst = src0;
d1832 6
a1837 2
               _dst_val.u32[_i] = dst;
         }
d1839 2
a1840 9
      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1842 1
a1842 7
               uint32_t dst = src0;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
d1844 3
a1846 3
   default:
      unreachable("unknown bit width");
   }
d1851 1
a1851 2
evaluate_fabs(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1853 1
a1853 1
   nir_const_value _dst_val = { {0, } };
d1855 2
a1856 3
   switch (bit_size) {
   case 32: {
      
d1858 1
a1858 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
d1860 3
a1862 1
               float32_t dst = bit_size == 64 ? fabs(src0) : fabsf(src0);
d1864 6
a1869 14
               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? fabs(src0) : fabsf(src0);
d1871 2
a1872 2
               _dst_val.f64[_i] = dst;
         }
d1874 1
a1874 2
      break;
   }
d1876 3
a1878 3
   default:
      unreachable("unknown bit width");
   }
d1883 1
a1883 2
evaluate_fadd(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1885 1
a1885 1
   nir_const_value _dst_val = { {0, } };
d1887 2
a1888 3
   switch (bit_size) {
   case 32: {
      
d1890 1
a1890 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];
d1892 3
a1894 1
               float32_t dst = src0 + src1;
d1896 6
a1901 16
               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = src0 + src1;
d1903 2
a1904 2
               _dst_val.f64[_i] = dst;
         }
d1906 1
a1906 2
      break;
   }
d1908 4
a1911 3
   default:
      unreachable("unknown bit width");
   }
d1916 1
a1916 2
evaluate_fall_equal2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1918 1
a1918 1
   nir_const_value _dst_val = { {0, } };
d1920 2
a1921 3
   switch (bit_size) {
   case 32: {
      
d1923 1
d1925 4
a1928 4
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };
d1930 6
a1935 4
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };
d1937 2
a1938 1
         struct float32_vec dst;
d1940 1
a1940 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y)) ? 1.0f : 0.0f;
d1942 4
a1945 1
               _dst_val.f32[0] = dst.x;
d1947 6
a1952 4
      break;
   }
   case 64: {
      
d1954 2
d1957 1
a1957 4
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };
d1959 4
a1962 4
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };
d1964 6
a1969 3
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y)) ? 1.0f : 0.0f;
d1971 3
a1973 1
               _dst_val.f32[0] = dst.x;
d1975 1
a1975 2
      break;
   }
d1977 2
a1978 3
   default:
      unreachable("unknown bit width");
   }
d1983 1
a1983 2
evaluate_fall_equal3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d1985 1
a1985 1
   nir_const_value _dst_val = { {0, } };
d1987 4
a1990 3
   switch (bit_size) {
   case 32: {
      
d1992 1
d1994 2
a1995 5
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };
d1997 6
a2002 5
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };
d2004 4
a2007 1
         struct float32_vec dst;
d2009 1
a2009 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z)) ? 1.0f : 0.0f;
d2011 2
a2012 1
               _dst_val.f32[0] = dst.x;
d2014 6
a2019 4
      break;
   }
   case 64: {
      
d2021 3
d2025 1
a2025 5
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };
d2027 2
a2028 5
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };
d2030 6
a2035 3
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z)) ? 1.0f : 0.0f;
d2037 3
a2039 1
               _dst_val.f32[0] = dst.x;
d2041 1
a2041 2
      break;
   }
d2043 2
a2044 3
   default:
      unreachable("unknown bit width");
   }
d2049 1
a2049 2
evaluate_fall_equal4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2051 1
a2051 1
   nir_const_value _dst_val = { {0, } };
d2053 3
a2055 3
   switch (bit_size) {
   case 32: {
      
d2057 1
d2059 2
a2060 6
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };
d2062 6
a2067 6
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };
d2069 3
a2071 1
         struct float32_vec dst;
d2073 1
a2073 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w)) ? 1.0f : 0.0f;
d2075 2
a2076 1
               _dst_val.f32[0] = dst.x;
d2078 6
a2083 4
      break;
   }
   case 64: {
      
d2085 3
d2089 1
a2089 6
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };
d2091 2
a2092 6
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };
d2094 6
a2099 3
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w)) ? 1.0f : 0.0f;
d2101 3
a2103 1
               _dst_val.f32[0] = dst.x;
d2105 1
a2105 2
      break;
   }
d2107 2
a2108 3
   default:
      unreachable("unknown bit width");
   }
d2113 1
a2113 2
evaluate_fand(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2115 1
a2115 1
   nir_const_value _dst_val = { {0, } };
d2117 3
a2119 3
   switch (bit_size) {
   case 32: {
      
d2121 1
a2121 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];
d2123 2
a2124 1
               float32_t dst = ((src0 != 0.0f) && (src1 != 0.0f)) ? 1.0f : 0.0f;
d2126 6
a2131 2
               _dst_val.f32[_i] = dst;
         }
d2133 4
a2136 13
      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = ((src0 != 0.0f) && (src1 != 0.0f)) ? 1.0f : 0.0f;
d2138 1
a2138 2
               _dst_val.f32[_i] = dst;
         }
d2140 2
a2141 6
      break;
   }

   default:
      unreachable("unknown bit width");
   }
d2146 1
a2146 2
evaluate_fany_nequal2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2148 1
a2148 1
   nir_const_value _dst_val = { {0, } };
d2150 3
a2152 3
   switch (bit_size) {
   case 32: {
      
d2154 1
d2156 2
a2157 4
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };
d2159 6
a2164 4
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };
d2166 4
a2169 1
         struct float32_vec dst;
d2171 1
a2171 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y)) ? 1.0f : 0.0f;
d2173 2
a2174 1
               _dst_val.f32[0] = dst.x;
d2176 6
a2181 4
      break;
   }
   case 64: {
      
d2183 3
d2187 1
a2187 4
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };
d2189 2
a2190 4
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };
d2192 6
a2197 3
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y)) ? 1.0f : 0.0f;
d2199 3
a2201 1
               _dst_val.f32[0] = dst.x;
d2203 1
a2203 2
      break;
   }
d2205 2
a2206 3
   default:
      unreachable("unknown bit width");
   }
d2211 1
a2211 2
evaluate_fany_nequal3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2213 1
a2213 1
   nir_const_value _dst_val = { {0, } };
d2215 3
a2217 3
   switch (bit_size) {
   case 32: {
      
d2219 1
d2221 2
a2222 5
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };
d2224 6
a2229 5
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };
d2231 4
a2234 1
         struct float32_vec dst;
d2236 1
a2236 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z)) ? 1.0f : 0.0f;
d2238 2
a2239 1
               _dst_val.f32[0] = dst.x;
d2241 6
a2246 4
      break;
   }
   case 64: {
      
d2248 4
d2253 1
a2253 5
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };
d2255 2
a2256 5
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };
d2258 6
a2263 1
         struct float32_vec dst;
d2265 5
a2269 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z)) ? 1.0f : 0.0f;
d2271 13
a2283 1
               _dst_val.f32[0] = dst.x;
a2284 2
      break;
   }
d2286 2
a2287 3
   default:
      unreachable("unknown bit width");
   }
d2292 1
a2292 2
evaluate_fany_nequal4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2294 1
a2294 1
   nir_const_value _dst_val = { {0, } };
d2296 5
a2300 3
   switch (bit_size) {
   case 32: {
      
d2302 11
a2313 6
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };
d2315 2
a2316 6
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };
d2318 6
a2323 1
         struct float32_vec dst;
d2325 4
a2328 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w)) ? 1.0f : 0.0f;
d2330 1
a2330 1
               _dst_val.f32[0] = dst.x;
d2332 2
a2333 4
      break;
   }
   case 64: {
      
d2335 6
d2342 4
a2345 6
         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };
d2347 1
a2347 6
         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };
d2349 2
a2350 1
         struct float32_vec dst;
d2352 6
a2357 1
            dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w)) ? 1.0f : 0.0f;
d2359 3
a2361 1
               _dst_val.f32[0] = dst.x;
d2363 10
d2375 1
d2377 3
a2379 3
   default:
      unreachable("unknown bit width");
   }
d2384 1
a2384 2
evaluate_fceil(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2386 1
a2386 1
   nir_const_value _dst_val = { {0, } };
d2388 4
a2391 67
   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? ceil(src0) : ceilf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? ceil(src0) : ceilf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fcos(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? cos(src0) : cosf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
d2393 1
a2393 1
               float64_t dst = bit_size == 64 ? cos(src0) : cosf(src0);
d2395 2
a2396 61
               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fcsel(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];
                  float32_t src2 =
                     _src[2].f32[_i];

               float32_t dst = (src0 != 0.0f) ? src1 : src2;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];
                  float32_t src2 =
                     _src[2].f32[_i];

               float32_t dst = (src0 != 0.0f) ? src1 : src2;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }
d2401 1
a2401 2
evaluate_fddx(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2403 1
a2403 13
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float32_t dst = 0.0;

               _dst_val.f32[_i] = dst;
         }
a2404 7
      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
d2406 3
a2408 1
               float64_t dst = 0.0;
d2410 1
a2410 2
               _dst_val.f64[_i] = dst;
         }
d2412 2
a2413 6
      break;
   }

   default:
      unreachable("unknown bit width");
   }
d2418 1
a2418 2
evaluate_fddx_coarse(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2420 1
a2420 18
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float32_t dst = 0.0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      
a2421 2
            
         for (unsigned _i = 0; _i < num_components; _i++) {
d2423 3
a2425 4
               float64_t dst = 0.0;

               _dst_val.f64[_i] = dst;
         }
d2427 1
a2427 2
      break;
   }
d2429 2
a2430 3
   default:
      unreachable("unknown bit width");
   }
d2435 1
a2435 2
evaluate_fddx_fine(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2437 1
a2437 18
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float32_t dst = 0.0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      
a2438 2
            
         for (unsigned _i = 0; _i < num_components; _i++) {
d2440 3
a2442 1
               float64_t dst = 0.0;
d2444 1
a2444 5
               _dst_val.f64[_i] = dst;
         }

      break;
   }
d2446 2
a2447 3
   default:
      unreachable("unknown bit width");
   }
d2452 1
a2452 2
evaluate_fddy(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2454 1
a2454 23
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float32_t dst = 0.0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float64_t dst = 0.0;
d2456 3
a2458 2
               _dst_val.f64[_i] = dst;
         }
d2460 1
a2460 2
      break;
   }
d2462 2
a2463 3
   default:
      unreachable("unknown bit width");
   }
d2468 1
a2468 2
evaluate_fddy_coarse(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2470 1
a2470 1
   nir_const_value _dst_val = { {0, } };
a2471 19
   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float32_t dst = 0.0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
d2473 3
a2475 4
               float64_t dst = 0.0;

               _dst_val.f64[_i] = dst;
         }
d2477 1
a2477 2
      break;
   }
d2479 2
a2480 3
   default:
      unreachable("unknown bit width");
   }
d2485 1
a2485 2
evaluate_fddy_fine(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2487 1
a2487 18
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  
               float32_t dst = 0.0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      
a2488 2
            
         for (unsigned _i = 0; _i < num_components; _i++) {
d2490 3
a2492 293
               float64_t dst = 0.0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdiv(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = src0 / src1;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = src0 / src1;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdot2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdot3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdot4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
               _src[0].f64[3],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
               _src[1].f64[3],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdot_replicated2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
         };
d2494 1
a2494 5364
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdot_replicated3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdot_replicated4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
               _src[0].f64[3],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
               _src[1].f64[3],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdph(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
               _src[1].f64[3],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fdph_replicated(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
               _src[1].f32[1],
               _src[1].f32[2],
               _src[1].f32[3],
         };

         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      


         struct float64_vec src0 = {
               _src[0].f64[0],
               _src[0].f64[1],
               _src[0].f64[2],
         };

         struct float64_vec src1 = {
               _src[1].f64[0],
               _src[1].f64[1],
               _src[1].f64[2],
               _src[1].f64[3],
         };

         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_feq(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               bool32_t dst = src0 == src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               bool32_t dst = src0 == src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fexp2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = exp2f(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = exp2f(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ffloor(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? floor(src0) : floorf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? floor(src0) : floorf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ffma(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];
                  float32_t src2 =
                     _src[2].f32[_i];

               float32_t dst = src0 * src1 + src2;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];
                  float64_t src2 =
                     _src[2].f64[_i];

               float64_t dst = src0 * src1 + src2;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ffract(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = src0 - (bit_size == 64 ? floor(src0) : floorf(src0));

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = src0 - (bit_size == 64 ? floor(src0) : floorf(src0));

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fge(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               bool32_t dst = src0 >= src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               bool32_t dst = src0 >= src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_find_lsb(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst;
               
dst = -1;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1) {
      dst = bit;
      break;
   }
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst;
               
dst = -1;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1) {
      dst = bit;
      break;
   }
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_flog2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = log2f(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = log2f(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_flrp(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];
                  float32_t src2 =
                     _src[2].f32[_i];

               float32_t dst = src0 * (1 - src2) + src1 * src2;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];
                  float64_t src2 =
                     _src[2].f64[_i];

               float64_t dst = src0 * (1 - src2) + src1 * src2;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_flt(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               bool32_t dst = src0 < src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               bool32_t dst = src0 < src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fmax(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = fmaxf(src0, src1);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = fmaxf(src0, src1);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fmin(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = fminf(src0, src1);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = fminf(src0, src1);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fmod(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = src0 - src1 * floorf(src0 / src1);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = src0 - src1 * floorf(src0 / src1);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fmov(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fmul(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = src0 * src1;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = src0 * src1;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fne(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               bool32_t dst = src0 != src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               bool32_t dst = src0 != src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fneg(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = -src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = -src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_1(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise1_4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_1(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise2_4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_1(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise3_4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_1(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnoise4_4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         struct float32_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
   case 64: {
      

            
         struct float64_vec dst;

            dst.x = dst.y = dst.z = dst.w = 0.0f;

               _dst_val.f64[0] = dst.x;
               _dst_val.f64[1] = dst.y;
               _dst_val.f64[2] = dst.z;
               _dst_val.f64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fnot(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? ((src0 == 0.0) ? 1.0 : 0.0f) : ((src0 == 0.0f) ? 1.0f : 0.0f);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? ((src0 == 0.0) ? 1.0 : 0.0f) : ((src0 == 0.0f) ? 1.0f : 0.0f);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_for(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = ((src0 != 0.0f) || (src1 != 0.0f)) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = ((src0 != 0.0f) || (src1 != 0.0f)) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fpow(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = bit_size == 64 ? powf(src0, src1) : pow(src0, src1);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = bit_size == 64 ? powf(src0, src1) : pow(src0, src1);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fquantize2f16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = (fabs(src0) < ldexpf(1.0, -14)) ? copysignf(0.0f, src0) : _mesa_half_to_float(_mesa_float_to_half(src0));

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = (fabs(src0) < ldexpf(1.0, -14)) ? copysignf(0.0f, src0) : _mesa_half_to_float(_mesa_float_to_half(src0));

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_frcp(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? 1.0 / src0 : 1.0f / src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? 1.0 / src0 : 1.0f / src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_frem(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = src0 - src1 * truncf(src0 / src1);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = src0 - src1 * truncf(src0 / src1);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fround_even(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? _mesa_roundeven(src0) : _mesa_roundevenf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? _mesa_roundeven(src0) : _mesa_roundevenf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_frsq(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? 1.0 / sqrt(src0) : 1.0f / sqrtf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? 1.0 / sqrt(src0) : 1.0f / sqrtf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fsat(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? ((src0 > 1.0) ? 1.0 : ((src0 <= 0.0) ? 0.0 : src0)) : ((src0 > 1.0f) ? 1.0f : ((src0 <= 0.0f) ? 0.0f : src0));

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? ((src0 > 1.0) ? 1.0 : ((src0 <= 0.0) ? 0.0 : src0)) : ((src0 > 1.0f) ? 1.0f : ((src0 <= 0.0f) ? 0.0f : src0));

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fsign(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? ((src0 == 0.0) ? 0.0 : ((src0 > 0.0) ? 1.0 : -1.0)) : ((src0 == 0.0f) ? 0.0f : ((src0 > 0.0f) ? 1.0f : -1.0f));

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? ((src0 == 0.0) ? 0.0 : ((src0 > 0.0) ? 1.0 : -1.0)) : ((src0 == 0.0f) ? 0.0f : ((src0 > 0.0f) ? 1.0f : -1.0f));

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fsin(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? sin(src0) : sinf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? sin(src0) : sinf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fsqrt(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? sqrt(src0) : sqrtf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? sqrt(src0) : sqrtf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fsub(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = src0 - src1;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  float64_t src1 =
                     _src[1].f64[_i];

               float64_t dst = src0 - src1;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ftrunc(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];

               float32_t dst = bit_size == 64 ? trunc(src0) : truncf(src0);

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];

               float64_t dst = bit_size == 64 ? trunc(src0) : truncf(src0);

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_fxor(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 != 0.0f && src1 == 0.0f) || (src0 == 0.0f && src1 != 0.0f) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 != 0.0f && src1 == 0.0f) || (src0 == 0.0f && src1 != 0.0f) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_i2b(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               bool32_t dst = src0 != 0;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               bool32_t dst = src0 != 0;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_i2d(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               float64_t dst = src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               float64_t dst = src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_i2f(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               float32_t dst = src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               float32_t dst = src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_iabs(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst = (src0 < 0) ? -src0 : src0;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];

               int64_t dst = (src0 < 0) ? -src0 : src0;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_iadd(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src0 + src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src0 + src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_iand(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src0 & src1;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src0 & src1;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ibfe(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               int32_t dst;
               
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               int32_t dst;
               
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ibitfield_extract(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               int32_t dst;
               
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || offset + bits > 32) {
   dst = 0;
} else {
   dst = (base << (32 - offset - bits)) >> offset; /* use sign-extending shift */
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               int32_t dst;
               
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || offset + bits > 32) {
   dst = 0;
} else {
   dst = (base << (32 - offset - bits)) >> offset; /* use sign-extending shift */
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_idiv(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src0 / src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src0 / src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ieq(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               bool32_t dst = src0 == src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               bool32_t dst = src0 == src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ifind_msb(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst;
               
dst = -1;
for (int bit = 31; bit >= 0; bit--) {
   /* If src0 < 0, we're looking for the first 0 bit.
    * if src0 >= 0, we're looking for the first 1 bit.
    */
   if ((((src0 >> bit) & 1) && (src0 >= 0)) ||
      (!((src0 >> bit) & 1) && (src0 < 0))) {
      dst = bit;
      break;
   }
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst;
               
dst = -1;
for (int bit = 31; bit >= 0; bit--) {
   /* If src0 < 0, we're looking for the first 0 bit.
    * if src0 >= 0, we're looking for the first 1 bit.
    */
   if ((((src0 >> bit) & 1) && (src0 >= 0)) ||
      (!((src0 >> bit) & 1) && (src0 < 0))) {
      dst = bit;
      break;
   }
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ige(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               bool32_t dst = src0 >= src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               bool32_t dst = src0 >= src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ilt(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               bool32_t dst = src0 < src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               bool32_t dst = src0 < src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_imax(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src1 > src0 ? src1 : src0;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src1 > src0 ? src1 : src0;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_imin(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src1 > src0 ? src0 : src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src1 > src0 ? src0 : src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_imod(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src1 == 0 ? 0 : ((src0 % src1 == 0 || (src0 >= 0) == (src1 >= 0)) ?                 src0 % src1 : src0 % src1 + src1);

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src1 == 0 ? 0 : ((src0 % src1 == 0 || (src0 >= 0) == (src1 >= 0)) ?                 src0 % src1 : src0 % src1 + src1);

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_imov(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst = src0;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];

               int64_t dst = src0;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_imul(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src0 * src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src0 * src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_imul_high(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = (int32_t)(((int64_t) src0 * (int64_t) src1) >> 32);

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = (int32_t)(((int64_t) src0 * (int64_t) src1) >> 32);

               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ine(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               bool32_t dst = src0 != src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               bool32_t dst = src0 != src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ineg(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst = -src0;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];

               int64_t dst = -src0;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_inot(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst = ~src0;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];

               int64_t dst = ~src0;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ior(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src0 | src1;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src0 | src1;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_irem(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src1 == 0 ? 0 : src0 % src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src1 == 0 ? 0 : src0 % src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ishl(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src0 << src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src0 << src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ishr(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src0 >> src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src0 >> src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_isign(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];

               int32_t dst = (src0 == 0) ? 0 : ((src0 > 0) ? 1 : -1);

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];

               int64_t dst = (src0 == 0) ? 0 : ((src0 > 0) ? 1 : -1);

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_isub(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst = src0 - src1;

               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int64_t src0 =
                     _src[0].i64[_i];
                  int64_t src1 =
                     _src[1].i64[_i];

               int64_t dst = src0 - src1;

               _dst_val.i64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ixor(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src0 ^ src1;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src0 ^ src1;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ldexp(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               float32_t dst;
               
dst = (bit_size == 64) ? ldexp(src0, src1) : ldexpf(src0, src1);
/* flush denormals to zero. */
if (!isnormal(dst))
   dst = copysignf(0.0f, src0);


               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float64_t src0 =
                     _src[0].f64[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               float64_t dst;
               
dst = (bit_size == 64) ? ldexp(src0, src1) : ldexpf(src0, src1);
/* flush denormals to zero. */
if (!isnormal(dst))
   dst = copysignf(0.0f, src0);


               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_double_2x32(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
               _src[0].u32[1],
         };

         struct uint64_vec dst;

            dst.x = src0.x | ((uint64_t)src0.y << 32);

               _dst_val.u64[0] = dst.x;

      break;
   }
   case 64: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
               _src[0].u32[1],
         };

         struct uint64_vec dst;

            dst.x = src0.x | ((uint64_t)src0.y << 32);

               _dst_val.u64[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_double_2x32_split(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint64_t dst = src0 | ((uint64_t)src1 << 32);

               _dst_val.u64[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint64_t dst = src0 | ((uint64_t)src1 << 32);

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_half_2x16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_half_1x16(src0.x);
dst.x |= ((uint32_t) pack_half_1x16(src0.y)) << 16;


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_half_1x16(src0.x);
dst.x |= ((uint32_t) pack_half_1x16(src0.y)) << 16;


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_half_2x16_split(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
         };

         struct uint32_vec dst;

            dst.x = dst.y = dst.z = dst.w = pack_half_1x16(src0.x) | (pack_half_1x16(src1.x) << 16);

               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
         };

         struct float32_vec src1 = {
               _src[1].f32[0],
         };

         struct uint32_vec dst;

            dst.x = dst.y = dst.z = dst.w = pack_half_1x16(src0.x) | (pack_half_1x16(src1.x) << 16);

               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_snorm_2x16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_snorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x16(src0.y)) << 16;


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_snorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x16(src0.y)) << 16;


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_snorm_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_snorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.w)) << 24;


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_snorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.w)) << 24;


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_unorm_2x16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_unorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x16(src0.y)) << 16;


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_unorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x16(src0.y)) << 16;


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_unorm_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_unorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.w)) << 24;


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct float32_vec src0 = {
               _src[0].f32[0],
               _src[0].f32[1],
               _src[0].f32[2],
               _src[0].f32[3],
         };

         struct uint32_vec dst;

            
dst.x = (uint32_t) pack_unorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.w)) << 24;


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_uvec2_to_uint(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
               _src[0].u32[1],
         };

         struct uint32_vec dst;

            
dst.x = (src0.x & 0xffff) | (src0.y << 16);


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
               _src[0].u32[1],
         };

         struct uint32_vec dst;

            
dst.x = (src0.x & 0xffff) | (src0.y << 16);


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_pack_uvec4_to_uint(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
               _src[0].u32[1],
               _src[0].u32[2],
               _src[0].u32[3],
         };

         struct uint32_vec dst;

            
dst.x = (src0.x <<  0) |
        (src0.y <<  8) |
        (src0.z << 16) |
        (src0.w << 24);


               _dst_val.u32[0] = dst.x;

      break;
   }
   case 64: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
               _src[0].u32[1],
               _src[0].u32[2],
               _src[0].u32[3],
         };

         struct uint32_vec dst;

            
dst.x = (src0.x <<  0) |
        (src0.y <<  8) |
        (src0.z << 16) |
        (src0.w << 24);


               _dst_val.u32[0] = dst.x;

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_seq(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 == src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 == src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_sge(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 >= src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 >= src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_slt(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 < src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 < src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_sne(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 != src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  float32_t src0 =
                     _src[0].f32[_i];
                  float32_t src1 =
                     _src[1].f32[_i];

               float32_t dst = (src0 != src1) ? 1.0f : 0.0f;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_u2d(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];

               float64_t dst = src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];

               float64_t dst = src0;

               _dst_val.f64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_u2f(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];

               float32_t dst = src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];

               float32_t dst = src0;

               _dst_val.f32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_uadd_carry(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src0 + src1 < src0;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src0 + src1 < src0;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ubfe(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               uint32_t dst;
               
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}


               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               uint32_t dst;
               
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}


               _dst_val.u32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ubitfield_extract(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               uint32_t dst;
               
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0 || offset + bits > 32) {
   dst = 0; /* undefined per the spec */
} else {
   dst = (base >> offset) & ((1ull << bits) - 1);
}


               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                                    
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
                  int32_t src2 =
                     _src[2].i32[_i];

               uint32_t dst;
               
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0 || offset + bits > 32) {
   dst = 0; /* undefined per the spec */
} else {
   dst = (base >> offset) & ((1ull << bits) - 1);
}


               _dst_val.u32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_udiv(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src0 / src1;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src0 / src1;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ufind_msb(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];

               int32_t dst;
               
dst = -1;
for (int bit = 31; bit > 0; bit--) {
   if ((src0 >> bit) & 1) {
      dst = bit;
      break;
   }
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];

               int32_t dst;
               
dst = -1;
for (int bit = 31; bit > 0; bit--) {
   if ((src0 >> bit) & 1) {
      dst = bit;
      break;
   }
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_uge(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               bool32_t dst = src0 >= src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               bool32_t dst = src0 >= src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_ult(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               bool32_t dst = src0 < src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               bool32_t dst = src0 < src1;

               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_umax(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src1 > src0 ? src1 : src0;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src1 > src0 ? src1 : src0;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_umax_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MAX2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MAX2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_umin(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];

               uint32_t dst = src1 > src0 ? src0 : src1;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];

               uint64_t dst = src1 > src0 ? src0 : src1;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
static nir_const_value
evaluate_umin_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MIN2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
}


               _dst_val.i32[_i] = dst;
         }

      break;
   }
   case 64: {
      
d2496 2
a2497 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d2499 1
a2499 5
               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MIN2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
d2501 4
d2506 4
d2511 1
a2511 5
               _dst_val.i32[_i] = dst;
         }

      break;
   }
d2513 2
a2514 3
   default:
      unreachable("unknown bit width");
   }
d2519 1
a2519 2
evaluate_umod(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2521 5
a2525 1
   nir_const_value _dst_val = { {0, } };
d2527 1
a2527 3
   switch (bit_size) {
   case 32: {
      
d2529 2
a2530 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d2532 6
a2537 1
               uint32_t dst = src1 == 0 ? 0 : src0 % src1;
d2539 3
a2541 2
               _dst_val.u32[_i] = dst;
         }
d2543 1
a2543 4
      break;
   }
   case 64: {
      
d2545 2
a2546 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];
d2548 6
a2553 1
               uint64_t dst = src1 == 0 ? 0 : src0 % src1;
d2555 4
a2558 2
               _dst_val.u64[_i] = dst;
         }
d2560 1
a2560 2
      break;
   }
d2562 2
a2563 3
   default:
      unreachable("unknown bit width");
   }
d2568 1
a2568 2
evaluate_umul_high(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2570 1
a2570 1
   nir_const_value _dst_val = { {0, } };
d2572 6
a2577 3
   switch (bit_size) {
   case 32: {
      
d2579 2
a2580 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d2582 6
a2587 1
               uint32_t dst = (uint32_t)(((uint64_t) src0 * (uint64_t) src1) >> 32);
d2589 4
a2592 2
               _dst_val.u32[_i] = dst;
         }
d2594 1
a2594 4
      break;
   }
   case 64: {
      
d2596 2
a2597 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d2599 6
a2604 1
               uint32_t dst = (uint32_t)(((uint64_t) src0 * (uint64_t) src1) >> 32);
d2606 3
a2608 2
               _dst_val.u32[_i] = dst;
         }
d2610 1
a2610 2
      break;
   }
d2612 2
a2613 3
   default:
      unreachable("unknown bit width");
   }
d2618 1
a2618 2
evaluate_umul_unorm_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2620 1
a2620 1
   nir_const_value _dst_val = { {0, } };
d2622 6
a2627 3
   switch (bit_size) {
   case 32: {
      
d2629 2
a2630 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d2632 1
a2632 7
               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   dst |= ((src0_chan * src1_chan) / 255) << i;
d2634 4
d2639 4
d2644 1
a2644 2
               _dst_val.i32[_i] = dst;
         }
d2646 2
a2647 4
      break;
   }
   case 64: {
      
d2649 1
a2649 14
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   dst |= ((src0_chan * src1_chan) / 255) << i;
d2651 4
d2656 4
d2661 6
a2666 2
               _dst_val.i32[_i] = dst;
         }
a2667 2
      break;
   }
d2669 2
a2670 3
   default:
      unreachable("unknown bit width");
   }
d2675 1
a2675 2
evaluate_unpack_double_2x32(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2677 1
a2677 1
   nir_const_value _dst_val = { {0, } };
a2678 3
   switch (bit_size) {
   case 32: {
      
d2680 4
d2685 1
a2685 3
         struct uint64_vec src0 = {
               _src[0].u64[0],
         };
d2687 3
a2689 1
         struct uint32_vec dst;
a2690 1
            dst.x = src0.x; dst.y = src0.x >> 32;
d2692 1
a2692 2
               _dst_val.u32[0] = dst.x;
               _dst_val.u32[1] = dst.y;
d2694 6
a2699 4
      break;
   }
   case 64: {
      
d2702 3
a2704 3
         struct uint64_vec src0 = {
               _src[0].u64[0],
         };
d2706 3
a2708 1
         struct uint32_vec dst;
d2710 1
a2710 1
            dst.x = src0.x; dst.y = src0.x >> 32;
d2712 1
a2712 2
               _dst_val.u32[0] = dst.x;
               _dst_val.u32[1] = dst.y;
d2714 1
a2714 6
      break;
   }

   default:
      unreachable("unknown bit width");
   }
d2719 1
a2719 2
evaluate_unpack_double_2x32_split_x(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2721 1
a2721 1
   nir_const_value _dst_val = { {0, } };
a2722 3
   switch (bit_size) {
   case 32: {
      
d2724 11
a2734 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
d2736 1
a2736 1
               uint32_t dst = src0;
d2738 6
a2743 2
               _dst_val.u32[_i] = dst;
         }
a2744 4
      break;
   }
   case 64: {
      
d2746 6
a2751 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
d2753 1
a2753 1
               uint32_t dst = src0;
d2755 5
a2759 2
               _dst_val.u32[_i] = dst;
         }
a2760 2
      break;
   }
d2762 1
a2762 3
   default:
      unreachable("unknown bit width");
   }
d2767 1
a2767 2
evaluate_unpack_double_2x32_split_y(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2769 1
a2769 1
   nir_const_value _dst_val = { {0, } };
a2770 3
   switch (bit_size) {
   case 32: {
      
d2772 4
a2775 4
            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
d2777 1
a2777 1
               uint32_t dst = src0 >> 32;
d2779 3
a2781 12
               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      

            
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
a2782 7
               uint32_t dst = src0 >> 32;

               _dst_val.u32[_i] = dst;
         }

      break;
   }
d2784 1
a2784 3
   default:
      unreachable("unknown bit width");
   }
d2789 1
a2789 2
evaluate_unpack_half_2x16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2791 1
a2791 1
   nir_const_value _dst_val = { {0, } };
a2792 3
   switch (bit_size) {
   case 32: {
      
d2794 6
d2801 1
a2801 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d2803 5
a2807 5
         struct float32_vec dst;

            
dst.x = unpack_half_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_half_1x16((uint16_t)(src0.x << 16));
d2810 1
a2810 7
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;

      break;
   }
   case 64: {
      
d2812 6
a2818 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d2820 4
a2823 5
         struct float32_vec dst;

            
dst.x = unpack_half_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_half_1x16((uint16_t)(src0.x << 16));
d2825 1
d2827 2
a2828 2
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
a2829 2
      break;
   }
d2831 1
a2831 3
   default:
      unreachable("unknown bit width");
   }
d2836 1
a2836 2
evaluate_unpack_half_2x16_split_x(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2838 1
a2838 1
   nir_const_value _dst_val = { {0, } };
a2839 3
   switch (bit_size) {
   case 32: {
      
d2841 6
d2848 1
a2848 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d2850 5
a2854 1
         struct float32_vec dst;
a2855 1
            dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x & 0xffff));
d2857 1
a2857 1
               _dst_val.f32[0] = dst.x;
d2859 6
a2864 4
      break;
   }
   case 64: {
      
d2866 4
d2871 1
a2871 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d2873 2
a2874 1
         struct float32_vec dst;
d2876 6
a2881 1
            dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x & 0xffff));
d2883 4
a2886 1
               _dst_val.f32[0] = dst.x;
d2888 1
a2888 2
      break;
   }
d2890 2
a2891 3
   default:
      unreachable("unknown bit width");
   }
d2896 1
a2896 2
evaluate_unpack_half_2x16_split_y(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2898 6
a2903 1
   nir_const_value _dst_val = { {0, } };
d2905 1
a2905 3
   switch (bit_size) {
   case 32: {
      
d2907 2
d2910 6
a2915 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d2917 4
a2920 1
         struct float32_vec dst;
d2922 1
a2922 1
            dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x >> 16));
d2924 2
a2925 1
               _dst_val.f32[0] = dst.x;
d2927 6
a2932 4
      break;
   }
   case 64: {
      
d2934 3
d2938 1
a2938 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d2940 2
a2941 1
         struct float32_vec dst;
d2943 6
a2948 1
            dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x >> 16));
d2950 4
a2953 1
               _dst_val.f32[0] = dst.x;
d2955 1
a2955 2
      break;
   }
d2957 2
a2958 3
   default:
      unreachable("unknown bit width");
   }
d2963 1
a2963 2
evaluate_unpack_snorm_2x16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d2965 1
a2965 5
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      
d2967 5
d2973 1
a2973 6
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };

         struct float32_vec dst;

d2975 11
a2985 2
dst.x = unpack_snorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_snorm_1x16((uint16_t)(src0.x << 16));
d2988 2
a2989 2
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
d2991 6
a2996 4
      break;
   }
   case 64: {
      
d2998 5
d3004 11
a3014 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
a3015 1
         struct float32_vec dst;
d3017 2
a3018 3
            
dst.x = unpack_snorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_snorm_1x16((uint16_t)(src0.x << 16));
d3020 6
d3027 4
a3030 2
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
d3032 1
a3032 2
      break;
   }
d3034 2
a3035 3
   default:
      unreachable("unknown bit width");
   }
d3040 1
a3040 2
evaluate_unpack_snorm_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3042 1
a3042 6
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   case 32: {
      

d3044 3
a3046 5
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };

         struct float32_vec dst;
d3048 1
d3050 4
a3053 11
dst.x = unpack_snorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_snorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_snorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_snorm_1x8((uint8_t)(src0.x >> 24));


               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

d3056 1
a3056 2
   case 64: {
      
d3059 2
a3060 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d3062 6
a3067 7
         struct float32_vec dst;

            
dst.x = unpack_snorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_snorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_snorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_snorm_1x8((uint8_t)(src0.x >> 24));
d3069 4
d3074 1
a3074 4
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;
d3076 2
a3077 6
      break;
   }

   default:
      unreachable("unknown bit width");
   }
d3082 1
a3082 2
evaluate_unpack_unorm_2x16(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3084 1
a3084 1
   nir_const_value _dst_val = { {0, } };
d3086 4
a3089 3
   switch (bit_size) {
   case 32: {
      
d3091 1
d3093 2
a3094 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d3096 6
a3101 1
         struct float32_vec dst;
d3103 4
a3106 3
            
dst.x = unpack_unorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_unorm_1x16((uint16_t)(src0.x << 16));
d3108 1
d3110 2
a3111 2
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
d3113 6
a3118 4
      break;
   }
   case 64: {
      
d3120 4
d3125 6
a3130 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
a3131 1
         struct float32_vec dst;
d3133 2
a3134 3
            
dst.x = unpack_unorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_unorm_1x16((uint16_t)(src0.x << 16));
d3136 6
d3143 4
a3146 2
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
d3148 1
a3148 2
      break;
   }
d3150 2
a3151 3
   default:
      unreachable("unknown bit width");
   }
d3156 1
a3156 2
evaluate_unpack_unorm_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3158 1
a3158 1
   nir_const_value _dst_val = { {0, } };
d3160 4
a3163 10
   switch (bit_size) {
   case 32: {
      


         struct uint32_vec src0 = {
               _src[0].u32[0],
         };

         struct float32_vec dst;
d3165 1
d3167 4
a3170 4
dst.x = unpack_unorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_unorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_unorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_unorm_1x8((uint8_t)(src0.x >> 24));
d3173 2
a3174 4
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;
d3176 6
a3181 4
      break;
   }
   case 64: {
      
d3183 4
d3188 1
a3188 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d3190 2
a3191 1
         struct float32_vec dst;
d3193 6
a3198 5
            
dst.x = unpack_unorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_unorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_unorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_unorm_1x8((uint8_t)(src0.x >> 24));
d3200 4
d3205 1
a3205 7
               _dst_val.f32[0] = dst.x;
               _dst_val.f32[1] = dst.y;
               _dst_val.f32[2] = dst.z;
               _dst_val.f32[3] = dst.w;

      break;
   }
d3207 2
a3208 3
   default:
      unreachable("unknown bit width");
   }
d3213 1
a3213 2
evaluate_usadd_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3215 1
a3215 1
   nir_const_value _dst_val = { {0, } };
d3217 4
a3220 3
   switch (bit_size) {
   case 32: {
      
d3222 2
a3223 9
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];

               int32_t dst;
               
d3226 3
a3228 1
   dst |= MIN2(((src0 >> i) & 0xff) + ((src1 >> i) & 0xff), 0xff) << i;
d3232 2
a3233 2
               _dst_val.i32[_i] = dst;
         }
d3235 6
a3240 4
      break;
   }
   case 64: {
      
a3241 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d3243 3
a3245 6
               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MIN2(((src0 >> i) & 0xff) + ((src1 >> i) & 0xff), 0xff) << i;
}
d3247 1
d3249 3
a3251 2
               _dst_val.i32[_i] = dst;
         }
a3252 2
      break;
   }
d3254 2
a3255 3
   default:
      unreachable("unknown bit width");
   }
d3260 1
a3260 2
evaluate_ushr(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3262 2
a3263 1
   nir_const_value _dst_val = { {0, } };
d3265 3
a3267 3
   switch (bit_size) {
   case 32: {
      
d3269 1
a3269 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d3271 1
a3271 1
               uint32_t dst = src0 >> src1;
d3273 1
a3273 2
               _dst_val.u32[_i] = dst;
         }
d3275 6
a3280 4
      break;
   }
   case 64: {
      
a3281 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];
d3283 3
a3285 1
               uint64_t dst = src0 >> src1;
d3287 1
a3287 2
               _dst_val.u64[_i] = dst;
         }
d3289 1
a3289 2
      break;
   }
d3291 1
a3291 3
   default:
      unreachable("unknown bit width");
   }
d3296 1
a3296 2
evaluate_ussub_4x8(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3298 2
a3299 1
   nir_const_value _dst_val = { {0, } };
d3301 3
a3303 3
   switch (bit_size) {
   case 32: {
      
d3305 1
a3305 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d3307 3
a3309 9
               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   if (src0_chan > src1_chan)
      dst |= (src0_chan - src1_chan) << i;
}
d3312 2
a3313 2
               _dst_val.i32[_i] = dst;
         }
d3315 6
a3320 4
      break;
   }
   case 64: {
      
a3321 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  int32_t src0 =
                     _src[0].i32[_i];
                  int32_t src1 =
                     _src[1].i32[_i];
d3323 3
a3325 9
               int32_t dst;
               
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   if (src0_chan > src1_chan)
      dst |= (src0_chan - src1_chan) << i;
}
d3327 1
d3329 5
a3333 2
               _dst_val.i32[_i] = dst;
         }
a3334 2
      break;
   }
d3336 4
a3339 3
   default:
      unreachable("unknown bit width");
   }
d3344 1
a3344 2
evaluate_usub_borrow(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3346 1
a3346 1
   nir_const_value _dst_val = { {0, } };
a3347 3
   switch (bit_size) {
   case 32: {
      
d3349 3
a3351 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint32_t src0 =
                     _src[0].u32[_i];
                  uint32_t src1 =
                     _src[1].u32[_i];
d3353 1
a3353 1
               uint32_t dst = src0 < src1;
d3355 3
a3357 7
               _dst_val.u32[_i] = dst;
         }

      break;
   }
   case 64: {
      
a3358 6
                        
         for (unsigned _i = 0; _i < num_components; _i++) {
                  uint64_t src0 =
                     _src[0].u64[_i];
                  uint64_t src1 =
                     _src[1].u64[_i];
d3360 2
a3361 11
               uint64_t dst = src0 < src1;

               _dst_val.u64[_i] = dst;
         }

      break;
   }

   default:
      unreachable("unknown bit width");
   }
d3366 1
a3366 2
evaluate_vec2(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3368 1
a3368 1
   nir_const_value _dst_val = { {0, } };
a3369 3
   switch (bit_size) {
   case 32: {
      
d3371 3
d3375 1
a3375 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d3377 5
a3381 3
         struct uint32_vec src1 = {
               _src[1].u32[0],
         };
a3382 1
         struct uint32_vec dst;
d3384 4
a3387 3
            
dst.x = src0.x;
dst.y = src1.x;
d3389 6
d3396 4
a3399 2
               _dst_val.u32[0] = dst.x;
               _dst_val.u32[1] = dst.y;
d3401 6
a3406 4
      break;
   }
   case 64: {
      
d3409 2
a3410 3
         struct uint64_vec src0 = {
               _src[0].u64[0],
         };
d3412 6
a3417 3
         struct uint64_vec src1 = {
               _src[1].u64[0],
         };
d3419 4
a3422 9
         struct uint64_vec dst;

            
dst.x = src0.x;
dst.y = src1.x;


               _dst_val.u64[0] = dst.x;
               _dst_val.u64[1] = dst.y;
d3424 1
a3424 2
      break;
   }
d3426 2
a3427 3
   default:
      unreachable("unknown bit width");
   }
d3432 1
a3432 2
evaluate_vec3(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3434 1
a3434 1
   nir_const_value _dst_val = { {0, } };
d3436 4
a3439 3
   switch (bit_size) {
   case 32: {
      
d3441 9
a3450 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d3452 2
a3453 3
         struct uint32_vec src1 = {
               _src[1].u32[0],
         };
d3455 6
a3460 3
         struct uint32_vec src2 = {
               _src[2].u32[0],
         };
d3462 4
a3465 6
         struct uint32_vec dst;

            
dst.x = src0.x;
dst.y = src1.x;
dst.z = src2.x;
d3467 1
d3469 2
a3470 3
               _dst_val.u32[0] = dst.x;
               _dst_val.u32[1] = dst.y;
               _dst_val.u32[2] = dst.z;
d3472 6
a3477 4
      break;
   }
   case 64: {
      
d3480 3
a3482 3
         struct uint64_vec src0 = {
               _src[0].u64[0],
         };
d3484 3
a3486 3
         struct uint64_vec src1 = {
               _src[1].u64[0],
         };
d3488 1
a3488 3
         struct uint64_vec src2 = {
               _src[2].u64[0],
         };
d3490 1
a3490 3
         struct uint64_vec dst;

            
a3492 2
dst.z = src2.x;

a3493 3
               _dst_val.u64[0] = dst.x;
               _dst_val.u64[1] = dst.y;
               _dst_val.u64[2] = dst.z;
d3495 2
a3496 6
      break;
   }

   default:
      unreachable("unknown bit width");
   }
d3501 1
a3501 2
evaluate_vec4(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d3503 1
a3503 1
   nir_const_value _dst_val = { {0, } };
a3504 3
   switch (bit_size) {
   case 32: {
      
d3506 3
d3510 3
a3512 3
         struct uint32_vec src0 = {
               _src[0].u32[0],
         };
d3514 3
a3516 3
         struct uint32_vec src1 = {
               _src[1].u32[0],
         };
d3518 1
a3518 3
         struct uint32_vec src2 = {
               _src[2].u32[0],
         };
d3520 1
a3520 7
         struct uint32_vec src3 = {
               _src[3].u32[0],
         };

         struct uint32_vec dst;

            
a3523 1
dst.w = src3.x;
d3526 3
a3528 4
               _dst_val.u32[0] = dst.x;
               _dst_val.u32[1] = dst.y;
               _dst_val.u32[2] = dst.z;
               _dst_val.u32[3] = dst.w;
d3530 6
a3535 4
      break;
   }
   case 64: {
      
d3538 3
a3540 3
         struct uint64_vec src0 = {
               _src[0].u64[0],
         };
d3542 3
a3544 3
         struct uint64_vec src1 = {
               _src[1].u64[0],
         };
d3546 3
a3548 3
         struct uint64_vec src2 = {
               _src[2].u64[0],
         };
d3550 3
a3552 3
         struct uint64_vec src3 = {
               _src[3].u64[0],
         };
d3554 1
a3554 1
         struct uint64_vec dst;
d3556 1
a3556 1
            
d3563 4
a3566 11
               _dst_val.u64[0] = dst.x;
               _dst_val.u64[1] = dst.y;
               _dst_val.u64[2] = dst.z;
               _dst_val.u64[3] = dst.w;

      break;
   }

   default:
      unreachable("unknown bit width");
   }
d3573 1
a3573 1
                      unsigned bit_width, nir_const_value *src)
d3577 1
a3577 1
      return evaluate_b2f(num_components, bit_width, src);
d3581 1
a3581 1
      return evaluate_b2i(num_components, bit_width, src);
d3585 1
a3585 1
      return evaluate_ball_fequal2(num_components, bit_width, src);
d3589 1
a3589 1
      return evaluate_ball_fequal3(num_components, bit_width, src);
d3593 1
a3593 1
      return evaluate_ball_fequal4(num_components, bit_width, src);
d3597 1
a3597 1
      return evaluate_ball_iequal2(num_components, bit_width, src);
d3601 1
a3601 1
      return evaluate_ball_iequal3(num_components, bit_width, src);
d3605 1
a3605 1
      return evaluate_ball_iequal4(num_components, bit_width, src);
d3609 1
a3609 1
      return evaluate_bany_fnequal2(num_components, bit_width, src);
d3613 1
a3613 1
      return evaluate_bany_fnequal3(num_components, bit_width, src);
d3617 1
a3617 1
      return evaluate_bany_fnequal4(num_components, bit_width, src);
d3621 1
a3621 1
      return evaluate_bany_inequal2(num_components, bit_width, src);
d3625 1
a3625 1
      return evaluate_bany_inequal3(num_components, bit_width, src);
d3629 1
a3629 1
      return evaluate_bany_inequal4(num_components, bit_width, src);
d3633 1
a3633 1
      return evaluate_bcsel(num_components, bit_width, src);
d3637 1
a3637 1
      return evaluate_bfi(num_components, bit_width, src);
d3641 1
a3641 1
      return evaluate_bfm(num_components, bit_width, src);
d3645 1
a3645 1
      return evaluate_bit_count(num_components, bit_width, src);
d3649 1
a3649 1
      return evaluate_bitfield_insert(num_components, bit_width, src);
d3653 1
a3653 17
      return evaluate_bitfield_reverse(num_components, bit_width, src);
      break;
   }
   case nir_op_d2b: {
      return evaluate_d2b(num_components, bit_width, src);
      break;
   }
   case nir_op_d2f: {
      return evaluate_d2f(num_components, bit_width, src);
      break;
   }
   case nir_op_d2i: {
      return evaluate_d2i(num_components, bit_width, src);
      break;
   }
   case nir_op_d2u: {
      return evaluate_d2u(num_components, bit_width, src);
d3657 1
a3657 1
      return evaluate_extract_i16(num_components, bit_width, src);
d3661 1
a3661 1
      return evaluate_extract_i8(num_components, bit_width, src);
d3665 1
a3665 1
      return evaluate_extract_u16(num_components, bit_width, src);
d3669 1
a3669 1
      return evaluate_extract_u8(num_components, bit_width, src);
d3673 1
a3673 5
      return evaluate_f2b(num_components, bit_width, src);
      break;
   }
   case nir_op_f2d: {
      return evaluate_f2d(num_components, bit_width, src);
d3677 1
a3677 1
      return evaluate_f2i(num_components, bit_width, src);
d3681 1
a3681 1
      return evaluate_f2u(num_components, bit_width, src);
d3685 1
a3685 1
      return evaluate_fabs(num_components, bit_width, src);
d3689 1
a3689 1
      return evaluate_fadd(num_components, bit_width, src);
d3693 1
a3693 1
      return evaluate_fall_equal2(num_components, bit_width, src);
d3697 1
a3697 1
      return evaluate_fall_equal3(num_components, bit_width, src);
d3701 1
a3701 1
      return evaluate_fall_equal4(num_components, bit_width, src);
d3705 1
a3705 1
      return evaluate_fand(num_components, bit_width, src);
d3709 1
a3709 1
      return evaluate_fany_nequal2(num_components, bit_width, src);
d3713 1
a3713 1
      return evaluate_fany_nequal3(num_components, bit_width, src);
d3717 1
a3717 1
      return evaluate_fany_nequal4(num_components, bit_width, src);
d3721 1
a3721 1
      return evaluate_fceil(num_components, bit_width, src);
d3725 1
a3725 1
      return evaluate_fcos(num_components, bit_width, src);
d3729 1
a3729 1
      return evaluate_fcsel(num_components, bit_width, src);
d3733 1
a3733 1
      return evaluate_fddx(num_components, bit_width, src);
d3737 1
a3737 1
      return evaluate_fddx_coarse(num_components, bit_width, src);
d3741 1
a3741 1
      return evaluate_fddx_fine(num_components, bit_width, src);
d3745 1
a3745 1
      return evaluate_fddy(num_components, bit_width, src);
d3749 1
a3749 1
      return evaluate_fddy_coarse(num_components, bit_width, src);
d3753 1
a3753 1
      return evaluate_fddy_fine(num_components, bit_width, src);
d3757 1
a3757 1
      return evaluate_fdiv(num_components, bit_width, src);
d3761 1
a3761 1
      return evaluate_fdot2(num_components, bit_width, src);
d3765 1
a3765 1
      return evaluate_fdot3(num_components, bit_width, src);
d3769 1
a3769 1
      return evaluate_fdot4(num_components, bit_width, src);
d3773 1
a3773 1
      return evaluate_fdot_replicated2(num_components, bit_width, src);
d3777 1
a3777 1
      return evaluate_fdot_replicated3(num_components, bit_width, src);
d3781 1
a3781 1
      return evaluate_fdot_replicated4(num_components, bit_width, src);
d3785 1
a3785 1
      return evaluate_fdph(num_components, bit_width, src);
d3789 1
a3789 1
      return evaluate_fdph_replicated(num_components, bit_width, src);
d3793 1
a3793 1
      return evaluate_feq(num_components, bit_width, src);
d3797 1
a3797 1
      return evaluate_fexp2(num_components, bit_width, src);
d3801 1
a3801 1
      return evaluate_ffloor(num_components, bit_width, src);
d3805 1
a3805 1
      return evaluate_ffma(num_components, bit_width, src);
d3809 1
a3809 1
      return evaluate_ffract(num_components, bit_width, src);
d3813 1
a3813 1
      return evaluate_fge(num_components, bit_width, src);
d3817 1
a3817 1
      return evaluate_find_lsb(num_components, bit_width, src);
d3821 1
a3821 1
      return evaluate_flog2(num_components, bit_width, src);
d3825 1
a3825 1
      return evaluate_flrp(num_components, bit_width, src);
d3829 1
a3829 1
      return evaluate_flt(num_components, bit_width, src);
d3833 1
a3833 1
      return evaluate_fmax(num_components, bit_width, src);
d3837 1
a3837 1
      return evaluate_fmin(num_components, bit_width, src);
d3841 1
a3841 1
      return evaluate_fmod(num_components, bit_width, src);
d3845 1
a3845 1
      return evaluate_fmov(num_components, bit_width, src);
d3849 1
a3849 1
      return evaluate_fmul(num_components, bit_width, src);
d3853 1
a3853 1
      return evaluate_fne(num_components, bit_width, src);
d3857 1
a3857 1
      return evaluate_fneg(num_components, bit_width, src);
d3861 1
a3861 1
      return evaluate_fnoise1_1(num_components, bit_width, src);
d3865 1
a3865 1
      return evaluate_fnoise1_2(num_components, bit_width, src);
d3869 1
a3869 1
      return evaluate_fnoise1_3(num_components, bit_width, src);
d3873 1
a3873 1
      return evaluate_fnoise1_4(num_components, bit_width, src);
d3877 1
a3877 1
      return evaluate_fnoise2_1(num_components, bit_width, src);
d3881 1
a3881 1
      return evaluate_fnoise2_2(num_components, bit_width, src);
d3885 1
a3885 1
      return evaluate_fnoise2_3(num_components, bit_width, src);
d3889 1
a3889 1
      return evaluate_fnoise2_4(num_components, bit_width, src);
d3893 1
a3893 1
      return evaluate_fnoise3_1(num_components, bit_width, src);
d3897 1
a3897 1
      return evaluate_fnoise3_2(num_components, bit_width, src);
d3901 1
a3901 1
      return evaluate_fnoise3_3(num_components, bit_width, src);
d3905 1
a3905 1
      return evaluate_fnoise3_4(num_components, bit_width, src);
d3909 1
a3909 1
      return evaluate_fnoise4_1(num_components, bit_width, src);
d3913 1
a3913 1
      return evaluate_fnoise4_2(num_components, bit_width, src);
d3917 1
a3917 1
      return evaluate_fnoise4_3(num_components, bit_width, src);
d3921 1
a3921 1
      return evaluate_fnoise4_4(num_components, bit_width, src);
d3925 1
a3925 1
      return evaluate_fnot(num_components, bit_width, src);
d3929 1
a3929 1
      return evaluate_for(num_components, bit_width, src);
d3933 1
a3933 5
      return evaluate_fpow(num_components, bit_width, src);
      break;
   }
   case nir_op_fquantize2f16: {
      return evaluate_fquantize2f16(num_components, bit_width, src);
d3937 1
a3937 5
      return evaluate_frcp(num_components, bit_width, src);
      break;
   }
   case nir_op_frem: {
      return evaluate_frem(num_components, bit_width, src);
d3941 1
a3941 1
      return evaluate_fround_even(num_components, bit_width, src);
d3945 1
a3945 1
      return evaluate_frsq(num_components, bit_width, src);
d3949 1
a3949 1
      return evaluate_fsat(num_components, bit_width, src);
d3953 1
a3953 1
      return evaluate_fsign(num_components, bit_width, src);
d3957 1
a3957 1
      return evaluate_fsin(num_components, bit_width, src);
d3961 1
a3961 1
      return evaluate_fsqrt(num_components, bit_width, src);
d3965 1
a3965 1
      return evaluate_fsub(num_components, bit_width, src);
d3969 1
a3969 1
      return evaluate_ftrunc(num_components, bit_width, src);
d3973 1
a3973 1
      return evaluate_fxor(num_components, bit_width, src);
d3977 1
a3977 5
      return evaluate_i2b(num_components, bit_width, src);
      break;
   }
   case nir_op_i2d: {
      return evaluate_i2d(num_components, bit_width, src);
d3981 1
a3981 1
      return evaluate_i2f(num_components, bit_width, src);
d3985 1
a3985 1
      return evaluate_iabs(num_components, bit_width, src);
d3989 1
a3989 1
      return evaluate_iadd(num_components, bit_width, src);
d3993 1
a3993 1
      return evaluate_iand(num_components, bit_width, src);
d3997 1
a3997 1
      return evaluate_ibfe(num_components, bit_width, src);
d4001 1
a4001 1
      return evaluate_ibitfield_extract(num_components, bit_width, src);
d4005 1
a4005 1
      return evaluate_idiv(num_components, bit_width, src);
d4009 1
a4009 1
      return evaluate_ieq(num_components, bit_width, src);
d4013 1
a4013 1
      return evaluate_ifind_msb(num_components, bit_width, src);
d4017 1
a4017 1
      return evaluate_ige(num_components, bit_width, src);
d4021 1
a4021 1
      return evaluate_ilt(num_components, bit_width, src);
d4025 1
a4025 1
      return evaluate_imax(num_components, bit_width, src);
d4029 1
a4029 5
      return evaluate_imin(num_components, bit_width, src);
      break;
   }
   case nir_op_imod: {
      return evaluate_imod(num_components, bit_width, src);
d4033 1
a4033 1
      return evaluate_imov(num_components, bit_width, src);
d4037 1
a4037 1
      return evaluate_imul(num_components, bit_width, src);
d4041 1
a4041 1
      return evaluate_imul_high(num_components, bit_width, src);
d4045 1
a4045 1
      return evaluate_ine(num_components, bit_width, src);
d4049 1
a4049 1
      return evaluate_ineg(num_components, bit_width, src);
d4053 1
a4053 1
      return evaluate_inot(num_components, bit_width, src);
d4057 1
a4057 5
      return evaluate_ior(num_components, bit_width, src);
      break;
   }
   case nir_op_irem: {
      return evaluate_irem(num_components, bit_width, src);
d4061 1
a4061 1
      return evaluate_ishl(num_components, bit_width, src);
d4065 1
a4065 1
      return evaluate_ishr(num_components, bit_width, src);
d4069 1
a4069 1
      return evaluate_isign(num_components, bit_width, src);
d4073 1
a4073 1
      return evaluate_isub(num_components, bit_width, src);
d4077 1
a4077 1
      return evaluate_ixor(num_components, bit_width, src);
d4081 1
a4081 9
      return evaluate_ldexp(num_components, bit_width, src);
      break;
   }
   case nir_op_pack_double_2x32: {
      return evaluate_pack_double_2x32(num_components, bit_width, src);
      break;
   }
   case nir_op_pack_double_2x32_split: {
      return evaluate_pack_double_2x32_split(num_components, bit_width, src);
d4085 1
a4085 1
      return evaluate_pack_half_2x16(num_components, bit_width, src);
d4089 1
a4089 1
      return evaluate_pack_half_2x16_split(num_components, bit_width, src);
d4093 1
a4093 1
      return evaluate_pack_snorm_2x16(num_components, bit_width, src);
d4097 1
a4097 1
      return evaluate_pack_snorm_4x8(num_components, bit_width, src);
d4101 1
a4101 1
      return evaluate_pack_unorm_2x16(num_components, bit_width, src);
d4105 1
a4105 1
      return evaluate_pack_unorm_4x8(num_components, bit_width, src);
d4109 1
a4109 1
      return evaluate_pack_uvec2_to_uint(num_components, bit_width, src);
d4113 1
a4113 1
      return evaluate_pack_uvec4_to_uint(num_components, bit_width, src);
d4117 1
a4117 1
      return evaluate_seq(num_components, bit_width, src);
d4121 1
a4121 1
      return evaluate_sge(num_components, bit_width, src);
d4125 1
a4125 1
      return evaluate_slt(num_components, bit_width, src);
d4129 1
a4129 5
      return evaluate_sne(num_components, bit_width, src);
      break;
   }
   case nir_op_u2d: {
      return evaluate_u2d(num_components, bit_width, src);
d4133 1
a4133 1
      return evaluate_u2f(num_components, bit_width, src);
d4137 1
a4137 1
      return evaluate_uadd_carry(num_components, bit_width, src);
d4141 1
a4141 1
      return evaluate_ubfe(num_components, bit_width, src);
d4145 1
a4145 1
      return evaluate_ubitfield_extract(num_components, bit_width, src);
d4149 1
a4149 1
      return evaluate_udiv(num_components, bit_width, src);
d4153 1
a4153 1
      return evaluate_ufind_msb(num_components, bit_width, src);
d4157 1
a4157 1
      return evaluate_uge(num_components, bit_width, src);
d4161 1
a4161 1
      return evaluate_ult(num_components, bit_width, src);
d4165 1
a4165 1
      return evaluate_umax(num_components, bit_width, src);
d4169 1
a4169 1
      return evaluate_umax_4x8(num_components, bit_width, src);
d4173 1
a4173 1
      return evaluate_umin(num_components, bit_width, src);
d4177 1
a4177 1
      return evaluate_umin_4x8(num_components, bit_width, src);
d4181 1
a4181 1
      return evaluate_umod(num_components, bit_width, src);
d4185 1
a4185 1
      return evaluate_umul_high(num_components, bit_width, src);
d4189 1
a4189 13
      return evaluate_umul_unorm_4x8(num_components, bit_width, src);
      break;
   }
   case nir_op_unpack_double_2x32: {
      return evaluate_unpack_double_2x32(num_components, bit_width, src);
      break;
   }
   case nir_op_unpack_double_2x32_split_x: {
      return evaluate_unpack_double_2x32_split_x(num_components, bit_width, src);
      break;
   }
   case nir_op_unpack_double_2x32_split_y: {
      return evaluate_unpack_double_2x32_split_y(num_components, bit_width, src);
d4193 1
a4193 1
      return evaluate_unpack_half_2x16(num_components, bit_width, src);
d4197 1
a4197 1
      return evaluate_unpack_half_2x16_split_x(num_components, bit_width, src);
d4201 1
a4201 1
      return evaluate_unpack_half_2x16_split_y(num_components, bit_width, src);
d4205 1
a4205 1
      return evaluate_unpack_snorm_2x16(num_components, bit_width, src);
d4209 1
a4209 1
      return evaluate_unpack_snorm_4x8(num_components, bit_width, src);
d4213 1
a4213 1
      return evaluate_unpack_unorm_2x16(num_components, bit_width, src);
d4217 1
a4217 1
      return evaluate_unpack_unorm_4x8(num_components, bit_width, src);
d4221 1
a4221 1
      return evaluate_usadd_4x8(num_components, bit_width, src);
d4225 1
a4225 1
      return evaluate_ushr(num_components, bit_width, src);
d4229 1
a4229 1
      return evaluate_ussub_4x8(num_components, bit_width, src);
d4233 1
a4233 1
      return evaluate_usub_borrow(num_components, bit_width, src);
d4237 1
a4237 1
      return evaluate_vec2(num_components, bit_width, src);
d4241 1
a4241 1
      return evaluate_vec3(num_components, bit_width, src);
d4245 1
a4245 1
      return evaluate_vec4(num_components, bit_width, src);
@


1.1.1.3
log
@Import Mesa 17.1.6
@
text
@a205 1
typedef float float16_t;
a208 6
struct float16_vec {
   float16_t x;
   float16_t y;
   float16_t z;
   float16_t w;
};
a220 12
struct int8_vec {
   int8_t x;
   int8_t y;
   int8_t z;
   int8_t w;
};
struct int16_vec {
   int16_t x;
   int16_t y;
   int16_t z;
   int16_t w;
};
a232 12
struct uint8_vec {
   uint8_t x;
   uint8_t y;
   uint8_t z;
   uint8_t w;
};
struct uint16_vec {
   uint16_t x;
   uint16_t y;
   uint16_t z;
   uint16_t w;
};
a252 2


d254 2
a255 2
evaluate_b2f(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d259 3
a261 4
      switch (bit_size) {
      case 16: {
         
   
d263 3
a265 3
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const bool src0 = _src[0].u32[_i] != 0;
d267 1
a267 1
            float16_t dst = src0 ? 1.0 : 0.0;
d269 2
a270 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d272 4
a275 5
         break;
      }
      case 32: {
         
   
d277 3
a279 3
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const bool src0 = _src[0].u32[_i] != 0;
d281 1
a281 1
            float32_t dst = src0 ? 1.0 : 0.0;
d283 2
a284 2
            _dst_val.f32[_i] = dst;
      }
d286 2
a287 5
         break;
      }
      case 64: {
         
   
d289 3
a291 15
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const bool src0 = _src[0].u32[_i] != 0;

            float64_t dst = src0 ? 1.0 : 0.0;

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d296 2
a297 2
evaluate_b2i(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d301 3
a303 4
      switch (bit_size) {
      case 8: {
         
   
d305 3
a307 3
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const bool src0 = _src[0].u32[_i] != 0;
d309 1
a309 1
            int8_t dst = src0 ? 1 : 0;
d311 2
a312 2
            _dst_val.i8[_i] = dst;
      }
d314 4
a317 5
         break;
      }
      case 16: {
         
   
d319 3
a321 3
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const bool src0 = _src[0].u32[_i] != 0;
d323 1
a323 1
            int16_t dst = src0 ? 1 : 0;
d325 2
a326 2
            _dst_val.i16[_i] = dst;
      }
d328 2
a329 5
         break;
      }
      case 32: {
         
   
d331 3
a333 30
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const bool src0 = _src[0].u32[_i] != 0;

            int32_t dst = src0 ? 1 : 0;

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const bool src0 = _src[0].u32[_i] != 0;

            int64_t dst = src0 ? 1 : 0;

            _dst_val.i64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d338 2
a339 2
evaluate_ball_fequal2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d343 3
a345 4
      switch (bit_size) {
      case 16: {
         
   
d348 4
a351 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
         0,
         0,
      };
d353 4
a356 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
         0,
         0,
      };
d358 1
a358 1
      struct bool32_vec dst;
d360 1
a360 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));
d362 1
a362 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d364 4
a367 5
         break;
      }
      case 32: {
         
   
d370 4
a373 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
         0,
         0,
      };
d375 4
a378 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
         0,
         0,
      };
d380 1
a380 1
      struct bool32_vec dst;
d382 1
a382 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));
d384 1
a384 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d386 2
a387 5
         break;
      }
      case 64: {
         
   
d389 3
a391 27

      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
         0,
         0,
      };

      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
         0,
         0,
      };

      struct bool32_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));

            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d396 2
a397 2
evaluate_ball_fequal3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d401 3
a403 4
      switch (bit_size) {
      case 16: {
         
   
d406 5
a410 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
            _mesa_half_to_float(_src[0].u16[2]),
         0,
      };
d412 5
a416 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
            _mesa_half_to_float(_src[1].u16[2]),
         0,
      };
d418 1
a418 1
      struct bool32_vec dst;
d420 1
a420 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));
d422 1
a422 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d424 4
a427 5
         break;
      }
      case 32: {
         
   
d430 5
a434 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
         0,
      };
d436 5
a440 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
         0,
      };
d442 1
a442 1
      struct bool32_vec dst;
d444 1
a444 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));
d446 1
a446 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d448 2
a449 5
         break;
      }
      case 64: {
         
   
d451 3
a453 27

      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
            _src[0].f64[2],
         0,
      };

      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
            _src[1].f64[2],
         0,
      };

      struct bool32_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));

            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d458 2
a459 2
evaluate_ball_fequal4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d463 3
a465 4
      switch (bit_size) {
      case 16: {
         
   
d468 6
a473 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
            _mesa_half_to_float(_src[0].u16[2]),
            _mesa_half_to_float(_src[0].u16[3]),
      };
d475 6
a480 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
            _mesa_half_to_float(_src[1].u16[2]),
            _mesa_half_to_float(_src[1].u16[3]),
      };
d482 1
a482 1
      struct bool32_vec dst;
d484 1
a484 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));
d486 1
a486 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d488 4
a491 5
         break;
      }
      case 32: {
         
   
d494 6
a499 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
            _src[0].f32[3],
      };
d501 6
a506 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
            _src[1].f32[3],
      };
d508 1
a508 1
      struct bool32_vec dst;
d510 1
a510 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));
d512 1
a512 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d514 2
a515 5
         break;
      }
      case 64: {
         
   
d517 3
a519 27

      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
            _src[0].f64[2],
            _src[0].f64[3],
      };

      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
            _src[1].f64[2],
            _src[1].f64[3],
      };

      struct bool32_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));

            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d524 2
a525 2
evaluate_ball_iequal2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d529 9
a537 4
      switch (bit_size) {
      case 8: {
         
   
d539 4
d544 1
a544 6
      const struct int8_vec src0 = {
            _src[0].i8[0],
            _src[0].i8[1],
         0,
         0,
      };
d546 1
a546 6
      const struct int8_vec src1 = {
            _src[1].i8[0],
            _src[1].i8[1],
         0,
         0,
      };
d548 6
a553 1
      struct bool32_vec dst;
a554 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));
d556 4
a559 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d561 4
a564 5
         break;
      }
      case 16: {
         
   
d566 1
d568 1
a568 6
      const struct int16_vec src0 = {
            _src[0].i16[0],
            _src[0].i16[1],
         0,
         0,
      };
d570 1
a570 6
      const struct int16_vec src1 = {
            _src[1].i16[0],
            _src[1].i16[1],
         0,
         0,
      };
d572 2
a573 1
      struct bool32_vec dst;
d575 3
a577 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));
d579 7
a585 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d587 3
a589 5
         break;
      }
      case 32: {
         
   
d592 5
a596 6
      const struct int32_vec src0 = {
            _src[0].i32[0],
            _src[0].i32[1],
         0,
         0,
      };
d598 5
a602 6
      const struct int32_vec src1 = {
            _src[1].i32[0],
            _src[1].i32[1],
         0,
         0,
      };
d604 1
a604 1
      struct bool32_vec dst;
d606 1
a606 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));
d608 1
a608 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d610 4
a613 5
         break;
      }
      case 64: {
         
   
d616 5
a620 6
      const struct int64_vec src0 = {
            _src[0].i64[0],
            _src[0].i64[1],
         0,
         0,
      };
d622 5
a626 6
      const struct int64_vec src1 = {
            _src[1].i64[0],
            _src[1].i64[1],
         0,
         0,
      };
d628 1
a628 1
      struct bool32_vec dst;
d630 1
a630 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y));
d632 1
a632 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d634 2
a635 2
         break;
      }
d637 3
a639 3
      default:
         unreachable("unknown bit width");
      }
d644 2
a645 2
evaluate_ball_iequal3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d649 11
a659 4
      switch (bit_size) {
      case 8: {
         
   
d661 6
d668 1
a668 6
      const struct int8_vec src0 = {
            _src[0].i8[0],
            _src[0].i8[1],
            _src[0].i8[2],
         0,
      };
d670 1
a670 6
      const struct int8_vec src1 = {
            _src[1].i8[0],
            _src[1].i8[1],
            _src[1].i8[2],
         0,
      };
d672 6
a677 1
      struct bool32_vec dst;
a678 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));
d680 6
a685 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d687 6
a692 5
         break;
      }
      case 16: {
         
   
d694 1
d696 1
a696 6
      const struct int16_vec src0 = {
            _src[0].i16[0],
            _src[0].i16[1],
            _src[0].i16[2],
         0,
      };
d698 1
a698 6
      const struct int16_vec src1 = {
            _src[1].i16[0],
            _src[1].i16[1],
            _src[1].i16[2],
         0,
      };
d700 2
a701 1
      struct bool32_vec dst;
d703 3
a705 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));
d707 7
a713 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d715 3
a717 5
         break;
      }
      case 32: {
         
   
d720 4
a723 6
      const struct int32_vec src0 = {
            _src[0].i32[0],
            _src[0].i32[1],
            _src[0].i32[2],
         0,
      };
d725 4
a728 6
      const struct int32_vec src1 = {
            _src[1].i32[0],
            _src[1].i32[1],
            _src[1].i32[2],
         0,
      };
d730 1
a730 1
      struct bool32_vec dst;
d732 1
a732 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));
d734 1
a734 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d736 4
a739 5
         break;
      }
      case 64: {
         
   
d742 4
a745 6
      const struct int64_vec src0 = {
            _src[0].i64[0],
            _src[0].i64[1],
            _src[0].i64[2],
         0,
      };
d747 4
a750 6
      const struct int64_vec src1 = {
            _src[1].i64[0],
            _src[1].i64[1],
            _src[1].i64[2],
         0,
      };
d752 1
a752 1
      struct bool32_vec dst;
d754 1
a754 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z));
d756 1
a756 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d758 2
a759 2
         break;
      }
d761 3
a763 3
      default:
         unreachable("unknown bit width");
      }
d768 2
a769 2
evaluate_ball_iequal4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d773 3
a775 4
      switch (bit_size) {
      case 8: {
         
   
d778 5
a782 6
      const struct int8_vec src0 = {
            _src[0].i8[0],
            _src[0].i8[1],
            _src[0].i8[2],
            _src[0].i8[3],
      };
d784 5
a788 6
      const struct int8_vec src1 = {
            _src[1].i8[0],
            _src[1].i8[1],
            _src[1].i8[2],
            _src[1].i8[3],
      };
d790 1
a790 1
      struct bool32_vec dst;
d792 1
a792 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));
d794 1
a794 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d796 4
a799 5
         break;
      }
      case 16: {
         
   
d802 5
a806 6
      const struct int16_vec src0 = {
            _src[0].i16[0],
            _src[0].i16[1],
            _src[0].i16[2],
            _src[0].i16[3],
      };
d808 5
a812 6
      const struct int16_vec src1 = {
            _src[1].i16[0],
            _src[1].i16[1],
            _src[1].i16[2],
            _src[1].i16[3],
      };
d814 1
a814 1
      struct bool32_vec dst;
d816 1
a816 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));
d818 1
a818 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d820 2
a821 5
         break;
      }
      case 32: {
         
   
d823 3
a825 54

      const struct int32_vec src0 = {
            _src[0].i32[0],
            _src[0].i32[1],
            _src[0].i32[2],
            _src[0].i32[3],
      };

      const struct int32_vec src1 = {
            _src[1].i32[0],
            _src[1].i32[1],
            _src[1].i32[2],
            _src[1].i32[3],
      };

      struct bool32_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));

            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

         break;
      }
      case 64: {
         
   


      const struct int64_vec src0 = {
            _src[0].i64[0],
            _src[0].i64[1],
            _src[0].i64[2],
            _src[0].i64[3],
      };

      const struct int64_vec src1 = {
            _src[1].i64[0],
            _src[1].i64[1],
            _src[1].i64[2],
            _src[1].i64[3],
      };

      struct bool32_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w));

            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d830 2
a831 2
evaluate_bany_fnequal2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d835 3
a837 4
      switch (bit_size) {
      case 16: {
         
   
d840 6
a845 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
         0,
         0,
      };
d847 6
a852 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
         0,
         0,
      };
d854 1
a854 1
      struct bool32_vec dst;
d856 1
a856 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));
d858 1
a858 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d860 4
a863 5
         break;
      }
      case 32: {
         
   
d866 6
a871 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
         0,
         0,
      };
d873 6
a878 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
         0,
         0,
      };
d880 1
a880 1
      struct bool32_vec dst;
d882 1
a882 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));
d884 1
a884 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d886 2
a887 5
         break;
      }
      case 64: {
         
   
d889 3
a891 27

      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
         0,
         0,
      };

      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
         0,
         0,
      };

      struct bool32_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));

            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d896 2
a897 2
evaluate_bany_fnequal3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d901 3
a903 4
      switch (bit_size) {
      case 16: {
         
   
d906 4
a909 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
            _mesa_half_to_float(_src[0].u16[2]),
         0,
      };
d911 4
a914 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
            _mesa_half_to_float(_src[1].u16[2]),
         0,
      };
d916 1
a916 1
      struct bool32_vec dst;
d918 1
a918 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
d920 1
a920 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d922 4
a925 5
         break;
      }
      case 32: {
         
   
d928 4
a931 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
         0,
      };
d933 4
a936 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
         0,
      };
d938 1
a938 1
      struct bool32_vec dst;
d940 1
a940 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
d942 1
a942 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d944 2
a945 5
         break;
      }
      case 64: {
         
   
d947 3
a949 27

      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
            _src[0].f64[2],
         0,
      };

      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
            _src[1].f64[2],
         0,
      };

      struct bool32_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));

            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d954 2
a955 2
evaluate_bany_fnequal4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d959 3
a961 4
      switch (bit_size) {
      case 16: {
         
   
d964 5
a968 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
            _mesa_half_to_float(_src[0].u16[2]),
            _mesa_half_to_float(_src[0].u16[3]),
      };
d970 5
a974 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
            _mesa_half_to_float(_src[1].u16[2]),
            _mesa_half_to_float(_src[1].u16[3]),
      };
d976 1
a976 1
      struct bool32_vec dst;
d978 1
a978 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));
d980 1
a980 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d982 4
a985 5
         break;
      }
      case 32: {
         
   
d988 5
a992 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
            _src[0].f32[3],
      };
d994 5
a998 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
            _src[1].f32[3],
      };
d1000 1
a1000 1
      struct bool32_vec dst;
d1002 1
a1002 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));
d1004 1
a1004 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d1006 2
a1007 5
         break;
      }
      case 64: {
         
   
d1009 3
a1011 27

      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
            _src[0].f64[2],
            _src[0].f64[3],
      };

      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
            _src[1].f64[2],
            _src[1].f64[3],
      };

      struct bool32_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));

            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d1016 2
a1017 2
evaluate_bany_inequal2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1021 3
a1023 4
      switch (bit_size) {
      case 8: {
         
   
d1026 6
a1031 6
      const struct int8_vec src0 = {
            _src[0].i8[0],
            _src[0].i8[1],
         0,
         0,
      };
d1033 6
a1038 6
      const struct int8_vec src1 = {
            _src[1].i8[0],
            _src[1].i8[1],
         0,
         0,
      };
d1040 1
a1040 1
      struct bool32_vec dst;
d1042 1
a1042 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));
d1044 1
a1044 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d1046 4
a1049 5
         break;
      }
      case 16: {
         
   
d1052 6
a1057 6
      const struct int16_vec src0 = {
            _src[0].i16[0],
            _src[0].i16[1],
         0,
         0,
      };
d1059 6
a1064 6
      const struct int16_vec src1 = {
            _src[1].i16[0],
            _src[1].i16[1],
         0,
         0,
      };
d1066 1
a1066 1
      struct bool32_vec dst;
d1068 1
a1068 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));
d1070 1
a1070 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d1072 2
a1073 5
         break;
      }
      case 32: {
         
   
d1075 3
d1079 7
a1085 6
      const struct int32_vec src0 = {
            _src[0].i32[0],
            _src[0].i32[1],
         0,
         0,
      };
d1087 3
a1089 6
      const struct int32_vec src1 = {
            _src[1].i32[0],
            _src[1].i32[1],
         0,
         0,
      };
d1091 7
a1097 1
      struct bool32_vec dst;
d1099 1
a1099 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));
d1101 2
a1102 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d1104 4
a1107 5
         break;
      }
      case 64: {
         
   
d1109 7
d1117 1
a1117 6
      const struct int64_vec src0 = {
            _src[0].i64[0],
            _src[0].i64[1],
         0,
         0,
      };
d1119 2
a1120 6
      const struct int64_vec src1 = {
            _src[1].i64[0],
            _src[1].i64[1],
         0,
         0,
      };
d1122 2
a1123 1
      struct bool32_vec dst;
d1125 3
a1127 10
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y));

            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d1132 2
a1133 2
evaluate_bany_inequal3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1137 3
a1139 4
      switch (bit_size) {
      case 8: {
         
   
d1141 8
d1150 13
a1162 6
      const struct int8_vec src0 = {
            _src[0].i8[0],
            _src[0].i8[1],
            _src[0].i8[2],
         0,
      };
a1163 6
      const struct int8_vec src1 = {
            _src[1].i8[0],
            _src[1].i8[1],
            _src[1].i8[2],
         0,
      };
d1165 2
a1166 1
      struct bool32_vec dst;
d1168 4
a1171 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
d1173 8
a1180 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d1182 13
a1194 5
         break;
      }
      case 16: {
         
   
d1197 2
a1198 6
      const struct int16_vec src0 = {
            _src[0].i16[0],
            _src[0].i16[1],
            _src[0].i16[2],
         0,
      };
d1200 2
a1201 6
      const struct int16_vec src1 = {
            _src[1].i16[0],
            _src[1].i16[1],
            _src[1].i16[2],
         0,
      };
d1203 3
a1205 1
      struct bool32_vec dst;
d1207 7
a1213 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
d1215 3
a1217 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d1219 6
a1224 5
         break;
      }
      case 32: {
         
   
d1226 7
a1233 6
      const struct int32_vec src0 = {
            _src[0].i32[0],
            _src[0].i32[1],
            _src[0].i32[2],
         0,
      };
d1235 2
a1236 6
      const struct int32_vec src1 = {
            _src[1].i32[0],
            _src[1].i32[1],
            _src[1].i32[2],
         0,
      };
d1238 4
a1241 1
      struct bool32_vec dst;
d1243 6
a1248 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));
d1250 7
a1256 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
a1257 5
         break;
      }
      case 64: {
         
   
d1259 2
d1262 2
a1263 6
      const struct int64_vec src0 = {
            _src[0].i64[0],
            _src[0].i64[1],
            _src[0].i64[2],
         0,
      };
d1265 3
a1267 19
      const struct int64_vec src1 = {
            _src[1].i64[0],
            _src[1].i64[1],
            _src[1].i64[2],
         0,
      };

      struct bool32_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z));

            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d1272 2
a1273 2
evaluate_bany_inequal4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1277 3
a1279 4
      switch (bit_size) {
      case 8: {
         
   
d1281 4
d1286 7
a1292 6
      const struct int8_vec src0 = {
            _src[0].i8[0],
            _src[0].i8[1],
            _src[0].i8[2],
            _src[0].i8[3],
      };
a1293 6
      const struct int8_vec src1 = {
            _src[1].i8[0],
            _src[1].i8[1],
            _src[1].i8[2],
            _src[1].i8[3],
      };
d1295 2
a1296 1
      struct bool32_vec dst;
d1298 4
a1301 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));
d1303 4
a1306 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d1308 7
a1314 5
         break;
      }
      case 16: {
         
   
d1317 2
a1318 6
      const struct int16_vec src0 = {
            _src[0].i16[0],
            _src[0].i16[1],
            _src[0].i16[2],
            _src[0].i16[3],
      };
d1320 2
a1321 6
      const struct int16_vec src1 = {
            _src[1].i16[0],
            _src[1].i16[1],
            _src[1].i16[2],
            _src[1].i16[3],
      };
d1323 3
a1325 1
      struct bool32_vec dst;
d1327 7
a1333 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));
d1335 3
a1337 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
d1339 10
a1348 5
         break;
      }
      case 32: {
         
   
d1350 12
a1362 6
      const struct int32_vec src0 = {
            _src[0].i32[0],
            _src[0].i32[1],
            _src[0].i32[2],
            _src[0].i32[3],
      };
d1364 2
a1365 6
      const struct int32_vec src1 = {
            _src[1].i32[0],
            _src[1].i32[1],
            _src[1].i32[2],
            _src[1].i32[3],
      };
d1367 4
a1370 1
      struct bool32_vec dst;
d1372 10
a1381 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));
d1383 12
a1394 1
            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;
a1395 5
         break;
      }
      case 64: {
         
   
d1397 2
d1400 2
a1401 6
      const struct int64_vec src0 = {
            _src[0].i64[0],
            _src[0].i64[1],
            _src[0].i64[2],
            _src[0].i64[3],
      };
d1403 3
a1405 19
      const struct int64_vec src1 = {
            _src[1].i64[0],
            _src[1].i64[1],
            _src[1].i64[2],
            _src[1].i64[3],
      };

      struct bool32_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w));

            _dst_val.u32[0] = dst.x ? NIR_TRUE : NIR_FALSE;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d1410 2
a1411 2
evaluate_bcsel(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1415 3
a1417 4
      switch (bit_size) {
      case 8: {
         
   
d1419 4
a1422 7
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const bool src0 = _src[0].u32[_i] != 0;
               const uint8_t src1 =
                  _src[1].u8[_i];
               const uint8_t src2 =
                  _src[2].u8[_i];
d1424 6
a1429 1
            uint8_t dst = src0 ? src1 : src2;
a1430 2
            _dst_val.u8[_i] = dst;
      }
d1432 2
a1433 5
         break;
      }
      case 16: {
         
   
d1435 4
a1438 7
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const bool src0 = _src[0].u32[_i] != 0;
               const uint16_t src1 =
                  _src[1].u16[_i];
               const uint16_t src2 =
                  _src[2].u16[_i];
d1440 4
a1443 1
            uint16_t dst = src0 ? src1 : src2;
d1445 6
a1450 2
            _dst_val.u16[_i] = dst;
      }
a1451 5
         break;
      }
      case 32: {
         
   
d1453 2
a1454 7
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const bool src0 = _src[0].u32[_i] != 0;
               const uint32_t src1 =
                  _src[1].u32[_i];
               const uint32_t src2 =
                  _src[2].u32[_i];
d1456 2
a1457 1
            uint32_t dst = src0 ? src1 : src2;
d1459 3
a1461 28
            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const bool src0 = _src[0].u32[_i] != 0;
               const uint64_t src1 =
                  _src[1].u64[_i];
               const uint64_t src2 =
                  _src[2].u64[_i];

            uint64_t dst = src0 ? src1 : src2;

            _dst_val.u64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d1466 2
a1467 2
evaluate_bfi(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1471 2
a1473 1
   
d1475 9
a1483 8
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];
               const uint32_t src2 =
                  _src[2].u32[_i];
d1485 4
a1488 1
            uint32_t dst;
d1491 5
a1495 11
unsigned mask = src0, insert = src1, base = src2;
if (mask == 0) {
   dst = base;
} else {
   unsigned tmp = mask;
   while (!(tmp & 1)) {
      tmp >>= 1;
      insert <<= 1;
   }
   dst = (base & ~mask) | (insert & mask);
}
d1497 2
d1500 2
a1501 2
            _dst_val.u32[_i] = dst;
      }
d1503 3
d1510 2
a1511 2
evaluate_bfm(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1515 2
a1517 1
   
d1519 9
a1527 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];
d1529 4
a1532 1
            uint32_t dst;
d1535 5
a1539 5
int bits = src0, offset = src1;
if (offset < 0 || bits < 0 || offset > 31 || bits > 31 || offset + bits > 32)
   dst = 0; /* undefined */
else
   dst = ((1u << bits) - 1) << offset;
d1541 2
d1544 2
a1545 2
            _dst_val.u32[_i] = dst;
      }
d1547 3
d1554 2
a1555 2
evaluate_bit_count(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1559 2
a1561 1
   
d1563 6
a1568 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
d1570 7
a1576 1
            uint32_t dst;
d1579 5
a1583 5
dst = 0;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1)
      dst++;
}
d1585 2
d1588 2
a1589 2
            _dst_val.u32[_i] = dst;
      }
d1591 3
d1598 2
a1599 2
evaluate_bitfield_insert(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1603 2
a1605 1
   
d1607 9
a1615 10
                                    
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];
               const int32_t src2 =
                  _src[2].i32[_i];
               const int32_t src3 =
                  _src[3].i32[_i];
d1617 4
a1620 1
            uint32_t dst;
d1623 5
a1627 10
unsigned base = src0, insert = src1;
int offset = src2, bits = src3;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || bits + offset > 32) {
   dst = 0;
} else {
   unsigned mask = ((1ull << bits) - 1) << offset;
   dst = (base & ~mask) | ((insert << bits) & mask);
}
d1629 2
d1632 2
a1633 2
            _dst_val.u32[_i] = dst;
      }
d1635 3
d1642 2
a1643 2
evaluate_bitfield_reverse(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1647 2
a1649 1
   
d1651 11
a1661 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
d1663 11
a1673 1
            uint32_t dst;
d1675 1
a1675 5
            
/* we're not winning any awards for speed here, but that's ok */
dst = 0;
for (unsigned bit = 0; bit < 32; bit++)
   dst |= ((src0 >> bit) & 1) << (31 - bit);
d1677 2
d1680 2
a1681 2
            _dst_val.u32[_i] = dst;
      }
d1683 3
d1690 2
a1691 2
evaluate_extract_i16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1695 10
a1704 4
      switch (bit_size) {
      case 8: {
         
   
d1706 1
a1706 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            int8_t dst = (int16_t)(src0 >> (src1 * 16));

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d1708 2
a1709 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            int16_t dst = (int16_t)(src0 >> (src1 * 16));

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d1711 4
a1714 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            int32_t dst = (int16_t)(src0 >> (src1 * 16));

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d1716 6
a1721 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
d1723 1
a1723 1
            int64_t dst = (int16_t)(src0 >> (src1 * 16));
d1725 2
a1726 2
            _dst_val.i64[_i] = dst;
      }
d1728 2
a1729 2
         break;
      }
d1731 3
a1733 3
      default:
         unreachable("unknown bit width");
      }
d1738 2
a1739 2
evaluate_extract_i8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1743 10
a1752 4
      switch (bit_size) {
      case 8: {
         
   
d1754 1
a1754 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            int8_t dst = (int8_t)(src0 >> (src1 * 8));

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d1756 2
a1757 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            int16_t dst = (int8_t)(src0 >> (src1 * 8));

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d1759 4
a1762 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            int32_t dst = (int8_t)(src0 >> (src1 * 8));

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d1764 6
a1769 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
d1771 1
a1771 1
            int64_t dst = (int8_t)(src0 >> (src1 * 8));
d1773 2
a1774 2
            _dst_val.i64[_i] = dst;
      }
d1776 2
a1777 2
         break;
      }
d1779 3
a1781 3
      default:
         unreachable("unknown bit width");
      }
d1786 2
a1787 2
evaluate_extract_u16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1791 10
a1800 4
      switch (bit_size) {
      case 8: {
         
   
d1802 1
a1802 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            uint8_t dst = (uint16_t)(src0 >> (src1 * 16));

            _dst_val.u8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d1804 2
a1805 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            uint16_t dst = (uint16_t)(src0 >> (src1 * 16));

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d1807 4
a1810 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint32_t dst = (uint16_t)(src0 >> (src1 * 16));

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d1812 6
a1817 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
d1819 1
a1819 1
            uint64_t dst = (uint16_t)(src0 >> (src1 * 16));
d1821 2
a1822 2
            _dst_val.u64[_i] = dst;
      }
d1824 2
a1825 2
         break;
      }
d1827 3
a1829 3
      default:
         unreachable("unknown bit width");
      }
d1834 2
a1835 2
evaluate_extract_u8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1839 8
a1846 4
      switch (bit_size) {
      case 8: {
         
   
d1848 1
a1848 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            uint8_t dst = (uint8_t)(src0 >> (src1 * 8));

            _dst_val.u8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d1850 2
a1851 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            uint16_t dst = (uint8_t)(src0 >> (src1 * 8));

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d1853 4
a1856 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint32_t dst = (uint8_t)(src0 >> (src1 * 8));

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d1858 4
a1861 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
d1863 1
a1863 1
            uint64_t dst = (uint8_t)(src0 >> (src1 * 8));
d1865 2
a1866 2
            _dst_val.u64[_i] = dst;
      }
d1868 2
a1869 2
         break;
      }
d1871 3
a1873 3
      default:
         unreachable("unknown bit width");
      }
d1878 2
a1879 2
evaluate_f2b(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1883 3
a1885 4
      switch (bit_size) {
      case 16: {
         
   
d1887 4
a1890 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d1892 1
a1892 1
            bool32_t dst = src0 != 0.0;
d1894 2
a1895 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d1897 4
a1900 5
         break;
      }
      case 32: {
         
   
d1902 4
a1905 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d1907 1
a1907 1
            bool32_t dst = src0 != 0.0;
d1909 2
a1910 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d1912 2
a1913 5
         break;
      }
      case 64: {
         
   
d1915 3
a1917 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            bool32_t dst = src0 != 0.0;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d1922 2
a1923 2
evaluate_f2f16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1927 3
a1929 4
      switch (bit_size) {
      case 16: {
         
   
d1931 4
a1934 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d1936 1
a1936 1
            float16_t dst = src0;
d1938 2
a1939 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d1941 4
a1944 5
         break;
      }
      case 32: {
         
   
d1946 4
a1949 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d1951 1
a1951 1
            float16_t dst = src0;
d1953 2
a1954 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d1956 2
a1957 5
         break;
      }
      case 64: {
         
   
d1959 3
a1961 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float16_t dst = src0;

            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d1966 2
a1967 2
evaluate_f2f32(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d1971 3
a1973 4
      switch (bit_size) {
      case 16: {
         
   
d1975 4
a1978 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d1980 1
a1980 1
            float32_t dst = src0;
d1982 2
a1983 2
            _dst_val.f32[_i] = dst;
      }
d1985 4
a1988 5
         break;
      }
      case 32: {
         
   
d1990 4
a1993 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d1995 1
a1995 1
            float32_t dst = src0;
d1997 2
a1998 2
            _dst_val.f32[_i] = dst;
      }
d2000 2
a2001 5
         break;
      }
      case 64: {
         
   
d2003 3
a2005 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float32_t dst = src0;

            _dst_val.f32[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d2010 2
a2011 2
evaluate_f2f64(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2015 3
a2017 4
      switch (bit_size) {
      case 16: {
         
   
d2019 4
a2022 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d2024 1
a2024 1
            float64_t dst = src0;
d2026 2
a2027 2
            _dst_val.f64[_i] = dst;
      }
d2029 4
a2032 5
         break;
      }
      case 32: {
         
   
d2034 4
a2037 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d2039 1
a2039 1
            float64_t dst = src0;
d2041 2
a2042 2
            _dst_val.f64[_i] = dst;
      }
d2044 2
a2045 5
         break;
      }
      case 64: {
         
   
d2047 3
a2049 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = src0;

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d2054 2
a2055 2
evaluate_f2i16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2059 3
a2061 4
      switch (bit_size) {
      case 16: {
         
   
d2063 6
a2068 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d2070 1
a2070 1
            int16_t dst = src0;
d2072 2
a2073 2
            _dst_val.i16[_i] = dst;
      }
d2075 4
a2078 5
         break;
      }
      case 32: {
         
   
d2080 6
a2085 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d2087 1
a2087 1
            int16_t dst = src0;
d2089 2
a2090 2
            _dst_val.i16[_i] = dst;
      }
d2092 2
a2093 5
         break;
      }
      case 64: {
         
   
d2095 3
a2097 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            int16_t dst = src0;

            _dst_val.i16[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d2102 2
a2103 2
evaluate_f2i32(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2107 9
a2115 4
      switch (bit_size) {
      case 16: {
         
   
d2117 4
a2120 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d2122 1
a2122 1
            int32_t dst = src0;
d2124 1
a2124 2
            _dst_val.i32[_i] = dst;
      }
d2126 1
a2126 5
         break;
      }
      case 32: {
         
   
d2128 4
a2131 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
a2132 1
            int32_t dst = src0;
d2134 4
a2137 2
            _dst_val.i32[_i] = dst;
      }
d2139 4
a2142 5
         break;
      }
      case 64: {
         
   
d2144 1
a2144 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
d2146 1
a2146 1
            int32_t dst = src0;
d2148 1
a2148 2
            _dst_val.i32[_i] = dst;
      }
d2150 2
a2151 2
         break;
      }
d2153 3
a2155 3
      default:
         unreachable("unknown bit width");
      }
d2160 2
a2161 2
evaluate_f2i64(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2165 4
a2168 4
      switch (bit_size) {
      case 16: {
         
   
d2170 5
a2174 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d2176 5
a2180 1
            int64_t dst = src0;
d2182 1
a2182 2
            _dst_val.i64[_i] = dst;
      }
d2184 1
a2184 5
         break;
      }
      case 32: {
         
   
d2186 6
a2191 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
a2192 1
            int64_t dst = src0;
d2194 5
a2198 2
            _dst_val.i64[_i] = dst;
      }
d2200 5
a2204 5
         break;
      }
      case 64: {
         
   
d2206 1
a2206 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
d2208 1
a2208 1
            int64_t dst = src0;
d2210 1
a2210 2
            _dst_val.i64[_i] = dst;
      }
d2212 2
a2213 2
         break;
      }
d2215 3
a2217 3
      default:
         unreachable("unknown bit width");
      }
d2222 2
a2223 2
evaluate_f2i8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2227 11
a2237 4
      switch (bit_size) {
      case 16: {
         
   
d2239 6
a2244 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d2246 1
a2246 1
            int8_t dst = src0;
d2248 1
a2248 2
            _dst_val.i8[_i] = dst;
      }
d2250 1
a2250 5
         break;
      }
      case 32: {
         
   
d2252 4
a2255 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
a2256 1
            int8_t dst = src0;
d2258 6
a2263 2
            _dst_val.i8[_i] = dst;
      }
d2265 6
a2270 5
         break;
      }
      case 64: {
         
   
d2272 1
a2272 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
d2274 1
a2274 1
            int8_t dst = src0;
d2276 1
a2276 2
            _dst_val.i8[_i] = dst;
      }
d2278 2
a2279 2
         break;
      }
d2281 3
a2283 3
      default:
         unreachable("unknown bit width");
      }
d2288 2
a2289 2
evaluate_f2u16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2293 3
a2295 4
      switch (bit_size) {
      case 16: {
         
   
d2297 6
a2302 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d2304 1
a2304 1
            uint16_t dst = src0;
d2306 2
a2307 2
            _dst_val.u16[_i] = dst;
      }
d2309 4
a2312 5
         break;
      }
      case 32: {
         
   
d2314 6
a2319 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d2321 1
a2321 1
            uint16_t dst = src0;
d2323 2
a2324 2
            _dst_val.u16[_i] = dst;
      }
d2326 2
a2327 5
         break;
      }
      case 64: {
         
   
d2329 3
a2331 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            uint16_t dst = src0;

            _dst_val.u16[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d2336 2
a2337 2
evaluate_f2u32(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2341 9
a2349 4
      switch (bit_size) {
      case 16: {
         
   
d2351 4
a2354 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d2356 1
a2356 1
            uint32_t dst = src0;
d2358 1
a2358 2
            _dst_val.u32[_i] = dst;
      }
d2360 1
a2360 5
         break;
      }
      case 32: {
         
   
d2362 4
a2365 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
a2366 1
            uint32_t dst = src0;
d2368 4
a2371 2
            _dst_val.u32[_i] = dst;
      }
d2373 4
a2376 5
         break;
      }
      case 64: {
         
   
d2378 1
a2378 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
d2380 1
a2380 1
            uint32_t dst = src0;
d2382 1
a2382 2
            _dst_val.u32[_i] = dst;
      }
d2384 2
a2385 2
         break;
      }
d2387 3
a2389 3
      default:
         unreachable("unknown bit width");
      }
d2394 2
a2395 2
evaluate_f2u64(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2399 4
a2402 4
      switch (bit_size) {
      case 16: {
         
   
d2404 5
a2408 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d2410 5
a2414 1
            uint64_t dst = src0;
d2416 1
a2416 2
            _dst_val.u64[_i] = dst;
      }
d2418 1
a2418 5
         break;
      }
      case 32: {
         
   
d2420 6
a2425 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
a2426 1
            uint64_t dst = src0;
d2428 5
a2432 2
            _dst_val.u64[_i] = dst;
      }
d2434 5
a2438 5
         break;
      }
      case 64: {
         
   
d2440 1
a2440 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
d2442 1
a2442 1
            uint64_t dst = src0;
d2444 1
a2444 2
            _dst_val.u64[_i] = dst;
      }
d2446 2
a2447 2
         break;
      }
d2449 3
a2451 3
      default:
         unreachable("unknown bit width");
      }
d2456 2
a2457 2
evaluate_f2u8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2461 11
a2471 4
      switch (bit_size) {
      case 16: {
         
   
d2473 6
a2478 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d2480 1
a2480 1
            uint8_t dst = src0;
d2482 1
a2482 2
            _dst_val.u8[_i] = dst;
      }
d2484 1
a2484 5
         break;
      }
      case 32: {
         
   
d2486 4
a2489 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
a2490 1
            uint8_t dst = src0;
d2492 6
a2497 2
            _dst_val.u8[_i] = dst;
      }
d2499 6
a2504 5
         break;
      }
      case 64: {
         
   
d2506 1
a2506 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
d2508 1
a2508 1
            uint8_t dst = src0;
d2510 1
a2510 2
            _dst_val.u8[_i] = dst;
      }
d2512 2
a2513 2
         break;
      }
d2515 3
a2517 3
      default:
         unreachable("unknown bit width");
      }
d2522 2
a2523 2
evaluate_fabs(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2527 3
a2529 4
      switch (bit_size) {
      case 16: {
         
   
d2531 4
a2534 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d2536 1
a2536 1
            float16_t dst = bit_size == 64 ? fabs(src0) : fabsf(src0);
d2538 2
a2539 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d2541 4
a2544 5
         break;
      }
      case 32: {
         
   
d2546 4
a2549 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d2551 1
a2551 1
            float32_t dst = bit_size == 64 ? fabs(src0) : fabsf(src0);
d2553 2
a2554 2
            _dst_val.f32[_i] = dst;
      }
d2556 2
a2557 5
         break;
      }
      case 64: {
         
   
d2559 3
a2561 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = bit_size == 64 ? fabs(src0) : fabsf(src0);

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d2566 2
a2567 2
evaluate_fadd(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2571 10
a2580 4
      switch (bit_size) {
      case 16: {
         
   
d2582 2
a2583 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            float16_t dst = src0 + src1;

            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }

         break;
      }
      case 32: {
         
   
d2585 4
a2588 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            float32_t dst = src0 + src1;

            _dst_val.f32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d2590 4
a2593 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d2595 1
a2595 1
            float64_t dst = src0 + src1;
d2597 2
a2598 2
            _dst_val.f64[_i] = dst;
      }
d2600 2
a2601 2
         break;
      }
d2603 3
a2605 3
      default:
         unreachable("unknown bit width");
      }
d2610 2
a2611 2
evaluate_fall_equal2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2615 2
a2617 1
   
d2619 13
d2633 4
a2636 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
         0,
         0,
      };
d2638 8
a2645 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
         0,
         0,
      };
d2647 1
a2647 1
      struct float32_vec dst;
d2649 2
a2650 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y)) ? 1.0f : 0.0f;
d2652 2
a2653 1
            _dst_val.f32[0] = dst.x;
d2655 3
d2662 2
a2663 2
evaluate_fall_equal3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2667 2
a2669 1
   
d2671 4
d2676 2
a2677 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
         0,
      };
d2679 4
a2682 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
         0,
      };
d2684 4
a2687 1
      struct float32_vec dst;
d2689 2
a2690 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z)) ? 1.0f : 0.0f;
d2692 2
a2693 1
            _dst_val.f32[0] = dst.x;
d2695 3
d2702 2
a2703 2
evaluate_fall_equal4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2707 2
a2709 1
   
d2711 4
d2716 2
a2717 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
            _src[0].f32[3],
      };
d2719 4
a2722 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
            _src[1].f32[3],
      };
d2724 4
a2727 1
      struct float32_vec dst;
d2729 2
a2730 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x == src1.x) && (src0.y == src1.y) && (src0.z == src1.z) && (src0.w == src1.w)) ? 1.0f : 0.0f;
d2732 2
a2733 1
            _dst_val.f32[0] = dst.x;
d2735 3
d2742 2
a2743 2
evaluate_fand(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2747 15
a2762 1
   
d2764 2
d2767 1
a2767 5
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];
d2769 2
a2770 1
            float32_t dst = ((src0 != 0.0f) && (src1 != 0.0f)) ? 1.0f : 0.0f;
d2772 2
a2773 2
            _dst_val.f32[_i] = dst;
      }
d2775 3
d2782 2
a2783 2
evaluate_fany_nequal2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2787 2
a2789 1
   
d2791 4
d2796 2
a2797 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
         0,
         0,
      };
d2799 4
a2802 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
         0,
         0,
      };
d2804 4
a2807 1
      struct float32_vec dst;
d2809 2
a2810 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y)) ? 1.0f : 0.0f;
d2812 2
a2813 1
            _dst_val.f32[0] = dst.x;
d2815 3
d2822 2
a2823 2
evaluate_fany_nequal3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2827 2
a2829 1
   
d2831 4
d2836 2
a2837 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
         0,
      };
d2839 4
a2842 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
         0,
      };
d2844 4
a2847 1
      struct float32_vec dst;
d2849 2
a2850 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z)) ? 1.0f : 0.0f;
d2852 2
a2853 1
            _dst_val.f32[0] = dst.x;
d2855 3
d2862 2
a2863 2
evaluate_fany_nequal4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2867 2
a2869 1
   
d2871 4
d2876 2
a2877 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
            _src[0].f32[3],
      };
d2879 4
a2882 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
            _src[1].f32[3],
      };
d2884 4
a2887 1
      struct float32_vec dst;
d2889 2
a2890 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x != src1.x) || (src0.y != src1.y) || (src0.z != src1.z) || (src0.w != src1.w)) ? 1.0f : 0.0f;
d2892 2
a2893 1
            _dst_val.f32[0] = dst.x;
d2895 3
d2902 2
a2903 2
evaluate_fceil(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2907 3
a2909 4
      switch (bit_size) {
      case 16: {
         
   
d2911 6
a2916 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d2918 1
a2918 1
            float16_t dst = bit_size == 64 ? ceil(src0) : ceilf(src0);
d2920 2
a2921 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d2923 4
a2926 5
         break;
      }
      case 32: {
         
   
d2928 6
a2933 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d2935 1
a2935 1
            float32_t dst = bit_size == 64 ? ceil(src0) : ceilf(src0);
d2937 2
a2938 2
            _dst_val.f32[_i] = dst;
      }
d2940 2
a2941 5
         break;
      }
      case 64: {
         
   
d2943 3
a2945 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = bit_size == 64 ? ceil(src0) : ceilf(src0);

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d2950 2
a2951 2
evaluate_fcos(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d2955 4
a2958 4
      switch (bit_size) {
      case 16: {
         
   
d2960 4
a2963 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d2965 4
a2968 1
            float16_t dst = bit_size == 64 ? cos(src0) : cosf(src0);
d2970 1
a2970 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d2972 1
a2972 5
         break;
      }
      case 32: {
         
   
d2974 6
a2979 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
a2980 1
            float32_t dst = bit_size == 64 ? cos(src0) : cosf(src0);
d2982 4
a2985 2
            _dst_val.f32[_i] = dst;
      }
d2987 4
a2990 5
         break;
      }
      case 64: {
         
   
d2992 1
a2992 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
d2994 1
a2994 1
            float64_t dst = bit_size == 64 ? cos(src0) : cosf(src0);
d2996 1
a2996 2
            _dst_val.f64[_i] = dst;
      }
d2998 2
a2999 2
         break;
      }
d3001 3
a3003 3
      default:
         unreachable("unknown bit width");
      }
d3008 2
a3009 2
evaluate_fcsel(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d3013 2
a3015 10
   

                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];
               const float32_t src2 =
                  _src[2].f32[_i];
a3016 1
            float32_t dst = (src0 != 0.0f) ? src1 : src2;
d3018 5
a3022 2
            _dst_val.f32[_i] = dst;
      }
d3024 5
d3030 1
a3030 7
   return _dst_val;
}
static nir_const_value
evaluate_fddx(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d3032 1
a3032 4
      switch (bit_size) {
      case 16: {
         
   
d3034 1
a3034 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float16_t dst = 0.0;
d3036 4
a3039 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
a3040 5
         break;
      }
      case 32: {
         
   
d3042 5
a3046 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float32_t dst = 0.0;
d3048 5
a3052 2
            _dst_val.f32[_i] = dst;
      }
d3054 1
a3054 5
         break;
      }
      case 64: {
         
   
d3056 1
a3056 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float64_t dst = 0.0;
d3058 1
a3058 2
            _dst_val.f64[_i] = dst;
      }
d3060 2
a3061 2
         break;
      }
d3063 3
a3065 3
      default:
         unreachable("unknown bit width");
      }
d3070 2
a3071 2
evaluate_fddx_coarse(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d3075 3
a3077 4
      switch (bit_size) {
      case 16: {
         
   
a3078 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float16_t dst = 0.0;
d3080 6
a3085 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d3087 6
a3092 5
         break;
      }
      case 32: {
         
   
d3094 1
a3094 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float32_t dst = 0.0;
d3096 1
a3096 2
            _dst_val.f32[_i] = dst;
      }
d3098 1
a3098 5
         break;
      }
      case 64: {
         
   
d3100 4
a3103 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float64_t dst = 0.0;
a3104 2
            _dst_val.f64[_i] = dst;
      }
d3106 6
a3111 2
         break;
      }
d3113 6
a3118 3
      default:
         unreachable("unknown bit width");
      }
d3120 1
a3120 7
   return _dst_val;
}
static nir_const_value
evaluate_fddx_fine(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d3122 1
a3122 4
      switch (bit_size) {
      case 16: {
         
   
d3124 1
a3124 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float16_t dst = 0.0;
d3126 2
a3127 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d3129 3
a3131 5
         break;
      }
      case 32: {
         
   
d3133 7
a3139 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float32_t dst = 0.0;
d3141 3
a3143 8
            _dst_val.f32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
a3144 7
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float64_t dst = 0.0;

            _dst_val.f64[_i] = dst;
      }
d3146 4
a3149 2
         break;
      }
d3151 4
a3154 3
      default:
         unreachable("unknown bit width");
      }
d3156 1
a3156 7
   return _dst_val;
}
static nir_const_value
evaluate_fddy(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d3158 1
a3158 4
      switch (bit_size) {
      case 16: {
         
   
d3160 4
a3163 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float16_t dst = 0.0;
d3165 4
a3168 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
a3169 5
         break;
      }
      case 32: {
         
   
d3171 4
a3174 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float32_t dst = 0.0;
d3176 4
a3179 2
            _dst_val.f32[_i] = dst;
      }
d3181 1
a3181 5
         break;
      }
      case 64: {
         
   
d3183 1
a3183 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float64_t dst = 0.0;
d3185 4
a3188 2
            _dst_val.f64[_i] = dst;
      }
d3190 2
a3191 2
         break;
      }
d3193 3
a3195 3
      default:
         unreachable("unknown bit width");
      }
d3200 2
a3201 2
evaluate_fddy_coarse(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d3205 16
a3220 4
      switch (bit_size) {
      case 16: {
         
   
d3222 8
a3229 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float16_t dst = 0.0;
d3231 4
a3234 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
a3235 5
         break;
      }
      case 32: {
         
   
d3237 5
a3241 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float32_t dst = 0.0;
d3243 5
a3247 2
            _dst_val.f32[_i] = dst;
      }
d3249 1
a3249 5
         break;
      }
      case 64: {
         
   
d3251 1
a3251 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float64_t dst = 0.0;
d3253 4
a3256 2
            _dst_val.f64[_i] = dst;
      }
d3258 2
a3259 2
         break;
      }
d3261 3
a3263 3
      default:
         unreachable("unknown bit width");
      }
d3268 2
a3269 2
evaluate_fddy_fine(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d3273 3
a3275 4
      switch (bit_size) {
      case 16: {
         
   
a3276 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float16_t dst = 0.0;
d3278 6
a3283 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d3285 6
a3290 5
         break;
      }
      case 32: {
         
   
d3292 1
a3292 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float32_t dst = 0.0;
d3294 1
a3294 2
            _dst_val.f32[_i] = dst;
      }
d3296 4
a3299 5
         break;
      }
      case 64: {
         
   
d3301 4
a3304 10
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               
            float64_t dst = 0.0;

            _dst_val.f64[_i] = dst;
      }

         break;
      }
a3305 11
      default:
         unreachable("unknown bit width");
      }

   return _dst_val;
}
static nir_const_value
evaluate_fdiv(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d3307 6
a3312 4
      switch (bit_size) {
      case 16: {
         
   
d3314 6
a3319 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            float16_t dst = src0 / src1;

            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }

         break;
      }
      case 32: {
         
   
d3321 1
a3321 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            float32_t dst = src0 / src1;

            _dst_val.f32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d3323 1
a3323 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d3325 4
a3328 1
            float64_t dst = src0 / src1;
d3330 2
a3331 2
            _dst_val.f64[_i] = dst;
      }
d3333 3
a3335 6
         break;
      }

      default:
         unreachable("unknown bit width");
      }
d3340 2
a3341 2
evaluate_fdot2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d3345 3
a3347 4
      switch (bit_size) {
      case 16: {
         
   
d3350 5
a3354 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
         0,
         0,
      };
d3356 6
a3361 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
         0,
         0,
      };
d3363 1
a3363 1
      struct float16_vec dst;
d3365 1
a3365 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));
d3367 1
a3367 1
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
d3369 4
a3372 5
         break;
      }
      case 32: {
         
   
d3375 5
a3379 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
         0,
         0,
      };
d3381 6
a3386 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
         0,
         0,
      };
d3388 1
a3388 1
      struct float32_vec dst;
d3390 1
a3390 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));
d3392 1
a3392 1
            _dst_val.f32[0] = dst.x;
d3394 2
a3395 5
         break;
      }
      case 64: {
         
   
d3397 3
a3399 27

      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
         0,
         0,
      };

      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
         0,
         0,
      };

      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));

            _dst_val.f64[0] = dst.x;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d3404 2
a3405 2
evaluate_fdot3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d3409 3
a3411 4
      switch (bit_size) {
      case 16: {
         
   
d3414 5
a3418 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
            _mesa_half_to_float(_src[0].u16[2]),
         0,
      };
d3420 6
a3425 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
            _mesa_half_to_float(_src[1].u16[2]),
         0,
      };
d3427 1
a3427 1
      struct float16_vec dst;
d3429 1
a3429 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));
d3431 4
a3434 1
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
d3436 4
a3439 5
         break;
      }
      case 32: {
         
   
d3442 5
a3446 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
         0,
      };
d3448 6
a3453 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
         0,
      };
d3455 1
a3455 1
      struct float32_vec dst;
d3457 1
a3457 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));
d3459 4
a3462 1
            _dst_val.f32[0] = dst.x;
d3464 2
a3465 5
         break;
      }
      case 64: {
         
   
d3467 3
a3469 27

      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
            _src[0].f64[2],
         0,
      };

      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
            _src[1].f64[2],
         0,
      };

      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));

            _dst_val.f64[0] = dst.x;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d3474 2
a3475 2
evaluate_fdot4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d3479 3
a3481 4
      switch (bit_size) {
      case 16: {
         
   
d3483 6
d3490 1
a3490 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
            _mesa_half_to_float(_src[0].u16[2]),
            _mesa_half_to_float(_src[0].u16[3]),
      };
d3492 2
a3493 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
            _mesa_half_to_float(_src[1].u16[2]),
            _mesa_half_to_float(_src[1].u16[3]),
      };
d3495 4
a3498 1
      struct float16_vec dst;
d3500 6
a3505 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));
d3507 1
a3507 1
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
d3509 2
a3510 5
         break;
      }
      case 32: {
         
   
d3512 2
d3515 3
a3517 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
            _src[0].f32[3],
      };
d3519 7
a3525 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
            _src[1].f32[3],
      };
d3527 3
a3529 1
      struct float32_vec dst;
d3531 4
a3534 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));
d3536 1
a3536 1
            _dst_val.f32[0] = dst.x;
d3538 2
a3539 5
         break;
      }
      case 64: {
         
   
d3541 4
d3546 4
a3549 6
      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
            _src[0].f64[2],
            _src[0].f64[3],
      };
d3551 1
a3551 6
      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
            _src[1].f64[2],
            _src[1].f64[3],
      };
d3553 2
a3554 1
      struct float64_vec dst;
d3556 2
a3557 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));
d3559 3
a3561 8
            _dst_val.f64[0] = dst.x;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d3566 2
a3567 2
evaluate_fdot_replicated2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d3571 3
a3573 4
      switch (bit_size) {
      case 16: {
         
   
d3575 4
d3580 1
a3580 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
         0,
         0,
      };
d3582 2
a3583 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
         0,
         0,
      };
d3585 4
a3588 1
      struct float16_vec dst;
d3590 4
a3593 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));
d3595 1
a3595 4
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
            _dst_val.u16[2] = _mesa_float_to_half(dst.z);
            _dst_val.u16[3] = _mesa_float_to_half(dst.w);
d3597 2
a3598 5
         break;
      }
      case 32: {
         
   
d3600 2
d3603 3
a3605 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
         0,
         0,
      };
d3607 7
a3613 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
         0,
         0,
      };
d3615 3
a3617 1
      struct float32_vec dst;
d3619 8
a3626 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));
d3628 1
a3628 4
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
            _dst_val.f32[3] = dst.w;
d3630 2
a3631 5
         break;
      }
      case 64: {
         
   
d3633 4
d3638 8
a3645 6
      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
         0,
         0,
      };
d3647 1
a3647 6
      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
         0,
         0,
      };
d3649 2
a3650 1
      struct float64_vec dst;
d3652 2
a3653 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y));
d3655 3
a3657 11
            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;
            _dst_val.f64[2] = dst.z;
            _dst_val.f64[3] = dst.w;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d3662 2
a3663 2
evaluate_fdot_replicated3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d3667 3
a3669 4
      switch (bit_size) {
      case 16: {
         
   
d3671 4
d3676 1
a3676 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
            _mesa_half_to_float(_src[0].u16[2]),
         0,
      };
d3678 2
a3679 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
            _mesa_half_to_float(_src[1].u16[2]),
         0,
      };
d3681 4
a3684 1
      struct float16_vec dst;
d3686 4
a3689 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));
d3691 1
a3691 4
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
            _dst_val.u16[2] = _mesa_float_to_half(dst.z);
            _dst_val.u16[3] = _mesa_float_to_half(dst.w);
d3693 2
a3694 5
         break;
      }
      case 32: {
         
   
d3696 2
d3699 3
a3701 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
         0,
      };
d3703 7
a3709 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
         0,
      };
d3711 3
a3713 1
      struct float32_vec dst;
d3715 6
a3720 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));
d3722 1
a3722 4
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
            _dst_val.f32[3] = dst.w;
d3724 2
a3725 5
         break;
      }
      case 64: {
         
   
d3727 4
d3732 6
a3737 6
      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
            _src[0].f64[2],
         0,
      };
d3739 1
a3739 6
      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
            _src[1].f64[2],
         0,
      };
d3741 2
a3742 1
      struct float64_vec dst;
d3744 2
a3745 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z));
d3747 3
a3749 11
            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;
            _dst_val.f64[2] = dst.z;
            _dst_val.f64[3] = dst.w;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d3754 2
a3755 2
evaluate_fdot_replicated4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d3759 3
a3761 4
      switch (bit_size) {
      case 16: {
         
   
d3763 4
d3768 9
a3776 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
            _mesa_half_to_float(_src[0].u16[2]),
            _mesa_half_to_float(_src[0].u16[3]),
      };
a3777 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
            _mesa_half_to_float(_src[1].u16[2]),
            _mesa_half_to_float(_src[1].u16[3]),
      };
d3779 2
a3780 1
      struct float16_vec dst;
d3782 4
a3785 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));
d3787 4
a3790 4
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
            _dst_val.u16[2] = _mesa_float_to_half(dst.z);
            _dst_val.u16[3] = _mesa_float_to_half(dst.w);
d3792 9
a3800 5
         break;
      }
      case 32: {
         
   
d3803 2
a3804 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
            _src[0].f32[3],
      };
d3806 2
a3807 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
            _src[1].f32[3],
      };
d3809 3
a3811 1
      struct float32_vec dst;
d3813 7
a3819 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));
d3821 3
a3823 4
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
            _dst_val.f32[3] = dst.w;
d3825 4
a3828 5
         break;
      }
      case 64: {
         
   
d3830 1
d3832 2
a3833 6
      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
            _src[0].f64[2],
            _src[0].f64[3],
      };
d3835 4
a3838 6
      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
            _src[1].f64[2],
            _src[1].f64[3],
      };
d3840 4
a3843 1
      struct float64_vec dst;
d3845 1
a3845 1
         dst.x = dst.y = dst.z = dst.w = ((src0.x * src1.x) + (src0.y * src1.y) + (src0.z * src1.z) + (src0.w * src1.w));
d3847 2
a3848 4
            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;
            _dst_val.f64[2] = dst.z;
            _dst_val.f64[3] = dst.w;
d3850 2
a3851 2
         break;
      }
d3853 3
a3855 3
      default:
         unreachable("unknown bit width");
      }
d3860 2
a3861 2
evaluate_fdph(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d3865 3
a3867 4
      switch (bit_size) {
      case 16: {
         
   
d3869 8
d3878 1
a3878 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
            _mesa_half_to_float(_src[0].u16[2]),
         0,
      };
d3880 2
a3881 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
            _mesa_half_to_float(_src[1].u16[2]),
            _mesa_half_to_float(_src[1].u16[3]),
      };
d3883 4
a3886 1
      struct float16_vec dst;
d3888 8
a3895 1
         dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;
d3897 1
a3897 1
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
d3899 2
a3900 5
         break;
      }
      case 32: {
         
   
d3902 2
d3905 3
a3907 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
         0,
      };
d3909 7
a3915 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
            _src[1].f32[3],
      };
d3917 3
a3919 1
      struct float32_vec dst;
d3921 6
a3926 1
         dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;
d3928 1
a3928 1
            _dst_val.f32[0] = dst.x;
d3930 2
a3931 5
         break;
      }
      case 64: {
         
   
d3933 4
d3938 6
a3943 6
      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
            _src[0].f64[2],
         0,
      };
d3945 1
a3945 6
      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
            _src[1].f64[2],
            _src[1].f64[3],
      };
d3947 2
a3948 1
      struct float64_vec dst;
d3950 2
a3951 1
         dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;
d3953 3
a3955 8
            _dst_val.f64[0] = dst.x;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d3960 2
a3961 2
evaluate_fdph_replicated(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d3965 3
a3967 4
      switch (bit_size) {
      case 16: {
         
   
d3969 6
d3976 1
a3976 6
      const struct float16_vec src0 = {
            _mesa_half_to_float(_src[0].u16[0]),
            _mesa_half_to_float(_src[0].u16[1]),
            _mesa_half_to_float(_src[0].u16[2]),
         0,
      };
d3978 2
a3979 6
      const struct float16_vec src1 = {
            _mesa_half_to_float(_src[1].u16[0]),
            _mesa_half_to_float(_src[1].u16[1]),
            _mesa_half_to_float(_src[1].u16[2]),
            _mesa_half_to_float(_src[1].u16[3]),
      };
d3981 4
a3984 1
      struct float16_vec dst;
d3986 6
a3991 1
         dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;
d3993 1
a3993 4
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
            _dst_val.u16[2] = _mesa_float_to_half(dst.z);
            _dst_val.u16[3] = _mesa_float_to_half(dst.w);
d3995 2
a3996 5
         break;
      }
      case 32: {
         
   
d3998 2
d4001 3
a4003 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
         0,
      };
d4005 7
a4011 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
            _src[1].f32[1],
            _src[1].f32[2],
            _src[1].f32[3],
      };
d4013 3
a4015 1
      struct float32_vec dst;
d4017 6
a4022 1
         dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;
d4024 1
a4024 4
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
            _dst_val.f32[3] = dst.w;
d4026 2
a4027 5
         break;
      }
      case 64: {
         
   
d4029 4
d4034 6
a4039 6
      const struct float64_vec src0 = {
            _src[0].f64[0],
            _src[0].f64[1],
            _src[0].f64[2],
         0,
      };
d4041 1
a4041 6
      const struct float64_vec src1 = {
            _src[1].f64[0],
            _src[1].f64[1],
            _src[1].f64[2],
            _src[1].f64[3],
      };
d4043 2
a4044 1
      struct float64_vec dst;
d4046 2
a4047 1
         dst.x = dst.y = dst.z = dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w;
d4049 3
a4051 11
            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;
            _dst_val.f64[2] = dst.z;
            _dst_val.f64[3] = dst.w;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4056 2
a4057 2
evaluate_feq(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4061 3
a4063 4
      switch (bit_size) {
      case 16: {
         
   
d4065 6
a4070 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            bool32_t dst = src0 == src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 32: {
         
   
d4072 1
a4072 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            bool32_t dst = src0 == src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 64: {
         
   
d4074 2
a4075 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d4077 4
a4080 1
            bool32_t dst = src0 == src1;
d4082 6
a4087 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d4089 1
a4089 2
         break;
      }
d4091 9
a4099 3
      default:
         unreachable("unknown bit width");
      }
d4104 2
a4105 2
evaluate_fexp2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4109 3
a4111 4
      switch (bit_size) {
      case 16: {
         
   
d4113 4
a4116 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d4118 1
a4118 1
            float16_t dst = exp2f(src0);
d4120 2
a4121 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d4123 4
a4126 5
         break;
      }
      case 32: {
         
   
d4128 4
a4131 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d4133 1
a4133 1
            float32_t dst = exp2f(src0);
d4135 2
a4136 2
            _dst_val.f32[_i] = dst;
      }
d4138 2
a4139 5
         break;
      }
      case 64: {
         
   
d4141 3
a4143 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = exp2f(src0);

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4148 2
a4149 2
evaluate_ffloor(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4153 3
a4155 4
      switch (bit_size) {
      case 16: {
         
   
d4157 6
a4162 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d4164 1
a4164 1
            float16_t dst = bit_size == 64 ? floor(src0) : floorf(src0);
d4166 2
a4167 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d4169 4
a4172 5
         break;
      }
      case 32: {
         
   
d4174 6
a4179 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d4181 1
a4181 1
            float32_t dst = bit_size == 64 ? floor(src0) : floorf(src0);
d4183 2
a4184 2
            _dst_val.f32[_i] = dst;
      }
d4186 2
a4187 5
         break;
      }
      case 64: {
         
   
d4189 3
a4191 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = bit_size == 64 ? floor(src0) : floorf(src0);

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4196 2
a4197 2
evaluate_ffma(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4201 3
a4203 4
      switch (bit_size) {
      case 16: {
         
   
d4205 6
a4210 8
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);
               const float src2 =
                  _mesa_half_to_float(_src[2].u16[_i]);
d4212 1
a4212 1
            float16_t dst = src0 * src1 + src2;
d4214 2
a4215 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d4217 4
a4220 5
         break;
      }
      case 32: {
         
   
d4222 6
a4227 8
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];
               const float32_t src2 =
                  _src[2].f32[_i];
d4229 1
a4229 1
            float32_t dst = src0 * src1 + src2;
d4231 2
a4232 2
            _dst_val.f32[_i] = dst;
      }
d4234 2
a4235 5
         break;
      }
      case 64: {
         
   
d4237 3
a4239 20
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
               const float64_t src2 =
                  _src[2].f64[_i];

            float64_t dst = src0 * src1 + src2;

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4244 2
a4245 2
evaluate_ffract(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4249 3
a4251 4
      switch (bit_size) {
      case 16: {
         
   
d4253 4
a4256 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d4258 1
a4258 1
            float16_t dst = src0 - (bit_size == 64 ? floor(src0) : floorf(src0));
d4260 2
a4261 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d4263 4
a4266 5
         break;
      }
      case 32: {
         
   
d4268 4
a4271 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d4273 1
a4273 1
            float32_t dst = src0 - (bit_size == 64 ? floor(src0) : floorf(src0));
d4275 2
a4276 2
            _dst_val.f32[_i] = dst;
      }
d4278 2
a4279 5
         break;
      }
      case 64: {
         
   
d4281 3
a4283 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = src0 - (bit_size == 64 ? floor(src0) : floorf(src0));

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4288 2
a4289 2
evaluate_fge(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4293 8
a4300 4
      switch (bit_size) {
      case 16: {
         
   
d4302 1
a4302 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            bool32_t dst = src0 >= src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 32: {
         
   
d4304 4
a4307 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            bool32_t dst = src0 >= src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 64: {
         
   
d4309 2
a4310 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d4312 1
a4312 1
            bool32_t dst = src0 >= src1;
d4314 1
a4314 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d4316 2
a4317 2
         break;
      }
d4319 3
a4321 3
      default:
         unreachable("unknown bit width");
      }
d4326 2
a4327 2
evaluate_find_lsb(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4331 2
a4333 1
   
d4335 4
a4338 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
d4340 1
a4340 1
            int32_t dst;
a4341 5
            
dst = -1;
for (unsigned bit = 0; bit < 32; bit++) {
   if ((src0 >> bit) & 1) {
      dst = bit;
d4344 7
a4350 1
}
d4352 1
d4354 2
a4355 2
            _dst_val.i32[_i] = dst;
      }
d4357 3
d4364 2
a4365 2
evaluate_flog2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4369 3
a4371 4
      switch (bit_size) {
      case 16: {
         
   
d4373 2
a4374 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d4376 1
a4376 1
            float16_t dst = log2f(src0);
d4378 1
a4378 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d4380 4
a4383 5
         break;
      }
      case 32: {
         
   
d4385 2
a4386 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d4388 1
a4388 1
            float32_t dst = log2f(src0);
d4390 1
a4390 2
            _dst_val.f32[_i] = dst;
      }
d4392 2
a4393 5
         break;
      }
      case 64: {
         
   
d4395 3
a4397 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = log2f(src0);

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4402 2
a4403 2
evaluate_flrp(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4407 3
a4409 4
      switch (bit_size) {
      case 16: {
         
   
d4411 2
a4412 8
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);
               const float src2 =
                  _mesa_half_to_float(_src[2].u16[_i]);
d4414 1
a4414 1
            float16_t dst = src0 * (1 - src2) + src1 * src2;
d4416 1
a4416 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d4418 4
a4421 5
         break;
      }
      case 32: {
         
   
d4423 2
a4424 8
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];
               const float32_t src2 =
                  _src[2].f32[_i];
d4426 1
a4426 1
            float32_t dst = src0 * (1 - src2) + src1 * src2;
d4428 1
a4428 2
            _dst_val.f32[_i] = dst;
      }
d4430 2
a4431 5
         break;
      }
      case 64: {
         
   
d4433 3
a4435 20
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
               const float64_t src2 =
                  _src[2].f64[_i];

            float64_t dst = src0 * (1 - src2) + src1 * src2;

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4440 2
a4441 2
evaluate_flt(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4445 8
a4452 4
      switch (bit_size) {
      case 16: {
         
   
d4454 2
a4455 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            bool32_t dst = src0 < src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 32: {
         
   
d4457 4
a4460 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            bool32_t dst = src0 < src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 64: {
         
   
d4462 2
a4463 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d4465 1
a4465 1
            bool32_t dst = src0 < src1;
d4467 2
a4468 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d4470 2
a4471 2
         break;
      }
d4473 3
a4475 3
      default:
         unreachable("unknown bit width");
      }
d4480 2
a4481 2
evaluate_fmax(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4485 8
a4492 4
      switch (bit_size) {
      case 16: {
         
   
d4494 2
a4495 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            float16_t dst = fmaxf(src0, src1);

            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }

         break;
      }
      case 32: {
         
   
d4497 4
a4500 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            float32_t dst = fmaxf(src0, src1);

            _dst_val.f32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d4502 2
a4503 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d4505 1
a4505 1
            float64_t dst = fmaxf(src0, src1);
d4507 2
a4508 2
            _dst_val.f64[_i] = dst;
      }
d4510 2
a4511 2
         break;
      }
d4513 3
a4515 3
      default:
         unreachable("unknown bit width");
      }
d4520 2
a4521 2
evaluate_fmin(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4525 8
a4532 4
      switch (bit_size) {
      case 16: {
         
   
d4534 2
a4535 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            float16_t dst = fminf(src0, src1);

            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }

         break;
      }
      case 32: {
         
   
d4537 4
a4540 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            float32_t dst = fminf(src0, src1);

            _dst_val.f32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d4542 2
a4543 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d4545 1
a4545 1
            float64_t dst = fminf(src0, src1);
d4547 2
a4548 2
            _dst_val.f64[_i] = dst;
      }
d4550 2
a4551 2
         break;
      }
d4553 3
a4555 3
      default:
         unreachable("unknown bit width");
      }
d4560 2
a4561 2
evaluate_fmod(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4565 8
a4572 4
      switch (bit_size) {
      case 16: {
         
   
d4574 2
a4575 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            float16_t dst = src0 - src1 * floorf(src0 / src1);

            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }

         break;
      }
      case 32: {
         
   
d4577 4
a4580 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            float32_t dst = src0 - src1 * floorf(src0 / src1);

            _dst_val.f32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d4582 2
a4583 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d4585 1
a4585 1
            float64_t dst = src0 - src1 * floorf(src0 / src1);
d4587 2
a4588 2
            _dst_val.f64[_i] = dst;
      }
d4590 2
a4591 2
         break;
      }
d4593 3
a4595 3
      default:
         unreachable("unknown bit width");
      }
d4600 2
a4601 2
evaluate_fmov(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4605 3
a4607 4
      switch (bit_size) {
      case 16: {
         
   
d4609 2
a4610 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d4612 1
a4612 1
            float16_t dst = src0;
d4614 3
a4616 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d4618 4
a4621 5
         break;
      }
      case 32: {
         
   
d4623 2
a4624 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d4626 1
a4626 1
            float32_t dst = src0;
d4628 3
a4630 2
            _dst_val.f32[_i] = dst;
      }
d4632 2
a4633 5
         break;
      }
      case 64: {
         
   
d4635 3
a4637 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = src0;

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4642 2
a4643 2
evaluate_fmul(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4647 8
a4654 4
      switch (bit_size) {
      case 16: {
         
   
d4656 3
a4658 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            float16_t dst = src0 * src1;

            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }

         break;
      }
      case 32: {
         
   
d4660 4
a4663 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            float32_t dst = src0 * src1;

            _dst_val.f32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d4665 2
a4666 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d4668 1
a4668 1
            float64_t dst = src0 * src1;
d4670 3
a4672 2
            _dst_val.f64[_i] = dst;
      }
d4674 2
a4675 2
         break;
      }
d4677 3
a4679 3
      default:
         unreachable("unknown bit width");
      }
d4684 2
a4685 2
evaluate_fne(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4689 8
a4696 4
      switch (bit_size) {
      case 16: {
         
   
d4698 3
a4700 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            bool32_t dst = src0 != src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 32: {
         
   
d4702 4
a4705 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            bool32_t dst = src0 != src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 64: {
         
   
d4707 2
a4708 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d4710 1
a4710 1
            bool32_t dst = src0 != src1;
d4712 3
a4714 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d4716 2
a4717 2
         break;
      }
d4719 3
a4721 3
      default:
         unreachable("unknown bit width");
      }
d4726 2
a4727 2
evaluate_fneg(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4731 3
a4733 4
      switch (bit_size) {
      case 16: {
         
   
d4735 2
a4736 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d4738 1
a4738 1
            float16_t dst = -src0;
d4740 3
a4742 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d4744 4
a4747 5
         break;
      }
      case 32: {
         
   
d4749 2
a4750 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d4752 1
a4752 1
            float32_t dst = -src0;
d4754 3
a4756 2
            _dst_val.f32[_i] = dst;
      }
d4758 2
a4759 5
         break;
      }
      case 64: {
         
   
d4761 3
a4763 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = -src0;

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4768 2
a4769 2
evaluate_fnoise1_1(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4773 3
a4775 4
      switch (bit_size) {
      case 16: {
         
   
d4777 2
a4778 2
         
      struct float16_vec dst;
d4780 1
a4780 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d4782 4
a4785 1
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
d4787 4
a4790 5
         break;
      }
      case 32: {
         
   
d4792 2
a4793 2
         
      struct float32_vec dst;
d4795 1
a4795 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d4797 4
a4800 1
            _dst_val.f32[0] = dst.x;
d4802 2
a4803 5
         break;
      }
      case 64: {
         
   
d4805 3
a4807 13
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4812 2
a4813 2
evaluate_fnoise1_2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4817 3
a4819 4
      switch (bit_size) {
      case 16: {
         
   
d4821 2
a4822 2
         
      struct float16_vec dst;
d4824 1
a4824 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d4826 4
a4829 1
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
d4831 4
a4834 5
         break;
      }
      case 32: {
         
   
d4836 2
a4837 2
         
      struct float32_vec dst;
d4839 1
a4839 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d4841 4
a4844 1
            _dst_val.f32[0] = dst.x;
d4846 2
a4847 5
         break;
      }
      case 64: {
         
   
d4849 3
a4851 13
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4856 2
a4857 2
evaluate_fnoise1_3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4861 3
a4863 4
      switch (bit_size) {
      case 16: {
         
   
d4865 2
a4866 2
         
      struct float16_vec dst;
d4868 1
a4868 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d4870 4
a4873 1
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
d4875 4
a4878 5
         break;
      }
      case 32: {
         
   
d4880 2
a4881 2
         
      struct float32_vec dst;
d4883 1
a4883 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d4885 4
a4888 1
            _dst_val.f32[0] = dst.x;
d4890 2
a4891 5
         break;
      }
      case 64: {
         
   
d4893 3
a4895 13
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4900 2
a4901 2
evaluate_fnoise1_4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4905 3
a4907 4
      switch (bit_size) {
      case 16: {
         
   
d4909 2
a4910 2
         
      struct float16_vec dst;
d4912 1
a4912 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d4914 4
a4917 1
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
d4919 4
a4922 5
         break;
      }
      case 32: {
         
   
d4924 2
a4925 2
         
      struct float32_vec dst;
d4927 1
a4927 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d4929 4
a4932 1
            _dst_val.f32[0] = dst.x;
d4934 2
a4935 5
         break;
      }
      case 64: {
         
   
d4937 3
a4939 13
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4944 2
a4945 2
evaluate_fnoise2_1(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4949 3
a4951 4
      switch (bit_size) {
      case 16: {
         
   
d4953 4
a4956 2
         
      struct float16_vec dst;
d4958 1
a4958 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d4960 2
a4961 2
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
d4963 4
a4966 5
         break;
      }
      case 32: {
         
   
d4968 4
a4971 2
         
      struct float32_vec dst;
d4973 1
a4973 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d4975 2
a4976 2
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
d4978 2
a4979 5
         break;
      }
      case 64: {
         
   
d4981 3
a4983 14
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d4988 2
a4989 2
evaluate_fnoise2_2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d4993 3
a4995 4
      switch (bit_size) {
      case 16: {
         
   
d4997 6
a5002 2
         
      struct float16_vec dst;
d5004 1
a5004 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5006 2
a5007 2
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
d5009 4
a5012 5
         break;
      }
      case 32: {
         
   
d5014 6
a5019 2
         
      struct float32_vec dst;
d5021 1
a5021 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5023 2
a5024 2
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
d5026 2
a5027 5
         break;
      }
      case 64: {
         
   
d5029 3
a5031 14
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5036 2
a5037 2
evaluate_fnoise2_3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5041 3
a5043 4
      switch (bit_size) {
      case 16: {
         
   
d5045 6
a5050 2
         
      struct float16_vec dst;
d5052 1
a5052 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5054 2
a5055 2
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
d5057 4
a5060 5
         break;
      }
      case 32: {
         
   
d5062 6
a5067 2
         
      struct float32_vec dst;
d5069 1
a5069 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5071 2
a5072 2
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
d5074 2
a5075 5
         break;
      }
      case 64: {
         
   
d5077 3
a5079 14
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5084 2
a5085 2
evaluate_fnoise2_4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5089 3
a5091 4
      switch (bit_size) {
      case 16: {
         
   
d5093 4
a5096 2
         
      struct float16_vec dst;
d5098 1
a5098 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5100 2
a5101 2
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
d5103 4
a5106 5
         break;
      }
      case 32: {
         
   
d5108 4
a5111 2
         
      struct float32_vec dst;
d5113 1
a5113 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5115 2
a5116 2
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
d5118 2
a5119 5
         break;
      }
      case 64: {
         
   
d5121 3
a5123 14
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5128 2
a5129 2
evaluate_fnoise3_1(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5133 3
a5135 4
      switch (bit_size) {
      case 16: {
         
   
d5137 4
a5140 2
         
      struct float16_vec dst;
d5142 1
a5142 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5144 2
a5145 3
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
            _dst_val.u16[2] = _mesa_float_to_half(dst.z);
d5147 4
a5150 5
         break;
      }
      case 32: {
         
   
d5152 4
a5155 2
         
      struct float32_vec dst;
d5157 1
a5157 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5159 2
a5160 3
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
d5162 2
a5163 5
         break;
      }
      case 64: {
         
   
d5165 3
a5167 15
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;
            _dst_val.f64[2] = dst.z;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5172 2
a5173 2
evaluate_fnoise3_2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5177 3
a5179 4
      switch (bit_size) {
      case 16: {
         
   
d5181 6
a5186 2
         
      struct float16_vec dst;
d5188 1
a5188 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5190 2
a5191 3
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
            _dst_val.u16[2] = _mesa_float_to_half(dst.z);
d5193 4
a5196 5
         break;
      }
      case 32: {
         
   
d5198 6
a5203 2
         
      struct float32_vec dst;
d5205 1
a5205 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5207 2
a5208 3
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
d5210 2
a5211 5
         break;
      }
      case 64: {
         
   
d5213 3
a5215 15
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;
            _dst_val.f64[2] = dst.z;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5220 2
a5221 2
evaluate_fnoise3_3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5225 3
a5227 4
      switch (bit_size) {
      case 16: {
         
   
d5229 4
a5232 2
         
      struct float16_vec dst;
d5234 1
a5234 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5236 2
a5237 3
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
            _dst_val.u16[2] = _mesa_float_to_half(dst.z);
d5239 4
a5242 5
         break;
      }
      case 32: {
         
   
d5244 4
a5247 2
         
      struct float32_vec dst;
d5249 1
a5249 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5251 2
a5252 3
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
d5254 2
a5255 5
         break;
      }
      case 64: {
         
   
d5257 3
a5259 15
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;
            _dst_val.f64[2] = dst.z;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5264 2
a5265 2
evaluate_fnoise3_4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5269 3
a5271 4
      switch (bit_size) {
      case 16: {
         
   
d5273 4
a5276 2
         
      struct float16_vec dst;
d5278 1
a5278 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5280 2
a5281 3
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
            _dst_val.u16[2] = _mesa_float_to_half(dst.z);
d5283 4
a5286 5
         break;
      }
      case 32: {
         
   
d5288 4
a5291 2
         
      struct float32_vec dst;
d5293 1
a5293 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5295 2
a5296 3
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
d5298 2
a5299 5
         break;
      }
      case 64: {
         
   
d5301 3
a5303 15
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;
            _dst_val.f64[2] = dst.z;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5308 2
a5309 2
evaluate_fnoise4_1(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5313 3
a5315 4
      switch (bit_size) {
      case 16: {
         
   
d5317 4
a5320 2
         
      struct float16_vec dst;
d5322 1
a5322 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5324 2
a5325 4
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
            _dst_val.u16[2] = _mesa_float_to_half(dst.z);
            _dst_val.u16[3] = _mesa_float_to_half(dst.w);
d5327 4
a5330 5
         break;
      }
      case 32: {
         
   
d5332 4
a5335 2
         
      struct float32_vec dst;
d5337 1
a5337 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5339 2
a5340 4
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
            _dst_val.f32[3] = dst.w;
d5342 2
a5343 5
         break;
      }
      case 64: {
         
   
d5345 3
a5347 16
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;
            _dst_val.f64[2] = dst.z;
            _dst_val.f64[3] = dst.w;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5352 2
a5353 2
evaluate_fnoise4_2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5357 3
a5359 4
      switch (bit_size) {
      case 16: {
         
   
d5361 4
a5364 2
         
      struct float16_vec dst;
d5366 1
a5366 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5368 2
a5369 4
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
            _dst_val.u16[2] = _mesa_float_to_half(dst.z);
            _dst_val.u16[3] = _mesa_float_to_half(dst.w);
d5371 4
a5374 5
         break;
      }
      case 32: {
         
   
d5376 4
a5379 2
         
      struct float32_vec dst;
d5381 1
a5381 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5383 2
a5384 4
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
            _dst_val.f32[3] = dst.w;
d5386 2
a5387 5
         break;
      }
      case 64: {
         
   
d5389 3
a5391 16
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;
            _dst_val.f64[2] = dst.z;
            _dst_val.f64[3] = dst.w;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5396 2
a5397 2
evaluate_fnoise4_3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5401 3
a5403 4
      switch (bit_size) {
      case 16: {
         
   
d5405 4
a5408 2
         
      struct float16_vec dst;
d5410 1
a5410 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5412 2
a5413 4
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
            _dst_val.u16[2] = _mesa_float_to_half(dst.z);
            _dst_val.u16[3] = _mesa_float_to_half(dst.w);
d5415 4
a5418 5
         break;
      }
      case 32: {
         
   
d5420 4
a5423 2
         
      struct float32_vec dst;
d5425 1
a5425 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5427 2
a5428 4
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
            _dst_val.f32[3] = dst.w;
d5430 2
a5431 5
         break;
      }
      case 64: {
         
   
d5433 3
a5435 16
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;
            _dst_val.f64[2] = dst.z;
            _dst_val.f64[3] = dst.w;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5440 2
a5441 2
evaluate_fnoise4_4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5445 3
a5447 4
      switch (bit_size) {
      case 16: {
         
   
d5449 4
a5452 2
         
      struct float16_vec dst;
d5454 1
a5454 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5456 2
a5457 4
            _dst_val.u16[0] = _mesa_float_to_half(dst.x);
            _dst_val.u16[1] = _mesa_float_to_half(dst.y);
            _dst_val.u16[2] = _mesa_float_to_half(dst.z);
            _dst_val.u16[3] = _mesa_float_to_half(dst.w);
d5459 4
a5462 5
         break;
      }
      case 32: {
         
   
d5464 4
a5467 2
         
      struct float32_vec dst;
d5469 1
a5469 1
         dst.x = dst.y = dst.z = dst.w = 0.0f;
d5471 2
a5472 4
            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
            _dst_val.f32[3] = dst.w;
d5474 2
a5475 5
         break;
      }
      case 64: {
         
   
d5477 3
a5479 16
         
      struct float64_vec dst;

         dst.x = dst.y = dst.z = dst.w = 0.0f;

            _dst_val.f64[0] = dst.x;
            _dst_val.f64[1] = dst.y;
            _dst_val.f64[2] = dst.z;
            _dst_val.f64[3] = dst.w;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5484 2
a5485 2
evaluate_fnot(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5489 3
a5491 4
      switch (bit_size) {
      case 16: {
         
   
d5493 6
a5498 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d5500 1
a5500 1
            float16_t dst = bit_size == 64 ? ((src0 == 0.0) ? 1.0 : 0.0f) : ((src0 == 0.0f) ? 1.0f : 0.0f);
d5502 2
a5503 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d5505 4
a5508 5
         break;
      }
      case 32: {
         
   
d5510 6
a5515 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d5517 1
a5517 1
            float32_t dst = bit_size == 64 ? ((src0 == 0.0) ? 1.0 : 0.0f) : ((src0 == 0.0f) ? 1.0f : 0.0f);
d5519 2
a5520 2
            _dst_val.f32[_i] = dst;
      }
d5522 2
a5523 5
         break;
      }
      case 64: {
         
   
d5525 3
a5527 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = bit_size == 64 ? ((src0 == 0.0) ? 1.0 : 0.0f) : ((src0 == 0.0f) ? 1.0f : 0.0f);

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5532 2
a5533 2
evaluate_for(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5537 17
a5554 1
   
d5556 6
a5561 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];
d5563 2
a5564 1
            float32_t dst = ((src0 != 0.0f) || (src1 != 0.0f)) ? 1.0f : 0.0f;
d5566 2
a5567 2
            _dst_val.f32[_i] = dst;
      }
d5569 3
d5576 2
a5577 2
evaluate_fpow(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5581 12
a5592 4
      switch (bit_size) {
      case 16: {
         
   
d5594 2
a5595 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            float16_t dst = bit_size == 64 ? powf(src0, src1) : pow(src0, src1);

            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }

         break;
      }
      case 32: {
         
   
d5597 4
a5600 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            float32_t dst = bit_size == 64 ? powf(src0, src1) : pow(src0, src1);

            _dst_val.f32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d5602 6
a5607 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d5609 1
a5609 1
            float64_t dst = bit_size == 64 ? powf(src0, src1) : pow(src0, src1);
d5611 2
a5612 2
            _dst_val.f64[_i] = dst;
      }
d5614 2
a5615 2
         break;
      }
d5617 3
a5619 3
      default:
         unreachable("unknown bit width");
      }
d5624 2
a5625 2
evaluate_fquantize2f16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5629 3
a5631 4
      switch (bit_size) {
      case 16: {
         
   
d5633 4
a5636 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d5638 1
a5638 1
            float16_t dst = (fabs(src0) < ldexpf(1.0, -14)) ? copysignf(0.0f, src0) : _mesa_half_to_float(_mesa_float_to_half(src0));
d5640 2
a5641 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d5643 4
a5646 5
         break;
      }
      case 32: {
         
   
d5648 4
a5651 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d5653 1
a5653 1
            float32_t dst = (fabs(src0) < ldexpf(1.0, -14)) ? copysignf(0.0f, src0) : _mesa_half_to_float(_mesa_float_to_half(src0));
d5655 2
a5656 2
            _dst_val.f32[_i] = dst;
      }
d5658 2
a5659 5
         break;
      }
      case 64: {
         
   
d5661 3
a5663 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = (fabs(src0) < ldexpf(1.0, -14)) ? copysignf(0.0f, src0) : _mesa_half_to_float(_mesa_float_to_half(src0));

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5668 2
a5669 2
evaluate_frcp(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5673 3
a5675 4
      switch (bit_size) {
      case 16: {
         
   
d5677 4
a5680 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d5682 1
a5682 1
            float16_t dst = bit_size == 64 ? 1.0 / src0 : 1.0f / src0;
d5684 2
a5685 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d5687 4
a5690 5
         break;
      }
      case 32: {
         
   
d5692 4
a5695 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d5697 1
a5697 1
            float32_t dst = bit_size == 64 ? 1.0 / src0 : 1.0f / src0;
d5699 2
a5700 2
            _dst_val.f32[_i] = dst;
      }
d5702 2
a5703 5
         break;
      }
      case 64: {
         
   
d5705 3
a5707 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = bit_size == 64 ? 1.0 / src0 : 1.0f / src0;

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5712 2
a5713 2
evaluate_frem(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5717 10
a5726 4
      switch (bit_size) {
      case 16: {
         
   
d5728 2
a5729 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            float16_t dst = src0 - src1 * truncf(src0 / src1);

            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }

         break;
      }
      case 32: {
         
   
d5731 4
a5734 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            float32_t dst = src0 - src1 * truncf(src0 / src1);

            _dst_val.f32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d5736 4
a5739 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d5741 1
a5741 1
            float64_t dst = src0 - src1 * truncf(src0 / src1);
d5743 2
a5744 2
            _dst_val.f64[_i] = dst;
      }
d5746 2
a5747 2
         break;
      }
d5749 3
a5751 3
      default:
         unreachable("unknown bit width");
      }
d5756 2
a5757 2
evaluate_fround_even(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5761 3
a5763 4
      switch (bit_size) {
      case 16: {
         
   
d5765 4
a5768 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d5770 1
a5770 1
            float16_t dst = bit_size == 64 ? _mesa_roundeven(src0) : _mesa_roundevenf(src0);
d5772 2
a5773 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d5775 4
a5778 5
         break;
      }
      case 32: {
         
   
d5780 4
a5783 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d5785 1
a5785 1
            float32_t dst = bit_size == 64 ? _mesa_roundeven(src0) : _mesa_roundevenf(src0);
d5787 2
a5788 2
            _dst_val.f32[_i] = dst;
      }
d5790 2
a5791 5
         break;
      }
      case 64: {
         
   
d5793 3
a5795 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = bit_size == 64 ? _mesa_roundeven(src0) : _mesa_roundevenf(src0);

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5800 2
a5801 2
evaluate_frsq(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5805 3
a5807 4
      switch (bit_size) {
      case 16: {
         
   
d5809 6
a5814 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d5816 1
a5816 1
            float16_t dst = bit_size == 64 ? 1.0 / sqrt(src0) : 1.0f / sqrtf(src0);
d5818 2
a5819 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d5821 4
a5824 5
         break;
      }
      case 32: {
         
   
d5826 6
a5831 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d5833 1
a5833 1
            float32_t dst = bit_size == 64 ? 1.0 / sqrt(src0) : 1.0f / sqrtf(src0);
d5835 2
a5836 2
            _dst_val.f32[_i] = dst;
      }
d5838 2
a5839 5
         break;
      }
      case 64: {
         
   
d5841 3
a5843 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = bit_size == 64 ? 1.0 / sqrt(src0) : 1.0f / sqrtf(src0);

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5848 2
a5849 2
evaluate_fsat(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5853 3
a5855 4
      switch (bit_size) {
      case 16: {
         
   
d5857 6
a5862 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d5864 1
a5864 1
            float16_t dst = bit_size == 64 ? ((src0 > 1.0) ? 1.0 : ((src0 <= 0.0) ? 0.0 : src0)) : ((src0 > 1.0f) ? 1.0f : ((src0 <= 0.0f) ? 0.0f : src0));
d5866 2
a5867 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d5869 4
a5872 5
         break;
      }
      case 32: {
         
   
d5874 6
a5879 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d5881 1
a5881 1
            float32_t dst = bit_size == 64 ? ((src0 > 1.0) ? 1.0 : ((src0 <= 0.0) ? 0.0 : src0)) : ((src0 > 1.0f) ? 1.0f : ((src0 <= 0.0f) ? 0.0f : src0));
d5883 2
a5884 2
            _dst_val.f32[_i] = dst;
      }
d5886 2
a5887 5
         break;
      }
      case 64: {
         
   
d5889 3
a5891 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = bit_size == 64 ? ((src0 > 1.0) ? 1.0 : ((src0 <= 0.0) ? 0.0 : src0)) : ((src0 > 1.0f) ? 1.0f : ((src0 <= 0.0f) ? 0.0f : src0));

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5896 2
a5897 2
evaluate_fsign(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5901 3
a5903 4
      switch (bit_size) {
      case 16: {
         
   
d5905 8
a5912 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d5914 13
a5926 1
            float16_t dst = bit_size == 64 ? ((src0 == 0.0) ? 0.0 : ((src0 > 0.0) ? 1.0 : -1.0)) : ((src0 == 0.0f) ? 0.0f : ((src0 > 0.0f) ? 1.0f : -1.0f));
a5927 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d5929 2
a5930 5
         break;
      }
      case 32: {
         
   
d5932 4
a5935 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d5937 8
a5944 1
            float32_t dst = bit_size == 64 ? ((src0 == 0.0) ? 0.0 : ((src0 > 0.0) ? 1.0 : -1.0)) : ((src0 == 0.0f) ? 0.0f : ((src0 > 0.0f) ? 1.0f : -1.0f));
d5946 13
a5958 2
            _dst_val.f32[_i] = dst;
      }
a5959 5
         break;
      }
      case 64: {
         
   
d5961 2
a5962 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
d5964 2
a5965 1
            float64_t dst = bit_size == 64 ? ((src0 == 0.0) ? 0.0 : ((src0 > 0.0) ? 1.0 : -1.0)) : ((src0 == 0.0f) ? 0.0f : ((src0 > 0.0f) ? 1.0f : -1.0f));
d5967 3
a5969 9
            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d5974 2
a5975 2
evaluate_fsin(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d5979 3
a5981 4
      switch (bit_size) {
      case 16: {
         
   
d5983 8
a5990 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d5992 11
a6002 1
            float16_t dst = bit_size == 64 ? sin(src0) : sinf(src0);
a6003 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d6005 2
a6006 5
         break;
      }
      case 32: {
         
   
d6008 4
a6011 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d6013 8
a6020 1
            float32_t dst = bit_size == 64 ? sin(src0) : sinf(src0);
d6022 11
a6032 2
            _dst_val.f32[_i] = dst;
      }
a6033 5
         break;
      }
      case 64: {
         
   
d6035 2
a6036 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
d6038 2
a6039 1
            float64_t dst = bit_size == 64 ? sin(src0) : sinf(src0);
d6041 3
a6043 9
            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d6048 2
a6049 2
evaluate_fsqrt(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6053 3
a6055 4
      switch (bit_size) {
      case 16: {
         
   
d6057 6
a6062 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d6064 1
a6064 1
            float16_t dst = bit_size == 64 ? sqrt(src0) : sqrtf(src0);
d6066 2
a6067 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d6069 4
a6072 5
         break;
      }
      case 32: {
         
   
d6074 6
a6079 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d6081 1
a6081 1
            float32_t dst = bit_size == 64 ? sqrt(src0) : sqrtf(src0);
d6083 2
a6084 2
            _dst_val.f32[_i] = dst;
      }
d6086 2
a6087 5
         break;
      }
      case 64: {
         
   
d6089 3
a6091 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];

            float64_t dst = bit_size == 64 ? sqrt(src0) : sqrtf(src0);

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d6096 2
a6097 2
evaluate_fsub(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6101 12
a6112 4
      switch (bit_size) {
      case 16: {
         
   
d6114 2
a6115 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const float src1 =
                  _mesa_half_to_float(_src[1].u16[_i]);

            float16_t dst = src0 - src1;

            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }

         break;
      }
      case 32: {
         
   
d6117 4
a6120 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];

            float32_t dst = src0 - src1;

            _dst_val.f32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d6122 6
a6127 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const float64_t src1 =
                  _src[1].f64[_i];
d6129 1
a6129 1
            float64_t dst = src0 - src1;
d6131 2
a6132 2
            _dst_val.f64[_i] = dst;
      }
d6134 2
a6135 2
         break;
      }
d6137 3
a6139 3
      default:
         unreachable("unknown bit width");
      }
d6144 2
a6145 2
evaluate_ftrunc(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6149 3
a6151 4
      switch (bit_size) {
      case 16: {
         
   
d6153 4
a6156 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
d6158 13
a6170 1
            float16_t dst = bit_size == 64 ? trunc(src0) : truncf(src0);
a6171 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d6173 2
a6174 5
         break;
      }
      case 32: {
         
   
d6176 4
a6179 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
d6181 4
a6184 1
            float32_t dst = bit_size == 64 ? trunc(src0) : truncf(src0);
d6186 13
a6198 2
            _dst_val.f32[_i] = dst;
      }
a6199 5
         break;
      }
      case 64: {
         
   
d6201 2
a6202 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
d6204 2
a6205 1
            float64_t dst = bit_size == 64 ? trunc(src0) : truncf(src0);
d6207 3
a6209 9
            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d6214 2
a6215 2
evaluate_fxor(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6219 19
a6238 1
   
d6240 8
a6247 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];
d6249 2
a6250 1
            float32_t dst = (src0 != 0.0f && src1 == 0.0f) || (src0 == 0.0f && src1 != 0.0f) ? 1.0f : 0.0f;
d6252 2
a6253 2
            _dst_val.f32[_i] = dst;
      }
d6255 3
d6262 2
a6263 2
evaluate_i2b(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6267 10
a6276 4
      switch (bit_size) {
      case 8: {
         
   
d6278 9
a6286 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d6288 6
a6293 1
            bool32_t dst = src0 != 0;
d6295 1
a6295 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d6297 2
a6298 5
         break;
      }
      case 16: {
         
   
d6300 2
a6301 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d6303 3
a6305 1
            bool32_t dst = src0 != 0;
d6307 7
a6313 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d6315 3
a6317 5
         break;
      }
      case 32: {
         
   
d6319 6
a6324 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
d6326 1
a6326 1
            bool32_t dst = src0 != 0;
d6328 2
a6329 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d6331 4
a6334 5
         break;
      }
      case 64: {
         
   
d6336 6
a6341 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
d6343 1
a6343 1
            bool32_t dst = src0 != 0;
d6345 2
a6346 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d6348 2
a6349 2
         break;
      }
d6351 3
a6353 3
      default:
         unreachable("unknown bit width");
      }
d6358 2
a6359 2
evaluate_i2f16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6363 15
a6377 4
      switch (bit_size) {
      case 8: {
         
   
d6379 4
a6382 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d6384 6
a6389 1
            float16_t dst = src0;
d6391 1
a6391 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d6393 2
a6394 5
         break;
      }
      case 16: {
         
   
d6396 2
a6397 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d6399 3
a6401 1
            float16_t dst = src0;
d6403 7
a6409 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d6411 3
a6413 5
         break;
      }
      case 32: {
         
   
d6415 6
a6420 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
d6422 1
a6422 1
            float16_t dst = src0;
d6424 2
a6425 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d6427 4
a6430 5
         break;
      }
      case 64: {
         
   
d6432 6
a6437 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
d6439 1
a6439 1
            float16_t dst = src0;
d6441 2
a6442 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d6444 2
a6445 2
         break;
      }
d6447 3
a6449 3
      default:
         unreachable("unknown bit width");
      }
d6454 2
a6455 2
evaluate_i2f32(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6459 10
a6468 4
      switch (bit_size) {
      case 8: {
         
   
d6470 7
a6476 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d6478 4
a6481 1
            float32_t dst = src0;
d6483 1
a6483 2
            _dst_val.f32[_i] = dst;
      }
d6485 2
a6486 5
         break;
      }
      case 16: {
         
   
d6488 2
a6489 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d6491 3
a6493 1
            float32_t dst = src0;
d6495 7
a6501 2
            _dst_val.f32[_i] = dst;
      }
d6503 3
a6505 5
         break;
      }
      case 32: {
         
   
d6507 6
a6512 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
d6514 1
a6514 1
            float32_t dst = src0;
d6516 2
a6517 2
            _dst_val.f32[_i] = dst;
      }
d6519 4
a6522 5
         break;
      }
      case 64: {
         
   
d6524 6
a6529 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
d6531 1
a6531 1
            float32_t dst = src0;
d6533 2
a6534 2
            _dst_val.f32[_i] = dst;
      }
d6536 2
a6537 2
         break;
      }
d6539 3
a6541 3
      default:
         unreachable("unknown bit width");
      }
d6546 2
a6547 2
evaluate_i2f64(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6551 3
a6553 4
      switch (bit_size) {
      case 8: {
         
   
d6555 6
a6560 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d6562 1
a6562 1
            float64_t dst = src0;
d6564 2
a6565 2
            _dst_val.f64[_i] = dst;
      }
d6567 4
a6570 5
         break;
      }
      case 16: {
         
   
d6572 6
a6577 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d6579 1
a6579 1
            float64_t dst = src0;
d6581 2
a6582 2
            _dst_val.f64[_i] = dst;
      }
d6584 2
a6585 5
         break;
      }
      case 32: {
         
   
d6587 3
a6589 32
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];

            float64_t dst = src0;

            _dst_val.f64[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];

            float64_t dst = src0;

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d6594 2
a6595 2
evaluate_i2i16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6599 3
a6601 4
      switch (bit_size) {
      case 8: {
         
   
d6603 6
a6608 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d6610 1
a6610 1
            int16_t dst = src0;
d6612 2
a6613 2
            _dst_val.i16[_i] = dst;
      }
d6615 4
a6618 5
         break;
      }
      case 16: {
         
   
d6620 6
a6625 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d6627 1
a6627 1
            int16_t dst = src0;
d6629 2
a6630 2
            _dst_val.i16[_i] = dst;
      }
d6632 2
a6633 5
         break;
      }
      case 32: {
         
   
d6635 3
a6637 32
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];

            int16_t dst = src0;

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];

            int16_t dst = src0;

            _dst_val.i16[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d6642 2
a6643 2
evaluate_i2i32(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6647 3
a6649 4
      switch (bit_size) {
      case 8: {
         
   
d6651 4
a6654 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d6656 1
a6656 1
            int32_t dst = src0;
d6658 2
a6659 2
            _dst_val.i32[_i] = dst;
      }
d6661 4
a6664 5
         break;
      }
      case 16: {
         
   
d6666 4
a6669 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d6671 1
a6671 1
            int32_t dst = src0;
d6673 2
a6674 2
            _dst_val.i32[_i] = dst;
      }
d6676 2
a6677 5
         break;
      }
      case 32: {
         
   
d6679 3
a6681 32
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];

            int32_t dst = src0;

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];

            int32_t dst = src0;

            _dst_val.i32[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d6686 2
a6687 2
evaluate_i2i64(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6691 3
a6693 4
      switch (bit_size) {
      case 8: {
         
   
d6695 4
a6698 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d6700 1
a6700 1
            int64_t dst = src0;
d6702 2
a6703 2
            _dst_val.i64[_i] = dst;
      }
d6705 4
a6708 5
         break;
      }
      case 16: {
         
   
d6710 4
a6713 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d6715 1
a6715 1
            int64_t dst = src0;
d6717 2
a6718 2
            _dst_val.i64[_i] = dst;
      }
d6720 2
a6721 5
         break;
      }
      case 32: {
         
   
d6723 3
a6725 32
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];

            int64_t dst = src0;

            _dst_val.i64[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];

            int64_t dst = src0;

            _dst_val.i64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d6730 2
a6731 2
evaluate_i2i8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6735 3
a6737 4
      switch (bit_size) {
      case 8: {
         
   
d6739 6
a6744 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d6746 1
a6746 1
            int8_t dst = src0;
d6748 2
a6749 2
            _dst_val.i8[_i] = dst;
      }
d6751 4
a6754 5
         break;
      }
      case 16: {
         
   
d6756 6
a6761 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d6763 1
a6763 1
            int8_t dst = src0;
d6765 2
a6766 2
            _dst_val.i8[_i] = dst;
      }
d6768 2
a6769 5
         break;
      }
      case 32: {
         
   
d6771 3
a6773 32
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];

            int8_t dst = src0;

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];

            int8_t dst = src0;

            _dst_val.i8[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d6778 2
a6779 2
evaluate_iabs(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6783 3
a6785 4
      switch (bit_size) {
      case 8: {
         
   
d6787 6
a6792 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d6794 1
a6794 1
            int8_t dst = (src0 < 0) ? -src0 : src0;
d6796 2
a6797 2
            _dst_val.i8[_i] = dst;
      }
d6799 4
a6802 5
         break;
      }
      case 16: {
         
   
d6804 6
a6809 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d6811 1
a6811 1
            int16_t dst = (src0 < 0) ? -src0 : src0;
d6813 2
a6814 2
            _dst_val.i16[_i] = dst;
      }
d6816 2
a6817 5
         break;
      }
      case 32: {
         
   
d6819 3
a6821 32
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];

            int32_t dst = (src0 < 0) ? -src0 : src0;

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];

            int64_t dst = (src0 < 0) ? -src0 : src0;

            _dst_val.i64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d6826 2
a6827 2
evaluate_iadd(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6831 10
a6840 4
      switch (bit_size) {
      case 8: {
         
   
d6842 1
a6842 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            int8_t dst = src0 + src1;

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d6844 2
a6845 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            int16_t dst = src0 + src1;

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d6847 4
a6850 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            int32_t dst = src0 + src1;

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d6852 6
a6857 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
d6859 1
a6859 1
            int64_t dst = src0 + src1;
d6861 2
a6862 2
            _dst_val.i64[_i] = dst;
      }
d6864 2
a6865 2
         break;
      }
d6867 3
a6869 3
      default:
         unreachable("unknown bit width");
      }
d6874 2
a6875 2
evaluate_iand(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6879 10
a6888 4
      switch (bit_size) {
      case 8: {
         
   
d6890 1
a6890 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            uint8_t dst = src0 & src1;

            _dst_val.u8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d6892 2
a6893 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            uint16_t dst = src0 & src1;

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d6895 4
a6898 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint32_t dst = src0 & src1;

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d6900 6
a6905 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
d6907 1
a6907 1
            uint64_t dst = src0 & src1;
d6909 2
a6910 2
            _dst_val.u64[_i] = dst;
      }
d6912 2
a6913 2
         break;
      }
d6915 3
a6917 3
      default:
         unreachable("unknown bit width");
      }
d6922 2
a6923 2
evaluate_ibfe(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6927 2
a6929 1
   
d6931 6
a6936 8
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];
               const int32_t src2 =
                  _src[2].i32[_i];
d6938 7
a6944 1
            int32_t dst;
d6947 5
a6951 11
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}
d6953 2
d6956 2
a6957 2
            _dst_val.i32[_i] = dst;
      }
d6959 3
d6966 2
a6967 2
evaluate_ibitfield_extract(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d6971 2
a6973 1
   
d6975 16
a6990 8
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];
               const int32_t src2 =
                  _src[2].i32[_i];
d6992 6
a6997 1
            int32_t dst;
d6999 1
a6999 10
            
int base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (offset < 0 || bits < 0 || offset + bits > 32) {
   dst = 0;
} else {
   dst = (base << (32 - offset - bits)) >> offset; /* use sign-extending shift */
}
d7001 2
d7004 2
a7005 2
            _dst_val.i32[_i] = dst;
      }
d7007 3
d7014 2
a7015 2
evaluate_idiv(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7019 10
a7028 4
      switch (bit_size) {
      case 8: {
         
   
d7030 1
a7030 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            int8_t dst = src0 / src1;

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d7032 2
a7033 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            int16_t dst = src0 / src1;

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d7035 4
a7038 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            int32_t dst = src0 / src1;

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d7040 6
a7045 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
d7047 1
a7047 1
            int64_t dst = src0 / src1;
d7049 2
a7050 2
            _dst_val.i64[_i] = dst;
      }
d7052 2
a7053 2
         break;
      }
d7055 3
a7057 3
      default:
         unreachable("unknown bit width");
      }
d7062 2
a7063 2
evaluate_ieq(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7067 18
a7084 4
      switch (bit_size) {
      case 8: {
         
   
d7086 2
a7087 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            bool32_t dst = src0 == src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 16: {
         
   
d7089 4
a7092 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            bool32_t dst = src0 == src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 32: {
         
   
d7094 6
a7099 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            bool32_t dst = src0 == src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 64: {
         
   
d7101 6
a7106 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
a7107 1
            bool32_t dst = src0 == src1;
d7109 2
a7110 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d7112 2
a7113 2
         break;
      }
d7115 3
a7117 3
      default:
         unreachable("unknown bit width");
      }
d7122 2
a7123 2
evaluate_ifind_msb(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7127 2
a7129 1
   
a7130 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
d7132 10
a7141 1
            int32_t dst;
a7142 9
            
dst = -1;
for (int bit = 31; bit >= 0; bit--) {
   /* If src0 < 0, we're looking for the first 0 bit.
    * if src0 >= 0, we're looking for the first 1 bit.
    */
   if ((((src0 >> bit) & 1) && (src0 >= 0)) ||
      (!((src0 >> bit) & 1) && (src0 < 0))) {
      dst = bit;
d7145 12
a7156 1
}
d7158 1
d7160 2
a7161 2
            _dst_val.i32[_i] = dst;
      }
d7163 3
d7170 2
a7171 2
evaluate_ige(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7175 10
a7184 4
      switch (bit_size) {
      case 8: {
         
   
d7186 1
a7186 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            bool32_t dst = src0 >= src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 16: {
         
   
d7188 2
a7189 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            bool32_t dst = src0 >= src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 32: {
         
   
d7191 4
a7194 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            bool32_t dst = src0 >= src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 64: {
         
   
d7196 6
a7201 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
d7203 1
a7203 1
            bool32_t dst = src0 >= src1;
d7205 2
a7206 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d7208 2
a7209 2
         break;
      }
d7211 3
a7213 3
      default:
         unreachable("unknown bit width");
      }
d7218 2
a7219 2
evaluate_ilt(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7223 3
a7225 4
      switch (bit_size) {
      case 8: {
         
   
a7226 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            bool32_t dst = src0 < src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 16: {
         
   
d7228 4
a7231 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            bool32_t dst = src0 < src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 32: {
         
   
d7233 1
a7233 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            bool32_t dst = src0 < src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 64: {
         
   
d7235 3
a7237 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
a7238 1
            bool32_t dst = src0 < src1;
d7240 1
a7240 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d7242 4
a7245 14
         break;
      }

      default:
         unreachable("unknown bit width");
      }

   return _dst_val;
}
static nir_const_value
evaluate_imax(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
a7246 4
      switch (bit_size) {
      case 8: {
         
   
d7248 4
a7251 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            int8_t dst = src1 > src0 ? src1 : src0;

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d7253 1
a7253 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            int16_t dst = src1 > src0 ? src1 : src0;

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d7255 3
a7257 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            int32_t dst = src1 > src0 ? src1 : src0;

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
a7258 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
d7260 1
a7260 1
            int64_t dst = src1 > src0 ? src1 : src0;
d7262 2
a7263 2
            _dst_val.i64[_i] = dst;
      }
d7265 3
a7267 6
         break;
      }

      default:
         unreachable("unknown bit width");
      }
d7272 2
a7273 2
evaluate_imin(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7277 3
a7279 40
      switch (bit_size) {
      case 8: {
         
   

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            int8_t dst = src1 > src0 ? src0 : src1;

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            int16_t dst = src1 > src0 ? src0 : src1;

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
a7280 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            int32_t dst = src1 > src0 ? src0 : src1;

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d7282 3
a7284 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
d7286 3
a7288 1
            int64_t dst = src1 > src0 ? src0 : src1;
d7290 1
a7290 2
            _dst_val.i64[_i] = dst;
      }
d7292 1
a7292 2
         break;
      }
d7294 1
a7294 3
      default:
         unreachable("unknown bit width");
      }
d7296 4
a7299 12
   return _dst_val;
}
static nir_const_value
evaluate_imod(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

      switch (bit_size) {
      case 8: {
         
   
a7300 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            int8_t dst = src1 == 0 ? 0 : ((src0 % src1 == 0 || (src0 >= 0) == (src1 >= 0)) ?                 src0 % src1 : src0 % src1 + src1);

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d7302 3
a7304 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            int16_t dst = src1 == 0 ? 0 : ((src0 % src1 == 0 || (src0 >= 0) == (src1 >= 0)) ?                 src0 % src1 : src0 % src1 + src1);

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d7306 3
a7308 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            int32_t dst = src1 == 0 ? 0 : ((src0 % src1 == 0 || (src0 >= 0) == (src1 >= 0)) ?                 src0 % src1 : src0 % src1 + src1);

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d7310 1
a7310 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
d7312 1
a7312 1
            int64_t dst = src1 == 0 ? 0 : ((src0 % src1 == 0 || (src0 >= 0) == (src1 >= 0)) ?                 src0 % src1 : src0 % src1 + src1);
d7314 1
a7314 2
            _dst_val.i64[_i] = dst;
      }
d7316 2
a7317 2
         break;
      }
d7319 3
a7321 3
      default:
         unreachable("unknown bit width");
      }
d7326 2
a7327 2
evaluate_imov(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7331 3
a7333 4
      switch (bit_size) {
      case 8: {
         
   
a7334 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d7336 4
a7339 1
            int8_t dst = src0;
d7341 1
a7341 2
            _dst_val.i8[_i] = dst;
      }
d7343 3
a7345 5
         break;
      }
      case 16: {
         
   
a7346 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d7348 1
a7348 1
            int16_t dst = src0;
d7350 4
a7353 2
            _dst_val.i16[_i] = dst;
      }
a7354 5
         break;
      }
      case 32: {
         
   
d7356 4
a7359 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
d7361 1
a7361 1
            int32_t dst = src0;
d7363 3
a7365 2
            _dst_val.i32[_i] = dst;
      }
a7366 5
         break;
      }
      case 64: {
         
   
d7368 1
a7368 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
d7370 2
a7371 1
            int64_t dst = src0;
d7373 3
a7375 9
            _dst_val.i64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d7380 2
a7381 2
evaluate_imul(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7385 3
a7387 4
      switch (bit_size) {
      case 8: {
         
   
a7388 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            int8_t dst = src0 * src1;

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d7390 6
a7395 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            int16_t dst = src0 * src1;

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d7397 1
a7397 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            int32_t dst = src0 * src1;

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d7399 5
a7403 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
a7404 1
            int64_t dst = src0 * src1;
d7406 1
a7406 17
            _dst_val.i64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }

   return _dst_val;
}
static nir_const_value
evaluate_imul_high(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d7408 3
a7411 1
   
a7412 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];
d7414 6
a7419 1
            int32_t dst = (int32_t)(((int64_t) src0 * (int64_t) src1) >> 32);
d7421 1
a7421 2
            _dst_val.i32[_i] = dst;
      }
d7423 5
a7428 12
   return _dst_val;
}
static nir_const_value
evaluate_ine(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

      switch (bit_size) {
      case 8: {
         
   
d7430 1
a7430 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            bool32_t dst = src0 != src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 16: {
         
   
d7432 2
a7433 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            bool32_t dst = src0 != src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 32: {
         
   
d7435 3
a7437 36
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            bool32_t dst = src0 != src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 64: {
         
   

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];

            bool32_t dst = src0 != src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d7442 2
a7443 2
evaluate_ineg(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7447 3
a7449 4
      switch (bit_size) {
      case 8: {
         
   
a7450 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d7452 4
a7455 1
            int8_t dst = -src0;
d7457 1
a7457 2
            _dst_val.i8[_i] = dst;
      }
d7459 3
a7461 5
         break;
      }
      case 16: {
         
   
a7462 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d7464 1
a7464 1
            int16_t dst = -src0;
d7466 4
a7469 2
            _dst_val.i16[_i] = dst;
      }
a7470 5
         break;
      }
      case 32: {
         
   
d7472 4
a7475 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
d7477 1
a7477 1
            int32_t dst = -src0;
d7479 3
a7481 2
            _dst_val.i32[_i] = dst;
      }
a7482 5
         break;
      }
      case 64: {
         
   
d7484 1
a7484 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
d7486 2
a7487 1
            int64_t dst = -src0;
d7489 3
a7491 9
            _dst_val.i64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d7496 2
a7497 2
evaluate_inot(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7501 3
a7503 4
      switch (bit_size) {
      case 8: {
         
   
a7504 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d7506 6
a7511 1
            int8_t dst = ~src0;
d7513 1
a7513 2
            _dst_val.i8[_i] = dst;
      }
d7515 5
a7519 5
         break;
      }
      case 16: {
         
   
a7520 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d7522 1
a7522 1
            int16_t dst = ~src0;
d7524 4
a7527 2
            _dst_val.i16[_i] = dst;
      }
a7528 5
         break;
      }
      case 32: {
         
   
d7530 6
a7535 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
d7537 1
a7537 1
            int32_t dst = ~src0;
d7539 5
a7543 2
            _dst_val.i32[_i] = dst;
      }
a7544 5
         break;
      }
      case 64: {
         
   
d7546 1
a7546 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
d7548 2
a7549 1
            int64_t dst = ~src0;
d7551 3
a7553 9
            _dst_val.i64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d7558 2
a7559 2
evaluate_ior(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7563 3
a7565 4
      switch (bit_size) {
      case 8: {
         
   
a7566 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            uint8_t dst = src0 | src1;

            _dst_val.u8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d7568 4
a7571 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            uint16_t dst = src0 | src1;

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d7573 1
a7573 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint32_t dst = src0 | src1;

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d7575 2
a7576 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
a7577 1
            uint64_t dst = src0 | src1;
d7579 1
a7579 2
            _dst_val.u64[_i] = dst;
      }
d7581 4
a7584 14
         break;
      }

      default:
         unreachable("unknown bit width");
      }

   return _dst_val;
}
static nir_const_value
evaluate_irem(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
a7585 4
      switch (bit_size) {
      case 8: {
         
   
d7587 4
a7590 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            int8_t dst = src1 == 0 ? 0 : src0 % src1;

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d7592 1
a7592 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            int16_t dst = src1 == 0 ? 0 : src0 % src1;

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d7594 2
a7595 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            int32_t dst = src1 == 0 ? 0 : src0 % src1;

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
a7596 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
d7598 1
a7598 1
            int64_t dst = src1 == 0 ? 0 : src0 % src1;
d7600 2
a7601 2
            _dst_val.i64[_i] = dst;
      }
d7603 3
a7605 6
         break;
      }

      default:
         unreachable("unknown bit width");
      }
d7610 2
a7611 2
evaluate_ishl(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7615 3
a7617 4
      switch (bit_size) {
      case 8: {
         
   
a7618 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            int8_t dst = src0 << src1;

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d7620 6
a7625 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            int16_t dst = src0 << src1;

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d7627 1
a7627 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            int32_t dst = src0 << src1;

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d7629 5
a7633 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];
a7634 1
            int64_t dst = src0 << src1;
d7636 1
a7636 2
            _dst_val.i64[_i] = dst;
      }
d7638 4
a7641 2
         break;
      }
a7642 3
      default:
         unreachable("unknown bit width");
      }
d7644 6
a7649 7
   return _dst_val;
}
static nir_const_value
evaluate_ishr(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d7651 1
a7651 4
      switch (bit_size) {
      case 8: {
         
   
d7653 5
a7657 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            int8_t dst = src0 >> src1;

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
a7658 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            int16_t dst = src0 >> src1;

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d7660 1
a7660 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            int32_t dst = src0 >> src1;

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d7662 2
a7663 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];
d7665 3
a7667 11
            int64_t dst = src0 >> src1;

            _dst_val.i64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d7672 2
a7673 2
evaluate_isign(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7677 3
a7679 4
      switch (bit_size) {
      case 8: {
         
   
d7681 6
a7686 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
d7688 1
a7688 1
            int8_t dst = (src0 == 0) ? 0 : ((src0 > 0) ? 1 : -1);
d7690 2
a7691 2
            _dst_val.i8[_i] = dst;
      }
d7693 4
a7696 5
         break;
      }
      case 16: {
         
   
d7698 6
a7703 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
d7705 1
a7705 1
            int16_t dst = (src0 == 0) ? 0 : ((src0 > 0) ? 1 : -1);
d7707 2
a7708 2
            _dst_val.i16[_i] = dst;
      }
d7710 2
a7711 5
         break;
      }
      case 32: {
         
   
d7713 3
a7715 32
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];

            int32_t dst = (src0 == 0) ? 0 : ((src0 > 0) ? 1 : -1);

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];

            int64_t dst = (src0 == 0) ? 0 : ((src0 > 0) ? 1 : -1);

            _dst_val.i64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d7720 2
a7721 2
evaluate_isub(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7725 10
a7734 4
      switch (bit_size) {
      case 8: {
         
   
d7736 1
a7736 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int8_t src0 =
                  _src[0].i8[_i];
               const int8_t src1 =
                  _src[1].i8[_i];

            int8_t dst = src0 - src1;

            _dst_val.i8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d7738 2
a7739 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int16_t src0 =
                  _src[0].i16[_i];
               const int16_t src1 =
                  _src[1].i16[_i];

            int16_t dst = src0 - src1;

            _dst_val.i16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d7741 4
a7744 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            int32_t dst = src0 - src1;

            _dst_val.i32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d7746 6
a7751 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int64_t src0 =
                  _src[0].i64[_i];
               const int64_t src1 =
                  _src[1].i64[_i];
d7753 1
a7753 1
            int64_t dst = src0 - src1;
d7755 2
a7756 2
            _dst_val.i64[_i] = dst;
      }
d7758 2
a7759 2
         break;
      }
d7761 3
a7763 3
      default:
         unreachable("unknown bit width");
      }
d7768 2
a7769 2
evaluate_ixor(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7773 10
a7782 4
      switch (bit_size) {
      case 8: {
         
   
d7784 1
a7784 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            uint8_t dst = src0 ^ src1;

            _dst_val.u8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d7786 2
a7787 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            uint16_t dst = src0 ^ src1;

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d7789 4
a7792 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint32_t dst = src0 ^ src1;

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d7794 6
a7799 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
d7801 1
a7801 1
            uint64_t dst = src0 ^ src1;
d7803 2
a7804 2
            _dst_val.u64[_i] = dst;
      }
d7806 2
a7807 2
         break;
      }
d7809 3
a7811 3
      default:
         unreachable("unknown bit width");
      }
d7816 2
a7817 2
evaluate_ldexp(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7821 3
a7823 11
      switch (bit_size) {
      case 16: {
         
   

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float src0 =
                  _mesa_half_to_float(_src[0].u16[_i]);
               const int32_t src1 =
                  _src[1].i32[_i];
d7825 6
a7830 1
            float16_t dst;
d7832 1
a7832 5
            
dst = (bit_size == 64) ? ldexp(src0, src1) : ldexpf(src0, src1);
/* flush denormals to zero. */
if (!isnormal(dst))
   dst = copysignf(0.0f, src0);
d7834 2
d7837 4
a7840 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d7842 6
a7847 5
         break;
      }
      case 32: {
         
   
d7849 1
a7849 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];
d7851 2
a7852 1
            float32_t dst;
d7854 2
a7855 5
            
dst = (bit_size == 64) ? ldexp(src0, src1) : ldexpf(src0, src1);
/* flush denormals to zero. */
if (!isnormal(dst))
   dst = copysignf(0.0f, src0);
d7857 3
a7859 35

            _dst_val.f32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float64_t src0 =
                  _src[0].f64[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            float64_t dst;

            
dst = (bit_size == 64) ? ldexp(src0, src1) : ldexpf(src0, src1);
/* flush denormals to zero. */
if (!isnormal(dst))
   dst = copysignf(0.0f, src0);


            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d7864 2
a7865 2
evaluate_pack_64_2x32(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7869 2
a7871 1
   
d7873 14
d7888 4
a7891 6
      const struct uint32_vec src0 = {
            _src[0].u32[0],
            _src[0].u32[1],
         0,
         0,
      };
d7893 1
a7893 1
      struct uint64_vec dst;
d7895 2
a7896 1
         dst.x = src0.x | ((uint64_t)src0.y << 32);
d7898 2
a7899 1
            _dst_val.u64[0] = dst.x;
d7901 3
d7908 2
a7909 2
evaluate_pack_64_2x32_split(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7913 2
a7915 1
   
d7917 4
a7920 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];
d7922 1
a7922 1
            uint64_t dst = src0 | ((uint64_t)src1 << 32);
d7924 2
a7925 11
            _dst_val.u64[_i] = dst;
      }


   return _dst_val;
}
static nir_const_value
evaluate_pack_half_2x16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d7927 3
a7930 1
   
d7932 4
d7937 1
a7937 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
         0,
         0,
      };
d7939 2
a7940 1
      struct uint32_vec dst;
d7942 2
a7943 6
         
dst.x = (uint32_t) pack_half_1x16(src0.x);
dst.x |= ((uint32_t) pack_half_1x16(src0.y)) << 16;


            _dst_val.u32[0] = dst.x;
d7945 3
d7952 2
a7953 2
evaluate_pack_half_2x16_split(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d7957 2
a7959 1
   
d7961 11
d7973 4
a7976 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
         0,
         0,
         0,
      };
d7978 6
a7983 6
      const struct float32_vec src1 = {
            _src[1].f32[0],
         0,
         0,
         0,
      };
d7985 1
a7985 1
      struct uint32_vec dst;
d7987 2
a7988 1
         dst.x = dst.y = dst.z = dst.w = pack_half_1x16(src0.x) | (pack_half_1x16(src1.x) << 16);
d7990 2
a7991 1
            _dst_val.u32[0] = dst.x;
d7993 3
d8000 2
a8001 2
evaluate_pack_snorm_2x16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8005 2
a8007 1
   
d8009 8
d8018 31
a8048 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
         0,
         0,
      };
d8050 13
a8062 1
      struct uint32_vec dst;
a8063 3
         
dst.x = (uint32_t) pack_snorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x16(src0.y)) << 16;
d8065 2
d8068 2
a8069 1
            _dst_val.u32[0] = dst.x;
d8071 3
d8078 2
a8079 2
evaluate_pack_snorm_4x8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8083 2
a8085 1
   
d8087 29
d8117 8
a8124 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
            _src[0].f32[3],
      };
d8126 11
a8136 1
      struct uint32_vec dst;
a8137 5
         
dst.x = (uint32_t) pack_snorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_snorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_snorm_1x8(src0.w)) << 24;
d8139 2
d8142 2
a8143 1
            _dst_val.u32[0] = dst.x;
d8145 3
d8152 2
a8153 2
evaluate_pack_unorm_2x16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8157 2
a8159 1
   
d8161 6
d8168 1
a8168 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
         0,
         0,
      };
d8170 2
a8171 1
      struct uint32_vec dst;
d8173 13
a8185 3
         
dst.x = (uint32_t) pack_unorm_1x16(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x16(src0.y)) << 16;
d8187 2
d8190 2
a8191 1
            _dst_val.u32[0] = dst.x;
d8193 3
d8200 2
a8201 2
evaluate_pack_unorm_4x8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8205 2
a8207 1
   
d8209 4
d8214 9
a8222 6
      const struct float32_vec src0 = {
            _src[0].f32[0],
            _src[0].f32[1],
            _src[0].f32[2],
            _src[0].f32[3],
      };
a8223 1
      struct uint32_vec dst;
d8225 2
a8226 5
         
dst.x = (uint32_t) pack_unorm_1x8(src0.x);
dst.x |= ((uint32_t) pack_unorm_1x8(src0.y)) << 8;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.z)) << 16;
dst.x |= ((uint32_t) pack_unorm_1x8(src0.w)) << 24;
d8228 4
d8233 4
a8236 1
            _dst_val.u32[0] = dst.x;
d8238 8
a8245 2

   return _dst_val;
a8246 8
static nir_const_value
evaluate_pack_uvec2_to_uint(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

      
   
d8249 2
a8250 6
      const struct uint32_vec src0 = {
            _src[0].u32[0],
            _src[0].u32[1],
         0,
         0,
      };
d8252 2
a8253 7
      struct uint32_vec dst;

         
dst.x = (src0.x & 0xffff) | (src0.y << 16);


            _dst_val.u32[0] = dst.x;
d8255 3
d8262 2
a8263 2
evaluate_pack_uvec4_to_uint(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8267 2
a8269 1
   
d8271 6
d8278 1
a8278 6
      const struct uint32_vec src0 = {
            _src[0].u32[0],
            _src[0].u32[1],
            _src[0].u32[2],
            _src[0].u32[3],
      };
d8280 2
a8281 1
      struct uint32_vec dst;
d8283 13
a8295 5
         
dst.x = (src0.x <<  0) |
        (src0.y <<  8) |
        (src0.z << 16) |
        (src0.w << 24);
d8297 2
d8300 2
a8301 1
            _dst_val.u32[0] = dst.x;
d8303 3
d8310 2
a8311 2
evaluate_seq(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8315 2
a8317 1
   
d8319 6
a8324 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];
d8326 1
a8326 1
            float32_t dst = (src0 == src1) ? 1.0f : 0.0f;
d8328 2
a8329 2
            _dst_val.f32[_i] = dst;
      }
d8331 4
d8336 6
a8341 7
   return _dst_val;
}
static nir_const_value
evaluate_sge(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d8343 1
a8343 2
      
   
d8345 2
a8346 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];
d8348 2
a8349 4
            float32_t dst = (src0 >= src1) ? 1.0f : 0.0f;

            _dst_val.f32[_i] = dst;
      }
d8351 3
d8358 2
a8359 2
evaluate_slt(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8363 2
a8365 1
   
d8367 6
a8372 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];
d8374 1
a8374 1
            float32_t dst = (src0 < src1) ? 1.0f : 0.0f;
d8376 2
a8377 2
            _dst_val.f32[_i] = dst;
      }
d8379 4
d8384 6
a8389 7
   return _dst_val;
}
static nir_const_value
evaluate_sne(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d8391 1
a8391 2
      
   
d8393 2
a8394 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const float32_t src0 =
                  _src[0].f32[_i];
               const float32_t src1 =
                  _src[1].f32[_i];
d8396 2
a8397 4
            float32_t dst = (src0 != src1) ? 1.0f : 0.0f;

            _dst_val.f32[_i] = dst;
      }
d8399 3
d8406 2
a8407 2
evaluate_u2f16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8411 3
a8413 4
      switch (bit_size) {
      case 8: {
         
   
d8415 6
a8420 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
d8422 6
a8427 1
            float16_t dst = src0;
a8428 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
d8430 2
a8431 5
         break;
      }
      case 16: {
         
   
d8433 4
a8436 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
d8438 6
a8443 1
            float16_t dst = src0;
d8445 6
a8450 2
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }
a8451 5
         break;
      }
      case 32: {
         
   
d8453 2
a8454 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
d8456 2
a8457 1
            float16_t dst = src0;
d8459 3
a8461 25
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];

            float16_t dst = src0;

            _dst_val.u16[_i] = _mesa_float_to_half(dst);
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d8466 2
a8467 2
evaluate_u2f32(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8471 3
a8473 4
      switch (bit_size) {
      case 8: {
         
   
d8475 6
a8480 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
d8482 1
a8482 1
            float32_t dst = src0;
d8484 2
a8485 2
            _dst_val.f32[_i] = dst;
      }
d8487 4
a8490 5
         break;
      }
      case 16: {
         
   
d8492 6
a8497 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
d8499 1
a8499 1
            float32_t dst = src0;
d8501 2
a8502 2
            _dst_val.f32[_i] = dst;
      }
d8504 2
a8505 5
         break;
      }
      case 32: {
         
   
d8507 3
a8509 32
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];

            float32_t dst = src0;

            _dst_val.f32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];

            float32_t dst = src0;

            _dst_val.f32[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d8514 2
a8515 2
evaluate_u2f64(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8519 3
a8521 4
      switch (bit_size) {
      case 8: {
         
   
d8523 6
a8528 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
d8530 6
a8535 1
            float64_t dst = src0;
a8536 2
            _dst_val.f64[_i] = dst;
      }
d8538 2
a8539 5
         break;
      }
      case 16: {
         
   
d8541 4
a8544 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
d8546 6
a8551 1
            float64_t dst = src0;
d8553 6
a8558 2
            _dst_val.f64[_i] = dst;
      }
a8559 5
         break;
      }
      case 32: {
         
   
d8561 2
a8562 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
d8564 2
a8565 1
            float64_t dst = src0;
d8567 3
a8569 25
            _dst_val.f64[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];

            float64_t dst = src0;

            _dst_val.f64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d8574 2
a8575 2
evaluate_u2u16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8579 3
a8581 4
      switch (bit_size) {
      case 8: {
         
   
d8583 6
a8588 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
d8590 1
a8590 1
            uint16_t dst = src0;
d8592 2
a8593 2
            _dst_val.u16[_i] = dst;
      }
d8595 4
a8598 5
         break;
      }
      case 16: {
         
   
d8600 6
a8605 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
d8607 1
a8607 1
            uint16_t dst = src0;
d8609 2
a8610 2
            _dst_val.u16[_i] = dst;
      }
d8612 2
a8613 5
         break;
      }
      case 32: {
         
   
d8615 3
a8617 32
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];

            uint16_t dst = src0;

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];

            uint16_t dst = src0;

            _dst_val.u16[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d8622 2
a8623 2
evaluate_u2u32(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8627 3
a8629 4
      switch (bit_size) {
      case 8: {
         
   
d8631 6
a8636 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
d8638 1
a8638 1
            uint32_t dst = src0;
d8640 2
a8641 2
            _dst_val.u32[_i] = dst;
      }
d8643 4
a8646 5
         break;
      }
      case 16: {
         
   
d8648 6
a8653 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
d8655 1
a8655 1
            uint32_t dst = src0;
d8657 2
a8658 2
            _dst_val.u32[_i] = dst;
      }
d8660 2
a8661 5
         break;
      }
      case 32: {
         
   
d8663 3
a8665 32
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];

            uint32_t dst = src0;

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];

            uint32_t dst = src0;

            _dst_val.u32[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d8670 2
a8671 2
evaluate_u2u64(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8675 3
a8677 4
      switch (bit_size) {
      case 8: {
         
   
d8679 6
a8684 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
d8686 8
a8693 1
            uint64_t dst = src0;
a8694 2
            _dst_val.u64[_i] = dst;
      }
d8696 2
a8697 5
         break;
      }
      case 16: {
         
   
d8699 4
a8702 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
d8704 6
a8709 1
            uint64_t dst = src0;
d8711 8
a8718 2
            _dst_val.u64[_i] = dst;
      }
a8719 5
         break;
      }
      case 32: {
         
   
d8721 2
a8722 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
d8724 2
a8725 1
            uint64_t dst = src0;
d8727 3
a8729 25
            _dst_val.u64[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];

            uint64_t dst = src0;

            _dst_val.u64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d8734 2
a8735 2
evaluate_u2u8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8739 3
a8741 4
      switch (bit_size) {
      case 8: {
         
   
a8742 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
d8744 3
a8746 1
            uint8_t dst = src0;
d8748 1
a8748 2
            _dst_val.u8[_i] = dst;
      }
d8750 1
a8750 5
         break;
      }
      case 16: {
         
   
d8752 2
a8753 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
d8755 4
a8758 1
            uint8_t dst = src0;
a8759 2
            _dst_val.u8[_i] = dst;
      }
d8761 3
a8763 5
         break;
      }
      case 32: {
         
   
d8765 1
a8765 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
d8767 1
a8767 1
            uint8_t dst = src0;
d8769 2
a8770 2
            _dst_val.u8[_i] = dst;
      }
d8772 2
a8773 5
         break;
      }
      case 64: {
         
   
d8775 3
a8777 16
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];

            uint8_t dst = src0;

            _dst_val.u8[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d8782 2
a8783 2
evaluate_uadd_carry(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8787 8
a8794 4
      switch (bit_size) {
      case 8: {
         
   
d8796 1
a8796 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            uint8_t dst = src0 + src1 < src0;

            _dst_val.u8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d8798 2
a8799 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            uint16_t dst = src0 + src1 < src0;

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d8801 4
a8804 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint32_t dst = src0 + src1 < src0;

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d8806 4
a8809 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
d8811 1
a8811 1
            uint64_t dst = src0 + src1 < src0;
d8813 2
a8814 2
            _dst_val.u64[_i] = dst;
      }
d8816 2
a8817 2
         break;
      }
d8819 3
a8821 3
      default:
         unreachable("unknown bit width");
      }
d8826 2
a8827 2
evaluate_ubfe(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8831 2
a8833 1
   
d8835 9
a8843 8
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];
               const int32_t src2 =
                  _src[2].i32[_i];
d8845 4
a8848 1
            uint32_t dst;
d8851 5
a8855 11
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0) {
   dst = 0; /* undefined */
} else if (offset + bits < 32) {
   dst = (base << (32 - bits - offset)) >> (32 - bits);
} else {
   dst = base >> offset;
}
d8857 2
d8860 2
a8861 2
            _dst_val.u32[_i] = dst;
      }
d8863 3
d8870 2
a8871 2
evaluate_ubitfield_extract(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8875 2
a8877 1
   
a8878 8
                           
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];
               const int32_t src2 =
                  _src[2].i32[_i];
d8880 5
a8884 1
            uint32_t dst;
d8887 2
a8888 9
unsigned base = src0;
int offset = src1, bits = src2;
if (bits == 0) {
   dst = 0;
} else if (bits < 0 || offset < 0 || offset + bits > 32) {
   dst = 0; /* undefined per the spec */
} else {
   dst = (base >> offset) & ((1ull << bits) - 1);
}
d8891 2
a8892 2
            _dst_val.u32[_i] = dst;
      }
d8894 4
a8898 12
   return _dst_val;
}
static nir_const_value
evaluate_udiv(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

      switch (bit_size) {
      case 8: {
         
   
d8900 3
a8902 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            uint8_t dst = src0 / src1;

            _dst_val.u8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d8904 1
a8904 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            uint16_t dst = src0 / src1;

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d8906 3
a8908 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint32_t dst = src0 / src1;

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
a8909 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
d8911 2
a8912 1
            uint64_t dst = src0 / src1;
d8914 2
a8915 2
            _dst_val.u64[_i] = dst;
      }
d8917 3
a8919 6
         break;
      }

      default:
         unreachable("unknown bit width");
      }
d8924 2
a8925 2
evaluate_ufind_msb(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8929 2
a8931 1
   
a8932 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
d8934 9
a8942 1
            int32_t dst;
a8943 5
            
dst = -1;
for (int bit = 31; bit > 0; bit--) {
   if ((src0 >> bit) & 1) {
      dst = bit;
d8946 11
a8956 1
}
d8958 1
d8960 2
a8961 2
            _dst_val.i32[_i] = dst;
      }
d8963 3
d8970 2
a8971 2
evaluate_uge(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d8975 12
a8986 4
      switch (bit_size) {
      case 8: {
         
   
d8988 6
a8993 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            bool32_t dst = src0 >= src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 16: {
         
   
a8994 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            bool32_t dst = src0 >= src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 32: {
         
   
d8996 3
a8998 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            bool32_t dst = src0 >= src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 64: {
         
   
d9000 1
a9000 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
d9002 1
a9002 1
            bool32_t dst = src0 >= src1;
d9004 1
a9004 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d9006 2
a9007 2
         break;
      }
d9009 3
a9011 3
      default:
         unreachable("unknown bit width");
      }
d9016 2
a9017 2
evaluate_ult(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d9021 3
a9023 4
      switch (bit_size) {
      case 8: {
         
   
a9024 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            bool32_t dst = src0 < src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 16: {
         
   
d9026 3
a9028 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            bool32_t dst = src0 < src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 32: {
         
   
d9030 1
a9030 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            bool32_t dst = src0 < src1;

            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }

         break;
      }
      case 64: {
         
   
d9032 3
a9034 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
a9035 1
            bool32_t dst = src0 < src1;
d9037 2
a9038 2
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
      }
d9040 4
a9043 2
         break;
      }
a9044 3
      default:
         unreachable("unknown bit width");
      }
d9046 3
a9048 7
   return _dst_val;
}
static nir_const_value
evaluate_umax(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d9050 1
a9050 4
      switch (bit_size) {
      case 8: {
         
   
d9052 3
a9054 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            uint8_t dst = src1 > src0 ? src1 : src0;

            _dst_val.u8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
a9055 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            uint16_t dst = src1 > src0 ? src1 : src0;

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d9057 2
a9058 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint32_t dst = src1 > src0 ? src1 : src0;

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d9060 2
a9061 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
d9063 3
a9065 11
            uint64_t dst = src1 > src0 ? src1 : src0;

            _dst_val.u64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d9070 2
a9071 2
evaluate_umax_4x8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d9075 2
a9077 1
   
a9078 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];
d9080 5
a9084 1
            int32_t dst;
d9087 4
a9090 4
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MAX2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
}
d9093 4
a9096 2
            _dst_val.i32[_i] = dst;
      }
d9098 4
a9102 7
   return _dst_val;
}
static nir_const_value
evaluate_umin(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d9104 3
a9106 4
      switch (bit_size) {
      case 8: {
         
   
d9108 1
a9108 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            uint8_t dst = src1 > src0 ? src0 : src1;

            _dst_val.u8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d9110 5
a9114 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            uint16_t dst = src1 > src0 ? src0 : src1;

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
a9115 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint32_t dst = src1 > src0 ? src0 : src1;

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d9117 4
a9120 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
d9122 2
a9123 1
            uint64_t dst = src1 > src0 ? src0 : src1;
d9125 3
a9127 9
            _dst_val.u64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d9132 2
a9133 2
evaluate_umin_4x8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d9137 2
a9139 1
   
a9140 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];
d9142 5
a9146 1
            int32_t dst;
d9149 2
a9150 4
dst = 0;
for (int i = 0; i < 32; i += 8) {
   dst |= MIN2((src0 >> i) & 0xff, (src1 >> i) & 0xff) << i;
}
d9153 2
a9154 2
            _dst_val.i32[_i] = dst;
      }
d9156 4
a9160 12
   return _dst_val;
}
static nir_const_value
evaluate_umod(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

      switch (bit_size) {
      case 8: {
         
   
d9162 3
a9164 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            uint8_t dst = src1 == 0 ? 0 : src0 % src1;

            _dst_val.u8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d9166 1
a9166 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            uint16_t dst = src1 == 0 ? 0 : src0 % src1;

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d9168 3
a9170 24
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint32_t dst = src1 == 0 ? 0 : src0 % src1;

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
a9171 1
            uint64_t dst = src1 == 0 ? 0 : src0 % src1;
d9173 2
a9174 2
            _dst_val.u64[_i] = dst;
      }
d9176 2
a9177 2
         break;
      }
d9179 3
a9181 3
      default:
         unreachable("unknown bit width");
      }
d9186 2
a9187 2
evaluate_umul_high(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d9191 2
a9193 1
   
a9194 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];
d9196 5
a9200 1
            uint32_t dst = (uint32_t)(((uint64_t) src0 * (uint64_t) src1) >> 32);
d9202 5
a9206 2
            _dst_val.u32[_i] = dst;
      }
d9209 4
a9212 7
   return _dst_val;
}
static nir_const_value
evaluate_umul_unorm_4x8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d9214 3
a9217 1
   
a9218 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];
d9220 5
a9224 1
            int32_t dst;
d9227 5
a9231 6
dst = 0;
for (int i = 0; i < 32; i += 8) {
   int src0_chan = (src0 >> i) & 0xff;
   int src1_chan = (src1 >> i) & 0xff;
   dst |= ((src0_chan * src1_chan) / 255) << i;
}
d9233 4
d9238 2
a9239 2
            _dst_val.i32[_i] = dst;
      }
d9241 3
d9248 2
a9249 2
evaluate_unpack_64_2x32(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d9253 2
a9255 1
   
d9257 6
d9264 5
a9268 16
      const struct uint64_vec src0 = {
            _src[0].u64[0],
         0,
         0,
         0,
      };

      struct uint32_vec dst;

         dst.x = src0.x; dst.y = src0.x >> 32;

            _dst_val.u32[0] = dst.x;
            _dst_val.u32[1] = dst.y;


   return _dst_val;
a9269 8
static nir_const_value
evaluate_unpack_64_2x32_split_x(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

      
   
a9270 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
d9272 2
a9273 13
            uint32_t dst = src0;

            _dst_val.u32[_i] = dst;
      }


   return _dst_val;
}
static nir_const_value
evaluate_unpack_64_2x32_split_y(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d9275 3
a9278 1
   
d9280 6
a9285 4
         
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
d9287 5
a9291 7
            uint32_t dst = src0 >> 32;

            _dst_val.u32[_i] = dst;
      }


   return _dst_val;
a9292 5
static nir_const_value
evaluate_unpack_half_2x16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
a9293 2
      
   
d9295 2
d9298 2
a9299 16
      const struct uint32_vec src0 = {
            _src[0].u32[0],
         0,
         0,
         0,
      };

      struct float32_vec dst;

         
dst.x = unpack_half_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_half_1x16((uint16_t)(src0.x << 16));


            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
d9301 3
d9308 2
a9309 2
evaluate_unpack_half_2x16_split_x(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d9313 2
a9315 1
   
d9317 6
d9324 1
a9324 6
      const struct uint32_vec src0 = {
            _src[0].u32[0],
         0,
         0,
         0,
      };
d9326 2
a9327 14
      struct float32_vec dst;

         dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x & 0xffff));

            _dst_val.f32[0] = dst.x;


   return _dst_val;
}
static nir_const_value
evaluate_unpack_half_2x16_split_y(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d9329 3
a9332 1
   
d9334 6
d9341 1
a9341 6
      const struct uint32_vec src0 = {
            _src[0].u32[0],
         0,
         0,
         0,
      };
d9343 2
a9344 1
      struct float32_vec dst;
d9346 2
a9347 3
         dst.x = dst.y = dst.z = dst.w = unpack_half_1x16((uint16_t)(src0.x >> 16));

            _dst_val.f32[0] = dst.x;
d9349 3
d9356 2
a9357 2
evaluate_unpack_snorm_2x16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d9361 2
a9363 1
   
d9365 6
d9372 2
a9373 137
      const struct uint32_vec src0 = {
            _src[0].u32[0],
         0,
         0,
         0,
      };

      struct float32_vec dst;

         
dst.x = unpack_snorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_snorm_1x16((uint16_t)(src0.x << 16));


            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;


   return _dst_val;
}
static nir_const_value
evaluate_unpack_snorm_4x8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

      
   


      const struct uint32_vec src0 = {
            _src[0].u32[0],
         0,
         0,
         0,
      };

      struct float32_vec dst;

         
dst.x = unpack_snorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_snorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_snorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_snorm_1x8((uint8_t)(src0.x >> 24));


            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
            _dst_val.f32[3] = dst.w;


   return _dst_val;
}
static nir_const_value
evaluate_unpack_unorm_2x16(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

      
   


      const struct uint32_vec src0 = {
            _src[0].u32[0],
         0,
         0,
         0,
      };

      struct float32_vec dst;

         
dst.x = unpack_unorm_1x16((uint16_t)(src0.x & 0xffff));
dst.y = unpack_unorm_1x16((uint16_t)(src0.x << 16));


            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;


   return _dst_val;
}
static nir_const_value
evaluate_unpack_unorm_4x8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

      
   


      const struct uint32_vec src0 = {
            _src[0].u32[0],
         0,
         0,
         0,
      };

      struct float32_vec dst;

         
dst.x = unpack_unorm_1x8((uint8_t)(src0.x & 0xff));
dst.y = unpack_unorm_1x8((uint8_t)((src0.x >> 8) & 0xff));
dst.z = unpack_unorm_1x8((uint8_t)((src0.x >> 16) & 0xff));
dst.w = unpack_unorm_1x8((uint8_t)(src0.x >> 24));


            _dst_val.f32[0] = dst.x;
            _dst_val.f32[1] = dst.y;
            _dst_val.f32[2] = dst.z;
            _dst_val.f32[3] = dst.w;


   return _dst_val;
}
static nir_const_value
evaluate_usadd_4x8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

      
   

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];

            int32_t dst;

            
d9376 4
a9379 1
   dst |= MIN2(((src0 >> i) & 0xff) + ((src1 >> i) & 0xff), 0xff) << i;
d9383 2
a9384 97
            _dst_val.i32[_i] = dst;
      }


   return _dst_val;
}
static nir_const_value
evaluate_ushr(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

      switch (bit_size) {
      case 8: {
         
   

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint8_t dst = src0 >> src1;

            _dst_val.u8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint16_t dst = src0 >> src1;

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint32_t dst = src0 >> src1;

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   

                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint64_t dst = src0 >> src1;

            _dst_val.u64[_i] = dst;
      }

         break;
      }

      default:
         unreachable("unknown bit width");
      }

   return _dst_val;
}
static nir_const_value
evaluate_ussub_4x8(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };
d9386 3
a9389 1
   
d9391 6
a9396 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const int32_t src0 =
                  _src[0].i32[_i];
               const int32_t src1 =
                  _src[1].i32[_i];
d9398 2
a9399 3
            int32_t dst;

            
d9409 2
a9410 2
            _dst_val.i32[_i] = dst;
      }
d9412 6
d9422 2
a9423 2
evaluate_usub_borrow(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d9427 10
a9436 4
      switch (bit_size) {
      case 8: {
         
   
d9438 1
a9438 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint8_t src0 =
                  _src[0].u8[_i];
               const uint8_t src1 =
                  _src[1].u8[_i];

            uint8_t dst = src0 < src1;

            _dst_val.u8[_i] = dst;
      }

         break;
      }
      case 16: {
         
   
d9440 2
a9441 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint16_t src0 =
                  _src[0].u16[_i];
               const uint16_t src1 =
                  _src[1].u16[_i];

            uint16_t dst = src0 < src1;

            _dst_val.u16[_i] = dst;
      }

         break;
      }
      case 32: {
         
   
d9443 4
a9446 17
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint32_t src0 =
                  _src[0].u32[_i];
               const uint32_t src1 =
                  _src[1].u32[_i];

            uint32_t dst = src0 < src1;

            _dst_val.u32[_i] = dst;
      }

         break;
      }
      case 64: {
         
   
d9448 6
a9453 6
                  
      for (unsigned _i = 0; _i < num_components; _i++) {
               const uint64_t src0 =
                  _src[0].u64[_i];
               const uint64_t src1 =
                  _src[1].u64[_i];
d9455 1
a9455 1
            uint64_t dst = src0 < src1;
d9457 2
a9458 2
            _dst_val.u64[_i] = dst;
      }
d9460 2
a9461 2
         break;
      }
d9463 3
a9465 3
      default:
         unreachable("unknown bit width");
      }
d9470 2
a9471 2
evaluate_vec2(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d9475 3
a9477 4
      switch (bit_size) {
      case 8: {
         
   
d9480 3
a9482 6
      const struct uint8_vec src0 = {
            _src[0].u8[0],
         0,
         0,
         0,
      };
d9484 3
a9486 6
      const struct uint8_vec src1 = {
            _src[1].u8[0],
         0,
         0,
         0,
      };
d9488 1
a9488 1
      struct uint8_vec dst;
d9490 1
a9490 1
         
d9495 2
a9496 2
            _dst_val.u8[0] = dst.x;
            _dst_val.u8[1] = dst.y;
d9498 4
a9501 20
         break;
      }
      case 16: {
         
   


      const struct uint16_vec src0 = {
            _src[0].u16[0],
         0,
         0,
         0,
      };

      const struct uint16_vec src1 = {
            _src[1].u16[0],
         0,
         0,
         0,
      };
a9502 1
      struct uint16_vec dst;
d9504 3
a9506 3
         
dst.x = src0.x;
dst.y = src1.x;
d9508 3
d9512 1
a9512 2
            _dst_val.u16[0] = dst.x;
            _dst_val.u16[1] = dst.y;
d9514 1
a9514 24
         break;
      }
      case 32: {
         
   


      const struct uint32_vec src0 = {
            _src[0].u32[0],
         0,
         0,
         0,
      };

      const struct uint32_vec src1 = {
            _src[1].u32[0],
         0,
         0,
         0,
      };

      struct uint32_vec dst;

         
d9519 2
a9520 2
            _dst_val.u32[0] = dst.x;
            _dst_val.u32[1] = dst.y;
d9522 2
a9523 20
         break;
      }
      case 64: {
         
   


      const struct uint64_vec src0 = {
            _src[0].u64[0],
         0,
         0,
         0,
      };

      const struct uint64_vec src1 = {
            _src[1].u64[0],
         0,
         0,
         0,
      };
d9525 3
a9527 16
      struct uint64_vec dst;

         
dst.x = src0.x;
dst.y = src1.x;


            _dst_val.u64[0] = dst.x;
            _dst_val.u64[1] = dst.y;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d9532 2
a9533 2
evaluate_vec3(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d9537 3
a9539 4
      switch (bit_size) {
      case 8: {
         
   
d9542 3
a9544 6
      const struct uint8_vec src0 = {
            _src[0].u8[0],
         0,
         0,
         0,
      };
d9546 3
a9548 6
      const struct uint8_vec src1 = {
            _src[1].u8[0],
         0,
         0,
         0,
      };
d9550 3
a9552 6
      const struct uint8_vec src2 = {
            _src[2].u8[0],
         0,
         0,
         0,
      };
d9554 1
a9554 1
      struct uint8_vec dst;
d9556 1
a9556 1
         
d9562 3
a9564 38
            _dst_val.u8[0] = dst.x;
            _dst_val.u8[1] = dst.y;
            _dst_val.u8[2] = dst.z;

         break;
      }
      case 16: {
         
   


      const struct uint16_vec src0 = {
            _src[0].u16[0],
         0,
         0,
         0,
      };

      const struct uint16_vec src1 = {
            _src[1].u16[0],
         0,
         0,
         0,
      };

      const struct uint16_vec src2 = {
            _src[2].u16[0],
         0,
         0,
         0,
      };

      struct uint16_vec dst;

         
dst.x = src0.x;
dst.y = src1.x;
dst.z = src2.x;
d9566 4
a9570 31
            _dst_val.u16[0] = dst.x;
            _dst_val.u16[1] = dst.y;
            _dst_val.u16[2] = dst.z;

         break;
      }
      case 32: {
         
   


      const struct uint32_vec src0 = {
            _src[0].u32[0],
         0,
         0,
         0,
      };

      const struct uint32_vec src1 = {
            _src[1].u32[0],
         0,
         0,
         0,
      };

      const struct uint32_vec src2 = {
            _src[2].u32[0],
         0,
         0,
         0,
      };
d9572 3
a9574 6
      struct uint32_vec dst;

         
dst.x = src0.x;
dst.y = src1.x;
dst.z = src2.x;
d9576 3
d9580 3
a9582 31
            _dst_val.u32[0] = dst.x;
            _dst_val.u32[1] = dst.y;
            _dst_val.u32[2] = dst.z;

         break;
      }
      case 64: {
         
   


      const struct uint64_vec src0 = {
            _src[0].u64[0],
         0,
         0,
         0,
      };

      const struct uint64_vec src1 = {
            _src[1].u64[0],
         0,
         0,
         0,
      };

      const struct uint64_vec src2 = {
            _src[2].u64[0],
         0,
         0,
         0,
      };
d9584 1
a9584 1
      struct uint64_vec dst;
d9586 1
a9586 1
         
d9592 3
a9594 3
            _dst_val.u64[0] = dst.x;
            _dst_val.u64[1] = dst.y;
            _dst_val.u64[2] = dst.z;
d9596 2
a9597 2
         break;
      }
d9599 3
a9601 3
      default:
         unreachable("unknown bit width");
      }
d9606 2
a9607 2
evaluate_vec4(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
d9611 3
a9613 4
      switch (bit_size) {
      case 8: {
         
   
d9616 3
a9618 6
      const struct uint8_vec src0 = {
            _src[0].u8[0],
         0,
         0,
         0,
      };
d9620 3
a9622 6
      const struct uint8_vec src1 = {
            _src[1].u8[0],
         0,
         0,
         0,
      };
d9624 3
a9626 6
      const struct uint8_vec src2 = {
            _src[2].u8[0],
         0,
         0,
         0,
      };
d9628 3
a9630 6
      const struct uint8_vec src3 = {
            _src[3].u8[0],
         0,
         0,
         0,
      };
d9632 1
a9632 1
      struct uint8_vec dst;
d9634 1
a9634 1
         
d9641 10
a9650 39
            _dst_val.u8[0] = dst.x;
            _dst_val.u8[1] = dst.y;
            _dst_val.u8[2] = dst.z;
            _dst_val.u8[3] = dst.w;

         break;
      }
      case 16: {
         
   


      const struct uint16_vec src0 = {
            _src[0].u16[0],
         0,
         0,
         0,
      };

      const struct uint16_vec src1 = {
            _src[1].u16[0],
         0,
         0,
         0,
      };

      const struct uint16_vec src2 = {
            _src[2].u16[0],
         0,
         0,
         0,
      };

      const struct uint16_vec src3 = {
            _src[3].u16[0],
         0,
         0,
         0,
      };
d9652 3
a9654 1
      struct uint16_vec dst;
d9656 3
a9658 5
         
dst.x = src0.x;
dst.y = src1.x;
dst.z = src2.x;
dst.w = src3.x;
d9660 3
d9664 3
a9666 39
            _dst_val.u16[0] = dst.x;
            _dst_val.u16[1] = dst.y;
            _dst_val.u16[2] = dst.z;
            _dst_val.u16[3] = dst.w;

         break;
      }
      case 32: {
         
   


      const struct uint32_vec src0 = {
            _src[0].u32[0],
         0,
         0,
         0,
      };

      const struct uint32_vec src1 = {
            _src[1].u32[0],
         0,
         0,
         0,
      };

      const struct uint32_vec src2 = {
            _src[2].u32[0],
         0,
         0,
         0,
      };

      const struct uint32_vec src3 = {
            _src[3].u32[0],
         0,
         0,
         0,
      };
d9668 1
a9668 1
      struct uint32_vec dst;
d9670 1
a9670 1
         
d9677 4
a9680 39
            _dst_val.u32[0] = dst.x;
            _dst_val.u32[1] = dst.y;
            _dst_val.u32[2] = dst.z;
            _dst_val.u32[3] = dst.w;

         break;
      }
      case 64: {
         
   


      const struct uint64_vec src0 = {
            _src[0].u64[0],
         0,
         0,
         0,
      };

      const struct uint64_vec src1 = {
            _src[1].u64[0],
         0,
         0,
         0,
      };

      const struct uint64_vec src2 = {
            _src[2].u64[0],
         0,
         0,
         0,
      };

      const struct uint64_vec src3 = {
            _src[3].u64[0],
         0,
         0,
         0,
      };
d9682 2
a9683 7
      struct uint64_vec dst;

         
dst.x = src0.x;
dst.y = src1.x;
dst.z = src2.x;
dst.w = src3.x;
d9685 3
a9687 12

            _dst_val.u64[0] = dst.x;
            _dst_val.u64[1] = dst.y;
            _dst_val.u64[2] = dst.z;
            _dst_val.u64[3] = dst.w;

         break;
      }

      default:
         unreachable("unknown bit width");
      }
d9697 1
a9697 1
   case nir_op_b2f:
d9699 3
a9701 1
   case nir_op_b2i:
d9703 3
a9705 1
   case nir_op_ball_fequal2:
d9707 3
a9709 1
   case nir_op_ball_fequal3:
d9711 3
a9713 1
   case nir_op_ball_fequal4:
d9715 3
a9717 1
   case nir_op_ball_iequal2:
d9719 3
a9721 1
   case nir_op_ball_iequal3:
d9723 3
a9725 1
   case nir_op_ball_iequal4:
d9727 3
a9729 1
   case nir_op_bany_fnequal2:
d9731 3
a9733 1
   case nir_op_bany_fnequal3:
d9735 3
a9737 1
   case nir_op_bany_fnequal4:
d9739 3
a9741 1
   case nir_op_bany_inequal2:
d9743 3
a9745 1
   case nir_op_bany_inequal3:
d9747 3
a9749 1
   case nir_op_bany_inequal4:
d9751 3
a9753 1
   case nir_op_bcsel:
d9755 3
a9757 1
   case nir_op_bfi:
d9759 3
a9761 1
   case nir_op_bfm:
d9763 3
a9765 1
   case nir_op_bit_count:
d9767 3
a9769 1
   case nir_op_bitfield_insert:
d9771 3
a9773 1
   case nir_op_bitfield_reverse:
d9775 19
a9793 1
   case nir_op_extract_i16:
d9795 3
a9797 1
   case nir_op_extract_i8:
d9799 3
a9801 1
   case nir_op_extract_u16:
d9803 3
a9805 1
   case nir_op_extract_u8:
d9807 3
a9809 1
   case nir_op_f2b:
d9811 15
a9825 23
   case nir_op_f2f16:
      return evaluate_f2f16(num_components, bit_width, src);
   case nir_op_f2f32:
      return evaluate_f2f32(num_components, bit_width, src);
   case nir_op_f2f64:
      return evaluate_f2f64(num_components, bit_width, src);
   case nir_op_f2i16:
      return evaluate_f2i16(num_components, bit_width, src);
   case nir_op_f2i32:
      return evaluate_f2i32(num_components, bit_width, src);
   case nir_op_f2i64:
      return evaluate_f2i64(num_components, bit_width, src);
   case nir_op_f2i8:
      return evaluate_f2i8(num_components, bit_width, src);
   case nir_op_f2u16:
      return evaluate_f2u16(num_components, bit_width, src);
   case nir_op_f2u32:
      return evaluate_f2u32(num_components, bit_width, src);
   case nir_op_f2u64:
      return evaluate_f2u64(num_components, bit_width, src);
   case nir_op_f2u8:
      return evaluate_f2u8(num_components, bit_width, src);
   case nir_op_fabs:
d9827 3
a9829 1
   case nir_op_fadd:
d9831 3
a9833 1
   case nir_op_fall_equal2:
d9835 3
a9837 1
   case nir_op_fall_equal3:
d9839 3
a9841 1
   case nir_op_fall_equal4:
d9843 3
a9845 1
   case nir_op_fand:
d9847 3
a9849 1
   case nir_op_fany_nequal2:
d9851 3
a9853 1
   case nir_op_fany_nequal3:
d9855 3
a9857 1
   case nir_op_fany_nequal4:
d9859 3
a9861 1
   case nir_op_fceil:
d9863 3
a9865 1
   case nir_op_fcos:
d9867 3
a9869 1
   case nir_op_fcsel:
d9871 3
a9873 1
   case nir_op_fddx:
d9875 3
a9877 1
   case nir_op_fddx_coarse:
d9879 3
a9881 1
   case nir_op_fddx_fine:
d9883 3
a9885 1
   case nir_op_fddy:
d9887 3
a9889 1
   case nir_op_fddy_coarse:
d9891 3
a9893 1
   case nir_op_fddy_fine:
d9895 3
a9897 1
   case nir_op_fdiv:
d9899 3
a9901 1
   case nir_op_fdot2:
d9903 3
a9905 1
   case nir_op_fdot3:
d9907 3
a9909 1
   case nir_op_fdot4:
d9911 3
a9913 1
   case nir_op_fdot_replicated2:
d9915 3
a9917 1
   case nir_op_fdot_replicated3:
d9919 3
a9921 1
   case nir_op_fdot_replicated4:
d9923 3
a9925 1
   case nir_op_fdph:
d9927 3
a9929 1
   case nir_op_fdph_replicated:
d9931 3
a9933 1
   case nir_op_feq:
d9935 3
a9937 1
   case nir_op_fexp2:
d9939 3
a9941 1
   case nir_op_ffloor:
d9943 3
a9945 1
   case nir_op_ffma:
d9947 3
a9949 1
   case nir_op_ffract:
d9951 3
a9953 1
   case nir_op_fge:
d9955 3
a9957 1
   case nir_op_find_lsb:
d9959 3
a9961 1
   case nir_op_flog2:
d9963 3
a9965 1
   case nir_op_flrp:
d9967 3
a9969 1
   case nir_op_flt:
d9971 3
a9973 1
   case nir_op_fmax:
d9975 3
a9977 1
   case nir_op_fmin:
d9979 3
a9981 1
   case nir_op_fmod:
d9983 3
a9985 1
   case nir_op_fmov:
d9987 3
a9989 1
   case nir_op_fmul:
d9991 3
a9993 1
   case nir_op_fne:
d9995 3
a9997 1
   case nir_op_fneg:
d9999 3
a10001 1
   case nir_op_fnoise1_1:
d10003 3
a10005 1
   case nir_op_fnoise1_2:
d10007 3
a10009 1
   case nir_op_fnoise1_3:
d10011 3
a10013 1
   case nir_op_fnoise1_4:
d10015 3
a10017 1
   case nir_op_fnoise2_1:
d10019 3
a10021 1
   case nir_op_fnoise2_2:
d10023 3
a10025 1
   case nir_op_fnoise2_3:
d10027 3
a10029 1
   case nir_op_fnoise2_4:
d10031 3
a10033 1
   case nir_op_fnoise3_1:
d10035 3
a10037 1
   case nir_op_fnoise3_2:
d10039 3
a10041 1
   case nir_op_fnoise3_3:
d10043 3
a10045 1
   case nir_op_fnoise3_4:
d10047 3
a10049 1
   case nir_op_fnoise4_1:
d10051 3
a10053 1
   case nir_op_fnoise4_2:
d10055 3
a10057 1
   case nir_op_fnoise4_3:
d10059 3
a10061 1
   case nir_op_fnoise4_4:
d10063 3
a10065 1
   case nir_op_fnot:
d10067 3
a10069 1
   case nir_op_for:
d10071 3
a10073 1
   case nir_op_fpow:
d10075 3
a10077 1
   case nir_op_fquantize2f16:
d10079 3
a10081 1
   case nir_op_frcp:
d10083 3
a10085 1
   case nir_op_frem:
d10087 3
a10089 1
   case nir_op_fround_even:
d10091 3
a10093 1
   case nir_op_frsq:
d10095 3
a10097 1
   case nir_op_fsat:
d10099 3
a10101 1
   case nir_op_fsign:
d10103 3
a10105 1
   case nir_op_fsin:
d10107 3
a10109 1
   case nir_op_fsqrt:
d10111 3
a10113 1
   case nir_op_fsub:
d10115 3
a10117 1
   case nir_op_ftrunc:
d10119 3
a10121 1
   case nir_op_fxor:
d10123 3
a10125 1
   case nir_op_i2b:
d10127 11
a10137 15
   case nir_op_i2f16:
      return evaluate_i2f16(num_components, bit_width, src);
   case nir_op_i2f32:
      return evaluate_i2f32(num_components, bit_width, src);
   case nir_op_i2f64:
      return evaluate_i2f64(num_components, bit_width, src);
   case nir_op_i2i16:
      return evaluate_i2i16(num_components, bit_width, src);
   case nir_op_i2i32:
      return evaluate_i2i32(num_components, bit_width, src);
   case nir_op_i2i64:
      return evaluate_i2i64(num_components, bit_width, src);
   case nir_op_i2i8:
      return evaluate_i2i8(num_components, bit_width, src);
   case nir_op_iabs:
d10139 3
a10141 1
   case nir_op_iadd:
d10143 3
a10145 1
   case nir_op_iand:
d10147 3
a10149 1
   case nir_op_ibfe:
d10151 3
a10153 1
   case nir_op_ibitfield_extract:
d10155 3
a10157 1
   case nir_op_idiv:
d10159 3
a10161 1
   case nir_op_ieq:
d10163 3
a10165 1
   case nir_op_ifind_msb:
d10167 3
a10169 1
   case nir_op_ige:
d10171 3
a10173 1
   case nir_op_ilt:
d10175 3
a10177 1
   case nir_op_imax:
d10179 3
a10181 1
   case nir_op_imin:
d10183 3
a10185 1
   case nir_op_imod:
d10187 3
a10189 1
   case nir_op_imov:
d10191 3
a10193 1
   case nir_op_imul:
d10195 3
a10197 1
   case nir_op_imul_high:
d10199 3
a10201 1
   case nir_op_ine:
d10203 3
a10205 1
   case nir_op_ineg:
d10207 3
a10209 1
   case nir_op_inot:
d10211 3
a10213 1
   case nir_op_ior:
d10215 3
a10217 1
   case nir_op_irem:
d10219 3
a10221 1
   case nir_op_ishl:
d10223 3
a10225 1
   case nir_op_ishr:
d10227 3
a10229 1
   case nir_op_isign:
d10231 3
a10233 1
   case nir_op_isub:
d10235 3
a10237 1
   case nir_op_ixor:
d10239 3
a10241 1
   case nir_op_ldexp:
d10243 11
a10253 5
   case nir_op_pack_64_2x32:
      return evaluate_pack_64_2x32(num_components, bit_width, src);
   case nir_op_pack_64_2x32_split:
      return evaluate_pack_64_2x32_split(num_components, bit_width, src);
   case nir_op_pack_half_2x16:
d10255 3
a10257 1
   case nir_op_pack_half_2x16_split:
d10259 3
a10261 1
   case nir_op_pack_snorm_2x16:
d10263 3
a10265 1
   case nir_op_pack_snorm_4x8:
d10267 3
a10269 1
   case nir_op_pack_unorm_2x16:
d10271 3
a10273 1
   case nir_op_pack_unorm_4x8:
d10275 3
a10277 1
   case nir_op_pack_uvec2_to_uint:
d10279 3
a10281 1
   case nir_op_pack_uvec4_to_uint:
d10283 3
a10285 1
   case nir_op_seq:
d10287 3
a10289 1
   case nir_op_sge:
d10291 3
a10293 1
   case nir_op_slt:
d10295 3
a10297 1
   case nir_op_sne:
d10299 11
a10309 15
   case nir_op_u2f16:
      return evaluate_u2f16(num_components, bit_width, src);
   case nir_op_u2f32:
      return evaluate_u2f32(num_components, bit_width, src);
   case nir_op_u2f64:
      return evaluate_u2f64(num_components, bit_width, src);
   case nir_op_u2u16:
      return evaluate_u2u16(num_components, bit_width, src);
   case nir_op_u2u32:
      return evaluate_u2u32(num_components, bit_width, src);
   case nir_op_u2u64:
      return evaluate_u2u64(num_components, bit_width, src);
   case nir_op_u2u8:
      return evaluate_u2u8(num_components, bit_width, src);
   case nir_op_uadd_carry:
d10311 3
a10313 1
   case nir_op_ubfe:
d10315 3
a10317 1
   case nir_op_ubitfield_extract:
d10319 3
a10321 1
   case nir_op_udiv:
d10323 3
a10325 1
   case nir_op_ufind_msb:
d10327 3
a10329 1
   case nir_op_uge:
d10331 3
a10333 1
   case nir_op_ult:
d10335 3
a10337 1
   case nir_op_umax:
d10339 3
a10341 1
   case nir_op_umax_4x8:
d10343 3
a10345 1
   case nir_op_umin:
d10347 3
a10349 1
   case nir_op_umin_4x8:
d10351 3
a10353 1
   case nir_op_umod:
d10355 3
a10357 1
   case nir_op_umul_high:
d10359 3
a10361 1
   case nir_op_umul_unorm_4x8:
d10363 15
a10377 7
   case nir_op_unpack_64_2x32:
      return evaluate_unpack_64_2x32(num_components, bit_width, src);
   case nir_op_unpack_64_2x32_split_x:
      return evaluate_unpack_64_2x32_split_x(num_components, bit_width, src);
   case nir_op_unpack_64_2x32_split_y:
      return evaluate_unpack_64_2x32_split_y(num_components, bit_width, src);
   case nir_op_unpack_half_2x16:
d10379 3
a10381 1
   case nir_op_unpack_half_2x16_split_x:
d10383 3
a10385 1
   case nir_op_unpack_half_2x16_split_y:
d10387 3
a10389 1
   case nir_op_unpack_snorm_2x16:
d10391 3
a10393 1
   case nir_op_unpack_snorm_4x8:
d10395 3
a10397 1
   case nir_op_unpack_unorm_2x16:
d10399 3
a10401 1
   case nir_op_unpack_unorm_4x8:
d10403 3
a10405 1
   case nir_op_usadd_4x8:
d10407 3
a10409 1
   case nir_op_ushr:
d10411 3
a10413 1
   case nir_op_ussub_4x8:
d10415 3
a10417 1
   case nir_op_usub_borrow:
d10419 3
a10421 1
   case nir_op_vec2:
d10423 3
a10425 1
   case nir_op_vec3:
d10427 3
a10429 1
   case nir_op_vec4:
d10431 2
@


