head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	mesa-17_1_6:1.1.1.3
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	mesa-13_0_6:1.1.1.2
	mesa-13_0_5:1.1.1.2
	mesa-13_0_3:1.1.1.2
	mesa-13_0_2:1.1.1.2
	OPENBSD_6_0:1.1.1.1.0.4
	OPENBSD_6_0_BASE:1.1.1.1
	mesa-11_2_2:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.08.26.16.59.21;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2016.05.29.10.16.22;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.1
date	2016.05.29.10.16.22;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.2
date	2016.12.11.08.33.42;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	uuv5VTS15jglEDZU;

1.1.1.3
date	2017.08.14.09.38.27;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@#! /usr/bin/python2

def type_has_size(type_):
    return type_[-1:].isdigit()

def type_sizes(type_):
    if type_.endswith("8"):
        return [8]
    elif type_.endswith("16"):
        return [16]
    elif type_.endswith("32"):
        return [32]
    elif type_.endswith("64"):
        return [64]
    else:
        return [32, 64]

def type_add_size(type_, size):
    if type_has_size(type_):
        return type_
    return type_ + str(size)

def get_const_field(type_):
    if type_ == "int32":
        return "i32"
    if type_ == "uint32":
        return "u32"
    if type_ == "int64":
        return "i64"
    if type_ == "uint64":
        return "u64"
    if type_ == "bool32":
        return "u32"
    if type_ == "float32":
        return "f32"
    if type_ == "float64":
        return "f64"
    raise Exception(str(type_))
    assert(0)

template = """\
/*
 * Copyright (C) 2014 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Jason Ekstrand (jason@@jlekstrand.net)
 */

#include <math.h>
#include "main/core.h"
#include "util/rounding.h" /* for _mesa_roundeven */
#include "util/half_float.h"
#include "nir_constant_expressions.h"

/**
 * Evaluate one component of packSnorm4x8.
 */
static uint8_t
pack_snorm_1x8(float x)
{
    /* From section 8.4 of the GLSL 4.30 spec:
     *
     *    packSnorm4x8
     *    ------------
     *    The conversion for component c of v to fixed point is done as
     *    follows:
     *
     *      packSnorm4x8: round(clamp(c, -1, +1) * 127.0)
     *
     * We must first cast the float to an int, because casting a negative
     * float to a uint is undefined.
     */
   return (uint8_t) (int)
          _mesa_roundevenf(CLAMP(x, -1.0f, +1.0f) * 127.0f);
}

/**
 * Evaluate one component of packSnorm2x16.
 */
static uint16_t
pack_snorm_1x16(float x)
{
    /* From section 8.4 of the GLSL ES 3.00 spec:
     *
     *    packSnorm2x16
     *    -------------
     *    The conversion for component c of v to fixed point is done as
     *    follows:
     *
     *      packSnorm2x16: round(clamp(c, -1, +1) * 32767.0)
     *
     * We must first cast the float to an int, because casting a negative
     * float to a uint is undefined.
     */
   return (uint16_t) (int)
          _mesa_roundevenf(CLAMP(x, -1.0f, +1.0f) * 32767.0f);
}

/**
 * Evaluate one component of unpackSnorm4x8.
 */
static float
unpack_snorm_1x8(uint8_t u)
{
    /* From section 8.4 of the GLSL 4.30 spec:
     *
     *    unpackSnorm4x8
     *    --------------
     *    The conversion for unpacked fixed-point value f to floating point is
     *    done as follows:
     *
     *       unpackSnorm4x8: clamp(f / 127.0, -1, +1)
     */
   return CLAMP((int8_t) u / 127.0f, -1.0f, +1.0f);
}

/**
 * Evaluate one component of unpackSnorm2x16.
 */
static float
unpack_snorm_1x16(uint16_t u)
{
    /* From section 8.4 of the GLSL ES 3.00 spec:
     *
     *    unpackSnorm2x16
     *    ---------------
     *    The conversion for unpacked fixed-point value f to floating point is
     *    done as follows:
     *
     *       unpackSnorm2x16: clamp(f / 32767.0, -1, +1)
     */
   return CLAMP((int16_t) u / 32767.0f, -1.0f, +1.0f);
}

/**
 * Evaluate one component packUnorm4x8.
 */
static uint8_t
pack_unorm_1x8(float x)
{
    /* From section 8.4 of the GLSL 4.30 spec:
     *
     *    packUnorm4x8
     *    ------------
     *    The conversion for component c of v to fixed point is done as
     *    follows:
     *
     *       packUnorm4x8: round(clamp(c, 0, +1) * 255.0)
     */
   return (uint8_t) (int)
          _mesa_roundevenf(CLAMP(x, 0.0f, 1.0f) * 255.0f);
}

/**
 * Evaluate one component packUnorm2x16.
 */
static uint16_t
pack_unorm_1x16(float x)
{
    /* From section 8.4 of the GLSL ES 3.00 spec:
     *
     *    packUnorm2x16
     *    -------------
     *    The conversion for component c of v to fixed point is done as
     *    follows:
     *
     *       packUnorm2x16: round(clamp(c, 0, +1) * 65535.0)
     */
   return (uint16_t) (int)
          _mesa_roundevenf(CLAMP(x, 0.0f, 1.0f) * 65535.0f);
}

/**
 * Evaluate one component of unpackUnorm4x8.
 */
static float
unpack_unorm_1x8(uint8_t u)
{
    /* From section 8.4 of the GLSL 4.30 spec:
     *
     *    unpackUnorm4x8
     *    --------------
     *    The conversion for unpacked fixed-point value f to floating point is
     *    done as follows:
     *
     *       unpackUnorm4x8: f / 255.0
     */
   return (float) u / 255.0f;
}

/**
 * Evaluate one component of unpackUnorm2x16.
 */
static float
unpack_unorm_1x16(uint16_t u)
{
    /* From section 8.4 of the GLSL ES 3.00 spec:
     *
     *    unpackUnorm2x16
     *    ---------------
     *    The conversion for unpacked fixed-point value f to floating point is
     *    done as follows:
     *
     *       unpackUnorm2x16: f / 65535.0
     */
   return (float) u / 65535.0f;
}

/**
 * Evaluate one component of packHalf2x16.
 */
static uint16_t
pack_half_1x16(float x)
{
   return _mesa_float_to_half(x);
}

/**
 * Evaluate one component of unpackHalf2x16.
 */
static float
unpack_half_1x16(uint16_t u)
{
   return _mesa_half_to_float(u);
}

/* Some typed vector structures to make things like src0.y work */
typedef float float32_t;
typedef double float64_t;
typedef bool bool32_t;
% for type in ["float", "int", "uint"]:
% for width in [32, 64]:
struct ${type}${width}_vec {
   ${type}${width}_t x;
   ${type}${width}_t y;
   ${type}${width}_t z;
   ${type}${width}_t w;
};
% endfor
% endfor

struct bool32_vec {
    bool x;
    bool y;
    bool z;
    bool w;
};

% for name, op in sorted(opcodes.iteritems()):
static nir_const_value
evaluate_${name}(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   switch (bit_size) {
   % for bit_size in [32, 64]:
   case ${bit_size}: {
      <%
      output_type = type_add_size(op.output_type, bit_size)
      input_types = [type_add_size(type_, bit_size) for type_ in op.input_types]
      %>

      ## For each non-per-component input, create a variable srcN that
      ## contains x, y, z, and w elements which are filled in with the
      ## appropriately-typed values.
      % for j in range(op.num_inputs):
         % if op.input_sizes[j] == 0:
            <% continue %>
         % elif "src" + str(j) not in op.const_expr:
            ## Avoid unused variable warnings
            <% continue %>
         %endif

         struct ${input_types[j]}_vec src${j} = {
         % for k in range(op.input_sizes[j]):
            % if input_types[j] == "bool32":
               _src[${j}].u32[${k}] != 0,
            % else:
               _src[${j}].${get_const_field(input_types[j])}[${k}],
            % endif
         % endfor
         };
      % endfor

      % if op.output_size == 0:
         ## For per-component instructions, we need to iterate over the
         ## components and apply the constant expression one component
         ## at a time.
         for (unsigned _i = 0; _i < num_components; _i++) {
            ## For each per-component input, create a variable srcN that
            ## contains the value of the current (_i'th) component.
            % for j in range(op.num_inputs):
               % if op.input_sizes[j] != 0:
                  <% continue %>
               % elif "src" + str(j) not in op.const_expr:
                  ## Avoid unused variable warnings
                  <% continue %>
               % elif input_types[j] == "bool32":
                  bool src${j} = _src[${j}].u32[_i] != 0;
               % else:
                  ${input_types[j]}_t src${j} =
                     _src[${j}].${get_const_field(input_types[j])}[_i];
               % endif
            % endfor

            ## Create an appropriately-typed variable dst and assign the
            ## result of the const_expr to it.  If const_expr already contains
            ## writes to dst, just include const_expr directly.
            % if "dst" in op.const_expr:
               ${output_type}_t dst;
               ${op.const_expr}
            % else:
               ${output_type}_t dst = ${op.const_expr};
            % endif

            ## Store the current component of the actual destination to the
            ## value of dst.
            % if output_type == "bool32":
               ## Sanitize the C value to a proper NIR bool
               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
            % else:
               _dst_val.${get_const_field(output_type)}[_i] = dst;
            % endif
         }
      % else:
         ## In the non-per-component case, create a struct dst with
         ## appropriately-typed elements x, y, z, and w and assign the result
         ## of the const_expr to all components of dst, or include the
         ## const_expr directly if it writes to dst already.
         struct ${output_type}_vec dst;

         % if "dst" in op.const_expr:
            ${op.const_expr}
         % else:
            ## Splat the value to all components.  This way expressions which
            ## write the same value to all components don't need to explicitly
            ## write to dest.  One such example is fnoise which has a
            ## const_expr of 0.0f.
            dst.x = dst.y = dst.z = dst.w = ${op.const_expr};
         % endif

         ## For each component in the destination, copy the value of dst to
         ## the actual destination.
         % for k in range(op.output_size):
            % if output_type == "bool32":
               ## Sanitize the C value to a proper NIR bool
               _dst_val.u32[${k}] = dst.${"xyzw"[k]} ? NIR_TRUE : NIR_FALSE;
            % else:
               _dst_val.${get_const_field(output_type)}[${k}] = dst.${"xyzw"[k]};
            % endif
         % endfor
      % endif

      break;
   }
   % endfor

   default:
      unreachable("unknown bit width");
   }

   return _dst_val;
}
% endfor

nir_const_value
nir_eval_const_opcode(nir_op op, unsigned num_components,
                      unsigned bit_width, nir_const_value *src)
{
   switch (op) {
% for name in sorted(opcodes.iterkeys()):
   case nir_op_${name}: {
      return evaluate_${name}(num_components, bit_width, src);
      break;
   }
% endfor
   default:
      unreachable("shouldn't get here");
   }
}"""

from nir_opcodes import opcodes
from mako.template import Template

print Template(template).render(opcodes=opcodes, type_sizes=type_sizes,
                                type_has_size=type_has_size,
                                type_add_size=type_add_size,
                                get_const_field=get_const_field)
@


1.1
log
@Initial revision
@
text
@d2 39
d247 10
a256 6
% for type in ["float", "int", "uint", "bool"]:
struct ${type}_vec {
   ${type} x;
   ${type} y;
   ${type} z;
   ${type} w;
d259 8
d270 2
a271 1
evaluate_${name}(unsigned num_components, nir_const_value *_src)
d273 1
a273 1
   nir_const_value _dst_val = { { {0, 0, 0, 0} } };
d275 28
a302 18
   ## For each non-per-component input, create a variable srcN that
   ## contains x, y, z, and w elements which are filled in with the
   ## appropriately-typed values.
   % for j in range(op.num_inputs):
      % if op.input_sizes[j] == 0:
         <% continue %>
      % elif "src" + str(j) not in op.const_expr:
         ## Avoid unused variable warnings
         <% continue %>
      %endif

      struct ${op.input_types[j]}_vec src${j} = {
      % for k in range(op.input_sizes[j]):
         % if op.input_types[j] == "bool":
            _src[${j}].u[${k}] != 0,
         % else:
            _src[${j}].${op.input_types[j][:1]}[${k}],
         % endif
a303 2
      };
   % endfor
d305 36
a340 15
   % if op.output_size == 0:
      ## For per-component instructions, we need to iterate over the
      ## components and apply the constant expression one component
      ## at a time.
      for (unsigned _i = 0; _i < num_components; _i++) {
         ## For each per-component input, create a variable srcN that
         ## contains the value of the current (_i'th) component.
         % for j in range(op.num_inputs):
            % if op.input_sizes[j] != 0:
               <% continue %>
            % elif "src" + str(j) not in op.const_expr:
               ## Avoid unused variable warnings
               <% continue %>
            % elif op.input_types[j] == "bool":
               bool src${j} = _src[${j}].u[_i] != 0;
d342 1
a342 1
               ${op.input_types[j]} src${j} = _src[${j}].${op.input_types[j][:1]}[_i];
d344 7
a350 1
         % endfor
a351 3
         ## Create an appropriately-typed variable dst and assign the
         ## result of the const_expr to it.  If const_expr already contains
         ## writes to dst, just include const_expr directly.
a352 1
            ${op.output_type} dst;
d355 5
a359 1
            ${op.output_type} dst = ${op.const_expr};
d362 11
a372 15
         ## Store the current component of the actual destination to the
         ## value of dst.
         % if op.output_type == "bool":
            ## Sanitize the C value to a proper NIR bool
            _dst_val.u[_i] = dst ? NIR_TRUE : NIR_FALSE;
         % else:
            _dst_val.${op.output_type[:1]}[_i] = dst;
         % endif
      }
   % else:
      ## In the non-per-component case, create a struct dst with
      ## appropriately-typed elements x, y, z, and w and assign the result
      ## of the const_expr to all components of dst, or include the
      ## const_expr directly if it writes to dst already.
      struct ${op.output_type}_vec dst;
d374 3
a376 9
      % if "dst" in op.const_expr:
         ${op.const_expr}
      % else:
         ## Splat the value to all components.  This way expressions which
         ## write the same value to all components don't need to explicitly
         ## write to dest.  One such example is fnoise which has a
         ## const_expr of 0.0f.
         dst.x = dst.y = dst.z = dst.w = ${op.const_expr};
      % endif
d378 3
a380 11
      ## For each component in the destination, copy the value of dst to
      ## the actual destination.
      % for k in range(op.output_size):
         % if op.output_type == "bool":
            ## Sanitize the C value to a proper NIR bool
            _dst_val.u[${k}] = dst.${"xyzw"[k]} ? NIR_TRUE : NIR_FALSE;
         % else:
            _dst_val.${op.output_type[:1]}[${k}] = dst.${"xyzw"[k]};
         % endif
      % endfor
   % endif
d388 1
a388 1
                      nir_const_value *src)
d393 1
a393 1
      return evaluate_${name}(num_components, src);
d405 4
a408 1
print Template(template).render(opcodes=opcodes)
@


1.1.1.1
log
@Import Mesa 11.2.2
@
text
@@


1.1.1.2
log
@Import Mesa 13.0.2
@
text
@a1 39

def type_has_size(type_):
    return type_[-1:].isdigit()

def type_sizes(type_):
    if type_.endswith("8"):
        return [8]
    elif type_.endswith("16"):
        return [16]
    elif type_.endswith("32"):
        return [32]
    elif type_.endswith("64"):
        return [64]
    else:
        return [32, 64]

def type_add_size(type_, size):
    if type_has_size(type_):
        return type_
    return type_ + str(size)

def get_const_field(type_):
    if type_ == "int32":
        return "i32"
    if type_ == "uint32":
        return "u32"
    if type_ == "int64":
        return "i64"
    if type_ == "uint64":
        return "u64"
    if type_ == "bool32":
        return "u32"
    if type_ == "float32":
        return "f32"
    if type_ == "float64":
        return "f64"
    raise Exception(str(type_))
    assert(0)

d208 6
a213 10
typedef float float32_t;
typedef double float64_t;
typedef bool bool32_t;
% for type in ["float", "int", "uint"]:
% for width in [32, 64]:
struct ${type}${width}_vec {
   ${type}${width}_t x;
   ${type}${width}_t y;
   ${type}${width}_t z;
   ${type}${width}_t w;
a215 8
% endfor

struct bool32_vec {
    bool x;
    bool y;
    bool z;
    bool w;
};
d219 1
a219 2
evaluate_${name}(unsigned num_components, unsigned bit_size,
                 nir_const_value *_src)
d221 1
a221 1
   nir_const_value _dst_val = { {0, } };
d223 18
a240 28
   switch (bit_size) {
   % for bit_size in [32, 64]:
   case ${bit_size}: {
      <%
      output_type = type_add_size(op.output_type, bit_size)
      input_types = [type_add_size(type_, bit_size) for type_ in op.input_types]
      %>

      ## For each non-per-component input, create a variable srcN that
      ## contains x, y, z, and w elements which are filled in with the
      ## appropriately-typed values.
      % for j in range(op.num_inputs):
         % if op.input_sizes[j] == 0:
            <% continue %>
         % elif "src" + str(j) not in op.const_expr:
            ## Avoid unused variable warnings
            <% continue %>
         %endif

         struct ${input_types[j]}_vec src${j} = {
         % for k in range(op.input_sizes[j]):
            % if input_types[j] == "bool32":
               _src[${j}].u32[${k}] != 0,
            % else:
               _src[${j}].${get_const_field(input_types[j])}[${k}],
            % endif
         % endfor
         };
d242 2
d245 15
a259 27
      % if op.output_size == 0:
         ## For per-component instructions, we need to iterate over the
         ## components and apply the constant expression one component
         ## at a time.
         for (unsigned _i = 0; _i < num_components; _i++) {
            ## For each per-component input, create a variable srcN that
            ## contains the value of the current (_i'th) component.
            % for j in range(op.num_inputs):
               % if op.input_sizes[j] != 0:
                  <% continue %>
               % elif "src" + str(j) not in op.const_expr:
                  ## Avoid unused variable warnings
                  <% continue %>
               % elif input_types[j] == "bool32":
                  bool src${j} = _src[${j}].u32[_i] != 0;
               % else:
                  ${input_types[j]}_t src${j} =
                     _src[${j}].${get_const_field(input_types[j])}[_i];
               % endif
            % endfor

            ## Create an appropriately-typed variable dst and assign the
            ## result of the const_expr to it.  If const_expr already contains
            ## writes to dst, just include const_expr directly.
            % if "dst" in op.const_expr:
               ${output_type}_t dst;
               ${op.const_expr}
d261 1
a261 1
               ${output_type}_t dst = ${op.const_expr};
d263 1
d265 3
a267 16
            ## Store the current component of the actual destination to the
            ## value of dst.
            % if output_type == "bool32":
               ## Sanitize the C value to a proper NIR bool
               _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
            % else:
               _dst_val.${get_const_field(output_type)}[_i] = dst;
            % endif
         }
      % else:
         ## In the non-per-component case, create a struct dst with
         ## appropriately-typed elements x, y, z, and w and assign the result
         ## of the const_expr to all components of dst, or include the
         ## const_expr directly if it writes to dst already.
         struct ${output_type}_vec dst;

d269 1
d272 1
a272 5
            ## Splat the value to all components.  This way expressions which
            ## write the same value to all components don't need to explicitly
            ## write to dest.  One such example is fnoise which has a
            ## const_expr of 0.0f.
            dst.x = dst.y = dst.z = dst.w = ${op.const_expr};
d275 24
a298 10
         ## For each component in the destination, copy the value of dst to
         ## the actual destination.
         % for k in range(op.output_size):
            % if output_type == "bool32":
               ## Sanitize the C value to a proper NIR bool
               _dst_val.u32[${k}] = dst.${"xyzw"[k]} ? NIR_TRUE : NIR_FALSE;
            % else:
               _dst_val.${get_const_field(output_type)}[${k}] = dst.${"xyzw"[k]};
            % endif
         % endfor
d301 11
a311 7
      break;
   }
   % endfor

   default:
      unreachable("unknown bit width");
   }
d319 1
a319 1
                      unsigned bit_width, nir_const_value *src)
d324 1
a324 1
      return evaluate_${name}(num_components, bit_width, src);
d336 1
a336 4
print Template(template).render(opcodes=opcodes, type_sizes=type_sizes,
                                type_has_size=type_has_size,
                                type_add_size=type_add_size,
                                get_const_field=get_const_field)
@


1.1.1.3
log
@Import Mesa 17.1.6
@
text
@d1 1
a1 4

import re

type_split_re = re.compile(r'(?P<type>[a-z]+)(?P<bits>\d+)')
a5 4
def type_size(type_):
    assert type_has_size(type_)
    return int(type_split_re.match(type_).group('bits'))

d7 8
a14 4
    if type_has_size(type_):
        return [type_size(type_)]
    elif type_ == 'float':
        return [16, 32, 64]
d16 1
a16 1
        return [8, 16, 32, 64]
a22 14
def op_bit_sizes(op):
    sizes = None
    if not type_has_size(op.output_type):
        sizes = set(type_sizes(op.output_type))

    for input_type in op.input_types:
        if not type_has_size(input_type):
            if sizes is None:
                sizes = set(type_sizes(input_type))
            else:
                sizes = sizes.intersection(set(type_sizes(input_type)))

    return sorted(list(sizes)) if sizes is not None else None

d24 8
d34 6
a39 7
    elif type_ == "float16":
        return "u16"
    else:
        m = type_split_re.match(type_)
        if not m:
            raise Exception(str(type_))
        return m.group('type')[0] + m.group('bits')
a246 1
typedef float float16_t;
d251 1
a251 1
% for width in type_sizes(type):
d268 35
a302 26
<%def name="evaluate_op(op, bit_size)">
   <%
   output_type = type_add_size(op.output_type, bit_size)
   input_types = [type_add_size(type_, bit_size) for type_ in op.input_types]
   %>

   ## For each non-per-component input, create a variable srcN that
   ## contains x, y, z, and w elements which are filled in with the
   ## appropriately-typed values.
   % for j in range(op.num_inputs):
      % if op.input_sizes[j] == 0:
         <% continue %>
      % elif "src" + str(j) not in op.const_expr:
         ## Avoid unused variable warnings
         <% continue %>
      %endif

      const struct ${input_types[j]}_vec src${j} = {
      % for k in range(op.input_sizes[j]):
         % if input_types[j] == "bool32":
            _src[${j}].u32[${k}] != 0,
         % elif input_types[j] == "float16":
            _mesa_half_to_float(_src[${j}].u16[${k}]),
         % else:
            _src[${j}].${get_const_field(input_types[j])}[${k}],
         % endif
a303 5
      % for k in range(op.input_sizes[j], 4):
         0,
      % endfor
      };
   % endfor
d305 36
a340 18
   % if op.output_size == 0:
      ## For per-component instructions, we need to iterate over the
      ## components and apply the constant expression one component
      ## at a time.
      for (unsigned _i = 0; _i < num_components; _i++) {
         ## For each per-component input, create a variable srcN that
         ## contains the value of the current (_i'th) component.
         % for j in range(op.num_inputs):
            % if op.input_sizes[j] != 0:
               <% continue %>
            % elif "src" + str(j) not in op.const_expr:
               ## Avoid unused variable warnings
               <% continue %>
            % elif input_types[j] == "bool32":
               const bool src${j} = _src[${j}].u32[_i] != 0;
            % elif input_types[j] == "float16":
               const float src${j} =
                  _mesa_half_to_float(_src[${j}].u16[_i]);
d342 1
a342 2
               const ${input_types[j]}_t src${j} =
                  _src[${j}].${get_const_field(input_types[j])}[_i];
d344 7
a350 1
         % endfor
a351 3
         ## Create an appropriately-typed variable dst and assign the
         ## result of the const_expr to it.  If const_expr already contains
         ## writes to dst, just include const_expr directly.
a352 2
            ${output_type}_t dst;

d355 5
a359 1
            ${output_type}_t dst = ${op.const_expr};
d362 10
a371 26
         ## Store the current component of the actual destination to the
         ## value of dst.
         % if output_type == "bool32":
            ## Sanitize the C value to a proper NIR bool
            _dst_val.u32[_i] = dst ? NIR_TRUE : NIR_FALSE;
         % elif output_type == "float16":
            _dst_val.u16[_i] = _mesa_float_to_half(dst);
         % else:
            _dst_val.${get_const_field(output_type)}[_i] = dst;
         % endif
      }
   % else:
      ## In the non-per-component case, create a struct dst with
      ## appropriately-typed elements x, y, z, and w and assign the result
      ## of the const_expr to all components of dst, or include the
      ## const_expr directly if it writes to dst already.
      struct ${output_type}_vec dst;

      % if "dst" in op.const_expr:
         ${op.const_expr}
      % else:
         ## Splat the value to all components.  This way expressions which
         ## write the same value to all components don't need to explicitly
         ## write to dest.  One such example is fnoise which has a
         ## const_expr of 0.0f.
         dst.x = dst.y = dst.z = dst.w = ${op.const_expr};
d374 3
a376 14
      ## For each component in the destination, copy the value of dst to
      ## the actual destination.
      % for k in range(op.output_size):
         % if output_type == "bool32":
            ## Sanitize the C value to a proper NIR bool
            _dst_val.u32[${k}] = dst.${"xyzw"[k]} ? NIR_TRUE : NIR_FALSE;
         % elif output_type == "float16":
            _dst_val.u16[${k}] = _mesa_float_to_half(dst.${"xyzw"[k]});
         % else:
            _dst_val.${get_const_field(output_type)}[${k}] = dst.${"xyzw"[k]};
         % endif
      % endfor
   % endif
</%def>
d378 3
a380 22
% for name, op in sorted(opcodes.iteritems()):
static nir_const_value
evaluate_${name}(MAYBE_UNUSED unsigned num_components, unsigned bit_size,
                 MAYBE_UNUSED nir_const_value *_src)
{
   nir_const_value _dst_val = { {0, } };

   % if op_bit_sizes(op) is not None:
      switch (bit_size) {
      % for bit_size in op_bit_sizes(op):
      case ${bit_size}: {
         ${evaluate_op(op, bit_size)}
         break;
      }
      % endfor

      default:
         unreachable("unknown bit width");
      }
   % else:
      ${evaluate_op(op, 0)}
   % endif
d392 1
a392 1
   case nir_op_${name}:
d394 2
a407 1
                                op_bit_sizes=op_bit_sizes,
@


