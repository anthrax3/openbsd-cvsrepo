head	1.1;
branch	1.1.1;
access;
symbols
	mesa-17_1_6:1.1.1.3
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	mesa-13_0_6:1.1.1.2
	mesa-13_0_5:1.1.1.2
	mesa-13_0_3:1.1.1.2
	mesa-13_0_2:1.1.1.2
	OPENBSD_6_0:1.1.1.1.0.4
	OPENBSD_6_0_BASE:1.1.1.1
	mesa-11_2_2:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2016.05.29.10.16.32;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.1
date	2016.05.29.10.16.32;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.2
date	2016.12.11.08.33.34;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	uuv5VTS15jglEDZU;

1.1.1.3
date	2017.08.14.09.38.18;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright Â© 2014 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Connor Abbott (cwabbott0@@gmail.com)
 *
 */

#include "nir.h"
#include <assert.h>

/*
 * This file checks for invalid IR indicating a bug somewhere in the compiler.
 */

/* Since this file is just a pile of asserts, don't bother compiling it if
 * we're not building a debug build.
 */
#ifdef DEBUG

/*
 * Per-register validation state.
 */

typedef struct {
   /*
    * equivalent to the uses and defs in nir_register, but built up by the
    * validator. At the end, we verify that the sets have the same entries.
    */
   struct set *uses, *if_uses, *defs;
   nir_function_impl *where_defined; /* NULL for global registers */
} reg_validate_state;

typedef struct {
   /*
    * equivalent to the uses in nir_ssa_def, but built up by the validator.
    * At the end, we verify that the sets have the same entries.
    */
   struct set *uses, *if_uses;
   nir_function_impl *where_defined;
} ssa_def_validate_state;

typedef struct {
   /* map of register -> validation state (struct above) */
   struct hash_table *regs;

   /* the current shader being validated */
   nir_shader *shader;

   /* the current instruction being validated */
   nir_instr *instr;

   /* the current basic block being validated */
   nir_block *block;

   /* the current if statement being validated */
   nir_if *if_stmt;

   /* the current loop being visited */
   nir_loop *loop;

   /* the parent of the current cf node being visited */
   nir_cf_node *parent_node;

   /* the current function implementation being validated */
   nir_function_impl *impl;

   /* map of SSA value -> function implementation where it is defined */
   struct hash_table *ssa_defs;

   /* bitset of ssa definitions we have found; used to check uniqueness */
   BITSET_WORD *ssa_defs_found;

   /* bitset of registers we have currently found; used to check uniqueness */
   BITSET_WORD *regs_found;

   /* map of local variable -> function implementation where it is defined */
   struct hash_table *var_defs;
} validate_state;

static void validate_src(nir_src *src, validate_state *state);

static void
validate_reg_src(nir_src *src, validate_state *state)
{
   assert(src->reg.reg != NULL);

   struct hash_entry *entry;
   entry = _mesa_hash_table_search(state->regs, src->reg.reg);
   assert(entry);

   reg_validate_state *reg_state = (reg_validate_state *) entry->data;

   if (state->instr) {
      _mesa_set_add(reg_state->uses, src);
   } else {
      assert(state->if_stmt);
      _mesa_set_add(reg_state->if_uses, src);
   }

   if (!src->reg.reg->is_global) {
      assert(reg_state->where_defined == state->impl &&
             "using a register declared in a different function");
   }

   assert((src->reg.reg->num_array_elems == 0 ||
          src->reg.base_offset < src->reg.reg->num_array_elems) &&
          "definitely out-of-bounds array access");

   if (src->reg.indirect) {
      assert(src->reg.reg->num_array_elems != 0);
      assert((src->reg.indirect->is_ssa ||
              src->reg.indirect->reg.indirect == NULL) &&
             "only one level of indirection allowed");
      validate_src(src->reg.indirect, state);
   }
}

static void
validate_ssa_src(nir_src *src, validate_state *state)
{
   assert(src->ssa != NULL);

   struct hash_entry *entry = _mesa_hash_table_search(state->ssa_defs, src->ssa);

   assert(entry);

   ssa_def_validate_state *def_state = (ssa_def_validate_state *)entry->data;

   assert(def_state->where_defined == state->impl &&
          "using an SSA value defined in a different function");

   if (state->instr) {
      _mesa_set_add(def_state->uses, src);
   } else {
      assert(state->if_stmt);
      _mesa_set_add(def_state->if_uses, src);
   }

   /* TODO validate that the use is dominated by the definition */
}

static void
validate_src(nir_src *src, validate_state *state)
{
   if (state->instr)
      assert(src->parent_instr == state->instr);
   else
      assert(src->parent_if == state->if_stmt);

   if (src->is_ssa)
      validate_ssa_src(src, state);
   else
      validate_reg_src(src, state);
}

static void
validate_alu_src(nir_alu_instr *instr, unsigned index, validate_state *state)
{
   nir_alu_src *src = &instr->src[index];

   unsigned num_components;
   if (src->src.is_ssa)
      num_components = src->src.ssa->num_components;
   else {
      if (src->src.reg.reg->is_packed)
         num_components = 4; /* can't check anything */
      else
         num_components = src->src.reg.reg->num_components;
   }
   for (unsigned i = 0; i < 4; i++) {
      assert(src->swizzle[i] < 4);

      if (nir_alu_instr_channel_used(instr, index, i))
         assert(src->swizzle[i] < num_components);
   }

   validate_src(&src->src, state);
}

static void
validate_reg_dest(nir_reg_dest *dest, validate_state *state)
{
   assert(dest->reg != NULL);

   assert(dest->parent_instr == state->instr);

   struct hash_entry *entry2;
   entry2 = _mesa_hash_table_search(state->regs, dest->reg);

   assert(entry2);

   reg_validate_state *reg_state = (reg_validate_state *) entry2->data;
   _mesa_set_add(reg_state->defs, dest);

   if (!dest->reg->is_global) {
      assert(reg_state->where_defined == state->impl &&
             "writing to a register declared in a different function");
   }

   assert((dest->reg->num_array_elems == 0 ||
          dest->base_offset < dest->reg->num_array_elems) &&
          "definitely out-of-bounds array access");

   if (dest->indirect) {
      assert(dest->reg->num_array_elems != 0);
      assert((dest->indirect->is_ssa || dest->indirect->reg.indirect == NULL) &&
             "only one level of indirection allowed");
      validate_src(dest->indirect, state);
   }
}

static void
validate_ssa_def(nir_ssa_def *def, validate_state *state)
{
   assert(def->index < state->impl->ssa_alloc);
   assert(!BITSET_TEST(state->ssa_defs_found, def->index));
   BITSET_SET(state->ssa_defs_found, def->index);

   assert(def->parent_instr == state->instr);

   assert(def->num_components <= 4);

   list_validate(&def->uses);
   list_validate(&def->if_uses);

   ssa_def_validate_state *def_state = ralloc(state->ssa_defs,
                                              ssa_def_validate_state);
   def_state->where_defined = state->impl;
   def_state->uses = _mesa_set_create(def_state, _mesa_hash_pointer,
                                      _mesa_key_pointer_equal);
   def_state->if_uses = _mesa_set_create(def_state, _mesa_hash_pointer,
                                         _mesa_key_pointer_equal);
   _mesa_hash_table_insert(state->ssa_defs, def, def_state);
}

static void
validate_dest(nir_dest *dest, validate_state *state)
{
   if (dest->is_ssa)
      validate_ssa_def(&dest->ssa, state);
   else
      validate_reg_dest(&dest->reg, state);
}

static void
validate_alu_dest(nir_alu_dest *dest, validate_state *state)
{
   unsigned dest_size =
      dest->dest.is_ssa ? dest->dest.ssa.num_components
                        : dest->dest.reg.reg->num_components;
   bool is_packed = !dest->dest.is_ssa && dest->dest.reg.reg->is_packed;
   /*
    * validate that the instruction doesn't write to components not in the
    * register/SSA value
    */
   assert(is_packed || !(dest->write_mask & ~((1 << dest_size) - 1)));

   /* validate that saturate is only ever used on instructions with
    * destinations of type float
    */
   nir_alu_instr *alu = nir_instr_as_alu(state->instr);
   assert(nir_op_infos[alu->op].output_type == nir_type_float ||
          !dest->saturate);

   validate_dest(&dest->dest, state);
}

static void
validate_alu_instr(nir_alu_instr *instr, validate_state *state)
{
   assert(instr->op < nir_num_opcodes);

   for (unsigned i = 0; i < nir_op_infos[instr->op].num_inputs; i++) {
      validate_alu_src(instr, i, state);
   }

   validate_alu_dest(&instr->dest, state);
}

static void
validate_deref_chain(nir_deref *deref, validate_state *state)
{
   assert(deref->child == NULL || ralloc_parent(deref->child) == deref);

   nir_deref *parent = NULL;
   while (deref != NULL) {
      switch (deref->deref_type) {
      case nir_deref_type_array:
         assert(deref->type == glsl_get_array_element(parent->type));
         if (nir_deref_as_array(deref)->deref_array_type ==
             nir_deref_array_type_indirect)
            validate_src(&nir_deref_as_array(deref)->indirect, state);
         break;

      case nir_deref_type_struct:
         assert(deref->type ==
                glsl_get_struct_field(parent->type,
                                      nir_deref_as_struct(deref)->index));
         break;

      case nir_deref_type_var:
         break;

      default:
         assert(!"Invalid deref type");
         break;
      }

      parent = deref;
      deref = deref->child;
   }
}

static void
validate_var_use(nir_variable *var, validate_state *state)
{
   if (var->data.mode == nir_var_local) {
      struct hash_entry *entry = _mesa_hash_table_search(state->var_defs, var);

      assert(entry);
      assert((nir_function_impl *) entry->data == state->impl);
   }
}

static void
validate_deref_var(void *parent_mem_ctx, nir_deref_var *deref, validate_state *state)
{
   assert(deref != NULL);
   assert(ralloc_parent(deref) == parent_mem_ctx);
   assert(deref->deref.type == deref->var->type);

   validate_var_use(deref->var, state);

   validate_deref_chain(&deref->deref, state);
}

static void
validate_intrinsic_instr(nir_intrinsic_instr *instr, validate_state *state)
{
   unsigned num_srcs = nir_intrinsic_infos[instr->intrinsic].num_srcs;
   for (unsigned i = 0; i < num_srcs; i++) {
      unsigned components_read =
         nir_intrinsic_infos[instr->intrinsic].src_components[i];
      if (components_read == 0)
         components_read = instr->num_components;

      assert(components_read > 0);

      if (instr->src[i].is_ssa) {
         assert(components_read <= instr->src[i].ssa->num_components);
      } else if (!instr->src[i].reg.reg->is_packed) {
         assert(components_read <= instr->src[i].reg.reg->num_components);
      }

      validate_src(&instr->src[i], state);
   }

   unsigned num_vars = nir_intrinsic_infos[instr->intrinsic].num_variables;
   for (unsigned i = 0; i < num_vars; i++) {
      validate_deref_var(instr, instr->variables[i], state);
   }

   if (nir_intrinsic_infos[instr->intrinsic].has_dest) {
      unsigned components_written =
         nir_intrinsic_infos[instr->intrinsic].dest_components;
      if (components_written == 0)
         components_written = instr->num_components;

      assert(components_written > 0);

      if (instr->dest.is_ssa) {
         assert(components_written <= instr->dest.ssa.num_components);
      } else if (!instr->dest.reg.reg->is_packed) {
         assert(components_written <= instr->dest.reg.reg->num_components);
      }

      validate_dest(&instr->dest, state);
   }

   switch (instr->intrinsic) {
   case nir_intrinsic_load_var: {
      const struct glsl_type *type =
         nir_deref_tail(&instr->variables[0]->deref)->type;
      assert(glsl_type_is_vector_or_scalar(type) ||
             (instr->variables[0]->var->data.mode == nir_var_uniform &&
              glsl_get_base_type(type) == GLSL_TYPE_SUBROUTINE));
      assert(instr->num_components == glsl_get_vector_elements(type));
      break;
   }
   case nir_intrinsic_store_var: {
      const struct glsl_type *type =
         nir_deref_tail(&instr->variables[0]->deref)->type;
      assert(glsl_type_is_vector_or_scalar(type) ||
             (instr->variables[0]->var->data.mode == nir_var_uniform &&
              glsl_get_base_type(type) == GLSL_TYPE_SUBROUTINE));
      assert(instr->num_components == glsl_get_vector_elements(type));
      assert(instr->variables[0]->var->data.mode != nir_var_shader_in &&
             instr->variables[0]->var->data.mode != nir_var_uniform &&
             instr->variables[0]->var->data.mode != nir_var_shader_storage);
      assert((nir_intrinsic_write_mask(instr) & ~((1 << instr->num_components) - 1)) == 0);
      break;
   }
   case nir_intrinsic_copy_var:
      assert(nir_deref_tail(&instr->variables[0]->deref)->type ==
             nir_deref_tail(&instr->variables[1]->deref)->type);
      assert(instr->variables[0]->var->data.mode != nir_var_shader_in &&
             instr->variables[0]->var->data.mode != nir_var_uniform &&
             instr->variables[0]->var->data.mode != nir_var_shader_storage);
      break;
   default:
      break;
   }
}

static void
validate_tex_instr(nir_tex_instr *instr, validate_state *state)
{
   bool src_type_seen[nir_num_tex_src_types];
   for (unsigned i = 0; i < nir_num_tex_src_types; i++)
      src_type_seen[i] = false;

   for (unsigned i = 0; i < instr->num_srcs; i++) {
      assert(!src_type_seen[instr->src[i].src_type]);
      src_type_seen[instr->src[i].src_type] = true;
      validate_src(&instr->src[i].src, state);
   }

   if (instr->texture != NULL)
      validate_deref_var(instr, instr->texture, state);

   if (instr->sampler != NULL)
      validate_deref_var(instr, instr->sampler, state);

   validate_dest(&instr->dest, state);
}

static void
validate_call_instr(nir_call_instr *instr, validate_state *state)
{
   if (instr->return_deref == NULL)
      assert(glsl_type_is_void(instr->callee->return_type));
   else
      assert(instr->return_deref->deref.type == instr->callee->return_type);

   assert(instr->num_params == instr->callee->num_params);

   for (unsigned i = 0; i < instr->num_params; i++) {
      assert(instr->callee->params[i].type == instr->params[i]->deref.type);
      validate_deref_var(instr, instr->params[i], state);
   }

   validate_deref_var(instr, instr->return_deref, state);
}

static void
validate_load_const_instr(nir_load_const_instr *instr, validate_state *state)
{
   validate_ssa_def(&instr->def, state);
}

static void
validate_ssa_undef_instr(nir_ssa_undef_instr *instr, validate_state *state)
{
   validate_ssa_def(&instr->def, state);
}

static void
validate_phi_instr(nir_phi_instr *instr, validate_state *state)
{
   /*
    * don't validate the sources until we get to them from their predecessor
    * basic blocks, to avoid validating an SSA use before its definition.
    */

   validate_dest(&instr->dest, state);

   exec_list_validate(&instr->srcs);
   assert(exec_list_length(&instr->srcs) ==
          state->block->predecessors->entries);
}

static void
validate_instr(nir_instr *instr, validate_state *state)
{
   assert(instr->block == state->block);

   state->instr = instr;

   switch (instr->type) {
   case nir_instr_type_alu:
      validate_alu_instr(nir_instr_as_alu(instr), state);
      break;

   case nir_instr_type_call:
      validate_call_instr(nir_instr_as_call(instr), state);
      break;

   case nir_instr_type_intrinsic:
      validate_intrinsic_instr(nir_instr_as_intrinsic(instr), state);
      break;

   case nir_instr_type_tex:
      validate_tex_instr(nir_instr_as_tex(instr), state);
      break;

   case nir_instr_type_load_const:
      validate_load_const_instr(nir_instr_as_load_const(instr), state);
      break;

   case nir_instr_type_phi:
      validate_phi_instr(nir_instr_as_phi(instr), state);
      break;

   case nir_instr_type_ssa_undef:
      validate_ssa_undef_instr(nir_instr_as_ssa_undef(instr), state);
      break;

   case nir_instr_type_jump:
      break;

   default:
      assert(!"Invalid ALU instruction type");
      break;
   }

   state->instr = NULL;
}

static void
validate_phi_src(nir_phi_instr *instr, nir_block *pred, validate_state *state)
{
   state->instr = &instr->instr;

   assert(instr->dest.is_ssa);

   exec_list_validate(&instr->srcs);
   nir_foreach_phi_src(instr, src) {
      if (src->pred == pred) {
         assert(src->src.is_ssa);
         assert(src->src.ssa->num_components ==
                instr->dest.ssa.num_components);

         validate_src(&src->src, state);
         state->instr = NULL;
         return;
      }
   }

   abort();
}

static void
validate_phi_srcs(nir_block *block, nir_block *succ, validate_state *state)
{
   nir_foreach_instr(succ, instr) {
      if (instr->type != nir_instr_type_phi)
         break;

      validate_phi_src(nir_instr_as_phi(instr), block, state);
   }
}

static void validate_cf_node(nir_cf_node *node, validate_state *state);

static void
validate_block(nir_block *block, validate_state *state)
{
   assert(block->cf_node.parent == state->parent_node);

   state->block = block;

   exec_list_validate(&block->instr_list);
   nir_foreach_instr(block, instr) {
      if (instr->type == nir_instr_type_phi) {
         assert(instr == nir_block_first_instr(block) ||
                nir_instr_prev(instr)->type == nir_instr_type_phi);
      }

      if (instr->type == nir_instr_type_jump) {
         assert(instr == nir_block_last_instr(block));
      }

      validate_instr(instr, state);
   }

   assert(block->successors[0] != NULL);
   assert(block->successors[0] != block->successors[1]);

   for (unsigned i = 0; i < 2; i++) {
      if (block->successors[i] != NULL) {
         struct set_entry *entry =
            _mesa_set_search(block->successors[i]->predecessors, block);
         assert(entry);

         validate_phi_srcs(block, block->successors[i], state);
      }
   }

   struct set_entry *entry;
   set_foreach(block->predecessors, entry) {
      const nir_block *pred = entry->key;
      assert(pred->successors[0] == block ||
             pred->successors[1] == block);
   }

   if (!exec_list_is_empty(&block->instr_list) &&
       nir_block_last_instr(block)->type == nir_instr_type_jump) {
      assert(block->successors[1] == NULL);
      nir_jump_instr *jump = nir_instr_as_jump(nir_block_last_instr(block));
      switch (jump->type) {
      case nir_jump_break: {
         nir_block *after =
            nir_cf_node_as_block(nir_cf_node_next(&state->loop->cf_node));
         assert(block->successors[0] == after);
         break;
      }

      case nir_jump_continue: {
         nir_block *first =
            nir_cf_node_as_block(nir_loop_first_cf_node(state->loop));
         assert(block->successors[0] == first);
         break;
      }

      case nir_jump_return:
         assert(block->successors[0] == state->impl->end_block);
         break;

      default:
         unreachable("bad jump type");
      }
   } else {
      nir_cf_node *next = nir_cf_node_next(&block->cf_node);
      if (next == NULL) {
         switch (state->parent_node->type) {
         case nir_cf_node_loop: {
            nir_block *first =
               nir_cf_node_as_block(nir_loop_first_cf_node(state->loop));
            assert(block->successors[0] == first);
            /* due to the hack for infinite loops, block->successors[1] may
             * point to the block after the loop.
             */
            break;
         }

         case nir_cf_node_if: {
            nir_block *after =
               nir_cf_node_as_block(nir_cf_node_next(state->parent_node));
            assert(block->successors[0] == after);
            assert(block->successors[1] == NULL);
            break;
         }

         case nir_cf_node_function:
            assert(block->successors[0] == state->impl->end_block);
            assert(block->successors[1] == NULL);
            break;

         default:
            unreachable("unknown control flow node type");
         }
      } else {
         if (next->type == nir_cf_node_if) {
            nir_if *if_stmt = nir_cf_node_as_if(next);
            assert(&block->successors[0]->cf_node ==
                   nir_if_first_then_node(if_stmt));
            assert(&block->successors[1]->cf_node ==
                   nir_if_first_else_node(if_stmt));
         } else {
            assert(next->type == nir_cf_node_loop);
            nir_loop *loop = nir_cf_node_as_loop(next);
            assert(&block->successors[0]->cf_node ==
                   nir_loop_first_cf_node(loop));
            assert(block->successors[1] == NULL);
         }
      }
   }
}

static void
validate_if(nir_if *if_stmt, validate_state *state)
{
   state->if_stmt = if_stmt;

   assert(!exec_node_is_head_sentinel(if_stmt->cf_node.node.prev));
   nir_cf_node *prev_node = nir_cf_node_prev(&if_stmt->cf_node);
   assert(prev_node->type == nir_cf_node_block);

   assert(!exec_node_is_tail_sentinel(if_stmt->cf_node.node.next));
   nir_cf_node *next_node = nir_cf_node_next(&if_stmt->cf_node);
   assert(next_node->type == nir_cf_node_block);

   validate_src(&if_stmt->condition, state);

   assert(!exec_list_is_empty(&if_stmt->then_list));
   assert(!exec_list_is_empty(&if_stmt->else_list));

   nir_cf_node *old_parent = state->parent_node;
   state->parent_node = &if_stmt->cf_node;

   exec_list_validate(&if_stmt->then_list);
   foreach_list_typed(nir_cf_node, cf_node, node, &if_stmt->then_list) {
      validate_cf_node(cf_node, state);
   }

   exec_list_validate(&if_stmt->else_list);
   foreach_list_typed(nir_cf_node, cf_node, node, &if_stmt->else_list) {
      validate_cf_node(cf_node, state);
   }

   state->parent_node = old_parent;
   state->if_stmt = NULL;
}

static void
validate_loop(nir_loop *loop, validate_state *state)
{
   assert(!exec_node_is_head_sentinel(loop->cf_node.node.prev));
   nir_cf_node *prev_node = nir_cf_node_prev(&loop->cf_node);
   assert(prev_node->type == nir_cf_node_block);

   assert(!exec_node_is_tail_sentinel(loop->cf_node.node.next));
   nir_cf_node *next_node = nir_cf_node_next(&loop->cf_node);
   assert(next_node->type == nir_cf_node_block);

   assert(!exec_list_is_empty(&loop->body));

   nir_cf_node *old_parent = state->parent_node;
   state->parent_node = &loop->cf_node;
   nir_loop *old_loop = state->loop;
   state->loop = loop;

   exec_list_validate(&loop->body);
   foreach_list_typed(nir_cf_node, cf_node, node, &loop->body) {
      validate_cf_node(cf_node, state);
   }

   state->parent_node = old_parent;
   state->loop = old_loop;
}

static void
validate_cf_node(nir_cf_node *node, validate_state *state)
{
   assert(node->parent == state->parent_node);

   switch (node->type) {
   case nir_cf_node_block:
      validate_block(nir_cf_node_as_block(node), state);
      break;

   case nir_cf_node_if:
      validate_if(nir_cf_node_as_if(node), state);
      break;

   case nir_cf_node_loop:
      validate_loop(nir_cf_node_as_loop(node), state);
      break;

   default:
      unreachable("Invalid CF node type");
   }
}

static void
prevalidate_reg_decl(nir_register *reg, bool is_global, validate_state *state)
{
   assert(reg->is_global == is_global);

   if (is_global)
      assert(reg->index < state->shader->reg_alloc);
   else
      assert(reg->index < state->impl->reg_alloc);
   assert(!BITSET_TEST(state->regs_found, reg->index));
   BITSET_SET(state->regs_found, reg->index);

   list_validate(&reg->uses);
   list_validate(&reg->defs);
   list_validate(&reg->if_uses);

   reg_validate_state *reg_state = ralloc(state->regs, reg_validate_state);
   reg_state->uses = _mesa_set_create(reg_state, _mesa_hash_pointer,
                                      _mesa_key_pointer_equal);
   reg_state->if_uses = _mesa_set_create(reg_state, _mesa_hash_pointer,
                                         _mesa_key_pointer_equal);
   reg_state->defs = _mesa_set_create(reg_state, _mesa_hash_pointer,
                                      _mesa_key_pointer_equal);

   reg_state->where_defined = is_global ? NULL : state->impl;

   _mesa_hash_table_insert(state->regs, reg, reg_state);
}

static void
postvalidate_reg_decl(nir_register *reg, validate_state *state)
{
   struct hash_entry *entry = _mesa_hash_table_search(state->regs, reg);

   reg_validate_state *reg_state = (reg_validate_state *) entry->data;

   nir_foreach_use(reg, src) {
      struct set_entry *entry = _mesa_set_search(reg_state->uses, src);
      assert(entry);
      _mesa_set_remove(reg_state->uses, entry);
   }

   if (reg_state->uses->entries != 0) {
      printf("extra entries in register uses:\n");
      struct set_entry *entry;
      set_foreach(reg_state->uses, entry)
         printf("%p\n", entry->key);

      abort();
   }

   nir_foreach_if_use(reg, src) {
      struct set_entry *entry = _mesa_set_search(reg_state->if_uses, src);
      assert(entry);
      _mesa_set_remove(reg_state->if_uses, entry);
   }

   if (reg_state->if_uses->entries != 0) {
      printf("extra entries in register if_uses:\n");
      struct set_entry *entry;
      set_foreach(reg_state->if_uses, entry)
         printf("%p\n", entry->key);

      abort();
   }

   nir_foreach_def(reg, src) {
      struct set_entry *entry = _mesa_set_search(reg_state->defs, src);
      assert(entry);
      _mesa_set_remove(reg_state->defs, entry);
   }

   if (reg_state->defs->entries != 0) {
      printf("extra entries in register defs:\n");
      struct set_entry *entry;
      set_foreach(reg_state->defs, entry)
         printf("%p\n", entry->key);

      abort();
   }
}

static void
validate_var_decl(nir_variable *var, bool is_global, validate_state *state)
{
   assert(is_global != (var->data.mode == nir_var_local));

   /*
    * TODO validate some things ir_validate.cpp does (requires more GLSL type
    * support)
    */

   if (!is_global) {
      _mesa_hash_table_insert(state->var_defs, var, state->impl);
   }
}

static bool
postvalidate_ssa_def(nir_ssa_def *def, void *void_state)
{
   validate_state *state = void_state;

   struct hash_entry *entry = _mesa_hash_table_search(state->ssa_defs, def);
   ssa_def_validate_state *def_state = (ssa_def_validate_state *)entry->data;

   nir_foreach_use(def, src) {
      struct set_entry *entry = _mesa_set_search(def_state->uses, src);
      assert(entry);
      _mesa_set_remove(def_state->uses, entry);
   }

   if (def_state->uses->entries != 0) {
      printf("extra entries in register uses:\n");
      struct set_entry *entry;
      set_foreach(def_state->uses, entry)
         printf("%p\n", entry->key);

      abort();
   }

   nir_foreach_if_use(def, src) {
      struct set_entry *entry = _mesa_set_search(def_state->if_uses, src);
      assert(entry);
      _mesa_set_remove(def_state->if_uses, entry);
   }

   if (def_state->if_uses->entries != 0) {
      printf("extra entries in register uses:\n");
      struct set_entry *entry;
      set_foreach(def_state->if_uses, entry)
         printf("%p\n", entry->key);

      abort();
   }

   return true;
}

static bool
postvalidate_ssa_defs_block(nir_block *block, void *state)
{
   nir_foreach_instr(block, instr)
      nir_foreach_ssa_def(instr, postvalidate_ssa_def, state);

   return true;
}

static void
validate_function_impl(nir_function_impl *impl, validate_state *state)
{
   assert(impl->function->impl == impl);
   assert(impl->cf_node.parent == NULL);

   assert(impl->num_params == impl->function->num_params);
   for (unsigned i = 0; i < impl->num_params; i++)
      assert(impl->params[i]->type == impl->function->params[i].type);

   if (glsl_type_is_void(impl->function->return_type))
      assert(impl->return_var == NULL);
   else
      assert(impl->return_var->type == impl->function->return_type);

   assert(exec_list_is_empty(&impl->end_block->instr_list));
   assert(impl->end_block->successors[0] == NULL);
   assert(impl->end_block->successors[1] == NULL);

   state->impl = impl;
   state->parent_node = &impl->cf_node;

   exec_list_validate(&impl->locals);
   nir_foreach_variable(var, &impl->locals) {
      validate_var_decl(var, false, state);
   }

   state->regs_found = realloc(state->regs_found,
                               BITSET_WORDS(impl->reg_alloc) *
                               sizeof(BITSET_WORD));
   memset(state->regs_found, 0, BITSET_WORDS(impl->reg_alloc) *
                                sizeof(BITSET_WORD));
   exec_list_validate(&impl->registers);
   foreach_list_typed(nir_register, reg, node, &impl->registers) {
      prevalidate_reg_decl(reg, false, state);
   }

   state->ssa_defs_found = realloc(state->ssa_defs_found,
                                   BITSET_WORDS(impl->ssa_alloc) *
                                   sizeof(BITSET_WORD));
   memset(state->ssa_defs_found, 0, BITSET_WORDS(impl->ssa_alloc) *
                                    sizeof(BITSET_WORD));
   exec_list_validate(&impl->body);
   foreach_list_typed(nir_cf_node, node, node, &impl->body) {
      validate_cf_node(node, state);
   }

   foreach_list_typed(nir_register, reg, node, &impl->registers) {
      postvalidate_reg_decl(reg, state);
   }

   nir_foreach_block(impl, postvalidate_ssa_defs_block, state);
}

static void
validate_function(nir_function *func, validate_state *state)
{
   if (func->impl != NULL) {
      assert(func->impl->function == func);
      validate_function_impl(func->impl, state);
   }
}

static void
init_validate_state(validate_state *state)
{
   state->regs = _mesa_hash_table_create(NULL, _mesa_hash_pointer,
                                         _mesa_key_pointer_equal);
   state->ssa_defs = _mesa_hash_table_create(NULL, _mesa_hash_pointer,
                                             _mesa_key_pointer_equal);
   state->ssa_defs_found = NULL;
   state->regs_found = NULL;
   state->var_defs = _mesa_hash_table_create(NULL, _mesa_hash_pointer,
                                             _mesa_key_pointer_equal);
   state->loop = NULL;
}

static void
destroy_validate_state(validate_state *state)
{
   _mesa_hash_table_destroy(state->regs, NULL);
   _mesa_hash_table_destroy(state->ssa_defs, NULL);
   free(state->ssa_defs_found);
   free(state->regs_found);
   _mesa_hash_table_destroy(state->var_defs, NULL);
}

void
nir_validate_shader(nir_shader *shader)
{
   validate_state state;
   init_validate_state(&state);

   state.shader = shader;

   exec_list_validate(&shader->uniforms);
   nir_foreach_variable(var, &shader->uniforms) {
      validate_var_decl(var, true, &state);
   }

   exec_list_validate(&shader->inputs);
   nir_foreach_variable(var, &shader->inputs) {
     validate_var_decl(var, true, &state);
   }

   exec_list_validate(&shader->outputs);
   nir_foreach_variable(var, &shader->outputs) {
     validate_var_decl(var, true, &state);
   }

   exec_list_validate(&shader->globals);
   nir_foreach_variable(var, &shader->globals) {
     validate_var_decl(var, true, &state);
   }

   exec_list_validate(&shader->system_values);
   nir_foreach_variable(var, &shader->system_values) {
     validate_var_decl(var, true, &state);
   }

   state.regs_found = realloc(state.regs_found,
                              BITSET_WORDS(shader->reg_alloc) *
                              sizeof(BITSET_WORD));
   memset(state.regs_found, 0, BITSET_WORDS(shader->reg_alloc) *
                               sizeof(BITSET_WORD));
   exec_list_validate(&shader->registers);
   foreach_list_typed(nir_register, reg, node, &shader->registers) {
      prevalidate_reg_decl(reg, true, &state);
   }

   exec_list_validate(&shader->functions);
   foreach_list_typed(nir_function, func, node, &shader->functions) {
      validate_function(func, &state);
   }

   foreach_list_typed(nir_register, reg, node, &shader->registers) {
      postvalidate_reg_decl(reg, &state);
   }

   destroy_validate_state(&state);
}

#endif /* NDEBUG */
@


1.1.1.1
log
@Import Mesa 11.2.2
@
text
@@


1.1.1.2
log
@Import Mesa 13.0.2
@
text
@a71 3
   /* the current variable being validated */
   nir_variable *var;

a97 3

   /* map of instruction/var/etc to failed assert string */
   struct hash_table *errors;
a99 23
static void
log_error(validate_state *state, const char *cond, const char *file, int line)
{
   const void *obj;

   if (state->instr)
      obj = state->instr;
   else if (state->var)
      obj = state->var;
   else
      obj = cond;

   char *msg = ralloc_asprintf(state->errors, "error: %s (%s:%d)",
                               cond, file, line);

   _mesa_hash_table_insert(state->errors, obj, msg);
}

#define validate_assert(state, cond) do {             \
      if (!(cond))                                    \
         log_error(state, #cond, __FILE__, __LINE__); \
   } while (0)

d105 1
a105 1
   validate_assert(state, src->reg.reg != NULL);
d109 1
a109 1
   validate_assert(state, entry);
d116 1
a116 1
      validate_assert(state, state->if_stmt);
d121 1
a121 1
      validate_assert(state, reg_state->where_defined == state->impl &&
d125 1
a125 1
   validate_assert(state, (src->reg.reg->num_array_elems == 0 ||
d130 2
a131 2
      validate_assert(state, src->reg.reg->num_array_elems != 0);
      validate_assert(state, (src->reg.indirect->is_ssa ||
d141 1
a141 1
   validate_assert(state, src->ssa != NULL);
d145 1
a145 4
   validate_assert(state, entry);

   if (!entry)
      return;
d149 1
a149 1
   validate_assert(state, def_state->where_defined == state->impl &&
d155 1
a155 1
      validate_assert(state, state->if_stmt);
d166 1
a166 1
      validate_assert(state, src->parent_instr == state->instr);
d168 1
a168 1
      validate_assert(state, src->parent_if == state->if_stmt);
d182 1
a182 3
   unsigned src_bit_size;
   if (src->src.is_ssa) {
      src_bit_size = src->src.ssa->bit_size;
d184 1
a184 2
   } else {
      src_bit_size = src->src.reg.reg->bit_size;
d191 1
a191 1
      validate_assert(state, src->swizzle[i] < 4);
d194 1
a194 19
         validate_assert(state, src->swizzle[i] < num_components);
   }

   nir_alu_type src_type = nir_op_infos[instr->op].input_types[index];

   /* 8-bit float isn't a thing */
   if (nir_alu_type_get_base_type(src_type) == nir_type_float)
      validate_assert(state, src_bit_size == 16 || src_bit_size == 32 || src_bit_size == 64);

   if (nir_alu_type_get_type_size(src_type)) {
      /* This source has an explicit bit size */
      validate_assert(state, nir_alu_type_get_type_size(src_type) == src_bit_size);
   } else {
      if (!nir_alu_type_get_type_size(nir_op_infos[instr->op].output_type)) {
         unsigned dest_bit_size =
            instr->dest.dest.is_ssa ? instr->dest.dest.ssa.bit_size
                                    : instr->dest.dest.reg.reg->bit_size;
         validate_assert(state, dest_bit_size == src_bit_size);
      }
d203 1
a203 1
   validate_assert(state, dest->reg != NULL);
d205 1
a205 1
   validate_assert(state, dest->parent_instr == state->instr);
d210 1
a210 1
   validate_assert(state, entry2);
d216 1
a216 1
      validate_assert(state, reg_state->where_defined == state->impl &&
d220 1
a220 1
   validate_assert(state, (dest->reg->num_array_elems == 0 ||
d225 2
a226 2
      validate_assert(state, dest->reg->num_array_elems != 0);
      validate_assert(state, (dest->indirect->is_ssa || dest->indirect->reg.indirect == NULL) &&
d235 2
a236 2
   validate_assert(state, def->index < state->impl->ssa_alloc);
   validate_assert(state, !BITSET_TEST(state->ssa_defs_found, def->index));
d239 1
a239 1
   validate_assert(state, def->parent_instr == state->instr);
d241 1
a241 1
   validate_assert(state, def->num_components <= 4);
d266 1
a266 1
validate_alu_dest(nir_alu_instr *instr, validate_state *state)
a267 2
   nir_alu_dest *dest = &instr->dest;

d276 1
a276 1
   validate_assert(state, is_packed || !(dest->write_mask & ~((1 << dest_size) - 1)));
d282 1
a282 3
   validate_assert(state,
          (nir_alu_type_get_base_type(nir_op_infos[alu->op].output_type) ==
           nir_type_float) ||
a284 11
   unsigned bit_size = dest->dest.is_ssa ? dest->dest.ssa.bit_size
                                         : dest->dest.reg.reg->bit_size;
   nir_alu_type type = nir_op_infos[instr->op].output_type;

   /* 8-bit float isn't a thing */
   if (nir_alu_type_get_base_type(type) == nir_type_float)
      validate_assert(state, bit_size == 16 || bit_size == 32 || bit_size == 64);

   validate_assert(state, nir_alu_type_get_type_size(type) == 0 ||
          nir_alu_type_get_type_size(type) == bit_size);

d291 1
a291 1
   validate_assert(state, instr->op < nir_num_opcodes);
d297 1
a297 1
   validate_alu_dest(instr, state);
d303 1
a303 1
   validate_assert(state, deref->child == NULL || ralloc_parent(deref->child) == deref);
d309 1
a309 1
         validate_assert(state, deref->type == glsl_get_array_element(parent->type));
d316 1
a316 2
         assume(parent); /* cannot happen: deref change starts w/ nir_deref_var */
         validate_assert(state, deref->type ==
d325 1
a325 1
         validate_assert(state, !"Invalid deref type");
d340 2
a341 2
      validate_assert(state, entry);
      validate_assert(state, (nir_function_impl *) entry->data == state->impl);
d348 3
a350 3
   validate_assert(state, deref != NULL);
   validate_assert(state, ralloc_parent(deref) == parent_mem_ctx);
   validate_assert(state, deref->deref.type == deref->var->type);
d367 1
a367 1
      validate_assert(state, components_read > 0);
d370 1
a370 1
         validate_assert(state, components_read <= instr->src[i].ssa->num_components);
d372 1
a372 1
         validate_assert(state, components_read <= instr->src[i].reg.reg->num_components);
d389 1
a389 1
      validate_assert(state, components_written > 0);
d392 1
a392 1
         validate_assert(state, components_written <= instr->dest.ssa.num_components);
d394 1
a394 1
         validate_assert(state, components_written <= instr->dest.reg.reg->num_components);
d404 1
a404 1
      validate_assert(state, glsl_type_is_vector_or_scalar(type) ||
d407 1
a407 1
      validate_assert(state, instr->num_components == glsl_get_vector_elements(type));
d413 1
a413 1
      validate_assert(state, glsl_type_is_vector_or_scalar(type) ||
d416 2
a417 2
      validate_assert(state, instr->num_components == glsl_get_vector_elements(type));
      validate_assert(state, instr->variables[0]->var->data.mode != nir_var_shader_in &&
d420 1
a420 1
      validate_assert(state, (nir_intrinsic_write_mask(instr) & ~((1 << instr->num_components) - 1)) == 0);
d424 1
a424 1
      validate_assert(state, nir_deref_tail(&instr->variables[0]->deref)->type ==
d426 1
a426 1
      validate_assert(state, instr->variables[0]->var->data.mode != nir_var_shader_in &&
d443 1
a443 1
      validate_assert(state, !src_type_seen[instr->src[i].src_type]);
d460 4
a463 6
   if (instr->return_deref == NULL) {
      validate_assert(state, glsl_type_is_void(instr->callee->return_type));
   } else {
      validate_assert(state, instr->return_deref->deref.type == instr->callee->return_type);
      validate_deref_var(instr, instr->return_deref, state);
   }
d465 1
a465 1
   validate_assert(state, instr->num_params == instr->callee->num_params);
d468 1
a468 1
      validate_assert(state, instr->callee->params[i].type == instr->params[i]->deref.type);
d471 2
d498 1
a498 1
   validate_assert(state, exec_list_length(&instr->srcs) ==
d505 1
a505 1
   validate_assert(state, instr->block == state->block);
d542 1
a542 1
      validate_assert(state, !"Invalid ALU instruction type");
d554 1
a554 1
   validate_assert(state, instr->dest.is_ssa);
d557 1
a557 1
   nir_foreach_phi_src(src, instr) {
d559 2
a560 2
         validate_assert(state, src->src.is_ssa);
         validate_assert(state, src->src.ssa->num_components ==
d575 1
a575 1
   nir_foreach_instr(instr, succ) {
d588 1
a588 1
   validate_assert(state, block->cf_node.parent == state->parent_node);
d593 1
a593 1
   nir_foreach_instr(instr, block) {
d595 1
a595 1
         validate_assert(state, instr == nir_block_first_instr(block) ||
d600 1
a600 1
         validate_assert(state, instr == nir_block_last_instr(block));
d606 2
a607 2
   validate_assert(state, block->successors[0] != NULL);
   validate_assert(state, block->successors[0] != block->successors[1]);
d613 1
a613 1
         validate_assert(state, entry);
d622 1
a622 1
      validate_assert(state, pred->successors[0] == block ||
d628 1
a628 1
      validate_assert(state, block->successors[1] == NULL);
d634 1
a634 1
         validate_assert(state, block->successors[0] == after);
d639 3
a641 2
         nir_block *first = nir_loop_first_block(state->loop);
         validate_assert(state, block->successors[0] == first);
d646 1
a646 1
         validate_assert(state, block->successors[0] == state->impl->end_block);
d657 3
a659 2
            nir_block *first = nir_loop_first_block(state->loop);
            validate_assert(state, block->successors[0] == first);
d669 2
a670 2
            validate_assert(state, block->successors[0] == after);
            validate_assert(state, block->successors[1] == NULL);
d675 2
a676 2
            validate_assert(state, block->successors[0] == state->impl->end_block);
            validate_assert(state, block->successors[1] == NULL);
d685 4
a688 4
            validate_assert(state, block->successors[0] ==
                   nir_if_first_then_block(if_stmt));
            validate_assert(state, block->successors[1] ==
                   nir_if_first_else_block(if_stmt));
d690 1
a690 1
            validate_assert(state, next->type == nir_cf_node_loop);
d692 3
a694 3
            validate_assert(state, block->successors[0] ==
                   nir_loop_first_block(loop));
            validate_assert(state, block->successors[1] == NULL);
d705 1
a705 1
   validate_assert(state, !exec_node_is_head_sentinel(if_stmt->cf_node.node.prev));
d707 1
a707 1
   validate_assert(state, prev_node->type == nir_cf_node_block);
d709 1
a709 1
   validate_assert(state, !exec_node_is_tail_sentinel(if_stmt->cf_node.node.next));
d711 1
a711 1
   validate_assert(state, next_node->type == nir_cf_node_block);
d715 2
a716 2
   validate_assert(state, !exec_list_is_empty(&if_stmt->then_list));
   validate_assert(state, !exec_list_is_empty(&if_stmt->else_list));
d738 1
a738 1
   validate_assert(state, !exec_node_is_head_sentinel(loop->cf_node.node.prev));
d740 1
a740 1
   validate_assert(state, prev_node->type == nir_cf_node_block);
d742 1
a742 1
   validate_assert(state, !exec_node_is_tail_sentinel(loop->cf_node.node.next));
d744 1
a744 1
   validate_assert(state, next_node->type == nir_cf_node_block);
d746 1
a746 1
   validate_assert(state, !exec_list_is_empty(&loop->body));
d765 1
a765 1
   validate_assert(state, node->parent == state->parent_node);
d788 1
a788 1
   validate_assert(state, reg->is_global == is_global);
d791 1
a791 1
      validate_assert(state, reg->index < state->shader->reg_alloc);
d793 2
a794 2
      validate_assert(state, reg->index < state->impl->reg_alloc);
   validate_assert(state, !BITSET_TEST(state->regs_found, reg->index));
a818 1
   assume(entry);
d821 1
a821 1
   nir_foreach_use(src, reg) {
d823 1
a823 1
      validate_assert(state, entry);
d836 1
a836 1
   nir_foreach_if_use(src, reg) {
d838 1
a838 1
      validate_assert(state, entry);
d851 1
a851 1
   nir_foreach_def(src, reg) {
d853 1
a853 1
      validate_assert(state, entry);
d870 1
a870 6
   state->var = var;

   validate_assert(state, is_global == nir_variable_is_global(var));

   /* Must have exactly one mode set */
   validate_assert(state, util_bitcount(var->data.mode) == 1);
a879 2

   state->var = NULL;
a887 2

   assume(entry);
d890 1
a890 1
   nir_foreach_use(src, def) {
d892 1
a892 1
      validate_assert(state, entry);
d897 1
a897 1
      printf("extra entries in SSA def uses:\n");
d905 1
a905 1
   nir_foreach_if_use(src, def) {
d907 1
a907 1
      validate_assert(state, entry);
d912 1
a912 1
      printf("extra entries in SSA def uses:\n");
d923 9
d935 2
a936 2
   validate_assert(state, impl->function->impl == impl);
   validate_assert(state, impl->cf_node.parent == NULL);
d938 3
a940 7
   validate_assert(state, impl->num_params == impl->function->num_params);
   for (unsigned i = 0; i < impl->num_params; i++) {
      validate_assert(state, impl->params[i]->type == impl->function->params[i].type);
      validate_assert(state, impl->params[i]->data.mode == nir_var_param);
      validate_assert(state, impl->params[i]->data.location == i);
      validate_var_decl(impl->params[i], false, state);
   }
d942 4
a945 8
   if (glsl_type_is_void(impl->function->return_type)) {
      validate_assert(state, impl->return_var == NULL);
   } else {
      validate_assert(state, impl->return_var->type == impl->function->return_type);
      validate_assert(state, impl->return_var->data.mode == nir_var_param);
      validate_assert(state, impl->return_var->data.location == -1);
      validate_var_decl(impl->return_var, false, state);
   }
d947 3
a949 3
   validate_assert(state, exec_list_is_empty(&impl->end_block->instr_list));
   validate_assert(state, impl->end_block->successors[0] == NULL);
   validate_assert(state, impl->end_block->successors[1] == NULL);
d983 1
a983 4
   nir_foreach_block(block, impl) {
      nir_foreach_instr(instr, block)
         nir_foreach_ssa_def(instr, postvalidate_ssa_def, state);
   }
d990 1
a990 1
      validate_assert(state, func->impl->function == func);
a1005 3
   state->errors = _mesa_hash_table_create(NULL, _mesa_hash_pointer,
                                           _mesa_key_pointer_equal);

a1006 2
   state->instr = NULL;
   state->var = NULL;
a1016 22
   _mesa_hash_table_destroy(state->errors, NULL);
}

static void
dump_errors(validate_state *state)
{
   struct hash_table *errors = state->errors;

   fprintf(stderr, "%d errors:\n", _mesa_hash_table_num_entries(errors));

   nir_print_shader_annotated(state->shader, stderr, errors);

   if (_mesa_hash_table_num_entries(errors) > 0) {
      fprintf(stderr, "%d additional errors:\n",
              _mesa_hash_table_num_entries(errors));
      struct hash_entry *entry;
      hash_table_foreach(errors, entry) {
         fprintf(stderr, "%s\n", (char *)entry->data);
      }
   }

   abort();
a1021 6
   static int should_validate = -1;
   if (should_validate < 0)
      should_validate = env_var_as_boolean("NIR_VALIDATE", true);
   if (!should_validate)
      return;

a1041 5
   exec_list_validate(&shader->shared);
   nir_foreach_variable(var, &shader->shared) {
      validate_var_decl(var, true, &state);
   }

a1069 3

   if (_mesa_hash_table_num_entries(state.errors) > 0)
      dump_errors(&state);
@


1.1.1.3
log
@Import Mesa 17.1.6
@
text
@d129 1
a129 2
static void validate_src(nir_src *src, validate_state *state,
                         unsigned bit_size, unsigned num_components);
d132 1
a132 2
validate_reg_src(nir_src *src, validate_state *state,
                 unsigned bit_size, unsigned num_components)
a153 7
   if (!src->reg.reg->is_packed) {
      if (bit_size)
         validate_assert(state, src->reg.reg->bit_size == bit_size);
      if (num_components)
         validate_assert(state, src->reg.reg->num_components == num_components);
   }

d163 1
a163 1
      validate_src(src->reg.indirect, state, 32, 1);
d168 1
a168 2
validate_ssa_src(nir_src *src, validate_state *state,
                 unsigned bit_size, unsigned num_components)
a190 5
   if (bit_size)
      validate_assert(state, src->ssa->bit_size == bit_size);
   if (num_components)
      validate_assert(state, src->ssa->num_components == num_components);

d195 1
a195 2
validate_src(nir_src *src, validate_state *state,
             unsigned bit_size, unsigned num_components)
d203 1
a203 1
      validate_ssa_src(src, state, bit_size, num_components);
d205 1
a205 1
      validate_reg_src(src, state, bit_size, num_components);
d214 1
d216 1
d219 1
d232 19
a250 1
   validate_src(&src->src, state, 0, 0);
d254 1
a254 2
validate_reg_dest(nir_reg_dest *dest, validate_state *state,
                  unsigned bit_size, unsigned num_components)
a272 7
   if (!dest->reg->is_packed) {
      if (bit_size)
         validate_assert(state, dest->reg->bit_size == bit_size);
      if (num_components)
         validate_assert(state, dest->reg->num_components == num_components);
   }

d281 1
a281 1
      validate_src(dest->indirect, state, 32, 1);
d310 1
a310 2
validate_dest(nir_dest *dest, validate_state *state,
              unsigned bit_size, unsigned num_components)
d312 1
a312 5
   if (dest->is_ssa) {
      if (bit_size)
         validate_assert(state, dest->ssa.bit_size == bit_size);
      if (num_components)
         validate_assert(state, dest->ssa.num_components == num_components);
d314 2
a315 3
   } else {
      validate_reg_dest(&dest->reg, state, bit_size, num_components);
   }
d342 12
a353 1
   validate_dest(&dest->dest, state, 0, 0);
a360 1
   unsigned instr_bit_size = 0;
a361 16
      nir_alu_type src_type = nir_op_infos[instr->op].input_types[i];
      unsigned src_bit_size = nir_src_bit_size(instr->src[i].src);
      if (nir_alu_type_get_type_size(src_type)) {
         validate_assert(state, src_bit_size == nir_alu_type_get_type_size(src_type));
      } else if (instr_bit_size) {
         validate_assert(state, src_bit_size == instr_bit_size);
      } else {
         instr_bit_size = src_bit_size;
      }

      if (nir_alu_type_get_base_type(src_type) == nir_type_float) {
         /* 8-bit float isn't a thing */
         validate_assert(state, src_bit_size == 16 || src_bit_size == 32 ||
                                src_bit_size == 64);
      }

a364 16
   nir_alu_type dest_type = nir_op_infos[instr->op].output_type;
   unsigned dest_bit_size = nir_dest_bit_size(instr->dest.dest);
   if (nir_alu_type_get_type_size(dest_type)) {
      validate_assert(state, dest_bit_size == nir_alu_type_get_type_size(dest_type));
   } else if (instr_bit_size) {
      validate_assert(state, dest_bit_size == instr_bit_size);
   } else {
      /* The only unsized thing is the destination so it's vacuously valid */
   }

   if (nir_alu_type_get_base_type(dest_type) == nir_type_float) {
      /* 8-bit float isn't a thing */
      validate_assert(state, dest_bit_size == 16 || dest_bit_size == 32 ||
                             dest_bit_size == 64);
   }

d380 1
a380 1
            validate_src(&nir_deref_as_array(deref)->indirect, state, 32, 1);
a428 8
   unsigned bit_size = 0;
   if (instr->intrinsic == nir_intrinsic_load_var ||
       instr->intrinsic == nir_intrinsic_store_var) {
      const struct glsl_type *type =
         nir_deref_tail(&instr->variables[0]->deref)->type;
      bit_size = glsl_get_bit_size(type);
   }

d438 7
a444 1
      validate_src(&instr->src[i], state, bit_size, components_read);
d460 7
a466 1
      validate_dest(&instr->dest, state, bit_size, components_written);
d514 1
a514 2
      validate_src(&instr->src[i].src, state,
                   0, nir_tex_instr_src_size(instr, i));
d523 1
a523 1
   validate_dest(&instr->dest, state, 0, nir_tex_instr_dest_size(instr));
d564 1
a564 1
   validate_dest(&instr->dest, state, 0, 0);
d629 4
a632 2
         validate_src(&src->src, state, instr->dest.ssa.bit_size,
                      instr->dest.ssa.num_components);
d780 1
a780 1
   validate_src(&if_stmt->condition, state, 32, 1);
a943 13

   if (var->data.compact) {
      /* The "compact" flag is only valid on arrays of scalars. */
      assert(glsl_type_is_array(var->type));

      const struct glsl_type *type = glsl_get_array_element(var->type);
      if (nir_is_per_vertex_io(var, state->shader->stage)) {
         assert(glsl_type_is_array(type));
         assert(glsl_type_is_scalar(glsl_get_array_element(type)));
      } else {
         assert(glsl_type_is_scalar(type));
      }
   }
@


