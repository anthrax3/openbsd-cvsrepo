head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	mesa-17_1_6:1.1.1.3
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	mesa-13_0_6:1.1.1.2
	mesa-13_0_5:1.1.1.2
	mesa-13_0_3:1.1.1.2
	mesa-13_0_2:1.1.1.2
	OPENBSD_6_0:1.1.1.1.0.4
	OPENBSD_6_0_BASE:1.1.1.1
	mesa-11_2_2:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.08.26.16.59.21;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2016.05.29.10.16.30;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.1
date	2016.05.29.10.16.30;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.2
date	2016.12.11.08.33.40;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	uuv5VTS15jglEDZU;

1.1.1.3
date	2017.08.14.09.38.24;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Copyright Â© 2014 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Jason Ekstrand (jason@@jlekstrand.net)
 *
 */

#include "nir.h"
#include "compiler/nir_types.h"

/*
 * Lowers all copy intrinsics to sequences of load/store intrinsics.
 */

/* Walks down the deref chain and returns the next deref in the chain whose
 * child is a wildcard.  In other words, given the chain  a[1].foo[*].bar,
 * this function will return the deref to foo.  Calling it a second time
 * with the [*].bar, it will return NULL.
 */
static nir_deref *
deref_next_wildcard_parent(nir_deref *deref)
{
   for (nir_deref *tail = deref; tail->child; tail = tail->child) {
      if (tail->child->deref_type != nir_deref_type_array)
         continue;

      nir_deref_array *arr = nir_deref_as_array(tail->child);

      if (arr->deref_array_type == nir_deref_array_type_wildcard)
         return tail;
   }

   return NULL;
}

/* This function recursively walks the given deref chain and replaces the
 * given copy instruction with an equivalent sequence load/store
 * operations.
 *
 * @@copy_instr    The copy instruction to replace; new instructions will be
 *                inserted before this one
 *
 * @@dest_head     The head of the destination variable deref chain
 *
 * @@src_head      The head of the source variable deref chain
 *
 * @@dest_tail     The current tail of the destination variable deref chain;
 *                this is used for recursion and external callers of this
 *                function should call it with tail == head
 *
 * @@src_tail      The current tail of the source variable deref chain;
 *                this is used for recursion and external callers of this
 *                function should call it with tail == head
 *
 * @@state         The current variable lowering state
 */
static void
emit_copy_load_store(nir_intrinsic_instr *copy_instr,
                     nir_deref_var *dest_head, nir_deref_var *src_head,
                     nir_deref *dest_tail, nir_deref *src_tail, void *mem_ctx)
{
   /* Find the next pair of wildcards */
   nir_deref *src_arr_parent = deref_next_wildcard_parent(src_tail);
   nir_deref *dest_arr_parent = deref_next_wildcard_parent(dest_tail);

   if (src_arr_parent || dest_arr_parent) {
      /* Wildcards had better come in matched pairs */
      assert(src_arr_parent && dest_arr_parent);

      nir_deref_array *src_arr = nir_deref_as_array(src_arr_parent->child);
      nir_deref_array *dest_arr = nir_deref_as_array(dest_arr_parent->child);

      unsigned length = glsl_get_length(src_arr_parent->type);
      /* The wildcards should represent the same number of elements */
      assert(length == glsl_get_length(dest_arr_parent->type));
      assert(length > 0);

      /* Walk over all of the elements that this wildcard refers to and
       * call emit_copy_load_store on each one of them */
      src_arr->deref_array_type = nir_deref_array_type_direct;
      dest_arr->deref_array_type = nir_deref_array_type_direct;
      for (unsigned i = 0; i < length; i++) {
         src_arr->base_offset = i;
         dest_arr->base_offset = i;
         emit_copy_load_store(copy_instr, dest_head, src_head,
                              &dest_arr->deref, &src_arr->deref, mem_ctx);
      }
      src_arr->deref_array_type = nir_deref_array_type_wildcard;
      dest_arr->deref_array_type = nir_deref_array_type_wildcard;
   } else {
      /* In this case, we have no wildcards anymore, so all we have to do
       * is just emit the load and store operations. */
      src_tail = nir_deref_tail(src_tail);
      dest_tail = nir_deref_tail(dest_tail);

      assert(src_tail->type == dest_tail->type);

      unsigned num_components = glsl_get_vector_elements(src_tail->type);
      unsigned bit_size = glsl_get_bit_size(src_tail->type);

      nir_intrinsic_instr *load =
         nir_intrinsic_instr_create(mem_ctx, nir_intrinsic_load_var);
      load->num_components = num_components;
      load->variables[0] = nir_deref_as_var(nir_copy_deref(load, &src_head->deref));
      nir_ssa_dest_init(&load->instr, &load->dest, num_components, bit_size,
                        NULL);

      nir_instr_insert_before(&copy_instr->instr, &load->instr);

      nir_intrinsic_instr *store =
         nir_intrinsic_instr_create(mem_ctx, nir_intrinsic_store_var);
      store->num_components = num_components;
      nir_intrinsic_set_write_mask(store, (1 << num_components) - 1);
      store->variables[0] = nir_deref_as_var(nir_copy_deref(store, &dest_head->deref));

      store->src[0].is_ssa = true;
      store->src[0].ssa = &load->dest.ssa;

      nir_instr_insert_before(&copy_instr->instr, &store->instr);
   }
}

/* Lowers a copy instruction to a sequence of load/store instructions
 *
 * The new instructions are placed before the copy instruction in the IR.
 */
void
nir_lower_var_copy_instr(nir_intrinsic_instr *copy, void *mem_ctx)
{
   assert(copy->intrinsic == nir_intrinsic_copy_var);
   emit_copy_load_store(copy, copy->variables[0], copy->variables[1],
                        &copy->variables[0]->deref,
                        &copy->variables[1]->deref, mem_ctx);
}

static void
lower_var_copies_impl(nir_function_impl *impl)
{
   void *mem_ctx = ralloc_parent(impl);

   nir_foreach_block(block, impl) {
      nir_foreach_instr_safe(instr, block) {
         if (instr->type != nir_instr_type_intrinsic)
            continue;

         nir_intrinsic_instr *copy = nir_instr_as_intrinsic(instr);
         if (copy->intrinsic != nir_intrinsic_copy_var)
            continue;

         nir_lower_var_copy_instr(copy, mem_ctx);

         nir_instr_remove(&copy->instr);
         ralloc_free(copy);
      }
   }
}

/* Lowers every copy_var instruction in the program to a sequence of
 * load/store instructions.
 */
void
nir_lower_var_copies(nir_shader *shader)
{
   nir_foreach_function(function, shader) {
      if (function->impl)
         lower_var_copies_impl(function->impl);
   }
}
@


1.1
log
@Initial revision
@
text
@d88 1
a88 1
      assert(dest_arr_parent && dest_arr_parent);
d119 1
d125 2
a126 1
      nir_ssa_dest_init(&load->instr, &load->dest, num_components, NULL);
d156 2
a157 2
static bool
lower_var_copies_block(nir_block *block, void *mem_ctx)
d159 1
a159 7
   nir_foreach_instr_safe(block, instr) {
      if (instr->type != nir_instr_type_intrinsic)
         continue;

      nir_intrinsic_instr *copy = nir_instr_as_intrinsic(instr);
      if (copy->intrinsic != nir_intrinsic_copy_var)
         continue;
d161 4
a164 1
      nir_lower_var_copy_instr(copy, mem_ctx);
d166 3
a168 3
      nir_instr_remove(&copy->instr);
      ralloc_free(copy);
   }
d170 1
a170 2
   return true;
}
d172 4
a175 4
static void
lower_var_copies_impl(nir_function_impl *impl)
{
   nir_foreach_block(impl, lower_var_copies_block, ralloc_parent(impl));
d184 1
a184 1
   nir_foreach_function(shader, function) {
@


1.1.1.1
log
@Import Mesa 11.2.2
@
text
@@


1.1.1.2
log
@Import Mesa 13.0.2
@
text
@d88 1
a88 1
      assert(src_arr_parent && dest_arr_parent);
a118 1
      unsigned bit_size = glsl_get_bit_size(src_tail->type);
d124 1
a124 2
      nir_ssa_dest_init(&load->instr, &load->dest, num_components, bit_size,
                        NULL);
d154 2
a155 2
static void
lower_var_copies_impl(nir_function_impl *impl)
d157 7
a163 1
   void *mem_ctx = ralloc_parent(impl);
d165 1
a165 4
   nir_foreach_block(block, impl) {
      nir_foreach_instr_safe(instr, block) {
         if (instr->type != nir_instr_type_intrinsic)
            continue;
d167 3
a169 3
         nir_intrinsic_instr *copy = nir_instr_as_intrinsic(instr);
         if (copy->intrinsic != nir_intrinsic_copy_var)
            continue;
d171 2
a172 1
         nir_lower_var_copy_instr(copy, mem_ctx);
d174 4
a177 4
         nir_instr_remove(&copy->instr);
         ralloc_free(copy);
      }
   }
d186 1
a186 1
   nir_foreach_function(function, shader) {
@


1.1.1.3
log
@Import Mesa 17.1.6
@
text
@d80 1
a80 2
                     nir_deref *dest_tail, nir_deref *src_tail,
                     nir_shader *shader)
d106 1
a106 1
                              &dest_arr->deref, &src_arr->deref, shader);
d122 1
a122 1
         nir_intrinsic_instr_create(shader, nir_intrinsic_load_var);
d124 1
a124 1
      load->variables[0] = nir_deref_var_clone(src_head, load);
d131 1
a131 1
         nir_intrinsic_instr_create(shader, nir_intrinsic_store_var);
d134 1
a134 1
      store->variables[0] = nir_deref_var_clone(dest_head, store);
d148 1
a148 1
nir_lower_var_copy_instr(nir_intrinsic_instr *copy, nir_shader *shader)
d153 1
a153 1
                        &copy->variables[1]->deref, shader);
d156 1
a156 1
static bool
d159 1
a159 2
   nir_shader *shader = impl->function->shader;
   bool progress = false;
d170 1
a170 1
         nir_lower_var_copy_instr(copy, shader);
a172 1
         progress = true;
a175 6

   if (progress)
      nir_metadata_preserve(impl, nir_metadata_block_index |
                                  nir_metadata_dominance);

   return progress;
d181 1
a181 1
bool
a183 2
   bool progress = false;

d186 1
a186 1
         progress |= lower_var_copies_impl(function->impl);
a187 2

   return progress;
@


