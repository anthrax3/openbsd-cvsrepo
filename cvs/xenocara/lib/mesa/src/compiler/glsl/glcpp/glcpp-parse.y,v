head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	mesa-17_1_6:1.1.1.3
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	mesa-13_0_6:1.1.1.2
	mesa-13_0_5:1.1.1.2
	mesa-13_0_3:1.1.1.2
	mesa-13_0_2:1.1.1.2
	OPENBSD_6_0:1.1.1.1.0.4
	OPENBSD_6_0_BASE:1.1.1.1
	mesa-11_2_2:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.08.26.16.59.20;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2016.05.29.10.17.01;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.1
date	2016.05.29.10.17.01;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.2
date	2016.12.11.08.33.30;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	uuv5VTS15jglEDZU;

1.1.1.3
date	2017.08.14.09.38.15;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@%{
/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <inttypes.h>

#include "glcpp.h"
#include "main/core.h" /* for struct gl_extensions */
#include "main/mtypes.h" /* for gl_api enum */

static void
yyerror(YYLTYPE *locp, glcpp_parser_t *parser, const char *error);

static void
_define_object_macro(glcpp_parser_t *parser,
                     YYLTYPE *loc,
                     const char *macro,
                     token_list_t *replacements);

static void
_define_function_macro(glcpp_parser_t *parser,
                       YYLTYPE *loc,
                       const char *macro,
                       string_list_t *parameters,
                       token_list_t *replacements);

static string_list_t *
_string_list_create(void *ctx);

static void
_string_list_append_item(string_list_t *list, const char *str);

static int
_string_list_contains(string_list_t *list, const char *member, int *index);

static const char *
_string_list_has_duplicate(string_list_t *list);

static int
_string_list_length(string_list_t *list);

static int
_string_list_equal(string_list_t *a, string_list_t *b);

static argument_list_t *
_argument_list_create(void *ctx);

static void
_argument_list_append(argument_list_t *list, token_list_t *argument);

static int
_argument_list_length(argument_list_t *list);

static token_list_t *
_argument_list_member_at(argument_list_t *list, int index);

/* Note: This function ralloc_steal()s the str pointer. */
static token_t *
_token_create_str(void *ctx, int type, char *str);

static token_t *
_token_create_ival(void *ctx, int type, int ival);

static token_list_t *
_token_list_create(void *ctx);

static void
_token_list_append(token_list_t *list, token_t *token);

static void
_token_list_append_list(token_list_t *list, token_list_t *tail);

static int
_token_list_equal_ignoring_space(token_list_t *a, token_list_t *b);

static void
_parser_active_list_push(glcpp_parser_t *parser, const char *identifier,
                         token_node_t *marker);

static void
_parser_active_list_pop(glcpp_parser_t *parser);

static int
_parser_active_list_contains(glcpp_parser_t *parser, const char *identifier);

typedef enum {
   EXPANSION_MODE_IGNORE_DEFINED,
   EXPANSION_MODE_EVALUATE_DEFINED
} expansion_mode_t;

/* Expand list, and begin lexing from the result (after first
 * prefixing a token of type 'head_token_type').
 */
static void
_glcpp_parser_expand_and_lex_from(glcpp_parser_t *parser, int head_token_type,
                                  token_list_t *list, expansion_mode_t mode);

/* Perform macro expansion in-place on the given list. */
static void
_glcpp_parser_expand_token_list(glcpp_parser_t *parser, token_list_t *list,
                                expansion_mode_t mode);

static void
_glcpp_parser_print_expanded_token_list(glcpp_parser_t *parser,
                                        token_list_t *list);

static void
_glcpp_parser_skip_stack_push_if(glcpp_parser_t *parser, YYLTYPE *loc,
                                 int condition);

static void
_glcpp_parser_skip_stack_change_if(glcpp_parser_t *parser, YYLTYPE *loc,
                                   const char *type, int condition);

static void
_glcpp_parser_skip_stack_pop(glcpp_parser_t *parser, YYLTYPE *loc);

static void
_glcpp_parser_handle_version_declaration(glcpp_parser_t *parser, intmax_t version,
                                         const char *ident, bool explicitly_set);

static int
glcpp_parser_lex(YYSTYPE *yylval, YYLTYPE *yylloc, glcpp_parser_t *parser);

static void
glcpp_parser_lex_from(glcpp_parser_t *parser, token_list_t *list);

static void
add_builtin_define(glcpp_parser_t *parser, const char *name, int value);

%}

%pure-parser
%error-verbose

%locations
%initial-action {
   @@$.first_line = 1;
   @@$.first_column = 1;
   @@$.last_line = 1;
   @@$.last_column = 1;
   @@$.source = 0;
}

%parse-param {glcpp_parser_t *parser}
%lex-param {glcpp_parser_t *parser}

%expect 0

        /* We use HASH_TOKEN, DEFINE_TOKEN and VERSION_TOKEN (as opposed to
         * HASH, DEFINE, and VERSION) to avoid conflicts with other symbols,
         * (such as the <HASH> and <DEFINE> start conditions in the lexer). */
%token DEFINED ELIF_EXPANDED HASH_TOKEN DEFINE_TOKEN FUNC_IDENTIFIER OBJ_IDENTIFIER ELIF ELSE ENDIF ERROR_TOKEN IF IFDEF IFNDEF LINE PRAGMA UNDEF VERSION_TOKEN GARBAGE IDENTIFIER IF_EXPANDED INTEGER INTEGER_STRING LINE_EXPANDED NEWLINE OTHER PLACEHOLDER SPACE PLUS_PLUS MINUS_MINUS
%token PASTE
%type <ival> INTEGER operator SPACE integer_constant version_constant
%type <expression_value> expression
%type <str> IDENTIFIER FUNC_IDENTIFIER OBJ_IDENTIFIER INTEGER_STRING OTHER ERROR_TOKEN PRAGMA
%type <string_list> identifier_list
%type <token> preprocessing_token
%type <token_list> pp_tokens replacement_list text_line
%left OR
%left AND
%left '|'
%left '^'
%left '&'
%left EQUAL NOT_EQUAL
%left '<' '>' LESS_OR_EQUAL GREATER_OR_EQUAL
%left LEFT_SHIFT RIGHT_SHIFT
%left '+' '-'
%left '*' '/' '%'
%right UNARY

%debug

%%

input:
	/* empty */
|	input line
;

line:
	control_line
|	SPACE control_line
|	text_line {
		_glcpp_parser_print_expanded_token_list (parser, $1);
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "\n");
		ralloc_free ($1);
	}
|	expanded_line
;

expanded_line:
	IF_EXPANDED expression NEWLINE {
		if (parser->is_gles && $2.undefined_macro)
			glcpp_error(& @@1, parser, "undefined macro %s in expression (illegal in GLES)", $2.undefined_macro);
		_glcpp_parser_skip_stack_push_if (parser, & @@1, $2.value);
	}
|	ELIF_EXPANDED expression NEWLINE {
		if (parser->is_gles && $2.undefined_macro)
			glcpp_error(& @@1, parser, "undefined macro %s in expression (illegal in GLES)", $2.undefined_macro);
		_glcpp_parser_skip_stack_change_if (parser, & @@1, "elif", $2.value);
	}
|	LINE_EXPANDED integer_constant NEWLINE {
		parser->has_new_line_number = 1;
		parser->new_line_number = $2;
		ralloc_asprintf_rewrite_tail (&parser->output,
					      &parser->output_length,
					      "#line %" PRIiMAX "\n",
					      $2);
	}
|	LINE_EXPANDED integer_constant integer_constant NEWLINE {
		parser->has_new_line_number = 1;
		parser->new_line_number = $2;
		parser->has_new_source_number = 1;
		parser->new_source_number = $3;
		ralloc_asprintf_rewrite_tail (&parser->output,
					      &parser->output_length,
					      "#line %" PRIiMAX " %" PRIiMAX "\n",
					      $2, $3);
	}
;

define:
	OBJ_IDENTIFIER replacement_list NEWLINE {
		_define_object_macro (parser, & @@1, $1, $2);
	}
|	FUNC_IDENTIFIER '(' ')' replacement_list NEWLINE {
		_define_function_macro (parser, & @@1, $1, NULL, $4);
	}
|	FUNC_IDENTIFIER '(' identifier_list ')' replacement_list NEWLINE {
		_define_function_macro (parser, & @@1, $1, $3, $5);
	}
;

control_line:
	control_line_success {
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "\n");
	}
|	control_line_error
|	HASH_TOKEN LINE pp_tokens NEWLINE {

		if (parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			_glcpp_parser_expand_and_lex_from (parser,
							   LINE_EXPANDED, $3,
							   EXPANSION_MODE_IGNORE_DEFINED);
		}
	}
;

control_line_success:
	HASH_TOKEN DEFINE_TOKEN define
|	HASH_TOKEN UNDEF IDENTIFIER NEWLINE {
		macro_t *macro;
		struct hash_entry *entry;

                /* Section 3.4 (Preprocessor) of the GLSL ES 3.00 spec says:
                 *
                 *    It is an error to undefine or to redefine a built-in
                 *    (pre-defined) macro name.
                 *
                 * The GLSL ES 1.00 spec does not contain this text.
                 *
                 * Section 3.3 (Preprocessor) of the GLSL 1.30 spec says:
                 *
                 *    #define and #undef functionality are defined as is
                 *    standard for C++ preprocessors for macro definitions
                 *    both with and without macro parameters.
                 *
                 * At least as far as I can tell GCC allow '#undef __FILE__'.
                 * Furthermore, there are desktop OpenGL conformance tests
                 * that expect '#undef __VERSION__' and '#undef
                 * GL_core_profile' to work.
                 *
                 * Only disallow #undef of pre-defined macros on GLSL ES >=
                 * 3.00 shaders.
                 */
		if (parser->is_gles &&
                    parser->version >= 300 &&
                    (strcmp("__LINE__", $3) == 0
                     || strcmp("__FILE__", $3) == 0
                     || strcmp("__VERSION__", $3) == 0
                     || strncmp("GL_", $3, 3) == 0))
			glcpp_error(& @@1, parser, "Built-in (pre-defined)"
				    " macro names cannot be undefined.");

		entry = _mesa_hash_table_search (parser->defines, $3);
		if (entry) {
			macro = entry->data;
			_mesa_hash_table_remove (parser->defines, entry);
			ralloc_free (macro);
		}
		ralloc_free ($3);
	}
|	HASH_TOKEN IF pp_tokens NEWLINE {
		/* Be careful to only evaluate the 'if' expression if
		 * we are not skipping. When we are skipping, we
		 * simply push a new 0-valued 'if' onto the skip
		 * stack.
		 *
		 * This avoids generating diagnostics for invalid
		 * expressions that are being skipped. */
		if (parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			_glcpp_parser_expand_and_lex_from (parser,
							   IF_EXPANDED, $3,
							   EXPANSION_MODE_EVALUATE_DEFINED);
		}	
		else
		{
			_glcpp_parser_skip_stack_push_if (parser, & @@1, 0);
			parser->skip_stack->type = SKIP_TO_ENDIF;
		}
	}
|	HASH_TOKEN IF NEWLINE {
		/* #if without an expression is only an error if we
		 *  are not skipping */
		if (parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			glcpp_error(& @@1, parser, "#if with no expression");
		}	
		_glcpp_parser_skip_stack_push_if (parser, & @@1, 0);
	}
|	HASH_TOKEN IFDEF IDENTIFIER junk NEWLINE {
		struct hash_entry *entry =
				_mesa_hash_table_search(parser->defines, $3);
		macro_t *macro = entry ? entry->data : NULL;
		ralloc_free ($3);
		_glcpp_parser_skip_stack_push_if (parser, & @@1, macro != NULL);
	}
|	HASH_TOKEN IFNDEF IDENTIFIER junk NEWLINE {
		struct hash_entry *entry =
				_mesa_hash_table_search(parser->defines, $3);
		macro_t *macro = entry ? entry->data : NULL;
		_glcpp_parser_skip_stack_push_if (parser, & @@3, macro == NULL);
	}
|	HASH_TOKEN ELIF pp_tokens NEWLINE {
		/* Be careful to only evaluate the 'elif' expression
		 * if we are not skipping. When we are skipping, we
		 * simply change to a 0-valued 'elif' on the skip
		 * stack.
		 *
		 * This avoids generating diagnostics for invalid
		 * expressions that are being skipped. */
		if (parser->skip_stack &&
		    parser->skip_stack->type == SKIP_TO_ELSE)
		{
			_glcpp_parser_expand_and_lex_from (parser,
							   ELIF_EXPANDED, $3,
							   EXPANSION_MODE_EVALUATE_DEFINED);
		}
		else if (parser->skip_stack &&
		    parser->skip_stack->has_else)
		{
			glcpp_error(& @@1, parser, "#elif after #else");
		}
		else
		{
			_glcpp_parser_skip_stack_change_if (parser, & @@1,
							    "elif", 0);
		}
	}
|	HASH_TOKEN ELIF NEWLINE {
		/* #elif without an expression is an error unless we
		 * are skipping. */
		if (parser->skip_stack &&
		    parser->skip_stack->type == SKIP_TO_ELSE)
		{
			glcpp_error(& @@1, parser, "#elif with no expression");
		}
		else if (parser->skip_stack &&
		    parser->skip_stack->has_else)
		{
			glcpp_error(& @@1, parser, "#elif after #else");
		}
		else
		{
			_glcpp_parser_skip_stack_change_if (parser, & @@1,
							    "elif", 0);
			glcpp_warning(& @@1, parser, "ignoring illegal #elif without expression");
		}
	}
|	HASH_TOKEN ELSE { parser->lexing_directive = 1; } NEWLINE {
		if (parser->skip_stack &&
		    parser->skip_stack->has_else)
		{
			glcpp_error(& @@1, parser, "multiple #else");
		}
		else
		{
			_glcpp_parser_skip_stack_change_if (parser, & @@1, "else", 1);
			if (parser->skip_stack)
				parser->skip_stack->has_else = true;
		}
	}
|	HASH_TOKEN ENDIF {
		_glcpp_parser_skip_stack_pop (parser, & @@1);
	} NEWLINE
|	HASH_TOKEN VERSION_TOKEN version_constant NEWLINE {
		if (parser->version_set) {
			glcpp_error(& @@1, parser, "#version must appear on the first line");
		}
		_glcpp_parser_handle_version_declaration(parser, $3, NULL, true);
	}
|	HASH_TOKEN VERSION_TOKEN version_constant IDENTIFIER NEWLINE {
		if (parser->version_set) {
			glcpp_error(& @@1, parser, "#version must appear on the first line");
		}
		_glcpp_parser_handle_version_declaration(parser, $3, $4, true);
	}
|	HASH_TOKEN NEWLINE {
		glcpp_parser_resolve_implicit_version(parser);
	}
|	HASH_TOKEN PRAGMA NEWLINE {
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "#%s", $2);
	}
;

control_line_error:
	HASH_TOKEN ERROR_TOKEN NEWLINE {
		glcpp_error(& @@1, parser, "#%s", $2);
	}
|	HASH_TOKEN DEFINE_TOKEN NEWLINE {
		glcpp_error (& @@1, parser, "#define without macro name");
	}
|	HASH_TOKEN GARBAGE pp_tokens NEWLINE  {
		glcpp_error (& @@1, parser, "Illegal non-directive after #");
	}
;

integer_constant:
	INTEGER_STRING {
		if (strlen ($1) >= 3 && strncmp ($1, "0x", 2) == 0) {
			$$ = strtoll ($1 + 2, NULL, 16);
		} else if ($1[0] == '0') {
			$$ = strtoll ($1, NULL, 8);
		} else {
			$$ = strtoll ($1, NULL, 10);
		}
	}
|	INTEGER {
		$$ = $1;
	}

version_constant:
	INTEGER_STRING {
	   /* Both octal and hexadecimal constants begin with 0. */
	   if ($1[0] == '0' && $1[1] != '\0') {
		glcpp_error(&@@1, parser, "invalid #version \"%s\" (not a decimal constant)", $1);
		$$ = 0;
	   } else {
		$$ = strtoll($1, NULL, 10);
	   }
	}

expression:
	integer_constant {
		$$.value = $1;
		$$.undefined_macro = NULL;
	}
|	IDENTIFIER {
		$$.value = 0;
		if (parser->is_gles)
			$$.undefined_macro = ralloc_strdup (parser, $1);
		else
			$$.undefined_macro = NULL;
	}
|	expression OR expression {
		$$.value = $1.value || $3.value;

		/* Short-circuit: Only flag undefined from right side
		 * if left side evaluates to false.
		 */
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else if (! $1.value)
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression AND expression {
		$$.value = $1.value && $3.value;

		/* Short-circuit: Only flag undefined from right-side
		 * if left side evaluates to true.
		 */
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else if ($1.value)
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression '|' expression {
		$$.value = $1.value | $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression '^' expression {
		$$.value = $1.value ^ $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression '&' expression {
		$$.value = $1.value & $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression NOT_EQUAL expression {
		$$.value = $1.value != $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression EQUAL expression {
		$$.value = $1.value == $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression GREATER_OR_EQUAL expression {
		$$.value = $1.value >= $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression LESS_OR_EQUAL expression {
		$$.value = $1.value <= $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression '>' expression {
		$$.value = $1.value > $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression '<' expression {
		$$.value = $1.value < $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression RIGHT_SHIFT expression {
		$$.value = $1.value >> $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression LEFT_SHIFT expression {
		$$.value = $1.value << $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression '-' expression {
		$$.value = $1.value - $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression '+' expression {
		$$.value = $1.value + $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression '%' expression {
		if ($3.value == 0) {
			yyerror (& @@1, parser,
				 "zero modulus in preprocessor directive");
		} else {
			$$.value = $1.value % $3.value;
		}
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression '/' expression {
		if ($3.value == 0) {
			yyerror (& @@1, parser,
				 "division by 0 in preprocessor directive");
		} else {
			$$.value = $1.value / $3.value;
		}
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	expression '*' expression {
		$$.value = $1.value * $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
	}
|	'!' expression %prec UNARY {
		$$.value = ! $2.value;
		$$.undefined_macro = $2.undefined_macro;
	}
|	'~' expression %prec UNARY {
		$$.value = ~ $2.value;
		$$.undefined_macro = $2.undefined_macro;
	}
|	'-' expression %prec UNARY {
		$$.value = - $2.value;
		$$.undefined_macro = $2.undefined_macro;
	}
|	'+' expression %prec UNARY {
		$$.value = + $2.value;
		$$.undefined_macro = $2.undefined_macro;
	}
|	'(' expression ')' {
		$$ = $2;
	}
;

identifier_list:
	IDENTIFIER {
		$$ = _string_list_create (parser);
		_string_list_append_item ($$, $1);
		ralloc_steal ($$, $1);
	}
|	identifier_list ',' IDENTIFIER {
		$$ = $1;	
		_string_list_append_item ($$, $3);
		ralloc_steal ($$, $3);
	}
;

text_line:
	NEWLINE { $$ = NULL; }
|	pp_tokens NEWLINE
;

replacement_list:
	/* empty */ { $$ = NULL; }
|	pp_tokens
;

junk:
	/* empty */
|	pp_tokens {
		glcpp_error(&@@1, parser, "extra tokens at end of directive");
	}
;

pp_tokens:
	preprocessing_token {
		parser->space_tokens = 1;
		$$ = _token_list_create (parser);
		_token_list_append ($$, $1);
	}
|	pp_tokens preprocessing_token {
		$$ = $1;
		_token_list_append ($$, $2);
	}
;

preprocessing_token:
	IDENTIFIER {
		$$ = _token_create_str (parser, IDENTIFIER, $1);
		$$->location = yylloc;
	}
|	INTEGER_STRING {
		$$ = _token_create_str (parser, INTEGER_STRING, $1);
		$$->location = yylloc;
	}
|	operator {
		$$ = _token_create_ival (parser, $1, $1);
		$$->location = yylloc;
	}
|	DEFINED {
		$$ = _token_create_ival (parser, DEFINED, DEFINED);
		$$->location = yylloc;
	}
|	OTHER {
		$$ = _token_create_str (parser, OTHER, $1);
		$$->location = yylloc;
	}
|	SPACE {
		$$ = _token_create_ival (parser, SPACE, SPACE);
		$$->location = yylloc;
	}
;

operator:
	'['			{ $$ = '['; }
|	']'			{ $$ = ']'; }
|	'('			{ $$ = '('; }
|	')'			{ $$ = ')'; }
|	'{'			{ $$ = '{'; }
|	'}'			{ $$ = '}'; }
|	'.'			{ $$ = '.'; }
|	'&'			{ $$ = '&'; }
|	'*'			{ $$ = '*'; }
|	'+'			{ $$ = '+'; }
|	'-'			{ $$ = '-'; }
|	'~'			{ $$ = '~'; }
|	'!'			{ $$ = '!'; }
|	'/'			{ $$ = '/'; }
|	'%'			{ $$ = '%'; }
|	LEFT_SHIFT		{ $$ = LEFT_SHIFT; }
|	RIGHT_SHIFT		{ $$ = RIGHT_SHIFT; }
|	'<'			{ $$ = '<'; }
|	'>'			{ $$ = '>'; }
|	LESS_OR_EQUAL		{ $$ = LESS_OR_EQUAL; }
|	GREATER_OR_EQUAL	{ $$ = GREATER_OR_EQUAL; }
|	EQUAL			{ $$ = EQUAL; }
|	NOT_EQUAL		{ $$ = NOT_EQUAL; }
|	'^'			{ $$ = '^'; }
|	'|'			{ $$ = '|'; }
|	AND			{ $$ = AND; }
|	OR			{ $$ = OR; }
|	';'			{ $$ = ';'; }
|	','			{ $$ = ','; }
|	'='			{ $$ = '='; }
|	PASTE			{ $$ = PASTE; }
|	PLUS_PLUS		{ $$ = PLUS_PLUS; }
|	MINUS_MINUS		{ $$ = MINUS_MINUS; }
;

%%

string_list_t *
_string_list_create(void *ctx)
{
   string_list_t *list;

   list = ralloc (ctx, string_list_t);
   list->head = NULL;
   list->tail = NULL;

   return list;
}

void
_string_list_append_item(string_list_t *list, const char *str)
{
   string_node_t *node;

   node = ralloc (list, string_node_t);
   node->str = ralloc_strdup (node, str);

   node->next = NULL;

   if (list->head == NULL) {
      list->head = node;
   } else {
      list->tail->next = node;
   }

   list->tail = node;
}

int
_string_list_contains(string_list_t *list, const char *member, int *index)
{
   string_node_t *node;
   int i;

   if (list == NULL)
      return 0;

   for (i = 0, node = list->head; node; i++, node = node->next) {
      if (strcmp (node->str, member) == 0) {
         if (index)
            *index = i;
         return 1;
      }
   }

   return 0;
}

/* Return duplicate string in list (if any), NULL otherwise. */
const char *
_string_list_has_duplicate(string_list_t *list)
{
   string_node_t *node, *dup;

   if (list == NULL)
      return NULL;

   for (node = list->head; node; node = node->next) {
      for (dup = node->next; dup; dup = dup->next) {
         if (strcmp (node->str, dup->str) == 0)
            return node->str;
      }
   }

   return NULL;
}

int
_string_list_length(string_list_t *list)
{
   int length = 0;
   string_node_t *node;

   if (list == NULL)
      return 0;

   for (node = list->head; node; node = node->next)
      length++;

   return length;
}

int
_string_list_equal(string_list_t *a, string_list_t *b)
{
   string_node_t *node_a, *node_b;

   if (a == NULL && b == NULL)
      return 1;

   if (a == NULL || b == NULL)
      return 0;

   for (node_a = a->head, node_b = b->head;
        node_a && node_b;
        node_a = node_a->next, node_b = node_b->next)
   {
      if (strcmp (node_a->str, node_b->str))
         return 0;
   }

   /* Catch the case of lists being different lengths, (which
    * would cause the loop above to terminate after the shorter
    * list). */
   return node_a == node_b;
}

argument_list_t *
_argument_list_create(void *ctx)
{
   argument_list_t *list;

   list = ralloc (ctx, argument_list_t);
   list->head = NULL;
   list->tail = NULL;

   return list;
}

void
_argument_list_append(argument_list_t *list, token_list_t *argument)
{
   argument_node_t *node;

   node = ralloc (list, argument_node_t);
   node->argument = argument;

   node->next = NULL;

   if (list->head == NULL) {
      list->head = node;
   } else {
      list->tail->next = node;
   }

   list->tail = node;
}

int
_argument_list_length(argument_list_t *list)
{
   int length = 0;
   argument_node_t *node;

   if (list == NULL)
      return 0;

   for (node = list->head; node; node = node->next)
      length++;

   return length;
}

token_list_t *
_argument_list_member_at(argument_list_t *list, int index)
{
   argument_node_t *node;
   int i;

   if (list == NULL)
      return NULL;

   node = list->head;
   for (i = 0; i < index; i++) {
      node = node->next;
      if (node == NULL)
         break;
   }

   if (node)
      return node->argument;

   return NULL;
}

/* Note: This function ralloc_steal()s the str pointer. */
token_t *
_token_create_str(void *ctx, int type, char *str)
{
   token_t *token;

   token = ralloc (ctx, token_t);
   token->type = type;
   token->value.str = str;

   ralloc_steal (token, str);

   return token;
}

token_t *
_token_create_ival(void *ctx, int type, int ival)
{
   token_t *token;

   token = ralloc (ctx, token_t);
   token->type = type;
   token->value.ival = ival;

   return token;
}

token_list_t *
_token_list_create(void *ctx)
{
   token_list_t *list;

   list = ralloc (ctx, token_list_t);
   list->head = NULL;
   list->tail = NULL;
   list->non_space_tail = NULL;

   return list;
}

void
_token_list_append(token_list_t *list, token_t *token)
{
   token_node_t *node;

   node = ralloc (list, token_node_t);
   node->token = token;
   node->next = NULL;

   if (list->head == NULL) {
      list->head = node;
   } else {
      list->tail->next = node;
   }

   list->tail = node;
   if (token->type != SPACE)
      list->non_space_tail = node;
}

void
_token_list_append_list(token_list_t *list, token_list_t *tail)
{
   if (tail == NULL || tail->head == NULL)
      return;

   if (list->head == NULL) {
      list->head = tail->head;
   } else {
      list->tail->next = tail->head;
   }

   list->tail = tail->tail;
   list->non_space_tail = tail->non_space_tail;
}

static token_list_t *
_token_list_copy(void *ctx, token_list_t *other)
{
   token_list_t *copy;
   token_node_t *node;

   if (other == NULL)
      return NULL;

   copy = _token_list_create (ctx);
   for (node = other->head; node; node = node->next) {
      token_t *new_token = ralloc (copy, token_t);
      *new_token = *node->token;
      _token_list_append (copy, new_token);
   }

   return copy;
}

static void
_token_list_trim_trailing_space(token_list_t *list)
{
   token_node_t *tail, *next;

   if (list->non_space_tail) {
      tail = list->non_space_tail->next;
      list->non_space_tail->next = NULL;
      list->tail = list->non_space_tail;

      while (tail) {
         next = tail->next;
         ralloc_free (tail);
         tail = next;
      }
   }
}

static int
_token_list_is_empty_ignoring_space(token_list_t *l)
{
   token_node_t *n;

   if (l == NULL)
      return 1;

   n = l->head;
   while (n != NULL && n->token->type == SPACE)
      n = n->next;

   return n == NULL;
}

int
_token_list_equal_ignoring_space(token_list_t *a, token_list_t *b)
{
   token_node_t *node_a, *node_b;

   if (a == NULL || b == NULL) {
      int a_empty = _token_list_is_empty_ignoring_space(a);
      int b_empty = _token_list_is_empty_ignoring_space(b);
      return a_empty == b_empty;
   }

   node_a = a->head;
   node_b = b->head;

   while (1)
   {
      if (node_a == NULL && node_b == NULL)
         break;

      if (node_a == NULL || node_b == NULL)
         return 0;
      /* Make sure whitespace appears in the same places in both.
       * It need not be exactly the same amount of whitespace,
       * though.
       */
      if (node_a->token->type == SPACE && node_b->token->type == SPACE) {
         while (node_a && node_a->token->type == SPACE)
            node_a = node_a->next;
         while (node_b && node_b->token->type == SPACE)
            node_b = node_b->next;
         continue;
      }

      if (node_a->token->type != node_b->token->type)
         return 0;

      switch (node_a->token->type) {
      case INTEGER:
         if (node_a->token->value.ival !=  node_b->token->value.ival) {
            return 0;
         }
         break;
      case IDENTIFIER:
      case INTEGER_STRING:
      case OTHER:
         if (strcmp(node_a->token->value.str, node_b->token->value.str)) {
            return 0;
         }
         break;
      }

      node_a = node_a->next;
      node_b = node_b->next;
   }

   return 1;
}

static void
_token_print(char **out, size_t *len, token_t *token)
{
   if (token->type < 256) {
      ralloc_asprintf_rewrite_tail (out, len, "%c", token->type);
      return;
   }

   switch (token->type) {
   case INTEGER:
      ralloc_asprintf_rewrite_tail (out, len, "%" PRIiMAX, token->value.ival);
      break;
   case IDENTIFIER:
   case INTEGER_STRING:
   case OTHER:
      ralloc_asprintf_rewrite_tail (out, len, "%s", token->value.str);
      break;
   case SPACE:
      ralloc_asprintf_rewrite_tail (out, len, " ");
      break;
   case LEFT_SHIFT:
      ralloc_asprintf_rewrite_tail (out, len, "<<");
      break;
   case RIGHT_SHIFT:
      ralloc_asprintf_rewrite_tail (out, len, ">>");
      break;
   case LESS_OR_EQUAL:
      ralloc_asprintf_rewrite_tail (out, len, "<=");
      break;
   case GREATER_OR_EQUAL:
      ralloc_asprintf_rewrite_tail (out, len, ">=");
      break;
   case EQUAL:
      ralloc_asprintf_rewrite_tail (out, len, "==");
      break;
   case NOT_EQUAL:
      ralloc_asprintf_rewrite_tail (out, len, "!=");
      break;
   case AND:
      ralloc_asprintf_rewrite_tail (out, len, "&&");
      break;
   case OR:
      ralloc_asprintf_rewrite_tail (out, len, "||");
      break;
   case PASTE:
      ralloc_asprintf_rewrite_tail (out, len, "##");
      break;
   case PLUS_PLUS:
      ralloc_asprintf_rewrite_tail (out, len, "++");
      break;
   case MINUS_MINUS:
      ralloc_asprintf_rewrite_tail (out, len, "--");
      break;
   case DEFINED:
      ralloc_asprintf_rewrite_tail (out, len, "defined");
      break;
   case PLACEHOLDER:
      /* Nothing to print. */
      break;
   default:
      assert(!"Error: Don't know how to print token.");

      break;
   }
}

/* Return a new token (ralloc()ed off of 'token') formed by pasting
 * 'token' and 'other'. Note that this function may return 'token' or
 * 'other' directly rather than allocating anything new.
 *
 * Caution: Only very cursory error-checking is performed to see if
 * the final result is a valid single token. */
static token_t *
_token_paste(glcpp_parser_t *parser, token_t *token, token_t *other)
{
   token_t *combined = NULL;

   /* Pasting a placeholder onto anything makes no change. */
   if (other->type == PLACEHOLDER)
      return token;

   /* When 'token' is a placeholder, just return 'other'. */
   if (token->type == PLACEHOLDER)
      return other;

   /* A very few single-character punctuators can be combined
    * with another to form a multi-character punctuator. */
   switch (token->type) {
   case '<':
      if (other->type == '<')
         combined = _token_create_ival (token, LEFT_SHIFT, LEFT_SHIFT);
      else if (other->type == '=')
         combined = _token_create_ival (token, LESS_OR_EQUAL, LESS_OR_EQUAL);
      break;
   case '>':
      if (other->type == '>')
         combined = _token_create_ival (token, RIGHT_SHIFT, RIGHT_SHIFT);
      else if (other->type == '=')
         combined = _token_create_ival (token, GREATER_OR_EQUAL, GREATER_OR_EQUAL);
      break;
   case '=':
      if (other->type == '=')
         combined = _token_create_ival (token, EQUAL, EQUAL);
      break;
   case '!':
      if (other->type == '=')
         combined = _token_create_ival (token, NOT_EQUAL, NOT_EQUAL);
      break;
   case '&':
      if (other->type == '&')
         combined = _token_create_ival (token, AND, AND);
      break;
   case '|':
      if (other->type == '|')
         combined = _token_create_ival (token, OR, OR);
      break;
   }

   if (combined != NULL) {
      /* Inherit the location from the first token */
      combined->location = token->location;
      return combined;
   }

   /* Two string-valued (or integer) tokens can usually just be
    * mashed together. (We also handle a string followed by an
    * integer here as well.)
    *
    * There are some exceptions here. Notably, if the first token
    * is an integer (or a string representing an integer), then
    * the second token must also be an integer or must be a
    * string representing an integer that begins with a digit.
    */
   if ((token->type == IDENTIFIER || token->type == OTHER || token->type == INTEGER_STRING || token->type == INTEGER) &&
       (other->type == IDENTIFIER || other->type == OTHER || other->type == INTEGER_STRING || other->type == INTEGER))
   {
      char *str;
      int combined_type;

      /* Check that pasting onto an integer doesn't create a
       * non-integer, (that is, only digits can be
       * pasted. */
      if (token->type == INTEGER_STRING || token->type == INTEGER) {
         switch (other->type) {
         case INTEGER_STRING:
            if (other->value.str[0] < '0' || other->value.str[0] > '9')
               goto FAIL;
            break;
         case INTEGER:
            if (other->value.ival < 0)
               goto FAIL;
            break;
         default:
            goto FAIL;
         }
      }

      if (token->type == INTEGER)
         str = ralloc_asprintf (token, "%" PRIiMAX, token->value.ival);
      else
         str = ralloc_strdup (token, token->value.str);

      if (other->type == INTEGER)
         ralloc_asprintf_append (&str, "%" PRIiMAX, other->value.ival);
      else
         ralloc_strcat (&str, other->value.str);

      /* New token is same type as original token, unless we
       * started with an integer, in which case we will be
       * creating an integer-string. */
      combined_type = token->type;
      if (combined_type == INTEGER)
         combined_type = INTEGER_STRING;

      combined = _token_create_str (token, combined_type, str);
      combined->location = token->location;
      return combined;
   }

    FAIL:
   glcpp_error (&token->location, parser, "");
   ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "Pasting \"");
   _token_print (&parser->info_log, &parser->info_log_length, token);
   ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "\" and \"");
   _token_print (&parser->info_log, &parser->info_log_length, other);
   ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "\" does not give a valid preprocessing token.\n");

   return token;
}

static void
_token_list_print(glcpp_parser_t *parser, token_list_t *list)
{
   token_node_t *node;

   if (list == NULL)
      return;

   for (node = list->head; node; node = node->next)
      _token_print (&parser->output, &parser->output_length, node->token);
}

void
yyerror(YYLTYPE *locp, glcpp_parser_t *parser, const char *error)
{
   glcpp_error(locp, parser, "%s", error);
}

static void
add_builtin_define(glcpp_parser_t *parser, const char *name, int value)
{
   token_t *tok;
   token_list_t *list;

   tok = _token_create_ival (parser, INTEGER, value);

   list = _token_list_create(parser);
   _token_list_append(list, tok);
   _define_object_macro(parser, NULL, name, list);
}

glcpp_parser_t *
glcpp_parser_create(glcpp_extension_iterator extensions, void *state, gl_api api)
{
   glcpp_parser_t *parser;

   parser = ralloc (NULL, glcpp_parser_t);

   glcpp_lex_init_extra (parser, &parser->scanner);
   parser->defines = _mesa_hash_table_create(NULL, _mesa_key_hash_string,
                                             _mesa_key_string_equal);
   parser->active = NULL;
   parser->lexing_directive = 0;
   parser->space_tokens = 1;
   parser->last_token_was_newline = 0;
   parser->last_token_was_space = 0;
   parser->first_non_space_token_this_line = 1;
   parser->newline_as_space = 0;
   parser->in_control_line = 0;
   parser->paren_count = 0;
   parser->commented_newlines = 0;

   parser->skip_stack = NULL;
   parser->skipping = 0;

   parser->lex_from_list = NULL;
   parser->lex_from_node = NULL;

   parser->output = ralloc_strdup(parser, "");
   parser->output_length = 0;
   parser->info_log = ralloc_strdup(parser, "");
   parser->info_log_length = 0;
   parser->error = 0;

   parser->extensions = extensions;
   parser->state = state;
   parser->api = api;
   parser->version = 0;
   parser->version_set = false;

   parser->has_new_line_number = 0;
   parser->new_line_number = 1;
   parser->has_new_source_number = 0;
   parser->new_source_number = 0;

   return parser;
}

void
glcpp_parser_destroy(glcpp_parser_t *parser)
{
   glcpp_lex_destroy (parser->scanner);
   _mesa_hash_table_destroy(parser->defines, NULL);
   ralloc_free (parser);
}

typedef enum function_status
{
   FUNCTION_STATUS_SUCCESS,
   FUNCTION_NOT_A_FUNCTION,
   FUNCTION_UNBALANCED_PARENTHESES
} function_status_t;

/* Find a set of function-like macro arguments by looking for a
 * balanced set of parentheses.
 *
 * When called, 'node' should be the opening-parenthesis token, (or
 * perhaps preceeding SPACE tokens). Upon successful return *last will
 * be the last consumed node, (corresponding to the closing right
 * parenthesis).
 *
 * Return values:
 *
 *   FUNCTION_STATUS_SUCCESS:
 *
 *      Successfully parsed a set of function arguments.
 *
 *   FUNCTION_NOT_A_FUNCTION:
 *
 *      Macro name not followed by a '('. This is not an error, but
 *      simply that the macro name should be treated as a non-macro.
 *
 *   FUNCTION_UNBALANCED_PARENTHESES
 *
 *      Macro name is not followed by a balanced set of parentheses.
 */
static function_status_t
_arguments_parse(argument_list_t *arguments, token_node_t *node,
                 token_node_t **last)
{
   token_list_t *argument;
   int paren_count;

   node = node->next;

   /* Ignore whitespace before first parenthesis. */
   while (node && node->token->type == SPACE)
      node = node->next;

   if (node == NULL || node->token->type != '(')
      return FUNCTION_NOT_A_FUNCTION;

   node = node->next;

   argument = _token_list_create (arguments);
   _argument_list_append (arguments, argument);

   for (paren_count = 1; node; node = node->next) {
      if (node->token->type == '(') {
         paren_count++;
      } else if (node->token->type == ')') {
         paren_count--;
         if (paren_count == 0)
            break;
      }

      if (node->token->type == ',' && paren_count == 1) {
         _token_list_trim_trailing_space (argument);
         argument = _token_list_create (arguments);
         _argument_list_append (arguments, argument);
      } else {
         if (argument->head == NULL) {
            /* Don't treat initial whitespace as part of the argument. */
            if (node->token->type == SPACE)
               continue;
         }
         _token_list_append (argument, node->token);
      }
   }

   if (paren_count)
      return FUNCTION_UNBALANCED_PARENTHESES;

   *last = node;

   return FUNCTION_STATUS_SUCCESS;
}

static token_list_t *
_token_list_create_with_one_ival(void *ctx, int type, int ival)
{
   token_list_t *list;
   token_t *node;

   list = _token_list_create(ctx);
   node = _token_create_ival(list, type, ival);
   _token_list_append(list, node);

   return list;
}

static token_list_t *
_token_list_create_with_one_space(void *ctx)
{
   return _token_list_create_with_one_ival(ctx, SPACE, SPACE);
}

static token_list_t *
_token_list_create_with_one_integer(void *ctx, int ival)
{
   return _token_list_create_with_one_ival(ctx, INTEGER, ival);
}

/* Evaluate a DEFINED token node (based on subsequent tokens in the list).
 *
 * Note: This function must only be called when "node" is a DEFINED token,
 * (and will abort with an assertion failure otherwise).
 *
 * If "node" is followed, (ignoring any SPACE tokens), by an IDENTIFIER token
 * (optionally preceded and followed by '(' and ')' tokens) then the following
 * occurs:
 *
 *   If the identifier is a defined macro, this function returns 1.
 *
 *   If the identifier is not a defined macro, this function returns 0.
 *
 *   In either case, *last will be updated to the last node in the list
 *   consumed by the evaluation, (either the token of the identifier or the
 *   token of the closing parenthesis).
 *
 * In all other cases, (such as "node is the final node of the list", or
 * "missing closing parenthesis", etc.), this function generates a
 * preprocessor error, returns -1 and *last will not be set.
 */
static int
_glcpp_parser_evaluate_defined(glcpp_parser_t *parser, token_node_t *node,
                               token_node_t **last)
{
   token_node_t *argument, *defined = node;

   assert(node->token->type == DEFINED);

   node = node->next;

   /* Ignore whitespace after DEFINED token. */
   while (node && node->token->type == SPACE)
      node = node->next;

   if (node == NULL)
      goto FAIL;

   if (node->token->type == IDENTIFIER || node->token->type == OTHER) {
      argument = node;
   } else if (node->token->type == '(') {
      node = node->next;

      /* Ignore whitespace after '(' token. */
      while (node && node->token->type == SPACE)
         node = node->next;

      if (node == NULL || (node->token->type != IDENTIFIER &&
                           node->token->type != OTHER)) {
         goto FAIL;
      }

      argument = node;

      node = node->next;

      /* Ignore whitespace after identifier, before ')' token. */
      while (node && node->token->type == SPACE)
         node = node->next;

      if (node == NULL || node->token->type != ')')
         goto FAIL;
   } else {
      goto FAIL;
   }

   *last = node;

   return _mesa_hash_table_search(parser->defines,
                                  argument->token->value.str) ? 1 : 0;

FAIL:
   glcpp_error (&defined->token->location, parser,
                "\"defined\" not followed by an identifier");
   return -1;
}

/* Evaluate all DEFINED nodes in a given list, modifying the list in place.
 */
static void
_glcpp_parser_evaluate_defined_in_list(glcpp_parser_t *parser,
                                       token_list_t *list)
{
   token_node_t *node, *node_prev, *replacement, *last = NULL;
   int value;

   if (list == NULL)
      return;

   node_prev = NULL;
   node = list->head;

   while (node) {

      if (node->token->type != DEFINED)
         goto NEXT;

      value = _glcpp_parser_evaluate_defined (parser, node, &last);
      if (value == -1)
         goto NEXT;

      replacement = ralloc (list, token_node_t);
      replacement->token = _token_create_ival (list, INTEGER, value);

      /* Splice replacement node into list, replacing from "node"
       * through "last". */
      if (node_prev)
         node_prev->next = replacement;
      else
         list->head = replacement;
      replacement->next = last->next;
      if (last == list->tail)
         list->tail = replacement;

      node = replacement;

   NEXT:
      node_prev = node;
      node = node->next;
   }
}

/* Perform macro expansion on 'list', placing the resulting tokens
 * into a new list which is initialized with a first token of type
 * 'head_token_type'. Then begin lexing from the resulting list,
 * (return to the current lexing source when this list is exhausted).
 *
 * See the documentation of _glcpp_parser_expand_token_list for a description
 * of the "mode" parameter.
 */
static void
_glcpp_parser_expand_and_lex_from(glcpp_parser_t *parser, int head_token_type,
                                  token_list_t *list, expansion_mode_t mode)
{
   token_list_t *expanded;
   token_t *token;

   expanded = _token_list_create (parser);
   token = _token_create_ival (parser, head_token_type, head_token_type);
   _token_list_append (expanded, token);
   _glcpp_parser_expand_token_list (parser, list, mode);
   _token_list_append_list (expanded, list);
   glcpp_parser_lex_from (parser, expanded);
}

static void
_glcpp_parser_apply_pastes(glcpp_parser_t *parser, token_list_t *list)
{
   token_node_t *node;

   node = list->head;
   while (node) {
      token_node_t *next_non_space;

      /* Look ahead for a PASTE token, skipping space. */
      next_non_space = node->next;
      while (next_non_space && next_non_space->token->type == SPACE)
         next_non_space = next_non_space->next;

      if (next_non_space == NULL)
         break;

      if (next_non_space->token->type != PASTE) {
         node = next_non_space;
         continue;
      }

      /* Now find the next non-space token after the PASTE. */
      next_non_space = next_non_space->next;
      while (next_non_space && next_non_space->token->type == SPACE)
         next_non_space = next_non_space->next;

      if (next_non_space == NULL) {
         yyerror(&node->token->location, parser, "'##' cannot appear at either end of a macro expansion\n");
         return;
      }

      node->token = _token_paste(parser, node->token, next_non_space->token);
      node->next = next_non_space->next;
      if (next_non_space == list->tail)
         list->tail = node;
   }

   list->non_space_tail = list->tail;
}

/* This is a helper function that's essentially part of the
 * implementation of _glcpp_parser_expand_node. It shouldn't be called
 * except for by that function.
 *
 * Returns NULL if node is a simple token with no expansion, (that is,
 * although 'node' corresponds to an identifier defined as a
 * function-like macro, it is not followed with a parenthesized
 * argument list).
 *
 * Compute the complete expansion of node (which is a function-like
 * macro) and subsequent nodes which are arguments.
 *
 * Returns the token list that results from the expansion and sets
 * *last to the last node in the list that was consumed by the
 * expansion. Specifically, *last will be set as follows: as the
 * token of the closing right parenthesis.
 *
 * See the documentation of _glcpp_parser_expand_token_list for a description
 * of the "mode" parameter.
 */
static token_list_t *
_glcpp_parser_expand_function(glcpp_parser_t *parser, token_node_t *node,
                              token_node_t **last, expansion_mode_t mode)
{
   struct hash_entry *entry;
   macro_t *macro;
   const char *identifier;
   argument_list_t *arguments;
   function_status_t status;
   token_list_t *substituted;
   int parameter_index;

   identifier = node->token->value.str;

   entry = _mesa_hash_table_search(parser->defines, identifier);
   macro = entry ? entry->data : NULL;

   assert(macro->is_function);

   arguments = _argument_list_create(parser);
   status = _arguments_parse(arguments, node, last);

   switch (status) {
   case FUNCTION_STATUS_SUCCESS:
      break;
   case FUNCTION_NOT_A_FUNCTION:
      return NULL;
   case FUNCTION_UNBALANCED_PARENTHESES:
      glcpp_error(&node->token->location, parser, "Macro %s call has unbalanced parentheses\n", identifier);
      return NULL;
   }

   /* Replace a macro defined as empty with a SPACE token. */
   if (macro->replacements == NULL) {
      ralloc_free(arguments);
      return _token_list_create_with_one_space(parser);
   }

   if (!((_argument_list_length (arguments) ==
          _string_list_length (macro->parameters)) ||
         (_string_list_length (macro->parameters) == 0 &&
          _argument_list_length (arguments) == 1 &&
          arguments->head->argument->head == NULL))) {
      glcpp_error(&node->token->location, parser,
                  "Error: macro %s invoked with %d arguments (expected %d)\n",
                  identifier, _argument_list_length (arguments),
                  _string_list_length(macro->parameters));
      return NULL;
   }

   /* Perform argument substitution on the replacement list. */
   substituted = _token_list_create(arguments);

   for (node = macro->replacements->head; node; node = node->next) {
      if (node->token->type == IDENTIFIER &&
          _string_list_contains(macro->parameters, node->token->value.str,
                                &parameter_index)) {
         token_list_t *argument;
         argument = _argument_list_member_at(arguments, parameter_index);
         /* Before substituting, we expand the argument tokens, or append a
          * placeholder token for an empty argument. */
         if (argument->head) {
            token_list_t *expanded_argument;
            expanded_argument = _token_list_copy(parser, argument);
            _glcpp_parser_expand_token_list(parser, expanded_argument, mode);
            _token_list_append_list(substituted, expanded_argument);
         } else {
            token_t *new_token;

            new_token = _token_create_ival(substituted, PLACEHOLDER,
                                           PLACEHOLDER);
            _token_list_append(substituted, new_token);
         }
      } else {
         _token_list_append(substituted, node->token);
      }
   }

   /* After argument substitution, and before further expansion
    * below, implement token pasting. */

   _token_list_trim_trailing_space(substituted);

   _glcpp_parser_apply_pastes(parser, substituted);

   return substituted;
}

/* Compute the complete expansion of node, (and subsequent nodes after
 * 'node' in the case that 'node' is a function-like macro and
 * subsequent nodes are arguments).
 *
 * Returns NULL if node is a simple token with no expansion.
 *
 * Otherwise, returns the token list that results from the expansion
 * and sets *last to the last node in the list that was consumed by
 * the expansion. Specifically, *last will be set as follows:
 *
 *   As 'node' in the case of object-like macro expansion.
 *
 *   As the token of the closing right parenthesis in the case of
 *   function-like macro expansion.
 *
 * See the documentation of _glcpp_parser_expand_token_list for a description
 * of the "mode" parameter.
 */
static token_list_t *
_glcpp_parser_expand_node(glcpp_parser_t *parser, token_node_t *node,
                          token_node_t **last, expansion_mode_t mode)
{
   token_t *token = node->token;
   const char *identifier;
   struct hash_entry *entry;
   macro_t *macro;

   /* We only expand identifiers */
   if (token->type != IDENTIFIER) {
      return NULL;
   }

   *last = node;
   identifier = token->value.str;

   /* Special handling for __LINE__ and __FILE__, (not through
    * the hash table). */
   if (strcmp(identifier, "__LINE__") == 0)
      return _token_list_create_with_one_integer(parser, node->token->location.first_line);

   if (strcmp(identifier, "__FILE__") == 0)
      return _token_list_create_with_one_integer(parser, node->token->location.source);

   /* Look up this identifier in the hash table. */
   entry = _mesa_hash_table_search(parser->defines, identifier);
   macro = entry ? entry->data : NULL;

   /* Not a macro, so no expansion needed. */
   if (macro == NULL)
      return NULL;

   /* Finally, don't expand this macro if we're already actively
    * expanding it, (to avoid infinite recursion). */
   if (_parser_active_list_contains (parser, identifier)) {
      /* We change the token type here from IDENTIFIER to OTHER to prevent any
       * future expansion of this unexpanded token. */
      char *str;
      token_list_t *expansion;
      token_t *final;

      str = ralloc_strdup(parser, token->value.str);
      final = _token_create_str(parser, OTHER, str);
      expansion = _token_list_create(parser);
      _token_list_append(expansion, final);
      return expansion;
   }

   if (! macro->is_function) {
      token_list_t *replacement;

      /* Replace a macro defined as empty with a SPACE token. */
      if (macro->replacements == NULL)
         return _token_list_create_with_one_space(parser);

      replacement = _token_list_copy(parser, macro->replacements);
      _glcpp_parser_apply_pastes(parser, replacement);
      return replacement;
   }

   return _glcpp_parser_expand_function(parser, node, last, mode);
}

/* Push a new identifier onto the parser's active list.
 *
 * Here, 'marker' is the token node that appears in the list after the
 * expansion of 'identifier'. That is, when the list iterator begins
 * examining 'marker', then it is time to pop this node from the
 * active stack.
 */
static void
_parser_active_list_push(glcpp_parser_t *parser, const char *identifier,
                         token_node_t *marker)
{
   active_list_t *node;

   node = ralloc(parser->active, active_list_t);
   node->identifier = ralloc_strdup(node, identifier);
   node->marker = marker;
   node->next = parser->active;

   parser->active = node;
}

static void
_parser_active_list_pop(glcpp_parser_t *parser)
{
   active_list_t *node = parser->active;

   if (node == NULL) {
      parser->active = NULL;
      return;
   }

   node = parser->active->next;
   ralloc_free (parser->active);

   parser->active = node;
}

static int
_parser_active_list_contains(glcpp_parser_t *parser, const char *identifier)
{
   active_list_t *node;

   if (parser->active == NULL)
      return 0;

   for (node = parser->active; node; node = node->next)
      if (strcmp(node->identifier, identifier) == 0)
         return 1;

   return 0;
}

/* Walk over the token list replacing nodes with their expansion.
 * Whenever nodes are expanded the walking will walk over the new
 * nodes, continuing to expand as necessary. The results are placed in
 * 'list' itself.
 *
 * The "mode" argument controls the handling of any DEFINED tokens that
 * result from expansion as follows:
 *
 *   EXPANSION_MODE_IGNORE_DEFINED: Any resulting DEFINED tokens will be
 *      left in the final list, unevaluated. This is the correct mode
 *      for expanding any list in any context other than a
 *      preprocessor conditional, (#if or #elif).
 *
 *   EXPANSION_MODE_EVALUATE_DEFINED: Any resulting DEFINED tokens will be
 *      evaluated to 0 or 1 tokens depending on whether the following
 *      token is the name of a defined macro. If the DEFINED token is
 *      not followed by an (optionally parenthesized) identifier, then
 *      an error will be generated. This the correct mode for
 *      expanding any list in the context of a preprocessor
 *      conditional, (#if or #elif).
 */
static void
_glcpp_parser_expand_token_list(glcpp_parser_t *parser, token_list_t *list,
                                expansion_mode_t mode)
{
   token_node_t *node_prev;
   token_node_t *node, *last = NULL;
   token_list_t *expansion;
   active_list_t *active_initial = parser->active;

   if (list == NULL)
      return;

   _token_list_trim_trailing_space (list);

   node_prev = NULL;
   node = list->head;

   if (mode == EXPANSION_MODE_EVALUATE_DEFINED)
      _glcpp_parser_evaluate_defined_in_list (parser, list);

   while (node) {

      while (parser->active && parser->active->marker == node)
         _parser_active_list_pop (parser);

      expansion = _glcpp_parser_expand_node (parser, node, &last, mode);
      if (expansion) {
         token_node_t *n;

         if (mode == EXPANSION_MODE_EVALUATE_DEFINED) {
            _glcpp_parser_evaluate_defined_in_list (parser, expansion);
         }

         for (n = node; n != last->next; n = n->next)
            while (parser->active && parser->active->marker == n) {
               _parser_active_list_pop (parser);
            }

         _parser_active_list_push(parser, node->token->value.str, last->next);

         /* Splice expansion into list, supporting a simple deletion if the
          * expansion is empty.
          */
         if (expansion->head) {
            if (node_prev)
               node_prev->next = expansion->head;
            else
               list->head = expansion->head;
            expansion->tail->next = last->next;
            if (last == list->tail)
               list->tail = expansion->tail;
         } else {
            if (node_prev)
               node_prev->next = last->next;
            else
               list->head = last->next;
            if (last == list->tail)
               list->tail = NULL;
         }
      } else {
         node_prev = node;
      }
      node = node_prev ? node_prev->next : list->head;
   }

   /* Remove any lingering effects of this invocation on the
    * active list. That is, pop until the list looks like it did
    * at the beginning of this function. */
   while (parser->active && parser->active != active_initial)
      _parser_active_list_pop (parser);

   list->non_space_tail = list->tail;
}

void
_glcpp_parser_print_expanded_token_list(glcpp_parser_t *parser,
                                        token_list_t *list)
{
   if (list == NULL)
      return;

   _glcpp_parser_expand_token_list (parser, list, EXPANSION_MODE_IGNORE_DEFINED);

   _token_list_trim_trailing_space (list);

   _token_list_print (parser, list);
}

static void
_check_for_reserved_macro_name(glcpp_parser_t *parser, YYLTYPE *loc,
                               const char *identifier)
{
   /* Section 3.3 (Preprocessor) of the GLSL 1.30 spec (and later) and
    * the GLSL ES spec (all versions) say:
    *
    *     "All macro names containing two consecutive underscores ( __ )
    *     are reserved for future use as predefined macro names. All
    *     macro names prefixed with "GL_" ("GL" followed by a single
    *     underscore) are also reserved."
    *
    * The intention is that names containing __ are reserved for internal
    * use by the implementation, and names prefixed with GL_ are reserved
    * for use by Khronos.  Since every extension adds a name prefixed
    * with GL_ (i.e., the name of the extension), that should be an
    * error.  Names simply containing __ are dangerous to use, but should
    * be allowed.
    *
    * A future version of the GLSL specification will clarify this.
    */
   if (strstr(identifier, "__")) {
      glcpp_warning(loc, parser, "Macro names containing \"__\" are reserved "
                    "for use by the implementation.\n");
   }
   if (strncmp(identifier, "GL_", 3) == 0) {
      glcpp_error (loc, parser, "Macro names starting with \"GL_\" are reserved.\n");
   }
   if (strcmp(identifier, "defined") == 0) {
      glcpp_error (loc, parser, "\"defined\" cannot be used as a macro name");
   }
}

static int
_macro_equal(macro_t *a, macro_t *b)
{
   if (a->is_function != b->is_function)
      return 0;

   if (a->is_function) {
      if (! _string_list_equal (a->parameters, b->parameters))
         return 0;
   }

   return _token_list_equal_ignoring_space(a->replacements, b->replacements);
}

void
_define_object_macro(glcpp_parser_t *parser, YYLTYPE *loc,
                     const char *identifier, token_list_t *replacements)
{
   macro_t *macro, *previous;
   struct hash_entry *entry;

   /* We define pre-defined macros before we've started parsing the actual
    * file. So if there's no location defined yet, that's what were doing and
    * we don't want to generate an error for using the reserved names. */
   if (loc != NULL)
      _check_for_reserved_macro_name(parser, loc, identifier);

   macro = ralloc (parser, macro_t);

   macro->is_function = 0;
   macro->parameters = NULL;
   macro->identifier = ralloc_strdup (macro, identifier);
   macro->replacements = replacements;
   ralloc_steal (macro, replacements);

   entry = _mesa_hash_table_search(parser->defines, identifier);
   previous = entry ? entry->data : NULL;
   if (previous) {
      if (_macro_equal (macro, previous)) {
         ralloc_free (macro);
         return;
      }
      glcpp_error (loc, parser, "Redefinition of macro %s\n",  identifier);
   }

   _mesa_hash_table_insert (parser->defines, identifier, macro);
}

void
_define_function_macro(glcpp_parser_t *parser, YYLTYPE *loc,
                       const char *identifier, string_list_t *parameters,
                       token_list_t *replacements)
{
   macro_t *macro, *previous;
   struct hash_entry *entry;
   const char *dup;

   _check_for_reserved_macro_name(parser, loc, identifier);

        /* Check for any duplicate parameter names. */
   if ((dup = _string_list_has_duplicate (parameters)) != NULL) {
      glcpp_error (loc, parser, "Duplicate macro parameter \"%s\"", dup);
   }

   macro = ralloc (parser, macro_t);
   ralloc_steal (macro, parameters);
   ralloc_steal (macro, replacements);

   macro->is_function = 1;
   macro->parameters = parameters;
   macro->identifier = ralloc_strdup (macro, identifier);
   macro->replacements = replacements;

   entry = _mesa_hash_table_search(parser->defines, identifier);
   previous = entry ? entry->data : NULL;
   if (previous) {
      if (_macro_equal (macro, previous)) {
         ralloc_free (macro);
         return;
      }
      glcpp_error (loc, parser, "Redefinition of macro %s\n", identifier);
   }

   _mesa_hash_table_insert(parser->defines, identifier, macro);
}

static int
glcpp_parser_lex(YYSTYPE *yylval, YYLTYPE *yylloc, glcpp_parser_t *parser)
{
   token_node_t *node;
   int ret;

   if (parser->lex_from_list == NULL) {
      ret = glcpp_lex(yylval, yylloc, parser->scanner);

      /* XXX: This ugly block of code exists for the sole
       * purpose of converting a NEWLINE token into a SPACE
       * token, but only in the case where we have seen a
       * function-like macro name, but have not yet seen its
       * closing parenthesis.
       *
       * There's perhaps a more compact way to do this with
       * mid-rule actions in the grammar.
       *
       * I'm definitely not pleased with the complexity of
       * this code here.
       */
      if (parser->newline_as_space) {
         if (ret == '(') {
            parser->paren_count++;
         } else if (ret == ')') {
            parser->paren_count--;
            if (parser->paren_count == 0)
               parser->newline_as_space = 0;
         } else if (ret == NEWLINE) {
            ret = SPACE;
         } else if (ret != SPACE) {
            if (parser->paren_count == 0)
               parser->newline_as_space = 0;
         }
      } else if (parser->in_control_line) {
         if (ret == NEWLINE)
            parser->in_control_line = 0;
      }
      else if (ret == DEFINE_TOKEN || ret == UNDEF || ret == IF ||
               ret == IFDEF || ret == IFNDEF || ret == ELIF || ret == ELSE ||
               ret == ENDIF || ret == HASH_TOKEN) {
         parser->in_control_line = 1;
      } else if (ret == IDENTIFIER) {
         struct hash_entry *entry = _mesa_hash_table_search(parser->defines,
                                                            yylval->str);
         macro_t *macro = entry ? entry->data : NULL;
         if (macro && macro->is_function) {
            parser->newline_as_space = 1;
            parser->paren_count = 0;
         }
      }

      return ret;
   }

   node = parser->lex_from_node;

   if (node == NULL) {
      ralloc_free (parser->lex_from_list);
      parser->lex_from_list = NULL;
      return NEWLINE;
   }

   *yylval = node->token->value;
   ret = node->token->type;

   parser->lex_from_node = node->next;

   return ret;
}

static void
glcpp_parser_lex_from(glcpp_parser_t *parser, token_list_t *list)
{
   token_node_t *node;

   assert (parser->lex_from_list == NULL);

   /* Copy list, eliminating any space tokens. */
   parser->lex_from_list = _token_list_create (parser);

   for (node = list->head; node; node = node->next) {
      if (node->token->type == SPACE)
         continue;
      _token_list_append (parser->lex_from_list, node->token);
   }

   ralloc_free (list);

   parser->lex_from_node = parser->lex_from_list->head;

   /* It's possible the list consisted of nothing but whitespace. */
   if (parser->lex_from_node == NULL) {
      ralloc_free (parser->lex_from_list);
      parser->lex_from_list = NULL;
   }
}

static void
_glcpp_parser_skip_stack_push_if(glcpp_parser_t *parser, YYLTYPE *loc,
                                 int condition)
{
   skip_type_t current = SKIP_NO_SKIP;
   skip_node_t *node;

   if (parser->skip_stack)
      current = parser->skip_stack->type;

   node = ralloc (parser, skip_node_t);
   node->loc = *loc;

   if (current == SKIP_NO_SKIP) {
      if (condition)
         node->type = SKIP_NO_SKIP;
      else
         node->type = SKIP_TO_ELSE;
   } else {
      node->type = SKIP_TO_ENDIF;
   }

   node->has_else = false;
   node->next = parser->skip_stack;
   parser->skip_stack = node;
}

static void
_glcpp_parser_skip_stack_change_if(glcpp_parser_t *parser, YYLTYPE *loc,
                                   const char *type, int condition)
{
   if (parser->skip_stack == NULL) {
      glcpp_error (loc, parser, "#%s without #if\n", type);
      return;
   }

   if (parser->skip_stack->type == SKIP_TO_ELSE) {
      if (condition)
         parser->skip_stack->type = SKIP_NO_SKIP;
   } else {
      parser->skip_stack->type = SKIP_TO_ENDIF;
   }
}

static void
_glcpp_parser_skip_stack_pop(glcpp_parser_t *parser, YYLTYPE *loc)
{
   skip_node_t *node;

   if (parser->skip_stack == NULL) {
      glcpp_error (loc, parser, "#endif without #if\n");
      return;
   }

   node = parser->skip_stack;
   parser->skip_stack = node->next;
   ralloc_free (node);
}

static void
_glcpp_parser_handle_version_declaration(glcpp_parser_t *parser, intmax_t version,
                                         const char *es_identifier,
                                         bool explicitly_set)
{
   if (parser->version_set)
      return;

   parser->version = version;
   parser->version_set = true;

   add_builtin_define (parser, "__VERSION__", version);

   parser->is_gles = (version == 100) ||
                     (es_identifier && (strcmp(es_identifier, "es") == 0));

   /* Add pre-defined macros. */
   if (parser->is_gles)
      add_builtin_define(parser, "GL_ES", 1);
   else if (version >= 150)
      add_builtin_define(parser, "GL_core_profile", 1);

   /* Currently, all ES2/ES3 implementations support highp in the
    * fragment shader, so we always define this macro in ES2/ES3.
    * If we ever get a driver that doesn't support highp, we'll
    * need to add a flag to the gl_context and check that here.
    */
   if (version >= 130 || parser->is_gles)
      add_builtin_define (parser, "GL_FRAGMENT_PRECISION_HIGH", 1);

   /* Add all the extension macros available in this context */
   if (parser->extensions)
      parser->extensions(parser->state, add_builtin_define, parser,
                         version, parser->is_gles);

   if (explicitly_set) {
      ralloc_asprintf_rewrite_tail(&parser->output, &parser->output_length,
                                   "#version %" PRIiMAX "%s%s", version,
                                   es_identifier ? " " : "",
                                   es_identifier ? es_identifier : "");
   }
}

/* GLSL version if no version is explicitly specified. */
#define IMPLICIT_GLSL_VERSION 110

/* GLSL ES version if no version is explicitly specified. */
#define IMPLICIT_GLSL_ES_VERSION 100

void
glcpp_parser_resolve_implicit_version(glcpp_parser_t *parser)
{
   int language_version = parser->api == API_OPENGLES2 ?
                          IMPLICIT_GLSL_ES_VERSION : IMPLICIT_GLSL_VERSION;

   _glcpp_parser_handle_version_declaration(parser, language_version,
                                            NULL, false);
}
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
yyerror (YYLTYPE *locp, glcpp_parser_t *parser, const char *error);
d39 4
a42 4
_define_object_macro (glcpp_parser_t *parser,
		      YYLTYPE *loc,
		      const char *macro,
		      token_list_t *replacements);
d45 5
a49 5
_define_function_macro (glcpp_parser_t *parser,
			YYLTYPE *loc,
			const char *macro,
			string_list_t *parameters,
			token_list_t *replacements);
d52 1
a52 1
_string_list_create (void *ctx);
d55 1
a55 1
_string_list_append_item (string_list_t *list, const char *str);
d58 1
a58 1
_string_list_contains (string_list_t *list, const char *member, int *index);
d61 1
a61 1
_string_list_has_duplicate (string_list_t *list);
d64 1
a64 1
_string_list_length (string_list_t *list);
d67 1
a67 1
_string_list_equal (string_list_t *a, string_list_t *b);
d70 1
a70 1
_argument_list_create (void *ctx);
d73 1
a73 1
_argument_list_append (argument_list_t *list, token_list_t *argument);
d76 1
a76 1
_argument_list_length (argument_list_t *list);
d79 1
a79 1
_argument_list_member_at (argument_list_t *list, int index);
d83 1
a83 1
_token_create_str (void *ctx, int type, char *str);
d86 1
a86 1
_token_create_ival (void *ctx, int type, int ival);
d89 1
a89 1
_token_list_create (void *ctx);
d92 1
a92 1
_token_list_append (token_list_t *list, token_t *token);
d95 1
a95 1
_token_list_append_list (token_list_t *list, token_list_t *tail);
d98 1
a98 1
_token_list_equal_ignoring_space (token_list_t *a, token_list_t *b);
d101 2
a102 3
_parser_active_list_push (glcpp_parser_t *parser,
			  const char *identifier,
			  token_node_t *marker);
d105 1
a105 1
_parser_active_list_pop (glcpp_parser_t *parser);
d108 1
a108 1
_parser_active_list_contains (glcpp_parser_t *parser, const char *identifier);
d111 2
a112 2
	EXPANSION_MODE_IGNORE_DEFINED,
	EXPANSION_MODE_EVALUATE_DEFINED
d119 2
a120 4
_glcpp_parser_expand_and_lex_from (glcpp_parser_t *parser,
				   int head_token_type,
				   token_list_t *list,
				   expansion_mode_t mode);
d124 2
a125 3
_glcpp_parser_expand_token_list (glcpp_parser_t *parser,
				 token_list_t *list,
				 expansion_mode_t mode);
d128 2
a129 2
_glcpp_parser_print_expanded_token_list (glcpp_parser_t *parser,
					 token_list_t *list);
d132 2
a133 2
_glcpp_parser_skip_stack_push_if (glcpp_parser_t *parser, YYLTYPE *loc,
				  int condition);
d136 2
a137 2
_glcpp_parser_skip_stack_change_if (glcpp_parser_t *parser, YYLTYPE *loc,
				    const char *type, int condition);
d140 1
a140 1
_glcpp_parser_skip_stack_pop (glcpp_parser_t *parser, YYLTYPE *loc);
d147 1
a147 1
glcpp_parser_lex (YYSTYPE *yylval, YYLTYPE *yylloc, glcpp_parser_t *parser);
d150 1
a150 1
glcpp_parser_lex_from (glcpp_parser_t *parser, token_list_t *list);
d162 5
a166 5
	@@$.first_line = 1;
	@@$.first_column = 1;
	@@$.last_line = 1;
	@@$.last_column = 1;
	@@$.source = 0;
d174 1
a174 1
	/* We use HASH_TOKEN, DEFINE_TOKEN and VERSION_TOKEN (as opposed to
d179 1
a179 1
%type <ival> INTEGER operator SPACE integer_constant
d265 1
a265 3
|	HASH_TOKEN LINE {
		glcpp_parser_resolve_implicit_version(parser);
	} pp_tokens NEWLINE {
d271 1
a271 1
							   LINE_EXPANDED, $4,
d278 2
a279 6
	HASH_TOKEN DEFINE_TOKEN {
		glcpp_parser_resolve_implicit_version(parser);
	} define
|	HASH_TOKEN UNDEF {
		glcpp_parser_resolve_implicit_version(parser);
	} IDENTIFIER NEWLINE {
d281 29
a309 4
		if (strcmp("__LINE__", $4) == 0
		    || strcmp("__FILE__", $4) == 0
		    || strcmp("__VERSION__", $4) == 0
		    || strncmp("GL_", $4, 3) == 0)
d313 4
a316 3
		macro = hash_table_find (parser->defines, $4);
		if (macro) {
			hash_table_remove (parser->defines, $4);
d319 1
a319 1
		ralloc_free ($4);
d321 1
a321 3
|	HASH_TOKEN IF {
		glcpp_parser_resolve_implicit_version(parser);
	} pp_tokens NEWLINE {
d333 1
a333 1
							   IF_EXPANDED, $4,
d352 5
a356 5
|	HASH_TOKEN IFDEF {
		glcpp_parser_resolve_implicit_version(parser);
	} IDENTIFIER junk NEWLINE {
		macro_t *macro = hash_table_find (parser->defines, $4);
		ralloc_free ($4);
d359 4
a362 5
|	HASH_TOKEN IFNDEF {
		glcpp_parser_resolve_implicit_version(parser);
	} IDENTIFIER junk NEWLINE {
		macro_t *macro = hash_table_find (parser->defines, $4);
		ralloc_free ($4);
d427 2
a428 2
|	HASH_TOKEN VERSION_TOKEN integer_constant NEWLINE {
		if (parser->version_resolved) {
d433 2
a434 2
|	HASH_TOKEN VERSION_TOKEN integer_constant IDENTIFIER NEWLINE {
		if (parser->version_resolved) {
d473 11
d769 1
a769 1
_string_list_create (void *ctx)
d771 1
a771 1
	string_list_t *list;
d773 3
a775 3
	list = ralloc (ctx, string_list_t);
	list->head = NULL;
	list->tail = NULL;
d777 1
a777 1
	return list;
d781 1
a781 1
_string_list_append_item (string_list_t *list, const char *str)
d783 1
a783 1
	string_node_t *node;
d785 2
a786 2
	node = ralloc (list, string_node_t);
	node->str = ralloc_strdup (node, str);
d788 1
a788 1
	node->next = NULL;
d790 5
a794 5
	if (list->head == NULL) {
		list->head = node;
	} else {
		list->tail->next = node;
	}
d796 1
a796 1
	list->tail = node;
d800 1
a800 1
_string_list_contains (string_list_t *list, const char *member, int *index)
d802 2
a803 2
	string_node_t *node;
	int i;
d805 2
a806 2
	if (list == NULL)
		return 0;
d808 7
a814 7
	for (i = 0, node = list->head; node; i++, node = node->next) {
		if (strcmp (node->str, member) == 0) {
			if (index)
				*index = i;
			return 1;
		}
	}
d816 1
a816 1
	return 0;
d821 1
a821 1
_string_list_has_duplicate (string_list_t *list)
d823 1
a823 1
	string_node_t *node, *dup;
d825 2
a826 2
	if (list == NULL)
		return NULL;
d828 6
a833 6
	for (node = list->head; node; node = node->next) {
		for (dup = node->next; dup; dup = dup->next) {
			if (strcmp (node->str, dup->str) == 0)
				return node->str;
		}
	}
d835 1
a835 1
	return NULL;
d839 1
a839 1
_string_list_length (string_list_t *list)
d841 2
a842 2
	int length = 0;
	string_node_t *node;
d844 2
a845 2
	if (list == NULL)
		return 0;
d847 2
a848 2
	for (node = list->head; node; node = node->next)
		length++;
d850 1
a850 1
	return length;
d854 1
a854 1
_string_list_equal (string_list_t *a, string_list_t *b)
d856 1
a856 1
	string_node_t *node_a, *node_b;
d858 2
a859 2
	if (a == NULL && b == NULL)
		return 1;
d861 15
a875 15
	if (a == NULL || b == NULL)
		return 0;

	for (node_a = a->head, node_b = b->head;
	     node_a && node_b;
	     node_a = node_a->next, node_b = node_b->next)
	{
		if (strcmp (node_a->str, node_b->str))
			return 0;
	}

	/* Catch the case of lists being different lengths, (which
	 * would cause the loop above to terminate after the shorter
	 * list). */
	return node_a == node_b;
d879 1
a879 1
_argument_list_create (void *ctx)
d881 1
a881 1
	argument_list_t *list;
d883 3
a885 3
	list = ralloc (ctx, argument_list_t);
	list->head = NULL;
	list->tail = NULL;
d887 1
a887 1
	return list;
d891 1
a891 1
_argument_list_append (argument_list_t *list, token_list_t *argument)
d893 1
a893 1
	argument_node_t *node;
d895 2
a896 2
	node = ralloc (list, argument_node_t);
	node->argument = argument;
d898 1
a898 1
	node->next = NULL;
d900 5
a904 5
	if (list->head == NULL) {
		list->head = node;
	} else {
		list->tail->next = node;
	}
d906 1
a906 1
	list->tail = node;
d910 1
a910 1
_argument_list_length (argument_list_t *list)
d912 2
a913 2
	int length = 0;
	argument_node_t *node;
d915 2
a916 2
	if (list == NULL)
		return 0;
d918 2
a919 2
	for (node = list->head; node; node = node->next)
		length++;
d921 1
a921 1
	return length;
d925 1
a925 1
_argument_list_member_at (argument_list_t *list, int index)
d927 2
a928 2
	argument_node_t *node;
	int i;
d930 2
a931 2
	if (list == NULL)
		return NULL;
d933 6
a938 6
	node = list->head;
	for (i = 0; i < index; i++) {
		node = node->next;
		if (node == NULL)
			break;
	}
d940 2
a941 2
	if (node)
		return node->argument;
d943 1
a943 1
	return NULL;
d948 1
a948 1
_token_create_str (void *ctx, int type, char *str)
d950 1
a950 1
	token_t *token;
d952 3
a954 3
	token = ralloc (ctx, token_t);
	token->type = type;
	token->value.str = str;
d956 1
a956 1
	ralloc_steal (token, str);
d958 1
a958 1
	return token;
d962 1
a962 1
_token_create_ival (void *ctx, int type, int ival)
d964 1
a964 1
	token_t *token;
d966 3
a968 3
	token = ralloc (ctx, token_t);
	token->type = type;
	token->value.ival = ival;
d970 1
a970 1
	return token;
d974 1
a974 1
_token_list_create (void *ctx)
d976 1
a976 1
	token_list_t *list;
d978 4
a981 4
	list = ralloc (ctx, token_list_t);
	list->head = NULL;
	list->tail = NULL;
	list->non_space_tail = NULL;
d983 1
a983 1
	return list;
d987 1
a987 1
_token_list_append (token_list_t *list, token_t *token)
d989 1
a989 11
	token_node_t *node;

	node = ralloc (list, token_node_t);
	node->token = token;
	node->next = NULL;

	if (list->head == NULL) {
		list->head = node;
	} else {
		list->tail->next = node;
	}
d991 13
a1003 3
	list->tail = node;
	if (token->type != SPACE)
		list->non_space_tail = node;
d1007 1
a1007 1
_token_list_append_list (token_list_t *list, token_list_t *tail)
d1009 2
a1010 2
	if (tail == NULL || tail->head == NULL)
		return;
d1012 5
a1016 5
	if (list->head == NULL) {
		list->head = tail->head;
	} else {
		list->tail->next = tail->head;
	}
d1018 2
a1019 2
	list->tail = tail->tail;
	list->non_space_tail = tail->non_space_tail;
d1023 1
a1023 1
_token_list_copy (void *ctx, token_list_t *other)
d1025 2
a1026 2
	token_list_t *copy;
	token_node_t *node;
d1028 2
a1029 2
	if (other == NULL)
		return NULL;
d1031 6
a1036 6
	copy = _token_list_create (ctx);
	for (node = other->head; node; node = node->next) {
		token_t *new_token = ralloc (copy, token_t);
		*new_token = *node->token;
		_token_list_append (copy, new_token);
	}
d1038 1
a1038 1
	return copy;
d1042 1
a1042 1
_token_list_trim_trailing_space (token_list_t *list)
d1044 1
a1044 1
	token_node_t *tail, *next;
d1046 4
a1049 4
	if (list->non_space_tail) {
		tail = list->non_space_tail->next;
		list->non_space_tail->next = NULL;
		list->tail = list->non_space_tail;
d1051 6
a1056 6
		while (tail) {
			next = tail->next;
			ralloc_free (tail);
			tail = next;
		}
	}
d1060 1
a1060 1
_token_list_is_empty_ignoring_space (token_list_t *l)
d1062 1
a1062 1
	token_node_t *n;
d1064 2
a1065 2
	if (l == NULL)
		return 1;
d1067 3
a1069 3
	n = l->head;
	while (n != NULL && n->token->type == SPACE)
		n = n->next;
d1071 1
a1071 1
	return n == NULL;
d1075 1
a1075 1
_token_list_equal_ignoring_space (token_list_t *a, token_list_t *b)
d1077 1
a1077 33
	token_node_t *node_a, *node_b;

	if (a == NULL || b == NULL) {
		int a_empty = _token_list_is_empty_ignoring_space(a);
		int b_empty = _token_list_is_empty_ignoring_space(b);
		return a_empty == b_empty;
	}

	node_a = a->head;
	node_b = b->head;

	while (1)
	{
		if (node_a == NULL && node_b == NULL)
			break;

		if (node_a == NULL || node_b == NULL)
			return 0;
		/* Make sure whitespace appears in the same places in both.
		 * It need not be exactly the same amount of whitespace,
		 * though.
		 */
		if (node_a->token->type == SPACE
		    && node_b->token->type == SPACE) {
			while (node_a && node_a->token->type == SPACE)
				node_a = node_a->next;
			while (node_b && node_b->token->type == SPACE)
				node_b = node_b->next;
			continue;
		}

		if (node_a->token->type != node_b->token->type)
			return 0;
d1079 114
a1192 18
		switch (node_a->token->type) {
		case INTEGER:
			if (node_a->token->value.ival != 
			    node_b->token->value.ival)
			{
				return 0;
			}
			break;
		case IDENTIFIER:
		case INTEGER_STRING:
		case OTHER:
			if (strcmp (node_a->token->value.str,
				    node_b->token->value.str))
			{
				return 0;
			}
			break;
		}
d1194 2
a1195 71
		node_a = node_a->next;
		node_b = node_b->next;
	}

	return 1;
}

static void
_token_print (char **out, size_t *len, token_t *token)
{
	if (token->type < 256) {
		ralloc_asprintf_rewrite_tail (out, len, "%c", token->type);
		return;
	}

	switch (token->type) {
	case INTEGER:
		ralloc_asprintf_rewrite_tail (out, len, "%" PRIiMAX, token->value.ival);
		break;
	case IDENTIFIER:
	case INTEGER_STRING:
	case OTHER:
		ralloc_asprintf_rewrite_tail (out, len, "%s", token->value.str);
		break;
	case SPACE:
		ralloc_asprintf_rewrite_tail (out, len, " ");
		break;
	case LEFT_SHIFT:
		ralloc_asprintf_rewrite_tail (out, len, "<<");
		break;
	case RIGHT_SHIFT:
		ralloc_asprintf_rewrite_tail (out, len, ">>");
		break;
	case LESS_OR_EQUAL:
		ralloc_asprintf_rewrite_tail (out, len, "<=");
		break;
	case GREATER_OR_EQUAL:
		ralloc_asprintf_rewrite_tail (out, len, ">=");
		break;
	case EQUAL:
		ralloc_asprintf_rewrite_tail (out, len, "==");
		break;
	case NOT_EQUAL:
		ralloc_asprintf_rewrite_tail (out, len, "!=");
		break;
	case AND:
		ralloc_asprintf_rewrite_tail (out, len, "&&");
		break;
	case OR:
		ralloc_asprintf_rewrite_tail (out, len, "||");
		break;
	case PASTE:
		ralloc_asprintf_rewrite_tail (out, len, "##");
		break;
        case PLUS_PLUS:
		ralloc_asprintf_rewrite_tail (out, len, "++");
		break;
        case MINUS_MINUS:
		ralloc_asprintf_rewrite_tail (out, len, "--");
		break;
	case DEFINED:
		ralloc_asprintf_rewrite_tail (out, len, "defined");
		break;
	case PLACEHOLDER:
		/* Nothing to print. */
		break;
	default:
		assert(!"Error: Don't know how to print token.");

		break;
	}
d1205 1
a1205 1
_token_paste (glcpp_parser_t *parser, token_t *token, token_t *other)
d1207 1
a1207 1
	token_t *combined = NULL;
d1209 101
a1309 106
	/* Pasting a placeholder onto anything makes no change. */
	if (other->type == PLACEHOLDER)
		return token;

	/* When 'token' is a placeholder, just return 'other'. */
	if (token->type == PLACEHOLDER)
		return other;

	/* A very few single-character punctuators can be combined
	 * with another to form a multi-character punctuator. */
	switch (token->type) {
	case '<':
		if (other->type == '<')
			combined = _token_create_ival (token, LEFT_SHIFT, LEFT_SHIFT);
		else if (other->type == '=')
			combined = _token_create_ival (token, LESS_OR_EQUAL, LESS_OR_EQUAL);
		break;
	case '>':
		if (other->type == '>')
			combined = _token_create_ival (token, RIGHT_SHIFT, RIGHT_SHIFT);
		else if (other->type == '=')
			combined = _token_create_ival (token, GREATER_OR_EQUAL, GREATER_OR_EQUAL);
		break;
	case '=':
		if (other->type == '=')
			combined = _token_create_ival (token, EQUAL, EQUAL);
		break;
	case '!':
		if (other->type == '=')
			combined = _token_create_ival (token, NOT_EQUAL, NOT_EQUAL);
		break;
	case '&':
		if (other->type == '&')
			combined = _token_create_ival (token, AND, AND);
		break;
	case '|':
		if (other->type == '|')
			combined = _token_create_ival (token, OR, OR);
		break;
	}

	if (combined != NULL) {
		/* Inherit the location from the first token */
		combined->location = token->location;
		return combined;
	}

	/* Two string-valued (or integer) tokens can usually just be
	 * mashed together. (We also handle a string followed by an
	 * integer here as well.)
	 *
	 * There are some exceptions here. Notably, if the first token
	 * is an integer (or a string representing an integer), then
	 * the second token must also be an integer or must be a
	 * string representing an integer that begins with a digit.
	 */
	if ((token->type == IDENTIFIER || token->type == OTHER || token->type == INTEGER_STRING || token->type == INTEGER) &&
	    (other->type == IDENTIFIER || other->type == OTHER || other->type == INTEGER_STRING || other->type == INTEGER))
	{
		char *str;
		int combined_type;

		/* Check that pasting onto an integer doesn't create a
		 * non-integer, (that is, only digits can be
		 * pasted. */
		if (token->type == INTEGER_STRING || token->type == INTEGER)
		{
			switch (other->type) {
			case INTEGER_STRING:
				if (other->value.str[0] < '0' ||
				    other->value.str[0] > '9')
					goto FAIL;
				break;
			case INTEGER:
				if (other->value.ival < 0)
					goto FAIL;
				break;
			default:
				goto FAIL;
			}
		}

		if (token->type == INTEGER)
			str = ralloc_asprintf (token, "%" PRIiMAX,
					       token->value.ival);
		else
			str = ralloc_strdup (token, token->value.str);
					       

		if (other->type == INTEGER)
			ralloc_asprintf_append (&str, "%" PRIiMAX,
						other->value.ival);
		else
			ralloc_strcat (&str, other->value.str);

		/* New token is same type as original token, unless we
		 * started with an integer, in which case we will be
		 * creating an integer-string. */
		combined_type = token->type;
		if (combined_type == INTEGER)
			combined_type = INTEGER_STRING;

		combined = _token_create_str (token, combined_type, str);
		combined->location = token->location;
		return combined;
	}
d1312 6
a1317 6
	glcpp_error (&token->location, parser, "");
	ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "Pasting \"");
	_token_print (&parser->info_log, &parser->info_log_length, token);
	ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "\" and \"");
	_token_print (&parser->info_log, &parser->info_log_length, other);
	ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "\" does not give a valid preprocessing token.\n");
d1319 1
a1319 1
	return token;
d1323 1
a1323 1
_token_list_print (glcpp_parser_t *parser, token_list_t *list)
d1325 1
a1325 1
	token_node_t *node;
d1327 2
a1328 2
	if (list == NULL)
		return;
d1330 2
a1331 2
	for (node = list->head; node; node = node->next)
		_token_print (&parser->output, &parser->output_length, node->token);
d1335 1
a1335 1
yyerror (YYLTYPE *locp, glcpp_parser_t *parser, const char *error)
d1337 1
a1337 1
	glcpp_error(locp, parser, "%s", error);
d1340 2
a1341 2
static void add_builtin_define(glcpp_parser_t *parser,
			       const char *name, int value)
d1354 1
a1354 1
glcpp_parser_create (const struct gl_extensions *extensions, gl_api api)
d1356 1
a1356 1
	glcpp_parser_t *parser;
d1358 1
a1358 1
	parser = ralloc (NULL, glcpp_parser_t);
d1360 36
a1395 34
	glcpp_lex_init_extra (parser, &parser->scanner);
	parser->defines = hash_table_ctor (32, hash_table_string_hash,
					   hash_table_string_compare);
	parser->active = NULL;
	parser->lexing_directive = 0;
	parser->space_tokens = 1;
	parser->last_token_was_newline = 0;
	parser->last_token_was_space = 0;
	parser->first_non_space_token_this_line = 1;
	parser->newline_as_space = 0;
	parser->in_control_line = 0;
	parser->paren_count = 0;
        parser->commented_newlines = 0;

	parser->skip_stack = NULL;
	parser->skipping = 0;

	parser->lex_from_list = NULL;
	parser->lex_from_node = NULL;

	parser->output = ralloc_strdup(parser, "");
	parser->output_length = 0;
	parser->info_log = ralloc_strdup(parser, "");
	parser->info_log_length = 0;
	parser->error = 0;

        parser->extensions = extensions;
        parser->api = api;
        parser->version_resolved = false;

	parser->has_new_line_number = 0;
	parser->new_line_number = 1;
	parser->has_new_source_number = 0;
	parser->new_source_number = 0;
d1397 1
a1397 1
	return parser;
d1401 1
a1401 1
glcpp_parser_destroy (glcpp_parser_t *parser)
d1403 3
a1405 3
	glcpp_lex_destroy (parser->scanner);
	hash_table_dtor (parser->defines);
	ralloc_free (parser);
d1410 3
a1412 3
	FUNCTION_STATUS_SUCCESS,
	FUNCTION_NOT_A_FUNCTION,
	FUNCTION_UNBALANCED_PARENTHESES
d1427 1
a1427 1
 *	Successfully parsed a set of function arguments.	
d1431 2
a1432 2
 *	Macro name not followed by a '('. This is not an error, but
 *	simply that the macro name should be treated as a non-macro.
d1436 1
a1436 1
 *	Macro name is not followed by a balanced set of parentheses.
d1439 2
a1440 3
_arguments_parse (argument_list_t *arguments,
		  token_node_t *node,
		  token_node_t **last)
d1442 2
a1443 4
	token_list_t *argument;
	int paren_count;

	node = node->next;
d1445 1
a1445 3
	/* Ignore whitespace before first parenthesis. */
	while (node && node->token->type == SPACE)
		node = node->next;
d1447 34
a1480 2
	if (node == NULL || node->token->type != '(')
		return FUNCTION_NOT_A_FUNCTION;
d1482 2
a1483 1
	node = node->next;
d1485 1
a1485 2
	argument = _token_list_create (arguments);
	_argument_list_append (arguments, argument);
d1487 1
a1487 36
	for (paren_count = 1; node; node = node->next) {
		if (node->token->type == '(')
		{
			paren_count++;
		}
		else if (node->token->type == ')')
		{
			paren_count--;
			if (paren_count == 0)
				break;
		}

		if (node->token->type == ',' &&
			 paren_count == 1)
		{
			_token_list_trim_trailing_space (argument);
			argument = _token_list_create (arguments);
			_argument_list_append (arguments, argument);
		}
		else {
			if (argument->head == NULL) {
				/* Don't treat initial whitespace as
				 * part of the argument. */
				if (node->token->type == SPACE)
					continue;
			}
			_token_list_append (argument, node->token);
		}
	}

	if (paren_count)
		return FUNCTION_UNBALANCED_PARENTHESES;

	*last = node;

	return FUNCTION_STATUS_SUCCESS;
d1491 1
a1491 1
_token_list_create_with_one_ival (void *ctx, int type, int ival)
d1493 2
a1494 2
	token_list_t *list;
	token_t *node;
d1496 3
a1498 3
	list = _token_list_create (ctx);
	node = _token_create_ival (list, type, ival);
	_token_list_append (list, node);
d1500 1
a1500 1
	return list;
d1504 1
a1504 1
_token_list_create_with_one_space (void *ctx)
d1506 1
a1506 1
	return _token_list_create_with_one_ival (ctx, SPACE, SPACE);
d1510 1
a1510 1
_token_list_create_with_one_integer (void *ctx, int ival)
d1512 1
a1512 1
	return _token_list_create_with_one_ival (ctx, INTEGER, ival);
d1524 1
a1524 1
 *	If the identifier is a defined macro, this function returns 1.
d1526 1
a1526 1
 *	If the identifier is not a defined macro, this function returns 0.
d1528 3
a1530 3
 *	In either case, *last will be updated to the last node in the list
 *	consumed by the evaluation, (either the token of the identifier or the
 *	token of the closing parenthesis).
d1537 2
a1538 3
_glcpp_parser_evaluate_defined (glcpp_parser_t *parser,
				token_node_t *node,
				token_node_t **last)
d1540 1
a1540 1
	token_node_t *argument, *defined = node;
d1542 1
a1542 1
	assert (node->token->type == DEFINED);
d1544 1
a1544 1
	node = node->next;
d1546 3
a1548 3
	/* Ignore whitespace after DEFINED token. */
	while (node && node->token->type == SPACE)
		node = node->next;
d1550 2
a1551 2
	if (node == NULL)
		goto FAIL;
d1553 4
a1556 4
	if (node->token->type == IDENTIFIER || node->token->type == OTHER) {
		argument = node;
	} else if (node->token->type == '(') {
		node = node->next;
d1558 3
a1560 3
		/* Ignore whitespace after '(' token. */
		while (node && node->token->type == SPACE)
			node = node->next;
d1562 4
a1565 5
		if (node == NULL || (node->token->type != IDENTIFIER &&
				     node->token->type != OTHER))
		{
			goto FAIL;
		}
d1567 1
a1567 1
		argument = node;
d1569 1
a1569 1
		node = node->next;
d1571 3
a1573 3
		/* Ignore whitespace after identifier, before ')' token. */
		while (node && node->token->type == SPACE)
			node = node->next;
d1575 5
a1579 5
		if (node == NULL || node->token->type != ')')
			goto FAIL;
	} else {
		goto FAIL;
	}
d1581 1
a1581 1
	*last = node;
d1583 2
a1584 2
	return hash_table_find (parser->defines,
				argument->token->value.str) ? 1 : 0;
d1587 3
a1589 3
	glcpp_error (&defined->token->location, parser,
		     "\"defined\" not followed by an identifier");
	return -1;
d1595 2
a1596 2
_glcpp_parser_evaluate_defined_in_list (glcpp_parser_t *parser,
					token_list_t *list)
d1598 2
a1599 17
	token_node_t *node, *node_prev, *replacement, *last = NULL;
	int value;

	if (list == NULL)
		return;

	node_prev = NULL;
	node = list->head;

	while (node) {

		if (node->token->type != DEFINED)
			goto NEXT;

		value = _glcpp_parser_evaluate_defined (parser, node, &last);
		if (value == -1)
			goto NEXT;
d1601 2
a1602 2
		replacement = ralloc (list, token_node_t);
		replacement->token = _token_create_ival (list, INTEGER, value);
d1604 31
a1634 16
		/* Splice replacement node into list, replacing from "node"
		 * through "last". */
		if (node_prev)
			node_prev->next = replacement;
		else
			list->head = replacement;
		replacement->next = last->next;
		if (last == list->tail)
			list->tail = replacement;

		node = replacement;

	NEXT:
		node_prev = node;
		node = node->next;
	}
d1646 2
a1647 4
_glcpp_parser_expand_and_lex_from (glcpp_parser_t *parser,
				   int head_token_type,
				   token_list_t *list,
				   expansion_mode_t mode)
d1649 2
a1650 2
	token_list_t *expanded;
	token_t *token;
d1652 6
a1657 6
	expanded = _token_list_create (parser);
	token = _token_create_ival (parser, head_token_type, head_token_type);
	_token_list_append (expanded, token);
	_glcpp_parser_expand_token_list (parser, list, mode);
	_token_list_append_list (expanded, list);
	glcpp_parser_lex_from (parser, expanded);
d1661 1
a1661 1
_glcpp_parser_apply_pastes (glcpp_parser_t *parser, token_list_t *list)
d1663 1
a1663 1
	token_node_t *node;
d1665 3
a1667 4
	node = list->head;
	while (node)
	{
		token_node_t *next_non_space;
d1669 4
a1672 4
		/* Look ahead for a PASTE token, skipping space. */
		next_non_space = node->next;
		while (next_non_space && next_non_space->token->type == SPACE)
			next_non_space = next_non_space->next;
d1674 2
a1675 2
		if (next_non_space == NULL)
			break;
d1677 9
a1685 4
		if (next_non_space->token->type != PASTE) {
			node = next_non_space;
			continue;
		}
d1687 4
a1690 9
		/* Now find the next non-space token after the PASTE. */
		next_non_space = next_non_space->next;
		while (next_non_space && next_non_space->token->type == SPACE)
			next_non_space = next_non_space->next;

		if (next_non_space == NULL) {
			yyerror (&node->token->location, parser, "'##' cannot appear at either end of a macro expansion\n");
			return;
		}
d1692 5
a1696 5
		node->token = _token_paste (parser, node->token, next_non_space->token);
		node->next = next_non_space->next;
		if (next_non_space == list->tail)
			list->tail = node;
	}
d1698 1
a1698 1
	list->non_space_tail = list->tail;
d1722 76
a1797 88
_glcpp_parser_expand_function (glcpp_parser_t *parser,
			       token_node_t *node,
			       token_node_t **last,
			       expansion_mode_t mode)
{
	macro_t *macro;
	const char *identifier;
	argument_list_t *arguments;
	function_status_t status;
	token_list_t *substituted;
	int parameter_index;

	identifier = node->token->value.str;

	macro = hash_table_find (parser->defines, identifier);

	assert (macro->is_function);

	arguments = _argument_list_create (parser);
	status = _arguments_parse (arguments, node, last);

	switch (status) {
	case FUNCTION_STATUS_SUCCESS:
		break;
	case FUNCTION_NOT_A_FUNCTION:
		return NULL;
	case FUNCTION_UNBALANCED_PARENTHESES:
		glcpp_error (&node->token->location, parser, "Macro %s call has unbalanced parentheses\n", identifier);
		return NULL;
	}

	/* Replace a macro defined as empty with a SPACE token. */
	if (macro->replacements == NULL) {
		ralloc_free (arguments);
		return _token_list_create_with_one_space (parser);
	}

	if (! ((_argument_list_length (arguments) == 
		_string_list_length (macro->parameters)) ||
	       (_string_list_length (macro->parameters) == 0 &&
		_argument_list_length (arguments) == 1 &&
		arguments->head->argument->head == NULL)))
	{
		glcpp_error (&node->token->location, parser,
			      "Error: macro %s invoked with %d arguments (expected %d)\n",
			      identifier,
			      _argument_list_length (arguments),
			      _string_list_length (macro->parameters));
		return NULL;
	}

	/* Perform argument substitution on the replacement list. */
	substituted = _token_list_create (arguments);

	for (node = macro->replacements->head; node; node = node->next)
	{
		if (node->token->type == IDENTIFIER &&
		    _string_list_contains (macro->parameters,
					   node->token->value.str,
					   &parameter_index))
		{
			token_list_t *argument;
			argument = _argument_list_member_at (arguments,
							     parameter_index);
			/* Before substituting, we expand the argument
			 * tokens, or append a placeholder token for
			 * an empty argument. */
			if (argument->head) {
				token_list_t *expanded_argument;
				expanded_argument = _token_list_copy (parser,
								      argument);
				_glcpp_parser_expand_token_list (parser,
								 expanded_argument,
								 mode);
				_token_list_append_list (substituted,
							 expanded_argument);
			} else {
				token_t *new_token;

				new_token = _token_create_ival (substituted,
								PLACEHOLDER,
								PLACEHOLDER);
				_token_list_append (substituted, new_token);
			}
		} else {
			_token_list_append (substituted, node->token);
		}
	}
d1799 2
a1800 2
	/* After argument substitution, and before further expansion
	 * below, implement token pasting. */
d1802 1
a1802 1
	_token_list_trim_trailing_space (substituted);
d1804 1
a1804 1
	_glcpp_parser_apply_pastes (parser, substituted);
d1806 1
a1806 1
	return substituted;
d1819 1
a1819 1
 *	As 'node' in the case of object-like macro expansion.
d1821 2
a1822 2
 *	As the token of the closing right parenthesis in the case of
 *	function-like macro expansion.
d1828 2
a1829 4
_glcpp_parser_expand_node (glcpp_parser_t *parser,
			   token_node_t *node,
			   token_node_t **last,
			   expansion_mode_t mode)
d1831 56
a1886 43
	token_t *token = node->token;
	const char *identifier;
	macro_t *macro;

	/* We only expand identifiers */
	if (token->type != IDENTIFIER) {
		return NULL;
	}

	*last = node;
	identifier = token->value.str;

	/* Special handling for __LINE__ and __FILE__, (not through
	 * the hash table). */
	if (strcmp(identifier, "__LINE__") == 0)
		return _token_list_create_with_one_integer (parser, node->token->location.first_line);

	if (strcmp(identifier, "__FILE__") == 0)
		return _token_list_create_with_one_integer (parser, node->token->location.source);

	/* Look up this identifier in the hash table. */
	macro = hash_table_find (parser->defines, identifier);

	/* Not a macro, so no expansion needed. */
	if (macro == NULL)
		return NULL;

	/* Finally, don't expand this macro if we're already actively
	 * expanding it, (to avoid infinite recursion). */
	if (_parser_active_list_contains (parser, identifier)) {
		/* We change the token type here from IDENTIFIER to
		 * OTHER to prevent any future expansion of this
		 * unexpanded token. */
		char *str;
		token_list_t *expansion;
		token_t *final;

		str = ralloc_strdup (parser, token->value.str);
		final = _token_create_str (parser, OTHER, str);
		expansion = _token_list_create (parser);
		_token_list_append (expansion, final);
		return expansion;
	}
d1888 1
a1888 14
	if (! macro->is_function)
	{
		token_list_t *replacement;

		/* Replace a macro defined as empty with a SPACE token. */
		if (macro->replacements == NULL)
			return _token_list_create_with_one_space (parser);

		replacement = _token_list_copy (parser, macro->replacements);
		_glcpp_parser_apply_pastes (parser, replacement);
		return replacement;
	}

	return _glcpp_parser_expand_function (parser, node, last, mode);
d1899 2
a1900 3
_parser_active_list_push (glcpp_parser_t *parser,
			  const char *identifier,
			  token_node_t *marker)
d1902 1
a1902 1
	active_list_t *node;
d1904 4
a1907 4
	node = ralloc (parser->active, active_list_t);
	node->identifier = ralloc_strdup (node, identifier);
	node->marker = marker;
	node->next = parser->active;
d1909 1
a1909 1
	parser->active = node;
d1913 1
a1913 1
_parser_active_list_pop (glcpp_parser_t *parser)
d1915 1
a1915 1
	active_list_t *node = parser->active;
d1917 4
a1920 4
	if (node == NULL) {
		parser->active = NULL;
		return;
	}
d1922 2
a1923 2
	node = parser->active->next;
	ralloc_free (parser->active);
d1925 1
a1925 1
	parser->active = node;
d1929 1
a1929 1
_parser_active_list_contains (glcpp_parser_t *parser, const char *identifier)
d1931 1
a1931 1
	active_list_t *node;
d1933 2
a1934 2
	if (parser->active == NULL)
		return 0;
d1936 3
a1938 3
	for (node = parser->active; node; node = node->next)
		if (strcmp (node->identifier, identifier) == 0)
			return 1;
d1940 1
a1940 1
	return 0;
d1951 12
a1962 12
 *	EXPANSION_MODE_IGNORE_DEFINED: Any resulting DEFINED tokens will be
 *		left in the final list, unevaluated. This is the correct mode
 *		for expanding any list in any context other than a
 *		preprocessor conditional, (#if or #elif).
 *
 *	EXPANSION_MODE_EVALUATE_DEFINED: Any resulting DEFINED tokens will be
 *		evaluated to 0 or 1 tokens depending on whether the following
 *		token is the name of a defined macro. If the DEFINED token is
 *		not followed by an (optionally parenthesized) identifier, then
 *		an error will be generated. This the correct mode for
 *		expanding any list in the context of a preprocessor
 *		conditional, (#if or #elif).
d1965 69
a2033 75
_glcpp_parser_expand_token_list (glcpp_parser_t *parser,
				 token_list_t *list,
				 expansion_mode_t mode)
{
	token_node_t *node_prev;
	token_node_t *node, *last = NULL;
	token_list_t *expansion;
	active_list_t *active_initial = parser->active;

	if (list == NULL)
		return;

	_token_list_trim_trailing_space (list);

	node_prev = NULL;
	node = list->head;

	if (mode == EXPANSION_MODE_EVALUATE_DEFINED)
		_glcpp_parser_evaluate_defined_in_list (parser, list);

	while (node) {

		while (parser->active && parser->active->marker == node)
			_parser_active_list_pop (parser);

		expansion = _glcpp_parser_expand_node (parser, node, &last, mode);
		if (expansion) {
			token_node_t *n;

			if (mode == EXPANSION_MODE_EVALUATE_DEFINED) {
				_glcpp_parser_evaluate_defined_in_list (parser,
									expansion);
			}

			for (n = node; n != last->next; n = n->next)
				while (parser->active &&
				       parser->active->marker == n)
				{
					_parser_active_list_pop (parser);
				}

			_parser_active_list_push (parser,
						  node->token->value.str,
						  last->next);
			
			/* Splice expansion into list, supporting a
			 * simple deletion if the expansion is
			 * empty. */
			if (expansion->head) {
				if (node_prev)
					node_prev->next = expansion->head;
				else
					list->head = expansion->head;
				expansion->tail->next = last->next;
				if (last == list->tail)
					list->tail = expansion->tail;
			} else {
				if (node_prev)
					node_prev->next = last->next;
				else
					list->head = last->next;
				if (last == list->tail)
					list->tail = NULL;
			}
		} else {
			node_prev = node;
		}
		node = node_prev ? node_prev->next : list->head;
	}

	/* Remove any lingering effects of this invocation on the
	 * active list. That is, pop until the list looks like it did
	 * at the beginning of this function. */
	while (parser->active && parser->active != active_initial)
		_parser_active_list_pop (parser);
d2035 1
a2035 1
	list->non_space_tail = list->tail;
d2039 2
a2040 2
_glcpp_parser_print_expanded_token_list (glcpp_parser_t *parser,
					 token_list_t *list)
d2042 2
a2043 2
	if (list == NULL)
		return;
d2045 1
a2045 1
	_glcpp_parser_expand_token_list (parser, list, EXPANSION_MODE_IGNORE_DEFINED);
d2047 3
a2049 3
	_token_list_trim_trailing_space (list);

	_token_list_print (parser, list);
d2053 30
a2082 31
_check_for_reserved_macro_name (glcpp_parser_t *parser, YYLTYPE *loc,
				const char *identifier)
{
	/* Section 3.3 (Preprocessor) of the GLSL 1.30 spec (and later) and
	 * the GLSL ES spec (all versions) say:
	 *
	 *     "All macro names containing two consecutive underscores ( __ )
	 *     are reserved for future use as predefined macro names. All
	 *     macro names prefixed with "GL_" ("GL" followed by a single
	 *     underscore) are also reserved."
	 *
	 * The intention is that names containing __ are reserved for internal
	 * use by the implementation, and names prefixed with GL_ are reserved
	 * for use by Khronos.  Since every extension adds a name prefixed
	 * with GL_ (i.e., the name of the extension), that should be an
	 * error.  Names simply containing __ are dangerous to use, but should
	 * be allowed.
	 *
	 * A future version of the GLSL specification will clarify this.
	 */
	if (strstr(identifier, "__")) {
		glcpp_warning(loc, parser,
			      "Macro names containing \"__\" are reserved "
			      "for use by the implementation.\n");
	}
	if (strncmp(identifier, "GL_", 3) == 0) {
		glcpp_error (loc, parser, "Macro names starting with \"GL_\" are reserved.\n");
	}
	if (strcmp(identifier, "defined") == 0) {
		glcpp_error (loc, parser, "\"defined\" cannot be used as a macro name");
	}
d2086 1
a2086 1
_macro_equal (macro_t *a, macro_t *b)
d2088 2
a2089 2
	if (a->is_function != b->is_function)
		return 0;
d2091 4
a2094 4
	if (a->is_function) {
		if (! _string_list_equal (a->parameters, b->parameters))
			return 0;
	}
d2096 1
a2096 2
	return _token_list_equal_ignoring_space (a->replacements,
						 b->replacements);
d2100 29
a2128 31
_define_object_macro (glcpp_parser_t *parser,
		      YYLTYPE *loc,
		      const char *identifier,
		      token_list_t *replacements)
{
	macro_t *macro, *previous;

	/* We define pre-defined macros before we've started parsing the
         * actual file. So if there's no location defined yet, that's what
         * were doing and we don't want to generate an error for using the
         * reserved names. */
	if (loc != NULL)
		_check_for_reserved_macro_name(parser, loc, identifier);

	macro = ralloc (parser, macro_t);

	macro->is_function = 0;
	macro->parameters = NULL;
	macro->identifier = ralloc_strdup (macro, identifier);
	macro->replacements = replacements;
	ralloc_steal (macro, replacements);

	previous = hash_table_find (parser->defines, identifier);
	if (previous) {
		if (_macro_equal (macro, previous)) {
			ralloc_free (macro);
			return;
		}
		glcpp_error (loc, parser, "Redefinition of macro %s\n",
			     identifier);
	}
d2130 1
a2130 1
	hash_table_insert (parser->defines, macro, identifier);
d2134 7
a2140 8
_define_function_macro (glcpp_parser_t *parser,
			YYLTYPE *loc,
			const char *identifier,
			string_list_t *parameters,
			token_list_t *replacements)
{
	macro_t *macro, *previous;
	const char *dup;
d2142 1
a2142 1
	_check_for_reserved_macro_name(parser, loc, identifier);
d2145 22
a2166 22
	if ((dup = _string_list_has_duplicate (parameters)) != NULL) {
		glcpp_error (loc, parser, "Duplicate macro parameter \"%s\"",
			     dup);
	}

	macro = ralloc (parser, macro_t);
	ralloc_steal (macro, parameters);
	ralloc_steal (macro, replacements);

	macro->is_function = 1;
	macro->parameters = parameters;
	macro->identifier = ralloc_strdup (macro, identifier);
	macro->replacements = replacements;
	previous = hash_table_find (parser->defines, identifier);
	if (previous) {
		if (_macro_equal (macro, previous)) {
			ralloc_free (macro);
			return;
		}
		glcpp_error (loc, parser, "Redefinition of macro %s\n",
			     identifier);
	}
d2168 1
a2168 1
	hash_table_insert (parser->defines, macro, identifier);
d2172 1
a2172 1
glcpp_parser_lex (YYSTYPE *yylval, YYLTYPE *yylloc, glcpp_parser_t *parser)
d2174 2
a2175 67
	token_node_t *node;
	int ret;

	if (parser->lex_from_list == NULL) {
		ret = glcpp_lex (yylval, yylloc, parser->scanner);

		/* XXX: This ugly block of code exists for the sole
		 * purpose of converting a NEWLINE token into a SPACE
		 * token, but only in the case where we have seen a
		 * function-like macro name, but have not yet seen its
		 * closing parenthesis.
		 *
		 * There's perhaps a more compact way to do this with
		 * mid-rule actions in the grammar.
		 *
		 * I'm definitely not pleased with the complexity of
		 * this code here.
		 */
		if (parser->newline_as_space)
		{
			if (ret == '(') {
				parser->paren_count++;
			} else if (ret == ')') {
				parser->paren_count--;
				if (parser->paren_count == 0)
					parser->newline_as_space = 0;
			} else if (ret == NEWLINE) {
				ret = SPACE;
			} else if (ret != SPACE) {
				if (parser->paren_count == 0)
					parser->newline_as_space = 0;
			}
		}
		else if (parser->in_control_line)
		{
			if (ret == NEWLINE)
				parser->in_control_line = 0;
		}
		else if (ret == DEFINE_TOKEN ||
			 ret == UNDEF || ret == IF ||
			 ret == IFDEF || ret == IFNDEF ||
			 ret == ELIF || ret == ELSE ||
			 ret == ENDIF || ret == HASH_TOKEN)
		{
			parser->in_control_line = 1;
		}
		else if (ret == IDENTIFIER)
		{
			macro_t *macro;
			macro = hash_table_find (parser->defines,
						 yylval->str);
			if (macro && macro->is_function) {
				parser->newline_as_space = 1;
				parser->paren_count = 0;
			}
		}

		return ret;
	}

	node = parser->lex_from_node;

	if (node == NULL) {
		ralloc_free (parser->lex_from_list);
		parser->lex_from_list = NULL;
		return NEWLINE;
	}
d2177 2
a2178 2
	*yylval = node->token->value;
	ret = node->token->type;
d2180 146
a2325 89
	parser->lex_from_node = node->next;

	return ret;
}

static void
glcpp_parser_lex_from (glcpp_parser_t *parser, token_list_t *list)
{
	token_node_t *node;

	assert (parser->lex_from_list == NULL);

	/* Copy list, eliminating any space tokens. */
	parser->lex_from_list = _token_list_create (parser);

	for (node = list->head; node; node = node->next) {
		if (node->token->type == SPACE)
			continue;
		_token_list_append (parser->lex_from_list, node->token);
	}

	ralloc_free (list);

	parser->lex_from_node = parser->lex_from_list->head;

	/* It's possible the list consisted of nothing but whitespace. */
	if (parser->lex_from_node == NULL) {
		ralloc_free (parser->lex_from_list);
		parser->lex_from_list = NULL;
	}
}

static void
_glcpp_parser_skip_stack_push_if (glcpp_parser_t *parser, YYLTYPE *loc,
				  int condition)
{
	skip_type_t current = SKIP_NO_SKIP;
	skip_node_t *node;

	if (parser->skip_stack)
		current = parser->skip_stack->type;

	node = ralloc (parser, skip_node_t);
	node->loc = *loc;

	if (current == SKIP_NO_SKIP) {
		if (condition)
			node->type = SKIP_NO_SKIP;
		else
			node->type = SKIP_TO_ELSE;
	} else {
		node->type = SKIP_TO_ENDIF;
	}

	node->has_else = false;
	node->next = parser->skip_stack;
	parser->skip_stack = node;
}

static void
_glcpp_parser_skip_stack_change_if (glcpp_parser_t *parser, YYLTYPE *loc,
				    const char *type, int condition)
{
	if (parser->skip_stack == NULL) {
		glcpp_error (loc, parser, "#%s without #if\n", type);
		return;
	}

	if (parser->skip_stack->type == SKIP_TO_ELSE) {
		if (condition)
			parser->skip_stack->type = SKIP_NO_SKIP;
	} else {
		parser->skip_stack->type = SKIP_TO_ENDIF;
	}
}

static void
_glcpp_parser_skip_stack_pop (glcpp_parser_t *parser, YYLTYPE *loc)
{
	skip_node_t *node;

	if (parser->skip_stack == NULL) {
		glcpp_error (loc, parser, "#endif without #if\n");
		return;
	}

	node = parser->skip_stack;
	parser->skip_stack = node->next;
	ralloc_free (node);
d2333 2
a2334 80
	const struct gl_extensions *extensions = parser->extensions;

	if (parser->version_resolved)
		return;

	parser->version_resolved = true;

	add_builtin_define (parser, "__VERSION__", version);

	parser->is_gles = (version == 100) ||
			   (es_identifier &&
			    (strcmp(es_identifier, "es") == 0));

	/* Add pre-defined macros. */
	if (parser->is_gles) {
	   add_builtin_define(parser, "GL_ES", 1);
           add_builtin_define(parser, "GL_EXT_separate_shader_objects", 1);
           add_builtin_define(parser, "GL_EXT_draw_buffers", 1);

	   if (extensions != NULL) {
	      if (extensions->OES_EGL_image_external)
	         add_builtin_define(parser, "GL_OES_EGL_image_external", 1);
              if (extensions->OES_standard_derivatives)
                 add_builtin_define(parser, "GL_OES_standard_derivatives", 1);
              if (extensions->ARB_texture_multisample)
                 add_builtin_define(parser, "GL_OES_texture_storage_multisample_2d_array", 1);
              if (extensions->ARB_blend_func_extended)
                 add_builtin_define(parser, "GL_EXT_blend_func_extended", 1);

              if (version >= 310) {
                 if (extensions->OES_geometry_shader) {
                    add_builtin_define(parser, "GL_OES_geometry_point_size", 1);
                    add_builtin_define(parser, "GL_OES_geometry_shader", 1);
                 }
              }
	   }
	} else {
	   add_builtin_define(parser, "GL_ARB_draw_buffers", 1);
           add_builtin_define(parser, "GL_ARB_enhanced_layouts", 1);
           add_builtin_define(parser, "GL_ARB_separate_shader_objects", 1);
	   add_builtin_define(parser, "GL_ARB_texture_rectangle", 1);
           add_builtin_define(parser, "GL_AMD_shader_trinary_minmax", 1);


	   if (extensions != NULL) {
	      if (extensions->EXT_texture_array)
	         add_builtin_define(parser, "GL_EXT_texture_array", 1);

	      if (extensions->ARB_arrays_of_arrays)
	          add_builtin_define(parser, "GL_ARB_arrays_of_arrays", 1);

	      if (extensions->ARB_fragment_coord_conventions)
	         add_builtin_define(parser, "GL_ARB_fragment_coord_conventions",
				    1);

              if (extensions->ARB_fragment_layer_viewport)
                 add_builtin_define(parser, "GL_ARB_fragment_layer_viewport", 1);

	      if (extensions->ARB_explicit_attrib_location)
	         add_builtin_define(parser, "GL_ARB_explicit_attrib_location", 1);

	      if (extensions->ARB_explicit_uniform_location)
	         add_builtin_define(parser, "GL_ARB_explicit_uniform_location", 1);

	      if (extensions->ARB_shader_texture_lod)
	         add_builtin_define(parser, "GL_ARB_shader_texture_lod", 1);

	      if (extensions->ARB_draw_instanced)
	         add_builtin_define(parser, "GL_ARB_draw_instanced", 1);

	      if (extensions->ARB_conservative_depth) {
	         add_builtin_define(parser, "GL_AMD_conservative_depth", 1);
	         add_builtin_define(parser, "GL_ARB_conservative_depth", 1);
	      }

	      if (extensions->ARB_shader_bit_encoding)
	         add_builtin_define(parser, "GL_ARB_shader_bit_encoding", 1);

	      if (extensions->ARB_shader_clock)
	         add_builtin_define(parser, "GL_ARB_shader_clock", 1);
d2336 2
a2337 2
	      if (extensions->ARB_uniform_buffer_object)
	         add_builtin_define(parser, "GL_ARB_uniform_buffer_object", 1);
d2339 1
a2339 2
	      if (extensions->ARB_texture_cube_map_array)
	         add_builtin_define(parser, "GL_ARB_texture_cube_map_array", 1);
d2341 28
a2368 99
	      if (extensions->ARB_shading_language_packing)
	         add_builtin_define(parser, "GL_ARB_shading_language_packing", 1);

	      if (extensions->ARB_texture_multisample)
	         add_builtin_define(parser, "GL_ARB_texture_multisample", 1);

	      if (extensions->ARB_texture_query_levels)
	         add_builtin_define(parser, "GL_ARB_texture_query_levels", 1);

	      if (extensions->ARB_texture_query_lod)
	         add_builtin_define(parser, "GL_ARB_texture_query_lod", 1);

	      if (extensions->ARB_gpu_shader5)
	         add_builtin_define(parser, "GL_ARB_gpu_shader5", 1);

              if (extensions->ARB_gpu_shader_fp64)
                 add_builtin_define(parser, "GL_ARB_gpu_shader_fp64", 1);

	      if (extensions->ARB_vertex_attrib_64bit)
	         add_builtin_define(parser, "GL_ARB_vertex_attrib_64bit", 1);

	      if (extensions->AMD_vertex_shader_layer)
	         add_builtin_define(parser, "GL_AMD_vertex_shader_layer", 1);

	      if (extensions->AMD_vertex_shader_viewport_index)
	         add_builtin_define(parser, "GL_AMD_vertex_shader_viewport_index", 1);

	      if (extensions->ARB_shading_language_420pack)
	         add_builtin_define(parser, "GL_ARB_shading_language_420pack", 1);

	      if (extensions->ARB_sample_shading)
	         add_builtin_define(parser, "GL_ARB_sample_shading", 1);

	      if (extensions->ARB_texture_gather)
	         add_builtin_define(parser, "GL_ARB_texture_gather", 1);

	      if (extensions->ARB_shader_atomic_counters)
	         add_builtin_define(parser, "GL_ARB_shader_atomic_counters", 1);

	      if (extensions->ARB_viewport_array)
	         add_builtin_define(parser, "GL_ARB_viewport_array", 1);

              if (extensions->ARB_compute_shader)
                 add_builtin_define(parser, "GL_ARB_compute_shader", 1);

	      if (extensions->ARB_shader_image_load_store)
	         add_builtin_define(parser, "GL_ARB_shader_image_load_store", 1);

              if (extensions->ARB_shader_image_size)
                 add_builtin_define(parser, "GL_ARB_shader_image_size", 1);

              if (extensions->ARB_shader_texture_image_samples)
                 add_builtin_define(parser, "GL_ARB_shader_texture_image_samples", 1);

              if (extensions->ARB_derivative_control)
                 add_builtin_define(parser, "GL_ARB_derivative_control", 1);

              if (extensions->ARB_shader_precision)
                 add_builtin_define(parser, "GL_ARB_shader_precision", 1);

	      if (extensions->ARB_shader_storage_buffer_object)
	         add_builtin_define(parser, "GL_ARB_shader_storage_buffer_object", 1);

	      if (extensions->ARB_tessellation_shader)
	         add_builtin_define(parser, "GL_ARB_tessellation_shader", 1);

              if (extensions->ARB_shader_subroutine)
                 add_builtin_define(parser, "GL_ARB_shader_subroutine", 1);

              if (extensions->ARB_shader_draw_parameters)
                 add_builtin_define(parser, "GL_ARB_shader_draw_parameters", 1);
	   }
	}

	if (extensions != NULL) {
	   if (extensions->EXT_shader_integer_mix)
	      add_builtin_define(parser, "GL_EXT_shader_integer_mix", 1);

	   if (extensions->EXT_shader_samples_identical)
	      add_builtin_define(parser, "GL_EXT_shader_samples_identical", 1);
	}

	if (version >= 150)
		add_builtin_define(parser, "GL_core_profile", 1);

	/* Currently, all ES2/ES3 implementations support highp in the
	 * fragment shader, so we always define this macro in ES2/ES3.
	 * If we ever get a driver that doesn't support highp, we'll
	 * need to add a flag to the gl_context and check that here.
	 */
	if (version >= 130 || parser->is_gles)
		add_builtin_define (parser, "GL_FRAGMENT_PRECISION_HIGH", 1);

	if (explicitly_set) {
	   ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length,
					 "#version %" PRIiMAX "%s%s", version,
					 es_identifier ? " " : "",
					 es_identifier ? es_identifier : "");
	}
d2380 2
a2381 3
	int language_version = parser->api == API_OPENGLES2 ?
			       IMPLICIT_GLSL_ES_VERSION :
			       IMPLICIT_GLSL_VERSION;
d2383 2
a2384 2
	_glcpp_parser_handle_version_declaration(parser, language_version,
						 NULL, false);
@


1.1.1.1
log
@Import Mesa 11.2.2
@
text
@@


1.1.1.2
log
@Import Mesa 13.0.2
@
text
@d36 1
a36 1
yyerror(YYLTYPE *locp, glcpp_parser_t *parser, const char *error);
d39 4
a42 4
_define_object_macro(glcpp_parser_t *parser,
                     YYLTYPE *loc,
                     const char *macro,
                     token_list_t *replacements);
d45 5
a49 5
_define_function_macro(glcpp_parser_t *parser,
                       YYLTYPE *loc,
                       const char *macro,
                       string_list_t *parameters,
                       token_list_t *replacements);
d52 1
a52 1
_string_list_create(void *ctx);
d55 1
a55 1
_string_list_append_item(string_list_t *list, const char *str);
d58 1
a58 1
_string_list_contains(string_list_t *list, const char *member, int *index);
d61 1
a61 1
_string_list_has_duplicate(string_list_t *list);
d64 1
a64 1
_string_list_length(string_list_t *list);
d67 1
a67 1
_string_list_equal(string_list_t *a, string_list_t *b);
d70 1
a70 1
_argument_list_create(void *ctx);
d73 1
a73 1
_argument_list_append(argument_list_t *list, token_list_t *argument);
d76 1
a76 1
_argument_list_length(argument_list_t *list);
d79 1
a79 1
_argument_list_member_at(argument_list_t *list, int index);
d83 1
a83 1
_token_create_str(void *ctx, int type, char *str);
d86 1
a86 1
_token_create_ival(void *ctx, int type, int ival);
d89 1
a89 1
_token_list_create(void *ctx);
d92 1
a92 1
_token_list_append(token_list_t *list, token_t *token);
d95 1
a95 1
_token_list_append_list(token_list_t *list, token_list_t *tail);
d98 1
a98 1
_token_list_equal_ignoring_space(token_list_t *a, token_list_t *b);
d101 3
a103 2
_parser_active_list_push(glcpp_parser_t *parser, const char *identifier,
                         token_node_t *marker);
d106 1
a106 1
_parser_active_list_pop(glcpp_parser_t *parser);
d109 1
a109 1
_parser_active_list_contains(glcpp_parser_t *parser, const char *identifier);
d112 2
a113 2
   EXPANSION_MODE_IGNORE_DEFINED,
   EXPANSION_MODE_EVALUATE_DEFINED
d120 4
a123 2
_glcpp_parser_expand_and_lex_from(glcpp_parser_t *parser, int head_token_type,
                                  token_list_t *list, expansion_mode_t mode);
d127 3
a129 2
_glcpp_parser_expand_token_list(glcpp_parser_t *parser, token_list_t *list,
                                expansion_mode_t mode);
d132 2
a133 2
_glcpp_parser_print_expanded_token_list(glcpp_parser_t *parser,
                                        token_list_t *list);
d136 2
a137 2
_glcpp_parser_skip_stack_push_if(glcpp_parser_t *parser, YYLTYPE *loc,
                                 int condition);
d140 2
a141 2
_glcpp_parser_skip_stack_change_if(glcpp_parser_t *parser, YYLTYPE *loc,
                                   const char *type, int condition);
d144 1
a144 1
_glcpp_parser_skip_stack_pop(glcpp_parser_t *parser, YYLTYPE *loc);
d151 1
a151 1
glcpp_parser_lex(YYSTYPE *yylval, YYLTYPE *yylloc, glcpp_parser_t *parser);
d154 1
a154 1
glcpp_parser_lex_from(glcpp_parser_t *parser, token_list_t *list);
d166 5
a170 5
   @@$.first_line = 1;
   @@$.first_column = 1;
   @@$.last_line = 1;
   @@$.last_column = 1;
   @@$.source = 0;
d178 1
a178 1
        /* We use HASH_TOKEN, DEFINE_TOKEN and VERSION_TOKEN (as opposed to
d183 1
a183 1
%type <ival> INTEGER operator SPACE integer_constant version_constant
d269 3
a271 1
|	HASH_TOKEN LINE pp_tokens NEWLINE {
d277 1
a277 1
							   LINE_EXPANDED, $3,
d284 6
a289 2
	HASH_TOKEN DEFINE_TOKEN define
|	HASH_TOKEN UNDEF IDENTIFIER NEWLINE {
d291 4
a294 29
		struct hash_entry *entry;

                /* Section 3.4 (Preprocessor) of the GLSL ES 3.00 spec says:
                 *
                 *    It is an error to undefine or to redefine a built-in
                 *    (pre-defined) macro name.
                 *
                 * The GLSL ES 1.00 spec does not contain this text.
                 *
                 * Section 3.3 (Preprocessor) of the GLSL 1.30 spec says:
                 *
                 *    #define and #undef functionality are defined as is
                 *    standard for C++ preprocessors for macro definitions
                 *    both with and without macro parameters.
                 *
                 * At least as far as I can tell GCC allow '#undef __FILE__'.
                 * Furthermore, there are desktop OpenGL conformance tests
                 * that expect '#undef __VERSION__' and '#undef
                 * GL_core_profile' to work.
                 *
                 * Only disallow #undef of pre-defined macros on GLSL ES >=
                 * 3.00 shaders.
                 */
		if (parser->is_gles &&
                    parser->version >= 300 &&
                    (strcmp("__LINE__", $3) == 0
                     || strcmp("__FILE__", $3) == 0
                     || strcmp("__VERSION__", $3) == 0
                     || strncmp("GL_", $3, 3) == 0))
d298 3
a300 4
		entry = _mesa_hash_table_search (parser->defines, $3);
		if (entry) {
			macro = entry->data;
			_mesa_hash_table_remove (parser->defines, entry);
d303 1
a303 1
		ralloc_free ($3);
d305 3
a307 1
|	HASH_TOKEN IF pp_tokens NEWLINE {
d319 1
a319 1
							   IF_EXPANDED, $3,
d338 5
a342 5
|	HASH_TOKEN IFDEF IDENTIFIER junk NEWLINE {
		struct hash_entry *entry =
				_mesa_hash_table_search(parser->defines, $3);
		macro_t *macro = entry ? entry->data : NULL;
		ralloc_free ($3);
d345 5
a349 4
|	HASH_TOKEN IFNDEF IDENTIFIER junk NEWLINE {
		struct hash_entry *entry =
				_mesa_hash_table_search(parser->defines, $3);
		macro_t *macro = entry ? entry->data : NULL;
d414 2
a415 2
|	HASH_TOKEN VERSION_TOKEN version_constant NEWLINE {
		if (parser->version_set) {
d420 2
a421 2
|	HASH_TOKEN VERSION_TOKEN version_constant IDENTIFIER NEWLINE {
		if (parser->version_set) {
a459 11
version_constant:
	INTEGER_STRING {
	   /* Both octal and hexadecimal constants begin with 0. */
	   if ($1[0] == '0' && $1[1] != '\0') {
		glcpp_error(&@@1, parser, "invalid #version \"%s\" (not a decimal constant)", $1);
		$$ = 0;
	   } else {
		$$ = strtoll($1, NULL, 10);
	   }
	}

d745 1
a745 1
_string_list_create(void *ctx)
d747 1
a747 1
   string_list_t *list;
d749 3
a751 3
   list = ralloc (ctx, string_list_t);
   list->head = NULL;
   list->tail = NULL;
d753 1
a753 1
   return list;
d757 1
a757 1
_string_list_append_item(string_list_t *list, const char *str)
d759 1
a759 1
   string_node_t *node;
d761 2
a762 2
   node = ralloc (list, string_node_t);
   node->str = ralloc_strdup (node, str);
d764 1
a764 1
   node->next = NULL;
d766 5
a770 5
   if (list->head == NULL) {
      list->head = node;
   } else {
      list->tail->next = node;
   }
d772 1
a772 1
   list->tail = node;
d776 1
a776 1
_string_list_contains(string_list_t *list, const char *member, int *index)
d778 2
a779 2
   string_node_t *node;
   int i;
d781 2
a782 2
   if (list == NULL)
      return 0;
d784 7
a790 7
   for (i = 0, node = list->head; node; i++, node = node->next) {
      if (strcmp (node->str, member) == 0) {
         if (index)
            *index = i;
         return 1;
      }
   }
d792 1
a792 1
   return 0;
d797 1
a797 1
_string_list_has_duplicate(string_list_t *list)
d799 1
a799 1
   string_node_t *node, *dup;
d801 2
a802 2
   if (list == NULL)
      return NULL;
d804 6
a809 6
   for (node = list->head; node; node = node->next) {
      for (dup = node->next; dup; dup = dup->next) {
         if (strcmp (node->str, dup->str) == 0)
            return node->str;
      }
   }
d811 1
a811 1
   return NULL;
d815 1
a815 1
_string_list_length(string_list_t *list)
d817 2
a818 2
   int length = 0;
   string_node_t *node;
d820 2
a821 2
   if (list == NULL)
      return 0;
d823 2
a824 2
   for (node = list->head; node; node = node->next)
      length++;
d826 1
a826 1
   return length;
d830 1
a830 1
_string_list_equal(string_list_t *a, string_list_t *b)
d832 1
a832 1
   string_node_t *node_a, *node_b;
d834 2
a835 2
   if (a == NULL && b == NULL)
      return 1;
d837 15
a851 15
   if (a == NULL || b == NULL)
      return 0;

   for (node_a = a->head, node_b = b->head;
        node_a && node_b;
        node_a = node_a->next, node_b = node_b->next)
   {
      if (strcmp (node_a->str, node_b->str))
         return 0;
   }

   /* Catch the case of lists being different lengths, (which
    * would cause the loop above to terminate after the shorter
    * list). */
   return node_a == node_b;
d855 1
a855 1
_argument_list_create(void *ctx)
d857 1
a857 1
   argument_list_t *list;
d859 3
a861 3
   list = ralloc (ctx, argument_list_t);
   list->head = NULL;
   list->tail = NULL;
d863 1
a863 1
   return list;
d867 1
a867 1
_argument_list_append(argument_list_t *list, token_list_t *argument)
d869 1
a869 1
   argument_node_t *node;
d871 2
a872 2
   node = ralloc (list, argument_node_t);
   node->argument = argument;
d874 1
a874 1
   node->next = NULL;
d876 5
a880 5
   if (list->head == NULL) {
      list->head = node;
   } else {
      list->tail->next = node;
   }
d882 1
a882 1
   list->tail = node;
d886 1
a886 1
_argument_list_length(argument_list_t *list)
d888 2
a889 2
   int length = 0;
   argument_node_t *node;
d891 2
a892 2
   if (list == NULL)
      return 0;
d894 2
a895 2
   for (node = list->head; node; node = node->next)
      length++;
d897 1
a897 1
   return length;
d901 1
a901 1
_argument_list_member_at(argument_list_t *list, int index)
d903 2
a904 2
   argument_node_t *node;
   int i;
d906 2
a907 2
   if (list == NULL)
      return NULL;
d909 6
a914 6
   node = list->head;
   for (i = 0; i < index; i++) {
      node = node->next;
      if (node == NULL)
         break;
   }
d916 2
a917 2
   if (node)
      return node->argument;
d919 1
a919 1
   return NULL;
d924 1
a924 1
_token_create_str(void *ctx, int type, char *str)
d926 1
a926 1
   token_t *token;
d928 3
a930 3
   token = ralloc (ctx, token_t);
   token->type = type;
   token->value.str = str;
d932 1
a932 1
   ralloc_steal (token, str);
d934 1
a934 1
   return token;
d938 1
a938 1
_token_create_ival(void *ctx, int type, int ival)
d940 1
a940 1
   token_t *token;
d942 3
a944 3
   token = ralloc (ctx, token_t);
   token->type = type;
   token->value.ival = ival;
d946 1
a946 1
   return token;
d950 1
a950 1
_token_list_create(void *ctx)
d952 1
a952 1
   token_list_t *list;
d954 4
a957 4
   list = ralloc (ctx, token_list_t);
   list->head = NULL;
   list->tail = NULL;
   list->non_space_tail = NULL;
d959 1
a959 1
   return list;
d963 1
a963 1
_token_list_append(token_list_t *list, token_t *token)
d965 11
a975 1
   token_node_t *node;
d977 3
a979 13
   node = ralloc (list, token_node_t);
   node->token = token;
   node->next = NULL;

   if (list->head == NULL) {
      list->head = node;
   } else {
      list->tail->next = node;
   }

   list->tail = node;
   if (token->type != SPACE)
      list->non_space_tail = node;
d983 1
a983 1
_token_list_append_list(token_list_t *list, token_list_t *tail)
d985 2
a986 2
   if (tail == NULL || tail->head == NULL)
      return;
d988 5
a992 5
   if (list->head == NULL) {
      list->head = tail->head;
   } else {
      list->tail->next = tail->head;
   }
d994 2
a995 2
   list->tail = tail->tail;
   list->non_space_tail = tail->non_space_tail;
d999 1
a999 1
_token_list_copy(void *ctx, token_list_t *other)
d1001 2
a1002 2
   token_list_t *copy;
   token_node_t *node;
d1004 2
a1005 2
   if (other == NULL)
      return NULL;
d1007 6
a1012 6
   copy = _token_list_create (ctx);
   for (node = other->head; node; node = node->next) {
      token_t *new_token = ralloc (copy, token_t);
      *new_token = *node->token;
      _token_list_append (copy, new_token);
   }
d1014 1
a1014 1
   return copy;
d1018 1
a1018 1
_token_list_trim_trailing_space(token_list_t *list)
d1020 1
a1020 1
   token_node_t *tail, *next;
d1022 4
a1025 4
   if (list->non_space_tail) {
      tail = list->non_space_tail->next;
      list->non_space_tail->next = NULL;
      list->tail = list->non_space_tail;
d1027 6
a1032 6
      while (tail) {
         next = tail->next;
         ralloc_free (tail);
         tail = next;
      }
   }
d1036 1
a1036 1
_token_list_is_empty_ignoring_space(token_list_t *l)
d1038 1
a1038 1
   token_node_t *n;
d1040 2
a1041 2
   if (l == NULL)
      return 1;
d1043 3
a1045 3
   n = l->head;
   while (n != NULL && n->token->type == SPACE)
      n = n->next;
d1047 1
a1047 1
   return n == NULL;
d1051 1
a1051 1
_token_list_equal_ignoring_space(token_list_t *a, token_list_t *b)
d1053 33
a1085 1
   token_node_t *node_a, *node_b;
d1087 18
a1104 114
   if (a == NULL || b == NULL) {
      int a_empty = _token_list_is_empty_ignoring_space(a);
      int b_empty = _token_list_is_empty_ignoring_space(b);
      return a_empty == b_empty;
   }

   node_a = a->head;
   node_b = b->head;

   while (1)
   {
      if (node_a == NULL && node_b == NULL)
         break;

      if (node_a == NULL || node_b == NULL)
         return 0;
      /* Make sure whitespace appears in the same places in both.
       * It need not be exactly the same amount of whitespace,
       * though.
       */
      if (node_a->token->type == SPACE && node_b->token->type == SPACE) {
         while (node_a && node_a->token->type == SPACE)
            node_a = node_a->next;
         while (node_b && node_b->token->type == SPACE)
            node_b = node_b->next;
         continue;
      }

      if (node_a->token->type != node_b->token->type)
         return 0;

      switch (node_a->token->type) {
      case INTEGER:
         if (node_a->token->value.ival !=  node_b->token->value.ival) {
            return 0;
         }
         break;
      case IDENTIFIER:
      case INTEGER_STRING:
      case OTHER:
         if (strcmp(node_a->token->value.str, node_b->token->value.str)) {
            return 0;
         }
         break;
      }

      node_a = node_a->next;
      node_b = node_b->next;
   }

   return 1;
}

static void
_token_print(char **out, size_t *len, token_t *token)
{
   if (token->type < 256) {
      ralloc_asprintf_rewrite_tail (out, len, "%c", token->type);
      return;
   }

   switch (token->type) {
   case INTEGER:
      ralloc_asprintf_rewrite_tail (out, len, "%" PRIiMAX, token->value.ival);
      break;
   case IDENTIFIER:
   case INTEGER_STRING:
   case OTHER:
      ralloc_asprintf_rewrite_tail (out, len, "%s", token->value.str);
      break;
   case SPACE:
      ralloc_asprintf_rewrite_tail (out, len, " ");
      break;
   case LEFT_SHIFT:
      ralloc_asprintf_rewrite_tail (out, len, "<<");
      break;
   case RIGHT_SHIFT:
      ralloc_asprintf_rewrite_tail (out, len, ">>");
      break;
   case LESS_OR_EQUAL:
      ralloc_asprintf_rewrite_tail (out, len, "<=");
      break;
   case GREATER_OR_EQUAL:
      ralloc_asprintf_rewrite_tail (out, len, ">=");
      break;
   case EQUAL:
      ralloc_asprintf_rewrite_tail (out, len, "==");
      break;
   case NOT_EQUAL:
      ralloc_asprintf_rewrite_tail (out, len, "!=");
      break;
   case AND:
      ralloc_asprintf_rewrite_tail (out, len, "&&");
      break;
   case OR:
      ralloc_asprintf_rewrite_tail (out, len, "||");
      break;
   case PASTE:
      ralloc_asprintf_rewrite_tail (out, len, "##");
      break;
   case PLUS_PLUS:
      ralloc_asprintf_rewrite_tail (out, len, "++");
      break;
   case MINUS_MINUS:
      ralloc_asprintf_rewrite_tail (out, len, "--");
      break;
   case DEFINED:
      ralloc_asprintf_rewrite_tail (out, len, "defined");
      break;
   case PLACEHOLDER:
      /* Nothing to print. */
      break;
   default:
      assert(!"Error: Don't know how to print token.");
d1106 71
a1176 2
      break;
   }
d1186 1
a1186 1
_token_paste(glcpp_parser_t *parser, token_t *token, token_t *other)
d1188 1
a1188 1
   token_t *combined = NULL;
d1190 106
a1295 101
   /* Pasting a placeholder onto anything makes no change. */
   if (other->type == PLACEHOLDER)
      return token;

   /* When 'token' is a placeholder, just return 'other'. */
   if (token->type == PLACEHOLDER)
      return other;

   /* A very few single-character punctuators can be combined
    * with another to form a multi-character punctuator. */
   switch (token->type) {
   case '<':
      if (other->type == '<')
         combined = _token_create_ival (token, LEFT_SHIFT, LEFT_SHIFT);
      else if (other->type == '=')
         combined = _token_create_ival (token, LESS_OR_EQUAL, LESS_OR_EQUAL);
      break;
   case '>':
      if (other->type == '>')
         combined = _token_create_ival (token, RIGHT_SHIFT, RIGHT_SHIFT);
      else if (other->type == '=')
         combined = _token_create_ival (token, GREATER_OR_EQUAL, GREATER_OR_EQUAL);
      break;
   case '=':
      if (other->type == '=')
         combined = _token_create_ival (token, EQUAL, EQUAL);
      break;
   case '!':
      if (other->type == '=')
         combined = _token_create_ival (token, NOT_EQUAL, NOT_EQUAL);
      break;
   case '&':
      if (other->type == '&')
         combined = _token_create_ival (token, AND, AND);
      break;
   case '|':
      if (other->type == '|')
         combined = _token_create_ival (token, OR, OR);
      break;
   }

   if (combined != NULL) {
      /* Inherit the location from the first token */
      combined->location = token->location;
      return combined;
   }

   /* Two string-valued (or integer) tokens can usually just be
    * mashed together. (We also handle a string followed by an
    * integer here as well.)
    *
    * There are some exceptions here. Notably, if the first token
    * is an integer (or a string representing an integer), then
    * the second token must also be an integer or must be a
    * string representing an integer that begins with a digit.
    */
   if ((token->type == IDENTIFIER || token->type == OTHER || token->type == INTEGER_STRING || token->type == INTEGER) &&
       (other->type == IDENTIFIER || other->type == OTHER || other->type == INTEGER_STRING || other->type == INTEGER))
   {
      char *str;
      int combined_type;

      /* Check that pasting onto an integer doesn't create a
       * non-integer, (that is, only digits can be
       * pasted. */
      if (token->type == INTEGER_STRING || token->type == INTEGER) {
         switch (other->type) {
         case INTEGER_STRING:
            if (other->value.str[0] < '0' || other->value.str[0] > '9')
               goto FAIL;
            break;
         case INTEGER:
            if (other->value.ival < 0)
               goto FAIL;
            break;
         default:
            goto FAIL;
         }
      }

      if (token->type == INTEGER)
         str = ralloc_asprintf (token, "%" PRIiMAX, token->value.ival);
      else
         str = ralloc_strdup (token, token->value.str);

      if (other->type == INTEGER)
         ralloc_asprintf_append (&str, "%" PRIiMAX, other->value.ival);
      else
         ralloc_strcat (&str, other->value.str);

      /* New token is same type as original token, unless we
       * started with an integer, in which case we will be
       * creating an integer-string. */
      combined_type = token->type;
      if (combined_type == INTEGER)
         combined_type = INTEGER_STRING;

      combined = _token_create_str (token, combined_type, str);
      combined->location = token->location;
      return combined;
   }
d1298 6
a1303 6
   glcpp_error (&token->location, parser, "");
   ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "Pasting \"");
   _token_print (&parser->info_log, &parser->info_log_length, token);
   ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "\" and \"");
   _token_print (&parser->info_log, &parser->info_log_length, other);
   ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "\" does not give a valid preprocessing token.\n");
d1305 1
a1305 1
   return token;
d1309 1
a1309 1
_token_list_print(glcpp_parser_t *parser, token_list_t *list)
d1311 1
a1311 1
   token_node_t *node;
d1313 2
a1314 2
   if (list == NULL)
      return;
d1316 2
a1317 2
   for (node = list->head; node; node = node->next)
      _token_print (&parser->output, &parser->output_length, node->token);
d1321 1
a1321 1
yyerror(YYLTYPE *locp, glcpp_parser_t *parser, const char *error)
d1323 1
a1323 1
   glcpp_error(locp, parser, "%s", error);
d1326 2
a1327 2
static void
add_builtin_define(glcpp_parser_t *parser, const char *name, int value)
d1340 1
a1340 1
glcpp_parser_create(glcpp_extension_iterator extensions, void *state, gl_api api)
d1342 1
a1342 1
   glcpp_parser_t *parser;
d1344 1
a1344 1
   parser = ralloc (NULL, glcpp_parser_t);
d1346 34
a1379 36
   glcpp_lex_init_extra (parser, &parser->scanner);
   parser->defines = _mesa_hash_table_create(NULL, _mesa_key_hash_string,
                                             _mesa_key_string_equal);
   parser->active = NULL;
   parser->lexing_directive = 0;
   parser->space_tokens = 1;
   parser->last_token_was_newline = 0;
   parser->last_token_was_space = 0;
   parser->first_non_space_token_this_line = 1;
   parser->newline_as_space = 0;
   parser->in_control_line = 0;
   parser->paren_count = 0;
   parser->commented_newlines = 0;

   parser->skip_stack = NULL;
   parser->skipping = 0;

   parser->lex_from_list = NULL;
   parser->lex_from_node = NULL;

   parser->output = ralloc_strdup(parser, "");
   parser->output_length = 0;
   parser->info_log = ralloc_strdup(parser, "");
   parser->info_log_length = 0;
   parser->error = 0;

   parser->extensions = extensions;
   parser->state = state;
   parser->api = api;
   parser->version = 0;
   parser->version_set = false;

   parser->has_new_line_number = 0;
   parser->new_line_number = 1;
   parser->has_new_source_number = 0;
   parser->new_source_number = 0;
d1381 1
a1381 1
   return parser;
d1385 1
a1385 1
glcpp_parser_destroy(glcpp_parser_t *parser)
d1387 3
a1389 3
   glcpp_lex_destroy (parser->scanner);
   _mesa_hash_table_destroy(parser->defines, NULL);
   ralloc_free (parser);
d1394 3
a1396 3
   FUNCTION_STATUS_SUCCESS,
   FUNCTION_NOT_A_FUNCTION,
   FUNCTION_UNBALANCED_PARENTHESES
d1411 1
a1411 1
 *      Successfully parsed a set of function arguments.
d1415 2
a1416 2
 *      Macro name not followed by a '('. This is not an error, but
 *      simply that the macro name should be treated as a non-macro.
d1420 1
a1420 1
 *      Macro name is not followed by a balanced set of parentheses.
d1423 3
a1425 2
_arguments_parse(argument_list_t *arguments, token_node_t *node,
                 token_node_t **last)
d1427 4
a1430 2
   token_list_t *argument;
   int paren_count;
d1432 3
a1434 1
   node = node->next;
d1436 2
a1437 34
   /* Ignore whitespace before first parenthesis. */
   while (node && node->token->type == SPACE)
      node = node->next;

   if (node == NULL || node->token->type != '(')
      return FUNCTION_NOT_A_FUNCTION;

   node = node->next;

   argument = _token_list_create (arguments);
   _argument_list_append (arguments, argument);

   for (paren_count = 1; node; node = node->next) {
      if (node->token->type == '(') {
         paren_count++;
      } else if (node->token->type == ')') {
         paren_count--;
         if (paren_count == 0)
            break;
      }

      if (node->token->type == ',' && paren_count == 1) {
         _token_list_trim_trailing_space (argument);
         argument = _token_list_create (arguments);
         _argument_list_append (arguments, argument);
      } else {
         if (argument->head == NULL) {
            /* Don't treat initial whitespace as part of the argument. */
            if (node->token->type == SPACE)
               continue;
         }
         _token_list_append (argument, node->token);
      }
   }
d1439 1
a1439 2
   if (paren_count)
      return FUNCTION_UNBALANCED_PARENTHESES;
d1441 2
a1442 1
   *last = node;
d1444 36
a1479 1
   return FUNCTION_STATUS_SUCCESS;
d1483 1
a1483 1
_token_list_create_with_one_ival(void *ctx, int type, int ival)
d1485 2
a1486 2
   token_list_t *list;
   token_t *node;
d1488 3
a1490 3
   list = _token_list_create(ctx);
   node = _token_create_ival(list, type, ival);
   _token_list_append(list, node);
d1492 1
a1492 1
   return list;
d1496 1
a1496 1
_token_list_create_with_one_space(void *ctx)
d1498 1
a1498 1
   return _token_list_create_with_one_ival(ctx, SPACE, SPACE);
d1502 1
a1502 1
_token_list_create_with_one_integer(void *ctx, int ival)
d1504 1
a1504 1
   return _token_list_create_with_one_ival(ctx, INTEGER, ival);
d1516 1
a1516 1
 *   If the identifier is a defined macro, this function returns 1.
d1518 1
a1518 1
 *   If the identifier is not a defined macro, this function returns 0.
d1520 3
a1522 3
 *   In either case, *last will be updated to the last node in the list
 *   consumed by the evaluation, (either the token of the identifier or the
 *   token of the closing parenthesis).
d1529 3
a1531 2
_glcpp_parser_evaluate_defined(glcpp_parser_t *parser, token_node_t *node,
                               token_node_t **last)
d1533 1
a1533 1
   token_node_t *argument, *defined = node;
d1535 1
a1535 1
   assert(node->token->type == DEFINED);
d1537 1
a1537 1
   node = node->next;
d1539 3
a1541 3
   /* Ignore whitespace after DEFINED token. */
   while (node && node->token->type == SPACE)
      node = node->next;
d1543 2
a1544 2
   if (node == NULL)
      goto FAIL;
d1546 4
a1549 4
   if (node->token->type == IDENTIFIER || node->token->type == OTHER) {
      argument = node;
   } else if (node->token->type == '(') {
      node = node->next;
d1551 3
a1553 3
      /* Ignore whitespace after '(' token. */
      while (node && node->token->type == SPACE)
         node = node->next;
d1555 5
a1559 4
      if (node == NULL || (node->token->type != IDENTIFIER &&
                           node->token->type != OTHER)) {
         goto FAIL;
      }
d1561 1
a1561 1
      argument = node;
d1563 1
a1563 1
      node = node->next;
d1565 3
a1567 3
      /* Ignore whitespace after identifier, before ')' token. */
      while (node && node->token->type == SPACE)
         node = node->next;
d1569 5
a1573 5
      if (node == NULL || node->token->type != ')')
         goto FAIL;
   } else {
      goto FAIL;
   }
d1575 1
a1575 1
   *last = node;
d1577 2
a1578 2
   return _mesa_hash_table_search(parser->defines,
                                  argument->token->value.str) ? 1 : 0;
d1581 3
a1583 3
   glcpp_error (&defined->token->location, parser,
                "\"defined\" not followed by an identifier");
   return -1;
d1589 2
a1590 2
_glcpp_parser_evaluate_defined_in_list(glcpp_parser_t *parser,
                                       token_list_t *list)
d1592 17
a1608 2
   token_node_t *node, *node_prev, *replacement, *last = NULL;
   int value;
d1610 2
a1611 2
   if (list == NULL)
      return;
d1613 16
a1628 31
   node_prev = NULL;
   node = list->head;

   while (node) {

      if (node->token->type != DEFINED)
         goto NEXT;

      value = _glcpp_parser_evaluate_defined (parser, node, &last);
      if (value == -1)
         goto NEXT;

      replacement = ralloc (list, token_node_t);
      replacement->token = _token_create_ival (list, INTEGER, value);

      /* Splice replacement node into list, replacing from "node"
       * through "last". */
      if (node_prev)
         node_prev->next = replacement;
      else
         list->head = replacement;
      replacement->next = last->next;
      if (last == list->tail)
         list->tail = replacement;

      node = replacement;

   NEXT:
      node_prev = node;
      node = node->next;
   }
d1640 4
a1643 2
_glcpp_parser_expand_and_lex_from(glcpp_parser_t *parser, int head_token_type,
                                  token_list_t *list, expansion_mode_t mode)
d1645 2
a1646 2
   token_list_t *expanded;
   token_t *token;
d1648 6
a1653 6
   expanded = _token_list_create (parser);
   token = _token_create_ival (parser, head_token_type, head_token_type);
   _token_list_append (expanded, token);
   _glcpp_parser_expand_token_list (parser, list, mode);
   _token_list_append_list (expanded, list);
   glcpp_parser_lex_from (parser, expanded);
d1657 1
a1657 1
_glcpp_parser_apply_pastes(glcpp_parser_t *parser, token_list_t *list)
d1659 1
a1659 1
   token_node_t *node;
d1661 4
a1664 3
   node = list->head;
   while (node) {
      token_node_t *next_non_space;
d1666 4
a1669 4
      /* Look ahead for a PASTE token, skipping space. */
      next_non_space = node->next;
      while (next_non_space && next_non_space->token->type == SPACE)
         next_non_space = next_non_space->next;
d1671 2
a1672 2
      if (next_non_space == NULL)
         break;
d1674 4
a1677 4
      if (next_non_space->token->type != PASTE) {
         node = next_non_space;
         continue;
      }
d1679 9
a1687 4
      /* Now find the next non-space token after the PASTE. */
      next_non_space = next_non_space->next;
      while (next_non_space && next_non_space->token->type == SPACE)
         next_non_space = next_non_space->next;
d1689 5
a1693 10
      if (next_non_space == NULL) {
         yyerror(&node->token->location, parser, "'##' cannot appear at either end of a macro expansion\n");
         return;
      }

      node->token = _token_paste(parser, node->token, next_non_space->token);
      node->next = next_non_space->next;
      if (next_non_space == list->tail)
         list->tail = node;
   }
d1695 1
a1695 1
   list->non_space_tail = list->tail;
d1719 88
a1806 76
_glcpp_parser_expand_function(glcpp_parser_t *parser, token_node_t *node,
                              token_node_t **last, expansion_mode_t mode)
{
   struct hash_entry *entry;
   macro_t *macro;
   const char *identifier;
   argument_list_t *arguments;
   function_status_t status;
   token_list_t *substituted;
   int parameter_index;

   identifier = node->token->value.str;

   entry = _mesa_hash_table_search(parser->defines, identifier);
   macro = entry ? entry->data : NULL;

   assert(macro->is_function);

   arguments = _argument_list_create(parser);
   status = _arguments_parse(arguments, node, last);

   switch (status) {
   case FUNCTION_STATUS_SUCCESS:
      break;
   case FUNCTION_NOT_A_FUNCTION:
      return NULL;
   case FUNCTION_UNBALANCED_PARENTHESES:
      glcpp_error(&node->token->location, parser, "Macro %s call has unbalanced parentheses\n", identifier);
      return NULL;
   }

   /* Replace a macro defined as empty with a SPACE token. */
   if (macro->replacements == NULL) {
      ralloc_free(arguments);
      return _token_list_create_with_one_space(parser);
   }

   if (!((_argument_list_length (arguments) ==
          _string_list_length (macro->parameters)) ||
         (_string_list_length (macro->parameters) == 0 &&
          _argument_list_length (arguments) == 1 &&
          arguments->head->argument->head == NULL))) {
      glcpp_error(&node->token->location, parser,
                  "Error: macro %s invoked with %d arguments (expected %d)\n",
                  identifier, _argument_list_length (arguments),
                  _string_list_length(macro->parameters));
      return NULL;
   }

   /* Perform argument substitution on the replacement list. */
   substituted = _token_list_create(arguments);

   for (node = macro->replacements->head; node; node = node->next) {
      if (node->token->type == IDENTIFIER &&
          _string_list_contains(macro->parameters, node->token->value.str,
                                &parameter_index)) {
         token_list_t *argument;
         argument = _argument_list_member_at(arguments, parameter_index);
         /* Before substituting, we expand the argument tokens, or append a
          * placeholder token for an empty argument. */
         if (argument->head) {
            token_list_t *expanded_argument;
            expanded_argument = _token_list_copy(parser, argument);
            _glcpp_parser_expand_token_list(parser, expanded_argument, mode);
            _token_list_append_list(substituted, expanded_argument);
         } else {
            token_t *new_token;

            new_token = _token_create_ival(substituted, PLACEHOLDER,
                                           PLACEHOLDER);
            _token_list_append(substituted, new_token);
         }
      } else {
         _token_list_append(substituted, node->token);
      }
   }
d1808 2
a1809 2
   /* After argument substitution, and before further expansion
    * below, implement token pasting. */
d1811 1
a1811 1
   _token_list_trim_trailing_space(substituted);
d1813 1
a1813 1
   _glcpp_parser_apply_pastes(parser, substituted);
d1815 1
a1815 1
   return substituted;
d1828 1
a1828 1
 *   As 'node' in the case of object-like macro expansion.
d1830 2
a1831 2
 *   As the token of the closing right parenthesis in the case of
 *   function-like macro expansion.
d1837 4
a1840 2
_glcpp_parser_expand_node(glcpp_parser_t *parser, token_node_t *node,
                          token_node_t **last, expansion_mode_t mode)
d1842 43
a1884 56
   token_t *token = node->token;
   const char *identifier;
   struct hash_entry *entry;
   macro_t *macro;

   /* We only expand identifiers */
   if (token->type != IDENTIFIER) {
      return NULL;
   }

   *last = node;
   identifier = token->value.str;

   /* Special handling for __LINE__ and __FILE__, (not through
    * the hash table). */
   if (strcmp(identifier, "__LINE__") == 0)
      return _token_list_create_with_one_integer(parser, node->token->location.first_line);

   if (strcmp(identifier, "__FILE__") == 0)
      return _token_list_create_with_one_integer(parser, node->token->location.source);

   /* Look up this identifier in the hash table. */
   entry = _mesa_hash_table_search(parser->defines, identifier);
   macro = entry ? entry->data : NULL;

   /* Not a macro, so no expansion needed. */
   if (macro == NULL)
      return NULL;

   /* Finally, don't expand this macro if we're already actively
    * expanding it, (to avoid infinite recursion). */
   if (_parser_active_list_contains (parser, identifier)) {
      /* We change the token type here from IDENTIFIER to OTHER to prevent any
       * future expansion of this unexpanded token. */
      char *str;
      token_list_t *expansion;
      token_t *final;

      str = ralloc_strdup(parser, token->value.str);
      final = _token_create_str(parser, OTHER, str);
      expansion = _token_list_create(parser);
      _token_list_append(expansion, final);
      return expansion;
   }

   if (! macro->is_function) {
      token_list_t *replacement;

      /* Replace a macro defined as empty with a SPACE token. */
      if (macro->replacements == NULL)
         return _token_list_create_with_one_space(parser);

      replacement = _token_list_copy(parser, macro->replacements);
      _glcpp_parser_apply_pastes(parser, replacement);
      return replacement;
   }
d1886 14
a1899 1
   return _glcpp_parser_expand_function(parser, node, last, mode);
d1910 3
a1912 2
_parser_active_list_push(glcpp_parser_t *parser, const char *identifier,
                         token_node_t *marker)
d1914 1
a1914 1
   active_list_t *node;
d1916 4
a1919 4
   node = ralloc(parser->active, active_list_t);
   node->identifier = ralloc_strdup(node, identifier);
   node->marker = marker;
   node->next = parser->active;
d1921 1
a1921 1
   parser->active = node;
d1925 1
a1925 1
_parser_active_list_pop(glcpp_parser_t *parser)
d1927 1
a1927 1
   active_list_t *node = parser->active;
d1929 4
a1932 4
   if (node == NULL) {
      parser->active = NULL;
      return;
   }
d1934 2
a1935 2
   node = parser->active->next;
   ralloc_free (parser->active);
d1937 1
a1937 1
   parser->active = node;
d1941 1
a1941 1
_parser_active_list_contains(glcpp_parser_t *parser, const char *identifier)
d1943 1
a1943 1
   active_list_t *node;
d1945 2
a1946 2
   if (parser->active == NULL)
      return 0;
d1948 3
a1950 3
   for (node = parser->active; node; node = node->next)
      if (strcmp(node->identifier, identifier) == 0)
         return 1;
d1952 1
a1952 1
   return 0;
d1963 12
a1974 12
 *   EXPANSION_MODE_IGNORE_DEFINED: Any resulting DEFINED tokens will be
 *      left in the final list, unevaluated. This is the correct mode
 *      for expanding any list in any context other than a
 *      preprocessor conditional, (#if or #elif).
 *
 *   EXPANSION_MODE_EVALUATE_DEFINED: Any resulting DEFINED tokens will be
 *      evaluated to 0 or 1 tokens depending on whether the following
 *      token is the name of a defined macro. If the DEFINED token is
 *      not followed by an (optionally parenthesized) identifier, then
 *      an error will be generated. This the correct mode for
 *      expanding any list in the context of a preprocessor
 *      conditional, (#if or #elif).
d1977 75
a2051 69
_glcpp_parser_expand_token_list(glcpp_parser_t *parser, token_list_t *list,
                                expansion_mode_t mode)
{
   token_node_t *node_prev;
   token_node_t *node, *last = NULL;
   token_list_t *expansion;
   active_list_t *active_initial = parser->active;

   if (list == NULL)
      return;

   _token_list_trim_trailing_space (list);

   node_prev = NULL;
   node = list->head;

   if (mode == EXPANSION_MODE_EVALUATE_DEFINED)
      _glcpp_parser_evaluate_defined_in_list (parser, list);

   while (node) {

      while (parser->active && parser->active->marker == node)
         _parser_active_list_pop (parser);

      expansion = _glcpp_parser_expand_node (parser, node, &last, mode);
      if (expansion) {
         token_node_t *n;

         if (mode == EXPANSION_MODE_EVALUATE_DEFINED) {
            _glcpp_parser_evaluate_defined_in_list (parser, expansion);
         }

         for (n = node; n != last->next; n = n->next)
            while (parser->active && parser->active->marker == n) {
               _parser_active_list_pop (parser);
            }

         _parser_active_list_push(parser, node->token->value.str, last->next);

         /* Splice expansion into list, supporting a simple deletion if the
          * expansion is empty.
          */
         if (expansion->head) {
            if (node_prev)
               node_prev->next = expansion->head;
            else
               list->head = expansion->head;
            expansion->tail->next = last->next;
            if (last == list->tail)
               list->tail = expansion->tail;
         } else {
            if (node_prev)
               node_prev->next = last->next;
            else
               list->head = last->next;
            if (last == list->tail)
               list->tail = NULL;
         }
      } else {
         node_prev = node;
      }
      node = node_prev ? node_prev->next : list->head;
   }

   /* Remove any lingering effects of this invocation on the
    * active list. That is, pop until the list looks like it did
    * at the beginning of this function. */
   while (parser->active && parser->active != active_initial)
      _parser_active_list_pop (parser);
d2053 1
a2053 1
   list->non_space_tail = list->tail;
d2057 2
a2058 2
_glcpp_parser_print_expanded_token_list(glcpp_parser_t *parser,
                                        token_list_t *list)
d2060 2
a2061 2
   if (list == NULL)
      return;
d2063 1
a2063 1
   _glcpp_parser_expand_token_list (parser, list, EXPANSION_MODE_IGNORE_DEFINED);
d2065 3
a2067 3
   _token_list_trim_trailing_space (list);

   _token_list_print (parser, list);
d2071 31
a2101 30
_check_for_reserved_macro_name(glcpp_parser_t *parser, YYLTYPE *loc,
                               const char *identifier)
{
   /* Section 3.3 (Preprocessor) of the GLSL 1.30 spec (and later) and
    * the GLSL ES spec (all versions) say:
    *
    *     "All macro names containing two consecutive underscores ( __ )
    *     are reserved for future use as predefined macro names. All
    *     macro names prefixed with "GL_" ("GL" followed by a single
    *     underscore) are also reserved."
    *
    * The intention is that names containing __ are reserved for internal
    * use by the implementation, and names prefixed with GL_ are reserved
    * for use by Khronos.  Since every extension adds a name prefixed
    * with GL_ (i.e., the name of the extension), that should be an
    * error.  Names simply containing __ are dangerous to use, but should
    * be allowed.
    *
    * A future version of the GLSL specification will clarify this.
    */
   if (strstr(identifier, "__")) {
      glcpp_warning(loc, parser, "Macro names containing \"__\" are reserved "
                    "for use by the implementation.\n");
   }
   if (strncmp(identifier, "GL_", 3) == 0) {
      glcpp_error (loc, parser, "Macro names starting with \"GL_\" are reserved.\n");
   }
   if (strcmp(identifier, "defined") == 0) {
      glcpp_error (loc, parser, "\"defined\" cannot be used as a macro name");
   }
d2105 1
a2105 1
_macro_equal(macro_t *a, macro_t *b)
d2107 2
a2108 2
   if (a->is_function != b->is_function)
      return 0;
d2110 4
a2113 4
   if (a->is_function) {
      if (! _string_list_equal (a->parameters, b->parameters))
         return 0;
   }
d2115 2
a2116 1
   return _token_list_equal_ignoring_space(a->replacements, b->replacements);
d2120 31
a2150 29
_define_object_macro(glcpp_parser_t *parser, YYLTYPE *loc,
                     const char *identifier, token_list_t *replacements)
{
   macro_t *macro, *previous;
   struct hash_entry *entry;

   /* We define pre-defined macros before we've started parsing the actual
    * file. So if there's no location defined yet, that's what were doing and
    * we don't want to generate an error for using the reserved names. */
   if (loc != NULL)
      _check_for_reserved_macro_name(parser, loc, identifier);

   macro = ralloc (parser, macro_t);

   macro->is_function = 0;
   macro->parameters = NULL;
   macro->identifier = ralloc_strdup (macro, identifier);
   macro->replacements = replacements;
   ralloc_steal (macro, replacements);

   entry = _mesa_hash_table_search(parser->defines, identifier);
   previous = entry ? entry->data : NULL;
   if (previous) {
      if (_macro_equal (macro, previous)) {
         ralloc_free (macro);
         return;
      }
      glcpp_error (loc, parser, "Redefinition of macro %s\n",  identifier);
   }
d2152 1
a2152 1
   _mesa_hash_table_insert (parser->defines, identifier, macro);
d2156 8
a2163 7
_define_function_macro(glcpp_parser_t *parser, YYLTYPE *loc,
                       const char *identifier, string_list_t *parameters,
                       token_list_t *replacements)
{
   macro_t *macro, *previous;
   struct hash_entry *entry;
   const char *dup;
d2165 1
a2165 1
   _check_for_reserved_macro_name(parser, loc, identifier);
d2168 22
a2189 22
   if ((dup = _string_list_has_duplicate (parameters)) != NULL) {
      glcpp_error (loc, parser, "Duplicate macro parameter \"%s\"", dup);
   }

   macro = ralloc (parser, macro_t);
   ralloc_steal (macro, parameters);
   ralloc_steal (macro, replacements);

   macro->is_function = 1;
   macro->parameters = parameters;
   macro->identifier = ralloc_strdup (macro, identifier);
   macro->replacements = replacements;

   entry = _mesa_hash_table_search(parser->defines, identifier);
   previous = entry ? entry->data : NULL;
   if (previous) {
      if (_macro_equal (macro, previous)) {
         ralloc_free (macro);
         return;
      }
      glcpp_error (loc, parser, "Redefinition of macro %s\n", identifier);
   }
d2191 1
a2191 1
   _mesa_hash_table_insert(parser->defines, identifier, macro);
d2195 1
a2195 1
glcpp_parser_lex(YYSTYPE *yylval, YYLTYPE *yylloc, glcpp_parser_t *parser)
d2197 67
a2263 2
   token_node_t *node;
   int ret;
d2265 2
a2266 2
   if (parser->lex_from_list == NULL) {
      ret = glcpp_lex(yylval, yylloc, parser->scanner);
d2268 89
a2356 146
      /* XXX: This ugly block of code exists for the sole
       * purpose of converting a NEWLINE token into a SPACE
       * token, but only in the case where we have seen a
       * function-like macro name, but have not yet seen its
       * closing parenthesis.
       *
       * There's perhaps a more compact way to do this with
       * mid-rule actions in the grammar.
       *
       * I'm definitely not pleased with the complexity of
       * this code here.
       */
      if (parser->newline_as_space) {
         if (ret == '(') {
            parser->paren_count++;
         } else if (ret == ')') {
            parser->paren_count--;
            if (parser->paren_count == 0)
               parser->newline_as_space = 0;
         } else if (ret == NEWLINE) {
            ret = SPACE;
         } else if (ret != SPACE) {
            if (parser->paren_count == 0)
               parser->newline_as_space = 0;
         }
      } else if (parser->in_control_line) {
         if (ret == NEWLINE)
            parser->in_control_line = 0;
      }
      else if (ret == DEFINE_TOKEN || ret == UNDEF || ret == IF ||
               ret == IFDEF || ret == IFNDEF || ret == ELIF || ret == ELSE ||
               ret == ENDIF || ret == HASH_TOKEN) {
         parser->in_control_line = 1;
      } else if (ret == IDENTIFIER) {
         struct hash_entry *entry = _mesa_hash_table_search(parser->defines,
                                                            yylval->str);
         macro_t *macro = entry ? entry->data : NULL;
         if (macro && macro->is_function) {
            parser->newline_as_space = 1;
            parser->paren_count = 0;
         }
      }

      return ret;
   }

   node = parser->lex_from_node;

   if (node == NULL) {
      ralloc_free (parser->lex_from_list);
      parser->lex_from_list = NULL;
      return NEWLINE;
   }

   *yylval = node->token->value;
   ret = node->token->type;

   parser->lex_from_node = node->next;

   return ret;
}

static void
glcpp_parser_lex_from(glcpp_parser_t *parser, token_list_t *list)
{
   token_node_t *node;

   assert (parser->lex_from_list == NULL);

   /* Copy list, eliminating any space tokens. */
   parser->lex_from_list = _token_list_create (parser);

   for (node = list->head; node; node = node->next) {
      if (node->token->type == SPACE)
         continue;
      _token_list_append (parser->lex_from_list, node->token);
   }

   ralloc_free (list);

   parser->lex_from_node = parser->lex_from_list->head;

   /* It's possible the list consisted of nothing but whitespace. */
   if (parser->lex_from_node == NULL) {
      ralloc_free (parser->lex_from_list);
      parser->lex_from_list = NULL;
   }
}

static void
_glcpp_parser_skip_stack_push_if(glcpp_parser_t *parser, YYLTYPE *loc,
                                 int condition)
{
   skip_type_t current = SKIP_NO_SKIP;
   skip_node_t *node;

   if (parser->skip_stack)
      current = parser->skip_stack->type;

   node = ralloc (parser, skip_node_t);
   node->loc = *loc;

   if (current == SKIP_NO_SKIP) {
      if (condition)
         node->type = SKIP_NO_SKIP;
      else
         node->type = SKIP_TO_ELSE;
   } else {
      node->type = SKIP_TO_ENDIF;
   }

   node->has_else = false;
   node->next = parser->skip_stack;
   parser->skip_stack = node;
}

static void
_glcpp_parser_skip_stack_change_if(glcpp_parser_t *parser, YYLTYPE *loc,
                                   const char *type, int condition)
{
   if (parser->skip_stack == NULL) {
      glcpp_error (loc, parser, "#%s without #if\n", type);
      return;
   }

   if (parser->skip_stack->type == SKIP_TO_ELSE) {
      if (condition)
         parser->skip_stack->type = SKIP_NO_SKIP;
   } else {
      parser->skip_stack->type = SKIP_TO_ENDIF;
   }
}

static void
_glcpp_parser_skip_stack_pop(glcpp_parser_t *parser, YYLTYPE *loc)
{
   skip_node_t *node;

   if (parser->skip_stack == NULL) {
      glcpp_error (loc, parser, "#endif without #if\n");
      return;
   }

   node = parser->skip_stack;
   parser->skip_stack = node->next;
   ralloc_free (node);
d2364 80
a2443 2
   if (parser->version_set)
      return;
d2445 2
a2446 2
   parser->version = version;
   parser->version_set = true;
d2448 2
a2449 1
   add_builtin_define (parser, "__VERSION__", version);
d2451 99
a2549 28
   parser->is_gles = (version == 100) ||
                     (es_identifier && (strcmp(es_identifier, "es") == 0));

   /* Add pre-defined macros. */
   if (parser->is_gles)
      add_builtin_define(parser, "GL_ES", 1);
   else if (version >= 150)
      add_builtin_define(parser, "GL_core_profile", 1);

   /* Currently, all ES2/ES3 implementations support highp in the
    * fragment shader, so we always define this macro in ES2/ES3.
    * If we ever get a driver that doesn't support highp, we'll
    * need to add a flag to the gl_context and check that here.
    */
   if (version >= 130 || parser->is_gles)
      add_builtin_define (parser, "GL_FRAGMENT_PRECISION_HIGH", 1);

   /* Add all the extension macros available in this context */
   if (parser->extensions)
      parser->extensions(parser->state, add_builtin_define, parser,
                         version, parser->is_gles);

   if (explicitly_set) {
      ralloc_asprintf_rewrite_tail(&parser->output, &parser->output_length,
                                   "#version %" PRIiMAX "%s%s", version,
                                   es_identifier ? " " : "",
                                   es_identifier ? es_identifier : "");
   }
d2561 3
a2563 2
   int language_version = parser->api == API_OPENGLES2 ?
                          IMPLICIT_GLSL_ES_VERSION : IMPLICIT_GLSL_VERSION;
d2565 2
a2566 2
   _glcpp_parser_handle_version_declaration(parser, language_version,
                                            NULL, false);
@


1.1.1.3
log
@Import Mesa 17.1.6
@
text
@d52 1
a52 1
_string_list_create(glcpp_parser_t *parser);
d55 1
a55 2
_string_list_append_item(glcpp_parser_t *parser, string_list_t *list,
                         const char *str);
d70 1
a70 1
_argument_list_create(glcpp_parser_t *parser);
d73 1
a73 2
_argument_list_append(glcpp_parser_t *parser, argument_list_t *list,
                      token_list_t *argument);
d81 1
d83 1
a83 1
_token_create_str(glcpp_parser_t *parser, int type, char *str);
d86 1
a86 1
_token_create_ival(glcpp_parser_t *parser, int type, int ival);
d89 1
a89 1
_token_list_create(glcpp_parser_t *parser);
d92 1
a92 1
_token_list_append(glcpp_parser_t *parser, token_list_t *list, token_t *token);
d212 1
d280 1
d315 1
d317 1
d319 1
d356 1
d492 1
a492 1
			$$.undefined_macro = linear_strdup(parser->linalloc, $1);
d664 2
a665 1
		_string_list_append_item (parser, $$, $1);
d669 2
a670 1
		_string_list_append_item (parser, $$, $3);
d695 1
a695 1
		_token_list_append (parser, $$, $1);
d699 1
a699 1
		_token_list_append (parser, $$, $2);
d769 1
a769 1
_string_list_create(glcpp_parser_t *parser)
d773 1
a773 1
   list = linear_alloc_child(parser->linalloc, sizeof(string_list_t));
d781 1
a781 2
_string_list_append_item(glcpp_parser_t *parser, string_list_t *list,
                         const char *str)
d785 2
a786 2
   node = linear_alloc_child(parser->linalloc, sizeof(string_node_t));
   node->str = linear_strdup(parser->linalloc, str);
d879 1
a879 1
_argument_list_create(glcpp_parser_t *parser)
d883 1
a883 1
   list = linear_alloc_child(parser->linalloc, sizeof(argument_list_t));
d891 1
a891 2
_argument_list_append(glcpp_parser_t *parser,
                      argument_list_t *list, token_list_t *argument)
d895 1
a895 1
   node = linear_alloc_child(parser->linalloc, sizeof(argument_node_t));
d946 1
d948 1
a948 1
_token_create_str(glcpp_parser_t *parser, int type, char *str)
d952 1
a952 1
   token = linear_alloc_child(parser->linalloc, sizeof(token_t));
d956 2
d962 1
a962 1
_token_create_ival(glcpp_parser_t *parser, int type, int ival)
d966 1
a966 1
   token = linear_alloc_child(parser->linalloc, sizeof(token_t));
d974 1
a974 1
_token_list_create(glcpp_parser_t *parser)
d978 1
a978 1
   list = linear_alloc_child(parser->linalloc, sizeof(token_list_t));
d987 1
a987 1
_token_list_append(glcpp_parser_t *parser, token_list_t *list, token_t *token)
d991 1
a991 1
   node = linear_alloc_child(parser->linalloc, sizeof(token_node_t));
d1023 1
a1023 1
_token_list_copy(glcpp_parser_t *parser, token_list_t *other)
d1031 1
a1031 1
   copy = _token_list_create (parser);
d1033 1
a1033 1
      token_t *new_token = linear_alloc_child(parser->linalloc, sizeof(token_t));
d1035 1
a1035 1
      _token_list_append (parser, copy, new_token);
d1044 2
d1047 1
d1050 6
d1198 3
a1200 3
/* Return a new token formed by pasting 'token' and 'other'. Note that this
 * function may return 'token' or 'other' directly rather than allocating
 * anything new.
d1222 1
a1222 1
         combined = _token_create_ival (parser, LEFT_SHIFT, LEFT_SHIFT);
d1224 1
a1224 1
         combined = _token_create_ival (parser, LESS_OR_EQUAL, LESS_OR_EQUAL);
d1228 1
a1228 1
         combined = _token_create_ival (parser, RIGHT_SHIFT, RIGHT_SHIFT);
d1230 1
a1230 1
         combined = _token_create_ival (parser, GREATER_OR_EQUAL, GREATER_OR_EQUAL);
d1234 1
a1234 1
         combined = _token_create_ival (parser, EQUAL, EQUAL);
d1238 1
a1238 1
         combined = _token_create_ival (parser, NOT_EQUAL, NOT_EQUAL);
d1242 1
a1242 1
         combined = _token_create_ival (parser, AND, AND);
d1246 1
a1246 1
         combined = _token_create_ival (parser, OR, OR);
d1290 1
a1290 1
         str = linear_asprintf(parser->linalloc, "%" PRIiMAX, token->value.ival);
d1292 1
a1292 1
         str = linear_strdup(parser->linalloc, token->value.str);
d1295 1
a1295 1
         linear_asprintf_append(parser->linalloc, &str, "%" PRIiMAX, other->value.ival);
d1297 1
a1297 1
         linear_strcat(parser->linalloc, &str, other->value.str);
d1306 1
a1306 1
      combined = _token_create_str (parser, combined_type, str);
d1349 1
a1349 1
   _token_list_append(parser, list, tok);
d1354 1
a1354 2
glcpp_parser_create(const struct gl_extensions *extension_list,
                    glcpp_extension_iterator extensions, void *state, gl_api api)
a1362 1
   parser->linalloc = linear_alloc_parent(parser, 0);
a1364 1
   parser->lexing_version_directive = 0;
a1386 1
   parser->extension_list = extension_list;
a1396 2
   parser->is_gles = false;

d1439 1
a1439 2
_arguments_parse(glcpp_parser_t *parser,
                 argument_list_t *arguments, token_node_t *node,
d1456 2
a1457 2
   argument = _token_list_create (parser);
   _argument_list_append (parser, arguments, argument);
d1470 2
a1471 2
         argument = _token_list_create (parser);
         _argument_list_append (parser, arguments, argument);
d1478 1
a1478 1
         _token_list_append(parser, argument, node->token);
d1491 1
a1491 1
_token_list_create_with_one_ival(glcpp_parser_t *parser, int type, int ival)
d1496 3
a1498 3
   list = _token_list_create(parser);
   node = _token_create_ival(parser, type, ival);
   _token_list_append(parser, list, node);
d1504 1
a1504 1
_token_list_create_with_one_space(glcpp_parser_t *parser)
d1506 1
a1506 1
   return _token_list_create_with_one_ival(parser, SPACE, SPACE);
d1510 1
a1510 1
_token_list_create_with_one_integer(glcpp_parser_t *parser, int ival)
d1512 1
a1512 1
   return _token_list_create_with_one_ival(parser, INTEGER, ival);
d1616 2
a1617 2
      replacement = linear_alloc_child(parser->linalloc, sizeof(token_node_t));
      replacement->token = _token_create_ival (parser, INTEGER, value);
d1654 1
a1654 1
   _token_list_append (parser, expanded, token);
d1741 1
a1741 1
   status = _arguments_parse(parser, arguments, node, last);
d1755 1
d1772 1
a1772 1
   substituted = _token_list_create(parser);
d1790 1
a1790 1
            new_token = _token_create_ival(parser, PLACEHOLDER,
d1792 1
a1792 1
            _token_list_append(parser, substituted, new_token);
d1795 1
a1795 1
         _token_list_append(parser, substituted, node->token);
d1869 1
a1869 1
      str = linear_strdup(parser->linalloc, token->value.str);
d1872 1
a1872 1
      _token_list_append(parser, expansion, final);
d1904 2
a1905 2
   node = linear_alloc_child(parser->linalloc, sizeof(active_list_t));
   node->identifier = linear_strdup(parser->linalloc, identifier);
d1923 2
d2112 1
a2112 1
   macro = linear_alloc_child(parser->linalloc, sizeof(macro_t));
d2116 1
a2116 1
   macro->identifier = linear_strdup(parser->linalloc, identifier);
d2118 1
d2124 1
d2149 3
a2151 1
   macro = linear_alloc_child(parser->linalloc, sizeof(macro_t));
d2155 1
a2155 1
   macro->identifier = linear_strdup(parser->linalloc, identifier);
d2162 1
d2229 1
d2255 1
a2255 1
      _token_list_append (parser,  parser->lex_from_list, node->token);
d2258 2
d2264 1
d2279 1
a2279 1
   node = linear_alloc_child(parser->linalloc, sizeof(skip_node_t));
d2325 1
a2361 15

   if (parser->extension_list) {
      /* If MESA_shader_integer_functions is supported, then the building
       * blocks required for the 64x64 => 64 multiply exist.  Add defines for
       * those functions so that they can be tested.
       */
      if (parser->extension_list->MESA_shader_integer_functions) {
         add_builtin_define(parser, "__have_builtin_builtin_sign64", 1);
         add_builtin_define(parser, "__have_builtin_builtin_umul64", 1);
         add_builtin_define(parser, "__have_builtin_builtin_udiv64", 1);
         add_builtin_define(parser, "__have_builtin_builtin_umod64", 1);
         add_builtin_define(parser, "__have_builtin_builtin_idiv64", 1);
         add_builtin_define(parser, "__have_builtin_builtin_imod64", 1);
      }
   }
@


