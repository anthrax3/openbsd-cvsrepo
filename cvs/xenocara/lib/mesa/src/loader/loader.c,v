head	1.2;
access;
symbols
	mesa-17_1_6:1.1.1.3
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	mesa-13_0_6:1.1.1.2
	mesa-13_0_5:1.1.1.2
	mesa-13_0_3:1.1.1.2
	mesa-13_0_2:1.1.1.2
	OPENBSD_6_0:1.1.1.1.0.6
	OPENBSD_6_0_BASE:1.1.1.1
	mesa-11_2_2:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.34;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.41.37;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.41.37;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.12.11.08.33.49;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	uuv5VTS15jglEDZU;

1.1.1.3
date	2017.08.14.09.38.36;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Copyright (C) 2013 Rob Clark <robclark@@freedesktop.org>
 * Copyright (C) 2014-2016 Emil Velikov <emil.l.velikov@@gmail.com>
 * Copyright (C) 2016 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Rob Clark <robclark@@freedesktop.org>
 */

#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#ifdef MAJOR_IN_MKDEV
#include <sys/mkdev.h>
#endif
#ifdef MAJOR_IN_SYSMACROS
#include <sys/sysmacros.h>
#endif
#include "loader.h"

#ifdef HAVE_LIBDRM
#include <stdlib.h>
#include <unistd.h>
#include <xf86drm.h>
#ifdef USE_DRICONF
#include "xmlconfig.h"
#include "xmlpool.h"
#endif
#endif

#define __IS_LOADER
#include "pci_id_driver_map.h"

static void default_logger(int level, const char *fmt, ...)
{
   if (level <= _LOADER_WARNING) {
      va_list args;
      va_start(args, fmt);
      vfprintf(stderr, fmt, args);
      va_end(args);
   }
}

static void (*log_)(int level, const char *fmt, ...) = default_logger;

int
loader_open_device(const char *device_name)
{
   int fd;
#ifdef O_CLOEXEC
   fd = open(device_name, O_RDWR | O_CLOEXEC);
   if (fd == -1 && errno == EINVAL)
#endif
   {
      fd = open(device_name, O_RDWR);
      if (fd != -1)
         fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);
   }
   return fd;
}

#if defined(HAVE_LIBDRM)
#ifdef USE_DRICONF
static const char __driConfigOptionsLoader[] =
DRI_CONF_BEGIN
    DRI_CONF_SECTION_INITIALIZATION
        DRI_CONF_DEVICE_ID_PATH_TAG()
    DRI_CONF_SECTION_END
DRI_CONF_END;

static char *loader_get_dri_config_device_id(void)
{
   driOptionCache defaultInitOptions;
   driOptionCache userInitOptions;
   char *prime = NULL;

   driParseOptionInfo(&defaultInitOptions, __driConfigOptionsLoader);
   driParseConfigFiles(&userInitOptions, &defaultInitOptions, 0, "loader");
   if (driCheckOption(&userInitOptions, "device_id", DRI_STRING))
      prime = strdup(driQueryOptionstr(&userInitOptions, "device_id"));
   driDestroyOptionCache(&userInitOptions);
   driDestroyOptionInfo(&defaultInitOptions);

   return prime;
}
#endif

static char *drm_construct_id_path_tag(drmDevicePtr device)
{
/* Length of "pci-xxxx_xx_xx_x\0" */
#define PCI_ID_PATH_TAG_LENGTH 17
   char *tag = NULL;

   if (device->bustype == DRM_BUS_PCI) {
        tag = calloc(PCI_ID_PATH_TAG_LENGTH, sizeof(char));
        if (tag == NULL)
            return NULL;

        snprintf(tag, PCI_ID_PATH_TAG_LENGTH, "pci-%04x_%02x_%02x_%1u",
                 device->businfo.pci->domain, device->businfo.pci->bus,
                 device->businfo.pci->dev, device->businfo.pci->func);
   }
   return tag;
}

static bool drm_device_matches_tag(drmDevicePtr device, const char *prime_tag)
{
   char *tag = drm_construct_id_path_tag(device);
   int ret;

   if (tag == NULL)
      return false;

   ret = strcmp(tag, prime_tag);

   free(tag);
   return ret == 0;
}

static char *drm_get_id_path_tag_for_fd(int fd)
{
   drmDevicePtr device;
   char *tag;

   if (drmGetDevice(fd, &device) != 0)
       return NULL;

   tag = drm_construct_id_path_tag(device);
   drmFreeDevice(&device);
   return tag;
}

int loader_get_user_preferred_fd(int default_fd, int *different_device)
{
/* Arbitrary "maximum" value of drm devices. */
#define MAX_DRM_DEVICES 32
   const char *dri_prime = getenv("DRI_PRIME");
   char *default_tag, *prime = NULL;
   drmDevicePtr devices[MAX_DRM_DEVICES];
   int i, num_devices, fd;
   bool found = false;

   if (dri_prime)
      prime = strdup(dri_prime);
#ifdef USE_DRICONF
   else
      prime = loader_get_dri_config_device_id();
#endif

   if (prime == NULL) {
      *different_device = 0;
      return default_fd;
   }

   default_tag = drm_get_id_path_tag_for_fd(default_fd);
   if (default_tag == NULL)
      goto err;

   num_devices = drmGetDevices(devices, MAX_DRM_DEVICES);
   if (num_devices < 0)
      goto err;

   /* two format are supported:
    * "1": choose any other card than the card used by default.
    * id_path_tag: (for example "pci-0000_02_00_0") choose the card
    * with this id_path_tag.
    */
   if (!strcmp(prime,"1")) {
      /* Hmm... detection for 2-7 seems to be broken. Oh well ...
       * Pick the first render device that is not our own.
       */
      for (i = 0; i < num_devices; i++) {
         if (devices[i]->available_nodes & 1 << DRM_NODE_RENDER &&
             !drm_device_matches_tag(devices[i], default_tag)) {

            found = true;
            break;
         }
      }
   } else {
      for (i = 0; i < num_devices; i++) {
         if (devices[i]->available_nodes & 1 << DRM_NODE_RENDER &&
            drm_device_matches_tag(devices[i], prime)) {

            found = true;
            break;
         }
      }
   }

   if (!found) {
      drmFreeDevices(devices, num_devices);
      goto err;
   }

   fd = loader_open_device(devices[i]->nodes[DRM_NODE_RENDER]);
   drmFreeDevices(devices, num_devices);
   if (fd < 0)
      goto err;

   close(default_fd);

   *different_device = !!strcmp(default_tag, prime);

   free(default_tag);
   free(prime);
   return fd;

 err:
   *different_device = 0;

   free(default_tag);
   free(prime);
   return default_fd;
}
#else
int loader_get_user_preferred_fd(int default_fd, int *different_device)
{
   *different_device = 0;
   return default_fd;
}
#endif

#if defined(HAVE_LIBDRM)
static int
dev_node_from_fd(int fd, unsigned int *maj, unsigned int *min)
{
   struct stat buf;

   if (fstat(fd, &buf) < 0) {
      log_(_LOADER_WARNING, "MESA-LOADER: failed to stat fd %d\n", fd);
      return -1;
   }

   if (!S_ISCHR(buf.st_mode)) {
      log_(_LOADER_WARNING, "MESA-LOADER: fd %d not a character device\n", fd);
      return -1;
   }

   *maj = major(buf.st_rdev);
   *min = minor(buf.st_rdev);

   return 0;
}
#endif

#if defined(HAVE_LIBDRM)

static int
drm_get_pci_id_for_fd(int fd, int *vendor_id, int *chip_id)
{
   drmDevicePtr device;
   int ret;

   if (drmGetDevice(fd, &device) == 0) {
      if (device->bustype == DRM_BUS_PCI) {
         *vendor_id = device->deviceinfo.pci->vendor_id;
         *chip_id = device->deviceinfo.pci->device_id;
         ret = 1;
      }
      else {
         log_(_LOADER_WARNING, "MESA-LOADER: device is not located on the PCI bus\n");
         ret = 0;
      }
      drmFreeDevice(&device);
   }
   else {
      log_(_LOADER_WARNING, "MESA-LOADER: failed to retrieve device information\n");
      ret = 0;
   }

   return ret;
}
#endif


int
loader_get_pci_id_for_fd(int fd, int *vendor_id, int *chip_id)
{
#if HAVE_LIBDRM
   if (drm_get_pci_id_for_fd(fd, vendor_id, chip_id))
      return 1;
#endif
   return 0;
}


#if defined(HAVE_LIBDRM)
static char *
drm_get_device_name_for_fd(int fd)
{
   unsigned int maj, min;
   char buf[0x40];
   int n;

   if (dev_node_from_fd(fd, &maj, &min) < 0)
      return NULL;

   n = snprintf(buf, sizeof(buf), DRM_DEV_NAME, DRM_DIR_NAME, min);
   if (n == -1 || n >= sizeof(buf))
      return NULL;

   return strdup(buf);
}
#endif

char *
loader_get_device_name_for_fd(int fd)
{
   char *result = NULL;

#if HAVE_LIBDRM
   if ((result = drm_get_device_name_for_fd(fd)))
      return result;
#endif
   return result;
}

char *
loader_get_driver_for_fd(int fd)
{
   int vendor_id, chip_id, i, j;
   char *driver = NULL;

   if (!loader_get_pci_id_for_fd(fd, &vendor_id, &chip_id)) {

#if HAVE_LIBDRM
      /* fallback to drmGetVersion(): */
      drmVersionPtr version = drmGetVersion(fd);

      if (!version) {
         log_(_LOADER_WARNING, "failed to get driver name for fd %d\n", fd);
         return NULL;
      }

      driver = strndup(version->name, version->name_len);
      log_(_LOADER_INFO, "using driver %s for %d\n", driver, fd);

      drmFreeVersion(version);
#endif

      return driver;
   }

   for (i = 0; driver_map[i].driver; i++) {
      if (vendor_id != driver_map[i].vendor_id)
         continue;

      if (driver_map[i].predicate && !driver_map[i].predicate(fd))
         continue;

      if (driver_map[i].num_chips_ids == -1) {
         driver = strdup(driver_map[i].driver);
         goto out;
      }

      for (j = 0; j < driver_map[i].num_chips_ids; j++)
         if (driver_map[i].chip_ids[j] == chip_id) {
            driver = strdup(driver_map[i].driver);
            goto out;
         }
   }

out:
   log_(driver ? _LOADER_DEBUG : _LOADER_WARNING,
         "pci id for fd %d: %04x:%04x, driver %s\n",
         fd, vendor_id, chip_id, driver);
   return driver;
}

void
loader_set_logger(void (*logger)(int level, const char *fmt, ...))
{
   log_ = logger;
}
@


1.1
log
@Initial revision
@
text
@d3 2
a4 40
 *
 * This code is derived from the following files.
 *
 * * src/glx/dri3_common.c
 * Copyright © 2013 Keith Packard
 *
 * * src/egl/drivers/dri2/common.c
 * * src/gbm/backends/dri/driver_name.c
 * Copyright © 2011 Intel Corporation
 *
 * Authors:
 *    Kristian Høgsberg <krh@@bitplanet.net>
 *    Benjamin Franzke <benjaminfranzke@@googlemail.com>
 *
 * * src/gallium/targets/egl-static/egl.c
 * Copyright (C) 2010-2011 LunarG Inc.
 *
 * Authors:
 *    Chia-I Wu <olv@@lunarg.com>
 *
 * * src/gallium/state_trackers/egl/drm/native_drm.c
 * Copyright (C) 2010 Chia-I Wu <olv@@0xlab.org>
 *
 * * src/egl/drivers/dri2/platform_android.c
 *
 * Copyright (C) 2010-2011 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright (C) 2010-2011 LunarG Inc.
 *
 * Based on platform_x11, which has
 *
 * Copyright © 2011 Intel Corporation
 *
 * * src/gallium/auxiliary/pipe-loader/pipe_loader_drm.c
 * Copyright 2011 Intel Corporation
 * Copyright 2012 Francisco Jerez
 * All Rights Reserved.
 *
 * Authors:
 *    Kristian Høgsberg <krh@@bitplanet.net>
 *    Benjamin Franzke <benjaminfranzke@@googlemail.com>
d34 1
d36 2
a37 9
#ifdef HAVE_LIBUDEV
#include <assert.h>
#include <dlfcn.h>
#include <unistd.h>
#include <stdlib.h>
#ifdef USE_DRICONF
#include "xmlconfig.h"
#include "xmlpool.h"
#endif
d39 2
a40 2
#ifdef HAVE_SYSFS
#include <sys/types.h>
d45 2
d48 4
d85 8
a92 2
#ifdef HAVE_LIBUDEV
#include <libudev.h>
d94 1
a94 4
static void *udev_handle = NULL;

static void *
udev_dlopen_handle(void)
d96 3
a98 10
   char name[80];
   unsigned flags = RTLD_NOLOAD | RTLD_LOCAL | RTLD_LAZY;
   int version;

   /* libudev.so.1 changed the return types of the two unref functions
    * from voids to pointers.  We don't use those return values, and the
    * only ABI I've heard that cares about this kind of change (calling
    * a function with a void * return that actually only returns void)
    * might be ia64.
    */
d100 6
a105 14
   /* First try opening an already linked libudev, then try loading one */
   do {
      for (version = 1; version >= 0; version--) {
         snprintf(name, sizeof(name), "libudev.so.%d", version);
         udev_handle = dlopen(name, flags);
         if (udev_handle)
            return udev_handle;
      }

      if ((flags & RTLD_NOLOAD) == 0)
         break;

      flags &= ~RTLD_NOLOAD;
   } while (1);
d107 1
a107 4
   log_(_LOADER_WARNING,
        "Couldn't dlopen libudev.so.1 or "
        "libudev.so.0, driver detection may be broken.\n");
   return NULL;
d109 1
d111 1
a111 17
static int dlsym_failed = 0;

static void *
checked_dlsym(void *dlopen_handle, const char *name)
{
   void *result = dlsym(dlopen_handle, name);
   if (!result)
      dlsym_failed = 1;
   return result;
}

#define UDEV_SYMBOL(ret, name, args) \
   ret (*name) args = checked_dlsym(udev_dlopen_handle(), #name);


static inline struct udev_device *
udev_device_new_from_fd(struct udev *udev, int fd)
d113 3
a115 4
   struct udev_device *device;
   struct stat buf;
   UDEV_SYMBOL(struct udev_device *, udev_device_new_from_devnum,
               (struct udev *udev, char type, dev_t devnum));
d117 4
a120 7
   if (dlsym_failed)
      return NULL;

   if (fstat(fd, &buf) < 0) {
      log_(_LOADER_WARNING, "MESA-LOADER: failed to stat fd %d\n", fd);
      return NULL;
   }
d122 3
a124 5
   device = udev_device_new_from_devnum(udev, 'c', buf.st_rdev);
   if (device == NULL) {
      log_(_LOADER_WARNING,
              "MESA-LOADER: could not create udev device for fd %d\n", fd);
      return NULL;
d126 1
a126 2

   return device;
d129 1
a129 2
static int
libudev_get_pci_id_for_fd(int fd, int *vendor_id, int *chip_id)
d131 2
a132 47
   struct udev *udev = NULL;
   struct udev_device *device = NULL, *parent;
   const char *pci_id;
   UDEV_SYMBOL(struct udev *, udev_new, (void));
   UDEV_SYMBOL(struct udev_device *, udev_device_get_parent,
               (struct udev_device *));
   UDEV_SYMBOL(const char *, udev_device_get_property_value,
               (struct udev_device *, const char *));
   UDEV_SYMBOL(struct udev_device *, udev_device_unref,
               (struct udev_device *));
   UDEV_SYMBOL(struct udev *, udev_unref, (struct udev *));

   *chip_id = -1;

   if (dlsym_failed)
      return 0;

   udev = udev_new();
   device = udev_device_new_from_fd(udev, fd);
   if (!device)
      goto out;

   parent = udev_device_get_parent(device);
   if (parent == NULL) {
      log_(_LOADER_WARNING, "MESA-LOADER: could not get parent device\n");
      goto out;
   }

   pci_id = udev_device_get_property_value(parent, "PCI_ID");
   if (pci_id == NULL) {
      log_(_LOADER_INFO, "MESA-LOADER: no PCI ID\n");
      *chip_id = -1;
      goto out;
   } else if (sscanf(pci_id, "%x:%x", vendor_id, chip_id) != 2) {
      log_(_LOADER_WARNING, "MESA-LOADER: malformed PCI ID\n");
      *chip_id = -1;
      goto out;
   }

out:
   if (device)
      udev_device_unref(device);
   if (udev)
      udev_unref(udev);

   return (*chip_id >= 0);
}
d134 2
a135 56
static char *
get_render_node_from_id_path_tag(struct udev *udev,
                                 char *id_path_tag,
                                 char another_tag)
{
   struct udev_device *device;
   struct udev_enumerate *e;
   struct udev_list_entry *entry;
   const char *path, *id_path_tag_tmp;
   char *path_res;
   char found = 0;
   UDEV_SYMBOL(struct udev_enumerate *, udev_enumerate_new,
               (struct udev *));
   UDEV_SYMBOL(int, udev_enumerate_add_match_subsystem,
               (struct udev_enumerate *, const char *));
   UDEV_SYMBOL(int, udev_enumerate_add_match_sysname,
               (struct udev_enumerate *, const char *));
   UDEV_SYMBOL(int, udev_enumerate_scan_devices,
               (struct udev_enumerate *));
   UDEV_SYMBOL(struct udev_list_entry *, udev_enumerate_get_list_entry,
               (struct udev_enumerate *));
   UDEV_SYMBOL(void, udev_enumerate_unref,
               (struct udev_enumerate *));
   UDEV_SYMBOL(struct udev_list_entry *, udev_list_entry_get_next,
               (struct udev_list_entry *));
   UDEV_SYMBOL(const char *, udev_list_entry_get_name,
               (struct udev_list_entry *));
   UDEV_SYMBOL(struct udev_device *, udev_device_new_from_syspath,
               (struct udev *, const char *));
   UDEV_SYMBOL(const char *, udev_device_get_property_value,
               (struct udev_device *, const char *));
   UDEV_SYMBOL(const char *, udev_device_get_devnode,
               (struct udev_device *));
   UDEV_SYMBOL(struct udev_device *, udev_device_unref,
               (struct udev_device *));

   e = udev_enumerate_new(udev);
   udev_enumerate_add_match_subsystem(e, "drm");
   udev_enumerate_add_match_sysname(e, "render*");

   udev_enumerate_scan_devices(e);
   udev_list_entry_foreach(entry, udev_enumerate_get_list_entry(e)) {
      path = udev_list_entry_get_name(entry);
      device = udev_device_new_from_syspath(udev, path);
      if (!device)
         continue;
      id_path_tag_tmp = udev_device_get_property_value(device, "ID_PATH_TAG");
      if (id_path_tag_tmp) {
         if ((!another_tag && !strcmp(id_path_tag, id_path_tag_tmp)) ||
             (another_tag && strcmp(id_path_tag, id_path_tag_tmp))) {
            found = 1;
            break;
         }
      }
      udev_device_unref(device);
   }
d137 1
a137 1
   udev_enumerate_unref(e);
d139 2
a140 6
   if (found) {
      path_res = strdup(udev_device_get_devnode(device));
      udev_device_unref(device);
      return path_res;
   }
   return NULL;
d143 1
a143 2
static char *
get_id_path_tag_from_fd(struct udev *udev, int fd)
d145 2
a146 7
   struct udev_device *device;
   const char *id_path_tag_tmp;
   char *id_path_tag;
   UDEV_SYMBOL(const char *, udev_device_get_property_value,
               (struct udev_device *, const char *));
   UDEV_SYMBOL(struct udev_device *, udev_device_unref,
               (struct udev_device *));
d148 2
a149 9
   device = udev_device_new_from_fd(udev, fd);
   if (!device)
      return NULL;

   id_path_tag_tmp = udev_device_get_property_value(device, "ID_PATH_TAG");
   if (!id_path_tag_tmp)
      return NULL;

   id_path_tag = strdup(id_path_tag_tmp);
d151 3
a153 2
   udev_device_unref(device);
   return id_path_tag;
a155 9
#ifdef USE_DRICONF
const char __driConfigOptionsLoader[] =
DRI_CONF_BEGIN
    DRI_CONF_SECTION_INITIALIZATION
        DRI_CONF_DEVICE_ID_PATH_TAG()
    DRI_CONF_SECTION_END
DRI_CONF_END;
#endif

d158 2
a159 5
   struct udev *udev;
#ifdef USE_DRICONF
   driOptionCache defaultInitOptions;
   driOptionCache userInitOptions;
#endif
d161 4
a164 7
   char *prime = NULL;
   int is_different_device = 0, fd = default_fd;
   char *default_device_id_path_tag;
   char *device_name = NULL;
   char another_tag = 0;
   UDEV_SYMBOL(struct udev *, udev_new, (void));
   UDEV_SYMBOL(struct udev *, udev_unref, (struct udev *));
d169 2
a170 8
   else {
      driParseOptionInfo(&defaultInitOptions, __driConfigOptionsLoader);
      driParseConfigFiles(&userInitOptions, &defaultInitOptions, 0, "loader");
      if (driCheckOption(&userInitOptions, "device_id", DRI_STRING))
         prime = strdup(driQueryOptionstr(&userInitOptions, "device_id"));
      driDestroyOptionCache(&userInitOptions);
      driDestroyOptionInfo(&defaultInitOptions);
   }
d178 7
a184 7
   udev = udev_new();
   if (!udev)
      goto prime_clean;

   default_device_id_path_tag = get_id_path_tag_from_fd(udev, default_fd);
   if (!default_device_id_path_tag)
      goto udev_clean;
a185 1
   is_different_device = 1;
d192 11
a202 19
      free(prime);
      prime = strdup(default_device_id_path_tag);
      /* request a card with a different card than the default card */
      another_tag = 1;
   } else if (!strcmp(default_device_id_path_tag, prime))
      /* we are to get a new fd (render-node) of the same device */
      is_different_device = 0;

   device_name = get_render_node_from_id_path_tag(udev,
                                                  prime,
                                                  another_tag);
   if (device_name == NULL) {
      is_different_device = 0;
      goto default_device_clean;
   }

   fd = loader_open_device(device_name);
   if (fd >= 0) {
      close(default_fd);
d204 8
a211 2
      fd = default_fd;
      is_different_device = 0;
a212 1
   free(device_name);
d214 15
a228 5
 default_device_clean:
   free(default_device_id_path_tag);
 udev_clean:
   udev_unref(udev);
 prime_clean:
d230 1
d232 6
a237 2
   *different_device = is_different_device;
   return fd;
d247 1
a247 1
#if defined(HAVE_SYSFS)
a267 37

static int
sysfs_get_pci_id_for_fd(int fd, int *vendor_id, int *chip_id)
{
   unsigned int maj, min;
   FILE *f;
   char buf[0x40];

   if (dev_node_from_fd(fd, &maj, &min) < 0) {
      *chip_id = -1;
      return 0;
   }

   snprintf(buf, sizeof(buf), "/sys/dev/char/%d:%d/device/vendor", maj, min);
   if (!(f = fopen(buf, "r"))) {
      *chip_id = -1;
      return 0;
   }
   if (fscanf(f, "%x", vendor_id) != 1) {
      *chip_id = -1;
      fclose(f);
      return 0;
   }
   fclose(f);
   snprintf(buf, sizeof(buf), "/sys/dev/char/%d:%d/device/device", maj, min);
   if (!(f = fopen(buf, "r"))) {
      *chip_id = -1;
      return 0;
   }
   if (fscanf(f, "%x", chip_id) != 1) {
      *chip_id = -1;
      fclose(f);
      return 0;
   }
   fclose(f);
   return 1;
}
a270 4
/* for i915 */
#include <i915_drm.h>
/* for radeon */
#include <radeon_drm.h>
d275 2
a276 1
   drmVersionPtr version;
d278 5
a282 26
   *chip_id = -1;

   version = drmGetVersion(fd);
   if (!version) {
      log_(_LOADER_WARNING, "MESA-LOADER: invalid drm fd\n");
      return 0;
   }
   if (!version->name) {
      log_(_LOADER_WARNING, "MESA-LOADER: unable to determine the driver name\n");
      drmFreeVersion(version);
      return 0;
   }

   if (strcmp(version->name, "i915") == 0) {
      struct drm_i915_getparam gp;
      int ret;

      *vendor_id = 0x8086;

      memset(&gp, 0, sizeof(gp));
      gp.param = I915_PARAM_CHIPSET_ID;
      gp.value = chip_id;
      ret = drmCommandWriteRead(fd, DRM_I915_GETPARAM, &gp, sizeof(gp));
      if (ret) {
         log_(_LOADER_WARNING, "MESA-LOADER: failed to get param for i915\n");
	 *chip_id = -1;
d284 3
a286 14
   }
   else if (strcmp(version->name, "radeon") == 0) {
      struct drm_radeon_info info;
      int ret;

      *vendor_id = 0x1002;

      memset(&info, 0, sizeof(info));
      info.request = RADEON_INFO_DEVICE_ID;
      info.value = (unsigned long) chip_id;
      ret = drmCommandWriteRead(fd, DRM_RADEON_INFO, &info, sizeof(info));
      if (ret) {
         log_(_LOADER_WARNING, "MESA-LOADER: failed to get info for radeon\n");
	 *chip_id = -1;
d288 1
d290 3
a292 9
   else if (strcmp(version->name, "nouveau") == 0) {
      *vendor_id = 0x10de;
      /* not used */
      *chip_id = 0;
   }
   else if (strcmp(version->name, "vmwgfx") == 0) {
      *vendor_id = 0x15ad;
      /* assume SVGA II */
      *chip_id = 0x0405;
d295 1
a295 3
   drmFreeVersion(version);

   return (*chip_id >= 0);
a302 8
#if HAVE_LIBUDEV
   if (libudev_get_pci_id_for_fd(fd, vendor_id, chip_id))
      return 1;
#endif
#if HAVE_SYSFS
   if (sysfs_get_pci_id_for_fd(fd, vendor_id, chip_id))
      return 1;
#endif
d311 1
a311 1
#ifdef HAVE_LIBUDEV
d313 1
a313 1
libudev_get_device_name_for_fd(int fd)
a314 37
   char *device_name = NULL;
   struct udev *udev;
   struct udev_device *device;
   const char *const_device_name;
   UDEV_SYMBOL(struct udev *, udev_new, (void));
   UDEV_SYMBOL(const char *, udev_device_get_devnode,
               (struct udev_device *));
   UDEV_SYMBOL(struct udev_device *, udev_device_unref,
               (struct udev_device *));
   UDEV_SYMBOL(struct udev *, udev_unref, (struct udev *));

   if (dlsym_failed)
      return NULL;

   udev = udev_new();
   device = udev_device_new_from_fd(udev, fd);
   if (device == NULL)
      return NULL;

   const_device_name = udev_device_get_devnode(device);
   if (!const_device_name)
      goto out;
   device_name = strdup(const_device_name);

out:
   udev_device_unref(device);
   udev_unref(udev);
   return device_name;
}
#endif


#if HAVE_SYSFS
static char *
sysfs_get_device_name_for_fd(int fd)
{
   char *device_name = NULL;
a315 1
   FILE *f;
d317 1
a317 2
   static const char match[9] = "\0DEVNAME=";
   int expected = 1;
d322 3
a324 3
   snprintf(buf, sizeof(buf), "/sys/dev/char/%d:%d/uevent", maj, min);
   if (!(f = fopen(buf, "r")))
       return NULL;
d326 1
a326 18
   while (expected < sizeof(match)) {
      int c = getc(f);

      if (c == EOF) {
         fclose(f);
         return NULL;
      } else if (c == match[expected] )
         expected++;
      else
         expected = 0;
   }

   strcpy(buf, "/dev/");
   if (fgets(buf + 5, sizeof(buf) - 5, f))
      device_name = strdup(buf);

   fclose(f);
   return device_name;
a329 1

d335 2
a336 6
#if HAVE_LIBUDEV
   if ((result = libudev_get_device_name_for_fd(fd)))
      return result;
#endif
#if HAVE_SYSFS
   if ((result = sysfs_get_device_name_for_fd(fd)))
d343 1
a343 1
loader_get_driver_for_fd(int fd, unsigned driver_types)
a347 3
   if (!driver_types)
      driver_types = _LOADER_GALLIUM | _LOADER_DRI;

a369 3
         continue;

      if (!(driver_types & driver_map[i].driver_types))
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 13.0.2
@
text
@d3 40
a42 2
 * Copyright (C) 2014-2016 Emil Velikov <emil.l.velikov@@gmail.com>
 * Copyright (C) 2016 Intel Corporation
a71 1
#include <stdbool.h>
d73 9
a81 2
#ifdef MAJOR_IN_MKDEV
#include <sys/mkdev.h>
d83 2
a84 2
#ifdef MAJOR_IN_SYSMACROS
#include <sys/sysmacros.h>
a88 2
#include <stdlib.h>
#include <unistd.h>
a89 4
#ifdef USE_DRICONF
#include "xmlconfig.h"
#include "xmlpool.h"
#endif
d123 4
a126 8
#if defined(HAVE_LIBDRM)
#ifdef USE_DRICONF
static const char __driConfigOptionsLoader[] =
DRI_CONF_BEGIN
    DRI_CONF_SECTION_INITIALIZATION
        DRI_CONF_DEVICE_ID_PATH_TAG()
    DRI_CONF_SECTION_END
DRI_CONF_END;
d128 2
a129 1
static char *loader_get_dri_config_device_id(void)
d131 31
a161 3
   driOptionCache defaultInitOptions;
   driOptionCache userInitOptions;
   char *prime = NULL;
d163 1
a163 6
   driParseOptionInfo(&defaultInitOptions, __driConfigOptionsLoader);
   driParseConfigFiles(&userInitOptions, &defaultInitOptions, 0, "loader");
   if (driCheckOption(&userInitOptions, "device_id", DRI_STRING))
      prime = strdup(driQueryOptionstr(&userInitOptions, "device_id"));
   driDestroyOptionCache(&userInitOptions);
   driDestroyOptionInfo(&defaultInitOptions);
d165 7
a171 1
   return prime;
a172 1
#endif
d174 6
a179 1
static char *drm_construct_id_path_tag(drmDevicePtr device)
d181 4
a184 3
/* Length of "pci-xxxx_xx_xx_x\0" */
#define PCI_ID_PATH_TAG_LENGTH 17
   char *tag = NULL;
d186 7
a192 4
   if (device->bustype == DRM_BUS_PCI) {
        tag = calloc(PCI_ID_PATH_TAG_LENGTH, sizeof(char));
        if (tag == NULL)
            return NULL;
d194 5
a198 3
        snprintf(tag, PCI_ID_PATH_TAG_LENGTH, "pci-%04x_%02x_%02x_%1u",
                 device->businfo.pci->domain, device->businfo.pci->bus,
                 device->businfo.pci->dev, device->businfo.pci->func);
d200 2
a201 1
   return tag;
d204 2
a205 1
static bool drm_device_matches_tag(drmDevicePtr device, const char *prime_tag)
d207 47
a253 2
   char *tag = drm_construct_id_path_tag(device);
   int ret;
d255 56
a310 2
   if (tag == NULL)
      return false;
d312 1
a312 1
   ret = strcmp(tag, prime_tag);
d314 6
a319 2
   free(tag);
   return ret == 0;
d322 2
a323 1
static char *drm_get_id_path_tag_for_fd(int fd)
d325 7
a331 2
   drmDevicePtr device;
   char *tag;
d333 9
a341 2
   if (drmGetDevice(fd, &device) != 0)
       return NULL;
d343 2
a344 3
   tag = drm_construct_id_path_tag(device);
   drmFreeDevice(&device);
   return tag;
d347 9
d358 5
a362 2
/* Arbitrary "maximum" value of drm devices. */
#define MAX_DRM_DEVICES 32
d364 7
a370 4
   char *default_tag, *prime = NULL;
   drmDevicePtr devices[MAX_DRM_DEVICES];
   int i, num_devices, fd;
   bool found = false;
d375 8
a382 2
   else
      prime = loader_get_dri_config_device_id();
d390 7
a396 7
   default_tag = drm_get_id_path_tag_for_fd(default_fd);
   if (default_tag == NULL)
      goto err;

   num_devices = drmGetDevices(devices, MAX_DRM_DEVICES);
   if (num_devices < 0)
      goto err;
d398 1
d405 19
a423 11
      /* Hmm... detection for 2-7 seems to be broken. Oh well ...
       * Pick the first render device that is not our own.
       */
      for (i = 0; i < num_devices; i++) {
         if (devices[i]->available_nodes & 1 << DRM_NODE_RENDER &&
             !drm_device_matches_tag(devices[i], default_tag)) {

            found = true;
            break;
         }
      }
d425 2
a426 8
      for (i = 0; i < num_devices; i++) {
         if (devices[i]->available_nodes & 1 << DRM_NODE_RENDER &&
            drm_device_matches_tag(devices[i], prime)) {

            found = true;
            break;
         }
      }
d428 1
d430 6
a435 11
   if (!found) {
      drmFreeDevices(devices, num_devices);
      goto err;
   }

   fd = loader_open_device(devices[i]->nodes[DRM_NODE_RENDER]);
   drmFreeDevices(devices, num_devices);
   if (fd < 0)
      goto err;

   close(default_fd);
d437 1
a437 4
   *different_device = !!strcmp(default_tag, prime);

   free(default_tag);
   free(prime);
a438 7

 err:
   *different_device = 0;

   free(default_tag);
   free(prime);
   return default_fd;
d448 1
a448 1
#if defined(HAVE_LIBDRM)
d469 37
d509 4
d517 1
a517 2
   drmDevicePtr device;
   int ret;
d519 26
a544 5
   if (drmGetDevice(fd, &device) == 0) {
      if (device->bustype == DRM_BUS_PCI) {
         *vendor_id = device->deviceinfo.pci->vendor_id;
         *chip_id = device->deviceinfo.pci->device_id;
         ret = 1;
d546 14
a559 3
      else {
         log_(_LOADER_WARNING, "MESA-LOADER: device is not located on the PCI bus\n");
         ret = 0;
a560 1
      drmFreeDevice(&device);
d562 9
a570 3
   else {
      log_(_LOADER_WARNING, "MESA-LOADER: failed to retrieve device information\n");
      ret = 0;
d573 3
a575 1
   return ret;
d583 8
d599 37
a635 1
#if defined(HAVE_LIBDRM)
d637 1
a637 1
drm_get_device_name_for_fd(int fd)
d639 1
d641 1
d643 2
a644 1
   int n;
d649 19
a667 3
   n = snprintf(buf, sizeof(buf), DRM_DEV_NAME, DRM_DIR_NAME, min);
   if (n == -1 || n >= sizeof(buf))
      return NULL;
d669 2
a670 1
   return strdup(buf);
d674 1
d680 6
a685 2
#if HAVE_LIBDRM
   if ((result = drm_get_device_name_for_fd(fd)))
d692 1
a692 1
loader_get_driver_for_fd(int fd)
d697 3
d722 3
@


1.1.1.3
log
@Import Mesa 17.1.6
@
text
@a35 2
#include <unistd.h>
#include <stdlib.h>
d45 2
d148 1
a148 1
   if (drmGetDevice2(fd, 0, &device) != 0)
d182 1
a182 1
   num_devices = drmGetDevices2(0, devices, MAX_DRM_DEVICES);
d278 1
a278 1
   if (drmGetDevice2(fd, 0, &device) == 0) {
d285 1
a285 1
         log_(_LOADER_DEBUG, "MESA-LOADER: device is not located on the PCI bus\n");
a347 11
   /* Allow an environment variable to force choosing a different driver
    * binary.  If that driver binary can't survive on this FD, that's the
    * user's problem, but this allows vc4 simulator to run on an i965 host,
    * and may be useful for some touch testing of i915 on an i965 host.
    */
   if (geteuid() == getuid()) {
      driver = getenv("MESA_LOADER_DRIVER_OVERRIDE");
      if (driver)
         return strdup(driver);
   }

a397 25
}

/* XXX: Local definition to avoid pulling the heavyweight GL/gl.h and
 * GL/internal/dri_interface.h
 */

#ifndef __DRI_DRIVER_GET_EXTENSIONS
#define __DRI_DRIVER_GET_EXTENSIONS "__driDriverGetExtensions"
#endif

char *
loader_get_extensions_name(const char *driver_name)
{
   char *name = NULL;

   if (asprintf(&name, "%s_%s", __DRI_DRIVER_GET_EXTENSIONS, driver_name) < 0)
      return NULL;

   const size_t len = strlen(name);
   for (size_t i = 0; i < len; i++) {
	   if (name[i] == '-')
		   name[i] = '_';
   }

   return name;
@


