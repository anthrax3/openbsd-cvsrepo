head	1.1;
branch	1.1.1;
access;
symbols
	mesa-17_1_6:1.1.1.2
	OPENBSD_6_1:1.1.1.1.0.2
	OPENBSD_6_1_BASE:1.1.1.1
	mesa-13_0_6:1.1.1.1
	mesa-13_0_5:1.1.1.1
	mesa-13_0_3:1.1.1.1
	mesa-13_0_2:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.1
date	2016.12.11.08.35.53;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	uuv5VTS15jglEDZU;

1.1.1.1
date	2016.12.11.08.35.53;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	uuv5VTS15jglEDZU;

1.1.1.2
date	2017.08.14.09.41.13;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright Â© 2014 Advanced Micro Devices, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
 * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 */

/**
***************************************************************************************************
* @@file  addrinterface.cpp
* @@brief Contains the addrlib interface functions
***************************************************************************************************
*/
#include "addrinterface.h"
#include "addrlib.h"

#include "addrcommon.h"

///////////////////////////////////////////////////////////////////////////////////////////////////
//                               Create/Destroy/Config functions
///////////////////////////////////////////////////////////////////////////////////////////////////

/**
***************************************************************************************************
*   AddrCreate
*
*   @@brief
*       Create address lib object
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrCreate(
    const ADDR_CREATE_INPUT*    pAddrCreateIn,  ///< [in] infomation for creating address lib object
    ADDR_CREATE_OUTPUT*         pAddrCreateOut) ///< [out] address lib handle
{
    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    returnCode = AddrLib::Create(pAddrCreateIn, pAddrCreateOut);

    return returnCode;
}



/**
***************************************************************************************************
*   AddrDestroy
*
*   @@brief
*       Destroy address lib object
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrDestroy(
    ADDR_HANDLE hLib) ///< [in] address lib handle
{
    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (hLib)
    {
        AddrLib* pLib = AddrLib::GetAddrLib(hLib);
        pLib->Destroy();
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}



///////////////////////////////////////////////////////////////////////////////////////////////////
//                                    Surface functions
///////////////////////////////////////////////////////////////////////////////////////////////////

/**
***************************************************************************************************
*   AddrComputeSurfaceInfo
*
*   @@brief
*       Calculate surface width/height/depth/alignments and suitable tiling mode
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeSurfaceInfo(
    ADDR_HANDLE                             hLib, ///< [in] address lib handle
    const ADDR_COMPUTE_SURFACE_INFO_INPUT*  pIn,  ///< [in] surface information
    ADDR_COMPUTE_SURFACE_INFO_OUTPUT*       pOut) ///< [out] surface parameters and alignments
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeSurfaceInfo(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}



/**
***************************************************************************************************
*   AddrComputeSurfaceAddrFromCoord
*
*   @@brief
*       Compute surface address according to coordinates
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeSurfaceAddrFromCoord(
    ADDR_HANDLE                                     hLib, ///< [in] address lib handle
    const ADDR_COMPUTE_SURFACE_ADDRFROMCOORD_INPUT* pIn,  ///< [in] surface info and coordinates
    ADDR_COMPUTE_SURFACE_ADDRFROMCOORD_OUTPUT*      pOut) ///< [out] surface address
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeSurfaceAddrFromCoord(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrComputeSurfaceCoordFromAddr
*
*   @@brief
*       Compute coordinates according to surface address
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeSurfaceCoordFromAddr(
    ADDR_HANDLE                                     hLib, ///< [in] address lib handle
    const ADDR_COMPUTE_SURFACE_COORDFROMADDR_INPUT* pIn,  ///< [in] surface info and address
    ADDR_COMPUTE_SURFACE_COORDFROMADDR_OUTPUT*      pOut) ///< [out] coordinates
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeSurfaceCoordFromAddr(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}



///////////////////////////////////////////////////////////////////////////////////////////////////
//                                   HTile functions
///////////////////////////////////////////////////////////////////////////////////////////////////

/**
***************************************************************************************************
*   AddrComputeHtileInfo
*
*   @@brief
*       Compute Htile pitch, height, base alignment and size in bytes
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeHtileInfo(
    ADDR_HANDLE                             hLib, ///< [in] address lib handle
    const ADDR_COMPUTE_HTILE_INFO_INPUT*    pIn,  ///< [in] Htile information
    ADDR_COMPUTE_HTILE_INFO_OUTPUT*         pOut) ///< [out] Htile pitch, height and size in bytes
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeHtileInfo(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrComputeHtileAddrFromCoord
*
*   @@brief
*       Compute Htile address according to coordinates (of depth buffer)
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeHtileAddrFromCoord(
    ADDR_HANDLE                                     hLib, ///< [in] address lib handle
    const ADDR_COMPUTE_HTILE_ADDRFROMCOORD_INPUT*   pIn,  ///< [in] Htile info and coordinates
    ADDR_COMPUTE_HTILE_ADDRFROMCOORD_OUTPUT*        pOut) ///< [out] Htile address
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeHtileAddrFromCoord(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrComputeHtileCoordFromAddr
*
*   @@brief
*       Compute coordinates within depth buffer (1st pixel of a micro tile) according to
*       Htile address
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeHtileCoordFromAddr(
    ADDR_HANDLE                                     hLib, ///< [in] address lib handle
    const ADDR_COMPUTE_HTILE_COORDFROMADDR_INPUT*   pIn,  ///< [in] Htile info and address
    ADDR_COMPUTE_HTILE_COORDFROMADDR_OUTPUT*        pOut) ///< [out] Htile coordinates
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeHtileCoordFromAddr(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}



///////////////////////////////////////////////////////////////////////////////////////////////////
//                                     C-mask functions
///////////////////////////////////////////////////////////////////////////////////////////////////

/**
***************************************************************************************************
*   AddrComputeCmaskInfo
*
*   @@brief
*       Compute Cmask pitch, height, base alignment and size in bytes from color buffer
*       info
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeCmaskInfo(
    ADDR_HANDLE                             hLib, ///< [in] address lib handle
    const ADDR_COMPUTE_CMASK_INFO_INPUT*    pIn,  ///< [in] Cmask pitch and height
    ADDR_COMPUTE_CMASK_INFO_OUTPUT*         pOut) ///< [out] Cmask pitch, height and size in bytes
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeCmaskInfo(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrComputeCmaskAddrFromCoord
*
*   @@brief
*       Compute Cmask address according to coordinates (of MSAA color buffer)
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeCmaskAddrFromCoord(
    ADDR_HANDLE                                     hLib, ///< [in] address lib handle
    const ADDR_COMPUTE_CMASK_ADDRFROMCOORD_INPUT*   pIn,  ///< [in] Cmask info and coordinates
    ADDR_COMPUTE_CMASK_ADDRFROMCOORD_OUTPUT*        pOut) ///< [out] Cmask address
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeCmaskAddrFromCoord(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrComputeCmaskCoordFromAddr
*
*   @@brief
*       Compute coordinates within color buffer (1st pixel of a micro tile) according to
*       Cmask address
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeCmaskCoordFromAddr(
    ADDR_HANDLE                                     hLib, ///< [in] address lib handle
    const ADDR_COMPUTE_CMASK_COORDFROMADDR_INPUT*   pIn,  ///< [in] Cmask info and address
    ADDR_COMPUTE_CMASK_COORDFROMADDR_OUTPUT*        pOut) ///< [out] Cmask coordinates
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeCmaskCoordFromAddr(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}



///////////////////////////////////////////////////////////////////////////////////////////////////
//                                     F-mask functions
///////////////////////////////////////////////////////////////////////////////////////////////////

/**
***************************************************************************************************
*   AddrComputeFmaskInfo
*
*   @@brief
*       Compute Fmask pitch/height/depth/alignments and size in bytes
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeFmaskInfo(
    ADDR_HANDLE                             hLib, ///< [in] address lib handle
    const ADDR_COMPUTE_FMASK_INFO_INPUT*    pIn,  ///< [in] Fmask information
    ADDR_COMPUTE_FMASK_INFO_OUTPUT*         pOut) ///< [out] Fmask pitch and height
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeFmaskInfo(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrComputeFmaskAddrFromCoord
*
*   @@brief
*       Compute Fmask address according to coordinates (x,y,slice,sample,plane)
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeFmaskAddrFromCoord(
    ADDR_HANDLE                                     hLib, ///< [in] address lib handle
    const ADDR_COMPUTE_FMASK_ADDRFROMCOORD_INPUT*   pIn,  ///< [in] Fmask info and coordinates
    ADDR_COMPUTE_FMASK_ADDRFROMCOORD_OUTPUT*        pOut) ///< [out] Fmask address
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeFmaskAddrFromCoord(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrComputeFmaskCoordFromAddr
*
*   @@brief
*       Compute coordinates (x,y,slice,sample,plane) according to Fmask address
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeFmaskCoordFromAddr(
    ADDR_HANDLE                                     hLib, ///< [in] address lib handle
    const ADDR_COMPUTE_FMASK_COORDFROMADDR_INPUT*   pIn,  ///< [in] Fmask info and address
    ADDR_COMPUTE_FMASK_COORDFROMADDR_OUTPUT*        pOut) ///< [out] Fmask coordinates
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeFmaskCoordFromAddr(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}



///////////////////////////////////////////////////////////////////////////////////////////////////
//                                     DCC key functions
///////////////////////////////////////////////////////////////////////////////////////////////////

/**
***************************************************************************************************
*   AddrComputeDccInfo
*
*   @@brief
*       Compute DCC key size, base alignment based on color surface size, tile info or tile index
*
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeDccInfo(
    ADDR_HANDLE                             hLib,   ///< [in] handle of addrlib
    const ADDR_COMPUTE_DCCINFO_INPUT*       pIn,    ///< [in] input
    ADDR_COMPUTE_DCCINFO_OUTPUT*            pOut)   ///< [out] output
{
    ADDR_E_RETURNCODE returnCode;

    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    if (pLib != NULL)
    {
       returnCode = pLib->ComputeDccInfo(pIn, pOut);
    }
    else
    {
       returnCode = ADDR_ERROR;
    }

    return returnCode;
}



///////////////////////////////////////////////////////////////////////////////
// Below functions are element related or helper functions
///////////////////////////////////////////////////////////////////////////////

/**
***************************************************************************************************
*   AddrGetVersion
*
*   @@brief
*       Get AddrLib version number. Client may check this return value against ADDRLIB_VERSION
*       defined in addrinterface.h to see if there is a mismatch.
***************************************************************************************************
*/
UINT_32 ADDR_API AddrGetVersion(ADDR_HANDLE hLib)
{
    UINT_32 version = 0;

    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_ASSERT(pLib != NULL);

    if (pLib)
    {
        version = pLib->GetVersion();
    }

    return version;
}

/**
***************************************************************************************************
*   AddrUseTileIndex
*
*   @@brief
*       Return TRUE if tileIndex is enabled in this address library
***************************************************************************************************
*/
BOOL_32 ADDR_API AddrUseTileIndex(ADDR_HANDLE hLib)
{
    BOOL_32 useTileIndex = FALSE;

    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_ASSERT(pLib != NULL);

    if (pLib)
    {
        useTileIndex = pLib->UseTileIndex(0);
    }

    return useTileIndex;
}

/**
***************************************************************************************************
*   AddrUseCombinedSwizzle
*
*   @@brief
*       Return TRUE if combined swizzle is enabled in this address library
***************************************************************************************************
*/
BOOL_32 ADDR_API AddrUseCombinedSwizzle(ADDR_HANDLE hLib)
{
    BOOL_32 useCombinedSwizzle = FALSE;

    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_ASSERT(pLib != NULL);

    if (pLib)
    {
        useCombinedSwizzle = pLib->UseCombinedSwizzle();
    }

    return useCombinedSwizzle;
}

/**
***************************************************************************************************
*   AddrExtractBankPipeSwizzle
*
*   @@brief
*       Extract Bank and Pipe swizzle from base256b
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrExtractBankPipeSwizzle(
    ADDR_HANDLE                                 hLib,     ///< [in] addrlib handle
    const ADDR_EXTRACT_BANKPIPE_SWIZZLE_INPUT*  pIn,      ///< [in] input structure
    ADDR_EXTRACT_BANKPIPE_SWIZZLE_OUTPUT*       pOut)     ///< [out] output structure
{
    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    if (pLib != NULL)
    {
        returnCode = pLib->ExtractBankPipeSwizzle(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrCombineBankPipeSwizzle
*
*   @@brief
*       Combine Bank and Pipe swizzle
*   @@return
*       ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrCombineBankPipeSwizzle(
    ADDR_HANDLE                                 hLib,
    const ADDR_COMBINE_BANKPIPE_SWIZZLE_INPUT*  pIn,
    ADDR_COMBINE_BANKPIPE_SWIZZLE_OUTPUT*       pOut)
{
    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    if (pLib != NULL)
    {
        returnCode = pLib->CombineBankPipeSwizzle(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrComputeSliceSwizzle
*
*   @@brief
*       Compute a swizzle for slice from a base swizzle
*   @@return
*       ADDR_OK if no error
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeSliceSwizzle(
    ADDR_HANDLE                                 hLib,
    const ADDR_COMPUTE_SLICESWIZZLE_INPUT*      pIn,
    ADDR_COMPUTE_SLICESWIZZLE_OUTPUT*           pOut)
{
    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeSliceTileSwizzle(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrComputeBaseSwizzle
*
*   @@brief
*       Return a Combined Bank and Pipe swizzle base on surface based on surface type/index
*   @@return
*       ADDR_OK if no error
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputeBaseSwizzle(
    ADDR_HANDLE                             hLib,
    const ADDR_COMPUTE_BASE_SWIZZLE_INPUT*  pIn,
    ADDR_COMPUTE_BASE_SWIZZLE_OUTPUT*       pOut)
{
    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeBaseSwizzle(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   ElemFlt32ToDepthPixel
*
*   @@brief
*       Convert a FLT_32 value to a depth/stencil pixel value
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
*
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API ElemFlt32ToDepthPixel(
    ADDR_HANDLE                         hLib,    ///< [in] addrlib handle
    const ELEM_FLT32TODEPTHPIXEL_INPUT* pIn,     ///< [in] per-component value
    ELEM_FLT32TODEPTHPIXEL_OUTPUT*      pOut)    ///< [out] final pixel value
{
    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    if (pLib != NULL)
    {
        pLib->Flt32ToDepthPixel(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   ElemFlt32ToColorPixel
*
*   @@brief
*       Convert a FLT_32 value to a red/green/blue/alpha pixel value
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
*
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API ElemFlt32ToColorPixel(
    ADDR_HANDLE                         hLib,    ///< [in] addrlib handle
    const ELEM_FLT32TOCOLORPIXEL_INPUT* pIn,     ///< [in] format, surface number and swap value
    ELEM_FLT32TOCOLORPIXEL_OUTPUT*      pOut)    ///< [out] final pixel value
{
    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    if (pLib != NULL)
    {
        pLib->Flt32ToColorPixel(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   ElemGetExportNorm
*
*   @@brief
*       Helper function to check one format can be EXPORT_NUM,
*       which is a register CB_COLOR_INFO.SURFACE_FORMAT.
*       FP16 can be reported as EXPORT_NORM for rv770 in r600
*       family
*
***************************************************************************************************
*/
BOOL_32 ADDR_API ElemGetExportNorm(
    ADDR_HANDLE                     hLib, ///< [in] addrlib handle
    const ELEM_GETEXPORTNORM_INPUT* pIn)  ///< [in] input structure
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);
    BOOL_32 enabled = FALSE;

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        enabled = pLib->GetExportNorm(pIn);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    ADDR_ASSERT(returnCode == ADDR_OK);

    return enabled;
}

/**
***************************************************************************************************
*   AddrConvertTileInfoToHW
*
*   @@brief
*       Convert tile info from real value to hardware register value
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrConvertTileInfoToHW(
    ADDR_HANDLE                             hLib, ///< [in] address lib handle
    const ADDR_CONVERT_TILEINFOTOHW_INPUT*  pIn,  ///< [in] tile info with real value
    ADDR_CONVERT_TILEINFOTOHW_OUTPUT*       pOut) ///< [out] tile info with HW register value
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ConvertTileInfoToHW(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrConvertTileIndex
*
*   @@brief
*       Convert tile index to tile mode/type/info
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrConvertTileIndex(
    ADDR_HANDLE                          hLib, ///< [in] address lib handle
    const ADDR_CONVERT_TILEINDEX_INPUT*  pIn,  ///< [in] input - tile index
    ADDR_CONVERT_TILEINDEX_OUTPUT*       pOut) ///< [out] tile mode/type/info
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ConvertTileIndex(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrConvertTileIndex1
*
*   @@brief
*       Convert tile index to tile mode/type/info
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrConvertTileIndex1(
    ADDR_HANDLE                          hLib, ///< [in] address lib handle
    const ADDR_CONVERT_TILEINDEX1_INPUT* pIn,  ///< [in] input - tile index
    ADDR_CONVERT_TILEINDEX_OUTPUT*       pOut) ///< [out] tile mode/type/info
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ConvertTileIndex1(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrGetTileIndex
*
*   @@brief
*       Get tile index from tile mode/type/info
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
*
*   @@note
*       Only meaningful for SI (and above)
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrGetTileIndex(
    ADDR_HANDLE                     hLib,
    const ADDR_GET_TILEINDEX_INPUT* pIn,
    ADDR_GET_TILEINDEX_OUTPUT*      pOut)
{
    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->GetTileIndex(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
***************************************************************************************************
*   AddrComputePrtInfo
*
*   @@brief
*       Interface function for ComputePrtInfo
*
***************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrComputePrtInfo(
    ADDR_HANDLE                 hLib,
    const ADDR_PRT_INFO_INPUT*  pIn,
    ADDR_PRT_INFO_OUTPUT*       pOut)
{
    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    AddrLib* pLib = AddrLib::GetAddrLib(hLib);

    if (pLib != NULL)
    {
        returnCode = pLib->ComputePrtInfo(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

@


1.1.1.1
log
@Import Mesa 13.0.2
@
text
@@


1.1.1.2
log
@Import Mesa 17.1.6
@
text
@d28 1
a28 1
****************************************************************************************************
d31 1
a31 1
****************************************************************************************************
d34 1
a34 2
#include "addrlib1.h"
#include "addrlib2.h"
d38 1
a38 3
using namespace Addr;

////////////////////////////////////////////////////////////////////////////////////////////////////
d40 1
a40 1
////////////////////////////////////////////////////////////////////////////////////////////////////
d43 1
a43 1
****************************************************************************************************
d51 1
a51 1
****************************************************************************************************
d59 1
a59 1
    returnCode = Lib::Create(pAddrCreateIn, pAddrCreateOut);
d67 1
a67 1
****************************************************************************************************
d75 1
a75 1
****************************************************************************************************
d78 1
a78 1
    ADDR_HANDLE hLib) ///< address lib handle
d84 1
a84 1
        Lib* pLib = Lib::GetLib(hLib);
d97 1
a97 1
////////////////////////////////////////////////////////////////////////////////////////////////////
d99 1
a99 1
////////////////////////////////////////////////////////////////////////////////////////////////////
d102 1
a102 1
****************************************************************************************************
d110 1
a110 1
****************************************************************************************************
d113 1
a113 1
    ADDR_HANDLE                             hLib, ///< address lib handle
d117 1
a117 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d136 1
a136 1
****************************************************************************************************
d144 1
a144 1
****************************************************************************************************
d147 1
a147 1
    ADDR_HANDLE                                     hLib, ///< address lib handle
d151 1
a151 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d168 1
a168 1
****************************************************************************************************
d176 1
a176 1
****************************************************************************************************
d179 1
a179 1
    ADDR_HANDLE                                     hLib, ///< address lib handle
d183 1
a183 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d201 1
a201 1
////////////////////////////////////////////////////////////////////////////////////////////////////
d203 1
a203 1
////////////////////////////////////////////////////////////////////////////////////////////////////
d206 1
a206 1
****************************************************************************************************
d214 1
a214 1
****************************************************************************************************
d217 1
a217 1
    ADDR_HANDLE                             hLib, ///< address lib handle
d221 1
a221 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d238 1
a238 1
****************************************************************************************************
d246 1
a246 1
****************************************************************************************************
d249 1
a249 1
    ADDR_HANDLE                                     hLib, ///< address lib handle
d253 1
a253 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d270 1
a270 1
****************************************************************************************************
d279 1
a279 1
****************************************************************************************************
d282 1
a282 1
    ADDR_HANDLE                                     hLib, ///< address lib handle
d286 1
a286 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d304 1
a304 1
////////////////////////////////////////////////////////////////////////////////////////////////////
d306 1
a306 1
////////////////////////////////////////////////////////////////////////////////////////////////////
d309 1
a309 1
****************************************************************************************************
d318 1
a318 1
****************************************************************************************************
d321 1
a321 1
    ADDR_HANDLE                             hLib, ///< address lib handle
d325 1
a325 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d342 1
a342 1
****************************************************************************************************
d350 1
a350 1
****************************************************************************************************
d353 1
a353 1
    ADDR_HANDLE                                     hLib, ///< address lib handle
d357 1
a357 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d374 1
a374 1
****************************************************************************************************
d383 1
a383 1
****************************************************************************************************
d386 1
a386 1
    ADDR_HANDLE                                     hLib, ///< address lib handle
d390 1
a390 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d408 1
a408 1
////////////////////////////////////////////////////////////////////////////////////////////////////
d410 1
a410 1
////////////////////////////////////////////////////////////////////////////////////////////////////
d413 1
a413 1
****************************************************************************************************
d421 1
a421 1
****************************************************************************************************
d424 1
a424 1
    ADDR_HANDLE                             hLib, ///< address lib handle
d428 1
a428 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d445 1
a445 1
****************************************************************************************************
d453 1
a453 1
****************************************************************************************************
d456 1
a456 1
    ADDR_HANDLE                                     hLib, ///< address lib handle
d460 1
a460 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d477 1
a477 1
****************************************************************************************************
d485 1
a485 1
****************************************************************************************************
d488 1
a488 1
    ADDR_HANDLE                                     hLib, ///< address lib handle
d492 1
a492 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d510 1
a510 1
////////////////////////////////////////////////////////////////////////////////////////////////////
d512 1
a512 1
////////////////////////////////////////////////////////////////////////////////////////////////////
d515 1
a515 1
****************************************************************************************************
d521 1
a521 1
****************************************************************************************************
d524 1
a524 1
    ADDR_HANDLE                             hLib,   ///< handle of addrlib
d530 1
a530 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d551 1
a551 1
****************************************************************************************************
d557 1
a557 1
****************************************************************************************************
d563 1
a563 1
    Addr::Lib* pLib = Lib::GetLib(hLib);
d576 1
a576 1
****************************************************************************************************
d581 1
a581 1
****************************************************************************************************
d587 1
a587 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d600 1
a600 1
****************************************************************************************************
d605 1
a605 1
****************************************************************************************************
d611 1
a611 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d624 1
a624 1
****************************************************************************************************
d631 1
a631 1
****************************************************************************************************
d634 1
a634 1
    ADDR_HANDLE                                 hLib,     ///< addrlib handle
d640 1
a640 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d655 1
a655 1
****************************************************************************************************
d662 1
a662 1
****************************************************************************************************
d671 1
a671 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d686 1
a686 1
****************************************************************************************************
d693 1
a693 1
****************************************************************************************************
d702 1
a702 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d717 1
a717 1
****************************************************************************************************
d724 1
a724 1
****************************************************************************************************
d733 1
a733 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d748 1
a748 1
****************************************************************************************************
d757 1
a757 1
****************************************************************************************************
d760 1
a760 1
    ADDR_HANDLE                         hLib,    ///< addrlib handle
d766 1
a766 1
    Lib* pLib = Lib::GetLib(hLib);
d781 1
a781 1
****************************************************************************************************
d790 1
a790 1
****************************************************************************************************
d793 1
a793 1
    ADDR_HANDLE                         hLib,    ///< addrlib handle
d799 1
a799 1
    Lib* pLib = Lib::GetLib(hLib);
d814 1
a814 1
****************************************************************************************************
d823 1
a823 1
****************************************************************************************************
d826 1
a826 1
    ADDR_HANDLE                     hLib, ///< addrlib handle
d829 1
a829 1
    Addr::Lib* pLib = Lib::GetLib(hLib);
d849 1
a849 1
****************************************************************************************************
d857 1
a857 1
****************************************************************************************************
d860 1
a860 1
    ADDR_HANDLE                             hLib, ///< address lib handle
d864 1
a864 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d881 1
a881 1
****************************************************************************************************
d889 1
a889 1
****************************************************************************************************
d892 1
a892 1
    ADDR_HANDLE                          hLib, ///< address lib handle
d896 1
a896 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d913 1
a913 33
****************************************************************************************************
*   AddrGetMacroModeIndex
*
*   @@brief
*       Get macro mode index based on input parameters
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrGetMacroModeIndex(
    ADDR_HANDLE                          hLib, ///< address lib handle
    const ADDR_GET_MACROMODEINDEX_INPUT* pIn,  ///< [in] input
    ADDR_GET_MACROMODEINDEX_OUTPUT*      pOut) ///< [out] macro mode index
{
    V1::Lib* pLib = V1::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode;

    if (pLib != NULL)
    {
        returnCode = pLib->GetMacroModeIndex(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
****************************************************************************************************
d921 1
a921 1
****************************************************************************************************
d924 1
a924 1
    ADDR_HANDLE                          hLib, ///< address lib handle
d928 1
a928 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d945 1
a945 1
****************************************************************************************************
d956 1
a956 1
****************************************************************************************************
d963 1
a963 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
d980 1
a980 1
****************************************************************************************************
d986 1
a986 1
****************************************************************************************************
d995 1
a995 1
    V1::Lib* pLib = V1::Lib::GetLib(hLib);
a999 634
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
****************************************************************************************************
*   AddrGetMaxAlignments
*
*   @@brief
*       Convert maximum alignments
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API AddrGetMaxAlignments(
    ADDR_HANDLE                     hLib, ///< address lib handle
    ADDR_GET_MAX_ALINGMENTS_OUTPUT* pOut) ///< [out] output structure
{
    Addr::Lib* pLib = Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->GetMaxAlignments(pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
//                                    Surface functions for Addr2
////////////////////////////////////////////////////////////////////////////////////////////////////

/**
****************************************************************************************************
*   Addr2ComputeSurfaceInfo
*
*   @@brief
*       Calculate surface width/height/depth/alignments and suitable tiling mode
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeSurfaceInfo(
    ADDR_HANDLE                                hLib, ///< address lib handle
    const ADDR2_COMPUTE_SURFACE_INFO_INPUT*    pIn,  ///< [in] surface information
    ADDR2_COMPUTE_SURFACE_INFO_OUTPUT*         pOut) ///< [out] surface parameters and alignments
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeSurfaceInfo(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}


/**
****************************************************************************************************
*   Addr2ComputeSurfaceAddrFromCoord
*
*   @@brief
*       Compute surface address according to coordinates
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeSurfaceAddrFromCoord(
    ADDR_HANDLE                                         hLib, ///< address lib handle
    const ADDR2_COMPUTE_SURFACE_ADDRFROMCOORD_INPUT*    pIn,  ///< [in] surface info and coordinates
    ADDR2_COMPUTE_SURFACE_ADDRFROMCOORD_OUTPUT*         pOut) ///< [out] surface address
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeSurfaceAddrFromCoord(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}


/**
****************************************************************************************************
*   Addr2ComputeSurfaceCoordFromAddr
*
*   @@brief
*       Compute coordinates according to surface address
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeSurfaceCoordFromAddr(
    ADDR_HANDLE                                         hLib, ///< address lib handle
    const ADDR2_COMPUTE_SURFACE_COORDFROMADDR_INPUT*    pIn,  ///< [in] surface info and address
    ADDR2_COMPUTE_SURFACE_COORDFROMADDR_OUTPUT*         pOut) ///< [out] coordinates
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeSurfaceCoordFromAddr(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
//                                   HTile functions for Addr2
////////////////////////////////////////////////////////////////////////////////////////////////////

/**
****************************************************************************************************
*   Addr2ComputeHtileInfo
*
*   @@brief
*       Compute Htile pitch, height, base alignment and size in bytes
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeHtileInfo(
    ADDR_HANDLE                              hLib, ///< address lib handle
    const ADDR2_COMPUTE_HTILE_INFO_INPUT*    pIn,  ///< [in] Htile information
    ADDR2_COMPUTE_HTILE_INFO_OUTPUT*         pOut) ///< [out] Htile pitch, height and size in bytes
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeHtileInfo(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}


/**
****************************************************************************************************
*   Addr2ComputeHtileAddrFromCoord
*
*   @@brief
*       Compute Htile address according to coordinates (of depth buffer)
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeHtileAddrFromCoord(
    ADDR_HANDLE                                       hLib, ///< address lib handle
    const ADDR2_COMPUTE_HTILE_ADDRFROMCOORD_INPUT*    pIn,  ///< [in] Htile info and coordinates
    ADDR2_COMPUTE_HTILE_ADDRFROMCOORD_OUTPUT*         pOut) ///< [out] Htile address
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeHtileAddrFromCoord(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}


/**
****************************************************************************************************
*   Addr2ComputeHtileCoordFromAddr
*
*   @@brief
*       Compute coordinates within depth buffer (1st pixel of a micro tile) according to
*       Htile address
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeHtileCoordFromAddr(
    ADDR_HANDLE                                       hLib, ///< address lib handle
    const ADDR2_COMPUTE_HTILE_COORDFROMADDR_INPUT*    pIn,  ///< [in] Htile info and address
    ADDR2_COMPUTE_HTILE_COORDFROMADDR_OUTPUT*         pOut) ///< [out] Htile coordinates
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeHtileCoordFromAddr(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
//                                     C-mask functions for Addr2
////////////////////////////////////////////////////////////////////////////////////////////////////

/**
****************************************************************************************************
*   Addr2ComputeCmaskInfo
*
*   @@brief
*       Compute Cmask pitch, height, base alignment and size in bytes from color buffer
*       info
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeCmaskInfo(
    ADDR_HANDLE                              hLib, ///< address lib handle
    const ADDR2_COMPUTE_CMASK_INFO_INPUT*    pIn,  ///< [in] Cmask pitch and height
    ADDR2_COMPUTE_CMASK_INFO_OUTPUT*         pOut) ///< [out] Cmask pitch, height and size in bytes
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeCmaskInfo(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}


/**
****************************************************************************************************
*   Addr2ComputeCmaskAddrFromCoord
*
*   @@brief
*       Compute Cmask address according to coordinates (of MSAA color buffer)
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeCmaskAddrFromCoord(
    ADDR_HANDLE                                       hLib, ///< address lib handle
    const ADDR2_COMPUTE_CMASK_ADDRFROMCOORD_INPUT*    pIn,  ///< [in] Cmask info and coordinates
    ADDR2_COMPUTE_CMASK_ADDRFROMCOORD_OUTPUT*         pOut) ///< [out] Cmask address
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeCmaskAddrFromCoord(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}


/**
****************************************************************************************************
*   Addr2ComputeCmaskCoordFromAddr
*
*   @@brief
*       Compute coordinates within color buffer (1st pixel of a micro tile) according to
*       Cmask address
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeCmaskCoordFromAddr(
    ADDR_HANDLE                                       hLib, ///< address lib handle
    const ADDR2_COMPUTE_CMASK_COORDFROMADDR_INPUT*    pIn,  ///< [in] Cmask info and address
    ADDR2_COMPUTE_CMASK_COORDFROMADDR_OUTPUT*         pOut) ///< [out] Cmask coordinates
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeCmaskCoordFromAddr(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
//                                     F-mask functions for Addr2
////////////////////////////////////////////////////////////////////////////////////////////////////

/**
****************************************************************************************************
*   Addr2ComputeFmaskInfo
*
*   @@brief
*       Compute Fmask pitch/height/depth/alignments and size in bytes
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeFmaskInfo(
    ADDR_HANDLE                              hLib, ///< address lib handle
    const ADDR2_COMPUTE_FMASK_INFO_INPUT*    pIn,  ///< [in] Fmask information
    ADDR2_COMPUTE_FMASK_INFO_OUTPUT*         pOut) ///< [out] Fmask pitch and height
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeFmaskInfo(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}


/**
****************************************************************************************************
*   Addr2ComputeFmaskAddrFromCoord
*
*   @@brief
*       Compute Fmask address according to coordinates (x,y,slice,sample,plane)
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeFmaskAddrFromCoord(
    ADDR_HANDLE                                       hLib, ///< address lib handle
    const ADDR2_COMPUTE_FMASK_ADDRFROMCOORD_INPUT*    pIn,  ///< [in] Fmask info and coordinates
    ADDR2_COMPUTE_FMASK_ADDRFROMCOORD_OUTPUT*         pOut) ///< [out] Fmask address
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeFmaskAddrFromCoord(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}


/**
****************************************************************************************************
*   Addr2ComputeFmaskCoordFromAddr
*
*   @@brief
*       Compute coordinates (x,y,slice,sample,plane) according to Fmask address
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeFmaskCoordFromAddr(
    ADDR_HANDLE                                       hLib, ///< address lib handle
    const ADDR2_COMPUTE_FMASK_COORDFROMADDR_INPUT*    pIn,  ///< [in] Fmask info and address
    ADDR2_COMPUTE_FMASK_COORDFROMADDR_OUTPUT*         pOut) ///< [out] Fmask coordinates
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeFmaskCoordFromAddr(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
//                                     DCC key functions for Addr2
////////////////////////////////////////////////////////////////////////////////////////////////////

/**
****************************************************************************************************
*   Addr2ComputeDccInfo
*
*   @@brief
*       Compute DCC key size, base alignment based on color surface size, tile info or tile index
*
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeDccInfo(
    ADDR_HANDLE                           hLib,   ///< handle of addrlib
    const ADDR2_COMPUTE_DCCINFO_INPUT*    pIn,    ///< [in] input
    ADDR2_COMPUTE_DCCINFO_OUTPUT*         pOut)   ///< [out] output
{
    ADDR_E_RETURNCODE returnCode;

    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeDccInfo(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
****************************************************************************************************
*   Addr2ComputeDccAddrFromCoord
*
*   @@brief
*       Compute DCC key address according to coordinates
*
*   @@return
*       ADDR_OK if successful, otherwise an error code of ADDR_E_RETURNCODE
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeDccAddrFromCoord(
    ADDR_HANDLE                                     hLib, ///< address lib handle
    const ADDR2_COMPUTE_DCC_ADDRFROMCOORD_INPUT*    pIn,  ///< [in] Dcc info and coordinates
    ADDR2_COMPUTE_DCC_ADDRFROMCOORD_OUTPUT*         pOut) ///< [out] Dcc address
{
    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    ADDR_E_RETURNCODE returnCode = ADDR_OK;

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeDccAddrFromCoord(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
****************************************************************************************************
*   Addr2ComputePipeBankXor
*
*   @@brief
*       Calculate a valid bank pipe xor value for client to use.
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputePipeBankXor(
    ADDR_HANDLE                            hLib, ///< handle of addrlib
    const ADDR2_COMPUTE_PIPEBANKXOR_INPUT* pIn,  ///< [in] input
    ADDR2_COMPUTE_PIPEBANKXOR_OUTPUT*      pOut) ///< [out] output
{
    ADDR_E_RETURNCODE returnCode;

    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    if (pLib != NULL)
    {
        returnCode = pLib->ComputePipeBankXor(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
****************************************************************************************************
*   Addr2ComputeSlicePipeBankXor
*
*   @@brief
*       Calculate slice pipe bank xor value based on base pipe bank xor and slice id.
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeSlicePipeBankXor(
    ADDR_HANDLE                                  hLib, ///< handle of addrlib
    const ADDR2_COMPUTE_SLICE_PIPEBANKXOR_INPUT* pIn,  ///< [in] input
    ADDR2_COMPUTE_SLICE_PIPEBANKXOR_OUTPUT*      pOut) ///< [out] output
{
    ADDR_E_RETURNCODE returnCode;

    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeSlicePipeBankXor(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
****************************************************************************************************
*   Addr2ComputeSubResourceOffsetForSwizzlePattern
*
*   @@brief
*       Calculate sub resource offset for swizzle pattern.
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2ComputeSubResourceOffsetForSwizzlePattern(
    ADDR_HANDLE                                                     hLib, ///< handle of addrlib
    const ADDR2_COMPUTE_SUBRESOURCE_OFFSET_FORSWIZZLEPATTERN_INPUT* pIn,  ///< [in] input
    ADDR2_COMPUTE_SUBRESOURCE_OFFSET_FORSWIZZLEPATTERN_OUTPUT*      pOut) ///< [out] output
{
    ADDR_E_RETURNCODE returnCode;

    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    if (pLib != NULL)
    {
        returnCode = pLib->ComputeSubResourceOffsetForSwizzlePattern(pIn, pOut);
    }
    else
    {
        returnCode = ADDR_ERROR;
    }

    return returnCode;
}

/**
****************************************************************************************************
*   Addr2GetPreferredSurfaceSetting
*
*   @@brief
*       Suggest a preferred setting for client driver to program HW register
****************************************************************************************************
*/
ADDR_E_RETURNCODE ADDR_API Addr2GetPreferredSurfaceSetting(
    ADDR_HANDLE                                   hLib, ///< handle of addrlib
    const ADDR2_GET_PREFERRED_SURF_SETTING_INPUT* pIn,  ///< [in] input
    ADDR2_GET_PREFERRED_SURF_SETTING_OUTPUT*      pOut) ///< [out] output
{
    ADDR_E_RETURNCODE returnCode;

    V2::Lib* pLib = V2::Lib::GetLib(hLib);

    if (pLib != NULL)
    {
        returnCode = pLib->Addr2GetPreferredSurfaceSetting(pIn, pOut);
@

