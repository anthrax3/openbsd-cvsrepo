head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	mesa-17_1_6:1.1.1.5
	OPENBSD_6_1:1.1.1.4.0.2
	OPENBSD_6_1_BASE:1.1.1.4
	mesa-13_0_6:1.1.1.4
	mesa-13_0_5:1.1.1.4
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.39;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.39.21;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.39.21;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.14.36;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.39.04;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.02.26.12.19.33;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	xZcdklZavddTKAf1;

1.1.1.5
date	2017.08.14.09.44.44;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2004-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009-2010  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file shaderobj.c
 * \author Brian Paul
 *
 */


#include "main/glheader.h"
#include "main/context.h"
#include "main/hash.h"
#include "main/mtypes.h"
#include "main/shaderapi.h"
#include "main/shaderobj.h"
#include "main/uniforms.h"
#include "program/program.h"
#include "program/prog_parameter.h"
#include "util/u_atomic.h"
#include "util/ralloc.h"
#include "util/string_to_uint_map.h"

/**********************************************************************/
/*** Shader object functions                                        ***/
/**********************************************************************/


/**
 * Set ptr to point to sh.
 * If ptr is pointing to another shader, decrement its refcount (and delete
 * if refcount hits zero).
 * Then set ptr to point to sh, incrementing its refcount.
 */
void
_mesa_reference_shader(struct gl_context *ctx, struct gl_shader **ptr,
                       struct gl_shader *sh)
{
   assert(ptr);
   if (*ptr == sh) {
      /* no-op */
      return;
   }
   if (*ptr) {
      /* Unreference the old shader */
      struct gl_shader *old = *ptr;

      assert(old->RefCount > 0);

      if (p_atomic_dec_zero(&old->RefCount)) {
	 if (old->Name != 0)
	    _mesa_HashRemove(ctx->Shared->ShaderObjects, old->Name);
         _mesa_delete_shader(ctx, old);
      }

      *ptr = NULL;
   }
   assert(!*ptr);

   if (sh) {
      /* reference new */
      p_atomic_inc(&sh->RefCount);
      *ptr = sh;
   }
}

static void
_mesa_init_shader(struct gl_shader *shader)
{
   shader->RefCount = 1;
   shader->info.Geom.VerticesOut = -1;
   shader->info.Geom.InputType = GL_TRIANGLES;
   shader->info.Geom.OutputType = GL_TRIANGLE_STRIP;
}

/**
 * Allocate a new gl_shader object, initialize it.
 */
struct gl_shader *
_mesa_new_shader(GLuint name, gl_shader_stage stage)
{
   struct gl_shader *shader;
   shader = rzalloc(NULL, struct gl_shader);
   if (shader) {
      shader->Stage = stage;
      shader->Name = name;
      _mesa_init_shader(shader);
   }
   return shader;
}


/**
 * Allocate a new gl_linked_shader object.
 * Called via ctx->Driver.NewShader()
 */
struct gl_linked_shader *
_mesa_new_linked_shader(gl_shader_stage stage)
{
   struct gl_linked_shader *shader;
   shader = rzalloc(NULL, struct gl_linked_shader);
   if (shader) {
      shader->Stage = stage;
   }
   return shader;
}


/**
 * Delete a shader object.
 */
void
_mesa_delete_shader(struct gl_context *ctx, struct gl_shader *sh)
{
   free((void *)sh->Source);
   free(sh->Label);
   ralloc_free(sh);
}


/**
 * Delete a shader object.
 */
void
_mesa_delete_linked_shader(struct gl_context *ctx,
                           struct gl_linked_shader *sh)
{
   _mesa_reference_program(ctx, &sh->Program, NULL);
   ralloc_free(sh);
}


/**
 * Lookup a GLSL shader object.
 */
struct gl_shader *
_mesa_lookup_shader(struct gl_context *ctx, GLuint name)
{
   if (name) {
      struct gl_shader *sh = (struct gl_shader *)
         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
      /* Note that both gl_shader and gl_shader_program objects are kept
       * in the same hash table.  Check the object's type to be sure it's
       * what we're expecting.
       */
      if (sh && sh->Type == GL_SHADER_PROGRAM_MESA) {
         return NULL;
      }
      return sh;
   }
   return NULL;
}


/**
 * As above, but record an error if shader is not found.
 */
struct gl_shader *
_mesa_lookup_shader_err(struct gl_context *ctx, GLuint name, const char *caller)
{
   if (!name) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s", caller);
      return NULL;
   }
   else {
      struct gl_shader *sh = (struct gl_shader *)
         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
      if (!sh) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s", caller);
         return NULL;
      }
      if (sh->Type == GL_SHADER_PROGRAM_MESA) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s", caller);
         return NULL;
      }
      return sh;
   }
}



/**********************************************************************/
/*** Shader Program object functions                                ***/
/**********************************************************************/


/**
 * Set ptr to point to shProg.
 * If ptr is pointing to another object, decrement its refcount (and delete
 * if refcount hits zero).
 * Then set ptr to point to shProg, incrementing its refcount.
 */
void
_mesa_reference_shader_program_(struct gl_context *ctx,
                                struct gl_shader_program **ptr,
                                struct gl_shader_program *shProg)
{
   assert(ptr);
   if (*ptr == shProg) {
      /* no-op */
      return;
   }
   if (*ptr) {
      /* Unreference the old shader program */
      struct gl_shader_program *old = *ptr;

      assert(old->RefCount > 0);

      if (p_atomic_dec_zero(&old->RefCount)) {
	 if (old->Name != 0)
	    _mesa_HashRemove(ctx->Shared->ShaderObjects, old->Name);
         _mesa_delete_shader_program(ctx, old);
      }

      *ptr = NULL;
   }
   assert(!*ptr);

   if (shProg) {
      p_atomic_inc(&shProg->RefCount);
      *ptr = shProg;
   }
}

static void
init_shader_program(struct gl_shader_program *prog)
{
   prog->Type = GL_SHADER_PROGRAM_MESA;
   prog->RefCount = 1;

   prog->AttributeBindings = string_to_uint_map_ctor();
   prog->FragDataBindings = string_to_uint_map_ctor();
   prog->FragDataIndexBindings = string_to_uint_map_ctor();

   prog->Geom.UsesEndPrimitive = false;
   prog->Geom.UsesStreams = false;

   prog->Comp.LocalSizeVariable = false;

   prog->TransformFeedback.BufferMode = GL_INTERLEAVED_ATTRIBS;

   exec_list_make_empty(&prog->EmptyUniformLocations);

   prog->InfoLog = ralloc_strdup(prog, "");
}

/**
 * Allocate a new gl_shader_program object, initialize it.
 */
struct gl_shader_program *
_mesa_new_shader_program(GLuint name)
{
   struct gl_shader_program *shProg;
   shProg = rzalloc(NULL, struct gl_shader_program);
   if (shProg) {
      shProg->Name = name;
      init_shader_program(shProg);
   }
   return shProg;
}


/**
 * Clear (free) the shader program state that gets produced by linking.
 */
void
_mesa_clear_shader_program_data(struct gl_context *ctx,
                                struct gl_shader_program *shProg)
{
   for (gl_shader_stage sh = 0; sh < MESA_SHADER_STAGES; sh++) {
      if (shProg->_LinkedShaders[sh] != NULL) {
         _mesa_delete_linked_shader(ctx, shProg->_LinkedShaders[sh]);
         shProg->_LinkedShaders[sh] = NULL;
      }
   }

   if (shProg->UniformStorage) {
      for (unsigned i = 0; i < shProg->NumUniformStorage; ++i)
         _mesa_uniform_detach_all_driver_storage(&shProg->UniformStorage[i]);
      ralloc_free(shProg->UniformStorage);
      shProg->NumUniformStorage = 0;
      shProg->UniformStorage = NULL;
   }

   if (shProg->UniformRemapTable) {
      ralloc_free(shProg->UniformRemapTable);
      shProg->NumUniformRemapTable = 0;
      shProg->UniformRemapTable = NULL;
   }

   if (shProg->UniformHash) {
      string_to_uint_map_dtor(shProg->UniformHash);
      shProg->UniformHash = NULL;
   }

   assert(shProg->InfoLog != NULL);
   ralloc_free(shProg->InfoLog);
   shProg->InfoLog = ralloc_strdup(shProg, "");

   ralloc_free(shProg->UniformBlocks);
   shProg->UniformBlocks = NULL;
   shProg->NumUniformBlocks = 0;

   ralloc_free(shProg->ShaderStorageBlocks);
   shProg->ShaderStorageBlocks = NULL;
   shProg->NumShaderStorageBlocks = 0;

   ralloc_free(shProg->AtomicBuffers);
   shProg->AtomicBuffers = NULL;
   shProg->NumAtomicBuffers = 0;

   if (shProg->ProgramResourceList) {
      ralloc_free(shProg->ProgramResourceList);
      shProg->ProgramResourceList = NULL;
      shProg->NumProgramResourceList = 0;
   }
}


/**
 * Free all the data that hangs off a shader program object, but not the
 * object itself.
 */
void
_mesa_free_shader_program_data(struct gl_context *ctx,
                               struct gl_shader_program *shProg)
{
   GLuint i;

   assert(shProg->Type == GL_SHADER_PROGRAM_MESA);

   _mesa_clear_shader_program_data(ctx, shProg);

   if (shProg->AttributeBindings) {
      string_to_uint_map_dtor(shProg->AttributeBindings);
      shProg->AttributeBindings = NULL;
   }

   if (shProg->FragDataBindings) {
      string_to_uint_map_dtor(shProg->FragDataBindings);
      shProg->FragDataBindings = NULL;
   }

   if (shProg->FragDataIndexBindings) {
      string_to_uint_map_dtor(shProg->FragDataIndexBindings);
      shProg->FragDataIndexBindings = NULL;
   }

   /* detach shaders */
   for (i = 0; i < shProg->NumShaders; i++) {
      _mesa_reference_shader(ctx, &shProg->Shaders[i], NULL);
   }
   shProg->NumShaders = 0;

   free(shProg->Shaders);
   shProg->Shaders = NULL;

   /* Transform feedback varying vars */
   for (i = 0; i < shProg->TransformFeedback.NumVarying; i++) {
      free(shProg->TransformFeedback.VaryingNames[i]);
   }
   free(shProg->TransformFeedback.VaryingNames);
   shProg->TransformFeedback.VaryingNames = NULL;
   shProg->TransformFeedback.NumVarying = 0;

   free(shProg->Label);
   shProg->Label = NULL;
}


/**
 * Free/delete a shader program object.
 */
void
_mesa_delete_shader_program(struct gl_context *ctx,
                            struct gl_shader_program *shProg)
{
   _mesa_free_shader_program_data(ctx, shProg);

   ralloc_free(shProg);
}


/**
 * Lookup a GLSL program object.
 */
struct gl_shader_program *
_mesa_lookup_shader_program(struct gl_context *ctx, GLuint name)
{
   struct gl_shader_program *shProg;
   if (name) {
      shProg = (struct gl_shader_program *)
         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
      /* Note that both gl_shader and gl_shader_program objects are kept
       * in the same hash table.  Check the object's type to be sure it's
       * what we're expecting.
       */
      if (shProg && shProg->Type != GL_SHADER_PROGRAM_MESA) {
         return NULL;
      }
      return shProg;
   }
   return NULL;
}


/**
 * As above, but record an error if program is not found.
 */
struct gl_shader_program *
_mesa_lookup_shader_program_err(struct gl_context *ctx, GLuint name,
                                const char *caller)
{
   if (!name) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s", caller);
      return NULL;
   }
   else {
      struct gl_shader_program *shProg = (struct gl_shader_program *)
         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
      if (!shProg) {
         _mesa_error(ctx, GL_INVALID_VALUE, "%s", caller);
         return NULL;
      }
      if (shProg->Type != GL_SHADER_PROGRAM_MESA) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "%s", caller);
         return NULL;
      }
      return shProg;
   }
}


void
_mesa_init_shader_object_functions(struct dd_function_table *driver)
{
   driver->NewShader = _mesa_new_linked_shader;
   driver->LinkShader = _mesa_ir_link_shader;
}
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
#include "program/hash_table.h"
d44 1
a67 1
      GLboolean deleteFlag = GL_FALSE;
a70 4
      old->RefCount--;
      /*printf("SHADER DECR %p (%d) to %d\n",
        (void*) old, old->Name, old->RefCount);*/
      deleteFlag = (old->RefCount == 0);
d72 1
a72 1
      if (deleteFlag) {
d75 1
a75 1
         ctx->Driver.DeleteShader(ctx, old);
d84 1
a84 3
      sh->RefCount++;
      /*printf("SHADER INCR %p (%d) to %d\n",
        (void*) sh, sh->Name, sh->RefCount);*/
d89 2
a90 2
void
_mesa_init_shader(struct gl_context *ctx, struct gl_shader *shader)
d93 3
a99 1
 * Called via ctx->Driver.NewShader()
d102 1
a102 1
_mesa_new_shader(struct gl_context *ctx, GLuint name, GLenum type)
a104 1
   assert(_mesa_validate_shader_target(ctx, type));
d107 1
a107 2
      shader->Type = type;
      shader->Stage = _mesa_shader_enum_to_shader_stage(type);
d109 17
a125 1
      _mesa_init_shader(ctx, shader);
a132 1
 * Called via ctx->Driver.DeleteShader().
d134 1
a134 1
static void
d139 11
a226 1
      GLboolean deleteFlag = GL_FALSE;
a229 6
      old->RefCount--;
#if 0
      printf("ShaderProgram %p ID=%u  RefCount-- to %d\n",
             (void *) old, old->Name, old->RefCount);
#endif
      deleteFlag = (old->RefCount == 0);
d231 1
a231 1
      if (deleteFlag) {
d234 1
a234 1
         ctx->Driver.DeleteShaderProgram(ctx, old);
d242 1
a242 5
      shProg->RefCount++;
#if 0
      printf("ShaderProgram %p ID=%u  RefCount++ to %d\n",
             (void *) shProg, shProg->Name, shProg->RefCount);
#endif
a256 3
   prog->Geom.VerticesOut = 0;
   prog->Geom.InputType = GL_TRIANGLES;
   prog->Geom.OutputType = GL_TRIANGLE_STRIP;
d260 2
d264 2
a270 1
 * Called via ctx->Driver.NewShaderProgram()
d272 1
a272 1
static struct gl_shader_program *
d289 2
a290 1
_mesa_clear_shader_program_data(struct gl_shader_program *shProg)
d292 6
a297 1
   unsigned i;
d300 1
a300 1
      for (i = 0; i < shProg->NumUniformStorage; ++i)
d325 4
a328 4
   for (i = 0; i < MESA_SHADER_STAGES; i++) {
      ralloc_free(shProg->UniformBlockStageIndex[i]);
      shProg->UniformBlockStageIndex[i] = NULL;
   }
a350 1
   gl_shader_stage sh;
d354 1
a354 1
   _mesa_clear_shader_program_data(shProg);
a387 8

   for (sh = 0; sh < MESA_SHADER_STAGES; sh++) {
      if (shProg->_LinkedShaders[sh] != NULL) {
	 ctx->Driver.DeleteShader(ctx, shProg->_LinkedShaders[sh]);
	 shProg->_LinkedShaders[sh] = NULL;
      }
   }

a394 1
 * Called via ctx->Driver.DeleteShaderProgram().
d396 3
a398 2
static void
_mesa_delete_shader_program(struct gl_context *ctx, struct gl_shader_program *shProg)
d459 1
a459 4
   driver->NewShader = _mesa_new_shader;
   driver->DeleteShader = _mesa_delete_shader;
   driver->NewShaderProgram = _mesa_new_shader_program;
   driver->DeleteShaderProgram = _mesa_delete_shader_program;
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d72 2
d79 1
a79 1
         _mesa_delete_shader(ctx, old);
d89 2
d123 1
d125 1
a125 1
void
d212 4
d221 1
a221 1
         _mesa_delete_shader_program(ctx, old);
d230 4
a255 2
   exec_list_make_empty(&prog->EmptyUniformLocations);

d261 1
d263 1
a263 1
struct gl_shader_program *
d307 3
a309 3
   ralloc_free(shProg->BufferInterfaceBlocks);
   shProg->BufferInterfaceBlocks = NULL;
   shProg->NumBufferInterfaceBlocks = 0;
d311 2
a312 2
      ralloc_free(shProg->InterfaceBlockStageIndex[i]);
      shProg->InterfaceBlockStageIndex[i] = NULL;
d377 1
a377 1
	 _mesa_delete_shader(ctx, shProg->_LinkedShaders[sh]);
d389 1
d391 2
a392 3
void
_mesa_delete_shader_program(struct gl_context *ctx,
                            struct gl_shader_program *shProg)
d454 3
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d42 1
a43 1
#include "util/string_to_uint_map.h"
d91 2
a92 2
static void
_mesa_init_shader(struct gl_shader *shader)
a94 3
   shader->info.Geom.VerticesOut = -1;
   shader->info.Geom.InputType = GL_TRIANGLES;
   shader->info.Geom.OutputType = GL_TRIANGLE_STRIP;
d99 1
d102 1
a102 1
_mesa_new_shader(GLuint name, gl_shader_stage stage)
d105 1
d108 2
a109 1
      shader->Stage = stage;
d111 1
a111 17
      _mesa_init_shader(shader);
   }
   return shader;
}


/**
 * Allocate a new gl_linked_shader object.
 * Called via ctx->Driver.NewShader()
 */
struct gl_linked_shader *
_mesa_new_linked_shader(gl_shader_stage stage)
{
   struct gl_linked_shader *shader;
   shader = rzalloc(NULL, struct gl_linked_shader);
   if (shader) {
      shader->Stage = stage;
a124 11
   ralloc_free(sh);
}


/**
 * Delete a shader object.
 */
void
_mesa_delete_linked_shader(struct gl_context *ctx,
                           struct gl_linked_shader *sh)
{
d235 3
a240 2
   prog->Comp.LocalSizeVariable = false;

d268 1
a268 2
_mesa_clear_shader_program_data(struct gl_context *ctx,
                                struct gl_shader_program *shProg)
d270 1
a270 6
   for (gl_shader_stage sh = 0; sh < MESA_SHADER_STAGES; sh++) {
      if (shProg->_LinkedShaders[sh] != NULL) {
         _mesa_delete_linked_shader(ctx, shProg->_LinkedShaders[sh]);
         shProg->_LinkedShaders[sh] = NULL;
      }
   }
d273 1
a273 1
      for (unsigned i = 0; i < shProg->NumUniformStorage; ++i)
d295 7
a301 7
   ralloc_free(shProg->UniformBlocks);
   shProg->UniformBlocks = NULL;
   shProg->NumUniformBlocks = 0;

   ralloc_free(shProg->ShaderStorageBlocks);
   shProg->ShaderStorageBlocks = NULL;
   shProg->NumShaderStorageBlocks = 0;
d324 1
d328 1
a328 1
   _mesa_clear_shader_program_data(ctx, shProg);
d362 8
d441 1
a441 1
   driver->NewShader = _mesa_new_linked_shader;
@


1.1.1.4
log
@Import Mesa 13.0.5
@
text
@a41 1
#include "util/u_atomic.h"
d67 1
d71 2
d74 1
a74 1
      if (p_atomic_dec_zero(&old->RefCount)) {
d86 1
a86 1
      p_atomic_inc(&sh->RefCount);
d229 1
d233 2
d236 1
a236 1
      if (p_atomic_dec_zero(&old->RefCount)) {
d247 1
a247 1
      p_atomic_inc(&shProg->RefCount);
@


1.1.1.5
log
@Import Mesa 17.1.6
@
text
@d42 1
a44 1
#include "util/u_atomic.h"
a108 3
#ifdef DEBUG
      shader->SourceChecksum = 0xa110c; /* alloc */
#endif
d116 16
a137 1
   free((void *)sh->FallbackSource);
a208 27
void
_mesa_reference_shader_program_data(struct gl_context *ctx,
                                    struct gl_shader_program_data **ptr,
                                    struct gl_shader_program_data *data)
{
   if (*ptr == data)
      return;

   if (*ptr) {
      struct gl_shader_program_data *oldData = *ptr;

      assert(oldData->RefCount > 0);

      if (p_atomic_dec_zero(&oldData->RefCount)) {
         assert(ctx);
         ralloc_free(oldData);
      }

      *ptr = NULL;
   }

   if (data)
      p_atomic_inc(&data->RefCount);

   *ptr = data;
}

a246 11
static struct gl_shader_program_data *
create_shader_program_data()
{
   struct gl_shader_program_data *data;
   data = rzalloc(NULL, struct gl_shader_program_data);
   if (data)
      data->RefCount = 1;

   return data;
}

d260 2
d266 1
a266 1
   prog->data->InfoLog = ralloc_strdup(prog->data, "");
a278 5
      shProg->data = create_shader_program_data();
      if (!shProg->data) {
         ralloc_free(shProg);
         return NULL;
      }
d299 6
a304 9
   shProg->data->linked_stages = 0;

   if (shProg->data->UniformStorage && !shProg->data->cache_fallback) {
      for (unsigned i = 0; i < shProg->data->NumUniformStorage; ++i)
         _mesa_uniform_detach_all_driver_storage(&shProg->data->
                                                    UniformStorage[i]);
      ralloc_free(shProg->data->UniformStorage);
      shProg->data->NumUniformStorage = 0;
      shProg->data->UniformStorage = NULL;
d307 1
a307 1
   if (shProg->UniformRemapTable && !shProg->data->cache_fallback) {
d318 20
a337 24
   assert(shProg->data->InfoLog != NULL);
   ralloc_free(shProg->data->InfoLog);
   shProg->data->InfoLog = ralloc_strdup(shProg->data, "");

   if (!shProg->data->cache_fallback) {
      ralloc_free(shProg->data->UniformBlocks);
      shProg->data->UniformBlocks = NULL;
      shProg->data->NumUniformBlocks = 0;

      ralloc_free(shProg->data->ShaderStorageBlocks);
      shProg->data->ShaderStorageBlocks = NULL;
      shProg->data->NumShaderStorageBlocks = 0;
   }

   if (shProg->data->AtomicBuffers && !shProg->data->cache_fallback) {
      ralloc_free(shProg->data->AtomicBuffers);
      shProg->data->AtomicBuffers = NULL;
      shProg->data->NumAtomicBuffers = 0;
   }

   if (shProg->data->ProgramResourceList) {
      ralloc_free(shProg->data->ProgramResourceList);
      shProg->data->ProgramResourceList = NULL;
      shProg->data->NumProgramResourceList = 0;
d401 1
a401 2
   if (!shProg->data->cache_fallback)
      _mesa_reference_shader_program_data(ctx, &shProg->data, NULL);
d459 1
@


