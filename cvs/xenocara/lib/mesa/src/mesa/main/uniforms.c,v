head	1.2;
access;
symbols
	mesa-17_1_6:1.1.1.4
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.08.26.16.59.39;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2015.11.22.02.39.15;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.39.15;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.14.29;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.39.03;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.08.14.09.44.42;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2004-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009-2010  VMware, Inc.  All Rights Reserved.
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file uniforms.c
 * Functions related to GLSL uniform variables.
 * \author Brian Paul
 */

/**
 * XXX things to do:
 * 1. Check that the right error code is generated for all _mesa_error() calls.
 * 2. Insert FLUSH_VERTICES calls in various places
 */

#include "main/glheader.h"
#include "main/context.h"
#include "main/dispatch.h"
#include "main/shaderapi.h"
#include "main/shaderobj.h"
#include "main/uniforms.h"
#include "main/enums.h"
#include "compiler/glsl/ir_uniform.h"
#include "compiler/glsl_types.h"
#include "program/program.h"
#include "util/bitscan.h"

/**
 * Update the vertex/fragment program's TexturesUsed array.
 *
 * This needs to be called after glUniform(set sampler var) is called.
 * A call to glUniform(samplerVar, value) causes a sampler to point to a
 * particular texture unit.  We know the sampler's texture target
 * (1D/2D/3D/etc) from compile time but the sampler's texture unit is
 * set by glUniform() calls.
 *
 * So, scan the program->SamplerUnits[] and program->SamplerTargets[]
 * information to update the prog->TexturesUsed[] values.
 * Each value of TexturesUsed[unit] is one of zero, TEXTURE_1D_INDEX,
 * TEXTURE_2D_INDEX, TEXTURE_3D_INDEX, etc.
 * We'll use that info for state validation before rendering.
 */
void
_mesa_update_shader_textures_used(struct gl_shader_program *shProg,
				  struct gl_program *prog)
{
   GLbitfield mask = prog->SamplersUsed;
   struct gl_linked_shader *shader =
      shProg->_LinkedShaders[_mesa_program_enum_to_shader_stage(prog->Target)];

   assert(shader);

   memcpy(prog->SamplerUnits, shader->SamplerUnits, sizeof(prog->SamplerUnits));
   memset(prog->TexturesUsed, 0, sizeof(prog->TexturesUsed));

   shProg->SamplersValidated = GL_TRUE;

   while (mask) {
      const int s = u_bit_scan(&mask);
      GLuint unit = shader->SamplerUnits[s];
      GLuint tgt = shader->SamplerTargets[s];
      assert(unit < ARRAY_SIZE(prog->TexturesUsed));
      assert(tgt < NUM_TEXTURE_TARGETS);

      /* The types of the samplers associated with a particular texture
       * unit must be an exact match.  Page 74 (page 89 of the PDF) of the
       * OpenGL 3.3 core spec says:
       *
       *     "It is not allowed to have variables of different sampler
       *     types pointing to the same texture image unit within a program
       *     object."
       */
      if (prog->TexturesUsed[unit] & ~(1 << tgt))
         shProg->SamplersValidated = GL_FALSE;

      prog->TexturesUsed[unit] |= (1 << tgt);
   }
}

/**
 * Connect a piece of driver storage with a part of a uniform
 *
 * \param uni            The uniform with which the storage will be associated
 * \param element_stride Byte-stride between array elements.
 *                       \sa gl_uniform_driver_storage::element_stride.
 * \param vector_stride  Byte-stride between vectors (in a matrix).
 *                       \sa gl_uniform_driver_storage::vector_stride.
 * \param format         Conversion from native format to driver format
 *                       required by the driver.
 * \param data           Location to dump the data.
 */
void
_mesa_uniform_attach_driver_storage(struct gl_uniform_storage *uni,
				    unsigned element_stride,
				    unsigned vector_stride,
				    enum gl_uniform_driver_format format,
				    void *data)
{
   uni->driver_storage =
      realloc(uni->driver_storage,
	      sizeof(struct gl_uniform_driver_storage)
	      * (uni->num_driver_storage + 1));

   uni->driver_storage[uni->num_driver_storage].element_stride = element_stride;
   uni->driver_storage[uni->num_driver_storage].vector_stride = vector_stride;
   uni->driver_storage[uni->num_driver_storage].format = format;
   uni->driver_storage[uni->num_driver_storage].data = data;

   uni->num_driver_storage++;
}

/**
 * Sever all connections with all pieces of driver storage for all uniforms
 *
 * \warning
 * This function does \b not release any of the \c data pointers
 * previously passed in to \c _mesa_uniform_attach_driver_stoarge.
 */
void
_mesa_uniform_detach_all_driver_storage(struct gl_uniform_storage *uni)
{
   free(uni->driver_storage);
   uni->driver_storage = NULL;
   uni->num_driver_storage = 0;
}

void GLAPIENTRY
_mesa_Uniform1f(GLint location, GLfloat v0)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, &v0, GLSL_TYPE_FLOAT, 1);
}

void GLAPIENTRY
_mesa_Uniform2f(GLint location, GLfloat v0, GLfloat v1)
{
   GET_CURRENT_CONTEXT(ctx);
   GLfloat v[2];
   v[0] = v0;
   v[1] = v1;
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, v, GLSL_TYPE_FLOAT, 2);
}

void GLAPIENTRY
_mesa_Uniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   GET_CURRENT_CONTEXT(ctx);
   GLfloat v[3];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, v, GLSL_TYPE_FLOAT, 3);
}

void GLAPIENTRY
_mesa_Uniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2,
                   GLfloat v3)
{
   GET_CURRENT_CONTEXT(ctx);
   GLfloat v[4];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, v, GLSL_TYPE_FLOAT, 4);
}

void GLAPIENTRY
_mesa_Uniform1i(GLint location, GLint v0)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, &v0, GLSL_TYPE_INT, 1);
}

void GLAPIENTRY
_mesa_Uniform2i(GLint location, GLint v0, GLint v1)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint v[2];
   v[0] = v0;
   v[1] = v1;
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, v, GLSL_TYPE_INT, 2);
}

void GLAPIENTRY
_mesa_Uniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint v[3];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, v, GLSL_TYPE_INT, 3);
}

void GLAPIENTRY
_mesa_Uniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint v[4];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, v, GLSL_TYPE_INT, 4);
}

void GLAPIENTRY
_mesa_Uniform1fv(GLint location, GLsizei count, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_FLOAT, 1);
}

void GLAPIENTRY
_mesa_Uniform2fv(GLint location, GLsizei count, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_FLOAT, 2);
}

void GLAPIENTRY
_mesa_Uniform3fv(GLint location, GLsizei count, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_FLOAT, 3);
}

void GLAPIENTRY
_mesa_Uniform4fv(GLint location, GLsizei count, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_FLOAT, 4);
}

void GLAPIENTRY
_mesa_Uniform1iv(GLint location, GLsizei count, const GLint * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_INT, 1);
}

void GLAPIENTRY
_mesa_Uniform2iv(GLint location, GLsizei count, const GLint * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_INT, 2);
}

void GLAPIENTRY
_mesa_Uniform3iv(GLint location, GLsizei count, const GLint * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_INT, 3);
}

void GLAPIENTRY
_mesa_Uniform4iv(GLint location, GLsizei count, const GLint * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_INT, 4);
}

/** Same as above with direct state access **/
void GLAPIENTRY
_mesa_ProgramUniform1f(GLuint program, GLint location, GLfloat v0)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform1f");
   _mesa_uniform(ctx, shProg, location, 1, &v0, GLSL_TYPE_FLOAT, 1);
}

void GLAPIENTRY
_mesa_ProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
   GET_CURRENT_CONTEXT(ctx);
   GLfloat v[2];
   struct gl_shader_program *shProg;
   v[0] = v0;
   v[1] = v1;
   shProg = _mesa_lookup_shader_program_err(ctx, program, "glProgramUniform2f");
   _mesa_uniform(ctx, shProg, location, 1, v, GLSL_TYPE_FLOAT, 2);
}

void GLAPIENTRY
_mesa_ProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1,
                       GLfloat v2)
{
   GET_CURRENT_CONTEXT(ctx);
   GLfloat v[3];
   struct gl_shader_program *shProg;
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   shProg = _mesa_lookup_shader_program_err(ctx, program, "glProgramUniform3f");
   _mesa_uniform(ctx, shProg, location, 1, v, GLSL_TYPE_FLOAT, 3);
}

void GLAPIENTRY
_mesa_ProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1,
                       GLfloat v2, GLfloat v3)
{
   GET_CURRENT_CONTEXT(ctx);
   GLfloat v[4];
   struct gl_shader_program *shProg;
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;
   shProg = _mesa_lookup_shader_program_err(ctx, program, "glProgramUniform4f");
   _mesa_uniform(ctx, shProg, location, 1, v, GLSL_TYPE_FLOAT, 4);
}

void GLAPIENTRY
_mesa_ProgramUniform1i(GLuint program, GLint location, GLint v0)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform1i");
   _mesa_uniform(ctx, shProg, location, 1, &v0, GLSL_TYPE_INT, 1);
}

void GLAPIENTRY
_mesa_ProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint v[2];
   struct gl_shader_program *shProg;
   v[0] = v0;
   v[1] = v1;
   shProg = _mesa_lookup_shader_program_err(ctx, program, "glProgramUniform2i");
   _mesa_uniform(ctx, shProg, location, 1, v, GLSL_TYPE_INT, 2);
}

void GLAPIENTRY
_mesa_ProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1,
                       GLint v2)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint v[3];
   struct gl_shader_program *shProg;
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   shProg = _mesa_lookup_shader_program_err(ctx, program, "glProgramUniform3i");
   _mesa_uniform(ctx, shProg, location, 1, v, GLSL_TYPE_INT, 3);
}

void GLAPIENTRY
_mesa_ProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1,
                       GLint v2, GLint v3)
{
   GET_CURRENT_CONTEXT(ctx);
   GLint v[4];
   struct gl_shader_program *shProg;
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;
   shProg = _mesa_lookup_shader_program_err(ctx, program, "glProgramUniform4i");
   _mesa_uniform(ctx, shProg, location, 1, v, GLSL_TYPE_INT, 4);
}

void GLAPIENTRY
_mesa_ProgramUniform1fv(GLuint program, GLint location, GLsizei count,
                        const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform1fv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_FLOAT, 1);
}

void GLAPIENTRY
_mesa_ProgramUniform2fv(GLuint program, GLint location, GLsizei count,
                        const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform2fv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_FLOAT, 2);
}

void GLAPIENTRY
_mesa_ProgramUniform3fv(GLuint program, GLint location, GLsizei count,
                        const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform3fv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_FLOAT, 3);
}

void GLAPIENTRY
_mesa_ProgramUniform4fv(GLuint program, GLint location, GLsizei count,
                        const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform4fv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_FLOAT, 4);
}

void GLAPIENTRY
_mesa_ProgramUniform1iv(GLuint program, GLint location, GLsizei count,
                        const GLint * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform1iv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_INT, 1);
}

void GLAPIENTRY
_mesa_ProgramUniform2iv(GLuint program, GLint location, GLsizei count,
                        const GLint * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform2iv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_INT, 2);
}

void GLAPIENTRY
_mesa_ProgramUniform3iv(GLuint program, GLint location, GLsizei count,
                        const GLint * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform3iv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_INT, 3);
}

void GLAPIENTRY
_mesa_ProgramUniform4iv(GLuint program, GLint location, GLsizei count,
                        const GLint * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform4iv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_INT, 4);
}


/** OpenGL 3.0 GLuint-valued functions **/
void GLAPIENTRY
_mesa_Uniform1ui(GLint location, GLuint v0)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, &v0, GLSL_TYPE_UINT, 1);
}

void GLAPIENTRY
_mesa_Uniform2ui(GLint location, GLuint v0, GLuint v1)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint v[2];
   v[0] = v0;
   v[1] = v1;
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, v, GLSL_TYPE_UINT, 2);
}

void GLAPIENTRY
_mesa_Uniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint v[3];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, v, GLSL_TYPE_UINT, 3);
}

void GLAPIENTRY
_mesa_Uniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint v[4];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, v, GLSL_TYPE_UINT, 4);
}

void GLAPIENTRY
_mesa_Uniform1uiv(GLint location, GLsizei count, const GLuint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_UINT, 1);
}

void GLAPIENTRY
_mesa_Uniform2uiv(GLint location, GLsizei count, const GLuint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_UINT, 2);
}

void GLAPIENTRY
_mesa_Uniform3uiv(GLint location, GLsizei count, const GLuint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_UINT, 3);
}

void GLAPIENTRY
_mesa_Uniform4uiv(GLint location, GLsizei count, const GLuint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_UINT, 4);
}



void GLAPIENTRY
_mesa_UniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose,
                          const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			2, 2, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_UniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose,
                          const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			3, 3, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_UniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose,
                          const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			4, 4, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

/** Same as above with direct state access **/

void GLAPIENTRY
_mesa_ProgramUniform1ui(GLuint program, GLint location, GLuint v0)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform1ui");
   _mesa_uniform(ctx, shProg, location, 1, &v0, GLSL_TYPE_UINT, 1);
}

void GLAPIENTRY
_mesa_ProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint v[2];
   struct gl_shader_program *shProg;
   v[0] = v0;
   v[1] = v1;
   shProg = _mesa_lookup_shader_program_err(ctx, program,
                                            "glProgramUniform2ui");
   _mesa_uniform(ctx, shProg, location, 1, v, GLSL_TYPE_UINT, 2);
}

void GLAPIENTRY
_mesa_ProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1,
                        GLuint v2)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint v[3];
   struct gl_shader_program *shProg;
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   shProg = _mesa_lookup_shader_program_err(ctx, program,
                                            "glProgramUniform3ui");
   _mesa_uniform(ctx, shProg, location, 1, v, GLSL_TYPE_UINT, 3);
}

void GLAPIENTRY
_mesa_ProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1,
                        GLuint v2, GLuint v3)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint v[4];
   struct gl_shader_program *shProg;
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;
   shProg = _mesa_lookup_shader_program_err(ctx, program, "glProgramUniform4ui");
   _mesa_uniform(ctx, shProg, location, 1, v, GLSL_TYPE_UINT, 4);
}

void GLAPIENTRY
_mesa_ProgramUniform1uiv(GLuint program, GLint location, GLsizei count,
                         const GLuint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform1uiv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_UINT, 1);
}

void GLAPIENTRY
_mesa_ProgramUniform2uiv(GLuint program, GLint location, GLsizei count,
                         const GLuint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform2uiv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_UINT, 2);
}

void GLAPIENTRY
_mesa_ProgramUniform3uiv(GLuint program, GLint location, GLsizei count,
                         const GLuint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform3uiv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_UINT, 3);
}

void GLAPIENTRY
_mesa_ProgramUniform4uiv(GLuint program, GLint location, GLsizei count,
                         const GLuint *value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform4uiv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_UINT, 4);
}



void GLAPIENTRY
_mesa_ProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count,
                              GLboolean transpose, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix2fv");
   _mesa_uniform_matrix(ctx, shProg, 2, 2, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count,
                              GLboolean transpose, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix3fv");
   _mesa_uniform_matrix(ctx, shProg, 3, 3, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count,
                              GLboolean transpose, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix4fv");
   _mesa_uniform_matrix(ctx, shProg, 4, 4, location, count, transpose, value, GLSL_TYPE_FLOAT);
}


/**
 * Non-square UniformMatrix are OpenGL 2.1
 */
void GLAPIENTRY
_mesa_UniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			2, 3, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_UniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			3, 2, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_UniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			2, 4, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_UniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			4, 2, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_UniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			3, 4, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_UniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose,
                         const GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			4, 3, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

/** Same as above with direct state access **/

void GLAPIENTRY
_mesa_ProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix2x3fv");
   _mesa_uniform_matrix(ctx, shProg, 2, 3, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix3x2fv");
   _mesa_uniform_matrix(ctx, shProg, 3, 2, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix2x4fv");
   _mesa_uniform_matrix(ctx, shProg, 2, 4, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix4x2fv");
   _mesa_uniform_matrix(ctx, shProg, 4, 2, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix3x4fv");
   _mesa_uniform_matrix(ctx, shProg, 3, 4, location, count, transpose, value, GLSL_TYPE_FLOAT);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLfloat * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix4x3fv");
   _mesa_uniform_matrix(ctx, shProg, 4, 3, location, count, transpose, value, GLSL_TYPE_FLOAT);
}


void GLAPIENTRY
_mesa_GetnUniformfvARB(GLuint program, GLint location,
                       GLsizei bufSize, GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_get_uniform(ctx, program, location, bufSize, GLSL_TYPE_FLOAT, params);
}

void GLAPIENTRY
_mesa_GetUniformfv(GLuint program, GLint location, GLfloat *params)
{
   _mesa_GetnUniformfvARB(program, location, INT_MAX, params);
}


void GLAPIENTRY
_mesa_GetnUniformivARB(GLuint program, GLint location,
                       GLsizei bufSize, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_get_uniform(ctx, program, location, bufSize, GLSL_TYPE_INT, params);
}

void GLAPIENTRY
_mesa_GetUniformiv(GLuint program, GLint location, GLint *params)
{
   _mesa_GetnUniformivARB(program, location, INT_MAX, params);
}


/* GL3 */
void GLAPIENTRY
_mesa_GetnUniformuivARB(GLuint program, GLint location,
                        GLsizei bufSize, GLuint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_get_uniform(ctx, program, location, bufSize, GLSL_TYPE_UINT, params);
}

void GLAPIENTRY
_mesa_GetUniformuiv(GLuint program, GLint location, GLuint *params)
{
   _mesa_GetnUniformuivARB(program, location, INT_MAX, params);
}


/* GL4 */
void GLAPIENTRY
_mesa_GetnUniformdvARB(GLuint program, GLint location,
                       GLsizei bufSize, GLdouble *params)
{
   GET_CURRENT_CONTEXT(ctx);

   _mesa_get_uniform(ctx, program, location, bufSize, GLSL_TYPE_DOUBLE, params);
}

void GLAPIENTRY
_mesa_GetUniformdv(GLuint program, GLint location, GLdouble *params)
{
   _mesa_GetnUniformdvARB(program, location, INT_MAX, params);
}


GLint GLAPIENTRY
_mesa_GetUniformLocation(GLuint programObj, const GLcharARB *name)
{
   struct gl_shader_program *shProg;

   GET_CURRENT_CONTEXT(ctx);

   shProg = _mesa_lookup_shader_program_err(ctx, programObj,
					    "glGetUniformLocation");
   if (!shProg)
      return -1;

   /* Page 80 (page 94 of the PDF) of the OpenGL 2.1 spec says:
    *
    *     "If program has not been successfully linked, the error
    *     INVALID_OPERATION is generated."
    */
   if (shProg->LinkStatus == GL_FALSE) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
		  "glGetUniformLocation(program not linked)");
      return -1;
   }

   return _mesa_program_resource_location(shProg, GL_UNIFORM, name);
}

GLuint GLAPIENTRY
_mesa_GetUniformBlockIndex(GLuint program,
			   const GLchar *uniformBlockName)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg;

   if (!ctx->Extensions.ARB_uniform_buffer_object) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetUniformBlockIndex");
      return GL_INVALID_INDEX;
   }

   shProg = _mesa_lookup_shader_program_err(ctx, program,
					    "glGetUniformBlockIndex");
   if (!shProg)
      return GL_INVALID_INDEX;

   struct gl_program_resource *res =
      _mesa_program_resource_find_name(shProg, GL_UNIFORM_BLOCK,
                                       uniformBlockName, NULL);
   if (!res)
      return GL_INVALID_INDEX;

   return _mesa_program_resource_index(shProg, res);
}

void GLAPIENTRY
_mesa_GetUniformIndices(GLuint program,
			GLsizei uniformCount,
			const GLchar * const *uniformNames,
			GLuint *uniformIndices)
{
   GET_CURRENT_CONTEXT(ctx);
   GLsizei i;
   struct gl_shader_program *shProg;

   if (!ctx->Extensions.ARB_uniform_buffer_object) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetUniformIndices");
      return;
   }

   shProg = _mesa_lookup_shader_program_err(ctx, program,
					    "glGetUniformIndices");
   if (!shProg)
      return;

   if (uniformCount < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "glGetUniformIndices(uniformCount < 0)");
      return;
   }

   for (i = 0; i < uniformCount; i++) {
      struct gl_program_resource *res =
         _mesa_program_resource_find_name(shProg, GL_UNIFORM, uniformNames[i],
                                          NULL);
      uniformIndices[i] = _mesa_program_resource_index(shProg, res);
   }
}

void GLAPIENTRY
_mesa_UniformBlockBinding(GLuint program,
			  GLuint uniformBlockIndex,
			  GLuint uniformBlockBinding)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg;

   if (!ctx->Extensions.ARB_uniform_buffer_object) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glUniformBlockBinding");
      return;
   }

   shProg = _mesa_lookup_shader_program_err(ctx, program,
					    "glUniformBlockBinding");
   if (!shProg)
      return;

   if (uniformBlockIndex >= shProg->NumUniformBlocks) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "glUniformBlockBinding(block index %u >= %u)",
		  uniformBlockIndex, shProg->NumUniformBlocks);
      return;
   }

   if (uniformBlockBinding >= ctx->Const.MaxUniformBufferBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "glUniformBlockBinding(block binding %u >= %u)",
		  uniformBlockBinding, ctx->Const.MaxUniformBufferBindings);
      return;
   }

   if (shProg->UniformBlocks[uniformBlockIndex].Binding !=
       uniformBlockBinding) {

      FLUSH_VERTICES(ctx, 0);
      ctx->NewDriverState |= ctx->DriverFlags.NewUniformBuffer;

      shProg->UniformBlocks[uniformBlockIndex].Binding = uniformBlockBinding;
   }
}

void GLAPIENTRY
_mesa_ShaderStorageBlockBinding(GLuint program,
			        GLuint shaderStorageBlockIndex,
			        GLuint shaderStorageBlockBinding)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg;

   if (!ctx->Extensions.ARB_shader_storage_buffer_object) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glShaderStorageBlockBinding");
      return;
   }

   shProg = _mesa_lookup_shader_program_err(ctx, program,
					    "glShaderStorageBlockBinding");
   if (!shProg)
      return;

   if (shaderStorageBlockIndex >= shProg->NumShaderStorageBlocks) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "glShaderStorageBlockBinding(block index %u >= %u)",
		  shaderStorageBlockIndex, shProg->NumShaderStorageBlocks);
      return;
   }

   if (shaderStorageBlockBinding >= ctx->Const.MaxShaderStorageBufferBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "glShaderStorageBlockBinding(block binding %u >= %u)",
		  shaderStorageBlockBinding,
                  ctx->Const.MaxShaderStorageBufferBindings);
      return;
   }

   if (shProg->ShaderStorageBlocks[shaderStorageBlockIndex].Binding !=
       shaderStorageBlockBinding) {

      FLUSH_VERTICES(ctx, 0);
      ctx->NewDriverState |= ctx->DriverFlags.NewShaderStorageBuffer;

      shProg->ShaderStorageBlocks[shaderStorageBlockIndex].Binding =
         shaderStorageBlockBinding;
   }
}

/**
 * Generic program resource property query.
 */
static void
mesa_bufferiv(struct gl_shader_program *shProg, GLenum type,
              GLuint index, GLenum pname, GLint *params, const char *caller)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_program_resource *res =
      _mesa_program_resource_find_index(shProg, type, index);

   if (!res) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(bufferindex %d)", caller, index);
      return;
   }

   switch (pname) {
   case GL_UNIFORM_BLOCK_BINDING:
   case GL_ATOMIC_COUNTER_BUFFER_BINDING:
      _mesa_program_resource_prop(shProg, res, index, GL_BUFFER_BINDING,
                                  params, caller);
      return;
   case GL_UNIFORM_BLOCK_DATA_SIZE:
   case GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE:
      _mesa_program_resource_prop(shProg, res, index, GL_BUFFER_DATA_SIZE,
                                  params, caller);
      return;
   case GL_UNIFORM_BLOCK_NAME_LENGTH:
      _mesa_program_resource_prop(shProg, res, index, GL_NAME_LENGTH,
                                  params, caller);
      return;
   case GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS:
   case GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS:
      _mesa_program_resource_prop(shProg, res, index, GL_NUM_ACTIVE_VARIABLES,
                                  params, caller);
      return;
   case GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES:
   case GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES:
      _mesa_program_resource_prop(shProg, res, index, GL_ACTIVE_VARIABLES,
                                  params, caller);
      return;
   case GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:
   case GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER:
      _mesa_program_resource_prop(shProg, res, index,
                                  GL_REFERENCED_BY_VERTEX_SHADER, params,
                                  caller);
      return;

   case GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER:
   case GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER:
      _mesa_program_resource_prop(shProg, res, index,
                                  GL_REFERENCED_BY_TESS_CONTROL_SHADER, params,
                                  caller);
      return;

   case GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER:
   case GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER:
      _mesa_program_resource_prop(shProg, res, index,
                                  GL_REFERENCED_BY_TESS_EVALUATION_SHADER, params,
                                  caller);
      return;

   case GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER:
   case GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER:
      _mesa_program_resource_prop(shProg, res, index,
                                  GL_REFERENCED_BY_GEOMETRY_SHADER, params,
                                  caller);
      return;
   case GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:
   case GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER:
      _mesa_program_resource_prop(shProg, res, index,
                                  GL_REFERENCED_BY_FRAGMENT_SHADER, params,
                                  caller);
      return;
   case GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER:
   case GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER:
      _mesa_program_resource_prop(shProg, res, index,
                                  GL_REFERENCED_BY_COMPUTE_SHADER, params,
                                  caller);
      return;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "%s(pname 0x%x (%s))", caller, pname,
                  _mesa_enum_to_string(pname));
      return;
   }
}


void GLAPIENTRY
_mesa_GetActiveUniformBlockiv(GLuint program,
			      GLuint uniformBlockIndex,
			      GLenum pname,
			      GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg;

   if (!ctx->Extensions.ARB_uniform_buffer_object) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetActiveUniformBlockiv");
      return;
   }

   shProg = _mesa_lookup_shader_program_err(ctx, program,
					    "glGetActiveUniformBlockiv");
   if (!shProg)
      return;

   mesa_bufferiv(shProg, GL_UNIFORM_BLOCK, uniformBlockIndex, pname, params,
                 "glGetActiveUniformBlockiv");
}

void GLAPIENTRY
_mesa_GetActiveUniformBlockName(GLuint program,
				GLuint uniformBlockIndex,
				GLsizei bufSize,
				GLsizei *length,
				GLchar *uniformBlockName)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg;

   if (!ctx->Extensions.ARB_uniform_buffer_object) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetActiveUniformBlockiv");
      return;
   }

   if (bufSize < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "glGetActiveUniformBlockName(bufSize %d < 0)",
		  bufSize);
      return;
   }

   shProg = _mesa_lookup_shader_program_err(ctx, program,
					    "glGetActiveUniformBlockiv");
   if (!shProg)
      return;

   if (uniformBlockName)
      _mesa_get_program_resource_name(shProg, GL_UNIFORM_BLOCK,
                                      uniformBlockIndex, bufSize, length,
                                      uniformBlockName,
                                      "glGetActiveUniformBlockName");
}

void GLAPIENTRY
_mesa_GetActiveUniformName(GLuint program, GLuint uniformIndex,
			   GLsizei bufSize, GLsizei *length,
			   GLchar *uniformName)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg;

   if (!ctx->Extensions.ARB_uniform_buffer_object) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetActiveUniformName");
      return;
   }

   if (bufSize < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "glGetActiveUniformName(bufSize %d < 0)",
		  bufSize);
      return;
   }

   shProg = _mesa_lookup_shader_program_err(ctx, program, "glGetActiveUniformName");

   if (!shProg)
      return;

   _mesa_get_program_resource_name(shProg, GL_UNIFORM, uniformIndex, bufSize,
                                   length, uniformName, "glGetActiveUniformName");
}

void GLAPIENTRY
_mesa_GetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex,
                                     GLenum pname, GLint *params)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg;

   if (!ctx->Extensions.ARB_shader_atomic_counters) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetActiveAtomicCounterBufferiv");
      return;
   }

   shProg = _mesa_lookup_shader_program_err(ctx, program,
                                            "glGetActiveAtomicCounterBufferiv");
   if (!shProg)
      return;

   mesa_bufferiv(shProg, GL_ATOMIC_COUNTER_BUFFER, bufferIndex, pname, params,
                 "glGetActiveAtomicCounterBufferiv");
}

void GLAPIENTRY
_mesa_Uniform1d(GLint location, GLdouble v0)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, &v0, GLSL_TYPE_DOUBLE, 1);
}

void GLAPIENTRY
_mesa_Uniform2d(GLint location, GLdouble v0, GLdouble v1)
{
   GET_CURRENT_CONTEXT(ctx);
   GLdouble v[2];
   v[0] = v0;
   v[1] = v1;
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, v, GLSL_TYPE_DOUBLE, 2);
}

void GLAPIENTRY
_mesa_Uniform3d(GLint location, GLdouble v0, GLdouble v1, GLdouble v2)
{
   GET_CURRENT_CONTEXT(ctx);
   GLdouble v[3];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, v, GLSL_TYPE_DOUBLE, 3);
}

void GLAPIENTRY
_mesa_Uniform4d(GLint location, GLdouble v0, GLdouble v1, GLdouble v2,
                GLdouble v3)
{
   GET_CURRENT_CONTEXT(ctx);
   GLdouble v[4];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, 1, v, GLSL_TYPE_DOUBLE, 4);
}

void GLAPIENTRY
_mesa_Uniform1dv(GLint location, GLsizei count, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_DOUBLE, 1);
}

void GLAPIENTRY
_mesa_Uniform2dv(GLint location, GLsizei count, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_DOUBLE, 2);
}

void GLAPIENTRY
_mesa_Uniform3dv(GLint location, GLsizei count, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_DOUBLE, 3);
}

void GLAPIENTRY
_mesa_Uniform4dv(GLint location, GLsizei count, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(ctx, ctx->_Shader->ActiveProgram, location, count, value, GLSL_TYPE_DOUBLE, 4);
}

void GLAPIENTRY
_mesa_UniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose,
                       const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			2, 2, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_UniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose,
                       const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			3, 3, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_UniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose,
                       const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			4, 4, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_UniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose,
                         const GLdouble *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			2, 3, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_UniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose,
                         const GLdouble *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			3, 2, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_UniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose,
                         const GLdouble *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			2, 4, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_UniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose,
                         const GLdouble *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			4, 2, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_UniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose,
                         const GLdouble *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			3, 4, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_UniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose,
                         const GLdouble *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform_matrix(ctx, ctx->_Shader->ActiveProgram,
			4, 3, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_ProgramUniform1d(GLuint program, GLint location, GLdouble v0)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform1d");
   _mesa_uniform(ctx, shProg, location, 1, &v0, GLSL_TYPE_DOUBLE, 1);
}

void GLAPIENTRY
_mesa_ProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1)
{
   GET_CURRENT_CONTEXT(ctx);
   GLdouble v[2];
   struct gl_shader_program *shProg;
   v[0] = v0;
   v[1] = v1;
   shProg = _mesa_lookup_shader_program_err(ctx, program, "glProgramUniform2d");
   _mesa_uniform(ctx, shProg, location, 1, v, GLSL_TYPE_DOUBLE, 2);
}

void GLAPIENTRY
_mesa_ProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1,
                       GLdouble v2)
{
   GET_CURRENT_CONTEXT(ctx);
   GLdouble v[3];
   struct gl_shader_program *shProg;
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   shProg = _mesa_lookup_shader_program_err(ctx, program, "glProgramUniform3d");
   _mesa_uniform(ctx, shProg, location, 1, v, GLSL_TYPE_DOUBLE, 3);
}

void GLAPIENTRY
_mesa_ProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1,
                       GLdouble v2, GLdouble v3)
{
   GET_CURRENT_CONTEXT(ctx);
   GLdouble v[4];
   struct gl_shader_program *shProg;
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;
   shProg = _mesa_lookup_shader_program_err(ctx, program, "glProgramUniform4d");
   _mesa_uniform(ctx, shProg, location, 1, v, GLSL_TYPE_DOUBLE, 4);
}

void GLAPIENTRY
_mesa_ProgramUniform1dv(GLuint program, GLint location, GLsizei count,
                        const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform1dv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_DOUBLE, 1);
}

void GLAPIENTRY
_mesa_ProgramUniform2dv(GLuint program, GLint location, GLsizei count,
                        const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform2dv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_DOUBLE, 2);
}

void GLAPIENTRY
_mesa_ProgramUniform3dv(GLuint program, GLint location, GLsizei count,
                        const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform3dv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_DOUBLE, 3);
}

void GLAPIENTRY
_mesa_ProgramUniform4dv(GLuint program, GLint location, GLsizei count,
                        const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform4dv");
   _mesa_uniform(ctx, shProg, location, count, value, GLSL_TYPE_DOUBLE, 4);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count,
                              GLboolean transpose, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix2dv");
   _mesa_uniform_matrix(ctx, shProg, 2, 2, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count,
                              GLboolean transpose, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix3dv");
   _mesa_uniform_matrix(ctx, shProg, 3, 3, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count,
                              GLboolean transpose, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix4dv");
   _mesa_uniform_matrix(ctx, shProg, 4, 4, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix2x3dv");
   _mesa_uniform_matrix(ctx, shProg, 2, 3, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix3x2dv");
   _mesa_uniform_matrix(ctx, shProg, 3, 2, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix2x4dv");
   _mesa_uniform_matrix(ctx, shProg, 2, 4, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix4x2dv");
   _mesa_uniform_matrix(ctx, shProg, 4, 2, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix3x4dv");
   _mesa_uniform_matrix(ctx, shProg, 3, 4, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_ProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count,
                                GLboolean transpose, const GLdouble * value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniformMatrix4x3dv");
   _mesa_uniform_matrix(ctx, shProg, 4, 3, location, count, transpose, value, GLSL_TYPE_DOUBLE);
}
@


1.1
log
@Initial revision
@
text
@d46 2
a47 2
#include "ir_uniform.h"
#include "glsl_types.h"
d49 1
d70 2
a71 2
   GLuint s;
   struct gl_shader *shader =
d81 17
a97 17
   for (s = 0; s < MAX_SAMPLERS; s++) {
      if (prog->SamplersUsed & (1 << s)) {
         GLuint unit = shader->SamplerUnits[s];
         GLuint tgt = shader->SamplerTargets[s];
         assert(unit < ARRAY_SIZE(prog->TexturesUsed));
         assert(tgt < NUM_TEXTURE_TARGETS);

         /* The types of the samplers associated with a particular texture
          * unit must be an exact match.  Page 74 (page 89 of the PDF) of the
          * OpenGL 3.3 core spec says:
          *
          *     "It is not allowed to have variables of different sampler
          *     types pointing to the same texture image unit within a program
          *     object."
          */
         if (prog->TexturesUsed[unit] & ~(1 << tgt))
            shProg->SamplersValidated = GL_FALSE;
d99 1
a99 2
         prog->TexturesUsed[unit] |= (1 << tgt);
      }
a1020 1
      int i;
d1026 20
d1047 14
a1060 2
      for (i = 0; i < MESA_SHADER_STAGES; i++) {
	 int stage_index = shProg->UniformBlockStageIndex[i][uniformBlockIndex];
d1062 8
a1069 5
	 if (stage_index != -1) {
	    struct gl_shader *sh = shProg->_LinkedShaders[i];
	    sh->UniformBlocks[stage_index].Binding = uniformBlockBinding;
	 }
      }
a1072 1

d1145 6
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d46 2
a47 2
#include "compiler/glsl/ir_uniform.h"
#include "compiler/glsl_types.h"
d1019 1
a1019 1
   if (shProg->UniformBlocks[uniformBlockIndex]->Binding !=
d1026 1
a1026 5
      const int interface_block_index =
         shProg->UboInterfaceBlockIndex[uniformBlockIndex];

      shProg->BufferInterfaceBlocks[interface_block_index].Binding =
         uniformBlockBinding;
d1029 1
a1029 2
	 int stage_index =
            shProg->InterfaceBlockStageIndex[i][interface_block_index];
d1033 1
a1033 1
	    sh->BufferInterfaceBlocks[stage_index].Binding = uniformBlockBinding;
a1038 57
void GLAPIENTRY
_mesa_ShaderStorageBlockBinding(GLuint program,
			        GLuint shaderStorageBlockIndex,
			        GLuint shaderStorageBlockBinding)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg;

   if (!ctx->Extensions.ARB_shader_storage_buffer_object) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glShaderStorageBlockBinding");
      return;
   }

   shProg = _mesa_lookup_shader_program_err(ctx, program,
					    "glShaderStorageBlockBinding");
   if (!shProg)
      return;

   if (shaderStorageBlockIndex >= shProg->NumShaderStorageBlocks) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "glShaderStorageBlockBinding(block index %u >= %u)",
		  shaderStorageBlockIndex, shProg->NumShaderStorageBlocks);
      return;
   }

   if (shaderStorageBlockBinding >= ctx->Const.MaxShaderStorageBufferBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE,
		  "glShaderStorageBlockBinding(block binding %u >= %u)",
		  shaderStorageBlockBinding,
                  ctx->Const.MaxShaderStorageBufferBindings);
      return;
   }

   if (shProg->ShaderStorageBlocks[shaderStorageBlockIndex]->Binding !=
       shaderStorageBlockBinding) {
      int i;

      FLUSH_VERTICES(ctx, 0);
      ctx->NewDriverState |= ctx->DriverFlags.NewShaderStorageBuffer;

      const int interface_block_index =
         shProg->SsboInterfaceBlockIndex[shaderStorageBlockIndex];

      shProg->BufferInterfaceBlocks[interface_block_index].Binding =
         shaderStorageBlockBinding;

      for (i = 0; i < MESA_SHADER_STAGES; i++) {
	 int stage_index =
            shProg->InterfaceBlockStageIndex[i][interface_block_index];

	 if (stage_index != -1) {
	    struct gl_shader *sh = shProg->_LinkedShaders[i];
	    sh->BufferInterfaceBlocks[stage_index].Binding = shaderStorageBlockBinding;
	 }
      }
   }
}
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@a48 1
#include "util/bitscan.h"
d69 2
a70 2
   GLbitfield mask = prog->SamplersUsed;
   struct gl_linked_shader *shader =
d80 17
a96 17
   while (mask) {
      const int s = u_bit_scan(&mask);
      GLuint unit = shader->SamplerUnits[s];
      GLuint tgt = shader->SamplerTargets[s];
      assert(unit < ARRAY_SIZE(prog->TexturesUsed));
      assert(tgt < NUM_TEXTURE_TARGETS);

      /* The types of the samplers associated with a particular texture
       * unit must be an exact match.  Page 74 (page 89 of the PDF) of the
       * OpenGL 3.3 core spec says:
       *
       *     "It is not allowed to have variables of different sampler
       *     types pointing to the same texture image unit within a program
       *     object."
       */
      if (prog->TexturesUsed[unit] & ~(1 << tgt))
         shProg->SamplersValidated = GL_FALSE;
d98 2
a99 1
      prog->TexturesUsed[unit] |= (1 << tgt);
d1019 1
a1019 1
   if (shProg->UniformBlocks[uniformBlockIndex].Binding !=
d1021 1
d1026 15
a1040 1
      shProg->UniformBlocks[uniformBlockIndex].Binding = uniformBlockBinding;
d1077 1
a1077 1
   if (shProg->ShaderStorageBlocks[shaderStorageBlockIndex].Binding !=
d1079 1
d1084 4
a1087 1
      shProg->ShaderStorageBlocks[shaderStorageBlockIndex].Binding =
d1089 10
a1173 6
                                  caller);
      return;
   case GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER:
   case GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER:
      _mesa_program_resource_prop(shProg, res, index,
                                  GL_REFERENCED_BY_COMPUTE_SHADER, params,
@


1.1.1.4
log
@Import Mesa 17.1.6
@
text
@d68 1
a68 1
                                  struct gl_program *prog)
d71 2
a72 3
   gl_shader_stage prog_stage =
      _mesa_program_enum_to_shader_stage(prog->Target);
   struct gl_linked_shader *shader = shProg->_LinkedShaders[prog_stage];
d76 1
d79 2
d83 2
a84 2
      GLuint unit = prog->SamplerUnits[s];
      GLuint tgt = prog->sh.SamplerTargets[s];
d96 2
a97 14
      unsigned stages_mask = shProg->data->linked_stages;
      while (stages_mask) {
         const int stage = u_bit_scan(&stages_mask);

         /* Skip validation if we are yet to update textures used in this
          * stage.
          */
         if (prog_stage < stage)
            break;

         struct gl_program *glprog = shProg->_LinkedShaders[stage]->Program;
         if (glprog->TexturesUsed[unit] & ~(1 << tgt))
            shProg->SamplersValidated = GL_FALSE;
      }
d154 1
a154 1
   _mesa_uniform(location, 1, &v0, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_FLOAT, 1);
d164 1
a164 1
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_FLOAT, 2);
d175 1
a175 1
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_FLOAT, 3);
d188 1
a188 1
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_FLOAT, 4);
d195 1
a195 1
   _mesa_uniform(location, 1, &v0, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT, 1);
d205 1
a205 1
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT, 2);
d216 1
a216 1
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT, 3);
d228 1
a228 1
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT, 4);
d235 1
a235 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_FLOAT, 1);
d242 1
a242 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_FLOAT, 2);
d249 1
a249 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_FLOAT, 3);
d256 1
a256 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_FLOAT, 4);
d263 1
a263 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT, 1);
d270 1
a270 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT, 2);
d277 1
a277 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT, 3);
d284 1
a284 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT, 4);
d295 1
a295 1
   _mesa_uniform(location, 1, &v0, ctx, shProg, GLSL_TYPE_FLOAT, 1);
d307 1
a307 1
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_FLOAT, 2);
d321 1
a321 1
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_FLOAT, 3);
d336 1
a336 1
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_FLOAT, 4);
d346 1
a346 1
   _mesa_uniform(location, 1, &v0, ctx, shProg, GLSL_TYPE_INT, 1);
d358 1
a358 1
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_INT, 2);
d372 1
a372 1
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_INT, 3);
d387 1
a387 1
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_INT, 4);
d398 1
a398 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_FLOAT, 1);
d409 1
a409 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_FLOAT, 2);
d420 1
a420 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_FLOAT, 3);
d431 1
a431 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_FLOAT, 4);
d442 1
a442 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_INT, 1);
d453 1
a453 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_INT, 2);
d464 1
a464 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_INT, 3);
d475 1
a475 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_INT, 4);
d484 1
a484 1
   _mesa_uniform(location, 1, &v0, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT, 1);
d494 1
a494 1
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT, 2);
d505 1
a505 1
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT, 3);
d517 1
a517 1
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT, 4);
d524 1
a524 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT, 1);
d531 1
a531 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT, 2);
d538 1
a538 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT, 3);
d545 1
a545 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT, 4);
d555 2
a556 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 2, 2, GLSL_TYPE_FLOAT);
d564 2
a565 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 3, 3, GLSL_TYPE_FLOAT);
d573 2
a574 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 4, 4, GLSL_TYPE_FLOAT);
d586 1
a586 1
   _mesa_uniform(location, 1, &v0, ctx, shProg, GLSL_TYPE_UINT, 1);
d599 1
a599 1
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_UINT, 2);
d614 1
a614 1
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_UINT, 3);
d629 1
a629 1
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_UINT, 4);
d640 1
a640 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_UINT, 1);
d651 1
a651 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_UINT, 2);
d662 1
a662 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_UINT, 3);
d673 1
a673 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_UINT, 4);
d686 1
a686 1
   _mesa_uniform_matrix(location, count, transpose, value, ctx, shProg, 2, 2, GLSL_TYPE_FLOAT);
d697 1
a697 1
   _mesa_uniform_matrix(location, count, transpose, value, ctx, shProg, 3, 3, GLSL_TYPE_FLOAT);
d708 1
a708 1
   _mesa_uniform_matrix(location, count, transpose, value, ctx, shProg, 4, 4, GLSL_TYPE_FLOAT);
d720 2
a721 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 2, 3, GLSL_TYPE_FLOAT);
d729 2
a730 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 3, 2, GLSL_TYPE_FLOAT);
d738 2
a739 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 2, 4, GLSL_TYPE_FLOAT);
d747 2
a748 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 4, 2, GLSL_TYPE_FLOAT);
d756 2
a757 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 3, 4, GLSL_TYPE_FLOAT);
d765 2
a766 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 4, 3, GLSL_TYPE_FLOAT);
d779 1
a779 1
   _mesa_uniform_matrix(location, count, transpose, value, ctx, shProg, 2, 3, GLSL_TYPE_FLOAT);
d790 1
a790 1
   _mesa_uniform_matrix(location, count, transpose, value, ctx, shProg, 3, 2, GLSL_TYPE_FLOAT);
d801 1
a801 1
   _mesa_uniform_matrix(location, count, transpose, value, ctx, shProg, 2, 4, GLSL_TYPE_FLOAT);
d812 1
a812 1
   _mesa_uniform_matrix(location, count, transpose, value, ctx, shProg, 4, 2, GLSL_TYPE_FLOAT);
d823 1
a823 1
   _mesa_uniform_matrix(location, count, transpose, value, ctx, shProg, 3, 4, GLSL_TYPE_FLOAT);
d834 1
a834 1
   _mesa_uniform_matrix(location, count, transpose, value, ctx, shProg, 4, 3, GLSL_TYPE_FLOAT);
a899 27
void GLAPIENTRY
_mesa_GetnUniformi64vARB(GLuint program, GLint location,
                         GLsizei bufSize, GLint64 *params)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_get_uniform(ctx, program, location, bufSize, GLSL_TYPE_INT64, params);
}
void GLAPIENTRY
_mesa_GetUniformi64vARB(GLuint program, GLint location, GLint64 *params)
{
   _mesa_GetnUniformi64vARB(program, location, INT_MAX, params);
}

void GLAPIENTRY
_mesa_GetnUniformui64vARB(GLuint program, GLint location,
                         GLsizei bufSize, GLuint64 *params)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_get_uniform(ctx, program, location, bufSize, GLSL_TYPE_UINT64, params);
}

void GLAPIENTRY
_mesa_GetUniformui64vARB(GLuint program, GLint location, GLuint64 *params)
{
   _mesa_GetnUniformui64vARB(program, location, INT_MAX, params);
}

d918 1
a918 1
   if (shProg->data->LinkStatus == linking_failure) {
d1005 1
a1005 1
   if (uniformBlockIndex >= shProg->data->NumUniformBlocks) {
d1008 1
a1008 1
                  uniformBlockIndex, shProg->data->NumUniformBlocks);
d1019 1
a1019 1
   if (shProg->data->UniformBlocks[uniformBlockIndex].Binding !=
d1025 1
a1025 2
      shProg->data->UniformBlocks[uniformBlockIndex].Binding =
         uniformBlockBinding;
d1047 1
a1047 1
   if (shaderStorageBlockIndex >= shProg->data->NumShaderStorageBlocks) {
d1050 1
a1050 2
                  shaderStorageBlockIndex,
                  shProg->data->NumShaderStorageBlocks);
d1062 1
a1062 1
   if (shProg->data->ShaderStorageBlocks[shaderStorageBlockIndex].Binding !=
d1068 1
a1068 1
      shProg->data->ShaderStorageBlocks[shaderStorageBlockIndex].Binding =
d1274 1
a1274 1
   _mesa_uniform(location, 1, &v0, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_DOUBLE, 1);
d1284 1
a1284 1
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_DOUBLE, 2);
d1295 1
a1295 1
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_DOUBLE, 3);
d1308 1
a1308 1
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_DOUBLE, 4);
d1315 1
a1315 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_DOUBLE, 1);
d1322 1
a1322 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_DOUBLE, 2);
d1329 1
a1329 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_DOUBLE, 3);
d1336 1
a1336 1
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_DOUBLE, 4);
d1344 2
a1345 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 2, 2, GLSL_TYPE_DOUBLE);
d1353 2
a1354 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 3, 3, GLSL_TYPE_DOUBLE);
d1362 2
a1363 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 4, 4, GLSL_TYPE_DOUBLE);
d1371 2
a1372 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 2, 3, GLSL_TYPE_DOUBLE);
d1380 2
a1381 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 3, 2, GLSL_TYPE_DOUBLE);
d1389 2
a1390 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 2, 4, GLSL_TYPE_DOUBLE);
d1398 2
a1399 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 4, 2, GLSL_TYPE_DOUBLE);
d1407 2
a1408 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 3, 4, GLSL_TYPE_DOUBLE);
d1416 2
a1417 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, ctx->_Shader->ActiveProgram, 4, 3, GLSL_TYPE_DOUBLE);
d1427 1
a1427 1
   _mesa_uniform(location, 1, &v0, ctx, shProg, GLSL_TYPE_DOUBLE, 1);
d1439 1
a1439 1
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_DOUBLE, 2);
d1453 1
a1453 1
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_DOUBLE, 3);
d1468 1
a1468 1
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_DOUBLE, 4);
d1479 1
a1479 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_DOUBLE, 1);
d1490 1
a1490 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_DOUBLE, 2);
d1501 1
a1501 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_DOUBLE, 3);
d1512 1
a1512 1
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_DOUBLE, 4);
d1523 1
a1523 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, shProg, 2, 2, GLSL_TYPE_DOUBLE);
d1534 1
a1534 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, shProg, 3, 3, GLSL_TYPE_DOUBLE);
d1545 1
a1545 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, shProg, 4, 4, GLSL_TYPE_DOUBLE);
d1556 1
a1556 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, shProg, 2, 3, GLSL_TYPE_DOUBLE);
d1567 1
a1567 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, shProg, 3, 2, GLSL_TYPE_DOUBLE);
d1578 1
a1578 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, shProg, 2, 4, GLSL_TYPE_DOUBLE);
d1589 1
a1589 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, shProg, 4, 2, GLSL_TYPE_DOUBLE);
d1600 1
a1600 2
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, shProg, 3, 4, GLSL_TYPE_DOUBLE);
d1611 1
a1611 323
   _mesa_uniform_matrix(location, count, transpose, value,
                        ctx, shProg, 4, 3, GLSL_TYPE_DOUBLE);
}

void GLAPIENTRY
_mesa_Uniform1i64ARB(GLint location, GLint64 v0)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(location, 1, &v0, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT64, 1);
}

void GLAPIENTRY
_mesa_Uniform2i64ARB(GLint location, GLint64 v0, GLint64 v1)
{
   GET_CURRENT_CONTEXT(ctx);
   int64_t v[2];
   v[0] = v0;
   v[1] = v1;
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT64, 2);
}

void GLAPIENTRY
_mesa_Uniform3i64ARB(GLint location, GLint64 v0, GLint64 v1, GLint64 v2)
{
   GET_CURRENT_CONTEXT(ctx);
   int64_t v[3];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT64, 3);
}

void GLAPIENTRY
_mesa_Uniform4i64ARB(GLint location,  GLint64 v0, GLint64 v1, GLint64 v2, GLint64 v3)
{
   GET_CURRENT_CONTEXT(ctx);
   int64_t v[4];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT64, 4);
}

void GLAPIENTRY
_mesa_Uniform1i64vARB(GLint location, GLsizei count, const GLint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT64, 1);
}

void GLAPIENTRY
_mesa_Uniform2i64vARB(GLint location,  GLsizei count, const GLint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT64, 2);
}

void GLAPIENTRY
_mesa_Uniform3i64vARB(GLint location,  GLsizei count, const GLint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT64, 3);
}

void GLAPIENTRY
_mesa_Uniform4i64vARB(GLint location,  GLsizei count, const GLint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_INT64, 4);
}

void GLAPIENTRY
_mesa_Uniform1ui64ARB(GLint location,  GLuint64 v0)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(location, 1, &v0, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT64, 1);
}

void GLAPIENTRY
_mesa_Uniform2ui64ARB(GLint location,  GLuint64 v0, GLuint64 v1)
{
   GET_CURRENT_CONTEXT(ctx);
   uint64_t v[2];
   v[0] = v0;
   v[1] = v1;
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT64, 2);
}

void GLAPIENTRY
_mesa_Uniform3ui64ARB(GLint location, GLuint64 v0, GLuint64 v1, GLuint64 v2)
{
   GET_CURRENT_CONTEXT(ctx);
   uint64_t v[3];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT64, 3);
}

void GLAPIENTRY
_mesa_Uniform4ui64ARB(GLint location,  GLuint64 v0, GLuint64 v1, GLuint64 v2, GLuint64 v3)
{
   GET_CURRENT_CONTEXT(ctx);
   uint64_t v[4];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;
   _mesa_uniform(location, 1, v, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT64, 4);
}

void GLAPIENTRY
_mesa_Uniform1ui64vARB(GLint location,  GLsizei count, const GLuint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT64, 1);
}

void GLAPIENTRY
_mesa_Uniform2ui64vARB(GLint location,  GLsizei count, const GLuint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT64, 2);
}

void GLAPIENTRY
_mesa_Uniform3ui64vARB(GLint location,  GLsizei count, const GLuint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT64, 3);
}

void GLAPIENTRY
_mesa_Uniform4ui64vARB(GLint location,  GLsizei count, const GLuint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   _mesa_uniform(location, count, value, ctx, ctx->_Shader->ActiveProgram, GLSL_TYPE_UINT64, 4);
}

/* DSA entrypoints */
void GLAPIENTRY
_mesa_ProgramUniform1i64ARB(GLuint program, GLint location, GLint64 v0)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
            "glProgramUniform1i64ARB");
   _mesa_uniform(location, 1, &v0, ctx, shProg, GLSL_TYPE_INT64, 1);
}

void GLAPIENTRY
_mesa_ProgramUniform2i64ARB(GLuint program, GLint location, GLint64 v0, GLint64 v1)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform2i64ARB");
   int64_t v[2];
   v[0] = v0;
   v[1] = v1;
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_INT64, 2);
}

void GLAPIENTRY
_mesa_ProgramUniform3i64ARB(GLuint program, GLint location, GLint64 v0, GLint64 v1, GLint64 v2)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform3i64ARB");
   int64_t v[3];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_INT64, 3);
}

void GLAPIENTRY
_mesa_ProgramUniform4i64ARB(GLuint program, GLint location,  GLint64 v0, GLint64 v1, GLint64 v2, GLint64 v3)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform4i64ARB");
   int64_t v[4];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_INT64, 4);
}

void GLAPIENTRY
_mesa_ProgramUniform1i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform1i64vARB");
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_INT64, 1);
}

void GLAPIENTRY
_mesa_ProgramUniform2i64vARB(GLuint program, GLint location,  GLsizei count, const GLint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform2i64vARB");
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_INT64, 2);
}

void GLAPIENTRY
_mesa_ProgramUniform3i64vARB(GLuint program, GLint location,  GLsizei count, const GLint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform3i64vARB");
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_INT64, 3);
}

void GLAPIENTRY
_mesa_ProgramUniform4i64vARB(GLuint program, GLint location,  GLsizei count, const GLint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform4i64vARB");
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_INT64, 4);
}

void GLAPIENTRY
_mesa_ProgramUniform1ui64ARB(GLuint program, GLint location,  GLuint64 v0)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform1ui64ARB");
   _mesa_uniform(location, 1, &v0, ctx, shProg, GLSL_TYPE_UINT64, 1);
}

void GLAPIENTRY
_mesa_ProgramUniform2ui64ARB(GLuint program, GLint location,  GLuint64 v0, GLuint64 v1)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform2ui64ARB");
   uint64_t v[2];
   v[0] = v0;
   v[1] = v1;
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_UINT64, 2);
}

void GLAPIENTRY
_mesa_ProgramUniform3ui64ARB(GLuint program, GLint location, GLuint64 v0, GLuint64 v1, GLuint64 v2)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform3ui64ARB");
   uint64_t v[3];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_UINT64, 3);
}

void GLAPIENTRY
_mesa_ProgramUniform4ui64ARB(GLuint program, GLint location,  GLuint64 v0, GLuint64 v1, GLuint64 v2, GLuint64 v3)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform4ui64ARB");
   uint64_t v[4];
   v[0] = v0;
   v[1] = v1;
   v[2] = v2;
   v[3] = v3;
   _mesa_uniform(location, 1, v, ctx, shProg, GLSL_TYPE_UINT64, 4);
}

void GLAPIENTRY
_mesa_ProgramUniform1ui64vARB(GLuint program, GLint location,  GLsizei count, const GLuint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform1ui64vARB");
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_UINT64, 1);
}

void GLAPIENTRY
_mesa_ProgramUniform2ui64vARB(GLuint program, GLint location,  GLsizei count, const GLuint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform2ui64vARB");
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_UINT64, 2);
}

void GLAPIENTRY
_mesa_ProgramUniform3ui64vARB(GLuint program, GLint location,  GLsizei count, const GLuint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform3ui64vARB");
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_UINT64, 3);
}

void GLAPIENTRY
_mesa_ProgramUniform4ui64vARB(GLuint program, GLint location,  GLsizei count, const GLuint64 *value)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program,
                                      "glProgramUniform4ui64vARB");
   _mesa_uniform(location, count, value, ctx, shProg, GLSL_TYPE_UINT64, 4);
@


