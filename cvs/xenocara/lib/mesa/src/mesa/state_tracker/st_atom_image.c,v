head	1.2;
access;
symbols
	mesa-17_1_6:1.1.1.3
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	mesa-13_0_6:1.1.1.2
	mesa-13_0_5:1.1.1.2
	mesa-13_0_3:1.1.1.2
	mesa-13_0_2:1.1.1.2
	OPENBSD_6_0:1.1.1.1.0.4
	OPENBSD_6_0_BASE:1.1.1.1
	mesa-11_2_2:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.08.26.16.59.40;	author jsg;	state Exp;
branches;
next	1.1;
commitid	D0k2io1oY8gcsQ2S;

1.1
date	2016.05.29.10.13.27;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.1
date	2016.05.29.10.13.27;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.2
date	2016.12.11.08.38.07;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	uuv5VTS15jglEDZU;

1.1.1.3
date	2017.08.14.09.43.32;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.2
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/**************************************************************************
 *
 * Copyright 2016 Ilia Mirkin. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "main/imports.h"
#include "main/shaderimage.h"
#include "program/prog_parameter.h"
#include "program/prog_print.h"
#include "compiler/glsl/ir_uniform.h"

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "util/u_surface.h"
#include "cso_cache/cso_context.h"

#include "st_cb_texture.h"
#include "st_debug.h"
#include "st_texture.h"
#include "st_context.h"
#include "st_atom.h"
#include "st_program.h"
#include "st_format.h"

static void
st_bind_images(struct st_context *st, struct gl_linked_shader *shader,
              enum pipe_shader_type shader_type)
{
   unsigned i;
   struct pipe_image_view images[MAX_IMAGE_UNIFORMS];
   struct gl_program_constants *c;

   if (!shader || !st->pipe->set_shader_images)
      return;

   c = &st->ctx->Const.Program[shader->Stage];

   for (i = 0; i < shader->NumImages; i++) {
      struct gl_image_unit *u = &st->ctx->ImageUnits[shader->ImageUnits[i]];
      struct st_texture_object *stObj = st_texture_object(u->TexObj);
      struct pipe_image_view *img = &images[i];

      if (!_mesa_is_image_unit_valid(st->ctx, u) ||
          !st_finalize_texture(st->ctx, st->pipe, u->TexObj) ||
          !stObj->pt) {
         memset(img, 0, sizeof(*img));
         continue;
      }

      img->resource = stObj->pt;
      img->format = st_mesa_format_to_pipe_format(st, u->_ActualFormat);

      switch (u->Access) {
      case GL_READ_ONLY:
         img->access = PIPE_IMAGE_ACCESS_READ;
         break;
      case GL_WRITE_ONLY:
         img->access = PIPE_IMAGE_ACCESS_WRITE;
         break;
      case GL_READ_WRITE:
         img->access = PIPE_IMAGE_ACCESS_READ_WRITE;
         break;
      default:
         unreachable("bad gl_image_unit::Access");
      }

      if (stObj->pt->target == PIPE_BUFFER) {
         unsigned base, size;

         base = stObj->base.BufferOffset;
         assert(base < stObj->pt->width0);
         size = MIN2(stObj->pt->width0 - base, (unsigned)stObj->base.BufferSize);

         img->u.buf.offset = base;
         img->u.buf.size = size;
      } else {
         img->u.tex.level = u->Level + stObj->base.MinLevel;
         if (stObj->pt->target == PIPE_TEXTURE_3D) {
            if (u->Layered) {
               img->u.tex.first_layer = 0;
               img->u.tex.last_layer = u_minify(stObj->pt->depth0, img->u.tex.level) - 1;
            } else {
               img->u.tex.first_layer = u->_Layer;
               img->u.tex.last_layer = u->_Layer;
            }
         } else {
            img->u.tex.first_layer = u->_Layer + stObj->base.MinLayer;
            img->u.tex.last_layer = u->_Layer + stObj->base.MinLayer;
            if (u->Layered && img->resource->array_size > 1) {
               if (stObj->base.Immutable)
                  img->u.tex.last_layer += stObj->base.NumLayers - 1;
               else
                  img->u.tex.last_layer += img->resource->array_size - 1;
            }
         }
      }
   }
   cso_set_shader_images(st->cso_context, shader_type, 0, shader->NumImages,
                         images);
   /* clear out any stale shader images */
   if (shader->NumImages < c->MaxImageUniforms)
      cso_set_shader_images(
            st->cso_context, shader_type,
            shader->NumImages,
            c->MaxImageUniforms - shader->NumImages,
            NULL);
}

static void bind_vs_images(struct st_context *st)
{
   struct gl_shader_program *prog =
      st->ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];

   if (!prog)
      return;

   st_bind_images(st, prog->_LinkedShaders[MESA_SHADER_VERTEX], PIPE_SHADER_VERTEX);
}

const struct st_tracked_state st_bind_vs_images = {
   bind_vs_images
};

static void bind_fs_images(struct st_context *st)
{
   struct gl_shader_program *prog =
      st->ctx->_Shader->CurrentProgram[MESA_SHADER_FRAGMENT];

   if (!prog)
      return;

   st_bind_images(st, prog->_LinkedShaders[MESA_SHADER_FRAGMENT], PIPE_SHADER_FRAGMENT);
}

const struct st_tracked_state st_bind_fs_images = {
   bind_fs_images
};

static void bind_gs_images(struct st_context *st)
{
   struct gl_shader_program *prog =
      st->ctx->_Shader->CurrentProgram[MESA_SHADER_GEOMETRY];

   if (!prog)
      return;

   st_bind_images(st, prog->_LinkedShaders[MESA_SHADER_GEOMETRY], PIPE_SHADER_GEOMETRY);
}

const struct st_tracked_state st_bind_gs_images = {
   bind_gs_images
};

static void bind_tcs_images(struct st_context *st)
{
   struct gl_shader_program *prog =
      st->ctx->_Shader->CurrentProgram[MESA_SHADER_TESS_CTRL];

   if (!prog)
      return;

   st_bind_images(st, prog->_LinkedShaders[MESA_SHADER_TESS_CTRL], PIPE_SHADER_TESS_CTRL);
}

const struct st_tracked_state st_bind_tcs_images = {
   bind_tcs_images
};

static void bind_tes_images(struct st_context *st)
{
   struct gl_shader_program *prog =
      st->ctx->_Shader->CurrentProgram[MESA_SHADER_TESS_EVAL];

   if (!prog)
      return;

   st_bind_images(st, prog->_LinkedShaders[MESA_SHADER_TESS_EVAL], PIPE_SHADER_TESS_EVAL);
}

const struct st_tracked_state st_bind_tes_images = {
   bind_tes_images
};

static void bind_cs_images(struct st_context *st)
{
   struct gl_shader_program *prog =
      st->ctx->_Shader->CurrentProgram[MESA_SHADER_COMPUTE];

   if (!prog)
      return;

   st_bind_images(st, prog->_LinkedShaders[MESA_SHADER_COMPUTE], PIPE_SHADER_COMPUTE);
}

const struct st_tracked_state st_bind_cs_images = {
   bind_cs_images
};
@


1.1
log
@Initial revision
@
text
@d28 1
d37 1
d48 2
a49 2
st_bind_images(struct st_context *st, struct gl_shader *shader,
              unsigned shader_type)
d53 1
a53 1
   struct gl_program_constants *c = &st->ctx->Const.Program[shader->Stage];
d58 2
d65 1
a65 1
      if (!stObj ||
d74 15
a90 3
         unsigned f, n;
         const struct util_format_description *desc
            = util_format_description(img->format);
d96 2
a97 5
         f = (base / (desc->block.bits / 8)) * desc->block.width;
         n = (size / (desc->block.bits / 8)) * desc->block.width;
         assert(n > 0);
         img->u.buf.first_element = f;
         img->u.buf.last_element  = f + (n - 1);
d120 2
a121 2
   st->pipe->set_shader_images(st->pipe, shader_type, 0, shader->NumImages,
                               images);
d124 2
a125 2
      st->pipe->set_shader_images(
            st->pipe, shader_type,
a142 5
   "st_bind_vs_images",
   {
      0,
      ST_NEW_VERTEX_PROGRAM | ST_NEW_IMAGE_UNITS,
   },
a157 5
   "st_bind_fs_images",
   {
      0,
      ST_NEW_FRAGMENT_PROGRAM | ST_NEW_IMAGE_UNITS,
   },
a172 5
   "st_bind_gs_images",
   {
      0,
      ST_NEW_GEOMETRY_PROGRAM | ST_NEW_IMAGE_UNITS,
   },
a187 5
   "st_bind_tcs_images",
   {
      0,
      ST_NEW_TESSCTRL_PROGRAM | ST_NEW_IMAGE_UNITS,
   },
a202 5
   "st_bind_tes_images",
   {
      0,
      ST_NEW_TESSEVAL_PROGRAM | ST_NEW_IMAGE_UNITS,
   },
a217 5
   "st_bind_cs_images",
   {
      0,
      ST_NEW_COMPUTE_PROGRAM | ST_NEW_IMAGE_UNITS,
   },
@


1.1.1.1
log
@Import Mesa 11.2.2
@
text
@@


1.1.1.2
log
@Import Mesa 13.0.2
@
text
@a27 1
#include "main/shaderimage.h"
a35 1
#include "cso_cache/cso_context.h"
d46 2
a47 2
st_bind_images(struct st_context *st, struct gl_linked_shader *shader,
              enum pipe_shader_type shader_type)
d51 1
a51 1
   struct gl_program_constants *c;
a55 2
   c = &st->ctx->Const.Program[shader->Stage];

d61 1
a61 1
      if (!_mesa_is_image_unit_valid(st->ctx, u) ||
a69 15

      switch (u->Access) {
      case GL_READ_ONLY:
         img->access = PIPE_IMAGE_ACCESS_READ;
         break;
      case GL_WRITE_ONLY:
         img->access = PIPE_IMAGE_ACCESS_WRITE;
         break;
      case GL_READ_WRITE:
         img->access = PIPE_IMAGE_ACCESS_READ_WRITE;
         break;
      default:
         unreachable("bad gl_image_unit::Access");
      }

d72 3
d80 5
a84 2
         img->u.buf.offset = base;
         img->u.buf.size = size;
d107 2
a108 2
   cso_set_shader_images(st->cso_context, shader_type, 0, shader->NumImages,
                         images);
d111 2
a112 2
      cso_set_shader_images(
            st->cso_context, shader_type,
d130 5
d150 5
d170 5
d190 5
d210 5
d230 5
@


1.1.1.3
log
@Import Mesa 17.1.6
@
text
@a46 58
/**
 * Convert a gl_image_unit object to a pipe_image_view object.
 */
void
st_convert_image(const struct st_context *st, const struct gl_image_unit *u,
                 struct pipe_image_view *img)
{
   struct st_texture_object *stObj = st_texture_object(u->TexObj);

   img->resource = stObj->pt;
   img->format = st_mesa_format_to_pipe_format(st, u->_ActualFormat);

   switch (u->Access) {
   case GL_READ_ONLY:
      img->access = PIPE_IMAGE_ACCESS_READ;
      break;
   case GL_WRITE_ONLY:
      img->access = PIPE_IMAGE_ACCESS_WRITE;
      break;
   case GL_READ_WRITE:
      img->access = PIPE_IMAGE_ACCESS_READ_WRITE;
      break;
   default:
      unreachable("bad gl_image_unit::Access");
   }

   if (stObj->pt->target == PIPE_BUFFER) {
      unsigned base, size;

      base = stObj->base.BufferOffset;
      assert(base < stObj->pt->width0);
      size = MIN2(stObj->pt->width0 - base, (unsigned)stObj->base.BufferSize);

      img->u.buf.offset = base;
      img->u.buf.size = size;
   } else {
      img->u.tex.level = u->Level + stObj->base.MinLevel;
      if (stObj->pt->target == PIPE_TEXTURE_3D) {
         if (u->Layered) {
            img->u.tex.first_layer = 0;
            img->u.tex.last_layer = u_minify(stObj->pt->depth0, img->u.tex.level) - 1;
         } else {
            img->u.tex.first_layer = u->_Layer;
            img->u.tex.last_layer = u->_Layer;
         }
      } else {
         img->u.tex.first_layer = u->_Layer + stObj->base.MinLayer;
         img->u.tex.last_layer = u->_Layer + stObj->base.MinLayer;
         if (u->Layered && img->resource->array_size > 1) {
            if (stObj->base.Immutable)
               img->u.tex.last_layer += stObj->base.NumLayers - 1;
            else
               img->u.tex.last_layer += img->resource->array_size - 1;
         }
      }
   }
}

d48 2
a49 2
st_bind_images(struct st_context *st, struct gl_program *prog,
               enum pipe_shader_type shader_type)
d55 1
a55 1
   if (!prog || !st->pipe->set_shader_images)
d58 1
a58 1
   c = &st->ctx->Const.Program[prog->info.stage];
d60 2
a61 3
   for (i = 0; i < prog->info.num_images; i++) {
      struct gl_image_unit *u =
         &st->ctx->ImageUnits[prog->sh.ImageUnits[i]];
d66 1
a66 1
          !st_finalize_texture(st->ctx, st->pipe, u->TexObj, 0) ||
d72 47
a118 1
      st_convert_image(st, u, img);
d120 2
a121 2
   cso_set_shader_images(st->cso_context, shader_type, 0,
                         prog->info.num_images, images);
d123 1
a123 1
   if (prog->info.num_images < c->MaxImageUniforms)
d125 4
a128 2
            st->cso_context, shader_type, prog->info.num_images,
            c->MaxImageUniforms - prog->info.num_images, NULL);
d133 1
a133 1
   struct gl_program *prog =
d136 4
a139 1
   st_bind_images(st, prog, PIPE_SHADER_VERTEX);
d148 1
a148 1
   struct gl_program *prog =
d151 4
a154 1
   st_bind_images(st, prog, PIPE_SHADER_FRAGMENT);
d163 1
a163 1
   struct gl_program *prog =
d166 4
a169 1
   st_bind_images(st, prog, PIPE_SHADER_GEOMETRY);
d178 1
a178 1
   struct gl_program *prog =
d181 4
a184 1
   st_bind_images(st, prog, PIPE_SHADER_TESS_CTRL);
d193 1
a193 1
   struct gl_program *prog =
d196 4
a199 1
   st_bind_images(st, prog, PIPE_SHADER_TESS_EVAL);
d208 1
a208 1
   struct gl_program *prog =
d211 4
a214 1
   st_bind_images(st, prog, PIPE_SHADER_COMPUTE);
@


