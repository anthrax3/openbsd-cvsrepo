head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.2
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.1.1.5.0.2
	OPENBSD_6_1_BASE:1.1.1.5
	mesa-13_0_6:1.1.1.5
	mesa-13_0_5:1.1.1.5
	mesa-13_0_3:1.1.1.5
	mesa-13_0_2:1.1.1.4
	OPENBSD_6_0:1.1.1.3.0.4
	OPENBSD_6_0_BASE:1.1.1.3
	mesa-11_2_2:1.1.1.3
	OPENBSD_5_9:1.1.1.2.0.2
	OPENBSD_5_9_BASE:1.1.1.2
	mesa-11_0_9:1.1.1.2
	mesa-11_0_8:1.1.1.2
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2017.08.26.16.59.37;	author jsg;	state Exp;
branches;
next	1.2;
commitid	D0k2io1oY8gcsQ2S;

1.2
date	2017.08.14.09.58.00;	author jsg;	state dead;
branches;
next	1.1;
commitid	bC4bLqwWTo4kLw82;

1.1
date	2015.11.22.02.39.58;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.39.58;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2015.12.23.13.21.59;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	bCnCUEGWDw3j16Q3;

1.1.1.3
date	2016.05.29.10.15.14;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.4
date	2016.12.11.08.37.03;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	uuv5VTS15jglEDZU;

1.1.1.5
date	2017.01.19.05.42.11;	author jsg;	state Exp;
branches;
next	;
commitid	vYSESphXPMoytdgU;


desc
@@


1.3
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#pragma once

#include "brw_shader.h"
#include "brw_ir_fs.h"
#include "brw_fs_builder.h"
#include "compiler/nir/nir.h"

struct bblock_t;
namespace {
   struct acp_entry;
}

namespace brw {
   class fs_live_variables;
}

struct brw_gs_compile;

static inline fs_reg
offset(const fs_reg &reg, const brw::fs_builder &bld, unsigned delta)
{
   return offset(reg, bld.dispatch_width(), delta);
}

/**
 * The fragment shader front-end.
 *
 * Translates either GLSL IR or Mesa IR (for ARB_fragment_program) into FS IR.
 */
class fs_visitor : public backend_shader
{
public:
   fs_visitor(const struct brw_compiler *compiler, void *log_data,
              void *mem_ctx,
              const void *key,
              struct brw_stage_prog_data *prog_data,
              struct gl_program *prog,
              const nir_shader *shader,
              unsigned dispatch_width,
              int shader_time_index,
              const struct brw_vue_map *input_vue_map = NULL);
   fs_visitor(const struct brw_compiler *compiler, void *log_data,
              void *mem_ctx,
              struct brw_gs_compile *gs_compile,
              struct brw_gs_prog_data *prog_data,
              const nir_shader *shader,
              int shader_time_index);
   void init();
   ~fs_visitor();

   fs_reg vgrf(const glsl_type *const type);
   void import_uniforms(fs_visitor *v);
   void setup_uniform_clipplane_values(gl_clip_plane *clip_planes);
   void compute_clip_distance(gl_clip_plane *clip_planes);

   fs_inst *get_instruction_generating_reg(fs_inst *start,
					   fs_inst *end,
					   const fs_reg &reg);

   void VARYING_PULL_CONSTANT_LOAD(const brw::fs_builder &bld,
                                   const fs_reg &dst,
                                   const fs_reg &surf_index,
                                   const fs_reg &varying_offset,
                                   uint32_t const_offset);
   void DEP_RESOLVE_MOV(const brw::fs_builder &bld, int grf);

   bool run_fs(bool allow_spilling, bool do_rep_send);
   bool run_vs(gl_clip_plane *clip_planes);
   bool run_tcs_single_patch();
   bool run_tes();
   bool run_gs();
   bool run_cs();
   void optimize();
   void allocate_registers(bool allow_spilling);
   void setup_fs_payload_gen4();
   void setup_fs_payload_gen6();
   void setup_vs_payload();
   void setup_gs_payload();
   void setup_cs_payload();
   void fixup_3src_null_dest();
   void assign_curb_setup();
   void calculate_urb_setup();
   void assign_urb_setup();
   void convert_attr_sources_to_hw_regs(fs_inst *inst);
   void assign_vs_urb_setup();
   void assign_tcs_single_patch_urb_setup();
   void assign_tes_urb_setup();
   void assign_gs_urb_setup();
   bool assign_regs(bool allow_spilling, bool spill_all);
   void assign_regs_trivial();
   void calculate_payload_ranges(int payload_node_count,
                                 int *payload_last_use_ip);
   void setup_payload_interference(struct ra_graph *g, int payload_reg_count,
                                   int first_payload_node);
   int choose_spill_reg(struct ra_graph *g);
   void spill_reg(int spill_reg);
   void split_virtual_grfs();
   bool compact_virtual_grfs();
   void assign_constant_locations();
   void lower_constant_loads();
   void invalidate_live_intervals();
   void calculate_live_intervals();
   void calculate_register_pressure();
   void validate();
   bool opt_algebraic();
   bool opt_redundant_discard_jumps();
   bool opt_cse();
   bool opt_cse_local(bblock_t *block);
   bool opt_copy_propagation();
   bool try_copy_propagate(fs_inst *inst, int arg, acp_entry *entry);
   bool try_constant_propagate(fs_inst *inst, acp_entry *entry);
   bool opt_copy_propagation_local(void *mem_ctx, bblock_t *block,
                                   exec_list *acp);
   bool opt_drop_redundant_mov_to_flags();
   bool opt_register_renaming();
   bool register_coalesce();
   bool compute_to_mrf();
   bool eliminate_find_live_channel();
   bool dead_code_eliminate();
   bool remove_duplicate_mrf_writes();

   bool opt_sampler_eot();
   bool virtual_grf_interferes(int a, int b);
   void schedule_instructions(instruction_scheduler_mode mode);
   void insert_gen4_send_dependency_workarounds();
   void insert_gen4_pre_send_dependency_workarounds(bblock_t *block,
                                                    fs_inst *inst);
   void insert_gen4_post_send_dependency_workarounds(bblock_t *block,
                                                     fs_inst *inst);
   void vfail(const char *msg, va_list args);
   void fail(const char *msg, ...);
   void limit_dispatch_width(unsigned n, const char *msg);
   void lower_uniform_pull_constant_loads();
   bool lower_load_payload();
   bool lower_pack();
   bool lower_d2x();
   bool lower_logical_sends();
   bool lower_integer_multiplication();
   bool lower_minmax();
   bool lower_simd_width();
   bool opt_combine_constants();

   void emit_dummy_fs();
   void emit_repclear_shader();
   void emit_fragcoord_interpolation(fs_reg wpos);
   fs_reg *emit_frontfacing_interpolation();
   fs_reg *emit_samplepos_setup();
   fs_reg *emit_sampleid_setup();
   fs_reg *emit_samplemaskin_setup();
   fs_reg *emit_vs_system_value(int location);
   void emit_interpolation_setup_gen4();
   void emit_interpolation_setup_gen6();
   void compute_sample_position(fs_reg dst, fs_reg int_sample_pos);
   fs_reg emit_mcs_fetch(const fs_reg &coordinate, unsigned components,
                         const fs_reg &sampler);
   void emit_gen6_gather_wa(uint8_t wa, fs_reg dst);
   fs_reg resolve_source_modifiers(const fs_reg &src);
   void emit_discard_jump();
   bool opt_peephole_sel();
   bool opt_peephole_predicated_break();
   bool opt_saturate_propagation();
   bool opt_cmod_propagation();
   bool opt_zero_samples();

   void emit_nir_code();
   void nir_setup_single_output_varying(fs_reg *reg, const glsl_type *type,
                                        unsigned *location);
   void nir_setup_outputs();
   void nir_setup_uniforms();
   void nir_emit_system_values();
   void nir_emit_impl(nir_function_impl *impl);
   void nir_emit_cf_list(exec_list *list);
   void nir_emit_if(nir_if *if_stmt);
   void nir_emit_loop(nir_loop *loop);
   void nir_emit_block(nir_block *block);
   void nir_emit_instr(nir_instr *instr);
   void nir_emit_alu(const brw::fs_builder &bld, nir_alu_instr *instr);
   void nir_emit_load_const(const brw::fs_builder &bld,
                            nir_load_const_instr *instr);
   void nir_emit_vs_intrinsic(const brw::fs_builder &bld,
                              nir_intrinsic_instr *instr);
   void nir_emit_tcs_intrinsic(const brw::fs_builder &bld,
                               nir_intrinsic_instr *instr);
   void nir_emit_gs_intrinsic(const brw::fs_builder &bld,
                              nir_intrinsic_instr *instr);
   void nir_emit_fs_intrinsic(const brw::fs_builder &bld,
                              nir_intrinsic_instr *instr);
   void nir_emit_cs_intrinsic(const brw::fs_builder &bld,
                              nir_intrinsic_instr *instr);
   void nir_emit_intrinsic(const brw::fs_builder &bld,
                           nir_intrinsic_instr *instr);
   void nir_emit_tes_intrinsic(const brw::fs_builder &bld,
                               nir_intrinsic_instr *instr);
   void nir_emit_ssbo_atomic(const brw::fs_builder &bld,
                             int op, nir_intrinsic_instr *instr);
   void nir_emit_shared_atomic(const brw::fs_builder &bld,
                               int op, nir_intrinsic_instr *instr);
   void nir_emit_texture(const brw::fs_builder &bld,
                         nir_tex_instr *instr);
   void nir_emit_jump(const brw::fs_builder &bld,
                      nir_jump_instr *instr);
   fs_reg get_nir_src(const nir_src &src);
   fs_reg get_nir_src_imm(const nir_src &src);
   fs_reg get_nir_dest(const nir_dest &dest);
   fs_reg get_nir_image_deref(const nir_deref_var *deref);
   fs_reg get_indirect_offset(nir_intrinsic_instr *instr);
   void emit_percomp(const brw::fs_builder &bld, const fs_inst &inst,
                     unsigned wr_mask);

   bool optimize_extract_to_float(nir_alu_instr *instr,
                                  const fs_reg &result);
   bool optimize_frontfacing_ternary(nir_alu_instr *instr,
                                     const fs_reg &result);

   void emit_alpha_test();
   fs_inst *emit_single_fb_write(const brw::fs_builder &bld,
                                 fs_reg color1, fs_reg color2,
                                 fs_reg src0_alpha, unsigned components);
   void emit_fb_writes();
   fs_inst *emit_non_coherent_fb_read(const brw::fs_builder &bld,
                                      const fs_reg &dst, unsigned target);
   void emit_urb_writes(const fs_reg &gs_vertex_count = fs_reg());
   void set_gs_stream_control_data_bits(const fs_reg &vertex_count,
                                        unsigned stream_id);
   void emit_gs_control_data_bits(const fs_reg &vertex_count);
   void emit_gs_end_primitive(const nir_src &vertex_count_nir_src);
   void emit_gs_vertex(const nir_src &vertex_count_nir_src,
                       unsigned stream_id);
   void emit_gs_thread_end();
   void emit_gs_input_load(const fs_reg &dst, const nir_src &vertex_src,
                           unsigned base_offset, const nir_src &offset_src,
                           unsigned num_components, unsigned first_component);
   void emit_cs_terminate();
   fs_reg *emit_cs_work_group_id_setup();

   void emit_barrier();

   void emit_shader_time_begin();
   void emit_shader_time_end();
   void SHADER_TIME_ADD(const brw::fs_builder &bld,
                        int shader_time_subindex,
                        fs_reg value);

   fs_reg get_timestamp(const brw::fs_builder &bld);

   struct brw_reg interp_reg(int location, int channel);

   int implied_mrf_writes(fs_inst *inst);

   virtual void dump_instructions();
   virtual void dump_instructions(const char *name);
   void dump_instruction(backend_instruction *inst);
   void dump_instruction(backend_instruction *inst, FILE *file);

   const void *const key;
   const struct brw_sampler_prog_key_data *key_tex;

   struct brw_gs_compile *gs_compile;

   struct brw_stage_prog_data *prog_data;
   struct gl_program *prog;

   const struct brw_vue_map *input_vue_map;

   int *virtual_grf_start;
   int *virtual_grf_end;
   brw::fs_live_variables *live_intervals;

   int *regs_live_at_ip;

   /** Number of uniform variable components visited. */
   unsigned uniforms;

   /** Byte-offset for the next available spot in the scratch space buffer. */
   unsigned last_scratch;

   /**
    * Array mapping UNIFORM register numbers to the pull parameter index,
    * or -1 if this uniform register isn't being uploaded as a pull constant.
    */
   int *pull_constant_loc;

   /**
    * Array mapping UNIFORM register numbers to the push parameter index,
    * or -1 if this uniform register isn't being uploaded as a push constant.
    */
   int *push_constant_loc;

   fs_reg frag_depth;
   fs_reg frag_stencil;
   fs_reg sample_mask;
   fs_reg outputs[VARYING_SLOT_MAX];
   fs_reg dual_src_output;
   int first_non_payload_grf;
   /** Either BRW_MAX_GRF or GEN7_MRF_HACK_START */
   unsigned max_grf;

   fs_reg *nir_locals;
   fs_reg *nir_ssa_values;
   fs_reg *nir_system_values;

   bool failed;
   char *fail_msg;

   /** Register numbers for thread payload fields. */
   struct thread_payload {
      uint8_t source_depth_reg;
      uint8_t source_w_reg;
      uint8_t aa_dest_stencil_reg;
      uint8_t dest_depth_reg;
      uint8_t sample_pos_reg;
      uint8_t sample_mask_in_reg;
      uint8_t barycentric_coord_reg[BRW_BARYCENTRIC_MODE_COUNT];
      uint8_t local_invocation_id_reg;

      /** The number of thread payload registers the hardware will supply. */
      uint8_t num_regs;
   } payload;

   bool source_depth_to_render_target;
   bool runtime_check_aads_emit;

   fs_reg pixel_x;
   fs_reg pixel_y;
   fs_reg wpos_w;
   fs_reg pixel_w;
   fs_reg delta_xy[BRW_BARYCENTRIC_MODE_COUNT];
   fs_reg shader_start_time;
   fs_reg userplane[MAX_CLIP_PLANES];
   fs_reg final_gs_vertex_count;
   fs_reg control_data_bits;
   fs_reg invocation_id;

   unsigned grf_used;
   bool spilled_any_registers;

   const unsigned dispatch_width; /**< 8, 16 or 32 */
   unsigned min_dispatch_width;
   unsigned max_dispatch_width;

   int shader_time_index;

   unsigned promoted_constants;
   brw::fs_builder bld;
};

/**
 * The fragment shader code generator.
 *
 * Translates FS IR to actual i965 assembly code.
 */
class fs_generator
{
public:
   fs_generator(const struct brw_compiler *compiler, void *log_data,
                void *mem_ctx,
                const void *key,
                struct brw_stage_prog_data *prog_data,
                unsigned promoted_constants,
                bool runtime_check_aads_emit,
                gl_shader_stage stage);
   ~fs_generator();

   void enable_debug(const char *shader_name);
   int generate_code(const cfg_t *cfg, int dispatch_width);
   const unsigned *get_assembly(unsigned int *assembly_size);

private:
   void fire_fb_write(fs_inst *inst,
                      struct brw_reg payload,
                      struct brw_reg implied_header,
                      GLuint nr);
   void generate_fb_write(fs_inst *inst, struct brw_reg payload);
   void generate_fb_read(fs_inst *inst, struct brw_reg dst,
                         struct brw_reg payload);
   void generate_urb_read(fs_inst *inst, struct brw_reg dst, struct brw_reg payload);
   void generate_urb_write(fs_inst *inst, struct brw_reg payload);
   void generate_cs_terminate(fs_inst *inst, struct brw_reg payload);
   void generate_barrier(fs_inst *inst, struct brw_reg src);
   void generate_linterp(fs_inst *inst, struct brw_reg dst,
			 struct brw_reg *src);
   void generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src,
                     struct brw_reg surface_index,
                     struct brw_reg sampler_index);
   void generate_get_buffer_size(fs_inst *inst, struct brw_reg dst,
                                 struct brw_reg src,
                                 struct brw_reg surf_index);
   void generate_ddx(enum opcode op, struct brw_reg dst, struct brw_reg src);
   void generate_ddy(enum opcode op, struct brw_reg dst, struct brw_reg src);
   void generate_scratch_write(fs_inst *inst, struct brw_reg src);
   void generate_scratch_read(fs_inst *inst, struct brw_reg dst);
   void generate_scratch_read_gen7(fs_inst *inst, struct brw_reg dst);
   void generate_uniform_pull_constant_load(fs_inst *inst, struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
   void generate_uniform_pull_constant_load_gen7(fs_inst *inst,
                                                 struct brw_reg dst,
                                                 struct brw_reg surf_index,
                                                 struct brw_reg offset);
   void generate_varying_pull_constant_load_gen4(fs_inst *inst,
                                                 struct brw_reg dst,
                                                 struct brw_reg index);
   void generate_varying_pull_constant_load_gen7(fs_inst *inst,
                                                 struct brw_reg dst,
                                                 struct brw_reg index,
                                                 struct brw_reg offset);
   void generate_mov_dispatch_to_flags(fs_inst *inst);

   void generate_pixel_interpolator_query(fs_inst *inst,
                                          struct brw_reg dst,
                                          struct brw_reg src,
                                          struct brw_reg msg_data,
                                          unsigned msg_type);

   void generate_set_sample_id(fs_inst *inst,
                               struct brw_reg dst,
                               struct brw_reg src0,
                               struct brw_reg src1);

   void generate_set_simd4x2_offset(fs_inst *inst,
                                    struct brw_reg dst,
                                    struct brw_reg offset);
   void generate_discard_jump(fs_inst *inst);

   void generate_pack_half_2x16_split(fs_inst *inst,
                                      struct brw_reg dst,
                                      struct brw_reg x,
                                      struct brw_reg y);
   void generate_unpack_half_2x16_split(fs_inst *inst,
                                        struct brw_reg dst,
                                        struct brw_reg src);

   void generate_shader_time_add(fs_inst *inst,
                                 struct brw_reg payload,
                                 struct brw_reg offset,
                                 struct brw_reg value);

   void generate_mov_indirect(fs_inst *inst,
                              struct brw_reg dst,
                              struct brw_reg reg,
                              struct brw_reg indirect_byte_offset);

   bool patch_discard_jumps_to_fb_writes();

   const struct brw_compiler *compiler;
   void *log_data; /* Passed to compiler->*_log functions */

   const struct gen_device_info *devinfo;

   struct brw_codegen *p;
   const void * const key;
   struct brw_stage_prog_data * const prog_data;

   unsigned dispatch_width; /**< 8, 16 or 32 */

   exec_list discard_halt_patches;
   unsigned promoted_constants;
   bool runtime_check_aads_emit;
   bool debug_flag;
   const char *shader_name;
   gl_shader_stage stage;
   void *mem_ctx;
};

bool brw_do_channel_expressions(struct exec_list *instructions);
bool brw_do_vector_splitting(struct exec_list *instructions);

void shuffle_32bit_load_result_to_64bit_data(const brw::fs_builder &bld,
                                             const fs_reg &dst,
                                             const fs_reg &src,
                                             uint32_t components);

void shuffle_64bit_data_for_32bit_write(const brw::fs_builder &bld,
                                        const fs_reg &dst,
                                        const fs_reg &src,
                                        uint32_t components);
fs_reg setup_imm_df(const brw::fs_builder &bld,
                    double v);

enum brw_barycentric_mode brw_barycentric_mode(enum glsl_interp_mode mode,
                                               nir_intrinsic_op op);
@


1.2
log
@Merge Mesa 17.1.6
@
text
@d33 1
a33 22

extern "C" {

#include <sys/types.h>

#include "main/macros.h"
#include "main/shaderobj.h"
#include "main/uniforms.h"
#include "program/prog_parameter.h"
#include "program/prog_print.h"
#include "program/prog_optimize.h"
#include "util/register_allocate.h"
#include "program/hash_table.h"
#include "brw_context.h"
#include "brw_eu.h"
#include "brw_wm.h"
#include "intel_asm_annotation.h"
}
#include "glsl/glsl_types.h"
#include "glsl/ir.h"
#include "glsl/nir/nir.h"
#include "program/sampler.h"
d44 2
d47 1
a47 1
offset(fs_reg reg, const brw::fs_builder& bld, unsigned delta)
d49 1
a49 16
   switch (reg.file) {
   case BAD_FILE:
      break;
   case GRF:
   case MRF:
   case HW_REG:
   case ATTR:
      return byte_offset(reg,
                         delta * reg.component_size(bld.dispatch_width()));
   case UNIFORM:
      reg.reg_offset += delta;
      break;
   case IMM:
      assert(delta == 0);
   }
   return reg;
a61 1
              gl_shader_stage stage,
a63 1
              struct gl_shader_program *shader_prog,
d65 1
d67 7
d75 1
a75 1

a82 5
   uint32_t gather_channel(int orig_chan, uint32_t sampler);
   void swizzle_result(ir_texture_opcode op, int dest_components,
                       fs_reg orig_val, uint32_t sampler);

   int type_size(const struct glsl_type *type);
d94 1
a94 1
   bool run_fs(bool do_rep_send);
d96 3
d101 3
a103 4
   void allocate_registers();
   void assign_binding_table_offsets();
   void setup_payload_gen4();
   void setup_payload_gen6();
d105 1
d111 1
d113 4
a116 1
   bool assign_regs(bool allow_spilling);
d118 2
a125 1
   void move_uniform_array_access_to_pull_constants();
d127 1
a127 1
   void demote_pull_constants();
d131 1
d136 1
a136 1
   bool opt_copy_propagate();
d139 3
a141 2
   bool opt_copy_propagate_local(void *mem_ctx, bblock_t *block,
                                 exec_list *acp);
d159 1
a159 1
   void no16(const char *msg);
d162 2
d166 1
d172 1
a172 5
   fs_reg *emit_fragcoord_interpolation(bool pixel_center_integer,
                                        bool origin_upper_left);
   fs_inst *emit_linterp(const fs_reg &attr, const fs_reg &interp,
                         glsl_interp_qualifier interpolation_mode,
                         bool is_centroid, bool is_sample);
d176 1
a176 5
   void emit_general_interpolation(fs_reg attr, const char *name,
                                   const glsl_type *type,
                                   glsl_interp_qualifier interpolation_mode,
                                   int location, bool mod_centroid,
                                   bool mod_sample);
a180 16
   fs_reg rescale_texcoord(fs_reg coordinate, int coord_components,
                           bool is_rect, uint32_t sampler, int texunit);
   void emit_texture(ir_texture_opcode op,
                     const glsl_type *dest_type,
                     fs_reg coordinate, int components,
                     fs_reg shadow_c,
                     fs_reg lod, fs_reg dpdy, int grad_components,
                     fs_reg sample_index,
                     fs_reg offset,
                     fs_reg mcs,
                     int gather_component,
                     bool is_cube_array,
                     bool is_rect,
                     uint32_t sampler,
                     fs_reg sampler_reg,
                     int texunit);
a185 1
   bool try_replace_with_sel();
a190 4
   void emit_unspill(bblock_t *block, fs_inst *inst, fs_reg reg,
                     uint32_t spill_offset, int count);
   void emit_spill(bblock_t *block, fs_inst *inst, fs_reg reg,
                   uint32_t spill_offset, int count);
d193 5
a197 6
   void nir_setup_inputs(nir_shader *shader);
   void nir_setup_outputs(nir_shader *shader);
   void nir_setup_uniforms(nir_shader *shader);
   void nir_setup_uniform(nir_variable *var);
   void nir_setup_builtin_uniform(nir_variable *var);
   void nir_emit_system_values(nir_shader *shader);
d207 10
a216 2
   void nir_emit_undef(const brw::fs_builder &bld,
                       nir_ssa_undef_instr *instr);
d219 6
d229 3
a231 2
   fs_reg get_nir_src(nir_src src);
   fs_reg get_nir_dest(nir_dest dest);
d233 1
d237 2
d247 13
a259 1
   void emit_urb_writes();
d261 1
a274 3
   virtual void setup_vector_uniform_values(const gl_constant_value *values,
                                            unsigned n);

d285 2
d288 1
a288 1
   unsigned int sanity_param_count;
d290 1
a290 1
   int *param_size;
a300 3
   /** Total number of direct uniforms we can get from NIR */
   unsigned num_direct_uniforms;

d317 1
a319 1
   unsigned output_components[VARYING_SLOT_MAX];
a320 1
   bool do_dual_src;
a326 2
   fs_reg nir_inputs;
   fs_reg nir_outputs;
a330 5
   bool simd16_unsupported;
   char *no16_msg;

   /* Result of last visit() method. Still used by emit_texture() */
   fs_reg result;
d340 2
a341 1
      uint8_t barycentric_coord_reg[BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT];
d354 1
a354 1
   fs_reg delta_xy[BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT];
d357 3
d364 3
a366 1
   const unsigned dispatch_width; /**< 8 or 16 */
a385 1
                struct gl_program *fp,
d388 1
a388 1
                const char *stage_abbrev);
d401 3
a406 1
   void generate_blorp_fb_write(fs_inst *inst);
d410 1
d412 3
a414 10
   void generate_math_gen6(fs_inst *inst,
                           struct brw_reg dst,
                           struct brw_reg src0,
                           struct brw_reg src1);
   void generate_math_gen4(fs_inst *inst,
			   struct brw_reg dst,
			   struct brw_reg src);
   void generate_math_g45(fs_inst *inst,
			  struct brw_reg dst,
			  struct brw_reg src);
d416 1
a416 2
   void generate_ddy(enum opcode op, struct brw_reg dst, struct brw_reg src,
                     bool negate_value);
d427 3
a429 3
   void generate_varying_pull_constant_load(fs_inst *inst, struct brw_reg dst,
                                            struct brw_reg index,
                                            struct brw_reg offset);
d465 5
d475 1
a475 1
   const struct brw_device_info *devinfo;
d481 1
a481 3
   const struct gl_program *prog;

   unsigned dispatch_width; /**< 8 or 16 */
d488 1
a488 1
   const char *stage_abbrev;
d494 15
a508 3
void brw_setup_tex_for_precompile(struct brw_context *brw,
                                  struct brw_sampler_prog_key_data *tex,
                                  struct gl_program *prog);
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.0.8

This seems to fix some of the problems with clutter/gnome reported to
occur on r600 with 11.0.6
@
text
@d200 1
a200 1
   void emit_general_interpolation(fs_reg *attr, const char *name,
d203 1
a203 1
                                   int *location, bool mod_centroid,
a242 2
   void nir_setup_single_output_varying(fs_reg &reg, const glsl_type *type,
                                        unsigned &location);
@


1.1.1.3
log
@Import Mesa 11.2.2
@
text
@d33 22
a54 2
#include "compiler/glsl/ir.h"
#include "compiler/nir/nir.h"
a64 2
struct brw_gs_compile;

d71 1
a71 2
   case ARF:
   case FIXED_GRF:
d73 1
a73 1
   case VGRF:
d96 1
d99 1
a100 1
              const nir_shader *shader,
a101 7
              int shader_time_index,
              const struct brw_vue_map *input_vue_map = NULL);
   fs_visitor(const struct brw_compiler *compiler, void *log_data,
              void *mem_ctx,
              struct brw_gs_compile *gs_compile,
              struct brw_gs_prog_data *prog_data,
              const nir_shader *shader,
d103 1
a103 1
   void init();
d111 5
a128 2
   bool run_tes();
   bool run_gs();
d132 3
a134 2
   void setup_fs_payload_gen4();
   void setup_fs_payload_gen6();
a135 1
   void setup_gs_payload();
a140 1
   void convert_attr_sources_to_hw_regs(fs_inst *inst);
a141 2
   void assign_tes_urb_setup();
   void assign_gs_urb_setup();
a143 2
   void calculate_payload_ranges(int payload_node_count,
                                 int *payload_last_use_ip);
d150 1
a155 1
   void validate();
a186 1
   bool lower_minmax();
d209 2
d221 1
a221 2
                     uint32_t surface,
                     fs_reg surface_reg,
d223 2
a224 1
                     fs_reg sampler_reg);
d230 1
d242 8
a249 6
   void nir_setup_inputs();
   void nir_setup_single_output_varying(fs_reg *reg, const glsl_type *type,
                                        unsigned *location);
   void nir_setup_outputs();
   void nir_setup_uniforms();
   void nir_emit_system_values();
a260 8
   void nir_emit_vs_intrinsic(const brw::fs_builder &bld,
                              nir_intrinsic_instr *instr);
   void nir_emit_gs_intrinsic(const brw::fs_builder &bld,
                              nir_intrinsic_instr *instr);
   void nir_emit_fs_intrinsic(const brw::fs_builder &bld,
                              nir_intrinsic_instr *instr);
   void nir_emit_cs_intrinsic(const brw::fs_builder &bld,
                              nir_intrinsic_instr *instr);
a262 6
   void nir_emit_tes_intrinsic(const brw::fs_builder &bld,
                               nir_intrinsic_instr *instr);
   void nir_emit_ssbo_atomic(const brw::fs_builder &bld,
                             int op, nir_intrinsic_instr *instr);
   void nir_emit_shared_atomic(const brw::fs_builder &bld,
                               int op, nir_intrinsic_instr *instr);
a269 1
   fs_reg get_indirect_offset(nir_intrinsic_instr *instr);
d281 1
a281 11
   void emit_urb_writes(const fs_reg &gs_vertex_count = fs_reg());
   void set_gs_stream_control_data_bits(const fs_reg &vertex_count,
                                        unsigned stream_id);
   void emit_gs_control_data_bits(const fs_reg &vertex_count);
   void emit_gs_end_primitive(const nir_src &vertex_count_nir_src);
   void emit_gs_vertex(const nir_src &vertex_count_nir_src,
                       unsigned stream_id);
   void emit_gs_thread_end();
   void emit_gs_input_load(const fs_reg &dst, const nir_src &vertex_src,
                           unsigned base_offset, const nir_src &offset_src,
                           unsigned num_components);
a282 2
   fs_reg *emit_cs_local_invocation_id_setup();
   fs_reg *emit_cs_work_group_id_setup();
d296 3
a308 2
   struct brw_gs_compile *gs_compile;

d310 1
a310 3
   struct gl_program *prog;

   const struct brw_vue_map *input_vue_map;
d323 3
a341 1
   fs_reg frag_stencil;
a373 1
      uint8_t local_invocation_id_reg;
a388 2
   fs_reg final_gs_vertex_count;
   fs_reg control_data_bits;
a393 1
   unsigned min_dispatch_width;
d413 1
d416 1
a416 1
                gl_shader_stage stage);
a428 1
   void generate_urb_read(fs_inst *inst, struct brw_reg dst, struct brw_reg payload);
a430 2
   void generate_stencil_ref_packing(fs_inst *inst, struct brw_reg dst,
                                     struct brw_reg src);
a435 1
                     struct brw_reg surface_index,
a436 3
   void generate_get_buffer_size(fs_inst *inst, struct brw_reg dst,
                                 struct brw_reg src,
                                 struct brw_reg surf_index);
a497 5
   void generate_mov_indirect(fs_inst *inst,
                              struct brw_reg dst,
                              struct brw_reg reg,
                              struct brw_reg indirect_byte_offset);

d509 2
d518 1
a518 1
   gl_shader_stage stage;
d524 3
@


1.1.1.4
log
@Import Mesa 13.0.2
@
text
@d33 1
d48 1
a48 1
offset(const fs_reg &reg, const brw::fs_builder &bld, unsigned delta)
d50 17
a66 1
   return offset(reg, bld.dispatch_width(), delta);
d111 1
a111 1
   bool run_fs(bool allow_spilling, bool do_rep_send);
a112 1
   bool run_tcs_single_patch();
d117 1
a117 1
   void allocate_registers(bool allow_spilling);
a128 1
   void assign_tcs_single_patch_urb_setup();
d131 1
a131 1
   bool assign_regs(bool allow_spilling, bool spill_all);
d142 1
a142 1
   void lower_constant_loads();
a155 1
   bool opt_drop_redundant_mov_to_flags();
d173 1
a173 1
   void limit_dispatch_width(unsigned n, const char *msg);
a175 2
   bool lower_pack();
   bool lower_d2x();
d184 5
a188 1
   void emit_fragcoord_interpolation(fs_reg wpos);
d192 5
a196 1
   fs_reg *emit_samplemaskin_setup();
d201 14
d225 4
d231 1
d246 2
a249 2
   void nir_emit_tcs_intrinsic(const brw::fs_builder &bld,
                               nir_intrinsic_instr *instr);
d268 2
a269 3
   fs_reg get_nir_src(const nir_src &src);
   fs_reg get_nir_src_imm(const nir_src &src);
   fs_reg get_nir_dest(const nir_dest &dest);
a274 2
   bool optimize_extract_to_float(nir_alu_instr *instr,
                                  const fs_reg &result);
a282 2
   fs_inst *emit_non_coherent_fb_read(const brw::fs_builder &bld,
                                      const fs_reg &dst, unsigned target);
d293 1
a293 1
                           unsigned num_components, unsigned first_component);
d295 1
d327 2
d357 1
d359 1
d366 2
d372 5
d386 1
a386 1
      uint8_t barycentric_coord_reg[BRW_BARYCENTRIC_MODE_COUNT];
d400 1
a400 1
   fs_reg delta_xy[BRW_BARYCENTRIC_MODE_COUNT];
a404 1
   fs_reg invocation_id;
d409 1
a409 1
   const unsigned dispatch_width; /**< 8, 16 or 32 */
a410 1
   unsigned max_dispatch_width;
a444 2
   void generate_fb_read(fs_inst *inst, struct brw_reg dst,
                         struct brw_reg payload);
d448 2
d451 1
d460 10
d471 2
a472 1
   void generate_ddy(enum opcode op, struct brw_reg dst, struct brw_reg src);
d483 3
a485 3
   void generate_varying_pull_constant_load_gen4(fs_inst *inst,
                                                 struct brw_reg dst,
                                                 struct brw_reg index);
d531 1
a531 1
   const struct gen_device_info *devinfo;
d537 1
a537 1
   unsigned dispatch_width; /**< 8, 16 or 32 */
a549 15

void shuffle_32bit_load_result_to_64bit_data(const brw::fs_builder &bld,
                                             const fs_reg &dst,
                                             const fs_reg &src,
                                             uint32_t components);

void shuffle_64bit_data_for_32bit_write(const brw::fs_builder &bld,
                                        const fs_reg &dst,
                                        const fs_reg &src,
                                        uint32_t components);
fs_reg setup_imm_df(const brw::fs_builder &bld,
                    double v);

enum brw_barycentric_mode brw_barycentric_mode(enum glsl_interp_mode mode,
                                               nir_intrinsic_op op);
@


1.1.1.5
log
@Import Mesa 13.0.3
@
text
@d136 1
a136 1
   bool opt_copy_propagation();
d139 2
a140 2
   bool opt_copy_propagation_local(void *mem_ctx, bblock_t *block,
                                   exec_list *acp);
@


