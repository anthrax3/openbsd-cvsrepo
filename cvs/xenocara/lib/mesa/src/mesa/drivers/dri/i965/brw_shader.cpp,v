head	1.3;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.3
date	2017.08.26.16.59.37;	author jsg;	state Exp;
branches;
next	1.2;
commitid	D0k2io1oY8gcsQ2S;

1.2
date	2017.08.14.09.58.01;	author jsg;	state dead;
branches;
next	1.1;
commitid	bC4bLqwWTo4kLw82;

1.1
date	2015.11.22.02.40.22;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.40.22;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.15.41;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.37.08;	author jsg;	state Exp;
branches;
next	;
commitid	uuv5VTS15jglEDZU;


desc
@@


1.3
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include "brw_context.h"
#include "brw_cfg.h"
#include "brw_eu.h"
#include "brw_fs.h"
#include "brw_nir.h"
#include "brw_vec4_tes.h"
#include "main/uniforms.h"

extern "C" void
brw_mark_surface_used(struct brw_stage_prog_data *prog_data,
                      unsigned surf_index)
{
   assert(surf_index < BRW_MAX_SURFACES);

   prog_data->binding_table.size_bytes =
      MAX2(prog_data->binding_table.size_bytes, (surf_index + 1) * 4);
}

enum brw_reg_type
brw_type_for_base_type(const struct glsl_type *type)
{
   switch (type->base_type) {
   case GLSL_TYPE_FLOAT:
      return BRW_REGISTER_TYPE_F;
   case GLSL_TYPE_INT:
   case GLSL_TYPE_BOOL:
   case GLSL_TYPE_SUBROUTINE:
      return BRW_REGISTER_TYPE_D;
   case GLSL_TYPE_UINT:
      return BRW_REGISTER_TYPE_UD;
   case GLSL_TYPE_ARRAY:
      return brw_type_for_base_type(type->fields.array);
   case GLSL_TYPE_STRUCT:
   case GLSL_TYPE_SAMPLER:
   case GLSL_TYPE_ATOMIC_UINT:
      /* These should be overridden with the type of the member when
       * dereferenced into.  BRW_REGISTER_TYPE_UD seems like a likely
       * way to trip up if we don't.
       */
      return BRW_REGISTER_TYPE_UD;
   case GLSL_TYPE_IMAGE:
      return BRW_REGISTER_TYPE_UD;
   case GLSL_TYPE_DOUBLE:
      return BRW_REGISTER_TYPE_DF;
   case GLSL_TYPE_VOID:
   case GLSL_TYPE_ERROR:
   case GLSL_TYPE_INTERFACE:
   case GLSL_TYPE_FUNCTION:
      unreachable("not reached");
   }

   return BRW_REGISTER_TYPE_F;
}

enum brw_conditional_mod
brw_conditional_for_comparison(unsigned int op)
{
   switch (op) {
   case ir_binop_less:
      return BRW_CONDITIONAL_L;
   case ir_binop_greater:
      return BRW_CONDITIONAL_G;
   case ir_binop_lequal:
      return BRW_CONDITIONAL_LE;
   case ir_binop_gequal:
      return BRW_CONDITIONAL_GE;
   case ir_binop_equal:
   case ir_binop_all_equal: /* same as equal for scalars */
      return BRW_CONDITIONAL_Z;
   case ir_binop_nequal:
   case ir_binop_any_nequal: /* same as nequal for scalars */
      return BRW_CONDITIONAL_NZ;
   default:
      unreachable("not reached: bad operation for comparison");
   }
}

uint32_t
brw_math_function(enum opcode op)
{
   switch (op) {
   case SHADER_OPCODE_RCP:
      return BRW_MATH_FUNCTION_INV;
   case SHADER_OPCODE_RSQ:
      return BRW_MATH_FUNCTION_RSQ;
   case SHADER_OPCODE_SQRT:
      return BRW_MATH_FUNCTION_SQRT;
   case SHADER_OPCODE_EXP2:
      return BRW_MATH_FUNCTION_EXP;
   case SHADER_OPCODE_LOG2:
      return BRW_MATH_FUNCTION_LOG;
   case SHADER_OPCODE_POW:
      return BRW_MATH_FUNCTION_POW;
   case SHADER_OPCODE_SIN:
      return BRW_MATH_FUNCTION_SIN;
   case SHADER_OPCODE_COS:
      return BRW_MATH_FUNCTION_COS;
   case SHADER_OPCODE_INT_QUOTIENT:
      return BRW_MATH_FUNCTION_INT_DIV_QUOTIENT;
   case SHADER_OPCODE_INT_REMAINDER:
      return BRW_MATH_FUNCTION_INT_DIV_REMAINDER;
   default:
      unreachable("not reached: unknown math function");
   }
}

uint32_t
brw_texture_offset(int *offsets, unsigned num_components)
{
   if (!offsets) return 0;  /* nonconstant offset; caller will handle it. */

   /* Combine all three offsets into a single unsigned dword:
    *
    *    bits 11:8 - U Offset (X component)
    *    bits  7:4 - V Offset (Y component)
    *    bits  3:0 - R Offset (Z component)
    */
   unsigned offset_bits = 0;
   for (unsigned i = 0; i < num_components; i++) {
      const unsigned shift = 4 * (2 - i);
      offset_bits |= (offsets[i] << shift) & (0xF << shift);
   }
   return offset_bits;
}

const char *
brw_instruction_name(const struct gen_device_info *devinfo, enum opcode op)
{
   switch (op) {
   case BRW_OPCODE_ILLEGAL ... BRW_OPCODE_NOP:
      /* The DO instruction doesn't exist on Gen6+, but we use it to mark the
       * start of a loop in the IR.
       */
      if (devinfo->gen >= 6 && op == BRW_OPCODE_DO)
         return "do";

      assert(brw_opcode_desc(devinfo, op)->name);
      return brw_opcode_desc(devinfo, op)->name;
   case FS_OPCODE_FB_WRITE:
      return "fb_write";
   case FS_OPCODE_FB_WRITE_LOGICAL:
      return "fb_write_logical";
   case FS_OPCODE_REP_FB_WRITE:
      return "rep_fb_write";
   case FS_OPCODE_FB_READ:
      return "fb_read";
   case FS_OPCODE_FB_READ_LOGICAL:
      return "fb_read_logical";

   case SHADER_OPCODE_RCP:
      return "rcp";
   case SHADER_OPCODE_RSQ:
      return "rsq";
   case SHADER_OPCODE_SQRT:
      return "sqrt";
   case SHADER_OPCODE_EXP2:
      return "exp2";
   case SHADER_OPCODE_LOG2:
      return "log2";
   case SHADER_OPCODE_POW:
      return "pow";
   case SHADER_OPCODE_INT_QUOTIENT:
      return "int_quot";
   case SHADER_OPCODE_INT_REMAINDER:
      return "int_rem";
   case SHADER_OPCODE_SIN:
      return "sin";
   case SHADER_OPCODE_COS:
      return "cos";

   case SHADER_OPCODE_TEX:
      return "tex";
   case SHADER_OPCODE_TEX_LOGICAL:
      return "tex_logical";
   case SHADER_OPCODE_TXD:
      return "txd";
   case SHADER_OPCODE_TXD_LOGICAL:
      return "txd_logical";
   case SHADER_OPCODE_TXF:
      return "txf";
   case SHADER_OPCODE_TXF_LOGICAL:
      return "txf_logical";
   case SHADER_OPCODE_TXF_LZ:
      return "txf_lz";
   case SHADER_OPCODE_TXL:
      return "txl";
   case SHADER_OPCODE_TXL_LOGICAL:
      return "txl_logical";
   case SHADER_OPCODE_TXL_LZ:
      return "txl_lz";
   case SHADER_OPCODE_TXS:
      return "txs";
   case SHADER_OPCODE_TXS_LOGICAL:
      return "txs_logical";
   case FS_OPCODE_TXB:
      return "txb";
   case FS_OPCODE_TXB_LOGICAL:
      return "txb_logical";
   case SHADER_OPCODE_TXF_CMS:
      return "txf_cms";
   case SHADER_OPCODE_TXF_CMS_LOGICAL:
      return "txf_cms_logical";
   case SHADER_OPCODE_TXF_CMS_W:
      return "txf_cms_w";
   case SHADER_OPCODE_TXF_CMS_W_LOGICAL:
      return "txf_cms_w_logical";
   case SHADER_OPCODE_TXF_UMS:
      return "txf_ums";
   case SHADER_OPCODE_TXF_UMS_LOGICAL:
      return "txf_ums_logical";
   case SHADER_OPCODE_TXF_MCS:
      return "txf_mcs";
   case SHADER_OPCODE_TXF_MCS_LOGICAL:
      return "txf_mcs_logical";
   case SHADER_OPCODE_LOD:
      return "lod";
   case SHADER_OPCODE_LOD_LOGICAL:
      return "lod_logical";
   case SHADER_OPCODE_TG4:
      return "tg4";
   case SHADER_OPCODE_TG4_LOGICAL:
      return "tg4_logical";
   case SHADER_OPCODE_TG4_OFFSET:
      return "tg4_offset";
   case SHADER_OPCODE_TG4_OFFSET_LOGICAL:
      return "tg4_offset_logical";
   case SHADER_OPCODE_SAMPLEINFO:
      return "sampleinfo";
   case SHADER_OPCODE_SAMPLEINFO_LOGICAL:
      return "sampleinfo_logical";

   case SHADER_OPCODE_SHADER_TIME_ADD:
      return "shader_time_add";

   case SHADER_OPCODE_UNTYPED_ATOMIC:
      return "untyped_atomic";
   case SHADER_OPCODE_UNTYPED_ATOMIC_LOGICAL:
      return "untyped_atomic_logical";
   case SHADER_OPCODE_UNTYPED_SURFACE_READ:
      return "untyped_surface_read";
   case SHADER_OPCODE_UNTYPED_SURFACE_READ_LOGICAL:
      return "untyped_surface_read_logical";
   case SHADER_OPCODE_UNTYPED_SURFACE_WRITE:
      return "untyped_surface_write";
   case SHADER_OPCODE_UNTYPED_SURFACE_WRITE_LOGICAL:
      return "untyped_surface_write_logical";
   case SHADER_OPCODE_TYPED_ATOMIC:
      return "typed_atomic";
   case SHADER_OPCODE_TYPED_ATOMIC_LOGICAL:
      return "typed_atomic_logical";
   case SHADER_OPCODE_TYPED_SURFACE_READ:
      return "typed_surface_read";
   case SHADER_OPCODE_TYPED_SURFACE_READ_LOGICAL:
      return "typed_surface_read_logical";
   case SHADER_OPCODE_TYPED_SURFACE_WRITE:
      return "typed_surface_write";
   case SHADER_OPCODE_TYPED_SURFACE_WRITE_LOGICAL:
      return "typed_surface_write_logical";
   case SHADER_OPCODE_MEMORY_FENCE:
      return "memory_fence";

   case SHADER_OPCODE_LOAD_PAYLOAD:
      return "load_payload";
   case FS_OPCODE_PACK:
      return "pack";

   case SHADER_OPCODE_GEN4_SCRATCH_READ:
      return "gen4_scratch_read";
   case SHADER_OPCODE_GEN4_SCRATCH_WRITE:
      return "gen4_scratch_write";
   case SHADER_OPCODE_GEN7_SCRATCH_READ:
      return "gen7_scratch_read";
   case SHADER_OPCODE_URB_WRITE_SIMD8:
      return "gen8_urb_write_simd8";
   case SHADER_OPCODE_URB_WRITE_SIMD8_PER_SLOT:
      return "gen8_urb_write_simd8_per_slot";
   case SHADER_OPCODE_URB_WRITE_SIMD8_MASKED:
      return "gen8_urb_write_simd8_masked";
   case SHADER_OPCODE_URB_WRITE_SIMD8_MASKED_PER_SLOT:
      return "gen8_urb_write_simd8_masked_per_slot";
   case SHADER_OPCODE_URB_READ_SIMD8:
      return "urb_read_simd8";
   case SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT:
      return "urb_read_simd8_per_slot";

   case SHADER_OPCODE_FIND_LIVE_CHANNEL:
      return "find_live_channel";
   case SHADER_OPCODE_BROADCAST:
      return "broadcast";

   case VEC4_OPCODE_MOV_BYTES:
      return "mov_bytes";
   case VEC4_OPCODE_PACK_BYTES:
      return "pack_bytes";
   case VEC4_OPCODE_UNPACK_UNIFORM:
      return "unpack_uniform";

   case FS_OPCODE_DDX_COARSE:
      return "ddx_coarse";
   case FS_OPCODE_DDX_FINE:
      return "ddx_fine";
   case FS_OPCODE_DDY_COARSE:
      return "ddy_coarse";
   case FS_OPCODE_DDY_FINE:
      return "ddy_fine";

   case FS_OPCODE_CINTERP:
      return "cinterp";
   case FS_OPCODE_LINTERP:
      return "linterp";

   case FS_OPCODE_PIXEL_X:
      return "pixel_x";
   case FS_OPCODE_PIXEL_Y:
      return "pixel_y";

   case FS_OPCODE_GET_BUFFER_SIZE:
      return "fs_get_buffer_size";

   case FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD:
      return "uniform_pull_const";
   case FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD_GEN7:
      return "uniform_pull_const_gen7";
   case FS_OPCODE_VARYING_PULL_CONSTANT_LOAD_GEN4:
      return "varying_pull_const_gen4";
   case FS_OPCODE_VARYING_PULL_CONSTANT_LOAD_GEN7:
      return "varying_pull_const_gen7";
   case FS_OPCODE_VARYING_PULL_CONSTANT_LOAD_LOGICAL:
      return "varying_pull_const_logical";

   case FS_OPCODE_MOV_DISPATCH_TO_FLAGS:
      return "mov_dispatch_to_flags";
   case FS_OPCODE_DISCARD_JUMP:
      return "discard_jump";

   case FS_OPCODE_SET_SAMPLE_ID:
      return "set_sample_id";
   case FS_OPCODE_SET_SIMD4X2_OFFSET:
      return "set_simd4x2_offset";

   case FS_OPCODE_PACK_HALF_2x16_SPLIT:
      return "pack_half_2x16_split";
   case FS_OPCODE_UNPACK_HALF_2x16_SPLIT_X:
      return "unpack_half_2x16_split_x";
   case FS_OPCODE_UNPACK_HALF_2x16_SPLIT_Y:
      return "unpack_half_2x16_split_y";

   case FS_OPCODE_PLACEHOLDER_HALT:
      return "placeholder_halt";

   case FS_OPCODE_INTERPOLATE_AT_SAMPLE:
      return "interp_sample";
   case FS_OPCODE_INTERPOLATE_AT_SHARED_OFFSET:
      return "interp_shared_offset";
   case FS_OPCODE_INTERPOLATE_AT_PER_SLOT_OFFSET:
      return "interp_per_slot_offset";

   case VS_OPCODE_URB_WRITE:
      return "vs_urb_write";
   case VS_OPCODE_PULL_CONSTANT_LOAD:
      return "pull_constant_load";
   case VS_OPCODE_PULL_CONSTANT_LOAD_GEN7:
      return "pull_constant_load_gen7";

   case VS_OPCODE_SET_SIMD4X2_HEADER_GEN9:
      return "set_simd4x2_header_gen9";

   case VS_OPCODE_GET_BUFFER_SIZE:
      return "vs_get_buffer_size";

   case VS_OPCODE_UNPACK_FLAGS_SIMD4X2:
      return "unpack_flags_simd4x2";

   case GS_OPCODE_URB_WRITE:
      return "gs_urb_write";
   case GS_OPCODE_URB_WRITE_ALLOCATE:
      return "gs_urb_write_allocate";
   case GS_OPCODE_THREAD_END:
      return "gs_thread_end";
   case GS_OPCODE_SET_WRITE_OFFSET:
      return "set_write_offset";
   case GS_OPCODE_SET_VERTEX_COUNT:
      return "set_vertex_count";
   case GS_OPCODE_SET_DWORD_2:
      return "set_dword_2";
   case GS_OPCODE_PREPARE_CHANNEL_MASKS:
      return "prepare_channel_masks";
   case GS_OPCODE_SET_CHANNEL_MASKS:
      return "set_channel_masks";
   case GS_OPCODE_GET_INSTANCE_ID:
      return "get_instance_id";
   case GS_OPCODE_FF_SYNC:
      return "ff_sync";
   case GS_OPCODE_SET_PRIMITIVE_ID:
      return "set_primitive_id";
   case GS_OPCODE_SVB_WRITE:
      return "gs_svb_write";
   case GS_OPCODE_SVB_SET_DST_INDEX:
      return "gs_svb_set_dst_index";
   case GS_OPCODE_FF_SYNC_SET_PRIMITIVES:
      return "gs_ff_sync_set_primitives";
   case CS_OPCODE_CS_TERMINATE:
      return "cs_terminate";
   case SHADER_OPCODE_BARRIER:
      return "barrier";
   case SHADER_OPCODE_MULH:
      return "mulh";
   case SHADER_OPCODE_MOV_INDIRECT:
      return "mov_indirect";

   case VEC4_OPCODE_URB_READ:
      return "urb_read";
   case TCS_OPCODE_GET_INSTANCE_ID:
      return "tcs_get_instance_id";
   case TCS_OPCODE_URB_WRITE:
      return "tcs_urb_write";
   case TCS_OPCODE_SET_INPUT_URB_OFFSETS:
      return "tcs_set_input_urb_offsets";
   case TCS_OPCODE_SET_OUTPUT_URB_OFFSETS:
      return "tcs_set_output_urb_offsets";
   case TCS_OPCODE_GET_PRIMITIVE_ID:
      return "tcs_get_primitive_id";
   case TCS_OPCODE_CREATE_BARRIER_HEADER:
      return "tcs_create_barrier_header";
   case TCS_OPCODE_SRC0_010_IS_ZERO:
      return "tcs_src0<0,1,0>_is_zero";
   case TCS_OPCODE_RELEASE_INPUT:
      return "tcs_release_input";
   case TCS_OPCODE_THREAD_END:
      return "tcs_thread_end";
   case TES_OPCODE_CREATE_INPUT_READ_HEADER:
      return "tes_create_input_read_header";
   case TES_OPCODE_ADD_INDIRECT_URB_OFFSET:
      return "tes_add_indirect_urb_offset";
   case TES_OPCODE_GET_PRIMITIVE_ID:
      return "tes_get_primitive_id";
   }

   unreachable("not reached");
}

bool
brw_saturate_immediate(enum brw_reg_type type, struct brw_reg *reg)
{
   union {
      unsigned ud;
      int d;
      float f;
      double df;
   } imm, sat_imm = { 0 };

   const unsigned size = type_sz(type);

   /* We want to either do a 32-bit or 64-bit data copy, the type is otherwise
    * irrelevant, so just check the size of the type and copy from/to an
    * appropriately sized field.
    */
   if (size < 8)
      imm.ud = reg->ud;
   else
      imm.df = reg->df;

   switch (type) {
   case BRW_REGISTER_TYPE_UD:
   case BRW_REGISTER_TYPE_D:
   case BRW_REGISTER_TYPE_UW:
   case BRW_REGISTER_TYPE_W:
   case BRW_REGISTER_TYPE_UQ:
   case BRW_REGISTER_TYPE_Q:
      /* Nothing to do. */
      return false;
   case BRW_REGISTER_TYPE_F:
      sat_imm.f = CLAMP(imm.f, 0.0f, 1.0f);
      break;
   case BRW_REGISTER_TYPE_DF:
      sat_imm.df = CLAMP(imm.df, 0.0, 1.0);
      break;
   case BRW_REGISTER_TYPE_UB:
   case BRW_REGISTER_TYPE_B:
      unreachable("no UB/B immediates");
   case BRW_REGISTER_TYPE_V:
   case BRW_REGISTER_TYPE_UV:
   case BRW_REGISTER_TYPE_VF:
      unreachable("unimplemented: saturate vector immediate");
   case BRW_REGISTER_TYPE_HF:
      unreachable("unimplemented: saturate HF immediate");
   }

   if (size < 8) {
      if (imm.ud != sat_imm.ud) {
         reg->ud = sat_imm.ud;
         return true;
      }
   } else {
      if (imm.df != sat_imm.df) {
         reg->df = sat_imm.df;
         return true;
      }
   }
   return false;
}

bool
brw_negate_immediate(enum brw_reg_type type, struct brw_reg *reg)
{
   switch (type) {
   case BRW_REGISTER_TYPE_D:
   case BRW_REGISTER_TYPE_UD:
      reg->d = -reg->d;
      return true;
   case BRW_REGISTER_TYPE_W:
   case BRW_REGISTER_TYPE_UW:
      reg->d = -(int16_t)reg->ud;
      return true;
   case BRW_REGISTER_TYPE_F:
      reg->f = -reg->f;
      return true;
   case BRW_REGISTER_TYPE_VF:
      reg->ud ^= 0x80808080;
      return true;
   case BRW_REGISTER_TYPE_DF:
      reg->df = -reg->df;
      return true;
   case BRW_REGISTER_TYPE_UB:
   case BRW_REGISTER_TYPE_B:
      unreachable("no UB/B immediates");
   case BRW_REGISTER_TYPE_UV:
   case BRW_REGISTER_TYPE_V:
      assert(!"unimplemented: negate UV/V immediate");
   case BRW_REGISTER_TYPE_UQ:
   case BRW_REGISTER_TYPE_Q:
      assert(!"unimplemented: negate UQ/Q immediate");
   case BRW_REGISTER_TYPE_HF:
      assert(!"unimplemented: negate HF immediate");
   }

   return false;
}

bool
brw_abs_immediate(enum brw_reg_type type, struct brw_reg *reg)
{
   switch (type) {
   case BRW_REGISTER_TYPE_D:
      reg->d = abs(reg->d);
      return true;
   case BRW_REGISTER_TYPE_W:
      reg->d = abs((int16_t)reg->ud);
      return true;
   case BRW_REGISTER_TYPE_F:
      reg->f = fabsf(reg->f);
      return true;
   case BRW_REGISTER_TYPE_DF:
      reg->df = fabs(reg->df);
      return true;
   case BRW_REGISTER_TYPE_VF:
      reg->ud &= ~0x80808080;
      return true;
   case BRW_REGISTER_TYPE_UB:
   case BRW_REGISTER_TYPE_B:
      unreachable("no UB/B immediates");
   case BRW_REGISTER_TYPE_UQ:
   case BRW_REGISTER_TYPE_UD:
   case BRW_REGISTER_TYPE_UW:
   case BRW_REGISTER_TYPE_UV:
      /* Presumably the absolute value modifier on an unsigned source is a
       * nop, but it would be nice to confirm.
       */
      assert(!"unimplemented: abs unsigned immediate");
   case BRW_REGISTER_TYPE_V:
      assert(!"unimplemented: abs V immediate");
   case BRW_REGISTER_TYPE_Q:
      assert(!"unimplemented: abs Q immediate");
   case BRW_REGISTER_TYPE_HF:
      assert(!"unimplemented: abs HF immediate");
   }

   return false;
}

/**
 * Get the appropriate atomic op for an image atomic intrinsic.
 */
unsigned
get_atomic_counter_op(nir_intrinsic_op op)
{
   switch (op) {
   case nir_intrinsic_atomic_counter_inc:
      return BRW_AOP_INC;
   case nir_intrinsic_atomic_counter_dec:
      return BRW_AOP_PREDEC;
   case nir_intrinsic_atomic_counter_add:
      return BRW_AOP_ADD;
   case nir_intrinsic_atomic_counter_min:
      return BRW_AOP_UMIN;
   case nir_intrinsic_atomic_counter_max:
      return BRW_AOP_UMAX;
   case nir_intrinsic_atomic_counter_and:
      return BRW_AOP_AND;
   case nir_intrinsic_atomic_counter_or:
      return BRW_AOP_OR;
   case nir_intrinsic_atomic_counter_xor:
      return BRW_AOP_XOR;
   case nir_intrinsic_atomic_counter_exchange:
      return BRW_AOP_MOV;
   case nir_intrinsic_atomic_counter_comp_swap:
      return BRW_AOP_CMPWR;
   default:
      unreachable("Not reachable.");
   }
}

unsigned
tesslevel_outer_components(GLenum tes_primitive_mode)
{
   switch (tes_primitive_mode) {
   case GL_QUADS:
      return 4;
   case GL_TRIANGLES:
      return 3;
   case GL_ISOLINES:
      return 2;
   default:
      unreachable("Bogus tessellation domain");
   }
   return 0;
}

unsigned
tesslevel_inner_components(GLenum tes_primitive_mode)
{
   switch (tes_primitive_mode) {
   case GL_QUADS:
      return 2;
   case GL_TRIANGLES:
      return 1;
   case GL_ISOLINES:
      return 0;
   default:
      unreachable("Bogus tessellation domain");
   }
   return 0;
}

/**
 * Given a normal .xyzw writemask, convert it to a writemask for a vector
 * that's stored backwards, i.e. .wzyx.
 */
unsigned
writemask_for_backwards_vector(unsigned mask)
{
   unsigned new_mask = 0;

   for (int i = 0; i < 4; i++)
      new_mask |= ((mask >> i) & 1) << (3 - i);

   return new_mask;
}

backend_shader::backend_shader(const struct brw_compiler *compiler,
                               void *log_data,
                               void *mem_ctx,
                               const nir_shader *shader,
                               struct brw_stage_prog_data *stage_prog_data)
   : compiler(compiler),
     log_data(log_data),
     devinfo(compiler->devinfo),
     nir(shader),
     stage_prog_data(stage_prog_data),
     mem_ctx(mem_ctx),
     cfg(NULL),
     stage(shader->stage)
{
   debug_enabled = INTEL_DEBUG & intel_debug_flag_for_shader_stage(stage);
   stage_name = _mesa_shader_stage_to_string(stage);
   stage_abbrev = _mesa_shader_stage_to_abbrev(stage);
   is_passthrough_shader =
      nir->info.name && strcmp(nir->info.name, "passthrough") == 0;
}

bool
backend_reg::equals(const backend_reg &r) const
{
   return brw_regs_equal(this, &r) && offset == r.offset;
}

bool
backend_reg::is_zero() const
{
   if (file != IMM)
      return false;

   switch (type) {
   case BRW_REGISTER_TYPE_F:
      return f == 0;
   case BRW_REGISTER_TYPE_DF:
      return df == 0;
   case BRW_REGISTER_TYPE_D:
   case BRW_REGISTER_TYPE_UD:
      return d == 0;
   default:
      return false;
   }
}

bool
backend_reg::is_one() const
{
   if (file != IMM)
      return false;

   switch (type) {
   case BRW_REGISTER_TYPE_F:
      return f == 1.0f;
   case BRW_REGISTER_TYPE_DF:
      return df == 1.0;
   case BRW_REGISTER_TYPE_D:
   case BRW_REGISTER_TYPE_UD:
      return d == 1;
   default:
      return false;
   }
}

bool
backend_reg::is_negative_one() const
{
   if (file != IMM)
      return false;

   switch (type) {
   case BRW_REGISTER_TYPE_F:
      return f == -1.0;
   case BRW_REGISTER_TYPE_DF:
      return df == -1.0;
   case BRW_REGISTER_TYPE_D:
      return d == -1;
   default:
      return false;
   }
}

bool
backend_reg::is_null() const
{
   return file == ARF && nr == BRW_ARF_NULL;
}


bool
backend_reg::is_accumulator() const
{
   return file == ARF && nr == BRW_ARF_ACCUMULATOR;
}

bool
backend_instruction::is_commutative() const
{
   switch (opcode) {
   case BRW_OPCODE_AND:
   case BRW_OPCODE_OR:
   case BRW_OPCODE_XOR:
   case BRW_OPCODE_ADD:
   case BRW_OPCODE_MUL:
   case SHADER_OPCODE_MULH:
      return true;
   case BRW_OPCODE_SEL:
      /* MIN and MAX are commutative. */
      if (conditional_mod == BRW_CONDITIONAL_GE ||
          conditional_mod == BRW_CONDITIONAL_L) {
         return true;
      }
      /* fallthrough */
   default:
      return false;
   }
}

bool
backend_instruction::is_3src(const struct gen_device_info *devinfo) const
{
   return ::is_3src(devinfo, opcode);
}

bool
backend_instruction::is_tex() const
{
   return (opcode == SHADER_OPCODE_TEX ||
           opcode == FS_OPCODE_TXB ||
           opcode == SHADER_OPCODE_TXD ||
           opcode == SHADER_OPCODE_TXF ||
           opcode == SHADER_OPCODE_TXF_LZ ||
           opcode == SHADER_OPCODE_TXF_CMS ||
           opcode == SHADER_OPCODE_TXF_CMS_W ||
           opcode == SHADER_OPCODE_TXF_UMS ||
           opcode == SHADER_OPCODE_TXF_MCS ||
           opcode == SHADER_OPCODE_TXL ||
           opcode == SHADER_OPCODE_TXL_LZ ||
           opcode == SHADER_OPCODE_TXS ||
           opcode == SHADER_OPCODE_LOD ||
           opcode == SHADER_OPCODE_TG4 ||
           opcode == SHADER_OPCODE_TG4_OFFSET ||
           opcode == SHADER_OPCODE_SAMPLEINFO);
}

bool
backend_instruction::is_math() const
{
   return (opcode == SHADER_OPCODE_RCP ||
           opcode == SHADER_OPCODE_RSQ ||
           opcode == SHADER_OPCODE_SQRT ||
           opcode == SHADER_OPCODE_EXP2 ||
           opcode == SHADER_OPCODE_LOG2 ||
           opcode == SHADER_OPCODE_SIN ||
           opcode == SHADER_OPCODE_COS ||
           opcode == SHADER_OPCODE_INT_QUOTIENT ||
           opcode == SHADER_OPCODE_INT_REMAINDER ||
           opcode == SHADER_OPCODE_POW);
}

bool
backend_instruction::is_control_flow() const
{
   switch (opcode) {
   case BRW_OPCODE_DO:
   case BRW_OPCODE_WHILE:
   case BRW_OPCODE_IF:
   case BRW_OPCODE_ELSE:
   case BRW_OPCODE_ENDIF:
   case BRW_OPCODE_BREAK:
   case BRW_OPCODE_CONTINUE:
      return true;
   default:
      return false;
   }
}

bool
backend_instruction::can_do_source_mods() const
{
   switch (opcode) {
   case BRW_OPCODE_ADDC:
   case BRW_OPCODE_BFE:
   case BRW_OPCODE_BFI1:
   case BRW_OPCODE_BFI2:
   case BRW_OPCODE_BFREV:
   case BRW_OPCODE_CBIT:
   case BRW_OPCODE_FBH:
   case BRW_OPCODE_FBL:
   case BRW_OPCODE_SUBB:
      return false;
   default:
      return true;
   }
}

bool
backend_instruction::can_do_saturate() const
{
   switch (opcode) {
   case BRW_OPCODE_ADD:
   case BRW_OPCODE_ASR:
   case BRW_OPCODE_AVG:
   case BRW_OPCODE_DP2:
   case BRW_OPCODE_DP3:
   case BRW_OPCODE_DP4:
   case BRW_OPCODE_DPH:
   case BRW_OPCODE_F16TO32:
   case BRW_OPCODE_F32TO16:
   case BRW_OPCODE_LINE:
   case BRW_OPCODE_LRP:
   case BRW_OPCODE_MAC:
   case BRW_OPCODE_MAD:
   case BRW_OPCODE_MATH:
   case BRW_OPCODE_MOV:
   case BRW_OPCODE_MUL:
   case SHADER_OPCODE_MULH:
   case BRW_OPCODE_PLN:
   case BRW_OPCODE_RNDD:
   case BRW_OPCODE_RNDE:
   case BRW_OPCODE_RNDU:
   case BRW_OPCODE_RNDZ:
   case BRW_OPCODE_SEL:
   case BRW_OPCODE_SHL:
   case BRW_OPCODE_SHR:
   case FS_OPCODE_LINTERP:
   case SHADER_OPCODE_COS:
   case SHADER_OPCODE_EXP2:
   case SHADER_OPCODE_LOG2:
   case SHADER_OPCODE_POW:
   case SHADER_OPCODE_RCP:
   case SHADER_OPCODE_RSQ:
   case SHADER_OPCODE_SIN:
   case SHADER_OPCODE_SQRT:
      return true;
   default:
      return false;
   }
}

bool
backend_instruction::can_do_cmod() const
{
   switch (opcode) {
   case BRW_OPCODE_ADD:
   case BRW_OPCODE_ADDC:
   case BRW_OPCODE_AND:
   case BRW_OPCODE_ASR:
   case BRW_OPCODE_AVG:
   case BRW_OPCODE_CMP:
   case BRW_OPCODE_CMPN:
   case BRW_OPCODE_DP2:
   case BRW_OPCODE_DP3:
   case BRW_OPCODE_DP4:
   case BRW_OPCODE_DPH:
   case BRW_OPCODE_F16TO32:
   case BRW_OPCODE_F32TO16:
   case BRW_OPCODE_FRC:
   case BRW_OPCODE_LINE:
   case BRW_OPCODE_LRP:
   case BRW_OPCODE_LZD:
   case BRW_OPCODE_MAC:
   case BRW_OPCODE_MACH:
   case BRW_OPCODE_MAD:
   case BRW_OPCODE_MOV:
   case BRW_OPCODE_MUL:
   case BRW_OPCODE_NOT:
   case BRW_OPCODE_OR:
   case BRW_OPCODE_PLN:
   case BRW_OPCODE_RNDD:
   case BRW_OPCODE_RNDE:
   case BRW_OPCODE_RNDU:
   case BRW_OPCODE_RNDZ:
   case BRW_OPCODE_SAD2:
   case BRW_OPCODE_SADA2:
   case BRW_OPCODE_SHL:
   case BRW_OPCODE_SHR:
   case BRW_OPCODE_SUBB:
   case BRW_OPCODE_XOR:
   case FS_OPCODE_CINTERP:
   case FS_OPCODE_LINTERP:
      return true;
   default:
      return false;
   }
}

bool
backend_instruction::reads_accumulator_implicitly() const
{
   switch (opcode) {
   case BRW_OPCODE_MAC:
   case BRW_OPCODE_MACH:
   case BRW_OPCODE_SADA2:
      return true;
   default:
      return false;
   }
}

bool
backend_instruction::writes_accumulator_implicitly(const struct gen_device_info *devinfo) const
{
   return writes_accumulator ||
          (devinfo->gen < 6 &&
           ((opcode >= BRW_OPCODE_ADD && opcode < BRW_OPCODE_NOP) ||
            (opcode >= FS_OPCODE_DDX_COARSE && opcode <= FS_OPCODE_LINTERP &&
             opcode != FS_OPCODE_CINTERP)));
}

bool
backend_instruction::has_side_effects() const
{
   switch (opcode) {
   case SHADER_OPCODE_UNTYPED_ATOMIC:
   case SHADER_OPCODE_UNTYPED_ATOMIC_LOGICAL:
   case SHADER_OPCODE_GEN4_SCRATCH_WRITE:
   case SHADER_OPCODE_UNTYPED_SURFACE_WRITE:
   case SHADER_OPCODE_UNTYPED_SURFACE_WRITE_LOGICAL:
   case SHADER_OPCODE_TYPED_ATOMIC:
   case SHADER_OPCODE_TYPED_ATOMIC_LOGICAL:
   case SHADER_OPCODE_TYPED_SURFACE_WRITE:
   case SHADER_OPCODE_TYPED_SURFACE_WRITE_LOGICAL:
   case SHADER_OPCODE_MEMORY_FENCE:
   case SHADER_OPCODE_URB_WRITE_SIMD8:
   case SHADER_OPCODE_URB_WRITE_SIMD8_PER_SLOT:
   case SHADER_OPCODE_URB_WRITE_SIMD8_MASKED:
   case SHADER_OPCODE_URB_WRITE_SIMD8_MASKED_PER_SLOT:
   case FS_OPCODE_FB_WRITE:
   case FS_OPCODE_FB_WRITE_LOGICAL:
   case SHADER_OPCODE_BARRIER:
   case TCS_OPCODE_URB_WRITE:
   case TCS_OPCODE_RELEASE_INPUT:
      return true;
   default:
      return false;
   }
}

bool
backend_instruction::is_volatile() const
{
   switch (opcode) {
   case SHADER_OPCODE_UNTYPED_SURFACE_READ:
   case SHADER_OPCODE_UNTYPED_SURFACE_READ_LOGICAL:
   case SHADER_OPCODE_TYPED_SURFACE_READ:
   case SHADER_OPCODE_TYPED_SURFACE_READ_LOGICAL:
   case SHADER_OPCODE_URB_READ_SIMD8:
   case SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT:
   case VEC4_OPCODE_URB_READ:
      return true;
   default:
      return false;
   }
}

#ifndef NDEBUG
static bool
inst_is_in_block(const bblock_t *block, const backend_instruction *inst)
{
   bool found = false;
   foreach_inst_in_block (backend_instruction, i, block) {
      if (inst == i) {
         found = true;
      }
   }
   return found;
}
#endif

static void
adjust_later_block_ips(bblock_t *start_block, int ip_adjustment)
{
   for (bblock_t *block_iter = start_block->next();
        block_iter;
        block_iter = block_iter->next()) {
      block_iter->start_ip += ip_adjustment;
      block_iter->end_ip += ip_adjustment;
   }
}

void
backend_instruction::insert_after(bblock_t *block, backend_instruction *inst)
{
   assert(this != inst);

   if (!this->is_head_sentinel())
      assert(inst_is_in_block(block, this) || !"Instruction not in block");

   block->end_ip++;

   adjust_later_block_ips(block, 1);

   exec_node::insert_after(inst);
}

void
backend_instruction::insert_before(bblock_t *block, backend_instruction *inst)
{
   assert(this != inst);

   if (!this->is_tail_sentinel())
      assert(inst_is_in_block(block, this) || !"Instruction not in block");

   block->end_ip++;

   adjust_later_block_ips(block, 1);

   exec_node::insert_before(inst);
}

void
backend_instruction::insert_before(bblock_t *block, exec_list *list)
{
   assert(inst_is_in_block(block, this) || !"Instruction not in block");

   unsigned num_inst = list->length();

   block->end_ip += num_inst;

   adjust_later_block_ips(block, num_inst);

   exec_node::insert_before(list);
}

void
backend_instruction::remove(bblock_t *block)
{
   assert(inst_is_in_block(block, this) || !"Instruction not in block");

   adjust_later_block_ips(block, -1);

   if (block->start_ip == block->end_ip) {
      block->cfg->remove_block(block);
   } else {
      block->end_ip--;
   }

   exec_node::remove();
}

void
backend_shader::dump_instructions()
{
   dump_instructions(NULL);
}

void
backend_shader::dump_instructions(const char *name)
{
   FILE *file = stderr;
   if (name && geteuid() != 0) {
      file = fopen(name, "w");
      if (!file)
         file = stderr;
   }

   if (cfg) {
      int ip = 0;
      foreach_block_and_inst(block, backend_instruction, inst, cfg) {
         if (!unlikely(INTEL_DEBUG & DEBUG_OPTIMIZER))
            fprintf(file, "%4d: ", ip++);
         dump_instruction(inst, file);
      }
   } else {
      int ip = 0;
      foreach_in_list(backend_instruction, inst, &instructions) {
         if (!unlikely(INTEL_DEBUG & DEBUG_OPTIMIZER))
            fprintf(file, "%4d: ", ip++);
         dump_instruction(inst, file);
      }
   }

   if (file != stderr) {
      fclose(file);
   }
}

void
backend_shader::calculate_cfg()
{
   if (this->cfg)
      return;
   cfg = new(mem_ctx) cfg_t(&this->instructions);
}

/**
 * Sets up the starting offsets for the groups of binding table entries
 * commong to all pipeline stages.
 *
 * Unused groups are initialized to 0xd0d0d0d0 to make it obvious that they're
 * unused but also make sure that addition of small offsets to them will
 * trigger some of our asserts that surface indices are < BRW_MAX_SURFACES.
 */
uint32_t
brw_assign_common_binding_table_offsets(gl_shader_stage stage,
                                        const struct gen_device_info *devinfo,
                                        const struct gl_shader_program *shader_prog,
                                        const struct gl_program *prog,
                                        struct brw_stage_prog_data *stage_prog_data,
                                        uint32_t next_binding_table_offset)
{
   const struct gl_linked_shader *shader = NULL;
   int num_textures = util_last_bit(prog->SamplersUsed);

   if (shader_prog)
      shader = shader_prog->_LinkedShaders[stage];

   stage_prog_data->binding_table.texture_start = next_binding_table_offset;
   next_binding_table_offset += num_textures;

   if (shader) {
      assert(shader->NumUniformBlocks <= BRW_MAX_UBO);
      stage_prog_data->binding_table.ubo_start = next_binding_table_offset;
      next_binding_table_offset += shader->NumUniformBlocks;

      assert(shader->NumShaderStorageBlocks <= BRW_MAX_SSBO);
      stage_prog_data->binding_table.ssbo_start = next_binding_table_offset;
      next_binding_table_offset += shader->NumShaderStorageBlocks;
   } else {
      stage_prog_data->binding_table.ubo_start = 0xd0d0d0d0;
      stage_prog_data->binding_table.ssbo_start = 0xd0d0d0d0;
   }

   if (INTEL_DEBUG & DEBUG_SHADER_TIME) {
      stage_prog_data->binding_table.shader_time_start = next_binding_table_offset;
      next_binding_table_offset++;
   } else {
      stage_prog_data->binding_table.shader_time_start = 0xd0d0d0d0;
   }

   if (prog->nir->info.uses_texture_gather) {
      if (devinfo->gen >= 8) {
         stage_prog_data->binding_table.gather_texture_start =
            stage_prog_data->binding_table.texture_start;
      } else {
         stage_prog_data->binding_table.gather_texture_start = next_binding_table_offset;
         next_binding_table_offset += num_textures;
      }
   } else {
      stage_prog_data->binding_table.gather_texture_start = 0xd0d0d0d0;
   }

   if (shader && shader->NumAtomicBuffers) {
      stage_prog_data->binding_table.abo_start = next_binding_table_offset;
      next_binding_table_offset += shader->NumAtomicBuffers;
   } else {
      stage_prog_data->binding_table.abo_start = 0xd0d0d0d0;
   }

   if (shader && shader->NumImages) {
      stage_prog_data->binding_table.image_start = next_binding_table_offset;
      next_binding_table_offset += shader->NumImages;
   } else {
      stage_prog_data->binding_table.image_start = 0xd0d0d0d0;
   }

   /* This may or may not be used depending on how the compile goes. */
   stage_prog_data->binding_table.pull_constants_start = next_binding_table_offset;
   next_binding_table_offset++;

   /* Plane 0 is just the regular texture section */
   stage_prog_data->binding_table.plane_start[0] = stage_prog_data->binding_table.texture_start;

   stage_prog_data->binding_table.plane_start[1] = next_binding_table_offset;
   next_binding_table_offset += num_textures;

   stage_prog_data->binding_table.plane_start[2] = next_binding_table_offset;
   next_binding_table_offset += num_textures;

   /* prog_data->base.binding_table.size will be set by brw_mark_surface_used. */

   assert(next_binding_table_offset <= BRW_MAX_SURFACES);
   return next_binding_table_offset;
}

static void
setup_vec4_uniform_value(const gl_constant_value **params,
                         const gl_constant_value *values,
                         unsigned n)
{
   static const gl_constant_value zero = { 0 };

   for (unsigned i = 0; i < n; ++i)
      params[i] = &values[i];

   for (unsigned i = n; i < 4; ++i)
      params[i] = &zero;
}

void
brw_setup_image_uniform_values(gl_shader_stage stage,
                               struct brw_stage_prog_data *stage_prog_data,
                               unsigned param_start_index,
                               const gl_uniform_storage *storage)
{
   const gl_constant_value **param =
      &stage_prog_data->param[param_start_index];

   for (unsigned i = 0; i < MAX2(storage->array_elements, 1); i++) {
      const unsigned image_idx = storage->opaque[stage].index + i;
      const brw_image_param *image_param =
         &stage_prog_data->image_param[image_idx];

      /* Upload the brw_image_param structure.  The order is expected to match
       * the BRW_IMAGE_PARAM_*_OFFSET defines.
       */
      setup_vec4_uniform_value(param + BRW_IMAGE_PARAM_SURFACE_IDX_OFFSET,
         (const gl_constant_value *)&image_param->surface_idx, 1);
      setup_vec4_uniform_value(param + BRW_IMAGE_PARAM_OFFSET_OFFSET,
         (const gl_constant_value *)image_param->offset, 2);
      setup_vec4_uniform_value(param + BRW_IMAGE_PARAM_SIZE_OFFSET,
         (const gl_constant_value *)image_param->size, 3);
      setup_vec4_uniform_value(param + BRW_IMAGE_PARAM_STRIDE_OFFSET,
         (const gl_constant_value *)image_param->stride, 4);
      setup_vec4_uniform_value(param + BRW_IMAGE_PARAM_TILING_OFFSET,
         (const gl_constant_value *)image_param->tiling, 3);
      setup_vec4_uniform_value(param + BRW_IMAGE_PARAM_SWIZZLING_OFFSET,
         (const gl_constant_value *)image_param->swizzling, 2);
      param += BRW_IMAGE_PARAM_SIZE;

      brw_mark_surface_used(
         stage_prog_data,
         stage_prog_data->binding_table.image_start + image_idx);
   }
}

/**
 * Decide which set of clip planes should be used when clipping via
 * gl_Position or gl_ClipVertex.
 */
gl_clip_plane *brw_select_clip_planes(struct gl_context *ctx)
{
   if (ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX]) {
      /* There is currently a GLSL vertex shader, so clip according to GLSL
       * rules, which means compare gl_ClipVertex (or gl_Position, if
       * gl_ClipVertex wasn't assigned) against the eye-coordinate clip planes
       * that were stored in EyeUserPlane at the time the clip planes were
       * specified.
       */
      return ctx->Transform.EyeUserPlane;
   } else {
      /* Either we are using fixed function or an ARB vertex program.  In
       * either case the clip planes are going to be compared against
       * gl_Position (which is in clip coordinates) so we have to clip using
       * _ClipUserPlane, which was transformed into clip coordinates by Mesa
       * core.
       */
      return ctx->Transform._ClipUserPlane;
   }
}

extern "C" const unsigned *
brw_compile_tes(const struct brw_compiler *compiler,
                void *log_data,
                void *mem_ctx,
                const struct brw_tes_prog_key *key,
                struct brw_tes_prog_data *prog_data,
                const nir_shader *src_shader,
                struct gl_shader_program *shader_prog,
                int shader_time_index,
                unsigned *final_assembly_size,
                char **error_str)
{
   const struct gen_device_info *devinfo = compiler->devinfo;
   struct gl_linked_shader *shader =
      shader_prog->_LinkedShaders[MESA_SHADER_TESS_EVAL];
   const bool is_scalar = compiler->scalar_stage[MESA_SHADER_TESS_EVAL];

   nir_shader *nir = nir_shader_clone(mem_ctx, src_shader);
   nir->info.inputs_read = key->inputs_read;
   nir->info.patch_inputs_read = key->patch_inputs_read;

   struct brw_vue_map input_vue_map;
   brw_compute_tess_vue_map(&input_vue_map,
                            nir->info.inputs_read & ~VARYING_BIT_PRIMITIVE_ID,
                            nir->info.patch_inputs_read);

   nir = brw_nir_apply_sampler_key(nir, devinfo, &key->tex, is_scalar);
   brw_nir_lower_tes_inputs(nir, &input_vue_map);
   brw_nir_lower_vue_outputs(nir, is_scalar);
   nir = brw_postprocess_nir(nir, compiler->devinfo, is_scalar);

   brw_compute_vue_map(devinfo, &prog_data->base.vue_map,
                       nir->info.outputs_written,
                       nir->info.separate_shader);

   unsigned output_size_bytes = prog_data->base.vue_map.num_slots * 4 * 4;

   assert(output_size_bytes >= 1);
   if (output_size_bytes > GEN7_MAX_DS_URB_ENTRY_SIZE_BYTES) {
      if (error_str)
         *error_str = ralloc_strdup(mem_ctx, "DS outputs exceed maximum size");
      return NULL;
   }

   /* URB entry sizes are stored as a multiple of 64 bytes. */
   prog_data->base.urb_entry_size = ALIGN(output_size_bytes, 64) / 64;

   bool need_patch_header = nir->info.system_values_read &
      (BITFIELD64_BIT(SYSTEM_VALUE_TESS_LEVEL_OUTER) |
       BITFIELD64_BIT(SYSTEM_VALUE_TESS_LEVEL_INNER));

   /* The TES will pull most inputs using URB read messages.
    *
    * However, we push the patch header for TessLevel factors when required,
    * as it's a tiny amount of extra data.
    */
   prog_data->base.urb_read_length = need_patch_header ? 1 : 0;

   if (unlikely(INTEL_DEBUG & DEBUG_TES)) {
      fprintf(stderr, "TES Input ");
      brw_print_vue_map(stderr, &input_vue_map);
      fprintf(stderr, "TES Output ");
      brw_print_vue_map(stderr, &prog_data->base.vue_map);
   }

   if (is_scalar) {
      fs_visitor v(compiler, log_data, mem_ctx, (void *) key,
                   &prog_data->base.base, shader->Program, nir, 8,
                   shader_time_index, &input_vue_map);
      if (!v.run_tes()) {
         if (error_str)
            *error_str = ralloc_strdup(mem_ctx, v.fail_msg);
         return NULL;
      }

      prog_data->base.base.dispatch_grf_start_reg = v.payload.num_regs;
      prog_data->base.dispatch_mode = DISPATCH_MODE_SIMD8;

      fs_generator g(compiler, log_data, mem_ctx, (void *) key,
                     &prog_data->base.base, v.promoted_constants, false,
                     MESA_SHADER_TESS_EVAL);
      if (unlikely(INTEL_DEBUG & DEBUG_TES)) {
         g.enable_debug(ralloc_asprintf(mem_ctx,
                                        "%s tessellation evaluation shader %s",
                                        nir->info.label ? nir->info.label
                                                        : "unnamed",
                                        nir->info.name));
      }

      g.generate_code(v.cfg, 8);

      return g.get_assembly(final_assembly_size);
   } else {
      brw::vec4_tes_visitor v(compiler, log_data, key, prog_data,
			      nir, mem_ctx, shader_time_index);
      if (!v.run()) {
	 if (error_str)
	    *error_str = ralloc_strdup(mem_ctx, v.fail_msg);
	 return NULL;
      }

      if (unlikely(INTEL_DEBUG & DEBUG_TES))
	 v.dump_instructions();

      return brw_vec4_generate_assembly(compiler, log_data, mem_ctx, nir,
					&prog_data->base, v.cfg,
					final_assembly_size);
   }
}
@


1.2
log
@Merge Mesa 17.1.6
@
text
@a23 1
#include "main/macros.h"
d25 2
a26 2
#include "brw_vs.h"
#include "brw_gs.h"
a27 1
#include "brw_cfg.h"
d29 2
a30 43
#include "glsl/ir_optimization.h"
#include "glsl/glsl_parser_extras.h"
#include "main/shaderapi.h"

static void
shader_debug_log_mesa(void *data, const char *fmt, ...)
{
   struct brw_context *brw = (struct brw_context *)data;
   va_list args;

   va_start(args, fmt);
   GLuint msg_id = 0;
   _mesa_gl_vdebug(&brw->ctx, &msg_id,
                   MESA_DEBUG_SOURCE_SHADER_COMPILER,
                   MESA_DEBUG_TYPE_OTHER,
                   MESA_DEBUG_SEVERITY_NOTIFICATION, fmt, args);
   va_end(args);
}

static void
shader_perf_log_mesa(void *data, const char *fmt, ...)
{
   struct brw_context *brw = (struct brw_context *)data;

   va_list args;
   va_start(args, fmt);

   if (unlikely(INTEL_DEBUG & DEBUG_PERF)) {
      va_list args_copy;
      va_copy(args_copy, args);
      vfprintf(stderr, fmt, args_copy);
      va_end(args_copy);
   }

   if (brw->perf_debug) {
      GLuint msg_id = 0;
      _mesa_gl_vdebug(&brw->ctx, &msg_id,
                      MESA_DEBUG_SOURCE_SHADER_COMPILER,
                      MESA_DEBUG_TYPE_PERFORMANCE,
                      MESA_DEBUG_SEVERITY_MEDIUM, fmt, args);
   }
   va_end(args);
}
d32 3
a34 2
struct brw_compiler *
brw_compiler_create(void *mem_ctx, const struct brw_device_info *devinfo)
d36 1
a36 1
   struct brw_compiler *compiler = rzalloc(mem_ctx, struct brw_compiler);
d38 2
a39 66
   compiler->devinfo = devinfo;
   compiler->shader_debug_log = shader_debug_log_mesa;
   compiler->shader_perf_log = shader_perf_log_mesa;

   brw_fs_alloc_reg_sets(compiler);
   brw_vec4_alloc_reg_set(compiler);

   if (devinfo->gen >= 8 && !(INTEL_DEBUG & DEBUG_VEC4VS))
      compiler->scalar_vs = true;

   nir_shader_compiler_options *nir_options =
      rzalloc(compiler, nir_shader_compiler_options);
   nir_options->native_integers = true;
   /* In order to help allow for better CSE at the NIR level we tell NIR
    * to split all ffma instructions during opt_algebraic and we then
    * re-combine them as a later step.
    */
   nir_options->lower_ffma = true;
   nir_options->lower_sub = true;

   /* We want the GLSL compiler to emit code that uses condition codes */
   for (int i = 0; i < MESA_SHADER_STAGES; i++) {
      compiler->glsl_compiler_options[i].MaxUnrollIterations = 32;
      compiler->glsl_compiler_options[i].MaxIfDepth =
         devinfo->gen < 6 ? 16 : UINT_MAX;

      compiler->glsl_compiler_options[i].EmitCondCodes = true;
      compiler->glsl_compiler_options[i].EmitNoNoise = true;
      compiler->glsl_compiler_options[i].EmitNoMainReturn = true;
      compiler->glsl_compiler_options[i].EmitNoIndirectInput = true;
      compiler->glsl_compiler_options[i].EmitNoIndirectOutput =
	 (i == MESA_SHADER_FRAGMENT);
      compiler->glsl_compiler_options[i].EmitNoIndirectTemp =
	 (i == MESA_SHADER_FRAGMENT);
      compiler->glsl_compiler_options[i].EmitNoIndirectUniform = false;
      compiler->glsl_compiler_options[i].LowerClipDistance = true;

      /* !ARB_gpu_shader5 */
      if (devinfo->gen < 7)
         compiler->glsl_compiler_options[i].EmitNoIndirectSampler = true;
   }

   compiler->glsl_compiler_options[MESA_SHADER_VERTEX].OptimizeForAOS = true;
   compiler->glsl_compiler_options[MESA_SHADER_GEOMETRY].OptimizeForAOS = true;

   if (compiler->scalar_vs || brw_env_var_as_boolean("INTEL_USE_NIR", true)) {
      if (compiler->scalar_vs) {
         /* If we're using the scalar backend for vertex shaders, we need to
          * configure these accordingly.
          */
         compiler->glsl_compiler_options[MESA_SHADER_VERTEX].EmitNoIndirectOutput = true;
         compiler->glsl_compiler_options[MESA_SHADER_VERTEX].EmitNoIndirectTemp = true;
         compiler->glsl_compiler_options[MESA_SHADER_VERTEX].OptimizeForAOS = false;
      }

      compiler->glsl_compiler_options[MESA_SHADER_VERTEX].NirOptions = nir_options;
   }

   if (brw_env_var_as_boolean("INTEL_USE_NIR", true)) {
      compiler->glsl_compiler_options[MESA_SHADER_GEOMETRY].NirOptions = nir_options;
   }

   compiler->glsl_compiler_options[MESA_SHADER_FRAGMENT].NirOptions = nir_options;
   compiler->glsl_compiler_options[MESA_SHADER_COMPUTE].NirOptions = nir_options;

   return compiler;
a41 286
struct gl_shader *
brw_new_shader(struct gl_context *ctx, GLuint name, GLuint type)
{
   struct brw_shader *shader;

   shader = rzalloc(NULL, struct brw_shader);
   if (shader) {
      shader->base.Type = type;
      shader->base.Stage = _mesa_shader_enum_to_shader_stage(type);
      shader->base.Name = name;
      _mesa_init_shader(ctx, &shader->base);
   }

   return &shader->base;
}

/**
 * Performs a compile of the shader stages even when we don't know
 * what non-orthogonal state will be set, in the hope that it reflects
 * the eventual NOS used, and thus allows us to produce link failures.
 */
static bool
brw_shader_precompile(struct gl_context *ctx,
                      struct gl_shader_program *sh_prog)
{
   struct gl_shader *vs = sh_prog->_LinkedShaders[MESA_SHADER_VERTEX];
   struct gl_shader *gs = sh_prog->_LinkedShaders[MESA_SHADER_GEOMETRY];
   struct gl_shader *fs = sh_prog->_LinkedShaders[MESA_SHADER_FRAGMENT];
   struct gl_shader *cs = sh_prog->_LinkedShaders[MESA_SHADER_COMPUTE];

   if (fs && !brw_fs_precompile(ctx, sh_prog, fs->Program))
      return false;

   if (gs && !brw_gs_precompile(ctx, sh_prog, gs->Program))
      return false;

   if (vs && !brw_vs_precompile(ctx, sh_prog, vs->Program))
      return false;

   if (cs && !brw_cs_precompile(ctx, sh_prog, cs->Program))
      return false;

   return true;
}

static inline bool
is_scalar_shader_stage(struct brw_context *brw, int stage)
{
   switch (stage) {
   case MESA_SHADER_FRAGMENT:
      return true;
   case MESA_SHADER_VERTEX:
      return brw->intelScreen->compiler->scalar_vs;
   default:
      return false;
   }
}

static void
brw_lower_packing_builtins(struct brw_context *brw,
                           gl_shader_stage shader_type,
                           exec_list *ir)
{
   int ops = LOWER_PACK_SNORM_2x16
           | LOWER_UNPACK_SNORM_2x16
           | LOWER_PACK_UNORM_2x16
           | LOWER_UNPACK_UNORM_2x16;

   if (is_scalar_shader_stage(brw, shader_type)) {
      ops |= LOWER_UNPACK_UNORM_4x8
           | LOWER_UNPACK_SNORM_4x8
           | LOWER_PACK_UNORM_4x8
           | LOWER_PACK_SNORM_4x8;
   }

   if (brw->gen >= 7) {
      /* Gen7 introduced the f32to16 and f16to32 instructions, which can be
       * used to execute packHalf2x16 and unpackHalf2x16. For AOS code, no
       * lowering is needed. For SOA code, the Half2x16 ops must be
       * scalarized.
       */
      if (is_scalar_shader_stage(brw, shader_type)) {
         ops |= LOWER_PACK_HALF_2x16_TO_SPLIT
             |  LOWER_UNPACK_HALF_2x16_TO_SPLIT;
      }
   } else {
      ops |= LOWER_PACK_HALF_2x16
          |  LOWER_UNPACK_HALF_2x16;
   }

   lower_packing_builtins(ir, ops);
}

static void
process_glsl_ir(gl_shader_stage stage,
                struct brw_context *brw,
                struct gl_shader_program *shader_prog,
                struct gl_shader *shader)
{
   struct gl_context *ctx = &brw->ctx;
   const struct gl_shader_compiler_options *options =
      &ctx->Const.ShaderCompilerOptions[shader->Stage];

   /* Temporary memory context for any new IR. */
   void *mem_ctx = ralloc_context(NULL);

   ralloc_adopt(mem_ctx, shader->ir);

   /* lower_packing_builtins() inserts arithmetic instructions, so it
    * must precede lower_instructions().
    */
   brw_lower_packing_builtins(brw, shader->Stage, shader->ir);
   do_mat_op_to_vec(shader->ir);
   const int bitfield_insert = brw->gen >= 7 ? BITFIELD_INSERT_TO_BFM_BFI : 0;
   lower_instructions(shader->ir,
                      MOD_TO_FLOOR |
                      DIV_TO_MUL_RCP |
                      SUB_TO_ADD_NEG |
                      EXP_TO_EXP2 |
                      LOG_TO_LOG2 |
                      bitfield_insert |
                      LDEXP_TO_ARITH |
                      CARRY_TO_ARITH |
                      BORROW_TO_ARITH);

   /* Pre-gen6 HW can only nest if-statements 16 deep.  Beyond this,
    * if-statements need to be flattened.
    */
   if (brw->gen < 6)
      lower_if_to_cond_assign(shader->ir, 16);

   do_lower_texture_projection(shader->ir);
   brw_lower_texture_gradients(brw, shader->ir);
   do_vec_index_to_cond_assign(shader->ir);
   lower_vector_insert(shader->ir, true);
   if (options->NirOptions == NULL)
      brw_do_cubemap_normalize(shader->ir);
   lower_offset_arrays(shader->ir);
   brw_do_lower_unnormalized_offset(shader->ir);
   lower_noise(shader->ir);
   lower_quadop_vector(shader->ir, false);

   bool lowered_variable_indexing =
      lower_variable_index_to_cond_assign((gl_shader_stage)stage,
                                          shader->ir,
                                          options->EmitNoIndirectInput,
                                          options->EmitNoIndirectOutput,
                                          options->EmitNoIndirectTemp,
                                          options->EmitNoIndirectUniform);

   if (unlikely(brw->perf_debug && lowered_variable_indexing)) {
      perf_debug("Unsupported form of variable indexing in %s; falling "
                 "back to very inefficient code generation\n",
                 _mesa_shader_stage_to_abbrev(shader->Stage));
   }

   lower_ubo_reference(shader, shader->ir);

   bool progress;
   do {
      progress = false;

      if (is_scalar_shader_stage(brw, shader->Stage)) {
         brw_do_channel_expressions(shader->ir);
         brw_do_vector_splitting(shader->ir);
      }

      progress = do_lower_jumps(shader->ir, true, true,
                                true, /* main return */
                                false, /* continue */
                                false /* loops */
                                ) || progress;

      progress = do_common_optimization(shader->ir, true, true,
                                        options, ctx->Const.NativeIntegers) || progress;
   } while (progress);

   if (options->NirOptions != NULL)
      lower_output_reads(stage, shader->ir);

   validate_ir_tree(shader->ir);

   /* Now that we've finished altering the linked IR, reparent any live IR back
    * to the permanent memory context, and free the temporary one (discarding any
    * junk we optimized away).
    */
   reparent_ir(shader->ir, shader->ir);
   ralloc_free(mem_ctx);

   if (ctx->_Shader->Flags & GLSL_DUMP) {
      fprintf(stderr, "\n");
      fprintf(stderr, "GLSL IR for linked %s program %d:\n",
              _mesa_shader_stage_to_string(shader->Stage),
              shader_prog->Name);
      _mesa_print_ir(stderr, shader->ir, NULL);
      fprintf(stderr, "\n");
   }
}

GLboolean
brw_link_shader(struct gl_context *ctx, struct gl_shader_program *shProg)
{
   struct brw_context *brw = brw_context(ctx);
   unsigned int stage;

   for (stage = 0; stage < ARRAY_SIZE(shProg->_LinkedShaders); stage++) {
      struct gl_shader *shader = shProg->_LinkedShaders[stage];
      const struct gl_shader_compiler_options *options =
         &ctx->Const.ShaderCompilerOptions[stage];

      if (!shader)
	 continue;

      struct gl_program *prog =
	 ctx->Driver.NewProgram(ctx, _mesa_shader_stage_to_program(stage),
                                shader->Name);
      if (!prog)
	return false;
      prog->Parameters = _mesa_new_parameter_list();

      _mesa_copy_linked_program_data((gl_shader_stage) stage, shProg, prog);

      process_glsl_ir((gl_shader_stage) stage, brw, shProg, shader);

      /* Make a pass over the IR to add state references for any built-in
       * uniforms that are used.  This has to be done now (during linking).
       * Code generation doesn't happen until the first time this shader is
       * used for rendering.  Waiting until then to generate the parameters is
       * too late.  At that point, the values for the built-in uniforms won't
       * get sent to the shader.
       */
      foreach_in_list(ir_instruction, node, shader->ir) {
	 ir_variable *var = node->as_variable();

	 if ((var == NULL) || (var->data.mode != ir_var_uniform)
	     || (strncmp(var->name, "gl_", 3) != 0))
	    continue;

	 const ir_state_slot *const slots = var->get_state_slots();
	 assert(slots != NULL);

	 for (unsigned int i = 0; i < var->get_num_state_slots(); i++) {
	    _mesa_add_state_reference(prog->Parameters,
				      (gl_state_index *) slots[i].tokens);
	 }
      }

      do_set_program_inouts(shader->ir, prog, shader->Stage);

      prog->SamplersUsed = shader->active_samplers;
      prog->ShadowSamplers = shader->shadow_samplers;
      _mesa_update_shader_textures_used(shProg, prog);

      _mesa_reference_program(ctx, &shader->Program, prog);

      brw_add_texrect_params(prog);

      if (options->NirOptions) {
         prog->nir = brw_create_nir(brw, shProg, prog, (gl_shader_stage) stage,
                                    is_scalar_shader_stage(brw, stage));
      }

      _mesa_reference_program(ctx, &prog, NULL);
   }

   if ((ctx->_Shader->Flags & GLSL_DUMP) && shProg->Name != 0) {
      for (unsigned i = 0; i < shProg->NumShaders; i++) {
         const struct gl_shader *sh = shProg->Shaders[i];
         if (!sh)
            continue;

         fprintf(stderr, "GLSL %s shader %d source for linked program %d:\n",
                 _mesa_shader_stage_to_string(sh->Stage),
                 i, shProg->Name);
         fprintf(stderr, "%s", sh->Source);
         fprintf(stderr, "\n");
      }
   }

   if (brw->precompile && !brw_shader_precompile(ctx, shProg))
      return false;

   return true;
}


d66 2
d71 1
a71 1
   case GLSL_TYPE_DOUBLE:
d150 1
a150 1
brw_instruction_name(enum opcode op)
d153 9
a161 3
   case BRW_OPCODE_MOV ... BRW_OPCODE_NOP:
      assert(opcode_descs[op].name);
      return opcode_descs[op].name;
a165 2
   case FS_OPCODE_BLORP_FB_WRITE:
      return "blorp_fb_write";
d168 4
d206 2
d212 2
d226 4
d250 4
d287 2
d298 10
d340 3
d347 2
a348 2
   case FS_OPCODE_VARYING_PULL_CONSTANT_LOAD:
      return "varying_pull_const";
d351 2
a373 2
   case FS_OPCODE_INTERPOLATE_AT_CENTROID:
      return "interp_centroid";
d391 3
d431 29
d472 13
a484 1
   } imm = { reg->dw1.ud }, sat_imm = { 0 };
d489 2
a494 6
   case BRW_REGISTER_TYPE_UW:
      sat_imm.ud = CLAMP(imm.ud, 0, USHRT_MAX);
      break;
   case BRW_REGISTER_TYPE_W:
      sat_imm.d = CLAMP(imm.d, SHRT_MIN, SHRT_MAX);
      break;
d498 3
a507 1
   case BRW_REGISTER_TYPE_DF:
d509 1
a509 1
      unreachable("unimplemented: saturate DF/HF immediate");
d512 10
a521 3
   if (imm.ud != sat_imm.ud) {
      reg->dw1.ud = sat_imm.ud;
      return true;
d532 1
a532 1
      reg->dw1.d = -reg->dw1.d;
d536 1
a536 1
      reg->dw1.d = -(int16_t)reg->dw1.ud;
d539 1
a539 1
      reg->dw1.f = -reg->dw1.f;
d542 4
a545 1
      reg->dw1.ud ^= 0x80808080;
a555 1
   case BRW_REGISTER_TYPE_DF:
d557 1
a557 1
      assert(!"unimplemented: negate DF/HF immediate");
d568 1
a568 1
      reg->dw1.d = abs(reg->dw1.d);
d571 1
a571 1
      reg->dw1.d = abs((int16_t)reg->dw1.ud);
d574 4
a577 1
      reg->dw1.f = fabsf(reg->dw1.f);
d580 1
a580 1
      reg->dw1.ud &= ~0x80808080;
a596 1
   case BRW_REGISTER_TYPE_DF:
d598 1
a598 1
      assert(!"unimplemented: abs DF/HF immediate");
d604 79
d686 2
a687 4
                               struct gl_shader_program *shader_prog,
                               struct gl_program *prog,
                               struct brw_stage_prog_data *stage_prog_data,
                               gl_shader_stage stage)
d691 1
a691 4
     shader(shader_prog ?
        (struct brw_shader *)shader_prog->_LinkedShaders[stage] : NULL),
     shader_prog(shader_prog),
     prog(prog),
d695 1
a695 1
     stage(stage)
d700 8
d716 11
a726 1
   return fixed_hw_reg.dw1.d == 0;
d735 11
a745 3
   return type == BRW_REGISTER_TYPE_F
          ? fixed_hw_reg.dw1.f == 1.0
          : fixed_hw_reg.dw1.d == 1;
d756 3
a758 1
      return fixed_hw_reg.dw1.f == -1.0;
d760 1
a760 1
      return fixed_hw_reg.dw1.d == -1;
d769 1
a769 3
   return file == HW_REG &&
          fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE &&
          fixed_hw_reg.nr == BRW_ARF_NULL;
d776 1
a776 12
   return file == HW_REG &&
          fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE &&
          fixed_hw_reg.nr == BRW_ARF_ACCUMULATOR;
}

bool
backend_reg::in_range(const backend_reg &r, unsigned n) const
{
   return (file == r.file &&
           reg == r.reg &&
           reg_offset >= r.reg_offset &&
           reg_offset < r.reg_offset + n);
d803 1
a803 1
backend_instruction::is_3src() const
d805 1
a805 1
   return opcode < ARRAY_SIZE(opcode_descs) && opcode_descs[opcode].nsrc == 3;
d815 1
d817 1
d821 1
d825 2
a826 1
           opcode == SHADER_OPCODE_TG4_OFFSET);
d985 1
a985 1
backend_instruction::writes_accumulator_implicitly(const struct brw_device_info *devinfo) const
d1009 3
d1013 1
d1015 19
d1058 1
a1058 1
        !block_iter->link.is_tail_sentinel();
d1068 2
d1083 2
d1144 2
a1145 1
         fprintf(file, "%4d: ", ip++);
d1151 2
a1152 1
         fprintf(file, "%4d: ", ip++);
a1169 7
void
backend_shader::invalidate_cfg()
{
   ralloc_free(this->cfg);
   this->cfg = NULL;
}

d1178 7
a1184 2
void
backend_shader::assign_common_binding_table_offsets(uint32_t next_binding_table_offset)
d1186 5
a1190 1
   int num_textures = _mesa_fls(prog->SamplersUsed);
d1196 1
d1198 5
a1202 1
      next_binding_table_offset += shader->base.NumUniformBlocks;
d1205 1
d1215 1
a1215 1
   if (prog->UsesGather) {
d1227 1
a1227 1
   if (shader_prog && shader_prog->NumAtomicBuffers) {
d1229 1
a1229 1
      next_binding_table_offset += shader_prog->NumAtomicBuffers;
d1234 1
a1234 1
   if (shader && shader->base.NumImages) {
d1236 1
a1236 1
      next_binding_table_offset += shader->base.NumImages;
d1245 11
d1257 12
d1270 2
a1271 1
   /* prog_data->base.binding_table.size will be set by brw_mark_surface_used. */
d1275 4
a1278 1
backend_shader::setup_image_uniform_values(const gl_uniform_storage *storage)
d1280 2
a1281 1
   const unsigned stage = _mesa_program_enum_to_shader_stage(prog->Target);
d1284 3
a1286 2
      const unsigned image_idx = storage->image[stage].index + i;
      const brw_image_param *param = &stage_prog_data->image_param[image_idx];
d1291 13
a1303 12
      setup_vector_uniform_values(
         (const gl_constant_value *)&param->surface_idx, 1);
      setup_vector_uniform_values(
         (const gl_constant_value *)param->offset, 2);
      setup_vector_uniform_values(
         (const gl_constant_value *)param->size, 3);
      setup_vector_uniform_values(
         (const gl_constant_value *)param->stride, 4);
      setup_vector_uniform_values(
         (const gl_constant_value *)param->tiling, 3);
      setup_vector_uniform_values(
         (const gl_constant_value *)param->swizzling, 2);
d1308 135
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d24 1
d26 3
a29 2
#include "brw_eu.h"
#include "brw_fs.h"
d31 55
a85 3
#include "brw_vec4_tes.h"
#include "main/shaderobj.h"
#include "main/uniforms.h"
d87 62
a148 1
extern "C" struct gl_shader *
d164 8
a171 3
extern "C" void
brw_mark_surface_used(struct brw_stage_prog_data *prog_data,
                      unsigned surf_index)
d173 208
a380 1
   assert(surf_index < BRW_MAX_SURFACES);
d382 49
a430 2
   prog_data->binding_table.size_bytes =
      MAX2(prog_data->binding_table.size_bytes, (surf_index + 1) * 4);
d433 1
a461 1
   case GLSL_TYPE_FUNCTION:
d543 1
a543 1
   case BRW_OPCODE_ILLEGAL ... BRW_OPCODE_NOP:
a549 2
   case FS_OPCODE_PACK_STENCIL_REF:
      return "pack_stencil_ref";
a603 4
   case SHADER_OPCODE_TXF_CMS_W:
      return "txf_cms_w";
   case SHADER_OPCODE_TXF_CMS_W_LOGICAL:
      return "txf_cms_w_logical";
a623 2
   case SHADER_OPCODE_SAMPLEINFO:
      return "sampleinfo";
a665 10
   case SHADER_OPCODE_URB_WRITE_SIMD8_PER_SLOT:
      return "gen8_urb_write_simd8_per_slot";
   case SHADER_OPCODE_URB_WRITE_SIMD8_MASKED:
      return "gen8_urb_write_simd8_masked";
   case SHADER_OPCODE_URB_WRITE_SIMD8_MASKED_PER_SLOT:
      return "gen8_urb_write_simd8_masked_per_slot";
   case SHADER_OPCODE_URB_READ_SIMD8:
      return "urb_read_simd8";
   case SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT:
      return "urb_read_simd8_per_slot";
a671 4
   case SHADER_OPCODE_EXTRACT_BYTE:
      return "extract_byte";
   case SHADER_OPCODE_EXTRACT_WORD:
      return "extract_word";
a697 3
   case FS_OPCODE_GET_BUFFER_SIZE:
      return "fs_get_buffer_size";

a745 3
   case VS_OPCODE_GET_BUFFER_SIZE:
      return "vs_get_buffer_size";

a782 29
   case SHADER_OPCODE_MOV_INDIRECT:
      return "mov_indirect";

   case VEC4_OPCODE_URB_READ:
      return "urb_read";
   case TCS_OPCODE_GET_INSTANCE_ID:
      return "tcs_get_instance_id";
   case TCS_OPCODE_URB_WRITE:
      return "tcs_urb_write";
   case TCS_OPCODE_SET_INPUT_URB_OFFSETS:
      return "tcs_set_input_urb_offsets";
   case TCS_OPCODE_SET_OUTPUT_URB_OFFSETS:
      return "tcs_set_output_urb_offsets";
   case TCS_OPCODE_GET_PRIMITIVE_ID:
      return "tcs_get_primitive_id";
   case TCS_OPCODE_CREATE_BARRIER_HEADER:
      return "tcs_create_barrier_header";
   case TCS_OPCODE_SRC0_010_IS_ZERO:
      return "tcs_src0<0,1,0>_is_zero";
   case TCS_OPCODE_RELEASE_INPUT:
      return "tcs_release_input";
   case TCS_OPCODE_THREAD_END:
      return "tcs_thread_end";
   case TES_OPCODE_CREATE_INPUT_READ_HEADER:
      return "tes_create_input_read_header";
   case TES_OPCODE_ADD_INDIRECT_URB_OFFSET:
      return "tes_add_indirect_urb_offset";
   case TES_OPCODE_GET_PRIMITIVE_ID:
      return "tes_get_primitive_id";
d795 1
a795 1
   } imm = { reg->ud }, sat_imm = { 0 };
a799 2
   case BRW_REGISTER_TYPE_UW:
   case BRW_REGISTER_TYPE_W:
d804 6
d826 1
a826 1
      reg->ud = sat_imm.ud;
d838 1
a838 1
      reg->d = -reg->d;
d842 1
a842 1
      reg->d = -(int16_t)reg->ud;
d845 1
a845 1
      reg->f = -reg->f;
d848 1
a848 1
      reg->ud ^= 0x80808080;
d872 1
a872 1
      reg->d = abs(reg->d);
d875 1
a875 1
      reg->d = abs((int16_t)reg->ud);
d878 1
a878 1
      reg->f = fabsf(reg->f);
d881 1
a881 1
      reg->ud &= ~0x80808080;
d909 4
a912 2
                               const nir_shader *shader,
                               struct brw_stage_prog_data *stage_prog_data)
d916 4
a919 1
     nir(shader),
d923 1
a923 1
     stage(shader->stage)
a930 7
backend_reg::equals(const backend_reg &r) const
{
   return memcmp((brw_reg *)this, (brw_reg *)&r, sizeof(brw_reg)) == 0 &&
          reg_offset == r.reg_offset;
}

bool
d936 1
a936 1
   return d == 0;
d946 2
a947 2
          ? f == 1.0
          : d == 1;
d958 1
a958 1
      return f == -1.0;
d960 1
a960 1
      return d == -1;
d969 3
a971 1
   return file == ARF && nr == BRW_ARF_NULL;
d978 3
a980 1
   return file == ARF && nr == BRW_ARF_ACCUMULATOR;
d987 1
a987 1
           nr == r.nr &&
d1018 1
a1018 1
   return ::is_3src(opcode);
a1028 1
           opcode == SHADER_OPCODE_TXF_CMS_W ||
d1035 1
a1035 2
           opcode == SHADER_OPCODE_TG4_OFFSET ||
           opcode == SHADER_OPCODE_SAMPLEINFO);
a1217 3
   case SHADER_OPCODE_URB_WRITE_SIMD8_PER_SLOT:
   case SHADER_OPCODE_URB_WRITE_SIMD8_MASKED:
   case SHADER_OPCODE_URB_WRITE_SIMD8_MASKED_PER_SLOT:
a1219 16
   case TCS_OPCODE_URB_WRITE:
   case TCS_OPCODE_RELEASE_INPUT:
      return true;
   default:
      return false;
   }
}

bool
backend_instruction::is_volatile() const
{
   switch (opcode) {
   case SHADER_OPCODE_UNTYPED_SURFACE_READ:
   case SHADER_OPCODE_UNTYPED_SURFACE_READ_LOGICAL:
   case SHADER_OPCODE_TYPED_SURFACE_READ:
   case SHADER_OPCODE_TYPED_SURFACE_READ_LOGICAL:
d1326 1
a1326 2
         if (!unlikely(INTEL_DEBUG & DEBUG_OPTIMIZER))
            fprintf(file, "%4d: ", ip++);
d1332 1
a1332 2
         if (!unlikely(INTEL_DEBUG & DEBUG_OPTIMIZER))
            fprintf(file, "%4d: ", ip++);
d1366 1
a1366 6
brw_assign_common_binding_table_offsets(gl_shader_stage stage,
                                        const struct brw_device_info *devinfo,
                                        const struct gl_shader_program *shader_prog,
                                        const struct gl_program *prog,
                                        struct brw_stage_prog_data *stage_prog_data,
                                        uint32_t next_binding_table_offset)
a1367 1
   const struct gl_shader *shader = NULL;
a1369 3
   if (shader_prog)
      shader = shader_prog->_LinkedShaders[stage];

a1373 1
      assert(shader->NumUniformBlocks <= BRW_MAX_UBO);
d1375 1
a1375 5
      next_binding_table_offset += shader->NumUniformBlocks;

      assert(shader->NumShaderStorageBlocks <= BRW_MAX_SSBO);
      stage_prog_data->binding_table.ssbo_start = next_binding_table_offset;
      next_binding_table_offset += shader->NumShaderStorageBlocks;
a1377 1
      stage_prog_data->binding_table.ssbo_start = 0xd0d0d0d0;
d1399 1
a1399 1
   if (shader && shader->NumAtomicBuffers) {
d1401 1
a1401 1
      next_binding_table_offset += shader->NumAtomicBuffers;
d1406 1
a1406 1
   if (shader && shader->NumImages) {
d1408 1
a1408 1
      next_binding_table_offset += shader->NumImages;
a1421 14
static void
setup_vec4_uniform_value(const gl_constant_value **params,
                         const gl_constant_value *values,
                         unsigned n)
{
   static const gl_constant_value zero = { 0 };

   for (unsigned i = 0; i < n; ++i)
      params[i] = &values[i];

   for (unsigned i = n; i < 4; ++i)
      params[i] = &zero;
}

d1423 1
a1423 4
brw_setup_image_uniform_values(gl_shader_stage stage,
                               struct brw_stage_prog_data *stage_prog_data,
                               unsigned param_start_index,
                               const gl_uniform_storage *storage)
d1425 1
a1425 2
   const gl_constant_value **param =
      &stage_prog_data->param[param_start_index];
d1428 2
a1429 3
      const unsigned image_idx = storage->opaque[stage].index + i;
      const brw_image_param *image_param =
         &stage_prog_data->image_param[image_idx];
d1434 12
a1445 13
      setup_vec4_uniform_value(param + BRW_IMAGE_PARAM_SURFACE_IDX_OFFSET,
         (const gl_constant_value *)&image_param->surface_idx, 1);
      setup_vec4_uniform_value(param + BRW_IMAGE_PARAM_OFFSET_OFFSET,
         (const gl_constant_value *)image_param->offset, 2);
      setup_vec4_uniform_value(param + BRW_IMAGE_PARAM_SIZE_OFFSET,
         (const gl_constant_value *)image_param->size, 3);
      setup_vec4_uniform_value(param + BRW_IMAGE_PARAM_STRIDE_OFFSET,
         (const gl_constant_value *)image_param->stride, 4);
      setup_vec4_uniform_value(param + BRW_IMAGE_PARAM_TILING_OFFSET,
         (const gl_constant_value *)image_param->tiling, 3);
      setup_vec4_uniform_value(param + BRW_IMAGE_PARAM_SWIZZLING_OFFSET,
         (const gl_constant_value *)image_param->swizzling, 2);
      param += BRW_IMAGE_PARAM_SIZE;
a1449 132
   }
}

/**
 * Decide which set of clip planes should be used when clipping via
 * gl_Position or gl_ClipVertex.
 */
gl_clip_plane *brw_select_clip_planes(struct gl_context *ctx)
{
   if (ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX]) {
      /* There is currently a GLSL vertex shader, so clip according to GLSL
       * rules, which means compare gl_ClipVertex (or gl_Position, if
       * gl_ClipVertex wasn't assigned) against the eye-coordinate clip planes
       * that were stored in EyeUserPlane at the time the clip planes were
       * specified.
       */
      return ctx->Transform.EyeUserPlane;
   } else {
      /* Either we are using fixed function or an ARB vertex program.  In
       * either case the clip planes are going to be compared against
       * gl_Position (which is in clip coordinates) so we have to clip using
       * _ClipUserPlane, which was transformed into clip coordinates by Mesa
       * core.
       */
      return ctx->Transform._ClipUserPlane;
   }
}

extern "C" const unsigned *
brw_compile_tes(const struct brw_compiler *compiler,
                void *log_data,
                void *mem_ctx,
                const struct brw_tes_prog_key *key,
                struct brw_tes_prog_data *prog_data,
                const nir_shader *src_shader,
                struct gl_shader_program *shader_prog,
                int shader_time_index,
                unsigned *final_assembly_size,
                char **error_str)
{
   const struct brw_device_info *devinfo = compiler->devinfo;
   struct gl_shader *shader =
      shader_prog->_LinkedShaders[MESA_SHADER_TESS_EVAL];
   const bool is_scalar = compiler->scalar_stage[MESA_SHADER_TESS_EVAL];

   nir_shader *nir = nir_shader_clone(mem_ctx, src_shader);
   nir = brw_nir_apply_sampler_key(nir, devinfo, &key->tex, is_scalar);
   nir->info.inputs_read = key->inputs_read;
   nir->info.patch_inputs_read = key->patch_inputs_read;
   nir = brw_nir_lower_io(nir, compiler->devinfo, is_scalar, false, NULL);
   nir = brw_postprocess_nir(nir, compiler->devinfo, is_scalar);

   brw_compute_vue_map(devinfo, &prog_data->base.vue_map,
                       nir->info.outputs_written,
                       nir->info.separate_shader);

   unsigned output_size_bytes = prog_data->base.vue_map.num_slots * 4 * 4;

   assert(output_size_bytes >= 1);
   if (output_size_bytes > GEN7_MAX_DS_URB_ENTRY_SIZE_BYTES) {
      if (error_str)
         *error_str = ralloc_strdup(mem_ctx, "DS outputs exceed maximum size");
      return NULL;
   }

   /* URB entry sizes are stored as a multiple of 64 bytes. */
   prog_data->base.urb_entry_size = ALIGN(output_size_bytes, 64) / 64;

   struct brw_vue_map input_vue_map;
   brw_compute_tess_vue_map(&input_vue_map,
                            nir->info.inputs_read & ~VARYING_BIT_PRIMITIVE_ID,
                            nir->info.patch_inputs_read);

   bool need_patch_header = nir->info.system_values_read &
      (BITFIELD64_BIT(SYSTEM_VALUE_TESS_LEVEL_OUTER) |
       BITFIELD64_BIT(SYSTEM_VALUE_TESS_LEVEL_INNER));

   /* The TES will pull most inputs using URB read messages.
    *
    * However, we push the patch header for TessLevel factors when required,
    * as it's a tiny amount of extra data.
    */
   prog_data->base.urb_read_length = need_patch_header ? 1 : 0;

   if (unlikely(INTEL_DEBUG & DEBUG_TES)) {
      fprintf(stderr, "TES Input ");
      brw_print_vue_map(stderr, &input_vue_map);
      fprintf(stderr, "TES Output ");
      brw_print_vue_map(stderr, &prog_data->base.vue_map);
   }

   if (is_scalar) {
      fs_visitor v(compiler, log_data, mem_ctx, (void *) key,
                   &prog_data->base.base, shader->Program, nir, 8,
                   shader_time_index, &input_vue_map);
      if (!v.run_tes()) {
         if (error_str)
            *error_str = ralloc_strdup(mem_ctx, v.fail_msg);
         return NULL;
      }

      prog_data->base.dispatch_mode = DISPATCH_MODE_SIMD8;

      fs_generator g(compiler, log_data, mem_ctx, (void *) key,
                     &prog_data->base.base, v.promoted_constants, false,
                     MESA_SHADER_TESS_EVAL);
      if (unlikely(INTEL_DEBUG & DEBUG_TES)) {
         g.enable_debug(ralloc_asprintf(mem_ctx,
                                        "%s tessellation evaluation shader %s",
                                        nir->info.label ? nir->info.label
                                                        : "unnamed",
                                        nir->info.name));
      }

      g.generate_code(v.cfg, 8);

      return g.get_assembly(final_assembly_size);
   } else {
      brw::vec4_tes_visitor v(compiler, log_data, key, prog_data,
			      nir, mem_ctx, shader_time_index);
      if (!v.run()) {
	 if (error_str)
	    *error_str = ralloc_strdup(mem_ctx, v.fail_msg);
	 return NULL;
      }

      if (unlikely(INTEL_DEBUG & DEBUG_TES))
	 v.dump_instructions();

      return brw_vec4_generate_assembly(compiler, log_data, mem_ctx, nir,
					&prog_data->base, v.cfg,
					final_assembly_size);
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d30 1
d33 16
a82 2
   case GLSL_TYPE_DOUBLE:
      return BRW_REGISTER_TYPE_DF;
d86 1
d166 1
a166 1
brw_instruction_name(const struct gen_device_info *devinfo, enum opcode op)
d170 2
a171 8
      /* The DO instruction doesn't exist on Gen6+, but we use it to mark the
       * start of a loop in the IR.
       */
      if (devinfo->gen >= 6 && op == BRW_OPCODE_DO)
         return "do";

      assert(brw_opcode_desc(devinfo, op)->name);
      return brw_opcode_desc(devinfo, op)->name;
d176 4
a181 4
   case FS_OPCODE_FB_READ:
      return "fb_read";
   case FS_OPCODE_FB_READ_LOGICAL:
      return "fb_read_logical";
a215 2
   case SHADER_OPCODE_TXF_LZ:
      return "txf_lz";
a219 2
   case SHADER_OPCODE_TXL_LZ:
      return "txl_lz";
a257 2
   case SHADER_OPCODE_SAMPLEINFO_LOGICAL:
      return "sampleinfo_logical";
a290 2
   case FS_OPCODE_PACK:
      return "pack";
d316 4
d353 2
a354 2
   case FS_OPCODE_VARYING_PULL_CONSTANT_LOAD_GEN4:
      return "varying_pull_const_gen4";
a356 2
   case FS_OPCODE_VARYING_PULL_CONSTANT_LOAD_LOGICAL:
      return "varying_pull_const_logical";
d378 2
d478 1
a478 13
      double df;
   } imm, sat_imm = { 0 };

   const unsigned size = type_sz(type);

   /* We want to either do a 32-bit or 64-bit data copy, the type is otherwise
    * irrelevant, so just check the size of the type and copy from/to an
    * appropriately sized field.
    */
   if (size < 8)
      imm.ud = reg->ud;
   else
      imm.df = reg->df;
a491 3
   case BRW_REGISTER_TYPE_DF:
      sat_imm.df = CLAMP(imm.df, 0.0, 1.0);
      break;
d499 1
d501 1
a501 1
      unreachable("unimplemented: saturate HF immediate");
d504 3
a506 10
   if (size < 8) {
      if (imm.ud != sat_imm.ud) {
         reg->ud = sat_imm.ud;
         return true;
      }
   } else {
      if (imm.df != sat_imm.df) {
         reg->df = sat_imm.df;
         return true;
      }
a528 3
   case BRW_REGISTER_TYPE_DF:
      reg->df = -reg->df;
      return true;
d538 1
d540 1
a540 1
      assert(!"unimplemented: negate HF immediate");
a558 3
   case BRW_REGISTER_TYPE_DF:
      reg->df = fabs(reg->df);
      return true;
d577 1
d579 1
a579 1
      assert(!"unimplemented: abs HF immediate");
a584 79
/**
 * Get the appropriate atomic op for an image atomic intrinsic.
 */
unsigned
get_atomic_counter_op(nir_intrinsic_op op)
{
   switch (op) {
   case nir_intrinsic_atomic_counter_inc:
      return BRW_AOP_INC;
   case nir_intrinsic_atomic_counter_dec:
      return BRW_AOP_PREDEC;
   case nir_intrinsic_atomic_counter_add:
      return BRW_AOP_ADD;
   case nir_intrinsic_atomic_counter_min:
      return BRW_AOP_UMIN;
   case nir_intrinsic_atomic_counter_max:
      return BRW_AOP_UMAX;
   case nir_intrinsic_atomic_counter_and:
      return BRW_AOP_AND;
   case nir_intrinsic_atomic_counter_or:
      return BRW_AOP_OR;
   case nir_intrinsic_atomic_counter_xor:
      return BRW_AOP_XOR;
   case nir_intrinsic_atomic_counter_exchange:
      return BRW_AOP_MOV;
   case nir_intrinsic_atomic_counter_comp_swap:
      return BRW_AOP_CMPWR;
   default:
      unreachable("Not reachable.");
   }
}

unsigned
tesslevel_outer_components(GLenum tes_primitive_mode)
{
   switch (tes_primitive_mode) {
   case GL_QUADS:
      return 4;
   case GL_TRIANGLES:
      return 3;
   case GL_ISOLINES:
      return 2;
   default:
      unreachable("Bogus tessellation domain");
   }
   return 0;
}

unsigned
tesslevel_inner_components(GLenum tes_primitive_mode)
{
   switch (tes_primitive_mode) {
   case GL_QUADS:
      return 2;
   case GL_TRIANGLES:
      return 1;
   case GL_ISOLINES:
      return 0;
   default:
      unreachable("Bogus tessellation domain");
   }
   return 0;
}

/**
 * Given a normal .xyzw writemask, convert it to a writemask for a vector
 * that's stored backwards, i.e. .wzyx.
 */
unsigned
writemask_for_backwards_vector(unsigned mask)
{
   unsigned new_mask = 0;

   for (int i = 0; i < 4; i++)
      new_mask |= ((mask >> i) & 1) << (3 - i);

   return new_mask;
}

a601 2
   is_passthrough_shader =
      nir->info.name && strcmp(nir->info.name, "passthrough") == 0;
d607 2
a608 1
   return brw_regs_equal(this, &r) && offset == r.offset;
d617 1
a617 11
   switch (type) {
   case BRW_REGISTER_TYPE_F:
      return f == 0;
   case BRW_REGISTER_TYPE_DF:
      return df == 0;
   case BRW_REGISTER_TYPE_D:
   case BRW_REGISTER_TYPE_UD:
      return d == 0;
   default:
      return false;
   }
d626 3
a628 11
   switch (type) {
   case BRW_REGISTER_TYPE_F:
      return f == 1.0f;
   case BRW_REGISTER_TYPE_DF:
      return df == 1.0;
   case BRW_REGISTER_TYPE_D:
   case BRW_REGISTER_TYPE_UD:
      return d == 1;
   default:
      return false;
   }
a639 2
   case BRW_REGISTER_TYPE_DF:
      return df == -1.0;
d661 9
d693 1
a693 1
backend_instruction::is_3src(const struct gen_device_info *devinfo) const
d695 1
a695 1
   return ::is_3src(devinfo, opcode);
a704 1
           opcode == SHADER_OPCODE_TXF_LZ ||
a709 1
           opcode == SHADER_OPCODE_TXL_LZ ||
d873 1
a873 1
backend_instruction::writes_accumulator_implicitly(const struct gen_device_info *devinfo) const
a900 1
   case FS_OPCODE_FB_WRITE_LOGICAL:
a917 3
   case SHADER_OPCODE_URB_READ_SIMD8:
   case SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT:
   case VEC4_OPCODE_URB_READ:
d942 1
a942 1
        block_iter;
a951 2
   assert(this != inst);

a964 2
   assert(this != inst);

d1050 7
d1065 1
a1065 1
uint32_t
d1067 1
a1067 1
                                        const struct gen_device_info *devinfo,
d1073 2
a1074 2
   const struct gl_linked_shader *shader = NULL;
   int num_textures = util_last_bit(prog->SamplersUsed);
d1102 1
a1102 1
   if (prog->nir->info.uses_texture_gather) {
d1132 1
a1132 8
   /* Plane 0 is just the regular texture section */
   stage_prog_data->binding_table.plane_start[0] = stage_prog_data->binding_table.texture_start;

   stage_prog_data->binding_table.plane_start[1] = next_binding_table_offset;
   next_binding_table_offset += num_textures;

   stage_prog_data->binding_table.plane_start[2] = next_binding_table_offset;
   next_binding_table_offset += num_textures;
a1134 3

   assert(next_binding_table_offset <= BRW_MAX_SURFACES);
   return next_binding_table_offset;
d1225 2
a1226 2
   const struct gen_device_info *devinfo = compiler->devinfo;
   struct gl_linked_shader *shader =
d1231 1
d1234 1
a1234 9

   struct brw_vue_map input_vue_map;
   brw_compute_tess_vue_map(&input_vue_map,
                            nir->info.inputs_read & ~VARYING_BIT_PRIMITIVE_ID,
                            nir->info.patch_inputs_read);

   nir = brw_nir_apply_sampler_key(nir, devinfo, &key->tex, is_scalar);
   brw_nir_lower_tes_inputs(nir, &input_vue_map);
   brw_nir_lower_vue_outputs(nir, is_scalar);
d1253 5
a1285 1
      prog_data->base.base.dispatch_grf_start_reg = v.payload.num_regs;
@


