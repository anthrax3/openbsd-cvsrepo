head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.40.09;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.40.09;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.15.27;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.37.08;	author jsg;	state Exp;
branches;
next	;
commitid	uuv5VTS15jglEDZU;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright Â© 2014 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include "brw_nir.h"
#include "glsl/glsl_parser_extras.h"
#include "glsl/nir/glsl_to_nir.h"
#include "program/prog_to_nir.h"

static void
nir_optimize(nir_shader *nir, bool is_scalar)
{
   bool progress;
   do {
      progress = false;
      nir_lower_vars_to_ssa(nir);
      nir_validate_shader(nir);

      if (is_scalar) {
         nir_lower_alu_to_scalar(nir);
         nir_validate_shader(nir);
      }

      progress |= nir_copy_prop(nir);
      nir_validate_shader(nir);

      if (is_scalar) {
         nir_lower_phis_to_scalar(nir);
         nir_validate_shader(nir);
      }

      progress |= nir_copy_prop(nir);
      nir_validate_shader(nir);
      progress |= nir_opt_dce(nir);
      nir_validate_shader(nir);
      progress |= nir_opt_cse(nir);
      nir_validate_shader(nir);
      progress |= nir_opt_peephole_select(nir);
      nir_validate_shader(nir);
      progress |= nir_opt_algebraic(nir);
      nir_validate_shader(nir);
      progress |= nir_opt_constant_folding(nir);
      nir_validate_shader(nir);
      progress |= nir_opt_remove_phis(nir);
      nir_validate_shader(nir);
   } while (progress);
}

nir_shader *
brw_create_nir(struct brw_context *brw,
               const struct gl_shader_program *shader_prog,
               const struct gl_program *prog,
               gl_shader_stage stage,
               bool is_scalar)
{
   struct gl_context *ctx = &brw->ctx;
   const nir_shader_compiler_options *options =
      ctx->Const.ShaderCompilerOptions[stage].NirOptions;
   struct gl_shader *shader = shader_prog ? shader_prog->_LinkedShaders[stage] : NULL;
   bool debug_enabled = INTEL_DEBUG & intel_debug_flag_for_shader_stage(stage);
   nir_shader *nir;

   /* First, lower the GLSL IR or Mesa IR to NIR */
   if (shader_prog) {
      nir = glsl_to_nir(shader, options);
   } else {
      nir = prog_to_nir(prog, options);
      nir_convert_to_ssa(nir); /* turn registers into SSA */
   }
   nir_validate_shader(nir);

   nir_lower_global_vars_to_local(nir);
   nir_validate_shader(nir);

   nir_lower_tex_projector(nir);
   nir_validate_shader(nir);

   nir_normalize_cubemap_coords(nir);
   nir_validate_shader(nir);

   nir_split_var_copies(nir);
   nir_validate_shader(nir);

   nir_optimize(nir, is_scalar);

   /* Lower a bunch of stuff */
   nir_lower_var_copies(nir);
   nir_validate_shader(nir);

   /* Get rid of split copies */
   nir_optimize(nir, is_scalar);

   if (is_scalar) {
      nir_assign_var_locations_direct_first(nir, &nir->uniforms,
                                            &nir->num_direct_uniforms,
                                            &nir->num_uniforms,
                                            is_scalar);
      nir_assign_var_locations(&nir->outputs, &nir->num_outputs, is_scalar);
   } else {
      nir_assign_var_locations(&nir->uniforms,
                               &nir->num_uniforms,
                               is_scalar);

      foreach_list_typed(nir_variable, var, node, &nir->outputs)
         var->data.driver_location = var->data.location;
   }
   nir_assign_var_locations(&nir->inputs, &nir->num_inputs, is_scalar);

   nir_lower_io(nir, is_scalar);

   nir_validate_shader(nir);

   nir_remove_dead_variables(nir);
   nir_validate_shader(nir);

   if (shader_prog) {
      nir_lower_samplers(nir, shader_prog, stage);
      nir_validate_shader(nir);
   }

   nir_lower_system_values(nir);
   nir_validate_shader(nir);

   nir_lower_atomics(nir);
   nir_validate_shader(nir);

   nir_optimize(nir, is_scalar);

   if (brw->gen >= 6) {
      /* Try and fuse multiply-adds */
      nir_opt_peephole_ffma(nir);
      nir_validate_shader(nir);
   }

   nir_opt_algebraic_late(nir);
   nir_validate_shader(nir);

   nir_lower_locals_to_regs(nir);
   nir_validate_shader(nir);

   nir_lower_to_source_mods(nir);
   nir_validate_shader(nir);
   nir_copy_prop(nir);
   nir_validate_shader(nir);
   nir_opt_dce(nir);
   nir_validate_shader(nir);

   if (unlikely(debug_enabled)) {
      /* Re-index SSA defs so we print more sensible numbers. */
      nir_foreach_overload(nir, overload) {
         if (overload->impl)
            nir_index_ssa_defs(overload->impl);
      }

      fprintf(stderr, "NIR (SSA form) for %s shader:\n",
              _mesa_shader_stage_to_string(stage));
      nir_print_shader(nir, stderr);
   }

   nir_convert_from_ssa(nir, is_scalar);
   nir_validate_shader(nir);

   if (!is_scalar) {
      nir_lower_vec_to_movs(nir);
      nir_validate_shader(nir);
   }

   /* This is the last pass we run before we start emitting stuff.  It
    * determines when we need to insert boolean resolves on Gen <= 5.  We
    * run it last because it stashes data in instr->pass_flags and we don't
    * want that to be squashed by other NIR passes.
    */
   if (brw->gen <= 5)
      brw_nir_analyze_boolean_resolves(nir);

   nir_sweep(nir);

   if (unlikely(debug_enabled)) {
      fprintf(stderr, "NIR (final form) for %s shader:\n",
              _mesa_shader_stage_to_string(stage));
      nir_print_shader(nir, stderr);
   }

   return nir;
}

enum brw_reg_type
brw_type_for_nir_type(nir_alu_type type)
{
   switch (type) {
   case nir_type_unsigned:
      return BRW_REGISTER_TYPE_UD;
   case nir_type_bool:
   case nir_type_int:
      return BRW_REGISTER_TYPE_D;
   case nir_type_float:
      return BRW_REGISTER_TYPE_F;
   default:
      unreachable("unknown type");
   }

   return BRW_REGISTER_TYPE_F;
}

/* Returns the glsl_base_type corresponding to a nir_alu_type.
 * This is used by both brw_vec4_nir and brw_fs_nir.
 */
enum glsl_base_type
brw_glsl_base_type_for_nir_type(nir_alu_type type)
{
   switch (type) {
   case nir_type_float:
      return GLSL_TYPE_FLOAT;

   case nir_type_int:
      return GLSL_TYPE_INT;

   case nir_type_unsigned:
      return GLSL_TYPE_UINT;

   default:
      unreachable("bad type");
   }
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d25 2
a26 3
#include "brw_shader.h"
#include "compiler/nir/glsl_to_nir.h"
#include "compiler/nir/nir_builder.h"
a28 175
static bool
is_input(nir_intrinsic_instr *intrin)
{
   return intrin->intrinsic == nir_intrinsic_load_input ||
          intrin->intrinsic == nir_intrinsic_load_per_vertex_input;
}

static bool
is_output(nir_intrinsic_instr *intrin)
{
   return intrin->intrinsic == nir_intrinsic_load_output ||
          intrin->intrinsic == nir_intrinsic_load_per_vertex_output ||
          intrin->intrinsic == nir_intrinsic_store_output ||
          intrin->intrinsic == nir_intrinsic_store_per_vertex_output;
}

/**
 * In many cases, we just add the base and offset together, so there's no
 * reason to keep them separate.  Sometimes, combining them is essential:
 * if a shader only accesses part of a compound variable (such as a matrix
 * or array), the variable's base may not actually exist in the VUE map.
 *
 * This pass adds constant offsets to instr->const_index[0], and resets
 * the offset source to 0.  Non-constant offsets remain unchanged - since
 * we don't know what part of a compound variable is accessed, we allocate
 * storage for the entire thing.
 */
struct add_const_offset_to_base_params {
   nir_builder b;
   nir_variable_mode mode;
};

static bool
add_const_offset_to_base_block(nir_block *block, void *closure)
{
   struct add_const_offset_to_base_params *params = closure;
   nir_builder *b = &params->b;

   nir_foreach_instr_safe(block, instr) {
      if (instr->type != nir_instr_type_intrinsic)
         continue;

      nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);

      if ((params->mode == nir_var_shader_in && is_input(intrin)) ||
          (params->mode == nir_var_shader_out && is_output(intrin))) {
         nir_src *offset = nir_get_io_offset_src(intrin);
         nir_const_value *const_offset = nir_src_as_const_value(*offset);

         if (const_offset) {
            intrin->const_index[0] += const_offset->u[0];
            b->cursor = nir_before_instr(&intrin->instr);
            nir_instr_rewrite_src(&intrin->instr, offset,
                                  nir_src_for_ssa(nir_imm_int(b, 0)));
         }
      }
   }
   return true;
}

static void
add_const_offset_to_base(nir_shader *nir, nir_variable_mode mode)
{
   struct add_const_offset_to_base_params params = { .mode = mode };

   nir_foreach_function(nir, f) {
      if (f->impl) {
         nir_builder_init(&params.b, f->impl);
         nir_foreach_block(f->impl, add_const_offset_to_base_block, &params);
      }
   }
}

static bool
remap_vs_attrs(nir_block *block, void *closure)
{
   GLbitfield64 inputs_read = *((GLbitfield64 *) closure);

   nir_foreach_instr(block, instr) {
      if (instr->type != nir_instr_type_intrinsic)
         continue;

      nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);

      if (intrin->intrinsic == nir_intrinsic_load_input) {
         /* Attributes come in a contiguous block, ordered by their
          * gl_vert_attrib value.  That means we can compute the slot
          * number for an attribute by masking out the enabled attributes
          * before it and counting the bits.
          */
         int attr = intrin->const_index[0];
         int slot = _mesa_bitcount_64(inputs_read & BITFIELD64_MASK(attr));

         intrin->const_index[0] = 4 * slot;
      }
   }
   return true;
}

static bool
remap_inputs_with_vue_map(nir_block *block, void *closure)
{
   const struct brw_vue_map *vue_map = closure;

   nir_foreach_instr(block, instr) {
      if (instr->type != nir_instr_type_intrinsic)
         continue;

      nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);

      if (intrin->intrinsic == nir_intrinsic_load_input ||
          intrin->intrinsic == nir_intrinsic_load_per_vertex_input) {
         int vue_slot = vue_map->varying_to_slot[intrin->const_index[0]];
         assert(vue_slot != -1);
         intrin->const_index[0] = vue_slot;
      }
   }
   return true;
}

struct remap_patch_urb_offsets_state {
   nir_builder b;
   struct brw_vue_map vue_map;
};

static bool
remap_patch_urb_offsets(nir_block *block, void *closure)
{
   struct remap_patch_urb_offsets_state *state = closure;

   nir_foreach_instr_safe(block, instr) {
      if (instr->type != nir_instr_type_intrinsic)
         continue;

      nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);

      gl_shader_stage stage = state->b.shader->stage;

      if ((stage == MESA_SHADER_TESS_CTRL && is_output(intrin)) ||
          (stage == MESA_SHADER_TESS_EVAL && is_input(intrin))) {
         int vue_slot = state->vue_map.varying_to_slot[intrin->const_index[0]];
         assert(vue_slot != -1);
         intrin->const_index[0] = vue_slot;

         nir_src *vertex = nir_get_io_vertex_index_src(intrin);
         if (vertex) {
            nir_const_value *const_vertex = nir_src_as_const_value(*vertex);
            if (const_vertex) {
               intrin->const_index[0] += const_vertex->u[0] *
                                         state->vue_map.num_per_vertex_slots;
            } else {
               state->b.cursor = nir_before_instr(&intrin->instr);

               /* Multiply by the number of per-vertex slots. */
               nir_ssa_def *vertex_offset =
                  nir_imul(&state->b,
                           nir_ssa_for_src(&state->b, *vertex, 1),
                           nir_imm_int(&state->b,
                                       state->vue_map.num_per_vertex_slots));

               /* Add it to the existing offset */
               nir_src *offset = nir_get_io_offset_src(intrin);
               nir_ssa_def *total_offset =
                  nir_iadd(&state->b, vertex_offset,
                           nir_ssa_for_src(&state->b, *offset, 1));

               nir_instr_rewrite_src(&intrin->instr, offset,
                                     nir_src_for_ssa(total_offset));
            }
         }
      }
   }
   return true;
}

a29 222
brw_nir_lower_inputs(nir_shader *nir,
                     const struct brw_device_info *devinfo,
                     bool is_scalar,
                     bool use_legacy_snorm_formula,
                     const uint8_t *vs_attrib_wa_flags)
{
   switch (nir->stage) {
   case MESA_SHADER_VERTEX:
      /* Start with the location of the variable's base. */
      foreach_list_typed(nir_variable, var, node, &nir->inputs) {
         var->data.driver_location = var->data.location;
      }

      /* Now use nir_lower_io to walk dereference chains.  Attribute arrays
       * are loaded as one vec4 per element (or matrix column), so we use
       * type_size_vec4 here.
       */
      nir_lower_io(nir, nir_var_shader_in, type_size_vec4);

      /* This pass needs actual constants */
      nir_opt_constant_folding(nir);

      add_const_offset_to_base(nir, nir_var_shader_in);

      brw_nir_apply_attribute_workarounds(nir, use_legacy_snorm_formula,
                                          vs_attrib_wa_flags);

      if (is_scalar) {
         /* Finally, translate VERT_ATTRIB_* values into the actual registers.
          *
          * Note that we can use nir->info.inputs_read instead of
          * key->inputs_read since the two are identical aside from Gen4-5
          * edge flag differences.
          */
         GLbitfield64 inputs_read = nir->info.inputs_read;

         nir_foreach_function(nir, function) {
            if (function->impl) {
               nir_foreach_block(function->impl, remap_vs_attrs, &inputs_read);
            }
         }
      }
      break;
   case MESA_SHADER_TESS_CTRL:
   case MESA_SHADER_GEOMETRY: {
      if (!is_scalar && nir->stage == MESA_SHADER_GEOMETRY) {
         foreach_list_typed(nir_variable, var, node, &nir->inputs) {
            var->data.driver_location = var->data.location;
         }
      } else {
         /* The GLSL linker will have already matched up GS inputs and
          * the outputs of prior stages.  The driver does extend VS outputs
          * in some cases, but only for legacy OpenGL or Gen4-5 hardware,
          * neither of which offer geometry shader support.  So we can
          * safely ignore that.
          *
          * For SSO pipelines, we use a fixed VUE map layout based on variable
          * locations, so we can rely on rendezvous-by-location to make this
          * work.
          *
          * However, we need to ignore VARYING_SLOT_PRIMITIVE_ID, as it's not
          * written by previous stages and shows up via payload magic.
          */
         struct brw_vue_map input_vue_map;
         GLbitfield64 inputs_read =
            nir->info.inputs_read & ~VARYING_BIT_PRIMITIVE_ID;
         brw_compute_vue_map(devinfo, &input_vue_map, inputs_read,
                             nir->info.separate_shader ||
                             nir->stage == MESA_SHADER_TESS_CTRL);

         foreach_list_typed(nir_variable, var, node, &nir->inputs) {
            var->data.driver_location = var->data.location;
         }

         /* Inputs are stored in vec4 slots, so use type_size_vec4(). */
         nir_lower_io(nir, nir_var_shader_in, type_size_vec4);

         /* This pass needs actual constants */
         nir_opt_constant_folding(nir);

         add_const_offset_to_base(nir, nir_var_shader_in);

         nir_foreach_function(nir, function) {
            if (function->impl) {
               nir_foreach_block(function->impl, remap_inputs_with_vue_map,
                                 &input_vue_map);
            }
         }
      }
      break;
   }
   case MESA_SHADER_TESS_EVAL: {
      struct remap_patch_urb_offsets_state state;
      brw_compute_tess_vue_map(&state.vue_map,
                               nir->info.inputs_read & ~VARYING_BIT_PRIMITIVE_ID,
                               nir->info.patch_inputs_read);

      foreach_list_typed(nir_variable, var, node, &nir->inputs) {
         var->data.driver_location = var->data.location;
      }

      nir_lower_io(nir, nir_var_shader_in, type_size_vec4);

      /* This pass needs actual constants */
      nir_opt_constant_folding(nir);

      add_const_offset_to_base(nir, nir_var_shader_in);

      nir_foreach_function(nir, function) {
         if (function->impl) {
            nir_builder_init(&state.b, function->impl);
            nir_foreach_block(function->impl, remap_patch_urb_offsets, &state);
         }
      }
      break;
   }
   case MESA_SHADER_FRAGMENT:
      assert(is_scalar);
      nir_assign_var_locations(&nir->inputs, &nir->num_inputs,
                               type_size_scalar);
      break;
   case MESA_SHADER_COMPUTE:
      /* Compute shaders have no inputs. */
      assert(exec_list_is_empty(&nir->inputs));
      break;
   default:
      unreachable("unsupported shader stage");
   }
}

static void
brw_nir_lower_outputs(nir_shader *nir,
                      const struct brw_device_info *devinfo,
                      bool is_scalar)
{
   switch (nir->stage) {
   case MESA_SHADER_VERTEX:
   case MESA_SHADER_TESS_EVAL:
   case MESA_SHADER_GEOMETRY:
      if (is_scalar) {
         nir_assign_var_locations(&nir->outputs, &nir->num_outputs,
                                  type_size_vec4_times_4);
         nir_lower_io(nir, nir_var_shader_out, type_size_vec4_times_4);
      } else {
         nir_foreach_variable(var, &nir->outputs)
            var->data.driver_location = var->data.location;
      }
      break;
   case MESA_SHADER_TESS_CTRL: {
      struct remap_patch_urb_offsets_state state;
      brw_compute_tess_vue_map(&state.vue_map, nir->info.outputs_written,
                               nir->info.patch_outputs_written);

      nir_foreach_variable(var, &nir->outputs) {
         var->data.driver_location = var->data.location;
      }

      nir_lower_io(nir, nir_var_shader_out, type_size_vec4);

      /* This pass needs actual constants */
      nir_opt_constant_folding(nir);

      add_const_offset_to_base(nir, nir_var_shader_out);

      nir_foreach_function(nir, function) {
         if (function->impl) {
            nir_builder_init(&state.b, function->impl);
            nir_foreach_block(function->impl, remap_patch_urb_offsets, &state);
         }
      }
      break;
   }
   case MESA_SHADER_FRAGMENT:
      nir_assign_var_locations(&nir->outputs, &nir->num_outputs,
                               type_size_scalar);
      break;
   case MESA_SHADER_COMPUTE:
      /* Compute shaders have no outputs. */
      assert(exec_list_is_empty(&nir->outputs));
      break;
   default:
      unreachable("unsupported shader stage");
   }
}

static int
type_size_scalar_bytes(const struct glsl_type *type)
{
   return type_size_scalar(type) * 4;
}

static int
type_size_vec4_bytes(const struct glsl_type *type)
{
   return type_size_vec4(type) * 16;
}

static void
brw_nir_lower_uniforms(nir_shader *nir, bool is_scalar)
{
   if (is_scalar) {
      nir_assign_var_locations(&nir->uniforms, &nir->num_uniforms,
                               type_size_scalar_bytes);
      nir_lower_io(nir, nir_var_uniform, type_size_scalar_bytes);
   } else {
      nir_assign_var_locations(&nir->uniforms, &nir->num_uniforms,
                               type_size_vec4_bytes);
      nir_lower_io(nir, nir_var_uniform, type_size_vec4_bytes);
   }
}

#define OPT(pass, ...) ({                                  \
   bool this_progress = false;                             \
   NIR_PASS(this_progress, nir, pass, ##__VA_ARGS__);      \
   if (this_progress)                                      \
      progress = true;                                     \
   this_progress;                                          \
})

#define OPT_V(pass, ...) NIR_PASS_V(nir, pass, ##__VA_ARGS__)

static nir_shader *
d35 2
a36 1
      OPT_V(nir_lower_vars_to_ssa);
d39 2
a40 1
         OPT_V(nir_lower_alu_to_scalar);
d43 2
a44 1
      OPT(nir_copy_prop);
d47 2
a48 1
         OPT_V(nir_lower_phis_to_scalar);
d51 14
a64 9
      OPT(nir_copy_prop);
      OPT(nir_opt_dce);
      OPT(nir_opt_cse);
      OPT(nir_opt_peephole_select);
      OPT(nir_opt_algebraic);
      OPT(nir_opt_constant_folding);
      OPT(nir_opt_dead_cf);
      OPT(nir_opt_remove_phis);
      OPT(nir_opt_undef);
a65 2

   return nir;
a67 9
/* Does some simple lowering and runs the standard suite of optimizations
 *
 * This is intended to be called more-or-less directly after you get the
 * shader out of GLSL or some other source.  While it is geared towards i965,
 * it is not at all generator-specific except for the is_scalar flag.  Even
 * there, it is safe to call with is_scalar = false for a shader that is
 * intended for the FS backend as long as nir_optimize is called again with
 * is_scalar = true to scalarize everything prior to code gen.
 */
d69 5
a73 1
brw_preprocess_nir(nir_shader *nir, bool is_scalar)
d75 6
a80 2
   bool progress; /* Written by OPT and OPT_V */
   (void)progress;
d82 8
a89 2
   if (nir->stage == MESA_SHADER_GEOMETRY)
      OPT(nir_lower_gs_intrinsics);
d91 2
a92 3
   static const nir_lower_tex_options tex_options = {
      .lower_txp = ~0,
   };
d94 2
a95 2
   OPT(nir_lower_tex, &tex_options);
   OPT(nir_normalize_cubemap_coords);
d97 2
a98 1
   OPT(nir_lower_global_vars_to_local);
d100 2
a101 1
   OPT(nir_split_var_copies);
d103 1
a103 5
   nir = nir_optimize(nir, is_scalar);

   if (is_scalar) {
      OPT_V(nir_lower_load_const_to_scalar);
   }
d106 2
a107 1
   OPT_V(nir_lower_var_copies);
d110 1
a110 1
   nir = nir_optimize(nir, is_scalar);
d112 10
a121 1
   OPT(nir_remove_dead_variables);
d123 8
a130 2
   return nir;
}
d132 2
a133 10
/** Lower input and output loads and stores for i965. */
nir_shader *
brw_nir_lower_io(nir_shader *nir,
                 const struct brw_device_info *devinfo,
                 bool is_scalar,
                 bool use_legacy_snorm_formula,
                 const uint8_t *vs_attrib_wa_flags)
{
   bool progress; /* Written by OPT and OPT_V */
   (void)progress;
d135 4
a138 4
   OPT_V(brw_nir_lower_inputs, devinfo, is_scalar,
         use_legacy_snorm_formula, vs_attrib_wa_flags);
   OPT_V(brw_nir_lower_outputs, devinfo, is_scalar);
   OPT_V(nir_lower_io, nir_var_all, is_scalar ? type_size_scalar : type_size_vec4);
d140 2
a141 2
   return nir_optimize(nir, is_scalar);
}
d143 2
a144 14
/* Prepare the given shader for codegen
 *
 * This function is intended to be called right before going into the actual
 * backend and is highly backend-specific.  Also, once this function has been
 * called on a shader, it will no longer be in SSA form so most optimizations
 * will not work.
 */
nir_shader *
brw_postprocess_nir(nir_shader *nir,
                    const struct brw_device_info *devinfo,
                    bool is_scalar)
{
   bool debug_enabled =
      (INTEL_DEBUG & intel_debug_flag_for_shader_stage(nir->stage));
d146 1
a146 2
   bool progress; /* Written by OPT and OPT_V */
   (void)progress;
d148 1
a148 1
   if (devinfo->gen >= 6) {
d150 2
a151 1
      OPT(brw_nir_opt_peephole_ffma);
d154 2
a155 1
   OPT(nir_opt_algebraic_late);
d157 2
a158 1
   OPT(nir_lower_locals_to_regs);
d160 6
a165 3
   OPT_V(nir_lower_to_source_mods);
   OPT(nir_copy_prop);
   OPT(nir_opt_dce);
d169 3
a171 3
      nir_foreach_function(nir, function) {
         if (function->impl)
            nir_index_ssa_defs(function->impl);
d175 1
a175 1
              _mesa_shader_stage_to_string(nir->stage));
d179 2
a180 1
   OPT_V(nir_convert_from_ssa, true);
d183 2
a184 2
      OPT_V(nir_move_vec_src_uses_to_dest);
      OPT(nir_lower_vec_to_movs);
d192 1
a192 1
   if (devinfo->gen <= 5)
d199 1
a199 1
              _mesa_shader_stage_to_string(nir->stage));
a205 81
nir_shader *
brw_create_nir(struct brw_context *brw,
               const struct gl_shader_program *shader_prog,
               const struct gl_program *prog,
               gl_shader_stage stage,
               bool is_scalar)
{
   struct gl_context *ctx = &brw->ctx;
   const struct brw_device_info *devinfo = brw->intelScreen->devinfo;
   const nir_shader_compiler_options *options =
      ctx->Const.ShaderCompilerOptions[stage].NirOptions;
   bool progress;
   nir_shader *nir;

   /* First, lower the GLSL IR or Mesa IR to NIR */
   if (shader_prog) {
      nir = glsl_to_nir(shader_prog, stage, options);
   } else {
      nir = prog_to_nir(prog, options);
      OPT_V(nir_convert_to_ssa); /* turn registers into SSA */
   }
   nir_validate_shader(nir);

   (void)progress;

   nir = brw_preprocess_nir(nir, is_scalar);

   OPT(nir_lower_system_values);
   OPT_V(brw_nir_lower_uniforms, is_scalar);

   if (shader_prog) {
      OPT_V(nir_lower_samplers, shader_prog);
      OPT_V(nir_lower_atomics, shader_prog);
   }

   if (nir->stage != MESA_SHADER_VERTEX &&
       nir->stage != MESA_SHADER_TESS_CTRL &&
       nir->stage != MESA_SHADER_TESS_EVAL) {
      nir = brw_nir_lower_io(nir, devinfo, is_scalar, false, NULL);
   }

   return nir;
}

nir_shader *
brw_nir_apply_sampler_key(nir_shader *nir,
                          const struct brw_device_info *devinfo,
                          const struct brw_sampler_prog_key_data *key_tex,
                          bool is_scalar)
{
   nir_lower_tex_options tex_options = { 0 };

   /* Iron Lake and prior require lowering of all rectangle textures */
   if (devinfo->gen < 6)
      tex_options.lower_rect = true;

   /* Prior to Broadwell, our hardware can't actually do GL_CLAMP */
   if (devinfo->gen < 8) {
      tex_options.saturate_s = key_tex->gl_clamp_mask[0];
      tex_options.saturate_t = key_tex->gl_clamp_mask[1];
      tex_options.saturate_r = key_tex->gl_clamp_mask[2];
   }

   /* Prior to Haswell, we have to fake texture swizzle */
   for (unsigned s = 0; s < MAX_SAMPLERS; s++) {
      if (key_tex->swizzles[s] == SWIZZLE_NOOP)
         continue;

      tex_options.swizzle_result |= (1 << s);
      for (unsigned c = 0; c < 4; c++)
         tex_options.swizzles[s][c] = GET_SWZ(key_tex->swizzles[s], c);
   }

   if (nir_lower_tex(nir, &tex_options)) {
      nir_validate_shader(nir);
      nir = nir_optimize(nir, is_scalar);
   }

   return nir;
}

d210 1
a210 1
   case nir_type_uint:
d237 1
a237 1
   case nir_type_uint:
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d26 1
a26 1
#include "compiler/glsl_types.h"
d28 1
d34 1
a34 2
          intrin->intrinsic == nir_intrinsic_load_per_vertex_input ||
          intrin->intrinsic == nir_intrinsic_load_interpolated_input;
d57 4
d63 1
a63 2
add_const_offset_to_base_block(nir_block *block, nir_builder *b,
                               nir_variable_mode mode)
d65 4
a68 1
   nir_foreach_instr_safe(instr, block) {
d74 2
a75 2
      if ((mode == nir_var_shader_in && is_input(intrin)) ||
          (mode == nir_var_shader_out && is_output(intrin))) {
d80 1
a80 1
            intrin->const_index[0] += const_offset->u32[0];
d93 3
a95 1
   nir_foreach_function(f, nir) {
d97 2
a98 5
         nir_builder b;
         nir_builder_init(&b, f->impl);
         nir_foreach_block(block, f->impl) {
            add_const_offset_to_base_block(block, &b, mode);
         }
d104 1
a104 1
remap_vs_attrs(nir_block *block, struct nir_shader_info *nir_info)
d106 3
a108 1
   nir_foreach_instr(instr, block) {
d121 3
a123 5
         int slot = _mesa_bitcount_64(nir_info->inputs_read &
                                      BITFIELD64_MASK(attr));
         int dslot = _mesa_bitcount_64(nir_info->double_inputs_read &
                                       BITFIELD64_MASK(attr));
         intrin->const_index[0] = 4 * (slot + dslot);
d130 1
a130 1
remap_inputs_with_vue_map(nir_block *block, const struct brw_vue_map *vue_map)
d132 3
a134 1
   nir_foreach_instr(instr, block) {
d150 5
d156 1
a156 2
remap_patch_urb_offsets(nir_block *block, nir_builder *b,
                        const struct brw_vue_map *vue_map)
d158 3
a160 1
   nir_foreach_instr_safe(instr, block) {
d166 1
a166 1
      gl_shader_stage stage = b->shader->stage;
d170 1
a170 1
         int vue_slot = vue_map->varying_to_slot[intrin->const_index[0]];
d178 2
a179 2
               intrin->const_index[0] += const_vertex->u32[0] *
                                         vue_map->num_per_vertex_slots;
d181 1
a181 1
               b->cursor = nir_before_instr(&intrin->instr);
d185 4
a188 4
                  nir_imul(b,
                           nir_ssa_for_src(b, *vertex, 1),
                           nir_imm_int(b,
                                       vue_map->num_per_vertex_slots));
d193 2
a194 2
                  nir_iadd(b, vertex_offset,
                           nir_ssa_for_src(b, *offset, 1));
d205 19
a223 10
void
brw_nir_lower_vs_inputs(nir_shader *nir,
                        bool is_scalar,
                        bool use_legacy_snorm_formula,
                        const uint8_t *vs_attrib_wa_flags)
{
   /* Start with the location of the variable's base. */
   foreach_list_typed(nir_variable, var, node, &nir->inputs) {
      var->data.driver_location = var->data.location;
   }
d225 2
a226 5
   /* Now use nir_lower_io to walk dereference chains.  Attribute arrays are
    * loaded as one vec4 or dvec4 per element (or matrix column), depending on
    * whether it is a double-precision type or not.
    */
   nir_lower_io(nir, nir_var_shader_in, type_size_vs_input, 0);
d228 1
a228 2
   /* This pass needs actual constants */
   nir_opt_constant_folding(nir);
d230 2
a231 1
   add_const_offset_to_base(nir, nir_var_shader_in);
d233 8
a240 5
   brw_nir_apply_attribute_workarounds(nir, use_legacy_snorm_formula,
                                       vs_attrib_wa_flags);

   if (is_scalar) {
      /* Finally, translate VERT_ATTRIB_* values into the actual registers. */
d242 3
a244 4
      nir_foreach_function(function, nir) {
         if (function->impl) {
            nir_foreach_block(block, function->impl) {
               remap_vs_attrs(block, &nir->info);
d248 27
a274 2
   }
}
d276 3
a278 7
void
brw_nir_lower_vue_inputs(nir_shader *nir, bool is_scalar,
                         const struct brw_vue_map *vue_map)
{
   foreach_list_typed(nir_variable, var, node, &nir->inputs) {
      var->data.driver_location = var->data.location;
   }
d280 2
a281 2
   /* Inputs are stored in vec4 slots, so use type_size_vec4(). */
   nir_lower_io(nir, nir_var_shader_in, type_size_vec4, 0);
d283 2
a284 3
   if (is_scalar || nir->stage != MESA_SHADER_GEOMETRY) {
      /* This pass needs actual constants */
      nir_opt_constant_folding(nir);
d286 1
a286 1
      add_const_offset_to_base(nir, nir_var_shader_in);
d288 4
a291 4
      nir_foreach_function(function, nir) {
         if (function->impl) {
            nir_foreach_block(block, function->impl) {
               remap_inputs_with_vue_map(block, vue_map);
d295 1
d297 5
a301 1
}
d303 3
a305 6
void
brw_nir_lower_tes_inputs(nir_shader *nir, const struct brw_vue_map *vue_map)
{
   foreach_list_typed(nir_variable, var, node, &nir->inputs) {
      var->data.driver_location = var->data.location;
   }
d307 1
a307 1
   nir_lower_io(nir, nir_var_shader_in, type_size_vec4, 0);
d309 2
a310 2
   /* This pass needs actual constants */
   nir_opt_constant_folding(nir);
d312 1
a312 1
   add_const_offset_to_base(nir, nir_var_shader_in);
d314 4
a317 6
   nir_foreach_function(function, nir) {
      if (function->impl) {
         nir_builder b;
         nir_builder_init(&b, function->impl);
         nir_foreach_block(block, function->impl) {
            remap_patch_urb_offsets(block, &b, vue_map);
d320 13
d336 22
a357 21
void
brw_nir_lower_fs_inputs(nir_shader *nir,
                        const struct gen_device_info *devinfo,
                        const struct brw_wm_prog_key *key)
{
   foreach_list_typed(nir_variable, var, node, &nir->inputs) {
      var->data.driver_location = var->data.location;

      /* Apply default interpolation mode.
       *
       * Everything defaults to smooth except for the legacy GL color
       * built-in variables, which might be flat depending on API state.
       */
      if (var->data.interpolation == INTERP_MODE_NONE) {
         const bool flat = key->flat_shade &&
            (var->data.location == VARYING_SLOT_COL0 ||
             var->data.location == VARYING_SLOT_COL1);

         var->data.interpolation = flat ? INTERP_MODE_FLAT
                                        : INTERP_MODE_SMOOTH;
      }
d359 2
a360 7
      /* On Ironlake and below, there is only one interpolation mode.
       * Centroid interpolation doesn't mean anything on this hardware --
       * there is no multisampling.
       */
      if (devinfo->gen < 6) {
         var->data.centroid = false;
         var->data.sample = false;
a361 1
   }
d363 1
a363 3
   nir_lower_io_options lower_io_options = 0;
   if (key->persample_interp)
      lower_io_options |= nir_lower_io_force_sample_interpolation;
d365 2
a366 1
   nir_lower_io(nir, nir_var_shader_in, type_size_vec4, lower_io_options);
d368 1
a368 2
   /* This pass needs actual constants */
   nir_opt_constant_folding(nir);
d370 19
a388 1
   add_const_offset_to_base(nir, nir_var_shader_in);
d391 2
a392 3
void
brw_nir_lower_vue_outputs(nir_shader *nir,
                          bool is_scalar)
d394 1
a394 5
   nir_foreach_variable(var, &nir->outputs) {
      var->data.driver_location = var->data.location;
   }

   nir_lower_io(nir, nir_var_shader_out, type_size_vec4, 0);
d397 2
a398 2
void
brw_nir_lower_tcs_outputs(nir_shader *nir, const struct brw_vue_map *vue_map)
d400 1
a400 20
   nir_foreach_variable(var, &nir->outputs) {
      var->data.driver_location = var->data.location;
   }

   nir_lower_io(nir, nir_var_shader_out, type_size_vec4, 0);

   /* This pass needs actual constants */
   nir_opt_constant_folding(nir);

   add_const_offset_to_base(nir, nir_var_shader_out);

   nir_foreach_function(function, nir) {
      if (function->impl) {
         nir_builder b;
         nir_builder_init(&b, function->impl);
         nir_foreach_block(block, function->impl) {
            remap_patch_urb_offsets(block, &b, vue_map);
         }
      }
   }
d403 2
a404 2
void
brw_nir_lower_fs_outputs(nir_shader *nir)
d406 8
a413 4
   nir_foreach_variable(var, &nir->outputs) {
      var->data.driver_location =
         SET_FIELD(var->data.index, BRW_NIR_FRAG_OUTPUT_INDEX) |
         SET_FIELD(var->data.location, BRW_NIR_FRAG_OUTPUT_LOCATION);
a414 10

   nir_lower_io(nir, nir_var_shader_out, type_size_dvec4, 0);
}

void
brw_nir_lower_cs_shared(nir_shader *nir)
{
   nir_assign_var_locations(&nir->shared, &nir->num_shared, 0,
                            type_size_scalar_bytes);
   nir_lower_io(nir, nir_var_shared, type_size_scalar_bytes, 0);
d436 1
a436 1
         OPT(nir_lower_alu_to_scalar);
d442 1
a442 1
         OPT(nir_lower_phis_to_scalar);
d448 1
a448 1
      OPT(nir_opt_peephole_select, 0);
a453 10
      OPT_V(nir_lower_doubles, nir_lower_drcp |
                               nir_lower_dsqrt |
                               nir_lower_drsq |
                               nir_lower_dtrunc |
                               nir_lower_dfloor |
                               nir_lower_dceil |
                               nir_lower_dfract |
                               nir_lower_dround_even |
                               nir_lower_dmod);
      OPT_V(nir_lower_double_pack);
d469 1
a469 1
brw_preprocess_nir(const struct brw_compiler *compiler, nir_shader *nir)
a473 2
   const bool is_scalar = compiler->scalar_stage[nir->stage];

a476 3
   if (compiler->precise_trig)
      OPT(brw_nir_apply_trig_workarounds);

a478 2
      .lower_txf_offset = true,
      .lower_rect_offset = true,
d500 1
a500 1
   OPT(nir_remove_dead_variables, nir_var_local);
d505 19
d533 1
a533 1
                    const struct gen_device_info *devinfo,
a541 2
   nir = nir_optimize(nir, is_scalar);

d557 1
a557 1
      nir_foreach_function(function, nir) {
d594 44
d639 1
a639 1
                          const struct gen_device_info *devinfo,
a665 4
   tex_options.lower_y_uv_external = key_tex->y_uv_image_mask;
   tex_options.lower_y_u_v_external = key_tex->y_u_v_image_mask;
   tex_options.lower_yx_xuxv_external = key_tex->yx_xuxv_image_mask;

a678 1
   case nir_type_uint32:
a681 2
   case nir_type_bool32:
   case nir_type_int32:
a683 1
   case nir_type_float32:
a684 8
   case nir_type_float64:
      return BRW_REGISTER_TYPE_DF;
   case nir_type_int64:
   case nir_type_uint64:
      /* TODO we should only see these in moves, so for now it's ok, but when
       * we add actual 64-bit integer support we should fix this.
       */
      return BRW_REGISTER_TYPE_DF;
a699 1
   case nir_type_float32:
a701 3
   case nir_type_float64:
      return GLSL_TYPE_DOUBLE;

a702 1
   case nir_type_int32:
a705 1
   case nir_type_uint32:
@


