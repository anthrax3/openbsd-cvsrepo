head	1.5;
access;
symbols
	mesa-17_1_6:1.1.1.4
	OPENBSD_6_1:1.3.0.2
	OPENBSD_6_1_BASE:1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.3.0.4
	OPENBSD_6_0_BASE:1.3
	mesa-11_2_2:1.1.1.3
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	mesa-11_0_9:1.1.1.2
	mesa-11_0_8:1.1.1.2
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2017.08.26.16.59.36;	author jsg;	state Exp;
branches;
next	1.4;
commitid	D0k2io1oY8gcsQ2S;

1.4
date	2017.08.14.09.58.00;	author jsg;	state Exp;
branches;
next	1.3;
commitid	bC4bLqwWTo4kLw82;

1.3
date	2016.05.29.10.40.27;	author jsg;	state Exp;
branches;
next	1.2;
commitid	lFAjX4nNEOTq8hSb;

1.2
date	2016.01.07.23.41.25;	author jsg;	state Exp;
branches;
next	1.1;
commitid	kTG7q8kbzqf43AFg;

1.1
date	2015.11.22.02.40.45;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.40.45;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2015.12.23.13.22.47;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	bCnCUEGWDw3j16Q3;

1.1.1.3
date	2016.05.29.10.16.04;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.4
date	2017.08.14.09.42.54;	author jsg;	state Exp;
branches;
next	;
commitid	enNyoMGkcgwM3Ww6;


desc
@@


1.5
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * XML DRI client-side driver configuration
 * Copyright (C) 2003 Felix Kuehling
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * FELIX KUEHLING, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 */
/**
 * \file xmlconfig.c
 * \brief Driver-independent client-side part of the XML configuration
 * \author Felix Kuehling
 */

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <expat.h>
#include <fcntl.h>
#include <math.h>
#include <unistd.h>
#include <errno.h>
#include "main/imports.h"
#include "utils.h"
#include "xmlconfig.h"

#undef GET_PROGRAM_NAME

#if (defined(__GNU_LIBRARY__) || defined(__GLIBC__)) && !defined(__UCLIBC__)
#    if !defined(__GLIBC__) || (__GLIBC__ < 2)
/* These aren't declared in any libc5 header */
extern char *program_invocation_name, *program_invocation_short_name;
#    endif
#    define GET_PROGRAM_NAME() program_invocation_short_name
#elif defined(__CYGWIN__)
#    define GET_PROGRAM_NAME() program_invocation_short_name
#elif defined(__FreeBSD__) && (__FreeBSD__ >= 2)
#    include <osreldate.h>
#    if (__FreeBSD_version >= 440000)
#        include <stdlib.h>
#        define GET_PROGRAM_NAME() getprogname()
#    endif
#elif defined(__NetBSD__) && defined(__NetBSD_Version__) && (__NetBSD_Version__ >= 106000100)
#    include <stdlib.h>
#    define GET_PROGRAM_NAME() getprogname()
#elif defined(__DragonFly__)
#    include <stdlib.h>
#    define GET_PROGRAM_NAME() getprogname()
#elif defined(__APPLE__)
#    include <stdlib.h>
#    define GET_PROGRAM_NAME() getprogname()
#elif defined(__sun)
/* Solaris has getexecname() which returns the full path - return just
   the basename to match BSD getprogname() */
#    include <stdlib.h>
#    include <libgen.h>

static const char *__getProgramName () {
    static const char *progname;

    if (progname == NULL) {
	const char *e = getexecname();
	if (e != NULL) {
	    /* Have to make a copy since getexecname can return a readonly
	       string, but basename expects to be able to modify its arg. */
	    char *n = strdup(e);
	    if (n != NULL) {
		progname = basename(n);
	    }
	}
    }
    return progname;
}

#    define GET_PROGRAM_NAME() __getProgramName()
#endif

#if !defined(GET_PROGRAM_NAME)
#    if defined(__OpenBSD__) || defined(NetBSD) || defined(__UCLIBC__) || defined(ANDROID)
/* This is a hack. It's said to work on OpenBSD, NetBSD and GNU.
 * Rogelio M.Serrano Jr. reported it's also working with UCLIBC. It's
 * used as a last resort, if there is no documented facility available. */
static const char *__getProgramName () {
    extern const char *__progname;
    char * arg = strrchr(__progname, '/');
    if (arg)
        return arg+1;
    else
        return __progname;
}
#        define GET_PROGRAM_NAME() __getProgramName()
#    else
#        define GET_PROGRAM_NAME() ""
#        warning "Per application configuration won't work with your OS version."
#    endif
#endif

/** \brief Find an option in an option cache with the name as key */
static uint32_t findOption (const driOptionCache *cache, const char *name) {
    uint32_t len = strlen (name);
    uint32_t size = 1 << cache->tableSize, mask = size - 1;
    uint32_t hash = 0;
    uint32_t i, shift;

  /* compute a hash from the variable length name */
    for (i = 0, shift = 0; i < len; ++i, shift = (shift+8) & 31)
	hash += (uint32_t)name[i] << shift;
    hash *= hash;
    hash = (hash >> (16-cache->tableSize/2)) & mask;

  /* this is just the starting point of the linear search for the option */
    for (i = 0; i < size; ++i, hash = (hash+1) & mask) {
      /* if we hit an empty entry then the option is not defined (yet) */
	if (cache->info[hash].name == 0)
	    break;
	else if (!strcmp (name, cache->info[hash].name))
	    break;
    }
  /* this assertion fails if the hash table is full */
    assert (i < size);

    return hash;
}

/** \brief Like strdup but using malloc and with error checking. */
#define XSTRDUP(dest,source) do { \
    uint32_t len = strlen (source); \
    if (!(dest = malloc(len+1))) { \
	fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__); \
	abort(); \
    } \
    memcpy (dest, source, len+1); \
} while (0)

static int compare (const void *a, const void *b) {
    return strcmp (*(char *const*)a, *(char *const*)b);
}
/** \brief Binary search in a string array. */
static uint32_t bsearchStr (const XML_Char *name,
			  const XML_Char *elems[], uint32_t count) {
    const XML_Char **found;
    found = bsearch (&name, elems, count, sizeof (XML_Char *), compare);
    if (found)
	return found - elems;
    else
	return count;
}

/** \brief Locale-independent integer parser.
 *
 * Works similar to strtol. Leading space is NOT skipped. The input
 * number may have an optional sign. Radix is specified by base. If
 * base is 0 then decimal is assumed unless the input number is
 * prefixed by 0x or 0X for hexadecimal or 0 for octal. After
 * returning tail points to the first character that is not part of
 * the integer number. If no number was found then tail points to the
 * start of the input string. */
static int strToI (const XML_Char *string, const XML_Char **tail, int base) {
    int radix = base == 0 ? 10 : base;
    int result = 0;
    int sign = 1;
    bool numberFound = false;
    const XML_Char *start = string;

    assert (radix >= 2 && radix <= 36);

    if (*string == '-') {
	sign = -1;
	string++;
    } else if (*string == '+')
	string++;
    if (base == 0 && *string == '0') {
	numberFound = true;
	if (*(string+1) == 'x' || *(string+1) == 'X') {
	    radix = 16;
	    string += 2;
	} else {
	    radix = 8;
	    string++;
	}
    }
    do {
	int digit = -1;
	if (radix <= 10) {
	    if (*string >= '0' && *string < '0' + radix)
		digit = *string - '0';
	} else {
	    if (*string >= '0' && *string <= '9')
		digit = *string - '0';
	    else if (*string >= 'a' && *string < 'a' + radix - 10)
		digit = *string - 'a' + 10;
	    else if (*string >= 'A' && *string < 'A' + radix - 10)
		digit = *string - 'A' + 10;
	}
	if (digit != -1) {
	    numberFound = true;
	    result = radix*result + digit;
	    string++;
	} else
	    break;
    } while (true);
    *tail = numberFound ? string : start;
    return sign * result;
}

/** \brief Locale-independent floating-point parser.
 *
 * Works similar to strtod. Leading space is NOT skipped. The input
 * number may have an optional sign. '.' is interpreted as decimal
 * point and may occur at most once. Optionally the number may end in
 * [eE]<exponent>, where <exponent> is an integer as recognized by
 * strToI. In that case the result is number * 10^exponent. After
 * returning tail points to the first character that is not part of
 * the floating point number. If no number was found then tail points
 * to the start of the input string.
 *
 * Uses two passes for maximum accuracy. */
static float strToF (const XML_Char *string, const XML_Char **tail) {
    int nDigits = 0, pointPos, exponent;
    float sign = 1.0f, result = 0.0f, scale;
    const XML_Char *start = string, *numStart;

    /* sign */
    if (*string == '-') {
	sign = -1.0f;
	string++;
    } else if (*string == '+')
	string++;

    /* first pass: determine position of decimal point, number of
     * digits, exponent and the end of the number. */
    numStart = string;
    while (*string >= '0' && *string <= '9') {
	string++;
	nDigits++;
    }
    pointPos = nDigits;
    if (*string == '.') {
	string++;
	while (*string >= '0' && *string <= '9') {
	    string++;
	    nDigits++;
	}
    }
    if (nDigits == 0) {
	/* no digits, no number */
	*tail = start;
	return 0.0f;
    }
    *tail = string;
    if (*string == 'e' || *string == 'E') {
	const XML_Char *expTail;
	exponent = strToI (string+1, &expTail, 10);
	if (expTail == string+1)
	    exponent = 0;
	else
	    *tail = expTail;
    } else
	exponent = 0;
    string = numStart;

    /* scale of the first digit */
    scale = sign * (float)pow (10.0, (double)(pointPos-1 + exponent));

    /* second pass: parse digits */
    do {
	if (*string != '.') {
	    assert (*string >= '0' && *string <= '9');
	    result += scale * (float)(*string - '0');
	    scale *= 0.1f;
	    nDigits--;
	}
	string++;
    } while (nDigits > 0);

    return result;
}

/** \brief Parse a value of a given type. */
static unsigned char parseValue (driOptionValue *v, driOptionType type,
			     const XML_Char *string) {
    const XML_Char *tail = NULL;
  /* skip leading white-space */
    string += strspn (string, " \f\n\r\t\v");
    switch (type) {
      case DRI_BOOL:
	if (!strcmp (string, "false")) {
	    v->_bool = false;
	    tail = string + 5;
	} else if (!strcmp (string, "true")) {
	    v->_bool = true;
	    tail = string + 4;
	}
	else
	    return false;
	break;
      case DRI_ENUM: /* enum is just a special integer */
      case DRI_INT:
	v->_int = strToI (string, &tail, 0);
	break;
      case DRI_FLOAT:
	v->_float = strToF (string, &tail);
	break;
      case DRI_STRING:
	free (v->_string);
	v->_string = strndup(string, STRING_CONF_MAXLEN);
	return GL_TRUE;
    }

    if (tail == string)
	return false; /* empty string (or containing only white-space) */
  /* skip trailing white space */
    if (*tail)
	tail += strspn (tail, " \f\n\r\t\v");
    if (*tail)
	return false; /* something left over that is not part of value */

    return true;
}

/** \brief Parse a list of ranges of type info->type. */
static unsigned char parseRanges (driOptionInfo *info, const XML_Char *string) {
    XML_Char *cp, *range;
    uint32_t nRanges, i;
    driOptionRange *ranges;

    XSTRDUP (cp, string);
  /* pass 1: determine the number of ranges (number of commas + 1) */
    range = cp;
    for (nRanges = 1; *range; ++range)
	if (*range == ',')
	    ++nRanges;

    if ((ranges = malloc(nRanges*sizeof(driOptionRange))) == NULL) {
	fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
	abort();
    }

  /* pass 2: parse all ranges into preallocated array */
    range = cp;
    for (i = 0; i < nRanges; ++i) {
	XML_Char *end, *sep;
	assert (range);
	end = strchr (range, ',');
	if (end)
	    *end = '\0';
	sep = strchr (range, ':');
	if (sep) { /* non-empty interval */
	    *sep = '\0';
	    if (!parseValue (&ranges[i].start, info->type, range) ||
		!parseValue (&ranges[i].end, info->type, sep+1))
	        break;
	    if (info->type == DRI_INT &&
		ranges[i].start._int > ranges[i].end._int)
		break;
	    if (info->type == DRI_FLOAT &&
		ranges[i].start._float > ranges[i].end._float)
		break;
	} else { /* empty interval */
	    if (!parseValue (&ranges[i].start, info->type, range))
		break;
	    ranges[i].end = ranges[i].start;
	}
	if (end)
	    range = end+1;
	else
	    range = NULL;
    }
    free(cp);
    if (i < nRanges) {
	free(ranges);
	return false;
    } else
	assert (range == NULL);

    info->nRanges = nRanges;
    info->ranges = ranges;
    return true;
}

/** \brief Check if a value is in one of info->ranges. */
static bool checkValue (const driOptionValue *v, const driOptionInfo *info) {
    uint32_t i;
    assert (info->type != DRI_BOOL); /* should be caught by the parser */
    if (info->nRanges == 0)
	return true;
    switch (info->type) {
      case DRI_ENUM: /* enum is just a special integer */
      case DRI_INT:
	for (i = 0; i < info->nRanges; ++i)
	    if (v->_int >= info->ranges[i].start._int &&
		v->_int <= info->ranges[i].end._int)
		return true;
	break;
      case DRI_FLOAT:
	for (i = 0; i < info->nRanges; ++i)
	    if (v->_float >= info->ranges[i].start._float &&
		v->_float <= info->ranges[i].end._float)
		return true;
	break;
      case DRI_STRING:
	break;
      default:
	assert (0); /* should never happen */
    }
    return false;
}

/**
 * Print message to \c stderr if the \c LIBGL_DEBUG environment variable
 * is set. 
 * 
 * Is called from the drivers.
 * 
 * \param f \c printf like format string.
 */
static void
__driUtilMessage(const char *f, ...)
{
    va_list args;
    const char *libgl_debug;

    libgl_debug=getenv("LIBGL_DEBUG");
    if (libgl_debug && !strstr(libgl_debug, "quiet")) {
        fprintf(stderr, "libGL: ");
        va_start(args, f);
        vfprintf(stderr, f, args);
        va_end(args);
        fprintf(stderr, "\n");
    }
}

/** \brief Output a warning message. */
#define XML_WARNING1(msg) do {\
    __driUtilMessage ("Warning in %s line %d, column %d: "msg, data->name, \
                      (int) XML_GetCurrentLineNumber(data->parser), \
                      (int) XML_GetCurrentColumnNumber(data->parser)); \
} while (0)
#define XML_WARNING(msg,args...) do { \
    __driUtilMessage ("Warning in %s line %d, column %d: "msg, data->name, \
                      (int) XML_GetCurrentLineNumber(data->parser), \
                      (int) XML_GetCurrentColumnNumber(data->parser), \
                      args); \
} while (0)
/** \brief Output an error message. */
#define XML_ERROR1(msg) do { \
    __driUtilMessage ("Error in %s line %d, column %d: "msg, data->name, \
                      (int) XML_GetCurrentLineNumber(data->parser), \
                      (int) XML_GetCurrentColumnNumber(data->parser)); \
} while (0)
#define XML_ERROR(msg,args...) do { \
    __driUtilMessage ("Error in %s line %d, column %d: "msg, data->name, \
                      (int) XML_GetCurrentLineNumber(data->parser), \
                      (int) XML_GetCurrentColumnNumber(data->parser), \
                      args); \
} while (0)
/** \brief Output a fatal error message and abort. */
#define XML_FATAL1(msg) do { \
    fprintf (stderr, "Fatal error in %s line %d, column %d: "msg"\n", \
             data->name, \
             (int) XML_GetCurrentLineNumber(data->parser),	\
             (int) XML_GetCurrentColumnNumber(data->parser)); \
    abort();\
} while (0)
#define XML_FATAL(msg,args...) do { \
    fprintf (stderr, "Fatal error in %s line %d, column %d: "msg"\n", \
             data->name, \
             (int) XML_GetCurrentLineNumber(data->parser),	\
             (int) XML_GetCurrentColumnNumber(data->parser),		\
             args); \
    abort();\
} while (0)

/** \brief Parser context for __driConfigOptions. */
struct OptInfoData {
    const char *name;
    XML_Parser parser;
    driOptionCache *cache;
    bool inDriInfo;
    bool inSection;
    bool inDesc;
    bool inOption;
    bool inEnum;
    int curOption;
};

/** \brief Elements in __driConfigOptions. */
enum OptInfoElem {
    OI_DESCRIPTION = 0, OI_DRIINFO, OI_ENUM, OI_OPTION, OI_SECTION, OI_COUNT
};
static const XML_Char *OptInfoElems[] = {
    "description", "driinfo", "enum", "option", "section"
};

/** \brief Parse attributes of an enum element.
 *
 * We're not actually interested in the data. Just make sure this is ok
 * for external configuration tools.
 */
static void parseEnumAttr (struct OptInfoData *data, const XML_Char **attr) {
    uint32_t i;
    const XML_Char *value = NULL, *text = NULL;
    driOptionValue v;
    uint32_t opt = data->curOption;
    for (i = 0; attr[i]; i += 2) {
	if (!strcmp (attr[i], "value")) value = attr[i+1];
	else if (!strcmp (attr[i], "text")) text = attr[i+1];
	else XML_FATAL("illegal enum attribute: %s.", attr[i]);
    }
    if (!value) XML_FATAL1 ("value attribute missing in enum.");
    if (!text) XML_FATAL1 ("text attribute missing in enum.");
     if (!parseValue (&v, data->cache->info[opt].type, value))
	XML_FATAL ("illegal enum value: %s.", value);
    if (!checkValue (&v, &data->cache->info[opt]))
	XML_FATAL ("enum value out of valid range: %s.", value);
}

/** \brief Parse attributes of a description element.
 *
 * We're not actually interested in the data. Just make sure this is ok
 * for external configuration tools.
 */
static void parseDescAttr (struct OptInfoData *data, const XML_Char **attr) {
    uint32_t i;
    const XML_Char *lang = NULL, *text = NULL;
    for (i = 0; attr[i]; i += 2) {
	if (!strcmp (attr[i], "lang")) lang = attr[i+1];
	else if (!strcmp (attr[i], "text")) text = attr[i+1];
	else XML_FATAL("illegal description attribute: %s.", attr[i]);
    }
    if (!lang) XML_FATAL1 ("lang attribute missing in description.");
    if (!text) XML_FATAL1 ("text attribute missing in description.");
}

/** \brief Parse attributes of an option element. */
static void parseOptInfoAttr (struct OptInfoData *data, const XML_Char **attr) {
    enum OptAttr {OA_DEFAULT = 0, OA_NAME, OA_TYPE, OA_VALID, OA_COUNT};
    static const XML_Char *optAttr[] = {"default", "name", "type", "valid"};
    const XML_Char *attrVal[OA_COUNT] = {NULL, NULL, NULL, NULL};
    const char *defaultVal;
    driOptionCache *cache = data->cache;
    uint32_t opt, i;
    for (i = 0; attr[i]; i += 2) {
	uint32_t attrName = bsearchStr (attr[i], optAttr, OA_COUNT);
	if (attrName >= OA_COUNT)
	    XML_FATAL ("illegal option attribute: %s", attr[i]);
	attrVal[attrName] = attr[i+1];
    }
    if (!attrVal[OA_NAME]) XML_FATAL1 ("name attribute missing in option.");
    if (!attrVal[OA_TYPE]) XML_FATAL1 ("type attribute missing in option.");
    if (!attrVal[OA_DEFAULT]) XML_FATAL1 ("default attribute missing in option.");

    opt = findOption (cache, attrVal[OA_NAME]);
    if (cache->info[opt].name)
	XML_FATAL ("option %s redefined.", attrVal[OA_NAME]);
    data->curOption = opt;

    XSTRDUP (cache->info[opt].name, attrVal[OA_NAME]);

    if (!strcmp (attrVal[OA_TYPE], "bool"))
	cache->info[opt].type = DRI_BOOL;
    else if (!strcmp (attrVal[OA_TYPE], "enum"))
	cache->info[opt].type = DRI_ENUM;
    else if (!strcmp (attrVal[OA_TYPE], "int"))
	cache->info[opt].type = DRI_INT;
    else if (!strcmp (attrVal[OA_TYPE], "float"))
	cache->info[opt].type = DRI_FLOAT;
    else if (!strcmp (attrVal[OA_TYPE], "string"))
	cache->info[opt].type = DRI_STRING;
    else
	XML_FATAL ("illegal type in option: %s.", attrVal[OA_TYPE]);

    defaultVal = getenv (cache->info[opt].name);
    if (defaultVal != NULL) {
      /* don't use XML_WARNING, we want the user to see this! */
	fprintf (stderr,
		 "ATTENTION: default value of option %s overridden by environment.\n",
		 cache->info[opt].name);
    } else
	defaultVal = attrVal[OA_DEFAULT];
    if (!parseValue (&cache->values[opt], cache->info[opt].type, defaultVal))
	XML_FATAL ("illegal default value for %s: %s.", cache->info[opt].name, defaultVal);

    if (attrVal[OA_VALID]) {
	if (cache->info[opt].type == DRI_BOOL)
	    XML_FATAL1 ("boolean option with valid attribute.");
	if (!parseRanges (&cache->info[opt], attrVal[OA_VALID]))
	    XML_FATAL ("illegal valid attribute: %s.", attrVal[OA_VALID]);
	if (!checkValue (&cache->values[opt], &cache->info[opt]))
	    XML_FATAL ("default value out of valid range '%s': %s.",
		       attrVal[OA_VALID], defaultVal);
    } else if (cache->info[opt].type == DRI_ENUM) {
	XML_FATAL1 ("valid attribute missing in option (mandatory for enums).");
    } else {
	cache->info[opt].nRanges = 0;
	cache->info[opt].ranges = NULL;
    }
}

/** \brief Handler for start element events. */
static void optInfoStartElem (void *userData, const XML_Char *name,
			      const XML_Char **attr) {
    struct OptInfoData *data = (struct OptInfoData *)userData;
    enum OptInfoElem elem = bsearchStr (name, OptInfoElems, OI_COUNT);
    switch (elem) {
      case OI_DRIINFO:
	if (data->inDriInfo)
	    XML_FATAL1 ("nested <driinfo> elements.");
	if (attr[0])
	    XML_FATAL1 ("attributes specified on <driinfo> element.");
	data->inDriInfo = true;
	break;
      case OI_SECTION:
	if (!data->inDriInfo)
	    XML_FATAL1 ("<section> must be inside <driinfo>.");
	if (data->inSection)
	    XML_FATAL1 ("nested <section> elements.");
	if (attr[0])
	    XML_FATAL1 ("attributes specified on <section> element.");
	data->inSection = true;
	break;
      case OI_DESCRIPTION:
	if (!data->inSection && !data->inOption)
	    XML_FATAL1 ("<description> must be inside <description> or <option.");
	if (data->inDesc)
	    XML_FATAL1 ("nested <description> elements.");
	data->inDesc = true;
	parseDescAttr (data, attr);
	break;
      case OI_OPTION:
	if (!data->inSection)
	    XML_FATAL1 ("<option> must be inside <section>.");
	if (data->inDesc)
	    XML_FATAL1 ("<option> nested in <description> element.");
	if (data->inOption)
	    XML_FATAL1 ("nested <option> elements.");
	data->inOption = true;
	parseOptInfoAttr (data, attr);
	break;
      case OI_ENUM:
	if (!(data->inOption && data->inDesc))
	    XML_FATAL1 ("<enum> must be inside <option> and <description>.");
	if (data->inEnum)
	    XML_FATAL1 ("nested <enum> elements.");
	data->inEnum = true;
	parseEnumAttr (data, attr);
	break;
      default:
	XML_FATAL ("unknown element: %s.", name);
    }
}

/** \brief Handler for end element events. */
static void optInfoEndElem (void *userData, const XML_Char *name) {
    struct OptInfoData *data = (struct OptInfoData *)userData;
    enum OptInfoElem elem = bsearchStr (name, OptInfoElems, OI_COUNT);
    switch (elem) {
      case OI_DRIINFO:
	data->inDriInfo = false;
	break;
      case OI_SECTION:
	data->inSection = false;
	break;
      case OI_DESCRIPTION:
	data->inDesc = false;
	break;
      case OI_OPTION:
	data->inOption = false;
	break;
      case OI_ENUM:
	data->inEnum = false;
	break;
      default:
	assert (0); /* should have been caught by StartElem */
    }
}

void driParseOptionInfo (driOptionCache *info, const char *configOptions) {
    XML_Parser p;
    int status;
    struct OptInfoData userData;
    struct OptInfoData *data = &userData;

    /* Make the hash table big enough to fit more than the maximum number of
     * config options we've ever seen in a driver.
     */
    info->tableSize = 6;
    info->info = calloc(1 << info->tableSize, sizeof (driOptionInfo));
    info->values = calloc(1 << info->tableSize, sizeof (driOptionValue));
    if (info->info == NULL || info->values == NULL) {
	fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
	abort();
    }

    p = XML_ParserCreate ("UTF-8"); /* always UTF-8 */
    XML_SetElementHandler (p, optInfoStartElem, optInfoEndElem);
    XML_SetUserData (p, data);

    userData.name = "__driConfigOptions";
    userData.parser = p;
    userData.cache = info;
    userData.inDriInfo = false;
    userData.inSection = false;
    userData.inDesc = false;
    userData.inOption = false;
    userData.inEnum = false;
    userData.curOption = -1;

    status = XML_Parse (p, configOptions, strlen (configOptions), 1);
    if (!status)
	XML_FATAL ("%s.", XML_ErrorString(XML_GetErrorCode(p)));

    XML_ParserFree (p);
}

/** \brief Parser context for configuration files. */
struct OptConfData {
    const char *name;
    XML_Parser parser;
    driOptionCache *cache;
    int screenNum;
    const char *driverName, *execName;
    uint32_t ignoringDevice;
    uint32_t ignoringApp;
    uint32_t inDriConf;
    uint32_t inDevice;
    uint32_t inApp;
    uint32_t inOption;
};

/** \brief Elements in configuration files. */
enum OptConfElem {
    OC_APPLICATION = 0, OC_DEVICE, OC_DRICONF, OC_OPTION, OC_COUNT
};
static const XML_Char *OptConfElems[] = {
    "application", "device", "driconf", "option"
};

/** \brief Parse attributes of a device element. */
static void parseDeviceAttr (struct OptConfData *data, const XML_Char **attr) {
    uint32_t i;
    const XML_Char *driver = NULL, *screen = NULL;
    for (i = 0; attr[i]; i += 2) {
	if (!strcmp (attr[i], "driver")) driver = attr[i+1];
	else if (!strcmp (attr[i], "screen")) screen = attr[i+1];
	else XML_WARNING("unknown device attribute: %s.", attr[i]);
    }
    if (driver && strcmp (driver, data->driverName))
	data->ignoringDevice = data->inDevice;
    else if (screen) {
	driOptionValue screenNum;
	if (!parseValue (&screenNum, DRI_INT, screen))
	    XML_WARNING("illegal screen number: %s.", screen);
	else if (screenNum._int != data->screenNum)
	    data->ignoringDevice = data->inDevice;
    }
}

/** \brief Parse attributes of an application element. */
static void parseAppAttr (struct OptConfData *data, const XML_Char **attr) {
    uint32_t i;
    const XML_Char *exec = NULL;
    for (i = 0; attr[i]; i += 2) {
	if (!strcmp (attr[i], "name")) /* not needed here */;
	else if (!strcmp (attr[i], "executable")) exec = attr[i+1];
	else XML_WARNING("unknown application attribute: %s.", attr[i]);
    }
    if (exec && strcmp (exec, data->execName))
	data->ignoringApp = data->inApp;
}

/** \brief Parse attributes of an option element. */
static void parseOptConfAttr (struct OptConfData *data, const XML_Char **attr) {
    uint32_t i;
    const XML_Char *name = NULL, *value = NULL;
    for (i = 0; attr[i]; i += 2) {
	if (!strcmp (attr[i], "name")) name = attr[i+1];
	else if (!strcmp (attr[i], "value")) value = attr[i+1];
	else XML_WARNING("unknown option attribute: %s.", attr[i]);
    }
    if (!name) XML_WARNING1 ("name attribute missing in option.");
    if (!value) XML_WARNING1 ("value attribute missing in option.");
    if (name && value) {
	driOptionCache *cache = data->cache;
	uint32_t opt = findOption (cache, name);
	if (cache->info[opt].name == NULL)
            /* don't use XML_WARNING, drirc defines options for all drivers,
             * but not all drivers support them */
            return;
	else if (getenv (cache->info[opt].name))
	  /* don't use XML_WARNING, we want the user to see this! */
	    fprintf (stderr, "ATTENTION: option value of option %s ignored.\n",
		     cache->info[opt].name);
	else if (!parseValue (&cache->values[opt], cache->info[opt].type, value))
	    XML_WARNING ("illegal option value: %s.", value);
    }
}

/** \brief Handler for start element events. */
static void optConfStartElem (void *userData, const XML_Char *name,
			      const XML_Char **attr) {
    struct OptConfData *data = (struct OptConfData *)userData;
    enum OptConfElem elem = bsearchStr (name, OptConfElems, OC_COUNT);
    switch (elem) {
      case OC_DRICONF:
	if (data->inDriConf)
	    XML_WARNING1 ("nested <driconf> elements.");
	if (attr[0])
	    XML_WARNING1 ("attributes specified on <driconf> element.");
	data->inDriConf++;
	break;
      case OC_DEVICE:
	if (!data->inDriConf)
	    XML_WARNING1 ("<device> should be inside <driconf>.");
	if (data->inDevice)
	    XML_WARNING1 ("nested <device> elements.");
	data->inDevice++;
	if (!data->ignoringDevice && !data->ignoringApp)
	    parseDeviceAttr (data, attr);
	break;
      case OC_APPLICATION:
	if (!data->inDevice)
	    XML_WARNING1 ("<application> should be inside <device>.");
	if (data->inApp)
	    XML_WARNING1 ("nested <application> elements.");
	data->inApp++;
	if (!data->ignoringDevice && !data->ignoringApp)
	    parseAppAttr (data, attr);
	break;
      case OC_OPTION:
	if (!data->inApp)
	    XML_WARNING1 ("<option> should be inside <application>.");
	if (data->inOption)
	    XML_WARNING1 ("nested <option> elements.");
	data->inOption++;
	if (!data->ignoringDevice && !data->ignoringApp)
	    parseOptConfAttr (data, attr);
	break;
      default:
	XML_WARNING ("unknown element: %s.", name);
    }
}

/** \brief Handler for end element events. */
static void optConfEndElem (void *userData, const XML_Char *name) {
    struct OptConfData *data = (struct OptConfData *)userData;
    enum OptConfElem elem = bsearchStr (name, OptConfElems, OC_COUNT);
    switch (elem) {
      case OC_DRICONF:
	data->inDriConf--;
	break;
      case OC_DEVICE:
	if (data->inDevice-- == data->ignoringDevice)
	    data->ignoringDevice = 0;
	break;
      case OC_APPLICATION:
	if (data->inApp-- == data->ignoringApp)
	    data->ignoringApp = 0;
	break;
      case OC_OPTION:
	data->inOption--;
	break;
      default:
	/* unknown element, warning was produced on start tag */;
    }
}

/** \brief Initialize an option cache based on info */
static void initOptionCache (driOptionCache *cache, const driOptionCache *info) {
    GLuint i, size = 1 << info->tableSize;
    cache->info = info->info;
    cache->tableSize = info->tableSize;
    cache->values = malloc((1<<info->tableSize) * sizeof (driOptionValue));
    if (cache->values == NULL) {
	fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
	abort();
    }
    memcpy (cache->values, info->values,
	    (1<<info->tableSize) * sizeof (driOptionValue));
    for (i = 0; i < size; ++i) {
	if (cache->info[i].type == DRI_STRING)
	    XSTRDUP(cache->values[i]._string, info->values[i]._string);
    }
}

/** \brief Parse the named configuration file */
static void parseOneConfigFile (XML_Parser p) {
#define BUF_SIZE 0x1000
    struct OptConfData *data = (struct OptConfData *)XML_GetUserData (p);
    int status;
    int fd;

    if ((fd = open (data->name, O_RDONLY)) == -1) {
	__driUtilMessage ("Can't open configuration file %s: %s.",
			  data->name, strerror (errno));
	return;
    }

    while (1) {
	int bytesRead;
	void *buffer = XML_GetBuffer (p, BUF_SIZE);
	if (!buffer) {
	    __driUtilMessage ("Can't allocate parser buffer.");
	    break;
	}
	bytesRead = read (fd, buffer, BUF_SIZE);
	if (bytesRead == -1) {
	    __driUtilMessage ("Error reading from configuration file %s: %s.",
			      data->name, strerror (errno));
	    break;
	}
	status = XML_ParseBuffer (p, bytesRead, bytesRead == 0);
	if (!status) {
	    XML_ERROR ("%s.", XML_ErrorString(XML_GetErrorCode(p)));
	    break;
	}
	if (bytesRead == 0)
	    break;
    }

    close (fd);
#undef BUF_SIZE
}

#ifndef SYSCONFDIR
#define SYSCONFDIR "/etc"
#endif

void driParseConfigFiles (driOptionCache *cache, const driOptionCache *info,
			  int screenNum, const char *driverName) {
#if defined(__OpenBSD__)
    /*
     * Opening drirc files is disabled by default so sandboxed
     * browser processes with OpenGL contexts can drop the ability
     * to read files.
     */
    initOptionCache (cache, info);
#else
    char *filenames[2] = { SYSCONFDIR "/drirc", NULL};
    char *home;
    uint32_t i;
    struct OptConfData userData;

    initOptionCache (cache, info);

    userData.cache = cache;
    userData.screenNum = screenNum;
    userData.driverName = driverName;
    userData.execName = GET_PROGRAM_NAME();

    if ((home = getenv ("HOME"))) {
	uint32_t len = strlen (home);
	filenames[1] = malloc(len + 7+1);
	if (filenames[1] == NULL)
	    __driUtilMessage ("Can't allocate memory for %s/.drirc.", home);
	else {
	    memcpy (filenames[1], home, len);
	    memcpy (filenames[1] + len, "/.drirc", 7+1);
	}
    }

    for (i = 0; i < 2; ++i) {
	XML_Parser p;
	if (filenames[i] == NULL)
	    continue;

	p = XML_ParserCreate (NULL); /* use encoding specified by file */
	XML_SetElementHandler (p, optConfStartElem, optConfEndElem);
	XML_SetUserData (p, &userData);
	userData.parser = p;
	userData.name = filenames[i];
	userData.ignoringDevice = 0;
	userData.ignoringApp = 0;
	userData.inDriConf = 0;
	userData.inDevice = 0;
	userData.inApp = 0;
	userData.inOption = 0;

	parseOneConfigFile (p);
	XML_ParserFree (p);
    }

    free(filenames[1]);
#endif
}

void driDestroyOptionInfo (driOptionCache *info) {
    driDestroyOptionCache (info);
    if (info->info) {
	uint32_t i, size = 1 << info->tableSize;
	for (i = 0; i < size; ++i) {
	    if (info->info[i].name) {
		free(info->info[i].name);
		free(info->info[i].ranges);
	    }
	}
	free(info->info);
    }
}

void driDestroyOptionCache (driOptionCache *cache) {
    if (cache->info) {
	GLuint i, size = 1 << cache->tableSize;
	for (i = 0; i < size; ++i) {
	    if (cache->info[i].type == DRI_STRING)
		free(cache->values[i]._string);
	}
    }
    free(cache->values);
}

unsigned char driCheckOption (const driOptionCache *cache, const char *name,
			  driOptionType type) {
    uint32_t i = findOption (cache, name);
    return cache->info[i].name != NULL && cache->info[i].type == type;
}

unsigned char driQueryOptionb (const driOptionCache *cache, const char *name) {
    uint32_t i = findOption (cache, name);
  /* make sure the option is defined and has the correct type */
    assert (cache->info[i].name != NULL);
    assert (cache->info[i].type == DRI_BOOL);
    return cache->values[i]._bool;
}

int driQueryOptioni (const driOptionCache *cache, const char *name) {
    uint32_t i = findOption (cache, name);
  /* make sure the option is defined and has the correct type */
    assert (cache->info[i].name != NULL);
    assert (cache->info[i].type == DRI_INT || cache->info[i].type == DRI_ENUM);
    return cache->values[i]._int;
}

float driQueryOptionf (const driOptionCache *cache, const char *name) {
    uint32_t i = findOption (cache, name);
  /* make sure the option is defined and has the correct type */
    assert (cache->info[i].name != NULL);
    assert (cache->info[i].type == DRI_FLOAT);
    return cache->values[i]._float;
}

char *driQueryOptionstr (const driOptionCache *cache, const char *name) {
    GLuint i = findOption (cache, name);
  /* make sure the option is defined and has the correct type */
    assert (cache->info[i].name != NULL);
    assert (cache->info[i].type == DRI_STRING);
    return cache->values[i]._string;
}
@


1.4
log
@Merge Mesa 17.1.6
@
text
@d74 1
a74 3
static const char *
__getProgramName()
{
d78 9
a86 9
        const char *e = getexecname();
        if (e != NULL) {
            /* Have to make a copy since getexecname can return a readonly
               string, but basename expects to be able to modify its arg. */
            char *n = strdup(e);
            if (n != NULL) {
                progname = basename(n);
            }
        }
d99 1
a99 3
static const char *
__getProgramName()
{
d115 1
a115 3
static uint32_t
findOption(const driOptionCache *cache, const char *name)
{
d123 1
a123 1
        hash += (uint32_t)name[i] << shift;
d130 4
a133 4
        if (cache->info[hash].name == 0)
            break;
        else if (!strcmp (name, cache->info[hash].name))
            break;
d145 2
a146 2
        fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__); \
        abort(); \
d155 2
a156 3
static uint32_t
bsearchStr (const XML_Char *name, const XML_Char *elems[], uint32_t count)
{
d160 1
a160 1
        return found - elems;
d162 1
a162 1
        return count;
d174 1
a174 3
static int
strToI(const XML_Char *string, const XML_Char **tail, int base)
{
d184 2
a185 2
        sign = -1;
        string++;
d187 1
a187 1
        string++;
d189 8
a196 8
        numberFound = true;
        if (*(string+1) == 'x' || *(string+1) == 'X') {
            radix = 16;
            string += 2;
        } else {
            radix = 8;
            string++;
        }
d199 18
a216 18
        int digit = -1;
        if (radix <= 10) {
            if (*string >= '0' && *string < '0' + radix)
                digit = *string - '0';
        } else {
            if (*string >= '0' && *string <= '9')
                digit = *string - '0';
            else if (*string >= 'a' && *string < 'a' + radix - 10)
                digit = *string - 'a' + 10;
            else if (*string >= 'A' && *string < 'A' + radix - 10)
                digit = *string - 'A' + 10;
        }
        if (digit != -1) {
            numberFound = true;
            result = radix*result + digit;
            string++;
        } else
            break;
d234 1
a234 3
static float
strToF(const XML_Char *string, const XML_Char **tail)
{
d241 2
a242 2
        sign = -1.0f;
        string++;
d244 1
a244 1
        string++;
d250 2
a251 2
        string++;
        nDigits++;
d255 5
a259 5
        string++;
        while (*string >= '0' && *string <= '9') {
            string++;
            nDigits++;
        }
d262 3
a264 3
        /* no digits, no number */
        *tail = start;
        return 0.0f;
d268 6
a273 6
        const XML_Char *expTail;
        exponent = strToI (string+1, &expTail, 10);
        if (expTail == string+1)
            exponent = 0;
        else
            *tail = expTail;
d275 1
a275 1
        exponent = 0;
d283 7
a289 7
        if (*string != '.') {
            assert (*string >= '0' && *string <= '9');
            result += scale * (float)(*string - '0');
            scale *= 0.1f;
            nDigits--;
        }
        string++;
d296 2
a297 3
static unsigned char
parseValue(driOptionValue *v, driOptionType type, const XML_Char *string)
{
d303 10
a312 10
        if (!strcmp (string, "false")) {
            v->_bool = false;
            tail = string + 5;
        } else if (!strcmp (string, "true")) {
            v->_bool = true;
            tail = string + 4;
        }
        else
            return false;
        break;
d315 2
a316 2
        v->_int = strToI (string, &tail, 0);
        break;
d318 2
a319 2
        v->_float = strToF (string, &tail);
        break;
d321 3
a323 3
        free (v->_string);
        v->_string = strndup(string, STRING_CONF_MAXLEN);
        return GL_TRUE;
d327 1
a327 1
        return false; /* empty string (or containing only white-space) */
d330 1
a330 1
        tail += strspn (tail, " \f\n\r\t\v");
d332 1
a332 1
        return false; /* something left over that is not part of value */
d338 1
a338 3
static unsigned char
parseRanges(driOptionInfo *info, const XML_Char *string)
{
d347 2
a348 2
        if (*range == ',')
            ++nRanges;
d351 2
a352 2
        fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
        abort();
d358 26
a383 26
        XML_Char *end, *sep;
        assert (range);
        end = strchr (range, ',');
        if (end)
            *end = '\0';
        sep = strchr (range, ':');
        if (sep) { /* non-empty interval */
            *sep = '\0';
            if (!parseValue (&ranges[i].start, info->type, range) ||
                !parseValue (&ranges[i].end, info->type, sep+1))
                break;
            if (info->type == DRI_INT &&
                ranges[i].start._int > ranges[i].end._int)
                break;
            if (info->type == DRI_FLOAT &&
                ranges[i].start._float > ranges[i].end._float)
                break;
        } else { /* empty interval */
            if (!parseValue (&ranges[i].start, info->type, range))
                break;
            ranges[i].end = ranges[i].start;
        }
        if (end)
            range = end+1;
        else
            range = NULL;
d387 2
a388 2
        free(ranges);
        return false;
d390 1
a390 1
        assert (range == NULL);
d398 1
a398 3
static bool
checkValue(const driOptionValue *v, const driOptionInfo *info)
{
d402 1
a402 1
        return true;
d406 5
a410 5
        for (i = 0; i < info->nRanges; ++i)
            if (v->_int >= info->ranges[i].start._int &&
                v->_int <= info->ranges[i].end._int)
                return true;
        break;
d412 5
a416 5
        for (i = 0; i < info->nRanges; ++i)
            if (v->_float >= info->ranges[i].start._float &&
                v->_float <= info->ranges[i].end._float)
                return true;
        break;
d418 1
a418 1
        break;
d420 1
a420 1
        assert (0); /* should never happen */
d477 1
a477 1
             (int) XML_GetCurrentLineNumber(data->parser),        \
d484 2
a485 2
             (int) XML_GetCurrentLineNumber(data->parser), \
             (int) XML_GetCurrentColumnNumber(data->parser), \
d516 1
a516 3
static void
parseEnumAttr(struct OptInfoData *data, const XML_Char **attr)
{
d522 3
a524 3
        if (!strcmp (attr[i], "value")) value = attr[i+1];
        else if (!strcmp (attr[i], "text")) text = attr[i+1];
        else XML_FATAL("illegal enum attribute: %s.", attr[i]);
d529 1
a529 1
        XML_FATAL ("illegal enum value: %s.", value);
d531 1
a531 1
        XML_FATAL ("enum value out of valid range: %s.", value);
d539 1
a539 3
static void
parseDescAttr(struct OptInfoData *data, const XML_Char **attr)
{
d543 3
a545 3
        if (!strcmp (attr[i], "lang")) lang = attr[i+1];
        else if (!strcmp (attr[i], "text")) text = attr[i+1];
        else XML_FATAL("illegal description attribute: %s.", attr[i]);
d552 1
a552 3
static void
parseOptInfoAttr(struct OptInfoData *data, const XML_Char **attr)
{
d560 4
a563 4
        uint32_t attrName = bsearchStr (attr[i], optAttr, OA_COUNT);
        if (attrName >= OA_COUNT)
            XML_FATAL ("illegal option attribute: %s", attr[i]);
        attrVal[attrName] = attr[i+1];
d571 1
a571 1
        XML_FATAL ("option %s redefined.", attrVal[OA_NAME]);
d577 1
a577 1
        cache->info[opt].type = DRI_BOOL;
d579 1
a579 1
        cache->info[opt].type = DRI_ENUM;
d581 1
a581 1
        cache->info[opt].type = DRI_INT;
d583 1
a583 1
        cache->info[opt].type = DRI_FLOAT;
d585 1
a585 1
        cache->info[opt].type = DRI_STRING;
d587 1
a587 1
        XML_FATAL ("illegal type in option: %s.", attrVal[OA_TYPE]);
d592 3
a594 3
        fprintf (stderr,
                 "ATTENTION: default value of option %s overridden by environment.\n",
                 cache->info[opt].name);
d596 1
a596 1
        defaultVal = attrVal[OA_DEFAULT];
d598 1
a598 1
        XML_FATAL ("illegal default value for %s: %s.", cache->info[opt].name, defaultVal);
d601 7
a607 7
        if (cache->info[opt].type == DRI_BOOL)
            XML_FATAL1 ("boolean option with valid attribute.");
        if (!parseRanges (&cache->info[opt], attrVal[OA_VALID]))
            XML_FATAL ("illegal valid attribute: %s.", attrVal[OA_VALID]);
        if (!checkValue (&cache->values[opt], &cache->info[opt]))
            XML_FATAL ("default value out of valid range '%s': %s.",
                       attrVal[OA_VALID], defaultVal);
d609 1
a609 1
        XML_FATAL1 ("valid attribute missing in option (mandatory for enums).");
d611 2
a612 2
        cache->info[opt].nRanges = 0;
        cache->info[opt].ranges = NULL;
d617 2
a618 3
static void
optInfoStartElem(void *userData, const XML_Char *name, const XML_Char **attr)
{
d623 6
a628 6
        if (data->inDriInfo)
            XML_FATAL1 ("nested <driinfo> elements.");
        if (attr[0])
            XML_FATAL1 ("attributes specified on <driinfo> element.");
        data->inDriInfo = true;
        break;
d630 8
a637 8
        if (!data->inDriInfo)
            XML_FATAL1 ("<section> must be inside <driinfo>.");
        if (data->inSection)
            XML_FATAL1 ("nested <section> elements.");
        if (attr[0])
            XML_FATAL1 ("attributes specified on <section> element.");
        data->inSection = true;
        break;
d639 7
a645 7
        if (!data->inSection && !data->inOption)
            XML_FATAL1 ("<description> must be inside <description> or <option.");
        if (data->inDesc)
            XML_FATAL1 ("nested <description> elements.");
        data->inDesc = true;
        parseDescAttr (data, attr);
        break;
d647 9
a655 9
        if (!data->inSection)
            XML_FATAL1 ("<option> must be inside <section>.");
        if (data->inDesc)
            XML_FATAL1 ("<option> nested in <description> element.");
        if (data->inOption)
            XML_FATAL1 ("nested <option> elements.");
        data->inOption = true;
        parseOptInfoAttr (data, attr);
        break;
d657 7
a663 7
        if (!(data->inOption && data->inDesc))
            XML_FATAL1 ("<enum> must be inside <option> and <description>.");
        if (data->inEnum)
            XML_FATAL1 ("nested <enum> elements.");
        data->inEnum = true;
        parseEnumAttr (data, attr);
        break;
d665 1
a665 1
        XML_FATAL ("unknown element: %s.", name);
d670 1
a670 3
static void
optInfoEndElem(void *userData, const XML_Char *name)
{
d675 2
a676 2
        data->inDriInfo = false;
        break;
d678 2
a679 2
        data->inSection = false;
        break;
d681 2
a682 2
        data->inDesc = false;
        break;
d684 2
a685 2
        data->inOption = false;
        break;
d687 2
a688 2
        data->inEnum = false;
        break;
d690 1
a690 1
        assert (0); /* should have been caught by StartElem */
d694 1
a694 3
void
driParseOptionInfo(driOptionCache *info, const char *configOptions)
{
d707 2
a708 2
        fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
        abort();
d727 1
a727 1
        XML_FATAL ("%s.", XML_ErrorString(XML_GetErrorCode(p)));
d756 1
a756 3
static void
parseDeviceAttr(struct OptConfData *data, const XML_Char **attr)
{
d760 3
a762 3
        if (!strcmp (attr[i], "driver")) driver = attr[i+1];
        else if (!strcmp (attr[i], "screen")) screen = attr[i+1];
        else XML_WARNING("unknown device attribute: %s.", attr[i]);
d765 1
a765 1
        data->ignoringDevice = data->inDevice;
d767 5
a771 5
        driOptionValue screenNum;
        if (!parseValue (&screenNum, DRI_INT, screen))
            XML_WARNING("illegal screen number: %s.", screen);
        else if (screenNum._int != data->screenNum)
            data->ignoringDevice = data->inDevice;
d776 1
a776 3
static void
parseAppAttr(struct OptConfData *data, const XML_Char **attr)
{
d780 3
a782 3
        if (!strcmp (attr[i], "name")) /* not needed here */;
        else if (!strcmp (attr[i], "executable")) exec = attr[i+1];
        else XML_WARNING("unknown application attribute: %s.", attr[i]);
d785 1
a785 1
        data->ignoringApp = data->inApp;
d789 1
a789 3
static void
parseOptConfAttr(struct OptConfData *data, const XML_Char **attr)
{
d793 3
a795 3
        if (!strcmp (attr[i], "name")) name = attr[i+1];
        else if (!strcmp (attr[i], "value")) value = attr[i+1];
        else XML_WARNING("unknown option attribute: %s.", attr[i]);
d800 3
a802 3
        driOptionCache *cache = data->cache;
        uint32_t opt = findOption (cache, name);
        if (cache->info[opt].name == NULL)
d806 6
a811 6
        else if (getenv (cache->info[opt].name))
          /* don't use XML_WARNING, we want the user to see this! */
            fprintf (stderr, "ATTENTION: option value of option %s ignored.\n",
                     cache->info[opt].name);
        else if (!parseValue (&cache->values[opt], cache->info[opt].type, value))
            XML_WARNING ("illegal option value: %s.", value);
d816 2
a817 4
static void
optConfStartElem(void *userData, const XML_Char *name,
                 const XML_Char **attr)
{
d822 6
a827 6
        if (data->inDriConf)
            XML_WARNING1 ("nested <driconf> elements.");
        if (attr[0])
            XML_WARNING1 ("attributes specified on <driconf> element.");
        data->inDriConf++;
        break;
d829 8
a836 8
        if (!data->inDriConf)
            XML_WARNING1 ("<device> should be inside <driconf>.");
        if (data->inDevice)
            XML_WARNING1 ("nested <device> elements.");
        data->inDevice++;
        if (!data->ignoringDevice && !data->ignoringApp)
            parseDeviceAttr (data, attr);
        break;
d838 8
a845 8
        if (!data->inDevice)
            XML_WARNING1 ("<application> should be inside <device>.");
        if (data->inApp)
            XML_WARNING1 ("nested <application> elements.");
        data->inApp++;
        if (!data->ignoringDevice && !data->ignoringApp)
            parseAppAttr (data, attr);
        break;
d847 8
a854 8
        if (!data->inApp)
            XML_WARNING1 ("<option> should be inside <application>.");
        if (data->inOption)
            XML_WARNING1 ("nested <option> elements.");
        data->inOption++;
        if (!data->ignoringDevice && !data->ignoringApp)
            parseOptConfAttr (data, attr);
        break;
d856 1
a856 1
        XML_WARNING ("unknown element: %s.", name);
d861 1
a861 3
static void
optConfEndElem(void *userData, const XML_Char *name)
{
d866 2
a867 2
        data->inDriConf--;
        break;
d869 3
a871 3
        if (data->inDevice-- == data->ignoringDevice)
            data->ignoringDevice = 0;
        break;
d873 3
a875 3
        if (data->inApp-- == data->ignoringApp)
            data->ignoringApp = 0;
        break;
d877 2
a878 2
        data->inOption--;
        break;
d880 1
a880 1
        /* unknown element, warning was produced on start tag */;
d885 1
a885 3
static void
initOptionCache(driOptionCache *cache, const driOptionCache *info)
{
d891 2
a892 2
        fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
        abort();
d895 1
a895 1
            (1<<info->tableSize) * sizeof (driOptionValue));
d897 2
a898 2
        if (cache->info[i].type == DRI_STRING)
            XSTRDUP(cache->values[i]._string, info->values[i]._string);
d903 1
a903 3
static void
parseOneConfigFile(XML_Parser p)
{
d910 3
a912 3
        __driUtilMessage ("Can't open configuration file %s: %s.",
                          data->name, strerror (errno));
        return;
d916 19
a934 19
        int bytesRead;
        void *buffer = XML_GetBuffer (p, BUF_SIZE);
        if (!buffer) {
            __driUtilMessage ("Can't allocate parser buffer.");
            break;
        }
        bytesRead = read (fd, buffer, BUF_SIZE);
        if (bytesRead == -1) {
            __driUtilMessage ("Error reading from configuration file %s: %s.",
                              data->name, strerror (errno));
            break;
        }
        status = XML_ParseBuffer (p, bytesRead, bytesRead == 0);
        if (!status) {
            XML_ERROR ("%s.", XML_ErrorString(XML_GetErrorCode(p)));
            break;
        }
        if (bytesRead == 0)
            break;
d945 2
a946 4
void
driParseConfigFiles(driOptionCache *cache, const driOptionCache *info,
                    int screenNum, const char *driverName)
{
d968 8
a975 8
        uint32_t len = strlen (home);
        filenames[1] = malloc(len + 7+1);
        if (filenames[1] == NULL)
            __driUtilMessage ("Can't allocate memory for %s/.drirc.", home);
        else {
            memcpy (filenames[1], home, len);
            memcpy (filenames[1] + len, "/.drirc", 7+1);
        }
d979 15
a993 15
        XML_Parser p;
        if (filenames[i] == NULL)
            continue;

        p = XML_ParserCreate (NULL); /* use encoding specified by file */
        XML_SetElementHandler (p, optConfStartElem, optConfEndElem);
        XML_SetUserData (p, &userData);
        userData.parser = p;
        userData.name = filenames[i];
        userData.ignoringDevice = 0;
        userData.ignoringApp = 0;
        userData.inDriConf = 0;
        userData.inDevice = 0;
        userData.inApp = 0;
        userData.inOption = 0;
d995 2
a996 2
        parseOneConfigFile (p);
        XML_ParserFree (p);
d1003 2
a1004 4
void
driDestroyOptionInfo(driOptionCache *info)
{
    driDestroyOptionCache(info);
d1006 8
a1013 8
        uint32_t i, size = 1 << info->tableSize;
        for (i = 0; i < size; ++i) {
            if (info->info[i].name) {
                free(info->info[i].name);
                free(info->info[i].ranges);
            }
        }
        free(info->info);
d1017 1
a1017 3
void
driDestroyOptionCache(driOptionCache *cache)
{
d1019 5
a1023 5
        GLuint i, size = 1 << cache->tableSize;
        for (i = 0; i < size; ++i) {
            if (cache->info[i].type == DRI_STRING)
                free(cache->values[i]._string);
        }
d1028 2
a1029 4
unsigned char
driCheckOption(const driOptionCache *cache, const char *name,
               driOptionType type)
{
d1034 1
a1034 3
unsigned char
driQueryOptionb(const driOptionCache *cache, const char *name)
{
d1042 1
a1042 3
int
driQueryOptioni(const driOptionCache *cache, const char *name)
{
d1050 1
a1050 3
float
driQueryOptionf(const driOptionCache *cache, const char *name)
{
d1058 1
a1058 3
char *
driQueryOptionstr(const driOptionCache *cache, const char *name)
{
@


1.3
log
@Merge Mesa 11.2.2
@
text
@d74 3
a76 1
static const char *__getProgramName () {
d80 9
a88 9
	const char *e = getexecname();
	if (e != NULL) {
	    /* Have to make a copy since getexecname can return a readonly
	       string, but basename expects to be able to modify its arg. */
	    char *n = strdup(e);
	    if (n != NULL) {
		progname = basename(n);
	    }
	}
d101 3
a103 1
static const char *__getProgramName () {
d119 3
a121 1
static uint32_t findOption (const driOptionCache *cache, const char *name) {
d129 1
a129 1
	hash += (uint32_t)name[i] << shift;
d136 4
a139 4
	if (cache->info[hash].name == 0)
	    break;
	else if (!strcmp (name, cache->info[hash].name))
	    break;
d151 2
a152 2
	fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__); \
	abort(); \
d161 3
a163 2
static uint32_t bsearchStr (const XML_Char *name,
			  const XML_Char *elems[], uint32_t count) {
d167 1
a167 1
	return found - elems;
d169 1
a169 1
	return count;
d181 3
a183 1
static int strToI (const XML_Char *string, const XML_Char **tail, int base) {
d193 2
a194 2
	sign = -1;
	string++;
d196 1
a196 1
	string++;
d198 8
a205 8
	numberFound = true;
	if (*(string+1) == 'x' || *(string+1) == 'X') {
	    radix = 16;
	    string += 2;
	} else {
	    radix = 8;
	    string++;
	}
d208 18
a225 18
	int digit = -1;
	if (radix <= 10) {
	    if (*string >= '0' && *string < '0' + radix)
		digit = *string - '0';
	} else {
	    if (*string >= '0' && *string <= '9')
		digit = *string - '0';
	    else if (*string >= 'a' && *string < 'a' + radix - 10)
		digit = *string - 'a' + 10;
	    else if (*string >= 'A' && *string < 'A' + radix - 10)
		digit = *string - 'A' + 10;
	}
	if (digit != -1) {
	    numberFound = true;
	    result = radix*result + digit;
	    string++;
	} else
	    break;
d243 3
a245 1
static float strToF (const XML_Char *string, const XML_Char **tail) {
d252 2
a253 2
	sign = -1.0f;
	string++;
d255 1
a255 1
	string++;
d261 2
a262 2
	string++;
	nDigits++;
d266 5
a270 5
	string++;
	while (*string >= '0' && *string <= '9') {
	    string++;
	    nDigits++;
	}
d273 3
a275 3
	/* no digits, no number */
	*tail = start;
	return 0.0f;
d279 6
a284 6
	const XML_Char *expTail;
	exponent = strToI (string+1, &expTail, 10);
	if (expTail == string+1)
	    exponent = 0;
	else
	    *tail = expTail;
d286 1
a286 1
	exponent = 0;
d294 7
a300 7
	if (*string != '.') {
	    assert (*string >= '0' && *string <= '9');
	    result += scale * (float)(*string - '0');
	    scale *= 0.1f;
	    nDigits--;
	}
	string++;
d307 3
a309 2
static unsigned char parseValue (driOptionValue *v, driOptionType type,
			     const XML_Char *string) {
d315 10
a324 10
	if (!strcmp (string, "false")) {
	    v->_bool = false;
	    tail = string + 5;
	} else if (!strcmp (string, "true")) {
	    v->_bool = true;
	    tail = string + 4;
	}
	else
	    return false;
	break;
d327 2
a328 2
	v->_int = strToI (string, &tail, 0);
	break;
d330 2
a331 2
	v->_float = strToF (string, &tail);
	break;
d333 3
a335 3
	free (v->_string);
	v->_string = strndup(string, STRING_CONF_MAXLEN);
	return GL_TRUE;
d339 1
a339 1
	return false; /* empty string (or containing only white-space) */
d342 1
a342 1
	tail += strspn (tail, " \f\n\r\t\v");
d344 1
a344 1
	return false; /* something left over that is not part of value */
d350 3
a352 1
static unsigned char parseRanges (driOptionInfo *info, const XML_Char *string) {
d361 2
a362 2
	if (*range == ',')
	    ++nRanges;
d365 2
a366 2
	fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
	abort();
d372 26
a397 26
	XML_Char *end, *sep;
	assert (range);
	end = strchr (range, ',');
	if (end)
	    *end = '\0';
	sep = strchr (range, ':');
	if (sep) { /* non-empty interval */
	    *sep = '\0';
	    if (!parseValue (&ranges[i].start, info->type, range) ||
		!parseValue (&ranges[i].end, info->type, sep+1))
	        break;
	    if (info->type == DRI_INT &&
		ranges[i].start._int > ranges[i].end._int)
		break;
	    if (info->type == DRI_FLOAT &&
		ranges[i].start._float > ranges[i].end._float)
		break;
	} else { /* empty interval */
	    if (!parseValue (&ranges[i].start, info->type, range))
		break;
	    ranges[i].end = ranges[i].start;
	}
	if (end)
	    range = end+1;
	else
	    range = NULL;
d401 2
a402 2
	free(ranges);
	return false;
d404 1
a404 1
	assert (range == NULL);
d412 3
a414 1
static bool checkValue (const driOptionValue *v, const driOptionInfo *info) {
d418 1
a418 1
	return true;
d422 5
a426 5
	for (i = 0; i < info->nRanges; ++i)
	    if (v->_int >= info->ranges[i].start._int &&
		v->_int <= info->ranges[i].end._int)
		return true;
	break;
d428 5
a432 5
	for (i = 0; i < info->nRanges; ++i)
	    if (v->_float >= info->ranges[i].start._float &&
		v->_float <= info->ranges[i].end._float)
		return true;
	break;
d434 1
a434 1
	break;
d436 1
a436 1
	assert (0); /* should never happen */
d493 1
a493 1
             (int) XML_GetCurrentLineNumber(data->parser),	\
d500 2
a501 2
             (int) XML_GetCurrentLineNumber(data->parser),	\
             (int) XML_GetCurrentColumnNumber(data->parser),		\
d532 3
a534 1
static void parseEnumAttr (struct OptInfoData *data, const XML_Char **attr) {
d540 3
a542 3
	if (!strcmp (attr[i], "value")) value = attr[i+1];
	else if (!strcmp (attr[i], "text")) text = attr[i+1];
	else XML_FATAL("illegal enum attribute: %s.", attr[i]);
d547 1
a547 1
	XML_FATAL ("illegal enum value: %s.", value);
d549 1
a549 1
	XML_FATAL ("enum value out of valid range: %s.", value);
d557 3
a559 1
static void parseDescAttr (struct OptInfoData *data, const XML_Char **attr) {
d563 3
a565 3
	if (!strcmp (attr[i], "lang")) lang = attr[i+1];
	else if (!strcmp (attr[i], "text")) text = attr[i+1];
	else XML_FATAL("illegal description attribute: %s.", attr[i]);
d572 3
a574 1
static void parseOptInfoAttr (struct OptInfoData *data, const XML_Char **attr) {
d582 4
a585 4
	uint32_t attrName = bsearchStr (attr[i], optAttr, OA_COUNT);
	if (attrName >= OA_COUNT)
	    XML_FATAL ("illegal option attribute: %s", attr[i]);
	attrVal[attrName] = attr[i+1];
d593 1
a593 1
	XML_FATAL ("option %s redefined.", attrVal[OA_NAME]);
d599 1
a599 1
	cache->info[opt].type = DRI_BOOL;
d601 1
a601 1
	cache->info[opt].type = DRI_ENUM;
d603 1
a603 1
	cache->info[opt].type = DRI_INT;
d605 1
a605 1
	cache->info[opt].type = DRI_FLOAT;
d607 1
a607 1
	cache->info[opt].type = DRI_STRING;
d609 1
a609 1
	XML_FATAL ("illegal type in option: %s.", attrVal[OA_TYPE]);
d614 3
a616 3
	fprintf (stderr,
		 "ATTENTION: default value of option %s overridden by environment.\n",
		 cache->info[opt].name);
d618 1
a618 1
	defaultVal = attrVal[OA_DEFAULT];
d620 1
a620 1
	XML_FATAL ("illegal default value for %s: %s.", cache->info[opt].name, defaultVal);
d623 7
a629 7
	if (cache->info[opt].type == DRI_BOOL)
	    XML_FATAL1 ("boolean option with valid attribute.");
	if (!parseRanges (&cache->info[opt], attrVal[OA_VALID]))
	    XML_FATAL ("illegal valid attribute: %s.", attrVal[OA_VALID]);
	if (!checkValue (&cache->values[opt], &cache->info[opt]))
	    XML_FATAL ("default value out of valid range '%s': %s.",
		       attrVal[OA_VALID], defaultVal);
d631 1
a631 1
	XML_FATAL1 ("valid attribute missing in option (mandatory for enums).");
d633 2
a634 2
	cache->info[opt].nRanges = 0;
	cache->info[opt].ranges = NULL;
d639 3
a641 2
static void optInfoStartElem (void *userData, const XML_Char *name,
			      const XML_Char **attr) {
d646 6
a651 6
	if (data->inDriInfo)
	    XML_FATAL1 ("nested <driinfo> elements.");
	if (attr[0])
	    XML_FATAL1 ("attributes specified on <driinfo> element.");
	data->inDriInfo = true;
	break;
d653 8
a660 8
	if (!data->inDriInfo)
	    XML_FATAL1 ("<section> must be inside <driinfo>.");
	if (data->inSection)
	    XML_FATAL1 ("nested <section> elements.");
	if (attr[0])
	    XML_FATAL1 ("attributes specified on <section> element.");
	data->inSection = true;
	break;
d662 7
a668 7
	if (!data->inSection && !data->inOption)
	    XML_FATAL1 ("<description> must be inside <description> or <option.");
	if (data->inDesc)
	    XML_FATAL1 ("nested <description> elements.");
	data->inDesc = true;
	parseDescAttr (data, attr);
	break;
d670 9
a678 9
	if (!data->inSection)
	    XML_FATAL1 ("<option> must be inside <section>.");
	if (data->inDesc)
	    XML_FATAL1 ("<option> nested in <description> element.");
	if (data->inOption)
	    XML_FATAL1 ("nested <option> elements.");
	data->inOption = true;
	parseOptInfoAttr (data, attr);
	break;
d680 7
a686 7
	if (!(data->inOption && data->inDesc))
	    XML_FATAL1 ("<enum> must be inside <option> and <description>.");
	if (data->inEnum)
	    XML_FATAL1 ("nested <enum> elements.");
	data->inEnum = true;
	parseEnumAttr (data, attr);
	break;
d688 1
a688 1
	XML_FATAL ("unknown element: %s.", name);
d693 3
a695 1
static void optInfoEndElem (void *userData, const XML_Char *name) {
d700 2
a701 2
	data->inDriInfo = false;
	break;
d703 2
a704 2
	data->inSection = false;
	break;
d706 2
a707 2
	data->inDesc = false;
	break;
d709 2
a710 2
	data->inOption = false;
	break;
d712 2
a713 2
	data->inEnum = false;
	break;
d715 1
a715 1
	assert (0); /* should have been caught by StartElem */
d719 3
a721 1
void driParseOptionInfo (driOptionCache *info, const char *configOptions) {
d734 2
a735 2
	fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
	abort();
d754 1
a754 1
	XML_FATAL ("%s.", XML_ErrorString(XML_GetErrorCode(p)));
d783 3
a785 1
static void parseDeviceAttr (struct OptConfData *data, const XML_Char **attr) {
d789 3
a791 3
	if (!strcmp (attr[i], "driver")) driver = attr[i+1];
	else if (!strcmp (attr[i], "screen")) screen = attr[i+1];
	else XML_WARNING("unknown device attribute: %s.", attr[i]);
d794 1
a794 1
	data->ignoringDevice = data->inDevice;
d796 5
a800 5
	driOptionValue screenNum;
	if (!parseValue (&screenNum, DRI_INT, screen))
	    XML_WARNING("illegal screen number: %s.", screen);
	else if (screenNum._int != data->screenNum)
	    data->ignoringDevice = data->inDevice;
d805 3
a807 1
static void parseAppAttr (struct OptConfData *data, const XML_Char **attr) {
d811 3
a813 3
	if (!strcmp (attr[i], "name")) /* not needed here */;
	else if (!strcmp (attr[i], "executable")) exec = attr[i+1];
	else XML_WARNING("unknown application attribute: %s.", attr[i]);
d816 1
a816 1
	data->ignoringApp = data->inApp;
d820 3
a822 1
static void parseOptConfAttr (struct OptConfData *data, const XML_Char **attr) {
d826 3
a828 3
	if (!strcmp (attr[i], "name")) name = attr[i+1];
	else if (!strcmp (attr[i], "value")) value = attr[i+1];
	else XML_WARNING("unknown option attribute: %s.", attr[i]);
d833 3
a835 3
	driOptionCache *cache = data->cache;
	uint32_t opt = findOption (cache, name);
	if (cache->info[opt].name == NULL)
d839 6
a844 6
	else if (getenv (cache->info[opt].name))
	  /* don't use XML_WARNING, we want the user to see this! */
	    fprintf (stderr, "ATTENTION: option value of option %s ignored.\n",
		     cache->info[opt].name);
	else if (!parseValue (&cache->values[opt], cache->info[opt].type, value))
	    XML_WARNING ("illegal option value: %s.", value);
d849 4
a852 2
static void optConfStartElem (void *userData, const XML_Char *name,
			      const XML_Char **attr) {
d857 6
a862 6
	if (data->inDriConf)
	    XML_WARNING1 ("nested <driconf> elements.");
	if (attr[0])
	    XML_WARNING1 ("attributes specified on <driconf> element.");
	data->inDriConf++;
	break;
d864 8
a871 8
	if (!data->inDriConf)
	    XML_WARNING1 ("<device> should be inside <driconf>.");
	if (data->inDevice)
	    XML_WARNING1 ("nested <device> elements.");
	data->inDevice++;
	if (!data->ignoringDevice && !data->ignoringApp)
	    parseDeviceAttr (data, attr);
	break;
d873 8
a880 8
	if (!data->inDevice)
	    XML_WARNING1 ("<application> should be inside <device>.");
	if (data->inApp)
	    XML_WARNING1 ("nested <application> elements.");
	data->inApp++;
	if (!data->ignoringDevice && !data->ignoringApp)
	    parseAppAttr (data, attr);
	break;
d882 8
a889 8
	if (!data->inApp)
	    XML_WARNING1 ("<option> should be inside <application>.");
	if (data->inOption)
	    XML_WARNING1 ("nested <option> elements.");
	data->inOption++;
	if (!data->ignoringDevice && !data->ignoringApp)
	    parseOptConfAttr (data, attr);
	break;
d891 1
a891 1
	XML_WARNING ("unknown element: %s.", name);
d896 3
a898 1
static void optConfEndElem (void *userData, const XML_Char *name) {
d903 2
a904 2
	data->inDriConf--;
	break;
d906 3
a908 3
	if (data->inDevice-- == data->ignoringDevice)
	    data->ignoringDevice = 0;
	break;
d910 3
a912 3
	if (data->inApp-- == data->ignoringApp)
	    data->ignoringApp = 0;
	break;
d914 2
a915 2
	data->inOption--;
	break;
d917 1
a917 1
	/* unknown element, warning was produced on start tag */;
d922 3
a924 1
static void initOptionCache (driOptionCache *cache, const driOptionCache *info) {
d930 2
a931 2
	fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
	abort();
d934 1
a934 1
	    (1<<info->tableSize) * sizeof (driOptionValue));
d936 2
a937 2
	if (cache->info[i].type == DRI_STRING)
	    XSTRDUP(cache->values[i]._string, info->values[i]._string);
d942 3
a944 1
static void parseOneConfigFile (XML_Parser p) {
d951 3
a953 3
	__driUtilMessage ("Can't open configuration file %s: %s.",
			  data->name, strerror (errno));
	return;
d957 19
a975 19
	int bytesRead;
	void *buffer = XML_GetBuffer (p, BUF_SIZE);
	if (!buffer) {
	    __driUtilMessage ("Can't allocate parser buffer.");
	    break;
	}
	bytesRead = read (fd, buffer, BUF_SIZE);
	if (bytesRead == -1) {
	    __driUtilMessage ("Error reading from configuration file %s: %s.",
			      data->name, strerror (errno));
	    break;
	}
	status = XML_ParseBuffer (p, bytesRead, bytesRead == 0);
	if (!status) {
	    XML_ERROR ("%s.", XML_ErrorString(XML_GetErrorCode(p)));
	    break;
	}
	if (bytesRead == 0)
	    break;
d986 4
a989 2
void driParseConfigFiles (driOptionCache *cache, const driOptionCache *info,
			  int screenNum, const char *driverName) {
d1011 8
a1018 8
	uint32_t len = strlen (home);
	filenames[1] = malloc(len + 7+1);
	if (filenames[1] == NULL)
	    __driUtilMessage ("Can't allocate memory for %s/.drirc.", home);
	else {
	    memcpy (filenames[1], home, len);
	    memcpy (filenames[1] + len, "/.drirc", 7+1);
	}
d1022 15
a1036 15
	XML_Parser p;
	if (filenames[i] == NULL)
	    continue;

	p = XML_ParserCreate (NULL); /* use encoding specified by file */
	XML_SetElementHandler (p, optConfStartElem, optConfEndElem);
	XML_SetUserData (p, &userData);
	userData.parser = p;
	userData.name = filenames[i];
	userData.ignoringDevice = 0;
	userData.ignoringApp = 0;
	userData.inDriConf = 0;
	userData.inDevice = 0;
	userData.inApp = 0;
	userData.inOption = 0;
d1038 2
a1039 2
	parseOneConfigFile (p);
	XML_ParserFree (p);
d1046 4
a1049 2
void driDestroyOptionInfo (driOptionCache *info) {
    driDestroyOptionCache (info);
d1051 8
a1058 8
	uint32_t i, size = 1 << info->tableSize;
	for (i = 0; i < size; ++i) {
	    if (info->info[i].name) {
		free(info->info[i].name);
		free(info->info[i].ranges);
	    }
	}
	free(info->info);
d1062 3
a1064 1
void driDestroyOptionCache (driOptionCache *cache) {
d1066 5
a1070 5
	GLuint i, size = 1 << cache->tableSize;
	for (i = 0; i < size; ++i) {
	    if (cache->info[i].type == DRI_STRING)
		free(cache->values[i]._string);
	}
d1075 4
a1078 2
unsigned char driCheckOption (const driOptionCache *cache, const char *name,
			  driOptionType type) {
d1083 3
a1085 1
unsigned char driQueryOptionb (const driOptionCache *cache, const char *name) {
d1093 3
a1095 1
int driQueryOptioni (const driOptionCache *cache, const char *name) {
d1103 3
a1105 1
float driQueryOptionf (const driOptionCache *cache, const char *name) {
d1113 3
a1115 1
char *driQueryOptionstr (const driOptionCache *cache, const char *name) {
@


1.2
log
@Disable reading of drirc files by default so chromium processes
with OpenGL contexts can drop the ability to read files.

Diff from robert@@ with a comment added.

ok robert@@ deraadt@@
@
text
@d941 4
d955 1
a955 1
    char *filenames[2] = {"/etc/drirc", NULL};
@


1.1
log
@Initial revision
@
text
@d62 3
d943 8
d996 1
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.0.8

This seems to fix some of the problems with clutter/gnome reported to
occur on r600 with 11.0.6
@
text
@a61 3
#elif defined(__DragonFly__)
#    include <stdlib.h>
#    define GET_PROGRAM_NAME() getprogname()
@


1.1.1.3
log
@Import Mesa 11.2.2
@
text
@a940 4
#ifndef SYSCONFDIR
#define SYSCONFDIR "/etc"
#endif

d943 1
a943 1
    char *filenames[2] = { SYSCONFDIR "/drirc", NULL};
@


1.1.1.4
log
@Import Mesa 17.1.6
@
text
@d74 1
a74 3
static const char *
__getProgramName()
{
d78 9
a86 9
        const char *e = getexecname();
        if (e != NULL) {
            /* Have to make a copy since getexecname can return a readonly
               string, but basename expects to be able to modify its arg. */
            char *n = strdup(e);
            if (n != NULL) {
                progname = basename(n);
            }
        }
d99 1
a99 3
static const char *
__getProgramName()
{
d115 1
a115 3
static uint32_t
findOption(const driOptionCache *cache, const char *name)
{
d123 1
a123 1
        hash += (uint32_t)name[i] << shift;
d130 4
a133 4
        if (cache->info[hash].name == 0)
            break;
        else if (!strcmp (name, cache->info[hash].name))
            break;
d145 2
a146 2
        fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__); \
        abort(); \
d155 2
a156 3
static uint32_t
bsearchStr (const XML_Char *name, const XML_Char *elems[], uint32_t count)
{
d160 1
a160 1
        return found - elems;
d162 1
a162 1
        return count;
d174 1
a174 3
static int
strToI(const XML_Char *string, const XML_Char **tail, int base)
{
d184 2
a185 2
        sign = -1;
        string++;
d187 1
a187 1
        string++;
d189 8
a196 8
        numberFound = true;
        if (*(string+1) == 'x' || *(string+1) == 'X') {
            radix = 16;
            string += 2;
        } else {
            radix = 8;
            string++;
        }
d199 18
a216 18
        int digit = -1;
        if (radix <= 10) {
            if (*string >= '0' && *string < '0' + radix)
                digit = *string - '0';
        } else {
            if (*string >= '0' && *string <= '9')
                digit = *string - '0';
            else if (*string >= 'a' && *string < 'a' + radix - 10)
                digit = *string - 'a' + 10;
            else if (*string >= 'A' && *string < 'A' + radix - 10)
                digit = *string - 'A' + 10;
        }
        if (digit != -1) {
            numberFound = true;
            result = radix*result + digit;
            string++;
        } else
            break;
d234 1
a234 3
static float
strToF(const XML_Char *string, const XML_Char **tail)
{
d241 2
a242 2
        sign = -1.0f;
        string++;
d244 1
a244 1
        string++;
d250 2
a251 2
        string++;
        nDigits++;
d255 5
a259 5
        string++;
        while (*string >= '0' && *string <= '9') {
            string++;
            nDigits++;
        }
d262 3
a264 3
        /* no digits, no number */
        *tail = start;
        return 0.0f;
d268 6
a273 6
        const XML_Char *expTail;
        exponent = strToI (string+1, &expTail, 10);
        if (expTail == string+1)
            exponent = 0;
        else
            *tail = expTail;
d275 1
a275 1
        exponent = 0;
d283 7
a289 7
        if (*string != '.') {
            assert (*string >= '0' && *string <= '9');
            result += scale * (float)(*string - '0');
            scale *= 0.1f;
            nDigits--;
        }
        string++;
d296 2
a297 3
static unsigned char
parseValue(driOptionValue *v, driOptionType type, const XML_Char *string)
{
d303 10
a312 10
        if (!strcmp (string, "false")) {
            v->_bool = false;
            tail = string + 5;
        } else if (!strcmp (string, "true")) {
            v->_bool = true;
            tail = string + 4;
        }
        else
            return false;
        break;
d315 2
a316 2
        v->_int = strToI (string, &tail, 0);
        break;
d318 2
a319 2
        v->_float = strToF (string, &tail);
        break;
d321 3
a323 3
        free (v->_string);
        v->_string = strndup(string, STRING_CONF_MAXLEN);
        return GL_TRUE;
d327 1
a327 1
        return false; /* empty string (or containing only white-space) */
d330 1
a330 1
        tail += strspn (tail, " \f\n\r\t\v");
d332 1
a332 1
        return false; /* something left over that is not part of value */
d338 1
a338 3
static unsigned char
parseRanges(driOptionInfo *info, const XML_Char *string)
{
d347 2
a348 2
        if (*range == ',')
            ++nRanges;
d351 2
a352 2
        fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
        abort();
d358 26
a383 26
        XML_Char *end, *sep;
        assert (range);
        end = strchr (range, ',');
        if (end)
            *end = '\0';
        sep = strchr (range, ':');
        if (sep) { /* non-empty interval */
            *sep = '\0';
            if (!parseValue (&ranges[i].start, info->type, range) ||
                !parseValue (&ranges[i].end, info->type, sep+1))
                break;
            if (info->type == DRI_INT &&
                ranges[i].start._int > ranges[i].end._int)
                break;
            if (info->type == DRI_FLOAT &&
                ranges[i].start._float > ranges[i].end._float)
                break;
        } else { /* empty interval */
            if (!parseValue (&ranges[i].start, info->type, range))
                break;
            ranges[i].end = ranges[i].start;
        }
        if (end)
            range = end+1;
        else
            range = NULL;
d387 2
a388 2
        free(ranges);
        return false;
d390 1
a390 1
        assert (range == NULL);
d398 1
a398 3
static bool
checkValue(const driOptionValue *v, const driOptionInfo *info)
{
d402 1
a402 1
        return true;
d406 5
a410 5
        for (i = 0; i < info->nRanges; ++i)
            if (v->_int >= info->ranges[i].start._int &&
                v->_int <= info->ranges[i].end._int)
                return true;
        break;
d412 5
a416 5
        for (i = 0; i < info->nRanges; ++i)
            if (v->_float >= info->ranges[i].start._float &&
                v->_float <= info->ranges[i].end._float)
                return true;
        break;
d418 1
a418 1
        break;
d420 1
a420 1
        assert (0); /* should never happen */
d477 1
a477 1
             (int) XML_GetCurrentLineNumber(data->parser),        \
d484 2
a485 2
             (int) XML_GetCurrentLineNumber(data->parser), \
             (int) XML_GetCurrentColumnNumber(data->parser), \
d516 1
a516 3
static void
parseEnumAttr(struct OptInfoData *data, const XML_Char **attr)
{
d522 3
a524 3
        if (!strcmp (attr[i], "value")) value = attr[i+1];
        else if (!strcmp (attr[i], "text")) text = attr[i+1];
        else XML_FATAL("illegal enum attribute: %s.", attr[i]);
d529 1
a529 1
        XML_FATAL ("illegal enum value: %s.", value);
d531 1
a531 1
        XML_FATAL ("enum value out of valid range: %s.", value);
d539 1
a539 3
static void
parseDescAttr(struct OptInfoData *data, const XML_Char **attr)
{
d543 3
a545 3
        if (!strcmp (attr[i], "lang")) lang = attr[i+1];
        else if (!strcmp (attr[i], "text")) text = attr[i+1];
        else XML_FATAL("illegal description attribute: %s.", attr[i]);
d552 1
a552 3
static void
parseOptInfoAttr(struct OptInfoData *data, const XML_Char **attr)
{
d560 4
a563 4
        uint32_t attrName = bsearchStr (attr[i], optAttr, OA_COUNT);
        if (attrName >= OA_COUNT)
            XML_FATAL ("illegal option attribute: %s", attr[i]);
        attrVal[attrName] = attr[i+1];
d571 1
a571 1
        XML_FATAL ("option %s redefined.", attrVal[OA_NAME]);
d577 1
a577 1
        cache->info[opt].type = DRI_BOOL;
d579 1
a579 1
        cache->info[opt].type = DRI_ENUM;
d581 1
a581 1
        cache->info[opt].type = DRI_INT;
d583 1
a583 1
        cache->info[opt].type = DRI_FLOAT;
d585 1
a585 1
        cache->info[opt].type = DRI_STRING;
d587 1
a587 1
        XML_FATAL ("illegal type in option: %s.", attrVal[OA_TYPE]);
d592 3
a594 3
        fprintf (stderr,
                 "ATTENTION: default value of option %s overridden by environment.\n",
                 cache->info[opt].name);
d596 1
a596 1
        defaultVal = attrVal[OA_DEFAULT];
d598 1
a598 1
        XML_FATAL ("illegal default value for %s: %s.", cache->info[opt].name, defaultVal);
d601 7
a607 7
        if (cache->info[opt].type == DRI_BOOL)
            XML_FATAL1 ("boolean option with valid attribute.");
        if (!parseRanges (&cache->info[opt], attrVal[OA_VALID]))
            XML_FATAL ("illegal valid attribute: %s.", attrVal[OA_VALID]);
        if (!checkValue (&cache->values[opt], &cache->info[opt]))
            XML_FATAL ("default value out of valid range '%s': %s.",
                       attrVal[OA_VALID], defaultVal);
d609 1
a609 1
        XML_FATAL1 ("valid attribute missing in option (mandatory for enums).");
d611 2
a612 2
        cache->info[opt].nRanges = 0;
        cache->info[opt].ranges = NULL;
d617 2
a618 3
static void
optInfoStartElem(void *userData, const XML_Char *name, const XML_Char **attr)
{
d623 6
a628 6
        if (data->inDriInfo)
            XML_FATAL1 ("nested <driinfo> elements.");
        if (attr[0])
            XML_FATAL1 ("attributes specified on <driinfo> element.");
        data->inDriInfo = true;
        break;
d630 8
a637 8
        if (!data->inDriInfo)
            XML_FATAL1 ("<section> must be inside <driinfo>.");
        if (data->inSection)
            XML_FATAL1 ("nested <section> elements.");
        if (attr[0])
            XML_FATAL1 ("attributes specified on <section> element.");
        data->inSection = true;
        break;
d639 7
a645 7
        if (!data->inSection && !data->inOption)
            XML_FATAL1 ("<description> must be inside <description> or <option.");
        if (data->inDesc)
            XML_FATAL1 ("nested <description> elements.");
        data->inDesc = true;
        parseDescAttr (data, attr);
        break;
d647 9
a655 9
        if (!data->inSection)
            XML_FATAL1 ("<option> must be inside <section>.");
        if (data->inDesc)
            XML_FATAL1 ("<option> nested in <description> element.");
        if (data->inOption)
            XML_FATAL1 ("nested <option> elements.");
        data->inOption = true;
        parseOptInfoAttr (data, attr);
        break;
d657 7
a663 7
        if (!(data->inOption && data->inDesc))
            XML_FATAL1 ("<enum> must be inside <option> and <description>.");
        if (data->inEnum)
            XML_FATAL1 ("nested <enum> elements.");
        data->inEnum = true;
        parseEnumAttr (data, attr);
        break;
d665 1
a665 1
        XML_FATAL ("unknown element: %s.", name);
d670 1
a670 3
static void
optInfoEndElem(void *userData, const XML_Char *name)
{
d675 2
a676 2
        data->inDriInfo = false;
        break;
d678 2
a679 2
        data->inSection = false;
        break;
d681 2
a682 2
        data->inDesc = false;
        break;
d684 2
a685 2
        data->inOption = false;
        break;
d687 2
a688 2
        data->inEnum = false;
        break;
d690 1
a690 1
        assert (0); /* should have been caught by StartElem */
d694 1
a694 3
void
driParseOptionInfo(driOptionCache *info, const char *configOptions)
{
d707 2
a708 2
        fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
        abort();
d727 1
a727 1
        XML_FATAL ("%s.", XML_ErrorString(XML_GetErrorCode(p)));
d756 1
a756 3
static void
parseDeviceAttr(struct OptConfData *data, const XML_Char **attr)
{
d760 3
a762 3
        if (!strcmp (attr[i], "driver")) driver = attr[i+1];
        else if (!strcmp (attr[i], "screen")) screen = attr[i+1];
        else XML_WARNING("unknown device attribute: %s.", attr[i]);
d765 1
a765 1
        data->ignoringDevice = data->inDevice;
d767 5
a771 5
        driOptionValue screenNum;
        if (!parseValue (&screenNum, DRI_INT, screen))
            XML_WARNING("illegal screen number: %s.", screen);
        else if (screenNum._int != data->screenNum)
            data->ignoringDevice = data->inDevice;
d776 1
a776 3
static void
parseAppAttr(struct OptConfData *data, const XML_Char **attr)
{
d780 3
a782 3
        if (!strcmp (attr[i], "name")) /* not needed here */;
        else if (!strcmp (attr[i], "executable")) exec = attr[i+1];
        else XML_WARNING("unknown application attribute: %s.", attr[i]);
d785 1
a785 1
        data->ignoringApp = data->inApp;
d789 1
a789 3
static void
parseOptConfAttr(struct OptConfData *data, const XML_Char **attr)
{
d793 3
a795 3
        if (!strcmp (attr[i], "name")) name = attr[i+1];
        else if (!strcmp (attr[i], "value")) value = attr[i+1];
        else XML_WARNING("unknown option attribute: %s.", attr[i]);
d800 3
a802 3
        driOptionCache *cache = data->cache;
        uint32_t opt = findOption (cache, name);
        if (cache->info[opt].name == NULL)
d806 6
a811 6
        else if (getenv (cache->info[opt].name))
          /* don't use XML_WARNING, we want the user to see this! */
            fprintf (stderr, "ATTENTION: option value of option %s ignored.\n",
                     cache->info[opt].name);
        else if (!parseValue (&cache->values[opt], cache->info[opt].type, value))
            XML_WARNING ("illegal option value: %s.", value);
d816 2
a817 4
static void
optConfStartElem(void *userData, const XML_Char *name,
                 const XML_Char **attr)
{
d822 6
a827 6
        if (data->inDriConf)
            XML_WARNING1 ("nested <driconf> elements.");
        if (attr[0])
            XML_WARNING1 ("attributes specified on <driconf> element.");
        data->inDriConf++;
        break;
d829 8
a836 8
        if (!data->inDriConf)
            XML_WARNING1 ("<device> should be inside <driconf>.");
        if (data->inDevice)
            XML_WARNING1 ("nested <device> elements.");
        data->inDevice++;
        if (!data->ignoringDevice && !data->ignoringApp)
            parseDeviceAttr (data, attr);
        break;
d838 8
a845 8
        if (!data->inDevice)
            XML_WARNING1 ("<application> should be inside <device>.");
        if (data->inApp)
            XML_WARNING1 ("nested <application> elements.");
        data->inApp++;
        if (!data->ignoringDevice && !data->ignoringApp)
            parseAppAttr (data, attr);
        break;
d847 8
a854 8
        if (!data->inApp)
            XML_WARNING1 ("<option> should be inside <application>.");
        if (data->inOption)
            XML_WARNING1 ("nested <option> elements.");
        data->inOption++;
        if (!data->ignoringDevice && !data->ignoringApp)
            parseOptConfAttr (data, attr);
        break;
d856 1
a856 1
        XML_WARNING ("unknown element: %s.", name);
d861 1
a861 3
static void
optConfEndElem(void *userData, const XML_Char *name)
{
d866 2
a867 2
        data->inDriConf--;
        break;
d869 3
a871 3
        if (data->inDevice-- == data->ignoringDevice)
            data->ignoringDevice = 0;
        break;
d873 3
a875 3
        if (data->inApp-- == data->ignoringApp)
            data->ignoringApp = 0;
        break;
d877 2
a878 2
        data->inOption--;
        break;
d880 1
a880 1
        /* unknown element, warning was produced on start tag */;
d885 1
a885 3
static void
initOptionCache(driOptionCache *cache, const driOptionCache *info)
{
d891 2
a892 2
        fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
        abort();
d895 1
a895 1
            (1<<info->tableSize) * sizeof (driOptionValue));
d897 2
a898 2
        if (cache->info[i].type == DRI_STRING)
            XSTRDUP(cache->values[i]._string, info->values[i]._string);
d903 1
a903 3
static void
parseOneConfigFile(XML_Parser p)
{
d910 3
a912 3
        __driUtilMessage ("Can't open configuration file %s: %s.",
                          data->name, strerror (errno));
        return;
d916 19
a934 19
        int bytesRead;
        void *buffer = XML_GetBuffer (p, BUF_SIZE);
        if (!buffer) {
            __driUtilMessage ("Can't allocate parser buffer.");
            break;
        }
        bytesRead = read (fd, buffer, BUF_SIZE);
        if (bytesRead == -1) {
            __driUtilMessage ("Error reading from configuration file %s: %s.",
                              data->name, strerror (errno));
            break;
        }
        status = XML_ParseBuffer (p, bytesRead, bytesRead == 0);
        if (!status) {
            XML_ERROR ("%s.", XML_ErrorString(XML_GetErrorCode(p)));
            break;
        }
        if (bytesRead == 0)
            break;
d945 2
a946 4
void
driParseConfigFiles(driOptionCache *cache, const driOptionCache *info,
                    int screenNum, const char *driverName)
{
d960 8
a967 8
        uint32_t len = strlen (home);
        filenames[1] = malloc(len + 7+1);
        if (filenames[1] == NULL)
            __driUtilMessage ("Can't allocate memory for %s/.drirc.", home);
        else {
            memcpy (filenames[1], home, len);
            memcpy (filenames[1] + len, "/.drirc", 7+1);
        }
d971 15
a985 15
        XML_Parser p;
        if (filenames[i] == NULL)
            continue;

        p = XML_ParserCreate (NULL); /* use encoding specified by file */
        XML_SetElementHandler (p, optConfStartElem, optConfEndElem);
        XML_SetUserData (p, &userData);
        userData.parser = p;
        userData.name = filenames[i];
        userData.ignoringDevice = 0;
        userData.ignoringApp = 0;
        userData.inDriConf = 0;
        userData.inDevice = 0;
        userData.inApp = 0;
        userData.inOption = 0;
d987 2
a988 2
        parseOneConfigFile (p);
        XML_ParserFree (p);
d994 2
a995 4
void
driDestroyOptionInfo(driOptionCache *info)
{
    driDestroyOptionCache(info);
d997 8
a1004 8
        uint32_t i, size = 1 << info->tableSize;
        for (i = 0; i < size; ++i) {
            if (info->info[i].name) {
                free(info->info[i].name);
                free(info->info[i].ranges);
            }
        }
        free(info->info);
d1008 1
a1008 3
void
driDestroyOptionCache(driOptionCache *cache)
{
d1010 5
a1014 5
        GLuint i, size = 1 << cache->tableSize;
        for (i = 0; i < size; ++i) {
            if (cache->info[i].type == DRI_STRING)
                free(cache->values[i]._string);
        }
d1019 2
a1020 4
unsigned char
driCheckOption(const driOptionCache *cache, const char *name,
               driOptionType type)
{
d1025 1
a1025 3
unsigned char
driQueryOptionb(const driOptionCache *cache, const char *name)
{
d1033 1
a1033 3
int
driQueryOptioni(const driOptionCache *cache, const char *name)
{
d1041 1
a1041 3
float
driQueryOptionf(const driOptionCache *cache, const char *name)
{
d1049 1
a1049 3
char *
driQueryOptionstr(const driOptionCache *cache, const char *name)
{
@


