head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.39.56;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.39.56;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.15.12;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.37.05;	author jsg;	state Exp;
branches;
next	;
commitid	uuv5VTS15jglEDZU;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2014 Intel Corporation All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Jason Ekstrand <jason.ekstrand@@intel.com>
 */

#include "intel_tex.h"
#include "intel_blit.h"
#include "intel_mipmap_tree.h"
#include "main/formats.h"
#include "drivers/common/meta.h"

static bool
copy_image_with_blitter(struct brw_context *brw,
                        struct intel_mipmap_tree *src_mt, int src_level,
                        int src_x, int src_y, int src_z,
                        struct intel_mipmap_tree *dst_mt, int dst_level,
                        int dst_x, int dst_y, int dst_z,
                        int src_width, int src_height)
{
   GLuint bw, bh;
   uint32_t src_image_x, src_image_y, dst_image_x, dst_image_y;
   int cpp;

   /* The blitter doesn't understand multisampling at all. */
   if (src_mt->num_samples > 0 || dst_mt->num_samples > 0)
      return false;

   /* According to the Ivy Bridge PRM, Vol1 Part4, section 1.2.1.2 (Graphics
    * Data Size Limitations):
    *
    *    The BLT engine is capable of transferring very large quantities of
    *    graphics data. Any graphics data read from and written to the
    *    destination is permitted to represent a number of pixels that
    *    occupies up to 65,536 scan lines and up to 32,768 bytes per scan line
    *    at the destination. The maximum number of pixels that may be
    *    represented per scan lineâ€™s worth of graphics data depends on the
    *    color depth.
    *
    * Furthermore, intelEmitCopyBlit (which is called below) uses a signed
    * 16-bit integer to represent buffer pitch, so it can only handle buffer
    * pitches < 32k.
    *
    * As a result of these two limitations, we can only use the blitter to do
    * this copy when the miptree's pitch is less than 32k.
    */
   if (src_mt->pitch >= 32768 ||
       dst_mt->pitch >= 32768) {
      perf_debug("Falling back due to >=32k pitch\n");
      return false;
   }

   intel_miptree_get_image_offset(src_mt, src_level, src_z,
                                  &src_image_x, &src_image_y);

   if (_mesa_is_format_compressed(src_mt->format)) {
      _mesa_get_format_block_size(src_mt->format, &bw, &bh);

      assert(src_x % bw == 0);
      assert(src_y % bh == 0);
      assert(src_width % bw == 0);
      assert(src_height % bh == 0);

      src_x /= (int)bw;
      src_y /= (int)bh;
      src_width /= (int)bw;
      src_height /= (int)bh;

      /* Inside of the miptree, the x offsets are stored in pixels while
       * the y offsets are stored in blocks.  We need to scale just the x
       * offset.
       */
      src_image_x /= bw;

      cpp = _mesa_get_format_bytes(src_mt->format);
   } else {
      cpp = src_mt->cpp;
   }
   src_x += src_image_x;
   src_y += src_image_y;

   intel_miptree_get_image_offset(dst_mt, dst_level, dst_z,
                                  &dst_image_x, &dst_image_y);

   if (_mesa_is_format_compressed(dst_mt->format)) {
      _mesa_get_format_block_size(dst_mt->format, &bw, &bh);

      assert(dst_x % bw == 0);
      assert(dst_y % bh == 0);

      dst_x /= (int)bw;
      dst_y /= (int)bh;

      /* Inside of the miptree, the x offsets are stored in pixels while
       * the y offsets are stored in blocks.  We need to scale just the x
       * offset.
       */
      dst_image_x /= bw;
   }
   dst_x += dst_image_x;
   dst_y += dst_image_y;

   return intelEmitCopyBlit(brw,
                            cpp,
                            src_mt->pitch,
                            src_mt->bo, src_mt->offset,
                            src_mt->tiling,
                            src_mt->tr_mode,
                            dst_mt->pitch,
                            dst_mt->bo, dst_mt->offset,
                            dst_mt->tiling,
                            dst_mt->tr_mode,
                            src_x, src_y,
                            dst_x, dst_y,
                            src_width, src_height,
                            GL_COPY);
}

static void
copy_image_with_memcpy(struct brw_context *brw,
                       struct intel_mipmap_tree *src_mt, int src_level,
                       int src_x, int src_y, int src_z,
                       struct intel_mipmap_tree *dst_mt, int dst_level,
                       int dst_x, int dst_y, int dst_z,
                       int src_width, int src_height)
{
   bool same_slice;
   void *mapped, *src_mapped, *dst_mapped;
   ptrdiff_t src_stride, dst_stride, cpp;
   int map_x1, map_y1, map_x2, map_y2;
   GLuint src_bw, src_bh;

   cpp = _mesa_get_format_bytes(src_mt->format);
   _mesa_get_format_block_size(src_mt->format, &src_bw, &src_bh);

   assert(src_width % src_bw == 0);
   assert(src_height % src_bw == 0);
   assert(src_x % src_bw == 0);
   assert(src_y % src_bw == 0);

   /* If we are on the same miptree, same level, and same slice, then
    * intel_miptree_map won't let us map it twice.  We have to do things a
    * bit differently.  In particular, we do a single map large enough for
    * both portions and in read-write mode.
    */
   same_slice = src_mt == dst_mt && src_level == dst_level && src_z == dst_z;

   if (same_slice) {
      assert(dst_x % src_bw == 0);
      assert(dst_y % src_bw == 0);

      map_x1 = MIN2(src_x, dst_x);
      map_y1 = MIN2(src_y, dst_y);
      map_x2 = MAX2(src_x, dst_x) + src_width;
      map_y2 = MAX2(src_y, dst_y) + src_height;

      intel_miptree_map(brw, src_mt, src_level, src_z,
                        map_x1, map_y1, map_x2 - map_x1, map_y2 - map_y1,
                        GL_MAP_READ_BIT | GL_MAP_WRITE_BIT,
                        &mapped, &src_stride);

      dst_stride = src_stride;

      /* Set the offsets here so we don't have to think about while looping */
      src_mapped = mapped + ((src_y - map_y1) / src_bh) * src_stride +
                            ((src_x - map_x1) / src_bw) * cpp;
      dst_mapped = mapped + ((dst_y - map_y1) / src_bh) * dst_stride +
                            ((dst_x - map_x1) / src_bw) * cpp;
   } else {
      intel_miptree_map(brw, src_mt, src_level, src_z,
                        src_x, src_y, src_width, src_height,
                        GL_MAP_READ_BIT, &src_mapped, &src_stride);
      intel_miptree_map(brw, dst_mt, dst_level, dst_z,
                        dst_x, dst_y, src_width, src_height,
                        GL_MAP_WRITE_BIT, &dst_mapped, &dst_stride);
   }

   src_width /= (int)src_bw;
   src_height /= (int)src_bh;

   for (int i = 0; i < src_height; ++i) {
      memcpy(dst_mapped, src_mapped, src_width * cpp);
      src_mapped += src_stride;
      dst_mapped += dst_stride;
   }

   if (same_slice) {
      intel_miptree_unmap(brw, src_mt, src_level, src_z);
   } else {
      intel_miptree_unmap(brw, dst_mt, dst_level, dst_z);
      intel_miptree_unmap(brw, src_mt, src_level, src_z);
   }
}

static void
intel_copy_image_sub_data(struct gl_context *ctx,
                          struct gl_texture_image *src_image,
                          int src_x, int src_y, int src_z,
                          struct gl_texture_image *dst_image,
                          int dst_x, int dst_y, int dst_z,
                          int src_width, int src_height)
{
   struct brw_context *brw = brw_context(ctx);
   struct intel_texture_image *intel_src_image = intel_texture_image(src_image);
   struct intel_texture_image *intel_dst_image = intel_texture_image(dst_image);

   if (_mesa_meta_CopyImageSubData_uncompressed(ctx,
                                                src_image, src_x, src_y, src_z,
                                                dst_image, dst_x, dst_y, dst_z,
                                                src_width, src_height)) {
      return;
   }

   if (intel_src_image->mt->num_samples > 0 ||
       intel_dst_image->mt->num_samples > 0) {
      _mesa_problem(ctx, "Failed to copy multisampled texture with meta path\n");
      return;
   }

   /* Cube maps actually have different images per face */
   if (src_image->TexObject->Target == GL_TEXTURE_CUBE_MAP)
      src_z = src_image->Face;
   if (dst_image->TexObject->Target == GL_TEXTURE_CUBE_MAP)
      dst_z = dst_image->Face;

   /* We are now going to try and copy the texture using the blitter.  If
    * that fails, we will fall back mapping the texture and using memcpy.
    * In either case, we need to do a full resolve.
    */
   intel_miptree_all_slices_resolve_hiz(brw, intel_src_image->mt);
   intel_miptree_all_slices_resolve_depth(brw, intel_src_image->mt);
   intel_miptree_resolve_color(brw, intel_src_image->mt);

   intel_miptree_all_slices_resolve_hiz(brw, intel_dst_image->mt);
   intel_miptree_all_slices_resolve_depth(brw, intel_dst_image->mt);
   intel_miptree_resolve_color(brw, intel_dst_image->mt);

   unsigned src_level = src_image->Level + src_image->TexObject->MinLevel;
   unsigned dst_level = dst_image->Level + dst_image->TexObject->MinLevel;
   if (copy_image_with_blitter(brw, intel_src_image->mt, src_level,
                               src_x, src_y, src_z,
                               intel_dst_image->mt, dst_level,
                               dst_x, dst_y, dst_z,
                               src_width, src_height))
      return;

   /* This is a worst-case scenario software fallback that maps the two
    * textures and does a memcpy between them.
    */
   copy_image_with_memcpy(brw, intel_src_image->mt, src_level,
                          src_x, src_y, src_z,
                          intel_dst_image->mt, dst_level,
                          dst_x, dst_y, dst_z,
                          src_width, src_height);
}

void
intelInitCopyImageFuncs(struct dd_function_table *functions)
{
   functions->CopyImageSubData = intel_copy_image_sub_data;
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@a27 1
#include "intel_fbo.h"
a31 1
#include "main/teximage.h"
d44 1
d89 10
d114 6
d125 1
a125 1
                            src_mt->cpp,
d158 1
a158 1
   assert(src_height % src_bh == 0);
d160 1
a160 1
   assert(src_y % src_bh == 0);
d171 1
a171 1
      assert(dst_y % src_bh == 0);
a215 1

a218 1
                          struct gl_renderbuffer *src_renderbuffer,
a220 1
                          struct gl_renderbuffer *dst_renderbuffer,
d225 2
a226 3
   struct intel_mipmap_tree *src_mt, *dst_mt;
   unsigned src_level, dst_level;
   GLuint bw, bh;
d229 2
a230 4
                                                src_image, src_renderbuffer,
                                                src_x, src_y, src_z,
                                                dst_image, dst_renderbuffer,
                                                dst_x, dst_y, dst_z,
d235 2
a236 17
   if (src_image) {
      src_mt = intel_texture_image(src_image)->mt;
   } else {
      assert(src_renderbuffer);
      src_mt = intel_renderbuffer(src_renderbuffer)->mt;
      src_image = src_renderbuffer->TexImage;
   }

   if (dst_image) {
      dst_mt = intel_texture_image(dst_image)->mt;
   } else {
      assert(dst_renderbuffer);
      dst_mt = intel_renderbuffer(dst_renderbuffer)->mt;
      dst_image = dst_renderbuffer->TexImage;
   }

   if (src_mt->num_samples > 0 || dst_mt->num_samples > 0) {
d241 5
a245 19
   if (src_image) {
      src_level = src_image->Level + src_image->TexObject->MinLevel;

      /* Cube maps actually have different images per face */
      if (src_image->TexObject->Target == GL_TEXTURE_CUBE_MAP)
         src_z = src_image->Face;
   } else {
      src_level = 0;
   }

   if (dst_image) {
      dst_level = dst_image->Level + dst_image->TexObject->MinLevel;

      /* Cube maps actually have different images per face */
      if (dst_image->TexObject->Target == GL_TEXTURE_CUBE_MAP)
         dst_z = dst_image->Face;
   } else {
      dst_level = 0;
   }
d251 11
a261 22
   intel_miptree_all_slices_resolve_hiz(brw, src_mt);
   intel_miptree_all_slices_resolve_depth(brw, src_mt);
   intel_miptree_resolve_color(brw, src_mt, 0);

   intel_miptree_all_slices_resolve_hiz(brw, dst_mt);
   intel_miptree_all_slices_resolve_depth(brw, dst_mt);
   intel_miptree_resolve_color(brw, dst_mt, 0);

   _mesa_get_format_block_size(src_mt->format, &bw, &bh);

   /* It's legal to have a WxH that's smaller than a compressed block. This
    * happens for example when you are using a higher level LOD. For this case,
    * we still want to copy the entire block, or else the decompression will be
    * incorrect.
    */
   if (src_width < bw)
      src_width = ALIGN_NPOT(src_width, bw);

   if (src_height < bh)
      src_height = ALIGN_NPOT(src_height, bh);

   if (copy_image_with_blitter(brw, src_mt, src_level,
d263 1
a263 1
                               dst_mt, dst_level,
d271 1
a271 1
   copy_image_with_memcpy(brw, src_mt, src_level,
d273 1
a273 1
                          dst_mt, dst_level,
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@a27 1
#include "brw_blorp.h"
a50 3
   if (src_mt->format == MESA_FORMAT_S_UINT8)
      return false;

a200 60
static void
copy_miptrees(struct brw_context *brw,
              struct intel_mipmap_tree *src_mt,
              int src_x, int src_y, int src_z, unsigned src_level,
              struct intel_mipmap_tree *dst_mt,
              int dst_x, int dst_y, int dst_z, unsigned dst_level,
              int src_width, int src_height)
{
   unsigned bw, bh;

   if (brw->gen >= 6) {
      brw_blorp_copy_miptrees(brw,
                              src_mt, src_level, src_z,
                              dst_mt, dst_level, dst_z,
                              src_x, src_y, dst_x, dst_y,
                              src_width, src_height);
      return;
   }

   /* We are now going to try and copy the texture using the blitter.  If
    * that fails, we will fall back mapping the texture and using memcpy.
    * In either case, we need to do a full resolve.
    */
   intel_miptree_all_slices_resolve_hiz(brw, src_mt);
   intel_miptree_all_slices_resolve_depth(brw, src_mt);
   intel_miptree_resolve_color(brw, src_mt, 0);

   intel_miptree_all_slices_resolve_hiz(brw, dst_mt);
   intel_miptree_all_slices_resolve_depth(brw, dst_mt);
   intel_miptree_resolve_color(brw, dst_mt, 0);

   _mesa_get_format_block_size(src_mt->format, &bw, &bh);

   /* It's legal to have a WxH that's smaller than a compressed block. This
    * happens for example when you are using a higher level LOD. For this case,
    * we still want to copy the entire block, or else the decompression will be
    * incorrect.
    */
   if (src_width < bw)
      src_width = ALIGN_NPOT(src_width, bw);

   if (src_height < bh)
      src_height = ALIGN_NPOT(src_height, bh);

   if (copy_image_with_blitter(brw, src_mt, src_level,
                               src_x, src_y, src_z,
                               dst_mt, dst_level,
                               dst_x, dst_y, dst_z,
                               src_width, src_height))
      return;

   /* This is a worst-case scenario software fallback that maps the two
    * textures and does a memcpy between them.
    */
   copy_image_with_memcpy(brw, src_mt, src_level,
                          src_x, src_y, src_z,
                          dst_mt, dst_level,
                          dst_x, dst_y, dst_z,
                          src_width, src_height);
}
d215 1
d217 1
a217 2
   if (brw->gen < 6 &&
       _mesa_meta_CopyImageSubData_uncompressed(ctx,
d228 20
a252 2

      src_z += src_image->TexObject->MinLayer;
a253 3
      assert(src_renderbuffer);
      src_mt = intel_renderbuffer(src_renderbuffer)->mt;
      src_image = src_renderbuffer->TexImage;
a257 2
      dst_mt = intel_texture_image(dst_image)->mt;

a262 2

      dst_z += dst_image->TexObject->MinLayer;
a263 3
      assert(dst_renderbuffer);
      dst_mt = intel_renderbuffer(dst_renderbuffer)->mt;
      dst_image = dst_renderbuffer->TexImage;
d267 13
a279 3
   copy_miptrees(brw, src_mt, src_x, src_y, src_z, src_level,
                 dst_mt, dst_x, dst_y, dst_z, dst_level,
                 src_width, src_height);
d281 4
a284 6
   /* CopyImage only works for equal formats, texture view equivalence
    * classes, and a couple special cases for compressed textures.
    *
    * Notably, GL_DEPTH_STENCIL does not appear in any equivalence
    * classes, so we know the formats must be the same, and thus both
    * will either have stencil, or not.  They can't be mismatched.
d286 2
a287 1
   assert((src_mt->stencil_mt != NULL) == (dst_mt->stencil_mt != NULL));
d289 18
a306 5
   if (dst_mt->stencil_mt) {
      copy_miptrees(brw, src_mt->stencil_mt, src_x, src_y, src_z, src_level,
                    dst_mt->stencil_mt, dst_x, dst_y, dst_z, dst_level,
                    src_width, src_height);
   }
@


