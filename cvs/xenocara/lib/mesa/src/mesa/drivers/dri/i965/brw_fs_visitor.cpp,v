head	1.3;
access;
symbols
	OPENBSD_6_1:1.1.1.4.0.2
	OPENBSD_6_1_BASE:1.1.1.4
	mesa-13_0_6:1.1.1.4
	mesa-13_0_5:1.1.1.4
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.3
date	2017.08.26.16.59.37;	author jsg;	state Exp;
branches;
next	1.2;
commitid	D0k2io1oY8gcsQ2S;

1.2
date	2017.08.14.09.58.00;	author jsg;	state dead;
branches;
next	1.1;
commitid	bC4bLqwWTo4kLw82;

1.1
date	2015.11.22.02.40.19;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.40.19;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.15.38;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.36.56;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	uuv5VTS15jglEDZU;

1.1.1.4
date	2017.02.26.12.17.28;	author jsg;	state Exp;
branches;
next	;
commitid	xZcdklZavddTKAf1;


desc
@@


1.3
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

/** @@file brw_fs_visitor.cpp
 *
 * This file supports generating the FS LIR from the GLSL IR.  The LIR
 * makes it easier to do backend-specific optimizations than doing so
 * in the GLSL IR or in the native code.
 */
#include "brw_fs.h"
#include "compiler/glsl_types.h"

using namespace brw;

fs_reg *
fs_visitor::emit_vs_system_value(int location)
{
   fs_reg *reg = new(this->mem_ctx)
      fs_reg(ATTR, 4 * (_mesa_bitcount_64(nir->info.inputs_read) +
                        _mesa_bitcount_64(nir->info.double_inputs_read)),
             BRW_REGISTER_TYPE_D);
   struct brw_vs_prog_data *vs_prog_data = brw_vs_prog_data(prog_data);

   switch (location) {
   case SYSTEM_VALUE_BASE_VERTEX:
      reg->offset = 0;
      vs_prog_data->uses_basevertex = true;
      break;
   case SYSTEM_VALUE_BASE_INSTANCE:
      reg->offset = REG_SIZE;
      vs_prog_data->uses_baseinstance = true;
      break;
   case SYSTEM_VALUE_VERTEX_ID:
      unreachable("should have been lowered");
   case SYSTEM_VALUE_VERTEX_ID_ZERO_BASE:
      reg->offset = 2 * REG_SIZE;
      vs_prog_data->uses_vertexid = true;
      break;
   case SYSTEM_VALUE_INSTANCE_ID:
      reg->offset = 3 * REG_SIZE;
      vs_prog_data->uses_instanceid = true;
      break;
   case SYSTEM_VALUE_DRAW_ID:
      if (nir->info.system_values_read &
          (BITFIELD64_BIT(SYSTEM_VALUE_BASE_VERTEX) |
           BITFIELD64_BIT(SYSTEM_VALUE_BASE_INSTANCE) |
           BITFIELD64_BIT(SYSTEM_VALUE_VERTEX_ID_ZERO_BASE) |
           BITFIELD64_BIT(SYSTEM_VALUE_INSTANCE_ID)))
         reg->nr += 4;
      reg->offset = 0;
      vs_prog_data->uses_drawid = true;
      break;
   default:
      unreachable("not reached");
   }

   return reg;
}

/* Sample from the MCS surface attached to this multisample texture. */
fs_reg
fs_visitor::emit_mcs_fetch(const fs_reg &coordinate, unsigned components,
                           const fs_reg &texture)
{
   const fs_reg dest = vgrf(glsl_type::uvec4_type);

   fs_reg srcs[TEX_LOGICAL_NUM_SRCS];
   srcs[TEX_LOGICAL_SRC_COORDINATE] = coordinate;
   srcs[TEX_LOGICAL_SRC_SURFACE] = texture;
   srcs[TEX_LOGICAL_SRC_SAMPLER] = texture;
   srcs[TEX_LOGICAL_SRC_COORD_COMPONENTS] = brw_imm_d(components);
   srcs[TEX_LOGICAL_SRC_GRAD_COMPONENTS] = brw_imm_d(0);

   fs_inst *inst = bld.emit(SHADER_OPCODE_TXF_MCS_LOGICAL, dest, srcs,
                            ARRAY_SIZE(srcs));

   /* We only care about one or two regs of response, but the sampler always
    * writes 4/8.
    */
   inst->size_written = 4 * dest.component_size(inst->exec_size);

   return dest;
}

/**
 * Apply workarounds for Gen6 gather with UINT/SINT
 */
void
fs_visitor::emit_gen6_gather_wa(uint8_t wa, fs_reg dst)
{
   if (!wa)
      return;

   int width = (wa & WA_8BIT) ? 8 : 16;

   for (int i = 0; i < 4; i++) {
      fs_reg dst_f = retype(dst, BRW_REGISTER_TYPE_F);
      /* Convert from UNORM to UINT */
      bld.MUL(dst_f, dst_f, brw_imm_f((1 << width) - 1));
      bld.MOV(dst, dst_f);

      if (wa & WA_SIGN) {
         /* Reinterpret the UINT value as a signed INT value by
          * shifting the sign bit into place, then shifting back
          * preserving sign.
          */
         bld.SHL(dst, dst, brw_imm_d(32 - width));
         bld.ASR(dst, dst, brw_imm_d(32 - width));
      }

      dst = offset(dst, bld, 1);
   }
}

/** Emits a dummy fragment shader consisting of magenta for bringup purposes. */
void
fs_visitor::emit_dummy_fs()
{
   int reg_width = dispatch_width / 8;

   /* Everyone's favorite color. */
   const float color[4] = { 1.0, 0.0, 1.0, 0.0 };
   for (int i = 0; i < 4; i++) {
      bld.MOV(fs_reg(MRF, 2 + i * reg_width, BRW_REGISTER_TYPE_F),
              brw_imm_f(color[i]));
   }

   fs_inst *write;
   write = bld.emit(FS_OPCODE_FB_WRITE);
   write->eot = true;
   if (devinfo->gen >= 6) {
      write->base_mrf = 2;
      write->mlen = 4 * reg_width;
   } else {
      write->header_size = 2;
      write->base_mrf = 0;
      write->mlen = 2 + 4 * reg_width;
   }

   /* Tell the SF we don't have any inputs.  Gen4-5 require at least one
    * varying to avoid GPU hangs, so set that.
    */
   struct brw_wm_prog_data *wm_prog_data = brw_wm_prog_data(this->prog_data);
   wm_prog_data->num_varying_inputs = devinfo->gen < 6 ? 1 : 0;
   memset(wm_prog_data->urb_setup, -1,
          sizeof(wm_prog_data->urb_setup[0]) * VARYING_SLOT_MAX);

   /* We don't have any uniforms. */
   stage_prog_data->nr_params = 0;
   stage_prog_data->nr_pull_params = 0;
   stage_prog_data->curb_read_length = 0;
   stage_prog_data->dispatch_grf_start_reg = 2;
   wm_prog_data->dispatch_grf_start_reg_2 = 2;
   grf_used = 1; /* Gen4-5 don't allow zero GRF blocks */

   calculate_cfg();
}

/* The register location here is relative to the start of the URB
 * data.  It will get adjusted to be a real location before
 * generate_code() time.
 */
struct brw_reg
fs_visitor::interp_reg(int location, int channel)
{
   assert(stage == MESA_SHADER_FRAGMENT);
   struct brw_wm_prog_data *prog_data = brw_wm_prog_data(this->prog_data);
   int regnr = prog_data->urb_setup[location] * 2 + channel / 2;
   int stride = (channel & 1) * 4;

   assert(prog_data->urb_setup[location] != -1);

   return brw_vec1_grf(regnr, stride);
}

/** Emits the interpolation for the varying inputs. */
void
fs_visitor::emit_interpolation_setup_gen4()
{
   struct brw_reg g1_uw = retype(brw_vec1_grf(1, 0), BRW_REGISTER_TYPE_UW);

   fs_builder abld = bld.annotate("compute pixel centers");
   this->pixel_x = vgrf(glsl_type::uint_type);
   this->pixel_y = vgrf(glsl_type::uint_type);
   this->pixel_x.type = BRW_REGISTER_TYPE_UW;
   this->pixel_y.type = BRW_REGISTER_TYPE_UW;
   abld.ADD(this->pixel_x,
            fs_reg(stride(suboffset(g1_uw, 4), 2, 4, 0)),
            fs_reg(brw_imm_v(0x10101010)));
   abld.ADD(this->pixel_y,
            fs_reg(stride(suboffset(g1_uw, 5), 2, 4, 0)),
            fs_reg(brw_imm_v(0x11001100)));

   abld = bld.annotate("compute pixel deltas from v0");

   this->delta_xy[BRW_BARYCENTRIC_PERSPECTIVE_PIXEL] =
      vgrf(glsl_type::vec2_type);
   const fs_reg &delta_xy = this->delta_xy[BRW_BARYCENTRIC_PERSPECTIVE_PIXEL];
   const fs_reg xstart(negate(brw_vec1_grf(1, 0)));
   const fs_reg ystart(negate(brw_vec1_grf(1, 1)));

   if (devinfo->has_pln && dispatch_width == 16) {
      for (unsigned i = 0; i < 2; i++) {
         abld.half(i).ADD(half(offset(delta_xy, abld, i), 0),
                          half(this->pixel_x, i), xstart);
         abld.half(i).ADD(half(offset(delta_xy, abld, i), 1),
                          half(this->pixel_y, i), ystart);
      }
   } else {
      abld.ADD(offset(delta_xy, abld, 0), this->pixel_x, xstart);
      abld.ADD(offset(delta_xy, abld, 1), this->pixel_y, ystart);
   }

   abld = bld.annotate("compute pos.w and 1/pos.w");
   /* Compute wpos.w.  It's always in our setup, since it's needed to
    * interpolate the other attributes.
    */
   this->wpos_w = vgrf(glsl_type::float_type);
   abld.emit(FS_OPCODE_LINTERP, wpos_w, delta_xy,
             interp_reg(VARYING_SLOT_POS, 3));
   /* Compute the pixel 1/W value from wpos.w. */
   this->pixel_w = vgrf(glsl_type::float_type);
   abld.emit(SHADER_OPCODE_RCP, this->pixel_w, wpos_w);
}

/** Emits the interpolation for the varying inputs. */
void
fs_visitor::emit_interpolation_setup_gen6()
{
   struct brw_reg g1_uw = retype(brw_vec1_grf(1, 0), BRW_REGISTER_TYPE_UW);

   fs_builder abld = bld.annotate("compute pixel centers");
   if (devinfo->gen >= 8 || dispatch_width == 8) {
      /* The "Register Region Restrictions" page says for BDW (and newer,
       * presumably):
       *
       *     "When destination spans two registers, the source may be one or
       *      two registers. The destination elements must be evenly split
       *      between the two registers."
       *
       * Thus we can do a single add(16) in SIMD8 or an add(32) in SIMD16 to
       * compute our pixel centers.
       */
      fs_reg int_pixel_xy(VGRF, alloc.allocate(dispatch_width / 8),
                          BRW_REGISTER_TYPE_UW);

      const fs_builder dbld = abld.exec_all().group(dispatch_width * 2, 0);
      dbld.ADD(int_pixel_xy,
               fs_reg(stride(suboffset(g1_uw, 4), 1, 4, 0)),
               fs_reg(brw_imm_v(0x11001010)));

      this->pixel_x = vgrf(glsl_type::float_type);
      this->pixel_y = vgrf(glsl_type::float_type);
      abld.emit(FS_OPCODE_PIXEL_X, this->pixel_x, int_pixel_xy);
      abld.emit(FS_OPCODE_PIXEL_Y, this->pixel_y, int_pixel_xy);
   } else {
      /* The "Register Region Restrictions" page says for SNB, IVB, HSW:
       *
       *     "When destination spans two registers, the source MUST span two
       *      registers."
       *
       * Since the GRF source of the ADD will only read a single register, we
       * must do two separate ADDs in SIMD16.
       */
      fs_reg int_pixel_x = vgrf(glsl_type::uint_type);
      fs_reg int_pixel_y = vgrf(glsl_type::uint_type);
      int_pixel_x.type = BRW_REGISTER_TYPE_UW;
      int_pixel_y.type = BRW_REGISTER_TYPE_UW;
      abld.ADD(int_pixel_x,
               fs_reg(stride(suboffset(g1_uw, 4), 2, 4, 0)),
               fs_reg(brw_imm_v(0x10101010)));
      abld.ADD(int_pixel_y,
               fs_reg(stride(suboffset(g1_uw, 5), 2, 4, 0)),
               fs_reg(brw_imm_v(0x11001100)));

      /* As of gen6, we can no longer mix float and int sources.  We have
       * to turn the integer pixel centers into floats for their actual
       * use.
       */
      this->pixel_x = vgrf(glsl_type::float_type);
      this->pixel_y = vgrf(glsl_type::float_type);
      abld.MOV(this->pixel_x, int_pixel_x);
      abld.MOV(this->pixel_y, int_pixel_y);
   }

   abld = bld.annotate("compute pos.w");
   this->pixel_w = fs_reg(brw_vec8_grf(payload.source_w_reg, 0));
   this->wpos_w = vgrf(glsl_type::float_type);
   abld.emit(SHADER_OPCODE_RCP, this->wpos_w, this->pixel_w);

   struct brw_wm_prog_data *wm_prog_data = brw_wm_prog_data(prog_data);
   uint32_t centroid_modes = wm_prog_data->barycentric_interp_modes &
      (1 << BRW_BARYCENTRIC_PERSPECTIVE_CENTROID |
       1 << BRW_BARYCENTRIC_NONPERSPECTIVE_CENTROID);

   for (int i = 0; i < BRW_BARYCENTRIC_MODE_COUNT; ++i) {
      uint8_t reg = payload.barycentric_coord_reg[i];
      this->delta_xy[i] = fs_reg(brw_vec16_grf(reg, 0));

      if (devinfo->needs_unlit_centroid_workaround &&
          (centroid_modes & (1 << i))) {
         /* Get the pixel/sample mask into f0 so that we know which
          * pixels are lit.  Then, for each channel that is unlit,
          * replace the centroid data with non-centroid data.
          */
         bld.emit(FS_OPCODE_MOV_DISPATCH_TO_FLAGS);

         uint8_t pixel_reg = payload.barycentric_coord_reg[i - 1];

         set_predicate_inv(BRW_PREDICATE_NORMAL, true,
                           bld.half(0).MOV(brw_vec8_grf(reg, 0),
                                           brw_vec8_grf(pixel_reg, 0)));
         set_predicate_inv(BRW_PREDICATE_NORMAL, true,
                           bld.half(0).MOV(brw_vec8_grf(reg + 1, 0),
                                           brw_vec8_grf(pixel_reg + 1, 0)));
         if (dispatch_width == 16) {
            set_predicate_inv(BRW_PREDICATE_NORMAL, true,
                              bld.half(1).MOV(brw_vec8_grf(reg + 2, 0),
                                              brw_vec8_grf(pixel_reg + 2, 0)));
            set_predicate_inv(BRW_PREDICATE_NORMAL, true,
                              bld.half(1).MOV(brw_vec8_grf(reg + 3, 0),
                                              brw_vec8_grf(pixel_reg + 3, 0)));
         }
         assert(dispatch_width != 32); /* not implemented yet */
      }
   }
}

static enum brw_conditional_mod
cond_for_alpha_func(GLenum func)
{
   switch(func) {
      case GL_GREATER:
         return BRW_CONDITIONAL_G;
      case GL_GEQUAL:
         return BRW_CONDITIONAL_GE;
      case GL_LESS:
         return BRW_CONDITIONAL_L;
      case GL_LEQUAL:
         return BRW_CONDITIONAL_LE;
      case GL_EQUAL:
         return BRW_CONDITIONAL_EQ;
      case GL_NOTEQUAL:
         return BRW_CONDITIONAL_NEQ;
      default:
         unreachable("Not reached");
   }
}

/**
 * Alpha test support for when we compile it into the shader instead
 * of using the normal fixed-function alpha test.
 */
void
fs_visitor::emit_alpha_test()
{
   assert(stage == MESA_SHADER_FRAGMENT);
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;
   const fs_builder abld = bld.annotate("Alpha test");

   fs_inst *cmp;
   if (key->alpha_test_func == GL_ALWAYS)
      return;

   if (key->alpha_test_func == GL_NEVER) {
      /* f0.1 = 0 */
      fs_reg some_reg = fs_reg(retype(brw_vec8_grf(0, 0),
                                      BRW_REGISTER_TYPE_UW));
      cmp = abld.CMP(bld.null_reg_f(), some_reg, some_reg,
                     BRW_CONDITIONAL_NEQ);
   } else {
      /* RT0 alpha */
      fs_reg color = offset(outputs[0], bld, 3);

      /* f0.1 &= func(color, ref) */
      cmp = abld.CMP(bld.null_reg_f(), color, brw_imm_f(key->alpha_test_ref),
                     cond_for_alpha_func(key->alpha_test_func));
   }
   cmp->predicate = BRW_PREDICATE_NORMAL;
   cmp->flag_subreg = 1;
}

fs_inst *
fs_visitor::emit_single_fb_write(const fs_builder &bld,
                                 fs_reg color0, fs_reg color1,
                                 fs_reg src0_alpha, unsigned components)
{
   assert(stage == MESA_SHADER_FRAGMENT);
   struct brw_wm_prog_data *prog_data = brw_wm_prog_data(this->prog_data);

   /* Hand over gl_FragDepth or the payload depth. */
   const fs_reg dst_depth = (payload.dest_depth_reg ?
                             fs_reg(brw_vec8_grf(payload.dest_depth_reg, 0)) :
                             fs_reg());
   fs_reg src_depth, src_stencil;

   if (source_depth_to_render_target) {
      if (nir->info.outputs_written & BITFIELD64_BIT(FRAG_RESULT_DEPTH))
         src_depth = frag_depth;
      else
         src_depth = fs_reg(brw_vec8_grf(payload.source_depth_reg, 0));
   }

   if (nir->info.outputs_written & BITFIELD64_BIT(FRAG_RESULT_STENCIL))
      src_stencil = frag_stencil;

   const fs_reg sources[] = {
      color0, color1, src0_alpha, src_depth, dst_depth, src_stencil,
      (prog_data->uses_omask ? sample_mask : fs_reg()),
      brw_imm_ud(components)
   };
   assert(ARRAY_SIZE(sources) - 1 == FB_WRITE_LOGICAL_SRC_COMPONENTS);
   fs_inst *write = bld.emit(FS_OPCODE_FB_WRITE_LOGICAL, fs_reg(),
                             sources, ARRAY_SIZE(sources));

   if (prog_data->uses_kill) {
      write->predicate = BRW_PREDICATE_NORMAL;
      write->flag_subreg = 1;
   }

   return write;
}

void
fs_visitor::emit_fb_writes()
{
   assert(stage == MESA_SHADER_FRAGMENT);
   struct brw_wm_prog_data *prog_data = brw_wm_prog_data(this->prog_data);
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;

   fs_inst *inst = NULL;

   if (source_depth_to_render_target && devinfo->gen == 6) {
      /* For outputting oDepth on gen6, SIMD8 writes have to be used.  This
       * would require SIMD8 moves of each half to message regs, e.g. by using
       * the SIMD lowering pass.  Unfortunately this is more difficult than it
       * sounds because the SIMD8 single-source message lacks channel selects
       * for the second and third subspans.
       */
      limit_dispatch_width(8, "Depth writes unsupported in SIMD16+ mode.\n");
   }

   if (nir->info.outputs_written & BITFIELD64_BIT(FRAG_RESULT_STENCIL)) {
      /* From the 'Render Target Write message' section of the docs:
       * "Output Stencil is not supported with SIMD16 Render Target Write
       * Messages."
       */
      limit_dispatch_width(8, "gl_FragStencilRefARB unsupported "
                           "in SIMD16+ mode.\n");
   }

   for (int target = 0; target < key->nr_color_regions; target++) {
      /* Skip over outputs that weren't written. */
      if (this->outputs[target].file == BAD_FILE)
         continue;

      const fs_builder abld = bld.annotate(
         ralloc_asprintf(this->mem_ctx, "FB write target %d", target));

      fs_reg src0_alpha;
      if (devinfo->gen >= 6 && key->replicate_alpha && target != 0)
         src0_alpha = offset(outputs[0], bld, 3);

      inst = emit_single_fb_write(abld, this->outputs[target],
                                  this->dual_src_output, src0_alpha, 4);
      inst->target = target;
   }

   prog_data->dual_src_blend = (this->dual_src_output.file != BAD_FILE);
   assert(!prog_data->dual_src_blend || key->nr_color_regions == 1);

   if (inst == NULL) {
      /* Even if there's no color buffers enabled, we still need to send
       * alpha out the pipeline to our null renderbuffer to support
       * alpha-testing, alpha-to-coverage, and so on.
       */
      /* FINISHME: Factor out this frequently recurring pattern into a
       * helper function.
       */
      const fs_reg srcs[] = { reg_undef, reg_undef,
                              reg_undef, offset(this->outputs[0], bld, 3) };
      const fs_reg tmp = bld.vgrf(BRW_REGISTER_TYPE_UD, 4);
      bld.LOAD_PAYLOAD(tmp, srcs, 4, 0);

      inst = emit_single_fb_write(bld, tmp, reg_undef, reg_undef, 4);
      inst->target = 0;
   }

   inst->eot = true;
}

void
fs_visitor::setup_uniform_clipplane_values(gl_clip_plane *clip_planes)
{
   const struct brw_vs_prog_key *key =
      (const struct brw_vs_prog_key *) this->key;

   for (int i = 0; i < key->nr_userclip_plane_consts; i++) {
      this->userplane[i] = fs_reg(UNIFORM, uniforms);
      for (int j = 0; j < 4; ++j) {
         stage_prog_data->param[uniforms + j] =
            (gl_constant_value *) &clip_planes[i][j];
      }
      uniforms += 4;
   }
}

/**
 * Lower legacy fixed-function and gl_ClipVertex clipping to clip distances.
 *
 * This does nothing if the shader uses gl_ClipDistance or user clipping is
 * disabled altogether.
 */
void fs_visitor::compute_clip_distance(gl_clip_plane *clip_planes)
{
   struct brw_vue_prog_data *vue_prog_data = brw_vue_prog_data(prog_data);
   const struct brw_vs_prog_key *key =
      (const struct brw_vs_prog_key *) this->key;

   /* Bail unless some sort of legacy clipping is enabled */
   if (key->nr_userclip_plane_consts == 0)
      return;

   /* From the GLSL 1.30 spec, section 7.1 (Vertex Shader Special Variables):
    *
    *     "If a linked set of shaders forming the vertex stage contains no
    *     static write to gl_ClipVertex or gl_ClipDistance, but the
    *     application has requested clipping against user clip planes through
    *     the API, then the coordinate written to gl_Position is used for
    *     comparison against the user clip planes."
    *
    * This function is only called if the shader didn't write to
    * gl_ClipDistance.  Accordingly, we use gl_ClipVertex to perform clipping
    * if the user wrote to it; otherwise we use gl_Position.
    */

   gl_varying_slot clip_vertex = VARYING_SLOT_CLIP_VERTEX;
   if (!(vue_prog_data->vue_map.slots_valid & VARYING_BIT_CLIP_VERTEX))
      clip_vertex = VARYING_SLOT_POS;

   /* If the clip vertex isn't written, skip this.  Typically this means
    * the GS will set up clipping. */
   if (outputs[clip_vertex].file == BAD_FILE)
      return;

   setup_uniform_clipplane_values(clip_planes);

   const fs_builder abld = bld.annotate("user clip distances");

   this->outputs[VARYING_SLOT_CLIP_DIST0] = vgrf(glsl_type::vec4_type);
   this->outputs[VARYING_SLOT_CLIP_DIST1] = vgrf(glsl_type::vec4_type);

   for (int i = 0; i < key->nr_userclip_plane_consts; i++) {
      fs_reg u = userplane[i];
      const fs_reg output = offset(outputs[VARYING_SLOT_CLIP_DIST0 + i / 4],
                                   bld, i & 3);

      abld.MUL(output, outputs[clip_vertex], u);
      for (int j = 1; j < 4; j++) {
         u.nr = userplane[i].nr + j;
         abld.MAD(output, output, offset(outputs[clip_vertex], bld, j), u);
      }
   }
}

void
fs_visitor::emit_urb_writes(const fs_reg &gs_vertex_count)
{
   int slot, urb_offset, length;
   int starting_urb_offset = 0;
   const struct brw_vue_prog_data *vue_prog_data =
      brw_vue_prog_data(this->prog_data);
   const struct brw_vs_prog_key *vs_key =
      (const struct brw_vs_prog_key *) this->key;
   const GLbitfield64 psiz_mask =
      VARYING_BIT_LAYER | VARYING_BIT_VIEWPORT | VARYING_BIT_PSIZ;
   const struct brw_vue_map *vue_map = &vue_prog_data->vue_map;
   bool flush;
   fs_reg sources[8];
   fs_reg urb_handle;

   if (stage == MESA_SHADER_TESS_EVAL)
      urb_handle = fs_reg(retype(brw_vec8_grf(4, 0), BRW_REGISTER_TYPE_UD));
   else
      urb_handle = fs_reg(retype(brw_vec8_grf(1, 0), BRW_REGISTER_TYPE_UD));

   /* If we don't have any valid slots to write, just do a minimal urb write
    * send to terminate the shader.  This includes 1 slot of undefined data,
    * because it's invalid to write 0 data:
    *
    * From the Broadwell PRM, Volume 7: 3D Media GPGPU, Shared Functions -
    * Unified Return Buffer (URB) > URB_SIMD8_Write and URB_SIMD8_Read >
    * Write Data Payload:
    *
    *    "The write data payload can be between 1 and 8 message phases long."
    */
   if (vue_map->slots_valid == 0) {
      /* For GS, just turn EmitVertex() into a no-op.  We don't want it to
       * end the thread, and emit_gs_thread_end() already emits a SEND with
       * EOT at the end of the program for us.
       */
      if (stage == MESA_SHADER_GEOMETRY)
         return;

      fs_reg payload = fs_reg(VGRF, alloc.allocate(2), BRW_REGISTER_TYPE_UD);
      bld.exec_all().MOV(payload, urb_handle);

      fs_inst *inst = bld.emit(SHADER_OPCODE_URB_WRITE_SIMD8, reg_undef, payload);
      inst->eot = true;
      inst->mlen = 2;
      inst->offset = 1;
      return;
   }

   opcode opcode = SHADER_OPCODE_URB_WRITE_SIMD8;
   int header_size = 1;
   fs_reg per_slot_offsets;

   if (stage == MESA_SHADER_GEOMETRY) {
      const struct brw_gs_prog_data *gs_prog_data =
         brw_gs_prog_data(this->prog_data);

      /* We need to increment the Global Offset to skip over the control data
       * header and the extra "Vertex Count" field (1 HWord) at the beginning
       * of the VUE.  We're counting in OWords, so the units are doubled.
       */
      starting_urb_offset = 2 * gs_prog_data->control_data_header_size_hwords;
      if (gs_prog_data->static_vertex_count == -1)
         starting_urb_offset += 2;

      /* We also need to use per-slot offsets.  The per-slot offset is the
       * Vertex Count.  SIMD8 mode processes 8 different primitives at a
       * time; each may output a different number of vertices.
       */
      opcode = SHADER_OPCODE_URB_WRITE_SIMD8_PER_SLOT;
      header_size++;

      /* The URB offset is in 128-bit units, so we need to multiply by 2 */
      const int output_vertex_size_owords =
         gs_prog_data->output_vertex_size_hwords * 2;

      if (gs_vertex_count.file == IMM) {
         per_slot_offsets = brw_imm_ud(output_vertex_size_owords *
                                       gs_vertex_count.ud);
      } else {
         per_slot_offsets = vgrf(glsl_type::int_type);
         bld.MUL(per_slot_offsets, gs_vertex_count,
                 brw_imm_ud(output_vertex_size_owords));
      }
   }

   length = 0;
   urb_offset = starting_urb_offset;
   flush = false;

   /* SSO shaders can have VUE slots allocated which are never actually
    * written to, so ignore them when looking for the last (written) slot.
    */
   int last_slot = vue_map->num_slots - 1;
   while (last_slot > 0 &&
          (vue_map->slot_to_varying[last_slot] == BRW_VARYING_SLOT_PAD ||
           outputs[vue_map->slot_to_varying[last_slot]].file == BAD_FILE)) {
      last_slot--;
   }

   for (slot = 0; slot < vue_map->num_slots; slot++) {
      int varying = vue_map->slot_to_varying[slot];
      switch (varying) {
      case VARYING_SLOT_PSIZ: {
         /* The point size varying slot is the vue header and is always in the
          * vue map.  But often none of the special varyings that live there
          * are written and in that case we can skip writing to the vue
          * header, provided the corresponding state properly clamps the
          * values further down the pipeline. */
         if ((vue_map->slots_valid & psiz_mask) == 0) {
            assert(length == 0);
            urb_offset++;
            break;
         }

         fs_reg zero(VGRF, alloc.allocate(1), BRW_REGISTER_TYPE_UD);
         bld.MOV(zero, brw_imm_ud(0u));

         sources[length++] = zero;
         if (vue_map->slots_valid & VARYING_BIT_LAYER)
            sources[length++] = this->outputs[VARYING_SLOT_LAYER];
         else
            sources[length++] = zero;

         if (vue_map->slots_valid & VARYING_BIT_VIEWPORT)
            sources[length++] = this->outputs[VARYING_SLOT_VIEWPORT];
         else
            sources[length++] = zero;

         if (vue_map->slots_valid & VARYING_BIT_PSIZ)
            sources[length++] = this->outputs[VARYING_SLOT_PSIZ];
         else
            sources[length++] = zero;
         break;
      }
      case BRW_VARYING_SLOT_NDC:
      case VARYING_SLOT_EDGE:
         unreachable("unexpected scalar vs output");
         break;

      default:
         /* gl_Position is always in the vue map, but isn't always written by
          * the shader.  Other varyings (clip distances) get added to the vue
          * map but don't always get written.  In those cases, the
          * corresponding this->output[] slot will be invalid we and can skip
          * the urb write for the varying.  If we've already queued up a vue
          * slot for writing we flush a mlen 5 urb write, otherwise we just
          * advance the urb_offset.
          */
         if (varying == BRW_VARYING_SLOT_PAD ||
             this->outputs[varying].file == BAD_FILE) {
            if (length > 0)
               flush = true;
            else
               urb_offset++;
            break;
         }

         if (stage == MESA_SHADER_VERTEX && vs_key->clamp_vertex_color &&
             (varying == VARYING_SLOT_COL0 ||
              varying == VARYING_SLOT_COL1 ||
              varying == VARYING_SLOT_BFC0 ||
              varying == VARYING_SLOT_BFC1)) {
            /* We need to clamp these guys, so do a saturating MOV into a
             * temp register and use that for the payload.
             */
            for (int i = 0; i < 4; i++) {
               fs_reg reg = fs_reg(VGRF, alloc.allocate(1), outputs[varying].type);
               fs_reg src = offset(this->outputs[varying], bld, i);
               set_saturate(true, bld.MOV(reg, src));
               sources[length++] = reg;
            }
         } else {
            for (unsigned i = 0; i < 4; i++)
               sources[length++] = offset(this->outputs[varying], bld, i);
         }
         break;
      }

      const fs_builder abld = bld.annotate("URB write");

      /* If we've queued up 8 registers of payload (2 VUE slots), if this is
       * the last slot or if we need to flush (see BAD_FILE varying case
       * above), emit a URB write send now to flush out the data.
       */
      if (length == 8 || slot == last_slot)
         flush = true;
      if (flush) {
         fs_reg *payload_sources =
            ralloc_array(mem_ctx, fs_reg, length + header_size);
         fs_reg payload = fs_reg(VGRF, alloc.allocate(length + header_size),
                                 BRW_REGISTER_TYPE_F);
         payload_sources[0] = urb_handle;

         if (opcode == SHADER_OPCODE_URB_WRITE_SIMD8_PER_SLOT)
            payload_sources[1] = per_slot_offsets;

         memcpy(&payload_sources[header_size], sources,
                length * sizeof sources[0]);

         abld.LOAD_PAYLOAD(payload, payload_sources, length + header_size,
                           header_size);

         fs_inst *inst = abld.emit(opcode, reg_undef, payload);
         inst->eot = slot == last_slot && stage != MESA_SHADER_GEOMETRY;
         inst->mlen = length + header_size;
         inst->offset = urb_offset;
         urb_offset = starting_urb_offset + slot + 1;
         length = 0;
         flush = false;
      }
   }
}

void
fs_visitor::emit_cs_terminate()
{
   assert(devinfo->gen >= 7);

   /* We are getting the thread ID from the compute shader header */
   assert(stage == MESA_SHADER_COMPUTE);

   /* We can't directly send from g0, since sends with EOT have to use
    * g112-127. So, copy it to a virtual register, The register allocator will
    * make sure it uses the appropriate register range.
    */
   struct brw_reg g0 = retype(brw_vec8_grf(0, 0), BRW_REGISTER_TYPE_UD);
   fs_reg payload = fs_reg(VGRF, alloc.allocate(1), BRW_REGISTER_TYPE_UD);
   bld.group(8, 0).exec_all().MOV(payload, g0);

   /* Send a message to the thread spawner to terminate the thread. */
   fs_inst *inst = bld.exec_all()
                      .emit(CS_OPCODE_CS_TERMINATE, reg_undef, payload);
   inst->eot = true;
}

void
fs_visitor::emit_barrier()
{
   assert(devinfo->gen >= 7);
   const uint32_t barrier_id_mask =
      devinfo->gen >= 9 ? 0x8f000000u : 0x0f000000u;

   /* We are getting the barrier ID from the compute shader header */
   assert(stage == MESA_SHADER_COMPUTE);

   fs_reg payload = fs_reg(VGRF, alloc.allocate(1), BRW_REGISTER_TYPE_UD);

   const fs_builder pbld = bld.exec_all().group(8, 0);

   /* Clear the message payload */
   pbld.MOV(payload, brw_imm_ud(0u));

   /* Copy the barrier id from r0.2 to the message payload reg.2 */
   fs_reg r0_2 = fs_reg(retype(brw_vec1_grf(0, 2), BRW_REGISTER_TYPE_UD));
   pbld.AND(component(payload, 2), r0_2, brw_imm_ud(barrier_id_mask));

   /* Emit a gateway "barrier" message using the payload we set up, followed
    * by a wait instruction.
    */
   bld.exec_all().emit(SHADER_OPCODE_BARRIER, reg_undef, payload);
}

fs_visitor::fs_visitor(const struct brw_compiler *compiler, void *log_data,
                       void *mem_ctx,
                       const void *key,
                       struct brw_stage_prog_data *prog_data,
                       struct gl_program *prog,
                       const nir_shader *shader,
                       unsigned dispatch_width,
                       int shader_time_index,
                       const struct brw_vue_map *input_vue_map)
   : backend_shader(compiler, log_data, mem_ctx, shader, prog_data),
     key(key), gs_compile(NULL), prog_data(prog_data), prog(prog),
     input_vue_map(input_vue_map),
     dispatch_width(dispatch_width),
     shader_time_index(shader_time_index),
     bld(fs_builder(this, dispatch_width).at_end())
{
   init();
}

fs_visitor::fs_visitor(const struct brw_compiler *compiler, void *log_data,
                       void *mem_ctx,
                       struct brw_gs_compile *c,
                       struct brw_gs_prog_data *prog_data,
                       const nir_shader *shader,
                       int shader_time_index)
   : backend_shader(compiler, log_data, mem_ctx, shader,
                    &prog_data->base.base),
     key(&c->key), gs_compile(c),
     prog_data(&prog_data->base.base), prog(NULL),
     dispatch_width(8),
     shader_time_index(shader_time_index),
     bld(fs_builder(this, dispatch_width).at_end())
{
   init();
}


void
fs_visitor::init()
{
   switch (stage) {
   case MESA_SHADER_FRAGMENT:
      key_tex = &((const brw_wm_prog_key *) key)->tex;
      break;
   case MESA_SHADER_VERTEX:
      key_tex = &((const brw_vs_prog_key *) key)->tex;
      break;
   case MESA_SHADER_TESS_CTRL:
      key_tex = &((const brw_tcs_prog_key *) key)->tex;
      break;
   case MESA_SHADER_TESS_EVAL:
      key_tex = &((const brw_tes_prog_key *) key)->tex;
      break;
   case MESA_SHADER_GEOMETRY:
      key_tex = &((const brw_gs_prog_key *) key)->tex;
      break;
   case MESA_SHADER_COMPUTE:
      key_tex = &((const brw_cs_prog_key*) key)->tex;
      break;
   default:
      unreachable("unhandled shader stage");
   }

   if (stage == MESA_SHADER_COMPUTE) {
      const struct brw_cs_prog_data *cs_prog_data = brw_cs_prog_data(prog_data);
      unsigned size = cs_prog_data->local_size[0] *
                      cs_prog_data->local_size[1] *
                      cs_prog_data->local_size[2];
      size = DIV_ROUND_UP(size, devinfo->max_cs_threads);
      min_dispatch_width = size > 16 ? 32 : (size > 8 ? 16 : 8);
   } else {
      min_dispatch_width = 8;
   }

   this->max_dispatch_width = 32;
   this->prog_data = this->stage_prog_data;

   this->failed = false;

   this->nir_locals = NULL;
   this->nir_ssa_values = NULL;

   memset(&this->payload, 0, sizeof(this->payload));
   this->source_depth_to_render_target = false;
   this->runtime_check_aads_emit = false;
   this->first_non_payload_grf = 0;
   this->max_grf = devinfo->gen >= 7 ? GEN7_MRF_HACK_START : BRW_MAX_GRF;

   this->virtual_grf_start = NULL;
   this->virtual_grf_end = NULL;
   this->live_intervals = NULL;
   this->regs_live_at_ip = NULL;

   this->uniforms = 0;
   this->last_scratch = 0;
   this->pull_constant_loc = NULL;
   this->push_constant_loc = NULL;

   this->promoted_constants = 0,

   this->spilled_any_registers = false;
}

fs_visitor::~fs_visitor()
{
}
@


1.2
log
@Merge Mesa 17.1.6
@
text
@a29 14
#include <sys/types.h>

#include "main/macros.h"
#include "main/shaderobj.h"
#include "program/prog_parameter.h"
#include "program/prog_print.h"
#include "program/prog_optimize.h"
#include "util/register_allocate.h"
#include "program/hash_table.h"
#include "brw_context.h"
#include "brw_eu.h"
#include "brw_wm.h"
#include "brw_cs.h"
#include "brw_vec4.h"
d31 1
a31 4
#include "main/uniforms.h"
#include "glsl/glsl_types.h"
#include "glsl/ir_optimization.h"
#include "program/sampler.h"
d39 4
a42 2
      fs_reg(ATTR, VERT_ATTRIB_MAX, BRW_REGISTER_TYPE_D);
   brw_vs_prog_data *vs_prog_data = (brw_vs_prog_data *) prog_data;
d46 6
a51 2
      reg->reg_offset = 0;
      vs_prog_data->uses_vertexid = true;
d54 1
d56 1
a56 1
      reg->reg_offset = 2;
d60 1
a60 1
      reg->reg_offset = 3;
d63 10
a79 110
fs_reg
fs_visitor::rescale_texcoord(fs_reg coordinate, int coord_components,
                             bool is_rect, uint32_t sampler, int texunit)
{
   bool needs_gl_clamp = true;
   fs_reg scale_x, scale_y;

   /* The 965 requires the EU to do the normalization of GL rectangle
    * texture coordinates.  We use the program parameter state
    * tracking to get the scaling factor.
    */
   if (is_rect &&
       (devinfo->gen < 6 ||
        (devinfo->gen >= 6 && (key_tex->gl_clamp_mask[0] & (1 << sampler) ||
                               key_tex->gl_clamp_mask[1] & (1 << sampler))))) {
      struct gl_program_parameter_list *params = prog->Parameters;
      int tokens[STATE_LENGTH] = {
	 STATE_INTERNAL,
	 STATE_TEXRECT_SCALE,
	 texunit,
	 0,
	 0
      };

      no16("rectangle scale uniform setup not supported on SIMD16\n");
      if (dispatch_width == 16) {
	 return coordinate;
      }

      GLuint index = _mesa_add_state_reference(params,
					       (gl_state_index *)tokens);
      /* Try to find existing copies of the texrect scale uniforms. */
      for (unsigned i = 0; i < uniforms; i++) {
         if (stage_prog_data->param[i] ==
             &prog->Parameters->ParameterValues[index][0]) {
            scale_x = fs_reg(UNIFORM, i);
            scale_y = fs_reg(UNIFORM, i + 1);
            break;
         }
      }

      /* If we didn't already set them up, do so now. */
      if (scale_x.file == BAD_FILE) {
         scale_x = fs_reg(UNIFORM, uniforms);
         scale_y = fs_reg(UNIFORM, uniforms + 1);

         stage_prog_data->param[uniforms++] =
            &prog->Parameters->ParameterValues[index][0];
         stage_prog_data->param[uniforms++] =
            &prog->Parameters->ParameterValues[index][1];
      }
   }

   /* The 965 requires the EU to do the normalization of GL rectangle
    * texture coordinates.  We use the program parameter state
    * tracking to get the scaling factor.
    */
   if (devinfo->gen < 6 && is_rect) {
      fs_reg dst = fs_reg(GRF, alloc.allocate(coord_components));
      fs_reg src = coordinate;
      coordinate = dst;

      bld.MUL(dst, src, scale_x);
      dst = offset(dst, bld, 1);
      src = offset(src, bld, 1);
      bld.MUL(dst, src, scale_y);
   } else if (is_rect) {
      /* On gen6+, the sampler handles the rectangle coordinates
       * natively, without needing rescaling.  But that means we have
       * to do GL_CLAMP clamping at the [0, width], [0, height] scale,
       * not [0, 1] like the default case below.
       */
      needs_gl_clamp = false;

      for (int i = 0; i < 2; i++) {
	 if (key_tex->gl_clamp_mask[i] & (1 << sampler)) {
	    fs_reg chan = coordinate;
	    chan = offset(chan, bld, i);

            set_condmod(BRW_CONDITIONAL_GE,
                        bld.emit(BRW_OPCODE_SEL, chan, chan, fs_reg(0.0f)));

	    /* Our parameter comes in as 1.0/width or 1.0/height,
	     * because that's what people normally want for doing
	     * texture rectangle handling.  We need width or height
	     * for clamping, but we don't care enough to make a new
	     * parameter type, so just invert back.
	     */
	    fs_reg limit = vgrf(glsl_type::float_type);
            bld.MOV(limit, i == 0 ? scale_x : scale_y);
            bld.emit(SHADER_OPCODE_RCP, limit, limit);

            set_condmod(BRW_CONDITIONAL_L,
                        bld.emit(BRW_OPCODE_SEL, chan, chan, limit));
	 }
      }
   }

   if (coord_components > 0 && needs_gl_clamp) {
      for (int i = 0; i < MIN2(coord_components, 3); i++) {
	 if (key_tex->gl_clamp_mask[i] & (1 << sampler)) {
	    fs_reg chan = coordinate;
	    chan = offset(chan, bld, i);
            set_saturate(true, bld.MOV(chan, chan));
	 }
      }
   }
   return coordinate;
}

d83 1
a83 1
                           const fs_reg &sampler)
d86 8
a93 4
   const fs_reg srcs[] = {
      coordinate, fs_reg(), fs_reg(), fs_reg(), fs_reg(), fs_reg(),
      sampler, fs_reg(), fs_reg(components), fs_reg(0)
   };
d97 2
a98 2
   /* We only care about one reg of response, but the sampler always writes
    * 4/8.
d100 1
a100 1
   inst->regs_written = 4 * dispatch_width / 8;
a104 134
void
fs_visitor::emit_texture(ir_texture_opcode op,
                         const glsl_type *dest_type,
                         fs_reg coordinate, int coord_components,
                         fs_reg shadow_c,
                         fs_reg lod, fs_reg lod2, int grad_components,
                         fs_reg sample_index,
                         fs_reg offset_value,
                         fs_reg mcs,
                         int gather_component,
                         bool is_cube_array,
                         bool is_rect,
                         uint32_t sampler,
                         fs_reg sampler_reg, int texunit)
{
   fs_inst *inst = NULL;

   if (op == ir_tg4) {
      /* When tg4 is used with the degenerate ZERO/ONE swizzles, don't bother
       * emitting anything other than setting up the constant result.
       */
      int swiz = GET_SWZ(key_tex->swizzles[sampler], gather_component);
      if (swiz == SWIZZLE_ZERO || swiz == SWIZZLE_ONE) {

         fs_reg res = vgrf(glsl_type::vec4_type);
         this->result = res;

         for (int i=0; i<4; i++) {
            bld.MOV(res, fs_reg(swiz == SWIZZLE_ZERO ? 0.0f : 1.0f));
            res = offset(res, bld, 1);
         }
         return;
      }
   }

   if (op == ir_query_levels) {
      /* textureQueryLevels() is implemented in terms of TXS so we need to
       * pass a valid LOD argument.
       */
      assert(lod.file == BAD_FILE);
      lod = fs_reg(0u);
   }

   if (coordinate.file != BAD_FILE) {
      /* FINISHME: Texture coordinate rescaling doesn't work with non-constant
       * samplers.  This should only be a problem with GL_CLAMP on Gen7.
       */
      coordinate = rescale_texcoord(coordinate, coord_components, is_rect,
                                    sampler, texunit);
   }

   /* Writemasking doesn't eliminate channels on SIMD8 texture
    * samples, so don't worry about them.
    */
   fs_reg dst = vgrf(glsl_type::get_instance(dest_type->base_type, 4, 1));
   const fs_reg srcs[] = {
      coordinate, shadow_c, lod, lod2,
      sample_index, mcs, sampler_reg, offset_value,
      fs_reg(coord_components), fs_reg(grad_components)
   };
   enum opcode opcode;

   switch (op) {
   case ir_tex:
      opcode = SHADER_OPCODE_TEX_LOGICAL;
      break;
   case ir_txb:
      opcode = FS_OPCODE_TXB_LOGICAL;
      break;
   case ir_txl:
      opcode = SHADER_OPCODE_TXL_LOGICAL;
      break;
   case ir_txd:
      opcode = SHADER_OPCODE_TXD_LOGICAL;
      break;
   case ir_txf:
      opcode = SHADER_OPCODE_TXF_LOGICAL;
      break;
   case ir_txf_ms:
      opcode = SHADER_OPCODE_TXF_CMS_LOGICAL;
      break;
   case ir_txs:
   case ir_query_levels:
      opcode = SHADER_OPCODE_TXS_LOGICAL;
      break;
   case ir_lod:
      opcode = SHADER_OPCODE_LOD_LOGICAL;
      break;
   case ir_tg4:
      opcode = (offset_value.file != BAD_FILE && offset_value.file != IMM ?
                SHADER_OPCODE_TG4_OFFSET_LOGICAL : SHADER_OPCODE_TG4_LOGICAL);
      break;
   default:
      unreachable("Invalid texture opcode.");
   }

   inst = bld.emit(opcode, dst, srcs, ARRAY_SIZE(srcs));
   inst->regs_written = 4 * dispatch_width / 8;

   if (shadow_c.file != BAD_FILE)
      inst->shadow_compare = true;

   if (offset_value.file == IMM)
      inst->offset = offset_value.fixed_hw_reg.dw1.ud;

   if (op == ir_tg4) {
      inst->offset |=
         gather_channel(gather_component, sampler) << 16; /* M0.2:16-17 */

      if (devinfo->gen == 6)
         emit_gen6_gather_wa(key_tex->gen6_gather_wa[sampler], dst);
   }

   /* fixup #layers for cube map arrays */
   if (op == ir_txs && is_cube_array) {
      fs_reg depth = offset(dst, bld, 2);
      fs_reg fixed_depth = vgrf(glsl_type::int_type);
      bld.emit(SHADER_OPCODE_INT_QUOTIENT, fixed_depth, depth, fs_reg(6));

      fs_reg *fixed_payload = ralloc_array(mem_ctx, fs_reg, inst->regs_written);
      int components = inst->regs_written / (inst->exec_size / 8);
      for (int i = 0; i < components; i++) {
         if (i == 2) {
            fixed_payload[i] = fixed_depth;
         } else {
            fixed_payload[i] = offset(dst, bld, i);
         }
      }
      bld.LOAD_PAYLOAD(dst, fixed_payload, components, 0);
   }

   swizzle_result(op, dest_type->vector_elements, dst, sampler);
}

d119 1
a119 1
      bld.MUL(dst_f, dst_f, fs_reg((float)((1 << width) - 1)));
d127 2
a128 2
         bld.SHL(dst, dst, fs_reg(32 - width));
         bld.ASR(dst, dst, fs_reg(32 - width));
a134 158
/**
 * Set up the gather channel based on the swizzle, for gather4.
 */
uint32_t
fs_visitor::gather_channel(int orig_chan, uint32_t sampler)
{
   int swiz = GET_SWZ(key_tex->swizzles[sampler], orig_chan);
   switch (swiz) {
      case SWIZZLE_X: return 0;
      case SWIZZLE_Y:
         /* gather4 sampler is broken for green channel on RG32F --
          * we must ask for blue instead.
          */
         if (key_tex->gather_channel_quirk_mask & (1 << sampler))
            return 2;
         return 1;
      case SWIZZLE_Z: return 2;
      case SWIZZLE_W: return 3;
      default:
         unreachable("Not reached"); /* zero, one swizzles handled already */
   }
}

/**
 * Swizzle the result of a texture result.  This is necessary for
 * EXT_texture_swizzle as well as DEPTH_TEXTURE_MODE for shadow comparisons.
 */
void
fs_visitor::swizzle_result(ir_texture_opcode op, int dest_components,
                           fs_reg orig_val, uint32_t sampler)
{
   if (op == ir_query_levels) {
      /* # levels is in .w */
      this->result = offset(orig_val, bld, 3);
      return;
   }

   this->result = orig_val;

   /* txs,lod don't actually sample the texture, so swizzling the result
    * makes no sense.
    */
   if (op == ir_txs || op == ir_lod || op == ir_tg4)
      return;

   if (dest_components == 1) {
      /* Ignore DEPTH_TEXTURE_MODE swizzling. */
   } else if (key_tex->swizzles[sampler] != SWIZZLE_NOOP) {
      fs_reg swizzled_result = vgrf(glsl_type::vec4_type);
      swizzled_result.type = orig_val.type;

      for (int i = 0; i < 4; i++) {
	 int swiz = GET_SWZ(key_tex->swizzles[sampler], i);
	 fs_reg l = swizzled_result;
	 l = offset(l, bld, i);

	 if (swiz == SWIZZLE_ZERO) {
            bld.MOV(l, fs_reg(0.0f));
	 } else if (swiz == SWIZZLE_ONE) {
            bld.MOV(l, fs_reg(1.0f));
	 } else {
            bld.MOV(l, offset(orig_val, bld,
                                  GET_SWZ(key_tex->swizzles[sampler], i)));
	 }
      }
      this->result = swizzled_result;
   }
}

/**
 * Try to replace IF/MOV/ELSE/MOV/ENDIF with SEL.
 *
 * Many GLSL shaders contain the following pattern:
 *
 *    x = condition ? foo : bar
 *
 * The compiler emits an ir_if tree for this, since each subexpression might be
 * a complex tree that could have side-effects or short-circuit logic.
 *
 * However, the common case is to simply select one of two constants or
 * variable values---which is exactly what SEL is for.  In this case, the
 * assembly looks like:
 *
 *    (+f0) IF
 *    MOV dst src0
 *    ELSE
 *    MOV dst src1
 *    ENDIF
 *
 * which can be easily translated into:
 *
 *    (+f0) SEL dst src0 src1
 *
 * If src0 is an immediate value, we promote it to a temporary GRF.
 */
bool
fs_visitor::try_replace_with_sel()
{
   fs_inst *endif_inst = (fs_inst *) instructions.get_tail();
   assert(endif_inst->opcode == BRW_OPCODE_ENDIF);

   /* Pattern match in reverse: IF, MOV, ELSE, MOV, ENDIF. */
   int opcodes[] = {
      BRW_OPCODE_IF, BRW_OPCODE_MOV, BRW_OPCODE_ELSE, BRW_OPCODE_MOV,
   };

   fs_inst *match = (fs_inst *) endif_inst->prev;
   for (int i = 0; i < 4; i++) {
      if (match->is_head_sentinel() || match->opcode != opcodes[4-i-1])
         return false;
      match = (fs_inst *) match->prev;
   }

   /* The opcodes match; it looks like the right sequence of instructions. */
   fs_inst *else_mov = (fs_inst *) endif_inst->prev;
   fs_inst *then_mov = (fs_inst *) else_mov->prev->prev;
   fs_inst *if_inst = (fs_inst *) then_mov->prev;

   /* Check that the MOVs are the right form. */
   if (then_mov->dst.equals(else_mov->dst) &&
       !then_mov->is_partial_write() &&
       !else_mov->is_partial_write()) {

      /* Remove the matched instructions; we'll emit a SEL to replace them. */
      while (!if_inst->next->is_tail_sentinel())
         if_inst->next->exec_node::remove();
      if_inst->exec_node::remove();

      /* Only the last source register can be a constant, so if the MOV in
       * the "then" clause uses a constant, we need to put it in a temporary.
       */
      fs_reg src0(then_mov->src[0]);
      if (src0.file == IMM) {
         src0 = vgrf(glsl_type::float_type);
         src0.type = then_mov->src[0].type;
         bld.MOV(src0, then_mov->src[0]);
      }

      if (if_inst->conditional_mod) {
         /* Sandybridge-specific IF with embedded comparison */
         bld.CMP(bld.null_reg_d(), if_inst->src[0], if_inst->src[1],
                 if_inst->conditional_mod);
         set_predicate(BRW_PREDICATE_NORMAL,
                       bld.emit(BRW_OPCODE_SEL, then_mov->dst,
                                src0, else_mov->src[0]));
      } else {
         /* Separate CMP and IF instructions */
         set_predicate_inv(if_inst->predicate, if_inst->predicate_inverse,
                           bld.emit(BRW_OPCODE_SEL, then_mov->dst,
                                    src0, else_mov->src[0]));
      }

      return true;
   }

   return false;
}

d145 1
a145 1
              fs_reg(color[i]));
d163 1
a163 1
   brw_wm_prog_data *wm_prog_data = (brw_wm_prog_data *) this->prog_data;
d173 1
a173 1
   wm_prog_data->dispatch_grf_start_reg_16 = 2;
d187 1
a187 1
   brw_wm_prog_data *prog_data = (brw_wm_prog_data*) this->prog_data;
d216 1
a216 1
   this->delta_xy[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC] =
d218 1
a218 1
   const fs_reg &delta_xy = this->delta_xy[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC];
d264 1
a264 1
      fs_reg int_pixel_xy(GRF, alloc.allocate(dispatch_width / 8),
d311 6
a316 1
   for (int i = 0; i < BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT; ++i) {
d319 27
d396 1
a396 1
      cmp = abld.CMP(bld.null_reg_f(), color, fs_reg(key->alpha_test_ref),
d409 1
a409 1
   brw_wm_prog_data *prog_data = (brw_wm_prog_data*) this->prog_data;
d415 1
a415 1
   fs_reg src_depth;
d418 1
a418 1
      if (prog->OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_DEPTH))
d424 3
d428 3
a430 2
      color0, color1, src0_alpha, src_depth, dst_depth, sample_mask,
      fs_reg(components)
d432 1
d448 1
a448 1
   brw_wm_prog_data *prog_data = (brw_wm_prog_data*) this->prog_data;
d460 10
a469 1
      no16("Missing support for simd16 depth writes on gen6\n");
d472 4
a475 2
   if (do_dual_src) {
      const fs_builder abld = bld.annotate("FB dual-source write");
d477 6
a482 3
      inst = emit_single_fb_write(abld, this->outputs[0],
                                  this->dual_src_output, reg_undef, 4);
      inst->target = 0;
d484 3
a486 19
      prog_data->dual_src_blend = true;
   } else {
      for (int target = 0; target < key->nr_color_regions; target++) {
         /* Skip over outputs that weren't written. */
         if (this->outputs[target].file == BAD_FILE)
            continue;

         const fs_builder abld = bld.annotate(
            ralloc_asprintf(this->mem_ctx, "FB write target %d", target));

         fs_reg src0_alpha;
         if (devinfo->gen >= 6 && key->replicate_alpha && target != 0)
            src0_alpha = offset(outputs[0], bld, 3);

         inst = emit_single_fb_write(abld, this->outputs[target], reg_undef,
                                     src0_alpha,
                                     this->output_components[target]);
         inst->target = target;
      }
d489 3
d515 2
a516 2
   const struct brw_vue_prog_key *key =
      (const struct brw_vue_prog_key *) this->key;
d536 3
a538 4
   struct brw_vue_prog_data *vue_prog_data =
      (struct brw_vue_prog_data *) prog_data;
   const struct brw_vue_prog_key *key =
      (const struct brw_vue_prog_key *) this->key;
d541 1
a541 1
   if (!key->userclip_active || prog->UsesClipDistanceOut)
d575 2
a576 2
      fs_reg output = outputs[VARYING_SLOT_CLIP_DIST0 + i / 4];
      output.reg_offset = i & 3;
d580 1
a580 1
         u.reg = userplane[i].reg + j;
d587 1
a587 1
fs_visitor::emit_urb_writes()
d590 4
a593 3
   struct brw_vs_prog_data *vs_prog_data =
      (struct brw_vs_prog_data *) prog_data;
   const struct brw_vs_prog_key *key =
d597 1
a597 1
   const struct brw_vue_map *vue_map = &vs_prog_data->base.vue_map;
d600 6
d618 9
a626 3
      fs_reg payload = fs_reg(GRF, alloc.allocate(2), BRW_REGISTER_TYPE_UD);
      bld.exec_all().MOV(payload, fs_reg(retype(brw_vec8_grf(1, 0),
                                                BRW_REGISTER_TYPE_UD)));
d635 37
d673 1
a673 1
   urb_offset = 0;
d675 11
a686 2
      fs_reg reg, src, zero;

d689 1
a689 2
      case VARYING_SLOT_PSIZ:

d701 2
a702 2
         zero = fs_reg(GRF, alloc.allocate(1), BRW_REGISTER_TYPE_UD);
         bld.MOV(zero, fs_reg(0u));
d720 1
a720 1

a725 3
      case BRW_VARYING_SLOT_PAD:
         break;

d735 2
a736 1
         if (this->outputs[varying].file == BAD_FILE) {
d744 2
a745 1
         if ((varying == VARYING_SLOT_COL0 ||
d748 1
a748 2
              varying == VARYING_SLOT_BFC1) &&
             key->clamp_vertex_color) {
d753 2
a754 2
               reg = fs_reg(GRF, alloc.allocate(1), outputs[varying].type);
               src = offset(this->outputs[varying], bld, i);
d759 1
a759 1
            for (int i = 0; i < 4; i++)
d771 1
a771 2
      int last = slot == vue_map->num_slots - 1;
      if (length == 8 || last)
d774 3
a776 2
         fs_reg *payload_sources = ralloc_array(mem_ctx, fs_reg, length + 1);
         fs_reg payload = fs_reg(GRF, alloc.allocate(length + 1),
d778 7
a784 2
         payload_sources[0] =
            fs_reg(retype(brw_vec8_grf(1, 0), BRW_REGISTER_TYPE_UD));
d786 2
a787 2
         memcpy(&payload_sources[1], sources, length * sizeof sources[0]);
         abld.LOAD_PAYLOAD(payload, payload_sources, length + 1, 1);
d789 3
a791 4
         fs_inst *inst =
            abld.emit(SHADER_OPCODE_URB_WRITE_SIMD8, reg_undef, payload);
         inst->eot = last;
         inst->mlen = length + 1;
d793 1
a793 1
         urb_offset = slot + 1;
d813 1
a813 1
   fs_reg payload = fs_reg(GRF, alloc.allocate(1), BRW_REGISTER_TYPE_UD);
d826 2
d832 3
a834 1
   fs_reg payload = fs_reg(GRF, alloc.allocate(1), BRW_REGISTER_TYPE_UD);
d837 1
a837 1
   bld.exec_all().MOV(payload, fs_reg(0u));
d839 1
a839 1
   /* Copy bits 27:24 of r0.2 (barrier id) to the message payload reg.2 */
d841 1
a841 1
   bld.exec_all().AND(component(payload, 2), r0_2, fs_reg(0x0f000000u));
a850 1
                       gl_shader_stage stage,
a852 1
                       struct gl_shader_program *shader_prog,
d854 1
d856 17
d874 5
a878 4
   : backend_shader(compiler, log_data, mem_ctx,
                    shader_prog, prog, prog_data, stage),
     key(key), prog_data(prog_data),
     dispatch_width(dispatch_width),
a879 1
     promoted_constants(0),
d882 7
d894 8
d903 1
a903 1
      key_tex = &((const brw_vue_prog_key *) key)->tex;
d912 14
a926 2
   this->simd16_unsupported = false;
   this->no16_msg = NULL;
a931 2
   memset(this->outputs, 0, sizeof(this->outputs));
   memset(this->output_components, 0, sizeof(this->output_components));
d947 2
a949 4
   this->do_dual_src = false;

   if (dispatch_width == 8)
      this->param_size = rzalloc_array(mem_ctx, int, stage_prog_data->nr_params);
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d30 14
d45 4
a48 1
#include "compiler/glsl_types.h"
d56 1
a56 2
      fs_reg(ATTR, 4 * _mesa_bitcount_64(nir->info.inputs_read),
             BRW_REGISTER_TYPE_D);
d62 1
a62 5
      vs_prog_data->uses_basevertex = true;
      break;
   case SYSTEM_VALUE_BASE_INSTANCE:
      reg->reg_offset = 1;
      vs_prog_data->uses_baseinstance = true;
a64 1
      unreachable("should have been lowered");
a72 10
   case SYSTEM_VALUE_DRAW_ID:
      if (nir->info.system_values_read &
          (BITFIELD64_BIT(SYSTEM_VALUE_BASE_VERTEX) |
           BITFIELD64_BIT(SYSTEM_VALUE_BASE_INSTANCE) |
           BITFIELD64_BIT(SYSTEM_VALUE_VERTEX_ID_ZERO_BASE) |
           BITFIELD64_BIT(SYSTEM_VALUE_INSTANCE_ID)))
         reg->nr += 4;
      reg->reg_offset = 0;
      vs_prog_data->uses_drawid = true;
      break;
d80 110
d193 1
a193 1
                           const fs_reg &texture)
d196 4
a199 8

   fs_reg srcs[TEX_LOGICAL_NUM_SRCS];
   srcs[TEX_LOGICAL_SRC_COORDINATE] = coordinate;
   srcs[TEX_LOGICAL_SRC_SURFACE] = texture;
   srcs[TEX_LOGICAL_SRC_SAMPLER] = texture;
   srcs[TEX_LOGICAL_SRC_COORD_COMPONENTS] = brw_imm_d(components);
   srcs[TEX_LOGICAL_SRC_GRAD_COMPONENTS] = brw_imm_d(0);

d203 2
a204 2
   /* We only care about one or two regs of response, but the sampler always
    * writes 4/8.
d222 1
a222 2
                         uint32_t surface,
                         fs_reg surface_reg,
d224 1
a224 1
                         fs_reg sampler_reg)
d228 18
d251 1
a251 1
      lod = brw_imm_ud(0u);
d254 3
a256 5
   if (op == ir_samples_identical) {
      fs_reg dst = vgrf(glsl_type::get_instance(dest_type->base_type, 1, 1));

      /* If mcs is an immediate value, it means there is no MCS.  In that case
       * just return false.
d258 2
a259 12
      if (mcs.file == BRW_IMMEDIATE_VALUE) {
         bld.MOV(dst, brw_imm_ud(0u));
      } else if ((key_tex->msaa_16 & (1 << sampler))) {
         fs_reg tmp = vgrf(glsl_type::uint_type);
         bld.OR(tmp, mcs, offset(mcs, bld, 1));
         bld.CMP(dst, tmp, brw_imm_ud(0u), BRW_CONDITIONAL_EQ);
      } else {
         bld.CMP(dst, mcs, brw_imm_ud(0u), BRW_CONDITIONAL_EQ);
      }

      this->result = dst;
      return;
d266 6
a272 14
   fs_reg srcs[TEX_LOGICAL_NUM_SRCS];
   srcs[TEX_LOGICAL_SRC_COORDINATE] = coordinate;
   srcs[TEX_LOGICAL_SRC_SHADOW_C] = shadow_c;
   srcs[TEX_LOGICAL_SRC_LOD] = lod;
   srcs[TEX_LOGICAL_SRC_LOD2] = lod2;
   srcs[TEX_LOGICAL_SRC_SAMPLE_INDEX] = sample_index;
   srcs[TEX_LOGICAL_SRC_MCS] = mcs;
   srcs[TEX_LOGICAL_SRC_SURFACE] = surface_reg;
   srcs[TEX_LOGICAL_SRC_SAMPLER] = sampler_reg;
   srcs[TEX_LOGICAL_SRC_OFFSET_VALUE] = offset_value;
   srcs[TEX_LOGICAL_SRC_COORD_COMPONENTS] = brw_imm_d(coord_components);
   srcs[TEX_LOGICAL_SRC_GRAD_COMPONENTS] = brw_imm_d(grad_components);

   enum opcode opcode;
d290 1
a290 4
      if ((key_tex->msaa_16 & (1 << sampler)))
         opcode = SHADER_OPCODE_TXF_CMS_W_LOGICAL;
      else
         opcode = SHADER_OPCODE_TXF_CMS_LOGICAL;
d314 1
a314 1
      inst->offset = offset_value.ud;
d317 2
a318 9
      if (gather_component == 1 &&
          key_tex->gather_channel_quirk_mask & (1 << surface)) {
         /* gather4 sampler is broken for green channel on RG32F --
          * we must ask for blue instead.
          */
         inst->offset |= 2 << 16;
      } else {
         inst->offset |= gather_component << 16;
      }
d321 1
a321 1
         emit_gen6_gather_wa(key_tex->gen6_gather_wa[surface], dst);
d325 1
a325 1
   if (op == ir_txs && (devinfo->gen < 7 || is_cube_array)) {
d328 1
a328 7

      if (is_cube_array) {
         bld.emit(SHADER_OPCODE_INT_QUOTIENT, fixed_depth, depth, brw_imm_d(6));
      } else if (devinfo->gen < 7) {
         /* Gen4-6 return 0 instead of 1 for single layer surfaces. */
         bld.emit_minmax(fixed_depth, depth, brw_imm_d(1), BRW_CONDITIONAL_GE);
      }
d342 1
a342 6
   if (op == ir_query_levels) {
      /* # levels is in .w */
      dst = offset(dst, bld, 3);
   }

   this->result = dst;
d359 1
a359 1
      bld.MUL(dst_f, dst_f, brw_imm_f((1 << width) - 1));
d367 2
a368 2
         bld.SHL(dst, dst, brw_imm_d(32 - width));
         bld.ASR(dst, dst, brw_imm_d(32 - width));
d375 158
d543 1
a543 1
              brw_imm_f(color[i]));
d662 1
a662 1
      fs_reg int_pixel_xy(VGRF, alloc.allocate(dispatch_width / 8),
d762 1
a762 1
      cmp = abld.CMP(bld.null_reg_f(), color, brw_imm_f(key->alpha_test_ref),
d781 1
a781 1
   fs_reg src_depth, src_stencil;
d784 1
a784 1
      if (nir->info.outputs_written & BITFIELD64_BIT(FRAG_RESULT_DEPTH))
a789 3
   if (nir->info.outputs_written & BITFIELD64_BIT(FRAG_RESULT_STENCIL))
      src_stencil = frag_stencil;

d791 2
a792 2
      color0, color1, src0_alpha, src_depth, dst_depth, src_stencil,
      sample_mask, brw_imm_ud(components)
a793 1
   assert(ARRAY_SIZE(sources) - 1 == FB_WRITE_LOGICAL_SRC_COMPONENTS);
a823 10
   if (nir->info.outputs_written & BITFIELD64_BIT(FRAG_RESULT_STENCIL)) {
      /* From the 'Render Target Write message' section of the docs:
       * "Output Stencil is not supported with SIMD16 Render Target Write
       * Messages."
       *
       * FINISHME: split 16 into 2 8s
       */
      no16("FINISHME: support 2 simd8 writes for gl_FragStencilRefARB\n");
   }

d875 2
a876 2
   const struct brw_vs_prog_key *key =
      (const struct brw_vs_prog_key *) this->key;
d898 2
a899 2
   const struct brw_vs_prog_key *key =
      (const struct brw_vs_prog_key *) this->key;
d902 1
a902 1
   if (key->nr_userclip_plane_consts == 0)
a931 1
   this->output_components[VARYING_SLOT_CLIP_DIST0] = 4;
a932 1
   this->output_components[VARYING_SLOT_CLIP_DIST1] = 4;
d941 1
a941 1
         u.nr = userplane[i].nr + j;
d948 1
a948 1
fs_visitor::emit_urb_writes(const fs_reg &gs_vertex_count)
d951 3
a953 4
   int starting_urb_offset = 0;
   const struct brw_vue_prog_data *vue_prog_data =
      (const struct brw_vue_prog_data *) this->prog_data;
   const struct brw_vs_prog_key *vs_key =
d957 1
a957 1
   const struct brw_vue_map *vue_map = &vue_prog_data->vue_map;
a959 6
   fs_reg urb_handle;

   if (stage == MESA_SHADER_TESS_EVAL)
      urb_handle = fs_reg(retype(brw_vec8_grf(4, 0), BRW_REGISTER_TYPE_UD));
   else
      urb_handle = fs_reg(retype(brw_vec8_grf(1, 0), BRW_REGISTER_TYPE_UD));
d972 3
a974 2
      fs_reg payload = fs_reg(VGRF, alloc.allocate(2), BRW_REGISTER_TYPE_UD);
      bld.exec_all().MOV(payload, urb_handle);
a982 37
   opcode opcode = SHADER_OPCODE_URB_WRITE_SIMD8;
   int header_size = 1;
   fs_reg per_slot_offsets;

   if (stage == MESA_SHADER_GEOMETRY) {
      const struct brw_gs_prog_data *gs_prog_data =
         (const struct brw_gs_prog_data *) this->prog_data;

      /* We need to increment the Global Offset to skip over the control data
       * header and the extra "Vertex Count" field (1 HWord) at the beginning
       * of the VUE.  We're counting in OWords, so the units are doubled.
       */
      starting_urb_offset = 2 * gs_prog_data->control_data_header_size_hwords;
      if (gs_prog_data->static_vertex_count == -1)
         starting_urb_offset += 2;

      /* We also need to use per-slot offsets.  The per-slot offset is the
       * Vertex Count.  SIMD8 mode processes 8 different primitives at a
       * time; each may output a different number of vertices.
       */
      opcode = SHADER_OPCODE_URB_WRITE_SIMD8_PER_SLOT;
      header_size++;

      /* The URB offset is in 128-bit units, so we need to multiply by 2 */
      const int output_vertex_size_owords =
         gs_prog_data->output_vertex_size_hwords * 2;

      if (gs_vertex_count.file == IMM) {
         per_slot_offsets = brw_imm_ud(output_vertex_size_owords *
                                       gs_vertex_count.ud);
      } else {
         per_slot_offsets = vgrf(glsl_type::int_type);
         bld.MUL(per_slot_offsets, gs_vertex_count,
                 brw_imm_ud(output_vertex_size_owords));
      }
   }

d984 1
a984 1
   urb_offset = starting_urb_offset;
d987 2
d991 2
a992 1
      case VARYING_SLOT_PSIZ: {
d1004 2
a1005 2
         fs_reg zero(VGRF, alloc.allocate(1), BRW_REGISTER_TYPE_UD);
         bld.MOV(zero, brw_imm_ud(0u));
d1023 1
a1023 1
      }
d1029 3
d1041 1
a1041 2
         if (varying == BRW_VARYING_SLOT_PAD ||
             this->outputs[varying].file == BAD_FILE) {
d1049 1
a1049 2
         if (stage == MESA_SHADER_VERTEX && vs_key->clamp_vertex_color &&
             (varying == VARYING_SLOT_COL0 ||
d1052 2
a1053 1
              varying == VARYING_SLOT_BFC1)) {
d1058 2
a1059 2
               fs_reg reg = fs_reg(VGRF, alloc.allocate(1), outputs[varying].type);
               fs_reg src = offset(this->outputs[varying], bld, i);
d1064 1
a1064 1
            for (unsigned i = 0; i < output_components[varying]; i++)
a1065 2
            for (unsigned i = output_components[varying]; i < 4; i++)
               sources[length++] = brw_imm_d(0);
d1080 2
a1081 3
         fs_reg *payload_sources =
            ralloc_array(mem_ctx, fs_reg, length + header_size);
         fs_reg payload = fs_reg(VGRF, alloc.allocate(length + header_size),
d1083 2
a1084 7
         payload_sources[0] = urb_handle;

         if (opcode == SHADER_OPCODE_URB_WRITE_SIMD8_PER_SLOT)
            payload_sources[1] = per_slot_offsets;

         memcpy(&payload_sources[header_size], sources,
                length * sizeof sources[0]);
d1086 2
a1087 2
         abld.LOAD_PAYLOAD(payload, payload_sources, length + header_size,
                           header_size);
d1089 4
a1092 3
         fs_inst *inst = abld.emit(opcode, reg_undef, payload);
         inst->eot = last && stage != MESA_SHADER_GEOMETRY;
         inst->mlen = length + header_size;
d1094 1
a1094 1
         urb_offset = starting_urb_offset + slot + 1;
d1114 1
a1114 1
   fs_reg payload = fs_reg(VGRF, alloc.allocate(1), BRW_REGISTER_TYPE_UD);
a1126 2
   const uint32_t barrier_id_mask =
      devinfo->gen >= 9 ? 0x8f000000u : 0x0f000000u;
d1131 1
a1131 3
   fs_reg payload = fs_reg(VGRF, alloc.allocate(1), BRW_REGISTER_TYPE_UD);

   const fs_builder pbld = bld.exec_all().group(8, 0);
d1134 1
a1134 1
   pbld.MOV(payload, brw_imm_ud(0u));
d1136 1
a1136 1
   /* Copy the barrier id from r0.2 to the message payload reg.2 */
d1138 1
a1138 1
   pbld.AND(component(payload, 2), r0_2, brw_imm_ud(barrier_id_mask));
d1148 1
d1151 1
a1152 1
                       const nir_shader *shader,
d1154 4
a1157 5
                       int shader_time_index,
                       const struct brw_vue_map *input_vue_map)
   : backend_shader(compiler, log_data, mem_ctx, shader, prog_data),
     key(key), gs_compile(NULL), prog_data(prog_data), prog(prog),
     input_vue_map(input_vue_map),
d1160 1
a1162 24
   init();
}

fs_visitor::fs_visitor(const struct brw_compiler *compiler, void *log_data,
                       void *mem_ctx,
                       struct brw_gs_compile *c,
                       struct brw_gs_prog_data *prog_data,
                       const nir_shader *shader,
                       int shader_time_index)
   : backend_shader(compiler, log_data, mem_ctx, shader,
                    &prog_data->base.base),
     key(&c->key), gs_compile(c),
     prog_data(&prog_data->base.base), prog(NULL),
     dispatch_width(8),
     shader_time_index(shader_time_index),
     bld(fs_builder(this, dispatch_width).at_end())
{
   init();
}


void
fs_visitor::init()
{
a1167 5
      key_tex = &((const brw_vs_prog_key *) key)->tex;
      break;
   case MESA_SHADER_TESS_EVAL:
      key_tex = &((const brw_tes_prog_key *) key)->tex;
      break;
d1169 1
a1169 1
      key_tex = &((const brw_gs_prog_key *) key)->tex;
a1177 14
   if (stage == MESA_SHADER_COMPUTE) {
      const brw_cs_prog_data *cs_prog_data =
         (const brw_cs_prog_data *) prog_data;
      unsigned size = cs_prog_data->local_size[0] *
                      cs_prog_data->local_size[1] *
                      cs_prog_data->local_size[2];
      size = DIV_ROUND_UP(size, devinfo->max_cs_threads);
      min_dispatch_width = size > 16 ? 32 : (size > 8 ? 16 : 8);
   } else {
      min_dispatch_width = 8;
   }

   this->prog_data = this->stage_prog_data;

d1186 1
a1201 2

   this->promoted_constants = 0,
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@d39 1
a39 2
      fs_reg(ATTR, 4 * (_mesa_bitcount_64(nir->info.inputs_read) +
                        _mesa_bitcount_64(nir->info.double_inputs_read)),
d41 1
a41 1
   struct brw_vs_prog_data *vs_prog_data = brw_vs_prog_data(prog_data);
d45 1
a45 1
      reg->offset = 0;
d49 1
a49 1
      reg->offset = REG_SIZE;
d55 1
a55 1
      reg->offset = 2 * REG_SIZE;
d59 1
a59 1
      reg->offset = 3 * REG_SIZE;
d69 1
a69 1
      reg->offset = 0;
d99 1
a99 1
   inst->size_written = 4 * dest.component_size(inst->exec_size);
d104 158
d320 1
a320 1
   struct brw_wm_prog_data *wm_prog_data = brw_wm_prog_data(this->prog_data);
d330 1
a330 1
   wm_prog_data->dispatch_grf_start_reg_2 = 2;
d344 1
a344 1
   struct brw_wm_prog_data *prog_data = brw_wm_prog_data(this->prog_data);
d373 1
a373 1
   this->delta_xy[BRW_BARYCENTRIC_PERSPECTIVE_PIXEL] =
d375 1
a375 1
   const fs_reg &delta_xy = this->delta_xy[BRW_BARYCENTRIC_PERSPECTIVE_PIXEL];
d468 1
a468 6
   struct brw_wm_prog_data *wm_prog_data = brw_wm_prog_data(prog_data);
   uint32_t centroid_modes = wm_prog_data->barycentric_interp_modes &
      (1 << BRW_BARYCENTRIC_PERSPECTIVE_CENTROID |
       1 << BRW_BARYCENTRIC_NONPERSPECTIVE_CENTROID);

   for (int i = 0; i < BRW_BARYCENTRIC_MODE_COUNT; ++i) {
a470 27

      if (devinfo->needs_unlit_centroid_workaround &&
          (centroid_modes & (1 << i))) {
         /* Get the pixel/sample mask into f0 so that we know which
          * pixels are lit.  Then, for each channel that is unlit,
          * replace the centroid data with non-centroid data.
          */
         bld.emit(FS_OPCODE_MOV_DISPATCH_TO_FLAGS);

         uint8_t pixel_reg = payload.barycentric_coord_reg[i - 1];

         set_predicate_inv(BRW_PREDICATE_NORMAL, true,
                           bld.half(0).MOV(brw_vec8_grf(reg, 0),
                                           brw_vec8_grf(pixel_reg, 0)));
         set_predicate_inv(BRW_PREDICATE_NORMAL, true,
                           bld.half(0).MOV(brw_vec8_grf(reg + 1, 0),
                                           brw_vec8_grf(pixel_reg + 1, 0)));
         if (dispatch_width == 16) {
            set_predicate_inv(BRW_PREDICATE_NORMAL, true,
                              bld.half(1).MOV(brw_vec8_grf(reg + 2, 0),
                                              brw_vec8_grf(pixel_reg + 2, 0)));
            set_predicate_inv(BRW_PREDICATE_NORMAL, true,
                              bld.half(1).MOV(brw_vec8_grf(reg + 3, 0),
                                              brw_vec8_grf(pixel_reg + 3, 0)));
         }
         assert(dispatch_width != 32); /* not implemented yet */
      }
d534 1
a534 1
   struct brw_wm_prog_data *prog_data = brw_wm_prog_data(this->prog_data);
d554 1
a554 2
      (prog_data->uses_omask ? sample_mask : fs_reg()),
      brw_imm_ud(components)
d572 1
a572 1
   struct brw_wm_prog_data *prog_data = brw_wm_prog_data(this->prog_data);
d584 1
a584 1
      limit_dispatch_width(8, "Depth writes unsupported in SIMD16+ mode.\n");
d591 2
d594 1
a594 2
      limit_dispatch_width(8, "gl_FragStencilRefARB unsupported "
                           "in SIMD16+ mode.\n");
d597 2
a598 4
   for (int target = 0; target < key->nr_color_regions; target++) {
      /* Skip over outputs that weren't written. */
      if (this->outputs[target].file == BAD_FILE)
         continue;
d600 3
a602 2
      const fs_builder abld = bld.annotate(
         ralloc_asprintf(this->mem_ctx, "FB write target %d", target));
d604 19
a622 7
      fs_reg src0_alpha;
      if (devinfo->gen >= 6 && key->replicate_alpha && target != 0)
         src0_alpha = offset(outputs[0], bld, 3);

      inst = emit_single_fb_write(abld, this->outputs[target],
                                  this->dual_src_output, src0_alpha, 4);
      inst->target = target;
a624 3
   prog_data->dual_src_blend = (this->dual_src_output.file != BAD_FILE);
   assert(!prog_data->dual_src_blend || key->nr_color_regions == 1);

d669 2
a670 1
   struct brw_vue_prog_data *vue_prog_data = brw_vue_prog_data(prog_data);
d705 1
d707 1
d711 2
a712 2
      const fs_reg output = offset(outputs[VARYING_SLOT_CLIP_DIST0 + i / 4],
                                   bld, i & 3);
d728 1
a728 1
      brw_vue_prog_data(this->prog_data);
a753 7
      /* For GS, just turn EmitVertex() into a no-op.  We don't want it to
       * end the thread, and emit_gs_thread_end() already emits a SEND with
       * EOT at the end of the program for us.
       */
      if (stage == MESA_SHADER_GEOMETRY)
         return;

d770 1
a770 1
         brw_gs_prog_data(this->prog_data);
d877 1
a877 1
            for (unsigned i = 0; i < 4; i++)
d879 2
a1016 3
   case MESA_SHADER_TESS_CTRL:
      key_tex = &((const brw_tcs_prog_key *) key)->tex;
      break;
d1031 2
a1032 1
      const struct brw_cs_prog_data *cs_prog_data = brw_cs_prog_data(prog_data);
a1041 1
   this->max_dispatch_width = 32;
d1045 2
d1052 1
d1071 4
@


1.1.1.4
log
@Import Mesa 13.0.5
@
text
@a674 11

   /* SSO shaders can have VUE slots allocated which are never actually
    * written to, so ignore them when looking for the last (written) slot.
    */
   int last_slot = vue_map->num_slots - 1;
   while (last_slot > 0 &&
          (vue_map->slot_to_varying[last_slot] == BRW_VARYING_SLOT_PAD ||
           outputs[vue_map->slot_to_varying[last_slot]].file == BAD_FILE)) {
      last_slot--;
   }

d760 2
a761 1
      if (length == 8 || slot == last_slot)
d780 1
a780 1
         inst->eot = slot == last_slot && stage != MESA_SHADER_GEOMETRY;
@


