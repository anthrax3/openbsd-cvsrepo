head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.5.0.2
	OPENBSD_6_1_BASE:1.1.1.5
	mesa-13_0_6:1.1.1.5
	mesa-13_0_5:1.1.1.4
	mesa-13_0_3:1.1.1.4
	mesa-13_0_2:1.1.1.4
	OPENBSD_6_0:1.1.1.3.0.4
	OPENBSD_6_0_BASE:1.1.1.3
	mesa-11_2_2:1.1.1.3
	OPENBSD_5_9:1.1.1.2.0.2
	OPENBSD_5_9_BASE:1.1.1.2
	mesa-11_0_9:1.1.1.2
	mesa-11_0_8:1.1.1.2
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2015.11.22.02.40.17;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.40.17;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2015.12.23.13.22.18;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	bCnCUEGWDw3j16Q3;

1.1.1.3
date	2016.05.29.10.15.36;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.4
date	2016.12.11.08.37.02;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	uuv5VTS15jglEDZU;

1.1.1.5
date	2017.03.25.00.16.35;	author jsg;	state Exp;
branches;
next	;
commitid	YgkKuQ9hssScckR1;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include "glsl/ir.h"
#include "glsl/ir_optimization.h"
#include "glsl/nir/glsl_to_nir.h"
#include "main/shaderimage.h"
#include "program/prog_to_nir.h"
#include "brw_fs.h"
#include "brw_fs_surface_builder.h"
#include "brw_nir.h"

using namespace brw;

void
fs_visitor::emit_nir_code()
{
   nir_shader *nir = prog->nir;

   /* emit the arrays used for inputs and outputs - load/store intrinsics will
    * be converted to reads/writes of these arrays
    */
   nir_setup_inputs(nir);
   nir_setup_outputs(nir);
   nir_setup_uniforms(nir);
   nir_emit_system_values(nir);

   /* get the main function and emit it */
   nir_foreach_overload(nir, overload) {
      assert(strcmp(overload->function->name, "main") == 0);
      assert(overload->impl);
      nir_emit_impl(overload->impl);
   }
}

void
fs_visitor::nir_setup_inputs(nir_shader *shader)
{
   nir_inputs = bld.vgrf(BRW_REGISTER_TYPE_F, shader->num_inputs);

   foreach_list_typed(nir_variable, var, node, &shader->inputs) {
      enum brw_reg_type type = brw_type_for_base_type(var->type);
      fs_reg input = offset(nir_inputs, bld, var->data.driver_location);

      fs_reg reg;
      switch (stage) {
      case MESA_SHADER_VERTEX: {
         /* Our ATTR file is indexed by VERT_ATTRIB_*, which is the value
          * stored in nir_variable::location.
          *
          * However, NIR's load_input intrinsics use a different index - an
          * offset into a single contiguous array containing all inputs.
          * This index corresponds to the nir_variable::driver_location field.
          *
          * So, we need to copy from fs_reg(ATTR, var->location) to
          * offset(nir_inputs, var->data.driver_location).
          */
         const glsl_type *const t = var->type->without_array();
         const unsigned components = t->components();
         const unsigned cols = t->matrix_columns;
         const unsigned elts = t->vector_elements;
         unsigned array_length = var->type->is_array() ? var->type->length : 1;
         for (unsigned i = 0; i < array_length; i++) {
            for (unsigned j = 0; j < cols; j++) {
               for (unsigned k = 0; k < elts; k++) {
                  bld.MOV(offset(retype(input, type), bld,
                                 components * i + elts * j + k),
                          offset(fs_reg(ATTR, var->data.location + i, type),
                                 bld, 4 * j + k));
               }
            }
         }
         break;
      }
      case MESA_SHADER_GEOMETRY:
      case MESA_SHADER_COMPUTE:
      case MESA_SHADER_TESS_CTRL:
      case MESA_SHADER_TESS_EVAL:
         unreachable("fs_visitor not used for these stages yet.");
         break;
      case MESA_SHADER_FRAGMENT:
         if (var->data.location == VARYING_SLOT_POS) {
            reg = *emit_fragcoord_interpolation(var->data.pixel_center_integer,
                                                var->data.origin_upper_left);
            emit_percomp(bld, fs_inst(BRW_OPCODE_MOV, bld.dispatch_width(),
                                      input, reg), 0xF);
         } else {
            emit_general_interpolation(input, var->name, var->type,
                                       (glsl_interp_qualifier) var->data.interpolation,
                                       var->data.location, var->data.centroid,
                                       var->data.sample);
         }
         break;
      }
   }
}

void
fs_visitor::nir_setup_outputs(nir_shader *shader)
{
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;

   nir_outputs = bld.vgrf(BRW_REGISTER_TYPE_F, shader->num_outputs);

   foreach_list_typed(nir_variable, var, node, &shader->outputs) {
      fs_reg reg = offset(nir_outputs, bld, var->data.driver_location);

      int vector_elements =
         var->type->is_array() ? var->type->fields.array->vector_elements
                               : var->type->vector_elements;

      switch (stage) {
      case MESA_SHADER_VERTEX:
         for (int i = 0; i < ALIGN(type_size(var->type), 4) / 4; i++) {
            int output = var->data.location + i;
            this->outputs[output] = offset(reg, bld, 4 * i);
            this->output_components[output] = vector_elements;
         }
         break;
      case MESA_SHADER_FRAGMENT:
         if (var->data.index > 0) {
            assert(var->data.location == FRAG_RESULT_DATA0);
            assert(var->data.index == 1);
            this->dual_src_output = reg;
            this->do_dual_src = true;
         } else if (var->data.location == FRAG_RESULT_COLOR) {
            /* Writing gl_FragColor outputs to all color regions. */
            for (unsigned int i = 0; i < MAX2(key->nr_color_regions, 1); i++) {
               this->outputs[i] = reg;
               this->output_components[i] = 4;
            }
         } else if (var->data.location == FRAG_RESULT_DEPTH) {
            this->frag_depth = reg;
         } else if (var->data.location == FRAG_RESULT_SAMPLE_MASK) {
            this->sample_mask = reg;
         } else {
            /* gl_FragData or a user-defined FS output */
            assert(var->data.location >= FRAG_RESULT_DATA0 &&
                   var->data.location < FRAG_RESULT_DATA0+BRW_MAX_DRAW_BUFFERS);

            /* General color output. */
            for (unsigned int i = 0; i < MAX2(1, var->type->length); i++) {
               int output = var->data.location - FRAG_RESULT_DATA0 + i;
               this->outputs[output] = offset(reg, bld, vector_elements * i);
               this->output_components[output] = vector_elements;
            }
         }
         break;
      default:
         unreachable("unhandled shader stage");
      }
   }
}

void
fs_visitor::nir_setup_uniforms(nir_shader *shader)
{
   num_direct_uniforms = shader->num_direct_uniforms;

   if (dispatch_width != 8)
      return;

   /* We split the uniform register file in half.  The first half is
    * entirely direct uniforms.  The second half is indirect.
    */
   if (num_direct_uniforms > 0)
      param_size[0] = num_direct_uniforms;
   if (shader->num_uniforms > num_direct_uniforms)
      param_size[num_direct_uniforms] = shader->num_uniforms - num_direct_uniforms;

   uniforms = shader->num_uniforms;

   if (shader_prog) {
      foreach_list_typed(nir_variable, var, node, &shader->uniforms) {
         /* UBO's and atomics don't take up space in the uniform file */
         if (var->interface_type != NULL || var->type->contains_atomic())
            continue;

         if (strncmp(var->name, "gl_", 3) == 0)
            nir_setup_builtin_uniform(var);
         else
            nir_setup_uniform(var);
      }
   } else {
      /* prog_to_nir doesn't create uniform variables; set param up directly. */
      for (unsigned p = 0; p < prog->Parameters->NumParameters; p++) {
         for (unsigned int i = 0; i < 4; i++) {
            stage_prog_data->param[4 * p + i] =
               &prog->Parameters->ParameterValues[p][i];
         }
      }
   }
}

void
fs_visitor::nir_setup_uniform(nir_variable *var)
{
   int namelen = strlen(var->name);

   /* The data for our (non-builtin) uniforms is stored in a series of
      * gl_uniform_driver_storage structs for each subcomponent that
      * glGetUniformLocation() could name.  We know it's been set up in the
      * same order we'd walk the type, so walk the list of storage and find
      * anything with our name, or the prefix of a component that starts with
      * our name.
      */
   unsigned index = var->data.driver_location;
   for (unsigned u = 0; u < shader_prog->NumUniformStorage; u++) {
      struct gl_uniform_storage *storage = &shader_prog->UniformStorage[u];

      if (storage->builtin)
              continue;

      if (strncmp(var->name, storage->name, namelen) != 0 ||
         (storage->name[namelen] != 0 &&
         storage->name[namelen] != '.' &&
         storage->name[namelen] != '[')) {
         continue;
      }

      if (storage->type->is_image()) {
         /* Images don't get a valid location assigned by nir_lower_io()
          * because their size is driver-specific, so we need to allocate
          * space for them here at the end of the parameter array.
          */
         var->data.driver_location = uniforms;
         param_size[uniforms] =
            BRW_IMAGE_PARAM_SIZE * MAX2(storage->array_elements, 1);

         setup_image_uniform_values(storage);
      } else {
         unsigned slots = storage->type->component_slots();
         if (storage->array_elements)
            slots *= storage->array_elements;

         for (unsigned i = 0; i < slots; i++) {
            stage_prog_data->param[index++] = &storage->storage[i];
         }
      }
   }
}

void
fs_visitor::nir_setup_builtin_uniform(nir_variable *var)
{
   const nir_state_slot *const slots = var->state_slots;
   assert(var->state_slots != NULL);

   unsigned uniform_index = var->data.driver_location;
   for (unsigned int i = 0; i < var->num_state_slots; i++) {
      /* This state reference has already been setup by ir_to_mesa, but we'll
       * get the same index back here.
       */
      int index = _mesa_add_state_reference(this->prog->Parameters,
                                            (gl_state_index *)slots[i].tokens);

      /* Add each of the unique swizzles of the element as a parameter.
       * This'll end up matching the expected layout of the
       * array/matrix/structure we're trying to fill in.
       */
      int last_swiz = -1;
      for (unsigned int j = 0; j < 4; j++) {
         int swiz = GET_SWZ(slots[i].swizzle, j);
         if (swiz == last_swiz)
            break;
         last_swiz = swiz;

         stage_prog_data->param[uniform_index++] =
            &prog->Parameters->ParameterValues[index][swiz];
      }
   }
}

static bool
emit_system_values_block(nir_block *block, void *void_visitor)
{
   fs_visitor *v = (fs_visitor *)void_visitor;
   fs_reg *reg;

   nir_foreach_instr(block, instr) {
      if (instr->type != nir_instr_type_intrinsic)
         continue;

      nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);
      switch (intrin->intrinsic) {
      case nir_intrinsic_load_vertex_id:
         unreachable("should be lowered by lower_vertex_id().");

      case nir_intrinsic_load_vertex_id_zero_base:
         assert(v->stage == MESA_SHADER_VERTEX);
         reg = &v->nir_system_values[SYSTEM_VALUE_VERTEX_ID_ZERO_BASE];
         if (reg->file == BAD_FILE)
            *reg = *v->emit_vs_system_value(SYSTEM_VALUE_VERTEX_ID_ZERO_BASE);
         break;

      case nir_intrinsic_load_base_vertex:
         assert(v->stage == MESA_SHADER_VERTEX);
         reg = &v->nir_system_values[SYSTEM_VALUE_BASE_VERTEX];
         if (reg->file == BAD_FILE)
            *reg = *v->emit_vs_system_value(SYSTEM_VALUE_BASE_VERTEX);
         break;

      case nir_intrinsic_load_instance_id:
         assert(v->stage == MESA_SHADER_VERTEX);
         reg = &v->nir_system_values[SYSTEM_VALUE_INSTANCE_ID];
         if (reg->file == BAD_FILE)
            *reg = *v->emit_vs_system_value(SYSTEM_VALUE_INSTANCE_ID);
         break;

      case nir_intrinsic_load_sample_pos:
         assert(v->stage == MESA_SHADER_FRAGMENT);
         reg = &v->nir_system_values[SYSTEM_VALUE_SAMPLE_POS];
         if (reg->file == BAD_FILE)
            *reg = *v->emit_samplepos_setup();
         break;

      case nir_intrinsic_load_sample_id:
         assert(v->stage == MESA_SHADER_FRAGMENT);
         reg = &v->nir_system_values[SYSTEM_VALUE_SAMPLE_ID];
         if (reg->file == BAD_FILE)
            *reg = *v->emit_sampleid_setup();
         break;

      case nir_intrinsic_load_sample_mask_in:
         assert(v->stage == MESA_SHADER_FRAGMENT);
         assert(v->devinfo->gen >= 7);
         reg = &v->nir_system_values[SYSTEM_VALUE_SAMPLE_MASK_IN];
         if (reg->file == BAD_FILE)
            *reg = fs_reg(retype(brw_vec8_grf(v->payload.sample_mask_in_reg, 0),
                                 BRW_REGISTER_TYPE_D));
         break;

      default:
         break;
      }
   }

   return true;
}

void
fs_visitor::nir_emit_system_values(nir_shader *shader)
{
   nir_system_values = ralloc_array(mem_ctx, fs_reg, SYSTEM_VALUE_MAX);
   nir_foreach_overload(shader, overload) {
      assert(strcmp(overload->function->name, "main") == 0);
      assert(overload->impl);
      nir_foreach_block(overload->impl, emit_system_values_block, this);
   }
}

void
fs_visitor::nir_emit_impl(nir_function_impl *impl)
{
   nir_locals = reralloc(mem_ctx, nir_locals, fs_reg, impl->reg_alloc);
   foreach_list_typed(nir_register, reg, node, &impl->registers) {
      unsigned array_elems =
         reg->num_array_elems == 0 ? 1 : reg->num_array_elems;
      unsigned size = array_elems * reg->num_components;
      nir_locals[reg->index] = bld.vgrf(BRW_REGISTER_TYPE_F, size);
   }

   nir_ssa_values = reralloc(mem_ctx, nir_ssa_values, fs_reg,
                             impl->ssa_alloc);

   nir_emit_cf_list(&impl->body);
}

void
fs_visitor::nir_emit_cf_list(exec_list *list)
{
   exec_list_validate(list);
   foreach_list_typed(nir_cf_node, node, node, list) {
      switch (node->type) {
      case nir_cf_node_if:
         nir_emit_if(nir_cf_node_as_if(node));
         break;

      case nir_cf_node_loop:
         nir_emit_loop(nir_cf_node_as_loop(node));
         break;

      case nir_cf_node_block:
         nir_emit_block(nir_cf_node_as_block(node));
         break;

      default:
         unreachable("Invalid CFG node block");
      }
   }
}

void
fs_visitor::nir_emit_if(nir_if *if_stmt)
{
   /* first, put the condition into f0 */
   fs_inst *inst = bld.MOV(bld.null_reg_d(),
                            retype(get_nir_src(if_stmt->condition),
                                   BRW_REGISTER_TYPE_D));
   inst->conditional_mod = BRW_CONDITIONAL_NZ;

   bld.IF(BRW_PREDICATE_NORMAL);

   nir_emit_cf_list(&if_stmt->then_list);

   /* note: if the else is empty, dead CF elimination will remove it */
   bld.emit(BRW_OPCODE_ELSE);

   nir_emit_cf_list(&if_stmt->else_list);

   bld.emit(BRW_OPCODE_ENDIF);

   try_replace_with_sel();
}

void
fs_visitor::nir_emit_loop(nir_loop *loop)
{
   bld.emit(BRW_OPCODE_DO);

   nir_emit_cf_list(&loop->body);

   bld.emit(BRW_OPCODE_WHILE);
}

void
fs_visitor::nir_emit_block(nir_block *block)
{
   nir_foreach_instr(block, instr) {
      nir_emit_instr(instr);
   }
}

void
fs_visitor::nir_emit_instr(nir_instr *instr)
{
   const fs_builder abld = bld.annotate(NULL, instr);

   switch (instr->type) {
   case nir_instr_type_alu:
      nir_emit_alu(abld, nir_instr_as_alu(instr));
      break;

   case nir_instr_type_intrinsic:
      nir_emit_intrinsic(abld, nir_instr_as_intrinsic(instr));
      break;

   case nir_instr_type_tex:
      nir_emit_texture(abld, nir_instr_as_tex(instr));
      break;

   case nir_instr_type_load_const:
      nir_emit_load_const(abld, nir_instr_as_load_const(instr));
      break;

   case nir_instr_type_ssa_undef:
      nir_emit_undef(abld, nir_instr_as_ssa_undef(instr));
      break;

   case nir_instr_type_jump:
      nir_emit_jump(abld, nir_instr_as_jump(instr));
      break;

   default:
      unreachable("unknown instruction type");
   }
}

bool
fs_visitor::optimize_frontfacing_ternary(nir_alu_instr *instr,
                                         const fs_reg &result)
{
   if (!instr->src[0].src.is_ssa ||
       instr->src[0].src.ssa->parent_instr->type != nir_instr_type_intrinsic)
      return false;

   nir_intrinsic_instr *src0 =
      nir_instr_as_intrinsic(instr->src[0].src.ssa->parent_instr);

   if (src0->intrinsic != nir_intrinsic_load_front_face)
      return false;

   nir_const_value *value1 = nir_src_as_const_value(instr->src[1].src);
   if (!value1 || fabsf(value1->f[0]) != 1.0f)
      return false;

   nir_const_value *value2 = nir_src_as_const_value(instr->src[2].src);
   if (!value2 || fabsf(value2->f[0]) != 1.0f)
      return false;

   fs_reg tmp = vgrf(glsl_type::int_type);

   if (devinfo->gen >= 6) {
      /* Bit 15 of g0.0 is 0 if the polygon is front facing. */
      fs_reg g0 = fs_reg(retype(brw_vec1_grf(0, 0), BRW_REGISTER_TYPE_W));

      /* For (gl_FrontFacing ? 1.0 : -1.0), emit:
       *
       *    or(8)  tmp.1<2>W  g0.0<0,1,0>W  0x00003f80W
       *    and(8) dst<1>D    tmp<8,8,1>D   0xbf800000D
       *
       * and negate g0.0<0,1,0>W for (gl_FrontFacing ? -1.0 : 1.0).
       *
       * This negation looks like it's safe in practice, because bits 0:4 will
       * surely be TRIANGLES
       */

      if (value1->f[0] == -1.0f) {
         g0.negate = true;
      }

      tmp.type = BRW_REGISTER_TYPE_W;
      tmp.subreg_offset = 2;
      tmp.stride = 2;

      fs_inst *or_inst = bld.OR(tmp, g0, fs_reg(0x3f80));
      or_inst->src[1].type = BRW_REGISTER_TYPE_UW;

      tmp.type = BRW_REGISTER_TYPE_D;
      tmp.subreg_offset = 0;
      tmp.stride = 1;
   } else {
      /* Bit 31 of g1.6 is 0 if the polygon is front facing. */
      fs_reg g1_6 = fs_reg(retype(brw_vec1_grf(1, 6), BRW_REGISTER_TYPE_D));

      /* For (gl_FrontFacing ? 1.0 : -1.0), emit:
       *
       *    or(8)  tmp<1>D  g1.6<0,1,0>D  0x3f800000D
       *    and(8) dst<1>D  tmp<8,8,1>D   0xbf800000D
       *
       * and negate g1.6<0,1,0>D for (gl_FrontFacing ? -1.0 : 1.0).
       *
       * This negation looks like it's safe in practice, because bits 0:4 will
       * surely be TRIANGLES
       */

      if (value1->f[0] == -1.0f) {
         g1_6.negate = true;
      }

      bld.OR(tmp, g1_6, fs_reg(0x3f800000));
   }
   bld.AND(retype(result, BRW_REGISTER_TYPE_D), tmp, fs_reg(0xbf800000));

   return true;
}

void
fs_visitor::nir_emit_alu(const fs_builder &bld, nir_alu_instr *instr)
{
   struct brw_wm_prog_key *fs_key = (struct brw_wm_prog_key *) this->key;
   fs_inst *inst;

   fs_reg result = get_nir_dest(instr->dest.dest);
   result.type = brw_type_for_nir_type(nir_op_infos[instr->op].output_type);

   fs_reg op[4];
   for (unsigned i = 0; i < nir_op_infos[instr->op].num_inputs; i++) {
      op[i] = get_nir_src(instr->src[i].src);
      op[i].type = brw_type_for_nir_type(nir_op_infos[instr->op].input_types[i]);
      op[i].abs = instr->src[i].abs;
      op[i].negate = instr->src[i].negate;
   }

   /* We get a bunch of mov's out of the from_ssa pass and they may still
    * be vectorized.  We'll handle them as a special-case.  We'll also
    * handle vecN here because it's basically the same thing.
    */
   switch (instr->op) {
   case nir_op_imov:
   case nir_op_fmov:
   case nir_op_vec2:
   case nir_op_vec3:
   case nir_op_vec4: {
      fs_reg temp = result;
      bool need_extra_copy = false;
      for (unsigned i = 0; i < nir_op_infos[instr->op].num_inputs; i++) {
         if (!instr->src[i].src.is_ssa &&
             instr->dest.dest.reg.reg == instr->src[i].src.reg.reg) {
            need_extra_copy = true;
            temp = bld.vgrf(result.type, 4);
            break;
         }
      }

      for (unsigned i = 0; i < 4; i++) {
         if (!(instr->dest.write_mask & (1 << i)))
            continue;

         if (instr->op == nir_op_imov || instr->op == nir_op_fmov) {
            inst = bld.MOV(offset(temp, bld, i),
                           offset(op[0], bld, instr->src[0].swizzle[i]));
         } else {
            inst = bld.MOV(offset(temp, bld, i),
                           offset(op[i], bld, instr->src[i].swizzle[0]));
         }
         inst->saturate = instr->dest.saturate;
      }

      /* In this case the source and destination registers were the same,
       * so we need to insert an extra set of moves in order to deal with
       * any swizzling.
       */
      if (need_extra_copy) {
         for (unsigned i = 0; i < 4; i++) {
            if (!(instr->dest.write_mask & (1 << i)))
               continue;

            bld.MOV(offset(result, bld, i), offset(temp, bld, i));
         }
      }
      return;
   }
   default:
      break;
   }

   /* At this point, we have dealt with any instruction that operates on
    * more than a single channel.  Therefore, we can just adjust the source
    * and destination registers for that channel and emit the instruction.
    */
   unsigned channel = 0;
   if (nir_op_infos[instr->op].output_size == 0) {
      /* Since NIR is doing the scalarizing for us, we should only ever see
       * vectorized operations with a single channel.
       */
      assert(_mesa_bitcount(instr->dest.write_mask) == 1);
      channel = ffs(instr->dest.write_mask) - 1;

      result = offset(result, bld, channel);
   }

   for (unsigned i = 0; i < nir_op_infos[instr->op].num_inputs; i++) {
      assert(nir_op_infos[instr->op].input_sizes[i] < 2);
      op[i] = offset(op[i], bld, instr->src[i].swizzle[channel]);
   }

   switch (instr->op) {
   case nir_op_i2f:
   case nir_op_u2f:
      inst = bld.MOV(result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_f2i:
   case nir_op_f2u:
      bld.MOV(result, op[0]);
      break;

   case nir_op_fsign: {
      /* AND(val, 0x80000000) gives the sign bit.
         *
         * Predicated OR ORs 1.0 (0x3f800000) with the sign bit if val is not
         * zero.
         */
      bld.CMP(bld.null_reg_f(), op[0], fs_reg(0.0f), BRW_CONDITIONAL_NZ);

      fs_reg result_int = retype(result, BRW_REGISTER_TYPE_UD);
      op[0].type = BRW_REGISTER_TYPE_UD;
      result.type = BRW_REGISTER_TYPE_UD;
      bld.AND(result_int, op[0], fs_reg(0x80000000u));

      inst = bld.OR(result_int, result_int, fs_reg(0x3f800000u));
      inst->predicate = BRW_PREDICATE_NORMAL;
      if (instr->dest.saturate) {
         inst = bld.MOV(result, result);
         inst->saturate = true;
      }
      break;
   }

   case nir_op_isign:
      /*  ASR(val, 31) -> negative val generates 0xffffffff (signed -1).
       *               -> non-negative val generates 0x00000000.
       *  Predicated OR sets 1 if val is positive.
       */
      bld.CMP(bld.null_reg_d(), op[0], fs_reg(0), BRW_CONDITIONAL_G);
      bld.ASR(result, op[0], fs_reg(31));
      inst = bld.OR(result, result, fs_reg(1));
      inst->predicate = BRW_PREDICATE_NORMAL;
      break;

   case nir_op_frcp:
      inst = bld.emit(SHADER_OPCODE_RCP, result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_fexp2:
      inst = bld.emit(SHADER_OPCODE_EXP2, result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_flog2:
      inst = bld.emit(SHADER_OPCODE_LOG2, result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_fsin:
      inst = bld.emit(SHADER_OPCODE_SIN, result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_fcos:
      inst = bld.emit(SHADER_OPCODE_COS, result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_fddx:
      if (fs_key->high_quality_derivatives) {
         inst = bld.emit(FS_OPCODE_DDX_FINE, result, op[0]);
      } else {
         inst = bld.emit(FS_OPCODE_DDX_COARSE, result, op[0]);
      }
      inst->saturate = instr->dest.saturate;
      break;
   case nir_op_fddx_fine:
      inst = bld.emit(FS_OPCODE_DDX_FINE, result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;
   case nir_op_fddx_coarse:
      inst = bld.emit(FS_OPCODE_DDX_COARSE, result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;
   case nir_op_fddy:
      if (fs_key->high_quality_derivatives) {
         inst = bld.emit(FS_OPCODE_DDY_FINE, result, op[0],
                         fs_reg(fs_key->render_to_fbo));
      } else {
         inst = bld.emit(FS_OPCODE_DDY_COARSE, result, op[0],
                         fs_reg(fs_key->render_to_fbo));
      }
      inst->saturate = instr->dest.saturate;
      break;
   case nir_op_fddy_fine:
      inst = bld.emit(FS_OPCODE_DDY_FINE, result, op[0],
                      fs_reg(fs_key->render_to_fbo));
      inst->saturate = instr->dest.saturate;
      break;
   case nir_op_fddy_coarse:
      inst = bld.emit(FS_OPCODE_DDY_COARSE, result, op[0],
                      fs_reg(fs_key->render_to_fbo));
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_fadd:
   case nir_op_iadd:
      inst = bld.ADD(result, op[0], op[1]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_fmul:
      inst = bld.MUL(result, op[0], op[1]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_imul:
      bld.MUL(result, op[0], op[1]);
      break;

   case nir_op_imul_high:
   case nir_op_umul_high:
      bld.emit(SHADER_OPCODE_MULH, result, op[0], op[1]);
      break;

   case nir_op_idiv:
   case nir_op_udiv:
      bld.emit(SHADER_OPCODE_INT_QUOTIENT, result, op[0], op[1]);
      break;

   case nir_op_uadd_carry:
      unreachable("Should have been lowered by carry_to_arith().");

   case nir_op_usub_borrow:
      unreachable("Should have been lowered by borrow_to_arith().");

   case nir_op_umod:
      bld.emit(SHADER_OPCODE_INT_REMAINDER, result, op[0], op[1]);
      break;

   case nir_op_flt:
   case nir_op_ilt:
   case nir_op_ult:
      bld.CMP(result, op[0], op[1], BRW_CONDITIONAL_L);
      break;

   case nir_op_fge:
   case nir_op_ige:
   case nir_op_uge:
      bld.CMP(result, op[0], op[1], BRW_CONDITIONAL_GE);
      break;

   case nir_op_feq:
   case nir_op_ieq:
      bld.CMP(result, op[0], op[1], BRW_CONDITIONAL_Z);
      break;

   case nir_op_fne:
   case nir_op_ine:
      bld.CMP(result, op[0], op[1], BRW_CONDITIONAL_NZ);
      break;

   case nir_op_inot:
      if (devinfo->gen >= 8) {
         op[0] = resolve_source_modifiers(op[0]);
      }
      bld.NOT(result, op[0]);
      break;
   case nir_op_ixor:
      if (devinfo->gen >= 8) {
         op[0] = resolve_source_modifiers(op[0]);
         op[1] = resolve_source_modifiers(op[1]);
      }
      bld.XOR(result, op[0], op[1]);
      break;
   case nir_op_ior:
      if (devinfo->gen >= 8) {
         op[0] = resolve_source_modifiers(op[0]);
         op[1] = resolve_source_modifiers(op[1]);
      }
      bld.OR(result, op[0], op[1]);
      break;
   case nir_op_iand:
      if (devinfo->gen >= 8) {
         op[0] = resolve_source_modifiers(op[0]);
         op[1] = resolve_source_modifiers(op[1]);
      }
      bld.AND(result, op[0], op[1]);
      break;

   case nir_op_fdot2:
   case nir_op_fdot3:
   case nir_op_fdot4:
   case nir_op_bany2:
   case nir_op_bany3:
   case nir_op_bany4:
   case nir_op_ball2:
   case nir_op_ball3:
   case nir_op_ball4:
   case nir_op_ball_fequal2:
   case nir_op_ball_iequal2:
   case nir_op_ball_fequal3:
   case nir_op_ball_iequal3:
   case nir_op_ball_fequal4:
   case nir_op_ball_iequal4:
   case nir_op_bany_fnequal2:
   case nir_op_bany_inequal2:
   case nir_op_bany_fnequal3:
   case nir_op_bany_inequal3:
   case nir_op_bany_fnequal4:
   case nir_op_bany_inequal4:
      unreachable("Lowered by nir_lower_alu_reductions");

   case nir_op_fnoise1_1:
   case nir_op_fnoise1_2:
   case nir_op_fnoise1_3:
   case nir_op_fnoise1_4:
   case nir_op_fnoise2_1:
   case nir_op_fnoise2_2:
   case nir_op_fnoise2_3:
   case nir_op_fnoise2_4:
   case nir_op_fnoise3_1:
   case nir_op_fnoise3_2:
   case nir_op_fnoise3_3:
   case nir_op_fnoise3_4:
   case nir_op_fnoise4_1:
   case nir_op_fnoise4_2:
   case nir_op_fnoise4_3:
   case nir_op_fnoise4_4:
      unreachable("not reached: should be handled by lower_noise");

   case nir_op_ldexp:
      unreachable("not reached: should be handled by ldexp_to_arith()");

   case nir_op_fsqrt:
      inst = bld.emit(SHADER_OPCODE_SQRT, result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_frsq:
      inst = bld.emit(SHADER_OPCODE_RSQ, result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_b2i:
   case nir_op_b2f:
      bld.MOV(result, negate(op[0]));
      break;

   case nir_op_f2b:
      bld.CMP(result, op[0], fs_reg(0.0f), BRW_CONDITIONAL_NZ);
      break;
   case nir_op_i2b:
      bld.CMP(result, op[0], fs_reg(0), BRW_CONDITIONAL_NZ);
      break;

   case nir_op_ftrunc:
      inst = bld.RNDZ(result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_fceil: {
      op[0].negate = !op[0].negate;
      fs_reg temp = vgrf(glsl_type::float_type);
      bld.RNDD(temp, op[0]);
      temp.negate = true;
      inst = bld.MOV(result, temp);
      inst->saturate = instr->dest.saturate;
      break;
   }
   case nir_op_ffloor:
      inst = bld.RNDD(result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;
   case nir_op_ffract:
      inst = bld.FRC(result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;
   case nir_op_fround_even:
      inst = bld.RNDE(result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_fmin:
   case nir_op_imin:
   case nir_op_umin:
      if (devinfo->gen >= 6) {
         inst = bld.emit(BRW_OPCODE_SEL, result, op[0], op[1]);
         inst->conditional_mod = BRW_CONDITIONAL_L;
      } else {
         bld.CMP(bld.null_reg_d(), op[0], op[1], BRW_CONDITIONAL_L);
         inst = bld.SEL(result, op[0], op[1]);
         inst->predicate = BRW_PREDICATE_NORMAL;
      }
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_fmax:
   case nir_op_imax:
   case nir_op_umax:
      if (devinfo->gen >= 6) {
         inst = bld.emit(BRW_OPCODE_SEL, result, op[0], op[1]);
         inst->conditional_mod = BRW_CONDITIONAL_GE;
      } else {
         bld.CMP(bld.null_reg_d(), op[0], op[1], BRW_CONDITIONAL_GE);
         inst = bld.SEL(result, op[0], op[1]);
         inst->predicate = BRW_PREDICATE_NORMAL;
      }
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_pack_snorm_2x16:
   case nir_op_pack_snorm_4x8:
   case nir_op_pack_unorm_2x16:
   case nir_op_pack_unorm_4x8:
   case nir_op_unpack_snorm_2x16:
   case nir_op_unpack_snorm_4x8:
   case nir_op_unpack_unorm_2x16:
   case nir_op_unpack_unorm_4x8:
   case nir_op_unpack_half_2x16:
   case nir_op_pack_half_2x16:
      unreachable("not reached: should be handled by lower_packing_builtins");

   case nir_op_unpack_half_2x16_split_x:
      inst = bld.emit(FS_OPCODE_UNPACK_HALF_2x16_SPLIT_X, result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;
   case nir_op_unpack_half_2x16_split_y:
      inst = bld.emit(FS_OPCODE_UNPACK_HALF_2x16_SPLIT_Y, result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_fpow:
      inst = bld.emit(SHADER_OPCODE_POW, result, op[0], op[1]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_bitfield_reverse:
      bld.BFREV(result, op[0]);
      break;

   case nir_op_bit_count:
      bld.CBIT(result, op[0]);
      break;

   case nir_op_ufind_msb:
   case nir_op_ifind_msb: {
      bld.FBH(retype(result, BRW_REGISTER_TYPE_UD), op[0]);

      /* FBH counts from the MSB side, while GLSL's findMSB() wants the count
       * from the LSB side. If FBH didn't return an error (0xFFFFFFFF), then
       * subtract the result from 31 to convert the MSB count into an LSB count.
       */

      bld.CMP(bld.null_reg_d(), result, fs_reg(-1), BRW_CONDITIONAL_NZ);
      fs_reg neg_result(result);
      neg_result.negate = true;
      inst = bld.ADD(result, neg_result, fs_reg(31));
      inst->predicate = BRW_PREDICATE_NORMAL;
      break;
   }

   case nir_op_find_lsb:
      bld.FBL(result, op[0]);
      break;

   case nir_op_ubitfield_extract:
   case nir_op_ibitfield_extract:
      bld.BFE(result, op[2], op[1], op[0]);
      break;
   case nir_op_bfm:
      bld.BFI1(result, op[0], op[1]);
      break;
   case nir_op_bfi:
      bld.BFI2(result, op[0], op[1], op[2]);
      break;

   case nir_op_bitfield_insert:
      unreachable("not reached: should be handled by "
                  "lower_instructions::bitfield_insert_to_bfm_bfi");

   case nir_op_ishl:
      bld.SHL(result, op[0], op[1]);
      break;
   case nir_op_ishr:
      bld.ASR(result, op[0], op[1]);
      break;
   case nir_op_ushr:
      bld.SHR(result, op[0], op[1]);
      break;

   case nir_op_pack_half_2x16_split:
      bld.emit(FS_OPCODE_PACK_HALF_2x16_SPLIT, result, op[0], op[1]);
      break;

   case nir_op_ffma:
      inst = bld.MAD(result, op[2], op[1], op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_flrp:
      inst = bld.LRP(result, op[0], op[1], op[2]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_bcsel:
      if (optimize_frontfacing_ternary(instr, result))
         return;

      bld.CMP(bld.null_reg_d(), op[0], fs_reg(0), BRW_CONDITIONAL_NZ);
      inst = bld.SEL(result, op[1], op[2]);
      inst->predicate = BRW_PREDICATE_NORMAL;
      break;

   default:
      unreachable("unhandled instruction");
   }

   /* If we need to do a boolean resolve, replace the result with -(x & 1)
    * to sign extend the low bit to 0/~0
    */
   if (devinfo->gen <= 5 &&
       (instr->instr.pass_flags & BRW_NIR_BOOLEAN_MASK) == BRW_NIR_BOOLEAN_NEEDS_RESOLVE) {
      fs_reg masked = vgrf(glsl_type::int_type);
      bld.AND(masked, result, fs_reg(1));
      masked.negate = true;
      bld.MOV(retype(result, BRW_REGISTER_TYPE_D), masked);
   }
}

void
fs_visitor::nir_emit_load_const(const fs_builder &bld,
                                nir_load_const_instr *instr)
{
   fs_reg reg = bld.vgrf(BRW_REGISTER_TYPE_D, instr->def.num_components);

   for (unsigned i = 0; i < instr->def.num_components; i++)
      bld.MOV(offset(reg, bld, i), fs_reg(instr->value.i[i]));

   nir_ssa_values[instr->def.index] = reg;
}

void
fs_visitor::nir_emit_undef(const fs_builder &bld, nir_ssa_undef_instr *instr)
{
   nir_ssa_values[instr->def.index] = bld.vgrf(BRW_REGISTER_TYPE_D,
                                               instr->def.num_components);
}

static fs_reg
fs_reg_for_nir_reg(fs_visitor *v, nir_register *nir_reg,
                   unsigned base_offset, nir_src *indirect)
{
   fs_reg reg;

   assert(!nir_reg->is_global);

   reg = v->nir_locals[nir_reg->index];

   reg = offset(reg, v->bld, base_offset * nir_reg->num_components);
   if (indirect) {
      int multiplier = nir_reg->num_components * (v->dispatch_width / 8);

      reg.reladdr = new(v->mem_ctx) fs_reg(v->vgrf(glsl_type::int_type));
      v->bld.MUL(*reg.reladdr, v->get_nir_src(*indirect),
                 fs_reg(multiplier));
   }

   return reg;
}

fs_reg
fs_visitor::get_nir_src(nir_src src)
{
   fs_reg reg;
   if (src.is_ssa) {
      reg = nir_ssa_values[src.ssa->index];
   } else {
      reg = fs_reg_for_nir_reg(this, src.reg.reg, src.reg.base_offset,
                               src.reg.indirect);
   }

   /* to avoid floating-point denorm flushing problems, set the type by
    * default to D - instructions that need floating point semantics will set
    * this to F if they need to
    */
   return retype(reg, BRW_REGISTER_TYPE_D);
}

fs_reg
fs_visitor::get_nir_dest(nir_dest dest)
{
   if (dest.is_ssa) {
      nir_ssa_values[dest.ssa.index] = bld.vgrf(BRW_REGISTER_TYPE_F,
                                                dest.ssa.num_components);
      return nir_ssa_values[dest.ssa.index];
   }

   return fs_reg_for_nir_reg(this, dest.reg.reg, dest.reg.base_offset,
                             dest.reg.indirect);
}

fs_reg
fs_visitor::get_nir_image_deref(const nir_deref_var *deref)
{
   fs_reg image(UNIFORM, deref->var->data.driver_location,
                BRW_REGISTER_TYPE_UD);

   if (deref->deref.child) {
      const nir_deref_array *deref_array =
         nir_deref_as_array(deref->deref.child);
      assert(deref->deref.child->deref_type == nir_deref_type_array &&
             deref_array->deref.child == NULL);
      const unsigned size = glsl_get_length(deref->var->type);
      const unsigned base = MIN2(deref_array->base_offset, size - 1);

      image = offset(image, bld, base * BRW_IMAGE_PARAM_SIZE);

      if (deref_array->deref_array_type == nir_deref_array_type_indirect) {
         fs_reg *tmp = new(mem_ctx) fs_reg(vgrf(glsl_type::int_type));

         if (devinfo->gen == 7 && !devinfo->is_haswell) {
            /* IVB hangs when trying to access an invalid surface index with
             * the dataport.  According to the spec "if the index used to
             * select an individual element is negative or greater than or
             * equal to the size of the array, the results of the operation
             * are undefined but may not lead to termination" -- which is one
             * of the possible outcomes of the hang.  Clamp the index to
             * prevent access outside of the array bounds.
             */
            bld.emit_minmax(*tmp, retype(get_nir_src(deref_array->indirect),
                                         BRW_REGISTER_TYPE_UD),
                            fs_reg(size - base - 1), BRW_CONDITIONAL_L);
         } else {
            bld.MOV(*tmp, get_nir_src(deref_array->indirect));
         }

         bld.MUL(*tmp, *tmp, fs_reg(BRW_IMAGE_PARAM_SIZE));
         image.reladdr = tmp;
      }
   }

   return image;
}

void
fs_visitor::emit_percomp(const fs_builder &bld, const fs_inst &inst,
                         unsigned wr_mask)
{
   for (unsigned i = 0; i < 4; i++) {
      if (!((wr_mask >> i) & 1))
         continue;

      fs_inst *new_inst = new(mem_ctx) fs_inst(inst);
      new_inst->dst = offset(new_inst->dst, bld, i);
      for (unsigned j = 0; j < new_inst->sources; j++)
         if (new_inst->src[j].file == GRF)
            new_inst->src[j] = offset(new_inst->src[j], bld, i);

      bld.emit(new_inst);
   }
}

/**
 * Get the matching channel register datatype for an image intrinsic of the
 * specified GLSL image type.
 */
static brw_reg_type
get_image_base_type(const glsl_type *type)
{
   switch ((glsl_base_type)type->sampler_type) {
   case GLSL_TYPE_UINT:
      return BRW_REGISTER_TYPE_UD;
   case GLSL_TYPE_INT:
      return BRW_REGISTER_TYPE_D;
   case GLSL_TYPE_FLOAT:
      return BRW_REGISTER_TYPE_F;
   default:
      unreachable("Not reached.");
   }
}

/**
 * Get the appropriate atomic op for an image atomic intrinsic.
 */
static unsigned
get_image_atomic_op(nir_intrinsic_op op, const glsl_type *type)
{
   switch (op) {
   case nir_intrinsic_image_atomic_add:
      return BRW_AOP_ADD;
   case nir_intrinsic_image_atomic_min:
      return (get_image_base_type(type) == BRW_REGISTER_TYPE_D ?
              BRW_AOP_IMIN : BRW_AOP_UMIN);
   case nir_intrinsic_image_atomic_max:
      return (get_image_base_type(type) == BRW_REGISTER_TYPE_D ?
              BRW_AOP_IMAX : BRW_AOP_UMAX);
   case nir_intrinsic_image_atomic_and:
      return BRW_AOP_AND;
   case nir_intrinsic_image_atomic_or:
      return BRW_AOP_OR;
   case nir_intrinsic_image_atomic_xor:
      return BRW_AOP_XOR;
   case nir_intrinsic_image_atomic_exchange:
      return BRW_AOP_MOV;
   case nir_intrinsic_image_atomic_comp_swap:
      return BRW_AOP_CMPWR;
   default:
      unreachable("Not reachable.");
   }
}

void
fs_visitor::nir_emit_intrinsic(const fs_builder &bld, nir_intrinsic_instr *instr)
{
   fs_reg dest;
   if (nir_intrinsic_infos[instr->intrinsic].has_dest)
      dest = get_nir_dest(instr->dest);

   bool has_indirect = false;

   switch (instr->intrinsic) {
   case nir_intrinsic_discard:
   case nir_intrinsic_discard_if: {
      /* We track our discarded pixels in f0.1.  By predicating on it, we can
       * update just the flag bits that aren't yet discarded.  If there's no
       * condition, we emit a CMP of g0 != g0, so all currently executing
       * channels will get turned off.
       */
      fs_inst *cmp;
      if (instr->intrinsic == nir_intrinsic_discard_if) {
         cmp = bld.CMP(bld.null_reg_f(), get_nir_src(instr->src[0]),
                       fs_reg(0), BRW_CONDITIONAL_Z);
      } else {
         fs_reg some_reg = fs_reg(retype(brw_vec8_grf(0, 0),
                                       BRW_REGISTER_TYPE_UW));
         cmp = bld.CMP(bld.null_reg_f(), some_reg, some_reg, BRW_CONDITIONAL_NZ);
      }
      cmp->predicate = BRW_PREDICATE_NORMAL;
      cmp->flag_subreg = 1;

      if (devinfo->gen >= 6) {
         emit_discard_jump();
      }
      break;
   }

   case nir_intrinsic_atomic_counter_inc:
   case nir_intrinsic_atomic_counter_dec:
   case nir_intrinsic_atomic_counter_read: {
      using namespace surface_access;

      /* Get the arguments of the atomic intrinsic. */
      const fs_reg offset = get_nir_src(instr->src[0]);
      const unsigned surface = (stage_prog_data->binding_table.abo_start +
                                instr->const_index[0]);
      fs_reg tmp;

      /* Emit a surface read or atomic op. */
      switch (instr->intrinsic) {
      case nir_intrinsic_atomic_counter_read:
         tmp = emit_untyped_read(bld, fs_reg(surface), offset, 1, 1);
         break;

      case nir_intrinsic_atomic_counter_inc:
         tmp = emit_untyped_atomic(bld, fs_reg(surface), offset, fs_reg(),
                                   fs_reg(), 1, 1, BRW_AOP_INC);
         break;

      case nir_intrinsic_atomic_counter_dec:
         tmp = emit_untyped_atomic(bld, fs_reg(surface), offset, fs_reg(),
                                   fs_reg(), 1, 1, BRW_AOP_PREDEC);
         break;

      default:
         unreachable("Unreachable");
      }

      /* Assign the result. */
      bld.MOV(retype(dest, BRW_REGISTER_TYPE_UD), tmp);

      /* Mark the surface as used. */
      brw_mark_surface_used(stage_prog_data, surface);
      break;
   }

   case nir_intrinsic_image_load:
   case nir_intrinsic_image_store:
   case nir_intrinsic_image_atomic_add:
   case nir_intrinsic_image_atomic_min:
   case nir_intrinsic_image_atomic_max:
   case nir_intrinsic_image_atomic_and:
   case nir_intrinsic_image_atomic_or:
   case nir_intrinsic_image_atomic_xor:
   case nir_intrinsic_image_atomic_exchange:
   case nir_intrinsic_image_atomic_comp_swap: {
      using namespace image_access;

      /* Get the referenced image variable and type. */
      const nir_variable *var = instr->variables[0]->var;
      const glsl_type *type = var->type->without_array();
      const brw_reg_type base_type = get_image_base_type(type);

      /* Get some metadata from the image intrinsic. */
      const nir_intrinsic_info *info = &nir_intrinsic_infos[instr->intrinsic];
      const unsigned arr_dims = type->sampler_array ? 1 : 0;
      const unsigned surf_dims = type->coordinate_components() - arr_dims;
      const mesa_format format =
         (var->data.image.write_only ? MESA_FORMAT_NONE :
          _mesa_get_shader_image_format(var->data.image.format));

      /* Get the arguments of the image intrinsic. */
      const fs_reg image = get_nir_image_deref(instr->variables[0]);
      const fs_reg addr = retype(get_nir_src(instr->src[0]),
                                 BRW_REGISTER_TYPE_UD);
      const fs_reg src0 = (info->num_srcs >= 3 ?
                           retype(get_nir_src(instr->src[2]), base_type) :
                           fs_reg());
      const fs_reg src1 = (info->num_srcs >= 4 ?
                           retype(get_nir_src(instr->src[3]), base_type) :
                           fs_reg());
      fs_reg tmp;

      /* Emit an image load, store or atomic op. */
      if (instr->intrinsic == nir_intrinsic_image_load)
         tmp = emit_image_load(bld, image, addr, surf_dims, arr_dims, format);

      else if (instr->intrinsic == nir_intrinsic_image_store)
         emit_image_store(bld, image, addr, src0, surf_dims, arr_dims, format);

      else
         tmp = emit_image_atomic(bld, image, addr, src0, src1,
                                 surf_dims, arr_dims, info->dest_components,
                                 get_image_atomic_op(instr->intrinsic, type));

      /* Assign the result. */
      for (unsigned c = 0; c < info->dest_components; ++c)
         bld.MOV(offset(retype(dest, base_type), bld, c),
                 offset(tmp, bld, c));
      break;
   }

   case nir_intrinsic_memory_barrier: {
      const fs_reg tmp = bld.vgrf(BRW_REGISTER_TYPE_UD, 16 / dispatch_width);
      bld.emit(SHADER_OPCODE_MEMORY_FENCE, tmp)
         ->regs_written = 2;
      break;
   }

   case nir_intrinsic_image_size: {
      /* Get the referenced image variable and type. */
      const nir_variable *var = instr->variables[0]->var;
      const glsl_type *type = var->type->without_array();

      /* Get the size of the image. */
      const fs_reg image = get_nir_image_deref(instr->variables[0]);
      const fs_reg size = offset(image, bld, BRW_IMAGE_PARAM_SIZE_OFFSET);

      /* For 1DArray image types, the array index is stored in the Z component.
       * Fix this by swizzling the Z component to the Y component.
       */
      const bool is_1d_array_image =
                  type->sampler_dimensionality == GLSL_SAMPLER_DIM_1D &&
                  type->sampler_array;

      /* For CubeArray images, we should count the number of cubes instead
       * of the number of faces. Fix it by dividing the (Z component) by 6.
       */
      const bool is_cube_array_image =
                  type->sampler_dimensionality == GLSL_SAMPLER_DIM_CUBE &&
                  type->sampler_array;

      /* Copy all the components. */
      const nir_intrinsic_info *info = &nir_intrinsic_infos[instr->intrinsic];
      for (unsigned c = 0; c < info->dest_components; ++c) {
         if ((int)c >= type->coordinate_components()) {
             bld.MOV(offset(retype(dest, BRW_REGISTER_TYPE_D), bld, c),
                     fs_reg(1));
         } else if (c == 1 && is_1d_array_image) {
            bld.MOV(offset(retype(dest, BRW_REGISTER_TYPE_D), bld, c),
                    offset(size, bld, 2));
         } else if (c == 2 && is_cube_array_image) {
            bld.emit(SHADER_OPCODE_INT_QUOTIENT,
                     offset(retype(dest, BRW_REGISTER_TYPE_D), bld, c),
                     offset(size, bld, c), fs_reg(6));
         } else {
            bld.MOV(offset(retype(dest, BRW_REGISTER_TYPE_D), bld, c),
                    offset(size, bld, c));
         }
       }

      break;
   }

   case nir_intrinsic_load_front_face:
      bld.MOV(retype(dest, BRW_REGISTER_TYPE_D),
              *emit_frontfacing_interpolation());
      break;

   case nir_intrinsic_load_vertex_id:
      unreachable("should be lowered by lower_vertex_id()");

   case nir_intrinsic_load_vertex_id_zero_base: {
      fs_reg vertex_id = nir_system_values[SYSTEM_VALUE_VERTEX_ID_ZERO_BASE];
      assert(vertex_id.file != BAD_FILE);
      dest.type = vertex_id.type;
      bld.MOV(dest, vertex_id);
      break;
   }

   case nir_intrinsic_load_base_vertex: {
      fs_reg base_vertex = nir_system_values[SYSTEM_VALUE_BASE_VERTEX];
      assert(base_vertex.file != BAD_FILE);
      dest.type = base_vertex.type;
      bld.MOV(dest, base_vertex);
      break;
   }

   case nir_intrinsic_load_instance_id: {
      fs_reg instance_id = nir_system_values[SYSTEM_VALUE_INSTANCE_ID];
      assert(instance_id.file != BAD_FILE);
      dest.type = instance_id.type;
      bld.MOV(dest, instance_id);
      break;
   }

   case nir_intrinsic_load_sample_mask_in: {
      fs_reg sample_mask_in = nir_system_values[SYSTEM_VALUE_SAMPLE_MASK_IN];
      assert(sample_mask_in.file != BAD_FILE);
      dest.type = sample_mask_in.type;
      bld.MOV(dest, sample_mask_in);
      break;
   }

   case nir_intrinsic_load_sample_pos: {
      fs_reg sample_pos = nir_system_values[SYSTEM_VALUE_SAMPLE_POS];
      assert(sample_pos.file != BAD_FILE);
      dest.type = sample_pos.type;
      bld.MOV(dest, sample_pos);
      bld.MOV(offset(dest, bld, 1), offset(sample_pos, bld, 1));
      break;
   }

   case nir_intrinsic_load_sample_id: {
      fs_reg sample_id = nir_system_values[SYSTEM_VALUE_SAMPLE_ID];
      assert(sample_id.file != BAD_FILE);
      dest.type = sample_id.type;
      bld.MOV(dest, sample_id);
      break;
   }

   case nir_intrinsic_load_uniform_indirect:
      has_indirect = true;
      /* fallthrough */
   case nir_intrinsic_load_uniform: {
      unsigned index = instr->const_index[0];

      fs_reg uniform_reg;
      if (index < num_direct_uniforms) {
         uniform_reg = fs_reg(UNIFORM, 0);
      } else {
         uniform_reg = fs_reg(UNIFORM, num_direct_uniforms);
         index -= num_direct_uniforms;
      }

      for (unsigned j = 0; j < instr->num_components; j++) {
         fs_reg src = offset(retype(uniform_reg, dest.type), bld, index);
         if (has_indirect)
            src.reladdr = new(mem_ctx) fs_reg(get_nir_src(instr->src[0]));
         index++;

         bld.MOV(dest, src);
         dest = offset(dest, bld, 1);
      }
      break;
   }

   case nir_intrinsic_load_ubo_indirect:
      has_indirect = true;
      /* fallthrough */
   case nir_intrinsic_load_ubo: {
      nir_const_value *const_index = nir_src_as_const_value(instr->src[0]);
      fs_reg surf_index;

      if (const_index) {
         surf_index = fs_reg(stage_prog_data->binding_table.ubo_start +
                             const_index->u[0]);
      } else {
         /* The block index is not a constant. Evaluate the index expression
          * per-channel and add the base UBO index; we have to select a value
          * from any live channel.
          */
         surf_index = vgrf(glsl_type::uint_type);
         bld.ADD(surf_index, get_nir_src(instr->src[0]),
                 fs_reg(stage_prog_data->binding_table.ubo_start));
         surf_index = bld.emit_uniformize(surf_index);

         /* Assume this may touch any UBO. It would be nice to provide
          * a tighter bound, but the array information is already lowered away.
          */
         brw_mark_surface_used(prog_data,
                               stage_prog_data->binding_table.ubo_start +
                               shader_prog->NumUniformBlocks - 1);
      }

      if (has_indirect) {
         /* Turn the byte offset into a dword offset. */
         fs_reg base_offset = vgrf(glsl_type::int_type);
         bld.SHR(base_offset, retype(get_nir_src(instr->src[1]),
                                     BRW_REGISTER_TYPE_D),
                 fs_reg(2));

         unsigned vec4_offset = instr->const_index[0] / 4;
         for (int i = 0; i < instr->num_components; i++)
            VARYING_PULL_CONSTANT_LOAD(bld, offset(dest, bld, i), surf_index,
                                       base_offset, vec4_offset + i);
      } else {
         fs_reg packed_consts = vgrf(glsl_type::float_type);
         packed_consts.type = dest.type;

         fs_reg const_offset_reg((unsigned) instr->const_index[0] & ~15);
         bld.emit(FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD, packed_consts,
                  surf_index, const_offset_reg);

         for (unsigned i = 0; i < instr->num_components; i++) {
            packed_consts.set_smear(instr->const_index[0] % 16 / 4 + i);

            /* The std140 packing rules don't allow vectors to cross 16-byte
             * boundaries, and a reg is 32 bytes.
             */
            assert(packed_consts.subreg_offset < 32);

            bld.MOV(dest, packed_consts);
            dest = offset(dest, bld, 1);
         }
      }
      break;
   }

   case nir_intrinsic_load_input_indirect:
      has_indirect = true;
      /* fallthrough */
   case nir_intrinsic_load_input: {
      unsigned index = 0;
      for (unsigned j = 0; j < instr->num_components; j++) {
         fs_reg src = offset(retype(nir_inputs, dest.type), bld,
                             instr->const_index[0] + index);
         if (has_indirect)
            src.reladdr = new(mem_ctx) fs_reg(get_nir_src(instr->src[0]));
         index++;

         bld.MOV(dest, src);
         dest = offset(dest, bld, 1);
      }
      break;
   }

   /* Handle ARB_gpu_shader5 interpolation intrinsics
    *
    * It's worth a quick word of explanation as to why we handle the full
    * variable-based interpolation intrinsic rather than a lowered version
    * with like we do for other inputs.  We have to do that because the way
    * we set up inputs doesn't allow us to use the already setup inputs for
    * interpolation.  At the beginning of the shader, we go through all of
    * the input variables and do the initial interpolation and put it in
    * the nir_inputs array based on its location as determined in
    * nir_lower_io.  If the input isn't used, dead code cleans up and
    * everything works fine.  However, when we get to the ARB_gpu_shader5
    * interpolation intrinsics, we need to reinterpolate the input
    * differently.  If we used an intrinsic that just had an index it would
    * only give us the offset into the nir_inputs array.  However, this is
    * useless because that value is post-interpolation and we need
    * pre-interpolation.  In order to get the actual location of the bits
    * we get from the vertex fetching hardware, we need the variable.
    */
   case nir_intrinsic_interp_var_at_centroid:
   case nir_intrinsic_interp_var_at_sample:
   case nir_intrinsic_interp_var_at_offset: {
      assert(stage == MESA_SHADER_FRAGMENT);

      ((struct brw_wm_prog_data *) prog_data)->pulls_bary = true;

      fs_reg dst_xy = bld.vgrf(BRW_REGISTER_TYPE_F, 2);

      /* For most messages, we need one reg of ignored data; the hardware
       * requires mlen==1 even when there is no payload. in the per-slot
       * offset case, we'll replace this with the proper source data.
       */
      fs_reg src = vgrf(glsl_type::float_type);
      int mlen = 1;     /* one reg unless overriden */
      fs_inst *inst;

      switch (instr->intrinsic) {
      case nir_intrinsic_interp_var_at_centroid:
         inst = bld.emit(FS_OPCODE_INTERPOLATE_AT_CENTROID,
                         dst_xy, src, fs_reg(0u));
         break;

      case nir_intrinsic_interp_var_at_sample: {
         /* XXX: We should probably handle non-constant sample id's */
         nir_const_value *const_sample = nir_src_as_const_value(instr->src[0]);
         assert(const_sample);
         unsigned msg_data = const_sample ? const_sample->i[0] << 4 : 0;
         inst = bld.emit(FS_OPCODE_INTERPOLATE_AT_SAMPLE, dst_xy, src,
                         fs_reg(msg_data));
         break;
      }

      case nir_intrinsic_interp_var_at_offset: {
         nir_const_value *const_offset = nir_src_as_const_value(instr->src[0]);

         if (const_offset) {
            unsigned off_x = MIN2((int)(const_offset->f[0] * 16), 7) & 0xf;
            unsigned off_y = MIN2((int)(const_offset->f[1] * 16), 7) & 0xf;

            inst = bld.emit(FS_OPCODE_INTERPOLATE_AT_SHARED_OFFSET, dst_xy, src,
                            fs_reg(off_x | (off_y << 4)));
         } else {
            src = vgrf(glsl_type::ivec2_type);
            fs_reg offset_src = retype(get_nir_src(instr->src[0]),
                                       BRW_REGISTER_TYPE_F);
            for (int i = 0; i < 2; i++) {
               fs_reg temp = vgrf(glsl_type::float_type);
               bld.MUL(temp, offset(offset_src, bld, i), fs_reg(16.0f));
               fs_reg itemp = vgrf(glsl_type::int_type);
               bld.MOV(itemp, temp);  /* float to int */

               /* Clamp the upper end of the range to +7/16.
                * ARB_gpu_shader5 requires that we support a maximum offset
                * of +0.5, which isn't representable in a S0.4 value -- if
                * we didn't clamp it, we'd end up with -8/16, which is the
                * opposite of what the shader author wanted.
                *
                * This is legal due to ARB_gpu_shader5's quantization
                * rules:
                *
                * "Not all values of <offset> may be supported; x and y
                * offsets may be rounded to fixed-point values with the
                * number of fraction bits given by the
                * implementation-dependent constant
                * FRAGMENT_INTERPOLATION_OFFSET_BITS"
                */
               set_condmod(BRW_CONDITIONAL_L,
                           bld.SEL(offset(src, bld, i), itemp, fs_reg(7)));
            }

            mlen = 2 * dispatch_width / 8;
            inst = bld.emit(FS_OPCODE_INTERPOLATE_AT_PER_SLOT_OFFSET, dst_xy, src,
                            fs_reg(0u));
         }
         break;
      }

      default:
         unreachable("Invalid intrinsic");
      }

      inst->mlen = mlen;
      /* 2 floats per slot returned */
      inst->regs_written = 2 * dispatch_width / 8;
      inst->pi_noperspective = instr->variables[0]->var->data.interpolation ==
                               INTERP_QUALIFIER_NOPERSPECTIVE;

      for (unsigned j = 0; j < instr->num_components; j++) {
         fs_reg src = interp_reg(instr->variables[0]->var->data.location, j);
         src.type = dest.type;

         bld.emit(FS_OPCODE_LINTERP, dest, dst_xy, src);
         dest = offset(dest, bld, 1);
      }
      break;
   }

   case nir_intrinsic_store_output_indirect:
      has_indirect = true;
      /* fallthrough */
   case nir_intrinsic_store_output: {
      fs_reg src = get_nir_src(instr->src[0]);
      unsigned index = 0;
      for (unsigned j = 0; j < instr->num_components; j++) {
         fs_reg new_dest = offset(retype(nir_outputs, src.type), bld,
                                  instr->const_index[0] + index);
         if (has_indirect)
            src.reladdr = new(mem_ctx) fs_reg(get_nir_src(instr->src[1]));
         index++;
         bld.MOV(new_dest, src);
         src = offset(src, bld, 1);
      }
      break;
   }

   case nir_intrinsic_barrier:
      emit_barrier();
      break;

   default:
      unreachable("unknown intrinsic");
   }
}

void
fs_visitor::nir_emit_texture(const fs_builder &bld, nir_tex_instr *instr)
{
   unsigned sampler = instr->sampler_index;
   fs_reg sampler_reg(sampler);

   /* FINISHME: We're failing to recompile our programs when the sampler is
    * updated.  This only matters for the texture rectangle scale parameters
    * (pre-gen6, or gen6+ with GL_CLAMP).
    */
   int texunit = prog->SamplerUnits[sampler];

   int gather_component = instr->component;

   bool is_rect = instr->sampler_dim == GLSL_SAMPLER_DIM_RECT;

   bool is_cube_array = instr->sampler_dim == GLSL_SAMPLER_DIM_CUBE &&
                        instr->is_array;

   int lod_components = 0;
   int UNUSED offset_components = 0;

   fs_reg coordinate, shadow_comparitor, lod, lod2, sample_index, mcs, tex_offset;

   for (unsigned i = 0; i < instr->num_srcs; i++) {
      fs_reg src = get_nir_src(instr->src[i].src);
      switch (instr->src[i].src_type) {
      case nir_tex_src_bias:
         lod = retype(src, BRW_REGISTER_TYPE_F);
         break;
      case nir_tex_src_comparitor:
         shadow_comparitor = retype(src, BRW_REGISTER_TYPE_F);
         break;
      case nir_tex_src_coord:
         switch (instr->op) {
         case nir_texop_txf:
         case nir_texop_txf_ms:
            coordinate = retype(src, BRW_REGISTER_TYPE_D);
            break;
         default:
            coordinate = retype(src, BRW_REGISTER_TYPE_F);
            break;
         }
         break;
      case nir_tex_src_ddx:
         lod = retype(src, BRW_REGISTER_TYPE_F);
         lod_components = nir_tex_instr_src_size(instr, i);
         break;
      case nir_tex_src_ddy:
         lod2 = retype(src, BRW_REGISTER_TYPE_F);
         break;
      case nir_tex_src_lod:
         switch (instr->op) {
         case nir_texop_txs:
            lod = retype(src, BRW_REGISTER_TYPE_UD);
            break;
         case nir_texop_txf:
            lod = retype(src, BRW_REGISTER_TYPE_D);
            break;
         default:
            lod = retype(src, BRW_REGISTER_TYPE_F);
            break;
         }
         break;
      case nir_tex_src_ms_index:
         sample_index = retype(src, BRW_REGISTER_TYPE_UD);
         break;
      case nir_tex_src_offset:
         tex_offset = retype(src, BRW_REGISTER_TYPE_D);
         if (instr->is_array)
            offset_components = instr->coord_components - 1;
         else
            offset_components = instr->coord_components;
         break;
      case nir_tex_src_projector:
         unreachable("should be lowered");

      case nir_tex_src_sampler_offset: {
         /* Figure out the highest possible sampler index and mark it as used */
         uint32_t max_used = sampler + instr->sampler_array_size - 1;
         if (instr->op == nir_texop_tg4 && devinfo->gen < 8) {
            max_used += stage_prog_data->binding_table.gather_texture_start;
         } else {
            max_used += stage_prog_data->binding_table.texture_start;
         }
         brw_mark_surface_used(prog_data, max_used);

         /* Emit code to evaluate the actual indexing expression */
         sampler_reg = vgrf(glsl_type::uint_type);
         bld.ADD(sampler_reg, src, fs_reg(sampler));
         sampler_reg = bld.emit_uniformize(sampler_reg);
         break;
      }

      default:
         unreachable("unknown texture source");
      }
   }

   if (instr->op == nir_texop_txf_ms) {
      if (devinfo->gen >= 7 &&
          key_tex->compressed_multisample_layout_mask & (1 << sampler)) {
         mcs = emit_mcs_fetch(coordinate, instr->coord_components, sampler_reg);
      } else {
         mcs = fs_reg(0u);
      }
   }

   for (unsigned i = 0; i < 3; i++) {
      if (instr->const_offset[i] != 0) {
         assert(offset_components == 0);
         tex_offset = fs_reg(brw_texture_offset(instr->const_offset, 3));
         break;
      }
   }

   enum glsl_base_type dest_base_type =
     brw_glsl_base_type_for_nir_type (instr->dest_type);

   const glsl_type *dest_type =
      glsl_type::get_instance(dest_base_type, nir_tex_instr_dest_size(instr),
                              1);

   ir_texture_opcode op;
   switch (instr->op) {
   case nir_texop_lod: op = ir_lod; break;
   case nir_texop_query_levels: op = ir_query_levels; break;
   case nir_texop_tex: op = ir_tex; break;
   case nir_texop_tg4: op = ir_tg4; break;
   case nir_texop_txb: op = ir_txb; break;
   case nir_texop_txd: op = ir_txd; break;
   case nir_texop_txf: op = ir_txf; break;
   case nir_texop_txf_ms: op = ir_txf_ms; break;
   case nir_texop_txl: op = ir_txl; break;
   case nir_texop_txs: op = ir_txs; break;
   default:
      unreachable("unknown texture opcode");
   }

   emit_texture(op, dest_type, coordinate, instr->coord_components,
                shadow_comparitor, lod, lod2, lod_components, sample_index,
                tex_offset, mcs, gather_component,
                is_cube_array, is_rect, sampler, sampler_reg, texunit);

   fs_reg dest = get_nir_dest(instr->dest);
   dest.type = this->result.type;
   unsigned num_components = nir_tex_instr_dest_size(instr);
   emit_percomp(bld, fs_inst(BRW_OPCODE_MOV, bld.dispatch_width(),
                             dest, this->result),
                (1 << num_components) - 1);
}

void
fs_visitor::nir_emit_jump(const fs_builder &bld, nir_jump_instr *instr)
{
   switch (instr->type) {
   case nir_jump_break:
      bld.emit(BRW_OPCODE_BREAK);
      break;
   case nir_jump_continue:
      bld.emit(BRW_OPCODE_CONTINUE);
      break;
   case nir_jump_return:
   default:
      unreachable("unknown jump");
   }
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.0.8

This seems to fix some of the problems with clutter/gnome reported to
occur on r600 with 11.0.6
@
text
@d108 1
a108 2
            int location = var->data.location;
            emit_general_interpolation(&input, var->name, var->type,
d110 1
a110 1
                                       &location, var->data.centroid,
a118 26
fs_visitor::nir_setup_single_output_varying(fs_reg &reg,
                                            const glsl_type *type,
                                            unsigned &location)
{
   if (type->is_array() || type->is_matrix()) {
      const struct glsl_type *elem_type = glsl_get_array_element(type);
      const unsigned length = glsl_get_length(type);

      for (unsigned i = 0; i < length; i++) {
         nir_setup_single_output_varying(reg, elem_type, location);
      }
   } else if (type->is_record()) {
      for (unsigned i = 0; i < type->length; i++) {
         const struct glsl_type *field_type = type->fields.structure[i].type;
         nir_setup_single_output_varying(reg, field_type, location);
      }
   } else {
      assert(type->is_scalar() || type->is_vector());
      this->outputs[location] = reg;
      this->output_components[location] = type->vector_elements;
      reg = offset(reg, bld, 4);
      location++;
   }
}

void
d133 6
a138 3
      case MESA_SHADER_VERTEX: {
         unsigned location = var->data.location;
         nir_setup_single_output_varying(reg, var->type, location);
a139 1
      }
@


1.1.1.3
log
@Import Mesa 11.2.2
@
text
@d24 3
a26 1
#include "compiler/glsl/ir.h"
d28 1
a31 1
#include "brw_program.h"
a33 1
using namespace brw::surface_access;
d38 2
d43 4
a46 4
   nir_setup_inputs();
   nir_setup_outputs();
   nir_setup_uniforms();
   nir_emit_system_values();
d49 4
a52 4
   nir_foreach_function(nir, function) {
      assert(strcmp(function->name, "main") == 0);
      assert(function->impl);
      nir_emit_impl(function->impl);
d57 1
a57 1
fs_visitor::nir_setup_inputs()
d59 1
a59 2
   if (stage != MESA_SHADER_FRAGMENT)
      return;
d61 2
a62 3
   nir_inputs = bld.vgrf(BRW_REGISTER_TYPE_F, nir->num_inputs);

   nir_foreach_variable(var, &nir->inputs) {
d66 49
a114 19
      if (var->data.location == VARYING_SLOT_POS) {
         reg = *emit_fragcoord_interpolation(var->data.pixel_center_integer,
                                             var->data.origin_upper_left);
         emit_percomp(bld, fs_inst(BRW_OPCODE_MOV, bld.dispatch_width(),
                                   input, reg), 0xF);
      } else if (var->data.location == VARYING_SLOT_LAYER) {
         struct brw_reg reg = suboffset(interp_reg(VARYING_SLOT_LAYER, 1), 3);
         reg.type = BRW_REGISTER_TYPE_D;
         bld.emit(FS_OPCODE_CINTERP, retype(input, BRW_REGISTER_TYPE_D), reg);
      } else if (var->data.location == VARYING_SLOT_VIEWPORT) {
         struct brw_reg reg = suboffset(interp_reg(VARYING_SLOT_VIEWPORT, 2), 3);
         reg.type = BRW_REGISTER_TYPE_D;
         bld.emit(FS_OPCODE_CINTERP, retype(input, BRW_REGISTER_TYPE_D), reg);
      } else {
         int location = var->data.location;
         emit_general_interpolation(&input, var->name, var->type,
                                    (glsl_interp_qualifier) var->data.interpolation,
                                    &location, var->data.centroid,
                                    var->data.sample);
d120 1
a120 1
fs_visitor::nir_setup_single_output_varying(fs_reg *reg,
d122 1
a122 1
                                            unsigned *location)
d138 4
a141 4
      this->outputs[*location] = *reg;
      this->output_components[*location] = type->vector_elements;
      *reg = offset(*reg, bld, 4);
      (*location)++;
d146 1
a146 1
fs_visitor::nir_setup_outputs()
d150 1
a150 1
   nir_outputs = bld.vgrf(BRW_REGISTER_TYPE_F, nir->num_outputs);
d152 1
a152 1
   nir_foreach_variable(var, &nir->outputs) {
d155 4
d160 1
a160 3
      case MESA_SHADER_VERTEX:
      case MESA_SHADER_TESS_EVAL:
      case MESA_SHADER_GEOMETRY: {
d162 1
a162 1
         nir_setup_single_output_varying(&reg, var->type, &location);
d166 1
a166 5
         if (key->force_dual_color_blend &&
             var->data.location == FRAG_RESULT_DATA1) {
            this->dual_src_output = reg;
            this->do_dual_src = true;
         } else if (var->data.index > 0) {
a178 2
         } else if (var->data.location == FRAG_RESULT_STENCIL) {
            this->frag_stencil = reg;
a181 2
            int vector_elements = var->type->without_array()->vector_elements;

d201 1
a201 1
fs_visitor::nir_setup_uniforms()
d203 2
d208 36
a243 1
   uniforms = nir->num_uniforms / 4;
d245 18
a262 3
   nir_foreach_variable(var, &nir->uniforms) {
      /* UBO's and atomics don't take up space in the uniform file */
      if (var->interface_type != NULL || var->type->contains_atomic())
d264 29
d294 22
a315 2
      if (type_size_scalar(var->type) > 0)
         param_size[var->data.driver_location / 4] = type_size_scalar(var->type);
a354 26
      case nir_intrinsic_load_base_instance:
         assert(v->stage == MESA_SHADER_VERTEX);
         reg = &v->nir_system_values[SYSTEM_VALUE_BASE_INSTANCE];
         if (reg->file == BAD_FILE)
            *reg = *v->emit_vs_system_value(SYSTEM_VALUE_BASE_INSTANCE);
         break;

      case nir_intrinsic_load_draw_id:
         assert(v->stage == MESA_SHADER_VERTEX);
         reg = &v->nir_system_values[SYSTEM_VALUE_DRAW_ID];
         if (reg->file == BAD_FILE)
            *reg = *v->emit_vs_system_value(SYSTEM_VALUE_DRAW_ID);
         break;

      case nir_intrinsic_load_invocation_id:
         assert(v->stage == MESA_SHADER_GEOMETRY);
         reg = &v->nir_system_values[SYSTEM_VALUE_INVOCATION_ID];
         if (reg->file == BAD_FILE) {
            const fs_builder abld = v->bld.annotate("gl_InvocationID", NULL);
            fs_reg g1(retype(brw_vec8_grf(1, 0), BRW_REGISTER_TYPE_UD));
            fs_reg iid = abld.vgrf(BRW_REGISTER_TYPE_UD, 1);
            abld.SHR(iid, g1, brw_imm_ud(27u));
            *reg = iid;
         }
         break;

a377 65
      case nir_intrinsic_load_local_invocation_id:
         assert(v->stage == MESA_SHADER_COMPUTE);
         reg = &v->nir_system_values[SYSTEM_VALUE_LOCAL_INVOCATION_ID];
         if (reg->file == BAD_FILE)
            *reg = *v->emit_cs_local_invocation_id_setup();
         break;

      case nir_intrinsic_load_work_group_id:
         assert(v->stage == MESA_SHADER_COMPUTE);
         reg = &v->nir_system_values[SYSTEM_VALUE_WORK_GROUP_ID];
         if (reg->file == BAD_FILE)
            *reg = *v->emit_cs_work_group_id_setup();
         break;

      case nir_intrinsic_load_helper_invocation:
         assert(v->stage == MESA_SHADER_FRAGMENT);
         reg = &v->nir_system_values[SYSTEM_VALUE_HELPER_INVOCATION];
         if (reg->file == BAD_FILE) {
            const fs_builder abld =
               v->bld.annotate("gl_HelperInvocation", NULL);

            /* On Gen6+ (gl_HelperInvocation is only exposed on Gen7+) the
             * pixel mask is in g1.7 of the thread payload.
             *
             * We move the per-channel pixel enable bit to the low bit of each
             * channel by shifting the byte containing the pixel mask by the
             * vector immediate 0x76543210UV.
             *
             * The region of <1,8,0> reads only 1 byte (the pixel masks for
             * subspans 0 and 1) in SIMD8 and an additional byte (the pixel
             * masks for 2 and 3) in SIMD16.
             */
            fs_reg shifted = abld.vgrf(BRW_REGISTER_TYPE_UW, 1);
            abld.SHR(shifted,
                     stride(byte_offset(retype(brw_vec1_grf(1, 0),
                                               BRW_REGISTER_TYPE_UB), 28),
                            1, 8, 0),
                     brw_imm_uv(0x76543210));

            /* A set bit in the pixel mask means the channel is enabled, but
             * that is the opposite of gl_HelperInvocation so we need to invert
             * the mask.
             *
             * The negate source-modifier bit of logical instructions on Gen8+
             * performs 1's complement negation, so we can use that instead of
             * a NOT instruction.
             */
            fs_reg inverted = negate(shifted);
            if (v->devinfo->gen < 8) {
               inverted = abld.vgrf(BRW_REGISTER_TYPE_UW);
               abld.NOT(inverted, shifted);
            }

            /* We then resolve the 0/1 result to 0/~0 boolean values by ANDing
             * with 1 and negating.
             */
            fs_reg anded = abld.vgrf(BRW_REGISTER_TYPE_UD, 1);
            abld.AND(anded, inverted, brw_imm_uw(1));

            fs_reg dst = abld.vgrf(BRW_REGISTER_TYPE_D, 1);
            abld.MOV(dst, negate(retype(anded, BRW_REGISTER_TYPE_D)));
            *reg = dst;
         }
         break;

d387 1
a387 1
fs_visitor::nir_emit_system_values()
d390 4
a393 8
   for (unsigned i = 0; i < SYSTEM_VALUE_MAX; i++) {
      nir_system_values[i] = fs_reg();
   }

   nir_foreach_function(nir, function) {
      assert(strcmp(function->name, "main") == 0);
      assert(function->impl);
      nir_foreach_block(function->impl, emit_system_values_block, this);
d400 1
a400 5
   nir_locals = ralloc_array(mem_ctx, fs_reg, impl->reg_alloc);
   for (unsigned i = 0; i < impl->reg_alloc; i++) {
      nir_locals[i] = fs_reg();
   }

d457 2
d490 1
a490 19
      switch (stage) {
      case MESA_SHADER_VERTEX:
         nir_emit_vs_intrinsic(abld, nir_instr_as_intrinsic(instr));
         break;
      case MESA_SHADER_TESS_EVAL:
         nir_emit_tes_intrinsic(abld, nir_instr_as_intrinsic(instr));
         break;
      case MESA_SHADER_GEOMETRY:
         nir_emit_gs_intrinsic(abld, nir_instr_as_intrinsic(instr));
         break;
      case MESA_SHADER_FRAGMENT:
         nir_emit_fs_intrinsic(abld, nir_instr_as_intrinsic(instr));
         break;
      case MESA_SHADER_COMPUTE:
         nir_emit_cs_intrinsic(abld, nir_instr_as_intrinsic(instr));
         break;
      default:
         unreachable("unsupported shader stage");
      }
d561 2
a562 1
      bld.OR(tmp, g0, brw_imm_uw(0x3f80));
d586 1
a586 1
      bld.OR(tmp, g1_6, brw_imm_d(0x3f800000));
d588 1
a588 1
   bld.AND(retype(result, BRW_REGISTER_TYPE_D), tmp, brw_imm_d(0xbf800000));
d701 1
a701 1
      bld.CMP(bld.null_reg_f(), op[0], brw_imm_f(0.0f), BRW_CONDITIONAL_NZ);
d706 1
a706 1
      bld.AND(result_int, op[0], brw_imm_ud(0x80000000u));
d708 1
a708 1
      inst = bld.OR(result_int, result_int, brw_imm_ud(0x3f800000u));
d722 3
a724 3
      bld.CMP(bld.null_reg_d(), op[0], brw_imm_d(0), BRW_CONDITIONAL_G);
      bld.ASR(result, op[0], brw_imm_d(31));
      inst = bld.OR(result, result, brw_imm_d(1));
d772 1
a772 1
                         brw_imm_d(fs_key->render_to_fbo));
d775 1
a775 1
                         brw_imm_d(fs_key->render_to_fbo));
d781 1
a781 1
                      brw_imm_d(fs_key->render_to_fbo));
d786 1
a786 1
                      brw_imm_d(fs_key->render_to_fbo));
d878 6
d935 1
a935 1
      bld.CMP(result, op[0], brw_imm_f(0.0f), BRW_CONDITIONAL_NZ);
d938 1
a938 1
      bld.CMP(result, op[0], brw_imm_d(0), BRW_CONDITIONAL_NZ);
d971 8
a978 1
      inst = bld.emit_minmax(result, op[0], op[1], BRW_CONDITIONAL_L);
d985 8
a992 1
      inst = bld.emit_minmax(result, op[0], op[1], BRW_CONDITIONAL_GE);
a1037 1
      bld.CMP(bld.null_reg_d(), result, brw_imm_d(-1), BRW_CONDITIONAL_NZ);
d1039 4
a1042 1
      inst = bld.ADD(result, result, brw_imm_d(31));
a1043 1
      inst->src[0].negate = true;
a1052 3
      unreachable("should have been lowered");
   case nir_op_ubfe:
   case nir_op_ibfe:
d1063 2
a1064 1
      unreachable("not reached: should have been lowered");
d1094 1
a1094 1
      bld.CMP(bld.null_reg_d(), op[0], brw_imm_d(0), BRW_CONDITIONAL_NZ);
a1098 16
   case nir_op_extract_u8:
   case nir_op_extract_i8: {
      nir_const_value *byte = nir_src_as_const_value(instr->src[1].src);
      bld.emit(SHADER_OPCODE_EXTRACT_BYTE,
               result, op[0], brw_imm_ud(byte->u[0]));
      break;
   }

   case nir_op_extract_u16:
   case nir_op_extract_i16: {
      nir_const_value *word = nir_src_as_const_value(instr->src[1].src);
      bld.emit(SHADER_OPCODE_EXTRACT_WORD,
               result, op[0], brw_imm_ud(word->u[0]));
      break;
   }

d1109 1
a1109 1
      bld.AND(masked, result, brw_imm_d(1));
d1122 1
a1122 1
      bld.MOV(offset(reg, bld, i), brw_imm_d(instr->value.i[i]));
d1134 22
d1163 2
a1164 4
      /* We don't handle indirects on locals */
      assert(src.reg.indirect == NULL);
      reg = offset(nir_locals[src.reg.reg->index], bld,
                   src.reg.base_offset * src.reg.reg->num_components);
a1180 5
   } else {
      /* We don't handle indirects on locals */
      assert(dest.reg.indirect == NULL);
      return offset(nir_locals[dest.reg.reg->index], bld,
                    dest.reg.base_offset * dest.reg.reg->num_components);
d1182 3
d1190 1
a1190 1
   fs_reg image(UNIFORM, deref->var->data.driver_location / 4,
d1193 6
a1198 6
   for (const nir_deref *tail = &deref->deref; tail->child;
        tail = tail->child) {
      const nir_deref_array *deref_array = nir_deref_as_array(tail->child);
      assert(tail->child->deref_type == nir_deref_type_array);
      const unsigned size = glsl_get_length(tail->type);
      const unsigned element_size = type_size_scalar(deref_array->deref.type);
d1200 2
a1201 1
      image = offset(image, bld, base * element_size);
d1204 1
a1204 1
         fs_reg tmp = vgrf(glsl_type::int_type);
d1215 3
a1217 3
            bld.emit_minmax(tmp, retype(get_nir_src(deref_array->indirect),
                                        BRW_REGISTER_TYPE_UD),
                            brw_imm_ud(size - base - 1), BRW_CONDITIONAL_L);
d1219 1
a1219 1
            bld.MOV(tmp, get_nir_src(deref_array->indirect));
d1222 2
a1223 5
         bld.MUL(tmp, tmp, brw_imm_ud(element_size * 4));
         if (image.reladdr)
            bld.ADD(*image.reladdr, *image.reladdr, tmp);
         else
            image.reladdr = new(mem_ctx) fs_reg(tmp);
d1241 1
a1241 1
         if (new_inst->src[j].file == VGRF)
d1255 1
a1255 1
   switch ((glsl_base_type)type->sampled_type) {
d1297 2
a1298 7
static fs_inst *
emit_pixel_interpolater_send(const fs_builder &bld,
                             enum opcode opcode,
                             const fs_reg &dst,
                             const fs_reg &src,
                             const fs_reg &desc,
                             glsl_interp_qualifier interpolation)
d1300 25
a1324 3
   fs_inst *inst;
   fs_reg payload;
   int mlen;
d1326 4
a1329 7
   if (src.file == BAD_FILE) {
      /* Dummy payload */
      payload = bld.vgrf(BRW_REGISTER_TYPE_F, 1);
      mlen = 1;
   } else {
      payload = src;
      mlen = 2 * bld.dispatch_width() / 8;
d1332 4
a1335 5
   inst = bld.emit(opcode, dst, payload, desc);
   inst->mlen = mlen;
   /* 2 floats per slot returned */
   inst->regs_written = 2 * bld.dispatch_width() / 8;
   inst->pi_noperspective = interpolation == INTERP_QUALIFIER_NOPERSPECTIVE;
d1337 5
a1341 2
   return inst;
}
d1343 5
a1347 7
/**
 * Computes 1 << x, given a D/UD register containing some value x.
 */
static fs_reg
intexp2(const fs_builder &bld, const fs_reg &x)
{
   assert(x.type == BRW_REGISTER_TYPE_UD || x.type == BRW_REGISTER_TYPE_D);
d1349 4
a1352 2
   fs_reg result = bld.vgrf(x.type, 1);
   fs_reg one = bld.vgrf(x.type, 1);
d1354 4
a1357 4
   bld.MOV(one, retype(brw_imm_d(1), one.type));
   bld.SHL(result, one, x);
   return result;
}
d1359 3
a1361 4
void
fs_visitor::emit_gs_end_primitive(const nir_src &vertex_count_nir_src)
{
   assert(stage == MESA_SHADER_GEOMETRY);
d1363 2
a1364 2
   struct brw_gs_prog_data *gs_prog_data =
      (struct brw_gs_prog_data *) prog_data;
d1366 3
a1368 7
   /* We can only do EndPrimitive() functionality when the control data
    * consists of cut bits.  Fortunately, the only time it isn't is when the
    * output type is points, in which case EndPrimitive() is a no-op.
    */
   if (gs_prog_data->control_data_format !=
       GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_CUT) {
      return;
d1371 11
a1381 2
   /* Cut bits use one bit per vertex. */
   assert(gs_compile->control_data_bits_per_vertex == 1);
d1383 4
a1386 2
   fs_reg vertex_count = get_nir_src(vertex_count_nir_src);
   vertex_count.type = BRW_REGISTER_TYPE_UD;
d1388 7
a1394 20
   /* Cut bit n should be set to 1 if EndPrimitive() was called after emitting
    * vertex n, 0 otherwise.  So all we need to do here is mark bit
    * (vertex_count - 1) % 32 in the cut_bits register to indicate that
    * EndPrimitive() was called after emitting vertex (vertex_count - 1);
    * vec4_gs_visitor::emit_control_data_bits() will take care of the rest.
    *
    * Note that if EndPrimitive() is called before emitting any vertices, this
    * will cause us to set bit 31 of the control_data_bits register to 1.
    * That's fine because:
    *
    * - If max_vertices < 32, then vertex number 31 (zero-based) will never be
    *   output, so the hardware will ignore cut bit 31.
    *
    * - If max_vertices == 32, then vertex number 31 is guaranteed to be the
    *   last vertex, so setting cut bit 31 has no effect (since the primitive
    *   is automatically ended when the GS terminates).
    *
    * - If max_vertices > 32, then the ir_emit_vertex visitor will reset the
    *   control_data_bits register to 0 when the first vertex is emitted.
    */
d1396 11
a1406 1
   const fs_builder abld = bld.annotate("end primitive");
d1408 3
a1410 11
   /* control_data_bits |= 1 << ((vertex_count - 1) % 32) */
   fs_reg prev_count = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
   abld.ADD(prev_count, vertex_count, brw_imm_ud(0xffffffffu));
   fs_reg mask = intexp2(abld, prev_count);
   /* Note: we're relying on the fact that the GEN SHL instruction only pays
    * attention to the lower 5 bits of its second source argument, so on this
    * architecture, 1 << (vertex_count - 1) is equivalent to 1 <<
    * ((vertex_count - 1) % 32).
    */
   abld.OR(this->control_data_bits, this->control_data_bits, mask);
}
d1412 2
a1413 5
void
fs_visitor::emit_gs_control_data_bits(const fs_reg &vertex_count)
{
   assert(stage == MESA_SHADER_GEOMETRY);
   assert(gs_compile->control_data_bits_per_vertex != 0);
d1415 4
a1418 2
   struct brw_gs_prog_data *gs_prog_data =
      (struct brw_gs_prog_data *) prog_data;
d1420 6
a1425 2
   const fs_builder abld = bld.annotate("emit control data bits");
   const fs_builder fwa_bld = bld.exec_all();
d1427 5
a1431 1052
   /* We use a single UD register to accumulate control data bits (32 bits
    * for each of the SIMD8 channels).  So we need to write a DWord (32 bits)
    * at a time.
    *
    * Unfortunately, the URB_WRITE_SIMD8 message uses 128-bit (OWord) offsets.
    * We have select a 128-bit group via the Global and Per-Slot Offsets, then
    * use the Channel Mask phase to enable/disable which DWord within that
    * group to write.  (Remember, different SIMD8 channels may have emitted
    * different numbers of vertices, so we may need per-slot offsets.)
    *
    * Channel masking presents an annoying problem: we may have to replicate
    * the data up to 4 times:
    *
    * Msg = Handles, Per-Slot Offsets, Channel Masks, Data, Data, Data, Data.
    *
    * To avoid penalizing shaders that emit a small number of vertices, we
    * can avoid these sometimes: if the size of the control data header is
    * <= 128 bits, then there is only 1 OWord.  All SIMD8 channels will land
    * land in the same 128-bit group, so we can skip per-slot offsets.
    *
    * Similarly, if the control data header is <= 32 bits, there is only one
    * DWord, so we can skip channel masks.
    */
   enum opcode opcode = SHADER_OPCODE_URB_WRITE_SIMD8;

   fs_reg channel_mask, per_slot_offset;

   if (gs_compile->control_data_header_size_bits > 32) {
      opcode = SHADER_OPCODE_URB_WRITE_SIMD8_MASKED;
      channel_mask = vgrf(glsl_type::uint_type);
   }

   if (gs_compile->control_data_header_size_bits > 128) {
      opcode = SHADER_OPCODE_URB_WRITE_SIMD8_MASKED_PER_SLOT;
      per_slot_offset = vgrf(glsl_type::uint_type);
   }

   /* Figure out which DWord we're trying to write to using the formula:
    *
    *    dword_index = (vertex_count - 1) * bits_per_vertex / 32
    *
    * Since bits_per_vertex is a power of two, and is known at compile
    * time, this can be optimized to:
    *
    *    dword_index = (vertex_count - 1) >> (6 - log2(bits_per_vertex))
    */
   if (opcode != SHADER_OPCODE_URB_WRITE_SIMD8) {
      fs_reg dword_index = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
      fs_reg prev_count = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
      abld.ADD(prev_count, vertex_count, brw_imm_ud(0xffffffffu));
      unsigned log2_bits_per_vertex =
         _mesa_fls(gs_compile->control_data_bits_per_vertex);
      abld.SHR(dword_index, prev_count, brw_imm_ud(6u - log2_bits_per_vertex));

      if (per_slot_offset.file != BAD_FILE) {
         /* Set the per-slot offset to dword_index / 4, so that we'll write to
          * the appropriate OWord within the control data header.
          */
         abld.SHR(per_slot_offset, dword_index, brw_imm_ud(2u));
      }

      /* Set the channel masks to 1 << (dword_index % 4), so that we'll
       * write to the appropriate DWORD within the OWORD.
       */
      fs_reg channel = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
      fwa_bld.AND(channel, dword_index, brw_imm_ud(3u));
      channel_mask = intexp2(fwa_bld, channel);
      /* Then the channel masks need to be in bits 23:16. */
      fwa_bld.SHL(channel_mask, channel_mask, brw_imm_ud(16u));
   }

   /* Store the control data bits in the message payload and send it. */
   int mlen = 2;
   if (channel_mask.file != BAD_FILE)
      mlen += 4; /* channel masks, plus 3 extra copies of the data */
   if (per_slot_offset.file != BAD_FILE)
      mlen++;

   fs_reg payload = bld.vgrf(BRW_REGISTER_TYPE_UD, mlen);
   fs_reg *sources = ralloc_array(mem_ctx, fs_reg, mlen);
   int i = 0;
   sources[i++] = fs_reg(retype(brw_vec8_grf(1, 0), BRW_REGISTER_TYPE_UD));
   if (per_slot_offset.file != BAD_FILE)
      sources[i++] = per_slot_offset;
   if (channel_mask.file != BAD_FILE)
      sources[i++] = channel_mask;
   while (i < mlen) {
      sources[i++] = this->control_data_bits;
   }

   abld.LOAD_PAYLOAD(payload, sources, mlen, mlen);
   fs_inst *inst = abld.emit(opcode, reg_undef, payload);
   inst->mlen = mlen;
   /* We need to increment Global Offset by 256-bits to make room for
    * Broadwell's extra "Vertex Count" payload at the beginning of the
    * URB entry.  Since this is an OWord message, Global Offset is counted
    * in 128-bit units, so we must set it to 2.
    */
   if (gs_prog_data->static_vertex_count == -1)
      inst->offset = 2;
}

void
fs_visitor::set_gs_stream_control_data_bits(const fs_reg &vertex_count,
                                            unsigned stream_id)
{
   /* control_data_bits |= stream_id << ((2 * (vertex_count - 1)) % 32) */

   /* Note: we are calling this *before* increasing vertex_count, so
    * this->vertex_count == vertex_count - 1 in the formula above.
    */

   /* Stream mode uses 2 bits per vertex */
   assert(gs_compile->control_data_bits_per_vertex == 2);

   /* Must be a valid stream */
   assert(stream_id >= 0 && stream_id < MAX_VERTEX_STREAMS);

   /* Control data bits are initialized to 0 so we don't have to set any
    * bits when sending vertices to stream 0.
    */
   if (stream_id == 0)
      return;

   const fs_builder abld = bld.annotate("set stream control data bits", NULL);

   /* reg::sid = stream_id */
   fs_reg sid = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
   abld.MOV(sid, brw_imm_ud(stream_id));

   /* reg:shift_count = 2 * (vertex_count - 1) */
   fs_reg shift_count = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
   abld.SHL(shift_count, vertex_count, brw_imm_ud(1u));

   /* Note: we're relying on the fact that the GEN SHL instruction only pays
    * attention to the lower 5 bits of its second source argument, so on this
    * architecture, stream_id << 2 * (vertex_count - 1) is equivalent to
    * stream_id << ((2 * (vertex_count - 1)) % 32).
    */
   fs_reg mask = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
   abld.SHL(mask, sid, shift_count);
   abld.OR(this->control_data_bits, this->control_data_bits, mask);
}

void
fs_visitor::emit_gs_vertex(const nir_src &vertex_count_nir_src,
                           unsigned stream_id)
{
   assert(stage == MESA_SHADER_GEOMETRY);

   struct brw_gs_prog_data *gs_prog_data =
      (struct brw_gs_prog_data *) prog_data;

   fs_reg vertex_count = get_nir_src(vertex_count_nir_src);
   vertex_count.type = BRW_REGISTER_TYPE_UD;

   /* Haswell and later hardware ignores the "Render Stream Select" bits
    * from the 3DSTATE_STREAMOUT packet when the SOL stage is disabled,
    * and instead sends all primitives down the pipeline for rasterization.
    * If the SOL stage is enabled, "Render Stream Select" is honored and
    * primitives bound to non-zero streams are discarded after stream output.
    *
    * Since the only purpose of primives sent to non-zero streams is to
    * be recorded by transform feedback, we can simply discard all geometry
    * bound to these streams when transform feedback is disabled.
    */
   if (stream_id > 0 && !nir->info.has_transform_feedback_varyings)
      return;

   /* If we're outputting 32 control data bits or less, then we can wait
    * until the shader is over to output them all.  Otherwise we need to
    * output them as we go.  Now is the time to do it, since we're about to
    * output the vertex_count'th vertex, so it's guaranteed that the
    * control data bits associated with the (vertex_count - 1)th vertex are
    * correct.
    */
   if (gs_compile->control_data_header_size_bits > 32) {
      const fs_builder abld =
         bld.annotate("emit vertex: emit control data bits");

      /* Only emit control data bits if we've finished accumulating a batch
       * of 32 bits.  This is the case when:
       *
       *     (vertex_count * bits_per_vertex) % 32 == 0
       *
       * (in other words, when the last 5 bits of vertex_count *
       * bits_per_vertex are 0).  Assuming bits_per_vertex == 2^n for some
       * integer n (which is always the case, since bits_per_vertex is
       * always 1 or 2), this is equivalent to requiring that the last 5-n
       * bits of vertex_count are 0:
       *
       *     vertex_count & (2^(5-n) - 1) == 0
       *
       * 2^(5-n) == 2^5 / 2^n == 32 / bits_per_vertex, so this is
       * equivalent to:
       *
       *     vertex_count & (32 / bits_per_vertex - 1) == 0
       *
       * TODO: If vertex_count is an immediate, we could do some of this math
       *       at compile time...
       */
      fs_inst *inst =
         abld.AND(bld.null_reg_d(), vertex_count,
                  brw_imm_ud(32u / gs_compile->control_data_bits_per_vertex - 1u));
      inst->conditional_mod = BRW_CONDITIONAL_Z;

      abld.IF(BRW_PREDICATE_NORMAL);
      /* If vertex_count is 0, then no control data bits have been
       * accumulated yet, so we can skip emitting them.
       */
      abld.CMP(bld.null_reg_d(), vertex_count, brw_imm_ud(0u),
               BRW_CONDITIONAL_NEQ);
      abld.IF(BRW_PREDICATE_NORMAL);
      emit_gs_control_data_bits(vertex_count);
      abld.emit(BRW_OPCODE_ENDIF);

      /* Reset control_data_bits to 0 so we can start accumulating a new
       * batch.
       *
       * Note: in the case where vertex_count == 0, this neutralizes the
       * effect of any call to EndPrimitive() that the shader may have
       * made before outputting its first vertex.
       */
      inst = abld.MOV(this->control_data_bits, brw_imm_ud(0u));
      inst->force_writemask_all = true;
      abld.emit(BRW_OPCODE_ENDIF);
   }

   emit_urb_writes(vertex_count);

   /* In stream mode we have to set control data bits for all vertices
    * unless we have disabled control data bits completely (which we do
    * do for GL_POINTS outputs that don't use streams).
    */
   if (gs_compile->control_data_header_size_bits > 0 &&
       gs_prog_data->control_data_format ==
          GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_SID) {
      set_gs_stream_control_data_bits(vertex_count, stream_id);
   }
}

void
fs_visitor::emit_gs_input_load(const fs_reg &dst,
                               const nir_src &vertex_src,
                               unsigned base_offset,
                               const nir_src &offset_src,
                               unsigned num_components)
{
   struct brw_gs_prog_data *gs_prog_data = (struct brw_gs_prog_data *) prog_data;

   nir_const_value *vertex_const = nir_src_as_const_value(vertex_src);
   nir_const_value *offset_const = nir_src_as_const_value(offset_src);
   const unsigned push_reg_count = gs_prog_data->base.urb_read_length * 8;

   /* Offset 0 is the VUE header, which contains VARYING_SLOT_LAYER [.y],
    * VARYING_SLOT_VIEWPORT [.z], and VARYING_SLOT_PSIZ [.w].  Only
    * gl_PointSize is available as a GS input, however, so it must be that.
    */
   const bool is_point_size = (base_offset == 0);

   if (offset_const != NULL && vertex_const != NULL &&
       4 * (base_offset + offset_const->u[0]) < push_reg_count) {
      int imm_offset = (base_offset + offset_const->u[0]) * 4 +
                       vertex_const->u[0] * push_reg_count;
      /* This input was pushed into registers. */
      if (is_point_size) {
         /* gl_PointSize comes in .w */
         assert(imm_offset == 0);
         bld.MOV(dst, fs_reg(ATTR, imm_offset + 3, dst.type));
      } else {
         for (unsigned i = 0; i < num_components; i++) {
            bld.MOV(offset(dst, bld, i),
                    fs_reg(ATTR, imm_offset + i, dst.type));
         }
      }
   } else {
      /* Resort to the pull model.  Ensure the VUE handles are provided. */
      gs_prog_data->base.include_vue_handles = true;

      unsigned first_icp_handle = gs_prog_data->include_primitive_id ? 3 : 2;
      fs_reg icp_handle;

      if (vertex_const) {
         /* The vertex index is constant; just select the proper URB handle. */
         icp_handle =
            retype(brw_vec8_grf(first_icp_handle + vertex_const->i[0], 0),
                   BRW_REGISTER_TYPE_UD);
      } else {
         /* The vertex index is non-constant.  We need to use indirect
          * addressing to fetch the proper URB handle.
          *
          * First, we start with the sequence <7, 6, 5, 4, 3, 2, 1, 0>
          * indicating that channel <n> should read the handle from
          * DWord <n>.  We convert that to bytes by multiplying by 4.
          *
          * Next, we convert the vertex index to bytes by multiplying
          * by 32 (shifting by 5), and add the two together.  This is
          * the final indirect byte offset.
          */
         fs_reg sequence = bld.vgrf(BRW_REGISTER_TYPE_W, 1);
         fs_reg channel_offsets = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
         fs_reg vertex_offset_bytes = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
         fs_reg icp_offset_bytes = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
         icp_handle = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);

         /* sequence = <7, 6, 5, 4, 3, 2, 1, 0> */
         bld.MOV(sequence, fs_reg(brw_imm_v(0x76543210)));
         /* channel_offsets = 4 * sequence = <28, 24, 20, 16, 12, 8, 4, 0> */
         bld.SHL(channel_offsets, sequence, brw_imm_ud(2u));
         /* Convert vertex_index to bytes (multiply by 32) */
         bld.SHL(vertex_offset_bytes,
                 retype(get_nir_src(vertex_src), BRW_REGISTER_TYPE_UD),
                 brw_imm_ud(5u));
         bld.ADD(icp_offset_bytes, vertex_offset_bytes, channel_offsets);

         /* Use first_icp_handle as the base offset.  There is one register
          * of URB handles per vertex, so inform the register allocator that
          * we might read up to nir->info.gs.vertices_in registers.
          */
         bld.emit(SHADER_OPCODE_MOV_INDIRECT, icp_handle,
                  fs_reg(brw_vec8_grf(first_icp_handle, 0)),
                  fs_reg(icp_offset_bytes),
                  brw_imm_ud(nir->info.gs.vertices_in * REG_SIZE));
      }

      fs_inst *inst;
      if (offset_const) {
         /* Constant indexing - use global offset. */
         inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, dst, icp_handle);
         inst->offset = base_offset + offset_const->u[0];
         inst->base_mrf = -1;
         inst->mlen = 1;
         inst->regs_written = num_components;
      } else {
         /* Indirect indexing - use per-slot offsets as well. */
         const fs_reg srcs[] = { icp_handle, get_nir_src(offset_src) };
         fs_reg payload = bld.vgrf(BRW_REGISTER_TYPE_UD, 2);
         bld.LOAD_PAYLOAD(payload, srcs, ARRAY_SIZE(srcs), 0);

         inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT, dst, payload);
         inst->offset = base_offset;
         inst->base_mrf = -1;
         inst->mlen = 2;
         inst->regs_written = num_components;
      }

      if (is_point_size) {
         /* Read the whole VUE header (because of alignment) and read .w. */
         fs_reg tmp = bld.vgrf(dst.type, 4);
         inst->dst = tmp;
         inst->regs_written = 4;
         bld.MOV(dst, offset(tmp, bld, 3));
      }
   }
}

fs_reg
fs_visitor::get_indirect_offset(nir_intrinsic_instr *instr)
{
   nir_src *offset_src = nir_get_io_offset_src(instr);
   nir_const_value *const_value = nir_src_as_const_value(*offset_src);

   if (const_value) {
      /* The only constant offset we should find is 0.  brw_nir.c's
       * add_const_offset_to_base() will fold other constant offsets
       * into instr->const_index[0].
       */
      assert(const_value->u[0] == 0);
      return fs_reg();
   }

   return get_nir_src(*offset_src);
}

void
fs_visitor::nir_emit_vs_intrinsic(const fs_builder &bld,
                                  nir_intrinsic_instr *instr)
{
   assert(stage == MESA_SHADER_VERTEX);

   fs_reg dest;
   if (nir_intrinsic_infos[instr->intrinsic].has_dest)
      dest = get_nir_dest(instr->dest);

   switch (instr->intrinsic) {
   case nir_intrinsic_load_vertex_id:
      unreachable("should be lowered by lower_vertex_id()");

   case nir_intrinsic_load_vertex_id_zero_base:
   case nir_intrinsic_load_base_vertex:
   case nir_intrinsic_load_instance_id:
   case nir_intrinsic_load_base_instance:
   case nir_intrinsic_load_draw_id: {
      gl_system_value sv = nir_system_value_from_intrinsic(instr->intrinsic);
      fs_reg val = nir_system_values[sv];
      assert(val.file != BAD_FILE);
      dest.type = val.type;
      bld.MOV(dest, val);
      break;
   }

   default:
      nir_emit_intrinsic(bld, instr);
      break;
   }
}

void
fs_visitor::nir_emit_tes_intrinsic(const fs_builder &bld,
                                   nir_intrinsic_instr *instr)
{
   assert(stage == MESA_SHADER_TESS_EVAL);
   struct brw_tes_prog_data *tes_prog_data = (struct brw_tes_prog_data *) prog_data;

   fs_reg dest;
   if (nir_intrinsic_infos[instr->intrinsic].has_dest)
      dest = get_nir_dest(instr->dest);

   switch (instr->intrinsic) {
   case nir_intrinsic_load_primitive_id:
      bld.MOV(dest, fs_reg(brw_vec1_grf(0, 1)));
      break;
   case nir_intrinsic_load_tess_coord:
      /* gl_TessCoord is part of the payload in g1-3 */
      for (unsigned i = 0; i < 3; i++) {
         bld.MOV(offset(dest, bld, i), fs_reg(brw_vec8_grf(1 + i, 0)));
      }
      break;

   case nir_intrinsic_load_tess_level_outer:
      /* When the TES reads gl_TessLevelOuter, we ensure that the patch header
       * appears as a push-model input.  So, we can simply use the ATTR file
       * rather than issuing URB read messages.  The data is stored in the
       * high DWords in reverse order - DWord 7 contains .x, DWord 6 contains
       * .y, and so on.
       */
      switch (tes_prog_data->domain) {
      case BRW_TESS_DOMAIN_QUAD:
         for (unsigned i = 0; i < 4; i++)
            bld.MOV(offset(dest, bld, i), component(fs_reg(ATTR, 0), 7 - i));
         break;
      case BRW_TESS_DOMAIN_TRI:
         for (unsigned i = 0; i < 3; i++)
            bld.MOV(offset(dest, bld, i), component(fs_reg(ATTR, 0), 7 - i));
         break;
      case BRW_TESS_DOMAIN_ISOLINE:
         for (unsigned i = 0; i < 2; i++)
            bld.MOV(offset(dest, bld, i), component(fs_reg(ATTR, 0), 7 - i));
         break;
      }
      break;

   case nir_intrinsic_load_tess_level_inner:
      /* When the TES reads gl_TessLevelInner, we ensure that the patch header
       * appears as a push-model input.  So, we can simply use the ATTR file
       * rather than issuing URB read messages.
       */
      switch (tes_prog_data->domain) {
      case BRW_TESS_DOMAIN_QUAD:
         bld.MOV(dest, component(fs_reg(ATTR, 0), 3));
         bld.MOV(offset(dest, bld, 1), component(fs_reg(ATTR, 0), 2));
         break;
      case BRW_TESS_DOMAIN_TRI:
         bld.MOV(dest, component(fs_reg(ATTR, 0), 4));
         break;
      case BRW_TESS_DOMAIN_ISOLINE:
         /* ignore - value is undefined */
         break;
      }
      break;

   case nir_intrinsic_load_input:
   case nir_intrinsic_load_per_vertex_input: {
      fs_reg indirect_offset = get_indirect_offset(instr);
      unsigned imm_offset = instr->const_index[0];

      fs_inst *inst;
      if (indirect_offset.file == BAD_FILE) {
         /* Arbitrarily only push up to 32 vec4 slots worth of data,
          * which is 16 registers (since each holds 2 vec4 slots).
          */
         const unsigned max_push_slots = 32;
         if (imm_offset < max_push_slots) {
            fs_reg src = fs_reg(ATTR, imm_offset / 2, dest.type);
            for (int i = 0; i < instr->num_components; i++) {
               bld.MOV(offset(dest, bld, i),
                       component(src, 4 * (imm_offset % 2) + i));
            }
            tes_prog_data->base.urb_read_length =
               MAX2(tes_prog_data->base.urb_read_length,
                    DIV_ROUND_UP(imm_offset + 1, 2));
         } else {
            /* Replicate the patch handle to all enabled channels */
            const fs_reg srcs[] = {
               retype(brw_vec1_grf(0, 0), BRW_REGISTER_TYPE_UD)
            };
            fs_reg patch_handle = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
            bld.LOAD_PAYLOAD(patch_handle, srcs, ARRAY_SIZE(srcs), 0);

            inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, dest, patch_handle);
            inst->mlen = 1;
            inst->offset = imm_offset;
            inst->base_mrf = -1;
            inst->regs_written = instr->num_components;
         }
      } else {
         /* Indirect indexing - use per-slot offsets as well. */
         const fs_reg srcs[] = {
            retype(brw_vec1_grf(0, 0), BRW_REGISTER_TYPE_UD),
            indirect_offset
         };
         fs_reg payload = bld.vgrf(BRW_REGISTER_TYPE_UD, 2);
         bld.LOAD_PAYLOAD(payload, srcs, ARRAY_SIZE(srcs), 0);

         inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT, dest, payload);
         inst->mlen = 2;
         inst->offset = imm_offset;
         inst->base_mrf = -1;
         inst->regs_written = instr->num_components;
      }
      break;
   }
   default:
      nir_emit_intrinsic(bld, instr);
      break;
   }
}

void
fs_visitor::nir_emit_gs_intrinsic(const fs_builder &bld,
                                  nir_intrinsic_instr *instr)
{
   assert(stage == MESA_SHADER_GEOMETRY);
   fs_reg indirect_offset;

   fs_reg dest;
   if (nir_intrinsic_infos[instr->intrinsic].has_dest)
      dest = get_nir_dest(instr->dest);

   switch (instr->intrinsic) {
   case nir_intrinsic_load_primitive_id:
      assert(stage == MESA_SHADER_GEOMETRY);
      assert(((struct brw_gs_prog_data *)prog_data)->include_primitive_id);
      bld.MOV(retype(dest, BRW_REGISTER_TYPE_UD),
              retype(fs_reg(brw_vec8_grf(2, 0)), BRW_REGISTER_TYPE_UD));
      break;

   case nir_intrinsic_load_input:
      unreachable("load_input intrinsics are invalid for the GS stage");

   case nir_intrinsic_load_per_vertex_input:
      emit_gs_input_load(dest, instr->src[0], instr->const_index[0],
                         instr->src[1], instr->num_components);
      break;

   case nir_intrinsic_emit_vertex_with_counter:
      emit_gs_vertex(instr->src[0], instr->const_index[0]);
      break;

   case nir_intrinsic_end_primitive_with_counter:
      emit_gs_end_primitive(instr->src[0]);
      break;

   case nir_intrinsic_set_vertex_count:
      bld.MOV(this->final_gs_vertex_count, get_nir_src(instr->src[0]));
      break;

   case nir_intrinsic_load_invocation_id: {
      fs_reg val = nir_system_values[SYSTEM_VALUE_INVOCATION_ID];
      assert(val.file != BAD_FILE);
      dest.type = val.type;
      bld.MOV(dest, val);
      break;
   }

   default:
      nir_emit_intrinsic(bld, instr);
      break;
   }
}

void
fs_visitor::nir_emit_fs_intrinsic(const fs_builder &bld,
                                  nir_intrinsic_instr *instr)
{
   assert(stage == MESA_SHADER_FRAGMENT);
   struct brw_wm_prog_data *wm_prog_data =
      (struct brw_wm_prog_data *) prog_data;

   fs_reg dest;
   if (nir_intrinsic_infos[instr->intrinsic].has_dest)
      dest = get_nir_dest(instr->dest);

   switch (instr->intrinsic) {
   case nir_intrinsic_load_front_face:
      bld.MOV(retype(dest, BRW_REGISTER_TYPE_D),
              *emit_frontfacing_interpolation());
      break;

   case nir_intrinsic_load_sample_pos: {
      fs_reg sample_pos = nir_system_values[SYSTEM_VALUE_SAMPLE_POS];
      assert(sample_pos.file != BAD_FILE);
      dest.type = sample_pos.type;
      bld.MOV(dest, sample_pos);
      bld.MOV(offset(dest, bld, 1), offset(sample_pos, bld, 1));
      break;
   }

   case nir_intrinsic_load_helper_invocation:
   case nir_intrinsic_load_sample_mask_in:
   case nir_intrinsic_load_sample_id: {
      gl_system_value sv = nir_system_value_from_intrinsic(instr->intrinsic);
      fs_reg val = nir_system_values[sv];
      assert(val.file != BAD_FILE);
      dest.type = val.type;
      bld.MOV(dest, val);
      break;
   }

   case nir_intrinsic_discard:
   case nir_intrinsic_discard_if: {
      /* We track our discarded pixels in f0.1.  By predicating on it, we can
       * update just the flag bits that aren't yet discarded.  If there's no
       * condition, we emit a CMP of g0 != g0, so all currently executing
       * channels will get turned off.
       */
      fs_inst *cmp;
      if (instr->intrinsic == nir_intrinsic_discard_if) {
         cmp = bld.CMP(bld.null_reg_f(), get_nir_src(instr->src[0]),
                       brw_imm_d(0), BRW_CONDITIONAL_Z);
      } else {
         fs_reg some_reg = fs_reg(retype(brw_vec8_grf(0, 0),
                                       BRW_REGISTER_TYPE_UW));
         cmp = bld.CMP(bld.null_reg_f(), some_reg, some_reg, BRW_CONDITIONAL_NZ);
      }
      cmp->predicate = BRW_PREDICATE_NORMAL;
      cmp->flag_subreg = 1;

      if (devinfo->gen >= 6) {
         emit_discard_jump();
      }
      break;
   }

   case nir_intrinsic_interp_var_at_centroid:
   case nir_intrinsic_interp_var_at_sample:
   case nir_intrinsic_interp_var_at_offset: {
      /* Handle ARB_gpu_shader5 interpolation intrinsics
       *
       * It's worth a quick word of explanation as to why we handle the full
       * variable-based interpolation intrinsic rather than a lowered version
       * with like we do for other inputs.  We have to do that because the way
       * we set up inputs doesn't allow us to use the already setup inputs for
       * interpolation.  At the beginning of the shader, we go through all of
       * the input variables and do the initial interpolation and put it in
       * the nir_inputs array based on its location as determined in
       * nir_lower_io.  If the input isn't used, dead code cleans up and
       * everything works fine.  However, when we get to the ARB_gpu_shader5
       * interpolation intrinsics, we need to reinterpolate the input
       * differently.  If we used an intrinsic that just had an index it would
       * only give us the offset into the nir_inputs array.  However, this is
       * useless because that value is post-interpolation and we need
       * pre-interpolation.  In order to get the actual location of the bits
       * we get from the vertex fetching hardware, we need the variable.
       */
      wm_prog_data->pulls_bary = true;

      fs_reg dst_xy = bld.vgrf(BRW_REGISTER_TYPE_F, 2);
      const glsl_interp_qualifier interpolation =
         (glsl_interp_qualifier) instr->variables[0]->var->data.interpolation;

      switch (instr->intrinsic) {
      case nir_intrinsic_interp_var_at_centroid:
         emit_pixel_interpolater_send(bld,
                                      FS_OPCODE_INTERPOLATE_AT_CENTROID,
                                      dst_xy,
                                      fs_reg(), /* src */
                                      brw_imm_ud(0u),
                                      interpolation);
         break;

      case nir_intrinsic_interp_var_at_sample: {
         nir_const_value *const_sample = nir_src_as_const_value(instr->src[0]);

         if (const_sample) {
            unsigned msg_data = const_sample->i[0] << 4;

            emit_pixel_interpolater_send(bld,
                                         FS_OPCODE_INTERPOLATE_AT_SAMPLE,
                                         dst_xy,
                                         fs_reg(), /* src */
                                         brw_imm_ud(msg_data),
                                         interpolation);
         } else {
            const fs_reg sample_src = retype(get_nir_src(instr->src[0]),
                                             BRW_REGISTER_TYPE_UD);

            if (nir_src_is_dynamically_uniform(instr->src[0])) {
               const fs_reg sample_id = bld.emit_uniformize(sample_src);
               const fs_reg msg_data = vgrf(glsl_type::uint_type);
               bld.exec_all().group(1, 0)
                  .SHL(msg_data, sample_id, brw_imm_ud(4u));
               emit_pixel_interpolater_send(bld,
                                            FS_OPCODE_INTERPOLATE_AT_SAMPLE,
                                            dst_xy,
                                            fs_reg(), /* src */
                                            msg_data,
                                            interpolation);
            } else {
               /* Make a loop that sends a message to the pixel interpolater
                * for the sample number in each live channel. If there are
                * multiple channels with the same sample number then these
                * will be handled simultaneously with a single interation of
                * the loop.
                */
               bld.emit(BRW_OPCODE_DO);

               /* Get the next live sample number into sample_id_reg */
               const fs_reg sample_id = bld.emit_uniformize(sample_src);

               /* Set the flag register so that we can perform the send
                * message on all channels that have the same sample number
                */
               bld.CMP(bld.null_reg_ud(),
                       sample_src, sample_id,
                       BRW_CONDITIONAL_EQ);
               const fs_reg msg_data = vgrf(glsl_type::uint_type);
               bld.exec_all().group(1, 0)
                  .SHL(msg_data, sample_id, brw_imm_ud(4u));
               fs_inst *inst =
                  emit_pixel_interpolater_send(bld,
                                               FS_OPCODE_INTERPOLATE_AT_SAMPLE,
                                               dst_xy,
                                               fs_reg(), /* src */
                                               msg_data,
                                               interpolation);
               set_predicate(BRW_PREDICATE_NORMAL, inst);

               /* Continue the loop if there are any live channels left */
               set_predicate_inv(BRW_PREDICATE_NORMAL,
                                 true, /* inverse */
                                 bld.emit(BRW_OPCODE_WHILE));
            }
         }

         break;
      }

      case nir_intrinsic_interp_var_at_offset: {
         nir_const_value *const_offset = nir_src_as_const_value(instr->src[0]);

         if (const_offset) {
            unsigned off_x = MIN2((int)(const_offset->f[0] * 16), 7) & 0xf;
            unsigned off_y = MIN2((int)(const_offset->f[1] * 16), 7) & 0xf;

            emit_pixel_interpolater_send(bld,
                                         FS_OPCODE_INTERPOLATE_AT_SHARED_OFFSET,
                                         dst_xy,
                                         fs_reg(), /* src */
                                         brw_imm_ud(off_x | (off_y << 4)),
                                         interpolation);
         } else {
            fs_reg src = vgrf(glsl_type::ivec2_type);
            fs_reg offset_src = retype(get_nir_src(instr->src[0]),
                                       BRW_REGISTER_TYPE_F);
            for (int i = 0; i < 2; i++) {
               fs_reg temp = vgrf(glsl_type::float_type);
               bld.MUL(temp, offset(offset_src, bld, i), brw_imm_f(16.0f));
               fs_reg itemp = vgrf(glsl_type::int_type);
               bld.MOV(itemp, temp);  /* float to int */

               /* Clamp the upper end of the range to +7/16.
                * ARB_gpu_shader5 requires that we support a maximum offset
                * of +0.5, which isn't representable in a S0.4 value -- if
                * we didn't clamp it, we'd end up with -8/16, which is the
                * opposite of what the shader author wanted.
                *
                * This is legal due to ARB_gpu_shader5's quantization
                * rules:
                *
                * "Not all values of <offset> may be supported; x and y
                * offsets may be rounded to fixed-point values with the
                * number of fraction bits given by the
                * implementation-dependent constant
                * FRAGMENT_INTERPOLATION_OFFSET_BITS"
                */
               set_condmod(BRW_CONDITIONAL_L,
                           bld.SEL(offset(src, bld, i), itemp, brw_imm_d(7)));
            }

            const enum opcode opcode = FS_OPCODE_INTERPOLATE_AT_PER_SLOT_OFFSET;
            emit_pixel_interpolater_send(bld,
                                         opcode,
                                         dst_xy,
                                         src,
                                         brw_imm_ud(0u),
                                         interpolation);
         }
         break;
      }

      default:
         unreachable("Invalid intrinsic");
      }

      for (unsigned j = 0; j < instr->num_components; j++) {
         fs_reg src = interp_reg(instr->variables[0]->var->data.location, j);
         src.type = dest.type;

         bld.emit(FS_OPCODE_LINTERP, dest, dst_xy, src);
         dest = offset(dest, bld, 1);
      }
      break;
   }
   default:
      nir_emit_intrinsic(bld, instr);
      break;
   }
}

void
fs_visitor::nir_emit_cs_intrinsic(const fs_builder &bld,
                                  nir_intrinsic_instr *instr)
{
   assert(stage == MESA_SHADER_COMPUTE);
   struct brw_cs_prog_data *cs_prog_data =
      (struct brw_cs_prog_data *) prog_data;

   fs_reg dest;
   if (nir_intrinsic_infos[instr->intrinsic].has_dest)
      dest = get_nir_dest(instr->dest);

   switch (instr->intrinsic) {
   case nir_intrinsic_barrier:
      emit_barrier();
      cs_prog_data->uses_barrier = true;
      break;

   case nir_intrinsic_load_local_invocation_id:
   case nir_intrinsic_load_work_group_id: {
      gl_system_value sv = nir_system_value_from_intrinsic(instr->intrinsic);
      fs_reg val = nir_system_values[sv];
      assert(val.file != BAD_FILE);
      dest.type = val.type;
      for (unsigned i = 0; i < 3; i++)
         bld.MOV(offset(dest, bld, i), offset(val, bld, i));
      break;
   }

   case nir_intrinsic_load_num_work_groups: {
      const unsigned surface =
         cs_prog_data->binding_table.work_groups_start;

      cs_prog_data->uses_num_work_groups = true;

      fs_reg surf_index = brw_imm_ud(surface);
      brw_mark_surface_used(prog_data, surface);

      /* Read the 3 GLuint components of gl_NumWorkGroups */
      for (unsigned i = 0; i < 3; i++) {
         fs_reg read_result =
            emit_untyped_read(bld, surf_index,
                              brw_imm_ud(i << 2),
                              1 /* dims */, 1 /* size */,
                              BRW_PREDICATE_NONE);
         read_result.type = dest.type;
         bld.MOV(dest, read_result);
         dest = offset(dest, bld, 1);
      }
      break;
   }

   case nir_intrinsic_shared_atomic_add:
      nir_emit_shared_atomic(bld, BRW_AOP_ADD, instr);
      break;
   case nir_intrinsic_shared_atomic_imin:
      nir_emit_shared_atomic(bld, BRW_AOP_IMIN, instr);
      break;
   case nir_intrinsic_shared_atomic_umin:
      nir_emit_shared_atomic(bld, BRW_AOP_UMIN, instr);
      break;
   case nir_intrinsic_shared_atomic_imax:
      nir_emit_shared_atomic(bld, BRW_AOP_IMAX, instr);
      break;
   case nir_intrinsic_shared_atomic_umax:
      nir_emit_shared_atomic(bld, BRW_AOP_UMAX, instr);
      break;
   case nir_intrinsic_shared_atomic_and:
      nir_emit_shared_atomic(bld, BRW_AOP_AND, instr);
      break;
   case nir_intrinsic_shared_atomic_or:
      nir_emit_shared_atomic(bld, BRW_AOP_OR, instr);
      break;
   case nir_intrinsic_shared_atomic_xor:
      nir_emit_shared_atomic(bld, BRW_AOP_XOR, instr);
      break;
   case nir_intrinsic_shared_atomic_exchange:
      nir_emit_shared_atomic(bld, BRW_AOP_MOV, instr);
      break;
   case nir_intrinsic_shared_atomic_comp_swap:
      nir_emit_shared_atomic(bld, BRW_AOP_CMPWR, instr);
      break;

   default:
      nir_emit_intrinsic(bld, instr);
      break;
   }
}

void
fs_visitor::nir_emit_intrinsic(const fs_builder &bld, nir_intrinsic_instr *instr)
{
   fs_reg dest;
   if (nir_intrinsic_infos[instr->intrinsic].has_dest)
      dest = get_nir_dest(instr->dest);

   switch (instr->intrinsic) {
   case nir_intrinsic_atomic_counter_inc:
   case nir_intrinsic_atomic_counter_dec:
   case nir_intrinsic_atomic_counter_read: {
      using namespace surface_access;

      /* Get the arguments of the atomic intrinsic. */
      const fs_reg offset = get_nir_src(instr->src[0]);
      const unsigned surface = (stage_prog_data->binding_table.abo_start +
                                instr->const_index[0]);
      fs_reg tmp;

      /* Emit a surface read or atomic op. */
      switch (instr->intrinsic) {
      case nir_intrinsic_atomic_counter_read:
         tmp = emit_untyped_read(bld, brw_imm_ud(surface), offset, 1, 1);
         break;

      case nir_intrinsic_atomic_counter_inc:
         tmp = emit_untyped_atomic(bld, brw_imm_ud(surface), offset, fs_reg(),
                                   fs_reg(), 1, 1, BRW_AOP_INC);
         break;

      case nir_intrinsic_atomic_counter_dec:
         tmp = emit_untyped_atomic(bld, brw_imm_ud(surface), offset, fs_reg(),
                                   fs_reg(), 1, 1, BRW_AOP_PREDEC);
         break;

      default:
         unreachable("Unreachable");
      }

      /* Assign the result. */
      bld.MOV(retype(dest, BRW_REGISTER_TYPE_UD), tmp);

      /* Mark the surface as used. */
      brw_mark_surface_used(stage_prog_data, surface);
      break;
   }

   case nir_intrinsic_image_load:
   case nir_intrinsic_image_store:
   case nir_intrinsic_image_atomic_add:
   case nir_intrinsic_image_atomic_min:
   case nir_intrinsic_image_atomic_max:
   case nir_intrinsic_image_atomic_and:
   case nir_intrinsic_image_atomic_or:
   case nir_intrinsic_image_atomic_xor:
   case nir_intrinsic_image_atomic_exchange:
   case nir_intrinsic_image_atomic_comp_swap: {
      using namespace image_access;

      /* Get the referenced image variable and type. */
      const nir_variable *var = instr->variables[0]->var;
      const glsl_type *type = var->type->without_array();
      const brw_reg_type base_type = get_image_base_type(type);

      /* Get some metadata from the image intrinsic. */
      const nir_intrinsic_info *info = &nir_intrinsic_infos[instr->intrinsic];
      const unsigned arr_dims = type->sampler_array ? 1 : 0;
      const unsigned surf_dims = type->coordinate_components() - arr_dims;
      const mesa_format format =
         (var->data.image.write_only ? MESA_FORMAT_NONE :
          _mesa_get_shader_image_format(var->data.image.format));

      /* Get the arguments of the image intrinsic. */
      const fs_reg image = get_nir_image_deref(instr->variables[0]);
      const fs_reg addr = retype(get_nir_src(instr->src[0]),
                                 BRW_REGISTER_TYPE_UD);
      const fs_reg src0 = (info->num_srcs >= 3 ?
                           retype(get_nir_src(instr->src[2]), base_type) :
                           fs_reg());
      const fs_reg src1 = (info->num_srcs >= 4 ?
                           retype(get_nir_src(instr->src[3]), base_type) :
                           fs_reg());
      fs_reg tmp;

      /* Emit an image load, store or atomic op. */
      if (instr->intrinsic == nir_intrinsic_image_load)
         tmp = emit_image_load(bld, image, addr, surf_dims, arr_dims, format);

      else if (instr->intrinsic == nir_intrinsic_image_store)
         emit_image_store(bld, image, addr, src0, surf_dims, arr_dims, format);

      else
         tmp = emit_image_atomic(bld, image, addr, src0, src1,
                                 surf_dims, arr_dims, info->dest_components,
                                 get_image_atomic_op(instr->intrinsic, type));

      /* Assign the result. */
      for (unsigned c = 0; c < info->dest_components; ++c)
         bld.MOV(offset(retype(dest, base_type), bld, c),
                 offset(tmp, bld, c));
      break;
   }

   case nir_intrinsic_memory_barrier_atomic_counter:
   case nir_intrinsic_memory_barrier_buffer:
   case nir_intrinsic_memory_barrier_image:
   case nir_intrinsic_memory_barrier: {
      const fs_reg tmp = bld.vgrf(BRW_REGISTER_TYPE_UD, 16 / dispatch_width);
      bld.emit(SHADER_OPCODE_MEMORY_FENCE, tmp)
         ->regs_written = 2;
      break;
   }

   case nir_intrinsic_group_memory_barrier:
   case nir_intrinsic_memory_barrier_shared:
      /* We treat these workgroup-level barriers as no-ops.  This should be
       * safe at present and as long as:
       *
       *  - Memory access instructions are not subsequently reordered by the
       *    compiler back-end.
       *
       *  - All threads from a given compute shader workgroup fit within a
       *    single subslice and therefore talk to the same HDC shared unit
       *    what supposedly guarantees ordering and coherency between threads
       *    from the same workgroup.  This may change in the future when we
       *    start splitting workgroups across multiple subslices.
       *
       *  - The context is not in fault-and-stream mode, which could cause
       *    memory transactions (including to SLM) prior to the barrier to be
       *    replayed after the barrier if a pagefault occurs.  This shouldn't
       *    be a problem up to and including SKL because fault-and-stream is
       *    not usable due to hardware issues, but that's likely to change in
       *    the future.
       */
      break;

   case nir_intrinsic_shader_clock: {
      /* We cannot do anything if there is an event, so ignore it for now */
      fs_reg shader_clock = get_timestamp(bld);
      const fs_reg srcs[] = { shader_clock.set_smear(0), shader_clock.set_smear(1) };

      bld.LOAD_PAYLOAD(dest, srcs, ARRAY_SIZE(srcs), 0);
      break;
d1462 1
a1462 1
                     brw_imm_d(1));
d1469 1
a1469 1
                     offset(size, bld, c), brw_imm_d(6));
d1479 54
a1532 3
   case nir_intrinsic_image_samples:
      /* The driver does not support multi-sampled images. */
      bld.MOV(retype(dest, BRW_REGISTER_TYPE_D), brw_imm_d(1));
d1534 1
d1536 3
d1540 1
a1540 2
      /* Offsets are in bytes but they should always be multiples of 4 */
      assert(instr->const_index[0] % 4 == 0);
d1542 3
a1544 7
      fs_reg src(UNIFORM, instr->const_index[0] / 4, dest.type);

      nir_const_value *const_offset = nir_src_as_const_value(instr->src[0]);
      if (const_offset) {
         /* Offsets are in bytes but they should always be multiples of 4 */
         assert(const_offset->u[0] % 4 == 0);
         src.reg_offset = const_offset->u[0] / 4;
d1546 2
a1547 1
         src.reladdr = new(mem_ctx) fs_reg(get_nir_src(instr->src[0]));
d1551 7
a1557 1
         bld.MOV(offset(dest, bld, j), offset(src, bld, j));
d1562 3
d1570 2
a1571 4
         const unsigned index = stage_prog_data->binding_table.ubo_start +
                                const_index->u[0];
         surf_index = brw_imm_ud(index);
         brw_mark_surface_used(prog_data, index);
d1579 1
a1579 1
                 brw_imm_ud(stage_prog_data->binding_table.ubo_start));
d1587 1
a1587 1
                               nir->info.num_ubos - 1);
d1590 6
a1595 4
      nir_const_value *const_offset = nir_src_as_const_value(instr->src[1]);
      if (const_offset == NULL) {
         fs_reg base_offset = retype(get_nir_src(instr->src[1]),
                                     BRW_REGISTER_TYPE_D);
d1597 1
d1600 1
a1600 1
                                       base_offset, i * 4);
d1605 1
a1605 1
         struct brw_reg const_offset_reg = brw_imm_ud(const_offset->u[0] & ~15);
d1610 1
a1610 1
            packed_consts.set_smear(const_offset->u[0] % 16 / 4 + i);
d1624 11
a1634 2
   case nir_intrinsic_load_ssbo: {
      assert(devinfo->gen >= 7);
d1636 2
a1637 28
      nir_const_value *const_uniform_block =
         nir_src_as_const_value(instr->src[0]);

      fs_reg surf_index;
      if (const_uniform_block) {
         unsigned index = stage_prog_data->binding_table.ssbo_start +
                          const_uniform_block->u[0];
         surf_index = brw_imm_ud(index);
         brw_mark_surface_used(prog_data, index);
      } else {
         surf_index = vgrf(glsl_type::uint_type);
         bld.ADD(surf_index, get_nir_src(instr->src[0]),
                 brw_imm_ud(stage_prog_data->binding_table.ssbo_start));

         /* Assume this may touch any UBO. It would be nice to provide
          * a tighter bound, but the array information is already lowered away.
          */
         brw_mark_surface_used(prog_data,
                               stage_prog_data->binding_table.ssbo_start +
                               nir->info.num_ssbos - 1);
      }

      fs_reg offset_reg;
      nir_const_value *const_offset = nir_src_as_const_value(instr->src[1]);
      if (const_offset) {
         offset_reg = brw_imm_ud(const_offset->u[0]);
      } else {
         offset_reg = get_nir_src(instr->src[1]);
a1638 10

      /* Read the vector */
      fs_reg read_result = emit_untyped_read(bld, surf_index, offset_reg,
                                             1 /* dims */,
                                             instr->num_components,
                                             BRW_PREDICATE_NONE);
      read_result.type = dest.type;
      for (int i = 0; i < instr->num_components; i++)
         bld.MOV(offset(dest, bld, i), offset(read_result, bld, i));

d1642 22
a1663 2
   case nir_intrinsic_load_shared: {
      assert(devinfo->gen >= 7);
d1665 1
a1665 1
      fs_reg surf_index = brw_imm_ud(GEN7_BTI_SLM);
d1667 1
a1667 11
      /* Get the offset to read from */
      fs_reg offset_reg;
      nir_const_value *const_offset = nir_src_as_const_value(instr->src[0]);
      if (const_offset) {
         offset_reg = brw_imm_ud(instr->const_index[0] + const_offset->u[0]);
      } else {
         offset_reg = vgrf(glsl_type::uint_type);
         bld.ADD(offset_reg,
                 retype(get_nir_src(instr->src[0]), BRW_REGISTER_TYPE_UD),
                 brw_imm_ud(instr->const_index[0]));
      }
d1669 7
a1675 8
      /* Read the vector */
      fs_reg read_result = emit_untyped_read(bld, surf_index, offset_reg,
                                             1 /* dims */,
                                             instr->num_components,
                                             BRW_PREDICATE_NONE);
      read_result.type = dest.type;
      for (int i = 0; i < instr->num_components; i++)
         bld.MOV(offset(dest, bld, i), offset(read_result, bld, i));
d1677 5
a1681 2
      break;
   }
d1683 9
a1691 2
   case nir_intrinsic_store_shared: {
      assert(devinfo->gen >= 7);
d1693 2
a1694 2
      /* Block index */
      fs_reg surf_index = brw_imm_ud(GEN7_BTI_SLM);
d1696 3
a1698 2
      /* Value */
      fs_reg val_reg = get_nir_src(instr->src[0]);
d1700 11
a1710 2
      /* Writemask */
      unsigned writemask = instr->const_index[1];
d1712 18
a1729 9
      /* Combine groups of consecutive enabled channels in one write
       * message. We use ffs to find the first enabled channel and then ffs on
       * the bit-inverse, down-shifted writemask to determine the length of
       * the block of enabled bits.
       */
      while (writemask) {
         unsigned first_component = ffs(writemask) - 1;
         unsigned length = ffs(~(writemask >> first_component)) - 1;
         fs_reg offset_reg;
d1731 3
a1733 9
         nir_const_value *const_offset = nir_src_as_const_value(instr->src[1]);
         if (const_offset) {
            offset_reg = brw_imm_ud(instr->const_index[0] + const_offset->u[0] +
                                    4 * first_component);
         } else {
            offset_reg = vgrf(glsl_type::uint_type);
            bld.ADD(offset_reg,
                    retype(get_nir_src(instr->src[1]), BRW_REGISTER_TYPE_UD),
                    brw_imm_ud(instr->const_index[0] + 4 * first_component));
d1735 1
a1735 10

         emit_untyped_write(bld, surf_index, offset_reg,
                            offset(val_reg, bld, first_component),
                            1 /* dims */, length,
                            BRW_PREDICATE_NONE);

         /* Clear the bits in the writemask that we just wrote, then try
          * again to see if more channels are left.
          */
         writemask &= (15 << (first_component + length));
d1738 2
a1739 10
      break;
   }

   case nir_intrinsic_load_input: {
      fs_reg src;
      if (stage == MESA_SHADER_VERTEX) {
         src = fs_reg(ATTR, instr->const_index[0], dest.type);
      } else {
         src = offset(retype(nir_inputs, dest.type), bld,
                      instr->const_index[0]);
d1742 5
a1746 3
      nir_const_value *const_offset = nir_src_as_const_value(instr->src[0]);
      assert(const_offset && "Indirect input loads not allowed");
      src = offset(src, bld, const_offset->u[0]);
d1749 2
a1750 4
         bld.MOV(offset(dest, bld, j), offset(src, bld, j));
      }
      break;
   }
d1752 2
a1753 57
   case nir_intrinsic_store_ssbo: {
      assert(devinfo->gen >= 7);

      /* Block index */
      fs_reg surf_index;
      nir_const_value *const_uniform_block =
         nir_src_as_const_value(instr->src[1]);
      if (const_uniform_block) {
         unsigned index = stage_prog_data->binding_table.ssbo_start +
                          const_uniform_block->u[0];
         surf_index = brw_imm_ud(index);
         brw_mark_surface_used(prog_data, index);
      } else {
         surf_index = vgrf(glsl_type::uint_type);
         bld.ADD(surf_index, get_nir_src(instr->src[1]),
                  brw_imm_ud(stage_prog_data->binding_table.ssbo_start));

         brw_mark_surface_used(prog_data,
                               stage_prog_data->binding_table.ssbo_start +
                               nir->info.num_ssbos - 1);
      }

      /* Value */
      fs_reg val_reg = get_nir_src(instr->src[0]);

      /* Writemask */
      unsigned writemask = instr->const_index[0];

      /* Combine groups of consecutive enabled channels in one write
       * message. We use ffs to find the first enabled channel and then ffs on
       * the bit-inverse, down-shifted writemask to determine the length of
       * the block of enabled bits.
       */
      while (writemask) {
         unsigned first_component = ffs(writemask) - 1;
         unsigned length = ffs(~(writemask >> first_component)) - 1;

         fs_reg offset_reg;
         nir_const_value *const_offset = nir_src_as_const_value(instr->src[2]);
         if (const_offset) {
            offset_reg = brw_imm_ud(const_offset->u[0] + 4 * first_component);
         } else {
            offset_reg = vgrf(glsl_type::uint_type);
            bld.ADD(offset_reg,
                    retype(get_nir_src(instr->src[2]), BRW_REGISTER_TYPE_UD),
                    brw_imm_ud(4 * first_component));
         }

         emit_untyped_write(bld, surf_index, offset_reg,
                            offset(val_reg, bld, first_component),
                            1 /* dims */, length,
                            BRW_PREDICATE_NONE);

         /* Clear the bits in the writemask that we just wrote, then try
          * again to see if more channels are left.
          */
         writemask &= (15 << (first_component + length));
d1758 3
d1763 1
a1763 7
      fs_reg new_dest = offset(retype(nir_outputs, src.type), bld,
                               instr->const_index[0]);

      nir_const_value *const_offset = nir_src_as_const_value(instr->src[1]);
      assert(const_offset && "Indirect output stores not allowed");
      new_dest = offset(new_dest, bld, const_offset->u[0]);

d1765 7
a1771 1
         bld.MOV(offset(new_dest, bld, j), offset(src, bld, j));
d1776 2
a1777 64
   case nir_intrinsic_ssbo_atomic_add:
      nir_emit_ssbo_atomic(bld, BRW_AOP_ADD, instr);
      break;
   case nir_intrinsic_ssbo_atomic_imin:
      nir_emit_ssbo_atomic(bld, BRW_AOP_IMIN, instr);
      break;
   case nir_intrinsic_ssbo_atomic_umin:
      nir_emit_ssbo_atomic(bld, BRW_AOP_UMIN, instr);
      break;
   case nir_intrinsic_ssbo_atomic_imax:
      nir_emit_ssbo_atomic(bld, BRW_AOP_IMAX, instr);
      break;
   case nir_intrinsic_ssbo_atomic_umax:
      nir_emit_ssbo_atomic(bld, BRW_AOP_UMAX, instr);
      break;
   case nir_intrinsic_ssbo_atomic_and:
      nir_emit_ssbo_atomic(bld, BRW_AOP_AND, instr);
      break;
   case nir_intrinsic_ssbo_atomic_or:
      nir_emit_ssbo_atomic(bld, BRW_AOP_OR, instr);
      break;
   case nir_intrinsic_ssbo_atomic_xor:
      nir_emit_ssbo_atomic(bld, BRW_AOP_XOR, instr);
      break;
   case nir_intrinsic_ssbo_atomic_exchange:
      nir_emit_ssbo_atomic(bld, BRW_AOP_MOV, instr);
      break;
   case nir_intrinsic_ssbo_atomic_comp_swap:
      nir_emit_ssbo_atomic(bld, BRW_AOP_CMPWR, instr);
      break;

   case nir_intrinsic_get_buffer_size: {
      nir_const_value *const_uniform_block = nir_src_as_const_value(instr->src[0]);
      unsigned ssbo_index = const_uniform_block ? const_uniform_block->u[0] : 0;
      int reg_width = dispatch_width / 8;

      /* Set LOD = 0 */
      fs_reg source = brw_imm_d(0);

      int mlen = 1 * reg_width;

      /* A resinfo's sampler message is used to get the buffer size.
       * The SIMD8's writeback message consists of four registers and
       * SIMD16's writeback message consists of 8 destination registers
       * (two per each component), although we are only interested on the
       * first component, where resinfo returns the buffer size for
       * SURFTYPE_BUFFER.
       */
      int regs_written = 4 * mlen;
      fs_reg src_payload = fs_reg(VGRF, alloc.allocate(mlen),
                                  BRW_REGISTER_TYPE_UD);
      bld.LOAD_PAYLOAD(src_payload, &source, 1, 0);
      fs_reg buffer_size = fs_reg(VGRF, alloc.allocate(regs_written),
                                  BRW_REGISTER_TYPE_UD);
      const unsigned index = prog_data->binding_table.ssbo_start + ssbo_index;
      fs_inst *inst = bld.emit(FS_OPCODE_GET_BUFFER_SIZE, buffer_size,
                               src_payload, brw_imm_ud(index));
      inst->header_size = 0;
      inst->mlen = mlen;
      inst->regs_written = regs_written;
      bld.emit(inst);
      bld.MOV(retype(dest, buffer_size.type), buffer_size);

      brw_mark_surface_used(prog_data, index);
a1778 1
   }
a1785 73
fs_visitor::nir_emit_ssbo_atomic(const fs_builder &bld,
                                 int op, nir_intrinsic_instr *instr)
{
   fs_reg dest;
   if (nir_intrinsic_infos[instr->intrinsic].has_dest)
      dest = get_nir_dest(instr->dest);

   fs_reg surface;
   nir_const_value *const_surface = nir_src_as_const_value(instr->src[0]);
   if (const_surface) {
      unsigned surf_index = stage_prog_data->binding_table.ssbo_start +
                            const_surface->u[0];
      surface = brw_imm_ud(surf_index);
      brw_mark_surface_used(prog_data, surf_index);
   } else {
      surface = vgrf(glsl_type::uint_type);
      bld.ADD(surface, get_nir_src(instr->src[0]),
              brw_imm_ud(stage_prog_data->binding_table.ssbo_start));

      /* Assume this may touch any SSBO. This is the same we do for other
       * UBO/SSBO accesses with non-constant surface.
       */
      brw_mark_surface_used(prog_data,
                            stage_prog_data->binding_table.ssbo_start +
                            nir->info.num_ssbos - 1);
   }

   fs_reg offset = get_nir_src(instr->src[1]);
   fs_reg data1 = get_nir_src(instr->src[2]);
   fs_reg data2;
   if (op == BRW_AOP_CMPWR)
      data2 = get_nir_src(instr->src[3]);

   /* Emit the actual atomic operation operation */

   fs_reg atomic_result =
      surface_access::emit_untyped_atomic(bld, surface, offset,
                                          data1, data2,
                                          1 /* dims */, 1 /* rsize */,
                                          op,
                                          BRW_PREDICATE_NONE);
   dest.type = atomic_result.type;
   bld.MOV(dest, atomic_result);
}

void
fs_visitor::nir_emit_shared_atomic(const fs_builder &bld,
                                   int op, nir_intrinsic_instr *instr)
{
   fs_reg dest;
   if (nir_intrinsic_infos[instr->intrinsic].has_dest)
      dest = get_nir_dest(instr->dest);

   fs_reg surface = brw_imm_ud(GEN7_BTI_SLM);
   fs_reg offset = get_nir_src(instr->src[0]);
   fs_reg data1 = get_nir_src(instr->src[1]);
   fs_reg data2;
   if (op == BRW_AOP_CMPWR)
      data2 = get_nir_src(instr->src[2]);

   /* Emit the actual atomic operation operation */

   fs_reg atomic_result =
      surface_access::emit_untyped_atomic(bld, surface, offset,
                                          data1, data2,
                                          1 /* dims */, 1 /* rsize */,
                                          op,
                                          BRW_PREDICATE_NONE);
   dest.type = atomic_result.type;
   bld.MOV(dest, atomic_result);
}

void
a1787 1
   unsigned texture = instr->texture_index;
d1789 7
a1795 2
   fs_reg texture_reg(brw_imm_ud(texture));
   fs_reg sampler_reg(brw_imm_ud(sampler));
d1799 2
d1805 1
a1821 1
         case nir_texop_samples_identical:
d1852 6
a1857 9

      case nir_tex_src_offset: {
         nir_const_value *const_offset =
            nir_src_as_const_value(instr->src[i].src);
         if (const_offset) {
            tex_offset = brw_imm_ud(brw_texture_offset(const_offset->i, 3));
         } else {
            tex_offset = retype(src, BRW_REGISTER_TYPE_D);
         }
a1858 2
      }

d1862 3
a1864 3
      case nir_tex_src_texture_offset: {
         /* Figure out the highest possible texture index and mark it as used */
         uint32_t max_used = texture + instr->texture_array_size - 1;
a1872 8
         texture_reg = vgrf(glsl_type::uint_type);
         bld.ADD(texture_reg, src, brw_imm_ud(texture));
         texture_reg = bld.emit_uniformize(texture_reg);
         break;
      }

      case nir_tex_src_sampler_offset: {
         /* Emit code to evaluate the actual indexing expression */
d1874 1
a1874 1
         bld.ADD(sampler_reg, src, brw_imm_ud(sampler));
d1884 1
a1884 2
   if (instr->op == nir_texop_txf_ms ||
       instr->op == nir_texop_samples_identical) {
d1886 2
a1887 2
          key_tex->compressed_multisample_layout_mask & (1 << texture)) {
         mcs = emit_mcs_fetch(coordinate, instr->coord_components, texture_reg);
d1889 9
a1897 1
         mcs = brw_imm_ud(0u);
a1919 17
   case nir_texop_texture_samples: {
      fs_reg dst = retype(get_nir_dest(instr->dest), BRW_REGISTER_TYPE_D);

      fs_reg tmp = bld.vgrf(BRW_REGISTER_TYPE_D, 4);
      fs_inst *inst = bld.emit(SHADER_OPCODE_SAMPLEINFO, tmp,
                               bld.vgrf(BRW_REGISTER_TYPE_D, 1),
                               texture_reg, texture_reg);
      inst->mlen = 1;
      inst->header_size = 1;
      inst->base_mrf = -1;
      inst->regs_written = 4 * (dispatch_width / 8);

      /* Pick off the one component we care about */
      bld.MOV(dst, tmp);
      return;
   }
   case nir_texop_samples_identical: op = ir_samples_identical; break;
d1926 2
a1927 2
                tex_offset, mcs, gather_component, is_cube_array,
                texture, texture_reg, sampler, sampler_reg);
@


1.1.1.4
log
@Import Mesa 13.0.2
@
text
@d25 1
d40 1
d46 1
a46 1
   nir_foreach_function(function, nir) {
d54 61
d117 3
a119 2
   if (stage == MESA_SHADER_TESS_CTRL || stage == MESA_SHADER_FRAGMENT)
      return;
d122 49
a170 5
      const unsigned vec4s = type_size_vec4(var->type);
      fs_reg reg = bld.vgrf(BRW_REGISTER_TYPE_F, 4 * vec4s);
      for (unsigned i = 0; i < vec4s; i++) {
         if (outputs[var->data.driver_location + i].file == BAD_FILE)
            outputs[var->data.driver_location + i] = offset(reg, bld, 4 * i);
d178 1
a178 1
   if (dispatch_width != min_dispatch_width)
d182 9
d194 1
a194 1
emit_system_values_block(nir_block *block, fs_visitor *v)
d196 1
d199 1
a199 1
   nir_foreach_instr(instr, block) {
a243 2
         if (v->stage == MESA_SHADER_TESS_CTRL)
            break;
d274 9
a282 1
            *reg = *v->emit_samplemaskin_setup();
d315 1
a315 1
                     brw_imm_v(0x76543210));
d359 1
a359 1
   nir_foreach_function(function, nir) {
d362 1
a362 3
      nir_foreach_block(block, function->impl) {
         emit_system_values_block(block, this);
      }
d378 1
a378 3
      const brw_reg_type reg_type =
         reg->bit_size == 32 ? BRW_REGISTER_TYPE_F : BRW_REGISTER_TYPE_DF;
      nir_locals[reg->index] = bld.vgrf(reg_type, size);
d445 1
a445 1
   nir_foreach_instr(instr, block) {
a464 3
      case MESA_SHADER_TESS_CTRL:
         nir_emit_tcs_intrinsic(abld, nir_instr_as_intrinsic(instr));
         break;
d491 1
a491 4
      /* We create a new VGRF for undefs on every use (by handling
       * them in get_nir_src()), rather than for each definition.
       * This helps register coalescing eliminate MOVs from undef.
       */
a502 41
/**
 * Recognizes a parent instruction of nir_op_extract_* and changes the type to
 * match instr.
 */
bool
fs_visitor::optimize_extract_to_float(nir_alu_instr *instr,
                                      const fs_reg &result)
{
   if (!instr->src[0].src.is_ssa ||
       !instr->src[0].src.ssa->parent_instr)
      return false;

   if (instr->src[0].src.ssa->parent_instr->type != nir_instr_type_alu)
      return false;

   nir_alu_instr *src0 =
      nir_instr_as_alu(instr->src[0].src.ssa->parent_instr);

   if (src0->op != nir_op_extract_u8 && src0->op != nir_op_extract_u16 &&
       src0->op != nir_op_extract_i8 && src0->op != nir_op_extract_i16)
      return false;

   nir_const_value *element = nir_src_as_const_value(src0->src[1].src);
   assert(element != NULL);

   /* Element type to extract.*/
   const brw_reg_type type = brw_int_type(
      src0->op == nir_op_extract_u16 || src0->op == nir_op_extract_i16 ? 2 : 1,
      src0->op == nir_op_extract_i16 || src0->op == nir_op_extract_i8);

   fs_reg op0 = get_nir_src(src0->src[0].src);
   op0.type = brw_type_for_nir_type(
      (nir_alu_type)(nir_op_infos[src0->op].input_types[0] |
                     nir_src_bit_size(src0->src[0].src)));
   op0 = offset(op0, bld, src0->src[0].swizzle[0]);

   set_saturate(instr->dest.saturate,
                bld.MOV(result, subscript(op0, type, element->u32[0])));
   return true;
}

d518 1
a518 1
   if (!value1 || fabsf(value1->f32[0]) != 1.0f)
d522 1
a522 1
   if (!value2 || fabsf(value2->f32[0]) != 1.0f)
d542 1
a542 1
      if (value1->f32[0] == -1.0f) {
d546 9
a554 2
      bld.OR(subscript(tmp, BRW_REGISTER_TYPE_W, 1),
             g0, brw_imm_uw(0x3f80));
d570 1
a570 1
      if (value1->f32[0] == -1.0f) {
a580 47
static void
emit_find_msb_using_lzd(const fs_builder &bld,
                        const fs_reg &result,
                        const fs_reg &src,
                        bool is_signed)
{
   fs_inst *inst;
   fs_reg temp = src;

   if (is_signed) {
      /* LZD of an absolute value source almost always does the right
       * thing.  There are two problem values:
       *
       * * 0x80000000.  Since abs(0x80000000) == 0x80000000, LZD returns
       *   0.  However, findMSB(int(0x80000000)) == 30.
       *
       * * 0xffffffff.  Since abs(0xffffffff) == 1, LZD returns
       *   31.  Section 8.8 (Integer Functions) of the GLSL 4.50 spec says:
       *
       *    For a value of zero or negative one, -1 will be returned.
       *
       * * Negative powers of two.  LZD(abs(-(1<<x))) returns x, but
       *   findMSB(-(1<<x)) should return x-1.
       *
       * For all negative number cases, including 0x80000000 and
       * 0xffffffff, the correct value is obtained from LZD if instead of
       * negating the (already negative) value the logical-not is used.  A
       * conditonal logical-not can be achieved in two instructions.
       */
      temp = bld.vgrf(BRW_REGISTER_TYPE_D);

      bld.ASR(temp, src, brw_imm_d(31));
      bld.XOR(temp, temp, src);
   }

   bld.LZD(retype(result, BRW_REGISTER_TYPE_UD),
           retype(temp, BRW_REGISTER_TYPE_UD));

   /* LZD counts from the MSB side, while GLSL's findMSB() wants the count
    * from the LSB side. Subtract the result from 31 to convert the MSB
    * count into an LSB count.  If no bits are set, LZD will return 32.
    * 31-32 = -1, which is exactly what findMSB() is supposed to return.
    */
   inst = bld.ADD(result, retype(result, BRW_REGISTER_TYPE_D), brw_imm_d(31));
   inst->src[0].negate = true;
}

d588 1
a588 3
   result.type = brw_type_for_nir_type(
      (nir_alu_type)(nir_op_infos[instr->op].output_type |
                     nir_dest_bit_size(instr->dest.dest)));
d593 1
a593 3
      op[i].type = brw_type_for_nir_type(
         (nir_alu_type)(nir_op_infos[instr->op].input_types[i] |
                        nir_src_bit_size(instr->src[i].src)));
a673 34
      if (optimize_extract_to_float(instr, result))
         return;
      inst = bld.MOV(result, op[0]);
      inst->saturate = instr->dest.saturate;
      break;

   case nir_op_f2d:
   case nir_op_i2d:
   case nir_op_u2d:
      /* CHV PRM, vol07, 3D Media GPGPU Engine, Register Region Restrictions:
       *
       *    "When source or destination is 64b (...), regioning in Align1
       *     must follow these rules:
       *
       *     1. Source and destination horizontal stride must be aligned to
       *        the same qword.
       *     (...)"
       *
       * This means that 32-bit to 64-bit conversions need to have the 32-bit
       * data elements aligned to 64-bit. This restriction does not apply to
       * BDW and later.
       */
      if (devinfo->is_cherryview || devinfo->is_broxton) {
         fs_reg tmp = bld.vgrf(result.type, 1);
         tmp = subscript(tmp, op[0].type, 0);
         inst = bld.MOV(tmp, op[0]);
         inst = bld.MOV(result, tmp);
         inst->saturate = instr->dest.saturate;
         break;
      }
      /* fallthrough */
   case nir_op_d2f:
   case nir_op_d2i:
   case nir_op_d2u:
d684 11
a694 7
      if (type_sz(op[0].type) < 8) {
         /* AND(val, 0x80000000) gives the sign bit.
          *
          * Predicated OR ORs 1.0 (0x3f800000) with the sign bit if val is not
          * zero.
          */
         bld.CMP(bld.null_reg_f(), op[0], brw_imm_f(0.0f), BRW_CONDITIONAL_NZ);
d696 5
a700 68
         fs_reg result_int = retype(result, BRW_REGISTER_TYPE_UD);
         op[0].type = BRW_REGISTER_TYPE_UD;
         result.type = BRW_REGISTER_TYPE_UD;
         bld.AND(result_int, op[0], brw_imm_ud(0x80000000u));

         inst = bld.OR(result_int, result_int, brw_imm_ud(0x3f800000u));
         inst->predicate = BRW_PREDICATE_NORMAL;
         if (instr->dest.saturate) {
            inst = bld.MOV(result, result);
            inst->saturate = true;
         }
      } else {
         /* For doubles we do the same but we need to consider:
          *
          * - 2-src instructions can't operate with 64-bit immediates
          * - The sign is encoded in the high 32-bit of each DF
          * - CMP with DF requires special handling in SIMD16
          * - We need to produce a DF result.
          */

         /* 2-src instructions can't have 64-bit immediates, so put 0.0 in
          * a register and compare with that.
          */
         fs_reg tmp = vgrf(glsl_type::double_type);
         bld.MOV(tmp, setup_imm_df(bld, 0.0));

         /* A direct DF CMP using the flag register (null dst) won't work in
          * SIMD16 because the CMP will be split in two by lower_simd_width,
          * resulting in two CMP instructions with the same dst (NULL),
          * leading to dead code elimination of the first one. In SIMD8,
          * however, there is no need to split the CMP and we can save some
          * work.
          */
         fs_reg dst_tmp = vgrf(glsl_type::double_type);
         bld.CMP(dst_tmp, op[0], tmp, BRW_CONDITIONAL_NZ);

         /* In SIMD16 we want to avoid using a NULL dst register with DF CMP,
          * so we store the result of the comparison in a vgrf instead and
          * then we generate a UD comparison from that that won't have to
          * be split by lower_simd_width. This is what NIR does to handle
          * double comparisons in the general case.
          */
         if (bld.dispatch_width() == 16 ) {
            fs_reg dst_tmp_ud = retype(dst_tmp, BRW_REGISTER_TYPE_UD);
            bld.MOV(dst_tmp_ud, subscript(dst_tmp, BRW_REGISTER_TYPE_UD, 0));
            bld.CMP(bld.null_reg_ud(),
                    dst_tmp_ud, brw_imm_ud(0), BRW_CONDITIONAL_NZ);
         }

         /* Get the high 32-bit of each double component where the sign is */
         fs_reg result_int = retype(result, BRW_REGISTER_TYPE_UD);
         bld.MOV(result_int, subscript(op[0], BRW_REGISTER_TYPE_UD, 1));

         /* Get the sign bit */
         bld.AND(result_int, result_int, brw_imm_ud(0x80000000u));

         /* Add 1.0 to the sign, predicated to skip the case of op[0] == 0.0 */
         inst = bld.OR(result_int, result_int, brw_imm_ud(0x3f800000u));
         inst->predicate = BRW_PREDICATE_NORMAL;

         /* Convert from 32-bit float to 64-bit double */
         result.type = BRW_REGISTER_TYPE_DF;
         inst = bld.MOV(result, retype(result_int, BRW_REGISTER_TYPE_F));

         if (instr->dest.saturate) {
            inst = bld.MOV(result, result);
            inst->saturate = true;
         }
a709 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
d759 2
a760 1
         inst = bld.emit(FS_OPCODE_DDY_FINE, result, op[0]);
d762 2
a763 1
         inst = bld.emit(FS_OPCODE_DDY_COARSE, result, op[0]);
d768 2
a769 1
      inst = bld.emit(FS_OPCODE_DDY_FINE, result, op[0]);
d773 2
a774 1
      inst = bld.emit(FS_OPCODE_DDY_COARSE, result, op[0]);
d778 1
a779 2
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
   case nir_op_fadd:
a789 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a794 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a799 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a809 11
   case nir_op_irem:
      /* According to the sign table for INT DIV in the Ivy Bridge PRM, it
       * appears that our hardware just does the right thing for signed
       * remainder.
       */
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
      bld.emit(SHADER_OPCODE_INT_REMAINDER, result, op[0], op[1]);
      break;

   case nir_op_imod: {
      /* Get a regular C-style remainder.  If a % b == 0, set the predicate. */
a810 25

      /* Math instructions don't support conditional mod */
      inst = bld.MOV(bld.null_reg_d(), result);
      inst->conditional_mod = BRW_CONDITIONAL_NZ;

      /* Now, we need to determine if signs of the sources are different.
       * When we XOR the sources, the top bit is 0 if they are the same and 1
       * if they are different.  We can then use a conditional modifier to
       * turn that into a predicate.  This leads us to an XOR.l instruction.
       *
       * Technically, according to the PRM, you're not allowed to use .l on a
       * XOR instruction.  However, emperical experiments and Curro's reading
       * of the simulator source both indicate that it's safe.
       */
      fs_reg tmp = bld.vgrf(BRW_REGISTER_TYPE_D);
      inst = bld.XOR(tmp, op[0], op[1]);
      inst->predicate = BRW_PREDICATE_NORMAL;
      inst->conditional_mod = BRW_CONDITIONAL_L;

      /* If the result of the initial remainder operation is non-zero and the
       * two sources have different signs, add in a copy of op[1] to get the
       * final integer modulus value.
       */
      inst = bld.ADD(result, result, op[1]);
      inst->predicate = BRW_PREDICATE_NORMAL;
a811 1
   }
a813 31
   case nir_op_fge:
   case nir_op_feq:
   case nir_op_fne: {
      fs_reg dest = result;
      if (nir_src_bit_size(instr->src[0].src) > 32) {
         dest = bld.vgrf(BRW_REGISTER_TYPE_DF, 1);
      }
      brw_conditional_mod cond;
      switch (instr->op) {
      case nir_op_flt:
         cond = BRW_CONDITIONAL_L;
         break;
      case nir_op_fge:
         cond = BRW_CONDITIONAL_GE;
         break;
      case nir_op_feq:
         cond = BRW_CONDITIONAL_Z;
         break;
      case nir_op_fne:
         cond = BRW_CONDITIONAL_NZ;
         break;
      default:
         unreachable("bad opcode");
      }
      bld.CMP(dest, op[0], op[1], cond);
      if (nir_src_bit_size(instr->src[0].src) > 32) {
         bld.MOV(result, subscript(dest, BRW_REGISTER_TYPE_UD, 0));
      }
      break;
   }

a815 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
d819 1
a821 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
d825 1
a826 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
d830 1
a831 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a835 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a841 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a848 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a855 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a918 13
   case nir_op_d2b: {
      /* two-argument instructions can't take 64-bit immediates */
      fs_reg zero = vgrf(glsl_type::double_type);
      bld.MOV(zero, setup_imm_df(bld, 0.0));
      /* A SIMD16 execution needs to be split in two instructions, so use
       * a vgrf instead of the flag register as dst so instruction splitting
       * works
       */
      fs_reg tmp = vgrf(glsl_type::double_type);
      bld.CMP(tmp, op[0], zero, BRW_CONDITIONAL_NZ);
      bld.MOV(result, subscript(tmp, BRW_REGISTER_TYPE_UD, 0));
      break;
   }
d950 1
a950 28
   case nir_op_fquantize2f16: {
      fs_reg tmp16 = bld.vgrf(BRW_REGISTER_TYPE_D);
      fs_reg tmp32 = bld.vgrf(BRW_REGISTER_TYPE_F);
      fs_reg zero = bld.vgrf(BRW_REGISTER_TYPE_F);

      /* The destination stride must be at least as big as the source stride. */
      tmp16.type = BRW_REGISTER_TYPE_W;
      tmp16.stride = 2;

      /* Check for denormal */
      fs_reg abs_src0 = op[0];
      abs_src0.abs = true;
      bld.CMP(bld.null_reg_f(), abs_src0, brw_imm_f(ldexpf(1.0, -14)),
              BRW_CONDITIONAL_L);
      /* Get the appropriately signed zero */
      bld.AND(retype(zero, BRW_REGISTER_TYPE_UD),
              retype(op[0], BRW_REGISTER_TYPE_UD),
              brw_imm_ud(0x80000000));
      /* Do the actual F32 -> F16 -> F32 conversion */
      bld.emit(BRW_OPCODE_F32TO16, tmp16, op[0]);
      bld.emit(BRW_OPCODE_F16TO32, tmp32, tmp16);
      /* Select that or zero based on normal status */
      inst = bld.SEL(result, zero, tmp32);
      inst->predicate = BRW_PREDICATE_NORMAL;
      inst->saturate = instr->dest.saturate;
      break;
   }

a952 2
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
   case nir_op_fmin:
d957 1
a959 2
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
   case nir_op_fmax:
a984 63
   case nir_op_pack_double_2x32_split:
      /* Optimize the common case where we are re-packing a double with
       * the result of a previous double unpack. In this case we can take the
       * 32-bit value to use in the re-pack from the original double and bypass
       * the unpack operation.
       */
      for (int i = 0; i < 2; i++) {
         if (instr->src[i].src.is_ssa)
            continue;

         const nir_instr *parent_instr = instr->src[i].src.ssa->parent_instr;
         if (parent_instr->type == nir_instr_type_alu)
            continue;

         const nir_alu_instr *alu_parent = nir_instr_as_alu(parent_instr);
         if (alu_parent->op == nir_op_unpack_double_2x32_split_x ||
             alu_parent->op == nir_op_unpack_double_2x32_split_y)
            continue;

         if (!alu_parent->src[0].src.is_ssa)
            continue;

         op[i] = get_nir_src(alu_parent->src[0].src);
         op[i] = offset(retype(op[i], BRW_REGISTER_TYPE_DF), bld,
                        alu_parent->src[0].swizzle[channel]);
         if (alu_parent->op == nir_op_unpack_double_2x32_split_y)
            op[i] = subscript(op[i], BRW_REGISTER_TYPE_UD, 1);
         else
            op[i] = subscript(op[i], BRW_REGISTER_TYPE_UD, 0);
      }
      bld.emit(FS_OPCODE_PACK, result, op[0], op[1]);
      break;

   case nir_op_unpack_double_2x32_split_x:
   case nir_op_unpack_double_2x32_split_y: {
      /* Optimize the common case where we are unpacking from a double we have
       * previously packed. In this case we can just bypass the pack operation
       * and source directly from its arguments.
       */
      unsigned index = (instr->op == nir_op_unpack_double_2x32_split_x) ? 0 : 1;
      if (instr->src[0].src.is_ssa) {
         nir_instr *parent_instr = instr->src[0].src.ssa->parent_instr;
         if (parent_instr->type == nir_instr_type_alu) {
            nir_alu_instr *alu_parent = nir_instr_as_alu(parent_instr);
            if (alu_parent->op == nir_op_pack_double_2x32_split &&
                alu_parent->src[index].src.is_ssa) {
               op[0] = retype(get_nir_src(alu_parent->src[index].src),
                              BRW_REGISTER_TYPE_UD);
               op[0] =
                  offset(op[0], bld, alu_parent->src[index].swizzle[channel]);
               bld.MOV(result, op[0]);
               break;
            }
         }
      }

      if (instr->op == nir_op_unpack_double_2x32_split_x)
         bld.MOV(result, subscript(op[0], BRW_REGISTER_TYPE_UD, 0));
      else
         bld.MOV(result, subscript(op[0], BRW_REGISTER_TYPE_UD, 1));
      break;
   }

a990 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a994 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
d998 1
a998 6
   case nir_op_ufind_msb: {
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
      emit_find_msb_using_lzd(bld, result, op[0], false);
      break;
   }

d1000 1
a1000 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
d1002 5
a1006 4
      if (devinfo->gen < 7) {
         emit_find_msb_using_lzd(bld, result, op[0], true);
      } else {
         bld.FBH(retype(result, BRW_REGISTER_TYPE_UD), op[0]);
d1008 3
a1010 11
         /* FBH counts from the MSB side, while GLSL's findMSB() wants the
          * count from the LSB side. If FBH didn't return an error
          * (0xFFFFFFFF), then subtract the result from 31 to convert the MSB
          * count into an LSB count.
          */
         bld.CMP(bld.null_reg_d(), result, brw_imm_d(-1), BRW_CONDITIONAL_NZ);

         inst = bld.ADD(result, result, brw_imm_d(31));
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->src[0].negate = true;
      }
d1015 1
a1015 22
      assert(nir_dest_bit_size(instr->dest.dest) < 64);

      if (devinfo->gen < 7) {
         fs_reg temp = vgrf(glsl_type::int_type);

         /* (x & -x) generates a value that consists of only the LSB of x.
          * For all powers of 2, findMSB(y) == findLSB(y).
          */
         fs_reg src = retype(op[0], BRW_REGISTER_TYPE_D);
         fs_reg negated_src = src;

         /* One must be negated, and the other must be non-negated.  It
          * doesn't matter which is which.
          */
         negated_src.negate = true;
         src.negate = false;

         bld.AND(temp, src, negated_src);
         emit_find_msb_using_lzd(bld, result, temp, false);
      } else {
         bld.FBL(result, op[0]);
      }
a1022 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a1025 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a1028 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a1035 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a1038 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a1041 1
      assert(nir_dest_bit_size(instr->dest.dest) < 64);
a1069 1
      const brw_reg_type type = brw_int_type(1, instr->op == nir_op_extract_i8);
d1071 2
a1072 2
      assert(byte != NULL);
      bld.MOV(result, subscript(op[0], type, byte->u32[0]));
a1077 1
      const brw_reg_type type = brw_int_type(2, instr->op == nir_op_extract_i16);
d1079 2
a1080 2
      assert(word != NULL);
      bld.MOV(result, subscript(op[0], type, word->u32[0]));
d1104 1
a1104 9
   const brw_reg_type reg_type =
      instr->def.bit_size == 32 ? BRW_REGISTER_TYPE_D : BRW_REGISTER_TYPE_DF;
   fs_reg reg = bld.vgrf(reg_type, instr->def.num_components);

   switch (instr->def.bit_size) {
   case 32:
      for (unsigned i = 0; i < instr->def.num_components; i++)
         bld.MOV(offset(reg, bld, i), brw_imm_d(instr->value.i32[i]));
      break;
d1106 2
a1107 5
   case 64:
      for (unsigned i = 0; i < instr->def.num_components; i++)
         bld.MOV(offset(reg, bld, i),
                 setup_imm_df(bld, instr->value.f64[i]));
      break;
d1109 2
a1110 3
   default:
      unreachable("Invalid bit size");
   }
d1112 5
a1116 1
   nir_ssa_values[instr->def.index] = reg;
d1120 1
a1120 1
fs_visitor::get_nir_src(const nir_src &src)
d1124 1
a1124 7
      if (src.ssa->parent_instr->type == nir_instr_type_ssa_undef) {
         const brw_reg_type reg_type = src.ssa->bit_size == 32 ?
            BRW_REGISTER_TYPE_D : BRW_REGISTER_TYPE_DF;
         reg = bld.vgrf(reg_type, src.ssa->num_components);
      } else {
         reg = nir_ssa_values[src.ssa->index];
      }
a1138 10
/**
 * Return an IMM for constants; otherwise call get_nir_src() as normal.
 */
fs_reg
fs_visitor::get_nir_src_imm(const nir_src &src)
{
   nir_const_value *val = nir_src_as_const_value(src);
   return val ? fs_reg(brw_imm_d(val->i32[0])) : get_nir_src(src);
}

d1140 1
a1140 1
fs_visitor::get_nir_dest(const nir_dest &dest)
d1143 2
a1144 4
      const brw_reg_type reg_type =
         dest.ssa.bit_size == 32 ? BRW_REGISTER_TYPE_F : BRW_REGISTER_TYPE_DF;
      nir_ssa_values[dest.ssa.index] =
         bld.vgrf(reg_type, dest.ssa.num_components);
a1158 2
   fs_reg indirect;
   unsigned indirect_max = 0;
d1170 1
a1170 1
         fs_reg tmp = vgrf(glsl_type::uint_type);
d1172 15
a1186 13
         /* Accessing an invalid surface index with the dataport can result
          * in a hang.  According to the spec "if the index used to
          * select an individual element is negative or greater than or
          * equal to the size of the array, the results of the operation
          * are undefined but may not lead to termination" -- which is one
          * of the possible outcomes of the hang.  Clamp the index to
          * prevent access outside of the array bounds.
          */
         bld.emit_minmax(tmp, retype(get_nir_src(deref_array->indirect),
                                     BRW_REGISTER_TYPE_UD),
                         brw_imm_ud(size - base - 1), BRW_CONDITIONAL_L);

         indirect_max += element_size * (tail->type->length - 1);
d1189 4
a1192 5
         if (indirect.file == BAD_FILE) {
            indirect = tmp;
         } else {
            bld.ADD(indirect, indirect, tmp);
         }
d1196 1
a1196 14
   if (indirect.file == BAD_FILE) {
      return image;
   } else {
      /* Emit a pile of MOVs to load the uniform into a temporary.  The
       * dead-code elimination pass will get rid of what we don't use.
       */
      fs_reg tmp = bld.vgrf(BRW_REGISTER_TYPE_UD, BRW_IMAGE_PARAM_SIZE);
      for (unsigned j = 0; j < BRW_IMAGE_PARAM_SIZE; j++) {
         bld.emit(SHADER_OPCODE_MOV_INDIRECT,
                  offset(tmp, bld, j), offset(image, bld, j),
                  indirect, brw_imm_ud((indirect_max + 1) * 4));
      }
      return tmp;
   }
d1272 1
a1272 1
                             glsl_interp_mode interpolation)
a1273 2
   struct brw_wm_prog_data *wm_prog_data =
      brw_wm_prog_data(bld.shader->stage_prog_data);
d1290 2
a1291 4
   inst->size_written = 2 * dst.component_size(inst->exec_size);
   inst->pi_noperspective = interpolation == INTERP_MODE_NOPERSPECTIVE;

   wm_prog_data->pulls_bary = true;
d1317 2
a1318 4
   struct brw_gs_prog_data *gs_prog_data = brw_gs_prog_data(prog_data);

   if (gs_compile->control_data_header_size_bits == 0)
      return;
d1376 2
a1377 1
   struct brw_gs_prog_data *gs_prog_data = brw_gs_prog_data(prog_data);
d1433 1
a1433 1
         util_last_bit(gs_compile->control_data_bits_per_vertex);
d1532 2
a1533 1
   struct brw_gs_prog_data *gs_prog_data = brw_gs_prog_data(prog_data);
d1628 1
a1628 2
                               unsigned num_components,
                               unsigned first_component)
d1630 1
a1630 1
   struct brw_gs_prog_data *gs_prog_data = brw_gs_prog_data(prog_data);
d1642 4
a1645 6
   /* TODO: figure out push input layout for invocations == 1 */
   if (gs_prog_data->invocations == 1 &&
       offset_const != NULL && vertex_const != NULL &&
       4 * (base_offset + offset_const->u32[0]) < push_reg_count) {
      int imm_offset = (base_offset + offset_const->u32[0]) * 4 +
                       vertex_const->u32[0] * push_reg_count;
d1649 1
d1654 1
a1654 1
                    fs_reg(ATTR, imm_offset + i + first_component, dst.type));
d1657 3
a1659 2
      return;
   }
d1661 2
a1662 2
   /* Resort to the pull model.  Ensure the VUE handles are provided. */
   gs_prog_data->base.include_vue_handles = true;
a1663 4
   unsigned first_icp_handle = gs_prog_data->include_primitive_id ? 3 : 2;
   fs_reg icp_handle = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);

   if (gs_prog_data->invocations == 1) {
d1667 1
a1667 1
            retype(brw_vec8_grf(first_icp_handle + vertex_const->i32[0], 0),
d1685 1
a1705 2
   } else {
      assert(gs_prog_data->invocations > 1);
d1707 1
a1707 49
      if (vertex_const) {
         assert(devinfo->gen >= 9 || vertex_const->i32[0] <= 5);
         bld.MOV(icp_handle,
                 retype(brw_vec1_grf(first_icp_handle +
                                     vertex_const->i32[0] / 8,
                                     vertex_const->i32[0] % 8),
                        BRW_REGISTER_TYPE_UD));
      } else {
         /* The vertex index is non-constant.  We need to use indirect
          * addressing to fetch the proper URB handle.
          *
          */
         fs_reg icp_offset_bytes = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);

         /* Convert vertex_index to bytes (multiply by 4) */
         bld.SHL(icp_offset_bytes,
                 retype(get_nir_src(vertex_src), BRW_REGISTER_TYPE_UD),
                 brw_imm_ud(2u));

         /* Use first_icp_handle as the base offset.  There is one DWord
          * of URB handles per vertex, so inform the register allocator that
          * we might read up to ceil(nir->info.gs.vertices_in / 8) registers.
          */
         bld.emit(SHADER_OPCODE_MOV_INDIRECT, icp_handle,
                  fs_reg(brw_vec8_grf(first_icp_handle, 0)),
                  fs_reg(icp_offset_bytes),
                  brw_imm_ud(DIV_ROUND_UP(nir->info.gs.vertices_in, 8) *
                             REG_SIZE));
      }
   }

   fs_inst *inst;

   fs_reg tmp_dst = dst;
   fs_reg indirect_offset = get_nir_src(offset_src);
   unsigned num_iterations = 1;
   unsigned orig_num_components = num_components;

   if (type_sz(dst.type) == 8) {
      if (num_components > 2) {
         num_iterations = 2;
         num_components = 2;
      }
      fs_reg tmp = fs_reg(VGRF, alloc.allocate(4), dst.type);
      tmp_dst = tmp;
      first_component = first_component / 2;
   }

   for (unsigned iter = 0; iter < num_iterations; iter++) {
d1710 3
a1712 17
         if (first_component != 0) {
            unsigned read_components = num_components + first_component;
            fs_reg tmp = bld.vgrf(dst.type, read_components);
            inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, tmp, icp_handle);
            inst->size_written = read_components *
                                 tmp.component_size(inst->exec_size);
            for (unsigned i = 0; i < num_components; i++) {
               bld.MOV(offset(tmp_dst, bld, i),
                       offset(tmp, bld, i + first_component));
            }
         } else {
            inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, tmp_dst,
                            icp_handle);
            inst->size_written = num_components *
                                 tmp_dst.component_size(inst->exec_size);
         }
         inst->offset = base_offset + offset_const->u32[0];
d1714 1
d1717 1
a1717 3
         const fs_reg srcs[] = { icp_handle, indirect_offset };
         unsigned read_components = num_components + first_component;
         fs_reg tmp = bld.vgrf(dst.type, read_components);
d1720 2
a1721 15
         if (first_component != 0) {
            inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT, tmp,
                            payload);
            inst->size_written = read_components *
                                 tmp.component_size(inst->exec_size);
            for (unsigned i = 0; i < num_components; i++) {
               bld.MOV(offset(tmp_dst, bld, i),
                       offset(tmp, bld, i + first_component));
            }
         } else {
            inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT, tmp_dst,
                         payload);
            inst->size_written = num_components *
                                 tmp_dst.component_size(inst->exec_size);
         }
d1723 1
d1725 1
d1728 6
a1733 6
      if (type_sz(dst.type) == 8) {
         shuffle_32bit_load_result_to_64bit_data(
            bld, tmp_dst, retype(tmp_dst, BRW_REGISTER_TYPE_F), num_components);

         for (unsigned c = 0; c < num_components; c++)
            bld.MOV(offset(dst, bld, iter * 2 + c), offset(tmp_dst, bld, c));
d1735 2
a1736 21

      if (num_iterations > 1) {
         num_components = orig_num_components - 2;
         if(offset_const) {
            base_offset++;
         } else {
            fs_reg new_indirect = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
            bld.ADD(new_indirect, indirect_offset, brw_imm_ud(1u));
            indirect_offset = new_indirect;
         }
      }
   }

   if (is_point_size) {
      /* Read the whole VUE header (because of alignment) and read .w. */
      fs_reg tmp = bld.vgrf(dst.type, 4);
      inst->dst = tmp;
      inst->size_written = 4 * REG_SIZE;
      bld.MOV(dst, offset(tmp, bld, 3));
   }
}
d1749 1
a1749 1
      assert(const_value->u32[0] == 0);
a1755 63
static void
do_untyped_vector_read(const fs_builder &bld,
                       const fs_reg dest,
                       const fs_reg surf_index,
                       const fs_reg offset_reg,
                       unsigned num_components)
{
   if (type_sz(dest.type) == 4) {
      fs_reg read_result = emit_untyped_read(bld, surf_index, offset_reg,
                                             1 /* dims */,
                                             num_components,
                                             BRW_PREDICATE_NONE);
      read_result.type = dest.type;
      for (unsigned i = 0; i < num_components; i++)
         bld.MOV(offset(dest, bld, i), offset(read_result, bld, i));
   } else if (type_sz(dest.type) == 8) {
      /* Reading a dvec, so we need to:
       *
       * 1. Multiply num_components by 2, to account for the fact that we
       *    need to read 64-bit components.
       * 2. Shuffle the result of the load to form valid 64-bit elements
       * 3. Emit a second load (for components z/w) if needed.
       */
      fs_reg read_offset = bld.vgrf(BRW_REGISTER_TYPE_UD);
      bld.MOV(read_offset, offset_reg);

      int iters = num_components <= 2 ? 1 : 2;

      /* Load the dvec, the first iteration loads components x/y, the second
       * iteration, if needed, loads components z/w
       */
      for (int it = 0; it < iters; it++) {
         /* Compute number of components to read in this iteration */
         int iter_components = MIN2(2, num_components);
         num_components -= iter_components;

         /* Read. Since this message reads 32-bit components, we need to
          * read twice as many components.
          */
         fs_reg read_result = emit_untyped_read(bld, surf_index, read_offset,
                                                1 /* dims */,
                                                iter_components * 2,
                                                BRW_PREDICATE_NONE);

         /* Shuffle the 32-bit load result into valid 64-bit data */
         const fs_reg packed_result = bld.vgrf(dest.type, iter_components);
         shuffle_32bit_load_result_to_64bit_data(
            bld, packed_result, read_result, iter_components);

         /* Move each component to its destination */
         read_result = retype(read_result, BRW_REGISTER_TYPE_DF);
         for (int c = 0; c < iter_components; c++) {
            bld.MOV(offset(dest, bld, it * 2 + c),
                    offset(packed_result, bld, c));
         }

         bld.ADD(read_offset, read_offset, brw_imm_ud(16));
      }
   } else {
      unreachable("Unsupported type");
   }
}

a1782 548
   case nir_intrinsic_load_input: {
      fs_reg src = fs_reg(ATTR, instr->const_index[0], dest.type);
      unsigned first_component = nir_intrinsic_component(instr);
      unsigned num_components = instr->num_components;
      enum brw_reg_type type = dest.type;

      nir_const_value *const_offset = nir_src_as_const_value(instr->src[0]);
      assert(const_offset && "Indirect input loads not allowed");
      src = offset(src, bld, const_offset->u32[0]);

      for (unsigned j = 0; j < num_components; j++) {
         bld.MOV(offset(dest, bld, j), offset(src, bld, j + first_component));
      }

      if (type == BRW_REGISTER_TYPE_DF) {
         /* Once the double vector is read, set again its original register
          * type to continue with normal execution.
          */
         src = retype(src, type);
         dest = retype(dest, type);
      }

      if (type_sz(src.type) == 8) {
         shuffle_32bit_load_result_to_64bit_data(bld,
                                                 dest,
                                                 retype(dest, BRW_REGISTER_TYPE_F),
                                                 instr->num_components);
      }
      break;
   }

   default:
      nir_emit_intrinsic(bld, instr);
      break;
   }
}

void
fs_visitor::nir_emit_tcs_intrinsic(const fs_builder &bld,
                                   nir_intrinsic_instr *instr)
{
   assert(stage == MESA_SHADER_TESS_CTRL);
   struct brw_tcs_prog_key *tcs_key = (struct brw_tcs_prog_key *) key;
   struct brw_tcs_prog_data *tcs_prog_data = brw_tcs_prog_data(prog_data);

   fs_reg dst;
   if (nir_intrinsic_infos[instr->intrinsic].has_dest)
      dst = get_nir_dest(instr->dest);

   switch (instr->intrinsic) {
   case nir_intrinsic_load_primitive_id:
      bld.MOV(dst, fs_reg(brw_vec1_grf(0, 1)));
      break;
   case nir_intrinsic_load_invocation_id:
      bld.MOV(retype(dst, invocation_id.type), invocation_id);
      break;
   case nir_intrinsic_load_patch_vertices_in:
      bld.MOV(retype(dst, BRW_REGISTER_TYPE_D),
              brw_imm_d(tcs_key->input_vertices));
      break;

   case nir_intrinsic_barrier: {
      if (tcs_prog_data->instances == 1)
         break;

      fs_reg m0 = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
      fs_reg m0_2 = component(m0, 2);

      const fs_builder chanbld = bld.exec_all().group(1, 0);

      /* Zero the message header */
      bld.exec_all().MOV(m0, brw_imm_ud(0u));

      /* Copy "Barrier ID" from r0.2, bits 16:13 */
      chanbld.AND(m0_2, retype(brw_vec1_grf(0, 2), BRW_REGISTER_TYPE_UD),
                  brw_imm_ud(INTEL_MASK(16, 13)));

      /* Shift it up to bits 27:24. */
      chanbld.SHL(m0_2, m0_2, brw_imm_ud(11));

      /* Set the Barrier Count and the enable bit */
      chanbld.OR(m0_2, m0_2,
                 brw_imm_ud(tcs_prog_data->instances << 9 | (1 << 15)));

      bld.emit(SHADER_OPCODE_BARRIER, bld.null_reg_ud(), m0);
      break;
   }

   case nir_intrinsic_load_input:
      unreachable("nir_lower_io should never give us these.");
      break;

   case nir_intrinsic_load_per_vertex_input: {
      fs_reg indirect_offset = get_indirect_offset(instr);
      unsigned imm_offset = instr->const_index[0];

      const nir_src &vertex_src = instr->src[0];
      nir_const_value *vertex_const = nir_src_as_const_value(vertex_src);

      fs_inst *inst;

      fs_reg icp_handle;

      if (vertex_const) {
         /* Emit a MOV to resolve <0,1,0> regioning. */
         icp_handle = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
         bld.MOV(icp_handle,
                 retype(brw_vec1_grf(1 + (vertex_const->i32[0] >> 3),
                                     vertex_const->i32[0] & 7),
                        BRW_REGISTER_TYPE_UD));
      } else if (tcs_prog_data->instances == 1 &&
                 vertex_src.is_ssa &&
                 vertex_src.ssa->parent_instr->type == nir_instr_type_intrinsic &&
                 nir_instr_as_intrinsic(vertex_src.ssa->parent_instr)->intrinsic == nir_intrinsic_load_invocation_id) {
         /* For the common case of only 1 instance, an array index of
          * gl_InvocationID means reading g1.  Skip all the indirect work.
          */
         icp_handle = retype(brw_vec8_grf(1, 0), BRW_REGISTER_TYPE_UD);
      } else {
         /* The vertex index is non-constant.  We need to use indirect
          * addressing to fetch the proper URB handle.
          */
         icp_handle = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);

         /* Each ICP handle is a single DWord (4 bytes) */
         fs_reg vertex_offset_bytes = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
         bld.SHL(vertex_offset_bytes,
                 retype(get_nir_src(vertex_src), BRW_REGISTER_TYPE_UD),
                 brw_imm_ud(2u));

         /* Start at g1.  We might read up to 4 registers. */
         bld.emit(SHADER_OPCODE_MOV_INDIRECT, icp_handle,
                  fs_reg(brw_vec8_grf(1, 0)), vertex_offset_bytes,
                  brw_imm_ud(4 * REG_SIZE));
      }

      /* We can only read two double components with each URB read, so
       * we send two read messages in that case, each one loading up to
       * two double components.
       */
      unsigned num_iterations = 1;
      unsigned num_components = instr->num_components;
      unsigned first_component = nir_intrinsic_component(instr);
      fs_reg orig_dst = dst;
      if (type_sz(dst.type) == 8) {
         first_component = first_component / 2;
         if (instr->num_components > 2) {
            num_iterations = 2;
            num_components = 2;
         }

         fs_reg tmp = fs_reg(VGRF, alloc.allocate(4), dst.type);
         dst = tmp;
      }

      for (unsigned iter = 0; iter < num_iterations; iter++) {
         if (indirect_offset.file == BAD_FILE) {
            /* Constant indexing - use global offset. */
            if (first_component != 0) {
               unsigned read_components = num_components + first_component;
               fs_reg tmp = bld.vgrf(dst.type, read_components);
               inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, tmp, icp_handle);
               for (unsigned i = 0; i < num_components; i++) {
                  bld.MOV(offset(dst, bld, i),
                          offset(tmp, bld, i + first_component));
               }
            } else {
               inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, dst, icp_handle);
            }
            inst->offset = imm_offset;
            inst->mlen = 1;
         } else {
            /* Indirect indexing - use per-slot offsets as well. */
            const fs_reg srcs[] = { icp_handle, indirect_offset };
            fs_reg payload = bld.vgrf(BRW_REGISTER_TYPE_UD, 2);
            bld.LOAD_PAYLOAD(payload, srcs, ARRAY_SIZE(srcs), 0);
            if (first_component != 0) {
               unsigned read_components = num_components + first_component;
               fs_reg tmp = bld.vgrf(dst.type, read_components);
               inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT, tmp,
                               payload);
               for (unsigned i = 0; i < num_components; i++) {
                  bld.MOV(offset(dst, bld, i),
                          offset(tmp, bld, i + first_component));
               }
            } else {
               inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT, dst,
                               payload);
            }
            inst->offset = imm_offset;
            inst->mlen = 2;
         }
         inst->size_written = (num_components + first_component) *
                              inst->dst.component_size(inst->exec_size);

         /* If we are reading 64-bit data using 32-bit read messages we need
          * build proper 64-bit data elements by shuffling the low and high
          * 32-bit components around like we do for other things like UBOs
          * or SSBOs.
          */
         if (type_sz(dst.type) == 8) {
            shuffle_32bit_load_result_to_64bit_data(
               bld, dst, retype(dst, BRW_REGISTER_TYPE_F), num_components);

            for (unsigned c = 0; c < num_components; c++) {
               bld.MOV(offset(orig_dst, bld, iter * 2 + c),
                       offset(dst, bld, c));
            }
         }

         /* Copy the temporary to the destination to deal with writemasking.
          *
          * Also attempt to deal with gl_PointSize being in the .w component.
          */
         if (inst->offset == 0 && indirect_offset.file == BAD_FILE) {
            assert(type_sz(dst.type) < 8);
            inst->dst = bld.vgrf(dst.type, 4);
            inst->size_written = 4 * REG_SIZE;
            bld.MOV(dst, offset(inst->dst, bld, 3));
         }

         /* If we are loading double data and we need a second read message
          * adjust the write offset
          */
         if (num_iterations > 1) {
            num_components = instr->num_components - 2;
            imm_offset++;
         }
      }
      break;
   }

   case nir_intrinsic_load_output:
   case nir_intrinsic_load_per_vertex_output: {
      fs_reg indirect_offset = get_indirect_offset(instr);
      unsigned imm_offset = instr->const_index[0];
      unsigned first_component = nir_intrinsic_component(instr);

      fs_inst *inst;
      if (indirect_offset.file == BAD_FILE) {
         /* Replicate the patch handle to all enabled channels */
         fs_reg patch_handle = bld.vgrf(BRW_REGISTER_TYPE_UD, 1);
         bld.MOV(patch_handle,
                 retype(brw_vec1_grf(0, 0), BRW_REGISTER_TYPE_UD));

         if (imm_offset == 0) {
            /* This is a read of gl_TessLevelInner[], which lives in the
             * Patch URB header.  The layout depends on the domain.
             */
            dst.type = BRW_REGISTER_TYPE_F;
            switch (tcs_key->tes_primitive_mode) {
            case GL_QUADS: {
               /* DWords 3-2 (reversed) */
               fs_reg tmp = bld.vgrf(BRW_REGISTER_TYPE_F, 4);

               inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, tmp, patch_handle);
               inst->offset = 0;
               inst->mlen = 1;
               inst->size_written = 4 * REG_SIZE;

               /* dst.xy = tmp.wz */
               bld.MOV(dst,                 offset(tmp, bld, 3));
               bld.MOV(offset(dst, bld, 1), offset(tmp, bld, 2));
               break;
            }
            case GL_TRIANGLES:
               /* DWord 4; hardcode offset = 1 and size_written = REG_SIZE */
               inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, dst, patch_handle);
               inst->offset = 1;
               inst->mlen = 1;
               inst->size_written = REG_SIZE;
               break;
            case GL_ISOLINES:
               /* All channels are undefined. */
               break;
            default:
               unreachable("Bogus tessellation domain");
            }
         } else if (imm_offset == 1) {
            /* This is a read of gl_TessLevelOuter[], which lives in the
             * Patch URB header.  The layout depends on the domain.
             */
            dst.type = BRW_REGISTER_TYPE_F;

            fs_reg tmp = bld.vgrf(BRW_REGISTER_TYPE_F, 4);
            inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, tmp, patch_handle);
            inst->offset = 1;
            inst->mlen = 1;
            inst->size_written = 4 * REG_SIZE;

            /* Reswizzle: WZYX */
            fs_reg srcs[4] = {
               offset(tmp, bld, 3),
               offset(tmp, bld, 2),
               offset(tmp, bld, 1),
               offset(tmp, bld, 0),
            };

            unsigned num_components;
            switch (tcs_key->tes_primitive_mode) {
            case GL_QUADS:
               num_components = 4;
               break;
            case GL_TRIANGLES:
               num_components = 3;
               break;
            case GL_ISOLINES:
               /* Isolines are not reversed; swizzle .zw -> .xy */
               srcs[0] = offset(tmp, bld, 2);
               srcs[1] = offset(tmp, bld, 3);
               num_components = 2;
               break;
            default:
               unreachable("Bogus tessellation domain");
            }
            bld.LOAD_PAYLOAD(dst, srcs, num_components, 0);
         } else {
            if (first_component != 0) {
               unsigned read_components =
                  instr->num_components + first_component;
               fs_reg tmp = bld.vgrf(dst.type, read_components);
               inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, tmp,
                               patch_handle);
               inst->size_written = read_components * REG_SIZE;
               for (unsigned i = 0; i < instr->num_components; i++) {
                  bld.MOV(offset(dst, bld, i),
                          offset(tmp, bld, i + first_component));
               }
            } else {
               inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, dst,
                               patch_handle);
               inst->size_written = instr->num_components * REG_SIZE;
            }
            inst->offset = imm_offset;
            inst->mlen = 1;
         }
      } else {
         /* Indirect indexing - use per-slot offsets as well. */
         const fs_reg srcs[] = {
            retype(brw_vec1_grf(0, 0), BRW_REGISTER_TYPE_UD),
            indirect_offset
         };
         fs_reg payload = bld.vgrf(BRW_REGISTER_TYPE_UD, 2);
         bld.LOAD_PAYLOAD(payload, srcs, ARRAY_SIZE(srcs), 0);
         if (first_component != 0) {
            unsigned read_components =
               instr->num_components + first_component;
            fs_reg tmp = bld.vgrf(dst.type, read_components);
            inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT, tmp,
                            payload);
            inst->size_written = read_components * REG_SIZE;
            for (unsigned i = 0; i < instr->num_components; i++) {
               bld.MOV(offset(dst, bld, i),
                       offset(tmp, bld, i + first_component));
            }
         } else {
            inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT, dst,
                            payload);
            inst->size_written = instr->num_components * REG_SIZE;
         }
         inst->offset = imm_offset;
         inst->mlen = 2;
      }
      break;
   }

   case nir_intrinsic_store_output:
   case nir_intrinsic_store_per_vertex_output: {
      fs_reg value = get_nir_src(instr->src[0]);
      bool is_64bit = (instr->src[0].is_ssa ?
         instr->src[0].ssa->bit_size : instr->src[0].reg.reg->bit_size) == 64;
      fs_reg indirect_offset = get_indirect_offset(instr);
      unsigned imm_offset = instr->const_index[0];
      unsigned swiz = BRW_SWIZZLE_XYZW;
      unsigned mask = instr->const_index[1];
      unsigned header_regs = 0;
      fs_reg srcs[7];
      srcs[header_regs++] = retype(brw_vec1_grf(0, 0), BRW_REGISTER_TYPE_UD);

      if (indirect_offset.file != BAD_FILE) {
         srcs[header_regs++] = indirect_offset;
      } else if (!is_passthrough_shader) {
         if (imm_offset == 0) {
            value.type = BRW_REGISTER_TYPE_F;

            mask &= (1 << tesslevel_inner_components(tcs_key->tes_primitive_mode)) - 1;

            /* This is a write to gl_TessLevelInner[], which lives in the
             * Patch URB header.  The layout depends on the domain.
             */
            switch (tcs_key->tes_primitive_mode) {
            case GL_QUADS:
               /* gl_TessLevelInner[].xy lives at DWords 3-2 (reversed).
                * We use an XXYX swizzle to reverse put .xy in the .wz
                * channels, and use a .zw writemask.
                */
               mask = writemask_for_backwards_vector(mask);
               swiz = BRW_SWIZZLE4(0, 0, 1, 0);
               break;
            case GL_TRIANGLES:
               /* gl_TessLevelInner[].x lives at DWord 4, so we set the
                * writemask to X and bump the URB offset by 1.
                */
               imm_offset = 1;
               break;
            case GL_ISOLINES:
               /* Skip; gl_TessLevelInner[] doesn't exist for isolines. */
               return;
            default:
               unreachable("Bogus tessellation domain");
            }
         } else if (imm_offset == 1) {
            /* This is a write to gl_TessLevelOuter[] which lives in the
             * Patch URB Header at DWords 4-7.  However, it's reversed, so
             * instead of .xyzw we have .wzyx.
             */
            value.type = BRW_REGISTER_TYPE_F;

            mask &= (1 << tesslevel_outer_components(tcs_key->tes_primitive_mode)) - 1;

            if (tcs_key->tes_primitive_mode == GL_ISOLINES) {
               /* Isolines .xy should be stored in .zw, in order. */
               swiz = BRW_SWIZZLE4(0, 0, 0, 1);
               mask <<= 2;
            } else {
               /* Other domains are reversed; store .wzyx instead of .xyzw */
               swiz = BRW_SWIZZLE_WZYX;
               mask = writemask_for_backwards_vector(mask);
            }
         }
      }

      if (mask == 0)
         break;

      unsigned num_components = util_last_bit(mask);
      enum opcode opcode;

      /* We can only pack two 64-bit components in a single message, so send
       * 2 messages if we have more components
       */
      unsigned num_iterations = 1;
      unsigned iter_components = num_components;
      unsigned first_component = nir_intrinsic_component(instr);
      if (is_64bit) {
         first_component = first_component / 2;
         if (instr->num_components > 2) {
            num_iterations = 2;
            iter_components = 2;
         }
      }

      /* 64-bit data needs to me shuffled before we can write it to the URB.
       * We will use this temporary to shuffle the components in each
       * iteration.
       */
      fs_reg tmp =
         fs_reg(VGRF, alloc.allocate(2 * iter_components), value.type);

      mask = mask << first_component;

      for (unsigned iter = 0; iter < num_iterations; iter++) {
         if (!is_64bit && mask != WRITEMASK_XYZW) {
            srcs[header_regs++] = brw_imm_ud(mask << 16);
            opcode = indirect_offset.file != BAD_FILE ?
               SHADER_OPCODE_URB_WRITE_SIMD8_MASKED_PER_SLOT :
               SHADER_OPCODE_URB_WRITE_SIMD8_MASKED;
         } else if (is_64bit && ((mask & WRITEMASK_XY) != WRITEMASK_XY)) {
            /* Expand the 64-bit mask to 32-bit channels. We only handle
             * two channels in each iteration, so we only care about X/Y.
             */
            unsigned mask32 = 0;
            if (mask & WRITEMASK_X)
               mask32 |= WRITEMASK_XY;
            if (mask & WRITEMASK_Y)
               mask32 |= WRITEMASK_ZW;

            /* If the mask does not include any of the channels X or Y there
             * is nothing to do in this iteration. Move on to the next couple
             * of 64-bit channels.
             */
            if (!mask32) {
               mask >>= 2;
               imm_offset++;
               continue;
            }

            srcs[header_regs++] = brw_imm_ud(mask32 << 16);
            opcode = indirect_offset.file != BAD_FILE ?
               SHADER_OPCODE_URB_WRITE_SIMD8_MASKED_PER_SLOT :
               SHADER_OPCODE_URB_WRITE_SIMD8_MASKED;
         } else {
            opcode = indirect_offset.file != BAD_FILE ?
               SHADER_OPCODE_URB_WRITE_SIMD8_PER_SLOT :
               SHADER_OPCODE_URB_WRITE_SIMD8;
         }

         for (unsigned i = 0; i < iter_components; i++) {
            if (!(mask & (1 << (i + first_component))))
               continue;

            if (!is_64bit) {
               srcs[header_regs + i + first_component] =
                  offset(value, bld, BRW_GET_SWZ(swiz, i));
            } else {
               /* We need to shuffle the 64-bit data to match the layout
                * expected by our 32-bit URB write messages. We use a temporary
                * for that.
                */
               unsigned channel = BRW_GET_SWZ(swiz, iter * 2 + i);
               shuffle_64bit_data_for_32bit_write(bld,
                  retype(offset(tmp, bld, 2 * i), BRW_REGISTER_TYPE_F),
                  retype(offset(value, bld, 2 * channel), BRW_REGISTER_TYPE_DF),
                  1);

               /* Now copy the data to the destination */
               fs_reg dest = fs_reg(VGRF, alloc.allocate(2), value.type);
               unsigned idx = 2 * i;
               bld.MOV(dest, offset(tmp, bld, idx));
               bld.MOV(offset(dest, bld, 1), offset(tmp, bld, idx + 1));
               srcs[header_regs + idx + first_component * 2] = dest;
               srcs[header_regs + idx + 1 + first_component * 2] =
                  offset(dest, bld, 1);
            }
         }

         unsigned mlen =
            header_regs + (is_64bit ? 2 * iter_components : iter_components) +
            (is_64bit ? 2 * first_component : first_component);
         fs_reg payload =
            bld.vgrf(BRW_REGISTER_TYPE_UD, mlen);
         bld.LOAD_PAYLOAD(payload, srcs, mlen, header_regs);

         fs_inst *inst = bld.emit(opcode, bld.null_reg_ud(), payload);
         inst->offset = imm_offset;
         inst->mlen = mlen;

         /* If this is a 64-bit attribute, select the next two 64-bit channels
          * to be handled in the next iteration.
          */
         if (is_64bit) {
            mask >>= 2;
            imm_offset++;
         }
      }
      break;
   }

d1794 1
a1794 1
   struct brw_tes_prog_data *tes_prog_data = brw_tes_prog_data(prog_data);
d1829 1
a1829 1
            bld.MOV(offset(dest, bld, i), component(fs_reg(ATTR, 0), 6 + i));
a1856 5
      unsigned first_component = nir_intrinsic_component(instr);

      if (type_sz(dest.type) == 8) {
         first_component = first_component / 2;
      }
d1867 2
a1868 3
               unsigned comp = 16 / type_sz(dest.type) * (imm_offset % 2) +
                  i + first_component;
               bld.MOV(offset(dest, bld, i), component(src, comp));
d1881 1
a1881 16
            if (first_component != 0) {
               unsigned read_components =
                  instr->num_components + first_component;
               fs_reg tmp = bld.vgrf(dest.type, read_components);
               inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, tmp,
                               patch_handle);
               inst->size_written = read_components * REG_SIZE;
               for (unsigned i = 0; i < instr->num_components; i++) {
                  bld.MOV(offset(dest, bld, i),
                          offset(tmp, bld, i + first_component));
               }
            } else {
               inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8, dest,
                               patch_handle);
               inst->size_written = instr->num_components * REG_SIZE;
            }
d1884 2
d1889 6
d1896 5
a1900 66
         /* We can only read two double components with each URB read, so
          * we send two read messages in that case, each one loading up to
          * two double components.
          */
         unsigned num_iterations = 1;
         unsigned num_components = instr->num_components;
         fs_reg orig_dest = dest;
         if (type_sz(dest.type) == 8) {
            if (instr->num_components > 2) {
               num_iterations = 2;
               num_components = 2;
            }
            fs_reg tmp = fs_reg(VGRF, alloc.allocate(4), dest.type);
            dest = tmp;
         }

         for (unsigned iter = 0; iter < num_iterations; iter++) {
            const fs_reg srcs[] = {
               retype(brw_vec1_grf(0, 0), BRW_REGISTER_TYPE_UD),
               indirect_offset
            };
            fs_reg payload = bld.vgrf(BRW_REGISTER_TYPE_UD, 2);
            bld.LOAD_PAYLOAD(payload, srcs, ARRAY_SIZE(srcs), 0);

            if (first_component != 0) {
               unsigned read_components =
                   num_components + first_component;
               fs_reg tmp = bld.vgrf(dest.type, read_components);
               inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT, tmp,
                               payload);
               for (unsigned i = 0; i < num_components; i++) {
                  bld.MOV(offset(dest, bld, i),
                          offset(tmp, bld, i + first_component));
               }
            } else {
               inst = bld.emit(SHADER_OPCODE_URB_READ_SIMD8_PER_SLOT, dest,
                               payload);
            }
            inst->mlen = 2;
            inst->offset = imm_offset;
            inst->size_written = (num_components + first_component) *
                                 inst->dst.component_size(inst->exec_size);

            /* If we are reading 64-bit data using 32-bit read messages we need
             * build proper 64-bit data elements by shuffling the low and high
             * 32-bit components around like we do for other things like UBOs
             * or SSBOs.
             */
            if (type_sz(dest.type) == 8) {
               shuffle_32bit_load_result_to_64bit_data(
                  bld, dest, retype(dest, BRW_REGISTER_TYPE_F), num_components);

               for (unsigned c = 0; c < num_components; c++) {
                  bld.MOV(offset(orig_dest, bld, iter * 2 + c),
                          offset(dest, bld, c));
               }
            }

            /* If we are loading double data and we need a second read message
             * adjust the offset
             */
            if (num_iterations > 1) {
               num_components = instr->num_components - 2;
               imm_offset++;
            }
         }
d1924 1
a1924 1
      assert(brw_gs_prog_data(prog_data)->include_primitive_id);
d1934 1
a1934 2
                         instr->src[1], instr->num_components,
                         nir_intrinsic_component(instr));
a1962 156
/**
 * Fetch the current render target layer index.
 */
static fs_reg
fetch_render_target_array_index(const fs_builder &bld)
{
   if (bld.shader->devinfo->gen >= 6) {
      /* The render target array index is provided in the thread payload as
       * bits 26:16 of r0.0.
       */
      const fs_reg idx = bld.vgrf(BRW_REGISTER_TYPE_UD);
      bld.AND(idx, brw_uw1_reg(BRW_GENERAL_REGISTER_FILE, 0, 1),
              brw_imm_uw(0x7ff));
      return idx;
   } else {
      /* Pre-SNB we only ever render into the first layer of the framebuffer
       * since layered rendering is not implemented.
       */
      return brw_imm_ud(0);
   }
}

/**
 * Fake non-coherent framebuffer read implemented using TXF to fetch from the
 * framebuffer at the current fragment coordinates and sample index.
 */
fs_inst *
fs_visitor::emit_non_coherent_fb_read(const fs_builder &bld, const fs_reg &dst,
                                      unsigned target)
{
   const struct gen_device_info *devinfo = bld.shader->devinfo;

   assert(bld.shader->stage == MESA_SHADER_FRAGMENT);
   const brw_wm_prog_key *wm_key =
      reinterpret_cast<const brw_wm_prog_key *>(key);
   assert(!wm_key->coherent_fb_fetch);
   const struct brw_wm_prog_data *wm_prog_data =
      brw_wm_prog_data(stage_prog_data);

   /* Calculate the surface index relative to the start of the texture binding
    * table block, since that's what the texturing messages expect.
    */
   const unsigned surface = target +
      wm_prog_data->binding_table.render_target_read_start -
      wm_prog_data->base.binding_table.texture_start;

   brw_mark_surface_used(
      bld.shader->stage_prog_data,
      wm_prog_data->binding_table.render_target_read_start + target);

   /* Calculate the fragment coordinates. */
   const fs_reg coords = bld.vgrf(BRW_REGISTER_TYPE_UD, 3);
   bld.MOV(offset(coords, bld, 0), pixel_x);
   bld.MOV(offset(coords, bld, 1), pixel_y);
   bld.MOV(offset(coords, bld, 2), fetch_render_target_array_index(bld));

   /* Calculate the sample index and MCS payload when multisampling.  Luckily
    * the MCS fetch message behaves deterministically for UMS surfaces, so it
    * shouldn't be necessary to recompile based on whether the framebuffer is
    * CMS or UMS.
    */
   if (wm_key->multisample_fbo &&
       nir_system_values[SYSTEM_VALUE_SAMPLE_ID].file == BAD_FILE)
      nir_system_values[SYSTEM_VALUE_SAMPLE_ID] = *emit_sampleid_setup();

   const fs_reg sample = nir_system_values[SYSTEM_VALUE_SAMPLE_ID];
   const fs_reg mcs = wm_key->multisample_fbo ?
      emit_mcs_fetch(coords, 3, brw_imm_ud(surface)) : fs_reg();

   /* Use either a normal or a CMS texel fetch message depending on whether
    * the framebuffer is single or multisample.  On SKL+ use the wide CMS
    * message just in case the framebuffer uses 16x multisampling, it should
    * be equivalent to the normal CMS fetch for lower multisampling modes.
    */
   const opcode op = !wm_key->multisample_fbo ? SHADER_OPCODE_TXF_LOGICAL :
                     devinfo->gen >= 9 ? SHADER_OPCODE_TXF_CMS_W_LOGICAL :
                     SHADER_OPCODE_TXF_CMS_LOGICAL;

   /* Emit the instruction. */
   const fs_reg srcs[] = { coords, fs_reg(), brw_imm_ud(0), fs_reg(),
                           sample, mcs,
                           brw_imm_ud(surface), brw_imm_ud(0),
                           fs_reg(), brw_imm_ud(3), brw_imm_ud(0) };
   STATIC_ASSERT(ARRAY_SIZE(srcs) == TEX_LOGICAL_NUM_SRCS);

   fs_inst *inst = bld.emit(op, dst, srcs, ARRAY_SIZE(srcs));
   inst->size_written = 4 * inst->dst.component_size(inst->exec_size);

   return inst;
}

/**
 * Actual coherent framebuffer read implemented using the native render target
 * read message.  Requires SKL+.
 */
static fs_inst *
emit_coherent_fb_read(const fs_builder &bld, const fs_reg &dst, unsigned target)
{
   assert(bld.shader->devinfo->gen >= 9);
   fs_inst *inst = bld.emit(FS_OPCODE_FB_READ_LOGICAL, dst);
   inst->target = target;
   inst->size_written = 4 * inst->dst.component_size(inst->exec_size);

   return inst;
}

static fs_reg
alloc_temporary(const fs_builder &bld, unsigned size, fs_reg *regs, unsigned n)
{
   if (n && regs[0].file != BAD_FILE) {
      return regs[0];

   } else {
      const fs_reg tmp = bld.vgrf(BRW_REGISTER_TYPE_F, size);

      for (unsigned i = 0; i < n; i++)
         regs[i] = tmp;

      return tmp;
   }
}

static fs_reg
alloc_frag_output(fs_visitor *v, unsigned location)
{
   assert(v->stage == MESA_SHADER_FRAGMENT);
   const brw_wm_prog_key *const key =
      reinterpret_cast<const brw_wm_prog_key *>(v->key);
   const unsigned l = GET_FIELD(location, BRW_NIR_FRAG_OUTPUT_LOCATION);
   const unsigned i = GET_FIELD(location, BRW_NIR_FRAG_OUTPUT_INDEX);

   if (i > 0 || (key->force_dual_color_blend && l == FRAG_RESULT_DATA1))
      return alloc_temporary(v->bld, 4, &v->dual_src_output, 1);

   else if (l == FRAG_RESULT_COLOR)
      return alloc_temporary(v->bld, 4, v->outputs,
                             MAX2(key->nr_color_regions, 1));

   else if (l == FRAG_RESULT_DEPTH)
      return alloc_temporary(v->bld, 1, &v->frag_depth, 1);

   else if (l == FRAG_RESULT_STENCIL)
      return alloc_temporary(v->bld, 1, &v->frag_stencil, 1);

   else if (l == FRAG_RESULT_SAMPLE_MASK)
      return alloc_temporary(v->bld, 1, &v->sample_mask, 1);

   else if (l >= FRAG_RESULT_DATA0 &&
            l < FRAG_RESULT_DATA0 + BRW_MAX_DRAW_BUFFERS)
      return alloc_temporary(v->bld, 4,
                             &v->outputs[l - FRAG_RESULT_DATA0], 1);

   else
      unreachable("Invalid location");
}

d1968 2
a2000 38
   case nir_intrinsic_store_output: {
      const fs_reg src = get_nir_src(instr->src[0]);
      const nir_const_value *const_offset = nir_src_as_const_value(instr->src[1]);
      assert(const_offset && "Indirect output stores not allowed");
      const unsigned location = nir_intrinsic_base(instr) +
         SET_FIELD(const_offset->u32[0], BRW_NIR_FRAG_OUTPUT_LOCATION);
      const fs_reg new_dest = retype(alloc_frag_output(this, location),
                                     src.type);

      for (unsigned j = 0; j < instr->num_components; j++)
         bld.MOV(offset(new_dest, bld, nir_intrinsic_component(instr) + j),
                 offset(src, bld, j));

      break;
   }

   case nir_intrinsic_load_output: {
      const unsigned l = GET_FIELD(nir_intrinsic_base(instr),
                                   BRW_NIR_FRAG_OUTPUT_LOCATION);
      assert(l >= FRAG_RESULT_DATA0);
      nir_const_value *const_offset = nir_src_as_const_value(instr->src[0]);
      assert(const_offset && "Indirect output loads not allowed");
      const unsigned target = l - FRAG_RESULT_DATA0 + const_offset->u32[0];
      const fs_reg tmp = bld.vgrf(dest.type, 4);

      if (reinterpret_cast<const brw_wm_prog_key *>(key)->coherent_fb_fetch)
         emit_coherent_fb_read(bld, tmp, target);
      else
         emit_non_coherent_fb_read(bld, tmp, target);

      for (unsigned j = 0; j < instr->num_components; j++) {
         bld.MOV(offset(dest, bld, j),
                 offset(tmp, bld, nir_intrinsic_component(instr) + j));
      }

      break;
   }

d2026 26
a2051 52
   case nir_intrinsic_load_input: {
      /* load_input is only used for flat inputs */
      unsigned base = nir_intrinsic_base(instr);
      unsigned component = nir_intrinsic_component(instr);
      unsigned num_components = instr->num_components;
      enum brw_reg_type type = dest.type;

      /* Special case fields in the VUE header */
      if (base == VARYING_SLOT_LAYER)
         component = 1;
      else if (base == VARYING_SLOT_VIEWPORT)
         component = 2;

      if (nir_dest_bit_size(instr->dest) == 64) {
         /* const_index is in 32-bit type size units that could not be aligned
          * with DF. We need to read the double vector as if it was a float
          * vector of twice the number of components to fetch the right data.
          */
         type = BRW_REGISTER_TYPE_F;
         num_components *= 2;
      }

      for (unsigned int i = 0; i < num_components; i++) {
         struct brw_reg interp = interp_reg(base, component + i);
         interp = suboffset(interp, 3);
         bld.emit(FS_OPCODE_CINTERP, offset(retype(dest, type), bld, i),
                  retype(fs_reg(interp), type));
      }

      if (nir_dest_bit_size(instr->dest) == 64) {
         shuffle_32bit_load_result_to_64bit_data(bld,
                                                 dest,
                                                 retype(dest, type),
                                                 instr->num_components);
      }
      break;
   }

   case nir_intrinsic_load_barycentric_pixel:
   case nir_intrinsic_load_barycentric_centroid:
   case nir_intrinsic_load_barycentric_sample:
      /* Do nothing - load_interpolated_input handling will handle it later. */
      break;

   case nir_intrinsic_load_barycentric_at_sample: {
      const glsl_interp_mode interpolation =
         (enum glsl_interp_mode) nir_intrinsic_interp_mode(instr);

      nir_const_value *const_sample = nir_src_as_const_value(instr->src[0]);

      if (const_sample) {
         unsigned msg_data = const_sample->i32[0] << 4;
d2053 2
d2056 2
a2057 2
                                      FS_OPCODE_INTERPOLATE_AT_SAMPLE,
                                      dest,
d2059 1
a2059 1
                                      brw_imm_ud(msg_data),
d2061 7
a2067 3
      } else {
         const fs_reg sample_src = retype(get_nir_src(instr->src[0]),
                                          BRW_REGISTER_TYPE_UD);
a2068 5
         if (nir_src_is_dynamically_uniform(instr->src[0])) {
            const fs_reg sample_id = bld.emit_uniformize(sample_src);
            const fs_reg msg_data = vgrf(glsl_type::uint_type);
            bld.exec_all().group(1, 0)
               .SHL(msg_data, sample_id, brw_imm_ud(4u));
d2071 1
a2071 1
                                         dest,
d2073 1
a2073 1
                                         msg_data,
d2076 2
a2077 7
            /* Make a loop that sends a message to the pixel interpolater
             * for the sample number in each live channel. If there are
             * multiple channels with the same sample number then these
             * will be handled simultaneously with a single interation of
             * the loop.
             */
            bld.emit(BRW_OPCODE_DO);
d2079 5
a2083 13
            /* Get the next live sample number into sample_id_reg */
            const fs_reg sample_id = bld.emit_uniformize(sample_src);

            /* Set the flag register so that we can perform the send
             * message on all channels that have the same sample number
             */
            bld.CMP(bld.null_reg_ud(),
                    sample_src, sample_id,
                    BRW_CONDITIONAL_EQ);
            const fs_reg msg_data = vgrf(glsl_type::uint_type);
            bld.exec_all().group(1, 0)
               .SHL(msg_data, sample_id, brw_imm_ud(4u));
            fs_inst *inst =
d2086 1
a2086 1
                                            dest,
d2090 8
a2097 1
            set_predicate(BRW_PREDICATE_NORMAL, inst);
d2099 26
a2124 4
            /* Continue the loop if there are any live channels left */
            set_predicate_inv(BRW_PREDICATE_NORMAL,
                              true, /* inverse */
                              bld.emit(BRW_OPCODE_WHILE));
d2126 2
a2128 2
      break;
   }
d2130 2
a2131 3
   case nir_intrinsic_load_barycentric_at_offset: {
      const glsl_interp_mode interpolation =
         (enum glsl_interp_mode) nir_intrinsic_interp_mode(instr);
d2133 3
a2135 1
      nir_const_value *const_offset = nir_src_as_const_value(instr->src[0]);
d2137 34
a2170 3
      if (const_offset) {
         unsigned off_x = MIN2((int)(const_offset->f32[0] * 16), 7) & 0xf;
         unsigned off_y = MIN2((int)(const_offset->f32[1] * 16), 7) & 0xf;
d2172 7
a2178 34
         emit_pixel_interpolater_send(bld,
                                      FS_OPCODE_INTERPOLATE_AT_SHARED_OFFSET,
                                      dest,
                                      fs_reg(), /* src */
                                      brw_imm_ud(off_x | (off_y << 4)),
                                      interpolation);
      } else {
         fs_reg src = vgrf(glsl_type::ivec2_type);
         fs_reg offset_src = retype(get_nir_src(instr->src[0]),
                                    BRW_REGISTER_TYPE_F);
         for (int i = 0; i < 2; i++) {
            fs_reg temp = vgrf(glsl_type::float_type);
            bld.MUL(temp, offset(offset_src, bld, i), brw_imm_f(16.0f));
            fs_reg itemp = vgrf(glsl_type::int_type);
            /* float to int */
            bld.MOV(itemp, temp);

            /* Clamp the upper end of the range to +7/16.
             * ARB_gpu_shader5 requires that we support a maximum offset
             * of +0.5, which isn't representable in a S0.4 value -- if
             * we didn't clamp it, we'd end up with -8/16, which is the
             * opposite of what the shader author wanted.
             *
             * This is legal due to ARB_gpu_shader5's quantization
             * rules:
             *
             * "Not all values of <offset> may be supported; x and y
             * offsets may be rounded to fixed-point values with the
             * number of fraction bits given by the
             * implementation-dependent constant
             * FRAGMENT_INTERPOLATION_OFFSET_BITS"
             */
            set_condmod(BRW_CONDITIONAL_L,
                        bld.SEL(offset(src, bld, i), itemp, brw_imm_d(7)));
d2180 2
d2183 2
a2184 7
         const enum opcode opcode = FS_OPCODE_INTERPOLATE_AT_PER_SLOT_OFFSET;
         emit_pixel_interpolater_send(bld,
                                      opcode,
                                      dest,
                                      src,
                                      brw_imm_ud(0u),
                                      interpolation);
a2185 2
      break;
   }
d2187 3
a2189 5
   case nir_intrinsic_load_interpolated_input: {
      if (nir_intrinsic_base(instr) == VARYING_SLOT_POS) {
         emit_fragcoord_interpolation(dest);
         break;
      }
d2191 2
a2192 35
      assert(instr->src[0].ssa &&
             instr->src[0].ssa->parent_instr->type == nir_instr_type_intrinsic);
      nir_intrinsic_instr *bary_intrinsic =
         nir_instr_as_intrinsic(instr->src[0].ssa->parent_instr);
      nir_intrinsic_op bary_intrin = bary_intrinsic->intrinsic;
      enum glsl_interp_mode interp_mode =
         (enum glsl_interp_mode) nir_intrinsic_interp_mode(bary_intrinsic);
      fs_reg dst_xy;

      if (bary_intrin == nir_intrinsic_load_barycentric_at_offset ||
          bary_intrin == nir_intrinsic_load_barycentric_at_sample) {
         /* Use the result of the PI message */
         dst_xy = retype(get_nir_src(instr->src[0]), BRW_REGISTER_TYPE_F);
      } else {
         /* Use the delta_xy values computed from the payload */
         enum brw_barycentric_mode bary =
            brw_barycentric_mode(interp_mode, bary_intrin);

         dst_xy = this->delta_xy[bary];
      }

      for (unsigned int i = 0; i < instr->num_components; i++) {
         fs_reg interp =
            fs_reg(interp_reg(nir_intrinsic_base(instr),
                              nir_intrinsic_component(instr) + i));
         interp.type = BRW_REGISTER_TYPE_F;
         dest.type = BRW_REGISTER_TYPE_F;

         if (devinfo->gen < 6 && interp_mode == INTERP_MODE_SMOOTH) {
            fs_reg tmp = vgrf(glsl_type::float_type);
            bld.emit(FS_OPCODE_LINTERP, tmp, dst_xy, interp);
            bld.MUL(offset(dest, bld, i), tmp, this->pixel_w);
         } else {
            bld.emit(FS_OPCODE_LINTERP, offset(dest, bld, i), dst_xy, interp);
         }
a2195 1

d2207 2
a2208 1
   struct brw_cs_prog_data *cs_prog_data = brw_cs_prog_data(prog_data);
d2237 2
a2238 138
      fs_reg surf_index = brw_imm_ud(surface);
      brw_mark_surface_used(prog_data, surface);

      /* Read the 3 GLuint components of gl_NumWorkGroups */
      for (unsigned i = 0; i < 3; i++) {
         fs_reg read_result =
            emit_untyped_read(bld, surf_index,
                              brw_imm_ud(i << 2),
                              1 /* dims */, 1 /* size */,
                              BRW_PREDICATE_NONE);
         read_result.type = dest.type;
         bld.MOV(dest, read_result);
         dest = offset(dest, bld, 1);
      }
      break;
   }

   case nir_intrinsic_shared_atomic_add:
      nir_emit_shared_atomic(bld, BRW_AOP_ADD, instr);
      break;
   case nir_intrinsic_shared_atomic_imin:
      nir_emit_shared_atomic(bld, BRW_AOP_IMIN, instr);
      break;
   case nir_intrinsic_shared_atomic_umin:
      nir_emit_shared_atomic(bld, BRW_AOP_UMIN, instr);
      break;
   case nir_intrinsic_shared_atomic_imax:
      nir_emit_shared_atomic(bld, BRW_AOP_IMAX, instr);
      break;
   case nir_intrinsic_shared_atomic_umax:
      nir_emit_shared_atomic(bld, BRW_AOP_UMAX, instr);
      break;
   case nir_intrinsic_shared_atomic_and:
      nir_emit_shared_atomic(bld, BRW_AOP_AND, instr);
      break;
   case nir_intrinsic_shared_atomic_or:
      nir_emit_shared_atomic(bld, BRW_AOP_OR, instr);
      break;
   case nir_intrinsic_shared_atomic_xor:
      nir_emit_shared_atomic(bld, BRW_AOP_XOR, instr);
      break;
   case nir_intrinsic_shared_atomic_exchange:
      nir_emit_shared_atomic(bld, BRW_AOP_MOV, instr);
      break;
   case nir_intrinsic_shared_atomic_comp_swap:
      nir_emit_shared_atomic(bld, BRW_AOP_CMPWR, instr);
      break;

   case nir_intrinsic_load_shared: {
      assert(devinfo->gen >= 7);

      fs_reg surf_index = brw_imm_ud(GEN7_BTI_SLM);

      /* Get the offset to read from */
      fs_reg offset_reg;
      nir_const_value *const_offset = nir_src_as_const_value(instr->src[0]);
      if (const_offset) {
         offset_reg = brw_imm_ud(instr->const_index[0] + const_offset->u32[0]);
      } else {
         offset_reg = vgrf(glsl_type::uint_type);
         bld.ADD(offset_reg,
                 retype(get_nir_src(instr->src[0]), BRW_REGISTER_TYPE_UD),
                 brw_imm_ud(instr->const_index[0]));
      }

      /* Read the vector */
      do_untyped_vector_read(bld, dest, surf_index, offset_reg,
                             instr->num_components);
      break;
   }

   case nir_intrinsic_store_shared: {
      assert(devinfo->gen >= 7);

      /* Block index */
      fs_reg surf_index = brw_imm_ud(GEN7_BTI_SLM);

      /* Value */
      fs_reg val_reg = get_nir_src(instr->src[0]);

      /* Writemask */
      unsigned writemask = instr->const_index[1];

      /* get_nir_src() retypes to integer. Be wary of 64-bit types though
       * since the untyped writes below operate in units of 32-bits, which
       * means that we need to write twice as many components each time.
       * Also, we have to suffle 64-bit data to be in the appropriate layout
       * expected by our 32-bit write messages.
       */
      unsigned type_size = 4;
      unsigned bit_size = instr->src[0].is_ssa ?
         instr->src[0].ssa->bit_size : instr->src[0].reg.reg->bit_size;
      if (bit_size == 64) {
         type_size = 8;
         fs_reg tmp =
           fs_reg(VGRF, alloc.allocate(alloc.sizes[val_reg.nr]), val_reg.type);
         shuffle_64bit_data_for_32bit_write(
            bld,
            retype(tmp, BRW_REGISTER_TYPE_F),
            retype(val_reg, BRW_REGISTER_TYPE_DF),
            instr->num_components);
         val_reg = tmp;
      }

      unsigned type_slots = type_size / 4;

      /* Combine groups of consecutive enabled channels in one write
       * message. We use ffs to find the first enabled channel and then ffs on
       * the bit-inverse, down-shifted writemask to determine the length of
       * the block of enabled bits.
       */
      while (writemask) {
         unsigned first_component = ffs(writemask) - 1;
         unsigned length = ffs(~(writemask >> first_component)) - 1;

         /* We can't write more than 2 64-bit components at once. Limit the
          * length of the write to what we can do and let the next iteration
          * handle the rest
          */
         if (type_size > 4)
            length = MIN2(2, length);

         fs_reg offset_reg;
         nir_const_value *const_offset = nir_src_as_const_value(instr->src[1]);
         if (const_offset) {
            offset_reg = brw_imm_ud(instr->const_index[0] + const_offset->u32[0] +
                                    type_size * first_component);
         } else {
            offset_reg = vgrf(glsl_type::uint_type);
            bld.ADD(offset_reg,
                    retype(get_nir_src(instr->src[1]), BRW_REGISTER_TYPE_UD),
                    brw_imm_ud(instr->const_index[0] + type_size * first_component));
         }

         emit_untyped_write(bld, surf_index, offset_reg,
                            offset(val_reg, bld, first_component * type_slots),
                            1 /* dims */, length * type_slots,
                            BRW_PREDICATE_NONE);
d2240 10
a2249 4
         /* Clear the bits in the writemask that we just wrote, then try
          * again to see if more channels are left.
          */
         writemask &= (15 << (first_component + length));
d2251 2
d2254 29
a2283 1
   }
d2301 2
a2302 15
   case nir_intrinsic_atomic_counter_read:
   case nir_intrinsic_atomic_counter_add:
   case nir_intrinsic_atomic_counter_min:
   case nir_intrinsic_atomic_counter_max:
   case nir_intrinsic_atomic_counter_and:
   case nir_intrinsic_atomic_counter_or:
   case nir_intrinsic_atomic_counter_xor:
   case nir_intrinsic_atomic_counter_exchange:
   case nir_intrinsic_atomic_counter_comp_swap: {
      if (stage == MESA_SHADER_FRAGMENT &&
          instr->intrinsic != nir_intrinsic_atomic_counter_read)
         brw_wm_prog_data(prog_data)->has_side_effects = true;

      /* Get some metadata from the image intrinsic. */
      const nir_intrinsic_info *info = &nir_intrinsic_infos[instr->intrinsic];
a2307 4
      const fs_reg src0 = (info->num_srcs >= 2
                           ? get_nir_src(instr->src[1]) : fs_reg());
      const fs_reg src1 = (info->num_srcs >= 3
                           ? get_nir_src(instr->src[2]) : fs_reg());
a2309 2
      assert(info->num_srcs <= 3);

d2311 2
a2312 1
      if (instr->intrinsic == nir_intrinsic_atomic_counter_read) {
d2314 14
a2327 4
      } else {
         tmp = emit_untyped_atomic(bld, brw_imm_ud(surface), offset, src0,
                                   src1, 1, 1,
                                   get_atomic_counter_op(instr->intrinsic));
a2349 4
      if (stage == MESA_SHADER_FRAGMENT &&
          instr->intrinsic != nir_intrinsic_image_load)
         brw_wm_prog_data(prog_data)->has_side_effects = true;

d2359 3
a2361 1
      const unsigned format = var->data.image.format;
d2380 1
a2380 2
         emit_image_store(bld, image, addr, src0, surf_dims, arr_dims,
                          var->data.image.write_only ? GL_NONE : format);
d2398 3
a2400 4
      const fs_builder ubld = bld.group(8, 0);
      const fs_reg tmp = ubld.vgrf(BRW_REGISTER_TYPE_UD, 2);
      ubld.emit(SHADER_OPCODE_MEMORY_FENCE, tmp)
         ->size_written = 2 * REG_SIZE;
d2429 3
a2431 3
      const fs_reg shader_clock = get_timestamp(bld);
      const fs_reg srcs[] = { component(shader_clock, 0),
                              component(shader_clock, 1) };
d2495 2
a2496 6
         assert(const_offset->u32[0] % 4 == 0);
         src.offset = const_offset->u32[0];

         for (unsigned j = 0; j < instr->num_components; j++) {
            bld.MOV(offset(dest, bld, j), offset(src, bld, j));
         }
d2498 2
a2499 2
         fs_reg indirect = retype(get_nir_src(instr->src[0]),
                                  BRW_REGISTER_TYPE_UD);
d2501 2
a2502 37
         /* We need to pass a size to the MOV_INDIRECT but we don't want it to
          * go past the end of the uniform.  In order to keep the n'th
          * component from running past, we subtract off the size of all but
          * one component of the vector.
          */
         assert(instr->const_index[1] >=
                instr->num_components * (int) type_sz(dest.type));
         unsigned read_size = instr->const_index[1] -
            (instr->num_components - 1) * type_sz(dest.type);

         fs_reg indirect_chv_high_32bit;
         bool is_chv_bxt_64bit =
            (devinfo->is_cherryview || devinfo->is_broxton) &&
            type_sz(dest.type) == 8;
         if (is_chv_bxt_64bit) {
            indirect_chv_high_32bit = vgrf(glsl_type::uint_type);
            /* Calculate indirect address to read high 32 bits */
            bld.ADD(indirect_chv_high_32bit, indirect, brw_imm_ud(4));
         }

         for (unsigned j = 0; j < instr->num_components; j++) {
            if (!is_chv_bxt_64bit) {
               bld.emit(SHADER_OPCODE_MOV_INDIRECT,
                        offset(dest, bld, j), offset(src, bld, j),
                        indirect, brw_imm_ud(read_size));
            } else {
               bld.emit(SHADER_OPCODE_MOV_INDIRECT,
                        subscript(offset(dest, bld, j), BRW_REGISTER_TYPE_UD, 0),
                        offset(src, bld, j),
                        indirect, brw_imm_ud(read_size));

               bld.emit(SHADER_OPCODE_MOV_INDIRECT,
                        subscript(offset(dest, bld, j), BRW_REGISTER_TYPE_UD, 1),
                        offset(src, bld, j),
                        indirect_chv_high_32bit, brw_imm_ud(read_size));
            }
         }
d2513 1
a2513 1
                                const_index->u32[0];
d2537 1
a2537 1
                                     BRW_REGISTER_TYPE_UD);
d2541 1
a2541 1
                                       base_offset, i * type_sz(dest.type));
d2543 6
a2548 20
         /* Even if we are loading doubles, a pull constant load will load
          * a 32-bit vec4, so should only reserve vgrf space for that. If we
          * need to load a full dvec4 we will have to emit 2 loads. This is
          * similar to demote_pull_constants(), except that in that case we
          * see individual accesses to each component of the vector and then
          * we let CSE deal with duplicate loads. Here we see a vector access
          * and we have to split it if necessary.
          */
         const unsigned type_size = type_sz(dest.type);
         const fs_reg packed_consts = bld.vgrf(BRW_REGISTER_TYPE_F);
         for (unsigned c = 0; c < instr->num_components;) {
            const unsigned base = const_offset->u32[0] + c * type_size;

            /* Number of usable components in the next 16B-aligned load */
            const unsigned count = MIN2(instr->num_components - c,
                                        (16 - base % 16) / type_size);

            bld.exec_all()
               .emit(FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD,
                     packed_consts, surf_index, brw_imm_ud(base & ~15));
d2550 2
a2551 2
            const fs_reg consts =
               retype(byte_offset(packed_consts, base & 15), dest.type);
d2553 4
a2556 2
            for (unsigned d = 0; d < count; d++)
               bld.MOV(offset(dest, bld, c + d), component(consts, d));
d2558 2
a2559 1
            c += count;
d2574 1
a2574 1
                          const_uniform_block->u32[0];
d2593 1
a2593 1
         offset_reg = brw_imm_ud(const_offset->u32[0]);
d2599 99
a2697 2
      do_untyped_vector_read(bld, dest, surf_index, offset_reg,
                             instr->num_components);
d2699 3
a2707 3
      if (stage == MESA_SHADER_FRAGMENT)
         brw_wm_prog_data(prog_data)->has_side_effects = true;

d2714 1
a2714 1
                          const_uniform_block->u32[0];
a2732 22
      /* get_nir_src() retypes to integer. Be wary of 64-bit types though
       * since the untyped writes below operate in units of 32-bits, which
       * means that we need to write twice as many components each time.
       * Also, we have to suffle 64-bit data to be in the appropriate layout
       * expected by our 32-bit write messages.
       */
      unsigned type_size = 4;
      unsigned bit_size = instr->src[0].is_ssa ?
         instr->src[0].ssa->bit_size : instr->src[0].reg.reg->bit_size;
      if (bit_size == 64) {
         type_size = 8;
         fs_reg tmp =
           fs_reg(VGRF, alloc.allocate(alloc.sizes[val_reg.nr]), val_reg.type);
         shuffle_64bit_data_for_32bit_write(bld,
            retype(tmp, BRW_REGISTER_TYPE_F),
            retype(val_reg, BRW_REGISTER_TYPE_DF),
            instr->num_components);
         val_reg = tmp;
      }

      unsigned type_slots = type_size / 4;

a2741 7
         /* We can't write more than 2 64-bit components at once. Limit the
          * length of the write to what we can do and let the next iteration
          * handle the rest
          */
         if (type_size > 4)
            length = MIN2(2, length);

d2745 1
a2745 2
            offset_reg = brw_imm_ud(const_offset->u32[0] +
                                    type_size * first_component);
d2750 1
a2750 1
                    brw_imm_ud(type_size * first_component));
a2752 1

d2754 2
a2755 2
                            offset(val_reg, bld, first_component * type_slots),
                            1 /* dims */, length * type_slots,
d2768 2
d2773 1
a2773 2
      fs_reg new_dest = retype(offset(outputs[instr->const_index[0]], bld,
                                      4 * const_offset->u32[0]), src.type);
d2775 2
a2776 17
      unsigned num_components = instr->num_components;
      unsigned first_component = nir_intrinsic_component(instr);
      unsigned bit_size = instr->src[0].is_ssa ?
         instr->src[0].ssa->bit_size : instr->src[0].reg.reg->bit_size;
      if (bit_size == 64) {
         fs_reg tmp =
            fs_reg(VGRF, alloc.allocate(2 * num_components),
                   BRW_REGISTER_TYPE_F);
         shuffle_64bit_data_for_32bit_write(
            bld, tmp, retype(src, BRW_REGISTER_TYPE_DF), num_components);
         src = retype(tmp, src.type);
         num_components *= 2;
      }

      for (unsigned j = 0; j < num_components; j++) {
         bld.MOV(offset(new_dest, bld, j + first_component),
                 offset(src, bld, j));
d2814 2
a2815 1
      unsigned ssbo_index = const_uniform_block ? const_uniform_block->u32[0] : 0;
d2817 2
a2818 11
      /* A resinfo's sampler message is used to get the buffer size.  The
       * SIMD8's writeback message consists of four registers and SIMD16's
       * writeback message consists of 8 destination registers (two per each
       * component).  Because we are only interested on the first channel of
       * the first returned component, where resinfo returns the buffer size
       * for SURFTYPE_BUFFER, we can just use the SIMD8 variant regardless of
       * the dispatch width.
       */
      const fs_builder ubld = bld.exec_all().group(8, 0);
      fs_reg src_payload = ubld.vgrf(BRW_REGISTER_TYPE_UD);
      fs_reg ret_payload = ubld.vgrf(BRW_REGISTER_TYPE_UD, 4);
d2820 1
a2820 2
      /* Set LOD = 0 */
      ubld.MOV(src_payload, brw_imm_d(0));
d2822 13
d2836 2
a2837 2
      fs_inst *inst = ubld.emit(FS_OPCODE_GET_BUFFER_SIZE, ret_payload,
                                src_payload, brw_imm_ud(index));
d2839 4
a2842 2
      inst->mlen = 1;
      inst->size_written = 4 * REG_SIZE;
a2843 1
      bld.MOV(retype(dest, ret_payload.type), component(ret_payload, 0));
a2847 15
   case nir_intrinsic_load_channel_num: {
      fs_reg tmp = bld.vgrf(BRW_REGISTER_TYPE_UW);
      dest = retype(dest, BRW_REGISTER_TYPE_UD);
      const fs_builder allbld8 = bld.group(8, 0).exec_all();
      allbld8.MOV(tmp, brw_imm_v(0x76543210));
      if (dispatch_width > 8)
         allbld8.ADD(byte_offset(tmp, 16), tmp, brw_imm_uw(8u));
      if (dispatch_width > 16) {
         const fs_builder allbld16 = bld.group(16, 0).exec_all();
         allbld16.ADD(byte_offset(tmp, 32), tmp, brw_imm_uw(16u));
      }
      bld.MOV(dest, tmp);
      break;
   }

a2856 3
   if (stage == MESA_SHADER_FRAGMENT)
      brw_wm_prog_data(prog_data)->has_side_effects = true;

d2865 1
a2865 1
                            const_surface->u32[0];
d2887 1
a2887 1
   /* Emit the actual atomic operation */
d2889 6
a2894 5
   fs_reg atomic_result = emit_untyped_atomic(bld, surface, offset,
                                              data1, data2,
                                              1 /* dims */, 1 /* rsize */,
                                              op,
                                              BRW_PREDICATE_NONE);
d2908 1
a2908 1
   fs_reg offset;
a2913 11
   /* Get the offset */
   nir_const_value *const_offset = nir_src_as_const_value(instr->src[0]);
   if (const_offset) {
      offset = brw_imm_ud(instr->const_index[0] + const_offset->u32[0]);
   } else {
      offset = vgrf(glsl_type::uint_type);
      bld.ADD(offset,
	      retype(get_nir_src(instr->src[0]), BRW_REGISTER_TYPE_UD),
	      brw_imm_ud(instr->const_index[0]));
   }

d2916 6
a2921 5
   fs_reg atomic_result = emit_untyped_atomic(bld, surface, offset,
                                              data1, data2,
                                              1 /* dims */, 1 /* rsize */,
                                              op,
                                              BRW_PREDICATE_NONE);
d2931 2
d2934 1
a2934 1
   fs_reg srcs[TEX_LOGICAL_NUM_SRCS];
d2936 2
a2937 2
   srcs[TEX_LOGICAL_SRC_SURFACE] = brw_imm_ud(texture);
   srcs[TEX_LOGICAL_SRC_SAMPLER] = brw_imm_ud(sampler);
d2941 1
a2941 3
   /* The hardware requires a LOD for buffer textures */
   if (instr->sampler_dim == GLSL_SAMPLER_DIM_BUF)
      srcs[TEX_LOGICAL_SRC_LOD] = brw_imm_d(0);
d2947 1
a2947 2
         srcs[TEX_LOGICAL_SRC_LOD] =
            retype(get_nir_src_imm(instr->src[i].src), BRW_REGISTER_TYPE_F);
d2950 1
a2950 1
         srcs[TEX_LOGICAL_SRC_SHADOW_C] = retype(src, BRW_REGISTER_TYPE_F);
a2955 1
         case nir_texop_txf_ms_mcs:
d2957 1
a2957 1
            srcs[TEX_LOGICAL_SRC_COORDINATE] = retype(src, BRW_REGISTER_TYPE_D);
d2960 1
a2960 1
            srcs[TEX_LOGICAL_SRC_COORDINATE] = retype(src, BRW_REGISTER_TYPE_F);
d2965 1
a2965 1
         srcs[TEX_LOGICAL_SRC_LOD] = retype(src, BRW_REGISTER_TYPE_F);
d2969 1
a2969 1
         srcs[TEX_LOGICAL_SRC_LOD2] = retype(src, BRW_REGISTER_TYPE_F);
d2974 1
a2974 2
            srcs[TEX_LOGICAL_SRC_LOD] =
               retype(get_nir_src_imm(instr->src[i].src), BRW_REGISTER_TYPE_UD);
d2977 1
a2977 2
            srcs[TEX_LOGICAL_SRC_LOD] =
               retype(get_nir_src_imm(instr->src[i].src), BRW_REGISTER_TYPE_D);
d2980 1
a2980 2
            srcs[TEX_LOGICAL_SRC_LOD] =
               retype(get_nir_src_imm(instr->src[i].src), BRW_REGISTER_TYPE_F);
d2985 1
a2985 1
         srcs[TEX_LOGICAL_SRC_SAMPLE_INDEX] = retype(src, BRW_REGISTER_TYPE_UD);
d2992 1
a2992 3
            unsigned header_bits = brw_texture_offset(const_offset->i32, 3);
            if (header_bits != 0)
               srcs[TEX_LOGICAL_SRC_OFFSET_VALUE] = brw_imm_ud(header_bits);
d2994 1
a2994 2
            srcs[TEX_LOGICAL_SRC_OFFSET_VALUE] =
               retype(src, BRW_REGISTER_TYPE_D);
d3013 3
a3015 3
         fs_reg tmp = vgrf(glsl_type::uint_type);
         bld.ADD(tmp, src, brw_imm_ud(texture));
         srcs[TEX_LOGICAL_SRC_SURFACE] = bld.emit_uniformize(tmp);
d3021 3
a3023 21
         fs_reg tmp = vgrf(glsl_type::uint_type);
         bld.ADD(tmp, src, brw_imm_ud(sampler));
         srcs[TEX_LOGICAL_SRC_SAMPLER] = bld.emit_uniformize(tmp);
         break;
      }

      case nir_tex_src_ms_mcs:
         assert(instr->op == nir_texop_txf_ms);
         srcs[TEX_LOGICAL_SRC_MCS] = retype(src, BRW_REGISTER_TYPE_D);
         break;

      case nir_tex_src_plane: {
         nir_const_value *const_plane =
            nir_src_as_const_value(instr->src[i].src);
         const uint32_t plane = const_plane->u32[0];
         const uint32_t texture_index =
            instr->texture_index +
            stage_prog_data->binding_table.plane_start[plane] -
            stage_prog_data->binding_table.texture_start;

         srcs[TEX_LOGICAL_SRC_SURFACE] = brw_imm_ud(texture_index);
d3032 2
a3033 3
   if (srcs[TEX_LOGICAL_SRC_MCS].file == BAD_FILE &&
       (instr->op == nir_texop_txf_ms ||
        instr->op == nir_texop_samples_identical)) {
d3036 1
a3036 4
         srcs[TEX_LOGICAL_SRC_MCS] =
            emit_mcs_fetch(srcs[TEX_LOGICAL_SRC_COORDINATE],
                           instr->coord_components,
                           srcs[TEX_LOGICAL_SRC_SURFACE]);
d3038 1
a3038 1
         srcs[TEX_LOGICAL_SRC_MCS] = brw_imm_ud(0u);
d3042 2
a3043 2
   srcs[TEX_LOGICAL_SRC_COORD_COMPONENTS] = brw_imm_d(instr->coord_components);
   srcs[TEX_LOGICAL_SRC_GRAD_COMPONENTS] = brw_imm_d(lod_components);
d3045 3
a3047 8
   if (instr->op == nir_texop_query_levels ||
       (instr->op == nir_texop_tex && stage != MESA_SHADER_FRAGMENT)) {
      /* textureQueryLevels() and texture() are implemented in terms of TXS
       * and TXL respectively, so we need to pass a valid LOD argument.
       */
      assert(srcs[TEX_LOGICAL_SRC_LOD].file == BAD_FILE);
      srcs[TEX_LOGICAL_SRC_LOD] = brw_imm_ud(0u);
   }
d3049 1
a3049 1
   enum opcode opcode;
d3051 11
a3061 43
   case nir_texop_tex:
      opcode = (stage == MESA_SHADER_FRAGMENT ? SHADER_OPCODE_TEX_LOGICAL :
                SHADER_OPCODE_TXL_LOGICAL);
      break;
   case nir_texop_txb:
      opcode = FS_OPCODE_TXB_LOGICAL;
      break;
   case nir_texop_txl:
      opcode = SHADER_OPCODE_TXL_LOGICAL;
      break;
   case nir_texop_txd:
      opcode = SHADER_OPCODE_TXD_LOGICAL;
      break;
   case nir_texop_txf:
      opcode = SHADER_OPCODE_TXF_LOGICAL;
      break;
   case nir_texop_txf_ms:
      if ((key_tex->msaa_16 & (1 << sampler)))
         opcode = SHADER_OPCODE_TXF_CMS_W_LOGICAL;
      else
         opcode = SHADER_OPCODE_TXF_CMS_LOGICAL;
      break;
   case nir_texop_txf_ms_mcs:
      opcode = SHADER_OPCODE_TXF_MCS_LOGICAL;
      break;
   case nir_texop_query_levels:
   case nir_texop_txs:
      opcode = SHADER_OPCODE_TXS_LOGICAL;
      break;
   case nir_texop_lod:
      opcode = SHADER_OPCODE_LOD_LOGICAL;
      break;
   case nir_texop_tg4:
      if (srcs[TEX_LOGICAL_SRC_OFFSET_VALUE].file != BAD_FILE &&
          srcs[TEX_LOGICAL_SRC_OFFSET_VALUE].file != IMM)
         opcode = SHADER_OPCODE_TG4_OFFSET_LOGICAL;
      else
         opcode = SHADER_OPCODE_TG4_LOGICAL;
      break;
   case nir_texop_texture_samples:
      opcode = SHADER_OPCODE_SAMPLEINFO_LOGICAL;
      break;
   case nir_texop_samples_identical: {
d3064 11
a3074 14
      /* If mcs is an immediate value, it means there is no MCS.  In that case
       * just return false.
       */
      if (srcs[TEX_LOGICAL_SRC_MCS].file == BRW_IMMEDIATE_VALUE) {
         bld.MOV(dst, brw_imm_ud(0u));
      } else if ((key_tex->msaa_16 & (1 << sampler))) {
         fs_reg tmp = vgrf(glsl_type::uint_type);
         bld.OR(tmp, srcs[TEX_LOGICAL_SRC_MCS],
                offset(srcs[TEX_LOGICAL_SRC_MCS], bld, 1));
         bld.CMP(dst, tmp, brw_imm_ud(0u), BRW_CONDITIONAL_EQ);
      } else {
         bld.CMP(dst, srcs[TEX_LOGICAL_SRC_MCS], brw_imm_ud(0u),
                 BRW_CONDITIONAL_EQ);
      }
d3077 1
d3082 11
a3092 53
   fs_reg dst = bld.vgrf(brw_type_for_nir_type(instr->dest_type), 4);
   fs_inst *inst = bld.emit(opcode, dst, srcs, ARRAY_SIZE(srcs));

   const unsigned dest_size = nir_tex_instr_dest_size(instr);
   if (devinfo->gen >= 9 &&
       instr->op != nir_texop_tg4 && instr->op != nir_texop_query_levels) {
      unsigned write_mask = instr->dest.is_ssa ?
                            nir_ssa_def_components_read(&instr->dest.ssa):
                            (1 << dest_size) - 1;
      assert(write_mask != 0); /* dead code should have been eliminated */
      inst->size_written = util_last_bit(write_mask) *
                           inst->dst.component_size(inst->exec_size);
   } else {
      inst->size_written = 4 * inst->dst.component_size(inst->exec_size);
   }

   if (srcs[TEX_LOGICAL_SRC_SHADOW_C].file != BAD_FILE)
      inst->shadow_compare = true;

   if (srcs[TEX_LOGICAL_SRC_OFFSET_VALUE].file == IMM)
      inst->offset = srcs[TEX_LOGICAL_SRC_OFFSET_VALUE].ud;

   if (instr->op == nir_texop_tg4) {
      if (instr->component == 1 &&
          key_tex->gather_channel_quirk_mask & (1 << texture)) {
         /* gather4 sampler is broken for green channel on RG32F --
          * we must ask for blue instead.
          */
         inst->offset |= 2 << 16;
      } else {
         inst->offset |= instr->component << 16;
      }

      if (devinfo->gen == 6)
         emit_gen6_gather_wa(key_tex->gen6_gather_wa[texture], dst);
   }

   fs_reg nir_dest[4];
   for (unsigned i = 0; i < dest_size; i++)
      nir_dest[i] = offset(dst, bld, i);

   if (instr->op == nir_texop_query_levels) {
      /* # levels is in .w */
      nir_dest[0] = offset(dst, bld, 3);
   } else if (instr->op == nir_texop_txs &&
              dest_size >= 3 && devinfo->gen < 7) {
      /* Gen4-6 return 0 instead of 1 for single layer surfaces. */
      fs_reg depth = offset(dst, bld, 2);
      nir_dest[2] = vgrf(glsl_type::int_type);
      bld.emit_minmax(nir_dest[2], depth, brw_imm_d(1), BRW_CONDITIONAL_GE);
   }

   bld.LOAD_PAYLOAD(get_nir_dest(instr->dest), nir_dest, dest_size, 0);
a3108 135
}

/**
 * This helper takes the result of a load operation that reads 32-bit elements
 * in this format:
 *
 * x x x x x x x x
 * y y y y y y y y
 * z z z z z z z z
 * w w w w w w w w
 *
 * and shuffles the data to get this:
 *
 * x y x y x y x y
 * x y x y x y x y
 * z w z w z w z w
 * z w z w z w z w
 *
 * Which is exactly what we want if the load is reading 64-bit components
 * like doubles, where x represents the low 32-bit of the x double component
 * and y represents the high 32-bit of the x double component (likewise with
 * z and w for double component y). The parameter @@components represents
 * the number of 64-bit components present in @@src. This would typically be
 * 2 at most, since we can only fit 2 double elements in the result of a
 * vec4 load.
 *
 * Notice that @@dst and @@src can be the same register.
 */
void
shuffle_32bit_load_result_to_64bit_data(const fs_builder &bld,
                                        const fs_reg &dst,
                                        const fs_reg &src,
                                        uint32_t components)
{
   assert(type_sz(src.type) == 4);
   assert(type_sz(dst.type) == 8);

   /* A temporary that we will use to shuffle the 32-bit data of each
    * component in the vector into valid 64-bit data. We can't write directly
    * to dst because dst can be (and would usually be) the same as src
    * and in that case the first MOV in the loop below would overwrite the
    * data read in the second MOV.
    */
   fs_reg tmp = bld.vgrf(dst.type);

   for (unsigned i = 0; i < components; i++) {
      const fs_reg component_i = offset(src, bld, 2 * i);

      bld.MOV(subscript(tmp, src.type, 0), component_i);
      bld.MOV(subscript(tmp, src.type, 1), offset(component_i, bld, 1));

      bld.MOV(offset(dst, bld, i), tmp);
   }
}

/**
 * This helper does the inverse operation of
 * SHUFFLE_32BIT_LOAD_RESULT_TO_64BIT_DATA.
 *
 * We need to do this when we are going to use untyped write messsages that
 * operate with 32-bit components in order to arrange our 64-bit data to be
 * in the expected layout.
 *
 * Notice that callers of this function, unlike in the case of the inverse
 * operation, would typically need to call this with dst and src being
 * different registers, since they would otherwise corrupt the original
 * 64-bit data they are about to write. Because of this the function checks
 * that the src and dst regions involved in the operation do not overlap.
 */
void
shuffle_64bit_data_for_32bit_write(const fs_builder &bld,
                                   const fs_reg &dst,
                                   const fs_reg &src,
                                   uint32_t components)
{
   assert(type_sz(src.type) == 8);
   assert(type_sz(dst.type) == 4);

   assert(!regions_overlap(
             dst, 2 * components * dst.component_size(bld.dispatch_width()),
             src, components * src.component_size(bld.dispatch_width())));

   for (unsigned i = 0; i < components; i++) {
      const fs_reg component_i = offset(src, bld, i);
      bld.MOV(offset(dst, bld, 2 * i), subscript(component_i, dst.type, 0));
      bld.MOV(offset(dst, bld, 2 * i + 1), subscript(component_i, dst.type, 1));
   }
}

fs_reg
setup_imm_df(const fs_builder &bld, double v)
{
   const struct gen_device_info *devinfo = bld.shader->devinfo;
   assert(devinfo->gen >= 7);

   if (devinfo->gen >= 8)
      return brw_imm_df(v);

   /* gen7.5 does not support DF immediates straighforward but the DIM
    * instruction allows to set the 64-bit immediate value.
    */
   if (devinfo->is_haswell) {
      const fs_builder ubld = bld.exec_all();
      fs_reg dst = ubld.vgrf(BRW_REGISTER_TYPE_DF, 1);
      ubld.DIM(dst, brw_imm_df(v));
      return component(dst, 0);
   }

   /* gen7 does not support DF immediates, so we generate a 64-bit constant by
    * writing the low 32-bit of the constant to suboffset 0 of a VGRF and
    * the high 32-bit to suboffset 4 and then applying a stride of 0.
    *
    * Alternatively, we could also produce a normal VGRF (without stride 0)
    * by writing to all the channels in the VGRF, however, that would hit the
    * gen7 bug where we have to split writes that span more than 1 register
    * into instructions with a width of 4 (otherwise the write to the second
    * register written runs into an execmask hardware bug) which isn't very
    * nice.
    */
   union {
      double d;
      struct {
         uint32_t i1;
         uint32_t i2;
      };
   } di;

   di.d = v;

   const fs_builder ubld = bld.exec_all().group(1, 0);
   const fs_reg tmp = ubld.vgrf(BRW_REGISTER_TYPE_UD, 2);
   ubld.MOV(tmp, brw_imm_ud(di.i1));
   ubld.MOV(horiz_offset(tmp, 1), brw_imm_ud(di.i2));

   return component(retype(tmp, BRW_REGISTER_TYPE_DF), 0);
@


1.1.1.5
log
@Import Mesa 13.0.6
@
text
@d1167 29
d2037 1
a2037 1
                  retype(brw_vec8_grf(first_icp_handle, 0), icp_handle.type),
d2068 1
a2068 1
                  retype(brw_vec8_grf(first_icp_handle, 0), icp_handle.type),
d2408 1
a2408 1
                  retype(brw_vec8_grf(1, 0), icp_handle.type), vertex_offset_bytes,
d3979 9
a3987 2
         bool supports_64bit_indirects =
            !devinfo->is_cherryview && !devinfo->is_broxton;
d3989 2
a3990 2
         if (type_sz(dest.type) != 8 || supports_64bit_indirects) {
            for (unsigned j = 0; j < instr->num_components; j++) {
d3994 10
a4003 16
            }
         } else {
            const unsigned num_mov_indirects =
               type_sz(dest.type) / type_sz(BRW_REGISTER_TYPE_UD);
            /* We read a little bit less per MOV INDIRECT, as they are now
             * 32-bits ones instead of 64-bit. Fix read_size then.
             */
            const unsigned read_size_32bit = read_size -
                (num_mov_indirects - 1) * type_sz(BRW_REGISTER_TYPE_UD);
            for (unsigned j = 0; j < instr->num_components; j++) {
               for (unsigned i = 0; i < num_mov_indirects; i++) {
                  bld.emit(SHADER_OPCODE_MOV_INDIRECT,
                           subscript(offset(dest, bld, j), BRW_REGISTER_TYPE_UD, i),
                           subscript(offset(src, bld, j), BRW_REGISTER_TYPE_UD, i),
                           indirect, brw_imm_ud(read_size_32bit));
               }
@


