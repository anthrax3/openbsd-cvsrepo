head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.2
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.1.1.3.0.2
	OPENBSD_6_1_BASE:1.1.1.3
	mesa-13_0_6:1.1.1.3
	mesa-13_0_5:1.1.1.3
	mesa-13_0_3:1.1.1.3
	mesa-13_0_2:1.1.1.3
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2017.08.26.16.59.36;	author jsg;	state Exp;
branches;
next	1.2;
commitid	D0k2io1oY8gcsQ2S;

1.2
date	2017.08.14.09.58.00;	author jsg;	state dead;
branches;
next	1.1;
commitid	bC4bLqwWTo4kLw82;

1.1
date	2015.11.22.02.40.50;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.40.50;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.16.09;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	OwGfrJACrYJkCVJ4;

1.1.1.3
date	2016.12.11.08.37.38;	author jsg;	state Exp;
branches;
next	;
commitid	uuv5VTS15jglEDZU;


desc
@@


1.3
log
@Revert to Mesa 13.0.6 to hopefully address rendering issues a handful of
people have reported with xpdf/fvwm on ivy bridge with modesetting driver.
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2014 Intel Corporation.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "glheader.h"
#include "context.h"
#include "enums.h"
#include "imports.h"
#include "macros.h"
#include "teximage.h"
#include "texobj.h"
#include "fbobject.h"
#include "framebuffer.h"
#include "buffers.h"
#include "state.h"
#include "mtypes.h"
#include "meta.h"

/**
 * Create a texture image that wraps a renderbuffer.
 */
static struct gl_texture_image *
wrap_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
   GLenum texTarget;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;

   if (rb->NumSamples > 1)
      texTarget = GL_TEXTURE_2D_MULTISAMPLE;
   else
      texTarget = GL_TEXTURE_2D;

   /* Texture ID is not significant since it never goes into the hash table */
   texObj = ctx->Driver.NewTextureObject(ctx, 0, texTarget);
   assert(texObj);
   if (!texObj)
      return NULL;

   texImage = _mesa_get_tex_image(ctx, texObj, texTarget, 0);
   assert(texImage);
   if (!texImage)
      return NULL;

   if (!ctx->Driver.BindRenderbufferTexImage(ctx, rb, texImage)) {
      _mesa_problem(ctx, "Failed to create texture from renderbuffer");
      return NULL;
   }

   if (ctx->Driver.FinishRenderTexture && !rb->NeedsFinishRenderTexture) {
      rb->NeedsFinishRenderTexture = true;
      ctx->Driver.FinishRenderTexture(ctx, rb);
   }

   return texImage;
}


/* This function makes a texture view without bothering with all of the API
 * checks.  Most of them are the same for CopyTexSubImage so checking would
 * be redundant.  The one major difference is that we don't check for
 * whether the texture is immutable or not.  However, since the view will
 * be created and then immediately destroyed, this should not be a problem.
 */
static bool
make_view(struct gl_context *ctx, struct gl_texture_image *tex_image,
          struct gl_texture_image **view_tex_image, GLuint *view_tex_name,
          GLenum internal_format)
{
   struct gl_texture_object *tex_obj = tex_image->TexObject;
   struct gl_texture_object *view_tex_obj;
   mesa_format tex_format;

   /* Set up the new texture object */
   _mesa_GenTextures(1, view_tex_name);
   view_tex_obj = _mesa_lookup_texture(ctx, *view_tex_name);
   if (!view_tex_obj)
      return false;

   tex_format = _mesa_choose_texture_format(ctx, view_tex_obj, tex_obj->Target,
                                           0, internal_format,
                                           GL_NONE, GL_NONE);

   if (!ctx->Driver.TestProxyTexImage(ctx, tex_obj->Target, 1, 0, tex_format,
                                      1, tex_image->Width, tex_image->Height,
                                      tex_image->Depth)) {
      _mesa_DeleteTextures(1, view_tex_name);
      *view_tex_name = 0;
      return false;
   }

   assert(tex_obj->Target != 0);
   assert(tex_obj->TargetIndex < NUM_TEXTURE_TARGETS);

   view_tex_obj->Target = tex_obj->Target;
   view_tex_obj->TargetIndex = tex_obj->TargetIndex;

   *view_tex_image = _mesa_get_tex_image(ctx, view_tex_obj, tex_obj->Target, 0);

   if (!*view_tex_image) {
      _mesa_DeleteTextures(1, view_tex_name);
      *view_tex_name = 0;
      return false;
   }

   _mesa_init_teximage_fields(ctx, *view_tex_image,
                              tex_image->Width, tex_image->Height,
                              tex_image->Depth,
                              0, internal_format, tex_format);

   view_tex_obj->MinLevel = tex_image->Level;
   view_tex_obj->NumLevels = 1;
   view_tex_obj->MinLayer = tex_obj->MinLayer;
   view_tex_obj->NumLayers = tex_obj->NumLayers;
   view_tex_obj->Immutable = tex_obj->Immutable;
   view_tex_obj->ImmutableLevels = tex_obj->ImmutableLevels;

   if (ctx->Driver.TextureView != NULL &&
       !ctx->Driver.TextureView(ctx, view_tex_obj, tex_obj)) {
      _mesa_DeleteTextures(1, view_tex_name);
      *view_tex_name = 0;
      return false; /* driver recorded error */
   }

   return true;
}

/** A partial implementation of glCopyImageSubData
 *
 * This is a partial implementation of glCopyImageSubData that works only
 * if both textures are uncompressed and the destination texture is
 * renderable.  It uses a slight abuse of a texture view (see make_view) to
 * turn the source texture into the destination texture type and then uses
 * _mesa_meta_BlitFramebuffers to do the copy.
 */
bool
_mesa_meta_CopyImageSubData_uncompressed(struct gl_context *ctx,
                                         struct gl_texture_image *src_tex_image,
                                         struct gl_renderbuffer *src_renderbuffer,
                                         int src_x, int src_y, int src_z,
                                         struct gl_texture_image *dst_tex_image,
                                         struct gl_renderbuffer *dst_renderbuffer,
                                         int dst_x, int dst_y, int dst_z,
                                         int src_width, int src_height)
{
   mesa_format src_format, dst_format;
   GLint src_internal_format, dst_internal_format;
   GLuint src_view_texture = 0;
   struct gl_texture_image *src_view_tex_image;
   struct gl_framebuffer *readFb;
   struct gl_framebuffer *drawFb = NULL;
   bool success = false;
   GLbitfield mask;
   GLenum status, attachment;

   if (src_renderbuffer) {
      src_format = src_renderbuffer->Format;
      src_internal_format = src_renderbuffer->InternalFormat;
   } else {
      assert(src_tex_image);
      src_format = src_tex_image->TexFormat;
      src_internal_format = src_tex_image->InternalFormat;
   }

   if (dst_renderbuffer) {
      dst_format = dst_renderbuffer->Format;
      dst_internal_format = dst_renderbuffer->InternalFormat;
   } else {
      assert(dst_tex_image);
      dst_format = dst_tex_image->TexFormat;
      dst_internal_format = dst_tex_image->InternalFormat;
   }

   if (_mesa_is_format_compressed(src_format))
      return false;

   if (_mesa_is_format_compressed(dst_format))
      return false;

   if (src_internal_format == dst_internal_format) {
      src_view_tex_image = src_tex_image;
   } else {
      if (src_renderbuffer) {
         assert(src_tex_image == NULL);
         src_tex_image = wrap_renderbuffer(ctx, src_renderbuffer);
      }
      if (!make_view(ctx, src_tex_image, &src_view_tex_image, &src_view_texture,
                     dst_internal_format))
         goto cleanup;
   }

   /* We really only need to stash the bound framebuffers and scissor. */
   _mesa_meta_begin(ctx, MESA_META_SCISSOR);

   readFb = ctx->Driver.NewFramebuffer(ctx, 0xDEADBEEF);
   if (readFb == NULL)
      goto meta_end;

   drawFb = ctx->Driver.NewFramebuffer(ctx, 0xDEADBEEF);
   if (drawFb == NULL)
      goto meta_end;

   _mesa_bind_framebuffers(ctx, drawFb, readFb);

   switch (_mesa_get_format_base_format(src_format)) {
   case GL_DEPTH_COMPONENT:
      attachment = GL_DEPTH_ATTACHMENT;
      mask = GL_DEPTH_BUFFER_BIT;
      break;
   case GL_DEPTH_STENCIL:
      attachment = GL_DEPTH_STENCIL_ATTACHMENT;
      mask = GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT;
      break;
   case GL_STENCIL_INDEX:
      attachment = GL_STENCIL_ATTACHMENT;
      mask = GL_STENCIL_BUFFER_BIT;
      break;
   default:
      attachment = GL_COLOR_ATTACHMENT0;
      mask = GL_COLOR_BUFFER_BIT;
      _mesa_DrawBuffer(GL_COLOR_ATTACHMENT0);
      _mesa_ReadBuffer(GL_COLOR_ATTACHMENT0);
   }

   if (src_view_tex_image) {
      /* Prefer the tex image because, even if we have a renderbuffer, we may
       * have had to wrap it in a texture view.
       */
      _mesa_meta_framebuffer_texture_image(ctx, ctx->ReadBuffer, attachment,
                                           src_view_tex_image, src_z);
   } else {
      _mesa_framebuffer_renderbuffer(ctx, ctx->ReadBuffer, attachment,
                                     src_renderbuffer);
   }

   status = _mesa_check_framebuffer_status(ctx, ctx->ReadBuffer);
   if (status != GL_FRAMEBUFFER_COMPLETE)
      goto meta_end;

   if (dst_renderbuffer) {
      _mesa_framebuffer_renderbuffer(ctx, ctx->DrawBuffer, attachment,
                                     dst_renderbuffer);
   } else {
      _mesa_meta_framebuffer_texture_image(ctx, ctx->DrawBuffer, attachment,
                                           dst_tex_image, dst_z);
   }

   status = _mesa_check_framebuffer_status(ctx, ctx->DrawBuffer);
   if (status != GL_FRAMEBUFFER_COMPLETE)
      goto meta_end;

   /* Explicitly disable sRGB encoding */
   ctx->DrawBuffer->Visual.sRGBCapable = false;

   /* Since we've bound a new draw framebuffer, we need to update its
    * derived state -- _Xmin, etc -- for BlitFramebuffer's clipping to
    * be correct.
    */
   _mesa_update_state(ctx);

   /* We skip the core BlitFramebuffer checks for format consistency.
    * We have already created views to ensure that the texture formats
    * match.
    */
   ctx->Driver.BlitFramebuffer(ctx, ctx->ReadBuffer, ctx->DrawBuffer,
                               src_x, src_y,
                               src_x + src_width, src_y + src_height,
                               dst_x, dst_y,
                               dst_x + src_width, dst_y + src_height,
                               mask, GL_NEAREST);

   success = true;

meta_end:
   _mesa_reference_framebuffer(&readFb, NULL);
   _mesa_reference_framebuffer(&drawFb, NULL);
   _mesa_meta_end(ctx);

cleanup:
   _mesa_DeleteTextures(1, &src_view_texture);

   /* If we got a renderbuffer source, delete the temporary texture */
   if (src_renderbuffer && src_tex_image)
      ctx->Driver.DeleteTexture(ctx, src_tex_image->TexObject);

   return success;
}
@


1.2
log
@Merge Mesa 17.1.6
@
text
@d33 1
d39 40
d104 3
a106 3
   if (!ctx->Driver.TestProxyTexImage(ctx, tex_obj->Target, 0, tex_format,
                                      tex_image->Width, tex_image->Height,
                                      tex_image->Depth, 0)) {
d112 3
d116 1
a136 1
   view_tex_obj->Target = tex_obj->Target;
d159 1
d162 1
d166 2
d170 2
a171 1
   GLuint fbos[2];
d176 19
a194 1
   if (_mesa_is_format_compressed(dst_tex_image->TexFormat))
d197 1
a197 1
   if (_mesa_is_format_compressed(src_tex_image->TexFormat))
d200 1
a200 1
   if (src_tex_image->InternalFormat == dst_tex_image->InternalFormat) {
d203 4
d208 1
a208 1
                     dst_tex_image->InternalFormat))
d215 9
a223 3
   _mesa_GenFramebuffers(2, fbos);
   _mesa_BindFramebuffer(GL_READ_FRAMEBUFFER, fbos[0]);
   _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER, fbos[1]);
d225 1
a225 1
   switch (_mesa_get_format_base_format(src_tex_image->TexFormat)) {
d245 10
a254 2
   _mesa_meta_bind_fbo_image(GL_READ_FRAMEBUFFER, attachment,
                             src_view_tex_image, src_z);
d256 1
a256 1
   status = _mesa_CheckFramebufferStatus(GL_READ_FRAMEBUFFER);
d260 7
a266 2
   _mesa_meta_bind_fbo_image(GL_DRAW_FRAMEBUFFER, attachment,
                             dst_tex_image, dst_z);
d268 1
a268 1
   status = _mesa_CheckFramebufferStatus(GL_DRAW_FRAMEBUFFER);
d272 3
d295 2
a296 1
   _mesa_DeleteFramebuffers(2, fbos);
d301 4
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@a37 40
/**
 * Create a texture image that wraps a renderbuffer.
 */
static struct gl_texture_image *
wrap_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
   GLenum texTarget;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;

   if (rb->NumSamples > 1)
      texTarget = GL_TEXTURE_2D_MULTISAMPLE;
   else
      texTarget = GL_TEXTURE_2D;

   /* Texture ID is not significant since it never goes into the hash table */
   texObj = ctx->Driver.NewTextureObject(ctx, 0, texTarget);
   assert(texObj);
   if (!texObj)
      return NULL;

   texImage = _mesa_get_tex_image(ctx, texObj, texTarget, 0);
   assert(texImage);
   if (!texImage)
      return NULL;

   if (!ctx->Driver.BindRenderbufferTexImage(ctx, rb, texImage)) {
      _mesa_problem(ctx, "Failed to create texture from renderbuffer");
      return NULL;
   }

   if (ctx->Driver.FinishRenderTexture && !rb->NeedsFinishRenderTexture) {
      rb->NeedsFinishRenderTexture = true;
      ctx->Driver.FinishRenderTexture(ctx, rb);
   }

   return texImage;
}


a70 3
   assert(tex_obj->Target != 0);
   assert(tex_obj->TargetIndex < NUM_TEXTURE_TARGETS);

a71 1
   view_tex_obj->TargetIndex = tex_obj->TargetIndex;
d92 1
a114 1
                                         struct gl_renderbuffer *src_renderbuffer,
a116 1
                                         struct gl_renderbuffer *dst_renderbuffer,
a119 2
   mesa_format src_format, dst_format;
   GLint src_internal_format, dst_internal_format;
d127 1
a127 19
   if (src_renderbuffer) {
      src_format = src_renderbuffer->Format;
      src_internal_format = src_renderbuffer->InternalFormat;
   } else {
      assert(src_tex_image);
      src_format = src_tex_image->TexFormat;
      src_internal_format = src_tex_image->InternalFormat;
   }

   if (dst_renderbuffer) {
      dst_format = dst_renderbuffer->Format;
      dst_internal_format = dst_renderbuffer->InternalFormat;
   } else {
      assert(dst_tex_image);
      dst_format = dst_tex_image->TexFormat;
      dst_internal_format = dst_tex_image->InternalFormat;
   }

   if (_mesa_is_format_compressed(src_format))
d130 1
a130 1
   if (_mesa_is_format_compressed(dst_format))
d133 1
a133 1
   if (src_internal_format == dst_internal_format) {
a135 4
      if (src_renderbuffer) {
         assert(src_tex_image == NULL);
         src_tex_image = wrap_renderbuffer(ctx, src_renderbuffer);
      }
d137 1
a137 1
                     dst_internal_format))
d148 1
a148 1
   switch (_mesa_get_format_base_format(src_format)) {
d168 2
a169 10
   if (src_view_tex_image) {
      /* Prefer the tex image because, even if we have a renderbuffer, we may
       * have had to wrap it in a texture view.
       */
      _mesa_meta_bind_fbo_image(GL_READ_FRAMEBUFFER, attachment,
                                src_view_tex_image, src_z);
   } else {
      _mesa_framebuffer_renderbuffer(ctx, ctx->ReadBuffer, attachment,
                                     src_renderbuffer);
   }
d175 2
a176 7
   if (dst_renderbuffer) {
      _mesa_framebuffer_renderbuffer(ctx, ctx->DrawBuffer, attachment,
                                     dst_renderbuffer);
   } else {
      _mesa_meta_bind_fbo_image(GL_DRAW_FRAMEBUFFER, attachment,
                                dst_tex_image, dst_z);
   }
a206 4

   /* If we got a renderbuffer source, delete the temporary texture */
   if (src_renderbuffer && src_tex_image)
      ctx->Driver.DeleteTexture(ctx, src_tex_image->TexObject);
@


1.1.1.3
log
@Import Mesa 13.0.2
@
text
@a32 1
#include "framebuffer.h"
d103 3
a105 3
   if (!ctx->Driver.TestProxyTexImage(ctx, tex_obj->Target, 1, 0, tex_format,
                                      1, tex_image->Width, tex_image->Height,
                                      tex_image->Depth)) {
d169 1
a169 2
   struct gl_framebuffer *readFb;
   struct gl_framebuffer *drawFb = NULL;
d213 3
a215 9
   readFb = ctx->Driver.NewFramebuffer(ctx, 0xDEADBEEF);
   if (readFb == NULL)
      goto meta_end;

   drawFb = ctx->Driver.NewFramebuffer(ctx, 0xDEADBEEF);
   if (drawFb == NULL)
      goto meta_end;

   _mesa_bind_framebuffers(ctx, drawFb, readFb);
d241 2
a242 2
      _mesa_meta_framebuffer_texture_image(ctx, ctx->ReadBuffer, attachment,
                                           src_view_tex_image, src_z);
d248 1
a248 1
   status = _mesa_check_framebuffer_status(ctx, ctx->ReadBuffer);
d256 2
a257 2
      _mesa_meta_framebuffer_texture_image(ctx, ctx->DrawBuffer, attachment,
                                           dst_tex_image, dst_z);
d260 1
a260 1
   status = _mesa_check_framebuffer_status(ctx, ctx->DrawBuffer);
a263 3
   /* Explicitly disable sRGB encoding */
   ctx->DrawBuffer->Visual.sRGBCapable = false;

d284 1
a284 2
   _mesa_reference_framebuffer(&readFb, NULL);
   _mesa_reference_framebuffer(&drawFb, NULL);
@


