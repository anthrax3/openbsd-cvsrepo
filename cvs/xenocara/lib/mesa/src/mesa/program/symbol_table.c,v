head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.4
	OPENBSD_6_2_BASE:1.1.1.2
	mesa-17_1_6:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.2
	OPENBSD_6_1_BASE:1.1.1.2
	mesa-13_0_6:1.1.1.2
	mesa-13_0_5:1.1.1.2
	mesa-13_0_3:1.1.1.2
	mesa-13_0_2:1.1.1.2
	OPENBSD_6_0:1.1.1.1.0.6
	OPENBSD_6_0_BASE:1.1.1.1
	mesa-11_2_2:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.38.30;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.38.30;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.12.11.08.39.29;	author jsg;	state Exp;
branches;
next	;
commitid	uuv5VTS15jglEDZU;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright Â© 2008 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "main/imports.h"
#include "symbol_table.h"
#include "hash_table.h"

struct symbol {
    /**
     * Link to the next symbol in the table with the same name
     *
     * The linked list of symbols with the same name is ordered by scope
     * from inner-most to outer-most.
     */
    struct symbol *next_with_same_name;


    /**
     * Link to the next symbol in the table with the same scope
     *
     * The linked list of symbols with the same scope is unordered.  Symbols
     * in this list my have unique names.
     */
    struct symbol *next_with_same_scope;


    /**
     * Header information for the list of symbols with the same name.
     */
    struct symbol_header *hdr;


    /**
     * Name space of the symbol
     *
     * Name space are arbitrary user assigned integers.  No two symbols can
     * exist in the same name space at the same scope level.
     */
    int name_space;

    /** Scope depth where this symbol was defined. */
    unsigned depth;

    /**
     * Arbitrary user supplied data.
     */
    void *data;
};


/**
 */
struct symbol_header {
    /** Linkage in list of all headers in a given symbol table. */
    struct symbol_header *next;

    /** Symbol name. */
    char *name;

    /** Linked list of symbols with the same name. */
    struct symbol *symbols;
};


/**
 * Element of the scope stack.
 */
struct scope_level {
    /** Link to next (inner) scope level. */
    struct scope_level *next;
    
    /** Linked list of symbols with the same scope. */
    struct symbol *symbols;
};


/**
 *
 */
struct _mesa_symbol_table {
    /** Hash table containing all symbols in the symbol table. */
    struct hash_table *ht;

    /** Top of scope stack. */
    struct scope_level *current_scope;

    /** List of all symbol headers in the table. */
    struct symbol_header *hdr;

    /** Current scope depth. */
    unsigned depth;
};


static void
check_symbol_table(struct _mesa_symbol_table *table)
{
#if !defined(NDEBUG)
    struct scope_level *scope;

    for (scope = table->current_scope; scope != NULL; scope = scope->next) {
        struct symbol *sym;

        for (sym = scope->symbols
             ; sym != NULL
             ; sym = sym->next_with_same_name) {
            const struct symbol_header *const hdr = sym->hdr;
            struct symbol *sym2;

            for (sym2 = hdr->symbols
                 ; sym2 != NULL
                 ; sym2 = sym2->next_with_same_name) {
                assert(sym2->hdr == hdr);
            }
        }
    }
#else
    (void) table;
#endif /* !defined(NDEBUG) */
}

void
_mesa_symbol_table_pop_scope(struct _mesa_symbol_table *table)
{
    struct scope_level *const scope = table->current_scope;
    struct symbol *sym = scope->symbols;

    table->current_scope = scope->next;
    table->depth--;

    free(scope);

    while (sym != NULL) {
        struct symbol *const next = sym->next_with_same_scope;
        struct symbol_header *const hdr = sym->hdr;

        assert(hdr->symbols == sym);

        hdr->symbols = sym->next_with_same_name;

        free(sym);

        sym = next;
    }

    check_symbol_table(table);
}


void
_mesa_symbol_table_push_scope(struct _mesa_symbol_table *table)
{
    struct scope_level *const scope = calloc(1, sizeof(*scope));
    
    if (scope == NULL) {
       _mesa_error_no_memory(__func__);
       return;
    }

    scope->next = table->current_scope;
    table->current_scope = scope;
    table->depth++;
}


static struct symbol_header *
find_symbol(struct _mesa_symbol_table *table, const char *name)
{
    return (struct symbol_header *) hash_table_find(table->ht, name);
}


/**
 * Determine the scope "distance" of a symbol from the current scope
 *
 * \return
 * A non-negative number for the number of scopes between the current scope
 * and the scope where a symbol was defined.  A value of zero means the current
 * scope.  A negative number if the symbol does not exist.
 */
int
_mesa_symbol_table_symbol_scope(struct _mesa_symbol_table *table,
				int name_space, const char *name)
{
    struct symbol_header *const hdr = find_symbol(table, name);
    struct symbol *sym;

    if (hdr != NULL) {
       for (sym = hdr->symbols; sym != NULL; sym = sym->next_with_same_name) {
	  assert(sym->hdr == hdr);

	  if ((name_space == -1) || (sym->name_space == name_space)) {
	     assert(sym->depth <= table->depth);
	     return sym->depth - table->depth;
	  }
       }
    }

    return -1;
}


void *
_mesa_symbol_table_find_symbol(struct _mesa_symbol_table *table,
                               int name_space, const char *name)
{
    struct symbol_header *const hdr = find_symbol(table, name);

    if (hdr != NULL) {
        struct symbol *sym;


        for (sym = hdr->symbols; sym != NULL; sym = sym->next_with_same_name) {
            assert(sym->hdr == hdr);

            if ((name_space == -1) || (sym->name_space == name_space)) {
                return sym->data;
            }
        }
    }

    return NULL;
}


int
_mesa_symbol_table_add_symbol(struct _mesa_symbol_table *table,
                              int name_space, const char *name,
                              void *declaration)
{
    struct symbol_header *hdr;
    struct symbol *sym;

    check_symbol_table(table);

    hdr = find_symbol(table, name);

    check_symbol_table(table);

    if (hdr == NULL) {
       hdr = calloc(1, sizeof(*hdr));
       if (hdr == NULL) {
          _mesa_error_no_memory(__func__);
          return -1;
       }

       hdr->name = strdup(name);
       if (hdr->name == NULL) {
          free(hdr);
          _mesa_error_no_memory(__func__);
          return -1;
       }

       hash_table_insert(table->ht, hdr, hdr->name);
       hdr->next = table->hdr;
       table->hdr = hdr;
    }

    check_symbol_table(table);

    /* If the symbol already exists in this namespace at this scope, it cannot
     * be added to the table.
     */
    for (sym = hdr->symbols
	 ; (sym != NULL) && (sym->name_space != name_space)
	 ; sym = sym->next_with_same_name) {
       /* empty */
    }

    if (sym && (sym->depth == table->depth))
       return -1;

    sym = calloc(1, sizeof(*sym));
    if (sym == NULL) {
       _mesa_error_no_memory(__func__);
       return -1;
    }

    sym->next_with_same_name = hdr->symbols;
    sym->next_with_same_scope = table->current_scope->symbols;
    sym->hdr = hdr;
    sym->name_space = name_space;
    sym->data = declaration;
    sym->depth = table->depth;

    assert(sym->hdr == hdr);

    hdr->symbols = sym;
    table->current_scope->symbols = sym;

    check_symbol_table(table);
    return 0;
}


int
_mesa_symbol_table_add_global_symbol(struct _mesa_symbol_table *table,
				     int name_space, const char *name,
				     void *declaration)
{
    struct symbol_header *hdr;
    struct symbol *sym;
    struct symbol *curr;
    struct scope_level *top_scope;

    check_symbol_table(table);

    hdr = find_symbol(table, name);

    check_symbol_table(table);

    if (hdr == NULL) {
        hdr = calloc(1, sizeof(*hdr));
        if (hdr == NULL) {
           _mesa_error_no_memory(__func__);
           return -1;
        }

        hdr->name = strdup(name);

        hash_table_insert(table->ht, hdr, hdr->name);
        hdr->next = table->hdr;
        table->hdr = hdr;
    }

    check_symbol_table(table);

    /* If the symbol already exists in this namespace at this scope, it cannot
     * be added to the table.
     */
    for (sym = hdr->symbols
	 ; (sym != NULL) && (sym->name_space != name_space)
	 ; sym = sym->next_with_same_name) {
       /* empty */
    }

    if (sym && sym->depth == 0)
       return -1;

    /* Find the top-level scope */
    for (top_scope = table->current_scope
	 ; top_scope->next != NULL
	 ; top_scope = top_scope->next) {
       /* empty */
    }

    sym = calloc(1, sizeof(*sym));
    if (sym == NULL) {
       _mesa_error_no_memory(__func__);
       return -1;
    }

    sym->next_with_same_scope = top_scope->symbols;
    sym->hdr = hdr;
    sym->name_space = name_space;
    sym->data = declaration;

    assert(sym->hdr == hdr);

    /* Since next_with_same_name is ordered by scope, we need to append the
     * new symbol to the _end_ of the list.
     */
    if (hdr->symbols == NULL) {
       hdr->symbols = sym;
    } else {
       for (curr = hdr->symbols
	    ; curr->next_with_same_name != NULL
	    ; curr = curr->next_with_same_name) {
	  /* empty */
       }
       curr->next_with_same_name = sym;
    }
    top_scope->symbols = sym;

    check_symbol_table(table);
    return 0;
}



struct _mesa_symbol_table *
_mesa_symbol_table_ctor(void)
{
    struct _mesa_symbol_table *table = calloc(1, sizeof(*table));

    if (table != NULL) {
       table->ht = hash_table_ctor(32, hash_table_string_hash,
				   hash_table_string_compare);

       _mesa_symbol_table_push_scope(table);
    }

    return table;
}


void
_mesa_symbol_table_dtor(struct _mesa_symbol_table *table)
{
   struct symbol_header *hdr;
   struct symbol_header *next;

   while (table->current_scope != NULL) {
      _mesa_symbol_table_pop_scope(table);
   }

   for (hdr = table->hdr; hdr != NULL; hdr = next) {
       next = hdr->next;
       free(hdr->name);
       free(hdr);
   }

   hash_table_dtor(table->ht);
   free(table);
}
@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 13.0.2
@
text
@d26 1
a26 1
#include "../../util/hash_table.h"
a28 3
   /** Symbol name. */
   char *name;

d37 1
d46 15
d72 14
d107 3
d114 28
d155 5
a159 12
        struct hash_entry *hte = _mesa_hash_table_search(table->ht,
                                                         sym->name);
        if (sym->next_with_same_name) {
           /* If there is a symbol with this name in an outer scope update
            * the hash table to point to it.
            */
           hte->key = sym->next_with_same_name->name;
           hte->data = sym->next_with_same_name;
        } else {
           _mesa_hash_table_remove(table->ht, hte);
           free(sym->name);
        }
d162 1
d165 2
d174 1
d186 1
a186 1
static struct symbol *
d189 1
a189 2
   struct hash_entry *entry = _mesa_hash_table_search(table->ht, name);
   return entry ? (struct symbol *) entry->data : NULL;
d203 1
a203 1
                                const char *name)
d205 2
a206 1
   struct symbol *const sym = find_symbol(table, name);
d208 10
a217 4
   if (sym) {
      assert(sym->depth <= table->depth);
      return sym->depth - table->depth;
   }
d219 1
a219 1
   return -1;
d225 1
a225 1
                               const char *name)
d227 14
a240 3
   struct symbol *const sym = find_symbol(table, name);
   if (sym)
      return sym->data;
d242 1
a242 1
   return NULL;
d248 2
a249 1
                              const char *name, void *declaration)
d251 2
a252 2
   struct symbol *new_sym;
   struct symbol *sym = find_symbol(table, name);
d254 1
a254 2
   if (sym && sym->depth == table->depth)
      return -1;
d256 1
a256 5
   new_sym = calloc(1, sizeof(*sym));
   if (new_sym == NULL) {
      _mesa_error_no_memory(__func__);
      return -1;
   }
d258 1
a258 12
   if (sym) {
      /* Store link to symbol in outer scope with the same name */
      new_sym->next_with_same_name = sym;
      new_sym->name = sym->name;
   } else {
      new_sym->name = strdup(name);
      if (new_sym->name == NULL) {
         free(new_sym);
         _mesa_error_no_memory(__func__);
         return -1;
      }
   }
d260 18
a277 3
   new_sym->next_with_same_scope = table->current_scope->symbols;
   new_sym->data = declaration;
   new_sym->depth = table->depth;
d279 1
a279 1
   table->current_scope->symbols = new_sym;
d281 8
a288 1
   _mesa_hash_table_insert(table->ht, new_sym->name, new_sym);
d290 2
a291 2
   return 0;
}
d293 3
a295 9
int
_mesa_symbol_table_replace_symbol(struct _mesa_symbol_table *table,
                                  const char *name,
                                  void *declaration)
{
    struct symbol *sym = find_symbol(table, name);

    /* If the symbol doesn't exist, it cannot be replaced. */
    if (sym == NULL)
d297 1
d299 4
d304 8
d315 1
d318 2
a319 1
                                     const char *name, void *declaration)
d321 19
a339 7
   struct scope_level *top_scope;
   struct symbol *inner_sym = NULL;
   struct symbol *sym = find_symbol(table, name);

   while (sym) {
      if (sym->depth == 0)
         return -1;
d341 6
a346 1
      inner_sym = sym;
d348 8
a355 3
      /* Get symbol from the outer scope with the same name */
      sym = sym->next_with_same_name;
   }
d357 2
a358 5
   /* Find the top-level scope */
   for (top_scope = table->current_scope; top_scope->next != NULL;
        top_scope = top_scope->next) {
      /* empty */
   }
d360 6
a365 5
   sym = calloc(1, sizeof(*sym));
   if (sym == NULL) {
      _mesa_error_no_memory(__func__);
      return -1;
   }
d367 5
a371 15
   if (inner_sym) {
      /* In case we add the global out of order store a link to the global
       * symbol in global.
       */
      inner_sym->next_with_same_name = sym;

      sym->name = inner_sym->name;
   } else {
      sym->name = strdup(name);
      if (sym->name == NULL) {
         free(sym);
         _mesa_error_no_memory(__func__);
         return -1;
      }
   }
d373 4
a376 2
   sym->next_with_same_scope = top_scope->symbols;
   sym->data = declaration;
d378 1
a378 1
   top_scope->symbols = sym;
d380 14
a393 1
   _mesa_hash_table_insert(table->ht, sym->name, sym);
d395 2
a396 1
   return 0;
d407 2
a408 2
       table->ht = _mesa_hash_table_create(NULL, _mesa_key_hash_string,
                                           _mesa_key_string_equal);
d420 3
d427 7
a433 1
   _mesa_hash_table_destroy(table->ht, NULL);
@

