head	1.1;
branch	1.1.1;
access;
symbols
	mesa-13_0_6:1.1.1.2
	mesa-13_0_5:1.1.1.2
	mesa-13_0_3:1.1.1.2
	mesa-13_0_2:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.4
	OPENBSD_6_0_BASE:1.1.1.2
	mesa-11_2_2:1.1.1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	mesa-11_0_9:1.1.1.1
	mesa-11_0_8:1.1.1.1
	mesa-11_0_6:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2015.11.22.02.38.22;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bJUptkbooQfJPk5r;

1.1.1.1
date	2015.11.22.02.38.22;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	bJUptkbooQfJPk5r;

1.1.1.2
date	2016.05.29.10.13.32;	author jsg;	state Exp;
branches;
next	;
commitid	OwGfrJACrYJkCVJ4;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keithw@@vmware.com>
 */


/**
 * \file t_dd_dmatmp.h
 * Template for render stages which build and emit vertices directly
 * to fixed-size dma buffers.  Useful for rendering strips and other
 * native primitives where clipping and per-vertex tweaks such as
 * those in t_dd_tritmp.h are not required.
 *
 * Produces code for both inline triangles and indexed triangles.
 * Where various primitive types are unaccelerated by hardware, the
 * code attempts to fallback to other primitive types (quadstrips to
 * tristrips, lineloops to linestrips), or to indexed vertices.
 */

#if !defined(HAVE_TRIANGLES)
#error "must have at least triangles to use render template"
#endif

#if !HAVE_ELTS
#define ELTS_VARS(buf)
#define ALLOC_ELTS(nr) 0
#define EMIT_ELT( offset, elt )
#define EMIT_TWO_ELTS( offset, elt0, elt1 )
#define INCR_ELTS( nr )
#define ELT_INIT(prim)
#define GET_CURRENT_VB_MAX_ELTS() 0
#define GET_SUBSEQUENT_VB_MAX_ELTS() 0
#define RELEASE_ELT_VERTS()
#define EMIT_INDEXED_VERTS( ctx, start, count )
#endif

#ifndef EMIT_TWO_ELTS
#define EMIT_TWO_ELTS( offset, elt0, elt1 )	\
do { 						\
   EMIT_ELT( offset, elt0 ); 			\
   EMIT_ELT( offset+1, elt1 ); 			\
} while (0)
#endif


/**********************************************************************/
/*                  Render whole begin/end objects                    */
/**********************************************************************/




#if (HAVE_ELTS)
static void *TAG(emit_elts)( struct gl_context *ctx, GLuint *elts, GLuint nr,
			     void *buf)
{
   GLint i;
   LOCAL_VARS;
   ELTS_VARS(buf);

   for ( i = 0 ; i+1 < nr ; i+=2, elts += 2 ) {
      EMIT_TWO_ELTS( 0, elts[0], elts[1] );
      INCR_ELTS( 2 );
   }
   
   if (i < nr) {
      EMIT_ELT( 0, elts[0] );
      INCR_ELTS( 1 );
   }

   return (void *)ELTPTR;
}
#endif

static __inline void *TAG(emit_verts)( struct gl_context *ctx, GLuint start, 
				     GLuint count, void *buf )
{
   return EMIT_VERTS(ctx, start, count, buf);
}

/***********************************************************************
 *                    Render non-indexed primitives.
 ***********************************************************************/

static void TAG(render_points_verts)( struct gl_context *ctx,
				      GLuint start,
				      GLuint count,
				      GLuint flags )
{
   if (HAVE_POINTS) {
      LOCAL_VARS;
      int dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
      int currentsz;
      GLuint j, nr;

      INIT( GL_POINTS );

      currentsz = GET_CURRENT_VB_MAX_VERTS();
      if (currentsz < 8)
	 currentsz = dmasz;

      for (j = 0; j < count; j += nr) {
	 nr = MIN2( currentsz, count - j );
         TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
	 currentsz = dmasz;
      }

   } else {
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}

static void TAG(render_lines_verts)( struct gl_context *ctx,
				     GLuint start,
				     GLuint count,
				     GLuint flags )
{
   if (HAVE_LINES) {
      LOCAL_VARS;
      int dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
      int currentsz;
      GLuint j, nr;

      INIT( GL_LINES );

      /* Emit whole number of lines in total and in each buffer:
       */
      count -= count & 1;
      currentsz = GET_CURRENT_VB_MAX_VERTS();
      currentsz -= currentsz & 1;
      dmasz -= dmasz & 1;

      if (currentsz < 8)
	 currentsz = dmasz;

      for (j = 0; j < count; j += nr) {
	 nr = MIN2( currentsz, count - j );
         TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
	 currentsz = dmasz;
      }

   } else {
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}


static void TAG(render_line_strip_verts)( struct gl_context *ctx,
					  GLuint start,
					  GLuint count,
					  GLuint flags )
{
   if (HAVE_LINE_STRIPS) {
      LOCAL_VARS;
      int dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
      int currentsz;
      GLuint j, nr;

      INIT( GL_LINE_STRIP );

      currentsz = GET_CURRENT_VB_MAX_VERTS();
      if (currentsz < 8)
	 currentsz = dmasz;

      for (j = 0; j + 1 < count; j += nr - 1 ) {
	 nr = MIN2( currentsz, count - j );
         TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
	 currentsz = dmasz;
      }
 
      FLUSH();

   } else {
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}


static void TAG(render_line_loop_verts)( struct gl_context *ctx,
					 GLuint start,
					 GLuint count,
					 GLuint flags )
{
   if (HAVE_LINE_STRIPS) {
      LOCAL_VARS;
      int dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
      int currentsz;
      GLuint j, nr;

      INIT( GL_LINE_STRIP );

      j = (flags & PRIM_BEGIN) ? 0 : 1;

      /* Ensure last vertex won't wrap buffers:
       */
      currentsz = GET_CURRENT_VB_MAX_VERTS();
      currentsz--;
      dmasz--;

      if (currentsz < 8) {
	 currentsz = dmasz;
      }

      if (j + 1 < count) {
	 for ( ; j + 1 < count; j += nr - 1 ) {
	    nr = MIN2( currentsz, count - j );

	    if (j + nr >= count &&
		count > 1 &&
		(flags & PRIM_END)) 
	    {
	       void *tmp;
	       tmp = ALLOC_VERTS(nr+1);
               tmp = TAG(emit_verts)(ctx, start + j, nr, tmp);
	       tmp = TAG(emit_verts)( ctx, start, 1, tmp );
	       (void) tmp;
	    }
	    else {
               TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
	       currentsz = dmasz;
	    }
	 }

      }
      else if (count > 1 && (flags & PRIM_END)) {
	 void *tmp;
	 tmp = ALLOC_VERTS(2);
	 tmp = TAG(emit_verts)( ctx, start+1, 1, tmp );
	 tmp = TAG(emit_verts)( ctx, start, 1, tmp );
	 (void) tmp;
      }

      FLUSH();

   } else {
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}


static void TAG(render_triangles_verts)( struct gl_context *ctx,
					 GLuint start,
					 GLuint count,
					 GLuint flags )
{
   LOCAL_VARS;
   int dmasz = (GET_SUBSEQUENT_VB_MAX_VERTS()/3) * 3;
   int currentsz;
   GLuint j, nr;

   INIT(GL_TRIANGLES);

   currentsz = (GET_CURRENT_VB_MAX_VERTS()/3) * 3;

   /* Emit whole number of tris in total.  dmasz is already a multiple
    * of 3.
    */
   count -= count % 3;

   if (currentsz < 8)
      currentsz = dmasz;

   for (j = 0; j < count; j += nr) {
      nr = MIN2( currentsz, count - j );
      TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
      currentsz = dmasz;
   }
}



static void TAG(render_tri_strip_verts)( struct gl_context *ctx,
					 GLuint start,
					 GLuint count,
					 GLuint flags )
{
   if (HAVE_TRI_STRIPS) {
      LOCAL_VARS;
      GLuint j, nr;
      int dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
      int currentsz;

      INIT(GL_TRIANGLE_STRIP);

      currentsz = GET_CURRENT_VB_MAX_VERTS();

      if (currentsz < 8) {
	 currentsz = dmasz;
      }

      /* From here on emit even numbers of tris when wrapping over buffers:
       */
      dmasz -= (dmasz & 1);
      currentsz -= (currentsz & 1);

      for (j = 0; j + 2 < count; j += nr - 2) {
	 nr = MIN2( currentsz, count - j );
         TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
	 currentsz = dmasz;
      }

      FLUSH();

   } else {
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}

static void TAG(render_tri_fan_verts)( struct gl_context *ctx,
				       GLuint start,
				       GLuint count,
				       GLuint flags )
{
   if (HAVE_TRI_FANS) {
      LOCAL_VARS;
      GLuint j, nr;
      int dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
      int currentsz;

      INIT(GL_TRIANGLE_FAN);

      currentsz = GET_CURRENT_VB_MAX_VERTS();
      if (currentsz < 8) {
	 currentsz = dmasz;
      }

      for (j = 1; j + 1 < count; j += nr - 2) {
	 void *tmp;
	 nr = MIN2( currentsz, count - j + 1 );
	 tmp = ALLOC_VERTS( nr );
	 tmp = TAG(emit_verts)( ctx, start, 1, tmp );
         tmp = TAG(emit_verts)( ctx, start + j, nr - 1, tmp );
	 (void) tmp;
	 currentsz = dmasz;
      }

      FLUSH();
   }
   else {
      /* Could write code to emit these as indexed vertices (for the
       * g400, for instance).
       */
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}


static void TAG(render_poly_verts)( struct gl_context *ctx,
				    GLuint start,
				    GLuint count,
				    GLuint flags )
{
   if (HAVE_POLYGONS) {
      LOCAL_VARS;
      GLuint j, nr;
      int dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
      int currentsz;

      INIT(GL_POLYGON);

      currentsz = GET_CURRENT_VB_MAX_VERTS();
      if (currentsz < 8) {
	 currentsz = dmasz;
      }

      for (j = 1 ; j + 1 < count ; j += nr - 2 ) {
	 void *tmp;
	 nr = MIN2( currentsz, count - j + 1 );
	 tmp = ALLOC_VERTS( nr );
	 tmp = TAG(emit_verts)( ctx, start, 1, tmp );
         tmp = TAG(emit_verts)(ctx, start + j, nr - 1, tmp);
	 (void) tmp;
	 currentsz = dmasz;
      }

      FLUSH();
   }
   else if (HAVE_TRI_FANS && ctx->Light.ShadeModel == GL_SMOOTH) {
      TAG(render_tri_fan_verts)( ctx, start, count, flags );
   } else {
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}

static void TAG(render_quad_strip_verts)( struct gl_context *ctx,
					  GLuint start,
					  GLuint count,
					  GLuint flags )
{
   GLuint j, nr;

   if (HAVE_QUAD_STRIPS) {
      LOCAL_VARS;
      GLuint j, nr;
      int dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
      int currentsz;

      INIT(GL_QUAD_STRIP);

      currentsz = GET_CURRENT_VB_MAX_VERTS();
      if (currentsz < 8) {
	 currentsz = dmasz;
      }

      dmasz -= (dmasz & 2);
      currentsz -= (currentsz & 2);

      for (j = 0; j + 3 < count; j += nr - 2 ) {
	 nr = MIN2( currentsz, count - j );
         TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
	 currentsz = dmasz;
      }

      FLUSH();

   } else if (HAVE_TRI_STRIPS && 
	      ctx->Light.ShadeModel == GL_FLAT &&
	      TNL_CONTEXT(ctx)->vb.AttribPtr[_TNL_ATTRIB_COLOR0]->stride) {
      if (HAVE_ELTS) {
	 LOCAL_VARS;
	 int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS();
	 int currentsz;
	 GLuint j, nr;

         EMIT_INDEXED_VERTS( ctx, start, count );

	 /* Simulate flat-shaded quadstrips using indexed vertices:
	  */
	 ELT_INIT( GL_TRIANGLES );

	 currentsz = GET_CURRENT_VB_MAX_ELTS();

	 /* Emit whole number of quads in total, and in each buffer.
	  */
	 dmasz -= dmasz & 1;
	 count -= count & 1;
	 currentsz -= currentsz & 1;

	 if (currentsz < 12)
	    currentsz = dmasz;

	 currentsz = currentsz/6*2;
	 dmasz = dmasz/6*2;

	 for (j = 0; j + 3 < count; j += nr - 2) {
	    nr = MIN2( currentsz, count - j );
	    if (nr >= 4) {
	       GLint quads = (nr/2)-1;
	       GLint i;
	       ELTS_VARS( ALLOC_ELTS( quads*6 ) );

               for (i = j; i < j + quads * 2; i += 2) {
		  EMIT_TWO_ELTS( 0, (i+0), (i+1) );
		  EMIT_TWO_ELTS( 2, (i+2), (i+1) );
		  EMIT_TWO_ELTS( 4, (i+3), (i+2) );
		  INCR_ELTS( 6 );
	       }

	       FLUSH();
	    }
	    currentsz = dmasz;
	 }

	 RELEASE_ELT_VERTS();
	 FLUSH();
      }
      else {
	 /* Vertices won't fit in a single buffer or elts not
	  * available - should never happen.
	  */
        fprintf(stderr, "%s - cannot draw primitive\n", __func__);
	 return;
      }
   }
   else if (HAVE_TRI_STRIPS) {
      LOCAL_VARS;
      int dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
      int currentsz;

      /* Emit smooth-shaded quadstrips as tristrips:
       */
      FLUSH();
      INIT( GL_TRIANGLE_STRIP );

      /* Emit whole number of quads in total, and in each buffer.
       */
      dmasz -= dmasz & 1;
      currentsz = GET_CURRENT_VB_MAX_VERTS();
      currentsz -= currentsz & 1;
      count -= count & 1;

      if (currentsz < 8) {
	 currentsz = dmasz;
      }

      for (j = 0; j + 3 < count; j += nr - 2) {
	 nr = MIN2( currentsz, count - j );
         TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
	 currentsz = dmasz;
      }

      FLUSH();

   } else {
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}


static void TAG(render_quads_verts)( struct gl_context *ctx,
				     GLuint start,
				     GLuint count,
				     GLuint flags )
{
   /* Emit whole number of quads in total. */
   count -= count & 3;

   if (HAVE_QUADS) {
      LOCAL_VARS;
      int dmasz = (GET_SUBSEQUENT_VB_MAX_VERTS()/4) * 4;
      int currentsz;
      GLuint j, nr;

      INIT(GL_QUADS);

      currentsz = (GET_CURRENT_VB_MAX_VERTS()/4) * 4;
      if (currentsz < 8)
         currentsz = dmasz;

      for (j = 0; j < count; j += nr) {
         nr = MIN2( currentsz, count - j );
         TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
         currentsz = dmasz;
      }
   }
   else if (HAVE_ELTS) {
      /* Hardware doesn't have a quad primitive type -- try to
       * simulate it using indexed vertices and the triangle
       * primitive:
       */
      LOCAL_VARS;
      int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS();
      int currentsz;
      GLuint j, nr;

      EMIT_INDEXED_VERTS( ctx, start, count );

      FLUSH();
      ELT_INIT( GL_TRIANGLES );
      currentsz = GET_CURRENT_VB_MAX_ELTS();

      /* Emit whole number of quads in total, and in each buffer.
       */
      dmasz -= dmasz & 3;
      currentsz -= currentsz & 3;

      /* Adjust for rendering as triangles:
       */
      currentsz = currentsz/6*4;
      dmasz = dmasz/6*4;

      if (currentsz < 8)
	 currentsz = dmasz;

      for (j = 0; j < count; j += nr ) {
	 nr = MIN2( currentsz, count - j );
	 if (nr >= 4) {
	    GLint quads = nr/4;
	    GLint i;
	    ELTS_VARS( ALLOC_ELTS( quads*6 ) );

            for (i = j; i < j + quads * 4; i += 4) {
	       EMIT_TWO_ELTS( 0, (i+0), (i+1) );
	       EMIT_TWO_ELTS( 2, (i+3), (i+1) );
	       EMIT_TWO_ELTS( 4, (i+2), (i+3) );
	       INCR_ELTS( 6 );
	    }

	    FLUSH();
	 }
	 currentsz = dmasz;
      }

      RELEASE_ELT_VERTS();
   }
   else if (HAVE_TRIANGLES) {
      /* Hardware doesn't have a quad primitive type -- try to
       * simulate it using triangle primitive.  This is a win for
       * gears, but is it useful in the broader world?
       */
      LOCAL_VARS;
      GLuint j;

      INIT(GL_TRIANGLES);

      for (j = 0; j + 3 < count; j += 4) {
	 void *tmp = ALLOC_VERTS( 6 );
	 /* Send v0, v1, v3
	  */
	 tmp = EMIT_VERTS(ctx, start + j,     2, tmp);
	 tmp = EMIT_VERTS(ctx, start + j + 3, 1, tmp);
	 /* Send v1, v2, v3
	  */
	 tmp = EMIT_VERTS(ctx, start + j + 1, 3, tmp);
	 (void) tmp;
      }
   }
   else {
      /* Vertices won't fit in a single buffer, should never happen.
       */
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}

static void TAG(render_noop)( struct gl_context *ctx,
			      GLuint start,
			      GLuint count,
			      GLuint flags )
{
}




static tnl_render_func TAG(render_tab_verts)[GL_POLYGON+2] =
{
   TAG(render_points_verts),
   TAG(render_lines_verts),
   TAG(render_line_loop_verts),
   TAG(render_line_strip_verts),
   TAG(render_triangles_verts),
   TAG(render_tri_strip_verts),
   TAG(render_tri_fan_verts),
   TAG(render_quads_verts),
   TAG(render_quad_strip_verts),
   TAG(render_poly_verts),
   TAG(render_noop),
};


/****************************************************************************
 *                 Render elts using hardware indexed verts                 *
 ****************************************************************************/

#if (HAVE_ELTS)
static void TAG(render_points_elts)( struct gl_context *ctx,
				     GLuint start,
				     GLuint count,
				     GLuint flags )
{
   if (HAVE_POINTS) {
      LOCAL_VARS;
      int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS();
      int currentsz;
      GLuint *elts = TNL_CONTEXT(ctx)->vb.Elts;
      GLuint j, nr;

      ELT_INIT( GL_POINTS );

      currentsz = GET_CURRENT_VB_MAX_ELTS();
      if (currentsz < 8)
	 currentsz = dmasz;

      for (j = 0; j < count; j += nr ) {
	 nr = MIN2( currentsz, count - j );
         TAG(emit_elts)(ctx, elts + start + j, nr, ALLOC_ELTS(nr));
	 FLUSH();
	 currentsz = dmasz;
      }
   } else {
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}



static void TAG(render_lines_elts)( struct gl_context *ctx,
				    GLuint start,
				    GLuint count,
				    GLuint flags )
{
   if (HAVE_LINES) {
      LOCAL_VARS;
      int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS();
      int currentsz;
      GLuint *elts = TNL_CONTEXT(ctx)->vb.Elts;
      GLuint j, nr;

      ELT_INIT( GL_LINES );

      /* Emit whole number of lines in total and in each buffer:
       */
      count -= count & 1;
      currentsz -= currentsz & 1;
      dmasz -= dmasz & 1;

      currentsz = GET_CURRENT_VB_MAX_ELTS();
      if (currentsz < 8)
	 currentsz = dmasz;

      for (j = 0; j < count; j += nr ) {
	 nr = MIN2( currentsz, count - j );
         TAG(emit_elts)(ctx, elts + start + j, nr, ALLOC_ELTS(nr));
	 FLUSH();
	 currentsz = dmasz;
      }
   } else {
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}


static void TAG(render_line_strip_elts)( struct gl_context *ctx,
					 GLuint start,
					 GLuint count,
					 GLuint flags )
{
   if (HAVE_LINE_STRIPS) {
      LOCAL_VARS;
      int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS();
      int currentsz;
      GLuint *elts = TNL_CONTEXT(ctx)->vb.Elts;
      GLuint j, nr;

      FLUSH(); /* always a new primitive */
      ELT_INIT( GL_LINE_STRIP );

      currentsz = GET_CURRENT_VB_MAX_ELTS();
      if (currentsz < 8)
	 currentsz = dmasz;

      for (j = 0; j + 1 < count; j += nr - 1) {
	 nr = MIN2( currentsz, count - j );
         TAG(emit_elts)( ctx, elts + start + j, nr, ALLOC_ELTS(nr));
	 FLUSH();
	 currentsz = dmasz;
      }
   } else {
      /* TODO: Try to emit as indexed lines.
       */
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}


static void TAG(render_line_loop_elts)( struct gl_context *ctx,
					GLuint start,
					GLuint count,
					GLuint flags )
{
   if (HAVE_LINE_STRIPS) {
      LOCAL_VARS;
      int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS();
      int currentsz;
      GLuint *elts = TNL_CONTEXT(ctx)->vb.Elts;
      GLuint j, nr;

      FLUSH();
      ELT_INIT( GL_LINE_STRIP );

      j = (flags & PRIM_BEGIN) ? 0 : 1;

      currentsz = GET_CURRENT_VB_MAX_ELTS();
      if (currentsz < 8) {
	 currentsz = dmasz;
      }

      /* Ensure last vertex doesn't wrap:
       */
      currentsz--;
      dmasz--;

      if (j + 1 < count) {
	 for ( ; j + 1 < count; j += nr - 1 ) {
	    nr = MIN2( currentsz, count - j );

	    if (j + nr >= count &&
		count > 1 &&
		(flags & PRIM_END)) 
	    {
	       void *tmp;
	       tmp = ALLOC_ELTS(nr+1);
               tmp = TAG(emit_elts)(ctx, elts + start + j, nr, tmp);
	       tmp = TAG(emit_elts)( ctx, elts+start, 1, tmp );
	       (void) tmp;
	    }
	    else {
               TAG(emit_elts)(ctx, elts + start + j, nr, ALLOC_ELTS(nr));
	       currentsz = dmasz;
	    }
	 }

      }
      else if (count > 1 && (flags & PRIM_END)) {
	 void *tmp;
	 tmp = ALLOC_ELTS(2);
	 tmp = TAG(emit_elts)( ctx, elts+start+1, 1, tmp );
	 tmp = TAG(emit_elts)( ctx, elts+start, 1, tmp );
	 (void) tmp;
      }

      FLUSH();
   } else {
      /* TODO: Try to emit as indexed lines */
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}


/* For verts, we still eliminate the copy from main memory to dma
 * buffers.  For elts, this is probably no better (worse?) than the
 * standard path.
 */
static void TAG(render_triangles_elts)( struct gl_context *ctx,
					GLuint start,
					GLuint count,
					GLuint flags )
{
   LOCAL_VARS;
   GLuint *elts = TNL_CONTEXT(ctx)->vb.Elts;
   int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS()/3*3;
   int currentsz;
   GLuint j, nr;

   FLUSH();
   ELT_INIT( GL_TRIANGLES );

   currentsz = GET_CURRENT_VB_MAX_ELTS();

   /* Emit whole number of tris in total.  dmasz is already a multiple
    * of 3.
    */
   count -= count % 3;
   currentsz -= currentsz%3;
   if (currentsz < 8)
      currentsz = dmasz;

   for (j = 0; j < count; j += nr) {
      nr = MIN2( currentsz, count - j );
      TAG(emit_elts)(ctx, elts + start + j, nr, ALLOC_ELTS(nr));
      FLUSH();
      currentsz = dmasz;
   }
}



static void TAG(render_tri_strip_elts)( struct gl_context *ctx,
					GLuint start,
					GLuint count,
					GLuint flags )
{
   if (HAVE_TRI_STRIPS) {
      LOCAL_VARS;
      GLuint j, nr;
      GLuint *elts = TNL_CONTEXT(ctx)->vb.Elts;
      int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS();
      int currentsz;

      FLUSH();
      ELT_INIT( GL_TRIANGLE_STRIP );

      currentsz = GET_CURRENT_VB_MAX_ELTS();
      if (currentsz < 8) {
	 currentsz = dmasz;
      }

      /* Keep the same winding over multiple buffers:
       */
      dmasz -= (dmasz & 1);
      currentsz -= (currentsz & 1);

      for (j = 0; j + 2 < count; j += nr - 2) {
	 nr = MIN2( currentsz, count - j );
	 TAG(emit_elts)( ctx, elts + start + j, nr, ALLOC_ELTS(nr) );
	 FLUSH();
	 currentsz = dmasz;
      }
   } else {
      /* TODO: try to emit as indexed triangles */
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}

static void TAG(render_tri_fan_elts)( struct gl_context *ctx,
				      GLuint start,
				      GLuint count,
				      GLuint flags )
{
   if (HAVE_TRI_FANS) {
      LOCAL_VARS;
      GLuint *elts = TNL_CONTEXT(ctx)->vb.Elts;
      GLuint j, nr;
      int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS();
      int currentsz;

      FLUSH();
      ELT_INIT( GL_TRIANGLE_FAN );

      currentsz = GET_CURRENT_VB_MAX_ELTS();
      if (currentsz < 8) {
	 currentsz = dmasz;
      }

      for (j = 1; j + 1 < count; j += nr - 2) {
	 void *tmp;
	 nr = MIN2( currentsz, count - j + 1 );
	 tmp = ALLOC_ELTS( nr );
	 tmp = TAG(emit_elts)( ctx, elts+start, 1, tmp );
         tmp = TAG(emit_elts)(ctx, elts + start + j, nr - 1, tmp);
	 (void) tmp;
	 FLUSH();
	 currentsz = dmasz;
      }
   } else {
      /* TODO: try to emit as indexed triangles */
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}


static void TAG(render_poly_elts)( struct gl_context *ctx,
				   GLuint start,
				   GLuint count,
				   GLuint flags )
{
   if (HAVE_POLYGONS) {
      LOCAL_VARS;
      GLuint *elts = TNL_CONTEXT(ctx)->vb.Elts;
      GLuint j, nr;
      int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS();
      int currentsz;

      FLUSH();
      ELT_INIT( GL_POLYGON );

      currentsz = GET_CURRENT_VB_MAX_ELTS();
      if (currentsz < 8) {
	 currentsz = dmasz;
      }

      for (j = 1 ; j + 1 < count; j += nr - 2) {
	 void *tmp;
	 nr = MIN2( currentsz, count - j + 1 );
	 tmp = ALLOC_ELTS( nr );
	 tmp = TAG(emit_elts)( ctx, elts+start, 1, tmp );
         tmp = TAG(emit_elts)(ctx, elts + start + j, nr - 1, tmp);
	 (void) tmp;
	 FLUSH();
	 currentsz = dmasz;
      }
   } else if (HAVE_TRI_FANS && ctx->Light.ShadeModel == GL_SMOOTH) {
      TAG(render_tri_fan_verts)( ctx, start, count, flags );
   } else {
      fprintf(stderr, "%s - cannot draw primitive\n", __func__);
      return;
   }
}

static void TAG(render_quad_strip_elts)( struct gl_context *ctx,
					 GLuint start,
					 GLuint count,
					 GLuint flags )
{
   if (HAVE_QUAD_STRIPS && 0) {
   }
   else if (HAVE_TRI_STRIPS) {
      LOCAL_VARS;
      GLuint *elts = TNL_CONTEXT(ctx)->vb.Elts;
      int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS();
      int currentsz;
      GLuint j, nr;

      FLUSH();
      currentsz = GET_CURRENT_VB_MAX_ELTS();

      /* Emit whole number of quads in total, and in each buffer.
       */
      dmasz -= dmasz & 1;
      count -= count & 1;
      currentsz -= currentsz & 1;

      if (currentsz < 12)
	 currentsz = dmasz;

      if (ctx->Light.ShadeModel == GL_FLAT) {
	 ELT_INIT( GL_TRIANGLES );

	 currentsz = currentsz/6*2;
	 dmasz = dmasz/6*2;

         for (j = 0; j + 3 < count; j += nr - 2) {
	    nr = MIN2( currentsz, count - j );

	    if (nr >= 4)
	    {
	       GLint i;
	       GLint quads = (nr/2)-1;
	       ELTS_VARS( ALLOC_ELTS( quads*6 ) );

               for (i = j; i < j + quads; i++, elts += 2) {
		  EMIT_TWO_ELTS( 0, elts[0], elts[1] );
		  EMIT_TWO_ELTS( 2, elts[2], elts[1] );
		  EMIT_TWO_ELTS( 4, elts[3], elts[2] );
		  INCR_ELTS( 6 );
	       }

	       FLUSH();
	    }

	    currentsz = dmasz;
	 }
      }
      else {
	 ELT_INIT( GL_TRIANGLE_STRIP );

         for (j = 0; j + 3 < count; j += nr - 2) {
	    nr = MIN2( currentsz, count - j );
            TAG(emit_elts)(ctx, elts + start + j, nr, ALLOC_ELTS(nr));
	    FLUSH();
	    currentsz = dmasz;
	 }
      }
   }
}


static void TAG(render_quads_elts)( struct gl_context *ctx,
				    GLuint start,
				    GLuint count,
				    GLuint flags )
{
   /* Emit whole number of quads in total. */
   count -= count & 3;

   if (HAVE_QUADS) {
      LOCAL_VARS;
      GLuint *elts = TNL_CONTEXT(ctx)->vb.Elts;
      int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS()/4*4;
      int currentsz;
      GLuint j, nr;

      FLUSH();
      ELT_INIT( GL_TRIANGLES );

      currentsz = GET_CURRENT_VB_MAX_ELTS()/4*4;

      if (currentsz < 8)
	 currentsz = dmasz;

      for (j = 0; j < count; j += nr) {
	 nr = MIN2( currentsz, count - j );
         TAG(emit_elts)(ctx, elts + start + j, nr, ALLOC_ELTS(nr));
	 FLUSH();
	 currentsz = dmasz;
      }
   } else {
      LOCAL_VARS;
      GLuint *elts = TNL_CONTEXT(ctx)->vb.Elts;
      int dmasz = GET_SUBSEQUENT_VB_MAX_ELTS();
      int currentsz;
      GLuint j, nr;

      ELT_INIT( GL_TRIANGLES );
      currentsz = GET_CURRENT_VB_MAX_ELTS();

      /* Emit whole number of quads in total, and in each buffer.
       */
      dmasz -= dmasz & 3;
      currentsz -= currentsz & 3;

      /* Adjust for rendering as triangles:
       */
      currentsz = currentsz/6*4;
      dmasz = dmasz/6*4;

      if (currentsz < 8)
	 currentsz = dmasz;

      for (j = 0; j + 3 < count; j += nr - 2) {
	 nr = MIN2( currentsz, count - j );

	 if (nr >= 4)
	 {
	    GLint quads = nr/4;
	    GLint i;
	    ELTS_VARS( ALLOC_ELTS( quads * 6 ) );

	    for (i = j; i < j + quads; i++, elts += 4) {
	       EMIT_TWO_ELTS( 0, elts[0], elts[1] );
	       EMIT_TWO_ELTS( 2, elts[3], elts[1] );
	       EMIT_TWO_ELTS( 4, elts[2], elts[3] );
	       INCR_ELTS( 6 );
	    }

	    FLUSH();
	 }

	 currentsz = dmasz;
      }
   }
}



static tnl_render_func TAG(render_tab_elts)[GL_POLYGON+2] =
{
   TAG(render_points_elts),
   TAG(render_lines_elts),
   TAG(render_line_loop_elts),
   TAG(render_line_strip_elts),
   TAG(render_triangles_elts),
   TAG(render_tri_strip_elts),
   TAG(render_tri_fan_elts),
   TAG(render_quads_elts),
   TAG(render_quad_strip_elts),
   TAG(render_poly_elts),
   TAG(render_noop),
};



#endif



/* Pre-check the primitives in the VB to prevent the need for
 * fallbacks later on.
 */
static GLboolean TAG(validate_render)( struct gl_context *ctx,
				       struct vertex_buffer *VB )
{
   GLint i;

   if (VB->ClipOrMask & ~CLIP_CULL_BIT)
      return GL_FALSE;

   if (VB->Elts && !HAVE_ELTS)
      return GL_FALSE;

   for (i = 0 ; i < VB->PrimitiveCount ; i++) {
      GLuint prim = VB->Primitive[i].mode;
      GLuint count = VB->Primitive[i].count;
      GLboolean ok = GL_FALSE;

      if (!count)
	 continue;

      switch (prim & PRIM_MODE_MASK) {
      case GL_POINTS:
	 ok = HAVE_POINTS;
	 break;
      case GL_LINES:
	 ok = HAVE_LINES && !ctx->Line.StippleFlag;
	 break;
      case GL_LINE_STRIP:
	 ok = HAVE_LINE_STRIPS && !ctx->Line.StippleFlag;
	 break;
      case GL_LINE_LOOP:
	 ok = HAVE_LINE_STRIPS && !ctx->Line.StippleFlag;
	 break;
      case GL_TRIANGLES:
	 ok = HAVE_TRIANGLES;
	 break;
      case GL_TRIANGLE_STRIP:
	 ok = HAVE_TRI_STRIPS;
	 break;
      case GL_TRIANGLE_FAN:
	 ok = HAVE_TRI_FANS;
	 break;
      case GL_POLYGON:
	 if (HAVE_POLYGONS) {
	    ok = GL_TRUE;
	 }
	 else {
	    ok = (HAVE_TRI_FANS && ctx->Light.ShadeModel == GL_SMOOTH);
         }
	 break;
      case GL_QUAD_STRIP:
	 if (VB->Elts) {
	    ok = HAVE_TRI_STRIPS;
	 }
	 else if (HAVE_QUAD_STRIPS) {
	    ok = GL_TRUE;
	 } else if (HAVE_TRI_STRIPS && 
		    ctx->Light.ShadeModel == GL_FLAT &&
		    VB->AttribPtr[_TNL_ATTRIB_COLOR0]->stride != 0) {
	    if (HAVE_ELTS) {
	       ok = (GLint) count < GET_SUBSEQUENT_VB_MAX_ELTS();
	    }
	    else {
	       ok = GL_FALSE;
	    }
	 }
	 else 
	    ok = HAVE_TRI_STRIPS;
	 break;
      case GL_QUADS:
	 if (HAVE_QUADS) {
	    ok = GL_TRUE;
	 } else if (HAVE_ELTS) {
	    ok = (GLint) count < GET_SUBSEQUENT_VB_MAX_ELTS();
	 }
	 else {
	    ok = HAVE_TRIANGLES; /* flatshading is ok. */
	 }
	 break;
      default:
	 break;
      }
      
      if (!ok) {
/* 	 fprintf(stderr, "not ok %s\n", _mesa_enum_to_string(prim & PRIM_MODE_MASK)); */
	 return GL_FALSE;
      }
   }

   return GL_TRUE;
}

@


1.1.1.1
log
@import Mesa 11.0.6
@
text
@@


1.1.1.2
log
@Import Mesa 11.2.2
@
text
@d27 1
a27 1
#include <stdbool.h>
d42 15
a56 2
#if !HAVE_TRIANGLES || !HAVE_LINES || !HAVE_LINE_STRIPS || !HAVE_TRI_STRIPS || !HAVE_TRI_FANS
#error "must have lines, line strips, triangles, triangle fans, and triangle strips to use render template"
d59 6
a64 2
#if HAVE_QUAD_STRIPS || HAVE_QUADS || HAVE_ELTS
#error "ELTs, quads, and quad strips not supported by render template"
d72 27
a98 2
static inline void *TAG(emit_verts)(struct gl_context *ctx, GLuint start,
                                    GLuint count, void *buf)
d107 4
a110 4
static void TAG(render_points_verts)(struct gl_context *ctx,
                                     GLuint start,
                                     GLuint count,
                                     GLuint flags)
d114 2
a115 2
      const unsigned dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
      unsigned currentsz;
d118 1
a118 1
      INIT(GL_POINTS);
d122 1
a122 1
         currentsz = dmasz;
d125 1
a125 1
         nr = MIN2(currentsz, count - j);
d127 1
a127 1
         currentsz = dmasz;
d129 1
d131 2
a132 2
      unreachable("Cannot draw primitive; validate_render should have "
                  "prevented this");
d136 4
a139 4
static void TAG(render_lines_verts)(struct gl_context *ctx,
                                    GLuint start,
                                    GLuint count,
                                    GLuint flags)
d141 5
a145 4
   LOCAL_VARS;
   const unsigned dmasz = GET_SUBSEQUENT_VB_MAX_VERTS() & ~1;
   unsigned currentsz;
   GLuint j, nr;
d147 1
a147 1
   INIT(GL_LINES);
d149 9
a157 5
   /* Emit whole number of lines in total and in each buffer:
    */
   count -= count & 1;
   currentsz = GET_CURRENT_VB_MAX_VERTS();
   currentsz -= currentsz & 1;
d159 5
a163 2
   if (currentsz < 8)
      currentsz = dmasz;
d165 3
a167 4
   for (j = 0; j < count; j += nr) {
      nr = MIN2(currentsz, count - j);
      TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
      currentsz = dmasz;
d172 4
a175 4
static void TAG(render_line_strip_verts)(struct gl_context *ctx,
                                         GLuint start,
                                         GLuint count,
                                         GLuint flags)
d177 7
a183 4
   LOCAL_VARS;
   const unsigned dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
   unsigned currentsz;
   GLuint j, nr;
d185 3
a187 1
   INIT(GL_LINE_STRIP);
d189 7
a195 3
   currentsz = GET_CURRENT_VB_MAX_VERTS();
   if (currentsz < 8)
      currentsz = dmasz;
d197 3
a199 4
   for (j = 0; j + 1 < count; j += nr - 1) {
      nr = MIN2(currentsz, count - j);
      TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
      currentsz = dmasz;
a200 2
 
   FLUSH();
d204 4
a207 4
static void TAG(render_line_loop_verts)(struct gl_context *ctx,
                                        GLuint start,
                                        GLuint count,
                                        GLuint flags)
d209 5
a213 4
   LOCAL_VARS;
   const unsigned dmasz = GET_SUBSEQUENT_VB_MAX_VERTS() - 1;
   unsigned currentsz;
   GLuint j, nr;
d215 1
a215 1
   INIT(GL_LINE_STRIP);
d217 1
a217 1
   j = (flags & PRIM_BEGIN) ? 0 : 1;
d219 9
a227 4
   /* Ensure last vertex won't wrap buffers:
    */
   currentsz = GET_CURRENT_VB_MAX_VERTS();
   currentsz--;
d229 19
a247 2
   if (currentsz < 8)
      currentsz = dmasz;
a248 16
   if (j + 1 < count) {
      for (/* empty */; j + 1 < count; j += nr - 1) {
         nr = MIN2(currentsz, count - j);

         if (j + nr >= count &&
             count > 1 &&
             (flags & PRIM_END)) {
            void *tmp;
            tmp = ALLOC_VERTS(nr+1);
            tmp = TAG(emit_verts)(ctx, start + j, nr, tmp);
            tmp = TAG(emit_verts)( ctx, start, 1, tmp );
            (void) tmp;
         } else {
            TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
            currentsz = dmasz;
         }
d250 13
a262 6
   } else if (count > 1 && (flags & PRIM_END)) {
      void *tmp;
      tmp = ALLOC_VERTS(2);
      tmp = TAG(emit_verts)( ctx, start+1, 1, tmp );
      tmp = TAG(emit_verts)( ctx, start, 1, tmp );
      (void) tmp;
a263 2

   FLUSH();
d267 4
a270 4
static void TAG(render_triangles_verts)(struct gl_context *ctx,
                                        GLuint start,
                                        GLuint count,
                                        GLuint flags)
d273 2
a274 2
   const unsigned dmasz = (GET_SUBSEQUENT_VB_MAX_VERTS() / 3) * 3;
   unsigned currentsz;
d279 1
a279 1
   currentsz = (GET_CURRENT_VB_MAX_VERTS() / 3) * 3;
d290 1
a290 1
      nr = MIN2(currentsz, count - j);
d298 4
a301 4
static void TAG(render_tri_strip_verts)(struct gl_context *ctx,
                                        GLuint start,
                                        GLuint count,
                                        GLuint flags)
d303 9
a311 4
   LOCAL_VARS;
   GLuint j, nr;
   const unsigned dmasz = GET_SUBSEQUENT_VB_MAX_VERTS() & ~1;
   unsigned currentsz;
d313 3
a315 1
   INIT(GL_TRIANGLE_STRIP);
d317 4
a320 1
   currentsz = GET_CURRENT_VB_MAX_VERTS();
d322 5
a326 2
   if (currentsz < 8)
      currentsz = dmasz;
d328 1
a328 3
   /* From here on emit even numbers of tris when wrapping over buffers:
    */
   currentsz -= (currentsz & 1);
d330 3
a332 4
   for (j = 0; j + 2 < count; j += nr - 2) {
      nr = MIN2(currentsz, count - j);
      TAG(emit_verts)(ctx, start + j, nr, ALLOC_VERTS(nr));
      currentsz = dmasz;
a333 2

   FLUSH();
d336 4
a339 4
static void TAG(render_tri_fan_verts)(struct gl_context *ctx,
                                      GLuint start,
                                      GLuint count,
                                      GLuint flags)
d341 5
a345 4
   LOCAL_VARS;
   GLuint j, nr;
   const unsigned dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
   unsigned currentsz;
d347 1
a347 1
   INIT(GL_TRIANGLE_FAN);
d349 14
a362 3
   currentsz = GET_CURRENT_VB_MAX_VERTS();
   if (currentsz < 8)
      currentsz = dmasz;
d364 8
a371 8
   for (j = 1; j + 1 < count; j += nr - 2) {
      void *tmp;
      nr = MIN2(currentsz, count - j + 1);
      tmp = ALLOC_VERTS(nr);
      tmp = TAG(emit_verts)(ctx, start, 1, tmp);
      tmp = TAG(emit_verts)(ctx, start + j, nr - 1, tmp);
      (void) tmp;
      currentsz = dmasz;
a372 2

   FLUSH();
d376 4
a379 4
static void TAG(render_poly_verts)(struct gl_context *ctx,
                                   GLuint start,
                                   GLuint count,
                                   GLuint flags)
d384 2
a385 2
      const unsigned dmasz = GET_SUBSEQUENT_VB_MAX_VERTS();
      unsigned currentsz;
d391 1
a391 1
         currentsz = dmasz;
d394 5
a398 5
      for (j = 1; j + 1 < count; j += nr - 2) {
         void *tmp;
         nr = MIN2(currentsz, count - j + 1);
         tmp = ALLOC_VERTS(nr);
         tmp = TAG(emit_verts)(ctx, start, 1, tmp);
d400 2
a401 2
         (void) tmp;
         currentsz = dmasz;
d405 2
a406 2
   } else if (ctx->Light.ShadeModel == GL_SMOOTH ||
              ctx->Light.ProvokingVertex == GL_FIRST_VERTEX_CONVENTION) {
d409 2
a410 2
      unreachable("Cannot draw primitive; validate_render should have "
                  "prevented this");
d414 4
a417 4
static void TAG(render_quad_strip_verts)(struct gl_context *ctx,
                                         GLuint start,
                                         GLuint count,
                                         GLuint flags)
d421 1
a421 1
   if (ctx->Light.ShadeModel == GL_SMOOTH) {
d423 85
a507 2
      const unsigned dmasz = GET_SUBSEQUENT_VB_MAX_VERTS() & ~1;
      unsigned currentsz;
d512 1
a512 1
      INIT(GL_TRIANGLE_STRIP);
d516 1
d521 3
a523 2
      if (currentsz < 8)
         currentsz = dmasz;
d526 1
a526 1
         nr = MIN2(currentsz, count - j);
d528 1
a528 1
         currentsz = dmasz;
d532 1
d534 2
a535 2
      unreachable("Cannot draw primitive; validate_render should have "
                  "prevented this");
d540 4
a543 4
static void TAG(render_quads_verts)(struct gl_context *ctx,
                                    GLuint start,
                                    GLuint count,
                                    GLuint flags)
d545 4
a548 2
   if (ctx->Light.ShadeModel == GL_SMOOTH ||
       ctx->Light.ProvokingVertex == GL_LAST_VERTEX_CONVENTION) {
d550 31
a580 1
      GLuint j;
d582 4
a585 2
      /* Emit whole number of quads in total. */
      count -= count & 3;
d587 1
a587 3
      /* Hardware doesn't have a quad primitive type -- try to simulate it using
       * triangle primitive.  This is a win for gears, but is it useful in the
       * broader world?
d589 35
d627 9
a635 9
         void *tmp = ALLOC_VERTS(6);
         /* Send v0, v1, v3
          */
         tmp = EMIT_VERTS(ctx, start + j,     2, tmp);
         tmp = EMIT_VERTS(ctx, start + j + 3, 1, tmp);
         /* Send v1, v2, v3
          */
         tmp = EMIT_VERTS(ctx, start + j + 1, 3, tmp);
         (void) tmp;
d637 6
a642 2
   } else {
      unreachable("Cannot draw primitive");
d646 4
a649 4
static void TAG(render_noop)(struct gl_context *ctx,
                             GLuint start,
                             GLuint count,
                             GLuint flags)
a650 4
   (void) ctx;
   (void) start;
   (void) count;
   (void) flags;
d653 4
a656 1
static const tnl_render_func TAG(render_tab_verts)[GL_POLYGON+2] =
d671 493
d1167 2
a1168 2
static bool TAG(validate_render)(struct gl_context *ctx,
                                 struct vertex_buffer *VB)
d1173 1
a1173 1
      return false;
d1175 2
a1176 2
   if (VB->Elts)
      return false;
d1181 1
a1181 1
      bool ok = false;
d1184 1
a1184 1
         continue;
d1188 2
a1189 2
         ok = HAVE_POINTS;
         break;
d1191 2
d1194 2
d1197 2
a1198 2
         ok = !ctx->Line.StippleFlag;
         break;
d1200 2
d1203 2
d1206 2
a1207 2
         ok = true;
         break;
d1209 7
a1215 3
         ok = (HAVE_POLYGONS) || ctx->Light.ShadeModel == GL_SMOOTH ||
              ctx->Light.ProvokingVertex == GL_FIRST_VERTEX_CONVENTION;
         break;
d1217 18
a1234 2
         ok = VB->Elts || ctx->Light.ShadeModel == GL_SMOOTH;
         break;
d1236 9
a1244 3
         ok = ctx->Light.ShadeModel == GL_SMOOTH ||
              ctx->Light.ProvokingVertex == GL_LAST_VERTEX_CONVENTION;
         break;
d1246 1
a1246 1
         break;
d1250 2
a1251 2
/*          fprintf(stderr, "not ok %s\n", _mesa_enum_to_string(prim & PRIM_MODE_MASK)); */
         return false;
d1255 1
a1255 1
   return true;
@

