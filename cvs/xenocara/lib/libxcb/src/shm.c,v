head	1.5;
access;
symbols
	OPENBSD_6_0:1.4.0.8
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.6
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.14
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.12
	OPENBSD_5_0:1.1.1.1.0.10
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.4
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.2
	OPENBSD_4_6_BASE:1.1.1.1
	v1_2:1.1.1.1
	XENOCARA:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2016.09.02.10.09.44;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	mKDGsTNpiR2zRHYQ;

1.4
date	2015.01.26.21.32.11;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	01TEvO4uNHLqFv7N;

1.3
date	2014.04.14.19.20.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2012.11.22.20.31.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.22.16.09.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.05.22.16.09.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xcb-proto/libxcb 1.12. "Just commit it" naddy@@
@
text
@/*
 * This file generated automatically from shm.xml by c_client.py.
 * Edit at your peril.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stddef.h>  /* for offsetof() */
#include "xcbext.h"
#include "shm.h"

#define ALIGNOF(type) offsetof(struct { char dummy; type member; }, member)
#include "xproto.h"

xcb_extension_t xcb_shm_id = { "MIT-SHM", 0 };

void
xcb_shm_seg_next (xcb_shm_seg_iterator_t *i)
{
    --i->rem;
    ++i->data;
    i->index += sizeof(xcb_shm_seg_t);
}

xcb_generic_iterator_t
xcb_shm_seg_end (xcb_shm_seg_iterator_t i)
{
    xcb_generic_iterator_t ret;
    ret.data = i.data + i.rem;
    ret.index = i.index + ((char *) ret.data - (char *) i.data);
    ret.rem = 0;
    return ret;
}

xcb_shm_query_version_cookie_t
xcb_shm_query_version (xcb_connection_t *c)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_QUERY_VERSION,
        .isvoid = 0
    };

    struct iovec xcb_parts[4];
    xcb_shm_query_version_cookie_t xcb_ret;
    xcb_shm_query_version_request_t xcb_out;


    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_shm_query_version_cookie_t
xcb_shm_query_version_unchecked (xcb_connection_t *c)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_QUERY_VERSION,
        .isvoid = 0
    };

    struct iovec xcb_parts[4];
    xcb_shm_query_version_cookie_t xcb_ret;
    xcb_shm_query_version_request_t xcb_out;


    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_shm_query_version_reply_t *
xcb_shm_query_version_reply (xcb_connection_t                *c,
                             xcb_shm_query_version_cookie_t   cookie  /**< */,
                             xcb_generic_error_t            **e)
{
    return (xcb_shm_query_version_reply_t *) xcb_wait_for_reply(c, cookie.sequence, e);
}

xcb_void_cookie_t
xcb_shm_attach_checked (xcb_connection_t *c,
                        xcb_shm_seg_t     shmseg,
                        uint32_t          shmid,
                        uint8_t           read_only)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_ATTACH,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_shm_attach_request_t xcb_out;

    xcb_out.shmseg = shmseg;
    xcb_out.shmid = shmid;
    xcb_out.read_only = read_only;
    memset(xcb_out.pad0, 0, 3);

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_shm_attach (xcb_connection_t *c,
                xcb_shm_seg_t     shmseg,
                uint32_t          shmid,
                uint8_t           read_only)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_ATTACH,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_shm_attach_request_t xcb_out;

    xcb_out.shmseg = shmseg;
    xcb_out.shmid = shmid;
    xcb_out.read_only = read_only;
    memset(xcb_out.pad0, 0, 3);

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_shm_detach_checked (xcb_connection_t *c,
                        xcb_shm_seg_t     shmseg)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_DETACH,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_shm_detach_request_t xcb_out;

    xcb_out.shmseg = shmseg;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_shm_detach (xcb_connection_t *c,
                xcb_shm_seg_t     shmseg)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_DETACH,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_shm_detach_request_t xcb_out;

    xcb_out.shmseg = shmseg;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_shm_put_image_checked (xcb_connection_t *c,
                           xcb_drawable_t    drawable,
                           xcb_gcontext_t    gc,
                           uint16_t          total_width,
                           uint16_t          total_height,
                           uint16_t          src_x,
                           uint16_t          src_y,
                           uint16_t          src_width,
                           uint16_t          src_height,
                           int16_t           dst_x,
                           int16_t           dst_y,
                           uint8_t           depth,
                           uint8_t           format,
                           uint8_t           send_event,
                           xcb_shm_seg_t     shmseg,
                           uint32_t          offset)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_PUT_IMAGE,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_shm_put_image_request_t xcb_out;

    xcb_out.drawable = drawable;
    xcb_out.gc = gc;
    xcb_out.total_width = total_width;
    xcb_out.total_height = total_height;
    xcb_out.src_x = src_x;
    xcb_out.src_y = src_y;
    xcb_out.src_width = src_width;
    xcb_out.src_height = src_height;
    xcb_out.dst_x = dst_x;
    xcb_out.dst_y = dst_y;
    xcb_out.depth = depth;
    xcb_out.format = format;
    xcb_out.send_event = send_event;
    xcb_out.pad0 = 0;
    xcb_out.shmseg = shmseg;
    xcb_out.offset = offset;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_shm_put_image (xcb_connection_t *c,
                   xcb_drawable_t    drawable,
                   xcb_gcontext_t    gc,
                   uint16_t          total_width,
                   uint16_t          total_height,
                   uint16_t          src_x,
                   uint16_t          src_y,
                   uint16_t          src_width,
                   uint16_t          src_height,
                   int16_t           dst_x,
                   int16_t           dst_y,
                   uint8_t           depth,
                   uint8_t           format,
                   uint8_t           send_event,
                   xcb_shm_seg_t     shmseg,
                   uint32_t          offset)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_PUT_IMAGE,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_shm_put_image_request_t xcb_out;

    xcb_out.drawable = drawable;
    xcb_out.gc = gc;
    xcb_out.total_width = total_width;
    xcb_out.total_height = total_height;
    xcb_out.src_x = src_x;
    xcb_out.src_y = src_y;
    xcb_out.src_width = src_width;
    xcb_out.src_height = src_height;
    xcb_out.dst_x = dst_x;
    xcb_out.dst_y = dst_y;
    xcb_out.depth = depth;
    xcb_out.format = format;
    xcb_out.send_event = send_event;
    xcb_out.pad0 = 0;
    xcb_out.shmseg = shmseg;
    xcb_out.offset = offset;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_shm_get_image_cookie_t
xcb_shm_get_image (xcb_connection_t *c,
                   xcb_drawable_t    drawable,
                   int16_t           x,
                   int16_t           y,
                   uint16_t          width,
                   uint16_t          height,
                   uint32_t          plane_mask,
                   uint8_t           format,
                   xcb_shm_seg_t     shmseg,
                   uint32_t          offset)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_GET_IMAGE,
        .isvoid = 0
    };

    struct iovec xcb_parts[4];
    xcb_shm_get_image_cookie_t xcb_ret;
    xcb_shm_get_image_request_t xcb_out;

    xcb_out.drawable = drawable;
    xcb_out.x = x;
    xcb_out.y = y;
    xcb_out.width = width;
    xcb_out.height = height;
    xcb_out.plane_mask = plane_mask;
    xcb_out.format = format;
    memset(xcb_out.pad0, 0, 3);
    xcb_out.shmseg = shmseg;
    xcb_out.offset = offset;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_shm_get_image_cookie_t
xcb_shm_get_image_unchecked (xcb_connection_t *c,
                             xcb_drawable_t    drawable,
                             int16_t           x,
                             int16_t           y,
                             uint16_t          width,
                             uint16_t          height,
                             uint32_t          plane_mask,
                             uint8_t           format,
                             xcb_shm_seg_t     shmseg,
                             uint32_t          offset)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_GET_IMAGE,
        .isvoid = 0
    };

    struct iovec xcb_parts[4];
    xcb_shm_get_image_cookie_t xcb_ret;
    xcb_shm_get_image_request_t xcb_out;

    xcb_out.drawable = drawable;
    xcb_out.x = x;
    xcb_out.y = y;
    xcb_out.width = width;
    xcb_out.height = height;
    xcb_out.plane_mask = plane_mask;
    xcb_out.format = format;
    memset(xcb_out.pad0, 0, 3);
    xcb_out.shmseg = shmseg;
    xcb_out.offset = offset;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_shm_get_image_reply_t *
xcb_shm_get_image_reply (xcb_connection_t            *c,
                         xcb_shm_get_image_cookie_t   cookie  /**< */,
                         xcb_generic_error_t        **e)
{
    return (xcb_shm_get_image_reply_t *) xcb_wait_for_reply(c, cookie.sequence, e);
}

xcb_void_cookie_t
xcb_shm_create_pixmap_checked (xcb_connection_t *c,
                               xcb_pixmap_t      pid,
                               xcb_drawable_t    drawable,
                               uint16_t          width,
                               uint16_t          height,
                               uint8_t           depth,
                               xcb_shm_seg_t     shmseg,
                               uint32_t          offset)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_CREATE_PIXMAP,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_shm_create_pixmap_request_t xcb_out;

    xcb_out.pid = pid;
    xcb_out.drawable = drawable;
    xcb_out.width = width;
    xcb_out.height = height;
    xcb_out.depth = depth;
    memset(xcb_out.pad0, 0, 3);
    xcb_out.shmseg = shmseg;
    xcb_out.offset = offset;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_shm_create_pixmap (xcb_connection_t *c,
                       xcb_pixmap_t      pid,
                       xcb_drawable_t    drawable,
                       uint16_t          width,
                       uint16_t          height,
                       uint8_t           depth,
                       xcb_shm_seg_t     shmseg,
                       uint32_t          offset)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_CREATE_PIXMAP,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_shm_create_pixmap_request_t xcb_out;

    xcb_out.pid = pid;
    xcb_out.drawable = drawable;
    xcb_out.width = width;
    xcb_out.height = height;
    xcb_out.depth = depth;
    memset(xcb_out.pad0, 0, 3);
    xcb_out.shmseg = shmseg;
    xcb_out.offset = offset;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_shm_attach_fd_checked (xcb_connection_t *c,
                           xcb_shm_seg_t     shmseg,
                           int32_t           shm_fd,
                           uint8_t           read_only)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_ATTACH_FD,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_shm_attach_fd_request_t xcb_out;
    int fds[1];

    xcb_out.shmseg = shmseg;
    xcb_out.read_only = read_only;
    memset(xcb_out.pad0, 0, 3);

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    fds[0] = shm_fd;
    xcb_ret.sequence = xcb_send_request_with_fds(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req, 1, fds);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_shm_attach_fd (xcb_connection_t *c,
                   xcb_shm_seg_t     shmseg,
                   int32_t           shm_fd,
                   uint8_t           read_only)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_ATTACH_FD,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_shm_attach_fd_request_t xcb_out;
    int fds[1];

    xcb_out.shmseg = shmseg;
    xcb_out.read_only = read_only;
    memset(xcb_out.pad0, 0, 3);

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    fds[0] = shm_fd;
    xcb_ret.sequence = xcb_send_request_with_fds(c, 0, xcb_parts + 2, &xcb_req, 1, fds);
    return xcb_ret;
}

xcb_shm_create_segment_cookie_t
xcb_shm_create_segment (xcb_connection_t *c,
                        xcb_shm_seg_t     shmseg,
                        uint32_t          size,
                        uint8_t           read_only)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_CREATE_SEGMENT,
        .isvoid = 0
    };

    struct iovec xcb_parts[4];
    xcb_shm_create_segment_cookie_t xcb_ret;
    xcb_shm_create_segment_request_t xcb_out;

    xcb_out.shmseg = shmseg;
    xcb_out.size = size;
    xcb_out.read_only = read_only;
    memset(xcb_out.pad0, 0, 3);

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED|XCB_REQUEST_REPLY_FDS, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_shm_create_segment_cookie_t
xcb_shm_create_segment_unchecked (xcb_connection_t *c,
                                  xcb_shm_seg_t     shmseg,
                                  uint32_t          size,
                                  uint8_t           read_only)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_shm_id,
        .opcode = XCB_SHM_CREATE_SEGMENT,
        .isvoid = 0
    };

    struct iovec xcb_parts[4];
    xcb_shm_create_segment_cookie_t xcb_ret;
    xcb_shm_create_segment_request_t xcb_out;

    xcb_out.shmseg = shmseg;
    xcb_out.size = size;
    xcb_out.read_only = read_only;
    memset(xcb_out.pad0, 0, 3);

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_REPLY_FDS, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_shm_create_segment_reply_t *
xcb_shm_create_segment_reply (xcb_connection_t                 *c,
                              xcb_shm_create_segment_cookie_t   cookie  /**< */,
                              xcb_generic_error_t             **e)
{
    return (xcb_shm_create_segment_reply_t *) xcb_wait_for_reply(c, cookie.sequence, e);
}

int *
xcb_shm_create_segment_reply_fds (xcb_connection_t                *c  /**< */,
                                  xcb_shm_create_segment_reply_t  *reply)
{
    return xcb_get_reply_fds(c, reply, sizeof(xcb_shm_create_segment_reply_t) + 4 * reply->length);
}

@


1.4
log
@Update to libxcb and xcb-proto 1.11.
Tested on a bulk ports build by naddy@@.
Lots of churn due to white-space and comments changes in generated code.
@
text
@d22 1
a22 1
xcb_shm_seg_next (xcb_shm_seg_iterator_t *i  /**< */)
d30 1
a30 1
xcb_shm_seg_end (xcb_shm_seg_iterator_t i  /**< */)
d40 1
a40 1
xcb_shm_query_version (xcb_connection_t *c  /**< */)
d43 4
a46 4
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_QUERY_VERSION,
        /* isvoid */ 0
d64 1
a64 1
xcb_shm_query_version_unchecked (xcb_connection_t *c  /**< */)
d67 4
a70 4
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_QUERY_VERSION,
        /* isvoid */ 0
d88 1
a88 1
xcb_shm_query_version_reply (xcb_connection_t                *c  /**< */,
d90 1
a90 1
                             xcb_generic_error_t            **e  /**< */)
d96 4
a99 4
xcb_shm_attach_checked (xcb_connection_t *c  /**< */,
                        xcb_shm_seg_t     shmseg  /**< */,
                        uint32_t          shmid  /**< */,
                        uint8_t           read_only  /**< */)
d102 4
a105 4
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_ATTACH,
        /* isvoid */ 1
d127 4
a130 4
xcb_shm_attach (xcb_connection_t *c  /**< */,
                xcb_shm_seg_t     shmseg  /**< */,
                uint32_t          shmid  /**< */,
                uint8_t           read_only  /**< */)
d133 4
a136 4
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_ATTACH,
        /* isvoid */ 1
d158 2
a159 2
xcb_shm_detach_checked (xcb_connection_t *c  /**< */,
                        xcb_shm_seg_t     shmseg  /**< */)
d162 4
a165 4
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_DETACH,
        /* isvoid */ 1
d184 2
a185 2
xcb_shm_detach (xcb_connection_t *c  /**< */,
                xcb_shm_seg_t     shmseg  /**< */)
d188 4
a191 4
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_DETACH,
        /* isvoid */ 1
d210 22
a231 22
xcb_shm_put_image_checked (xcb_connection_t *c  /**< */,
                           xcb_drawable_t    drawable  /**< */,
                           xcb_gcontext_t    gc  /**< */,
                           uint16_t          total_width  /**< */,
                           uint16_t          total_height  /**< */,
                           uint16_t          src_x  /**< */,
                           uint16_t          src_y  /**< */,
                           uint16_t          src_width  /**< */,
                           uint16_t          src_height  /**< */,
                           int16_t           dst_x  /**< */,
                           int16_t           dst_y  /**< */,
                           uint8_t           depth  /**< */,
                           uint8_t           format  /**< */,
                           uint8_t           send_event  /**< */,
                           xcb_shm_seg_t     shmseg  /**< */,
                           uint32_t          offset  /**< */)
{
    static const xcb_protocol_request_t xcb_req = {
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_PUT_IMAGE,
        /* isvoid */ 1
d265 22
a286 22
xcb_shm_put_image (xcb_connection_t *c  /**< */,
                   xcb_drawable_t    drawable  /**< */,
                   xcb_gcontext_t    gc  /**< */,
                   uint16_t          total_width  /**< */,
                   uint16_t          total_height  /**< */,
                   uint16_t          src_x  /**< */,
                   uint16_t          src_y  /**< */,
                   uint16_t          src_width  /**< */,
                   uint16_t          src_height  /**< */,
                   int16_t           dst_x  /**< */,
                   int16_t           dst_y  /**< */,
                   uint8_t           depth  /**< */,
                   uint8_t           format  /**< */,
                   uint8_t           send_event  /**< */,
                   xcb_shm_seg_t     shmseg  /**< */,
                   uint32_t          offset  /**< */)
{
    static const xcb_protocol_request_t xcb_req = {
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_PUT_IMAGE,
        /* isvoid */ 1
d320 16
a335 16
xcb_shm_get_image (xcb_connection_t *c  /**< */,
                   xcb_drawable_t    drawable  /**< */,
                   int16_t           x  /**< */,
                   int16_t           y  /**< */,
                   uint16_t          width  /**< */,
                   uint16_t          height  /**< */,
                   uint32_t          plane_mask  /**< */,
                   uint8_t           format  /**< */,
                   xcb_shm_seg_t     shmseg  /**< */,
                   uint32_t          offset  /**< */)
{
    static const xcb_protocol_request_t xcb_req = {
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_GET_IMAGE,
        /* isvoid */ 0
d363 16
a378 16
xcb_shm_get_image_unchecked (xcb_connection_t *c  /**< */,
                             xcb_drawable_t    drawable  /**< */,
                             int16_t           x  /**< */,
                             int16_t           y  /**< */,
                             uint16_t          width  /**< */,
                             uint16_t          height  /**< */,
                             uint32_t          plane_mask  /**< */,
                             uint8_t           format  /**< */,
                             xcb_shm_seg_t     shmseg  /**< */,
                             uint32_t          offset  /**< */)
{
    static const xcb_protocol_request_t xcb_req = {
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_GET_IMAGE,
        /* isvoid */ 0
d406 1
a406 1
xcb_shm_get_image_reply (xcb_connection_t            *c  /**< */,
d408 1
a408 1
                         xcb_generic_error_t        **e  /**< */)
d414 8
a421 8
xcb_shm_create_pixmap_checked (xcb_connection_t *c  /**< */,
                               xcb_pixmap_t      pid  /**< */,
                               xcb_drawable_t    drawable  /**< */,
                               uint16_t          width  /**< */,
                               uint16_t          height  /**< */,
                               uint8_t           depth  /**< */,
                               xcb_shm_seg_t     shmseg  /**< */,
                               uint32_t          offset  /**< */)
d424 4
a427 4
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_CREATE_PIXMAP,
        /* isvoid */ 1
d453 8
a460 8
xcb_shm_create_pixmap (xcb_connection_t *c  /**< */,
                       xcb_pixmap_t      pid  /**< */,
                       xcb_drawable_t    drawable  /**< */,
                       uint16_t          width  /**< */,
                       uint16_t          height  /**< */,
                       uint8_t           depth  /**< */,
                       xcb_shm_seg_t     shmseg  /**< */,
                       uint32_t          offset  /**< */)
d463 4
a466 4
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_CREATE_PIXMAP,
        /* isvoid */ 1
d492 4
a495 4
xcb_shm_attach_fd_checked (xcb_connection_t *c  /**< */,
                           xcb_shm_seg_t     shmseg  /**< */,
                           int32_t           shm_fd  /**< */,
                           uint8_t           read_only  /**< */)
d498 4
a501 4
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_ATTACH_FD,
        /* isvoid */ 1
d507 1
d518 2
a519 2
    xcb_send_fd(c, shm_fd);
    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req);
d524 4
a527 4
xcb_shm_attach_fd (xcb_connection_t *c  /**< */,
                   xcb_shm_seg_t     shmseg  /**< */,
                   int32_t           shm_fd  /**< */,
                   uint8_t           read_only  /**< */)
d530 4
a533 4
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_ATTACH_FD,
        /* isvoid */ 1
d539 1
d550 2
a551 2
    xcb_send_fd(c, shm_fd);
    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);
d556 4
a559 4
xcb_shm_create_segment (xcb_connection_t *c  /**< */,
                        xcb_shm_seg_t     shmseg  /**< */,
                        uint32_t          size  /**< */,
                        uint8_t           read_only  /**< */)
d562 4
a565 4
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_CREATE_SEGMENT,
        /* isvoid */ 0
d587 4
a590 4
xcb_shm_create_segment_unchecked (xcb_connection_t *c  /**< */,
                                  xcb_shm_seg_t     shmseg  /**< */,
                                  uint32_t          size  /**< */,
                                  uint8_t           read_only  /**< */)
d593 4
a596 4
        /* count */ 2,
        /* ext */ &xcb_shm_id,
        /* opcode */ XCB_SHM_CREATE_SEGMENT,
        /* isvoid */ 0
d618 1
a618 1
xcb_shm_create_segment_reply (xcb_connection_t                 *c  /**< */,
d620 1
a620 1
                              xcb_generic_error_t             **e  /**< */)
d627 1
a627 1
                                  xcb_shm_create_segment_reply_t  *reply  /**< */)
@


1.3
log
@Update build system and generated files for libxcb 1.10.
@
text
@a20 10

/*****************************************************************************
 **
 ** void xcb_shm_seg_next
 ** 
 ** @@param xcb_shm_seg_iterator_t *i
 ** @@returns void
 **
 *****************************************************************************/
 
a28 10

/*****************************************************************************
 **
 ** xcb_generic_iterator_t xcb_shm_seg_end
 ** 
 ** @@param xcb_shm_seg_iterator_t i
 ** @@returns xcb_generic_iterator_t
 **
 *****************************************************************************/
 
a38 10

/*****************************************************************************
 **
 ** xcb_shm_query_version_cookie_t xcb_shm_query_version
 ** 
 ** @@param xcb_connection_t *c
 ** @@returns xcb_shm_query_version_cookie_t
 **
 *****************************************************************************/
 
d48 1
a48 1
    
d52 2
a53 2
    
    
d58 1
a58 1
    
a62 10

/*****************************************************************************
 **
 ** xcb_shm_query_version_cookie_t xcb_shm_query_version_unchecked
 ** 
 ** @@param xcb_connection_t *c
 ** @@returns xcb_shm_query_version_cookie_t
 **
 *****************************************************************************/
 
d72 1
a72 1
    
d76 2
a77 2
    
    
d82 1
a82 1
    
a86 12

/*****************************************************************************
 **
 ** xcb_shm_query_version_reply_t * xcb_shm_query_version_reply
 ** 
 ** @@param xcb_connection_t                *c
 ** @@param xcb_shm_query_version_cookie_t   cookie
 ** @@param xcb_generic_error_t            **e
 ** @@returns xcb_shm_query_version_reply_t *
 **
 *****************************************************************************/
 
a94 13

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_shm_attach_checked
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_shm_seg_t     shmseg
 ** @@param uint32_t          shmid
 ** @@param uint8_t           read_only
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d107 1
a107 1
    
d111 1
a111 1
    
d116 1
a116 1
    
d121 1
a121 1
    
a125 13

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_shm_attach
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_shm_seg_t     shmseg
 ** @@param uint32_t          shmid
 ** @@param uint8_t           read_only
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d138 1
a138 1
    
d142 1
a142 1
    
d147 1
a147 1
    
d152 1
a152 1
    
a156 11

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_shm_detach_checked
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_shm_seg_t     shmseg
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d167 1
a167 1
    
d171 1
a171 1
    
d173 1
a173 1
    
d178 1
a178 1
    
a182 11

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_shm_detach
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_shm_seg_t     shmseg
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d193 1
a193 1
    
d197 1
a197 1
    
d199 1
a199 1
    
d204 1
a204 1
    
a208 25

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_shm_put_image_checked
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_drawable_t    drawable
 ** @@param xcb_gcontext_t    gc
 ** @@param uint16_t          total_width
 ** @@param uint16_t          total_height
 ** @@param uint16_t          src_x
 ** @@param uint16_t          src_y
 ** @@param uint16_t          src_width
 ** @@param uint16_t          src_height
 ** @@param int16_t           dst_x
 ** @@param int16_t           dst_y
 ** @@param uint8_t           depth
 ** @@param uint8_t           format
 ** @@param uint8_t           send_event
 ** @@param xcb_shm_seg_t     shmseg
 ** @@param uint32_t          offset
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d233 1
a233 1
    
d237 1
a237 1
    
d254 1
a254 1
    
d259 1
a259 1
    
a263 25

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_shm_put_image
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_drawable_t    drawable
 ** @@param xcb_gcontext_t    gc
 ** @@param uint16_t          total_width
 ** @@param uint16_t          total_height
 ** @@param uint16_t          src_x
 ** @@param uint16_t          src_y
 ** @@param uint16_t          src_width
 ** @@param uint16_t          src_height
 ** @@param int16_t           dst_x
 ** @@param int16_t           dst_y
 ** @@param uint8_t           depth
 ** @@param uint8_t           format
 ** @@param uint8_t           send_event
 ** @@param xcb_shm_seg_t     shmseg
 ** @@param uint32_t          offset
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d288 1
a288 1
    
d292 1
a292 1
    
d309 1
a309 1
    
d314 1
a314 1
    
a318 19

/*****************************************************************************
 **
 ** xcb_shm_get_image_cookie_t xcb_shm_get_image
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_drawable_t    drawable
 ** @@param int16_t           x
 ** @@param int16_t           y
 ** @@param uint16_t          width
 ** @@param uint16_t          height
 ** @@param uint32_t          plane_mask
 ** @@param uint8_t           format
 ** @@param xcb_shm_seg_t     shmseg
 ** @@param uint32_t          offset
 ** @@returns xcb_shm_get_image_cookie_t
 **
 *****************************************************************************/
 
d337 1
a337 1
    
d341 1
a341 1
    
d352 1
a352 1
    
d357 1
a357 1
    
a361 19

/*****************************************************************************
 **
 ** xcb_shm_get_image_cookie_t xcb_shm_get_image_unchecked
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_drawable_t    drawable
 ** @@param int16_t           x
 ** @@param int16_t           y
 ** @@param uint16_t          width
 ** @@param uint16_t          height
 ** @@param uint32_t          plane_mask
 ** @@param uint8_t           format
 ** @@param xcb_shm_seg_t     shmseg
 ** @@param uint32_t          offset
 ** @@returns xcb_shm_get_image_cookie_t
 **
 *****************************************************************************/
 
d380 1
a380 1
    
d384 1
a384 1
    
d395 1
a395 1
    
d400 1
a400 1
    
a404 12

/*****************************************************************************
 **
 ** xcb_shm_get_image_reply_t * xcb_shm_get_image_reply
 ** 
 ** @@param xcb_connection_t            *c
 ** @@param xcb_shm_get_image_cookie_t   cookie
 ** @@param xcb_generic_error_t        **e
 ** @@returns xcb_shm_get_image_reply_t *
 **
 *****************************************************************************/
 
a412 17

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_shm_create_pixmap_checked
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_pixmap_t      pid
 ** @@param xcb_drawable_t    drawable
 ** @@param uint16_t          width
 ** @@param uint16_t          height
 ** @@param uint8_t           depth
 ** @@param xcb_shm_seg_t     shmseg
 ** @@param uint32_t          offset
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d429 1
a429 1
    
d433 1
a433 1
    
d442 1
a442 1
    
d447 1
a447 1
    
a451 17

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_shm_create_pixmap
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_pixmap_t      pid
 ** @@param xcb_drawable_t    drawable
 ** @@param uint16_t          width
 ** @@param uint16_t          height
 ** @@param uint8_t           depth
 ** @@param xcb_shm_seg_t     shmseg
 ** @@param uint32_t          offset
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d468 1
a468 1
    
d472 1
a472 1
    
d481 1
a481 1
    
d486 1
a486 1
    
a490 13

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_shm_attach_fd_checked
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_shm_seg_t     shmseg
 ** @@param int32_t           shm_fd
 ** @@param uint8_t           read_only
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d503 1
a503 1
    
d507 1
a507 1
    
d511 1
a511 1
    
d516 1
a516 1
    
a521 13

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_shm_attach_fd
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_shm_seg_t     shmseg
 ** @@param int32_t           shm_fd
 ** @@param uint8_t           read_only
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d534 1
a534 1
    
d538 1
a538 1
    
d542 1
a542 1
    
d547 1
a547 1
    
a552 13

/*****************************************************************************
 **
 ** xcb_shm_create_segment_cookie_t xcb_shm_create_segment
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_shm_seg_t     shmseg
 ** @@param uint32_t          size
 ** @@param uint8_t           read_only
 ** @@returns xcb_shm_create_segment_cookie_t
 **
 *****************************************************************************/
 
d565 1
a565 1
    
d569 1
a569 1
    
d574 1
a574 1
    
d579 1
a579 1
    
a583 13

/*****************************************************************************
 **
 ** xcb_shm_create_segment_cookie_t xcb_shm_create_segment_unchecked
 ** 
 ** @@param xcb_connection_t *c
 ** @@param xcb_shm_seg_t     shmseg
 ** @@param uint32_t          size
 ** @@param uint8_t           read_only
 ** @@returns xcb_shm_create_segment_cookie_t
 **
 *****************************************************************************/
 
d596 1
a596 1
    
d600 1
a600 1
    
d605 1
a605 1
    
d610 1
a610 1
    
a614 12

/*****************************************************************************
 **
 ** xcb_shm_create_segment_reply_t * xcb_shm_create_segment_reply
 ** 
 ** @@param xcb_connection_t                 *c
 ** @@param xcb_shm_create_segment_cookie_t   cookie
 ** @@param xcb_generic_error_t             **e
 ** @@returns xcb_shm_create_segment_reply_t *
 **
 *****************************************************************************/
 
a622 11

/*****************************************************************************
 **
 ** int * xcb_shm_create_segment_reply_fds
 ** 
 ** @@param xcb_connection_t                *c
 ** @@param xcb_shm_create_segment_reply_t  *reply
 ** @@returns int *
 **
 *****************************************************************************/
 
@


1.2
log
@Update to libxcb 1.9.0.
tested by ajacoutot@@ and naddy@@ on a full ports build
@
text
@d725 214
@


1.1
log
@Initial revision
@
text
@d6 4
d12 1
d15 2
d88 1
d122 1
d186 1
d230 1
d267 1
d304 1
d384 1
d464 1
d526 1
d588 1
d664 1
d720 1
@


1.1.1.1
log
@Xenocara build infrastructure for libxcb.

This includes a set of pre-generated sources files in src/ so that
python and xslt are not needed to build.
@
text
@@
