head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.3.0.8
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.6
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.4
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.8
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.14
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.12
	OPENBSD_5_0:1.1.1.1.0.10
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.4
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.2
	OPENBSD_4_6_BASE:1.1.1.1
	v1_2:1.1.1.1
	XENOCARA:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2016.09.02.10.09.44;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	mKDGsTNpiR2zRHYQ;

1.3
date	2015.01.26.21.32.11;	author matthieu;	state Exp;
branches;
next	1.2;
commitid	01TEvO4uNHLqFv7N;

1.2
date	2012.11.22.20.31.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.22.16.09.17;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.05.22.16.09.17;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to xcb-proto/libxcb 1.12. "Just commit it" naddy@@
@
text
@/*
 * This file generated automatically from damage.xml by c_client.py.
 * Edit at your peril.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stddef.h>  /* for offsetof() */
#include "xcbext.h"
#include "damage.h"

#define ALIGNOF(type) offsetof(struct { char dummy; type member; }, member)
#include "xproto.h"
#include "xfixes.h"

xcb_extension_t xcb_damage_id = { "DAMAGE", 0 };

void
xcb_damage_damage_next (xcb_damage_damage_iterator_t *i)
{
    --i->rem;
    ++i->data;
    i->index += sizeof(xcb_damage_damage_t);
}

xcb_generic_iterator_t
xcb_damage_damage_end (xcb_damage_damage_iterator_t i)
{
    xcb_generic_iterator_t ret;
    ret.data = i.data + i.rem;
    ret.index = i.index + ((char *) ret.data - (char *) i.data);
    ret.rem = 0;
    return ret;
}

xcb_damage_query_version_cookie_t
xcb_damage_query_version (xcb_connection_t *c,
                          uint32_t          client_major_version,
                          uint32_t          client_minor_version)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_damage_id,
        .opcode = XCB_DAMAGE_QUERY_VERSION,
        .isvoid = 0
    };

    struct iovec xcb_parts[4];
    xcb_damage_query_version_cookie_t xcb_ret;
    xcb_damage_query_version_request_t xcb_out;

    xcb_out.client_major_version = client_major_version;
    xcb_out.client_minor_version = client_minor_version;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_damage_query_version_cookie_t
xcb_damage_query_version_unchecked (xcb_connection_t *c,
                                    uint32_t          client_major_version,
                                    uint32_t          client_minor_version)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_damage_id,
        .opcode = XCB_DAMAGE_QUERY_VERSION,
        .isvoid = 0
    };

    struct iovec xcb_parts[4];
    xcb_damage_query_version_cookie_t xcb_ret;
    xcb_damage_query_version_request_t xcb_out;

    xcb_out.client_major_version = client_major_version;
    xcb_out.client_minor_version = client_minor_version;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_damage_query_version_reply_t *
xcb_damage_query_version_reply (xcb_connection_t                   *c,
                                xcb_damage_query_version_cookie_t   cookie  /**< */,
                                xcb_generic_error_t               **e)
{
    return (xcb_damage_query_version_reply_t *) xcb_wait_for_reply(c, cookie.sequence, e);
}

xcb_void_cookie_t
xcb_damage_create_checked (xcb_connection_t    *c,
                           xcb_damage_damage_t  damage,
                           xcb_drawable_t       drawable,
                           uint8_t              level)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_damage_id,
        .opcode = XCB_DAMAGE_CREATE,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_damage_create_request_t xcb_out;

    xcb_out.damage = damage;
    xcb_out.drawable = drawable;
    xcb_out.level = level;
    memset(xcb_out.pad0, 0, 3);

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_damage_create (xcb_connection_t    *c,
                   xcb_damage_damage_t  damage,
                   xcb_drawable_t       drawable,
                   uint8_t              level)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_damage_id,
        .opcode = XCB_DAMAGE_CREATE,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_damage_create_request_t xcb_out;

    xcb_out.damage = damage;
    xcb_out.drawable = drawable;
    xcb_out.level = level;
    memset(xcb_out.pad0, 0, 3);

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_damage_destroy_checked (xcb_connection_t    *c,
                            xcb_damage_damage_t  damage)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_damage_id,
        .opcode = XCB_DAMAGE_DESTROY,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_damage_destroy_request_t xcb_out;

    xcb_out.damage = damage;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_damage_destroy (xcb_connection_t    *c,
                    xcb_damage_damage_t  damage)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_damage_id,
        .opcode = XCB_DAMAGE_DESTROY,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_damage_destroy_request_t xcb_out;

    xcb_out.damage = damage;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_damage_subtract_checked (xcb_connection_t    *c,
                             xcb_damage_damage_t  damage,
                             xcb_xfixes_region_t  repair,
                             xcb_xfixes_region_t  parts)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_damage_id,
        .opcode = XCB_DAMAGE_SUBTRACT,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_damage_subtract_request_t xcb_out;

    xcb_out.damage = damage;
    xcb_out.repair = repair;
    xcb_out.parts = parts;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_damage_subtract (xcb_connection_t    *c,
                     xcb_damage_damage_t  damage,
                     xcb_xfixes_region_t  repair,
                     xcb_xfixes_region_t  parts)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_damage_id,
        .opcode = XCB_DAMAGE_SUBTRACT,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_damage_subtract_request_t xcb_out;

    xcb_out.damage = damage;
    xcb_out.repair = repair;
    xcb_out.parts = parts;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_damage_add_checked (xcb_connection_t    *c,
                        xcb_drawable_t       drawable,
                        xcb_xfixes_region_t  region)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_damage_id,
        .opcode = XCB_DAMAGE_ADD,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_damage_add_request_t xcb_out;

    xcb_out.drawable = drawable;
    xcb_out.region = region;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, XCB_REQUEST_CHECKED, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

xcb_void_cookie_t
xcb_damage_add (xcb_connection_t    *c,
                xcb_drawable_t       drawable,
                xcb_xfixes_region_t  region)
{
    static const xcb_protocol_request_t xcb_req = {
        .count = 2,
        .ext = &xcb_damage_id,
        .opcode = XCB_DAMAGE_ADD,
        .isvoid = 1
    };

    struct iovec xcb_parts[4];
    xcb_void_cookie_t xcb_ret;
    xcb_damage_add_request_t xcb_out;

    xcb_out.drawable = drawable;
    xcb_out.region = region;

    xcb_parts[2].iov_base = (char *) &xcb_out;
    xcb_parts[2].iov_len = sizeof(xcb_out);
    xcb_parts[3].iov_base = 0;
    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;

    xcb_ret.sequence = xcb_send_request(c, 0, xcb_parts + 2, &xcb_req);
    return xcb_ret;
}

@


1.3
log
@Update to libxcb and xcb-proto 1.11.
Tested on a bulk ports build by naddy@@.
Lots of churn due to white-space and comments changes in generated code.
@
text
@d23 1
a23 1
xcb_damage_damage_next (xcb_damage_damage_iterator_t *i  /**< */)
d31 1
a31 1
xcb_damage_damage_end (xcb_damage_damage_iterator_t i  /**< */)
d41 3
a43 3
xcb_damage_query_version (xcb_connection_t *c  /**< */,
                          uint32_t          client_major_version  /**< */,
                          uint32_t          client_minor_version  /**< */)
d46 4
a49 4
        /* count */ 2,
        /* ext */ &xcb_damage_id,
        /* opcode */ XCB_DAMAGE_QUERY_VERSION,
        /* isvoid */ 0
d69 3
a71 3
xcb_damage_query_version_unchecked (xcb_connection_t *c  /**< */,
                                    uint32_t          client_major_version  /**< */,
                                    uint32_t          client_minor_version  /**< */)
d74 4
a77 4
        /* count */ 2,
        /* ext */ &xcb_damage_id,
        /* opcode */ XCB_DAMAGE_QUERY_VERSION,
        /* isvoid */ 0
d97 1
a97 1
xcb_damage_query_version_reply (xcb_connection_t                   *c  /**< */,
d99 1
a99 1
                                xcb_generic_error_t               **e  /**< */)
d105 4
a108 4
xcb_damage_create_checked (xcb_connection_t    *c  /**< */,
                           xcb_damage_damage_t  damage  /**< */,
                           xcb_drawable_t       drawable  /**< */,
                           uint8_t              level  /**< */)
d111 4
a114 4
        /* count */ 2,
        /* ext */ &xcb_damage_id,
        /* opcode */ XCB_DAMAGE_CREATE,
        /* isvoid */ 1
d136 4
a139 4
xcb_damage_create (xcb_connection_t    *c  /**< */,
                   xcb_damage_damage_t  damage  /**< */,
                   xcb_drawable_t       drawable  /**< */,
                   uint8_t              level  /**< */)
d142 4
a145 4
        /* count */ 2,
        /* ext */ &xcb_damage_id,
        /* opcode */ XCB_DAMAGE_CREATE,
        /* isvoid */ 1
d167 2
a168 2
xcb_damage_destroy_checked (xcb_connection_t    *c  /**< */,
                            xcb_damage_damage_t  damage  /**< */)
d171 4
a174 4
        /* count */ 2,
        /* ext */ &xcb_damage_id,
        /* opcode */ XCB_DAMAGE_DESTROY,
        /* isvoid */ 1
d193 2
a194 2
xcb_damage_destroy (xcb_connection_t    *c  /**< */,
                    xcb_damage_damage_t  damage  /**< */)
d197 4
a200 4
        /* count */ 2,
        /* ext */ &xcb_damage_id,
        /* opcode */ XCB_DAMAGE_DESTROY,
        /* isvoid */ 1
d219 4
a222 4
xcb_damage_subtract_checked (xcb_connection_t    *c  /**< */,
                             xcb_damage_damage_t  damage  /**< */,
                             xcb_xfixes_region_t  repair  /**< */,
                             xcb_xfixes_region_t  parts  /**< */)
d225 4
a228 4
        /* count */ 2,
        /* ext */ &xcb_damage_id,
        /* opcode */ XCB_DAMAGE_SUBTRACT,
        /* isvoid */ 1
d249 4
a252 4
xcb_damage_subtract (xcb_connection_t    *c  /**< */,
                     xcb_damage_damage_t  damage  /**< */,
                     xcb_xfixes_region_t  repair  /**< */,
                     xcb_xfixes_region_t  parts  /**< */)
d255 4
a258 4
        /* count */ 2,
        /* ext */ &xcb_damage_id,
        /* opcode */ XCB_DAMAGE_SUBTRACT,
        /* isvoid */ 1
d279 3
a281 3
xcb_damage_add_checked (xcb_connection_t    *c  /**< */,
                        xcb_drawable_t       drawable  /**< */,
                        xcb_xfixes_region_t  region  /**< */)
d284 4
a287 4
        /* count */ 2,
        /* ext */ &xcb_damage_id,
        /* opcode */ XCB_DAMAGE_ADD,
        /* isvoid */ 1
d307 3
a309 3
xcb_damage_add (xcb_connection_t    *c  /**< */,
                xcb_drawable_t       drawable  /**< */,
                xcb_xfixes_region_t  region  /**< */)
d312 4
a315 4
        /* count */ 2,
        /* ext */ &xcb_damage_id,
        /* opcode */ XCB_DAMAGE_ADD,
        /* isvoid */ 1
@


1.2
log
@Update to libxcb 1.9.0.
tested by ajacoutot@@ and naddy@@ on a full ports build
@
text
@a17 2
#include "render.h"
#include "shape.h"
a21 10

/*****************************************************************************
 **
 ** void xcb_damage_damage_next
 ** 
 ** @@param xcb_damage_damage_iterator_t *i
 ** @@returns void
 **
 *****************************************************************************/
 
a29 10

/*****************************************************************************
 **
 ** xcb_generic_iterator_t xcb_damage_damage_end
 ** 
 ** @@param xcb_damage_damage_iterator_t i
 ** @@returns xcb_generic_iterator_t
 **
 *****************************************************************************/
 
a39 12

/*****************************************************************************
 **
 ** xcb_damage_query_version_cookie_t xcb_damage_query_version
 ** 
 ** @@param xcb_connection_t *c
 ** @@param uint32_t          client_major_version
 ** @@param uint32_t          client_minor_version
 ** @@returns xcb_damage_query_version_cookie_t
 **
 *****************************************************************************/
 
d51 1
a51 1
    
d55 1
a55 1
    
d58 1
a58 1
    
d63 1
a63 1
    
a67 12

/*****************************************************************************
 **
 ** xcb_damage_query_version_cookie_t xcb_damage_query_version_unchecked
 ** 
 ** @@param xcb_connection_t *c
 ** @@param uint32_t          client_major_version
 ** @@param uint32_t          client_minor_version
 ** @@returns xcb_damage_query_version_cookie_t
 **
 *****************************************************************************/
 
d79 1
a79 1
    
d83 1
a83 1
    
d86 1
a86 1
    
d91 1
a91 1
    
a95 12

/*****************************************************************************
 **
 ** xcb_damage_query_version_reply_t * xcb_damage_query_version_reply
 ** 
 ** @@param xcb_connection_t                   *c
 ** @@param xcb_damage_query_version_cookie_t   cookie
 ** @@param xcb_generic_error_t               **e
 ** @@returns xcb_damage_query_version_reply_t *
 **
 *****************************************************************************/
 
a103 13

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_damage_create_checked
 ** 
 ** @@param xcb_connection_t    *c
 ** @@param xcb_damage_damage_t  damage
 ** @@param xcb_drawable_t       drawable
 ** @@param uint8_t              level
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d116 1
a116 1
    
d120 1
a120 1
    
d125 1
a125 1
    
d130 1
a130 1
    
a134 13

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_damage_create
 ** 
 ** @@param xcb_connection_t    *c
 ** @@param xcb_damage_damage_t  damage
 ** @@param xcb_drawable_t       drawable
 ** @@param uint8_t              level
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d147 1
a147 1
    
d151 1
a151 1
    
d156 1
a156 1
    
d161 1
a161 1
    
a165 11

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_damage_destroy_checked
 ** 
 ** @@param xcb_connection_t    *c
 ** @@param xcb_damage_damage_t  damage
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d176 1
a176 1
    
d180 1
a180 1
    
d182 1
a182 1
    
d187 1
a187 1
    
a191 11

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_damage_destroy
 ** 
 ** @@param xcb_connection_t    *c
 ** @@param xcb_damage_damage_t  damage
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d202 1
a202 1
    
d206 1
a206 1
    
d208 1
a208 1
    
d213 1
a213 1
    
a217 13

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_damage_subtract_checked
 ** 
 ** @@param xcb_connection_t    *c
 ** @@param xcb_damage_damage_t  damage
 ** @@param xcb_xfixes_region_t  repair
 ** @@param xcb_xfixes_region_t  parts
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d230 1
a230 1
    
d234 1
a234 1
    
d238 1
a238 1
    
d243 1
a243 1
    
a247 13

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_damage_subtract
 ** 
 ** @@param xcb_connection_t    *c
 ** @@param xcb_damage_damage_t  damage
 ** @@param xcb_xfixes_region_t  repair
 ** @@param xcb_xfixes_region_t  parts
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d260 1
a260 1
    
d264 1
a264 1
    
d268 1
a268 1
    
d273 1
a273 1
    
a277 12

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_damage_add_checked
 ** 
 ** @@param xcb_connection_t    *c
 ** @@param xcb_drawable_t       drawable
 ** @@param xcb_xfixes_region_t  region
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d289 1
a289 1
    
d293 1
a293 1
    
d296 1
a296 1
    
d301 1
a301 1
    
a305 12

/*****************************************************************************
 **
 ** xcb_void_cookie_t xcb_damage_add
 ** 
 ** @@param xcb_connection_t    *c
 ** @@param xcb_drawable_t       drawable
 ** @@param xcb_xfixes_region_t  region
 ** @@returns xcb_void_cookie_t
 **
 *****************************************************************************/
 
d317 1
a317 1
    
d321 1
a321 1
    
d324 1
a324 1
    
d329 1
a329 1
    
@


1.1
log
@Initial revision
@
text
@d6 4
d12 1
d15 2
d97 1
d137 1
d201 1
d245 1
d282 1
d319 1
d362 1
d405 1
d445 1
d485 1
@


1.1.1.1
log
@Xenocara build infrastructure for libxcb.

This includes a set of pre-generated sources files in src/ so that
python and xslt are not needed to build.
@
text
@@
