head	1.7;
access;
symbols
	OPENBSD_6_0:1.6.0.6
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.4
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.2
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.8
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.2.0.16
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.12
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.10
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.8
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_0_4:1.1.1.2
	v1_0_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.10.04.15.11.05;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	RQsdND9x6Ge5m1lc;

1.6
date	2015.04.06.13.33.24;	author matthieu;	state Exp;
branches
	1.6.4.1
	1.6.6.1;
next	1.5;
commitid	KUeYW69Fsj6l33ZO;

1.5
date	2013.06.14.21.40.43;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2013.05.23.22.42.12;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.03.10.17.04.00;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.08.22.10.02.29;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.05.45;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.05.45;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.12.17.10.51.53;	author matthieu;	state Exp;
branches;
next	;

1.6.4.1
date	2016.10.04.18.55.14;	author matthieu;	state Exp;
branches;
next	;
commitid	PNaHexTGDQbxwlMB;

1.6.6.1
date	2016.10.04.18.54.01;	author matthieu;	state Exp;
branches;
next	;
commitid	b1RDOJn7dNqLwuaq;


desc
@@


1.7
log
@Avoid buffer underflow on empty strings.

If an empty string is received from an x-server, do not underrun the
buffer by accessing "rep.nameLen - 1" unconditionally, which could end
up being -1.

From Tobias Stoeckmann / X.Org security advisory Oct 4, 2016
@
text
@#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdio.h>
#include "XvMClibint.h"
#ifdef HAVE_SHMAT
#ifndef Lynx
#include <sys/ipc.h>
#include <sys/shm.h>
#else
#include <ipc.h>
#include <shm.h>
#endif /* Lynx */
#endif /* HAVE_SHMAT */
#include <unistd.h>
#include <sys/time.h>
#include <X11/extensions/Xext.h>
#include <X11/extensions/extutil.h>
#include <limits.h>

static XExtensionInfo _xvmc_info_data;
static XExtensionInfo *xvmc_info = &_xvmc_info_data;
static const char *xvmc_extension_name = XvMCName;

static const char *xvmc_error_list[] =
{
   "BadContext",
   "BadSurface",
   "BadSubpicture"
};

static XEXT_GENERATE_CLOSE_DISPLAY (xvmc_close_display, xvmc_info)


static XEXT_GENERATE_ERROR_STRING (xvmc_error_string, xvmc_extension_name,
                                   XvMCNumErrors, xvmc_error_list)


static XExtensionHooks xvmc_extension_hooks = {
    NULL,                               /* create_gc */
    NULL,                               /* copy_gc */
    NULL,                               /* flush_gc */
    NULL,                               /* free_gc */
    NULL,                               /* create_font */
    NULL,                               /* free_font */
    xvmc_close_display,                 /* close_display */
    NULL,                               /* wire_to_event */
    NULL,                               /* event_to_wire */
    NULL,                               /* error */
    xvmc_error_string                   /* error_string */
};

static XEXT_GENERATE_FIND_DISPLAY (xvmc_find_display, xvmc_info,
                                   xvmc_extension_name,
                                   &xvmc_extension_hooks,
                                   XvMCNumEvents, NULL)

Bool XvMCQueryExtension (Display *dpy, int *event_basep, int *error_basep)
{
    XExtDisplayInfo *info = xvmc_find_display(dpy);

    if (XextHasExtension(info)) {
        *event_basep = info->codes->first_event;
        *error_basep = info->codes->first_error;
        return True;
    } else {
        return False;
    }
}

Status XvMCQueryVersion (Display *dpy, int *major, int *minor)
{
    XExtDisplayInfo *info = xvmc_find_display(dpy);
    xvmcQueryVersionReply rep;
    xvmcQueryVersionReq  *req;

    XvMCCheckExtension (dpy, info, BadImplementation);

    LockDisplay (dpy);
    XvMCGetReq (QueryVersion, req);
    if (!_XReply (dpy, (xReply *) &rep, 0, xTrue)) {
        UnlockDisplay (dpy);
        SyncHandle ();
        return BadImplementation;
    }
    *major = rep.major;
    *minor = rep.minor;
    UnlockDisplay (dpy);
    SyncHandle ();
    return Success;
}


XvMCSurfaceInfo * XvMCListSurfaceTypes(Display *dpy, XvPortID port, int *num)
{
    XExtDisplayInfo *info = xvmc_find_display(dpy);
    xvmcListSurfaceTypesReply rep;
    xvmcListSurfaceTypesReq  *req;
    XvMCSurfaceInfo *surface_info = NULL;

    *num = 0;

    XvMCCheckExtension (dpy, info, NULL);

    LockDisplay (dpy);
    XvMCGetReq (ListSurfaceTypes, req);
    req->port = port;
    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay (dpy);
        SyncHandle ();
        return NULL;
    }

    if(rep.num > 0) {
        if (rep.num < (INT_MAX / sizeof(XvMCSurfaceInfo)))
            surface_info = Xmalloc(rep.num * sizeof(XvMCSurfaceInfo));

        if(surface_info) {
	    xvmcSurfaceInfo sinfo;
	    int i;

	    *num = rep.num;

	    for(i = 0; i < rep.num; i++) {
		_XRead(dpy, (char*)&sinfo, sizeof(xvmcSurfaceInfo));
	       surface_info[i].surface_type_id = sinfo.surface_type_id;
	       surface_info[i].chroma_format = sinfo.chroma_format;
	       surface_info[i].max_width = sinfo.max_width;
	       surface_info[i].max_height = sinfo.max_height;
	       surface_info[i].subpicture_max_width =
					sinfo.subpicture_max_width;
	       surface_info[i].subpicture_max_height =
					sinfo.subpicture_max_height;
	       surface_info[i].mc_type = sinfo.mc_type;
	       surface_info[i].flags = sinfo.flags;
	    }
	} else
	   _XEatDataWords(dpy, rep.length);
    }

    UnlockDisplay (dpy);
    SyncHandle ();
    return surface_info;
}


XvImageFormatValues * XvMCListSubpictureTypes (
  Display * dpy,
  XvPortID port,
  int surface_type_id,
  int *count_return
)
{
    XExtDisplayInfo *info = xvmc_find_display(dpy);
    xvmcListSubpictureTypesReply rep;
    xvmcListSubpictureTypesReq  *req;
    XvImageFormatValues *ret = NULL;


    *count_return = 0;

    XvMCCheckExtension (dpy, info, NULL);


    LockDisplay (dpy);
    XvMCGetReq (ListSubpictureTypes, req);
    req->port = port;
    req->surface_type_id = surface_type_id;
    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay (dpy);
        SyncHandle ();
        return NULL;
    }

    if(rep.num > 0) {
        if (rep.num < (INT_MAX / sizeof(XvImageFormatValues)))
            ret = Xmalloc(rep.num * sizeof(XvImageFormatValues));

        if(ret) {
            xvImageFormatInfo Info;
            int i;

            *count_return = rep.num;

            for(i = 0; i < rep.num; i++) {
              _XRead(dpy, (char*)(&Info), sz_xvImageFormatInfo);
              ret[i].id = Info.id;
              ret[i].type = Info.type;
              ret[i].byte_order = Info.byte_order;
              memcpy(&(ret[i].guid[0]), &(Info.guid[0]), 16);
              ret[i].bits_per_pixel = Info.bpp;
              ret[i].format = Info.format;
              ret[i].num_planes = Info.num_planes;
              ret[i].depth = Info.depth;
              ret[i].red_mask = Info.red_mask;
              ret[i].green_mask = Info.green_mask;
              ret[i].blue_mask = Info.blue_mask;
              ret[i].y_sample_bits = Info.y_sample_bits;
              ret[i].u_sample_bits = Info.u_sample_bits;
              ret[i].v_sample_bits = Info.v_sample_bits;
              ret[i].horz_y_period = Info.horz_y_period;
              ret[i].horz_u_period = Info.horz_u_period;
              ret[i].horz_v_period = Info.horz_v_period;
              ret[i].vert_y_period = Info.vert_y_period;
              ret[i].vert_u_period = Info.vert_u_period;
              ret[i].vert_v_period = Info.vert_v_period;
              memcpy(&(ret[i].component_order[0]), &(Info.comp_order[0]), 32);
              ret[i].scanline_order = Info.scanline_order;
            }
        } else
	   _XEatDataWords(dpy, rep.length);
    }

    UnlockDisplay (dpy);
    SyncHandle ();
    return ret;
}


/******************************************************************
   These are intended as a protocol interface to be used by direct
   rendering libraries.  They are not intended to be client viewable
   functions.  These will stay in place until we have a mechanism in
   place similar to that of OpenGL with an libXvMCcore library.
*******************************************************************/

/*
   _xvmc_create_context -

   Pass in the context with the surface_type_id, width, height,
   port and flags filled out.  This function will fill out the
   context_id and update the width, height and flags field.
   The server may return implementation-specific information
   back in the priv_data.  The size of that information will
   an array of priv_count CARD32s.  This data is allocated by
   this function.  If returned, the caller is responsible for
   freeing it!  Generally, such information is only returned if
   an XVMC_DIRECT context was specified.
*/


Status _xvmc_create_context (
    Display *dpy,
    XvMCContext *context,
    int *priv_count,
    CARD32 **priv_data
)
{
    XExtDisplayInfo *info = xvmc_find_display(dpy);
    xvmcCreateContextReply rep;
    xvmcCreateContextReq  *req;

    *priv_count = 0;
    *priv_data = NULL;

    XvMCCheckExtension (dpy, info, BadImplementation);

    LockDisplay (dpy);
    XvMCGetReq (CreateContext, req);
    context->context_id = XAllocID(dpy);
    req->context_id = context->context_id;
    req->port = context->port;
    req->surface_type_id = context->surface_type_id;
    req->width = context->width;
    req->height = context->height;
    req->flags = context->flags;
    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay (dpy);
        SyncHandle ();
        return BadImplementation;
    }
    context->width = rep.width_actual;
    context->height = rep.height_actual;
    context->flags = rep.flags_return;

    if(rep.length) {
	if (rep.length < (INT_MAX >> 2))
	    *priv_data = Xmalloc(rep.length << 2);
	if(*priv_data) {
            _XRead(dpy, (char*)(*priv_data), rep.length << 2);
	    *priv_count = rep.length;
	} else
	    _XEatDataWords(dpy, rep.length);
    }

    UnlockDisplay (dpy);
    SyncHandle ();
    return Success;
}

Status _xvmc_destroy_context (
    Display *dpy,
    XvMCContext *context
)
{
    XExtDisplayInfo *info = xvmc_find_display(dpy);
    xvmcDestroyContextReq  *req;

    XvMCCheckExtension (dpy, info, BadImplementation);

    LockDisplay (dpy);
    XvMCGetReq (DestroyContext, req);
    req->context_id = context->context_id;
    UnlockDisplay (dpy);
    SyncHandle ();
    return Success;
}


/*
   _xvmc_create_surface -

   Pass the context and this function will fill out all the
   information in the surface.
   The server may return implementation-specific information
   back in the priv_data.  The size of that information will
   an array of priv_count CARD32s.  This data is allocated by
   this function.  If returned, the caller is responsible for
   freeing it!  Generally, such information is returned only if
   the context was a direct context.

*/

Status _xvmc_create_surface (
    Display *dpy,
    XvMCContext *context,
    XvMCSurface *surface,
    int *priv_count,
    CARD32 **priv_data
)
{
    XExtDisplayInfo *info = xvmc_find_display(dpy);
    xvmcCreateSurfaceReply rep;
    xvmcCreateSurfaceReq  *req;

    *priv_count = 0;
    *priv_data = NULL;

    XvMCCheckExtension (dpy, info, BadImplementation);

    LockDisplay (dpy);
    XvMCGetReq (CreateSurface, req);

    surface->surface_id = XAllocID(dpy);
    surface->context_id = context->context_id;
    surface->surface_type_id = context->surface_type_id;
    surface->width = context->width;
    surface->height = context->height;

    req->surface_id = surface->surface_id;
    req->context_id = surface->context_id;
    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay (dpy);
        SyncHandle ();
        return BadImplementation;
    }

    if(rep.length) {
        if (rep.length < (INT_MAX >> 2))
            *priv_data = Xmalloc(rep.length << 2);
        if(*priv_data) {
            _XRead(dpy, (char*)(*priv_data), rep.length << 2);
            *priv_count = rep.length;
        } else
            _XEatDataWords(dpy, rep.length);
    }

    UnlockDisplay (dpy);
    SyncHandle ();
    return Success;
}

Status _xvmc_destroy_surface (
    Display *dpy,
    XvMCSurface *surface
)
{
    XExtDisplayInfo *info = xvmc_find_display(dpy);
    xvmcDestroySurfaceReq  *req;

    XvMCCheckExtension (dpy, info, BadImplementation);

    LockDisplay (dpy);
    XvMCGetReq (DestroySurface, req);
    req->surface_id = surface->surface_id;
    UnlockDisplay (dpy);
    SyncHandle ();
    return Success;
}

/*
   _xvmc_create_subpicture -

   Pass the subpicture with the width, height and xvimage_id filled
   out and this function will fill out everything else in the
   subpicture as well as adjust the width and height if needed.
   The server may return implementation-specific information
   back in the priv_data.  The size of that information will
   an array of priv_count CARD32s.  This data is allocated by
   this function.  If returned, the caller is responsible for
   freeing it!  Generally, such information is returned only if
   the context was a direct context.

*/

Status _xvmc_create_subpicture (
    Display *dpy,
    XvMCContext *context,
    XvMCSubpicture *subpicture,
    int *priv_count,
    CARD32 **priv_data
)
{
    XExtDisplayInfo *info = xvmc_find_display(dpy);
    xvmcCreateSubpictureReply rep;
    xvmcCreateSubpictureReq  *req;

    *priv_count = 0;
    *priv_data = NULL;

    XvMCCheckExtension (dpy, info, BadImplementation);

    LockDisplay (dpy);
    XvMCGetReq (CreateSubpicture, req);

    subpicture->subpicture_id = XAllocID(dpy);
    subpicture->context_id = context->context_id;

    req->subpicture_id = subpicture->subpicture_id;
    req->context_id = subpicture->context_id;
    req->xvimage_id = subpicture->xvimage_id;
    req->width = subpicture->width;
    req->height = subpicture->height;
    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay (dpy);
        SyncHandle ();
        return BadImplementation;
    }

    subpicture->width = rep.width_actual;
    subpicture->height = rep.height_actual;
    subpicture->num_palette_entries = rep.num_palette_entries;
    subpicture->entry_bytes = rep.entry_bytes;
    subpicture->component_order[0] = rep.component_order[0];
    subpicture->component_order[1] = rep.component_order[1];
    subpicture->component_order[2] = rep.component_order[2];
    subpicture->component_order[3] = rep.component_order[3];

    if(rep.length) {
        if (rep.length < (INT_MAX >> 2))
            *priv_data = Xmalloc(rep.length << 2);
        if(*priv_data) {
            _XRead(dpy, (char*)(*priv_data), rep.length << 2);
            *priv_count = rep.length;
        } else
            _XEatDataWords(dpy, rep.length);
    }

    UnlockDisplay (dpy);
    SyncHandle ();
    return Success;
}

Status _xvmc_destroy_subpicture(
    Display *dpy,
    XvMCSubpicture *subpicture
)
{
    XExtDisplayInfo *info = xvmc_find_display(dpy);
    xvmcDestroySubpictureReq  *req;

    XvMCCheckExtension (dpy, info, BadImplementation);

    LockDisplay (dpy);
    XvMCGetReq (DestroySubpicture, req);
    req->subpicture_id = subpicture->subpicture_id;
    UnlockDisplay (dpy);
    SyncHandle ();
    return Success;
}

Status XvMCGetDRInfo(Display *dpy, XvPortID port,
		     char **name, char **busID,
		     int *major, int *minor,
		     int *patchLevel,
		     int *isLocal)
{
    XExtDisplayInfo *info = xvmc_find_display(dpy);
    xvmcGetDRInfoReply rep;
    xvmcGetDRInfoReq  *req;
    CARD32 magic;

#ifdef HAVE_SHMAT
    volatile CARD32 *shMem;
    struct timezone here;
    struct timeval now;
    here.tz_minuteswest = 0;
    here.tz_dsttime = 0;
#endif

    *name = NULL;
    *busID = NULL;

    XvMCCheckExtension (dpy, info, BadImplementation);

    LockDisplay (dpy);
    XvMCGetReq (GetDRInfo, req);

    req->port = port;
    magic = 0;
    req->magic = 0;
#ifdef HAVE_SHMAT
    req->shmKey = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0600);

    /*
     * We fill a shared memory page with a repetitive pattern. If the
     * X server can read this pattern, we probably have a local connection.
     * Note that we can trigger the remote X server to read any shared
     * page on the remote machine, so we shouldn't be able to guess and verify
     * any complicated data on those pages. Thats the explanation of this
     * otherwise stupid-looking pattern algorithm.
     */

    if (req->shmKey >= 0) {
	shMem = (CARD32 *) shmat(req->shmKey, NULL, 0);
	shmctl( req->shmKey, IPC_RMID, NULL);
	if ( shMem ) {

	    register volatile CARD32 *shMemC = shMem;
	    register int i;

	    gettimeofday( &now, &here);
	    magic = now.tv_usec & 0x000FFFFF;
	    req->magic = magic;
	    i = 1024 / sizeof(CARD32);
	    while(i--) {
	        *shMemC++ = magic;
	        magic = ~magic;
	    }
	} else {
	    req->shmKey = -1;
	}
    }
#else
    req->shmKey = 0;
#endif
    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {
        UnlockDisplay (dpy);
        SyncHandle ();
#ifdef HAVE_SHMAT
	if ( req->shmKey >= 0) {
	    shmdt( (const void *) shMem );
	}
#endif
        return -1;
    }
#ifdef HAVE_SHMAT
    shmdt( (const void *) shMem );
#endif

    if (rep.length > 0) {
	unsigned long realSize = 0;
	char *tmpBuf = NULL;

	if ((rep.length < (INT_MAX >> 2)) &&
	    /* protect against overflow in strncpy below */
	    (rep.nameLen + rep.busIDLen > rep.nameLen)) {
	    realSize = rep.length << 2;
	    if (realSize >= (rep.nameLen + rep.busIDLen)) {
		tmpBuf = Xmalloc(realSize);
		*name = Xmalloc(rep.nameLen);
		*busID = Xmalloc(rep.busIDLen);
	    }
	}

	if (*name && *busID && tmpBuf) {
	    _XRead(dpy, tmpBuf, realSize);
	    strncpy(*name,tmpBuf,rep.nameLen);
	    (*name)[rep.nameLen == 0 ? 0 : rep.nameLen - 1] = '\0';
	    strncpy(*busID,tmpBuf+rep.nameLen,rep.busIDLen);
	    (*busID)[rep.busIDLen == 0 ? 0 : rep.busIDLen - 1] = '\0';
	    XFree(tmpBuf);
	} else {
	    XFree(*name);
	    *name = NULL;
	    XFree(*busID);
	    *busID = NULL;
	    XFree(tmpBuf);

	    _XEatDataWords(dpy, rep.length);
	    UnlockDisplay (dpy);
	    SyncHandle ();
	    return -1;

	}
    }

    UnlockDisplay (dpy);
    SyncHandle ();
    *major = rep.major;
    *minor = rep.minor;
    *patchLevel = rep.patchLevel;
    *isLocal = (req->shmKey > 0) ? rep.isLocal : 1;
    return (rep.length > 0) ? Success : BadImplementation;
}

@


1.6
log
@Update to libXvMC 1.0.9
@
text
@d579 1
a579 1
	    (*name)[rep.nameLen - 1] = '\0';
d581 1
a581 1
	    (*busID)[rep.busIDLen - 1] = '\0';
@


1.6.4.1
log
@Protocol handling issues in X Window System client libraries
X.Org security advisory: October 4, 2016

Fix a number of issues in the way various X client libraries handle
server responses.

Checked by tj@@
@
text
@d579 1
a579 1
	    (*name)[rep.nameLen == 0 ? 0 : rep.nameLen - 1] = '\0';
d581 1
a581 1
	    (*busID)[rep.busIDLen == 0 ? 0 : rep.busIDLen - 1] = '\0';
@


1.6.6.1
log
@Protocol handling issues in X Window System client libraries
X.Org security advisory: October 4, 2016

Fix a number of issues in the way various X client libraries handle
server responses.

Checked by tj@@
@
text
@d579 1
a579 1
	    (*name)[rep.nameLen == 0 ? 0 : rep.nameLen - 1] = '\0';
d581 1
a581 1
	    (*busID)[rep.busIDLen == 0 ? 0 : rep.busIDLen - 1] = '\0';
@


1.5
log
@Update to libXvMC 1.0.8
@
text
@a20 11
#ifndef HAVE__XEATDATAWORDS
static inline void _XEatDataWords(Display *dpy, unsigned long n)
{
# ifndef LONG64
    if (n >= (ULONG_MAX >> 2))
        _XIOError(dpy);
# endif
    _XEatData (dpy, n << 2);
}
#endif

@


1.4
log
@Merge upstream fixes for several X libs vulnerabilities
discovered by Ilja van Sprundel.

CVE-2013-1981 X.org libX11 1.5.99.901 (1.6 RC1) integer overflows
CVE-2013-1982 X.org libXext 1.3.1 integer overflows
CVE-2013-1983 X.org libXfixes 5.0 integer overflows
CVE-2013-1984 X.org libXi 1.7.1 integer overflows
CVE-2013-1985 X.org libXinerama 1.1.2 integer overflows
CVE-2013-1986 X.org libXrandr 1.4.0 integer overflows
CVE-2013-1987 X.org libXrender 0.9.7 integer overflows
CVE-2013-1988 X.org libXRes 1.0.6 integer overflows
CVE-2013-1989 X.org libXv 1.0.7 integer overflows
CVE-2013-1990 X.org libXvMC 1.0.7 integer overflows
CVE-2013-1991 X.org libXxf86dga 1.1.3 integer overflows
CVE-2013-1992 X.org libdmx 1.1.2 integer overflows
CVE-2013-1994 X.org libchromeXvMC & libchromeXvMCPro in openChrome
0.3.2 integer overflows
CVE-2013-1995 X.org libXi 1.7.1 sign extension issues
CVE-2013-1996 X.org libFS 1.0.4 sign extension issues
CVE-2013-1997 X.org libX11 1.5.99.901 (1.6 RC1) buffer overflows
CVE-2013-1998 X.org libXi 1.7.1 buffer overflows
CVE-2013-1999 X.org libXvMC 1.0.7 buffer overflows
CVE-2013-2000 X.org libXxf86dga 1.1.3 buffer overflows
CVE-2013-2001 X.org libXxf86vm 1.1.2 buffer overflows
CVE-2013-2002 X.org libXt 1.1.3 buffer overflows
CVE-2013-2003 X.org libXcursor 1.1.13 integer overflows
CVE-2013-2004 X.org libX11 1.5.99.901 (1.6 RC1) unbounded recursion
CVE-2013-2005 X.org libXt 1.1.3 memory corruption
CVE-2013-2066 X.org libXv 1.0.7 buffer overflows
@
text
@d576 3
a578 1
	if (rep.length < (INT_MAX >> 2)) {
d590 1
a590 1
	    name[rep.nameLen - 1] = '\0';
d592 1
a592 1
	    busID[rep.busIDLen - 1] = '\0';
d598 1
a598 1
	    *name = NULL;
@


1.3
log
@Upate to libXvMC 1.0.7
@
text
@d19 12
d126 2
a127 2
	surface_info =
	    (XvMCSurfaceInfo*)Xmalloc(rep.num * sizeof(XvMCSurfaceInfo));
d149 1
a149 1
	   _XEatData(dpy, rep.length << 2);
d187 2
a188 2
        ret =
	   (XvImageFormatValues*)Xmalloc(rep.num * sizeof(XvImageFormatValues));
d222 1
a222 1
	   _XEatData(dpy, rep.length << 2);
d288 2
a289 1
	*priv_data = Xmalloc(rep.length << 2);
d294 1
a294 1
	    _XEatData(dpy, rep.length << 2);
d370 2
a371 1
        *priv_data = Xmalloc(rep.length << 2);
d376 1
a376 1
            _XEatData(dpy, rep.length << 2);
d461 2
a462 1
        *priv_data = Xmalloc(rep.length << 2);
d467 1
a467 1
            _XEatData(dpy, rep.length << 2);
a501 1
    char *tmpBuf = NULL;
d512 3
d573 2
d576 6
a581 13
        int realSize = rep.length << 2;

	tmpBuf = (char *) Xmalloc(realSize);
	if (tmpBuf) {
	    *name = (char *) Xmalloc(rep.nameLen);
	    if (*name) {
		*busID = (char *) Xmalloc(rep.busIDLen);
		if (! *busID) {
		    XFree(*name);
		    XFree(tmpBuf);
		}
	    } else {
		XFree(tmpBuf);
a585 1

d588 1
d590 1
a591 1

d593 5
d599 1
a599 1
	    _XEatData(dpy, realSize);
@


1.2
log
@Update to libXvMC 1.0.6. No functionnal change.
@
text
@d6 1
a6 1
#ifdef HAS_SHM
d14 1
a14 1
#endif /* HAS_SHM */
d22 1
a22 1
static char *xvmc_extension_name = XvMCName;
d24 1
a24 1
static char *xvmc_error_list[] =
d103 1
a103 1
    
d114 1
a114 1
	surface_info = 
d129 1
a129 1
	       surface_info[i].subpicture_max_width = 
d131 1
a131 1
	       surface_info[i].subpicture_max_height = 
d175 1
a175 1
        ret = 
d186 3
a188 3
              ret[i].id = Info.id;            
              ret[i].type = Info.type;        
              ret[i].byte_order = Info.byte_order;            
d190 9
a198 9
              ret[i].bits_per_pixel = Info.bpp;       
              ret[i].format = Info.format;            
              ret[i].num_planes = Info.num_planes;            
              ret[i].depth = Info.depth;              
              ret[i].red_mask = Info.red_mask;        
              ret[i].green_mask = Info.green_mask;            
              ret[i].blue_mask = Info.blue_mask;              
              ret[i].y_sample_bits = Info.y_sample_bits;              
              ret[i].u_sample_bits = Info.u_sample_bits;              
d215 1
a215 1
    return ret; 
d219 1
a219 1
/****************************************************************** 
d224 3
a226 3
*******************************************************************/ 
 
/* 
d237 1
a237 1
   an XVMC_DIRECT context was specified. 
d312 1
a312 1
   information in the surface. 
d319 1
a319 1
 
d472 1
a472 1
    req->subpicture_id = subpicture->subpicture_id; 
d479 2
a480 2
		     char **name, char **busID, 
		     int *major, int *minor, 
d490 1
a490 1
#ifdef HAS_SHM
d506 1
a506 1
#ifdef HAS_SHM 
d517 1
a517 1
   
d521 1
a521 1
	if ( shMem ) { 
d531 1
a531 1
	        *shMemC++ = magic; 
d544 1
a544 1
#ifdef HAS_SHM
d547 1
a547 1
	}            
d551 1
a551 1
#ifdef HAS_SHM
d570 1
a570 1
	    }	    
@


1.1
log
@Initial revision
@
text
@d1 3
a3 4
/* $XFree86: xc/lib/XvMC/XvMC.c,v 1.4 2001/11/14 21:54:38 mvojkovi Exp $ */

#define NEED_REPLIES

d519 2
a520 2
	shMem = (CARD32 *) shmat(req->shmKey, 0, 0);
	shmctl( req->shmKey, IPC_RMID, 0);
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@libXvMC 1.0.4
@
text
@a4 3
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
d520 2
a521 2
	shMem = (CARD32 *) shmat(req->shmKey, NULL, 0);
	shmctl( req->shmKey, IPC_RMID, NULL);
@

