head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.16
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.14
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.12
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.10
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.8
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.6
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.10
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_1_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.01.05.15.02.20;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.17.15.16.03;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.31.17.48.42;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.17.01.38;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.17.01.38;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.30.06.44.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to libXdamage 1.4.4. No actual code change.
@
text
@/*
 * Copyright © 2003 Keith Packard
 * Copyright © 2007 Eric Anholt
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "xdamageint.h"

XDamageExtInfo XDamageExtensionInfo;

const char XDamageExtensionName[] = DAMAGE_NAME;

static int
XDamageCloseDisplay (Display *dpy, XExtCodes *codes);

static Bool
XDamageWireToEvent(Display *dpy, XEvent *event, xEvent *wire);

static Status
XDamageEventToWire(Display *dpy, XEvent *event, xEvent *wire);

/*
 * XDamageExtAddDisplay - add a display to this extension. (Replaces
 * XextAddDisplay)
 */
static XDamageExtDisplayInfo *
XDamageExtAddDisplay (XDamageExtInfo	*extinfo,
                      Display		*dpy,
                      const char	*ext_name)
{
    XDamageExtDisplayInfo    *info;
    int			    ev;

    info = (XDamageExtDisplayInfo *) Xmalloc (sizeof (XDamageExtDisplayInfo));
    if (!info) return NULL;
    info->display = dpy;

    info->codes = XInitExtension (dpy, ext_name);

    /*
     * if the server has the extension, then we can initialize the
     * appropriate function vectors
     */
    if (info->codes) {
	xDamageQueryVersionReply	rep;
	xDamageQueryVersionReq	*req;
        XESetCloseDisplay (dpy, info->codes->extension,
                           XDamageCloseDisplay);
	for (ev = info->codes->first_event;
	     ev < info->codes->first_event + XDamageNumberEvents;
	     ev++)
	{
	    XESetWireToEvent (dpy, ev, XDamageWireToEvent);
	    XESetEventToWire (dpy, ev, XDamageEventToWire);
	}
	/*
	 * Get the version info
	 */
	LockDisplay (dpy);
	GetReq (DamageQueryVersion, req);
	req->reqType = info->codes->major_opcode;
	req->damageReqType = X_DamageQueryVersion;
	req->majorVersion = DAMAGE_MAJOR;
	req->minorVersion = DAMAGE_MINOR;
	if (!_XReply (dpy, (xReply *) &rep, 0, xTrue))
	{
	    UnlockDisplay (dpy);
	    SyncHandle ();
	    Xfree(info);
	    return NULL;
	}
	info->major_version = rep.majorVersion;
	info->minor_version = rep.minorVersion;
	UnlockDisplay (dpy);
	SyncHandle ();
    } else {
	/* The server doesn't have this extension.
	 * Use a private Xlib-internal extension to hang the close_display
	 * hook on so that the "cache" (extinfo->cur) is properly cleaned.
	 * (XBUG 7955)
	 */
	XExtCodes *codes = XAddExtension(dpy);
	if (!codes) {
	    XFree(info);
	    return NULL;
	}
        XESetCloseDisplay (dpy, codes->extension, XDamageCloseDisplay);
    }

    /*
     * now, chain it onto the list
     */
    _XLockMutex(_Xglobal_lock);
    info->next = extinfo->head;
    extinfo->head = info;
    extinfo->cur = info;
    extinfo->ndisplays++;
    _XUnlockMutex(_Xglobal_lock);
    return info;
}


/*
 * XDamageExtRemoveDisplay - remove the indicated display from the
 * extension object. (Replaces XextRemoveDisplay.)
 */
static int
XDamageExtRemoveDisplay (XDamageExtInfo *extinfo, Display *dpy)
{
    XDamageExtDisplayInfo *info, *prev;

    /*
     * locate this display and its back link so that it can be removed
     */
    _XLockMutex(_Xglobal_lock);
    prev = NULL;
    for (info = extinfo->head; info; info = info->next) {
	if (info->display == dpy) break;
	prev = info;
    }
    if (!info) {
	_XUnlockMutex(_Xglobal_lock);
	return 0;		/* hmm, actually an error */
    }

    /*
     * remove the display from the list; handles going to zero
     */
    if (prev)
	prev->next = info->next;
    else
	extinfo->head = info->next;

    extinfo->ndisplays--;
    if (info == extinfo->cur) extinfo->cur = NULL;  /* flush cache */
    _XUnlockMutex(_Xglobal_lock);

    Xfree ((char *) info);
    return 1;
}

/*
 * XDamageExtFindDisplay - look for a display in this extension; keeps a
 * cache of the most-recently used for efficiency. (Replaces
 * XextFindDisplay.)
 */
static XDamageExtDisplayInfo *
XDamageExtFindDisplay (XDamageExtInfo *extinfo,
		      Display	    *dpy)
{
    XDamageExtDisplayInfo *info;

    /*
     * see if this was the most recently accessed display
     */
    if ((info = extinfo->cur) && info->display == dpy)
	return info;

    /*
     * look for display in list
     */
    _XLockMutex(_Xglobal_lock);
    for (info = extinfo->head; info; info = info->next) {
	if (info->display == dpy) {
	    extinfo->cur = info;     /* cache most recently used */
	    _XUnlockMutex(_Xglobal_lock);
	    return info;
	}
    }
    _XUnlockMutex(_Xglobal_lock);

    return NULL;
}

XDamageExtDisplayInfo *
XDamageFindDisplay (Display *dpy)
{
    XDamageExtDisplayInfo *info;

    info = XDamageExtFindDisplay (&XDamageExtensionInfo, dpy);
    if (!info)
	info = XDamageExtAddDisplay (&XDamageExtensionInfo, dpy,
				    XDamageExtensionName);
    return info;
}

static int
XDamageCloseDisplay (Display *dpy, XExtCodes *codes)
{
    return XDamageExtRemoveDisplay (&XDamageExtensionInfo, dpy);
}

static Bool
XDamageWireToEvent(Display *dpy, XEvent *event, xEvent *wire)
{
    XDamageExtDisplayInfo *info = XDamageFindDisplay(dpy);

    XDamageCheckExtension(dpy, info, False);

    switch ((wire->u.u.type & 0x7F) - info->codes->first_event)
    {
    case XDamageNotify: {
	XDamageNotifyEvent *aevent = (XDamageNotifyEvent *) event;
	xDamageNotifyEvent *awire = (xDamageNotifyEvent *) wire;

	aevent->type = awire->type & 0x7F;
	aevent->serial = _XSetLastRequestRead(dpy,
					      (xGenericReply *) wire);
	aevent->send_event = (awire->type & 0x80) != 0;
	aevent->display = dpy;
	aevent->drawable = awire->drawable;
	aevent->damage = awire->damage;
	aevent->level = awire->level & ~DamageNotifyMore;
	aevent->more = (awire->level & DamageNotifyMore) ? True : False;
	aevent->timestamp = awire->timestamp;
	aevent->area.x = awire->area.x;
	aevent->area.y = awire->area.y;
	aevent->area.width = awire->area.width;
	aevent->area.height = awire->area.height;
	aevent->geometry.x = awire->geometry.x;
	aevent->geometry.y = awire->geometry.y;
	aevent->geometry.width = awire->geometry.width;
	aevent->geometry.height = awire->geometry.height;
	return True;
    }
    }
    return False;
}

static Status
XDamageEventToWire(Display *dpy, XEvent *event, xEvent *wire)
{
    XDamageExtDisplayInfo *info = XDamageFindDisplay(dpy);

    XDamageCheckExtension(dpy, info, False);

    switch ((event->type & 0x7F) - info->codes->first_event)
    {
    case XDamageNotify: {
	XDamageNotifyEvent *aevent;
	xDamageNotifyEvent *awire;
	awire = (xDamageNotifyEvent *) wire;
	aevent = (XDamageNotifyEvent *) event;
	awire->type = aevent->type | (aevent->send_event ? 0x80 : 0);
	awire->drawable = aevent->drawable;
	awire->damage = aevent->damage;
	awire->level = aevent->level | (aevent->more ? DamageNotifyMore : 0);
	awire->timestamp = aevent->timestamp;
	awire->area.x = aevent->area.x;
	awire->area.y = aevent->area.y;
	awire->area.width = aevent->area.width;
	awire->area.height = aevent->area.height;
	awire->geometry.x = aevent->geometry.x;
	awire->geometry.y = aevent->geometry.y;
	awire->geometry.width = aevent->geometry.width;
	awire->geometry.height = aevent->geometry.height;
	return True;
    }
    }
    return False;
}

Bool
XDamageQueryExtension (Display *dpy,
			int *event_base_return,
			int *error_base_return)
{
    XDamageExtDisplayInfo *info = XDamageFindDisplay (dpy);

    if (XDamageHasExtension(info))
    {
	*event_base_return = info->codes->first_event;
	*error_base_return = info->codes->first_error;
	return True;
    }
    else
	return False;
}

Status
XDamageQueryVersion (Display *dpy,
		    int	    *major_version_return,
		    int	    *minor_version_return)
{
    XDamageExtDisplayInfo	*info = XDamageFindDisplay (dpy);

    XDamageCheckExtension (dpy, info, 0);

    *major_version_return = info->major_version;
    *minor_version_return = info->minor_version;
    return 1;
}

Damage
XDamageCreate (Display *dpy, Drawable drawable, int level)
{
    XDamageExtDisplayInfo	*info = XDamageFindDisplay (dpy);
    xDamageCreateReq		*req;
    Damage			damage;

    XDamageCheckExtension (dpy, info, 0);
    LockDisplay (dpy);
    GetReq (DamageCreate, req);
    req->reqType = info->codes->major_opcode;
    req->damageReqType = X_DamageCreate;
    req->damage = damage = XAllocID (dpy);
    req->drawable = drawable;
    req->level = level;
    UnlockDisplay (dpy);
    SyncHandle ();
    return damage;
}

void
XDamageDestroy (Display *dpy, Damage damage)
{
    XDamageExtDisplayInfo	*info = XDamageFindDisplay (dpy);
    xDamageDestroyReq		*req;

    XDamageSimpleCheckExtension (dpy, info);
    LockDisplay (dpy);
    GetReq (DamageDestroy, req);
    req->reqType = info->codes->major_opcode;
    req->damageReqType = X_DamageDestroy;
    req->damage = damage;
    UnlockDisplay (dpy);
    SyncHandle ();
}

void
XDamageSubtract (Display *dpy, Damage damage,
		 XserverRegion repair, XserverRegion parts)
{
    XDamageExtDisplayInfo	*info = XDamageFindDisplay (dpy);
    xDamageSubtractReq		*req;

    XDamageSimpleCheckExtension (dpy, info);
    LockDisplay (dpy);
    GetReq (DamageSubtract, req);
    req->reqType = info->codes->major_opcode;
    req->damageReqType = X_DamageSubtract;
    req->damage = damage;
    req->repair = repair;
    req->parts = parts;
    UnlockDisplay (dpy);
    SyncHandle ();
}

void
XDamageAdd (Display *dpy, Drawable drawable, XserverRegion region)
{
    XDamageExtDisplayInfo	*info = XDamageFindDisplay (dpy);
    xDamageAddReq		*req;

    XDamageSimpleCheckExtension (dpy, info);
    LockDisplay (dpy);
    GetReq (DamageAdd, req);
    req->reqType = info->codes->major_opcode;
    req->damageReqType = X_DamageAdd;
    req->drawable = drawable;
    req->region = region;

    UnlockDisplay (dpy);
    SyncHandle ();
}
@


1.3
log
@update to libXdamage 1.1.3
@
text
@d35 1
a35 1
    
d61 1
a61 1
     * if the server has the extension, then we can initialize the 
d67 1
a67 1
        XESetCloseDisplay (dpy, info->codes->extension, 
d85 1
a85 1
	if (!_XReply (dpy, (xReply *) &rep, 0, xTrue)) 
d127 1
a127 1
static int 
d168 1
a168 1
XDamageExtFindDisplay (XDamageExtInfo *extinfo, 
d176 1
a176 1
    if ((info = extinfo->cur) && info->display == dpy) 
d202 1
a202 1
	info = XDamageExtAddDisplay (&XDamageExtensionInfo, dpy, 
d206 1
a206 1
    
d283 1
a283 1
Bool 
d290 1
a290 1
    if (XDamageHasExtension(info)) 
d295 1
a295 1
    } 
d300 1
a300 1
Status 
d351 1
a351 1
XDamageSubtract (Display *dpy, Damage damage, 
@


1.2
log
@Update to libXdamage 1.1.2
@
text
@a1 2
 * $Id: Xdamage.c,v 1.1.1.2 2007/09/30 06:44:31 matthieu Exp $
 *
d95 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id$
d5 1
d92 1
a92 1
	    return 0;
d234 2
a235 1
	aevent->level = awire->level;
d268 1
a268 1
	awire->level = aevent->level;
d285 3
a287 1
XDamageQueryExtension (Display *dpy, int *event_basep, int *error_basep)
d293 2
a294 2
	*event_basep = info->codes->first_event;
	*error_basep = info->codes->first_error;
d303 2
a304 2
		    int	    *major_versionp,
		    int	    *minor_versionp)
d310 2
a311 2
    *major_versionp = info->major_version;
    *minor_versionp = info->minor_version;
d366 18
@


1.1.1.1
log
@import from X.Org 7.2RC1
@
text
@@


1.1.1.2
log
@libXdamage 1.1.1
@
text
@a4 1
 * Copyright © 2007 Eric Anholt
a361 19
    UnlockDisplay (dpy);
    SyncHandle ();
}

void
XDamageAdd (Display *dpy, Drawable drawable, XserverRegion region)
{
    XDamageExtDisplayInfo	*info = XDamageFindDisplay (dpy);
    xDamageAddReq		*req;
    int				len;

    XDamageSimpleCheckExtension (dpy, info);
    LockDisplay (dpy);
    GetReq (DamageAdd, req);
    req->reqType = info->codes->major_opcode;
    req->damageReqType = X_DamageAdd;
    req->drawable = drawable;
    req->region = region;

@

