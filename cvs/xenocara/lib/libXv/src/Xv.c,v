head	1.7;
access;
symbols
	OPENBSD_6_0:1.6.0.12
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.10
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_3:1.1.1.1
	v1_0_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.10.04.15.09.40;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	GVeZqdrCarv5MMe3;

1.6
date	2013.09.28.17.51.21;	author matthieu;	state Exp;
branches
	1.6.10.1
	1.6.12.1;
next	1.5;

1.5
date	2013.06.23.09.51.38;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2013.05.23.22.42.11;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.03.10.16.59.02;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.31.16.30.04;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.04.54;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.04.54;	author matthieu;	state Exp;
branches;
next	;

1.6.10.1
date	2016.10.04.18.55.14;	author matthieu;	state Exp;
branches;
next	;
commitid	PNaHexTGDQbxwlMB;

1.6.12.1
date	2016.10.04.18.54.01;	author matthieu;	state Exp;
branches;
next	;
commitid	b1RDOJn7dNqLwuaq;


desc
@@


1.7
log
@Protocol handling issues in libXv

The Xv query functions for adaptors and encodings suffer from out of boundary
accesses if a hostile X server sends a maliciously crafted response.

A previous fix already checks the received length against fixed values but
ignores additional length specifications which are stored inside the received
data.

These lengths are accessed in a for-loop. The easiest way to guarantee a
correct processing is by validating all lengths against the remaining size
left before accessing referenced memory.

This makes the previously applied check obsolete, therefore I removed it.

From Tobias Stoeckmann / X.Org security advisory Oct 4, 2016
@
text
@/***********************************************************
Copyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/
/*
** File:
**
**   Xv.c --- Xv library extension module.
**
** Author:
**
**   David Carver (Digital Workstation Engineering/Project Athena)
**
** Revisions:
**
**   26.06.91 Carver
**     - changed XvFreeAdaptors to XvFreeAdaptorInfo
**     - changed XvFreeEncodings to XvFreeEncodingInfo
**
**   11.06.91 Carver
**     - changed SetPortControl to SetPortAttribute
**     - changed GetPortControl to GetPortAttribute
**     - changed QueryBestSize
**
**   15.05.91 Carver
**     - version 2.0 upgrade
**
**   240.01.91 Carver
**     - version 1.4 upgrade
**
*/

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <stdio.h>
#include "Xvlibint.h"
#include <X11/extensions/Xext.h>
#include <X11/extensions/extutil.h>
#include <X11/extensions/XShm.h>
#include <limits.h>

static XExtensionInfo _xv_info_data;
static XExtensionInfo *xv_info = &_xv_info_data;
static const char *xv_extension_name = XvName;

#define XvCheckExtension(dpy, i, val) \
  XextCheckExtension(dpy, i, xv_extension_name, val)

#define pad_to_int32(bytes) (((bytes) + 3) & ~3U)

static char *xv_error_string(Display *dpy, int code, XExtCodes *codes,
                             char *buf, int n);
static int xv_close_display(Display *dpy, XExtCodes *codes);
static Bool xv_wire_to_event(Display *dpy, XEvent *host, xEvent *wire);

static XExtensionHooks xv_extension_hooks = {
    NULL,                       /* create_gc */
    NULL,                       /* copy_gc */
    NULL,                       /* flush_gc */
    NULL,                       /* free_gc */
    NULL,                       /* create_font */
    NULL,                       /* free_font */
    xv_close_display,           /* close_display */
    xv_wire_to_event,           /* wire_to_event */
    NULL,                       /* event_to_wire */
    NULL,                       /* error */
    xv_error_string             /* error_string */
};


static const char *xv_error_list[] = {
    "BadPort",                  /* XvBadPort     */
    "BadEncoding",              /* XvBadEncoding */
    "BadControl"                /* XvBadControl  */
};

static XEXT_GENERATE_CLOSE_DISPLAY(xv_close_display, xv_info)

static XEXT_GENERATE_FIND_DISPLAY(xv_find_display, xv_info,
				  xv_extension_name, &xv_extension_hooks,
				  XvNumEvents, NULL)

static XEXT_GENERATE_ERROR_STRING(xv_error_string, xv_extension_name,
				  XvNumErrors, xv_error_list)


int
XvQueryExtension(
    Display *dpy,
    unsigned int *p_version,
    unsigned int *p_revision,
    unsigned int *p_requestBase,
    unsigned int *p_eventBase,
    unsigned int *p_errorBase)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvQueryExtensionReq *req;
    xvQueryExtensionReply rep;
    int status;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    XvGetReq(QueryExtension, req);

    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse)) {
        status = XvBadExtension;
        goto out;
    }

    *p_version = rep.version;
    *p_revision = rep.revision;
    *p_requestBase = info->codes->major_opcode;
    *p_eventBase = info->codes->first_event;
    *p_errorBase = info->codes->first_error;

    status = Success;

  out:
    UnlockDisplay(dpy);
    SyncHandle();

    return status;
}

int
XvQueryAdaptors(
    Display *dpy,
    Window window,
    unsigned int *p_nAdaptors,
    XvAdaptorInfo **p_pAdaptors)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvQueryAdaptorsReq *req;
    xvQueryAdaptorsReply rep;
    size_t size;
    unsigned int ii, jj;
    char *name;
    char *end;
    XvAdaptorInfo *pas = NULL, *pa;
    XvFormat *pfs, *pf;
    char *buffer = NULL;
    union {
        char *buffer;
        char *string;
        xvAdaptorInfo *pa;
        xvFormat *pf;
    } u;
    int status;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    XvGetReq(QueryAdaptors, req);
    req->window = window;

    /* READ THE REPLY */

    if (_XReply(dpy, (xReply *) &rep, 0, xFalse) == 0) {
        rep.num_adaptors = 0;
        status = XvBadReply;
        goto out;
    }

    size = rep.length << 2;
    if (size > 0) {
        if ((buffer = Xmalloc(size)) == NULL) {
            _XEatDataWords(dpy, rep.length);
            status = XvBadAlloc;
            goto out;
        }
        _XRead(dpy, buffer, (long) size);
    }

    /* GET INPUT ADAPTORS */

    if (rep.num_adaptors == 0) {
        /* If there are no adaptors, there's nothing more to do. */
        status = Success;
        goto out;
    }

    u.buffer = buffer;
    end = buffer + size;

    size = rep.num_adaptors * sizeof(XvAdaptorInfo);
    if ((pas = Xmalloc(size)) == NULL) {
        status = XvBadAlloc;
        goto out;
    }

    /* INIT ADAPTOR FIELDS */

    pa = pas;
    for (ii = 0; ii < rep.num_adaptors; ii++) {
        pa->num_adaptors = 0;
        pa->name = (char *) NULL;
        pa->formats = (XvFormat *) NULL;
        pa++;
    }

    pa = pas;
    for (ii = 0; ii < rep.num_adaptors; ii++) {
        if (u.buffer + sz_xvAdaptorInfo > end) {
            status = XvBadReply;
            goto out;
        }
        pa->type = u.pa->type;
        pa->base_id = u.pa->base_id;
        pa->num_ports = u.pa->num_ports;
        pa->num_formats = u.pa->num_formats;
        pa->num_adaptors = rep.num_adaptors - ii;

        /* GET ADAPTOR NAME */

        size = u.pa->name_size;
        u.buffer += pad_to_int32(sz_xvAdaptorInfo);

        if (u.buffer + size > end) {
            status = XvBadReply;
            goto out;
        }
        if ((name = Xmalloc(size + 1)) == NULL) {
            status = XvBadAlloc;
            goto out;
        }
        (void) strncpy(name, u.string, size);
        name[size] = '\0';
        pa->name = name;

        u.buffer += pad_to_int32(size);

        /* GET FORMATS */

        size = pa->num_formats * sizeof(XvFormat);
        if ((pfs = Xmalloc(size)) == NULL) {
            status = XvBadAlloc;
            goto out;
        }

        pf = pfs;
        for (jj = 0; jj < pa->num_formats; jj++) {
            if (u.buffer + sz_xvFormat > end) {
                Xfree(pfs);
                status = XvBadReply;
                goto out;
            }
            pf->depth = u.pf->depth;
            pf->visual_id = u.pf->visual;
            pf++;

            u.buffer += pad_to_int32(sz_xvFormat);
        }

        pa->formats = pfs;

        pa++;

    }

    status = Success;

  out:
    if (status != Success) {
        XvFreeAdaptorInfo(pas);
        pas = NULL;
    }

    *p_nAdaptors = rep.num_adaptors;
    *p_pAdaptors = pas;

    Xfree(buffer);
    UnlockDisplay(dpy);
    SyncHandle();

    return status;
}


void
XvFreeAdaptorInfo(XvAdaptorInfo *pAdaptors)
{
    XvAdaptorInfo *pa;
    unsigned int ii;

    if (!pAdaptors)
        return;

    pa = pAdaptors;

    for (ii = 0; ii < pAdaptors->num_adaptors; ii++, pa++) {
        if (pa->name) {
            Xfree(pa->name);
        }
        if (pa->formats) {
            Xfree(pa->formats);
        }
    }

    Xfree(pAdaptors);
}

int
XvQueryEncodings(
    Display *dpy,
    XvPortID port,
    unsigned int *p_nEncodings,
    XvEncodingInfo ** p_pEncodings)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvQueryEncodingsReq *req;
    xvQueryEncodingsReply rep;
    size_t size;
    unsigned int jj;
    char *name;
    char *end;
    XvEncodingInfo *pes = NULL, *pe;
    char *buffer = NULL;
    union {
        char *buffer;
        char *string;
        xvEncodingInfo *pe;
    } u;
    int status;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    XvGetReq(QueryEncodings, req);
    req->port = port;

    /* READ THE REPLY */

    if (_XReply(dpy, (xReply *) &rep, 0, xFalse) == 0) {
        rep.num_encodings = 0;
        status = XvBadReply;
        goto out;
    }

    size = rep.length << 2;
    if (size > 0) {
        if ((buffer = Xmalloc(size)) == NULL) {
            _XEatDataWords(dpy, rep.length);
            status = XvBadAlloc;
            goto out;
        }
        _XRead(dpy, buffer, (long) size);
    }

    /* GET ENCODINGS */

    if (rep.num_encodings == 0) {
        /* If there are no encodings, there's nothing more to do. */
        status = Success;
        goto out;
    }

    u.buffer = buffer;
    end = buffer + size;

    size = rep.num_encodings * sizeof(XvEncodingInfo);
    if ((pes = Xmalloc(size)) == NULL) {
        status = XvBadAlloc;
        goto out;
    }

    /* INITIALIZE THE ENCODING POINTER */

    pe = pes;
    for (jj = 0; jj < rep.num_encodings; jj++) {
        pe->name = (char *) NULL;
        pe->num_encodings = 0;
        pe++;
    }

    pe = pes;
    for (jj = 0; jj < rep.num_encodings; jj++) {
        if (u.buffer + sz_xvEncodingInfo > end) {
            status = XvBadReply;
            goto out;
        }
        pe->encoding_id = u.pe->encoding;
        pe->width = u.pe->width;
        pe->height = u.pe->height;
        pe->rate.numerator = u.pe->rate.numerator;
        pe->rate.denominator = u.pe->rate.denominator;
        pe->num_encodings = rep.num_encodings - jj;

        size = u.pe->name_size;
        u.buffer += pad_to_int32(sz_xvEncodingInfo);

        if (u.buffer + size > end) {
            status = XvBadReply;
            goto out;
        }
        if ((name = Xmalloc(size + 1)) == NULL) {
            status = XvBadAlloc;
            goto out;
        }
        strncpy(name, u.string, size);
        name[size] = '\0';
        pe->name = name;
        pe++;

        u.buffer += pad_to_int32(size);
    }

    status = Success;

  out:
    if (status != Success) {
        XvFreeEncodingInfo(pes);
        pes = NULL;
    }

    *p_nEncodings = rep.num_encodings;
    *p_pEncodings = pes;

    Xfree(buffer);
    UnlockDisplay(dpy);
    SyncHandle();

    return (Success);
}

void
XvFreeEncodingInfo(XvEncodingInfo *pEncodings)
{
    XvEncodingInfo *pe;
    unsigned long ii;

    if (!pEncodings)
        return;

    pe = pEncodings;

    for (ii = 0; ii < pEncodings->num_encodings; ii++, pe++) {
        if (pe->name)
            Xfree(pe->name);
    }

    Xfree(pEncodings);
}

int
XvPutVideo(
    Display *dpy,
    XvPortID port,
    Drawable d,
    GC gc,
    int vx, int vy,
    unsigned int vw, unsigned int vh,
    int dx, int dy,
    unsigned int dw, unsigned int dh)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvPutVideoReq *req;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    FlushGC(dpy, gc);

    XvGetReq(PutVideo, req);

    req->port = port;
    req->drawable = d;
    req->gc = gc->gid;
    req->vid_x = vx;
    req->vid_y = vy;
    req->vid_w = vw;
    req->vid_h = vh;
    req->drw_x = dx;
    req->drw_y = dy;
    req->drw_w = dw;
    req->drw_h = dh;

    UnlockDisplay(dpy);
    SyncHandle();

    return Success;
}

int
XvPutStill(
    Display *dpy,
    XvPortID port,
    Drawable d,
    GC gc,
    int vx, int vy,
    unsigned int vw, unsigned int vh,
    int dx, int dy,
    unsigned int dw, unsigned int dh)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvPutStillReq *req;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    FlushGC(dpy, gc);

    XvGetReq(PutStill, req);
    req->port = port;
    req->drawable = d;
    req->gc = gc->gid;
    req->vid_x = vx;
    req->vid_y = vy;
    req->vid_w = vw;
    req->vid_h = vh;
    req->drw_x = dx;
    req->drw_y = dy;
    req->drw_w = dw;
    req->drw_h = dh;

    UnlockDisplay(dpy);
    SyncHandle();

    return Success;
}

int
XvGetVideo(
    Display *dpy,
    XvPortID port,
    Drawable d,
    GC gc,
    int vx, int vy,
    unsigned int vw, unsigned int vh,
    int dx, int dy,
    unsigned int dw, unsigned int dh)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvGetVideoReq *req;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    FlushGC(dpy, gc);

    XvGetReq(GetVideo, req);
    req->port = port;
    req->drawable = d;
    req->gc = gc->gid;
    req->vid_x = vx;
    req->vid_y = vy;
    req->vid_w = vw;
    req->vid_h = vh;
    req->drw_x = dx;
    req->drw_y = dy;
    req->drw_w = dw;
    req->drw_h = dh;

    UnlockDisplay(dpy);
    SyncHandle();

    return Success;
}

int
XvGetStill(
    Display *dpy,
    XvPortID port,
    Drawable d,
    GC gc,
    int vx, int vy,
    unsigned int vw, unsigned int vh,
    int dx, int dy,
    unsigned int dw, unsigned int dh)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvGetStillReq *req;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    FlushGC(dpy, gc);

    XvGetReq(GetStill, req);
    req->port = port;
    req->drawable = d;
    req->gc = gc->gid;
    req->vid_x = vx;
    req->vid_y = vy;
    req->vid_w = vw;
    req->vid_h = vh;
    req->drw_x = dx;
    req->drw_y = dy;
    req->drw_w = dw;
    req->drw_h = dh;

    UnlockDisplay(dpy);
    SyncHandle();

    return Success;
}

int
XvStopVideo(Display *dpy, XvPortID port, Drawable draw)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvStopVideoReq *req;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    XvGetReq(StopVideo, req);
    req->port = port;
    req->drawable = draw;

    UnlockDisplay(dpy);
    SyncHandle();

    return Success;
}

int
XvGrabPort(Display *dpy, XvPortID port, Time time)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    int result;
    xvGrabPortReply rep;
    xvGrabPortReq *req;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    XvGetReq(GrabPort, req);
    req->port = port;
    req->time = time;

    if (_XReply(dpy, (xReply *) &rep, 0, xTrue) == 0)
        rep.result = GrabSuccess;

    result = rep.result;

    UnlockDisplay(dpy);
    SyncHandle();

    return result;
}

int
XvUngrabPort(Display *dpy, XvPortID port, Time time)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvUngrabPortReq *req;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    XvGetReq(UngrabPort, req);
    req->port = port;
    req->time = time;

    UnlockDisplay(dpy);
    SyncHandle();

    return Success;
}

int
XvSelectVideoNotify(Display *dpy, Drawable drawable, Bool onoff)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvSelectVideoNotifyReq *req;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    XvGetReq(SelectVideoNotify, req);
    req->drawable = drawable;
    req->onoff = onoff;

    UnlockDisplay(dpy);
    SyncHandle();

    return Success;
}

int
XvSelectPortNotify(Display *dpy, XvPortID port, Bool onoff)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvSelectPortNotifyReq *req;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    XvGetReq(SelectPortNotify, req);
    req->port = port;
    req->onoff = onoff;

    UnlockDisplay(dpy);
    SyncHandle();

    return Success;
}

int
XvSetPortAttribute(Display *dpy, XvPortID port, Atom attribute, int value)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvSetPortAttributeReq *req;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    XvGetReq(SetPortAttribute, req);
    req->port = port;
    req->attribute = attribute;
    req->value = value;

    UnlockDisplay(dpy);
    SyncHandle();

    return (Success);
}

int
XvGetPortAttribute(Display *dpy, XvPortID port, Atom attribute, int *p_value)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvGetPortAttributeReq *req;
    xvGetPortAttributeReply rep;
    int status;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    XvGetReq(GetPortAttribute, req);
    req->port = port;
    req->attribute = attribute;

    /* READ THE REPLY */

    if (_XReply(dpy, (xReply *) &rep, 0, xFalse) == 0) {
        status = XvBadReply;
    }
    else {
        *p_value = rep.value;
        status = Success;
    }

    UnlockDisplay(dpy);
    SyncHandle();

    return status;
}

int
XvQueryBestSize(
    Display *dpy,
    XvPortID port,
    Bool motion,
    unsigned int vid_w,
    unsigned int vid_h,
    unsigned int drw_w,
    unsigned int drw_h,
    unsigned int *p_actual_width,
    unsigned int *p_actual_height)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvQueryBestSizeReq *req;
    xvQueryBestSizeReply rep;
    int status;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    XvGetReq(QueryBestSize, req);
    req->port = port;
    req->motion = motion;
    req->vid_w = vid_w;
    req->vid_h = vid_h;
    req->drw_w = drw_w;
    req->drw_h = drw_h;

    /* READ THE REPLY */

    if (_XReply(dpy, (xReply *) &rep, 0, xFalse) == 0) {
        status = XvBadReply;
    }
    else {
        *p_actual_width = rep.actual_width;
        *p_actual_height = rep.actual_height;
        status = Success;
    }

    UnlockDisplay(dpy);
    SyncHandle();

    return status;
}


XvAttribute *
XvQueryPortAttributes(Display *dpy, XvPortID port, int *num)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvQueryPortAttributesReq *req;
    xvQueryPortAttributesReply rep;
    XvAttribute *ret = NULL;

    *num = 0;

    XvCheckExtension(dpy, info, NULL);

    LockDisplay(dpy);

    XvGetReq(QueryPortAttributes, req);
    req->port = port;

    /* READ THE REPLY */

    if (_XReply(dpy, (xReply *) &rep, 0, xFalse) == 0) {
        goto out;
    }

    /*
     * X server sends data packed as:
     *   attribute1, name1, attribute2, name2, ...
     * We allocate a single buffer large enough to hold them all and
     * then de-interleave the data so we return it to clients as:
     *   attribute1, attribute2, ..., name1, name2, ...
     * so that clients may refer to attributes as a simple array of
     * structs:  attributes[0], attributes[1], ...
     * and free it as a single/simple buffer.
     */

    if (rep.num_attributes) {
        unsigned long size;

        /* limit each part to no more than one half the max size */
        if ((rep.num_attributes < ((INT_MAX / 2) / sizeof(XvAttribute))) &&
            (rep.text_size < (INT_MAX / 2) - 1)) {
            size = (rep.num_attributes * sizeof(XvAttribute)) +
		rep.text_size + 1;
            ret = Xmalloc(size);
        }

        if (ret != NULL) {
            char *marker = (char *) (&ret[rep.num_attributes]);
            xvAttributeInfo Info;
            unsigned int i;

            /* keep track of remaining room for text strings */
            size = rep.text_size;

            for (i = 0; i < rep.num_attributes; i++) {
                _XRead(dpy, (char *) (&Info), sz_xvAttributeInfo);
                ret[i].flags = (int) Info.flags;
                ret[i].min_value = Info.min;
                ret[i].max_value = Info.max;
                ret[i].name = marker;
                if (Info.size <= size) {
                    _XRead(dpy, marker, Info.size);
                    marker += Info.size;
                    size -= Info.size;
                }
                (*num)++;
            }

            /* ensure final string is nil-terminated to avoid exposure of
               uninitialized memory */
            *marker = '\0';
        }
        else
            _XEatDataWords(dpy, rep.length);
    }

  out:
    UnlockDisplay(dpy);
    SyncHandle();

    return ret;
}

XvImageFormatValues *
XvListImageFormats(Display *dpy, XvPortID port, int *num)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvListImageFormatsReq *req;
    xvListImageFormatsReply rep;
    XvImageFormatValues *ret = NULL;

    *num = 0;

    XvCheckExtension(dpy, info, NULL);

    LockDisplay(dpy);

    XvGetReq(ListImageFormats, req);
    req->port = port;

    /* READ THE REPLY */

    if (_XReply(dpy, (xReply *) &rep, 0, xFalse) == 0) {
        goto out;
    }

    if (rep.num_formats) {
        if (rep.num_formats < (INT_MAX / sizeof(XvImageFormatValues)))
            ret = Xmalloc(rep.num_formats * sizeof(XvImageFormatValues));

        if (ret != NULL) {
            xvImageFormatInfo Info;
            unsigned int i;

            for (i = 0; i < rep.num_formats; i++) {
                _XRead(dpy, (char *) (&Info), sz_xvImageFormatInfo);
                ret[i].id = Info.id;
                ret[i].type = Info.type;
                ret[i].byte_order = Info.byte_order;
                memcpy(&(ret[i].guid[0]), &(Info.guid[0]), 16);
                ret[i].bits_per_pixel = Info.bpp;
                ret[i].format = Info.format;
                ret[i].num_planes = Info.num_planes;
                ret[i].depth = Info.depth;
                ret[i].red_mask = Info.red_mask;
                ret[i].green_mask = Info.green_mask;
                ret[i].blue_mask = Info.blue_mask;
                ret[i].y_sample_bits = Info.y_sample_bits;
                ret[i].u_sample_bits = Info.u_sample_bits;
                ret[i].v_sample_bits = Info.v_sample_bits;
                ret[i].horz_y_period = Info.horz_y_period;
                ret[i].horz_u_period = Info.horz_u_period;
                ret[i].horz_v_period = Info.horz_v_period;
                ret[i].vert_y_period = Info.vert_y_period;
                ret[i].vert_u_period = Info.vert_u_period;
                ret[i].vert_v_period = Info.vert_v_period;
                memcpy(&(ret[i].component_order[0]), &(Info.comp_order[0]), 32);
                ret[i].scanline_order = Info.scanline_order;
                (*num)++;
            }
        }
        else
            _XEatDataWords(dpy, rep.length);
    }

  out:
    UnlockDisplay(dpy);
    SyncHandle();

    return ret;
}

XvImage *
XvCreateImage(
    Display *dpy,
    XvPortID port,
    int id,
    char *data,
    int width,
    int height)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvQueryImageAttributesReq *req;
    xvQueryImageAttributesReply rep;
    XvImage *ret = NULL;

    XvCheckExtension(dpy, info, NULL);

    LockDisplay(dpy);

    XvGetReq(QueryImageAttributes, req);
    req->id = id;
    req->port = port;
    req->width = width;
    req->height = height;

    /* READ THE REPLY */

    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse)) {
        goto out;
    }

    if (rep.num_planes < ((INT_MAX >> 3) - sizeof(XvImage)))
        ret = Xmalloc(sizeof(XvImage) + (rep.num_planes << 3));

    if (ret != NULL) {
        ret->id = id;
        ret->width = rep.width;
        ret->height = rep.height;
        ret->data_size = rep.data_size;
        ret->num_planes = rep.num_planes;
        ret->pitches = (int *) (&ret[1]);
        ret->offsets = ret->pitches + rep.num_planes;
        ret->data = data;
        ret->obdata = NULL;
        _XRead(dpy, (char *) (ret->pitches), rep.num_planes << 2);
        _XRead(dpy, (char *) (ret->offsets), rep.num_planes << 2);
    }
    else
        _XEatDataWords(dpy, rep.length);

  out:
    UnlockDisplay(dpy);
    SyncHandle();

    return ret;
}

XvImage *
XvShmCreateImage(
    Display *dpy,
    XvPortID port,
    int id,
    char *data,
    int width,
    int height,
    XShmSegmentInfo *shminfo)
{
    XvImage *ret;

    ret = XvCreateImage(dpy, port, id, data, width, height);

    if (ret)
        ret->obdata = (XPointer) shminfo;

    return ret;
}

int
XvPutImage(
    Display *dpy,
    XvPortID port,
    Drawable d,
    GC gc,
    XvImage *image,
    int src_x, int src_y,
    unsigned int src_w, unsigned int src_h,
    int dest_x, int dest_y,
    unsigned int dest_w, unsigned int dest_h)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvPutImageReq *req;
    unsigned int len;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    FlushGC(dpy, gc);

    XvGetReq(PutImage, req);

    req->port = port;
    req->drawable = d;
    req->gc = gc->gid;
    req->id = image->id;
    req->src_x = src_x;
    req->src_y = src_y;
    req->src_w = src_w;
    req->src_h = src_h;
    req->drw_x = dest_x;
    req->drw_y = dest_y;
    req->drw_w = dest_w;
    req->drw_h = dest_h;
    req->width = image->width;
    req->height = image->height;

    len = ((unsigned int) image->data_size + 3) >> 2;
    SetReqLen(req, len, len);

    /* Yes it's kindof lame that we are sending the whole thing,
       but for video all of it may be needed even if displaying
       only a subsection, and I don't want to go through the
       trouble of creating subregions to send */
    Data(dpy, (char *) image->data, image->data_size);

    UnlockDisplay(dpy);
    SyncHandle();

    return Success;
}

int
XvShmPutImage(
    Display *dpy,
    XvPortID port,
    Drawable d,
    GC gc,
    XvImage *image,
    int src_x, int src_y,
    unsigned int src_w, unsigned int src_h,
    int dest_x, int dest_y,
    unsigned int dest_w, unsigned int dest_h,
    Bool send_event)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    XShmSegmentInfo *shminfo = (XShmSegmentInfo *) image->obdata;
    xvShmPutImageReq *req;

    XvCheckExtension(dpy, info, XvBadExtension);

    LockDisplay(dpy);

    FlushGC(dpy, gc);

    XvGetReq(ShmPutImage, req);

    req->port = port;
    req->drawable = d;
    req->gc = gc->gid;
    req->shmseg = shminfo->shmseg;
    req->id = image->id;
    req->src_x = src_x;
    req->src_y = src_y;
    req->src_w = src_w;
    req->src_h = src_h;
    req->drw_x = dest_x;
    req->drw_y = dest_y;
    req->drw_w = dest_w;
    req->drw_h = dest_h;
    req->offset = image->data - shminfo->shmaddr;
    req->width = image->width;
    req->height = image->height;
    req->send_event = send_event;

    UnlockDisplay(dpy);
    SyncHandle();

    return Success;
}


static Bool
xv_wire_to_event(Display *dpy, XEvent *host, xEvent *wire)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    XvEvent *re = (XvEvent *) host;
    xvEvent *event = (xvEvent *) wire;

    XvCheckExtension(dpy, info, False);

    switch ((event->u.u.type & 0x7F) - info->codes->first_event) {
    case XvVideoNotify:
        re->xvvideo.type = event->u.u.type & 0x7f;
        re->xvvideo.serial = _XSetLastRequestRead(dpy, (xGenericReply *) event);
        re->xvvideo.send_event = ((event->u.u.type & 0x80) != 0);
        re->xvvideo.display = dpy;
        re->xvvideo.time = event->u.videoNotify.time;
        re->xvvideo.reason = event->u.videoNotify.reason;
        re->xvvideo.drawable = event->u.videoNotify.drawable;
        re->xvvideo.port_id = event->u.videoNotify.port;
        break;
    case XvPortNotify:
        re->xvport.type = event->u.u.type & 0x7f;
        re->xvport.serial = _XSetLastRequestRead(dpy, (xGenericReply *) event);
        re->xvport.send_event = ((event->u.u.type & 0x80) != 0);
        re->xvport.display = dpy;
        re->xvport.time = event->u.portNotify.time;
        re->xvport.port_id = event->u.portNotify.port;
        re->xvport.attribute = event->u.portNotify.attribute;
        re->xvport.value = event->u.portNotify.value;
        break;
    default:
        return False;
    }

    return (True);
}
@


1.6
log
@Update to libXv 1.0.10
@
text
@d161 1
d201 1
a201 1
        /* If there's no adaptors, there's nothing more to do. */
d206 2
a207 6
    if (size < (rep.num_adaptors * sz_xvAdaptorInfo)) {
        /* If there's not enough data for the number of adaptors,
           then we have a problem. */
        status = XvBadReply;
        goto out;
    }
a224 1
    u.buffer = buffer;
d227 4
d242 4
d266 5
d339 1
d377 1
a377 1
        /* If there's no encodings, there's nothing more to do. */
d382 2
a383 6
    if (size < (rep.num_encodings * sz_xvEncodingInfo)) {
        /* If there's not enough data for the number of adaptors,
           then we have a problem. */
        status = XvBadReply;
        goto out;
    }
a399 2
    u.buffer = buffer;

d402 4
d416 4
@


1.6.10.1
log
@Protocol handling issues in X Window System client libraries
X.Org security advisory: October 4, 2016

Fix a number of issues in the way various X client libraries handle
server responses.

Checked by tj@@
@
text
@a160 1
    char *end;
d200 1
a200 1
        /* If there are no adaptors, there's nothing more to do. */
d205 6
a210 2
    u.buffer = buffer;
    end = buffer + size;
d228 1
a230 4
        if (u.buffer + sz_xvAdaptorInfo > end) {
            status = XvBadReply;
            goto out;
        }
a241 4
        if (u.buffer + size > end) {
            status = XvBadReply;
            goto out;
        }
a261 5
            if (u.buffer + sz_xvFormat > end) {
                Xfree(pfs);
                status = XvBadReply;
                goto out;
            }
a329 1
    char *end;
d367 1
a367 1
        /* If there are no encodings, there's nothing more to do. */
d372 6
a377 2
    u.buffer = buffer;
    end = buffer + size;
d394 2
a397 4
        if (u.buffer + sz_xvEncodingInfo > end) {
            status = XvBadReply;
            goto out;
        }
a407 4
        if (u.buffer + size > end) {
            status = XvBadReply;
            goto out;
        }
@


1.6.12.1
log
@Protocol handling issues in X Window System client libraries
X.Org security advisory: October 4, 2016

Fix a number of issues in the way various X client libraries handle
server responses.

Checked by tj@@
@
text
@a160 1
    char *end;
d200 1
a200 1
        /* If there are no adaptors, there's nothing more to do. */
d205 6
a210 2
    u.buffer = buffer;
    end = buffer + size;
d228 1
a230 4
        if (u.buffer + sz_xvAdaptorInfo > end) {
            status = XvBadReply;
            goto out;
        }
a241 4
        if (u.buffer + size > end) {
            status = XvBadReply;
            goto out;
        }
a261 5
            if (u.buffer + sz_xvFormat > end) {
                Xfree(pfs);
                status = XvBadReply;
                goto out;
            }
a329 1
    char *end;
d367 1
a367 1
        /* If there are no encodings, there's nothing more to do. */
d372 6
a377 2
    u.buffer = buffer;
    end = buffer + size;
d394 2
a397 4
        if (u.buffer + sz_xvEncodingInfo > end) {
            status = XvBadReply;
            goto out;
        }
a407 4
        if (u.buffer + size > end) {
            status = XvBadReply;
            goto out;
        }
@


1.5
log
@Update to libXv 1.0.9
@
text
@a62 11
#ifndef HAVE__XEATDATAWORDS
static inline void _XEatDataWords(Display *dpy, unsigned long n)
{
# ifndef LONG64
    if (n >= (ULONG_MAX >> 2))
        _XIOError(dpy);
# endif
    _XEatData (dpy, n << 2);
}
#endif

d70 2
d73 1
a73 1
			     char * buf, int n);
d78 11
a88 11
    NULL,                               /* create_gc */
    NULL,                               /* copy_gc */
    NULL,                               /* flush_gc */
    NULL,                               /* free_gc */
    NULL,                               /* create_font */
    NULL,                               /* free_font */
    xv_close_display,                   /* close_display */
    xv_wire_to_event,                   /* wire_to_event */
    NULL,                               /* event_to_wire */
    NULL,                               /* error */
    xv_error_string                     /* error_string */
d92 4
a95 5
static const char *xv_error_list[] =
{
   "BadPort",	    /* XvBadPort     */
   "BadEncoding",   /* XvBadEncoding */
   "BadControl"     /* XvBadControl  */
d98 1
a98 1
static XEXT_GENERATE_CLOSE_DISPLAY (xv_close_display, xv_info)
d100 3
d104 17
a120 4
static XEXT_GENERATE_FIND_DISPLAY (xv_find_display, xv_info,
                                   xv_extension_name,
                                   &xv_extension_hooks,
				   XvNumEvents, NULL)
d122 1
d124 1
a124 2
static XEXT_GENERATE_ERROR_STRING (xv_error_string, xv_extension_name,
                                   XvNumErrors, xv_error_list)
d126 1
d128 4
a131 30
int
XvQueryExtension(
     Display *dpy,
     unsigned int *p_version,
     unsigned int *p_revision,
     unsigned int *p_requestBase,
     unsigned int *p_eventBase,
     unsigned int *p_errorBase
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvQueryExtensionReq *req;
  xvQueryExtensionReply rep;

  XvCheckExtension(dpy, info, XvBadExtension);

  LockDisplay(dpy);

  XvGetReq(QueryExtension, req);

  if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
     UnlockDisplay(dpy);
     SyncHandle();
     return XvBadExtension;
  }

  *p_version = rep.version;
  *p_revision = rep.revision;
  *p_requestBase = info->codes->major_opcode;
  *p_eventBase = info->codes->first_event;
  *p_errorBase = info->codes->first_error;
d133 11
a143 2
  UnlockDisplay(dpy);
  SyncHandle();
d145 1
a145 1
  return Success;
d150 19
a168 19
     Display *dpy,
     Window window,
     unsigned int *p_nAdaptors,
     XvAdaptorInfo **p_pAdaptors
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvQueryAdaptorsReq *req;
  xvQueryAdaptorsReply rep;
  int size,ii,jj;
  char *name;
  XvAdaptorInfo *pas, *pa;
  XvFormat *pfs, *pf;
  char *buffer;
  union
    {
      char *buffer;
      char *string;
      xvAdaptorInfo *pa;
      xvFormat *pf;
d170 16
d187 85
a271 1
  XvCheckExtension(dpy, info, XvBadExtension);
d273 3
a275 1
  LockDisplay(dpy);
d277 5
a281 2
  XvGetReq(QueryAdaptors, req);
  req->window = window;
d283 2
a284 1
  /* READ THE REPLY */
d286 3
a288 99
  if (_XReply(dpy, (xReply *)&rep, 0, xFalse) == 0) {
      UnlockDisplay(dpy);
      SyncHandle();
      return(XvBadReply);
  }

  size = rep.length << 2;
  if ( (buffer = (char *)Xmalloc ((unsigned) size)) == NULL) {
      UnlockDisplay(dpy);
      SyncHandle();
      return(XvBadAlloc);
  }
  _XRead (dpy, buffer, size);

  u.buffer = buffer;

  /* GET INPUT ADAPTORS */

  if (rep.num_adaptors == 0) {
      pas = NULL;
  } else {
      size = rep.num_adaptors*sizeof(XvAdaptorInfo);
      if ((pas=(XvAdaptorInfo *)Xmalloc(size))==NULL) {
          Xfree(buffer);
          UnlockDisplay(dpy);
          SyncHandle();
          return(XvBadAlloc);
      }
  }

  /* INIT ADAPTOR FIELDS */

  pa = pas;
  for (ii=0; ii<rep.num_adaptors; ii++) {
      pa->num_adaptors = 0;
      pa->name = (char *)NULL;
      pa->formats = (XvFormat *)NULL;
      pa++;
  }

  pa = pas;
  for (ii=0; ii<rep.num_adaptors; ii++) {
      pa->type = u.pa->type;
      pa->base_id = u.pa->base_id;
      pa->num_ports = u.pa->num_ports;
      pa->num_formats = u.pa->num_formats;
      pa->num_adaptors = rep.num_adaptors - ii;

      /* GET ADAPTOR NAME */

      size = u.pa->name_size;
      u.buffer += (sz_xvAdaptorInfo + 3) & ~3;

      if ( (name = (char *)Xmalloc(size+1)) == NULL)
	{
	  XvFreeAdaptorInfo(pas);
	  Xfree(buffer);
          UnlockDisplay(dpy);
          SyncHandle();
	  return(XvBadAlloc);
	}
      (void)strncpy(name, u.string, size);
      name[size] = '\0';
      pa->name = name;

      u.buffer += (size + 3) & ~3;

      /* GET FORMATS */

      size = pa->num_formats*sizeof(XvFormat);
      if ((pfs=(XvFormat *)Xmalloc(size))==NULL) {
	  XvFreeAdaptorInfo(pas);
	  Xfree(buffer);
          UnlockDisplay(dpy);
          SyncHandle();
	  return(XvBadAlloc);
      }

      pf = pfs;
      for (jj=0; jj<pa->num_formats; jj++) {
	  pf->depth = u.pf->depth;
	  pf->visual_id = u.pf->visual;
	  pf++;

	  u.buffer += (sz_xvFormat + 3) & ~3;
      }

      pa->formats = pfs;

      pa++;

  }

  *p_nAdaptors = rep.num_adaptors;
  *p_pAdaptors = pas;

  Xfree(buffer);
  UnlockDisplay(dpy);
  SyncHandle();
d290 1
a290 1
  return (Success);
d297 2
d300 2
a301 2
  XvAdaptorInfo *pa;
  int ii;
d303 1
a303 1
  if (!pAdaptors) return;
d305 7
a311 12
  pa = pAdaptors;

  for (ii=0; ii<pAdaptors->num_adaptors; ii++, pa++)
    {
      if (pa->name)
	{
	  Xfree(pa->name);
	}
      if (pa->formats)
	{
	  Xfree(pa->formats);
	}
d314 1
a314 1
  Xfree(pAdaptors);
d319 17
a335 17
     Display *dpy,
     XvPortID port,
     unsigned int *p_nEncodings,
     XvEncodingInfo **p_pEncodings
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvQueryEncodingsReq *req;
  xvQueryEncodingsReply rep;
  int size, jj;
  char *name;
  XvEncodingInfo *pes, *pe;
  char *buffer;
  union
    {
      char *buffer;
      char *string;
      xvEncodingInfo *pe;
d337 1
d339 1
a339 1
  XvCheckExtension(dpy, info, XvBadExtension);
d341 1
a341 1
  LockDisplay(dpy);
d343 2
a344 2
  XvGetReq(QueryEncodings, req);
  req->port = port;
d346 1
a346 1
  /* READ THE REPLY */
d348 79
a426 68
  if (_XReply(dpy, (xReply *)&rep, 0, xFalse) == 0) {
      UnlockDisplay(dpy);
      SyncHandle();
      return(XvBadReply);
  }

  size = rep.length << 2;
  if ( (buffer = (char *)Xmalloc ((unsigned) size)) == NULL) {
      UnlockDisplay(dpy);
      SyncHandle();
      return(XvBadAlloc);
  }
  _XRead (dpy, buffer, size);

  u.buffer = buffer;

  /* GET ENCODINGS */

  size = rep.num_encodings*sizeof(XvEncodingInfo);
  if ( (pes = (XvEncodingInfo *)Xmalloc(size)) == NULL) {
      Xfree(buffer);
      UnlockDisplay(dpy);
      SyncHandle();
      return(XvBadAlloc);
  }

  /* INITIALIZE THE ENCODING POINTER */

  pe = pes;
  for (jj=0; jj<rep.num_encodings; jj++) {
      pe->name = (char *)NULL;
      pe->num_encodings = 0;
      pe++;
  }

  pe = pes;
  for (jj=0; jj<rep.num_encodings; jj++) {
      pe->encoding_id = u.pe->encoding;
      pe->width = u.pe->width;
      pe->height = u.pe->height;
      pe->rate.numerator = u.pe->rate.numerator;
      pe->rate.denominator = u.pe->rate.denominator;
      pe->num_encodings = rep.num_encodings - jj;

      size = u.pe->name_size;
      u.buffer += (sz_xvEncodingInfo + 3) & ~3;

      if ( (name = (char *)Xmalloc(size+1)) == NULL) {
	  XvFreeEncodingInfo(pes);
	  Xfree(buffer);
          UnlockDisplay(dpy);
          SyncHandle();
	  return(XvBadAlloc);
      }
      strncpy(name, u.string, size);
      name[size] = '\0';
      pe->name = name;
      pe++;

      u.buffer += (size + 3) & ~3;
  }

  *p_nEncodings = rep.num_encodings;
  *p_pEncodings = pes;

  Xfree(buffer);
  UnlockDisplay(dpy);
  SyncHandle();
d428 8
a435 1
  return (Success);
d441 2
d444 2
a445 2
  XvEncodingInfo *pe;
  int ii;
d447 1
a447 1
  if (!pEncodings) return;
d449 4
a452 1
  pe = pEncodings;
d454 1
a454 5
  for (ii=0; ii<pEncodings->num_encodings; ii++, pe++) {
      if (pe->name) Xfree(pe->name);
  }

  Xfree(pEncodings);
d459 31
a489 31
     Display *dpy,
     XvPortID port,
     Drawable d,
     GC gc,
     int vx, int vy,
     unsigned int vw, unsigned int vh,
     int dx, int dy,
     unsigned int dw, unsigned int dh
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvPutVideoReq *req;

  XvCheckExtension(dpy, info, XvBadExtension);

  LockDisplay(dpy);

  FlushGC(dpy, gc);

  XvGetReq(PutVideo, req);

  req->port = port;
  req->drawable = d;
  req->gc = gc->gid;
  req->vid_x = vx;
  req->vid_y = vy;
  req->vid_w = vw;
  req->vid_h = vh;
  req->drw_x = dx;
  req->drw_y = dy;
  req->drw_w = dw;
  req->drw_h = dh;
d491 2
a492 2
  UnlockDisplay(dpy);
  SyncHandle();
d494 1
a494 1
  return Success;
d499 30
a528 30
     Display *dpy,
     XvPortID port,
     Drawable d,
     GC gc,
     int vx, int vy,
     unsigned int vw, unsigned int vh,
     int dx, int dy,
     unsigned int dw, unsigned int dh
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvPutStillReq *req;

  XvCheckExtension(dpy, info, XvBadExtension);

  LockDisplay(dpy);

  FlushGC(dpy, gc);

  XvGetReq(PutStill, req);
  req->port = port;
  req->drawable = d;
  req->gc = gc->gid;
  req->vid_x = vx;
  req->vid_y = vy;
  req->vid_w = vw;
  req->vid_h = vh;
  req->drw_x = dx;
  req->drw_y = dy;
  req->drw_w = dw;
  req->drw_h = dh;
d530 2
a531 2
  UnlockDisplay(dpy);
  SyncHandle();
d533 1
a533 1
  return Success;
d538 30
a567 30
     Display *dpy,
     XvPortID port,
     Drawable d,
     GC gc,
     int vx, int vy,
     unsigned int vw, unsigned int vh,
     int dx, int dy,
     unsigned int dw, unsigned int dh
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvGetVideoReq *req;

  XvCheckExtension(dpy, info, XvBadExtension);

  LockDisplay(dpy);

  FlushGC(dpy, gc);

  XvGetReq(GetVideo, req);
  req->port = port;
  req->drawable = d;
  req->gc = gc->gid;
  req->vid_x = vx;
  req->vid_y = vy;
  req->vid_w = vw;
  req->vid_h = vh;
  req->drw_x = dx;
  req->drw_y = dy;
  req->drw_w = dw;
  req->drw_h = dh;
d569 2
a570 2
  UnlockDisplay(dpy);
  SyncHandle();
d572 1
a572 1
  return Success;
d577 30
a606 30
     Display *dpy,
     XvPortID port,
     Drawable d,
     GC gc,
     int vx, int vy,
     unsigned int vw, unsigned int vh,
     int dx, int dy,
     unsigned int dw, unsigned int dh
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvGetStillReq *req;

  XvCheckExtension(dpy, info, XvBadExtension);

  LockDisplay(dpy);

  FlushGC(dpy, gc);

  XvGetReq(GetStill, req);
  req->port = port;
  req->drawable = d;
  req->gc = gc->gid;
  req->vid_x = vx;
  req->vid_y = vy;
  req->vid_w = vw;
  req->vid_h = vh;
  req->drw_x = dx;
  req->drw_y = dy;
  req->drw_w = dw;
  req->drw_h = dh;
d608 2
a609 2
  UnlockDisplay(dpy);
  SyncHandle();
d611 1
a611 1
  return Success;
d615 8
a622 15
XvStopVideo(
     Display *dpy,
     XvPortID port,
     Drawable draw
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvStopVideoReq *req;

  XvCheckExtension(dpy, info, XvBadExtension);

  LockDisplay(dpy);

  XvGetReq(StopVideo, req);
  req->port = port;
  req->drawable = draw;
d624 3
a626 2
  UnlockDisplay(dpy);
  SyncHandle();
d628 4
a631 1
  return Success;
d635 6
a640 9
XvGrabPort(
     Display *dpy,
     XvPortID port,
     Time time
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  int result;
  xvGrabPortReply rep;
  xvGrabPortReq *req;
d642 1
a642 1
  XvCheckExtension(dpy, info, XvBadExtension);
d644 1
a644 1
  LockDisplay(dpy);
d646 3
a648 3
  XvGetReq(GrabPort, req);
  req->port = port;
  req->time = time;
d650 2
a651 2
  if (_XReply (dpy, (xReply *) &rep, 0, xTrue) == 0)
    rep.result = GrabSuccess;
d653 1
a653 1
  result = rep.result;
d655 2
a656 2
  UnlockDisplay(dpy);
  SyncHandle();
d658 1
a658 1
  return result;
d662 8
a669 15
XvUngrabPort(
     Display *dpy,
     XvPortID port,
     Time time
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvUngrabPortReq *req;

  XvCheckExtension(dpy, info, XvBadExtension);

  LockDisplay(dpy);

  XvGetReq(UngrabPort, req);
  req->port = port;
  req->time = time;
d671 3
a673 2
  UnlockDisplay(dpy);
  SyncHandle();
d675 4
a678 1
  return Success;
d682 4
a685 15
XvSelectVideoNotify(
     Display *dpy,
     Drawable drawable,
     Bool onoff
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvSelectVideoNotifyReq *req;

  XvCheckExtension(dpy, info, XvBadExtension);

  LockDisplay(dpy);

  XvGetReq(SelectVideoNotify, req);
  req->drawable = drawable;
  req->onoff = onoff;
d687 1
a687 2
  UnlockDisplay(dpy);
  SyncHandle();
d689 10
a698 1
  return Success;
d702 6
a707 15
XvSelectPortNotify(
     Display *dpy,
     XvPortID port,
     Bool onoff
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvSelectPortNotifyReq *req;

  XvCheckExtension(dpy, info, XvBadExtension);

  LockDisplay(dpy);

  XvGetReq(SelectPortNotify, req);
  req->port = port;
  req->onoff = onoff;
d709 1
a709 2
  UnlockDisplay(dpy);
  SyncHandle();
d711 8
a718 1
  return Success;
d722 1
a722 6
XvSetPortAttribute (
     Display *dpy,
     XvPortID port,
     Atom attribute,
     int value
)
d724 2
a725 2
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvSetPortAttributeReq *req;
d727 1
a727 1
  XvCheckExtension(dpy, info, XvBadExtension);
d729 1
a729 1
  LockDisplay(dpy);
d731 4
a734 4
  XvGetReq(SetPortAttribute, req);
  req->port = port;
  req->attribute = attribute;
  req->value = value;
d736 2
a737 2
  UnlockDisplay(dpy);
  SyncHandle();
d739 1
a739 1
  return (Success);
d743 1
a743 6
XvGetPortAttribute (
     Display *dpy,
     XvPortID port,
     Atom attribute,
     int *p_value
)
d745 4
a748 3
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvGetPortAttributeReq *req;
  xvGetPortAttributeReply rep;
d750 1
a750 1
  XvCheckExtension(dpy, info, XvBadExtension);
d752 1
a752 1
  LockDisplay(dpy);
d754 3
a756 3
  XvGetReq(GetPortAttribute, req);
  req->port = port;
  req->attribute = attribute;
d758 1
a758 1
  /* READ THE REPLY */
d760 7
a766 7
  if (_XReply(dpy, (xReply *)&rep, 0, xFalse) == 0) {
      UnlockDisplay(dpy);
      SyncHandle();
      return(XvBadReply);
  }

  *p_value = rep.value;
d768 2
a769 2
  UnlockDisplay(dpy);
  SyncHandle();
d771 1
a771 1
  return (Success);
d776 47
a822 10
     Display *dpy,
     XvPortID port,
     Bool motion,
     unsigned int vid_w,
     unsigned int vid_h,
     unsigned int drw_w,
     unsigned int drw_h,
     unsigned int *p_actual_width,
     unsigned int *p_actual_height
)
d824 4
a827 3
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvQueryBestSizeReq *req;
  xvQueryBestSizeReply rep;
d829 1
a829 1
  XvCheckExtension(dpy, info, XvBadExtension);
d831 1
a831 1
  LockDisplay(dpy);
d833 1
a833 7
  XvGetReq(QueryBestSize, req);
  req->port = port;
  req->motion = motion;
  req->vid_w = vid_w;
  req->vid_h = vid_h;
  req->drw_w = drw_w;
  req->drw_h = drw_h;
d835 2
a836 1
  /* READ THE REPLY */
d838 1
a838 5
  if (_XReply(dpy, (xReply *)&rep, 0, xFalse) == 0) {
      UnlockDisplay(dpy);
      SyncHandle();
      return(XvBadReply);
  }
d840 3
a842 2
  *p_actual_width = rep.actual_width;
  *p_actual_height = rep.actual_height;
d844 51
a894 2
  UnlockDisplay(dpy);
  SyncHandle();
d896 5
a900 1
  return (Success);
d903 7
d911 203
a1113 2
XvAttribute*
XvQueryPortAttributes(Display *dpy, XvPortID port, int *num)
d1115 29
a1143 323
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvQueryPortAttributesReq *req;
  xvQueryPortAttributesReply rep;
  XvAttribute *ret = NULL;

  *num = 0;

  XvCheckExtension(dpy, info, NULL);

  LockDisplay(dpy);

  XvGetReq(QueryPortAttributes, req);
  req->port = port;

  /* READ THE REPLY */

  if (_XReply(dpy, (xReply *)&rep, 0, xFalse) == 0) {
      UnlockDisplay(dpy);
      SyncHandle();
      return ret;
  }

  /*
   * X server sends data packed as:
   *   attribute1, name1, attribute2, name2, ...
   * We allocate a single buffer large enough to hold them all and
   * then de-interleave the data so we return it to clients as:
   *   attribute1, attribute2, ..., name1, name2, ...
   * so that clients may refer to attributes as a simple array of
   * structs:  attributes[0], attributes[1], ...
   * and free it as a single/simple buffer.
   */

  if(rep.num_attributes) {
      unsigned long size;
      /* limit each part to no more than one half the max size */
      if ((rep.num_attributes < ((INT_MAX / 2) / sizeof(XvAttribute))) &&
	  (rep.text_size < (INT_MAX / 2)-1)) {
	  size = (rep.num_attributes * sizeof(XvAttribute)) + rep.text_size + 1;
	  ret = Xmalloc(size);
      }

      if (ret != NULL) {
	  char* marker = (char*)(&ret[rep.num_attributes]);
	  xvAttributeInfo Info;
	  int i;

	  /* keep track of remaining room for text strings */
	  size = rep.text_size;

	  for(i = 0; i < rep.num_attributes; i++) {
             _XRead(dpy, (char*)(&Info), sz_xvAttributeInfo);
	      ret[i].flags = (int)Info.flags;
	      ret[i].min_value = Info.min;
	      ret[i].max_value = Info.max;
	      ret[i].name = marker;
	      if (Info.size <= size) {
		  _XRead(dpy, marker, Info.size);
		  marker += Info.size;
		  size -= Info.size;
	      }
	      (*num)++;
	  }

	  /* ensure final string is nil-terminated to avoid exposure of
             uninitialized memory */
	  *marker = '\0';
      } else
	  _XEatDataWords(dpy, rep.length);
  }

  UnlockDisplay(dpy);
  SyncHandle();

  return ret;
}

XvImageFormatValues * XvListImageFormats (
   Display 	*dpy,
   XvPortID 	port,
   int 		*num
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvListImageFormatsReq *req;
  xvListImageFormatsReply rep;
  XvImageFormatValues *ret = NULL;

  *num = 0;

  XvCheckExtension(dpy, info, NULL);

  LockDisplay(dpy);

  XvGetReq(ListImageFormats, req);
  req->port = port;

  /* READ THE REPLY */

  if (_XReply(dpy, (xReply *)&rep, 0, xFalse) == 0) {
      UnlockDisplay(dpy);
      SyncHandle();
      return NULL;
  }

  if(rep.num_formats) {
      if (rep.num_formats < (INT_MAX / sizeof(XvImageFormatValues)))
	  ret = Xmalloc(rep.num_formats * sizeof(XvImageFormatValues));

      if (ret != NULL) {
	  xvImageFormatInfo Info;
	  int i;

	  for(i = 0; i < rep.num_formats; i++) {
              _XRead(dpy, (char*)(&Info), sz_xvImageFormatInfo);
	      ret[i].id = Info.id;
	      ret[i].type = Info.type;
	      ret[i].byte_order = Info.byte_order;
	      memcpy(&(ret[i].guid[0]), &(Info.guid[0]), 16);
	      ret[i].bits_per_pixel = Info.bpp;
  	      ret[i].format = Info.format;
   	      ret[i].num_planes = Info.num_planes;
    	      ret[i].depth = Info.depth;
    	      ret[i].red_mask = Info.red_mask;
    	      ret[i].green_mask = Info.green_mask;
    	      ret[i].blue_mask = Info.blue_mask;
    	      ret[i].y_sample_bits = Info.y_sample_bits;
    	      ret[i].u_sample_bits = Info.u_sample_bits;
    	      ret[i].v_sample_bits = Info.v_sample_bits;
    	      ret[i].horz_y_period = Info.horz_y_period;
    	      ret[i].horz_u_period = Info.horz_u_period;
    	      ret[i].horz_v_period = Info.horz_v_period;
    	      ret[i].vert_y_period = Info.vert_y_period;
    	      ret[i].vert_u_period = Info.vert_u_period;
    	      ret[i].vert_v_period = Info.vert_v_period;
	      memcpy(&(ret[i].component_order[0]), &(Info.comp_order[0]), 32);
    	      ret[i].scanline_order = Info.scanline_order;
	      (*num)++;
	  }
      } else
	  _XEatDataWords(dpy, rep.length);
  }

  UnlockDisplay(dpy);
  SyncHandle();

  return ret;
}

XvImage * XvCreateImage (
   Display *dpy,
   XvPortID port,
   int id,
   char *data,
   int width,
   int height
) {
   XExtDisplayInfo *info = xv_find_display(dpy);
   xvQueryImageAttributesReq *req;
   xvQueryImageAttributesReply rep;
   XvImage *ret = NULL;

   XvCheckExtension(dpy, info, NULL);

   LockDisplay(dpy);

   XvGetReq(QueryImageAttributes, req);
   req->id = id;
   req->port = port;
   req->width = width;
   req->height = height;

   /* READ THE REPLY */

   if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
       UnlockDisplay(dpy);
       SyncHandle();
      return NULL;
   }

   if (rep.num_planes < ((INT_MAX >> 3) - sizeof(XvImage)))
       ret = Xmalloc(sizeof(XvImage) + (rep.num_planes << 3));

   if (ret != NULL) {
	ret->id = id;
	ret->width = rep.width;
	ret->height = rep.height;
	ret->data_size = rep.data_size;
	ret->num_planes = rep.num_planes;
	ret->pitches = (int*)(&ret[1]);
	ret->offsets = ret->pitches + rep.num_planes;
	ret->data = data;
	ret->obdata = NULL;
  	_XRead(dpy, (char*)(ret->pitches), rep.num_planes << 2);
	_XRead(dpy, (char*)(ret->offsets), rep.num_planes << 2);
   } else
       _XEatDataWords(dpy, rep.length);

   UnlockDisplay(dpy);
   SyncHandle();

   return ret;
}

XvImage * XvShmCreateImage (
   Display *dpy,
   XvPortID port,
   int id,
   char *data,
   int width,
   int height,
   XShmSegmentInfo *shminfo
){
   XvImage *ret;

   ret = XvCreateImage(dpy, port, id, data, width, height);

   if(ret) ret->obdata = (XPointer)shminfo;

   return ret;
}

int XvPutImage (
   Display *dpy,
   XvPortID port,
   Drawable d,
   GC gc,
   XvImage *image,
   int src_x,
   int src_y,
   unsigned int src_w,
   unsigned int src_h,
   int dest_x,
   int dest_y,
   unsigned int dest_w,
   unsigned int dest_h
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  xvPutImageReq *req;
  int len;

  XvCheckExtension(dpy, info, XvBadExtension);

  LockDisplay(dpy);

  FlushGC(dpy, gc);

  XvGetReq(PutImage, req);

  req->port = port;
  req->drawable = d;
  req->gc = gc->gid;
  req->id = image->id;
  req->src_x = src_x;
  req->src_y = src_y;
  req->src_w = src_w;
  req->src_h = src_h;
  req->drw_x = dest_x;
  req->drw_y = dest_y;
  req->drw_w = dest_w;
  req->drw_h = dest_h;
  req->width = image->width;
  req->height = image->height;

  len = (image->data_size + 3) >> 2;
  SetReqLen(req, len, len);

  /* Yes it's kindof lame that we are sending the whole thing,
     but for video all of it may be needed even if displaying
     only a subsection, and I don't want to go through the
     trouble of creating subregions to send */
  Data(dpy, (char *)image->data, image->data_size);

  UnlockDisplay(dpy);
  SyncHandle();

  return Success;
}

int XvShmPutImage (
   Display *dpy,
   XvPortID port,
   Drawable d,
   GC gc,
   XvImage *image,
   int src_x,
   int src_y,
   unsigned int src_w,
   unsigned int src_h,
   int dest_x,
   int dest_y,
   unsigned int dest_w,
   unsigned int dest_h,
   Bool send_event
){
  XExtDisplayInfo *info = xv_find_display(dpy);
  XShmSegmentInfo *shminfo = (XShmSegmentInfo *)image->obdata;
  xvShmPutImageReq *req;

  XvCheckExtension(dpy, info, XvBadExtension);

  LockDisplay(dpy);

  FlushGC(dpy, gc);

  XvGetReq(ShmPutImage, req);

  req->port = port;
  req->drawable = d;
  req->gc = gc->gid;
  req->shmseg = shminfo->shmseg;
  req->id = image->id;
  req->src_x = src_x;
  req->src_y = src_y;
  req->src_w = src_w;
  req->src_h = src_h;
  req->drw_x = dest_x;
  req->drw_y = dest_y;
  req->drw_w = dest_w;
  req->drw_h = dest_h;
  req->offset = image->data - shminfo->shmaddr;
  req->width = image->width;
  req->height = image->height;
  req->send_event = send_event;
d1145 2
a1146 2
  UnlockDisplay(dpy);
  SyncHandle();
d1148 1
a1148 1
  return Success;
d1155 3
a1157 3
  XExtDisplayInfo *info = xv_find_display(dpy);
  XvEvent *re    = (XvEvent *)host;
  xvEvent *event = (xvEvent *)wire;
d1159 1
a1159 1
  XvCheckExtension(dpy, info, False);
d1161 1
a1161 2
  switch((event->u.u.type & 0x7F) - info->codes->first_event)
  {
d1163 9
a1171 10
      re->xvvideo.type = event->u.u.type & 0x7f;
      re->xvvideo.serial =
	_XSetLastRequestRead(dpy, (xGenericReply *)event);
      re->xvvideo.send_event = ((event->u.u.type & 0x80) != 0);
      re->xvvideo.display = dpy;
      re->xvvideo.time = event->u.videoNotify.time;
      re->xvvideo.reason = event->u.videoNotify.reason;
      re->xvvideo.drawable = event->u.videoNotify.drawable;
      re->xvvideo.port_id = event->u.videoNotify.port;
      break;
d1173 9
a1181 10
      re->xvport.type = event->u.u.type & 0x7f;
      re->xvport.serial =
	_XSetLastRequestRead(dpy, (xGenericReply *)event);
      re->xvport.send_event = ((event->u.u.type & 0x80) != 0);
      re->xvport.display = dpy;
      re->xvport.time = event->u.portNotify.time;
      re->xvport.port_id = event->u.portNotify.port;
      re->xvport.attribute = event->u.portNotify.attribute;
      re->xvport.value = event->u.portNotify.value;
      break;
d1183 2
a1184 2
      return False;
  }
d1186 1
a1186 1
  return (True);
a1187 2


@


1.4
log
@Merge upstream fixes for several X libs vulnerabilities
discovered by Ilja van Sprundel.

CVE-2013-1981 X.org libX11 1.5.99.901 (1.6 RC1) integer overflows
CVE-2013-1982 X.org libXext 1.3.1 integer overflows
CVE-2013-1983 X.org libXfixes 5.0 integer overflows
CVE-2013-1984 X.org libXi 1.7.1 integer overflows
CVE-2013-1985 X.org libXinerama 1.1.2 integer overflows
CVE-2013-1986 X.org libXrandr 1.4.0 integer overflows
CVE-2013-1987 X.org libXrender 0.9.7 integer overflows
CVE-2013-1988 X.org libXRes 1.0.6 integer overflows
CVE-2013-1989 X.org libXv 1.0.7 integer overflows
CVE-2013-1990 X.org libXvMC 1.0.7 integer overflows
CVE-2013-1991 X.org libXxf86dga 1.1.3 integer overflows
CVE-2013-1992 X.org libdmx 1.1.2 integer overflows
CVE-2013-1994 X.org libchromeXvMC & libchromeXvMCPro in openChrome
0.3.2 integer overflows
CVE-2013-1995 X.org libXi 1.7.1 sign extension issues
CVE-2013-1996 X.org libFS 1.0.4 sign extension issues
CVE-2013-1997 X.org libX11 1.5.99.901 (1.6 RC1) buffer overflows
CVE-2013-1998 X.org libXi 1.7.1 buffer overflows
CVE-2013-1999 X.org libXvMC 1.0.7 buffer overflows
CVE-2013-2000 X.org libXxf86dga 1.1.3 buffer overflows
CVE-2013-2001 X.org libXxf86vm 1.1.2 buffer overflows
CVE-2013-2002 X.org libXt 1.1.3 buffer overflows
CVE-2013-2003 X.org libXcursor 1.1.13 integer overflows
CVE-2013-2004 X.org libX11 1.5.99.901 (1.6 RC1) unbounded recursion
CVE-2013-2005 X.org libXt 1.1.3 memory corruption
CVE-2013-2066 X.org libXv 1.0.7 buffer overflows
@
text
@d853 11
d868 2
a869 2
	  (rep.text_size < (INT_MAX / 2))) {
	  size = (rep.num_attributes * sizeof(XvAttribute)) + rep.text_size;
d894 4
@


1.3
log
@Update to libXv 1.0.7
@
text
@d52 4
d61 12
d854 7
a860 1
      int size = (rep.num_attributes * sizeof(XvAttribute)) + rep.text_size;
d862 1
a862 1
      if((ret = Xmalloc(size))) {
d867 3
d876 5
a880 2
	      _XRead(dpy, marker, Info.size);
	      marker += Info.size;
d884 1
a884 1
	_XEatData(dpy, rep.length << 2);
d921 2
a922 1
      int size = (rep.num_formats * sizeof(XvImageFormatValues));
d924 1
a924 1
      if((ret = Xmalloc(size))) {
d955 1
a955 1
	_XEatData(dpy, rep.length << 2);
d995 4
a998 1
   if((ret = (XvImage*)Xmalloc(sizeof(XvImage) + (rep.num_planes << 3)))) {
d1011 1
a1011 1
	_XEatData(dpy, rep.length << 2);
@


1.2
log
@Update to libXv 1.0.6. No functional change.
@
text
@d7 2
a8 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d10 1
a10 1
both that copyright notice and this permission notice appear in 
d13 1
a13 1
software without specific, written prior permission.  
d25 1
a25 1
** File: 
d29 1
a29 1
** Author: 
d60 1
a60 1
static char *xv_extension_name = XvName;
d85 1
a85 1
static char *xv_error_list[] = 
d95 2
a96 2
static XEXT_GENERATE_FIND_DISPLAY (xv_find_display, xv_info, 
                                   xv_extension_name, 
d99 1
a99 1
     
d157 1
a157 1
  union 
d164 1
a164 1
  
d257 1
a257 1
	  
d299 1
a299 1
    } 
d318 1
a318 1
  union 
d324 1
a324 1
  
d430 1
a430 1
     int vx, int vy, 
d441 1
a441 1
  
d470 1
a470 1
     int vx, int vy, 
d509 1
a509 1
     int vx, int vy, 
d548 1
a548 1
     int vx, int vy, 
d623 1
a623 1
  if (_XReply (dpy, (xReply *) &rep, 0, xTrue) == 0) 
d758 1
a758 1
  
d770 1
a770 1
     unsigned int vid_w, 
d772 1
a772 1
     unsigned int drw_w, 
d774 1
a774 1
     unsigned int *p_actual_width, 
d812 1
a812 1
XvAttribute* 
d844 1
a844 1
	
d847 3
a849 3
	      ret[i].flags = (int)Info.flags;	      
	      ret[i].min_value = Info.min;	      
	      ret[i].max_value = Info.max;	      
d898 1
a898 1
	
d901 3
a903 3
	      ret[i].id = Info.id;	      
	      ret[i].type = Info.type;	      
	      ret[i].byte_order = Info.byte_order;	      
d905 9
a913 9
	      ret[i].bits_per_pixel = Info.bpp;	      
  	      ret[i].format = Info.format;	      
   	      ret[i].num_planes = Info.num_planes;	      
    	      ret[i].depth = Info.depth;	      
    	      ret[i].red_mask = Info.red_mask;	      
    	      ret[i].green_mask = Info.green_mask;	      
    	      ret[i].blue_mask = Info.blue_mask;	      
    	      ret[i].y_sample_bits = Info.y_sample_bits;	      
    	      ret[i].u_sample_bits = Info.u_sample_bits;	      
d940 2
a941 2
   int width, 
   int height 
d992 1
a992 1
   int width, 
d1015 1
a1015 1
   int dest_x, 
d1052 1
a1052 1
     only a subsection, and I don't want to go through the 
d1072 1
a1072 1
   int dest_x, 
d1085 1
a1085 1
  
d1128 1
a1128 1
      re->xvvideo.serial = 
d1139 1
a1139 1
      re->xvport.serial = 
d1149 1
a1149 1
      return False; 
@


1.1
log
@Initial revision
@
text
@a23 2
/* $XFree86: xc/lib/Xv/Xv.c,v 1.17 2003/04/28 16:56:27 dawes Exp $ */
/* $XdotOrg: xc/lib/Xv/Xv.c,v 1.2 2004/04/23 18:43:55 eich Exp $ */
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
