head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.2
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.6
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	libpciaccess-070616:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.05.10.09.31.51;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	oHH7rwfUXCSZpX6V;

1.8
date	2014.01.03.09.44.25;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.04.09.18.50.45;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.03.09.21.02.10;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.06.21.35.46;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.10.18.56.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.04.14.20.14.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.24.14.14.00;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.16.16.14.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.06.16.16.14.03;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@update to libpciaccess 0.13.4
@
text
@/*
 * (C) Copyright IBM Corporation 2006
 * Copyright (c) 2007, 2009, 2011, 2012, 2013 Oracle and/or its affiliates.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * IBM AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/*
 * Solaris devfs interfaces
 */

#include <stdlib.h>
#include <strings.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <errno.h>
#include <sys/pci.h>
#include <libdevinfo.h>
#include "pci_tools.h"

#ifdef __x86
# include <sys/sysi86.h>
# include <sys/psw.h>
#endif

#include "pciaccess.h"
#include "pciaccess_private.h"

/* #define DEBUG */

#define	INITIAL_NUM_DEVICES	256
#define	CELL_NUMS_1275	(sizeof(pci_regspec_t) / sizeof(uint_t))

typedef struct i_devnode {
    uint8_t bus;
    uint8_t dev;
    uint8_t func;
    di_node_t node;
} i_devnode_t;

typedef struct nexus {
    int fd;
    int first_bus;
    int last_bus;
    int domain;
    char *path;			/* for errors/debugging; fd is all we need */
    char *dev_path;
    struct nexus *next;
} nexus_t;

typedef struct probe_info {
    volatile size_t num_allocated_elems;
    volatile size_t num_devices;
    struct pci_device_private * volatile devices;
} probe_info_t;

typedef struct probe_args {
    probe_info_t *pinfo;
    nexus_t *nexus;
    int ret;
} probe_args_t;

typedef struct property_info {
    const char *name;
    int value;
} property_info_t;

static nexus_t *nexus_list = NULL;
#if !defined(__sparc)
static int xsvc_fd = -1;
#endif

#ifdef __sparc
static di_prom_handle_t di_phdl;
static size_t  nexus_count = 0;
#endif

/*
 * Read config space in native processor endianness.  Endian-neutral
 * processing can then take place.  On big endian machines, MSB and LSB
 * of little endian data end up switched if read as little endian.
 * They are in correct order if read as big endian.
 */
#if defined(__sparc)
# define NATIVE_ENDIAN	PCITOOL_ACC_ATTR_ENDN_BIG
#elif defined(__x86)
# define NATIVE_ENDIAN	PCITOOL_ACC_ATTR_ENDN_LTL
#else
# error "ISA is neither __sparc nor __x86"
#endif

#ifdef __sparc
#define MAPPING_DEV_PATH(dev)	 (((struct pci_device_private *) dev)->device_string)
#endif

static nexus_t *
find_nexus_for_bus( int domain, int bus )
{
    nexus_t *nexus;

    for (nexus = nexus_list ; nexus != NULL ; nexus = nexus->next) {
	if ((domain == nexus->domain) &&
	    (bus >= nexus->first_bus) && (bus <= nexus->last_bus)) {
	    return nexus;
	}
    }
    return NULL;
}

/*
 * Release all the resources
 * Solaris version
 */
static void
pci_system_solx_devfs_destroy( void )
{
    /*
     * The memory allocated for pci_sys & devices in create routines
     * will be freed in pci_system_cleanup.
     * Need to free system-specific allocations here.
     */
    nexus_t *nexus, *next;

    for (nexus = nexus_list ; nexus != NULL ; nexus = next) {
	next = nexus->next;
	close(nexus->fd);
	free(nexus->path);
	free(nexus->dev_path);
	free(nexus);
    }
    nexus_list = NULL;

#ifdef __sparc
    if (di_phdl != DI_PROM_HANDLE_NIL)
	(void) di_prom_fini(di_phdl);
#else
    if (xsvc_fd >= 0) {
	close(xsvc_fd);
	xsvc_fd = -1;
    }
#endif
}


#ifdef __sparc
/*
 * Release resources per device
 */
static void
pci_system_solx_devfs_destroy_device( struct pci_device *dev )
{
   if (MAPPING_DEV_PATH(dev))
	di_devfs_path_free((char *) MAPPING_DEV_PATH(dev));
}
#endif


static int
probe_device_node(di_node_t node, void *arg)
{
    int *retbuf = NULL;
    int len = 0, i;
    struct pci_device	*pci_base;
    probe_info_t *pinfo = ((probe_args_t *)arg)->pinfo;
    nexus_t *nexus = ((probe_args_t *)arg)->nexus;
    property_info_t property_list[] = {
        { "class-code", 0 },
        { "device-id", 0 },
        { "vendor-id", 0 },
        { "revision-id", 0},
        { "subsystem-vendor-id", 0},
        { "subsystem-id", 0},
    };
#define NUM_PROPERTIES		sizeof(property_list)/sizeof(property_info_t)

    len = di_prop_lookup_ints(DDI_DEV_T_ANY, node, "reg", &retbuf);

#ifdef __sparc
    if ((len <= 0) && di_phdl)
	len = di_prom_prop_lookup_ints(di_phdl, node, "reg", &retbuf);
#endif

    /* Exclude usb devices */
    if (len < 5) {
	return DI_WALK_CONTINUE;
    }

    pci_base = &pinfo->devices[pinfo->num_devices].base;

    pci_base->domain = nexus->domain;
    pci_base->bus = PCI_REG_BUS_G(retbuf[0]);
    pci_base->dev = PCI_REG_DEV_G(retbuf[0]);
    pci_base->func  = PCI_REG_FUNC_G(retbuf[0]);

    /* Get property values */
    for (i = 0; i < NUM_PROPERTIES; i++) {
	len = di_prop_lookup_ints(DDI_DEV_T_ANY, node,
		property_list[i].name, &retbuf);
#ifdef __sparc
	if ((len <= 0) && di_phdl)
	    len = di_prom_prop_lookup_ints(di_phdl, node,
		property_list[i].name, &retbuf);
#endif

	if (len > 0)
	    property_list[i].value = retbuf[0];
	else {
	    /* a device must have property "class-code", "device-id", "vendor-id" */
	    if (i < 3)
		return DI_WALK_CONTINUE;
#ifdef DEBUG
	    fprintf(stderr, "cannot get property \"%s\" for nexus = %s :\n",
		property_list[i].name, nexus->path);
	    fprintf(stderr, "	domain = %x, busno = %x, devno = %x, funcno = %x\n",
		pci_base->domain, pci_base->bus, pci_base->dev, pci_base->func);
#endif
	}
    }

    if ((property_list[1].value == 0) && (property_list[2].value == 0))
	return DI_WALK_CONTINUE;

    pci_base->device_class = property_list[0].value;
    pci_base->device_id = property_list[1].value;
    pci_base->vendor_id = property_list[2].value;
    pci_base->revision = property_list[3].value;
    pci_base->subvendor_id = property_list[4].value;
    pci_base->subdevice_id = property_list[5].value;

#ifdef DEBUG
    fprintf(stderr,
	    "nexus = %s, domain = %x, busno = %x, devno = %x, funcno = %x\n",
	    nexus->path, pci_base->domain, pci_base->bus, pci_base->dev, pci_base->func);
#endif

    pinfo->num_devices++;
    if (pinfo->num_devices == pinfo->num_allocated_elems) {
	struct pci_device_private *new_devs;
	size_t new_num_elems = pinfo->num_allocated_elems * 2;

	new_devs = realloc(pinfo->devices,
	new_num_elems * sizeof (struct pci_device_private));
	if (new_devs == NULL) {
	    (void) fprintf(stderr,
	           "Error allocating memory for PCI devices:"
		   " %s\n discarding additional devices\n",
		   strerror(errno));
	    ((probe_args_t *)arg)->ret = 1;
	    return (DI_WALK_TERMINATE);
	}
	(void) memset(&new_devs[pinfo->num_devices], 0,
		pinfo->num_allocated_elems *
		sizeof (struct pci_device_private));
	pinfo->num_allocated_elems = new_num_elems;
	pinfo->devices = new_devs;
    }

    return (DI_WALK_CONTINUE);
}
/*
 * This function is called from di_walk_minor() when any PROBE is processed
 */
static int
probe_nexus_node(di_node_t di_node, di_minor_t minor, void *arg)
{
    probe_info_t *pinfo = (probe_info_t *)arg;
    char *nexus_name, *nexus_dev_path;
    nexus_t *nexus;
    int fd;
    char nexus_path[MAXPATHLEN];

    di_prop_t prop;
    char *strings;
    int *ints;
    int numval;
    int pci_node = 0;
    int first_bus = 0, last_bus = PCI_REG_BUS_G(PCI_REG_BUS_M);
    int domain = 0;
    di_node_t rnode =  DI_NODE_NIL;
#ifdef __sparc
    int bus_range_found = 0;
    int device_type_found = 0;
    di_prom_prop_t prom_prop;
#endif


#ifdef DEBUG
    nexus_name = di_devfs_minor_path(minor);
    fprintf(stderr, "-- device name: %s\n", nexus_name);
    di_devfs_path_free(nexus_name);
#endif

    for (prop = di_prop_next(di_node, NULL); prop != NULL;
	 prop = di_prop_next(di_node, prop)) {

	const char *prop_name = di_prop_name(prop);

#ifdef DEBUG
	fprintf(stderr, "   property: %s\n", prop_name);
#endif

	if (strcmp(prop_name, "device_type") == 0) {
	    numval = di_prop_strings(prop, &strings);
	    if (numval == 1) {
		if (strncmp(strings, "pci", 3) != 0)
		    /* not a PCI node, bail */
		    return (DI_WALK_CONTINUE);
		else {
		    pci_node = 1;
#ifdef __sparc
		    device_type_found =  1;
#endif
		}
	    }
	}
	else if (strcmp(prop_name, "class-code") == 0) {
	    /* not a root bus node, bail */
	    return (DI_WALK_CONTINUE);
	}
	else if (strcmp(prop_name, "bus-range") == 0) {
	    numval = di_prop_ints(prop, &ints);
	    if (numval == 2) {
		first_bus = ints[0];
		last_bus = ints[1];
#ifdef __sparc
		bus_range_found = 1;
#endif
	    }
	}
#ifdef __sparc
	domain = nexus_count;
#else
	else if (strcmp(prop_name, "pciseg") == 0) {
	    numval = di_prop_ints(prop, &ints);
	    if (numval == 1) {
		domain = ints[0];
	    }
	}
#endif
    }

#ifdef __sparc
    if ((!device_type_found) && di_phdl) {
	numval = di_prom_prop_lookup_strings(di_phdl, di_node,
	    "device_type", &strings);
	if (numval == 1) {
	    if (strncmp(strings, "pci", 3) != 0)
		return (DI_WALK_CONTINUE);
	    else
		pci_node = 1;
	}
    }

    if ((!bus_range_found) && di_phdl) {
	numval = di_prom_prop_lookup_ints(di_phdl, di_node,
	    "bus-range", &ints);
	if (numval == 2) {
	    first_bus = ints[0];
	    last_bus = ints[1];
	}
    }
#endif

    if (pci_node != 1)
	return (DI_WALK_CONTINUE);

    /* we have a PCI root bus node. */
    nexus = calloc(1, sizeof(nexus_t));
    if (nexus == NULL) {
	(void) fprintf(stderr, "Error allocating memory for nexus: %s\n",
		       strerror(errno));
	return (DI_WALK_TERMINATE);
    }
    nexus->first_bus = first_bus;
    nexus->last_bus = last_bus;
    nexus->domain = domain;

#ifdef __sparc
    nexus_count++;
#endif

    nexus_name = di_devfs_minor_path(minor);
    if (nexus_name == NULL) {
	(void) fprintf(stderr, "Error getting nexus path: %s\n",
		       strerror(errno));
	free(nexus);
	return (DI_WALK_CONTINUE);
    }

    snprintf(nexus_path, sizeof(nexus_path), "/devices%s", nexus_name);
    di_devfs_path_free(nexus_name);

#ifdef DEBUG
    fprintf(stderr, "nexus = %s, bus-range = %d - %d\n",
	    nexus_path, first_bus, last_bus);
#endif

    if ((fd = open(nexus_path, O_RDWR | O_CLOEXEC)) >= 0) {
	probe_args_t args;

	nexus->fd = fd;
	nexus->path = strdup(nexus_path);
	nexus_dev_path = di_devfs_path(di_node);
	nexus->dev_path = strdup(nexus_dev_path);
	di_devfs_path_free(nexus_dev_path);

	if ((rnode = di_init(nexus->dev_path, DINFOCPYALL)) == DI_NODE_NIL) {
	    (void) fprintf(stderr, "di_init failed: %s\n", strerror(errno));
	    close(nexus->fd);
	    free(nexus->path);
	    free(nexus->dev_path);
	    free(nexus);
	    return (DI_WALK_TERMINATE);
	}

	/* Walk through devices under the rnode */
	args.pinfo = pinfo;
	args.nexus = nexus;
	args.ret = 0;

	(void) di_walk_node(rnode, DI_WALK_CLDFIRST, (void *)&args, probe_device_node);
	if (args.ret) {
	    close(nexus->fd);
	    free(nexus->path);
	    free(nexus->dev_path);
	    free(nexus);
	    di_fini(rnode);
	    return (DI_WALK_TERMINATE);
	}

	nexus->next = nexus_list;
	nexus_list = nexus;
    } else {
	(void) fprintf(stderr, "Error opening %s: %s\n",
		       nexus_path, strerror(errno));
	free(nexus);
    }

    if (rnode != DI_NODE_NIL) {
	di_fini(rnode);
    }

    return DI_WALK_CONTINUE;
}

static int
find_target_node(di_node_t node, void *arg)
{
    int *regbuf = NULL;
    int len = 0;
    uint32_t busno, funcno, devno;
    i_devnode_t *devnode = (i_devnode_t *)arg;

    /*
     * Test the property functions, only for testing
     */
    /*
    void *prop = DI_PROP_NIL;

    (void) fprintf(stderr, "start of node 0x%x\n", node->nodeid);
    while ((prop = di_prop_hw_next(node, prop)) != DI_PROP_NIL) {
	int i;
	(void) fprintf(stderr, "name=%s: ", di_prop_name(prop));
	len = 0;
	if (!strcmp(di_prop_name(prop), "reg")) {
	    len = di_prop_ints(prop, &regbuf);
	}
	for (i = 0; i < len; i++) {
	    fprintf(stderr, "0x%0x.", regbuf[i]);
	}
	fprintf(stderr, "\n");
    }
    (void) fprintf(stderr, "end of node 0x%x\n", node->nodeid);
    */

    len = di_prop_lookup_ints(DDI_DEV_T_ANY, node, "reg", &regbuf);

#ifdef __sparc
    if ((len <= 0) && di_phdl)
	len = di_prom_prop_lookup_ints(di_phdl, node, "reg", &regbuf);
#endif

    if (len <= 0) {
#ifdef DEBUG
	fprintf(stderr, "error = %x\n", errno);
	fprintf(stderr, "can not find assigned-address\n");
#endif
	return (DI_WALK_CONTINUE);
    }

    busno = PCI_REG_BUS_G(regbuf[0]);
    devno = PCI_REG_DEV_G(regbuf[0]);
    funcno = PCI_REG_FUNC_G(regbuf[0]);

    if ((busno == devnode->bus) &&
	(devno == devnode->dev) &&
	(funcno == devnode->func)) {
	devnode->node = node;

	return (DI_WALK_TERMINATE);
    }

    return (DI_WALK_CONTINUE);
}

/*
 * Solaris version
 */
static int
pci_device_solx_devfs_probe( struct pci_device * dev )
{
    int err = 0;
    di_node_t rnode = DI_NODE_NIL;
    i_devnode_t args = { 0, 0, 0, DI_NODE_NIL };
    int *regbuf;
    pci_regspec_t *reg;
    int i;
    int len = 0;
    uint ent = 0;
    struct pci_device_private *priv =
	(struct pci_device_private *) dev;
    nexus_t *nexus;

    if ( (nexus = find_nexus_for_bus(dev->domain, dev->bus)) == NULL )
	return ENODEV;

    pci_device_cfg_read_u8(dev, &priv->header_type, PCI_CONF_HEADER);

    pci_device_cfg_read_u8(dev, (uint8_t *)&dev->irq, PCI_CONF_ILINE);

    /*
     * starting to find if it is MEM/MEM64/IO
     * using libdevinfo
     */
    if ((rnode = di_init(nexus->dev_path, DINFOCPYALL)) == DI_NODE_NIL) {
	err = errno;
	(void) fprintf(stderr, "di_init failed: %s\n", strerror(errno));
    } else {
	args.bus = dev->bus;
	args.dev = dev->dev;
	args.func = dev->func;
	(void) di_walk_node(rnode, DI_WALK_CLDFIRST,
		(void *)&args, find_target_node);
    }

    if (args.node != DI_NODE_NIL) {
	int *prop;
#ifdef __sparc
	di_minor_t minor;
#endif

	priv->is_primary = 0;

#ifdef __sparc
	if (minor = di_minor_next(args.node, DI_MINOR_NIL))
	    MAPPING_DEV_PATH(dev) = di_devfs_minor_path (minor);
	else
	    MAPPING_DEV_PATH(dev) = NULL;
#endif

	if (di_prop_lookup_ints(DDI_DEV_T_ANY, args.node,
				"primary-controller", &prop) >= 1) {
	    if (prop[0])
		priv->is_primary = 1;
	}

	/*
	 * It will succeed for sure, because it was
	 * successfully called in find_target_node
	 */
	len = di_prop_lookup_ints(DDI_DEV_T_ANY, args.node,
				  "assigned-addresses",
				  &regbuf);

#ifdef __sparc
	if ((len <= 0) && di_phdl) {
	    len = di_prom_prop_lookup_ints(di_phdl, args.node,
				"assigned-addresses", &regbuf);
	}
#endif
    }

    if (len <= 0)
	goto cleanup;

    /*
     * Each BAR address get its own region slot in sequence.
     * 32 bit BAR:
     * BAR 0x10 -> slot0, BAR 0x14 -> slot1...
     * 64 bit BAR:
     * BAR 0x10 -> slot0, BAR 0x18 -> slot2...,
     * slot1 is part of BAR 0x10
     * Linux give two region slot for 64 bit address.
     */
    for (i = 0; i < len; i = i + (int)CELL_NUMS_1275) {

	reg = (pci_regspec_t *)&regbuf[i];
	ent = reg->pci_phys_hi & 0xff;

	if (ent > PCI_CONF_ROM) {
	    fprintf(stderr, "error ent = %d\n", ent);
	    break;
	}
	/*
	 * G35 broken in BAR0
	 */
	if (ent < PCI_CONF_BASE0) {
	    /*
	     * VGA resource here and ignore it
	     */
	    break;
	} else if (ent == PCI_CONF_ROM) {
	    priv->rom_base = reg->pci_phys_low |
		((uint64_t)reg->pci_phys_mid << 32);
	    dev->rom_size = reg->pci_size_low;
	} else {
	    ent = (ent - PCI_CONF_BASE0) >> 2;
	    /*
	     * non relocatable resource is excluded
	     * such like 0xa0000, 0x3b0. If it is met,
	     * the loop is broken;
	     */
	    if (!PCI_REG_REG_G(reg->pci_phys_hi))
		break;

	    if (reg->pci_phys_hi & PCI_PREFETCH_B) {
		dev->regions[ent].is_prefetchable = 1;
	    }


	    dev->regions[ent].base_addr = reg->pci_phys_low |
		((uint64_t)reg->pci_phys_mid << 32);
	    dev->regions[ent].size = reg->pci_size_low |
		((uint64_t)reg->pci_size_hi << 32);

	    switch (reg->pci_phys_hi & PCI_REG_ADDR_M) {
		case PCI_ADDR_IO:
		    dev->regions[ent].is_IO = 1;
		    break;
		case PCI_ADDR_MEM32:
		    break;
		case PCI_ADDR_MEM64:
		    dev->regions[ent].is_64 = 1;
		    /*
		     * Skip one slot for 64 bit address
		     */
		    break;
	    }
	}
    }

  cleanup:
    if (rnode != DI_NODE_NIL) {
	di_fini(rnode);
    }
    return (err);
}

/**
 * Map a memory region for a device using /dev/xsvc (x86) or fb device (sparc)
 *
 * \param dev   Device whose memory region is to be mapped.
 * \param map   Parameters of the mapping that is to be created.
 *
 * \return
 * Zero on success or an \c errno value on failure.
 */
static int
pci_device_solx_devfs_map_range(struct pci_device *dev,
				struct pci_device_mapping *map)
{
    const int prot = ((map->flags & PCI_DEV_MAP_FLAG_WRITABLE) != 0)
			? (PROT_READ | PROT_WRITE) : PROT_READ;
    int err = 0;

    const char *map_dev;
    int		map_fd;

#ifdef __sparc
    char	map_dev_buf[128];

    if (MAPPING_DEV_PATH(dev)) {
	snprintf(map_dev_buf, sizeof (map_dev_buf), "%s%s",
		 "/devices", MAPPING_DEV_PATH(dev));
	map_dev = map_dev_buf;
    }
    else
	map_dev = "/dev/fb0";

    map_fd = -1;
#else
    /*
     * Still uses xsvc to do the user space mapping on x86/x64,
     * caches open fd across multiple calls.
     */
    map_dev = "/dev/xsvc";
    map_fd = xsvc_fd;
#endif

    if (map_fd < 0) {
	if ((map_fd = open(map_dev, O_RDWR | O_CLOEXEC)) < 0) {
	    err = errno;
	    (void) fprintf(stderr, "can not open %s: %s\n", map_dev,
			   strerror(errno));
	    return err;
	}
#ifndef __sparc
        xsvc_fd = map_fd;
#endif
    }

    map->memory = mmap(NULL, map->size, prot, MAP_SHARED, map_fd, map->base);
    if (map->memory == MAP_FAILED) {
	err = errno;

	(void) fprintf(stderr, "map rom region =%llx failed: %s\n",
		       (unsigned long long) map->base, strerror(errno));
    }

#ifdef __sparc
    close (map_fd);
#endif

    return err;
}

/*
 * Solaris version: read the VGA ROM data
 */
static int
pci_device_solx_devfs_read_rom( struct pci_device * dev, void * buffer )
{
    int err;
    struct pci_device_mapping prom = {
	.base = 0xC0000,
	.size = 0x10000,
	.flags = 0
    };
    struct pci_device_private *priv =
	(struct pci_device_private *) dev;

    if (priv->rom_base) {
	prom.base = priv->rom_base;
	prom.size = dev->rom_size;
    }

    err = pci_device_solx_devfs_map_range(dev, &prom);
    if (err == 0) {
	(void) bcopy(prom.memory, buffer, dev->rom_size);

	if (munmap(prom.memory, prom.size) == -1) {
	    err = errno;
	}
    }
    return err;
}

/*
 * solaris version: Read the configurations space of the devices
 */
static int
pci_device_solx_devfs_read( struct pci_device * dev, void * data,
			     pciaddr_t offset, pciaddr_t size,
			     pciaddr_t * bytes_read )
{
    pcitool_reg_t cfg_prg;
    int err = 0;
    unsigned int i = 0;
    nexus_t *nexus;

    nexus = find_nexus_for_bus(dev->domain, dev->bus);

    *bytes_read = 0;

    if ( nexus == NULL ) {
	return ENODEV;
    }

    cfg_prg.offset = offset;
    cfg_prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_1 + NATIVE_ENDIAN;
    cfg_prg.bus_no = dev->bus;
    cfg_prg.dev_no = dev->dev;
    cfg_prg.func_no = dev->func;
    cfg_prg.barnum = 0;
    cfg_prg.user_version = PCITOOL_USER_VERSION;

    for (i = 0; i < size; i += PCITOOL_ACC_ATTR_SIZE(PCITOOL_ACC_ATTR_SIZE_1))
    {
	cfg_prg.offset = offset + i;

	if ((err = ioctl(nexus->fd, PCITOOL_DEVICE_GET_REG, &cfg_prg)) != 0) {
	    fprintf(stderr, "read bdf<%s,%x,%x,%x,%llx> config space failure\n",
		    nexus->path,
		    cfg_prg.bus_no,
		    cfg_prg.dev_no,
		    cfg_prg.func_no,
		    (unsigned long long) cfg_prg.offset);
	    fprintf(stderr, "Failure cause = %x\n", err);
	    break;
	}

	((uint8_t *)data)[i] = (uint8_t)cfg_prg.data;
	/*
	 * DWORDS Offset or bytes Offset ??
	 */
    }
    *bytes_read = i;

    return (err);
}

/*
 * Solaris version
 */
static int
pci_device_solx_devfs_write( struct pci_device * dev, const void * data,
			     pciaddr_t offset, pciaddr_t size,
			     pciaddr_t * bytes_written )
{
    pcitool_reg_t cfg_prg;
    int err = 0;
    int cmd;
    nexus_t *nexus;

    nexus = find_nexus_for_bus(dev->domain, dev->bus);

    if ( bytes_written != NULL ) {
	*bytes_written = 0;
    }

    if ( nexus == NULL ) {
	return ENODEV;
    }

    cfg_prg.offset = offset;
    switch (size) {
        case 1:
	    cfg_prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_1 + NATIVE_ENDIAN;
	    cfg_prg.data = *((const uint8_t *)data);
	    break;
        case 2:
	    cfg_prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_2 + NATIVE_ENDIAN;
	    cfg_prg.data = *((const uint16_t *)data);
	    break;
        case 4:
	    cfg_prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_4 + NATIVE_ENDIAN;
	    cfg_prg.data = *((const uint32_t *)data);
	    break;
        case 8:
	    cfg_prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_8 + NATIVE_ENDIAN;
	    cfg_prg.data = *((const uint64_t *)data);
	    break;
        default:
	    return EINVAL;
    }
    cfg_prg.bus_no = dev->bus;
    cfg_prg.dev_no = dev->dev;
    cfg_prg.func_no = dev->func;
    cfg_prg.barnum = 0;
    cfg_prg.user_version = PCITOOL_USER_VERSION;

    /*
     * Check if this device is bridge device.
     * If it is, it is also a nexus node???
     * It seems that there is no explicit
     * PCI nexus device for X86, so not applicable
     * from pcitool_bus_reg_ops in pci_tools.c
     */
    cmd = PCITOOL_DEVICE_SET_REG;

    if ((err = ioctl(nexus->fd, cmd, &cfg_prg)) != 0) {
	return (err);
    }
    *bytes_written = size;

    return (err);
}

static int pci_device_solx_devfs_boot_vga(struct pci_device *dev)
{
    struct pci_device_private *priv =
	(struct pci_device_private *) dev;

    return (priv->is_primary);

}

static struct pci_io_handle *
pci_device_solx_devfs_open_legacy_io(struct pci_io_handle *ret,
				     struct pci_device *dev,
				     pciaddr_t base, pciaddr_t size)
{
#ifdef __x86
    if (sysi86(SI86V86, V86SC_IOPL, PS_IOPL) == 0) {
	ret->base = base;
	ret->size = size;
	ret->is_legacy = 1;
	return ret;
    }
#endif
    return NULL;
}

static uint32_t
pci_device_solx_devfs_read32(struct pci_io_handle *handle, uint32_t reg)
{
#ifdef __x86
    uint16_t port = (uint16_t) (handle->base + reg);
    uint32_t ret;
    __asm__ __volatile__("inl %1,%0":"=a"(ret):"d"(port));
    return ret;
#else
    return *(uint32_t *)((uintptr_t)handle->memory + reg);
#endif
}

static uint16_t
pci_device_solx_devfs_read16(struct pci_io_handle *handle, uint32_t reg)
{
#ifdef __x86
    uint16_t port = (uint16_t) (handle->base + reg);
    uint16_t ret;
    __asm__ __volatile__("inw %1,%0":"=a"(ret):"d"(port));
    return ret;
#else
    return *(uint16_t *)((uintptr_t)handle->memory + reg);
#endif
}

static uint8_t
pci_device_solx_devfs_read8(struct pci_io_handle *handle, uint32_t reg)
{
#ifdef __x86
    uint16_t port = (uint16_t) (handle->base + reg);
    uint8_t ret;
    __asm__ __volatile__("inb %1,%0":"=a"(ret):"d"(port));
    return ret;
#else
    return *(uint8_t *)((uintptr_t)handle->memory + reg);
#endif
}

static void
pci_device_solx_devfs_write32(struct pci_io_handle *handle, uint32_t reg,
    uint32_t data)
{
#ifdef __x86
      uint16_t port = (uint16_t) (handle->base + reg);
      __asm__ __volatile__("outl %0,%1"::"a"(data), "d"(port));
#else
      *(uint16_t *)((uintptr_t)handle->memory + reg) = data;
#endif
}

static void
pci_device_solx_devfs_write16(struct pci_io_handle *handle, uint32_t reg,
    uint16_t data)
{
#ifdef __x86
      uint16_t port = (uint16_t) (handle->base + reg);
      __asm__ __volatile__("outw %0,%1"::"a"(data), "d"(port));
#else
    *(uint8_t *)((uintptr_t)handle->memory + reg) = data;
#endif
}

static void
pci_device_solx_devfs_write8(struct pci_io_handle *handle, uint32_t reg,
    uint8_t data)
{
#ifdef __x86
      uint16_t port = (uint16_t) (handle->base + reg);
      __asm__ __volatile__("outb %0,%1"::"a"(data), "d"(port));
#else
      *(uint32_t *)((uintptr_t)handle->memory + reg) = data;
#endif
}

static int
pci_device_solx_devfs_map_legacy(struct pci_device *dev, pciaddr_t base,
				 pciaddr_t size, unsigned map_flags,
				 void **addr)
{
    int err;
    struct pci_device_mapping map = {
	.base = base,
	.size = size,
	.flags = map_flags,
    };

    err = pci_device_solx_devfs_map_range(dev, &map);
    if (err == 0)
	*addr = map.memory;
    return err;
}

static int
pci_device_solx_devfs_unmap_legacy(struct pci_device *dev,
				   void *addr, pciaddr_t size)
{
    struct pci_device_mapping map = {
	.memory = addr,
	.size = size,
    };

    return pci_device_generic_unmap_range(dev, &map);
}

static const struct pci_system_methods solx_devfs_methods = {
    .destroy = pci_system_solx_devfs_destroy,
#ifdef __sparc
    .destroy_device = pci_system_solx_devfs_destroy_device,
#else
    .destroy_device = NULL,
#endif
    .read_rom = pci_device_solx_devfs_read_rom,
    .probe = pci_device_solx_devfs_probe,
    .map_range = pci_device_solx_devfs_map_range,
    .unmap_range = pci_device_generic_unmap_range,

    .read = pci_device_solx_devfs_read,
    .write = pci_device_solx_devfs_write,

    .fill_capabilities = pci_fill_capabilities_generic,
    .boot_vga = pci_device_solx_devfs_boot_vga,

    .open_legacy_io = pci_device_solx_devfs_open_legacy_io,
    .read32 = pci_device_solx_devfs_read32,
    .read16 = pci_device_solx_devfs_read16,
    .read8 = pci_device_solx_devfs_read8,
    .write32 = pci_device_solx_devfs_write32,
    .write16 = pci_device_solx_devfs_write16,
    .write8 = pci_device_solx_devfs_write8,
    .map_legacy = pci_device_solx_devfs_map_legacy,
    .unmap_legacy = pci_device_solx_devfs_unmap_legacy,
};

/*
 * Attempt to access PCI subsystem using Solaris's devfs interface.
 * Solaris version
 */
_pci_hidden int
pci_system_solx_devfs_create( void )
{
    int err = 0;
    di_node_t di_node;
    probe_info_t pinfo;
    struct pci_device_private *devices;

    if (nexus_list != NULL) {
	return 0;
    }

    if ((di_node = di_init("/", DINFOCPYALL)) == DI_NODE_NIL) {
	err = errno;
	(void) fprintf(stderr, "di_init() failed: %s\n",
		       strerror(errno));
	return (err);
    }

    if ((devices = calloc(INITIAL_NUM_DEVICES,
			sizeof (struct pci_device_private))) == NULL) {
	err = errno;
	di_fini(di_node);
	return (err);
    }

#ifdef __sparc
    if ((di_phdl = di_prom_init()) == DI_PROM_HANDLE_NIL)
	(void) fprintf(stderr, "di_prom_init failed: %s\n", strerror(errno));
#endif

    pinfo.num_allocated_elems = INITIAL_NUM_DEVICES;
    pinfo.num_devices = 0;
    pinfo.devices = devices;
#ifdef __sparc
    nexus_count = 0;
#endif
    (void) di_walk_minor(di_node, DDI_NT_REGACC, 0, &pinfo, probe_nexus_node);

    di_fini(di_node);

    if ((pci_sys = calloc(1, sizeof (struct pci_system))) == NULL) {
	err = errno;
	free(devices);
	return (err);
    }

    pci_sys->methods = &solx_devfs_methods;
    pci_sys->devices = pinfo.devices;
    pci_sys->num_devices = pinfo.num_devices;

    return (err);
}
@


1.8
log
@Update to libpciacces 0.13.2.
@
text
@d727 3
d917 1
@


1.7
log
@Update to libpciaccess 0.13.1
@
text
@d3 1
a3 1
 * Copyright (c) 2007, 2009, 2011, Oracle and/or its affiliates.
d41 5
a53 5
typedef union {
    uint8_t bytes[16 * sizeof (uint32_t)];
    uint32_t dwords[16];
} pci_conf_hdr_t;

a68 5
#ifdef __sparc
    struct pci_device **devlist;
    volatile size_t num_allocated_elems;
    volatile size_t num_devices;
#endif
d77 11
d95 1
a115 36
/*
 * Identify problematic southbridges.  These have device id 0x5249 and
 * vendor id 0x10b9.  Check for revision ID 0 and class code 060400 as well.
 * Values are little endian, so they are reversed for SPARC.
 *
 * Check for these southbridges on all architectures, as the issue is a
 * southbridge issue, independent of processor.
 *
 * If one of these is found during probing, skip probing other devs/funcs on
 * the rest of the bus, since the southbridge and all devs underneath will
 * otherwise disappear.
 */
#if (NATIVE_ENDIAN == PCITOOL_ACC_ATTR_ENDN_BIG)
# define U45_SB_DEVID_VID	0xb9104952
# define U45_SB_CLASS_RID	0x00000406
#else
# define U45_SB_DEVID_VID	0x524910b9
# define U45_SB_CLASS_RID	0x06040000
#endif

#ifdef __sparc
static nexus_t *
find_nexus_for_dev(struct pci_device *dev)
{
    nexus_t *nexus;
    int i;

    for (nexus = nexus_list ; nexus != NULL ; nexus = nexus->next) {
	for (i = 0; i < nexus->num_devices; i++) {
	    if (nexus->devlist[i] == dev)
		return nexus;
	}
    }
    return NULL;
}
#else
a128 10
#endif

#define GET_CONFIG_VAL_8(offset) (config_hdr.bytes[offset])
#define GET_CONFIG_VAL_16(offset) \
    (uint16_t) (GET_CONFIG_VAL_8(offset) + (GET_CONFIG_VAL_8(offset+1) << 8))
#define GET_CONFIG_VAL_32(offset) \
    (uint32_t) (GET_CONFIG_VAL_8(offset) + 		\
		(GET_CONFIG_VAL_8(offset+1) << 8) +	\
		(GET_CONFIG_VAL_8(offset+2) << 16) +	\
		(GET_CONFIG_VAL_8(offset+3) << 24))
a148 13
#ifdef __sparc
	{
	    struct pci_device *dev;
	    int i;

	    for (i = 0; i < nexus->num_devices; i++) {
		dev = nexus->devlist[i];
		if (MAPPING_DEV_PATH(dev))
		    di_devfs_path_free((char *) MAPPING_DEV_PATH(dev));
	    }
	}
	free(nexus->devlist);
#endif
d164 2
d167 1
a167 2
 * Retrieve first 16 dwords of device's config header, except for the first
 * dword.  First 16 dwords are defined by the PCI specification.
d169 2
a170 3
static int
get_config_header(int fd, uint8_t bus_no, uint8_t dev_no, uint8_t func_no,
		  pci_conf_hdr_t *config_hdr_p)
d172 2
a173 23
    pcitool_reg_t cfg_prg;
    int i;
    int rval = 0;

    /* Prepare a local pcitool_reg_t so as to not disturb the caller's. */
    cfg_prg.offset = 0;
    cfg_prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_4 + NATIVE_ENDIAN;
    cfg_prg.bus_no = bus_no;
    cfg_prg.dev_no = dev_no;
    cfg_prg.func_no = func_no;
    cfg_prg.barnum = 0;
    cfg_prg.user_version = PCITOOL_USER_VERSION;

    /* Get dwords 1-15 of config space. They must be read as uint32_t. */
    for (i = 1; i < (sizeof (pci_conf_hdr_t) / sizeof (uint32_t)); i++) {
	cfg_prg.offset += sizeof (uint32_t);
	if ((rval = ioctl(fd, PCITOOL_DEVICE_GET_REG, &cfg_prg)) != 0) {
	    break;
	}
	config_hdr_p->dwords[i] = (uint32_t)cfg_prg.data;
    }

    return (rval);
d175 1
a177 3
/*
 * Probe device's functions.  Modifies many fields in the prg_p.
 */
d179 1
a179 1
probe_dev(nexus_t *nexus, pcitool_reg_t *prg_p, probe_info_t *pinfo)
d181 14
a194 7
    pci_conf_hdr_t	config_hdr;
    boolean_t		multi_function_device;
    int8_t		func;
    int8_t		first_func = 0;
    int8_t		last_func = PCI_REG_FUNC_M >> PCI_REG_FUNC_SHIFT;
    int			rval = 0;
    struct pci_device *	pci_base;
d196 1
a196 15
    /*
     * Loop through at least func=first_func.  Continue looping through
     * functions if there are no errors and the device is a multi-function
     * device.
     *
     * (Note, if first_func == 0, header will show whether multifunction
     * device and set multi_function_device.  If first_func != 0, then we
     * will force the loop as the user wants a specific function to be
     * checked.
     */
    for (func = first_func, multi_function_device = B_FALSE;
	 ((func <= last_func) &&
	  ((func == first_func) || (multi_function_device)));
	 func++) {
	prg_p->func_no = func;
d198 4
a201 14
	/*
	 * Four things can happen here:
	 *
	 * 1) ioctl comes back as EFAULT and prg_p->status is
	 *    PCITOOL_INVALID_ADDRESS.  There is no device at this location.
	 *
	 * 2) ioctl comes back successful and the data comes back as
	 *    zero.  Config space is mapped but no device responded.
	 *
	 * 3) ioctl comes back successful and the data comes back as
	 *    non-zero.  We've found a device.
	 *
	 * 4) Some other error occurs in an ioctl.
	 */
d203 4
a206 8
	prg_p->status = PCITOOL_SUCCESS;
	prg_p->offset = 0;
	prg_p->data = 0;
	prg_p->user_version = PCITOOL_USER_VERSION;

	errno = 0;
	if (((rval = ioctl(nexus->fd, PCITOOL_DEVICE_GET_REG, prg_p)) != 0) ||
	    (prg_p->data == 0xffffffff)) {
d208 1
a208 10
	    /*
	     * Accept errno == EINVAL along with status of
	     * PCITOOL_OUT_OF_RANGE because some systems
	     * don't implement the full range of config space.
	     * Leave the loop quietly in this case.
	     */
	    if ((errno == EINVAL) ||
		(prg_p->status == PCITOOL_OUT_OF_RANGE)) {
		break;
	    }
d210 4
a213 8
	    /*
	     * Exit silently with ENXIO as this means that there are
	     * no devices under the pci root nexus.
	     */
	    else if ((errno == ENXIO) &&
		     (prg_p->status == PCITOOL_IO_ERROR)) {
		break;
	    }
d215 4
a218 8
	    /*
	     * Expect errno == EFAULT along with status of
	     * PCITOOL_INVALID_ADDRESS because there won't be
	     * devices at each stop.  Quit on any other error.
	     */
	    else if (((errno != EFAULT) ||
		      (prg_p->status != PCITOOL_INVALID_ADDRESS)) &&
		     (prg_p->data != 0xffffffff)) {
d220 3
a222 2
/* on sparc, devices can be enumerated discontiguously. Do not quit */
		rval = 0;
a223 70
		break;
	    }

	    /*
	     * If no function at this location,
	     * just advance to the next function.
	     */
	    else {
		rval = 0;
	    }

	    /*
	     * Data came back as 0.
	     * Treat as unresponsive device and check next device.
	     */
	} else if (prg_p->data == 0) {
	    rval = 0;
	    break;	/* Func loop. */

	    /* Found something. */
	} else {
	    config_hdr.dwords[0] = (uint32_t)prg_p->data;

	    /* Get the rest of the PCI header. */
	    if ((rval = get_config_header(nexus->fd, prg_p->bus_no,
					  prg_p->dev_no, prg_p->func_no,
					  &config_hdr)) != 0) {
		break;
	    }

	    /*
	     * Special case for the type of Southbridge found on
	     * Ultra-45 and other sun4u fire workstations.
	     */
	    if ((config_hdr.dwords[0] == U45_SB_DEVID_VID) &&
		(config_hdr.dwords[2] == U45_SB_CLASS_RID)) {
		rval = ECANCELED;
		break;
	    }

	    /*
	     * Found one device with bus number, device number and
	     * function number.
	     */

	    pci_base = &pinfo->devices[pinfo->num_devices].base;

	    pci_base->domain = nexus->domain;
	    pci_base->bus = prg_p->bus_no;
	    pci_base->dev = prg_p->dev_no;
	    pci_base->func = func;

	    /*
	     * for the format of device_class, see struct pci_device;
	     */

	    pci_base->device_class =
		(GET_CONFIG_VAL_8(PCI_CONF_BASCLASS) << 16) |
		(GET_CONFIG_VAL_8(PCI_CONF_SUBCLASS) << 8) |
		GET_CONFIG_VAL_8(PCI_CONF_PROGCLASS);

	    pci_base->revision		= GET_CONFIG_VAL_8(PCI_CONF_REVID);
	    pci_base->vendor_id		= GET_CONFIG_VAL_16(PCI_CONF_VENID);
	    pci_base->device_id		= GET_CONFIG_VAL_16(PCI_CONF_DEVID);
	    pci_base->subvendor_id 	= GET_CONFIG_VAL_16(PCI_CONF_SUBVENID);
	    pci_base->subdevice_id 	= GET_CONFIG_VAL_16(PCI_CONF_SUBSYSID);
	    pci_base->irq		= GET_CONFIG_VAL_8(PCI_CONF_ILINE);

	    pinfo->devices[pinfo->num_devices].header_type
					= GET_CONFIG_VAL_8(PCI_CONF_HEADER);
d225 6
d232 4
a235 43
	    fprintf(stderr,
		    "nexus = %s, busno = %x, devno = %x, funcno = %x\n",
		    nexus->path, prg_p->bus_no, prg_p->dev_no, func);
#endif

	    pinfo->num_devices++;
	    if (pinfo->num_devices == pinfo->num_allocated_elems) {
		struct pci_device_private *new_devs;
		size_t new_num_elems = pinfo->num_allocated_elems * 2;

		new_devs = realloc(pinfo->devices,
			new_num_elems * sizeof (struct pci_device_private));
		if (new_devs == NULL) {
		    (void) fprintf(stderr,
			           "Error allocating memory for PCI devices:"
				   " %s\n discarding additional devices\n",
				   strerror(errno));
		    return (rval);
		}
		(void) memset(&new_devs[pinfo->num_devices], 0,
			pinfo->num_allocated_elems *
			sizeof (struct pci_device_private));
		pinfo->num_allocated_elems = new_num_elems;
		pinfo->devices = new_devs;
	    }

#ifdef __sparc
	    nexus->devlist[nexus->num_devices++] = pci_base;

	    if (nexus->num_devices == nexus->num_allocated_elems) {
		struct pci_device **new_devs;
		size_t new_num_elems = nexus->num_allocated_elems * 2;

		new_devs = realloc(nexus->devlist,
			new_num_elems * sizeof (struct pci_device *));
		if (new_devs == NULL)
		    return (rval);
		(void) memset(&new_devs[nexus->num_devices], 0,
			nexus->num_allocated_elems *
			sizeof (struct pci_device *));
		nexus->num_allocated_elems = new_num_elems;
		nexus->devlist = new_devs;
	    }
a236 10

	    /*
	     * Accommodate devices which state their
	     * multi-functionality only in their function 0 config
	     * space.  Note multi-functionality throughout probing
	     * of all of this device's functions.
	     */
	    if (config_hdr.bytes[PCI_CONF_HEADER] & PCI_HEADER_MULTI) {
		multi_function_device = B_TRUE;
	    }
d240 2
a241 2
    return (rval);
}
d243 6
d250 26
a275 52
/*
 * Solaris version
 * Probe a given nexus config space for devices.
 *
 * fd is the file descriptor of the nexus.
 * input_args contains commandline options as specified by the user.
 */
static int
do_probe(nexus_t *nexus, probe_info_t *pinfo)
{
    pcitool_reg_t prg;
    uint32_t bus;
    uint8_t dev;
    uint32_t last_bus = nexus->last_bus;
    uint8_t last_dev = PCI_REG_DEV_M >> PCI_REG_DEV_SHIFT;
    uint8_t first_bus = nexus->first_bus;
    uint8_t first_dev = 0;
    int rval = 0;

    prg.barnum = 0;	/* Config space. */

    /* Must read in 4-byte quantities. */
    prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_4 + NATIVE_ENDIAN;

    prg.data = 0;

    /*
     * Loop through all valid bus / dev / func combinations to check for
     * all devices, with the following exceptions:
     *
     * When nothing is found at function 0 of a bus / dev combination, skip
     * the other functions of that bus / dev combination.
     *
     * When a found device's function 0 is probed and it is determined that
     * it is not a multifunction device, skip probing of that device's
     * other functions.
     */
    for (bus = first_bus; ((bus <= last_bus) && (rval == 0)); bus++) {
	prg.bus_no = (uint8_t)bus;

	for (dev = first_dev; ((dev <= last_dev) && (rval == 0)); dev++) {
	    prg.dev_no = dev;
	    rval = probe_dev(nexus, &prg, pinfo);
	}

	/*
	 * Ultra-45 southbridge workaround:
	 * ECANCELED tells to skip to the next bus.
	 */
	if (rval == ECANCELED) {
	    rval = 0;
	}
d278 1
a278 1
    return (rval);
a279 1

d299 1
d310 1
d350 3
d359 1
d399 1
a399 9
    if ((nexus->devlist = calloc(INITIAL_NUM_DEVICES,
			sizeof (struct pci_device *))) == NULL) {
	(void) fprintf(stderr, "Error allocating memory for nexus devlist: %s\n",
                       strerror(errno));
	free (nexus);
	return (DI_WALK_TERMINATE);
    }
    nexus->num_allocated_elems = INITIAL_NUM_DEVICES;
    nexus->num_devices = 0;
d419 2
d426 4
a429 4
	if ((do_probe(nexus, pinfo) != 0) && (errno != ENXIO)) {
	    (void) fprintf(stderr, "Error probing node %s: %s\n",
			   nexus_path, strerror(errno));
	    (void) close(fd);
d433 16
a448 3
	} else {
	    nexus->next = nexus_list;
	    nexus_list = nexus;
d450 3
d459 4
d540 2
a543 3
#ifdef __sparc
    if ( (nexus = find_nexus_for_dev(dev)) == NULL )
#else
a544 1
#endif
d547 4
d567 1
d572 2
d581 6
a605 26

    /*
     * how to find the size of rom???
     * if the device has expansion rom,
     * it must be listed in the last
     * cells because solaris find probe
     * the base address from offset 0x10
     * to 0x30h. So only check the last
     * item.
     */
    reg = (pci_regspec_t *)&regbuf[len - CELL_NUMS_1275];
    if (PCI_REG_REG_G(reg->pci_phys_hi) == PCI_CONF_ROM) {
	/*
	 * rom can only be 32 bits
	 */
	dev->rom_size = reg->pci_size_low;
	len = len - CELL_NUMS_1275;
    }
    else {
	/*
	 * size default to 64K and base address
	 * default to 0xC0000
	 */
	dev->rom_size = 0x10000;
    }

d607 6
a612 1
     * Solaris has its own BAR index.
d615 1
a615 1
    for (i = 0; i < len; i = i + CELL_NUMS_1275) {
d619 2
a620 5
	/*
	 * G35 broken in BAR0
	 */
	ent = (ent - PCI_CONF_BASE0) >> 2;
	if (ent >= 6) {
a623 1

d625 1
a625 3
	 * non relocatable resource is excluded
	 * such like 0xa0000, 0x3b0. If it is met,
	 * the loop is broken;
d627 4
a630 1
	if (!PCI_REG_REG_G(reg->pci_phys_hi))
d632 13
d646 3
a648 3
	if (reg->pci_phys_hi & PCI_PREFETCH_B) {
	    dev->regions[ent].is_prefetchable = 1;
	}
d651 18
a668 21
	/*
	 * We split the shift count 32 into two 16 to
	 * avoid the complaining of the compiler
	 */
	dev->regions[ent].base_addr = reg->pci_phys_low +
	    ((reg->pci_phys_mid << 16) << 16);
	dev->regions[ent].size = reg->pci_size_low +
	    ((reg->pci_size_hi << 16) << 16);

	switch (reg->pci_phys_hi & PCI_REG_ADDR_M) {
	    case PCI_ADDR_IO:
		dev->regions[ent].is_IO = 1;
		break;
	    case PCI_ADDR_MEM32:
		break;
	    case PCI_ADDR_MEM64:
		dev->regions[ent].is_64 = 1;
		/*
		 * Skip one slot for 64 bit address
		 */
		break;
d680 1
a680 1
 * Map a memory region for a device using /dev/xsvc.
d696 1
a696 2
#ifdef __sparc
    char	map_dev[128];
d699 2
a700 4
    if (MAPPING_DEV_PATH(dev))
	snprintf(map_dev, sizeof (map_dev), "%s%s", "/devices", MAPPING_DEV_PATH(dev));
    else
	strcpy (map_dev, "/dev/fb0");
d702 4
a705 5
    if ((map_fd = open(map_dev, O_RDWR | O_CLOEXEC)) < 0) {
	err = errno;
	(void) fprintf(stderr, "can not open %s: %s\n", map_dev,
			   strerror(errno));
	return err;
d707 2
d710 1
a710 1
    map->memory = mmap(NULL, map->size, prot, MAP_SHARED, map_fd, map->base);
d713 2
a714 1
     * Still used xsvc to do the user space mapping
d716 6
a721 2
    if (xsvc_fd < 0) {
	if ((xsvc_fd = open("/dev/xsvc", O_RDWR | O_CLOEXEC)) < 0) {
d723 1
a723 1
	    (void) fprintf(stderr, "can not open /dev/xsvc: %s\n",
d729 1
a729 3
    map->memory = mmap(NULL, map->size, prot, MAP_SHARED, xsvc_fd, map->base);
#endif

d734 1
a734 1
		       map->base, strerror(errno));
d753 1
a753 1
	.size = dev->rom_size,
d756 7
d768 1
a768 1
	if (munmap(prom.memory, dev->rom_size) == -1) {
d785 1
a785 1
    int i = 0;
a787 3
#ifdef __sparc
    nexus = find_nexus_for_dev(dev);
#else
a788 1
#endif
d814 1
a814 1
		    cfg_prg.offset);
a841 3
#ifdef __sparc
    nexus = find_nexus_for_dev(dev);
#else
a842 1
#endif
d896 125
d1022 2
d1027 3
d1031 1
d1040 12
a1051 1
    .fill_capabilities = pci_fill_capabilities_generic
d1092 3
@


1.6
log
@Update to libpciaccess 0.13. Tested by shadchin@@
@
text
@d666 1
a666 1
    if ((fd = open(nexus_path, O_RDWR)) >= 0) {
d934 1
a934 1
    if ((map_fd = open(map_dev, O_RDWR)) < 0) {
d947 1
a947 1
	if ((xsvc_fd = open("/dev/xsvc", O_RDWR)) < 0) {
@


1.5
log
@Update to libpciaccess 0.12.1. Ok kettenis@@, shadchin@@
@
text
@d3 1
a3 1
 * Copyright (c) 2007, 2009, Oracle and/or its affiliates.
d46 1
a46 1
#define	MAX_DEVICES	256
d65 1
d67 1
d69 5
d76 6
d83 1
d85 5
d105 4
d129 6
a134 42
static int pci_device_solx_devfs_map_range(struct pci_device *dev,
    struct pci_device_mapping *map);

static int pci_device_solx_devfs_read_rom( struct pci_device * dev,
    void * buffer );

static int pci_device_solx_devfs_probe( struct pci_device * dev );

static int pci_device_solx_devfs_read( struct pci_device * dev, void * data,
    pciaddr_t offset, pciaddr_t size, pciaddr_t * bytes_read );

static int pci_device_solx_devfs_write( struct pci_device * dev,
    const void * data, pciaddr_t offset, pciaddr_t size,
    pciaddr_t * bytes_written );

static int probe_dev(nexus_t *nexus, pcitool_reg_t *prg_p,
		     struct pci_system *pci_sys);

static int do_probe(nexus_t *nexus, struct pci_system *pci_sys);

static int probe_nexus_node(di_node_t di_node, di_minor_t minor, void *arg);

static void pci_system_solx_devfs_destroy( void );

static int get_config_header(int fd, uint8_t bus_no, uint8_t dev_no,
			     uint8_t func_no, pci_conf_hdr_t *config_hdr_p);

int pci_system_solx_devfs_create( void );

static const struct pci_system_methods solx_devfs_methods = {
    .destroy = pci_system_solx_devfs_destroy,
    .destroy_device = NULL,
    .read_rom = pci_device_solx_devfs_read_rom,
    .probe = pci_device_solx_devfs_probe,
    .map_range = pci_device_solx_devfs_map_range,
    .unmap_range = pci_device_generic_unmap_range,

    .read = pci_device_solx_devfs_read,
    .write = pci_device_solx_devfs_write,

    .fill_capabilities = pci_fill_capabilities_generic
};
d136 9
d146 1
a146 1
find_nexus_for_bus( int bus )
d151 2
a152 1
	if ((bus >= nexus->first_bus) && (bus <= nexus->last_bus)) {
d158 1
d187 14
d205 4
d213 1
a213 55
}

/*
 * Attempt to access PCI subsystem using Solaris's devfs interface.
 * Solaris version
 */
_pci_hidden int
pci_system_solx_devfs_create( void )
{
    int err = 0;
    di_node_t di_node;


    if (nexus_list != NULL) {
	return 0;
    }

    /*
     * Only allow MAX_DEVICES exists
     * I will fix it later to get
     * the total devices first
     */
    if ((pci_sys = calloc(1, sizeof (struct pci_system))) != NULL) {
	pci_sys->methods = &solx_devfs_methods;

	if ((pci_sys->devices =
	     calloc(MAX_DEVICES, sizeof (struct pci_device_private)))
	    != NULL) {

	    if ((di_node = di_init("/", DINFOCPYALL)) == DI_NODE_NIL) {
		err = errno;
		(void) fprintf(stderr, "di_init() failed: %s\n",
			       strerror(errno));
	    } else {
		(void) di_walk_minor(di_node, DDI_NT_REGACC, 0, pci_sys,
				     probe_nexus_node);
		di_fini(di_node);
	    }
	}
	else {
	    err = errno;
	}
    } else {
	err = errno;
    }

    if (err != 0) {
	if (pci_sys != NULL) {
	    free(pci_sys->devices);
	    free(pci_sys);
	    pci_sys = NULL;
	}
    }

    return (err);
d254 1
a254 1
probe_dev(nexus_t *nexus, pcitool_reg_t *prg_p, struct pci_system *pci_sys)
d332 4
d381 1
a381 1
	    pci_base = &pci_sys->devices[pci_sys->num_devices].base;
d383 1
a383 4
	    /*
	     * Domain is peer bus??
	     */
	    pci_base->domain = 0;
d402 1
d404 1
a404 1
	    pci_sys->devices[pci_sys->num_devices].header_type
d413 19
a431 6
	    if (pci_sys->num_devices < (MAX_DEVICES - 1)) {
		pci_sys->num_devices++;
	    } else {
		(void) fprintf(stderr,
			       "Maximum number of PCI devices found,"
			       " discarding additional devices\n");
d434 18
d468 58
d532 2
a533 2
    struct pci_system *pci_sys = (struct pci_system *) arg;
    char *nexus_name;
d544 7
d568 10
a577 3
	    if (numval != 1 || strncmp(strings, "pci", 3) != 0) {
		/* not a PCI node, bail */
		return (DI_WALK_CONTINUE);
a578 1
	    pci_node = 1;
d589 9
d602 22
a623 1
#ifdef __x86  /* sparc pci nodes don't have the device_type set */
a625 1
#endif
d636 13
d669 4
a672 1
	if ((do_probe(nexus, pci_sys) != 0) && (errno != ENXIO)) {
d677 1
a691 58

/*
 * Solaris version
 * Probe a given nexus config space for devices.
 *
 * fd is the file descriptor of the nexus.
 * input_args contains commandline options as specified by the user.
 */
static int
do_probe(nexus_t *nexus, struct pci_system *pci_sys)
{
    pcitool_reg_t prg;
    uint32_t bus;
    uint8_t dev;
    uint32_t last_bus = nexus->last_bus;
    uint8_t last_dev = PCI_REG_DEV_M >> PCI_REG_DEV_SHIFT;
    uint8_t first_bus = nexus->first_bus;
    uint8_t first_dev = 0;
    int rval = 0;

    prg.barnum = 0;	/* Config space. */

    /* Must read in 4-byte quantities. */
    prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_4 + NATIVE_ENDIAN;

    prg.data = 0;

    /*
     * Loop through all valid bus / dev / func combinations to check for
     * all devices, with the following exceptions:
     *
     * When nothing is found at function 0 of a bus / dev combination, skip
     * the other functions of that bus / dev combination.
     *
     * When a found device's function 0 is probed and it is determined that
     * it is not a multifunction device, skip probing of that device's
     * other functions.
     */
    for (bus = first_bus; ((bus <= last_bus) && (rval == 0)); bus++) {
	prg.bus_no = (uint8_t)bus;

	for (dev = first_dev; ((dev <= last_dev) && (rval == 0)); dev++) {
	    prg.dev_no = dev;
	    rval = probe_dev(nexus, &prg, pci_sys);
	}

	/*
	 * Ultra-45 southbridge workaround:
	 * ECANCELED tells to skip to the next bus.
	 */
	if (rval == ECANCELED) {
	    rval = 0;
	}
    }

    return (rval);
}

d724 5
d758 1
a758 2
    uint8_t  config[256];
    int err;
a763 1
    pciaddr_t bytes;
d766 1
d768 6
a773 1
    err = pci_device_solx_devfs_read( dev, config, 0, 256, & bytes );
d775 14
a788 9
    if ( bytes >= 64 ) {
	struct pci_device_private *priv =
	    (struct pci_device_private *) dev;

	dev->vendor_id = (uint16_t)config[0] + ((uint16_t)config[1] << 8);
	dev->device_id = (uint16_t)config[2] + ((uint16_t)config[3] << 8);
	dev->device_class = (uint32_t)config[9] +
	    ((uint32_t)config[10] << 8) +
	    ((uint16_t)config[11] << 16);
d790 11
a800 8
	/*
	 * device class code is already there.
	 * see probe_dev function.
	 */
	dev->revision = config[8];
	dev->subvendor_id = (uint16_t)config[44] + ((uint16_t)config[45] << 8);
	dev->subdevice_id = (uint16_t)config[46] + ((uint16_t)config[47] << 8);
	dev->irq = config[60];
a801 17
	priv->header_type = config[14];
	/*
	 * starting to find if it is MEM/MEM64/IO
	 * using libdevinfo
	 */
	if ((rnode = di_init("/", DINFOCPYALL)) == DI_NODE_NIL) {
	    err = errno;
	    (void) fprintf(stderr, "di_init failed: %s\n", strerror(errno));
	} else {
	    args.bus = dev->bus;
	    args.dev = dev->dev;
	    args.func = dev->func;
	    (void) di_walk_node(rnode, DI_WALK_CLDFIRST,
				(void *)&args, find_target_node);
	}
    }
    if (args.node != DI_NODE_NIL) {
d810 6
d908 64
d1007 7
a1013 1
    nexus_t *nexus = find_nexus_for_bus(dev->bus);
d1065 7
a1071 1
    nexus_t *nexus = find_nexus_for_bus(dev->bus);
d1085 1
d1089 1
d1093 1
d1097 1
a1106 1
    cfg_prg.data = *((uint64_t *)data);
d1126 18
a1143 8
/**
 * Map a memory region for a device using /dev/xsvc.
 *
 * \param dev   Device whose memory region is to be mapped.
 * \param map   Parameters of the mapping that is to be created.
 *
 * \return
 * Zero on success or an \c errno value on failure.
d1145 2
a1146 3
static int
pci_device_solx_devfs_map_range(struct pci_device *dev,
				struct pci_device_mapping *map)
a1147 2
    const int prot = ((map->flags & PCI_DEV_MAP_FLAG_WRITABLE) != 0)
			? (PROT_READ | PROT_WRITE) : PROT_READ;
d1149 7
d1157 5
a1161 10
    /*
     * Still used xsvc to do the user space mapping
     */
    if (xsvc_fd < 0) {
	if ((xsvc_fd = open("/dev/xsvc", O_RDWR)) < 0) {
	    err = errno;
	    (void) fprintf(stderr, "can not open /dev/xsvc: %s\n",
			   strerror(errno));
	    return err;
	}
d1164 2
a1165 2
    map->memory = mmap(NULL, map->size, prot, MAP_SHARED, xsvc_fd, map->base);
    if (map->memory == MAP_FAILED) {
d1167 3
d1171 16
a1186 2
	(void) fprintf(stderr, "map rom region =%llx failed: %s\n",
		       map->base, strerror(errno));
d1189 5
a1193 1
    return err;
@


1.4
log
@Update to libpciaccess 0.11, with VGA arbiter support code from kettenis@@.
@
text
@d3 1
a3 1
 * Copyright 2007, 2009 Sun Microsystems, Inc.
@


1.3
log
@Merge libpciaccess 0.10.5. No functionnal change on OpenBSD.
@
text
@d3 1
a25 28
 * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
 */
/*
d44 2
d63 3
a65 1
    int domain;
a69 1
static int num_domains = 0;
a105 3
#define	DEBUGON	0


d150 1
a150 1
find_nexus_for_domain( int domain )
d155 1
a155 1
	if (nexus->domain == domain) {
d188 1
d420 1
a420 1
	    pci_base->domain = nexus->domain;
d443 4
a446 3
#if DEBUGON
	    fprintf(stderr, "busno = %x, devno = %x, funcno = %x\n",
		    prg_p->bus_no, prg_p->dev_no, func);
d449 8
a456 1
	    pci_sys->num_devices++;
d485 48
d537 1
a537 1
	return DI_WALK_TERMINATE;
d539 2
d553 5
d560 1
a560 1
	nexus->domain = num_domains++;
d565 1
d594 1
a594 1
    uint32_t last_bus = PCI_REG_BUS_M >> PCI_REG_BUS_SHIFT;
d596 1
a596 1
    uint8_t first_bus = 0;
a633 3
    if (pci_sys->num_devices > MAX_DEVICES) {
	(void) fprintf(stderr, "pci devices reach maximum number\n");
    }
d644 1
a644 5
    i_devnode_t *devnode;
    void *prop = DI_PROP_NIL;
    int i;

    devnode = (i_devnode_t *)arg;
d650 2
d654 1
d671 1
a671 1
#if DEBUGON
d701 2
a702 2
    di_node_t rnode;
    i_devnode_t args;
d708 1
a710 1
    args.node = DI_NODE_NIL;
a744 1
	    di_fini(rnode);
d759 1
a759 1
	return (err);
d788 2
a789 2
     * solaris has its own BAR index. To be sure that
     * Xorg has the same BAR number as solaris. ????
a791 1
	int ent = i/CELL_NUMS_1275;
d794 9
d816 10
d834 3
d839 1
d841 3
a843 8
	/*
	 * We split the shift count 32 into two 16 to
	 * avoid the complaining of the compiler
	 */
	dev->regions[ent].base_addr = reg->pci_phys_low +
	    ((reg->pci_phys_mid << 16) << 16);
	dev->regions[ent].size = reg->pci_size_low +
	    ((reg->pci_size_hi << 16) << 16);
a844 1

d860 1
a860 1
    
d883 1
a883 1
    nexus_t *nexus = find_nexus_for_domain(dev->domain);
d904 2
a905 1
	    fprintf(stderr, "read bdf<%x,%x,%x,%llx> config space failure\n",
d935 1
a935 1
    nexus_t *nexus = find_nexus_for_domain(dev->domain);
@


1.2
log
@Merge libpciaccess 0.10.2, including kettenis@@ OpenBSD port.
@
text
@d2 1
a2 1
 * Copyright (c) 2007, Sun Microsystems, Inc.
d24 28
a51 1

a55 2
#define _GNU_SOURCE

a60 1
#include <sys/stat.h>
a62 1
#include <dirent.h>
a64 1
#include <assert.h>
a70 1
#define	PCI_NEXUS_1	"/devices/pci@@0,0:reg"
d72 2
a73 1
#define	CELL_NUMS_1275		(sizeof(pci_regspec_t)/sizeof(uint_t))
d75 2
a76 2
	uint8_t bytes[16 * sizeof (uint32_t)];
	uint32_t dwords[16];
d80 11
a90 5
	uint8_t bus;
	uint8_t dev;
	uint8_t func;
	di_node_t node;
}i_devnode_t;
d92 2
a93 1
static int root_fd = -1;
d95 1
d103 1
a103 1
#define	NATIVE_ENDIAN	PCITOOL_ACC_ATTR_ENDN_BIG
d105 1
a105 1
#define	NATIVE_ENDIAN	PCITOOL_ACC_ATTR_ENDN_LTL
d107 1
a107 1
#error "ISA is neither __sparc nor __x86"
d123 2
a124 2
#define	U45_SB_DEVID_VID	0xb9104952
#define	U45_SB_CLASS_RID	0x00000406
d126 2
a127 2
#define	U45_SB_DEVID_VID	0x524910b9
#define	U45_SB_CLASS_RID	0x06040000
d146 1
a146 1
    pciaddr_t * bytes_wrtten );
d148 2
a149 2
static int
probe_dev(int fd, pcitool_reg_t *prg_p, struct pci_system *pci_sys);
d151 1
a151 2
static int
do_probe(int fd, struct pci_system *pci_sys);
d153 1
a153 9
static void
pci_system_solx_devfs_destroy( void );

static int
get_config_header(int fd, uint8_t bus_no, uint8_t dev_no, uint8_t func_no,
    pci_conf_hdr_t *config_hdr_p);

int
pci_system_solx_devfs_create( void );
d155 1
d157 2
d160 1
d176 22
d199 1
a199 1
 * Rlease all the resources
d205 19
a223 14
	/*
	 * the memory allocated in create routines
	 * will be freed in pci_system_init
	 * It is more reasonable to free them here
	 */
	if (root_fd >= 0) {
		close(root_fd);
		root_fd = -1;
	}

	if (xsvc_fd >= 0) {
		close(xsvc_fd);
		xsvc_fd = -1;
	}
a224 1
}
d229 1
a229 1
int
d232 2
a233 1
	int err = 0;
d236 15
a250 10
	if (root_fd >= 0)
		return (err);
	/* If the directory "/sys/bus/pci/devices" exists,
	 * then the PCI subsystem can be accessed using
	 * this interface.
	 */
   	if ((root_fd = open(PCI_NEXUS_1, O_RDWR)) == -1) {
		(void) fprintf(stderr,
		    "Could not open nexus node %s: %s\n",
		    PCI_NEXUS_1, strerror(errno));
d252 24
a275 1
			err = errno;
d277 1
a277 26
			return (err);
	} else {
		/*
		 * Only allow MAX_DEVICES exists
		 * I will fix it later to get
		 * the total devices first
		 */
		if ((pci_sys = calloc(1, sizeof (struct pci_system))) != NULL) {
			pci_sys->methods = &solx_devfs_methods;
			if ((pci_sys->devices =
			    calloc(MAX_DEVICES,
			    sizeof (struct pci_device_private))) != NULL) {
				(void) do_probe(root_fd, pci_sys);
			}
			else {
				err = errno;
				free(pci_sys);
				pci_sys = NULL;
			}
		} else {
			err = errno;
		}
		
	}
	
	return (err);
d286 1
a286 1
    pci_conf_hdr_t *config_hdr_p)
d288 18
a305 21
	pcitool_reg_t cfg_prg;
	int i;
	int rval = 0;

	/* Prepare a local pcitool_reg_t so as to not disturb the caller's. */
	cfg_prg.offset = 0;
	cfg_prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_4 + NATIVE_ENDIAN;
	cfg_prg.bus_no = bus_no;
	cfg_prg.dev_no = dev_no;
	cfg_prg.func_no = func_no;
	cfg_prg.barnum = 0;
	cfg_prg.user_version = PCITOOL_USER_VERSION;

	/* Get dwords 1-15 of config space. They must be read as uint32_t. */
	for (i = 1; i < (sizeof (pci_conf_hdr_t) / sizeof (uint32_t)); i++) {
		cfg_prg.offset += sizeof (uint32_t);
		if ((rval =
		    ioctl(fd, PCITOOL_DEVICE_GET_REG, &cfg_prg)) != 0) {
			break;
		}
		config_hdr_p->dwords[i] = (uint32_t)cfg_prg.data;
d307 2
d310 1
a310 1
	return (rval);
d318 1
a318 1
probe_dev(int fd, pcitool_reg_t *prg_p, struct pci_system *pci_sys)
d320 23
a342 7
	pci_conf_hdr_t	config_hdr;
	boolean_t	multi_function_device;
	int8_t		func;
	int8_t		first_func = 0;
	int8_t		last_func = PCI_REG_FUNC_M >> PCI_REG_FUNC_SHIFT;
	int		rval = 0;

d345 7
a351 3
	 * Loop through at least func=first_func.  Continue looping through
	 * functions if there are no errors and the device is a multi-function
	 * device.
d353 4
a356 4
	 * (Note, if first_func == 0, header will show whether multifunction
	 * device and set multi_function_device.  If first_func != 0, then we
	 * will force the loop as the user wants a specific function to be
	 * checked.
d358 111
a468 128
	for (func = first_func, multi_function_device = B_FALSE;
	    ((func <= last_func) &&
		((func == first_func) || (multi_function_device)));
	    func++) {
		prg_p->func_no = func;

		/*
		 * Four things can happen here:
		 *
		 * 1) ioctl comes back as EFAULT and prg_p->status is
		 *    PCITOOL_INVALID_ADDRESS.  There is no device at this
		 *    location.
		 *
		 * 2) ioctl comes back successful and the data comes back as
		 *    zero.  Config space is mapped but no device responded.
		 *
		 * 3) ioctl comes back successful and the data comes back as
		 *    non-zero.  We've found a device.
		 *
		 * 4) Some other error occurs in an ioctl.
		 */

		prg_p->status = PCITOOL_SUCCESS;
		prg_p->offset = 0;
		prg_p->data = 0;
		prg_p->user_version = PCITOOL_USER_VERSION;
		if (((rval = ioctl(fd, PCITOOL_DEVICE_GET_REG, prg_p)) != 0) ||
		    (prg_p->data == 0xffffffff)) {

			/*
			 * Accept errno == EINVAL along with status of
			 * PCITOOL_OUT_OF_RANGE because some systems
			 * don't implement the full range of config space.
			 * Leave the loop quietly in this case.
			 */
			if ((errno == EINVAL) ||
			    (prg_p->status == PCITOOL_OUT_OF_RANGE)) {
				break;
			}

			/*
			 * Exit silently with ENXIO as this means that there are
			 * no devices under the pci root nexus.
			 */
			else if ((errno == ENXIO) &&
			    (prg_p->status == PCITOOL_IO_ERROR)) {
				break;
			}

			/*
			 * Expect errno == EFAULT along with status of
			 * PCITOOL_INVALID_ADDRESS because there won't be
			 * devices at each stop.  Quit on any other error.
			 */
			else if (((errno != EFAULT) ||
			    (prg_p->status != PCITOOL_INVALID_ADDRESS)) &&
			    (prg_p->data != 0xffffffff)) {

				break;

			/*
			 * If no function at this location,
			 * just advance to the next function.
			 */
			} else {
				rval = 0;
			}

		/*
		 * Data came back as 0.
		 * Treat as unresponsive device amd check next device.
		 */
		} else if (prg_p->data == 0) {
			rval = 0;
			break;	/* Func loop. */

		/* Found something. */
		} else {
			config_hdr.dwords[0] = (uint32_t)prg_p->data;

			/* Get the rest of the PCI header. */
			if ((rval = get_config_header(fd, prg_p->bus_no,
			    prg_p->dev_no, prg_p->func_no, &config_hdr)) !=
			    0) {
				break;
			}

			/*
			 * Special case for the type of Southbridge found on
			 * Ultra-45 and other sun4u fire workstations.
			 */
			if ((config_hdr.dwords[0] == U45_SB_DEVID_VID) &&
			    (config_hdr.dwords[2] == U45_SB_CLASS_RID)) {
				rval = ECANCELED;
				break;
			}

			/*
			 * Found one device with bus numer, device number and
			 * function number.
			 */

			/*
			 * Domain is peer bus??
			 */
			pci_sys->devices[pci_sys->num_devices].base.domain = 0;
			pci_sys->devices[pci_sys->num_devices].base.bus =
			    prg_p->bus_no;
			pci_sys->devices[pci_sys->num_devices].base.dev =
			    prg_p->dev_no;
			pci_sys->devices[pci_sys->num_devices].base.func = func;
			/*
			 * for the format of device_class, see struct pci_device;
			 */
			pci_sys->devices[pci_sys->num_devices].base.device_class =
			    config_hdr.dwords[2]>>8;
			pci_sys->devices[pci_sys->num_devices].base.revision =
			    (uint8_t)(config_hdr.dwords[2] & 0xff);
			pci_sys->devices[pci_sys->num_devices].base.vendor_id =
			    (uint16_t)(config_hdr.dwords[0] & 0xffff);		
			pci_sys->devices[pci_sys->num_devices].base.device_id =
			    (uint16_t)((config_hdr.dwords[0]>>16) & 0xffff);		
			pci_sys->devices[pci_sys->num_devices].base.subvendor_id =
			    (uint16_t)(config_hdr.dwords[11] & 0xffff);		
			pci_sys->devices[pci_sys->num_devices].base.subdevice_id =
			    (uint16_t)((config_hdr.dwords[11]>>16) & 0xffff);		
			pci_sys->devices[pci_sys->num_devices].header_type =
			    (uint8_t)(((config_hdr.dwords[3])&0xff0000)>>16);
d470 2
a471 2
			fprintf(stderr, "busno = %x, devno = %x, funcno = %x\n",
			    prg_p->bus_no, prg_p->dev_no, func);
d474 46
a519 1
			pci_sys->num_devices++;
d521 11
a531 11
			/*
			 * Accomodate devices which state their
			 * multi-functionality only in their function 0 config
			 * space.  Note multi-functionality throughout probing
			 * of all of this device's functions.
			 */
			if (config_hdr.bytes[PCI_CONF_HEADER] &
			    PCI_HEADER_MULTI) {
				multi_function_device = B_TRUE;
			}
		}
d533 5
d539 1
a539 1
	return (rval);
d542 1
d551 1
a551 1
do_probe(int fd, struct pci_system *pci_sys)
d553 34
a586 15
	pcitool_reg_t prg;
	uint32_t bus;
	uint8_t dev;
	uint32_t last_bus = PCI_REG_BUS_M >> PCI_REG_BUS_SHIFT;
	uint8_t last_dev = PCI_REG_DEV_M >> PCI_REG_DEV_SHIFT;
	uint8_t first_bus = 0;
	uint8_t first_dev = 0;
	int rval = 0;

	prg.barnum = 0;	/* Config space. */

	/* Must read in 4-byte quantities. */
	prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_4 + NATIVE_ENDIAN;

	prg.data = 0;
d589 2
a590 9
	 * Loop through all valid bus / dev / func combinations to check for
	 * all devices, with the following exceptions:
	 *
	 * When nothing is found at function 0 of a bus / dev combination, skip
	 * the other functions of that bus / dev combination.
	 *
	 * When a found device's function 0 is probed and it is determined that
	 * it is not a multifunction device, skip probing of that device's
	 * other functions.
d592 2
a593 18
	for (bus = first_bus; ((bus <= last_bus) && (rval == 0)); bus++) {
		prg.bus_no = (uint8_t)bus;
		for (dev = first_dev;
		    ((dev <= last_dev) && (rval == 0)); dev++) {
			prg.dev_no = dev;
			rval = probe_dev(fd, &prg, pci_sys);
		}

		/*
		 * Ultra-45 southbridge workaround:
		 * ECANCELED tells to skip to the next bus.
		 */
		if (rval == ECANCELED) {
			rval = 0;
		}
	}
	if (pci_sys->num_devices > MAX_DEVICES) {
		(void) fprintf(stderr, "pci devices reach maximu number\n");
d595 4
d600 1
a600 1
	return (rval);
d606 27
a632 6
	int *regbuf = NULL;
	int len = 0;
	uint32_t busno, funcno, devno;
	i_devnode_t *devnode;
	void *prop = DI_PROP_NIL;
	int i;
d634 1
a634 1
	devnode = (i_devnode_t *)arg;
d636 1
a636 23
	/*
	 * Test the property funtions, only for testing
	 */
	/*
	(void) fprintf(stderr, "start of node 0x%x\n", node->nodeid);
	while ((prop = di_prop_hw_next(node, prop)) != DI_PROP_NIL) {
		(void) fprintf(stderr, "name=%s: ", di_prop_name(prop));
		len = 0;
		if (!strcmp(di_prop_name(prop), "reg")) {
			len = di_prop_ints(prop, &regbuf);
		}
		for (i = 0; i < len; i++) {
			fprintf(stderr, "0x%0x.", regbuf[i]);
		}
		fprintf(stderr, "\n");
	}
	(void) fprintf(stderr, "end of node 0x%x\n", node->nodeid);
	*/
	
	len = di_prop_lookup_ints(DDI_DEV_T_ANY, node, "reg",
	    &regbuf);

	if (len <= 0) {
d638 2
a639 2
		fprintf(stderr, "error = %x\n", errno);
		fprintf(stderr, "can not find assigned-address\n");
d641 14
a654 13
		return (DI_WALK_CONTINUE);
	}
	busno = PCI_REG_BUS_G(regbuf[0]);
	devno = PCI_REG_DEV_G(regbuf[0]);
	funcno = PCI_REG_FUNC_G(regbuf[0]);

	if ((busno == devnode->bus) &&
	    (devno == devnode->dev) &&
	    (funcno == devnode->func)) {
		devnode->node = node;
		
		return (DI_WALK_TERMINATE);
	}
d656 1
a656 1
	return (DI_WALK_CONTINUE);
d665 31
a695 60
	uint8_t  config[256];
	int err;
	di_node_t rnode;
	i_devnode_t args;
	int *regbuf;
	pci_regspec_t *reg;
	int i;
	pciaddr_t bytes;
	int len = 0;

	err = pci_device_solx_devfs_read( dev, config, 0, 256, & bytes );
	args.node = DI_NODE_NIL;
	if ( bytes >= 64 ) {
		struct pci_device_private *priv =
		     (struct pci_device_private *) dev;

		dev->vendor_id =
		    (uint16_t)config[0] + ((uint16_t)config[1] << 8);
		dev->device_id =
		    (uint16_t)config[2] + ((uint16_t)config[3] << 8);
		dev->device_class = (uint32_t)config[9] +
		    ((uint32_t)config[10] << 8) +
		    ((uint16_t)config[11] << 16);
		/*
		 * device class code is already there.
		 * see probe_dev function.
		 */
		dev->revision = config[8];
		dev->subvendor_id =
		    (uint16_t)config[44] + ((uint16_t)config[45] << 8);
		dev->subdevice_id =
		    (uint16_t)config[46] + ((uint16_t)config[47] << 8);
		dev->irq = config[60];

		priv->header_type = config[14];
		/*
		 * starting to find if it is MEM/MEM64/IO
		 * using libdevinfo
		 */
		if ((rnode = di_init("/", DINFOCPYALL)) == DI_NODE_NIL) {
			(void) fprintf(stderr, "di_init failed: %s\n",
			    strerror(errno));
			err = errno;
		} else {
			args.bus = dev->bus;
			args.dev = dev->dev;
			args.func = dev->func;
			(void) di_walk_node(rnode, DI_WALK_CLDFIRST,
			    (void *)&args, find_target_node);
			di_fini(rnode);
		}
	}
	if (args.node != DI_NODE_NIL) {
		/*
		 * It will success for sure, because it was
		 * successfully called in find_target_node
		 */
		len = di_prop_lookup_ints(DDI_DEV_T_ANY, args.node,
		    "assigned-addresses",
		    &regbuf);
d697 15
d713 9
d723 4
a726 2
	if (len <= 0)
		return (err);
d729 18
d748 2
a749 7
	 * how to find the size of rom???
	 * if the device has expansion rom,
	 * it must be listed in the last
	 * cells because solaris find probe
	 * the base address from offset 0x10
	 * to 0x30h. So only check the last
	 * item.
d751 11
a761 16
	reg = (pci_regspec_t *)&regbuf[len - CELL_NUMS_1275];
	if (PCI_REG_REG_G(reg->pci_phys_hi) ==
	    PCI_CONF_ROM) {
		/*
		 * rom can only be 32 bits
		 */
		dev->rom_size = reg->pci_size_low;
		len = len - CELL_NUMS_1275;
	}
	else {
		/*
		 * size default to 64K and base address
		 * default to 0xC0000
		 */
		dev->rom_size = 0x10000;
	}
d764 3
a766 2
	 * solaris has its own BAR index. To be sure that
	 * Xorg has the same BAR number as solaris. ????
d768 2
a769 2
	for (i = 0; i < len; i = i + CELL_NUMS_1275) {
		int ent = i/CELL_NUMS_1275;
d771 3
a773 1
		reg = (pci_regspec_t *)&regbuf[i];
d775 9
a783 31
		/*
		 * non relocatable resource is excluded
		 * such like 0xa0000, 0x3b0. If it is met,
		 * the loop is broken;
		 */
		if (!PCI_REG_REG_G(reg->pci_phys_hi))
			break; 		


		if (reg->pci_phys_hi & PCI_PREFETCH_B) {
			dev->regions[ent].is_prefetchable = 1;
		}

		switch (reg->pci_phys_hi & PCI_REG_ADDR_M) {
		case PCI_ADDR_IO:
			dev->regions[ent].is_IO = 1;
			break;
		case PCI_ADDR_MEM32:
			break;
		case PCI_ADDR_MEM64:
			dev->regions[ent].is_64 = 1;
			break;
		}
		/*
		 * We split the shift count 32 into two 16 to
		 * avoid the complaining of the compiler
		 */
		dev->regions[ent].base_addr = reg->pci_phys_low +
		    ((reg->pci_phys_mid << 16) << 16);
		dev->regions[ent].size = reg->pci_size_low +
		    ((reg->pci_size_hi << 16) << 16);
d785 10
a794 1
		 
d800 1
a800 1
 * Solaris version: read the ROM data
d805 10
a814 25
	void *prom = MAP_FAILED;

	if (xsvc_fd < 0) {
		if ((xsvc_fd = open("/dev/xsvc", O_RDWR)) < 0) {
		    (void) fprintf(stderr, "can not open xsvc driver\n");
		
			return (-1);
		}
	}

	prom = mmap(NULL, dev->rom_size,
	    PROT_READ, MAP_SHARED,
	    xsvc_fd, 0xC0000);

	if (prom == MAP_FAILED) {
		(void) fprintf(stderr, "map rom base =0xC0000 failed");
		return (-1);
	}
	(void) bcopy(prom, buffer, dev->rom_size);
	
	
	/*
	 * Still used xsvc to do the user space mapping
	 */
	return (0);
d816 5
d831 31
a861 31
	pcitool_reg_t cfg_prg;
	int err = 0;
	int i = 0;

	cfg_prg.offset = offset;
	cfg_prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_1 + NATIVE_ENDIAN;
	cfg_prg.bus_no = dev->bus;
	cfg_prg.dev_no = dev->dev;
	cfg_prg.func_no = dev->func;
	cfg_prg.barnum = 0;
	cfg_prg.user_version = PCITOOL_USER_VERSION;
	*bytes_read = 0;

	for (i = 0; i < size; i = i + PCITOOL_ACC_ATTR_SIZE(PCITOOL_ACC_ATTR_SIZE_1)) {

		cfg_prg.offset = offset + i;
		if ((err = ioctl(root_fd, PCITOOL_DEVICE_GET_REG,
		    &cfg_prg)) != 0) {
			fprintf(stderr, "read bdf<%x,%x,%x,%llx> config space failure\n",
			    cfg_prg.bus_no,
			    cfg_prg.dev_no,
			    cfg_prg.func_no,
			    cfg_prg.offset);
			fprintf(stderr, "Failure cause = %x\n", err);
			break;
		}

		((uint8_t *)data)[i] = (uint8_t)cfg_prg.data;
		/*
		 * DWORDS Offset or bytes Offset ??
		 */
a862 1
	*bytes_read = i;
d864 8
a871 1
	return (err);
d882 45
a926 3
	pcitool_reg_t cfg_prg;
	int err = 0;
	int cmd;
d928 4
d933 1
a933 43
	if ( bytes_written != NULL ) {
		*bytes_written = 0;
	}

	cfg_prg.offset = offset;
	switch (size) {
		case 1:
		cfg_prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_1 + NATIVE_ENDIAN;
		break;
		case 2:
		cfg_prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_2 + NATIVE_ENDIAN;
		break;
		case 4:
		cfg_prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_4 + NATIVE_ENDIAN;
		break;
		case 8:
		cfg_prg.acc_attr = PCITOOL_ACC_ATTR_SIZE_8 + NATIVE_ENDIAN;
		break;
		default:
			assert(0);

	}
	cfg_prg.bus_no = dev->bus;
	cfg_prg.dev_no = dev->dev;
	cfg_prg.func_no = dev->func;
	cfg_prg.barnum = 0;
	cfg_prg.user_version = PCITOOL_USER_VERSION;
	cfg_prg.data = *((uint64_t *)data);
	/*
	 * Check if this device is bridge device.
	 * If it is, it is also a nexus node???
	 * It seems that there is no explicit
	 * PCI nexus device for X86, so not applicable
	 * from pcitool_bus_reg_ops in pci_tools.c
	 */
	cmd = PCITOOL_DEVICE_SET_REG;

	if ((err = ioctl(root_fd, cmd, &cfg_prg)) != 0) {
		return (err);
	}
	*bytes_written = size;

	return (err);
d939 1
a939 1
 * 
d942 1
a942 1
 * 
d950 23
a972 20
	const int prot = ((map->flags & PCI_DEV_MAP_FLAG_WRITABLE) != 0) 
		? (PROT_READ | PROT_WRITE) : PROT_READ;
	int err = 0;


	if (xsvc_fd < 0) {
		if ((xsvc_fd = open("/dev/xsvc", O_RDWR)) < 0) {
			(void) fprintf(stderr, "can not open xsvc driver\n");
			return errno;
		}
	}

	map->memory = mmap(NULL, map->size, prot, MAP_SHARED, xsvc_fd,
			   map->base);
	if (map->memory == MAP_FAILED) {
		err = errno;

		(void) fprintf(stderr, "map rom region =%llx failed",
			       map->base);
	}
d974 1
a974 1
	return err;
@


1.1
log
@Initial revision
@
text
@d103 2
a104 1

a110 6
static int pci_device_solx_devfs_map_region( struct pci_device * dev,
    unsigned region, int write_enable );

static int pci_device_solx_devfs_unmap_region( struct pci_device * dev,
    unsigned region );

d142 2
a143 2
    .map = pci_device_solx_devfs_map_region,
    .unmap = pci_device_solx_devfs_unmap_region,
d597 1
a597 1
			(void) fprintf(stderr, "di_init failed: $s\n",
d756 1
a756 1
			fprintf(stderr, "read bdf<%x,%x,%x,%x> config space failure\n",
d834 8
a841 2
/*
 * Solaris Version
d844 2
a845 2
pci_device_solx_devfs_map_region( struct pci_device * dev, unsigned region,
    int write_enable )
d847 4
d854 2
a855 3
		    (void) fprintf(stderr, "can not open xsvc driver\n");
		
			return (-1);
d859 4
a862 3
	dev->regions[region].memory = mmap(NULL, dev->regions[region].size,
	    (write_enable) ? (PROT_READ | PROT_WRITE) : PROT_READ, MAP_SHARED,
	    xsvc_fd, dev->regions[region].base_addr);
d864 2
a865 6
	if (dev->regions[region].memory == MAP_FAILED) {
		dev->regions[region].memory = 0;
	
		(void) fprintf(stderr, "map rom region =%x failed",
		    dev->regions[region].base_addr);
		return (-1);
a866 7
	
	/*
	 * Still used xsvc to do the user space mapping
	 */
	return (0);
}

d868 1
a868 16
/*
 * Solaris version
 */
static int
pci_device_solx_devfs_unmap_region( struct pci_device * dev, unsigned region )
{
    int err = 0;

    if ( munmap( dev->regions[ region ].memory, dev->regions[ region ].size )
	 == -1 ) {
	err = errno;
    }

    dev->regions[ region ].memory = NULL;

    return (err);
@


1.1.1.1
log
@Import libpciaccess from git as of today. 
Changes: solaris support added.
@
text
@@
