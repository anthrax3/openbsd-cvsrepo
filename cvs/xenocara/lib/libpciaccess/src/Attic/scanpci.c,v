head	1.5;
access;
symbols
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	libpciaccess-070616:1.1.1.1
	libpciaccess-070327:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2011.11.06.21.35.46;	author matthieu;	state dead;
branches;
next	1.4;

1.4
date	2010.07.10.18.56.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.04.14.20.14.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.24.14.14.00;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.05.20.08.58;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.06.05.20.08.58;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to libpciaccess 0.12.1. Ok kettenis@@, shadchin@@
@
text
@/*
 * (C) Copyright IBM Corporation 2006
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * IBM AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdlib.h>
#include <stdio.h>
#include <err.h>
#include <unistd.h>

#include "pciaccess.h"


static void
print_pci_bridge( const struct pci_bridge_info * info )
{
    printf( "  Bus: primary=%02x, secondary=%02x, subordinate=%02x, "
	    "sec-latency=%u\n",
	    info->primary_bus,
	    info->secondary_bus,
	    info->subordinate_bus,
	    info->secondary_latency_timer );
    printf( "  I/O behind bridge: %08x-%08x\n",
	    info->io_base,
	    info->io_limit );
    printf( "  Memory behind bridge: %08x-%08x\n",
	    info->mem_base,
	    info->mem_limit );
    printf( "  Prefetchable memory behind bridge: %08llx-%08llx\n",
	    info->prefetch_mem_base,
	    info->prefetch_mem_limit );
}

static void
print_pci_device( struct pci_device * dev, int verbose )
{
    const char * dev_name;
    const char * vend_name;

    vend_name = pci_device_get_vendor_name( dev );
    dev_name = pci_device_get_device_name( dev );
    if ( dev_name == NULL ) {
	dev_name = "Device unknown";
    }

    printf("\npci ");
    if (dev->domain != 0)
	printf("domain 0x%04x ", dev->domain);
    printf("bus 0x%04x cardnum 0x%02x function 0x%02x:"
	   " vendor 0x%04x device 0x%04x\n",
	   dev->bus, 
	   dev->dev,
	   dev->func,
	   dev->vendor_id,
	   dev->device_id );
    if ( vend_name != NULL ) {
	printf( " %s %s\n", vend_name, dev_name );
    }
    else {
	printf( " %s\n", dev_name );
    }
    
    if ( verbose ) {
	unsigned   i;
	uint16_t  command, status;
	uint8_t   bist;
	uint8_t   header_type;
	uint8_t   latency_timer;
	uint8_t   cache_line_size;
	uint8_t   max_latency;
	uint8_t   min_grant;
	uint8_t   int_pin;


	vend_name = pci_device_get_subvendor_name( dev );
	dev_name = pci_device_get_subdevice_name( dev );
	if ( dev_name == NULL ) {
	    dev_name = "Card unknown";
	}

	printf( " CardVendor 0x%04x card 0x%04x (",
		dev->subvendor_id,
		dev->subdevice_id );
	if ( vend_name != NULL ) {
	    printf( "%s, %s)\n", vend_name, dev_name );
	}
	else {
	    printf( "%s)\n", dev_name );
	}

	pci_device_cfg_read_u16( dev, & command, 4 );
	pci_device_cfg_read_u16( dev, & status,  6 );
	printf( "  STATUS    0x%04x  COMMAND 0x%04x\n", 
		status,
		command );
	printf( "  CLASS     0x%02x 0x%02x 0x%02x  REVISION 0x%02x\n",
		(dev->device_class >> 16) & 0x0ff,
		(dev->device_class >>  8) & 0x0ff,
		(dev->device_class >>  0) & 0x0ff,
		dev->revision );

	pci_device_cfg_read_u8( dev, & cache_line_size, 12 );
	pci_device_cfg_read_u8( dev, & latency_timer, 13 );
	pci_device_cfg_read_u8( dev, & header_type, 14 );
	pci_device_cfg_read_u8( dev, & bist, 15 );

	printf( "  BIST      0x%02x  HEADER 0x%02x  LATENCY 0x%02x  CACHE 0x%02x\n",
		bist,
		header_type,
		latency_timer,
		cache_line_size );
	
	pci_device_probe( dev );
	for ( i = 0 ; i < 6 ; i++ ) {
	    if ( dev->regions[i].base_addr != 0 ) {
		printf( "  BASE%u     0x%08x SIZE %d  %s",
			i,
			(intptr_t) dev->regions[i].base_addr,
			(size_t) dev->regions[i].size,
			(dev->regions[i].is_IO) ? "I/O" : "MEM" );

		if ( ! dev->regions[i].is_IO ) {
		    if ( dev->regions[i].is_prefetchable ) {
			printf( " PREFETCHABLE" );
		    }
		}
		
		printf( "\n" );
	    }
	}

	if ( dev->rom_size ) {
	    printf( "  BASEROM   0x%08x  addr 0x%08x\n",
		    0, 0 );
	}

	pci_device_cfg_read_u8( dev, & int_pin, 61 );
	pci_device_cfg_read_u8( dev, & min_grant, 62 );
	pci_device_cfg_read_u8( dev, & max_latency, 63 );

	printf( "  MAX_LAT   0x%02x  MIN_GNT 0x%02x  INT_PIN 0x%02x  INT_LINE 0x%02x\n",
		max_latency,
		min_grant,
		int_pin,
		dev->irq );

	if ( (dev->device_class >> 16) == 0x06 ) {
	    const void * info;

	    if ( (info = pci_device_get_bridge_info(dev)) != NULL ) {
		print_pci_bridge( (const struct pci_bridge_info *) info );
	    }
	    else if ( (info = pci_device_get_pcmcia_bridge_info(dev)) != NULL ) {
		/* Nothing yet. */
	    }
	}
    }
}


int main( int argc, char ** argv )
{
    struct pci_device_iterator * iter;
    struct pci_device * dev;
    int ret;
    int verbose = 0;
    int c;
    int errors = 0;

    while ((c = getopt(argc, argv, "v")) != -1) {
	switch (c) {
	case 'v':
	    verbose = 1;
	    break;
	case '?':
	    errors++;
	}
    }
    if (errors != 0) {
	fprintf(stderr, "usage: %s [-v]\n", argv[0]);
	exit(2);
    }

    ret = pci_system_init();
    if (ret != 0)
	err(1, "Couldn't initialize PCI system");

    iter = pci_slot_match_iterator_create( NULL );

    while ( (dev = pci_device_next( iter )) != NULL ) {
	print_pci_device( dev, verbose );
    }

    pci_system_cleanup();
    return 0;
}
@


1.4
log
@Update to libpciaccess 0.11, with VGA arbiter support code from kettenis@@.
@
text
@@


1.3
log
@Merge libpciaccess 0.10.5. No functionnal change on OpenBSD.
@
text
@d28 1
@


1.2
log
@Merge libpciaccess 0.10.2, including kettenis@@ OpenBSD port.
@
text
@d184 17
d209 1
a209 1
	print_pci_device( dev, 1 );
@


1.1
log
@Initial revision
@
text
@d27 1
d64 4
a67 1
    printf("\npci bus 0x%04x cardnum 0x%02x function 0x%02x:"
d134 1
a134 1
		printf( "  BASE%u     0x%08x  addr 0x%08x  %s",
a135 1
			0,
d137 1
d183 1
d185 3
a187 1
    pci_system_init();
@


1.1.1.1
log
@import libpciaccess 070327
@
text
@@
