head	1.31;
access;
symbols
	OPENBSD_6_1:1.30.0.2
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.24.0.2
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.21.0.2
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.2
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2017.06.23.16.15.20;	author dcoppa;	state Exp;
branches;
next	1.30;
commitid	nHj0O50aY5QcUcQ4;

1.30
date	2017.01.13.11.20.00;	author dcoppa;	state Exp;
branches;
next	1.29;
commitid	ESXG9TuEmwmBXggf;

1.29
date	2016.10.28.21.41.15;	author dcoppa;	state Exp;
branches;
next	1.28;
commitid	T2hf37tVZU8TmjB1;

1.28
date	2016.08.09.07.16.10;	author dcoppa;	state Exp;
branches;
next	1.27;
commitid	C8TgUUJolulx9B5d;

1.27
date	2016.05.29.11.57.14;	author dcoppa;	state Exp;
branches;
next	1.26;
commitid	1dOLexdOAzW2mQjp;

1.26
date	2015.12.07.09.34.04;	author dcoppa;	state Exp;
branches;
next	1.25;
commitid	wZOPiDmcwgRFTDVL;

1.25
date	2015.10.19.07.51.38;	author dcoppa;	state Exp;
branches;
next	1.24;
commitid	d2XmJCtYff11VIDu;

1.24
date	2015.06.28.08.27.50;	author dcoppa;	state Exp;
branches;
next	1.23;
commitid	qXwIGV2h9uFjxAmt;

1.23
date	2015.01.10.17.17.24;	author dcoppa;	state Exp;
branches;
next	1.22;
commitid	2tSYQMWVSV3t7clo;

1.22
date	2014.12.26.17.52.36;	author dcoppa;	state Exp;
branches;
next	1.21;
commitid	gwhRExMduYqoPQHI;

1.21
date	2014.03.14.08.18.02;	author dcoppa;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.12.15.08.28;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2013.10.10.19.49.59;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.07.17.21.11;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.04.16.51.59;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2012.07.07.16.45.04;	author dcoppa;	state Exp;
branches;
next	1.15;

1.15
date	2012.04.14.09.45.47;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.19.11.32.46;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2011.10.30.10.14.51;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.18.20.29.59;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.19.16.08.14;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.11.06.16.45.49;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.23.19.30.17;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.01.19.14.25;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.17.14.06.43;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.25.20.49.55;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.26.07.31.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.10.20.28.35;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.21.05.09.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.45.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.45.05;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.32.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.31
log
@
Update to freetype-2.8

No fallout in a bulk build on i386 (sthen@@)

OK matthieu@@, sthen@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ttinterp.c                                                             */
/*                                                                         */
/*    TrueType bytecode interpreter (body).                                */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


/* Greg Hitchcock from Microsoft has helped a lot in resolving unclear */
/* issues; many thanks!                                                */


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_CALC_H
#include FT_TRIGONOMETRY_H
#include FT_SYSTEM_H
#include FT_TRUETYPE_DRIVER_H
#include FT_MULTIPLE_MASTERS_H

#include "ttinterp.h"
#include "tterrors.h"
#include "ttsubpix.h"
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#include "ttgxvar.h"
#endif


#ifdef TT_USE_BYTECODE_INTERPRETER


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_ttinterp


#define NO_SUBPIXEL_HINTING                                                  \
          ( ((TT_Driver)FT_FACE_DRIVER( exc->face ))->interpreter_version == \
            TT_INTERPRETER_VERSION_35 )

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
#define SUBPIXEL_HINTING_INFINALITY                                          \
          ( ((TT_Driver)FT_FACE_DRIVER( exc->face ))->interpreter_version == \
            TT_INTERPRETER_VERSION_38 )
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
#define SUBPIXEL_HINTING_MINIMAL                                             \
          ( ((TT_Driver)FT_FACE_DRIVER( exc->face ))->interpreter_version == \
            TT_INTERPRETER_VERSION_40 )
#endif

#define PROJECT( v1, v2 )                                                \
          exc->func_project( exc, (v1)->x - (v2)->x, (v1)->y - (v2)->y )

#define DUALPROJ( v1, v2 )                                                \
          exc->func_dualproj( exc, (v1)->x - (v2)->x, (v1)->y - (v2)->y )

#define FAST_PROJECT( v )                          \
          exc->func_project( exc, (v)->x, (v)->y )

#define FAST_DUALPROJ( v )                          \
          exc->func_dualproj( exc, (v)->x, (v)->y )


  /*************************************************************************/
  /*                                                                       */
  /* Two simple bounds-checking macros.                                    */
  /*                                                                       */
#define BOUNDS( x, n )   ( (FT_UInt)(x)  >= (FT_UInt)(n)  )
#define BOUNDSL( x, n )  ( (FT_ULong)(x) >= (FT_ULong)(n) )


#undef  SUCCESS
#define SUCCESS  0

#undef  FAILURE
#define FAILURE  1


  /*************************************************************************/
  /*                                                                       */
  /*                        CODERANGE FUNCTIONS                            */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Goto_CodeRange                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Switches to a new code range (updates the code related elements in */
  /*    `exec', and `IP').                                                 */
  /*                                                                       */
  /* <Input>                                                               */
  /*    range :: The new execution code range.                             */
  /*                                                                       */
  /*    IP    :: The new IP in the new code range.                         */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    exec  :: The target execution context.                             */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  TT_Goto_CodeRange( TT_ExecContext  exec,
                     FT_Int          range,
                     FT_Long         IP )
  {
    TT_CodeRange*  coderange;


    FT_ASSERT( range >= 1 && range <= 3 );

    coderange = &exec->codeRangeTable[range - 1];

    FT_ASSERT( coderange->base );

    /* NOTE: Because the last instruction of a program may be a CALL */
    /*       which will return to the first byte *after* the code    */
    /*       range, we test for IP <= Size instead of IP < Size.     */
    /*                                                               */
    FT_ASSERT( IP <= coderange->size );

    exec->code     = coderange->base;
    exec->codeSize = coderange->size;
    exec->IP       = IP;
    exec->curRange = range;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Set_CodeRange                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Sets a code range.                                                 */
  /*                                                                       */
  /* <Input>                                                               */
  /*    range  :: The code range index.                                    */
  /*                                                                       */
  /*    base   :: The new code base.                                       */
  /*                                                                       */
  /*    length :: The range size in bytes.                                 */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    exec   :: The target execution context.                            */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  TT_Set_CodeRange( TT_ExecContext  exec,
                    FT_Int          range,
                    void*           base,
                    FT_Long         length )
  {
    FT_ASSERT( range >= 1 && range <= 3 );

    exec->codeRangeTable[range - 1].base = (FT_Byte*)base;
    exec->codeRangeTable[range - 1].size = length;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Clear_CodeRange                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Clears a code range.                                               */
  /*                                                                       */
  /* <Input>                                                               */
  /*    range :: The code range index.                                     */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    exec  :: The target execution context.                             */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  TT_Clear_CodeRange( TT_ExecContext  exec,
                      FT_Int          range )
  {
    FT_ASSERT( range >= 1 && range <= 3 );

    exec->codeRangeTable[range - 1].base = NULL;
    exec->codeRangeTable[range - 1].size = 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /*                   EXECUTION CONTEXT ROUTINES                          */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Done_Context                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Destroys a given context.                                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    exec   :: A handle to the target execution context.                */
  /*                                                                       */
  /*    memory :: A handle to the parent memory object.                    */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Only the glyph loader and debugger should call this function.      */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  TT_Done_Context( TT_ExecContext  exec )
  {
    FT_Memory  memory = exec->memory;


    /* points zone */
    exec->maxPoints   = 0;
    exec->maxContours = 0;

    /* free stack */
    FT_FREE( exec->stack );
    exec->stackSize = 0;

    /* free call stack */
    FT_FREE( exec->callStack );
    exec->callSize = 0;
    exec->callTop  = 0;

    /* free glyph code range */
    FT_FREE( exec->glyphIns );
    exec->glyphSize = 0;

    exec->size = NULL;
    exec->face = NULL;

    FT_FREE( exec );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Init_Context                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initializes a context object.                                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    memory :: A handle to the parent memory object.                    */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    exec   :: A handle to the target execution context.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  static FT_Error
  Init_Context( TT_ExecContext  exec,
                FT_Memory       memory )
  {
    FT_Error  error;


    FT_TRACE1(( "Init_Context: new object at 0x%08p\n", exec ));

    exec->memory   = memory;
    exec->callSize = 32;

    if ( FT_NEW_ARRAY( exec->callStack, exec->callSize ) )
      goto Fail_Memory;

    /* all values in the context are set to 0 already, but this is */
    /* here as a remainder                                         */
    exec->maxPoints   = 0;
    exec->maxContours = 0;

    exec->stackSize = 0;
    exec->glyphSize = 0;

    exec->stack    = NULL;
    exec->glyphIns = NULL;

    exec->face = NULL;
    exec->size = NULL;

    return FT_Err_Ok;

  Fail_Memory:
    FT_ERROR(( "Init_Context: not enough memory for %p\n", exec ));
    TT_Done_Context( exec );

    return error;
 }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Update_Max                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Checks the size of a buffer and reallocates it if necessary.       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    memory     :: A handle to the parent memory object.                */
  /*                                                                       */
  /*    multiplier :: The size in bytes of each element in the buffer.     */
  /*                                                                       */
  /*    new_max    :: The new capacity (size) of the buffer.               */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    size       :: The address of the buffer's current size expressed   */
  /*                  in elements.                                         */
  /*                                                                       */
  /*    buff       :: The address of the buffer base pointer.              */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  Update_Max( FT_Memory  memory,
              FT_ULong*  size,
              FT_ULong   multiplier,
              void*      _pbuff,
              FT_ULong   new_max )
  {
    FT_Error  error;
    void**    pbuff = (void**)_pbuff;


    if ( *size < new_max )
    {
      if ( FT_REALLOC( *pbuff, *size * multiplier, new_max * multiplier ) )
        return error;
      *size = new_max;
    }

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Context                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Prepare an execution context for glyph hinting.                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A handle to the source face object.                        */
  /*                                                                       */
  /*    size :: A handle to the source size object.                        */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    exec :: A handle to the target execution context.                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Only the glyph loader and debugger should call this function.      */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  TT_Load_Context( TT_ExecContext  exec,
                   TT_Face         face,
                   TT_Size         size )
  {
    FT_Int          i;
    FT_ULong        tmp;
    TT_MaxProfile*  maxp;
    FT_Error        error;


    exec->face = face;
    maxp       = &face->max_profile;
    exec->size = size;

    if ( size )
    {
      exec->numFDefs   = size->num_function_defs;
      exec->maxFDefs   = size->max_function_defs;
      exec->numIDefs   = size->num_instruction_defs;
      exec->maxIDefs   = size->max_instruction_defs;
      exec->FDefs      = size->function_defs;
      exec->IDefs      = size->instruction_defs;
      exec->pointSize  = size->point_size;
      exec->tt_metrics = size->ttmetrics;
      exec->metrics    = *size->metrics;

      exec->maxFunc    = size->max_func;
      exec->maxIns     = size->max_ins;

      for ( i = 0; i < TT_MAX_CODE_RANGES; i++ )
        exec->codeRangeTable[i] = size->codeRangeTable[i];

      /* set graphics state */
      exec->GS = size->GS;

      exec->cvtSize = size->cvt_size;
      exec->cvt     = size->cvt;

      exec->storeSize = size->storage_size;
      exec->storage   = size->storage;

      exec->twilight  = size->twilight;

      /* In case of multi-threading it can happen that the old size object */
      /* no longer exists, thus we must clear all glyph zone references.   */
      FT_ZERO( &exec->zp0 );
      exec->zp1 = exec->zp0;
      exec->zp2 = exec->zp0;
    }

    /* XXX: We reserve a little more elements on the stack to deal safely */
    /*      with broken fonts like arialbs, courbs, timesbs, etc.         */
    tmp = (FT_ULong)exec->stackSize;
    error = Update_Max( exec->memory,
                        &tmp,
                        sizeof ( FT_F26Dot6 ),
                        (void*)&exec->stack,
                        maxp->maxStackElements + 32 );
    exec->stackSize = (FT_Long)tmp;
    if ( error )
      return error;

    tmp = exec->glyphSize;
    error = Update_Max( exec->memory,
                        &tmp,
                        sizeof ( FT_Byte ),
                        (void*)&exec->glyphIns,
                        maxp->maxSizeOfInstructions );
    exec->glyphSize = (FT_UShort)tmp;
    if ( error )
      return error;

    exec->pts.n_points   = 0;
    exec->pts.n_contours = 0;

    exec->zp1 = exec->pts;
    exec->zp2 = exec->pts;
    exec->zp0 = exec->pts;

    exec->instruction_trap = FALSE;

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Save_Context                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Saves the code ranges in a `size' object.                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    exec :: A handle to the source execution context.                  */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    size :: A handle to the target size object.                        */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Only the glyph loader and debugger should call this function.      */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  TT_Save_Context( TT_ExecContext  exec,
                   TT_Size         size )
  {
    FT_Int  i;


    /* XXX: Will probably disappear soon with all the code range */
    /*      management, which is now rather obsolete.            */
    /*                                                           */
    size->num_function_defs    = exec->numFDefs;
    size->num_instruction_defs = exec->numIDefs;

    size->max_func = exec->maxFunc;
    size->max_ins  = exec->maxIns;

    for ( i = 0; i < TT_MAX_CODE_RANGES; i++ )
      size->codeRangeTable[i] = exec->codeRangeTable[i];
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Run_Context                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Executes one or more instructions in the execution context.        */
  /*                                                                       */
  /* <Input>                                                               */
  /*    debug :: A Boolean flag.  If set, the function sets some internal  */
  /*             variables and returns immediately, otherwise TT_RunIns()  */
  /*             is called.                                                */
  /*                                                                       */
  /*             This is commented out currently.                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    exec  :: A handle to the target execution context.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    TrueType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  TT_Run_Context( TT_ExecContext  exec )
  {
    TT_Goto_CodeRange( exec, tt_coderange_glyph, 0 );

    exec->zp0 = exec->pts;
    exec->zp1 = exec->pts;
    exec->zp2 = exec->pts;

    exec->GS.gep0 = 1;
    exec->GS.gep1 = 1;
    exec->GS.gep2 = 1;

    exec->GS.projVector.x = 0x4000;
    exec->GS.projVector.y = 0x0000;

    exec->GS.freeVector = exec->GS.projVector;
    exec->GS.dualVector = exec->GS.projVector;

    exec->GS.round_state = 1;
    exec->GS.loop        = 1;

    /* some glyphs leave something on the stack. so we clean it */
    /* before a new execution.                                  */
    exec->top     = 0;
    exec->callTop = 0;

    return exec->face->interpreter( exec );
  }


  /* The default value for `scan_control' is documented as FALSE in the */
  /* TrueType specification.  This is confusing since it implies a      */
  /* Boolean value.  However, this is not the case, thus both the       */
  /* default values of our `scan_type' and `scan_control' fields (which */
  /* the documentation's `scan_control' variable is split into) are     */
  /* zero.                                                              */

  const TT_GraphicsState  tt_default_graphics_state =
  {
    0, 0, 0,
    { 0x4000, 0 },
    { 0x4000, 0 },
    { 0x4000, 0 },

    1, 64, 1,
    TRUE, 68, 0, 0, 9, 3,
    0, FALSE, 0, 1, 1, 1
  };


  /* documentation is in ttinterp.h */

  FT_EXPORT_DEF( TT_ExecContext )
  TT_New_Context( TT_Driver  driver )
  {
    FT_Memory  memory;
    FT_Error   error;

    TT_ExecContext  exec = NULL;


    if ( !driver )
      goto Fail;

    memory = driver->root.root.memory;

    /* allocate object */
    if ( FT_NEW( exec ) )
      goto Fail;

    /* initialize it; in case of error this deallocates `exec' too */
    error = Init_Context( exec, memory );
    if ( error )
      goto Fail;

    return exec;

  Fail:
    return NULL;
  }


  /*************************************************************************/
  /*                                                                       */
  /* Before an opcode is executed, the interpreter verifies that there are */
  /* enough arguments on the stack, with the help of the `Pop_Push_Count'  */
  /* table.                                                                */
  /*                                                                       */
  /* For each opcode, the first column gives the number of arguments that  */
  /* are popped from the stack; the second one gives the number of those   */
  /* that are pushed in result.                                            */
  /*                                                                       */
  /* Opcodes which have a varying number of parameters in the data stream  */
  /* (NPUSHB, NPUSHW) are handled specially; they have a negative value in */
  /* the `opcode_length' table, and the value in `Pop_Push_Count' is set   */
  /* to zero.                                                              */
  /*                                                                       */
  /*************************************************************************/


#undef  PACK
#define PACK( x, y )  ( ( x << 4 ) | y )


  static
  const FT_Byte  Pop_Push_Count[256] =
  {
    /* opcodes are gathered in groups of 16 */
    /* please keep the spaces as they are   */

    /*  SVTCA  y  */  PACK( 0, 0 ),
    /*  SVTCA  x  */  PACK( 0, 0 ),
    /*  SPvTCA y  */  PACK( 0, 0 ),
    /*  SPvTCA x  */  PACK( 0, 0 ),
    /*  SFvTCA y  */  PACK( 0, 0 ),
    /*  SFvTCA x  */  PACK( 0, 0 ),
    /*  SPvTL //  */  PACK( 2, 0 ),
    /*  SPvTL +   */  PACK( 2, 0 ),
    /*  SFvTL //  */  PACK( 2, 0 ),
    /*  SFvTL +   */  PACK( 2, 0 ),
    /*  SPvFS     */  PACK( 2, 0 ),
    /*  SFvFS     */  PACK( 2, 0 ),
    /*  GPv       */  PACK( 0, 2 ),
    /*  GFv       */  PACK( 0, 2 ),
    /*  SFvTPv    */  PACK( 0, 0 ),
    /*  ISECT     */  PACK( 5, 0 ),

    /*  SRP0      */  PACK( 1, 0 ),
    /*  SRP1      */  PACK( 1, 0 ),
    /*  SRP2      */  PACK( 1, 0 ),
    /*  SZP0      */  PACK( 1, 0 ),
    /*  SZP1      */  PACK( 1, 0 ),
    /*  SZP2      */  PACK( 1, 0 ),
    /*  SZPS      */  PACK( 1, 0 ),
    /*  SLOOP     */  PACK( 1, 0 ),
    /*  RTG       */  PACK( 0, 0 ),
    /*  RTHG      */  PACK( 0, 0 ),
    /*  SMD       */  PACK( 1, 0 ),
    /*  ELSE      */  PACK( 0, 0 ),
    /*  JMPR      */  PACK( 1, 0 ),
    /*  SCvTCi    */  PACK( 1, 0 ),
    /*  SSwCi     */  PACK( 1, 0 ),
    /*  SSW       */  PACK( 1, 0 ),

    /*  DUP       */  PACK( 1, 2 ),
    /*  POP       */  PACK( 1, 0 ),
    /*  CLEAR     */  PACK( 0, 0 ),
    /*  SWAP      */  PACK( 2, 2 ),
    /*  DEPTH     */  PACK( 0, 1 ),
    /*  CINDEX    */  PACK( 1, 1 ),
    /*  MINDEX    */  PACK( 1, 0 ),
    /*  AlignPTS  */  PACK( 2, 0 ),
    /*  INS_$28   */  PACK( 0, 0 ),
    /*  UTP       */  PACK( 1, 0 ),
    /*  LOOPCALL  */  PACK( 2, 0 ),
    /*  CALL      */  PACK( 1, 0 ),
    /*  FDEF      */  PACK( 1, 0 ),
    /*  ENDF      */  PACK( 0, 0 ),
    /*  MDAP[0]   */  PACK( 1, 0 ),
    /*  MDAP[1]   */  PACK( 1, 0 ),

    /*  IUP[0]    */  PACK( 0, 0 ),
    /*  IUP[1]    */  PACK( 0, 0 ),
    /*  SHP[0]    */  PACK( 0, 0 ), /* loops */
    /*  SHP[1]    */  PACK( 0, 0 ), /* loops */
    /*  SHC[0]    */  PACK( 1, 0 ),
    /*  SHC[1]    */  PACK( 1, 0 ),
    /*  SHZ[0]    */  PACK( 1, 0 ),
    /*  SHZ[1]    */  PACK( 1, 0 ),
    /*  SHPIX     */  PACK( 1, 0 ), /* loops */
    /*  IP        */  PACK( 0, 0 ), /* loops */
    /*  MSIRP[0]  */  PACK( 2, 0 ),
    /*  MSIRP[1]  */  PACK( 2, 0 ),
    /*  AlignRP   */  PACK( 0, 0 ), /* loops */
    /*  RTDG      */  PACK( 0, 0 ),
    /*  MIAP[0]   */  PACK( 2, 0 ),
    /*  MIAP[1]   */  PACK( 2, 0 ),

    /*  NPushB    */  PACK( 0, 0 ),
    /*  NPushW    */  PACK( 0, 0 ),
    /*  WS        */  PACK( 2, 0 ),
    /*  RS        */  PACK( 1, 1 ),
    /*  WCvtP     */  PACK( 2, 0 ),
    /*  RCvt      */  PACK( 1, 1 ),
    /*  GC[0]     */  PACK( 1, 1 ),
    /*  GC[1]     */  PACK( 1, 1 ),
    /*  SCFS      */  PACK( 2, 0 ),
    /*  MD[0]     */  PACK( 2, 1 ),
    /*  MD[1]     */  PACK( 2, 1 ),
    /*  MPPEM     */  PACK( 0, 1 ),
    /*  MPS       */  PACK( 0, 1 ),
    /*  FlipON    */  PACK( 0, 0 ),
    /*  FlipOFF   */  PACK( 0, 0 ),
    /*  DEBUG     */  PACK( 1, 0 ),

    /*  LT        */  PACK( 2, 1 ),
    /*  LTEQ      */  PACK( 2, 1 ),
    /*  GT        */  PACK( 2, 1 ),
    /*  GTEQ      */  PACK( 2, 1 ),
    /*  EQ        */  PACK( 2, 1 ),
    /*  NEQ       */  PACK( 2, 1 ),
    /*  ODD       */  PACK( 1, 1 ),
    /*  EVEN      */  PACK( 1, 1 ),
    /*  IF        */  PACK( 1, 0 ),
    /*  EIF       */  PACK( 0, 0 ),
    /*  AND       */  PACK( 2, 1 ),
    /*  OR        */  PACK( 2, 1 ),
    /*  NOT       */  PACK( 1, 1 ),
    /*  DeltaP1   */  PACK( 1, 0 ),
    /*  SDB       */  PACK( 1, 0 ),
    /*  SDS       */  PACK( 1, 0 ),

    /*  ADD       */  PACK( 2, 1 ),
    /*  SUB       */  PACK( 2, 1 ),
    /*  DIV       */  PACK( 2, 1 ),
    /*  MUL       */  PACK( 2, 1 ),
    /*  ABS       */  PACK( 1, 1 ),
    /*  NEG       */  PACK( 1, 1 ),
    /*  FLOOR     */  PACK( 1, 1 ),
    /*  CEILING   */  PACK( 1, 1 ),
    /*  ROUND[0]  */  PACK( 1, 1 ),
    /*  ROUND[1]  */  PACK( 1, 1 ),
    /*  ROUND[2]  */  PACK( 1, 1 ),
    /*  ROUND[3]  */  PACK( 1, 1 ),
    /*  NROUND[0] */  PACK( 1, 1 ),
    /*  NROUND[1] */  PACK( 1, 1 ),
    /*  NROUND[2] */  PACK( 1, 1 ),
    /*  NROUND[3] */  PACK( 1, 1 ),

    /*  WCvtF     */  PACK( 2, 0 ),
    /*  DeltaP2   */  PACK( 1, 0 ),
    /*  DeltaP3   */  PACK( 1, 0 ),
    /*  DeltaCn[0] */ PACK( 1, 0 ),
    /*  DeltaCn[1] */ PACK( 1, 0 ),
    /*  DeltaCn[2] */ PACK( 1, 0 ),
    /*  SROUND    */  PACK( 1, 0 ),
    /*  S45Round  */  PACK( 1, 0 ),
    /*  JROT      */  PACK( 2, 0 ),
    /*  JROF      */  PACK( 2, 0 ),
    /*  ROFF      */  PACK( 0, 0 ),
    /*  INS_$7B   */  PACK( 0, 0 ),
    /*  RUTG      */  PACK( 0, 0 ),
    /*  RDTG      */  PACK( 0, 0 ),
    /*  SANGW     */  PACK( 1, 0 ),
    /*  AA        */  PACK( 1, 0 ),

    /*  FlipPT    */  PACK( 0, 0 ), /* loops */
    /*  FlipRgON  */  PACK( 2, 0 ),
    /*  FlipRgOFF */  PACK( 2, 0 ),
    /*  INS_$83   */  PACK( 0, 0 ),
    /*  INS_$84   */  PACK( 0, 0 ),
    /*  ScanCTRL  */  PACK( 1, 0 ),
    /*  SDPvTL[0] */  PACK( 2, 0 ),
    /*  SDPvTL[1] */  PACK( 2, 0 ),
    /*  GetINFO   */  PACK( 1, 1 ),
    /*  IDEF      */  PACK( 1, 0 ),
    /*  ROLL      */  PACK( 3, 3 ),
    /*  MAX       */  PACK( 2, 1 ),
    /*  MIN       */  PACK( 2, 1 ),
    /*  ScanTYPE  */  PACK( 1, 0 ),
    /*  InstCTRL  */  PACK( 2, 0 ),
    /*  INS_$8F   */  PACK( 0, 0 ),

    /*  INS_$90  */   PACK( 0, 0 ),
    /*  GETVAR   */   PACK( 0, 0 ), /* will be handled specially */
    /*  GETDATA  */   PACK( 0, 1 ),
    /*  INS_$93  */   PACK( 0, 0 ),
    /*  INS_$94  */   PACK( 0, 0 ),
    /*  INS_$95  */   PACK( 0, 0 ),
    /*  INS_$96  */   PACK( 0, 0 ),
    /*  INS_$97  */   PACK( 0, 0 ),
    /*  INS_$98  */   PACK( 0, 0 ),
    /*  INS_$99  */   PACK( 0, 0 ),
    /*  INS_$9A  */   PACK( 0, 0 ),
    /*  INS_$9B  */   PACK( 0, 0 ),
    /*  INS_$9C  */   PACK( 0, 0 ),
    /*  INS_$9D  */   PACK( 0, 0 ),
    /*  INS_$9E  */   PACK( 0, 0 ),
    /*  INS_$9F  */   PACK( 0, 0 ),

    /*  INS_$A0  */   PACK( 0, 0 ),
    /*  INS_$A1  */   PACK( 0, 0 ),
    /*  INS_$A2  */   PACK( 0, 0 ),
    /*  INS_$A3  */   PACK( 0, 0 ),
    /*  INS_$A4  */   PACK( 0, 0 ),
    /*  INS_$A5  */   PACK( 0, 0 ),
    /*  INS_$A6  */   PACK( 0, 0 ),
    /*  INS_$A7  */   PACK( 0, 0 ),
    /*  INS_$A8  */   PACK( 0, 0 ),
    /*  INS_$A9  */   PACK( 0, 0 ),
    /*  INS_$AA  */   PACK( 0, 0 ),
    /*  INS_$AB  */   PACK( 0, 0 ),
    /*  INS_$AC  */   PACK( 0, 0 ),
    /*  INS_$AD  */   PACK( 0, 0 ),
    /*  INS_$AE  */   PACK( 0, 0 ),
    /*  INS_$AF  */   PACK( 0, 0 ),

    /*  PushB[0]  */  PACK( 0, 1 ),
    /*  PushB[1]  */  PACK( 0, 2 ),
    /*  PushB[2]  */  PACK( 0, 3 ),
    /*  PushB[3]  */  PACK( 0, 4 ),
    /*  PushB[4]  */  PACK( 0, 5 ),
    /*  PushB[5]  */  PACK( 0, 6 ),
    /*  PushB[6]  */  PACK( 0, 7 ),
    /*  PushB[7]  */  PACK( 0, 8 ),
    /*  PushW[0]  */  PACK( 0, 1 ),
    /*  PushW[1]  */  PACK( 0, 2 ),
    /*  PushW[2]  */  PACK( 0, 3 ),
    /*  PushW[3]  */  PACK( 0, 4 ),
    /*  PushW[4]  */  PACK( 0, 5 ),
    /*  PushW[5]  */  PACK( 0, 6 ),
    /*  PushW[6]  */  PACK( 0, 7 ),
    /*  PushW[7]  */  PACK( 0, 8 ),

    /*  MDRP[00]  */  PACK( 1, 0 ),
    /*  MDRP[01]  */  PACK( 1, 0 ),
    /*  MDRP[02]  */  PACK( 1, 0 ),
    /*  MDRP[03]  */  PACK( 1, 0 ),
    /*  MDRP[04]  */  PACK( 1, 0 ),
    /*  MDRP[05]  */  PACK( 1, 0 ),
    /*  MDRP[06]  */  PACK( 1, 0 ),
    /*  MDRP[07]  */  PACK( 1, 0 ),
    /*  MDRP[08]  */  PACK( 1, 0 ),
    /*  MDRP[09]  */  PACK( 1, 0 ),
    /*  MDRP[10]  */  PACK( 1, 0 ),
    /*  MDRP[11]  */  PACK( 1, 0 ),
    /*  MDRP[12]  */  PACK( 1, 0 ),
    /*  MDRP[13]  */  PACK( 1, 0 ),
    /*  MDRP[14]  */  PACK( 1, 0 ),
    /*  MDRP[15]  */  PACK( 1, 0 ),

    /*  MDRP[16]  */  PACK( 1, 0 ),
    /*  MDRP[17]  */  PACK( 1, 0 ),
    /*  MDRP[18]  */  PACK( 1, 0 ),
    /*  MDRP[19]  */  PACK( 1, 0 ),
    /*  MDRP[20]  */  PACK( 1, 0 ),
    /*  MDRP[21]  */  PACK( 1, 0 ),
    /*  MDRP[22]  */  PACK( 1, 0 ),
    /*  MDRP[23]  */  PACK( 1, 0 ),
    /*  MDRP[24]  */  PACK( 1, 0 ),
    /*  MDRP[25]  */  PACK( 1, 0 ),
    /*  MDRP[26]  */  PACK( 1, 0 ),
    /*  MDRP[27]  */  PACK( 1, 0 ),
    /*  MDRP[28]  */  PACK( 1, 0 ),
    /*  MDRP[29]  */  PACK( 1, 0 ),
    /*  MDRP[30]  */  PACK( 1, 0 ),
    /*  MDRP[31]  */  PACK( 1, 0 ),

    /*  MIRP[00]  */  PACK( 2, 0 ),
    /*  MIRP[01]  */  PACK( 2, 0 ),
    /*  MIRP[02]  */  PACK( 2, 0 ),
    /*  MIRP[03]  */  PACK( 2, 0 ),
    /*  MIRP[04]  */  PACK( 2, 0 ),
    /*  MIRP[05]  */  PACK( 2, 0 ),
    /*  MIRP[06]  */  PACK( 2, 0 ),
    /*  MIRP[07]  */  PACK( 2, 0 ),
    /*  MIRP[08]  */  PACK( 2, 0 ),
    /*  MIRP[09]  */  PACK( 2, 0 ),
    /*  MIRP[10]  */  PACK( 2, 0 ),
    /*  MIRP[11]  */  PACK( 2, 0 ),
    /*  MIRP[12]  */  PACK( 2, 0 ),
    /*  MIRP[13]  */  PACK( 2, 0 ),
    /*  MIRP[14]  */  PACK( 2, 0 ),
    /*  MIRP[15]  */  PACK( 2, 0 ),

    /*  MIRP[16]  */  PACK( 2, 0 ),
    /*  MIRP[17]  */  PACK( 2, 0 ),
    /*  MIRP[18]  */  PACK( 2, 0 ),
    /*  MIRP[19]  */  PACK( 2, 0 ),
    /*  MIRP[20]  */  PACK( 2, 0 ),
    /*  MIRP[21]  */  PACK( 2, 0 ),
    /*  MIRP[22]  */  PACK( 2, 0 ),
    /*  MIRP[23]  */  PACK( 2, 0 ),
    /*  MIRP[24]  */  PACK( 2, 0 ),
    /*  MIRP[25]  */  PACK( 2, 0 ),
    /*  MIRP[26]  */  PACK( 2, 0 ),
    /*  MIRP[27]  */  PACK( 2, 0 ),
    /*  MIRP[28]  */  PACK( 2, 0 ),
    /*  MIRP[29]  */  PACK( 2, 0 ),
    /*  MIRP[30]  */  PACK( 2, 0 ),
    /*  MIRP[31]  */  PACK( 2, 0 )
  };


#ifdef FT_DEBUG_LEVEL_TRACE

  /* the first hex digit gives the length of the opcode name; the space */
  /* after the digit is here just to increase readability of the source */
  /* code                                                               */

  static
  const char*  const opcode_name[256] =
  {
    "7 SVTCA y",
    "7 SVTCA x",
    "8 SPvTCA y",
    "8 SPvTCA x",
    "8 SFvTCA y",
    "8 SFvTCA x",
    "8 SPvTL ||",
    "7 SPvTL +",
    "8 SFvTL ||",
    "7 SFvTL +",
    "5 SPvFS",
    "5 SFvFS",
    "3 GPv",
    "3 GFv",
    "6 SFvTPv",
    "5 ISECT",

    "4 SRP0",
    "4 SRP1",
    "4 SRP2",
    "4 SZP0",
    "4 SZP1",
    "4 SZP2",
    "4 SZPS",
    "5 SLOOP",
    "3 RTG",
    "4 RTHG",
    "3 SMD",
    "4 ELSE",
    "4 JMPR",
    "6 SCvTCi",
    "5 SSwCi",
    "3 SSW",

    "3 DUP",
    "3 POP",
    "5 CLEAR",
    "4 SWAP",
    "5 DEPTH",
    "6 CINDEX",
    "6 MINDEX",
    "8 AlignPTS",
    "7 INS_$28",
    "3 UTP",
    "8 LOOPCALL",
    "4 CALL",
    "4 FDEF",
    "4 ENDF",
    "7 MDAP[0]",
    "7 MDAP[1]",

    "6 IUP[0]",
    "6 IUP[1]",
    "6 SHP[0]",
    "6 SHP[1]",
    "6 SHC[0]",
    "6 SHC[1]",
    "6 SHZ[0]",
    "6 SHZ[1]",
    "5 SHPIX",
    "2 IP",
    "8 MSIRP[0]",
    "8 MSIRP[1]",
    "7 AlignRP",
    "4 RTDG",
    "7 MIAP[0]",
    "7 MIAP[1]",

    "6 NPushB",
    "6 NPushW",
    "2 WS",
    "2 RS",
    "5 WCvtP",
    "4 RCvt",
    "5 GC[0]",
    "5 GC[1]",
    "4 SCFS",
    "5 MD[0]",
    "5 MD[1]",
    "5 MPPEM",
    "3 MPS",
    "6 FlipON",
    "7 FlipOFF",
    "5 DEBUG",

    "2 LT",
    "4 LTEQ",
    "2 GT",
    "4 GTEQ",
    "2 EQ",
    "3 NEQ",
    "3 ODD",
    "4 EVEN",
    "2 IF",
    "3 EIF",
    "3 AND",
    "2 OR",
    "3 NOT",
    "7 DeltaP1",
    "3 SDB",
    "3 SDS",

    "3 ADD",
    "3 SUB",
    "3 DIV",
    "3 MUL",
    "3 ABS",
    "3 NEG",
    "5 FLOOR",
    "7 CEILING",
    "8 ROUND[0]",
    "8 ROUND[1]",
    "8 ROUND[2]",
    "8 ROUND[3]",
    "9 NROUND[0]",
    "9 NROUND[1]",
    "9 NROUND[2]",
    "9 NROUND[3]",

    "5 WCvtF",
    "7 DeltaP2",
    "7 DeltaP3",
    "A DeltaCn[0]",
    "A DeltaCn[1]",
    "A DeltaCn[2]",
    "6 SROUND",
    "8 S45Round",
    "4 JROT",
    "4 JROF",
    "4 ROFF",
    "7 INS_$7B",
    "4 RUTG",
    "4 RDTG",
    "5 SANGW",
    "2 AA",

    "6 FlipPT",
    "8 FlipRgON",
    "9 FlipRgOFF",
    "7 INS_$83",
    "7 INS_$84",
    "8 ScanCTRL",
    "9 SDPvTL[0]",
    "9 SDPvTL[1]",
    "7 GetINFO",
    "4 IDEF",
    "4 ROLL",
    "3 MAX",
    "3 MIN",
    "8 ScanTYPE",
    "8 InstCTRL",
    "7 INS_$8F",

    "7 INS_$90",
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    "6 GETVAR",
    "7 GETDATA",
#else
    "7 INS_$91",
    "7 INS_$92",
#endif
    "7 INS_$93",
    "7 INS_$94",
    "7 INS_$95",
    "7 INS_$96",
    "7 INS_$97",
    "7 INS_$98",
    "7 INS_$99",
    "7 INS_$9A",
    "7 INS_$9B",
    "7 INS_$9C",
    "7 INS_$9D",
    "7 INS_$9E",
    "7 INS_$9F",

    "7 INS_$A0",
    "7 INS_$A1",
    "7 INS_$A2",
    "7 INS_$A3",
    "7 INS_$A4",
    "7 INS_$A5",
    "7 INS_$A6",
    "7 INS_$A7",
    "7 INS_$A8",
    "7 INS_$A9",
    "7 INS_$AA",
    "7 INS_$AB",
    "7 INS_$AC",
    "7 INS_$AD",
    "7 INS_$AE",
    "7 INS_$AF",

    "8 PushB[0]",
    "8 PushB[1]",
    "8 PushB[2]",
    "8 PushB[3]",
    "8 PushB[4]",
    "8 PushB[5]",
    "8 PushB[6]",
    "8 PushB[7]",
    "8 PushW[0]",
    "8 PushW[1]",
    "8 PushW[2]",
    "8 PushW[3]",
    "8 PushW[4]",
    "8 PushW[5]",
    "8 PushW[6]",
    "8 PushW[7]",

    "8 MDRP[00]",
    "8 MDRP[01]",
    "8 MDRP[02]",
    "8 MDRP[03]",
    "8 MDRP[04]",
    "8 MDRP[05]",
    "8 MDRP[06]",
    "8 MDRP[07]",
    "8 MDRP[08]",
    "8 MDRP[09]",
    "8 MDRP[10]",
    "8 MDRP[11]",
    "8 MDRP[12]",
    "8 MDRP[13]",
    "8 MDRP[14]",
    "8 MDRP[15]",

    "8 MDRP[16]",
    "8 MDRP[17]",
    "8 MDRP[18]",
    "8 MDRP[19]",
    "8 MDRP[20]",
    "8 MDRP[21]",
    "8 MDRP[22]",
    "8 MDRP[23]",
    "8 MDRP[24]",
    "8 MDRP[25]",
    "8 MDRP[26]",
    "8 MDRP[27]",
    "8 MDRP[28]",
    "8 MDRP[29]",
    "8 MDRP[30]",
    "8 MDRP[31]",

    "8 MIRP[00]",
    "8 MIRP[01]",
    "8 MIRP[02]",
    "8 MIRP[03]",
    "8 MIRP[04]",
    "8 MIRP[05]",
    "8 MIRP[06]",
    "8 MIRP[07]",
    "8 MIRP[08]",
    "8 MIRP[09]",
    "8 MIRP[10]",
    "8 MIRP[11]",
    "8 MIRP[12]",
    "8 MIRP[13]",
    "8 MIRP[14]",
    "8 MIRP[15]",

    "8 MIRP[16]",
    "8 MIRP[17]",
    "8 MIRP[18]",
    "8 MIRP[19]",
    "8 MIRP[20]",
    "8 MIRP[21]",
    "8 MIRP[22]",
    "8 MIRP[23]",
    "8 MIRP[24]",
    "8 MIRP[25]",
    "8 MIRP[26]",
    "8 MIRP[27]",
    "8 MIRP[28]",
    "8 MIRP[29]",
    "8 MIRP[30]",
    "8 MIRP[31]"
  };

#endif /* FT_DEBUG_LEVEL_TRACE */


  static
  const FT_Char  opcode_length[256] =
  {
    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,

   -1,-2, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,

    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
    2, 3, 4, 5,  6, 7, 8, 9,  3, 5, 7, 9, 11,13,15,17,

    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1
  };

#undef PACK


#ifndef FT_CONFIG_OPTION_NO_ASSEMBLER

#if defined( __arm__ )                                 && \
    ( defined( __thumb2__ ) || !defined( __thumb__ ) )

#define TT_MulFix14  TT_MulFix14_arm

  static FT_Int32
  TT_MulFix14_arm( FT_Int32  a,
                   FT_Int    b )
  {
    FT_Int32  t, t2;


#if defined( __CC_ARM ) || defined( __ARMCC__ )

    __asm
    {
      smull t2, t,  b,  a           /* (lo=t2,hi=t) = a*b */
      mov   a,  t,  asr #31         /* a   = (hi >> 31) */
      add   a,  a,  #0x2000         /* a  += 0x2000 */
      adds  t2, t2, a               /* t2 += a */
      adc   t,  t,  #0              /* t  += carry */
      mov   a,  t2, lsr #14         /* a   = t2 >> 14 */
      orr   a,  a,  t,  lsl #18     /* a  |= t << 18 */
    }

#elif defined( __GNUC__ )

    __asm__ __volatile__ (
      "smull  %1, %2, %4, %3\n\t"       /* (lo=%1,hi=%2) = a*b */
      "mov    %0, %2, asr #31\n\t"      /* %0  = (hi >> 31) */
#if defined( __clang__ ) && defined( __thumb2__ )
      "add.w  %0, %0, #0x2000\n\t"      /* %0 += 0x2000 */
#else
      "add    %0, %0, #0x2000\n\t"      /* %0 += 0x2000 */
#endif
      "adds   %1, %1, %0\n\t"           /* %1 += %0 */
      "adc    %2, %2, #0\n\t"           /* %2 += carry */
      "mov    %0, %1, lsr #14\n\t"      /* %0  = %1 >> 16 */
      "orr    %0, %0, %2, lsl #18\n\t"  /* %0 |= %2 << 16 */
      : "=r"(a), "=&r"(t2), "=&r"(t)
      : "r"(a), "r"(b)
      : "cc" );

#endif

    return a;
  }

#endif /* __arm__ && ( __thumb2__ || !__thumb__ ) */

#endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */


#if defined( __GNUC__ )                              && \
    ( defined( __i386__ ) || defined( __x86_64__ ) )

#define TT_MulFix14  TT_MulFix14_long_long

  /* Temporarily disable the warning that C90 doesn't support `long long'. */
#if ( __GNUC__ * 100 + __GNUC_MINOR__ ) >= 406
#pragma GCC diagnostic push
#endif
#pragma GCC diagnostic ignored "-Wlong-long"

  /* This is declared `noinline' because inlining the function results */
  /* in slower code.  The `pure' attribute indicates that the result   */
  /* only depends on the parameters.                                   */
  static __attribute__(( noinline ))
         __attribute__(( pure )) FT_Int32
  TT_MulFix14_long_long( FT_Int32  a,
                         FT_Int    b )
  {

    long long  ret = (long long)a * b;

    /* The following line assumes that right shifting of signed values */
    /* will actually preserve the sign bit.  The exact behaviour is    */
    /* undefined, but this is true on x86 and x86_64.                  */
    long long  tmp = ret >> 63;


    ret += 0x2000 + tmp;

    return (FT_Int32)( ret >> 14 );
  }

#if ( __GNUC__ * 100 + __GNUC_MINOR__ ) >= 406
#pragma GCC diagnostic pop
#endif

#endif /* __GNUC__ && ( __i386__ || __x86_64__ ) */


#ifndef TT_MulFix14

  /* Compute (a*b)/2^14 with maximum accuracy and rounding.  */
  /* This is optimized to be faster than calling FT_MulFix() */
  /* for platforms where sizeof(int) == 2.                   */
  static FT_Int32
  TT_MulFix14( FT_Int32  a,
               FT_Int    b )
  {
    FT_Int32   sign;
    FT_UInt32  ah, al, mid, lo, hi;


    sign = a ^ b;

    if ( a < 0 )
      a = -a;
    if ( b < 0 )
      b = -b;

    ah = (FT_UInt32)( ( a >> 16 ) & 0xFFFFU );
    al = (FT_UInt32)( a & 0xFFFFU );

    lo    = al * b;
    mid   = ah * b;
    hi    = mid >> 16;
    mid   = ( mid << 16 ) + ( 1 << 13 ); /* rounding */
    lo   += mid;
    if ( lo < mid )
      hi += 1;

    mid = ( lo >> 14 ) | ( hi << 18 );

    return sign >= 0 ? (FT_Int32)mid : -(FT_Int32)mid;
  }

#endif  /* !TT_MulFix14 */


#if defined( __GNUC__ )        && \
    ( defined( __i386__ )   ||    \
      defined( __x86_64__ ) ||    \
      defined( __arm__ )    )

#define TT_DotFix14  TT_DotFix14_long_long

#if ( __GNUC__ * 100 + __GNUC_MINOR__ ) >= 406
#pragma GCC diagnostic push
#endif
#pragma GCC diagnostic ignored "-Wlong-long"

  static __attribute__(( pure )) FT_Int32
  TT_DotFix14_long_long( FT_Int32  ax,
                         FT_Int32  ay,
                         FT_Int    bx,
                         FT_Int    by )
  {
    /* Temporarily disable the warning that C90 doesn't support */
    /* `long long'.                                             */

    long long  temp1 = (long long)ax * bx;
    long long  temp2 = (long long)ay * by;


    temp1 += temp2;
    temp2  = temp1 >> 63;
    temp1 += 0x2000 + temp2;

    return (FT_Int32)( temp1 >> 14 );

  }

#if ( __GNUC__ * 100 + __GNUC_MINOR__ ) >= 406
#pragma GCC diagnostic pop
#endif

#endif /* __GNUC__ && (__arm__ || __i386__ || __x86_64__) */


#ifndef TT_DotFix14

  /* compute (ax*bx+ay*by)/2^14 with maximum accuracy and rounding */
  static FT_Int32
  TT_DotFix14( FT_Int32  ax,
               FT_Int32  ay,
               FT_Int    bx,
               FT_Int    by )
  {
    FT_Int32   m, s, hi1, hi2, hi;
    FT_UInt32  l, lo1, lo2, lo;


    /* compute ax*bx as 64-bit value */
    l = (FT_UInt32)( ( ax & 0xFFFFU ) * bx );
    m = ( ax >> 16 ) * bx;

    lo1 = l + ( (FT_UInt32)m << 16 );
    hi1 = ( m >> 16 ) + ( (FT_Int32)l >> 31 ) + ( lo1 < l );

    /* compute ay*by as 64-bit value */
    l = (FT_UInt32)( ( ay & 0xFFFFU ) * by );
    m = ( ay >> 16 ) * by;

    lo2 = l + ( (FT_UInt32)m << 16 );
    hi2 = ( m >> 16 ) + ( (FT_Int32)l >> 31 ) + ( lo2 < l );

    /* add them */
    lo = lo1 + lo2;
    hi = hi1 + hi2 + ( lo < lo1 );

    /* divide the result by 2^14 with rounding */
    s   = hi >> 31;
    l   = lo + (FT_UInt32)s;
    hi += s + ( l < lo );
    lo  = l;

    l   = lo + 0x2000U;
    hi += ( l < lo );

    return (FT_Int32)( ( (FT_UInt32)hi << 18 ) | ( l >> 14 ) );
  }

#endif /* TT_DotFix14 */


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Current_Ratio                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Returns the current aspect ratio scaling factor depending on the   */
  /*    projection vector's state and device resolutions.                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The aspect ratio in 16.16 format, always <= 1.0 .                  */
  /*                                                                       */
  static FT_Long
  Current_Ratio( TT_ExecContext  exc )
  {
    if ( !exc->tt_metrics.ratio )
    {
      if ( exc->GS.projVector.y == 0 )
        exc->tt_metrics.ratio = exc->tt_metrics.x_ratio;

      else if ( exc->GS.projVector.x == 0 )
        exc->tt_metrics.ratio = exc->tt_metrics.y_ratio;

      else
      {
        FT_F26Dot6  x, y;


        x = TT_MulFix14( exc->tt_metrics.x_ratio,
                         exc->GS.projVector.x );
        y = TT_MulFix14( exc->tt_metrics.y_ratio,
                         exc->GS.projVector.y );
        exc->tt_metrics.ratio = FT_Hypot( x, y );
      }
    }
    return exc->tt_metrics.ratio;
  }


  FT_CALLBACK_DEF( FT_Long )
  Current_Ppem( TT_ExecContext  exc )
  {
    return exc->tt_metrics.ppem;
  }


  FT_CALLBACK_DEF( FT_Long )
  Current_Ppem_Stretched( TT_ExecContext  exc )
  {
    return FT_MulFix( exc->tt_metrics.ppem, Current_Ratio( exc ) );
  }


  /*************************************************************************/
  /*                                                                       */
  /* Functions related to the control value table (CVT).                   */
  /*                                                                       */
  /*************************************************************************/


  FT_CALLBACK_DEF( FT_F26Dot6 )
  Read_CVT( TT_ExecContext  exc,
            FT_ULong        idx )
  {
    return exc->cvt[idx];
  }


  FT_CALLBACK_DEF( FT_F26Dot6 )
  Read_CVT_Stretched( TT_ExecContext  exc,
                      FT_ULong        idx )
  {
    return FT_MulFix( exc->cvt[idx], Current_Ratio( exc ) );
  }


  FT_CALLBACK_DEF( void )
  Write_CVT( TT_ExecContext  exc,
             FT_ULong        idx,
             FT_F26Dot6      value )
  {
    exc->cvt[idx] = value;
  }


  FT_CALLBACK_DEF( void )
  Write_CVT_Stretched( TT_ExecContext  exc,
                       FT_ULong        idx,
                       FT_F26Dot6      value )
  {
    exc->cvt[idx] = FT_DivFix( value, Current_Ratio( exc ) );
  }


  FT_CALLBACK_DEF( void )
  Move_CVT( TT_ExecContext  exc,
            FT_ULong        idx,
            FT_F26Dot6      value )
  {
    exc->cvt[idx] += value;
  }


  FT_CALLBACK_DEF( void )
  Move_CVT_Stretched( TT_ExecContext  exc,
                      FT_ULong        idx,
                      FT_F26Dot6      value )
  {
    exc->cvt[idx] += FT_DivFix( value, Current_Ratio( exc ) );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    GetShortIns                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Returns a short integer taken from the instruction stream at       */
  /*    address IP.                                                        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Short read at code[IP].                                            */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This one could become a macro.                                     */
  /*                                                                       */
  static FT_Short
  GetShortIns( TT_ExecContext  exc )
  {
    /* Reading a byte stream so there is no endianness (DaveP) */
    exc->IP += 2;
    return (FT_Short)( ( exc->code[exc->IP - 2] << 8 ) +
                         exc->code[exc->IP - 1]      );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Ins_Goto_CodeRange                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Goes to a certain code range in the instruction stream.            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    aRange :: The index of the code range.                             */
  /*                                                                       */
  /*    aIP    :: The new IP address in the code range.                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    SUCCESS or FAILURE.                                                */
  /*                                                                       */
  static FT_Bool
  Ins_Goto_CodeRange( TT_ExecContext  exc,
                      FT_Int          aRange,
                      FT_Long         aIP )
  {
    TT_CodeRange*  range;


    if ( aRange < 1 || aRange > 3 )
    {
      exc->error = FT_THROW( Bad_Argument );
      return FAILURE;
    }

    range = &exc->codeRangeTable[aRange - 1];

    if ( !range->base )     /* invalid coderange */
    {
      exc->error = FT_THROW( Invalid_CodeRange );
      return FAILURE;
    }

    /* NOTE: Because the last instruction of a program may be a CALL */
    /*       which will return to the first byte *after* the code    */
    /*       range, we test for aIP <= Size, instead of aIP < Size.  */

    if ( aIP > range->size )
    {
      exc->error = FT_THROW( Code_Overflow );
      return FAILURE;
    }

    exc->code     = range->base;
    exc->codeSize = range->size;
    exc->IP       = aIP;
    exc->curRange = aRange;

    return SUCCESS;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Direct_Move                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Moves a point by a given distance along the freedom vector.  The   */
  /*    point will be `touched'.                                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    point    :: The index of the point to move.                        */
  /*                                                                       */
  /*    distance :: The distance to apply.                                 */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    zone     :: The affected glyph zone.                               */
  /*                                                                       */
  /* <Note>                                                                */
  /*    See `ttinterp.h' for details on backward compatibility mode.       */
  /*    `Touches' the point.                                               */
  /*                                                                       */
  static void
  Direct_Move( TT_ExecContext  exc,
               TT_GlyphZone    zone,
               FT_UShort       point,
               FT_F26Dot6      distance )
  {
    FT_F26Dot6  v;


    v = exc->GS.freeVector.x;

    if ( v != 0 )
    {
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      if ( SUBPIXEL_HINTING_INFINALITY                            &&
           ( !exc->ignore_x_mode                                ||
             ( exc->sph_tweak_flags & SPH_TWEAK_ALLOW_X_DMOVE ) ) )
        zone->cur[point].x += FT_MulDiv( distance, v, exc->F_dot_P );
      else
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      /* Exception to the post-IUP curfew: Allow the x component of */
      /* diagonal moves, but only post-IUP.  DejaVu tries to adjust */
      /* diagonal stems like on `Z' and `z' post-IUP.               */
      if ( SUBPIXEL_HINTING_MINIMAL && !exc->backward_compatibility )
        zone->cur[point].x += FT_MulDiv( distance, v, exc->F_dot_P );
      else
#endif

      if ( NO_SUBPIXEL_HINTING )
        zone->cur[point].x += FT_MulDiv( distance, v, exc->F_dot_P );

      zone->tags[point] |= FT_CURVE_TAG_TOUCH_X;
    }

    v = exc->GS.freeVector.y;

    if ( v != 0 )
    {
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      if ( !( SUBPIXEL_HINTING_MINIMAL    &&
              exc->backward_compatibility &&
              exc->iupx_called            &&
              exc->iupy_called            ) )
#endif
        zone->cur[point].y += FT_MulDiv( distance, v, exc->F_dot_P );

      zone->tags[point] |= FT_CURVE_TAG_TOUCH_Y;
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Direct_Move_Orig                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Moves the *original* position of a point by a given distance along */
  /*    the freedom vector.  Obviously, the point will not be `touched'.   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    point    :: The index of the point to move.                        */
  /*                                                                       */
  /*    distance :: The distance to apply.                                 */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    zone     :: The affected glyph zone.                               */
  /*                                                                       */
  static void
  Direct_Move_Orig( TT_ExecContext  exc,
                    TT_GlyphZone    zone,
                    FT_UShort       point,
                    FT_F26Dot6      distance )
  {
    FT_F26Dot6  v;


    v = exc->GS.freeVector.x;

    if ( v != 0 )
      zone->org[point].x += FT_MulDiv( distance, v, exc->F_dot_P );

    v = exc->GS.freeVector.y;

    if ( v != 0 )
      zone->org[point].y += FT_MulDiv( distance, v, exc->F_dot_P );
  }


  /*************************************************************************/
  /*                                                                       */
  /* Special versions of Direct_Move()                                     */
  /*                                                                       */
  /*   The following versions are used whenever both vectors are both      */
  /*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
  /*   See `ttinterp.h' for details on backward compatibility mode.        */
  /*                                                                       */
  /*************************************************************************/


  static void
  Direct_Move_X( TT_ExecContext  exc,
                 TT_GlyphZone    zone,
                 FT_UShort       point,
                 FT_F26Dot6      distance )
  {
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( SUBPIXEL_HINTING_INFINALITY && !exc->ignore_x_mode )
      zone->cur[point].x += distance;
    else
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    if ( SUBPIXEL_HINTING_MINIMAL && !exc->backward_compatibility )
      zone->cur[point].x += distance;
    else
#endif

    if ( NO_SUBPIXEL_HINTING )
      zone->cur[point].x += distance;

    zone->tags[point]  |= FT_CURVE_TAG_TOUCH_X;
  }


  static void
  Direct_Move_Y( TT_ExecContext  exc,
                 TT_GlyphZone    zone,
                 FT_UShort       point,
                 FT_F26Dot6      distance )
  {
    FT_UNUSED( exc );

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    if ( !( SUBPIXEL_HINTING_MINIMAL             &&
            exc->backward_compatibility          &&
            exc->iupx_called && exc->iupy_called ) )
#endif
      zone->cur[point].y += distance;

    zone->tags[point] |= FT_CURVE_TAG_TOUCH_Y;
  }


  /*************************************************************************/
  /*                                                                       */
  /* Special versions of Direct_Move_Orig()                                */
  /*                                                                       */
  /*   The following versions are used whenever both vectors are both      */
  /*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
  /*                                                                       */
  /*************************************************************************/


  static void
  Direct_Move_Orig_X( TT_ExecContext  exc,
                      TT_GlyphZone    zone,
                      FT_UShort       point,
                      FT_F26Dot6      distance )
  {
    FT_UNUSED( exc );

    zone->org[point].x += distance;
  }


  static void
  Direct_Move_Orig_Y( TT_ExecContext  exc,
                      TT_GlyphZone    zone,
                      FT_UShort       point,
                      FT_F26Dot6      distance )
  {
    FT_UNUSED( exc );

    zone->org[point].y += distance;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Round_None                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Does not round, but adds engine compensation.                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    distance     :: The distance (not) to round.                       */
  /*                                                                       */
  /*    compensation :: The engine compensation.                           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The compensated distance.                                          */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The TrueType specification says very few about the relationship    */
  /*    between rounding and engine compensation.  However, it seems from  */
  /*    the description of super round that we should add the compensation */
  /*    before rounding.                                                   */
  /*                                                                       */
  static FT_F26Dot6
  Round_None( TT_ExecContext  exc,
              FT_F26Dot6      distance,
              FT_F26Dot6      compensation )
  {
    FT_F26Dot6  val;

    FT_UNUSED( exc );


    if ( distance >= 0 )
    {
      val = distance + compensation;
      if ( val < 0 )
        val = 0;
    }
    else
    {
      val = distance - compensation;
      if ( val > 0 )
        val = 0;
    }
    return val;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Round_To_Grid                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Rounds value to grid after adding engine compensation.             */
  /*                                                                       */
  /* <Input>                                                               */
  /*    distance     :: The distance to round.                             */
  /*                                                                       */
  /*    compensation :: The engine compensation.                           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Rounded distance.                                                  */
  /*                                                                       */
  static FT_F26Dot6
  Round_To_Grid( TT_ExecContext  exc,
                 FT_F26Dot6      distance,
                 FT_F26Dot6      compensation )
  {
    FT_F26Dot6  val;

    FT_UNUSED( exc );


    if ( distance >= 0 )
    {
      val = FT_PIX_ROUND( distance + compensation );
      if ( val < 0 )
        val = 0;
    }
    else
    {
      val = -FT_PIX_ROUND( compensation - distance );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Round_To_Half_Grid                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Rounds value to half grid after adding engine compensation.        */
  /*                                                                       */
  /* <Input>                                                               */
  /*    distance     :: The distance to round.                             */
  /*                                                                       */
  /*    compensation :: The engine compensation.                           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Rounded distance.                                                  */
  /*                                                                       */
  static FT_F26Dot6
  Round_To_Half_Grid( TT_ExecContext  exc,
                      FT_F26Dot6      distance,
                      FT_F26Dot6      compensation )
  {
    FT_F26Dot6  val;

    FT_UNUSED( exc );


    if ( distance >= 0 )
    {
      val = FT_PIX_FLOOR( distance + compensation ) + 32;
      if ( val < 0 )
        val = 32;
    }
    else
    {
      val = -( FT_PIX_FLOOR( compensation - distance ) + 32 );
      if ( val > 0 )
        val = -32;
    }

    return val;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Round_Down_To_Grid                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Rounds value down to grid after adding engine compensation.        */
  /*                                                                       */
  /* <Input>                                                               */
  /*    distance     :: The distance to round.                             */
  /*                                                                       */
  /*    compensation :: The engine compensation.                           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Rounded distance.                                                  */
  /*                                                                       */
  static FT_F26Dot6
  Round_Down_To_Grid( TT_ExecContext  exc,
                      FT_F26Dot6      distance,
                      FT_F26Dot6      compensation )
  {
    FT_F26Dot6  val;

    FT_UNUSED( exc );


    if ( distance >= 0 )
    {
      val = FT_PIX_FLOOR( distance + compensation );
      if ( val < 0 )
        val = 0;
    }
    else
    {
      val = -FT_PIX_FLOOR( compensation - distance );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Round_Up_To_Grid                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Rounds value up to grid after adding engine compensation.          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    distance     :: The distance to round.                             */
  /*                                                                       */
  /*    compensation :: The engine compensation.                           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Rounded distance.                                                  */
  /*                                                                       */
  static FT_F26Dot6
  Round_Up_To_Grid( TT_ExecContext  exc,
                    FT_F26Dot6      distance,
                    FT_F26Dot6      compensation )
  {
    FT_F26Dot6  val;

    FT_UNUSED( exc );


    if ( distance >= 0 )
    {
      val = FT_PIX_CEIL( distance + compensation );
      if ( val < 0 )
        val = 0;
    }
    else
    {
      val = -FT_PIX_CEIL( compensation - distance );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Round_To_Double_Grid                                               */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Rounds value to double grid after adding engine compensation.      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    distance     :: The distance to round.                             */
  /*                                                                       */
  /*    compensation :: The engine compensation.                           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Rounded distance.                                                  */
  /*                                                                       */
  static FT_F26Dot6
  Round_To_Double_Grid( TT_ExecContext  exc,
                        FT_F26Dot6      distance,
                        FT_F26Dot6      compensation )
  {
    FT_F26Dot6  val;

    FT_UNUSED( exc );


    if ( distance >= 0 )
    {
      val = FT_PAD_ROUND( distance + compensation, 32 );
      if ( val < 0 )
        val = 0;
    }
    else
    {
      val = -FT_PAD_ROUND( compensation - distance, 32 );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Round_Super                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Super-rounds value to grid after adding engine compensation.       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    distance     :: The distance to round.                             */
  /*                                                                       */
  /*    compensation :: The engine compensation.                           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Rounded distance.                                                  */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The TrueType specification says very little about the relationship */
  /*    between rounding and engine compensation.  However, it seems from  */
  /*    the description of super round that we should add the compensation */
  /*    before rounding.                                                   */
  /*                                                                       */
  static FT_F26Dot6
  Round_Super( TT_ExecContext  exc,
               FT_F26Dot6      distance,
               FT_F26Dot6      compensation )
  {
    FT_F26Dot6  val;


    if ( distance >= 0 )
    {
      val = ( distance - exc->phase + exc->threshold + compensation ) &
              -exc->period;
      val += exc->phase;
      if ( val < 0 )
        val = exc->phase;
    }
    else
    {
      val = -( ( exc->threshold - exc->phase - distance + compensation ) &
               -exc->period );
      val -= exc->phase;
      if ( val > 0 )
        val = -exc->phase;
    }

    return val;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Round_Super_45                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Super-rounds value to grid after adding engine compensation.       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    distance     :: The distance to round.                             */
  /*                                                                       */
  /*    compensation :: The engine compensation.                           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Rounded distance.                                                  */
  /*                                                                       */
  /* <Note>                                                                */
  /*    There is a separate function for Round_Super_45() as we may need   */
  /*    greater precision.                                                 */
  /*                                                                       */
  static FT_F26Dot6
  Round_Super_45( TT_ExecContext  exc,
                  FT_F26Dot6      distance,
                  FT_F26Dot6      compensation )
  {
    FT_F26Dot6  val;


    if ( distance >= 0 )
    {
      val = ( ( distance - exc->phase + exc->threshold + compensation ) /
                exc->period ) * exc->period;
      val += exc->phase;
      if ( val < 0 )
        val = exc->phase;
    }
    else
    {
      val = -( ( ( exc->threshold - exc->phase - distance + compensation ) /
                   exc->period ) * exc->period );
      val -= exc->phase;
      if ( val > 0 )
        val = -exc->phase;
    }

    return val;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Compute_Round                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Sets the rounding mode.                                            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    round_mode :: The rounding mode to be used.                        */
  /*                                                                       */
  static void
  Compute_Round( TT_ExecContext  exc,
                 FT_Byte         round_mode )
  {
    switch ( round_mode )
    {
    case TT_Round_Off:
      exc->func_round = (TT_Round_Func)Round_None;
      break;

    case TT_Round_To_Grid:
      exc->func_round = (TT_Round_Func)Round_To_Grid;
      break;

    case TT_Round_Up_To_Grid:
      exc->func_round = (TT_Round_Func)Round_Up_To_Grid;
      break;

    case TT_Round_Down_To_Grid:
      exc->func_round = (TT_Round_Func)Round_Down_To_Grid;
      break;

    case TT_Round_To_Half_Grid:
      exc->func_round = (TT_Round_Func)Round_To_Half_Grid;
      break;

    case TT_Round_To_Double_Grid:
      exc->func_round = (TT_Round_Func)Round_To_Double_Grid;
      break;

    case TT_Round_Super:
      exc->func_round = (TT_Round_Func)Round_Super;
      break;

    case TT_Round_Super_45:
      exc->func_round = (TT_Round_Func)Round_Super_45;
      break;
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    SetSuperRound                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Sets Super Round parameters.                                       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    GridPeriod :: The grid period.                                     */
  /*                                                                       */
  /*    selector   :: The SROUND opcode.                                   */
  /*                                                                       */
  static void
  SetSuperRound( TT_ExecContext  exc,
                 FT_F2Dot14      GridPeriod,
                 FT_Long         selector )
  {
    switch ( (FT_Int)( selector & 0xC0 ) )
    {
      case 0:
        exc->period = GridPeriod / 2;
        break;

      case 0x40:
        exc->period = GridPeriod;
        break;

      case 0x80:
        exc->period = GridPeriod * 2;
        break;

      /* This opcode is reserved, but... */
      case 0xC0:
        exc->period = GridPeriod;
        break;
    }

    switch ( (FT_Int)( selector & 0x30 ) )
    {
    case 0:
      exc->phase = 0;
      break;

    case 0x10:
      exc->phase = exc->period / 4;
      break;

    case 0x20:
      exc->phase = exc->period / 2;
      break;

    case 0x30:
      exc->phase = exc->period * 3 / 4;
      break;
    }

    if ( ( selector & 0x0F ) == 0 )
      exc->threshold = exc->period - 1;
    else
      exc->threshold = ( (FT_Int)( selector & 0x0F ) - 4 ) * exc->period / 8;

    /* convert to F26Dot6 format */
    exc->period    >>= 8;
    exc->phase     >>= 8;
    exc->threshold >>= 8;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Project                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Computes the projection of vector given by (v2-v1) along the       */
  /*    current projection vector.                                         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    v1 :: First input vector.                                          */
  /*    v2 :: Second input vector.                                         */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The distance in F26dot6 format.                                    */
  /*                                                                       */
  static FT_F26Dot6
  Project( TT_ExecContext  exc,
           FT_Pos          dx,
           FT_Pos          dy )
  {
    return TT_DotFix14( dx, dy,
                        exc->GS.projVector.x,
                        exc->GS.projVector.y );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Dual_Project                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Computes the projection of the vector given by (v2-v1) along the   */
  /*    current dual vector.                                               */
  /*                                                                       */
  /* <Input>                                                               */
  /*    v1 :: First input vector.                                          */
  /*    v2 :: Second input vector.                                         */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The distance in F26dot6 format.                                    */
  /*                                                                       */
  static FT_F26Dot6
  Dual_Project( TT_ExecContext  exc,
                FT_Pos          dx,
                FT_Pos          dy )
  {
    return TT_DotFix14( dx, dy,
                        exc->GS.dualVector.x,
                        exc->GS.dualVector.y );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Project_x                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Computes the projection of the vector given by (v2-v1) along the   */
  /*    horizontal axis.                                                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    v1 :: First input vector.                                          */
  /*    v2 :: Second input vector.                                         */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The distance in F26dot6 format.                                    */
  /*                                                                       */
  static FT_F26Dot6
  Project_x( TT_ExecContext  exc,
             FT_Pos          dx,
             FT_Pos          dy )
  {
    FT_UNUSED( exc );
    FT_UNUSED( dy );

    return dx;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Project_y                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Computes the projection of the vector given by (v2-v1) along the   */
  /*    vertical axis.                                                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    v1 :: First input vector.                                          */
  /*    v2 :: Second input vector.                                         */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The distance in F26dot6 format.                                    */
  /*                                                                       */
  static FT_F26Dot6
  Project_y( TT_ExecContext  exc,
             FT_Pos          dx,
             FT_Pos          dy )
  {
    FT_UNUSED( exc );
    FT_UNUSED( dx );

    return dy;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Compute_Funcs                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Computes the projection and movement function pointers according   */
  /*    to the current graphics state.                                     */
  /*                                                                       */
  static void
  Compute_Funcs( TT_ExecContext  exc )
  {
    if ( exc->GS.freeVector.x == 0x4000 )
      exc->F_dot_P = exc->GS.projVector.x;
    else if ( exc->GS.freeVector.y == 0x4000 )
      exc->F_dot_P = exc->GS.projVector.y;
    else
      exc->F_dot_P =
        ( (FT_Long)exc->GS.projVector.x * exc->GS.freeVector.x +
          (FT_Long)exc->GS.projVector.y * exc->GS.freeVector.y ) >> 14;

    if ( exc->GS.projVector.x == 0x4000 )
      exc->func_project = (TT_Project_Func)Project_x;
    else if ( exc->GS.projVector.y == 0x4000 )
      exc->func_project = (TT_Project_Func)Project_y;
    else
      exc->func_project = (TT_Project_Func)Project;

    if ( exc->GS.dualVector.x == 0x4000 )
      exc->func_dualproj = (TT_Project_Func)Project_x;
    else if ( exc->GS.dualVector.y == 0x4000 )
      exc->func_dualproj = (TT_Project_Func)Project_y;
    else
      exc->func_dualproj = (TT_Project_Func)Dual_Project;

    exc->func_move      = (TT_Move_Func)Direct_Move;
    exc->func_move_orig = (TT_Move_Func)Direct_Move_Orig;

    if ( exc->F_dot_P == 0x4000L )
    {
      if ( exc->GS.freeVector.x == 0x4000 )
      {
        exc->func_move      = (TT_Move_Func)Direct_Move_X;
        exc->func_move_orig = (TT_Move_Func)Direct_Move_Orig_X;
      }
      else if ( exc->GS.freeVector.y == 0x4000 )
      {
        exc->func_move      = (TT_Move_Func)Direct_Move_Y;
        exc->func_move_orig = (TT_Move_Func)Direct_Move_Orig_Y;
      }
    }

    /* at small sizes, F_dot_P can become too small, resulting   */
    /* in overflows and `spikes' in a number of glyphs like `w'. */

    if ( FT_ABS( exc->F_dot_P ) < 0x400L )
      exc->F_dot_P = 0x4000L;

    /* Disable cached aspect ratio */
    exc->tt_metrics.ratio = 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Normalize                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Norms a vector.                                                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    Vx :: The horizontal input vector coordinate.                      */
  /*    Vy :: The vertical input vector coordinate.                        */
  /*                                                                       */
  /* <Output>                                                              */
  /*    R  :: The normed unit vector.                                      */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Returns FAILURE if a vector parameter is zero.                     */
  /*                                                                       */
  /* <Note>                                                                */
  /*    In case Vx and Vy are both zero, `Normalize' returns SUCCESS, and  */
  /*    R is undefined.                                                    */
  /*                                                                       */
  static FT_Bool
  Normalize( FT_F26Dot6      Vx,
             FT_F26Dot6      Vy,
             FT_UnitVector*  R )
  {
    FT_Vector V;


    if ( Vx == 0 && Vy == 0 )
    {
      /* XXX: UNDOCUMENTED! It seems that it is possible to try   */
      /*      to normalize the vector (0,0).  Return immediately. */
      return SUCCESS;
    }

    V.x = Vx;
    V.y = Vy;

    FT_Vector_NormLen( &V );

    R->x = (FT_F2Dot14)( V.x / 4 );
    R->y = (FT_F2Dot14)( V.y / 4 );

    return SUCCESS;
  }


  /*************************************************************************/
  /*                                                                       */
  /* Here we start with the implementation of the various opcodes.         */
  /*                                                                       */
  /*************************************************************************/


#define ARRAY_BOUND_ERROR                         \
    do                                            \
    {                                             \
      exc->error = FT_THROW( Invalid_Reference ); \
      return;                                     \
    } while (0)


  /*************************************************************************/
  /*                                                                       */
  /* MPPEM[]:      Measure Pixel Per EM                                    */
  /* Opcode range: 0x4B                                                    */
  /* Stack:        --> Euint16                                             */
  /*                                                                       */
  static void
  Ins_MPPEM( TT_ExecContext  exc,
             FT_Long*        args )
  {
    args[0] = exc->func_cur_ppem( exc );
  }


  /*************************************************************************/
  /*                                                                       */
  /* MPS[]:        Measure Point Size                                      */
  /* Opcode range: 0x4C                                                    */
  /* Stack:        --> Euint16                                             */
  /*                                                                       */
  static void
  Ins_MPS( TT_ExecContext  exc,
           FT_Long*        args )
  {
    if ( NO_SUBPIXEL_HINTING )
    {
      /* Microsoft's GDI bytecode interpreter always returns value 12; */
      /* we return the current PPEM value instead.                     */
      args[0] = exc->func_cur_ppem( exc );
    }
    else
    {
      /* A possible practical application of the MPS instruction is to   */
      /* implement optical scaling and similar features, which should be */
      /* based on perceptual attributes, thus independent of the         */
      /* resolution.                                                     */
      args[0] = exc->pointSize;
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* DUP[]:        DUPlicate the stack's top element                       */
  /* Opcode range: 0x20                                                    */
  /* Stack:        StkElt --> StkElt StkElt                                */
  /*                                                                       */
  static void
  Ins_DUP( FT_Long*  args )
  {
    args[1] = args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* POP[]:        POP the stack's top element                             */
  /* Opcode range: 0x21                                                    */
  /* Stack:        StkElt -->                                              */
  /*                                                                       */
  static void
  Ins_POP( void )
  {
    /* nothing to do */
  }


  /*************************************************************************/
  /*                                                                       */
  /* CLEAR[]:      CLEAR the entire stack                                  */
  /* Opcode range: 0x22                                                    */
  /* Stack:        StkElt... -->                                           */
  /*                                                                       */
  static void
  Ins_CLEAR( TT_ExecContext  exc )
  {
    exc->new_top = 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* SWAP[]:       SWAP the stack's top two elements                       */
  /* Opcode range: 0x23                                                    */
  /* Stack:        2 * StkElt --> 2 * StkElt                               */
  /*                                                                       */
  static void
  Ins_SWAP( FT_Long*  args )
  {
    FT_Long  L;


    L       = args[0];
    args[0] = args[1];
    args[1] = L;
  }


  /*************************************************************************/
  /*                                                                       */
  /* DEPTH[]:      return the stack DEPTH                                  */
  /* Opcode range: 0x24                                                    */
  /* Stack:        --> uint32                                              */
  /*                                                                       */
  static void
  Ins_DEPTH( TT_ExecContext  exc,
             FT_Long*        args )
  {
    args[0] = exc->top;
  }


  /*************************************************************************/
  /*                                                                       */
  /* LT[]:         Less Than                                               */
  /* Opcode range: 0x50                                                    */
  /* Stack:        int32? int32? --> bool                                  */
  /*                                                                       */
  static void
  Ins_LT( FT_Long*  args )
  {
    args[0] = ( args[0] < args[1] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* LTEQ[]:       Less Than or EQual                                      */
  /* Opcode range: 0x51                                                    */
  /* Stack:        int32? int32? --> bool                                  */
  /*                                                                       */
  static void
  Ins_LTEQ( FT_Long*  args )
  {
    args[0] = ( args[0] <= args[1] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* GT[]:         Greater Than                                            */
  /* Opcode range: 0x52                                                    */
  /* Stack:        int32? int32? --> bool                                  */
  /*                                                                       */
  static void
  Ins_GT( FT_Long*  args )
  {
    args[0] = ( args[0] > args[1] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* GTEQ[]:       Greater Than or EQual                                   */
  /* Opcode range: 0x53                                                    */
  /* Stack:        int32? int32? --> bool                                  */
  /*                                                                       */
  static void
  Ins_GTEQ( FT_Long*  args )
  {
    args[0] = ( args[0] >= args[1] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* EQ[]:         EQual                                                   */
  /* Opcode range: 0x54                                                    */
  /* Stack:        StkElt StkElt --> bool                                  */
  /*                                                                       */
  static void
  Ins_EQ( FT_Long*  args )
  {
    args[0] = ( args[0] == args[1] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* NEQ[]:        Not EQual                                               */
  /* Opcode range: 0x55                                                    */
  /* Stack:        StkElt StkElt --> bool                                  */
  /*                                                                       */
  static void
  Ins_NEQ( FT_Long*  args )
  {
    args[0] = ( args[0] != args[1] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* ODD[]:        Is ODD                                                  */
  /* Opcode range: 0x56                                                    */
  /* Stack:        f26.6 --> bool                                          */
  /*                                                                       */
  static void
  Ins_ODD( TT_ExecContext  exc,
           FT_Long*        args )
  {
    args[0] = ( ( exc->func_round( exc, args[0], 0 ) & 127 ) == 64 );
  }


  /*************************************************************************/
  /*                                                                       */
  /* EVEN[]:       Is EVEN                                                 */
  /* Opcode range: 0x57                                                    */
  /* Stack:        f26.6 --> bool                                          */
  /*                                                                       */
  static void
  Ins_EVEN( TT_ExecContext  exc,
            FT_Long*        args )
  {
    args[0] = ( ( exc->func_round( exc, args[0], 0 ) & 127 ) == 0 );
  }


  /*************************************************************************/
  /*                                                                       */
  /* AND[]:        logical AND                                             */
  /* Opcode range: 0x5A                                                    */
  /* Stack:        uint32 uint32 --> uint32                                */
  /*                                                                       */
  static void
  Ins_AND( FT_Long*  args )
  {
    args[0] = ( args[0] && args[1] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* OR[]:         logical OR                                              */
  /* Opcode range: 0x5B                                                    */
  /* Stack:        uint32 uint32 --> uint32                                */
  /*                                                                       */
  static void
  Ins_OR( FT_Long*  args )
  {
    args[0] = ( args[0] || args[1] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* NOT[]:        logical NOT                                             */
  /* Opcode range: 0x5C                                                    */
  /* Stack:        StkElt --> uint32                                       */
  /*                                                                       */
  static void
  Ins_NOT( FT_Long*  args )
  {
    args[0] = !args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* ADD[]:        ADD                                                     */
  /* Opcode range: 0x60                                                    */
  /* Stack:        f26.6 f26.6 --> f26.6                                   */
  /*                                                                       */
  static void
  Ins_ADD( FT_Long*  args )
  {
    args[0] += args[1];
  }


  /*************************************************************************/
  /*                                                                       */
  /* SUB[]:        SUBtract                                                */
  /* Opcode range: 0x61                                                    */
  /* Stack:        f26.6 f26.6 --> f26.6                                   */
  /*                                                                       */
  static void
  Ins_SUB( FT_Long*  args )
  {
    args[0] -= args[1];
  }


  /*************************************************************************/
  /*                                                                       */
  /* DIV[]:        DIVide                                                  */
  /* Opcode range: 0x62                                                    */
  /* Stack:        f26.6 f26.6 --> f26.6                                   */
  /*                                                                       */
  static void
  Ins_DIV( TT_ExecContext  exc,
           FT_Long*        args )
  {
    if ( args[1] == 0 )
      exc->error = FT_THROW( Divide_By_Zero );
    else
      args[0] = FT_MulDiv_No_Round( args[0], 64L, args[1] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* MUL[]:        MULtiply                                                */
  /* Opcode range: 0x63                                                    */
  /* Stack:        f26.6 f26.6 --> f26.6                                   */
  /*                                                                       */
  static void
  Ins_MUL( FT_Long*  args )
  {
    args[0] = FT_MulDiv( args[0], args[1], 64L );
  }


  /*************************************************************************/
  /*                                                                       */
  /* ABS[]:        ABSolute value                                          */
  /* Opcode range: 0x64                                                    */
  /* Stack:        f26.6 --> f26.6                                         */
  /*                                                                       */
  static void
  Ins_ABS( FT_Long*  args )
  {
    args[0] = FT_ABS( args[0] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* NEG[]:        NEGate                                                  */
  /* Opcode range: 0x65                                                    */
  /* Stack:        f26.6 --> f26.6                                         */
  /*                                                                       */
  static void
  Ins_NEG( FT_Long*  args )
  {
    args[0] = -args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* FLOOR[]:      FLOOR                                                   */
  /* Opcode range: 0x66                                                    */
  /* Stack:        f26.6 --> f26.6                                         */
  /*                                                                       */
  static void
  Ins_FLOOR( FT_Long*  args )
  {
    args[0] = FT_PIX_FLOOR( args[0] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* CEILING[]:    CEILING                                                 */
  /* Opcode range: 0x67                                                    */
  /* Stack:        f26.6 --> f26.6                                         */
  /*                                                                       */
  static void
  Ins_CEILING( FT_Long*  args )
  {
    args[0] = FT_PIX_CEIL( args[0] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* RS[]:         Read Store                                              */
  /* Opcode range: 0x43                                                    */
  /* Stack:        uint32 --> uint32                                       */
  /*                                                                       */
  static void
  Ins_RS( TT_ExecContext  exc,
          FT_Long*        args )
  {
    FT_ULong  I = (FT_ULong)args[0];


    if ( BOUNDSL( I, exc->storeSize ) )
    {
      if ( exc->pedantic_hinting )
        ARRAY_BOUND_ERROR;
      else
        args[0] = 0;
    }
    else
    {
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      /* subpixel hinting - avoid Typeman Dstroke and */
      /* IStroke and Vacuform rounds                  */
      if ( SUBPIXEL_HINTING_INFINALITY                 &&
           exc->ignore_x_mode                          &&
           ( ( I == 24                             &&
               ( exc->face->sph_found_func_flags &
                 ( SPH_FDEF_SPACING_1 |
                   SPH_FDEF_SPACING_2 )          ) ) ||
             ( I == 22                      &&
               ( exc->sph_in_func_flags   &
                 SPH_FDEF_TYPEMAN_STROKES ) )        ||
             ( I == 8                              &&
               ( exc->face->sph_found_func_flags &
                 SPH_FDEF_VACUFORM_ROUND_1       ) &&
               exc->iup_called                     ) ) )
        args[0] = 0;
      else
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
        args[0] = exc->storage[I];
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* WS[]:         Write Store                                             */
  /* Opcode range: 0x42                                                    */
  /* Stack:        uint32 uint32 -->                                       */
  /*                                                                       */
  static void
  Ins_WS( TT_ExecContext  exc,
          FT_Long*        args )
  {
    FT_ULong  I = (FT_ULong)args[0];


    if ( BOUNDSL( I, exc->storeSize ) )
    {
      if ( exc->pedantic_hinting )
        ARRAY_BOUND_ERROR;
    }
    else
      exc->storage[I] = args[1];
  }


  /*************************************************************************/
  /*                                                                       */
  /* WCVTP[]:      Write CVT in Pixel units                                */
  /* Opcode range: 0x44                                                    */
  /* Stack:        f26.6 uint32 -->                                        */
  /*                                                                       */
  static void
  Ins_WCVTP( TT_ExecContext  exc,
             FT_Long*        args )
  {
    FT_ULong  I = (FT_ULong)args[0];


    if ( BOUNDSL( I, exc->cvtSize ) )
    {
      if ( exc->pedantic_hinting )
        ARRAY_BOUND_ERROR;
    }
    else
      exc->func_write_cvt( exc, I, args[1] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* WCVTF[]:      Write CVT in Funits                                     */
  /* Opcode range: 0x70                                                    */
  /* Stack:        uint32 uint32 -->                                       */
  /*                                                                       */
  static void
  Ins_WCVTF( TT_ExecContext  exc,
             FT_Long*        args )
  {
    FT_ULong  I = (FT_ULong)args[0];


    if ( BOUNDSL( I, exc->cvtSize ) )
    {
      if ( exc->pedantic_hinting )
        ARRAY_BOUND_ERROR;
    }
    else
      exc->cvt[I] = FT_MulFix( args[1], exc->tt_metrics.scale );
  }


  /*************************************************************************/
  /*                                                                       */
  /* RCVT[]:       Read CVT                                                */
  /* Opcode range: 0x45                                                    */
  /* Stack:        uint32 --> f26.6                                        */
  /*                                                                       */
  static void
  Ins_RCVT( TT_ExecContext  exc,
            FT_Long*        args )
  {
    FT_ULong  I = (FT_ULong)args[0];


    if ( BOUNDSL( I, exc->cvtSize ) )
    {
      if ( exc->pedantic_hinting )
        ARRAY_BOUND_ERROR;
      else
        args[0] = 0;
    }
    else
      args[0] = exc->func_read_cvt( exc, I );
  }


  /*************************************************************************/
  /*                                                                       */
  /* AA[]:         Adjust Angle                                            */
  /* Opcode range: 0x7F                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_AA( void )
  {
    /* intentionally no longer supported */
  }


  /*************************************************************************/
  /*                                                                       */
  /* DEBUG[]:      DEBUG.  Unsupported.                                    */
  /* Opcode range: 0x4F                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  /* Note: The original instruction pops a value from the stack.           */
  /*                                                                       */
  static void
  Ins_DEBUG( TT_ExecContext  exc )
  {
    exc->error = FT_THROW( Debug_OpCode );
  }


  /*************************************************************************/
  /*                                                                       */
  /* ROUND[ab]:    ROUND value                                             */
  /* Opcode range: 0x68-0x6B                                               */
  /* Stack:        f26.6 --> f26.6                                         */
  /*                                                                       */
  static void
  Ins_ROUND( TT_ExecContext  exc,
             FT_Long*        args )
  {
    args[0] = exc->func_round(
                exc,
                args[0],
                exc->tt_metrics.compensations[exc->opcode - 0x68] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* NROUND[ab]:   No ROUNDing of value                                    */
  /* Opcode range: 0x6C-0x6F                                               */
  /* Stack:        f26.6 --> f26.6                                         */
  /*                                                                       */
  static void
  Ins_NROUND( TT_ExecContext  exc,
              FT_Long*        args )
  {
    args[0] = Round_None(
                exc,
                args[0],
                exc->tt_metrics.compensations[exc->opcode - 0x6C] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* MAX[]:        MAXimum                                                 */
  /* Opcode range: 0x8B                                                    */
  /* Stack:        int32? int32? --> int32                                 */
  /*                                                                       */
  static void
  Ins_MAX( FT_Long*  args )
  {
    if ( args[1] > args[0] )
      args[0] = args[1];
  }


  /*************************************************************************/
  /*                                                                       */
  /* MIN[]:        MINimum                                                 */
  /* Opcode range: 0x8C                                                    */
  /* Stack:        int32? int32? --> int32                                 */
  /*                                                                       */
  static void
  Ins_MIN( FT_Long*  args )
  {
    if ( args[1] < args[0] )
      args[0] = args[1];
  }


  /*************************************************************************/
  /*                                                                       */
  /* MINDEX[]:     Move INDEXed element                                    */
  /* Opcode range: 0x26                                                    */
  /* Stack:        int32? --> StkElt                                       */
  /*                                                                       */
  static void
  Ins_MINDEX( TT_ExecContext  exc,
              FT_Long*        args )
  {
    FT_Long  L, K;


    L = args[0];

    if ( L <= 0 || L > exc->args )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
    }
    else
    {
      K = exc->stack[exc->args - L];

      FT_ARRAY_MOVE( &exc->stack[exc->args - L    ],
                     &exc->stack[exc->args - L + 1],
                     ( L - 1 ) );

      exc->stack[exc->args - 1] = K;
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* CINDEX[]:     Copy INDEXed element                                    */
  /* Opcode range: 0x25                                                    */
  /* Stack:        int32 --> StkElt                                        */
  /*                                                                       */
  static void
  Ins_CINDEX( TT_ExecContext  exc,
              FT_Long*        args )
  {
    FT_Long  L;


    L = args[0];

    if ( L <= 0 || L > exc->args )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      args[0] = 0;
    }
    else
      args[0] = exc->stack[exc->args - L];
  }


  /*************************************************************************/
  /*                                                                       */
  /* ROLL[]:       ROLL top three elements                                 */
  /* Opcode range: 0x8A                                                    */
  /* Stack:        3 * StkElt --> 3 * StkElt                               */
  /*                                                                       */
  static void
  Ins_ROLL( FT_Long*  args )
  {
    FT_Long  A, B, C;


    A = args[2];
    B = args[1];
    C = args[0];

    args[2] = C;
    args[1] = A;
    args[0] = B;
  }


  /*************************************************************************/
  /*                                                                       */
  /* MANAGING THE FLOW OF CONTROL                                          */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* SLOOP[]:      Set LOOP variable                                       */
  /* Opcode range: 0x17                                                    */
  /* Stack:        int32? -->                                              */
  /*                                                                       */
  static void
  Ins_SLOOP( TT_ExecContext  exc,
             FT_Long*        args )
  {
    if ( args[0] < 0 )
      exc->error = FT_THROW( Bad_Argument );
    else
      exc->GS.loop = args[0];
  }


  static FT_Bool
  SkipCode( TT_ExecContext  exc )
  {
    exc->IP += exc->length;

    if ( exc->IP < exc->codeSize )
    {
      exc->opcode = exc->code[exc->IP];

      exc->length = opcode_length[exc->opcode];
      if ( exc->length < 0 )
      {
        if ( exc->IP + 1 >= exc->codeSize )
          goto Fail_Overflow;
        exc->length = 2 - exc->length * exc->code[exc->IP + 1];
      }

      if ( exc->IP + exc->length <= exc->codeSize )
        return SUCCESS;
    }

  Fail_Overflow:
    exc->error = FT_THROW( Code_Overflow );
    return FAILURE;
  }


  /*************************************************************************/
  /*                                                                       */
  /* IF[]:         IF test                                                 */
  /* Opcode range: 0x58                                                    */
  /* Stack:        StkElt -->                                              */
  /*                                                                       */
  static void
  Ins_IF( TT_ExecContext  exc,
          FT_Long*        args )
  {
    FT_Int   nIfs;
    FT_Bool  Out;


    if ( args[0] != 0 )
      return;

    nIfs = 1;
    Out = 0;

    do
    {
      if ( SkipCode( exc ) == FAILURE )
        return;

      switch ( exc->opcode )
      {
      case 0x58:      /* IF */
        nIfs++;
        break;

      case 0x1B:      /* ELSE */
        Out = FT_BOOL( nIfs == 1 );
        break;

      case 0x59:      /* EIF */
        nIfs--;
        Out = FT_BOOL( nIfs == 0 );
        break;
      }
    } while ( Out == 0 );
  }


  /*************************************************************************/
  /*                                                                       */
  /* ELSE[]:       ELSE                                                    */
  /* Opcode range: 0x1B                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_ELSE( TT_ExecContext  exc )
  {
    FT_Int  nIfs;


    nIfs = 1;

    do
    {
      if ( SkipCode( exc ) == FAILURE )
        return;

      switch ( exc->opcode )
      {
      case 0x58:    /* IF */
        nIfs++;
        break;

      case 0x59:    /* EIF */
        nIfs--;
        break;
      }
    } while ( nIfs != 0 );
  }


  /*************************************************************************/
  /*                                                                       */
  /* EIF[]:        End IF                                                  */
  /* Opcode range: 0x59                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_EIF( void )
  {
    /* nothing to do */
  }


  /*************************************************************************/
  /*                                                                       */
  /* JMPR[]:       JuMP Relative                                           */
  /* Opcode range: 0x1C                                                    */
  /* Stack:        int32 -->                                               */
  /*                                                                       */
  static void
  Ins_JMPR( TT_ExecContext  exc,
            FT_Long*        args )
  {
    if ( args[0] == 0 && exc->args == 0 )
    {
      exc->error = FT_THROW( Bad_Argument );
      return;
    }

    exc->IP += args[0];
    if ( exc->IP < 0                                             ||
         ( exc->callTop > 0                                    &&
           exc->IP > exc->callStack[exc->callTop - 1].Def->end ) )
    {
      exc->error = FT_THROW( Bad_Argument );
      return;
    }

    exc->step_ins = FALSE;

    if ( args[0] < 0 )
    {
      if ( ++exc->neg_jump_counter > exc->neg_jump_counter_max )
        exc->error = FT_THROW( Execution_Too_Long );
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* JROT[]:       Jump Relative On True                                   */
  /* Opcode range: 0x78                                                    */
  /* Stack:        StkElt int32 -->                                        */
  /*                                                                       */
  static void
  Ins_JROT( TT_ExecContext  exc,
            FT_Long*        args )
  {
    if ( args[1] != 0 )
      Ins_JMPR( exc, args );
  }


  /*************************************************************************/
  /*                                                                       */
  /* JROF[]:       Jump Relative On False                                  */
  /* Opcode range: 0x79                                                    */
  /* Stack:        StkElt int32 -->                                        */
  /*                                                                       */
  static void
  Ins_JROF( TT_ExecContext  exc,
            FT_Long*        args )
  {
    if ( args[1] == 0 )
      Ins_JMPR( exc, args );
  }


  /*************************************************************************/
  /*                                                                       */
  /* DEFINING AND USING FUNCTIONS AND INSTRUCTIONS                         */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* FDEF[]:       Function DEFinition                                     */
  /* Opcode range: 0x2C                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_FDEF( TT_ExecContext  exc,
            FT_Long*        args )
  {
    FT_ULong       n;
    TT_DefRecord*  rec;
    TT_DefRecord*  limit;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    /* arguments to opcodes are skipped by `SKIP_Code' */
    FT_Byte    opcode_pattern[9][12] = {
                 /* #0 inline delta function 1 */
                 {
                   0x4B, /* PPEM    */
                   0x53, /* GTEQ    */
                   0x23, /* SWAP    */
                   0x4B, /* PPEM    */
                   0x51, /* LTEQ    */
                   0x5A, /* AND     */
                   0x58, /* IF      */
                   0x38, /*   SHPIX */
                   0x1B, /* ELSE    */
                   0x21, /*   POP   */
                   0x21, /*   POP   */
                   0x59  /* EIF     */
                 },
                 /* #1 inline delta function 2 */
                 {
                   0x4B, /* PPEM    */
                   0x54, /* EQ      */
                   0x58, /* IF      */
                   0x38, /*   SHPIX */
                   0x1B, /* ELSE    */
                   0x21, /*   POP   */
                   0x21, /*   POP   */
                   0x59  /* EIF     */
                 },
                 /* #2 diagonal stroke function */
                 {
                   0x20, /* DUP     */
                   0x20, /* DUP     */
                   0xB0, /* PUSHB_1 */
                         /*   1     */
                   0x60, /* ADD     */
                   0x46, /* GC_cur  */
                   0xB0, /* PUSHB_1 */
                         /*   64    */
                   0x23, /* SWAP    */
                   0x42  /* WS      */
                 },
                 /* #3 VacuFormRound function */
                 {
                   0x45, /* RCVT    */
                   0x23, /* SWAP    */
                   0x46, /* GC_cur  */
                   0x60, /* ADD     */
                   0x20, /* DUP     */
                   0xB0  /* PUSHB_1 */
                         /*   38    */
                 },
                 /* #4 TTFautohint bytecode (old) */
                 {
                   0x20, /* DUP     */
                   0x64, /* ABS     */
                   0xB0, /* PUSHB_1 */
                         /*   32    */
                   0x60, /* ADD     */
                   0x66, /* FLOOR   */
                   0x23, /* SWAP    */
                   0xB0  /* PUSHB_1 */
                 },
                 /* #5 spacing function 1 */
                 {
                   0x01, /* SVTCA_x */
                   0xB0, /* PUSHB_1 */
                         /*   24    */
                   0x43, /* RS      */
                   0x58  /* IF      */
                 },
                 /* #6 spacing function 2 */
                 {
                   0x01, /* SVTCA_x */
                   0x18, /* RTG     */
                   0xB0, /* PUSHB_1 */
                         /*   24    */
                   0x43, /* RS      */
                   0x58  /* IF      */
                 },
                 /* #7 TypeMan Talk DiagEndCtrl function */
                 {
                   0x01, /* SVTCA_x */
                   0x20, /* DUP     */
                   0xB0, /* PUSHB_1 */
                         /*   3     */
                   0x25, /* CINDEX  */
                 },
                 /* #8 TypeMan Talk Align */
                 {
                   0x06, /* SPVTL   */
                   0x7D, /* RDTG    */
                 },
               };
    FT_UShort  opcode_patterns   = 9;
    FT_UShort  opcode_pointer[9] = {  0, 0, 0, 0, 0, 0, 0, 0, 0 };
    FT_UShort  opcode_size[9]    = { 12, 8, 8, 6, 7, 4, 5, 4, 2 };
    FT_UShort  i;
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */


    /* FDEF is only allowed in `prep' or `fpgm' */
    if ( exc->curRange == tt_coderange_glyph )
    {
      exc->error = FT_THROW( DEF_In_Glyf_Bytecode );
      return;
    }

    /* some font programs are broken enough to redefine functions! */
    /* We will then parse the current table.                       */

    rec   = exc->FDefs;
    limit = rec + exc->numFDefs;
    n     = (FT_ULong)args[0];

    for ( ; rec < limit; rec++ )
    {
      if ( rec->opc == n )
        break;
    }

    if ( rec == limit )
    {
      /* check that there is enough room for new functions */
      if ( exc->numFDefs >= exc->maxFDefs )
      {
        exc->error = FT_THROW( Too_Many_Function_Defs );
        return;
      }
      exc->numFDefs++;
    }

    /* Although FDEF takes unsigned 32-bit integer,  */
    /* func # must be within unsigned 16-bit integer */
    if ( n > 0xFFFFU )
    {
      exc->error = FT_THROW( Too_Many_Function_Defs );
      return;
    }

    rec->range          = exc->curRange;
    rec->opc            = (FT_UInt16)n;
    rec->start          = exc->IP + 1;
    rec->active         = TRUE;
    rec->inline_delta   = FALSE;
    rec->sph_fdef_flags = 0x0000;

    if ( n > exc->maxFunc )
      exc->maxFunc = (FT_UInt16)n;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    /* We don't know for sure these are typeman functions, */
    /* however they are only active when RS 22 is called   */
    if ( n >= 64 && n <= 66 )
      rec->sph_fdef_flags |= SPH_FDEF_TYPEMAN_STROKES;
#endif

    /* Now skip the whole function definition. */
    /* We don't allow nested IDEFS & FDEFs.    */

    while ( SkipCode( exc ) == SUCCESS )
    {

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( SUBPIXEL_HINTING_INFINALITY )
      {
        for ( i = 0; i < opcode_patterns; i++ )
        {
          if ( opcode_pointer[i] < opcode_size[i]                  &&
               exc->opcode == opcode_pattern[i][opcode_pointer[i]] )
          {
            opcode_pointer[i] += 1;

            if ( opcode_pointer[i] == opcode_size[i] )
            {
              FT_TRACE6(( "sph: Function %d, opcode ptrn: %d, %s %s\n",
                          i, n,
                          exc->face->root.family_name,
                          exc->face->root.style_name ));

              switch ( i )
              {
              case 0:
                rec->sph_fdef_flags             |= SPH_FDEF_INLINE_DELTA_1;
                exc->face->sph_found_func_flags |= SPH_FDEF_INLINE_DELTA_1;
                break;

              case 1:
                rec->sph_fdef_flags             |= SPH_FDEF_INLINE_DELTA_2;
                exc->face->sph_found_func_flags |= SPH_FDEF_INLINE_DELTA_2;
                break;

              case 2:
                switch ( n )
                {
                  /* needs to be implemented still */
                case 58:
                  rec->sph_fdef_flags             |= SPH_FDEF_DIAGONAL_STROKE;
                  exc->face->sph_found_func_flags |= SPH_FDEF_DIAGONAL_STROKE;
                }
                break;

              case 3:
                switch ( n )
                {
                case 0:
                  rec->sph_fdef_flags             |= SPH_FDEF_VACUFORM_ROUND_1;
                  exc->face->sph_found_func_flags |= SPH_FDEF_VACUFORM_ROUND_1;
                }
                break;

              case 4:
                /* probably not necessary to detect anymore */
                rec->sph_fdef_flags             |= SPH_FDEF_TTFAUTOHINT_1;
                exc->face->sph_found_func_flags |= SPH_FDEF_TTFAUTOHINT_1;
                break;

              case 5:
                switch ( n )
                {
                case 0:
                case 1:
                case 2:
                case 4:
                case 7:
                case 8:
                  rec->sph_fdef_flags             |= SPH_FDEF_SPACING_1;
                  exc->face->sph_found_func_flags |= SPH_FDEF_SPACING_1;
                }
                break;

              case 6:
                switch ( n )
                {
                case 0:
                case 1:
                case 2:
                case 4:
                case 7:
                case 8:
                  rec->sph_fdef_flags             |= SPH_FDEF_SPACING_2;
                  exc->face->sph_found_func_flags |= SPH_FDEF_SPACING_2;
                }
                break;

               case 7:
                 rec->sph_fdef_flags             |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
                 exc->face->sph_found_func_flags |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
                 break;

               case 8:
#if 0
                 rec->sph_fdef_flags             |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
                 exc->face->sph_found_func_flags |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
#endif
                 break;
              }
              opcode_pointer[i] = 0;
            }
          }

          else
            opcode_pointer[i] = 0;
        }

        /* Set sph_compatibility_mode only when deltas are detected */
        exc->face->sph_compatibility_mode =
          ( ( exc->face->sph_found_func_flags & SPH_FDEF_INLINE_DELTA_1 ) |
            ( exc->face->sph_found_func_flags & SPH_FDEF_INLINE_DELTA_2 ) );
      }

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      switch ( exc->opcode )
      {
      case 0x89:    /* IDEF */
      case 0x2C:    /* FDEF */
        exc->error = FT_THROW( Nested_DEFS );
        return;

      case 0x2D:   /* ENDF */
        rec->end = exc->IP;
        return;
      }
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* ENDF[]:       END Function definition                                 */
  /* Opcode range: 0x2D                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_ENDF( TT_ExecContext  exc )
  {
    TT_CallRec*  pRec;


#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    exc->sph_in_func_flags = 0x0000;
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    if ( exc->callTop <= 0 )     /* We encountered an ENDF without a call */
    {
      exc->error = FT_THROW( ENDF_In_Exec_Stream );
      return;
    }

    exc->callTop--;

    pRec = &exc->callStack[exc->callTop];

    pRec->Cur_Count--;

    exc->step_ins = FALSE;

    if ( pRec->Cur_Count > 0 )
    {
      exc->callTop++;
      exc->IP = pRec->Def->start;
    }
    else
      /* Loop through the current function */
      Ins_Goto_CodeRange( exc, pRec->Caller_Range, pRec->Caller_IP );

    /* Exit the current call frame.                      */

    /* NOTE: If the last instruction of a program is a   */
    /*       CALL or LOOPCALL, the return address is     */
    /*       always out of the code range.  This is a    */
    /*       valid address, and it is why we do not test */
    /*       the result of Ins_Goto_CodeRange() here!    */
  }


  /*************************************************************************/
  /*                                                                       */
  /* CALL[]:       CALL function                                           */
  /* Opcode range: 0x2B                                                    */
  /* Stack:        uint32? -->                                             */
  /*                                                                       */
  static void
  Ins_CALL( TT_ExecContext  exc,
            FT_Long*        args )
  {
    FT_ULong       F;
    TT_CallRec*    pCrec;
    TT_DefRecord*  def;


    /* first of all, check the index */

    F = (FT_ULong)args[0];
    if ( BOUNDSL( F, exc->maxFunc + 1 ) )
      goto Fail;

    /* Except for some old Apple fonts, all functions in a TrueType */
    /* font are defined in increasing order, starting from 0.  This */
    /* means that we normally have                                  */
    /*                                                              */
    /*    exc->maxFunc+1 == exc->numFDefs                           */
    /*    exc->FDefs[n].opc == n for n in 0..exc->maxFunc           */
    /*                                                              */
    /* If this isn't true, we need to look up the function table.   */

    def = exc->FDefs + F;
    if ( exc->maxFunc + 1 != exc->numFDefs || def->opc != F )
    {
      /* look up the FDefs table */
      TT_DefRecord*  limit;


      def   = exc->FDefs;
      limit = def + exc->numFDefs;

      while ( def < limit && def->opc != F )
        def++;

      if ( def == limit )
        goto Fail;
    }

    /* check that the function is active */
    if ( !def->active )
      goto Fail;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( SUBPIXEL_HINTING_INFINALITY                                    &&
         exc->ignore_x_mode                                             &&
         ( ( exc->iup_called                                        &&
             ( exc->sph_tweak_flags & SPH_TWEAK_NO_CALL_AFTER_IUP ) ) ||
           ( def->sph_fdef_flags & SPH_FDEF_VACUFORM_ROUND_1 )        ) )
      goto Fail;
    else
      exc->sph_in_func_flags = def->sph_fdef_flags;
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    /* check the call stack */
    if ( exc->callTop >= exc->callSize )
    {
      exc->error = FT_THROW( Stack_Overflow );
      return;
    }

    pCrec = exc->callStack + exc->callTop;

    pCrec->Caller_Range = exc->curRange;
    pCrec->Caller_IP    = exc->IP + 1;
    pCrec->Cur_Count    = 1;
    pCrec->Def          = def;

    exc->callTop++;

    Ins_Goto_CodeRange( exc, def->range, def->start );

    exc->step_ins = FALSE;

    return;

  Fail:
    exc->error = FT_THROW( Invalid_Reference );
  }


  /*************************************************************************/
  /*                                                                       */
  /* LOOPCALL[]:   LOOP and CALL function                                  */
  /* Opcode range: 0x2A                                                    */
  /* Stack:        uint32? Eint16? -->                                     */
  /*                                                                       */
  static void
  Ins_LOOPCALL( TT_ExecContext  exc,
                FT_Long*        args )
  {
    FT_ULong       F;
    TT_CallRec*    pCrec;
    TT_DefRecord*  def;


    /* first of all, check the index */
    F = (FT_ULong)args[1];
    if ( BOUNDSL( F, exc->maxFunc + 1 ) )
      goto Fail;

    /* Except for some old Apple fonts, all functions in a TrueType */
    /* font are defined in increasing order, starting from 0.  This */
    /* means that we normally have                                  */
    /*                                                              */
    /*    exc->maxFunc+1 == exc->numFDefs                           */
    /*    exc->FDefs[n].opc == n for n in 0..exc->maxFunc           */
    /*                                                              */
    /* If this isn't true, we need to look up the function table.   */

    def = exc->FDefs + F;
    if ( exc->maxFunc + 1 != exc->numFDefs || def->opc != F )
    {
      /* look up the FDefs table */
      TT_DefRecord*  limit;


      def   = exc->FDefs;
      limit = def + exc->numFDefs;

      while ( def < limit && def->opc != F )
        def++;

      if ( def == limit )
        goto Fail;
    }

    /* check that the function is active */
    if ( !def->active )
      goto Fail;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( SUBPIXEL_HINTING_INFINALITY                         &&
         exc->ignore_x_mode                                  &&
         ( def->sph_fdef_flags & SPH_FDEF_VACUFORM_ROUND_1 ) )
      goto Fail;
    else
      exc->sph_in_func_flags = def->sph_fdef_flags;
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    /* check stack */
    if ( exc->callTop >= exc->callSize )
    {
      exc->error = FT_THROW( Stack_Overflow );
      return;
    }

    if ( args[0] > 0 )
    {
      pCrec = exc->callStack + exc->callTop;

      pCrec->Caller_Range = exc->curRange;
      pCrec->Caller_IP    = exc->IP + 1;
      pCrec->Cur_Count    = (FT_Int)args[0];
      pCrec->Def          = def;

      exc->callTop++;

      Ins_Goto_CodeRange( exc, def->range, def->start );

      exc->step_ins = FALSE;

      exc->loopcall_counter += (FT_ULong)args[0];
      if ( exc->loopcall_counter > exc->loopcall_counter_max )
        exc->error = FT_THROW( Execution_Too_Long );
    }

    return;

  Fail:
    exc->error = FT_THROW( Invalid_Reference );
  }


  /*************************************************************************/
  /*                                                                       */
  /* IDEF[]:       Instruction DEFinition                                  */
  /* Opcode range: 0x89                                                    */
  /* Stack:        Eint8 -->                                               */
  /*                                                                       */
  static void
  Ins_IDEF( TT_ExecContext  exc,
            FT_Long*        args )
  {
    TT_DefRecord*  def;
    TT_DefRecord*  limit;


    /* we enable IDEF only in `prep' or `fpgm' */
    if ( exc->curRange == tt_coderange_glyph )
    {
      exc->error = FT_THROW( DEF_In_Glyf_Bytecode );
      return;
    }

    /*  First of all, look for the same function in our table */

    def   = exc->IDefs;
    limit = def + exc->numIDefs;

    for ( ; def < limit; def++ )
      if ( def->opc == (FT_ULong)args[0] )
        break;

    if ( def == limit )
    {
      /* check that there is enough room for a new instruction */
      if ( exc->numIDefs >= exc->maxIDefs )
      {
        exc->error = FT_THROW( Too_Many_Instruction_Defs );
        return;
      }
      exc->numIDefs++;
    }

    /* opcode must be unsigned 8-bit integer */
    if ( 0 > args[0] || args[0] > 0x00FF )
    {
      exc->error = FT_THROW( Too_Many_Instruction_Defs );
      return;
    }

    def->opc    = (FT_Byte)args[0];
    def->start  = exc->IP + 1;
    def->range  = exc->curRange;
    def->active = TRUE;

    if ( (FT_ULong)args[0] > exc->maxIns )
      exc->maxIns = (FT_Byte)args[0];

    /* Now skip the whole function definition. */
    /* We don't allow nested IDEFs & FDEFs.    */

    while ( SkipCode( exc ) == SUCCESS )
    {
      switch ( exc->opcode )
      {
      case 0x89:   /* IDEF */
      case 0x2C:   /* FDEF */
        exc->error = FT_THROW( Nested_DEFS );
        return;
      case 0x2D:   /* ENDF */
        def->end = exc->IP;
        return;
      }
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* PUSHING DATA ONTO THE INTERPRETER STACK                               */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* NPUSHB[]:     PUSH N Bytes                                            */
  /* Opcode range: 0x40                                                    */
  /* Stack:        --> uint32...                                           */
  /*                                                                       */
  static void
  Ins_NPUSHB( TT_ExecContext  exc,
              FT_Long*        args )
  {
    FT_UShort  L, K;


    L = (FT_UShort)exc->code[exc->IP + 1];

    if ( BOUNDS( L, exc->stackSize + 1 - exc->top ) )
    {
      exc->error = FT_THROW( Stack_Overflow );
      return;
    }

    for ( K = 1; K <= L; K++ )
      args[K - 1] = exc->code[exc->IP + K + 1];

    exc->new_top += L;
  }


  /*************************************************************************/
  /*                                                                       */
  /* NPUSHW[]:     PUSH N Words                                            */
  /* Opcode range: 0x41                                                    */
  /* Stack:        --> int32...                                            */
  /*                                                                       */
  static void
  Ins_NPUSHW( TT_ExecContext  exc,
              FT_Long*        args )
  {
    FT_UShort  L, K;


    L = (FT_UShort)exc->code[exc->IP + 1];

    if ( BOUNDS( L, exc->stackSize + 1 - exc->top ) )
    {
      exc->error = FT_THROW( Stack_Overflow );
      return;
    }

    exc->IP += 2;

    for ( K = 0; K < L; K++ )
      args[K] = GetShortIns( exc );

    exc->step_ins = FALSE;
    exc->new_top += L;
  }


  /*************************************************************************/
  /*                                                                       */
  /* PUSHB[abc]:   PUSH Bytes                                              */
  /* Opcode range: 0xB0-0xB7                                               */
  /* Stack:        --> uint32...                                           */
  /*                                                                       */
  static void
  Ins_PUSHB( TT_ExecContext  exc,
             FT_Long*        args )
  {
    FT_UShort  L, K;


    L = (FT_UShort)( exc->opcode - 0xB0 + 1 );

    if ( BOUNDS( L, exc->stackSize + 1 - exc->top ) )
    {
      exc->error = FT_THROW( Stack_Overflow );
      return;
    }

    for ( K = 1; K <= L; K++ )
      args[K - 1] = exc->code[exc->IP + K];
  }


  /*************************************************************************/
  /*                                                                       */
  /* PUSHW[abc]:   PUSH Words                                              */
  /* Opcode range: 0xB8-0xBF                                               */
  /* Stack:        --> int32...                                            */
  /*                                                                       */
  static void
  Ins_PUSHW( TT_ExecContext  exc,
             FT_Long*        args )
  {
    FT_UShort  L, K;


    L = (FT_UShort)( exc->opcode - 0xB8 + 1 );

    if ( BOUNDS( L, exc->stackSize + 1 - exc->top ) )
    {
      exc->error = FT_THROW( Stack_Overflow );
      return;
    }

    exc->IP++;

    for ( K = 0; K < L; K++ )
      args[K] = GetShortIns( exc );

    exc->step_ins = FALSE;
  }


  /*************************************************************************/
  /*                                                                       */
  /* MANAGING THE GRAPHICS STATE                                           */
  /*                                                                       */
  /*************************************************************************/


  static FT_Bool
  Ins_SxVTL( TT_ExecContext  exc,
             FT_UShort       aIdx1,
             FT_UShort       aIdx2,
             FT_UnitVector*  Vec )
  {
    FT_Long     A, B, C;
    FT_Vector*  p1;
    FT_Vector*  p2;

    FT_Byte  opcode = exc->opcode;


    if ( BOUNDS( aIdx1, exc->zp2.n_points ) ||
         BOUNDS( aIdx2, exc->zp1.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return FAILURE;
    }

    p1 = exc->zp1.cur + aIdx2;
    p2 = exc->zp2.cur + aIdx1;

    A = p1->x - p2->x;
    B = p1->y - p2->y;

    /* If p1 == p2, SPvTL and SFvTL behave the same as */
    /* SPvTCA[X] and SFvTCA[X], respectively.          */
    /*                                                 */
    /* Confirmed by Greg Hitchcock.                    */

    if ( A == 0 && B == 0 )
    {
      A      = 0x4000;
      opcode = 0;
    }

    if ( ( opcode & 1 ) != 0 )
    {
      C =  B;   /* counter clockwise rotation */
      B =  A;
      A = -C;
    }

    Normalize( A, B, Vec );

    return SUCCESS;
  }


  /*************************************************************************/
  /*                                                                       */
  /* SVTCA[a]:     Set (F and P) Vectors to Coordinate Axis                */
  /* Opcode range: 0x00-0x01                                               */
  /* Stack:        -->                                                     */
  /*                                                                       */
  /* SPvTCA[a]:    Set PVector to Coordinate Axis                          */
  /* Opcode range: 0x02-0x03                                               */
  /* Stack:        -->                                                     */
  /*                                                                       */
  /* SFvTCA[a]:    Set FVector to Coordinate Axis                          */
  /* Opcode range: 0x04-0x05                                               */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_SxyTCA( TT_ExecContext  exc )
  {
    FT_Short  AA, BB;

    FT_Byte  opcode = exc->opcode;


    AA = (FT_Short)( ( opcode & 1 ) << 14 );
    BB = (FT_Short)( AA ^ 0x4000 );

    if ( opcode < 4 )
    {
      exc->GS.projVector.x = AA;
      exc->GS.projVector.y = BB;

      exc->GS.dualVector.x = AA;
      exc->GS.dualVector.y = BB;
    }

    if ( ( opcode & 2 ) == 0 )
    {
      exc->GS.freeVector.x = AA;
      exc->GS.freeVector.y = BB;
    }

    Compute_Funcs( exc );
  }


  /*************************************************************************/
  /*                                                                       */
  /* SPvTL[a]:     Set PVector To Line                                     */
  /* Opcode range: 0x06-0x07                                               */
  /* Stack:        uint32 uint32 -->                                       */
  /*                                                                       */
  static void
  Ins_SPVTL( TT_ExecContext  exc,
             FT_Long*        args )
  {
    if ( Ins_SxVTL( exc,
                    (FT_UShort)args[1],
                    (FT_UShort)args[0],
                    &exc->GS.projVector ) == SUCCESS )
    {
      exc->GS.dualVector = exc->GS.projVector;
      Compute_Funcs( exc );
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* SFvTL[a]:     Set FVector To Line                                     */
  /* Opcode range: 0x08-0x09                                               */
  /* Stack:        uint32 uint32 -->                                       */
  /*                                                                       */
  static void
  Ins_SFVTL( TT_ExecContext  exc,
             FT_Long*        args )
  {
    if ( Ins_SxVTL( exc,
                    (FT_UShort)args[1],
                    (FT_UShort)args[0],
                    &exc->GS.freeVector ) == SUCCESS )
    {
      Compute_Funcs( exc );
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* SFvTPv[]:     Set FVector To PVector                                  */
  /* Opcode range: 0x0E                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_SFVTPV( TT_ExecContext  exc )
  {
    exc->GS.freeVector = exc->GS.projVector;
    Compute_Funcs( exc );
  }


  /*************************************************************************/
  /*                                                                       */
  /* SPvFS[]:      Set PVector From Stack                                  */
  /* Opcode range: 0x0A                                                    */
  /* Stack:        f2.14 f2.14 -->                                         */
  /*                                                                       */
  static void
  Ins_SPVFS( TT_ExecContext  exc,
             FT_Long*        args )
  {
    FT_Short  S;
    FT_Long   X, Y;


    /* Only use low 16bits, then sign extend */
    S = (FT_Short)args[1];
    Y = (FT_Long)S;
    S = (FT_Short)args[0];
    X = (FT_Long)S;

    Normalize( X, Y, &exc->GS.projVector );

    exc->GS.dualVector = exc->GS.projVector;
    Compute_Funcs( exc );
  }


  /*************************************************************************/
  /*                                                                       */
  /* SFvFS[]:      Set FVector From Stack                                  */
  /* Opcode range: 0x0B                                                    */
  /* Stack:        f2.14 f2.14 -->                                         */
  /*                                                                       */
  static void
  Ins_SFVFS( TT_ExecContext  exc,
             FT_Long*        args )
  {
    FT_Short  S;
    FT_Long   X, Y;


    /* Only use low 16bits, then sign extend */
    S = (FT_Short)args[1];
    Y = (FT_Long)S;
    S = (FT_Short)args[0];
    X = S;

    Normalize( X, Y, &exc->GS.freeVector );
    Compute_Funcs( exc );
  }


  /*************************************************************************/
  /*                                                                       */
  /* GPv[]:        Get Projection Vector                                   */
  /* Opcode range: 0x0C                                                    */
  /* Stack:        ef2.14 --> ef2.14                                       */
  /*                                                                       */
  static void
  Ins_GPV( TT_ExecContext  exc,
           FT_Long*        args )
  {
    args[0] = exc->GS.projVector.x;
    args[1] = exc->GS.projVector.y;
  }


  /*************************************************************************/
  /*                                                                       */
  /* GFv[]:        Get Freedom Vector                                      */
  /* Opcode range: 0x0D                                                    */
  /* Stack:        ef2.14 --> ef2.14                                       */
  /*                                                                       */
  static void
  Ins_GFV( TT_ExecContext  exc,
           FT_Long*        args )
  {
    args[0] = exc->GS.freeVector.x;
    args[1] = exc->GS.freeVector.y;
  }


  /*************************************************************************/
  /*                                                                       */
  /* SRP0[]:       Set Reference Point 0                                   */
  /* Opcode range: 0x10                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_SRP0( TT_ExecContext  exc,
            FT_Long*        args )
  {
    exc->GS.rp0 = (FT_UShort)args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* SRP1[]:       Set Reference Point 1                                   */
  /* Opcode range: 0x11                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_SRP1( TT_ExecContext  exc,
            FT_Long*        args )
  {
    exc->GS.rp1 = (FT_UShort)args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* SRP2[]:       Set Reference Point 2                                   */
  /* Opcode range: 0x12                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_SRP2( TT_ExecContext  exc,
            FT_Long*        args )
  {
    exc->GS.rp2 = (FT_UShort)args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* SMD[]:        Set Minimum Distance                                    */
  /* Opcode range: 0x1A                                                    */
  /* Stack:        f26.6 -->                                               */
  /*                                                                       */
  static void
  Ins_SMD( TT_ExecContext  exc,
           FT_Long*        args )
  {
    exc->GS.minimum_distance = args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* SCVTCI[]:     Set Control Value Table Cut In                          */
  /* Opcode range: 0x1D                                                    */
  /* Stack:        f26.6 -->                                               */
  /*                                                                       */
  static void
  Ins_SCVTCI( TT_ExecContext  exc,
              FT_Long*        args )
  {
    exc->GS.control_value_cutin = (FT_F26Dot6)args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* SSWCI[]:      Set Single Width Cut In                                 */
  /* Opcode range: 0x1E                                                    */
  /* Stack:        f26.6 -->                                               */
  /*                                                                       */
  static void
  Ins_SSWCI( TT_ExecContext  exc,
             FT_Long*        args )
  {
    exc->GS.single_width_cutin = (FT_F26Dot6)args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* SSW[]:        Set Single Width                                        */
  /* Opcode range: 0x1F                                                    */
  /* Stack:        int32? -->                                              */
  /*                                                                       */
  static void
  Ins_SSW( TT_ExecContext  exc,
           FT_Long*        args )
  {
    exc->GS.single_width_value = FT_MulFix( args[0],
                                            exc->tt_metrics.scale );
  }


  /*************************************************************************/
  /*                                                                       */
  /* FLIPON[]:     Set auto-FLIP to ON                                     */
  /* Opcode range: 0x4D                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_FLIPON( TT_ExecContext  exc )
  {
    exc->GS.auto_flip = TRUE;
  }


  /*************************************************************************/
  /*                                                                       */
  /* FLIPOFF[]:    Set auto-FLIP to OFF                                    */
  /* Opcode range: 0x4E                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_FLIPOFF( TT_ExecContext  exc )
  {
    exc->GS.auto_flip = FALSE;
  }


  /*************************************************************************/
  /*                                                                       */
  /* SANGW[]:      Set ANGle Weight                                        */
  /* Opcode range: 0x7E                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_SANGW( void )
  {
    /* instruction not supported anymore */
  }


  /*************************************************************************/
  /*                                                                       */
  /* SDB[]:        Set Delta Base                                          */
  /* Opcode range: 0x5E                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_SDB( TT_ExecContext  exc,
           FT_Long*        args )
  {
    exc->GS.delta_base = (FT_UShort)args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* SDS[]:        Set Delta Shift                                         */
  /* Opcode range: 0x5F                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_SDS( TT_ExecContext  exc,
           FT_Long*        args )
  {
    if ( (FT_ULong)args[0] > 6UL )
      exc->error = FT_THROW( Bad_Argument );
    else
      exc->GS.delta_shift = (FT_UShort)args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* RTHG[]:       Round To Half Grid                                      */
  /* Opcode range: 0x19                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_RTHG( TT_ExecContext  exc )
  {
    exc->GS.round_state = TT_Round_To_Half_Grid;
    exc->func_round     = (TT_Round_Func)Round_To_Half_Grid;
  }


  /*************************************************************************/
  /*                                                                       */
  /* RTG[]:        Round To Grid                                           */
  /* Opcode range: 0x18                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_RTG( TT_ExecContext  exc )
  {
    exc->GS.round_state = TT_Round_To_Grid;
    exc->func_round     = (TT_Round_Func)Round_To_Grid;
  }


  /*************************************************************************/
  /* RTDG[]:       Round To Double Grid                                    */
  /* Opcode range: 0x3D                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_RTDG( TT_ExecContext  exc )
  {
    exc->GS.round_state = TT_Round_To_Double_Grid;
    exc->func_round     = (TT_Round_Func)Round_To_Double_Grid;
  }


  /*************************************************************************/
  /* RUTG[]:       Round Up To Grid                                        */
  /* Opcode range: 0x7C                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_RUTG( TT_ExecContext  exc )
  {
    exc->GS.round_state = TT_Round_Up_To_Grid;
    exc->func_round     = (TT_Round_Func)Round_Up_To_Grid;
  }


  /*************************************************************************/
  /*                                                                       */
  /* RDTG[]:       Round Down To Grid                                      */
  /* Opcode range: 0x7D                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_RDTG( TT_ExecContext  exc )
  {
    exc->GS.round_state = TT_Round_Down_To_Grid;
    exc->func_round     = (TT_Round_Func)Round_Down_To_Grid;
  }


  /*************************************************************************/
  /*                                                                       */
  /* ROFF[]:       Round OFF                                               */
  /* Opcode range: 0x7A                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_ROFF( TT_ExecContext  exc )
  {
    exc->GS.round_state = TT_Round_Off;
    exc->func_round     = (TT_Round_Func)Round_None;
  }


  /*************************************************************************/
  /*                                                                       */
  /* SROUND[]:     Super ROUND                                             */
  /* Opcode range: 0x76                                                    */
  /* Stack:        Eint8 -->                                               */
  /*                                                                       */
  static void
  Ins_SROUND( TT_ExecContext  exc,
              FT_Long*        args )
  {
    SetSuperRound( exc, 0x4000, args[0] );

    exc->GS.round_state = TT_Round_Super;
    exc->func_round     = (TT_Round_Func)Round_Super;
  }


  /*************************************************************************/
  /*                                                                       */
  /* S45ROUND[]:   Super ROUND 45 degrees                                  */
  /* Opcode range: 0x77                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_S45ROUND( TT_ExecContext  exc,
                FT_Long*        args )
  {
    SetSuperRound( exc, 0x2D41, args[0] );

    exc->GS.round_state = TT_Round_Super_45;
    exc->func_round     = (TT_Round_Func)Round_Super_45;
  }


  /*************************************************************************/
  /*                                                                       */
  /* GC[a]:        Get Coordinate projected onto                           */
  /* Opcode range: 0x46-0x47                                               */
  /* Stack:        uint32 --> f26.6                                        */
  /*                                                                       */
  /* XXX: UNDOCUMENTED: Measures from the original glyph must be taken     */
  /*      along the dual projection vector!                                */
  /*                                                                       */
  static void
  Ins_GC( TT_ExecContext  exc,
          FT_Long*        args )
  {
    FT_ULong    L;
    FT_F26Dot6  R;


    L = (FT_ULong)args[0];

    if ( BOUNDSL( L, exc->zp2.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      R = 0;
    }
    else
    {
      if ( exc->opcode & 1 )
        R = FAST_DUALPROJ( &exc->zp2.org[L] );
      else
        R = FAST_PROJECT( &exc->zp2.cur[L] );
    }

    args[0] = R;
  }


  /*************************************************************************/
  /*                                                                       */
  /* SCFS[]:       Set Coordinate From Stack                               */
  /* Opcode range: 0x48                                                    */
  /* Stack:        f26.6 uint32 -->                                        */
  /*                                                                       */
  /* Formula:                                                              */
  /*                                                                       */
  /*   OA := OA + ( value - OA.p )/( f.p ) * f                             */
  /*                                                                       */
  static void
  Ins_SCFS( TT_ExecContext  exc,
            FT_Long*        args )
  {
    FT_Long    K;
    FT_UShort  L;


    L = (FT_UShort)args[0];

    if ( BOUNDS( L, exc->zp2.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    K = FAST_PROJECT( &exc->zp2.cur[L] );

    exc->func_move( exc, &exc->zp2, L, args[1] - K );

    /* UNDOCUMENTED!  The MS rasterizer does that with */
    /* twilight points (confirmed by Greg Hitchcock)   */
    if ( exc->GS.gep2 == 0 )
      exc->zp2.org[L] = exc->zp2.cur[L];
  }


  /*************************************************************************/
  /*                                                                       */
  /* MD[a]:        Measure Distance                                        */
  /* Opcode range: 0x49-0x4A                                               */
  /* Stack:        uint32 uint32 --> f26.6                                 */
  /*                                                                       */
  /* XXX: UNDOCUMENTED: Measure taken in the original glyph must be along  */
  /*                    the dual projection vector.                        */
  /*                                                                       */
  /* XXX: UNDOCUMENTED: Flag attributes are inverted!                      */
  /*                      0 => measure distance in original outline        */
  /*                      1 => measure distance in grid-fitted outline     */
  /*                                                                       */
  /* XXX: UNDOCUMENTED: `zp0 - zp1', and not `zp2 - zp1!                   */
  /*                                                                       */
  static void
  Ins_MD( TT_ExecContext  exc,
          FT_Long*        args )
  {
    FT_UShort   K, L;
    FT_F26Dot6  D;


    K = (FT_UShort)args[1];
    L = (FT_UShort)args[0];

    if ( BOUNDS( L, exc->zp0.n_points ) ||
         BOUNDS( K, exc->zp1.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      D = 0;
    }
    else
    {
      if ( exc->opcode & 1 )
        D = PROJECT( exc->zp0.cur + L, exc->zp1.cur + K );
      else
      {
        /* XXX: UNDOCUMENTED: twilight zone special case */

        if ( exc->GS.gep0 == 0 || exc->GS.gep1 == 0 )
        {
          FT_Vector*  vec1 = exc->zp0.org + L;
          FT_Vector*  vec2 = exc->zp1.org + K;


          D = DUALPROJ( vec1, vec2 );
        }
        else
        {
          FT_Vector*  vec1 = exc->zp0.orus + L;
          FT_Vector*  vec2 = exc->zp1.orus + K;


          if ( exc->metrics.x_scale == exc->metrics.y_scale )
          {
            /* this should be faster */
            D = DUALPROJ( vec1, vec2 );
            D = FT_MulFix( D, exc->metrics.x_scale );
          }
          else
          {
            FT_Vector  vec;


            vec.x = FT_MulFix( vec1->x - vec2->x, exc->metrics.x_scale );
            vec.y = FT_MulFix( vec1->y - vec2->y, exc->metrics.y_scale );

            D = FAST_DUALPROJ( &vec );
          }
        }
      }
    }

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    /* Disable Type 2 Vacuform Rounds - e.g. Arial Narrow */
    if ( SUBPIXEL_HINTING_INFINALITY &&
         exc->ignore_x_mode          &&
         FT_ABS( D ) == 64           )
      D += 1;
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    args[0] = D;
  }


  /*************************************************************************/
  /*                                                                       */
  /* SDPvTL[a]:    Set Dual PVector to Line                                */
  /* Opcode range: 0x86-0x87                                               */
  /* Stack:        uint32 uint32 -->                                       */
  /*                                                                       */
  static void
  Ins_SDPVTL( TT_ExecContext  exc,
              FT_Long*        args )
  {
    FT_Long    A, B, C;
    FT_UShort  p1, p2;            /* was FT_Int in pas type ERROR */

    FT_Byte  opcode = exc->opcode;


    p1 = (FT_UShort)args[1];
    p2 = (FT_UShort)args[0];

    if ( BOUNDS( p2, exc->zp1.n_points ) ||
         BOUNDS( p1, exc->zp2.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    {
      FT_Vector* v1 = exc->zp1.org + p2;
      FT_Vector* v2 = exc->zp2.org + p1;


      A = v1->x - v2->x;
      B = v1->y - v2->y;

      /* If v1 == v2, SDPvTL behaves the same as */
      /* SVTCA[X], respectively.                 */
      /*                                         */
      /* Confirmed by Greg Hitchcock.            */

      if ( A == 0 && B == 0 )
      {
        A      = 0x4000;
        opcode = 0;
      }
    }

    if ( ( opcode & 1 ) != 0 )
    {
      C =  B;   /* counter clockwise rotation */
      B =  A;
      A = -C;
    }

    Normalize( A, B, &exc->GS.dualVector );

    {
      FT_Vector*  v1 = exc->zp1.cur + p2;
      FT_Vector*  v2 = exc->zp2.cur + p1;


      A = v1->x - v2->x;
      B = v1->y - v2->y;

      if ( A == 0 && B == 0 )
      {
        A      = 0x4000;
        opcode = 0;
      }
    }

    if ( ( opcode & 1 ) != 0 )
    {
      C =  B;   /* counter clockwise rotation */
      B =  A;
      A = -C;
    }

    Normalize( A, B, &exc->GS.projVector );
    Compute_Funcs( exc );
  }


  /*************************************************************************/
  /*                                                                       */
  /* SZP0[]:       Set Zone Pointer 0                                      */
  /* Opcode range: 0x13                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_SZP0( TT_ExecContext  exc,
            FT_Long*        args )
  {
    switch ( (FT_Int)args[0] )
    {
    case 0:
      exc->zp0 = exc->twilight;
      break;

    case 1:
      exc->zp0 = exc->pts;
      break;

    default:
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    exc->GS.gep0 = (FT_UShort)args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* SZP1[]:       Set Zone Pointer 1                                      */
  /* Opcode range: 0x14                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_SZP1( TT_ExecContext  exc,
            FT_Long*        args )
  {
    switch ( (FT_Int)args[0] )
    {
    case 0:
      exc->zp1 = exc->twilight;
      break;

    case 1:
      exc->zp1 = exc->pts;
      break;

    default:
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    exc->GS.gep1 = (FT_UShort)args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* SZP2[]:       Set Zone Pointer 2                                      */
  /* Opcode range: 0x15                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_SZP2( TT_ExecContext  exc,
            FT_Long*        args )
  {
    switch ( (FT_Int)args[0] )
    {
    case 0:
      exc->zp2 = exc->twilight;
      break;

    case 1:
      exc->zp2 = exc->pts;
      break;

    default:
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    exc->GS.gep2 = (FT_UShort)args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* SZPS[]:       Set Zone PointerS                                       */
  /* Opcode range: 0x16                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_SZPS( TT_ExecContext  exc,
            FT_Long*        args )
  {
    switch ( (FT_Int)args[0] )
    {
    case 0:
      exc->zp0 = exc->twilight;
      break;

    case 1:
      exc->zp0 = exc->pts;
      break;

    default:
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    exc->zp1 = exc->zp0;
    exc->zp2 = exc->zp0;

    exc->GS.gep0 = (FT_UShort)args[0];
    exc->GS.gep1 = (FT_UShort)args[0];
    exc->GS.gep2 = (FT_UShort)args[0];
  }


  /*************************************************************************/
  /*                                                                       */
  /* INSTCTRL[]:   INSTruction ConTRoL                                     */
  /* Opcode range: 0x8E                                                    */
  /* Stack:        int32 int32 -->                                         */
  /*                                                                       */
  static void
  Ins_INSTCTRL( TT_ExecContext  exc,
                FT_Long*        args )
  {
    FT_ULong  K, L, Kf;


    K = (FT_ULong)args[1];
    L = (FT_ULong)args[0];

    /* selector values cannot be `OR'ed;                 */
    /* they are indices starting with index 1, not flags */
    if ( K < 1 || K > 3 )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    /* convert index to flag value */
    Kf = 1 << ( K - 1 );

    if ( L != 0 )
    {
      /* arguments to selectors look like flag values */
      if ( L != Kf )
      {
        if ( exc->pedantic_hinting )
          exc->error = FT_THROW( Invalid_Reference );
        return;
      }
    }

    exc->GS.instruct_control &= ~(FT_Byte)Kf;
    exc->GS.instruct_control |= (FT_Byte)L;

    if ( K == 3 )
    {
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      /* INSTCTRL modifying flag 3 also has an effect */
      /* outside of the CVT program                   */
      if ( SUBPIXEL_HINTING_INFINALITY )
        exc->ignore_x_mode = FT_BOOL( L == 4 );
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      /* Native ClearType fonts sign a waiver that turns off all backward  */
      /* compatibility hacks and lets them program points to the grid like */
      /* it's 1996.  They might sign a waiver for just one glyph, though.  */
      if ( SUBPIXEL_HINTING_MINIMAL )
        exc->backward_compatibility = !FT_BOOL( L == 4 );
#endif
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* SCANCTRL[]:   SCAN ConTRoL                                            */
  /* Opcode range: 0x85                                                    */
  /* Stack:        uint32? -->                                             */
  /*                                                                       */
  static void
  Ins_SCANCTRL( TT_ExecContext  exc,
                FT_Long*        args )
  {
    FT_Int  A;


    /* Get Threshold */
    A = (FT_Int)( args[0] & 0xFF );

    if ( A == 0xFF )
    {
      exc->GS.scan_control = TRUE;
      return;
    }
    else if ( A == 0 )
    {
      exc->GS.scan_control = FALSE;
      return;
    }

    if ( ( args[0] & 0x100 ) != 0 && exc->tt_metrics.ppem <= A )
      exc->GS.scan_control = TRUE;

    if ( ( args[0] & 0x200 ) != 0 && exc->tt_metrics.rotated )
      exc->GS.scan_control = TRUE;

    if ( ( args[0] & 0x400 ) != 0 && exc->tt_metrics.stretched )
      exc->GS.scan_control = TRUE;

    if ( ( args[0] & 0x800 ) != 0 && exc->tt_metrics.ppem > A )
      exc->GS.scan_control = FALSE;

    if ( ( args[0] & 0x1000 ) != 0 && exc->tt_metrics.rotated )
      exc->GS.scan_control = FALSE;

    if ( ( args[0] & 0x2000 ) != 0 && exc->tt_metrics.stretched )
      exc->GS.scan_control = FALSE;
  }


  /*************************************************************************/
  /*                                                                       */
  /* SCANTYPE[]:   SCAN TYPE                                               */
  /* Opcode range: 0x8D                                                    */
  /* Stack:        uint16 -->                                              */
  /*                                                                       */
  static void
  Ins_SCANTYPE( TT_ExecContext  exc,
                FT_Long*        args )
  {
    if ( args[0] >= 0 )
      exc->GS.scan_type = (FT_Int)args[0] & 0xFFFF;
  }


  /*************************************************************************/
  /*                                                                       */
  /* MANAGING OUTLINES                                                     */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* FLIPPT[]:     FLIP PoinT                                              */
  /* Opcode range: 0x80                                                    */
  /* Stack:        uint32... -->                                           */
  /*                                                                       */
  static void
  Ins_FLIPPT( TT_ExecContext  exc )
  {
    FT_UShort  point;


#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    /* See `ttinterp.h' for details on backward compatibility mode. */
    if ( SUBPIXEL_HINTING_MINIMAL    &&
         exc->backward_compatibility &&
         exc->iupx_called            &&
         exc->iupy_called            )
      goto Fail;
#endif

    if ( exc->top < exc->GS.loop )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Too_Few_Arguments );
      goto Fail;
    }

    while ( exc->GS.loop > 0 )
    {
      exc->args--;

      point = (FT_UShort)exc->stack[exc->args];

      if ( BOUNDS( point, exc->pts.n_points ) )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = FT_THROW( Invalid_Reference );
          return;
        }
      }
      else
        exc->pts.tags[point] ^= FT_CURVE_TAG_ON;

      exc->GS.loop--;
    }

  Fail:
    exc->GS.loop = 1;
    exc->new_top = exc->args;
  }


  /*************************************************************************/
  /*                                                                       */
  /* FLIPRGON[]:   FLIP RanGe ON                                           */
  /* Opcode range: 0x81                                                    */
  /* Stack:        uint32 uint32 -->                                       */
  /*                                                                       */
  static void
  Ins_FLIPRGON( TT_ExecContext  exc,
                FT_Long*        args )
  {
    FT_UShort  I, K, L;


#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    /* See `ttinterp.h' for details on backward compatibility mode. */
    if ( SUBPIXEL_HINTING_MINIMAL    &&
         exc->backward_compatibility &&
         exc->iupx_called            &&
         exc->iupy_called            )
      return;
#endif

    K = (FT_UShort)args[1];
    L = (FT_UShort)args[0];

    if ( BOUNDS( K, exc->pts.n_points ) ||
         BOUNDS( L, exc->pts.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    for ( I = L; I <= K; I++ )
      exc->pts.tags[I] |= FT_CURVE_TAG_ON;
  }


  /*************************************************************************/
  /*                                                                       */
  /* FLIPRGOFF:    FLIP RanGe OFF                                          */
  /* Opcode range: 0x82                                                    */
  /* Stack:        uint32 uint32 -->                                       */
  /*                                                                       */
  static void
  Ins_FLIPRGOFF( TT_ExecContext  exc,
                 FT_Long*        args )
  {
    FT_UShort  I, K, L;


#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    /* See `ttinterp.h' for details on backward compatibility mode. */
    if ( SUBPIXEL_HINTING_MINIMAL    &&
         exc->backward_compatibility &&
         exc->iupx_called            &&
         exc->iupy_called            )
      return;
#endif

    K = (FT_UShort)args[1];
    L = (FT_UShort)args[0];

    if ( BOUNDS( K, exc->pts.n_points ) ||
         BOUNDS( L, exc->pts.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    for ( I = L; I <= K; I++ )
      exc->pts.tags[I] &= ~FT_CURVE_TAG_ON;
  }


  static FT_Bool
  Compute_Point_Displacement( TT_ExecContext  exc,
                              FT_F26Dot6*     x,
                              FT_F26Dot6*     y,
                              TT_GlyphZone    zone,
                              FT_UShort*      refp )
  {
    TT_GlyphZoneRec  zp;
    FT_UShort        p;
    FT_F26Dot6       d;


    if ( exc->opcode & 1 )
    {
      zp = exc->zp0;
      p  = exc->GS.rp1;
    }
    else
    {
      zp = exc->zp1;
      p  = exc->GS.rp2;
    }

    if ( BOUNDS( p, zp.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      *refp = 0;
      return FAILURE;
    }

    *zone = zp;
    *refp = p;

    d = PROJECT( zp.cur + p, zp.org + p );

    *x = FT_MulDiv( d, (FT_Long)exc->GS.freeVector.x, exc->F_dot_P );
    *y = FT_MulDiv( d, (FT_Long)exc->GS.freeVector.y, exc->F_dot_P );

    return SUCCESS;
  }


  /* See `ttinterp.h' for details on backward compatibility mode. */
  static void
  Move_Zp2_Point( TT_ExecContext  exc,
                  FT_UShort       point,
                  FT_F26Dot6      dx,
                  FT_F26Dot6      dy,
                  FT_Bool         touch )
  {
    if ( exc->GS.freeVector.x != 0 )
    {
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      if ( !( SUBPIXEL_HINTING_MINIMAL    &&
              exc->backward_compatibility ) )
#endif
        exc->zp2.cur[point].x += dx;

      if ( touch )
        exc->zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;
    }

    if ( exc->GS.freeVector.y != 0 )
    {
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      if ( !( SUBPIXEL_HINTING_MINIMAL    &&
              exc->backward_compatibility &&
              exc->iupx_called            &&
              exc->iupy_called            ) )
#endif
        exc->zp2.cur[point].y += dy;

      if ( touch )
        exc->zp2.tags[point] |= FT_CURVE_TAG_TOUCH_Y;
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* SHP[a]:       SHift Point by the last point                           */
  /* Opcode range: 0x32-0x33                                               */
  /* Stack:        uint32... -->                                           */
  /*                                                                       */
  static void
  Ins_SHP( TT_ExecContext  exc )
  {
    TT_GlyphZoneRec  zp;
    FT_UShort        refp;

    FT_F26Dot6       dx, dy;
    FT_UShort        point;


    if ( exc->top < exc->GS.loop )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      goto Fail;
    }

    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )
      return;

    while ( exc->GS.loop > 0 )
    {
      exc->args--;
      point = (FT_UShort)exc->stack[exc->args];

      if ( BOUNDS( point, exc->zp2.n_points ) )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = FT_THROW( Invalid_Reference );
          return;
        }
      }
      else
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      /* doesn't follow Cleartype spec but produces better result */
      if ( SUBPIXEL_HINTING_INFINALITY && exc->ignore_x_mode )
        Move_Zp2_Point( exc, point, 0, dy, TRUE );
      else
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
        Move_Zp2_Point( exc, point, dx, dy, TRUE );

      exc->GS.loop--;
    }

  Fail:
    exc->GS.loop = 1;
    exc->new_top = exc->args;
  }


  /*************************************************************************/
  /*                                                                       */
  /* SHC[a]:       SHift Contour                                           */
  /* Opcode range: 0x34-35                                                 */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  /* UNDOCUMENTED: According to Greg Hitchcock, there is one (virtual)     */
  /*               contour in the twilight zone, namely contour number     */
  /*               zero which includes all points of it.                   */
  /*                                                                       */
  static void
  Ins_SHC( TT_ExecContext  exc,
           FT_Long*        args )
  {
    TT_GlyphZoneRec  zp;
    FT_UShort        refp;
    FT_F26Dot6       dx, dy;

    FT_Short         contour, bounds;
    FT_UShort        start, limit, i;


    contour = (FT_Short)args[0];
    bounds  = ( exc->GS.gep2 == 0 ) ? 1 : exc->zp2.n_contours;

    if ( BOUNDS( contour, bounds ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )
      return;

    if ( contour == 0 )
      start = 0;
    else
      start = (FT_UShort)( exc->zp2.contours[contour - 1] + 1 -
                           exc->zp2.first_point );

    /* we use the number of points if in the twilight zone */
    if ( exc->GS.gep2 == 0 )
      limit = exc->zp2.n_points;
    else
      limit = (FT_UShort)( exc->zp2.contours[contour] -
                           exc->zp2.first_point + 1 );

    for ( i = start; i < limit; i++ )
    {
      if ( zp.cur != exc->zp2.cur || refp != i )
        Move_Zp2_Point( exc, i, dx, dy, TRUE );
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* SHZ[a]:       SHift Zone                                              */
  /* Opcode range: 0x36-37                                                 */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_SHZ( TT_ExecContext  exc,
           FT_Long*        args )
  {
    TT_GlyphZoneRec  zp;
    FT_UShort        refp;
    FT_F26Dot6       dx,
                     dy;

    FT_UShort        limit, i;


    if ( BOUNDS( args[0], 2 ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )
      return;

    /* XXX: UNDOCUMENTED! SHZ doesn't move the phantom points.     */
    /*      Twilight zone has no real contours, so use `n_points'. */
    /*      Normal zone's `n_points' includes phantoms, so must    */
    /*      use end of last contour.                               */
    if ( exc->GS.gep2 == 0 )
      limit = (FT_UShort)exc->zp2.n_points;
    else if ( exc->GS.gep2 == 1 && exc->zp2.n_contours > 0 )
      limit = (FT_UShort)( exc->zp2.contours[exc->zp2.n_contours - 1] + 1 );
    else
      limit = 0;

    /* XXX: UNDOCUMENTED! SHZ doesn't touch the points */
    for ( i = 0; i < limit; i++ )
    {
      if ( zp.cur != exc->zp2.cur || refp != i )
        Move_Zp2_Point( exc, i, dx, dy, FALSE );
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* SHPIX[]:      SHift points by a PIXel amount                          */
  /* Opcode range: 0x38                                                    */
  /* Stack:        f26.6 uint32... -->                                     */
  /*                                                                       */
  static void
  Ins_SHPIX( TT_ExecContext  exc,
             FT_Long*        args )
  {
    FT_F26Dot6  dx, dy;
    FT_UShort   point;
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    FT_Int      B1, B2;
#endif
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    FT_Bool     in_twilight = FT_BOOL( exc->GS.gep0 == 0 ||
                                       exc->GS.gep1 == 0 ||
                                       exc->GS.gep2 == 0 );
#endif



    if ( exc->top < exc->GS.loop + 1 )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      goto Fail;
    }

    dx = TT_MulFix14( args[0], exc->GS.freeVector.x );
    dy = TT_MulFix14( args[0], exc->GS.freeVector.y );

    while ( exc->GS.loop > 0 )
    {
      exc->args--;

      point = (FT_UShort)exc->stack[exc->args];

      if ( BOUNDS( point, exc->zp2.n_points ) )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = FT_THROW( Invalid_Reference );
          return;
        }
      }
      else
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      if ( SUBPIXEL_HINTING_INFINALITY )
      {
        /*  If not using ignore_x_mode rendering, allow ZP2 move.        */
        /*  If inline deltas aren't allowed, skip ZP2 move.              */
        /*  If using ignore_x_mode rendering, allow ZP2 point move if:   */
        /*   - freedom vector is y and sph_compatibility_mode is off     */
        /*   - the glyph is composite and the move is in the Y direction */
        /*   - the glyph is specifically set to allow SHPIX moves        */
        /*   - the move is on a previously Y-touched point               */

        if ( exc->ignore_x_mode )
        {
          /* save point for later comparison */
          if ( exc->GS.freeVector.y != 0 )
            B1 = exc->zp2.cur[point].y;
          else
            B1 = exc->zp2.cur[point].x;

          if ( !exc->face->sph_compatibility_mode &&
               exc->GS.freeVector.y != 0          )
          {
            Move_Zp2_Point( exc, point, dx, dy, TRUE );

            /* save new point */
            if ( exc->GS.freeVector.y != 0 )
            {
              B2 = exc->zp2.cur[point].y;

              /* reverse any disallowed moves */
              if ( ( exc->sph_tweak_flags & SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&
                   ( B1 & 63 ) != 0                                           &&
                   ( B2 & 63 ) != 0                                           &&
                   B1 != B2                                                   )
                Move_Zp2_Point( exc, point, -dx, -dy, TRUE );
            }
          }
          else if ( exc->face->sph_compatibility_mode )
          {
            if ( exc->sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES )
            {
              dx = FT_PIX_ROUND( B1 + dx ) - B1;
              dy = FT_PIX_ROUND( B1 + dy ) - B1;
            }

            /* skip post-iup deltas */
            if ( exc->iup_called                                          &&
                 ( ( exc->sph_in_func_flags & SPH_FDEF_INLINE_DELTA_1 ) ||
                   ( exc->sph_in_func_flags & SPH_FDEF_INLINE_DELTA_2 ) ) )
              goto Skip;

            if ( !( exc->sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP ) &&
                  ( ( exc->is_composite && exc->GS.freeVector.y != 0 ) ||
                    ( exc->zp2.tags[point] & FT_CURVE_TAG_TOUCH_Y )    ||
                    ( exc->sph_tweak_flags & SPH_TWEAK_DO_SHPIX )      )  )
              Move_Zp2_Point( exc, point, 0, dy, TRUE );

            /* save new point */
            if ( exc->GS.freeVector.y != 0 )
            {
              B2 = exc->zp2.cur[point].y;

              /* reverse any disallowed moves */
              if ( ( B1 & 63 ) == 0 &&
                   ( B2 & 63 ) != 0 &&
                   B1 != B2         )
                Move_Zp2_Point( exc, point, 0, -dy, TRUE );
            }
          }
          else if ( exc->sph_in_func_flags & SPH_FDEF_TYPEMAN_DIAGENDCTRL )
            Move_Zp2_Point( exc, point, dx, dy, TRUE );
        }
        else
          Move_Zp2_Point( exc, point, dx, dy, TRUE );
      }
      else
#endif
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      if ( SUBPIXEL_HINTING_MINIMAL    &&
           exc->backward_compatibility )
      {
        /* Special case: allow SHPIX to move points in the twilight zone.  */
        /* Otherwise, treat SHPIX the same as DELTAP.  Unbreaks various    */
        /* fonts such as older versions of Rokkitt and DTL Argo T Light    */
        /* that would glitch severely after calling ALIGNRP after a        */
        /* blocked SHPIX.                                                  */
        if ( in_twilight                                                ||
             ( !( exc->iupx_called && exc->iupy_called )              &&
               ( ( exc->is_composite && exc->GS.freeVector.y != 0 ) ||
                 ( exc->zp2.tags[point] & FT_CURVE_TAG_TOUCH_Y )    ) ) )
          Move_Zp2_Point( exc, point, 0, dy, TRUE );
      }
      else
#endif
        Move_Zp2_Point( exc, point, dx, dy, TRUE );

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    Skip:
#endif
      exc->GS.loop--;
    }

  Fail:
    exc->GS.loop = 1;
    exc->new_top = exc->args;
  }


  /*************************************************************************/
  /*                                                                       */
  /* MSIRP[a]:     Move Stack Indirect Relative Position                   */
  /* Opcode range: 0x3A-0x3B                                               */
  /* Stack:        f26.6 uint32 -->                                        */
  /*                                                                       */
  static void
  Ins_MSIRP( TT_ExecContext  exc,
             FT_Long*        args )
  {
    FT_UShort   point = 0;
    FT_F26Dot6  distance;
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    FT_F26Dot6  control_value_cutin = 0;


    if ( SUBPIXEL_HINTING_INFINALITY )
    {
      control_value_cutin = exc->GS.control_value_cutin;

      if ( exc->ignore_x_mode                                 &&
           exc->GS.freeVector.x != 0                          &&
           !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
        control_value_cutin = 0;
    }
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    point = (FT_UShort)args[0];

    if ( BOUNDS( point,       exc->zp1.n_points ) ||
         BOUNDS( exc->GS.rp0, exc->zp0.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    /* UNDOCUMENTED!  The MS rasterizer does that with */
    /* twilight points (confirmed by Greg Hitchcock)   */
    if ( exc->GS.gep1 == 0 )
    {
      exc->zp1.org[point] = exc->zp0.org[exc->GS.rp0];
      exc->func_move_orig( exc, &exc->zp1, point, args[1] );
      exc->zp1.cur[point] = exc->zp1.org[point];
    }

    distance = PROJECT( exc->zp1.cur + point, exc->zp0.cur + exc->GS.rp0 );

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    /* subpixel hinting - make MSIRP respect CVT cut-in; */
    if ( SUBPIXEL_HINTING_INFINALITY                         &&
         exc->ignore_x_mode                                  &&
         exc->GS.freeVector.x != 0                           &&
         FT_ABS( distance - args[1] ) >= control_value_cutin )
      distance = args[1];
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    exc->func_move( exc, &exc->zp1, point, args[1] - distance );

    exc->GS.rp1 = exc->GS.rp0;
    exc->GS.rp2 = point;

    if ( ( exc->opcode & 1 ) != 0 )
      exc->GS.rp0 = point;
  }


  /*************************************************************************/
  /*                                                                       */
  /* MDAP[a]:      Move Direct Absolute Point                              */
  /* Opcode range: 0x2E-0x2F                                               */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_MDAP( TT_ExecContext  exc,
            FT_Long*        args )
  {
    FT_UShort   point;
    FT_F26Dot6  cur_dist;
    FT_F26Dot6  distance;


    point = (FT_UShort)args[0];

    if ( BOUNDS( point, exc->zp0.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    if ( ( exc->opcode & 1 ) != 0 )
    {
      cur_dist = FAST_PROJECT( &exc->zp0.cur[point] );
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      if ( SUBPIXEL_HINTING_INFINALITY &&
           exc->ignore_x_mode          &&
           exc->GS.freeVector.x != 0   )
        distance = Round_None(
                     exc,
                     cur_dist,
                     exc->tt_metrics.compensations[0] ) - cur_dist;
      else
#endif
        distance = exc->func_round(
                     exc,
                     cur_dist,
                     exc->tt_metrics.compensations[0] ) - cur_dist;
    }
    else
      distance = 0;

    exc->func_move( exc, &exc->zp0, point, distance );

    exc->GS.rp0 = point;
    exc->GS.rp1 = point;
  }


  /*************************************************************************/
  /*                                                                       */
  /* MIAP[a]:      Move Indirect Absolute Point                            */
  /* Opcode range: 0x3E-0x3F                                               */
  /* Stack:        uint32 uint32 -->                                       */
  /*                                                                       */
  static void
  Ins_MIAP( TT_ExecContext  exc,
            FT_Long*        args )
  {
    FT_ULong    cvtEntry;
    FT_UShort   point;
    FT_F26Dot6  distance;
    FT_F26Dot6  org_dist;
    FT_F26Dot6  control_value_cutin;


    control_value_cutin = exc->GS.control_value_cutin;
    cvtEntry            = (FT_ULong)args[1];
    point               = (FT_UShort)args[0];

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( SUBPIXEL_HINTING_INFINALITY                        &&
         exc->ignore_x_mode                                 &&
         exc->GS.freeVector.x != 0                          &&
         exc->GS.freeVector.y == 0                          &&
         !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
      control_value_cutin = 0;
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    if ( BOUNDS( point,     exc->zp0.n_points ) ||
         BOUNDSL( cvtEntry, exc->cvtSize )      )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      goto Fail;
    }

    /* UNDOCUMENTED!                                                      */
    /*                                                                    */
    /* The behaviour of an MIAP instruction is quite different when used  */
    /* in the twilight zone.                                              */
    /*                                                                    */
    /* First, no control value cut-in test is performed as it would fail  */
    /* anyway.  Second, the original point, i.e. (org_x,org_y) of         */
    /* zp0.point, is set to the absolute, unrounded distance found in the */
    /* CVT.                                                               */
    /*                                                                    */
    /* This is used in the CVT programs of the Microsoft fonts Arial,     */
    /* Times, etc., in order to re-adjust some key font heights.  It      */
    /* allows the use of the IP instruction in the twilight zone, which   */
    /* otherwise would be invalid according to the specification.         */
    /*                                                                    */
    /* We implement it with a special sequence for the twilight zone.     */
    /* This is a bad hack, but it seems to work.                          */
    /*                                                                    */
    /* Confirmed by Greg Hitchcock.                                       */

    distance = exc->func_read_cvt( exc, cvtEntry );

    if ( exc->GS.gep0 == 0 )   /* If in twilight zone */
    {
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      /* Only adjust if not in sph_compatibility_mode or ignore_x_mode. */
      /* Determined via experimentation and may be incorrect...         */
      if ( !( SUBPIXEL_HINTING_INFINALITY           &&
              ( exc->ignore_x_mode                &&
                exc->face->sph_compatibility_mode ) ) )
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
        exc->zp0.org[point].x = TT_MulFix14( distance,
                                             exc->GS.freeVector.x );
      exc->zp0.org[point].y = TT_MulFix14( distance,
                                           exc->GS.freeVector.y ),
      exc->zp0.cur[point]   = exc->zp0.org[point];
    }
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( SUBPIXEL_HINTING_INFINALITY                    &&
         exc->ignore_x_mode                             &&
         ( exc->sph_tweak_flags & SPH_TWEAK_MIAP_HACK ) &&
         distance > 0                                   &&
         exc->GS.freeVector.y != 0                      )
      distance = 0;
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    org_dist = FAST_PROJECT( &exc->zp0.cur[point] );

    if ( ( exc->opcode & 1 ) != 0 )   /* rounding and control cut-in flag */
    {
      if ( FT_ABS( distance - org_dist ) > control_value_cutin )
        distance = org_dist;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      if ( SUBPIXEL_HINTING_INFINALITY &&
           exc->ignore_x_mode          &&
           exc->GS.freeVector.x != 0   )
        distance = Round_None( exc,
                               distance,
                               exc->tt_metrics.compensations[0] );
      else
#endif
        distance = exc->func_round( exc,
                                    distance,
                                    exc->tt_metrics.compensations[0] );
    }

    exc->func_move( exc, &exc->zp0, point, distance - org_dist );

  Fail:
    exc->GS.rp0 = point;
    exc->GS.rp1 = point;
  }


  /*************************************************************************/
  /*                                                                       */
  /* MDRP[abcde]:  Move Direct Relative Point                              */
  /* Opcode range: 0xC0-0xDF                                               */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_MDRP( TT_ExecContext  exc,
            FT_Long*        args )
  {
    FT_UShort   point = 0;
    FT_F26Dot6  org_dist, distance, minimum_distance;


    minimum_distance = exc->GS.minimum_distance;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( SUBPIXEL_HINTING_INFINALITY                        &&
         exc->ignore_x_mode                                 &&
         exc->GS.freeVector.x != 0                          &&
         !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
      minimum_distance = 0;
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    point = (FT_UShort)args[0];

    if ( BOUNDS( point,       exc->zp1.n_points ) ||
         BOUNDS( exc->GS.rp0, exc->zp0.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      goto Fail;
    }

    /* XXX: Is there some undocumented feature while in the */
    /*      twilight zone?                                  */

    /* XXX: UNDOCUMENTED: twilight zone special case */

    if ( exc->GS.gep0 == 0 || exc->GS.gep1 == 0 )
    {
      FT_Vector*  vec1 = &exc->zp1.org[point];
      FT_Vector*  vec2 = &exc->zp0.org[exc->GS.rp0];


      org_dist = DUALPROJ( vec1, vec2 );
    }
    else
    {
      FT_Vector*  vec1 = &exc->zp1.orus[point];
      FT_Vector*  vec2 = &exc->zp0.orus[exc->GS.rp0];


      if ( exc->metrics.x_scale == exc->metrics.y_scale )
      {
        /* this should be faster */
        org_dist = DUALPROJ( vec1, vec2 );
        org_dist = FT_MulFix( org_dist, exc->metrics.x_scale );
      }
      else
      {
        FT_Vector  vec;


        vec.x = FT_MulFix( vec1->x - vec2->x, exc->metrics.x_scale );
        vec.y = FT_MulFix( vec1->y - vec2->y, exc->metrics.y_scale );

        org_dist = FAST_DUALPROJ( &vec );
      }
    }

    /* single width cut-in test */

    if ( FT_ABS( org_dist - exc->GS.single_width_value ) <
         exc->GS.single_width_cutin )
    {
      if ( org_dist >= 0 )
        org_dist = exc->GS.single_width_value;
      else
        org_dist = -exc->GS.single_width_value;
    }

    /* round flag */

    if ( ( exc->opcode & 4 ) != 0 )
    {
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      if ( SUBPIXEL_HINTING_INFINALITY &&
           exc->ignore_x_mode          &&
           exc->GS.freeVector.x != 0   )
        distance = Round_None(
                     exc,
                     org_dist,
                     exc->tt_metrics.compensations[exc->opcode & 3] );
      else
#endif
        distance = exc->func_round(
                     exc,
                     org_dist,
                     exc->tt_metrics.compensations[exc->opcode & 3] );
    }
    else
      distance = Round_None(
                   exc,
                   org_dist,
                   exc->tt_metrics.compensations[exc->opcode & 3] );

    /* minimum distance flag */

    if ( ( exc->opcode & 8 ) != 0 )
    {
      if ( org_dist >= 0 )
      {
        if ( distance < minimum_distance )
          distance = minimum_distance;
      }
      else
      {
        if ( distance > -minimum_distance )
          distance = -minimum_distance;
      }
    }

    /* now move the point */

    org_dist = PROJECT( exc->zp1.cur + point, exc->zp0.cur + exc->GS.rp0 );

    exc->func_move( exc, &exc->zp1, point, distance - org_dist );

  Fail:
    exc->GS.rp1 = exc->GS.rp0;
    exc->GS.rp2 = point;

    if ( ( exc->opcode & 16 ) != 0 )
      exc->GS.rp0 = point;
  }


  /*************************************************************************/
  /*                                                                       */
  /* MIRP[abcde]:  Move Indirect Relative Point                            */
  /* Opcode range: 0xE0-0xFF                                               */
  /* Stack:        int32? uint32 -->                                       */
  /*                                                                       */
  static void
  Ins_MIRP( TT_ExecContext  exc,
            FT_Long*        args )
  {
    FT_UShort   point;
    FT_ULong    cvtEntry;

    FT_F26Dot6  cvt_dist,
                distance,
                cur_dist,
                org_dist,
                control_value_cutin,
                minimum_distance;
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    FT_Int      B1           = 0; /* pacify compiler */
    FT_Int      B2           = 0;
    FT_Bool     reverse_move = FALSE;
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */


    minimum_distance    = exc->GS.minimum_distance;
    control_value_cutin = exc->GS.control_value_cutin;
    point               = (FT_UShort)args[0];
    cvtEntry            = (FT_ULong)( args[1] + 1 );

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( SUBPIXEL_HINTING_INFINALITY                        &&
         exc->ignore_x_mode                                 &&
         exc->GS.freeVector.x != 0                          &&
         !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
      control_value_cutin = minimum_distance = 0;
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    /* XXX: UNDOCUMENTED! cvt[-1] = 0 always */

    if ( BOUNDS( point,       exc->zp1.n_points ) ||
         BOUNDSL( cvtEntry,   exc->cvtSize + 1 )  ||
         BOUNDS( exc->GS.rp0, exc->zp0.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      goto Fail;
    }

    if ( !cvtEntry )
      cvt_dist = 0;
    else
      cvt_dist = exc->func_read_cvt( exc, cvtEntry - 1 );

    /* single width test */

    if ( FT_ABS( cvt_dist - exc->GS.single_width_value ) <
         exc->GS.single_width_cutin )
    {
      if ( cvt_dist >= 0 )
        cvt_dist =  exc->GS.single_width_value;
      else
        cvt_dist = -exc->GS.single_width_value;
    }

    /* UNDOCUMENTED!  The MS rasterizer does that with */
    /* twilight points (confirmed by Greg Hitchcock)   */
    if ( exc->GS.gep1 == 0 )
    {
      exc->zp1.org[point].x = exc->zp0.org[exc->GS.rp0].x +
                              TT_MulFix14( cvt_dist,
                                           exc->GS.freeVector.x );
      exc->zp1.org[point].y = exc->zp0.org[exc->GS.rp0].y +
                              TT_MulFix14( cvt_dist,
                                           exc->GS.freeVector.y );
      exc->zp1.cur[point]   = exc->zp1.org[point];
    }

    org_dist = DUALPROJ( &exc->zp1.org[point], &exc->zp0.org[exc->GS.rp0] );
    cur_dist = PROJECT ( &exc->zp1.cur[point], &exc->zp0.cur[exc->GS.rp0] );

    /* auto-flip test */

    if ( exc->GS.auto_flip )
    {
      if ( ( org_dist ^ cvt_dist ) < 0 )
        cvt_dist = -cvt_dist;
    }

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( SUBPIXEL_HINTING_INFINALITY                               &&
         exc->ignore_x_mode                                        &&
         exc->GS.freeVector.y != 0                                 &&
         ( exc->sph_tweak_flags & SPH_TWEAK_TIMES_NEW_ROMAN_HACK ) )
    {
      if ( cur_dist < -64 )
        cvt_dist -= 16;
      else if ( cur_dist > 64 && cur_dist < 84 )
        cvt_dist += 32;
    }
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    /* control value cut-in and round */

    if ( ( exc->opcode & 4 ) != 0 )
    {
      /* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */
      /*      refer to the same zone.                                  */

      if ( exc->GS.gep0 == exc->GS.gep1 )
      {
        /* XXX: According to Greg Hitchcock, the following wording is */
        /*      the right one:                                        */
        /*                                                            */
        /*        When the absolute difference between the value in   */
        /*        the table [CVT] and the measurement directly from   */
        /*        the outline is _greater_ than the cut_in value, the */
        /*        outline measurement is used.                        */
        /*                                                            */
        /*      This is from `instgly.doc'.  The description in       */
        /*      `ttinst2.doc', version 1.66, is thus incorrect since  */
        /*      it implies `>=' instead of `>'.                       */

        if ( FT_ABS( cvt_dist - org_dist ) > control_value_cutin )
          cvt_dist = org_dist;
      }

      distance = exc->func_round(
                   exc,
                   cvt_dist,
                   exc->tt_metrics.compensations[exc->opcode & 3] );
    }
    else
    {

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      /* do cvt cut-in always in MIRP for sph */
      if ( SUBPIXEL_HINTING_INFINALITY  &&
           exc->ignore_x_mode           &&
           exc->GS.gep0 == exc->GS.gep1 )
      {
        if ( FT_ABS( cvt_dist - org_dist ) > control_value_cutin )
          cvt_dist = org_dist;
      }
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      distance = Round_None(
                   exc,
                   cvt_dist,
                   exc->tt_metrics.compensations[exc->opcode & 3] );
    }

    /* minimum distance test */

    if ( ( exc->opcode & 8 ) != 0 )
    {
      if ( org_dist >= 0 )
      {
        if ( distance < minimum_distance )
          distance = minimum_distance;
      }
      else
      {
        if ( distance > -minimum_distance )
          distance = -minimum_distance;
      }
    }

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( SUBPIXEL_HINTING_INFINALITY )
    {
      B1 = exc->zp1.cur[point].y;

      /* Round moves if necessary */
      if ( exc->ignore_x_mode                                          &&
           exc->GS.freeVector.y != 0                                   &&
           ( exc->sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES ) )
        distance = FT_PIX_ROUND( B1 + distance - cur_dist ) - B1 + cur_dist;

      if ( exc->ignore_x_mode                                      &&
           exc->GS.freeVector.y != 0                               &&
           ( exc->opcode & 16 ) == 0                               &&
           ( exc->opcode & 8 ) == 0                                &&
           ( exc->sph_tweak_flags & SPH_TWEAK_COURIER_NEW_2_HACK ) )
        distance += 64;
    }
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    exc->func_move( exc, &exc->zp1, point, distance - cur_dist );

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( SUBPIXEL_HINTING_INFINALITY )
    {
      B2 = exc->zp1.cur[point].y;

      /* Reverse move if necessary */
      if ( exc->ignore_x_mode )
      {
        if ( exc->face->sph_compatibility_mode &&
             exc->GS.freeVector.y != 0         &&
             ( B1 & 63 ) == 0                  &&
             ( B2 & 63 ) != 0                  )
          reverse_move = TRUE;

        if ( ( exc->sph_tweak_flags & SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&
             exc->GS.freeVector.y != 0                                  &&
             ( B2 & 63 ) != 0                                           &&
             ( B1 & 63 ) != 0                                           )
          reverse_move = TRUE;
      }

      if ( reverse_move )
        exc->func_move( exc, &exc->zp1, point, -( distance - cur_dist ) );
    }

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

  Fail:
    exc->GS.rp1 = exc->GS.rp0;

    if ( ( exc->opcode & 16 ) != 0 )
      exc->GS.rp0 = point;

    exc->GS.rp2 = point;
  }


  /*************************************************************************/
  /*                                                                       */
  /* ALIGNRP[]:    ALIGN Relative Point                                    */
  /* Opcode range: 0x3C                                                    */
  /* Stack:        uint32 uint32... -->                                    */
  /*                                                                       */
  static void
  Ins_ALIGNRP( TT_ExecContext  exc )
  {
    FT_UShort   point;
    FT_F26Dot6  distance;


#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( SUBPIXEL_HINTING_INFINALITY                               &&
         exc->ignore_x_mode                                        &&
         exc->iup_called                                           &&
         ( exc->sph_tweak_flags & SPH_TWEAK_NO_ALIGNRP_AFTER_IUP ) )
    {
      exc->error = FT_THROW( Invalid_Reference );
      goto Fail;
    }
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    if ( exc->top < exc->GS.loop                  ||
         BOUNDS( exc->GS.rp0, exc->zp0.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      goto Fail;
    }

    while ( exc->GS.loop > 0 )
    {
      exc->args--;

      point = (FT_UShort)exc->stack[exc->args];

      if ( BOUNDS( point, exc->zp1.n_points ) )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = FT_THROW( Invalid_Reference );
          return;
        }
      }
      else
      {
        distance = PROJECT( exc->zp1.cur + point,
                            exc->zp0.cur + exc->GS.rp0 );

        exc->func_move( exc, &exc->zp1, point, -distance );
      }

      exc->GS.loop--;
    }

  Fail:
    exc->GS.loop = 1;
    exc->new_top = exc->args;
  }


  /*************************************************************************/
  /*                                                                       */
  /* ISECT[]:      moves point to InterSECTion                             */
  /* Opcode range: 0x0F                                                    */
  /* Stack:        5 * uint32 -->                                          */
  /*                                                                       */
  static void
  Ins_ISECT( TT_ExecContext  exc,
             FT_Long*        args )
  {
    FT_UShort   point,
                a0, a1,
                b0, b1;

    FT_F26Dot6  discriminant, dotproduct;

    FT_F26Dot6  dx,  dy,
                dax, day,
                dbx, dby;

    FT_F26Dot6  val;

    FT_Vector   R;


    point = (FT_UShort)args[0];

    a0 = (FT_UShort)args[1];
    a1 = (FT_UShort)args[2];
    b0 = (FT_UShort)args[3];
    b1 = (FT_UShort)args[4];

    if ( BOUNDS( b0,    exc->zp0.n_points ) ||
         BOUNDS( b1,    exc->zp0.n_points ) ||
         BOUNDS( a0,    exc->zp1.n_points ) ||
         BOUNDS( a1,    exc->zp1.n_points ) ||
         BOUNDS( point, exc->zp2.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    /* Cramer's rule */

    dbx = exc->zp0.cur[b1].x - exc->zp0.cur[b0].x;
    dby = exc->zp0.cur[b1].y - exc->zp0.cur[b0].y;

    dax = exc->zp1.cur[a1].x - exc->zp1.cur[a0].x;
    day = exc->zp1.cur[a1].y - exc->zp1.cur[a0].y;

    dx = exc->zp0.cur[b0].x - exc->zp1.cur[a0].x;
    dy = exc->zp0.cur[b0].y - exc->zp1.cur[a0].y;

    discriminant = FT_MulDiv( dax, -dby, 0x40 ) +
                   FT_MulDiv( day, dbx, 0x40 );
    dotproduct   = FT_MulDiv( dax, dbx, 0x40 ) +
                   FT_MulDiv( day, dby, 0x40 );

    /* The discriminant above is actually a cross product of vectors     */
    /* da and db. Together with the dot product, they can be used as     */
    /* surrogates for sine and cosine of the angle between the vectors.  */
    /* Indeed,                                                           */
    /*       dotproduct   = |da||db|cos(angle)                           */
    /*       discriminant = |da||db|sin(angle)     .                     */
    /* We use these equations to reject grazing intersections by         */
    /* thresholding abs(tan(angle)) at 1/19, corresponding to 3 degrees. */
    if ( 19 * FT_ABS( discriminant ) > FT_ABS( dotproduct ) )
    {
      val = FT_MulDiv( dx, -dby, 0x40 ) + FT_MulDiv( dy, dbx, 0x40 );

      R.x = FT_MulDiv( val, dax, discriminant );
      R.y = FT_MulDiv( val, day, discriminant );

      /* XXX: Block in backward_compatibility and/or post-IUP? */
      exc->zp2.cur[point].x = exc->zp1.cur[a0].x + R.x;
      exc->zp2.cur[point].y = exc->zp1.cur[a0].y + R.y;
    }
    else
    {
      /* else, take the middle of the middles of A and B */

      /* XXX: Block in backward_compatibility and/or post-IUP? */
      exc->zp2.cur[point].x = ( exc->zp1.cur[a0].x +
                                exc->zp1.cur[a1].x +
                                exc->zp0.cur[b0].x +
                                exc->zp0.cur[b1].x ) / 4;
      exc->zp2.cur[point].y = ( exc->zp1.cur[a0].y +
                                exc->zp1.cur[a1].y +
                                exc->zp0.cur[b0].y +
                                exc->zp0.cur[b1].y ) / 4;
    }

    exc->zp2.tags[point] |= FT_CURVE_TAG_TOUCH_BOTH;
  }


  /*************************************************************************/
  /*                                                                       */
  /* ALIGNPTS[]:   ALIGN PoinTS                                            */
  /* Opcode range: 0x27                                                    */
  /* Stack:        uint32 uint32 -->                                       */
  /*                                                                       */
  static void
  Ins_ALIGNPTS( TT_ExecContext  exc,
                FT_Long*        args )
  {
    FT_UShort   p1, p2;
    FT_F26Dot6  distance;


    p1 = (FT_UShort)args[0];
    p2 = (FT_UShort)args[1];

    if ( BOUNDS( p1, exc->zp1.n_points ) ||
         BOUNDS( p2, exc->zp0.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    distance = PROJECT( exc->zp0.cur + p2, exc->zp1.cur + p1 ) / 2;

    exc->func_move( exc, &exc->zp1, p1, distance );
    exc->func_move( exc, &exc->zp0, p2, -distance );
  }


  /*************************************************************************/
  /*                                                                       */
  /* IP[]:         Interpolate Point                                       */
  /* Opcode range: 0x39                                                    */
  /* Stack:        uint32... -->                                           */
  /*                                                                       */

  /* SOMETIMES, DUMBER CODE IS BETTER CODE */

  static void
  Ins_IP( TT_ExecContext  exc )
  {
    FT_F26Dot6  old_range, cur_range;
    FT_Vector*  orus_base;
    FT_Vector*  cur_base;
    FT_Int      twilight;


    if ( exc->top < exc->GS.loop )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      goto Fail;
    }

    /*
     * We need to deal in a special way with the twilight zone.
     * Otherwise, by definition, the value of exc->twilight.orus[n] is (0,0),
     * for every n.
     */
    twilight = ( exc->GS.gep0 == 0 ||
                 exc->GS.gep1 == 0 ||
                 exc->GS.gep2 == 0 );

    if ( BOUNDS( exc->GS.rp1, exc->zp0.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      goto Fail;
    }

    if ( twilight )
      orus_base = &exc->zp0.org[exc->GS.rp1];
    else
      orus_base = &exc->zp0.orus[exc->GS.rp1];

    cur_base = &exc->zp0.cur[exc->GS.rp1];

    /* XXX: There are some glyphs in some braindead but popular */
    /*      fonts out there (e.g. [aeu]grave in monotype.ttf)   */
    /*      calling IP[] with bad values of rp[12].             */
    /*      Do something sane when this odd thing happens.      */
    if ( BOUNDS( exc->GS.rp1, exc->zp0.n_points ) ||
         BOUNDS( exc->GS.rp2, exc->zp1.n_points ) )
    {
      old_range = 0;
      cur_range = 0;
    }
    else
    {
      if ( twilight )
        old_range = DUALPROJ( &exc->zp1.org[exc->GS.rp2], orus_base );
      else if ( exc->metrics.x_scale == exc->metrics.y_scale )
        old_range = DUALPROJ( &exc->zp1.orus[exc->GS.rp2], orus_base );
      else
      {
        FT_Vector  vec;


        vec.x = FT_MulFix( exc->zp1.orus[exc->GS.rp2].x - orus_base->x,
                           exc->metrics.x_scale );
        vec.y = FT_MulFix( exc->zp1.orus[exc->GS.rp2].y - orus_base->y,
                           exc->metrics.y_scale );

        old_range = FAST_DUALPROJ( &vec );
      }

      cur_range = PROJECT( &exc->zp1.cur[exc->GS.rp2], cur_base );
    }

    for ( ; exc->GS.loop > 0; exc->GS.loop-- )
    {
      FT_UInt     point = (FT_UInt)exc->stack[--exc->args];
      FT_F26Dot6  org_dist, cur_dist, new_dist;


      /* check point bounds */
      if ( BOUNDS( point, exc->zp2.n_points ) )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = FT_THROW( Invalid_Reference );
          return;
        }
        continue;
      }

      if ( twilight )
        org_dist = DUALPROJ( &exc->zp2.org[point], orus_base );
      else if ( exc->metrics.x_scale == exc->metrics.y_scale )
        org_dist = DUALPROJ( &exc->zp2.orus[point], orus_base );
      else
      {
        FT_Vector  vec;


        vec.x = FT_MulFix( exc->zp2.orus[point].x - orus_base->x,
                           exc->metrics.x_scale );
        vec.y = FT_MulFix( exc->zp2.orus[point].y - orus_base->y,
                           exc->metrics.y_scale );

        org_dist = FAST_DUALPROJ( &vec );
      }

      cur_dist = PROJECT( &exc->zp2.cur[point], cur_base );

      if ( org_dist )
      {
        if ( old_range )
          new_dist = FT_MulDiv( org_dist, cur_range, old_range );
        else
        {
          /* This is the same as what MS does for the invalid case:  */
          /*                                                         */
          /*   delta = (Original_Pt - Original_RP1) -                */
          /*           (Current_Pt - Current_RP1)         ;          */
          /*                                                         */
          /* In FreeType speak:                                      */
          /*                                                         */
          /*   delta = org_dist - cur_dist          .                */
          /*                                                         */
          /* We move `point' by `new_dist - cur_dist' after leaving  */
          /* this block, thus we have                                */
          /*                                                         */
          /*   new_dist - cur_dist = delta                   ,       */
          /*   new_dist - cur_dist = org_dist - cur_dist     ,       */
          /*              new_dist = org_dist                .       */

          new_dist = org_dist;
        }
      }
      else
        new_dist = 0;

      exc->func_move( exc,
                      &exc->zp2,
                      (FT_UShort)point,
                      new_dist - cur_dist );
    }

  Fail:
    exc->GS.loop = 1;
    exc->new_top = exc->args;
  }


  /*************************************************************************/
  /*                                                                       */
  /* UTP[a]:       UnTouch Point                                           */
  /* Opcode range: 0x29                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_UTP( TT_ExecContext  exc,
           FT_Long*        args )
  {
    FT_UShort  point;
    FT_Byte    mask;


    point = (FT_UShort)args[0];

    if ( BOUNDS( point, exc->zp0.n_points ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = FT_THROW( Invalid_Reference );
      return;
    }

    mask = 0xFF;

    if ( exc->GS.freeVector.x != 0 )
      mask &= ~FT_CURVE_TAG_TOUCH_X;

    if ( exc->GS.freeVector.y != 0 )
      mask &= ~FT_CURVE_TAG_TOUCH_Y;

    exc->zp0.tags[point] &= mask;
  }


  /* Local variables for Ins_IUP: */
  typedef struct  IUP_WorkerRec_
  {
    FT_Vector*  orgs;   /* original and current coordinate */
    FT_Vector*  curs;   /* arrays                          */
    FT_Vector*  orus;
    FT_UInt     max_points;

  } IUP_WorkerRec, *IUP_Worker;


  static void
  _iup_worker_shift( IUP_Worker  worker,
                     FT_UInt     p1,
                     FT_UInt     p2,
                     FT_UInt     p )
  {
    FT_UInt     i;
    FT_F26Dot6  dx;


    dx = worker->curs[p].x - worker->orgs[p].x;
    if ( dx != 0 )
    {
      for ( i = p1; i < p; i++ )
        worker->curs[i].x += dx;

      for ( i = p + 1; i <= p2; i++ )
        worker->curs[i].x += dx;
    }
  }


  static void
  _iup_worker_interpolate( IUP_Worker  worker,
                           FT_UInt     p1,
                           FT_UInt     p2,
                           FT_UInt     ref1,
                           FT_UInt     ref2 )
  {
    FT_UInt     i;
    FT_F26Dot6  orus1, orus2, org1, org2, cur1, cur2, delta1, delta2;


    if ( p1 > p2 )
      return;

    if ( BOUNDS( ref1, worker->max_points ) ||
         BOUNDS( ref2, worker->max_points ) )
      return;

    orus1 = worker->orus[ref1].x;
    orus2 = worker->orus[ref2].x;

    if ( orus1 > orus2 )
    {
      FT_F26Dot6  tmp_o;
      FT_UInt     tmp_r;


      tmp_o = orus1;
      orus1 = orus2;
      orus2 = tmp_o;

      tmp_r = ref1;
      ref1  = ref2;
      ref2  = tmp_r;
    }

    org1   = worker->orgs[ref1].x;
    org2   = worker->orgs[ref2].x;
    cur1   = worker->curs[ref1].x;
    cur2   = worker->curs[ref2].x;
    delta1 = cur1 - org1;
    delta2 = cur2 - org2;

    if ( cur1 == cur2 || orus1 == orus2 )
    {

      /* trivial snap or shift of untouched points */
      for ( i = p1; i <= p2; i++ )
      {
        FT_F26Dot6  x = worker->orgs[i].x;


        if ( x <= org1 )
          x += delta1;

        else if ( x >= org2 )
          x += delta2;

        else
          x = cur1;

        worker->curs[i].x = x;
      }
    }
    else
    {
      FT_Fixed  scale       = 0;
      FT_Bool   scale_valid = 0;


      /* interpolation */
      for ( i = p1; i <= p2; i++ )
      {
        FT_F26Dot6  x = worker->orgs[i].x;


        if ( x <= org1 )
          x += delta1;

        else if ( x >= org2 )
          x += delta2;

        else
        {
          if ( !scale_valid )
          {
            scale_valid = 1;
            scale       = FT_DivFix( cur2 - cur1, orus2 - orus1 );
          }

          x = cur1 + FT_MulFix( worker->orus[i].x - orus1, scale );
        }
        worker->curs[i].x = x;
      }
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* IUP[a]:       Interpolate Untouched Points                            */
  /* Opcode range: 0x30-0x31                                               */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_IUP( TT_ExecContext  exc )
  {
    IUP_WorkerRec  V;
    FT_Byte        mask;

    FT_UInt   first_point;   /* first point of contour        */
    FT_UInt   end_point;     /* end point (last+1) of contour */

    FT_UInt   first_touched; /* first touched point in contour   */
    FT_UInt   cur_touched;   /* current touched point in contour */

    FT_UInt   point;         /* current point   */
    FT_Short  contour;       /* current contour */


#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    /* See `ttinterp.h' for details on backward compatibility mode.  */
    /* Allow IUP until it has been called on both axes.  Immediately */
    /* return on subsequent ones.                                    */
    if ( SUBPIXEL_HINTING_MINIMAL    &&
         exc->backward_compatibility )
    {
      if ( exc->iupx_called && exc->iupy_called )
        return;

      if ( exc->opcode & 1 )
        exc->iupx_called = TRUE;
      else
        exc->iupy_called = TRUE;
    }
#endif

    /* ignore empty outlines */
    if ( exc->pts.n_contours == 0 )
      return;

    if ( exc->opcode & 1 )
    {
      mask   = FT_CURVE_TAG_TOUCH_X;
      V.orgs = exc->pts.org;
      V.curs = exc->pts.cur;
      V.orus = exc->pts.orus;
    }
    else
    {
      mask   = FT_CURVE_TAG_TOUCH_Y;
      V.orgs = (FT_Vector*)( (FT_Pos*)exc->pts.org + 1 );
      V.curs = (FT_Vector*)( (FT_Pos*)exc->pts.cur + 1 );
      V.orus = (FT_Vector*)( (FT_Pos*)exc->pts.orus + 1 );
    }
    V.max_points = exc->pts.n_points;

    contour = 0;
    point   = 0;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( SUBPIXEL_HINTING_INFINALITY &&
         exc->ignore_x_mode          )
    {
      exc->iup_called = TRUE;
      if ( exc->sph_tweak_flags & SPH_TWEAK_SKIP_IUP )
        return;
    }
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    do
    {
      end_point   = exc->pts.contours[contour] - exc->pts.first_point;
      first_point = point;

      if ( BOUNDS( end_point, exc->pts.n_points ) )
        end_point = exc->pts.n_points - 1;

      while ( point <= end_point && ( exc->pts.tags[point] & mask ) == 0 )
        point++;

      if ( point <= end_point )
      {
        first_touched = point;
        cur_touched   = point;

        point++;

        while ( point <= end_point )
        {
          if ( ( exc->pts.tags[point] & mask ) != 0 )
          {
            _iup_worker_interpolate( &V,
                                     cur_touched + 1,
                                     point - 1,
                                     cur_touched,
                                     point );
            cur_touched = point;
          }

          point++;
        }

        if ( cur_touched == first_touched )
          _iup_worker_shift( &V, first_point, end_point, cur_touched );
        else
        {
          _iup_worker_interpolate( &V,
                                   (FT_UShort)( cur_touched + 1 ),
                                   end_point,
                                   cur_touched,
                                   first_touched );

          if ( first_touched > 0 )
            _iup_worker_interpolate( &V,
                                     first_point,
                                     first_touched - 1,
                                     cur_touched,
                                     first_touched );
        }
      }
      contour++;
    } while ( contour < exc->pts.n_contours );
  }


  /*************************************************************************/
  /*                                                                       */
  /* DELTAPn[]:    DELTA exceptions P1, P2, P3                             */
  /* Opcode range: 0x5D,0x71,0x72                                          */
  /* Stack:        uint32 (2 * uint32)... -->                              */
  /*                                                                       */
  static void
  Ins_DELTAP( TT_ExecContext  exc,
              FT_Long*        args )
  {
    FT_ULong   nump, k;
    FT_UShort  A;
    FT_ULong   C, P;
    FT_Long    B;
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    FT_UShort  B1, B2;


    if ( SUBPIXEL_HINTING_INFINALITY                              &&
         exc->ignore_x_mode                                       &&
         exc->iup_called                                          &&
         ( exc->sph_tweak_flags & SPH_TWEAK_NO_DELTAP_AFTER_IUP ) )
      goto Fail;
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    P    = (FT_ULong)exc->func_cur_ppem( exc );
    nump = (FT_ULong)args[0];   /* some points theoretically may occur more
                                   than once, thus UShort isn't enough */

    for ( k = 1; k <= nump; k++ )
    {
      if ( exc->args < 2 )
      {
        if ( exc->pedantic_hinting )
          exc->error = FT_THROW( Too_Few_Arguments );
        exc->args = 0;
        goto Fail;
      }

      exc->args -= 2;

      A = (FT_UShort)exc->stack[exc->args + 1];
      B = exc->stack[exc->args];

      /* XXX: Because some popular fonts contain some invalid DeltaP */
      /*      instructions, we simply ignore them when the stacked   */
      /*      point reference is off limit, rather than returning an */
      /*      error.  As a delta instruction doesn't change a glyph  */
      /*      in great ways, this shouldn't be a problem.            */

      if ( !BOUNDS( A, exc->zp0.n_points ) )
      {
        C = ( (FT_ULong)B & 0xF0 ) >> 4;

        switch ( exc->opcode )
        {
        case 0x5D:
          break;

        case 0x71:
          C += 16;
          break;

        case 0x72:
          C += 32;
          break;
        }

        C += exc->GS.delta_base;

        if ( P == C )
        {
          B = ( (FT_ULong)B & 0xF ) - 8;
          if ( B >= 0 )
            B++;
          B *= 1L << ( 6 - exc->GS.delta_shift );

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

          if ( SUBPIXEL_HINTING_INFINALITY )
          {
            /*
             *  Allow delta move if
             *
             *  - not using ignore_x_mode rendering,
             *  - glyph is specifically set to allow it, or
             *  - glyph is composite and freedom vector is not in subpixel
             *    direction.
             */
            if ( !exc->ignore_x_mode                                   ||
                 ( exc->sph_tweak_flags & SPH_TWEAK_ALWAYS_DO_DELTAP ) ||
                 ( exc->is_composite && exc->GS.freeVector.y != 0 )    )
              exc->func_move( exc, &exc->zp0, A, B );

            /* Otherwise, apply subpixel hinting and compatibility mode */
            /* rules, always skipping deltas in subpixel direction.     */
            else if ( exc->ignore_x_mode && exc->GS.freeVector.y != 0 )
            {
              /* save the y value of the point now; compare after move */
              B1 = (FT_UShort)exc->zp0.cur[A].y;

              /* Standard subpixel hinting: Allow y move for y-touched */
              /* points.  This messes up DejaVu ...                    */
              if ( !exc->face->sph_compatibility_mode          &&
                   ( exc->zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y ) )
                exc->func_move( exc, &exc->zp0, A, B );

              /* compatibility mode */
              else if ( exc->face->sph_compatibility_mode                        &&
                        !( exc->sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP ) )
              {
                if ( exc->sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES )
                  B = FT_PIX_ROUND( B1 + B ) - B1;

                /* Allow delta move if using sph_compatibility_mode,   */
                /* IUP has not been called, and point is touched on Y. */
                if ( !exc->iup_called                            &&
                     ( exc->zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y ) )
                  exc->func_move( exc, &exc->zp0, A, B );
              }

              B2 = (FT_UShort)exc->zp0.cur[A].y;

              /* Reverse this move if it results in a disallowed move */
              if ( exc->GS.freeVector.y != 0                          &&
                   ( ( exc->face->sph_compatibility_mode          &&
                       ( B1 & 63 ) == 0                           &&
                       ( B2 & 63 ) != 0                           ) ||
                     ( ( exc->sph_tweak_flags                   &
                         SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES_DELTAP ) &&
                       ( B1 & 63 ) != 0                           &&
                       ( B2 & 63 ) != 0                           ) ) )
                exc->func_move( exc, &exc->zp0, A, -B );
            }
          }
          else
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

          {

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
            /* See `ttinterp.h' for details on backward compatibility */
            /* mode.                                                  */
            if ( SUBPIXEL_HINTING_MINIMAL    &&
                 exc->backward_compatibility )
            {
              if ( !( exc->iupx_called && exc->iupy_called )              &&
                   ( ( exc->is_composite && exc->GS.freeVector.y != 0 ) ||
                     ( exc->zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y )        ) )
                exc->func_move( exc, &exc->zp0, A, B );
            }
            else
#endif
              exc->func_move( exc, &exc->zp0, A, B );
          }
        }
      }
      else
        if ( exc->pedantic_hinting )
          exc->error = FT_THROW( Invalid_Reference );
    }

  Fail:
    exc->new_top = exc->args;
  }


  /*************************************************************************/
  /*                                                                       */
  /* DELTACn[]:    DELTA exceptions C1, C2, C3                             */
  /* Opcode range: 0x73,0x74,0x75                                          */
  /* Stack:        uint32 (2 * uint32)... -->                              */
  /*                                                                       */
  static void
  Ins_DELTAC( TT_ExecContext  exc,
              FT_Long*        args )
  {
    FT_ULong  nump, k;
    FT_ULong  A, C, P;
    FT_Long   B;


    P    = (FT_ULong)exc->func_cur_ppem( exc );
    nump = (FT_ULong)args[0];

    for ( k = 1; k <= nump; k++ )
    {
      if ( exc->args < 2 )
      {
        if ( exc->pedantic_hinting )
          exc->error = FT_THROW( Too_Few_Arguments );
        exc->args = 0;
        goto Fail;
      }

      exc->args -= 2;

      A = (FT_ULong)exc->stack[exc->args + 1];
      B = exc->stack[exc->args];

      if ( BOUNDSL( A, exc->cvtSize ) )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = FT_THROW( Invalid_Reference );
          return;
        }
      }
      else
      {
        C = ( (FT_ULong)B & 0xF0 ) >> 4;

        switch ( exc->opcode )
        {
        case 0x73:
          break;

        case 0x74:
          C += 16;
          break;

        case 0x75:
          C += 32;
          break;
        }

        C += exc->GS.delta_base;

        if ( P == C )
        {
          B = ( (FT_ULong)B & 0xF ) - 8;
          if ( B >= 0 )
            B++;
          B *= 1L << ( 6 - exc->GS.delta_shift );

          exc->func_move_cvt( exc, A, B );
        }
      }
    }

  Fail:
    exc->new_top = exc->args;
  }


  /*************************************************************************/
  /*                                                                       */
  /* MISC. INSTRUCTIONS                                                    */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* GETINFO[]:    GET INFOrmation                                         */
  /* Opcode range: 0x88                                                    */
  /* Stack:        uint32 --> uint32                                       */
  /*                                                                       */
  /* XXX: UNDOCUMENTED: Selector bits higher than 9 are currently (May     */
  /*      2015) not documented in the OpenType specification.              */
  /*                                                                       */
  /*      Selector bit 11 is incorrectly described as bit 8, while the     */
  /*      real meaning of bit 8 (vertical LCD subpixels) stays             */
  /*      undocumented.  The same mistake can be found in Greg Hitchcock's */
  /*      whitepaper.                                                      */
  /*                                                                       */
  static void
  Ins_GETINFO( TT_ExecContext  exc,
               FT_Long*        args )
  {
    FT_Long    K;
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( exc->face );


    K = 0;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    /********************************/
    /* RASTERIZER VERSION           */
    /* Selector Bit:  0             */
    /* Return Bit(s): 0-7           */
    /*                              */
    if ( SUBPIXEL_HINTING_INFINALITY &&
         ( args[0] & 1 ) != 0        &&
         exc->subpixel_hinting       )
    {
      if ( exc->ignore_x_mode )
      {
        /* if in ClearType backward compatibility mode,         */
        /* we sometimes change the TrueType version dynamically */
        K = exc->rasterizer_version;
        FT_TRACE6(( "Setting rasterizer version %d\n",
                    exc->rasterizer_version ));
      }
      else
        K = TT_INTERPRETER_VERSION_38;
    }
    else
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
      if ( ( args[0] & 1 ) != 0 )
        K = driver->interpreter_version;

    /********************************/
    /* GLYPH ROTATED                */
    /* Selector Bit:  1             */
    /* Return Bit(s): 8             */
    /*                              */
    if ( ( args[0] & 2 ) != 0 && exc->tt_metrics.rotated )
      K |= 1 << 8;

    /********************************/
    /* GLYPH STRETCHED              */
    /* Selector Bit:  2             */
    /* Return Bit(s): 9             */
    /*                              */
    if ( ( args[0] & 4 ) != 0 && exc->tt_metrics.stretched )
      K |= 1 << 9;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    /********************************/
    /* VARIATION GLYPH              */
    /* Selector Bit:  3             */
    /* Return Bit(s): 10            */
    /*                              */
    /* XXX: UNDOCUMENTED!           */
    if ( (args[0] & 8 ) != 0 && exc->face->blend )
      K |= 1 << 10;
#endif

    /********************************/
    /* BI-LEVEL HINTING AND         */
    /* GRAYSCALE RENDERING          */
    /* Selector Bit:  5             */
    /* Return Bit(s): 12            */
    /*                              */
    if ( ( args[0] & 32 ) != 0 && exc->grayscale )
      K |= 1 << 12;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    if ( SUBPIXEL_HINTING_MINIMAL )
    {
      /********************************/
      /* HINTING FOR SUBPIXEL         */
      /* Selector Bit:  6             */
      /* Return Bit(s): 13            */
      /*                              */
      /* v40 does subpixel hinting by default. */
      if ( ( args[0] & 64 ) != 0 )
        K |= 1 << 13;

      /********************************/
      /* VERTICAL LCD SUBPIXELS?      */
      /* Selector Bit:  8             */
      /* Return Bit(s): 15            */
      /*                              */
      if ( ( args[0] & 256 ) != 0 && exc->vertical_lcd_lean )
        K |= 1 << 15;

      /********************************/
      /* SUBPIXEL POSITIONED?         */
      /* Selector Bit:  10            */
      /* Return Bit(s): 17            */
      /*                              */
      /* XXX: FreeType supports it, dependent on what client does? */
      if ( ( args[0] & 1024 ) != 0 )
        K |= 1 << 17;

      /********************************/
      /* SYMMETRICAL SMOOTHING        */
      /* Selector Bit:  11            */
      /* Return Bit(s): 18            */
      /*                              */
      /* The only smoothing method FreeType supports unless someone sets */
      /* FT_LOAD_TARGET_MONO.                                            */
      if ( ( args[0] & 2048 ) != 0 )
        K |= 1 << 18;

      /********************************/
      /* CLEARTYPE HINTING AND        */
      /* GRAYSCALE RENDERING          */
      /* Selector Bit:  12            */
      /* Return Bit(s): 19            */
      /*                              */
      /* Grayscale rendering is what FreeType does anyway unless someone */
      /* sets FT_LOAD_TARGET_MONO or FT_LOAD_TARGET_LCD(_V)              */
      if ( ( args[0] & 4096 ) != 0 && exc->grayscale_cleartype )
        K |= 1 << 19;
    }
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

    if ( SUBPIXEL_HINTING_INFINALITY                          &&
         exc->rasterizer_version >= TT_INTERPRETER_VERSION_35 )
    {

      if ( exc->rasterizer_version >= 37 )
      {
        /********************************/
        /* HINTING FOR SUBPIXEL         */
        /* Selector Bit:  6             */
        /* Return Bit(s): 13            */
        /*                              */
        if ( ( args[0] & 64 ) != 0 && exc->subpixel_hinting )
          K |= 1 << 13;

        /********************************/
        /* COMPATIBLE WIDTHS ENABLED    */
        /* Selector Bit:  7             */
        /* Return Bit(s): 14            */
        /*                              */
        /* Functionality still needs to be added */
        if ( ( args[0] & 128 ) != 0 && exc->compatible_widths )
          K |= 1 << 14;

        /********************************/
        /* VERTICAL LCD SUBPIXELS?      */
        /* Selector Bit:  8             */
        /* Return Bit(s): 15            */
        /*                              */
        /* Functionality still needs to be added */
        if ( ( args[0] & 256 ) != 0 && exc->vertical_lcd )
          K |= 1 << 15;

        /********************************/
        /* HINTING FOR BGR?             */
        /* Selector Bit:  9             */
        /* Return Bit(s): 16            */
        /*                              */
        /* Functionality still needs to be added */
        if ( ( args[0] & 512 ) != 0 && exc->bgr )
          K |= 1 << 16;

        if ( exc->rasterizer_version >= 38 )
        {
          /********************************/
          /* SUBPIXEL POSITIONED?         */
          /* Selector Bit:  10            */
          /* Return Bit(s): 17            */
          /*                              */
          /* Functionality still needs to be added */
          if ( ( args[0] & 1024 ) != 0 && exc->subpixel_positioned )
            K |= 1 << 17;

          /********************************/
          /* SYMMETRICAL SMOOTHING        */
          /* Selector Bit:  11            */
          /* Return Bit(s): 18            */
          /*                              */
          /* Functionality still needs to be added */
          if ( ( args[0] & 2048 ) != 0 && exc->symmetrical_smoothing )
            K |= 1 << 18;

          /********************************/
          /* GRAY CLEARTYPE               */
          /* Selector Bit:  12            */
          /* Return Bit(s): 19            */
          /*                              */
          /* Functionality still needs to be added */
          if ( ( args[0] & 4096 ) != 0 && exc->gray_cleartype )
            K |= 1 << 19;
        }
      }
    }

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    args[0] = K;
  }


#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT

  /*************************************************************************/
  /*                                                                       */
  /* GETVARIATION[]: get normalized variation (blend) coordinates          */
  /* Opcode range: 0x91                                                    */
  /* Stack:        --> f2.14...                                            */
  /*                                                                       */
  /* XXX: UNDOCUMENTED!  There is no official documentation from Apple for */
  /*      this bytecode instruction.  Active only if a font has GX         */
  /*      variation axes.                                                  */
  /*                                                                       */
  static void
  Ins_GETVARIATION( TT_ExecContext  exc,
                    FT_Long*        args )
  {
    FT_UInt    num_axes = exc->face->blend->num_axis;
    FT_Fixed*  coords   = exc->face->blend->normalizedcoords;

    FT_UInt  i;


    if ( BOUNDS( num_axes, exc->stackSize + 1 - exc->top ) )
    {
      exc->error = FT_THROW( Stack_Overflow );
      return;
    }

    for ( i = 0; i < num_axes; i++ )
      args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */
  }


  /*************************************************************************/
  /*                                                                       */
  /* GETDATA[]:    no idea what this is good for                           */
  /* Opcode range: 0x92                                                    */
  /* Stack:        --> 17                                                  */
  /*                                                                       */
  /* XXX: UNDOCUMENTED!  There is no documentation from Apple for this     */
  /*      very weird bytecode instruction.                                 */
  /*                                                                       */
  static void
  Ins_GETDATA( FT_Long*  args )
  {
    args[0] = 17;
  }

#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */


  static void
  Ins_UNKNOWN( TT_ExecContext  exc )
  {
    TT_DefRecord*  def   = exc->IDefs;
    TT_DefRecord*  limit = def + exc->numIDefs;


    for ( ; def < limit; def++ )
    {
      if ( (FT_Byte)def->opc == exc->opcode && def->active )
      {
        TT_CallRec*  call;


        if ( exc->callTop >= exc->callSize )
        {
          exc->error = FT_THROW( Stack_Overflow );
          return;
        }

        call = exc->callStack + exc->callTop++;

        call->Caller_Range = exc->curRange;
        call->Caller_IP    = exc->IP + 1;
        call->Cur_Count    = 1;
        call->Def          = def;

        Ins_Goto_CodeRange( exc, def->range, def->start );

        exc->step_ins = FALSE;
        return;
      }
    }

    exc->error = FT_THROW( Invalid_Opcode );
  }


  /*************************************************************************/
  /*                                                                       */
  /* RUN                                                                   */
  /*                                                                       */
  /*  This function executes a run of opcodes.  It will exit in the        */
  /*  following cases:                                                     */
  /*                                                                       */
  /*  - Errors (in which case it returns FALSE).                           */
  /*                                                                       */
  /*  - Reaching the end of the main code range (returns TRUE).            */
  /*    Reaching the end of a code range within a function call is an      */
  /*    error.                                                             */
  /*                                                                       */
  /*  - After executing one single opcode, if the flag `Instruction_Trap'  */
  /*    is set to TRUE (returns TRUE).                                     */
  /*                                                                       */
  /*  On exit with TRUE, test IP < CodeSize to know whether it comes from  */
  /*  an instruction trap or a normal termination.                         */
  /*                                                                       */
  /*                                                                       */
  /*  Note: The documented DEBUG opcode pops a value from the stack.  This */
  /*        behaviour is unsupported; here a DEBUG opcode is always an     */
  /*        error.                                                         */
  /*                                                                       */
  /*                                                                       */
  /* THIS IS THE INTERPRETER'S MAIN LOOP.                                  */
  /*                                                                       */
  /*************************************************************************/


  /* documentation is in ttinterp.h */

  FT_EXPORT_DEF( FT_Error )
  TT_RunIns( TT_ExecContext  exc )
  {
    FT_ULong   ins_counter = 0;  /* executed instructions counter */
    FT_ULong   num_twilight_points;
    FT_UShort  i;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    FT_Byte    opcode_pattern[1][2] = {
                  /* #8 TypeMan Talk Align */
                  {
                    0x06, /* SPVTL   */
                    0x7D, /* RDTG    */
                  },
                };
    FT_UShort  opcode_patterns   = 1;
    FT_UShort  opcode_pointer[1] = { 0 };
    FT_UShort  opcode_size[1]    = { 1 };
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */


#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    exc->iup_called = FALSE;
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    /* Toggle backward compatibility according to what font says, except   */
    /* when it's a `tricky' font that heavily relies on the interpreter to */
    /* render glyphs correctly, e.g. DFKai-SB.  Backward compatibility     */
    /* hacks may break it.                                                 */
    if ( SUBPIXEL_HINTING_MINIMAL          &&
         !FT_IS_TRICKY( &exc->face->root ) )
      exc->backward_compatibility = !( exc->GS.instruct_control & 4 );
    else
      exc->backward_compatibility = FALSE;

    exc->iupx_called = FALSE;
    exc->iupy_called = FALSE;
#endif

    /* We restrict the number of twilight points to a reasonable,     */
    /* heuristic value to avoid slow execution of malformed bytecode. */
    num_twilight_points = FT_MAX( 30,
                                  2 * ( exc->pts.n_points + exc->cvtSize ) );
    if ( exc->twilight.n_points > num_twilight_points )
    {
      if ( num_twilight_points > 0xFFFFU )
        num_twilight_points = 0xFFFFU;

      FT_TRACE5(( "TT_RunIns: Resetting number of twilight points\n"
                  "           from %d to the more reasonable value %d\n",
                  exc->twilight.n_points,
                  num_twilight_points ));
      exc->twilight.n_points = (FT_UShort)num_twilight_points;
    }

    /* Set up loop detectors.  We restrict the number of LOOPCALL loops */
    /* and the number of JMPR, JROT, and JROF calls with a negative     */
    /* argument to values that depend on various parameters like the    */
    /* size of the CVT table or the number of points in the current     */
    /* glyph (if applicable).                                           */
    /*                                                                  */
    /* The idea is that in real-world bytecode you either iterate over  */
    /* all CVT entries (in the `prep' table), or over all points (or    */
    /* contours, in the `glyf' table) of a glyph, and such iterations   */
    /* don't happen very often.                                         */
    exc->loopcall_counter = 0;
    exc->neg_jump_counter = 0;

    /* The maximum values are heuristic. */
    if ( exc->pts.n_points )
      exc->loopcall_counter_max = FT_MAX( 50,
                                          10 * exc->pts.n_points ) +
                                  FT_MAX( 50,
                                          exc->cvtSize / 10 );
    else
      exc->loopcall_counter_max = FT_MAX( 100,
                                          10 * exc->cvtSize );

    /* as a protection against an unreasonable number of CVT entries  */
    /* we assume at most 100 control values per glyph for the counter */
    if ( exc->loopcall_counter_max >
         100 * (FT_ULong)exc->face->root.num_glyphs )
      exc->loopcall_counter_max = 100 * (FT_ULong)exc->face->root.num_glyphs;

    FT_TRACE5(( "TT_RunIns: Limiting total number of loops in LOOPCALL"
                " to %d\n", exc->loopcall_counter_max ));

    exc->neg_jump_counter_max = exc->loopcall_counter_max;
    FT_TRACE5(( "TT_RunIns: Limiting total number of backward jumps"
                " to %d\n", exc->neg_jump_counter_max ));

    /* set PPEM and CVT functions */
    exc->tt_metrics.ratio = 0;
    if ( exc->metrics.x_ppem != exc->metrics.y_ppem )
    {
      /* non-square pixels, use the stretched routines */
      exc->func_cur_ppem  = Current_Ppem_Stretched;
      exc->func_read_cvt  = Read_CVT_Stretched;
      exc->func_write_cvt = Write_CVT_Stretched;
      exc->func_move_cvt  = Move_CVT_Stretched;
    }
    else
    {
      /* square pixels, use normal routines */
      exc->func_cur_ppem  = Current_Ppem;
      exc->func_read_cvt  = Read_CVT;
      exc->func_write_cvt = Write_CVT;
      exc->func_move_cvt  = Move_CVT;
    }

    Compute_Funcs( exc );
    Compute_Round( exc, (FT_Byte)exc->GS.round_state );

    do
    {
      exc->opcode = exc->code[exc->IP];

#ifdef FT_DEBUG_LEVEL_TRACE
      {
        FT_Long  cnt = FT_MIN( 8, exc->top );
        FT_Long  n;


        /* if tracing level is 7, show current code position */
        /* and the first few stack elements also             */
        FT_TRACE6(( "  " ));
        FT_TRACE7(( "%06d ", exc->IP ));
        FT_TRACE6(( opcode_name[exc->opcode] + 2 ));
        FT_TRACE7(( "%*s", *opcode_name[exc->opcode] == 'A'
                              ? 2
                              : 12 - ( *opcode_name[exc->opcode] - '0' ),
                              "#" ));
        for ( n = 1; n <= cnt; n++ )
          FT_TRACE7(( " %d", exc->stack[exc->top - n] ));
        FT_TRACE6(( "\n" ));
      }
#endif /* FT_DEBUG_LEVEL_TRACE */

      if ( ( exc->length = opcode_length[exc->opcode] ) < 0 )
      {
        if ( exc->IP + 1 >= exc->codeSize )
          goto LErrorCodeOverflow_;

        exc->length = 2 - exc->length * exc->code[exc->IP + 1];
      }

      if ( exc->IP + exc->length > exc->codeSize )
        goto LErrorCodeOverflow_;

      /* First, let's check for empty stack and overflow */
      exc->args = exc->top - ( Pop_Push_Count[exc->opcode] >> 4 );

      /* `args' is the top of the stack once arguments have been popped. */
      /* One can also interpret it as the index of the last argument.    */
      if ( exc->args < 0 )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = FT_THROW( Too_Few_Arguments );
          goto LErrorLabel_;
        }

        /* push zeroes onto the stack */
        for ( i = 0; i < Pop_Push_Count[exc->opcode] >> 4; i++ )
          exc->stack[i] = 0;
        exc->args = 0;
      }

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
      if ( exc->opcode == 0x91 )
      {
        /* this is very special: GETVARIATION returns */
        /* a variable number of arguments             */

        /* it is the job of the application to `activate' GX handling, */
        /* this is, calling any of the GX API functions on the current */
        /* font to select a variation instance                         */
        if ( exc->face->blend )
          exc->new_top = exc->args + exc->face->blend->num_axis;
      }
      else
#endif
        exc->new_top = exc->args + ( Pop_Push_Count[exc->opcode] & 15 );

      /* `new_top' is the new top of the stack, after the instruction's */
      /* execution.  `top' will be set to `new_top' after the `switch'  */
      /* statement.                                                     */
      if ( exc->new_top > exc->stackSize )
      {
        exc->error = FT_THROW( Stack_Overflow );
        goto LErrorLabel_;
      }

      exc->step_ins = TRUE;
      exc->error    = FT_Err_Ok;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( SUBPIXEL_HINTING_INFINALITY )
      {
        for ( i = 0; i < opcode_patterns; i++ )
        {
          if ( opcode_pointer[i] < opcode_size[i]                  &&
               exc->opcode == opcode_pattern[i][opcode_pointer[i]] )
          {
            opcode_pointer[i] += 1;

            if ( opcode_pointer[i] == opcode_size[i] )
            {
              FT_TRACE6(( "sph: opcode ptrn: %d, %s %s\n",
                          i,
                          exc->face->root.family_name,
                          exc->face->root.style_name ));

              switch ( i )
              {
              case 0:
                break;
              }
              opcode_pointer[i] = 0;
            }
          }
          else
            opcode_pointer[i] = 0;
        }
      }

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      {
        FT_Long*  args   = exc->stack + exc->args;
        FT_Byte   opcode = exc->opcode;


        switch ( opcode )
        {
        case 0x00:  /* SVTCA y  */
        case 0x01:  /* SVTCA x  */
        case 0x02:  /* SPvTCA y */
        case 0x03:  /* SPvTCA x */
        case 0x04:  /* SFvTCA y */
        case 0x05:  /* SFvTCA x */
          Ins_SxyTCA( exc );
          break;

        case 0x06:  /* SPvTL // */
        case 0x07:  /* SPvTL +  */
          Ins_SPVTL( exc, args );
          break;

        case 0x08:  /* SFvTL // */
        case 0x09:  /* SFvTL +  */
          Ins_SFVTL( exc, args );
          break;

        case 0x0A:  /* SPvFS */
          Ins_SPVFS( exc, args );
          break;

        case 0x0B:  /* SFvFS */
          Ins_SFVFS( exc, args );
          break;

        case 0x0C:  /* GPv */
          Ins_GPV( exc, args );
          break;

        case 0x0D:  /* GFv */
          Ins_GFV( exc, args );
          break;

        case 0x0E:  /* SFvTPv */
          Ins_SFVTPV( exc );
          break;

        case 0x0F:  /* ISECT  */
          Ins_ISECT( exc, args );
          break;

        case 0x10:  /* SRP0 */
          Ins_SRP0( exc, args );
          break;

        case 0x11:  /* SRP1 */
          Ins_SRP1( exc, args );
          break;

        case 0x12:  /* SRP2 */
          Ins_SRP2( exc, args );
          break;

        case 0x13:  /* SZP0 */
          Ins_SZP0( exc, args );
          break;

        case 0x14:  /* SZP1 */
          Ins_SZP1( exc, args );
          break;

        case 0x15:  /* SZP2 */
          Ins_SZP2( exc, args );
          break;

        case 0x16:  /* SZPS */
          Ins_SZPS( exc, args );
          break;

        case 0x17:  /* SLOOP */
          Ins_SLOOP( exc, args );
          break;

        case 0x18:  /* RTG */
          Ins_RTG( exc );
          break;

        case 0x19:  /* RTHG */
          Ins_RTHG( exc );
          break;

        case 0x1A:  /* SMD */
          Ins_SMD( exc, args );
          break;

        case 0x1B:  /* ELSE */
          Ins_ELSE( exc );
          break;

        case 0x1C:  /* JMPR */
          Ins_JMPR( exc, args );
          break;

        case 0x1D:  /* SCVTCI */
          Ins_SCVTCI( exc, args );
          break;

        case 0x1E:  /* SSWCI */
          Ins_SSWCI( exc, args );
          break;

        case 0x1F:  /* SSW */
          Ins_SSW( exc, args );
          break;

        case 0x20:  /* DUP */
          Ins_DUP( args );
          break;

        case 0x21:  /* POP */
          Ins_POP();
          break;

        case 0x22:  /* CLEAR */
          Ins_CLEAR( exc );
          break;

        case 0x23:  /* SWAP */
          Ins_SWAP( args );
          break;

        case 0x24:  /* DEPTH */
          Ins_DEPTH( exc, args );
          break;

        case 0x25:  /* CINDEX */
          Ins_CINDEX( exc, args );
          break;

        case 0x26:  /* MINDEX */
          Ins_MINDEX( exc, args );
          break;

        case 0x27:  /* ALIGNPTS */
          Ins_ALIGNPTS( exc, args );
          break;

        case 0x28:  /* RAW */
          Ins_UNKNOWN( exc );
          break;

        case 0x29:  /* UTP */
          Ins_UTP( exc, args );
          break;

        case 0x2A:  /* LOOPCALL */
          Ins_LOOPCALL( exc, args );
          break;

        case 0x2B:  /* CALL */
          Ins_CALL( exc, args );
          break;

        case 0x2C:  /* FDEF */
          Ins_FDEF( exc, args );
          break;

        case 0x2D:  /* ENDF */
          Ins_ENDF( exc );
          break;

        case 0x2E:  /* MDAP */
        case 0x2F:  /* MDAP */
          Ins_MDAP( exc, args );
          break;

        case 0x30:  /* IUP */
        case 0x31:  /* IUP */
          Ins_IUP( exc );
          break;

        case 0x32:  /* SHP */
        case 0x33:  /* SHP */
          Ins_SHP( exc );
          break;

        case 0x34:  /* SHC */
        case 0x35:  /* SHC */
          Ins_SHC( exc, args );
          break;

        case 0x36:  /* SHZ */
        case 0x37:  /* SHZ */
          Ins_SHZ( exc, args );
          break;

        case 0x38:  /* SHPIX */
          Ins_SHPIX( exc, args );
          break;

        case 0x39:  /* IP    */
          Ins_IP( exc );
          break;

        case 0x3A:  /* MSIRP */
        case 0x3B:  /* MSIRP */
          Ins_MSIRP( exc, args );
          break;

        case 0x3C:  /* AlignRP */
          Ins_ALIGNRP( exc );
          break;

        case 0x3D:  /* RTDG */
          Ins_RTDG( exc );
          break;

        case 0x3E:  /* MIAP */
        case 0x3F:  /* MIAP */
          Ins_MIAP( exc, args );
          break;

        case 0x40:  /* NPUSHB */
          Ins_NPUSHB( exc, args );
          break;

        case 0x41:  /* NPUSHW */
          Ins_NPUSHW( exc, args );
          break;

        case 0x42:  /* WS */
          Ins_WS( exc, args );
          break;

        case 0x43:  /* RS */
          Ins_RS( exc, args );
          break;

        case 0x44:  /* WCVTP */
          Ins_WCVTP( exc, args );
          break;

        case 0x45:  /* RCVT */
          Ins_RCVT( exc, args );
          break;

        case 0x46:  /* GC */
        case 0x47:  /* GC */
          Ins_GC( exc, args );
          break;

        case 0x48:  /* SCFS */
          Ins_SCFS( exc, args );
          break;

        case 0x49:  /* MD */
        case 0x4A:  /* MD */
          Ins_MD( exc, args );
          break;

        case 0x4B:  /* MPPEM */
          Ins_MPPEM( exc, args );
          break;

        case 0x4C:  /* MPS */
          Ins_MPS( exc, args );
          break;

        case 0x4D:  /* FLIPON */
          Ins_FLIPON( exc );
          break;

        case 0x4E:  /* FLIPOFF */
          Ins_FLIPOFF( exc );
          break;

        case 0x4F:  /* DEBUG */
          Ins_DEBUG( exc );
          break;

        case 0x50:  /* LT */
          Ins_LT( args );
          break;

        case 0x51:  /* LTEQ */
          Ins_LTEQ( args );
          break;

        case 0x52:  /* GT */
          Ins_GT( args );
          break;

        case 0x53:  /* GTEQ */
          Ins_GTEQ( args );
          break;

        case 0x54:  /* EQ */
          Ins_EQ( args );
          break;

        case 0x55:  /* NEQ */
          Ins_NEQ( args );
          break;

        case 0x56:  /* ODD */
          Ins_ODD( exc, args );
          break;

        case 0x57:  /* EVEN */
          Ins_EVEN( exc, args );
          break;

        case 0x58:  /* IF */
          Ins_IF( exc, args );
          break;

        case 0x59:  /* EIF */
          Ins_EIF();
          break;

        case 0x5A:  /* AND */
          Ins_AND( args );
          break;

        case 0x5B:  /* OR */
          Ins_OR( args );
          break;

        case 0x5C:  /* NOT */
          Ins_NOT( args );
          break;

        case 0x5D:  /* DELTAP1 */
          Ins_DELTAP( exc, args );
          break;

        case 0x5E:  /* SDB */
          Ins_SDB( exc, args );
          break;

        case 0x5F:  /* SDS */
          Ins_SDS( exc, args );
          break;

        case 0x60:  /* ADD */
          Ins_ADD( args );
          break;

        case 0x61:  /* SUB */
          Ins_SUB( args );
          break;

        case 0x62:  /* DIV */
          Ins_DIV( exc, args );
          break;

        case 0x63:  /* MUL */
          Ins_MUL( args );
          break;

        case 0x64:  /* ABS */
          Ins_ABS( args );
          break;

        case 0x65:  /* NEG */
          Ins_NEG( args );
          break;

        case 0x66:  /* FLOOR */
          Ins_FLOOR( args );
          break;

        case 0x67:  /* CEILING */
          Ins_CEILING( args );
          break;

        case 0x68:  /* ROUND */
        case 0x69:  /* ROUND */
        case 0x6A:  /* ROUND */
        case 0x6B:  /* ROUND */
          Ins_ROUND( exc, args );
          break;

        case 0x6C:  /* NROUND */
        case 0x6D:  /* NROUND */
        case 0x6E:  /* NRRUND */
        case 0x6F:  /* NROUND */
          Ins_NROUND( exc, args );
          break;

        case 0x70:  /* WCVTF */
          Ins_WCVTF( exc, args );
          break;

        case 0x71:  /* DELTAP2 */
        case 0x72:  /* DELTAP3 */
          Ins_DELTAP( exc, args );
          break;

        case 0x73:  /* DELTAC0 */
        case 0x74:  /* DELTAC1 */
        case 0x75:  /* DELTAC2 */
          Ins_DELTAC( exc, args );
          break;

        case 0x76:  /* SROUND */
          Ins_SROUND( exc, args );
          break;

        case 0x77:  /* S45Round */
          Ins_S45ROUND( exc, args );
          break;

        case 0x78:  /* JROT */
          Ins_JROT( exc, args );
          break;

        case 0x79:  /* JROF */
          Ins_JROF( exc, args );
          break;

        case 0x7A:  /* ROFF */
          Ins_ROFF( exc );
          break;

        case 0x7B:  /* ???? */
          Ins_UNKNOWN( exc );
          break;

        case 0x7C:  /* RUTG */
          Ins_RUTG( exc );
          break;

        case 0x7D:  /* RDTG */
          Ins_RDTG( exc );
          break;

        case 0x7E:  /* SANGW */
          Ins_SANGW();
          break;

        case 0x7F:  /* AA */
          Ins_AA();
          break;

        case 0x80:  /* FLIPPT */
          Ins_FLIPPT( exc );
          break;

        case 0x81:  /* FLIPRGON */
          Ins_FLIPRGON( exc, args );
          break;

        case 0x82:  /* FLIPRGOFF */
          Ins_FLIPRGOFF( exc, args );
          break;

        case 0x83:  /* UNKNOWN */
        case 0x84:  /* UNKNOWN */
          Ins_UNKNOWN( exc );
          break;

        case 0x85:  /* SCANCTRL */
          Ins_SCANCTRL( exc, args );
          break;

        case 0x86:  /* SDPvTL */
        case 0x87:  /* SDPvTL */
          Ins_SDPVTL( exc, args );
          break;

        case 0x88:  /* GETINFO */
          Ins_GETINFO( exc, args );
          break;

        case 0x89:  /* IDEF */
          Ins_IDEF( exc, args );
          break;

        case 0x8A:  /* ROLL */
          Ins_ROLL( args );
          break;

        case 0x8B:  /* MAX */
          Ins_MAX( args );
          break;

        case 0x8C:  /* MIN */
          Ins_MIN( args );
          break;

        case 0x8D:  /* SCANTYPE */
          Ins_SCANTYPE( exc, args );
          break;

        case 0x8E:  /* INSTCTRL */
          Ins_INSTCTRL( exc, args );
          break;

        case 0x8F:  /* ADJUST */
        case 0x90:  /* ADJUST */
          Ins_UNKNOWN( exc );
          break;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
        case 0x91:
          /* it is the job of the application to `activate' GX handling, */
          /* this is, calling any of the GX API functions on the current */
          /* font to select a variation instance                         */
          if ( exc->face->blend )
            Ins_GETVARIATION( exc, args );
          else
            Ins_UNKNOWN( exc );
          break;

        case 0x92:
          /* there is at least one MS font (LaoUI.ttf version 5.01) that */
          /* uses IDEFs for 0x91 and 0x92; for this reason we activate   */
          /* GETDATA for GX fonts only, similar to GETVARIATION          */
          if ( exc->face->blend )
            Ins_GETDATA( args );
          else
            Ins_UNKNOWN( exc );
          break;
#endif

        default:
          if ( opcode >= 0xE0 )
            Ins_MIRP( exc, args );
          else if ( opcode >= 0xC0 )
            Ins_MDRP( exc, args );
          else if ( opcode >= 0xB8 )
            Ins_PUSHW( exc, args );
          else if ( opcode >= 0xB0 )
            Ins_PUSHB( exc, args );
          else
            Ins_UNKNOWN( exc );
        }
      }

      if ( exc->error )
      {
        switch ( exc->error )
        {
          /* looking for redefined instructions */
        case FT_ERR( Invalid_Opcode ):
          {
            TT_DefRecord*  def   = exc->IDefs;
            TT_DefRecord*  limit = def + exc->numIDefs;


            for ( ; def < limit; def++ )
            {
              if ( def->active && exc->opcode == (FT_Byte)def->opc )
              {
                TT_CallRec*  callrec;


                if ( exc->callTop >= exc->callSize )
                {
                  exc->error = FT_THROW( Invalid_Reference );
                  goto LErrorLabel_;
                }

                callrec = &exc->callStack[exc->callTop];

                callrec->Caller_Range = exc->curRange;
                callrec->Caller_IP    = exc->IP + 1;
                callrec->Cur_Count    = 1;
                callrec->Def          = def;

                if ( Ins_Goto_CodeRange( exc,
                                         def->range,
                                         def->start ) == FAILURE )
                  goto LErrorLabel_;

                goto LSuiteLabel_;
              }
            }
          }

          exc->error = FT_THROW( Invalid_Opcode );
          goto LErrorLabel_;

#if 0
          break;   /* Unreachable code warning suppression.             */
                   /* Leave to remind in case a later change the editor */
                   /* to consider break;                                */
#endif

        default:
          goto LErrorLabel_;

#if 0
        break;
#endif
        }
      }

      exc->top = exc->new_top;

      if ( exc->step_ins )
        exc->IP += exc->length;

      /* increment instruction counter and check if we didn't */
      /* run this program for too long (e.g. infinite loops). */
      if ( ++ins_counter > TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES )
        return FT_THROW( Execution_Too_Long );

    LSuiteLabel_:
      if ( exc->IP >= exc->codeSize )
      {
        if ( exc->callTop > 0 )
        {
          exc->error = FT_THROW( Code_Overflow );
          goto LErrorLabel_;
        }
        else
          goto LNo_Error_;
      }
    } while ( !exc->instruction_trap );

  LNo_Error_:
    FT_TRACE4(( "  %d instructions executed\n", ins_counter ));
    return FT_Err_Ok;

  LErrorCodeOverflow_:
    exc->error = FT_THROW( Code_Overflow );

  LErrorLabel_:
    if ( exc->error && !exc->instruction_trap )
      FT_TRACE1(( "  The interpreter returned error 0x%x\n", exc->error ));

    return exc->error;
  }

#else /* !TT_USE_BYTECODE_INTERPRETER */

  /* ANSI C doesn't like empty source files */
  typedef int  _tt_interp_dummy;

#endif /* !TT_USE_BYTECODE_INTERPRETER */


/* END */
@


1.30
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2016 by                                                 */
d405 1
a405 1
      exec->metrics    = size->metrics;
d1659 1
a1659 1
  /*    See `ttinterp.h' for details on backwards compatibility mode.      */
d1687 1
a1687 1
      if ( SUBPIXEL_HINTING_MINIMAL && !exc->backwards_compatibility )
d1703 4
a1706 4
      if ( !( SUBPIXEL_HINTING_MINIMAL     &&
              exc->backwards_compatibility &&
              exc->iupx_called             &&
              exc->iupy_called             ) )
d1759 1
a1759 1
  /*   See `ttinterp.h' for details on backwards compatibility mode.       */
d1777 1
a1777 1
    if ( SUBPIXEL_HINTING_MINIMAL && !exc->backwards_compatibility )
d1799 1
a1799 1
            exc->backwards_compatibility         &&
d3567 7
d4000 7
d5129 1
a5129 1
      /* Native ClearType fonts sign a waiver that turns off all backwards */
d5133 1
a5133 1
        exc->backwards_compatibility = !FT_BOOL( L == 4 );
d5221 5
a5225 5
    /* See `ttinterp.h' for details on backwards compatibility mode. */
    if ( SUBPIXEL_HINTING_MINIMAL     &&
         exc->backwards_compatibility &&
         exc->iupx_called             &&
         exc->iupy_called             )
d5276 5
a5280 5
    /* See `ttinterp.h' for details on backwards compatibility mode. */
    if ( SUBPIXEL_HINTING_MINIMAL     &&
         exc->backwards_compatibility &&
         exc->iupx_called             &&
         exc->iupy_called             )
d5314 5
a5318 5
    /* See `ttinterp.h' for details on backwards compatibility mode. */
    if ( SUBPIXEL_HINTING_MINIMAL     &&
         exc->backwards_compatibility &&
         exc->iupx_called             &&
         exc->iupy_called             )
d5381 1
a5381 1
  /* See `ttinterp.h' for details on backwards compatibility mode. */
d5392 2
a5393 2
      if ( !( SUBPIXEL_HINTING_MINIMAL     &&
              exc->backwards_compatibility ) )
d5404 4
a5407 4
      if ( !( SUBPIXEL_HINTING_MINIMAL     &&
              exc->backwards_compatibility &&
              exc->iupx_called             &&
              exc->iupy_called             ) )
d5704 2
a5705 2
      if ( SUBPIXEL_HINTING_MINIMAL     &&
           exc->backwards_compatibility )
d5710 2
a5711 2
        /* that would glitch severly after calling ALIGNRP after a blocked */
        /* SHPIX.                                                          */
d6469 1
a6469 1
      /* XXX: Block in backwards_compatibility and/or post-IUP? */
d6477 1
a6477 1
      /* XXX: Block in backwards_compatibility and/or post-IUP? */
d6869 1
a6869 1
    /* See `ttinterp.h' for details on backwards compatibility mode. */
d6872 2
a6873 2
    if ( SUBPIXEL_HINTING_MINIMAL     &&
         exc->backwards_compatibility )
d7115 4
a7118 4
            /* See `ttinterp.h' for details on backwards compatibility */
            /* mode.                                                   */
            if ( SUBPIXEL_HINTING_MINIMAL     &&
                 exc->backwards_compatibility )
d7262 1
a7262 1
        /* if in ClearType backwards compatibility mode,        */
d7592 1
a7592 1
    /* Toggle backwards compatibility according to what font says, except  */
d7594 1
a7594 1
    /* render glyphs correctly, e.g. DFKai-SB.  Backwards compatibility    */
d7598 1
a7598 1
      exc->backwards_compatibility = !( exc->GS.instruct_control & 4 );
d7600 1
a7600 1
      exc->backwards_compatibility = FALSE;
d7622 10
a7631 8
    /* Set up loop detectors.  We restrict the number of LOOPCALL loops  */
    /* and the number of JMPR, JROT, and JROF calls with a negative      */
    /* argument to values that depend on the size of the CVT table and   */
    /* the number of points in the current glyph (if applicable).        */
    /*                                                                   */
    /* The idea is that in real-world bytecode you either iterate over   */
    /* all CVT entries, or over all points (or contours) of a glyph, and */
    /* such iterations don't happen very often.                          */
d7636 15
a7650 3
    exc->loopcall_counter_max = FT_MAX( 100,
                                        10 * ( exc->pts.n_points +
                                               exc->cvtSize ) );
d8425 1
a8425 7
    /* If any errors have occurred, function tables may be broken. */
    /* Force a re-execution of `prep' and `fpgm' tables if no      */
    /* bytecode debugger is run.                                   */
    if ( exc->error                          &&
         !exc->instruction_trap              &&
         exc->curRange == tt_coderange_glyph )
    {
a8426 3
      exc->size->bytecode_ready = -1;
      exc->size->cvt_ready      = -1;
    }
d8431 4
d8436 1
a8436 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
@


1.29
log
@
Update to FreeType 2.7

Now Subpixel hinting, also known as ClearType hinting, is enabled
by default.

OK matthieu@@
@
text
@d132 1
a132 1
    FT_ASSERT( coderange->base != NULL );
d426 1
a426 1
      ft_memset( &exec->zp0, 0, sizeof ( exec->zp0 ) );
d1616 1
a1616 1
    if ( range->base == NULL )     /* invalid coderange */
d3391 1
d3393 3
d3400 1
d3402 3
d3406 6
d3966 4
d5176 1
a5176 1
  /* Stack:        uint32? -->                                             */
d5183 1
a5183 1
      exc->GS.scan_type = (FT_Int)args[0];
d5580 3
a5582 3
    FT_Bool     in_twilight = exc->GS.gep0 == 0 || \
                              exc->GS.gep1 == 0 || \
                              exc->GS.gep2 == 0;
d6540 3
a6542 1
    twilight = exc->GS.gep0 == 0 || exc->GS.gep1 == 0 || exc->GS.gep2 == 0;
d6590 1
a6590 1
    for ( ; exc->GS.loop > 0; --exc->GS.loop )
d7555 2
a7556 1
    FT_Long    ins_counter = 0;  /* executed instructions counter */
d7592 38
d8390 1
@


1.28
log
@
Update to FreeType 2.6.5

ok matthieu@@
@
text
@d29 1
d34 3
d403 1
d689 2
a690 2
    /*  SHP[0]    */  PACK( 0, 0 ),
    /*  SHP[1]    */  PACK( 0, 0 ),
d695 2
a696 2
    /*  SHPIX     */  PACK( 1, 0 ),
    /*  IP        */  PACK( 0, 0 ),
d699 1
a699 1
    /*  AlignRP   */  PACK( 0, 0 ),
d772 1
a772 1
    /*  FlipPT    */  PACK( 0, 0 ),
d790 2
a791 2
    /*  INS_$91  */   PACK( 0, 0 ),
    /*  INS_$92  */   PACK( 0, 0 ),
d1073 4
d1079 1
d2587 14
a2600 7
    /* Note: The point size should be irrelevant in a given font program; */
    /*       we thus decide to return only the PPEM value.                */
#if 0
    args[0] = exc->metrics.pointSize;
#else
    args[0] = exc->func_cur_ppem( exc );
#endif
d2893 1
a2893 1
  /* Stack: f26.6 --> f26.6                                                */
d3133 1
a3133 1
  /* Opcode range: 0x68                                                    */
d3147 1
a3147 1
  /* Opcode range: 0x69                                                    */
d4022 1
d4506 1
a4506 1
  /* Stack: -->                                                            */
a6108 1
    else
d7248 1
a7248 1
      K |= 0x80;
d7256 12
a7267 1
      K |= 1 << 8;
d7411 51
d7648 15
a7662 1
      exc->new_top = exc->args + ( Pop_Push_Count[exc->opcode] & 15 );
d7855 1
a7855 1
        case 0x28:  /* ???? */
d8207 2
a8208 1
        case 0x8F:
d8211 22
@


1.27
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d48 6
a53 1
#define SUBPIXEL_HINTING                                                     \
d56 1
d58 5
a78 8
  /* Instruction dispatch function, as used by the interpreter.            */
  /*                                                                       */
  typedef void  (*TInstruction_Function)( TT_ExecContext  exc,
                                          FT_Long*        args );


  /*************************************************************************/
  /*                                                                       */
d292 2
a293 2
    exec->stack     = NULL;
    exec->glyphIns  = NULL;
d1567 1
a1567 1
    /* Reading a byte stream so there is no endianess (DaveP) */
d1648 4
d1665 2
a1666 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
      if ( !SUBPIXEL_HINTING                                      ||
d1669 14
a1682 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d1692 7
a1698 1
      zone->cur[point].y += FT_MulDiv( distance, v, exc->F_dot_P );
d1749 1
d1760 11
a1770 1
    FT_UNUSED( exc );
d1772 1
a1772 4
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( !SUBPIXEL_HINTING   ||
         !exc->ignore_x_mode )
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d1787 8
a1794 2
    zone->cur[point].y += distance;
    zone->tags[point]  |= FT_CURVE_TAG_TOUCH_Y;
d2073 1
a2073 1
    FT_F26Dot6 val;
d2112 1
a2112 1
  /*    The TrueType specification says very few about the relationship    */
a2920 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING

d2933 1
d2936 1
a2936 1
      if ( SUBPIXEL_HINTING                            &&
d2951 1
a2953 17

#else /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */

    FT_ULong  I = (FT_ULong)args[0];


    if ( BOUNDSL( I, exc->storeSize ) )
    {
      if ( exc->pedantic_hinting )
        ARRAY_BOUND_ERROR;
      else
        args[0] = 0;
    }
    else
      args[0] = exc->storage[I];

#endif /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d3435 1
a3435 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d3533 1
a3533 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d3578 1
a3578 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d3591 1
a3591 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d3593 1
a3593 1
      if ( SUBPIXEL_HINTING )
d3700 1
a3700 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d3729 1
a3729 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d3731 1
a3731 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d3817 2
a3818 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING                                               &&
d3826 1
a3826 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d3905 2
a3906 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING                                    &&
d3912 1
a3912 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d4807 1
a4807 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d4809 3
a4811 3
    if ( SUBPIXEL_HINTING   &&
         exc->ignore_x_mode &&
         FT_ABS( D ) == 64  )
d4813 1
a4813 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
a5068 3
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    /* INSTCTRL modifying flag 3 also has an effect */
    /* outside of the CVT program                   */
d5070 6
a5075 1
      exc->ignore_x_mode = FT_BOOL( L == 4 );
d5077 9
d5170 9
d5225 9
d5263 9
d5331 1
d5341 6
a5346 1
      exc->zp2.cur[point].x += dx;
d5353 8
a5360 1
      exc->zp2.cur[point].y += dy;
d5407 1
a5407 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d5409 1
a5409 2
      if ( SUBPIXEL_HINTING   &&
           exc->ignore_x_mode )
d5412 1
a5412 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d5540 1
a5540 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d5543 6
d5576 2
a5577 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d5587 1
a5587 2
        if ( SUBPIXEL_HINTING   &&
             exc->ignore_x_mode )
d5651 20
d5672 1
d5674 1
a5674 7

#else /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */

      Move_Zp2_Point( exc, point, dx, dy, TRUE );

#endif /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */

d5694 1
a5694 1
    FT_UShort   point;
d5696 2
a5698 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    FT_F26Dot6  control_value_cutin = 0; /* pacify compiler */
d5700 1
a5700 2

    if ( SUBPIXEL_HINTING )
d5709 1
a5709 2

#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d5732 1
a5732 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d5734 1
a5734 1
    if ( SUBPIXEL_HINTING                                    &&
d5739 1
a5739 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d5778 4
a5781 4
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
      if ( SUBPIXEL_HINTING          &&
           exc->ignore_x_mode        &&
           exc->GS.freeVector.x != 0 )
d5824 2
a5825 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING                                   &&
d5831 1
a5831 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d5865 1
a5865 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d5868 4
a5871 4
      if ( !SUBPIXEL_HINTING                      ||
           ( !exc->ignore_x_mode                ||
             !exc->face->sph_compatibility_mode ) )
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d5878 2
a5879 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING                               &&
d5885 1
a5885 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d5894 4
a5897 4
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
      if ( SUBPIXEL_HINTING          &&
           exc->ignore_x_mode        &&
           exc->GS.freeVector.x != 0 )
d5926 1
a5926 1
    FT_UShort   point;
d5932 2
a5933 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING                                   &&
d5938 1
a5938 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d6002 4
a6005 4
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
      if ( SUBPIXEL_HINTING          &&
           exc->ignore_x_mode        &&
           exc->GS.freeVector.x != 0 )
d6073 1
a6073 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d6077 1
a6077 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d6085 2
a6086 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING                                   &&
d6091 2
a6092 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d6145 2
a6146 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING                                          &&
d6156 1
a6156 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d6191 1
a6191 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d6193 1
a6193 1
      if ( SUBPIXEL_HINTING             &&
d6200 1
a6200 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d6224 2
a6225 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING )
d6242 1
a6242 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d6246 2
a6247 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING )
d6271 1
a6271 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d6296 2
a6297 2
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING                                          &&
d6305 1
a6305 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d6420 1
d6428 1
d6817 17
d6857 3
a6859 3
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING   &&
         exc->ignore_x_mode )
d6865 1
a6865 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d6937 1
a6937 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d6941 1
a6941 1
    if ( SUBPIXEL_HINTING                                         &&
d6946 1
a6946 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d7000 1
a7000 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d7002 1
a7002 1
          if ( SUBPIXEL_HINTING )
d7059 3
a7061 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d7063 15
a7077 1
            exc->func_move( exc, &exc->zp0, A, B );
d7193 2
a7194 1
    FT_Long  K;
d7199 1
a7199 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d7205 3
a7207 3
    if ( SUBPIXEL_HINTING      &&
         ( args[0] & 1 ) != 0  &&
         exc->subpixel_hinting )
d7221 1
a7221 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d7223 1
a7223 1
        K = TT_INTERPRETER_VERSION_35;
d7242 2
a7243 1
    /* HINTING FOR GRAYSCALE        */
d7250 53
a7302 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d7304 1
a7304 1
    if ( SUBPIXEL_HINTING                                     &&
d7377 1
a7377 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d7459 1
a7459 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d7470 1
a7470 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d7473 1
a7473 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d7475 16
a7490 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d7583 1
a7583 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d7585 1
a7585 1
      if ( SUBPIXEL_HINTING )
d7614 1
a7614 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
@


1.26
log
@
Bugfixing update to freetype-2.6.2

Tested on amd64, i386, macppc, sparc64, loongson and compile-tested
on arm by matthieu@@
Also tested in a ports bulk build by naddy@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2015 by                                                 */
a87 14
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
#define GUESS_VECTOR( V )                                             \
  do                                                                  \
  {                                                                   \
    if ( exc->face->unpatented_hinting )                              \
    {                                                                 \
      exc->GS.V.x = (FT_F2Dot14)( exc->GS.both_x_axis ? 0x4000 : 0 ); \
      exc->GS.V.y = (FT_F2Dot14)( exc->GS.both_x_axis ? 0 : 0x4000 ); \
    }                                                                 \
  } while (0)
#else
#define GUESS_VECTOR( V )  do { } while (0)
#endif

a535 4
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    exec->GS.both_x_axis = TRUE;
#endif

a561 4
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    TRUE,
#endif

d1451 6
a1456 8
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
      if ( exc->face->unpatented_hinting )
      {
        if ( exc->GS.both_x_axis )
          exc->tt_metrics.ratio = exc->tt_metrics.x_ratio;
        else
          exc->tt_metrics.ratio = exc->tt_metrics.y_ratio;
      }
a1457 1
#endif
d1459 1
a1459 5
        if ( exc->GS.projVector.y == 0 )
          exc->tt_metrics.ratio = exc->tt_metrics.x_ratio;

        else if ( exc->GS.projVector.x == 0 )
          exc->tt_metrics.ratio = exc->tt_metrics.y_ratio;
a1460 3
        else
        {
          FT_F26Dot6  x, y;
d1462 5
a1466 7

          x = TT_MulFix14( exc->tt_metrics.x_ratio,
                           exc->GS.projVector.x );
          y = TT_MulFix14( exc->tt_metrics.y_ratio,
                           exc->GS.projVector.y );
          exc->tt_metrics.ratio = FT_Hypot( x, y );
        }
a1653 4
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    FT_ASSERT( !exc->face->unpatented_hinting );
#endif

a1704 4
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    FT_ASSERT( !exc->face->unpatented_hinting );
#endif

a2296 4
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    FT_ASSERT( !exc->face->unpatented_hinting );
#endif

a2397 45
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    if ( exc->face->unpatented_hinting )
    {
      /* If both vectors point rightwards along the x axis, set          */
      /* `both-x-axis' true, otherwise set it false.  The x values only  */
      /* need be tested because the vector has been normalised to a unit */
      /* vector of length 0x4000 = unity.                                */
      exc->GS.both_x_axis = (FT_Bool)( exc->GS.projVector.x == 0x4000 &&
                                       exc->GS.freeVector.x == 0x4000 );

      /* Throw away projection and freedom vector information */
      /* because the patents don't allow them to be stored.   */
      /* The relevant US Patents are 5155805 and 5325479.     */
      exc->GS.projVector.x = 0;
      exc->GS.projVector.y = 0;
      exc->GS.freeVector.x = 0;
      exc->GS.freeVector.y = 0;

      if ( exc->GS.both_x_axis )
      {
        exc->func_project   = Project_x;
        exc->func_move      = Direct_Move_X;
        exc->func_move_orig = Direct_Move_Orig_X;
      }
      else
      {
        exc->func_project   = Project_y;
        exc->func_move      = Direct_Move_Y;
        exc->func_move_orig = Direct_Move_Orig_Y;
      }

      if ( exc->GS.dualVector.x == 0x4000 )
        exc->func_dualproj = Project_x;
      else if ( exc->GS.dualVector.y == 0x4000 )
        exc->func_dualproj = Project_y;
      else
        exc->func_dualproj = Dual_Project;

      /* Force recalculation of cached aspect ratio */
      exc->tt_metrics.ratio = 0;

      return;
    }
#endif /* TT_CONFIG_OPTION_UNPATENTED_HINTING */

a4200 2
    else
      GUESS_VECTOR( projVector );
a4206 2
    else
      GUESS_VECTOR( freeVector );
a4227 1
      GUESS_VECTOR( freeVector );
a4247 1
      GUESS_VECTOR( projVector );
a4261 1
    GUESS_VECTOR( projVector );
a4289 1
    GUESS_VECTOR( freeVector );
a4314 1
    GUESS_VECTOR( projVector );
a4328 12
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    if ( exc->face->unpatented_hinting )
    {
      args[0] = exc->GS.both_x_axis ? 0x4000 : 0;
      args[1] = exc->GS.both_x_axis ? 0 : 0x4000;
    }
    else
    {
      args[0] = exc->GS.projVector.x;
      args[1] = exc->GS.projVector.y;
    }
#else
a4330 1
#endif
a4343 12
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    if ( exc->face->unpatented_hinting )
    {
      args[0] = exc->GS.both_x_axis ? 0x4000 : 0;
      args[1] = exc->GS.both_x_axis ? 0 : 0x4000;
    }
    else
    {
      args[0] = exc->GS.freeVector.x;
      args[1] = exc->GS.freeVector.y;
    }
#else
a4345 1
#endif
a4874 1
    GUESS_VECTOR( freeVector );
d5263 2
a5264 20
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    if ( exc->face->unpatented_hinting )
    {
      if ( exc->GS.both_x_axis )
      {
        *x = d;
        *y = 0;
      }
      else
      {
        *x = 0;
        *y = d;
      }
    }
    else
#endif
    {
      *x = FT_MulDiv( d, (FT_Long)exc->GS.freeVector.x, exc->F_dot_P );
      *y = FT_MulDiv( d, (FT_Long)exc->GS.freeVector.y, exc->F_dot_P );
    }
a5276 19
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    if ( exc->face->unpatented_hinting )
    {
      if ( exc->GS.both_x_axis )
      {
        exc->zp2.cur[point].x += dx;
        if ( touch )
          exc->zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;
      }
      else
      {
        exc->zp2.cur[point].y += dy;
        if ( touch )
          exc->zp2.tags[point] |= FT_CURVE_TAG_TOUCH_Y;
      }
      return;
    }
#endif

d5479 2
a5480 20
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    if ( exc->face->unpatented_hinting )
    {
      if ( exc->GS.both_x_axis )
      {
        dx = (FT_UInt32)args[0];
        dy = 0;
      }
      else
      {
        dx = 0;
        dy = (FT_UInt32)args[0];
      }
    }
    else
#endif
    {
      dx = TT_MulFix14( args[0], exc->GS.freeVector.x );
      dy = TT_MulFix14( args[0], exc->GS.freeVector.y );
    }
a6835 21

#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    /* Delta hinting is covered by US Patent 5159668. */
    if ( exc->face->unpatented_hinting )
    {
      FT_Long  n = args[0] * 2;


      if ( exc->args < n )
      {
        if ( exc->pedantic_hinting )
          exc->error = FT_THROW( Too_Few_Arguments );
        n = exc->args;
      }

      exc->args -= n;
      exc->new_top = exc->args;
      return;
    }
#endif

a6975 20

#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    /* Delta hinting is covered by US Patent 5159668. */
    if ( exc->face->unpatented_hinting )
    {
      FT_Long  n = args[0] * 2;


      if ( exc->args < n )
      {
        if ( exc->pedantic_hinting )
          exc->error = FT_THROW( Too_Few_Arguments );
        n = exc->args;
      }

      exc->args -= n;
      exc->new_top = exc->args;
      return;
    }
#endif
@


1.25
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@a47 9
  /*************************************************************************/
  /*                                                                       */
  /* In order to detect infinite loops in the code, we set up a counter    */
  /* within the run loop.  A single stroke of interpretation is now        */
  /* limited to a maximum number of opcodes defined below.                 */
  /*                                                                       */
#define MAX_RUNNABLE_OPCODES  1000000L


d7559 1
a7559 1
        for ( n = 0; n < cnt; n++ )
d8224 1
a8224 1
      if ( ++ins_counter > MAX_RUNNABLE_OPCODES )
@


1.24
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@a90 7
  /*************************************************************************/
  /*                                                                       */
  /* This macro computes (a*2^14)/b and complements TT_MulFix14.           */
  /*                                                                       */
#define TT_DivFix14( a, b )  FT_DivFix( a, (b) << 2 )


d2576 1
a2576 1
    FT_F26Dot6  W;
d2579 1
a2579 1
    if ( FT_ABS( Vx ) < 0x4000L && FT_ABS( Vy ) < 0x4000L )
d2581 4
a2584 6
      if ( Vx == 0 && Vy == 0 )
      {
        /* XXX: UNDOCUMENTED! It seems that it is possible to try   */
        /*      to normalize the vector (0,0).  Return immediately. */
        return SUCCESS;
      }
d2586 2
a2587 3
      Vx *= 0x4000;
      Vy *= 0x4000;
    }
d2589 1
a2589 1
    W = FT_Hypot( Vx, Vy );
d2591 2
a2592 2
    R->x = (FT_F2Dot14)TT_DivFix14( Vx, W );
    R->y = (FT_F2Dot14)TT_DivFix14( Vy, W );
d5150 1
a5150 1
    FT_Long  K, L, Kf;
d5153 2
a5154 2
    K = args[1];
    L = args[0];
a6497 2
    exc->zp2.tags[point] |= FT_CURVE_TAG_TOUCH_BOTH;

d6534 2
@


1.23
log
@
Bugfixing update to freetype-2.5.5

ok matthieu@@
@
text
@d7 2
a8 2
/*  Copyright 1996-2014                                                    */
/*  by David Turner, Robert Wilhelm, and Werner Lemberg.                   */
d47 1
d57 2
a58 81
  /*************************************************************************/
  /*                                                                       */
  /* There are two kinds of implementations:                               */
  /*                                                                       */
  /* a. static implementation                                              */
  /*                                                                       */
  /*    The current execution context is a static variable, which fields   */
  /*    are accessed directly by the interpreter during execution.  The    */
  /*    context is named `cur'.                                            */
  /*                                                                       */
  /*    This version is non-reentrant, of course.                          */
  /*                                                                       */
  /* b. indirect implementation                                            */
  /*                                                                       */
  /*    The current execution context is passed to _each_ function as its  */
  /*    first argument, and each field is thus accessed indirectly.        */
  /*                                                                       */
  /*    This version is fully re-entrant.                                  */
  /*                                                                       */
  /* The idea is that an indirect implementation may be slower to execute  */
  /* on low-end processors that are used in some systems (like 386s or     */
  /* even 486s).                                                           */
  /*                                                                       */
  /* As a consequence, the indirect implementation is now the default, as  */
  /* its performance costs can be considered negligible in our context.    */
  /* Note, however, that we kept the same source with macros because:      */
  /*                                                                       */
  /* - The code is kept very close in design to the Pascal code used for   */
  /*   development.                                                        */
  /*                                                                       */
  /* - It's much more readable that way!                                   */
  /*                                                                       */
  /* - It's still open to experimentation and tuning.                      */
  /*                                                                       */
  /*************************************************************************/


#ifndef TT_CONFIG_OPTION_STATIC_INTERPRETER     /* indirect implementation */

#define CUR  (*exc)                             /* see ttobjs.h */

  /*************************************************************************/
  /*                                                                       */
  /* This macro is used whenever `exec' is unused in a function, to avoid  */
  /* stupid warnings from pedantic compilers.                              */
  /*                                                                       */
#define FT_UNUSED_EXEC  FT_UNUSED( exc )

#else                                           /* static implementation */

#define CUR  cur

#define FT_UNUSED_EXEC  int  __dummy = __dummy

  static
  TT_ExecContextRec  cur;   /* static exec. context variable */

  /* apparently, we have a _lot_ of direct indexing when accessing  */
  /* the static `cur', which makes the code bigger (due to all the  */
  /* four bytes addresses).                                         */

#endif /* TT_CONFIG_OPTION_STATIC_INTERPRETER */


  /*************************************************************************/
  /*                                                                       */
  /* The instruction argument stack.                                       */
  /*                                                                       */
#define INS_ARG  EXEC_OP_ FT_Long*  args    /* see ttobjs.h for EXEC_OP_ */


  /*************************************************************************/
  /*                                                                       */
  /* This macro is used whenever `args' is unused in a function, to avoid  */
  /* stupid warnings from pedantic compilers.                              */
  /*                                                                       */
#define FT_UNUSED_ARG  FT_UNUSED_EXEC; FT_UNUSED( args )


#define SUBPIXEL_HINTING                                                    \
          ( ((TT_Driver)FT_FACE_DRIVER( CUR.face ))->interpreter_version == \
d62 2
a63 58
  /*************************************************************************/
  /*                                                                       */
  /* The following macros hide the use of EXEC_ARG and EXEC_ARG_ to        */
  /* increase readability of the code.                                     */
  /*                                                                       */
  /*************************************************************************/


#define SKIP_Code() \
          SkipCode( EXEC_ARG )

#define GET_ShortIns() \
          GetShortIns( EXEC_ARG )

#define NORMalize( x, y, v ) \
          Normalize( EXEC_ARG_ x, y, v )

#define SET_SuperRound( scale, flags ) \
          SetSuperRound( EXEC_ARG_ scale, flags )

#define ROUND_None( d, c ) \
          Round_None( EXEC_ARG_ d, c )

#define INS_Goto_CodeRange( range, ip ) \
          Ins_Goto_CodeRange( EXEC_ARG_ range, ip )

#define CUR_Func_move( z, p, d ) \
          CUR.func_move( EXEC_ARG_ z, p, d )

#define CUR_Func_move_orig( z, p, d ) \
          CUR.func_move_orig( EXEC_ARG_ z, p, d )

#define CUR_Func_round( d, c ) \
          CUR.func_round( EXEC_ARG_ d, c )

#define CUR_Func_cur_ppem() \
          CUR.func_cur_ppem( EXEC_ARG )

#define CUR_Func_read_cvt( index ) \
          CUR.func_read_cvt( EXEC_ARG_ index )

#define CUR_Func_write_cvt( index, val ) \
          CUR.func_write_cvt( EXEC_ARG_ index, val )

#define CUR_Func_move_cvt( index, val ) \
          CUR.func_move_cvt( EXEC_ARG_ index, val )

#define CURRENT_Ratio() \
          Current_Ratio( EXEC_ARG )

#define INS_SxVTL( a, b, c, d ) \
          Ins_SxVTL( EXEC_ARG_ a, b, c, d )

#define COMPUTE_Funcs() \
          Compute_Funcs( EXEC_ARG )

#define COMPUTE_Round( a ) \
          Compute_Round( EXEC_ARG_ a )
d65 2
a66 2
#define COMPUTE_Point_Displacement( a, b, c, d ) \
          Compute_Point_Displacement( EXEC_ARG_ a, b, c, d )
d68 2
a69 2
#define MOVE_Zp2_Point( a, b, c, t ) \
          Move_Zp2_Point( EXEC_ARG_ a, b, c, t )
d71 2
a72 12

#define CUR_Func_project( v1, v2 )  \
          CUR.func_project( EXEC_ARG_ (v1)->x - (v2)->x, (v1)->y - (v2)->y )

#define CUR_Func_dualproj( v1, v2 )  \
          CUR.func_dualproj( EXEC_ARG_ (v1)->x - (v2)->x, (v1)->y - (v2)->y )

#define CUR_fast_project( v ) \
          CUR.func_project( EXEC_ARG_ (v)->x, (v)->y )

#define CUR_fast_dualproj( v ) \
          CUR.func_dualproj( EXEC_ARG_ (v)->x, (v)->y )
d79 2
a80 1
  typedef void  (*TInstruction_Function)( INS_ARG );
d90 1
d95 1
a95 2
#define TT_DivFix14( a, b ) \
          FT_DivFix( a, (b) << 2 )
d105 9
a113 6
#define GUESS_VECTOR( V )                                         \
  if ( CUR.face->unpatented_hinting )                             \
  {                                                               \
    CUR.GS.V.x = (FT_F2Dot14)( CUR.GS.both_x_axis ? 0x4000 : 0 ); \
    CUR.GS.V.y = (FT_F2Dot14)( CUR.GS.both_x_axis ? 0 : 0x4000 ); \
  }
d115 1
a115 1
#define GUESS_VECTOR( V )
d118 1
d161 1
a161 1
    FT_ASSERT( (FT_ULong)IP <= coderange->size );
d362 1
a362 1
              FT_Long    multiplier,
d455 1
a455 1
    tmp = exec->stackSize;
d461 1
a461 1
    exec->stackSize = (FT_UInt)tmp;
a546 3
  /* <Note>                                                                */
  /*    Only the glyph loader and debugger should call this function.      */
  /*                                                                       */
d548 1
a548 2
  TT_Run_Context( TT_ExecContext  exec,
                  FT_Bool         debug )
a577 3
#if 1
    FT_UNUSED( debug );

a578 6
#else
    if ( !debug )
      return TT_RunIns( exec );
    else
      return FT_Err_Ok;
#endif
d612 3
d622 3
a624 4
    if ( !driver->context )
    {
      FT_Error        error;
      TT_ExecContext  exec;
d626 4
d631 1
a631 14
      /* allocate object */
      if ( FT_NEW( exec ) )
        goto Fail;

      /* initialize it; in case of error this deallocates `exec' too */
      error = Init_Context( exec, memory );
      if ( error )
        goto Fail;

      /* store it into the driver */
      driver->context = exec;
    }

    return driver->context;
d678 2
a679 2
    /*  GPV       */  PACK( 0, 2 ),
    /*  GFV       */  PACK( 0, 2 ),
d808 2
a809 2
    /*  SDPVTL[0] */  PACK( 2, 0 ),
    /*  SDPVTL[1] */  PACK( 2, 0 ),
d942 4
d949 271
a1219 271
    "SVTCA y",
    "SVTCA x",
    "SPvTCA y",
    "SPvTCA x",
    "SFvTCA y",
    "SFvTCA x",
    "SPvTL ||",
    "SPvTL +",
    "SFvTL ||",
    "SFvTL +",
    "SPvFS",
    "SFvFS",
    "GPV",
    "GFV",
    "SFvTPv",
    "ISECT",

    "SRP0",
    "SRP1",
    "SRP2",
    "SZP0",
    "SZP1",
    "SZP2",
    "SZPS",
    "SLOOP",
    "RTG",
    "RTHG",
    "SMD",
    "ELSE",
    "JMPR",
    "SCvTCi",
    "SSwCi",
    "SSW",

    "DUP",
    "POP",
    "CLEAR",
    "SWAP",
    "DEPTH",
    "CINDEX",
    "MINDEX",
    "AlignPTS",
    "INS_$28",
    "UTP",
    "LOOPCALL",
    "CALL",
    "FDEF",
    "ENDF",
    "MDAP[0]",
    "MDAP[1]",

    "IUP[0]",
    "IUP[1]",
    "SHP[0]",
    "SHP[1]",
    "SHC[0]",
    "SHC[1]",
    "SHZ[0]",
    "SHZ[1]",
    "SHPIX",
    "IP",
    "MSIRP[0]",
    "MSIRP[1]",
    "AlignRP",
    "RTDG",
    "MIAP[0]",
    "MIAP[1]",

    "NPushB",
    "NPushW",
    "WS",
    "RS",
    "WCvtP",
    "RCvt",
    "GC[0]",
    "GC[1]",
    "SCFS",
    "MD[0]",
    "MD[1]",
    "MPPEM",
    "MPS",
    "FlipON",
    "FlipOFF",
    "DEBUG",

    "LT",
    "LTEQ",
    "GT",
    "GTEQ",
    "EQ",
    "NEQ",
    "ODD",
    "EVEN",
    "IF",
    "EIF",
    "AND",
    "OR",
    "NOT",
    "DeltaP1",
    "SDB",
    "SDS",

    "ADD",
    "SUB",
    "DIV",
    "MUL",
    "ABS",
    "NEG",
    "FLOOR",
    "CEILING",
    "ROUND[0]",
    "ROUND[1]",
    "ROUND[2]",
    "ROUND[3]",
    "NROUND[0]",
    "NROUND[1]",
    "NROUND[2]",
    "NROUND[3]",

    "WCvtF",
    "DeltaP2",
    "DeltaP3",
    "DeltaCn[0]",
    "DeltaCn[1]",
    "DeltaCn[2]",
    "SROUND",
    "S45Round",
    "JROT",
    "JROF",
    "ROFF",
    "INS_$7B",
    "RUTG",
    "RDTG",
    "SANGW",
    "AA",

    "FlipPT",
    "FlipRgON",
    "FlipRgOFF",
    "INS_$83",
    "INS_$84",
    "ScanCTRL",
    "SDVPTL[0]",
    "SDVPTL[1]",
    "GetINFO",
    "IDEF",
    "ROLL",
    "MAX",
    "MIN",
    "ScanTYPE",
    "InstCTRL",
    "INS_$8F",

    "INS_$90",
    "INS_$91",
    "INS_$92",
    "INS_$93",
    "INS_$94",
    "INS_$95",
    "INS_$96",
    "INS_$97",
    "INS_$98",
    "INS_$99",
    "INS_$9A",
    "INS_$9B",
    "INS_$9C",
    "INS_$9D",
    "INS_$9E",
    "INS_$9F",

    "INS_$A0",
    "INS_$A1",
    "INS_$A2",
    "INS_$A3",
    "INS_$A4",
    "INS_$A5",
    "INS_$A6",
    "INS_$A7",
    "INS_$A8",
    "INS_$A9",
    "INS_$AA",
    "INS_$AB",
    "INS_$AC",
    "INS_$AD",
    "INS_$AE",
    "INS_$AF",

    "PushB[0]",
    "PushB[1]",
    "PushB[2]",
    "PushB[3]",
    "PushB[4]",
    "PushB[5]",
    "PushB[6]",
    "PushB[7]",
    "PushW[0]",
    "PushW[1]",
    "PushW[2]",
    "PushW[3]",
    "PushW[4]",
    "PushW[5]",
    "PushW[6]",
    "PushW[7]",

    "MDRP[00]",
    "MDRP[01]",
    "MDRP[02]",
    "MDRP[03]",
    "MDRP[04]",
    "MDRP[05]",
    "MDRP[06]",
    "MDRP[07]",
    "MDRP[08]",
    "MDRP[09]",
    "MDRP[10]",
    "MDRP[11]",
    "MDRP[12]",
    "MDRP[13]",
    "MDRP[14]",
    "MDRP[15]",

    "MDRP[16]",
    "MDRP[17]",
    "MDRP[18]",
    "MDRP[19]",
    "MDRP[20]",
    "MDRP[21]",
    "MDRP[22]",
    "MDRP[23]",
    "MDRP[24]",
    "MDRP[25]",
    "MDRP[26]",
    "MDRP[27]",
    "MDRP[28]",
    "MDRP[29]",
    "MDRP[30]",
    "MDRP[31]",

    "MIRP[00]",
    "MIRP[01]",
    "MIRP[02]",
    "MIRP[03]",
    "MIRP[04]",
    "MIRP[05]",
    "MIRP[06]",
    "MIRP[07]",
    "MIRP[08]",
    "MIRP[09]",
    "MIRP[10]",
    "MIRP[11]",
    "MIRP[12]",
    "MIRP[13]",
    "MIRP[14]",
    "MIRP[15]",

    "MIRP[16]",
    "MIRP[17]",
    "MIRP[18]",
    "MIRP[19]",
    "MIRP[20]",
    "MIRP[21]",
    "MIRP[22]",
    "MIRP[23]",
    "MIRP[24]",
    "MIRP[25]",
    "MIRP[26]",
    "MIRP[27]",
    "MIRP[28]",
    "MIRP[29]",
    "MIRP[30]",
    "MIRP[31]"
d1485 1
a1485 1
  Current_Ratio( EXEC_OP )
d1487 1
a1487 1
    if ( !CUR.tt_metrics.ratio )
d1490 1
a1490 1
      if ( CUR.face->unpatented_hinting )
d1492 2
a1493 2
        if ( CUR.GS.both_x_axis )
          CUR.tt_metrics.ratio = CUR.tt_metrics.x_ratio;
d1495 1
a1495 1
          CUR.tt_metrics.ratio = CUR.tt_metrics.y_ratio;
d1500 2
a1501 2
        if ( CUR.GS.projVector.y == 0 )
          CUR.tt_metrics.ratio = CUR.tt_metrics.x_ratio;
d1503 2
a1504 2
        else if ( CUR.GS.projVector.x == 0 )
          CUR.tt_metrics.ratio = CUR.tt_metrics.y_ratio;
d1511 5
a1515 5
          x = TT_MulFix14( CUR.tt_metrics.x_ratio,
                           CUR.GS.projVector.x );
          y = TT_MulFix14( CUR.tt_metrics.y_ratio,
                           CUR.GS.projVector.y );
          CUR.tt_metrics.ratio = FT_Hypot( x, y );
d1519 1
a1519 1
    return CUR.tt_metrics.ratio;
d1524 1
a1524 1
  Current_Ppem( EXEC_OP )
d1526 1
a1526 1
    return CUR.tt_metrics.ppem;
d1531 1
a1531 1
  Current_Ppem_Stretched( EXEC_OP )
d1533 1
a1533 1
    return FT_MulFix( CUR.tt_metrics.ppem, CURRENT_Ratio() );
d1545 2
a1546 1
  Read_CVT( EXEC_OP_ FT_ULong  idx )
d1548 1
a1548 1
    return CUR.cvt[idx];
d1553 2
a1554 1
  Read_CVT_Stretched( EXEC_OP_ FT_ULong  idx )
d1556 1
a1556 1
    return FT_MulFix( CUR.cvt[idx], CURRENT_Ratio() );
d1561 3
a1563 2
  Write_CVT( EXEC_OP_ FT_ULong    idx,
                      FT_F26Dot6  value )
d1565 1
a1565 1
    CUR.cvt[idx] = value;
d1570 3
a1572 2
  Write_CVT_Stretched( EXEC_OP_ FT_ULong    idx,
                                FT_F26Dot6  value )
d1574 1
a1574 1
    CUR.cvt[idx] = FT_DivFix( value, CURRENT_Ratio() );
d1579 3
a1581 2
  Move_CVT( EXEC_OP_ FT_ULong    idx,
                     FT_F26Dot6  value )
d1583 1
a1583 1
    CUR.cvt[idx] += value;
d1588 3
a1590 2
  Move_CVT_Stretched( EXEC_OP_ FT_ULong    idx,
                               FT_F26Dot6  value )
d1592 1
a1592 1
    CUR.cvt[idx] += FT_DivFix( value, CURRENT_Ratio() );
d1612 1
a1612 1
  GetShortIns( EXEC_OP )
d1615 3
a1617 3
    CUR.IP += 2;
    return (FT_Short)( ( CUR.code[CUR.IP - 2] << 8 ) +
                         CUR.code[CUR.IP - 1]      );
d1638 3
a1640 2
  Ins_Goto_CodeRange( EXEC_OP_ FT_Int    aRange,
                               FT_ULong  aIP )
d1647 1
a1647 1
      CUR.error = FT_THROW( Bad_Argument );
d1651 1
a1651 1
    range = &CUR.codeRangeTable[aRange - 1];
d1655 1
a1655 1
      CUR.error = FT_THROW( Invalid_CodeRange );
d1665 1
a1665 1
      CUR.error = FT_THROW( Code_Overflow );
d1669 4
a1672 4
    CUR.code     = range->base;
    CUR.codeSize = range->size;
    CUR.IP       = aIP;
    CUR.curRange = aRange;
d1696 4
a1699 3
  Direct_Move( EXEC_OP_ TT_GlyphZone  zone,
                        FT_UShort     point,
                        FT_F26Dot6    distance )
d1705 1
a1705 1
    FT_ASSERT( !CUR.face->unpatented_hinting );
d1708 1
a1708 1
    v = CUR.GS.freeVector.x;
d1713 3
a1715 3
      if ( !SUBPIXEL_HINTING                                     ||
           ( !CUR.ignore_x_mode                                ||
             ( CUR.sph_tweak_flags & SPH_TWEAK_ALLOW_X_DMOVE ) ) )
d1717 1
a1717 1
        zone->cur[point].x += FT_MulDiv( distance, v, CUR.F_dot_P );
d1722 1
a1722 1
    v = CUR.GS.freeVector.y;
d1726 1
a1726 1
      zone->cur[point].y += FT_MulDiv( distance, v, CUR.F_dot_P );
d1751 4
a1754 3
  Direct_Move_Orig( EXEC_OP_ TT_GlyphZone  zone,
                             FT_UShort     point,
                             FT_F26Dot6    distance )
d1760 1
a1760 1
    FT_ASSERT( !CUR.face->unpatented_hinting );
d1763 1
a1763 1
    v = CUR.GS.freeVector.x;
d1766 1
a1766 1
      zone->org[point].x += FT_MulDiv( distance, v, CUR.F_dot_P );
d1768 1
a1768 1
    v = CUR.GS.freeVector.y;
d1771 1
a1771 1
      zone->org[point].y += FT_MulDiv( distance, v, CUR.F_dot_P );
d1786 4
a1789 3
  Direct_Move_X( EXEC_OP_ TT_GlyphZone  zone,
                          FT_UShort     point,
                          FT_F26Dot6    distance )
d1791 1
a1791 1
    FT_UNUSED_EXEC;
d1794 2
a1795 2
    if ( !SUBPIXEL_HINTING  ||
         !CUR.ignore_x_mode )
d1804 4
a1807 3
  Direct_Move_Y( EXEC_OP_ TT_GlyphZone  zone,
                          FT_UShort     point,
                          FT_F26Dot6    distance )
d1809 1
a1809 1
    FT_UNUSED_EXEC;
d1827 4
a1830 3
  Direct_Move_Orig_X( EXEC_OP_ TT_GlyphZone  zone,
                               FT_UShort     point,
                               FT_F26Dot6    distance )
d1832 1
a1832 1
    FT_UNUSED_EXEC;
d1839 4
a1842 3
  Direct_Move_Orig_Y( EXEC_OP_ TT_GlyphZone  zone,
                               FT_UShort     point,
                               FT_F26Dot6    distance )
d1844 1
a1844 1
    FT_UNUSED_EXEC;
d1873 3
a1875 2
  Round_None( EXEC_OP_ FT_F26Dot6  distance,
                       FT_F26Dot6  compensation )
d1879 1
a1879 1
    FT_UNUSED_EXEC;
d1915 3
a1917 2
  Round_To_Grid( EXEC_OP_ FT_F26Dot6  distance,
                          FT_F26Dot6  compensation )
d1921 1
a1921 1
    FT_UNUSED_EXEC;
d1937 1
a1937 1
    return  val;
d1958 3
a1960 2
  Round_To_Half_Grid( EXEC_OP_ FT_F26Dot6  distance,
                               FT_F26Dot6  compensation )
d1964 1
a1964 1
    FT_UNUSED_EXEC;
d2001 3
a2003 2
  Round_Down_To_Grid( EXEC_OP_ FT_F26Dot6  distance,
                               FT_F26Dot6  compensation )
d2007 1
a2007 1
    FT_UNUSED_EXEC;
d2044 3
a2046 2
  Round_Up_To_Grid( EXEC_OP_ FT_F26Dot6  distance,
                             FT_F26Dot6  compensation )
d2050 1
a2050 1
    FT_UNUSED_EXEC;
d2087 3
a2089 2
  Round_To_Double_Grid( EXEC_OP_ FT_F26Dot6  distance,
                                 FT_F26Dot6  compensation )
d2093 1
a2093 1
    FT_UNUSED_EXEC;
d2136 3
a2138 2
  Round_Super( EXEC_OP_ FT_F26Dot6  distance,
                        FT_F26Dot6  compensation )
d2145 3
a2147 3
      val = ( distance - CUR.phase + CUR.threshold + compensation ) &
              -CUR.period;
      val += CUR.phase;
d2149 1
a2149 1
        val = CUR.phase;
d2153 3
a2155 3
      val = -( ( CUR.threshold - CUR.phase - distance + compensation ) &
               -CUR.period );
      val -= CUR.phase;
d2157 1
a2157 1
        val = -CUR.phase;
d2185 3
a2187 2
  Round_Super_45( EXEC_OP_ FT_F26Dot6  distance,
                           FT_F26Dot6  compensation )
d2194 3
a2196 3
      val = ( ( distance - CUR.phase + CUR.threshold + compensation ) /
                CUR.period ) * CUR.period;
      val += CUR.phase;
d2198 1
a2198 1
        val = CUR.phase;
d2202 3
a2204 3
      val = -( ( ( CUR.threshold - CUR.phase - distance + compensation ) /
                   CUR.period ) * CUR.period );
      val -= CUR.phase;
d2206 1
a2206 1
        val = -CUR.phase;
d2225 2
a2226 1
  Compute_Round( EXEC_OP_ FT_Byte  round_mode )
d2231 1
a2231 1
      CUR.func_round = (TT_Round_Func)Round_None;
d2235 1
a2235 1
      CUR.func_round = (TT_Round_Func)Round_To_Grid;
d2239 1
a2239 1
      CUR.func_round = (TT_Round_Func)Round_Up_To_Grid;
d2243 1
a2243 1
      CUR.func_round = (TT_Round_Func)Round_Down_To_Grid;
d2247 1
a2247 1
      CUR.func_round = (TT_Round_Func)Round_To_Half_Grid;
d2251 1
a2251 1
      CUR.func_round = (TT_Round_Func)Round_To_Double_Grid;
d2255 1
a2255 1
      CUR.func_round = (TT_Round_Func)Round_Super;
d2259 1
a2259 1
      CUR.func_round = (TT_Round_Func)Round_Super_45;
d2279 3
a2281 2
  SetSuperRound( EXEC_OP_ FT_F26Dot6  GridPeriod,
                          FT_Long     selector )
d2286 1
a2286 1
        CUR.period = GridPeriod / 2;
d2290 1
a2290 1
        CUR.period = GridPeriod;
d2294 1
a2294 1
        CUR.period = GridPeriod * 2;
a2297 1

d2299 1
a2299 1
        CUR.period = GridPeriod;
d2306 1
a2306 1
      CUR.phase = 0;
d2310 1
a2310 1
      CUR.phase = CUR.period / 4;
d2314 1
a2314 1
      CUR.phase = CUR.period / 2;
d2318 1
a2318 1
      CUR.phase = CUR.period * 3 / 4;
d2323 1
a2323 1
      CUR.threshold = CUR.period - 1;
d2325 1
a2325 1
      CUR.threshold = ( (FT_Int)( selector & 0x0F ) - 4 ) * CUR.period / 8;
d2327 4
a2330 3
    CUR.period    /= 256;
    CUR.phase     /= 256;
    CUR.threshold /= 256;
d2351 3
a2353 2
  Project( EXEC_OP_ FT_Pos  dx,
                    FT_Pos  dy )
d2356 1
a2356 1
    FT_ASSERT( !CUR.face->unpatented_hinting );
d2359 3
a2361 3
    return TT_DotFix14( (FT_UInt32)dx, (FT_UInt32)dy,
                        CUR.GS.projVector.x,
                        CUR.GS.projVector.y );
d2382 7
a2388 6
  Dual_Project( EXEC_OP_ FT_Pos  dx,
                         FT_Pos  dy )
  {
    return TT_DotFix14( (FT_UInt32)dx, (FT_UInt32)dy,
                        CUR.GS.dualVector.x,
                        CUR.GS.dualVector.y );
d2409 3
a2411 2
  Project_x( EXEC_OP_ FT_Pos  dx,
                      FT_Pos  dy )
d2413 1
a2413 1
    FT_UNUSED_EXEC;
d2437 3
a2439 2
  Project_y( EXEC_OP_ FT_Pos  dx,
                      FT_Pos  dy )
d2441 1
a2441 1
    FT_UNUSED_EXEC;
d2458 1
a2458 1
  Compute_Funcs( EXEC_OP )
d2461 1
a2461 1
    if ( CUR.face->unpatented_hinting )
d2463 6
a2468 6
      /* If both vectors point rightwards along the x axis, set             */
      /* `both-x-axis' true, otherwise set it false.  The x values only     */
      /* need be tested because the vector has been normalised to a unit    */
      /* vector of length 0x4000 = unity.                                   */
      CUR.GS.both_x_axis = (FT_Bool)( CUR.GS.projVector.x == 0x4000 &&
                                      CUR.GS.freeVector.x == 0x4000 );
d2473 10
a2482 10
      CUR.GS.projVector.x = 0;
      CUR.GS.projVector.y = 0;
      CUR.GS.freeVector.x = 0;
      CUR.GS.freeVector.y = 0;

      if ( CUR.GS.both_x_axis )
      {
        CUR.func_project   = Project_x;
        CUR.func_move      = Direct_Move_X;
        CUR.func_move_orig = Direct_Move_Orig_X;
d2486 3
a2488 3
        CUR.func_project   = Project_y;
        CUR.func_move      = Direct_Move_Y;
        CUR.func_move_orig = Direct_Move_Orig_Y;
d2491 4
a2494 4
      if ( CUR.GS.dualVector.x == 0x4000 )
        CUR.func_dualproj = Project_x;
      else if ( CUR.GS.dualVector.y == 0x4000 )
        CUR.func_dualproj = Project_y;
d2496 1
a2496 1
        CUR.func_dualproj = Dual_Project;
d2499 1
a2499 1
      CUR.tt_metrics.ratio = 0;
d2505 4
a2508 4
    if ( CUR.GS.freeVector.x == 0x4000 )
      CUR.F_dot_P = CUR.GS.projVector.x;
    else if ( CUR.GS.freeVector.y == 0x4000 )
      CUR.F_dot_P = CUR.GS.projVector.y;
d2510 8
a2517 8
      CUR.F_dot_P = ( (FT_Long)CUR.GS.projVector.x * CUR.GS.freeVector.x +
                      (FT_Long)CUR.GS.projVector.y * CUR.GS.freeVector.y ) >>
                    14;

    if ( CUR.GS.projVector.x == 0x4000 )
      CUR.func_project = (TT_Project_Func)Project_x;
    else if ( CUR.GS.projVector.y == 0x4000 )
      CUR.func_project = (TT_Project_Func)Project_y;
d2519 1
a2519 1
      CUR.func_project = (TT_Project_Func)Project;
d2521 4
a2524 4
    if ( CUR.GS.dualVector.x == 0x4000 )
      CUR.func_dualproj = (TT_Project_Func)Project_x;
    else if ( CUR.GS.dualVector.y == 0x4000 )
      CUR.func_dualproj = (TT_Project_Func)Project_y;
d2526 1
a2526 1
      CUR.func_dualproj = (TT_Project_Func)Dual_Project;
d2528 2
a2529 2
    CUR.func_move      = (TT_Move_Func)Direct_Move;
    CUR.func_move_orig = (TT_Move_Func)Direct_Move_Orig;
d2531 1
a2531 1
    if ( CUR.F_dot_P == 0x4000L )
d2533 1
a2533 1
      if ( CUR.GS.freeVector.x == 0x4000 )
d2535 2
a2536 2
        CUR.func_move      = (TT_Move_Func)Direct_Move_X;
        CUR.func_move_orig = (TT_Move_Func)Direct_Move_Orig_X;
d2538 1
a2538 1
      else if ( CUR.GS.freeVector.y == 0x4000 )
d2540 2
a2541 2
        CUR.func_move      = (TT_Move_Func)Direct_Move_Y;
        CUR.func_move_orig = (TT_Move_Func)Direct_Move_Orig_Y;
d2548 2
a2549 2
    if ( FT_ABS( CUR.F_dot_P ) < 0x400L )
      CUR.F_dot_P = 0x4000L;
d2552 1
a2552 1
    CUR.tt_metrics.ratio = 0;
d2575 1
a2575 1
  /*    In case Vx and Vy are both zero, Normalize() returns SUCCESS, and  */
d2579 3
a2581 3
  Normalize( EXEC_OP_ FT_F26Dot6      Vx,
                      FT_F26Dot6      Vy,
                      FT_UnitVector*  R )
a2584 2
    FT_UNUSED_EXEC;

d2615 6
a2620 10
  static FT_Bool
  Ins_SxVTL( EXEC_OP_ FT_UShort       aIdx1,
                      FT_UShort       aIdx2,
                      FT_Int          aOpc,
                      FT_UnitVector*  Vec )
  {
    FT_Long     A, B, C;
    FT_Vector*  p1;
    FT_Vector*  p2;

a2621 7
    if ( BOUNDS( aIdx1, CUR.zp2.n_points ) ||
         BOUNDS( aIdx2, CUR.zp1.n_points ) )
    {
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
      return FAILURE;
    }
d2623 11
a2633 27
    p1 = CUR.zp1.cur + aIdx2;
    p2 = CUR.zp2.cur + aIdx1;

    A = p1->x - p2->x;
    B = p1->y - p2->y;

    /* If p1 == p2, SPVTL and SFVTL behave the same as */
    /* SPVTCA[X] and SFVTCA[X], respectively.          */
    /*                                                 */
    /* Confirmed by Greg Hitchcock.                    */

    if ( A == 0 && B == 0 )
    {
      A    = 0x4000;
      aOpc = 0;
    }

    if ( ( aOpc & 1 ) != 0 )
    {
      C =  B;   /* counter clockwise rotation */
      B =  A;
      A = -C;
    }

    NORMalize( A, B, Vec );

    return SUCCESS;
d2637 14
a2650 142
  /* When not using the big switch statements, the interpreter uses a */
  /* call table defined later below in this source.  Each opcode must */
  /* thus have a corresponding function, even trivial ones.           */
  /*                                                                  */
  /* They are all defined there.                                      */

#define DO_SVTCA                            \
  {                                         \
    FT_Short  A, B;                         \
                                            \
                                            \
    A = (FT_Short)( CUR.opcode & 1 ) << 14; \
    B = A ^ (FT_Short)0x4000;               \
                                            \
    CUR.GS.freeVector.x = A;                \
    CUR.GS.projVector.x = A;                \
    CUR.GS.dualVector.x = A;                \
                                            \
    CUR.GS.freeVector.y = B;                \
    CUR.GS.projVector.y = B;                \
    CUR.GS.dualVector.y = B;                \
                                            \
    COMPUTE_Funcs();                        \
  }


#define DO_SPVTCA                           \
  {                                         \
    FT_Short  A, B;                         \
                                            \
                                            \
    A = (FT_Short)( CUR.opcode & 1 ) << 14; \
    B = A ^ (FT_Short)0x4000;               \
                                            \
    CUR.GS.projVector.x = A;                \
    CUR.GS.dualVector.x = A;                \
                                            \
    CUR.GS.projVector.y = B;                \
    CUR.GS.dualVector.y = B;                \
                                            \
    GUESS_VECTOR( freeVector );             \
                                            \
    COMPUTE_Funcs();                        \
  }


#define DO_SFVTCA                           \
  {                                         \
    FT_Short  A, B;                         \
                                            \
                                            \
    A = (FT_Short)( CUR.opcode & 1 ) << 14; \
    B = A ^ (FT_Short)0x4000;               \
                                            \
    CUR.GS.freeVector.x = A;                \
    CUR.GS.freeVector.y = B;                \
                                            \
    GUESS_VECTOR( projVector );             \
                                            \
    COMPUTE_Funcs();                        \
  }


#define DO_SPVTL                                      \
    if ( INS_SxVTL( (FT_UShort)args[1],               \
                    (FT_UShort)args[0],               \
                    CUR.opcode,                       \
                    &CUR.GS.projVector ) == SUCCESS ) \
    {                                                 \
      CUR.GS.dualVector = CUR.GS.projVector;          \
      GUESS_VECTOR( freeVector );                     \
      COMPUTE_Funcs();                                \
    }


#define DO_SFVTL                                      \
    if ( INS_SxVTL( (FT_UShort)args[1],               \
                    (FT_UShort)args[0],               \
                    CUR.opcode,                       \
                    &CUR.GS.freeVector ) == SUCCESS ) \
    {                                                 \
      GUESS_VECTOR( projVector );                     \
      COMPUTE_Funcs();                                \
    }


#define DO_SFVTPV                          \
    GUESS_VECTOR( projVector );            \
    CUR.GS.freeVector = CUR.GS.projVector; \
    COMPUTE_Funcs();


#define DO_SPVFS                                \
  {                                             \
    FT_Short  S;                                \
    FT_Long   X, Y;                             \
                                                \
                                                \
    /* Only use low 16bits, then sign extend */ \
    S = (FT_Short)args[1];                      \
    Y = (FT_Long)S;                             \
    S = (FT_Short)args[0];                      \
    X = (FT_Long)S;                             \
                                                \
    NORMalize( X, Y, &CUR.GS.projVector );      \
                                                \
    CUR.GS.dualVector = CUR.GS.projVector;      \
    GUESS_VECTOR( freeVector );                 \
    COMPUTE_Funcs();                            \
  }


#define DO_SFVFS                                \
  {                                             \
    FT_Short  S;                                \
    FT_Long   X, Y;                             \
                                                \
                                                \
    /* Only use low 16bits, then sign extend */ \
    S = (FT_Short)args[1];                      \
    Y = (FT_Long)S;                             \
    S = (FT_Short)args[0];                      \
    X = S;                                      \
                                                \
    NORMalize( X, Y, &CUR.GS.freeVector );      \
    GUESS_VECTOR( projVector );                 \
    COMPUTE_Funcs();                            \
  }


#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
#define DO_GPV                                   \
    if ( CUR.face->unpatented_hinting )          \
    {                                            \
      args[0] = CUR.GS.both_x_axis ? 0x4000 : 0; \
      args[1] = CUR.GS.both_x_axis ? 0 : 0x4000; \
    }                                            \
    else                                         \
    {                                            \
      args[0] = CUR.GS.projVector.x;             \
      args[1] = CUR.GS.projVector.y;             \
    }
d2652 1
a2652 3
#define DO_GPV                                   \
    args[0] = CUR.GS.projVector.x;               \
    args[1] = CUR.GS.projVector.y;
d2654 1
d2657 11
a2667 17
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
#define DO_GFV                                   \
    if ( CUR.face->unpatented_hinting )          \
    {                                            \
      args[0] = CUR.GS.both_x_axis ? 0x4000 : 0; \
      args[1] = CUR.GS.both_x_axis ? 0 : 0x4000; \
    }                                            \
    else                                         \
    {                                            \
      args[0] = CUR.GS.freeVector.x;             \
      args[1] = CUR.GS.freeVector.y;             \
    }
#else
#define DO_GFV                                   \
    args[0] = CUR.GS.freeVector.x;               \
    args[1] = CUR.GS.freeVector.y;
#endif
d2670 11
a2680 2
#define DO_SRP0                      \
    CUR.GS.rp0 = (FT_UShort)args[0];
d2683 11
a2693 2
#define DO_SRP1                      \
    CUR.GS.rp1 = (FT_UShort)args[0];
d2696 10
a2705 2
#define DO_SRP2                      \
    CUR.GS.rp2 = (FT_UShort)args[0];
d2708 4
a2711 3
#define DO_RTHG                                         \
    CUR.GS.round_state = TT_Round_To_Half_Grid;         \
    CUR.func_round = (TT_Round_Func)Round_To_Half_Grid;
d2714 12
a2725 3
#define DO_RTG                                     \
    CUR.GS.round_state = TT_Round_To_Grid;         \
    CUR.func_round = (TT_Round_Func)Round_To_Grid;
d2728 11
a2738 3
#define DO_RTDG                                           \
    CUR.GS.round_state = TT_Round_To_Double_Grid;         \
    CUR.func_round = (TT_Round_Func)Round_To_Double_Grid;
d2741 11
a2751 3
#define DO_RUTG                                       \
    CUR.GS.round_state = TT_Round_Up_To_Grid;         \
    CUR.func_round = (TT_Round_Func)Round_Up_To_Grid;
d2754 11
a2764 3
#define DO_RDTG                                         \
    CUR.GS.round_state = TT_Round_Down_To_Grid;         \
    CUR.func_round = (TT_Round_Func)Round_Down_To_Grid;
d2767 11
a2777 3
#define DO_ROFF                                 \
    CUR.GS.round_state = TT_Round_Off;          \
    CUR.func_round = (TT_Round_Func)Round_None;
d2780 11
a2790 4
#define DO_SROUND                                \
    SET_SuperRound( 0x4000, args[0] );           \
    CUR.GS.round_state = TT_Round_Super;         \
    CUR.func_round = (TT_Round_Func)Round_Super;
d2793 11
a2803 394
#define DO_S45ROUND                                 \
    SET_SuperRound( 0x2D41, args[0] );              \
    CUR.GS.round_state = TT_Round_Super_45;         \
    CUR.func_round = (TT_Round_Func)Round_Super_45;


#define DO_SLOOP                            \
    if ( args[0] < 0 )                      \
      CUR.error = FT_THROW( Bad_Argument ); \
    else                                    \
      CUR.GS.loop = args[0];


#define DO_SMD                         \
    CUR.GS.minimum_distance = args[0];


#define DO_SCVTCI                                     \
    CUR.GS.control_value_cutin = (FT_F26Dot6)args[0];


#define DO_SSWCI                                     \
    CUR.GS.single_width_cutin = (FT_F26Dot6)args[0];


#define DO_SSW                                                     \
    CUR.GS.single_width_value = FT_MulFix( args[0],                \
                                           CUR.tt_metrics.scale );


#define DO_FLIPON            \
    CUR.GS.auto_flip = TRUE;


#define DO_FLIPOFF            \
    CUR.GS.auto_flip = FALSE;


#define DO_SDB                              \
    CUR.GS.delta_base = (FT_UShort)args[0];


#define DO_SDS                                 \
    if ( (FT_ULong)args[0] > 6UL )             \
      CUR.error = FT_THROW( Bad_Argument );    \
    else                                       \
      CUR.GS.delta_shift = (FT_UShort)args[0];


#define DO_MD  /* nothing */


#define DO_MPPEM                   \
    args[0] = CUR_Func_cur_ppem();


  /* Note: The pointSize should be irrelevant in a given font program; */
  /*       we thus decide to return only the ppem.                     */
#if 0

#define DO_MPS                       \
    args[0] = CUR.metrics.pointSize;

#else

#define DO_MPS                     \
    args[0] = CUR_Func_cur_ppem();

#endif /* 0 */


#define DO_DUP         \
    args[1] = args[0];


#define DO_CLEAR     \
    CUR.new_top = 0;


#define DO_SWAP        \
  {                    \
    FT_Long  L;        \
                       \
                       \
    L       = args[0]; \
    args[0] = args[1]; \
    args[1] = L;       \
  }


#define DO_DEPTH       \
    args[0] = CUR.top;


#define DO_CINDEX                                  \
  {                                                \
    FT_Long  L;                                    \
                                                   \
                                                   \
    L = args[0];                                   \
                                                   \
    if ( L <= 0 || L > CUR.args )                  \
    {                                              \
      if ( CUR.pedantic_hinting )                  \
        CUR.error = FT_THROW( Invalid_Reference ); \
      args[0] = 0;                                 \
    }                                              \
    else                                           \
      args[0] = CUR.stack[CUR.args - L];           \
  }


#define DO_JROT                                                    \
    if ( args[1] != 0 )                                            \
    {                                                              \
      if ( args[0] == 0 && CUR.args == 0 )                         \
        CUR.error = FT_THROW( Bad_Argument );                      \
      CUR.IP += args[0];                                           \
      if ( CUR.IP < 0                                           || \
           ( CUR.callTop > 0                                  &&   \
             CUR.IP > CUR.callStack[CUR.callTop - 1].Def->end ) )  \
        CUR.error = FT_THROW( Bad_Argument );                      \
      CUR.step_ins = FALSE;                                        \
    }


#define DO_JMPR                                                  \
    if ( args[0] == 0 && CUR.args == 0 )                         \
      CUR.error = FT_THROW( Bad_Argument );                      \
    CUR.IP += args[0];                                           \
    if ( CUR.IP < 0                                           || \
         ( CUR.callTop > 0                                  &&   \
           CUR.IP > CUR.callStack[CUR.callTop - 1].Def->end ) )  \
      CUR.error = FT_THROW( Bad_Argument );                      \
    CUR.step_ins = FALSE;


#define DO_JROF                                                    \
    if ( args[1] == 0 )                                            \
    {                                                              \
      if ( args[0] == 0 && CUR.args == 0 )                         \
        CUR.error = FT_THROW( Bad_Argument );                      \
      CUR.IP += args[0];                                           \
      if ( CUR.IP < 0                                           || \
           ( CUR.callTop > 0                                  &&   \
             CUR.IP > CUR.callStack[CUR.callTop - 1].Def->end ) )  \
        CUR.error = FT_THROW( Bad_Argument );                      \
      CUR.step_ins = FALSE;                                        \
    }


#define DO_LT                        \
    args[0] = ( args[0] < args[1] );


#define DO_LTEQ                       \
    args[0] = ( args[0] <= args[1] );


#define DO_GT                        \
    args[0] = ( args[0] > args[1] );


#define DO_GTEQ                       \
    args[0] = ( args[0] >= args[1] );


#define DO_EQ                         \
    args[0] = ( args[0] == args[1] );


#define DO_NEQ                        \
    args[0] = ( args[0] != args[1] );


#define DO_ODD                                                  \
    args[0] = ( ( CUR_Func_round( args[0], 0 ) & 127 ) == 64 );


#define DO_EVEN                                                \
    args[0] = ( ( CUR_Func_round( args[0], 0 ) & 127 ) == 0 );


#define DO_AND                        \
    args[0] = ( args[0] && args[1] );


#define DO_OR                         \
    args[0] = ( args[0] || args[1] );


#define DO_NOT          \
    args[0] = !args[0];


#define DO_ADD          \
    args[0] += args[1];


#define DO_SUB          \
    args[0] -= args[1];


#define DO_DIV                                               \
    if ( args[1] == 0 )                                      \
      CUR.error = FT_THROW( Divide_By_Zero );                \
    else                                                     \
      args[0] = FT_MulDiv_No_Round( args[0], 64L, args[1] );


#define DO_MUL                                    \
    args[0] = FT_MulDiv( args[0], args[1], 64L );


#define DO_ABS                   \
    args[0] = FT_ABS( args[0] );


#define DO_NEG          \
    args[0] = -args[0];


#define DO_FLOOR    \
    args[0] = FT_PIX_FLOOR( args[0] );


#define DO_CEILING                    \
    args[0] = FT_PIX_CEIL( args[0] );

#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING

#define DO_RS                                             \
   {                                                      \
     FT_ULong  I = (FT_ULong)args[0];                     \
                                                          \
                                                          \
     if ( BOUNDSL( I, CUR.storeSize ) )                   \
     {                                                    \
       if ( CUR.pedantic_hinting )                        \
         ARRAY_BOUND_ERROR;                               \
       else                                               \
         args[0] = 0;                                     \
     }                                                    \
     else                                                 \
     {                                                    \
       /* subpixel hinting - avoid Typeman Dstroke and */ \
       /* IStroke and Vacuform rounds                  */ \
                                                          \
       if ( SUBPIXEL_HINTING                           && \
            CUR.ignore_x_mode                          && \
            ( ( I == 24                            &&     \
                ( CUR.face->sph_found_func_flags &        \
                  ( SPH_FDEF_SPACING_1 |                  \
                    SPH_FDEF_SPACING_2 )         ) ) ||   \
              ( I == 22                      &&           \
                ( CUR.sph_in_func_flags    &              \
                  SPH_FDEF_TYPEMAN_STROKES ) )       ||   \
              ( I == 8                             &&     \
                ( CUR.face->sph_found_func_flags &        \
                  SPH_FDEF_VACUFORM_ROUND_1      ) &&     \
                  CUR.iup_called                   ) ) )  \
         args[0] = 0;                                     \
       else                                               \
         args[0] = CUR.storage[I];                        \
     }                                                    \
   }

#else /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */

#define DO_RS                           \
   {                                    \
     FT_ULong  I = (FT_ULong)args[0];   \
                                        \
                                        \
     if ( BOUNDSL( I, CUR.storeSize ) ) \
     {                                  \
       if ( CUR.pedantic_hinting )      \
       {                                \
         ARRAY_BOUND_ERROR;             \
       }                                \
       else                             \
         args[0] = 0;                   \
     }                                  \
     else                               \
       args[0] = CUR.storage[I];        \
   }

#endif /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */


#define DO_WS                           \
   {                                    \
     FT_ULong  I = (FT_ULong)args[0];   \
                                        \
                                        \
     if ( BOUNDSL( I, CUR.storeSize ) ) \
     {                                  \
       if ( CUR.pedantic_hinting )      \
       {                                \
         ARRAY_BOUND_ERROR;             \
       }                                \
     }                                  \
     else                               \
       CUR.storage[I] = args[1];        \
   }


#define DO_RCVT                          \
   {                                     \
     FT_ULong  I = (FT_ULong)args[0];    \
                                         \
                                         \
     if ( BOUNDSL( I, CUR.cvtSize ) )    \
     {                                   \
       if ( CUR.pedantic_hinting )       \
       {                                 \
         ARRAY_BOUND_ERROR;              \
       }                                 \
       else                              \
         args[0] = 0;                    \
     }                                   \
     else                                \
       args[0] = CUR_Func_read_cvt( I ); \
   }


#define DO_WCVTP                         \
   {                                     \
     FT_ULong  I = (FT_ULong)args[0];    \
                                         \
                                         \
     if ( BOUNDSL( I, CUR.cvtSize ) )    \
     {                                   \
       if ( CUR.pedantic_hinting )       \
       {                                 \
         ARRAY_BOUND_ERROR;              \
       }                                 \
     }                                   \
     else                                \
       CUR_Func_write_cvt( I, args[1] ); \
   }


#define DO_WCVTF                                                \
   {                                                            \
     FT_ULong  I = (FT_ULong)args[0];                           \
                                                                \
                                                                \
     if ( BOUNDSL( I, CUR.cvtSize ) )                           \
     {                                                          \
       if ( CUR.pedantic_hinting )                              \
       {                                                        \
         ARRAY_BOUND_ERROR;                                     \
       }                                                        \
     }                                                          \
     else                                                       \
       CUR.cvt[I] = FT_MulFix( args[1], CUR.tt_metrics.scale ); \
   }


#define DO_DEBUG                          \
    CUR.error = FT_THROW( Debug_OpCode );


#define DO_ROUND                                                   \
    args[0] = CUR_Func_round(                                      \
                args[0],                                           \
                CUR.tt_metrics.compensations[CUR.opcode - 0x68] );


#define DO_NROUND                                                            \
    args[0] = ROUND_None( args[0],                                           \
                          CUR.tt_metrics.compensations[CUR.opcode - 0x6C] );


#define DO_MAX               \
    if ( args[1] > args[0] ) \
      args[0] = args[1];


#define DO_MIN               \
    if ( args[1] < args[0] ) \
      args[0] = args[1];


#ifndef TT_CONFIG_OPTION_INTERPRETER_SWITCH


#undef  ARRAY_BOUND_ERROR
#define ARRAY_BOUND_ERROR                        \
    {                                            \
      CUR.error = FT_THROW( Invalid_Reference ); \
      return;                                    \
    }
d2808 3
a2810 3
  /* SVTCA[a]:     Set (F and P) Vectors to Coordinate Axis                */
  /* Opcode range: 0x00-0x01                                               */
  /* Stack:        -->                                                     */
d2813 2
a2814 1
  Ins_SVTCA( INS_ARG )
d2816 1
a2816 1
    DO_SVTCA
d2822 3
a2824 3
  /* SPVTCA[a]:    Set PVector to Coordinate Axis                          */
  /* Opcode range: 0x02-0x03                                               */
  /* Stack:        -->                                                     */
d2827 2
a2828 1
  Ins_SPVTCA( INS_ARG )
d2830 1
a2830 1
    DO_SPVTCA
d2836 3
a2838 3
  /* SFVTCA[a]:    Set FVector to Coordinate Axis                          */
  /* Opcode range: 0x04-0x05                                               */
  /* Stack:        -->                                                     */
d2841 1
a2841 1
  Ins_SFVTCA( INS_ARG )
d2843 1
a2843 1
    DO_SFVTCA
d2849 3
a2851 3
  /* SPVTL[a]:     Set PVector To Line                                     */
  /* Opcode range: 0x06-0x07                                               */
  /* Stack:        uint32 uint32 -->                                       */
d2854 1
a2854 1
  Ins_SPVTL( INS_ARG )
d2856 1
a2856 1
    DO_SPVTL
d2862 3
a2864 3
  /* SFVTL[a]:     Set FVector To Line                                     */
  /* Opcode range: 0x08-0x09                                               */
  /* Stack:        uint32 uint32 -->                                       */
d2867 1
a2867 1
  Ins_SFVTL( INS_ARG )
d2869 1
a2869 1
    DO_SFVTL
d2875 3
a2877 3
  /* SFVTPV[]:     Set FVector To PVector                                  */
  /* Opcode range: 0x0E                                                    */
  /* Stack:        -->                                                     */
d2880 1
a2880 1
  Ins_SFVTPV( INS_ARG )
d2882 1
a2882 1
    DO_SFVTPV
d2888 3
a2890 3
  /* SPVFS[]:      Set PVector From Stack                                  */
  /* Opcode range: 0x0A                                                    */
  /* Stack:        f2.14 f2.14 -->                                         */
d2893 1
a2893 1
  Ins_SPVFS( INS_ARG )
d2895 1
a2895 1
    DO_SPVFS
d2901 3
a2903 3
  /* SFVFS[]:      Set FVector From Stack                                  */
  /* Opcode range: 0x0B                                                    */
  /* Stack:        f2.14 f2.14 -->                                         */
d2906 2
a2907 1
  Ins_SFVFS( INS_ARG )
d2909 4
a2912 1
    DO_SFVFS
d2918 3
a2920 3
  /* GPV[]:        Get Projection Vector                                   */
  /* Opcode range: 0x0C                                                    */
  /* Stack:        ef2.14 --> ef2.14                                       */
d2923 1
a2923 1
  Ins_GPV( INS_ARG )
d2925 1
a2925 1
    DO_GPV
d2930 4
a2933 3
  /* GFV[]:        Get Freedom Vector                                      */
  /* Opcode range: 0x0D                                                    */
  /* Stack:        ef2.14 --> ef2.14                                       */
d2936 1
a2936 1
  Ins_GFV( INS_ARG )
d2938 1
a2938 1
    DO_GFV
d2944 3
a2946 3
  /* SRP0[]:       Set Reference Point 0                                   */
  /* Opcode range: 0x10                                                    */
  /* Stack:        uint32 -->                                              */
d2949 1
a2949 1
  Ins_SRP0( INS_ARG )
d2951 1
a2951 1
    DO_SRP0
d2957 3
a2959 3
  /* SRP1[]:       Set Reference Point 1                                   */
  /* Opcode range: 0x11                                                    */
  /* Stack:        uint32 -->                                              */
d2962 1
a2962 1
  Ins_SRP1( INS_ARG )
d2964 1
a2964 1
    DO_SRP1
d2970 3
a2972 3
  /* SRP2[]:       Set Reference Point 2                                   */
  /* Opcode range: 0x12                                                    */
  /* Stack:        uint32 -->                                              */
d2975 1
a2975 1
  Ins_SRP2( INS_ARG )
d2977 1
a2977 1
    DO_SRP2
d2983 3
a2985 3
  /* RTHG[]:       Round To Half Grid                                      */
  /* Opcode range: 0x19                                                    */
  /* Stack:        -->                                                     */
d2988 2
a2989 1
  Ins_RTHG( INS_ARG )
d2991 50
a3040 1
    DO_RTHG
d3046 3
a3048 3
  /* RTG[]:        Round To Grid                                           */
  /* Opcode range: 0x18                                                    */
  /* Stack:        -->                                                     */
d3051 2
a3052 1
  Ins_RTG( INS_ARG )
d3054 10
a3063 1
    DO_RTG
d3068 4
a3071 3
  /* RTDG[]:       Round To Double Grid                                    */
  /* Opcode range: 0x3D                                                    */
  /* Stack:        -->                                                     */
d3074 2
a3075 1
  Ins_RTDG( INS_ARG )
d3077 10
a3086 1
    DO_RTDG
d3091 4
a3094 3
  /* RUTG[]:       Round Up To Grid                                        */
  /* Opcode range: 0x7C                                                    */
  /* Stack:        -->                                                     */
d3097 2
a3098 1
  Ins_RUTG( INS_ARG )
d3100 1
a3100 2
    DO_RUTG
  }
d3103 7
a3109 10
  /*************************************************************************/
  /*                                                                       */
  /* RDTG[]:       Round Down To Grid                                      */
  /* Opcode range: 0x7D                                                    */
  /* Stack:        -->                                                     */
  /*                                                                       */
  static void
  Ins_RDTG( INS_ARG )
  {
    DO_RDTG
d3115 3
a3117 3
  /* ROFF[]:       Round OFF                                               */
  /* Opcode range: 0x7A                                                    */
  /* Stack:        -->                                                     */
d3120 2
a3121 1
  Ins_ROFF( INS_ARG )
d3123 12
a3134 1
    DO_ROFF
d3140 3
a3142 3
  /* SROUND[]:     Super ROUND                                             */
  /* Opcode range: 0x76                                                    */
  /* Stack:        Eint8 -->                                               */
d3145 1
a3145 1
  Ins_SROUND( INS_ARG )
d3147 1
a3147 1
    DO_SROUND
d3153 2
a3154 2
  /* S45ROUND[]:   Super ROUND 45 degrees                                  */
  /* Opcode range: 0x77                                                    */
d3157 2
d3160 1
a3160 1
  Ins_S45ROUND( INS_ARG )
d3162 1
a3162 1
    DO_S45ROUND
d3168 3
a3170 3
  /* SLOOP[]:      Set LOOP variable                                       */
  /* Opcode range: 0x17                                                    */
  /* Stack:        int32? -->                                              */
d3173 2
a3174 1
  Ins_SLOOP( INS_ARG )
d3176 4
a3179 1
    DO_SLOOP
d3185 3
a3187 3
  /* SMD[]:        Set Minimum Distance                                    */
  /* Opcode range: 0x1A                                                    */
  /* Stack:        f26.6 -->                                               */
d3190 2
a3191 1
  Ins_SMD( INS_ARG )
d3193 4
a3196 1
    DO_SMD
d3202 3
a3204 3
  /* SCVTCI[]:     Set Control Value Table Cut In                          */
  /* Opcode range: 0x1D                                                    */
  /* Stack:        f26.6 -->                                               */
d3207 1
a3207 1
  Ins_SCVTCI( INS_ARG )
d3209 2
a3210 1
    DO_SCVTCI
d3216 3
a3218 3
  /* SSWCI[]:      Set Single Width Cut In                                 */
  /* Opcode range: 0x1E                                                    */
  /* Stack:        f26.6 -->                                               */
d3221 1
a3221 1
  Ins_SSWCI( INS_ARG )
d3223 2
a3224 1
    DO_SSWCI
d3230 3
a3232 3
  /* SSW[]:        Set Single Width                                        */
  /* Opcode range: 0x1F                                                    */
  /* Stack:        int32? -->                                              */
d3235 2
a3236 1
  Ins_SSW( INS_ARG )
d3238 20
a3257 1
    DO_SSW
d3263 3
a3265 3
  /* FLIPON[]:     Set auto-FLIP to ON                                     */
  /* Opcode range: 0x4D                                                    */
  /* Stack:        -->                                                     */
d3268 2
a3269 1
  Ins_FLIPON( INS_ARG )
d3271 13
a3283 1
    DO_FLIPON
d3289 3
a3291 3
  /* FLIPOFF[]:    Set auto-FLIP to OFF                                    */
  /* Opcode range: 0x4E                                                    */
  /* Stack: -->                                                            */
d3294 1
a3294 1
  Ins_FLIPOFF( INS_ARG )
d3296 10
a3305 1
    DO_FLIPOFF
d3311 1
a3311 3
  /* SANGW[]:      Set ANGle Weight                                        */
  /* Opcode range: 0x7E                                                    */
  /* Stack:        uint32 -->                                              */
d3313 1
a3313 5
  static void
  Ins_SANGW( INS_ARG )
  {
    /* instruction not supported anymore */
  }
d3318 3
a3320 3
  /* SDB[]:        Set Delta Base                                          */
  /* Opcode range: 0x5E                                                    */
  /* Stack:        uint32 -->                                              */
d3323 2
a3324 1
  Ins_SDB( INS_ARG )
d3326 4
a3329 1
    DO_SDB
d3333 2
a3334 8
  /*************************************************************************/
  /*                                                                       */
  /* SDS[]:        Set Delta Shift                                         */
  /* Opcode range: 0x5F                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_SDS( INS_ARG )
d3336 21
a3356 1
    DO_SDS
d3362 3
a3364 3
  /* MPPEM[]:      Measure Pixel Per EM                                    */
  /* Opcode range: 0x4B                                                    */
  /* Stack:        --> Euint16                                             */
d3367 2
a3368 1
  Ins_MPPEM( INS_ARG )
d3370 31
a3400 1
    DO_MPPEM
d3406 3
a3408 3
  /* MPS[]:        Measure Point Size                                      */
  /* Opcode range: 0x4C                                                    */
  /* Stack:        --> Euint16                                             */
d3411 1
a3411 1
  Ins_MPS( INS_ARG )
d3413 9
a3421 2
    DO_MPS
  }
d3423 5
d3429 5
a3433 10
  /*************************************************************************/
  /*                                                                       */
  /* DUP[]:        DUPlicate the top stack's element                       */
  /* Opcode range: 0x20                                                    */
  /* Stack:        StkElt --> StkElt StkElt                                */
  /*                                                                       */
  static void
  Ins_DUP( INS_ARG )
  {
    DO_DUP
d3439 3
a3441 3
  /* POP[]:        POP the stack's top element                             */
  /* Opcode range: 0x21                                                    */
  /* Stack:        StkElt -->                                              */
d3444 1
a3444 1
  Ins_POP( INS_ARG )
d3452 3
a3454 3
  /* CLEAR[]:      CLEAR the entire stack                                  */
  /* Opcode range: 0x22                                                    */
  /* Stack:        StkElt... -->                                           */
d3457 2
a3458 1
  Ins_CLEAR( INS_ARG )
d3460 8
a3467 1
    DO_CLEAR
d3473 3
a3475 3
  /* SWAP[]:       SWAP the stack's top two elements                       */
  /* Opcode range: 0x23                                                    */
  /* Stack:        2 * StkElt --> 2 * StkElt                               */
d3478 2
a3479 1
  Ins_SWAP( INS_ARG )
d3481 2
a3482 1
    DO_SWAP
d3488 3
a3490 3
  /* DEPTH[]:      return the stack DEPTH                                  */
  /* Opcode range: 0x24                                                    */
  /* Stack:        --> uint32                                              */
d3493 2
a3494 1
  Ins_DEPTH( INS_ARG )
d3496 2
a3497 1
    DO_DEPTH
d3503 1
a3503 3
  /* CINDEX[]:     Copy INDEXed element                                    */
  /* Opcode range: 0x25                                                    */
  /* Stack:        int32 --> StkElt                                        */
d3505 1
a3505 5
  static void
  Ins_CINDEX( INS_ARG )
  {
    DO_CINDEX
  }
d3510 3
a3512 3
  /* EIF[]:        End IF                                                  */
  /* Opcode range: 0x59                                                    */
  /* Stack:        -->                                                     */
d3515 2
a3516 1
  Ins_EIF( INS_ARG )
d3518 3
a3520 2
    /* nothing to do */
  }
d3522 99
a3620 246

  /*************************************************************************/
  /*                                                                       */
  /* JROT[]:       Jump Relative On True                                   */
  /* Opcode range: 0x78                                                    */
  /* Stack:        StkElt int32 -->                                        */
  /*                                                                       */
  static void
  Ins_JROT( INS_ARG )
  {
    DO_JROT
  }


  /*************************************************************************/
  /*                                                                       */
  /* JMPR[]:       JuMP Relative                                           */
  /* Opcode range: 0x1C                                                    */
  /* Stack:        int32 -->                                               */
  /*                                                                       */
  static void
  Ins_JMPR( INS_ARG )
  {
    DO_JMPR
  }


  /*************************************************************************/
  /*                                                                       */
  /* JROF[]:       Jump Relative On False                                  */
  /* Opcode range: 0x79                                                    */
  /* Stack:        StkElt int32 -->                                        */
  /*                                                                       */
  static void
  Ins_JROF( INS_ARG )
  {
    DO_JROF
  }


  /*************************************************************************/
  /*                                                                       */
  /* LT[]:         Less Than                                               */
  /* Opcode range: 0x50                                                    */
  /* Stack:        int32? int32? --> bool                                  */
  /*                                                                       */
  static void
  Ins_LT( INS_ARG )
  {
    DO_LT
  }


  /*************************************************************************/
  /*                                                                       */
  /* LTEQ[]:       Less Than or EQual                                      */
  /* Opcode range: 0x51                                                    */
  /* Stack:        int32? int32? --> bool                                  */
  /*                                                                       */
  static void
  Ins_LTEQ( INS_ARG )
  {
    DO_LTEQ
  }


  /*************************************************************************/
  /*                                                                       */
  /* GT[]:         Greater Than                                            */
  /* Opcode range: 0x52                                                    */
  /* Stack:        int32? int32? --> bool                                  */
  /*                                                                       */
  static void
  Ins_GT( INS_ARG )
  {
    DO_GT
  }


  /*************************************************************************/
  /*                                                                       */
  /* GTEQ[]:       Greater Than or EQual                                   */
  /* Opcode range: 0x53                                                    */
  /* Stack:        int32? int32? --> bool                                  */
  /*                                                                       */
  static void
  Ins_GTEQ( INS_ARG )
  {
    DO_GTEQ
  }


  /*************************************************************************/
  /*                                                                       */
  /* EQ[]:         EQual                                                   */
  /* Opcode range: 0x54                                                    */
  /* Stack:        StkElt StkElt --> bool                                  */
  /*                                                                       */
  static void
  Ins_EQ( INS_ARG )
  {
    DO_EQ
  }


  /*************************************************************************/
  /*                                                                       */
  /* NEQ[]:        Not EQual                                               */
  /* Opcode range: 0x55                                                    */
  /* Stack:        StkElt StkElt --> bool                                  */
  /*                                                                       */
  static void
  Ins_NEQ( INS_ARG )
  {
    DO_NEQ
  }


  /*************************************************************************/
  /*                                                                       */
  /* ODD[]:        Is ODD                                                  */
  /* Opcode range: 0x56                                                    */
  /* Stack:        f26.6 --> bool                                          */
  /*                                                                       */
  static void
  Ins_ODD( INS_ARG )
  {
    DO_ODD
  }


  /*************************************************************************/
  /*                                                                       */
  /* EVEN[]:       Is EVEN                                                 */
  /* Opcode range: 0x57                                                    */
  /* Stack:        f26.6 --> bool                                          */
  /*                                                                       */
  static void
  Ins_EVEN( INS_ARG )
  {
    DO_EVEN
  }


  /*************************************************************************/
  /*                                                                       */
  /* AND[]:        logical AND                                             */
  /* Opcode range: 0x5A                                                    */
  /* Stack:        uint32 uint32 --> uint32                                */
  /*                                                                       */
  static void
  Ins_AND( INS_ARG )
  {
    DO_AND
  }


  /*************************************************************************/
  /*                                                                       */
  /* OR[]:         logical OR                                              */
  /* Opcode range: 0x5B                                                    */
  /* Stack:        uint32 uint32 --> uint32                                */
  /*                                                                       */
  static void
  Ins_OR( INS_ARG )
  {
    DO_OR
  }


  /*************************************************************************/
  /*                                                                       */
  /* NOT[]:        logical NOT                                             */
  /* Opcode range: 0x5C                                                    */
  /* Stack:        StkElt --> uint32                                       */
  /*                                                                       */
  static void
  Ins_NOT( INS_ARG )
  {
    DO_NOT
  }


  /*************************************************************************/
  /*                                                                       */
  /* ADD[]:        ADD                                                     */
  /* Opcode range: 0x60                                                    */
  /* Stack:        f26.6 f26.6 --> f26.6                                   */
  /*                                                                       */
  static void
  Ins_ADD( INS_ARG )
  {
    DO_ADD
  }


  /*************************************************************************/
  /*                                                                       */
  /* SUB[]:        SUBtract                                                */
  /* Opcode range: 0x61                                                    */
  /* Stack:        f26.6 f26.6 --> f26.6                                   */
  /*                                                                       */
  static void
  Ins_SUB( INS_ARG )
  {
    DO_SUB
  }


  /*************************************************************************/
  /*                                                                       */
  /* DIV[]:        DIVide                                                  */
  /* Opcode range: 0x62                                                    */
  /* Stack:        f26.6 f26.6 --> f26.6                                   */
  /*                                                                       */
  static void
  Ins_DIV( INS_ARG )
  {
    DO_DIV
  }


  /*************************************************************************/
  /*                                                                       */
  /* MUL[]:        MULtiply                                                */
  /* Opcode range: 0x63                                                    */
  /* Stack:        f26.6 f26.6 --> f26.6                                   */
  /*                                                                       */
  static void
  Ins_MUL( INS_ARG )
  {
    DO_MUL
  }


  /*************************************************************************/
  /*                                                                       */
  /* ABS[]:        ABSolute value                                          */
  /* Opcode range: 0x64                                                    */
  /* Stack:        f26.6 --> f26.6                                         */
  /*                                                                       */
  static void
  Ins_ABS( INS_ARG )
  {
    DO_ABS
  }
d3623 2
a3624 11
  /*************************************************************************/
  /*                                                                       */
  /* NEG[]:        NEGate                                                  */
  /* Opcode range: 0x65                                                    */
  /* Stack: f26.6 --> f26.6                                                */
  /*                                                                       */
  static void
  Ins_NEG( INS_ARG )
  {
    DO_NEG
  }
d3626 3
d3630 5
a3634 11
  /*************************************************************************/
  /*                                                                       */
  /* FLOOR[]:      FLOOR                                                   */
  /* Opcode range: 0x66                                                    */
  /* Stack:        f26.6 --> f26.6                                         */
  /*                                                                       */
  static void
  Ins_FLOOR( INS_ARG )
  {
    DO_FLOOR
  }
d3636 10
d3647 7
a3653 11
  /*************************************************************************/
  /*                                                                       */
  /* CEILING[]:    CEILING                                                 */
  /* Opcode range: 0x67                                                    */
  /* Stack:        f26.6 --> f26.6                                         */
  /*                                                                       */
  static void
  Ins_CEILING( INS_ARG )
  {
    DO_CEILING
  }
d3655 6
d3662 2
a3663 11
  /*************************************************************************/
  /*                                                                       */
  /* RS[]:         Read Store                                              */
  /* Opcode range: 0x43                                                    */
  /* Stack:        uint32 --> uint32                                       */
  /*                                                                       */
  static void
  Ins_RS( INS_ARG )
  {
    DO_RS
  }
d3665 6
d3672 2
a3673 11
  /*************************************************************************/
  /*                                                                       */
  /* WS[]:         Write Store                                             */
  /* Opcode range: 0x42                                                    */
  /* Stack:        uint32 uint32 -->                                       */
  /*                                                                       */
  static void
  Ins_WS( INS_ARG )
  {
    DO_WS
  }
d3675 2
d3678 1
a3678 11
  /*************************************************************************/
  /*                                                                       */
  /* WCVTP[]:      Write CVT in Pixel units                                */
  /* Opcode range: 0x44                                                    */
  /* Stack:        f26.6 uint32 -->                                        */
  /*                                                                       */
  static void
  Ins_WCVTP( INS_ARG )
  {
    DO_WCVTP
  }
d3680 8
d3689 6
a3694 11
  /*************************************************************************/
  /*                                                                       */
  /* WCVTF[]:      Write CVT in Funits                                     */
  /* Opcode range: 0x70                                                    */
  /* Stack:        uint32 uint32 -->                                       */
  /*                                                                       */
  static void
  Ins_WCVTF( INS_ARG )
  {
    DO_WCVTF
  }
d3696 6
d3703 4
a3706 11
  /*************************************************************************/
  /*                                                                       */
  /* RCVT[]:       Read CVT                                                */
  /* Opcode range: 0x45                                                    */
  /* Stack:        uint32 --> f26.6                                        */
  /*                                                                       */
  static void
  Ins_RCVT( INS_ARG )
  {
    DO_RCVT
  }
d3708 9
d3718 8
a3725 11
  /*************************************************************************/
  /*                                                                       */
  /* AA[]:         Adjust Angle                                            */
  /* Opcode range: 0x7F                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_AA( INS_ARG )
  {
    /* intentionally no longer supported */
  }
d3727 5
d3733 13
a3745 13
  /*************************************************************************/
  /*                                                                       */
  /* DEBUG[]:      DEBUG.  Unsupported.                                    */
  /* Opcode range: 0x4F                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  /* Note: The original instruction pops a value from the stack.           */
  /*                                                                       */
  static void
  Ins_DEBUG( INS_ARG )
  {
    DO_DEBUG
  }
d3747 13
d3761 4
a3764 11
  /*************************************************************************/
  /*                                                                       */
  /* ROUND[ab]:    ROUND value                                             */
  /* Opcode range: 0x68-0x6B                                               */
  /* Stack:        f26.6 --> f26.6                                         */
  /*                                                                       */
  static void
  Ins_ROUND( INS_ARG )
  {
    DO_ROUND
  }
d3766 10
d3777 3
a3779 11
  /*************************************************************************/
  /*                                                                       */
  /* NROUND[ab]:   No ROUNDing of value                                    */
  /* Opcode range: 0x6C-0x6F                                               */
  /* Stack:        f26.6 --> f26.6                                         */
  /*                                                                       */
  static void
  Ins_NROUND( INS_ARG )
  {
    DO_NROUND
  }
d3781 5
d3787 1
a3787 11
  /*************************************************************************/
  /*                                                                       */
  /* MAX[]:        MAXimum                                                 */
  /* Opcode range: 0x68                                                    */
  /* Stack:        int32? int32? --> int32                                 */
  /*                                                                       */
  static void
  Ins_MAX( INS_ARG )
  {
    DO_MAX
  }
d3789 6
d3796 5
a3800 10
  /*************************************************************************/
  /*                                                                       */
  /* MIN[]:        MINimum                                                 */
  /* Opcode range: 0x69                                                    */
  /* Stack:        int32? int32? --> int32                                 */
  /*                                                                       */
  static void
  Ins_MIN( INS_ARG )
  {
    DO_MIN
a3803 3
#endif  /* !TT_CONFIG_OPTION_INTERPRETER_SWITCH */


d3806 3
a3808 10
  /* The following functions are called as is within the switch statement. */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* MINDEX[]:     Move INDEXed element                                    */
  /* Opcode range: 0x26                                                    */
  /* Stack:        int32? --> StkElt                                       */
d3811 1
a3811 1
  Ins_MINDEX( INS_ARG )
d3813 16
a3828 1
    FT_Long  L, K;
d3830 1
d3832 1
a3832 1
    L = args[0];
d3834 1
a3834 1
    if ( L <= 0 || L > CUR.args )
d3836 2
a3837 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d3840 2
a3841 2
    {
      K = CUR.stack[CUR.args - L];
d3843 1
a3843 3
      FT_ARRAY_MOVE( &CUR.stack[CUR.args - L    ],
                     &CUR.stack[CUR.args - L + 1],
                     ( L - 1 ) );
d3845 5
a3849 2
      CUR.stack[CUR.args - 1] = K;
    }
d3855 3
a3857 3
  /* ROLL[]:       ROLL top three elements                                 */
  /* Opcode range: 0x8A                                                    */
  /* Stack:        3 * StkElt --> 3 * StkElt                               */
d3860 2
a3861 1
  Ins_ROLL( INS_ARG )
d3863 3
a3865 1
    FT_Long  A, B, C;
a3866 1
    FT_UNUSED_EXEC;
d3868 1
d3870 3
a3872 3
    A = args[2];
    B = args[1];
    C = args[0];
d3874 8
a3881 4
    args[2] = C;
    args[1] = A;
    args[0] = B;
  }
d3883 5
a3888 7
  /*************************************************************************/
  /*                                                                       */
  /* MANAGING THE FLOW OF CONTROL                                          */
  /*                                                                       */
  /*   Instructions appear in the specification's order.                   */
  /*                                                                       */
  /*************************************************************************/
d3890 2
d3893 2
a3894 4
  static FT_Bool
  SkipCode( EXEC_OP )
  {
    CUR.IP += CUR.length;
d3896 2
a3897 14
    if ( CUR.IP < CUR.codeSize )
    {
      CUR.opcode = CUR.code[CUR.IP];

      CUR.length = opcode_length[CUR.opcode];
      if ( CUR.length < 0 )
      {
        if ( CUR.IP + 1 >= CUR.codeSize )
          goto Fail_Overflow;
        CUR.length = 2 - CUR.length * CUR.code[CUR.IP + 1];
      }

      if ( CUR.IP + CUR.length <= CUR.codeSize )
        return SUCCESS;
d3900 3
a3902 4
  Fail_Overflow:
    CUR.error = FT_THROW( Code_Overflow );
    return FAILURE;
  }
d3904 10
d3915 6
a3920 11
  /*************************************************************************/
  /*                                                                       */
  /* IF[]:         IF test                                                 */
  /* Opcode range: 0x58                                                    */
  /* Stack:        StkElt -->                                              */
  /*                                                                       */
  static void
  Ins_IF( INS_ARG )
  {
    FT_Int   nIfs;
    FT_Bool  Out;
d3922 1
d3924 4
a3927 2
    if ( args[0] != 0 )
      return;
d3929 1
a3929 2
    nIfs = 1;
    Out = 0;
d3931 1
a3931 4
    do
    {
      if ( SKIP_Code() == FAILURE )
        return;
d3933 1
a3933 5
      switch ( CUR.opcode )
      {
      case 0x58:      /* IF */
        nIfs++;
        break;
d3935 1
a3935 3
      case 0x1B:      /* ELSE */
        Out = FT_BOOL( nIfs == 1 );
        break;
d3937 2
a3938 6
      case 0x59:      /* EIF */
        nIfs--;
        Out = FT_BOOL( nIfs == 0 );
        break;
      }
    } while ( Out == 0 );
d3944 3
a3946 3
  /* ELSE[]:       ELSE                                                    */
  /* Opcode range: 0x1B                                                    */
  /* Stack:        -->                                                     */
d3949 2
a3950 1
  Ins_ELSE( INS_ARG )
d3952 3
a3954 1
    FT_Int  nIfs;
a3955 1
    FT_UNUSED_ARG;
d3957 4
d3962 8
a3969 1
    nIfs = 1;
d3971 2
a3972 1
    do
d3974 2
a3975 2
      if ( SKIP_Code() == FAILURE )
        return;
a3976 5
      switch ( CUR.opcode )
      {
      case 0x58:    /* IF */
        nIfs++;
        break;
d3978 2
a3979 6
      case 0x59:    /* EIF */
        nIfs--;
        break;
      }
    } while ( nIfs != 0 );
  }
d3981 2
d3984 3
a3986 7
  /*************************************************************************/
  /*                                                                       */
  /* DEFINING AND USING FUNCTIONS AND INSTRUCTIONS                         */
  /*                                                                       */
  /*   Instructions appear in the specification's order.                   */
  /*                                                                       */
  /*************************************************************************/
d3988 3
a3990 13

  /*************************************************************************/
  /*                                                                       */
  /* FDEF[]:       Function DEFinition                                     */
  /* Opcode range: 0x2C                                                    */
  /* Stack:        uint32 -->                                              */
  /*                                                                       */
  static void
  Ins_FDEF( INS_ARG )
  {
    FT_ULong       n;
    TT_DefRecord*  rec;
    TT_DefRecord*  limit;
d3993 6
a3998 97
    /* arguments to opcodes are skipped by `SKIP_Code' */
    FT_Byte    opcode_pattern[9][12] = {
                 /* #0 inline delta function 1 */
                 {
                   0x4B, /* PPEM    */
                   0x53, /* GTEQ    */
                   0x23, /* SWAP    */
                   0x4B, /* PPEM    */
                   0x51, /* LTEQ    */
                   0x5A, /* AND     */
                   0x58, /* IF      */
                   0x38, /*   SHPIX */
                   0x1B, /* ELSE    */
                   0x21, /*   POP   */
                   0x21, /*   POP   */
                   0x59  /* EIF     */
                 },
                 /* #1 inline delta function 2 */
                 {
                   0x4B, /* PPEM    */
                   0x54, /* EQ      */
                   0x58, /* IF      */
                   0x38, /*   SHPIX */
                   0x1B, /* ELSE    */
                   0x21, /*   POP   */
                   0x21, /*   POP   */
                   0x59  /* EIF     */
                 },
                 /* #2 diagonal stroke function */
                 {
                   0x20, /* DUP     */
                   0x20, /* DUP     */
                   0xB0, /* PUSHB_1 */
                         /*   1     */
                   0x60, /* ADD     */
                   0x46, /* GC_cur  */
                   0xB0, /* PUSHB_1 */
                         /*   64    */
                   0x23, /* SWAP    */
                   0x42  /* WS      */
                 },
                 /* #3 VacuFormRound function */
                 {
                   0x45, /* RCVT    */
                   0x23, /* SWAP    */
                   0x46, /* GC_cur  */
                   0x60, /* ADD     */
                   0x20, /* DUP     */
                   0xB0  /* PUSHB_1 */
                         /*   38    */
                 },
                 /* #4 TTFautohint bytecode (old) */
                 {
                   0x20, /* DUP     */
                   0x64, /* ABS     */
                   0xB0, /* PUSHB_1 */
                         /*   32    */
                   0x60, /* ADD     */
                   0x66, /* FLOOR   */
                   0x23, /* SWAP    */
                   0xB0  /* PUSHB_1 */
                 },
                 /* #5 spacing function 1 */
                 {
                   0x01, /* SVTCA_x */
                   0xB0, /* PUSHB_1 */
                         /*   24    */
                   0x43, /* RS      */
                   0x58  /* IF      */
                 },
                 /* #6 spacing function 2 */
                 {
                   0x01, /* SVTCA_x */
                   0x18, /* RTG     */
                   0xB0, /* PUSHB_1 */
                         /*   24    */
                   0x43, /* RS      */
                   0x58  /* IF      */
                 },
                 /* #7 TypeMan Talk DiagEndCtrl function */
                 {
                   0x01, /* SVTCA_x */
                   0x20, /* DUP     */
                   0xB0, /* PUSHB_1 */
                         /*   3     */
                   0x25, /* CINDEX  */
                 },
                 /* #8 TypeMan Talk Align */
                 {
                   0x06, /* SPVTL   */
                   0x7D, /* RDTG    */
                 },
               };
    FT_UShort  opcode_patterns   = 9;
    FT_UShort  opcode_pointer[9] = {  0, 0, 0, 0, 0, 0, 0, 0, 0 };
    FT_UShort  opcode_size[9]    = { 12, 8, 8, 6, 7, 4, 5, 4, 2 };
    FT_UShort  i;
d4001 43
d4045 8
a4052 2
    /* some font programs are broken enough to redefine functions! */
    /* We will then parse the current table.                       */
d4054 10
a4063 3
    rec   = CUR.FDefs;
    limit = rec + CUR.numFDefs;
    n     = args[0];
d4065 2
a4066 1
    for ( ; rec < limit; rec++ )
d4068 2
a4069 2
      if ( rec->opc == n )
        break;
d4072 12
a4083 1
    if ( rec == limit )
d4085 1
a4085 2
      /* check that there is enough room for new functions */
      if ( CUR.numFDefs >= CUR.maxFDefs )
d4087 5
a4091 1
        CUR.error = FT_THROW( Too_Many_Function_Defs );
a4093 1
      CUR.numFDefs++;
d4095 22
d4118 3
a4120 3
    /* Although FDEF takes unsigned 32-bit integer,  */
    /* func # must be within unsigned 16-bit integer */
    if ( n > 0xFFFFU )
d4122 1
a4122 1
      CUR.error = FT_THROW( Too_Many_Function_Defs );
d4126 6
a4131 6
    rec->range          = CUR.curRange;
    rec->opc            = (FT_UInt16)n;
    rec->start          = CUR.IP + 1;
    rec->active         = TRUE;
    rec->inline_delta   = FALSE;
    rec->sph_fdef_flags = 0x0000;
d4133 11
a4143 2
    if ( n > CUR.maxFunc )
      CUR.maxFunc = (FT_UInt16)n;
a4144 6
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    /* We don't know for sure these are typeman functions, */
    /* however they are only active when RS 22 is called   */
    if ( n >= 64 && n <= 66 )
      rec->sph_fdef_flags |= SPH_FDEF_TYPEMAN_STROKES;
#endif
d4146 1
a4146 2
    /* Now skip the whole function definition. */
    /* We don't allow nested IDEFS & FDEFs.    */
d4148 1
a4148 1
    while ( SKIP_Code() == SUCCESS )
d4150 3
d4154 1
a4154 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d4156 2
a4157 8
      if ( SUBPIXEL_HINTING )
      {
        for ( i = 0; i < opcode_patterns; i++ )
        {
          if ( opcode_pointer[i] < opcode_size[i]                 &&
               CUR.opcode == opcode_pattern[i][opcode_pointer[i]] )
          {
            opcode_pointer[i] += 1;
d4159 3
a4161 6
            if ( opcode_pointer[i] == opcode_size[i] )
            {
              FT_TRACE7(( "sph: Function %d, opcode ptrn: %d, %s %s\n",
                          i, n,
                          CUR.face->root.family_name,
                          CUR.face->root.style_name ));
a4162 6
              switch ( i )
              {
              case 0:
                rec->sph_fdef_flags            |= SPH_FDEF_INLINE_DELTA_1;
                CUR.face->sph_found_func_flags |= SPH_FDEF_INLINE_DELTA_1;
                break;
d4164 11
a4174 4
              case 1:
                rec->sph_fdef_flags            |= SPH_FDEF_INLINE_DELTA_2;
                CUR.face->sph_found_func_flags |= SPH_FDEF_INLINE_DELTA_2;
                break;
a4175 9
              case 2:
                switch ( n )
                {
                  /* needs to be implemented still */
                case 58:
                  rec->sph_fdef_flags            |= SPH_FDEF_DIAGONAL_STROKE;
                  CUR.face->sph_found_func_flags |= SPH_FDEF_DIAGONAL_STROKE;
                }
                break;
d4177 1
a4177 8
              case 3:
                switch ( n )
                {
                case 0:
                  rec->sph_fdef_flags            |= SPH_FDEF_VACUFORM_ROUND_1;
                  CUR.face->sph_found_func_flags |= SPH_FDEF_VACUFORM_ROUND_1;
                }
                break;
d4179 5
a4183 5
              case 4:
                /* probably not necessary to detect anymore */
                rec->sph_fdef_flags            |= SPH_FDEF_TTFAUTOHINT_1;
                CUR.face->sph_found_func_flags |= SPH_FDEF_TTFAUTOHINT_1;
                break;
d4185 3
a4187 13
              case 5:
                switch ( n )
                {
                case 0:
                case 1:
                case 2:
                case 4:
                case 7:
                case 8:
                  rec->sph_fdef_flags            |= SPH_FDEF_SPACING_1;
                  CUR.face->sph_found_func_flags |= SPH_FDEF_SPACING_1;
                }
                break;
a4188 13
              case 6:
                switch ( n )
                {
                case 0:
                case 1:
                case 2:
                case 4:
                case 7:
                case 8:
                  rec->sph_fdef_flags            |= SPH_FDEF_SPACING_2;
                  CUR.face->sph_found_func_flags |= SPH_FDEF_SPACING_2;
                }
                break;
d4190 11
a4200 4
               case 7:
                 rec->sph_fdef_flags            |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
                 CUR.face->sph_found_func_flags |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
                 break;
a4201 10
               case 8:
#if 0
                 rec->sph_fdef_flags            |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
                 CUR.face->sph_found_func_flags |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
#endif
                 break;
              }
              opcode_pointer[i] = 0;
            }
          }
d4203 1
a4203 3
          else
            opcode_pointer[i] = 0;
        }
d4205 5
a4209 5
        /* Set sph_compatibility_mode only when deltas are detected */
        CUR.face->sph_compatibility_mode =
          ( ( CUR.face->sph_found_func_flags & SPH_FDEF_INLINE_DELTA_1 ) |
            ( CUR.face->sph_found_func_flags & SPH_FDEF_INLINE_DELTA_2 ) );
      }
d4211 1
a4211 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d4213 2
a4214 6
      switch ( CUR.opcode )
      {
      case 0x89:    /* IDEF */
      case 0x2C:    /* FDEF */
        CUR.error = FT_THROW( Nested_DEFS );
        return;
d4216 1
a4216 5
      case 0x2D:   /* ENDF */
        rec->end = CUR.IP;
        return;
      }
    }
d4222 1
a4222 3
  /* ENDF[]:       END Function definition                                 */
  /* Opcode range: 0x2D                                                    */
  /* Stack:        -->                                                     */
d4224 8
a4231 2
  static void
  Ins_ENDF( INS_ARG )
d4233 3
a4235 3
    TT_CallRec*  pRec;

    FT_UNUSED_ARG;
d4237 1
a4238 3
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    CUR.sph_in_func_flags = 0x0000;
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d4240 2
a4241 1
    if ( CUR.callTop <= 0 )     /* We encountered an ENDF without a call */
d4243 3
a4245 2
      CUR.error = FT_THROW( ENDF_In_Exec_Stream );
      return;
d4248 2
a4249 1
    CUR.callTop--;
d4251 2
a4252 1
    pRec = &CUR.callStack[CUR.callTop];
d4254 4
a4257 1
    pRec->Cur_Count--;
d4259 5
a4263 1
    CUR.step_ins = FALSE;
d4265 1
a4265 1
    if ( pRec->Cur_Count > 0 )
d4267 3
a4269 2
      CUR.callTop++;
      CUR.IP = pRec->Def->start;
a4270 4
    else
      /* Loop through the current function */
      INS_Goto_CodeRange( pRec->Caller_Range,
                          pRec->Caller_IP );
d4272 1
a4272 1
    /* Exit the current call frame.                      */
d4274 1
a4274 5
    /* NOTE: If the last instruction of a program is a   */
    /*       CALL or LOOPCALL, the return address is     */
    /*       always out of the code range.  This is a    */
    /*       valid address, and it is why we do not test */
    /*       the result of Ins_Goto_CodeRange() here!    */
d4280 11
a4290 3
  /* CALL[]:       CALL function                                           */
  /* Opcode range: 0x2B                                                    */
  /* Stack:        uint32? -->                                             */
d4293 1
a4293 1
  Ins_CALL( INS_ARG )
d4295 1
a4295 3
    FT_ULong       F;
    TT_CallRec*    pCrec;
    TT_DefRecord*  def;
d4297 1
a4298 5
    /* first of all, check the index */

    F = args[0];
    if ( BOUNDSL( F, CUR.maxFunc + 1 ) )
      goto Fail;
d4300 2
a4301 8
    /* Except for some old Apple fonts, all functions in a TrueType */
    /* font are defined in increasing order, starting from 0.  This */
    /* means that we normally have                                  */
    /*                                                              */
    /*    CUR.maxFunc+1 == CUR.numFDefs                             */
    /*    CUR.FDefs[n].opc == n for n in 0..CUR.maxFunc             */
    /*                                                              */
    /* If this isn't true, we need to look up the function table.   */
d4303 1
a4303 2
    def = CUR.FDefs + F;
    if ( CUR.maxFunc + 1 != CUR.numFDefs || def->opc != F )
d4305 2
a4306 9
      /* look up the FDefs table */
      TT_DefRecord*  limit;


      def   = CUR.FDefs;
      limit = def + CUR.numFDefs;

      while ( def < limit && def->opc != F )
        def++;
d4308 2
a4309 2
      if ( def == limit )
        goto Fail;
a4310 12

    /* check that the function is active */
    if ( !def->active )
      goto Fail;

#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING                                              &&
         CUR.ignore_x_mode                                             &&
         ( ( CUR.iup_called                                        &&
             ( CUR.sph_tweak_flags & SPH_TWEAK_NO_CALL_AFTER_IUP ) ) ||
           ( def->sph_fdef_flags & SPH_FDEF_VACUFORM_ROUND_1 )       ) )
      goto Fail;
d4312 1
a4312 2
      CUR.sph_in_func_flags = def->sph_fdef_flags;
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d4314 1
a4314 2
    /* check the call stack */
    if ( CUR.callTop >= CUR.callSize )
d4316 2
a4317 2
      CUR.error = FT_THROW( Stack_Overflow );
      return;
d4319 2
d4322 2
a4323 1
    pCrec = CUR.callStack + CUR.callTop;
a4324 4
    pCrec->Caller_Range = CUR.curRange;
    pCrec->Caller_IP    = CUR.IP + 1;
    pCrec->Cur_Count    = 1;
    pCrec->Def          = def;
d4326 20
a4345 1
    CUR.callTop++;
a4346 2
    INS_Goto_CodeRange( def->range,
                        def->start );
d4348 19
a4366 1
    CUR.step_ins = FALSE;
a4367 1
    return;
d4369 12
a4380 2
  Fail:
    CUR.error = FT_THROW( Invalid_Reference );
d4386 3
a4388 3
  /* LOOPCALL[]:   LOOP and CALL function                                  */
  /* Opcode range: 0x2A                                                    */
  /* Stack:        uint32? Eint16? -->                                     */
d4391 2
a4392 1
  Ins_LOOPCALL( INS_ARG )
d4394 2
a4395 3
    FT_ULong       F;
    TT_CallRec*    pCrec;
    TT_DefRecord*  def;
d4398 5
a4402 4
    /* first of all, check the index */
    F = args[1];
    if ( BOUNDSL( F, CUR.maxFunc + 1 ) )
      goto Fail;
d4404 1
a4404 8
    /* Except for some old Apple fonts, all functions in a TrueType */
    /* font are defined in increasing order, starting from 0.  This */
    /* means that we normally have                                  */
    /*                                                              */
    /*    CUR.maxFunc+1 == CUR.numFDefs                             */
    /*    CUR.FDefs[n].opc == n for n in 0..CUR.maxFunc             */
    /*                                                              */
    /* If this isn't true, we need to look up the function table.   */
d4406 4
a4409 5
    def = CUR.FDefs + F;
    if ( CUR.maxFunc + 1 != CUR.numFDefs || def->opc != F )
    {
      /* look up the FDefs table */
      TT_DefRecord*  limit;
d4412 12
a4423 2
      def   = CUR.FDefs;
      limit = def + CUR.numFDefs;
a4424 2
      while ( def < limit && def->opc != F )
        def++;
d4426 5
a4430 3
      if ( def == limit )
        goto Fail;
    }
d4432 4
a4435 3
    /* check that the function is active */
    if ( !def->active )
      goto Fail;
a4436 8
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    if ( SUBPIXEL_HINTING                                    &&
         CUR.ignore_x_mode                                   &&
         ( def->sph_fdef_flags & SPH_FDEF_VACUFORM_ROUND_1 ) )
      goto Fail;
    else
      CUR.sph_in_func_flags = def->sph_fdef_flags;
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d4438 12
a4449 2
    /* check stack */
    if ( CUR.callTop >= CUR.callSize )
d4451 2
a4452 2
      CUR.error = FT_THROW( Stack_Overflow );
      return;
d4454 1
a4454 2

    if ( args[0] > 0 )
d4456 8
a4463 1
      pCrec = CUR.callStack + CUR.callTop;
a4464 4
      pCrec->Caller_Range = CUR.curRange;
      pCrec->Caller_IP    = CUR.IP + 1;
      pCrec->Cur_Count    = (FT_Int)args[0];
      pCrec->Def          = def;
d4466 20
a4485 5
      CUR.callTop++;

      INS_Goto_CodeRange( def->range, def->start );

      CUR.step_ins = FALSE;
d4487 5
a4492 1
    return;
d4494 11
a4504 2
  Fail:
    CUR.error = FT_THROW( Invalid_Reference );
d4510 3
a4512 3
  /* IDEF[]:       Instruction DEFinition                                  */
  /* Opcode range: 0x89                                                    */
  /* Stack:        Eint8 -->                                               */
d4515 2
a4516 1
  Ins_IDEF( INS_ARG )
d4518 2
a4519 2
    TT_DefRecord*  def;
    TT_DefRecord*  limit;
d4522 12
a4533 1
    /*  First of all, look for the same function in our table */
a4534 2
    def   = CUR.IDefs;
    limit = def + CUR.numIDefs;
d4536 11
a4546 45
    for ( ; def < limit; def++ )
      if ( def->opc == (FT_ULong)args[0] )
        break;

    if ( def == limit )
    {
      /* check that there is enough room for a new instruction */
      if ( CUR.numIDefs >= CUR.maxIDefs )
      {
        CUR.error = FT_THROW( Too_Many_Instruction_Defs );
        return;
      }
      CUR.numIDefs++;
    }

    /* opcode must be unsigned 8-bit integer */
    if ( 0 > args[0] || args[0] > 0x00FF )
    {
      CUR.error = FT_THROW( Too_Many_Instruction_Defs );
      return;
    }

    def->opc    = (FT_Byte)args[0];
    def->start  = CUR.IP + 1;
    def->range  = CUR.curRange;
    def->active = TRUE;

    if ( (FT_ULong)args[0] > CUR.maxIns )
      CUR.maxIns = (FT_Byte)args[0];

    /* Now skip the whole function definition. */
    /* We don't allow nested IDEFs & FDEFs.    */

    while ( SKIP_Code() == SUCCESS )
    {
      switch ( CUR.opcode )
      {
      case 0x89:   /* IDEF */
      case 0x2C:   /* FDEF */
        CUR.error = FT_THROW( Nested_DEFS );
        return;
      case 0x2D:   /* ENDF */
        return;
      }
    }
d4552 13
a4564 1
  /* PUSHING DATA ONTO THE INTERPRETER STACK                               */
d4566 3
a4568 1
  /*   Instructions appear in the specification's order.                   */
d4570 6
a4575 1
  /*************************************************************************/
d4580 3
a4582 3
  /* NPUSHB[]:     PUSH N Bytes                                            */
  /* Opcode range: 0x40                                                    */
  /* Stack:        --> uint32...                                           */
d4585 2
a4586 1
  Ins_NPUSHB( INS_ARG )
d4588 3
a4590 1
    FT_UShort  L, K;
d4593 11
a4603 1
    L = (FT_UShort)CUR.code[CUR.IP + 1];
a4604 5
    if ( BOUNDS( L, CUR.stackSize + 1 - CUR.top ) )
    {
      CUR.error = FT_THROW( Stack_Overflow );
      return;
    }
d4606 10
a4615 4
    for ( K = 1; K <= L; K++ )
      args[K - 1] = CUR.code[CUR.IP + K + 1];

    CUR.new_top += L;
d4621 3
a4623 3
  /* NPUSHW[]:     PUSH N Words                                            */
  /* Opcode range: 0x41                                                    */
  /* Stack:        --> int32...                                            */
d4626 1
a4626 1
  Ins_NPUSHW( INS_ARG )
d4628 2
a4629 1
    FT_UShort  L, K;
d4632 12
a4643 1
    L = (FT_UShort)CUR.code[CUR.IP + 1];
a4644 5
    if ( BOUNDS( L, CUR.stackSize + 1 - CUR.top ) )
    {
      CUR.error = FT_THROW( Stack_Overflow );
      return;
    }
d4646 15
a4660 1
    CUR.IP += 2;
a4661 2
    for ( K = 0; K < L; K++ )
      args[K] = GET_ShortIns();
d4663 11
a4673 2
    CUR.step_ins = FALSE;
    CUR.new_top += L;
d4679 3
a4681 3
  /* PUSHB[abc]:   PUSH Bytes                                              */
  /* Opcode range: 0xB0-0xB7                                               */
  /* Stack:        --> uint32...                                           */
d4684 1
a4684 1
  Ins_PUSHB( INS_ARG )
d4686 3
a4688 1
    FT_UShort  L, K;
d4691 11
a4701 1
    L = (FT_UShort)( CUR.opcode - 0xB0 + 1 );
a4702 5
    if ( BOUNDS( L, CUR.stackSize + 1 - CUR.top ) )
    {
      CUR.error = FT_THROW( Stack_Overflow );
      return;
    }
d4704 10
a4713 2
    for ( K = 1; K <= L; K++ )
      args[K - 1] = CUR.code[CUR.IP + K];
d4719 3
a4721 3
  /* PUSHW[abc]:   PUSH Words                                              */
  /* Opcode range: 0xB8-0xBF                                               */
  /* Stack:        --> int32...                                            */
d4724 1
a4724 1
  Ins_PUSHW( INS_ARG )
d4726 3
a4728 1
    FT_UShort  L, K;
d4731 12
a4742 1
    L = (FT_UShort)( CUR.opcode - 0xB8 + 1 );
a4743 5
    if ( BOUNDS( L, CUR.stackSize + 1 - CUR.top ) )
    {
      CUR.error = FT_THROW( Stack_Overflow );
      return;
    }
d4745 11
a4755 1
    CUR.IP++;
d4757 2
a4758 4
    for ( K = 0; K < L; K++ )
      args[K] = GET_ShortIns();

    CUR.step_ins = FALSE;
d4764 3
a4766 1
  /* MANAGING THE GRAPHICS STATE                                           */
d4768 9
a4776 3
  /*  Instructions appear in the specs' order.                             */
  /*                                                                       */
  /*************************************************************************/
d4789 2
a4790 1
  Ins_GC( INS_ARG )
d4798 1
a4798 1
    if ( BOUNDSL( L, CUR.zp2.n_points ) )
d4800 2
a4801 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d4806 2
a4807 2
      if ( CUR.opcode & 1 )
        R = CUR_fast_dualproj( &CUR.zp2.org[L] );
d4809 1
a4809 1
        R = CUR_fast_project( &CUR.zp2.cur[L] );
d4827 2
a4828 1
  Ins_SCFS( INS_ARG )
d4836 1
a4836 1
    if ( BOUNDS( L, CUR.zp2.n_points ) )
d4838 2
a4839 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d4843 1
a4843 1
    K = CUR_fast_project( &CUR.zp2.cur[L] );
d4845 1
a4845 1
    CUR_Func_move( &CUR.zp2, L, args[1] - K );
d4849 2
a4850 2
    if ( CUR.GS.gep2 == 0 )
      CUR.zp2.org[L] = CUR.zp2.cur[L];
d4870 2
a4871 1
  Ins_MD( INS_ARG )
d4880 2
a4881 2
    if ( BOUNDS( L, CUR.zp0.n_points ) ||
         BOUNDS( K, CUR.zp1.n_points ) )
d4883 2
a4884 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d4889 2
a4890 2
      if ( CUR.opcode & 1 )
        D = CUR_Func_project( CUR.zp0.cur + L, CUR.zp1.cur + K );
d4895 1
a4895 1
        if ( CUR.GS.gep0 == 0 || CUR.GS.gep1 == 0 )
d4897 2
a4898 2
          FT_Vector*  vec1 = CUR.zp0.org + L;
          FT_Vector*  vec2 = CUR.zp1.org + K;
d4901 1
a4901 1
          D = CUR_Func_dualproj( vec1, vec2 );
d4905 2
a4906 2
          FT_Vector*  vec1 = CUR.zp0.orus + L;
          FT_Vector*  vec2 = CUR.zp1.orus + K;
d4909 1
a4909 1
          if ( CUR.metrics.x_scale == CUR.metrics.y_scale )
d4912 2
a4913 2
            D = CUR_Func_dualproj( vec1, vec2 );
            D = FT_MulFix( D, CUR.metrics.x_scale );
d4920 2
a4921 2
            vec.x = FT_MulFix( vec1->x - vec2->x, CUR.metrics.x_scale );
            vec.y = FT_MulFix( vec1->y - vec2->y, CUR.metrics.y_scale );
d4923 1
a4923 1
            D = CUR_fast_dualproj( &vec );
d4931 3
a4933 2
    if ( SUBPIXEL_HINTING                       &&
         CUR.ignore_x_mode && FT_ABS( D ) == 64 )
d4943 1
a4943 1
  /* SDPVTL[a]:    Set Dual PVector to Line                                */
d4948 2
a4949 1
  Ins_SDPVTL( INS_ARG )
d4953 2
a4954 1
    FT_Int     aOpc = CUR.opcode;
d4960 2
a4961 2
    if ( BOUNDS( p2, CUR.zp1.n_points ) ||
         BOUNDS( p1, CUR.zp2.n_points ) )
d4963 2
a4964 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d4969 2
a4970 2
      FT_Vector* v1 = CUR.zp1.org + p2;
      FT_Vector* v2 = CUR.zp2.org + p1;
d4976 1
a4976 1
      /* If v1 == v2, SDPVTL behaves the same as */
d4983 2
a4984 2
        A    = 0x4000;
        aOpc = 0;
d4988 1
a4988 1
    if ( ( aOpc & 1 ) != 0 )
d4995 1
a4995 1
    NORMalize( A, B, &CUR.GS.dualVector );
d4998 2
a4999 2
      FT_Vector*  v1 = CUR.zp1.cur + p2;
      FT_Vector*  v2 = CUR.zp2.cur + p1;
d5007 2
a5008 2
        A    = 0x4000;
        aOpc = 0;
d5012 1
a5012 1
    if ( ( aOpc & 1 ) != 0 )
d5019 1
a5019 2
    NORMalize( A, B, &CUR.GS.projVector );

d5021 1
a5021 2

    COMPUTE_Funcs();
d5032 2
a5033 1
  Ins_SZP0( INS_ARG )
d5038 1
a5038 1
      CUR.zp0 = CUR.twilight;
d5042 1
a5042 1
      CUR.zp0 = CUR.pts;
d5046 2
a5047 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5051 1
a5051 1
    CUR.GS.gep0 = (FT_UShort)args[0];
d5062 2
a5063 1
  Ins_SZP1( INS_ARG )
d5068 1
a5068 1
      CUR.zp1 = CUR.twilight;
d5072 1
a5072 1
      CUR.zp1 = CUR.pts;
d5076 2
a5077 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5081 1
a5081 1
    CUR.GS.gep1 = (FT_UShort)args[0];
d5092 2
a5093 1
  Ins_SZP2( INS_ARG )
d5098 1
a5098 1
      CUR.zp2 = CUR.twilight;
d5102 1
a5102 1
      CUR.zp2 = CUR.pts;
d5106 2
a5107 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5111 1
a5111 1
    CUR.GS.gep2 = (FT_UShort)args[0];
d5122 2
a5123 1
  Ins_SZPS( INS_ARG )
d5128 1
a5128 1
      CUR.zp0 = CUR.twilight;
d5132 1
a5132 1
      CUR.zp0 = CUR.pts;
d5136 2
a5137 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5141 2
a5142 2
    CUR.zp1 = CUR.zp0;
    CUR.zp2 = CUR.zp0;
d5144 3
a5146 3
    CUR.GS.gep0 = (FT_UShort)args[0];
    CUR.GS.gep1 = (FT_UShort)args[0];
    CUR.GS.gep2 = (FT_UShort)args[0];
d5157 2
a5158 1
  Ins_INSTCTRL( INS_ARG )
d5160 1
a5160 1
    FT_Long  K, L;
d5166 3
a5168 1
    if ( K < 1 || K > 2 )
d5170 2
a5171 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5175 3
d5179 12
a5190 1
        L = K;
d5192 6
a5197 2
    CUR.GS.instruct_control = FT_BOOL(
      ( (FT_Byte)CUR.GS.instruct_control & ~(FT_Byte)K ) | (FT_Byte)L );
d5208 2
a5209 1
  Ins_SCANCTRL( INS_ARG )
d5219 1
a5219 1
      CUR.GS.scan_control = TRUE;
d5224 1
a5224 1
      CUR.GS.scan_control = FALSE;
d5228 2
a5229 2
    if ( ( args[0] & 0x100 ) != 0 && CUR.tt_metrics.ppem <= A )
      CUR.GS.scan_control = TRUE;
d5231 2
a5232 2
    if ( ( args[0] & 0x200 ) != 0 && CUR.tt_metrics.rotated )
      CUR.GS.scan_control = TRUE;
d5234 2
a5235 2
    if ( ( args[0] & 0x400 ) != 0 && CUR.tt_metrics.stretched )
      CUR.GS.scan_control = TRUE;
d5237 2
a5238 2
    if ( ( args[0] & 0x800 ) != 0 && CUR.tt_metrics.ppem > A )
      CUR.GS.scan_control = FALSE;
d5240 2
a5241 2
    if ( ( args[0] & 0x1000 ) != 0 && CUR.tt_metrics.rotated )
      CUR.GS.scan_control = FALSE;
d5243 2
a5244 2
    if ( ( args[0] & 0x2000 ) != 0 && CUR.tt_metrics.stretched )
      CUR.GS.scan_control = FALSE;
d5255 2
a5256 1
  Ins_SCANTYPE( INS_ARG )
d5259 1
a5259 1
      CUR.GS.scan_type = (FT_Int)args[0];
a5266 2
  /*   Instructions appear in the specification's order.                   */
  /*                                                                       */
d5277 1
a5277 1
  Ins_FLIPPT( INS_ARG )
a5280 2
    FT_UNUSED_ARG;

d5282 1
a5282 1
    if ( CUR.top < CUR.GS.loop )
d5284 2
a5285 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Too_Few_Arguments );
d5289 1
a5289 1
    while ( CUR.GS.loop > 0 )
d5291 1
a5291 1
      CUR.args--;
d5293 1
a5293 1
      point = (FT_UShort)CUR.stack[CUR.args];
d5295 1
a5295 1
      if ( BOUNDS( point, CUR.pts.n_points ) )
d5297 1
a5297 1
        if ( CUR.pedantic_hinting )
d5299 1
a5299 1
          CUR.error = FT_THROW( Invalid_Reference );
d5304 1
a5304 1
        CUR.pts.tags[point] ^= FT_CURVE_TAG_ON;
d5306 1
a5306 1
      CUR.GS.loop--;
d5310 2
a5311 2
    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
d5322 2
a5323 1
  Ins_FLIPRGON( INS_ARG )
d5331 2
a5332 2
    if ( BOUNDS( K, CUR.pts.n_points ) ||
         BOUNDS( L, CUR.pts.n_points ) )
d5334 2
a5335 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5340 1
a5340 1
      CUR.pts.tags[I] |= FT_CURVE_TAG_ON;
d5351 2
a5352 1
  Ins_FLIPRGOFF( INS_ARG )
d5360 2
a5361 2
    if ( BOUNDS( K, CUR.pts.n_points ) ||
         BOUNDS( L, CUR.pts.n_points ) )
d5363 2
a5364 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5369 1
a5369 1
      CUR.pts.tags[I] &= ~FT_CURVE_TAG_ON;
d5374 5
a5378 4
  Compute_Point_Displacement( EXEC_OP_ FT_F26Dot6*   x,
                                       FT_F26Dot6*   y,
                                       TT_GlyphZone  zone,
                                       FT_UShort*    refp )
d5385 1
a5385 1
    if ( CUR.opcode & 1 )
d5387 2
a5388 2
      zp = CUR.zp0;
      p  = CUR.GS.rp1;
d5392 2
a5393 2
      zp = CUR.zp1;
      p  = CUR.GS.rp2;
d5398 2
a5399 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5407 1
a5407 1
    d = CUR_Func_project( zp.cur + p, zp.org + p );
d5410 1
a5410 1
    if ( CUR.face->unpatented_hinting )
d5412 1
a5412 1
      if ( CUR.GS.both_x_axis )
d5426 2
a5427 2
      *x = FT_MulDiv( d, (FT_Long)CUR.GS.freeVector.x, CUR.F_dot_P );
      *y = FT_MulDiv( d, (FT_Long)CUR.GS.freeVector.y, CUR.F_dot_P );
d5435 5
a5439 4
  Move_Zp2_Point( EXEC_OP_ FT_UShort   point,
                           FT_F26Dot6  dx,
                           FT_F26Dot6  dy,
                           FT_Bool     touch )
d5442 1
a5442 1
    if ( CUR.face->unpatented_hinting )
d5444 1
a5444 1
      if ( CUR.GS.both_x_axis )
d5446 1
a5446 1
        CUR.zp2.cur[point].x += dx;
d5448 1
a5448 1
          CUR.zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;
d5452 1
a5452 1
        CUR.zp2.cur[point].y += dy;
d5454 1
a5454 1
          CUR.zp2.tags[point] |= FT_CURVE_TAG_TOUCH_Y;
d5460 1
a5460 1
    if ( CUR.GS.freeVector.x != 0 )
d5462 1
a5462 1
      CUR.zp2.cur[point].x += dx;
d5464 1
a5464 1
        CUR.zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;
d5467 1
a5467 1
    if ( CUR.GS.freeVector.y != 0 )
d5469 1
a5469 1
      CUR.zp2.cur[point].y += dy;
d5471 1
a5471 1
        CUR.zp2.tags[point] |= FT_CURVE_TAG_TOUCH_Y;
d5483 1
a5483 1
  Ins_SHP( INS_ARG )
d5488 1
a5488 2
    FT_F26Dot6       dx,
                     dy;
a5490 2
    FT_UNUSED_ARG;

d5492 1
a5492 1
    if ( CUR.top < CUR.GS.loop )
d5494 2
a5495 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5499 1
a5499 1
    if ( COMPUTE_Point_Displacement( &dx, &dy, &zp, &refp ) )
d5502 1
a5502 1
    while ( CUR.GS.loop > 0 )
d5504 2
a5505 2
      CUR.args--;
      point = (FT_UShort)CUR.stack[CUR.args];
d5507 1
a5507 1
      if ( BOUNDS( point, CUR.zp2.n_points ) )
d5509 1
a5509 1
        if ( CUR.pedantic_hinting )
d5511 1
a5511 1
          CUR.error = FT_THROW( Invalid_Reference );
d5518 3
a5520 3
      if ( SUBPIXEL_HINTING  &&
           CUR.ignore_x_mode )
        MOVE_Zp2_Point( point, 0, dy, TRUE );
d5523 1
a5523 1
        MOVE_Zp2_Point( point, dx, dy, TRUE );
d5525 1
a5525 1
      CUR.GS.loop--;
d5529 2
a5530 2
    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
d5545 2
a5546 1
  Ins_SHC( INS_ARG )
d5556 2
a5557 2
    contour = (FT_UShort)args[0];
    bounds  = ( CUR.GS.gep2 == 0 ) ? 1 : CUR.zp2.n_contours;
d5561 2
a5562 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5566 1
a5566 1
    if ( COMPUTE_Point_Displacement( &dx, &dy, &zp, &refp ) )
d5572 2
a5573 2
      start = (FT_UShort)( CUR.zp2.contours[contour - 1] + 1 -
                           CUR.zp2.first_point );
d5576 2
a5577 2
    if ( CUR.GS.gep2 == 0 )
      limit = CUR.zp2.n_points;
d5579 2
a5580 2
      limit = (FT_UShort)( CUR.zp2.contours[contour] -
                           CUR.zp2.first_point + 1 );
d5584 2
a5585 2
      if ( zp.cur != CUR.zp2.cur || refp != i )
        MOVE_Zp2_Point( i, dx, dy, TRUE );
d5597 2
a5598 1
  Ins_SHZ( INS_ARG )
d5610 2
a5611 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5615 1
a5615 1
    if ( COMPUTE_Point_Displacement( &dx, &dy, &zp, &refp ) )
d5622 4
a5625 4
    if ( CUR.GS.gep2 == 0 )
      limit = (FT_UShort)CUR.zp2.n_points;
    else if ( CUR.GS.gep2 == 1 && CUR.zp2.n_contours > 0 )
      limit = (FT_UShort)( CUR.zp2.contours[CUR.zp2.n_contours - 1] + 1 );
d5632 2
a5633 2
      if ( zp.cur != CUR.zp2.cur || refp != i )
        MOVE_Zp2_Point( i, dx, dy, FALSE );
d5645 2
a5646 1
  Ins_SHPIX( INS_ARG )
d5655 1
a5655 1
    if ( CUR.top < CUR.GS.loop + 1 )
d5657 2
a5658 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5663 1
a5663 1
    if ( CUR.face->unpatented_hinting )
d5665 1
a5665 1
      if ( CUR.GS.both_x_axis )
d5679 2
a5680 2
      dx = TT_MulFix14( (FT_UInt32)args[0], CUR.GS.freeVector.x );
      dy = TT_MulFix14( (FT_UInt32)args[0], CUR.GS.freeVector.y );
d5683 1
a5683 1
    while ( CUR.GS.loop > 0 )
d5685 1
a5685 1
      CUR.args--;
d5687 1
a5687 1
      point = (FT_UShort)CUR.stack[CUR.args];
d5689 1
a5689 1
      if ( BOUNDS( point, CUR.zp2.n_points ) )
d5691 1
a5691 1
        if ( CUR.pedantic_hinting )
d5693 1
a5693 1
          CUR.error = FT_THROW( Invalid_Reference );
d5700 7
a5706 7
        /*  If not using ignore_x_mode rendering, allow ZP2 move.          */
        /*  If inline deltas aren't allowed, skip ZP2 move.                */
        /*  If using ignore_x_mode rendering, allow ZP2 point move if:     */
        /*   - freedom vector is y and sph_compatibility_mode is off       */
        /*   - the glyph is composite and the move is in the Y direction   */
        /*   - the glyph is specifically set to allow SHPIX moves          */
        /*   - the move is on a previously Y-touched point                 */
d5708 2
a5709 2
        if ( SUBPIXEL_HINTING  &&
             CUR.ignore_x_mode )
d5712 2
a5713 2
          if ( CUR.GS.freeVector.y != 0 )
            B1 = CUR.zp2.cur[point].y;
d5715 1
a5715 1
            B1 = CUR.zp2.cur[point].x;
d5717 2
a5718 2
          if ( !CUR.face->sph_compatibility_mode &&
               CUR.GS.freeVector.y != 0          )
d5720 1
a5720 1
            MOVE_Zp2_Point( point, dx, dy, TRUE );
d5723 1
a5723 1
            if ( CUR.GS.freeVector.y != 0 )
d5725 1
a5725 1
              B2 = CUR.zp2.cur[point].y;
d5728 5
a5732 5
              if ( ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&
                   ( B1 & 63 ) != 0                                          &&
                   ( B2 & 63 ) != 0                                          &&
                    B1 != B2                                                 )
                MOVE_Zp2_Point( point, -dx, -dy, TRUE );
d5735 1
a5735 1
          else if ( CUR.face->sph_compatibility_mode )
d5737 1
a5737 1
            if ( CUR.sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES )
d5744 3
a5746 3
            if ( CUR.iup_called                                          &&
                 ( ( CUR.sph_in_func_flags & SPH_FDEF_INLINE_DELTA_1 ) ||
                   ( CUR.sph_in_func_flags & SPH_FDEF_INLINE_DELTA_2 ) ) )
d5749 5
a5753 5
            if ( !( CUR.sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP ) &&
                  ( ( CUR.is_composite && CUR.GS.freeVector.y != 0 ) ||
                    ( CUR.zp2.tags[point] & FT_CURVE_TAG_TOUCH_Y )   ||
                    ( CUR.sph_tweak_flags & SPH_TWEAK_DO_SHPIX )     )   )
              MOVE_Zp2_Point( point, 0, dy, TRUE );
d5756 1
a5756 1
            if ( CUR.GS.freeVector.y != 0 )
d5758 1
a5758 1
              B2 = CUR.zp2.cur[point].y;
d5764 1
a5764 1
                MOVE_Zp2_Point( point, 0, -dy, TRUE );
d5767 2
a5768 2
          else if ( CUR.sph_in_func_flags & SPH_FDEF_TYPEMAN_DIAGENDCTRL )
            MOVE_Zp2_Point( point, dx, dy, TRUE );
d5771 1
a5771 1
          MOVE_Zp2_Point( point, dx, dy, TRUE );
d5778 1
a5778 1
        MOVE_Zp2_Point( point, dx, dy, TRUE );
d5782 1
a5782 1
      CUR.GS.loop--;
d5786 2
a5787 2
    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
d5798 2
a5799 1
  Ins_MSIRP( INS_ARG )
d5810 1
a5810 1
      control_value_cutin = CUR.GS.control_value_cutin;
d5812 3
a5814 3
      if ( CUR.ignore_x_mode                                 &&
           CUR.GS.freeVector.x != 0                          &&
           !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
d5822 2
a5823 2
    if ( BOUNDS( point,      CUR.zp1.n_points ) ||
         BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
d5825 2
a5826 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5832 1
a5832 1
    if ( CUR.GS.gep1 == 0 )
d5834 3
a5836 3
      CUR.zp1.org[point] = CUR.zp0.org[CUR.GS.rp0];
      CUR_Func_move_orig( &CUR.zp1, point, args[1] );
      CUR.zp1.cur[point] = CUR.zp1.org[point];
d5839 1
a5839 2
    distance = CUR_Func_project( CUR.zp1.cur + point,
                                 CUR.zp0.cur + CUR.GS.rp0 );
d5844 2
a5845 2
         CUR.ignore_x_mode                                   &&
         CUR.GS.freeVector.x != 0                            &&
d5850 1
a5850 1
    CUR_Func_move( &CUR.zp1, point, args[1] - distance );
d5852 2
a5853 2
    CUR.GS.rp1 = CUR.GS.rp0;
    CUR.GS.rp2 = point;
d5855 2
a5856 2
    if ( ( CUR.opcode & 1 ) != 0 )
      CUR.GS.rp0 = point;
d5867 2
a5868 1
  Ins_MDAP( INS_ARG )
d5877 1
a5877 1
    if ( BOUNDS( point, CUR.zp0.n_points ) )
d5879 2
a5880 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5884 1
a5884 1
    if ( ( CUR.opcode & 1 ) != 0 )
d5886 1
a5886 1
      cur_dist = CUR_fast_project( &CUR.zp0.cur[point] );
d5888 5
a5892 4
      if ( SUBPIXEL_HINTING         &&
           CUR.ignore_x_mode        &&
           CUR.GS.freeVector.x != 0 )
        distance = ROUND_None(
d5894 1
a5894 1
                     CUR.tt_metrics.compensations[0] ) - cur_dist;
d5897 2
a5898 1
        distance = CUR_Func_round(
d5900 1
a5900 1
                     CUR.tt_metrics.compensations[0] ) - cur_dist;
d5905 1
a5905 1
    CUR_Func_move( &CUR.zp0, point, distance );
d5907 2
a5908 2
    CUR.GS.rp0 = point;
    CUR.GS.rp1 = point;
d5919 2
a5920 1
  Ins_MIAP( INS_ARG )
d5929 1
a5929 1
    control_value_cutin = CUR.GS.control_value_cutin;
d5934 5
a5938 5
    if ( SUBPIXEL_HINTING                                  &&
         CUR.ignore_x_mode                                 &&
         CUR.GS.freeVector.x != 0                          &&
         CUR.GS.freeVector.y == 0                          &&
         !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
d5942 2
a5943 2
    if ( BOUNDS( point,     CUR.zp0.n_points ) ||
         BOUNDSL( cvtEntry, CUR.cvtSize )      )
d5945 2
a5946 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d5970 1
a5970 1
    distance = CUR_Func_read_cvt( cvtEntry );
d5972 1
a5972 1
    if ( CUR.GS.gep0 == 0 )   /* If in twilight zone */
d5977 3
a5979 3
      if ( !SUBPIXEL_HINTING                     ||
           ( !CUR.ignore_x_mode                ||
             !CUR.face->sph_compatibility_mode ) )
d5981 5
a5985 5
        CUR.zp0.org[point].x = TT_MulFix14( (FT_UInt32)distance,
                                            CUR.GS.freeVector.x );
      CUR.zp0.org[point].y = TT_MulFix14( (FT_UInt32)distance,
                                          CUR.GS.freeVector.y ),
      CUR.zp0.cur[point]   = CUR.zp0.org[point];
d5988 5
a5992 5
    if ( SUBPIXEL_HINTING                              &&
         CUR.ignore_x_mode                             &&
         ( CUR.sph_tweak_flags & SPH_TWEAK_MIAP_HACK ) &&
         distance > 0                                  &&
         CUR.GS.freeVector.y != 0                      )
d5996 1
a5996 1
    org_dist = CUR_fast_project( &CUR.zp0.cur[point] );
d5998 1
a5998 1
    if ( ( CUR.opcode & 1 ) != 0 )   /* rounding and control cut-in flag */
d6004 6
a6009 5
      if ( SUBPIXEL_HINTING         &&
           CUR.ignore_x_mode        &&
           CUR.GS.freeVector.x != 0 )
        distance = ROUND_None( distance,
                               CUR.tt_metrics.compensations[0] );
d6012 3
a6014 2
        distance = CUR_Func_round( distance,
                                   CUR.tt_metrics.compensations[0] );
d6017 1
a6017 1
    CUR_Func_move( &CUR.zp0, point, distance - org_dist );
d6020 2
a6021 2
    CUR.GS.rp0 = point;
    CUR.GS.rp1 = point;
d6032 2
a6033 1
  Ins_MDRP( INS_ARG )
d6039 1
a6039 1
    minimum_distance = CUR.GS.minimum_distance;
d6042 4
a6045 4
    if ( SUBPIXEL_HINTING                                  &&
         CUR.ignore_x_mode                                 &&
         CUR.GS.freeVector.x != 0                          &&
         !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
d6051 2
a6052 2
    if ( BOUNDS( point,      CUR.zp1.n_points ) ||
         BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
d6054 2
a6055 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d6064 1
a6064 1
    if ( CUR.GS.gep0 == 0 || CUR.GS.gep1 == 0 )
d6066 2
a6067 2
      FT_Vector*  vec1 = &CUR.zp1.org[point];
      FT_Vector*  vec2 = &CUR.zp0.org[CUR.GS.rp0];
d6070 1
a6070 1
      org_dist = CUR_Func_dualproj( vec1, vec2 );
d6074 2
a6075 2
      FT_Vector*  vec1 = &CUR.zp1.orus[point];
      FT_Vector*  vec2 = &CUR.zp0.orus[CUR.GS.rp0];
d6078 1
a6078 1
      if ( CUR.metrics.x_scale == CUR.metrics.y_scale )
d6081 2
a6082 2
        org_dist = CUR_Func_dualproj( vec1, vec2 );
        org_dist = FT_MulFix( org_dist, CUR.metrics.x_scale );
d6089 2
a6090 2
        vec.x = FT_MulFix( vec1->x - vec2->x, CUR.metrics.x_scale );
        vec.y = FT_MulFix( vec1->y - vec2->y, CUR.metrics.y_scale );
d6092 1
a6092 1
        org_dist = CUR_fast_dualproj( &vec );
d6098 2
a6099 2
    if ( FT_ABS( org_dist - CUR.GS.single_width_value ) <
         CUR.GS.single_width_cutin )
d6102 1
a6102 1
        org_dist = CUR.GS.single_width_value;
d6104 1
a6104 1
        org_dist = -CUR.GS.single_width_value;
d6109 1
a6109 1
    if ( ( CUR.opcode & 4 ) != 0 )
d6112 5
a6116 4
      if ( SUBPIXEL_HINTING         &&
           CUR.ignore_x_mode        &&
           CUR.GS.freeVector.x != 0 )
        distance = ROUND_None(
d6118 1
a6118 1
                     CUR.tt_metrics.compensations[CUR.opcode & 3] );
d6121 4
a6124 3
      distance = CUR_Func_round(
                   org_dist,
                   CUR.tt_metrics.compensations[CUR.opcode & 3] );
d6127 2
a6128 1
      distance = ROUND_None(
d6130 1
a6130 1
                   CUR.tt_metrics.compensations[CUR.opcode & 3] );
d6134 1
a6134 1
    if ( ( CUR.opcode & 8 ) != 0 )
d6150 1
a6150 2
    org_dist = CUR_Func_project( CUR.zp1.cur + point,
                                 CUR.zp0.cur + CUR.GS.rp0 );
d6152 1
a6152 1
    CUR_Func_move( &CUR.zp1, point, distance - org_dist );
d6155 2
a6156 2
    CUR.GS.rp1 = CUR.GS.rp0;
    CUR.GS.rp2 = point;
d6158 2
a6159 2
    if ( ( CUR.opcode & 16 ) != 0 )
      CUR.GS.rp0 = point;
d6170 2
a6171 1
  Ins_MIRP( INS_ARG )
d6189 2
a6190 2
    minimum_distance    = CUR.GS.minimum_distance;
    control_value_cutin = CUR.GS.control_value_cutin;
d6195 4
a6198 4
    if ( SUBPIXEL_HINTING                                  &&
         CUR.ignore_x_mode                                 &&
         CUR.GS.freeVector.x != 0                          &&
         !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
d6204 3
a6206 3
    if ( BOUNDS( point,      CUR.zp1.n_points ) ||
         BOUNDSL( cvtEntry,  CUR.cvtSize + 1 )  ||
         BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
d6208 2
a6209 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d6216 1
a6216 1
      cvt_dist = CUR_Func_read_cvt( cvtEntry - 1 );
d6220 2
a6221 2
    if ( FT_ABS( cvt_dist - CUR.GS.single_width_value ) <
         CUR.GS.single_width_cutin )
d6224 1
a6224 1
        cvt_dist =  CUR.GS.single_width_value;
d6226 1
a6226 1
        cvt_dist = -CUR.GS.single_width_value;
d6231 1
a6231 1
    if ( CUR.GS.gep1 == 0 )
d6233 7
a6239 7
      CUR.zp1.org[point].x = CUR.zp0.org[CUR.GS.rp0].x +
                             TT_MulFix14( (FT_UInt32)cvt_dist,
                                          CUR.GS.freeVector.x );
      CUR.zp1.org[point].y = CUR.zp0.org[CUR.GS.rp0].y +
                             TT_MulFix14( (FT_UInt32)cvt_dist,
                                          CUR.GS.freeVector.y );
      CUR.zp1.cur[point]   = CUR.zp1.org[point];
d6242 2
a6243 4
    org_dist = CUR_Func_dualproj( &CUR.zp1.org[point],
                                  &CUR.zp0.org[CUR.GS.rp0] );
    cur_dist = CUR_Func_project ( &CUR.zp1.cur[point],
                                  &CUR.zp0.cur[CUR.GS.rp0] );
d6247 1
a6247 1
    if ( CUR.GS.auto_flip )
d6254 4
a6257 4
    if ( SUBPIXEL_HINTING                                         &&
         CUR.ignore_x_mode                                        &&
         CUR.GS.freeVector.y != 0                                 &&
         ( CUR.sph_tweak_flags & SPH_TWEAK_TIMES_NEW_ROMAN_HACK ) )
d6268 1
a6268 1
    if ( ( CUR.opcode & 4 ) != 0 )
d6273 1
a6273 1
      if ( CUR.GS.gep0 == CUR.GS.gep1 )
d6291 2
a6292 1
      distance = CUR_Func_round(
d6294 1
a6294 1
                   CUR.tt_metrics.compensations[CUR.opcode & 3] );
d6301 3
a6303 3
      if ( SUBPIXEL_HINTING           &&
           CUR.ignore_x_mode          &&
           CUR.GS.gep0 == CUR.GS.gep1 )
d6310 2
a6311 1
      distance = ROUND_None(
d6313 1
a6313 1
                   CUR.tt_metrics.compensations[CUR.opcode & 3] );
d6318 1
a6318 1
    if ( ( CUR.opcode & 8 ) != 0 )
d6335 1
a6335 1
      B1 = CUR.zp1.cur[point].y;
d6338 3
a6340 3
      if ( CUR.ignore_x_mode                                          &&
           CUR.GS.freeVector.y != 0                                   &&
           ( CUR.sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES ) )
d6343 5
a6347 5
      if ( CUR.ignore_x_mode                                      &&
           CUR.GS.freeVector.y != 0                               &&
           ( CUR.opcode & 16 ) == 0                               &&
           ( CUR.opcode & 8 ) == 0                                &&
           ( CUR.sph_tweak_flags & SPH_TWEAK_COURIER_NEW_2_HACK ) )
d6352 1
a6352 1
    CUR_Func_move( &CUR.zp1, point, distance - cur_dist );
d6357 1
a6357 1
      B2 = CUR.zp1.cur[point].y;
d6360 1
a6360 1
      if ( CUR.ignore_x_mode )
d6362 4
a6365 4
        if ( CUR.face->sph_compatibility_mode                          &&
             CUR.GS.freeVector.y != 0                                  &&
             ( B1 & 63 ) == 0                                          &&
             ( B2 & 63 ) != 0                                          )
d6368 4
a6371 4
        if ( ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&
             CUR.GS.freeVector.y != 0                                  &&
             ( B2 & 63 ) != 0                                          &&
             ( B1 & 63 ) != 0                                          )
d6376 1
a6376 1
        CUR_Func_move( &CUR.zp1, point, -( distance - cur_dist ) );
d6382 1
a6382 1
    CUR.GS.rp1 = CUR.GS.rp0;
d6384 2
a6385 2
    if ( ( CUR.opcode & 16 ) != 0 )
      CUR.GS.rp0 = point;
d6387 1
a6387 1
    CUR.GS.rp2 = point;
d6398 1
a6398 1
  Ins_ALIGNRP( INS_ARG )
a6402 2
    FT_UNUSED_ARG;

d6405 4
a6408 4
    if ( SUBPIXEL_HINTING                                         &&
         CUR.ignore_x_mode                                        &&
         CUR.iup_called                                           &&
         ( CUR.sph_tweak_flags & SPH_TWEAK_NO_ALIGNRP_AFTER_IUP ) )
d6410 1
a6410 1
      CUR.error = FT_THROW( Invalid_Reference );
d6415 2
a6416 2
    if ( CUR.top < CUR.GS.loop ||
         BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
d6418 2
a6419 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d6423 1
a6423 1
    while ( CUR.GS.loop > 0 )
d6425 1
a6425 1
      CUR.args--;
d6427 1
a6427 1
      point = (FT_UShort)CUR.stack[CUR.args];
d6429 1
a6429 1
      if ( BOUNDS( point, CUR.zp1.n_points ) )
d6431 1
a6431 1
        if ( CUR.pedantic_hinting )
d6433 1
a6433 1
          CUR.error = FT_THROW( Invalid_Reference );
d6439 2
a6440 2
        distance = CUR_Func_project( CUR.zp1.cur + point,
                                     CUR.zp0.cur + CUR.GS.rp0 );
d6442 1
a6442 1
        CUR_Func_move( &CUR.zp1, point, -distance );
d6445 1
a6445 1
      CUR.GS.loop--;
d6449 2
a6450 2
    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
d6461 2
a6462 1
  Ins_ISECT( INS_ARG )
d6486 5
a6490 5
    if ( BOUNDS( b0, CUR.zp0.n_points )  ||
         BOUNDS( b1, CUR.zp0.n_points )  ||
         BOUNDS( a0, CUR.zp1.n_points )  ||
         BOUNDS( a1, CUR.zp1.n_points )  ||
         BOUNDS( point, CUR.zp2.n_points ) )
d6492 2
a6493 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d6499 2
a6500 2
    dbx = CUR.zp0.cur[b1].x - CUR.zp0.cur[b0].x;
    dby = CUR.zp0.cur[b1].y - CUR.zp0.cur[b0].y;
d6502 2
a6503 2
    dax = CUR.zp1.cur[a1].x - CUR.zp1.cur[a0].x;
    day = CUR.zp1.cur[a1].y - CUR.zp1.cur[a0].y;
d6505 2
a6506 2
    dx = CUR.zp0.cur[b0].x - CUR.zp1.cur[a0].x;
    dy = CUR.zp0.cur[b0].y - CUR.zp1.cur[a0].y;
d6508 1
a6508 1
    CUR.zp2.tags[point] |= FT_CURVE_TAG_TOUCH_BOTH;
d6530 2
a6531 2
      CUR.zp2.cur[point].x = CUR.zp1.cur[a0].x + R.x;
      CUR.zp2.cur[point].y = CUR.zp1.cur[a0].y + R.y;
d6537 8
a6544 8
      CUR.zp2.cur[point].x = ( CUR.zp1.cur[a0].x +
                               CUR.zp1.cur[a1].x +
                               CUR.zp0.cur[b0].x +
                               CUR.zp0.cur[b1].x ) / 4;
      CUR.zp2.cur[point].y = ( CUR.zp1.cur[a0].y +
                               CUR.zp1.cur[a1].y +
                               CUR.zp0.cur[b0].y +
                               CUR.zp0.cur[b1].y ) / 4;
d6556 2
a6557 1
  Ins_ALIGNPTS( INS_ARG )
d6566 2
a6567 2
    if ( BOUNDS( p1, CUR.zp1.n_points ) ||
         BOUNDS( p2, CUR.zp0.n_points ) )
d6569 2
a6570 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d6574 1
a6574 2
    distance = CUR_Func_project( CUR.zp0.cur + p2,
                                 CUR.zp1.cur + p1 ) / 2;
d6576 2
a6577 2
    CUR_Func_move( &CUR.zp1, p1, distance );
    CUR_Func_move( &CUR.zp0, p2, -distance );
d6591 1
a6591 1
  Ins_IP( INS_ARG )
a6597 2
    FT_UNUSED_ARG;

d6599 1
a6599 1
    if ( CUR.top < CUR.GS.loop )
d6601 2
a6602 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d6608 1
a6608 1
     * Otherwise, by definition, the value of CUR.twilight.orus[n] is (0,0),
d6611 1
a6611 1
    twilight = CUR.GS.gep0 == 0 || CUR.GS.gep1 == 0 || CUR.GS.gep2 == 0;
d6613 1
a6613 1
    if ( BOUNDS( CUR.GS.rp1, CUR.zp0.n_points ) )
d6615 2
a6616 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d6621 1
a6621 1
      orus_base = &CUR.zp0.org[CUR.GS.rp1];
d6623 1
a6623 1
      orus_base = &CUR.zp0.orus[CUR.GS.rp1];
d6625 1
a6625 1
    cur_base = &CUR.zp0.cur[CUR.GS.rp1];
d6631 2
a6632 2
    if ( BOUNDS( CUR.GS.rp1, CUR.zp0.n_points ) ||
         BOUNDS( CUR.GS.rp2, CUR.zp1.n_points ) )
d6640 3
a6642 5
        old_range = CUR_Func_dualproj( &CUR.zp1.org[CUR.GS.rp2],
                                       orus_base );
      else if ( CUR.metrics.x_scale == CUR.metrics.y_scale )
        old_range = CUR_Func_dualproj( &CUR.zp1.orus[CUR.GS.rp2],
                                       orus_base );
d6648 4
a6651 4
        vec.x = FT_MulFix( CUR.zp1.orus[CUR.GS.rp2].x - orus_base->x,
                           CUR.metrics.x_scale );
        vec.y = FT_MulFix( CUR.zp1.orus[CUR.GS.rp2].y - orus_base->y,
                           CUR.metrics.y_scale );
d6653 1
a6653 1
        old_range = CUR_fast_dualproj( &vec );
d6656 1
a6656 1
      cur_range = CUR_Func_project ( &CUR.zp1.cur[CUR.GS.rp2], cur_base );
d6659 1
a6659 1
    for ( ; CUR.GS.loop > 0; --CUR.GS.loop )
d6661 1
a6661 1
      FT_UInt     point = (FT_UInt)CUR.stack[--CUR.args];
d6666 1
a6666 1
      if ( BOUNDS( point, CUR.zp2.n_points ) )
d6668 1
a6668 1
        if ( CUR.pedantic_hinting )
d6670 1
a6670 1
          CUR.error = FT_THROW( Invalid_Reference );
d6677 3
a6679 3
        org_dist = CUR_Func_dualproj( &CUR.zp2.org[point], orus_base );
      else if ( CUR.metrics.x_scale == CUR.metrics.y_scale )
        org_dist = CUR_Func_dualproj( &CUR.zp2.orus[point], orus_base );
d6685 4
a6688 4
        vec.x = FT_MulFix( CUR.zp2.orus[point].x - orus_base->x,
                           CUR.metrics.x_scale );
        vec.y = FT_MulFix( CUR.zp2.orus[point].y - orus_base->y,
                           CUR.metrics.y_scale );
d6690 1
a6690 1
        org_dist = CUR_fast_dualproj( &vec );
d6693 1
a6693 1
      cur_dist = CUR_Func_project( &CUR.zp2.cur[point], cur_base );
d6723 4
a6726 1
      CUR_Func_move( &CUR.zp2, (FT_UShort)point, new_dist - cur_dist );
d6730 2
a6731 2
    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
d6742 2
a6743 1
  Ins_UTP( INS_ARG )
d6751 1
a6751 1
    if ( BOUNDS( point, CUR.zp0.n_points ) )
d6753 2
a6754 2
      if ( CUR.pedantic_hinting )
        CUR.error = FT_THROW( Invalid_Reference );
d6760 1
a6760 1
    if ( CUR.GS.freeVector.x != 0 )
d6763 1
a6763 1
    if ( CUR.GS.freeVector.y != 0 )
d6766 1
a6766 1
    CUR.zp0.tags[point] &= mask;
d6811 1
a6811 1
    FT_F26Dot6  orus1, orus2, org1, org2, delta1, delta2;
d6841 4
a6844 2
    delta1 = worker->curs[ref1].x - org1;
    delta2 = worker->curs[ref2].x - org2;
d6846 1
a6846 1
    if ( orus1 == orus2 )
d6848 2
a6849 1
      /* simple shift of untouched points */
d6857 4
d6862 1
a6862 1
          x += delta2;
d6890 1
a6890 2
            scale       = FT_DivFix( org2 + delta2 - ( org1 + delta1 ),
                                     orus2 - orus1 );
d6893 1
a6893 2
          x = ( org1 + delta1 ) +
              FT_MulFix( worker->orus[i].x - orus1, scale );
d6908 1
a6908 1
  Ins_IUP( INS_ARG )
a6921 2
    FT_UNUSED_ARG;

d6924 1
a6924 1
    if ( CUR.pts.n_contours == 0 )
d6927 1
a6927 1
    if ( CUR.opcode & 1 )
d6930 3
a6932 3
      V.orgs = CUR.pts.org;
      V.curs = CUR.pts.cur;
      V.orus = CUR.pts.orus;
d6937 3
a6939 3
      V.orgs = (FT_Vector*)( (FT_Pos*)CUR.pts.org + 1 );
      V.curs = (FT_Vector*)( (FT_Pos*)CUR.pts.cur + 1 );
      V.orus = (FT_Vector*)( (FT_Pos*)CUR.pts.orus + 1 );
d6941 1
a6941 1
    V.max_points = CUR.pts.n_points;
d6947 2
a6948 2
    if ( SUBPIXEL_HINTING  &&
         CUR.ignore_x_mode )
d6950 2
a6951 2
      CUR.iup_called = TRUE;
      if ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_IUP )
d6958 1
a6958 1
      end_point   = CUR.pts.contours[contour] - CUR.pts.first_point;
d6961 2
a6962 2
      if ( BOUNDS ( end_point, CUR.pts.n_points ) )
        end_point = CUR.pts.n_points - 1;
d6964 1
a6964 1
      while ( point <= end_point && ( CUR.pts.tags[point] & mask ) == 0 )
d6976 1
a6976 1
          if ( ( CUR.pts.tags[point] & mask ) != 0 )
d7008 1
a7008 1
    } while ( contour < CUR.pts.n_contours );
d7019 2
a7020 1
  Ins_DELTAP( INS_ARG )
d7030 4
a7033 4
    if ( SUBPIXEL_HINTING                                        &&
         CUR.ignore_x_mode                                       &&
         CUR.iup_called                                          &&
         ( CUR.sph_tweak_flags & SPH_TWEAK_NO_DELTAP_AFTER_IUP ) )
d7040 1
a7040 1
    if ( CUR.face->unpatented_hinting )
d7045 1
a7045 1
      if ( CUR.args < n )
d7047 3
a7049 3
        if ( CUR.pedantic_hinting )
          CUR.error = FT_THROW( Too_Few_Arguments );
        n = CUR.args;
d7052 2
a7053 2
      CUR.args -= n;
      CUR.new_top = CUR.args;
d7058 1
a7058 1
    P = (FT_ULong)CUR_Func_cur_ppem();
d7064 1
a7064 1
      if ( CUR.args < 2 )
d7066 3
a7068 3
        if ( CUR.pedantic_hinting )
          CUR.error = FT_THROW( Too_Few_Arguments );
        CUR.args = 0;
d7072 1
a7072 1
      CUR.args -= 2;
d7074 2
a7075 2
      A = (FT_UShort)CUR.stack[CUR.args + 1];
      B = CUR.stack[CUR.args];
d7083 1
a7083 1
      if ( !BOUNDS( A, CUR.zp0.n_points ) )
d7087 1
a7087 1
        switch ( CUR.opcode )
d7101 1
a7101 1
        C += CUR.GS.delta_base;
d7108 1
a7108 1
          B *= 1L << ( 6 - CUR.GS.delta_shift );
d7122 4
a7125 4
            if ( !CUR.ignore_x_mode                                   ||
                 ( CUR.sph_tweak_flags & SPH_TWEAK_ALWAYS_DO_DELTAP ) ||
                 ( CUR.is_composite && CUR.GS.freeVector.y != 0 )     )
              CUR_Func_move( &CUR.zp0, A, B );
d7129 1
a7129 1
            else if ( CUR.ignore_x_mode && CUR.GS.freeVector.y != 0 )
d7132 1
a7132 1
              B1 = (FT_UShort)CUR.zp0.cur[A].y;
d7136 3
a7138 3
              if ( !CUR.face->sph_compatibility_mode          &&
                   ( CUR.zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y ) )
                CUR_Func_move( &CUR.zp0, A, B );
d7141 2
a7142 2
              else if ( CUR.face->sph_compatibility_mode                      &&
                        !( CUR.sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP ) )
d7144 1
a7144 1
                if ( CUR.sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES )
d7149 3
a7151 3
                if ( !CUR.iup_called                            &&
                     ( CUR.zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y ) )
                  CUR_Func_move( &CUR.zp0, A, B );
d7154 1
a7154 1
              B2 = (FT_UShort)CUR.zp0.cur[A].y;
d7157 2
a7158 2
              if ( CUR.GS.freeVector.y != 0                           &&
                   ( ( CUR.face->sph_compatibility_mode           &&
d7161 1
a7161 1
                     ( ( CUR.sph_tweak_flags                    &
d7165 1
a7165 1
                CUR_Func_move( &CUR.zp0, A, -B );
d7171 1
a7171 1
            CUR_Func_move( &CUR.zp0, A, B );
d7175 2
a7176 2
        if ( CUR.pedantic_hinting )
          CUR.error = FT_THROW( Invalid_Reference );
d7180 1
a7180 1
    CUR.new_top = CUR.args;
d7191 2
a7192 1
  Ins_DELTAC( INS_ARG )
d7201 1
a7201 1
    if ( CUR.face->unpatented_hinting )
d7206 1
a7206 1
      if ( CUR.args < n )
d7208 3
a7210 3
        if ( CUR.pedantic_hinting )
          CUR.error = FT_THROW( Too_Few_Arguments );
        n = CUR.args;
d7213 2
a7214 2
      CUR.args -= n;
      CUR.new_top = CUR.args;
d7219 1
a7219 1
    P    = (FT_ULong)CUR_Func_cur_ppem();
d7224 1
a7224 1
      if ( CUR.args < 2 )
d7226 3
a7228 3
        if ( CUR.pedantic_hinting )
          CUR.error = FT_THROW( Too_Few_Arguments );
        CUR.args = 0;
d7232 1
a7232 1
      CUR.args -= 2;
d7234 2
a7235 2
      A = (FT_ULong)CUR.stack[CUR.args + 1];
      B = CUR.stack[CUR.args];
d7237 1
a7237 1
      if ( BOUNDSL( A, CUR.cvtSize ) )
d7239 1
a7239 1
        if ( CUR.pedantic_hinting )
d7241 1
a7241 1
          CUR.error = FT_THROW( Invalid_Reference );
d7249 1
a7249 1
        switch ( CUR.opcode )
d7263 1
a7263 1
        C += CUR.GS.delta_base;
d7270 1
a7270 1
          B *= 1L << ( 6 - CUR.GS.delta_shift );
d7272 1
a7272 1
          CUR_Func_move_cvt( A, B );
d7278 1
a7278 1
    CUR.new_top = CUR.args;
d7295 8
d7304 2
a7305 1
  Ins_GETINFO( INS_ARG )
d7318 14
a7331 7
    if ( SUBPIXEL_HINTING     &&
         ( args[0] & 1 ) != 0 &&
         CUR.ignore_x_mode    )
    {
      K = CUR.rasterizer_version;
      FT_TRACE7(( "Setting rasterizer version %d\n",
                  CUR.rasterizer_version ));
d7343 1
a7343 1
    if ( ( args[0] & 2 ) != 0 && CUR.tt_metrics.rotated )
d7351 1
a7351 1
    if ( ( args[0] & 4 ) != 0 && CUR.tt_metrics.stretched )
d7359 1
a7359 1
    if ( ( args[0] & 32 ) != 0 && CUR.grayscale )
d7364 2
a7365 3
    if ( SUBPIXEL_HINTING                                    &&
         CUR.ignore_x_mode                                   &&
         CUR.rasterizer_version >= TT_INTERPRETER_VERSION_35 )
d7368 1
a7368 1
      if ( CUR.rasterizer_version >= 37 )
d7375 1
a7375 1
        if ( ( args[0] & 64 ) != 0 && CUR.subpixel )
d7384 1
a7384 1
        if ( ( args[0] & 128 ) != 0 && CUR.compatible_widths )
d7388 1
a7388 1
        /* SYMMETRICAL SMOOTHING        */
d7393 1
a7393 1
        if ( ( args[0] & 256 ) != 0 && CUR.symmetrical_smoothing )
d7402 1
a7402 1
        if ( ( args[0] & 512 ) != 0 && CUR.bgr )
d7405 1
a7405 1
        if ( CUR.rasterizer_version >= 38 )
d7413 1
a7413 1
          if ( ( args[0] & 1024 ) != 0 && CUR.subpixel_positioned )
d7415 18
d7444 1
a7444 1
  Ins_UNKNOWN( INS_ARG )
d7446 2
a7447 4
    TT_DefRecord*  def   = CUR.IDefs;
    TT_DefRecord*  limit = def + CUR.numIDefs;

    FT_UNUSED_ARG;
d7452 1
a7452 1
      if ( (FT_Byte)def->opc == CUR.opcode && def->active )
d7457 1
a7457 1
        if ( CUR.callTop >= CUR.callSize )
d7459 1
a7459 1
          CUR.error = FT_THROW( Stack_Overflow );
d7463 1
a7463 1
        call = CUR.callStack + CUR.callTop++;
d7465 2
a7466 2
        call->Caller_Range = CUR.curRange;
        call->Caller_IP    = CUR.IP + 1;
d7470 1
a7470 1
        INS_Goto_CodeRange( def->range, def->start );
d7472 1
a7472 1
        CUR.step_ins = FALSE;
d7477 1
a7477 1
    CUR.error = FT_THROW( Invalid_Opcode );
a7480 286
#ifndef TT_CONFIG_OPTION_INTERPRETER_SWITCH


  static
  TInstruction_Function  Instruct_Dispatch[256] =
  {
    /* Opcodes are gathered in groups of 16. */
    /* Please keep the spaces as they are.   */

    /*  SVTCA  y  */  Ins_SVTCA,
    /*  SVTCA  x  */  Ins_SVTCA,
    /*  SPvTCA y  */  Ins_SPVTCA,
    /*  SPvTCA x  */  Ins_SPVTCA,
    /*  SFvTCA y  */  Ins_SFVTCA,
    /*  SFvTCA x  */  Ins_SFVTCA,
    /*  SPvTL //  */  Ins_SPVTL,
    /*  SPvTL +   */  Ins_SPVTL,
    /*  SFvTL //  */  Ins_SFVTL,
    /*  SFvTL +   */  Ins_SFVTL,
    /*  SPvFS     */  Ins_SPVFS,
    /*  SFvFS     */  Ins_SFVFS,
    /*  GPV       */  Ins_GPV,
    /*  GFV       */  Ins_GFV,
    /*  SFvTPv    */  Ins_SFVTPV,
    /*  ISECT     */  Ins_ISECT,

    /*  SRP0      */  Ins_SRP0,
    /*  SRP1      */  Ins_SRP1,
    /*  SRP2      */  Ins_SRP2,
    /*  SZP0      */  Ins_SZP0,
    /*  SZP1      */  Ins_SZP1,
    /*  SZP2      */  Ins_SZP2,
    /*  SZPS      */  Ins_SZPS,
    /*  SLOOP     */  Ins_SLOOP,
    /*  RTG       */  Ins_RTG,
    /*  RTHG      */  Ins_RTHG,
    /*  SMD       */  Ins_SMD,
    /*  ELSE      */  Ins_ELSE,
    /*  JMPR      */  Ins_JMPR,
    /*  SCvTCi    */  Ins_SCVTCI,
    /*  SSwCi     */  Ins_SSWCI,
    /*  SSW       */  Ins_SSW,

    /*  DUP       */  Ins_DUP,
    /*  POP       */  Ins_POP,
    /*  CLEAR     */  Ins_CLEAR,
    /*  SWAP      */  Ins_SWAP,
    /*  DEPTH     */  Ins_DEPTH,
    /*  CINDEX    */  Ins_CINDEX,
    /*  MINDEX    */  Ins_MINDEX,
    /*  AlignPTS  */  Ins_ALIGNPTS,
    /*  INS_0x28  */  Ins_UNKNOWN,
    /*  UTP       */  Ins_UTP,
    /*  LOOPCALL  */  Ins_LOOPCALL,
    /*  CALL      */  Ins_CALL,
    /*  FDEF      */  Ins_FDEF,
    /*  ENDF      */  Ins_ENDF,
    /*  MDAP[0]   */  Ins_MDAP,
    /*  MDAP[1]   */  Ins_MDAP,

    /*  IUP[0]    */  Ins_IUP,
    /*  IUP[1]    */  Ins_IUP,
    /*  SHP[0]    */  Ins_SHP,
    /*  SHP[1]    */  Ins_SHP,
    /*  SHC[0]    */  Ins_SHC,
    /*  SHC[1]    */  Ins_SHC,
    /*  SHZ[0]    */  Ins_SHZ,
    /*  SHZ[1]    */  Ins_SHZ,
    /*  SHPIX     */  Ins_SHPIX,
    /*  IP        */  Ins_IP,
    /*  MSIRP[0]  */  Ins_MSIRP,
    /*  MSIRP[1]  */  Ins_MSIRP,
    /*  AlignRP   */  Ins_ALIGNRP,
    /*  RTDG      */  Ins_RTDG,
    /*  MIAP[0]   */  Ins_MIAP,
    /*  MIAP[1]   */  Ins_MIAP,

    /*  NPushB    */  Ins_NPUSHB,
    /*  NPushW    */  Ins_NPUSHW,
    /*  WS        */  Ins_WS,
    /*  RS        */  Ins_RS,
    /*  WCvtP     */  Ins_WCVTP,
    /*  RCvt      */  Ins_RCVT,
    /*  GC[0]     */  Ins_GC,
    /*  GC[1]     */  Ins_GC,
    /*  SCFS      */  Ins_SCFS,
    /*  MD[0]     */  Ins_MD,
    /*  MD[1]     */  Ins_MD,
    /*  MPPEM     */  Ins_MPPEM,
    /*  MPS       */  Ins_MPS,
    /*  FlipON    */  Ins_FLIPON,
    /*  FlipOFF   */  Ins_FLIPOFF,
    /*  DEBUG     */  Ins_DEBUG,

    /*  LT        */  Ins_LT,
    /*  LTEQ      */  Ins_LTEQ,
    /*  GT        */  Ins_GT,
    /*  GTEQ      */  Ins_GTEQ,
    /*  EQ        */  Ins_EQ,
    /*  NEQ       */  Ins_NEQ,
    /*  ODD       */  Ins_ODD,
    /*  EVEN      */  Ins_EVEN,
    /*  IF        */  Ins_IF,
    /*  EIF       */  Ins_EIF,
    /*  AND       */  Ins_AND,
    /*  OR        */  Ins_OR,
    /*  NOT       */  Ins_NOT,
    /*  DeltaP1   */  Ins_DELTAP,
    /*  SDB       */  Ins_SDB,
    /*  SDS       */  Ins_SDS,

    /*  ADD       */  Ins_ADD,
    /*  SUB       */  Ins_SUB,
    /*  DIV       */  Ins_DIV,
    /*  MUL       */  Ins_MUL,
    /*  ABS       */  Ins_ABS,
    /*  NEG       */  Ins_NEG,
    /*  FLOOR     */  Ins_FLOOR,
    /*  CEILING   */  Ins_CEILING,
    /*  ROUND[0]  */  Ins_ROUND,
    /*  ROUND[1]  */  Ins_ROUND,
    /*  ROUND[2]  */  Ins_ROUND,
    /*  ROUND[3]  */  Ins_ROUND,
    /*  NROUND[0] */  Ins_NROUND,
    /*  NROUND[1] */  Ins_NROUND,
    /*  NROUND[2] */  Ins_NROUND,
    /*  NROUND[3] */  Ins_NROUND,

    /*  WCvtF     */  Ins_WCVTF,
    /*  DeltaP2   */  Ins_DELTAP,
    /*  DeltaP3   */  Ins_DELTAP,
    /*  DeltaCn[0] */ Ins_DELTAC,
    /*  DeltaCn[1] */ Ins_DELTAC,
    /*  DeltaCn[2] */ Ins_DELTAC,
    /*  SROUND    */  Ins_SROUND,
    /*  S45Round  */  Ins_S45ROUND,
    /*  JROT      */  Ins_JROT,
    /*  JROF      */  Ins_JROF,
    /*  ROFF      */  Ins_ROFF,
    /*  INS_0x7B  */  Ins_UNKNOWN,
    /*  RUTG      */  Ins_RUTG,
    /*  RDTG      */  Ins_RDTG,
    /*  SANGW     */  Ins_SANGW,
    /*  AA        */  Ins_AA,

    /*  FlipPT    */  Ins_FLIPPT,
    /*  FlipRgON  */  Ins_FLIPRGON,
    /*  FlipRgOFF */  Ins_FLIPRGOFF,
    /*  INS_0x83  */  Ins_UNKNOWN,
    /*  INS_0x84  */  Ins_UNKNOWN,
    /*  ScanCTRL  */  Ins_SCANCTRL,
    /*  SDPVTL[0] */  Ins_SDPVTL,
    /*  SDPVTL[1] */  Ins_SDPVTL,
    /*  GetINFO   */  Ins_GETINFO,
    /*  IDEF      */  Ins_IDEF,
    /*  ROLL      */  Ins_ROLL,
    /*  MAX       */  Ins_MAX,
    /*  MIN       */  Ins_MIN,
    /*  ScanTYPE  */  Ins_SCANTYPE,
    /*  InstCTRL  */  Ins_INSTCTRL,
    /*  INS_0x8F  */  Ins_UNKNOWN,

    /*  INS_0x90  */   Ins_UNKNOWN,
    /*  INS_0x91  */   Ins_UNKNOWN,
    /*  INS_0x92  */   Ins_UNKNOWN,
    /*  INS_0x93  */   Ins_UNKNOWN,
    /*  INS_0x94  */   Ins_UNKNOWN,
    /*  INS_0x95  */   Ins_UNKNOWN,
    /*  INS_0x96  */   Ins_UNKNOWN,
    /*  INS_0x97  */   Ins_UNKNOWN,
    /*  INS_0x98  */   Ins_UNKNOWN,
    /*  INS_0x99  */   Ins_UNKNOWN,
    /*  INS_0x9A  */   Ins_UNKNOWN,
    /*  INS_0x9B  */   Ins_UNKNOWN,
    /*  INS_0x9C  */   Ins_UNKNOWN,
    /*  INS_0x9D  */   Ins_UNKNOWN,
    /*  INS_0x9E  */   Ins_UNKNOWN,
    /*  INS_0x9F  */   Ins_UNKNOWN,

    /*  INS_0xA0  */   Ins_UNKNOWN,
    /*  INS_0xA1  */   Ins_UNKNOWN,
    /*  INS_0xA2  */   Ins_UNKNOWN,
    /*  INS_0xA3  */   Ins_UNKNOWN,
    /*  INS_0xA4  */   Ins_UNKNOWN,
    /*  INS_0xA5  */   Ins_UNKNOWN,
    /*  INS_0xA6  */   Ins_UNKNOWN,
    /*  INS_0xA7  */   Ins_UNKNOWN,
    /*  INS_0xA8  */   Ins_UNKNOWN,
    /*  INS_0xA9  */   Ins_UNKNOWN,
    /*  INS_0xAA  */   Ins_UNKNOWN,
    /*  INS_0xAB  */   Ins_UNKNOWN,
    /*  INS_0xAC  */   Ins_UNKNOWN,
    /*  INS_0xAD  */   Ins_UNKNOWN,
    /*  INS_0xAE  */   Ins_UNKNOWN,
    /*  INS_0xAF  */   Ins_UNKNOWN,

    /*  PushB[0]  */  Ins_PUSHB,
    /*  PushB[1]  */  Ins_PUSHB,
    /*  PushB[2]  */  Ins_PUSHB,
    /*  PushB[3]  */  Ins_PUSHB,
    /*  PushB[4]  */  Ins_PUSHB,
    /*  PushB[5]  */  Ins_PUSHB,
    /*  PushB[6]  */  Ins_PUSHB,
    /*  PushB[7]  */  Ins_PUSHB,
    /*  PushW[0]  */  Ins_PUSHW,
    /*  PushW[1]  */  Ins_PUSHW,
    /*  PushW[2]  */  Ins_PUSHW,
    /*  PushW[3]  */  Ins_PUSHW,
    /*  PushW[4]  */  Ins_PUSHW,
    /*  PushW[5]  */  Ins_PUSHW,
    /*  PushW[6]  */  Ins_PUSHW,
    /*  PushW[7]  */  Ins_PUSHW,

    /*  MDRP[00]  */  Ins_MDRP,
    /*  MDRP[01]  */  Ins_MDRP,
    /*  MDRP[02]  */  Ins_MDRP,
    /*  MDRP[03]  */  Ins_MDRP,
    /*  MDRP[04]  */  Ins_MDRP,
    /*  MDRP[05]  */  Ins_MDRP,
    /*  MDRP[06]  */  Ins_MDRP,
    /*  MDRP[07]  */  Ins_MDRP,
    /*  MDRP[08]  */  Ins_MDRP,
    /*  MDRP[09]  */  Ins_MDRP,
    /*  MDRP[10]  */  Ins_MDRP,
    /*  MDRP[11]  */  Ins_MDRP,
    /*  MDRP[12]  */  Ins_MDRP,
    /*  MDRP[13]  */  Ins_MDRP,
    /*  MDRP[14]  */  Ins_MDRP,
    /*  MDRP[15]  */  Ins_MDRP,

    /*  MDRP[16]  */  Ins_MDRP,
    /*  MDRP[17]  */  Ins_MDRP,
    /*  MDRP[18]  */  Ins_MDRP,
    /*  MDRP[19]  */  Ins_MDRP,
    /*  MDRP[20]  */  Ins_MDRP,
    /*  MDRP[21]  */  Ins_MDRP,
    /*  MDRP[22]  */  Ins_MDRP,
    /*  MDRP[23]  */  Ins_MDRP,
    /*  MDRP[24]  */  Ins_MDRP,
    /*  MDRP[25]  */  Ins_MDRP,
    /*  MDRP[26]  */  Ins_MDRP,
    /*  MDRP[27]  */  Ins_MDRP,
    /*  MDRP[28]  */  Ins_MDRP,
    /*  MDRP[29]  */  Ins_MDRP,
    /*  MDRP[30]  */  Ins_MDRP,
    /*  MDRP[31]  */  Ins_MDRP,

    /*  MIRP[00]  */  Ins_MIRP,
    /*  MIRP[01]  */  Ins_MIRP,
    /*  MIRP[02]  */  Ins_MIRP,
    /*  MIRP[03]  */  Ins_MIRP,
    /*  MIRP[04]  */  Ins_MIRP,
    /*  MIRP[05]  */  Ins_MIRP,
    /*  MIRP[06]  */  Ins_MIRP,
    /*  MIRP[07]  */  Ins_MIRP,
    /*  MIRP[08]  */  Ins_MIRP,
    /*  MIRP[09]  */  Ins_MIRP,
    /*  MIRP[10]  */  Ins_MIRP,
    /*  MIRP[11]  */  Ins_MIRP,
    /*  MIRP[12]  */  Ins_MIRP,
    /*  MIRP[13]  */  Ins_MIRP,
    /*  MIRP[14]  */  Ins_MIRP,
    /*  MIRP[15]  */  Ins_MIRP,

    /*  MIRP[16]  */  Ins_MIRP,
    /*  MIRP[17]  */  Ins_MIRP,
    /*  MIRP[18]  */  Ins_MIRP,
    /*  MIRP[19]  */  Ins_MIRP,
    /*  MIRP[20]  */  Ins_MIRP,
    /*  MIRP[21]  */  Ins_MIRP,
    /*  MIRP[22]  */  Ins_MIRP,
    /*  MIRP[23]  */  Ins_MIRP,
    /*  MIRP[24]  */  Ins_MIRP,
    /*  MIRP[25]  */  Ins_MIRP,
    /*  MIRP[26]  */  Ins_MIRP,
    /*  MIRP[27]  */  Ins_MIRP,
    /*  MIRP[28]  */  Ins_MIRP,
    /*  MIRP[29]  */  Ins_MIRP,
    /*  MIRP[30]  */  Ins_MIRP,
    /*  MIRP[31]  */  Ins_MIRP
  };


#endif /* !TT_CONFIG_OPTION_INTERPRETER_SWITCH */


a7507 2
  /*  Instructions appear in the specification's order.                    */
  /*                                                                       */
a7532 7
#ifdef TT_CONFIG_OPTION_STATIC_RASTER
    if ( !exc )
      return FT_THROW( Invalid_Argument );

    cur = *exc;
#endif

d7534 1
a7534 1
    CUR.iup_called = FALSE;
d7538 2
a7539 2
    CUR.tt_metrics.ratio = 0;
    if ( CUR.metrics.x_ppem != CUR.metrics.y_ppem )
d7542 4
a7545 4
      CUR.func_cur_ppem  = Current_Ppem_Stretched;
      CUR.func_read_cvt  = Read_CVT_Stretched;
      CUR.func_write_cvt = Write_CVT_Stretched;
      CUR.func_move_cvt  = Move_CVT_Stretched;
d7550 4
a7553 4
      CUR.func_cur_ppem  = Current_Ppem;
      CUR.func_read_cvt  = Read_CVT;
      CUR.func_write_cvt = Write_CVT;
      CUR.func_move_cvt  = Move_CVT;
d7556 2
a7557 2
    COMPUTE_Funcs();
    COMPUTE_Round( (FT_Byte)exc->GS.round_state );
d7561 1
a7561 1
      CUR.opcode = CUR.code[CUR.IP];
d7563 20
a7582 3
      FT_TRACE7(( "  " ));
      FT_TRACE7(( opcode_name[CUR.opcode] ));
      FT_TRACE7(( "\n" ));
d7584 1
a7584 1
      if ( ( CUR.length = opcode_length[CUR.opcode] ) < 0 )
d7586 1
a7586 1
        if ( CUR.IP + 1 >= CUR.codeSize )
d7589 1
a7589 1
        CUR.length = 2 - CUR.length * CUR.code[CUR.IP + 1];
d7592 1
a7592 1
      if ( CUR.IP + CUR.length > CUR.codeSize )
d7596 1
a7596 1
      CUR.args = CUR.top - ( Pop_Push_Count[CUR.opcode] >> 4 );
d7600 1
a7600 1
      if ( CUR.args < 0 )
d7602 1
a7602 1
        if ( CUR.pedantic_hinting )
d7604 1
a7604 1
          CUR.error = FT_THROW( Too_Few_Arguments );
d7609 3
a7611 3
        for ( i = 0; i < Pop_Push_Count[CUR.opcode] >> 4; i++ )
          CUR.stack[i] = 0;
        CUR.args = 0;
d7614 1
a7614 1
      CUR.new_top = CUR.args + ( Pop_Push_Count[CUR.opcode] & 15 );
d7619 1
a7619 1
      if ( CUR.new_top > CUR.stackSize )
d7621 1
a7621 1
        CUR.error = FT_THROW( Stack_Overflow );
d7625 2
a7626 2
      CUR.step_ins = TRUE;
      CUR.error    = FT_Err_Ok;
d7634 2
a7635 2
          if ( opcode_pointer[i] < opcode_size[i]                 &&
               CUR.opcode == opcode_pattern[i][opcode_pointer[i]] )
d7641 1
a7641 1
              FT_TRACE7(( "sph: opcode ptrn: %d, %s %s\n",
d7643 2
a7644 2
                          CUR.face->root.family_name,
                          CUR.face->root.style_name ));
a7660 2
#ifdef TT_CONFIG_OPTION_INTERPRETER_SWITCH

d7662 2
a7663 6
        FT_Long*  args   = CUR.stack + CUR.args;
        FT_Byte   opcode = CUR.opcode;


#undef  ARRAY_BOUND_ERROR
#define ARRAY_BOUND_ERROR  goto Set_Invalid_Ref
d7674 1
a7674 32
          {
            FT_Short  AA, BB;


            AA = (FT_Short)( ( opcode & 1 ) << 14 );
            BB = (FT_Short)( AA ^ 0x4000 );

            if ( opcode < 4 )
            {
              CUR.GS.projVector.x = AA;
              CUR.GS.projVector.y = BB;

              CUR.GS.dualVector.x = AA;
              CUR.GS.dualVector.y = BB;
            }
            else
            {
              GUESS_VECTOR( projVector );
            }

            if ( ( opcode & 2 ) == 0 )
            {
              CUR.GS.freeVector.x = AA;
              CUR.GS.freeVector.y = BB;
            }
            else
            {
              GUESS_VECTOR( freeVector );
            }

            COMPUTE_Funcs();
          }
d7679 1
a7679 1
          DO_SPVTL
d7684 1
a7684 1
          DO_SFVTL
d7688 1
a7688 1
          DO_SPVFS
d7692 1
a7692 1
          DO_SFVFS
d7695 2
a7696 2
        case 0x0C:  /* GPV */
          DO_GPV
d7699 2
a7700 2
        case 0x0D:  /* GFV */
          DO_GFV
d7704 1
a7704 1
          DO_SFVTPV
d7708 1
a7708 1
          Ins_ISECT( EXEC_ARG_ args );
d7712 1
a7712 1
          DO_SRP0
d7716 1
a7716 1
          DO_SRP1
d7720 1
a7720 1
          DO_SRP2
d7724 1
a7724 1
          Ins_SZP0( EXEC_ARG_ args );
d7728 1
a7728 1
          Ins_SZP1( EXEC_ARG_ args );
d7732 1
a7732 1
          Ins_SZP2( EXEC_ARG_ args );
d7736 1
a7736 1
          Ins_SZPS( EXEC_ARG_ args );
d7740 1
a7740 1
          DO_SLOOP
d7744 1
a7744 1
          DO_RTG
d7748 1
a7748 1
          DO_RTHG
d7752 1
a7752 1
          DO_SMD
d7756 1
a7756 1
          Ins_ELSE( EXEC_ARG_ args );
d7760 1
a7760 1
          DO_JMPR
d7764 1
a7764 1
          DO_SCVTCI
d7768 1
a7768 1
          DO_SSWCI
d7772 1
a7772 1
          DO_SSW
d7776 1
a7776 1
          DO_DUP
d7780 1
a7780 1
          /* nothing :-) */
d7784 1
a7784 1
          DO_CLEAR
d7788 1
a7788 1
          DO_SWAP
d7792 1
a7792 1
          DO_DEPTH
d7796 1
a7796 1
          DO_CINDEX
d7800 1
a7800 1
          Ins_MINDEX( EXEC_ARG_ args );
d7804 1
a7804 1
          Ins_ALIGNPTS( EXEC_ARG_ args );
d7808 1
a7808 1
          Ins_UNKNOWN( EXEC_ARG_ args );
d7812 1
a7812 1
          Ins_UTP( EXEC_ARG_ args );
d7816 1
a7816 1
          Ins_LOOPCALL( EXEC_ARG_ args );
d7820 1
a7820 1
          Ins_CALL( EXEC_ARG_ args );
d7824 1
a7824 1
          Ins_FDEF( EXEC_ARG_ args );
d7828 1
a7828 1
          Ins_ENDF( EXEC_ARG_ args );
d7833 1
a7833 1
          Ins_MDAP( EXEC_ARG_ args );
d7838 1
a7838 1
          Ins_IUP( EXEC_ARG_ args );
d7843 1
a7843 1
          Ins_SHP( EXEC_ARG_ args );
d7848 1
a7848 1
          Ins_SHC( EXEC_ARG_ args );
d7853 1
a7853 1
          Ins_SHZ( EXEC_ARG_ args );
d7857 1
a7857 1
          Ins_SHPIX( EXEC_ARG_ args );
d7861 1
a7861 1
          Ins_IP( EXEC_ARG_ args );
d7866 1
a7866 1
          Ins_MSIRP( EXEC_ARG_ args );
d7870 1
a7870 1
          Ins_ALIGNRP( EXEC_ARG_ args );
d7874 1
a7874 1
          DO_RTDG
d7879 1
a7879 1
          Ins_MIAP( EXEC_ARG_ args );
d7883 1
a7883 1
          Ins_NPUSHB( EXEC_ARG_ args );
d7887 1
a7887 1
          Ins_NPUSHW( EXEC_ARG_ args );
d7891 1
a7891 5
          DO_WS
          break;

      Set_Invalid_Ref:
            CUR.error = FT_THROW( Invalid_Reference );
d7895 1
a7895 1
          DO_RS
d7899 1
a7899 1
          DO_WCVTP
d7903 1
a7903 1
          DO_RCVT
d7908 1
a7908 1
          Ins_GC( EXEC_ARG_ args );
d7912 1
a7912 1
          Ins_SCFS( EXEC_ARG_ args );
d7917 1
a7917 1
          Ins_MD( EXEC_ARG_ args );
d7921 1
a7921 1
          DO_MPPEM
d7925 1
a7925 1
          DO_MPS
d7929 1
a7929 1
          DO_FLIPON
d7933 1
a7933 1
          DO_FLIPOFF
d7937 1
a7937 1
          DO_DEBUG
d7941 1
a7941 1
          DO_LT
d7945 1
a7945 1
          DO_LTEQ
d7949 1
a7949 1
          DO_GT
d7953 1
a7953 1
          DO_GTEQ
d7957 1
a7957 1
          DO_EQ
d7961 1
a7961 1
          DO_NEQ
d7965 1
a7965 1
          DO_ODD
d7969 1
a7969 1
          DO_EVEN
d7973 1
a7973 1
          Ins_IF( EXEC_ARG_ args );
d7977 1
a7977 1
          /* do nothing */
d7981 1
a7981 1
          DO_AND
d7985 1
a7985 1
          DO_OR
d7989 1
a7989 1
          DO_NOT
d7993 1
a7993 1
          Ins_DELTAP( EXEC_ARG_ args );
d7997 1
a7997 1
          DO_SDB
d8001 1
a8001 1
          DO_SDS
d8005 1
a8005 1
          DO_ADD
d8009 1
a8009 1
          DO_SUB
d8013 1
a8013 1
          DO_DIV
d8017 1
a8017 1
          DO_MUL
d8021 1
a8021 1
          DO_ABS
d8025 1
a8025 1
          DO_NEG
d8029 1
a8029 1
          DO_FLOOR
d8033 1
a8033 1
          DO_CEILING
d8040 1
a8040 1
          DO_ROUND
d8047 1
a8047 1
          DO_NROUND
d8051 1
a8051 1
          DO_WCVTF
d8056 1
a8056 1
          Ins_DELTAP( EXEC_ARG_ args );
d8062 1
a8062 1
          Ins_DELTAC( EXEC_ARG_ args );
d8066 1
a8066 1
          DO_SROUND
d8070 1
a8070 1
          DO_S45ROUND
d8074 1
a8074 1
          DO_JROT
d8078 1
a8078 1
          DO_JROF
d8082 1
a8082 1
          DO_ROFF
d8086 1
a8086 1
          Ins_UNKNOWN( EXEC_ARG_ args );
d8090 1
a8090 1
          DO_RUTG
d8094 1
a8094 1
          DO_RDTG
d8098 5
a8102 2
        case 0x7F:  /* AA    */
          /* nothing - obsolete */
d8106 1
a8106 1
          Ins_FLIPPT( EXEC_ARG_ args );
d8110 1
a8110 1
          Ins_FLIPRGON( EXEC_ARG_ args );
d8114 1
a8114 1
          Ins_FLIPRGOFF( EXEC_ARG_ args );
d8119 1
a8119 1
          Ins_UNKNOWN( EXEC_ARG_ args );
d8123 1
a8123 1
          Ins_SCANCTRL( EXEC_ARG_ args );
d8126 3
a8128 3
        case 0x86:  /* SDPVTL */
        case 0x87:  /* SDPVTL */
          Ins_SDPVTL( EXEC_ARG_ args );
d8132 1
a8132 1
          Ins_GETINFO( EXEC_ARG_ args );
d8136 1
a8136 1
          Ins_IDEF( EXEC_ARG_ args );
d8140 1
a8140 1
          Ins_ROLL( EXEC_ARG_ args );
d8144 1
a8144 1
          DO_MAX
d8148 1
a8148 1
          DO_MIN
d8152 1
a8152 1
          Ins_SCANTYPE( EXEC_ARG_ args );
d8156 1
a8156 1
          Ins_INSTCTRL( EXEC_ARG_ args );
d8160 1
a8160 1
          Ins_UNKNOWN( EXEC_ARG_ args );
d8165 1
a8165 1
            Ins_MIRP( EXEC_ARG_ args );
d8167 1
a8167 1
            Ins_MDRP( EXEC_ARG_ args );
d8169 1
a8169 1
            Ins_PUSHW( EXEC_ARG_ args );
d8171 1
a8171 1
            Ins_PUSHB( EXEC_ARG_ args );
d8173 1
a8173 1
            Ins_UNKNOWN( EXEC_ARG_ args );
a8174 1

d8177 1
a8177 7
#else

      Instruct_Dispatch[CUR.opcode]( EXEC_ARG_ &CUR.stack[CUR.args] );

#endif /* TT_CONFIG_OPTION_INTERPRETER_SWITCH */

      if ( CUR.error )
d8179 1
a8179 1
        switch ( CUR.error )
d8184 2
a8185 2
            TT_DefRecord*  def   = CUR.IDefs;
            TT_DefRecord*  limit = def + CUR.numIDefs;
d8190 1
a8190 1
              if ( def->active && CUR.opcode == (FT_Byte)def->opc )
d8195 1
a8195 1
                if ( CUR.callTop >= CUR.callSize )
d8197 1
a8197 1
                  CUR.error = FT_THROW( Invalid_Reference );
d8201 1
a8201 1
                callrec = &CUR.callStack[CUR.callTop];
d8203 2
a8204 2
                callrec->Caller_Range = CUR.curRange;
                callrec->Caller_IP    = CUR.IP + 1;
d8208 3
a8210 1
                if ( INS_Goto_CodeRange( def->range, def->start ) == FAILURE )
d8218 1
a8218 1
          CUR.error = FT_THROW( Invalid_Opcode );
d8236 1
a8236 1
      CUR.top = CUR.new_top;
d8238 2
a8239 2
      if ( CUR.step_ins )
        CUR.IP += CUR.length;
d8247 1
a8247 1
      if ( CUR.IP >= CUR.codeSize )
d8249 1
a8249 1
        if ( CUR.callTop > 0 )
d8251 1
a8251 1
          CUR.error = FT_THROW( Code_Overflow );
d8257 1
a8257 1
    } while ( !CUR.instruction_trap );
a8259 5

#ifdef TT_CONFIG_OPTION_STATIC_RASTER
    *exc = cur;
#endif

d8263 1
a8263 1
    CUR.error = FT_THROW( Code_Overflow );
a8265 5

#ifdef TT_CONFIG_OPTION_STATIC_RASTER
    *exc = cur;
#endif

d8269 3
a8271 3
    if ( CUR.error                          &&
         !CUR.instruction_trap              &&
         CUR.curRange == tt_coderange_glyph )
d8273 1
a8273 1
      FT_TRACE1(( "  The interpreter returned error 0x%x\n", CUR.error ));
d8278 1
a8278 1
    return CUR.error;
@


1.22
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d3062 1
a3062 1
#define DO_MPPEM              \
d3075 1
a3075 1
#define DO_MPS                \
d5628 1
a5628 1
  /* Opcode range: 0x8e                                                    */
d7657 1
a7657 1
    P = (FT_ULong)CUR_Func_cur_ppem();
d9007 3
a9009 3
    if ( CUR.error
         && !CUR.instruction_trap
         && CUR.curRange == tt_coderange_glyph )
@


1.21
log
@
Security/bugfixing update to freetype-2.5.3, featuring a fix for a
vulnerability in the CFF driver (CVE-2014-2240) and assorted minor
fixes.

ok matthieu@@
@
text
@d175 3
a189 6
#define CURRENT_Ppem() \
          Current_Ppem( EXEC_ARG )

#define CUR_Ppem() \
          Cur_PPEM( EXEC_ARG )

d282 1
a282 4
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
a305 2

    return FT_Err_Ok;
d327 1
a327 4
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
a336 2

    return FT_Err_Ok;
d354 1
a354 7
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Does not set the Error variable.                                   */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
a361 2

    return FT_Err_Ok;
a384 3
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
d388 1
a388 1
  FT_LOCAL_DEF( FT_Error )
a414 2

    return FT_Err_Ok;
a640 3
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
d644 1
a644 1
  FT_LOCAL_DEF( FT_Error )
a661 2

    return FT_Err_Ok;
d693 1
a693 6
    FT_Error  error;


    if ( ( error = TT_Goto_CodeRange( exec, tt_coderange_glyph, 0 ) )
           != FT_Err_Ok )
      return error;
d763 5
a767 1
    FT_Memory  memory = driver->root.root.memory;
d769 1
d1418 1
a1418 1
    register FT_Int32  t, t2;
d1678 1
a1678 1
  static FT_Long
d1681 7
d2026 1
a2026 1
      if ( distance && val < 0 )
d2066 2
a2067 4
      val = distance + compensation + 32;
      if ( distance && val > 0 )
        val &= ~63;
      else
d2109 2
a2110 2
      if ( distance && val < 0 )
        val = 0;
d2116 1
a2116 1
        val = 0;
d2150 2
a2151 4
      val = distance + compensation;
      if ( distance && val > 0 )
        val &= ~63;
      else
d2156 1
a2156 1
      val = -( ( compensation - distance ) & -64 );
d2192 2
a2193 4
      val = distance + compensation + 63;
      if ( distance && val > 0 )
        val &= ~63;
      else
d2234 2
a2235 4
      val = distance + compensation + 16;
      if ( distance && val > 0 )
        val &= ~31;
      else
a2281 2
      if ( distance && val < 0 )
        val = 0;
d2283 2
d2290 1
d2292 1
a2292 2
        val = 0;
      val -= CUR.phase;
a2329 2
      if ( distance && val < 0 )
        val = 0;
d2331 2
d2338 1
d2340 1
a2340 2
        val = 0;
      val -= CUR.phase;
d3048 2
a3049 2
#define DO_SDB                             \
    CUR.GS.delta_base = (FT_Short)args[0];
d3052 5
a3056 2
#define DO_SDS                              \
    CUR.GS.delta_shift = (FT_Short)args[0];
d3063 1
a3063 1
    args[0] = CURRENT_Ppem();
d3076 1
a3076 1
    args[0] = CURRENT_Ppem();
d7461 1
a7461 1
    FT_ULong   k, nump;
d7463 1
a7463 1
    FT_ULong   C;
d7497 1
d7542 1
a7542 1
        if ( CURRENT_Ppem() == (FT_Long)C )
d7547 1
a7547 1
          B = B * 64 / ( 1L << CUR.GS.delta_shift );
d7556 4
a7559 4
             *  - not using ignore_x_mode rendering
             *  - glyph is specifically set to allow it
             *  - glyph is composite and freedom vector is not subpixel
             *    vector
d7566 3
a7568 3
            /* Otherwise apply subpixel hinting and */
            /* compatibility mode rules             */
            else if ( CUR.ignore_x_mode )
d7570 2
a7571 4
              if ( CUR.GS.freeVector.y != 0 )
                B1 = CUR.zp0.cur[A].y;
              else
                B1 = CUR.zp0.cur[A].x;
d7573 4
a7576 5
#if 0
              /* Standard Subpixel Hinting: Allow y move.       */
              /* This messes up dejavu and may not be needed... */
              if ( !CUR.face->sph_compatibility_mode &&
                   CUR.GS.freeVector.y != 0          )
a7577 2
              else
#endif /* 0 */
d7579 3
a7581 4
              /* Compatibility Mode: Allow x or y move if point touched in */
              /* Y direction.                                              */
              if ( CUR.face->sph_compatibility_mode                      &&
                   !( CUR.sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP ) )
a7582 3
                /* save the y value of the point now; compare after move */
                B1 = CUR.zp0.cur[A].y;

d7593 1
a7593 1
              B2 = CUR.zp0.cur[A].y;
d7633 1
a7633 1
    FT_ULong  A, C;
d7657 1
d7703 1
a7703 1
        if ( CURRENT_Ppem() == (FT_Long)C )
d7708 1
a7708 1
          B = B * 64 / ( 1L << CUR.GS.delta_shift );
d8229 3
d8239 1
a8239 1
    /* set CVT functions */
d8244 1
d8252 1
d9007 3
a9009 1
    if ( CUR.error && !CUR.instruction_trap )
d9012 2
a9013 1
      exc->size->cvt_ready      = FALSE;
@


1.20
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d7 1
a7 1
/*  Copyright 1996-2013                                                    */
d799 1
a799 2
    TT_ExecContext  exec;
    FT_Memory       memory;
a801 3
    memory = driver->root.root.memory;
    exec   = driver->context;

d804 2
a805 1
      FT_Error  error;
d1470 1
a1470 1
#ifdef __clang__
d7169 1
a7169 1
      cur_dist = CUR_Func_project ( &CUR.zp2.cur[point], cur_base );
d7180 1
a7180 1
          /*           (Current_Pt - Current_RP1)                    */
d7184 8
a7191 2
          /*   new_dist = cur_dist -                                 */
          /*              org_dist - cur_dist;                       */
d7193 1
a7193 1
          new_dist = -org_dist;
a7825 7
      /********************************/
      /* HINTING FOR GRAYSCALE        */
      /* Selector Bit:  5             */
      /* Return Bit(s): 12            */
      /*                              */
      if ( ( args[0] & 32 ) != 0 && CUR.grayscale_hinting )
        K |= 1 << 12;
d7834 1
a7834 1
        if ( ( args[0] & 64 ) != 0 && CUR.subpixel_hinting )
@


1.19
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@a1439 1
#if 1
d1441 100
d1572 14
a1585 1
#else
d1587 5
a1591 4
  /* compute (a*b)/2^14 with maximum accuracy and rounding */
  static FT_Int32
  TT_MulFix14( FT_Int32  a,
               FT_Int    b )
d1593 2
a1594 2
    FT_Int32   m, s, hi;
    FT_UInt32  l, lo;
d1596 2
a1598 3
    /* compute ax*bx as 64-bit value */
    l  = (FT_UInt32)( ( a & 0xFFFFU ) * b );
    m  = ( a >> 16 ) * b;
d1600 3
a1602 2
    lo = l + ( (FT_UInt32)m << 16 );
    hi = ( m >> 16 ) + ( (FT_Int32)l >> 31 ) + ( lo < l );
d1604 1
a1604 5
    /* divide the result by 2^14 with rounding */
    s   = hi >> 31;
    l   = lo + (FT_UInt32)s;
    hi += s + ( l < lo );
    lo  = l;
d1606 1
a1606 2
    l   = lo + 0x2000U;
    hi += l < lo;
d1608 2
a1609 2
    return (FT_Int32)( ( (FT_UInt32)hi << 18 ) | ( l >> 14 ) );
  }
d1612 4
d1658 2
d3154 11
a3164 11
#define DO_JROT                                                   \
    if ( args[1] != 0 )                                           \
    {                                                             \
      if ( args[0] == 0 && CUR.args == 0 )                        \
        CUR.error = FT_THROW( Bad_Argument );                     \
      CUR.IP += args[0];                                          \
      if ( CUR.IP < 0                                          || \
           ( CUR.callTop > 0                                 &&   \
             CUR.IP > CUR.callStack[CUR.callTop - 1].Cur_End ) )  \
        CUR.error = FT_THROW( Bad_Argument );                     \
      CUR.step_ins = FALSE;                                       \
d3168 8
a3175 8
#define DO_JMPR                                                 \
    if ( args[0] == 0 && CUR.args == 0 )                        \
      CUR.error = FT_THROW( Bad_Argument );                     \
    CUR.IP += args[0];                                          \
    if ( CUR.IP < 0                                          || \
         ( CUR.callTop > 0                                 &&   \
           CUR.IP > CUR.callStack[CUR.callTop - 1].Cur_End ) )  \
      CUR.error = FT_THROW( Bad_Argument );                     \
d3179 11
a3189 11
#define DO_JROF                                                   \
    if ( args[1] == 0 )                                           \
    {                                                             \
      if ( args[0] == 0 && CUR.args == 0 )                        \
        CUR.error = FT_THROW( Bad_Argument );                     \
      CUR.IP += args[0];                                          \
      if ( CUR.IP < 0                                          || \
           ( CUR.callTop > 0                                 &&   \
             CUR.IP > CUR.callStack[CUR.callTop - 1].Cur_End ) )  \
        CUR.error = FT_THROW( Bad_Argument );                     \
      CUR.step_ins = FALSE;                                       \
d4905 1
a4905 1
      CUR.IP = pRec->Cur_Restart;
d4995 1
a4995 2
    pCrec->Cur_Restart  = def->start;
    pCrec->Cur_End      = def->end;
d5083 1
a5083 2
      pCrec->Cur_Restart  = def->start;
      pCrec->Cur_End      = def->end;
d7831 1
a7831 8
      /********************************/
      /* HINTING FOR SUBPIXEL         */
      /* Selector Bit:  6             */
      /* Return Bit(s): 13            */
      /*                              */
      if ( ( args[0] & 64 ) != 0        &&
           CUR.subpixel_hinting         &&
           CUR.rasterizer_version >= 37 )
d7833 7
a7839 3
        K |= 1 << 13;

        /* the stuff below is irrelevant if subpixel_hinting is not set */
d7915 1
a7915 2
        call->Cur_Restart  = def->start;
        call->Cur_End      = def->end;
d8971 1
a8971 2
                callrec->Cur_Restart  = def->start;
                callrec->Cur_End      = def->end;
@


1.18
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@d28 1
d135 5
d1773 3
a1775 2
      if ( !CUR.ignore_x_mode                                ||
           ( CUR.sph_tweak_flags & SPH_TWEAK_ALLOW_X_DMOVE ) )
d1777 1
a1777 1
      zone->cur[point].x += FT_MulDiv( distance, v, CUR.F_dot_P );
d1852 2
a1853 2
    if ( !CUR.ignore_x_mode                                 ||
         ( CUR.sph_tweak_flags & SPH_TWEAK_ALLOW_X_DMOVEX ) )
d1855 2
a1856 1
    zone->cur[point].x += distance;
d3176 2
a3177 1
       if ( CUR.ignore_x_mode                          && \
d4476 1
a4476 1
    FT_Byte    opcode_pattern[7][12] = {
d4554 13
d4568 3
a4570 3
    FT_UShort  opcode_patterns   = 7;
    FT_UShort  opcode_pointer[7] = {  0, 0, 0, 0, 0, 0, 0 };
    FT_UShort  opcode_size[7]    = { 12, 8, 8, 6, 7, 4, 5 };
d4629 1
d4632 1
a4632 1
      for ( i = 0; i < opcode_patterns; i++ )
d4634 1
a4634 2
        if ( opcode_pointer[i] < opcode_size[i]                 &&
             CUR.opcode == opcode_pattern[i][opcode_pointer[i]] )
d4636 2
a4637 3
          opcode_pointer[i] += 1;

          if ( opcode_pointer[i] == opcode_size[i] )
d4639 1
a4639 4
            FT_TRACE7(( "sph: Function %d, opcode ptrn: %d, %s %s\n",
                        i, n,
                        CUR.face->root.family_name,
                        CUR.face->root.style_name ));
d4641 1
a4641 1
            switch ( i )
d4643 4
a4646 9
            case 0:
              rec->sph_fdef_flags            |= SPH_FDEF_INLINE_DELTA_1;
              CUR.face->sph_found_func_flags |= SPH_FDEF_INLINE_DELTA_1;
              break;

            case 1:
              rec->sph_fdef_flags            |= SPH_FDEF_INLINE_DELTA_2;
              CUR.face->sph_found_func_flags |= SPH_FDEF_INLINE_DELTA_2;
              break;
d4648 1
a4648 12
            case 2:
              switch ( n )
              {
              /* needs to be implemented still */
              case 58:
                rec->sph_fdef_flags            |= SPH_FDEF_DIAGONAL_STROKE;
                CUR.face->sph_found_func_flags |= SPH_FDEF_DIAGONAL_STROKE;
              }
              break;

            case 3:
              switch ( n )
d4651 3
a4653 4
                rec->sph_fdef_flags            |= SPH_FDEF_VACUFORM_ROUND_1;
                CUR.face->sph_found_func_flags |= SPH_FDEF_VACUFORM_ROUND_1;
              }
              break;
d4655 4
a4658 5
            case 4:
              /* probably not necessary to detect anymore */
              rec->sph_fdef_flags            |= SPH_FDEF_TTFAUTOHINT_1;
              CUR.face->sph_found_func_flags |= SPH_FDEF_TTFAUTOHINT_1;
              break;
a4659 5
            case 5:
              switch ( n )
              {
              case 0:
              case 1:
d4661 18
d4680 37
a4716 6
              case 7:
              case 8:
                rec->sph_fdef_flags            |= SPH_FDEF_SPACING_1;
                CUR.face->sph_found_func_flags |= SPH_FDEF_SPACING_1;
              }
              break;
d4718 6
a4723 11
            case 6:
              switch ( n )
              {
              case 0:
              case 1:
              case 2:
              case 4:
              case 7:
              case 8:
                rec->sph_fdef_flags            |= SPH_FDEF_SPACING_2;
                CUR.face->sph_found_func_flags |= SPH_FDEF_SPACING_2;
d4725 1
a4725 1
              break;
d4727 3
a4730 1
          }
d4733 4
a4736 2
        else
          opcode_pointer[i] = 0;
a4738 5
      /* Set sph_compatibility_mode only when deltas are detected */
      CUR.face->sph_compatibility_mode =
        ( ( CUR.face->sph_found_func_flags & SPH_FDEF_INLINE_DELTA_1 ) |
          ( CUR.face->sph_found_func_flags & SPH_FDEF_INLINE_DELTA_2 ) );

d4770 4
d4859 8
a4866 1
    CUR.sph_in_func_flags &= def->sph_fdef_flags;
a4890 4
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    CUR.sph_in_func_flags &= !def->sph_fdef_flags;
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */

d4948 6
a4953 1
    CUR.sph_in_func_flags &= def->sph_fdef_flags;
a4979 4
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    CUR.sph_in_func_flags &= !def->sph_fdef_flags;
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */

d5331 2
a5332 1
    if ( CUR.ignore_x_mode && FT_ABS( D ) == 64 )
d5401 6
d5834 1
a5834 6
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
      if ( !CUR.ignore_x_mode                                      ||
          ( CUR.ignore_x_mode                                    &&
            ( CUR.sph_tweak_flags & SPH_TWEAK_ALLOW_X_MOVE_ZP2 ) ) )
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
        CUR.zp2.cur[point].x += dx;
d5891 7
d6080 2
a6081 1
        if ( CUR.ignore_x_mode )
a6088 4
          if ( CUR.GS.freeVector.y != 0                               &&
               ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_INLINE_DELTAS ) )
            goto Skip;

d6091 1
d6094 13
d6115 6
d6125 1
a6125 2
              MOVE_Zp2_Point( point, dx, dy, TRUE );
          }
d6127 4
a6130 5
          /* save new point */
          if ( CUR.GS.freeVector.y != 0 )
            B2 = CUR.zp2.cur[point].y;
          else
            B2 = CUR.zp2.cur[point].x;
d6132 10
a6141 13
          /* reverse any disallowed moves */
          if ( ( ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&
                 CUR.GS.freeVector.y != 0                                  &&
                 ( B1 & 63 ) != 0                                          &&
                 ( B2 & 63 ) != 0                                          &&
                 B1 != B2                                                  ) ||
               ( CUR.face->sph_compatibility_mode                          &&
                 CUR.GS.freeVector.y != 0                                  &&
                 ( B1 & 63 ) == 0                                          &&
                 ( B2 & 63 ) != 0                                          &&
                 B1 != B2                                                  ) )
            MOVE_Zp2_Point( point, -dx, -dy, TRUE );
      }
d6145 5
a6149 2
  Skip:
#else
d6151 2
a6152 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d6174 1
d6176 2
a6177 1
    FT_F26Dot6  control_value_cutin;
d6179 3
d6183 5
a6187 1
    control_value_cutin = CUR.GS.control_value_cutin;
a6188 4
    if ( CUR.ignore_x_mode                                 &&
         CUR.GS.freeVector.x != 0                          &&
         !( CUR.sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
      control_value_cutin = 0;
d6215 2
a6216 1
    if ( CUR.ignore_x_mode                                   &&
d6259 2
a6260 1
      if ( CUR.ignore_x_mode        &&
d6302 2
a6303 1
    if ( CUR.ignore_x_mode                                 &&
d6305 1
d6345 3
a6347 1
      if ( !CUR.ignore_x_mode || !CUR.face->sph_compatibility_mode )
d6356 2
a6357 1
    if ( CUR.ignore_x_mode                             &&
d6372 2
a6373 1
      if ( CUR.ignore_x_mode        &&
d6407 2
a6408 1
    if ( CUR.ignore_x_mode                                 &&
a6413 1

d6477 3
a6479 1
      if ( CUR.ignore_x_mode && CUR.GS.freeVector.x != 0 )
d6545 2
a6546 2
    FT_Int      B1;
    FT_Int      B2;
d6557 2
a6558 1
    if ( CUR.ignore_x_mode                                 &&
a6578 5
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
      if ( CUR.ignore_x_mode                                 &&
           ( CUR.sph_tweak_flags & SPH_TWEAK_MIRP_CVT_ZERO ) )
        cvt_dist = 0;
#endif
d6616 1
d6618 2
a6619 1
    if ( CUR.ignore_x_mode                                        &&
d6629 1
d6660 2
a6662 1
    {
d6664 3
a6666 1
      if ( CUR.ignore_x_mode && CUR.GS.gep0 == CUR.GS.gep1 )
d6671 2
a6676 5
#else
      distance = ROUND_None(
                   cvt_dist,
                   CUR.tt_metrics.compensations[CUR.opcode & 3] );
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d6695 3
a6697 1
    B1 = CUR.zp1.cur[point].y;
d6699 13
a6711 12
    /* Round moves if necessary */
    if ( CUR.ignore_x_mode                                          &&
         CUR.GS.freeVector.y != 0                                   &&
         ( CUR.sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES ) )
      distance = FT_PIX_ROUND( B1 + distance - cur_dist ) - B1 + cur_dist;

    if ( CUR.ignore_x_mode                                      &&
         CUR.GS.freeVector.y != 0                               &&
         ( CUR.opcode & 16 ) == 0                               &&
         ( CUR.opcode & 8 ) == 0                                &&
         ( CUR.sph_tweak_flags & SPH_TWEAK_COURIER_NEW_2_HACK ) )
      distance += 64;
d6717 12
a6728 1
    B2 = CUR.zp1.cur[point].y;
d6730 9
a6738 20
    /* Reverse move if necessary */
    if ( CUR.ignore_x_mode )
    {
      if ( CUR.face->sph_compatibility_mode                          &&
           CUR.GS.freeVector.y != 0                                  &&
           ( B1 & 63 ) == 0                                          &&
           ( B2 & 63 ) != 0                                          )
        reverse_move = TRUE;

      if ( ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&
           CUR.GS.freeVector.y != 0                                  &&
           ( B2 & 63 ) != 0                                          &&
           ( B1 & 63 ) != 0                                          )
        reverse_move = TRUE;

      if ( ( CUR.sph_tweak_flags                      &
             SPH_TWEAK_DELTAP_SKIP_EXAGGERATED_VALUES ) &&
           !reverse_move                                &&
           FT_ABS( B1 - B2 ) >= 64                      )
        reverse_move = TRUE;
a6740 3
    if ( reverse_move )
      CUR_Func_move( &CUR.zp1, point, -( distance - cur_dist ) );

d6769 2
a6770 1
    if ( CUR.ignore_x_mode                                        &&
d7301 2
a7302 1
    if ( CUR.ignore_x_mode )
d7304 1
a7304 1
      CUR.iup_called = 1;
d7381 8
a7388 1
#endif
a7462 11
          /*
           *  Allow delta move if
           *
           *  - not using ignore_x_mode rendering
           *  - glyph is specifically set to allow it
           *  - glyph is composite and freedom vector is not subpixel vector
           */
          if ( !CUR.ignore_x_mode                                   ||
               ( CUR.sph_tweak_flags & SPH_TWEAK_ALWAYS_DO_DELTAP ) ||
               ( CUR.is_composite && CUR.GS.freeVector.y != 0 )     )
            CUR_Func_move( &CUR.zp0, A, B );
d7464 1
a7464 2
          /* Otherwise apply subpixel hinting and compatibility mode rules */
          else if ( CUR.ignore_x_mode )
d7466 11
a7476 9
            if ( CUR.GS.freeVector.y != 0 )
              B1 = CUR.zp0.cur[A].y;
            else
              B1 = CUR.zp0.cur[A].x;
#if 0
            /* Standard Subpixel Hinting: Allow y move.       */
            /* This messes up dejavu and may not be needed... */
            if ( !CUR.face->sph_compatibility_mode &&
                 CUR.GS.freeVector.y != 0           )
d7478 4
a7481 6
            else
#endif
            /* Compatibility Mode: Allow x or y move if point touched in */
            /* Y direction.                                              */
            if ( CUR.face->sph_compatibility_mode                      &&
                 !( CUR.sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP ) )
d7483 13
a7495 2
              /* save the y value of the point now; compare after move */
              B1 = CUR.zp0.cur[A].y;
d7497 10
a7506 2
              if ( ( CUR.sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES ) )
                B = FT_PIX_ROUND( B1 + B ) - B1;
d7508 6
a7513 6
              /* Allow delta move if using sph_compatibility_mode,   */
              /* IUP has not been called, and point is touched on Y. */
              if ( !CUR.iup_called                            &&
                   ( CUR.zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y ) )
                CUR_Func_move( &CUR.zp0, A, B );
            }
d7515 1
a7515 1
            B2 = CUR.zp0.cur[A].y;
d7517 11
a7527 10
            /* Reverse this move if it results in a disallowed move */
            if ( CUR.GS.freeVector.y != 0                    &&
                 ( ( CUR.face->sph_compatibility_mode    &&
                     ( B1 & 63 ) == 0                    &&
                     ( B2 & 63 ) != 0                    ) ||
                   ( ( CUR.sph_tweak_flags             &
                       SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&
                     ( B1 & 63 ) != 0                    &&
                     ( B2 & 63 ) != 0                    ) ) )
              CUR_Func_move( &CUR.zp0, A, -B );
d7529 4
a7532 3
#else
          CUR_Func_move( &CUR.zp0, A, B );
#endif /* *TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d7668 3
a7670 1
    if ( ( args[0] & 1 ) != 0 && CUR.ignore_x_mode )
d7679 1
a7679 1
        K = 35;
d7706 4
a7709 1
    if ( CUR.ignore_x_mode && CUR.rasterizer_version >= 35 )
d7772 1
d7774 1
d8143 15
a8157 1
    FT_Long  ins_counter = 0;  /* executed instructions counter */
a8213 3
        FT_UShort  i;


d8240 33
d8469 1
a8469 7
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
          if ( !CUR.ignore_x_mode                                         ||
               !CUR.iup_called                                            ||
               ( CUR.iup_called                                         &&
                 !( CUR.sph_tweak_flags & SPH_TWEAK_NO_CALL_AFTER_IUP ) ) )
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
            Ins_CALL( EXEC_ARG_ args );
d8487 1
a8487 5
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
          if ( CUR.ignore_x_mode )
            CUR.iup_called = TRUE;
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
            Ins_IUP( EXEC_ARG_ args );
d8646 1
a8646 7
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
          if ( !CUR.ignore_x_mode                                           ||
               !CUR.iup_called                                              ||
               ( CUR.iup_called                                           &&
                 !( CUR.sph_tweak_flags & SPH_TWEAK_NO_DELTAP_AFTER_IUP ) ) )
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
            Ins_DELTAP( EXEC_ARG_ args );
@


1.17
log
@Update to freetype 2.4.11. Tested by krw@@, jasper@@ and on a bulk ports
build by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2012                                                    */
a36 4
#define xxxSPH_DEBUG
#define xxxSPH_DEBUG_MORE_VERBOSE


d307 1
a307 1
    return TT_Err_Ok;
d343 1
a343 1
    return TT_Err_Ok;
d376 1
a376 1
    return TT_Err_Ok;
d434 1
a434 1
    return TT_Err_Ok;
d484 1
a484 1
    return TT_Err_Ok;
d536 1
a536 1
    return TT_Err_Ok;
d643 1
a643 1
    return TT_Err_Ok;
d686 1
a686 1
    return TT_Err_Ok;
d722 1
a722 1
           != TT_Err_Ok )
d759 1
a759 1
      return TT_Err_Ok;
d1482 1
a1482 1
    lo = l + (FT_UInt32)( m << 16 );
d1494 1
a1494 1
    return ( hi << 18 ) | ( l >> 14 );
d1514 1
a1514 1
    lo1 = l + (FT_UInt32)( m << 16 );
d1521 1
a1521 1
    lo2 = l + (FT_UInt32)( m << 16 );
d1537 1
a1537 89
    return ( hi << 18 ) | ( l >> 14 );
  }


  /* return length of given vector */

#if 0

  static FT_Int32
  TT_VecLen( FT_Int32  x,
             FT_Int32  y )
  {
    FT_Int32   m, hi1, hi2, hi;
    FT_UInt32  l, lo1, lo2, lo;


    /* compute x*x as 64-bit value */
    lo = (FT_UInt32)( x & 0xFFFFU );
    hi = x >> 16;

    l  = lo * lo;
    m  = hi * lo;
    hi = hi * hi;

    lo1 = l + (FT_UInt32)( m << 17 );
    hi1 = hi + ( m >> 15 ) + ( lo1 < l );

    /* compute y*y as 64-bit value */
    lo = (FT_UInt32)( y & 0xFFFFU );
    hi = y >> 16;

    l  = lo * lo;
    m  = hi * lo;
    hi = hi * hi;

    lo2 = l + (FT_UInt32)( m << 17 );
    hi2 = hi + ( m >> 15 ) + ( lo2 < l );

    /* add them to get 'x*x+y*y' as 64-bit value */
    lo = lo1 + lo2;
    hi = hi1 + hi2 + ( lo < lo1 );

    /* compute the square root of this value */
    {
      FT_UInt32  root, rem, test_div;
      FT_Int     count;


      root = 0;

      {
        rem   = 0;
        count = 32;
        do
        {
          rem      = ( rem << 2 ) | ( (FT_UInt32)hi >> 30 );
          hi       = (  hi << 2 ) | (            lo >> 30 );
          lo     <<= 2;
          root   <<= 1;
          test_div = ( root << 1 ) + 1;

          if ( rem >= test_div )
          {
            rem  -= test_div;
            root += 1;
          }
        } while ( --count );
      }

      return (FT_Int32)root;
    }
  }

#else

  /* this version uses FT_Vector_Length which computes the same value */
  /* much, much faster..                                              */
  /*                                                                  */
  static FT_F26Dot6
  TT_VecLen( FT_F26Dot6  X,
             FT_F26Dot6  Y )
  {
    FT_Vector  v;


    v.x = X;
    v.y = Y;

    return FT_Vector_Length( &v );
a1539 2
#endif

d1584 1
a1584 1
          CUR.tt_metrics.ratio = TT_VecLen( x, y );
d1702 1
a1702 1
      CUR.error = TT_Err_Bad_Argument;
d1710 1
a1710 1
      CUR.error = TT_Err_Invalid_CodeRange;
d1720 1
a1720 1
      CUR.error = TT_Err_Code_Overflow;
a2618 2


a2624 1
    FT_Bool     S1, S2;
d2629 1
a2629 1
    if ( FT_ABS( Vx ) < 0x10000L && FT_ABS( Vy ) < 0x10000L )
d2631 1
a2631 6
      Vx *= 0x100;
      Vy *= 0x100;

      W = TT_VecLen( Vx, Vy );

      if ( W == 0 )
d2638 2
a2639 41
      R->x = (FT_F2Dot14)TT_DivFix14( Vx, W );
      R->y = (FT_F2Dot14)TT_DivFix14( Vy, W );

      return SUCCESS;
    }

    W = TT_VecLen( Vx, Vy );

    Vx = TT_DivFix14( Vx, W );
    Vy = TT_DivFix14( Vy, W );

    W = Vx * Vx + Vy * Vy;

    /* Now, we want that Sqrt( W ) = 0x4000 */
    /* Or 0x10000000 <= W < 0x10004000      */

    if ( Vx < 0 )
    {
      Vx = -Vx;
      S1 = TRUE;
    }
    else
      S1 = FALSE;

    if ( Vy < 0 )
    {
      Vy = -Vy;
      S2 = TRUE;
    }
    else
      S2 = FALSE;

    while ( W < 0x10000000L )
    {
      /* We need to increase W by a minimal amount */
      if ( Vx < Vy )
        Vx++;
      else
        Vy++;

      W = Vx * Vx + Vy * Vy;
d2642 1
a2642 10
    while ( W >= 0x10004000L )
    {
      /* We need to decrease W by a minimal amount */
      if ( Vx < Vy )
        Vx--;
      else
        Vy--;

      W = Vx * Vx + Vy * Vy;
    }
d2644 2
a2645 11
    /* Note that in various cases, we can only  */
    /* compute a Sqrt(W) of 0x3FFF, eg. Vx = Vy */

    if ( S1 )
      Vx = -Vx;

    if ( S2 )
      Vy = -Vy;

    R->x = (FT_F2Dot14)Vx;   /* Type conversion */
    R->y = (FT_F2Dot14)Vy;   /* Type conversion */
d2673 1
a2673 1
        CUR.error = TT_Err_Invalid_Reference;
d2929 4
a2932 4
#define DO_SLOOP                       \
    if ( args[0] < 0 )                 \
      CUR.error = TT_Err_Bad_Argument; \
    else                               \
d3014 15
a3028 15
#define DO_CINDEX                             \
  {                                           \
    FT_Long  L;                               \
                                              \
                                              \
    L = args[0];                              \
                                              \
    if ( L <= 0 || L > CUR.args )             \
    {                                         \
      if ( CUR.pedantic_hinting )             \
        CUR.error = TT_Err_Invalid_Reference; \
      args[0] = 0;                            \
    }                                         \
    else                                      \
      args[0] = CUR.stack[CUR.args - L];      \
d3036 1
a3036 1
        CUR.error = TT_Err_Bad_Argument;                          \
d3041 1
a3041 1
        CUR.error = TT_Err_Bad_Argument;                          \
d3048 1
a3048 1
      CUR.error = TT_Err_Bad_Argument;                          \
d3053 1
a3053 1
      CUR.error = TT_Err_Bad_Argument;                          \
d3061 1
a3061 1
        CUR.error = TT_Err_Bad_Argument;                          \
d3066 1
a3066 1
        CUR.error = TT_Err_Bad_Argument;                          \
d3125 1
a3125 1
      CUR.error = TT_Err_Divide_By_Zero;                     \
d3168 12
a3179 2
       if ( CUR.compatibility_mode           &&           \
            ( I == 24 || I == 22 || I == 8 ) )            \
d3279 2
a3280 2
#define DO_DEBUG                     \
    CUR.error = TT_Err_Debug_OpCode;
d3308 4
a3311 4
#define ARRAY_BOUND_ERROR                   \
    {                                       \
      CUR.error = TT_Err_Invalid_Reference; \
      return;                               \
d4290 1
a4290 1
        CUR.error = TT_Err_Invalid_Reference;
d4360 1
a4360 1
    CUR.error = TT_Err_Code_Overflow;
d4467 51
a4517 2
    FT_Byte    opcode_pattern[1][12] = {
                 /* #0 TTFautohint bytecode (old) */
d4528 17
d4546 3
a4548 3
    FT_UShort  opcode_patterns   = 1;
    FT_UShort  opcode_pointer[1] = { 0, };
    FT_UShort  opcode_size[1]    = { 7, };
d4571 1
a4571 1
        CUR.error = TT_Err_Too_Many_Function_Defs;
d4581 1
a4581 1
      CUR.error = TT_Err_Too_Many_Function_Defs;
d4585 6
a4590 5
    rec->range        = CUR.curRange;
    rec->opc          = (FT_UInt16)n;
    rec->start        = CUR.IP + 1;
    rec->active       = TRUE;
    rec->inline_delta = FALSE;
d4595 7
a4608 4
#ifdef SPH_DEBUG_MORE_VERBOSE
      printf ( "Opcode: %d ", CUR.opcode );
#endif

a4613 5
#ifdef SPH_DEBUG_MORE_VERBOSE
          printf( "function %d, opcode ptrn: %d"
                  "  op# %d: %d FOUND \n",
                  n, i, opcode_pointer[i], CUR.opcode );
#endif
d4618 4
a4621 3
#ifdef SPH_DEBUG
            printf( "Function signature %d detected in FDEF %d\n", i, n);
#endif
d4626 60
a4685 1
              CUR.size->ttfautohinted = TRUE;
d4696 5
d4707 1
a4707 1
        CUR.error = TT_Err_Nested_DEFS;
d4734 1
a4734 1
      CUR.error = TT_Err_ENDF_In_Exec_Stream;
a4745 9
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    /*
     *  CUR.ignore_x_mode may be turned off prior to function calls.  This
     *  ensures it is turned back on.
     */
    CUR.ignore_x_mode =  ( CUR.subpixel_hinting || CUR.grayscale_hinting ) &&
                        !( CUR.sph_tweak_flags & SPH_TWEAK_PIXEL_HINTING );
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */

d4816 3
d4823 1
a4823 1
      CUR.error = TT_Err_Stack_Overflow;
d4841 5
d4849 1
a4849 1
    CUR.error = TT_Err_Invalid_Reference;
d4902 4
d4909 1
a4909 1
      CUR.error = TT_Err_Stack_Overflow;
d4930 4
d4937 1
a4937 1
    CUR.error = TT_Err_Invalid_Reference;
d4968 1
a4968 1
        CUR.error = TT_Err_Too_Many_Instruction_Defs;
d4977 1
a4977 1
      CUR.error = TT_Err_Too_Many_Instruction_Defs;
d4998 1
a4998 1
        CUR.error = TT_Err_Nested_DEFS;
d5032 1
a5032 1
      CUR.error = TT_Err_Stack_Overflow;
d5059 1
a5059 1
      CUR.error = TT_Err_Stack_Overflow;
d5089 1
a5089 1
      CUR.error = TT_Err_Stack_Overflow;
d5114 1
a5114 1
      CUR.error = TT_Err_Stack_Overflow;
d5157 1
a5157 1
        CUR.error = TT_Err_Invalid_Reference;
d5194 1
a5194 1
        CUR.error = TT_Err_Invalid_Reference;
d5238 1
a5238 1
        CUR.error = TT_Err_Invalid_Reference;
d5314 1
a5314 1
        CUR.error = TT_Err_Invalid_Reference;
d5392 1
a5392 1
        CUR.error = TT_Err_Invalid_Reference;
d5421 1
a5421 1
        CUR.error = TT_Err_Invalid_Reference;
d5450 1
a5450 1
        CUR.error = TT_Err_Invalid_Reference;
d5479 1
a5479 1
        CUR.error = TT_Err_Invalid_Reference;
d5510 1
a5510 1
        CUR.error = TT_Err_Invalid_Reference;
d5608 1
a5608 1
        CUR.error = TT_Err_Too_Few_Arguments;
d5622 1
a5622 1
          CUR.error = TT_Err_Invalid_Reference;
d5657 1
a5657 1
        CUR.error = TT_Err_Invalid_Reference;
d5685 1
a5685 1
        CUR.error = TT_Err_Invalid_Reference;
d5719 1
a5719 1
        CUR.error = TT_Err_Invalid_Reference;
d5822 1
a5822 1
        CUR.error = TT_Err_Invalid_Reference;
d5838 1
a5838 1
          CUR.error = TT_Err_Invalid_Reference;
d5881 1
a5881 1
        CUR.error = TT_Err_Invalid_Reference;
d5929 1
a5929 1
        CUR.error = TT_Err_Invalid_Reference;
d5975 1
a5975 1
        CUR.error = TT_Err_Invalid_Reference;
d6010 1
a6010 1
          CUR.error = TT_Err_Invalid_Reference;
d6020 1
a6020 1
        /*   - freedom vector is y and compatibility_mode is off           */
d6037 2
a6038 2
          if ( CUR.ignore_x_mode                                   &&
               !CUR.compatibility_mode && CUR.GS.freeVector.y != 0 )
d6041 1
a6041 1
          else if ( CUR.ignore_x_mode && CUR.compatibility_mode )
d6043 1
a6043 2
            if ( CUR.ignore_x_mode                                         &&
                ( CUR.sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES ) )
d6065 2
a6066 2
                 B1 % 64 != 0                                              &&
                 B2 % 64 != 0                                              &&
d6068 1
a6068 1
               ( ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_OFFPIXEL_Y_MOVES ) &&
d6070 3
a6072 8
                 B1 % 64 == 0                                              &&
                 B2 % 64 != 0                                              &&
                 B1 != B2                                                  &&
                 !CUR.size->ttfautohinted                                  ) )
          {
#ifdef SPH_DEBUG
            printf( "Reversing ZP2 move\n" );
#endif
a6073 1
          }
d6121 1
a6121 1
        CUR.error = TT_Err_Invalid_Reference;
d6174 1
a6174 1
        CUR.error = TT_Err_Invalid_Reference;
d6234 1
a6234 1
        CUR.error = TT_Err_Invalid_Reference;
d6263 3
a6265 2
      /* only adjust legacy fonts x otherwise breaks Calibri italic */
      if ( CUR.compatibility_mode )
d6274 2
a6275 1
    if ( ( CUR.sph_tweak_flags & SPH_TWEAK_MIAP_HACK ) &&
d6336 1
a6336 1
        CUR.error = TT_Err_Invalid_Reference;
d6484 1
a6484 1
        CUR.error = TT_Err_Invalid_Reference;
d6493 2
a6494 1
      if ( CUR.sph_tweak_flags & SPH_TWEAK_MIRP_CVT_ZERO )
d6535 2
a6536 1
    if ( CUR.GS.freeVector.y != 0                                 &&
d6575 8
d6586 6
d6618 2
a6619 1
    if ( CUR.GS.freeVector.y != 0                               &&
d6634 1
a6634 1
      if ( ( CUR.sph_tweak_flags & SPH_TWEAK_SKIP_OFFPIXEL_Y_MOVES ) &&
d6636 2
a6637 3
           B1 % 64 == 0                                              &&
           B2 % 64 != 0                                              &&
           !CUR.size->ttfautohinted                                  )
d6642 2
a6643 2
           B2 % 64 != 0                                              &&
           B1 % 64 != 0                                              )
d6646 1
a6646 1
      if ( ( CUR.sph_tweak_flags &
d6688 1
a6688 1
      CUR.error = TT_Err_Invalid_Reference;
d6697 1
a6697 1
        CUR.error = TT_Err_Invalid_Reference;
d6711 1
a6711 1
          CUR.error = TT_Err_Invalid_Reference;
d6770 1
a6770 1
        CUR.error = TT_Err_Invalid_Reference;
d6846 1
a6846 1
        CUR.error = TT_Err_Invalid_Reference;
d6881 1
a6881 1
        CUR.error = TT_Err_Invalid_Reference;
d6895 1
a6895 1
        CUR.error = TT_Err_Invalid_Reference;
d6951 1
a6951 1
          CUR.error = TT_Err_Invalid_Reference;
d6977 18
a6994 3
        new_dist = ( old_range != 0 )
                     ? FT_MulDiv( org_dist, cur_range, old_range )
                     : cur_dist;
d7025 1
a7025 1
        CUR.error = TT_Err_Invalid_Reference;
d7307 1
a7307 1
          CUR.error = TT_Err_Too_Few_Arguments;
d7325 1
a7325 1
          CUR.error = TT_Err_Too_Few_Arguments;
d7388 5
a7392 3

            /* Standard Subpixel Hinting:  Allow y move */
            if ( !CUR.compatibility_mode && CUR.GS.freeVector.y != 0 )
d7394 6
a7399 5

            /* Compatibility Mode: Allow x or y move if point touched in
                Y direction */
            else if ( CUR.compatibility_mode                                  &&
                      !( CUR.sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP ) )
d7407 2
a7408 4
              /*
              *  Allow delta move if using compatibility_mode, IUP has not
              *  been called, and point is touched on Y.
              */
d7417 8
a7424 10
            if ( CUR.GS.freeVector.y != 0                     &&
                 ( ( ( CUR.sph_tweak_flags &
                        SPH_TWEAK_SKIP_OFFPIXEL_Y_MOVES ) &&
                        B1 % 64 == 0                      &&
                        B2 % 64 != 0                      &&
                        !CUR.size->ttfautohinted          ) ||
                   ( ( CUR.sph_tweak_flags &
                        SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&
                        B1 % 64 != 0                      &&
                        B2 % 64 != 0                      ) ) )
d7434 1
a7434 1
          CUR.error = TT_Err_Invalid_Reference;
d7466 1
a7466 1
          CUR.error = TT_Err_Too_Few_Arguments;
d7483 1
a7483 1
          CUR.error = TT_Err_Too_Few_Arguments;
d7497 1
a7497 1
          CUR.error = TT_Err_Invalid_Reference;
d7568 2
a7569 3
#ifdef SPH_DEBUG_MORE_VERBOSE
      printf(" SETTING AS %d\n", CUR.rasterizer_version );
#endif
d7687 1
a7687 1
          CUR.error = TT_Err_Stack_Overflow;
d7706 1
a7706 1
    CUR.error = TT_Err_Invalid_Opcode;
d8041 1
a8041 2
    if ( CUR.ignore_x_mode )
      CUR.iup_called        = FALSE;
d8095 1
a8095 1
          CUR.error = TT_Err_Too_Few_Arguments;
d8112 1
a8112 1
        CUR.error = TT_Err_Stack_Overflow;
d8117 1
a8117 1
      CUR.error    = TT_Err_Ok;
d8400 1
a8400 1
            CUR.error = TT_Err_Invalid_Reference;
d8696 1
a8696 1
      if ( CUR.error != TT_Err_Ok )
d8700 2
a8701 1
        case TT_Err_Invalid_Opcode: /* looking for redefined instructions */
d8716 1
a8716 1
                  CUR.error = TT_Err_Invalid_Reference;
d8736 1
a8736 1
          CUR.error = TT_Err_Invalid_Opcode;
d8762 1
a8762 1
        return TT_Err_Execution_Too_Long;
d8769 1
a8769 1
          CUR.error = TT_Err_Code_Overflow;
d8783 1
a8783 1
    return TT_Err_Ok;
d8786 1
a8786 1
    CUR.error = TT_Err_Code_Overflow;
@


1.16
log
@Update to freetype-2.4.10.

With help and ok matthieu@@
@
text
@a29 1

d31 1
d37 2
a38 3
#define TT_MULFIX           FT_MulFix
#define TT_MULDIV           FT_MulDiv
#define TT_MULDIV_NO_ROUND  FT_MulDiv_No_Round
d234 8
d1671 1
a1671 1
          FT_Long  x, y;
d1674 4
a1677 4
          x = TT_MULDIV( CUR.GS.projVector.x,
                         CUR.tt_metrics.x_ratio, 0x4000 );
          y = TT_MULDIV( CUR.GS.projVector.y,
                         CUR.tt_metrics.y_ratio, 0x4000 );
d1689 1
a1689 1
    return TT_MULFIX( CUR.tt_metrics.ppem, CURRENT_Ratio() );
d1710 1
a1710 1
    return TT_MULFIX( CUR.cvt[idx], CURRENT_Ratio() );
d1860 5
a1864 3
      zone->cur[point].x += TT_MULDIV( distance,
                                       v * 0x10000L,
                                       CUR.F_dot_P );
d1873 1
a1873 3
      zone->cur[point].y += TT_MULDIV( distance,
                                       v * 0x10000L,
                                       CUR.F_dot_P );
d1912 1
a1912 3
      zone->org[point].x += TT_MULDIV( distance,
                                       v * 0x10000L,
                                       CUR.F_dot_P );
d1917 1
a1917 3
      zone->org[point].y += TT_MULDIV( distance,
                                       v * 0x10000L,
                                       CUR.F_dot_P );
d1938 4
d2203 1
a2203 1
      val = - FT_PIX_CEIL( compensation - distance );
d2414 3
a2416 2
  /*    GridPeriod :: Grid period                                          */
  /*    selector   :: SROUND opcode                                        */
d2628 2
d2631 1
a2631 6
      {
        if ( CUR.GS.dualVector.y == 0x4000 )
          CUR.func_dualproj = Project_y;
        else
          CUR.func_dualproj = Dual_Project;
      }
d2641 3
a2643 1
      CUR.F_dot_P       = CUR.GS.projVector.x * 0x10000L;
d2645 3
a2647 7
    {
      if ( CUR.GS.freeVector.y == 0x4000 )
        CUR.F_dot_P       = CUR.GS.projVector.y * 0x10000L;
      else
        CUR.F_dot_P = (FT_Long)CUR.GS.projVector.x * CUR.GS.freeVector.x * 4 +
                      (FT_Long)CUR.GS.projVector.y * CUR.GS.freeVector.y * 4;
    }
d2651 2
d2654 1
a2654 6
    {
      if ( CUR.GS.projVector.y == 0x4000 )
        CUR.func_project = (TT_Project_Func)Project_y;
      else
        CUR.func_project = (TT_Project_Func)Project;
    }
d2658 2
d2661 1
a2661 6
    {
      if ( CUR.GS.dualVector.y == 0x4000 )
        CUR.func_dualproj = (TT_Project_Func)Project_y;
      else
        CUR.func_dualproj = (TT_Project_Func)Dual_Project;
    }
d2666 1
a2666 1
    if ( CUR.F_dot_P == 0x40000000L )
d2673 1
a2673 1
      else
d2675 2
a2676 5
        if ( CUR.GS.freeVector.y == 0x4000 )
        {
          CUR.func_move      = (TT_Move_Func)Direct_Move_Y;
          CUR.func_move_orig = (TT_Move_Func)Direct_Move_Orig_Y;
        }
d2683 2
a2684 2
    if ( FT_ABS( CUR.F_dot_P ) < 0x4000000L )
      CUR.F_dot_P = 0x40000000L;
d2740 2
a2741 2
      R->x = (FT_F2Dot14)FT_MulDiv( Vx, 0x4000L, W );
      R->y = (FT_F2Dot14)FT_MulDiv( Vy, 0x4000L, W );
d2748 2
a2749 2
    Vx = FT_MulDiv( Vx, 0x4000L, W );
    Vy = FT_MulDiv( Vy, 0x4000L, W );
d3108 1
a3108 1
    CUR.GS.single_width_value = TT_MULFIX( args[0],                \
d3286 1
a3286 1
      args[0] = TT_MULDIV_NO_ROUND( args[0], 64L, args[1] );
d3290 1
a3290 1
    args[0] = TT_MULDIV( args[0], args[1], 64L );
d3308 28
d3355 2
d3424 1
a3424 1
       CUR.cvt[I] = TT_MULFIX( args[1], CUR.tt_metrics.scale ); \
d4614 21
d4668 5
a4672 4
    rec->range  = CUR.curRange;
    rec->opc    = (FT_UInt16)n;
    rec->start  = CUR.IP + 1;
    rec->active = TRUE;
d4682 40
d4765 9
d4844 1
d4945 1
d5279 1
a5279 1
            D = TT_MULFIX( D, CUR.metrics.x_scale );
d5286 2
a5287 2
            vec.x = TT_MULFIX( vec1->x - vec2->x, CUR.metrics.x_scale );
            vec.y = TT_MULFIX( vec1->y - vec2->y, CUR.metrics.y_scale );
d5295 6
d5758 2
a5759 6
      *x = TT_MULDIV( d,
                      (FT_Long)CUR.GS.freeVector.x * 0x10000L,
                      CUR.F_dot_P );
      *y = TT_MULDIV( d,
                      (FT_Long)CUR.GS.freeVector.y * 0x10000L,
                      CUR.F_dot_P );
d5793 6
a5798 1
      CUR.zp2.cur[point].x += dx;
d5979 3
d5996 1
a5996 1
        dx = TT_MulFix14( (FT_UInt32)args[0], 0x4000 );
d6002 1
a6002 1
        dy = TT_MulFix14( (FT_UInt32)args[0], 0x4000 );
d6027 72
d6100 1
d6122 2
d6126 8
d6156 8
d6184 2
a6185 2
    FT_F26Dot6  cur_dist,
                distance;
d6200 11
a6210 2
      distance = CUR_Func_round( cur_dist,
                                 CUR.tt_metrics.compensations[0] ) - cur_dist;
d6233 3
a6235 2
    FT_F26Dot6  distance,
                org_dist;
d6238 10
a6247 2
    cvtEntry = (FT_ULong)args[1];
    point    = (FT_UShort)args[0];
d6281 6
a6286 2
      CUR.zp0.org[point].x = TT_MulFix14( (FT_UInt32)distance,
                                          CUR.GS.freeVector.x );
d6291 6
d6300 1
a6300 1
    if ( ( CUR.opcode & 1 ) != 0 )   /* rounding and control cutin flag */
d6302 1
a6302 1
      if ( FT_ABS( distance - org_dist ) > CUR.GS.control_value_cutin )
d6305 9
a6313 1
      distance = CUR_Func_round( distance, CUR.tt_metrics.compensations[0] );
d6334 11
a6344 1
    FT_F26Dot6  org_dist, distance;
d6380 1
a6380 1
        org_dist = TT_MULFIX( org_dist, CUR.metrics.x_scale );
d6387 2
a6388 2
        vec.x = TT_MULFIX( vec1->x - vec2->x, CUR.metrics.x_scale );
        vec.y = TT_MULFIX( vec1->y - vec2->y, CUR.metrics.y_scale );
d6408 8
d6419 1
d6431 2
a6432 2
        if ( distance < CUR.GS.minimum_distance )
          distance = CUR.GS.minimum_distance;
d6436 2
a6437 2
        if ( distance > -CUR.GS.minimum_distance )
          distance = -CUR.GS.minimum_distance;
d6472 21
a6492 5
                org_dist;


    point    = (FT_UShort)args[0];
    cvtEntry = (FT_ULong)( args[1] + 1 );
d6509 4
d6550 11
a6560 2

    /* control value cutin and round */
d6581 1
a6581 1
        if ( FT_ABS( cvt_dist - org_dist ) > CUR.GS.control_value_cutin )
d6600 2
a6601 2
        if ( distance < CUR.GS.minimum_distance )
          distance = CUR.GS.minimum_distance;
d6605 2
a6606 2
        if ( distance > -CUR.GS.minimum_distance )
          distance = -CUR.GS.minimum_distance;
d6610 16
d6628 31
d6684 10
d6746 1
a6746 1
    FT_F26Dot6  discriminant;
d6775 2
d6788 14
a6801 4
    discriminant = TT_MULDIV( dax, -dby, 0x40 ) +
                   TT_MULDIV( day, dbx, 0x40 );

    if ( FT_ABS( discriminant ) >= 0x40 )
d6803 1
a6803 1
      val = TT_MULDIV( dx, -dby, 0x40 ) + TT_MULDIV( dy, dbx, 0x40 );
d6805 2
a6806 2
      R.x = TT_MULDIV( val, dax, discriminant );
      R.y = TT_MULDIV( val, day, discriminant );
d6930 1
a6930 1
        vec.x = TT_MULFIX( CUR.zp1.orus[CUR.GS.rp2].x - orus_base->x,
d6932 1
a6932 1
        vec.y = TT_MULFIX( CUR.zp1.orus[CUR.GS.rp2].y - orus_base->y,
d6967 1
a6967 1
        vec.x = TT_MULFIX( CUR.zp2.orus[point].x - orus_base->x,
d6969 1
a6969 1
        vec.y = TT_MULFIX( CUR.zp2.orus[point].y - orus_base->y,
d6979 1
a6979 1
                     ? TT_MULDIV( org_dist, cur_range, old_range )
d7140 2
a7141 2
            scale       = TT_MULDIV( org2 + delta2 - ( org1 + delta1 ),
                                     0x10000L, orus2 - orus1 );
d7145 1
a7145 1
              TT_MULFIX( worker->orus[i].x - orus1, scale );
d7200 9
d7278 3
d7354 61
d7416 1
d7546 23
a7568 5
    /* We return MS rasterizer version 1.7 for the font scaler. */
    if ( ( args[0] & 1 ) != 0 )
      K = 35;

    /* Has the glyph been rotated? */
d7572 5
a7576 1
    /* Has the glyph been stretched? */
d7580 5
a7584 1
    /* Are we hinting for grayscale? */
d7588 65
d8028 5
d8304 7
a8310 1
          Ins_CALL( EXEC_ARG_ args );
a8325 1

d8328 5
a8332 1
          Ins_IUP( EXEC_ARG_ args );
d8491 7
a8497 1
          Ins_DELTAP( EXEC_ARG_ args );
@


1.15
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@d55 1
a55 1
  /* limited to a maximal number of opcodes defined below.                 */
d1466 1
a1466 1
  /* compute (a*b)/2^14 with maximal accuracy and rounding */
d1496 1
a1496 1
  /* compute (ax*bx+ay*by)/2^14 with maximal accuracy and rounding */
d3113 3
a3115 8
    /* XXX: UNDOCUMENTED! or bug in the Windows engine?   */
    /*                                                    */
    /*      It seems that the value that is read here is  */
    /*      expressed in 16.16 format rather than in font */
    /*      units.                                        */
    /*                                                    */
#define DO_SSW                                                 \
    CUR.GS.single_width_value = (FT_F26Dot6)( args[0] >> 10 );
d5770 1
a5770 1
  /*               zero.                                                   */
@


1.14
log
@Update to freetype 2.4.8. Security update fixing CVE-2011-3439
@
text
@d7 1
a7 1
/*  Copyright 1996-2011                                                    */
d718 1
a718 1
    if ( ( error = TT_Goto_CodeRange( exec, tt_coderange_glyph, 0  ) )
d1803 1
a1803 1
    /*       range, we test for AIP <= Size, instead of AIP < Size.  */
d2760 1
a2760 1
    /* Or 0x10000000 <= W < 0x10004000        */
d3202 11
a3212 9
#define DO_JROT                            \
    if ( args[1] != 0 )                    \
    {                                      \
      if ( args[0] == 0 && CUR.args == 0 ) \
        CUR.error = TT_Err_Bad_Argument;   \
      CUR.IP += args[0];                   \
      if ( CUR.IP < 0 )                    \
        CUR.error = TT_Err_Bad_Argument;   \
      CUR.step_ins = FALSE;                \
d3216 8
a3223 6
#define DO_JMPR                          \
    if ( args[0] == 0 && CUR.args == 0 ) \
      CUR.error = TT_Err_Bad_Argument;   \
    CUR.IP += args[0];                   \
    if ( CUR.IP < 0 )                    \
      CUR.error = TT_Err_Bad_Argument;   \
d3227 11
a3237 9
#define DO_JROF                            \
    if ( args[1] == 0 )                    \
    {                                      \
      if ( args[0] == 0 && CUR.args == 0 ) \
        CUR.error = TT_Err_Bad_Argument;   \
      CUR.IP += args[0];                   \
      if ( CUR.IP < 0 )                    \
        CUR.error = TT_Err_Bad_Argument;   \
      CUR.step_ins = FALSE;                \
d4480 1
a4480 1
        if ( CUR.IP + 1 > CUR.codeSize )
d4649 1
d4767 1
d4846 1
d5062 2
a5063 2
  /* BULLSHIT: Measures from the original glyph must be taken along the    */
  /*           dual projection vector!                                     */
d5135 2
a5136 2
  /* BULLSHIT: Measure taken in the original glyph must be along the dual  */
  /*           projection vector.                                          */
d5138 3
a5140 3
  /* Second BULLSHIT: Flag attributes are inverted!                        */
  /*                  0 => measure distance in original outline            */
  /*                  1 => measure distance in grid-fitted outline         */
d5142 1
a5142 1
  /* Third one: `zp0 - zp1', and not `zp2 - zp1!                           */
d5773 4
d5780 3
a5782 4
    TT_GlyphZoneRec zp;
    FT_UShort       refp;
    FT_F26Dot6      dx,
                    dy;
d5784 2
a5785 2
    FT_Short        contour;
    FT_UShort       first_point, last_point, i;
d5789 1
d5791 1
a5791 1
    if ( BOUNDS( contour, CUR.pts.n_contours ) )
d5802 1
a5802 1
      first_point = 0;
d5804 2
a5805 2
      first_point = (FT_UShort)( CUR.pts.contours[contour - 1] + 1 -
                                 CUR.pts.first_point );
d5807 6
a5812 12
    last_point = (FT_UShort)( CUR.pts.contours[contour] -
                              CUR.pts.first_point );

    /* XXX: this is probably wrong... at least it prevents memory */
    /*      corruption when zp2 is the twilight zone              */
    if ( BOUNDS( last_point, CUR.zp2.n_points ) )
    {
      if ( CUR.zp2.n_points > 0 )
        last_point = (FT_UShort)(CUR.zp2.n_points - 1);
      else
        last_point = 0;
    }
d5814 1
a5814 1
    for ( i = first_point; i <= last_point; i++ )
d5836 1
a5836 1
    FT_UShort        last_point, i;
d5849 6
a5854 6
    /* XXX: UNDOCUMENTED! SHZ doesn't move the phantom points.  */
    /*      Twilight zone has no contours, so use `n_points'.   */
    /*      Normal zone's `n_points' includes phantoms, so must */
    /*      use end of last contour.                            */
    if ( CUR.GS.gep2 == 0 && CUR.zp2.n_points > 0 )
      last_point = (FT_UShort)( CUR.zp2.n_points - 1 );
d5856 1
a5856 10
    {
      last_point = (FT_UShort)( CUR.zp2.contours[CUR.zp2.n_contours - 1] );

      if ( BOUNDS( last_point, CUR.zp2.n_points ) )
      {
        if ( CUR.pedantic_hinting )
          CUR.error = TT_Err_Invalid_Reference;
        return;
      }
    }
d5858 1
a5858 1
      last_point = 0;
d5861 1
a5861 1
    for ( i = 0; i <= last_point; i++ )
d6267 1
a6267 1
      CUR.zp1.cur[point]   = CUR.zp0.cur[point];
d6576 1
a6576 1
      else
d6579 12
d6614 2
d6617 11
a6627 1
        org_dist = CUR_Func_dualproj( &CUR.zp2.orus[point], orus_base );
d7174 1
d7547 1
a7547 1
        if ( CUR.IP + 1 > CUR.codeSize )
d8183 1
d8257 1
a8257 1
      exc->size->cvt_ready      = FALSE;  
@


1.13
log
@Update to freetype 2.4.7.

This moslty is a bug-fix release for CVE-2011-3256.
@
text
@d5158 6
a5163 2
        FT_Vector*  vec1 = CUR.zp0.orus + L;
        FT_Vector*  vec2 = CUR.zp1.orus + K;
a5165 3
        if ( CUR.metrics.x_scale == CUR.metrics.y_scale )
        {
          /* this should be faster */
a5166 1
          D = TT_MULFIX( D, CUR.metrics.x_scale );
d5170 13
a5182 1
          FT_Vector  vec;
d5185 2
a5186 2
          vec.x = TT_MULFIX( vec1->x - vec2->x, CUR.metrics.x_scale );
          vec.y = TT_MULFIX( vec1->y - vec2->y, CUR.metrics.y_scale );
d5188 2
a5189 1
          D = CUR_fast_dualproj( &vec );
@


1.12
log
@Update to freetype 2.4.5. Tested by many.
@
text
@d19 4
d671 3
a673 3
    /* XXXX: Will probably disappear soon with all the code range */
    /*       management, which is now rather obsolete.            */
    /*                                                            */
d2848 11
d5113 2
a5114 2
    /* not part of the specs, but here for safety */

d5195 2
a5196 1
    FT_UShort  p1, p2;   /* was FT_Int in pas type ERROR */
d5217 11
d5230 1
a5230 1
    if ( ( CUR.opcode & 1 ) != 0 )
d5248 1
a5248 1
    if ( ( CUR.opcode & 1 ) != 0 )
a5733 1
        /* XXX: UNDOCUMENTED! SHP touches the points */
a5793 1
    /* XXX: UNDOCUMENTED! SHC touches the points */
d5948 3
a5950 3
    /* XXX: UNDOCUMENTED! behaviour */
    if ( CUR.GS.gep1 == 0 )   /* if the point that is to be moved */
                              /* is in twilight zone              */
a5992 2
    /* XXX: Is there some undocumented feature while in the */
    /*      twilight zone? ?                                */
d6035 19
a6053 21
    /* XXX: UNDOCUMENTED!                                */
    /*                                                   */
    /* The behaviour of an MIAP instruction is quite     */
    /* different when used in the twilight zone.         */
    /*                                                   */
    /* First, no control value cut-in test is performed  */
    /* as it would fail anyway.  Second, the original    */
    /* point, i.e. (org_x,org_y) of zp0.point, is set    */
    /* to the absolute, unrounded distance found in      */
    /* the CVT.                                          */
    /*                                                   */
    /* This is used in the CVT programs of the Microsoft */
    /* fonts Arial, Times, etc., in order to re-adjust   */
    /* some key font heights.  It allows the use of the  */
    /* IP instruction in the twilight zone, which        */
    /* otherwise would be `illegal' according to the     */
    /* specification.                                    */
    /*                                                   */
    /* We implement it with a special sequence for the   */
    /* twilight zone.  This is a bad hack, but it seems  */
    /* to work.                                          */
d6059 4
a6062 2
      CUR.zp0.org[point].x = TT_MulFix14( (FT_UInt32)distance, CUR.GS.freeVector.x );
      CUR.zp0.org[point].y = TT_MulFix14( (FT_UInt32)distance, CUR.GS.freeVector.y ),
d6246 2
a6247 2
    /* XXX: UNDOCUMENTED! -- twilight zone */

a6252 1

d6256 1
a6256 2

      CUR.zp1.cur[point] = CUR.zp0.cur[point];
a6329 1
    /* XXX: UNDOCUMENTED! */
@


1.11
log
@Update to freetype 2.4.4. Tested by shadchin@@, ajacoutot@@, krw@@.
@
text
@d7 1
a7 2
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010                                                         */
d988 2
a989 2
    /*  SDVPTL[0] */  PACK( 2, 0 ),
    /*  SDVPTL[1] */  PACK( 2, 0 ),
d3169 15
a3183 11
#define DO_CINDEX                           \
  {                                         \
    FT_Long  L;                             \
                                            \
                                            \
    L = args[0];                            \
                                            \
    if ( L <= 0 || L > CUR.args )           \
      CUR.error = TT_Err_Invalid_Reference; \
    else                                    \
      args[0] = CUR.stack[CUR.args - L];    \
d3187 9
a3195 7
#define DO_JROT                          \
    if ( args[1] != 0 )                  \
    {                                    \
      CUR.IP      += args[0];            \
      if ( CUR.IP < 0 )                  \
        CUR.error = TT_Err_Bad_Argument; \
      CUR.step_ins = FALSE;              \
d3199 6
a3204 4
#define DO_JMPR                        \
    CUR.IP      += args[0];            \
    if ( CUR.IP < 0 )                  \
      CUR.error = TT_Err_Bad_Argument; \
d3208 9
a3216 7
#define DO_JROF                          \
    if ( args[1] == 0 )                  \
    {                                    \
      CUR.IP      += args[0];            \
      if ( CUR.IP < 0 )                  \
        CUR.error = TT_Err_Bad_Argument; \
      CUR.step_ins = FALSE;              \
d4398 2
a4399 2
      CUR.error = TT_Err_Invalid_Reference;
      return;
d4401 3
d4405 3
a4407 1
    K = CUR.stack[CUR.args - L];
d4409 2
a4410 5
    FT_ARRAY_MOVE( &CUR.stack[CUR.args - L    ],
                   &CUR.stack[CUR.args - L + 1],
                   ( L - 1 ) );

    CUR.stack[CUR.args - 1] = K;
a5052 1
      {
d5054 1
a5054 4
        return;
      }
      else
        R = 0;
a5133 1
      {
a5134 2
        return;
      }
d5472 3
a5474 2
      CUR.error = TT_Err_Too_Few_Arguments;
      return;
d5497 1
d5685 3
a5687 2
      CUR.error = TT_Err_Invalid_Reference;
      return;
d5713 1
d5848 3
a5850 2
      CUR.error = TT_Err_Invalid_Reference;
      return;
d5894 1
d6009 1
a6009 1
      return;
d6055 1
d6081 1
a6081 1
      return;
d6166 1
d6204 1
a6204 1
      return;
d6259 14
a6272 1
        if ( FT_ABS( cvt_dist - org_dist ) >= CUR.GS.control_value_cutin )
d6274 1
d6303 1
d6334 1
a6334 1
      return;
d6362 1
d6504 3
a6506 2
      CUR.error = TT_Err_Invalid_Reference;
      return;
d6520 1
a6520 1
      return;
d6585 2
d6879 3
a6881 2
        CUR.error = TT_Err_Too_Few_Arguments;
        return;
d6897 4
a6900 2
        CUR.error = TT_Err_Too_Few_Arguments;
        return;
d6949 1
d6977 3
a6979 2
        CUR.error = TT_Err_Too_Few_Arguments;
        return;
d6994 4
a6997 2
        CUR.error = TT_Err_Too_Few_Arguments;
        return;
d7045 1
d7507 13
a7519 2
        CUR.error = TT_Err_Too_Few_Arguments;
        goto LErrorLabel_;
d7556 1
a7556 1
            FT_Short AA, BB;
@


1.10
log
@MFC security fix for CVE-2010-3814

commit 0edf0986f3be570f5bf90ff245a85c1675f5c9a4
Author: Werner Lemberg <wl@@gnu.org>
Date:   Wed Oct 6 11:52:27 2010 +0200

    [truetype] Improve error handling of `SHZ' bytecode instruction.
    Problem reported by Chris Evans <scarybeasts@@gmail.com>.

    * src/truetype/ttinterp.c (Ins_SHZ): Check `last_point'.
@
text
@d481 1
a481 2
    FT_ERROR(( "Init_Context: not enough memory for 0x%08lx\n",
               (FT_Long)exec ));
d598 6
@


1.9
log
@Update to freetype 2.4.3. Tested at least by krw@@, ajacoutot@@ and jasper@@
@
text
@d5798 1
d5800 8
@


1.8
log
@Update to freetype 2.4.2. This has been in snapshots for a while
and tested explicitely by ajacoutot@@ jasper@@, jcs@@, krw@@ and others
on various architectures.
@
text
@d6776 5
a6780 6
            if ( point > 0 )
              _iup_worker_interpolate( &V,
                                       cur_touched + 1,
                                       point - 1,
                                       cur_touched,
                                       point );
d8129 9
@


1.7
log
@patches from Freetype.org for the security issues found by Robert Swiecki:

CVE-2010-2497 freetype integer underflow
CVE-2010-2498 freetype invalid free
CVE-2010-2499 freetype buffer overflow
CVE-2010-2500 freetype integer overflow
CVE-2010-2519 freetype heap buffer overflow
CVE-2010-2520 freetype buffer overflow on heap
@
text
@d7 3
a9 2
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
d227 1
a227 1
  /* A simple bounds-checking macro.                                       */
d229 2
a230 1
#define BOUNDS( x, n )  ( (FT_UInt)(x) >= (FT_UInt)(n) )
d513 1
a513 1
  static FT_Error
d1116 281
d2013 2
a2014 1
    else {
d3179 7
a3185 5
#define DO_JROT               \
    if ( args[1] != 0 )       \
    {                         \
      CUR.IP      += args[0]; \
      CUR.step_ins = FALSE;   \
d3189 4
a3192 2
#define DO_JMPR             \
    CUR.IP      += args[0]; \
d3196 7
a3202 5
#define DO_JROF               \
    if ( args[1] == 0 )       \
    {                         \
      CUR.IP      += args[0]; \
      CUR.step_ins = FALSE;   \
d3285 16
a3300 16
#define DO_RS                          \
   {                                   \
     FT_ULong  I = (FT_ULong)args[0];  \
                                       \
                                       \
     if ( BOUNDS( I, CUR.storeSize ) ) \
     {                                 \
       if ( CUR.pedantic_hinting )     \
       {                               \
         ARRAY_BOUND_ERROR;            \
       }                               \
       else                            \
         args[0] = 0;                  \
     }                                 \
     else                              \
       args[0] = CUR.storage[I];       \
d3304 14
a3317 14
#define DO_WS                          \
   {                                   \
     FT_ULong  I = (FT_ULong)args[0];  \
                                       \
                                       \
     if ( BOUNDS( I, CUR.storeSize ) ) \
     {                                 \
       if ( CUR.pedantic_hinting )     \
       {                               \
         ARRAY_BOUND_ERROR;            \
       }                               \
     }                                 \
     else                              \
       CUR.storage[I] = args[1];       \
d3326 1
a3326 1
     if ( BOUNDS( I, CUR.cvtSize ) )     \
d3345 1
a3345 1
     if ( BOUNDS( I, CUR.cvtSize ) )     \
d3362 1
a3362 1
     if ( BOUNDS( I, CUR.cvtSize ) )                            \
d4683 1
a4683 1
    if ( BOUNDS( F, CUR.maxFunc + 1 ) )
d4759 1
a4759 1
    if ( BOUNDS( F, CUR.maxFunc + 1 ) )
d4862 1
a4862 1
    def->start  = CUR.IP+1;
d5034 1
a5034 1
    if ( BOUNDS( L, CUR.zp2.n_points ) )
d5118 2
a5119 2
    if( BOUNDS( L, CUR.zp0.n_points ) ||
        BOUNDS( K, CUR.zp1.n_points ) )
d5773 4
a5776 4
    TT_GlyphZoneRec zp;
    FT_UShort       refp;
    FT_F26Dot6      dx,
                    dy;
d5778 1
a5778 1
    FT_UShort       last_point, i;
d5980 2
a5981 2
    if ( BOUNDS( point,    CUR.zp0.n_points ) ||
         BOUNDS( cvtEntry, CUR.cvtSize )      )
d6173 1
a6173 1
         BOUNDS( cvtEntry,   CUR.cvtSize + 1 )  ||
d6424 2
a6425 2
    if ( BOUNDS( args[0], CUR.zp1.n_points ) ||
         BOUNDS( args[1], CUR.zp0.n_points ) )
d6954 1
a6954 1
      if ( BOUNDS( A, CUR.cvtSize ) )
d7064 1
a7064 1
        call->Caller_IP    = CUR.IP+1;
d7432 4
@


1.6
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d6469 2
a6470 2
      if ( CUR.pts.n_points <= end_point )
        end_point = CUR.pts.n_points;
@


1.5
log
@Update to Freetype 2.3.9.

Bump major to be safe.
Small arm assembler fix in ftconfig.h by drahn@@
@
text
@d794 1
a794 1
        goto Exit;
d796 1
a796 1
      /* initialize it */
a804 1
  Exit:
d808 1
a808 3
    FT_FREE( exec );

    return 0;
d2197 1
a2197 1
    return TT_DotFix14( dx, dy,
d2223 1
a2223 1
    return TT_DotFix14( dx, dy,
d4293 8
d4302 1
a4302 1
    rec->opc    = n;
d4307 1
a4307 1
      CUR.maxFunc = n;
d4564 8
a4571 1
    def->opc    = args[0];
d4577 1
a4577 1
      CUR.maxIns = args[0];
d5545 1
a5545 1
        dx = TT_MulFix14( args[0], 0x4000 );
d5551 1
a5551 1
        dy = TT_MulFix14( args[0], 0x4000 );
d5557 2
a5558 2
      dx = TT_MulFix14( args[0], CUR.GS.freeVector.x );
      dy = TT_MulFix14( args[0], CUR.GS.freeVector.y );
d5724 2
a5725 2
      CUR.zp0.org[point].x = TT_MulFix14( distance, CUR.GS.freeVector.x );
      CUR.zp0.org[point].y = TT_MulFix14( distance, CUR.GS.freeVector.y ),
d5912 2
a5913 1
                             TT_MulFix14( cvt_dist, CUR.GS.freeVector.x );
d5916 2
a5917 1
                             TT_MulFix14( cvt_dist, CUR.GS.freeVector.y );
@


1.4
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d5102 1
a5102 1
    if ( ( args[0] & 0x100 ) != 0 && CUR.tt_metrics.ppem < A )
d5111 1
a5111 1
    if ( ( args[0] & 0x800 ) != 0 && CUR.tt_metrics.ppem >= A )
@


1.3
log
@Update to Freetype 2.3.7. This is a bug fix release. No API change.
@
text
@d751 7
d771 1
a771 1
    0, FALSE, 2, 1, 1, 1
d6391 1
a6391 1
                                     0x10000, orus2 - orus1 );
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d696 1
a696 1
  /*    TrueTyoe error code.  0 means success.                             */
d5095 1
a5095 4
    A *= 64;

#if 0
    if ( ( args[0] & 0x100 ) != 0 && CUR.metrics.pointSize <= A )
a5096 1
#endif
d5104 1
a5104 2
#if 0
    if ( ( args[0] & 0x800 ) != 0 && CUR.metrics.pointSize > A )
a5105 1
#endif
d5124 1
a5124 8
    /* for compatibility with future enhancements, */
    /* we must ignore new modes                    */

    if ( args[0] >= 0 && args[0] <= 5 )
    {
      if ( args[0] == 3 )
        args[0] = 2;

a5125 1
    }
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d30 1
a30 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d51 1
a51 1
  /* limitet to a maximal number of opcodes defined below.                 */
d138 1
a138 1
  /* increase readabilty of the code.                                      */
a160 3
#define CUR_Func_project( x, y ) \
          CUR.func_project( EXEC_ARG_ x, y )

a166 3
#define CUR_Func_dualproj( x, y ) \
          CUR.func_dualproj( EXEC_ARG_ x, y )

d204 13
d515 1
a515 1
              void**     buff,
d519 1
d524 1
a524 1
      if ( FT_REALLOC( *buff, *size * multiplier, new_max * multiplier ) )
d605 1
a605 1
                        (void**)&exec->stack,
d615 1
a615 1
                        (void**)&exec->glyphIns,
d624 4
d1134 18
a1151 2
  static
  const FT_Vector  Null_Vector = {0,0};
d1153 2
d1156 7
a1162 1
#undef PACK
d1164 1
d1166 2
a1167 2
#undef  NULL_Vector
#define NULL_Vector  (FT_Vector*)&Null_Vector
d1169 1
d1194 1
a1194 1
    hi += (l < lo);
d1198 1
d1887 1
a1888 1
    FT_UNUSED_EXEC;
d2158 1
a2158 1
    if ( (selector & 0x0F) == 0 )
d2186 2
a2187 2
  Project( EXEC_OP_ FT_Vector*  v1,
                    FT_Vector*  v2 )
d2193 1
a2193 2
    return TT_DotFix14( v1->x - v2->x,
                        v1->y - v2->y,
d2198 1
d2216 2
a2217 2
  Dual_Project( EXEC_OP_ FT_Vector*  v1,
                         FT_Vector*  v2 )
d2219 1
a2219 2
    return TT_DotFix14( v1->x - v2->x,
                        v1->y - v2->y,
d2242 2
a2243 2
  Project_x( EXEC_OP_ FT_Vector*  v1,
                      FT_Vector*  v2 )
d2246 1
d2248 1
a2248 1
    return ( v1->x - v2->x );
d2269 2
a2270 2
  Project_y( EXEC_OP_ FT_Vector*  v1,
                      FT_Vector*  v2 )
d2273 1
d2275 1
a2275 1
   return ( v1->y - v2->y );
d2806 6
a2811 6
    /* XXX: UNDOCUMENTED! or bug in the Windows engine? */
    /*                                                  */
    /* It seems that the value that is read here is     */
    /* expressed in 16.16 format rather than in font    */
    /* units.                                           */
    /*                                                  */
d4356 1
a4356 1
    /* NOTE: If the last intruction of a program is a    */
d4656 1
a4656 1
    L = (FT_UShort)(CUR.opcode - 0xB0 + 1);
d4681 1
a4681 1
    L = (FT_UShort)(CUR.opcode - 0xB8 + 1);
d4738 1
a4738 1
        R = CUR_Func_dualproj( CUR.zp2.org + L, NULL_Vector );
d4740 1
a4740 1
        R = CUR_Func_project( CUR.zp2.cur + L, NULL_Vector );
d4773 1
a4773 1
    K = CUR_Func_project( CUR.zp2.cur + L, NULL_Vector );
d4824 22
a4845 1
        D = CUR_Func_dualproj( CUR.zp0.org + L, CUR.zp1.org + K );
d5098 1
a5098 1
    if ( (args[0] & 0x100) != 0 && CUR.metrics.pointSize <= A )
d5102 1
a5102 1
    if ( (args[0] & 0x200) != 0 && CUR.tt_metrics.rotated )
d5105 1
a5105 1
    if ( (args[0] & 0x400) != 0 && CUR.tt_metrics.stretched )
d5109 1
a5109 1
    if ( (args[0] & 0x800) != 0 && CUR.metrics.pointSize > A )
d5113 1
a5113 1
    if ( (args[0] & 0x1000) != 0 && CUR.tt_metrics.rotated )
d5116 1
a5116 1
    if ( (args[0] & 0x2000) != 0 && CUR.tt_metrics.stretched )
d5279 1
d5444 2
a5445 1
      first_point = (FT_UShort)(CUR.pts.contours[contour - 1] + 1);
d5447 2
a5448 1
    last_point = CUR.pts.contours[contour];
d5452 1
a5452 1
    if ( last_point > CUR.zp2.n_points )
d5460 1
a5460 1
    /* XXX: UNDOCUMENTED! SHC does touch the points */
d5496 8
a5503 2
    if ( CUR.zp2.n_points > 0 )
      last_point = (FT_UShort)(CUR.zp2.n_points - 1);
d5621 1
a5621 1
    if ( (CUR.opcode & 1) != 0 )
d5653 1
a5653 1
      cur_dist = CUR_Func_project( CUR.zp0.cur + point, NULL_Vector );
d5693 1
a5693 1
    /* UNDOCUMENTED!                                     */
d5698 1
a5698 1
    /* First, no control value cutin test is performed   */
d5724 1
a5724 1
    org_dist = CUR_Func_project( CUR.zp0.cur + point, NULL_Vector );
d5767 33
a5799 2
    org_dist = CUR_Func_dualproj( CUR.zp1.org + point,
                                  CUR.zp0.org + CUR.GS.rp0 );
d5801 1
a5801 1
    /* single width cutin test */
d5912 1
a5912 1
      CUR.zp1.cur[point] = CUR.zp1.org[point];
d5915 4
a5918 5
    org_dist = CUR_Func_dualproj( CUR.zp1.org + point,
                                  CUR.zp0.org + CUR.GS.rp0 );

    cur_dist = CUR_Func_project( CUR.zp1.cur + point,
                                 CUR.zp0.cur + CUR.GS.rp0 );
a5971 1

d6149 3
d6155 4
a6158 4
    FT_F26Dot6  org_a, org_b, org_x,
                cur_a, cur_b, cur_x,
                distance;
    FT_UShort   point;
d6169 6
a6174 4
    /* XXX: There are some glyphs in some braindead but popular  */
    /*      fonts out there (e.g. [aeu]grave in monotype.ttf)    */
    /*      calling IP[] with bad values of rp[12].              */
    /*      Do something sane when this odd thing happens.       */
d6176 18
d6197 2
a6198 2
      org_a = cur_a = 0;
      org_b = cur_b = 0;
d6202 6
a6207 2
      org_a = CUR_Func_dualproj( CUR.zp0.org + CUR.GS.rp1, NULL_Vector );
      org_b = CUR_Func_dualproj( CUR.zp1.org + CUR.GS.rp2, NULL_Vector );
d6209 1
a6209 2
      cur_a = CUR_Func_project( CUR.zp0.cur + CUR.GS.rp1, NULL_Vector );
      cur_b = CUR_Func_project( CUR.zp1.cur + CUR.GS.rp2, NULL_Vector );
d6212 1
a6212 1
    while ( CUR.GS.loop > 0 )
d6214 3
a6216 1
      CUR.args--;
d6218 1
a6218 1
      point = (FT_UShort)CUR.stack[CUR.args];
d6226 1
d6228 3
d6232 1
a6232 3
      {
        org_x = CUR_Func_dualproj( CUR.zp2.org + point, NULL_Vector );
        cur_x = CUR_Func_project ( CUR.zp2.cur + point, NULL_Vector );
d6234 1
a6234 2
        if ( ( org_a <= org_b && org_x <= org_a ) ||
             ( org_a >  org_b && org_x >= org_a ) )
d6236 6
a6241 4
          distance = ( cur_a - org_a ) + ( org_x - cur_x );

        else if ( ( org_a <= org_b  &&  org_x >= org_b ) ||
                  ( org_a >  org_b  &&  org_x <  org_b ) )
d6243 1
a6243 14
          distance = ( cur_b - org_b ) + ( org_x - cur_x );

        else
           /* note: it seems that rounding this value isn't a good */
           /*       idea (cf. width of capital `S' in Times)       */

           distance = TT_MULDIV( cur_b - cur_a,
                                 org_x - org_a,
                                 org_b - org_a ) + ( cur_a - cur_x );

        CUR_Func_move( &CUR.zp2, point, distance );
      }

      CUR.GS.loop--;
a6244 1

d6285 1
a6285 1
  struct  LOC_Ins_IUP
d6289 4
a6292 1
  };
d6296 4
a6299 4
  Shift( FT_UInt              p1,
         FT_UInt              p2,
         FT_UInt              p,
         struct LOC_Ins_IUP*  LINK )
d6302 1
a6302 1
    FT_F26Dot6  x;
d6305 5
a6309 1
    x = LINK->curs[p].x - LINK->orgs[p].x;
d6311 3
a6313 5
    for ( i = p1; i < p; i++ )
      LINK->curs[i].x += x;

    for ( i = p + 1; i <= p2; i++ )
      LINK->curs[i].x += x;
d6318 5
a6322 5
  Interp( FT_UInt              p1,
          FT_UInt              p2,
          FT_UInt              ref1,
          FT_UInt              ref2,
          struct LOC_Ins_IUP*  LINK )
d6325 1
a6325 1
    FT_F26Dot6  x, x1, x2, d1, d2;
d6331 6
a6336 4
    x1 = LINK->orgs[ref1].x;
    d1 = LINK->curs[ref1].x - LINK->orgs[ref1].x;
    x2 = LINK->orgs[ref2].x;
    d2 = LINK->curs[ref2].x - LINK->orgs[ref2].x;
d6338 1
a6338 1
    if ( x1 == x2 )
d6340 3
a6342 3
      for ( i = p1; i <= p2; i++ )
      {
        x = LINK->orgs[i].x;
d6344 3
a6346 4
        if ( x <= x1 )
          x += d1;
        else
          x += d2;
d6348 3
a6350 3
        LINK->curs[i].x = x;
      }
      return;
d6353 6
a6358 1
    if ( x1 < x2 )
d6360 1
d6363 1
a6363 1
        x = LINK->orgs[i].x;
d6365 3
a6367 2
        if ( x <= x1 )
          x += d1;
d6369 3
a6371 10
        {
          if ( x >= x2 )
            x += d2;
          else
            x = LINK->curs[ref1].x +
                  TT_MULDIV( x - x1,
                             LINK->curs[ref2].x - LINK->curs[ref1].x,
                             x2 - x1 );
        }
        LINK->curs[i].x = x;
a6372 1
      return;
d6374 4
a6378 1
    /* x2 < x1 */
d6380 2
a6381 6
    for ( i = p1; i <= p2; i++ )
    {
      x = LINK->orgs[i].x;
      if ( x <= x2 )
        x += d2;
      else
d6383 9
a6391 2
        if ( x >= x1 )
          x += d1;
d6393 12
a6404 4
          x = LINK->curs[ref1].x +
              TT_MULDIV( x - x1,
                         LINK->curs[ref2].x - LINK->curs[ref1].x,
                         x2 - x1 );
a6405 1
      LINK->curs[i].x = x;
d6419 2
a6420 2
    struct LOC_Ins_IUP  V;
    FT_Byte             mask;
d6434 4
d6443 1
d6450 1
d6452 1
d6459 1
a6459 1
      end_point   = CUR.pts.contours[contour];
d6462 4
a6465 1
      while ( point <= end_point && (CUR.pts.tags[point] & mask) == 0 )
d6480 5
a6484 5
              Interp( cur_touched + 1,
                      point - 1,
                      cur_touched,
                      point,
                      &V );
d6492 1
a6492 1
          Shift( first_point, end_point, cur_touched, &V );
d6495 5
a6499 5
          Interp( (FT_UShort)( cur_touched + 1 ),
                  end_point,
                  cur_touched,
                  first_touched,
                  &V );
d6502 5
a6506 5
            Interp( first_point,
                    first_touched - 1,
                    cur_touched,
                    first_touched,
                    &V );
d6528 1
d6532 4
a6535 2
      {
      FT_Long n = args[0] * 2;
d6736 1
a6736 1
      K |= (1 << 12);
d7084 1
a7084 1
  /*  On exit whith TRUE, test IP < CodeSize to know wether it comes from  */
d7834 1
a7834 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d30 1
a30 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d51 1
a51 1
  /* limited to a maximal number of opcodes defined below.                 */
d138 1
a138 1
  /* increase readability of the code.                                     */
d161 3
d170 3
a209 13
#define CUR_Func_project( v1, v2 )  \
          CUR.func_project( EXEC_ARG_ (v1)->x - (v2)->x, (v1)->y - (v2)->y )

#define CUR_Func_dualproj( v1, v2 )  \
          CUR.func_dualproj( EXEC_ARG_ (v1)->x - (v2)->x, (v1)->y - (v2)->y )

#define CUR_fast_project( v ) \
          CUR.func_project( EXEC_ARG_ (v)->x, (v)->y )

#define CUR_fast_dualproj( v ) \
          CUR.func_dualproj( EXEC_ARG_ (v)->x, (v)->y )


d508 1
a508 1
              void*      _pbuff,
a511 1
    void**    pbuff = (void**)_pbuff;
d516 1
a516 1
      if ( FT_REALLOC( *pbuff, *size * multiplier, new_max * multiplier ) )
d597 1
a597 1
                        (void*)&exec->stack,
d607 1
a607 1
                        (void*)&exec->glyphIns,
a615 4
    exec->zp1 = exec->pts;
    exec->zp2 = exec->pts;
    exec->zp0 = exec->pts;

d1122 2
a1123 1
#undef PACK
a1124 1
#if 1
d1126 1
a1126 25
  static FT_Int32
  TT_MulFix14( FT_Int32  a,
               FT_Int    b )
  {
    FT_Int32   sign;
    FT_UInt32  ah, al, mid, lo, hi;


    sign = a ^ b;

    if ( a < 0 )
      a = -a;
    if ( b < 0 )
      b = -b;

    ah = (FT_UInt32)( ( a >> 16 ) & 0xFFFFU );
    al = (FT_UInt32)( a & 0xFFFFU );

    lo    = al * b;
    mid   = ah * b;
    hi    = mid >> 16;
    mid   = ( mid << 16 ) + ( 1 << 13 ); /* rounding */
    lo   += mid;
    if ( lo < mid )
      hi += 1;
a1127 1
    mid = ( lo >> 14 ) | ( hi << 18 );
d1129 2
a1130 2
    return sign >= 0 ? (FT_Int32)mid : -(FT_Int32)mid;
  }
a1131 1
#else
d1156 1
a1156 1
    hi += l < lo;
a1159 1
#endif
d1848 1
a1850 1

d2119 1
a2119 1
    if ( ( selector & 0x0F ) == 0 )
d2147 2
a2148 2
  Project( EXEC_OP_ FT_Pos  dx,
                    FT_Pos  dy )
d2154 2
a2155 1
    return TT_DotFix14( dx, dy,
a2159 1

d2177 2
a2178 2
  Dual_Project( EXEC_OP_ FT_Pos  dx,
                         FT_Pos  dy )
d2180 2
a2181 1
    return TT_DotFix14( dx, dy,
d2204 2
a2205 2
  Project_x( EXEC_OP_ FT_Pos  dx,
                      FT_Pos  dy )
a2207 1
    FT_UNUSED( dy );
d2209 1
a2209 1
    return dx;
d2230 2
a2231 2
  Project_y( EXEC_OP_ FT_Pos  dx,
                      FT_Pos  dy )
a2233 1
    FT_UNUSED( dx );
d2235 1
a2235 1
    return dy;
d2766 6
a2771 6
    /* XXX: UNDOCUMENTED! or bug in the Windows engine?   */
    /*                                                    */
    /*      It seems that the value that is read here is  */
    /*      expressed in 16.16 format rather than in font */
    /*      units.                                        */
    /*                                                    */
d4316 1
a4316 1
    /* NOTE: If the last instruction of a program is a   */
d4616 1
a4616 1
    L = (FT_UShort)( CUR.opcode - 0xB0 + 1 );
d4641 1
a4641 1
    L = (FT_UShort)( CUR.opcode - 0xB8 + 1 );
d4698 1
a4698 1
        R = CUR_fast_dualproj( &CUR.zp2.org[L] );
d4700 1
a4700 1
        R = CUR_fast_project( &CUR.zp2.cur[L] );
d4733 1
a4733 1
    K = CUR_fast_project( &CUR.zp2.cur[L] );
d5037 1
a5037 1
    if ( ( args[0] & 0x100 ) != 0 && CUR.metrics.pointSize <= A )
d5041 1
a5041 1
    if ( ( args[0] & 0x200 ) != 0 && CUR.tt_metrics.rotated )
d5044 1
a5044 1
    if ( ( args[0] & 0x400 ) != 0 && CUR.tt_metrics.stretched )
d5048 1
a5048 1
    if ( ( args[0] & 0x800 ) != 0 && CUR.metrics.pointSize > A )
d5052 1
a5052 1
    if ( ( args[0] & 0x1000 ) != 0 && CUR.tt_metrics.rotated )
d5055 1
a5055 1
    if ( ( args[0] & 0x2000 ) != 0 && CUR.tt_metrics.stretched )
a5217 1
      *refp = 0;
d5382 1
a5382 2
      first_point = (FT_UShort)( CUR.pts.contours[contour - 1] + 1 -
                                 CUR.pts.first_point );
d5384 1
a5384 2
    last_point = (FT_UShort)( CUR.pts.contours[contour] -
                              CUR.pts.first_point );
d5396 1
a5396 1
    /* XXX: UNDOCUMENTED! SHC touches the points */
d5432 2
a5433 8
    /* XXX: UNDOCUMENTED! SHZ doesn't move the phantom points.  */
    /*      Twilight zone has no contours, so use `n_points'.   */
    /*      Normal zone's `n_points' includes phantoms, so must */
    /*      use end of last contour.                            */
    if ( CUR.GS.gep2 == 0 && CUR.zp2.n_points > 0 )
      last_point = (FT_UShort)( CUR.zp2.n_points - 1 );
    else if ( CUR.GS.gep2 == 1 && CUR.zp2.n_contours > 0 )
      last_point = (FT_UShort)( CUR.zp2.contours[CUR.zp2.n_contours - 1] );
d5551 1
a5551 1
    if ( ( CUR.opcode & 1 ) != 0 )
d5583 1
a5583 1
      cur_dist = CUR_fast_project( &CUR.zp0.cur[point] );
d5623 1
a5623 1
    /* XXX: UNDOCUMENTED!                                */
d5628 1
a5628 1
    /* First, no control value cut-in test is performed  */
d5654 1
a5654 1
    org_dist = CUR_fast_project( &CUR.zp0.cur[point] );
d5697 2
a5698 1
    /* XXX: UNDOCUMENTED: twilight zone special case */
d5700 1
a5700 33
    if ( CUR.GS.gep0 == 0 || CUR.GS.gep1 == 0 )
    {
      FT_Vector*  vec1 = &CUR.zp1.org[point];
      FT_Vector*  vec2 = &CUR.zp0.org[CUR.GS.rp0];


      org_dist = CUR_Func_dualproj( vec1, vec2 );
    }
    else
    {
      FT_Vector*  vec1 = &CUR.zp1.orus[point];
      FT_Vector*  vec2 = &CUR.zp0.orus[CUR.GS.rp0];


      if ( CUR.metrics.x_scale == CUR.metrics.y_scale )
      {
        /* this should be faster */
        org_dist = CUR_Func_dualproj( vec1, vec2 );
        org_dist = TT_MULFIX( org_dist, CUR.metrics.x_scale );
      }
      else
      {
        FT_Vector  vec;


        vec.x = TT_MULFIX( vec1->x - vec2->x, CUR.metrics.x_scale );
        vec.y = TT_MULFIX( vec1->y - vec2->y, CUR.metrics.y_scale );

        org_dist = CUR_fast_dualproj( &vec );
      }
    }

    /* single width cut-in test */
d5811 1
a5811 1
      CUR.zp1.cur[point] = CUR.zp0.cur[point];
d5814 5
a5818 4
    org_dist = CUR_Func_dualproj( &CUR.zp1.org[point],
                                  &CUR.zp0.org[CUR.GS.rp0] );
    cur_dist = CUR_Func_project ( &CUR.zp1.cur[point],
                                  &CUR.zp0.cur[CUR.GS.rp0] );
d5872 1
a6049 3

  /* SOMETIMES, DUMBER CODE IS BETTER CODE */

d6053 4
a6056 4
    FT_F26Dot6  old_range, cur_range;
    FT_Vector*  orus_base;
    FT_Vector*  cur_base;
    FT_Int      twilight;
d6067 4
a6070 13
    /*
     * We need to deal in a special way with the twilight zone.
     * Otherwise, by definition, the value of CUR.twilight.orus[n] is (0,0),
     * for every n.
     */
    twilight = CUR.GS.gep0 == 0 || CUR.GS.gep1 == 0 || CUR.GS.gep2 == 0;

    if ( BOUNDS( CUR.GS.rp1, CUR.zp0.n_points ) )
    {
      if ( CUR.pedantic_hinting )
        CUR.error = TT_Err_Invalid_Reference;
      return;
    }
a6071 11
    if ( twilight )
      orus_base = &CUR.zp0.org[CUR.GS.rp1];
    else
      orus_base = &CUR.zp0.orus[CUR.GS.rp1];

    cur_base = &CUR.zp0.cur[CUR.GS.rp1];

    /* XXX: There are some glyphs in some braindead but popular */
    /*      fonts out there (e.g. [aeu]grave in monotype.ttf)   */
    /*      calling IP[] with bad values of rp[12].             */
    /*      Do something sane when this odd thing happens.      */
d6075 2
a6076 2
      old_range = 0;
      cur_range = 0;
d6080 2
a6081 6
      if ( twilight )
        old_range = CUR_Func_dualproj( &CUR.zp1.org[CUR.GS.rp2],
                                       orus_base );
      else
        old_range = CUR_Func_dualproj( &CUR.zp1.orus[CUR.GS.rp2],
                                       orus_base );
d6083 2
a6084 1
      cur_range = CUR_Func_project ( &CUR.zp1.cur[CUR.GS.rp2], cur_base );
d6087 1
a6087 1
    for ( ; CUR.GS.loop > 0; --CUR.GS.loop )
d6089 1
a6089 2
      FT_UInt     point = (FT_UInt)CUR.stack[--CUR.args];
      FT_F26Dot6  org_dist, cur_dist, new_dist;
d6091 1
a6091 2

      /* check point bounds */
a6098 1
        continue;
d6100 18
d6119 3
a6121 4
      if ( twilight )
        org_dist = CUR_Func_dualproj( &CUR.zp2.org[point], orus_base );
      else
        org_dist = CUR_Func_dualproj( &CUR.zp2.orus[point], orus_base );
d6123 2
a6124 4
      cur_dist = CUR_Func_project ( &CUR.zp2.cur[point], cur_base );
      new_dist = ( old_range != 0 )
                   ? TT_MULDIV( org_dist, cur_range, old_range )
                   : cur_dist;
d6126 1
a6126 1
      CUR_Func_move( &CUR.zp2, (FT_UShort)point, new_dist - cur_dist );
d6128 1
d6169 1
a6169 1
  typedef struct
d6173 1
a6173 4
    FT_Vector*  orus;
    FT_UInt     max_points;

  } IUP_WorkerRec, *IUP_Worker;
d6177 4
a6180 4
  _iup_worker_shift( IUP_Worker  worker,
                     FT_UInt     p1,
                     FT_UInt     p2,
                     FT_UInt     p )
d6183 1
a6183 1
    FT_F26Dot6  dx;
d6186 4
a6189 5
    dx = worker->curs[p].x - worker->orgs[p].x;
    if ( dx != 0 )
    {
      for ( i = p1; i < p; i++ )
        worker->curs[i].x += dx;
d6191 2
a6192 3
      for ( i = p + 1; i <= p2; i++ )
        worker->curs[i].x += dx;
    }
d6197 5
a6201 5
  _iup_worker_interpolate( IUP_Worker  worker,
                           FT_UInt     p1,
                           FT_UInt     p2,
                           FT_UInt     ref1,
                           FT_UInt     ref2 )
d6204 1
a6204 1
    FT_F26Dot6  orus1, orus2, org1, org2, delta1, delta2;
d6210 4
a6213 6
    if ( BOUNDS( ref1, worker->max_points ) ||
         BOUNDS( ref2, worker->max_points ) )
      return;

    orus1 = worker->orus[ref1].x;
    orus2 = worker->orus[ref2].x;
d6215 1
a6215 1
    if ( orus1 > orus2 )
d6217 3
a6219 2
      FT_F26Dot6  tmp_o;
      FT_UInt     tmp_r;
d6221 4
d6226 3
a6228 7
      tmp_o = orus1;
      orus1 = orus2;
      orus2 = tmp_o;

      tmp_r = ref1;
      ref1  = ref2;
      ref2  = tmp_r;
d6231 1
a6231 6
    org1   = worker->orgs[ref1].x;
    org2   = worker->orgs[ref2].x;
    delta1 = worker->curs[ref1].x - org1;
    delta2 = worker->curs[ref2].x - org2;

    if ( orus1 == orus2 )
a6232 1
      /* simple shift of untouched points */
d6235 1
a6235 2
        FT_F26Dot6  x = worker->orgs[i].x;

d6237 2
a6238 2
        if ( x <= org1 )
          x += delta1;
d6240 10
a6249 3
          x += delta2;

        worker->curs[i].x = x;
d6251 1
a6252 4
    else
    {
      FT_Fixed  scale       = 0;
      FT_Bool   scale_valid = 0;
d6254 1
d6256 6
a6261 2
      /* interpolation */
      for ( i = p1; i <= p2; i++ )
d6263 2
a6264 9
        FT_F26Dot6  x = worker->orgs[i].x;


        if ( x <= org1 )
          x += delta1;

        else if ( x >= org2 )
          x += delta2;

d6266 4
a6269 12
        {
          if ( !scale_valid )
          {
            scale_valid = 1;
            scale       = TT_MULDIV( org2 + delta2 - ( org1 + delta1 ),
                                     0x10000, orus2 - orus1 );
          }

          x = ( org1 + delta1 ) +
              TT_MULFIX( worker->orus[i].x - orus1, scale );
        }
        worker->curs[i].x = x;
d6271 1
d6285 2
a6286 2
    IUP_WorkerRec  V;
    FT_Byte        mask;
a6299 4
    /* ignore empty outlines */
    if ( CUR.pts.n_contours == 0 )
      return;

a6304 1
      V.orus = CUR.pts.orus;
a6310 1
      V.orus = (FT_Vector*)( (FT_Pos*)CUR.pts.orus + 1 );
a6311 1
    V.max_points = CUR.pts.n_points;
d6318 1
a6318 1
      end_point   = CUR.pts.contours[contour] - CUR.pts.first_point;
d6321 1
a6321 1
      while ( point <= end_point && ( CUR.pts.tags[point] & mask ) == 0 )
d6336 5
a6340 5
              _iup_worker_interpolate( &V,
                                       cur_touched + 1,
                                       point - 1,
                                       cur_touched,
                                       point );
d6348 1
a6348 1
          _iup_worker_shift( &V, first_point, end_point, cur_touched );
d6351 5
a6355 5
          _iup_worker_interpolate( &V,
                                   (FT_UShort)( cur_touched + 1 ),
                                   end_point,
                                   cur_touched,
                                   first_touched );
d6358 5
a6362 5
            _iup_worker_interpolate( &V,
                                     first_point,
                                     first_touched - 1,
                                     cur_touched,
                                     first_touched );
a6383 1

d6387 2
a6388 4
    {
      FT_Long  n = args[0] * 2;


d6589 1
a6589 1
      K |= 1 << 12;
d6937 1
a6937 1
  /*  On exit with TRUE, test IP < CodeSize to know whether it comes from  */
d7687 1
a7687 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
@

