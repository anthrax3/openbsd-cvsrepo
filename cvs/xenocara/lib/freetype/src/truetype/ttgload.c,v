head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.2
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.20.0.2
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.2
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.2
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.2
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2017.01.13.11.20.00;	author dcoppa;	state Exp;
branches;
next	1.25;
commitid	ESXG9TuEmwmBXggf;

1.25
date	2016.10.28.21.41.15;	author dcoppa;	state Exp;
branches;
next	1.24;
commitid	T2hf37tVZU8TmjB1;

1.24
date	2016.08.09.07.16.10;	author dcoppa;	state Exp;
branches;
next	1.23;
commitid	C8TgUUJolulx9B5d;

1.23
date	2016.05.29.11.57.14;	author dcoppa;	state Exp;
branches;
next	1.22;
commitid	1dOLexdOAzW2mQjp;

1.22
date	2015.12.07.09.34.04;	author dcoppa;	state Exp;
branches;
next	1.21;
commitid	wZOPiDmcwgRFTDVL;

1.21
date	2015.10.19.07.51.38;	author dcoppa;	state Exp;
branches;
next	1.20;
commitid	d2XmJCtYff11VIDu;

1.20
date	2015.06.28.08.27.50;	author dcoppa;	state Exp;
branches;
next	1.19;
commitid	qXwIGV2h9uFjxAmt;

1.19
date	2014.12.26.17.52.36;	author dcoppa;	state Exp;
branches;
next	1.18;
commitid	gwhRExMduYqoPQHI;

1.18
date	2014.03.14.08.18.02;	author dcoppa;	state Exp;
branches;
next	1.17;

1.17
date	2014.01.12.15.08.28;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2013.10.10.19.49.59;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.07.17.21.11;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2013.01.04.16.51.59;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2012.07.07.16.45.04;	author dcoppa;	state Exp;
branches;
next	1.12;

1.12
date	2012.04.14.09.45.47;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.18.20.29.59;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.23.19.30.17;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.01.19.14.25;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.25.20.49.55;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.03.10.20.28.35;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.21.05.09.10;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.08.16.59.03;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.08.16.39.54;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.25.01.23.29;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.59;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.59;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.32.08;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ttgload.c                                                              */
/*                                                                         */
/*    TrueType Glyph Loader (body).                                        */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_CALC_H
#include FT_INTERNAL_STREAM_H
#include FT_INTERNAL_SFNT_H
#include FT_TRUETYPE_TAGS_H
#include FT_OUTLINE_H
#include FT_TRUETYPE_DRIVER_H
#include FT_LIST_H

#include "ttgload.h"
#include "ttpload.h"

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#include "ttgxvar.h"
#endif

#include "tterrors.h"
#include "ttsubpix.h"


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_ttgload


  /*************************************************************************/
  /*                                                                       */
  /* Composite glyph flags.                                                */
  /*                                                                       */
#define ARGS_ARE_WORDS             0x0001
#define ARGS_ARE_XY_VALUES         0x0002
#define ROUND_XY_TO_GRID           0x0004
#define WE_HAVE_A_SCALE            0x0008
/* reserved                        0x0010 */
#define MORE_COMPONENTS            0x0020
#define WE_HAVE_AN_XY_SCALE        0x0040
#define WE_HAVE_A_2X2              0x0080
#define WE_HAVE_INSTR              0x0100
#define USE_MY_METRICS             0x0200
#define OVERLAP_COMPOUND           0x0400
#define SCALED_COMPONENT_OFFSET    0x0800
#define UNSCALED_COMPONENT_OFFSET  0x1000


  /*************************************************************************/
  /*                                                                       */
  /* Return the horizontal metrics in font units for a given glyph.        */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  TT_Get_HMetrics( TT_Face     face,
                   FT_UInt     idx,
                   FT_Short*   lsb,
                   FT_UShort*  aw )
  {
    ( (SFNT_Service)face->sfnt )->get_metrics( face, 0, idx, lsb, aw );

    FT_TRACE5(( "  advance width (font units): %d\n", *aw ));
    FT_TRACE5(( "  left side bearing (font units): %d\n", *lsb ));
  }


  /*************************************************************************/
  /*                                                                       */
  /* Return the vertical metrics in font units for a given glyph.          */
  /* See macro `TT_LOADER_SET_PP' below for explanations.                  */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  TT_Get_VMetrics( TT_Face     face,
                   FT_UInt     idx,
                   FT_Pos      yMax,
                   FT_Short*   tsb,
                   FT_UShort*  ah )
  {
    if ( face->vertical_info )
      ( (SFNT_Service)face->sfnt )->get_metrics( face, 1, idx, tsb, ah );

    else if ( face->os2.version != 0xFFFFU )
    {
      *tsb = (FT_Short)( face->os2.sTypoAscender - yMax );
      *ah  = (FT_UShort)FT_ABS( face->os2.sTypoAscender -
                                face->os2.sTypoDescender );
    }

    else
    {
      *tsb = (FT_Short)( face->horizontal.Ascender - yMax );
      *ah  = (FT_UShort)FT_ABS( face->horizontal.Ascender -
                                face->horizontal.Descender );
    }

    FT_TRACE5(( "  advance height (font units): %d\n", *ah ));
    FT_TRACE5(( "  top side bearing (font units): %d\n", *tsb ));
  }


  static FT_Error
  tt_get_metrics( TT_Loader  loader,
                  FT_UInt    glyph_index )
  {
    TT_Face    face   = loader->face;
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
#endif

    FT_Error   error;
    FT_Stream  stream = loader->stream;

    FT_Short   left_bearing = 0, top_bearing = 0;
    FT_UShort  advance_width = 0, advance_height = 0;

    /* we must preserve the stream position          */
    /* (which gets altered by the metrics functions) */
    FT_ULong  pos = FT_STREAM_POS();


    TT_Get_HMetrics( face, glyph_index,
                     &left_bearing,
                     &advance_width );
    TT_Get_VMetrics( face, glyph_index,
                     loader->bbox.yMax,
                     &top_bearing,
                     &advance_height );

    if ( FT_STREAM_SEEK( pos ) )
      return error;

    loader->left_bearing = left_bearing;
    loader->advance      = advance_width;
    loader->top_bearing  = top_bearing;
    loader->vadvance     = advance_height;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 &&
         loader->exec                                             )
    {
      loader->exec->sph_tweak_flags = 0;

      /* This may not be the right place for this, but it works...  */
      /* Note that we have to unconditionally load the tweaks since */
      /* it is possible that glyphs individually switch ClearType's */
      /* backwards compatibility mode on and off.                   */
      sph_set_tweaks( loader, glyph_index );
    }
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    if ( !loader->linear_def )
    {
      loader->linear_def = 1;
      loader->linear     = advance_width;
    }

    return FT_Err_Ok;
  }


#ifdef FT_CONFIG_OPTION_INCREMENTAL

  static void
  tt_get_metrics_incr_overrides( TT_Loader  loader,
                                 FT_UInt    glyph_index )
  {
    TT_Face  face = loader->face;

    FT_Short   left_bearing = 0, top_bearing = 0;
    FT_UShort  advance_width = 0, advance_height = 0;


    /* If this is an incrementally loaded font check whether there are */
    /* overriding metrics for this glyph.                              */
    if ( face->root.internal->incremental_interface                           &&
         face->root.internal->incremental_interface->funcs->get_glyph_metrics )
    {
      FT_Incremental_MetricsRec  metrics;
      FT_Error                   error;


      metrics.bearing_x = loader->left_bearing;
      metrics.bearing_y = 0;
      metrics.advance   = loader->advance;
      metrics.advance_v = 0;

      error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                face->root.internal->incremental_interface->object,
                glyph_index, FALSE, &metrics );
      if ( error )
        goto Exit;

      left_bearing  = (FT_Short)metrics.bearing_x;
      advance_width = (FT_UShort)metrics.advance;

#if 0

      /* GWW: Do I do the same for vertical metrics? */
      metrics.bearing_x = 0;
      metrics.bearing_y = loader->top_bearing;
      metrics.advance   = loader->vadvance;

      error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                face->root.internal->incremental_interface->object,
                glyph_index, TRUE, &metrics );
      if ( error )
        goto Exit;

      top_bearing    = (FT_Short)metrics.bearing_y;
      advance_height = (FT_UShort)metrics.advance;

#endif /* 0 */

      loader->left_bearing = left_bearing;
      loader->advance      = advance_width;
      loader->top_bearing  = top_bearing;
      loader->vadvance     = advance_height;

      if ( !loader->linear_def )
      {
        loader->linear_def = 1;
        loader->linear     = advance_width;
      }
    }

  Exit:
    return;
  }

#endif /* FT_CONFIG_OPTION_INCREMENTAL */


  /*************************************************************************/
  /*                                                                       */
  /* The following functions are used by default with TrueType fonts.      */
  /* However, they can be replaced by alternatives if we need to support   */
  /* TrueType-compressed formats (like MicroType) in the future.           */
  /*                                                                       */
  /*************************************************************************/

  FT_CALLBACK_DEF( FT_Error )
  TT_Access_Glyph_Frame( TT_Loader  loader,
                         FT_UInt    glyph_index,
                         FT_ULong   offset,
                         FT_UInt    byte_count )
  {
    FT_Error   error;
    FT_Stream  stream = loader->stream;

    /* for non-debug mode */
    FT_UNUSED( glyph_index );


    FT_TRACE4(( "Glyph %ld\n", glyph_index ));

    /* the following line sets the `error' variable through macros! */
    if ( FT_STREAM_SEEK( offset ) || FT_FRAME_ENTER( byte_count ) )
      return error;

    loader->cursor = stream->cursor;
    loader->limit  = stream->limit;

    return FT_Err_Ok;
  }


  FT_CALLBACK_DEF( void )
  TT_Forget_Glyph_Frame( TT_Loader  loader )
  {
    FT_Stream  stream = loader->stream;


    FT_FRAME_EXIT();
  }


  FT_CALLBACK_DEF( FT_Error )
  TT_Load_Glyph_Header( TT_Loader  loader )
  {
    FT_Byte*  p     = loader->cursor;
    FT_Byte*  limit = loader->limit;


    if ( p + 10 > limit )
      return FT_THROW( Invalid_Outline );

    loader->n_contours = FT_NEXT_SHORT( p );

    loader->bbox.xMin = FT_NEXT_SHORT( p );
    loader->bbox.yMin = FT_NEXT_SHORT( p );
    loader->bbox.xMax = FT_NEXT_SHORT( p );
    loader->bbox.yMax = FT_NEXT_SHORT( p );

    FT_TRACE5(( "  # of contours: %d\n", loader->n_contours ));
    FT_TRACE5(( "  xMin: %4d  xMax: %4d\n", loader->bbox.xMin,
                                            loader->bbox.xMax ));
    FT_TRACE5(( "  yMin: %4d  yMax: %4d\n", loader->bbox.yMin,
                                            loader->bbox.yMax ));
    loader->cursor = p;

    return FT_Err_Ok;
  }


  FT_CALLBACK_DEF( FT_Error )
  TT_Load_Simple_Glyph( TT_Loader  load )
  {
    FT_Error        error;
    FT_Byte*        p          = load->cursor;
    FT_Byte*        limit      = load->limit;
    FT_GlyphLoader  gloader    = load->gloader;
    FT_Int          n_contours = load->n_contours;
    FT_Outline*     outline;
    FT_UShort       n_ins;
    FT_Int          n_points;
    FT_ULong        tmp;

    FT_Byte         *flag, *flag_limit;
    FT_Byte         c, count;
    FT_Vector       *vec, *vec_limit;
    FT_Pos          x;
    FT_Short        *cont, *cont_limit, prev_cont;
    FT_Int          xy_size = 0;


    /* check that we can add the contours to the glyph */
    error = FT_GLYPHLOADER_CHECK_POINTS( gloader, 0, n_contours );
    if ( error )
      goto Fail;

    /* reading the contours' endpoints & number of points */
    cont       = gloader->current.outline.contours;
    cont_limit = cont + n_contours;

    /* check space for contours array + instructions count */
    if ( n_contours >= 0xFFF || p + ( n_contours + 1 ) * 2 > limit )
      goto Invalid_Outline;

    prev_cont = FT_NEXT_SHORT( p );

    if ( n_contours > 0 )
      cont[0] = prev_cont;

    if ( prev_cont < 0 )
      goto Invalid_Outline;

    for ( cont++; cont < cont_limit; cont++ )
    {
      cont[0] = FT_NEXT_SHORT( p );
      if ( cont[0] <= prev_cont )
      {
        /* unordered contours: this is invalid */
        goto Invalid_Outline;
      }
      prev_cont = cont[0];
    }

    n_points = 0;
    if ( n_contours > 0 )
    {
      n_points = cont[-1] + 1;
      if ( n_points < 0 )
        goto Invalid_Outline;
    }

    /* note that we will add four phantom points later */
    error = FT_GLYPHLOADER_CHECK_POINTS( gloader, n_points + 4, 0 );
    if ( error )
      goto Fail;

    /* reading the bytecode instructions */
    load->glyph->control_len  = 0;
    load->glyph->control_data = NULL;

    if ( p + 2 > limit )
      goto Invalid_Outline;

    n_ins = FT_NEXT_USHORT( p );

    FT_TRACE5(( "  Instructions size: %u\n", n_ins ));

    /* check it */
    if ( ( limit - p ) < n_ins )
    {
      FT_TRACE0(( "TT_Load_Simple_Glyph: instruction count mismatch\n" ));
      error = FT_THROW( Too_Many_Hints );
      goto Fail;
    }

#ifdef TT_USE_BYTECODE_INTERPRETER

    if ( IS_HINTED( load->load_flags ) )
    {
      /* we don't trust `maxSizeOfInstructions' in the `maxp' table */
      /* and thus update the bytecode array size by ourselves       */

      tmp   = load->exec->glyphSize;
      error = Update_Max( load->exec->memory,
                          &tmp,
                          sizeof ( FT_Byte ),
                          (void*)&load->exec->glyphIns,
                          n_ins );

      load->exec->glyphSize = (FT_UShort)tmp;
      if ( error )
        return error;

      load->glyph->control_len  = n_ins;
      load->glyph->control_data = load->exec->glyphIns;

      if ( n_ins )
        FT_MEM_COPY( load->exec->glyphIns, p, (FT_Long)n_ins );
    }

#endif /* TT_USE_BYTECODE_INTERPRETER */

    p += n_ins;

    outline = &gloader->current.outline;

    /* reading the point tags */
    flag       = (FT_Byte*)outline->tags;
    flag_limit = flag + n_points;

    FT_ASSERT( flag );

    while ( flag < flag_limit )
    {
      if ( p + 1 > limit )
        goto Invalid_Outline;

      *flag++ = c = FT_NEXT_BYTE( p );
      if ( c & 8 )
      {
        if ( p + 1 > limit )
          goto Invalid_Outline;

        count = FT_NEXT_BYTE( p );
        if ( flag + (FT_Int)count > flag_limit )
          goto Invalid_Outline;

        for ( ; count > 0; count-- )
          *flag++ = c;
      }
    }

    /* reading the X coordinates */

    vec       = outline->points;
    vec_limit = vec + n_points;
    flag      = (FT_Byte*)outline->tags;
    x         = 0;

    if ( p + xy_size > limit )
      goto Invalid_Outline;

    for ( ; vec < vec_limit; vec++, flag++ )
    {
      FT_Pos   y = 0;
      FT_Byte  f = *flag;


      if ( f & 2 )
      {
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_BYTE( p );
        if ( ( f & 16 ) == 0 )
          y = -y;
      }
      else if ( ( f & 16 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_SHORT( p );
      }

      x     += y;
      vec->x = x;
      /* the cast is for stupid compilers */
      *flag  = (FT_Byte)( f & ~( 2 | 16 ) );
    }

    /* reading the Y coordinates */

    vec       = gloader->current.outline.points;
    vec_limit = vec + n_points;
    flag      = (FT_Byte*)outline->tags;
    x         = 0;

    for ( ; vec < vec_limit; vec++, flag++ )
    {
      FT_Pos   y = 0;
      FT_Byte  f = *flag;


      if ( f & 4 )
      {
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_BYTE( p );
        if ( ( f & 32 ) == 0 )
          y = -y;
      }
      else if ( ( f & 32 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_SHORT( p );
      }

      x     += y;
      vec->y = x;
      /* the cast is for stupid compilers */
      *flag  = (FT_Byte)( f & FT_CURVE_TAG_ON );
    }

    outline->n_points   = (FT_Short)n_points;
    outline->n_contours = (FT_Short)n_contours;

    load->cursor = p;

  Fail:
    return error;

  Invalid_Outline:
    error = FT_THROW( Invalid_Outline );
    goto Fail;
  }


  FT_CALLBACK_DEF( FT_Error )
  TT_Load_Composite_Glyph( TT_Loader  loader )
  {
    FT_Error        error;
    FT_Byte*        p       = loader->cursor;
    FT_Byte*        limit   = loader->limit;
    FT_GlyphLoader  gloader = loader->gloader;
    FT_SubGlyph     subglyph;
    FT_UInt         num_subglyphs;


    num_subglyphs = 0;

    do
    {
      FT_Fixed  xx, xy, yy, yx;
      FT_UInt   count;


      /* check that we can load a new subglyph */
      error = FT_GlyphLoader_CheckSubGlyphs( gloader, num_subglyphs + 1 );
      if ( error )
        goto Fail;

      /* check space */
      if ( p + 4 > limit )
        goto Invalid_Composite;

      subglyph = gloader->current.subglyphs + num_subglyphs;

      subglyph->arg1 = subglyph->arg2 = 0;

      subglyph->flags = FT_NEXT_USHORT( p );
      subglyph->index = FT_NEXT_USHORT( p );

      /* check space */
      count = 2;
      if ( subglyph->flags & ARGS_ARE_WORDS )
        count += 2;
      if ( subglyph->flags & WE_HAVE_A_SCALE )
        count += 2;
      else if ( subglyph->flags & WE_HAVE_AN_XY_SCALE )
        count += 4;
      else if ( subglyph->flags & WE_HAVE_A_2X2 )
        count += 8;

      if ( p + count > limit )
        goto Invalid_Composite;

      /* read arguments */
      if ( subglyph->flags & ARGS_ARE_XY_VALUES )
      {
        if ( subglyph->flags & ARGS_ARE_WORDS )
        {
          subglyph->arg1 = FT_NEXT_SHORT( p );
          subglyph->arg2 = FT_NEXT_SHORT( p );
        }
        else
        {
          subglyph->arg1 = FT_NEXT_CHAR( p );
          subglyph->arg2 = FT_NEXT_CHAR( p );
        }
      }
      else
      {
        if ( subglyph->flags & ARGS_ARE_WORDS )
        {
          subglyph->arg1 = (FT_Int)FT_NEXT_USHORT( p );
          subglyph->arg2 = (FT_Int)FT_NEXT_USHORT( p );
        }
        else
        {
          subglyph->arg1 = (FT_Int)FT_NEXT_BYTE( p );
          subglyph->arg2 = (FT_Int)FT_NEXT_BYTE( p );
        }
      }

      /* read transform */
      xx = yy = 0x10000L;
      xy = yx = 0;

      if ( subglyph->flags & WE_HAVE_A_SCALE )
      {
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        yy = xx;
      }
      else if ( subglyph->flags & WE_HAVE_AN_XY_SCALE )
      {
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
      }
      else if ( subglyph->flags & WE_HAVE_A_2X2 )
      {
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        yx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        xy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
      }

      subglyph->transform.xx = xx;
      subglyph->transform.xy = xy;
      subglyph->transform.yx = yx;
      subglyph->transform.yy = yy;

      num_subglyphs++;

    } while ( subglyph->flags & MORE_COMPONENTS );

    gloader->current.num_subglyphs = num_subglyphs;
    FT_TRACE5(( "  %d components\n", num_subglyphs ));

#ifdef TT_USE_BYTECODE_INTERPRETER

    {
      FT_Stream  stream = loader->stream;


      /* we must undo the FT_FRAME_ENTER in order to point */
      /* to the composite instructions, if we find some.   */
      /* We will process them later.                       */
      /*                                                   */
      loader->ins_pos = (FT_ULong)( FT_STREAM_POS() +
                                    p - limit );
    }

#endif

    loader->cursor = p;

  Fail:
    return error;

  Invalid_Composite:
    error = FT_THROW( Invalid_Composite );
    goto Fail;
  }


  FT_LOCAL_DEF( void )
  TT_Init_Glyph_Loading( TT_Face  face )
  {
    face->access_glyph_frame   = TT_Access_Glyph_Frame;
    face->read_glyph_header    = TT_Load_Glyph_Header;
    face->read_simple_glyph    = TT_Load_Simple_Glyph;
    face->read_composite_glyph = TT_Load_Composite_Glyph;
    face->forget_glyph_frame   = TT_Forget_Glyph_Frame;
  }


  static void
  tt_prepare_zone( TT_GlyphZone  zone,
                   FT_GlyphLoad  load,
                   FT_UInt       start_point,
                   FT_UInt       start_contour )
  {
    zone->n_points    = (FT_UShort)load->outline.n_points -
                          (FT_UShort)start_point;
    zone->n_contours  = load->outline.n_contours -
                          (FT_Short)start_contour;
    zone->org         = load->extra_points + start_point;
    zone->cur         = load->outline.points + start_point;
    zone->orus        = load->extra_points2 + start_point;
    zone->tags        = (FT_Byte*)load->outline.tags + start_point;
    zone->contours    = (FT_UShort*)load->outline.contours + start_contour;
    zone->first_point = (FT_UShort)start_point;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Hint_Glyph                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Hint the glyph using the zone prepared by the caller.  Note that   */
  /*    the zone is supposed to include four phantom points.               */
  /*                                                                       */
  static FT_Error
  TT_Hint_Glyph( TT_Loader  loader,
                 FT_Bool    is_composite )
  {
#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    TT_Face    face   = loader->face;
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
#endif

    TT_GlyphZone  zone = &loader->zone;

#ifdef TT_USE_BYTECODE_INTERPRETER
    FT_Long       n_ins;
#else
    FT_UNUSED( is_composite );
#endif


#ifdef TT_USE_BYTECODE_INTERPRETER
    if ( loader->glyph->control_len > 0xFFFFL )
    {
      FT_TRACE1(( "TT_Hint_Glyph: too long instructions" ));
      FT_TRACE1(( " (0x%lx byte) is truncated\n",
                 loader->glyph->control_len ));
    }
    n_ins = loader->glyph->control_len;

    /* save original point position in org */
    if ( n_ins > 0 )
      FT_ARRAY_COPY( zone->org, zone->cur, zone->n_points );

    /* Reset graphics state. */
    loader->exec->GS = loader->size->GS;

    /* XXX: UNDOCUMENTED! Hinting instructions of a composite glyph */
    /*      completely refer to the (already) hinted subglyphs.     */
    if ( is_composite )
    {
      loader->exec->metrics.x_scale = 1 << 16;
      loader->exec->metrics.y_scale = 1 << 16;

      FT_ARRAY_COPY( zone->orus, zone->cur, zone->n_points );
    }
    else
    {
      loader->exec->metrics.x_scale = loader->size->metrics.x_scale;
      loader->exec->metrics.y_scale = loader->size->metrics.y_scale;
    }
#endif

    /* round phantom points */
    zone->cur[zone->n_points - 4].x =
      FT_PIX_ROUND( zone->cur[zone->n_points - 4].x );
    zone->cur[zone->n_points - 3].x =
      FT_PIX_ROUND( zone->cur[zone->n_points - 3].x );
    zone->cur[zone->n_points - 2].y =
      FT_PIX_ROUND( zone->cur[zone->n_points - 2].y );
    zone->cur[zone->n_points - 1].y =
      FT_PIX_ROUND( zone->cur[zone->n_points - 1].y );

#ifdef TT_USE_BYTECODE_INTERPRETER

    if ( n_ins > 0 )
    {
      FT_Error  error;

      FT_GlyphLoader  gloader         = loader->gloader;
      FT_Outline      current_outline = gloader->current.outline;


      TT_Set_CodeRange( loader->exec, tt_coderange_glyph,
                        loader->exec->glyphIns, n_ins );

      loader->exec->is_composite = is_composite;
      loader->exec->pts          = *zone;

      error = TT_Run_Context( loader->exec );
      if ( error && loader->exec->pedantic_hinting )
        return error;

      /* store drop-out mode in bits 5-7; set bit 2 also as a marker */
      current_outline.tags[0] |=
        ( loader->exec->GS.scan_type << 5 ) | FT_CURVE_TAG_HAS_SCANMODE;
    }

#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    /* Save possibly modified glyph phantom points unless in v40 backwards */
    /* compatibility mode, where no movement on the x axis means no reason */
    /* to change bearings or advance widths.                               */
    if ( !( driver->interpreter_version == TT_INTERPRETER_VERSION_40 &&
            !loader->exec->backwards_compatibility ) )
    {
#endif
      loader->pp1 = zone->cur[zone->n_points - 4];
      loader->pp2 = zone->cur[zone->n_points - 3];
      loader->pp3 = zone->cur[zone->n_points - 2];
      loader->pp4 = zone->cur[zone->n_points - 1];
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    }
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
    {
      if ( loader->exec->sph_tweak_flags & SPH_TWEAK_DEEMBOLDEN )
        FT_Outline_EmboldenXY( &loader->gloader->current.outline, -24, 0 );

      else if ( loader->exec->sph_tweak_flags & SPH_TWEAK_EMBOLDEN )
        FT_Outline_EmboldenXY( &loader->gloader->current.outline, 24, 0 );
    }
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Process_Simple_Glyph                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Once a simple glyph has been loaded, it needs to be processed.     */
  /*    Usually, this means scaling and hinting through bytecode           */
  /*    interpretation.                                                    */
  /*                                                                       */
  static FT_Error
  TT_Process_Simple_Glyph( TT_Loader  loader )
  {
    FT_GlyphLoader  gloader = loader->gloader;
    FT_Error        error   = FT_Err_Ok;
    FT_Outline*     outline;
    FT_Int          n_points;


    outline  = &gloader->current.outline;
    n_points = outline->n_points;

    /* set phantom points */

    outline->points[n_points    ] = loader->pp1;
    outline->points[n_points + 1] = loader->pp2;
    outline->points[n_points + 2] = loader->pp3;
    outline->points[n_points + 3] = loader->pp4;

    outline->tags[n_points    ] = 0;
    outline->tags[n_points + 1] = 0;
    outline->tags[n_points + 2] = 0;
    outline->tags[n_points + 3] = 0;

    n_points += 4;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT

    if ( loader->face->doblend && !loader->face->is_default_instance )
    {
      /* Deltas apply to the unscaled data. */
      error = TT_Vary_Apply_Glyph_Deltas( loader->face,
                                          loader->glyph_index,
                                          outline,
                                          (FT_UInt)n_points );

      /* recalculate linear horizontal and vertical advances */
      /* if we don't have HVAR and VVAR, respectively        */
      if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
        loader->linear = outline->points[n_points - 3].x -
                         outline->points[n_points - 4].x;
      if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
        loader->vadvance = outline->points[n_points - 1].x -
                           outline->points[n_points - 2].x;

      if ( error )
        return error;
    }

#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */

    if ( IS_HINTED( loader->load_flags ) )
    {
      tt_prepare_zone( &loader->zone, &gloader->current, 0, 0 );

      FT_ARRAY_COPY( loader->zone.orus, loader->zone.cur,
                     loader->zone.n_points + 4 );
    }

    {
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      TT_Face    face   = loader->face;
      TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );

      FT_String*  family         = face->root.family_name;
      FT_UInt     ppem           = loader->size->metrics.x_ppem;
      FT_String*  style          = face->root.style_name;
      FT_UInt     x_scale_factor = 1000;
#endif

      FT_Vector*  vec   = outline->points;
      FT_Vector*  limit = outline->points + n_points;

      FT_Fixed  x_scale = 0; /* pacify compiler */
      FT_Fixed  y_scale = 0;

      FT_Bool  do_scale = FALSE;


#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
      {
        /* scale, but only if enabled and only if TT hinting is being used */
        if ( IS_HINTED( loader->load_flags ) )
          x_scale_factor = sph_test_tweak_x_scaling( face,
                                                     family,
                                                     ppem,
                                                     style,
                                                     loader->glyph_index );
        /* scale the glyph */
        if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 ||
             x_scale_factor != 1000                         )
        {
          x_scale = FT_MulDiv( loader->size->metrics.x_scale,
                               (FT_Long)x_scale_factor, 1000 );
          y_scale = loader->size->metrics.y_scale;

          /* compensate for any scaling by de/emboldening; */
          /* the amount was determined via experimentation */
          if ( x_scale_factor != 1000 && ppem > 11 )
            FT_Outline_EmboldenXY( outline,
                                   FT_MulFix( 1280 * ppem,
                                              1000 - x_scale_factor ),
                                   0 );
          do_scale = TRUE;
        }
      }
      else

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      {
        /* scale the glyph */
        if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
        {
          x_scale = loader->size->metrics.x_scale;
          y_scale = loader->size->metrics.y_scale;

          do_scale = TRUE;
        }
      }

      if ( do_scale )
      {
        for ( ; vec < limit; vec++ )
        {
          vec->x = FT_MulFix( vec->x, x_scale );
          vec->y = FT_MulFix( vec->y, y_scale );
        }

        loader->pp1 = outline->points[n_points - 4];
        loader->pp2 = outline->points[n_points - 3];
        loader->pp3 = outline->points[n_points - 2];
        loader->pp4 = outline->points[n_points - 1];
      }
    }

    if ( IS_HINTED( loader->load_flags ) )
    {
      loader->zone.n_points += 4;

      error = TT_Hint_Glyph( loader, 0 );
    }

    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Process_Composite_Component                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Once a composite component has been loaded, it needs to be         */
  /*    processed.  Usually, this means transforming and translating.      */
  /*                                                                       */
  static FT_Error
  TT_Process_Composite_Component( TT_Loader    loader,
                                  FT_SubGlyph  subglyph,
                                  FT_UInt      start_point,
                                  FT_UInt      num_base_points )
  {
    FT_GlyphLoader  gloader = loader->gloader;
    FT_Outline      current;
    FT_Bool         have_scale;
    FT_Pos          x, y;


    current.points   = gloader->base.outline.points +
                         num_base_points;
    current.n_points = gloader->base.outline.n_points -
                         (short)num_base_points;

    have_scale = FT_BOOL( subglyph->flags & ( WE_HAVE_A_SCALE     |
                                              WE_HAVE_AN_XY_SCALE |
                                              WE_HAVE_A_2X2       ) );

    /* perform the transform required for this subglyph */
    if ( have_scale )
      FT_Outline_Transform( &current, &subglyph->transform );

    /* get offset */
    if ( !( subglyph->flags & ARGS_ARE_XY_VALUES ) )
    {
      FT_UInt     num_points = (FT_UInt)gloader->base.outline.n_points;
      FT_UInt     k = (FT_UInt)subglyph->arg1;
      FT_UInt     l = (FT_UInt)subglyph->arg2;
      FT_Vector*  p1;
      FT_Vector*  p2;


      /* match l-th point of the newly loaded component to the k-th point */
      /* of the previously loaded components.                             */

      /* change to the point numbers used by our outline */
      k += start_point;
      l += num_base_points;
      if ( k >= num_base_points ||
           l >= num_points      )
        return FT_THROW( Invalid_Composite );

      p1 = gloader->base.outline.points + k;
      p2 = gloader->base.outline.points + l;

      x = p1->x - p2->x;
      y = p1->y - p2->y;
    }
    else
    {
      x = subglyph->arg1;
      y = subglyph->arg2;

      if ( !x && !y )
        return FT_Err_Ok;

      /* Use a default value dependent on                                  */
      /* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old */
      /* TT fonts which don't set the xxx_COMPONENT_OFFSET bit.            */

      if ( have_scale &&
#ifdef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
           !( subglyph->flags & UNSCALED_COMPONENT_OFFSET ) )
#else
            ( subglyph->flags & SCALED_COMPONENT_OFFSET ) )
#endif
      {

#if 0

        /*******************************************************************/
        /*                                                                 */
        /* This algorithm is what Apple documents.  But it doesn't work.   */
        /*                                                                 */
        int  a = subglyph->transform.xx > 0 ?  subglyph->transform.xx
                                            : -subglyph->transform.xx;
        int  b = subglyph->transform.yx > 0 ?  subglyph->transform.yx
                                            : -subglyph->transform.yx;
        int  c = subglyph->transform.xy > 0 ?  subglyph->transform.xy
                                            : -subglyph->transform.xy;
        int  d = subglyph->transform.yy > 0 ?  subglyph->transform.yy
                                            : -subglyph->transform.yy;
        int  m = a > b ? a : b;
        int  n = c > d ? c : d;


        if ( a - b <= 33 && a - b >= -33 )
          m *= 2;
        if ( c - d <= 33 && c - d >= -33 )
          n *= 2;
        x = FT_MulFix( x, m );
        y = FT_MulFix( y, n );

#else /* 1 */

        /*******************************************************************/
        /*                                                                 */
        /* This algorithm is a guess and works much better than the above. */
        /*                                                                 */
        FT_Fixed  mac_xscale = FT_Hypot( subglyph->transform.xx,
                                         subglyph->transform.xy );
        FT_Fixed  mac_yscale = FT_Hypot( subglyph->transform.yy,
                                         subglyph->transform.yx );


        x = FT_MulFix( x, mac_xscale );
        y = FT_MulFix( y, mac_yscale );

#endif /* 1 */

      }

      if ( !( loader->load_flags & FT_LOAD_NO_SCALE ) )
      {
        FT_Fixed  x_scale = loader->size->metrics.x_scale;
        FT_Fixed  y_scale = loader->size->metrics.y_scale;


        x = FT_MulFix( x, x_scale );
        y = FT_MulFix( y, y_scale );

        if ( subglyph->flags & ROUND_XY_TO_GRID )
        {
          x = FT_PIX_ROUND( x );
          y = FT_PIX_ROUND( y );
        }
      }
    }

    if ( x || y )
      FT_Outline_Translate( &current, x, y );

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Process_Composite_Glyph                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This is slightly different from TT_Process_Simple_Glyph, in that   */
  /*    its sole purpose is to hint the glyph.  Thus this function is      */
  /*    only available when bytecode interpreter is enabled.               */
  /*                                                                       */
  static FT_Error
  TT_Process_Composite_Glyph( TT_Loader  loader,
                              FT_UInt    start_point,
                              FT_UInt    start_contour )
  {
    FT_Error     error;
    FT_Outline*  outline;
    FT_UInt      i;


    outline = &loader->gloader->base.outline;

    /* make room for phantom points */
    error = FT_GLYPHLOADER_CHECK_POINTS( loader->gloader,
                                         outline->n_points + 4,
                                         0 );
    if ( error )
      return error;

    outline->points[outline->n_points    ] = loader->pp1;
    outline->points[outline->n_points + 1] = loader->pp2;
    outline->points[outline->n_points + 2] = loader->pp3;
    outline->points[outline->n_points + 3] = loader->pp4;

    outline->tags[outline->n_points    ] = 0;
    outline->tags[outline->n_points + 1] = 0;
    outline->tags[outline->n_points + 2] = 0;
    outline->tags[outline->n_points + 3] = 0;

#ifdef TT_USE_BYTECODE_INTERPRETER

    {
      FT_Stream  stream = loader->stream;
      FT_UShort  n_ins, max_ins;
      FT_ULong   tmp;


      /* TT_Load_Composite_Glyph only gives us the offset of instructions */
      /* so we read them here                                             */
      if ( FT_STREAM_SEEK( loader->ins_pos ) ||
           FT_READ_USHORT( n_ins )           )
        return error;

      FT_TRACE5(( "  Instructions size = %d\n", n_ins ));

      /* check it */
      max_ins = loader->face->max_profile.maxSizeOfInstructions;
      if ( n_ins > max_ins )
      {
        /* don't trust `maxSizeOfInstructions'; */
        /* only do a rough safety check         */
        if ( (FT_Int)n_ins > loader->byte_len )
        {
          FT_TRACE1(( "TT_Process_Composite_Glyph:"
                      " too many instructions (%d) for glyph with length %d\n",
                      n_ins, loader->byte_len ));
          return FT_THROW( Too_Many_Hints );
        }

        tmp   = loader->exec->glyphSize;
        error = Update_Max( loader->exec->memory,
                            &tmp,
                            sizeof ( FT_Byte ),
                            (void*)&loader->exec->glyphIns,
                            n_ins );

        loader->exec->glyphSize = (FT_UShort)tmp;
        if ( error )
          return error;
      }
      else if ( n_ins == 0 )
        return FT_Err_Ok;

      if ( FT_STREAM_READ( loader->exec->glyphIns, n_ins ) )
        return error;

      loader->glyph->control_data = loader->exec->glyphIns;
      loader->glyph->control_len  = n_ins;
    }

#endif

    tt_prepare_zone( &loader->zone, &loader->gloader->base,
                     start_point, start_contour );

    /* Some points are likely touched during execution of  */
    /* instructions on components.  So let's untouch them. */
    for ( i = 0; i < loader->zone.n_points; i++ )
      loader->zone.tags[i] &= ~FT_CURVE_TAG_TOUCH_BOTH;

    loader->zone.n_points += 4;

    return TT_Hint_Glyph( loader, 1 );
  }


  /*
   * Calculate the phantom points
   *
   * Defining the right side bearing (rsb) as
   *
   *   rsb = aw - (lsb + xmax - xmin)
   *
   * (with `aw' the advance width, `lsb' the left side bearing, and `xmin'
   * and `xmax' the glyph's minimum and maximum x value), the OpenType
   * specification defines the initial position of horizontal phantom points
   * as
   *
   *   pp1 = (round(xmin - lsb), 0)      ,
   *   pp2 = (round(pp1 + aw), 0)        .
   *
   * Note that the rounding to the grid (in the device space) is not
   * documented currently in the specification.
   *
   * However, the specification lacks the precise definition of vertical
   * phantom points.  Greg Hitchcock provided the following explanation.
   *
   * - a `vmtx' table is present
   *
   *   For any glyph, the minimum and maximum y values (`ymin' and `ymax')
   *   are given in the `glyf' table, the top side bearing (tsb) and advance
   *   height (ah) are given in the `vmtx' table.  The bottom side bearing
   *   (bsb) is then calculated as
   *
   *     bsb = ah - (tsb + ymax - ymin)       ,
   *
   *   and the initial position of vertical phantom points is
   *
   *     pp3 = (x, round(ymax + tsb))       ,
   *     pp4 = (x, round(pp3 - ah))         .
   *
   *   See below for value `x'.
   *
   * - no `vmtx' table in the font
   *
   *   If there is an `OS/2' table, we set
   *
   *     DefaultAscender = sTypoAscender       ,
   *     DefaultDescender = sTypoDescender     ,
   *
   *   otherwise we use data from the `hhea' table:
   *
   *     DefaultAscender = Ascender         ,
   *     DefaultDescender = Descender       .
   *
   *   With these two variables we can now set
   *
   *     ah = DefaultAscender - sDefaultDescender    ,
   *     tsb = DefaultAscender - yMax                ,
   *
   *   and proceed as if a `vmtx' table was present.
   *
   * Usually we have
   *
   *   x = aw / 2      ,                                                (1)
   *
   * but there is one compatibility case where it can be set to
   *
   *   x = -DefaultDescender -
   *         ((DefaultAscender - DefaultDescender - aw) / 2)     .      (2)
   *
   * and another one with
   *
   *   x = 0     .                                                      (3)
   *
   * In Windows, the history of those values is quite complicated,
   * depending on the hinting engine (that is, the graphics framework).
   *
   *   framework        from                 to       formula
   *  ----------------------------------------------------------
   *    GDI       Windows 98               current      (1)
   *              (Windows 2000 for NT)
   *    GDI+      Windows XP               Windows 7    (2)
   *    GDI+      Windows 8                current      (3)
   *    DWrite    Windows 7                current      (3)
   *
   * For simplicity, FreeType uses (1) for grayscale subpixel hinting and
   * (3) for everything else.
   *
   */
  static void
  tt_loader_set_pp( TT_Loader  loader )
  {
    FT_Bool  subpixel_hinting = 0;
    FT_Bool  grayscale        = 0;
    FT_Bool  use_aw_2         = 0;

#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    TT_Driver driver = (TT_Driver)FT_FACE_DRIVER( loader->face );
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
    {
      subpixel_hinting = loader->exec ? loader->exec->subpixel_hinting
                                      : 0;
      grayscale        = loader->exec ? loader->exec->grayscale
                                      : 0;
    }
#endif
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
    {
      subpixel_hinting = loader->exec ? loader->exec->subpixel_hinting_lean
                                      : 0;
      grayscale        = loader->exec ? loader->exec->grayscale_cleartype
                                      : 0;
    }
#endif

    use_aw_2 = (FT_Bool)( subpixel_hinting && grayscale );

    loader->pp1.x = loader->bbox.xMin - loader->left_bearing;
    loader->pp1.y = 0;
    loader->pp2.x = loader->pp1.x + loader->advance;
    loader->pp2.y = 0;

    loader->pp3.x = use_aw_2 ? loader->advance / 2 : 0;
    loader->pp3.y = loader->bbox.yMax + loader->top_bearing;
    loader->pp4.x = use_aw_2 ? loader->advance / 2 : 0;
    loader->pp4.y = loader->pp3.y - loader->vadvance;
  }


  /* a utility function to retrieve i-th node from given FT_List */
  static FT_ListNode
  ft_list_get_node_at( FT_List  list,
                       FT_UInt  index )
  {
    FT_ListNode  cur;


    if ( !list )
      return NULL;

    for ( cur = list->head; cur; cur = cur->next )
    {
      if ( !index )
        return cur;

      index--;
    }

    return NULL;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    load_truetype_glyph                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads a given truetype glyph.  Handles composites and uses a       */
  /*    TT_Loader object.                                                  */
  /*                                                                       */
  static FT_Error
  load_truetype_glyph( TT_Loader  loader,
                       FT_UInt    glyph_index,
                       FT_UInt    recurse_count,
                       FT_Bool    header_only )
  {
    FT_Error        error        = FT_Err_Ok;
    FT_Fixed        x_scale, y_scale;
    FT_ULong        offset;
    TT_Face         face         = loader->face;
    FT_GlyphLoader  gloader      = loader->gloader;
    FT_Bool         opened_frame = 0;

#ifdef FT_CONFIG_OPTION_INCREMENTAL
    FT_StreamRec    inc_stream;
    FT_Data         glyph_data;
    FT_Bool         glyph_data_loaded = 0;
#endif


#ifdef FT_DEBUG_LEVEL_TRACE
    if ( recurse_count )
      FT_TRACE5(( "  nesting level: %d\n", recurse_count ));
#endif

    /* some fonts have an incorrect value of `maxComponentDepth' */
    if ( recurse_count > face->max_profile.maxComponentDepth )
    {
      FT_TRACE1(( "load_truetype_glyph: maxComponentDepth set to %d\n",
                  recurse_count ));
      face->max_profile.maxComponentDepth = (FT_UShort)recurse_count;
    }

#ifndef FT_CONFIG_OPTION_INCREMENTAL
    /* check glyph index */
    if ( glyph_index >= (FT_UInt)face->root.num_glyphs )
    {
      error = FT_THROW( Invalid_Glyph_Index );
      goto Exit;
    }
#endif

    loader->glyph_index = glyph_index;

    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
    {
      x_scale = loader->size->metrics.x_scale;
      y_scale = loader->size->metrics.y_scale;
    }
    else
    {
      x_scale = 0x10000L;
      y_scale = 0x10000L;
    }

    /* Set `offset' to the start of the glyph relative to the start of */
    /* the `glyf' table, and `byte_len' to the length of the glyph in  */
    /* bytes.                                                          */

#ifdef FT_CONFIG_OPTION_INCREMENTAL

    /* If we are loading glyph data via the incremental interface, set */
    /* the loader stream to a memory stream reading the data returned  */
    /* by the interface.                                               */
    if ( face->root.internal->incremental_interface )
    {
      error = face->root.internal->incremental_interface->funcs->get_glyph_data(
                face->root.internal->incremental_interface->object,
                glyph_index, &glyph_data );
      if ( error )
        goto Exit;

      glyph_data_loaded = 1;
      offset            = 0;
      loader->byte_len  = glyph_data.length;

      FT_ZERO( &inc_stream );
      FT_Stream_OpenMemory( &inc_stream,
                            glyph_data.pointer,
                            (FT_ULong)glyph_data.length );

      loader->stream = &inc_stream;
    }
    else

#endif /* FT_CONFIG_OPTION_INCREMENTAL */

      offset = tt_face_get_location( face, glyph_index,
                                     (FT_UInt*)&loader->byte_len );

    if ( loader->byte_len > 0 )
    {
#ifdef FT_CONFIG_OPTION_INCREMENTAL
      /* for the incremental interface, `glyf_offset' is always zero */
      if ( !face->glyf_offset                          &&
           !face->root.internal->incremental_interface )
#else
      if ( !face->glyf_offset )
#endif /* FT_CONFIG_OPTION_INCREMENTAL */
      {
        FT_TRACE2(( "no `glyf' table but non-zero `loca' entry\n" ));
        error = FT_THROW( Invalid_Table );
        goto Exit;
      }

      error = face->access_glyph_frame( loader, glyph_index,
                                        face->glyf_offset + offset,
                                        (FT_UInt)loader->byte_len );
      if ( error )
        goto Exit;

      opened_frame = 1;

      /* read glyph header first */
      error = face->read_glyph_header( loader );
      if ( error )
        goto Exit;

      /* the metrics must be computed after loading the glyph header */
      /* since we need the glyph's `yMax' value in case the vertical */
      /* metrics must be emulated                                    */
      error = tt_get_metrics( loader, glyph_index );
      if ( error )
        goto Exit;

      if ( header_only )
        goto Exit;
    }

    if ( loader->byte_len == 0 || loader->n_contours == 0 )
    {
      loader->bbox.xMin = 0;
      loader->bbox.xMax = 0;
      loader->bbox.yMin = 0;
      loader->bbox.yMax = 0;

      error = tt_get_metrics( loader, glyph_index );
      if ( error )
        goto Exit;

      if ( header_only )
        goto Exit;

      /* must initialize points before (possibly) overriding */
      /* glyph metrics from the incremental interface        */
      tt_loader_set_pp( loader );

#ifdef FT_CONFIG_OPTION_INCREMENTAL
      tt_get_metrics_incr_overrides( loader, glyph_index );
#endif

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT

      if ( loader->face->doblend && !loader->face->is_default_instance )
      {
        /* a small outline structure with four elements for */
        /* communication with `TT_Vary_Apply_Glyph_Deltas'  */
        FT_Vector   points[4];
        char        tags[4]     = { 1, 1, 1, 1 };
        short       contours[4] = { 0, 1, 2, 3 };
        FT_Outline  outline;


        points[0].x = loader->pp1.x;
        points[0].y = loader->pp1.y;
        points[1].x = loader->pp2.x;
        points[1].y = loader->pp2.y;

        points[2].x = loader->pp3.x;
        points[2].y = loader->pp3.y;
        points[3].x = loader->pp4.x;
        points[3].y = loader->pp4.y;

        outline.n_points   = 4;
        outline.n_contours = 4;
        outline.points     = points;
        outline.tags       = tags;
        outline.contours   = contours;

        /* this must be done before scaling */
        error = TT_Vary_Apply_Glyph_Deltas( loader->face,
                                            glyph_index,
                                            &outline,
                                            (FT_UInt)outline.n_points );
        if ( error )
          goto Exit;

        loader->pp1.x = points[0].x;
        loader->pp1.y = points[0].y;
        loader->pp2.x = points[1].x;
        loader->pp2.y = points[1].y;

        loader->pp3.x = points[2].x;
        loader->pp3.y = points[2].y;
        loader->pp4.x = points[3].x;
        loader->pp4.y = points[3].y;


        /* recalculate linear horizontal and vertical advances */
        /* if we don't have HVAR and VVAR, respectively        */
        if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
          loader->linear = loader->pp2.x - loader->pp1.x;
        if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
          loader->vadvance = loader->pp4.x - loader->pp3.x;
      }

#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */

      /* scale phantom points, if necessary; */
      /* they get rounded in `TT_Hint_Glyph' */
      if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
      {
        loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
        loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
        /* pp1.y and pp2.y are always zero */

        loader->pp3.x = FT_MulFix( loader->pp3.x, x_scale );
        loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
        loader->pp4.x = FT_MulFix( loader->pp4.x, x_scale );
        loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
      }

      error = FT_Err_Ok;
      goto Exit;
    }

    /* must initialize phantom points before (possibly) overriding */
    /* glyph metrics from the incremental interface                */
    tt_loader_set_pp( loader );

#ifdef FT_CONFIG_OPTION_INCREMENTAL
    tt_get_metrics_incr_overrides( loader, glyph_index );
#endif

    /***********************************************************************/
    /***********************************************************************/
    /***********************************************************************/

    /* if it is a simple glyph, load it */

    if ( loader->n_contours > 0 )
    {
      error = face->read_simple_glyph( loader );
      if ( error )
        goto Exit;

      /* all data have been read */
      face->forget_glyph_frame( loader );
      opened_frame = 0;

      error = TT_Process_Simple_Glyph( loader );
      if ( error )
        goto Exit;

      FT_GlyphLoader_Add( gloader );
    }

    /***********************************************************************/
    /***********************************************************************/
    /***********************************************************************/

    /* otherwise, load a composite! */
    else if ( loader->n_contours == -1 )
    {
      FT_Memory  memory = face->root.memory;

      FT_UInt   start_point;
      FT_UInt   start_contour;
      FT_ULong  ins_pos;  /* position of composite instructions, if any */

      FT_ListNode  node, node2;


      /*
       * We store the glyph index directly in the `node->data' pointer,
       * following the glib solution (cf. macro `GUINT_TO_POINTER') with a
       * double cast to make this portable.  Note, however, that this needs
       * pointers with a width of at least 32 bits.
       */


      /* clear the nodes filled by sibling chains */
      node = ft_list_get_node_at( &loader->composites, recurse_count );
      for ( node2 = node; node2; node2 = node2->next )
        node2->data = (void*)ULONG_MAX;

      /* check whether we already have a composite glyph with this index */
      if ( FT_List_Find( &loader->composites,
                         (void*)(unsigned long)glyph_index ) )
      {
        FT_TRACE1(( "TT_Load_Composite_Glyph:"
                    " infinite recursion detected\n" ));
        error = FT_THROW( Invalid_Composite );
        goto Exit;
      }

      else if ( node )
        node->data = (void*)(unsigned long)glyph_index;

      else
      {
        if ( FT_NEW( node ) )
          goto Exit;
        node->data = (void*)(unsigned long)glyph_index;
        FT_List_Add( &loader->composites, node );
      }

      start_point   = (FT_UInt)gloader->base.outline.n_points;
      start_contour = (FT_UInt)gloader->base.outline.n_contours;

      /* for each subglyph, read composite header */
      error = face->read_composite_glyph( loader );
      if ( error )
        goto Exit;

      /* store the offset of instructions */
      ins_pos = loader->ins_pos;

      /* all data we need are read */
      face->forget_glyph_frame( loader );
      opened_frame = 0;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT

      if ( face->doblend && !face->is_default_instance )
      {
        short        i, limit;
        FT_SubGlyph  subglyph;

        FT_Outline  outline;
        FT_Vector*  points   = NULL;
        char*       tags     = NULL;
        short*      contours = NULL;


        limit = (short)gloader->current.num_subglyphs;

        /* construct an outline structure for              */
        /* communication with `TT_Vary_Apply_Glyph_Deltas' */
        outline.n_points   = (short)( gloader->current.num_subglyphs + 4 );
        outline.n_contours = outline.n_points;

        outline.points   = NULL;
        outline.tags     = NULL;
        outline.contours = NULL;

        if ( FT_NEW_ARRAY( points, outline.n_points )   ||
             FT_NEW_ARRAY( tags, outline.n_points )     ||
             FT_NEW_ARRAY( contours, outline.n_points ) )
          goto Exit1;

        subglyph = gloader->current.subglyphs;

        for ( i = 0; i < limit; i++, subglyph++ )
        {
          /* applying deltas for anchor points doesn't make sense, */
          /* but we don't have to specially check this since       */
          /* unused delta values are zero anyways                  */
          points[i].x = subglyph->arg1;
          points[i].y = subglyph->arg2;
          tags[i]     = 1;
          contours[i] = i;
        }

        points[i].x = loader->pp1.x;
        points[i].y = loader->pp1.y;
        tags[i]     = 1;
        contours[i] = i;

        i++;
        points[i].x = loader->pp2.x;
        points[i].y = loader->pp2.y;
        tags[i]     = 1;
        contours[i] = i;

        i++;
        points[i].x = loader->pp3.x;
        points[i].y = loader->pp3.y;
        tags[i]     = 1;
        contours[i] = i;

        i++;
        points[i].x = loader->pp4.x;
        points[i].y = loader->pp4.y;
        tags[i]     = 1;
        contours[i] = i;

        outline.points   = points;
        outline.tags     = tags;
        outline.contours = contours;

        /* this call provides additional offsets */
        /* for each component's translation      */
        if ( FT_SET_ERROR( TT_Vary_Apply_Glyph_Deltas(
                             face,
                             glyph_index,
                             &outline,
                             (FT_UInt)outline.n_points ) ) )
          goto Exit1;

        subglyph = gloader->current.subglyphs;

        for ( i = 0; i < limit; i++, subglyph++ )
        {
          if ( subglyph->flags & ARGS_ARE_XY_VALUES )
          {
            subglyph->arg1 = (FT_Int16)points[i].x;
            subglyph->arg2 = (FT_Int16)points[i].y;
          }
        }

        loader->pp1.x = points[i + 0].x;
        loader->pp1.y = points[i + 0].y;
        loader->pp2.x = points[i + 1].x;
        loader->pp2.y = points[i + 1].y;

        loader->pp3.x = points[i + 2].x;
        loader->pp3.y = points[i + 2].y;
        loader->pp4.x = points[i + 3].x;
        loader->pp4.y = points[i + 3].y;

        /* recalculate linear horizontal and vertical advances */
        /* if we don't have HVAR and VVAR, respectively        */
        if ( !( face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
          loader->linear = loader->pp2.x - loader->pp1.x;
        if ( !( face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
          loader->vadvance = loader->pp4.x - loader->pp3.x;

      Exit1:
        FT_FREE( outline.points );
        FT_FREE( outline.tags );
        FT_FREE( outline.contours );

        if ( error )
          goto Exit;
      }

#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */

      /* scale phantom points, if necessary; */
      /* they get rounded in `TT_Hint_Glyph' */
      if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
      {
        loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
        loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
        /* pp1.y and pp2.y are always zero */

        loader->pp3.x = FT_MulFix( loader->pp3.x, x_scale );
        loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
        loader->pp4.x = FT_MulFix( loader->pp4.x, x_scale );
        loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
      }

      /* if the flag FT_LOAD_NO_RECURSE is set, we return the subglyph */
      /* `as is' in the glyph slot (the client application will be     */
      /* responsible for interpreting these data)...                   */
      if ( loader->load_flags & FT_LOAD_NO_RECURSE )
      {
        FT_GlyphLoader_Add( gloader );
        loader->glyph->format = FT_GLYPH_FORMAT_COMPOSITE;

        goto Exit;
      }

      /*********************************************************************/
      /*********************************************************************/
      /*********************************************************************/

      {
        FT_UInt      n, num_base_points;
        FT_SubGlyph  subglyph       = NULL;

        FT_UInt      num_points     = start_point;
        FT_UInt      num_subglyphs  = gloader->current.num_subglyphs;
        FT_UInt      num_base_subgs = gloader->base.num_subglyphs;

        FT_Stream    old_stream     = loader->stream;
        FT_Int       old_byte_len   = loader->byte_len;


        FT_GlyphLoader_Add( gloader );

        /* read each subglyph independently */
        for ( n = 0; n < num_subglyphs; n++ )
        {
          FT_Vector  pp[4];

          FT_Int  linear_hadvance;
          FT_Int  linear_vadvance;


          /* Each time we call load_truetype_glyph in this loop, the   */
          /* value of `gloader.base.subglyphs' can change due to table */
          /* reallocations.  We thus need to recompute the subglyph    */
          /* pointer on each iteration.                                */
          subglyph = gloader->base.subglyphs + num_base_subgs + n;

          pp[0] = loader->pp1;
          pp[1] = loader->pp2;
          pp[2] = loader->pp3;
          pp[3] = loader->pp4;

          linear_hadvance = loader->linear;
          linear_vadvance = loader->vadvance;

          num_base_points = (FT_UInt)gloader->base.outline.n_points;

          error = load_truetype_glyph( loader,
                                       (FT_UInt)subglyph->index,
                                       recurse_count + 1,
                                       FALSE );
          if ( error )
            goto Exit;

          /* restore subglyph pointer */
          subglyph = gloader->base.subglyphs + num_base_subgs + n;

          /* restore phantom points if necessary */
          if ( !( subglyph->flags & USE_MY_METRICS ) )
          {
            loader->pp1 = pp[0];
            loader->pp2 = pp[1];
            loader->pp3 = pp[2];
            loader->pp4 = pp[3];

            loader->linear   = linear_hadvance;
            loader->vadvance = linear_vadvance;
          }

          num_points = (FT_UInt)gloader->base.outline.n_points;

          if ( num_points == num_base_points )
            continue;

          /* gloader->base.outline consists of three parts:               */
          /* 0 -(1)-> start_point -(2)-> num_base_points -(3)-> n_points. */
          /*                                                              */
          /* (1): exists from the beginning                               */
          /* (2): components that have been loaded so far                 */
          /* (3): the newly loaded component                              */
          error = TT_Process_Composite_Component( loader,
                                                  subglyph,
                                                  start_point,
                                                  num_base_points );
          if ( error )
            goto Exit;
        }

        loader->stream   = old_stream;
        loader->byte_len = old_byte_len;

        /* process the glyph */
        loader->ins_pos = ins_pos;
        if ( IS_HINTED( loader->load_flags ) &&
#ifdef TT_USE_BYTECODE_INTERPRETER
             subglyph->flags & WE_HAVE_INSTR &&
#endif
             num_points > start_point )
        {
          error = TT_Process_Composite_Glyph( loader,
                                              start_point,
                                              start_contour );
          if ( error )
            goto Exit;
        }
      }
    }
    else
    {
      /* invalid composite count (negative but not -1) */
      error = FT_THROW( Invalid_Outline );
      goto Exit;
    }

    /***********************************************************************/
    /***********************************************************************/
    /***********************************************************************/

  Exit:

    if ( opened_frame )
      face->forget_glyph_frame( loader );

#ifdef FT_CONFIG_OPTION_INCREMENTAL

    if ( glyph_data_loaded )
      face->root.internal->incremental_interface->funcs->free_glyph_data(
        face->root.internal->incremental_interface->object,
        &glyph_data );

#endif

    return error;
  }


  static FT_Error
  compute_glyph_metrics( TT_Loader  loader,
                         FT_UInt    glyph_index )
  {
    TT_Face    face   = loader->face;
#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
#endif

    FT_BBox       bbox;
    FT_Fixed      y_scale;
    TT_GlyphSlot  glyph = loader->glyph;
    TT_Size       size  = loader->size;


    y_scale = 0x10000L;
    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
      y_scale = size->root.metrics.y_scale;

    if ( glyph->format != FT_GLYPH_FORMAT_COMPOSITE )
      FT_Outline_Get_CBox( &glyph->outline, &bbox );
    else
      bbox = loader->bbox;

    /* get the device-independent horizontal advance; it is scaled later */
    /* by the base layer.                                                */
    glyph->linearHoriAdvance = loader->linear;

    glyph->metrics.horiBearingX = bbox.xMin;
    glyph->metrics.horiBearingY = bbox.yMax;
    glyph->metrics.horiAdvance  = loader->pp2.x - loader->pp1.x;

    /* Adjust advance width to the value contained in the hdmx table    */
    /* unless FT_LOAD_COMPUTE_METRICS is set or backwards compatibility */
    /* mode of the v40 interpreter is active.  See `ttinterp.h' for     */
    /* details on backwards compatibility mode.                         */
    if (
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
         !( driver->interpreter_version == TT_INTERPRETER_VERSION_40 &&
            ( loader->exec && loader->exec->backwards_compatibility  ) ) &&
#endif
         !face->postscript.isFixedPitch                                  &&
         IS_HINTED( loader->load_flags )                                 &&
         !( loader->load_flags & FT_LOAD_COMPUTE_METRICS )               )
    {
      FT_Byte*  widthp;


      widthp = tt_face_get_device_metrics( face,
                                           size->root.metrics.x_ppem,
                                           glyph_index );

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
      {
        FT_Bool  ignore_x_mode;


        ignore_x_mode = FT_BOOL( FT_LOAD_TARGET_MODE( loader->load_flags ) !=
                                 FT_RENDER_MODE_MONO );

        if ( widthp                                                   &&
             ( ( ignore_x_mode && loader->exec->compatible_widths ) ||
                !ignore_x_mode                                      ||
                SPH_OPTION_BITMAP_WIDTHS                            ) )
          glyph->metrics.horiAdvance = *widthp * 64;
      }
      else

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      {
        if ( widthp )
          glyph->metrics.horiAdvance = *widthp * 64;
      }
    }

    /* set glyph dimensions */
    glyph->metrics.width  = bbox.xMax - bbox.xMin;
    glyph->metrics.height = bbox.yMax - bbox.yMin;

    /* Now take care of vertical metrics.  In the case where there is */
    /* no vertical information within the font (relatively common),   */
    /* create some metrics manually                                   */
    {
      FT_Pos  top;      /* scaled vertical top side bearing  */
      FT_Pos  advance;  /* scaled vertical advance height    */


      /* Get the unscaled top bearing and advance height. */
      if ( face->vertical_info                   &&
           face->vertical.number_Of_VMetrics > 0 )
      {
        top = (FT_Short)FT_DivFix( loader->pp3.y - bbox.yMax,
                                   y_scale );

        if ( loader->pp3.y <= loader->pp4.y )
          advance = 0;
        else
          advance = (FT_UShort)FT_DivFix( loader->pp3.y - loader->pp4.y,
                                          y_scale );
      }
      else
      {
        FT_Pos  height;


        /* XXX Compute top side bearing and advance height in  */
        /*     Get_VMetrics instead of here.                   */

        /* NOTE: The OS/2 values are the only `portable' ones, */
        /*       which is why we use them, if there is an OS/2 */
        /*       table in the font.  Otherwise, we use the     */
        /*       values defined in the horizontal header.      */

        height = (FT_Short)FT_DivFix( bbox.yMax - bbox.yMin,
                                      y_scale );
        if ( face->os2.version != 0xFFFFU )
          advance = (FT_Pos)( face->os2.sTypoAscender -
                              face->os2.sTypoDescender );
        else
          advance = (FT_Pos)( face->horizontal.Ascender -
                              face->horizontal.Descender );

        top = ( advance - height ) / 2;
      }

#ifdef FT_CONFIG_OPTION_INCREMENTAL
      {
        FT_Incremental_InterfaceRec*  incr;
        FT_Incremental_MetricsRec     metrics;
        FT_Error                      error;


        incr = face->root.internal->incremental_interface;

        /* If this is an incrementally loaded font see if there are */
        /* overriding metrics for this glyph.                       */
        if ( incr && incr->funcs->get_glyph_metrics )
        {
          metrics.bearing_x = 0;
          metrics.bearing_y = top;
          metrics.advance   = advance;

          error = incr->funcs->get_glyph_metrics( incr->object,
                                                  glyph_index,
                                                  TRUE,
                                                  &metrics );
          if ( error )
            return error;

          top     = metrics.bearing_y;
          advance = metrics.advance;
        }
      }

      /* GWW: Do vertical metrics get loaded incrementally too? */

#endif /* FT_CONFIG_OPTION_INCREMENTAL */

      glyph->linearVertAdvance = advance;

      /* scale the metrics */
      if ( !( loader->load_flags & FT_LOAD_NO_SCALE ) )
      {
        top     = FT_MulFix( top,     y_scale );
        advance = FT_MulFix( advance, y_scale );
      }

      /* XXX: for now, we have no better algorithm for the lsb, but it */
      /*      should work fine.                                        */
      /*                                                               */
      glyph->metrics.vertBearingX = glyph->metrics.horiBearingX -
                                      glyph->metrics.horiAdvance / 2;
      glyph->metrics.vertBearingY = top;
      glyph->metrics.vertAdvance  = advance;
    }

    return 0;
  }


#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

  static FT_Error
  load_sbit_image( TT_Size       size,
                   TT_GlyphSlot  glyph,
                   FT_UInt       glyph_index,
                   FT_Int32      load_flags )
  {
    TT_Face             face;
    SFNT_Service        sfnt;
    FT_Stream           stream;
    FT_Error            error;
    TT_SBit_MetricsRec  metrics;


    face   = (TT_Face)glyph->face;
    sfnt   = (SFNT_Service)face->sfnt;
    stream = face->root.stream;

    error = sfnt->load_sbit_image( face,
                                   size->strike_index,
                                   glyph_index,
                                   (FT_UInt)load_flags,
                                   stream,
                                   &glyph->bitmap,
                                   &metrics );
    if ( !error )
    {
      glyph->outline.n_points   = 0;
      glyph->outline.n_contours = 0;

      glyph->metrics.width  = (FT_Pos)metrics.width  * 64;
      glyph->metrics.height = (FT_Pos)metrics.height * 64;

      glyph->metrics.horiBearingX = (FT_Pos)metrics.horiBearingX * 64;
      glyph->metrics.horiBearingY = (FT_Pos)metrics.horiBearingY * 64;
      glyph->metrics.horiAdvance  = (FT_Pos)metrics.horiAdvance  * 64;

      glyph->metrics.vertBearingX = (FT_Pos)metrics.vertBearingX * 64;
      glyph->metrics.vertBearingY = (FT_Pos)metrics.vertBearingY * 64;
      glyph->metrics.vertAdvance  = (FT_Pos)metrics.vertAdvance  * 64;

      glyph->format = FT_GLYPH_FORMAT_BITMAP;

      if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )
      {
        glyph->bitmap_left = metrics.vertBearingX;
        glyph->bitmap_top  = metrics.vertBearingY;
      }
      else
      {
        glyph->bitmap_left = metrics.horiBearingX;
        glyph->bitmap_top  = metrics.horiBearingY;
      }
    }

    return error;
  }

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */


  static FT_Error
  tt_loader_init( TT_Loader     loader,
                  TT_Size       size,
                  TT_GlyphSlot  glyph,
                  FT_Int32      load_flags,
                  FT_Bool       glyf_table_only )
  {
    FT_Error  error;

    TT_Face    face;
    FT_Stream  stream;
#ifdef TT_USE_BYTECODE_INTERPRETER
    FT_Bool    pedantic = FT_BOOL( load_flags & FT_LOAD_PEDANTIC );
#endif
#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( (TT_Face)glyph->face );
#endif


    face   = (TT_Face)glyph->face;
    stream = face->root.stream;

    FT_ZERO( loader );

#ifdef TT_USE_BYTECODE_INTERPRETER

    /* load execution context */
    if ( IS_HINTED( load_flags ) && !glyf_table_only )
    {
      TT_ExecContext  exec;
      FT_Bool         grayscale = TRUE;
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      FT_Bool         subpixel_hinting_lean;
      FT_Bool         grayscale_cleartype;
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      FT_Bool  subpixel_hinting = FALSE;

#if 0
      /* not used yet */
      FT_Bool  compatible_widths;
      FT_Bool  symmetrical_smoothing;
      FT_Bool  bgr;
      FT_Bool  vertical_lcd;
      FT_Bool  subpixel_positioned;
      FT_Bool  gray_cleartype;
#endif
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      FT_Bool  reexecute = FALSE;


      if ( size->bytecode_ready < 0 || size->cvt_ready < 0 )
      {
        error = tt_size_ready_bytecode( size, pedantic );
        if ( error )
          return error;
      }
      else if ( size->bytecode_ready )
        return size->bytecode_ready;
      else if ( size->cvt_ready )
        return size->cvt_ready;

      /* query new execution context */
      exec = size->context;
      if ( !exec )
        return FT_THROW( Could_Not_Find_Context );

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
      {
        subpixel_hinting_lean   = TRUE;
        grayscale_cleartype     = !FT_BOOL( load_flags         &
                                            FT_LOAD_TARGET_LCD     ||
                                            load_flags           &
                                            FT_LOAD_TARGET_LCD_V   );
        exec->vertical_lcd_lean = FT_BOOL( load_flags           &
                                           FT_LOAD_TARGET_LCD_V );
      }
      else
      {
        subpixel_hinting_lean   = FALSE;
        grayscale_cleartype     = FALSE;
        exec->vertical_lcd_lean = FALSE;
      }
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
      {
        subpixel_hinting = FT_BOOL( ( FT_LOAD_TARGET_MODE( load_flags ) !=
                                      FT_RENDER_MODE_MONO               )  &&
                                    SPH_OPTION_SET_SUBPIXEL                );

        if ( subpixel_hinting )
          grayscale = FALSE;
        else if ( SPH_OPTION_SET_GRAYSCALE )
        {
          grayscale        = TRUE;
          subpixel_hinting = FALSE;
        }
        else
          grayscale = FALSE;

        if ( FT_IS_TRICKY( glyph->face ) )
          subpixel_hinting = FALSE;

        exec->ignore_x_mode      = subpixel_hinting || grayscale;
        exec->rasterizer_version = SPH_OPTION_SET_RASTERIZER_VERSION;
        if ( exec->sph_tweak_flags & SPH_TWEAK_RASTERIZER_35 )
          exec->rasterizer_version = TT_INTERPRETER_VERSION_35;

#if 1
        exec->compatible_widths     = SPH_OPTION_SET_COMPATIBLE_WIDTHS;
        exec->symmetrical_smoothing = TRUE;
        exec->bgr                   = FALSE;
        exec->vertical_lcd          = FALSE;
        exec->subpixel_positioned   = TRUE;
        exec->gray_cleartype        = FALSE;
#else /* 0 */
        exec->compatible_widths =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_COMPATIBLE_WIDTHS );
        exec->symmetrical_smoothing =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_SYMMETRICAL_SMOOTHING );
        exec->bgr =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_BGR );
        exec->vertical_lcd =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_VERTICAL_LCD );
        exec->subpixel_positioned =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_SUBPIXEL_POSITIONED );
        exec->gray_cleartype =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_GRAY_CLEARTYPE );
#endif /* 0 */

      }
      else

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
        grayscale = FT_BOOL( !subpixel_hinting_lean               &&
                             FT_LOAD_TARGET_MODE( load_flags ) !=
                               FT_RENDER_MODE_MONO                );
      else
#endif
        grayscale = FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                               FT_RENDER_MODE_MONO             );

      error = TT_Load_Context( exec, face, size );
      if ( error )
        return error;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
      {
        /* a change from mono to subpixel rendering (and vice versa) */
        /* requires a re-execution of the CVT program                */
        if ( subpixel_hinting != exec->subpixel_hinting )
        {
          FT_TRACE4(( "tt_loader_init: subpixel hinting change,"
                      " re-executing `prep' table\n" ));

          exec->subpixel_hinting = subpixel_hinting;
          reexecute              = TRUE;
        }

        /* a change from mono to grayscale rendering (and vice versa) */
        /* requires a re-execution of the CVT program                 */
        if ( grayscale != exec->grayscale )
        {
          FT_TRACE4(( "tt_loader_init: grayscale hinting change,"
                      " re-executing `prep' table\n" ));

          exec->grayscale = grayscale;
          reexecute       = TRUE;
        }
      }
      else

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      {

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
        if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
        {
          /* a change from mono to subpixel rendering (and vice versa) */
          /* requires a re-execution of the CVT program                */
          if ( subpixel_hinting_lean != exec->subpixel_hinting_lean )
          {
            FT_TRACE4(( "tt_loader_init: subpixel hinting change,"
                        " re-executing `prep' table\n" ));

            exec->subpixel_hinting_lean = subpixel_hinting_lean;
            reexecute                   = TRUE;
          }

          /* a change from colored to grayscale subpixel rendering (and */
          /* vice versa) requires a re-execution of the CVT program     */
          if ( grayscale_cleartype != exec->grayscale_cleartype )
          {
            FT_TRACE4(( "tt_loader_init: grayscale subpixel hinting change,"
                        " re-executing `prep' table\n" ));

            exec->grayscale_cleartype = grayscale_cleartype;
            reexecute                 = TRUE;
          }
        }
#endif

        /* a change from mono to grayscale rendering (and vice versa) */
        /* requires a re-execution of the CVT program                 */
        if ( grayscale != exec->grayscale )
        {
          FT_TRACE4(( "tt_loader_init: grayscale hinting change,"
                      " re-executing `prep' table\n" ));

          exec->grayscale = grayscale;
          reexecute       = TRUE;
        }
      }

      if ( reexecute )
      {
        FT_UInt  i;


        for ( i = 0; i < size->cvt_size; i++ )
          size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );
        error = tt_size_run_prep( size, pedantic );
        if ( error )
          return error;
      }

      /* check whether the cvt program has disabled hinting */
      if ( exec->GS.instruct_control & 1 )
        load_flags |= FT_LOAD_NO_HINTING;

      /* load default graphics state -- if needed */
      if ( exec->GS.instruct_control & 2 )
        exec->GS = tt_default_graphics_state;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      /* check whether we have a font hinted for ClearType --           */
      /* note that this flag can also be modified in a glyph's bytecode */
      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 &&
           exec->GS.instruct_control & 4                            )
        exec->ignore_x_mode = 0;
#endif

      exec->pedantic_hinting = FT_BOOL( load_flags & FT_LOAD_PEDANTIC );
      loader->exec = exec;
      loader->instructions = exec->glyphIns;
    }

#endif /* TT_USE_BYTECODE_INTERPRETER */

    /* get face's glyph loader */
    if ( !glyf_table_only )
    {
      FT_GlyphLoader  gloader = glyph->internal->loader;


      FT_GlyphLoader_Rewind( gloader );
      loader->gloader = gloader;
    }

    loader->load_flags = (FT_ULong)load_flags;

    loader->face   = face;
    loader->size   = size;
    loader->glyph  = (FT_GlyphSlot)glyph;
    loader->stream = stream;

    loader->composites.head = NULL;
    loader->composites.tail = NULL;

    return FT_Err_Ok;
  }


  static void
  tt_loader_done( TT_Loader  loader )
  {
    FT_List_Finalize( &loader->composites,
                      NULL,
                      loader->face->root.memory,
                      NULL );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Glyph                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function used to load a single glyph within a given glyph slot,  */
  /*    for a given size.                                                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    glyph       :: A handle to a target slot object where the glyph    */
  /*                   will be loaded.                                     */
  /*                                                                       */
  /*    size        :: A handle to the source face size at which the glyph */
  /*                   must be scaled/loaded.                              */
  /*                                                                       */
  /*    glyph_index :: The index of the glyph in the font file.            */
  /*                                                                       */
  /*    load_flags  :: A flag indicating what to load for this glyph.  The */
  /*                   FT_LOAD_XXX constants can be used to control the    */
  /*                   glyph loading process (e.g., whether the outline    */
  /*                   should be scaled, whether to load bitmaps or not,   */
  /*                   whether to hint the outline, etc).                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  TT_Load_Glyph( TT_Size       size,
                 TT_GlyphSlot  glyph,
                 FT_UInt       glyph_index,
                 FT_Int32      load_flags )
  {
    FT_Error      error;
    TT_LoaderRec  loader;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#define IS_DEFAULT_INSTANCE  ( ( (TT_Face)glyph->face )->is_default_instance )
#else
#define IS_DEFAULT_INSTANCE  1
#endif


    FT_TRACE1(( "TT_Load_Glyph: glyph index %d\n", glyph_index ));

#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

    /* try to load embedded bitmap (if any) */
    if ( size->strike_index != 0xFFFFFFFFUL      &&
         ( load_flags & FT_LOAD_NO_BITMAP ) == 0 &&
         IS_DEFAULT_INSTANCE                     )
    {
      error = load_sbit_image( size, glyph, glyph_index, load_flags );
      if ( !error )
      {
        if ( FT_IS_SCALABLE( glyph->face ) )
        {
          /* for the bbox we need the header only */
          (void)tt_loader_init( &loader, size, glyph, load_flags, TRUE );
          (void)load_truetype_glyph( &loader, glyph_index, 0, TRUE );
          tt_loader_done( &loader );
          glyph->linearHoriAdvance = loader.linear;
          glyph->linearVertAdvance = loader.vadvance;

          /* sanity checks: if `xxxAdvance' in the sbit metric */
          /* structure isn't set, use `linearXXXAdvance'      */
          if ( !glyph->metrics.horiAdvance && glyph->linearHoriAdvance )
            glyph->metrics.horiAdvance =
              FT_MulFix( glyph->linearHoriAdvance,
                         size->root.metrics.x_scale );
          if ( !glyph->metrics.vertAdvance && glyph->linearVertAdvance )
            glyph->metrics.vertAdvance =
              FT_MulFix( glyph->linearVertAdvance,
                         size->root.metrics.y_scale );
        }

        return FT_Err_Ok;
      }
    }

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */

    /* if FT_LOAD_NO_SCALE is not set, `ttmetrics' must be valid */
    if ( !( load_flags & FT_LOAD_NO_SCALE ) && !size->ttmetrics.valid )
      return FT_THROW( Invalid_Size_Handle );

    if ( load_flags & FT_LOAD_SBITS_ONLY )
      return FT_THROW( Invalid_Argument );

    error = tt_loader_init( &loader, size, glyph, load_flags, FALSE );
    if ( error )
      return error;

    glyph->format        = FT_GLYPH_FORMAT_OUTLINE;
    glyph->num_subglyphs = 0;
    glyph->outline.flags = 0;

    /* main loading loop */
    error = load_truetype_glyph( &loader, glyph_index, 0, FALSE );
    if ( !error )
    {
      if ( glyph->format == FT_GLYPH_FORMAT_COMPOSITE )
      {
        glyph->num_subglyphs = loader.gloader->base.num_subglyphs;
        glyph->subglyphs     = loader.gloader->base.subglyphs;
      }
      else
      {
        glyph->outline        = loader.gloader->base.outline;
        glyph->outline.flags &= ~FT_OUTLINE_SINGLE_PASS;

        /* Translate array so that (0,0) is the glyph's origin.  Note  */
        /* that this behaviour is independent on the value of bit 1 of */
        /* the `flags' field in the `head' table -- at least major     */
        /* applications like Acroread indicate that.                   */
        if ( loader.pp1.x )
          FT_Outline_Translate( &glyph->outline, -loader.pp1.x, 0 );
      }

#ifdef TT_USE_BYTECODE_INTERPRETER

      if ( IS_HINTED( load_flags ) )
      {
        if ( loader.exec->GS.scan_control )
        {
          /* convert scan conversion mode to FT_OUTLINE_XXX flags */
          switch ( loader.exec->GS.scan_type )
          {
          case 0: /* simple drop-outs including stubs */
            glyph->outline.flags |= FT_OUTLINE_INCLUDE_STUBS;
            break;
          case 1: /* simple drop-outs excluding stubs */
            /* nothing; it's the default rendering mode */
            break;
          case 4: /* smart drop-outs including stubs */
            glyph->outline.flags |= FT_OUTLINE_SMART_DROPOUTS |
                                    FT_OUTLINE_INCLUDE_STUBS;
            break;
          case 5: /* smart drop-outs excluding stubs  */
            glyph->outline.flags |= FT_OUTLINE_SMART_DROPOUTS;
            break;

          default: /* no drop-out control */
            glyph->outline.flags |= FT_OUTLINE_IGNORE_DROPOUTS;
            break;
          }
        }
        else
          glyph->outline.flags |= FT_OUTLINE_IGNORE_DROPOUTS;
      }

#endif /* TT_USE_BYTECODE_INTERPRETER */

      error = compute_glyph_metrics( &loader, glyph_index );
    }

    tt_loader_done( &loader );

    /* Set the `high precision' bit flag.                           */
    /* This is _critical_ to get correct output for monochrome      */
    /* TrueType glyphs at all sizes using the bytecode interpreter. */
    /*                                                              */
    if ( !( load_flags & FT_LOAD_NO_SCALE ) &&
         size->root.metrics.y_ppem < 24     )
      glyph->outline.flags |= FT_OUTLINE_HIGH_PRECISION;

    return error;
  }


/* END */
@


1.25
log
@
Update to FreeType 2.7

Now Subpixel hinting, also known as ClearType hinting, is enabled
by default.

OK matthieu@@
@
text
@d444 1
a444 1
    FT_ASSERT( flag != NULL );
d889 1
a889 1
    if ( loader->face->doblend )
d896 10
d1500 1
a1500 1
      FT_MEM_ZERO( &inc_stream, sizeof ( inc_stream ) );
d1518 1
a1518 1
      if ( !loader->glyf_offset                        &&
d1521 1
a1521 1
      if ( !loader->glyf_offset )
d1530 1
a1530 1
                                        loader->glyf_offset + offset,
d1577 1
a1577 1
      if ( loader->face->doblend )
d1620 8
d1748 1
a1748 1
      if ( face->doblend )
d1817 5
a1821 5
        if ( ( error = TT_Vary_Apply_Glyph_Deltas(
                         face,
                         glyph_index,
                         &outline,
                         (FT_UInt)outline.n_points ) ) != 0 )
d1845 7
d1911 3
d1926 3
d1948 3
d2289 1
a2289 1
    FT_MEM_ZERO( loader, sizeof ( TT_LoaderRec ) );
a2533 26
    /* seek to the beginning of the glyph table -- for Type 42 fonts     */
    /* the table might be accessed from a Postscript stream or something */
    /* else...                                                           */

#ifdef FT_CONFIG_OPTION_INCREMENTAL

    if ( face->root.internal->incremental_interface )
      loader->glyf_offset = 0;
    else

#endif

    {
      error = face->goto_table( face, TTAG_glyf, stream, 0 );

      if ( FT_ERR_EQ( error, Table_Missing ) )
        loader->glyf_offset = 0;
      else if ( error )
      {
        FT_ERROR(( "tt_loader_init: could not access glyph table\n" ));
        return error;
      }
      else
        loader->glyf_offset = FT_STREAM_POS();
    }

d2604 6
d2615 1
a2615 4
    /* try to load embedded bitmap if any              */
    /*                                                 */
    /* XXX: The convention should be emphasized in     */
    /*      the documents because it can be confusing. */
d2617 2
a2618 1
         ( load_flags & FT_LOAD_NO_BITMAP ) == 0 )
@


1.24
log
@
Update to FreeType 2.6.5

ok matthieu@@
@
text
@d1439 2
a1440 4
    /* some fonts have an incorrect value of `maxComponentDepth', */
    /* thus we allow depth 1 to catch the majority of them        */
    if ( recurse_count > 1                                   &&
         recurse_count > face->max_profile.maxComponentDepth )
d1442 3
a1444 2
      error = FT_THROW( Invalid_Composite );
      goto Exit;
d1810 5
a1814 5
          /* XXX: overflow check for subglyph->{arg1,arg2}.         */
          /*      Deltas must be within signed 16-bit,              */
          /*      but the restriction of summed deltas is not clear */
          subglyph->arg1 = (FT_Int16)points[i].x;
          subglyph->arg2 = (FT_Int16)points[i].y;
@


1.23
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d125 1
a125 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d156 1
a156 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d168 1
a168 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d430 2
a431 1
      FT_MEM_COPY( load->exec->glyphIns, p, (FT_Long)n_ins );
d736 2
a737 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d820 15
a834 5
    /* save glyph phantom points */
    loader->pp1 = zone->cur[zone->n_points - 4];
    loader->pp2 = zone->cur[zone->n_points - 3];
    loader->pp3 = zone->cur[zone->n_points - 2];
    loader->pp4 = zone->cur[zone->n_points - 1];
d836 1
a836 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d845 1
a845 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d911 1
a911 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d930 1
a930 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d961 1
a961 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d1092 1
a1092 1
        int  d = subglyph->transform.yy > 0 ? subglyph->transform.yy
d1338 7
d1346 34
a1380 39
#define TT_LOADER_SET_PP( loader )                                          \
          do                                                                \
          {                                                                 \
            FT_Bool  subpixel_hinting_ = loader->exec                       \
                                           ? loader->exec->subpixel_hinting \
                                           : 0;                             \
            FT_Bool  grayscale_        = loader->exec                       \
                                           ? loader->exec->grayscale        \
                                           : 0;                             \
            FT_Bool  use_aw_2_         = (FT_Bool)( subpixel_hinting_ &&    \
                                                    grayscale_        );    \
                                                                            \
                                                                            \
            (loader)->pp1.x = (loader)->bbox.xMin - (loader)->left_bearing; \
            (loader)->pp1.y = 0;                                            \
            (loader)->pp2.x = (loader)->pp1.x + (loader)->advance;          \
            (loader)->pp2.y = 0;                                            \
                                                                            \
            (loader)->pp3.x = use_aw_2_ ? (loader)->advance / 2 : 0;        \
            (loader)->pp3.y = (loader)->bbox.yMax + (loader)->top_bearing;  \
            (loader)->pp4.x = use_aw_2_ ? (loader)->advance / 2 : 0;        \
            (loader)->pp4.y = (loader)->pp3.y - (loader)->vadvance;         \
          } while ( 0 )

#else /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */

#define TT_LOADER_SET_PP( loader )                                          \
          do                                                                \
          {                                                                 \
            (loader)->pp1.x = (loader)->bbox.xMin - (loader)->left_bearing; \
            (loader)->pp1.y = 0;                                            \
            (loader)->pp2.x = (loader)->pp1.x + (loader)->advance;          \
            (loader)->pp2.y = 0;                                            \
                                                                            \
            (loader)->pp3.x = 0;                                            \
            (loader)->pp3.y = (loader)->bbox.yMax + (loader)->top_bearing;  \
            (loader)->pp4.x = 0;                                            \
            (loader)->pp4.y = (loader)->pp3.y - (loader)->vadvance;         \
          } while ( 0 )
d1382 21
a1402 1
#endif /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d1560 1
a1560 1
      TT_LOADER_SET_PP( loader );
d1635 1
a1635 1
    TT_LOADER_SET_PP( loader );
d1677 2
d1687 6
d1702 4
a1707 3
        FT_ListNode  node = NULL;


d1749 4
d1992 2
a1993 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d2020 12
a2031 5
    /* adjust advance width to the value contained in the hdmx table */
    /* unless FT_LOAD_COMPUTE_METRICS is set                         */
    if ( !face->postscript.isFixedPitch                    &&
         IS_HINTED( loader->load_flags )                   &&
         !( loader->load_flags & FT_LOAD_COMPUTE_METRICS ) )
d2040 1
a2040 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d2058 1
a2058 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d2247 4
d2264 5
a2268 4
      FT_Bool         grayscale;

#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
      TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
d2270 1
d2282 1
a2282 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d2303 20
a2322 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d2379 1
a2379 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d2381 7
a2387 1
      {
d2389 1
a2389 2
                             FT_RENDER_MODE_MONO );
      }
d2395 1
a2395 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d2423 1
a2423 1
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d2426 28
d2486 1
a2486 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d2489 2
a2490 1
      if ( exec->GS.instruct_control & 4 )
@


1.22
log
@
Bugfixing update to freetype-2.6.2

Tested on amd64, i386, macppc, sparc64, loongson and compile-tested
on arm by matthieu@@
Also tested in a ports bulk build by naddy@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2015 by                                                 */
@


1.21
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@d27 1
d663 1
d1400 5
d1637 2
d1644 27
a1697 2
        FT_Memory  memory = face->root.memory;

d2430 3
d2437 10
d2503 1
d2598 2
@


1.20
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d123 1
a123 1
    TT_Face    face   = (TT_Face)loader->face;
d185 1
a185 1
    TT_Face  face = (TT_Face)loader->face;
a252 23
  /* Translates an array of coordinates.                                   */
  /*                                                                       */
  static void
  translate_array( FT_UInt     n,
                   FT_Vector*  coords,
                   FT_Pos      delta_x,
                   FT_Pos      delta_y )
  {
    FT_UInt  k;


    if ( delta_x )
      for ( k = 0; k < n; k++ )
        coords[k].x += delta_x;

    if ( delta_y )
      for ( k = 0; k < n; k++ )
        coords[k].y += delta_y;
  }


  /*************************************************************************/
  /*                                                                       */
d636 1
a636 1
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d641 2
a642 2
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d646 4
a649 4
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        xy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d734 1
a734 1
    TT_Face    face   = (TT_Face)loader->face;
d761 1
a761 1
    loader->exec->GS = ((TT_Size)loader->size)->GS;
d774 2
a775 4
      loader->exec->metrics.x_scale =
        ((TT_Size)loader->size)->metrics.x_scale;
      loader->exec->metrics.y_scale =
        ((TT_Size)loader->size)->metrics.y_scale;
d875 1
a875 1
    if ( ((TT_Face)loader->face)->doblend )
d878 4
a881 4
      error = TT_Vary_Apply_Glyph_Deltas( (TT_Face)(loader->face),
                                           loader->glyph_index,
                                           outline,
                                           (FT_UInt)n_points );
d898 1
a898 1
      TT_Face    face   = (TT_Face)loader->face;
d931 1
a931 1
          x_scale = FT_MulDiv( ((TT_Size)loader->size)->metrics.x_scale,
d933 1
a933 1
          y_scale = ((TT_Size)loader->size)->metrics.y_scale;
d953 2
a954 2
          x_scale = ((TT_Size)loader->size)->metrics.x_scale;
          y_scale = ((TT_Size)loader->size)->metrics.y_scale;
d1001 2
a1002 3
    FT_GlyphLoader  gloader    = loader->gloader;
    FT_Vector*      base_vec   = gloader->base.outline.points;
    FT_UInt         num_points = (FT_UInt)gloader->base.outline.n_points;
d1007 5
d1018 1
a1018 7
    {
      FT_UInt  i;


      for ( i = num_base_points; i < num_points; i++ )
        FT_Vector_Transform( base_vec + i, &subglyph->transform );
    }
d1023 1
d1112 2
a1113 2
        FT_Fixed  x_scale = ((TT_Size)loader->size)->metrics.x_scale;
        FT_Fixed  y_scale = ((TT_Size)loader->size)->metrics.y_scale;
d1128 1
a1128 3
      translate_array( num_points - num_base_points,
                       base_vec + num_base_points,
                       x, y );
d1190 1
a1190 1
      max_ins = ((TT_Face)loader->face)->max_profile.maxSizeOfInstructions;
d1387 1
a1387 1
    TT_Face         face         = (TT_Face)loader->face;
d1420 2
a1421 2
      x_scale = ((TT_Size)loader->size)->metrics.x_scale;
      y_scale = ((TT_Size)loader->size)->metrics.y_scale;
d1527 1
a1527 1
      if ( ((TT_Face)(loader->face))->doblend )
d1554 4
a1557 4
        error = TT_Vary_Apply_Glyph_Deltas( (TT_Face)(loader->face),
                                             glyph_index,
                                             &outline,
                                             outline.n_points );
d1654 1
a1654 1
        FT_UInt      i, limit;
d1665 1
a1665 1
        limit = gloader->current.num_subglyphs;
d1669 1
a1669 1
        outline.n_points   = gloader->current.num_subglyphs + 4;
d1677 1
a1677 1
        subglyph = gloader->current.subglyphs + gloader->base.num_subglyphs;
d1723 1
a1723 1
                         outline.n_points ) ) != 0 )
d1726 1
a1726 1
        subglyph = gloader->current.subglyphs + gloader->base.num_subglyphs;
d1910 1
a1910 1
    TT_Face    face   = (TT_Face)loader->face;
d1918 1
a1918 1
    TT_Size       size  = (TT_Size)loader->size;
d1939 4
a1942 2
    if ( !face->postscript.isFixedPitch  &&
         IS_HINTED( loader->load_flags ) )
d1965 1
a1965 1
          glyph->metrics.horiAdvance = *widthp << 6;
d1973 1
a1973 1
          glyph->metrics.horiAdvance = *widthp << 6;
d2113 2
a2114 2
      glyph->metrics.width  = (FT_Pos)metrics.width  << 6;
      glyph->metrics.height = (FT_Pos)metrics.height << 6;
d2116 7
a2122 7
      glyph->metrics.horiBearingX = (FT_Pos)metrics.horiBearingX << 6;
      glyph->metrics.horiBearingY = (FT_Pos)metrics.horiBearingY << 6;
      glyph->metrics.horiAdvance  = (FT_Pos)metrics.horiAdvance  << 6;

      glyph->metrics.vertBearingX = (FT_Pos)metrics.vertBearingX << 6;
      glyph->metrics.vertBearingY = (FT_Pos)metrics.vertBearingY << 6;
      glyph->metrics.vertAdvance  = (FT_Pos)metrics.vertAdvance  << 6;
d2391 2
a2392 2
    loader->face   = (FT_Face)face;
    loader->size   = (FT_Size)size;
@


1.19
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2014                                                    */
d103 2
a104 1
      *ah  = face->os2.sTypoAscender - face->os2.sTypoDescender;
d110 2
a111 1
      *ah  = face->horizontal.Ascender - face->horizontal.Descender;
d156 2
a157 1
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
d159 1
a159 2
      if ( loader->exec )
        loader->exec->sph_tweak_flags = 0;
d161 5
a165 3
      /* this may not be the right place for this, but it works */
      if ( loader->exec && loader->exec->ignore_x_mode )
        sph_set_tweaks( loader, glyph_index );
d414 1
a414 1
    load->glyph->control_data = 0;
d562 2
a563 2
    outline->n_points   = (FT_UShort)n_points;
    outline->n_contours = (FT_Short) n_contours;
d626 1
a626 1
      if ( subglyph->flags & ARGS_ARE_WORDS )
d628 10
a637 2
        subglyph->arg1 = FT_NEXT_SHORT( p );
        subglyph->arg2 = FT_NEXT_SHORT( p );
d641 10
a650 2
        subglyph->arg1 = FT_NEXT_CHAR( p );
        subglyph->arg2 = FT_NEXT_CHAR( p );
d730 4
a733 3
    zone->n_points    = (FT_UShort)( load->outline.n_points - start_point );
    zone->n_contours  = (FT_Short) ( load->outline.n_contours -
                                       start_contour );
d764 1
a764 1
    FT_UInt       n_ins;
d777 1
a777 1
    n_ins = (FT_UInt)( loader->glyph->control_len );
a817 1
      FT_Bool   debug;
d830 1
a830 4
      debug = FT_BOOL( !( loader->load_flags & FT_LOAD_NO_SCALE ) &&
                       ((TT_Size)loader->size)->debug             );

      error = TT_Run_Context( loader->exec, debug );
d903 4
a906 9
      FT_Vector*  deltas;
      FT_Memory   memory = loader->face->memory;
      FT_Int      i;


      error = TT_Vary_Get_Glyph_Deltas( (TT_Face)(loader->face),
                                        loader->glyph_index,
                                        &deltas,
                                        n_points );
a908 8

      for ( i = 0; i < n_points; ++i )
      {
        outline->points[i].x += deltas[i].x;
        outline->points[i].y += deltas[i].y;
      }

      FT_FREE( deltas );
d927 1
a927 1
      FT_Int      ppem           = loader->size->metrics.x_ppem;
d929 1
a929 1
      FT_Int      x_scale_factor = 1000;
d957 1
a957 1
                               x_scale_factor, 1000 );
d1028 1
a1028 1
    FT_UInt         num_points = gloader->base.outline.n_points;
d1050 2
a1051 2
      FT_UInt     k = subglyph->arg1;
      FT_UInt     l = subglyph->arg2;
d1357 8
a1364 5
            FT_Bool  subpixel_  = loader->exec ? loader->exec->subpixel     \
                                               : 0;                         \
            FT_Bool  grayscale_ = loader->exec ? loader->exec->grayscale    \
                                               : 0;                         \
            FT_Bool  use_aw_2_  = (FT_Bool)( subpixel_ && grayscale_ );     \
a1418 4
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    FT_Vector*      deltas       = NULL;
#endif

d1435 1
d1442 1
d1480 2
a1481 1
                            glyph_data.pointer, glyph_data.length );
d1509 1
a1509 1
                                        loader->byte_len );
d1557 24
d1582 4
a1585 5
        FT_Memory  memory = loader->face->memory;


        error = TT_Vary_Get_Glyph_Deltas( (TT_Face)(loader->face),
                                          glyph_index, &deltas, 4 );
d1589 9
a1597 11
        loader->pp1.x += deltas[0].x;
        loader->pp1.y += deltas[0].y;
        loader->pp2.x += deltas[1].x;
        loader->pp2.y += deltas[1].y;

        loader->pp3.x += deltas[2].x;
        loader->pp3.y += deltas[2].y;
        loader->pp4.x += deltas[3].x;
        loader->pp4.y += deltas[3].y;

        FT_FREE( deltas );
d1663 2
a1664 2
      start_point   = gloader->base.outline.n_points;
      start_contour = gloader->base.outline.n_contours;
d1682 1
a1682 1
        FT_Int       i, limit;
a1683 1
        FT_Memory    memory = face->root.memory;
d1685 9
d1695 22
a1716 2
        /* this provides additional offsets */
        /* for each component's translation */
d1718 30
a1747 1
        if ( ( error = TT_Vary_Get_Glyph_Deltas(
d1750 3
a1752 3
                         &deltas,
                         gloader->current.num_subglyphs + 4 ) ) != 0 )
          goto Exit;
a1754 1
        limit    = gloader->current.num_subglyphs;
d1756 1
a1756 1
        for ( i = 0; i < limit; ++i, ++subglyph )
d1758 5
a1762 8
          if ( subglyph->flags & ARGS_ARE_XY_VALUES )
          {
            /* XXX: overflow check for subglyph->{arg1,arg2}.   */
            /* deltas[i].{x,y} must be within signed 16-bit,    */
            /* but the restriction of summed delta is not clear */
            subglyph->arg1 += (FT_Int16)deltas[i].x;
            subglyph->arg2 += (FT_Int16)deltas[i].y;
          }
d1765 14
a1778 9
        loader->pp1.x += deltas[i + 0].x;
        loader->pp1.y += deltas[i + 0].y;
        loader->pp2.x += deltas[i + 1].x;
        loader->pp2.y += deltas[i + 1].y;

        loader->pp3.x += deltas[i + 2].x;
        loader->pp3.y += deltas[i + 2].y;
        loader->pp4.x += deltas[i + 3].x;
        loader->pp4.y += deltas[i + 3].y;
d1780 2
a1781 1
        FT_FREE( deltas );
d1817 1
a1817 1
        FT_SubGlyph  subglyph       = 0;
d1846 1
a1846 1
          num_base_points = gloader->base.outline.n_points;
d1848 4
a1851 2
          error = load_truetype_glyph( loader, subglyph->index,
                                       recurse_count + 1, FALSE );
d1867 1
a1867 1
          num_points = gloader->base.outline.n_points;
d2130 1
a2130 1
                                   (FT_Int)load_flags,
d2202 1
a2202 1
      FT_Bool  subpixel = FALSE;
d2209 1
d2211 1
d2230 1
a2230 2
      exec = size->debug ? size->context
                         : ( (TT_Driver)FT_FACE_DRIVER( face ) )->context;
d2238 3
a2240 3
        subpixel = FT_BOOL( ( FT_LOAD_TARGET_MODE( load_flags ) !=
                              FT_RENDER_MODE_MONO               )  &&
                            SPH_OPTION_SET_SUBPIXEL                );
d2242 1
a2242 1
        if ( subpixel )
d2246 2
a2247 2
          grayscale = TRUE;
          subpixel  = FALSE;
d2253 1
a2253 1
          subpixel = FALSE;
d2255 1
a2255 1
        exec->ignore_x_mode      = subpixel || grayscale;
d2262 1
a2262 1
        exec->symmetrical_smoothing = FALSE;
d2264 1
d2266 1
d2277 3
d2283 3
d2308 1
a2308 1
        if ( subpixel != exec->subpixel )
d2313 2
a2314 2
          exec->subpixel = subpixel;
          reexecute      = TRUE;
d2337 1
a2337 1
          FT_TRACE4(( "tt_loader_init: grayscale change,"
d2357 1
a2357 1
      /* see whether the cvt program has disabled hinting */
d2365 7
d2415 1
a2415 1
    loader->load_flags = load_flags;
@


1.18
log
@
Security/bugfixing update to freetype-2.5.3, featuring a fix for a
vulnerability in the CFF driver (CVE-2014-2240) and assorted minor
fixes.

ok matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2013                                                    */
d102 1
a102 1
      *tsb = face->os2.sTypoAscender - yMax;
d108 1
a108 1
      *tsb = face->horizontal.Ascender - yMax;
d804 2
a805 4
      error = TT_Set_CodeRange( loader->exec, tt_coderange_glyph,
                                loader->exec->glyphIns, n_ins );
      if ( error )
        return error;
d1790 6
a1795 2
          TT_Process_Composite_Component( loader, subglyph, start_point,
                                          num_base_points );
a1803 1

a1804 1

a1805 1

a1806 1

d1808 7
a1814 2
          TT_Process_Composite_Glyph( loader, start_point, start_contour );

d2089 2
d2128 1
a2128 1
      if ( !size->cvt_ready )
d2130 1
a2130 3
        FT_Error  error = tt_size_ready_bytecode( size, pedantic );


d2134 4
d2201 3
a2203 1
      TT_Load_Context( exec, face, size );
d2255 3
a2257 1
        tt_size_run_prep( size, pedantic );
d2288 1
a2288 2
      FT_Error  error = face->goto_table( face, TTAG_glyf, stream, 0 );

d2379 1
a2379 2
          glyph->linearVertAdvance = loader.top_bearing + loader.bbox.yMax -
                                       loader.vadvance;
d2381 2
a2382 2
          /* sanity check: if `horiAdvance' in the sbit metric */
          /* structure isn't set, use `linearHoriAdvance'      */
d2387 4
d2470 1
a2470 1
      compute_glyph_metrics( &loader, glyph_index );
@


1.17
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@a740 1
    FT_Pos        origin;
a756 6
#endif

    origin = zone->cur[zone->n_points - 4].x;
    origin = FT_PIX_ROUND( origin ) - origin;
    if ( origin )
      translate_array( zone->n_points, zone->cur, origin, 0 );
a757 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d1078 3
a1080 3
  /* Use a default value dependent on                                     */
  /* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old TT */
  /* fonts which don't set the xxx_COMPONENT_OFFSET bit.                  */
d1092 4
a1095 4
  /*************************************************************************/
  /*                                                                       */
  /* This algorithm is what Apple documents.  But it doesn't work.         */
  /*                                                                       */
d1115 1
a1115 1
#else /* 0 */
d1117 4
a1120 4
  /*************************************************************************/
  /*                                                                       */
  /* This algorithm is a guess and works much better than the above.       */
  /*                                                                       */
d1130 1
a1130 1
#endif /* 0 */
d1281 2
a1282 2
   * Note that the rounding to the grid is not documented currently in the
   * specification.
d1355 4
a1358 6
            FT_Bool  subpixel_  = loader->exec                              \
                                    ? loader->exec->subpixel_hinting        \
                                    : 0;                                    \
            FT_Bool  grayscale_ = loader->exec                              \
                                    ? loader->exec->grayscale_hinting       \
                                    : 0;                                    \
d1366 1
d1382 1
d1562 9
a1570 4
        loader->pp1.x += deltas[0].x; loader->pp1.y += deltas[0].y;
        loader->pp2.x += deltas[1].x; loader->pp2.y += deltas[1].y;
        loader->pp3.x += deltas[2].x; loader->pp3.y += deltas[2].y;
        loader->pp4.x += deltas[3].x; loader->pp4.y += deltas[3].y;
d1575 1
a1575 1
#endif
d1577 2
d1583 3
d1587 1
d1595 2
a1596 2
    /* must initialize points before (possibly) overriding */
    /* glyph metrics from the incremental interface        */
d1669 1
a1669 1
                         gloader->current.num_subglyphs + 4 )) != 0 )
d1687 9
a1695 4
        loader->pp1.x += deltas[i + 0].x; loader->pp1.y += deltas[i + 0].y;
        loader->pp2.x += deltas[i + 1].x; loader->pp2.y += deltas[i + 1].y;
        loader->pp3.x += deltas[i + 2].x; loader->pp3.y += deltas[i + 2].y;
        loader->pp4.x += deltas[i + 3].x; loader->pp4.y += deltas[i + 3].y;
d1702 2
d1708 3
d1712 1
d1772 1
d2109 1
a2109 2
      FT_Bool  subpixel_hinting  = FALSE;
      FT_Bool  grayscale_hinting = TRUE;
d2142 3
a2144 3
        subpixel_hinting = FT_BOOL( ( FT_LOAD_TARGET_MODE( load_flags )
                                      != FT_RENDER_MODE_MONO )          &&
                                    SPH_OPTION_SET_SUBPIXEL             );
d2146 2
a2147 2
        if ( subpixel_hinting )
          grayscale = grayscale_hinting = FALSE;
d2150 2
a2151 2
          grayscale = grayscale_hinting = TRUE;
          subpixel_hinting              = FALSE;
d2154 1
a2154 1
          grayscale = grayscale_hinting = FALSE;
d2157 1
a2157 1
          subpixel_hinting = grayscale_hinting = FALSE;
d2159 1
a2159 1
        exec->ignore_x_mode      = subpixel_hinting || grayscale_hinting;
d2202 1
a2202 1
        if ( subpixel_hinting != exec->subpixel_hinting )
d2207 2
a2208 2
          exec->subpixel_hinting = subpixel_hinting;
          reexecute              = TRUE;
d2213 1
a2213 1
        if ( grayscale != exec->grayscale_hinting )
d2218 2
a2219 2
          exec->grayscale_hinting = grayscale_hinting;
          reexecute               = TRUE;
a2347 2

    error = FT_Err_Ok;
@


1.16
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@d88 1
a88 6
  /* Greg Hitchcock from Microsoft told us that if there were no `vmtx'    */
  /* table, typoAscender/Descender from the `OS/2' table would be used     */
  /* instead, and if there were no `OS/2' table, use ascender/descender    */
  /* from the `hhea' table.  But that is not what Microsoft's rasterizer   */
  /* apparently does: It uses the ppem value as the advance height, and    */
  /* sets the top side bearing to be zero.                                 */
d93 1
a99 10
#if 1             /* Empirically determined, at variance with what MS said */

    else
    {
      *tsb = 0;
      *ah  = face->root.units_per_EM;
    }

#else      /* This is what MS said to do.  It isn't what they do, however. */

d102 1
a102 1
      *tsb = face->os2.sTypoAscender;
d105 1
d108 1
a108 1
      *tsb = face->horizontal.Ascender;
a111 2
#endif

d117 1
a117 1
  static void
d126 3
d132 4
d141 1
d145 3
d170 2
a350 1
    TT_Face         face       = (TT_Face)load->face;
d353 1
d419 1
a419 8
    if ( n_ins > face->max_profile.maxSizeOfInstructions )
    {
      FT_TRACE0(( "TT_Load_Simple_Glyph: too many instructions (%d)\n",
                  n_ins ));
      error = FT_THROW( Too_Many_Hints );
      goto Fail;
    }

d431 14
d753 2
a754 2
      FT_TRACE1(( "TT_Hint_Glyph: too long instructions " ));
      FT_TRACE1(( "(0x%lx byte) is truncated\n",
d791 3
a793 1
    /* round pp2 and pp4 */
d796 2
d835 4
a838 7
    if ( !loader->preserve_pps )
    {
      loader->pp1 = zone->cur[zone->n_points - 4];
      loader->pp2 = zone->cur[zone->n_points - 3];
      loader->pp3 = zone->cur[zone->n_points - 2];
      loader->pp4 = zone->cur[zone->n_points - 1];
    }
d1227 2
a1228 1
        /* acroread ignores this field, so we only do a rough safety check */
d1231 2
a1232 2
          FT_TRACE1(( "TT_Process_Composite_Glyph: "
                      "too many instructions (%d) for glyph with length %d\n",
d1237 1
a1237 1
        tmp = loader->exec->glyphSize;
d1243 1
d1265 1
a1265 1
    for ( i = start_point; i < loader->zone.n_points; i++ )
d1274 110
a1383 3
  /* Calculate the four phantom points.                     */
  /* The first two stand for horizontal origin and advance. */
  /* The last two stand for vertical origin and advance.    */
d1385 2
a1386 1
          do {                                                              \
d1392 1
a1392 1
            (loader)->pp3.y = (loader)->top_bearing + (loader)->bbox.yMax;  \
d1397 2
a1461 2
    tt_get_metrics( loader, glyph_index );

d1521 11
a1531 1
      if ( error || header_only )
d1542 4
d2336 2
@


1.15
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@d26 1
d136 4
a139 1
    TT_Face  face = (TT_Face)loader->face;
d158 4
a161 2
    if ( loader->exec )
      loader->exec->sph_tweak_flags = 0;
d163 4
a166 3
    /* this may not be the right place for this, but it works */
    if ( loader->exec && loader->exec->ignore_x_mode )
      sph_set_tweaks( loader, glyph_index );
d730 5
d835 9
a843 2
    if ( loader->exec->sph_tweak_flags & SPH_TWEAK_DEEMBOLDEN )
      FT_Outline_EmboldenXY( &loader->gloader->current.outline, -24, 0 );
a844 3
    else if ( loader->exec->sph_tweak_flags & SPH_TWEAK_EMBOLDEN )
      FT_Outline_EmboldenXY( &loader->gloader->current.outline, 24, 0 );
#endif
a866 8
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    TT_Face     face           = (TT_Face)loader->face;
    FT_String*  family         = face->root.family_name;
    FT_Int      ppem           = loader->size->metrics.x_ppem;
    FT_String*  style          = face->root.style_name;
    FT_Int      x_scale_factor = 1000;
#endif

d921 1
d923 48
a970 35
    /* scale, but only if enabled and only if TT hinting is being used */
    if ( IS_HINTED( loader->load_flags ) )
      x_scale_factor = sph_test_tweak_x_scaling( face,
                                                 family,
                                                 ppem,
                                                 style,
                                                 loader->glyph_index );
    /* scale the glyph */
    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 ||
         x_scale_factor != 1000                         )
    {
      FT_Vector*  vec     = outline->points;
      FT_Vector*  limit   = outline->points + n_points;
      FT_Fixed    x_scale = FT_MulDiv(
                              ((TT_Size)loader->size)->metrics.x_scale,
                              x_scale_factor, 1000 );
      FT_Fixed    y_scale = ((TT_Size)loader->size)->metrics.y_scale;


      /* compensate for any scaling by de/emboldening; */
      /* the amount was determined via experimentation */
      if ( x_scale_factor != 1000 && ppem > 11 )
         FT_Outline_EmboldenXY( outline,
                                FT_MulFix( 1280 * ppem,
                                           1000 - x_scale_factor ),
                                0 );
#else
    /* scale the glyph */
    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
    {
      FT_Vector*  vec     = outline->points;
      FT_Vector*  limit   = outline->points + n_points;
      FT_Fixed    x_scale = ((TT_Size)loader->size)->metrics.x_scale;
      FT_Fixed    y_scale = ((TT_Size)loader->size)->metrics.y_scale;
#endif /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d972 1
a973 1
      for ( ; vec < limit; vec++ )
d975 8
a982 2
        vec->x = FT_MulFix( vec->x, x_scale );
        vec->y = FT_MulFix( vec->y, y_scale );
d985 13
a997 4
      loader->pp1 = outline->points[n_points - 4];
      loader->pp2 = outline->points[n_points - 3];
      loader->pp3 = outline->points[n_points - 2];
      loader->pp4 = outline->points[n_points - 1];
d1702 5
a1707 1
    TT_Face       face = (TT_Face)loader->face;
d1710 1
a1710 1
    TT_Size       size = (TT_Size)loader->size;
a1735 7
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
      FT_Bool  ignore_x_mode;


      ignore_x_mode = FT_BOOL( FT_LOAD_TARGET_MODE( loader->load_flags ) !=
                               FT_RENDER_MODE_MONO );
#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d1742 17
a1758 6
      if ( widthp                                                   &&
           ( ( ignore_x_mode && loader->exec->compatible_widths ) ||
              !ignore_x_mode                                      ||
              SPH_OPTION_BITMAP_WIDTHS                            ) )
#else
      if ( widthp )
d1760 5
a1764 1
        glyph->metrics.horiAdvance = *widthp << 6;
d1960 1
d1962 5
a1966 2
      FT_Bool         subpixel_hinting;
      FT_Bool         grayscale_hinting;
d1968 5
a1972 4
      FT_Bool         compatible_widths;
      FT_Bool         symmetrical_smoothing;
      FT_Bool         bgr;
      FT_Bool         subpixel_positioned;
d1976 2
d1996 1
a1996 7
      subpixel_hinting = FT_BOOL( ( FT_LOAD_TARGET_MODE( load_flags )
                                    != FT_RENDER_MODE_MONO )          &&
                                  SPH_OPTION_SET_SUBPIXEL             );

      if ( subpixel_hinting )
        grayscale = grayscale_hinting = FALSE;
      else if ( SPH_OPTION_SET_GRAYSCALE )
d1998 13
a2010 5
        grayscale = grayscale_hinting = TRUE;
        subpixel_hinting = FALSE;
      }
      else
        grayscale = grayscale_hinting = FALSE;
d2012 2
a2013 2
      if ( FT_IS_TRICKY( glyph->face ) )
        subpixel_hinting = grayscale_hinting = FALSE;
d2015 4
a2018 4
      exec->ignore_x_mode      = subpixel_hinting || grayscale_hinting;
      exec->rasterizer_version = SPH_OPTION_SET_RASTERIZER_VERSION;
      if ( exec->sph_tweak_flags & SPH_TWEAK_RASTERIZER_35 )
        exec->rasterizer_version = 35;
d2021 4
a2024 4
      exec->compatible_widths     = SPH_OPTION_SET_COMPATIBLE_WIDTHS;
      exec->symmetrical_smoothing = FALSE;
      exec->bgr                   = FALSE;
      exec->subpixel_positioned   = TRUE;
d2026 12
a2037 12
      exec->compatible_widths =
        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                 TT_LOAD_COMPATIBLE_WIDTHS );
      exec->symmetrical_smoothing =
        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                 TT_LOAD_SYMMETRICAL_SMOOTHING );
      exec->bgr =
        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                 TT_LOAD_BGR );
      exec->subpixel_positioned =
        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                 TT_LOAD_SUBPIXEL_POSITIONED );
d2040 2
a2041 1
#else /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d2043 1
a2043 2
      grayscale =
        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) != FT_RENDER_MODE_MONO );
d2045 4
a2048 1
#endif /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
d2054 1
a2054 3
      /* a change from mono to subpixel rendering (and vice versa) */
      /* requires a re-execution of the CVT program                */
      if ( subpixel_hinting != exec->subpixel_hinting )
d2056 6
a2061 1
        FT_UInt  i;
d2063 3
d2067 6
a2072 2
        FT_TRACE4(( "tt_loader_init: subpixel hinting change,"
                    " re-executing `prep' table\n" ));
d2074 5
a2078 1
        exec->subpixel_hinting = subpixel_hinting;
d2080 1
a2080 4
        for ( i = 0; i < size->cvt_size; i++ )
          size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );
        tt_size_run_prep( size, pedantic );
      }
a2081 3
      /* a change from mono to grayscale rendering (and vice versa) */
      /* requires a re-execution of the CVT program                 */
      if ( grayscale != exec->grayscale_hinting )
d2083 6
a2088 1
        FT_UInt  i;
d2090 3
a2092 9

        FT_TRACE4(( "tt_loader_init: grayscale hinting change,"
                    " re-executing `prep' table\n" ));

        exec->grayscale_hinting = grayscale_hinting;

        for ( i = 0; i < size->cvt_size; i++ )
          size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );
        tt_size_run_prep( size, pedantic );
d2095 1
a2095 5
#else /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */

      /* a change from mono to grayscale rendering (and vice versa) */
      /* requires a re-execution of the CVT program                 */
      if ( grayscale != exec->grayscale )
a2099 5
        FT_TRACE4(( "tt_loader_init: grayscale change,"
                    " re-executing `prep' table\n" ));

        exec->grayscale = grayscale;

a2104 2
#endif /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */

d2227 7
@


1.14
log
@Update to freetype 2.4.11. Tested by krw@@, jasper@@ and on a bulk ports
build by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2012                                                    */
d295 1
a295 1
    return TT_Err_Ok;
d317 1
a317 1
      return TT_Err_Invalid_Outline;
d333 1
a333 1
    return TT_Err_Ok;
d418 1
a418 1
      error = TT_Err_Too_Many_Hints;
d425 1
a425 1
      error = TT_Err_Too_Many_Hints;
d555 1
a555 1
    error = TT_Err_Invalid_Outline;
d676 1
a676 1
    error = TT_Err_Invalid_Composite;
d829 1
a829 1
    return TT_Err_Ok;
d847 1
a847 1
    FT_Error        error   = TT_Err_Ok;
d916 5
a920 3
      x_scale_factor = scale_test_tweak( face, family, ppem, style,
                                         loader->glyph_index, X_SCALING_Rules,
                                         X_SCALING_RULES_SIZE );
d1027 1
a1027 1
        return TT_Err_Invalid_Composite;
d1041 1
a1041 1
        return TT_Err_Ok;
d1086 4
a1089 10
        FT_Fixed  mac_xscale = FT_SqrtFixed(
                                 (FT_Int32)FT_MulFix( subglyph->transform.xx,
                                                      subglyph->transform.xx ) +
                                 (FT_Int32)FT_MulFix( subglyph->transform.xy,
                                                      subglyph->transform.xy ) );
        FT_Fixed  mac_yscale = FT_SqrtFixed(
                                 (FT_Int32)FT_MulFix( subglyph->transform.yy,
                                                      subglyph->transform.yy ) +
                                 (FT_Int32)FT_MulFix( subglyph->transform.yx,
                                                      subglyph->transform.yx ) );
d1121 1
a1121 1
    return TT_Err_Ok;
d1190 1
a1190 1
          return TT_Err_Too_Many_Hints;
d1204 1
a1204 1
        return TT_Err_Ok;
d1260 1
a1260 1
    FT_Error        error        = TT_Err_Ok;
d1283 1
a1283 1
      error = TT_Err_Invalid_Composite;
d1290 1
a1290 1
      error = TT_Err_Invalid_Glyph_Index;
d1354 1
a1354 1
        error = TT_Err_Invalid_Table;
d1421 1
a1421 1
      error = TT_Err_Ok;
d1635 1
a1635 1
      error = TT_Err_Invalid_Outline;
d1936 1
a1936 1
        return TT_Err_Could_Not_Find_Context;
a1945 1

d1951 2
d2000 3
d2017 3
d2079 1
a2079 1
      if ( error == TT_Err_Table_Missing )
d2107 1
a2107 1
    return TT_Err_Ok;
d2148 1
a2148 1
    error = TT_Err_Ok;
d2172 1
a2172 1
        return TT_Err_Ok;
d2180 1
a2180 1
      return TT_Err_Invalid_Size_Handle;
d2183 1
a2183 1
      return TT_Err_Invalid_Argument;
@


1.13
log
@Update to freetype-2.4.10.

With help and ok matthieu@@
@
text
@d35 1
d153 9
a264 4
#undef  IS_HINTED
#define IS_HINTED( flags )  ( ( flags & FT_LOAD_NO_HINTING ) == 0 )


d822 7
d851 8
d913 26
d946 1
d1699 7
d1711 6
d1718 1
d1898 1
d1900 1
d1915 10
d1942 45
d1990 2
d1994 32
d2042 2
@


1.12
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@a1985 1
    TT_Face       face;
d1990 1
a1990 2
    face   = (TT_Face)glyph->face;
    error  = TT_Err_Ok;
d2004 1
a2004 4
        FT_Face  root = &face->root;


        if ( FT_IS_SCALABLE( root ) )
@


1.11
log
@Update to freetype 2.4.5. Tested by many.
@
text
@d7 1
a7 1
/*  Copyright 1996-2011                                                    */
d365 1
a365 1
    prev_cont = FT_NEXT_USHORT( p );
d370 3
d375 1
a375 1
      cont[0] = FT_NEXT_USHORT( p );
d379 1
a379 2
        error = TT_Err_Invalid_Table;
        goto Fail;
a396 7
    /* we'd better check the contours table right now */
    outline = &gloader->current.outline;

    for ( cont = outline->contours + 1; cont < cont_limit; cont++ )
      if ( cont[-1] >= cont[0] )
        goto Invalid_Outline;

d436 2
@


1.10
log
@Update to freetype 2.4.3. Tested at least by krw@@, ajacoutot@@ and jasper@@
@
text
@d7 1
a7 2
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
d49 1
a49 1
  /* Composite font flags.                                                 */
d68 1
a68 3
  /* Returns the horizontal metrics in font units for a given glyph.  If   */
  /* `check' is true, take care of monospaced fonts by returning the       */
  /* advance width maximum.                                                */
a72 1
                   FT_Bool     check,
a77 3
    if ( check && face->postscript.isFixedPitch )
      *aw = face->horizontal.advance_Width_Max;

d85 1
a85 1
  /* Returns the vertical metrics in font units for a given glyph.         */
a92 3
  /* The monospace `check' is probably not meaningful here, but we leave   */
  /* it in for a consistent interface.                                     */
  /*                                                                       */
a95 1
                   FT_Bool     check,
a98 2
    FT_UNUSED( check );

a140 2
                     (FT_Bool)!( loader->load_flags &
                                 FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
a143 2
                     (FT_Bool)!( loader->load_flags &
                                 FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
d1642 1
a1642 17
    {
      FT_Pos  advance = loader->linear;


      /* the flag FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH was introduced to */
      /* correctly support DynaLab fonts, which have an incorrect       */
      /* `advance_Width_Max' field!  It is used, to my knowledge,       */
      /* exclusively in the X-TrueType font server.                     */
      /*                                                                */
      if ( face->postscript.isFixedPitch                                     &&
           ( loader->load_flags & FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ) == 0 )
        advance = face->horizontal.advance_Width_Max;

      /* we need to return the advance in font units in linearHoriAdvance, */
      /* it will be scaled later by the base layer.                        */
      glyph->linearHoriAdvance = advance;
    }
d1839 1
d1858 3
a1860 1
        FT_Error  error = tt_size_ready_bytecode( size );
d1890 1
a1890 1
        tt_size_run_prep( size );
a2019 3
          if ( face->postscript.isFixedPitch                             &&
               ( load_flags & FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ) == 0 )
            glyph->linearHoriAdvance = face->horizontal.advance_Width_Max;
@


1.9
log
@Update to freetype 2.4.2. This has been in snapshots for a while
and tested explicitely by ajacoutot@@ jasper@@, jcs@@, krw@@ and others
on various architectures.
@
text
@d1913 3
@


1.8
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d164 13
d179 10
d198 1
a198 1
      metrics.bearing_x = left_bearing;
d200 1
a200 1
      metrics.advance   = advance_width;
d216 2
a217 2
      metrics.bearing_y = top_bearing;
      metrics.advance   = advance_height;
d230 10
d243 2
a247 12
    loader->left_bearing = left_bearing;
    loader->advance      = advance_width;
    loader->top_bearing  = top_bearing;
    loader->vadvance     = advance_height;

    if ( !loader->linear_def )
    {
      loader->linear_def = 1;
      loader->linear     = advance_width;
    }
  }

d297 1
a297 1
    FT_TRACE5(( "Glyph %ld\n", glyph_index ));
d393 1
a393 1
        error = FT_Err_Invalid_Table;
d1144 2
a1145 1
      FT_UShort  n_ins;
d1157 2
a1158 1
      if ( n_ins > ((TT_Face)loader->face)->max_profile.maxSizeOfInstructions )
d1160 8
a1167 2
        FT_TRACE0(( "TT_Process_Composite_Glyph: too many instructions (%d)\n",
                    n_ins ));
d1169 9
a1177 1
        return TT_Err_Too_Many_Hints;
d1358 2
d1362 4
d1401 2
d1405 4
d1535 1
d1590 2
a1591 1
        loader->stream = old_stream;
d2087 5
a2091 3
        /* In case bit 1 of the `flags' field in the `head' table isn't */
        /* set, translate array so that (0,0) is the glyph's origin.    */
        if ( ( face->header.Flags & 2 ) == 0 && loader.pp1.x )
@


1.7
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d7 2
a8 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d73 1
a73 1
  FT_LOCAL_DEF(void)
d84 3
d103 1
a103 1
  FT_LOCAL_DEF(void)
d138 85
d409 1
a409 1
      FT_TRACE0(( "TT_Load_Simple_Glyph: Too many instructions (%d)\n",
d417 1
a417 1
      FT_TRACE0(( "TT_Load_Simple_Glyph: Instruction count mismatch!\n" ));
d725 7
a731 1
    n_ins = loader->glyph->control_len;
d778 3
d796 4
d1034 4
a1037 4
                                 FT_MulFix( subglyph->transform.xx,
                                            subglyph->transform.xx ) +
                                 FT_MulFix( subglyph->transform.xy,
                                            subglyph->transform.xy ) );
d1039 4
a1042 4
                                 FT_MulFix( subglyph->transform.yy,
                                            subglyph->transform.yy ) +
                                 FT_MulFix( subglyph->transform.yx,
                                            subglyph->transform.yx ) );
d1135 1
a1135 1
        FT_TRACE0(( "TT_Process_Composite_Glyph: Too many instructions (%d)\n",
d1158 1
a1158 2
      loader->zone.tags[i] &= ~( FT_CURVE_TAG_TOUCH_X |
                                 FT_CURVE_TAG_TOUCH_Y );
d1194 2
a1195 1
                       FT_UInt    recurse_count )
d1197 1
a1197 1
    FT_Error        error;
d1244 1
a1244 69
    /* get metrics, horizontal and vertical */
    {
      FT_Short   left_bearing = 0, top_bearing = 0;
      FT_UShort  advance_width = 0, advance_height = 0;


      TT_Get_HMetrics( face, glyph_index,
                       (FT_Bool)!( loader->load_flags &
                                   FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                       &left_bearing,
                       &advance_width );
      TT_Get_VMetrics( face, glyph_index,
                       (FT_Bool)!( loader->load_flags &
                                   FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                       &top_bearing,
                       &advance_height );

#ifdef FT_CONFIG_OPTION_INCREMENTAL

      /* If this is an incrementally loaded font see if there are */
      /* overriding metrics for this glyph.                       */
      if ( face->root.internal->incremental_interface &&
           face->root.internal->incremental_interface->funcs->get_glyph_metrics )
      {
        FT_Incremental_MetricsRec  metrics;


        metrics.bearing_x = left_bearing;
        metrics.bearing_y = 0;
        metrics.advance = advance_width;
        error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                  face->root.internal->incremental_interface->object,
                  glyph_index, FALSE, &metrics );
        if ( error )
          goto Exit;
        left_bearing  = (FT_Short)metrics.bearing_x;
        advance_width = (FT_UShort)metrics.advance;

#if 0

        /* GWW: Do I do the same for vertical metrics? */
        metrics.bearing_x = 0;
        metrics.bearing_y = top_bearing;
        metrics.advance = advance_height;
        error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                  face->root.internal->incremental_interface->object,
                  glyph_index, TRUE, &metrics );
        if ( error )
          goto Exit;
        top_bearing  = (FT_Short)metrics.bearing_y;
        advance_height = (FT_UShort)metrics.advance;

#endif /* 0 */

      }

#endif /* FT_CONFIG_OPTION_INCREMENTAL */

      loader->left_bearing = left_bearing;
      loader->advance      = advance_width;
      loader->top_bearing  = top_bearing;
      loader->vadvance     = advance_height;

      if ( !loader->linear_def )
      {
        loader->linear_def = 1;
        loader->linear     = advance_width;
      }
    }
d1282 5
d1288 1
d1290 1
a1290 1
        FT_TRACE2(( "no `glyf' table but non-zero `loca' entry!\n" ));
d1303 1
a1303 1
      /* read first glyph header */
d1305 1
a1305 1
      if ( error )
d1316 3
d1434 5
a1438 2
            subglyph->arg1 += deltas[i].x;
            subglyph->arg2 += deltas[i].y;
d1508 1
a1508 1
                                       recurse_count + 1 );
d1628 18
a1645 3
    /* Now take care of vertical metrics.  In the case where there is    */
    /* no vertical information within the font (relatively common), make */
    /* up some metrics by `hand'...                                      */
d1647 3
d1656 1
a1656 1
      if ( face->vertical_info &&
d1731 1
a1731 1
        top     = FT_MulFix( top, y_scale );
d1738 2
a1739 1
      glyph->metrics.vertBearingX = ( bbox.xMin - bbox.xMax ) / 2;
a1743 19
    /* adjust advance width to the value contained in the hdmx table */
    if ( !face->postscript.isFixedPitch  &&
         IS_HINTED( loader->load_flags ) )
    {
      FT_Byte*  widthp;


      widthp = tt_face_get_device_metrics( face,
                                           size->root.metrics.x_ppem,
                                           glyph_index );

      if ( widthp )
        glyph->metrics.horiAdvance = *widthp << 6;
    }

    /* set glyph dimensions */
    glyph->metrics.width  = bbox.xMax - bbox.xMin;
    glyph->metrics.height = bbox.yMax - bbox.yMin;

d1791 1
d1814 2
a1815 1
                  FT_Int32      load_flags )
d1829 1
a1829 1
    if ( IS_HINTED( load_flags ) )
d1902 1
a1902 1
        FT_ERROR(( "TT_Load_Glyph: could not access glyph table\n" ));
d1910 1
d1982 17
d2000 1
d2012 1
a2012 1
    error = tt_loader_init( &loader, size, glyph, load_flags );
d2021 1
a2021 1
    error = load_truetype_glyph( &loader, glyph_index, 0 );
d2068 1
a2068 1
        else 
@


1.6
log
@Update to Freetype 2.3.7. This is a bug fix release. No API change.
@
text
@d72 6
a77 6
  static void
  Get_HMetrics( TT_Face     face,
                FT_UInt     idx,
                FT_Bool     check,
                FT_Short*   lsb,
                FT_UShort*  aw )
d99 6
a104 6
  static void
  Get_VMetrics( TT_Face     face,
                FT_UInt     idx,
                FT_Bool     check,
                FT_Short*   tsb,
                FT_UShort*  ah )
d385 2
a386 2
      FT_Pos  y = 0;
      FT_Byte f = *flag;
d408 2
a409 1
      *flag  = f & ~( 2 | 16 );
d421 2
a422 2
      FT_Pos  y = 0;
      FT_Byte f = *flag;
d444 2
a445 1
      *flag  = f & FT_CURVE_TAG_ON;
d1148 10
a1157 10
      Get_HMetrics( face, glyph_index,
                    (FT_Bool)!( loader->load_flags &
                                FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                    &left_bearing,
                    &advance_width );
      Get_VMetrics( face, glyph_index,
                    (FT_Bool)!( loader->load_flags &
                                FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                    &top_bearing,
                    &advance_height );
d1248 7
d1850 3
a1852 1
      if ( error )
d1857 2
a1858 1
      loader->glyf_offset = FT_STREAM_POS();
d1870 1
a1870 1
    loader->load_flags    = load_flags;
@


1.5
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d560 4
a563 4
      /* we must undo the FT_FRAME_ENTER in order to point to the */
      /* composite instructions, if we find some.               */
      /* we will process them later...                          */
      /*                                                        */
d1671 2
a1672 2
    if ( !face->postscript.isFixedPitch &&
         IS_HINTED( loader->load_flags )        )
d1960 34
@


1.4
log
@More bits for freetype 2.3.5
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d270 5
a274 1
    cont[0] = prev_cont = FT_NEXT_USHORT( p );
d646 20
d729 1
a729 1
    FT_UInt         n_points;
d756 1
a756 1
      FT_UInt     i;
d1111 4
a1114 1
    if ( recurse_count > face->max_profile.maxComponentDepth )
d1244 17
a1260 1
    if ( loader->byte_len == 0 )
a1261 2
      /* as described by Frederic Loyer, these are spaces or */
      /* the unknown glyph.                                  */
a1303 13
    error = face->access_glyph_frame( loader, glyph_index,
                                      loader->glyf_offset + offset,
                                      loader->byte_len );
    if ( error )
      goto Exit;

    opened_frame = 1;

    /* read first glyph header */
    error = face->read_glyph_header( loader );
    if ( error )
      goto Exit;

d1312 1
a1312 1
    if ( loader->n_contours >= 0 )
d1421 2
a1422 2
        FT_UInt           n, num_base_points;
        FT_SubGlyph       subglyph       = 0;
d1424 3
a1426 3
        FT_UInt           num_points     = start_point;
        FT_UInt           num_subglyphs  = gloader->current.num_subglyphs;
        FT_UInt           num_base_subgs = gloader->base.num_subglyphs;
d1428 1
a1428 1
        FT_Stream         old_stream     = loader->stream;
a1429 5
        TT_GraphicsState  saved_GS;


        if ( loader->exec )
          saved_GS = loader->exec->GS;
a1437 4

          /* reinitialize graphics state */
          if ( loader->exec )
            loader->exec->GS = saved_GS;
@


1.3
log
@Merge freetype 2.3.5. Tested by naddy@@ and mbalmer@@.
@
text
@d705 1
a705 1
    FT_Int          n_points;
d732 1
a732 1
      FT_Int      i;
@


1.2
log
@Fix for CVE-2007-2754: integer overflow that can lead to an heap overflow.
Discovered by Victor Stinner. Patch from Freetype repository.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d111 1
a111 1
#if 1             /* Emperically determined, at variance with what MS said */
d191 3
d211 2
a212 2
    FT_Stream  stream   = loader->stream;
    FT_Int     byte_len = loader->byte_len - 10;
d215 1
a215 1
    if ( byte_len < 0 )
d218 1
a218 1
    loader->n_contours = FT_GET_SHORT();
d220 4
a223 4
    loader->bbox.xMin = FT_GET_SHORT();
    loader->bbox.yMin = FT_GET_SHORT();
    loader->bbox.xMax = FT_GET_SHORT();
    loader->bbox.yMax = FT_GET_SHORT();
d230 1
a230 1
    loader->byte_len = byte_len;
d240 2
a241 1
    FT_Stream       stream     = load->stream;
d247 1
a247 2
    FT_Int          n, n_points;
    FT_Int          byte_len   = load->byte_len;
d253 2
a254 1
    FT_Short        *cont, *cont_limit;
d267 1
a267 2
    byte_len -= 2 * ( n_contours + 1 );
    if ( byte_len < 0 )
d270 12
a281 2
    for ( ; cont < cont_limit; cont++ )
      cont[0] = FT_GET_USHORT();
d307 4
a310 1
    n_ins = FT_GET_USHORT();
d316 2
a317 1
      FT_TRACE0(( "TT_Load_Simple_Glyph: Too many instructions!\n" ));
d322 1
a322 2
    byte_len -= (FT_Int)n_ins;
    if ( byte_len < 0 )
d329 1
a329 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d336 1
a336 1
      FT_MEM_COPY( load->exec->glyphIns, stream->cursor, (FT_Long)n_ins );
d339 1
a339 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d341 1
a341 1
    stream->cursor += (FT_Int)n_ins;
d351 1
a351 1
      if ( --byte_len < 0 )
d354 1
a354 1
      *flag++ = c = FT_GET_BYTE();
d357 1
a357 1
        if ( --byte_len < 0 )
d360 1
a360 1
        count = FT_GET_BYTE();
a368 17
    /* check that there is enough room to load the coordinates */
    for ( flag = (FT_Byte*)outline->tags; flag < flag_limit; flag++ )
    {
      if ( *flag & 2 )
        byte_len -= 1;
      else if ( ( *flag & 16 ) == 0 )
        byte_len -= 2;

      if ( *flag & 4 )
        byte_len -= 1;
      else if ( ( *flag & 32 ) == 0 )
        byte_len -= 2;
    }

    if ( byte_len < 0 )
      goto Invalid_Outline;

d376 3
d382 1
d385 1
a385 1
      if ( *flag & 2 )
d387 5
a391 2
        y = (FT_Pos)FT_GET_BYTE();
        if ( ( *flag & 16 ) == 0 )
d394 7
a400 2
      else if ( ( *flag & 16 ) == 0 )
        y = (FT_Pos)FT_GET_SHORT();
d404 1
d417 1
d420 1
a420 1
      if ( *flag & 4 )
d422 5
a426 2
        y = (FT_Pos)FT_GET_BYTE();
        if ( ( *flag & 32 ) == 0 )
d429 7
a435 2
      else if ( ( *flag & 32 ) == 0 )
        y = (FT_Pos)FT_GET_SHORT();
d439 1
a441 4
    /* clear the touch tags */
    for ( n = 0; n < n_points; n++ )
      outline->tags[n] &= FT_CURVE_TAG_ON;

d445 1
a445 1
    load->byte_len = byte_len;
d460 2
a461 1
    FT_Stream       stream  = loader->stream;
a464 1
    FT_Int          byte_len = loader->byte_len;
d472 1
d481 1
a481 2
      byte_len -= 4;
      if ( byte_len < 0 )
d488 2
a489 2
      subglyph->flags = FT_GET_USHORT();
      subglyph->index = FT_GET_USHORT();
d492 1
a492 1
      byte_len -= 2;
d494 1
a494 1
        byte_len -= 2;
d496 1
a496 1
        byte_len -= 2;
d498 1
a498 1
        byte_len -= 4;
d500 1
a500 1
        byte_len -= 8;
d502 1
a502 1
      if ( byte_len < 0 )
d508 2
a509 2
        subglyph->arg1 = FT_GET_SHORT();
        subglyph->arg2 = FT_GET_SHORT();
d513 2
a514 2
        subglyph->arg1 = FT_GET_CHAR();
        subglyph->arg2 = FT_GET_CHAR();
d523 1
a523 1
        xx = (FT_Fixed)FT_GET_SHORT() << 2;
d528 2
a529 2
        xx = (FT_Fixed)FT_GET_SHORT() << 2;
        yy = (FT_Fixed)FT_GET_SHORT() << 2;
d533 4
a536 4
        xx = (FT_Fixed)FT_GET_SHORT() << 2;
        yx = (FT_Fixed)FT_GET_SHORT() << 2;
        xy = (FT_Fixed)FT_GET_SHORT() << 2;
        yy = (FT_Fixed)FT_GET_SHORT() << 2;
d550 1
a550 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d553 3
d561 1
a561 1
                                    stream->cursor - stream->limit );
d566 1
a566 1
    loader->byte_len = byte_len;
d594 9
a602 6
    zone->n_points   = (FT_UShort)( load->outline.n_points - start_point );
    zone->n_contours = (FT_Short) ( load->outline.n_contours - start_contour );
    zone->org        = load->extra_points + start_point;
    zone->cur        = load->outline.points + start_point;
    zone->tags       = (FT_Byte*)load->outline.tags + start_point;
    zone->contours   = (FT_UShort*)load->outline.contours + start_contour;
a614 3
#define cur_to_org( n, zone ) \
          FT_ARRAY_COPY( (zone)->org, (zone)->cur, (n) )

d622 1
a622 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d629 1
a629 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d638 2
a639 2
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
    /* save original point positioin in org */
d641 1
a641 1
      cur_to_org( zone->n_points, zone );
d650 1
a650 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d666 2
a667 2
      debug = !( loader->load_flags & FT_LOAD_NO_SCALE ) &&
              ( (TT_Size)loader->size )->debug;
d753 8
a783 1
      tt_prepare_zone( &loader->zone, &gloader->current, 0, 0 );
d957 1
a957 1
  /*    it's sole purpose is to hint the glyph.  Thus this function is     */
d967 1
d989 1
a989 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d1007 2
a1008 1
        FT_TRACE0(( "Too many instructions (%d)\n", n_ins ));
d1026 7
d1308 3
a1310 3
      FT_UInt       start_point;
      FT_UInt       start_contour;
      FT_ULong      ins_pos;  /* position of composite instructions, if any */
d1340 5
a1344 5
        if ( (error = TT_Vary_Get_Glyph_Deltas(
                        face,
                        glyph_index,
                        &deltas,
                        gloader->current.num_subglyphs + 4 )) != 0 )
a1379 1
      /*                                                               */
d1393 8
a1400 2
        FT_UInt      n, num_base_points;
        FT_SubGlyph  subglyph       = 0;
d1402 1
a1402 3
        FT_UInt      num_points     = start_point;
        FT_UInt      num_subglyphs  = gloader->current.num_subglyphs;
        FT_UInt      num_base_subgs = gloader->base.num_subglyphs;
d1405 3
d1416 4
d1454 6
a1459 6
          /* gloader->base.outline consists of three part:                  */
          /* 0 -(1)-> start_point -(2)-> num_base_points -(3)-> n_points.   */
          /*                                                                */
          /* (1): exist from the beginning                                  */
          /* (2): components that have been loaded so far                   */
          /* (3): the newly loaded component                                */
d1464 1
d1470 1
a1470 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d1483 1
a1483 1
      /* invalid composite count ( negative but not -1 ) */
d1511 2
a1512 2
  compute_glyph_metrics( TT_Loader   loader,
                         FT_UInt     glyph_index )
d1530 2
a1531 2
    /* get the device-independent horizontal advance.  It is scaled later */
    /* by the base layer.                                                 */
d1750 1
a1750 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d1753 1
d1756 1
d1759 7
d1772 3
d1777 15
a1791 1
      /* see if the cvt program has disabled hinting */
d1795 1
a1795 1
      /* load default graphics state - if needed */
a1799 3
      exec->grayscale =
        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) != FT_LOAD_TARGET_MONO );

d1804 1
a1804 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d1806 1
a1806 1
    /* seek to the beginning of the glyph table.  For Type 42 fonts      */
a1883 1
    FT_Stream     stream;
a1888 1
    stream = face->root.stream;
d1922 1
a1922 1
    /* Main loading loop */
@


1.1
log
@Initial revision
@
text
@d272 1
d274 3
d684 1
a684 1
    FT_UInt         n_points;
d711 1
a711 1
      FT_UInt     i;
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d111 1
a111 1
#if 1             /* Empirically determined, at variance with what MS said */
a190 3
    loader->cursor = stream->cursor;
    loader->limit  = stream->limit;

d208 2
a209 2
    FT_Byte*  p     = loader->cursor;
    FT_Byte*  limit = loader->limit;
d212 1
a212 1
    if ( p + 10 > limit )
d215 1
a215 1
    loader->n_contours = FT_NEXT_SHORT( p );
d217 4
a220 4
    loader->bbox.xMin = FT_NEXT_SHORT( p );
    loader->bbox.yMin = FT_NEXT_SHORT( p );
    loader->bbox.xMax = FT_NEXT_SHORT( p );
    loader->bbox.yMax = FT_NEXT_SHORT( p );
d227 1
a227 1
    loader->cursor = p;
d237 1
a237 2
    FT_Byte*        p          = load->cursor;
    FT_Byte*        limit      = load->limit;
d243 2
a244 1
    FT_Int          n_points;
d250 1
a250 2
    FT_Short        *cont, *cont_limit, prev_cont;
    FT_Int          xy_size = 0;
d263 2
a264 1
    if ( n_contours >= 0xFFF || p + ( n_contours + 1 ) * 2 > limit )
d267 2
a268 12
    cont[0] = prev_cont = FT_NEXT_USHORT( p );
    for ( cont++; cont < cont_limit; cont++ )
    {
      cont[0] = FT_NEXT_USHORT( p );
      if ( cont[0] <= prev_cont )
      {
        /* unordered contours: this is invalid */
        error = FT_Err_Invalid_Table;
        goto Fail;
      }
      prev_cont = cont[0];
    }
a271 1
    {
a272 3
      if ( n_points < 0 )
        goto Invalid_Outline;
    }
d290 1
a290 4
    if ( p + 2 > limit )
      goto Invalid_Outline;

    n_ins = FT_NEXT_USHORT( p );
d296 1
a296 2
      FT_TRACE0(( "TT_Load_Simple_Glyph: Too many instructions (%d)\n",
                  n_ins ));
d301 2
a302 1
    if ( ( limit - p ) < n_ins )
d309 1
a309 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d316 1
a316 1
      FT_MEM_COPY( load->exec->glyphIns, p, (FT_Long)n_ins );
d319 1
a319 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d321 1
a321 1
    p += n_ins;
d331 1
a331 1
      if ( p + 1 > limit )
d334 1
a334 1
      *flag++ = c = FT_NEXT_BYTE( p );
d337 1
a337 1
        if ( p + 1 > limit )
d340 1
a340 1
        count = FT_NEXT_BYTE( p );
d349 17
a372 3
    if ( p + xy_size > limit )
      goto Invalid_Outline;

a375 1
      FT_Byte f = *flag;
d378 1
a378 1
      if ( f & 2 )
d380 2
a381 5
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_BYTE( p );
        if ( ( f & 16 ) == 0 )
d384 2
a385 7
      else if ( ( f & 16 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_SHORT( p );
      }
a388 1
      *flag  = f & ~( 2 | 16 );
a400 1
      FT_Byte f = *flag;
d403 1
a403 1
      if ( f & 4 )
d405 2
a406 5
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_BYTE( p );
        if ( ( f & 32 ) == 0 )
d409 2
a410 7
      else if ( ( f & 32 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_SHORT( p );
      }
a413 1
      *flag  = f & FT_CURVE_TAG_ON;
d416 4
d423 1
a423 1
    load->cursor = p;
d438 1
a438 2
    FT_Byte*        p       = loader->cursor;
    FT_Byte*        limit   = loader->limit;
d442 1
a449 1
      FT_UInt   count;
d458 2
a459 1
      if ( p + 4 > limit )
d466 2
a467 2
      subglyph->flags = FT_NEXT_USHORT( p );
      subglyph->index = FT_NEXT_USHORT( p );
d470 1
a470 1
      count = 2;
d472 1
a472 1
        count += 2;
d474 1
a474 1
        count += 2;
d476 1
a476 1
        count += 4;
d478 1
a478 1
        count += 8;
d480 1
a480 1
      if ( p + count > limit )
d486 2
a487 2
        subglyph->arg1 = FT_NEXT_SHORT( p );
        subglyph->arg2 = FT_NEXT_SHORT( p );
d491 2
a492 2
        subglyph->arg1 = FT_NEXT_CHAR( p );
        subglyph->arg2 = FT_NEXT_CHAR( p );
d501 1
a501 1
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d506 2
a507 2
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d511 4
a514 4
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        xy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d528 1
a528 1
#ifdef TT_USE_BYTECODE_INTERPRETER
a530 3
      FT_Stream  stream = loader->stream;


d536 1
a536 1
                                    p - limit );
d541 1
a541 1
    loader->cursor = p;
d569 6
a574 9
    zone->n_points    = (FT_UShort)( load->outline.n_points - start_point );
    zone->n_contours  = (FT_Short) ( load->outline.n_contours -
                                       start_contour );
    zone->org         = load->extra_points + start_point;
    zone->cur         = load->outline.points + start_point;
    zone->orus        = load->extra_points2 + start_point;
    zone->tags        = (FT_Byte*)load->outline.tags + start_point;
    zone->contours    = (FT_UShort*)load->outline.contours + start_contour;
    zone->first_point = (FT_UShort)start_point;
d587 3
d597 1
a597 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d604 1
a604 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d613 2
a614 2
#ifdef TT_USE_BYTECODE_INTERPRETER
    /* save original point position in org */
d616 1
a616 1
      FT_ARRAY_COPY( zone->org, zone->cur, zone->n_points );
d625 1
a625 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d641 2
a642 2
      debug = FT_BOOL( !( loader->load_flags & FT_LOAD_NO_SCALE ) &&
                       ((TT_Size)loader->size)->debug             );
a727 8
    if ( IS_HINTED( loader->load_flags ) )
    {
      tt_prepare_zone( &loader->zone, &gloader->current, 0, 0 );

      FT_ARRAY_COPY( loader->zone.orus, loader->zone.cur,
                     loader->zone.n_points + 4 );
    }

d751 1
d925 1
a925 1
  /*    its sole purpose is to hint the glyph.  Thus this function is      */
a934 1
    FT_UInt      i;
d956 1
a956 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d974 1
a974 2
        FT_TRACE0(( "TT_Process_Composite_Glyph: Too many instructions (%d)\n",
                    n_ins ));
a991 7

    /* Some points are likely touched during execution of  */
    /* instructions on components.  So let's untouch them. */
    for ( i = start_point; i < loader->zone.n_points; i++ )
      loader->zone.tags[i] &= ~( FT_CURVE_TAG_TOUCH_X |
                                 FT_CURVE_TAG_TOUCH_Y );

d1267 3
a1269 3
      FT_UInt   start_point;
      FT_UInt   start_contour;
      FT_ULong  ins_pos;  /* position of composite instructions, if any */
d1299 5
a1303 5
        if ( ( error = TT_Vary_Get_Glyph_Deltas(
                         face,
                         glyph_index,
                         &deltas,
                         gloader->current.num_subglyphs + 4 )) != 0 )
d1339 1
d1353 2
a1354 8
        FT_UInt           n, num_base_points;
        FT_SubGlyph       subglyph       = 0;

        FT_UInt           num_points     = start_point;
        FT_UInt           num_subglyphs  = gloader->current.num_subglyphs;
        FT_UInt           num_base_subgs = gloader->base.num_subglyphs;

        FT_Stream         old_stream     = loader->stream;
d1356 3
a1358 1
        TT_GraphicsState  saved_GS;
a1360 3
        if ( loader->exec )
          saved_GS = loader->exec->GS;

a1368 4
          /* reinitialize graphics state */
          if ( loader->exec )
            loader->exec->GS = saved_GS;

d1403 6
a1408 6
          /* gloader->base.outline consists of three parts:               */
          /* 0 -(1)-> start_point -(2)-> num_base_points -(3)-> n_points. */
          /*                                                              */
          /* (1): exists from the beginning                               */
          /* (2): components that have been loaded so far                 */
          /* (3): the newly loaded component                              */
a1412 1
        loader->stream = old_stream;
d1418 1
a1418 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d1431 1
a1431 1
      /* invalid composite count (negative but not -1) */
d1459 2
a1460 2
  compute_glyph_metrics( TT_Loader  loader,
                         FT_UInt    glyph_index )
d1478 2
a1479 2
    /* get the device-independent horizontal advance; it is scaled later */
    /* by the base layer.                                                */
d1698 1
a1698 1
#ifdef TT_USE_BYTECODE_INTERPRETER
a1700 1
    if ( IS_HINTED( load_flags ) )
a1702 1
      FT_Bool         grayscale;
a1704 7
      if ( !size->cvt_ready )
      {
        FT_Error  error = tt_size_ready_bytecode( size );
        if ( error )
          return error;
      }

a1710 3
      grayscale =
        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) != FT_RENDER_MODE_MONO );

d1713 1
a1713 15
      /* a change from mono to grayscale rendering (and vice versa) */
      /* requires a re-execution of the CVT program                 */
      if ( grayscale != exec->grayscale )
      {
        FT_UInt  i;


        exec->grayscale = grayscale;

        for ( i = 0; i < size->cvt_size; i++ )
          size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );
        tt_size_run_prep( size );
      }

      /* see whether the cvt program has disabled hinting */
d1717 1
a1717 1
      /* load default graphics state -- if needed */
d1722 3
d1729 1
a1729 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d1731 1
a1731 1
    /* seek to the beginning of the glyph table -- for Type 42 fonts     */
d1809 1
d1815 1
d1849 1
a1849 1
    /* main loading loop */
@

