head	1.18;
access;
symbols
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.2
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2017.01.13.11.20.00;	author dcoppa;	state Exp;
branches;
next	1.17;
commitid	ESXG9TuEmwmBXggf;

1.17
date	2016.10.28.21.41.15;	author dcoppa;	state Exp;
branches;
next	1.16;
commitid	T2hf37tVZU8TmjB1;

1.16
date	2016.08.09.07.16.10;	author dcoppa;	state Exp;
branches;
next	1.15;
commitid	C8TgUUJolulx9B5d;

1.15
date	2016.05.29.11.57.14;	author dcoppa;	state Exp;
branches;
next	1.14;
commitid	1dOLexdOAzW2mQjp;

1.14
date	2015.12.07.09.34.04;	author dcoppa;	state Exp;
branches;
next	1.13;
commitid	wZOPiDmcwgRFTDVL;

1.13
date	2015.06.28.08.27.50;	author dcoppa;	state Exp;
branches;
next	1.12;
commitid	qXwIGV2h9uFjxAmt;

1.12
date	2015.01.10.17.17.24;	author dcoppa;	state Exp;
branches;
next	1.11;
commitid	2tSYQMWVSV3t7clo;

1.11
date	2014.12.26.17.52.36;	author dcoppa;	state Exp;
branches;
next	1.10;
commitid	gwhRExMduYqoPQHI;

1.10
date	2014.01.12.15.08.28;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.10.19.49.58;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.21.11;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.01.04.16.51.59;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.04.14.09.45.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.16.21.18.14;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.18.20.29.59;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.25.20.49.55;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.10.20.28.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.45.01;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.45.01;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.32.15;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ttdriver.c                                                             */
/*                                                                         */
/*    TrueType font driver implementation (body).                          */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_STREAM_H
#include FT_INTERNAL_SFNT_H
#include FT_SERVICE_FONT_FORMAT_H

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#include FT_MULTIPLE_MASTERS_H
#include FT_SERVICE_MULTIPLE_MASTERS_H
#include FT_SERVICE_METRICS_VARIATIONS_H
#endif

#include FT_SERVICE_TRUETYPE_ENGINE_H
#include FT_SERVICE_TRUETYPE_GLYF_H
#include FT_SERVICE_PROPERTIES_H
#include FT_TRUETYPE_DRIVER_H

#include "ttdriver.h"
#include "ttgload.h"
#include "ttpload.h"

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#include "ttgxvar.h"
#endif

#include "tterrors.h"

#include "ttpic.h"

  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_ttdriver


  /*
   *  PROPERTY SERVICE
   *
   */
  static FT_Error
  tt_property_set( FT_Module    module,         /* TT_Driver */
                   const char*  property_name,
                   const void*  value,
                   FT_Bool      value_is_string )
  {
    FT_Error   error  = FT_Err_Ok;
    TT_Driver  driver = (TT_Driver)module;

#ifndef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
    FT_UNUSED( value_is_string );
#endif


    if ( !ft_strcmp( property_name, "interpreter-version" ) )
    {
      FT_UInt  interpreter_version;


#ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
      if ( value_is_string )
      {
        const char*  s = (const char*)value;


        interpreter_version = (FT_UInt)ft_strtol( s, NULL, 10 );
      }
      else
#endif
      {
        FT_UInt*  iv = (FT_UInt*)value;


        interpreter_version = *iv;
      }

      if ( interpreter_version == TT_INTERPRETER_VERSION_35
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
           || interpreter_version == TT_INTERPRETER_VERSION_38
#endif
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
           || interpreter_version == TT_INTERPRETER_VERSION_40
#endif
         )
        driver->interpreter_version = interpreter_version;
      else
        error = FT_ERR( Unimplemented_Feature );

      return error;
    }

    FT_TRACE0(( "tt_property_set: missing property `%s'\n",
                property_name ));
    return FT_THROW( Missing_Property );
  }


  static FT_Error
  tt_property_get( FT_Module    module,         /* TT_Driver */
                   const char*  property_name,
                   const void*  value )
  {
    FT_Error   error  = FT_Err_Ok;
    TT_Driver  driver = (TT_Driver)module;

    FT_UInt  interpreter_version = driver->interpreter_version;


    if ( !ft_strcmp( property_name, "interpreter-version" ) )
    {
      FT_UInt*  val = (FT_UInt*)value;


      *val = interpreter_version;

      return error;
    }

    FT_TRACE0(( "tt_property_get: missing property `%s'\n",
                property_name ));
    return FT_THROW( Missing_Property );
  }


  FT_DEFINE_SERVICE_PROPERTIESREC(
    tt_service_properties,

    (FT_Properties_SetFunc)tt_property_set,     /* set_property */
    (FT_Properties_GetFunc)tt_property_get      /* get_property */
  )


  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****                                                                 ****/
  /****                          F A C E S                              ****/
  /****                                                                 ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_get_kerning                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A driver method used to return the kerning vector between two      */
  /*    glyphs of the same face.                                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face        :: A handle to the source face object.                 */
  /*                                                                       */
  /*    left_glyph  :: The index of the left glyph in the kern pair.       */
  /*                                                                       */
  /*    right_glyph :: The index of the right glyph in the kern pair.      */
  /*                                                                       */
  /* <Output>                                                              */
  /*    kerning     :: The kerning vector.  This is in font units for      */
  /*                   scalable formats, and in pixels for fixed-sizes     */
  /*                   formats.                                            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Only horizontal layouts (left-to-right & right-to-left) are        */
  /*    supported by this function.  Other layouts, or more sophisticated  */
  /*    kernings, are out of scope of this method (the basic driver        */
  /*    interface is meant to be simple).                                  */
  /*                                                                       */
  /*    They can be implemented by format-specific interfaces.             */
  /*                                                                       */
  static FT_Error
  tt_get_kerning( FT_Face     ttface,          /* TT_Face */
                  FT_UInt     left_glyph,
                  FT_UInt     right_glyph,
                  FT_Vector*  kerning )
  {
    TT_Face       face = (TT_Face)ttface;
    SFNT_Service  sfnt = (SFNT_Service)face->sfnt;


    kerning->x = 0;
    kerning->y = 0;

    if ( sfnt )
      kerning->x = sfnt->get_kerning( face, left_glyph, right_glyph );

    return 0;
  }


  static FT_Error
  tt_get_advances( FT_Face    ttface,
                   FT_UInt    start,
                   FT_UInt    count,
                   FT_Int32   flags,
                   FT_Fixed  *advances )
  {
    FT_UInt  nn;
    TT_Face  face = (TT_Face)ttface;


    /* XXX: TODO: check for sbits */

    if ( flags & FT_LOAD_VERTICAL_LAYOUT )
    {
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
      /* no fast retrieval for blended MM fonts without VVAR table */
      if ( !face->is_default_instance                               &&
           !( face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
        return FT_THROW( Unimplemented_Feature );
#endif

      for ( nn = 0; nn < count; nn++ )
      {
        FT_Short   tsb;
        FT_UShort  ah;


        /* since we don't need `tsb', we use zero for `yMax' parameter */
        TT_Get_VMetrics( face, start + nn, 0, &tsb, &ah );
        advances[nn] = ah;
      }
    }
    else
    {
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
      /* no fast retrieval for blended MM fonts without HVAR table */
      if ( !face->is_default_instance                               &&
           !( face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
        return FT_THROW( Unimplemented_Feature );
#endif

      for ( nn = 0; nn < count; nn++ )
      {
        FT_Short   lsb;
        FT_UShort  aw;


        TT_Get_HMetrics( face, start + nn, &lsb, &aw );
        advances[nn] = aw;
      }
    }

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****                                                                 ****/
  /****                           S I Z E S                             ****/
  /****                                                                 ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/


#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

  static FT_Error
  tt_size_select( FT_Size   size,
                  FT_ULong  strike_index )
  {
    TT_Face   ttface = (TT_Face)size->face;
    TT_Size   ttsize = (TT_Size)size;
    FT_Error  error  = FT_Err_Ok;


    ttsize->strike_index = strike_index;

    if ( FT_IS_SCALABLE( size->face ) )
    {
      /* use the scaled metrics, even when tt_size_reset fails */
      FT_Select_Metrics( size->face, strike_index );

      tt_size_reset( ttsize ); /* ignore return value */
    }
    else
    {
      SFNT_Service      sfnt    = (SFNT_Service)ttface->sfnt;
      FT_Size_Metrics*  metrics = &size->metrics;


      error = sfnt->load_strike_metrics( ttface, strike_index, metrics );
      if ( error )
        ttsize->strike_index = 0xFFFFFFFFUL;
    }

    return error;
  }

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */


  static FT_Error
  tt_size_request( FT_Size          size,
                   FT_Size_Request  req )
  {
    TT_Size   ttsize = (TT_Size)size;
    FT_Error  error  = FT_Err_Ok;


#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

    if ( FT_HAS_FIXED_SIZES( size->face ) )
    {
      TT_Face       ttface = (TT_Face)size->face;
      SFNT_Service  sfnt   = (SFNT_Service)ttface->sfnt;
      FT_ULong      strike_index;


      error = sfnt->set_sbit_strike( ttface, req, &strike_index );

      if ( error )
        ttsize->strike_index = 0xFFFFFFFFUL;
      else
        return tt_size_select( size, strike_index );
    }

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */

    FT_Request_Metrics( size->face, req );

    if ( FT_IS_SCALABLE( size->face ) )
    {
      error = tt_size_reset( ttsize );
      ttsize->root.metrics = ttsize->metrics;

#ifdef TT_USE_BYTECODE_INTERPRETER
      /* for the `MPS' bytecode instruction we need the point size */
      {
        FT_UInt  resolution = ttsize->metrics.x_ppem > ttsize->metrics.y_ppem
                                ? req->horiResolution
                                : req->vertResolution;


        /* if we don't have a resolution value, assume 72dpi */
        if ( req->type == FT_SIZE_REQUEST_TYPE_SCALES ||
             !resolution                              )
          resolution = 72;

        ttsize->point_size = FT_MulDiv( ttsize->ttmetrics.ppem,
                                        64 * 72,
                                        resolution );
      }
#endif
    }

    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_glyph_load                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A driver method used to load a glyph within a given glyph slot.    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    slot        :: A handle to the target slot object where the glyph  */
  /*                   will be loaded.                                     */
  /*                                                                       */
  /*    size        :: A handle to the source face size at which the glyph */
  /*                   must be scaled, loaded, etc.                        */
  /*                                                                       */
  /*    glyph_index :: The index of the glyph in the font file.            */
  /*                                                                       */
  /*    load_flags  :: A flag indicating what to load for this glyph.  The */
  /*                   FT_LOAD_XXX constants can be used to control the    */
  /*                   glyph loading process (e.g., whether the outline    */
  /*                   should be scaled, whether to load bitmaps or not,   */
  /*                   whether to hint the outline, etc).                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  static FT_Error
  tt_glyph_load( FT_GlyphSlot  ttslot,      /* TT_GlyphSlot */
                 FT_Size       ttsize,      /* TT_Size      */
                 FT_UInt       glyph_index,
                 FT_Int32      load_flags )
  {
    TT_GlyphSlot  slot = (TT_GlyphSlot)ttslot;
    TT_Size       size = (TT_Size)ttsize;
    FT_Face       face = ttslot->face;
    FT_Error      error;


    if ( !slot )
      return FT_THROW( Invalid_Slot_Handle );

    if ( !size )
      return FT_THROW( Invalid_Size_Handle );

    if ( !face )
      return FT_THROW( Invalid_Face_Handle );

#ifdef FT_CONFIG_OPTION_INCREMENTAL
    if ( glyph_index >= (FT_UInt)face->num_glyphs &&
         !face->internal->incremental_interface   )
#else
    if ( glyph_index >= (FT_UInt)face->num_glyphs )
#endif
      return FT_THROW( Invalid_Argument );

    if ( load_flags & FT_LOAD_NO_HINTING )
    {
      /* both FT_LOAD_NO_HINTING and FT_LOAD_NO_AUTOHINT   */
      /* are necessary to disable hinting for tricky fonts */

      if ( FT_IS_TRICKY( face ) )
        load_flags &= ~FT_LOAD_NO_HINTING;

      if ( load_flags & FT_LOAD_NO_AUTOHINT )
        load_flags |= FT_LOAD_NO_HINTING;
    }

    if ( load_flags & ( FT_LOAD_NO_RECURSE | FT_LOAD_NO_SCALE ) )
    {
      load_flags |= FT_LOAD_NO_BITMAP | FT_LOAD_NO_SCALE;

      if ( !FT_IS_TRICKY( face ) )
        load_flags |= FT_LOAD_NO_HINTING;
    }

    /* now load the glyph outline if necessary */
    error = TT_Load_Glyph( size, slot, glyph_index, load_flags );

    /* force drop-out mode to 2 - irrelevant now */
    /* slot->outline.dropout_mode = 2; */

    return error;
  }


  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****                                                                 ****/
  /****                D R I V E R  I N T E R F A C E                   ****/
  /****                                                                 ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT

  FT_DEFINE_SERVICE_MULTIMASTERSREC(
    tt_service_gx_multi_masters,

    (FT_Get_MM_Func)        NULL,                   /* get_mm         */
    (FT_Set_MM_Design_Func) NULL,                   /* set_mm_design  */
    (FT_Set_MM_Blend_Func)  TT_Set_MM_Blend,        /* set_mm_blend   */
    (FT_Get_MM_Blend_Func)  TT_Get_MM_Blend,        /* get_mm_blend   */
    (FT_Get_MM_Var_Func)    TT_Get_MM_Var,          /* get_mm_var     */
    (FT_Set_Var_Design_Func)TT_Set_Var_Design,      /* set_var_design */
    (FT_Get_Var_Design_Func)TT_Get_Var_Design,      /* get_var_design */

    (FT_Get_Var_Blend_Func) tt_get_var_blend,       /* get_var_blend  */
    (FT_Done_Blend_Func)    tt_done_blend           /* done_blend     */
  )

  FT_DEFINE_SERVICE_METRICSVARIATIONSREC(
    tt_service_metrics_variations,

    (FT_HAdvance_Adjust_Func)tt_hadvance_adjust,     /* hadvance_adjust */
    (FT_LSB_Adjust_Func)     NULL,                   /* lsb_adjust      */
    (FT_RSB_Adjust_Func)     NULL,                   /* rsb_adjust      */

    (FT_VAdvance_Adjust_Func)NULL,                   /* vadvance_adjust */
    (FT_TSB_Adjust_Func)     NULL,                   /* tsb_adjust      */
    (FT_BSB_Adjust_Func)     NULL,                   /* bsb_adjust      */
    (FT_VOrg_Adjust_Func)    NULL,                   /* vorg_adjust     */

    (FT_Metrics_Adjust_Func) NULL                    /* metrics_adjust  */
  )

#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */


  static const FT_Service_TrueTypeEngineRec  tt_service_truetype_engine =
  {
#ifdef TT_USE_BYTECODE_INTERPRETER

    FT_TRUETYPE_ENGINE_TYPE_PATENTED

#else /* !TT_USE_BYTECODE_INTERPRETER */

    FT_TRUETYPE_ENGINE_TYPE_NONE

#endif /* TT_USE_BYTECODE_INTERPRETER */
  };


  FT_DEFINE_SERVICE_TTGLYFREC(
    tt_service_truetype_glyf,

    (TT_Glyf_GetLocationFunc)tt_face_get_location      /* get_location */
  )


#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  FT_DEFINE_SERVICEDESCREC6(
    tt_services,

    FT_SERVICE_ID_FONT_FORMAT,        FT_FONT_FORMAT_TRUETYPE,
    FT_SERVICE_ID_MULTI_MASTERS,      &TT_SERVICE_GX_MULTI_MASTERS_GET,
    FT_SERVICE_ID_METRICS_VARIATIONS, &TT_SERVICE_METRICS_VARIATIONS_GET,
    FT_SERVICE_ID_TRUETYPE_ENGINE,    &tt_service_truetype_engine,
    FT_SERVICE_ID_TT_GLYF,            &TT_SERVICE_TRUETYPE_GLYF_GET,
    FT_SERVICE_ID_PROPERTIES,         &TT_SERVICE_PROPERTIES_GET )
#else
  FT_DEFINE_SERVICEDESCREC4(
    tt_services,

    FT_SERVICE_ID_FONT_FORMAT,     FT_FONT_FORMAT_TRUETYPE,
    FT_SERVICE_ID_TRUETYPE_ENGINE, &tt_service_truetype_engine,
    FT_SERVICE_ID_TT_GLYF,         &TT_SERVICE_TRUETYPE_GLYF_GET,
    FT_SERVICE_ID_PROPERTIES,      &TT_SERVICE_PROPERTIES_GET )
#endif


  FT_CALLBACK_DEF( FT_Module_Interface )
  tt_get_interface( FT_Module    driver,    /* TT_Driver */
                    const char*  tt_interface )
  {
    FT_Library           library;
    FT_Module_Interface  result;
    FT_Module            sfntd;
    SFNT_Service         sfnt;


    /* TT_SERVICES_GET dereferences `library' in PIC mode */
#ifdef FT_CONFIG_OPTION_PIC
    if ( !driver )
      return NULL;
    library = driver->library;
    if ( !library )
      return NULL;
#endif

    result = ft_service_list_lookup( TT_SERVICES_GET, tt_interface );
    if ( result )
      return result;

#ifndef FT_CONFIG_OPTION_PIC
    if ( !driver )
      return NULL;
    library = driver->library;
    if ( !library )
      return NULL;
#endif

    /* only return the default interface from the SFNT module */
    sfntd = FT_Get_Module( library, "sfnt" );
    if ( sfntd )
    {
      sfnt = (SFNT_Service)( sfntd->clazz->module_interface );
      if ( sfnt )
        return sfnt->get_interface( driver, tt_interface );
    }

    return 0;
  }


  /* The FT_DriverInterface structure is defined in ftdriver.h. */

#ifdef TT_USE_BYTECODE_INTERPRETER
#define TT_HINTER_FLAG  FT_MODULE_DRIVER_HAS_HINTER
#else
#define TT_HINTER_FLAG  0
#endif

#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
#define TT_SIZE_SELECT  tt_size_select
#else
#define TT_SIZE_SELECT  0
#endif

  FT_DEFINE_DRIVER(
    tt_driver_class,

      FT_MODULE_FONT_DRIVER     |
      FT_MODULE_DRIVER_SCALABLE |
      TT_HINTER_FLAG,

      sizeof ( TT_DriverRec ),

      "truetype",      /* driver name                           */
      0x10000L,        /* driver version == 1.0                 */
      0x20000L,        /* driver requires FreeType 2.0 or above */

      NULL,    /* module-specific interface */

      tt_driver_init,           /* FT_Module_Constructor  module_init   */
      tt_driver_done,           /* FT_Module_Destructor   module_done   */
      tt_get_interface,         /* FT_Module_Requester    get_interface */

    sizeof ( TT_FaceRec ),
    sizeof ( TT_SizeRec ),
    sizeof ( FT_GlyphSlotRec ),

    tt_face_init,               /* FT_Face_InitFunc  init_face */
    tt_face_done,               /* FT_Face_DoneFunc  done_face */
    tt_size_init,               /* FT_Size_InitFunc  init_size */
    tt_size_done,               /* FT_Size_DoneFunc  done_size */
    tt_slot_init,               /* FT_Slot_InitFunc  init_slot */
    NULL,                       /* FT_Slot_DoneFunc  done_slot */

    tt_glyph_load,              /* FT_Slot_LoadFunc  load_glyph */

    tt_get_kerning,             /* FT_Face_GetKerningFunc   get_kerning  */
    NULL,                       /* FT_Face_AttachFunc       attach_file  */
    tt_get_advances,            /* FT_Face_GetAdvancesFunc  get_advances */

    tt_size_request,            /* FT_Size_RequestFunc  request_size */
    TT_SIZE_SELECT              /* FT_Size_SelectFunc   select_size  */
  )


/* END */
@


1.17
log
@
Update to FreeType 2.7

Now Subpixel hinting, also known as ClearType hinting, is enabled
by default.

OK matthieu@@
@
text
@d28 1
d148 1
d150 2
a151 1
    (FT_Properties_GetFunc)tt_property_get )    /* get_property */
d227 1
a227 1
    TT_Face  face = (TT_Face) ttface;
d234 7
d254 7
d311 1
a311 1
      SFNT_Service      sfnt    = (SFNT_Service) ttface->sfnt;
d339 1
a339 1
      SFNT_Service  sfnt   = (SFNT_Service) ttface->sfnt;
d482 1
d485 1
d489 1
d491 23
a513 2
    (FT_Set_Var_Design_Func)TT_Set_Var_Design )     /* set_var_design */
#endif
d532 3
a534 1
    (TT_Glyf_GetLocationFunc)tt_face_get_location )    /* get_location */
d538 1
a538 1
  FT_DEFINE_SERVICEDESCREC5(
d540 7
a546 5
    FT_SERVICE_ID_FONT_FORMAT,     FT_FONT_FORMAT_TRUETYPE,
    FT_SERVICE_ID_MULTI_MASTERS,   &TT_SERVICE_GX_MULTI_MASTERS_GET,
    FT_SERVICE_ID_TRUETYPE_ENGINE, &tt_service_truetype_engine,
    FT_SERVICE_ID_TT_GLYF,         &TT_SERVICE_TRUETYPE_GLYF_GET,
    FT_SERVICE_ID_PROPERTIES,      &TT_SERVICE_PROPERTIES_GET )
d550 1
d578 1
a578 1
    if ( result != NULL )
d629 1
a629 1
      0,    /* module-specific interface */
d644 1
a644 1
    0,                          /* FT_Slot_DoneFunc  done_slot */
d649 1
a649 1
    0,                          /* FT_Face_AttachFunc       attach_file  */
@


1.16
log
@
Update to FreeType 2.6.5

ok matthieu@@
@
text
@d64 2
a65 1
                   const void*  value )
d70 4
d77 15
a91 1
      FT_UInt*  interpreter_version = (FT_UInt*)value;
d94 4
a97 1
      if ( *interpreter_version == TT_INTERPRETER_VERSION_35
d99 1
a99 1
           || *interpreter_version == TT_INTERPRETER_VERSION_38
d102 1
a102 1
           || *interpreter_version == TT_INTERPRETER_VERSION_40
d105 1
a105 1
        driver->interpreter_version = *interpreter_version;
d342 19
@


1.15
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d75 6
a80 4
#ifndef TT_CONFIG_OPTION_SUBPIXEL_HINTING
      if ( *interpreter_version != TT_INTERPRETER_VERSION_35 )
        error = FT_ERR( Unimplemented_Feature );
      else
d82 1
d84 2
@


1.14
log
@
Bugfixing update to freetype-2.6.2

Tested on amd64, i386, macppc, sparc64, loongson and compile-tested
on arm by matthieu@@
Also tested in a ports bulk build by naddy@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2015 by                                                 */
d197 1
a197 1
    TT_Face  face  = (TT_Face) ttface;
d231 1
a432 3
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    FT_TRUETYPE_ENGINE_TYPE_UNPATENTED
#else
a433 1
#endif
@


1.13
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d120 2
a121 2
    (FT_Properties_SetFunc)tt_property_set,
    (FT_Properties_GetFunc)tt_property_get )
d420 5
a424 5
    (FT_Get_MM_Func)        NULL,
    (FT_Set_MM_Design_Func) NULL,
    (FT_Set_MM_Blend_Func)  TT_Set_MM_Blend,
    (FT_Get_MM_Var_Func)    TT_Get_MM_Var,
    (FT_Set_Var_Design_Func)TT_Set_Var_Design )
d427 1
d445 1
d448 2
a449 1
    (TT_Glyf_GetLocationFunc)tt_face_get_location )
d540 1
a540 1
      (void*)0,        /* driver specific interface */
d542 3
a544 3
      tt_driver_init,
      tt_driver_done,
      tt_get_interface,
d550 12
a561 12
    tt_face_init,
    tt_face_done,
    tt_size_init,
    tt_size_done,
    tt_slot_init,
    0,                       /* FT_Slot_DoneFunc */

    tt_glyph_load,

    tt_get_kerning,
    0,                       /* FT_Face_AttachFunc */
    tt_get_advances,
d563 2
a564 2
    tt_size_request,
    TT_SIZE_SELECT
@


1.12
log
@
Bugfixing update to freetype-2.5.5

ok matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2014 by                                                 */
d23 1
a23 1
#include FT_SERVICE_XFREE86_NAME_H
a136 5
#undef  PAIR_TAG
#define PAIR_TAG( left, right )  ( ( (FT_ULong)left << 16 ) | \
                                     (FT_ULong)right        )


a188 3
#undef PAIR_TAG


d451 1
a451 1
    FT_SERVICE_ID_XF86_NAME,       FT_XF86_FORMAT_TRUETYPE,
d459 1
a459 1
    FT_SERVICE_ID_XF86_NAME,       FT_XF86_FORMAT_TRUETYPE,
@


1.11
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d484 1
a484 1
    /* TT_SERVICES_GET derefers `library' in PIC mode */
@


1.10
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d7 1
a7 1
/*  Copyright 1996-2013 by                                                 */
d270 1
a270 1
      tt_size_reset( ttsize );
d373 1
a373 1
      return FT_THROW( Invalid_Argument );
@


1.9
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@d218 2
a219 1
        TT_Get_VMetrics( face, start + nn, &tsb, &ah );
@


1.8
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@d32 2
d57 67
d456 1
a456 1
  FT_DEFINE_SERVICEDESCREC4(
d461 2
a462 1
    FT_SERVICE_ID_TT_GLYF,         &TT_SERVICE_TRUETYPE_GLYF_GET )
d464 1
a464 1
  FT_DEFINE_SERVICEDESCREC3(
d468 2
a469 1
    FT_SERVICE_ID_TT_GLYF,         &TT_SERVICE_TRUETYPE_GLYF_GET )
d531 2
a532 1
  FT_DEFINE_DRIVER( tt_driver_class,
a559 3

    ft_stub_set_char_sizes,  /* FT_CONFIG_OPTION_OLD_INTERNALS */
    ft_stub_set_pixel_sizes, /* FT_CONFIG_OPTION_OLD_INTERNALS */
@


1.7
log
@Update to freetype 2.4.11. Tested by krw@@, jasper@@ and on a bulk ports
build by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2012 by                                                 */
d166 1
a166 1
    return TT_Err_Ok;
d190 1
a190 1
    FT_Error  error  = TT_Err_Ok;
d224 1
a224 1
    FT_Error  error  = TT_Err_Ok;
d297 1
a297 1
      return TT_Err_Invalid_Slot_Handle;
d300 1
a300 1
      return TT_Err_Invalid_Size_Handle;
d303 1
a303 1
      return TT_Err_Invalid_Argument;
d311 1
a311 1
      return TT_Err_Invalid_Argument;
@


1.6
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@d356 2
a357 1
  FT_DEFINE_SERVICE_MULTIMASTERSREC(tt_service_gx_multi_masters,
d362 1
a362 2
    (FT_Set_Var_Design_Func)TT_Set_Var_Design
  )
d382 3
a384 3
  FT_DEFINE_SERVICE_TTGLYFREC(tt_service_truetype_glyf,
    (TT_Glyf_GetLocationFunc)tt_face_get_location
  )
d387 2
a388 1
  FT_DEFINE_SERVICEDESCREC4(tt_services,
d390 1
a390 1
    FT_SERVICE_ID_MULTI_MASTERS,   &FT_TT_SERVICE_GX_MULTI_MASTERS_GET,
d392 1
a392 2
    FT_SERVICE_ID_TT_GLYF,         &FT_TT_SERVICE_TRUETYPE_GLYF_GET
  )
d394 2
a395 1
  FT_DEFINE_SERVICEDESCREC3(tt_services,
d398 1
a398 2
    FT_SERVICE_ID_TT_GLYF,         &FT_TT_SERVICE_TRUETYPE_GLYF_GET
  )
d401 1
d412 1
a412 1
    /* FT_TT_SERVICES_GET derefers `library' in PIC mode */
d421 1
a421 1
    result = ft_service_list_lookup( FT_TT_SERVICES_GET, tt_interface );
d449 1
a449 1
#define TT_HINTER_FLAG   FT_MODULE_DRIVER_HAS_HINTER
d451 1
a451 1
#define TT_HINTER_FLAG   0
d455 1
a455 1
#define TT_SIZE_SELECT    tt_size_select
d457 1
a457 1
#define TT_SIZE_SELECT    0
@


1.5
log
@Commit the last bit of freetype 2.4.6 which I previously hold back,
since it changes the metrics of some TrueType fonts. Users of DejaVu
at small sizes in xterm can use the 'scaleHeight' resource to
restore the previous vertical spacing (with xterm 276 and later).
Tested on a wide set of ports by ajachoutot@@, naddy@@, krw@@ shadchin@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2011 by                                                 */
d261 1
a261 1
  /*    Load_Glyph                                                         */
d285 4
a288 4
  Load_Glyph( FT_GlyphSlot  ttslot,         /* TT_GlyphSlot */
              FT_Size       ttsize,         /* TT_Size      */
              FT_UInt       glyph_index,
              FT_Int32      load_flags )
d316 1
a316 1
      /* are necessary to disable hinting for tricky fonts */          
d405 1
d410 10
d424 1
d427 4
d433 1
a433 1
    sfntd = FT_Get_Module( driver->library, "sfnt" );
d459 4
a462 5
  FT_DEFINE_DRIVER(tt_driver_class,
  
    
      FT_MODULE_FONT_DRIVER        |
      FT_MODULE_DRIVER_SCALABLE    |
d486 1
a486 1
    0,                      /* FT_Slot_DoneFunc */
d488 1
a488 1
    ft_stub_set_char_sizes, /* FT_CONFIG_OPTION_OLD_INTERNALS */
d491 1
a491 1
    Load_Glyph,
d494 1
a494 1
    0,                      /* FT_Face_AttachFunc      */
@


1.4
log
@Update to freetype 2.4.5. Tested by many.
@
text
@d249 1
d251 2
@


1.3
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d7 1
a7 2
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009    */
/*            2010 by                                                      */
a136 2
    FT_Bool  check = FT_BOOL(
                       !( flags & FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ) );
d149 1
a149 1
        TT_Get_VMetrics( face, start + nn, check, &tsb, &ah );
d161 1
a161 1
        TT_Get_HMetrics( face, start + nn, check, &lsb, &aw );
@


1.2
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d7 2
a8 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
a23 1
#include FT_TRUETYPE_IDS_H
d44 1
d302 9
a310 1
    if ( !face || glyph_index >= (FT_UInt)face->num_glyphs )
d356 1
a356 2
  static const FT_Service_MultiMastersRec  tt_service_gx_multi_masters =
  {
d362 1
a362 1
  };
d382 1
a382 2
  static const FT_Service_TTGlyfRec  tt_service_truetype_glyf =
  {
d384 1
a384 1
  };
a385 3
  static const FT_ServiceDescRec  tt_services[] =
  {
    { FT_SERVICE_ID_XF86_NAME,       FT_XF86_FORMAT_TRUETYPE },
d387 12
a398 1
    { FT_SERVICE_ID_MULTI_MASTERS,   &tt_service_gx_multi_masters },
a399 5
    { FT_SERVICE_ID_TRUETYPE_ENGINE, &tt_service_truetype_engine },
    { FT_SERVICE_ID_TT_GLYF,         &tt_service_truetype_glyf },
    { NULL, NULL }
  };

d409 1
a409 2

    result = ft_service_list_lookup( tt_services, tt_interface );
d413 3
a430 6
  FT_CALLBACK_TABLE_DEF
  const FT_Driver_ClassRec  tt_driver_class =
  {
    {
      FT_MODULE_FONT_DRIVER        |
      FT_MODULE_DRIVER_SCALABLE    |
d432 7
a438 1
      FT_MODULE_DRIVER_HAS_HINTER,
d440 1
a440 1
      0,
d443 7
a460 1
    },
d473 3
a475 4
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
    ft_stub_set_char_sizes,
    ft_stub_set_pixel_sizes,
#endif
d483 2
a484 6
#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
    tt_size_select
#else
    0                       /* FT_Size_SelectFunc      */
#endif
  };
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d32 1
d36 1
d128 43
d235 1
a235 1
      FT_ULong      index;
d238 1
a238 1
      error = sfnt->set_sbit_strike( ttface, req, &index );
d243 1
a243 1
        return tt_size_select( size, index );
d275 1
a275 1
  /*                   FTLOAD_??? constants can be used to control the     */
d291 1
d301 15
d318 4
a321 3
      load_flags |= FT_LOAD_NO_HINTING |
                    FT_LOAD_NO_BITMAP  |
                    FT_LOAD_NO_SCALE;
d359 1
a359 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d367 1
a367 1
#else /* !TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d371 6
a376 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d386 1
d425 1
a425 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d463 1
a463 1
    0,                      /* FT_Face_GetAdvancesFunc */
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
a31 1
#include FT_SERVICE_TRUETYPE_GLYF_H
a34 1
#include "ttpload.h"
d190 1
a190 1
      FT_ULong      strike_index;
d193 1
a193 1
      error = sfnt->set_sbit_strike( ttface, req, &strike_index );
d198 1
a198 1
        return tt_size_select( size, strike_index );
a245 1
    FT_Face       face = ttslot->face;
a254 3
    if ( !face || glyph_index >= (FT_UInt)face->num_glyphs )
      return TT_Err_Invalid_Argument;

d297 1
a297 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d305 1
a305 1
#else /* !TT_USE_BYTECODE_INTERPRETER */
d309 1
a309 6
#endif /* TT_USE_BYTECODE_INTERPRETER */
  };

  static const FT_Service_TTGlyfRec  tt_service_truetype_glyf =
  {
    (TT_Glyf_GetLocationFunc)tt_face_get_location
a318 1
    { FT_SERVICE_ID_TT_GLYF,         &tt_service_truetype_glyf },
d357 1
a357 1
#ifdef TT_USE_BYTECODE_INTERPRETER
@

