head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.2
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.18.0.2
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.2
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2017.01.13.11.20.00;	author dcoppa;	state Exp;
branches;
next	1.22;
commitid	ESXG9TuEmwmBXggf;

1.22
date	2016.08.09.07.16.10;	author dcoppa;	state Exp;
branches;
next	1.21;
commitid	C8TgUUJolulx9B5d;

1.21
date	2016.05.29.11.57.14;	author dcoppa;	state Exp;
branches;
next	1.20;
commitid	1dOLexdOAzW2mQjp;

1.20
date	2015.12.07.09.34.04;	author dcoppa;	state Exp;
branches;
next	1.19;
commitid	wZOPiDmcwgRFTDVL;

1.19
date	2015.10.19.07.51.38;	author dcoppa;	state Exp;
branches;
next	1.18;
commitid	d2XmJCtYff11VIDu;

1.18
date	2015.06.28.08.27.50;	author dcoppa;	state Exp;
branches;
next	1.17;
commitid	qXwIGV2h9uFjxAmt;

1.17
date	2015.01.10.17.17.24;	author dcoppa;	state Exp;
branches;
next	1.16;
commitid	2tSYQMWVSV3t7clo;

1.16
date	2014.12.26.17.52.36;	author dcoppa;	state Exp;
branches;
next	1.15;
commitid	gwhRExMduYqoPQHI;

1.15
date	2014.01.12.15.08.28;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.10.19.49.59;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.07.17.21.11;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.01.04.16.51.59;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.07.07.16.45.04;	author dcoppa;	state Exp;
branches;
next	1.10;

1.10
date	2012.04.14.09.45.47;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.09.28.19.01.22;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.18.20.29.59;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.19.16.08.14;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.23.19.30.17;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.25.20.49.55;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.26.07.31.45;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.10.20.28.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.45.01;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.45.01;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.32.09;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.23
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ttobjs.c                                                               */
/*                                                                         */
/*    Objects manager (body).                                              */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_STREAM_H
#include FT_TRUETYPE_TAGS_H
#include FT_INTERNAL_SFNT_H
#include FT_TRUETYPE_DRIVER_H

#include "ttgload.h"
#include "ttpload.h"

#include "tterrors.h"

#ifdef TT_USE_BYTECODE_INTERPRETER
#include "ttinterp.h"
#endif

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#include "ttgxvar.h"
#endif

  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_ttobjs


#ifdef TT_USE_BYTECODE_INTERPRETER

  /*************************************************************************/
  /*                                                                       */
  /*                       GLYPH ZONE FUNCTIONS                            */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_glyphzone_done                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Deallocate a glyph zone.                                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    zone :: A pointer to the target glyph zone.                        */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  tt_glyphzone_done( TT_GlyphZone  zone )
  {
    FT_Memory  memory = zone->memory;


    if ( memory )
    {
      FT_FREE( zone->contours );
      FT_FREE( zone->tags );
      FT_FREE( zone->cur );
      FT_FREE( zone->org );
      FT_FREE( zone->orus );

      zone->max_points   = zone->n_points   = 0;
      zone->max_contours = zone->n_contours = 0;
      zone->memory       = NULL;
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_glyphzone_new                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Allocate a new glyph zone.                                         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    memory      :: A handle to the current memory object.              */
  /*                                                                       */
  /*    maxPoints   :: The capacity of glyph zone in points.               */
  /*                                                                       */
  /*    maxContours :: The capacity of glyph zone in contours.             */
  /*                                                                       */
  /* <Output>                                                              */
  /*    zone        :: A pointer to the target glyph zone record.          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_glyphzone_new( FT_Memory     memory,
                    FT_UShort     maxPoints,
                    FT_Short      maxContours,
                    TT_GlyphZone  zone )
  {
    FT_Error  error;


    FT_ZERO( zone );
    zone->memory = memory;

    if ( FT_NEW_ARRAY( zone->org,      maxPoints   ) ||
         FT_NEW_ARRAY( zone->cur,      maxPoints   ) ||
         FT_NEW_ARRAY( zone->orus,     maxPoints   ) ||
         FT_NEW_ARRAY( zone->tags,     maxPoints   ) ||
         FT_NEW_ARRAY( zone->contours, maxContours ) )
    {
      tt_glyphzone_done( zone );
    }
    else
    {
      zone->max_points   = maxPoints;
      zone->max_contours = maxContours;
    }

    return error;
  }
#endif /* TT_USE_BYTECODE_INTERPRETER */


  /* Compare the face with a list of well-known `tricky' fonts. */
  /* This list shall be expanded as we find more of them.       */

  static FT_Bool
  tt_check_trickyness_family( FT_String*  name )
  {

#define TRICK_NAMES_MAX_CHARACTERS  19
#define TRICK_NAMES_COUNT            9

    static const char trick_names[TRICK_NAMES_COUNT]
                                 [TRICK_NAMES_MAX_CHARACTERS + 1] =
    {
      "DFKaiSho-SB",        /* dfkaisb.ttf */
      "DFKaiShu",
      "DFKai-SB",           /* kaiu.ttf */
      "HuaTianKaiTi?",      /* htkt2.ttf */
      "HuaTianSongTi?",     /* htst3.ttf */
      "Ming(for ISO10646)", /* hkscsiic.ttf & iicore.ttf */
      "MingLiU",            /* mingliu.ttf & mingliu.ttc */
      "PMingLiU",           /* mingliu.ttc */
      "MingLi43",           /* mingli.ttf */
    };

    int  nn;


    for ( nn = 0; nn < TRICK_NAMES_COUNT; nn++ )
      if ( ft_strstr( name, trick_names[nn] ) )
        return TRUE;

    return FALSE;
  }


  /* XXX: This function should be in the `sfnt' module. */

  /* Some PDF generators clear the checksums in the TrueType header table. */
  /* For example, Quartz ContextPDF clears all entries, or Bullzip PDF     */
  /* Printer clears the entries for subsetted subtables.  We thus have to  */
  /* recalculate the checksums  where necessary.                           */

  static FT_UInt32
  tt_synth_sfnt_checksum( FT_Stream  stream,
                          FT_ULong   length )
  {
    FT_Error   error;
    FT_UInt32  checksum = 0;
    FT_UInt    i;


    if ( FT_FRAME_ENTER( length ) )
      return 0;

    for ( ; length > 3; length -= 4 )
      checksum += (FT_UInt32)FT_GET_ULONG();

    for ( i = 3; length > 0; length--, i-- )
      checksum += (FT_UInt32)FT_GET_BYTE() << ( i * 8 );

    FT_FRAME_EXIT();

    return checksum;
  }


  /* XXX: This function should be in the `sfnt' module. */

  static FT_ULong
  tt_get_sfnt_checksum( TT_Face    face,
                        FT_UShort  i )
  {
#if 0 /* if we believe the written value, use following part. */
    if ( face->dir_tables[i].CheckSum )
      return face->dir_tables[i].CheckSum;
#endif

    if ( !face->goto_table )
      return 0;

    if ( face->goto_table( face,
                           face->dir_tables[i].Tag,
                           face->root.stream,
                           NULL ) )
      return 0;

    return (FT_ULong)tt_synth_sfnt_checksum( face->root.stream,
                                             face->dir_tables[i].Length );
  }


  typedef struct tt_sfnt_id_rec_
  {
    FT_ULong  CheckSum;
    FT_ULong  Length;

  } tt_sfnt_id_rec;


  static FT_Bool
  tt_check_trickyness_sfnt_ids( TT_Face  face )
  {
#define TRICK_SFNT_IDS_PER_FACE   3
#define TRICK_SFNT_IDS_NUM_FACES  18

    static const tt_sfnt_id_rec sfnt_id[TRICK_SFNT_IDS_NUM_FACES]
                                       [TRICK_SFNT_IDS_PER_FACE] = {

#define TRICK_SFNT_ID_cvt   0
#define TRICK_SFNT_ID_fpgm  1
#define TRICK_SFNT_ID_prep  2

      { /* MingLiU 1995 */
        { 0x05BCF058UL, 0x000002E4UL }, /* cvt  */
        { 0x28233BF1UL, 0x000087C4UL }, /* fpgm */
        { 0xA344A1EAUL, 0x000001E1UL }  /* prep */
      },
      { /* MingLiU 1996- */
        { 0x05BCF058UL, 0x000002E4UL }, /* cvt  */
        { 0x28233BF1UL, 0x000087C4UL }, /* fpgm */
        { 0xA344A1EBUL, 0x000001E1UL }  /* prep */
      },
      { /* DFKaiShu */
        { 0x11E5EAD4UL, 0x00000350UL }, /* cvt  */
        { 0x5A30CA3BUL, 0x00009063UL }, /* fpgm */
        { 0x13A42602UL, 0x0000007EUL }  /* prep */
      },
      { /* DFKaiShu2 */
        { 0x11E5EAD4UL, 0x00000350UL }, /* cvt  */
        { 0xA6E78C01UL, 0x00008998UL }, /* fpgm */
        { 0x13A42602UL, 0x0000007EUL }  /* prep */
      },
      { /* HuaTianKaiTi */
        { 0xFFFBFFFCUL, 0x00000008UL }, /* cvt  */
        { 0x9C9E48B8UL, 0x0000BEA2UL }, /* fpgm */
        { 0x70020112UL, 0x00000008UL }  /* prep */
      },
      { /* HuaTianSongTi */
        { 0xFFFBFFFCUL, 0x00000008UL }, /* cvt  */
        { 0x0A5A0483UL, 0x00017C39UL }, /* fpgm */
        { 0x70020112UL, 0x00000008UL }  /* prep */
      },
      { /* NEC fadpop7.ttf */
        { 0x00000000UL, 0x00000000UL }, /* cvt  */
        { 0x40C92555UL, 0x000000E5UL }, /* fpgm */
        { 0xA39B58E3UL, 0x0000117CUL }  /* prep */
      },
      { /* NEC fadrei5.ttf */
        { 0x00000000UL, 0x00000000UL }, /* cvt  */
        { 0x33C41652UL, 0x000000E5UL }, /* fpgm */
        { 0x26D6C52AUL, 0x00000F6AUL }  /* prep */
      },
      { /* NEC fangot7.ttf */
        { 0x00000000UL, 0x00000000UL }, /* cvt  */
        { 0x6DB1651DUL, 0x0000019DUL }, /* fpgm */
        { 0x6C6E4B03UL, 0x00002492UL }  /* prep */
      },
      { /* NEC fangyo5.ttf */
        { 0x00000000UL, 0x00000000UL }, /* cvt  */
        { 0x40C92555UL, 0x000000E5UL }, /* fpgm */
        { 0xDE51FAD0UL, 0x0000117CUL }  /* prep */
      },
      { /* NEC fankyo5.ttf */
        { 0x00000000UL, 0x00000000UL }, /* cvt  */
        { 0x85E47664UL, 0x000000E5UL }, /* fpgm */
        { 0xA6C62831UL, 0x00001CAAUL }  /* prep */
      },
      { /* NEC fanrgo5.ttf */
        { 0x00000000UL, 0x00000000UL }, /* cvt  */
        { 0x2D891CFDUL, 0x0000019DUL }, /* fpgm */
        { 0xA0604633UL, 0x00001DE8UL }  /* prep */
      },
      { /* NEC fangot5.ttc */
        { 0x00000000UL, 0x00000000UL }, /* cvt  */
        { 0x40AA774CUL, 0x000001CBUL }, /* fpgm */
        { 0x9B5CAA96UL, 0x00001F9AUL }  /* prep */
      },
      { /* NEC fanmin3.ttc */
        { 0x00000000UL, 0x00000000UL }, /* cvt  */
        { 0x0D3DE9CBUL, 0x00000141UL }, /* fpgm */
        { 0xD4127766UL, 0x00002280UL }  /* prep */
      },
      { /* NEC FA-Gothic, 1996 */
        { 0x00000000UL, 0x00000000UL }, /* cvt  */
        { 0x4A692698UL, 0x000001F0UL }, /* fpgm */
        { 0x340D4346UL, 0x00001FCAUL }  /* prep */
      },
      { /* NEC FA-Minchou, 1996 */
        { 0x00000000UL, 0x00000000UL }, /* cvt  */
        { 0xCD34C604UL, 0x00000166UL }, /* fpgm */
        { 0x6CF31046UL, 0x000022B0UL }  /* prep */
      },
      { /* NEC FA-RoundGothicB, 1996 */
        { 0x00000000UL, 0x00000000UL }, /* cvt  */
        { 0x5DA75315UL, 0x0000019DUL }, /* fpgm */
        { 0x40745A5FUL, 0x000022E0UL }  /* prep */
      },
      { /* NEC FA-RoundGothicM, 1996 */
        { 0x00000000UL, 0x00000000UL }, /* cvt  */
        { 0xF055FC48UL, 0x000001C2UL }, /* fpgm */
        { 0x3900DED3UL, 0x00001E18UL }  /* prep */
      }
    };

    FT_ULong   checksum;
    int        num_matched_ids[TRICK_SFNT_IDS_NUM_FACES];
    FT_Bool    has_cvt, has_fpgm, has_prep;
    FT_UShort  i;
    int        j, k;


    FT_MEM_SET( num_matched_ids, 0,
                sizeof ( int ) * TRICK_SFNT_IDS_NUM_FACES );
    has_cvt  = FALSE;
    has_fpgm = FALSE;
    has_prep = FALSE;

    for ( i = 0; i < face->num_tables; i++ )
    {
      checksum = 0;

      switch( face->dir_tables[i].Tag )
      {
      case TTAG_cvt:
        k = TRICK_SFNT_ID_cvt;
        has_cvt  = TRUE;
        break;

      case TTAG_fpgm:
        k = TRICK_SFNT_ID_fpgm;
        has_fpgm = TRUE;
        break;

      case TTAG_prep:
        k = TRICK_SFNT_ID_prep;
        has_prep = TRUE;
        break;

      default:
        continue;
      }

      for ( j = 0; j < TRICK_SFNT_IDS_NUM_FACES; j++ )
        if ( face->dir_tables[i].Length == sfnt_id[j][k].Length )
        {
          if ( !checksum )
            checksum = tt_get_sfnt_checksum( face, i );

          if ( sfnt_id[j][k].CheckSum == checksum )
            num_matched_ids[j]++;

          if ( num_matched_ids[j] == TRICK_SFNT_IDS_PER_FACE )
            return TRUE;
        }
    }

    for ( j = 0; j < TRICK_SFNT_IDS_NUM_FACES; j++ )
    {
      if ( !has_cvt  && !sfnt_id[j][TRICK_SFNT_ID_cvt].Length )
        num_matched_ids[j]++;
      if ( !has_fpgm && !sfnt_id[j][TRICK_SFNT_ID_fpgm].Length )
        num_matched_ids[j]++;
      if ( !has_prep && !sfnt_id[j][TRICK_SFNT_ID_prep].Length )
        num_matched_ids[j]++;
      if ( num_matched_ids[j] == TRICK_SFNT_IDS_PER_FACE )
        return TRUE;
    }

    return FALSE;
  }


  static FT_Bool
  tt_check_trickyness( FT_Face  face )
  {
    if ( !face )
      return FALSE;

    /* For first, check the face name for quick check. */
    if ( face->family_name                               &&
         tt_check_trickyness_family( face->family_name ) )
      return TRUE;

    /* Type42 fonts may lack `name' tables, we thus try to identify */
    /* tricky fonts by checking the checksums of Type42-persistent  */
    /* sfnt tables (`cvt', `fpgm', and `prep').                     */
    if ( tt_check_trickyness_sfnt_ids( (TT_Face)face ) )
      return TRUE;

    return FALSE;
  }


  /* Check whether `.notdef' is the only glyph in the `loca' table. */
  static FT_Bool
  tt_check_single_notdef( FT_Face  ttface )
  {
    FT_Bool   result = FALSE;

    TT_Face   face = (TT_Face)ttface;
    FT_UInt   asize;
    FT_ULong  i;
    FT_ULong  glyph_index = 0;
    FT_UInt   count       = 0;


    for( i = 0; i < face->num_locations; i++ )
    {
      tt_face_get_location( face, i, &asize );
      if ( asize > 0 )
      {
        count += 1;
        if ( count > 1 )
          break;
        glyph_index = i;
      }
    }

    /* Only have a single outline. */
    if ( count == 1 )
    {
      if ( glyph_index == 0 )
        result = TRUE;
      else
      {
        /* FIXME: Need to test glyphname == .notdef ? */
        FT_Error error;
        char buf[8];


        error = FT_Get_Glyph_Name( ttface, glyph_index, buf, 8 );
        if ( !error                                            &&
             buf[0] == '.' && !ft_strncmp( buf, ".notdef", 8 ) )
          result = TRUE;
      }
    }

    return result;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_face_init                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initialize a given TrueType face object.                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    stream     :: The source font stream.                              */
  /*                                                                       */
  /*    face_index :: The index of the TrueType font, if we are opening a  */
  /*                  collection, in bits 0-15.  The numbered instance     */
  /*                  index~+~1 of a GX (sub)font, if applicable, in bits  */
  /*                  16-30.                                               */
  /*                                                                       */
  /*    num_params :: Number of additional generic parameters.  Ignored.   */
  /*                                                                       */
  /*    params     :: Additional generic parameters.  Ignored.             */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face       :: The newly built face object.                         */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_face_init( FT_Stream      stream,
                FT_Face        ttface,      /* TT_Face */
                FT_Int         face_index,
                FT_Int         num_params,
                FT_Parameter*  params )
  {
    FT_Error      error;
    FT_Library    library;
    SFNT_Service  sfnt;
    TT_Face       face = (TT_Face)ttface;


    FT_TRACE2(( "TTF driver\n" ));

    library = ttface->driver->root.library;

    sfnt = (SFNT_Service)FT_Get_Module_Interface( library, "sfnt" );
    if ( !sfnt )
    {
      FT_ERROR(( "tt_face_init: cannot access `sfnt' module\n" ));
      error = FT_THROW( Missing_Module );
      goto Exit;
    }

    /* create input stream from resource */
    if ( FT_STREAM_SEEK( 0 ) )
      goto Exit;

    /* check that we have a valid TrueType file */
    error = sfnt->init_face( stream, face, face_index, num_params, params );

    /* Stream may have changed. */
    stream = face->root.stream;

    if ( error )
      goto Exit;

    /* We must also be able to accept Mac/GX fonts, as well as OT ones. */
    /* The 0x00020000 tag is completely undocumented; some fonts from   */
    /* Arphic made for Chinese Windows 3.1 have this.                   */
    if ( face->format_tag != 0x00010000L &&    /* MS fonts  */
         face->format_tag != 0x00020000L &&    /* CJK fonts for Win 3.1 */
         face->format_tag != TTAG_true   )     /* Mac fonts */
    {
      FT_TRACE2(( "  not a TTF font\n" ));
      goto Bad_Format;
    }

#ifdef TT_USE_BYTECODE_INTERPRETER
    ttface->face_flags |= FT_FACE_FLAG_HINTER;
#endif

    /* If we are performing a simple font format check, exit immediately. */
    if ( face_index < 0 )
      return FT_Err_Ok;

    /* Load font directory */
    error = sfnt->load_face( stream, face, face_index, num_params, params );
    if ( error )
      goto Exit;

    if ( tt_check_trickyness( ttface ) )
      ttface->face_flags |= FT_FACE_FLAG_TRICKY;

    error = tt_face_load_hdmx( face, stream );
    if ( error )
      goto Exit;

    if ( FT_IS_SCALABLE( ttface ) )
    {
#ifdef FT_CONFIG_OPTION_INCREMENTAL
      if ( !ttface->internal->incremental_interface )
#endif
      {
        error = tt_face_load_loca( face, stream );

        /* having a (non-zero) `glyf' table without */
        /* a `loca' table is not valid              */
        if ( face->glyf_len && FT_ERR_EQ( error, Table_Missing ) )
          goto Exit;
        if ( error )
          goto Exit;
      }

      /* `fpgm', `cvt', and `prep' are optional */
      error = tt_face_load_cvt( face, stream );
      if ( error && FT_ERR_NEQ( error, Table_Missing ) )
        goto Exit;

      error = tt_face_load_fpgm( face, stream );
      if ( error && FT_ERR_NEQ( error, Table_Missing ) )
        goto Exit;

      error = tt_face_load_prep( face, stream );
      if ( error && FT_ERR_NEQ( error, Table_Missing ) )
        goto Exit;

      /* Check the scalable flag based on `loca'. */
#ifdef FT_CONFIG_OPTION_INCREMENTAL
      if ( !ttface->internal->incremental_interface )
#endif
      {
        if ( ttface->num_fixed_sizes          &&
             face->glyph_locations            &&
             tt_check_single_notdef( ttface ) )
        {
          FT_TRACE5(( "tt_face_init:"
                      " Only the `.notdef' glyph has an outline.\n"
                      "             "
                      " Resetting scalable flag to FALSE.\n" ));

          ttface->face_flags &= ~FT_FACE_FLAG_SCALABLE;
        }
      }
    }

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT

    {
      FT_Int  instance_index = face_index >> 16;


      if ( FT_HAS_MULTIPLE_MASTERS( ttface ) &&
           instance_index > 0                )
      {
        error = TT_Get_MM_Var( face, NULL );
        if ( error )
          goto Exit;

        if ( face->blend->mmvar->namedstyle )
        {
          FT_Memory  memory = ttface->memory;

          FT_Var_Named_Style*  named_style;
          FT_String*           style_name;


          /* in `face_index', the instance index starts with value 1 */
          named_style = face->blend->mmvar->namedstyle + instance_index - 1;
          error = sfnt->get_name( face,
                                  (FT_UShort)named_style->strid,
                                  &style_name );
          if ( error )
            goto Exit;

          /* set style name; if already set, replace it */
          if ( face->root.style_name )
            FT_FREE( face->root.style_name );
          face->root.style_name = style_name;

          /* finally, select the named instance */
          error = TT_Set_Var_Design( face,
                                     face->blend->mmvar->num_axis,
                                     named_style->coords );
          if ( error )
            goto Exit;
        }
      }
    }

#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */

    /* initialize standard glyph loading routines */
    TT_Init_Glyph_Loading( face );

  Exit:
    return error;

  Bad_Format:
    error = FT_THROW( Unknown_File_Format );
    goto Exit;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_face_done                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Finalize a given face object.                                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A pointer to the face object to destroy.                   */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  tt_face_done( FT_Face  ttface )           /* TT_Face */
  {
    TT_Face       face = (TT_Face)ttface;
    FT_Memory     memory;
    FT_Stream     stream;
    SFNT_Service  sfnt;


    if ( !face )
      return;

    memory = ttface->memory;
    stream = ttface->stream;
    sfnt   = (SFNT_Service)face->sfnt;

    /* for `extended TrueType formats' (i.e. compressed versions) */
    if ( face->extra.finalizer )
      face->extra.finalizer( face->extra.data );

    if ( sfnt )
      sfnt->done_face( face );

    /* freeing the locations table */
    tt_face_done_loca( face );

    tt_face_free_hdmx( face );

    /* freeing the CVT */
    FT_FREE( face->cvt );
    face->cvt_size = 0;

    /* freeing the programs */
    FT_FRAME_RELEASE( face->font_program );
    FT_FRAME_RELEASE( face->cvt_program );
    face->font_program_size = 0;
    face->cvt_program_size  = 0;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    tt_done_blend( face );
    face->blend = NULL;
#endif
  }


  /*************************************************************************/
  /*                                                                       */
  /*                           SIZE  FUNCTIONS                             */
  /*                                                                       */
  /*************************************************************************/

#ifdef TT_USE_BYTECODE_INTERPRETER

  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_size_run_fpgm                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Run the font program.                                              */
  /*                                                                       */
  /* <Input>                                                               */
  /*    size     :: A handle to the size object.                           */
  /*                                                                       */
  /*    pedantic :: Set if bytecode execution should be pedantic.          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_size_run_fpgm( TT_Size  size,
                    FT_Bool  pedantic )
  {
    TT_Face         face = (TT_Face)size->root.face;
    TT_ExecContext  exec;
    FT_Error        error;


    exec = size->context;

    error = TT_Load_Context( exec, face, size );
    if ( error )
      return error;

    exec->callTop = 0;
    exec->top     = 0;

    exec->period    = 64;
    exec->phase     = 0;
    exec->threshold = 0;

    exec->instruction_trap = FALSE;
    exec->F_dot_P          = 0x4000L;

    exec->pedantic_hinting = pedantic;

    {
      FT_Size_Metrics*  metrics    = &exec->metrics;
      TT_Size_Metrics*  tt_metrics = &exec->tt_metrics;


      metrics->x_ppem   = 0;
      metrics->y_ppem   = 0;
      metrics->x_scale  = 0;
      metrics->y_scale  = 0;

      tt_metrics->ppem  = 0;
      tt_metrics->scale = 0;
      tt_metrics->ratio = 0x10000L;
    }

    /* allow font program execution */
    TT_Set_CodeRange( exec,
                      tt_coderange_font,
                      face->font_program,
                      (FT_Long)face->font_program_size );

    /* disable CVT and glyph programs coderange */
    TT_Clear_CodeRange( exec, tt_coderange_cvt );
    TT_Clear_CodeRange( exec, tt_coderange_glyph );

    if ( face->font_program_size > 0 )
    {
      TT_Goto_CodeRange( exec, tt_coderange_font, 0 );

      FT_TRACE4(( "Executing `fpgm' table.\n" ));
      error = face->interpreter( exec );
    }
    else
      error = FT_Err_Ok;

    size->bytecode_ready = error;

    if ( !error )
      TT_Save_Context( exec, size );

    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_size_run_prep                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Run the control value program.                                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    size     :: A handle to the size object.                           */
  /*                                                                       */
  /*    pedantic :: Set if bytecode execution should be pedantic.          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_size_run_prep( TT_Size  size,
                    FT_Bool  pedantic )
  {
    TT_Face         face = (TT_Face)size->root.face;
    TT_ExecContext  exec;
    FT_Error        error;


    exec = size->context;

    error = TT_Load_Context( exec, face, size );
    if ( error )
      return error;

    exec->callTop = 0;
    exec->top     = 0;

    exec->instruction_trap = FALSE;

    exec->pedantic_hinting = pedantic;

    TT_Set_CodeRange( exec,
                      tt_coderange_cvt,
                      face->cvt_program,
                      (FT_Long)face->cvt_program_size );

    TT_Clear_CodeRange( exec, tt_coderange_glyph );

    if ( face->cvt_program_size > 0 )
    {
      TT_Goto_CodeRange( exec, tt_coderange_cvt, 0 );

      FT_TRACE4(( "Executing `prep' table.\n" ));

      error = face->interpreter( exec );
    }
    else
      error = FT_Err_Ok;

    size->cvt_ready = error;

    /* UNDOCUMENTED!  The MS rasterizer doesn't allow the following */
    /* graphics state variables to be modified by the CVT program.  */

    exec->GS.dualVector.x = 0x4000;
    exec->GS.dualVector.y = 0;
    exec->GS.projVector.x = 0x4000;
    exec->GS.projVector.y = 0x0;
    exec->GS.freeVector.x = 0x4000;
    exec->GS.freeVector.y = 0x0;

    exec->GS.rp0 = 0;
    exec->GS.rp1 = 0;
    exec->GS.rp2 = 0;

    exec->GS.gep0 = 1;
    exec->GS.gep1 = 1;
    exec->GS.gep2 = 1;

    exec->GS.loop = 1;

    /* save as default graphics state */
    size->GS = exec->GS;

    TT_Save_Context( exec, size );

    return error;
  }


  static void
  tt_size_done_bytecode( FT_Size  ftsize )
  {
    TT_Size    size   = (TT_Size)ftsize;
    TT_Face    face   = (TT_Face)ftsize->face;
    FT_Memory  memory = face->root.memory;

    if ( size->context )
    {
      TT_Done_Context( size->context );
      size->context = NULL;
    }

    FT_FREE( size->cvt );
    size->cvt_size = 0;

    /* free storage area */
    FT_FREE( size->storage );
    size->storage_size = 0;

    /* twilight zone */
    tt_glyphzone_done( &size->twilight );

    FT_FREE( size->function_defs );
    FT_FREE( size->instruction_defs );

    size->num_function_defs    = 0;
    size->max_function_defs    = 0;
    size->num_instruction_defs = 0;
    size->max_instruction_defs = 0;

    size->max_func = 0;
    size->max_ins  = 0;

    size->bytecode_ready = -1;
    size->cvt_ready      = -1;
  }


  /* Initialize bytecode-related fields in the size object.       */
  /* We do this only if bytecode interpretation is really needed. */
  static FT_Error
  tt_size_init_bytecode( FT_Size  ftsize,
                         FT_Bool  pedantic )
  {
    FT_Error   error;
    TT_Size    size = (TT_Size)ftsize;
    TT_Face    face = (TT_Face)ftsize->face;
    FT_Memory  memory = face->root.memory;

    FT_UShort       n_twilight;
    TT_MaxProfile*  maxp = &face->max_profile;


    /* clean up bytecode related data */
    FT_FREE( size->function_defs );
    FT_FREE( size->instruction_defs );
    FT_FREE( size->cvt );
    FT_FREE( size->storage );

    if ( size->context )
      TT_Done_Context( size->context );
    tt_glyphzone_done( &size->twilight );

    size->bytecode_ready = -1;
    size->cvt_ready      = -1;

    size->context = TT_New_Context( (TT_Driver)face->root.driver );

    size->max_function_defs    = maxp->maxFunctionDefs;
    size->max_instruction_defs = maxp->maxInstructionDefs;

    size->num_function_defs    = 0;
    size->num_instruction_defs = 0;

    size->max_func = 0;
    size->max_ins  = 0;

    size->cvt_size     = face->cvt_size;
    size->storage_size = maxp->maxStorage;

    /* Set default metrics */
    {
      TT_Size_Metrics*  metrics = &size->ttmetrics;


      metrics->rotated   = FALSE;
      metrics->stretched = FALSE;

      /* set default engine compensation */
      metrics->compensations[0] = 0;   /* gray     */
      metrics->compensations[1] = 0;   /* black    */
      metrics->compensations[2] = 0;   /* white    */
      metrics->compensations[3] = 0;   /* reserved */
    }

    /* allocate function defs, instruction defs, cvt, and storage area */
    if ( FT_NEW_ARRAY( size->function_defs,    size->max_function_defs    ) ||
         FT_NEW_ARRAY( size->instruction_defs, size->max_instruction_defs ) ||
         FT_NEW_ARRAY( size->cvt,              size->cvt_size             ) ||
         FT_NEW_ARRAY( size->storage,          size->storage_size         ) )
      goto Exit;

    /* reserve twilight zone */
    n_twilight = maxp->maxTwilightPoints;

    /* there are 4 phantom points (do we need this?) */
    n_twilight += 4;

    error = tt_glyphzone_new( memory, n_twilight, 0, &size->twilight );
    if ( error )
      goto Exit;

    size->twilight.n_points = n_twilight;

    size->GS = tt_default_graphics_state;

    /* set `face->interpreter' according to the debug hook present */
    {
      FT_Library  library = face->root.driver->root.library;


      face->interpreter = (TT_Interpreter)
                            library->debug_hooks[FT_DEBUG_HOOK_TRUETYPE];
      if ( !face->interpreter )
        face->interpreter = (TT_Interpreter)TT_RunIns;
    }

    /* Fine, now run the font program! */

    /* In case of an error while executing `fpgm', we intentionally don't */
    /* clean up immediately – bugs in the `fpgm' are so fundamental that  */
    /* all following hinting calls should fail.  Additionally, `fpgm' is  */
    /* to be executed just once; calling it again is completely useless   */
    /* and might even lead to extremely slow behaviour if it is malformed */
    /* (containing an infinite loop, for example).                        */
    error = tt_size_run_fpgm( size, pedantic );
    return error;

  Exit:
    if ( error )
      tt_size_done_bytecode( ftsize );

    return error;
  }


  FT_LOCAL_DEF( FT_Error )
  tt_size_ready_bytecode( TT_Size  size,
                          FT_Bool  pedantic )
  {
    FT_Error  error = FT_Err_Ok;


    if ( size->bytecode_ready < 0 )
      error = tt_size_init_bytecode( (FT_Size)size, pedantic );

    if ( error || size->bytecode_ready )
      goto Exit;

    /* rescale CVT when needed */
    if ( size->cvt_ready < 0 )
    {
      FT_UInt  i;
      TT_Face  face = (TT_Face)size->root.face;


      /* Scale the cvt values to the new ppem.          */
      /* We use by default the y ppem to scale the CVT. */
      for ( i = 0; i < size->cvt_size; i++ )
        size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );

      /* all twilight points are originally zero */
      for ( i = 0; i < (FT_UInt)size->twilight.n_points; i++ )
      {
        size->twilight.org[i].x = 0;
        size->twilight.org[i].y = 0;
        size->twilight.cur[i].x = 0;
        size->twilight.cur[i].y = 0;
      }

      /* clear storage area */
      for ( i = 0; i < (FT_UInt)size->storage_size; i++ )
        size->storage[i] = 0;

      size->GS = tt_default_graphics_state;

      error = tt_size_run_prep( size, pedantic );
    }

  Exit:
    return error;
  }

#endif /* TT_USE_BYTECODE_INTERPRETER */


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_size_init                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initialize a new TrueType size object.                             */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    size :: A handle to the size object.                               */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_size_init( FT_Size  ttsize )           /* TT_Size */
  {
    TT_Size   size  = (TT_Size)ttsize;
    FT_Error  error = FT_Err_Ok;


#ifdef TT_USE_BYTECODE_INTERPRETER
    size->bytecode_ready = -1;
    size->cvt_ready      = -1;
#endif

    size->ttmetrics.valid = FALSE;
    size->strike_index    = 0xFFFFFFFFUL;

    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_size_done                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The TrueType size object finalizer.                                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    size :: A handle to the target size object.                        */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  tt_size_done( FT_Size  ttsize )           /* TT_Size */
  {
    TT_Size  size = (TT_Size)ttsize;


#ifdef TT_USE_BYTECODE_INTERPRETER
    tt_size_done_bytecode( ttsize );
#endif

    size->ttmetrics.valid = FALSE;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_size_reset                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Reset a TrueType size when resolutions and character dimensions    */
  /*    have been changed.                                                 */
  /*                                                                       */
  /* <Input>                                                               */
  /*    size :: A handle to the target size object.                        */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_size_reset( TT_Size  size )
  {
    TT_Face           face;
    FT_Error          error = FT_Err_Ok;
    FT_Size_Metrics*  metrics;


    size->ttmetrics.valid = FALSE;

    face = (TT_Face)size->root.face;

    metrics = &size->metrics;

    /* copy the result from base layer */
    *metrics = size->root.metrics;

    if ( metrics->x_ppem < 1 || metrics->y_ppem < 1 )
      return FT_THROW( Invalid_PPem );

    /* This bit flag, if set, indicates that the ppems must be       */
    /* rounded to integers.  Nearly all TrueType fonts have this bit */
    /* set, as hinting won't work really well otherwise.             */
    /*                                                               */
    if ( face->header.Flags & 8 )
    {
      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,
                                    face->root.units_per_EM );
      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,
                                    face->root.units_per_EM );

      metrics->ascender =
        FT_PIX_ROUND( FT_MulFix( face->root.ascender, metrics->y_scale ) );
      metrics->descender =
        FT_PIX_ROUND( FT_MulFix( face->root.descender, metrics->y_scale ) );
      metrics->height =
        FT_PIX_ROUND( FT_MulFix( face->root.height, metrics->y_scale ) );
      metrics->max_advance =
        FT_PIX_ROUND( FT_MulFix( face->root.max_advance_width,
                                 metrics->x_scale ) );
    }

    /* compute new transformation */
    if ( metrics->x_ppem >= metrics->y_ppem )
    {
      size->ttmetrics.scale   = metrics->x_scale;
      size->ttmetrics.ppem    = metrics->x_ppem;
      size->ttmetrics.x_ratio = 0x10000L;
      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,
                                           metrics->x_ppem );
    }
    else
    {
      size->ttmetrics.scale   = metrics->y_scale;
      size->ttmetrics.ppem    = metrics->y_ppem;
      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,
                                           metrics->y_ppem );
      size->ttmetrics.y_ratio = 0x10000L;
    }

#ifdef TT_USE_BYTECODE_INTERPRETER
    size->cvt_ready = -1;
#endif /* TT_USE_BYTECODE_INTERPRETER */

    if ( !error )
      size->ttmetrics.valid = TRUE;

    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_driver_init                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initialize a given TrueType driver object.                         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    driver :: A handle to the target driver object.                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_driver_init( FT_Module  ttdriver )     /* TT_Driver */
  {

#ifdef TT_USE_BYTECODE_INTERPRETER

    TT_Driver  driver = (TT_Driver)ttdriver;

    driver->interpreter_version = TT_INTERPRETER_VERSION_35;
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    driver->interpreter_version = TT_INTERPRETER_VERSION_38;
#endif
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    driver->interpreter_version = TT_INTERPRETER_VERSION_40;
#endif

#else /* !TT_USE_BYTECODE_INTERPRETER */

    FT_UNUSED( ttdriver );

#endif /* !TT_USE_BYTECODE_INTERPRETER */

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_driver_done                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Finalize a given TrueType driver.                                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    driver :: A handle to the target TrueType driver.                  */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  tt_driver_done( FT_Module  ttdriver )     /* TT_Driver */
  {
    FT_UNUSED( ttdriver );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_slot_init                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initialize a new slot object.                                      */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    slot :: A handle to the slot object.                               */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_slot_init( FT_GlyphSlot  slot )
  {
    return FT_GlyphLoader_CreateExtra( slot->internal->loader );
  }


/* END */
@


1.22
log
@
Update to FreeType 2.6.5

ok matthieu@@
@
text
@d120 1
a120 1
    FT_MEM_ZERO( zone, sizeof ( *zone ) );
a579 1

a580 1

d582 2
a584 6
      if ( !error )
        error = tt_face_load_cvt( face, stream );
      if ( !error )
        error = tt_face_load_fpgm( face, stream );
      if ( !error )
        error = tt_face_load_prep( face, stream );
d586 6
a591 12
      /* Check the scalable flag based on `loca'. */
      if ( !ttface->internal->incremental_interface &&
           ttface->num_fixed_sizes                  &&
           face->glyph_locations                    &&
           tt_check_single_notdef( ttface )         )
      {
        FT_TRACE5(( "tt_face_init:"
                    " Only the `.notdef' glyph has an outline.\n"
                    "             "
                    " Resetting scalable flag to FALSE.\n" ));

        ttface->face_flags &= ~FT_FACE_FLAG_SCALABLE;
d594 12
a605 10
#else /* !FT_CONFIG_OPTION_INCREMENTAL */

      if ( !error )
        error = tt_face_load_loca( face, stream );
      if ( !error )
        error = tt_face_load_cvt( face, stream );
      if ( !error )
        error = tt_face_load_fpgm( face, stream );
      if ( !error )
        error = tt_face_load_prep( face, stream );
d608 3
a610 3
      if ( ttface->num_fixed_sizes          &&
           face->glyph_locations            &&
           tt_check_single_notdef( ttface ) )
d612 8
a619 4
        FT_TRACE5(( "tt_face_init:"
                    " Only the `.notdef' glyph has an outline.\n"
                    "             "
                    " Resetting scalable flag to FALSE.\n" ));
d621 2
a622 1
        ttface->face_flags &= ~FT_FACE_FLAG_SCALABLE;
a623 3

#endif /* !FT_CONFIG_OPTION_INCREMENTAL */

d734 1
a734 1
    tt_done_blend( memory, face->blend );
@


1.21
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d401 1
a401 1
        num_matched_ids[j] ++;
d403 1
a403 1
        num_matched_ids[j] ++;
d405 1
a405 1
        num_matched_ids[j] ++;
d1290 2
a1291 1
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
d1293 3
a1295 2
#else
    driver->interpreter_version = TT_INTERPRETER_VERSION_35;
@


1.20
log
@
Bugfixing update to freetype-2.6.2

Tested on amd64, i386, macppc, sparc64, loongson and compile-tested
on arm by matthieu@@
Also tested in a ports bulk build by naddy@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2015 by                                                 */
a34 4
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
#include FT_TRUETYPE_UNPATENTED_H
#endif

d245 1
a245 1
#define TRICK_SFNT_IDS_NUM_FACES  17
d269 5
a678 23

#if defined( TT_CONFIG_OPTION_UNPATENTED_HINTING    ) && \
    !defined( TT_CONFIG_OPTION_BYTECODE_INTERPRETER )

    {
      FT_Bool  unpatented_hinting;
      int      i;


      /* Determine whether unpatented hinting is to be used for this face. */
      unpatented_hinting = FT_BOOL
        ( library->debug_hooks[FT_DEBUG_HOOK_UNPATENTED_HINTING] != NULL );

      for ( i = 0; i < num_params && !face->unpatented_hinting; i++ )
        if ( params[i].tag == FT_PARAM_TAG_UNPATENTED_HINTING )
          unpatented_hinting = TRUE;

      if ( !unpatented_hinting )
        ttface->internal->ignore_unpatented_hinter = TRUE;
    }

#endif /* TT_CONFIG_OPTION_UNPATENTED_HINTING &&
          !TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
@


1.19
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@d1081 7
d1089 1
@


1.18
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d194 1
a194 1
    int        i;
d203 2
a204 2
    for ( i = 3; length > 0; length --, i-- )
      checksum += (FT_UInt32)( FT_GET_BYTE() << ( i * 8 ) );
d493 4
a496 1
  /*    face_index :: The index of the font face in the resource.          */
d605 1
a605 1
#else
d629 24
a652 1
#endif
d654 21
d676 2
@


1.17
log
@
Bugfixing update to freetype-2.5.5

ok matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2013                                                    */
d754 1
a754 8
    /* debugging instances have their own context */
    if ( size->debug )
      exec = size->context;
    else
      exec = ( (TT_Driver)FT_FACE_DRIVER( face ) )->context;

    if ( !exec )
      return FT_THROW( Could_Not_Find_Context );
d791 1
a791 1
                      face->font_program_size );
d841 1
a841 8
    /* debugging instances have their own context */
    if ( size->debug )
      exec = size->context;
    else
      exec = ( (TT_Driver)FT_FACE_DRIVER( face ) )->context;

    if ( !exec )
      return FT_THROW( Could_Not_Find_Context );
d857 1
a857 1
                      face->cvt_program_size );
d865 1
a865 3
      if ( !size->debug )
      {
        FT_TRACE4(( "Executing `prep' table.\n" ));
d867 1
a867 2
        error = face->interpreter( exec );
      }
d910 1
a910 2

    if ( size->debug )
d912 1
a912 1
      /* the debug context must be deleted by the debugger itself */
a913 1
      size->debug   = FALSE;
d957 10
d970 2
a1254 4

    if ( !TT_New_Context( driver ) )
      return FT_THROW( Could_Not_Find_Context );

a1284 11
#ifdef TT_USE_BYTECODE_INTERPRETER
    TT_Driver  driver = (TT_Driver)ttdriver;


    /* destroy the execution context */
    if ( driver->context )
    {
      TT_Done_Context( driver->context );
      driver->context = NULL;
    }
#else
a1285 2
#endif

@


1.16
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d259 3
a261 3
        { 0x05bcf058, 0x000002e4 }, /* cvt  */
        { 0x28233bf1, 0x000087c4 }, /* fpgm */
        { 0xa344a1ea, 0x000001e1 }  /* prep */
d264 3
a266 3
        { 0x05bcf058, 0x000002e4 }, /* cvt  */
        { 0x28233bf1, 0x000087c4 }, /* fpgm */
        { 0xa344a1eb, 0x000001e1 }  /* prep */
d269 3
a271 3
        { 0x11e5ead4, 0x00000350 }, /* cvt  */
        { 0x5a30ca3b, 0x00009063 }, /* fpgm */
        { 0x13a42602, 0x0000007e }  /* prep */
d274 3
a276 3
        { 0xfffbfffc, 0x00000008 }, /* cvt  */
        { 0x9c9e48b8, 0x0000bea2 }, /* fpgm */
        { 0x70020112, 0x00000008 }  /* prep */
d279 3
a281 3
        { 0xfffbfffc, 0x00000008 }, /* cvt  */
        { 0x0a5a0483, 0x00017c39 }, /* fpgm */
        { 0x70020112, 0x00000008 }  /* prep */
d284 3
a286 3
        { 0x00000000, 0x00000000 }, /* cvt  */
        { 0x40c92555, 0x000000e5 }, /* fpgm */
        { 0xa39b58e3, 0x0000117c }  /* prep */
d289 3
a291 3
        { 0x00000000, 0x00000000 }, /* cvt  */
        { 0x33c41652, 0x000000e5 }, /* fpgm */
        { 0x26d6c52a, 0x00000f6a }  /* prep */
d294 3
a296 3
        { 0x00000000, 0x00000000 }, /* cvt  */
        { 0x6db1651d, 0x0000019d }, /* fpgm */
        { 0x6c6e4b03, 0x00002492 }  /* prep */
d299 3
a301 3
        { 0x00000000, 0x00000000 }, /* cvt  */
        { 0x40c92555, 0x000000e5 }, /* fpgm */
        { 0xde51fad0, 0x0000117c }  /* prep */
d304 3
a306 3
        { 0x00000000, 0x00000000 }, /* cvt  */
        { 0x85e47664, 0x000000e5 }, /* fpgm */
        { 0xa6c62831, 0x00001caa }  /* prep */
d309 3
a311 3
        { 0x00000000, 0x00000000 }, /* cvt  */
        { 0x2d891cfd, 0x0000019d }, /* fpgm */
        { 0xa0604633, 0x00001de8 }  /* prep */
d314 3
a316 3
        { 0x00000000, 0x00000000 }, /* cvt  */
        { 0x40aa774c, 0x000001cb }, /* fpgm */
        { 0x9b5caa96, 0x00001f9a }  /* prep */
d319 3
a321 3
        { 0x00000000, 0x00000000 }, /* cvt  */
        { 0x0d3de9cb, 0x00000141 }, /* fpgm */
        { 0xd4127766, 0x00002280 }  /* prep */
d324 3
a326 3
        { 0x00000000, 0x00000000 }, /* cvt  */
        { 0x4a692698, 0x000001f0 }, /* fpgm */
        { 0x340d4346, 0x00001fca }  /* prep */
d329 3
a331 3
        { 0x00000000, 0x00000000 }, /* cvt  */
        { 0xcd34c604, 0x00000166 }, /* fpgm */
        { 0x6cf31046, 0x000022b0 }  /* prep */
d334 3
a336 3
        { 0x00000000, 0x00000000 }, /* cvt  */
        { 0x5da75315, 0x0000019d }, /* fpgm */
        { 0x40745a5f, 0x000022e0 }  /* prep */
d339 3
a341 3
        { 0x00000000, 0x00000000 }, /* cvt  */
        { 0xf055fc48, 0x000001c2 }, /* fpgm */
        { 0x3900ded3, 0x00001e18 }  /* prep */
d1119 1
d1150 1
a1150 2
    if ( size->bytecode_ready >= 0 )
      tt_size_done_bytecode( ttsize );
@


1.15
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d763 3
a765 1
    TT_Load_Context( exec, face, size );
d806 1
a806 5
      error = TT_Goto_CodeRange( exec, tt_coderange_font, 0 );

      if ( !error )
      {
        FT_TRACE4(( "Executing `fpgm' table.\n" ));
d808 2
a809 2
        error = face->interpreter( exec );
      }
d814 2
d857 3
a859 1
    TT_Load_Context( exec, face, size );
d877 1
a877 1
      error = TT_Goto_CodeRange( exec, tt_coderange_cvt, 0 );
d879 1
a879 1
      if ( !error && !size->debug )
d889 2
a918 4
#endif /* TT_USE_BYTECODE_INTERPRETER */


#ifdef TT_USE_BYTECODE_INTERPRETER
d956 2
a957 2
    size->bytecode_ready = 0;
    size->cvt_ready      = 0;
a970 1
    FT_Int     i;
d976 2
a977 2
    size->bytecode_ready = 1;
    size->cvt_ready      = 0;
d999 5
a1003 3
      /* set default compensation (all 0) */
      for ( i = 0; i < 4; i++ )
        metrics->compensations[i] = 0;
d1056 1
a1056 2
    if ( !size->bytecode_ready )
    {
d1058 3
a1060 3
      if ( error )
        goto Exit;
    }
d1063 1
a1063 1
    if ( !size->cvt_ready )
a1089 2
      if ( !error )
        size->cvt_ready = 1;
d1120 2
a1121 2
    size->bytecode_ready = 0;
    size->cvt_ready      = 0;
d1149 1
a1149 1
    if ( size->bytecode_ready )
d1230 1
a1230 1
    size->cvt_ready = 0;
@


1.14
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@d153 2
a154 2
#define TRICK_NAMES_MAX_CHARACTERS  16
#define TRICK_NAMES_COUNT            8
d159 1
a159 1
      "DFKaiSho-SB",     /* dfkaisb.ttf */
d161 7
a167 6
      "DFKai-SB",        /* kaiu.ttf */
      "HuaTianKaiTi?",   /* htkt2.ttf */
      "HuaTianSongTi?",  /* htst3.ttf */
      "MingLiU",         /* mingliu.ttf & mingliu.ttc */
      "PMingLiU",        /* mingliu.ttc */
      "MingLi43",        /* mingli.ttf */
d536 4
@


1.13
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@d24 1
d1263 2
d1266 4
d1273 1
a1273 1
#endif
@


1.12
log
@Update to freetype 2.4.11. Tested by krw@@, jasper@@ and on a bulk ports
build by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2012                                                    */
d524 1
a524 1
      error = TT_Err_Missing_Module;
d554 1
a554 1
      return TT_Err_Ok;
d654 1
a654 1
    error = TT_Err_Unknown_File_Format;
d755 1
a755 1
      return TT_Err_Could_Not_Find_Context;
d808 1
a808 1
      error = TT_Err_Ok;
d849 1
a849 1
      return TT_Err_Could_Not_Find_Context;
d879 21
a899 1
      error = TT_Err_Ok;
d1046 1
a1046 1
    FT_Error  error = TT_Err_Ok;
d1113 1
a1113 1
    FT_Error  error = TT_Err_Ok;
d1169 1
a1169 1
    FT_Error          error = TT_Err_Ok;
d1183 1
a1183 1
      return TT_Err_Invalid_PPem;
d1260 1
a1260 1
      return TT_Err_Could_Not_Find_Context;
d1268 1
a1268 1
    return TT_Err_Ok;
@


1.11
log
@Update to freetype-2.4.10.

With help and ok matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2011                                                    */
d767 1
a767 1
    exec->F_dot_P          = 0x10000L;
d1193 1
a1193 2
      size->ttmetrics.y_ratio = FT_MulDiv( metrics->y_ppem,
                                           0x10000L,
d1200 1
a1200 2
      size->ttmetrics.x_ratio = FT_MulDiv( metrics->x_ppem,
                                           0x10000L,
@


1.10
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@d247 1
a247 1
#define TRICK_SFNT_IDS_NUM_FACES  13
d320 20
@


1.9
log
@Update to freetype 2.4.6.

For now, omit the patch to ttdriver.c that changes some font metrics and
appearance of applications using TrueType fonts. Will revisit once the
issue is solved.
@
text
@d331 1
a331 1
                sizeof( int ) * TRICK_SFNT_IDS_NUM_FACES );
d496 2
d499 2
a500 1
    sfnt    = (SFNT_Service)FT_Get_Module_Interface( library, "sfnt" );
d502 5
a506 1
      goto Bad_Format;
d524 1
a524 1
      FT_TRACE2(( "[not a valid TTF font]\n" ));
@


1.8
log
@Update to freetype 2.4.5. Tested by many.
@
text
@d412 48
d555 14
d579 13
@


1.7
log
@Update to freetype 2.4.4. Tested by shadchin@@, ajacoutot@@, krw@@.
@
text
@d7 1
a7 2
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
d216 1
d219 1
d221 1
a221 1
    else if ( !face->goto_table )
d224 4
a227 4
    else if ( !face->goto_table( face,
                                 face->dir_tables[i].Tag,
                                 face->root.stream,
                                 NULL ) )
d247 1
a247 1
#define TRICK_SFNT_IDS_NUM_FACES  5
d280 40
d323 5
a327 3
    FT_ULong  checksum;
    int       num_matched_ids[TRICK_SFNT_IDS_NUM_FACES];
    int       i, j, k;
d332 3
d344 1
d349 1
d354 1
d375 12
d397 4
a400 8
    /* First, check the face name. */
    if ( face->family_name )
    {
      if ( tt_check_trickyness_family( face->family_name ) )
        return TRUE;
      else
        return FALSE;
    }
d630 3
a632 1
  /*    size :: A handle to the size object.                               */
d638 2
a639 1
  tt_size_run_fpgm( TT_Size  size )
d657 2
a658 2
    exec->callTop   = 0;
    exec->top       = 0;
d665 3
a667 1
    exec->F_dot_P = 0x10000L;
d724 3
a726 1
  /*    size :: A handle to the size object.                               */
d732 2
a733 1
  tt_size_run_prep( TT_Size  size )
d756 2
d836 2
a837 1
  tt_size_init_bytecode( FT_Size  ftsize )
d910 1
a910 1
    error = tt_size_run_fpgm( size );
d921 2
a922 1
  tt_size_ready_bytecode( TT_Size  size )
d929 1
a929 1
      error = tt_size_init_bytecode( (FT_Size)size );
d961 1
a961 1
      error = tt_size_run_prep( size );
@


1.6
log
@Update to freetype 2.4.3. Tested at least by krw@@, ajacoutot@@ and jasper@@
@
text
@d150 1
a150 1
  tt_check_trickyness( FT_String*  name )
d152 1
d154 4
a157 2
#define TRICK_NAMES_COUNT 8
    static const char trick_names[TRICK_NAMES_COUNT][TRICK_NAMES_MAX_CHARACTERS+1] =
d168 1
a171 5
    if ( !name )
      return TRUE;

    /* Note that we only check the face name at the moment; it might */
    /* be worth to do more checks for a few special cases.           */
d180 175
d429 1
a429 1
    if ( tt_check_trickyness( ttface->family_name ) )
@


1.5
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d7 2
a8 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
d153 1
a153 1
#define TRICK_NAMES_COUNT 7
d159 1
d169 1
a169 1
      return FALSE;
d463 3
d467 1
d529 3
d533 1
@


1.4
log
@Update to Freetype 2.3.9.

Bump major to be safe.
Small arm assembler fix in ftconfig.h by drahn@@
@
text
@a20 1
#include FT_INTERNAL_CALC_H
a21 1
#include FT_TRUETYPE_IDS_H
d151 3
a153 1
    static const char* const  trick_names[] =
a161 1
      NULL
d171 1
a171 1
    for ( nn = 0; trick_names[nn] != NULL; nn++ )
d614 1
a614 2
      FT_Size_Metrics*  metrics  = &size->metrics;
      TT_Size_Metrics*  metrics2 = &size->ttmetrics;
a615 2
      metrics->x_ppem = 0;
      metrics->y_ppem = 0;
d617 2
a618 2
      metrics2->rotated   = FALSE;
      metrics2->stretched = FALSE;
d622 1
a622 1
        metrics2->compensations[i] = 0;
@


1.3
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d156 1
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d147 32
d215 1
a215 1
    library = face->root.driver->root.library;
d241 1
a241 1
    face->root.face_flags |= FT_FACE_FLAG_HINTER;
d253 3
d260 1
a260 1
    if ( face->root.face_flags & FT_FACE_FLAG_SCALABLE )
d265 1
a265 1
      if ( !face->root.internal->incremental_interface )
a304 2
      /* Compare the face with a list of well-known `tricky' fonts. */
      /* This list shall be expanded as we find more of them.       */
d306 1
a306 29
      {
        static const char* const  trick_names[] =
        {
          "DFKaiSho-SB",     /* dfkaisb.ttf */
          "DFKai-SB",        /* kaiu.ttf */
          "HuaTianSongTi?",  /* htst3.ttf */
          "MingLiU",         /* mingliu.ttf & mingliu.ttc */
          "PMingLiU",        /* mingliu.ttc */
          "MingLi43",        /* mingli.ttf */
          NULL
        };
        int  nn;


        /* Note that we only check the face name at the moment; it might */
        /* be worth to do more checks for a few special cases.           */
        for ( nn = 0; trick_names[nn] != NULL; nn++ )
        {
          if ( ttface->family_name                               &&
               ft_strstr( ttface->family_name, trick_names[nn] ) )
          {
            unpatented_hinting = 1;
            break;
          }
        }
      }

      ttface->internal->ignore_unpatented_hinter =
        FT_BOOL( !unpatented_hinting );
d338 5
a342 3
    TT_Face       face   = (TT_Face)ttface;
    FT_Memory     memory = face->root.memory;
    FT_Stream     stream = face->root.stream;
d344 2
a345 1
    SFNT_Service  sfnt   = (SFNT_Service)face->sfnt;
d347 3
d688 1
a688 1
      TT_Face  face = (TT_Face) size->root.face;
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d32 1
a32 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d54 1
a54 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d86 1
d130 1
d144 1
a144 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d208 1
a208 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d233 5
a237 3
        error = tt_face_load_cvt( face, stream )  ||
                tt_face_load_fpgm( face, stream ) ||
                tt_face_load_prep( face, stream );
d242 7
a248 4
        error = tt_face_load_loca( face, stream ) ||
                tt_face_load_cvt( face, stream )  ||
                tt_face_load_fpgm( face, stream ) ||
                tt_face_load_prep( face, stream );
d254 2
a255 1
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
d257 3
a259 3
    /* Determine whether unpatented hinting is to be used for this face. */
    face->unpatented_hinting = FT_BOOL
       ( library->debug_hooks[ FT_DEBUG_HOOK_UNPATENTED_HINTING ] != NULL );
a260 2
    {
      int  i;
d262 3
d268 34
a301 1
          face->unpatented_hinting = TRUE;
d304 2
a305 1
#endif /* TT_CONFIG_OPTION_UNPATENTED_HINTING */
d375 1
a375 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d525 1
a525 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d528 4
a531 16
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_size_init                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initialize a new TrueType size object.                             */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    size :: A handle to the size object.                               */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_size_init( FT_Size  ttsize )           /* TT_Size */
d533 36
a568 2
    TT_Size   size  = (TT_Size)ttsize;
    FT_Error  error = TT_Err_Ok;
a569 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d571 8
a578 1
    TT_Face    face   = (TT_Face)size->root.face;
d586 3
d603 1
a603 1
      FT_Size_Metrics*  metrics  = &size->root.metrics;
a605 1

d622 1
a622 5
    {
      tt_size_done( ttsize );

      return error;
    }
d632 1
a632 5
    {
      tt_size_done( ttsize );

      return error;
    }
d652 1
d654 1
a654 1
      tt_size_done( ttsize );
d656 80
a735 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d758 1
a758 6
    TT_Size    size = (TT_Size)ttsize;

#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER

    FT_Memory  memory = size->root.face->memory;

a759 27
    if ( size->debug )
    {
      /* the debug context must be deleted by the debugger itself */
      size->context = NULL;
      size->debug   = FALSE;
    }

    FT_FREE( size->cvt );
    size->cvt_size = 0;

    /* free storage area */
    FT_FREE( size->storage );
    size->storage_size = 0;

    /* twilight zone */
    tt_glyphzone_done( &size->twilight );

    FT_FREE( size->function_defs );
    FT_FREE( size->instruction_defs );

    size->num_function_defs    = 0;
    size->max_function_defs    = 0;
    size->num_instruction_defs = 0;
    size->max_instruction_defs = 0;

    size->max_func = 0;
    size->max_ins  = 0;
d761 3
d844 3
a846 31

#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER

    {
      FT_UInt  i;


      /* Scale the cvt values to the new ppem.          */
      /* We use by default the y ppem to scale the CVT. */
      for ( i = 0; i < size->cvt_size; i++ )
        size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );

      /* All twilight points are originally zero */
      for ( i = 0; i < (FT_UInt)size->twilight.n_points; i++ )
      {
        size->twilight.org[i].x = 0;
        size->twilight.org[i].y = 0;
        size->twilight.cur[i].x = 0;
        size->twilight.cur[i].y = 0;
      }

      /* clear storage area */
      for ( i = 0; i < (FT_UInt)size->storage_size; i++ )
        size->storage[i] = 0;

      size->GS = tt_default_graphics_state;

      error = tt_size_run_prep( size );
    }

#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d873 1
a873 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d905 1
a905 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d32 1
a32 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d54 1
a54 1
#ifdef TT_USE_BYTECODE_INTERPRETER
a85 1
      FT_FREE( zone->orus );
a128 1
         FT_NEW_ARRAY( zone->orus,     maxPoints   ) ||
d142 1
a142 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d206 1
a206 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d247 5
a251 2
#if defined( TT_CONFIG_OPTION_UNPATENTED_HINTING    ) && \
    !defined( TT_CONFIG_OPTION_BYTECODE_INTERPRETER )
d254 1
a254 3
      FT_Bool  unpatented_hinting;
      int      i;

a255 3
      /* Determine whether unpatented hinting is to be used for this face. */
      unpatented_hinting = FT_BOOL
        ( library->debug_hooks[FT_DEBUG_HOOK_UNPATENTED_HINTING] != NULL );
d259 1
a259 34
          unpatented_hinting = TRUE;

      /* Compare the face with a list of well-known `tricky' fonts. */
      /* This list shall be expanded as we find more of them.       */
      if ( !unpatented_hinting )
      {
        static const char* const  trick_names[] =
        {
          "DFKaiSho-SB",     /* dfkaisb.ttf */
          "DFKai-SB",        /* kaiu.ttf */
          "HuaTianSongTi?",  /* htst3.ttf */
          "MingLiU",         /* mingliu.ttf & mingliu.ttc */
          "PMingLiU",        /* mingliu.ttc */
          "MingLi43",        /* mingli.ttf */
          NULL
        };
        int  nn;


        /* Note that we only check the face name at the moment; it might */
        /* be worth to do more checks for a few special cases.           */
        for ( nn = 0; trick_names[nn] != NULL; nn++ )
        {
          if ( ttface->family_name                               &&
               ft_strstr( ttface->family_name, trick_names[nn] ) )
          {
            unpatented_hinting = 1;
            break;
          }
        }
      }

      ttface->internal->ignore_unpatented_hinter =
        FT_BOOL( !unpatented_hinting );
d262 1
a262 2
#endif /* TT_CONFIG_OPTION_UNPATENTED_HINTING &&
          !TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d332 1
a332 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d482 1
a482 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d485 16
a500 4
#ifdef TT_USE_BYTECODE_INTERPRETER

  static void
  tt_size_done_bytecode( FT_Size  ftsize )
d502 2
a503 24
    TT_Size    size   = (TT_Size)ftsize;
    TT_Face    face   = (TT_Face)ftsize->face;
    FT_Memory  memory = face->root.memory;


    if ( size->debug )
    {
      /* the debug context must be deleted by the debugger itself */
      size->context = NULL;
      size->debug   = FALSE;
    }

    FT_FREE( size->cvt );
    size->cvt_size = 0;

    /* free storage area */
    FT_FREE( size->storage );
    size->storage_size = 0;

    /* twilight zone */
    tt_glyphzone_done( &size->twilight );

    FT_FREE( size->function_defs );
    FT_FREE( size->instruction_defs );
d505 1
a505 11
    size->num_function_defs    = 0;
    size->max_function_defs    = 0;
    size->num_instruction_defs = 0;
    size->max_instruction_defs = 0;

    size->max_func = 0;
    size->max_ins  = 0;

    size->bytecode_ready = 0;
    size->cvt_ready      = 0;
  }
d507 1
a507 9

  /* Initialize bytecode-related fields in the size object.       */
  /* We do this only if bytecode interpretation is really needed. */
  static FT_Error
  tt_size_init_bytecode( FT_Size  ftsize )
  {
    FT_Error   error;
    TT_Size    size = (TT_Size)ftsize;
    TT_Face    face = (TT_Face)ftsize->face;
a514 3
    size->bytecode_ready = 1;
    size->cvt_ready      = 0;

d529 1
a529 1
      FT_Size_Metrics*  metrics  = &size->metrics;
d532 1
d549 5
a553 1
      goto Exit;
d563 5
a567 1
      goto Exit;
a586 1
  Exit:
d588 1
a588 76
      tt_size_done_bytecode( ftsize );

    return error;
  }


  FT_LOCAL_DEF( FT_Error )
  tt_size_ready_bytecode( TT_Size  size )
  {
    FT_Error  error = TT_Err_Ok;


    if ( !size->bytecode_ready )
    {
      error = tt_size_init_bytecode( (FT_Size)size );
      if ( error )
        goto Exit;
    }

    /* rescale CVT when needed */
    if ( !size->cvt_ready )
    {
      FT_UInt  i;
      TT_Face  face = (TT_Face) size->root.face;


      /* Scale the cvt values to the new ppem.          */
      /* We use by default the y ppem to scale the CVT. */
      for ( i = 0; i < size->cvt_size; i++ )
        size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );

      /* all twilight points are originally zero */
      for ( i = 0; i < (FT_UInt)size->twilight.n_points; i++ )
      {
        size->twilight.org[i].x = 0;
        size->twilight.org[i].y = 0;
        size->twilight.cur[i].x = 0;
        size->twilight.cur[i].y = 0;
      }

      /* clear storage area */
      for ( i = 0; i < (FT_UInt)size->storage_size; i++ )
        size->storage[i] = 0;

      size->GS = tt_default_graphics_state;

      error = tt_size_run_prep( size );
      if ( !error )
          size->cvt_ready = 1;
    }
  Exit:
    return error;
  }

#endif /* TT_USE_BYTECODE_INTERPRETER */


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_size_init                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initialize a new TrueType size object.                             */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    size :: A handle to the size object.                               */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_size_init( FT_Size  ttsize )           /* TT_Size */
  {
    TT_Size   size  = (TT_Size)ttsize;
    FT_Error  error = TT_Err_Ok;
d590 1
a590 4
#ifdef TT_USE_BYTECODE_INTERPRETER
    size->bytecode_ready = 0;
    size->cvt_ready      = 0;
#endif
d613 13
a625 1
    TT_Size  size = (TT_Size)ttsize;
d627 20
a647 3
#ifdef TT_USE_BYTECODE_INTERPRETER
    if ( size->bytecode_ready )
      tt_size_done_bytecode( ttsize );
d728 31
a758 3
#ifdef TT_USE_BYTECODE_INTERPRETER
    size->cvt_ready = 0;
#endif /* TT_USE_BYTECODE_INTERPRETER */
d785 1
a785 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d817 1
a817 1
#ifdef TT_USE_BYTECODE_INTERPRETER
@

