head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.2
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.12.0.2
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.2
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.12
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.8
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2017.06.23.16.15.18;	author dcoppa;	state Exp;
branches;
next	1.12;
commitid	nHj0O50aY5QcUcQ4;

1.12
date	2016.10.28.21.41.15;	author dcoppa;	state Exp;
branches;
next	1.11;
commitid	T2hf37tVZU8TmjB1;

1.11
date	2016.08.09.07.16.09;	author dcoppa;	state Exp;
branches;
next	1.10;
commitid	C8TgUUJolulx9B5d;

1.10
date	2016.05.29.11.57.12;	author dcoppa;	state Exp;
branches;
next	1.9;
commitid	1dOLexdOAzW2mQjp;

1.9
date	2015.06.28.08.27.47;	author dcoppa;	state Exp;
branches;
next	1.8;
commitid	qXwIGV2h9uFjxAmt;

1.8
date	2014.12.26.17.52.35;	author dcoppa;	state Exp;
branches;
next	1.7;
commitid	gwhRExMduYqoPQHI;

1.7
date	2014.03.14.08.18.01;	author dcoppa;	state Exp;
branches;
next	1.6;

1.6
date	2014.01.12.15.08.27;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2013.01.04.16.51.58;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.18.20.29.58;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.09.01.19.14.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.45.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.45.19;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.32.29;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@
Update to freetype-2.8

No fallout in a bulk build on i386 (sthen@@)

OK matthieu@@, sthen@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  afhints.h                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines (specification).                        */
/*                                                                         */
/*  Copyright 2003-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#ifndef AFHINTS_H_
#define AFHINTS_H_

#include "aftypes.h"

#define xxAF_SORT_SEGMENTS

FT_BEGIN_HEADER

  /*
   *  The definition of outline glyph hints.  These are shared by all
   *  writing system analysis routines (until now).
   */

  typedef enum  AF_Dimension_
  {
    AF_DIMENSION_HORZ = 0,  /* x coordinates,                    */
                            /* i.e., vertical segments & edges   */
    AF_DIMENSION_VERT = 1,  /* y coordinates,                    */
                            /* i.e., horizontal segments & edges */

    AF_DIMENSION_MAX  /* do not remove */

  } AF_Dimension;


  /* hint directions -- the values are computed so that two vectors are */
  /* in opposite directions iff `dir1 + dir2 == 0'                      */
  typedef enum  AF_Direction_
  {
    AF_DIR_NONE  =  4,
    AF_DIR_RIGHT =  1,
    AF_DIR_LEFT  = -1,
    AF_DIR_UP    =  2,
    AF_DIR_DOWN  = -2

  } AF_Direction;


  /*
   *  The following explanations are mostly taken from the article
   *
   *    Real-Time Grid Fitting of Typographic Outlines
   *
   *  by David Turner and Werner Lemberg
   *
   *    http://www.tug.org/TUGboat/Articles/tb24-3/lemberg.pdf
   *
   *  with appropriate updates.
   *
   *
   *  Segments
   *
   *    `af_{cjk,latin,...}_hints_compute_segments' are the functions to
   *    find segments in an outline.
   *
   *    A segment is a series of at least two consecutive points that are
   *    approximately aligned along a coordinate axis.  The analysis to do
   *    so is specific to a writing system.
   *
   *
   *  Edges
   *
   *    `af_{cjk,latin,...}_hints_compute_edges' are the functions to find
   *    edges.
   *
   *    As soon as segments are defined, the auto-hinter groups them into
   *    edges.  An edge corresponds to a single position on the main
   *    dimension that collects one or more segments (allowing for a small
   *    threshold).
   *
   *    As an example, the `latin' writing system first tries to grid-fit
   *    edges, then to align segments on the edges unless it detects that
   *    they form a serif.
   *
   *
   *                      A          H
   *                       |        |
   *                       |        |
   *                       |        |
   *                       |        |
   *         C             |        |             F
   *          +------<-----+        +-----<------+
   *          |             B      G             |
   *          |                                  |
   *          |                                  |
   *          +--------------->------------------+
   *         D                                    E
   *
   *
   *  Stems
   *
   *    Stems are detected by `af_{cjk,latin,...}_hint_edges'.
   *
   *    Segments need to be `linked' to other ones in order to detect stems.
   *    A stem is made of two segments that face each other in opposite
   *    directions and that are sufficiently close to each other.  Using
   *    vocabulary from the TrueType specification, stem segments form a
   *    `black distance'.
   *
   *    In the above ASCII drawing, the horizontal segments are BC, DE, and
   *    FG; the vertical segments are AB, CD, EF, and GH.
   *
   *    Each segment has at most one `best' candidate to form a black
   *    distance, or no candidate at all.  Notice that two distinct segments
   *    can have the same candidate, which frequently means a serif.
   *
   *    A stem is recognized by the following condition:
   *
   *      best segment_1 = segment_2 && best segment_2 = segment_1
   *
   *    The best candidate is stored in field `link' in structure
   *    `AF_Segment'.
   *
   *    In the above ASCII drawing, the best candidate for both AB and CD is
   *    GH, while the best candidate for GH is AB.  Similarly, the best
   *    candidate for EF and GH is AB, while the best candidate for AB is
   *    GH.
   *
   *    The detection and handling of stems is dependent on the writing
   *    system.
   *
   *
   *  Serifs
   *
   *    Serifs are detected by `af_{cjk,latin,...}_hint_edges'.
   *
   *    In comparison to a stem, a serif (as handled by the auto-hinter
   *    module that takes care of the `latin' writing system) has
   *
   *      best segment_1 = segment_2 && best segment_2 != segment_1
   *
   *    where segment_1 corresponds to the serif segment (CD and EF in the
   *    above ASCII drawing).
   *
   *    The best candidate is stored in field `serif' in structure
   *    `AF_Segment' (and `link' is set to NULL).
   *
   *
   *  Touched points
   *
   *    A point is called `touched' if it has been processed somehow by the
   *    auto-hinter.  It basically means that it shouldn't be moved again
   *    (or moved only under certain constraints to preserve the already
   *    applied processing).
   *
   *
   *  Flat and round segments
   *
   *    Segments are `round' or `flat', depending on the series of points
   *    that define them.  A segment is round if the next and previous point
   *    of an extremum (which can be either a single point or sequence of
   *    points) are both conic or cubic control points.  Otherwise, a
   *    segment with an extremum is flat.
   *
   *
   *  Strong Points
   *
   *    Experience has shown that points not part of an edge need to be
   *    interpolated linearly between their two closest edges, even if these
   *    are not part of the contour of those particular points.  Typical
   *    candidates for this are
   *
   *    - angle points (i.e., points where the `in' and `out' direction
   *      differ greatly)
   *
   *    - inflection points (i.e., where the `in' and `out' angles are the
   *      same, but the curvature changes sign) [currently, such points
   *      aren't handled specially in the auto-hinter]
   *
   *    `af_glyph_hints_align_strong_points' is the function that takes
   *    care of such situations; it is equivalent to the TrueType `IP'
   *    hinting instruction.
   *
   *
   *  Weak Points
   *
   *    Other points in the outline must be interpolated using the
   *    coordinates of their previous and next unfitted contour neighbours.
   *    These are called `weak points' and are touched by the function
   *    `af_glyph_hints_align_weak_points', equivalent to the TrueType `IUP'
   *    hinting instruction.  Typical candidates are control points and
   *    points on the contour without a major direction.
   *
   *    The major effect is to reduce possible distortion caused by
   *    alignment of edges and strong points, thus weak points are processed
   *    after strong points.
   */


  /* point hint flags */
#define AF_FLAG_NONE  0

  /* point type flags */
#define AF_FLAG_CONIC    ( 1U << 0 )
#define AF_FLAG_CUBIC    ( 1U << 1 )
#define AF_FLAG_CONTROL  ( AF_FLAG_CONIC | AF_FLAG_CUBIC )

  /* point touch flags */
#define AF_FLAG_TOUCH_X  ( 1U << 2 )
#define AF_FLAG_TOUCH_Y  ( 1U << 3 )

  /* candidates for weak interpolation have this flag set */
#define AF_FLAG_WEAK_INTERPOLATION  ( 1U << 4 )

  /* the distance to the next point is very small */
#define AF_FLAG_NEAR  ( 1U << 5 )


  /* edge hint flags */
#define AF_EDGE_NORMAL  0
#define AF_EDGE_ROUND    ( 1U << 0 )
#define AF_EDGE_SERIF    ( 1U << 1 )
#define AF_EDGE_DONE     ( 1U << 2 )
#define AF_EDGE_NEUTRAL  ( 1U << 3 ) /* edge aligns to a neutral blue zone */


  typedef struct AF_PointRec_*    AF_Point;
  typedef struct AF_SegmentRec_*  AF_Segment;
  typedef struct AF_EdgeRec_*     AF_Edge;


  typedef struct  AF_PointRec_
  {
    FT_UShort  flags;    /* point flags used by hinter   */
    FT_Char    in_dir;   /* direction of inwards vector  */
    FT_Char    out_dir;  /* direction of outwards vector */

    FT_Pos     ox, oy;   /* original, scaled position                   */
    FT_Short   fx, fy;   /* original, unscaled position (in font units) */
    FT_Pos     x, y;     /* current position                            */
    FT_Pos     u, v;     /* current (x,y) or (y,x) depending on context */

    AF_Point   next;     /* next point in contour     */
    AF_Point   prev;     /* previous point in contour */

  } AF_PointRec;


  typedef struct  AF_SegmentRec_
  {
    FT_Byte     flags;       /* edge/segment flags for this segment */
    FT_Char     dir;         /* segment direction                   */
    FT_Short    pos;         /* position of segment                 */
    FT_Short    delta;       /* deviation from segment position     */
    FT_Short    min_coord;   /* minimum coordinate of segment       */
    FT_Short    max_coord;   /* maximum coordinate of segment       */
    FT_Short    height;      /* the hinted segment height           */

    AF_Edge     edge;        /* the segment's parent edge           */
    AF_Segment  edge_next;   /* link to next segment in parent edge */

    AF_Segment  link;        /* (stem) link segment        */
    AF_Segment  serif;       /* primary segment for serifs */
    FT_Pos      score;       /* used during stem matching  */
    FT_Pos      len;         /* used during stem matching  */

    AF_Point    first;       /* first point in edge segment */
    AF_Point    last;        /* last point in edge segment  */

  } AF_SegmentRec;


  typedef struct  AF_EdgeRec_
  {
    FT_Short    fpos;       /* original, unscaled position (in font units) */
    FT_Pos      opos;       /* original, scaled position                   */
    FT_Pos      pos;        /* current position                            */

    FT_Byte     flags;      /* edge flags                                   */
    FT_Char     dir;        /* edge direction                               */
    FT_Fixed    scale;      /* used to speed up interpolation between edges */

    AF_Width    blue_edge;  /* non-NULL if this is a blue edge */
    AF_Edge     link;       /* link edge                       */
    AF_Edge     serif;      /* primary edge for serifs         */
    FT_Int      score;      /* used during stem matching       */

    AF_Segment  first;      /* first segment in edge */
    AF_Segment  last;       /* last segment in edge  */

  } AF_EdgeRec;

#define AF_SEGMENTS_EMBEDDED  18   /* number of embedded segments   */
#define AF_EDGES_EMBEDDED     12   /* number of embedded edges      */

  typedef struct  AF_AxisHintsRec_
  {
    FT_Int        num_segments; /* number of used segments      */
    FT_Int        max_segments; /* number of allocated segments */
    AF_Segment    segments;     /* segments array               */
#ifdef AF_SORT_SEGMENTS
    FT_Int        mid_segments;
#endif

    FT_Int        num_edges;    /* number of used edges      */
    FT_Int        max_edges;    /* number of allocated edges */
    AF_Edge       edges;        /* edges array               */

    AF_Direction  major_dir;    /* either vertical or horizontal */

    /* two arrays to avoid allocation penalty */
    struct
    {
      AF_SegmentRec  segments[AF_SEGMENTS_EMBEDDED];
      AF_EdgeRec     edges[AF_EDGES_EMBEDDED];
    } embedded;


  } AF_AxisHintsRec, *AF_AxisHints;


#define AF_POINTS_EMBEDDED     96   /* number of embedded points   */
#define AF_CONTOURS_EMBEDDED    8   /* number of embedded contours */

  typedef struct  AF_GlyphHintsRec_
  {
    FT_Memory        memory;

    FT_Fixed         x_scale;
    FT_Pos           x_delta;

    FT_Fixed         y_scale;
    FT_Pos           y_delta;

    FT_Int           max_points;    /* number of allocated points */
    FT_Int           num_points;    /* number of used points      */
    AF_Point         points;        /* points array               */

    FT_Int           max_contours;  /* number of allocated contours */
    FT_Int           num_contours;  /* number of used contours      */
    AF_Point*        contours;      /* contours array               */

    AF_AxisHintsRec  axis[AF_DIMENSION_MAX];

    FT_UInt32        scaler_flags;  /* copy of scaler flags    */
    FT_UInt32        other_flags;   /* free for style-specific */
                                    /* implementations         */
    AF_StyleMetrics  metrics;

    FT_Pos           xmin_delta;    /* used for warping */
    FT_Pos           xmax_delta;

    /* Two arrays to avoid allocation penalty.            */
    /* The `embedded' structure must be the last element! */
    struct
    {
      AF_Point       contours[AF_CONTOURS_EMBEDDED];
      AF_PointRec    points[AF_POINTS_EMBEDDED];
    } embedded;

  } AF_GlyphHintsRec;


#define AF_HINTS_TEST_SCALER( h, f )  ( (h)->scaler_flags & (f) )
#define AF_HINTS_TEST_OTHER( h, f )   ( (h)->other_flags  & (f) )


#ifdef FT_DEBUG_AUTOFIT

#define AF_HINTS_DO_HORIZONTAL( h )                                     \
          ( !_af_debug_disable_horz_hints                            && \
            !AF_HINTS_TEST_SCALER( h, AF_SCALER_FLAG_NO_HORIZONTAL ) )

#define AF_HINTS_DO_VERTICAL( h )                                     \
          ( !_af_debug_disable_vert_hints                          && \
            !AF_HINTS_TEST_SCALER( h, AF_SCALER_FLAG_NO_VERTICAL ) )

#define AF_HINTS_DO_BLUES( h )  ( !_af_debug_disable_blue_hints )

#else /* !FT_DEBUG_AUTOFIT */

#define AF_HINTS_DO_HORIZONTAL( h )                                \
          !AF_HINTS_TEST_SCALER( h, AF_SCALER_FLAG_NO_HORIZONTAL )

#define AF_HINTS_DO_VERTICAL( h )                                \
          !AF_HINTS_TEST_SCALER( h, AF_SCALER_FLAG_NO_VERTICAL )

#define AF_HINTS_DO_BLUES( h )  1

#endif /* !FT_DEBUG_AUTOFIT */


#define AF_HINTS_DO_ADVANCE( h )                                \
          !AF_HINTS_TEST_SCALER( h, AF_SCALER_FLAG_NO_ADVANCE )

#define AF_HINTS_DO_WARP( h )                                  \
          !AF_HINTS_TEST_SCALER( h, AF_SCALER_FLAG_NO_WARPER )



  FT_LOCAL( AF_Direction )
  af_direction_compute( FT_Pos  dx,
                        FT_Pos  dy );


  FT_LOCAL( FT_Error )
  af_axis_hints_new_segment( AF_AxisHints  axis,
                             FT_Memory     memory,
                             AF_Segment   *asegment );

  FT_LOCAL( FT_Error)
  af_axis_hints_new_edge( AF_AxisHints  axis,
                          FT_Int        fpos,
                          AF_Direction  dir,
                          FT_Bool       top_to_bottom_hinting,
                          FT_Memory     memory,
                          AF_Edge      *edge );

  FT_LOCAL( void )
  af_glyph_hints_init( AF_GlyphHints  hints,
                       FT_Memory      memory );

  FT_LOCAL( void )
  af_glyph_hints_rescale( AF_GlyphHints    hints,
                          AF_StyleMetrics  metrics );

  FT_LOCAL( FT_Error )
  af_glyph_hints_reload( AF_GlyphHints  hints,
                         FT_Outline*    outline );

  FT_LOCAL( void )
  af_glyph_hints_save( AF_GlyphHints  hints,
                       FT_Outline*    outline );

  FT_LOCAL( void )
  af_glyph_hints_align_edge_points( AF_GlyphHints  hints,
                                    AF_Dimension   dim );

  FT_LOCAL( void )
  af_glyph_hints_align_strong_points( AF_GlyphHints  hints,
                                      AF_Dimension   dim );

  FT_LOCAL( void )
  af_glyph_hints_align_weak_points( AF_GlyphHints  hints,
                                    AF_Dimension   dim );

#ifdef AF_CONFIG_OPTION_USE_WARPER
  FT_LOCAL( void )
  af_glyph_hints_scale_dim( AF_GlyphHints  hints,
                            AF_Dimension   dim,
                            FT_Fixed       scale,
                            FT_Pos         delta );
#endif

  FT_LOCAL( void )
  af_glyph_hints_done( AF_GlyphHints  hints );

/* */

#define AF_SEGMENT_LEN( seg )          ( (seg)->max_coord - (seg)->min_coord )

#define AF_SEGMENT_DIST( seg1, seg2 )  ( ( (seg1)->pos > (seg2)->pos )   \
                                           ? (seg1)->pos - (seg2)->pos   \
                                           : (seg2)->pos - (seg1)->pos )


FT_END_HEADER

#endif /* AFHINTS_H_ */


/* END */
@


1.12
log
@
Update to FreeType 2.7

Now Subpixel hinting, also known as ClearType hinting, is enabled
by default.

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2003-2016 by                                                 */
@


1.11
log
@
Update to FreeType 2.6.5

ok matthieu@@
@
text
@d263 1
@


1.10
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d224 3
a271 1
    FT_Pos      num_linked;  /* number of linked segments  */
a293 1
    FT_Short    num_linked; /* number of linked edges          */
@


1.9
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2003-2015 by                                                 */
d19 2
a20 2
#ifndef __AFHINTS_H__
#define __AFHINTS_H__
d422 1
d476 1
a476 1
#endif /* __AFHINTS_H__ */
@


1.8
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2003-2008, 2010-2012, 2014 by                                */
d210 1
a210 12
  typedef enum  AF_Flags_
  {
    AF_FLAG_NONE = 0,

    /* point type flags */
    AF_FLAG_CONIC   = 1 << 0,
    AF_FLAG_CUBIC   = 1 << 1,
    AF_FLAG_CONTROL = AF_FLAG_CONIC | AF_FLAG_CUBIC,

    /* point touch flags */
    AF_FLAG_TOUCH_X = 1 << 2,
    AF_FLAG_TOUCH_Y = 1 << 3,
d212 8
a219 2
    /* candidates for weak interpolation have this flag set */
    AF_FLAG_WEAK_INTERPOLATION = 1 << 4
d221 2
a222 1
  } AF_Flags;
d226 5
a230 9
  typedef enum  AF_Edge_Flags_
  {
    AF_EDGE_NORMAL  = 0,
    AF_EDGE_ROUND   = 1 << 0,
    AF_EDGE_SERIF   = 1 << 1,
    AF_EDGE_DONE    = 1 << 2,
    AF_EDGE_NEUTRAL = 1 << 3  /* set if edge aligns to a neutral blue zone */

  } AF_Edge_Flags;
d300 2
d318 8
d329 3
d360 8
a384 3
#define AF_HINTS_DO_ADVANCE( h )                                \
          !AF_HINTS_TEST_SCALER( h, AF_SCALER_FLAG_NO_ADVANCE )

d395 5
d403 2
a404 1
#define AF_HINTS_DO_BLUES( h )  1
a405 1
#endif /* !FT_DEBUG_AUTOFIT */
@


1.7
log
@
Security/bugfixing update to freetype-2.5.3, featuring a fix for a
vulnerability in the CFF driver (CVE-2014-2240) and assorted minor
fixes.

ok matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2003-2008, 2010-2012 by                                      */
d75 3
a77 7
   *    A segment is a series of consecutive points that are approximately
   *    aligned along a coordinate axis.  The analysis to do so is specific
   *    to a writing system.
   *
   *    A segment must have at least two points, except in the case of
   *    `fake' segments that are generated to hint metrics appropriately,
   *    and which consist of a single point.
d147 1
a147 1
   *    module which takes care of the `latin' writing system) has
d177 4
a180 4
   *    Experience has shown that points which are not part of an edge need
   *    to be interpolated linearly between their two closest edges, even if
   *    these are not part of the contour of those particular points.
   *    Typical candidates for this are
d187 1
a187 1
   *      aren't handled in the auto-hinter]
d189 1
a189 1
   *    `af_glyph_hints_align_strong_points' is the function which takes
a218 8
    /* point extremum flags */
    AF_FLAG_EXTREMA_X = 1 << 2,
    AF_FLAG_EXTREMA_Y = 1 << 3,

    /* point roundness flags */
    AF_FLAG_ROUND_X = 1 << 4,
    AF_FLAG_ROUND_Y = 1 << 5,

d220 2
a221 2
    AF_FLAG_TOUCH_X = 1 << 6,
    AF_FLAG_TOUCH_Y = 1 << 7,
d224 1
a224 7
    AF_FLAG_WEAK_INTERPOLATION = 1 << 8,

    /* all inflection points in the outline have this flag set */
    AF_FLAG_INFLECTION = 1 << 9,

    /* the current point is very near to another one */
    AF_FLAG_NEAR = 1 << 10
d232 5
a236 4
    AF_EDGE_NORMAL = 0,
    AF_EDGE_ROUND  = 1 << 0,
    AF_EDGE_SERIF  = 1 << 1,
    AF_EDGE_DONE   = 1 << 2
@


1.6
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d30 1
a30 1
   *  script analysis routines (until now).
d346 1
a346 1
    FT_Memory         memory;
d348 2
a349 2
    FT_Fixed          x_scale;
    FT_Pos            x_delta;
d351 2
a352 2
    FT_Fixed          y_scale;
    FT_Pos            y_delta;
d354 3
a356 3
    FT_Int            max_points;    /* number of allocated points */
    FT_Int            num_points;    /* number of used points      */
    AF_Point          points;        /* points array               */
d358 3
a360 3
    FT_Int            max_contours;  /* number of allocated contours */
    FT_Int            num_contours;  /* number of used contours      */
    AF_Point*         contours;      /* contours array               */
d362 1
a362 1
    AF_AxisHintsRec   axis[AF_DIMENSION_MAX];
d364 4
a367 4
    FT_UInt32         scaler_flags;  /* copy of scaler flags     */
    FT_UInt32         other_flags;   /* free for script-specific */
                                     /* implementations          */
    AF_ScriptMetrics  metrics;
d369 2
a370 2
    FT_Pos            xmin_delta;    /* used for warping */
    FT_Pos            xmax_delta;
d432 2
a433 2
  af_glyph_hints_rescale( AF_GlyphHints     hints,
                          AF_ScriptMetrics  metrics );
@


1.5
log
@Update to freetype 2.4.11. Tested by krw@@, jasper@@ and on a bulk ports
build by naddy@@.
@
text
@d65 3
a67 1
   *   http://www.tug.org/TUGboat/Articles/tb24-3/lemberg.pdf
d73 5
a77 3
   *    find segments in an outline.  A segment is a series of consecutive
   *    points that are approximately aligned along a coordinate axis.  The
   *    analysis to do so is specific to a script.
d86 3
d94 3
a96 5
   *    The auto-hinter first tries to grid fit edges, then to align
   *    segments on the edges unless it detects that they form a serif.
   *
   *    `af_{cjk,latin,...}_hints_compute_edges' are the functions to find
   *    edges; they are specific to a script.
d115 2
a136 2
   *    Stems are detected by `af_{cjk,latin,...}_hint_edges'.
   *
d142 3
d148 4
a151 1
   *    On the opposite, a serif has
a160 2
   *    Serifs are detected by `af_{cjk,latin,...}_hint_edges'.
   *
d190 2
a191 1
   *      same, but the curvature changes sign)
d239 4
a242 1
    AF_FLAG_INFLECTION = 1 << 9
@


1.4
log
@Update to freetype 2.4.5. Tested by many.
@
text
@d7 1
a7 1
/*  Copyright 2003-2008, 2010-2011 by                                      */
d257 1
a257 1
    FT_Short   fx, fy;   /* original, unscaled position (font units)    */
d293 3
a295 3
    FT_Short    fpos;       /* original, unscaled position (font units) */
    FT_Pos      opos;       /* original, scaled position                */
    FT_Pos      pos;        /* current position                         */
a299 1
    AF_Width    blue_edge;  /* non-NULL if this is a blue edge              */
d301 5
a305 4
    AF_Edge     link;       /* link edge                 */
    AF_Edge     serif;      /* primary edge for serifs   */
    FT_Short    num_linked; /* number of linked edges    */
    FT_Int      score;      /* used during stem matching */
@


1.3
log
@Update to freetype 2.4.2. This has been in snapshots for a while
and tested explicitely by ajacoutot@@ jasper@@, jcs@@, krw@@ and others
on various architectures.
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2010 by                  */
d28 4
a31 4
 /*
  *  The definition of outline glyph hints.  These are shared by all
  *  script analysis routines (until now).
  */
d58 145
d285 2
a286 3
    AF_Point    first;       /* first point in edge segment             */
    AF_Point    last;        /* last point in edge segment              */
    AF_Point*   contour;     /* ptr to first point of segment's contour */
d302 4
a305 5
    AF_Edge     link;
    AF_Edge     serif;
    FT_Short    num_linked;

    FT_Int      score;
d307 2
a308 2
    AF_Segment  first;
    AF_Segment  last;
d315 3
a317 3
    FT_Int        num_segments;
    FT_Int        max_segments;
    AF_Segment    segments;
d322 3
a324 3
    FT_Int        num_edges;
    FT_Int        max_edges;
    AF_Edge       edges;
d326 1
a326 1
    AF_Direction  major_dir;
d341 7
a347 9
    FT_Pos            edge_distance_threshold;

    FT_Int            max_points;
    FT_Int            num_points;
    AF_Point          points;

    FT_Int            max_contours;
    FT_Int            num_contours;
    AF_Point*         contours;
d358 1
a358 1
    
d366 1
a366 1
#ifdef AF_DEBUG
d381 1
a381 1
#else /* !AF_DEBUG */
d394 1
a394 1
#endif /* !AF_DEBUG */
a417 6


  /*
   *  recompute all AF_Point in a AF_GlyphHints from the definitions
   *  in a source outline
   */
d442 1
a442 1
#ifdef AF_USE_WARPER
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008 by                        */
d289 1
a289 2
                         FT_Outline*    outline,
                         FT_Bool        get_inflections );
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
d24 1
d33 1
a33 1
  typedef enum
d47 1
a47 1
  typedef enum
d59 1
a59 1
  typedef enum
d90 1
a90 1
  typedef enum
d129 1
d175 3
d215 3
d224 18
d251 4
d269 1
d289 2
a290 1
                         FT_Outline*    outline );
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007 by                              */
a23 1
#define xxAF_SORT_SEGMENTS
a127 1
    FT_Short    height;      /* the hinted segment height           */
a172 3
#ifdef AF_SORT_SEGMENTS
    FT_Int        mid_segments;
#endif
a209 3
    FT_Pos            xmin_delta;    /* used for warping */
    FT_Pos            xmax_delta;
    
a215 18

#ifdef AF_DEBUG

#define AF_HINTS_DO_HORIZONTAL( h )                                     \
          ( !_af_debug_disable_horz_hints                            && \
            !AF_HINTS_TEST_SCALER( h, AF_SCALER_FLAG_NO_HORIZONTAL ) )

#define AF_HINTS_DO_VERTICAL( h )                                     \
          ( !_af_debug_disable_vert_hints                          && \
            !AF_HINTS_TEST_SCALER( h, AF_SCALER_FLAG_NO_VERTICAL ) )

#define AF_HINTS_DO_ADVANCE( h )                                \
          !AF_HINTS_TEST_SCALER( h, AF_SCALER_FLAG_NO_ADVANCE )

#define AF_HINTS_DO_BLUES( h )  ( !_af_debug_disable_blue_hints )

#else /* !AF_DEBUG */

a224 4
#define AF_HINTS_DO_BLUES( h )  1

#endif /* !AF_DEBUG */

a238 1
                          AF_Direction  dir,
d258 1
a258 2
                         FT_Outline*    outline,
                         FT_Bool        get_inflections );
@

