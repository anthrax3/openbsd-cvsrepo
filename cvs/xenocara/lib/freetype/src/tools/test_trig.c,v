head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.8
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.6
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.1.1.0.24
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.22
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.20
	OPENBSD_5_0:1.1.1.1.0.18
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.14
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v2_3_5:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.01.10.17.17.23;	author dcoppa;	state Exp;
branches;
next	1.3;
commitid	2tSYQMWVSV3t7clo;

1.3
date	2013.10.10.19.49.58;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.07.17.21.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.55;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.55;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@
Bugfixing update to freetype-2.5.5

ok matthieu@@
@
text
@#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_TRIGONOMETRY_H

#include <math.h>
#include <stdio.h>

#define  PI   3.14159265358979323846
#define  SPI  (PI/FT_ANGLE_PI)

/* the precision in 16.16 fixed-point checks. Expect between 2 and 5 */
/* noise LSB bits during operations, due to rounding errors..        */
#define  THRESHOLD  64

  static  error = 0;

  static void
  test_cos( void )
  {
    int  i;


    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000L )
    {
      FT_Fixed  f1, f2;
      double    d2;


      f1 = FT_Cos(i);
      d2 = cos( i*SPI );
      f2 = (FT_Fixed)(d2*65536.0);

      if ( abs( f2-f1 ) > THRESHOLD )
      {
        error = 1;
        printf( "FT_Cos[%3d] = %.7f  cos[%3d] = %.7f\n",
                (i >> 16), f1/65536.0, (i >> 16), d2 );
      }
    }
  }


  static void
  test_sin( void )
  {
    int  i;


    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000L )
    {
      FT_Fixed  f1, f2;
      double    d2;


      f1 = FT_Sin(i);
      d2 = sin( i*SPI );
      f2 = (FT_Fixed)(d2*65536.0);

      if ( abs( f2-f1 ) > THRESHOLD )
      {
        error = 1;
        printf( "FT_Sin[%3d] = %.7f  sin[%3d] = %.7f\n",
                (i >> 16), f1/65536.0, (i >> 16), d2 );
      }
    }
  }


  static void
  test_tan( void )
  {
    int  i;


    for ( i = 0; i < FT_ANGLE_PI2 - 0x2000000L; i += 0x10000L )
    {
      FT_Fixed  f1, f2;
      double    d2;


      f1 = FT_Tan(i);
      d2 = tan( i*SPI );
      f2 = (FT_Fixed)(d2*65536.0);

      if ( abs( f2-f1 ) > THRESHOLD )
      {
        error = 1;
        printf( "FT_Tan[%3d] = %.7f  tan[%3d] = %.7f\n",
                (i >> 16), f1/65536.0, (i >> 16), d2 );
      }
    }
  }


  static void
  test_atan2( void )
  {
    int  i;


    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000L )
    {
      FT_Fixed  c2, s2;
      double    l, a, c1, s1;
      int       j;


      l  = 5.0;
      a  = i*SPI;

      c1 = l * cos(a);
      s1 = l * sin(a);

      c2 = (FT_Fixed)(c1*65536.0);
      s2 = (FT_Fixed)(s1*65536.0);

      j  = FT_Atan2( c2, s2 );
      if ( j < 0 )
        j += FT_ANGLE_2PI;

      if ( abs( i - j ) > 1 )
      {
        printf( "FT_Atan2( %.7f, %.7f ) = %.5f, atan = %.5f\n",
                c2/65536.0, s2/65536.0, j/65536.0, i/65536.0 );
      }
    }
  }


  static void
  test_unit( void )
  {
    int  i;


    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000L )
    {
      FT_Vector  v;
      double     a, c1, s1;
      FT_Fixed   c2, s2;


      FT_Vector_Unit( &v, i );
      a  = ( i*SPI );
      c1 = cos(a);
      s1 = sin(a);
      c2 = (FT_Fixed)(c1*65536.0);
      s2 = (FT_Fixed)(s1*65536.0);

      if ( abs( v.x-c2 ) > THRESHOLD ||
           abs( v.y-s2 ) > THRESHOLD )
      {
        error = 1;
        printf( "FT_Vector_Unit[%3d] = ( %.7f, %.7f )  vec = ( %.7f, %.7f )\n",
                (i >> 16),
                v.x/65536.0, v.y/65536.0,
                c1, s1 );
      }
    }
  }


  static void
  test_length( void )
  {
    int  i;


    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000L )
    {
      FT_Vector  v;
      FT_Fixed   l, l2;


      l   = (FT_Fixed)(500.0*65536.0);
      v.x = (FT_Fixed)( l * cos( i*SPI ) );
      v.y = (FT_Fixed)( l * sin( i*SPI ) );
      l2  = FT_Vector_Length( &v );

      if ( abs( l2-l ) > THRESHOLD )
      {
        error = 1;
        printf( "FT_Length( %.7f, %.7f ) = %.5f, length = %.5f\n",
                v.x/65536.0, v.y/65536.0, l2/65536.0, l/65536.0 );
      }
    }
  }


  static void
  test_rotate( void )
  {
    int  rotate;


    for ( rotate = 0; rotate < FT_ANGLE_2PI; rotate += 0x10000L )
    {
      double  ra, cra, sra;
      int     i;


      ra  = rotate*SPI;
      cra = cos( ra );
      sra = sin( ra );

      for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000L )
      {
        FT_Fixed   c2, s2, c4, s4;
        FT_Vector  v;
        double     l, a, c1, s1, c3, s3;


        l  = 500.0;
        a  = i*SPI;

        c1 = l * cos(a);
        s1 = l * sin(a);

        v.x = c2 = (FT_Fixed)(c1*65536.0);
        v.y = s2 = (FT_Fixed)(s1*65536.0);

        FT_Vector_Rotate( &v, rotate );

        c3 = c1 * cra - s1 * sra;
        s3 = c1 * sra + s1 * cra;

        c4 = (FT_Fixed)(c3*65536.0);
        s4 = (FT_Fixed)(s3*65536.0);

        if ( abs( c4 - v.x ) > THRESHOLD ||
             abs( s4 - v.y ) > THRESHOLD )
        {
          error = 1;
          printf( "FT_Rotate( (%.7f,%.7f), %.5f ) = ( %.7f, %.7f ), rot = ( %.7f, %.7f )\n",
                  c1, s1, ra,
                  c2/65536.0, s2/65536.0,
                  c4/65536.0, s4/65536.0 );
        }
      }
    }
  }


  int main( void )
  {
    test_cos();
    test_sin();
    test_tan();
    test_atan2();
    test_unit();
    test_length();
    test_rotate();

    if (!error)
      printf( "trigonometry test ok !\n" );

    return !error;
  }
@


1.3
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@d23 1
a23 1
    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000 )
d49 1
a49 1
    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000 )
d75 1
a75 1
    for ( i = 0; i < FT_ANGLE_PI2-0x2000000; i += 0x10000 )
d101 1
a101 1
    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000 )
d136 1
a136 1
    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000 )
d169 1
a169 1
    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000 )
d196 1
a196 1
    for ( rotate = 0; rotate < FT_ANGLE_2PI; rotate += 0x10000 )
d206 1
a206 1
      for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000 )
@


1.2
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@d20 2
a21 3
    FT_Fixed  f1, f2;
    double    d1, d2;
    int       i;
d25 4
a29 1
      d1 = f1/65536.0;
a42 1

d46 2
a47 3
    FT_Fixed  f1, f2;
    double    d1, d2;
    int       i;
d51 4
a55 1
      d1 = f1/65536.0;
d72 2
a73 3
    FT_Fixed  f1, f2;
    double    d1, d2;
    int       i;
d77 4
a81 1
      d1 = f1/65536.0;
d98 2
a99 3
    FT_Fixed  c2, s2;
    double    l, a, c1, s1;
    int       i, j;
d103 5
d129 1
d133 2
a134 4
    FT_Vector  v;
    double     a, c1, s1;
    FT_Fixed   c2, s2;
    int        i;
d138 5
d166 2
a167 3
    FT_Vector  v;
    FT_Fixed   l, l2;
    int        i;
d171 4
d193 2
a194 4
    FT_Fixed  c2, s2, c4, s4;
    FT_Vector v;
    double    l, ra, a, c1, s1, cra, sra, c3, s3;
    int       i, j, rotate;
d198 4
d208 5
@


1.1
log
@Initial revision
@
text
@d11 2
a12 3
/* the precision in 16.16 fixed float points of the checks. Expect */
/* between 2 and 5 noise LSB bits during operations, due to        */
/* rounding errors..                                               */
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@
