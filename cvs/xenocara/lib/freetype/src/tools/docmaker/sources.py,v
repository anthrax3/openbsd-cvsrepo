head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.7.0.2
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.14
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.12
	OPENBSD_5_0:1.3.0.10
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.6
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.8
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2016.05.29.11.57.14;	author dcoppa;	state Exp;
branches;
next	1.9;
commitid	1dOLexdOAzW2mQjp;

1.9
date	2015.12.07.09.34.04;	author dcoppa;	state Exp;
branches;
next	1.8;
commitid	wZOPiDmcwgRFTDVL;

1.8
date	2015.10.19.07.51.38;	author dcoppa;	state Exp;
branches;
next	1.7;
commitid	d2XmJCtYff11VIDu;

1.7
date	2015.06.28.08.27.50;	author dcoppa;	state Exp;
branches;
next	1.6;
commitid	qXwIGV2h9uFjxAmt;

1.6
date	2014.12.26.17.52.36;	author dcoppa;	state Exp;
branches;
next	1.5;
commitid	gwhRExMduYqoPQHI;

1.5
date	2014.01.12.15.08.28;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.04.16.51.59;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.26.07.31.45;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.56;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.56;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.33.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@#
#  sources.py
#
#    Convert source code comments to multi-line blocks (library file).
#
#  Copyright 2002-2016 by
#  David Turner.
#
#  This file is part of the FreeType project, and may only be used,
#  modified, and distributed under the terms of the FreeType project
#  license, LICENSE.TXT.  By continuing to use, modify, or distribute
#  this file you indicate that you have read the license and
#  understand and accept it fully.

#
# This library file contains definitions of classes needed to decompose C
# source code files into a series of multi-line `blocks'.  There are two
# kinds of blocks.
#
#   - Normal blocks, which contain source code or ordinary comments.
#
#   - Documentation blocks, which have restricted formatting, and whose text
#     always start with a documentation markup tag like `<Function>',
#     `<Type>', etc.
#
# The routines to process the content of documentation blocks are contained
# in file `content.py'; the classes and methods found here only deal with
# text parsing and basic documentation block extraction.
#


import fileinput, re, sys, os, string


################################################################
##
##  SOURCE BLOCK FORMAT CLASS
##
##  A simple class containing compiled regular expressions to detect
##  potential documentation format block comments within C source code.
##
##  The `column' pattern must contain a group to `unbox' the content of
##  documentation comment blocks.
##
##  Later on, paragraphs are converted to long lines, which simplifies the
##  regular expressions that act upon the text.
##
class  SourceBlockFormat:

    def  __init__( self, id, start, column, end ):
        """Create a block pattern, used to recognize special documentation
           blocks."""
        self.id     = id
        self.start  = re.compile( start, re.VERBOSE )
        self.column = re.compile( column, re.VERBOSE )
        self.end    = re.compile( end, re.VERBOSE )


#
# Format 1 documentation comment blocks.
#
#    /************************************/ (at least 2 asterisks)
#    /*                                  */
#    /*                                  */
#    /*                                  */
#    /************************************/ (at least 2 asterisks)
#
start = r'''
  \s*      # any number of whitespace
  /\*{2,}/ # followed by '/' and at least two asterisks then '/'
  \s*$     # probably followed by whitespace
'''

column = r'''
  \s*      # any number of whitespace
  /\*{1}   # followed by '/' and precisely one asterisk
  ([^*].*) # followed by anything (group 1)
  \*{1}/   # followed by one asterisk and a '/'
  \s*$     # probably followed by whitespace
'''

re_source_block_format1 = SourceBlockFormat( 1, start, column, start )


#
# Format 2 documentation comment blocks.
#
#    /************************************ (at least 2 asterisks)
#     *
#     *                                    (1 asterisk)
#     *
#     */                                   (1 or more asterisks)
#
start = r'''
  \s*     # any number of whitespace
  /\*{2,} # followed by '/' and at least two asterisks
  \s*$    # probably followed by whitespace
'''

column = r'''
  \s*           # any number of whitespace
  \*{1}(?![*/]) # followed by precisely one asterisk not followed by `/'
  (.*)          # then anything (group1)
'''

end = r'''
  \s*  # any number of whitespace
  \*+/ # followed by at least one asterisk, then '/'
'''

re_source_block_format2 = SourceBlockFormat( 2, start, column, end )


#
# The list of supported documentation block formats.  We could add new ones
# quite easily.
#
re_source_block_formats = [re_source_block_format1, re_source_block_format2]


#
# The following regular expressions correspond to markup tags within the
# documentation comment blocks.  They are equivalent despite their different
# syntax.
#
# A markup tag consists of letters or character `-', to be found in group 1.
#
# Notice that a markup tag _must_ begin a new paragraph.
#
re_markup_tag1 = re.compile( r'''\s*<((?:\w|-)*)>''' )  # <xxxx> format
re_markup_tag2 = re.compile( r'''\s*@@((?:\w|-)*):''' )  # @@xxxx: format

#
# The list of supported markup tags.  We could add new ones quite easily.
#
re_markup_tags = [re_markup_tag1, re_markup_tag2]


#
# A regular expression to detect a cross reference, after markup tags have
# been stripped off.
#
# Two syntax forms are supported:
#
#   @@<name>
#   @@<name>[<id>]
#
# where both `<name>' and `<id>' consist of alphanumeric characters, `_',
# and `-'.  Use `<id>' if there are multiple, valid `<name>' entries.
#
# Example: @@foo[bar]
#
re_crossref = re.compile( r"""
                            @@
                            (?P<name>(?:\w|-)+
                                     (?:\[(?:\w|-)+\])?)
                            (?P<rest>.*)
                          """, re.VERBOSE )

#
# Two regular expressions to detect italic and bold markup, respectively.
# Group 1 is the markup, group 2 the rest of the line.
#
# Note that the markup is limited to words consisting of letters, digits,
# the characters `_' and `-', or an apostrophe (but not as the first
# character).
#
re_italic = re.compile( r"_((?:\w|-)(?:\w|'|-)*)_(.*)" )     #  _italic_
re_bold   = re.compile( r"\*((?:\w|-)(?:\w|'|-)*)\*(.*)" )   #  *bold*

#
# This regular expression code to identify an URL has been taken from
#
#   http://mail.python.org/pipermail/tutor/2002-September/017228.html
#
# (with slight modifications).
#
urls = r'(?:https?|telnet|gopher|file|wais|ftp)'
ltrs = r'\w'
gunk = r'/#~:.?+=&%@@!\-'
punc = r'.:?\-'
any  = "%(ltrs)s%(gunk)s%(punc)s" % { 'ltrs' : ltrs,
                                      'gunk' : gunk,
                                      'punc' : punc }
url  = r"""
         (
           \b                    # start at word boundary
           %(urls)s :            # need resource and a colon
           [%(any)s] +?          # followed by one or more of any valid
                                 # character, but be conservative and
                                 # take only what you need to...
           (?=                   # [look-ahead non-consumptive assertion]
             [%(punc)s]*         # either 0 or more punctuation
             (?:                 # [non-grouping parentheses]
               [^%(any)s] | $    # followed by a non-url char
                                 # or end of the string
             )
           )
         )
        """ % {'urls' : urls,
               'any'  : any,
               'punc' : punc }

re_url = re.compile( url, re.VERBOSE | re.MULTILINE )

#
# A regular expression that stops collection of comments for the current
# block.
#
re_source_sep = re.compile( r'\s*/\*\s*\*/' )   #  /* */

#
# A regular expression to find possible C identifiers while outputting
# source code verbatim, covering things like `*foo' or `(bar'.  Group 1 is
# the prefix, group 2 the identifier -- since we scan lines from left to
# right, sequentially splitting the source code into prefix and identifier
# is fully sufficient for our purposes.
#
re_source_crossref = re.compile( r'(\W*)(\w*)' )

#
# A regular expression that matches a list of reserved C source keywords.
#
re_source_keywords = re.compile( '''\\b ( typedef   |
                                          struct    |
                                          enum      |
                                          union     |
                                          const     |
                                          char      |
                                          int       |
                                          short     |
                                          long      |
                                          void      |
                                          signed    |
                                          unsigned  |
                                          \#include |
                                          \#define  |
                                          \#undef   |
                                          \#if      |
                                          \#ifdef   |
                                          \#ifndef  |
                                          \#else    |
                                          \#endif   ) \\b''', re.VERBOSE )


################################################################
##
##  SOURCE BLOCK CLASS
##
##  There are two important fields in a `SourceBlock' object.
##
##    self.lines
##      A list of text lines for the corresponding block.
##
##    self.content
##      For documentation comment blocks only, this is the block content
##      that has been `unboxed' from its decoration.  This is `None' for all
##      other blocks (i.e., sources or ordinary comments with no starting
##      markup tag)
##
class  SourceBlock:

    def  __init__( self, processor, filename, lineno, lines ):
        self.processor = processor
        self.filename  = filename
        self.lineno    = lineno
        self.lines     = lines[:]
        self.format    = processor.format
        self.content   = []

        if self.format == None:
            return

        words = []

        # extract comment lines
        lines = []

        for line0 in self.lines:
            m = self.format.column.match( line0 )
            if m:
                lines.append( m.group( 1 ) )

        # now, look for a markup tag
        for l in lines:
            l = string.strip( l )
            if len( l ) > 0:
                for tag in re_markup_tags:
                    if tag.match( l ):
                        self.content = lines
                        return

    def  location( self ):
        return "(" + self.filename + ":" + repr( self.lineno ) + ")"

    # debugging only -- not used in normal operations
    def  dump( self ):
        if self.content:
            print "{{{content start---"
            for l in self.content:
                print l
            print "---content end}}}"
            return

        fmt = ""
        if self.format:
            fmt = repr( self.format.id ) + " "

        for line in self.lines:
            print line


################################################################
##
##  SOURCE PROCESSOR CLASS
##
##  The `SourceProcessor' is in charge of reading a C source file and
##  decomposing it into a series of different `SourceBlock' objects.
##
##  A SourceBlock object consists of the following data.
##
##    - A documentation comment block using one of the layouts above.  Its
##      exact format will be discussed later.
##
##    - Normal sources lines, including comments.
##
##
class  SourceProcessor:

    def  __init__( self ):
        """Initialize a source processor."""
        self.blocks   = []
        self.filename = None
        self.format   = None
        self.lines    = []

    def  reset( self ):
        """Reset a block processor and clean up all its blocks."""
        self.blocks = []
        self.format = None

    def  parse_file( self, filename ):
        """Parse a C source file and add its blocks to the processor's
           list."""
        self.reset()

        self.filename = filename

        fileinput.close()
        self.format = None
        self.lineno = 0
        self.lines  = []

        for line in fileinput.input( filename ):
            # strip trailing newlines, important on Windows machines!
            if line[-1] == '\012':
                line = line[0:-1]

            if self.format == None:
                self.process_normal_line( line )
            else:
                if self.format.end.match( line ):
                    # A normal block end.  Add it to `lines' and create a
                    # new block
                    self.lines.append( line )
                    self.add_block_lines()
                elif self.format.column.match( line ):
                    # A normal column line.  Add it to `lines'.
                    self.lines.append( line )
                else:
                    # An unexpected block end.  Create a new block, but
                    # don't process the line.
                    self.add_block_lines()

                    # we need to process the line again
                    self.process_normal_line( line )

        # record the last lines
        self.add_block_lines()

    def  process_normal_line( self, line ):
        """Process a normal line and check whether it is the start of a new
           block."""
        for f in re_source_block_formats:
            if f.start.match( line ):
                self.add_block_lines()
                self.format = f
                self.lineno = fileinput.filelineno()

        self.lines.append( line )

    def  add_block_lines( self ):
        """Add the current accumulated lines and create a new block."""
        if self.lines != []:
            block = SourceBlock( self,
                                 self.filename,
                                 self.lineno,
                                 self.lines )

            self.blocks.append( block )
            self.format = None
            self.lines  = []

    # debugging only, not used in normal operations
    def  dump( self ):
        """Print all blocks in a processor."""
        for b in self.blocks:
            b.dump()

# eof
@


1.9
log
@
Bugfixing update to freetype-2.6.2

Tested on amd64, i386, macppc, sparc64, loongson and compile-tested
on arm by matthieu@@
Also tested in a ports bulk build by naddy@@

OK matthieu@@
@
text
@d6 1
a6 1
#  Copyright 2002-2015 by
@


1.8
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@d141 1
a141 2
# been stripped off.  Group 1 is the reference, group 2 the rest of the
# line.
d143 1
a143 1
# A cross reference consists of letters, digits, or characters `-' and `_'.
d145 14
a158 1
re_crossref = re.compile( r'@@((?:\w|-)*)(.*)' )    #  @@foo
@


1.7
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d153 2
a154 1
# the character `_', or an apostrophe (but not as the first character).
d156 2
a157 2
re_italic = re.compile( r"_(\w(?:\w|')*)_(.*)" )     #  _italic_
re_bold   = re.compile( r"\*(\w(?:\w|')*)\*(.*)" )   #  *bold*
@


1.6
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d6 1
a6 1
#  Copyright 2002-2004, 2006-2009, 2012-2014 by
@


1.5
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@a0 2
#  Sources (c) 2002-2004, 2006-2009, 2012, 2013
#    David Turner <david@@freetype.org>
d2 1
d4 1
a4 3
# this file contains definitions of classes needed to decompose
# C sources files into a series of multi-line "blocks". There are
# two kinds of blocks:
d6 2
a7 1
#   - normal blocks, which contain source code or ordinary comments
d9 12
a20 3
#   - documentation blocks, which have restricted formatting, and
#     whose text always start with a documentation markup tag like
#     "<Function>", "<Type>", etc..
d22 3
a24 2
# the routines used to process the content of documentation blocks
# are not contained here, but in "content.py"
d26 3
a28 2
# the classes and methods found here only deal with text parsing
# and basic documentation block extraction
d31 1
a34 1

d37 4
a40 1
##  BLOCK FORMAT PATTERN
d42 2
a43 3
##   A simple class containing compiled regular expressions used
##   to detect potential documentation format block comments within
##   C source code
d45 2
a46 2
##   note that the 'column' pattern must contain a group that will
##   be used to "unbox" the content of documentation comment blocks
d51 2
a52 1
        """create a block pattern, used to recognize special documentation blocks"""
a58 1

d60 1
a60 1
# format 1 documentation comment blocks look like the following:
d62 1
a62 1
#    /************************************/
d66 1
a66 3
#    /************************************/
#
# we define a few regular expressions here to detect them
a67 1

d86 1
a86 1
# format 2 documentation comment blocks look like the following:
d90 1
d92 1
a92 5
#     *
#     *
#     **/       (1 or more asterisks at the end)
#
# we define a few regular expressions here to detect them
d101 3
a103 3
  \s*        # any number of whitespace
  \*{1}(?!/) # followed by precisely one asterisk not followed by `/'
  (.*)       # then anything (group1)
d115 2
a116 2
# the list of supported documentation block formats, we could add new ones
# relatively easily
d122 5
a126 3
# the following regular expressions corresponds to markup tags
# within the documentation comment blocks. they're equivalent
# despite their different syntax
d128 1
a128 1
# notice how each markup tag _must_ begin a new line
d134 1
a134 2
# the list of supported markup tags, we could add new ones relatively
# easily
d138 1
d140 5
a144 1
# used to detect a cross-reference, after markup tags have been stripped
d149 5
a153 1
# used to detect italic and bold styles in paragraph text
d155 2
a156 2
re_italic = re.compile( r"_(\w(\w|')*)_(.*)" )     #  _italic_
re_bold   = re.compile( r"\*(\w(\w|')*)\*(.*)" )   #  *bold*
d159 1
a159 1
# this regular expression code to identify an URL has been taken from
d163 1
a163 1
# (with slight modifications)
a164 1

d194 2
a195 1
# used to detect the end of commented source lines
d197 1
a197 1
re_source_sep = re.compile( r'\s*/\*\s*\*/' )
d200 5
a204 1
# used to perform cross-reference within source output
d209 1
a209 1
# a list of reserved source keywords
d237 1
a237 8
##   A SourceProcessor is in charge of reading a C source file
##   and decomposing it into a series of different "SourceBlocks".
##   each one of these blocks can be made of the following data:
##
##   - A documentation comment block that starts with "/**" and
##     whose exact format will be discussed later
##
##   - normal sources lines, including comments
d239 2
a240 1
##   the important fields in a text block are the following ones:
d242 5
a246 7
##     self.lines   : a list of text lines for the corresponding block
##
##     self.content : for documentation comment blocks only, this is the
##                    block content that has been "unboxed" from its
##                    decoration. This is None for all other blocks
##                    (i.e. sources or ordinary comments with no starting
##                     markup tag)
d283 1
a283 1
    # debugging only - not used in normal operations
a299 1

d304 2
a305 3
##   The SourceProcessor is in charge of reading a C source file
##   and decomposing it into a series of different "SourceBlock"
##   objects.
d307 1
a307 1
##   each one of these blocks can be made of the following data:
d309 2
a310 2
##   - A documentation comment block that starts with "/**" and
##     whose exact format will be discussed later
d312 1
a312 1
##   - normal sources lines, include comments
d318 1
a318 1
        """initialize a source processor"""
d325 1
a325 1
        """reset a block processor, clean all its blocks"""
d330 2
a331 1
        """parse a C source file, and add its blocks to the processor's list"""
d350 2
a351 2
                    # that's a normal block end, add it to 'lines' and
                    # create a new block
d355 1
a355 1
                    # that's a normal column line, add it to 'lines'
d358 2
a359 2
                    # humm.. this is an unexpected block end,
                    # create a new block, but don't process the line
d369 2
a370 1
        """process a normal line and check whether it is the start of a new block"""
d380 1
a380 1
        """add the current accumulated lines and create a new block"""
d382 4
a385 1
            block = SourceBlock( self, self.filename, self.lineno, self.lines )
d393 1
a393 1
        """print all blocks in a processor"""
@


1.4
log
@Update to freetype 2.4.11. Tested by krw@@, jasper@@ and on a bulk ports
build by naddy@@.
@
text
@d1 1
a1 1
#  Sources (c) 2002-2004, 2006-2009, 2012
d135 1
a135 1
re_crossref = re.compile( r'@@((?:\w|-)*)(.*)' )
d142 36
@


1.3
log
@Update to Freetype 2.3.9.

Bump major to be safe.
Small arm assembler fix in ftconfig.h by drahn@@
@
text
@d1 1
a1 1
#  Sources (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009
d123 2
a124 2
re_markup_tag1 = re.compile( r'''\s*<(\w*)>''' )  # <xxxx> format
re_markup_tag2 = re.compile( r'''\s*@@(\w*):''' )  # @@xxxx: format
d135 1
a135 1
re_crossref = re.compile( r'@@(\w*)(.*)' )
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d1 1
a1 1
#  Sources (c) 2002, 2003, 2004, 2006, 2007, 2008
d182 1
a182 1
##   A SourceProcessor is in charge or reading a C source file
d189 1
a189 1
##   - normal sources lines, include comments
d258 1
a258 1
##   The SourceProcessor is in charge or reading a C source file
d304 1
a304 1
                    # that's a normal block end, add it to lines and
@


1.1
log
@Initial revision
@
text
@d1 3
d21 1
a25 3



d37 1
a37 1
class SourceBlockFormat:
d39 1
a39 1
    def __init__( self, id, start, column, end ):
a40 1

d61 3
a63 3
  \s*       # any number of whitespace
  /\*{2,}/  # followed by '/' and at least two asterisks then '/'
  \s*$      # eventually followed by whitespace
d71 1
a71 1
  \s*$     # enventually followed by whitespace
d76 1
d92 1
a92 1
  \s*$    # eventually followed by whitespace
d96 3
a98 3
  \s*         # any number of whitespace
  \*{1}(?!/)  # followed by precisely one asterisk not followed by `/'
  (.*)        # then anything (group1)
d102 2
a103 2
  \s*     # any number of whitespace
  \*+/    # followed by at least one asterisk, then '/'
d108 1
d113 1
a113 1
re_source_block_formats = [ re_source_block_format1, re_source_block_format2 ]
d130 1
a130 1
re_markup_tags = [ re_markup_tag1, re_markup_tag2 ]
d177 1
d201 3
a203 2
class SourceBlock:
    def __init__( self, processor, filename, lineno, lines ):
d222 1
a222 1
                lines.append( m.group(1) )
d226 2
a227 2
            l = string.strip(l)
            if len(l) > 0:
d231 1
a231 4
                return

    def location( self ):
        return "(" + self.filename + ":" + repr(self.lineno) + ")"
d233 2
d237 1
a237 2
    def dump( self ):

d247 1
a247 1
            fmt = repr(self.format.id) + " "
d253 1
d270 1
a270 1
class SourceProcessor:
a283 1

d285 1
a285 2
        """parse a C source file, and adds its blocks to the processor's list"""

d291 3
a293 3
        self.format    = None
        self.lineno    = 0
        self.lines     = []
d296 2
a297 3

            # strip trailing newlines, important on Windows machines !!
            if  line[-1] == '\012':
a301 1

a307 1

a310 1

d312 1
a312 1
                    # humm.. this is an unexcepted block end,
d322 2
a323 4


    def process_normal_line( self, line ):
        """process a normal line and check if it's the start of a new block"""
d325 4
a328 4
          if f.start.match( line ):
            self.add_block_lines()
            self.format = f
            self.lineno = fileinput.filelineno()
d332 2
a333 4


    def add_block_lines( self ):
        """add the current accumulated lines, and create a new block"""
a340 1

d342 1
a342 1
    def dump( self ):
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@a0 3
#  Sources (c) 2002, 2003, 2004, 2006, 2007
#    David Turner <david@@freetype.org>
#
d71 1
a71 1
  \s*$     # eventually followed by whitespace
d315 1
a315 1
                    # humm.. this is an unexpected block end,
@

