head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.2
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.2.0.26
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.24
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.22
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.20
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.18
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.16
	OPENBSD_5_0:1.2.0.14
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.10
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.12
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.8
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2016.05.29.11.57.14;	author dcoppa;	state Exp;
branches;
next	1.6;
commitid	1dOLexdOAzW2mQjp;

1.6
date	2015.12.07.09.34.04;	author dcoppa;	state Exp;
branches;
next	1.5;
commitid	wZOPiDmcwgRFTDVL;

1.5
date	2015.06.28.08.27.50;	author dcoppa;	state Exp;
branches;
next	1.4;
commitid	qXwIGV2h9uFjxAmt;

1.4
date	2015.01.10.17.17.24;	author dcoppa;	state Exp;
branches;
next	1.3;
commitid	2tSYQMWVSV3t7clo;

1.3
date	2014.12.26.17.52.36;	author dcoppa;	state Exp;
branches;
next	1.2;
commitid	gwhRExMduYqoPQHI;

1.2
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.56;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.56;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.33.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@#
#  formatter.py
#
#    Convert parsed content blocks to a structured document (library file).
#
#  Copyright 2002-2016 by
#  David Turner.
#
#  This file is part of the FreeType project, and may only be used,
#  modified, and distributed under the terms of the FreeType project
#  license, LICENSE.TXT.  By continuing to use, modify, or distribute
#  this file you indicate that you have read the license and
#  understand and accept it fully.

#
# This is the base Formatter class.  Its purpose is to convert a content
# processor's data into specific documents (i.e., table of contents, global
# index, and individual API reference indices).
#
# You need to sub-class it to output anything sensible.  For example, the
# file `tohtml.py' contains the definition of the `HtmlFormatter' sub-class
# to output HTML.
#


from sources import *
from content import *
from utils   import *


################################################################
##
##  FORMATTER CLASS
##
class  Formatter:

    def  __init__( self, processor ):
        self.processor   = processor
        self.identifiers = {}
        self.chapters    = processor.chapters
        self.sections    = processor.sections.values()
        self.block_index = []

        # store all blocks in a dictionary
        self.blocks = []
        for section in self.sections:
            for block in section.blocks.values():
                self.add_identifier( block.name, block )

                # add enumeration values to the index, since this is useful
                for markup in block.markups:
                    if markup.tag == 'values':
                        for field in markup.fields:
                            self.add_identifier( field.name, block )

        self.block_index = self.identifiers.keys()
        self.block_index.sort( key = index_key )

        # also add section names to dictionary (without making them appear
        # in the index)
        for section in self.sections:
            self.add_identifier( section.name, section )

    def  add_identifier( self, name, block ):
        if name in self.identifiers:
            # duplicate name!
            sys.stderr.write( "WARNING: duplicate definition for"
                              + " '" + name + "' "
                              + "in " + block.location() + ", "
                              + "previous definition in "
                              + self.identifiers[name].location()
                              + "\n" )
        else:
            self.identifiers[name] = block

    #
    # formatting the table of contents
    #
    def  toc_enter( self ):
        pass

    def  toc_chapter_enter( self, chapter ):
        pass

    def  toc_section_enter( self, section ):
        pass

    def  toc_section_exit( self, section ):
        pass

    def  toc_chapter_exit( self, chapter ):
        pass

    def  toc_index( self, index_filename ):
        pass

    def  toc_exit( self ):
        pass

    def  toc_dump( self, toc_filename = None, index_filename = None ):
        output = None
        if toc_filename:
            output = open_output( toc_filename )

        self.toc_enter()

        for chap in self.processor.chapters:

            self.toc_chapter_enter( chap )

            for section in chap.sections:
                self.toc_section_enter( section )
                self.toc_section_exit( section )

            self.toc_chapter_exit( chap )

        self.toc_index( index_filename )

        self.toc_exit()

        if output:
            close_output( output )

    #
    # formatting the index
    #
    def  index_enter( self ):
        pass

    def  index_name_enter( self, name ):
        pass

    def  index_name_exit( self, name ):
        pass

    def  index_exit( self ):
        pass

    def  index_dump( self, index_filename = None ):
        output = None
        if index_filename:
            output = open_output( index_filename )

        self.index_enter()

        for name in self.block_index:
            self.index_name_enter( name )
            self.index_name_exit( name )

        self.index_exit()

        if output:
            close_output( output )

    #
    # formatting a section
    #
    def  section_enter( self, section ):
        pass

    def  block_enter( self, block ):
        pass

    def  markup_enter( self, markup, block = None ):
        pass

    def  field_enter( self, field, markup = None, block = None ):
        pass

    def  field_exit( self, field, markup = None, block = None ):
        pass

    def  markup_exit( self, markup, block = None ):
        pass

    def  block_exit( self, block ):
        pass

    def  section_exit( self, section ):
        pass

    def  section_dump( self, section, section_filename = None ):
        output = None
        if section_filename:
            output = open_output( section_filename )

        self.section_enter( section )

        for name in section.block_names:
            skip_entry = 0
            try:
                block = self.identifiers[name]
                # `block_names' can contain field names also,
                # which we filter out
                for markup in block.markups:
                    if markup.tag == 'values':
                        for field in markup.fields:
                            if field.name == name:
                                skip_entry = 1
            except:
                skip_entry = 1   # this happens e.g. for `/empty/' entries

            if skip_entry:
              continue

            self.block_enter( block )

            for markup in block.markups[1:]:   # always ignore first markup!
                self.markup_enter( markup, block )

                for field in markup.fields:
                    self.field_enter( field, markup, block )
                    self.field_exit( field, markup, block )

                self.markup_exit( markup, block )

            self.block_exit( block )

        self.section_exit( section )

        if output:
            close_output( output )

    def  section_dump_all( self ):
        for section in self.sections:
            self.section_dump( section )

# eof
@


1.6
log
@
Bugfixing update to freetype-2.6.2

Tested on amd64, i386, macppc, sparc64, loongson and compile-tested
on arm by matthieu@@
Also tested in a ports bulk build by naddy@@

OK matthieu@@
@
text
@d6 1
a6 1
#  Copyright 2002-2015 by
@


1.5
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d59 5
@


1.4
log
@
Bugfixing update to freetype-2.5.5

ok matthieu@@
@
text
@d6 1
a6 1
#  Copyright 2002, 2004, 2007, 2008, 2014 by
@


1.3
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d199 1
a199 1
              continue;
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d1 22
a22 1
#  Formatter (c) 2002, 2004, 2007, 2008 David Turner <david@@freetype.org>
d25 1
a29 8
# This is the base Formatter class.  Its purpose is to convert
# a content processor's data into specific documents (i.e., table of
# contents, global index, and individual API reference indices).
#
# You need to sub-class it to output anything sensible.  For example,
# the file tohtml.py contains the definition of the HtmlFormatter sub-class
# used to output -- you guessed it -- HTML.
#
d31 4
d57 1
a57 1
        self.block_index.sort( index_sort )
d60 1
a60 1
        if self.identifiers.has_key( name ):
d62 6
a67 4
            sys.stderr.write(                                           \
               "WARNING: duplicate definition for '" + name + "' in " + \
               block.location() + ", previous definition in " +         \
               self.identifiers[name].location() + "\n" )
d72 1
a72 1
    #  Formatting the table of contents
d120 1
a120 1
    #  Formatting the index
d151 1
a151 1
    #  Formatting a section
d185 16
a200 1
            block = self.identifiers[name]
@


1.1
log
@Initial revision
@
text
@d1 3
d8 2
a9 2
# This is the base Formatter class. its purpose is to convert
# a content processor's data into specific documents (i.e. table of
d12 1
a12 1
# You'll need to sub-class it to output anything sensible.  For example,
d14 1
a14 1
# used to output, you guessed it, HTML.
d17 1
a17 3
class Formatter:

    def __init__( self, processor ):
d19 1
d27 1
a27 1
        self.blocks      = []
d31 1
a31 1
                    
a37 1

d41 1
a41 2

    def add_identifier( self, name, block ):
d43 2
a44 2
            # duplicate name !!
            sys.stderr.write( \
d47 1
a47 1
               self.identifiers[ name ].location() + "\n" )
a49 1
              
a53 1

d56 1
a56 1
    
d59 1
a59 1
    
d62 1
a62 1
        
d65 1
a65 1
        
d71 1
a71 1
    
a75 1
        
d79 1
a79 1
        
d81 1
a81 1
    
d83 1
a83 1
    
d85 1
a85 1
    
d89 3
a91 3
    
            self.toc_chapter_exit ( chap )
    
d93 1
a93 1
    
d98 1
a98 1
    
a101 1

a114 1
        
d123 1
a123 1
            self.index_name_exit ( name )
d126 1
a126 1
     
d129 1
a129 1
     
d135 1
a135 1
    
d138 1
a138 1
    
d141 1
a141 1
    
d144 1
a144 1
        
d147 1
a147 1
    
d150 1
a150 1
        
a156 1

a157 1
        
d161 1
a161 1
        
d165 1
a165 1
            block = self.identifiers[ name ]
d168 1
a168 1
            for markup in block.markups[1:]:   # always ignore first markup !!
d173 1
a173 2

                    self.field_exit ( field, markup, block )
d179 1
a179 1
        self.section_exit ( section )
d184 1
a184 2

    def section_dump_all( self ):
d188 1
a188 7
    #
    #  Formatting a block
    #




@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@a0 3
#  Formatter (c) 2002, 2004, 2007 David Turner <david@@freetype.org>
#

d5 2
a6 2
# This is the base Formatter class.  Its purpose is to convert
# a content processor's data into specific documents (i.e., table of
d9 1
a9 1
# You need to sub-class it to output anything sensible.  For example,
d11 1
a11 1
# used to output -- you guessed it -- HTML.
d29 1
a29 1

d50 1
a50 1

d58 1
a58 1

d61 1
a61 1

d64 1
a64 1

d67 1
a67 1

d73 1
a73 1

d78 1
a78 1

d82 1
a82 1

d84 1
a84 1

d86 1
a86 1

d88 1
a88 1

d92 1
a92 1

d94 1
a94 1

d96 1
a96 1

d101 1
a101 1

d119 1
a119 1

d131 1
a131 1

d134 1
a134 1

d140 1
a140 1

d143 1
a143 1

d146 1
a146 1

d149 1
a149 1

d152 1
a152 1

d155 1
a155 1

d164 1
a164 1

d168 1
a168 1

d201 3
a203 1
# eof
@

