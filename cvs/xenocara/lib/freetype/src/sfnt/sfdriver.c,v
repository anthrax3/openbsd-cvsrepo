head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.2
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.14.0.2
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2017.01.13.11.20.00;	author dcoppa;	state Exp;
branches;
next	1.18;
commitid	ESXG9TuEmwmBXggf;

1.18
date	2016.10.28.21.41.15;	author dcoppa;	state Exp;
branches;
next	1.17;
commitid	T2hf37tVZU8TmjB1;

1.17
date	2016.05.29.11.57.14;	author dcoppa;	state Exp;
branches;
next	1.16;
commitid	1dOLexdOAzW2mQjp;

1.16
date	2015.12.07.09.34.04;	author dcoppa;	state Exp;
branches;
next	1.15;
commitid	wZOPiDmcwgRFTDVL;

1.15
date	2015.10.19.07.51.38;	author dcoppa;	state Exp;
branches;
next	1.14;
commitid	d2XmJCtYff11VIDu;

1.14
date	2015.06.28.08.27.49;	author dcoppa;	state Exp;
branches;
next	1.13;
commitid	qXwIGV2h9uFjxAmt;

1.13
date	2015.01.10.17.17.23;	author dcoppa;	state Exp;
branches;
next	1.12;
commitid	2tSYQMWVSV3t7clo;

1.12
date	2014.12.26.17.52.35;	author dcoppa;	state Exp;
branches;
next	1.11;
commitid	gwhRExMduYqoPQHI;

1.11
date	2014.03.14.08.18.01;	author dcoppa;	state Exp;
branches;
next	1.10;

1.10
date	2014.01.12.15.08.28;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.10.19.49.57;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.21.11;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.01.04.16.51.59;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.04.14.09.45.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.18.20.29.59;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.09.01.19.14.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.25.20.49.55;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.26.07.31.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.33.07;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  sfdriver.c                                                             */
/*                                                                         */
/*    High-level SFNT driver interface (body).                             */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_SFNT_H
#include FT_INTERNAL_OBJECTS_H

#include "sfdriver.h"
#include "ttload.h"
#include "sfobjs.h"
#include "sfntpic.h"

#include "sferrors.h"

#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
#include "ttsbit.h"
#endif

#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
#include "ttpost.h"
#endif

#ifdef TT_CONFIG_OPTION_BDF
#include "ttbdf.h"
#include FT_SERVICE_BDF_H
#endif

#include "ttcmap.h"
#include "ttkern.h"
#include "ttmtx.h"

#include FT_SERVICE_GLYPH_DICT_H
#include FT_SERVICE_POSTSCRIPT_NAME_H
#include FT_SERVICE_SFNT_H
#include FT_SERVICE_TT_CMAP_H


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_sfdriver


  /*
   *  SFNT TABLE SERVICE
   *
   */

  static void*
  get_sfnt_table( TT_Face      face,
                  FT_Sfnt_Tag  tag )
  {
    void*  table;


    switch ( tag )
    {
    case FT_SFNT_HEAD:
      table = &face->header;
      break;

    case FT_SFNT_HHEA:
      table = &face->horizontal;
      break;

    case FT_SFNT_VHEA:
      table = face->vertical_info ? &face->vertical : NULL;
      break;

    case FT_SFNT_OS2:
      table = ( face->os2.version == 0xFFFFU ) ? NULL : &face->os2;
      break;

    case FT_SFNT_POST:
      table = &face->postscript;
      break;

    case FT_SFNT_MAXP:
      table = &face->max_profile;
      break;

    case FT_SFNT_PCLT:
      table = face->pclt.Version ? &face->pclt : NULL;
      break;

    default:
      table = NULL;
    }

    return table;
  }


  static FT_Error
  sfnt_table_info( TT_Face    face,
                   FT_UInt    idx,
                   FT_ULong  *tag,
                   FT_ULong  *offset,
                   FT_ULong  *length )
  {
    if ( !offset || !length )
      return FT_THROW( Invalid_Argument );

    if ( !tag )
      *length = face->num_tables;
    else
    {
      if ( idx >= face->num_tables )
        return FT_THROW( Table_Missing );

      *tag    = face->dir_tables[idx].Tag;
      *offset = face->dir_tables[idx].Offset;
      *length = face->dir_tables[idx].Length;
    }

    return FT_Err_Ok;
  }


  FT_DEFINE_SERVICE_SFNT_TABLEREC(
    sfnt_service_sfnt_table,

    (FT_SFNT_TableLoadFunc)tt_face_load_any,     /* load_table */
    (FT_SFNT_TableGetFunc) get_sfnt_table,       /* get_table  */
    (FT_SFNT_TableInfoFunc)sfnt_table_info       /* table_info */
  )


#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES

  /*
   *  GLYPH DICT SERVICE
   *
   */

  static FT_Error
  sfnt_get_glyph_name( FT_Face     face,
                       FT_UInt     glyph_index,
                       FT_Pointer  buffer,
                       FT_UInt     buffer_max )
  {
    FT_String*  gname;
    FT_Error    error;


    error = tt_face_get_ps_name( (TT_Face)face, glyph_index, &gname );
    if ( !error )
      FT_STRCPYN( buffer, gname, buffer_max );

    return error;
  }


  static FT_UInt
  sfnt_get_name_index( FT_Face     face,
                       FT_String*  glyph_name )
  {
    TT_Face  ttface = (TT_Face)face;

    FT_UInt  i, max_gid = FT_UINT_MAX;


    if ( face->num_glyphs < 0 )
      return 0;
    else if ( (FT_ULong)face->num_glyphs < FT_UINT_MAX )
      max_gid = (FT_UInt)face->num_glyphs;
    else
      FT_TRACE0(( "Ignore glyph names for invalid GID 0x%08x - 0x%08x\n",
                  FT_UINT_MAX, face->num_glyphs ));

    for ( i = 0; i < max_gid; i++ )
    {
      FT_String*  gname;
      FT_Error    error = tt_face_get_ps_name( ttface, i, &gname );


      if ( error )
        continue;

      if ( !ft_strcmp( glyph_name, gname ) )
        return i;
    }

    return 0;
  }


  FT_DEFINE_SERVICE_GLYPHDICTREC(
    sfnt_service_glyph_dict,

    (FT_GlyphDict_GetNameFunc)  sfnt_get_glyph_name,    /* get_name   */
    (FT_GlyphDict_NameIndexFunc)sfnt_get_name_index     /* name_index */
  )

#endif /* TT_CONFIG_OPTION_POSTSCRIPT_NAMES */


  /*
   *  POSTSCRIPT NAME SERVICE
   *
   */

  static const char*
  sfnt_get_ps_name( TT_Face  face )
  {
    FT_Int       n, found_win, found_apple;
    const char*  result = NULL;


    /* shouldn't happen, but just in case to avoid memory leaks */
    if ( face->postscript_name )
      return face->postscript_name;

    /* scan the name table to see whether we have a Postscript name here, */
    /* either in Macintosh or Windows platform encodings                  */
    found_win   = -1;
    found_apple = -1;

    for ( n = 0; n < face->num_names; n++ )
    {
      TT_NameEntryRec*  name = face->name_table.names + n;


      if ( name->nameID == 6 && name->stringLength > 0 )
      {
        if ( name->platformID == 3     &&
             name->encodingID == 1     &&
             name->languageID == 0x409 )
          found_win = n;

        if ( name->platformID == 1 &&
             name->encodingID == 0 &&
             name->languageID == 0 )
          found_apple = n;
      }
    }

    if ( found_win != -1 )
    {
      FT_Memory         memory = face->root.memory;
      TT_NameEntryRec*  name   = face->name_table.names + found_win;
      FT_UInt           len    = name->stringLength / 2;
      FT_Error          error  = FT_Err_Ok;

      FT_UNUSED( error );


      if ( !FT_ALLOC( result, name->stringLength + 1 ) )
      {
        FT_Stream   stream = face->name_table.stream;
        FT_String*  r      = (FT_String*)result;
        FT_Char*    p;


        if ( FT_STREAM_SEEK( name->stringOffset ) ||
             FT_FRAME_ENTER( name->stringLength ) )
        {
          FT_FREE( result );
          name->stringLength = 0;
          name->stringOffset = 0;
          FT_FREE( name->string );

          goto Exit;
        }

        p = (FT_Char*)stream->cursor;

        for ( ; len > 0; len--, p += 2 )
        {
          if ( p[0] == 0 && p[1] >= 32 )
            *r++ = p[1];
        }
        *r = '\0';

        FT_FRAME_EXIT();
      }
      goto Exit;
    }

    if ( found_apple != -1 )
    {
      FT_Memory         memory = face->root.memory;
      TT_NameEntryRec*  name   = face->name_table.names + found_apple;
      FT_UInt           len    = name->stringLength;
      FT_Error          error  = FT_Err_Ok;

      FT_UNUSED( error );


      if ( !FT_ALLOC( result, len + 1 ) )
      {
        FT_Stream  stream = face->name_table.stream;


        if ( FT_STREAM_SEEK( name->stringOffset ) ||
             FT_STREAM_READ( result, len )        )
        {
          name->stringOffset = 0;
          name->stringLength = 0;
          FT_FREE( name->string );
          FT_FREE( result );
          goto Exit;
        }
        ((char*)result)[len] = '\0';
      }
    }

  Exit:
    face->postscript_name = result;
    return result;
  }


  FT_DEFINE_SERVICE_PSFONTNAMEREC(
    sfnt_service_ps_name,

    (FT_PsName_GetFunc)sfnt_get_ps_name       /* get_ps_font_name */
  )


  /*
   *  TT CMAP INFO
   */
  FT_DEFINE_SERVICE_TTCMAPSREC(
    tt_service_get_cmap_info,

    (TT_CMap_Info_GetFunc)tt_get_cmap_info    /* get_cmap_info */
  )


#ifdef TT_CONFIG_OPTION_BDF

  static FT_Error
  sfnt_get_charset_id( TT_Face       face,
                       const char*  *acharset_encoding,
                       const char*  *acharset_registry )
  {
    BDF_PropertyRec  encoding, registry;
    FT_Error         error;


    /* XXX: I don't know whether this is correct, since
     *      tt_face_find_bdf_prop only returns something correct if we have
     *      previously selected a size that is listed in the BDF table.
     *      Should we change the BDF table format to include single offsets
     *      for `CHARSET_REGISTRY' and `CHARSET_ENCODING'?
     */
    error = tt_face_find_bdf_prop( face, "CHARSET_REGISTRY", &registry );
    if ( !error )
    {
      error = tt_face_find_bdf_prop( face, "CHARSET_ENCODING", &encoding );
      if ( !error )
      {
        if ( registry.type == BDF_PROPERTY_TYPE_ATOM &&
             encoding.type == BDF_PROPERTY_TYPE_ATOM )
        {
          *acharset_encoding = encoding.u.atom;
          *acharset_registry = registry.u.atom;
        }
        else
          error = FT_THROW( Invalid_Argument );
      }
    }

    return error;
  }


  FT_DEFINE_SERVICE_BDFRec(
    sfnt_service_bdf,

    (FT_BDF_GetCharsetIdFunc)sfnt_get_charset_id,     /* get_charset_id */
    (FT_BDF_GetPropertyFunc) tt_face_find_bdf_prop    /* get_property   */
  )


#endif /* TT_CONFIG_OPTION_BDF */


  /*
   *  SERVICE LIST
   */

#if defined TT_CONFIG_OPTION_POSTSCRIPT_NAMES && defined TT_CONFIG_OPTION_BDF
  FT_DEFINE_SERVICEDESCREC5(
    sfnt_services,

    FT_SERVICE_ID_SFNT_TABLE,           &SFNT_SERVICE_SFNT_TABLE_GET,
    FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &SFNT_SERVICE_PS_NAME_GET,
    FT_SERVICE_ID_GLYPH_DICT,           &SFNT_SERVICE_GLYPH_DICT_GET,
    FT_SERVICE_ID_BDF,                  &SFNT_SERVICE_BDF_GET,
    FT_SERVICE_ID_TT_CMAP,              &TT_SERVICE_CMAP_INFO_GET )
#elif defined TT_CONFIG_OPTION_POSTSCRIPT_NAMES
  FT_DEFINE_SERVICEDESCREC4(
    sfnt_services,

    FT_SERVICE_ID_SFNT_TABLE,           &SFNT_SERVICE_SFNT_TABLE_GET,
    FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &SFNT_SERVICE_PS_NAME_GET,
    FT_SERVICE_ID_GLYPH_DICT,           &SFNT_SERVICE_GLYPH_DICT_GET,
    FT_SERVICE_ID_TT_CMAP,              &TT_SERVICE_CMAP_INFO_GET )
#elif defined TT_CONFIG_OPTION_BDF
  FT_DEFINE_SERVICEDESCREC4(
    sfnt_services,

    FT_SERVICE_ID_SFNT_TABLE,           &SFNT_SERVICE_SFNT_TABLE_GET,
    FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &SFNT_SERVICE_PS_NAME_GET,
    FT_SERVICE_ID_BDF,                  &SFNT_SERVICE_BDF_GET,
    FT_SERVICE_ID_TT_CMAP,              &TT_SERVICE_CMAP_INFO_GET )
#else
  FT_DEFINE_SERVICEDESCREC3(
    sfnt_services,

    FT_SERVICE_ID_SFNT_TABLE,           &SFNT_SERVICE_SFNT_TABLE_GET,
    FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &SFNT_SERVICE_PS_NAME_GET,
    FT_SERVICE_ID_TT_CMAP,              &TT_SERVICE_CMAP_INFO_GET )
#endif


  FT_CALLBACK_DEF( FT_Module_Interface )
  sfnt_get_interface( FT_Module    module,
                      const char*  module_interface )
  {
    /* SFNT_SERVICES_GET dereferences `library' in PIC mode */
#ifdef FT_CONFIG_OPTION_PIC
    FT_Library  library;


    if ( !module )
      return NULL;
    library = module->library;
    if ( !library )
      return NULL;
#else
    FT_UNUSED( module );
#endif

    return ft_service_list_lookup( SFNT_SERVICES_GET, module_interface );
  }


#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
#define PUT_EMBEDDED_BITMAPS( a )  a
#else
#define PUT_EMBEDDED_BITMAPS( a )  NULL
#endif

#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
#define PUT_PS_NAMES( a )  a
#else
#define PUT_PS_NAMES( a )  NULL
#endif

  FT_DEFINE_SFNT_INTERFACE(
    sfnt_interface,

    tt_face_goto_table,     /* TT_Loader_GotoTableFunc goto_table      */

    sfnt_init_face,         /* TT_Init_Face_Func       init_face       */
    sfnt_load_face,         /* TT_Load_Face_Func       load_face       */
    sfnt_done_face,         /* TT_Done_Face_Func       done_face       */
    sfnt_get_interface,     /* FT_Module_Requester     get_interface   */

    tt_face_load_any,       /* TT_Load_Any_Func        load_any        */

    tt_face_load_head,      /* TT_Load_Table_Func      load_head       */
    tt_face_load_hhea,      /* TT_Load_Metrics_Func    load_hhea       */
    tt_face_load_cmap,      /* TT_Load_Table_Func      load_cmap       */
    tt_face_load_maxp,      /* TT_Load_Table_Func      load_maxp       */
    tt_face_load_os2,       /* TT_Load_Table_Func      load_os2        */
    tt_face_load_post,      /* TT_Load_Table_Func      load_post       */

    tt_face_load_name,      /* TT_Load_Table_Func      load_name       */
    tt_face_free_name,      /* TT_Free_Table_Func      free_name       */

    tt_face_load_kern,      /* TT_Load_Table_Func      load_kern       */
    tt_face_load_gasp,      /* TT_Load_Table_Func      load_gasp       */
    tt_face_load_pclt,      /* TT_Load_Table_Func      load_init       */

    /* see `ttload.h' */
    PUT_EMBEDDED_BITMAPS( tt_face_load_bhed ),
                            /* TT_Load_Table_Func      load_bhed       */
    PUT_EMBEDDED_BITMAPS( tt_face_load_sbit_image ),
                            /* TT_Load_SBit_Image_Func load_sbit_image */

    /* see `ttpost.h' */
    PUT_PS_NAMES( tt_face_get_ps_name   ),
                            /* TT_Get_PS_Name_Func     get_psname      */
    PUT_PS_NAMES( tt_face_free_ps_names ),
                            /* TT_Free_Table_Func      free_psnames    */

    /* since version 2.1.8 */
    tt_face_get_kerning,    /* TT_Face_GetKerningFunc  get_kerning     */

    /* since version 2.2 */
    tt_face_load_font_dir,  /* TT_Load_Table_Func      load_font_dir   */
    tt_face_load_hmtx,      /* TT_Load_Metrics_Func    load_hmtx       */

    /* see `ttsbit.h' and `sfnt.h' */
    PUT_EMBEDDED_BITMAPS( tt_face_load_sbit ),
                            /* TT_Load_Table_Func      load_eblc       */
    PUT_EMBEDDED_BITMAPS( tt_face_free_sbit ),
                            /* TT_Free_Table_Func      free_eblc       */

    PUT_EMBEDDED_BITMAPS( tt_face_set_sbit_strike     ),
                            /* TT_Set_SBit_Strike_Func set_sbit_strike */
    PUT_EMBEDDED_BITMAPS( tt_face_load_strike_metrics ),
                    /* TT_Load_Strike_Metrics_Func load_strike_metrics */

    tt_face_get_metrics,    /* TT_Get_Metrics_Func     get_metrics     */

    tt_face_get_name        /* TT_Get_Name_Func        get_name        */
  )


  FT_DEFINE_MODULE(
    sfnt_module_class,

    0,  /* not a font driver or renderer */
    sizeof ( FT_ModuleRec ),

    "sfnt",     /* driver name                            */
    0x10000L,   /* driver version 1.0                     */
    0x20000L,   /* driver requires FreeType 2.0 or higher */

    (const void*)&SFNT_INTERFACE_GET,  /* module specific interface */

    (FT_Module_Constructor)NULL,               /* module_init   */
    (FT_Module_Destructor) NULL,               /* module_done   */
    (FT_Module_Requester)  sfnt_get_interface  /* get_interface */
  )


/* END */
@


1.18
log
@
Update to FreeType 2.7

Now Subpixel hinting, also known as ClearType hinting, is enabled
by default.

OK matthieu@@
@
text
@d91 1
a91 1
      table = face->os2.version == 0xFFFFU ? NULL : &face->os2;
d142 1
d145 2
a146 1
    (FT_SFNT_TableInfoFunc)sfnt_table_info )     /* table_info */
d157 1
a157 1
  sfnt_get_glyph_name( TT_Face     face,
d166 1
a166 1
    error = tt_face_get_ps_name( face, glyph_index, &gname );
d175 1
a175 1
  sfnt_get_name_index( TT_Face     face,
d178 1
a178 1
    FT_Face  root = &face->root;
d183 1
a183 1
    if ( root->num_glyphs < 0 )
d185 2
a186 2
    else if ( (FT_ULong)root->num_glyphs < FT_UINT_MAX )
      max_gid = (FT_UInt)root->num_glyphs;
d189 1
a189 1
                  FT_UINT_MAX, root->num_glyphs ));
d194 1
a194 1
      FT_Error    error = tt_face_get_ps_name( face, i, &gname );
d210 1
d212 2
a213 2
    (FT_GlyphDict_NameIndexFunc)sfnt_get_name_index )   /* name_index */

d336 3
a338 1
    (FT_PsName_GetFunc)sfnt_get_ps_name )     /* get_ps_font_name */
d346 3
a348 1
    (TT_CMap_Info_GetFunc)tt_get_cmap_info )  /* get_cmap_info */
d391 1
d393 2
a394 1
    (FT_BDF_GetPropertyFunc) tt_face_find_bdf_prop )  /* get_property   */
d407 1
d416 1
d424 1
d432 1
d475 1
d547 4
a550 3
    (FT_Module_Constructor)0,
    (FT_Module_Destructor) 0,
    (FT_Module_Requester)  sfnt_get_interface )
@


1.17
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d462 1
a462 1
    tt_face_goto_table,
d464 20
a483 20
    sfnt_init_face,
    sfnt_load_face,
    sfnt_done_face,
    sfnt_get_interface,

    tt_face_load_any,

    tt_face_load_head,
    tt_face_load_hhea,
    tt_face_load_cmap,
    tt_face_load_maxp,
    tt_face_load_os2,
    tt_face_load_post,

    tt_face_load_name,
    tt_face_free_name,

    tt_face_load_kern,
    tt_face_load_gasp,
    tt_face_load_pclt,
d487 1
a487 1

d489 1
d493 1
d495 1
d498 1
a498 1
    tt_face_get_kerning,
d501 2
a502 2
    tt_face_load_font_dir,
    tt_face_load_hmtx,
d506 1
d508 1
d511 1
d513 1
d515 1
a515 1
    tt_face_get_metrics,
d517 1
a517 1
    tt_face_get_name
@


1.16
log
@
Bugfixing update to freetype-2.6.2

Tested on amd64, i386, macppc, sparc64, loongson and compile-tested
on arm by matthieu@@
Also tested in a ports bulk build by naddy@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2015 by                                                 */
@


1.15
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@d142 3
a144 3
    (FT_SFNT_TableLoadFunc)tt_face_load_any,
    (FT_SFNT_TableGetFunc) get_sfnt_table,
    (FT_SFNT_TableInfoFunc)sfnt_table_info )
d208 2
a209 2
    (FT_GlyphDict_GetNameFunc)  sfnt_get_glyph_name,
    (FT_GlyphDict_NameIndexFunc)sfnt_get_name_index )
d333 1
a333 1
    (FT_PsName_GetFunc)sfnt_get_ps_name )
d341 1
a341 1
    (TT_CMap_Info_GetFunc)tt_get_cmap_info )
d384 2
a385 2
    (FT_BDF_GetCharsetIdFunc)sfnt_get_charset_id,
    (FT_BDF_GetPropertyFunc) tt_face_find_bdf_prop )
@


1.14
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d508 3
a510 1
    tt_face_get_metrics
@


1.13
log
@
Bugfixing update to freetype-2.5.5

ok matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2007, 2009-2014 by                                      */
d269 1
a269 1
        FT_Byte*    p;
d283 1
a283 1
        p = (FT_Byte*)stream->cursor;
d287 1
a287 1
          if ( p[0] == 0 && p[1] >= 32 && p[1] < 128 )
@


1.12
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d430 1
a430 1
    /* SFNT_SERVICES_GET derefers `library' in PIC mode */
@


1.11
log
@
Security/bugfixing update to freetype-2.5.3, featuring a fix for a
vulnerability in the CFF driver (CVE-2014-2240) and assorted minor
fixes.

ok matthieu@@
@
text
@d78 1
a78 1
    case ft_sfnt_head:
d82 1
a82 1
    case ft_sfnt_hhea:
d86 2
a87 2
    case ft_sfnt_vhea:
      table = face->vertical_info ? &face->vertical : 0;
d90 2
a91 2
    case ft_sfnt_os2:
      table = face->os2.version == 0xFFFFU ? 0 : &face->os2;
d94 1
a94 1
    case ft_sfnt_post:
d98 1
a98 1
    case ft_sfnt_maxp:
d102 2
a103 2
    case ft_sfnt_pclt:
      table = face->pclt.Version ? &face->pclt : 0;
d107 1
a107 1
      table = 0;
@


1.10
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d7 1
a7 1
/*  Copyright 1996-2007, 2009-2013 by                                      */
d269 1
a269 1
        FT_Byte*    p      = (FT_Byte*)name->string;
@


1.9
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@d502 2
a503 2
    PUT_EMBEDDED_BITMAPS( tt_face_load_eblc ),
    PUT_EMBEDDED_BITMAPS( tt_face_free_eblc ),
@


1.8
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@a447 128
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS

  FT_CALLBACK_DEF( FT_Error )
  tt_face_load_sfnt_header_stub( TT_Face      face,
                                 FT_Stream    stream,
                                 FT_Long      face_index,
                                 SFNT_Header  header )
  {
    FT_UNUSED( face );
    FT_UNUSED( stream );
    FT_UNUSED( face_index );
    FT_UNUSED( header );

    return FT_THROW( Unimplemented_Feature );
  }


  FT_CALLBACK_DEF( FT_Error )
  tt_face_load_directory_stub( TT_Face      face,
                               FT_Stream    stream,
                               SFNT_Header  header )
  {
    FT_UNUSED( face );
    FT_UNUSED( stream );
    FT_UNUSED( header );

    return FT_THROW( Unimplemented_Feature );
  }


  FT_CALLBACK_DEF( FT_Error )
  tt_face_load_hdmx_stub( TT_Face    face,
                          FT_Stream  stream )
  {
    FT_UNUSED( face );
    FT_UNUSED( stream );

    return FT_THROW( Unimplemented_Feature );
  }


  FT_CALLBACK_DEF( void )
  tt_face_free_hdmx_stub( TT_Face  face )
  {
    FT_UNUSED( face );
  }


  FT_CALLBACK_DEF( FT_Error )
  tt_face_set_sbit_strike_stub( TT_Face    face,
                                FT_UInt    x_ppem,
                                FT_UInt    y_ppem,
                                FT_ULong*  astrike_index )
  {
    /*
     * We simply forge a FT_Size_Request and call the real function
     * that does all the work.
     *
     * This stub might be called by libXfont in the X.Org Xserver,
     * compiled against version 2.1.8 or newer.
     */

    FT_Size_RequestRec  req;


    req.type           = FT_SIZE_REQUEST_TYPE_NOMINAL;
    req.width          = (FT_F26Dot6)x_ppem;
    req.height         = (FT_F26Dot6)y_ppem;
    req.horiResolution = 0;
    req.vertResolution = 0;

    *astrike_index = 0x7FFFFFFFUL;

    return tt_face_set_sbit_strike( face, &req, astrike_index );
  }


  FT_CALLBACK_DEF( FT_Error )
  tt_face_load_sbit_stub( TT_Face    face,
                          FT_Stream  stream )
  {
    FT_UNUSED( face );
    FT_UNUSED( stream );

    /*
     *  This function was originally implemented to load the sbit table.
     *  However, it has been replaced by `tt_face_load_eblc', and this stub
     *  is only there for some rogue clients which would want to call it
     *  directly (which doesn't make much sense).
     */
    return FT_THROW( Unimplemented_Feature );
  }


  FT_CALLBACK_DEF( void )
  tt_face_free_sbit_stub( TT_Face  face )
  {
    /* nothing to do in this stub */
    FT_UNUSED( face );
  }


  FT_CALLBACK_DEF( FT_Error )
  tt_face_load_charmap_stub( TT_Face    face,
                             void*      cmap,
                             FT_Stream  input )
  {
    FT_UNUSED( face );
    FT_UNUSED( cmap );
    FT_UNUSED( input );

    return FT_THROW( Unimplemented_Feature );
  }


  FT_CALLBACK_DEF( FT_Error )
  tt_face_free_charmap_stub( TT_Face  face,
                             void*    cmap )
  {
    FT_UNUSED( face );
    FT_UNUSED( cmap );

    return FT_Err_Ok;
  }

#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */


a470 3
    tt_face_load_sfnt_header_stub, /* FT_CONFIG_OPTION_OLD_INTERNALS */
    tt_face_load_directory_stub,   /* FT_CONFIG_OPTION_OLD_INTERNALS */

a480 3
    tt_face_load_hdmx_stub, /* FT_CONFIG_OPTION_OLD_INTERNALS */
    tt_face_free_hdmx_stub, /* FT_CONFIG_OPTION_OLD_INTERNALS */

a487 6
    tt_face_set_sbit_strike_stub, /* FT_CONFIG_OPTION_OLD_INTERNALS */
    tt_face_load_sbit_stub,       /* FT_CONFIG_OPTION_OLD_INTERNALS */

    tt_find_sbit_image,   /* FT_CONFIG_OPTION_OLD_INTERNALS */
    tt_load_sbit_metrics, /* FT_CONFIG_OPTION_OLD_INTERNALS */

a489 2
    tt_face_free_sbit_stub, /* FT_CONFIG_OPTION_OLD_INTERNALS */

a493 3
    tt_face_load_charmap_stub, /* FT_CONFIG_OPTION_OLD_INTERNALS */
    tt_face_free_charmap_stub, /* FT_CONFIG_OPTION_OLD_INTERNALS */

a494 1

a497 1

@


1.7
log
@Update to freetype 2.4.11. Tested by krw@@, jasper@@ and on a bulk ports
build by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2007, 2009-2012 by                                      */
d122 1
a122 1
      return SFNT_Err_Invalid_Argument;
d129 1
a129 1
        return SFNT_Err_Table_Missing;
d136 1
a136 1
    return SFNT_Err_Ok;
d260 1
a260 1
      FT_Error          error  = SFNT_Err_Ok;
d302 1
a302 1
      FT_Error          error  = SFNT_Err_Ok;
d374 1
a374 1
          error = SFNT_Err_Invalid_Argument;
d461 1
a461 1
    return SFNT_Err_Unimplemented_Feature;
d474 1
a474 1
    return SFNT_Err_Unimplemented_Feature;
d485 1
a485 1
    return SFNT_Err_Unimplemented_Feature;
d538 1
a538 1
    return SFNT_Err_Unimplemented_Feature;
d559 1
a559 1
    return SFNT_Err_Unimplemented_Feature;
d570 1
a570 1
    return SFNT_Err_Ok;
@


1.6
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@d7 1
a7 1
/*  Copyright 1996-2007, 2009-2011 by                                      */
d53 1
d64 4
a67 4
 /*
  *  SFNT TABLE SERVICE
  *
  */
d140 2
a141 1
  FT_DEFINE_SERVICE_SFNT_TABLEREC(sfnt_service_sfnt_table,
d144 1
a144 2
    (FT_SFNT_TableInfoFunc)sfnt_table_info
  )
d149 4
a152 4
 /*
  *  GLYPH DICT SERVICE
  *
  */
d176 3
a178 2
    FT_Face   root = &face->root;
    FT_UInt   i, max_gid = FT_UINT_MAX;
d183 2
a184 2
    else if ( ( FT_ULong ) root->num_glyphs < FT_UINT_MAX )
      max_gid = ( FT_UInt ) root->num_glyphs;
d187 1
a187 1
         FT_UINT_MAX, root->num_glyphs ));
d206 2
a207 1
  FT_DEFINE_SERVICE_GLYPHDICTREC(sfnt_service_glyph_dict,
d209 2
a210 2
    (FT_GlyphDict_NameIndexFunc)sfnt_get_name_index
  )
d215 4
a218 4
 /*
  *  POSTSCRIPT NAME SERVICE
  *
  */
d330 4
a333 3
  FT_DEFINE_SERVICE_PSFONTNAMEREC(sfnt_service_ps_name,
    (FT_PsName_GetFunc)sfnt_get_ps_name
  )
d339 3
a341 3
  FT_DEFINE_SERVICE_TTCMAPSREC(tt_service_get_cmap_info,
    (TT_CMap_Info_GetFunc)tt_get_cmap_info
  )
d382 5
a386 4
  FT_DEFINE_SERVICE_BDFRec(sfnt_service_bdf,
    (FT_BDF_GetCharsetIdFunc) sfnt_get_charset_id,
    (FT_BDF_GetPropertyFunc)  tt_face_find_bdf_prop
  )
d396 7
a402 7
  FT_DEFINE_SERVICEDESCREC5(sfnt_services,
    FT_SERVICE_ID_SFNT_TABLE,           &FT_SFNT_SERVICE_SFNT_TABLE_GET,
    FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &FT_SFNT_SERVICE_PS_NAME_GET,
    FT_SERVICE_ID_GLYPH_DICT,           &FT_SFNT_SERVICE_GLYPH_DICT_GET,
    FT_SERVICE_ID_BDF,                  &FT_SFNT_SERVICE_BDF_GET,
    FT_SERVICE_ID_TT_CMAP,              &FT_TT_SERVICE_GET_CMAP_INFO_GET
  )
d404 6
a409 6
  FT_DEFINE_SERVICEDESCREC4(sfnt_services,
    FT_SERVICE_ID_SFNT_TABLE,           &FT_SFNT_SERVICE_SFNT_TABLE_GET,
    FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &FT_SFNT_SERVICE_PS_NAME_GET,
    FT_SERVICE_ID_GLYPH_DICT,           &FT_SFNT_SERVICE_GLYPH_DICT_GET,
    FT_SERVICE_ID_TT_CMAP,              &FT_TT_SERVICE_GET_CMAP_INFO_GET
  )
d411 6
a416 6
  FT_DEFINE_SERVICEDESCREC4(sfnt_services,
    FT_SERVICE_ID_SFNT_TABLE,           &FT_SFNT_SERVICE_SFNT_TABLE_GET,
    FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &FT_SFNT_SERVICE_PS_NAME_GET,
    FT_SERVICE_ID_BDF,                  &FT_SFNT_SERVICE_BDF_GET,
    FT_SERVICE_ID_TT_CMAP,              &FT_TT_SERVICE_GET_CMAP_INFO_GET
  )
d418 5
a422 5
  FT_DEFINE_SERVICEDESCREC3(sfnt_services,
    FT_SERVICE_ID_SFNT_TABLE,           &FT_SFNT_SERVICE_SFNT_TABLE_GET,
    FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &FT_SFNT_SERVICE_PS_NAME_GET,
    FT_SERVICE_ID_TT_CMAP,              &FT_TT_SERVICE_GET_CMAP_INFO_GET
  )
d430 1
a430 1
    /* FT_SFNT_SERVICES_GET derefers `library' in PIC mode */
d443 2
a444 1
    return ft_service_list_lookup( FT_SFNT_SERVICES_GET, module_interface );
d575 1
d577 1
a577 1
#define PUT_EMBEDDED_BITMAPS(a) a
d579 1
a579 1
#define PUT_EMBEDDED_BITMAPS(a) 0
d581 1
d583 1
a583 1
#define PUT_PS_NAMES(a) a
d585 1
a585 1
#define PUT_PS_NAMES(a) 0
d588 2
a589 1
  FT_DEFINE_SFNT_INTERFACE(sfnt_interface,
d600 1
a600 1
    tt_face_load_directory_stub, /* FT_CONFIG_OPTION_OLD_INTERNALS */
d620 1
a620 1
    PUT_EMBEDDED_BITMAPS(tt_face_load_bhed),
d623 1
a623 1
    tt_face_load_sbit_stub, /* FT_CONFIG_OPTION_OLD_INTERNALS */
d625 1
a625 1
    tt_find_sbit_image, /* FT_CONFIG_OPTION_OLD_INTERNALS */
d628 1
a628 1
    PUT_EMBEDDED_BITMAPS(tt_face_load_sbit_image),
d633 2
a634 2
    PUT_PS_NAMES(tt_face_get_ps_name),
    PUT_PS_NAMES(tt_face_free_ps_names),
d649 2
a650 2
    PUT_EMBEDDED_BITMAPS(tt_face_load_eblc),
    PUT_EMBEDDED_BITMAPS(tt_face_free_eblc),
d652 2
a653 2
    PUT_EMBEDDED_BITMAPS(tt_face_set_sbit_strike),
    PUT_EMBEDDED_BITMAPS(tt_face_load_strike_metrics),
d659 2
a660 1
  FT_DEFINE_MODULE(sfnt_module_class,
d669 1
a669 1
    (const void*)&FT_SFNT_INTERFACE_GET,  /* module specific interface */
d673 1
a673 2
    (FT_Module_Requester)  sfnt_get_interface
  )
@


1.5
log
@Update to freetype 2.4.5. Tested by many.
@
text
@d425 11
d437 1
a437 1

d570 1
a570 1
#define PUT_EMBEDDED_BITMAPS(a) a 
d572 1
a572 1
#define PUT_EMBEDDED_BITMAPS(a) 0 
d575 1
a575 1
#define PUT_PS_NAMES(a) a 
d577 1
a577 1
#define PUT_PS_NAMES(a) 0 
d651 1
a651 1
  
d653 1
a653 1
    sizeof( FT_ModuleRec ),
@


1.4
log
@Update to freetype 2.4.2. This has been in snapshots for a while
and tested explicitely by ajacoutot@@ jasper@@, jcs@@, krw@@ and others
on various architectures.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010 by */
d120 1
a120 1
    if ( !tag || !offset || !length )
d123 6
a128 2
    if ( idx >= face->num_tables )
      return SFNT_Err_Table_Missing;
d130 4
a133 3
    *tag    = face->dir_tables[idx].Tag;
    *offset = face->dir_tables[idx].Offset;
    *length = face->dir_tables[idx].Length;
@


1.3
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009 by       */
d365 1
a365 1
          error = FT_Err_Invalid_Argument;
d439 1
a439 1
    return FT_Err_Unimplemented_Feature;
d452 1
a452 1
    return FT_Err_Unimplemented_Feature;
d463 1
a463 1
    return FT_Err_Unimplemented_Feature;
d516 1
a516 1
    return FT_Err_Unimplemented_Feature;
d537 1
a537 1
    return FT_Err_Unimplemented_Feature;
d548 1
a548 1
    return 0;
@


1.2
log
@Update to Freetype 2.3.9.

Bump major to be safe.
Small arm assembler fix in ftconfig.h by drahn@@
@
text
@d20 1
d27 1
d53 9
d117 1
d120 1
a120 1
    if ( !tag || !length )
d127 1
d134 1
a134 2
  static const FT_Service_SFNT_TableRec  sfnt_service_sfnt_table =
  {
d138 1
a138 1
  };
d170 3
a172 2
    FT_Face  root = &face->root;
    FT_Long  i;
d174 7
d182 1
a182 1
    for ( i = 0; i < root->num_glyphs; i++ )
d192 1
a192 1
        return (FT_UInt)i;
d199 1
a199 2
  static const FT_Service_GlyphDictRec  sfnt_service_glyph_dict =
  {
d202 1
a202 1
  };
d322 1
a322 2
  static const FT_Service_PsFontNameRec  sfnt_service_ps_name =
  {
d324 1
a324 1
  };
d330 1
a330 2
  static const FT_Service_TTCMapsRec  tt_service_get_cmap_info =
  {
d332 1
a332 1
  };
d373 1
a373 2
  static const FT_Service_BDFRec  sfnt_service_bdf =
  {
d375 2
a376 2
    (FT_BDF_GetPropertyFunc)  tt_face_find_bdf_prop,
  };
d385 28
a412 9
  static const FT_ServiceDescRec  sfnt_services[] =
  {
    { FT_SERVICE_ID_SFNT_TABLE,           &sfnt_service_sfnt_table },
    { FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &sfnt_service_ps_name },
#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
    { FT_SERVICE_ID_GLYPH_DICT,           &sfnt_service_glyph_dict },
#endif
#ifdef TT_CONFIG_OPTION_BDF
    { FT_SERVICE_ID_BDF,                  &sfnt_service_bdf },
a413 4
    { FT_SERVICE_ID_TT_CMAP,              &tt_service_get_cmap_info },

    { NULL, NULL }
  };
d422 1
a422 1
    return ft_service_list_lookup( sfnt_services, module_interface );
d553 10
d564 1
a564 3
  static
  const SFNT_Interface  sfnt_interface =
  {
d574 2
a575 4
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
    tt_face_load_sfnt_header_stub,
    tt_face_load_directory_stub,
#endif
d587 2
a588 4
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
    tt_face_load_hdmx_stub,
    tt_face_free_hdmx_stub,
#endif
a593 1
#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
d595 1
a595 4
    tt_face_load_bhed,
#else
    0,
#endif
d597 2
a598 3
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
    tt_face_set_sbit_strike_stub,
    tt_face_load_sbit_stub,
d600 2
a601 3
    tt_find_sbit_image,
    tt_load_sbit_metrics,
#endif
d603 1
a603 5
#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
    tt_face_load_sbit_image,
#else
    0,
#endif
d605 1
a605 3
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
    tt_face_free_sbit_stub,
#endif
a606 1
#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
d608 2
a609 6
    tt_face_get_ps_name,
    tt_face_free_ps_names,
#else
    0,
    0,
#endif
d611 2
a612 4
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
    tt_face_load_charmap_stub,
    tt_face_free_charmap_stub,
#endif
a622 1
#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
d624 2
a625 2
    tt_face_load_eblc,
    tt_face_free_eblc,
d627 2
a628 8
    tt_face_set_sbit_strike,
    tt_face_load_strike_metrics,
#else
    0,
    0,
    0,
    0,
#endif
d631 1
a631 1
  };
d634 2
a635 3
  FT_CALLBACK_TABLE_DEF
  const FT_Module_Class  sfnt_module_class =
  {
d643 1
a643 1
    (const void*)&sfnt_interface,  /* module specific interface */
d648 1
a648 1
  };
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d147 16
a162 1
    if ( !error && buffer_max > 0 )
d164 2
a165 1
      FT_UInt  len = (FT_UInt)( ft_strlen( gname ) );
d168 2
a169 2
      if ( len >= buffer_max )
        len = buffer_max - 1;
d171 2
a172 2
      FT_MEM_COPY( buffer, gname, len );
      ((FT_Byte*)buffer)[len] = 0;
d175 1
a175 1
    return error;
d182 1
a182 1
    (FT_GlyphDict_NameIndexFunc)NULL
d431 1
a431 1
    
d433 1
a433 1
  }                          
d468 2
a469 2
    return tt_face_set_sbit_strike( face, &req, astrike_index );    
  }                                
d478 1
a478 1
    
d480 1
a480 1
     *  This function was originally implemented to load the sbit table. 
d486 1
a486 1
  }                          
d495 2
a496 2
  
  
d505 1
a505 1
    
d507 1
a507 1
  }                             
d516 1
a516 1
    
d518 2
a519 2
  }                             
  
d619 1
a619 1
#endif    
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d147 11
a157 2
    if ( !error )
      FT_STRCPYN( buffer, gname, buffer_max );
d415 1
a415 1

d417 1
a417 1
  }
d452 2
a453 2
    return tt_face_set_sbit_strike( face, &req, astrike_index );
  }
d462 1
a462 1

d464 1
a464 1
     *  This function was originally implemented to load the sbit table.
d470 1
a470 1
  }
d479 2
a480 2


d489 1
a489 1

d491 1
a491 1
  }
d500 1
a500 1

d502 2
a503 2
  }

d603 1
a603 1
#endif
@

