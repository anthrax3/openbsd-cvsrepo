head	1.14;
access;
symbols
	OPENBSD_6_1:1.13.0.2
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.2
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2017.06.23.16.15.19;	author dcoppa;	state Exp;
branches;
next	1.13;
commitid	nHj0O50aY5QcUcQ4;

1.13
date	2017.01.13.11.20.00;	author dcoppa;	state Exp;
branches;
next	1.12;
commitid	ESXG9TuEmwmBXggf;

1.12
date	2016.05.29.11.57.14;	author dcoppa;	state Exp;
branches;
next	1.11;
commitid	1dOLexdOAzW2mQjp;

1.11
date	2015.06.28.08.27.50;	author dcoppa;	state Exp;
branches;
next	1.10;
commitid	qXwIGV2h9uFjxAmt;

1.10
date	2014.12.26.17.52.35;	author dcoppa;	state Exp;
branches;
next	1.9;
commitid	gwhRExMduYqoPQHI;

1.9
date	2014.01.12.15.08.28;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.10.19.49.57;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.21.11;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.07.07.16.45.04;	author dcoppa;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.18.20.29.59;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.03.25.20.49.55;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.10.20.28.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.33.05;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@
Update to freetype-2.8

No fallout in a bulk build on i386 (sthen@@)

OK matthieu@@, sthen@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ttmtx.c                                                                */
/*                                                                         */
/*    Load the metrics tables common to TTF and OTF fonts (body).          */
/*                                                                         */
/*  Copyright 2006-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_STREAM_H
#include FT_TRUETYPE_TAGS_H

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#include FT_SERVICE_METRICS_VARIATIONS_H
#endif

#include "ttmtx.h"

#include "sferrors.h"


  /* IMPORTANT: The TT_HoriHeader and TT_VertHeader structures should   */
  /*            be identical except for the names of their fields,      */
  /*            which are different.                                    */
  /*                                                                    */
  /*            This ensures that `tt_face_load_hmtx' is able to read   */
  /*            both the horizontal and vertical headers.               */


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_ttmtx


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_face_load_hmtx                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Load the `hmtx' or `vmtx' table into a face object.                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face     :: A handle to the target face object.                    */
  /*                                                                       */
  /*    stream   :: The input stream.                                      */
  /*                                                                       */
  /*    vertical :: A boolean flag.  If set, load `vmtx'.                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_hmtx( TT_Face    face,
                     FT_Stream  stream,
                     FT_Bool    vertical )
  {
    FT_Error   error;
    FT_ULong   tag, table_size;
    FT_ULong*  ptable_offset;
    FT_ULong*  ptable_size;


    if ( vertical )
    {
      tag           = TTAG_vmtx;
      ptable_offset = &face->vert_metrics_offset;
      ptable_size   = &face->vert_metrics_size;
    }
    else
    {
      tag           = TTAG_hmtx;
      ptable_offset = &face->horz_metrics_offset;
      ptable_size   = &face->horz_metrics_size;
    }

    error = face->goto_table( face, tag, stream, &table_size );
    if ( error )
      goto Fail;

    *ptable_size   = table_size;
    *ptable_offset = FT_STREAM_POS();

  Fail:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_face_load_hhea                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Load the `hhea' or 'vhea' table into a face object.                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face     :: A handle to the target face object.                    */
  /*                                                                       */
  /*    stream   :: The input stream.                                      */
  /*                                                                       */
  /*    vertical :: A boolean flag.  If set, load `vhea'.                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_hhea( TT_Face    face,
                     FT_Stream  stream,
                     FT_Bool    vertical )
  {
    FT_Error        error;
    TT_HoriHeader*  header;

    static const FT_Frame_Field  metrics_header_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_HoriHeader

      FT_FRAME_START( 36 ),
        FT_FRAME_ULONG ( Version ),
        FT_FRAME_SHORT ( Ascender ),
        FT_FRAME_SHORT ( Descender ),
        FT_FRAME_SHORT ( Line_Gap ),
        FT_FRAME_USHORT( advance_Width_Max ),
        FT_FRAME_SHORT ( min_Left_Side_Bearing ),
        FT_FRAME_SHORT ( min_Right_Side_Bearing ),
        FT_FRAME_SHORT ( xMax_Extent ),
        FT_FRAME_SHORT ( caret_Slope_Rise ),
        FT_FRAME_SHORT ( caret_Slope_Run ),
        FT_FRAME_SHORT ( caret_Offset ),
        FT_FRAME_SHORT ( Reserved[0] ),
        FT_FRAME_SHORT ( Reserved[1] ),
        FT_FRAME_SHORT ( Reserved[2] ),
        FT_FRAME_SHORT ( Reserved[3] ),
        FT_FRAME_SHORT ( metric_Data_Format ),
        FT_FRAME_USHORT( number_Of_HMetrics ),
      FT_FRAME_END
    };


    if ( vertical )
    {
      void  *v = &face->vertical;


      error = face->goto_table( face, TTAG_vhea, stream, 0 );
      if ( error )
        goto Fail;

      header = (TT_HoriHeader*)v;
    }
    else
    {
      error = face->goto_table( face, TTAG_hhea, stream, 0 );
      if ( error )
        goto Fail;

      header = &face->horizontal;
    }

    if ( FT_STREAM_READ_FIELDS( metrics_header_fields, header ) )
      goto Fail;

    FT_TRACE3(( "Ascender:          %5d\n", header->Ascender ));
    FT_TRACE3(( "Descender:         %5d\n", header->Descender ));
    FT_TRACE3(( "number_Of_Metrics: %5u\n", header->number_Of_HMetrics ));

    header->long_metrics  = NULL;
    header->short_metrics = NULL;

  Fail:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_face_get_metrics                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the horizontal or vertical metrics in font units for a      */
  /*    given glyph.  The values are the left side bearing (top side       */
  /*    bearing for vertical metrics) and advance width (advance height    */
  /*    for vertical metrics).                                             */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face     :: A pointer to the TrueType face structure.              */
  /*                                                                       */
  /*    vertical :: If set to TRUE, get vertical metrics.                  */
  /*                                                                       */
  /*    gindex   :: The glyph index.                                       */
  /*                                                                       */
  /* <Output>                                                              */
  /*    abearing :: The bearing, either left side or top side.             */
  /*                                                                       */
  /*    aadvance :: The advance width or advance height, depending on      */
  /*                the `vertical' flag.                                   */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  tt_face_get_metrics( TT_Face     face,
                       FT_Bool     vertical,
                       FT_UInt     gindex,
                       FT_Short   *abearing,
                       FT_UShort  *aadvance )
  {
    FT_Error        error;
    FT_Stream       stream = face->root.stream;
    TT_HoriHeader*  header;
    FT_ULong        table_pos, table_size, table_end;
    FT_UShort       k;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    FT_Service_MetricsVariations  var =
      (FT_Service_MetricsVariations)face->var;
#endif


    if ( vertical )
    {
      void*  v = &face->vertical;


      header     = (TT_HoriHeader*)v;
      table_pos  = face->vert_metrics_offset;
      table_size = face->vert_metrics_size;
    }
    else
    {
      header     = &face->horizontal;
      table_pos  = face->horz_metrics_offset;
      table_size = face->horz_metrics_size;
    }

    table_end = table_pos + table_size;

    k = header->number_Of_HMetrics;

    if ( k > 0 )
    {
      if ( gindex < (FT_UInt)k )
      {
        table_pos += 4 * gindex;
        if ( table_pos + 4 > table_end )
          goto NoData;

        if ( FT_STREAM_SEEK( table_pos ) ||
             FT_READ_USHORT( *aadvance ) ||
             FT_READ_SHORT( *abearing )  )
          goto NoData;
      }
      else
      {
        table_pos += 4 * ( k - 1 );
        if ( table_pos + 4 > table_end )
          goto NoData;

        if ( FT_STREAM_SEEK( table_pos ) ||
             FT_READ_USHORT( *aadvance ) )
          goto NoData;

        table_pos += 4 + 2 * ( gindex - k );
        if ( table_pos + 2 > table_end )
          *abearing = 0;
        else
        {
          if ( !FT_STREAM_SEEK( table_pos ) )
            (void)FT_READ_SHORT( *abearing );
        }
      }
    }
    else
    {
    NoData:
      *abearing = 0;
      *aadvance = 0;
    }

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    if ( var )
    {
      FT_Face  f = FT_FACE( face );
      FT_Int   a = (FT_Int)*aadvance;
      FT_Int   b = (FT_Int)*abearing;


      if ( vertical )
      {
        if ( var->vadvance_adjust )
          var->vadvance_adjust( f, gindex, &a );
        if ( var->tsb_adjust )
          var->tsb_adjust( f, gindex, &b );
      }
      else
      {
        if ( var->hadvance_adjust )
          var->hadvance_adjust( f, gindex, &a );
        if ( var->lsb_adjust )
          var->lsb_adjust( f, gindex, &b );
      }

      *aadvance = (FT_UShort)a;
      *abearing = (FT_Short)b;
    }
#endif
  }


/* END */
@


1.13
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2006-2016 by                                                 */
d31 8
@


1.12
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d23 5
d222 5
d287 28
@


1.11
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2006-2015 by                                                 */
@


1.10
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2006-2009, 2011-2014 by                                      */
@


1.9
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d7 1
a7 1
/*  Copyright 2006-2009, 2011-2013 by                                      */
d204 1
a204 1
  FT_LOCAL_DEF( FT_Error )
a276 2

    return FT_Err_Ok;
@


1.8
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@d186 4
a189 3
  /*    Returns the horizontal or vertical metrics in font units for a     */
  /*    given glyph.  The metrics are the left side bearing (resp. top     */
  /*    side bearing) and advance width (resp. advance height).            */
d192 1
a192 2
  /*    header  :: A pointer to either the horizontal or vertical metrics  */
  /*               structure.                                              */
d194 3
a196 1
  /*    idx     :: The glyph index.                                        */
d199 1
a199 1
  /*    bearing :: The bearing, either left side or top side.              */
d201 2
a202 1
  /*    advance :: The advance width resp. advance height.                 */
@


1.7
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@a37 7
  /*
   *  Unfortunately, we can't enable our memory optimizations if
   *  FT_CONFIG_OPTION_OLD_INTERNALS is defined.  This is because at least
   *  one rogue client (libXfont in the X.Org XServer) is directly accessing
   *  the metrics.
   */

a55 2
#ifndef FT_CONFIG_OPTION_OLD_INTERNALS

a90 136
#else /* !FT_CONFIG_OPTION_OLD_INTERNALS */

  FT_LOCAL_DEF( FT_Error )
  tt_face_load_hmtx( TT_Face    face,
                     FT_Stream  stream,
                     FT_Bool    vertical )
  {
    FT_Error   error;
    FT_Memory  memory = stream->memory;

    FT_ULong   table_len;
    FT_Long    num_shorts, num_longs, num_shorts_checked;

    TT_LongMetrics*    longs;
    TT_ShortMetrics**  shorts;
    FT_Byte*           p;


    if ( vertical )
    {
      void*   lm = &face->vertical.long_metrics;
      void**  sm = &face->vertical.short_metrics;


      error = face->goto_table( face, TTAG_vmtx, stream, &table_len );
      if ( error )
        goto Fail;

      num_longs = face->vertical.number_Of_VMetrics;
      if ( (FT_ULong)num_longs > table_len / 4 )
        num_longs = (FT_Long)( table_len / 4 );

      face->vertical.number_Of_VMetrics = 0;

      longs  = (TT_LongMetrics*)lm;
      shorts = (TT_ShortMetrics**)sm;
    }
    else
    {
      void*   lm = &face->horizontal.long_metrics;
      void**  sm = &face->horizontal.short_metrics;


      error = face->goto_table( face, TTAG_hmtx, stream, &table_len );
      if ( error )
        goto Fail;

      num_longs = face->horizontal.number_Of_HMetrics;
      if ( (FT_ULong)num_longs > table_len / 4 )
        num_longs = (FT_Long)( table_len / 4 );

      face->horizontal.number_Of_HMetrics = 0;

      longs  = (TT_LongMetrics*)lm;
      shorts = (TT_ShortMetrics**)sm;
    }

    /* never trust derived values */

    num_shorts         = face->max_profile.numGlyphs - num_longs;
    num_shorts_checked = ( table_len - num_longs * 4L ) / 2;

    if ( num_shorts < 0 )
    {
      FT_TRACE0(( "tt_face_load_hmtx:"
                  " %cmtx has more metrics than glyphs.\n",
                  vertical ? 'v' : 'h' ));

      /* Adobe simply ignores this problem.  So we shall do the same. */
#if 0
      error = vertical ? FT_THROW( Invalid_Vert_Metrics )
                       : FT_THROW( Invalid_Horiz_Metrics );
      goto Exit;
#else
      num_shorts = 0;
#endif
    }

    if ( FT_QNEW_ARRAY( *longs,  num_longs  ) ||
         FT_QNEW_ARRAY( *shorts, num_shorts ) )
      goto Fail;

    if ( FT_FRAME_ENTER( table_len ) )
      goto Fail;

    p = stream->cursor;

    {
      TT_LongMetrics  cur   = *longs;
      TT_LongMetrics  limit = cur + num_longs;


      for ( ; cur < limit; cur++ )
      {
        cur->advance = FT_NEXT_USHORT( p );
        cur->bearing = FT_NEXT_SHORT( p );
      }
    }

    /* do we have an inconsistent number of metric values? */
    {
      TT_ShortMetrics*  cur   = *shorts;
      TT_ShortMetrics*  limit = cur +
                                FT_MIN( num_shorts, num_shorts_checked );


      for ( ; cur < limit; cur++ )
        *cur = FT_NEXT_SHORT( p );

      /* We fill up the missing left side bearings with the     */
      /* last valid value.  Since this will occur for buggy CJK */
      /* fonts usually only, nothing serious will happen.       */
      if ( num_shorts > num_shorts_checked && num_shorts_checked > 0 )
      {
        FT_Short  val = (*shorts)[num_shorts_checked - 1];


        limit = *shorts + num_shorts;
        for ( ; cur < limit; cur++ )
          *cur = val;
      }
    }

    FT_FRAME_EXIT();

    if ( vertical )
      face->vertical.number_Of_VMetrics = (FT_UShort)num_longs;
    else
      face->horizontal.number_Of_HMetrics = (FT_UShort)num_longs;

  Fail:
    return error;
  }

#endif /* !FT_CONFIG_OPTION_OLD_INTERNALS */

a200 2
#ifndef FT_CONFIG_OPTION_OLD_INTERNALS

a276 42

#else /* !FT_CONFIG_OPTION_OLD_INTERNALS */

  FT_LOCAL_DEF( FT_Error )
  tt_face_get_metrics( TT_Face     face,
                       FT_Bool     vertical,
                       FT_UInt     gindex,
                       FT_Short*   abearing,
                       FT_UShort*  aadvance )
  {
    void*           v = &face->vertical;
    void*           h = &face->horizontal;
    TT_HoriHeader*  header = vertical ? (TT_HoriHeader*)v
                                      : (TT_HoriHeader*)h;
    TT_LongMetrics  longs_m;
    FT_UShort       k = header->number_Of_HMetrics;


    if ( k == 0                                         ||
         !header->long_metrics                          ||
         gindex >= (FT_UInt)face->max_profile.numGlyphs )
    {
      *abearing = *aadvance = 0;
      return FT_Err_Ok;
    }

    if ( gindex < (FT_UInt)k )
    {
      longs_m   = (TT_LongMetrics)header->long_metrics + gindex;
      *abearing = longs_m->bearing;
      *aadvance = longs_m->advance;
    }
    else
    {
      *abearing = ((TT_ShortMetrics*)header->short_metrics)[gindex - k];
      *aadvance = ((TT_LongMetrics)header->long_metrics)[k - 1].advance;
    }

    return FT_Err_Ok;
  }

#endif /* !FT_CONFIG_OPTION_OLD_INTERNALS */
@


1.6
log
@Update to freetype-2.4.10.

With help and ok matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2006-2009, 2011-2012 by                                      */
d170 2
a171 2
      error = vertical ? SFNT_Err_Invalid_Vert_Metrics
                       : SFNT_Err_Invalid_Horiz_Metrics;
d422 1
a422 1
    return SFNT_Err_Ok;
d447 1
a447 1
      return SFNT_Err_Ok;
d462 1
a462 1
    return SFNT_Err_Ok;
@


1.5
log
@Update to freetype 2.4.5. Tested by many.
@
text
@d7 1
a7 1
/*  Copyright 2006-2009, 2011 by                                           */
d263 1
a263 1
    const FT_Frame_Field  metrics_header_fields[] =
@


1.4
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 2006, 2007, 2008, 2009 by                                    */
d166 1
a166 1
                  vertical ? "v" : "h" ));
@


1.3
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d7 1
a7 1
/*  Copyright 2006, 2007, 2008 by                                          */
d164 3
a166 1
      FT_ERROR(( "%cmtx has more metrics than glyphs.\n" ));
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d7 1
a7 1
/*  Copyright 2006, 2007 by                                                */
d63 1
a63 1
#if !defined FT_CONFIG_OPTION_OLD_INTERNALS
d100 1
a100 1
#else /* !OPTIMIZE_MEMORY || OLD_INTERNALS */
d232 1
a232 1
#endif /* !OPTIMIZE_MEMORY || OLD_INTERNALS */
d344 1
a344 1
#if !defined FT_CONFIG_OPTION_OLD_INTERNALS
d423 1
a423 1
#else /* OLD_INTERNALS */
d463 1
a463 1
#endif /* !OPTIMIZE_MEMORY || OLD_INTERNALS */
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 2006 by                                                      */
d63 1
a63 1
#if defined FT_OPTIMIZE_MEMORY && !defined FT_CONFIG_OPTION_OLD_INTERNALS
d71 2
a72 2
    FT_ULong   table_size;
    FT_Byte**  ptable;
d74 2
a75 2
    
    
d78 3
a80 6
      error = face->goto_table( face, TTAG_vmtx, stream, &table_size );
      if ( error )
        goto Fail;

      ptable      = &face->vert_metrics;
      ptable_size = &face->vert_metrics_size;
d84 4
a87 3
      error = face->goto_table( face, TTAG_hmtx, stream, &table_size );
      if ( error )
        goto Fail;
d89 2
a90 5
      ptable      = &face->horz_metrics;
      ptable_size = &face->horz_metrics_size;
    }
    
    if ( FT_FRAME_EXTRACT( table_size, *ptable ) )
d92 3
a94 2
      
    *ptable_size = table_size;
d113 1
a113 1
    TT_LongMetrics *   longs;
d115 1
d120 4
d130 1
a130 1
        num_longs = (FT_Long)(table_len / 4);
d134 2
a135 2
      longs  = (TT_LongMetrics *)&face->vertical.long_metrics;
      shorts = (TT_ShortMetrics**)&face->vertical.short_metrics;
d139 4
d149 1
a149 1
        num_longs = (FT_Long)(table_len / 4);
d153 2
a154 2
      longs  = (TT_LongMetrics *)&face->horizontal.long_metrics;
      shorts = (TT_ShortMetrics**)&face->horizontal.short_metrics;
d183 2
d192 2
a193 2
        cur->advance = FT_GET_USHORT();
        cur->bearing = FT_GET_SHORT();
d205 1
a205 1
        *cur = FT_GET_SHORT();
d290 3
d297 1
a297 1
      header = (TT_HoriHeader*)&face->vertical;
d326 1
a326 1
  /*    tt_face_get_metrics                                                */ 
d344 1
a344 1
#if defined FT_OPTIMIZE_MEMORY && !defined FT_CONFIG_OPTION_OLD_INTERNALS
d353 2
d356 1
a356 2
    FT_Byte*        p;
    FT_Byte*        limit;
d362 6
a367 3
      header = (TT_HoriHeader*)&face->vertical;
      p      = face->vert_metrics;
      limit  = p + face->vert_metrics_size;
d371 3
a373 3
      header = &face->horizontal;
      p      = face->horz_metrics;
      limit  = p + face->horz_metrics_size;
d376 2
d384 2
a385 2
        p += 4 * gindex;
        if ( p + 4 > limit )
d388 4
a391 2
        *aadvance = FT_NEXT_USHORT( p );
        *abearing = FT_NEXT_SHORT( p );
d395 2
a396 2
        p += 4 * ( k - 1 );
        if ( p + 4 > limit )
d399 6
a404 3
        *aadvance = FT_NEXT_USHORT( p );
        p += 2 + 2 * ( gindex - k );
        if ( p + 2 > limit )
d407 4
a410 1
          *abearing = FT_PEEK_SHORT( p );
d423 1
a423 1
#else /* !OPTIMIZE_MEMORY || OLD_INTERNALS */
d432 4
a435 2
    TT_HoriHeader*  header = vertical ? (TT_HoriHeader*)&face->vertical
                                      :                 &face->horizontal;
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d7 1
a7 1
/*  Copyright 2006, 2007 by                                                */
d63 1
a63 1
#if !defined FT_CONFIG_OPTION_OLD_INTERNALS
d71 2
a72 2
    FT_ULong   tag, table_size;
    FT_ULong*  ptable_offset;
d74 2
a75 2


d78 6
a83 3
      tag           = TTAG_vmtx;
      ptable_offset = &face->vert_metrics_offset;
      ptable_size   = &face->vert_metrics_size;
d87 6
a92 3
      tag           = TTAG_hmtx;
      ptable_offset = &face->horz_metrics_offset;
      ptable_size   = &face->horz_metrics_size;
d94 2
a95 3

    error = face->goto_table( face, tag, stream, &table_size );
    if ( error )
d97 2
a98 3

    *ptable_size   = table_size;
    *ptable_offset = FT_STREAM_POS();
d117 1
a117 1
    TT_LongMetrics*    longs;
a118 1
    FT_Byte*           p;
a122 4
      void*   lm = &face->vertical.long_metrics;
      void**  sm = &face->vertical.short_metrics;


d129 1
a129 1
        num_longs = (FT_Long)( table_len / 4 );
d133 2
a134 2
      longs  = (TT_LongMetrics*)lm;
      shorts = (TT_ShortMetrics**)sm;
a137 4
      void*   lm = &face->horizontal.long_metrics;
      void**  sm = &face->horizontal.short_metrics;


d144 1
a144 1
        num_longs = (FT_Long)( table_len / 4 );
d148 2
a149 2
      longs  = (TT_LongMetrics*)lm;
      shorts = (TT_ShortMetrics**)sm;
a177 2
    p = stream->cursor;

d185 2
a186 2
        cur->advance = FT_NEXT_USHORT( p );
        cur->bearing = FT_NEXT_SHORT( p );
d198 1
a198 1
        *cur = FT_NEXT_SHORT( p );
a282 3
      void  *v = &face->vertical;


d287 1
a287 1
      header = (TT_HoriHeader*)v;
d316 1
a316 1
  /*    tt_face_get_metrics                                                */
d334 1
a334 1
#if !defined FT_CONFIG_OPTION_OLD_INTERNALS
a342 2
    FT_Error        error;
    FT_Stream       stream = face->root.stream;
d344 2
a345 1
    FT_ULong        table_pos, table_size, table_end;
d351 3
a353 6
      void*  v = &face->vertical;


      header     = (TT_HoriHeader*)v;
      table_pos  = face->vert_metrics_offset;
      table_size = face->vert_metrics_size;
d357 3
a359 3
      header     = &face->horizontal;
      table_pos  = face->horz_metrics_offset;
      table_size = face->horz_metrics_size;
a361 2
    table_end = table_pos + table_size;

d368 2
a369 2
        table_pos += 4 * gindex;
        if ( table_pos + 4 > table_end )
d372 2
a373 4
        if ( FT_STREAM_SEEK( table_pos ) ||
             FT_READ_USHORT( *aadvance ) ||
             FT_READ_SHORT( *abearing )  )
          goto NoData;
d377 2
a378 2
        table_pos += 4 * ( k - 1 );
        if ( table_pos + 4 > table_end )
d381 3
a383 6
        if ( FT_STREAM_SEEK( table_pos ) ||
             FT_READ_USHORT( *aadvance ) )
          goto NoData;

        table_pos += 4 + 2 * ( gindex - k );
        if ( table_pos + 2 > table_end )
d386 1
a386 4
        {
          if ( !FT_STREAM_SEEK( table_pos ) )
            (void)FT_READ_SHORT( *abearing );
        }
d399 1
a399 1
#else /* OLD_INTERNALS */
d408 2
a409 3
    void*           v = &face->vertical;
    void*           h = &face->horizontal;
    TT_HoriHeader*  header = vertical ? (TT_HoriHeader*)v : h;
@

