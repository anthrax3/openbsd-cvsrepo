head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.2
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.2
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.10
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.8
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2017.01.13.11.20.00;	author dcoppa;	state Exp;
branches;
next	1.10;
commitid	ESXG9TuEmwmBXggf;

1.10
date	2016.08.09.07.16.10;	author dcoppa;	state Exp;
branches;
next	1.9;
commitid	C8TgUUJolulx9B5d;

1.9
date	2016.05.29.11.57.14;	author dcoppa;	state Exp;
branches;
next	1.8;
commitid	1dOLexdOAzW2mQjp;

1.8
date	2015.06.28.08.27.50;	author dcoppa;	state Exp;
branches;
next	1.7;
commitid	qXwIGV2h9uFjxAmt;

1.7
date	2014.12.26.17.52.36;	author dcoppa;	state Exp;
branches;
next	1.6;
commitid	gwhRExMduYqoPQHI;

1.6
date	2013.06.07.17.21.11;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.19.16.08.14;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.23.19.30.17;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.25.20.49.55;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.10.20.28.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.46;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.46;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.33.06;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ttpost.c                                                               */
/*                                                                         */
/*    PostScript name table processing for TrueType and OpenType fonts     */
/*    (body).                                                              */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* The post table is not completely loaded by the core engine.  This     */
  /* file loads the missing PS glyph names and implements an API to access */
  /* them.                                                                 */
  /*                                                                       */
  /*************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_STREAM_H
#include FT_TRUETYPE_TAGS_H
#include "ttpost.h"

#include "sferrors.h"


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_ttpost


  /* If this configuration macro is defined, we rely on the `PSNames' */
  /* module to grab the glyph names.                                  */

#ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES


#include FT_SERVICE_POSTSCRIPT_CMAPS_H

#define MAC_NAME( x )  (FT_String*)psnames->macintosh_name( (FT_UInt)(x) )


#else /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */


   /* Otherwise, we ignore the `PSNames' module, and provide our own  */
   /* table of Mac names.  Thus, it is possible to build a version of */
   /* FreeType without the Type 1 driver & PSNames module.            */

#define MAC_NAME( x )  (FT_String*)tt_post_default_names[x]

  /* the 258 default Mac PS glyph names; see file `tools/glnames.py' */

  static const FT_String* const  tt_post_default_names[258] =
  {
    /*   0 */
    ".notdef", ".null", "nonmarkingreturn", "space", "exclam",
    "quotedbl", "numbersign", "dollar", "percent", "ampersand",
    /*  10 */
    "quotesingle", "parenleft", "parenright", "asterisk", "plus",
    "comma", "hyphen", "period", "slash", "zero",
    /*  20 */
    "one", "two", "three", "four", "five",
    "six", "seven", "eight", "nine", "colon",
    /*  30 */
    "semicolon", "less", "equal", "greater", "question",
    "at", "A", "B", "C", "D",
    /*  40 */
    "E", "F", "G", "H", "I",
    "J", "K", "L", "M", "N",
    /*  50 */
    "O", "P", "Q", "R", "S",
    "T", "U", "V", "W", "X",
    /*  60 */
    "Y", "Z", "bracketleft", "backslash", "bracketright",
    "asciicircum", "underscore", "grave", "a", "b",
    /*  70 */
    "c", "d", "e", "f", "g",
    "h", "i", "j", "k", "l",
    /*  80 */
    "m", "n", "o", "p", "q",
    "r", "s", "t", "u", "v",
    /*  90 */
    "w", "x", "y", "z", "braceleft",
    "bar", "braceright", "asciitilde", "Adieresis", "Aring",
    /* 100 */
    "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis",
    "aacute", "agrave", "acircumflex", "adieresis", "atilde",
    /* 110 */
    "aring", "ccedilla", "eacute", "egrave", "ecircumflex",
    "edieresis", "iacute", "igrave", "icircumflex", "idieresis",
    /* 120 */
    "ntilde", "oacute", "ograve", "ocircumflex", "odieresis",
    "otilde", "uacute", "ugrave", "ucircumflex", "udieresis",
    /* 130 */
    "dagger", "degree", "cent", "sterling", "section",
    "bullet", "paragraph", "germandbls", "registered", "copyright",
    /* 140 */
    "trademark", "acute", "dieresis", "notequal", "AE",
    "Oslash", "infinity", "plusminus", "lessequal", "greaterequal",
    /* 150 */
    "yen", "mu", "partialdiff", "summation", "product",
    "pi", "integral", "ordfeminine", "ordmasculine", "Omega",
    /* 160 */
    "ae", "oslash", "questiondown", "exclamdown", "logicalnot",
    "radical", "florin", "approxequal", "Delta", "guillemotleft",
    /* 170 */
    "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde",
    "Otilde", "OE", "oe", "endash", "emdash",
    /* 180 */
    "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide",
    "lozenge", "ydieresis", "Ydieresis", "fraction", "currency",
    /* 190 */
    "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl",
    "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex",
    /* 200 */
    "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute",
    "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex",
    /* 210 */
    "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave",
    "dotlessi", "circumflex", "tilde", "macron", "breve",
    /* 220 */
    "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek",
    "caron", "Lslash", "lslash", "Scaron", "scaron",
    /* 230 */
    "Zcaron", "zcaron", "brokenbar", "Eth", "eth",
    "Yacute", "yacute", "Thorn", "thorn", "minus",
    /* 240 */
    "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf",
    "onequarter", "threequarters", "franc", "Gbreve", "gbreve",
    /* 250 */
    "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute",
    "Ccaron", "ccaron", "dcroat",
  };


#endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */


  static FT_Error
  load_format_20( TT_Face    face,
                  FT_Stream  stream,
                  FT_ULong   post_limit )
  {
    FT_Memory   memory = stream->memory;
    FT_Error    error;

    FT_Int      num_glyphs;
    FT_UShort   num_names;

    FT_UShort*  glyph_indices = NULL;
    FT_Char**   name_strings  = NULL;


    if ( FT_READ_USHORT( num_glyphs ) )
      goto Exit;

    /* UNDOCUMENTED!  The number of glyphs in this table can be smaller */
    /* than the value in the maxp table (cf. cyberbit.ttf).             */

    /* There already exist fonts which have more than 32768 glyph names */
    /* in this table, so the test for this threshold has been dropped.  */

    if ( num_glyphs > face->max_profile.numGlyphs )
    {
      error = FT_THROW( Invalid_File_Format );
      goto Exit;
    }

    /* load the indices */
    {
      FT_Int  n;


      if ( FT_NEW_ARRAY ( glyph_indices, num_glyphs ) ||
           FT_FRAME_ENTER( num_glyphs * 2L )          )
        goto Fail;

      for ( n = 0; n < num_glyphs; n++ )
        glyph_indices[n] = FT_GET_USHORT();

      FT_FRAME_EXIT();
    }

    /* compute number of names stored in table */
    {
      FT_Int  n;


      num_names = 0;

      for ( n = 0; n < num_glyphs; n++ )
      {
        FT_Int  idx;


        idx = glyph_indices[n];
        if ( idx >= 258 )
        {
          idx -= 257;
          if ( idx > num_names )
            num_names = (FT_UShort)idx;
        }
      }
    }

    /* now load the name strings */
    {
      FT_UShort  n;


      if ( FT_NEW_ARRAY( name_strings, num_names ) )
        goto Fail;

      for ( n = 0; n < num_names; n++ )
      {
        FT_UInt  len;


        if ( FT_STREAM_POS() >= post_limit )
          break;
        else
        {
          FT_TRACE6(( "load_format_20: %d byte left in post table\n",
                      post_limit - FT_STREAM_POS() ));

          if ( FT_READ_BYTE( len ) )
            goto Fail1;
        }

        if ( len > post_limit                   ||
             FT_STREAM_POS() > post_limit - len )
        {
          FT_Int  d = (FT_Int)post_limit - (FT_Int)FT_STREAM_POS();


          FT_ERROR(( "load_format_20:"
                     " exceeding string length (%d),"
                     " truncating at end of post table (%d byte left)\n",
                     len, d ));
          len = (FT_UInt)FT_MAX( 0, d );
        }

        if ( FT_NEW_ARRAY( name_strings[n], len + 1 ) ||
             FT_STREAM_READ( name_strings[n], len   ) )
          goto Fail1;

        name_strings[n][len] = '\0';
      }

      if ( n < num_names )
      {
        FT_ERROR(( "load_format_20:"
                   " all entries in post table are already parsed,"
                   " using NULL names for gid %d - %d\n",
                    n, num_names - 1 ));
        for ( ; n < num_names; n++ )
          if ( FT_NEW_ARRAY( name_strings[n], 1 ) )
            goto Fail1;
          else
            name_strings[n][0] = '\0';
      }
    }

    /* all right, set table fields and exit successfully */
    {
      TT_Post_20  table = &face->postscript_names.names.format_20;


      table->num_glyphs    = (FT_UShort)num_glyphs;
      table->num_names     = (FT_UShort)num_names;
      table->glyph_indices = glyph_indices;
      table->glyph_names   = name_strings;
    }
    return FT_Err_Ok;

  Fail1:
    {
      FT_UShort  n;


      for ( n = 0; n < num_names; n++ )
        FT_FREE( name_strings[n] );
    }

  Fail:
    FT_FREE( name_strings );
    FT_FREE( glyph_indices );

  Exit:
    return error;
  }


  static FT_Error
  load_format_25( TT_Face    face,
                  FT_Stream  stream,
                  FT_ULong   post_limit )
  {
    FT_Memory  memory = stream->memory;
    FT_Error   error;

    FT_Int     num_glyphs;
    FT_Char*   offset_table = NULL;

    FT_UNUSED( post_limit );


    /* UNDOCUMENTED!  This value appears only in the Apple TT specs. */
    if ( FT_READ_USHORT( num_glyphs ) )
      goto Exit;

    /* check the number of glyphs */
    if ( num_glyphs > face->max_profile.numGlyphs ||
         num_glyphs > 258                         ||
         num_glyphs < 1                           )
    {
      error = FT_THROW( Invalid_File_Format );
      goto Exit;
    }

    if ( FT_NEW_ARRAY( offset_table, num_glyphs )   ||
         FT_STREAM_READ( offset_table, num_glyphs ) )
      goto Fail;

    /* now check the offset table */
    {
      FT_Int  n;


      for ( n = 0; n < num_glyphs; n++ )
      {
        FT_Long  idx = (FT_Long)n + offset_table[n];


        if ( idx < 0 || idx > num_glyphs )
        {
          error = FT_THROW( Invalid_File_Format );
          goto Fail;
        }
      }
    }

    /* OK, set table fields and exit successfully */
    {
      TT_Post_25  table = &face->postscript_names.names.format_25;


      table->num_glyphs = (FT_UShort)num_glyphs;
      table->offsets    = offset_table;
    }

    return FT_Err_Ok;

  Fail:
    FT_FREE( offset_table );

  Exit:
    return error;
  }


  static FT_Error
  load_post_names( TT_Face  face )
  {
    FT_Stream  stream;
    FT_Error   error;
    FT_Fixed   format;
    FT_ULong   post_len;
    FT_ULong   post_limit;


    /* get a stream for the face's resource */
    stream = face->root.stream;

    /* seek to the beginning of the PS names table */
    error = face->goto_table( face, TTAG_post, stream, &post_len );
    if ( error )
      goto Exit;

    post_limit = FT_STREAM_POS() + post_len;

    format = face->postscript.FormatType;

    /* go to beginning of subtable */
    if ( FT_STREAM_SKIP( 32 ) )
      goto Exit;

    /* now read postscript table */
    if ( format == 0x00020000L )
      error = load_format_20( face, stream, post_limit );
    else if ( format == 0x00028000L )
      error = load_format_25( face, stream, post_limit );
    else
      error = FT_THROW( Invalid_File_Format );

    face->postscript_names.loaded = 1;

  Exit:
    return error;
  }


  FT_LOCAL_DEF( void )
  tt_face_free_ps_names( TT_Face  face )
  {
    FT_Memory      memory = face->root.memory;
    TT_Post_Names  names  = &face->postscript_names;
    FT_Fixed       format;


    if ( names->loaded )
    {
      format = face->postscript.FormatType;

      if ( format == 0x00020000L )
      {
        TT_Post_20  table = &names->names.format_20;
        FT_UShort   n;


        FT_FREE( table->glyph_indices );
        table->num_glyphs = 0;

        for ( n = 0; n < table->num_names; n++ )
          FT_FREE( table->glyph_names[n] );

        FT_FREE( table->glyph_names );
        table->num_names = 0;
      }
      else if ( format == 0x00028000L )
      {
        TT_Post_25  table = &names->names.format_25;


        FT_FREE( table->offsets );
        table->num_glyphs = 0;
      }
    }
    names->loaded = 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    tt_face_get_ps_name                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Get the PostScript glyph name of a glyph.                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the parent face.                             */
  /*                                                                       */
  /*    idx    :: The glyph index.                                         */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    PSname :: The address of a string pointer.  Will be NULL in case   */
  /*              of error, otherwise it is a pointer to the glyph name.   */
  /*                                                                       */
  /*              You must not modify the returned string!                 */
  /*                                                                       */
  /* <Output>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  tt_face_get_ps_name( TT_Face      face,
                       FT_UInt      idx,
                       FT_String**  PSname )
  {
    FT_Error       error;
    TT_Post_Names  names;
    FT_Fixed       format;

#ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
    FT_Service_PsCMaps  psnames;
#endif


    if ( !face )
      return FT_THROW( Invalid_Face_Handle );

    if ( idx >= (FT_UInt)face->max_profile.numGlyphs )
      return FT_THROW( Invalid_Glyph_Index );

#ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
    psnames = (FT_Service_PsCMaps)face->psnames;
    if ( !psnames )
      return FT_THROW( Unimplemented_Feature );
#endif

    names = &face->postscript_names;

    /* `.notdef' by default */
    *PSname = MAC_NAME( 0 );

    format = face->postscript.FormatType;

    if ( format == 0x00010000L )
    {
      if ( idx < 258 )                    /* paranoid checking */
        *PSname = MAC_NAME( idx );
    }
    else if ( format == 0x00020000L )
    {
      TT_Post_20  table = &names->names.format_20;


      if ( !names->loaded )
      {
        error = load_post_names( face );
        if ( error )
          goto End;
      }

      if ( idx < (FT_UInt)table->num_glyphs )
      {
        FT_UShort  name_index = table->glyph_indices[idx];


        if ( name_index < 258 )
          *PSname = MAC_NAME( name_index );
        else
          *PSname = (FT_String*)table->glyph_names[name_index - 258];
      }
    }
    else if ( format == 0x00028000L )
    {
      TT_Post_25  table = &names->names.format_25;


      if ( !names->loaded )
      {
        error = load_post_names( face );
        if ( error )
          goto End;
      }

      if ( idx < (FT_UInt)table->num_glyphs )    /* paranoid checking */
        *PSname = MAC_NAME( (FT_Int)idx + table->offsets[idx] );
    }

    /* nothing to do for format == 0x00030000L */

  End:
    return FT_Err_Ok;
  }


/* END */
@


1.10
log
@
Update to FreeType 2.6.5

ok matthieu@@
@
text
@d329 3
a331 1
    if ( num_glyphs > face->max_profile.numGlyphs || num_glyphs > 258 )
@


1.9
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d5 1
a5 1
/*    Postcript name table processing for TrueType and OpenType fonts      */
@


1.8
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d8 1
a8 1
/*  Copyright 1996-2015 by                                                 */
@


1.7
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d8 1
a8 1
/*  Copyright 1996-2003, 2006-2010, 2013, 2014 by                          */
d55 1
a55 1
#define MAC_NAME( x )  ( (FT_String*)psnames->macintosh_name( x ) )
d65 1
a65 1
#define MAC_NAME( x )  ( (FT_String*)tt_post_default_names[x] )
d158 1
a158 1
                  FT_Long    post_limit )
d166 2
a167 2
    FT_UShort*  glyph_indices = 0;
    FT_Char**   name_strings  = 0;
d246 2
a247 2
        if ( (FT_Int)len > post_limit                   ||
             FT_STREAM_POS() > post_limit - (FT_Int)len )
d249 3
d255 2
a256 2
                     len, post_limit - FT_STREAM_POS() ));
          len = FT_MAX( 0, post_limit - FT_STREAM_POS() );
d313 1
a313 1
                  FT_Long    post_limit )
d319 1
a319 1
    FT_Char*   offset_table = 0;
d383 1
a383 1
    FT_Long    post_limit;
d553 1
a553 4
      {
        idx    += table->offsets[idx];
        *PSname = MAC_NAME( idx );
      }
@


1.6
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@d8 1
a8 1
/*  Copyright 1996-2003, 2006-2010, 2013 by                                */
d67 1
a67 1
  /* the 258 default Mac PS glyph names */
d72 1
a72 1
    ".notdef", ".null", "CR", "space", "exclam",
d123 1
a123 1
    "guillemotright", "ellipsis", "nbspace", "Agrave", "Atilde",
d147 2
a148 2
    "Idot", "Scedilla", "scedilla", "Cacute", "cacute",
    "Ccaron", "ccaron", "dmacron",
@


1.5
log
@Update to freetype 2.4.4. Tested by shadchin@@, ajacoutot@@, krw@@.
@
text
@d8 1
a8 1
/*  Copyright 1996-2001, 2002, 2003, 2006, 2007, 2008, 2009, 2010 by       */
d181 1
a181 1
      error = SFNT_Err_Invalid_File_Format;
d287 1
a287 1
    return SFNT_Err_Ok;
d328 1
a328 1
      error = SFNT_Err_Invalid_File_Format;
d348 1
a348 1
          error = SFNT_Err_Invalid_File_Format;
d363 1
a363 1
    return SFNT_Err_Ok;
d405 1
a405 1
      error = SFNT_Err_Invalid_File_Format;
d491 1
a491 1
      return SFNT_Err_Invalid_Face_Handle;
d494 1
a494 1
      return SFNT_Err_Invalid_Glyph_Index;
d499 1
a499 1
      return SFNT_Err_Unimplemented_Feature;
d559 1
a559 1
    return SFNT_Err_Ok;
@


1.4
log
@Update to freetype 2.4.3. Tested at least by krw@@, ajacoutot@@ and jasper@@
@
text
@d29 1
@


1.3
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d8 1
a8 1
/*  Copyright 1996-2001, 2002, 2003, 2006, 2007, 2008, 2009 by             */
d156 2
a157 1
                  FT_Stream  stream )
d234 23
a256 3
        if ( FT_READ_BYTE  ( len )                    ||
             FT_NEW_ARRAY( name_strings[n], len + 1 ) ||
             FT_STREAM_READ  ( name_strings[n], len ) )
d261 13
d308 2
a309 1
                  FT_Stream  stream )
d317 2
d378 2
d386 1
a386 1
    error = face->goto_table( face, TTAG_post, stream, 0 );
d390 2
d400 1
a400 1
      error = load_format_20( face, stream );
d402 1
a402 1
      error = load_format_25( face, stream );
@


1.2
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d8 1
a8 1
/*  Copyright 1996-2001, 2002, 2003, 2006, 2007, 2008 by                   */
a31 1
#include "ttload.h"
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
/*  Copyright 1996-2001, 2002, 2003, 2006 by                               */
d65 1
a65 1
#define MAC_NAME( x )  tt_post_default_names[x]
d69 1
a69 1
  static const FT_String*  tt_post_default_names[258] =
d243 1
a243 1
    /* all right, set table fields and exit successfuly */
d317 1
a317 1
    /* OK, set table fields and exit successfuly */
d419 1
a419 1
  /*    Gets the PostScript glyph name of a glyph.                         */
d426 1
d440 3
a442 3
    FT_Error         error;
    TT_Post_Names    names;
    FT_Fixed         format;
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d8 1
a8 1
/*  Copyright 1996-2001, 2002, 2003, 2006, 2007 by                         */
d243 1
a243 1
    /* all right, set table fields and exit successfully */
d317 1
a317 1
    /* OK, set table fields and exit successfully */
@

