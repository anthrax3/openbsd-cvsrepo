head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.2
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.20.0.2
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.2
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.2
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.2
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2017.06.23.16.15.19;	author dcoppa;	state Exp;
branches;
next	1.20;
commitid	nHj0O50aY5QcUcQ4;

1.20
date	2017.01.13.11.19.59;	author dcoppa;	state Exp;
branches;
next	1.19;
commitid	ESXG9TuEmwmBXggf;

1.19
date	2016.08.09.07.16.09;	author dcoppa;	state Exp;
branches;
next	1.18;
commitid	C8TgUUJolulx9B5d;

1.18
date	2016.05.29.11.57.12;	author dcoppa;	state Exp;
branches;
next	1.17;
commitid	1dOLexdOAzW2mQjp;

1.17
date	2015.10.19.07.51.37;	author dcoppa;	state Exp;
branches;
next	1.16;
commitid	d2XmJCtYff11VIDu;

1.16
date	2015.06.28.08.27.47;	author dcoppa;	state Exp;
branches;
next	1.15;
commitid	qXwIGV2h9uFjxAmt;

1.15
date	2015.01.10.17.17.23;	author dcoppa;	state Exp;
branches;
next	1.14;
commitid	2tSYQMWVSV3t7clo;

1.14
date	2014.03.14.08.18.01;	author dcoppa;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.10.19.49.51;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.07.17.21.09;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.01.04.16.51.58;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.04.14.09.45.47;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.19.11.32.46;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.18.20.29.58;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.19.16.08.13;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.01.19.14.25;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.25.20.49.54;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.26.07.31.45;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.10.20.28.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.41;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.33.00;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@
Update to freetype-2.8

No fallout in a bulk build on i386 (sthen@@)

OK matthieu@@, sthen@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftrfork.c                                                              */
/*                                                                         */
/*    Embedded resource forks accessor (body).                             */
/*                                                                         */
/*  Copyright 2004-2017 by                                                 */
/*  Masatake YAMATO and Redhat K.K.                                        */
/*                                                                         */
/*  FT_Raccess_Get_HeaderInfo() and raccess_guess_darwin_hfsplus() are     */
/*  derived from ftobjs.c.                                                 */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/

/***************************************************************************/
/* Development of the code in this file is support of                      */
/* Information-technology Promotion Agency, Japan.                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_STREAM_H
#include FT_INTERNAL_RFORK_H
#include "basepic.h"
#include "ftbase.h"

#undef  FT_COMPONENT
#define FT_COMPONENT  trace_raccess


  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****                                                                 ****/
  /****               Resource fork directory access                    ****/
  /****                                                                 ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/

  FT_BASE_DEF( FT_Error )
  FT_Raccess_Get_HeaderInfo( FT_Library  library,
                             FT_Stream   stream,
                             FT_Long     rfork_offset,
                             FT_Long    *map_offset,
                             FT_Long    *rdata_pos )
  {
    FT_Error       error;
    unsigned char  head[16], head2[16];
    FT_Long        map_pos, map_len, rdata_len;
    int            allzeros, allmatch, i;
    FT_Long        type_list;

    FT_UNUSED( library );


    error = FT_Stream_Seek( stream, (FT_ULong)rfork_offset );
    if ( error )
      return error;

    error = FT_Stream_Read( stream, (FT_Byte*)head, 16 );
    if ( error )
      return error;

    /* ensure positive values */
    if ( head[0]  >= 0x80 ||
         head[4]  >= 0x80 ||
         head[8]  >= 0x80 ||
         head[12] >= 0x80 )
      return FT_THROW( Unknown_File_Format );

    *rdata_pos = ( head[ 0] << 24 ) |
                 ( head[ 1] << 16 ) |
                 ( head[ 2] <<  8 ) |
                   head[ 3];
    map_pos    = ( head[ 4] << 24 ) |
                 ( head[ 5] << 16 ) |
                 ( head[ 6] <<  8 ) |
                   head[ 7];
    rdata_len  = ( head[ 8] << 24 ) |
                 ( head[ 9] << 16 ) |
                 ( head[10] <<  8 ) |
                   head[11];
    map_len    = ( head[12] << 24 ) |
                 ( head[13] << 16 ) |
                 ( head[14] <<  8 ) |
                   head[15];

    /* the map must not be empty */
    if ( !map_pos )
      return FT_THROW( Unknown_File_Format );

    /* check whether rdata and map overlap */
    if ( *rdata_pos < map_pos )
    {
      if ( *rdata_pos > map_pos - rdata_len )
        return FT_THROW( Unknown_File_Format );
    }
    else
    {
      if ( map_pos > *rdata_pos - map_len )
        return FT_THROW( Unknown_File_Format );
    }

    /* check whether end of rdata or map exceeds stream size */
    if ( FT_LONG_MAX - rdata_len < *rdata_pos                               ||
         FT_LONG_MAX - map_len < map_pos                                    ||

         FT_LONG_MAX - ( *rdata_pos + rdata_len ) < rfork_offset            ||
         FT_LONG_MAX - ( map_pos + map_len ) < rfork_offset                 ||

         (FT_ULong)( rfork_offset + *rdata_pos + rdata_len ) > stream->size ||
         (FT_ULong)( rfork_offset + map_pos + map_len ) > stream->size      )
      return FT_THROW( Unknown_File_Format );

    *rdata_pos += rfork_offset;
    map_pos    += rfork_offset;

    error = FT_Stream_Seek( stream, (FT_ULong)map_pos );
    if ( error )
      return error;

    head2[15] = (FT_Byte)( head[15] + 1 );       /* make it be different */

    error = FT_Stream_Read( stream, (FT_Byte*)head2, 16 );
    if ( error )
      return error;

    allzeros = 1;
    allmatch = 1;
    for ( i = 0; i < 16; i++ )
    {
      if ( head2[i] != 0 )
        allzeros = 0;
      if ( head2[i] != head[i] )
        allmatch = 0;
    }
    if ( !allzeros && !allmatch )
      return FT_THROW( Unknown_File_Format );

    /* If we have reached this point then it is probably a mac resource */
    /* file.  Now, does it contain any interesting resources?           */

    (void)FT_STREAM_SKIP( 4        /* skip handle to next resource map */
                          + 2      /* skip file resource number */
                          + 2 );   /* skip attributes */

    if ( FT_READ_SHORT( type_list ) )
      return error;
    if ( type_list < 0 )
      return FT_THROW( Unknown_File_Format );

    error = FT_Stream_Seek( stream, (FT_ULong)( map_pos + type_list ) );
    if ( error )
      return error;

    *map_offset = map_pos + type_list;
    return FT_Err_Ok;
  }


  static int
  ft_raccess_sort_ref_by_id( FT_RFork_Ref*  a,
                             FT_RFork_Ref*  b )
  {
    if ( a->res_id < b->res_id )
      return -1;
    else if ( a->res_id > b->res_id )
      return 1;
    else
      return 0;
  }


  FT_BASE_DEF( FT_Error )
  FT_Raccess_Get_DataOffsets( FT_Library  library,
                              FT_Stream   stream,
                              FT_Long     map_offset,
                              FT_Long     rdata_pos,
                              FT_Long     tag,
                              FT_Bool     sort_by_res_id,
                              FT_Long   **offsets,
                              FT_Long    *count )
  {
    FT_Error      error;
    int           i, j, cnt, subcnt;
    FT_Long       tag_internal, rpos;
    FT_Memory     memory = library->memory;
    FT_Long       temp;
    FT_Long       *offsets_internal = NULL;
    FT_RFork_Ref  *ref = NULL;


    FT_TRACE3(( "\n" ));
    error = FT_Stream_Seek( stream, (FT_ULong)map_offset );
    if ( error )
      return error;

    if ( FT_READ_SHORT( cnt ) )
      return error;
    cnt++;

    /* `rpos' is a signed 16bit integer offset to resource records; the    */
    /* size of a resource record is 12 bytes.  The map header is 28 bytes, */
    /* and a type list needs 10 bytes or more.  If we assume that the name */
    /* list is empty and we have only a single entry in the type list,     */
    /* there can be at most                                                */
    /*                                                                     */
    /*   (32768 - 28 - 10) / 12 = 2727                                     */
    /*                                                                     */
    /* resources.                                                          */
    /*                                                                     */
    /* A type list starts with a two-byte counter, followed by 10-byte     */
    /* type records.  Assuming that there are no resources, the number of  */
    /* type records can be at most                                         */
    /*                                                                     */
    /*   (32768 - 28 - 2) / 8 = 4079                                       */
    /*                                                                     */
    if ( cnt > 4079 )
      return FT_THROW( Invalid_Table );

    for ( i = 0; i < cnt; i++ )
    {
      if ( FT_READ_LONG( tag_internal ) ||
           FT_READ_SHORT( subcnt )      ||
           FT_READ_SHORT( rpos )        )
        return error;

      FT_TRACE2(( "Resource tags: %c%c%c%c\n",
                  (char)( 0xFF & ( tag_internal >> 24 ) ),
                  (char)( 0xFF & ( tag_internal >> 16 ) ),
                  (char)( 0xFF & ( tag_internal >>  8 ) ),
                  (char)( 0xFF & ( tag_internal >>  0 ) ) ));
      FT_TRACE3(( "             : subcount=%d, suboffset=0x%04x\n",
                  subcnt, rpos ));

      if ( tag_internal == tag )
      {
        *count = subcnt + 1;
        rpos  += map_offset;

        /* a zero count might be valid in the resource specification, */
        /* however, it is completely useless to us                    */
        if ( *count < 1 || *count > 2727 )
          return FT_THROW( Invalid_Table );

        error = FT_Stream_Seek( stream, (FT_ULong)rpos );
        if ( error )
          return error;

        if ( FT_NEW_ARRAY( ref, *count ) )
          return error;

        for ( j = 0; j < *count; j++ )
        {
          if ( FT_READ_SHORT( ref[j].res_id ) )
            goto Exit;
          if ( FT_STREAM_SKIP( 2 ) )  /* resource name offset */
            goto Exit;
          if ( FT_READ_LONG( temp ) ) /* attributes (8bit), offset (24bit) */
            goto Exit;
          if ( FT_STREAM_SKIP( 4 ) )  /* mbz */
            goto Exit;

          if ( ref[j].res_id < 0 || temp < 0 )
          {
            error = FT_THROW( Invalid_Table );
            goto Exit;
          }

          ref[j].offset = temp & 0xFFFFFFL;

          FT_TRACE3(( "             [%d]:"
                      " resource_id=0x%04x, offset=0x%08x\n",
                      j, ref[j].res_id, ref[j].offset ));
        }

        if ( sort_by_res_id )
        {
          ft_qsort( ref,
                    (size_t)*count,
                    sizeof ( FT_RFork_Ref ),
                    ( int(*)(const void*,
                             const void*) )ft_raccess_sort_ref_by_id );

          FT_TRACE3(( "             -- sort resources by their ids --\n" ));

          for ( j = 0; j < *count; j++ )
            FT_TRACE3(( "             [%d]:"
                        " resource_id=0x%04x, offset=0x%08x\n",
                        j, ref[j].res_id, ref[j].offset ));
        }

        if ( FT_NEW_ARRAY( offsets_internal, *count ) )
          goto Exit;

        /* XXX: duplicated reference ID,
         *      gap between reference IDs are acceptable?
         *      further investigation on Apple implementation is needed.
         */
        for ( j = 0; j < *count; j++ )
          offsets_internal[j] = rdata_pos + ref[j].offset;

        *offsets = offsets_internal;
        error    = FT_Err_Ok;

      Exit:
        FT_FREE( ref );
        return error;
      }
    }

    return FT_THROW( Cannot_Open_Resource );
  }


#ifdef FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK

  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****                                                                 ****/
  /****                     Guessing functions                          ****/
  /****                                                                 ****/
  /****            When you add a new guessing function,                ****/
  /****           update FT_RACCESS_N_RULES in ftrfork.h.               ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/

  static FT_Error
  raccess_guess_apple_double( FT_Library  library,
                              FT_Stream   stream,
                              char       *base_file_name,
                              char      **result_file_name,
                              FT_Long    *result_offset );

  static FT_Error
  raccess_guess_apple_single( FT_Library  library,
                              FT_Stream   stream,
                              char       *base_file_name,
                              char      **result_file_name,
                              FT_Long    *result_offset );

  static FT_Error
  raccess_guess_darwin_ufs_export( FT_Library  library,
                                   FT_Stream   stream,
                                   char       *base_file_name,
                                   char      **result_file_name,
                                   FT_Long    *result_offset );

  static FT_Error
  raccess_guess_darwin_newvfs( FT_Library  library,
                               FT_Stream   stream,
                               char       *base_file_name,
                               char      **result_file_name,
                               FT_Long    *result_offset );

  static FT_Error
  raccess_guess_darwin_hfsplus( FT_Library  library,
                                FT_Stream   stream,
                                char       *base_file_name,
                                char      **result_file_name,
                                FT_Long    *result_offset );

  static FT_Error
  raccess_guess_vfat( FT_Library  library,
                      FT_Stream   stream,
                      char       *base_file_name,
                      char      **result_file_name,
                      FT_Long    *result_offset );

  static FT_Error
  raccess_guess_linux_cap( FT_Library  library,
                           FT_Stream   stream,
                           char       *base_file_name,
                           char      **result_file_name,
                           FT_Long    *result_offset );

  static FT_Error
  raccess_guess_linux_double( FT_Library  library,
                              FT_Stream   stream,
                              char       *base_file_name,
                              char      **result_file_name,
                              FT_Long    *result_offset );

  static FT_Error
  raccess_guess_linux_netatalk( FT_Library  library,
                                FT_Stream   stream,
                                char       *base_file_name,
                                char      **result_file_name,
                                FT_Long    *result_offset );


  CONST_FT_RFORK_RULE_ARRAY_BEGIN(ft_raccess_guess_table,
                                  ft_raccess_guess_rec)
  CONST_FT_RFORK_RULE_ARRAY_ENTRY(apple_double,      apple_double)
  CONST_FT_RFORK_RULE_ARRAY_ENTRY(apple_single,      apple_single)
  CONST_FT_RFORK_RULE_ARRAY_ENTRY(darwin_ufs_export, darwin_ufs_export)
  CONST_FT_RFORK_RULE_ARRAY_ENTRY(darwin_newvfs,     darwin_newvfs)
  CONST_FT_RFORK_RULE_ARRAY_ENTRY(darwin_hfsplus,    darwin_hfsplus)
  CONST_FT_RFORK_RULE_ARRAY_ENTRY(vfat,              vfat)
  CONST_FT_RFORK_RULE_ARRAY_ENTRY(linux_cap,         linux_cap)
  CONST_FT_RFORK_RULE_ARRAY_ENTRY(linux_double,      linux_double)
  CONST_FT_RFORK_RULE_ARRAY_ENTRY(linux_netatalk,    linux_netatalk)
  CONST_FT_RFORK_RULE_ARRAY_END


  /*************************************************************************/
  /****                                                                 ****/
  /****                       Helper functions                          ****/
  /****                                                                 ****/
  /*************************************************************************/

  static FT_Error
  raccess_guess_apple_generic( FT_Library  library,
                               FT_Stream   stream,
                               char       *base_file_name,
                               FT_Int32    magic,
                               FT_Long    *result_offset );

  static FT_Error
  raccess_guess_linux_double_from_file_name( FT_Library  library,
                                             char *      file_name,
                                             FT_Long    *result_offset );

  static char *
  raccess_make_file_name( FT_Memory    memory,
                          const char  *original_name,
                          const char  *insertion );

  FT_BASE_DEF( void )
  FT_Raccess_Guess( FT_Library  library,
                    FT_Stream   stream,
                    char*       base_name,
                    char      **new_names,
                    FT_Long    *offsets,
                    FT_Error   *errors )
  {
    FT_Int  i;


    for ( i = 0; i < FT_RACCESS_N_RULES; i++ )
    {
      new_names[i] = NULL;
      if ( NULL != stream )
        errors[i] = FT_Stream_Seek( stream, 0 );
      else
        errors[i] = FT_Err_Ok;

      if ( errors[i] )
        continue;

      errors[i] = (FT_RACCESS_GUESS_TABLE_GET[i].func)( library,
                                                 stream, base_name,
                                                 &(new_names[i]),
                                                 &(offsets[i]) );
    }

    return;
  }


#ifndef FT_MACINTOSH
  static FT_RFork_Rule
  raccess_get_rule_type_from_rule_index( FT_Library  library,
                                         FT_UInt     rule_index )
  {
    FT_UNUSED( library );

    if ( rule_index >= FT_RACCESS_N_RULES )
      return FT_RFork_Rule_invalid;

    return FT_RACCESS_GUESS_TABLE_GET[rule_index].type;
  }


  /*
   * For this function, refer ftbase.h.
   */
  FT_LOCAL_DEF( FT_Bool )
  ft_raccess_rule_by_darwin_vfs( FT_Library  library,
                                 FT_UInt     rule_index )
  {
    switch( raccess_get_rule_type_from_rule_index( library, rule_index ) )
    {
      case FT_RFork_Rule_darwin_newvfs:
      case FT_RFork_Rule_darwin_hfsplus:
        return TRUE;

      default:
        return FALSE;
    }
  }
#endif


  static FT_Error
  raccess_guess_apple_double( FT_Library  library,
                              FT_Stream   stream,
                              char       *base_file_name,
                              char      **result_file_name,
                              FT_Long    *result_offset )
  {
    FT_Int32  magic = ( 0x00 << 24 ) |
                      ( 0x05 << 16 ) |
                      ( 0x16 <<  8 ) |
                        0x07;


    *result_file_name = NULL;
    if ( NULL == stream )
      return FT_THROW( Cannot_Open_Stream );

    return raccess_guess_apple_generic( library, stream, base_file_name,
                                        magic, result_offset );
  }


  static FT_Error
  raccess_guess_apple_single( FT_Library  library,
                              FT_Stream   stream,
                              char       *base_file_name,
                              char      **result_file_name,
                              FT_Long    *result_offset )
  {
    FT_Int32  magic = ( 0x00 << 24 ) |
                      ( 0x05 << 16 ) |
                      ( 0x16 <<  8 ) |
                        0x00;


    *result_file_name = NULL;
    if ( NULL == stream )
      return FT_THROW( Cannot_Open_Stream );

    return raccess_guess_apple_generic( library, stream, base_file_name,
                                        magic, result_offset );
  }


  static FT_Error
  raccess_guess_darwin_ufs_export( FT_Library  library,
                                   FT_Stream   stream,
                                   char       *base_file_name,
                                   char      **result_file_name,
                                   FT_Long    *result_offset )
  {
    char*      newpath;
    FT_Error   error;
    FT_Memory  memory;

    FT_UNUSED( stream );


    memory  = library->memory;
    newpath = raccess_make_file_name( memory, base_file_name, "._" );
    if ( !newpath )
      return FT_THROW( Out_Of_Memory );

    error = raccess_guess_linux_double_from_file_name( library, newpath,
                                                       result_offset );
    if ( !error )
      *result_file_name = newpath;
    else
      FT_FREE( newpath );

    return error;
  }


  static FT_Error
  raccess_guess_darwin_hfsplus( FT_Library  library,
                                FT_Stream   stream,
                                char       *base_file_name,
                                char      **result_file_name,
                                FT_Long    *result_offset )
  {
    /*
      Only meaningful on systems with hfs+ drivers (or Macs).
     */
    FT_Error   error;
    char*      newpath = NULL;
    FT_Memory  memory;
    FT_Long    base_file_len = (FT_Long)ft_strlen( base_file_name );

    FT_UNUSED( stream );


    memory = library->memory;

    if ( base_file_len + 6 > FT_INT_MAX )
      return FT_THROW( Array_Too_Large );

    if ( FT_ALLOC( newpath, base_file_len + 6 ) )
      return error;

    FT_MEM_COPY( newpath, base_file_name, base_file_len );
    FT_MEM_COPY( newpath + base_file_len, "/rsrc", 6 );

    *result_file_name = newpath;
    *result_offset    = 0;

    return FT_Err_Ok;
  }


  static FT_Error
  raccess_guess_darwin_newvfs( FT_Library  library,
                               FT_Stream   stream,
                               char       *base_file_name,
                               char      **result_file_name,
                               FT_Long    *result_offset )
  {
    /*
      Only meaningful on systems with Mac OS X (> 10.1).
     */
    FT_Error   error;
    char*      newpath = NULL;
    FT_Memory  memory;
    FT_Long    base_file_len = (FT_Long)ft_strlen( base_file_name );

    FT_UNUSED( stream );


    memory = library->memory;

    if ( base_file_len + 18 > FT_INT_MAX )
      return FT_THROW( Array_Too_Large );

    if ( FT_ALLOC( newpath, base_file_len + 18 ) )
      return error;

    FT_MEM_COPY( newpath, base_file_name, base_file_len );
    FT_MEM_COPY( newpath + base_file_len, "/..namedfork/rsrc", 18 );

    *result_file_name = newpath;
    *result_offset    = 0;

    return FT_Err_Ok;
  }


  static FT_Error
  raccess_guess_vfat( FT_Library  library,
                      FT_Stream   stream,
                      char       *base_file_name,
                      char      **result_file_name,
                      FT_Long    *result_offset )
  {
    char*      newpath;
    FT_Memory  memory;

    FT_UNUSED( stream );


    memory = library->memory;

    newpath = raccess_make_file_name( memory, base_file_name,
                                      "resource.frk/" );
    if ( !newpath )
      return FT_THROW( Out_Of_Memory );

    *result_file_name = newpath;
    *result_offset    = 0;

    return FT_Err_Ok;
  }


  static FT_Error
  raccess_guess_linux_cap( FT_Library  library,
                           FT_Stream   stream,
                           char       *base_file_name,
                           char      **result_file_name,
                           FT_Long    *result_offset )
  {
    char*      newpath;
    FT_Memory  memory;

    FT_UNUSED( stream );


    memory = library->memory;

    newpath = raccess_make_file_name( memory, base_file_name, ".resource/" );
    if ( !newpath )
      return FT_THROW( Out_Of_Memory );

    *result_file_name = newpath;
    *result_offset    = 0;

    return FT_Err_Ok;
  }


  static FT_Error
  raccess_guess_linux_double( FT_Library  library,
                              FT_Stream   stream,
                              char       *base_file_name,
                              char      **result_file_name,
                              FT_Long    *result_offset )
  {
    char*      newpath;
    FT_Error   error;
    FT_Memory  memory;

    FT_UNUSED( stream );


    memory = library->memory;

    newpath = raccess_make_file_name( memory, base_file_name, "%" );
    if ( !newpath )
      return FT_THROW( Out_Of_Memory );

    error = raccess_guess_linux_double_from_file_name( library, newpath,
                                                       result_offset );
    if ( !error )
      *result_file_name = newpath;
    else
      FT_FREE( newpath );

    return error;
  }


  static FT_Error
  raccess_guess_linux_netatalk( FT_Library  library,
                                FT_Stream   stream,
                                char       *base_file_name,
                                char      **result_file_name,
                                FT_Long    *result_offset )
  {
    char*      newpath;
    FT_Error   error;
    FT_Memory  memory;

    FT_UNUSED( stream );


    memory = library->memory;

    newpath = raccess_make_file_name( memory, base_file_name,
                                      ".AppleDouble/" );
    if ( !newpath )
      return FT_THROW( Out_Of_Memory );

    error = raccess_guess_linux_double_from_file_name( library, newpath,
                                                       result_offset );
    if ( !error )
      *result_file_name = newpath;
    else
      FT_FREE( newpath );

    return error;
  }


  static FT_Error
  raccess_guess_apple_generic( FT_Library  library,
                               FT_Stream   stream,
                               char       *base_file_name,
                               FT_Int32    magic,
                               FT_Long    *result_offset )
  {
    FT_Int32   magic_from_stream;
    FT_Error   error;
    FT_Int32   version_number = 0;
    FT_UShort  n_of_entries;

    int        i;
    FT_Int32   entry_id, entry_offset, entry_length = 0;

    const FT_Int32  resource_fork_entry_id = 0x2;

    FT_UNUSED( library );
    FT_UNUSED( base_file_name );
    FT_UNUSED( version_number );
    FT_UNUSED( entry_length   );


    if ( FT_READ_LONG( magic_from_stream ) )
      return error;
    if ( magic_from_stream != magic )
      return FT_THROW( Unknown_File_Format );

    if ( FT_READ_LONG( version_number ) )
      return error;

    /* filler */
    error = FT_Stream_Skip( stream, 16 );
    if ( error )
      return error;

    if ( FT_READ_USHORT( n_of_entries ) )
      return error;
    if ( n_of_entries == 0 )
      return FT_THROW( Unknown_File_Format );

    for ( i = 0; i < n_of_entries; i++ )
    {
      if ( FT_READ_LONG( entry_id ) )
        return error;
      if ( entry_id == resource_fork_entry_id )
      {
        if ( FT_READ_LONG( entry_offset ) ||
             FT_READ_LONG( entry_length ) )
          continue;
        *result_offset = entry_offset;

        return FT_Err_Ok;
      }
      else
      {
        error = FT_Stream_Skip( stream, 4 + 4 );    /* offset + length */
        if ( error )
          return error;
      }
    }

    return FT_THROW( Unknown_File_Format );
  }


  static FT_Error
  raccess_guess_linux_double_from_file_name( FT_Library  library,
                                             char       *file_name,
                                             FT_Long    *result_offset )
  {
    FT_Open_Args  args2;
    FT_Stream     stream2;
    char *        nouse = NULL;
    FT_Error      error;


    args2.flags    = FT_OPEN_PATHNAME;
    args2.pathname = file_name;
    error = FT_Stream_New( library, &args2, &stream2 );
    if ( error )
      return error;

    error = raccess_guess_apple_double( library, stream2, file_name,
                                        &nouse, result_offset );

    FT_Stream_Free( stream2, 0 );

    return error;
  }


  static char*
  raccess_make_file_name( FT_Memory    memory,
                          const char  *original_name,
                          const char  *insertion )
  {
    char*        new_name = NULL;
    const char*  tmp;
    const char*  slash;
    size_t       new_length;
    FT_Error     error = FT_Err_Ok;

    FT_UNUSED( error );


    new_length = ft_strlen( original_name ) + ft_strlen( insertion );
    if ( FT_ALLOC( new_name, new_length + 1 ) )
      return NULL;

    tmp = ft_strrchr( original_name, '/' );
    if ( tmp )
    {
      ft_strncpy( new_name,
                  original_name,
                  (size_t)( tmp - original_name + 1 ) );
      new_name[tmp - original_name + 1] = '\0';
      slash = tmp + 1;
    }
    else
    {
      slash       = original_name;
      new_name[0] = '\0';
    }

    ft_strcat( new_name, insertion );
    ft_strcat( new_name, slash );

    return new_name;
  }


#else   /* !FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK */


  /*************************************************************************/
  /*                  Dummy function; just sets errors                     */
  /*************************************************************************/

  FT_BASE_DEF( void )
  FT_Raccess_Guess( FT_Library  library,
                    FT_Stream   stream,
                    char       *base_name,
                    char      **new_names,
                    FT_Long    *offsets,
                    FT_Error   *errors )
  {
    FT_Int  i;

    FT_UNUSED( library );
    FT_UNUSED( stream );
    FT_UNUSED( base_name );


    for ( i = 0; i < FT_RACCESS_N_RULES; i++ )
    {
      new_names[i] = NULL;
      offsets[i]   = 0;
      errors[i]    = FT_ERR( Unimplemented_Feature );
    }
  }


#endif  /* !FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK */


/* END */
@


1.20
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2004-2016 by                                                 */
@


1.19
log
@
Update to FreeType 2.6.5

ok matthieu@@
@
text
@d59 1
a59 1
    FT_Long        map_pos, rdata_len;
d70 1
a70 1
    error = FT_Stream_Read( stream, (FT_Byte *)head, 16 );
d75 4
a78 1
    if ( head[0] >= 0x80 || head[4] >= 0x80 || head[8] >= 0x80 )
d93 4
d98 3
a100 1
    /* map_len = head[12] .. head[15] */
d102 18
a119 2
    if ( *rdata_pos != map_pos - rdata_len || map_pos == 0 )
      return FT_THROW( Unknown_File_Format );
d121 2
a122 2
    if ( FT_LONG_MAX - rfork_offset < *rdata_pos ||
         FT_LONG_MAX - rfork_offset < map_pos    )
d140 1
a140 1
    for ( i = 0; i < 16; ++i )
d152 1
a152 2
    /* Skip handle to next resource map, the file resource number, and  */
    /* attributes.                                                      */
d157 1
a157 1
    if ( FT_READ_USHORT( type_list ) )
d159 1
a159 1
    if ( type_list == -1 )
d208 1
a208 1
    if ( FT_READ_USHORT( cnt ) )
d212 20
a231 1
    for ( i = 0; i < cnt; ++i )
d234 2
a235 2
           FT_READ_USHORT( subcnt )     ||
           FT_READ_USHORT( rpos )       )
d251 5
d263 1
a263 1
        for ( j = 0; j < *count; ++j )
d265 1
a265 1
          if ( FT_READ_USHORT( ref[j].res_id ) )
d267 1
a267 1
          if ( FT_STREAM_SKIP( 2 ) ) /* resource name */
d269 1
a269 1
          if ( FT_READ_LONG( temp ) )
d271 1
a271 1
          if ( FT_STREAM_SKIP( 4 ) ) /* mbz */
d274 6
d281 1
d287 1
a287 1
        if (sort_by_res_id)
d289 5
a293 3
          ft_qsort( ref, (size_t)*count, sizeof ( FT_RFork_Ref ),
                    ( int(*)(const void*, const void*) )
                    ft_raccess_sort_ref_by_id );
d296 2
a297 1
          for ( j = 0; j < *count; ++ j ) {
a300 1
          }
d310 1
a310 1
        for ( j = 0; j < *count; ++j )
@


1.18
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d406 1
a406 1
        continue ;
@


1.17
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@d7 1
a7 1
/*  Copyright 2004-2015 by                                                 */
@


1.16
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d74 16
a89 12
    *rdata_pos = rfork_offset + ( ( head[0] << 24 ) |
                                  ( head[1] << 16 ) |
                                  ( head[2] <<  8 ) |
                                    head[3]         );
    map_pos    = rfork_offset + ( ( head[4] << 24 ) |
                                  ( head[5] << 16 ) |
                                  ( head[6] <<  8 ) |
                                    head[7]         );
    rdata_len = ( head[ 8] << 24 ) |
                ( head[ 9] << 16 ) |
                ( head[10] <<  8 ) |
                  head[11];
d93 1
a93 1
    if ( *rdata_pos + rdata_len != map_pos || map_pos == rfork_offset )
d95 7
@


1.15
log
@
Bugfixing update to freetype-2.5.5

ok matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2004-2010, 2013, 2014 by                                     */
d66 1
a66 1
    error = FT_Stream_Seek( stream, rfork_offset );
d92 1
a92 1
    error = FT_Stream_Seek( stream, map_pos );
d127 1
a127 1
    error = FT_Stream_Seek( stream, map_pos + type_list );
d169 1
a169 1
    error = FT_Stream_Seek( stream, map_offset );
d197 1
a197 1
        error = FT_Stream_Seek( stream, rpos );
d223 1
a223 1
          ft_qsort( ref, *count, sizeof ( FT_RFork_Ref ),
d716 1
a716 1
    FT_UInt32  entry_id, entry_offset, entry_length = 0;
d718 1
a718 1
    const FT_UInt32  resource_fork_entry_id = 0x2;
d816 3
a818 1
      ft_strncpy( new_name, original_name, tmp - original_name + 1 );
@


1.14
log
@
Security/bugfixing update to freetype-2.5.3, featuring a fix for a
vulnerability in the CFF driver (CVE-2014-2240) and assorted minor
fixes.

ok matthieu@@
@
text
@d185 4
a188 4
                  (char)( 0xff & ( tag_internal >> 24 ) ),
                  (char)( 0xff & ( tag_internal >> 16 ) ),
                  (char)( 0xff & ( tag_internal >>  8 ) ),
                  (char)( 0xff & ( tag_internal >>  0 ) ) ));
@


1.13
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@d7 1
a7 1
/*  Copyright 2004-2010, 2013 by                                           */
d32 1
d155 1
d168 1
d189 2
d216 3
d221 13
a233 3
        ft_qsort( ref, *count, sizeof ( FT_RFork_Ref ),
                  ( int(*)(const void*, const void*) )
                  ft_raccess_sort_ref_by_id );
@


1.12
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@d510 1
a510 1
    FT_Long    base_file_len = ft_strlen( base_file_name );
d546 1
a546 1
    FT_Long    base_file_len = ft_strlen( base_file_name );
@


1.11
log
@Update to freetype 2.4.11. Tested by krw@@, jasper@@ and on a bulk ports
build by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 2004, 2005, 2006, 2007, 2008, 2009, 2010 by                  */
d89 1
a89 1
      return FT_Err_Unknown_File_Format;
d111 1
a111 1
      return FT_Err_Unknown_File_Format;
d124 1
a124 1
      return FT_Err_Unknown_File_Format;
d236 1
a236 1
    return FT_Err_Cannot_Open_Resource;
d438 1
a438 1
      return FT_Err_Cannot_Open_Stream;
d460 1
a460 1
      return FT_Err_Cannot_Open_Stream;
d484 1
a484 1
      return FT_Err_Out_Of_Memory;
d518 1
a518 1
      return FT_Err_Array_Too_Large;
d554 1
a554 1
      return FT_Err_Array_Too_Large;
d587 1
a587 1
      return FT_Err_Out_Of_Memory;
d613 1
a613 1
      return FT_Err_Out_Of_Memory;
d640 1
a640 1
      return FT_Err_Out_Of_Memory;
d672 1
a672 1
      return FT_Err_Out_Of_Memory;
d711 1
a711 1
      return FT_Err_Unknown_File_Format;
d724 1
a724 1
      return FT_Err_Unknown_File_Format;
d747 1
a747 1
    return FT_Err_Unknown_File_Format;
d841 1
a841 1
      errors[i]    = FT_Err_Unimplemented_Feature;
@


1.10
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@d365 1
a365 1
    FT_Long  i;
d830 1
a830 1
    int  i;
@


1.9
log
@Update to freetype 2.4.8. Security update fixing CVE-2011-3439
@
text
@d31 1
a31 1

a255 8
  typedef FT_Error
  (*raccess_guess_func)( FT_Library  library,
                         FT_Stream   stream,
                         char       *base_file_name,
                         char      **result_file_name,
                         FT_Long    *result_offset );


d320 14
a356 37

  typedef enum  FT_RFork_Rule_ {
    FT_RFork_Rule_invalid = -2,
    FT_RFork_Rule_uknown, /* -1 */
    FT_RFork_Rule_apple_double,
    FT_RFork_Rule_apple_single,
    FT_RFork_Rule_darwin_ufs_export,
    FT_RFork_Rule_darwin_newvfs,
    FT_RFork_Rule_darwin_hfsplus,
    FT_RFork_Rule_vfat,
    FT_RFork_Rule_linux_cap,
    FT_RFork_Rule_linux_double,
    FT_RFork_Rule_linux_netatalk
  } FT_RFork_Rule;

  /* For fast translation between rule index and rule type,
   * the macros FT_RFORK_xxx should be kept consistent with
   * the raccess_guess_funcs table
   */
  typedef struct raccess_guess_rec_ {
    raccess_guess_func  func;
    FT_RFork_Rule       type;
  } raccess_guess_rec;

  static raccess_guess_rec  raccess_guess_table[FT_RACCESS_N_RULES] =
  {
    { raccess_guess_apple_double,	FT_RFork_Rule_apple_double, },
    { raccess_guess_apple_single,	FT_RFork_Rule_apple_single, },
    { raccess_guess_darwin_ufs_export,	FT_RFork_Rule_darwin_ufs_export, },
    { raccess_guess_darwin_newvfs,	FT_RFork_Rule_darwin_newvfs, },
    { raccess_guess_darwin_hfsplus,	FT_RFork_Rule_darwin_hfsplus, },
    { raccess_guess_vfat,		FT_RFork_Rule_vfat, },
    { raccess_guess_linux_cap,		FT_RFork_Rule_linux_cap, },
    { raccess_guess_linux_double,	FT_RFork_Rule_linux_double, },
    { raccess_guess_linux_netatalk,	FT_RFork_Rule_linux_netatalk, },
  };

d379 1
a379 1
      errors[i] = (raccess_guess_table[i].func)( library,
d389 1
a389 1
#if !defined( FT_MACINTOSH ) || defined( DARWIN_NO_CARBON )
d391 2
a392 1
  raccess_get_rule_type_from_rule_index( FT_UInt  rule_index )
d394 2
d399 1
a399 1
    return raccess_guess_table[rule_index].type;
d403 3
d407 2
a408 1
  raccess_rule_by_darwin_vfs( FT_UInt  rule_index )
d410 1
a410 1
    switch( raccess_get_rule_type_from_rule_index( rule_index ) )
@


1.8
log
@Update to freetype 2.4.5. Tested by many.
@
text
@d420 1
d444 1
@


1.7
log
@Update to freetype 2.4.4. Tested by shadchin@@, ajacoutot@@, krw@@.
@
text
@d162 2
a163 2
    FT_Long       *offsets_internal;
    FT_RFork_Ref  *ref;
d530 1
a530 1
    char*      newpath;
d566 1
a566 1
    char*      newpath;
@


1.6
log
@Update to freetype 2.4.2. This has been in snapshots for a while
and tested explicitely by ajacoutot@@ jasper@@, jcs@@, krw@@ and others
on various architectures.
@
text
@d352 36
a398 13
    raccess_guess_func  funcs[FT_RACCESS_N_RULES] =
    {
      raccess_guess_apple_double,
      raccess_guess_apple_single,
      raccess_guess_darwin_ufs_export,
      raccess_guess_darwin_newvfs,
      raccess_guess_darwin_hfsplus,
      raccess_guess_vfat,
      raccess_guess_linux_cap,
      raccess_guess_linux_double,
      raccess_guess_linux_netatalk,
    };

d410 4
a413 2
      errors[i] = (funcs[i])( library, stream, base_name,
                              &(new_names[i]), &(offsets[i]) );
d417 25
@


1.5
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 2004, 2005, 2006, 2007, 2008, 2009 by                        */
d754 1
a754 1
    char*        new_name;
@


1.4
log
@Update to Freetype 2.3.9.

Bump major to be safe.
Small arm assembler fix in ftconfig.h by drahn@@
@
text
@d755 1
a755 1
    char*        tmp;
d757 1
a757 1
    unsigned     new_length;
@


1.3
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d7 1
a7 1
/*  Copyright 2004, 2005, 2006, 2007, 2008 by                              */
d712 4
a715 1
        FT_Stream_Skip( stream, 4 + 4 );    /* offset + length */
d717 1
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d7 1
a7 1
/*  Copyright 2004, 2005, 2006, 2007 by                                    */
d402 4
a405 1
    FT_Int32  magic = ( 0x00 << 24 | 0x05 << 16 | 0x16 << 8 | 0x07 );
d424 4
a427 1
    FT_Int32  magic = (0x00 << 24 | 0x05 << 16 | 0x16 << 8 | 0x00);
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 2004, 2005, 2006 by                                          */
d135 13
d157 7
a163 6
    FT_Error   error;
    int        i, j, cnt, subcnt;
    FT_Long    tag_internal, rpos;
    FT_Memory  memory = library->memory;
    FT_Long    temp;
    FT_Long    *offsets_internal;
d196 1
a196 1
        if ( FT_NEW_ARRAY( offsets_internal, *count ) )
d201 8
a208 2
          (void)FT_STREAM_SKIP( 2 ); /* resource id */
          (void)FT_STREAM_SKIP( 2 ); /* rsource name */
d210 2
a211 5
          if ( FT_READ_LONG( temp ) )
          {
            FT_FREE( offsets_internal );
            return error;
          }
d213 3
a215 1
          offsets_internal[j] = rdata_pos + ( temp & 0xFFFFFFL );
d217 9
a225 2
          (void)FT_STREAM_SKIP( 4 ); /* mbz */
        }
d228 1
d230 3
a232 1
        return FT_Err_Ok;
d259 1
a259 1
                         char *      base_file_name,
d267 1
a267 1
                              char *      base_file_name,
d274 1
a274 1
                              char *      base_file_name,
d281 1
a281 1
                                   char *      base_file_name,
d286 7
d295 1
a295 1
                                char *      base_file_name,
d302 1
a302 1
                      char *      base_file_name,
d309 1
a309 1
                           char *      base_file_name,
d316 1
a316 1
                              char *      base_file_name,
d323 1
a323 1
                                char *      base_file_name,
d337 1
a337 1
                               char *      base_file_name,
d368 1
d379 5
a383 1
      errors[i] = FT_Stream_Seek( stream, 0 );
d398 1
a398 1
                              char *      base_file_name,
d406 3
d417 1
a417 1
                              char *      base_file_name,
d425 3
d436 1
a436 1
                                   char *      base_file_name,
d466 1
a466 1
                                char *      base_file_name,
d483 1
a483 1
    if ( base_file_len > FT_INT_MAX )
d500 36
d538 1
a538 1
                      char *      base_file_name,
d565 1
a565 1
                           char *      base_file_name,
d591 1
a591 1
                              char *      base_file_name,
d622 1
a622 1
                                char *      base_file_name,
d654 1
a654 1
                               char *      base_file_name,
d715 1
a715 1
                                             char *      file_name,
d733 1
a733 1
    FT_Stream_Close( stream2 );
d787 1
a787 1
                    char*       base_name,
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d650 1
a650 1
    FT_Stream_Free( stream2, 0 );
@

