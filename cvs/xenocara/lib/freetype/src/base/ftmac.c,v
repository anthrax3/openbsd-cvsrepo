head	1.15;
access;
symbols
	OPENBSD_6_1:1.14.0.2
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.2
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.12
	OPENBSD_5_0:1.4.0.10
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.6
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.8
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2017.06.23.16.15.19;	author dcoppa;	state Exp;
branches;
next	1.14;
commitid	nHj0O50aY5QcUcQ4;

1.14
date	2017.01.13.11.19.59;	author dcoppa;	state Exp;
branches;
next	1.13;
commitid	ESXG9TuEmwmBXggf;

1.13
date	2016.08.09.07.16.09;	author dcoppa;	state Exp;
branches;
next	1.12;
commitid	C8TgUUJolulx9B5d;

1.12
date	2016.05.29.11.57.12;	author dcoppa;	state Exp;
branches;
next	1.11;
commitid	1dOLexdOAzW2mQjp;

1.11
date	2015.10.19.07.51.37;	author dcoppa;	state Exp;
branches;
next	1.10;
commitid	d2XmJCtYff11VIDu;

1.10
date	2015.06.28.08.27.47;	author dcoppa;	state Exp;
branches;
next	1.9;
commitid	qXwIGV2h9uFjxAmt;

1.9
date	2014.12.26.17.52.35;	author dcoppa;	state Exp;
branches;
next	1.8;
commitid	gwhRExMduYqoPQHI;

1.8
date	2014.01.12.15.08.27;	author matthieu;	state Exp;
branches
	1.8.2.1
	1.8.4.1;
next	1.7;

1.7
date	2013.10.10.19.49.49;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.21.09;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.04.14.09.45.47;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.10.20.28.35;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.21.05.09.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.40;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.40;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.33.02;	author matthieu;	state Exp;
branches;
next	;

1.8.2.1
date	2015.03.11.19.50.48;	author tedu;	state Exp;
branches;
next	;
commitid	gSxuITleqkyrLFtk;

1.8.4.1
date	2015.03.11.19.50.16;	author tedu;	state Exp;
branches;
next	;
commitid	DBjn1kYKEwrb9ob6;


desc
@@


1.15
log
@
Update to freetype-2.8

No fallout in a bulk build on i386 (sthen@@)

OK matthieu@@, sthen@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftmac.c                                                                */
/*                                                                         */
/*    Mac FOND support.  Written by just@@letterror.com.                    */
/*  Heavily modified by mpsuzuki, George Williams, and Sean McBride.       */
/*                                                                         */
/*  This file is for Mac OS X only; see builds/mac/ftoldmac.c for          */
/*  classic platforms built by MPW.                                        */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  Just van Rossum, David Turner, Robert Wilhelm, and Werner Lemberg.     */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*
    Notes

    Mac suitcase files can (and often do!) contain multiple fonts.  To
    support this I use the face_index argument of FT_(Open|New)_Face()
    functions, and pretend the suitcase file is a collection.

    Warning: fbit and NFNT bitmap resources are not supported yet.  In old
    sfnt fonts, bitmap glyph data for each size is stored in each `NFNT'
    resources instead of the `bdat' table in the sfnt resource.  Therefore,
    face->num_fixed_sizes is set to 0, because bitmap data in `NFNT'
    resource is unavailable at present.

    The Mac FOND support works roughly like this:

    - Check whether the offered stream points to a Mac suitcase file.  This
      is done by checking the file type: it has to be 'FFIL' or 'tfil'.  The
      stream that gets passed to our init_face() routine is a stdio stream,
      which isn't usable for us, since the FOND resources live in the
      resource fork.  So we just grab the stream->pathname field.

    - Read the FOND resource into memory, then check whether there is a
      TrueType font and/or(!) a Type 1 font available.

    - If there is a Type 1 font available (as a separate `LWFN' file), read
      its data into memory, massage it slightly so it becomes PFB data, wrap
      it into a memory stream, load the Type 1 driver and delegate the rest
      of the work to it by calling FT_Open_Face().  (XXX TODO: after this
      has been done, the kerning data from the FOND resource should be
      appended to the face: On the Mac there are usually no AFM files
      available.  However, this is tricky since we need to map Mac char
      codes to ps glyph names to glyph ID's...)

    - If there is a TrueType font (an `sfnt' resource), read it into memory,
      wrap it into a memory stream, load the TrueType driver and delegate
      the rest of the work to it, by calling FT_Open_Face().

    - Some suitcase fonts (notably Onyx) might point the `LWFN' file to
      itself, even though it doesn't contains `POST' resources.  To handle
      this special case without opening the file an extra time, we just
      ignore errors from the `LWFN' and fallback to the `sfnt' if both are
      available.
  */


#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_TRUETYPE_TAGS_H
#include FT_INTERNAL_STREAM_H
#include "ftbase.h"


#ifdef FT_MACINTOSH

  /* This is for Mac OS X.  Without redefinition, OS_INLINE */
  /* expands to `static inline' which doesn't survive the   */
  /* -ansi compilation flag of GCC.                         */
#if !HAVE_ANSI_OS_INLINE
#undef  OS_INLINE
#define OS_INLINE  static __inline__
#endif

  /* `configure' checks the availability of `ResourceIndex' strictly */
  /* and sets HAVE_TYPE_RESOURCE_INDEX 1 or 0 always.  If it is      */
  /* not set (e.g., a build without `configure'), the availability   */
  /* is guessed from the SDK version.                                */
#ifndef HAVE_TYPE_RESOURCE_INDEX
#if !defined( MAC_OS_X_VERSION_10_5 ) || \
    ( MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_5 )
#define HAVE_TYPE_RESOURCE_INDEX 0
#else
#define HAVE_TYPE_RESOURCE_INDEX 1
#endif
#endif /* !HAVE_TYPE_RESOURCE_INDEX */

#if ( HAVE_TYPE_RESOURCE_INDEX == 0 )
  typedef short  ResourceIndex;
#endif

#include <CoreServices/CoreServices.h>
#include <ApplicationServices/ApplicationServices.h>
#include <sys/syslimits.h> /* PATH_MAX */

  /* Don't want warnings about our own use of deprecated functions. */
#define FT_DEPRECATED_ATTRIBUTE

#include FT_MAC_H

#ifndef kATSOptionFlagsUnRestrictedScope /* since Mac OS X 10.1 */
#define kATSOptionFlagsUnRestrictedScope kATSOptionFlagsDefault
#endif


  /* Set PREFER_LWFN to 1 if LWFN (Type 1) is preferred over
     TrueType in case *both* are available (this is not common,
     but it *is* possible). */
#ifndef PREFER_LWFN
#define PREFER_LWFN  1
#endif


  /* This function is deprecated because FSSpec is deprecated in Mac OS X  */
  FT_EXPORT_DEF( FT_Error )
  FT_GetFile_From_Mac_Name( const char*  fontName,
                            FSSpec*      pathSpec,
                            FT_Long*     face_index )
  {
    FT_UNUSED( fontName );
    FT_UNUSED( pathSpec );
    FT_UNUSED( face_index );

    return FT_THROW( Unimplemented_Feature );
  }


  /* Private function.                                         */
  /* The FSSpec type has been discouraged for a long time,     */
  /* unfortunately an FSRef replacement API for                */
  /* ATSFontGetFileSpecification() is only available in        */
  /* Mac OS X 10.5 and later.                                  */
  static OSStatus
  FT_ATSFontGetFileReference( ATSFontRef  ats_font_id,
                              FSRef*      ats_font_ref )
  {
#if defined( MAC_OS_X_VERSION_10_5 ) && \
    ( MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5 )

    OSStatus  err;

    err = ATSFontGetFileReference( ats_font_id, ats_font_ref );

    return err;
#elif __LP64__ /* No 64bit Carbon API on legacy platforms */
    FT_UNUSED( ats_font_id );
    FT_UNUSED( ats_font_ref );


    return fnfErr;
#else /* 32bit Carbon API on legacy platforms */
    OSStatus  err;
    FSSpec    spec;


    err = ATSFontGetFileSpecification( ats_font_id, &spec );
    if ( noErr == err )
      err = FSpMakeFSRef( &spec, ats_font_ref );

    return err;
#endif
  }


  static FT_Error
  FT_GetFileRef_From_Mac_ATS_Name( const char*  fontName,
                                   FSRef*       ats_font_ref,
                                   FT_Long*     face_index )
  {
    CFStringRef  cf_fontName;
    ATSFontRef   ats_font_id;


    *face_index = 0;

    cf_fontName = CFStringCreateWithCString( NULL, fontName,
                                             kCFStringEncodingMacRoman );
    ats_font_id = ATSFontFindFromName( cf_fontName,
                                       kATSOptionFlagsUnRestrictedScope );
    CFRelease( cf_fontName );

    if ( ats_font_id == 0 || ats_font_id == 0xFFFFFFFFUL )
      return FT_THROW( Unknown_File_Format );

    if ( noErr != FT_ATSFontGetFileReference( ats_font_id, ats_font_ref ) )
      return FT_THROW( Unknown_File_Format );

    /* face_index calculation by searching preceding fontIDs */
    /* with same FSRef                                       */
    {
      ATSFontRef  id2 = ats_font_id - 1;
      FSRef       ref2;


      while ( id2 > 0 )
      {
        if ( noErr != FT_ATSFontGetFileReference( id2, &ref2 ) )
          break;
        if ( noErr != FSCompareFSRefs( ats_font_ref, &ref2 ) )
          break;

        id2 --;
      }
      *face_index = ats_font_id - ( id2 + 1 );
    }

    return FT_Err_Ok;
  }


  FT_EXPORT_DEF( FT_Error )
  FT_GetFilePath_From_Mac_ATS_Name( const char*  fontName,
                                    UInt8*       path,
                                    UInt32       maxPathSize,
                                    FT_Long*     face_index )
  {
    FSRef     ref;
    FT_Error  err;


    if ( !fontName || !face_index )
      return FT_THROW( Invalid_Argument);

    err = FT_GetFileRef_From_Mac_ATS_Name( fontName, &ref, face_index );
    if ( err )
      return err;

    if ( noErr != FSRefMakePath( &ref, path, maxPathSize ) )
      return FT_THROW( Unknown_File_Format );

    return FT_Err_Ok;
  }


  /* This function is deprecated because FSSpec is deprecated in Mac OS X  */
  FT_EXPORT_DEF( FT_Error )
  FT_GetFile_From_Mac_ATS_Name( const char*  fontName,
                                FSSpec*      pathSpec,
                                FT_Long*     face_index )
  {
#if ( __LP64__ ) || ( defined( MAC_OS_X_VERSION_10_5 ) && \
      ( MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5 ) )
    FT_UNUSED( fontName );
    FT_UNUSED( pathSpec );
    FT_UNUSED( face_index );

    return FT_THROW( Unimplemented_Feature );
#else
    FSRef     ref;
    FT_Error  err;


    if ( !fontName || !face_index )
      return FT_THROW( Invalid_Argument );

    err = FT_GetFileRef_From_Mac_ATS_Name( fontName, &ref, face_index );
    if ( err )
      return err;

    if ( noErr != FSGetCatalogInfo( &ref, kFSCatInfoNone, NULL, NULL,
                                    pathSpec, NULL ) )
      return FT_THROW( Unknown_File_Format );

    return FT_Err_Ok;
#endif
  }


  static OSErr
  FT_FSPathMakeRes( const UInt8*    pathname,
                    ResFileRefNum*  res )
  {
    OSErr  err;
    FSRef  ref;


    if ( noErr != FSPathMakeRef( pathname, &ref, FALSE ) )
      return FT_THROW( Cannot_Open_Resource );

    /* at present, no support for dfont format */
    err = FSOpenResourceFile( &ref, 0, NULL, fsRdPerm, res );
    if ( noErr == err )
      return err;

    /* fallback to original resource-fork font */
    *res = FSOpenResFile( &ref, fsRdPerm );
    err  = ResError();

    return err;
  }


  /* Return the file type for given pathname */
  static OSType
  get_file_type_from_path( const UInt8*  pathname )
  {
    FSRef          ref;
    FSCatalogInfo  info;


    if ( noErr != FSPathMakeRef( pathname, &ref, FALSE ) )
      return ( OSType ) 0;

    if ( noErr != FSGetCatalogInfo( &ref, kFSCatInfoFinderInfo, &info,
                                    NULL, NULL, NULL ) )
      return ( OSType ) 0;

    return ((FInfo *)(info.finderInfo))->fdType;
  }


  /* Given a PostScript font name, create the Macintosh LWFN file name. */
  static void
  create_lwfn_name( char*   ps_name,
                    Str255  lwfn_file_name )
  {
    int       max = 5, count = 0;
    FT_Byte*  p = lwfn_file_name;
    FT_Byte*  q = (FT_Byte*)ps_name;


    lwfn_file_name[0] = 0;

    while ( *q )
    {
      if ( ft_isupper( *q ) )
      {
        if ( count )
          max = 3;
        count = 0;
      }
      if ( count < max && ( ft_isalnum( *q ) || *q == '_' ) )
      {
        *++p = *q;
        lwfn_file_name[0]++;
        count++;
      }
      q++;
    }
  }


  static short
  count_faces_sfnt( char*  fond_data )
  {
    /* The count is 1 greater than the value in the FOND.  */
    /* Isn't that cute? :-)                                */

    return EndianS16_BtoN( *( (short*)( fond_data +
                                        sizeof ( FamRec ) ) ) ) + 1;
  }


  static short
  count_faces_scalable( char*  fond_data )
  {
    AsscEntry*  assoc;
    short       i, face, face_all;


    face_all = EndianS16_BtoN( *( (short *)( fond_data +
                                             sizeof ( FamRec ) ) ) ) + 1;
    assoc    = (AsscEntry*)( fond_data + sizeof ( FamRec ) + 2 );
    face     = 0;

    for ( i = 0; i < face_all; i++ )
    {
      if ( 0 == EndianS16_BtoN( assoc[i].fontSize ) )
        face++;
    }
    return face;
  }


  /* Look inside the FOND data, answer whether there should be an SFNT
     resource, and answer the name of a possible LWFN Type 1 file.

     Thanks to Paul Miller (paulm@@profoundeffects.com) for the fix
     to load a face OTHER than the first one in the FOND!
  */


  static void
  parse_fond( char*   fond_data,
              short*  have_sfnt,
              ResID*  sfnt_id,
              Str255  lwfn_file_name,
              short   face_index )
  {
    AsscEntry*  assoc;
    AsscEntry*  base_assoc;
    FamRec*     fond;


    *sfnt_id          = 0;
    *have_sfnt        = 0;
    lwfn_file_name[0] = 0;

    fond       = (FamRec*)fond_data;
    assoc      = (AsscEntry*)( fond_data + sizeof ( FamRec ) + 2 );
    base_assoc = assoc;

    /* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */
    if ( 47 < face_index )
      return;

    /* Let's do a little range checking before we get too excited here */
    if ( face_index < count_faces_sfnt( fond_data ) )
    {
      assoc += face_index;        /* add on the face_index! */

      /* if the face at this index is not scalable,
         fall back to the first one (old behavior) */
      if ( EndianS16_BtoN( assoc->fontSize ) == 0 )
      {
        *have_sfnt = 1;
        *sfnt_id   = EndianS16_BtoN( assoc->fontID );
      }
      else if ( base_assoc->fontSize == 0 )
      {
        *have_sfnt = 1;
        *sfnt_id   = EndianS16_BtoN( base_assoc->fontID );
      }
    }

    if ( EndianS32_BtoN( fond->ffStylOff ) )
    {
      unsigned char*  p = (unsigned char*)fond_data;
      StyleTable*     style;
      unsigned short  string_count;
      char            ps_name[256];
      unsigned char*  names[64];
      int             i;


      p += EndianS32_BtoN( fond->ffStylOff );
      style = (StyleTable*)p;
      p += sizeof ( StyleTable );
      string_count = EndianS16_BtoN( *(short*)(p) );
      string_count = FT_MIN( 64, string_count );
      p += sizeof ( short );

      for ( i = 0; i < string_count; i++ )
      {
        names[i] = p;
        p       += names[i][0];
        p++;
      }

      {
        size_t  ps_name_len = (size_t)names[0][0];


        if ( ps_name_len != 0 )
        {
          ft_memcpy(ps_name, names[0] + 1, ps_name_len);
          ps_name[ps_name_len] = 0;
        }
        if ( style->indexes[face_index] > 1 &&
             style->indexes[face_index] <= string_count )
        {
          unsigned char*  suffixes = names[style->indexes[face_index] - 1];


          for ( i = 1; i <= suffixes[0]; i++ )
          {
            unsigned char*  s;
            size_t          j = suffixes[i] - 1;


            if ( j < string_count && ( s = names[j] ) != NULL )
            {
              size_t  s_len = (size_t)s[0];


              if ( s_len != 0 && ps_name_len + s_len < sizeof ( ps_name ) )
              {
                ft_memcpy( ps_name + ps_name_len, s + 1, s_len );
                ps_name_len += s_len;
                ps_name[ps_name_len] = 0;
              }
            }
          }
        }
      }

      create_lwfn_name( ps_name, lwfn_file_name );
    }
  }


  static  FT_Error
  lookup_lwfn_by_fond( const UInt8*      path_fond,
                       ConstStr255Param  base_lwfn,
                       UInt8*            path_lwfn,
                       size_t            path_size )
  {
    FSRef   ref, par_ref;
    size_t  dirname_len;


    /* Pathname for FSRef can be in various formats: HFS, HFS+, and POSIX. */
    /* We should not extract parent directory by string manipulation.      */

    if ( noErr != FSPathMakeRef( path_fond, &ref, FALSE ) )
      return FT_THROW( Invalid_Argument );

    if ( noErr != FSGetCatalogInfo( &ref, kFSCatInfoNone,
                                    NULL, NULL, NULL, &par_ref ) )
      return FT_THROW( Invalid_Argument );

    if ( noErr != FSRefMakePath( &par_ref, path_lwfn, path_size ) )
      return FT_THROW( Invalid_Argument );

    if ( ft_strlen( (char *)path_lwfn ) + 1 + base_lwfn[0] > path_size )
      return FT_THROW( Invalid_Argument );

    /* now we have absolute dirname in path_lwfn */
    ft_strcat( (char *)path_lwfn, "/" );
    dirname_len = ft_strlen( (char *)path_lwfn );
    ft_strcat( (char *)path_lwfn, (char *)base_lwfn + 1 );
    path_lwfn[dirname_len + base_lwfn[0]] = '\0';

    if ( noErr != FSPathMakeRef( path_lwfn, &ref, FALSE ) )
      return FT_THROW( Cannot_Open_Resource );

    if ( noErr != FSGetCatalogInfo( &ref, kFSCatInfoNone,
                                    NULL, NULL, NULL, NULL ) )
      return FT_THROW( Cannot_Open_Resource );

    return FT_Err_Ok;
  }


  static short
  count_faces( Handle        fond,
               const UInt8*  pathname )
  {
    ResID     sfnt_id;
    short     have_sfnt, have_lwfn;
    Str255    lwfn_file_name;
    UInt8     buff[PATH_MAX];
    FT_Error  err;
    short     num_faces;


    have_sfnt = have_lwfn = 0;

    parse_fond( *fond, &have_sfnt, &sfnt_id, lwfn_file_name, 0 );

    if ( lwfn_file_name[0] )
    {
      err = lookup_lwfn_by_fond( pathname, lwfn_file_name,
                                 buff, sizeof ( buff )  );
      if ( !err )
        have_lwfn = 1;
    }

    if ( have_lwfn && ( !have_sfnt || PREFER_LWFN ) )
      num_faces = 1;
    else
      num_faces = count_faces_scalable( *fond );

    return num_faces;
  }


  /* Read Type 1 data from the POST resources inside the LWFN file,
     return a PFB buffer.  This is somewhat convoluted because the FT2
     PFB parser wants the ASCII header as one chunk, and the LWFN
     chunks are often not organized that way, so we glue chunks
     of the same type together. */
  static FT_Error
  read_lwfn( FT_Memory      memory,
             ResFileRefNum  res,
             FT_Byte**      pfb_data,
             FT_ULong*      size )
  {
    FT_Error       error = FT_Err_Ok;
    ResID          res_id;
    unsigned char  *buffer, *p, *size_p = NULL;
    FT_ULong       total_size = 0;
    FT_ULong       old_total_size = 0;
    FT_ULong       post_size, pfb_chunk_size;
    Handle         post_data;
    char           code, last_code;


    UseResFile( res );

    /* First pass: load all POST resources, and determine the size of */
    /* the output buffer.                                             */
    res_id    = 501;
    last_code = -1;

    for (;;)
    {
      post_data = Get1Resource( TTAG_POST, res_id++ );
      if ( !post_data )
        break;  /* we are done */

      code = (*post_data)[0];

      if ( code != last_code )
      {
        if ( code == 5 )
          total_size += 2; /* just the end code */
        else
          total_size += 6; /* code + 4 bytes chunk length */
      }

      total_size += (FT_ULong)GetHandleSize( post_data ) - 2;
      last_code = code;

      /* detect resource fork overflow */
      if ( FT_MAC_RFORK_MAX_LEN < total_size )
      {
        error = FT_THROW( Array_Too_Large );
        goto Error;
      }

      old_total_size = total_size;
    }

    if ( FT_ALLOC( buffer, (FT_Long)total_size ) )
      goto Error;

    /* Second pass: append all POST data to the buffer, add PFB fields. */
    /* Glue all consecutive chunks of the same type together.           */
    p              = buffer;
    res_id         = 501;
    last_code      = -1;
    pfb_chunk_size = 0;

    for (;;)
    {
      post_data = Get1Resource( TTAG_POST, res_id++ );
      if ( !post_data )
        break;  /* we are done */

      post_size = (FT_ULong)GetHandleSize( post_data ) - 2;
      code = (*post_data)[0];

      if ( code != last_code )
      {
        if ( last_code != -1 )
        {
          /* we are done adding a chunk, fill in the size field */
          if ( size_p )
          {
            *size_p++ = (FT_Byte)(   pfb_chunk_size         & 0xFF );
            *size_p++ = (FT_Byte)( ( pfb_chunk_size >> 8  ) & 0xFF );
            *size_p++ = (FT_Byte)( ( pfb_chunk_size >> 16 ) & 0xFF );
            *size_p++ = (FT_Byte)( ( pfb_chunk_size >> 24 ) & 0xFF );
          }
          pfb_chunk_size = 0;
        }

        *p++ = 0x80;
        if ( code == 5 )
          *p++ = 0x03;  /* the end */
        else if ( code == 2 )
          *p++ = 0x02;  /* binary segment */
        else
          *p++ = 0x01;  /* ASCII segment */

        if ( code != 5 )
        {
          size_p = p;   /* save for later */
          p += 4;       /* make space for size field */
        }
      }

      ft_memcpy( p, *post_data + 2, post_size );
      pfb_chunk_size += post_size;
      p += post_size;
      last_code = code;
    }

    *pfb_data = buffer;
    *size = total_size;

  Error:
    CloseResFile( res );
    return error;
  }


  /* Create a new FT_Face from a file path to an LWFN file. */
  static FT_Error
  FT_New_Face_From_LWFN( FT_Library    library,
                         const UInt8*  pathname,
                         FT_Long       face_index,
                         FT_Face*      aface )
  {
    FT_Byte*       pfb_data;
    FT_ULong       pfb_size;
    FT_Error       error;
    ResFileRefNum  res;


    if ( noErr != FT_FSPathMakeRes( pathname, &res ) )
      return FT_THROW( Cannot_Open_Resource );

    pfb_data = NULL;
    pfb_size = 0;
    error = read_lwfn( library->memory, res, &pfb_data, &pfb_size );
    CloseResFile( res ); /* PFB is already loaded, useless anymore */
    if ( error )
      return error;

    return open_face_from_buffer( library,
                                  pfb_data,
                                  pfb_size,
                                  face_index,
                                  "type1",
                                  aface );
  }


  /* Create a new FT_Face from an SFNT resource, specified by res ID. */
  static FT_Error
  FT_New_Face_From_SFNT( FT_Library  library,
                         ResID       sfnt_id,
                         FT_Long     face_index,
                         FT_Face*    aface )
  {
    Handle     sfnt = NULL;
    FT_Byte*   sfnt_data;
    size_t     sfnt_size;
    FT_Error   error  = FT_Err_Ok;
    FT_Memory  memory = library->memory;
    int        is_cff, is_sfnt_ps;


    sfnt = GetResource( TTAG_sfnt, sfnt_id );
    if ( !sfnt )
      return FT_THROW( Invalid_Handle );

    sfnt_size = (FT_ULong)GetHandleSize( sfnt );

    /* detect resource fork overflow */
    if ( FT_MAC_RFORK_MAX_LEN < sfnt_size )
      return FT_THROW( Array_Too_Large );

    if ( FT_ALLOC( sfnt_data, (FT_Long)sfnt_size ) )
    {
      ReleaseResource( sfnt );
      return error;
    }

    ft_memcpy( sfnt_data, *sfnt, sfnt_size );
    ReleaseResource( sfnt );

    is_cff     = sfnt_size > 4 && !ft_memcmp( sfnt_data, "OTTO", 4 );
    is_sfnt_ps = sfnt_size > 4 && !ft_memcmp( sfnt_data, "typ1", 4 );

    if ( is_sfnt_ps )
    {
      FT_Stream  stream;


      if ( FT_NEW( stream ) )
        goto Try_OpenType;

      FT_Stream_OpenMemory( stream, sfnt_data, sfnt_size );
      if ( !open_face_PS_from_sfnt_stream( library,
                                           stream,
                                           face_index,
                                           0, NULL,
                                           aface ) )
      {
        FT_Stream_Close( stream );
        FT_FREE( stream );
        FT_FREE( sfnt_data );
        goto Exit;
      }

      FT_FREE( stream );
    }
  Try_OpenType:
    error = open_face_from_buffer( library,
                                   sfnt_data,
                                   sfnt_size,
                                   face_index,
                                   is_cff ? "cff" : "truetype",
                                   aface );
  Exit:
    return error;
  }


  /* Create a new FT_Face from a file path to a suitcase file. */
  static FT_Error
  FT_New_Face_From_Suitcase( FT_Library    library,
                             const UInt8*  pathname,
                             FT_Long       face_index,
                             FT_Face*      aface )
  {
    FT_Error       error = FT_ERR( Cannot_Open_Resource );
    ResFileRefNum  res_ref;
    ResourceIndex  res_index;
    Handle         fond;
    short          num_faces_in_res;


    if ( noErr != FT_FSPathMakeRes( pathname, &res_ref ) )
      return FT_THROW( Cannot_Open_Resource );

    UseResFile( res_ref );
    if ( ResError() )
      return FT_THROW( Cannot_Open_Resource );

    num_faces_in_res = 0;
    for ( res_index = 1; ; res_index++ )
    {
      short  num_faces_in_fond;


      fond = Get1IndResource( TTAG_FOND, res_index );
      if ( ResError() )
        break;

      num_faces_in_fond  = count_faces( fond, pathname );
      num_faces_in_res  += num_faces_in_fond;

      if ( 0 <= face_index && face_index < num_faces_in_fond && error )
        error = FT_New_Face_From_FOND( library, fond, face_index, aface );

      face_index -= num_faces_in_fond;
    }

    CloseResFile( res_ref );
    if ( !error && aface && *aface )
      (*aface)->num_faces = num_faces_in_res;
    return error;
  }


  /* documentation is in ftmac.h */

  FT_EXPORT_DEF( FT_Error )
  FT_New_Face_From_FOND( FT_Library  library,
                         Handle      fond,
                         FT_Long     face_index,
                         FT_Face*    aface )
  {
    short     have_sfnt, have_lwfn = 0;
    ResID     sfnt_id, fond_id;
    OSType    fond_type;
    Str255    fond_name;
    Str255    lwfn_file_name;
    UInt8     path_lwfn[PATH_MAX];
    OSErr     err;
    FT_Error  error = FT_Err_Ok;


    /* check of `library' and `aface' delayed to `FT_New_Face_From_XXX' */

    GetResInfo( fond, &fond_id, &fond_type, fond_name );
    if ( ResError() != noErr || fond_type != TTAG_FOND )
      return FT_THROW( Invalid_File_Format );

    parse_fond( *fond, &have_sfnt, &sfnt_id, lwfn_file_name, face_index );

    if ( lwfn_file_name[0] )
    {
      ResFileRefNum  res;


      res = HomeResFile( fond );
      if ( noErr != ResError() )
        goto found_no_lwfn_file;

      {
        UInt8  path_fond[PATH_MAX];
        FSRef  ref;


        err = FSGetForkCBInfo( res, kFSInvalidVolumeRefNum,
                               NULL, NULL, NULL, &ref, NULL );
        if ( noErr != err )
          goto found_no_lwfn_file;

        err = FSRefMakePath( &ref, path_fond, sizeof ( path_fond ) );
        if ( noErr != err )
          goto found_no_lwfn_file;

        error = lookup_lwfn_by_fond( path_fond, lwfn_file_name,
                                     path_lwfn, sizeof ( path_lwfn ) );
        if ( !error )
          have_lwfn = 1;
      }
    }

    if ( have_lwfn && ( !have_sfnt || PREFER_LWFN ) )
      error = FT_New_Face_From_LWFN( library,
                                     path_lwfn,
                                     face_index,
                                     aface );
    else
      error = FT_THROW( Unknown_File_Format );

  found_no_lwfn_file:
    if ( have_sfnt && error )
      error = FT_New_Face_From_SFNT( library,
                                     sfnt_id,
                                     face_index,
                                     aface );

    return error;
  }


  /* Common function to load a new FT_Face from a resource file. */
  static FT_Error
  FT_New_Face_From_Resource( FT_Library    library,
                             const UInt8*  pathname,
                             FT_Long       face_index,
                             FT_Face*      aface )
  {
    OSType    file_type;
    FT_Error  error;


    /* LWFN is a (very) specific file format, check for it explicitly */
    file_type = get_file_type_from_path( pathname );
    if ( file_type == TTAG_LWFN )
      return FT_New_Face_From_LWFN( library, pathname, face_index, aface );

    /* Otherwise the file type doesn't matter (there are more than  */
    /* `FFIL' and `tfil').  Just try opening it as a font suitcase; */
    /* if it works, fine.                                           */

    error = FT_New_Face_From_Suitcase( library, pathname, face_index, aface );
    if ( error )
    {
      /* let it fall through to normal loader (.ttf, .otf, etc.); */
      /* we signal this by returning no error and no FT_Face      */
      *aface = NULL;
    }

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_New_Face                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This is the Mac-specific implementation of FT_New_Face.  In        */
  /*    addition to the standard FT_New_Face() functionality, it also      */
  /*    accepts pathnames to Mac suitcase files.  For further              */
  /*    documentation see the original FT_New_Face() in freetype.h.        */
  /*                                                                       */
  FT_EXPORT_DEF( FT_Error )
  FT_New_Face( FT_Library   library,
               const char*  pathname,
               FT_Long      face_index,
               FT_Face*     aface )
  {
    FT_Open_Args  args;
    FT_Error      error;


    /* test for valid `library' and `aface' delayed to FT_Open_Face() */
    if ( !pathname )
      return FT_THROW( Invalid_Argument );

    *aface = NULL;

    /* try resourcefork based font: LWFN, FFIL */
    error = FT_New_Face_From_Resource( library, (UInt8 *)pathname,
                                       face_index, aface );
    if ( error || *aface )
      return error;

    /* let it fall through to normal loader (.ttf, .otf, etc.) */
    args.flags    = FT_OPEN_PATHNAME;
    args.pathname = (char*)pathname;

    return FT_Open_Face( library, &args, face_index, aface );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_New_Face_From_FSRef                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    FT_New_Face_From_FSRef is identical to FT_New_Face except it       */
  /*    accepts an FSRef instead of a path.                                */
  /*                                                                       */
  /* This function is deprecated because Carbon data types (FSRef)         */
  /* are not cross-platform, and thus not suitable for the freetype API.   */
  FT_EXPORT_DEF( FT_Error )
  FT_New_Face_From_FSRef( FT_Library    library,
                          const FSRef*  ref,
                          FT_Long       face_index,
                          FT_Face*      aface )
  {
    FT_Error      error;
    FT_Open_Args  args;

    OSErr  err;
    UInt8  pathname[PATH_MAX];


    /* check of `library' and `aface' delayed to */
    /* `FT_New_Face_From_Resource'               */

    if ( !ref )
      return FT_THROW( Invalid_Argument );

    err = FSRefMakePath( ref, pathname, sizeof ( pathname ) );
    if ( err )
      error = FT_THROW( Cannot_Open_Resource );

    error = FT_New_Face_From_Resource( library, pathname, face_index, aface );
    if ( error || *aface )
      return error;

    /* fallback to datafork font */
    args.flags    = FT_OPEN_PATHNAME;
    args.pathname = (char*)pathname;
    return FT_Open_Face( library, &args, face_index, aface );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_New_Face_From_FSSpec                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    FT_New_Face_From_FSSpec is identical to FT_New_Face except it      */
  /*    accepts an FSSpec instead of a path.                               */
  /*                                                                       */
  /* This function is deprecated because FSSpec is deprecated in Mac OS X  */
  FT_EXPORT_DEF( FT_Error )
  FT_New_Face_From_FSSpec( FT_Library     library,
                           const FSSpec*  spec,
                           FT_Long        face_index,
                           FT_Face*       aface )
  {
#if ( __LP64__ ) || ( defined( MAC_OS_X_VERSION_10_5 ) && \
      ( MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5 ) )
    FT_UNUSED( library );
    FT_UNUSED( spec );
    FT_UNUSED( face_index );
    FT_UNUSED( aface );

    return FT_THROW( Unimplemented_Feature );
#else
    FSRef  ref;


    /* check of `library' and `aface' delayed to `FT_New_Face_From_FSRef' */

    if ( !spec || FSpMakeFSRef( spec, &ref ) != noErr )
      return FT_THROW( Invalid_Argument );
    else
      return FT_New_Face_From_FSRef( library, &ref, face_index, aface );
#endif
  }

#else /* !FT_MACINTOSH */

  /* ANSI C doesn't like empty source files */
  typedef int  _ft_mac_dummy;

#endif /* !FT_MACINTOSH */


/* END */
@


1.14
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@d11 1
a11 1
/*  Copyright 1996-2016 by                                                 */
d74 3
a123 2
#ifdef FT_MACINTOSH

d1080 6
a1085 1
#endif /* FT_MACINTOSH */
@


1.13
log
@
Update to FreeType 2.6.5

ok matthieu@@
@
text
@d608 1
a608 1
      if ( post_data == NULL )
d647 1
a647 1
      if ( post_data == NULL )
d658 1
a658 1
          if ( size_p != NULL )
d746 1
a746 1
    if ( sfnt == NULL )
d824 1
a824 1
    for ( res_index = 1; ; ++res_index )
d945 6
a950 2
    if ( error == 0 )
      return error;
d952 1
a952 4
    /* let it fall through to normal loader (.ttf, .otf, etc.); */
    /* we signal this by returning no error and no FT_Face      */
    *aface = NULL;
    return 0;
d986 1
a986 1
    if ( error != 0 || *aface != NULL )
d992 1
d1032 1
a1032 1
    if ( error != 0 || *aface != NULL )
@


1.12
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d231 1
a231 1
      return FT_THROW( Invalid_Argument) ;
@


1.11
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@d11 1
a11 1
/*  Copyright 1996-2015 by                                                 */
@


1.10
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d621 1
a621 1
      total_size += GetHandleSize( post_data ) - 2;
d624 2
a625 2
      /* detect integer overflows */
      if ( total_size < old_total_size )
d750 5
@


1.9
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d11 1
a11 1
/*  Copyright 1996-2009, 2013, 2014 by                                     */
@


1.8
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d11 1
a11 1
/*  Copyright 1996-2009, 2013 by                                           */
d230 3
d262 3
d449 1
d452 1
a452 1
      for ( i = 0; i < string_count && i < 64; i++ )
d469 1
a469 1
             style->indexes[face_index] <= FT_MIN( string_count, 64 ) )
d862 2
d1009 3
a1011 2
    OSErr   err;
    UInt8   pathname[PATH_MAX];
d1014 3
d1062 2
@


1.8.2.1
log
@backport fixes for malformed fonts from freetype 2.5.5.
fixes dug out of ubuntu by dcoppa@@
@
text
@a442 1
      string_count = FT_MIN( 64, string_count );
d445 1
a445 1
      for ( i = 0; i < string_count; i++ )
d462 1
a462 1
             style->indexes[face_index] <= string_count )
@


1.8.4.1
log
@backport fixes from freetype 2.5.5 for malformed fonts.
fixes dug out of ubuntu by dcoppa@@
@
text
@a442 1
      string_count = FT_MIN( 64, string_count );
d445 1
a445 1
      for ( i = 0; i < string_count; i++ )
d462 1
a462 1
             style->indexes[face_index] <= string_count )
@


1.7
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@a965 1
    error  = FT_Err_Ok;
@


1.6
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@a360 1
    FamRec*     fond;
a363 1
    fond     = (FamRec*)fond_data;
d801 1
a801 1
    short          num_faces_in_res, num_faces_in_fond;
d814 3
@


1.5
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@d11 1
a11 2
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,         */
/*            2009 by                                                      */
d133 1
a133 1
    return FT_Err_Unimplemented_Feature;
d192 1
a192 1
      return FT_Err_Unknown_File_Format;
d195 1
a195 1
      return FT_Err_Unknown_File_Format;
d231 1
a231 1
    if ( FT_Err_Ok != err )
d235 1
a235 1
      return FT_Err_Unknown_File_Format;
d253 1
a253 1
    return FT_Err_Unimplemented_Feature;
d260 1
a260 1
    if ( FT_Err_Ok != err )
d265 1
a265 1
      return FT_Err_Unknown_File_Format;
d281 1
a281 1
      return FT_Err_Cannot_Open_Resource;
d510 1
a510 1
      return FT_Err_Invalid_Argument;
d514 1
a514 1
      return FT_Err_Invalid_Argument;
d517 1
a517 1
      return FT_Err_Invalid_Argument;
d520 1
a520 1
      return FT_Err_Invalid_Argument;
d529 1
a529 1
      return FT_Err_Cannot_Open_Resource;
d533 1
a533 1
      return FT_Err_Cannot_Open_Resource;
d559 1
a559 1
      if ( FT_Err_Ok == err )
d622 1
a622 1
        error = FT_Err_Array_Too_Large;
d707 1
a707 1
      return FT_Err_Cannot_Open_Resource;
d742 1
a742 1
      return FT_Err_Invalid_Handle;
d799 1
a799 1
    FT_Error       error = FT_Err_Cannot_Open_Resource;
d807 1
a807 1
      return FT_Err_Cannot_Open_Resource;
d811 1
a811 1
      return FT_Err_Cannot_Open_Resource;
d830 1
a830 1
    if ( FT_Err_Ok == error && NULL != aface && NULL != *aface )
d856 1
a856 1
      return FT_Err_Invalid_File_Format;
d885 1
a885 1
        if ( FT_Err_Ok == error )
d896 1
a896 1
      error = FT_Err_Unknown_File_Format;
d899 1
a899 1
    if ( have_sfnt && FT_Err_Ok != error )
d963 1
a963 1
      return FT_Err_Invalid_Argument;
d1005 1
a1005 1
      return FT_Err_Invalid_Argument;
d1009 1
a1009 1
      error = FT_Err_Cannot_Open_Resource;
d1045 1
a1045 1
    return FT_Err_Unimplemented_Feature;
d1051 1
a1051 1
      return FT_Err_Invalid_Argument;
@


1.4
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d122 2
d149 1
a149 1
 
d1057 2
@


1.3
log
@Update to Freetype 2.3.7. This is a bug fix release. No API change.
@
text
@d11 2
a12 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d71 1
d73 1
d83 4
a86 1
  /* The ResourceIndex type was available SDKs on 10.5 */
d88 10
a97 1
typedef short ResourceIndex;
d104 1
a108 7
  /* undefine blocking-macros in ftmac.h */
#undef FT_GetFile_From_Mac_Name( a, b, c )
#undef FT_GetFile_From_Mac_ATS_Name( a, b, c )
#undef FT_New_Face_From_FOND( a, b, c, d )
#undef FT_New_Face_From_FSSpec( a, b, c, d )
#undef FT_New_Face_From_FSRef( a, b, c, d )

d601 1
a601 2
      post_data = Get1Resource( FT_MAKE_TAG( 'P', 'O', 'S', 'T' ),
                                res_id++ );
d640 1
a640 2
      post_data = Get1Resource( FT_MAKE_TAG( 'P', 'O', 'S', 'T' ),
                                res_id++ );
d692 1
a692 104
  /* Finalizer for a memory stream; gets called by FT_Done_Face().
     It frees the memory it uses. */
  static void
  memory_stream_close( FT_Stream  stream )
  {
    FT_Memory  memory = stream->memory;


    FT_FREE( stream->base );

    stream->size  = 0;
    stream->base  = 0;
    stream->close = 0;
  }


  /* Create a new memory stream from a buffer and a size. */
  static FT_Error
  new_memory_stream( FT_Library           library,
                     FT_Byte*             base,
                     FT_ULong             size,
                     FT_Stream_CloseFunc  close,
                     FT_Stream*           astream )
  {
    FT_Error   error;
    FT_Memory  memory;
    FT_Stream  stream;


    if ( !library )
      return FT_Err_Invalid_Library_Handle;

    if ( !base )
      return FT_Err_Invalid_Argument;

    *astream = 0;
    memory = library->memory;
    if ( FT_NEW( stream ) )
      goto Exit;

    FT_Stream_OpenMemory( stream, base, size );

    stream->close = close;

    *astream = stream;

  Exit:
    return error;
  }


  /* Create a new FT_Face given a buffer and a driver name. */
  static FT_Error
  open_face_from_buffer( FT_Library   library,
                         FT_Byte*     base,
                         FT_ULong     size,
                         FT_Long      face_index,
                         const char*  driver_name,
                         FT_Face*     aface )
  {
    FT_Open_Args  args;
    FT_Error      error;
    FT_Stream     stream;
    FT_Memory     memory = library->memory;


    error = new_memory_stream( library,
                               base,
                               size,
                               memory_stream_close,
                               &stream );
    if ( error )
    {
      FT_FREE( base );
      return error;
    }

    args.flags  = FT_OPEN_STREAM;
    args.stream = stream;
    if ( driver_name )
    {
      args.flags  = args.flags | FT_OPEN_DRIVER;
      args.driver = FT_Get_Module( library, driver_name );
    }

    /* At this point, face_index has served its purpose;      */
    /* whoever calls this function has already used it to     */
    /* locate the correct font data.  We should not propagate */
    /* this index to FT_Open_Face() (unless it is negative).  */

    if ( face_index > 0 )
      face_index = 0;

    error = FT_Open_Face( library, &args, face_index, aface );
    if ( error == FT_Err_Ok )
      (*aface)->face_flags &= ~FT_FACE_FLAG_EXTERNAL_STREAM;
    else
      FT_Stream_Free( stream, 0 );

    return error;
  }


  /* Create a new FT_Face from a file spec to an LWFN file. */
d736 1
a736 1
    int        is_cff;
d739 1
a739 1
    sfnt = GetResource( FT_MAKE_TAG( 's', 'f', 'n', 't' ), sfnt_id );
d753 23
a775 4
    is_cff = sfnt_size > 4 && sfnt_data[0] == 'O' &&
                              sfnt_data[1] == 'T' &&
                              sfnt_data[2] == 'T' &&
                              sfnt_data[3] == 'O';
d777 11
a787 6
    return open_face_from_buffer( library,
                                  sfnt_data,
                                  sfnt_size,
                                  face_index,
                                  is_cff ? "cff" : "truetype",
                                  aface );
d791 1
a791 1
  /* Create a new FT_Face from a file spec to a suitcase file. */
d815 1
a815 2
      fond = Get1IndResource( FT_MAKE_TAG( 'F', 'O', 'N', 'D' ),
                              res_index );
d854 1
a854 1
    if ( ResError() != noErr || fond_type != FT_MAKE_TAG( 'F', 'O', 'N', 'D' ) )
d921 1
a921 1
    if ( file_type == FT_MAKE_TAG( 'L', 'W', 'F', 'N' ) )
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d80 2
a81 2
  /* The ResourceIndex type was only added in the 10.5 SDK */
#ifndef MAC_OS_X_VERSION_10_5
d137 1
a137 1
    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5
d238 1
a238 1
      MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5 )
d1111 1
a1111 1
      MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5 )
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
/*  Heavily Fixed by mpsuzuki, George Williams and Sean McBride            */
d8 4
a11 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d59 6
a71 1
#if defined( __GNUC__ ) || defined( __IBMC__ )
d75 3
a77 8
#define OS_INLINE   static __inline__
#include <Carbon/Carbon.h>
#else
#include <Resources.h>
#include <Fonts.h>
#include <Errors.h>
#include <Files.h>
#include <TextUtils.h>
d80 3
a82 2
#if defined( __MWERKS__ ) && !TARGET_RT_MAC_MACHO
#include <FSp_fopen.h>
d85 3
a87 1
#include FT_MAC_H
d89 1
d91 1
a91 8
  /* FSSpec functions are deprecated since Mac OS X 10.4 */
#ifndef HAVE_FSSPEC
#if TARGET_API_MAC_OS8 || TARGET_API_MAC_CARBON
#define HAVE_FSSPEC  1
#else
#define HAVE_FSSPEC  0
#endif
#endif
d93 6
a98 8
  /* most FSRef functions were introduced since Mac OS 9 */
#ifndef HAVE_FSREF
#if TARGET_API_MAC_OSX
#define HAVE_FSREF  1
#else
#define HAVE_FSREF  0
#endif
#endif
d100 2
a101 2
#ifndef HFS_MAXPATHLEN
#define HFS_MAXPATHLEN  1024
a104 18
  /* QuickDraw is deprecated since Mac OS X 10.4 */
#ifndef HAVE_QUICKDRAW_CARBON
#if TARGET_API_MAC_OS8 || TARGET_API_MAC_CARBON
#define HAVE_QUICKDRAW_CARBON  1
#else
#define HAVE_QUICKDRAW_CARBON  0
#endif
#endif

  /* AppleTypeService is available since Mac OS X */
#ifndef HAVE_ATS
#if TARGET_API_MAC_OSX
#define HAVE_ATS  1
#else
#define HAVE_ATS  0
#endif
#endif

d113 1
a113 2
#if !HAVE_QUICKDRAW_CARBON  /* QuickDraw is deprecated since Mac OS X 10.4 */

d119 4
a125 1
#else
d127 13
a139 6
  FT_EXPORT_DEF( FT_Error )
  FT_GetFile_From_Mac_Name( const char*  fontName,
                            FSSpec*      pathSpec,
                            FT_Long*     face_index )
  {
    OptionBits            options = kFMUseGlobalScopeOption;
d141 1
a141 6
    FMFontFamilyIterator  famIter;
    OSStatus              status = FMCreateFontFamilyIterator( NULL, NULL,
                                                               options,
                                                               &famIter );
    FMFont                the_font = 0;
    FMFontFamily          family   = 0;
d143 4
a147 10
    *face_index = 0;
    while ( status == 0 && !the_font )
    {
      status = FMGetNextFontFamily( &famIter, &family );
      if ( status == 0 )
      {
        int                           stat2;
        FMFontFamilyInstanceIterator  instIter;
        Str255                        famNameStr;
        char                          famName[256];
d149 4
a153 3
        /* get the family name */
        FMGetFontFamilyName( family, famNameStr );
        CopyPascalStringToC( famNameStr, famName );
d155 3
a157 2
        /* iterate through the styles */
        FMCreateFontFamilyInstanceIterator( family, &instIter );
d159 2
a160 48
        *face_index = 0;
        stat2       = 0;

        while ( stat2 == 0 && !the_font )
        {
          FMFontStyle  style;
          FMFontSize   size;
          FMFont       font;


          stat2 = FMGetNextFontFamilyInstance( &instIter, &font,
                                               &style, &size );
          if ( stat2 == 0 && size == 0 )
          {
            char  fullName[256];


            /* build up a complete face name */
            ft_strcpy( fullName, famName );
            if ( style & bold )
              ft_strcat( fullName, " Bold" );
            if ( style & italic )
              ft_strcat( fullName, " Italic" );

            /* compare with the name we are looking for */
            if ( ft_strcmp( fullName, fontName ) == 0 )
            {
              /* found it! */
              the_font = font;
            }
            else
              ++(*face_index);
          }
        }

        FMDisposeFontFamilyInstanceIterator( &instIter );
      }
    }

    FMDisposeFontFamilyIterator( &famIter );

    if ( the_font )
    {
      FMGetFontContainer( the_font, pathSpec );
      return FT_Err_Ok;
    }
    else
      return FT_Err_Unknown_File_Format;
a162 1
#endif /* HAVE_QUICKDRAW_CARBON */
d164 4
a167 17

#if !HAVE_ATS

  FT_EXPORT_DEF( FT_Error )
  FT_GetFile_From_Mac_ATS_Name( const char*  fontName,
                                FSSpec*      pathSpec,
                                FT_Long*     face_index )
  {
    return FT_Err_Unimplemented_Feature;
  }

#else

  FT_EXPORT_DEF( FT_Error )
  FT_GetFile_From_Mac_ATS_Name( const char*  fontName,
                                FSSpec*      pathSpec,
                                FT_Long*     face_index )
d179 1
d184 1
a184 1
    if ( 0 != ATSFontGetFileSpecification( ats_font_id, pathSpec ) )
d190 2
a191 2
      int     i;
      FSSpec  f;
d194 1
a194 1
      for ( i = 1; i < ats_font_id; i++ )
d196 3
a198 8
        if ( 0 != ATSFontGetFileSpecification( ats_font_id - i,
                                               &f               ) ||
             f.vRefNum != pathSpec->vRefNum                       ||
             f.parID   != pathSpec->parID                         ||
             f.name[0] != pathSpec->name[0]                       ||
             0 != ft_strncmp( (char *)f.name + 1,
                              (char *)pathSpec->name + 1,
                              f.name[0]                           ) )
d200 2
d203 1
a203 1
      *face_index = ( i - 1 );
d205 1
a208 1
#endif /* HAVE_ATS */
d210 8
a218 1
#if defined( __MWERKS__ ) && !TARGET_RT_MAC_MACHO
d220 3
a222 1
#define STREAM_FILE( stream )  ( (FT_FILE*)stream->descriptor.pointer )
d224 2
d227 1
a227 8
  FT_CALLBACK_DEF( void )
  ft_FSp_stream_close( FT_Stream  stream )
  {
    ft_fclose( STREAM_FILE( stream ) );

    stream->descriptor.pointer = NULL;
    stream->size               = 0;
    stream->base               = 0;
d231 5
a235 5
  FT_CALLBACK_DEF( unsigned long )
  ft_FSp_stream_io( FT_Stream       stream,
                    unsigned long   offset,
                    unsigned char*  buffer,
                    unsigned long   count )
d237 5
a241 1
    FT_FILE*  file;
d243 4
a247 1
    file = STREAM_FILE( stream );
d249 3
a251 1
    ft_fseek( file, offset, SEEK_SET );
d253 3
a255 2
    return (unsigned long)ft_fread( buffer, 1, count, file );
  }
d257 2
a258 51
#endif  /* __MWERKS__ && !TARGET_RT_MAC_MACHO */


#if HAVE_FSSPEC && !HAVE_FSREF

  static OSErr
  FT_FSPathMakeSpec( const UInt8*  pathname,
                     FSSpec*       spec_p,
                     Boolean       isDirectory )
  {
    const char  *p, *q;
    short       vRefNum;
    long        dirID;
    Str255      nodeName;
    OSErr       err;


    p = q = (const char *)pathname;
    dirID   = 0;
    vRefNum = 0;

    while ( 1 )
    {
      q = p + FT_MIN( 255, ft_strlen( p ) );

      if ( q == p )
        return 0;

      if ( 255 < ft_strlen( (char *)pathname ) )
      {
        while ( p < q && *q != ':' )
          q--;
      }

      if ( p < q )
        *(char *)nodeName = q - p;
      else if ( ft_strlen( p ) < 256 )
        *(char *)nodeName = ft_strlen( p );
      else
        return errFSNameTooLong;

      ft_strncpy( (char *)nodeName + 1, (char *)p, *(char *)nodeName );
      err = FSMakeFSSpec( vRefNum, dirID, nodeName, spec_p );
      if ( err || '\0' == *q )
        return err;

      vRefNum = spec_p->vRefNum;
      dirID   = spec_p->parID;

      p = q;
    }
d263 2
a264 3
  FT_FSpMakePath( const FSSpec*  spec_p,
                  UInt8*         path,
                  UInt32         maxPathSize )
a265 43
    OSErr   err;
    FSSpec  spec = *spec_p;
    short   vRefNum;
    long    dirID;
    Str255  parDir_name;


    FT_MEM_SET( path, 0, maxPathSize );
    while ( 1 )
    {
      int             child_namelen = ft_strlen( (char *)path );
      unsigned char   node_namelen  = spec.name[0];
      unsigned char*  node_name     = spec.name + 1;


      if ( node_namelen + child_namelen > maxPathSize )
        return errFSNameTooLong;

      FT_MEM_MOVE( path + node_namelen + 1, path, child_namelen );
      FT_MEM_COPY( path, node_name, node_namelen );
      if ( child_namelen > 0 )
        path[node_namelen] = ':';

      vRefNum        = spec.vRefNum;
      dirID          = spec.parID;
      parDir_name[0] = '\0';
      err = FSMakeFSSpec( vRefNum, dirID, parDir_name, &spec );
      if ( noErr != err || dirID == spec.parID )
        break;
    }
    return noErr;
  }

#endif /* HAVE_FSSPEC && !HAVE_FSREF */


  static OSErr
  FT_FSPathMakeRes( const UInt8*  pathname,
                    short*        res )
  {

#if HAVE_FSREF

a281 16
#else

    OSErr   err;
    FSSpec  spec;


    if ( noErr != FT_FSPathMakeSpec( pathname, &spec, FALSE ) )
      return FT_Err_Cannot_Open_Resource;

    /* at present, no support for dfont format without FSRef */
    /* (see above), try original resource-fork font          */
    *res = FSpOpenResFile( &spec, fsRdPerm );
    err  = ResError();

#endif /* HAVE_FSREF */

a289 3

#if HAVE_FSREF

a301 17

#else

    FSSpec  spec;
    FInfo  finfo;


    if ( noErr != FT_FSPathMakeSpec( pathname, &spec, FALSE ) )
      return ( OSType ) 0;

    if ( noErr != FSpGetFInfo( &spec, &finfo ) )
      return ( OSType ) 0;

    return finfo.fdType;

#endif /* HAVE_FSREF */

d342 2
a343 1
    return 1 + *( (short*)( fond_data + sizeof ( FamRec ) ) );
d356 2
a357 1
    face_all = *( (short *)( fond_data + sizeof ( FamRec ) ) ) + 1;
d363 1
a363 1
      if ( 0 == assoc[i].fontSize )
d381 1
a381 1
              short*  sfnt_id,
d398 4
d409 1
a409 1
      if ( assoc->fontSize == 0 )
d412 1
a412 1
        *sfnt_id   = assoc->fontID;
d417 1
a417 1
        *sfnt_id   = base_assoc->fontID;
d421 1
a421 1
    if ( fond->ffStylOff )
d431 1
a431 1
      p += fond->ffStylOff;
d434 1
a434 1
      string_count = *(unsigned short*)(p);
d453 2
a454 1
        if ( style->indexes[0] > 1 )
d456 1
a456 1
          unsigned char*  suffixes = names[style->indexes[0] - 1];
d487 4
a490 4
  lookup_lwfn_by_fond( const UInt8*     path_fond,
                       const StringPtr  base_lwfn,
                       UInt8*           path_lwfn,
                       int              path_size )
d492 2
a493 5

#if HAVE_FSREF

    FSRef  ref, par_ref;
    int    dirname_len;
d512 2
a513 6
    /* now we have absolute dirname in lookup_path */
    if ( path_lwfn[0] == '/' )
      ft_strcat( (char *)path_lwfn, "/" );
    else
      ft_strcat( (char *)path_lwfn, ":" );

a525 38

#else

    int     i;
    FSSpec  spec;


    /* pathname for FSSpec is always HFS format */
    if ( ft_strlen( (char *)path_fond ) > path_size )
      return FT_Err_Invalid_Argument;

    ft_strcpy( (char *)path_lwfn, (char *)path_fond );

    i = ft_strlen( (char *)path_lwfn ) - 1;
    while ( i > 0 && ':' != path_lwfn[i] )
      i--;

    if ( i + 1 + base_lwfn[0] > path_size )
      return FT_Err_Invalid_Argument;

    if ( ':' == path_lwfn[i] )
    {
      ft_strcpy( (char *)path_lwfn + i + 1, (char *)base_lwfn + 1 );
      path_lwfn[i + 1 + base_lwfn[0]] = '\0';
    }
    else
    {
      ft_strcpy( (char *)path_lwfn, (char *)base_lwfn + 1 );
      path_lwfn[base_lwfn[0]] = '\0';
    }

    if ( noErr != FT_FSPathMakeSpec( path_lwfn, &spec, FALSE ) )
      return FT_Err_Cannot_Open_Resource;

    return FT_Err_Ok;

#endif /* HAVE_FSREF */

d533 1
a533 1
    short     sfnt_id;
d536 1
a536 1
    UInt8     buff[HFS_MAXPATHLEN];
d538 1
a542 1
    HLock( fond );
a543 1
    HUnlock( fond );
d554 1
a554 1
      return 1;
d556 3
a558 1
      return count_faces_scalable( *fond );
d568 4
a571 4
  read_lwfn( FT_Memory  memory,
             short      res,
             FT_Byte**  pfb_data,
             FT_ULong*  size )
d574 1
a574 1
    short          res_id;
d592 2
a593 1
      post_data = Get1Resource( 'POST', res_id++ );
d632 2
a633 1
      post_data = Get1Resource( 'POST', res_id++ );
d738 6
a743 6
  open_face_from_buffer( FT_Library  library,
                         FT_Byte*    base,
                         FT_ULong    size,
                         FT_Long     face_index,
                         char*       driver_name,
                         FT_Face*    aface )
d781 2
d795 4
a798 4
    FT_Byte*  pfb_data;
    FT_ULong  pfb_size;
    FT_Error  error;
    short     res;
d823 1
a823 1
                         short       sfnt_id,
d835 2
a836 2
    sfnt = GetResource( 'sfnt', sfnt_id );
    if ( ResError() )
a845 1
    HLock( sfnt );
a846 1
    HUnlock( sfnt );
d870 5
a874 4
    FT_Error  error = FT_Err_Cannot_Open_Resource;
    short     res_ref, res_index;
    Handle    fond;
    short     num_faces_in_res, num_faces_in_fond;
d887 2
a888 1
      fond = Get1IndResource( 'FOND', res_index );
d902 1
a902 1
    if ( FT_Err_Ok == error && NULL != aface )
d916 2
a917 2
    short     sfnt_id, have_sfnt, have_lwfn = 0;
    short     fond_id;
d921 1
a921 1
    UInt8     path_lwfn[HFS_MAXPATHLEN];
d923 1
a923 1
    FT_Error  error;
d927 1
a927 1
    if ( ResError() != noErr || fond_type != 'FOND' )
a929 1
    HLock( fond );
a930 1
    HUnlock( fond );
d934 1
a934 1
      short  res;
a940 2
#if HAVE_FSREF

d942 1
a942 1
        UInt8  path_fond[HFS_MAXPATHLEN];
a959 39

#elif HAVE_FSSPEC

      {
        UInt8     path_fond[HFS_MAXPATHLEN];
        FCBPBRec  pb;
        Str255    fond_file_name;
        FSSpec    spec;


        FT_MEM_SET( &spec, 0, sizeof ( FSSpec ) );
        FT_MEM_SET( &pb,   0, sizeof ( FCBPBRec ) );

        pb.ioNamePtr = fond_file_name;
        pb.ioVRefNum = 0;
        pb.ioRefNum  = res;
        pb.ioFCBIndx = 0;

        err = PBGetFCBInfoSync( &pb );
        if ( noErr != err )
          goto found_no_lwfn_file;

        err = FSMakeFSSpec( pb.ioFCBVRefNum, pb.ioFCBParID,
                            fond_file_name, &spec );
        if ( noErr != err )
          goto found_no_lwfn_file;

        err = FT_FSpMakePath( &spec, path_fond, sizeof ( path_fond ) );
        if ( noErr != err )
          goto found_no_lwfn_file;

        error = lookup_lwfn_by_fond( path_fond, lwfn_file_name,
                                     path_lwfn, sizeof ( path_lwfn ) );
        if ( FT_Err_Ok == error )
          have_lwfn = 1;
      }

#endif /* HAVE_FSREF, HAVE_FSSPEC */

d963 6
a968 4
      return FT_New_Face_From_LWFN( library,
                                    path_lwfn,
                                    face_index,
                                    aface );
d971 5
a975 5
    if ( have_sfnt )
      return FT_New_Face_From_SFNT( library,
                                    sfnt_id,
                                    face_index,
                                    aface );
d977 1
a977 1
    return FT_Err_Unknown_File_Format;
d994 1
a994 1
    if ( file_type == 'LWFN' )
d1062 2
a1069 7

#if !HAVE_FSREF

    return FT_Err_Unimplemented_Feature;

#else

d1073 1
a1073 1
    UInt8   pathname[HFS_MAXPATHLEN];
a1090 3

#endif /* HAVE_FSREF */

d1103 1
d1110 6
d1117 2
a1118 2
#if HAVE_FSREF

d1126 1
a1126 31

#elif HAVE_FSSPEC

    FT_Error      error;
    FT_Open_Args  args;
    OSErr         err;
    UInt8         pathname[HFS_MAXPATHLEN];


    if ( !spec )
      return FT_Err_Invalid_Argument;

    err = FT_FSpMakePath( spec, pathname, sizeof ( pathname ) );
    if ( err )
      error = FT_Err_Cannot_Open_Resource;

    error = FT_New_Face_From_Resource( library, pathname, face_index, aface );
    if ( error != 0 || *aface != NULL )
      return error;

    /* fallback to datafork font */
    args.flags    = FT_OPEN_PATHNAME;
    args.pathname = (char*)pathname;
    return FT_Open_Face( library, &args, face_index, aface );

#else

    return FT_Err_Unimplemented_Feature;

#endif /* HAVE_FSREF, HAVE_FSSPEC */

@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d6 1
a6 1
/*  Heavily modified by mpsuzuki, George Williams, and Sean McBride.       */
d8 1
a8 4
/*  This file is for Mac OS X only; see builds/mac/ftoldmac.c for          */
/*  classic platforms built by MPW.                                        */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
a55 6

    - Some suitcase fonts (notably Onyx) might point the `LWFN' file to
      itself, even though it doesn't contains `POST' resources.  To handle
      this special case without opening the file an extra time, we just
      ignore errors from the `LWFN' and fallback to the `sfnt' if both are
      available.
d63 1
d67 33
a99 3
#if !HAVE_ANSI_OS_INLINE
#undef  OS_INLINE
#define OS_INLINE  static __inline__
a100 1
#include <Carbon/Carbon.h>
a105 1
#define FT_DEPRECATED_ATTRIBUTE
d107 8
a114 6
#include FT_MAC_H

  /* undefine blocking-macros in ftmac.h */
#undef FT_GetFile_From_Mac_Name( a, b, c )
#undef FT_GetFile_From_Mac_ATS_Name( a, b, c )
#undef FT_New_Face_From_FSSpec( a, b, c, d )
d116 8
d133 2
a139 4
    FT_UNUSED( fontName );
    FT_UNUSED( pathSpec );
    FT_UNUSED( face_index );

d143 44
a187 12
  /* Private function.                                         */
  /* The FSSpec type has been discouraged for a long time,     */
  /* but for some reason, there is no FSRef version of         */
  /* ATSFontGetFileSpecification(), so we made our own.        */
  /* Apple will provide one eventually.                        */
  static OSStatus
  FT_ATSFontGetFileReference( ATSFontRef  ats_font_id,
                              FSRef*      ats_font_ref )
  {
#if __LP64__
    FT_UNUSED( ats_font_id );
    FT_UNUSED( ats_font_ref );
d189 41
a229 4
    return fnfErr;
#else
    OSStatus  err;
    FSSpec    spec;
d232 1
a232 3
    err = ATSFontGetFileSpecification( ats_font_id, &spec );
    if ( noErr == err )
      err = FSpMakeFSRef( &spec, ats_font_ref );
d234 6
a239 2
    return err;
#endif
d242 1
d244 4
a247 4
  static FT_Error
  FT_GetFileRef_From_Mac_ATS_Name( const char*  fontName,
                                   FSRef*       ats_font_ref,
                                   FT_Long*     face_index )
a258 1
    CFRelease( cf_fontName );
d263 1
a263 1
    if ( noErr != FT_ATSFontGetFileReference( ats_font_id, ats_font_ref ) )
d269 2
a270 2
      ATSFontRef  id2 = ats_font_id - 1;
      FSRef       ref2;
d273 1
a273 1
      while ( id2 > 0 )
d275 8
a282 1
        if ( noErr != FT_ATSFontGetFileReference( id2, &ref2 ) )
a283 4
        if ( noErr != FSCompareFSRefs( ats_font_ref, &ref2 ) )
          break;

        id2 --;
d285 1
a285 1
      *face_index = ats_font_id - ( id2 + 1 );
d287 15
d303 3
a305 1
    return FT_Err_Ok;
d309 5
a313 5
  FT_EXPORT_DEF( FT_Error )
  FT_GetFilePath_From_Mac_ATS_Name( const char*  fontName,
                                    UInt8*       path,
                                    UInt32       maxPathSize,
                                    FT_Long*     face_index )
d315 1
a315 2
    FSRef     ref;
    FT_Error  err;
d318 1
a318 3
    err = FT_GetFileRef_From_Mac_ATS_Name( fontName, &ref, face_index );
    if ( FT_Err_Ok != err )
      return err;
d320 1
a320 2
    if ( noErr != FSRefMakePath( &ref, path, maxPathSize ) )
      return FT_Err_Unknown_File_Format;
d322 1
a322 1
    return FT_Err_Ok;
d325 33
d359 14
a372 10
  /* This function is deprecated because FSSpec is deprecated in Mac OS X  */
  FT_EXPORT_DEF( FT_Error )
  FT_GetFile_From_Mac_ATS_Name( const char*  fontName,
                                FSSpec*      pathSpec,
                                FT_Long*     face_index )
  {
#if __LP64__
    FT_UNUSED( fontName );
    FT_UNUSED( pathSpec );
    FT_UNUSED( face_index );
d374 3
a376 4
    return FT_Err_Unimplemented_Feature;
#else
    FSRef     ref;
    FT_Error  err;
d379 10
a388 3
    err = FT_GetFileRef_From_Mac_ATS_Name( fontName, &ref, face_index );
    if ( FT_Err_Ok != err )
      return err;
a389 3
    if ( noErr != FSGetCatalogInfo( &ref, kFSCatInfoNone, NULL, NULL,
                                    pathSpec, NULL ) )
      return FT_Err_Unknown_File_Format;
d391 24
a414 2
    return FT_Err_Ok;
#endif
d417 2
d424 3
d443 16
d467 3
d482 17
d539 1
a539 2
    return EndianS16_BtoN( *( (short*)( fond_data +
                                        sizeof ( FamRec ) ) ) ) + 1;
d552 1
a552 2
    face_all = EndianS16_BtoN( *( (short *)( fond_data +
                                             sizeof ( FamRec ) ) ) ) + 1;
d558 1
a558 1
      if ( 0 == EndianS16_BtoN( assoc[i].fontSize ) )
d600 1
a600 1
      if ( EndianS16_BtoN( assoc->fontSize ) == 0 )
d603 1
a603 1
        *sfnt_id   = EndianS16_BtoN( assoc->fontID );
d608 1
a608 1
        *sfnt_id   = EndianS16_BtoN( base_assoc->fontID );
d612 1
a612 1
    if ( EndianS32_BtoN( fond->ffStylOff ) )
d622 1
a622 1
      p += EndianS32_BtoN( fond->ffStylOff );
d625 1
a625 1
      string_count = EndianS16_BtoN( *(short*)(p) );
d677 4
a680 4
  lookup_lwfn_by_fond( const UInt8*      path_fond,
                       ConstStr255Param  base_lwfn,
                       UInt8*            path_lwfn,
                       size_t            path_size )
d682 3
d705 6
a710 2
    /* now we have absolute dirname in path_lwfn */
    ft_strcat( (char *)path_lwfn, "/" );
d723 38
a772 1
    short     num_faces;
d777 1
d779 1
d790 1
a790 1
      num_faces = 1;
d792 1
a792 3
      num_faces = count_faces_scalable( *fond );

    return num_faces;
a1012 2
    else
      FT_Stream_Free( stream, 0 );
d1076 1
d1078 1
d1153 1
a1153 1
    FT_Error  error = FT_Err_Ok;
d1160 1
d1162 1
d1173 2
d1194 39
d1236 4
a1239 6
      error = FT_New_Face_From_LWFN( library,
                                     path_lwfn,
                                     face_index,
                                     aface );
    else
      error = FT_Err_Unknown_File_Format;
d1242 5
a1246 5
    if ( have_sfnt && FT_Err_Ok != error )
      error = FT_New_Face_From_SFNT( library,
                                     sfnt_id,
                                     face_index,
                                     aface );
d1248 1
a1248 1
    return error;
d1339 7
d1367 3
a1387 5
#if __LP64__
    FT_UNUSED( library );
    FT_UNUSED( spec );
    FT_UNUSED( face_index );
    FT_UNUSED( aface );
d1389 2
a1390 2
    return FT_Err_Unimplemented_Feature;
#else
d1398 31
a1428 1
#endif
@

