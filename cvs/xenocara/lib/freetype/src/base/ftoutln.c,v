head	1.17;
access;
symbols
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.13.0.2
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.08.09.07.16.09;	author dcoppa;	state Exp;
branches;
next	1.16;
commitid	C8TgUUJolulx9B5d;

1.16
date	2016.05.29.11.57.12;	author dcoppa;	state Exp;
branches;
next	1.15;
commitid	1dOLexdOAzW2mQjp;

1.15
date	2015.12.07.09.34.03;	author dcoppa;	state Exp;
branches;
next	1.14;
commitid	wZOPiDmcwgRFTDVL;

1.14
date	2015.10.19.07.51.37;	author dcoppa;	state Exp;
branches;
next	1.13;
commitid	d2XmJCtYff11VIDu;

1.13
date	2015.06.28.08.27.47;	author dcoppa;	state Exp;
branches;
next	1.12;
commitid	qXwIGV2h9uFjxAmt;

1.12
date	2014.12.26.17.52.35;	author dcoppa;	state Exp;
branches;
next	1.11;
commitid	gwhRExMduYqoPQHI;

1.11
date	2014.03.14.08.18.01;	author dcoppa;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2014.01.12.15.08.27;	author matthieu;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2013.06.07.17.21.09;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.01.04.16.51.58;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.07.07.16.45.04;	author dcoppa;	state Exp;
branches;
next	1.6;

1.6
date	2012.04.14.09.45.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.09.01.19.14.25;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.03.25.20.49.54;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.10.20.28.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.38;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.38;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.33.01;	author matthieu;	state Exp;
branches;
next	;

1.10.2.1
date	2015.03.11.19.50.48;	author tedu;	state Exp;
branches;
next	;
commitid	gSxuITleqkyrLFtk;

1.11.2.1
date	2015.03.11.19.50.16;	author tedu;	state Exp;
branches;
next	;
commitid	DBjn1kYKEwrb9ob6;


desc
@@


1.17
log
@
Update to FreeType 2.6.5

ok matthieu@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftoutln.c                                                              */
/*                                                                         */
/*    FreeType outline management (body).                                  */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* All functions are declared in freetype.h.                             */
  /*                                                                       */
  /*************************************************************************/


#include <ft2build.h>
#include FT_OUTLINE_H
#include FT_INTERNAL_OBJECTS_H
#include FT_INTERNAL_CALC_H
#include FT_INTERNAL_DEBUG_H
#include FT_TRIGONOMETRY_H


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_outline


  static
  const FT_Outline  null_outline = { 0, 0, NULL, NULL, NULL, 0 };


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Outline_Decompose( FT_Outline*              outline,
                        const FT_Outline_Funcs*  func_interface,
                        void*                    user )
  {
#undef  SCALED
#define SCALED( x )  ( ( (x) < 0 ? -( -(x) << shift )             \
                                 :  (  (x) << shift ) ) - delta )

    FT_Vector   v_last;
    FT_Vector   v_control;
    FT_Vector   v_start;

    FT_Vector*  point;
    FT_Vector*  limit;
    char*       tags;

    FT_Error    error;

    FT_Int   n;         /* index of contour in outline     */
    FT_UInt  first;     /* index of first point in contour */
    FT_Int   tag;       /* current point's state           */

    FT_Int   shift;
    FT_Pos   delta;


    if ( !outline )
      return FT_THROW( Invalid_Outline );

    if ( !func_interface )
      return FT_THROW( Invalid_Argument );

    shift = func_interface->shift;
    delta = func_interface->delta;
    first = 0;

    for ( n = 0; n < outline->n_contours; n++ )
    {
      FT_Int  last;  /* index of last point in contour */


      FT_TRACE5(( "FT_Outline_Decompose: Outline %d\n", n ));

      last = outline->contours[n];
      if ( last < 0 )
        goto Invalid_Outline;
      limit = outline->points + last;

      v_start   = outline->points[first];
      v_start.x = SCALED( v_start.x );
      v_start.y = SCALED( v_start.y );

      v_last   = outline->points[last];
      v_last.x = SCALED( v_last.x );
      v_last.y = SCALED( v_last.y );

      v_control = v_start;

      point = outline->points + first;
      tags  = outline->tags   + first;
      tag   = FT_CURVE_TAG( tags[0] );

      /* A contour cannot start with a cubic control point! */
      if ( tag == FT_CURVE_TAG_CUBIC )
        goto Invalid_Outline;

      /* check first point to determine origin */
      if ( tag == FT_CURVE_TAG_CONIC )
      {
        /* first point is conic control.  Yes, this happens. */
        if ( FT_CURVE_TAG( outline->tags[last] ) == FT_CURVE_TAG_ON )
        {
          /* start at last point if it is on the curve */
          v_start = v_last;
          limit--;
        }
        else
        {
          /* if both first and last points are conic,         */
          /* start at their middle and record its position    */
          /* for closure                                      */
          v_start.x = ( v_start.x + v_last.x ) / 2;
          v_start.y = ( v_start.y + v_last.y ) / 2;

       /* v_last = v_start; */
        }
        point--;
        tags--;
      }

      FT_TRACE5(( "  move to (%.2f, %.2f)\n",
                  v_start.x / 64.0, v_start.y / 64.0 ));
      error = func_interface->move_to( &v_start, user );
      if ( error )
        goto Exit;

      while ( point < limit )
      {
        point++;
        tags++;

        tag = FT_CURVE_TAG( tags[0] );
        switch ( tag )
        {
        case FT_CURVE_TAG_ON:  /* emit a single line_to */
          {
            FT_Vector  vec;


            vec.x = SCALED( point->x );
            vec.y = SCALED( point->y );

            FT_TRACE5(( "  line to (%.2f, %.2f)\n",
                        vec.x / 64.0, vec.y / 64.0 ));
            error = func_interface->line_to( &vec, user );
            if ( error )
              goto Exit;
            continue;
          }

        case FT_CURVE_TAG_CONIC:  /* consume conic arcs */
          v_control.x = SCALED( point->x );
          v_control.y = SCALED( point->y );

        Do_Conic:
          if ( point < limit )
          {
            FT_Vector  vec;
            FT_Vector  v_middle;


            point++;
            tags++;
            tag = FT_CURVE_TAG( tags[0] );

            vec.x = SCALED( point->x );
            vec.y = SCALED( point->y );

            if ( tag == FT_CURVE_TAG_ON )
            {
              FT_TRACE5(( "  conic to (%.2f, %.2f)"
                          " with control (%.2f, %.2f)\n",
                          vec.x / 64.0, vec.y / 64.0,
                          v_control.x / 64.0, v_control.y / 64.0 ));
              error = func_interface->conic_to( &v_control, &vec, user );
              if ( error )
                goto Exit;
              continue;
            }

            if ( tag != FT_CURVE_TAG_CONIC )
              goto Invalid_Outline;

            v_middle.x = ( v_control.x + vec.x ) / 2;
            v_middle.y = ( v_control.y + vec.y ) / 2;

            FT_TRACE5(( "  conic to (%.2f, %.2f)"
                        " with control (%.2f, %.2f)\n",
                        v_middle.x / 64.0, v_middle.y / 64.0,
                        v_control.x / 64.0, v_control.y / 64.0 ));
            error = func_interface->conic_to( &v_control, &v_middle, user );
            if ( error )
              goto Exit;

            v_control = vec;
            goto Do_Conic;
          }

          FT_TRACE5(( "  conic to (%.2f, %.2f)"
                      " with control (%.2f, %.2f)\n",
                      v_start.x / 64.0, v_start.y / 64.0,
                      v_control.x / 64.0, v_control.y / 64.0 ));
          error = func_interface->conic_to( &v_control, &v_start, user );
          goto Close;

        default:  /* FT_CURVE_TAG_CUBIC */
          {
            FT_Vector  vec1, vec2;


            if ( point + 1 > limit                             ||
                 FT_CURVE_TAG( tags[1] ) != FT_CURVE_TAG_CUBIC )
              goto Invalid_Outline;

            point += 2;
            tags  += 2;

            vec1.x = SCALED( point[-2].x );
            vec1.y = SCALED( point[-2].y );

            vec2.x = SCALED( point[-1].x );
            vec2.y = SCALED( point[-1].y );

            if ( point <= limit )
            {
              FT_Vector  vec;


              vec.x = SCALED( point->x );
              vec.y = SCALED( point->y );

              FT_TRACE5(( "  cubic to (%.2f, %.2f)"
                          " with controls (%.2f, %.2f) and (%.2f, %.2f)\n",
                          vec.x / 64.0, vec.y / 64.0,
                          vec1.x / 64.0, vec1.y / 64.0,
                          vec2.x / 64.0, vec2.y / 64.0 ));
              error = func_interface->cubic_to( &vec1, &vec2, &vec, user );
              if ( error )
                goto Exit;
              continue;
            }

            FT_TRACE5(( "  cubic to (%.2f, %.2f)"
                        " with controls (%.2f, %.2f) and (%.2f, %.2f)\n",
                        v_start.x / 64.0, v_start.y / 64.0,
                        vec1.x / 64.0, vec1.y / 64.0,
                        vec2.x / 64.0, vec2.y / 64.0 ));
            error = func_interface->cubic_to( &vec1, &vec2, &v_start, user );
            goto Close;
          }
        }
      }

      /* close the contour with a line segment */
      FT_TRACE5(( "  line to (%.2f, %.2f)\n",
                  v_start.x / 64.0, v_start.y / 64.0 ));
      error = func_interface->line_to( &v_start, user );

    Close:
      if ( error )
        goto Exit;

      first = (FT_UInt)last + 1;
    }

    FT_TRACE5(( "FT_Outline_Decompose: Done\n", n ));
    return FT_Err_Ok;

  Exit:
    FT_TRACE5(( "FT_Outline_Decompose: Error %d\n", error ));
    return error;

  Invalid_Outline:
    return FT_THROW( Invalid_Outline );
  }


  FT_EXPORT_DEF( FT_Error )
  FT_Outline_New_Internal( FT_Memory    memory,
                           FT_UInt      numPoints,
                           FT_Int       numContours,
                           FT_Outline  *anoutline )
  {
    FT_Error  error;


    if ( !anoutline || !memory )
      return FT_THROW( Invalid_Argument );

    *anoutline = null_outline;

    if ( numContours < 0                  ||
         (FT_UInt)numContours > numPoints )
      return FT_THROW( Invalid_Argument );

    if ( numPoints > FT_OUTLINE_POINTS_MAX )
      return FT_THROW( Array_Too_Large );

    if ( FT_NEW_ARRAY( anoutline->points,   numPoints   ) ||
         FT_NEW_ARRAY( anoutline->tags,     numPoints   ) ||
         FT_NEW_ARRAY( anoutline->contours, numContours ) )
      goto Fail;

    anoutline->n_points    = (FT_Short)numPoints;
    anoutline->n_contours  = (FT_Short)numContours;
    anoutline->flags      |= FT_OUTLINE_OWNER;

    return FT_Err_Ok;

  Fail:
    anoutline->flags |= FT_OUTLINE_OWNER;
    FT_Outline_Done_Internal( memory, anoutline );

    return error;
  }


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Outline_New( FT_Library   library,
                  FT_UInt      numPoints,
                  FT_Int       numContours,
                  FT_Outline  *anoutline )
  {
    if ( !library )
      return FT_THROW( Invalid_Library_Handle );

    return FT_Outline_New_Internal( library->memory, numPoints,
                                    numContours, anoutline );
  }


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Outline_Check( FT_Outline*  outline )
  {
    if ( outline )
    {
      FT_Int  n_points   = outline->n_points;
      FT_Int  n_contours = outline->n_contours;
      FT_Int  end0, end;
      FT_Int  n;


      /* empty glyph? */
      if ( n_points == 0 && n_contours == 0 )
        return FT_Err_Ok;

      /* check point and contour counts */
      if ( n_points <= 0 || n_contours <= 0 )
        goto Bad;

      end0 = end = -1;
      for ( n = 0; n < n_contours; n++ )
      {
        end = outline->contours[n];

        /* note that we don't accept empty contours */
        if ( end <= end0 || end >= n_points )
          goto Bad;

        end0 = end;
      }

      if ( end != n_points - 1 )
        goto Bad;

      /* XXX: check the tags array */
      return FT_Err_Ok;
    }

  Bad:
    return FT_THROW( Invalid_Argument );
  }


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Outline_Copy( const FT_Outline*  source,
                   FT_Outline        *target )
  {
    FT_Int  is_owner;


    if ( !source || !target )
      return FT_THROW( Invalid_Outline );

    if ( source->n_points   != target->n_points   ||
         source->n_contours != target->n_contours )
      return FT_THROW( Invalid_Argument );

    if ( source == target )
      return FT_Err_Ok;

    if ( source->n_points )
    {
      FT_ARRAY_COPY( target->points, source->points, source->n_points );
      FT_ARRAY_COPY( target->tags,   source->tags,   source->n_points );
    }

    if ( source->n_contours )
      FT_ARRAY_COPY( target->contours, source->contours, source->n_contours );

    /* copy all flags, except the `FT_OUTLINE_OWNER' one */
    is_owner      = target->flags & FT_OUTLINE_OWNER;
    target->flags = source->flags;

    target->flags &= ~FT_OUTLINE_OWNER;
    target->flags |= is_owner;

    return FT_Err_Ok;
  }


  FT_EXPORT_DEF( FT_Error )
  FT_Outline_Done_Internal( FT_Memory    memory,
                            FT_Outline*  outline )
  {
    if ( !outline )
      return FT_THROW( Invalid_Outline );

    if ( !memory )
      return FT_THROW( Invalid_Argument );

    if ( outline->flags & FT_OUTLINE_OWNER )
    {
      FT_FREE( outline->points   );
      FT_FREE( outline->tags     );
      FT_FREE( outline->contours );
    }
    *outline = null_outline;

    return FT_Err_Ok;
  }


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Outline_Done( FT_Library   library,
                   FT_Outline*  outline )
  {
    /* check for valid `outline' in FT_Outline_Done_Internal() */

    if ( !library )
      return FT_THROW( Invalid_Library_Handle );

    return FT_Outline_Done_Internal( library->memory, outline );
  }


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( void )
  FT_Outline_Get_CBox( const FT_Outline*  outline,
                       FT_BBox           *acbox )
  {
    FT_Pos  xMin, yMin, xMax, yMax;


    if ( outline && acbox )
    {
      if ( outline->n_points == 0 )
      {
        xMin = 0;
        yMin = 0;
        xMax = 0;
        yMax = 0;
      }
      else
      {
        FT_Vector*  vec   = outline->points;
        FT_Vector*  limit = vec + outline->n_points;


        xMin = xMax = vec->x;
        yMin = yMax = vec->y;
        vec++;

        for ( ; vec < limit; vec++ )
        {
          FT_Pos  x, y;


          x = vec->x;
          if ( x < xMin ) xMin = x;
          if ( x > xMax ) xMax = x;

          y = vec->y;
          if ( y < yMin ) yMin = y;
          if ( y > yMax ) yMax = y;
        }
      }
      acbox->xMin = xMin;
      acbox->xMax = xMax;
      acbox->yMin = yMin;
      acbox->yMax = yMax;
    }
  }


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( void )
  FT_Outline_Translate( const FT_Outline*  outline,
                        FT_Pos             xOffset,
                        FT_Pos             yOffset )
  {
    FT_UShort   n;
    FT_Vector*  vec;


    if ( !outline )
      return;

    vec = outline->points;

    for ( n = 0; n < outline->n_points; n++ )
    {
      vec->x += xOffset;
      vec->y += yOffset;
      vec++;
    }
  }


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( void )
  FT_Outline_Reverse( FT_Outline*  outline )
  {
    FT_UShort  n;
    FT_Int     first, last;


    if ( !outline )
      return;

    first = 0;

    for ( n = 0; n < outline->n_contours; n++ )
    {
      last  = outline->contours[n];

      /* reverse point table */
      {
        FT_Vector*  p = outline->points + first;
        FT_Vector*  q = outline->points + last;
        FT_Vector   swap;


        while ( p < q )
        {
          swap = *p;
          *p   = *q;
          *q   = swap;
          p++;
          q--;
        }
      }

      /* reverse tags table */
      {
        char*  p = outline->tags + first;
        char*  q = outline->tags + last;


        while ( p < q )
        {
          char  swap;


          swap = *p;
          *p   = *q;
          *q   = swap;
          p++;
          q--;
        }
      }

      first = last + 1;
    }

    outline->flags ^= FT_OUTLINE_REVERSE_FILL;
  }


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Outline_Render( FT_Library         library,
                     FT_Outline*        outline,
                     FT_Raster_Params*  params )
  {
    FT_Error     error;
    FT_Renderer  renderer;
    FT_ListNode  node;


    if ( !library )
      return FT_THROW( Invalid_Library_Handle );

    if ( !outline )
      return FT_THROW( Invalid_Outline );

    if ( !params )
      return FT_THROW( Invalid_Argument );

    renderer = library->cur_renderer;
    node     = library->renderers.head;

    params->source = (void*)outline;

    error = FT_ERR( Cannot_Render_Glyph );
    while ( renderer )
    {
      error = renderer->raster_render( renderer->raster, params );
      if ( !error || FT_ERR_NEQ( error, Cannot_Render_Glyph ) )
        break;

      /* FT_Err_Cannot_Render_Glyph is returned if the render mode   */
      /* is unsupported by the current renderer for this glyph image */
      /* format                                                      */

      /* now, look for another renderer that supports the same */
      /* format                                                */
      renderer = FT_Lookup_Renderer( library, FT_GLYPH_FORMAT_OUTLINE,
                                     &node );
    }

    return error;
  }


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Outline_Get_Bitmap( FT_Library        library,
                         FT_Outline*       outline,
                         const FT_Bitmap  *abitmap )
  {
    FT_Raster_Params  params;


    if ( !abitmap )
      return FT_THROW( Invalid_Argument );

    /* other checks are delayed to `FT_Outline_Render' */

    params.target = abitmap;
    params.flags  = 0;

    if ( abitmap->pixel_mode == FT_PIXEL_MODE_GRAY  ||
         abitmap->pixel_mode == FT_PIXEL_MODE_LCD   ||
         abitmap->pixel_mode == FT_PIXEL_MODE_LCD_V )
      params.flags |= FT_RASTER_FLAG_AA;

    return FT_Outline_Render( library, outline, &params );
  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( void )
  FT_Vector_Transform( FT_Vector*        vector,
                       const FT_Matrix*  matrix )
  {
    FT_Pos  xz, yz;


    if ( !vector || !matrix )
      return;

    xz = FT_MulFix( vector->x, matrix->xx ) +
         FT_MulFix( vector->y, matrix->xy );

    yz = FT_MulFix( vector->x, matrix->yx ) +
         FT_MulFix( vector->y, matrix->yy );

    vector->x = xz;
    vector->y = yz;
  }


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( void )
  FT_Outline_Transform( const FT_Outline*  outline,
                        const FT_Matrix*   matrix )
  {
    FT_Vector*  vec;
    FT_Vector*  limit;


    if ( !outline || !matrix )
      return;

    vec   = outline->points;
    limit = vec + outline->n_points;

    for ( ; vec < limit; vec++ )
      FT_Vector_Transform( vec, matrix );
  }


#if 0

#define FT_OUTLINE_GET_CONTOUR( outline, c, first, last )  \
  do                                                       \
  {                                                        \
    (first) = ( c > 0 ) ? (outline)->points +              \
                            (outline)->contours[c - 1] + 1 \
                        : (outline)->points;               \
    (last) = (outline)->points + (outline)->contours[c];   \
  } while ( 0 )


  /* Is a point in some contour?                     */
  /*                                                 */
  /* We treat every point of the contour as if it    */
  /* it were ON.  That is, we allow false positives, */
  /* but disallow false negatives.  (XXX really?)    */
  static FT_Bool
  ft_contour_has( FT_Outline*  outline,
                  FT_Short     c,
                  FT_Vector*   point )
  {
    FT_Vector*  first;
    FT_Vector*  last;
    FT_Vector*  a;
    FT_Vector*  b;
    FT_UInt     n = 0;


    FT_OUTLINE_GET_CONTOUR( outline, c, first, last );

    for ( a = first; a <= last; a++ )
    {
      FT_Pos  x;
      FT_Int  intersect;


      b = ( a == last ) ? first : a + 1;

      intersect = ( a->y - point->y ) ^ ( b->y - point->y );

      /* a and b are on the same side */
      if ( intersect >= 0 )
      {
        if ( intersect == 0 && a->y == point->y )
        {
          if ( ( a->x <= point->x && b->x >= point->x ) ||
               ( a->x >= point->x && b->x <= point->x ) )
            return 1;
        }

        continue;
      }

      x = a->x + ( b->x - a->x ) * (point->y - a->y ) / ( b->y - a->y );

      if ( x < point->x )
        n++;
      else if ( x == point->x )
        return 1;
    }

    return n & 1;
  }


  static FT_Bool
  ft_contour_enclosed( FT_Outline*  outline,
                       FT_UShort    c )
  {
    FT_Vector*  first;
    FT_Vector*  last;
    FT_Short    i;


    FT_OUTLINE_GET_CONTOUR( outline, c, first, last );

    for ( i = 0; i < outline->n_contours; i++ )
    {
      if ( i != c && ft_contour_has( outline, i, first ) )
      {
        FT_Vector*  pt;


        for ( pt = first + 1; pt <= last; pt++ )
          if ( !ft_contour_has( outline, i, pt ) )
            return 0;

        return 1;
      }
    }

    return 0;
  }


  /* This version differs from the public one in that each */
  /* part (contour not enclosed in another contour) of the */
  /* outline is checked for orientation.  This is          */
  /* necessary for some buggy CJK fonts.                   */
  static FT_Orientation
  ft_outline_get_orientation( FT_Outline*  outline )
  {
    FT_Short        i;
    FT_Vector*      first;
    FT_Vector*      last;
    FT_Orientation  orient = FT_ORIENTATION_NONE;


    first = outline->points;
    for ( i = 0; i < outline->n_contours; i++, first = last + 1 )
    {
      FT_Vector*  point;
      FT_Vector*  xmin_point;
      FT_Pos      xmin;


      last = outline->points + outline->contours[i];

      /* skip degenerate contours */
      if ( last < first + 2 )
        continue;

      if ( ft_contour_enclosed( outline, i ) )
        continue;

      xmin       = first->x;
      xmin_point = first;

      for ( point = first + 1; point <= last; point++ )
      {
        if ( point->x < xmin )
        {
          xmin       = point->x;
          xmin_point = point;
        }
      }

      /* check the orientation of the contour */
      {
        FT_Vector*      prev;
        FT_Vector*      next;
        FT_Orientation  o;


        prev = ( xmin_point == first ) ? last : xmin_point - 1;
        next = ( xmin_point == last ) ? first : xmin_point + 1;

        if ( FT_Atan2( prev->x - xmin_point->x, prev->y - xmin_point->y ) >
             FT_Atan2( next->x - xmin_point->x, next->y - xmin_point->y ) )
          o = FT_ORIENTATION_POSTSCRIPT;
        else
          o = FT_ORIENTATION_TRUETYPE;

        if ( orient == FT_ORIENTATION_NONE )
          orient = o;
        else if ( orient != o )
          return FT_ORIENTATION_NONE;
      }
    }

    return orient;
  }

#endif /* 0 */


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Outline_Embolden( FT_Outline*  outline,
                       FT_Pos       strength )
  {
    return FT_Outline_EmboldenXY( outline, strength, strength );
  }


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Outline_EmboldenXY( FT_Outline*  outline,
                         FT_Pos       xstrength,
                         FT_Pos       ystrength )
  {
    FT_Vector*  points;
    FT_Int      c, first, last;
    FT_Int      orientation;


    if ( !outline )
      return FT_THROW( Invalid_Outline );

    xstrength /= 2;
    ystrength /= 2;
    if ( xstrength == 0 && ystrength == 0 )
      return FT_Err_Ok;

    orientation = FT_Outline_Get_Orientation( outline );
    if ( orientation == FT_ORIENTATION_NONE )
    {
      if ( outline->n_contours )
        return FT_THROW( Invalid_Argument );
      else
        return FT_Err_Ok;
    }

    points = outline->points;

    first = 0;
    for ( c = 0; c < outline->n_contours; c++ )
    {
      FT_Vector  in, out, anchor, shift;
      FT_Fixed   l_in, l_out, l_anchor = 0, l, q, d;
      FT_Int     i, j, k;


      l_in = 0;
      last = outline->contours[c];

      /* pacify compiler */
      in.x = in.y = anchor.x = anchor.y = 0;

      /* Counter j cycles though the points; counter i advances only  */
      /* when points are moved; anchor k marks the first moved point. */
      for ( i = last, j = first, k = -1;
            j != i && i != k;
            j = j < last ? j + 1 : first )
      {
        if ( j != k )
        {
          out.x = points[j].x - points[i].x;
          out.y = points[j].y - points[i].y;
          l_out = (FT_Fixed)FT_Vector_NormLen( &out );

          if ( l_out == 0 )
            continue;
        }
        else
        {
          out   = anchor;
          l_out = l_anchor;
        }

        if ( l_in != 0 )
        {
          if ( k < 0 )
          {
            k        = i;
            anchor   = in;
            l_anchor = l_in;
          }

          d = FT_MulFix( in.x, out.x ) + FT_MulFix( in.y, out.y );

          /* shift only if turn is less than ~160 degrees */
          if ( d > -0xF000L )
          {
            d = d + 0x10000L;

            /* shift components along lateral bisector in proper orientation */
            shift.x = in.y + out.y;
            shift.y = in.x + out.x;

            if ( orientation == FT_ORIENTATION_TRUETYPE )
              shift.x = -shift.x;
            else
              shift.y = -shift.y;

            /* restrict shift magnitude to better handle collapsing segments */
            q = FT_MulFix( out.x, in.y ) - FT_MulFix( out.y, in.x );
            if ( orientation == FT_ORIENTATION_TRUETYPE )
              q = -q;

            l = FT_MIN( l_in, l_out );

            /* non-strict inequalities avoid divide-by-zero when q == l == 0 */
            if ( FT_MulFix( xstrength, q ) <= FT_MulFix( l, d ) )
              shift.x = FT_MulDiv( shift.x, xstrength, d );
            else
              shift.x = FT_MulDiv( shift.x, l, q );


            if ( FT_MulFix( ystrength, q ) <= FT_MulFix( l, d ) )
              shift.y = FT_MulDiv( shift.y, ystrength, d );
            else
              shift.y = FT_MulDiv( shift.y, l, q );
          }
          else
            shift.x = shift.y = 0;

          for ( ;
                i != j;
                i = i < last ? i + 1 : first )
          {
            points[i].x += xstrength + shift.x;
            points[i].y += ystrength + shift.y;
          }
        }
        else
          i = j;

        in   = out;
        l_in = l_out;
      }

      first = last + 1;
    }

    return FT_Err_Ok;
  }


  /* documentation is in ftoutln.h */

  FT_EXPORT_DEF( FT_Orientation )
  FT_Outline_Get_Orientation( FT_Outline*  outline )
  {
    FT_BBox     cbox;
    FT_Int      xshift, yshift;
    FT_Vector*  points;
    FT_Vector   v_prev, v_cur;
    FT_Int      c, n, first;
    FT_Pos      area = 0;


    if ( !outline || outline->n_points <= 0 )
      return FT_ORIENTATION_TRUETYPE;

    /* We use the nonzero winding rule to find the orientation.       */
    /* Since glyph outlines behave much more `regular' than arbitrary */
    /* cubic or quadratic curves, this test deals with the polygon    */
    /* only that is spanned up by the control points.                 */

    FT_Outline_Get_CBox( outline, &cbox );

    /* Handle collapsed outlines to avoid undefined FT_MSB. */
    if ( cbox.xMin == cbox.xMax || cbox.yMin == cbox.yMax )
      return FT_ORIENTATION_NONE;

    xshift = FT_MSB( (FT_UInt32)( FT_ABS( cbox.xMax ) |
                                  FT_ABS( cbox.xMin ) ) ) - 14;
    xshift = FT_MAX( xshift, 0 );

    yshift = FT_MSB( (FT_UInt32)( cbox.yMax - cbox.yMin ) ) - 14;
    yshift = FT_MAX( yshift, 0 );

    points = outline->points;

    first = 0;
    for ( c = 0; c < outline->n_contours; c++ )
    {
      FT_Int  last = outline->contours[c];


      v_prev.x = points[last].x >> xshift;
      v_prev.y = points[last].y >> yshift;

      for ( n = first; n <= last; n++ )
      {
        v_cur.x = points[n].x >> xshift;
        v_cur.y = points[n].y >> yshift;

        area += ( v_cur.y - v_prev.y ) * ( v_cur.x + v_prev.x );

        v_prev = v_cur;
      }

      first = last + 1;
    }

    if ( area > 0 )
      return FT_ORIENTATION_POSTSCRIPT;
    else if ( area < 0 )
      return FT_ORIENTATION_TRUETYPE;
    else
      return FT_ORIENTATION_NONE;
  }


/* END */
@


1.16
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d45 1
a45 1
  const FT_Outline  null_outline = { 0, 0, 0, 0, 0, 0 };
@


1.15
log
@
Bugfixing update to freetype-2.6.2

Tested on amd64, i386, macppc, sparc64, loongson and compile-tested
on arm by matthieu@@
Also tested in a ports bulk build by naddy@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2015 by                                                 */
d418 5
a422 3
    FT_ARRAY_COPY( target->points, source->points, source->n_points );

    FT_ARRAY_COPY( target->tags, source->tags, source->n_points );
d424 2
a425 1
    FT_ARRAY_COPY( target->contours, source->contours, source->n_contours );
@


1.14
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@d945 3
d1080 2
a1081 1
      v_prev = points[last];
d1085 5
a1089 3
        v_cur = points[n];
        area += ( ( v_cur.y - v_prev.y ) >> yshift ) *
                ( ( v_cur.x + v_prev.x ) >> xshift );
@


1.13
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d55 3
a57 2
#undef SCALED
#define SCALED( x )  ( ( (x) << shift ) - delta )
d911 1
a911 2
    FT_Vector   v_prev, v_first, v_next, v_cur;
    FT_Int      c, n, first;
d937 3
a939 3
      FT_Vector  in, out, shift;
      FT_Fixed   l_in, l_out, l, q, d;
      int        last = outline->contours[c];
d942 2
a943 3
      v_first = points[first];
      v_prev  = points[last];
      v_cur   = v_first;
d945 5
a949 5
      /* compute incoming normalized vector */
      in.x = v_cur.x - v_prev.x;
      in.y = v_cur.y - v_prev.y;
      l_in = FT_Vector_Length( &in );
      if ( l_in )
d951 5
a955 3
        in.x = FT_DivFix( in.x, l_in );
        in.y = FT_DivFix( in.y, l_in );
      }
d957 3
a959 4
      for ( n = first; n <= last; n++ )
      {
        if ( n < last )
          v_next = points[n + 1];
a960 7
          v_next = v_first;

        /* compute outgoing normalized vector */
        out.x = v_next.x - v_cur.x;
        out.y = v_next.y - v_cur.y;
        l_out = FT_Vector_Length( &out );
        if ( l_out )
d962 2
a963 2
          out.x = FT_DivFix( out.x, l_out );
          out.y = FT_DivFix( out.y, l_out );
d966 1
a966 4
        d = FT_MulFix( in.x, out.x ) + FT_MulFix( in.y, out.y );

        /* shift only if turn is less than ~160 degrees */
        if ( d > -0xF000L )
d968 6
a973 1
          d = d + 0x10000L;
d975 1
a975 4
          /* shift components are aligned along lateral bisector */
          /* and directed according to the outline orientation.  */
          shift.x = in.y + out.y;
          shift.y = in.x + out.x;
d977 4
a980 4
          if ( orientation == FT_ORIENTATION_TRUETYPE )
            shift.x = -shift.x;
          else
            shift.y = -shift.y;
d982 28
a1009 10
          /* restrict shift magnitude to better handle collapsing segments */
          q = FT_MulFix( out.x, in.y ) - FT_MulFix( out.y, in.x );
          if ( orientation == FT_ORIENTATION_TRUETYPE )
            q = -q;

          l = FT_MIN( l_in, l_out );

          /* non-strict inequalities avoid divide-by-zero when q == l == 0 */
          if ( FT_MulFix( xstrength, q ) <= FT_MulFix( l, d ) )
            shift.x = FT_MulDiv( shift.x, xstrength, d );
d1011 1
a1011 1
            shift.x = FT_MulDiv( shift.x, l, q );
d1013 7
a1019 5

          if ( FT_MulFix( ystrength, q ) <= FT_MulFix( l, d ) )
            shift.y = FT_MulDiv( shift.y, ystrength, d );
          else
            shift.y = FT_MulDiv( shift.y, l, q );
d1022 1
a1022 4
          shift.x = shift.y = 0;

        outline->points[n].x = v_cur.x + xstrength + shift.x;
        outline->points[n].y = v_cur.y + ystrength + shift.y;
d1024 2
a1025 3
        in    = out;
        l_in  = l_out;
        v_cur = v_next;
@


1.12
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2008, 2010, 2012-2014 by                                */
d282 1
a282 1
      first = last + 1;
d323 1
a323 1
    anoutline->n_points    = (FT_UShort)numPoints;
a614 1
    FT_Bool      update = FALSE;
a647 1
      update   = TRUE;
a649 5
    /* if we changed the current renderer for the glyph image format */
    /* we need to select it as the next current one                  */
    if ( !error && update && renderer )
      error = FT_Set_Renderer( library, renderer, 0, 0 );

d998 1
a998 1
          if ( FT_MulFix( xstrength, q ) <= FT_MulFix( d, l ) )
d1004 1
a1004 1
          if ( FT_MulFix( ystrength, q ) <= FT_MulFix( d, l ) )
d1046 1
a1046 1
    /* only which is spanned up by the control points.                */
d1054 2
a1055 1
    xshift = FT_MSB( FT_ABS( cbox.xMax ) | FT_ABS( cbox.xMin ) ) - 14;
d1058 1
a1058 1
    yshift = FT_MSB( cbox.yMax - cbox.yMin ) - 14;
@


1.11
log
@
Security/bugfixing update to freetype-2.5.3, featuring a fix for a
vulnerability in the CFF driver (CVE-2014-2240) and assorted minor
fixes.

ok matthieu@@
@
text
@d76 4
a79 1
    if ( !outline || !func_interface )
d368 1
a368 1
        return 0;
d390 1
a390 1
      return 0;
d407 4
a410 2
    if ( !source            || !target            ||
         source->n_points   != target->n_points   ||
d438 7
a444 1
    if ( memory && outline )
d446 5
a450 7
      if ( outline->flags & FT_OUTLINE_OWNER )
      {
        FT_FREE( outline->points   );
        FT_FREE( outline->tags     );
        FT_FREE( outline->contours );
      }
      *outline = null_outline;
d452 1
a452 4
      return FT_Err_Ok;
    }
    else
      return FT_THROW( Invalid_Argument );
d623 4
a626 1
    if ( !outline || !params )
d655 1
a655 1
      FT_Set_Renderer( library, renderer, 0, 0 );
d674 1
a674 1
    /* other checks are delayed to FT_Outline_Render() */
d923 1
a923 1
      return FT_THROW( Invalid_Argument );
d1056 4
@


1.11.2.1
log
@backport fixes from freetype 2.5.5 for malformed fonts.
fixes dug out of ubuntu by dcoppa@@
@
text
@d1030 1
a1030 1
    FT_BBox     cbox = {0,0,0,0};
@


1.10
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d7 1
a7 1
/*  Copyright 1996-2008, 2010, 2012-2013 by                                */
d131 1
a131 1
          v_last = v_start;
@


1.10.2.1
log
@backport fixes for malformed fonts from freetype 2.5.5.
fixes dug out of ubuntu by dcoppa@@
@
text
@d1030 1
a1030 1
    FT_BBox     cbox = {0,0,0,0};
@


1.9
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@a578 1
        char   swap;
d583 3
d726 2
a727 1
  do {                                                     \
@


1.8
log
@Update to freetype 2.4.11. Tested by krw@@, jasper@@ and on a bulk ports
build by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2008, 2010, 2012 by                                     */
d29 1
d77 1
a77 1
      return FT_Err_Invalid_Argument;
d290 1
a290 1
    return FT_Err_Invalid_Outline;
d304 1
a304 1
      return FT_Err_Invalid_Argument;
d308 7
d343 1
a343 1
      return FT_Err_Invalid_Library_Handle;
d391 1
a391 1
    return FT_Err_Invalid_Argument;
d407 1
a407 1
      return FT_Err_Invalid_Argument;
d446 1
a446 1
      return FT_Err_Invalid_Argument;
d459 1
a459 1
      return FT_Err_Invalid_Library_Handle;
d613 1
a613 1
      return FT_Err_Invalid_Library_Handle;
d616 1
a616 1
      return FT_Err_Invalid_Argument;
d623 1
a623 1
    error = FT_Err_Cannot_Render_Glyph;
d627 1
a627 1
      if ( !error || FT_ERROR_BASE( error ) != FT_Err_Cannot_Render_Glyph )
d661 1
a661 1
      return FT_Err_Invalid_Argument;
d911 1
a911 1
      return FT_Err_Invalid_Argument;
d922 1
a922 1
        return FT_Err_Invalid_Argument;
d941 1
a941 1
      /* compute the incoming vector and its length */
d945 5
d958 1
a958 1
        /* compute the outgoing vector and its length */
d962 5
d968 1
a968 1
        d = l_in * l_out + in.x * out.x + in.y * out.y;
d970 2
a971 2
        /* shift only if turn is less then ~160 degrees */
        if ( 16 * d > l_in * l_out )
d973 6
a978 4
          /* shift components are aligned along bisector        */
          /* and directed according to the outline orientation. */
          shift.x = l_out * in.y + l_in * out.y;
          shift.y = l_out * in.x + l_in * out.x;
d985 2
a986 3
          /* threshold strength to better handle collapsing segments */
          l = FT_MIN( l_in, l_out );
          q = out.x * in.y - out.y * in.x;
d990 4
a993 1
          if ( FT_MulDiv( xstrength, q, l ) < d )
d998 2
a999 2
          
          if ( FT_MulDiv( ystrength, q, l ) < d )
d1027 2
d1043 8
d1064 2
a1065 1
        area += ( v_cur.y - v_prev.y ) * ( v_cur.x + v_prev.x );
@


1.7
log
@Update to freetype-2.4.10.

With help and ok matthieu@@
@
text
@d925 1
a925 1
      FT_Fixed   l_in, l_out, d;
d955 4
a958 3
          /* shift components are rotated */
          shift.x = FT_DivFix( l_out * in.y + l_in * out.y, d );
          shift.y = FT_DivFix( l_out * in.x + l_in * out.x, d );
d965 16
a980 2
          shift.x = FT_MulFix( xstrength, shift.x );
          shift.y = FT_MulFix( ystrength, shift.y );
@


1.6
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@d885 11
a897 1
    FT_Angle    rotate, angle_in, angle_out;
d905 3
a907 2
    strength /= 2;
    if ( strength == 0 )
a918 5
    if ( orientation == FT_ORIENTATION_TRUETYPE )
      rotate = -FT_ANGLE_PI2;
    else
      rotate = FT_ANGLE_PI2;

d924 3
a926 1
      int  last = outline->contours[c];
d933 5
a939 6
        FT_Vector  in, out;
        FT_Angle   angle_diff;
        FT_Pos     d;
        FT_Fixed   scale;


d945 1
a945 4
        /* compute the in and out vectors */
        in.x = v_cur.x - v_prev.x;
        in.y = v_cur.y - v_prev.y;

d948 1
d950 1
a950 4
        angle_in   = FT_Atan2( in.x, in.y );
        angle_out  = FT_Atan2( out.x, out.y );
        angle_diff = FT_Angle_Diff( angle_in, angle_out );
        scale      = FT_Cos( angle_diff / 2 );
d952 2
a953 3
        if ( scale < 0x4000L && scale > -0x4000L )
          in.x = in.y = 0;
        else
d955 8
a962 1
          d = FT_DivFix( strength, scale );
d964 2
a965 1
          FT_Vector_From_Polar( &in, d, angle_in + angle_diff / 2 - rotate );
d967 2
d970 2
a971 2
        outline->points[n].x = v_cur.x + strength + in.x;
        outline->points[n].y = v_cur.y + strength + in.y;
d973 3
a975 2
        v_prev = v_cur;
        v_cur  = v_next;
d990 4
a993 17
    FT_Pos      xmin       = 32768L;
    FT_Pos      xmin_ymin  = 32768L;
    FT_Pos      xmin_ymax  = -32768L;
    FT_Vector*  xmin_first = NULL;
    FT_Vector*  xmin_last  = NULL;

    short*      contour;

    FT_Vector*  first;
    FT_Vector*  last;
    FT_Vector*  prev;
    FT_Vector*  point;

    int             i;
    FT_Pos          ray_y[3];
    FT_Orientation  result[3] =
      { FT_ORIENTATION_NONE, FT_ORIENTATION_NONE, FT_ORIENTATION_NONE };
d1004 4
a1007 4
    first = outline->points;
    for ( contour = outline->contours;
          contour < outline->contours + outline->n_contours;
          contour++, first = last + 1 )
d1009 1
a1009 4
      FT_Pos  contour_xmin = 32768L;
      FT_Pos  contour_xmax = -32768L;
      FT_Pos  contour_ymin = 32768L;
      FT_Pos  contour_ymax = -32768L;
d1012 1
a1012 1
      last = outline->points + *contour;
d1014 1
a1014 5
      /* skip degenerate contours */
      if ( last < first + 2 )
        continue;

      for ( point = first; point <= last; ++point )
d1016 3
a1018 11
        if ( point->x < contour_xmin )
          contour_xmin = point->x;

        if ( point->x > contour_xmax )
          contour_xmax = point->x;

        if ( point->y < contour_ymin )
          contour_ymin = point->y;

        if ( point->y > contour_ymax )
          contour_ymax = point->y;
d1021 1
a1021 10
      if ( contour_xmin < xmin          &&
           contour_xmin != contour_xmax &&
           contour_ymin != contour_ymax )
      {
        xmin       = contour_xmin;
        xmin_ymin  = contour_ymin;
        xmin_ymax  = contour_ymax;
        xmin_first = first;
        xmin_last  = last;
      }
d1024 3
a1026 1
    if ( xmin == 32768L )
d1028 2
a1029 75

    ray_y[0] = ( xmin_ymin * 3 + xmin_ymax     ) >> 2;
    ray_y[1] = ( xmin_ymin     + xmin_ymax     ) >> 1;
    ray_y[2] = ( xmin_ymin     + xmin_ymax * 3 ) >> 2;

    for ( i = 0; i < 3; i++ )
    {
      FT_Pos      left_x;
      FT_Pos      right_x;
      FT_Vector*  left1;
      FT_Vector*  left2;
      FT_Vector*  right1;
      FT_Vector*  right2;


    RedoRay:
      left_x  = 32768L;
      right_x = -32768L;

      left1 = left2 = right1 = right2 = NULL;

      prev = xmin_last;
      for ( point = xmin_first; point <= xmin_last; prev = point, ++point )
      {
        FT_Pos  tmp_x;


        if ( point->y == ray_y[i] || prev->y == ray_y[i] )
        {
          ray_y[i]++;
          goto RedoRay;
        }

        if ( ( point->y < ray_y[i] && prev->y < ray_y[i] ) ||
             ( point->y > ray_y[i] && prev->y > ray_y[i] ) )
          continue;

        tmp_x = FT_MulDiv( point->x - prev->x,
                           ray_y[i] - prev->y,
                           point->y - prev->y ) + prev->x;

        if ( tmp_x < left_x )
        {
          left_x = tmp_x;
          left1  = prev;
          left2  = point;
        }

        if ( tmp_x > right_x )
        {
          right_x = tmp_x;
          right1  = prev;
          right2  = point;
        }
      }

      if ( left1 && right1 )
      {
        if ( left1->y < left2->y && right1->y > right2->y )
          result[i] = FT_ORIENTATION_TRUETYPE;
        else if ( left1->y > left2->y && right1->y < right2->y )
          result[i] = FT_ORIENTATION_POSTSCRIPT;
        else
          result[i] = FT_ORIENTATION_NONE;
      }
    }

    if ( result[0] != FT_ORIENTATION_NONE                     &&
         ( result[0] == result[1] || result[0] == result[2] ) )
      return result[0];

    if ( result[1] != FT_ORIENTATION_NONE && result[1] == result[2] )
      return result[1];

    return FT_ORIENTATION_TRUETYPE;
@


1.5
log
@Update to freetype 2.4.2. This has been in snapshots for a while
and tested explicitely by ajacoutot@@ jasper@@, jcs@@, krw@@ and others
on various architectures.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 by */
d774 1
a774 1
    return ( n % 2 );
@


1.4
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d993 2
a994 1
    FT_Orientation  result[3];
@


1.3
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d307 3
a309 3
    if ( FT_NEW_ARRAY( anoutline->points,   numPoints * 2L ) ||
         FT_NEW_ARRAY( anoutline->tags,     numPoints      ) ||
         FT_NEW_ARRAY( anoutline->contours, numContours    ) )
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d29 1
d87 2
d94 7
a100 5
      v_start = outline->points[first];
      v_last  = outline->points[last];

      v_start.x = SCALED( v_start.x ); v_start.y = SCALED( v_start.y );
      v_last.x  = SCALED( v_last.x );  v_last.y  = SCALED( v_last.y );
d105 1
a105 1
      tags  = outline->tags  + first;
d136 2
d158 2
d186 4
d202 4
d214 4
d233 5
a237 2
            vec1.x = SCALED( point[-2].x ); vec1.y = SCALED( point[-2].y );
            vec2.x = SCALED( point[-1].x ); vec2.y = SCALED( point[-1].y );
d247 5
d258 5
d270 2
d281 2
a282 1
    return 0;
d285 1
d599 1
a599 1
    FT_Bool      update = 0;
d630 1
a630 1
      update   = 1;
d1048 1
a1048 1
    if ( xmin == 32768 )
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d86 3
a88 1
      last  = outline->contours[n];
d477 1
a477 1
    FT_Vector*  vec = outline->points;
d483 2
d631 1
a631 1
  /* documentation is in ftoutln.h */
d637 1
a637 1
    FT_Pos xz, yz;
d739 1
a739 1
  
d941 2
a942 1
    FT_Vector*  xmin_point = NULL;
d951 5
a955 1
    FT_Vector*  next;
d961 5
d971 5
a975 5
      FT_Vector*  point;
      FT_Int      on_curve;
      FT_Int      on_curve_count = 0;
      FT_Pos      tmp_xmin       = 32768L;
      FT_Vector*  tmp_xmin_point = NULL;
d985 2
a986 4
        /* Count on-curve points.  If there are less than 3 on-curve */
        /* points, just bypass this contour.                         */
        on_curve        = outline->tags[point - outline->points] & 1;
        on_curve_count += on_curve;
d988 8
a995 5
        if ( point->x < tmp_xmin && on_curve )
        {
          tmp_xmin       = point->x;
          tmp_xmin_point = point;
        }
d998 3
a1000 1
      if ( on_curve_count > 2 && tmp_xmin < xmin )
d1002 3
a1004 2
        xmin       = tmp_xmin;
        xmin_point = tmp_xmin_point;
d1010 1
a1010 1
    if ( !xmin_point )
d1013 3
a1015 2
    prev = ( xmin_point == xmin_first ) ? xmin_last : xmin_point - 1;
    next = ( xmin_point == xmin_last ) ? xmin_first : xmin_point + 1;
d1017 1
a1017 2
    /* Skip off-curve points */
    while ( ( outline->tags[prev - outline->points] & 1 ) == 0 )
d1019 58
a1076 4
      if ( prev == xmin_first )
        prev = xmin_last;
      else
        --prev;
d1079 6
a1084 7
    while ( ( outline->tags[next - outline->points] & 1 ) == 0 )
    {
      if ( next == xmin_last )
        next = xmin_first;
      else
        ++next;
    }
d1086 1
a1086 5
    if ( FT_Atan2( prev->x - xmin_point->x, prev->y - xmin_point->y ) >
         FT_Atan2( next->x - xmin_point->x, next->y - xmin_point->y ) )
      return FT_ORIENTATION_POSTSCRIPT;
    else
      return FT_ORIENTATION_TRUETYPE;
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d86 1
a86 3
      last = outline->contours[n];
      if ( last < 0 )
        goto Invalid_Outline;
d735 1
a735 1

d937 1
a937 2
    FT_Pos      xmin_ymin  = 32768L;
    FT_Pos      xmin_ymax  = -32768L;
d946 1
a946 5
    FT_Vector*  point;

    int             i;
    FT_Pos          ray_y[3];
    FT_Orientation  result[3];
a951 5
    /* We use the nonzero winding rule to find the orientation.       */
    /* Since glyph outlines behave much more `regular' than arbitrary */
    /* cubic or quadratic curves, this test deals with the polygon    */
    /* only which is spanned up by the control points.                */

d957 5
a961 5
      FT_Pos  contour_xmin = 32768L;
      FT_Pos  contour_xmax = -32768L;
      FT_Pos  contour_ymin = 32768L;
      FT_Pos  contour_ymax = -32768L;

d971 4
a974 2
        if ( point->x < contour_xmin )
          contour_xmin = point->x;
d976 5
a980 8
        if ( point->x > contour_xmax )
          contour_xmax = point->x;

        if ( point->y < contour_ymin )
          contour_ymin = point->y;

        if ( point->y > contour_ymax )
          contour_ymax = point->y;
d983 1
a983 3
      if ( contour_xmin < xmin          &&
           contour_xmin != contour_xmax &&
           contour_ymin != contour_ymax )
d985 2
a986 3
        xmin       = contour_xmin;
        xmin_ymin  = contour_ymin;
        xmin_ymax  = contour_ymax;
d992 1
a992 1
    if ( xmin == 32768 )
d995 2
a996 3
    ray_y[0] = ( xmin_ymin * 3 + xmin_ymax     ) >> 2;
    ray_y[1] = ( xmin_ymin     + xmin_ymax     ) >> 1;
    ray_y[2] = ( xmin_ymin     + xmin_ymax * 3 ) >> 2;
d998 2
a999 1
    for ( i = 0; i < 3; i++ )
d1001 5
a1005 11
      FT_Pos      left_x;
      FT_Pos      right_x;
      FT_Vector*  left1;
      FT_Vector*  left2;
      FT_Vector*  right1;
      FT_Vector*  right2;


    RedoRay:
      left_x  = 32768L;
      right_x = -32768L;
d1007 6
a1012 46
      left1 = left2 = right1 = right2 = NULL;

      prev = xmin_last;
      for ( point = xmin_first; point <= xmin_last; prev = point, ++point )
      {
        FT_Pos  tmp_x;


        if ( point->y == ray_y[i] || prev->y == ray_y[i] )
        {
          ray_y[i]++;
          goto RedoRay;
        }

        if ( ( point->y < ray_y[i] && prev->y < ray_y[i] ) ||
             ( point->y > ray_y[i] && prev->y > ray_y[i] ) )
          continue;

        tmp_x = FT_MulDiv( point->x - prev->x,
                           ray_y[i] - prev->y,
                           point->y - prev->y ) + prev->x;

        if ( tmp_x < left_x )
        {
          left_x = tmp_x;
          left1  = prev;
          left2  = point;
        }

        if ( tmp_x > right_x )
        {
          right_x = tmp_x;
          right1  = prev;
          right2  = point;
        }
      }

      if ( left1 && right1 )
      {
        if ( left1->y < left2->y && right1->y > right2->y )
          result[i] = FT_ORIENTATION_TRUETYPE;
        else if ( left1->y > left2->y && right1->y < right2->y )
          result[i] = FT_ORIENTATION_POSTSCRIPT;
        else
          result[i] = FT_ORIENTATION_NONE;
      }
d1015 5
a1019 8
    if ( result[0] != FT_ORIENTATION_NONE                     &&
         ( result[0] == result[1] || result[0] == result[2] ) )
      return result[0];

    if ( result[1] != FT_ORIENTATION_NONE && result[1] == result[2] )
      return result[1];

    return FT_ORIENTATION_TRUETYPE;
@

