head	1.17;
access;
symbols
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.2
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2017.01.13.11.19.59;	author dcoppa;	state Exp;
branches;
next	1.16;
commitid	ESXG9TuEmwmBXggf;

1.16
date	2016.08.09.07.16.09;	author dcoppa;	state Exp;
branches;
next	1.15;
commitid	C8TgUUJolulx9B5d;

1.15
date	2016.05.29.11.57.12;	author dcoppa;	state Exp;
branches;
next	1.14;
commitid	1dOLexdOAzW2mQjp;

1.14
date	2015.06.28.08.27.47;	author dcoppa;	state Exp;
branches;
next	1.13;
commitid	qXwIGV2h9uFjxAmt;

1.13
date	2015.01.10.17.17.23;	author dcoppa;	state Exp;
branches;
next	1.12;
commitid	2tSYQMWVSV3t7clo;

1.12
date	2014.12.26.17.52.35;	author dcoppa;	state Exp;
branches;
next	1.11;
commitid	gwhRExMduYqoPQHI;

1.11
date	2014.03.14.08.18.01;	author dcoppa;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2014.01.12.15.08.27;	author matthieu;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2013.10.10.19.49.49;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.21.09;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.04.14.09.45.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.19.11.32.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.30.10.14.51;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.18.20.29.58;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.25.20.49.54;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.10.20.28.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.39;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.32.55;	author matthieu;	state Exp;
branches;
next	;

1.10.2.1
date	2015.03.11.19.50.48;	author tedu;	state Exp;
branches;
next	;
commitid	gSxuITleqkyrLFtk;

1.11.2.1
date	2015.03.11.19.50.16;	author tedu;	state Exp;
branches;
next	;
commitid	DBjn1kYKEwrb9ob6;


desc
@@


1.17
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftbitmap.c                                                             */
/*                                                                         */
/*    FreeType utility functions for bitmaps (body).                       */
/*                                                                         */
/*  Copyright 2004-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H

#include FT_BITMAP_H
#include FT_IMAGE_H
#include FT_INTERNAL_OBJECTS_H


  static
  const FT_Bitmap  null_bitmap = { 0, 0, 0, 0, 0, 0, 0, 0 };


  /* documentation is in ftbitmap.h */

  FT_EXPORT_DEF( void )
  FT_Bitmap_Init( FT_Bitmap  *abitmap )
  {
    if ( abitmap )
      *abitmap = null_bitmap;
  }


  /* deprecated function name; retained for ABI compatibility */

  FT_EXPORT_DEF( void )
  FT_Bitmap_New( FT_Bitmap  *abitmap )
  {
    if ( abitmap )
      *abitmap = null_bitmap;
  }


  /* documentation is in ftbitmap.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Bitmap_Copy( FT_Library        library,
                  const FT_Bitmap  *source,
                  FT_Bitmap        *target)
  {
    FT_Memory  memory;
    FT_Error   error  = FT_Err_Ok;

    FT_Int    pitch;
    FT_ULong  size;

    FT_Int  source_pitch_sign, target_pitch_sign;


    if ( !library )
      return FT_THROW( Invalid_Library_Handle );

    if ( !source || !target )
      return FT_THROW( Invalid_Argument );

    if ( source == target )
      return FT_Err_Ok;

    source_pitch_sign = source->pitch < 0 ? -1 : 1;
    target_pitch_sign = target->pitch < 0 ? -1 : 1;

    if ( !source->buffer )
    {
      *target = *source;
      if ( source_pitch_sign != target_pitch_sign )
        target->pitch = -target->pitch;

      return FT_Err_Ok;
    }

    memory = library->memory;
    pitch  = source->pitch;

    if ( pitch < 0 )
      pitch = -pitch;
    size = (FT_ULong)pitch * source->rows;

    if ( target->buffer )
    {
      FT_Int    target_pitch = target->pitch;
      FT_ULong  target_size;


      if ( target_pitch < 0 )
        target_pitch = -target_pitch;
      target_size = (FT_ULong)target_pitch * target->rows;

      if ( target_size != size )
        (void)FT_QREALLOC( target->buffer, target_size, size );
    }
    else
      (void)FT_QALLOC( target->buffer, size );

    if ( !error )
    {
      unsigned char *p;


      p = target->buffer;
      *target = *source;
      target->buffer = p;

      if ( source_pitch_sign == target_pitch_sign )
        FT_MEM_COPY( target->buffer, source->buffer, size );
      else
      {
        /* take care of bitmap flow */
        FT_UInt   i;
        FT_Byte*  s = source->buffer;
        FT_Byte*  t = target->buffer;


        t += (FT_ULong)pitch * ( target->rows - 1 );

        for ( i = target->rows; i > 0; i-- )
        {
          FT_ARRAY_COPY( t, s, pitch );

          s += pitch;
          t -= pitch;
        }
      }
    }

    return error;
  }


  /* Enlarge `bitmap' horizontally and vertically by `xpixels' */
  /* and `ypixels', respectively.                              */

  static FT_Error
  ft_bitmap_assure_buffer( FT_Memory   memory,
                           FT_Bitmap*  bitmap,
                           FT_UInt     xpixels,
                           FT_UInt     ypixels )
  {
    FT_Error        error;
    int             pitch;
    int             new_pitch;
    FT_UInt         bpp;
    FT_UInt         i, width, height;
    unsigned char*  buffer = NULL;


    width  = bitmap->width;
    height = bitmap->rows;
    pitch  = bitmap->pitch;
    if ( pitch < 0 )
      pitch = -pitch;

    switch ( bitmap->pixel_mode )
    {
    case FT_PIXEL_MODE_MONO:
      bpp       = 1;
      new_pitch = (int)( ( width + xpixels + 7 ) >> 3 );
      break;
    case FT_PIXEL_MODE_GRAY2:
      bpp       = 2;
      new_pitch = (int)( ( width + xpixels + 3 ) >> 2 );
      break;
    case FT_PIXEL_MODE_GRAY4:
      bpp       = 4;
      new_pitch = (int)( ( width + xpixels + 1 ) >> 1 );
      break;
    case FT_PIXEL_MODE_GRAY:
    case FT_PIXEL_MODE_LCD:
    case FT_PIXEL_MODE_LCD_V:
      bpp       = 8;
      new_pitch = (int)( width + xpixels );
      break;
    default:
      return FT_THROW( Invalid_Glyph_Format );
    }

    /* if no need to allocate memory */
    if ( ypixels == 0 && new_pitch <= pitch )
    {
      /* zero the padding */
      FT_UInt  bit_width = (FT_UInt)pitch * 8;
      FT_UInt  bit_last  = ( width + xpixels ) * bpp;


      if ( bit_last < bit_width )
      {
        FT_Byte*  line  = bitmap->buffer + ( bit_last >> 3 );
        FT_Byte*  end   = bitmap->buffer + pitch;
        FT_UInt   shift = bit_last & 7;
        FT_UInt   mask  = 0xFF00U >> shift;
        FT_UInt   count = height;


        for ( ; count > 0; count--, line += pitch, end += pitch )
        {
          FT_Byte*  write = line;


          if ( shift > 0 )
          {
            write[0] = (FT_Byte)( write[0] & mask );
            write++;
          }
          if ( write < end )
            FT_MEM_ZERO( write, end - write );
        }
      }

      return FT_Err_Ok;
    }

    /* otherwise allocate new buffer */
    if ( FT_QALLOC_MULT( buffer, new_pitch, bitmap->rows + ypixels ) )
      return error;

    /* new rows get added at the top of the bitmap, */
    /* thus take care of the flow direction         */
    if ( bitmap->pitch > 0 )
    {
      FT_UInt  len = ( width * bpp + 7 ) >> 3;


      for ( i = 0; i < bitmap->rows; i++ )
        FT_MEM_COPY( buffer + (FT_UInt)new_pitch * ( ypixels + i ),
                     bitmap->buffer + (FT_UInt)pitch * i,
                     len );
    }
    else
    {
      FT_UInt  len = ( width * bpp + 7 ) >> 3;


      for ( i = 0; i < bitmap->rows; i++ )
        FT_MEM_COPY( buffer + (FT_UInt)new_pitch * i,
                     bitmap->buffer + (FT_UInt)pitch * i,
                     len );
    }

    FT_FREE( bitmap->buffer );
    bitmap->buffer = buffer;

    if ( bitmap->pitch < 0 )
      new_pitch = -new_pitch;

    /* set pitch only, width and height are left untouched */
    bitmap->pitch = new_pitch;

    return FT_Err_Ok;
  }


  /* documentation is in ftbitmap.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Bitmap_Embolden( FT_Library  library,
                      FT_Bitmap*  bitmap,
                      FT_Pos      xStrength,
                      FT_Pos      yStrength )
  {
    FT_Error        error;
    unsigned char*  p;
    FT_Int          i, x, pitch;
    FT_UInt         y;
    FT_Int          xstr, ystr;


    if ( !library )
      return FT_THROW( Invalid_Library_Handle );

    if ( !bitmap || !bitmap->buffer )
      return FT_THROW( Invalid_Argument );

    if ( ( ( FT_PIX_ROUND( xStrength ) >> 6 ) > FT_INT_MAX ) ||
         ( ( FT_PIX_ROUND( yStrength ) >> 6 ) > FT_INT_MAX ) )
      return FT_THROW( Invalid_Argument );

    xstr = (FT_Int)FT_PIX_ROUND( xStrength ) >> 6;
    ystr = (FT_Int)FT_PIX_ROUND( yStrength ) >> 6;

    if ( xstr == 0 && ystr == 0 )
      return FT_Err_Ok;
    else if ( xstr < 0 || ystr < 0 )
      return FT_THROW( Invalid_Argument );

    switch ( bitmap->pixel_mode )
    {
    case FT_PIXEL_MODE_GRAY2:
    case FT_PIXEL_MODE_GRAY4:
      {
        FT_Bitmap  tmp;


        /* convert to 8bpp */
        FT_Bitmap_Init( &tmp );
        error = FT_Bitmap_Convert( library, bitmap, &tmp, 1 );
        if ( error )
          return error;

        FT_Bitmap_Done( library, bitmap );
        *bitmap = tmp;
      }
      break;

    case FT_PIXEL_MODE_MONO:
      if ( xstr > 8 )
        xstr = 8;
      break;

    case FT_PIXEL_MODE_LCD:
      xstr *= 3;
      break;

    case FT_PIXEL_MODE_LCD_V:
      ystr *= 3;
      break;

    case FT_PIXEL_MODE_BGRA:
      /* We don't embolden color glyphs. */
      return FT_Err_Ok;
    }

    error = ft_bitmap_assure_buffer( library->memory, bitmap,
                                     (FT_UInt)xstr, (FT_UInt)ystr );
    if ( error )
      return error;

    /* take care of bitmap flow */
    pitch = bitmap->pitch;
    if ( pitch > 0 )
      p = bitmap->buffer + pitch * ystr;
    else
    {
      pitch = -pitch;
      p = bitmap->buffer + (FT_UInt)pitch * ( bitmap->rows - 1 );
    }

    /* for each row */
    for ( y = 0; y < bitmap->rows; y++ )
    {
      /*
       * Horizontally:
       *
       * From the last pixel on, make each pixel or'ed with the
       * `xstr' pixels before it.
       */
      for ( x = pitch - 1; x >= 0; x-- )
      {
        unsigned char  tmp;


        tmp = p[x];
        for ( i = 1; i <= xstr; i++ )
        {
          if ( bitmap->pixel_mode == FT_PIXEL_MODE_MONO )
          {
            p[x] |= tmp >> i;

            /* the maximum value of 8 for `xstr' comes from here */
            if ( x > 0 )
              p[x] |= p[x - 1] << ( 8 - i );

#if 0
            if ( p[x] == 0xFF )
              break;
#endif
          }
          else
          {
            if ( x - i >= 0 )
            {
              if ( p[x] + p[x - i] > bitmap->num_grays - 1 )
              {
                p[x] = (unsigned char)( bitmap->num_grays - 1 );
                break;
              }
              else
              {
                p[x] = (unsigned char)( p[x] + p[x - i] );
                if ( p[x] == bitmap->num_grays - 1 )
                  break;
              }
            }
            else
              break;
          }
        }
      }

      /*
       * Vertically:
       *
       * Make the above `ystr' rows or'ed with it.
       */
      for ( x = 1; x <= ystr; x++ )
      {
        unsigned char*  q;


        q = p - bitmap->pitch * x;
        for ( i = 0; i < pitch; i++ )
          q[i] |= p[i];
      }

      p += bitmap->pitch;
    }

    bitmap->width += (FT_UInt)xstr;
    bitmap->rows += (FT_UInt)ystr;

    return FT_Err_Ok;
  }


  static FT_Byte
  ft_gray_for_premultiplied_srgb_bgra( const FT_Byte*  bgra )
  {
    FT_UInt  a = bgra[3];
    FT_UInt  l;


    /* Short-circuit transparent color to avoid division by zero. */
    if ( !a )
      return 0;

    /*
     * Luminosity for sRGB is defined using ~0.2126,0.7152,0.0722
     * coefficients for RGB channels *on the linear colors*.
     * A gamma of 2.2 is fair to assume.  And then, we need to
     * undo the premultiplication too.
     *
     *   http://accessibility.kde.org/hsl-adjusted.php
     *
     * We do the computation with integers only, applying a gamma of 2.0.
     * We guarantee 32-bit arithmetic to avoid overflow but the resulting
     * luminosity fits into 16 bits.
     *
     */

    l = (  4732UL /* 0.0722 * 65536 */ * bgra[0] * bgra[0] +
          46871UL /* 0.7152 * 65536 */ * bgra[1] * bgra[1] +
          13933UL /* 0.2126 * 65536 */ * bgra[2] * bgra[2] ) >> 16;

    /*
     * Final transparency can be determined as follows.
     *
     * - If alpha is zero, we want 0.
     * - If alpha is zero and luminosity is zero, we want 255.
     * - If alpha is zero and luminosity is one, we want 0.
     *
     * So the formula is a * (1 - l) = a - l * a.
     *
     * We still need to undo premultiplication by dividing l by a*a.
     *
     */

    return (FT_Byte)( a - l / a );
  }


  /* documentation is in ftbitmap.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Bitmap_Convert( FT_Library        library,
                     const FT_Bitmap  *source,
                     FT_Bitmap        *target,
                     FT_Int            alignment )
  {
    FT_Error   error = FT_Err_Ok;
    FT_Memory  memory;

    FT_Byte*  s;
    FT_Byte*  t;


    if ( !library )
      return FT_THROW( Invalid_Library_Handle );

    if ( !source || !target )
      return FT_THROW( Invalid_Argument );

    memory = library->memory;

    switch ( source->pixel_mode )
    {
    case FT_PIXEL_MODE_MONO:
    case FT_PIXEL_MODE_GRAY:
    case FT_PIXEL_MODE_GRAY2:
    case FT_PIXEL_MODE_GRAY4:
    case FT_PIXEL_MODE_LCD:
    case FT_PIXEL_MODE_LCD_V:
    case FT_PIXEL_MODE_BGRA:
      {
        FT_Int    pad, old_target_pitch, target_pitch;
        FT_ULong  old_size;


        old_target_pitch = target->pitch;
        if ( old_target_pitch < 0 )
          old_target_pitch = -old_target_pitch;

        old_size = target->rows * (FT_UInt)old_target_pitch;

        target->pixel_mode = FT_PIXEL_MODE_GRAY;
        target->rows       = source->rows;
        target->width      = source->width;

        pad = 0;
        if ( alignment > 0 )
        {
          pad = (FT_Int)source->width % alignment;
          if ( pad != 0 )
            pad = alignment - pad;
        }

        target_pitch = (FT_Int)source->width + pad;

        if ( target_pitch > 0                                               &&
             (FT_ULong)target->rows > FT_ULONG_MAX / (FT_ULong)target_pitch )
          return FT_THROW( Invalid_Argument );

        if ( target->rows * (FT_ULong)target_pitch > old_size              &&
             FT_QREALLOC( target->buffer,
                          old_size, target->rows * (FT_UInt)target_pitch ) )
          return error;

        target->pitch = target->pitch < 0 ? -target_pitch : target_pitch;
      }
      break;

    default:
      error = FT_THROW( Invalid_Argument );
    }

    s = source->buffer;
    t = target->buffer;

    /* take care of bitmap flow */
    if ( source->pitch < 0 )
      s -= source->pitch * (FT_Int)( source->rows - 1 );
    if ( target->pitch < 0 )
      t -= target->pitch * (FT_Int)( target->rows - 1 );

    switch ( source->pixel_mode )
    {
    case FT_PIXEL_MODE_MONO:
      {
        FT_UInt  i;


        target->num_grays = 2;

        for ( i = source->rows; i > 0; i-- )
        {
          FT_Byte*  ss = s;
          FT_Byte*  tt = t;
          FT_UInt   j;


          /* get the full bytes */
          for ( j = source->width >> 3; j > 0; j-- )
          {
            FT_Int  val = ss[0]; /* avoid a byte->int cast on each line */


            tt[0] = (FT_Byte)( ( val & 0x80 ) >> 7 );
            tt[1] = (FT_Byte)( ( val & 0x40 ) >> 6 );
            tt[2] = (FT_Byte)( ( val & 0x20 ) >> 5 );
            tt[3] = (FT_Byte)( ( val & 0x10 ) >> 4 );
            tt[4] = (FT_Byte)( ( val & 0x08 ) >> 3 );
            tt[5] = (FT_Byte)( ( val & 0x04 ) >> 2 );
            tt[6] = (FT_Byte)( ( val & 0x02 ) >> 1 );
            tt[7] = (FT_Byte)(   val & 0x01 );

            tt += 8;
            ss += 1;
          }

          /* get remaining pixels (if any) */
          j = source->width & 7;
          if ( j > 0 )
          {
            FT_Int  val = *ss;


            for ( ; j > 0; j-- )
            {
              tt[0] = (FT_Byte)( ( val & 0x80 ) >> 7);
              val <<= 1;
              tt   += 1;
            }
          }

          s += source->pitch;
          t += target->pitch;
        }
      }
      break;


    case FT_PIXEL_MODE_GRAY:
    case FT_PIXEL_MODE_LCD:
    case FT_PIXEL_MODE_LCD_V:
      {
        FT_UInt  width = source->width;
        FT_UInt  i;


        target->num_grays = 256;

        for ( i = source->rows; i > 0; i-- )
        {
          FT_ARRAY_COPY( t, s, width );

          s += source->pitch;
          t += target->pitch;
        }
      }
      break;


    case FT_PIXEL_MODE_GRAY2:
      {
        FT_UInt  i;


        target->num_grays = 4;

        for ( i = source->rows; i > 0; i-- )
        {
          FT_Byte*  ss = s;
          FT_Byte*  tt = t;
          FT_UInt   j;


          /* get the full bytes */
          for ( j = source->width >> 2; j > 0; j-- )
          {
            FT_Int  val = ss[0];


            tt[0] = (FT_Byte)( ( val & 0xC0 ) >> 6 );
            tt[1] = (FT_Byte)( ( val & 0x30 ) >> 4 );
            tt[2] = (FT_Byte)( ( val & 0x0C ) >> 2 );
            tt[3] = (FT_Byte)( ( val & 0x03 ) );

            ss += 1;
            tt += 4;
          }

          j = source->width & 3;
          if ( j > 0 )
          {
            FT_Int  val = ss[0];


            for ( ; j > 0; j-- )
            {
              tt[0]  = (FT_Byte)( ( val & 0xC0 ) >> 6 );
              val  <<= 2;
              tt    += 1;
            }
          }

          s += source->pitch;
          t += target->pitch;
        }
      }
      break;


    case FT_PIXEL_MODE_GRAY4:
      {
        FT_UInt  i;


        target->num_grays = 16;

        for ( i = source->rows; i > 0; i-- )
        {
          FT_Byte*  ss = s;
          FT_Byte*  tt = t;
          FT_UInt   j;


          /* get the full bytes */
          for ( j = source->width >> 1; j > 0; j-- )
          {
            FT_Int  val = ss[0];


            tt[0] = (FT_Byte)( ( val & 0xF0 ) >> 4 );
            tt[1] = (FT_Byte)( ( val & 0x0F ) );

            ss += 1;
            tt += 2;
          }

          if ( source->width & 1 )
            tt[0] = (FT_Byte)( ( ss[0] & 0xF0 ) >> 4 );

          s += source->pitch;
          t += target->pitch;
        }
      }
      break;


    case FT_PIXEL_MODE_BGRA:
      {
        FT_UInt  i;


        target->num_grays = 256;

        for ( i = source->rows; i > 0; i-- )
        {
          FT_Byte*  ss = s;
          FT_Byte*  tt = t;
          FT_UInt   j;


          for ( j = source->width; j > 0; j-- )
          {
            tt[0] = ft_gray_for_premultiplied_srgb_bgra( ss );

            ss += 4;
            tt += 1;
          }

          s += source->pitch;
          t += target->pitch;
        }
      }
      break;

    default:
      ;
    }

    return error;
  }


  /* documentation is in ftbitmap.h */

  FT_EXPORT_DEF( FT_Error )
  FT_GlyphSlot_Own_Bitmap( FT_GlyphSlot  slot )
  {
    if ( slot && slot->format == FT_GLYPH_FORMAT_BITMAP   &&
         !( slot->internal->flags & FT_GLYPH_OWN_BITMAP ) )
    {
      FT_Bitmap  bitmap;
      FT_Error   error;


      FT_Bitmap_Init( &bitmap );
      error = FT_Bitmap_Copy( slot->library, &slot->bitmap, &bitmap );
      if ( error )
        return error;

      slot->bitmap = bitmap;
      slot->internal->flags |= FT_GLYPH_OWN_BITMAP;
    }

    return FT_Err_Ok;
  }


  /* documentation is in ftbitmap.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Bitmap_Done( FT_Library  library,
                  FT_Bitmap  *bitmap )
  {
    FT_Memory  memory;


    if ( !library )
      return FT_THROW( Invalid_Library_Handle );

    if ( !bitmap )
      return FT_THROW( Invalid_Argument );

    memory = library->memory;

    FT_FREE( bitmap->buffer );
    *bitmap = null_bitmap;

    return FT_Err_Ok;
  }


/* END */
@


1.16
log
@
Update to FreeType 2.6.5

ok matthieu@@
@
text
@d79 1
a79 1
    if ( source->buffer == NULL )
@


1.15
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d354 1
a354 1
    for ( y = 0; y < bitmap->rows ; y++ )
@


1.14
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2004-2015 by                                                 */
@


1.13
log
@
Bugfixing update to freetype-2.5.5

ok matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2004-2009, 2011, 2013, 2014 by                               */
d34 10
d130 1
a130 1
        t += pitch * ( target->rows - 1 );
d173 1
a173 1
      new_pitch = ( width + xpixels + 7 ) >> 3;
d177 1
a177 1
      new_pitch = ( width + xpixels + 3 ) >> 2;
d181 1
a181 1
      new_pitch = ( width + xpixels + 1 ) >> 1;
d187 1
a187 1
      new_pitch = ( width + xpixels );
d197 1
a197 1
      FT_UInt  bit_width = pitch * 8;
d240 3
a242 2
        FT_MEM_COPY( buffer + new_pitch * ( ypixels + i ),
                     bitmap->buffer + pitch * i, len );
d250 3
a252 2
        FT_MEM_COPY( buffer + new_pitch * i,
                     bitmap->buffer + pitch * i, len );
d310 1
a310 1
        FT_Bitmap_New( &tmp );
d338 2
a339 1
    error = ft_bitmap_assure_buffer( library->memory, bitmap, xstr, ystr );
d350 1
a350 1
      p = bitmap->buffer + pitch * ( bitmap->rows - 1 );
d423 2
a424 2
    bitmap->width += xstr;
    bitmap->rows += ystr;
d517 1
a517 1
        old_size = target->rows * old_target_pitch;
d526 1
a526 1
          pad = source->width % alignment;
d531 1
a531 1
        target_pitch = source->width + pad;
d533 2
a534 2
        if ( target_pitch > 0                                     &&
             (FT_ULong)target->rows > FT_ULONG_MAX / target_pitch )
d537 1
a537 1
        if ( target->rows * target_pitch > old_size               &&
d539 1
a539 1
                          old_size, target->rows * target_pitch ) )
d555 1
a555 1
      s -= source->pitch * ( source->rows - 1 );
d557 1
a557 1
      t -= target->pitch * ( target->rows - 1 );
d620 1
a620 1
        FT_Int   width = source->width;
d772 1
a772 1
      FT_Bitmap_New( &bitmap );
@


1.12
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d366 1
a366 1
            if ( p[x] == 0xff )
@


1.11
log
@
Security/bugfixing update to freetype-2.5.3, featuring a fix for a
vulnerability in the CFF driver (CVE-2014-2240) and assorted minor
fixes.

ok matthieu@@
@
text
@d36 2
a37 1
    *abitmap = null_bitmap;
d48 1
a48 1
    FT_Memory  memory = library->memory;
a49 2
    FT_Int     pitch  = source->pitch;
    FT_ULong   size;
d51 11
d66 3
d72 2
d78 3
d83 1
a83 1
    size = (FT_ULong)( pitch * source->rows );
d91 1
a91 1
      if ( target_pitch < 0  )
d93 1
a93 1
      target_size = (FT_ULong)( target_pitch * target->rows );
d110 20
a129 1
      FT_MEM_COPY( target->buffer, source->buffer, size );
d136 3
d149 1
a149 1
    FT_Int          i, width, height;
d187 2
a188 2
      FT_Int  bit_width = pitch * 8;
      FT_Int  bit_last  = ( width + xpixels ) * bpp;
d195 1
a195 1
        FT_Int    shift = bit_last & 7;
d197 1
a197 1
        FT_Int    count = height;
d211 1
a211 1
            FT_MEM_ZERO( write, end-write );
d218 1
d222 2
d226 1
a226 1
      FT_Int  len = ( width * bpp + 7 ) >> 3;
d235 1
a235 1
      FT_Int  len = ( width * bpp + 7 ) >> 3;
d266 2
a267 1
    FT_Int          i, x, y, pitch;
a294 2
        FT_Int     align;

a295 4
        if ( bitmap->pixel_mode == FT_PIXEL_MODE_GRAY2 )
          align = ( bitmap->width + xstr + 3 ) / 4;
        else
          align = ( bitmap->width + xstr + 1 ) / 2;
d297 1
d299 1
a299 2

        error = FT_Bitmap_Convert( library, bitmap, &tmp, align );
d330 1
d351 1
a351 1
        unsigned char tmp;
d376 1
a376 1
                p[x] = (unsigned char)(bitmap->num_grays - 1);
d381 1
a381 1
                p[x] = (unsigned char)(p[x] + p[x-i]);
d420 2
a421 5
    FT_Long  a = bgra[3];
    FT_Long  b = bgra[0];
    FT_Long  g = bgra[1];
    FT_Long  r = bgra[2];
    FT_Long  l;
d424 1
a424 1
    /* Short-circuit transparent color to avoid div-by-zero. */
d434 5
a438 1
     * http://accessibility.kde.org/hsl-adjusted.php
a439 1
     * We do the computation with integers only.
d442 3
a444 17
    /* Undo premultification, get the number in a 16.16 form. */
    b = FT_MulDiv( b, 65536, a );
    g = FT_MulDiv( g, 65536, a );
    r = FT_MulDiv( r, 65536, a );
    a = a * 256;

    /* Apply gamma of 2.0 instead of 2.2. */
    b = FT_MulFix( b, b );
    g = FT_MulFix( g, g );
    r = FT_MulFix( r, r );

    /* Apply coefficients. */
    b = FT_MulFix( b,  4731 /* 0.0722 * 65536 */ );
    g = FT_MulFix( g, 46871 /* 0.7152 * 65536 */ );
    r = FT_MulFix( r, 13933 /* 0.2126 * 65536 */ );

    l = r + g + b;
d447 1
a447 1
     * Final transparency can be determined this way:
d453 4
a456 1
     * So the formula is a * (1 - l).
d459 1
a459 1
    return (FT_Byte)( FT_MulFix( 65535 - l, a ) >> 8 );
d474 3
d481 3
d496 3
a498 2
        FT_Int   pad;
        FT_Long  old_size;
d500 3
d504 1
a504 3
        old_size = target->rows * target->pitch;
        if ( old_size < 0 )
          old_size = -old_size;
d518 1
a518 1
        target->pitch = source->width + pad;
d520 2
a521 2
        if ( target->pitch > 0                                     &&
             (FT_ULong)target->rows > FT_ULONG_MAX / target->pitch )
d524 1
a524 1
        if ( target->rows * target->pitch > old_size             &&
d526 1
a526 1
                          old_size, target->rows * target->pitch ) )
d528 2
d537 9
d550 1
a550 3
        FT_Byte*  s = source->buffer;
        FT_Byte*  t = target->buffer;
        FT_Int    i;
d559 1
a559 1
          FT_Int    j;
d607 2
a608 6
        FT_Int    width   = source->width;
        FT_Byte*  s       = source->buffer;
        FT_Byte*  t       = target->buffer;
        FT_Int    s_pitch = source->pitch;
        FT_Int    t_pitch = target->pitch;
        FT_Int    i;
d617 2
a618 2
          s += s_pitch;
          t += t_pitch;
d626 1
a626 3
        FT_Byte*  s = source->buffer;
        FT_Byte*  t = target->buffer;
        FT_Int    i;
d635 1
a635 1
          FT_Int    j;
d676 1
a676 3
        FT_Byte*  s = source->buffer;
        FT_Byte*  t = target->buffer;
        FT_Int    i;
d685 1
a685 1
          FT_Int    j;
d710 1
d713 1
a713 5
        FT_Byte*  s       = source->buffer;
        FT_Byte*  t       = target->buffer;
        FT_Int    s_pitch = source->pitch;
        FT_Int    t_pitch = target->pitch;
        FT_Int    i;
d722 1
a722 1
          FT_Int    j;
d733 2
a734 2
          s += s_pitch;
          t += t_pitch;
@


1.11.2.1
log
@backport fixes from freetype 2.5.5 for malformed fonts.
fixes dug out of ubuntu by dcoppa@@
@
text
@d65 1
a65 1
    size = (FT_ULong)pitch * source->rows;
d75 1
a75 1
      target_size = (FT_ULong)target_pitch * target->rows;
d109 1
a109 1
    FT_UInt         i, width, height;
d147 2
a148 2
      FT_UInt  bit_width = pitch * 8;
      FT_UInt  bit_last  = ( width + xpixels ) * bpp;
d155 1
a155 1
        FT_UInt   shift = bit_last & 7;
d157 1
a157 1
        FT_UInt   count = height;
d183 1
a183 1
      FT_UInt  len = ( width * bpp + 7 ) >> 3;
d192 1
a192 1
      FT_UInt  len = ( width * bpp + 7 ) >> 3;
d223 1
a223 2
    FT_Int          i, x, pitch;
    FT_UInt         y;
d463 1
a463 1
        FT_ULong  old_size;
@


1.10
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d7 1
a7 1
/*  Copyright 2004-2009, 2011, 2013 by                                     */
d378 1
a378 1
  FT_Byte
@


1.10.2.1
log
@backport fixes for malformed fonts from freetype 2.5.5.
fixes dug out of ubuntu by dcoppa@@
@
text
@d65 1
a65 1
    size = (FT_ULong)pitch * source->rows;
d75 1
a75 1
      target_size = (FT_ULong)target_pitch * target->rows;
d109 1
a109 1
    FT_UInt         i, width, height;
d147 2
a148 2
      FT_UInt  bit_width = pitch * 8;
      FT_UInt  bit_last  = ( width + xpixels ) * bpp;
d155 1
a155 1
        FT_UInt   shift = bit_last & 7;
d157 1
a157 1
        FT_UInt   count = height;
d183 1
a183 1
      FT_UInt  len = ( width * bpp + 7 ) >> 3;
d192 1
a192 1
      FT_UInt  len = ( width * bpp + 7 ) >> 3;
d223 1
a223 2
    FT_Int          i, x, pitch;
    FT_UInt         y;
d463 1
a463 1
        FT_ULong  old_size;
@


1.9
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@d388 4
@


1.8
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@d282 4
d378 53
d456 1
d669 31
@


1.7
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@d7 1
a7 1
/*  Copyright 2004-2009, 2011 by                                           */
d20 2
d140 1
a140 1
      return FT_Err_Invalid_Glyph_Format;
d228 1
a228 1
      return FT_Err_Invalid_Library_Handle;
d231 1
a231 1
      return FT_Err_Invalid_Argument;
d235 1
a235 1
      return FT_Err_Invalid_Argument;
d243 1
a243 1
      return FT_Err_Invalid_Argument;
d387 1
a387 1
      return FT_Err_Invalid_Library_Handle;
d424 1
a424 1
          return FT_Err_Invalid_Argument;
d434 1
a434 1
      error = FT_Err_Invalid_Argument;
d655 1
a655 1
      return FT_Err_Invalid_Library_Handle;
d658 1
a658 1
      return FT_Err_Invalid_Argument;
@


1.6
log
@Update to freetype 2.4.8. Security update fixing CVE-2011-3439
@
text
@d234 1
a234 1
       
@


1.5
log
@Update to freetype 2.4.7.

This moslty is a bug-fix release for CVE-2011-3256.
@
text
@d420 2
a421 2
        if ( target->pitch > 0                           &&
             target->rows > FT_ULONG_MAX / target->pitch )
@


1.4
log
@Update to freetype 2.4.5. Tested by many.
@
text
@d7 1
a7 1
/*  Copyright 2004, 2005, 2006, 2007, 2008, 2009 by                        */
d419 4
@


1.3
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d108 1
a108 1
    unsigned char*  buffer;
@


1.2
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d231 6
a236 2
    xstr = FT_PIX_ROUND( xStrength ) >> 6;
    ystr = FT_PIX_ROUND( yStrength ) >> 6;
@


1.1
log
@Initial revision
@
text
@d5 1
a5 2
/*    FreeType utility functions for converting 1bpp, 2bpp, 4bpp, and 8bpp */
/*    bitmaps into 8bpp format (body).                                     */
d7 1
a7 1
/*  Copyright 2004, 2005, 2006 by                                          */
d21 1
d106 2
a107 2
    FT_UInt         ppb;
    FT_Int          i;
d111 3
a113 1
    pitch = bitmap->pitch;
d120 2
a121 1
      ppb = 8;
d124 2
a125 1
      ppb = 4;
d128 2
a129 1
      ppb = 2;
d134 2
a135 1
      ppb = 1;
d142 1
a142 1
    if ( ypixels == 0 && pitch * ppb >= bitmap->width + xpixels )
d145 5
a149 1
      for ( i = 0; i < bitmap->rows; i++ )
d151 5
a155 4
        unsigned char*  last_byte;
        int             bits = xpixels * ( 8 / ppb );
        int             mask = 0;

a156 1
        last_byte = bitmap->buffer + i * pitch + ( bitmap->width - 1 ) / ppb;
d158 1
a158 1
        if ( bits >= 8 )
d160 1
a160 3
          FT_MEM_ZERO( last_byte + 1, bits / 8 );
          bits %= 8;
        }
a161 4
        if ( bits > 0 )
        {
          while ( bits-- > 0 )
            mask |= 1 << bits;
d163 7
a169 1
          *last_byte &= ~mask;
a175 2
    new_pitch = ( bitmap->width + xpixels + ppb - 1 ) / ppb;

d181 3
d186 1
a186 1
                     bitmap->buffer + pitch * i, pitch );
d190 3
d195 1
a195 1
                     bitmap->buffer + pitch * i, pitch );
d204 1
a204 1
    /* set pitch only */
d254 1
a255 1

d391 2
d487 2
d607 25
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d8 1
a8 1
/*  Copyright 2004, 2005, 2006, 2007 by                                    */
d106 2
a107 2
    FT_UInt         bpp;
    FT_Int          i, width, height;
d111 1
a111 3
    width  = bitmap->width;
    height = bitmap->rows;
    pitch  = bitmap->pitch;
d118 1
a118 2
      bpp       = 1;
      new_pitch = ( width + xpixels + 7 ) >> 3;
d121 1
a121 2
      bpp       = 2;
      new_pitch = ( width + xpixels + 3 ) >> 2;
d124 1
a124 2
      bpp       = 4;
      new_pitch = ( width + xpixels + 1 ) >> 1;
d129 1
a129 2
      bpp       = 8;
      new_pitch = ( width + xpixels );
d136 1
a136 1
    if ( ypixels == 0 && new_pitch <= pitch )
d139 5
a143 2
      FT_Int  bit_width = pitch * 8;
      FT_Int  bit_last  = ( width + xpixels ) * bpp;
d146 1
a146 7
      if ( bit_last < bit_width )
      {
        FT_Byte*  line  = bitmap->buffer + ( bit_last >> 3 );
        FT_Byte*  end   = bitmap->buffer + pitch;
        FT_Int    shift = bit_last & 7;
        FT_UInt   mask  = 0xFF00U >> shift;
        FT_Int    count = height;
d148 5
d154 1
a154 1
        for ( ; count > 0; count--, line += pitch, end += pitch )
d156 2
a157 2
          FT_Byte*  write = line;

d159 1
a159 7
          if ( shift > 0 )
          {
            write[0] = (FT_Byte)( write[0] & mask );
            write++;
          }
          if ( write < end )
            FT_MEM_ZERO( write, end-write );
d166 2
a172 3
      FT_Int  len = ( width * bpp + 7 ) >> 3;


d175 1
a175 1
                     bitmap->buffer + pitch * i, len );
a178 3
      FT_Int  len = ( width * bpp + 7 ) >> 3;


d181 1
a181 1
                     bitmap->buffer + pitch * i, len );
d190 1
a190 1
    /* set pitch only, width and height are left untouched */
d240 1
a241 1
        error = FT_Bitmap_Convert( library, bitmap, &tmp, align );
@

