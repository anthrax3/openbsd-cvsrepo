head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.2
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.2
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.8
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2017.01.13.11.19.59;	author dcoppa;	state Exp;
branches;
next	1.15;
commitid	ESXG9TuEmwmBXggf;

1.15
date	2016.05.29.11.57.12;	author dcoppa;	state Exp;
branches;
next	1.14;
commitid	1dOLexdOAzW2mQjp;

1.14
date	2015.10.19.07.51.37;	author dcoppa;	state Exp;
branches;
next	1.13;
commitid	d2XmJCtYff11VIDu;

1.13
date	2015.06.28.08.27.47;	author dcoppa;	state Exp;
branches;
next	1.12;
commitid	qXwIGV2h9uFjxAmt;

1.12
date	2015.01.10.17.17.23;	author dcoppa;	state Exp;
branches;
next	1.11;
commitid	2tSYQMWVSV3t7clo;

1.11
date	2014.12.26.17.52.35;	author dcoppa;	state Exp;
branches;
next	1.10;
commitid	gwhRExMduYqoPQHI;

1.10
date	2014.03.14.08.18.01;	author dcoppa;	state Exp;
branches;
next	1.9;

1.9
date	2014.01.12.15.08.27;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.10.19.49.49;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.21.09;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.04.14.09.45.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.25.20.49.54;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.10.20.28.35;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.21.05.09.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.41;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.33.02;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftcalc.c                                                               */
/*                                                                         */
/*    Arithmetic computations (body).                                      */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* Support for 1-complement arithmetic has been totally dropped in this  */
  /* release.  You can still write your own code if you need it.           */
  /*                                                                       */
  /*************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* Implementing basic computation routines.                              */
  /*                                                                       */
  /* FT_MulDiv(), FT_MulFix(), FT_DivFix(), FT_RoundFix(), FT_CeilFix(),   */
  /* and FT_FloorFix() are declared in freetype.h.                         */
  /*                                                                       */
  /*************************************************************************/


#include <ft2build.h>
#include FT_GLYPH_H
#include FT_TRIGONOMETRY_H
#include FT_INTERNAL_CALC_H
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_OBJECTS_H


#ifdef FT_MULFIX_ASSEMBLER
#undef FT_MulFix
#endif

/* we need to emulate a 64-bit data type if a real one isn't available */

#ifndef FT_LONG64

  typedef struct  FT_Int64_
  {
    FT_UInt32  lo;
    FT_UInt32  hi;

  } FT_Int64;

#endif /* !FT_LONG64 */


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_calc


  /* transfer sign leaving a positive number */
#define FT_MOVE_SIGN( x, s ) \
  FT_BEGIN_STMNT             \
    if ( x < 0 )             \
    {                        \
      x = -x;                \
      s = -s;                \
    }                        \
  FT_END_STMNT

  /* The following three functions are available regardless of whether */
  /* FT_LONG64 is defined.                                             */

  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Fixed )
  FT_RoundFix( FT_Fixed  a )
  {
    return ( a + 0x8000L - ( a < 0 ) ) & ~0xFFFFL;
  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Fixed )
  FT_CeilFix( FT_Fixed  a )
  {
    return ( a + 0xFFFFL ) & ~0xFFFFL;
  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Fixed )
  FT_FloorFix( FT_Fixed  a )
  {
    return a & ~0xFFFFL;
  }

#ifndef FT_MSB

  FT_BASE_DEF ( FT_Int )
  FT_MSB( FT_UInt32 z )
  {
    FT_Int  shift = 0;


    /* determine msb bit index in `shift' */
    if ( z & 0xFFFF0000UL )
    {
      z     >>= 16;
      shift  += 16;
    }
    if ( z & 0x0000FF00UL )
    {
      z     >>= 8;
      shift  += 8;
    }
    if ( z & 0x000000F0UL )
    {
      z     >>= 4;
      shift  += 4;
    }
    if ( z & 0x0000000CUL )
    {
      z     >>= 2;
      shift  += 2;
    }
    if ( z & 0x00000002UL )
    {
   /* z     >>= 1; */
      shift  += 1;
    }

    return shift;
  }

#endif /* !FT_MSB */


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Fixed )
  FT_Hypot( FT_Fixed  x,
            FT_Fixed  y )
  {
    FT_Vector  v;


    v.x = x;
    v.y = y;

    return FT_Vector_Length( &v );
  }


#ifdef FT_LONG64


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Long )
  FT_MulDiv( FT_Long  a_,
             FT_Long  b_,
             FT_Long  c_ )
  {
    FT_Int     s = 1;
    FT_UInt64  a, b, c, d;
    FT_Long    d_;


    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
    FT_MOVE_SIGN( c_, s );

    a = (FT_UInt64)a_;
    b = (FT_UInt64)b_;
    c = (FT_UInt64)c_;

    d = c > 0 ? ( a * b + ( c >> 1 ) ) / c
              : 0x7FFFFFFFUL;

    d_ = (FT_Long)d;

    return s < 0 ? -d_ : d_;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Long )
  FT_MulDiv_No_Round( FT_Long  a_,
                      FT_Long  b_,
                      FT_Long  c_ )
  {
    FT_Int     s = 1;
    FT_UInt64  a, b, c, d;
    FT_Long    d_;


    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
    FT_MOVE_SIGN( c_, s );

    a = (FT_UInt64)a_;
    b = (FT_UInt64)b_;
    c = (FT_UInt64)c_;

    d = c > 0 ? a * b / c
              : 0x7FFFFFFFUL;

    d_ = (FT_Long)d;

    return s < 0 ? -d_ : d_;
  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Long )
  FT_MulFix( FT_Long  a_,
             FT_Long  b_ )
  {
#ifdef FT_MULFIX_ASSEMBLER

    return FT_MULFIX_ASSEMBLER( (FT_Int32)a_, (FT_Int32)b_ );

#else

    FT_Int64  ab = (FT_Int64)a_ * (FT_Int64)b_;

    /* this requires arithmetic right shift of signed numbers */
    return (FT_Long)( ( ab + 0x8000L - ( ab < 0 ) ) >> 16 );

#endif /* FT_MULFIX_ASSEMBLER */
  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Long )
  FT_DivFix( FT_Long  a_,
             FT_Long  b_ )
  {
    FT_Int     s = 1;
    FT_UInt64  a, b, q;
    FT_Long    q_;


    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );

    a = (FT_UInt64)a_;
    b = (FT_UInt64)b_;

    q = b > 0 ? ( ( a << 16 ) + ( b >> 1 ) ) / b
              : 0x7FFFFFFFUL;

    q_ = (FT_Long)q;

    return s < 0 ? -q_ : q_;
  }


#else /* !FT_LONG64 */


  static void
  ft_multo64( FT_UInt32  x,
              FT_UInt32  y,
              FT_Int64  *z )
  {
    FT_UInt32  lo1, hi1, lo2, hi2, lo, hi, i1, i2;


    lo1 = x & 0x0000FFFFU;  hi1 = x >> 16;
    lo2 = y & 0x0000FFFFU;  hi2 = y >> 16;

    lo = lo1 * lo2;
    i1 = lo1 * hi2;
    i2 = lo2 * hi1;
    hi = hi1 * hi2;

    /* Check carry overflow of i1 + i2 */
    i1 += i2;
    hi += (FT_UInt32)( i1 < i2 ) << 16;

    hi += i1 >> 16;
    i1  = i1 << 16;

    /* Check carry overflow of i1 + lo */
    lo += i1;
    hi += ( lo < i1 );

    z->lo = lo;
    z->hi = hi;
  }


  static FT_UInt32
  ft_div64by32( FT_UInt32  hi,
                FT_UInt32  lo,
                FT_UInt32  y )
  {
    FT_UInt32  r, q;
    FT_Int     i;


    if ( hi >= y )
      return (FT_UInt32)0x7FFFFFFFL;

    /* We shift as many bits as we can into the high register, perform     */
    /* 32-bit division with modulo there, then work through the remaining  */
    /* bits with long division. This optimization is especially noticeable */
    /* for smaller dividends that barely use the high register.            */

    i = 31 - FT_MSB( hi );
    r = ( hi << i ) | ( lo >> ( 32 - i ) ); lo <<= i; /* left 64-bit shift */
    q = r / y;
    r -= q * y;   /* remainder */

    i = 32 - i;   /* bits remaining in low register */
    do
    {
      q <<= 1;
      r   = ( r << 1 ) | ( lo >> 31 ); lo <<= 1;

      if ( r >= y )
      {
        r -= y;
        q |= 1;
      }
    } while ( --i );

    return q;
  }


  static void
  FT_Add64( FT_Int64*  x,
            FT_Int64*  y,
            FT_Int64  *z )
  {
    FT_UInt32  lo, hi;


    lo = x->lo + y->lo;
    hi = x->hi + y->hi + ( lo < x->lo );

    z->lo = lo;
    z->hi = hi;
  }


  /*  The FT_MulDiv function has been optimized thanks to ideas from     */
  /*  Graham Asher and Alexei Podtelezhnikov.  The trick is to optimize  */
  /*  a rather common case when everything fits within 32-bits.          */
  /*                                                                     */
  /*  We compute 'a*b+c/2', then divide it by 'c' (all positive values). */
  /*                                                                     */
  /*  The product of two positive numbers never exceeds the square of    */
  /*  its mean values.  Therefore, we always avoid the overflow by       */
  /*  imposing                                                           */
  /*                                                                     */
  /*    (a + b) / 2 <= sqrt(X - c/2)    ,                                */
  /*                                                                     */
  /*  where X = 2^32 - 1, the maximum unsigned 32-bit value, and using   */
  /*  unsigned arithmetic.  Now we replace `sqrt' with a linear function */
  /*  that is smaller or equal for all values of c in the interval       */
  /*  [0;X/2]; it should be equal to sqrt(X) and sqrt(3X/4) at the       */
  /*  endpoints.  Substituting the linear solution and explicit numbers  */
  /*  we get                                                             */
  /*                                                                     */
  /*    a + b <= 131071.99 - c / 122291.84    .                          */
  /*                                                                     */
  /*  In practice, we should use a faster and even stronger inequality   */
  /*                                                                     */
  /*    a + b <= 131071 - (c >> 16)                                      */
  /*                                                                     */
  /*  or, alternatively,                                                 */
  /*                                                                     */
  /*    a + b <= 129894 - (c >> 17)    .                                 */
  /*                                                                     */
  /*  FT_MulFix, on the other hand, is optimized for a small value of    */
  /*  the first argument, when the second argument can be much larger.   */
  /*  This can be achieved by scaling the second argument and the limit  */
  /*  in the above inequalities.  For example,                           */
  /*                                                                     */
  /*    a + (b >> 8) <= (131071 >> 4)                                    */
  /*                                                                     */
  /*  covers the practical range of use. The actual test below is a bit  */
  /*  tighter to avoid the border case overflows.                        */
  /*                                                                     */
  /*  In the case of FT_DivFix, the exact overflow check                 */
  /*                                                                     */
  /*    a << 16 <= X - c/2                                               */
  /*                                                                     */
  /*  is scaled down by 2^16 and we use                                  */
  /*                                                                     */
  /*    a <= 65535 - (c >> 17)    .                                      */

  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Long )
  FT_MulDiv( FT_Long  a_,
             FT_Long  b_,
             FT_Long  c_ )
  {
    FT_Int     s = 1;
    FT_UInt32  a, b, c;


    /* XXX: this function does not allow 64-bit arguments */

    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
    FT_MOVE_SIGN( c_, s );

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;
    c = (FT_UInt32)c_;

    if ( c == 0 )
      a = 0x7FFFFFFFUL;

    else if ( a + b <= 129894UL - ( c >> 17 ) )
      a = ( a * b + ( c >> 1 ) ) / c;

    else
    {
      FT_Int64  temp, temp2;


      ft_multo64( a, b, &temp );

      temp2.hi = 0;
      temp2.lo = c >> 1;

      FT_Add64( &temp, &temp2, &temp );

      /* last attempt to ditch long division */
      a = ( temp.hi == 0 ) ? temp.lo / c
                           : ft_div64by32( temp.hi, temp.lo, c );
    }

    a_ = (FT_Long)a;

    return s < 0 ? -a_ : a_;
  }


  FT_BASE_DEF( FT_Long )
  FT_MulDiv_No_Round( FT_Long  a_,
                      FT_Long  b_,
                      FT_Long  c_ )
  {
    FT_Int     s = 1;
    FT_UInt32  a, b, c;


    /* XXX: this function does not allow 64-bit arguments */

    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
    FT_MOVE_SIGN( c_, s );

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;
    c = (FT_UInt32)c_;

    if ( c == 0 )
      a = 0x7FFFFFFFUL;

    else if ( a + b <= 131071UL )
      a = a * b / c;

    else
    {
      FT_Int64  temp;


      ft_multo64( a, b, &temp );

      /* last attempt to ditch long division */
      a = ( temp.hi == 0 ) ? temp.lo / c
                           : ft_div64by32( temp.hi, temp.lo, c );
    }

    a_ = (FT_Long)a;

    return s < 0 ? -a_ : a_;
  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Long )
  FT_MulFix( FT_Long  a_,
             FT_Long  b_ )
  {
#ifdef FT_MULFIX_ASSEMBLER

    return FT_MULFIX_ASSEMBLER( a_, b_ );

#elif 0

    /*
     *  This code is nonportable.  See comment below.
     *
     *  However, on a platform where right-shift of a signed quantity fills
     *  the leftmost bits by copying the sign bit, it might be faster.
     */

    FT_Long    sa, sb;
    FT_UInt32  a, b;


    /*
     *  This is a clever way of converting a signed number `a' into its
     *  absolute value (stored back into `a') and its sign.  The sign is
     *  stored in `sa'; 0 means `a' was positive or zero, and -1 means `a'
     *  was negative.  (Similarly for `b' and `sb').
     *
     *  Unfortunately, it doesn't work (at least not portably).
     *
     *  It makes the assumption that right-shift on a negative signed value
     *  fills the leftmost bits by copying the sign bit.  This is wrong.
     *  According to K&R 2nd ed, section `A7.8 Shift Operators' on page 206,
     *  the result of right-shift of a negative signed value is
     *  implementation-defined.  At least one implementation fills the
     *  leftmost bits with 0s (i.e., it is exactly the same as an unsigned
     *  right shift).  This means that when `a' is negative, `sa' ends up
     *  with the value 1 rather than -1.  After that, everything else goes
     *  wrong.
     */
    sa = ( a_ >> ( sizeof ( a_ ) * 8 - 1 ) );
    a  = ( a_ ^ sa ) - sa;
    sb = ( b_ >> ( sizeof ( b_ ) * 8 - 1 ) );
    b  = ( b_ ^ sb ) - sb;

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;

    if ( a + ( b >> 8 ) <= 8190UL )
      a = ( a * b + 0x8000U ) >> 16;
    else
    {
      FT_UInt32  al = a & 0xFFFFUL;


      a = ( a >> 16 ) * b + al * ( b >> 16 ) +
          ( ( al * ( b & 0xFFFFUL ) + 0x8000UL ) >> 16 );
    }

    sa ^= sb;
    a   = ( a ^ sa ) - sa;

    return (FT_Long)a;

#else /* 0 */

    FT_Int     s = 1;
    FT_UInt32  a, b;


    /* XXX: this function does not allow 64-bit arguments */

    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;

    if ( a + ( b >> 8 ) <= 8190UL )
      a = ( a * b + 0x8000UL ) >> 16;
    else
    {
      FT_UInt32  al = a & 0xFFFFUL;


      a = ( a >> 16 ) * b + al * ( b >> 16 ) +
          ( ( al * ( b & 0xFFFFUL ) + 0x8000UL ) >> 16 );
    }

    a_ = (FT_Long)a;

    return s < 0 ? -a_ : a_;

#endif /* 0 */

  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Long )
  FT_DivFix( FT_Long  a_,
             FT_Long  b_ )
  {
    FT_Int     s = 1;
    FT_UInt32  a, b, q;
    FT_Long    q_;


    /* XXX: this function does not allow 64-bit arguments */

    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;

    if ( b == 0 )
    {
      /* check for division by 0 */
      q = 0x7FFFFFFFUL;
    }
    else if ( a <= 65535UL - ( b >> 17 ) )
    {
      /* compute result directly */
      q = ( ( a << 16 ) + ( b >> 1 ) ) / b;
    }
    else
    {
      /* we need more bits; we have to do it by hand */
      FT_Int64  temp, temp2;


      temp.hi  = a >> 16;
      temp.lo  = a << 16;
      temp2.hi = 0;
      temp2.lo = b >> 1;

      FT_Add64( &temp, &temp2, &temp );
      q = ft_div64by32( temp.hi, temp.lo, b );
    }

    q_ = (FT_Long)q;

    return s < 0 ? -q_ : q_;
  }


#endif /* !FT_LONG64 */


  /* documentation is in ftglyph.h */

  FT_EXPORT_DEF( void )
  FT_Matrix_Multiply( const FT_Matrix*  a,
                      FT_Matrix        *b )
  {
    FT_Fixed  xx, xy, yx, yy;


    if ( !a || !b )
      return;

    xx = FT_MulFix( a->xx, b->xx ) + FT_MulFix( a->xy, b->yx );
    xy = FT_MulFix( a->xx, b->xy ) + FT_MulFix( a->xy, b->yy );
    yx = FT_MulFix( a->yx, b->xx ) + FT_MulFix( a->yy, b->yx );
    yy = FT_MulFix( a->yx, b->xy ) + FT_MulFix( a->yy, b->yy );

    b->xx = xx;  b->xy = xy;
    b->yx = yx;  b->yy = yy;
  }


  /* documentation is in ftglyph.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Matrix_Invert( FT_Matrix*  matrix )
  {
    FT_Pos  delta, xx, yy;


    if ( !matrix )
      return FT_THROW( Invalid_Argument );

    /* compute discriminant */
    delta = FT_MulFix( matrix->xx, matrix->yy ) -
            FT_MulFix( matrix->xy, matrix->yx );

    if ( !delta )
      return FT_THROW( Invalid_Argument );  /* matrix can't be inverted */

    matrix->xy = - FT_DivFix( matrix->xy, delta );
    matrix->yx = - FT_DivFix( matrix->yx, delta );

    xx = matrix->xx;
    yy = matrix->yy;

    matrix->xx = FT_DivFix( yy, delta );
    matrix->yy = FT_DivFix( xx, delta );

    return FT_Err_Ok;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( void )
  FT_Matrix_Multiply_Scaled( const FT_Matrix*  a,
                             FT_Matrix        *b,
                             FT_Long           scaling )
  {
    FT_Fixed  xx, xy, yx, yy;

    FT_Long   val = 0x10000L * scaling;


    if ( !a || !b )
      return;

    xx = FT_MulDiv( a->xx, b->xx, val ) + FT_MulDiv( a->xy, b->yx, val );
    xy = FT_MulDiv( a->xx, b->xy, val ) + FT_MulDiv( a->xy, b->yy, val );
    yx = FT_MulDiv( a->yx, b->xx, val ) + FT_MulDiv( a->yy, b->yx, val );
    yy = FT_MulDiv( a->yx, b->xy, val ) + FT_MulDiv( a->yy, b->yy, val );

    b->xx = xx;  b->xy = xy;
    b->yx = yx;  b->yy = yy;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( void )
  FT_Vector_Transform_Scaled( FT_Vector*        vector,
                              const FT_Matrix*  matrix,
                              FT_Long           scaling )
  {
    FT_Pos   xz, yz;

    FT_Long  val = 0x10000L * scaling;


    if ( !vector || !matrix )
      return;

    xz = FT_MulDiv( vector->x, matrix->xx, val ) +
         FT_MulDiv( vector->y, matrix->xy, val );

    yz = FT_MulDiv( vector->x, matrix->yx, val ) +
         FT_MulDiv( vector->y, matrix->yy, val );

    vector->x = xz;
    vector->y = yz;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_UInt32 )
  FT_Vector_NormLen( FT_Vector*  vector )
  {
    FT_Int32   x_ = vector->x;
    FT_Int32   y_ = vector->y;
    FT_Int32   b, z;
    FT_UInt32  x, y, u, v, l;
    FT_Int     sx = 1, sy = 1, shift;


    FT_MOVE_SIGN( x_, sx );
    FT_MOVE_SIGN( y_, sy );

    x = (FT_UInt32)x_;
    y = (FT_UInt32)y_;

    /* trivial cases */
    if ( x == 0 )
    {
      if ( y > 0 )
        vector->y = sy * 0x10000;
      return y;
    }
    else if ( y == 0 )
    {
      if ( x > 0 )
        vector->x = sx * 0x10000;
      return x;
    }

    /* Estimate length and prenormalize by shifting so that */
    /* the new approximate length is between 2/3 and 4/3.   */
    /* The magic constant 0xAAAAAAAAUL (2/3 of 2^32) helps  */
    /* achieve this in 16.16 fixed-point representation.    */
    l = x > y ? x + ( y >> 1 )
              : y + ( x >> 1 );

    shift  = 31 - FT_MSB( l );
    shift -= 15 + ( l >= ( 0xAAAAAAAAUL >> shift ) );

    if ( shift > 0 )
    {
      x <<= shift;
      y <<= shift;

      /* re-estimate length for tiny vectors */
      l = x > y ? x + ( y >> 1 )
                : y + ( x >> 1 );
    }
    else
    {
      x >>= -shift;
      y >>= -shift;
      l >>= -shift;
    }

    /* lower linear approximation for reciprocal length minus one */
    b = 0x10000 - (FT_Int32)l;

    x_ = (FT_Int32)x;
    y_ = (FT_Int32)y;

    /* Newton's iterations */
    do
    {
      u = (FT_UInt32)( x_ + ( x_ * b >> 16 ) );
      v = (FT_UInt32)( y_ + ( y_ * b >> 16 ) );

      /* Normalized squared length in the parentheses approaches 2^32. */
      /* On two's complement systems, converting to signed gives the   */
      /* difference with 2^32 even if the expression wraps around.     */
      z = -(FT_Int32)( u * u + v * v ) / 0x200;
      z = z * ( ( 0x10000 + b ) >> 8 ) / 0x10000;

      b += z;

    } while ( z > 0 );

    vector->x = sx < 0 ? -(FT_Pos)u : (FT_Pos)u;
    vector->y = sy < 0 ? -(FT_Pos)v : (FT_Pos)v;

    /* Conversion to signed helps to recover from likely wrap around */
    /* in calculating the prenormalized length, because it gives the */
    /* correct difference with 2^32 on two's complement systems.     */
    l = (FT_UInt32)( 0x10000 + (FT_Int32)( u * x + v * y ) / 0x10000 );
    if ( shift > 0 )
      l = ( l + ( 1 << ( shift - 1 ) ) ) >> shift;
    else
      l <<= -shift;

    return l;
  }


#if 0

  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Int32 )
  FT_SqrtFixed( FT_Int32  x )
  {
    FT_UInt32  root, rem_hi, rem_lo, test_div;
    FT_Int     count;


    root = 0;

    if ( x > 0 )
    {
      rem_hi = 0;
      rem_lo = (FT_UInt32)x;
      count  = 24;
      do
      {
        rem_hi   = ( rem_hi << 2 ) | ( rem_lo >> 30 );
        rem_lo <<= 2;
        root   <<= 1;
        test_div = ( root << 1 ) + 1;

        if ( rem_hi >= test_div )
        {
          rem_hi -= test_div;
          root   += 1;
        }
      } while ( --count );
    }

    return (FT_Int32)root;
  }

#endif /* 0 */


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Int )
  ft_corner_orientation( FT_Pos  in_x,
                         FT_Pos  in_y,
                         FT_Pos  out_x,
                         FT_Pos  out_y )
  {
#ifdef FT_LONG64

    FT_Int64  delta = (FT_Int64)in_x * out_y - (FT_Int64)in_y * out_x;


    return ( delta > 0 ) - ( delta < 0 );

#else

    FT_Int  result;


    if ( (FT_ULong)FT_ABS( in_x ) + (FT_ULong)FT_ABS( out_y ) <= 131071UL &&
         (FT_ULong)FT_ABS( in_y ) + (FT_ULong)FT_ABS( out_x ) <= 131071UL )
    {
      FT_Long  z1 = in_x * out_y;
      FT_Long  z2 = in_y * out_x;


      if ( z1 > z2 )
        result = +1;
      else if ( z1 < z2 )
        result = -1;
      else
        result = 0;
    }
    else /* products might overflow 32 bits */
    {
      FT_Int64  z1, z2;


      /* XXX: this function does not allow 64-bit arguments */
      ft_multo64( (FT_UInt32)in_x, (FT_UInt32)out_y, &z1 );
      ft_multo64( (FT_UInt32)in_y, (FT_UInt32)out_x, &z2 );

      if ( z1.hi > z2.hi )
        result = +1;
      else if ( z1.hi < z2.hi )
        result = -1;
      else if ( z1.lo > z2.lo )
        result = +1;
      else if ( z1.lo < z2.lo )
        result = -1;
      else
        result = 0;
    }

    /* XXX: only the sign of return value, +1/0/-1 must be used */
    return result;

#endif
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Int )
  ft_corner_is_flat( FT_Pos  in_x,
                     FT_Pos  in_y,
                     FT_Pos  out_x,
                     FT_Pos  out_y )
  {
    FT_Pos  ax = in_x + out_x;
    FT_Pos  ay = in_y + out_y;

    FT_Pos  d_in, d_out, d_hypot;


    /* The idea of this function is to compare the length of the */
    /* hypotenuse with the `in' and `out' length.  The `corner'  */
    /* represented by `in' and `out' is flat if the hypotenuse's */
    /* length isn't too large.                                   */
    /*                                                           */
    /* This approach has the advantage that the angle between    */
    /* `in' and `out' is not checked.  In case one of the two    */
    /* vectors is `dominant', this is, much larger than the      */
    /* other vector, we thus always have a flat corner.          */
    /*                                                           */
    /*                hypotenuse                                 */
    /*       x---------------------------x                       */
    /*        \                      /                           */
    /*         \                /                                */
    /*      in  \          /  out                                */
    /*           \    /                                          */
    /*            o                                              */
    /*              Point                                        */

    d_in    = FT_HYPOT(  in_x,  in_y );
    d_out   = FT_HYPOT( out_x, out_y );
    d_hypot = FT_HYPOT(    ax,    ay );

    /* now do a simple length comparison: */
    /*                                    */
    /*   d_in + d_out < 17/16 d_hypot     */

    return ( d_in + d_out - d_hypot ) < ( d_hypot >> 4 );
  }


/* END */
@


1.15
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d452 2
a453 2
      a = temp.hi == 0 ? temp.lo / c
                       : ft_div64by32( temp.hi, temp.lo, c );
d495 2
a496 2
      a = temp.hi == 0 ? temp.lo / c
                       : ft_div64by32( temp.hi, temp.lo, c );
@


1.14
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@d7 1
a7 1
/*  Copyright 1996-2015 by                                                 */
d236 1
a236 1
    return FT_MULFIX_ASSEMBLER( a_, b_ );
@


1.13
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d89 1
a89 2
    return a >= 0 ?   ( a + 0x8000L ) & ~0xFFFFL
                  : -((-a + 0x8000L ) & ~0xFFFFL );
d98 1
a98 2
    return a >= 0 ?   ( a + 0xFFFFL ) & ~0xFFFFL
                  : -((-a + 0xFFFFL ) & ~0xFFFFL );
d107 1
a107 2
    return a >= 0 ?   a & ~0xFFFFL
                  : -((-a) & ~0xFFFFL );
d240 1
a240 14
    FT_Int     s = 1;
    FT_UInt64  a, b, c;
    FT_Long    c_;


    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );

    a = (FT_UInt64)a_;
    b = (FT_UInt64)b_;

    c = ( a * b + 0x8000UL ) >> 16;

    c_ = (FT_Long)c;
d242 2
a243 1
    return s < 0 ? -c_ : c_;
a424 3
    if ( a_ == 0 || b_ == c_ )
      return a_;

a472 3
    if ( a_ == 0 || b_ == c_ )
      return a_;

a527 3
    if ( a_ == 0 || b_ == 0x10000L )
      return a_;

a577 3
    if ( a_ == 0 || b_ == 0x10000L )
      return a_;

d761 96
d904 3
a906 1
    FT_Long  result; /* avoid overflow on 16-bit system */
d909 3
a911 32
    /* deal with the trivial cases quickly */
    if ( in_y == 0 )
    {
      if ( in_x >= 0 )
        result = out_y;
      else
        result = -out_y;
    }
    else if ( in_x == 0 )
    {
      if ( in_y >= 0 )
        result = -out_x;
      else
        result = out_x;
    }
    else if ( out_y == 0 )
    {
      if ( out_x >= 0 )
        result = in_y;
      else
        result = -in_y;
    }
    else if ( out_x == 0 )
    {
      if ( out_y >= 0 )
        result = -in_x;
      else
        result =  in_x;
    }
    else /* general case */
    {
#ifdef FT_LONG64
d913 1
a913 1
      FT_Int64  delta = (FT_Int64)in_x * out_y - (FT_Int64)in_y * out_x;
d916 5
a920 4
      if ( delta == 0 )
        result = 0;
      else
        result = 1 - 2 * ( delta < 0 );
a921 1
#else
d923 9
a948 2

#endif
d952 3
a954 1
    return (FT_Int)result;
@


1.12
log
@
Bugfixing update to freetype-2.5.5

ok matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2006, 2008, 2012-2014 by                                */
d176 3
a178 3
  FT_MulDiv( FT_Long  a,
             FT_Long  b,
             FT_Long  c )
d180 3
a182 2
    FT_Int   s = 1;
    FT_Long  d;
d185 3
a187 3
    FT_MOVE_SIGN( a, s );
    FT_MOVE_SIGN( b, s );
    FT_MOVE_SIGN( c, s );
d189 3
a191 2
    d = (FT_Long)( c > 0 ? ( (FT_Int64)a * b + ( c >> 1 ) ) / c
                         : 0x7FFFFFFFL );
d193 6
a198 1
    return s < 0 ? -d : d;
d205 3
a207 3
  FT_MulDiv_No_Round( FT_Long  a,
                      FT_Long  b,
                      FT_Long  c )
d209 4
a212 2
    FT_Int   s = 1;
    FT_Long  d;
d214 3
d218 3
a220 3
    FT_MOVE_SIGN( a, s );
    FT_MOVE_SIGN( b, s );
    FT_MOVE_SIGN( c, s );
d222 2
a223 2
    d = (FT_Long)( c > 0 ? (FT_Int64)a * b / c
                         : 0x7FFFFFFFL );
d225 3
a227 1
    return s < 0 ? -d : d;
d234 2
a235 2
  FT_MulFix( FT_Long  a,
             FT_Long  b )
d239 1
a239 1
    return FT_MULFIX_ASSEMBLER( a, b );
d243 4
a246 2
    FT_Int   s = 1;
    FT_Long  c;
d248 2
d251 2
a252 2
    FT_MOVE_SIGN( a, s );
    FT_MOVE_SIGN( b, s );
d254 1
a254 1
    c = (FT_Long)( ( (FT_Int64)a * b + 0x8000L ) >> 16 );
d256 3
a258 1
    return s < 0 ? -c : c;
d267 2
a268 2
  FT_DivFix( FT_Long  a,
             FT_Long  b )
d270 7
a276 2
    FT_Int   s = 1;
    FT_Long  q;
d278 2
d281 2
a282 2
    FT_MOVE_SIGN( a, s );
    FT_MOVE_SIGN( b, s );
d284 1
a284 2
    q = (FT_Long)( b > 0 ? ( ( (FT_UInt64)a << 16 ) + ( b >> 1 ) ) / b
                         : 0x7FFFFFFFL );
d286 1
a286 1
    return s < 0 ? -q : q;
d430 3
a432 3
  FT_MulDiv( FT_Long  a,
             FT_Long  b,
             FT_Long  c )
d434 2
a435 1
    FT_Int  s = 1;
a438 2
    if ( a == 0 || b == c )
      return a;
d440 10
a449 3
    FT_MOVE_SIGN( a, s );
    FT_MOVE_SIGN( b, s );
    FT_MOVE_SIGN( c, s );
d452 1
a452 1
      a = 0x7FFFFFFFL;
d454 2
a455 2
    else if ( (FT_ULong)a + b <= 129894UL - ( c >> 17 ) )
      a = ( (FT_ULong)a * b + ( c >> 1 ) ) / c;
d474 3
a476 1
    return s < 0 ? -a : a;
d481 3
a483 3
  FT_MulDiv_No_Round( FT_Long  a,
                      FT_Long  b,
                      FT_Long  c )
d485 2
a486 1
    FT_Int  s = 1;
d489 4
a492 2
    if ( a == 0 || b == c )
      return a;
d494 7
a500 3
    FT_MOVE_SIGN( a, s );
    FT_MOVE_SIGN( b, s );
    FT_MOVE_SIGN( c, s );
d503 1
a503 1
      a = 0x7FFFFFFFL;
d505 2
a506 2
    else if ( (FT_ULong)a + b <= 131071UL )
      a = (FT_ULong)a * b / c;
d520 3
a522 1
    return s < 0 ? -a : a;
d529 2
a530 2
  FT_MulFix( FT_Long  a,
             FT_Long  b )
d534 1
a534 1
    return FT_MULFIX_ASSEMBLER( a, b );
d545 2
a546 2
    FT_Long   sa, sb;
    FT_ULong  ua, ub;
d549 2
a550 2
    if ( a == 0 || b == 0x10000L )
      return a;
d570 4
a573 4
    sa = ( a >> ( sizeof ( a ) * 8 - 1 ) );
    a  = ( a ^ sa ) - sa;
    sb = ( b >> ( sizeof ( b ) * 8 - 1 ) );
    b  = ( b ^ sb ) - sb;
d575 2
a576 2
    ua = (FT_ULong)a;
    ub = (FT_ULong)b;
d578 2
a579 2
    if ( ua + ( ub >> 8 ) <= 8190UL )
      ua = ( ua * ub + 0x8000U ) >> 16;
d582 1
a582 1
      FT_ULong  al = ua & 0xFFFFU;
d585 2
a586 2
      ua = ( ua >> 16 ) * ub +  al * ( ub >> 16 ) +
           ( ( al * ( ub & 0xFFFFU ) + 0x8000U ) >> 16 );
d589 2
a590 2
    sa ^= sb,
    ua  = (FT_ULong)(( ua ^ sa ) - sa);
d592 1
a592 1
    return (FT_Long)ua;
d596 2
a597 2
    FT_Int    s = 1;
    FT_ULong  ua, ub;
d600 4
a603 2
    if ( a == 0 || b == 0x10000L )
      return a;
d605 2
a606 2
    FT_MOVE_SIGN( a, s );
    FT_MOVE_SIGN( b, s );
d608 2
a609 2
    ua = (FT_ULong)a;
    ub = (FT_ULong)b;
d611 2
a612 2
    if ( ua + ( ub >> 8 ) <= 8190UL )
      ua = ( ua * ub + 0x8000UL ) >> 16;
d615 1
a615 1
      FT_ULong  al = ua & 0xFFFFUL;
d618 2
a619 2
      ua = ( ua >> 16 ) * ub +  al * ( ub >> 16 ) +
           ( ( al * ( ub & 0xFFFFUL ) + 0x8000UL ) >> 16 );
d622 3
a624 1
    return s < 0 ? -(FT_Long)ua : (FT_Long)ua;
d634 2
a635 2
  FT_DivFix( FT_Long  a,
             FT_Long  b )
d637 3
a639 2
    FT_Int   s = 1;
    FT_Long  q;
d644 5
a648 2
    FT_MOVE_SIGN( a, s );
    FT_MOVE_SIGN( b, s );
d653 1
a653 1
      q = 0x7FFFFFFFL;
d655 1
a655 1
    else if ( a <= 65535L - ( b >> 17 ) )
d658 1
a658 1
      q = (FT_Long)( ( ( (FT_ULong)a << 16 ) + ( b >> 1 ) ) / b );
d672 1
a672 1
      q = (FT_Long)ft_div64by32( temp.hi, temp.lo, b );
d675 3
a677 1
    return s < 0 ? -q : q;
d681 1
a681 1
#endif /* FT_LONG64 */
d804 1
a804 1
      rem_lo = x;
d885 2
a886 2
      ft_multo64( (FT_Int32)in_x, (FT_Int32)out_y, &z1 );
      ft_multo64( (FT_Int32)in_y, (FT_Int32)out_x, &z2 );
@


1.11
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d89 2
a90 2
    return ( a >= 0 ) ?   ( a + 0x8000L ) & ~0xFFFFL
                      : -((-a + 0x8000L ) & ~0xFFFFL );
d99 2
a100 2
    return ( a >= 0 ) ?   ( a + 0xFFFFL ) & ~0xFFFFL
                      : -((-a + 0xFFFFL ) & ~0xFFFFL );
d109 2
a110 2
    return ( a >= 0 ) ?   a & ~0xFFFFL
                      : -((-a) & ~0xFFFFL );
d118 2
a119 1
    FT_Int shift = 0;
d122 1
a122 1
    if ( z & 0xFFFF0000U )
d127 1
a127 1
    if ( z & 0x0000FF00U )
d132 1
a132 1
    if ( z & 0x000000F0U )
d137 1
a137 1
    if ( z & 0x0000000CU )
d142 1
a142 1
    if ( z & 0x00000002U )
d191 1
a191 1
    return ( s > 0 ) ? d : -d;
d213 1
a213 1
    return ( s > 0 ) ? d : -d;
d238 1
a238 1
    return ( s > 0 ) ? c : -c;
d260 1
a260 1
    return ( s < 0 ? -q : q );
d442 1
a442 1
    return ( s < 0 ? -a : a );
d479 1
a479 1
    return ( s < 0 ? -a : a );
d577 1
a577 1
    return ( s < 0 ? -(FT_Long)ua : (FT_Long)ua );
d624 1
a624 1
    return ( s < 0 ? -q : q );
@


1.10
log
@
Security/bugfixing update to freetype-2.5.3, featuring a fix for a
vulnerability in the CFF driver (CVE-2014-2240) and assorted minor
fixes.

ok matthieu@@
@
text
@d42 2
a43 1
#ifdef FT_MULFIX_INLINED
d71 10
d113 1
d121 1
a121 1
    if ( z >= ( 1L << 16 ) )
d126 1
a126 1
    if ( z >= ( 1L << 8 ) )
d131 1
a131 1
    if ( z >= ( 1L << 4 ) )
d136 1
a136 1
    if ( z >= ( 1L << 2 ) )
d141 1
a141 1
    if ( z >= ( 1L << 1 ) )
d150 2
d179 1
a179 1
    FT_Int   s;
d183 3
a185 4
    s = 1;
    if ( a < 0 ) { a = -a; s = -1; }
    if ( b < 0 ) { b = -b; s = -s; }
    if ( c < 0 ) { c = -c; s = -s; }
d201 1
a201 1
    FT_Int   s;
d205 3
a207 4
    s = 1;
    if ( a < 0 ) { a = -a; s = -1; }
    if ( b < 0 ) { b = -b; s = -s; }
    if ( c < 0 ) { c = -c; s = -s; }
d232 2
a233 11
    if ( a < 0 )
    {
      a = -a;
      s = -1;
    }

    if ( b < 0 )
    {
      b = -b;
      s = -s;
    }
d249 2
a250 2
    FT_Int32   s;
    FT_UInt32  q;
d253 2
a254 11
    s = 1;
    if ( a < 0 )
    {
      a = -a;
      s = -1;
    }
    if ( b < 0 )
    {
      b = -b;
      s = -s;
    }
d256 2
a257 6
    if ( b == 0 )
      /* check for division by 0 */
      q = 0x7FFFFFFFL;
    else
      /* compute result directly */
      q = (FT_UInt32)( ( ( (FT_UInt64)a << 16 ) + ( b >> 1 ) ) / b );
d259 1
a259 1
    return ( s < 0 ? -(FT_Long)q : (FT_Long)q );
d307 2
a308 2
    q = 0;
    r = hi;
d310 9
a318 2
    if ( r >= y )
      return (FT_UInt32)0x7FFFFFFFL;
d320 1
a320 1
    i = 32;
a322 1
      r <<= 1;
d324 1
a324 1
      r  |= lo >> 31;
a330 1
      lo <<= 1;
d342 1
a342 1
    register FT_UInt32  lo, hi;
d353 28
a380 5
  /* documentation is in freetype.h */

  /* The FT_MulDiv function has been optimized thanks to ideas from      */
  /* Graham Asher.  The trick is to optimize computation when everything */
  /* fits within 32-bits (a rather common case).                         */
d382 4
a385 1
  /*  we compute 'a*b+c/2', then divide it by 'c'. (positive values)     */
d387 1
a387 1
  /*  46340 is FLOOR(SQRT(2^31-1)).                                      */
d389 2
a390 1
  /*  if ( a <= 46340 && b <= 46340 ) then ( a*b <= 0x7FFEA810 )         */
d392 1
a392 1
  /*  0x7FFFFFFF - 0x7FFEA810 = 0x157F0                                  */
d394 1
a394 1
  /*  if ( c < 0x157F0*2 ) then ( a*b+c/2 <= 0x7FFFFFFF )                */
d396 1
a396 1
  /*  and 2*0x157F0 = 176096                                             */
d398 3
d407 1
a407 1
    long  s;
d414 3
a416 3
    s  = a; a = FT_ABS( a );
    s ^= b; b = FT_ABS( b );
    s ^= c; c = FT_ABS( c );
d418 2
a419 2
    if ( a <= 46340L && b <= 46340L && c <= 176095L && c > 0 )
      a = ( a * b + ( c >> 1 ) ) / c;
d421 4
a424 1
    else if ( (FT_Int32)c > 0 )
d429 1
a429 1
      ft_multo64( (FT_Int32)a, (FT_Int32)b, &temp );
d432 2
a433 1
      temp2.lo = (FT_UInt32)(c >> 1);
d435 4
a438 1
      a = ft_div64by32( temp.hi, temp.lo, (FT_Int32)c );
a439 2
    else
      a = 0x7FFFFFFFL;
d450 1
a450 1
    long  s;
d456 3
a458 3
    s  = a; a = FT_ABS( a );
    s ^= b; b = FT_ABS( b );
    s ^= c; c = FT_ABS( c );
d460 2
a461 2
    if ( a <= 46340L && b <= 46340L && c > 0 )
      a = a * b / c;
d463 4
a466 1
    else if ( (FT_Int32)c > 0 )
d471 5
a475 2
      ft_multo64( (FT_Int32)a, (FT_Int32)b, &temp );
      a = ft_div64by32( temp.hi, temp.lo, (FT_Int32)c );
a476 2
    else
      a = 0x7FFFFFFFL;
d534 1
a534 1
    if ( ua <= 2048 && ub <= 1048576L )
d552 1
a552 1
    FT_Long   s;
d559 2
a560 2
    s  = a; a = FT_ABS( a );
    s ^= b; b = FT_ABS( b );
d565 1
a565 1
    if ( ua <= 2048 && ub <= 1048576L )
d589 2
a590 2
    FT_Int32   s;
    FT_UInt32  q;
a593 2
    s  = (FT_Int32)a; a = FT_ABS( a );
    s ^= (FT_Int32)b; b = FT_ABS( b );
d595 4
a598 1
    if ( (FT_UInt32)b == 0 )
d601 1
a601 1
      q = (FT_UInt32)0x7FFFFFFFL;
d603 1
a603 1
    else if ( ( a >> 16 ) == 0 )
d606 1
a606 1
      q = (FT_UInt32)( ( (FT_ULong)a << 16 ) + ( b >> 1 ) ) / (FT_UInt32)b;
d614 2
a615 2
      temp.hi  = (FT_Int32)( a >> 16 );
      temp.lo  = (FT_UInt32)a << 16;
d617 2
a618 1
      temp2.lo = (FT_UInt32)( b >> 1 );
d620 1
a620 1
      q = ft_div64by32( temp.hi, temp.lo, (FT_Int32)b );
d623 1
a623 1
    return ( s < 0 ? -(FT_Int32)q : (FT_Int32)q );
a626 121
#if 0

  /* documentation is in ftcalc.h */

  FT_EXPORT_DEF( void )
  FT_MulTo64( FT_Int32   x,
              FT_Int32   y,
              FT_Int64  *z )
  {
    FT_Int32  s;


    s  = x; x = FT_ABS( x );
    s ^= y; y = FT_ABS( y );

    ft_multo64( x, y, z );

    if ( s < 0 )
    {
      z->lo = (FT_UInt32)-(FT_Int32)z->lo;
      z->hi = ~z->hi + !( z->lo );
    }
  }


  /* apparently, the second version of this code is not compiled correctly */
  /* on Mac machines with the MPW C compiler..  tsk, tsk, tsk...           */

#if 1

  FT_EXPORT_DEF( FT_Int32 )
  FT_Div64by32( FT_Int64*  x,
                FT_Int32   y )
  {
    FT_Int32   s;
    FT_UInt32  q, r, i, lo;


    s  = x->hi;
    if ( s < 0 )
    {
      x->lo = (FT_UInt32)-(FT_Int32)x->lo;
      x->hi = ~x->hi + !x->lo;
    }
    s ^= y;  y = FT_ABS( y );

    /* Shortcut */
    if ( x->hi == 0 )
    {
      if ( y > 0 )
        q = x->lo / y;
      else
        q = 0x7FFFFFFFL;

      return ( s < 0 ? -(FT_Int32)q : (FT_Int32)q );
    }

    r  = x->hi;
    lo = x->lo;

    if ( r >= (FT_UInt32)y ) /* we know y is to be treated as unsigned here */
      return ( s < 0 ? 0x80000001UL : 0x7FFFFFFFUL );
                             /* Return Max/Min Int32 if division overflow. */
                             /* This includes division by zero!            */
    q = 0;
    for ( i = 0; i < 32; i++ )
    {
      r <<= 1;
      q <<= 1;
      r  |= lo >> 31;

      if ( r >= (FT_UInt32)y )
      {
        r -= y;
        q |= 1;
      }
      lo <<= 1;
    }

    return ( s < 0 ? -(FT_Int32)q : (FT_Int32)q );
  }

#else /* 0 */

  FT_EXPORT_DEF( FT_Int32 )
  FT_Div64by32( FT_Int64*  x,
                FT_Int32   y )
  {
    FT_Int32   s;
    FT_UInt32  q;


    s  = x->hi;
    if ( s < 0 )
    {
      x->lo = (FT_UInt32)-(FT_Int32)x->lo;
      x->hi = ~x->hi + !x->lo;
    }
    s ^= y;  y = FT_ABS( y );

    /* Shortcut */
    if ( x->hi == 0 )
    {
      if ( y > 0 )
        q = ( x->lo + ( y >> 1 ) ) / y;
      else
        q = 0x7FFFFFFFL;

      return ( s < 0 ? -(FT_Int32)q : (FT_Int32)q );
    }

    q = ft_div64by32( x->hi, x->lo, y );

    return ( s < 0 ? -(FT_Int32)q : (FT_Int32)q );
  }

#endif /* 0 */

#endif /* 0 */


d861 2
a862 2
    FT_Pos  ax = in_x;
    FT_Pos  ay = in_y;
d864 1
a864 1
    FT_Pos  d_in, d_out, d_corner;
d867 22
a888 37
    /* We approximate the Euclidean metric (sqrt(x^2 + y^2)) with */
    /* the Taxicab metric (|x| + |y|), which can be computed much */
    /* faster.  If one of the two vectors is much longer than the */
    /* other one, the direction of the shorter vector doesn't     */
    /* influence the result any more.                             */
    /*                                                            */
    /*                 corner                                     */
    /*       x---------------------------x                        */
    /*        \                      /                            */
    /*         \                /                                 */
    /*      in  \          /  out                                 */
    /*           \    /                                           */
    /*            o                                               */
    /*              Point                                         */
    /*                                                            */

    if ( ax < 0 )
      ax = -ax;
    if ( ay < 0 )
      ay = -ay;
    d_in = ax + ay;  /* d_in = || in || */

    ax = out_x;
    if ( ax < 0 )
      ax = -ax;
    ay = out_y;
    if ( ay < 0 )
      ay = -ay;
    d_out = ax + ay;  /* d_out = || out || */

    ax = out_x + in_x;
    if ( ax < 0 )
      ax = -ax;
    ay = out_y + in_y;
    if ( ay < 0 )
      ay = -ay;
    d_corner = ax + ay;  /* d_corner = || in + out || */
d892 1
a892 1
    /*   d_in + d_out < 17/16 d_corner    */
d894 1
a894 1
    return ( d_in + d_out - d_corner ) < ( d_corner >> 4 );
@


1.9
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d7 1
a7 1
/*  Copyright 1996-2006, 2008, 2012-2013 by                                */
d131 1
a131 1
      z     >>= 1;
@


1.8
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@d819 2
d855 2
d952 16
d972 1
a972 1
    d_in = ax + ay;
d980 1
a980 1
    d_out = ax + ay;
d988 5
a992 1
    d_corner = ax + ay;
@


1.7
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@a154 34
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS

  /* documentation is in ftcalc.h */

  FT_EXPORT_DEF( FT_Int32 )
  FT_Sqrt32( FT_Int32  x )
  {
    FT_UInt32  val, root, newroot, mask;


    root = 0;
    mask = (FT_UInt32)0x40000000UL;
    val  = (FT_UInt32)x;

    do
    {
      newroot = root + mask;
      if ( newroot <= val )
      {
        val -= newroot;
        root = newroot + mask;
      }

      root >>= 1;
      mask >>= 2;

    } while ( mask != 0 );

    return root;
  }

#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */


d267 1
a267 1
      q = (FT_UInt32)( ( ( (FT_ULong)a << 16 ) + ( b >> 1 ) ) / b );
@


1.6
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@d7 1
a7 1
/*  Copyright 1996-2006, 2008, 2012 by                                     */
d37 1
d46 1
a46 1
/* we need to define a 64-bits data type here */
d48 1
a48 5
#ifdef FT_LONG64

  typedef FT_INT64  FT_Int64;

#else
d57 1
a57 1
#endif /* FT_LONG64 */
d103 52
a214 2
#ifdef TT_USE_BYTECODE_INTERPRETER

a236 2
#endif /* TT_USE_BYTECODE_INTERPRETER */

d283 1
d285 10
a294 2
    if ( a < 0 ) { a = -a; s = -1; }
    if ( b < 0 ) { b = -b; s = -s; }
d301 1
a301 1
      q = (FT_UInt32)( ( ( (FT_Int64)a << 16 ) + ( b >> 1 ) ) / b );
a448 2
#ifdef TT_USE_BYTECODE_INTERPRETER

a480 2
#endif /* TT_USE_BYTECODE_INTERPRETER */

d605 1
a605 1
      q = (FT_UInt32)( ( a << 16 ) + ( b >> 1 ) ) / (FT_UInt32)b;
d613 2
a614 2
      temp.hi  = (FT_Int32) ( a >> 16 );
      temp.lo  = (FT_UInt32)( a << 16 );
d780 1
a780 1
      return FT_Err_Invalid_Argument;
d787 1
a787 1
      return FT_Err_Invalid_Argument;  /* matrix can't be inverted */
@


1.5
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2008 by             */
d310 1
a310 1
      if ( r >= (FT_UInt32)y )
d376 1
a376 1
    else if ( c > 0 )
d415 1
a415 1
    else if ( c > 0 )
d467 1
a467 1
     *  fills the leftmost bits by copying the sign bit.  This is wrong. 
d547 1
a547 1
    if ( b == 0 )
d555 1
a555 1
      q = (FT_UInt32)( (a << 16) + (b >> 1) ) / (FT_UInt32)b;
d562 3
a564 2
      temp.hi  = (FT_Int32) (a >> 16);
      temp.lo  = (FT_UInt32)(a << 16);
@


1.4
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d113 1
a113 1
    FT_ULong  val, root, newroot, mask;
d117 2
a118 2
    mask = 0x40000000L;
    val  = (FT_ULong)x;
d365 1
d381 1
a381 1
      ft_multo64( a, b, &temp );
d386 1
a386 1
      a = ft_div64by32( temp.hi, temp.lo, c );
d420 2
a421 2
      ft_multo64( a, b, &temp );
      a = ft_div64by32( temp.hi, temp.lo, c );
d543 3
a545 2
    s  = a; a = FT_ABS( a );
    s ^= b; b = FT_ABS( b );
d550 1
a550 1
      q = 0x7FFFFFFFL;
d567 1
a567 1
      q = ft_div64by32( temp.hi, temp.lo, b );
d845 1
a845 1
    FT_Int  result;
d894 3
a896 2
      ft_multo64( in_x, out_y, &z1 );
      ft_multo64( in_y, out_x, &z2 );
d912 2
a913 1
    return result;
@


1.3
log
@Update to Freetype 2.3.7. This is a bug fix release. No API change.
@
text
@d41 3
d199 6
d209 11
a219 2
    if ( a < 0 ) { a = -a; s = -1; }
    if ( b < 0 ) { b = -b; s = -s; }
d222 4
a225 1
    return ( s > 0 ) ? c : -c ;
d437 1
a437 5
    /* use inline assembly to speed up things a bit */

#if defined( __GNUC__ ) && defined( i386 )

    FT_Long  result;
d439 1
d441 1
a441 16
    __asm__ __volatile__ (
      "imul  %%edx\n"
      "movl  %%edx, %%ecx\n"
      "sarl  $31, %%ecx\n"
      "addl  $0x8000, %%ecx\n"
      "addl  %%ecx, %%eax\n"
      "adcl  $0, %%edx\n"
      "shrl  $16, %%eax\n"
      "shll  $16, %%edx\n"
      "addl  %%edx, %%eax\n"
      "mov   %%eax, %0\n"
      : "=a"(result), "+d"(b)
      : "a"(a)
      : "%ecx"
    );
    return result;
d443 6
a448 1
#elif 1
d457 18
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d36 1
d434 2
a435 2
      : "=r"(result)
      : "a"(a), "d"(b)
d668 53
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d162 1
a162 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d186 1
a186 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d231 1
a231 1
#else /* FT_LONG64 */
d305 1
a305 1
    register FT_UInt32  lo, hi, max;
d308 2
a309 3
    max = x->lo > y->lo ? x->lo : y->lo;
    lo  = x->lo + y->lo;
    hi  = x->hi + y->hi + ( lo < max );
d318 17
d372 1
a372 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d406 1
a406 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d415 26
a440 1
#if 1
d449 1
a449 1
     a = ( a ^ sa ) - sa;
d451 1
a451 1
     b = ( b ^ sb ) - sb;
d457 1
a457 3
    {
      ua = ( ua * ub + 0x8000 ) >> 16;
    }
d460 1
a460 1
      FT_ULong  al = ua & 0xFFFF;
d464 1
a464 1
           ( ( al * ( ub & 0xFFFF ) + 0x8000 ) >> 16 );
d481 2
a482 2
    s  = a; a = FT_ABS(a);
    s ^= b; b = FT_ABS(b);
d488 1
a488 3
    {
      ua = ( ua * ub + 0x8000L ) >> 16;
    }
d491 1
a491 1
      FT_ULong  al = ua & 0xFFFFL;
d495 1
a495 1
           ( ( al * ( ub & 0xFFFFL ) + 0x8000L ) >> 16 );
d515 2
a516 2
    s  = a; a = FT_ABS(a);
    s ^= b; b = FT_ABS(b);
d571 1
a571 1
  /* on Mac machines with the MPW C compiler..  tsk, tsk, tsk...         */
d608 1
a608 1
                             /* This includes division by zero! */
d671 51
d752 118
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d162 1
a162 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d186 1
a186 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d231 1
a231 1
#else /* !FT_LONG64 */
d305 1
a305 1
    register FT_UInt32  lo, hi;
d308 3
a310 2
    lo = x->lo + y->lo;
    hi = x->hi + y->hi + ( lo < x->lo );
a318 17
  /* The FT_MulDiv function has been optimized thanks to ideas from      */
  /* Graham Asher.  The trick is to optimize computation when everything */
  /* fits within 32-bits (a rather common case).                         */
  /*                                                                     */
  /*  we compute 'a*b+c/2', then divide it by 'c'. (positive values)     */
  /*                                                                     */
  /*  46340 is FLOOR(SQRT(2^31-1)).                                      */
  /*                                                                     */
  /*  if ( a <= 46340 && b <= 46340 ) then ( a*b <= 0x7FFEA810 )         */
  /*                                                                     */
  /*  0x7FFFFFFF - 0x7FFEA810 = 0x157F0                                  */
  /*                                                                     */
  /*  if ( c < 0x157F0*2 ) then ( a*b+c/2 <= 0x7FFFFFFF )                */
  /*                                                                     */
  /*  and 2*0x157F0 = 176096                                             */
  /*                                                                     */

d356 1
a356 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d390 1
a390 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d399 1
a399 26
    /* use inline assembly to speed up things a bit */

#if defined( __GNUC__ ) && defined( i386 )

    FT_Long  result;


    __asm__ __volatile__ (
      "imul  %%edx\n"
      "movl  %%edx, %%ecx\n"
      "sarl  $31, %%ecx\n"
      "addl  $0x8000, %%ecx\n"
      "addl  %%ecx, %%eax\n"
      "adcl  $0, %%edx\n"
      "shrl  $16, %%eax\n"
      "shll  $16, %%edx\n"
      "addl  %%edx, %%eax\n"
      "mov   %%eax, %0\n"
      : "=r"(result)
      : "a"(a), "d"(b)
      : "%ecx"
    );
    return result;

#elif 1

d408 1
a408 1
    a  = ( a ^ sa ) - sa;
d410 1
a410 1
    b  = ( b ^ sb ) - sb;
d416 3
a418 1
      ua = ( ua * ub + 0x8000U ) >> 16;
d421 1
a421 1
      FT_ULong  al = ua & 0xFFFFU;
d425 1
a425 1
           ( ( al * ( ub & 0xFFFFU ) + 0x8000U ) >> 16 );
d442 2
a443 2
    s  = a; a = FT_ABS( a );
    s ^= b; b = FT_ABS( b );
d449 3
a451 1
      ua = ( ua * ub + 0x8000UL ) >> 16;
d454 1
a454 1
      FT_ULong  al = ua & 0xFFFFUL;
d458 1
a458 1
           ( ( al * ( ub & 0xFFFFUL ) + 0x8000UL ) >> 16 );
d534 1
a534 1
  /* on Mac machines with the MPW C compiler..  tsk, tsk, tsk...           */
d571 1
a571 1
                             /* This includes division by zero!            */
a663 118
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Int )
  ft_corner_orientation( FT_Pos  in_x,
                         FT_Pos  in_y,
                         FT_Pos  out_x,
                         FT_Pos  out_y )
  {
    FT_Int  result;


    /* deal with the trivial cases quickly */
    if ( in_y == 0 )
    {
      if ( in_x >= 0 )
        result = out_y;
      else
        result = -out_y;
    }
    else if ( in_x == 0 )
    {
      if ( in_y >= 0 )
        result = -out_x;
      else
        result = out_x;
    }
    else if ( out_y == 0 )
    {
      if ( out_x >= 0 )
        result = in_y;
      else
        result = -in_y;
    }
    else if ( out_x == 0 )
    {
      if ( out_y >= 0 )
        result = -in_x;
      else
        result =  in_x;
    }
    else /* general case */
    {
#ifdef FT_LONG64

      FT_Int64  delta = (FT_Int64)in_x * out_y - (FT_Int64)in_y * out_x;


      if ( delta == 0 )
        result = 0;
      else
        result = 1 - 2 * ( delta < 0 );

#else

      FT_Int64  z1, z2;


      ft_multo64( in_x, out_y, &z1 );
      ft_multo64( in_y, out_x, &z2 );

      if ( z1.hi > z2.hi )
        result = +1;
      else if ( z1.hi < z2.hi )
        result = -1;
      else if ( z1.lo > z2.lo )
        result = +1;
      else if ( z1.lo < z2.lo )
        result = -1;
      else
        result = 0;

#endif
    }

    return result;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Int )
  ft_corner_is_flat( FT_Pos  in_x,
                     FT_Pos  in_y,
                     FT_Pos  out_x,
                     FT_Pos  out_y )
  {
    FT_Pos  ax = in_x;
    FT_Pos  ay = in_y;

    FT_Pos  d_in, d_out, d_corner;


    if ( ax < 0 )
      ax = -ax;
    if ( ay < 0 )
      ay = -ay;
    d_in = ax + ay;

    ax = out_x;
    if ( ax < 0 )
      ax = -ax;
    ay = out_y;
    if ( ay < 0 )
      ay = -ay;
    d_out = ax + ay;

    ax = out_x + in_x;
    if ( ax < 0 )
      ax = -ax;
    ay = out_y + in_y;
    if ( ay < 0 )
      ay = -ay;
    d_corner = ax + ay;

    return ( d_in + d_out - d_corner ) < ( d_corner >> 4 );
@

