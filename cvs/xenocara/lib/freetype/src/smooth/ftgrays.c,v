head	1.27;
access;
symbols
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.2
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.18.0.2
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.2
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2017.01.13.11.20.00;	author dcoppa;	state Exp;
branches;
next	1.26;
commitid	ESXG9TuEmwmBXggf;

1.26
date	2016.10.28.21.41.15;	author dcoppa;	state Exp;
branches;
next	1.25;
commitid	T2hf37tVZU8TmjB1;

1.25
date	2016.08.09.07.16.10;	author dcoppa;	state Exp;
branches;
next	1.24;
commitid	C8TgUUJolulx9B5d;

1.24
date	2016.05.29.11.57.14;	author dcoppa;	state Exp;
branches;
next	1.23;
commitid	1dOLexdOAzW2mQjp;

1.23
date	2015.12.07.09.34.04;	author dcoppa;	state Exp;
branches;
next	1.22;
commitid	wZOPiDmcwgRFTDVL;

1.22
date	2015.10.19.07.51.38;	author dcoppa;	state Exp;
branches;
next	1.21;
commitid	d2XmJCtYff11VIDu;

1.21
date	2015.06.28.08.27.50;	author dcoppa;	state Exp;
branches;
next	1.20;
commitid	qXwIGV2h9uFjxAmt;

1.20
date	2015.01.10.17.17.23;	author dcoppa;	state Exp;
branches;
next	1.19;
commitid	2tSYQMWVSV3t7clo;

1.19
date	2014.12.26.17.52.36;	author dcoppa;	state Exp;
branches;
next	1.18;
commitid	gwhRExMduYqoPQHI;

1.18
date	2014.03.14.08.18.02;	author dcoppa;	state Exp;
branches;
next	1.17;

1.17
date	2014.01.12.15.08.28;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2013.10.10.19.49.58;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.07.17.21.11;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2013.01.04.16.51.59;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2012.07.07.16.45.04;	author dcoppa;	state Exp;
branches;
next	1.12;

1.12
date	2012.04.14.09.45.47;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.10.30.10.14.51;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.07.18.20.29.59;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.19.16.08.14;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.23.19.30.17;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.09.01.19.14.25;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.17.14.06.43;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.25.20.49.55;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.10.20.28.35;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.21.05.09.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.45.09;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.45.09;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.32.52;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.27
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftgrays.c                                                              */
/*                                                                         */
/*    A new `perfect' anti-aliasing renderer (body).                       */
/*                                                                         */
/*  Copyright 2000-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* This file can be compiled without the rest of the FreeType engine, by */
  /* defining the STANDALONE_ macro when compiling it.  You also need to   */
  /* put the files `ftgrays.h' and `ftimage.h' into the current            */
  /* compilation directory.  Typically, you could do something like        */
  /*                                                                       */
  /* - copy `src/smooth/ftgrays.c' (this file) to your current directory   */
  /*                                                                       */
  /* - copy `include/freetype/ftimage.h' and `src/smooth/ftgrays.h' to the */
  /*   same directory                                                      */
  /*                                                                       */
  /* - compile `ftgrays' with the STANDALONE_ macro defined, as in         */
  /*                                                                       */
  /*     cc -c -DSTANDALONE_ ftgrays.c                                     */
  /*                                                                       */
  /* The renderer can be initialized with a call to                        */
  /* `ft_gray_raster.raster_new'; an anti-aliased bitmap can be generated  */
  /* with a call to `ft_gray_raster.raster_render'.                        */
  /*                                                                       */
  /* See the comments and documentation in the file `ftimage.h' for more   */
  /* details on how the raster works.                                      */
  /*                                                                       */
  /*************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* This is a new anti-aliasing scan-converter for FreeType 2.  The       */
  /* algorithm used here is _very_ different from the one in the standard  */
  /* `ftraster' module.  Actually, `ftgrays' computes the _exact_          */
  /* coverage of the outline on each pixel cell.                           */
  /*                                                                       */
  /* It is based on ideas that I initially found in Raph Levien's          */
  /* excellent LibArt graphics library (see http://www.levien.com/libart   */
  /* for more information, though the web pages do not tell anything       */
  /* about the renderer; you'll have to dive into the source code to       */
  /* understand how it works).                                             */
  /*                                                                       */
  /* Note, however, that this is a _very_ different implementation         */
  /* compared to Raph's.  Coverage information is stored in a very         */
  /* different way, and I don't use sorted vector paths.  Also, it doesn't */
  /* use floating point values.                                            */
  /*                                                                       */
  /* This renderer has the following advantages:                           */
  /*                                                                       */
  /* - It doesn't need an intermediate bitmap.  Instead, one can supply a  */
  /*   callback function that will be called by the renderer to draw gray  */
  /*   spans on any target surface.  You can thus do direct composition on */
  /*   any kind of bitmap, provided that you give the renderer the right   */
  /*   callback.                                                           */
  /*                                                                       */
  /* - A perfect anti-aliaser, i.e., it computes the _exact_ coverage on   */
  /*   each pixel cell.                                                    */
  /*                                                                       */
  /* - It performs a single pass on the outline (the `standard' FT2        */
  /*   renderer makes two passes).                                         */
  /*                                                                       */
  /* - It can easily be modified to render to _any_ number of gray levels  */
  /*   cheaply.                                                            */
  /*                                                                       */
  /* - For small (< 20) pixel sizes, it is faster than the standard        */
  /*   renderer.                                                           */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_smooth


#ifdef STANDALONE_


  /* The size in bytes of the render pool used by the scan-line converter  */
  /* to do all of its work.                                                */
#define FT_RENDER_POOL_SIZE  16384L


  /* Auxiliary macros for token concatenation. */
#define FT_ERR_XCAT( x, y )  x ## y
#define FT_ERR_CAT( x, y )   FT_ERR_XCAT( x, y )

#define FT_BEGIN_STMNT  do {
#define FT_END_STMNT    } while ( 0 )

#define FT_MIN( a, b )  ( (a) < (b) ? (a) : (b) )
#define FT_MAX( a, b )  ( (a) > (b) ? (a) : (b) )
#define FT_ABS( a )     ( (a) < 0 ? -(a) : (a) )


  /*
   *  Approximate sqrt(x*x+y*y) using the `alpha max plus beta min'
   *  algorithm.  We use alpha = 1, beta = 3/8, giving us results with a
   *  largest error less than 7% compared to the exact value.
   */
#define FT_HYPOT( x, y )                 \
          ( x = FT_ABS( x ),             \
            y = FT_ABS( y ),             \
            x > y ? x + ( 3 * y >> 3 )   \
                  : y + ( 3 * x >> 3 ) )


  /* define this to dump debugging information */
/* #define FT_DEBUG_LEVEL_TRACE */


#ifdef FT_DEBUG_LEVEL_TRACE
#include <stdio.h>
#include <stdarg.h>
#endif

#include <stddef.h>
#include <string.h>
#include <setjmp.h>
#include <limits.h>
#define FT_CHAR_BIT   CHAR_BIT
#define FT_UINT_MAX   UINT_MAX
#define FT_INT_MAX    INT_MAX
#define FT_ULONG_MAX  ULONG_MAX

#define ft_memset   memset

#define ft_setjmp   setjmp
#define ft_longjmp  longjmp
#define ft_jmp_buf  jmp_buf

typedef ptrdiff_t  FT_PtrDist;


#define ErrRaster_Invalid_Mode      -2
#define ErrRaster_Invalid_Outline   -1
#define ErrRaster_Invalid_Argument  -3
#define ErrRaster_Memory_Overflow   -4

#define FT_BEGIN_HEADER
#define FT_END_HEADER

#include "ftimage.h"
#include "ftgrays.h"


  /* This macro is used to indicate that a function parameter is unused. */
  /* Its purpose is simply to reduce compiler warnings.  Note also that  */
  /* simply defining it as `(void)x' doesn't avoid warnings with certain */
  /* ANSI compilers (e.g. LCC).                                          */
#define FT_UNUSED( x )  (x) = (x)


  /* we only use level 5 & 7 tracing messages; cf. ftdebug.h */

#ifdef FT_DEBUG_LEVEL_TRACE

  void
  FT_Message( const char*  fmt,
              ... )
  {
    va_list  ap;


    va_start( ap, fmt );
    vfprintf( stderr, fmt, ap );
    va_end( ap );
  }


  /* empty function useful for setting a breakpoint to catch errors */
  int
  FT_Throw( int          error,
            int          line,
            const char*  file )
  {
    FT_UNUSED( error );
    FT_UNUSED( line );
    FT_UNUSED( file );

    return 0;
  }


  /* we don't handle tracing levels in stand-alone mode; */
#ifndef FT_TRACE5
#define FT_TRACE5( varformat )  FT_Message varformat
#endif
#ifndef FT_TRACE7
#define FT_TRACE7( varformat )  FT_Message varformat
#endif
#ifndef FT_ERROR
#define FT_ERROR( varformat )   FT_Message varformat
#endif

#define FT_THROW( e )                               \
          ( FT_Throw( FT_ERR_CAT( ErrRaster, e ),   \
                      __LINE__,                     \
                      __FILE__ )                  | \
            FT_ERR_CAT( ErrRaster, e )            )

#else /* !FT_DEBUG_LEVEL_TRACE */

#define FT_TRACE5( x )  do { } while ( 0 )     /* nothing */
#define FT_TRACE7( x )  do { } while ( 0 )     /* nothing */
#define FT_ERROR( x )   do { } while ( 0 )     /* nothing */
#define FT_THROW( e )   FT_ERR_CAT( ErrRaster_, e )


#endif /* !FT_DEBUG_LEVEL_TRACE */


#define FT_DEFINE_OUTLINE_FUNCS( class_,               \
                                 move_to_, line_to_,   \
                                 conic_to_, cubic_to_, \
                                 shift_, delta_ )      \
          static const FT_Outline_Funcs class_ =       \
          {                                            \
            move_to_,                                  \
            line_to_,                                  \
            conic_to_,                                 \
            cubic_to_,                                 \
            shift_,                                    \
            delta_                                     \
         };

#define FT_DEFINE_RASTER_FUNCS( class_, glyph_format_,            \
                                raster_new_, raster_reset_,       \
                                raster_set_mode_, raster_render_, \
                                raster_done_ )                    \
          const FT_Raster_Funcs class_ =                          \
          {                                                       \
            glyph_format_,                                        \
            raster_new_,                                          \
            raster_reset_,                                        \
            raster_set_mode_,                                     \
            raster_render_,                                       \
            raster_done_                                          \
         };


#else /* !STANDALONE_ */


#include <ft2build.h>
#include "ftgrays.h"
#include FT_INTERNAL_OBJECTS_H
#include FT_INTERNAL_DEBUG_H
#include FT_OUTLINE_H

#include "ftsmerrs.h"

#include "ftspic.h"

#define Smooth_Err_Invalid_Mode     Smooth_Err_Cannot_Render_Glyph
#define Smooth_Err_Memory_Overflow  Smooth_Err_Out_Of_Memory
#define ErrRaster_Memory_Overflow   Smooth_Err_Out_Of_Memory


#endif /* !STANDALONE_ */


#ifndef FT_MEM_SET
#define FT_MEM_SET( d, s, c )  ft_memset( d, s, c )
#endif

#ifndef FT_MEM_ZERO
#define FT_MEM_ZERO( dest, count )  FT_MEM_SET( dest, 0, count )
#endif

#ifndef FT_ZERO
#define FT_ZERO( p )  FT_MEM_ZERO( p, sizeof ( *(p) ) )
#endif

  /* as usual, for the speed hungry :-) */

#undef RAS_ARG
#undef RAS_ARG_
#undef RAS_VAR
#undef RAS_VAR_

#ifndef FT_STATIC_RASTER

#define RAS_ARG   gray_PWorker  worker
#define RAS_ARG_  gray_PWorker  worker,

#define RAS_VAR   worker
#define RAS_VAR_  worker,

#else /* FT_STATIC_RASTER */

#define RAS_ARG   void
#define RAS_ARG_  /* empty */
#define RAS_VAR   /* empty */
#define RAS_VAR_  /* empty */

#endif /* FT_STATIC_RASTER */


  /* must be at least 6 bits! */
#define PIXEL_BITS  8

#undef FLOOR
#undef CEILING
#undef TRUNC
#undef SCALED

#define ONE_PIXEL       ( 1 << PIXEL_BITS )
#define TRUNC( x )      ( (TCoord)( (x) >> PIXEL_BITS ) )
#define SUBPIXELS( x )  ( (TPos)(x) * ONE_PIXEL )
#define FLOOR( x )      ( (x) & -ONE_PIXEL )
#define CEILING( x )    ( ( (x) + ONE_PIXEL - 1 ) & -ONE_PIXEL )
#define ROUND( x )      ( ( (x) + ONE_PIXEL / 2 ) & -ONE_PIXEL )

#if PIXEL_BITS >= 6
#define UPSCALE( x )    ( (x) * ( ONE_PIXEL >> 6 ) )
#define DOWNSCALE( x )  ( (x) >> ( PIXEL_BITS - 6 ) )
#else
#define UPSCALE( x )    ( (x) >> ( 6 - PIXEL_BITS ) )
#define DOWNSCALE( x )  ( (x) * ( 64 >> PIXEL_BITS ) )
#endif


  /* Compute `dividend / divisor' and return both its quotient and     */
  /* remainder, cast to a specific type.  This macro also ensures that */
  /* the remainder is always positive.                                 */
#define FT_DIV_MOD( type, dividend, divisor, quotient, remainder ) \
  FT_BEGIN_STMNT                                                   \
    (quotient)  = (type)( (dividend) / (divisor) );                \
    (remainder) = (type)( (dividend) % (divisor) );                \
    if ( (remainder) < 0 )                                         \
    {                                                              \
      (quotient)--;                                                \
      (remainder) += (type)(divisor);                              \
    }                                                              \
  FT_END_STMNT

#ifdef  __arm__
  /* Work around a bug specific to GCC which make the compiler fail to */
  /* optimize a division and modulo operation on the same parameters   */
  /* into a single call to `__aeabi_idivmod'.  See                     */
  /*                                                                   */
  /*  http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43721                */
#undef FT_DIV_MOD
#define FT_DIV_MOD( type, dividend, divisor, quotient, remainder ) \
  FT_BEGIN_STMNT                                                   \
    (quotient)  = (type)( (dividend) / (divisor) );                \
    (remainder) = (type)( (dividend) - (quotient) * (divisor) );   \
    if ( (remainder) < 0 )                                         \
    {                                                              \
      (quotient)--;                                                \
      (remainder) += (type)(divisor);                              \
    }                                                              \
  FT_END_STMNT
#endif /* __arm__ */


  /* These macros speed up repetitive divisions by replacing them */
  /* with multiplications and right shifts.                       */
#define FT_UDIVPREP( c, b )                                        \
  long  b ## _r = c ? (long)( FT_ULONG_MAX >> PIXEL_BITS ) / ( b ) \
                    : 0
#define FT_UDIV( a, b )                                        \
  ( ( (unsigned long)( a ) * (unsigned long)( b ## _r ) ) >>   \
    ( sizeof( long ) * FT_CHAR_BIT - PIXEL_BITS ) )


  /*************************************************************************/
  /*                                                                       */
  /*   TYPE DEFINITIONS                                                    */
  /*                                                                       */

  /* don't change the following types to FT_Int or FT_Pos, since we might */
  /* need to define them to "float" or "double" when experimenting with   */
  /* new algorithms                                                       */

  typedef long  TPos;     /* sub-pixel coordinate              */
  typedef int   TCoord;   /* integer scanline/pixel coordinate */
  typedef int   TArea;    /* cell areas, coordinate products   */


  typedef struct TCell_*  PCell;

  typedef struct  TCell_
  {
    TCoord  x;     /* same with gray_TWorker.ex    */
    TCoord  cover; /* same with gray_TWorker.cover */
    TArea   area;
    PCell   next;

  } TCell;

  typedef struct TPixmap_
  {
    unsigned char*  origin;  /* pixmap origin at the bottom-left */
    int             pitch;   /* pitch to go down one row */

  } TPixmap;

  /* maximum number of gray cells in the buffer */
#if FT_RENDER_POOL_SIZE > 2048
#define FT_MAX_GRAY_POOL  ( FT_RENDER_POOL_SIZE / sizeof ( TCell ) )
#else
#define FT_MAX_GRAY_POOL  ( 2048 / sizeof ( TCell ) )
#endif


#if defined( _MSC_VER )      /* Visual C++ (and Intel C++) */
  /* We disable the warning `structure was padded due to   */
  /* __declspec(align())' in order to compile cleanly with */
  /* the maximum level of warnings.                        */
#pragma warning( push )
#pragma warning( disable : 4324 )
#endif /* _MSC_VER */

  typedef struct  gray_TWorker_
  {
    ft_jmp_buf  jump_buffer;

    TCoord  ex, ey;
    TCoord  min_ex, max_ex;
    TCoord  min_ey, max_ey;

    TArea   area;
    TCoord  cover;
    int     invalid;

    PCell*      ycells;
    PCell       cells;
    FT_PtrDist  max_cells;
    FT_PtrDist  num_cells;

    TPos    x,  y;

    FT_Outline  outline;
    TPixmap     target;

    FT_Raster_Span_Func  render_span;
    void*                render_span_data;

  } gray_TWorker, *gray_PWorker;

#if defined( _MSC_VER )
#pragma warning( pop )
#endif


#ifndef FT_STATIC_RASTER
#define ras  (*worker)
#else
  static gray_TWorker  ras;
#endif


  typedef struct gray_TRaster_
  {
    void*         memory;

  } gray_TRaster, *gray_PRaster;


#ifdef FT_DEBUG_LEVEL_TRACE

  /* to be called while in the debugger --                                */
  /* this function causes a compiler warning since it is unused otherwise */
  static void
  gray_dump_cells( RAS_ARG )
  {
    int  y;


    for ( y = ras.min_ey; y < ras.max_ey; y++ )
    {
      PCell  cell = ras.ycells[y - ras.min_ey];


      printf( "%3d:", y );

      for ( ; cell != NULL; cell = cell->next )
        printf( " (%3d, c:%4d, a:%6d)",
                cell->x, cell->cover, cell->area );
      printf( "\n" );
    }
  }

#endif /* FT_DEBUG_LEVEL_TRACE */


  /*************************************************************************/
  /*                                                                       */
  /* Record the current cell in the table.                                 */
  /*                                                                       */
  static void
  gray_record_cell( RAS_ARG )
  {
    PCell  *pcell, cell;
    TCoord  x = ras.ex;


    pcell = &ras.ycells[ras.ey - ras.min_ey];
    for (;;)
    {
      cell = *pcell;
      if ( !cell || cell->x > x )
        break;

      if ( cell->x == x )
        goto Found;

      pcell = &cell->next;
    }

    if ( ras.num_cells >= ras.max_cells )
      ft_longjmp( ras.jump_buffer, 1 );

    /* insert new cell */
    cell        = ras.cells + ras.num_cells++;
    cell->x     = x;
    cell->area  = ras.area;
    cell->cover = ras.cover;

    cell->next  = *pcell;
    *pcell      = cell;

    return;

  Found:
    /* update old cell */
    cell->area  += ras.area;
    cell->cover += ras.cover;
  }


  /*************************************************************************/
  /*                                                                       */
  /* Set the current cell to a new position.                               */
  /*                                                                       */
  static void
  gray_set_cell( RAS_ARG_ TCoord  ex,
                          TCoord  ey )
  {
    /* Move the cell pointer to a new position.  We set the `invalid'      */
    /* flag to indicate that the cell isn't part of those we're interested */
    /* in during the render phase.  This means that:                       */
    /*                                                                     */
    /* . the new vertical position must be within min_ey..max_ey-1.        */
    /* . the new horizontal position must be strictly less than max_ex     */
    /*                                                                     */
    /* Note that if a cell is to the left of the clipping region, it is    */
    /* actually set to the (min_ex-1) horizontal position.                 */

    /* All cells that are on the left of the clipping region go to the */
    /* min_ex - 1 horizontal position.                                 */

    if ( ex < ras.min_ex )
      ex = ras.min_ex - 1;

    /* record the current one if it is valid */
    if ( !ras.invalid )
      gray_record_cell( RAS_VAR );

    ras.area  = 0;
    ras.cover = 0;
    ras.ex    = ex;
    ras.ey    = ey;

    ras.invalid = ( ey >= ras.max_ey || ey < ras.min_ey ||
                    ex >= ras.max_ex );
  }


#ifndef FT_LONG64

  /*************************************************************************/
  /*                                                                       */
  /* Render a scanline as one or more cells.                               */
  /*                                                                       */
  static void
  gray_render_scanline( RAS_ARG_ TCoord  ey,
                                 TPos    x1,
                                 TCoord  y1,
                                 TPos    x2,
                                 TCoord  y2 )
  {
    TCoord  ex1, ex2, fx1, fx2, first, delta, mod;
    TPos    p, dx;
    int     incr;


    ex1 = TRUNC( x1 );
    ex2 = TRUNC( x2 );

    /* trivial case.  Happens often */
    if ( y1 == y2 )
    {
      gray_set_cell( RAS_VAR_ ex2, ey );
      return;
    }

    fx1   = (TCoord)( x1 - SUBPIXELS( ex1 ) );
    fx2   = (TCoord)( x2 - SUBPIXELS( ex2 ) );
    delta = y2 - y1;

    /* everything is located in a single cell.  That is easy! */
    /*                                                        */
    if ( ex1 == ex2 )
    {
      ras.area  += (TArea)(( fx1 + fx2 ) * delta);
      ras.cover += delta;
      return;
    }

    /* ok, we'll have to render a run of adjacent cells on the same */
    /* scanline...                                                  */
    /*                                                              */
    dx = x2 - x1;

    if ( dx > 0 )
    {
      p     = ( ONE_PIXEL - fx1 ) * delta;
      first = ONE_PIXEL;
      incr  = 1;
    }
    else
    {
      p     = fx1 * delta;
      first = 0;
      incr  = -1;
      dx    = -dx;
    }

    FT_DIV_MOD( TCoord, p, dx, delta, mod );

    ras.area  += (TArea)(( fx1 + first ) * delta);
    ras.cover += delta;

    ex1 += incr;
    gray_set_cell( RAS_VAR_ ex1, ey );
    y1  += delta;

    if ( ex1 != ex2 )
    {
      TCoord  lift, rem;


      p = ONE_PIXEL * ( y2 - y1 + delta );
      FT_DIV_MOD( TCoord, p, dx, lift, rem );

      mod -= (int)dx;

      do
      {
        delta = lift;
        mod  += rem;
        if ( mod >= 0 )
        {
          mod -= (TCoord)dx;
          delta++;
        }

        ras.area  += (TArea)(ONE_PIXEL * delta);
        ras.cover += delta;
        y1        += delta;
        ex1       += incr;
        gray_set_cell( RAS_VAR_ ex1, ey );
      } while ( ex1 != ex2 );
    }

    delta      = y2 - y1;
    ras.area  += (TArea)(( fx2 + ONE_PIXEL - first ) * delta);
    ras.cover += delta;
  }


  /*************************************************************************/
  /*                                                                       */
  /* Render a given line as a series of scanlines.                         */
  /*                                                                       */
  static void
  gray_render_line( RAS_ARG_ TPos  to_x,
                             TPos  to_y )
  {
    TCoord  ey1, ey2, fy1, fy2, first, delta, mod;
    TPos    p, dx, dy, x, x2;
    int     incr;


    ey1 = TRUNC( ras.y );
    ey2 = TRUNC( to_y );     /* if (ey2 >= ras.max_ey) ey2 = ras.max_ey-1; */

    /* perform vertical clipping */
    if ( ( ey1 >= ras.max_ey && ey2 >= ras.max_ey ) ||
         ( ey1 <  ras.min_ey && ey2 <  ras.min_ey ) )
      goto End;

    fy1 = (TCoord)( ras.y - SUBPIXELS( ey1 ) );
    fy2 = (TCoord)( to_y - SUBPIXELS( ey2 ) );

    /* everything is on a single scanline */
    if ( ey1 == ey2 )
    {
      gray_render_scanline( RAS_VAR_ ey1, ras.x, fy1, to_x, fy2 );
      goto End;
    }

    dx = to_x - ras.x;
    dy = to_y - ras.y;

    /* vertical line - avoid calling gray_render_scanline */
    if ( dx == 0 )
    {
      TCoord  ex     = TRUNC( ras.x );
      TCoord  two_fx = (TCoord)( ( ras.x - SUBPIXELS( ex ) ) << 1 );
      TArea   area;


      if ( dy > 0)
      {
        first = ONE_PIXEL;
        incr  = 1;
      }
      else
      {
        first = 0;
        incr  = -1;
      }

      delta      = first - fy1;
      ras.area  += (TArea)two_fx * delta;
      ras.cover += delta;
      ey1       += incr;

      gray_set_cell( RAS_VAR_ ex, ey1 );

      delta = first + first - ONE_PIXEL;
      area  = (TArea)two_fx * delta;
      while ( ey1 != ey2 )
      {
        ras.area  += area;
        ras.cover += delta;
        ey1       += incr;

        gray_set_cell( RAS_VAR_ ex, ey1 );
      }

      delta      = fy2 - ONE_PIXEL + first;
      ras.area  += (TArea)two_fx * delta;
      ras.cover += delta;

      goto End;
    }

    /* ok, we have to render several scanlines */
    if ( dy > 0)
    {
      p     = ( ONE_PIXEL - fy1 ) * dx;
      first = ONE_PIXEL;
      incr  = 1;
    }
    else
    {
      p     = fy1 * dx;
      first = 0;
      incr  = -1;
      dy    = -dy;
    }

    FT_DIV_MOD( TCoord, p, dy, delta, mod );

    x = ras.x + delta;
    gray_render_scanline( RAS_VAR_ ey1, ras.x, fy1, x, first );

    ey1 += incr;
    gray_set_cell( RAS_VAR_ TRUNC( x ), ey1 );

    if ( ey1 != ey2 )
    {
      TCoord  lift, rem;


      p    = ONE_PIXEL * dx;
      FT_DIV_MOD( TCoord, p, dy, lift, rem );
      mod -= (TCoord)dy;

      do
      {
        delta = lift;
        mod  += rem;
        if ( mod >= 0 )
        {
          mod -= (TCoord)dy;
          delta++;
        }

        x2 = x + delta;
        gray_render_scanline( RAS_VAR_ ey1,
                                       x, ONE_PIXEL - first,
                                       x2, first );
        x = x2;

        ey1 += incr;
        gray_set_cell( RAS_VAR_ TRUNC( x ), ey1 );
      } while ( ey1 != ey2 );
    }

    gray_render_scanline( RAS_VAR_ ey1,
                                   x, ONE_PIXEL - first,
                                   to_x, fy2 );

  End:
    ras.x       = to_x;
    ras.y       = to_y;
  }

#else

  /*************************************************************************/
  /*                                                                       */
  /* Render a straight line across multiple cells in any direction.        */
  /*                                                                       */
  static void
  gray_render_line( RAS_ARG_ TPos  to_x,
                             TPos  to_y )
  {
    TPos    dx, dy, fx1, fy1, fx2, fy2;
    TCoord  ex1, ex2, ey1, ey2;


    ey1 = TRUNC( ras.y );
    ey2 = TRUNC( to_y );

    /* perform vertical clipping */
    if ( ( ey1 >= ras.max_ey && ey2 >= ras.max_ey ) ||
         ( ey1 <  ras.min_ey && ey2 <  ras.min_ey ) )
      goto End;

    ex1 = TRUNC( ras.x );
    ex2 = TRUNC( to_x );

    fx1 = ras.x - SUBPIXELS( ex1 );
    fy1 = ras.y - SUBPIXELS( ey1 );

    dx = to_x - ras.x;
    dy = to_y - ras.y;

    if ( ex1 == ex2 && ey1 == ey2 )       /* inside one cell */
      ;
    else if ( dy == 0 ) /* ex1 != ex2 */  /* any horizontal line */
    {
      ex1 = ex2;
      gray_set_cell( RAS_VAR_ ex1, ey1 );
    }
    else if ( dx == 0 )
    {
      if ( dy > 0 )                       /* vertical line up */
        do
        {
          fy2 = ONE_PIXEL;
          ras.cover += ( fy2 - fy1 );
          ras.area  += ( fy2 - fy1 ) * fx1 * 2;
          fy1 = 0;
          ey1++;
          gray_set_cell( RAS_VAR_ ex1, ey1 );
        } while ( ey1 != ey2 );
      else                                /* vertical line down */
        do
        {
          fy2 = 0;
          ras.cover += ( fy2 - fy1 );
          ras.area  += ( fy2 - fy1 ) * fx1 * 2;
          fy1 = ONE_PIXEL;
          ey1--;
          gray_set_cell( RAS_VAR_ ex1, ey1 );
        } while ( ey1 != ey2 );
    }
    else                                  /* any other line */
    {
      TPos  prod = dx * fy1 - dy * fx1;
      FT_UDIVPREP( ex1 != ex2, dx );
      FT_UDIVPREP( ey1 != ey2, dy );


      /* The fundamental value `prod' determines which side and the  */
      /* exact coordinate where the line exits current cell.  It is  */
      /* also easily updated when moving from one cell to the next.  */
      do
      {
        if      ( prod                                   <= 0 &&
                  prod - dx * ONE_PIXEL                  >  0 ) /* left */
        {
          fx2 = 0;
          fy2 = (TPos)FT_UDIV( -prod, -dx );
          prod -= dy * ONE_PIXEL;
          ras.cover += ( fy2 - fy1 );
          ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
          fx1 = ONE_PIXEL;
          fy1 = fy2;
          ex1--;
        }
        else if ( prod - dx * ONE_PIXEL                  <= 0 &&
                  prod - dx * ONE_PIXEL + dy * ONE_PIXEL >  0 ) /* up */
        {
          prod -= dx * ONE_PIXEL;
          fx2 = (TPos)FT_UDIV( -prod, dy );
          fy2 = ONE_PIXEL;
          ras.cover += ( fy2 - fy1 );
          ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
          fx1 = fx2;
          fy1 = 0;
          ey1++;
        }
        else if ( prod - dx * ONE_PIXEL + dy * ONE_PIXEL <= 0 &&
                  prod                  + dy * ONE_PIXEL >= 0 ) /* right */
        {
          prod += dy * ONE_PIXEL;
          fx2 = ONE_PIXEL;
          fy2 = (TPos)FT_UDIV( prod, dx );
          ras.cover += ( fy2 - fy1 );
          ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
          fx1 = 0;
          fy1 = fy2;
          ex1++;
        }
        else /* ( prod                  + dy * ONE_PIXEL <  0 &&
                  prod                                   >  0 )    down */
        {
          fx2 = (TPos)FT_UDIV( prod, -dy );
          fy2 = 0;
          prod += dx * ONE_PIXEL;
          ras.cover += ( fy2 - fy1 );
          ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
          fx1 = fx2;
          fy1 = ONE_PIXEL;
          ey1--;
        }

        gray_set_cell( RAS_VAR_ ex1, ey1 );
      } while ( ex1 != ex2 || ey1 != ey2 );
    }

    fx2 = to_x - SUBPIXELS( ex2 );
    fy2 = to_y - SUBPIXELS( ey2 );

    ras.cover += ( fy2 - fy1 );
    ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );

  End:
    ras.x       = to_x;
    ras.y       = to_y;
  }

#endif

  static void
  gray_split_conic( FT_Vector*  base )
  {
    TPos  a, b;


    base[4].x = base[2].x;
    b = base[1].x;
    a = base[3].x = ( base[2].x + b ) / 2;
    b = base[1].x = ( base[0].x + b ) / 2;
    base[2].x = ( a + b ) / 2;

    base[4].y = base[2].y;
    b = base[1].y;
    a = base[3].y = ( base[2].y + b ) / 2;
    b = base[1].y = ( base[0].y + b ) / 2;
    base[2].y = ( a + b ) / 2;
  }


  static void
  gray_render_conic( RAS_ARG_ const FT_Vector*  control,
                              const FT_Vector*  to )
  {
    FT_Vector   bez_stack[16 * 2 + 1];  /* enough to accommodate bisections */
    FT_Vector*  arc = bez_stack;
    TPos        dx, dy;
    int         draw, split;


    arc[0].x = UPSCALE( to->x );
    arc[0].y = UPSCALE( to->y );
    arc[1].x = UPSCALE( control->x );
    arc[1].y = UPSCALE( control->y );
    arc[2].x = ras.x;
    arc[2].y = ras.y;

    /* short-cut the arc that crosses the current band */
    if ( ( TRUNC( arc[0].y ) >= ras.max_ey &&
           TRUNC( arc[1].y ) >= ras.max_ey &&
           TRUNC( arc[2].y ) >= ras.max_ey ) ||
         ( TRUNC( arc[0].y ) <  ras.min_ey &&
           TRUNC( arc[1].y ) <  ras.min_ey &&
           TRUNC( arc[2].y ) <  ras.min_ey ) )
    {
      ras.x = arc[0].x;
      ras.y = arc[0].y;
      return;
    }

    dx = FT_ABS( arc[2].x + arc[0].x - 2 * arc[1].x );
    dy = FT_ABS( arc[2].y + arc[0].y - 2 * arc[1].y );
    if ( dx < dy )
      dx = dy;

    /* We can calculate the number of necessary bisections because  */
    /* each bisection predictably reduces deviation exactly 4-fold. */
    /* Even 32-bit deviation would vanish after 16 bisections.      */
    draw = 1;
    while ( dx > ONE_PIXEL / 4 )
    {
      dx   >>= 2;
      draw <<= 1;
    }

    /* We use decrement counter to count the total number of segments */
    /* to draw starting from 2^level. Before each draw we split as    */
    /* many times as there are trailing zeros in the counter.         */
    do
    {
      split = 1;
      while ( ( draw & split ) == 0 )
      {
        gray_split_conic( arc );
        arc += 2;
        split <<= 1;
      }

      gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );
      arc -= 2;

    } while ( --draw );
  }


  static void
  gray_split_cubic( FT_Vector*  base )
  {
    TPos  a, b, c, d;


    base[6].x = base[3].x;
    c = base[1].x;
    d = base[2].x;
    base[1].x = a = ( base[0].x + c ) / 2;
    base[5].x = b = ( base[3].x + d ) / 2;
    c = ( c + d ) / 2;
    base[2].x = a = ( a + c ) / 2;
    base[4].x = b = ( b + c ) / 2;
    base[3].x = ( a + b ) / 2;

    base[6].y = base[3].y;
    c = base[1].y;
    d = base[2].y;
    base[1].y = a = ( base[0].y + c ) / 2;
    base[5].y = b = ( base[3].y + d ) / 2;
    c = ( c + d ) / 2;
    base[2].y = a = ( a + c ) / 2;
    base[4].y = b = ( b + c ) / 2;
    base[3].y = ( a + b ) / 2;
  }


  static void
  gray_render_cubic( RAS_ARG_ const FT_Vector*  control1,
                              const FT_Vector*  control2,
                              const FT_Vector*  to )
  {
    FT_Vector   bez_stack[16 * 3 + 1];  /* enough to accommodate bisections */
    FT_Vector*  arc = bez_stack;
    TPos        dx, dy, dx_, dy_;
    TPos        dx1, dy1, dx2, dy2;
    TPos        L, s, s_limit;


    arc[0].x = UPSCALE( to->x );
    arc[0].y = UPSCALE( to->y );
    arc[1].x = UPSCALE( control2->x );
    arc[1].y = UPSCALE( control2->y );
    arc[2].x = UPSCALE( control1->x );
    arc[2].y = UPSCALE( control1->y );
    arc[3].x = ras.x;
    arc[3].y = ras.y;

    /* short-cut the arc that crosses the current band */
    if ( ( TRUNC( arc[0].y ) >= ras.max_ey &&
           TRUNC( arc[1].y ) >= ras.max_ey &&
           TRUNC( arc[2].y ) >= ras.max_ey &&
           TRUNC( arc[3].y ) >= ras.max_ey ) ||
         ( TRUNC( arc[0].y ) <  ras.min_ey &&
           TRUNC( arc[1].y ) <  ras.min_ey &&
           TRUNC( arc[2].y ) <  ras.min_ey &&
           TRUNC( arc[3].y ) <  ras.min_ey ) )
    {
      ras.x = arc[0].x;
      ras.y = arc[0].y;
      return;
    }

    for (;;)
    {
      /* Decide whether to split or draw. See `Rapid Termination          */
      /* Evaluation for Recursive Subdivision of Bezier Curves' by Thomas */
      /* F. Hain, at                                                      */
      /* http://www.cis.southalabama.edu/~hain/general/Publications/Bezier/Camera-ready%20CISST02%202.pdf */

      /* dx and dy are x and y components of the P0-P3 chord vector. */
      dx = dx_ = arc[3].x - arc[0].x;
      dy = dy_ = arc[3].y - arc[0].y;

      L = FT_HYPOT( dx_, dy_ );

      /* Avoid possible arithmetic overflow below by splitting. */
      if ( L > 32767 )
        goto Split;

      /* Max deviation may be as much as (s/L) * 3/4 (if Hain's v = 1). */
      s_limit = L * (TPos)( ONE_PIXEL / 6 );

      /* s is L * the perpendicular distance from P1 to the line P0-P3. */
      dx1 = arc[1].x - arc[0].x;
      dy1 = arc[1].y - arc[0].y;
      s = FT_ABS( dy * dx1 - dx * dy1 );

      if ( s > s_limit )
        goto Split;

      /* s is L * the perpendicular distance from P2 to the line P0-P3. */
      dx2 = arc[2].x - arc[0].x;
      dy2 = arc[2].y - arc[0].y;
      s = FT_ABS( dy * dx2 - dx * dy2 );

      if ( s > s_limit )
        goto Split;

      /* Split super curvy segments where the off points are so far
         from the chord that the angles P0-P1-P3 or P0-P2-P3 become
         acute as detected by appropriate dot products. */
      if ( dx1 * ( dx1 - dx ) + dy1 * ( dy1 - dy ) > 0 ||
           dx2 * ( dx2 - dx ) + dy2 * ( dy2 - dy ) > 0 )
        goto Split;

      gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );

      if ( arc == bez_stack )
        return;

      arc -= 3;
      continue;

    Split:
      gray_split_cubic( arc );
      arc += 3;
    }
  }


  static int
  gray_move_to( const FT_Vector*  to,
                gray_PWorker      worker )
  {
    TPos  x, y;


    /* start to a new position */
    x = UPSCALE( to->x );
    y = UPSCALE( to->y );

    gray_set_cell( RAS_VAR_ TRUNC( x ), TRUNC( y ) );

    ras.x = x;
    ras.y = y;
    return 0;
  }


  static int
  gray_line_to( const FT_Vector*  to,
                gray_PWorker      worker )
  {
    gray_render_line( RAS_VAR_ UPSCALE( to->x ), UPSCALE( to->y ) );
    return 0;
  }


  static int
  gray_conic_to( const FT_Vector*  control,
                 const FT_Vector*  to,
                 gray_PWorker      worker )
  {
    gray_render_conic( RAS_VAR_ control, to );
    return 0;
  }


  static int
  gray_cubic_to( const FT_Vector*  control1,
                 const FT_Vector*  control2,
                 const FT_Vector*  to,
                 gray_PWorker      worker )
  {
    gray_render_cubic( RAS_VAR_ control1, control2, to );
    return 0;
  }


  static void
  gray_hline( RAS_ARG_ TCoord  x,
                       TCoord  y,
                       TArea   area,
                       TCoord  acount )
  {
    int      coverage;
    FT_Span  span;


    /* compute the coverage line's coverage, depending on the    */
    /* outline fill rule                                         */
    /*                                                           */
    /* the coverage percentage is area/(PIXEL_BITS*PIXEL_BITS*2) */
    /*                                                           */
    coverage = (int)( area >> ( PIXEL_BITS * 2 + 1 - 8 ) );
                                                    /* use range 0..256 */
    if ( coverage < 0 )
      coverage = -coverage;

    if ( ras.outline.flags & FT_OUTLINE_EVEN_ODD_FILL )
    {
      coverage &= 511;

      if ( coverage > 256 )
        coverage = 512 - coverage;
      else if ( coverage == 256 )
        coverage = 255;
    }
    else
    {
      /* normal non-zero winding rule */
      if ( coverage >= 256 )
        coverage = 255;
    }

    if ( ras.render_span )  /* for FT_RASTER_FLAG_DIRECT only */
    {
      span.x        = (short)x;
      span.len      = (unsigned short)acount;
      span.coverage = (unsigned char)coverage;

      ras.render_span( y, 1, &span, ras.render_span_data );
    }
    else
    {
      unsigned char*  q = ras.target.origin - ras.target.pitch * y + x;
      unsigned char   c = (unsigned char)coverage;


      /* For small-spans it is faster to do it by ourselves than
       * calling `memset'.  This is mainly due to the cost of the
       * function call.
       */
      switch ( acount )
      {
      case 7: *q++ = c;
      case 6: *q++ = c;
      case 5: *q++ = c;
      case 4: *q++ = c;
      case 3: *q++ = c;
      case 2: *q++ = c;
      case 1: *q   = c;
      case 0: break;
      default:
        FT_MEM_SET( q, c, acount );
      }
    }
  }


  static void
  gray_sweep( RAS_ARG )
  {
    int  y;


    FT_TRACE7(( "gray_sweep: start\n" ));

    for ( y = ras.min_ey; y < ras.max_ey; y++ )
    {
      PCell   cell  = ras.ycells[y - ras.min_ey];
      TCoord  cover = 0;
      TCoord  x     = ras.min_ex;


      for ( ; cell != NULL; cell = cell->next )
      {
        TArea  area;


        if ( cover != 0 && cell->x > x )
          gray_hline( RAS_VAR_ x, y, (TArea)cover * ( ONE_PIXEL * 2 ),
                      cell->x - x );

        cover += cell->cover;
        area   = (TArea)cover * ( ONE_PIXEL * 2 ) - cell->area;

        if ( area != 0 && cell->x >= ras.min_ex )
          gray_hline( RAS_VAR_ cell->x, y, area, 1 );

        x = cell->x + 1;
      }

      if ( cover != 0 )
        gray_hline( RAS_VAR_ x, y, (TArea)cover * ( ONE_PIXEL * 2 ),
                    ras.max_ex - x );
    }

    FT_TRACE7(( "gray_sweep: end\n" ));
  }


#ifdef STANDALONE_

  /*************************************************************************/
  /*                                                                       */
  /*  The following functions should only compile in stand-alone mode,     */
  /*  i.e., when building this component without the rest of FreeType.     */
  /*                                                                       */
  /*************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Outline_Decompose                                               */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Walk over an outline's structure to decompose it into individual   */
  /*    segments and Bézier arcs.  This function is also able to emit      */
  /*    `move to' and `close to' operations to indicate the start and end  */
  /*    of new contours in the outline.                                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    outline        :: A pointer to the source target.                  */
  /*                                                                       */
  /*    func_interface :: A table of `emitters', i.e., function pointers   */
  /*                      called during decomposition to indicate path     */
  /*                      operations.                                      */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    user           :: A typeless pointer which is passed to each       */
  /*                      emitter during the decomposition.  It can be     */
  /*                      used to store the state during the               */
  /*                      decomposition.                                   */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0 means success.                                      */
  /*                                                                       */
  static int
  FT_Outline_Decompose( const FT_Outline*        outline,
                        const FT_Outline_Funcs*  func_interface,
                        void*                    user )
  {
#undef SCALED
#define SCALED( x )  ( ( (x) << shift ) - delta )

    FT_Vector   v_last;
    FT_Vector   v_control;
    FT_Vector   v_start;

    FT_Vector*  point;
    FT_Vector*  limit;
    char*       tags;

    int         error;

    int   n;         /* index of contour in outline     */
    int   first;     /* index of first point in contour */
    char  tag;       /* current point's state           */

    int   shift;
    TPos  delta;


    if ( !outline )
      return FT_THROW( Invalid_Outline );

    if ( !func_interface )
      return FT_THROW( Invalid_Argument );

    shift = func_interface->shift;
    delta = func_interface->delta;
    first = 0;

    for ( n = 0; n < outline->n_contours; n++ )
    {
      int  last;  /* index of last point in contour */


      FT_TRACE5(( "FT_Outline_Decompose: Outline %d\n", n ));

      last  = outline->contours[n];
      if ( last < 0 )
        goto Invalid_Outline;
      limit = outline->points + last;

      v_start   = outline->points[first];
      v_start.x = SCALED( v_start.x );
      v_start.y = SCALED( v_start.y );

      v_last   = outline->points[last];
      v_last.x = SCALED( v_last.x );
      v_last.y = SCALED( v_last.y );

      v_control = v_start;

      point = outline->points + first;
      tags  = outline->tags   + first;
      tag   = FT_CURVE_TAG( tags[0] );

      /* A contour cannot start with a cubic control point! */
      if ( tag == FT_CURVE_TAG_CUBIC )
        goto Invalid_Outline;

      /* check first point to determine origin */
      if ( tag == FT_CURVE_TAG_CONIC )
      {
        /* first point is conic control.  Yes, this happens. */
        if ( FT_CURVE_TAG( outline->tags[last] ) == FT_CURVE_TAG_ON )
        {
          /* start at last point if it is on the curve */
          v_start = v_last;
          limit--;
        }
        else
        {
          /* if both first and last points are conic,         */
          /* start at their middle and record its position    */
          /* for closure                                      */
          v_start.x = ( v_start.x + v_last.x ) / 2;
          v_start.y = ( v_start.y + v_last.y ) / 2;

          v_last = v_start;
        }
        point--;
        tags--;
      }

      FT_TRACE5(( "  move to (%.2f, %.2f)\n",
                  v_start.x / 64.0, v_start.y / 64.0 ));
      error = func_interface->move_to( &v_start, user );
      if ( error )
        goto Exit;

      while ( point < limit )
      {
        point++;
        tags++;

        tag = FT_CURVE_TAG( tags[0] );
        switch ( tag )
        {
        case FT_CURVE_TAG_ON:  /* emit a single line_to */
          {
            FT_Vector  vec;


            vec.x = SCALED( point->x );
            vec.y = SCALED( point->y );

            FT_TRACE5(( "  line to (%.2f, %.2f)\n",
                        vec.x / 64.0, vec.y / 64.0 ));
            error = func_interface->line_to( &vec, user );
            if ( error )
              goto Exit;
            continue;
          }

        case FT_CURVE_TAG_CONIC:  /* consume conic arcs */
          v_control.x = SCALED( point->x );
          v_control.y = SCALED( point->y );

        Do_Conic:
          if ( point < limit )
          {
            FT_Vector  vec;
            FT_Vector  v_middle;


            point++;
            tags++;
            tag = FT_CURVE_TAG( tags[0] );

            vec.x = SCALED( point->x );
            vec.y = SCALED( point->y );

            if ( tag == FT_CURVE_TAG_ON )
            {
              FT_TRACE5(( "  conic to (%.2f, %.2f)"
                          " with control (%.2f, %.2f)\n",
                          vec.x / 64.0, vec.y / 64.0,
                          v_control.x / 64.0, v_control.y / 64.0 ));
              error = func_interface->conic_to( &v_control, &vec, user );
              if ( error )
                goto Exit;
              continue;
            }

            if ( tag != FT_CURVE_TAG_CONIC )
              goto Invalid_Outline;

            v_middle.x = ( v_control.x + vec.x ) / 2;
            v_middle.y = ( v_control.y + vec.y ) / 2;

            FT_TRACE5(( "  conic to (%.2f, %.2f)"
                        " with control (%.2f, %.2f)\n",
                        v_middle.x / 64.0, v_middle.y / 64.0,
                        v_control.x / 64.0, v_control.y / 64.0 ));
            error = func_interface->conic_to( &v_control, &v_middle, user );
            if ( error )
              goto Exit;

            v_control = vec;
            goto Do_Conic;
          }

          FT_TRACE5(( "  conic to (%.2f, %.2f)"
                      " with control (%.2f, %.2f)\n",
                      v_start.x / 64.0, v_start.y / 64.0,
                      v_control.x / 64.0, v_control.y / 64.0 ));
          error = func_interface->conic_to( &v_control, &v_start, user );
          goto Close;

        default:  /* FT_CURVE_TAG_CUBIC */
          {
            FT_Vector  vec1, vec2;


            if ( point + 1 > limit                             ||
                 FT_CURVE_TAG( tags[1] ) != FT_CURVE_TAG_CUBIC )
              goto Invalid_Outline;

            point += 2;
            tags  += 2;

            vec1.x = SCALED( point[-2].x );
            vec1.y = SCALED( point[-2].y );

            vec2.x = SCALED( point[-1].x );
            vec2.y = SCALED( point[-1].y );

            if ( point <= limit )
            {
              FT_Vector  vec;


              vec.x = SCALED( point->x );
              vec.y = SCALED( point->y );

              FT_TRACE5(( "  cubic to (%.2f, %.2f)"
                          " with controls (%.2f, %.2f) and (%.2f, %.2f)\n",
                          vec.x / 64.0, vec.y / 64.0,
                          vec1.x / 64.0, vec1.y / 64.0,
                          vec2.x / 64.0, vec2.y / 64.0 ));
              error = func_interface->cubic_to( &vec1, &vec2, &vec, user );
              if ( error )
                goto Exit;
              continue;
            }

            FT_TRACE5(( "  cubic to (%.2f, %.2f)"
                        " with controls (%.2f, %.2f) and (%.2f, %.2f)\n",
                        v_start.x / 64.0, v_start.y / 64.0,
                        vec1.x / 64.0, vec1.y / 64.0,
                        vec2.x / 64.0, vec2.y / 64.0 ));
            error = func_interface->cubic_to( &vec1, &vec2, &v_start, user );
            goto Close;
          }
        }
      }

      /* close the contour with a line segment */
      FT_TRACE5(( "  line to (%.2f, %.2f)\n",
                  v_start.x / 64.0, v_start.y / 64.0 ));
      error = func_interface->line_to( &v_start, user );

   Close:
      if ( error )
        goto Exit;

      first = last + 1;
    }

    FT_TRACE5(( "FT_Outline_Decompose: Done\n", n ));
    return 0;

  Exit:
    FT_TRACE5(( "FT_Outline_Decompose: Error %d\n", error ));
    return error;

  Invalid_Outline:
    return FT_THROW( Invalid_Outline );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Outline_Get_CBox                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return an outline's `control box'.  The control box encloses all   */
  /*    the outline's points, including Bézier control points.  Though it  */
  /*    coincides with the exact bounding box for most glyphs, it can be   */
  /*    slightly larger in some situations (like when rotating an outline  */
  /*    that contains Bézier outside arcs).                                */
  /*                                                                       */
  /*    Computing the control box is very fast, while getting the bounding */
  /*    box can take much more time as it needs to walk over all segments  */
  /*    and arcs in the outline.  To get the latter, you can use the       */
  /*    `ftbbox' component, which is dedicated to this single task.        */
  /*                                                                       */
  /* <Input>                                                               */
  /*    outline :: A pointer to the source outline descriptor.             */
  /*                                                                       */
  /* <Output>                                                              */
  /*    acbox   :: The outline's control box.                              */
  /*                                                                       */
  /* <Note>                                                                */
  /*    See @@FT_Glyph_Get_CBox for a discussion of tricky fonts.           */
  /*                                                                       */

  static void
  FT_Outline_Get_CBox( const FT_Outline*  outline,
                       FT_BBox           *acbox )
  {
    TPos  xMin, yMin, xMax, yMax;


    if ( outline && acbox )
    {
      if ( outline->n_points == 0 )
      {
        xMin = 0;
        yMin = 0;
        xMax = 0;
        yMax = 0;
      }
      else
      {
        FT_Vector*  vec   = outline->points;
        FT_Vector*  limit = vec + outline->n_points;


        xMin = xMax = vec->x;
        yMin = yMax = vec->y;
        vec++;

        for ( ; vec < limit; vec++ )
        {
          TPos  x, y;


          x = vec->x;
          if ( x < xMin ) xMin = x;
          if ( x > xMax ) xMax = x;

          y = vec->y;
          if ( y < yMin ) yMin = y;
          if ( y > yMax ) yMax = y;
        }
      }
      acbox->xMin = xMin;
      acbox->xMax = xMax;
      acbox->yMin = yMin;
      acbox->yMax = yMax;
    }
  }

#endif /* STANDALONE_ */


  FT_DEFINE_OUTLINE_FUNCS(
    func_interface,

    (FT_Outline_MoveTo_Func) gray_move_to,   /* move_to  */
    (FT_Outline_LineTo_Func) gray_line_to,   /* line_to  */
    (FT_Outline_ConicTo_Func)gray_conic_to,  /* conic_to */
    (FT_Outline_CubicTo_Func)gray_cubic_to,  /* cubic_to */

    0,                                       /* shift    */
    0                                        /* delta    */
  )


  static int
  gray_convert_glyph_inner( RAS_ARG )
  {

    volatile int  error = 0;

#ifdef FT_CONFIG_OPTION_PIC
      FT_Outline_Funcs func_interface;
      Init_Class_func_interface(&func_interface);
#endif

    if ( ft_setjmp( ras.jump_buffer ) == 0 )
    {
      error = FT_Outline_Decompose( &ras.outline, &func_interface, &ras );
      if ( !ras.invalid )
        gray_record_cell( RAS_VAR );

      FT_TRACE7(( "band [%d..%d]: %d cells\n",
                  ras.min_ey, ras.max_ey, ras.num_cells ));
    }
    else
    {
      error = FT_THROW( Memory_Overflow );

      FT_TRACE7(( "band [%d..%d]: to be bisected\n",
                  ras.min_ey, ras.max_ey ));
    }

    return error;
  }


  static int
  gray_convert_glyph( RAS_ARG )
  {
    TCell    buffer[FT_MAX_GRAY_POOL];
    TCoord   band_size = FT_MAX_GRAY_POOL / 8;
    TCoord   count = ras.max_ey - ras.min_ey;
    int      num_bands;
    TCoord   min, max, max_y;
    TCoord   bands[32];  /* enough to accommodate bisections */
    TCoord*  band;


    /* set up vertical bands */
    if ( count > band_size )
    {
      /* two divisions rounded up */
      num_bands = (int)( ( count + band_size - 1) / band_size );
      band_size = ( count + num_bands - 1 ) / num_bands;
    }

    min   = ras.min_ey;
    max_y = ras.max_ey;

    for ( ; min < max_y; min = max )
    {
      max = min + band_size;
      if ( max > max_y )
        max = max_y;

      band    = bands;
      band[1] = min;
      band[0] = max;

      do
      {
        TCoord  width = band[0] - band[1];
        int     error;


        /* memory management */
        {
          size_t  ycount = (size_t)width;
          size_t  cell_start;


          cell_start = ( ycount * sizeof ( PCell ) + sizeof ( TCell ) - 1 ) /
                       sizeof ( TCell );

          ras.cells     = buffer + cell_start;
          ras.max_cells = (FT_PtrDist)( FT_MAX_GRAY_POOL - cell_start );
          ras.num_cells = 0;

          ras.ycells = (PCell*)buffer;
          while ( ycount )
            ras.ycells[--ycount] = NULL;
        }

        ras.invalid   = 1;
        ras.min_ey    = band[1];
        ras.max_ey    = band[0];

        error = gray_convert_glyph_inner( RAS_VAR );

        if ( !error )
        {
          gray_sweep( RAS_VAR );
          band--;
          continue;
        }
        else if ( error != ErrRaster_Memory_Overflow )
          return 1;

        /* render pool overflow; we will reduce the render band by half */
        width >>= 1;

        /* This is too complex for a single scanline; there must */
        /* be some problems.                                     */
        if ( width == 0 )
        {
          FT_TRACE7(( "gray_convert_glyph: rotten glyph\n" ));
          return 1;
        }

        band++;
        band[1]  = band[0];
        band[0] += width;
      } while ( band >= bands );
    }

    return 0;
  }


  static int
  gray_raster_render( FT_Raster                raster,
                      const FT_Raster_Params*  params )
  {
    const FT_Outline*  outline    = (const FT_Outline*)params->source;
    const FT_Bitmap*   target_map = params->target;
    FT_BBox            cbox, clip;

#ifndef FT_STATIC_RASTER
    gray_TWorker  worker[1];
#endif


    if ( !raster )
      return FT_THROW( Invalid_Argument );

    /* this version does not support monochrome rendering */
    if ( !( params->flags & FT_RASTER_FLAG_AA ) )
      return FT_THROW( Invalid_Mode );

    if ( !outline )
      return FT_THROW( Invalid_Outline );

    /* return immediately if the outline is empty */
    if ( outline->n_points == 0 || outline->n_contours <= 0 )
      return 0;

    if ( !outline->contours || !outline->points )
      return FT_THROW( Invalid_Outline );

    if ( outline->n_points !=
           outline->contours[outline->n_contours - 1] + 1 )
      return FT_THROW( Invalid_Outline );

    ras.outline = *outline;

    if ( params->flags & FT_RASTER_FLAG_DIRECT )
    {
      if ( !params->gray_spans )
        return 0;

      ras.render_span      = (FT_Raster_Span_Func)params->gray_spans;
      ras.render_span_data = params->user;
    }
    else
    {
      /* if direct mode is not set, we must have a target bitmap */
      if ( !target_map )
        return FT_THROW( Invalid_Argument );

      /* nothing to do */
      if ( !target_map->width || !target_map->rows )
        return 0;

      if ( !target_map->buffer )
        return FT_THROW( Invalid_Argument );

      if ( target_map->pitch < 0 )
        ras.target.origin = target_map->buffer;
      else
        ras.target.origin = target_map->buffer
              + ( target_map->rows - 1 ) * (unsigned int)target_map->pitch;

      ras.target.pitch = target_map->pitch;

      ras.render_span      = (FT_Raster_Span_Func)NULL;
      ras.render_span_data = NULL;
    }

    FT_Outline_Get_CBox( outline, &cbox );

    /* reject too large outline coordinates */
    if ( cbox.xMin < -0x1000000L || cbox.xMax > 0x1000000L ||
         cbox.yMin < -0x1000000L || cbox.yMax > 0x1000000L )
      return FT_THROW( Invalid_Outline );

    /* truncate the bounding box to integer pixels */
    cbox.xMin = cbox.xMin >> 6;
    cbox.yMin = cbox.yMin >> 6;
    cbox.xMax = ( cbox.xMax + 63 ) >> 6;
    cbox.yMax = ( cbox.yMax + 63 ) >> 6;

    /* compute clipping box */
    if ( !( params->flags & FT_RASTER_FLAG_DIRECT ) )
    {
      /* compute clip box from target pixmap */
      clip.xMin = 0;
      clip.yMin = 0;
      clip.xMax = (FT_Pos)target_map->width;
      clip.yMax = (FT_Pos)target_map->rows;
    }
    else if ( params->flags & FT_RASTER_FLAG_CLIP )
      clip = params->clip_box;
    else
    {
      clip.xMin = -32768L;
      clip.yMin = -32768L;
      clip.xMax =  32767L;
      clip.yMax =  32767L;
    }

    /* clip to target bitmap, exit if nothing to do */
    ras.min_ex = FT_MAX( cbox.xMin, clip.xMin );
    ras.min_ey = FT_MAX( cbox.yMin, clip.yMin );
    ras.max_ex = FT_MIN( cbox.xMax, clip.xMax );
    ras.max_ey = FT_MIN( cbox.yMax, clip.yMax );

    if ( ras.max_ex <= ras.min_ex || ras.max_ey <= ras.min_ey )
      return 0;

    return gray_convert_glyph( RAS_VAR );
  }


  /**** RASTER OBJECT CREATION: In stand-alone mode, we simply use *****/
  /****                         a static object.                   *****/

#ifdef STANDALONE_

  static int
  gray_raster_new( void*       memory,
                   FT_Raster*  araster )
  {
    static gray_TRaster  the_raster;

    FT_UNUSED( memory );


    *araster = (FT_Raster)&the_raster;
    FT_ZERO( &the_raster );

    return 0;
  }


  static void
  gray_raster_done( FT_Raster  raster )
  {
    /* nothing */
    FT_UNUSED( raster );
  }

#else /* !STANDALONE_ */

  static int
  gray_raster_new( FT_Memory   memory,
                   FT_Raster*  araster )
  {
    FT_Error      error;
    gray_PRaster  raster = NULL;


    *araster = 0;
    if ( !FT_ALLOC( raster, sizeof ( gray_TRaster ) ) )
    {
      raster->memory = memory;
      *araster       = (FT_Raster)raster;
    }

    return error;
  }


  static void
  gray_raster_done( FT_Raster  raster )
  {
    FT_Memory  memory = (FT_Memory)((gray_PRaster)raster)->memory;


    FT_FREE( raster );
  }

#endif /* !STANDALONE_ */


  static void
  gray_raster_reset( FT_Raster       raster,
                     unsigned char*  pool_base,
                     unsigned long   pool_size )
  {
    FT_UNUSED( raster );
    FT_UNUSED( pool_base );
    FT_UNUSED( pool_size );
  }


  static int
  gray_raster_set_mode( FT_Raster      raster,
                        unsigned long  mode,
                        void*          args )
  {
    FT_UNUSED( raster );
    FT_UNUSED( mode );
    FT_UNUSED( args );


    return 0; /* nothing to do */
  }


  FT_DEFINE_RASTER_FUNCS(
    ft_grays_raster,

    FT_GLYPH_FORMAT_OUTLINE,

    (FT_Raster_New_Func)     gray_raster_new,       /* raster_new      */
    (FT_Raster_Reset_Func)   gray_raster_reset,     /* raster_reset    */
    (FT_Raster_Set_Mode_Func)gray_raster_set_mode,  /* raster_set_mode */
    (FT_Raster_Render_Func)  gray_raster_render,    /* raster_render   */
    (FT_Raster_Done_Func)    gray_raster_done       /* raster_done     */
  )


/* END */


/* Local Variables: */
/* coding: utf-8    */
/* End:             */
@


1.26
log
@
Update to FreeType 2.7

Now Subpixel hinting, also known as ClearType hinting, is enabled
by default.

OK matthieu@@
@
text
@d289 4
d378 3
a380 2
#define FT_UDIVPREP( b )                                       \
  long  b ## _r = (long)( FT_ULONG_MAX >> PIXEL_BITS ) / ( b )
d446 1
a458 2
    PCell*     ycells;

d511 2
a512 2
  static PCell
  gray_find_cell( RAS_ARG )
a517 3
    if ( x > ras.max_ex )
      x = ras.max_ex;

d522 1
a522 1
      if ( cell == NULL || cell->x > x )
d526 1
a526 1
        goto Exit;
d534 1
d537 2
a538 2
    cell->area  = 0;
    cell->cover = 0;
d543 1
a543 4
  Exit:
    return cell;
  }

d545 4
a548 11
  static void
  gray_record_cell( RAS_ARG )
  {
    if ( ras.area | ras.cover )
    {
      PCell  cell = gray_find_cell( RAS_VAR );


      cell->area  += ras.area;
      cell->cover += ras.cover;
    }
a571 2
    if ( ex > ras.max_ex )
      ex = ras.max_ex;
d576 8
a583 12
    /* are we moving to a different cell ? */
    if ( ex != ras.ex || ey != ras.ey )
    {
      /* record the current one if it is valid */
      if ( !ras.invalid )
        gray_record_cell( RAS_VAR );

      ras.area  = 0;
      ras.cover = 0;
      ras.ex    = ex;
      ras.ey    = ey;
    }
d897 2
a898 2
      FT_UDIVPREP( dx );
      FT_UDIVPREP( dy );
a1304 3
    if ( ras.num_cells == 0 )
      return;

d1704 8
a1711 6
    (FT_Outline_MoveTo_Func) gray_move_to,
    (FT_Outline_LineTo_Func) gray_line_to,
    (FT_Outline_ConicTo_Func)gray_conic_to,
    (FT_Outline_CubicTo_Func)gray_cubic_to,
    0,
    0 )
a1793 3
          if ( FT_MAX_GRAY_POOL - cell_start < 2 )
            goto ReduceBands;

d1796 1
a1802 1
        ras.num_cells = 0;
d1805 1
a1805 1
        ras.max_ey    = ras.ey = band[0];
a1817 1
      ReduceBands:
d1843 2
a1844 2
    const FT_Outline*  outline     = (const FT_Outline*)params->source;
    const FT_Bitmap*   target_map  = params->target;
d1968 1
a1968 1
    FT_MEM_ZERO( &the_raster, sizeof ( the_raster ) );
d2044 6
a2049 5
    (FT_Raster_New_Func)     gray_raster_new,
    (FT_Raster_Reset_Func)   gray_raster_reset,
    (FT_Raster_Set_Mode_Func)gray_raster_set_mode,
    (FT_Raster_Render_Func)  gray_raster_render,
    (FT_Raster_Done_Func)    gray_raster_done )
@


1.25
log
@
Update to FreeType 2.6.5

ok matthieu@@
@
text
@d406 4
d411 1
a411 2
  /* maximum number of gray spans in a call to the span callback */
#define FT_MAX_GRAY_SPANS  32
a435 1
    TCoord  count_ex, count_ey;
d448 1
a448 4
    FT_Bitmap   target;

    FT_Span     gray_spans[FT_MAX_GRAY_SPANS];
    int         num_gray_spans;
a451 1
    int                  span_y;
d483 1
a483 1
    int  yindex;
d486 1
a486 1
    for ( yindex = 0; yindex < ras.count_ey; yindex++ )
d488 1
a488 1
      PCell  cell;
d491 1
a491 1
      printf( "%3d:", yindex );
d493 1
a493 1
      for ( cell = ras.ycells[yindex]; cell != NULL; cell = cell->next )
d514 2
a515 2
    if ( x > ras.count_ex )
      x = ras.count_ex;
d517 1
a517 1
    pcell = &ras.ycells[ras.ey];
a579 2
    ey -= ras.min_ey;

d583 2
a584 3
    ex -= ras.min_ex;
    if ( ex < 0 )
      ex = -1;
d599 2
a600 2
    ras.invalid = ( (unsigned int)ey >= (unsigned int)ras.count_ey ||
                                  ex >= ras.count_ex               );
a603 23
  /*************************************************************************/
  /*                                                                       */
  /* Start a new contour at a given cell.                                  */
  /*                                                                       */
  static void
  gray_start_cell( RAS_ARG_ TCoord  ex,
                            TCoord  ey )
  {
    if ( ex > ras.max_ex )
      ex = ras.max_ex;

    if ( ex < ras.min_ex )
      ex = ras.min_ex - 1;

    ras.area    = 0;
    ras.cover   = 0;
    ras.ex      = ex - ras.min_ex;
    ras.ey      = ey - ras.min_ey;
    ras.invalid = 0;

    gray_set_cell( RAS_VAR_ ex, ey );
  }

d632 3
a634 2
    fx1 = (TCoord)( x1 - SUBPIXELS( ex1 ) );
    fx2 = (TCoord)( x2 - SUBPIXELS( ex2 ) );
a639 1
      delta      = y2 - y1;
d648 1
a648 4
    p     = ( ONE_PIXEL - fx1 ) * ( y2 - y1 );
    first = ONE_PIXEL;
    incr  = 1;
    dx    = x2 - x1;
d650 7
a656 1
    if ( dx < 0 )
d658 1
a658 1
      p     = fx1 * ( y2 - y1 );
a741 2
    incr = 1;

d749 6
a754 2
      first = ONE_PIXEL;
      if ( dy < 0 )
d786 7
a792 5
    p     = ( ONE_PIXEL - fy1 ) * dx;
    first = ONE_PIXEL;
    incr  = 1;

    if ( dy < 0 )
a1199 4
    /* record current cell, if any */
    if ( !ras.invalid )
      gray_record_cell( RAS_VAR );

d1204 1
a1204 1
    gray_start_cell( RAS_VAR_ TRUNC( x ), TRUNC( y ) );
a1242 47
  gray_render_span( int             y,
                    int             count,
                    const FT_Span*  spans,
                    gray_PWorker    worker )
  {
    unsigned char*  p;
    FT_Bitmap*      map = &worker->target;


    /* first of all, compute the scanline offset */
    p = (unsigned char*)map->buffer - y * map->pitch;
    if ( map->pitch >= 0 )
      p += ( map->rows - 1 ) * (unsigned int)map->pitch;

    for ( ; count > 0; count--, spans++ )
    {
      unsigned char  coverage = spans->coverage;


      if ( coverage )
      {
        unsigned char*  q = p + spans->x;


        /* For small-spans it is faster to do it by ourselves than
         * calling `memset'.  This is mainly due to the cost of the
         * function call.
         */
        switch ( spans->len )
        {
        case 7: *q++ = coverage;
        case 6: *q++ = coverage;
        case 5: *q++ = coverage;
        case 4: *q++ = coverage;
        case 3: *q++ = coverage;
        case 2: *q++ = coverage;
        case 1: *q   = coverage;
        case 0: break;
        default:
          FT_MEM_SET( q, coverage, spans->len );
        }
      }
    }
  }


  static void
d1248 2
a1249 1
    int  coverage;
d1278 5
a1282 2
    y += ras.min_ey;
    x += ras.min_ex;
d1284 3
a1286 1
    if ( coverage )
d1288 2
a1289 2
      FT_Span*  span;
      int       count;
d1292 5
a1296 7
      /* see whether we can add this span to the current list */
      count = ras.num_gray_spans;
      span  = ras.gray_spans + count - 1;
      if ( span->coverage == coverage &&
           span->x + span->len == x   &&
           ras.span_y == y            &&
           count > 0                  )
d1298 10
a1307 2
        span->len = (unsigned short)( span->len + acount );
        return;
a1308 38

      if ( ras.span_y != y || count >= FT_MAX_GRAY_SPANS )
      {
        if ( ras.render_span && count > 0 )
          ras.render_span( ras.span_y, count, ras.gray_spans,
                           ras.render_span_data );

#ifdef FT_DEBUG_LEVEL_TRACE

        if ( count > 0 )
        {
          int  n;


          FT_TRACE7(( "y = %3d ", ras.span_y ));
          span = ras.gray_spans;
          for ( n = 0; n < count; n++, span++ )
            FT_TRACE7(( "[%d..%d]:%02x ",
                        span->x, span->x + span->len - 1, span->coverage ));
          FT_TRACE7(( "\n" ));
        }

#endif /* FT_DEBUG_LEVEL_TRACE */

        ras.num_gray_spans = 0;
        ras.span_y         = (int)y;

        span  = ras.gray_spans;
      }
      else
        span++;

      /* add a gray span to the current list */
      span->x        = (short)x;
      span->len      = (unsigned short)acount;
      span->coverage = (unsigned char)coverage;

      ras.num_gray_spans++;
d1316 1
a1316 1
    int  yindex;
a1321 3
    ras.num_gray_spans = 0;
    ras.span_y         = 0;

d1324 1
a1324 1
    for ( yindex = 0; yindex < ras.count_ey; yindex++ )
d1326 1
a1326 1
      PCell   cell  = ras.ycells[yindex];
d1328 1
a1328 1
      TCoord  x     = 0;
d1336 2
a1337 2
        if ( cell->x > x && cover != 0 )
          gray_hline( RAS_VAR_ x, yindex, (TArea)cover * ( ONE_PIXEL * 2 ),
d1343 2
a1344 2
        if ( area != 0 && cell->x >= 0 )
          gray_hline( RAS_VAR_ cell->x, yindex, area, 1 );
d1350 2
a1351 22
        gray_hline( RAS_VAR_ x, yindex, (TArea)cover * ( ONE_PIXEL * 2 ),
                    ras.count_ex - x );
    }

    if ( ras.render_span && ras.num_gray_spans > 0 )
      ras.render_span( ras.span_y, ras.num_gray_spans,
                       ras.gray_spans, ras.render_span_data );

#ifdef FT_DEBUG_LEVEL_TRACE

    if ( ras.num_gray_spans > 0 )
    {
      FT_Span*  span;
      int       n;


      FT_TRACE7(( "y = %3d ", ras.span_y ));
      span = ras.gray_spans;
      for ( n = 0; n < ras.num_gray_spans; n++, span++ )
        FT_TRACE7(( "[%d..%d]:%02x ",
                    span->x, span->x + span->len - 1, span->coverage ));
      FT_TRACE7(( "\n" ));
a1354 3

#endif /* FT_DEBUG_LEVEL_TRACE */

a1717 7
  typedef struct  gray_TBand_
  {
    TCoord  min, max;

  } gray_TBand;


d1764 7
a1770 6
    TCell        buffer[FT_MAX_GRAY_POOL];
    TCoord       band_size = FT_MAX_GRAY_POOL / 8;
    int          num_bands;
    TCoord       min, max, max_y;
    gray_TBand   bands[32];  /* enough to accommodate bisections */
    gray_TBand*  band;
d1774 1
a1774 1
    if ( ras.count_ey > band_size )
d1777 2
a1778 2
      num_bands = (int)( ( ras.count_ey + band_size - 1) / band_size );
      band_size = ( ras.count_ey + num_bands - 1 ) / num_bands;
d1790 3
a1792 3
      bands[0].min = min;
      bands[0].max = max;
      band         = bands;
d1796 1
a1796 1
        TCoord  bottom, top, middle;
d1802 1
a1802 1
          size_t  ycount = (size_t)( band->max - band->min );
d1822 2
a1823 3
        ras.min_ey    = band->min;
        ras.max_ey    = band->max;
        ras.count_ey  = band->max - band->min;
d1838 1
a1838 3
        bottom = band->min;
        top    = band->max;
        middle = bottom + ( ( top - bottom ) >> 1 );
d1842 1
a1842 1
        if ( middle == bottom )
a1847 4
        band[1].min = bottom;
        band[1].max = middle;
        band[0].min = middle;
        band[0].max = top;
d1849 2
d1866 1
d1868 1
d1874 4
d1892 11
a1902 2
    /* if direct mode is not set, we must have a target bitmap */
    if ( !( params->flags & FT_RASTER_FLAG_DIRECT ) )
d1904 1
d1914 11
a1926 4
    /* this version does not support monochrome rendering */
    if ( !( params->flags & FT_RASTER_FLAG_AA ) )
      return FT_THROW( Invalid_Mode );

a1966 17

    ras.count_ex = ras.max_ex - ras.min_ex;
    ras.count_ey = ras.max_ey - ras.min_ey;

    ras.outline        = *outline;

    if ( params->flags & FT_RASTER_FLAG_DIRECT )
    {
      ras.render_span      = (FT_Raster_Span_Func)params->gray_spans;
      ras.render_span_data = params->user;
    }
    else
    {
      ras.target           = *target_map;
      ras.render_span      = (FT_Raster_Span_Func)gray_render_span;
      ras.render_span_data = &ras;
    }
@


1.24
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d109 1
d306 1
a306 1
#define RAS_ARG   /* empty */
d322 1
a322 1
#define ONE_PIXEL       ( 1L << PIXEL_BITS )
d324 1
a324 1
#define SUBPIXELS( x )  ( (TPos)(x) << PIXEL_BITS )
d330 1
a330 1
#define UPSCALE( x )    ( (x) << ( PIXEL_BITS - 6 ) )
d334 1
a334 1
#define DOWNSCALE( x )  ( (x) << ( 6 - PIXEL_BITS ) )
d373 1
a373 1
  /* with multiplications and right shifts.                       */ 
a389 1
  typedef long  TCoord;   /* integer scanline/pixel coordinate */
d391 2
a392 23

  /* determine the type used to store cell areas.  This normally takes at */
  /* least PIXEL_BITS*2 + 1 bits.  On 16-bit systems, we need to use      */
  /* `long' instead of `int', otherwise bad things happen                 */

#if PIXEL_BITS <= 7

  typedef int  TArea;

#else /* PIXEL_BITS >= 8 */

  /* approximately determine the size of integers using an ANSI-C header */
#if FT_UINT_MAX == 0xFFFFU
  typedef long  TArea;
#else
  typedef int   TArea;
#endif

#endif /* PIXEL_BITS >= 8 */


  /* maximum number of gray spans in a call to the span callback */
#define FT_MAX_GRAY_SPANS  32
d399 1
a399 1
    TPos    x;     /* same with gray_TWorker.ex    */
d407 11
d431 3
a433 3
    TPos    min_ex, max_ex;
    TPos    min_ey, max_ey;
    TPos    count_ex, count_ey;
a444 3
    FT_Vector   bez_stack[32 * 3 + 1];
    int         lev_stack[32];

a446 1
    FT_BBox     clip_box;
a454 6
    int  band_size;
    int  band_shoot;

    void*       buffer;
    long        buffer_size;

a455 1
    TPos       ycount;
d478 1
d480 2
a481 4
  /*************************************************************************/
  /*                                                                       */
  /* Initialize the cells table.                                           */
  /*                                                                       */
d483 1
a483 2
  gray_init_cells( RAS_ARG_ void*  buffer,
                            long   byte_size )
d485 1
a485 11
    ras.buffer      = buffer;
    ras.buffer_size = byte_size;

    ras.ycells      = (PCell*) buffer;
    ras.cells       = NULL;
    ras.max_cells   = 0;
    ras.num_cells   = 0;
    ras.area        = 0;
    ras.cover       = 0;
    ras.invalid     = 1;
  }
d488 1
a488 13
  /*************************************************************************/
  /*                                                                       */
  /* Compute the outline bounding box.                                     */
  /*                                                                       */
  static void
  gray_compute_cbox( RAS_ARG )
  {
    FT_Outline*  outline = &ras.outline;
    FT_Vector*   vec     = outline->points;
    FT_Vector*   limit   = vec + outline->n_points;


    if ( outline->n_points <= 0 )
d490 1
a490 4
      ras.min_ex = ras.max_ex = 0;
      ras.min_ey = ras.max_ey = 0;
      return;
    }
a491 2
    ras.min_ex = ras.max_ex = vec->x;
    ras.min_ey = ras.max_ey = vec->y;
d493 1
a493 1
    vec++;
d495 4
a498 10
    for ( ; vec < limit; vec++ )
    {
      TPos  x = vec->x;
      TPos  y = vec->y;


      if ( x < ras.min_ex ) ras.min_ex = x;
      if ( x > ras.max_ex ) ras.max_ex = x;
      if ( y < ras.min_ey ) ras.min_ey = y;
      if ( y > ras.max_ey ) ras.max_ey = y;
d500 1
d502 1
a502 6
    /* truncate the bounding box to integer pixels */
    ras.min_ex = ras.min_ex >> 6;
    ras.min_ey = ras.min_ey >> 6;
    ras.max_ex = ( ras.max_ex + 63 ) >> 6;
    ras.max_ey = ( ras.max_ey + 63 ) >> 6;
  }
d513 1
a513 1
    TPos    x = ras.ex;
d618 1
a618 1
      ex = (TCoord)( ras.max_ex );
d621 1
a621 1
      ex = (TCoord)( ras.min_ex - 1 );
d632 1
a632 1
#if 0
d645 2
a646 2
    TCoord  ex1, ex2, fx1, fx2, delta, mod;
    long    p, first, dx;
a649 2
    dx = x2 - x1;

a651 2
    fx1 = (TCoord)( x1 - SUBPIXELS( ex1 ) );
    fx2 = (TCoord)( x2 - SUBPIXELS( ex2 ) );
d660 3
d679 1
d740 3
a742 4
    TCoord  ey1, ey2, fy1, fy2, mod;
    TPos    dx, dy, x, x2;
    long    p, first;
    int     delta, rem, lift, incr;
a746 5
    fy1 = (TCoord)( ras.y - SUBPIXELS( ey1 ) );
    fy2 = (TCoord)( to_y - SUBPIXELS( ey2 ) );

    dx = to_x - ras.x;
    dy = to_y - ras.y;
d753 3
d763 3
d783 1
a783 1
      delta      = (int)( first - fy1 );
d790 1
a790 1
      delta = (int)( first + first - ONE_PIXEL );
d801 1
a801 1
      delta      = (int)( fy2 - ONE_PIXEL + first );
d821 1
a821 1
    FT_DIV_MOD( int, p, dy, delta, mod );
d824 1
a824 1
    gray_render_scanline( RAS_VAR_ ey1, ras.x, fy1, x, (TCoord)first );
d831 6
a836 3
      p     = ONE_PIXEL * dx;
      FT_DIV_MOD( int, p, dy, lift, rem );
      mod -= (int)dy;
d844 1
a844 1
          mod -= (int)dy;
d849 3
a851 3
        gray_render_scanline( RAS_VAR_ ey1, x,
                                       (TCoord)( ONE_PIXEL - first ), x2,
                                       (TCoord)first );
d859 3
a861 3
    gray_render_scanline( RAS_VAR_ ey1, x,
                                   (TCoord)( ONE_PIXEL - first ), to_x,
                                   fy2 );
a881 2
    ex1 = TRUNC( ras.x );
    ex2 = TRUNC( to_x );
d890 2
a891 2
    dx = to_x - ras.x;
    dy = to_y - ras.y;
d896 3
d931 1
a931 1
      TArea  prod = dx * fy1 - dy * fx1;
d1031 2
d1034 1
a1034 5
    TPos        min, max, y;
    int         top, level;
    int*        levels;
    FT_Vector*  arc;

a1035 1
    levels = ras.lev_stack;
a1036 1
    arc      = ras.bez_stack;
d1043 13
a1055 1
    top      = 0;
d1062 9
a1070 16
    if ( dx < ONE_PIXEL / 4 )
      goto Draw;

    /* short-cut the arc that crosses the current band */
    min = max = arc[0].y;

    y = arc[1].y;
    if ( y < min ) min = y;
    if ( y > max ) max = y;

    y = arc[2].y;
    if ( y < min ) min = y;
    if ( y > max ) max = y;

    if ( TRUNC( min ) >= ras.max_ey || TRUNC( max ) < ras.min_ey )
      goto Draw;
d1072 3
a1074 1
    level = 0;
d1077 2
a1078 10
      dx >>= 2;
      level++;
    } while ( dx > ONE_PIXEL / 4 );

    levels[0] = level;

    do
    {
      level = levels[top];
      if ( level > 0 )
d1082 1
a1082 3
        top++;
        levels[top] = levels[top - 1] = level - 1;
        continue;
a1084 1
    Draw:
a1085 1
      top--;
d1088 1
a1088 1
    } while ( top >= 0 );
d1125 5
a1129 2
    FT_Vector*  arc;
    TPos        min, max, y;
a1131 1
    arc      = ras.bez_stack;
d1141 14
a1154 23
    /* Short-cut the arc that crosses the current band. */
    min = max = arc[0].y;

    y = arc[1].y;
    if ( y < min )
      min = y;
    if ( y > max )
      max = y;

    y = arc[2].y;
    if ( y < min )
      min = y;
    if ( y > max )
      max = y;

    y = arc[3].y;
    if ( y < min )
      min = y;
    if ( y > max )
      max = y;

    if ( TRUNC( min ) >= ras.max_ey || TRUNC( max ) < ras.min_ey )
      goto Draw;
d1163 35
a1197 4
      {
        TPos  dx, dy, dx_, dy_;
        TPos  dx1, dy1, dx2, dy2;
        TPos  L, s, s_limit;
d1199 1
d1201 2
a1202 3
        /* dx and dy are x and y components of the P0-P3 chord vector. */
        dx = dx_ = arc[3].x - arc[0].x;
        dy = dy_ = arc[3].y - arc[0].y;
d1204 2
a1205 35
        L = FT_HYPOT( dx_, dy_ );

        /* Avoid possible arithmetic overflow below by splitting. */
        if ( L > 32767 )
          goto Split;

        /* Max deviation may be as much as (s/L) * 3/4 (if Hain's v = 1). */
        s_limit = L * (TPos)( ONE_PIXEL / 6 );

        /* s is L * the perpendicular distance from P1 to the line P0-P3. */
        dx1 = arc[1].x - arc[0].x;
        dy1 = arc[1].y - arc[0].y;
        s = FT_ABS( dy * dx1 - dx * dy1 );

        if ( s > s_limit )
          goto Split;

        /* s is L * the perpendicular distance from P2 to the line P0-P3. */
        dx2 = arc[2].x - arc[0].x;
        dy2 = arc[2].y - arc[0].y;
        s = FT_ABS( dy * dx2 - dx * dy2 );

        if ( s > s_limit )
          goto Split;

        /* Split super curvy segments where the off points are so far
           from the chord that the angles P0-P1-P3 or P0-P2-P3 become
           acute as detected by appropriate dot products. */
        if ( dx1 * ( dx1 - dx ) + dy1 * ( dy1 - dy ) > 0 ||
             dx2 * ( dx2 - dx ) + dy2 * ( dy2 - dy ) > 0 )
          goto Split;

        /* No reason to split. */
        goto Draw;
      }
a1209 9
      continue;

    Draw:
      gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );

      if ( arc == ras.bez_stack )
        return;

      arc -= 3;
d1231 2
a1232 2
    worker->x = x;
    worker->y = y;
d1289 3
d1296 1
a1296 3
        if ( spans->len >= 8 )
          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );
        else
d1298 10
a1307 15
          unsigned char*  q = p + spans->x;


          switch ( spans->len )
          {
          case 7: *q++ = (unsigned char)coverage;
          case 6: *q++ = (unsigned char)coverage;
          case 5: *q++ = (unsigned char)coverage;
          case 4: *q++ = (unsigned char)coverage;
          case 3: *q++ = (unsigned char)coverage;
          case 2: *q++ = (unsigned char)coverage;
          case 1: *q   = (unsigned char)coverage;
          default:
            ;
          }
d1317 1
a1317 1
                       TPos    area,
d1349 2
a1350 10
    y += (TCoord)ras.min_ey;
    x += (TCoord)ras.min_ex;

    /* FT_Span.x is a 16-bit short, so limit our coordinates appropriately */
    if ( x >= 32767 )
      x = 32767;

    /* FT_Span.y is an integer, so limit our coordinates appropriately */
    if ( y >= FT_INT_MAX )
      y = FT_INT_MAX;
d1361 4
a1364 4
      if ( count > 0                          &&
           ras.span_y == y                    &&
           (int)span->x + span->len == (int)x &&
           span->coverage == coverage         )
a1410 26
#ifdef FT_DEBUG_LEVEL_TRACE

  /* to be called while in the debugger --                                */
  /* this function causes a compiler warning since it is unused otherwise */
  static void
  gray_dump_cells( RAS_ARG )
  {
    int  yindex;


    for ( yindex = 0; yindex < ras.ycount; yindex++ )
    {
      PCell  cell;


      printf( "%3d:", yindex );

      for ( cell = ras.ycells[yindex]; cell != NULL; cell = cell->next )
        printf( " (%3ld, c:%4ld, a:%6d)", cell->x, cell->cover, cell->area );
      printf( "\n" );
    }
  }

#endif /* FT_DEBUG_LEVEL_TRACE */


d1412 1
a1412 1
  gray_sweep( RAS_ARG_ const FT_Bitmap*  target )
a1415 2
    FT_UNUSED( target );

d1421 1
d1425 1
a1425 1
    for ( yindex = 0; yindex < ras.ycount; yindex++ )
d1434 1
a1434 1
        TPos  area;
d1438 1
a1438 1
          gray_hline( RAS_VAR_ x, yindex, cover * ( ONE_PIXEL * 2 ),
d1442 1
a1442 1
        area   = cover * ( ONE_PIXEL * 2 ) - cell->area;
d1451 1
a1451 1
        gray_hline( RAS_VAR_ x, yindex, cover * ( ONE_PIXEL * 2 ),
d1486 1
a1486 1
  /*  The following function should only compile in stand-alone mode,      */
d1764 75
d1844 1
a1844 1
    TPos  min, max;
d1876 3
d1881 1
d1884 4
d1895 6
a1900 16
    gray_TBand            bands[40];
    gray_TBand* volatile  band;
    int volatile          n, num_bands;
    TPos volatile         min, max, max_y;
    FT_BBox*              clip;


    /* Set up state in the raster object */
    gray_compute_cbox( RAS_VAR );

    /* clip to target bitmap, exit if nothing to do */
    clip = &ras.clip_box;

    if ( ras.max_ex <= clip->xMin || ras.min_ex >= clip->xMax ||
         ras.max_ey <= clip->yMin || ras.min_ey >= clip->yMax )
      return 0;
a1901 8
    if ( ras.min_ex < clip->xMin ) ras.min_ex = clip->xMin;
    if ( ras.min_ey < clip->yMin ) ras.min_ey = clip->yMin;

    if ( ras.max_ex > clip->xMax ) ras.max_ex = clip->xMax;
    if ( ras.max_ey > clip->yMax ) ras.max_ey = clip->yMax;

    ras.count_ex = ras.max_ex - ras.min_ex;
    ras.count_ey = ras.max_ey - ras.min_ey;
d1904 6
a1909 7
    num_bands = (int)( ( ras.max_ey - ras.min_ey ) / ras.band_size );
    if ( num_bands == 0 )
      num_bands = 1;
    if ( num_bands >= 39 )
      num_bands = 39;

    ras.band_shoot = 0;
d1914 1
a1914 1
    for ( n = 0; n < num_bands; n++, min = max )
d1916 2
a1917 2
      max = min + ras.band_size;
      if ( n == num_bands - 1 || max > max_y )
d1926 3
a1928 2
        TPos  bottom, top, middle;
        int   error;
d1930 1
d1932 2
a1933 3
          PCell  cells_max;
          int    yindex;
          long   cell_start, cell_end, cell_mod;
d1936 2
a1937 2
          ras.ycells = (PCell*)ras.buffer;
          ras.ycount = band->max - band->min;
d1939 1
a1939 11
          cell_start = (long)sizeof ( PCell ) * ras.ycount;
          cell_mod   = cell_start % (long)sizeof ( TCell );
          if ( cell_mod > 0 )
            cell_start += (long)sizeof ( TCell ) - cell_mod;

          cell_end  = ras.buffer_size;
          cell_end -= cell_end % (long)sizeof ( TCell );

          cells_max = (PCell)( (char*)ras.buffer + cell_end );
          ras.cells = (PCell)( (char*)ras.buffer + cell_start );
          if ( ras.cells >= cells_max )
d1942 2
a1943 3
          ras.max_cells = cells_max - ras.cells;
          if ( ras.max_cells < 2 )
            goto ReduceBands;
d1945 3
a1947 2
          for ( yindex = 0; yindex < ras.ycount; yindex++ )
            ras.ycells[yindex] = NULL;
d1960 1
a1960 1
          gray_sweep( RAS_VAR_ &ras.target );
a1976 1
#ifdef FT_DEBUG_LEVEL_TRACE
a1977 1
#endif
a1980 3
        if ( bottom-top >= ras.band_size )
          ras.band_shoot++;

a1988 3
    if ( ras.band_shoot > 8 && ras.band_size > 16 )
      ras.band_size = ras.band_size / 2;

d1994 1
a1994 1
  gray_raster_render( gray_PRaster             raster,
d1999 1
a2002 5
    TCell  buffer[FT_MAX( FT_RENDER_POOL_SIZE, 2048 ) / sizeof ( TCell )];
    long   buffer_size = sizeof ( buffer );
    int    band_size   = (int)( buffer_size /
                                (long)( sizeof ( TCell ) * 8 ) );

d2039 13
d2056 4
a2059 4
      ras.clip_box.xMin = 0;
      ras.clip_box.yMin = 0;
      ras.clip_box.xMax = (FT_Pos)target_map->width;
      ras.clip_box.yMax = (FT_Pos)target_map->rows;
d2062 1
a2062 1
      ras.clip_box = params->clip_box;
d2065 4
a2068 4
      ras.clip_box.xMin = -32768L;
      ras.clip_box.yMin = -32768L;
      ras.clip_box.xMax =  32767L;
      ras.clip_box.yMax =  32767L;
d2071 11
a2081 1
    gray_init_cells( RAS_VAR_ buffer, buffer_size );
a2083 5
    ras.num_cells      = 0;
    ras.invalid        = 1;
    ras.band_size      = band_size;
    ras.num_gray_spans = 0;
    ras.span_y         = 0;
d2163 3
a2165 3
  gray_raster_reset( FT_Raster  raster,
                     char*      pool_base,
                     long       pool_size )
@


1.23
log
@
Bugfixing update to freetype-2.6.2

Tested on amd64, i386, macppc, sparc64, loongson and compile-tested
on arm by matthieu@@
Also tested in a ports bulk build by naddy@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2000-2015 by                                                 */
d21 1
a21 1
  /* defining the _STANDALONE_ macro when compiling it.  You also need to  */
d30 1
a30 1
  /* - compile `ftgrays' with the _STANDALONE_ macro defined, as in        */
d32 1
a32 1
  /*     cc -c -D_STANDALONE_ ftgrays.c                                    */
d94 1
a94 1
#ifdef _STANDALONE_
d259 1
a259 1
#else /* !_STANDALONE_ */
d277 1
a277 1
#endif /* !_STANDALONE_ */
d1604 1
a1604 1
#ifdef _STANDALONE_
d1886 1
a1886 1
#endif /* _STANDALONE_ */
d2165 1
a2165 1
#ifdef _STANDALONE_
d2190 1
a2190 1
#else /* !_STANDALONE_ */
d2220 1
a2220 1
#endif /* !_STANDALONE_ */
@


1.22
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@d138 4
a141 2
#define FT_UINT_MAX  UINT_MAX
#define FT_INT_MAX   INT_MAX
d371 9
d692 1
d925 137
@


1.21
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d27 2
a28 2
  /* - copy `include/ftimage.h' and `src/smooth/ftgrays.h' to the same     */
  /*   directory                                                           */
a319 1
#define PIXEL_MASK      ( -1L << PIXEL_BITS )
a441 1
    TCoord  cx, cy;
a443 2
    TPos    last_ey;

a675 1
    ras.last_ey = SUBPIXELS( ey );
d756 1
a756 1
      while ( ex1 != ex2 )
d771 1
a771 1
      }
d794 1
a794 1
    ey1 = TRUNC( ras.last_ey );
d796 1
a796 1
    fy1 = (TCoord)( ras.y - ras.last_ey );
d803 3
a805 14
    {
      TCoord  min, max;


      min = ey1;
      max = ey2;
      if ( ey1 > ey2 )
      {
        min = ey2;
        max = ey1;
      }
      if ( min >= ras.max_ey || max < ras.min_ey )
        goto End;
    }
d883 1
a883 1
      while ( ey1 != ey2 )
d901 1
a901 1
      }
a910 1
    ras.last_ey = SUBPIXELS( ey2 );
d1833 1
a1833 1
      while ( band >= bands )
d1909 1
a1909 1
      }
@


1.20
log
@
Bugfixing update to freetype-2.5.5

ok matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 2000-2003, 2005-2014 by                                      */
d97 5
d109 15
a486 3
    void*         buffer;
    long          buffer_size;
    int           band_size;
a487 1
    gray_PWorker  worker;
d499 1
a499 1
                   long            byte_size )
d657 2
a658 2
    ras.invalid = ( (unsigned)ey >= (unsigned)ras.count_ey ||
                              ex >= ras.count_ex           );
d1231 1
a1231 1
      p += (unsigned)( ( map->rows - 1 ) * map->pitch );
d1763 11
a1773 8
    FT_DEFINE_OUTLINE_FUNCS(func_interface,
      (FT_Outline_MoveTo_Func) gray_move_to,
      (FT_Outline_LineTo_Func) gray_line_to,
      (FT_Outline_ConicTo_Func)gray_conic_to,
      (FT_Outline_CubicTo_Func)gray_cubic_to,
      0,
      0
    )
d1864 2
a1865 2
          cell_start = sizeof ( PCell ) * ras.ycount;
          cell_mod   = cell_start % sizeof ( TCell );
d1867 1
a1867 1
            cell_start += sizeof ( TCell ) - cell_mod;
d1870 1
a1870 1
          cell_end -= cell_end % sizeof ( TCell );
d1940 4
a1943 3
    const FT_Outline*  outline    = (const FT_Outline*)params->source;
    const FT_Bitmap*   target_map = params->target;
    gray_PWorker       worker;
d1945 4
d1950 2
a1951 1
    if ( !raster || !raster->buffer || !raster->buffer_size )
a1967 2
    worker = raster->worker;

d1992 2
a1993 2
      ras.clip_box.xMax = target_map->width;
      ras.clip_box.yMax = target_map->rows;
d2005 1
a2005 1
    gray_init_cells( RAS_VAR_ raster->buffer, raster->buffer_size );
d2010 1
a2010 1
    ras.band_size      = raster->band_size;
d2012 1
d2096 3
a2098 28
    gray_PRaster  rast = (gray_PRaster)raster;


    if ( raster )
    {
      if ( pool_base && pool_size >= (long)sizeof ( gray_TWorker ) + 2048 )
      {
        gray_PWorker  worker = (gray_PWorker)pool_base;


        rast->worker      = worker;
        rast->buffer      = pool_base +
                              ( ( sizeof ( gray_TWorker ) +
                                  sizeof ( TCell ) - 1 )  &
                                ~( sizeof ( TCell ) - 1 ) );
        rast->buffer_size = (long)( ( pool_base + pool_size ) -
                                    (char*)rast->buffer ) &
                                      ~( sizeof ( TCell ) - 1 );
        rast->band_size   = (int)( rast->buffer_size /
                                     ( sizeof ( TCell ) * 8 ) );
      }
      else
      {
        rast->buffer      = NULL;
        rast->buffer_size = 0;
        rast->worker      = NULL;
      }
    }
d2116 3
a2118 1
  FT_DEFINE_RASTER_FUNCS(ft_grays_raster,
d2125 1
a2125 2
    (FT_Raster_Done_Func)    gray_raster_done
  )
@


1.19
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d408 2
a443 2

    ft_jmp_buf  jump_buffer;
@


1.18
log
@
Security/bugfixing update to freetype-2.5.3, featuring a fix for a
vulnerability in the CFF driver (CVE-2014-2240) and assorted minor
fixes.

ok matthieu@@
@
text
@d101 3
d1094 2
a1095 2
        dx = arc[3].x - arc[0].x;
        dy = arc[3].y - arc[0].y;
d1097 1
a1097 28
        /* L is an (under)estimate of the Euclidean distance P0-P3.       */
        /*                                                                */
        /* If dx >= dy, then r = sqrt(dx^2 + dy^2) can be overestimated   */
        /* with least maximum error by                                    */
        /*                                                                */
        /*   r_upperbound = dx + (sqrt(2) - 1) * dy  ,                    */
        /*                                                                */
        /* where sqrt(2) - 1 can be (over)estimated by 107/256, giving an */
        /* error of no more than 8.4%.                                    */
        /*                                                                */
        /* Similarly, some elementary calculus shows that r can be        */
        /* underestimated with least maximum error by                     */
        /*                                                                */
        /*   r_lowerbound = sqrt(2 + sqrt(2)) / 2 * dx                    */
        /*                  + sqrt(2 - sqrt(2)) / 2 * dy  .               */
        /*                                                                */
        /* 236/256 and 97/256 are (under)estimates of the two algebraic   */
        /* numbers, giving an error of no more than 8.1%.                 */

        dx_ = FT_ABS( dx );
        dy_ = FT_ABS( dy );

        /* This is the same as                     */
        /*                                         */
        /*   L = ( 236 * FT_MAX( dx_, dy_ )        */
        /*       + 97 * FT_MIN( dx_, dy_ ) ) >> 8; */
        L = ( dx_ > dy_ ? 236 * dx_ +  97 * dy_
                        :  97 * dx_ + 236 * dy_ ) >> 8;
d1518 4
a1521 1
    if ( !outline || !func_interface )
d2103 14
d2122 1
a2122 1
    (FT_Raster_Set_Mode_Func)0,
@


1.17
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d7 1
a7 1
/*  Copyright 2000-2003, 2005-2013 by                                      */
a1366 1
        count = 0;
@


1.16
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@d27 2
a28 2
  /* - copy `include/freetype/ftimage.h' and `src/smooth/ftgrays.h' to the */
  /*   same directory                                                      */
d313 34
d585 1
a585 1
    if ( !ras.invalid && ( ras.area | ras.cover ) )
d634 2
a637 2
    ras.ex      = ex;
    ras.ey      = ey;
d723 1
a723 7
    delta = (TCoord)( p / dx );
    mod   = (TCoord)( p % dx );
    if ( mod < 0 )
    {
      delta--;
      mod += (TCoord)dx;
    }
d737 2
a738 8
      p    = ONE_PIXEL * ( y2 - y1 + delta );
      lift = (TCoord)( p / dx );
      rem  = (TCoord)( p % dx );
      if ( rem < 0 )
      {
        lift--;
        rem += (TCoord)dx;
      }
a787 3
    /* XXX: we should do something about the trivial case where dx == 0, */
    /*      as it happens very often!                                    */

d866 1
a866 7
    delta = (int)( p / dy );
    mod   = (int)( p % dy );
    if ( mod < 0 )
    {
      delta--;
      mod += (TCoord)dy;
    }
d877 1
a877 7
      lift  = (int)( p / dy );
      rem   = (int)( p % dy );
      if ( rem < 0 )
      {
        lift--;
        rem += (int)dy;
      }
d1181 2
a1182 1
    gray_record_cell( RAS_VAR );
d1792 2
a1793 1
      gray_record_cell( RAS_VAR );
@


1.15
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@d361 8
d416 4
d645 1
a645 1
    TCoord  ex1, ex2, fx1, fx2, delta, mod, lift, rem;
d706 3
d1275 1
a1275 3
    FT_Span*  span;
    int       count;
    int       coverage;
d1317 4
@


1.14
log
@Update to freetype 2.4.11. Tested by krw@@, jasper@@ and on a bulk ports
build by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 2000-2003, 2005-2012 by                                      */
d97 5
d162 15
d188 6
d199 2
d233 1
d247 2
a248 2
#define ErrRaster_Invalid_Mode      Smooth_Err_Cannot_Render_Glyph
#define ErrRaster_Invalid_Outline   Smooth_Err_Invalid_Outline
d250 1
a250 1
#define ErrRaster_Invalid_Argument  Smooth_Err_Invalid_Argument
d254 1
d1125 1
a1125 1
           from the chord that the angles P0-P1-P3 or P0-P2-P3 become 
d1519 1
a1519 1
      return ErrRaster_Invalid_Argument;
d1732 1
a1732 1
    return ErrRaster_Invalid_Outline;
d1770 1
a1770 1
      error = ErrRaster_Memory_Overflow;
d1923 1
a1923 1
      return ErrRaster_Invalid_Argument;
d1926 1
a1926 1
      return ErrRaster_Invalid_Outline;
d1933 1
a1933 1
      return ErrRaster_Invalid_Outline;
d1937 1
a1937 1
      return ErrRaster_Invalid_Outline;
d1945 1
a1945 1
        return ErrRaster_Invalid_Argument;
d1952 1
a1952 1
        return ErrRaster_Invalid_Argument;
d1957 1
a1957 1
      return ErrRaster_Invalid_Mode;
@


1.13
log
@Update to freetype-2.4.10.

With help and ok matthieu@@
@
text
@d1094 5
a1098 5
        /* If P1 or P2 is outside P0-P3, split the curve. */
        if ( dy * dy1 + dx * dx1 < 0                                     ||
             dy * dy2 + dx * dx2 < 0                                     ||
             dy * (arc[3].y - arc[1].y) + dx * (arc[3].x - arc[1].x) < 0 ||
             dy * (arc[3].y - arc[2].y) + dx * (arc[3].x - arc[2].x) < 0 )
d1403 16
d1420 3
@


1.12
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@d315 1
a315 1
  /* maximal number of gray spans in a call to the span callback */
@


1.11
log
@Update to freetype 2.4.7.

This moslty is a bug-fix release for CVE-2011-3256.
@
text
@d7 1
a7 1
/*  Copyright 2000-2003, 2005-2011 by                                      */
d235 5
d242 2
a243 2
#define RAS_ARG   PWorker  worker
#define RAS_ARG_  PWorker  worker,
d261 5
d323 4
a326 4
    TPos   x;     /* same with TWorker.ex */
    TCoord cover; /* same with TWorker.cover */
    TArea  area;
    PCell  next;
d331 1
a331 1
  typedef struct  TWorker_
d342 1
a342 1
    PCell   cells;
d376 1
a376 1
  } TWorker, *PWorker;
d382 1
a382 1
  static TWorker  ras;
d386 1
a386 1
  typedef struct TRaster_
d388 5
a392 5
    void*    buffer;
    long     buffer_size;
    int      band_size;
    void*    memory;
    PWorker  worker;
d394 1
a394 1
  } TRaster, *PRaster;
d891 2
a930 1
    levels    = ras.lev_stack;
d1123 1
a1123 1
                PWorker           worker )
d1145 1
a1145 1
                PWorker           worker )
d1155 1
a1155 1
                 PWorker           worker )
d1166 1
a1166 1
                 PWorker           worker )
d1177 1
a1177 1
                    PWorker         worker )
d1689 1
a1689 1
  typedef struct  TBand_
d1693 1
a1693 1
  } TBand;
d1730 5
a1734 5
    TBand            bands[40];
    TBand* volatile  band;
    int volatile     n, num_bands;
    TPos volatile    min, max, max_y;
    FT_BBox*         clip;
d1798 1
a1798 1
          cell_end -= cell_end % sizeof( TCell );
d1865 1
a1865 1
  gray_raster_render( PRaster                  raster,
d1870 1
a1870 1
    PWorker            worker;
d1962 1
a1962 1
    static TRaster  the_raster;
d1987 2
a1988 2
    FT_Error  error;
    PRaster   raster = NULL;
d1992 1
a1992 1
    if ( !FT_ALLOC( raster, sizeof ( TRaster ) ) )
d1995 1
a1995 1
      *araster = (FT_Raster)raster;
d2005 1
a2005 1
    FT_Memory  memory = (FT_Memory)((PRaster)raster)->memory;
d2019 1
a2019 1
    PRaster  rast = (PRaster)raster;
d2024 1
a2024 1
      if ( pool_base && pool_size >= (long)sizeof ( TWorker ) + 2048 )
d2026 1
a2026 1
        PWorker  worker = (PWorker)pool_base;
d2031 2
a2032 1
                              ( ( sizeof ( TWorker ) + sizeof ( TCell ) - 1 ) &
@


1.10
log
@Update to freetype 2.4.5. Tested by many.
@
text
@d875 1
d888 1
d895 17
d913 1
a913 1
    while ( dx > ONE_PIXEL / 6 )
d917 1
a917 1
    }
a920 1
    top       = 0;
d925 1
a925 1
      if ( level > 1 )
a926 17
        /* check that the arc crosses the current band */
        TPos  min, max, y;


        min = max = arc[0].y;

        y = arc[1].y;
        if ( y < min ) min = y;
        if ( y > max ) max = y;

        y = arc[2].y;
        if ( y < min ) min = y;
        if ( y > max ) max = y;

        if ( TRUNC( min ) >= ras.max_ey || TRUNC( max ) < ras.min_ey )
          goto Draw;

d977 1
d990 2
a991 5
    for (;;)
    {
      /* Check that the arc crosses the current band. */
      TPos  min, max, y;

d993 17
a1009 1
      min = max = arc[0].y;
d1011 2
a1012 20
      y = arc[1].y;
      if ( y < min )
        min = y;
      if ( y > max )
        max = y;

      y = arc[2].y;
      if ( y < min )
        min = y;
      if ( y > max )
        max = y;

      y = arc[3].y;
      if ( y < min )
        min = y;
      if ( y > max )
        max = y;

      if ( TRUNC( min ) >= ras.max_ey || TRUNC( max ) < ras.min_ey )
        goto Draw;
d1014 2
@


1.9
log
@Update to freetype 2.4.4. Tested by shadchin@@, ajacoutot@@, krw@@.
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010 by */
a892 6
    if ( dx <= ONE_PIXEL / 4 )
    {
      gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );
      return;
    }

d894 1
a894 1
    while ( dx > ONE_PIXEL / 4 )
d904 1
a904 1
    while ( top >= 0 )
a936 1
    }
d938 1
a938 1
    return;
@


1.8
log
@Update to freetype 2.4.3. Tested at least by krw@@, ajacoutot@@ and jasper@@
@
text
@a93 5
  /* The maximum distance of a curve from the chord, in 64ths of a pixel; */
  /* used when flattening curves.                                         */
#define FT_MAX_CURVE_DEVIATION  16


d880 10
a889 6
    dx = DOWNSCALE( ras.x ) + to->x - ( control->x << 1 );
    if ( dx < 0 )
      dx = -dx;
    dy = DOWNSCALE( ras.y ) + to->y - ( control->y << 1 );
    if ( dy < 0 )
      dy = -dy;
d893 1
a893 1
    if ( dx <= FT_MAX_CURVE_DEVIATION )
d895 1
a895 1
      gray_render_line( RAS_VAR_ UPSCALE( to->x ), UPSCALE( to->y ) );
d899 2
a900 3
    level = 1;
    dx /= FT_MAX_CURVE_DEVIATION;
    while ( dx > 1 )
a905 1
    arc       = ras.bez_stack;
d907 1
a908 8
    levels[0] = level;

    arc[0].x = UPSCALE( to->x );
    arc[0].y = UPSCALE( to->y );
    arc[1].x = UPSCALE( control->x );
    arc[1].y = UPSCALE( control->y );
    arc[2].x = ras.x;
    arc[2].y = ras.y;
d1060 7
a1066 1
        L = ( 236 * FT_MAX( dx_, dy_ ) + 97 * FT_MIN( dx_, dy_ ) ) >> 8;
d1073 1
a1073 1
        s_limit = L * (TPos)( FT_MAX_CURVE_DEVIATION / 0.75 );
@


1.7
log
@Update to freetype 2.4.2. This has been in snapshots for a while
and tested explicitely by ajacoutot@@ jasper@@, jcs@@, krw@@ and others
on various architectures.
@
text
@d94 5
d195 1
a195 1
                                          
a361 2
    int  conic_level;
    int  cubic_level;
d894 6
d901 2
a902 2
    dx = dx / ras.conic_level;
    while ( dx > 0 )
a907 19
    /* a shortcut to speed things up */
    if ( level <= 1 )
    {
      /* we compute the mid-point directly in order to avoid */
      /* calling gray_split_conic()                          */
      TPos  to_x, to_y, mid_x, mid_y;


      to_x  = UPSCALE( to->x );
      to_y  = UPSCALE( to->y );
      mid_x = ( ras.x + to_x + 2 * UPSCALE( control->x ) ) / 4;
      mid_y = ( ras.y + to_y + 2 * UPSCALE( control->y ) ) / 4;

      gray_render_line( RAS_VAR_ mid_x, mid_y );
      gray_render_line( RAS_VAR_ to_x, to_y );

      return;
    }

d950 3
a952 15
      {
        TPos  to_x, to_y, mid_x, mid_y;


        to_x  = arc[0].x;
        to_y  = arc[0].y;
        mid_x = ( ras.x + to_x + 2 * arc[1].x ) / 4;
        mid_y = ( ras.y + to_y + 2 * arc[1].y ) / 4;

        gray_render_line( RAS_VAR_ mid_x, mid_y );
        gray_render_line( RAS_VAR_ to_x, to_y );

        top--;
        arc -= 2;
      }
a991 2
    int         top, level;
    int*        levels;
a992 40
    int         mid_x = ( DOWNSCALE( ras.x ) + to->x +
                          3 * (control1->x + control2->x ) ) / 8;
    int         mid_y = ( DOWNSCALE( ras.y ) + to->y +
                          3 * (control1->y + control2->y ) ) / 8;
    TPos        dx = DOWNSCALE( ras.x ) + to->x - ( mid_x << 1 );
    TPos        dy = DOWNSCALE( ras.y ) + to->y - ( mid_y << 1 );


    if ( dx < 0 )
      dx = -dx;
    if ( dy < 0 )
      dy = -dy;
    if ( dx < dy )
      dx = dy;

    level = 1;
    dx /= ras.cubic_level;
    while ( dx > 0 )
    {
      dx >>= 2;
      level++;
    }

    if ( level <= 1 )
    {
      TPos  to_x, to_y;


      to_x  = UPSCALE( to->x );
      to_y  = UPSCALE( to->y );

      /* Recalculation of midpoint is needed only if */
      /* UPSCALE and DOWNSCALE have any effect.      */

#if ( PIXEL_BITS != 6 )
      mid_x = ( ras.x + to_x +
                3 * UPSCALE( control1->x + control2->x ) ) / 8;
      mid_y = ( ras.y + to_y +
                3 * UPSCALE( control1->y + control2->y ) ) / 8;
#endif
a993 5
      gray_render_line( RAS_VAR_ mid_x, mid_y );
      gray_render_line( RAS_VAR_ to_x, to_y );

      return;
    }
d1005 33
a1037 3
    levels    = ras.lev_stack;
    top       = 0;
    levels[0] = level;
a1038 4
    while ( top >= 0 )
    {
      level = levels[top];
      if ( level > 1 )
d1040 61
a1100 2
        /* check that the arc crosses the current band */
        TPos  min, max, y;
d1102 3
d1106 4
a1109 18
        min = max = arc[0].y;
        y = arc[1].y;
        if ( y < min ) min = y;
        if ( y > max ) max = y;
        y = arc[2].y;
        if ( y < min ) min = y;
        if ( y > max ) max = y;
        y = arc[3].y;
        if ( y < min ) min = y;
        if ( y > max ) max = y;
        if ( TRUNC( min ) >= ras.max_ey || TRUNC( max ) < 0 )
          goto Draw;
        gray_split_cubic( arc );
        arc += 3;
        top ++;
        levels[top] = levels[top - 1] = level - 1;
        continue;
      }
d1112 1
a1112 2
      {
        TPos  to_x, to_y;
d1114 2
d1117 1
a1117 10
        to_x  = arc[0].x;
        to_y  = arc[0].y;
        mid_x = ( ras.x + to_x + 3 * ( arc[1].x + arc[2].x ) ) / 8;
        mid_y = ( ras.y + to_y + 3 * ( arc[1].y + arc[2].y ) ) / 8;

        gray_render_line( RAS_VAR_ mid_x, mid_y );
        gray_render_line( RAS_VAR_ to_x, to_y );
        top --;
        arc -= 3;
      }
a1118 2

    return;
a1121 1

a1755 19

    /* simple heuristic used to speed up the bezier decomposition -- see */
    /* the code in gray_render_conic() and gray_render_cubic() for more  */
    /* details                                                           */
    ras.conic_level = 32;
    ras.cubic_level = 16;

    {
      int  level = 0;


      if ( ras.count_ex > 24 || ras.count_ey > 24 )
        level++;
      if ( ras.count_ex > 120 || ras.count_ey > 120 )
        level++;

      ras.conic_level <<= level;
      ras.cubic_level <<= level;
    }
@


1.6
log
@patches from Freetype.org for the security issues found by Robert Swiecki:

CVE-2010-2497 freetype integer underflow
CVE-2010-2498 freetype invalid free
CVE-2010-2499 freetype buffer overflow
CVE-2010-2500 freetype integer overflow
CVE-2010-2519 freetype heap buffer overflow
CVE-2010-2520 freetype buffer overflow on heap
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009 by       */
d106 1
d111 1
d119 2
a1013 2
    TPos        dx, dy;
    TPos        mid_x, mid_y;
d1017 6
a1024 7
    /* Calculate midpoint and compare it with start and end. */
    mid_x = ( DOWNSCALE( ras.x ) + to->x +
              3 * ( control1->x + control2->x ) ) / 8;
    mid_y = ( DOWNSCALE( ras.y ) + to->y +
              3 * ( control1->y + control2->y ) ) / 8;

    dx = DOWNSCALE( ras.x ) + to->x - ( mid_x << 1 );
a1026 1
    dy = DOWNSCALE( ras.y ) + to->y - ( mid_y << 1 );
a1031 1
    /* Check whether an approximation with straight lines is sufficient. */
d1033 1
a1033 1
    dx    = dx / ras.conic_level;
d1036 1
a1036 1
      dx >>= 3;
d1042 1
a1042 1
      TPos   to_x, to_y;
d1047 5
d1056 1
d1060 1
d2007 1
a2007 1
#else /* _STANDALONE_ */
d2014 1
a2014 1
    PRaster   raster;
d2037 1
a2037 1
#endif /* _STANDALONE_ */
@


1.5
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d1010 2
a1011 1
    TPos        dx, dy, da, db;
d1017 5
a1021 9
    dx = DOWNSCALE( ras.x ) + to->x - ( control1->x << 1 );
    if ( dx < 0 )
      dx = -dx;
    dy = DOWNSCALE( ras.y ) + to->y - ( control1->y << 1 );
    if ( dy < 0 )
      dy = -dy;
    if ( dx < dy )
      dx = dy;
    da = dx;
d1023 1
a1023 1
    dx = DOWNSCALE( ras.x ) + to->x - 3 * ( control1->x + control2->x );
d1026 1
a1026 1
    dy = DOWNSCALE( ras.y ) + to->y - 3 * ( control1->x + control2->y );
a1030 1
    db = dx;
d1032 1
d1034 2
a1035 3
    da    = da / ras.cubic_level;
    db    = db / ras.conic_level;
    while ( da > 0 || db > 0 )
d1037 1
a1037 2
      da >>= 2;
      db >>= 3;
d1043 1
a1043 1
      TPos   to_x, to_y, mid_x, mid_y;
d1102 1
a1102 1
        TPos  to_x, to_y, mid_x, mid_y;
d1187 1
a1187 1
      p += ( map->rows - 1 ) * map->pitch;
@


1.4
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2005, 2006, 2007, 2008 by             */
d173 28
d212 2
a220 1

a232 1

a238 3
#define ras       (*worker)


a240 1

a245 3
  static TWorker  ras;


d278 1
a278 1
  typedef int   TCoord;   /* integer scanline/pixel coordinate */
d309 2
a310 2
    int    x;
    int    cover;
d325 1
a325 1
    int     cover;
d329 2
a330 2
    int     max_cells;
    int     num_cells;
d362 1
a362 1
    int        ycount;
d367 7
d459 1
a459 1
    int     x = ras.ex;
d591 1
a591 1
    TCoord  ex1, ex2, fx1, fx2, delta;
d593 1
a593 1
    int     incr, lift, mod, rem;
d615 1
a615 1
      ras.area  += (TArea)( fx1 + fx2 ) * delta;
d643 1
a643 1
    ras.area  += (TArea)( fx1 + first ) * delta;
d673 1
a673 1
        ras.area  += (TArea)ONE_PIXEL * delta;
d682 1
a682 1
    ras.area  += (TArea)( fx2 + ONE_PIXEL - first ) * delta;
d695 1
a695 1
    TCoord  ey1, ey2, fy1, fy2;
d698 1
a698 1
    int     delta, rem, mod, lift, incr;
d742 1
a742 1
      TPos    area;
d757 1
a757 1
      gray_set_cell( &ras, ex, ey1 );
d767 1
a767 1
        gray_set_cell( &ras, ex, ey1 );
d1135 1
a1135 1
    gray_record_cell( worker );
d1141 1
a1141 1
    gray_start_cell( worker, TRUNC( x ), TRUNC( y ) );
d1153 1
a1153 1
    gray_render_line( worker, UPSCALE( to->x ), UPSCALE( to->y ) );
d1163 1
a1163 1
    gray_render_conic( worker, control, to );
d1174 1
a1174 1
    gray_render_cubic( worker, control1, control2, to );
d1234 1
a1234 1
                       int     acount )
d1274 4
d1316 1
a1316 1
        ras.span_y         = y;
d1352 1
a1352 1
        printf( " (%3d, c:%4d, a:%6d)", cell->x, cell->cover, cell->area );
d1384 1
a1384 1
        TArea  area;
d1701 1
a1701 7

  static int
  gray_convert_glyph_inner( RAS_ARG )
  {
    static
    const FT_Outline_Funcs  func_interface =
    {
d1708 5
a1712 1
    };
d1716 4
d1866 1
a1866 1
          FT_TRACE7(( "gray_convert_glyph: Rotten glyph!\n" ));
d1954 1
a1954 1
    gray_init_cells( worker, raster->buffer, raster->buffer_size );
d1974 1
a1974 1
    return gray_convert_glyph( worker );
d2074 1
a2074 2
  const FT_Raster_Funcs  ft_grays_raster =
  {
d2082 1
a2082 1
  };
@


1.3
log
@Update to Freetype 2.3.7. This is a bug fix release. No API change.
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2005, 2006, 2007 by                   */
d94 2
d97 2
a99 1
#ifdef _STANDALONE_
d101 6
a106 1
#include <string.h>             /* for ft_memcpy() */
d129 1
d136 24
a159 2
  /* Disable the tracing mechanism for simplicity -- developers can      */
  /* activate it easily by redefining these two macros.                  */
d161 1
a161 1
#define FT_ERROR( x )  do ; while ( 0 )     /* nothing */
d164 8
a171 3
#ifndef FT_TRACE
#define FT_TRACE( x )  do ; while ( 0 )     /* nothing */
#endif
d175 1
d187 1
a187 1
#define ErrRaster_Invalid_Argument  Smooth_Err_Bad_Argument
a199 4
  /* define this to dump debugging information */
#define xxxDEBUG_GRAYS


d434 2
a435 2
    if ( x > ras.max_ex )
      x = ras.max_ex;
d1243 1
a1243 1
    if ( x >= 32768 )
a1264 1
        /* ras.render_span( span->y, ras.gray_spans, count ); */
d1266 1
a1266 1
#ifdef DEBUG_GRAYS
d1268 1
a1268 1
        if ( ras.span_y >= 0 )
d1273 1
a1273 1
          fprintf( stderr, "y=%3d ", ras.span_y );
d1276 3
a1278 3
            fprintf( stderr, "[%d..%d]:%02x ",
                     span->x, span->x + span->len - 1, span->coverage );
          fprintf( stderr, "\n" );
d1281 1
a1281 1
#endif /* DEBUG_GRAYS */
d1302 1
a1302 1
#ifdef DEBUG_GRAYS
d1304 3
a1306 1
  /* to be called while in the debugger */
d1325 1
a1325 1
#endif /* DEBUG_GRAYS */
d1341 2
d1376 2
d1385 1
a1385 1
  /*  The following function should only compile in stand_alone mode,      */
d1396 2
a1397 2
  /*    Walks over an outline's structure to decompose it into individual  */
  /*    segments and Bezier arcs.  This function is also able to emit      */
d1404 1
a1404 1
  /*    func_interface :: A table of `emitters', i.e,. function pointers   */
d1408 1
d1417 4
a1420 4
  static
  int  FT_Outline_Decompose( const FT_Outline*        outline,
                             const FT_Outline_Funcs*  func_interface,
                             void*                    user )
a1422 1
#if 0
a1423 3
#else
#define SCALED( x )  (x)
#endif
d1433 2
a1436 1
    int   error;
d1439 3
a1441 4
#if 0
    int   shift = func_interface->shift;
    TPos  delta = func_interface->delta;
#endif
d1443 2
d1446 2
d1455 2
d1458 2
d1462 1
a1462 3
      v_start = outline->points[first];
      v_last  = outline->points[last];

d1466 3
a1468 2
      v_last.x  = SCALED( v_last.x );
      v_last.y  = SCALED( v_last.y );
d1473 1
a1473 1
      tags  = outline->tags  + first;
d1504 2
d1526 2
d1535 5
d1541 2
a1542 2
            v_control.x = SCALED( point->x );
            v_control.y = SCALED( point->y );
a1543 5
          Do_Conic:
            if ( point < limit )
            {
              FT_Vector  vec;
              FT_Vector  v_middle;
d1545 3
d1549 2
a1550 3
              point++;
              tags++;
              tag = FT_CURVE_TAG( tags[0] );
d1552 11
a1562 2
              vec.x = SCALED( point->x );
              vec.y = SCALED( point->y );
d1564 2
a1565 8
              if ( tag == FT_CURVE_TAG_ON )
              {
                error = func_interface->conic_to( &v_control, &vec,
                                                  user );
                if ( error )
                  goto Exit;
                continue;
              }
d1567 2
a1568 2
              if ( tag != FT_CURVE_TAG_CONIC )
                goto Invalid_Outline;
d1570 7
a1576 2
              v_middle.x = ( v_control.x + vec.x ) / 2;
              v_middle.y = ( v_control.y + vec.y ) / 2;
d1578 3
a1580 4
              error = func_interface->conic_to( &v_control, &v_middle,
                                                user );
              if ( error )
                goto Exit;
d1582 6
a1587 8
              v_control = vec;
              goto Do_Conic;
            }

            error = func_interface->conic_to( &v_control, &v_start,
                                              user );
            goto Close;
          }
d1615 5
d1626 5
d1638 2
d1649 1
d1653 1
d1735 1
a1735 1
      int level = 0;
d1831 2
a1832 2
#ifdef DEBUG_GRAYS
          fprintf( stderr, "Rotten glyph!\n" );
d1884 1
a1884 1
    if ( ( params->flags & FT_RASTER_FLAG_DIRECT ) == 0 )
d1902 1
a1902 1
    if ( ( params->flags & FT_RASTER_FLAG_DIRECT ) == 0 )
a1910 1
    {
a1911 1
    }
a1927 6
    if ( target_map )
      ras.target = *target_map;

    ras.render_span      = (FT_Raster_Span_Func)gray_render_span;
    ras.render_span_data = &ras;

d1933 6
d1944 2
a1945 2
  /**** RASTER OBJECT CREATION: In standalone mode, we simply use *****/
  /****                         a static object.                  *****/
d2053 5
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d1619 1
a1625 1
    {
a1626 1
    }
d1680 1
a1680 1
    /* setup vertical bands */
d1682 4
a1685 2
    if ( num_bands == 0 )  num_bands = 1;
    if ( num_bands >= 39 ) num_bands = 39;
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2005, 2006 by                         */
a83 5

/* experimental support for gamma correction within the rasterizer */
#define xxxGRAYS_USE_GAMMA


a93 1
#define ErrRaster_MemoryOverflow   -4
d110 4
a113 2
#define ErrRaster_Invalid_Mode     -2
#define ErrRaster_Invalid_Outline  -1
d137 1
a137 3

#else /* _STANDALONE_ */

d147 4
a150 3
#define ErrRaster_Invalid_Mode     Smooth_Err_Cannot_Render_Glyph
#define ErrRaster_Invalid_Outline  Smooth_Err_Invalid_Outline

d152 1
a152 1
#endif /* _STANDALONE_ */
d166 1
d172 2
a173 2
#define RAS_ARG   PRaster  raster
#define RAS_ARG_  PRaster  raster,
d175 2
a176 2
#define RAS_VAR   raster
#define RAS_VAR_  raster,
d178 1
a178 1
#define ras       (*raster)
d189 1
a189 1
  static TRaster  ras;
d200 1
a200 1
#define TRUNC( x )      ( (TCoord)((x) >> PIXEL_BITS) )
a213 6
  /* Define this if you want to use a more compact storage scheme.  This   */
  /* increases the number of cells available in the render pool but slows  */
  /* down the rendering a bit.  It is useful if you have a really tiny     */
  /* render pool.                                                          */
#undef GRAYS_COMPACT

d233 1
a233 1
  typedef int   TArea;
d241 1
a241 1
  typedef int  TArea;
d251 1
a251 1
#ifdef GRAYS_COMPACT
d255 4
a258 4
    short  x     : 14;
    short  y     : 14;
    int    cover : PIXEL_BITS + 2;
    int    area  : PIXEL_BITS * 2 + 2;
d260 1
a260 1
  } TCell, *PCell;
a261 1
#else /* GRAYS_COMPACT */
d263 1
a263 1
  typedef struct  TCell_
d265 1
a265 16
    TCoord  x;
    TCoord  y;
    int     cover;
    TArea   area;

  } TCell, *PCell;

#endif /* GRAYS_COMPACT */


  typedef struct  TRaster_
  {
    PCell   cells;
    int     max_cells;
    int     num_cells;

d268 1
d274 4
a277 1
    TCoord  ex, ey;
a301 1
    void*       memory;
d304 16
a319 3
#ifdef GRAYS_USE_GAMMA
    unsigned char  gamma[257];
#endif
d324 1
d333 10
a342 6
    ras.cells     = (PCell)buffer;
    ras.max_cells = (int)( byte_size / sizeof ( TCell ) );
    ras.num_cells = 0;
    ras.area      = 0;
    ras.cover     = 0;
    ras.invalid   = 1;
d394 39
a435 3
    PCell  cell;


d438 1
a438 2
      if ( ras.num_cells >= ras.max_cells )
        ft_longjmp( ras.jump_buffer, 1 );
d440 3
a442 5
      cell        = ras.cells + ras.num_cells++;
      cell->x     = (TCoord)(ras.ex - ras.min_ex);
      cell->y     = (TCoord)(ras.ey - ras.min_ey);
      cell->area  = ras.area;
      cell->cover = ras.cover;
a454 3
    int  invalid, record, clean;


d465 17
a481 23
    record  = 0;
    clean   = 1;

    invalid = ( ey < ras.min_ey || ey >= ras.max_ey || ex >= ras.max_ex );
    if ( !invalid )
    {
      /* All cells that are on the left of the clipping region go to the */
      /* min_ex - 1 horizontal position.                                 */
      if ( ex < ras.min_ex )
        ex = (TCoord)(ras.min_ex - 1);

      /* if our position is new, then record the previous cell */
      if ( ex != ras.ex || ey != ras.ey )
        record = 1;
      else
        clean = ras.invalid;  /* do not clean if we didn't move from */
                              /* a valid cell                        */
    }

    /* record the previous cell if needed (i.e., if we changed the cell */
    /* position, or changed the `invalid' flag)                         */
    if ( ras.invalid != invalid || record )
      gray_record_cell( RAS_VAR );
a482 2
    if ( clean )
    {
a486 1
    ras.invalid = invalid;
d489 2
d499 2
a500 2
  gray_start_cell( RAS_ARG_  TCoord  ex,
                             TCoord  ey )
d502 3
d506 1
a506 1
      ex = (TCoord)(ras.min_ex - 1);
d510 2
a511 2
    ras.ex      = ex;
    ras.ey      = ey;
d524 5
a528 5
  gray_render_scanline( RAS_ARG_  TCoord  ey,
                                  TPos    x1,
                                  TCoord  y1,
                                  TPos    x2,
                                  TCoord  y2 )
d537 2
a538 2
    ex1 = TRUNC( x1 ); /* if (ex1 >= ras.max_ex) ex1 = ras.max_ex-1; */
    ex2 = TRUNC( x2 ); /* if (ex2 >= ras.max_ex) ex2 = ras.max_ex-1; */
d641 1
a641 1
    ey2 = TRUNC( to_y ); /* if (ey2 >= ras.max_ey) ey2 = ras.max_ey-1; */
d696 1
a696 1
      gray_set_cell( raster, ex, ey1 );
d705 2
a706 1
        gray_set_cell( raster, ex, ey1 );
d712 1
d839 1
a839 1
      TPos   to_x, to_y, mid_x, mid_y;
d849 1
d911 1
d1060 1
a1064 191
  /* a macro comparing two cell pointers.  Returns true if a <= b. */
#if 1

#define PACK( a )          ( ( (long)(a)->y << 16 ) + (a)->x )
#define LESS_THAN( a, b )  ( PACK( a ) < PACK( b ) )

#else /* 1 */

#define LESS_THAN( a, b )  ( (a)->y < (b)->y || \
                             ( (a)->y == (b)->y && (a)->x < (b)->x ) )

#endif /* 1 */

#define SWAP_CELLS( a, b, temp )  do             \
                                  {              \
                                    temp = *(a); \
                                    *(a) = *(b); \
                                    *(b) = temp; \
                                  } while ( 0 )
#define DEBUG_SORT
#define QUICK_SORT

#ifdef SHELL_SORT

  /* a simple shell sort algorithm that works directly on our */
  /* cells table                                              */
  static void
  gray_shell_sort ( PCell  cells,
                    int    count )
  {
    PCell  i, j, limit = cells + count;
    TCell  temp;
    int    gap;


    /* compute initial gap */
    for ( gap = 0; ++gap < count; gap *= 3 )
      ;

    while ( gap /= 3 )
    {
      for ( i = cells + gap; i < limit; i++ )
      {
        for ( j = i - gap; ; j -= gap )
        {
          PCell  k = j + gap;


          if ( LESS_THAN( j, k ) )
            break;

          SWAP_CELLS( j, k, temp );

          if ( j < cells + gap )
            break;
        }
      }
    }
  }

#endif /* SHELL_SORT */


#ifdef QUICK_SORT

  /* This is a non-recursive quicksort that directly process our cells     */
  /* array.  It should be faster than calling the stdlib qsort(), and we   */
  /* can even tailor our insertion threshold...                            */

#define QSORT_THRESHOLD  9  /* below this size, a sub-array will be sorted */
                            /* through a normal insertion sort             */

  static void
  gray_quick_sort( PCell  cells,
                   int    count )
  {
    PCell   stack[40];  /* should be enough ;-) */
    PCell*  top;        /* top of stack */
    PCell   base, limit;
    TCell   temp;


    limit = cells + count;
    base  = cells;
    top   = stack;

    for (;;)
    {
      int    len = (int)( limit - base );
      PCell  i, j, pivot;


      if ( len > QSORT_THRESHOLD )
      {
        /* we use base + len/2 as the pivot */
        pivot = base + len / 2;
        SWAP_CELLS( base, pivot, temp );

        i = base + 1;
        j = limit - 1;

        /* now ensure that *i <= *base <= *j */
        if ( LESS_THAN( j, i ) )
          SWAP_CELLS( i, j, temp );

        if ( LESS_THAN( base, i ) )
          SWAP_CELLS( base, i, temp );

        if ( LESS_THAN( j, base ) )
          SWAP_CELLS( base, j, temp );

        for (;;)
        {
          do i++; while ( LESS_THAN( i, base ) );
          do j--; while ( LESS_THAN( base, j ) );

          if ( i > j )
            break;

          SWAP_CELLS( i, j, temp );
        }

        SWAP_CELLS( base, j, temp );

        /* now, push the largest sub-array */
        if ( j - base > limit - i )
        {
          top[0] = base;
          top[1] = j;
          base   = i;
        }
        else
        {
          top[0] = i;
          top[1] = limit;
          limit  = j;
        }
        top += 2;
      }
      else
      {
        /* the sub-array is small, perform insertion sort */
        j = base;
        i = j + 1;

        for ( ; i < limit; j = i, i++ )
        {
          for ( ; LESS_THAN( j + 1, j ); j-- )
          {
            SWAP_CELLS( j + 1, j, temp );
            if ( j == base )
              break;
          }
        }
        if ( top > stack )
        {
          top  -= 2;
          base  = top[0];
          limit = top[1];
        }
        else
          break;
      }
    }
  }

#endif /* QUICK_SORT */


#ifdef DEBUG_GRAYS
#ifdef DEBUG_SORT

  static int
  gray_check_sort( PCell  cells,
                   int    count )
  {
    PCell  p, q;


    for ( p = cells + count - 2; p >= cells; p-- )
    {
      q = p + 1;
      if ( !LESS_THAN( p, q ) )
        return 0;
    }
    return 1;
  }

#endif /* DEBUG_SORT */
#endif /* DEBUG_GRAYS */

d1068 1
a1068 1
                FT_Raster         raster )
d1074 1
a1074 1
    gray_record_cell( (PRaster)raster );
d1080 1
a1080 1
    gray_start_cell( (PRaster)raster, TRUNC( x ), TRUNC( y ) );
d1082 2
a1083 2
    ((PRaster)raster)->x = x;
    ((PRaster)raster)->y = y;
d1090 1
a1090 1
                FT_Raster         raster )
d1092 1
a1092 2
    gray_render_line( (PRaster)raster,
                      UPSCALE( to->x ), UPSCALE( to->y ) );
d1100 1
a1100 1
                 FT_Raster         raster )
d1102 1
a1102 1
    gray_render_conic( (PRaster)raster, control, to );
d1111 1
a1111 1
                 FT_Raster         raster )
d1113 1
a1113 1
    gray_render_cubic( (PRaster)raster, control1, control2, to );
d1122 1
a1122 1
                    PRaster         raster )
d1125 1
a1125 1
    FT_Bitmap*      map = &raster->target;
a1137 4
#ifdef GRAYS_USE_GAMMA
      coverage = raster->gamma[coverage];
#endif

a1138 3
#if 1
        FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );
#else /* 1 */
d1140 9
a1148 8
        q     = p + spans->x;
        limit = q + spans->len;
        for ( ; q < limit; q++ )
          q[0] = (unsigned char)coverage;
      }
#endif /* 1 */
    }
  }
d1151 13
a1163 20
#ifdef DEBUG_GRAYS

#include <stdio.h>

  static void
  gray_dump_cells( RAS_ARG )
  {
    PCell  cell, limit;
    int    y = -1;


    cell  = ras.cells;
    limit = cell + ras.num_cells;

    for ( ; cell < limit; cell++ )
    {
      if ( cell->y != y )
      {
        fprintf( stderr, "\n%2d: ", cell->y );
        y = cell->y;
a1164 2
      fprintf( stderr, "[%d %d %d]",
               cell->x, cell->area, cell->cover );
a1165 1
    fprintf(stderr, "\n" );
a1167 2
#endif /* DEBUG_GRAYS */

d1175 3
a1177 3
    FT_Span*   span;
    int        count;
    int        coverage;
d1209 4
d1215 1
a1215 1
      /* see if we can add this span to the current list */
d1221 1
a1221 1
           span->coverage == coverage )
d1264 1
d1270 24
d1297 1
a1297 3
    TCoord  x, y, cover;
    TArea   area;
    PCell   start, cur, limit;
a1304 5
    cur   = ras.cells;
    limit = cur + ras.num_cells;

    cover              = 0;
    ras.span_y         = -1;
d1307 1
a1307 1
    for (;;)
d1309 3
a1311 3
      start  = cur;
      y      = start->y;
      x      = start->x;
a1312 2
      area   = start->area;
      cover += start->cover;
d1314 1
a1314 2
      /* accumulate all start cells */
      for (;;)
d1316 1
a1316 3
        ++cur;
        if ( cur >= limit || cur->y != start->y || cur->x != start->x )
          break;
a1317 3
        area  += cur->area;
        cover += cur->cover;
      }
d1319 6
a1324 7
      /* if the start cell has a non-null area, we must draw an */
      /* individual gray pixel there                            */
      if ( area && x >= 0 )
      {
        gray_hline( RAS_VAR_ x, y, cover * ( ONE_PIXEL * 2 ) - area, 1 );
        x++;
      }
d1326 2
a1327 2
      if ( x < 0 )
        x = 0;
d1329 1
a1329 15
      if ( cur < limit && start->y == cur->y )
      {
        /* draw a gray span between the start cell and the current one */
        if ( cur->x > x )
          gray_hline( RAS_VAR_ x, y,
                      cover * ( ONE_PIXEL * 2 ), cur->x - x );
      }
      else
      {
        /* draw a gray span until the end of the clipping region */
        if ( cover && x < ras.max_ex - ras.min_ex )
          gray_hline( RAS_VAR_ x, y,
                      cover * ( ONE_PIXEL * 2 ),
                      (int)( ras.max_ex - x - ras.min_ex ) );
        cover = 0;
d1332 3
a1334 2
      if ( cur >= limit )
        break;
a1339 18

#ifdef DEBUG_GRAYS

    {
      int       n;
      FT_Span*  span;


      fprintf( stderr, "y=%3d ", ras.span_y );
      span = ras.gray_spans;
      for ( n = 0; n < ras.num_gray_spans; n++, span++ )
        fprintf( stderr, "[%d..%d]:%02x ",
                 span->x, span->x + span->len - 1, span->coverage );
      fprintf( stderr, "\n" );
    }

#endif /* DEBUG_GRAYS */

d1376 1
a1376 1
  /*    Error code.  0 means sucess.                                       */
d1422 5
a1426 2
      v_start.x = SCALED( v_start.x ); v_start.y = SCALED( v_start.y );
      v_last.x  = SCALED( v_last.x );  v_last.y  = SCALED( v_last.y );
d1509 2
a1510 1
                error = func_interface->conic_to( &v_control, &vec, user );
d1522 2
a1523 1
              error = func_interface->conic_to( &v_control, &v_middle, user );
d1531 2
a1532 1
            error = func_interface->conic_to( &v_control, &v_start, user );
d1548 5
a1552 2
            vec1.x = SCALED( point[-2].x ); vec1.y = SCALED( point[-2].y );
            vec2.x = SCALED( point[-1].x ); vec2.y = SCALED( point[-1].y );
d1626 1
a1626 1
      error = ErrRaster_MemoryOverflow;
d1659 4
a1662 1
    /* simple heuristic used to speed-up the bezier decomposition -- see */
d1672 1
a1672 1
      if ( ras.max_ex > 24 || ras.max_ey > 24 )
d1674 1
a1674 1
      if ( ras.max_ex > 120 || ras.max_ey > 120 )
d1706 29
d1740 1
a1741 1
#if 1
a1742 4
#else
        error = FT_Outline_Decompose( outline, &func_interface, &ras ) ||
                gray_record_cell( RAS_VAR );
#endif
d1746 1
a1746 12
#ifdef SHELL_SORT
          gray_shell_sort( ras.cells, ras.num_cells );
#else
          gray_quick_sort( ras.cells, ras.num_cells );
#endif

#ifdef DEBUG_GRAYS
          gray_check_sort( ras.cells, ras.num_cells );
          gray_dump_cells( RAS_VAR );
#endif

          gray_sweep( RAS_VAR_  &ras.target );
d1750 1
a1750 1
        else if ( error != ErrRaster_MemoryOverflow )
d1753 2
a1754 1
        /* render pool overflow, we will reduce the render band by half */
d1759 2
a1760 2
        /* waoow! This is too complex for a single scanline, something */
        /* must be really rotten here!                                 */
d1793 1
d1796 5
a1800 2
    if ( !raster || !raster->cells || !raster->max_cells )
      return -1;
d1806 1
a1806 1
    if ( !outline || !outline->contours || !outline->points )
d1813 2
d1816 12
a1827 3
    if ( ( params->flags & FT_RASTER_FLAG_DIRECT ) == 0 &&
         ( !target_map || !target_map->buffer )         )
      return -1;
d1854 7
a1860 3
    ras.outline   = *outline;
    ras.num_cells = 0;
    ras.invalid   = 1;
d1874 1
a1874 1
    return gray_convert_glyph( (PRaster)raster );
a1880 29
#ifdef GRAYS_USE_GAMMA

  /* initialize the "gamma" table. Yes, this is really a crummy function */
  /* but the results look pretty good for something that simple.         */
  /*                                                                     */
#define M_MAX  255
#define M_X    128
#define M_Y    192

  static void
  grays_init_gamma( PRaster  raster )
  {
    unsigned int  x, a;


    for ( x = 0; x < 256; x++ )
    {
      if ( x <= M_X )
        a = ( x * M_Y + M_X / 2) / M_X;
      else
        a = M_Y + ( ( x - M_X ) * ( M_MAX - M_Y ) +
            ( M_MAX - M_X ) / 2 ) / ( M_MAX - M_X );

      raster->gamma[x] = (unsigned char)a;
    }
  }

#endif /* GRAYS_USE_GAMMA */

a1894 4
#ifdef GRAYS_USE_GAMMA
    grays_init_gamma( (PRaster)*araster );
#endif

a1920 4

#ifdef GRAYS_USE_GAMMA
      grays_init_gamma( raster );
#endif
d1940 3
a1942 3
  gray_raster_reset( FT_Raster    raster,
                     char*        pool_base,
                     long         pool_size )
d1947 5
a1951 2
    if ( raster && pool_base && pool_size >= 4096 )
      gray_init_cells( rast, (char*)pool_base, pool_size );
d1953 18
a1970 1
    rast->band_size  = (int)( ( pool_size / sizeof ( TCell ) ) / 8 );
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2005, 2006, 2007 by                   */
d84 5
d99 1
d116 2
a117 4
#define ErrRaster_Invalid_Mode      -2
#define ErrRaster_Invalid_Outline   -1
#define ErrRaster_Invalid_Argument  -3
#define ErrRaster_Memory_Overflow   -4
d141 3
a143 1
#else /* !_STANDALONE_ */
a154 2
#define ErrRaster_Memory_Overflow  Smooth_Err_Out_Of_Memory
#define ErrRaster_Invalid_Argument Smooth_Err_Bad_Argument
d156 2
a157 1
#endif /* !_STANDALONE_ */
a170 1

d176 2
a177 2
#define RAS_ARG   PWorker  worker
#define RAS_ARG_  PWorker  worker,
d179 2
a180 2
#define RAS_VAR   worker
#define RAS_VAR_  worker,
d182 1
a182 1
#define ras       (*worker)
d193 1
a193 1
  static TWorker  ras;
d204 1
a204 1
#define TRUNC( x )      ( (TCoord)( (x) >> PIXEL_BITS ) )
d218 6
d243 1
a243 1
  typedef int  TArea;
d251 1
a251 1
  typedef int   TArea;
d261 12
a272 1
  typedef struct TCell_*  PCell;
d276 4
a279 4
    int    x;
    int    cover;
    TArea  area;
    PCell  next;
d281 1
a281 1
  } TCell;
d283 1
d285 2
a286 1
  typedef struct  TWorker_
d288 4
a291 1
    TCoord  ex, ey;
a293 1
    TPos    count_ex, count_ey;
d299 1
a299 4
    PCell   cells;
    int     max_cells;
    int     num_cells;

d324 1
d327 3
a329 16
    void*       buffer;
    long        buffer_size;

    PCell*     ycells;
    int        ycount;

  } TWorker, *PWorker;


  typedef struct TRaster_
  {
    void*    buffer;
    long     buffer_size;
    int      band_size;
    void*    memory;
    PWorker  worker;
a333 1

d342 6
a347 10
    ras.buffer      = buffer;
    ras.buffer_size = byte_size;

    ras.ycells      = (PCell*) buffer;
    ras.cells       = NULL;
    ras.max_cells   = 0;
    ras.num_cells   = 0;
    ras.area        = 0;
    ras.cover       = 0;
    ras.invalid     = 1;
d399 2
a400 2
  static PCell
  gray_find_cell( RAS_ARG )
d402 1
a402 19
    PCell  *pcell, cell;
    int     x = ras.ex;


    if ( x > ras.max_ex )
      x = ras.max_ex;

    pcell = &ras.ycells[ras.ey];
    for (;;)
    {
      cell = *pcell;
      if ( cell == NULL || cell->x > x )
        break;

      if ( cell->x == x )
        goto Exit;

      pcell = &cell->next;
    }
a403 2
    if ( ras.num_cells >= ras.max_cells )
      ft_longjmp( ras.jump_buffer, 1 );
a404 16
    cell        = ras.cells + ras.num_cells++;
    cell->x     = x;
    cell->area  = 0;
    cell->cover = 0;

    cell->next  = *pcell;
    *pcell      = cell;

  Exit:
    return cell;
  }


  static void
  gray_record_cell( RAS_ARG )
  {
d407 2
a408 1
      PCell  cell = gray_find_cell( RAS_VAR );
d410 5
a414 3

      cell->area  += ras.area;
      cell->cover += ras.cover;
d427 3
d440 23
a462 17
    /* All cells that are on the left of the clipping region go to the */
    /* min_ex - 1 horizontal position.                                 */
    ey -= ras.min_ey;

    if ( ex > ras.max_ex )
      ex = ras.max_ex;

    ex -= ras.min_ex;
    if ( ex < 0 )
      ex = -1;

    /* are we moving to a different cell ? */
    if ( ex != ras.ex || ey != ras.ey )
    {
      /* record the current one if it is valid */
      if ( !ras.invalid )
        gray_record_cell( RAS_VAR );
d464 2
d470 1
a472 2
    ras.invalid = ( (unsigned)ey >= (unsigned)ras.count_ey ||
                              ex >= ras.count_ex           );
d481 2
a482 2
  gray_start_cell( RAS_ARG_ TCoord  ex,
                            TCoord  ey )
a483 3
    if ( ex > ras.max_ex )
      ex = (TCoord)( ras.max_ex );

d485 1
a485 1
      ex = (TCoord)( ras.min_ex - 1 );
d489 2
a490 2
    ras.ex      = ex - ras.min_ex;
    ras.ey      = ey - ras.min_ey;
d503 5
a507 5
  gray_render_scanline( RAS_ARG_ TCoord  ey,
                                 TPos    x1,
                                 TCoord  y1,
                                 TPos    x2,
                                 TCoord  y2 )
d516 2
a517 2
    ex1 = TRUNC( x1 );
    ex2 = TRUNC( x2 );
d620 1
a620 1
    ey2 = TRUNC( to_y );     /* if (ey2 >= ras.max_ey) ey2 = ras.max_ey-1; */
d675 1
a675 1
      gray_set_cell( &ras, ex, ey1 );
d684 1
a684 2

        gray_set_cell( &ras, ex, ey1 );
a689 1

d816 1
a816 1
      TPos  to_x, to_y, mid_x, mid_y;
a825 1

a886 1

d1035 182
d1218 7
a1224 1
    return;
d1227 2
d1233 1
a1233 1
                PWorker           worker )
d1239 1
a1239 1
    gray_record_cell( worker );
d1245 1
a1245 1
    gray_start_cell( worker, TRUNC( x ), TRUNC( y ) );
d1247 2
a1248 2
    worker->x = x;
    worker->y = y;
d1255 1
a1255 1
                PWorker           worker )
d1257 2
a1258 1
    gray_render_line( worker, UPSCALE( to->x ), UPSCALE( to->y ) );
d1266 1
a1266 1
                 PWorker           worker )
d1268 1
a1268 1
    gray_render_conic( worker, control, to );
d1277 1
a1277 1
                 PWorker           worker )
d1279 1
a1279 1
    gray_render_cubic( worker, control1, control2, to );
d1288 1
a1288 1
                    PWorker         worker )
d1291 1
a1291 1
    FT_Bitmap*      map = &worker->target;
d1304 4
d1309 3
d1313 20
a1332 9
        /* For small-spans it is faster to do it by ourselves than
         * calling `memset'.  This is mainly due to the cost of the
         * function call.
         */
        if ( spans->len >= 8 )
          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );
        else
        {
          unsigned char*  q = p + spans->x;
d1334 2
d1337 6
a1342 13
          switch ( spans->len )
          {
          case 7: *q++ = (unsigned char)coverage;
          case 6: *q++ = (unsigned char)coverage;
          case 5: *q++ = (unsigned char)coverage;
          case 4: *q++ = (unsigned char)coverage;
          case 3: *q++ = (unsigned char)coverage;
          case 2: *q++ = (unsigned char)coverage;
          case 1: *q   = (unsigned char)coverage;
          default:
            ;
          }
        }
d1344 2
d1347 1
d1350 2
d1359 3
a1361 3
    FT_Span*  span;
    int       count;
    int       coverage;
a1392 4
    /* FT_Span.x is a 16-bit short, so limit our coordinates appropriately */
    if ( x >= 32768 )
      x = 32767;

d1395 1
a1395 1
      /* see whether we can add this span to the current list */
d1401 1
a1401 1
           span->coverage == coverage         )
a1443 1

a1448 24
#ifdef DEBUG_GRAYS

  /* to be called while in the debugger */
  gray_dump_cells( RAS_ARG )
  {
    int  yindex;


    for ( yindex = 0; yindex < ras.ycount; yindex++ )
    {
      PCell  cell;


      printf( "%3d:", yindex );

      for ( cell = ras.ycells[yindex]; cell != NULL; cell = cell->next )
        printf( " (%3d, c:%4d, a:%6d)", cell->x, cell->cover, cell->area );
      printf( "\n" );
    }
  }

#endif /* DEBUG_GRAYS */


d1452 3
a1454 1
    int  yindex;
d1462 5
d1469 1
a1469 1
    for ( yindex = 0; yindex < ras.ycount; yindex++ )
d1471 3
a1473 3
      PCell   cell  = ras.ycells[yindex];
      TCoord  cover = 0;
      TCoord  x     = 0;
d1475 2
d1478 2
a1479 1
      for ( ; cell != NULL; cell = cell->next )
d1481 3
a1483 1
        TArea  area;
d1485 3
d1489 7
a1495 3
        if ( cell->x > x && cover != 0 )
          gray_hline( RAS_VAR_ x, yindex, cover * ( ONE_PIXEL * 2 ),
                      cell->x - x );
d1497 2
a1498 2
        cover += cell->cover;
        area   = cover * ( ONE_PIXEL * 2 ) - cell->area;
d1500 15
a1514 4
        if ( area != 0 && cell->x >= 0 )
          gray_hline( RAS_VAR_ cell->x, yindex, area, 1 );

        x = cell->x + 1;
d1517 2
a1518 3
      if ( cover != 0 )
        gray_hline( RAS_VAR_ x, yindex, cover * ( ONE_PIXEL * 2 ),
                    ras.count_ex - x );
d1524 18
d1578 1
a1578 1
  /*    Error code.  0 means success.                                      */
d1624 2
a1625 5
      v_start.x = SCALED( v_start.x );
      v_start.y = SCALED( v_start.y );

      v_last.x  = SCALED( v_last.x );
      v_last.y  = SCALED( v_last.y );
d1708 1
a1708 2
                error = func_interface->conic_to( &v_control, &vec,
                                                  user );
d1720 1
a1720 2
              error = func_interface->conic_to( &v_control, &v_middle,
                                                user );
d1728 1
a1728 2
            error = func_interface->conic_to( &v_control, &v_start,
                                              user );
d1744 2
a1745 5
            vec1.x = SCALED( point[-2].x );
            vec1.y = SCALED( point[-2].y );

            vec2.x = SCALED( point[-1].x );
            vec2.y = SCALED( point[-1].y );
d1819 1
a1819 1
      error = ErrRaster_Memory_Overflow;
a1851 3
    ras.count_ex = ras.max_ex - ras.min_ex;
    ras.count_ey = ras.max_ey - ras.min_ey;

d1862 1
a1862 1
      if ( ras.count_ex > 24 || ras.count_ey > 24 )
d1864 1
a1864 1
      if ( ras.count_ex > 120 || ras.count_ey > 120 )
a1895 29
        {
          PCell  cells_max;
          int    yindex;
          long   cell_start, cell_end, cell_mod;


          ras.ycells = (PCell*)ras.buffer;
          ras.ycount = band->max - band->min;

          cell_start = sizeof ( PCell ) * ras.ycount;
          cell_mod   = cell_start % sizeof ( TCell );
          if ( cell_mod > 0 )
            cell_start += sizeof ( TCell ) - cell_mod;

          cell_end  = ras.buffer_size;
          cell_end -= cell_end % sizeof( TCell );

          cells_max = (PCell)( (char*)ras.buffer + cell_end );
          ras.cells = (PCell)( (char*)ras.buffer + cell_start );
          if ( ras.cells >= cells_max )
            goto ReduceBands;

          ras.max_cells = cells_max - ras.cells;
          if ( ras.max_cells < 2 )
            goto ReduceBands;

          for ( yindex = 0; yindex < ras.ycount; yindex++ )
            ras.ycells[yindex] = NULL;
        }
a1900 1
        ras.count_ey  = band->max - band->min;
d1902 1
d1904 4
d1911 12
a1922 1
          gray_sweep( RAS_VAR_ &ras.target );
d1926 1
a1926 1
        else if ( error != ErrRaster_Memory_Overflow )
d1929 1
a1929 2
      ReduceBands:
        /* render pool overflow; we will reduce the render band by half */
d1934 2
a1935 2
        /* This is too complex for a single scanline; there must */
        /* be some problems.                                     */
a1967 1
    PWorker            worker;
d1970 2
a1971 2
    if ( !raster || !raster->buffer || !raster->buffer_size )
      return ErrRaster_Invalid_Argument;
a1983 2
    worker = raster->worker;

d1985 3
a1987 12
    if ( ( params->flags & FT_RASTER_FLAG_DIRECT ) == 0 )
    {
      if ( !target_map )
        return ErrRaster_Invalid_Argument;

      /* nothing to do */
      if ( !target_map->width || !target_map->rows )
        return 0;

      if ( !target_map->buffer )
        return ErrRaster_Invalid_Argument;
    }
a2013 2
    gray_init_cells( worker, raster->buffer, raster->buffer_size );

a2016 2
    ras.band_size = raster->band_size;
    ras.num_gray_spans = 0;
d2030 1
a2030 1
    return gray_convert_glyph( worker );
d2037 29
d2080 4
d2110 4
d2133 3
a2135 3
  gray_raster_reset( FT_Raster  raster,
                     char*      pool_base,
                     long       pool_size )
d2140 2
a2141 5
    if ( raster )
    {
      if ( pool_base && pool_size >= (long)sizeof ( TWorker ) + 2048 )
      {
        PWorker  worker = (PWorker)pool_base;
d2143 1
a2143 18

        rast->worker      = worker;
        rast->buffer      = pool_base +
                              ( ( sizeof ( TWorker ) + sizeof ( TCell ) - 1 ) &
                                ~( sizeof ( TCell ) - 1 ) );
        rast->buffer_size = (long)( ( pool_base + pool_size ) -
                                    (char*)rast->buffer ) &
                                      ~( sizeof ( TCell ) - 1 );
        rast->band_size   = (int)( rast->buffer_size /
                                     ( sizeof ( TCell ) * 8 ) );
      }
      else
      {
        rast->buffer      = NULL;
        rast->buffer_size = 0;
        rast->worker      = NULL;
      }
    }
@

