head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.2
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.4.0.2
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2017.01.13.11.19.59;	author dcoppa;	state Exp;
branches;
next	1.8;
commitid	ESXG9TuEmwmBXggf;

1.8
date	2016.10.28.21.41.15;	author dcoppa;	state Exp;
branches;
next	1.7;
commitid	T2hf37tVZU8TmjB1;

1.7
date	2016.05.29.11.57.12;	author dcoppa;	state Exp;
branches;
next	1.6;
commitid	1dOLexdOAzW2mQjp;

1.6
date	2015.12.07.09.34.03;	author dcoppa;	state Exp;
branches;
next	1.5;
commitid	wZOPiDmcwgRFTDVL;

1.5
date	2015.10.19.07.51.37;	author dcoppa;	state Exp;
branches;
next	1.4;
commitid	d2XmJCtYff11VIDu;

1.4
date	2015.06.28.08.27.48;	author dcoppa;	state Exp;
branches;
next	1.3;
commitid	qXwIGV2h9uFjxAmt;

1.3
date	2014.12.26.17.52.35;	author dcoppa;	state Exp;
branches;
next	1.2;
commitid	gwhRExMduYqoPQHI;

1.2
date	2013.10.10.19.49.53;	author matthieu;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2013.06.07.17.21.09;	author matthieu;	state Exp;
branches;
next	;

1.2.2.1
date	2015.03.11.19.50.48;	author tedu;	state Exp;
branches;
next	;
commitid	gSxuITleqkyrLFtk;

1.2.4.1
date	2015.03.11.19.50.17;	author tedu;	state Exp;
branches;
next	;
commitid	DBjn1kYKEwrb9ob6;


desc
@@


1.9
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  cf2intrp.c                                                             */
/*                                                                         */
/*    Adobe's CFF Interpreter (body).                                      */
/*                                                                         */
/*  Copyright 2007-2014 Adobe Systems Incorporated.                        */
/*                                                                         */
/*  This software, and all works of authorship, whether in source or       */
/*  object code form as indicated by the copyright notice(s) included      */
/*  herein (collectively, the "Work") is made available, and may only be   */
/*  used, modified, and distributed under the FreeType Project License,    */
/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
/*  FreeType Project License, each contributor to the Work hereby grants   */
/*  to any individual or legal entity exercising permissions granted by    */
/*  the FreeType Project License and this section (hereafter, "You" or     */
/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
/*  royalty-free, irrevocable (except as stated in this section) patent    */
/*  license to make, have made, use, offer to sell, sell, import, and      */
/*  otherwise transfer the Work, where such license applies only to those  */
/*  patent claims licensable by such contributor that are necessarily      */
/*  infringed by their contribution(s) alone or by combination of their    */
/*  contribution(s) with the Work to which such contribution(s) was        */
/*  submitted.  If You institute patent litigation against any entity      */
/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
/*  the Work or a contribution incorporated within the Work constitutes    */
/*  direct or contributory patent infringement, then any patent licenses   */
/*  granted to You under this License for that Work shall terminate as of  */
/*  the date such litigation is filed.                                     */
/*                                                                         */
/*  By using, modifying, or distributing the Work you indicate that you    */
/*  have read and understood the terms and conditions of the               */
/*  FreeType Project License as well as those provided in this section,    */
/*  and you accept them fully.                                             */
/*                                                                         */
/***************************************************************************/


#include "cf2ft.h"
#include FT_INTERNAL_DEBUG_H

#include "cf2glue.h"
#include "cf2font.h"
#include "cf2stack.h"
#include "cf2hints.h"
#include "cf2intrp.h"

#include "cf2error.h"

#include "cffload.h"


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_cf2interp


  /* some operators are not implemented yet */
#define CF2_FIXME  FT_TRACE4(( "cf2_interpT2CharString:"            \
                               " operator not implemented yet\n" ))



  FT_LOCAL_DEF( void )
  cf2_hintmask_init( CF2_HintMask  hintmask,
                     FT_Error*     error )
  {
    FT_ZERO( hintmask );

    hintmask->error = error;
  }


  FT_LOCAL_DEF( FT_Bool )
  cf2_hintmask_isValid( const CF2_HintMask  hintmask )
  {
    return hintmask->isValid;
  }


  FT_LOCAL_DEF( FT_Bool )
  cf2_hintmask_isNew( const CF2_HintMask  hintmask )
  {
    return hintmask->isNew;
  }


  FT_LOCAL_DEF( void )
  cf2_hintmask_setNew( CF2_HintMask  hintmask,
                       FT_Bool       val )
  {
    hintmask->isNew = val;
  }


  /* clients call `getMaskPtr' in order to iterate */
  /* through hint mask                             */

  FT_LOCAL_DEF( FT_Byte* )
  cf2_hintmask_getMaskPtr( CF2_HintMask  hintmask )
  {
    return hintmask->mask;
  }


  static size_t
  cf2_hintmask_setCounts( CF2_HintMask  hintmask,
                          size_t        bitCount )
  {
    if ( bitCount > CF2_MAX_HINTS )
    {
      /* total of h and v stems must be <= 96 */
      CF2_SET_ERROR( hintmask->error, Invalid_Glyph_Format );
      return 0;
    }

    hintmask->bitCount  = bitCount;
    hintmask->byteCount = ( hintmask->bitCount + 7 ) / 8;

    hintmask->isValid = TRUE;
    hintmask->isNew   = TRUE;

    return bitCount;
  }


  /* consume the hintmask bytes from the charstring, advancing the src */
  /* pointer                                                           */
  static void
  cf2_hintmask_read( CF2_HintMask  hintmask,
                     CF2_Buffer    charstring,
                     size_t        bitCount )
  {
    size_t  i;

#ifndef CF2_NDEBUG
    /* these are the bits in the final mask byte that should be zero  */
    /* Note: this variable is only used in an assert expression below */
    /* and then only if CF2_NDEBUG is not defined                     */
    CF2_UInt  mask = ( 1 << ( -(CF2_Int)bitCount & 7 ) ) - 1;
#endif


    /* initialize counts and isValid */
    if ( cf2_hintmask_setCounts( hintmask, bitCount ) == 0 )
      return;

    FT_ASSERT( hintmask->byteCount > 0 );

    FT_TRACE4(( " (maskbytes:" ));

    /* set mask and advance interpreter's charstring pointer */
    for ( i = 0; i < hintmask->byteCount; i++ )
    {
      hintmask->mask[i] = (FT_Byte)cf2_buf_readByte( charstring );
      FT_TRACE4(( " 0x%02X", hintmask->mask[i] ));
    }

    FT_TRACE4(( ")\n" ));

    /* assert any unused bits in last byte are zero unless there's a prior */
    /* error                                                               */
    /* bitCount -> mask, 0 -> 0, 1 -> 7f, 2 -> 3f, ... 6 -> 3, 7 -> 1      */
#ifndef CF2_NDEBUG
    FT_ASSERT( ( hintmask->mask[hintmask->byteCount - 1] & mask ) == 0 ||
               *hintmask->error                                        );
#endif
  }


  FT_LOCAL_DEF( void )
  cf2_hintmask_setAll( CF2_HintMask  hintmask,
                       size_t        bitCount )
  {
    size_t    i;
    CF2_UInt  mask = ( 1 << ( -(CF2_Int)bitCount & 7 ) ) - 1;


    /* initialize counts and isValid */
    if ( cf2_hintmask_setCounts( hintmask, bitCount ) == 0 )
      return;

    FT_ASSERT( hintmask->byteCount > 0 );
    FT_ASSERT( hintmask->byteCount <=
                 sizeof ( hintmask->mask ) / sizeof ( hintmask->mask[0] ) );

    /* set mask to all ones */
    for ( i = 0; i < hintmask->byteCount; i++ )
      hintmask->mask[i] = 0xFF;

    /* clear unused bits                                              */
    /* bitCount -> mask, 0 -> 0, 1 -> 7f, 2 -> 3f, ... 6 -> 3, 7 -> 1 */
    hintmask->mask[hintmask->byteCount - 1] &= ~mask;
  }


  /* Type2 charstring opcodes */
  enum
  {
    cf2_cmdRESERVED_0,   /* 0 */
    cf2_cmdHSTEM,        /* 1 */
    cf2_cmdRESERVED_2,   /* 2 */
    cf2_cmdVSTEM,        /* 3 */
    cf2_cmdVMOVETO,      /* 4 */
    cf2_cmdRLINETO,      /* 5 */
    cf2_cmdHLINETO,      /* 6 */
    cf2_cmdVLINETO,      /* 7 */
    cf2_cmdRRCURVETO,    /* 8 */
    cf2_cmdRESERVED_9,   /* 9 */
    cf2_cmdCALLSUBR,     /* 10 */
    cf2_cmdRETURN,       /* 11 */
    cf2_cmdESC,          /* 12 */
    cf2_cmdRESERVED_13,  /* 13 */
    cf2_cmdENDCHAR,      /* 14 */
    cf2_cmdVSINDEX,      /* 15 */
    cf2_cmdBLEND,        /* 16 */
    cf2_cmdRESERVED_17,  /* 17 */
    cf2_cmdHSTEMHM,      /* 18 */
    cf2_cmdHINTMASK,     /* 19 */
    cf2_cmdCNTRMASK,     /* 20 */
    cf2_cmdRMOVETO,      /* 21 */
    cf2_cmdHMOVETO,      /* 22 */
    cf2_cmdVSTEMHM,      /* 23 */
    cf2_cmdRCURVELINE,   /* 24 */
    cf2_cmdRLINECURVE,   /* 25 */
    cf2_cmdVVCURVETO,    /* 26 */
    cf2_cmdHHCURVETO,    /* 27 */
    cf2_cmdEXTENDEDNMBR, /* 28 */
    cf2_cmdCALLGSUBR,    /* 29 */
    cf2_cmdVHCURVETO,    /* 30 */
    cf2_cmdHVCURVETO     /* 31 */
  };

  enum
  {
    cf2_escDOTSECTION,   /* 0 */
    cf2_escRESERVED_1,   /* 1 */
    cf2_escRESERVED_2,   /* 2 */
    cf2_escAND,          /* 3 */
    cf2_escOR,           /* 4 */
    cf2_escNOT,          /* 5 */
    cf2_escRESERVED_6,   /* 6 */
    cf2_escRESERVED_7,   /* 7 */
    cf2_escRESERVED_8,   /* 8 */
    cf2_escABS,          /* 9 */
    cf2_escADD,          /* 10     like otherADD */
    cf2_escSUB,          /* 11     like otherSUB */
    cf2_escDIV,          /* 12 */
    cf2_escRESERVED_13,  /* 13 */
    cf2_escNEG,          /* 14 */
    cf2_escEQ,           /* 15 */
    cf2_escRESERVED_16,  /* 16 */
    cf2_escRESERVED_17,  /* 17 */
    cf2_escDROP,         /* 18 */
    cf2_escRESERVED_19,  /* 19 */
    cf2_escPUT,          /* 20     like otherPUT    */
    cf2_escGET,          /* 21     like otherGET    */
    cf2_escIFELSE,       /* 22     like otherIFELSE */
    cf2_escRANDOM,       /* 23     like otherRANDOM */
    cf2_escMUL,          /* 24     like otherMUL    */
    cf2_escRESERVED_25,  /* 25 */
    cf2_escSQRT,         /* 26 */
    cf2_escDUP,          /* 27     like otherDUP    */
    cf2_escEXCH,         /* 28     like otherEXCH   */
    cf2_escINDEX,        /* 29 */
    cf2_escROLL,         /* 30 */
    cf2_escRESERVED_31,  /* 31 */
    cf2_escRESERVED_32,  /* 32 */
    cf2_escRESERVED_33,  /* 33 */
    cf2_escHFLEX,        /* 34 */
    cf2_escFLEX,         /* 35 */
    cf2_escHFLEX1,       /* 36 */
    cf2_escFLEX1,        /* 37 */
    cf2_escRESERVED_38   /* 38     & all higher     */
  };


  /* `stemHintArray' does not change once we start drawing the outline. */
  static void
  cf2_doStems( const CF2_Font  font,
               CF2_Stack       opStack,
               CF2_ArrStack    stemHintArray,
               CF2_Fixed*      width,
               FT_Bool*        haveWidth,
               CF2_Fixed       hintOffset )
  {
    CF2_UInt  i;
    CF2_UInt  count       = cf2_stack_count( opStack );
    FT_Bool   hasWidthArg = (FT_Bool)( count & 1 );

    /* variable accumulates delta values from operand stack */
    CF2_Fixed  position = hintOffset;


    if ( hasWidthArg && !*haveWidth )
      *width = cf2_stack_getReal( opStack, 0 ) +
                 cf2_getNominalWidthX( font->decoder );

    if ( font->decoder->width_only )
      goto exit;

    for ( i = hasWidthArg ? 1 : 0; i < count; i += 2 )
    {
      /* construct a CF2_StemHint and push it onto the list */
      CF2_StemHintRec  stemhint;


      stemhint.min  =
        position   += cf2_stack_getReal( opStack, i );
      stemhint.max  =
        position   += cf2_stack_getReal( opStack, i + 1 );

      stemhint.used  = FALSE;
      stemhint.maxDS =
      stemhint.minDS = 0;

      cf2_arrstack_push( stemHintArray, &stemhint ); /* defer error check */
    }

    cf2_stack_clear( opStack );

  exit:
    /* cf2_doStems must define a width (may be default) */
    *haveWidth = TRUE;
  }


  static void
  cf2_doFlex( CF2_Stack       opStack,
              CF2_Fixed*      curX,
              CF2_Fixed*      curY,
              CF2_GlyphPath   glyphPath,
              const FT_Bool*  readFromStack,
              FT_Bool         doConditionalLastRead )
  {
    CF2_Fixed  vals[14];
    CF2_UInt   index;
    FT_Bool    isHFlex;
    CF2_Int    top, i, j;


    vals[0] = *curX;
    vals[1] = *curY;
    index   = 0;
    isHFlex = FT_BOOL( readFromStack[9] == FALSE );
    top     = isHFlex ? 9 : 10;

    for ( i = 0; i < top; i++ )
    {
      vals[i + 2] = vals[i];
      if ( readFromStack[i] )
        vals[i + 2] += cf2_stack_getReal( opStack, index++ );
    }

    if ( isHFlex )
      vals[9 + 2] = *curY;

    if ( doConditionalLastRead )
    {
      FT_Bool    lastIsX = (FT_Bool)( cf2_fixedAbs( vals[10] - *curX ) >
                                        cf2_fixedAbs( vals[11] - *curY ) );
      CF2_Fixed  lastVal = cf2_stack_getReal( opStack, index );


      if ( lastIsX )
      {
        vals[12] = vals[10] + lastVal;
        vals[13] = *curY;
      }
      else
      {
        vals[12] = *curX;
        vals[13] = vals[11] + lastVal;
      }
    }
    else
    {
      if ( readFromStack[10] )
        vals[12] = vals[10] + cf2_stack_getReal( opStack, index++ );
      else
        vals[12] = *curX;

      if ( readFromStack[11] )
        vals[13] = vals[11] + cf2_stack_getReal( opStack, index );
      else
        vals[13] = *curY;
    }

    for ( j = 0; j < 2; j++ )
      cf2_glyphpath_curveTo( glyphPath, vals[j * 6 + 2],
                                        vals[j * 6 + 3],
                                        vals[j * 6 + 4],
                                        vals[j * 6 + 5],
                                        vals[j * 6 + 6],
                                        vals[j * 6 + 7] );

    cf2_stack_clear( opStack );

    *curX = vals[12];
    *curY = vals[13];
  }


  /* Blend numOperands on the stack,                */
  /* store results into the first numBlends values, */
  /* then pop remaining arguments.                  */
  static void
  cf2_doBlend( const CFF_Blend  blend,
               CF2_Stack        opStack,
               CF2_UInt         numBlends )
  {
    CF2_UInt  delta;
    CF2_UInt  base;
    CF2_UInt  i, j;
    CF2_UInt  numOperands = (CF2_UInt)( numBlends * blend->lenBV );


    base  = cf2_stack_count( opStack ) - numOperands;
    delta = base + numBlends;

    for ( i = 0; i < numBlends; i++ )
    {
      const CF2_Fixed*  weight = &blend->BV[1];

      /* start with first term */
      CF2_Fixed  sum = cf2_stack_getReal( opStack, i + base );


      for ( j = 1; j < blend->lenBV; j++ )
        sum += FT_MulFix( *weight++, cf2_stack_getReal( opStack, delta++ ) );

      /* store blended result  */
      cf2_stack_setReal( opStack, i + base, sum );
    }

    /* leave only `numBlends' results on stack */
    cf2_stack_pop( opStack, numOperands - numBlends );
  }


  /*
   * `error' is a shared error code used by many objects in this
   * routine.  Before the code continues from an error, it must check and
   * record the error in `*error'.  The idea is that this shared
   * error code will record the first error encountered.  If testing
   * for an error anyway, the cost of `goto exit' is small, so we do it,
   * even if continuing would be safe.  In this case, `lastError' is
   * set, so the testing and storing can be done in one place, at `exit'.
   *
   * Continuing after an error is intended for objects which do their own
   * testing of `*error', e.g., array stack functions.  This allows us to
   * avoid an extra test after the call.
   *
   * Unimplemented opcodes are ignored.
   *
   */
  FT_LOCAL_DEF( void )
  cf2_interpT2CharString( CF2_Font              font,
                          CF2_Buffer            buf,
                          CF2_OutlineCallbacks  callbacks,
                          const FT_Vector*      translation,
                          FT_Bool               doingSeac,
                          CF2_Fixed             curX,
                          CF2_Fixed             curY,
                          CF2_Fixed*            width )
  {
    /* lastError is used for errors that are immediately tested */
    FT_Error  lastError = FT_Err_Ok;

    /* pointer to parsed font object */
    CFF_Decoder*  decoder = font->decoder;

    FT_Error*  error  = &font->error;
    FT_Memory  memory = font->memory;

    CF2_Fixed  scaleY        = font->innerTransform.d;
    CF2_Fixed  nominalWidthX = cf2_getNominalWidthX( decoder );

    /* save this for hinting seac accents */
    CF2_Fixed  hintOriginY = curY;

    CF2_Stack  opStack = NULL;
    FT_UInt    stackSize;
    FT_Byte    op1;                       /* first opcode byte */

    CF2_F16Dot16  storage[CF2_STORAGE_SIZE];    /* for `put' and `get' */

    /* instruction limit; 20,000,000 matches Avalon */
    FT_UInt32  instructionLimit = 20000000UL;

    CF2_ArrStackRec  subrStack;

    FT_Bool     haveWidth;
    CF2_Buffer  charstring = NULL;

    CF2_Int  charstringIndex = -1;       /* initialize to empty */

    /* TODO: placeholders for hint structures */

    /* objects used for hinting */
    CF2_ArrStackRec  hStemHintArray;
    CF2_ArrStackRec  vStemHintArray;

    CF2_HintMaskRec   hintMask;
    CF2_GlyphPathRec  glyphPath;


    FT_ZERO( &storage );

    /* initialize the remaining objects */
    cf2_arrstack_init( &subrStack,
                       memory,
                       error,
                       sizeof ( CF2_BufferRec ) );
    cf2_arrstack_init( &hStemHintArray,
                       memory,
                       error,
                       sizeof ( CF2_StemHintRec ) );
    cf2_arrstack_init( &vStemHintArray,
                       memory,
                       error,
                       sizeof ( CF2_StemHintRec ) );

    /* initialize CF2_StemHint arrays */
    cf2_hintmask_init( &hintMask, error );

    /* initialize path map to manage drawing operations */

    /* Note: last 4 params are used to handle `MoveToPermissive', which */
    /*       may need to call `hintMap.Build'                           */
    /* TODO: MoveToPermissive is gone; are these still needed?          */
    cf2_glyphpath_init( &glyphPath,
                        font,
                        callbacks,
                        scaleY,
                        /* hShift, */
                        &hStemHintArray,
                        &vStemHintArray,
                        &hintMask,
                        hintOriginY,
                        &font->blues,
                        translation );

    /*
     * Initialize state for width parsing.  From the CFF Spec:
     *
     *   The first stack-clearing operator, which must be one of hstem,
     *   hstemhm, vstem, vstemhm, cntrmask, hintmask, hmoveto, vmoveto,
     *   rmoveto, or endchar, takes an additional argument - the width (as
     *   described earlier), which may be expressed as zero or one numeric
     *   argument.
     *
     * What we implement here uses the first validly specified width, but
     * does not detect errors for specifying more than one width.
     *
     * If one of the above operators occurs without explicitly specifying
     * a width, we assume the default width.
     *
     * CFF2 charstrings always return the default width (0).
     *
     */
    haveWidth = font->isCFF2 ? TRUE : FALSE;
    *width    = cf2_getDefaultWidthX( decoder );

    /*
     * Note: At this point, all pointers to resources must be NULL
     *       and all local objects must be initialized.
     *       There must be no branches to `exit:' above this point.
     *
     */

    /* allocate an operand stack */
    stackSize = font->isCFF2 ? cf2_getMaxstack( decoder )
                             : CF2_OPERAND_STACK_SIZE;
    opStack   = cf2_stack_init( memory, error, stackSize );

    if ( !opStack )
    {
      lastError = FT_THROW( Out_Of_Memory );
      goto exit;
    }

    /* initialize subroutine stack by placing top level charstring as */
    /* first element (max depth plus one for the charstring)          */
    /* Note: Caller owns and must finalize the first charstring.      */
    /*       Our copy of it does not change that requirement.         */
    cf2_arrstack_setCount( &subrStack, CF2_MAX_SUBR + 1 );

    charstring  = (CF2_Buffer)cf2_arrstack_getBuffer( &subrStack );
    *charstring = *buf;    /* structure copy */

    charstringIndex = 0;       /* entry is valid now */

    /* catch errors so far */
    if ( *error )
      goto exit;

    /* main interpreter loop */
    while ( 1 )
    {
      if ( cf2_buf_isEnd( charstring ) )
      {
        /* If we've reached the end of the charstring, simulate a */
        /* cf2_cmdRETURN or cf2_cmdENDCHAR.                       */
        /* We do this for both CFF and CFF2.                      */
        if ( charstringIndex )
          op1 = cf2_cmdRETURN;  /* end of buffer for subroutine */
        else
          op1 = cf2_cmdENDCHAR; /* end of buffer for top level charstring */
      }
      else
      {
        op1 = (FT_Byte)cf2_buf_readByte( charstring );

        /* Explicit RETURN and ENDCHAR in CFF2 should be ignored. */
        /* Note: Trace message will report 0 instead of 11 or 14. */
        if ( ( op1 == cf2_cmdRETURN || op1 == cf2_cmdENDCHAR ) &&
             font->isCFF2                                      )
          op1 = cf2_cmdRESERVED_0;
      }

      /* check for errors once per loop */
      if ( *error )
        goto exit;

      instructionLimit--;
      if ( instructionLimit == 0 )
      {
        lastError = FT_THROW( Invalid_Glyph_Format );
        goto exit;
      }

      switch( op1 )
      {
      case cf2_cmdRESERVED_0:
      case cf2_cmdRESERVED_2:
      case cf2_cmdRESERVED_9:
      case cf2_cmdRESERVED_13:
      case cf2_cmdRESERVED_17:
        /* we may get here if we have a prior error */
        FT_TRACE4(( " unknown op (%d)\n", op1 ));
        break;

      case cf2_cmdVSINDEX:
        FT_TRACE4(( " vsindex\n" ));

        if ( !font->isCFF2 )
          break;    /* clear stack & ignore */

        if ( font->blend.usedBV )
        {
          /* vsindex not allowed after blend */
          lastError = FT_THROW( Invalid_Glyph_Format );
          goto exit;
        }

        {
          FT_Int  temp = cf2_stack_popInt( opStack );


          if ( temp >= 0 )
            font->vsindex = (FT_UInt)temp;
        }
        break;

      case cf2_cmdBLEND:
        {
          FT_UInt  numBlends;


          FT_TRACE4(( " blend\n" ));

          if ( !font->isCFF2 )
            break;    /* clear stack & ignore */

          /* do we have a `blend' op in a non-variant font? */
          if ( !font->blend.font )
          {
            lastError = FT_THROW( Invalid_Glyph_Format );
            goto exit;
          }

          /* check cached blend vector */
          if ( cff_blend_check_vector( &font->blend,
                                       font->vsindex,
                                       font->lenNDV,
                                       font->NDV ) )
          {
            lastError = cff_blend_build_vector( &font->blend,
                                                font->vsindex,
                                                font->lenNDV,
                                                font->NDV );
            if ( lastError )
              goto exit;
          }

          /* do the blend */
          numBlends = (FT_UInt)cf2_stack_popInt( opStack );
          if ( numBlends > stackSize )
          {
            lastError = FT_THROW( Invalid_Glyph_Format );
            goto exit;
          }

          cf2_doBlend( &font->blend, opStack, numBlends );

          font->blend.usedBV = TRUE;
        }
        continue;     /* do not clear the stack */

      case cf2_cmdHSTEMHM:
      case cf2_cmdHSTEM:
        FT_TRACE4(( op1 == cf2_cmdHSTEMHM ? " hstemhm\n" : " hstem\n" ));

        /* never add hints after the mask is computed */
        if ( cf2_hintmask_isValid( &hintMask ) )
        {
          FT_TRACE4(( "cf2_interpT2CharString:"
                      " invalid horizontal hint mask\n" ));
          break;
        }

        cf2_doStems( font,
                     opStack,
                     &hStemHintArray,
                     width,
                     &haveWidth,
                     0 );

        if ( font->decoder->width_only )
          goto exit;

        break;

      case cf2_cmdVSTEMHM:
      case cf2_cmdVSTEM:
        FT_TRACE4(( op1 == cf2_cmdVSTEMHM ? " vstemhm\n" : " vstem\n" ));

        /* never add hints after the mask is computed */
        if ( cf2_hintmask_isValid( &hintMask ) )
        {
          FT_TRACE4(( "cf2_interpT2CharString:"
                      " invalid vertical hint mask\n" ));
          break;
        }

        cf2_doStems( font,
                     opStack,
                     &vStemHintArray,
                     width,
                     &haveWidth,
                     0 );

        if ( font->decoder->width_only )
          goto exit;

        break;

      case cf2_cmdVMOVETO:
        FT_TRACE4(( " vmoveto\n" ));

        if ( cf2_stack_count( opStack ) > 1 && !haveWidth )
          *width = cf2_stack_getReal( opStack, 0 ) + nominalWidthX;

        /* width is defined or default after this */
        haveWidth = TRUE;

        if ( font->decoder->width_only )
          goto exit;

        curY += cf2_stack_popFixed( opStack );

        cf2_glyphpath_moveTo( &glyphPath, curX, curY );

        break;

      case cf2_cmdRLINETO:
        {
          CF2_UInt  index;
          CF2_UInt  count = cf2_stack_count( opStack );


          FT_TRACE4(( " rlineto\n" ));

          for ( index = 0; index < count; index += 2 )
          {
            curX += cf2_stack_getReal( opStack, index + 0 );
            curY += cf2_stack_getReal( opStack, index + 1 );

            cf2_glyphpath_lineTo( &glyphPath, curX, curY );
          }

          cf2_stack_clear( opStack );
        }
        continue; /* no need to clear stack again */

      case cf2_cmdHLINETO:
      case cf2_cmdVLINETO:
        {
          CF2_UInt  index;
          CF2_UInt  count = cf2_stack_count( opStack );

          FT_Bool  isX = FT_BOOL( op1 == cf2_cmdHLINETO );


          FT_TRACE4(( isX ? " hlineto\n" : " vlineto\n" ));

          for ( index = 0; index < count; index++ )
          {
            CF2_Fixed  v = cf2_stack_getReal( opStack, index );


            if ( isX )
              curX += v;
            else
              curY += v;

            isX = !isX;

            cf2_glyphpath_lineTo( &glyphPath, curX, curY );
          }

          cf2_stack_clear( opStack );
        }
        continue;

      case cf2_cmdRCURVELINE:
      case cf2_cmdRRCURVETO:
        {
          CF2_UInt  count = cf2_stack_count( opStack );
          CF2_UInt  index = 0;


          FT_TRACE4(( op1 == cf2_cmdRCURVELINE ? " rcurveline\n"
                                               : " rrcurveto\n" ));

          while ( index + 6 <= count )
          {
            CF2_Fixed  x1 = cf2_stack_getReal( opStack, index + 0 ) + curX;
            CF2_Fixed  y1 = cf2_stack_getReal( opStack, index + 1 ) + curY;
            CF2_Fixed  x2 = cf2_stack_getReal( opStack, index + 2 ) + x1;
            CF2_Fixed  y2 = cf2_stack_getReal( opStack, index + 3 ) + y1;
            CF2_Fixed  x3 = cf2_stack_getReal( opStack, index + 4 ) + x2;
            CF2_Fixed  y3 = cf2_stack_getReal( opStack, index + 5 ) + y2;


            cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );

            curX   = x3;
            curY   = y3;
            index += 6;
          }

          if ( op1 == cf2_cmdRCURVELINE )
          {
            curX += cf2_stack_getReal( opStack, index + 0 );
            curY += cf2_stack_getReal( opStack, index + 1 );

            cf2_glyphpath_lineTo( &glyphPath, curX, curY );
          }

          cf2_stack_clear( opStack );
        }
        continue; /* no need to clear stack again */

      case cf2_cmdCALLGSUBR:
      case cf2_cmdCALLSUBR:
        {
          CF2_Int  subrNum;


          FT_TRACE4(( op1 == cf2_cmdCALLGSUBR ? " callgsubr"
                                              : " callsubr" ));

          if ( charstringIndex > CF2_MAX_SUBR )
          {
            /* max subr plus one for charstring */
            lastError = FT_THROW( Invalid_Glyph_Format );
            goto exit;                      /* overflow of stack */
          }

          /* push our current CFF charstring region on subrStack */
          charstring = (CF2_Buffer)
                         cf2_arrstack_getPointer(
                           &subrStack,
                           (size_t)charstringIndex + 1 );

          /* set up the new CFF region and pointer */
          subrNum = cf2_stack_popInt( opStack );

          switch ( op1 )
          {
          case cf2_cmdCALLGSUBR:
            FT_TRACE4(( " (idx %d, entering level %d)\n",
                        subrNum + decoder->globals_bias,
                        charstringIndex + 1 ));

            if ( cf2_initGlobalRegionBuffer( decoder,
                                             subrNum,
                                             charstring ) )
            {
              lastError = FT_THROW( Invalid_Glyph_Format );
              goto exit;  /* subroutine lookup or stream error */
            }
            break;

          default:
            /* cf2_cmdCALLSUBR */
            FT_TRACE4(( " (idx %d, entering level %d)\n",
                        subrNum + decoder->locals_bias,
                        charstringIndex + 1 ));

            if ( cf2_initLocalRegionBuffer( decoder,
                                            subrNum,
                                            charstring ) )
            {
              lastError = FT_THROW( Invalid_Glyph_Format );
              goto exit;  /* subroutine lookup or stream error */
            }
          }

          charstringIndex += 1;       /* entry is valid now */
        }
        continue; /* do not clear the stack */

      case cf2_cmdRETURN:
        FT_TRACE4(( " return (leaving level %d)\n", charstringIndex ));

        if ( charstringIndex < 1 )
        {
          /* Note: cannot return from top charstring */
          lastError = FT_THROW( Invalid_Glyph_Format );
          goto exit;                      /* underflow of stack */
        }

        /* restore position in previous charstring */
        charstring = (CF2_Buffer)
                       cf2_arrstack_getPointer(
                         &subrStack,
                         (CF2_UInt)--charstringIndex );
        continue;     /* do not clear the stack */

      case cf2_cmdESC:
        {
          FT_Byte  op2 = (FT_Byte)cf2_buf_readByte( charstring );


          /* first switch for 2-byte operators handles CFF2      */
          /* and opcodes that are reserved for both CFF and CFF2 */
          switch ( op2 )
          {
          case cf2_escHFLEX:
            {
              static const FT_Bool  readFromStack[12] =
              {
                TRUE /* dx1 */, FALSE /* dy1 */,
                TRUE /* dx2 */, TRUE  /* dy2 */,
                TRUE /* dx3 */, FALSE /* dy3 */,
                TRUE /* dx4 */, FALSE /* dy4 */,
                TRUE /* dx5 */, FALSE /* dy5 */,
                TRUE /* dx6 */, FALSE /* dy6 */
              };


              FT_TRACE4(( " hflex\n" ));

              cf2_doFlex( opStack,
                          &curX,
                          &curY,
                          &glyphPath,
                          readFromStack,
                          FALSE /* doConditionalLastRead */ );
            }
            continue;

          case cf2_escFLEX:
            {
              static const FT_Bool  readFromStack[12] =
              {
                TRUE /* dx1 */, TRUE /* dy1 */,
                TRUE /* dx2 */, TRUE /* dy2 */,
                TRUE /* dx3 */, TRUE /* dy3 */,
                TRUE /* dx4 */, TRUE /* dy4 */,
                TRUE /* dx5 */, TRUE /* dy5 */,
                TRUE /* dx6 */, TRUE /* dy6 */
              };


              FT_TRACE4(( " flex\n" ));

              cf2_doFlex( opStack,
                          &curX,
                          &curY,
                          &glyphPath,
                          readFromStack,
                          FALSE /* doConditionalLastRead */ );
            }
            break;      /* TODO: why is this not a continue? */

          case cf2_escHFLEX1:
            {
              static const FT_Bool  readFromStack[12] =
              {
                TRUE /* dx1 */, TRUE  /* dy1 */,
                TRUE /* dx2 */, TRUE  /* dy2 */,
                TRUE /* dx3 */, FALSE /* dy3 */,
                TRUE /* dx4 */, FALSE /* dy4 */,
                TRUE /* dx5 */, TRUE  /* dy5 */,
                TRUE /* dx6 */, FALSE /* dy6 */
              };


              FT_TRACE4(( " hflex1\n" ));

              cf2_doFlex( opStack,
                          &curX,
                          &curY,
                          &glyphPath,
                          readFromStack,
                          FALSE /* doConditionalLastRead */ );
            }
            continue;

          case cf2_escFLEX1:
            {
              static const FT_Bool  readFromStack[12] =
              {
                TRUE  /* dx1 */, TRUE  /* dy1 */,
                TRUE  /* dx2 */, TRUE  /* dy2 */,
                TRUE  /* dx3 */, TRUE  /* dy3 */,
                TRUE  /* dx4 */, TRUE  /* dy4 */,
                TRUE  /* dx5 */, TRUE  /* dy5 */,
                FALSE /* dx6 */, FALSE /* dy6 */
              };


              FT_TRACE4(( " flex1\n" ));

              cf2_doFlex( opStack,
                          &curX,
                          &curY,
                          &glyphPath,
                          readFromStack,
                          TRUE /* doConditionalLastRead */ );
            }
            continue;

          /* these opcodes are reserved in both CFF & CFF2 */
          case cf2_escRESERVED_1:
          case cf2_escRESERVED_2:
          case cf2_escRESERVED_6:
          case cf2_escRESERVED_7:
          case cf2_escRESERVED_8:
          case cf2_escRESERVED_13:
          case cf2_escRESERVED_16:
          case cf2_escRESERVED_17:
          case cf2_escRESERVED_19:
          case cf2_escRESERVED_25:
          case cf2_escRESERVED_31:
          case cf2_escRESERVED_32:
          case cf2_escRESERVED_33:
            FT_TRACE4(( " unknown op (12, %d)\n", op2 ));
            break;

          default:
            {
              if ( font->isCFF2 || op2 >= cf2_escRESERVED_38 )
                FT_TRACE4(( " unknown op (12, %d)\n", op2 ));
              else
              {
                /* second switch for 2-byte operators handles just CFF */
                switch ( op2 )
                {

                case cf2_escDOTSECTION:
                  /* something about `flip type of locking' -- ignore it */
                  FT_TRACE4(( " dotsection\n" ));

                  break;

                case cf2_escAND:
                  {
                    CF2_F16Dot16  arg1;
                    CF2_F16Dot16  arg2;


                    FT_TRACE4(( " and\n" ));

                    arg2 = cf2_stack_popFixed( opStack );
                    arg1 = cf2_stack_popFixed( opStack );

                    cf2_stack_pushInt( opStack, arg1 && arg2 );
                  }
                  continue; /* do not clear the stack */

                case cf2_escOR:
                  {
                    CF2_F16Dot16  arg1;
                    CF2_F16Dot16  arg2;


                    FT_TRACE4(( " or\n" ));

                    arg2 = cf2_stack_popFixed( opStack );
                    arg1 = cf2_stack_popFixed( opStack );

                    cf2_stack_pushInt( opStack, arg1 || arg2 );
                  }
                  continue; /* do not clear the stack */

                case cf2_escNOT:
                  {
                    CF2_F16Dot16  arg;


                    FT_TRACE4(( " not\n" ));

                    arg = cf2_stack_popFixed( opStack );

                    cf2_stack_pushInt( opStack, !arg );
                  }
                  continue; /* do not clear the stack */

                case cf2_escABS:
                  {
                    CF2_F16Dot16  arg;


                    FT_TRACE4(( " abs\n" ));

                    arg = cf2_stack_popFixed( opStack );

                    cf2_stack_pushFixed( opStack, FT_ABS( arg ) );
                  }
                  continue; /* do not clear the stack */

                case cf2_escADD:
                  {
                    CF2_F16Dot16  summand1;
                    CF2_F16Dot16  summand2;


                    FT_TRACE4(( " add\n" ));

                    summand2 = cf2_stack_popFixed( opStack );
                    summand1 = cf2_stack_popFixed( opStack );

                    cf2_stack_pushFixed( opStack, summand1 + summand2 );
                  }
                  continue; /* do not clear the stack */

                case cf2_escSUB:
                  {
                    CF2_F16Dot16  minuend;
                    CF2_F16Dot16  subtrahend;


                    FT_TRACE4(( " sub\n" ));

                    subtrahend = cf2_stack_popFixed( opStack );
                    minuend    = cf2_stack_popFixed( opStack );

                    cf2_stack_pushFixed( opStack, minuend - subtrahend );
                  }
                  continue; /* do not clear the stack */

                case cf2_escDIV:
                  {
                    CF2_F16Dot16  dividend;
                    CF2_F16Dot16  divisor;


                    FT_TRACE4(( " div\n" ));

                    divisor  = cf2_stack_popFixed( opStack );
                    dividend = cf2_stack_popFixed( opStack );

                    cf2_stack_pushFixed( opStack, FT_DivFix( dividend, divisor ) );
                  }
                  continue; /* do not clear the stack */

                case cf2_escNEG:
                  {
                    CF2_F16Dot16  arg;


                    FT_TRACE4(( " neg\n" ));

                    arg = cf2_stack_popFixed( opStack );

                    cf2_stack_pushFixed( opStack, -arg );
                  }
                  continue; /* do not clear the stack */

                case cf2_escEQ:
                  {
                    CF2_F16Dot16  arg1;
                    CF2_F16Dot16  arg2;


                    FT_TRACE4(( " eq\n" ));

                    arg2 = cf2_stack_popFixed( opStack );
                    arg1 = cf2_stack_popFixed( opStack );

                    cf2_stack_pushInt( opStack, arg1 == arg2 );
                  }
                  continue; /* do not clear the stack */

                case cf2_escDROP:
                  FT_TRACE4(( " drop\n" ));

                  (void)cf2_stack_popFixed( opStack );
                  continue; /* do not clear the stack */

                case cf2_escPUT:
                  {
                    CF2_F16Dot16  val;
                    CF2_Int       idx;


                    FT_TRACE4(( " put\n" ));

                    idx = cf2_stack_popInt( opStack );
                    val = cf2_stack_popFixed( opStack );

                    if ( idx >= 0 && idx < CF2_STORAGE_SIZE )
                      storage[idx] = val;
                  }
                  continue; /* do not clear the stack */

                case cf2_escGET:
                  {
                    CF2_Int  idx;


                    FT_TRACE4(( " get\n" ));

                    idx = cf2_stack_popInt( opStack );

                    if ( idx >= 0 && idx < CF2_STORAGE_SIZE )
                      cf2_stack_pushFixed( opStack, storage[idx] );
                  }
                  continue; /* do not clear the stack */

                case cf2_escIFELSE:
                  {
                    CF2_F16Dot16  arg1;
                    CF2_F16Dot16  arg2;
                    CF2_F16Dot16  cond1;
                    CF2_F16Dot16  cond2;


                    FT_TRACE4(( " ifelse\n" ));

                    cond2 = cf2_stack_popFixed( opStack );
                    cond1 = cf2_stack_popFixed( opStack );
                    arg2  = cf2_stack_popFixed( opStack );
                    arg1  = cf2_stack_popFixed( opStack );

                    cf2_stack_pushFixed( opStack, cond1 <= cond2 ? arg1 : arg2 );
                  }
                  continue; /* do not clear the stack */

                case cf2_escRANDOM: /* in spec */
                  FT_TRACE4(( " random\n" ));

                  CF2_FIXME;
                  break;

                case cf2_escMUL:
                  {
                    CF2_F16Dot16  factor1;
                    CF2_F16Dot16  factor2;


                    FT_TRACE4(( " mul\n" ));

                    factor2 = cf2_stack_popFixed( opStack );
                    factor1 = cf2_stack_popFixed( opStack );

                    cf2_stack_pushFixed( opStack, FT_MulFix( factor1, factor2 ) );
                  }
                  continue; /* do not clear the stack */

                case cf2_escSQRT:
                  {
                    CF2_F16Dot16  arg;


                    FT_TRACE4(( " sqrt\n" ));

                    arg = cf2_stack_popFixed( opStack );
                    if ( arg > 0 )
                    {
                      FT_Fixed  root = arg;
                      FT_Fixed  new_root;


                      /* Babylonian method */
                      for (;;)
                      {
                        new_root = ( root + FT_DivFix( arg, root ) + 1 ) >> 1;
                        if ( new_root == root )
                          break;
                        root = new_root;
                      }
                      arg = new_root;
                    }
                    else
                      arg = 0;

                    cf2_stack_pushFixed( opStack, arg );
                  }
                  continue; /* do not clear the stack */

                case cf2_escDUP:
                  {
                    CF2_F16Dot16  arg;


                    FT_TRACE4(( " dup\n" ));

                    arg = cf2_stack_popFixed( opStack );

                    cf2_stack_pushFixed( opStack, arg );
                    cf2_stack_pushFixed( opStack, arg );
                  }
                  continue; /* do not clear the stack */

                case cf2_escEXCH:
                  {
                    CF2_F16Dot16  arg1;
                    CF2_F16Dot16  arg2;


                    FT_TRACE4(( " exch\n" ));

                    arg2 = cf2_stack_popFixed( opStack );
                    arg1 = cf2_stack_popFixed( opStack );

                    cf2_stack_pushFixed( opStack, arg2 );
                    cf2_stack_pushFixed( opStack, arg1 );
                  }
                  continue; /* do not clear the stack */

                case cf2_escINDEX:
                  {
                    CF2_Int   idx;
                    CF2_UInt  size;


                    FT_TRACE4(( " index\n" ));

                    idx  = cf2_stack_popInt( opStack );
                    size = cf2_stack_count( opStack );

                    if ( size > 0 )
                    {
                      /* for `cf2_stack_getReal', index 0 is bottom of stack */
                      CF2_UInt  gr_idx;


                      if ( idx < 0 )
                        gr_idx = size - 1;
                      else if ( (CF2_UInt)idx >= size )
                        gr_idx = 0;
                      else
                        gr_idx = size - 1 - (CF2_UInt)idx;

                      cf2_stack_pushFixed( opStack,
                                           cf2_stack_getReal( opStack, gr_idx ) );
                    }
                  }
                  continue; /* do not clear the stack */

                case cf2_escROLL:
                  {
                    CF2_Int  idx;
                    CF2_Int  count;


                    FT_TRACE4(( " roll\n" ));

                    idx   = cf2_stack_popInt( opStack );
                    count = cf2_stack_popInt( opStack );

                    cf2_stack_roll( opStack, count, idx );
                  }
                  continue; /* do not clear the stack */

                } /* end of 2nd switch checking op2 */
              }
            }
          } /* end of 1st switch checking op2 */
        } /* case cf2_cmdESC */

        break;

      case cf2_cmdENDCHAR:
        FT_TRACE4(( " endchar\n" ));

        if ( cf2_stack_count( opStack ) == 1 ||
             cf2_stack_count( opStack ) == 5 )
        {
          if ( !haveWidth )
            *width = cf2_stack_getReal( opStack, 0 ) + nominalWidthX;
        }

        /* width is defined or default after this */
        haveWidth = TRUE;

        if ( font->decoder->width_only )
          goto exit;

        /* close path if still open */
        cf2_glyphpath_closeOpenPath( &glyphPath );

        /* disable seac for CFF2 (charstring ending with args on stack) */
        if ( !font->isCFF2 && cf2_stack_count( opStack ) > 1 )
        {
          /* must be either 4 or 5 --                       */
          /* this is a (deprecated) implied `seac' operator */

          CF2_Int        achar;
          CF2_Int        bchar;
          CF2_BufferRec  component;
          CF2_Fixed      dummyWidth;   /* ignore component width */
          FT_Error       error2;


          if ( doingSeac )
          {
            lastError = FT_THROW( Invalid_Glyph_Format );
            goto exit;      /* nested seac */
          }

          achar = cf2_stack_popInt( opStack );
          bchar = cf2_stack_popInt( opStack );

          curY = cf2_stack_popFixed( opStack );
          curX = cf2_stack_popFixed( opStack );

          error2 = cf2_getSeacComponent( decoder, achar, &component );
          if ( error2 )
          {
            lastError = error2;      /* pass FreeType error through */
            goto exit;
          }
          cf2_interpT2CharString( font,
                                  &component,
                                  callbacks,
                                  translation,
                                  TRUE,
                                  curX,
                                  curY,
                                  &dummyWidth );
          cf2_freeSeacComponent( decoder, &component );

          error2 = cf2_getSeacComponent( decoder, bchar, &component );
          if ( error2 )
          {
            lastError = error2;      /* pass FreeType error through */
            goto exit;
          }
          cf2_interpT2CharString( font,
                                  &component,
                                  callbacks,
                                  translation,
                                  TRUE,
                                  0,
                                  0,
                                  &dummyWidth );
          cf2_freeSeacComponent( decoder, &component );
        }
        goto exit;

      case cf2_cmdCNTRMASK:
      case cf2_cmdHINTMASK:
        /* the final \n in the tracing message gets added in      */
        /* `cf2_hintmask_read' (which also traces the mask bytes) */
        FT_TRACE4(( op1 == cf2_cmdCNTRMASK ? " cntrmask" : " hintmask" ));

        /* never add hints after the mask is computed */
        if ( cf2_stack_count( opStack ) > 1    &&
             cf2_hintmask_isValid( &hintMask ) )
        {
          FT_TRACE4(( "cf2_interpT2CharString: invalid hint mask\n" ));
          break;
        }

        /* if there are arguments on the stack, there this is an */
        /* implied cf2_cmdVSTEMHM                                */
        cf2_doStems( font,
                     opStack,
                     &vStemHintArray,
                     width,
                     &haveWidth,
                     0 );

        if ( font->decoder->width_only )
          goto exit;

        if ( op1 == cf2_cmdHINTMASK )
        {
          /* consume the hint mask bytes which follow the operator */
          cf2_hintmask_read( &hintMask,
                             charstring,
                             cf2_arrstack_size( &hStemHintArray ) +
                               cf2_arrstack_size( &vStemHintArray ) );
        }
        else
        {
          /*
           * Consume the counter mask bytes which follow the operator:
           * Build a temporary hint map, just to place and lock those
           * stems participating in the counter mask.  These are most
           * likely the dominant hstems, and are grouped together in a
           * few counter groups, not necessarily in correspondence
           * with the hint groups.  This reduces the chances of
           * conflicts between hstems that are initially placed in
           * separate hint groups and then brought together.  The
           * positions are copied back to `hStemHintArray', so we can
           * discard `counterMask' and `counterHintMap'.
           *
           */
          CF2_HintMapRec   counterHintMap;
          CF2_HintMaskRec  counterMask;


          cf2_hintmap_init( &counterHintMap,
                            font,
                            &glyphPath.initialHintMap,
                            &glyphPath.hintMoves,
                            scaleY );
          cf2_hintmask_init( &counterMask, error );

          cf2_hintmask_read( &counterMask,
                             charstring,
                             cf2_arrstack_size( &hStemHintArray ) +
                               cf2_arrstack_size( &vStemHintArray ) );
          cf2_hintmap_build( &counterHintMap,
                             &hStemHintArray,
                             &vStemHintArray,
                             &counterMask,
                             0,
                             FALSE );
        }
        break;

      case cf2_cmdRMOVETO:
        FT_TRACE4(( " rmoveto\n" ));

        if ( cf2_stack_count( opStack ) > 2 && !haveWidth )
          *width = cf2_stack_getReal( opStack, 0 ) + nominalWidthX;

        /* width is defined or default after this */
        haveWidth = TRUE;

        if ( font->decoder->width_only )
          goto exit;

        curY += cf2_stack_popFixed( opStack );
        curX += cf2_stack_popFixed( opStack );

        cf2_glyphpath_moveTo( &glyphPath, curX, curY );

        break;

      case cf2_cmdHMOVETO:
        FT_TRACE4(( " hmoveto\n" ));

        if ( cf2_stack_count( opStack ) > 1 && !haveWidth )
          *width = cf2_stack_getReal( opStack, 0 ) + nominalWidthX;

        /* width is defined or default after this */
        haveWidth = TRUE;

        if ( font->decoder->width_only )
          goto exit;

        curX += cf2_stack_popFixed( opStack );

        cf2_glyphpath_moveTo( &glyphPath, curX, curY );

        break;

      case cf2_cmdRLINECURVE:
        {
          CF2_UInt  count = cf2_stack_count( opStack );
          CF2_UInt  index = 0;


          FT_TRACE4(( " rlinecurve\n" ));

          while ( index + 6 < count )
          {
            curX += cf2_stack_getReal( opStack, index + 0 );
            curY += cf2_stack_getReal( opStack, index + 1 );

            cf2_glyphpath_lineTo( &glyphPath, curX, curY );
            index += 2;
          }

          while ( index < count )
          {
            CF2_Fixed  x1 = cf2_stack_getReal( opStack, index + 0 ) + curX;
            CF2_Fixed  y1 = cf2_stack_getReal( opStack, index + 1 ) + curY;
            CF2_Fixed  x2 = cf2_stack_getReal( opStack, index + 2 ) + x1;
            CF2_Fixed  y2 = cf2_stack_getReal( opStack, index + 3 ) + y1;
            CF2_Fixed  x3 = cf2_stack_getReal( opStack, index + 4 ) + x2;
            CF2_Fixed  y3 = cf2_stack_getReal( opStack, index + 5 ) + y2;


            cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );

            curX   = x3;
            curY   = y3;
            index += 6;
          }

          cf2_stack_clear( opStack );
        }
        continue; /* no need to clear stack again */

      case cf2_cmdVVCURVETO:
        {
          CF2_UInt  count, count1 = cf2_stack_count( opStack );
          CF2_UInt  index = 0;


          /* if `cf2_stack_count' isn't of the form 4n or 4n+1, */
          /* we enforce it by clearing the second bit           */
          /* (and sorting the stack indexing to suit)           */
          count  = count1 & ~2U;
          index += count1 - count;

          FT_TRACE4(( " vvcurveto\n" ));

          while ( index < count )
          {
            CF2_Fixed  x1, y1, x2, y2, x3, y3;


            if ( ( count - index ) & 1 )
            {
              x1 = cf2_stack_getReal( opStack, index ) + curX;

              index++;
            }
            else
              x1 = curX;

            y1 = cf2_stack_getReal( opStack, index + 0 ) + curY;
            x2 = cf2_stack_getReal( opStack, index + 1 ) + x1;
            y2 = cf2_stack_getReal( opStack, index + 2 ) + y1;
            x3 = x2;
            y3 = cf2_stack_getReal( opStack, index + 3 ) + y2;

            cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );

            curX   = x3;
            curY   = y3;
            index += 4;
          }

          cf2_stack_clear( opStack );
        }
        continue; /* no need to clear stack again */

      case cf2_cmdHHCURVETO:
        {
          CF2_UInt  count, count1 = cf2_stack_count( opStack );
          CF2_UInt  index = 0;


          /* if `cf2_stack_count' isn't of the form 4n or 4n+1, */
          /* we enforce it by clearing the second bit           */
          /* (and sorting the stack indexing to suit)           */
          count  = count1 & ~2U;
          index += count1 - count;

          FT_TRACE4(( " hhcurveto\n" ));

          while ( index < count )
          {
            CF2_Fixed  x1, y1, x2, y2, x3, y3;


            if ( ( count - index ) & 1 )
            {
              y1 = cf2_stack_getReal( opStack, index ) + curY;

              index++;
            }
            else
              y1 = curY;

            x1 = cf2_stack_getReal( opStack, index + 0 ) + curX;
            x2 = cf2_stack_getReal( opStack, index + 1 ) + x1;
            y2 = cf2_stack_getReal( opStack, index + 2 ) + y1;
            x3 = cf2_stack_getReal( opStack, index + 3 ) + x2;
            y3 = y2;

            cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );

            curX   = x3;
            curY   = y3;
            index += 4;
          }

          cf2_stack_clear( opStack );
        }
        continue; /* no need to clear stack again */

      case cf2_cmdVHCURVETO:
      case cf2_cmdHVCURVETO:
        {
          CF2_UInt  count, count1 = cf2_stack_count( opStack );
          CF2_UInt  index = 0;

          FT_Bool  alternate = FT_BOOL( op1 == cf2_cmdHVCURVETO );


          /* if `cf2_stack_count' isn't of the form 8n, 8n+1, */
          /* 8n+4, or 8n+5, we enforce it by clearing the     */
          /* second bit                                       */
          /* (and sorting the stack indexing to suit)         */
          count  = count1 & ~2U;
          index += count1 - count;

          FT_TRACE4(( alternate ? " hvcurveto\n" : " vhcurveto\n" ));

          while ( index < count )
          {
            CF2_Fixed x1, x2, x3, y1, y2, y3;


            if ( alternate )
            {
              x1 = cf2_stack_getReal( opStack, index + 0 ) + curX;
              y1 = curY;
              x2 = cf2_stack_getReal( opStack, index + 1 ) + x1;
              y2 = cf2_stack_getReal( opStack, index + 2 ) + y1;
              y3 = cf2_stack_getReal( opStack, index + 3 ) + y2;

              if ( count - index == 5 )
              {
                x3 = cf2_stack_getReal( opStack, index + 4 ) + x2;

                index++;
              }
              else
                x3 = x2;

              alternate = FALSE;
            }
            else
            {
              x1 = curX;
              y1 = cf2_stack_getReal( opStack, index + 0 ) + curY;
              x2 = cf2_stack_getReal( opStack, index + 1 ) + x1;
              y2 = cf2_stack_getReal( opStack, index + 2 ) + y1;
              x3 = cf2_stack_getReal( opStack, index + 3 ) + x2;

              if ( count - index == 5 )
              {
                y3 = cf2_stack_getReal( opStack, index + 4 ) + y2;

                index++;
              }
              else
                y3 = y2;

              alternate = TRUE;
            }

            cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );

            curX   = x3;
            curY   = y3;
            index += 4;
          }

          cf2_stack_clear( opStack );
        }
        continue;     /* no need to clear stack again */

      case cf2_cmdEXTENDEDNMBR:
        {
          CF2_Int  v;

          CF2_Int  byte1 = cf2_buf_readByte( charstring );
          CF2_Int  byte2 = cf2_buf_readByte( charstring );


          v = (FT_Short)( ( byte1 << 8 ) |
                            byte2        );

          FT_TRACE4(( " %d", v ));

          cf2_stack_pushInt( opStack, v );
        }
        continue;

      default:
        /* numbers */
        {
          if ( /* op1 >= 32 && */ op1 <= 246 )
          {
            CF2_Int  v;


            v = op1 - 139;

            FT_TRACE4(( " %d", v ));

            /* -107 .. 107 */
            cf2_stack_pushInt( opStack, v );
          }

          else if ( /* op1 >= 247 && */ op1 <= 250 )
          {
            CF2_Int  v;


            v  = op1;
            v -= 247;
            v *= 256;
            v += cf2_buf_readByte( charstring );
            v += 108;

            FT_TRACE4(( " %d", v ));

            /* 108 .. 1131 */
            cf2_stack_pushInt( opStack, v );
          }

          else if ( /* op1 >= 251 && */ op1 <= 254 )
          {
            CF2_Int  v;


            v  = op1;
            v -= 251;
            v *= 256;
            v += cf2_buf_readByte( charstring );
            v  = -v - 108;

            FT_TRACE4(( " %d", v ));

            /* -1131 .. -108 */
            cf2_stack_pushInt( opStack, v );
          }

          else /* op1 == 255 */
          {
            CF2_Fixed  v;

            FT_UInt32  byte1 = (FT_UInt32)cf2_buf_readByte( charstring );
            FT_UInt32  byte2 = (FT_UInt32)cf2_buf_readByte( charstring );
            FT_UInt32  byte3 = (FT_UInt32)cf2_buf_readByte( charstring );
            FT_UInt32  byte4 = (FT_UInt32)cf2_buf_readByte( charstring );


            v = (CF2_Fixed)( ( byte1 << 24 ) |
                             ( byte2 << 16 ) |
                             ( byte3 <<  8 ) |
                               byte4         );

            FT_TRACE4(( " %.5f", v / 65536.0 ));

            cf2_stack_pushFixed( opStack, v );
          }
        }
        continue;   /* don't clear stack */

      } /* end of switch statement checking `op1' */

      cf2_stack_clear( opStack );

    } /* end of main interpreter loop */

    /* we get here if the charstring ends without cf2_cmdENDCHAR */
    FT_TRACE4(( "cf2_interpT2CharString:"
                "  charstring ends without ENDCHAR\n" ));

  exit:
    /* check whether last error seen is also the first one */
    cf2_setError( error, lastError );

    if ( *error )
      FT_TRACE4(( "charstring error %d\n", *error ));

    /* free resources from objects we've used */
    cf2_glyphpath_finalize( &glyphPath );
    cf2_arrstack_finalize( &vStemHintArray );
    cf2_arrstack_finalize( &hStemHintArray );
    cf2_arrstack_finalize( &subrStack );
    cf2_stack_free( opStack );

    FT_TRACE4(( "\n" ));

    return;
  }


/* END */
@


1.8
log
@
Update to FreeType 2.7

Now Subpixel hinting, also known as ClearType hinting, is enabled
by default.

OK matthieu@@
@
text
@d50 2
d220 2
a221 2
    cf2_cmdRESERVED_15,  /* 15 */
    cf2_cmdRESERVED_16,  /* 16 */
d278 2
a279 1
    cf2_escFLEX1         /* 37 */
d350 1
a350 1
    isHFlex = readFromStack[9] == FALSE;
d409 37
d488 1
d564 2
d567 1
a567 1
    haveWidth = FALSE;
d571 3
a573 3
     * Note: at this point, all pointers to resources must be NULL
     * and all local objects must be initialized.
     * There must be no branches to exit: above this point.
d578 4
a581 1
    opStack = cf2_stack_init( memory, error );
d610 1
d617 1
d620 7
a643 2
      case cf2_cmdRESERVED_15:
      case cf2_cmdRESERVED_16:
d649 67
d808 1
a808 1
          FT_Bool  isX = op1 == cf2_cmdHLINETO;
d953 2
d957 11
a967 3
          case cf2_escDOTSECTION:
            /* something about `flip type of locking' -- ignore it */
            FT_TRACE4(( " dotsection\n" ));
a968 1
            break;
d970 12
a981 1
          case cf2_escAND:
d983 9
a991 2
              CF2_F16Dot16  arg1;
              CF2_F16Dot16  arg2;
d994 1
a994 1
              FT_TRACE4(( " and\n" ));
d996 6
a1001 4
              arg2 = cf2_stack_popFixed( opStack );
              arg1 = cf2_stack_popFixed( opStack );

              cf2_stack_pushInt( opStack, arg1 && arg2 );
d1003 1
a1003 1
            continue; /* do not clear the stack */
d1005 1
a1005 1
          case cf2_escOR:
d1007 9
a1015 2
              CF2_F16Dot16  arg1;
              CF2_F16Dot16  arg2;
d1018 1
a1018 1
              FT_TRACE4(( " or\n" ));
d1020 6
a1025 4
              arg2 = cf2_stack_popFixed( opStack );
              arg1 = cf2_stack_popFixed( opStack );

              cf2_stack_pushInt( opStack, arg1 || arg2 );
d1027 1
a1027 1
            continue; /* do not clear the stack */
d1029 1
a1029 1
          case cf2_escNOT:
d1031 9
a1039 1
              CF2_F16Dot16  arg;
d1042 1
a1042 1
              FT_TRACE4(( " not\n" ));
d1044 8
a1051 1
              arg = cf2_stack_popFixed( opStack );
d1053 16
a1068 3
              cf2_stack_pushInt( opStack, !arg );
            }
            continue; /* do not clear the stack */
d1070 1
a1070 1
          case cf2_escABS:
d1072 7
a1078 1
              CF2_F16Dot16  arg;
d1080 3
d1084 1
a1084 1
              FT_TRACE4(( " abs\n" ));
d1086 4
a1089 1
              arg = cf2_stack_popFixed( opStack );
a1090 3
              cf2_stack_pushFixed( opStack, FT_ABS( arg ) );
            }
            continue; /* do not clear the stack */
d1092 1
a1092 4
          case cf2_escADD:
            {
              CF2_F16Dot16  summand1;
              CF2_F16Dot16  summand2;
d1094 2
d1097 3
a1099 1
              FT_TRACE4(( " add\n" ));
d1101 4
a1104 2
              summand2 = cf2_stack_popFixed( opStack );
              summand1 = cf2_stack_popFixed( opStack );
a1105 3
              cf2_stack_pushFixed( opStack, summand1 + summand2 );
            }
            continue; /* do not clear the stack */
d1107 1
a1107 4
          case cf2_escSUB:
            {
              CF2_F16Dot16  minuend;
              CF2_F16Dot16  subtrahend;
d1109 2
d1112 3
a1114 1
              FT_TRACE4(( " sub\n" ));
d1116 3
a1118 2
              subtrahend = cf2_stack_popFixed( opStack );
              minuend    = cf2_stack_popFixed( opStack );
a1119 3
              cf2_stack_pushFixed( opStack, minuend - subtrahend );
            }
            continue; /* do not clear the stack */
d1121 1
a1121 4
          case cf2_escDIV:
            {
              CF2_F16Dot16  dividend;
              CF2_F16Dot16  divisor;
d1123 1
d1125 3
a1127 1
              FT_TRACE4(( " div\n" ));
d1129 3
a1131 2
              divisor  = cf2_stack_popFixed( opStack );
              dividend = cf2_stack_popFixed( opStack );
a1132 3
              cf2_stack_pushFixed( opStack, FT_DivFix( dividend, divisor ) );
            }
            continue; /* do not clear the stack */
d1134 1
a1134 3
          case cf2_escNEG:
            {
              CF2_F16Dot16  arg;
d1136 1
d1138 3
a1140 1
              FT_TRACE4(( " neg\n" ));
d1142 4
a1145 1
              arg = cf2_stack_popFixed( opStack );
a1146 3
              cf2_stack_pushFixed( opStack, -arg );
            }
            continue; /* do not clear the stack */
d1148 1
a1148 4
          case cf2_escEQ:
            {
              CF2_F16Dot16  arg1;
              CF2_F16Dot16  arg2;
d1150 2
d1153 3
a1155 1
              FT_TRACE4(( " eq\n" ));
d1157 4
a1160 2
              arg2 = cf2_stack_popFixed( opStack );
              arg1 = cf2_stack_popFixed( opStack );
a1161 3
              cf2_stack_pushInt( opStack, arg1 == arg2 );
            }
            continue; /* do not clear the stack */
d1163 1
a1163 2
          case cf2_escDROP:
            FT_TRACE4(( " drop\n" ));
d1165 2
a1166 2
            (void)cf2_stack_popFixed( opStack );
            continue; /* do not clear the stack */
d1168 3
a1170 4
          case cf2_escPUT:
            {
              CF2_F16Dot16  val;
              CF2_Int       idx;
d1172 4
a1176 1
              FT_TRACE4(( " put\n" ));
d1178 1
a1178 2
              idx = cf2_stack_popInt( opStack );
              val = cf2_stack_popFixed( opStack );
d1180 2
a1181 4
              if ( idx >= 0 && idx < CF2_STORAGE_SIZE )
                storage[idx] = val;
            }
            continue; /* do not clear the stack */
d1183 3
a1185 3
          case cf2_escGET:
            {
              CF2_Int  idx;
d1187 3
a1190 1
              FT_TRACE4(( " get\n" ));
d1192 1
a1192 1
              idx = cf2_stack_popInt( opStack );
d1194 1
a1194 4
              if ( idx >= 0 && idx < CF2_STORAGE_SIZE )
                cf2_stack_pushFixed( opStack, storage[idx] );
            }
            continue; /* do not clear the stack */
d1196 3
a1198 6
          case cf2_escIFELSE:
            {
              CF2_F16Dot16  arg1;
              CF2_F16Dot16  arg2;
              CF2_F16Dot16  cond1;
              CF2_F16Dot16  cond2;
d1200 4
a1204 1
              FT_TRACE4(( " ifelse\n" ));
d1206 1
a1206 4
              cond2 = cf2_stack_popFixed( opStack );
              cond1 = cf2_stack_popFixed( opStack );
              arg2  = cf2_stack_popFixed( opStack );
              arg1  = cf2_stack_popFixed( opStack );
d1208 2
a1209 3
              cf2_stack_pushFixed( opStack, cond1 <= cond2 ? arg1 : arg2 );
            }
            continue; /* do not clear the stack */
d1211 3
a1213 2
          case cf2_escRANDOM: /* in spec */
            FT_TRACE4(( " random\n" ));
d1215 2
a1216 2
            CF2_FIXME;
            break;
d1218 2
a1219 4
          case cf2_escMUL:
            {
              CF2_F16Dot16  factor1;
              CF2_F16Dot16  factor2;
d1221 4
a1225 1
              FT_TRACE4(( " mul\n" ));
d1227 1
a1227 2
              factor2 = cf2_stack_popFixed( opStack );
              factor1 = cf2_stack_popFixed( opStack );
d1229 2
a1230 3
              cf2_stack_pushFixed( opStack, FT_MulFix( factor1, factor2 ) );
            }
            continue; /* do not clear the stack */
d1232 4
a1235 3
          case cf2_escSQRT:
            {
              CF2_F16Dot16  arg;
d1237 3
a1240 1
              FT_TRACE4(( " sqrt\n" ));
d1242 1
a1242 5
              arg = cf2_stack_popFixed( opStack );
              if ( arg > 0 )
              {
                FT_Fixed  root = arg;
                FT_Fixed  new_root;
d1244 1
d1246 4
a1249 12
                /* Babylonian method */
                for (;;)
                {
                  new_root = ( root + FT_DivFix( arg, root ) + 1 ) >> 1;
                  if ( new_root == root )
                    break;
                  root = new_root;
                }
                arg = new_root;
              }
              else
                arg = 0;
d1251 6
a1256 3
              cf2_stack_pushFixed( opStack, arg );
            }
            continue; /* do not clear the stack */
a1257 3
          case cf2_escDUP:
            {
              CF2_F16Dot16  arg;
d1259 1
d1261 4
a1264 1
              FT_TRACE4(( " dup\n" ));
d1266 3
a1268 1
              arg = cf2_stack_popFixed( opStack );
d1270 2
a1271 4
              cf2_stack_pushFixed( opStack, arg );
              cf2_stack_pushFixed( opStack, arg );
            }
            continue; /* do not clear the stack */
d1273 2
a1274 4
          case cf2_escEXCH:
            {
              CF2_F16Dot16  arg1;
              CF2_F16Dot16  arg2;
d1276 4
a1280 1
              FT_TRACE4(( " exch\n" ));
d1282 1
a1282 2
              arg2 = cf2_stack_popFixed( opStack );
              arg1 = cf2_stack_popFixed( opStack );
d1284 2
a1285 4
              cf2_stack_pushFixed( opStack, arg2 );
              cf2_stack_pushFixed( opStack, arg1 );
            }
            continue; /* do not clear the stack */
d1287 3
a1289 4
          case cf2_escINDEX:
            {
              CF2_Int   idx;
              CF2_UInt  size;
d1291 3
a1294 1
              FT_TRACE4(( " index\n" ));
d1296 1
a1296 2
              idx  = cf2_stack_popInt( opStack );
              size = cf2_stack_count( opStack );
d1298 5
a1302 4
              if ( size > 0 )
              {
                /* for `cf2_stack_getReal', index 0 is bottom of stack */
                CF2_UInt  gr_idx;
d1305 12
a1316 6
                if ( idx < 0 )
                  gr_idx = size - 1;
                else if ( (CF2_UInt)idx >= size )
                  gr_idx = 0;
                else
                  gr_idx = size - 1 - (CF2_UInt)idx;
d1318 3
a1320 5
                cf2_stack_pushFixed( opStack,
                                     cf2_stack_getReal( opStack, gr_idx ) );
              }
            }
            continue; /* do not clear the stack */
d1322 3
a1324 4
          case cf2_escROLL:
            {
              CF2_Int  idx;
              CF2_Int  count;
d1327 1
a1327 1
              FT_TRACE4(( " roll\n" ));
d1329 1
a1329 2
              idx   = cf2_stack_popInt( opStack );
              count = cf2_stack_popInt( opStack );
d1331 4
a1334 3
              cf2_stack_roll( opStack, count, idx );
            }
            continue; /* do not clear the stack */
d1336 4
a1339 11
          case cf2_escHFLEX:
            {
              static const FT_Bool  readFromStack[12] =
              {
                TRUE /* dx1 */, FALSE /* dy1 */,
                TRUE /* dx2 */, TRUE  /* dy2 */,
                TRUE /* dx3 */, FALSE /* dy3 */,
                TRUE /* dx4 */, FALSE /* dy4 */,
                TRUE /* dx5 */, FALSE /* dy5 */,
                TRUE /* dx6 */, FALSE /* dy6 */
              };
d1342 1
a1342 1
              FT_TRACE4(( " hflex\n" ));
d1344 2
a1345 8
              cf2_doFlex( opStack,
                          &curX,
                          &curY,
                          &glyphPath,
                          readFromStack,
                          FALSE /* doConditionalLastRead */ );
            }
            continue;
d1347 4
a1350 11
          case cf2_escFLEX:
            {
              static const FT_Bool  readFromStack[12] =
              {
                TRUE /* dx1 */, TRUE /* dy1 */,
                TRUE /* dx2 */, TRUE /* dy2 */,
                TRUE /* dx3 */, TRUE /* dy3 */,
                TRUE /* dx4 */, TRUE /* dy4 */,
                TRUE /* dx5 */, TRUE /* dy5 */,
                TRUE /* dx6 */, TRUE /* dy6 */
              };
d1352 4
a1356 1
              FT_TRACE4(( " flex\n" ));
d1358 1
a1358 8
              cf2_doFlex( opStack,
                          &curX,
                          &curY,
                          &glyphPath,
                          readFromStack,
                          FALSE /* doConditionalLastRead */ );
            }
            break;      /* TODO: why is this not a continue? */
d1360 2
a1361 11
          case cf2_escHFLEX1:
            {
              static const FT_Bool  readFromStack[12] =
              {
                TRUE /* dx1 */, TRUE  /* dy1 */,
                TRUE /* dx2 */, TRUE  /* dy2 */,
                TRUE /* dx3 */, FALSE /* dy3 */,
                TRUE /* dx4 */, FALSE /* dy4 */,
                TRUE /* dx5 */, TRUE  /* dy5 */,
                TRUE /* dx6 */, FALSE /* dy6 */
              };
d1363 4
a1367 1
              FT_TRACE4(( " hflex1\n" ));
d1369 6
a1374 8
              cf2_doFlex( opStack,
                          &curX,
                          &curY,
                          &glyphPath,
                          readFromStack,
                          FALSE /* doConditionalLastRead */ );
            }
            continue;
d1376 5
a1380 11
          case cf2_escFLEX1:
            {
              static const FT_Bool  readFromStack[12] =
              {
                TRUE  /* dx1 */, TRUE  /* dy1 */,
                TRUE  /* dx2 */, TRUE  /* dy2 */,
                TRUE  /* dx3 */, TRUE  /* dy3 */,
                TRUE  /* dx4 */, TRUE  /* dy4 */,
                TRUE  /* dx5 */, TRUE  /* dy5 */,
                FALSE /* dx6 */, FALSE /* dy6 */
              };
d1382 4
a1386 1
              FT_TRACE4(( " flex1\n" ));
d1388 1
a1388 8
              cf2_doFlex( opStack,
                          &curX,
                          &curY,
                          &glyphPath,
                          readFromStack,
                          TRUE /* doConditionalLastRead */ );
            }
            continue;
d1390 2
a1391 15
          case cf2_escRESERVED_1:
          case cf2_escRESERVED_2:
          case cf2_escRESERVED_6:
          case cf2_escRESERVED_7:
          case cf2_escRESERVED_8:
          case cf2_escRESERVED_13:
          case cf2_escRESERVED_16:
          case cf2_escRESERVED_17:
          case cf2_escRESERVED_19:
          case cf2_escRESERVED_25:
          case cf2_escRESERVED_31:
          case cf2_escRESERVED_32:
          case cf2_escRESERVED_33:
          default:
            FT_TRACE4(( " unknown op (12, %d)\n", op2 ));
d1393 3
a1395 1
          }; /* end of switch statement checking `op2' */
d1397 4
d1402 1
d1424 2
a1425 1
        if ( cf2_stack_count( opStack ) > 1 )
d1654 1
a1654 1
              ++index;
d1699 1
a1699 1
              ++index;
d1727 1
a1727 1
          FT_Bool  alternate = op1 == cf2_cmdHVCURVETO;
d1756 1
a1756 1
                ++index;
d1775 1
a1775 1
                ++index;
d1876 1
a1876 1
            FT_TRACE4(( " %.2f", v / 65536.0 ));
d1896 3
@


1.7
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d472 2
@


1.6
log
@
Bugfixing update to freetype-2.6.2

Tested on amd64, i386, macppc, sparc64, loongson and compile-tested
on arm by matthieu@@
Also tested in a ports bulk build by naddy@@

OK matthieu@@
@
text
@d296 2
a297 1
    if ( hasWidthArg && ! *haveWidth )
d450 2
d614 1
a614 1
            goto exit;
d638 1
a638 1
            goto exit;
d652 1
a652 1
            goto exit;
d839 78
a916 3
          /* TODO: should these operators be supported? */
          case cf2_escAND: /* in spec */
            FT_TRACE4(( " and\n" ));
d918 2
a919 2
            CF2_FIXME;
            break;
d921 3
a923 2
          case cf2_escOR: /* in spec */
            FT_TRACE4(( " or\n" ));
d925 4
a928 2
            CF2_FIXME;
            break;
a929 2
          case cf2_escNOT: /* in spec */
            FT_TRACE4(( " not\n" ));
d931 1
a931 2
            CF2_FIXME;
            break;
d933 2
a934 2
          case cf2_escABS: /* in spec */
            FT_TRACE4(( " abs\n" ));
d936 3
a938 2
            CF2_FIXME;
            break;
d940 3
a942 2
          case cf2_escADD: /* in spec */
            FT_TRACE4(( " add\n" ));
a943 2
            CF2_FIXME;
            break;
d945 1
a945 2
          case cf2_escSUB: /* in spec */
            FT_TRACE4(( " sub\n" ));
d947 1
a947 2
            CF2_FIXME;
            break;
d949 3
a951 2
          case cf2_escDIV: /* in spec */
            FT_TRACE4(( " div\n" ));
d953 4
a956 2
            CF2_FIXME;
            break;
a957 2
          case cf2_escNEG: /* in spec */
            FT_TRACE4(( " neg\n" ));
d959 1
a959 2
            CF2_FIXME;
            break;
d961 2
a962 2
          case cf2_escEQ: /* in spec */
            FT_TRACE4(( " eq\n" ));
d964 3
a966 2
            CF2_FIXME;
            break;
d968 1
a968 1
          case cf2_escDROP: /* in spec */
d971 27
a997 2
            CF2_FIXME;
            break;
d999 4
a1002 2
          case cf2_escPUT: /* in spec */
            FT_TRACE4(( " put\n" ));
d1004 6
a1009 2
            CF2_FIXME;
            break;
a1010 2
          case cf2_escGET: /* in spec */
            FT_TRACE4(( " get\n" ));
d1012 1
a1012 2
            CF2_FIXME;
            break;
d1014 4
a1017 2
          case cf2_escIFELSE: /* in spec */
            FT_TRACE4(( " ifelse\n" ));
d1019 3
a1021 2
            CF2_FIXME;
            break;
d1029 54
a1082 2
          case cf2_escMUL: /* in spec */
            FT_TRACE4(( " mul\n" ));
d1084 25
a1108 2
            CF2_FIXME;
            break;
a1109 2
          case cf2_escSQRT: /* in spec */
            FT_TRACE4(( " sqrt\n" ));
d1111 1
a1111 2
            CF2_FIXME;
            break;
d1113 7
a1119 2
          case cf2_escDUP: /* in spec */
            FT_TRACE4(( " dup\n" ));
a1120 2
            CF2_FIXME;
            break;
d1122 6
a1127 2
          case cf2_escEXCH: /* in spec */
            FT_TRACE4(( " exch\n" ));
d1129 10
a1138 2
            CF2_FIXME;
            break;
a1139 2
          case cf2_escINDEX: /* in spec */
            FT_TRACE4(( " index\n" ));
d1141 1
a1141 2
            CF2_FIXME;
            break;
d1143 2
a1144 2
          case cf2_escROLL: /* in spec */
            FT_TRACE4(( " roll\n" ));
d1146 3
a1148 2
            CF2_FIXME;
            break;
d1281 1
a1281 1
            goto exit;
d1313 2
a1314 2
             lastError = error2;      /* pass FreeType error through */
             goto exit;
d1368 1
a1368 1
            goto exit;
d1427 1
a1427 1
            goto exit;
d1446 1
a1446 1
            goto exit;
d1659 2
d1662 3
a1664 2
          v = (FT_Short)( ( cf2_buf_readByte( charstring ) << 8 ) |
                            cf2_buf_readByte( charstring )        );
d1726 5
d1732 4
a1735 5
            v = (CF2_Fixed)
                  ( ( (FT_UInt32)cf2_buf_readByte( charstring ) << 24 ) |
                    ( (FT_UInt32)cf2_buf_readByte( charstring ) << 16 ) |
                    ( (FT_UInt32)cf2_buf_readByte( charstring ) <<  8 ) |
                      (FT_UInt32)cf2_buf_readByte( charstring )         );
@


1.5
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@d187 1
a187 1
    FT_ASSERT( hintmask->byteCount <
d749 1
a749 1
          CF2_UInt  subrIndex;
d769 1
a769 1
          subrIndex = (CF2_UInt)cf2_stack_popInt( opStack );
d775 1
a775 1
                        subrIndex + (CF2_UInt)decoder->globals_bias,
d779 1
a779 1
                                             subrIndex,
d790 1
a790 1
                        subrIndex + (CF2_UInt)decoder->locals_bias,
d794 1
a794 1
                                            subrIndex,
@


1.4
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d1308 1
a1308 1
          count  = count1 & ~2;
d1353 1
a1353 1
          count  = count1 & ~2;
d1402 1
a1402 1
          count  = count1 & ~2;
@


1.3
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d46 1
d764 3
a766 2
                         cf2_arrstack_getPointer( &subrStack,
                                                  charstringIndex + 1 );
d769 1
a769 1
          subrIndex = cf2_stack_popInt( opStack );
d774 3
a776 1
            FT_TRACE4(( "(%d)\n", subrIndex + decoder->globals_bias ));
d789 3
a791 1
            FT_TRACE4(( "(%d)\n", subrIndex + decoder->locals_bias ));
d807 1
a807 1
        FT_TRACE4(( " return\n" ));
d818 3
a820 2
                       cf2_arrstack_getPointer( &subrStack,
                                                --charstringIndex );
d1098 2
a1099 2
          CF2_UInt       achar;
          CF2_UInt       bchar;
d1301 1
a1301 1
          CF2_UInt  count = cf2_stack_count( opStack );
d1305 6
d1346 1
a1346 1
          CF2_UInt  count = cf2_stack_count( opStack );
d1350 6
d1392 1
a1392 1
          CF2_UInt  count = cf2_stack_count( opStack );
d1397 7
@


1.2
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@d7 1
a7 1
/*  Copyright 2007-2013 Adobe Systems Incorporated.                        */
d596 1
d599 2
d620 1
d623 2
d1150 3
a1152 3
        /* if there are arguments on the stack, there this is an */
        /* implied cf2_cmdVSTEMHM                                */
        if ( cf2_stack_count( opStack ) != 0 )
d1154 2
a1155 3
          /* never add hints after the mask is computed */
          if ( cf2_hintmask_isValid( &hintMask ) )
            FT_TRACE4(( "cf2_interpT2CharString: invalid hint mask\n" ));
d1158 2
@


1.2.2.1
log
@backport fixes for malformed fonts from freetype 2.5.5.
fixes dug out of ubuntu by dcoppa@@
@
text
@a595 1
        {
a597 2
          break;
        }
a616 1
        {
a618 2
          break;
        }
d1144 3
a1146 3
        /* never add hints after the mask is computed */
        if ( cf2_stack_count( opStack ) > 1    &&
             cf2_hintmask_isValid( &hintMask ) )
d1148 3
a1150 2
          FT_TRACE4(( "cf2_interpT2CharString: invalid hint mask\n" ));
          break;
a1152 2
        /* if there are arguments on the stack, there this is an */
        /* implied cf2_cmdVSTEMHM                                */
@


1.2.4.1
log
@backport fixes from freetype 2.5.5 for malformed fonts.
fixes dug out of ubuntu by dcoppa@@
@
text
@a595 1
        {
a597 2
          break;
        }
a616 1
        {
a618 2
          break;
        }
d1144 3
a1146 3
        /* never add hints after the mask is computed */
        if ( cf2_stack_count( opStack ) > 1    &&
             cf2_hintmask_isValid( &hintMask ) )
d1148 3
a1150 2
          FT_TRACE4(( "cf2_interpT2CharString: invalid hint mask\n" ));
          break;
a1152 2
        /* if there are arguments on the stack, there this is an */
        /* implied cf2_cmdVSTEMHM                                */
@


1.1
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@d290 1
a290 1
    FT_Bool   hasWidthArg = count & 1;
d295 6
d309 1
a309 1
      position     += cf2_stack_getReal( opStack, i );
d311 1
a311 1
      position     += cf2_stack_getReal( opStack, i + 1 );
d320 1
a320 3
    if ( hasWidthArg && ! *haveWidth )
      *width = cf2_stack_getReal( opStack, 0 ) +
                 cf2_getNominalWidthX( font->decoder );
d322 2
a324 2

    cf2_stack_clear( opStack );
d360 2
a361 2
      FT_Bool    lastIsX = cf2_fixedAbs( vals[10] - *curX ) >
                             cf2_fixedAbs( vals[11] - *curY );
d514 3
d605 4
d626 4
d635 9
a647 4
        if ( cf2_stack_count( opStack ) > 0 && !haveWidth )
          *width = cf2_stack_popFixed( opStack ) + nominalWidthX;

        haveWidth = TRUE;
d812 1
a812 1
          FT_Byte  op2 = cf2_buf_readByte( charstring );
d1071 1
d1074 3
d1160 3
d1213 9
a1226 4
        if ( cf2_stack_count( opStack ) > 0 && !haveWidth )
          *width = cf2_stack_popFixed( opStack ) + nominalWidthX;

        haveWidth = TRUE;
d1232 9
a1244 4
        if ( cf2_stack_count( opStack ) > 0 && !haveWidth )
          *width = cf2_stack_popFixed( opStack ) + nominalWidthX;

        haveWidth = TRUE;
@

