head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.2
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.23.0.2
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.18.0.2
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.2
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.2
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2017.06.23.16.15.19;	author dcoppa;	state Exp;
branches;
next	1.23;
commitid	nHj0O50aY5QcUcQ4;

1.23
date	2017.01.13.11.19.59;	author dcoppa;	state Exp;
branches;
next	1.22;
commitid	ESXG9TuEmwmBXggf;

1.22
date	2016.08.09.07.16.09;	author dcoppa;	state Exp;
branches;
next	1.21;
commitid	C8TgUUJolulx9B5d;

1.21
date	2016.05.29.11.57.12;	author dcoppa;	state Exp;
branches;
next	1.20;
commitid	1dOLexdOAzW2mQjp;

1.20
date	2015.12.07.09.34.03;	author dcoppa;	state Exp;
branches;
next	1.19;
commitid	wZOPiDmcwgRFTDVL;

1.19
date	2015.10.19.07.51.37;	author dcoppa;	state Exp;
branches;
next	1.18;
commitid	d2XmJCtYff11VIDu;

1.18
date	2015.06.28.08.27.48;	author dcoppa;	state Exp;
branches;
next	1.17;
commitid	qXwIGV2h9uFjxAmt;

1.17
date	2014.12.26.17.52.35;	author dcoppa;	state Exp;
branches;
next	1.16;
commitid	gwhRExMduYqoPQHI;

1.16
date	2014.03.14.08.18.01;	author dcoppa;	state Exp;
branches;
next	1.15;

1.15
date	2014.01.12.15.08.28;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.10.19.49.53;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.07.17.21.09;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.01.04.16.51.58;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.04.14.09.45.47;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.10.30.10.14.51;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.07.18.20.29.58;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.23.19.30.17;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.09.01.19.14.25;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.17.14.06.43;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.25.20.49.54;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.10.20.28.35;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.21.05.09.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.22.17.37.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.44.29;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.44.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.32.17;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.24
log
@
Update to freetype-2.8

No fallout in a bulk build on i386 (sthen@@)

OK matthieu@@, sthen@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  cffobjs.c                                                              */
/*                                                                         */
/*    OpenType objects manager (body).                                     */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>

#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_CALC_H
#include FT_INTERNAL_STREAM_H
#include FT_ERRORS_H
#include FT_TRUETYPE_IDS_H
#include FT_TRUETYPE_TAGS_H
#include FT_INTERNAL_SFNT_H
#include FT_CFF_DRIVER_H

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#include FT_MULTIPLE_MASTERS_H
#include FT_SERVICE_MULTIPLE_MASTERS_H
#endif

#include "cffobjs.h"
#include "cffload.h"
#include "cffcmap.h"
#include "cffpic.h"

#include "cfferrs.h"


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_cffobjs


  /*************************************************************************/
  /*                                                                       */
  /*                            SIZE FUNCTIONS                             */
  /*                                                                       */
  /*************************************************************************/


  static PSH_Globals_Funcs
  cff_size_get_globals_funcs( CFF_Size  size )
  {
    CFF_Face          face     = (CFF_Face)size->root.face;
    CFF_Font          font     = (CFF_Font)face->extra.data;
    PSHinter_Service  pshinter = font->pshinter;
    FT_Module         module;


    module = FT_Get_Module( size->root.face->driver->root.library,
                            "pshinter" );
    return ( module && pshinter && pshinter->get_globals_funcs )
           ? pshinter->get_globals_funcs( module )
           : 0;
  }


  FT_LOCAL_DEF( void )
  cff_size_done( FT_Size  cffsize )        /* CFF_Size */
  {
    FT_Memory     memory   = cffsize->face->memory;
    CFF_Size      size     = (CFF_Size)cffsize;
    CFF_Face      face     = (CFF_Face)size->root.face;
    CFF_Font      font     = (CFF_Font)face->extra.data;
    CFF_Internal  internal = (CFF_Internal)cffsize->internal->module_data;


    if ( internal )
    {
      PSH_Globals_Funcs  funcs;


      funcs = cff_size_get_globals_funcs( size );
      if ( funcs )
      {
        FT_UInt  i;


        funcs->destroy( internal->topfont );

        for ( i = font->num_subfonts; i > 0; i-- )
          funcs->destroy( internal->subfonts[i - 1] );
      }

      FT_FREE( internal );
    }
  }


  /* CFF and Type 1 private dictionaries have slightly different      */
  /* structures; we need to synthesize a Type 1 dictionary on the fly */

  static void
  cff_make_private_dict( CFF_SubFont  subfont,
                         PS_Private   priv )
  {
    CFF_Private  cpriv = &subfont->private_dict;
    FT_UInt      n, count;


    FT_ZERO( priv );

    count = priv->num_blue_values = cpriv->num_blue_values;
    for ( n = 0; n < count; n++ )
      priv->blue_values[n] = (FT_Short)cpriv->blue_values[n];

    count = priv->num_other_blues = cpriv->num_other_blues;
    for ( n = 0; n < count; n++ )
      priv->other_blues[n] = (FT_Short)cpriv->other_blues[n];

    count = priv->num_family_blues = cpriv->num_family_blues;
    for ( n = 0; n < count; n++ )
      priv->family_blues[n] = (FT_Short)cpriv->family_blues[n];

    count = priv->num_family_other_blues = cpriv->num_family_other_blues;
    for ( n = 0; n < count; n++ )
      priv->family_other_blues[n] = (FT_Short)cpriv->family_other_blues[n];

    priv->blue_scale = cpriv->blue_scale;
    priv->blue_shift = (FT_Int)cpriv->blue_shift;
    priv->blue_fuzz  = (FT_Int)cpriv->blue_fuzz;

    priv->standard_width[0]  = (FT_UShort)cpriv->standard_width;
    priv->standard_height[0] = (FT_UShort)cpriv->standard_height;

    count = priv->num_snap_widths = cpriv->num_snap_widths;
    for ( n = 0; n < count; n++ )
      priv->snap_widths[n] = (FT_Short)cpriv->snap_widths[n];

    count = priv->num_snap_heights = cpriv->num_snap_heights;
    for ( n = 0; n < count; n++ )
      priv->snap_heights[n] = (FT_Short)cpriv->snap_heights[n];

    priv->force_bold     = cpriv->force_bold;
    priv->language_group = cpriv->language_group;
    priv->lenIV          = cpriv->lenIV;
  }


  FT_LOCAL_DEF( FT_Error )
  cff_size_init( FT_Size  cffsize )         /* CFF_Size */
  {
    CFF_Size           size  = (CFF_Size)cffsize;
    FT_Error           error = FT_Err_Ok;
    PSH_Globals_Funcs  funcs = cff_size_get_globals_funcs( size );


    if ( funcs )
    {
      CFF_Face      face     = (CFF_Face)cffsize->face;
      CFF_Font      font     = (CFF_Font)face->extra.data;
      CFF_Internal  internal = NULL;

      PS_PrivateRec  priv;
      FT_Memory      memory = cffsize->face->memory;

      FT_UInt  i;


      if ( FT_NEW( internal ) )
        goto Exit;

      cff_make_private_dict( &font->top_font, &priv );
      error = funcs->create( cffsize->face->memory, &priv,
                             &internal->topfont );
      if ( error )
        goto Exit;

      for ( i = font->num_subfonts; i > 0; i-- )
      {
        CFF_SubFont  sub = font->subfonts[i - 1];


        cff_make_private_dict( sub, &priv );
        error = funcs->create( cffsize->face->memory, &priv,
                               &internal->subfonts[i - 1] );
        if ( error )
          goto Exit;
      }

      cffsize->internal->module_data = internal;
    }

    size->strike_index = 0xFFFFFFFFUL;

  Exit:
    return error;
  }


#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

  FT_LOCAL_DEF( FT_Error )
  cff_size_select( FT_Size   size,
                   FT_ULong  strike_index )
  {
    CFF_Size           cffsize = (CFF_Size)size;
    PSH_Globals_Funcs  funcs;


    cffsize->strike_index = strike_index;

    FT_Select_Metrics( size->face, strike_index );

    funcs = cff_size_get_globals_funcs( cffsize );

    if ( funcs )
    {
      CFF_Face      face     = (CFF_Face)size->face;
      CFF_Font      font     = (CFF_Font)face->extra.data;
      CFF_Internal  internal = (CFF_Internal)size->internal->module_data;

      FT_Long  top_upm  = (FT_Long)font->top_font.font_dict.units_per_em;
      FT_UInt  i;


      funcs->set_scale( internal->topfont,
                        size->metrics.x_scale, size->metrics.y_scale,
                        0, 0 );

      for ( i = font->num_subfonts; i > 0; i-- )
      {
        CFF_SubFont  sub     = font->subfonts[i - 1];
        FT_Long      sub_upm = (FT_Long)sub->font_dict.units_per_em;
        FT_Pos       x_scale, y_scale;


        if ( top_upm != sub_upm )
        {
          x_scale = FT_MulDiv( size->metrics.x_scale, top_upm, sub_upm );
          y_scale = FT_MulDiv( size->metrics.y_scale, top_upm, sub_upm );
        }
        else
        {
          x_scale = size->metrics.x_scale;
          y_scale = size->metrics.y_scale;
        }

        funcs->set_scale( internal->subfonts[i - 1],
                          x_scale, y_scale, 0, 0 );
      }
    }

    return FT_Err_Ok;
  }

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */


  FT_LOCAL_DEF( FT_Error )
  cff_size_request( FT_Size          size,
                    FT_Size_Request  req )
  {
    CFF_Size           cffsize = (CFF_Size)size;
    PSH_Globals_Funcs  funcs;


#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

    if ( FT_HAS_FIXED_SIZES( size->face ) )
    {
      CFF_Face      cffface = (CFF_Face)size->face;
      SFNT_Service  sfnt    = (SFNT_Service)cffface->sfnt;
      FT_ULong      strike_index;


      if ( sfnt->set_sbit_strike( cffface, req, &strike_index ) )
        cffsize->strike_index = 0xFFFFFFFFUL;
      else
        return cff_size_select( size, strike_index );
    }

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */

    FT_Request_Metrics( size->face, req );

    funcs = cff_size_get_globals_funcs( cffsize );

    if ( funcs )
    {
      CFF_Face      cffface  = (CFF_Face)size->face;
      CFF_Font      font     = (CFF_Font)cffface->extra.data;
      CFF_Internal  internal = (CFF_Internal)size->internal->module_data;

      FT_Long  top_upm  = (FT_Long)font->top_font.font_dict.units_per_em;
      FT_UInt  i;


      funcs->set_scale( internal->topfont,
                        size->metrics.x_scale, size->metrics.y_scale,
                        0, 0 );

      for ( i = font->num_subfonts; i > 0; i-- )
      {
        CFF_SubFont  sub     = font->subfonts[i - 1];
        FT_Long      sub_upm = (FT_Long)sub->font_dict.units_per_em;
        FT_Pos       x_scale, y_scale;


        if ( top_upm != sub_upm )
        {
          x_scale = FT_MulDiv( size->metrics.x_scale, top_upm, sub_upm );
          y_scale = FT_MulDiv( size->metrics.y_scale, top_upm, sub_upm );
        }
        else
        {
          x_scale = size->metrics.x_scale;
          y_scale = size->metrics.y_scale;
        }

        funcs->set_scale( internal->subfonts[i - 1],
                          x_scale, y_scale, 0, 0 );
      }
    }

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /*                            SLOT  FUNCTIONS                            */
  /*                                                                       */
  /*************************************************************************/

  FT_LOCAL_DEF( void )
  cff_slot_done( FT_GlyphSlot  slot )
  {
    slot->internal->glyph_hints = NULL;
  }


  FT_LOCAL_DEF( FT_Error )
  cff_slot_init( FT_GlyphSlot  slot )
  {
    CFF_Face          face     = (CFF_Face)slot->face;
    CFF_Font          font     = (CFF_Font)face->extra.data;
    PSHinter_Service  pshinter = font->pshinter;


    if ( pshinter )
    {
      FT_Module  module;


      module = FT_Get_Module( slot->face->driver->root.library,
                              "pshinter" );
      if ( module )
      {
        T2_Hints_Funcs  funcs;


        funcs = pshinter->get_t2_funcs( module );
        slot->internal->glyph_hints = (void*)funcs;
      }
    }

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /*                           FACE  FUNCTIONS                             */
  /*                                                                       */
  /*************************************************************************/

  static FT_String*
  cff_strcpy( FT_Memory         memory,
              const FT_String*  source )
  {
    FT_Error    error;
    FT_String*  result;


    (void)FT_STRDUP( result, source );

    FT_UNUSED( error );

    return result;
  }


  /* Strip all subset prefixes of the form `ABCDEF+'.  Usually, there */
  /* is only one, but font names like `APCOOG+JFABTD+FuturaBQ-Bold'   */
  /* have been seen in the wild.                                      */

  static void
  remove_subset_prefix( FT_String*  name )
  {
    FT_Int32  idx             = 0;
    FT_Int32  length          = (FT_Int32)strlen( name ) + 1;
    FT_Bool   continue_search = 1;


    while ( continue_search )
    {
      if ( length >= 7 && name[6] == '+' )
      {
        for ( idx = 0; idx < 6; idx++ )
        {
          /* ASCII uppercase letters */
          if ( !( 'A' <= name[idx] && name[idx] <= 'Z' ) )
            continue_search = 0;
        }

        if ( continue_search )
        {
          for ( idx = 7; idx < length; idx++ )
            name[idx - 7] = name[idx];
          length -= 7;
        }
      }
      else
        continue_search = 0;
    }
  }


  /* Remove the style part from the family name (if present). */

  static void
  remove_style( FT_String*        family_name,
                const FT_String*  style_name )
  {
    FT_Int32  family_name_length, style_name_length;


    family_name_length = (FT_Int32)strlen( family_name );
    style_name_length  = (FT_Int32)strlen( style_name );

    if ( family_name_length > style_name_length )
    {
      FT_Int  idx;


      for ( idx = 1; idx <= style_name_length; idx++ )
      {
        if ( family_name[family_name_length - idx] !=
             style_name[style_name_length - idx] )
          break;
      }

      if ( idx > style_name_length )
      {
        /* family_name ends with style_name; remove it */
        idx = family_name_length - style_name_length - 1;

        /* also remove special characters     */
        /* between real family name and style */
        while ( idx > 0                     &&
                ( family_name[idx] == '-' ||
                  family_name[idx] == ' ' ||
                  family_name[idx] == '_' ||
                  family_name[idx] == '+' ) )
          idx--;

        if ( idx > 0 )
          family_name[idx + 1] = '\0';
      }
    }
  }


  FT_LOCAL_DEF( FT_Error )
  cff_face_init( FT_Stream      stream,
                 FT_Face        cffface,        /* CFF_Face */
                 FT_Int         face_index,
                 FT_Int         num_params,
                 FT_Parameter*  params )
  {
    CFF_Face            face        = (CFF_Face)cffface;
    FT_Error            error;
    SFNT_Service        sfnt;
    FT_Service_PsCMaps  psnames;
    PSHinter_Service    pshinter;
    FT_Bool             pure_cff    = 1;
    FT_Bool             cff2        = 0;
    FT_Bool             sfnt_format = 0;
    FT_Library          library     = cffface->driver->root.library;


    sfnt = (SFNT_Service)FT_Get_Module_Interface(
             library, "sfnt" );
    if ( !sfnt )
    {
      FT_ERROR(( "cff_face_init: cannot access `sfnt' module\n" ));
      error = FT_THROW( Missing_Module );
      goto Exit;
    }

    FT_FACE_FIND_GLOBAL_SERVICE( face, psnames, POSTSCRIPT_CMAPS );

    pshinter = (PSHinter_Service)FT_Get_Module_Interface(
                 library, "pshinter" );

    FT_TRACE2(( "CFF driver\n" ));

    /* create input stream from resource */
    if ( FT_STREAM_SEEK( 0 ) )
      goto Exit;

    /* check whether we have a valid OpenType file */
    FT_TRACE2(( "  " ));
    error = sfnt->init_face( stream, face, face_index, num_params, params );
    if ( !error )
    {
      if ( face->format_tag != TTAG_OTTO )  /* `OTTO'; OpenType/CFF font */
      {
        FT_TRACE2(( "  not an OpenType/CFF font\n" ));
        error = FT_THROW( Unknown_File_Format );
        goto Exit;
      }

      /* if we are performing a simple font format check, exit immediately */
      if ( face_index < 0 )
        return FT_Err_Ok;

      sfnt_format = 1;

      /* now, the font can be either an OpenType/CFF font, or an SVG CEF */
      /* font; in the latter case it doesn't have a `head' table         */
      error = face->goto_table( face, TTAG_head, stream, 0 );
      if ( !error )
      {
        pure_cff = 0;

        /* load font directory */
        error = sfnt->load_face( stream, face, face_index,
                                 num_params, params );
        if ( error )
          goto Exit;
      }
      else
      {
        /* load the `cmap' table explicitly */
        error = sfnt->load_cmap( face, stream );
        if ( error )
          goto Exit;
      }

      /* now load the CFF part of the file; */
      /* give priority to CFF2              */
      error = face->goto_table( face, TTAG_CFF2, stream, 0 );
      if ( !error )
      {
        cff2          = 1;
        face->is_cff2 = cff2;
      }

      if ( FT_ERR_EQ( error, Table_Missing ) )
        error = face->goto_table( face, TTAG_CFF, stream, 0 );

      if ( error )
        goto Exit;
    }
    else
    {
      /* rewind to start of file; we are going to load a pure-CFF font */
      if ( FT_STREAM_SEEK( 0 ) )
        goto Exit;
      error = FT_Err_Ok;
    }

    /* now load and parse the CFF table in the file */
    {
      CFF_Font         cff = NULL;
      CFF_FontRecDict  dict;
      FT_Memory        memory = cffface->memory;
      FT_Int32         flags;
      FT_UInt          i;


      if ( FT_NEW( cff ) )
        goto Exit;

      face->extra.data = cff;
      error = cff_font_load( library,
                             stream,
                             face_index,
                             cff,
                             face,
                             pure_cff,
                             cff2 );
      if ( error )
        goto Exit;

      /* if we are performing a simple font format check, exit immediately */
      /* (this is here for pure CFF)                                       */
      if ( face_index < 0 )
      {
        cffface->num_faces = (FT_Long)cff->num_faces;
        return FT_Err_Ok;
      }

      cff->pshinter = pshinter;
      cff->psnames  = psnames;

      cffface->face_index = face_index & 0xFFFF;

      /* Complement the root flags with some interesting information. */
      /* Note that this is only necessary for pure CFF and CEF fonts; */
      /* SFNT based fonts use the `name' table instead.               */

      cffface->num_glyphs = (FT_Long)cff->num_glyphs;

      dict = &cff->top_font.font_dict;

      /* we need the `PSNames' module for CFF and CEF formats */
      /* which aren't CID-keyed                               */
      if ( dict->cid_registry == 0xFFFFU && !psnames )
      {
        FT_ERROR(( "cff_face_init:"
                   " cannot open CFF & CEF fonts\n"
                   "              "
                   " without the `PSNames' module\n" ));
        error = FT_THROW( Missing_Module );
        goto Exit;
      }

#ifdef FT_DEBUG_LEVEL_TRACE
      {
        FT_UInt     idx;
        FT_String*  s;


        FT_TRACE4(( "SIDs\n" ));

        /* dump string index, including default strings for convenience */
        for ( idx = 0; idx <= 390; idx++ )
        {
          s = cff_index_get_sid_string( cff, idx );
          if ( s )
            FT_TRACE4(( "  %5d %s\n", idx, s ));
        }

        /* In Multiple Master CFFs, two SIDs hold the Normalize Design  */
        /* Vector (NDV) and Convert Design Vector (CDV) charstrings,    */
        /* which may contain NULL bytes in the middle of the data, too. */
        /* We thus access `cff->strings' directly.                      */
        for ( idx = 1; idx < cff->num_strings; idx++ )
        {
          FT_Byte*    s1    = cff->strings[idx - 1];
          FT_Byte*    s2    = cff->strings[idx];
          FT_PtrDist  s1len = s2 - s1 - 1; /* without the final NULL byte */
          FT_PtrDist  l;


          FT_TRACE4(( "  %5d ", idx + 390 ));
          for ( l = 0; l < s1len; l++ )
            FT_TRACE4(( "%c", s1[l] ));
          FT_TRACE4(( "\n" ));
        }

        /* print last element */
        if ( cff->num_strings )
        {
          FT_Byte*    s1    = cff->strings[cff->num_strings - 1];
          FT_Byte*    s2    = cff->string_pool + cff->string_pool_size;
          FT_PtrDist  s1len = s2 - s1 - 1;
          FT_PtrDist  l;


          FT_TRACE4(( "  %5d ", cff->num_strings + 390 ));
          for ( l = 0; l < s1len; l++ )
            FT_TRACE4(( "%c", s1[l] ));
          FT_TRACE4(( "\n" ));
        }
      }
#endif /* FT_DEBUG_LEVEL_TRACE */

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
      {
        FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;

        FT_Int  instance_index = face_index >> 16;


        if ( FT_HAS_MULTIPLE_MASTERS( cffface ) &&
             mm                                 &&
             instance_index > 0                 )
        {
          FT_MM_Var*  mm_var;


          error = mm->get_mm_var( cffface, NULL );
          if ( error )
            goto Exit;

          mm->get_var_blend( cffface, NULL, NULL, NULL, &mm_var );

          if ( mm_var->namedstyle )
          {
            FT_Var_Named_Style*  named_style;
            FT_String*           style_name;


            /* in `face_index', the instance index starts with value 1 */
            named_style = mm_var->namedstyle + instance_index - 1;
            error = sfnt->get_name( face,
                                    (FT_UShort)named_style->strid,
                                    &style_name );
            if ( error )
              goto Exit;

            /* set style name; if already set, replace it */
            if ( face->root.style_name )
              FT_FREE( face->root.style_name );
            face->root.style_name = style_name;

            /* finally, select the named instance */
            error = mm->set_var_design( cffface,
                                        mm_var->num_axis,
                                        named_style->coords );
            if ( error )
              goto Exit;
          }
        }
      }
#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */

      if ( !dict->has_font_matrix )
        dict->units_per_em = pure_cff ? 1000 : face->root.units_per_EM;

      /* Normalize the font matrix so that `matrix->yy' is 1; if  */
      /* it is zero, we use `matrix->yx' instead.  The scaling is */
      /* done with `units_per_em' then (at this point, it already */
      /* contains the scaling factor, but without normalization   */
      /* of the matrix).                                          */
      /*                                                          */
      /* Note that the offsets must be expressed in integer font  */
      /* units.                                                   */

      {
        FT_Matrix*  matrix = &dict->font_matrix;
        FT_Vector*  offset = &dict->font_offset;
        FT_ULong*   upm    = &dict->units_per_em;
        FT_Fixed    temp;


        temp = matrix->yy ? FT_ABS( matrix->yy )
                          : FT_ABS( matrix->yx );

        if ( temp != 0x10000L )
        {
          *upm = (FT_ULong)FT_DivFix( (FT_Long)*upm, temp );

          matrix->xx = FT_DivFix( matrix->xx, temp );
          matrix->yx = FT_DivFix( matrix->yx, temp );
          matrix->xy = FT_DivFix( matrix->xy, temp );
          matrix->yy = FT_DivFix( matrix->yy, temp );
          offset->x  = FT_DivFix( offset->x,  temp );
          offset->y  = FT_DivFix( offset->y,  temp );
        }

        offset->x >>= 16;
        offset->y >>= 16;
      }

      for ( i = cff->num_subfonts; i > 0; i-- )
      {
        CFF_FontRecDict  sub = &cff->subfonts[i - 1]->font_dict;
        CFF_FontRecDict  top = &cff->top_font.font_dict;

        FT_Matrix*  matrix;
        FT_Vector*  offset;
        FT_ULong*   upm;
        FT_Fixed    temp;


        if ( sub->has_font_matrix )
        {
          FT_Long  scaling;


          /* if we have a top-level matrix, */
          /* concatenate the subfont matrix */

          if ( top->has_font_matrix )
          {
            if ( top->units_per_em > 1 && sub->units_per_em > 1 )
              scaling = (FT_Long)FT_MIN( top->units_per_em,
                                         sub->units_per_em );
            else
              scaling = 1;

            FT_Matrix_Multiply_Scaled( &top->font_matrix,
                                       &sub->font_matrix,
                                       scaling );
            FT_Vector_Transform_Scaled( &sub->font_offset,
                                        &top->font_matrix,
                                        scaling );

            sub->units_per_em = (FT_ULong)
                                  FT_MulDiv( (FT_Long)sub->units_per_em,
                                             (FT_Long)top->units_per_em,
                                             scaling );
          }
        }
        else
        {
          sub->font_matrix = top->font_matrix;
          sub->font_offset = top->font_offset;

          sub->units_per_em = top->units_per_em;
        }

        matrix = &sub->font_matrix;
        offset = &sub->font_offset;
        upm    = &sub->units_per_em;

        temp = matrix->yy ? FT_ABS( matrix->yy )
                          : FT_ABS( matrix->yx );


        if ( temp != 0x10000L )
        {
          *upm = (FT_ULong)FT_DivFix( (FT_Long)*upm, temp );

          matrix->xx = FT_DivFix( matrix->xx, temp );
          matrix->yx = FT_DivFix( matrix->yx, temp );
          matrix->xy = FT_DivFix( matrix->xy, temp );
          matrix->yy = FT_DivFix( matrix->yy, temp );
          offset->x  = FT_DivFix( offset->x,  temp );
          offset->y  = FT_DivFix( offset->y,  temp );
        }

        offset->x >>= 16;
        offset->y >>= 16;
      }

      if ( pure_cff )
      {
        char*  style_name = NULL;


        /* set up num_faces */
        cffface->num_faces = (FT_Long)cff->num_faces;

        /* compute number of glyphs */
        if ( dict->cid_registry != 0xFFFFU )
          cffface->num_glyphs = (FT_Long)( cff->charset.max_cid + 1 );
        else
          cffface->num_glyphs = (FT_Long)cff->charstrings_index.count;

        /* set global bbox, as well as EM size */
        cffface->bbox.xMin =   dict->font_bbox.xMin            >> 16;
        cffface->bbox.yMin =   dict->font_bbox.yMin            >> 16;
        /* no `U' suffix here to 0xFFFF! */
        cffface->bbox.xMax = ( dict->font_bbox.xMax + 0xFFFF ) >> 16;
        cffface->bbox.yMax = ( dict->font_bbox.yMax + 0xFFFF ) >> 16;

        cffface->units_per_EM = (FT_UShort)( dict->units_per_em );

        cffface->ascender  = (FT_Short)( cffface->bbox.yMax );
        cffface->descender = (FT_Short)( cffface->bbox.yMin );

        cffface->height = (FT_Short)( ( cffface->units_per_EM * 12 ) / 10 );
        if ( cffface->height < cffface->ascender - cffface->descender )
          cffface->height = (FT_Short)( cffface->ascender - cffface->descender );

        cffface->underline_position  =
          (FT_Short)( dict->underline_position >> 16 );
        cffface->underline_thickness =
          (FT_Short)( dict->underline_thickness >> 16 );

        /* retrieve font family & style name */
        cffface->family_name = cff_index_get_name(
                                 cff,
                                 (FT_UInt)( face_index & 0xFFFF ) );
        if ( cffface->family_name )
        {
          char*  full   = cff_index_get_sid_string( cff,
                                                    dict->full_name );
          char*  fullp  = full;
          char*  family = cffface->family_name;
          char*  family_name = NULL;


          remove_subset_prefix( cffface->family_name );

          if ( dict->family_name )
          {
            family_name = cff_index_get_sid_string( cff,
                                                    dict->family_name );
            if ( family_name )
              family = family_name;
          }

          /* We try to extract the style name from the full name.   */
          /* We need to ignore spaces and dashes during the search. */
          if ( full && family )
          {
            while ( *fullp )
            {
              /* skip common characters at the start of both strings */
              if ( *fullp == *family )
              {
                family++;
                fullp++;
                continue;
              }

              /* ignore spaces and dashes in full name during comparison */
              if ( *fullp == ' ' || *fullp == '-' )
              {
                fullp++;
                continue;
              }

              /* ignore spaces and dashes in family name during comparison */
              if ( *family == ' ' || *family == '-' )
              {
                family++;
                continue;
              }

              if ( !*family && *fullp )
              {
                /* The full name begins with the same characters as the  */
                /* family name, with spaces and dashes removed.  In this */
                /* case, the remaining string in `fullp' will be used as */
                /* the style name.                                       */
                style_name = cff_strcpy( memory, fullp );

                /* remove the style part from the family name (if present) */
                remove_style( cffface->family_name, style_name );
              }
              break;
            }
          }
        }
        else
        {
          char  *cid_font_name =
                   cff_index_get_sid_string( cff,
                                             dict->cid_font_name );


          /* do we have a `/FontName' for a CID-keyed font? */
          if ( cid_font_name )
            cffface->family_name = cff_strcpy( memory, cid_font_name );
        }

        if ( style_name )
          cffface->style_name = style_name;
        else
          /* assume "Regular" style if we don't know better */
          cffface->style_name = cff_strcpy( memory, (char *)"Regular" );

        /*******************************************************************/
        /*                                                                 */
        /* Compute face flags.                                             */
        /*                                                                 */
        flags = FT_FACE_FLAG_SCALABLE   | /* scalable outlines */
                FT_FACE_FLAG_HORIZONTAL | /* horizontal data   */
                FT_FACE_FLAG_HINTER;      /* has native hinter */

        if ( sfnt_format )
          flags |= FT_FACE_FLAG_SFNT;

        /* fixed width font? */
        if ( dict->is_fixed_pitch )
          flags |= FT_FACE_FLAG_FIXED_WIDTH;

  /* XXX: WE DO NOT SUPPORT KERNING METRICS IN THE GPOS TABLE FOR NOW */
#if 0
        /* kerning available? */
        if ( face->kern_pairs )
          flags |= FT_FACE_FLAG_KERNING;
#endif

        cffface->face_flags |= flags;

        /*******************************************************************/
        /*                                                                 */
        /* Compute style flags.                                            */
        /*                                                                 */
        flags = 0;

        if ( dict->italic_angle )
          flags |= FT_STYLE_FLAG_ITALIC;

        {
          char  *weight = cff_index_get_sid_string( cff,
                                                    dict->weight );


          if ( weight )
            if ( !ft_strcmp( weight, "Bold"  ) ||
                 !ft_strcmp( weight, "Black" ) )
              flags |= FT_STYLE_FLAG_BOLD;
        }

        /* double check */
        if ( !(flags & FT_STYLE_FLAG_BOLD) && cffface->style_name )
          if ( !ft_strncmp( cffface->style_name, "Bold", 4 )  ||
               !ft_strncmp( cffface->style_name, "Black", 5 ) )
            flags |= FT_STYLE_FLAG_BOLD;

        cffface->style_flags = flags;
      }

#ifndef FT_CONFIG_OPTION_NO_GLYPH_NAMES
      /* CID-keyed CFF fonts don't have glyph names -- the SFNT loader */
      /* has unset this flag because of the 3.0 `post' table.          */
      if ( dict->cid_registry == 0xFFFFU )
        cffface->face_flags |= FT_FACE_FLAG_GLYPH_NAMES;
#endif

      if ( dict->cid_registry != 0xFFFFU && pure_cff )
        cffface->face_flags |= FT_FACE_FLAG_CID_KEYED;

      /*******************************************************************/
      /*                                                                 */
      /* Compute char maps.                                              */
      /*                                                                 */

      /* Try to synthesize a Unicode charmap if there is none available */
      /* already.  If an OpenType font contains a Unicode "cmap", we    */
      /* will use it, whatever be in the CFF part of the file.          */
      {
        FT_CharMapRec  cmaprec;
        FT_CharMap     cmap;
        FT_UInt        nn;
        CFF_Encoding   encoding = &cff->encoding;


        for ( nn = 0; nn < (FT_UInt)cffface->num_charmaps; nn++ )
        {
          cmap = cffface->charmaps[nn];

          /* Windows Unicode? */
          if ( cmap->platform_id == TT_PLATFORM_MICROSOFT &&
               cmap->encoding_id == TT_MS_ID_UNICODE_CS   )
            goto Skip_Unicode;

          /* Apple Unicode platform id? */
          if ( cmap->platform_id == TT_PLATFORM_APPLE_UNICODE )
            goto Skip_Unicode; /* Apple Unicode */
        }

        /* since CID-keyed fonts don't contain glyph names, we can't */
        /* construct a cmap                                          */
        if ( pure_cff && cff->top_font.font_dict.cid_registry != 0xFFFFU )
          goto Exit;

        /* we didn't find a Unicode charmap -- synthesize one */
        cmaprec.face        = cffface;
        cmaprec.platform_id = TT_PLATFORM_MICROSOFT;
        cmaprec.encoding_id = TT_MS_ID_UNICODE_CS;
        cmaprec.encoding    = FT_ENCODING_UNICODE;

        nn = (FT_UInt)cffface->num_charmaps;

        error = FT_CMap_New( &CFF_CMAP_UNICODE_CLASS_REC_GET, NULL,
                             &cmaprec, NULL );
        if ( error                                      &&
             FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) )
          goto Exit;
        error = FT_Err_Ok;

        /* if no Unicode charmap was previously selected, select this one */
        if ( !cffface->charmap && nn != (FT_UInt)cffface->num_charmaps )
          cffface->charmap = cffface->charmaps[nn];

      Skip_Unicode:
        if ( encoding->count > 0 )
        {
          FT_CMap_Class  clazz;


          cmaprec.face        = cffface;
          cmaprec.platform_id = TT_PLATFORM_ADOBE;  /* Adobe platform id */

          if ( encoding->offset == 0 )
          {
            cmaprec.encoding_id = TT_ADOBE_ID_STANDARD;
            cmaprec.encoding    = FT_ENCODING_ADOBE_STANDARD;
            clazz               = &CFF_CMAP_ENCODING_CLASS_REC_GET;
          }
          else if ( encoding->offset == 1 )
          {
            cmaprec.encoding_id = TT_ADOBE_ID_EXPERT;
            cmaprec.encoding    = FT_ENCODING_ADOBE_EXPERT;
            clazz               = &CFF_CMAP_ENCODING_CLASS_REC_GET;
          }
          else
          {
            cmaprec.encoding_id = TT_ADOBE_ID_CUSTOM;
            cmaprec.encoding    = FT_ENCODING_ADOBE_CUSTOM;
            clazz               = &CFF_CMAP_ENCODING_CLASS_REC_GET;
          }

          error = FT_CMap_New( clazz, NULL, &cmaprec, NULL );
        }
      }
    }

  Exit:
    return error;
  }


  FT_LOCAL_DEF( void )
  cff_face_done( FT_Face  cffface )         /* CFF_Face */
  {
    CFF_Face      face = (CFF_Face)cffface;
    FT_Memory     memory;
    SFNT_Service  sfnt;


    if ( !face )
      return;

    memory = cffface->memory;
    sfnt   = (SFNT_Service)face->sfnt;

    if ( sfnt )
      sfnt->done_face( face );

    {
      CFF_Font  cff = (CFF_Font)face->extra.data;


      if ( cff )
      {
        cff_font_done( cff );
        FT_FREE( face->extra.data );
      }
    }

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    cff_done_blend( face );
    face->blend = NULL;
#endif
  }


  FT_LOCAL_DEF( FT_Error )
  cff_driver_init( FT_Module  module )        /* CFF_Driver */
  {
    CFF_Driver  driver = (CFF_Driver)module;

    FT_UInt32  seed;


    /* set default property values, cf. `ftcffdrv.h' */
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
    driver->hinting_engine = FT_CFF_HINTING_FREETYPE;
#else
    driver->hinting_engine = FT_CFF_HINTING_ADOBE;
#endif

    driver->no_stem_darkening = TRUE;

    driver->darken_params[0] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1;
    driver->darken_params[1] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1;
    driver->darken_params[2] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2;
    driver->darken_params[3] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2;
    driver->darken_params[4] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3;
    driver->darken_params[5] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3;
    driver->darken_params[6] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4;
    driver->darken_params[7] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4;

    /* compute random seed from some memory addresses */
    seed = (FT_UInt32)( (FT_Offset)(char*)&seed          ^
                        (FT_Offset)(char*)&module        ^
                        (FT_Offset)(char*)module->memory );
    seed = seed ^ ( seed >> 10 ) ^ ( seed >> 20 );

    driver->random_seed = (FT_Int32)seed;
    if ( driver->random_seed < 0 )
      driver->random_seed = -driver->random_seed;
    else if ( driver->random_seed == 0 )
      driver->random_seed = 123456789;

    return FT_Err_Ok;
  }


  FT_LOCAL_DEF( void )
  cff_driver_done( FT_Module  module )        /* CFF_Driver */
  {
    FT_UNUSED( module );
  }


/* END */
@


1.23
log
@
Update to FreeType-2.7.1

i386 bulk build by sthen@@
amd64 bulk build by naddy@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2016 by                                                 */
d30 5
a56 3
  /*  Note that we store the global hints in the size's `internal' root    */
  /*  field.                                                               */
  /*                                                                       */
d80 1
d84 1
a84 1
    CFF_Internal  internal = (CFF_Internal)cffsize->internal;
d104 1
a104 1
      /* `internal' is freed by destroy_size (in ftobjs.c) */
d200 1
a200 1
      cffsize->internal = (FT_Size_Internal)(void*)internal;
d230 1
a230 1
      CFF_Internal  internal = (CFF_Internal)size->internal;
d302 1
a302 1
      CFF_Internal  internal = (CFF_Internal)size->internal;
d523 1
d566 2
a567 2
        cff2         = 1;
        face->isCFF2 = cff2;
d601 1
a690 2


a691 10

    {
      FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;

      FT_Int  instance_index = face_index >> 16;


      if ( FT_HAS_MULTIPLE_MASTERS( cffface ) &&
           mm                                 &&
           instance_index > 0                 )
d693 1
a693 1
        FT_MM_Var*  mm_var;
d695 1
a696 5
        error = mm->get_mm_var( cffface, NULL );
        if ( error )
          goto Exit;

        mm->get_var_blend( cffface, NULL, NULL, &mm_var );
d698 3
a700 1
        if ( mm_var->namedstyle )
d702 1
a702 2
          FT_Var_Named_Style*  named_style;
          FT_String*           style_name;
d705 1
a705 5
          /* in `face_index', the instance index starts with value 1 */
          named_style = mm_var->namedstyle + instance_index - 1;
          error = sfnt->get_name( face,
                                  (FT_UShort)named_style->strid,
                                  &style_name );
d709 28
a736 11
          /* set style name; if already set, replace it */
          if ( face->root.style_name )
            FT_FREE( face->root.style_name );
          face->root.style_name = style_name;

          /* finally, select the named instance */
          error = mm->set_var_design( cffface,
                                      mm_var->num_axis,
                                      named_style->coords );
          if ( error )
            goto Exit;
a738 2
    }

a740 2


a1022 1

a1032 1

d1164 2
d1184 12
@


1.22
log
@
Update to FreeType 2.6.5

ok matthieu@@
@
text
@d117 1
a117 1
    FT_MEM_ZERO( priv, sizeof ( *priv ) );
d453 1
a453 1
      for ( idx = 1; idx <= style_name_length; ++idx )
d472 1
a472 1
          --idx;
d494 1
d557 12
a568 2
      /* now load the CFF part of the file */
      error = face->goto_table( face, TTAG_CFF, stream, 0 );
d593 6
a598 1
      error = cff_font_load( library, stream, face_index, cff, pure_cff );
d686 56
d1086 1
a1086 1
        if ( cffface->charmap == NULL && nn != (FT_UInt)cffface->num_charmaps )
d1154 5
@


1.21
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@d628 1
a628 1
        for ( idx = 0; idx < cff->num_strings + 390; idx++ )
d632 34
a665 1
            FT_TRACE4(("  %5d %s\n", idx, s ));
d673 5
a677 4
      /* Normalize the font matrix so that `matrix->yy' is 1; the */
      /* scaling is done with `units_per_em' then (at this point, */
      /* it already contains the scaling factor, but without      */
      /* normalization of the matrix).                            */
d686 1
a686 1
        FT_Fixed    temp   = FT_ABS( matrix->yy );
d689 3
d759 4
a762 1
        temp   = FT_ABS( matrix->yy );
@


1.20
log
@
Bugfixing update to freetype-2.6.2

Tested on amd64, i386, macppc, sparc64, loongson and compile-tested
on arm by matthieu@@
Also tested in a ports bulk build by naddy@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2015 by                                                 */
d589 2
d592 1
@


1.19
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@d1055 1
a1055 1
    driver->no_stem_darkening = FALSE;
@


1.18
log
@
Update to FreeType 2.6

OK matthieu@@
@
text
@d586 5
d594 1
a594 1
      cffface->face_index = face_index;
d637 1
a637 1
      /* Normalize the font matrix so that `matrix->xx' is 1; the */
d773 3
a775 2
        cffface->family_name = cff_index_get_name( cff,
                                                   (FT_UInt)face_index );
@


1.17
log
@
Update to freetype-2.5.4

ports bulk build by landry@@

OK matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2014 by                                                 */
d229 2
a230 2
      FT_ULong  top_upm  = font->top_font.font_dict.units_per_em;
      FT_UInt   i;
d240 1
a240 1
        FT_ULong     sub_upm = sub->font_dict.units_per_em;
d301 2
a302 2
      FT_ULong  top_upm  = font->top_font.font_dict.units_per_em;
      FT_UInt   i;
d312 1
a312 1
        FT_ULong     sub_upm = sub->font_dict.units_per_em;
d345 1
a345 1
    slot->internal->glyph_hints = 0;
d595 1
a595 1
      cffface->num_glyphs = cff->num_glyphs;
d649 1
a649 1
          *upm = FT_DivFix( *upm, temp );
d685 2
a686 1
              scaling = FT_MIN( top->units_per_em, sub->units_per_em );
d697 4
a700 3
            sub->units_per_em = FT_MulDiv( sub->units_per_em,
                                           top->units_per_em,
                                           scaling );
d718 1
a718 1
          *upm = FT_DivFix( *upm, temp );
d738 1
a738 1
        cffface->num_faces = cff->num_faces;
d742 1
a742 1
          cffface->num_glyphs = cff->charset.max_cid + 1;
d744 1
a744 1
          cffface->num_glyphs = cff->charstrings_index.count;
d768 2
a769 1
        cffface->family_name = cff_index_get_name( cff, face_index );
@


1.16
log
@
Security/bugfixing update to freetype-2.5.3, featuring a fix for a
vulnerability in the CFF driver (CVE-2014-2240) and assorted minor
fixes.

ok matthieu@@
@
text
@d7 1
a7 1
/*  Copyright 1996-2013 by                                                 */
a945 10
#ifdef FT_MAX_CHARMAP_CACHEABLE
        if ( nn + 1 > FT_MAX_CHARMAP_CACHEABLE )
        {
          FT_ERROR(( "cff_face_init: no Unicode cmap is found, "
                     "and too many subtables (%d) to add synthesized cmap\n",
                     nn ));
          goto Exit;
        }
#endif

a965 9
#ifdef FT_MAX_CHARMAP_CACHEABLE
        if ( nn > FT_MAX_CHARMAP_CACHEABLE )
        {
          FT_ERROR(( "cff_face_init: Unicode cmap is found, "
                     "but too many preceding subtables (%d) to access\n",
                     nn - 1 ));
          goto Exit;
        }
#endif
d1039 1
a1039 1
    /* set default property values, cf `ftcffdrv.h' */
d1041 1
a1041 1
    driver->hinting_engine    = FT_CFF_HINTING_FREETYPE;
d1043 1
a1043 1
    driver->hinting_engine    = FT_CFF_HINTING_ADOBE;
d1045 1
d1048 8
a1055 8
    driver->darken_params[0] =  500;
    driver->darken_params[1] =  400;
    driver->darken_params[2] = 1000;
    driver->darken_params[3] =  275;
    driver->darken_params[4] = 1667;
    driver->darken_params[5] =  275;
    driver->darken_params[6] = 2333;
    driver->darken_params[7] =    0;
@


1.15
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d869 1
a869 1
        cffface->face_flags = flags;
@


1.14
log
@Update to freetype 2.5.0.1. Tested by many.
@
text
@d1058 1
a1058 1
    /* set default property values */
d1065 9
@


1.13
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@d408 1
a408 1
    FT_Int32  length          = strlen( name ) + 1;
d445 2
a446 2
    family_name_length = strlen( family_name );
    style_name_length  = strlen( style_name );
d1059 1
d1061 3
@


1.12
log
@Update to freetype 2.4.11. Tested by krw@@, jasper@@ and on a bulk ports
build by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2012 by                                                 */
d20 1
d28 2
d33 2
a35 1
#include "cffpic.h"
d160 1
a160 1
    FT_Error           error = CFF_Err_Ok;
d260 1
a260 1
    return CFF_Err_Ok;
d332 1
a332 1
    return CFF_Err_Ok;
d374 1
a374 1
    return CFF_Err_Ok;
d503 1
a503 1
      error = CFF_Err_Missing_Module;
d525 1
a525 1
        error = CFF_Err_Unknown_File_Format;
d531 1
a531 1
        return CFF_Err_Ok;
d566 1
a566 1
      error = CFF_Err_Ok;
d607 1
a607 1
        error = CFF_Err_Missing_Module;
d966 2
a967 1
        if ( error && FT_Err_No_Unicode_Glyph_Name != error )
d1053 1
a1053 1
  cff_driver_init( FT_Module  module )
d1055 6
a1060 1
    FT_UNUSED( module );
d1062 1
a1062 1
    return CFF_Err_Ok;
d1067 1
a1067 1
  cff_driver_done( FT_Module  module )
@


1.11
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@a528 8
      /* UNDOCUMENTED!  A CFF in an SFNT can have only a single font. */
      if ( face_index > 0 )
      {
        FT_ERROR(( "cff_face_init: invalid face index\n" ));
        error = CFF_Err_Invalid_Argument;
        goto Exit;
      }

d539 2
a540 1
        error = sfnt->load_face( stream, face, 0, num_params, params );
a549 4

        /* XXX: we don't load the GPOS table, as OpenType Layout     */
        /* support will be added later to a layout library on top of */
        /* FreeType 2                                                */
d960 1
a960 1
        error = FT_CMap_New( &FT_CFF_CMAP_UNICODE_CLASS_REC_GET, NULL,
d992 1
a992 1
            clazz               = &FT_CFF_CMAP_ENCODING_CLASS_REC_GET;
d998 1
a998 1
            clazz               = &FT_CFF_CMAP_ENCODING_CLASS_REC_GET;
d1004 1
a1004 1
            clazz               = &FT_CFF_CMAP_ENCODING_CLASS_REC_GET;
@


1.10
log
@Update to freetype 2.4.7.

This moslty is a bug-fix release for CVE-2011-3256.
@
text
@d7 1
a7 1
/*  Copyright 1996-2011 by                                                 */
d406 1
a406 1
 
d497 5
a501 1
      goto Bad_Format;
d508 2
d520 3
a522 2
        FT_TRACE2(( "[not a valid OpenType/CFF font]\n" ));
        goto Bad_Format;
d614 2
a615 1
        goto Bad_Format;
d783 1
a783 1
          remove_subset_prefix( cffface->family_name ); 
d830 1
a830 1
                remove_style( cffface->family_name, style_name ); 
d858 3
a860 3
        flags = (FT_UInt32)( FT_FACE_FLAG_SCALABLE   | /* scalable outlines */
                             FT_FACE_FLAG_HORIZONTAL | /* horizontal data   */
                             FT_FACE_FLAG_HINTER );    /* has native hinter */
d863 1
a863 1
          flags |= (FT_UInt32)FT_FACE_FLAG_SFNT;
d867 1
a867 1
          flags |= (FT_UInt32)FT_FACE_FLAG_FIXED_WIDTH;
d873 1
a873 1
          flags |= (FT_UInt32)FT_FACE_FLAG_KERNING;
a1024 4

  Bad_Format:
    error = CFF_Err_Unknown_File_Format;
    goto Exit;
@


1.9
log
@Update to freetype 2.4.5. Tested by many.
@
text
@d610 19
a628 1
      if ( !dict->units_per_em )
d673 1
a673 1
        if ( sub->units_per_em )
d678 21
a698 15
          if ( top->units_per_em > 1 && sub->units_per_em > 1 )
            scaling = FT_MIN( top->units_per_em, sub->units_per_em );
          else
            scaling = 1;

          FT_Matrix_Multiply_Scaled( &top->font_matrix,
                                     &sub->font_matrix,
                                     scaling );
          FT_Vector_Transform_Scaled( &sub->font_offset,
                                      &top->font_matrix,
                                      scaling );

          sub->units_per_em = FT_MulDiv( sub->units_per_em,
                                         top->units_per_em,
                                         scaling );
a715 10

          /* if *upm is larger than 100*1000 we divide by 1000 --     */
          /* this can happen if e.g. there is no top-font FontMatrix  */
          /* and the subfont FontMatrix already contains the complete */
          /* scaling for the subfont (see section 5.11 of the PLRM)   */

          /* 100 is a heuristic value */

          if ( *upm > 100L * 1000L )
            *upm = ( *upm + 500 ) / 1000;
@


1.8
log
@Update to freetype 2.4.3. Tested at least by krw@@, ajacoutot@@ and jasper@@
@
text
@d7 1
a7 2
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
d164 1
a164 1
      CFF_Internal  internal;
d423 1
d432 45
d484 1
a484 1
    CFF_Face            face = (CFF_Face)cffface;
d491 1
a491 1
    FT_Library library = cffface->driver->root.library;
d571 1
a571 1
      CFF_Font         cff;
d806 3
@


1.7
log
@Update to freetype 2.4.2. This has been in snapshots for a while
and tested explicitely by ajacoutot@@ jasper@@, jcs@@, krw@@ and others
on various architectures.
@
text
@d680 1
a680 1
          cffface->num_glyphs = cff->charset.max_cid;
@


1.6
log
@patches from Freetype.org for the security issues found by Robert Swiecki:

CVE-2010-2497 freetype integer underflow
CVE-2010-2498 freetype invalid free
CVE-2010-2499 freetype buffer overflow
CVE-2010-2500 freetype integer overflow
CVE-2010-2519 freetype heap buffer overflow
CVE-2010-2520 freetype buffer overflow on heap
@
text
@d7 2
a8 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
a27 2
#include FT_SERVICE_POSTSCRIPT_CMAPS_H
#include FT_INTERNAL_POSTSCRIPT_HINTS_H
d60 1
a60 1
    PSHinter_Service  pshinter = (PSHinter_Service)font->pshinter;
d351 1
a351 1
    PSHinter_Service  pshinter = (PSHinter_Service)font->pshinter;
d397 35
a448 8
#if 0
    FT_FACE_FIND_GLOBAL_SERVICE( face, sfnt,     SFNT );
    FT_FACE_FIND_GLOBAL_SERVICE( face, psnames,  POSTSCRIPT_NAMES );
    FT_FACE_FIND_GLOBAL_SERVICE( face, pshinter, POSTSCRIPT_HINTER );

    if ( !sfnt )
      goto Bad_Format;
#else
a457 1
#endif
d542 1
a542 1
      cff->psnames  = (void*)psnames;
d706 1
a706 3
        cffface->family_name = cff_index_get_name( &cff->name_index,
                                                   face_index );

d709 2
a710 3
          char*  full   = cff_index_get_sid_string( &cff->string_index,
                                                    dict->full_name,
                                                    psnames );
d713 2
a714 1
          char*  family_name = 0;
d716 1
d720 2
a721 3
            family_name = cff_index_get_sid_string( &cff->string_index,
                                                    dict->family_name,
                                                    psnames);
a763 4

            if ( family_name )
              FT_FREE( family_name );
            FT_FREE( full );
d769 2
a770 3
                   cff_index_get_sid_string( &cff->string_index,
                                             dict->cid_font_name,
                                             psnames );
d775 1
a775 1
            cffface->family_name = cid_font_name;
d818 2
a819 3
          char  *weight = cff_index_get_sid_string( &cff->string_index,
                                                    dict->weight,
                                                    psnames );
a825 1
          FT_FREE( weight );
d868 3
a870 2
          /* Windows Unicode (3,1)? */
          if ( cmap->platform_id == 3 && cmap->encoding_id == 1 )
d873 3
a875 3
          /* Deprecated Unicode platform id? */
          if ( cmap->platform_id == 0 )
            goto Skip_Unicode; /* Standard Unicode (deprecated) */
d895 2
a896 2
        cmaprec.platform_id = 3;
        cmaprec.encoding_id = 1;
d901 5
a905 1
        FT_CMap_New( &FT_CFF_CMAP_UNICODE_CLASS_REC_GET, NULL, &cmaprec, NULL );
d927 1
a927 1
          cmaprec.platform_id = 7;  /* Adobe platform id */
d948 1
a948 1
          FT_CMap_New( clazz, NULL, &cmaprec, NULL );
@


1.5
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d866 10
d891 9
@


1.4
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d33 1
d227 2
a228 2
      FT_Int   top_upm  = font->top_font.font_dict.units_per_em;
      FT_UInt  i;
d238 1
a238 1
        FT_Int       sub_upm = sub->font_dict.units_per_em;
d299 2
a300 2
      FT_Int   top_upm  = font->top_font.font_dict.units_per_em;
      FT_UInt  i;
d310 1
a310 1
        FT_Int       sub_upm = sub->font_dict.units_per_em;
d412 1
d424 1
a424 1
             cffface->driver->root.library, "sfnt" );
d431 1
a431 1
                 cffface->driver->root.library, "pshinter" );
d512 1
a512 1
      error = cff_font_load( stream, face_index, cff, pure_cff );
d533 4
a536 4
        FT_ERROR(( "cff_face_init:" ));
        FT_ERROR(( " cannot open CFF & CEF fonts\n" ));
        FT_ERROR(( "              " ));
        FT_ERROR(( " without the `PSNames' module\n" ));
d587 1
a587 1
          FT_Int  scaling;
d660 5
a664 4
        cffface->bbox.xMin =   dict->font_bbox.xMin             >> 16;
        cffface->bbox.yMin =   dict->font_bbox.yMin             >> 16;
        cffface->bbox.xMax = ( dict->font_bbox.xMax + 0xFFFFU ) >> 16;
        cffface->bbox.yMax = ( dict->font_bbox.yMax + 0xFFFFU ) >> 16;
d770 3
a772 3
        flags = FT_FACE_FLAG_SCALABLE   |       /* scalable outlines */
                FT_FACE_FLAG_HORIZONTAL |       /* horizontal data   */
                FT_FACE_FLAG_HINTER;            /* has native hinter */
d775 1
a775 1
          flags |= FT_FACE_FLAG_SFNT;
d779 1
a779 1
          flags |= FT_FACE_FLAG_FIXED_WIDTH;
d785 1
a785 1
          flags |= FT_FACE_FLAG_KERNING;
d874 1
a874 1
        FT_CMap_New( &cff_cmap_unicode_class_rec, NULL, &cmaprec, NULL );
d893 1
a893 1
            clazz               = &cff_cmap_encoding_class_rec;
d899 1
a899 1
            clazz               = &cff_cmap_encoding_class_rec;
d905 1
a905 1
            clazz               = &cff_cmap_encoding_class_rec;
@


1.3
log
@Update to Freetype 2.3.7. This is a bug fix release. No API change.
@
text
@d104 1
a104 1
  /* structures; we need to synthetize a Type 1 dictionary on the fly */
d440 1
a440 1
      if ( face->format_tag != 0x4F54544FL )  /* `OTTO'; OpenType/CFF font */
d468 1
a468 2
        error = sfnt->load_face( stream, face,
                                 face_index, num_params, params );
d510 1
a510 1
      error = cff_font_load( stream, face_index, cff );
d517 2
d663 1
a663 2

        cffface->units_per_EM = dict->units_per_em;
d826 1
a826 1
      if ( dict->cid_registry != 0xFFFFU )
d835 1
a835 1
      /* Try to synthetize a Unicode charmap if there is none available */
d922 7
a928 3
    CFF_Face      face   = (CFF_Face)cffface;
    FT_Memory     memory = cffface->memory;
    SFNT_Service  sfnt   = (SFNT_Service)face->sfnt;
d930 2
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d537 105
a661 2
        if ( !dict->units_per_em )
          dict->units_per_em = 1000;
a816 46
      else
      {
        if ( !dict->units_per_em )
          dict->units_per_em = face->root.units_per_EM;
      }

      /* Normalize the font matrix so that `matrix->xx' is 1; the */
      /* scaling is done with `units_per_em' then (at this point, */
      /* it already contains the scaling factor, but without      */
      /* normalization of the matrix).                            */
      /*                                                          */
      /* Note that the offsets must be expressed in integer font  */
      /* units.                                                   */

      {
        FT_Matrix*  matrix = &dict->font_matrix;
        FT_Vector*  offset = &dict->font_offset;
        FT_ULong*   upm    = &dict->units_per_em;
        FT_Fixed    temp   = FT_ABS( matrix->yy );


        if ( temp != 0x10000L )
        {
          *upm = FT_DivFix( *upm, temp );

          matrix->xx = FT_DivFix( matrix->xx, temp );
          matrix->yx = FT_DivFix( matrix->yx, temp );
          matrix->xy = FT_DivFix( matrix->xy, temp );
          matrix->yy = FT_DivFix( matrix->yy, temp );
          offset->x  = FT_DivFix( offset->x,  temp );
          offset->y  = FT_DivFix( offset->y,  temp );
        }

        offset->x >>= 16;
        offset->y >>= 16;
      }

      for ( i = cff->num_subfonts; i > 0; i-- )
      {
        CFF_FontRecDict  sub = &cff->subfonts[i - 1]->font_dict;
        CFF_FontRecDict  top = &cff->top_font.font_dict;

        FT_Matrix*  matrix;
        FT_Vector*  offset;
        FT_ULong*   upm;
        FT_Fixed    temp;
a817 60

        if ( sub->units_per_em )
        {
          FT_Int  scaling;


          if ( top->units_per_em > 1 && sub->units_per_em > 1 )
            scaling = FT_MIN( top->units_per_em, sub->units_per_em );
          else
            scaling = 1;

          FT_Matrix_Multiply_Scaled( &top->font_matrix,
                                     &sub->font_matrix,
                                     scaling );
          FT_Vector_Transform_Scaled( &sub->font_offset,
                                      &top->font_matrix,
                                      scaling );

          sub->units_per_em = FT_MulDiv( sub->units_per_em,
                                         top->units_per_em,
                                         scaling );
        }
        else
        {
          sub->font_matrix = top->font_matrix;
          sub->font_offset = top->font_offset;

          sub->units_per_em = top->units_per_em;
        }

        matrix = &sub->font_matrix;
        offset = &sub->font_offset;
        upm    = &sub->units_per_em;
        temp   = FT_ABS( matrix->yy );

        if ( temp != 0x10000L )
        {
          *upm = FT_DivFix( *upm, temp );

          /* if *upm is larger than 100*1000 we divide by 1000 --     */
          /* this can happen if e.g. there is no top-font FontMatrix  */
          /* and the subfont FontMatrix already contains the complete */
          /* scaling for the subfont (see section 5.11 of the PLRM)   */

          /* 100 is a heuristic value */

          if ( *upm > 100L * 1000L )
            *upm = ( *upm + 500 ) / 1000;

          matrix->xx = FT_DivFix( matrix->xx, temp );
          matrix->yx = FT_DivFix( matrix->yx, temp );
          matrix->xy = FT_DivFix( matrix->xy, temp );
          matrix->yy = FT_DivFix( matrix->yy, temp );
          offset->x  = FT_DivFix( offset->x,  temp );
          offset->y  = FT_DivFix( offset->y,  temp );
        }

        offset->x >>= 16;
        offset->y >>= 16;
      }
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d59 1
a59 1
    CFF_Font          font     = (CFF_FontRec *)face->extra.data;
d75 4
a78 1
    CFF_Size  size = (CFF_Size)cffsize;
d81 1
a81 1
    if ( cffsize->internal )
d88 5
a92 1
        funcs->destroy( (PSH_Globals)cffsize->internal );
d94 5
a98 1
      cffsize->internal = 0;
d103 50
d163 3
a165 4
      PSH_Globals    globals;
      CFF_Face       face    = (CFF_Face)cffsize->face;
      CFF_Font       font    = (CFF_FontRec *)face->extra.data;
      CFF_SubFont    subfont = &font->top_font;
a166 1
      CFF_Private    cpriv   = &subfont->private_dict;
d168 1
d170 1
a171 3
      /* IMPORTANT: The CFF and Type1 private dictionaries have    */
      /*            slightly different structures; we need to      */
      /*            synthetize a type1 dictionary on the fly here. */
d173 2
a174 2
      {
        FT_UInt  n, count;
d176 5
d182 3
a184 1
        FT_MEM_ZERO( &priv, sizeof ( priv ) );
a185 3
        count = priv.num_blue_values = cpriv->num_blue_values;
        for ( n = 0; n < count; n++ )
          priv.blue_values[n] = (FT_Short)cpriv->blue_values[n];
d187 5
a191 30
        count = priv.num_other_blues = cpriv->num_other_blues;
        for ( n = 0; n < count; n++ )
          priv.other_blues[n] = (FT_Short)cpriv->other_blues[n];

        count = priv.num_family_blues = cpriv->num_family_blues;
        for ( n = 0; n < count; n++ )
          priv.family_blues[n] = (FT_Short)cpriv->family_blues[n];

        count = priv.num_family_other_blues = cpriv->num_family_other_blues;
        for ( n = 0; n < count; n++ )
          priv.family_other_blues[n] = (FT_Short)cpriv->family_other_blues[n];

        priv.blue_scale = cpriv->blue_scale;
        priv.blue_shift = (FT_Int)cpriv->blue_shift;
        priv.blue_fuzz  = (FT_Int)cpriv->blue_fuzz;

        priv.standard_width[0]  = (FT_UShort)cpriv->standard_width;
        priv.standard_height[0] = (FT_UShort)cpriv->standard_height;

        count = priv.num_snap_widths = cpriv->num_snap_widths;
        for ( n = 0; n < count; n++ )
          priv.snap_widths[n] = (FT_Short)cpriv->snap_widths[n];

        count = priv.num_snap_heights = cpriv->num_snap_heights;
        for ( n = 0; n < count; n++ )
          priv.snap_heights[n] = (FT_Short)cpriv->snap_heights[n];

        priv.force_bold     = cpriv->force_bold;
        priv.language_group = cpriv->language_group;
        priv.lenIV          = cpriv->lenIV;
d194 1
a194 3
      error = funcs->create( cffsize->face->memory, &priv, &globals );
      if ( !error )
        cffsize->internal = (FT_Size_Internal)(void*)globals;
d199 1
d221 11
a231 3
      funcs->set_scale( (PSH_Globals)size->internal,
                        size->metrics.x_scale,
                        size->metrics.y_scale,
d234 23
d277 1
a277 1
      FT_ULong      index;
d280 1
a280 1
      if ( sfnt->set_sbit_strike( cffface, req, &index ) )
d283 1
a283 1
        return cff_size_select( size, index );
d293 11
a303 3
      funcs->set_scale( (PSH_Globals)size->internal,
                        size->metrics.x_scale,
                        size->metrics.y_scale,
d306 23
d350 1
a350 1
    CFF_Font          font     = (CFF_FontRec *)face->extra.data;
d371 1
a371 1
    return 0;
d386 1
a386 2
    FT_String*  result = 0;
    FT_Int      len = (FT_Int)ft_strlen( source );
d389 1
a389 5
    if ( !FT_ALLOC( result, len + 1 ) )
    {
      FT_MEM_COPY( result, source, len );
      result[len] = 0;
    }
d547 1
a547 1
          cffface->num_glyphs = dict->cid_count;
d720 31
a750 1
      /* handle font matrix settings in subfonts (if any) */
d756 5
d764 1
a764 2
          FT_Matrix  scale;

a765 3
          scale.xx = scale.yy = (FT_Fixed)FT_DivFix( top->units_per_em,
                                                     sub->units_per_em );
          scale.xy = scale.yx = 0;
d767 15
a781 2
          FT_Matrix_Multiply( &scale, &sub->font_matrix );
          FT_Vector_Transform( &sub->font_offset, &scale );
d787 2
d790 30
d824 1
a824 1
      /* has unset this flag because of the 3.0 `post' table           */
d829 4
d866 1
a866 1
        /* we didn't find a Unicode charmap -- synthetize one */
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d210 1
a210 1
      FT_ULong      strike_index;
d213 1
a213 1
      if ( sfnt->set_sbit_strike( cffface, req, &strike_index ) )
d216 1
a216 1
        return cff_size_select( size, strike_index );
d288 2
a289 1
    FT_String*  result;
d292 7
a298 1
    result = ft_mem_strdup( memory, source, &error );
@

