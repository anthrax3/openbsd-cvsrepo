head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_3_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_1:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.11.57.11;	author dcoppa;	state Exp;
branches;
next	1.12;
commitid	1dOLexdOAzW2mQjp;

1.12
date	2015.10.19.07.51.36;	author dcoppa;	state Exp;
branches;
next	1.11;
commitid	d2XmJCtYff11VIDu;

1.11
date	2014.01.12.15.08.27;	author matthieu;	state dead;
branches;
next	1.10;

1.10
date	2013.06.07.17.21.08;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.07.07.16.45.04;	author dcoppa;	state Exp;
branches;
next	1.8;

1.8
date	2012.04.14.09.45.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.09.28.19.01.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.25.20.49.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.26.07.31.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.10.20.28.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.21.05.09.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.22.17.37.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.46.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.46.13;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.08.16.31.33;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@
Update to FreeType 2.6.3

ok sthen@@, naddy@@, matthieu@@
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftstroke.h                                                             */
/*                                                                         */
/*    FreeType path stroker (specification).                               */
/*                                                                         */
/*  Copyright 2002-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#ifndef FTSTROKE_H_
#define FTSTROKE_H_

#include <ft2build.h>
#include FT_OUTLINE_H
#include FT_GLYPH_H


FT_BEGIN_HEADER


 /************************************************************************
  *
  * @@section:
  *    glyph_stroker
  *
  * @@title:
  *    Glyph Stroker
  *
  * @@abstract:
  *    Generating bordered and stroked glyphs.
  *
  * @@description:
  *    This component generates stroked outlines of a given vectorial
  *    glyph.  It also allows you to retrieve the `outside' and/or the
  *    `inside' borders of the stroke.
  *
  *    This can be useful to generate `bordered' glyph, i.e., glyphs
  *    displayed with a coloured (and anti-aliased) border around their
  *    shape.
  *
  * @@order:
  *    FT_Stroker
  *
  *    FT_Stroker_LineJoin
  *    FT_Stroker_LineCap
  *    FT_StrokerBorder
  *
  *    FT_Outline_GetInsideBorder
  *    FT_Outline_GetOutsideBorder
  *
  *    FT_Glyph_Stroke
  *    FT_Glyph_StrokeBorder
  *
  *    FT_Stroker_New
  *    FT_Stroker_Set
  *    FT_Stroker_Rewind
  *    FT_Stroker_ParseOutline
  *    FT_Stroker_Done
  *
  *    FT_Stroker_BeginSubPath
  *    FT_Stroker_EndSubPath
  *
  *    FT_Stroker_LineTo
  *    FT_Stroker_ConicTo
  *    FT_Stroker_CubicTo
  *
  *    FT_Stroker_GetBorderCounts
  *    FT_Stroker_ExportBorder
  *    FT_Stroker_GetCounts
  *    FT_Stroker_Export
  *
  */


 /**************************************************************
  *
  * @@type:
  *   FT_Stroker
  *
  * @@description:
  *   Opaque handle to a path stroker object.
  */
  typedef struct FT_StrokerRec_*  FT_Stroker;


  /**************************************************************
   *
   * @@enum:
   *   FT_Stroker_LineJoin
   *
   * @@description:
   *   These values determine how two joining lines are rendered
   *   in a stroker.
   *
   * @@values:
   *   FT_STROKER_LINEJOIN_ROUND ::
   *     Used to render rounded line joins.  Circular arcs are used
   *     to join two lines smoothly.
   *
   *   FT_STROKER_LINEJOIN_BEVEL ::
   *     Used to render beveled line joins.  The outer corner of
   *     the joined lines is filled by enclosing the triangular
   *     region of the corner with a straight line between the
   *     outer corners of each stroke.
   *
   *   FT_STROKER_LINEJOIN_MITER_FIXED ::
   *     Used to render mitered line joins, with fixed bevels if the
   *     miter limit is exceeded.  The outer edges of the strokes
   *     for the two segments are extended until they meet at an
   *     angle.  If the segments meet at too sharp an angle (such
   *     that the miter would extend from the intersection of the
   *     segments a distance greater than the product of the miter
   *     limit value and the border radius), then a bevel join (see
   *     above) is used instead.  This prevents long spikes being
   *     created.  FT_STROKER_LINEJOIN_MITER_FIXED generates a miter
   *     line join as used in PostScript and PDF.
   *
   *   FT_STROKER_LINEJOIN_MITER_VARIABLE ::
   *   FT_STROKER_LINEJOIN_MITER ::
   *     Used to render mitered line joins, with variable bevels if
   *     the miter limit is exceeded.  The intersection of the
   *     strokes is clipped at a line perpendicular to the bisector
   *     of the angle between the strokes, at the distance from the
   *     intersection of the segments equal to the product of the
   *     miter limit value and the border radius.  This prevents
   *     long spikes being created.
   *     FT_STROKER_LINEJOIN_MITER_VARIABLE generates a mitered line
   *     join as used in XPS.  FT_STROKER_LINEJOIN_MITER is an alias
   *     for FT_STROKER_LINEJOIN_MITER_VARIABLE, retained for
   *     backwards compatibility.
   */
  typedef enum  FT_Stroker_LineJoin_
  {
    FT_STROKER_LINEJOIN_ROUND          = 0,
    FT_STROKER_LINEJOIN_BEVEL          = 1,
    FT_STROKER_LINEJOIN_MITER_VARIABLE = 2,
    FT_STROKER_LINEJOIN_MITER          = FT_STROKER_LINEJOIN_MITER_VARIABLE,
    FT_STROKER_LINEJOIN_MITER_FIXED    = 3

  } FT_Stroker_LineJoin;


  /**************************************************************
   *
   * @@enum:
   *   FT_Stroker_LineCap
   *
   * @@description:
   *   These values determine how the end of opened sub-paths are
   *   rendered in a stroke.
   *
   * @@values:
   *   FT_STROKER_LINECAP_BUTT ::
   *     The end of lines is rendered as a full stop on the last
   *     point itself.
   *
   *   FT_STROKER_LINECAP_ROUND ::
   *     The end of lines is rendered as a half-circle around the
   *     last point.
   *
   *   FT_STROKER_LINECAP_SQUARE ::
   *     The end of lines is rendered as a square around the
   *     last point.
   */
  typedef enum  FT_Stroker_LineCap_
  {
    FT_STROKER_LINECAP_BUTT = 0,
    FT_STROKER_LINECAP_ROUND,
    FT_STROKER_LINECAP_SQUARE

  } FT_Stroker_LineCap;


  /**************************************************************
   *
   * @@enum:
   *   FT_StrokerBorder
   *
   * @@description:
   *   These values are used to select a given stroke border
   *   in @@FT_Stroker_GetBorderCounts and @@FT_Stroker_ExportBorder.
   *
   * @@values:
   *   FT_STROKER_BORDER_LEFT ::
   *     Select the left border, relative to the drawing direction.
   *
   *   FT_STROKER_BORDER_RIGHT ::
   *     Select the right border, relative to the drawing direction.
   *
   * @@note:
   *   Applications are generally interested in the `inside' and `outside'
   *   borders.  However, there is no direct mapping between these and the
   *   `left' and `right' ones, since this really depends on the glyph's
   *   drawing orientation, which varies between font formats.
   *
   *   You can however use @@FT_Outline_GetInsideBorder and
   *   @@FT_Outline_GetOutsideBorder to get these.
   */
  typedef enum  FT_StrokerBorder_
  {
    FT_STROKER_BORDER_LEFT = 0,
    FT_STROKER_BORDER_RIGHT

  } FT_StrokerBorder;


  /**************************************************************
   *
   * @@function:
   *   FT_Outline_GetInsideBorder
   *
   * @@description:
   *   Retrieve the @@FT_StrokerBorder value corresponding to the
   *   `inside' borders of a given outline.
   *
   * @@input:
   *   outline ::
   *     The source outline handle.
   *
   * @@return:
   *   The border index.  @@FT_STROKER_BORDER_RIGHT for empty or invalid
   *   outlines.
   */
  FT_EXPORT( FT_StrokerBorder )
  FT_Outline_GetInsideBorder( FT_Outline*  outline );


  /**************************************************************
   *
   * @@function:
   *   FT_Outline_GetOutsideBorder
   *
   * @@description:
   *   Retrieve the @@FT_StrokerBorder value corresponding to the
   *   `outside' borders of a given outline.
   *
   * @@input:
   *   outline ::
   *     The source outline handle.
   *
   * @@return:
   *   The border index.  @@FT_STROKER_BORDER_LEFT for empty or invalid
   *   outlines.
   */
  FT_EXPORT( FT_StrokerBorder )
  FT_Outline_GetOutsideBorder( FT_Outline*  outline );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_New
   *
   * @@description:
   *   Create a new stroker object.
   *
   * @@input:
   *   library ::
   *     FreeType library handle.
   *
   * @@output:
   *   astroker ::
   *     A new stroker object handle.  NULL in case of error.
   *
   * @@return:
   *    FreeType error code.  0~means success.
   */
  FT_EXPORT( FT_Error )
  FT_Stroker_New( FT_Library   library,
                  FT_Stroker  *astroker );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_Set
   *
   * @@description:
   *   Reset a stroker object's attributes.
   *
   * @@input:
   *   stroker ::
   *     The target stroker handle.
   *
   *   radius ::
   *     The border radius.
   *
   *   line_cap ::
   *     The line cap style.
   *
   *   line_join ::
   *     The line join style.
   *
   *   miter_limit ::
   *     The miter limit for the FT_STROKER_LINEJOIN_MITER_FIXED and
   *     FT_STROKER_LINEJOIN_MITER_VARIABLE line join styles,
   *     expressed as 16.16 fixed-point value.
   *
   * @@note:
   *   The radius is expressed in the same units as the outline
   *   coordinates.
   *
   *   This function calls @@FT_Stroker_Rewind automatically.
   */
  FT_EXPORT( void )
  FT_Stroker_Set( FT_Stroker           stroker,
                  FT_Fixed             radius,
                  FT_Stroker_LineCap   line_cap,
                  FT_Stroker_LineJoin  line_join,
                  FT_Fixed             miter_limit );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_Rewind
   *
   * @@description:
   *   Reset a stroker object without changing its attributes.
   *   You should call this function before beginning a new
   *   series of calls to @@FT_Stroker_BeginSubPath or
   *   @@FT_Stroker_EndSubPath.
   *
   * @@input:
   *   stroker ::
   *     The target stroker handle.
   */
  FT_EXPORT( void )
  FT_Stroker_Rewind( FT_Stroker  stroker );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_ParseOutline
   *
   * @@description:
   *   A convenience function used to parse a whole outline with
   *   the stroker.  The resulting outline(s) can be retrieved
   *   later by functions like @@FT_Stroker_GetCounts and @@FT_Stroker_Export.
   *
   * @@input:
   *   stroker ::
   *     The target stroker handle.
   *
   *   outline ::
   *     The source outline.
   *
   *   opened ::
   *     A boolean.  If~1, the outline is treated as an open path instead
   *     of a closed one.
   *
   * @@return:
   *   FreeType error code.  0~means success.
   *
   * @@note:
   *   If `opened' is~0 (the default), the outline is treated as a closed
   *   path, and the stroker generates two distinct `border' outlines.
   *
   *   If `opened' is~1, the outline is processed as an open path, and the
   *   stroker generates a single `stroke' outline.
   *
   *   This function calls @@FT_Stroker_Rewind automatically.
   */
  FT_EXPORT( FT_Error )
  FT_Stroker_ParseOutline( FT_Stroker   stroker,
                           FT_Outline*  outline,
                           FT_Bool      opened );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_BeginSubPath
   *
   * @@description:
   *   Start a new sub-path in the stroker.
   *
   * @@input:
   *   stroker ::
   *     The target stroker handle.
   *
   *   to ::
   *     A pointer to the start vector.
   *
   *   open ::
   *     A boolean.  If~1, the sub-path is treated as an open one.
   *
   * @@return:
   *   FreeType error code.  0~means success.
   *
   * @@note:
   *   This function is useful when you need to stroke a path that is
   *   not stored as an @@FT_Outline object.
   */
  FT_EXPORT( FT_Error )
  FT_Stroker_BeginSubPath( FT_Stroker  stroker,
                           FT_Vector*  to,
                           FT_Bool     open );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_EndSubPath
   *
   * @@description:
   *   Close the current sub-path in the stroker.
   *
   * @@input:
   *   stroker ::
   *     The target stroker handle.
   *
   * @@return:
   *   FreeType error code.  0~means success.
   *
   * @@note:
   *   You should call this function after @@FT_Stroker_BeginSubPath.
   *   If the subpath was not `opened', this function `draws' a
   *   single line segment to the start position when needed.
   */
  FT_EXPORT( FT_Error )
  FT_Stroker_EndSubPath( FT_Stroker  stroker );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_LineTo
   *
   * @@description:
   *   `Draw' a single line segment in the stroker's current sub-path,
   *   from the last position.
   *
   * @@input:
   *   stroker ::
   *     The target stroker handle.
   *
   *   to ::
   *     A pointer to the destination point.
   *
   * @@return:
   *   FreeType error code.  0~means success.
   *
   * @@note:
   *   You should call this function between @@FT_Stroker_BeginSubPath and
   *   @@FT_Stroker_EndSubPath.
   */
  FT_EXPORT( FT_Error )
  FT_Stroker_LineTo( FT_Stroker  stroker,
                     FT_Vector*  to );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_ConicTo
   *
   * @@description:
   *   `Draw' a single quadratic Bézier in the stroker's current sub-path,
   *   from the last position.
   *
   * @@input:
   *   stroker ::
   *     The target stroker handle.
   *
   *   control ::
   *     A pointer to a Bézier control point.
   *
   *   to ::
   *     A pointer to the destination point.
   *
   * @@return:
   *   FreeType error code.  0~means success.
   *
   * @@note:
   *   You should call this function between @@FT_Stroker_BeginSubPath and
   *   @@FT_Stroker_EndSubPath.
   */
  FT_EXPORT( FT_Error )
  FT_Stroker_ConicTo( FT_Stroker  stroker,
                      FT_Vector*  control,
                      FT_Vector*  to );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_CubicTo
   *
   * @@description:
   *   `Draw' a single cubic Bézier in the stroker's current sub-path,
   *   from the last position.
   *
   * @@input:
   *   stroker ::
   *     The target stroker handle.
   *
   *   control1 ::
   *     A pointer to the first Bézier control point.
   *
   *   control2 ::
   *     A pointer to second Bézier control point.
   *
   *   to ::
   *     A pointer to the destination point.
   *
   * @@return:
   *   FreeType error code.  0~means success.
   *
   * @@note:
   *   You should call this function between @@FT_Stroker_BeginSubPath and
   *   @@FT_Stroker_EndSubPath.
   */
  FT_EXPORT( FT_Error )
  FT_Stroker_CubicTo( FT_Stroker  stroker,
                      FT_Vector*  control1,
                      FT_Vector*  control2,
                      FT_Vector*  to );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_GetBorderCounts
   *
   * @@description:
   *   Call this function once you have finished parsing your paths
   *   with the stroker.  It returns the number of points and
   *   contours necessary to export one of the `border' or `stroke'
   *   outlines generated by the stroker.
   *
   * @@input:
   *   stroker ::
   *     The target stroker handle.
   *
   *   border ::
   *     The border index.
   *
   * @@output:
   *   anum_points ::
   *     The number of points.
   *
   *   anum_contours ::
   *     The number of contours.
   *
   * @@return:
   *   FreeType error code.  0~means success.
   *
   * @@note:
   *   When an outline, or a sub-path, is `closed', the stroker generates
   *   two independent `border' outlines, named `left' and `right'.
   *
   *   When the outline, or a sub-path, is `opened', the stroker merges
   *   the `border' outlines with caps.  The `left' border receives all
   *   points, while the `right' border becomes empty.
   *
   *   Use the function @@FT_Stroker_GetCounts instead if you want to
   *   retrieve the counts associated to both borders.
   */
  FT_EXPORT( FT_Error )
  FT_Stroker_GetBorderCounts( FT_Stroker        stroker,
                              FT_StrokerBorder  border,
                              FT_UInt          *anum_points,
                              FT_UInt          *anum_contours );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_ExportBorder
   *
   * @@description:
   *   Call this function after @@FT_Stroker_GetBorderCounts to
   *   export the corresponding border to your own @@FT_Outline
   *   structure.
   *
   *   Note that this function appends the border points and
   *   contours to your outline, but does not try to resize its
   *   arrays.
   *
   * @@input:
   *   stroker ::
   *     The target stroker handle.
   *
   *   border ::
   *     The border index.
   *
   *   outline ::
   *     The target outline handle.
   *
   * @@note:
   *   Always call this function after @@FT_Stroker_GetBorderCounts to
   *   get sure that there is enough room in your @@FT_Outline object to
   *   receive all new data.
   *
   *   When an outline, or a sub-path, is `closed', the stroker generates
   *   two independent `border' outlines, named `left' and `right'.
   *
   *   When the outline, or a sub-path, is `opened', the stroker merges
   *   the `border' outlines with caps.  The `left' border receives all
   *   points, while the `right' border becomes empty.
   *
   *   Use the function @@FT_Stroker_Export instead if you want to
   *   retrieve all borders at once.
   */
  FT_EXPORT( void )
  FT_Stroker_ExportBorder( FT_Stroker        stroker,
                           FT_StrokerBorder  border,
                           FT_Outline*       outline );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_GetCounts
   *
   * @@description:
   *   Call this function once you have finished parsing your paths
   *   with the stroker.  It returns the number of points and
   *   contours necessary to export all points/borders from the stroked
   *   outline/path.
   *
   * @@input:
   *   stroker ::
   *     The target stroker handle.
   *
   * @@output:
   *   anum_points ::
   *     The number of points.
   *
   *   anum_contours ::
   *     The number of contours.
   *
   * @@return:
   *   FreeType error code.  0~means success.
   */
  FT_EXPORT( FT_Error )
  FT_Stroker_GetCounts( FT_Stroker  stroker,
                        FT_UInt    *anum_points,
                        FT_UInt    *anum_contours );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_Export
   *
   * @@description:
   *   Call this function after @@FT_Stroker_GetBorderCounts to
   *   export all borders to your own @@FT_Outline structure.
   *
   *   Note that this function appends the border points and
   *   contours to your outline, but does not try to resize its
   *   arrays.
   *
   * @@input:
   *   stroker ::
   *     The target stroker handle.
   *
   *   outline ::
   *     The target outline handle.
   */
  FT_EXPORT( void )
  FT_Stroker_Export( FT_Stroker   stroker,
                     FT_Outline*  outline );


  /**************************************************************
   *
   * @@function:
   *   FT_Stroker_Done
   *
   * @@description:
   *   Destroy a stroker object.
   *
   * @@input:
   *   stroker ::
   *     A stroker handle.  Can be NULL.
   */
  FT_EXPORT( void )
  FT_Stroker_Done( FT_Stroker  stroker );


  /**************************************************************
   *
   * @@function:
   *   FT_Glyph_Stroke
   *
   * @@description:
   *   Stroke a given outline glyph object with a given stroker.
   *
   * @@inout:
   *   pglyph ::
   *     Source glyph handle on input, new glyph handle on output.
   *
   * @@input:
   *   stroker ::
   *     A stroker handle.
   *
   *   destroy ::
   *     A Boolean.  If~1, the source glyph object is destroyed
   *     on success.
   *
   * @@return:
   *    FreeType error code.  0~means success.
   *
   * @@note:
   *   The source glyph is untouched in case of error.
   *
   *   Adding stroke may yield a significantly wider and taller glyph
   *   depending on how large of a radius was used to stroke the glyph.  You
   *   may need to manually adjust horizontal and vertical advance amounts
   *   to account for this added size.
   */
  FT_EXPORT( FT_Error )
  FT_Glyph_Stroke( FT_Glyph    *pglyph,
                   FT_Stroker   stroker,
                   FT_Bool      destroy );


  /**************************************************************
   *
   * @@function:
   *   FT_Glyph_StrokeBorder
   *
   * @@description:
   *   Stroke a given outline glyph object with a given stroker, but
   *   only return either its inside or outside border.
   *
   * @@inout:
   *   pglyph ::
   *     Source glyph handle on input, new glyph handle on output.
   *
   * @@input:
   *   stroker ::
   *     A stroker handle.
   *
   *   inside ::
   *     A Boolean.  If~1, return the inside border, otherwise
   *     the outside border.
   *
   *   destroy ::
   *     A Boolean.  If~1, the source glyph object is destroyed
   *     on success.
   *
   * @@return:
   *    FreeType error code.  0~means success.
   *
   * @@note:
   *   The source glyph is untouched in case of error.
   *
   *   Adding stroke may yield a significantly wider and taller glyph
   *   depending on how large of a radius was used to stroke the glyph.  You
   *   may need to manually adjust horizontal and vertical advance amounts
   *   to account for this added size.
   */
  FT_EXPORT( FT_Error )
  FT_Glyph_StrokeBorder( FT_Glyph    *pglyph,
                         FT_Stroker   stroker,
                         FT_Bool      inside,
                         FT_Bool      destroy );

  /* */

FT_END_HEADER

#endif /* FTSTROKE_H_ */


/* END */


/* Local Variables: */
/* coding: utf-8    */
/* End:             */
@


1.12
log
@
Update to freetype-2.6.1

OK matthieu@@

Bulk build by naddy@@, thanks!
@
text
@d7 1
a7 1
/*  Copyright 2002-2015 by                                                 */
d19 2
a20 2
#ifndef __FT_STROKE_H__
#define __FT_STROKE_H__
d777 1
a777 1
#endif /* __FT_STROKE_H__ */
@


1.11
log
@Update to freetype 2.5.2.

With help for handling ports breakage from at least landry@@, naddy@@,
ajacoutot@@, jasper@@, and dcoppa@@. Thanks to all.

Need an up to date /etc/mtree/BSD.x11.dist (from a base system build)
before building.
@
text
@d7 1
a7 1
/*  Copyright 2002-2006, 2008, 2009, 2011-2012 by                          */
d49 32
d90 1
a90 1
  *   Opaque handler to a path stroker object.
d311 2
d607 1
a607 1
   *   two independent `border' outlines, named `left' and `right'
d610 1
a610 1
   *   the `border' outlines with caps. The `left' border receives all
d773 1
a773 1
 /* */
@


1.10
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@@


1.9
log
@Update to freetype-2.4.10.

With help and ok matthieu@@
@
text
@d274 1
a274 1
   *     expressed as 16.16 fixed point value.
@


1.8
log
@Update to freetype 2.4.9
Another round of fixes to better handle invalid fonts.   Many of
them are vulnerabilities  (see CVE-2012-1126 up to CVE-2012-1144
and SA48320).
@
text
@d7 1
a7 1
/*  Copyright 2002-2006, 2008, 2009, 2011 by                               */
d685 5
d727 5
@


1.7
log
@Update to freetype 2.4.6.

For now, omit the patch to ttdriver.c that changes some font metrics and
appearance of applications using TrueType fonts. Will revisit once the
issue is solved.
@
text
@d88 5
a92 5
   *     that the miter would extend from the intersection of the 
   *     segments a distance greater than the product of the miter 
   *     limit value and the border radius), then a bevel join (see 
   *     above) is used instead.  This prevents long spikes being 
   *     created.  FT_STROKER_LINEJOIN_MITER_FIXED generates a miter 
d98 9
a106 9
   *     the miter limit is exceeded.  The intersection of the 
   *     strokes is clipped at a line perpendicular to the bisector 
   *     of the angle between the strokes, at the distance from the 
   *     intersection of the segments equal to the product of the 
   *     miter limit value and the border radius.  This prevents 
   *     long spikes being created.  
   *     FT_STROKER_LINEJOIN_MITER_VARIABLE generates a mitered line 
   *     join as used in XPS.  FT_STROKER_LINEJOIN_MITER is an alias 
   *     for FT_STROKER_LINEJOIN_MITER_VARIABLE, retained for 
@


1.6
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d7 1
a7 1
/*  Copyright 2002, 2003, 2004, 2005, 2006, 2008, 2009 by                  */
d78 16
a93 2
   *     Used to render beveled line joins; i.e., the two joining lines
   *     are extended until they intersect.
d95 1
d97 11
a107 4
   *     Same as beveled rendering, except that an additional line
   *     break is added if the angle between the two joining lines
   *     is too closed (this is useful to avoid unpleasant spikes
   *     in beveled rendering).
d111 5
a115 3
    FT_STROKER_LINEJOIN_ROUND = 0,
    FT_STROKER_LINEJOIN_BEVEL,
    FT_STROKER_LINEJOIN_MITER
d272 2
a273 1
   *     The miter limit for the FT_STROKER_LINEJOIN_MITER style,
@


1.5
log
@Update to Freetype 2.3.9.

Bump major to be safe.
Small arm assembler fix in ftconfig.h by drahn@@
@
text
@d601 1
a601 1
   *   export the all borders to your own @@FT_Outline structure.
@


1.4
log
@Update to Freetype 2.3.8. Tested by jsg@@.
@
text
@d7 1
a7 1
/*  Copyright 2002, 2003, 2004, 2005, 2006, 2008 by                        */
d174 1
a174 1
   *   The border index.  @@FT_STROKER_BORDER_LEFT for empty or invalid
@


1.3
log
@Update to Freetype 2.3.7. This is a bug fix release. No API change.
@
text
@d252 1
a252 1
   *   The radius is expressed in the same units that the outline
d308 1
a308 1
   *   path, and the stroker will generate two distinct `border' outlines.
d311 1
a311 1
   *   stroker will generate a single `stroke' outline.
d369 1
a369 1
   *   If the subpath was not `opened', this function will `draw' a
d479 1
a479 1
   *   with the stroker.  It will return the number of points and
d528 2
a529 2
   *   Note that this function will append the border points and
   *   contours to your outline, but will not try to resize its
d603 2
a604 2
   *   Note that this function will append the border points and
   *   contours to your outline, but will not try to resize its
@


1.2
log
@Update to freetype 2.3.6.
Contains security fixes for CVE-2008-1806, CVE-2008-1807 and CVE-2008-1808.
Tested by many.
@
text
@d219 1
a219 1
   *    FreeType error code.  0 means success.
d300 1
a300 1
   *     A boolean.  If 1, the outline is treated as an open path instead
d304 1
a304 1
   *   FreeType error code.  0 means success.
d307 1
a307 1
   *   If `opened' is 0 (the default), the outline is treated as a closed
d310 1
a310 1
   *   If `opened' is 1, the outline is processed as an open path, and the
d337 1
a337 1
   *     A boolean.  If 1, the sub-path is treated as an open one.
d340 1
a340 1
   *   FreeType error code.  0 means success.
d365 1
a365 1
   *   FreeType error code.  0 means success.
d393 1
a393 1
   *   FreeType error code.  0 means success.
d424 1
a424 1
   *   FreeType error code.  0 means success.
d459 1
a459 1
   *   FreeType error code.  0 means success.
d498 1
a498 1
   *   FreeType error code.  0 means success.
d586 1
a586 1
   *   FreeType error code.  0 means success.
d652 1
a652 1
   *     A Boolean.  If 1, the source glyph object is destroyed
d656 1
a656 1
   *    FreeType error code.  0 means success.
d685 1
a685 1
   *     A Boolean.  If 1, return the inside border, otherwise
d689 1
a689 1
   *     A Boolean.  If 1, the source glyph object is destroyed
d693 1
a693 1
   *    FreeType error code.  0 means success.
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 2002, 2003, 2004, 2005, 2006 by                              */
d87 1
a87 1
  typedef enum
d118 1
a118 1
  typedef enum
d152 1
a152 1
  typedef enum
d300 2
a301 2
   *     A boolean.  If TRUE, the outline is treated as an open path
   *     instead of a closed one.
d337 1
a337 1
   *     A boolean.  If TRUE, the sub-path is treated as an open one.
d652 1
a652 1
   *     A Boolean.  If TRUE, the source glyph object is destroyed
d685 1
a685 1
   *     A Boolean.  If TRUE, return the inside border, otherwise
d689 1
a689 1
   *     A Boolean.  If TRUE, the source glyph object is destroyed
@


1.1.1.1
log
@Import freetype 2.2.1
@
text
@@


1.1.1.2
log
@import freetype 2.3.5
@
text
@d300 2
a301 2
   *     A boolean.  If 1, the outline is treated as an open path instead
   *     of a closed one.
d337 1
a337 1
   *     A boolean.  If 1, the sub-path is treated as an open one.
d652 1
a652 1
   *     A Boolean.  If 1, the source glyph object is destroyed
d685 1
a685 1
   *     A Boolean.  If 1, return the inside border, otherwise
d689 1
a689 1
   *     A Boolean.  If 1, the source glyph object is destroyed
@

