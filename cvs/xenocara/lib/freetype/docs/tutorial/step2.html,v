head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.2
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.4.0.10
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.8
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.12
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.10
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.6
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v2_3_5:1.1.1.1
	freetype:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2016.05.30.08.28.23;	author dcoppa;	state Exp;
branches;
next	1.5;
commitid	uW60vkhICnByxMgi;

1.5
date	2016.01.02.16.30.55;	author dcoppa;	state Exp;
branches;
next	1.4;
commitid	KONJVnu2E44KszPN;

1.4
date	2013.06.07.17.21.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.25.20.49.54;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.26.07.36.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.08.16.28.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.09.08.16.28.33;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@
Update to freetype-doc-2.6.3
@
text
@<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
          "http://www.w3.org/TR/html4/loose.dtd">

<html lang="en">

<head>
  <meta http-equiv="Content-Type"
        content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type"
        content="text/css">
  <meta http-equiv="Content-Script-Type"
        content="text/javascript">
  <meta name="description"
        content="FreeType Documentation">
  <meta name="Author"
        content="David Turner">

  <link rel="icon"
        href="../image/favicon_-90.ico">
  <link rel="shortcut icon"
        href="../image/favicon_-90.ico">
  <link rel="stylesheet"
        type="text/css"
        href="../css/freetype2_-90.css">

  <script type="text/javascript"
          src="../../../js/jquery-1.11.0.min.js">
  </script>
  <script type="text/javascript"
          src="../../../js/jquery.ba-resize.min.js">
  </script>
  <script type="text/javascript"
          src="../../../js/freetype2.js">
  </script>

  <title>FreeType Tutorial / II</title>
</head>


<body>

<div id="top"
     class="bar">
  <h1><a href="http://freetype.org/index.html">FreeType</a>
    Tutorial&nbsp;/&nbsp;II</h1>
</div>


<div id="wrapper">

<div class="colmask leftmenu">
  <div class="colright">
    <div class="col1wrap">
      <div class="col1">


        <!-- ************************************************** -->

        <div id="simple-glyph-loading">
          <h2>II. Managing Glyphs</h2>


          <h3 id="section-1">1. Glyph Metrics</h3>

          <p>Glyph metrics are, as the name suggests, certain
            distances associated with each glyph that describe how to
            position this glyph while creating a text layout.</p>

          <p>There are usually two sets of metrics for a single glyph:
            Those used to represent glyphs in horizontal text layouts
            (Latin, Cyrillic, Arabic, Hebrew, etc.), and those used to
            represent glyphs in vertical text layouts (Chinese,
            Japanese, Korean, Mongolian, etc.).</p>

          <p>Note that only a few font formats provide vertical
            metrics.  You can test whether a given face object
            contains them by using the
            macro <a href="../reference/ft2-base_interface.html#FT_HAS_VERTICAL"><tt>FT_HAS_VERTICAL</tt></a>,
            which returns true if appropriate.</p>

          <p>Individual glyph metrics can be accessed by first loading
            the glyph in a face's glyph slot, then accessing them
            through the <tt>face-&gt;glyph-&gt;metrics</tt> structure,
            whose type
            is <a href="../reference/ft2-base_interface.html#FT_Glyph_Metrics"><tt>FT_Glyph_Metrics</tt></a>.
            We will discuss this in more detail below; for now, we
            only note that it contains the following fields.</p>

          <dl>
            <dt>width</dt>
            <dd>This is the width of the glyph image's bounding box.
              It is independent of the layout direction.</dd>

            <dt>height</dt>
            <dd>This is the height of the glyph image's bounding box.
              It is independent of the layout direction.  Be careful
              not to confuse it with the &lsquo;height&rsquo; field in
              the <a href="../reference/ft2-base_interface.html#FT_Size_Metrics">
                <tt>FT_Size_Metrics</tt></a> structure.</dd>

            <dt>horiBearingX</dt>
            <dd>For <em>horizontal text layouts</em>, this is the
              horizontal distance from the current cursor position to
              the leftmost border of the glyph image's bounding
              box.</dd>

            <dt>horiBearingY</dt>
            <dd>For <em>horizontal text layouts</em>, this is the
              vertical distance from the current cursor position (on
              the baseline) to the topmost border of the glyph image's
              bounding box.</dd>

            <dt>horiAdvance</dt>
            <dd>For <em>horizontal text layouts</em>, this is the
              horizontal distance to increment the pen position when
              the glyph is drawn as part of a string of text.</dd>

            <dt>vertBearingX</dt>
            <dd>For <em>vertical text layouts</em>, this is the
              horizontal distance from the current cursor position to
              the leftmost border of the glyph image's bounding
              box.</dd>

            <dt>vertBearingY</dt>
            <dd>For <em>vertical text layouts</em>, this is the
              vertical distance from the current cursor position (on
              the baseline) to the topmost border of the glyph image's
              bounding box.</dd>

            <dt>vertAdvance</dt>
            <dd>For <em>vertical text layouts</em>, this is the
              vertical distance used to increment the pen position
              when the glyph is drawn as part of a string of
              text.</dd>
          </dl>

          <p class="warning">As not all fonts do contain vertical
            metrics, the values of <tt>vertBearingX</tt>,
            <tt>vertBearingY</tt> and <tt>vertAdvance</tt> should not
            be considered reliable if <tt>FT_HAS_VERTICAL</tt> returns
            false.</p>

          <p>The following graphics illustrate the metrics more
            clearly.  In case a distance is directed, it is marked
            with a single arrow, indicating a positive value.  The
            first image displays horizontal metrics, where the
            baseline is the horizontal axis.</p>

          <div class="figure">
            <img src="metrics.png"
                 alt="horizontal layout"
                 width=388
                 height=253>
          </div>

          <p>For vertical text layouts, the baseline is vertical,
            identical to the vertical axis.  Contrary to all other
            arrows, <tt>bearingX</tt> shows a negative value in this
            image.</p>

          <div class="figure">
            <img src="metrics2.png"
                 alt="vertical layout"
                 width=294
                 height=278>
          </div>

          <p>The metrics found in <tt>face-&gt;glyph-&gt;metrics</tt>
            are normally expressed in 26.6 pixel format (i.e., 1/64th
            of pixels), unless you use the <tt>FT_LOAD_NO_SCALE</tt>
            flag when calling <tt>FT_Load_Glyph</tt>
            or <tt>FT_Load_Char</tt>.  In this case, the metrics are
            expressed in original font units.</p>

          <p>The glyph slot object has also a few other interesting
            fields that eases a developer's work.  You can access them
            through <tt>face-&gt;glyph-&gt;xxx</tt>,
            where <tt>xxx</tt> is one of the following fields.</p>

          <dl>
            <dt>advance</dt>
            <dd>This field is a <tt>FT_Vector</tt> that holds the
              transformed advance for the glyph.  That is useful when
              you are using a transformation
              through <tt>FT_Set_Transform</tt>, as shown in the
              <a href="step1.html#transformed-text">rotated text
              example</a> of part&nbsp;I.  Other than that, its value
              is by default (metrics.horiAdvance,0), unless you
              specify <tt>FT_LOAD_VERTICAL</tt> when loading the glyph
              image; it is then (0,metrics.vertAdvance).</dd>

            <dt>linearHoriAdvance</dt>
            <dd>This field contains the linearly scaled value of the
              glyph's horizontal advance width.  Indeed, the value of
              <tt>metrics.horiAdvance</tt> that is returned in the
              glyph slot is normally rounded to integer pixel
              coordinates (i.e., being a multiple of&nbsp;64) by the
              font driver that actually loads the glyph
              image.  <tt>linearHoriAdvance</tt> is a 16.16
              fixed-point number that gives the value of the original
              glyph advance width in 1/65536th of pixels.  It can be
              use to perform pseudo device-independent text
              layouts.</dd>

            <dt>linearVertAdvance</dt>
            <dd>This is the similar to <tt>linearHoriAdvance</tt> but
              for the glyph's vertical advance height.  Its value is
              only reliable if the font face contains vertical
              metrics.</dd>
          </dl>


          <h3 id="section-2">2. Managing Glyph Images</h3>

          <p>The glyph image that is loaded in a glyph slot can be
            converted into a bitmap, either by
            using <tt>FT_LOAD_RENDER</tt> when loading it, or by
            calling <a href="../reference/ft2-base_interface.html#FT_Render_Glyph"><tt>FT_Render_Glyph</tt></a>.
            Each time you load a new glyph image, the previous one is
            erased from the glyph slot.</p>

          <p>There are situations, however, where you may need to
            extract this image from the glyph slot in order to cache
            it within your application, and even perform additional
            transformations and measures on it before converting it to
            a bitmap.</p>

          <p>The FreeType&nbsp;2 API has a specific extension that is
            capable of dealing with glyph images in a flexible and
            generic way.  To use it, you first need to include
            the <a href="../reference/ft2-header_file_macros.html#FT_GLYPH_H"><tt>FT_GLYPH_H</tt></a>
            header file.</p>

          <pre>
#include FT_GLYPH_H</pre>

          <h4>a.Extracting the Glyph Image</h4>

          <p>You can extract a single glyph image very easily.  Here
            some code that shows how to do it.</p>

          <pre>
FT_Glyph  glyph; <span class="comment">/* a handle to the glyph image */</span>


...
error = FT_Load_Glyph( face, glyph_index, FT_LOAD_NORMAL );
if ( error ) { ... }

error = FT_Get_Glyph( face-&gt;glyph, &amp;glyph );
if ( error ) { ... }</pre>

          <p>The following steps are performed.</p>

          <ul>
            <li>Create a variable named <tt>glyph</tt>, of
              type <a href="../reference/ft2-glyph_management.html#FT_Glyph"><tt>FT_Glyph</tt></a>.
              This is a handle (pointer) to an individual glyph
              image.</li>

            <li>Load the glyph image in the normal way into the face's
              glyph slot.  We don't use <tt>FT_LOAD_RENDER</tt>
              because we want to grab a scalable glyph image that we
              can transform later on.</li>

            <li>Copy the glyph image from the slot into a
              new <tt>FT_Glyph</tt> object by
              calling <a href="../reference/ft2-glyph_management.html#FT_Get_Glyph"><tt>FT_Get_Glyph</tt></a>.
              This function returns an error code and
              sets <tt>glyph</tt>.</li>
          </ul>

          <p>It is important to note that the extracted glyph is in
            the same format as the original one that is still in the
            slot.  For example, if we are loading a glyph from a
            TrueType font file, the glyph image is really a scalable
            vector outline.  You can access the
            field <tt>glyph-&gt;format</tt> if you want to know
            exactly how the glyph is modeled and stored.</p>

          <p>A new glyph object can be destroyed with a call
            to <a href="../reference/ft2-glyph_management.html#FT_Done_Glyph"><tt>FT_Done_Glyph</tt></a>.</p>

          <p>The glyph object contains exactly one glyph image and a
            2D vector representing the glyph's advance in 16.16
            fixed-point coordinates.  The latter can be accessed
            directly as <tt>glyph-&gt;advance</tt></p>

          <p class="warning">Note that unlike other FreeType objects,
            the library doesn't keep a list of all allocated glyph
            objects.  This means you have to destroy them yourself
            instead of relying on <tt>FT_Done_FreeType</tt> doing all
            the clean-up.</p>

          <h4>b. Transforming &amp; Copying the Glyph Image</h4>

          <p>If the glyph image is scalable (i.e.,
            if <tt>glyph-&gt;format</tt> is not equal
            to <tt>FT_GLYPH_FORMAT_BITMAP</tt>), it is possible to
            transform the image anytime by a call
            to <a href="../reference/ft2-glyph_management.html#FT_Glyph_Transform"><tt>FT_Glyph_Transform</tt></a>.</p>

          <p>You can also copy a single glyph image
            with <a href="../reference/ft2-glyph_management.html#FT_Glyph_Copy"><tt>FT_Glyph_Copy</tt></a>.</p>

          <pre>
FT_Glyph   glyph, glyph2;
FT_Matrix  matrix;
FT_Vector  delta;


... load glyph image in `glyph' ...

<span class="comment">/* copy glyph to glyph2 */</span>

error = FT_Glyph_Copy( glyph, &amp;glyph2 );
if ( error ) { ... could not copy (out of memory) ... }

<span class="comment">/* translate `glyph' */</span>

delta.x = -100 * 64; <span class="comment">/* coordinates are in 26.6 pixel format */</span>
delta.y =   50 * 64;

FT_Glyph_Transform( glyph, 0, &amp;delta );

<span class="comment">/* transform glyph2 (horizontal shear) */</span>

matrix.xx = 0x10000L;
matrix.xy = 0.12 * 0x10000L;
matrix.yx = 0;
matrix.yy = 0x10000L;

FT_Glyph_Transform( glyph2, &amp;matrix, 0 );</pre>

          <p>Note that the 2&times;2 transformation matrix is always
            applied to the 16.16 advance vector in the glyph; you thus
            don't need to recompute it.</p>

          <h4>c. Measuring the Glyph Image</h4>

          <p>You can also retrieve the control (bounding) box of any
            glyph image (scalable or not) through
            the <a href="../reference/ft2-glyph_management.html#FT_Glyph_Get_CBox"><tt>FT_Glyph_Get_CBox</tt></a>
            function.</p>

          <pre>
FT_BBox  bbox;


...
FT_Glyph_Get_CBox( glyph, <em>bbox_mode</em>, &amp;bbox );</pre>

          <p>Coordinates are relative to the glyph origin (0,0), using
            the y&nbsp;upwards convention.  This function takes a
            special argument, the <em>bbox mode</em>, to indicate how
            box coordinates are expressed.</p>

          <p>If the glyph has been loaded
            with <tt>FT_LOAD_NO_SCALE</tt>, <tt>bbox_mode</tt> must be
            set to <tt>FT_GLYPH_BBOX_UNSCALED</tt> to get unscaled
            font units in 26.6 pixel format.  The
            value <tt>FT_GLYPH_BBOX_SUBPIXELS</tt> is another name for
            this constant.</p>

          <p>Note that the box's maximum coordinates are exclusive,
            which means that you can always compute the width and
            height of the glyph image (regardless of using integer or
            26.6 coordinates) with a simple subtraction.</p>

          <pre class="example">
width  = bbox.xMax - bbox.xMin;
height = bbox.yMax - bbox.yMin;</pre>

          <p>Note also that for 26.6 coordinates, if
            <tt>FT_GLYPH_BBOX_GRIDFIT</tt> is used as the bbox mode,
            the coordinates are also grid-fitted, which corresponds to
            the following four lines.</p>

          <pre class="example">
bbox.xMin = FLOOR( bbox.xMin )
bbox.yMin = FLOOR( bbox.yMin )
bbox.xMax = CEILING( bbox.xMax )
bbox.yMax = CEILING( bbox.yMax )</pre>

          <p>To get the bbox in <em>integer</em> pixel coordinates,
            set <tt>bbox_mode</tt>
            to <tt>FT_GLYPH_BBOX_TRUNCATE</tt>.</p>

          <p>Finally, to get the bounding box in grid-fitted pixel
            coordinates, set <tt>bbox_mode</tt>
            to <tt>FT_GLYPH_BBOX_PIXELS</tt>.</p>

          <p>[Computing <em>exact</em> bounding boxes can be done with
            function <a href="../reference/ft2-outline_processing.html#FT_Outline_Get_BBox"><tt>FT_Outline_Get_BBox</tt></a>,
            at the cost of slower execution.  You probably don't need
            with the possible exception of rotated glyphs.]</p>

          <h4>d. Converting the Glyph Image to a Bitmap</h4>

          <p>You may need to convert the glyph object to a bitmap once
            you have conveniently cached or transformed it.  This can
            be done easily with
            the <a href="../reference/ft2-glyph_management.html"><tt>FT_Glyph_To_Bitmap</tt></a>
            function, which handles any glyph object.</p>

          <pre>
FT_Vector  origin;


origin.x = 32; <span class="comment">/* 1/2 pixel in 26.6 format */</span>
origin.y = 0;

error = FT_Glyph_To_Bitmap(
          &amp;glyph,
          <em>render_mode</em>,
          &amp;origin,
          1 );          <span class="comment">/* destroy original image == true */</span></pre>

          <p>Some notes.</p>

          <ul>
            <li>The first parameter is the address of the source
              glyph's handle.  When the function is called, it reads
              it to access the source glyph object.  After the call,
              the handle points to a <em>new</em> glyph object that
              contains the rendered bitmap.</li>

            <li>The second parameter is a standard render mode to
              specify what kind of bitmap we want.  For example, it
              can be <tt>FT_RENDER_MODE_DEFAULT</tt> for an 8-bit
              anti-aliased pixmap, or <tt>FT_RENDER_MODE_MONO</tt> for
              a 1-bit monochrome bitmap.</li>

            <li>The third parameter is a pointer to a two-dimensional
              vector to translate the source glyph image before the
              conversion.  After the call, the source image is
              translated back to its original position (and is thus
              left unchanged).  If you do not need to translate the
              source glyph before rendering, set this pointer
              to NULL.</li>

            <li>The last parameter is a boolean that indicates whether
              the source glyph object should be destroyed by the
              function.  If false, the original glyph object is never
              destroyed, even if its handle is lost (it is up to
              client applications to keep it).</li>
          </ul>

          <p>The new glyph object always contains a bitmap (if no
            error is returned), and you must <em>typecast</em> its
            handle to the <tt>FT_BitmapGlyph</tt> type in order to
            access its content.  This type is a sort of
            &lsquo;subclass&rsquo; of <tt>FT_Glyph</tt> that contains
            additional fields
            (see <a href="../reference/ft2-glyph_management.html#FT_BitmapGlyphRec"><tt>FT_BitmapGlyphRec</tt></a>).</p>

          <dl>
            <dt>left</dt>
            <dd>Just like the <tt>bitmap_left</tt> field of a glyph
              slot, this is the horizontal distance from the glyph
              origin (0,0) to the leftmost pixel of the glyph bitmap.
              It is expressed in integer pixels.</dd>

            <dt>top</dt>
            <dd>Just like the <tt>bitmap_top</tt> field of a glyph
              slot, this is the vertical distance from the glyph
              origin (0,0) to the topmost pixel of the glyph bitmap
              (more precise, to the pixel just above the bitmap).
              This distance is expressed in integer pixels, and is
              positive for upwards&nbsp;y.</dd>

            <dt>bitmap</dt>
            <dd>This is a bitmap descriptor for the glyph object, just
              like the <tt>bitmap</tt> field in a glyph slot.</dd>
          </dl>


          <h3 id="section-3">3. Global Glyph Metrics</h3>

          <p>Unlike glyph metrics, global metrics are used to describe
            distances and features of a whole font face.  They can be
            expressed either in 26.6 pixel format or in (unscaled)
            font units for scalable formats.</p>

          <h4> a. Design global metrics</h4>

          <p>For scalable formats, all global metrics are expressed in
            font units in order to be later scaled to the device
            space, according to the rules described in the last
            section of this tutorial part.  You can access them
            directly as fields of a <tt>FT_Face</tt> handle.</p>

          <p>However, you need to check that the font face's format is
            scalable before using them.  One can do it with
            macro <tt>FT_IS_SCALABLE</tt>, which returns true when
            appropriate.</p>

          <p>Here a table of the global design metrics for scalable
            faces.</p>

          <dl>
            <dt>units_per_EM</dt>
            <dd>This is the size of the EM square for the font face.
              It is used by scalable formats to scale design
              coordinates to device pixels, as described in the last
              section of this tutorial part.  Its value usually is
              2048 (for TrueType) or 1000 (for Type&nbsp;1 or CFF),
              but other values are possible, too.  It is set to&nbsp;1
              for fixed-size formats like FNT, FON, PCF, or BDF.</dd>

            <dt>bbox</dt>
            <dd>The global bounding box is defined as the smallest
              rectangle that can enclose all the glyphs in a font
              face.</dd>

            <dt>ascender</dt>
            <dd>The ascender is the vertical distance from the
              horizontal baseline to the highest
              &lsquo;character&rsquo; coordinate in a font face.
              Unfortunately, font formats don't define the ascender in
              a uniform way.  For some formats, it represents the
              ascent of all capital latin characters (without
              accents), for others it is the ascent of the highest
              accented character, and finally, other formats define it
              as being equal to <tt>bbox.yMax</tt>.</dd>

            <dt>descender</dt>
            <dd>The descender is the vertical distance from the
              horizontal baseline to the lowest
              &lsquo;character&rsquo; coordinate in a font face.
              Unfortunately, font formats don't define the descender
              in a uniform way.  For some formats, it represents the
              descent of all capital latin characters (without
              accents), for others it is the ascent of the lowest
              accented character, and finally, other formats define it
              as being equal to <tt>bbox.yMin</tt>.  This field is
              negative for values below the baseline.</dd>

            <dt>height</dt>
            <dd>This field represents a <em>default line spacing</em>
              (i.e., the baseline-to-baseline distance) when writing
              text with this font.  Note that it usually is larger
              than the sum of the ascender and descender taken as
              absolute values.  There is also no guarantee that no
              glyphs extend above or below subsequent baselines when
              using this distance &ndash; think of it as a value the
              designer of the font finds appropriate.</dd>

            <dt>max_advance_width</dt>
            <dd>This field gives the maximum horizontal cursor advance
              for all glyphs in the font.  It can be used to quickly
              compute the maximum advance width of a string of
              text.  <em>It doesn't correspond to the maximum glyph
                image width!</em></dd>

            <dt>max_advance_height</dt>
            <dd>Same as <tt>max_advance_width</tt> but for vertical
              text layout.</dd>

            <dt>underline_position</dt>
            <dd>When displaying or rendering underlined text, this
              value corresponds to the vertical position, relative to
              the baseline, of the underline bar's center.  It is
              negative if it is below the baseline.</dd>

            <dt>underline_thickness</dt>
            <dd>When displaying or rendering underlined text, this
              value corresponds to the vertical thickness of the
              underline.</dd>
          </dl>

          <p>Notice that the values of the ascender and the descender
            are not reliable (due to various discrepancies in font
            formats), unfortunately.</p>

          <h4>b. Scaled Global Metrics</h4>

          <p>Each size object also contains a scaled version of some
            of the global metrics described above, to be directly
            accessed through the <tt>face-&gt;size-&gt;metrics</tt>
            structure (of type <a href="../reference/ft2-base_interface.html#FT_Size_Metrics">
              <tt>FT_Size_Metrics</tt></a>).  <em>No rounding or
            grid-fitting is performed for those values</em>.  They are
            also completely independent of any hinting process.  In
            other words, don't rely on them to get exact metrics at
            the pixel level.  They are expressed in 26.6 pixel
            format.</p>

          <dl>
            <dt>ascender</dt>
            <dd>The scaled version of the original design
              ascender.</dd>

            <dt>descender</dt>
            <dd>The scaled version of the original design
              descender.</dd>

            <dt>height</dt>
            <dd>
              <p>The scaled version of the original design text height
                (the vertical distance from one baseline to the next).
                This is probably the only field you should really use
                in this structure.</p>

              <p>Be careful not to confuse it with the
                &lsquo;height&rsquo; field in
                the <a href="../reference/ft2-base_interface.html#FT_Glyph_Metrics"><tt>FT_Glyph_Metrics</tt></a>
                structure.</p>
            </dd>

            <dt>max_advance</dt>
            <dd>The scaled version of the original design maximum
              advance.</dd>
          </dl>

          <p>Note that the <tt>face-&gt;size-&gt;metrics</tt>
            structure contains other fields that are used to scale
            design coordinates to device space.  They are described in
            the last section.</p>

          <h4>c. Kerning</h4>

          <p>Kerning is the process of adjusting the position of two
            subsequent glyph images in a string of text in order to
            improve the general appearance of text.  For example, if a
            glyph for an uppercase &lsquo;A&rsquo; is followed by a
            glyph for an uppercase &lsquo;V&rsquo;, the space between
            the two glyphs can be slightly reduced to avoid extra
            &lsquo;diagonal whitespace&rsquo;.</p>

          <p>Note that in theory kerning can happen both in the
            horizontal and vertical direction between two glyphs;
            however, it only happens in a single direction in nearly
            all cases.</p>

          <p>Not all font formats contain kerning information, and not
            all kerning formats are supported by FreeType; in
            particular, for TrueType fonts, the API can only access
            kerning via the &lsquo;kern&rsquo;
            table.  <span class="important">OpenType kerning via the
            &lsquo;GPOS&rsquo; table is not supported!</span>  You
            need a higher-level library
            like <a href="http://www.harfbuzz.org">HarfBuzz</a>,
            <a href="http://www.pango.org">Pango</a>,
            or <a href="http://www.icu-project.org">ICU</a>, since
            GPOS kerning requires contextual string handling.</p>

          <p>Sometimes, the font file is associated with an additional
            file that contains various glyph metrics, including
            kerning, but no glyph images.  A good example is the
            Type&nbsp;1 format where glyph images are stored in files
            with extension <tt>.pfa</tt> or <tt>.pfb</tt>, while
            kerning metrics can be found in files with extension
            <tt>.afm</tt> or <tt>.pfm</tt>.</p>

          <p>FreeType&nbsp;2 allows you to deal with this, by
            providing
            the <a href="../reference/ft2-base_interface.html#FT_Attach_File"><tt>FT_Attach_File</tt></a>
            and <a href="../reference/ft2-base_interface.html#FT_Attach_Stream"><tt>FT_Attach_Stream</tt></A>
            APIs.  Both functions are used to load additional metrics
            into a face object by reading them from an additional
            format-specific file.  Here an example, opening a
            Type&nbsp;1 font.</p>

          <pre>
error = FT_New_Face( library, "/usr/share/fonts/cour.pfb",
                     0, &amp;face );
if ( error ) { ... }

error = FT_Attach_File( face, "/usr/share/fonts/cour.afm" );
if ( error )
{ ... could not read kerning and additional metrics ... }</pre>

          <p>Note that <tt>FT_Attach_Stream</tt> is similar to
            <tt>FT_Attach_File</tt> except that it doesn't take a
            C&nbsp;string to name the extra file but
            an <a href="../reference/ft2-system_interface.html#FT_StreamRec"><tt>FT_Stream</tt></a>
            handle.  Also, <em>reading a metrics file is in no way
            mandatory</em>.</p>

          <p>Finally, the file attachment APIs are very generic and
            can be used to load any kind of extra information for a
            given face.  The nature of the additional content is
            entirely font format specific.</p>

          <p>FreeType&nbsp;2 allows you to retrieve the kerning
            information between two glyphs through
            the <a href="../reference/ft2-base_interface.html#FT_Get_Kerning"><tt>FT_Get_Kerning</tt></a>
            function.</p>

          <pre>
FT_Vector  kerning;


...
error = FT_Get_Kerning( face,          <span class="comment">/* handle to face object */</span>
                        left,          <span class="comment">/* left glyph index      */</span>
                        right,         <span class="comment">/* right glyph index     */</span>
                        <em>kerning_mode</em>,  <span class="comment">/* kerning mode          */</span>
                        &amp;kerning );    <span class="comment">/* target vector         */</span></pre>

          <p>This function takes a handle to a face object, the
            indices of the left and right glyph for which the kerning
            value is desired, an integer, called the <em>kerning
            mode</em>, and a pointer to a destination vector that
            receives the corresponding distances.</p>

          <p>The kerning mode is very similar to the <em>bbox
            mode</em> described in a previous section.  It is a
            enumeration that indicates how the kerning distances are
            expressed in the target vector.</p>

          <p>The default value is <tt>FT_KERNING_DEFAULT</tt>, which
            has value&nbsp;0.  It corresponds to kerning distances
            expressed in 26.6 grid-fitted pixels (which means that the
            values are multiples of 64).  For scalable formats, this
            means that the design kerning distance is scaled, then
            rounded.</p>

          <p>The value <tt>FT_KERNING_UNFITTED</tt> corresponds to
            kerning distances expressed in 26.6 unfitted pixels (i.e.,
            that do not correspond to integer coordinates).  It is the
            design kerning distance that is scaled without
            rounding.</p>

          <p>Finally, the value <tt>FT_KERNING_UNSCALED</tt> indicates
            to return the design kerning distance, expressed in font
            units.  You can later scale it to the device space using
            the computations explained in the last section of this
            part.</p>

          <p>Note that the &lsquo;left&rsquo; and &lsquo;right&rsquo;
            positions correspond to the <em>visual order</em> of the
            glyphs in the string of text.  This is important for
            bidirectional or right-to-left text.</p>


          <h3 id="section-4">4. Simple Text Rendering: Kerning and Centering</h3>

          <p>In order to show off what we have just learned, we now
            demonstrate how to modify
            the <a href="step1.html#basic-code">example code</a> that
            was provided in part&nbsp;I to render a string of text,
            and enhance it to support kerning and delayed
            rendering.</p>

          <h4>a. Kerning Support</h4>

          <p>Adding support for kerning to our code is trivial, as
            long as we consider that we are still dealing with a
            left-to-right script like Latin.  We simply need to
            retrieve the kerning distance between two glyphs in order
            to alter the pen position appropriately.</p>

          <pre>
FT_GlyphSlot  slot = face-&gt;glyph;  <span class="comment">/* a small shortcut */</span>
FT_UInt       glyph_index;
FT_Bool       use_kerning;
FT_UInt       previous;
int           pen_x, pen_y, n;


... initialize library ...
... create face object ...
... set character size ...

pen_x = 300;
pen_y = 200;

use_kerning = FT_HAS_KERNING( face );
previous    = 0;

for ( n = 0; n &lt; num_chars; n++ )
{
  <span class="comment">/* convert character code to glyph index */</span>
  glyph_index = FT_Get_Char_Index( face, text[n] );

  <span class="comment">/* retrieve kerning distance and move pen position */</span>
  if ( use_kerning &amp;&amp; previous &amp;&amp; glyph_index )
  {
    FT_Vector  delta;


    FT_Get_Kerning( face, previous, glyph_index,
                    FT_KERNING_DEFAULT, &amp;delta );

    pen_x += delta.x &gt;&gt; 6;
  }

  <span class="comment">/* load glyph image into the slot (erase previous one) */</span>
  error = FT_Load_Glyph( face, glyph_index, FT_LOAD_RENDER );
  if ( error )
    continue;  <span class="comment">/* ignore errors */</span>

  <span class="comment">/* now draw to our target surface */</span>
  my_draw_bitmap( &amp;slot-&gt;bitmap,
                  pen_x + slot-&gt;bitmap_left,
                  pen_y - slot-&gt;bitmap_top );

  <span class="comment">/* increment pen position */</span>
  pen_x += slot->advance.x &gt;&gt; 6;

  <span class="comment">/* record current glyph index */</span>
  previous = glyph_index;
}</pre>

          <p>We are done.  Some notes.</p>

          <ul>
            <li>As kerning is determined by glyph indices, we need
              to explicitly convert our character codes into glyph
              indices, then later call <tt>FT_Load_Glyph</tt> instead
              of <tt>FT_Load_Char</tt>.</li>

            <li>We use a boolean named <tt>use_kerning</tt>, which is
              set to the result of the macro <tt>FT_HAS_KERNING</tt>.
              It is certainly faster not to
              call <tt>FT_Get_Kerning</tt> when we know that the font
              face does not contain kerning information.</li>

            <li>We move the position of the pen <em>before</em> a new
              glyph is drawn.</li>

            <li>We initialize the variable <tt>previous</tt> with the
              value&nbsp;0, which always corresponds to the
              &lsquo;missing glyph&rsquo; (also
              called <tt>.notdef</tt> in the PostScript world).  There
              is never any kerning distance associated with this
              glyph.</li>

            <li>We do not check the error code returned by
              <tt>FT_Get_Kerning</tt>.  This is because the function
              always sets the content of <tt>delta</tt> to (0,0) if
              an error occurs.</li>
          </ul>

          <h4>b. Centering</h4>

          <p>Our code begins to become interesting but it is still a
            bit too simple for normal use.  For example, the position
            of the pen is determined before we do the rendering;
            normally, you would rather determine the layout of the
            text and measure it before computing its final position
            (centering, etc.), or perform things like
            word-wrapping.</p>

          <p>Let us now decompose our text rendering function into two
            distinct but successive parts: The first one positions
            individual glyph images on the baseline, while the second
            one renders the glyphs.  As we will see, this has many
            advantages.</p>

          <p>We thus start by storing individual glyph images, as well
            as their position on the baseline.</p>

          <pre>
FT_GlyphSlot  slot = face-&gt;glyph;   <span class="comment">/* a small shortcut */</span>
FT_UInt       glyph_index;
FT_Bool       use_kerning;
FT_UInt       previous;
int           pen_x, pen_y, n;

FT_Glyph      glyphs[MAX_GLYPHS];   <span class="comment">/* glyph image    */</span>
FT_Vector     pos   [MAX_GLYPHS];   <span class="comment">/* glyph position */</span>
FT_UInt       num_glyphs;


... initialize library ...
... create face object ...
... set character size ...

pen_x = 0;   <span class="comment">/* start at (0,0) */</span>
pen_y = 0;

num_glyphs  = 0;
use_kerning = FT_HAS_KERNING( face );
previous    = 0;

for ( n = 0; n &lt; num_chars; n++ )
{
  <span class="comment">/* convert character code to glyph index */</span>
  glyph_index = FT_Get_Char_Index( face, text[n] );

  <span class="comment">/* retrieve kerning distance and move pen position */</span>
  if ( use_kerning &amp;&amp; previous &amp;&amp; glyph_index )
  {
    FT_Vector  delta;


    FT_Get_Kerning( face, previous, glyph_index,
                    FT_KERNING_DEFAULT, &amp;delta );

    pen_x += delta.x &gt;&gt; 6;
  }

  <span class="comment">/* store current pen position */</span>
  pos[num_glyphs].x = pen_x;
  pos[num_glyphs].y = pen_y;

  <span class="comment">/* load glyph image into the slot without rendering */</span>
  error = FT_Load_Glyph( face, glyph_index, FT_LOAD_DEFAULT );
  if ( error )
    continue;  <span class="comment">/* ignore errors, jump to next glyph */</span>

  <span class="comment">/* extract glyph image and store it in our table */</span>
  error = FT_Get_Glyph( face-&gt;glyph, &amp;glyphs[num_glyphs] );
  if ( error )
    continue;  <span class="comment">/* ignore errors, jump to next glyph */</span>

  <span class="comment">/* increment pen position */</span>
  pen_x += slot->advance.x &gt;&gt; 6;

  <span class="comment">/* record current glyph index */</span>
  previous = glyph_index;

  <span class="comment">/* increment number of glyphs */</span>
  num_glyphs++;
}</pre>

          <p>This is a very slight variation of our previous code; we
            extract each glyph image from the slot, then store it,
            along with the corresponding position, in our tables.</p>

          <p>Note also that <tt>pen_x</tt> contains the total advance
            for the string of text.  We can now compute the bounding
            box of the text string with a simple function.</p>

          <pre>
void  compute_string_bbox( FT_BBox  *abbox )
{
  FT_BBox  bbox;
  FT_BBox  glyph_bbox;


  <span class="comment">/* initialize string bbox to "empty" values */</span>
  bbox.xMin = bbox.yMin =  32000;
  bbox.xMax = bbox.yMax = -32000;

  <span class="comment">/* for each glyph image, compute its bounding box, */</span>
  <span class="comment">/* translate it, and grow the string bbox          */</span>
  for ( n = 0; n &lt; num_glyphs; n++ )
  {
    FT_Glyph_Get_CBox( glyphs[n], ft_glyph_bbox_pixels,
                       &amp;glyph_bbox );

    glyph_bbox.xMin += pos[n].x;
    glyph_bbox.xMax += pos[n].x;
    glyph_bbox.yMin += pos[n].y;
    glyph_bbox.yMax += pos[n].y;

    if ( glyph_bbox.xMin &lt; bbox.xMin )
      bbox.xMin = glyph_bbox.xMin;

    if ( glyph_bbox.yMin &lt; bbox.yMin )
      bbox.yMin = glyph_bbox.yMin;

    if ( glyph_bbox.xMax &gt; bbox.xMax )
      bbox.xMax = glyph_bbox.xMax;

    if ( glyph_bbox.yMax &gt; bbox.yMax )
      bbox.yMax = glyph_bbox.yMax;
  }

  <span class="comment">/* check that we really grew the string bbox */</span>
  if ( bbox.xMin &gt; bbox.xMax )
  {
    bbox.xMin = 0;
    bbox.yMin = 0;
    bbox.xMax = 0;
    bbox.yMax = 0;
  }

  <span class="comment">/* return string bbox */</span>
  *abbox = bbox;
}</pre>

          <p>The resulting bounding box dimensions are expressed in
            integer pixels and can then be used to compute the final
            pen position before rendering the string.</p>

          <p class="warning">In general, the above function
            does <em>not</em> compute an exact bounding box of a
            string!  As soon as hinting is involved, glyph
            dimensions <em>must</em> be derived from the resulting
            outlines.  For anti-aliased pixmaps,
            <tt>FT_Outline_Get_BBox</tt> then yields proper results.
            In case you need 1-bit monochrome bitmaps, it is even
            necessary to actually render the glyphs because the rules
            for the conversion from outline to bitmap can also be
            controlled by hinting instructions.</p>

          <pre>
<span class="comment">/* compute string dimensions in integer pixels */</span>
string_width  = string_bbox.xMax - string_bbox.xMin;
string_height = string_bbox.yMax - string_bbox.yMin;

<span class="comment">/* compute start pen position in 26.6 Cartesian pixels */</span>
start_x = ( ( my_target_width  - string_width  ) / 2 ) * 64;
start_y = ( ( my_target_height - string_height ) / 2 ) * 64;

for ( n = 0; n &lt; num_glyphs; n++ )
{
  FT_Glyph   image;
  FT_Vector  pen;


  image = glyphs[n];

  pen.x = start_x + pos[n].x;
  pen.y = start_y + pos[n].y;

  error = FT_Glyph_To_Bitmap( &amp;image, FT_RENDER_MODE_NORMAL,
                              &amp;pen, 0 );
  if ( !error )
  {
    FT_BitmapGlyph  bit = (FT_BitmapGlyph)image;


    my_draw_bitmap( bit-&gt;bitmap,
                    bit-&gt;left,
                    my_target_height - bit-&gt;top );

    FT_Done_Glyph( image );
  }
}</pre>

          <p>Some remarks.</p>

          <ul>
            <li>The pen position is expressed in the Cartesian space
              (i.e., y&nbsp;upwards).</li>

            <li>We call <tt>FT_Glyph_To_Bitmap</tt> with
              the <tt>destroy</tt> parameter set to&nbsp;0 (false), in
              order to avoid destroying the original glyph image.  The
              new glyph bitmap is accessed through
              <tt>image</tt> after the call and is typecast to
              <tt>FT_BitmapGlyph</tt>.</li>

            <li>We use translation when
              calling <tt>FT_Glyph_To_Bitmap</tt>.  This ensures that
              the <tt>left</tt> and <tt>top</tt> fields of the bitmap
              glyph object are already set to the correct pixel
              coordinates in the Cartesian space.</li>

            <li>Of course, we still need to convert pixel coordinates
              from Cartesian to device space before rendering, hence
              the <tt>my_target_height - bitmap->top</tt> in the call
              to <tt>my_draw_bitmap</tt>.</li>
          </ul>

          <p>The same loop can be used to render the string anywhere
            on our display surface, without the need to reload our
            glyph images each time.</p>


          <h3 id="section-5">5. Advanced Text Rendering:
            Transformation and Centering and Kerning</h3>

          <p>We are now going to modify our code in order to be able
            to easily transform the rendered string, for example, to
            rotate it.  First, some minor improvements.</p>

          <h4>a. Packing and Translating Glyphs</h4>

          <p>We start by packing the information related to a single
            glyph image into a single structure instead of parallel
            arrays.</p>

          <pre>
typedef struct  TGlyph_
{
  FT_UInt    index;  <span class="comment">/* glyph index                  */</span>
  FT_Vector  pos;    <span class="comment">/* glyph origin on the baseline */</span>
  FT_Glyph   image;  <span class="comment">/* glyph image                  */</span>

} TGlyph, *PGlyph;</pre>

          <p>We also translate each glyph image directly after it is
            loaded to its position on the baseline at load time.  As
            we will see, this has several advantages.  Here is our new
            glyph sequence loader.</p>

          <pre>
FT_GlyphSlot  slot = face-&gt;glyph;  <span class="comment">/* a small shortcut */</span>
FT_UInt       glyph_index;
FT_Bool       use_kerning;
FT_UInt       previous;
int           pen_x, pen_y, n;

TGlyph        glyphs[MAX_GLYPHS];  <span class="comment">/* glyphs table */</span>
PGlyph        glyph;               <span class="comment">/* current glyph in table */</span>
FT_UInt       num_glyphs;


... initialize library ...
... create face object ...
... set character size ...

pen_x = 0;   <span class="comment">/* start at (0,0) */</span>
pen_y = 0;

num_glyphs  = 0;
use_kerning = FT_HAS_KERNING( face );
previous    = 0;

glyph = glyphs;
for ( n = 0; n &lt; num_chars; n++ )
{
  glyph-&gt;index = FT_Get_Char_Index( face, text[n] );

  if ( use_kerning &amp;&amp; previous &amp;&amp; glyph->index )
  {
    FT_Vector  delta;


    FT_Get_Kerning( face, previous, glyph-&gt;index,
                    FT_KERNING_MODE_DEFAULT, &amp;delta );

    pen_x += delta.x &gt;&gt; 6;
  }

  <span class="comment">/* store current pen position */</span>
  glyph->pos.x = pen_x;
  glyph->pos.y = pen_y;

  error = FT_Load_Glyph( face, glyph_index, FT_LOAD_DEFAULT );
  if ( error ) continue;

  error = FT_Get_Glyph( face-&gt;glyph, &amp;glyph-&gt;image );
  if ( error ) continue;

  <span class="comment">/* translate the glyph image now */</span>
  FT_Glyph_Transform( glyph-&gt;image, 0, &amp;glyph-&gt;pos );

  pen_x   += slot->advance.x &gt;&gt; 6;
  previous = glyph->index;

  <span class="comment">/* increment number of glyphs */</span>
  glyph++;
}

<span class="comment">/* count number of glyphs loaded */</span>
num_glyphs = glyph - glyphs;</pre>

          <p>Note that translating glyphs now has several advantages.
            The first one is that we don't need to translate the glyph
            bbox when we compute the string's bounding box.</p>

          <pre>
void  compute_string_bbox( FT_BBox  *abbox )
{
  FT_BBox  bbox;


  bbox.xMin = bbox.yMin =  32000;
  bbox.xMax = bbox.yMax = -32000;

  for ( n = 0; n &lt; num_glyphs; n++ )
  {
    FT_BBox  glyph_bbox;


    FT_Glyph_Get_CBox( glyphs[n], ft_glyph_bbox_pixels,
                       &amp;glyph_bbox );

    if (glyph_bbox.xMin &lt; bbox.xMin)
      bbox.xMin = glyph_bbox.xMin;

    if (glyph_bbox.yMin &lt; bbox.yMin)
      bbox.yMin = glyph_bbox.yMin;

    if (glyph_bbox.xMax &gt; bbox.xMax)
      bbox.xMax = glyph_bbox.xMax;

    if (glyph_bbox.yMax &gt; bbox.yMax)
      bbox.yMax = glyph_bbox.yMax;
  }

  if ( bbox.xMin > bbox.xMax )
  {
    bbox.xMin = 0;
    bbox.yMin = 0;
    bbox.xMax = 0;
    bbox.yMax = 0;
  }

  *abbox = bbox;
}</pre>

          <p>With the above modifications,
            the <tt>compute_string_bbox</tt> function can now compute
            the bounding box of a transformed glyph string, which
            allows further code simplications.</p>

          <pre>
FT_BBox    bbox;
FT_Matrix  matrix;
FT_Vector  delta;


... load glyph sequence ...
... set up `matrix' and `delta' ...

<span class="comment">/* transform glyphs */</span>
for ( n = 0; n &lt; num_glyphs; n++ )
  FT_Glyph_Transform( glyphs[n].image, &amp;matrix, &amp;delta );

<span class="comment">/* compute bounding box of transformed glyphs */</span>
compute_string_bbox( &amp;bbox );</pre>

          <h4>b. Rendering a Transformed Glyph Sequence</h4>

          <p>However, directly transforming the glyphs in our sequence
            is not a good idea if we want to reuse them in order to
            draw the text string with various angles or
            transformations.  It is better to perform the affine
            transformation just before the glyph is rendered.</p>

          <pre>
FT_Vector  start;
FT_Matrix  matrix;

FT_Glyph   image;
FT_Vector  pen;
FT_BBox    bbox;


<span class="comment">/* get bbox of original glyph sequence */</span>
compute_string_bbox( &amp;string_bbox );

<span class="comment">/* compute string dimensions in integer pixels */</span>
string_width  = (string_bbox.xMax - string_bbox.xMin) / 64;
string_height = (string_bbox.yMax - string_bbox.yMin) / 64;

<span class="comment">/* set up start position in 26.6 Cartesian space */</span>
start.x = ( ( my_target_width  - string_width  ) / 2 ) * 64;
start.y = ( ( my_target_height - string_height ) / 2 ) * 64;

<span class="comment">/* set up transform (a rotation here) */</span>
matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );
matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );
matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );
matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );

pen = start;

for ( n = 0; n &lt; num_glyphs; n++ )
{
  <span class="comment">/* create a copy of the original glyph */</span>
  error = FT_Glyph_Copy( glyphs[n].image, &amp;image );
  if ( error ) continue;

  <span class="comment">/* transform copy (this will also translate it to the */</span>
  <span class="comment">/* correct position                                   */</span>
  FT_Glyph_Transform( image, &amp;matrix, &amp;pen );

  <span class="comment">/* check bounding box; if the transformed glyph image      */</span>
  <span class="comment">/* is not in our target surface, we can avoid rendering it */</span>
  FT_Glyph_Get_CBox( image, ft_glyph_bbox_pixels, &amp;bbox );
  if ( bbox.xMax &lt;= 0 || bbox.xMin &gt;= my_target_width  ||
       bbox.yMax &lt;= 0 || bbox.yMin &gt;= my_target_height )
    continue;

  <span class="comment">/* convert glyph image to bitmap (destroy the glyph copy!) */</span>
  error = FT_Glyph_To_Bitmap(
            &amp;image,
            FT_RENDER_MODE_NORMAL,
            0,                  <span class="comment">/* no additional translation */</span>
            1 );                <span class="comment">/* destroy copy in "image"   */</span>
  if ( !error )
  {
    FT_BitmapGlyph  bit = (FT_BitmapGlyph)image;


    my_draw_bitmap( bit-&gt;bitmap,
                    bit-&gt;left,
                    my_target_height - bit-&gt;top );

    <span class="comment">/* increment pen position --                       */</span>
    <span class="comment">/* we don't have access to a slot structure,       */</span>
    <span class="comment">/* so we have to use advances from glyph structure */</span>
    <span class="comment">/* (which are in 16.16 fixed float format)         */</span>
    pen.x += image.advance.x >> 10;
    pen.y += image.advance.y >> 10;

    FT_Done_Glyph( image );
  }
}</pre>

          <p>There are a few changes compared to the original version
            of this code.</p>

          <ul>
            <li>We keep the original glyph images untouched; instead,
              we transform a copy.</li>

            <li>We perform clipping computations in order to avoid
              rendering and drawing glyphs that are not within our
              target surface.</li>

            <li>We always destroy the copy when calling
              <tt>FT_Glyph_To_Bitmap</tt> in order to get rid of the
              transformed scalable image.  Note that the image is not
              destroyed if the function returns an error code (which
              is why <tt>FT_Done_Glyph</tt> is only called within the
              compound statement).</li>

            <li>The translation of the glyph sequence to the start pen
              position is integrated into the call
              to <tt>FT_Glyph_Transform</tt> instead
              of <tt>FT_Glyph_To_Bitmap</tt>.</li>
          </ul>

          <p>It is possible to call this function several times to
            render the string with different angles, or even change
            the way <tt>start</tt> is computed in order to move it to
            different place.</p>

          <p>This code is the basis of the FreeType&nbsp;2
            demonstration program
            named <a href="http://git.savannah.gnu.org/cgit/freetype/freetype2-demos.git/tree/src/ftstring.c"><tt>ftstring.c</tt></a>.
            It could be easily extended to perform advanced text
            layout or word-wrapping in the first part, without
            changing the second one.</p>

          <p>Note, however, that a normal implementation would use a
            glyph cache in order to reduce memory needs.  For example,
            let us assume that our text string is
            &lsquo;FreeType&rsquo;.  We would store three identical
            glyph images in our table for the letter &lsquo;e&rsquo;,
            which isn't optimal (especially when you consider longer
            lines of text, or even whole pages).</p>

          <p>A FreeType demo program that shows how glyph caching can
            be implemented
            is <a href="http://git.savannah.gnu.org/cgit/freetype/freetype2-demos.git/tree/src/ftview.c"><tt>ftview.c</tt></a>.
            In general, &lsquo;ftview&rsquo; is the main program used
            by the FreeType developer team to check the validity of
            loading, parsing, and rendering fonts.</p>


          <h3 id="section-6">6. Accessing Metrics in Design Font
            Units, and Scaling Them</h3>

          <p>Scalable font formats usually store a single vectorial
            image, called an <em>outline</em>, for each glyph in a
            face.  Each outline is defined in an abstract grid called
            the <em>design space</em>, with coordinates expressed in
            <em>font units</em>.  When a glyph image is loaded, the
            font driver usually scales the outline to device space
            according to the current character pixel size found in
            an <a href="../reference/ft2-base_interface.html#FT_Size"><tt>FT_Size</tt></a>
            object.  The driver may also modify the scaled outline in
            order to significantly improve its appearance on a
            pixel-based surface (a process known as <em>hinting</em>
            or <em>grid-fitting</em>).</p>

          <p>This section describes how design coordinates are scaled
            to the device space, and how to read glyph outlines and
            metrics in font units.  This is important for a number of
            things.</p>

          <ul>
            <li>&lsquo;True&rsquo; WYSIWYG text layout.</li>
            <li>Accessing font content for conversion or analysis
              purposes.</li>
          </ul>

          <h4>a. Scaling Distances to Device Space</h4>

          <p>Design coordinates are scaled to the device space using a
            simple scaling transformation whose coefficients are
            computed with the help of the <em>character pixel
            size</em>.</p>

          <pre class="example">
  device_x = design_x * x_scale
  device_y = design_y * y_scale

  x_scale  = pixel_size_x / EM_size
  y_scale  = pixel_size_y / EM_size</pre>

          <p>Here, the value <tt>EM_size</tt> is font-specific and
            corresponds to the size of an abstract square of the
            design space (called the <em>EM</em>), which is used by
            font designers to create glyph images.  It is thus
            expressed in font units.  It is also accessible directly
            for scalable font formats
            as <tt>face-&gt;units_per_EM</tt>.  You should check that
            a font face contains scalable glyph images by using
            the <tt>FT_IS_SCALABLE</tt> macro, which returns true if
            appropriate.</p>

          <p>When you call the
            function <a href="../reference/ft2-base_interface.html#FT_Set_Pixel_Sizes"><tt>FT_Set_Pixel_Sizes</tt></a>,
            you are specifying the value of <tt>pixel_size_x</tt> and
            <tt>pixel_size_y</tt> FreeType shall use.  The library will
            immediately compute the values of <tt>x_scale</tt> and
            <tt>y_scale</tt>.</p>

          <p>When you call the
            function <a href="../reference/ft2-base_interface.html#FT_Set_Char_Size"><tt>FT_Set_Char_Size</tt></a>,
            you are specifying the character size in
            physical <em>points</em>, which is used, along with the
            device's resolutions, to compute the character pixel size
            and the corresponding scaling factors.</p>

          <p>Note that after calling any of these two functions, you
            can access the values of the character pixel size and
            scaling factors as fields of
            the <tt>face-&gt;size-&gt;metrics</tt> structure.</p>

          <dl>
            <dt>x_ppem</dt>
            <dd>The field name stands for &lsquo;x&nbsp;pixels per
              EM&rsquo;; this is the horizontal size in integer pixels
              of the EM square, which also is the <em>horizontal
              character pixel size</em>, called <tt>pixel_size_x</tt>
              in the above example.</dd>

            <dt>y_ppem</dt>
            <dd>The field name stands for &lsquo;y&nbsp;pixels per
              EM&rsquo;; this is the vertical size in integer pixels
              of the EM square, which also is the <em>vertical
              character pixel size</em>, called <tt>pixel_size_y</tt>
              in the above example.</dd>

            <dt>x_scale</dt>
            <dd>This is a 16.16 fixed-point scale to directly scale
              horizontal distances from design space to 1/64th of
              device pixels.</dd>

            <dt>y_scale</dt>
            <dd>This is a 16.16 fixed-point scale to directly scale
              vertical distances from design space to 1/64th of device
              pixels.</dd>
          </dl>

          <p>You can scale a distance expressed in font units to 26.6
            pixel format directly with the help of
            the <a href="../reference/ft2-computations.html#FT_MulFix"><tt>FT_MulFix</tt></a>
            function.</p>

          <pre>
<span class="comment">/* convert design distances to 1/64th of pixels */</span>
pixels_x = FT_MulFix( design_x, face-&gt;size-&gt;metrics.x_scale );
pixels_y = FT_MulFix( design_y, face-&gt;size-&gt;metrics.y_scale );</pre>

          <p>Alternatively, you can also scale the value directly with
            more accuracy by using doubles.</p>

          <pre>
FT_Size_Metrics*  metrics = &amp;face-&gt;size-&gt;metrics; <span class="comment">/* shortcut */</span>
double            pixels_x, pixels_y;
double            em_size, x_scale, y_scale;


<span class="comment">/* compute floating point scale factors */</span>
em_size = 1.0 * face-&gt;units_per_EM;
x_scale = metrics-&gt;x_ppem / em_size;
y_scale = metrics-&gt;y_ppem / em_size;

<span class="comment">/* convert design distances to floating point pixels */</span>
pixels_x = design_x * x_scale;
pixels_y = design_y * y_scale;</pre>

          <h4>b. Accessing Design Metrics (Glyph &amp; Global)</h4>

          <p>You can access glyph metrics in font units simply by
            specifying the <tt>FT_LOAD_NO_SCALE</tt> bit flag
            in <tt>FT_Load_Glyph</tt> or <tt>FT_Load_Char</tt>.  The
            metrics returned in <tt>face-&gt;glyph-&gt;metrics</tt>
            will all be in font units.</p>

          <p>You can access unscaled kerning data using the
            <tt>FT_KERNING_MODE_UNSCALED</tt> mode.</p>

          <p>Finally, a few global metrics are available directly in
            font units as fields of the <tt>FT_Face</tt> handle, as
            described in <a href="#section-3">section&nbsp;3</a> of
            this part.</p>


          <h3 id="conclusion">Conclusion</h3>

          <p>This is the end of the second part of the FreeType
            tutorial.  You are now able to access glyph metrics,
            manage glyph images, and render text much more
            intelligently (kerning, measuring, transforming &amp;
            caching); this is sufficient knowledge to build a pretty
            decent text service on top of FreeType.</p>

          <p>The demo programs in the &lsquo;ft2demos&rsquo; bundle
            (especially &lsquo;ftview&rsquo;) are a kind of reference
            implementation, and are a good resource to turn to for
            answers.  They also show how to use additional features,
            such as the glyph stroker and cache.</p>
        </div>

        <!-- ************************************************** -->

        <div class="updated">
          <p>Last update: 12-Dec-2014</p>
        </div>
      </div>
    </div>


    <!-- ************************************************** -->

    <div class="col2">
    </div>
  </div>
</div>


<!-- ************************************************** -->

<div id="TOC">
  <ul>
    <li class="funding">
      <p><a href="https://pledgie.com/campaigns/24434">
        <img alt="Click here to lend your support to the FreeType project and make a donation at pledgie.com!"
             src="https://pledgie.com/campaigns/24434.png?skin_name=chrome"
             border="0"
             align="middle">
      </a></p>

      <p><a href="https://flattr.com/thing/421342/lemzwerg-on-Flattr"
         target="_blank">
        <img class="with-border"
             src="http://api.flattr.com/button/flattr-badge-large.png"
             alt="Flattr this"
             title="Flattr this"
             border="0"
             align="middle">
      </a></p>
    </li>
    <li class="primary">
      <a href="http://freetype.org/index.html">Home</a>
    </li>
    <li class="primary">
      <a href="http://freetype.org/index.html#news">News</a>
    </li>
    <li class="primary">
      <a href="../index.html">Overview</a>
    </li>
    <li class="primary">
      <a href="../documentation.html">Documentation</a>
    </li>
    <li class="primary">
      <a href="http://freetype.org/developer.html">Development</a>
    </li>
    <li class="primary">
      <a href="http://freetype.org/contact.html"
         class="emphasis">Contact</a>
    </li>

    <li>
      &nbsp; <!-- separate primary from secondary entries -->
    </li>

    <li class="secondary">
      <a href="index.html">FreeType Tutorial</a>
    </li>
    <li class="tertiary">
      <a href="step1.html">Simple Glyph Loading</a>
    </li>
    <li class="tertiary">
      <a href="step2.html" class="current">Managing Glyphs</a>
    </li>
    <li class="tertiary">
      <a href="step3.html">Examples</a>
    </li>
  </ul>
</div>

</div> <!-- id="wrapper" -->

<div id="TOC-bottom">
</div>

</body>
</html>
@


1.5
log
@
Sync freetype-doc with freetype, i.e. update freetype-doc to
ver. 2.6.2

ok matthieu@@
@
text
@d27 1
a27 1
          src="../javascript/jquery-1.11.0.min.js">
d30 1
a30 1
          src="../javascript/jquery.ba-resize.min.js">
d33 1
a33 1
          src="../javascript/freetype2.js">
@


1.4
log
@Update to freetype 2.4.12. tested by many during t2k13. Thanks.
@
text
@d1 5
a5 3
<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
a6 26
  <style type="text/css">
    body { font-family: Verdana, Geneva, Arial, Helvetica, serif;
           color: #000000;
           background: #FFFFFF; }

    p { text-align: justify; }
    h1 { text-align: center; }
    li { text-align: justify; }
    td { padding: 0 0.5em 0 0.5em; }

    a:link { color: #0000EF; }
    a:visited { color: #51188E; }
    a:hover { color: #FF0000; }

    div.pre { font-family: monospace;
              text-align:  left;
              white-space: pre;
              color:       blue; }

    div.example { font-family: monospace;
                  text-align:  left;
                  white-space: pre;
                  color:       purple; }

    span.comment { color: gray; }
  </style>
d8 7
a14 1
        content="text/html; charset=iso-8859-1">
a16 2
  <title>FreeType 2 Tutorial</title>
</head>
d18 17
a34 27
<body text="#000000"
      bgcolor="#FFFFFF"
      link="#0000EF"
      vlink="#51188E"
      alink="#FF0000">

<h1 align=center>
  FreeType&nbsp;2 Tutorial<br>
  Step&nbsp;2 &mdash; managing glyphs
</h1>

<h3 align=center>
  &copy; 2009 David Turner
    (<a href="mailto:david@@freetype.org">david@@freetype.org</a>)<br>
  &copy; 2009 The FreeType Development Team
    (<a href="http://www.freetype.org">www.freetype.org</a>)
</h3>

<center>
<table width="70%">
<tr><td>

  <hr>

  <h2>
    Introduction
  </h2>
d36 2
a37 2
  <p>This is the second section of the FreeType&nbsp;2 tutorial.  It
  describes how to</p>
a38 10
  <ul>
    <li>retrieve glyph metrics</li>
    <li>easily manage glyph images</li>
    <li>retrieve global metrics (including kerning)</li>
    <li>render a simple string of text, with kerning</li>
    <li>render a centered string of text (with kerning)</li>
    <li>render a transformed string of text (with centering)</li>
    <li>access metrics in design font units when needed,
        and how to scale them to device space</li>
  </ul>
d40 1
a40 1
    <hr>
d42 735
a776 205
    <h3>
      1.&nbsp;Glyph metrics
    </h3>

    <p>Glyph metrics are, as their name suggests, certain distances
    associated with each glyph in order to describe how to use it to layout
    text.</p>

    <p>There are usually two sets of metrics for a single glyph: Those used
    to layout the glyph in horizontal text layouts (Latin, Cyrillic, Arabic,
    Hebrew, etc.), and those used to layout the glyph in vertical text
    layouts (Chinese, Japanese, Korean, etc.).</p>

    <p>Note that only a few font formats provide vertical metrics.  You can
    test whether a given face object contains them by using the macro
    <tt>FT_HAS_VERTICAL</tt>, which is true when appropriate.</p>

    <p>Individual glyph metrics can be accessed by first loading the glyph
    in a face's glyph slot, then accessing them through the
    <tt>face-&gt;glyph-&gt;metrics</tt> structure, whose type is <a
    href="../reference/ft2-base_interface.html#FT_Glyph_Metrics">
    <tt>FT_Glyph_Metrics</tt></a>.  We will discuss this in more detail
    below; for now, we only note that it contains the following fields:</p>

    <center><table width="90%" cellpadding=5>
    <tr valign=top>
      <td>
        <tt>width</tt>
      </td>
      <td>
        <p>This is the width of the glyph image's bounding box.  It is
        independent of the layout direction.</p>
      </td>
    </tr>
    <tr valign=top>
      <td>
        <tt>height</tt>
      </td>
      <td>
        <p>This is the height of the glyph image's bounding box.  It is
        independent of the layout direction.  Be careful not to confuse it
        with the &lsquo;height&rsquo; field in the <a
        href="../reference/ft2-base_interface.html#FT_Size_Metrics">
        <tt>FT_Size_Metrics</tt></a> structure.</p>
      </td>
    </tr>
    <tr valign=top>
      <td>
        <tt>horiBearingX</tt>
      </td>
      <td>
        <p>For <em>horizontal text layouts</em>, this is the horizontal
        distance from the current cursor position to the leftmost border of
        the glyph image's bounding box.</p>
      </td>
    </tr>
    <tr valign=top>
      <td>
        <tt>horiBearingY</tt>
      </td>
      <td>
        <p>For <em>horizontal text layouts</em>, this is the vertical
        distance from the current cursor position (on the baseline) to the
        topmost border of the glyph image's bounding box.</p>
      </td>
    </tr>
    <tr valign=top>
      <td>
        <tt>horiAdvance</tt>
      </td>
      <td>
        <p>For <em>horizontal text layouts</em>, this is the horizontal
        distance used to increment the pen position when the glyph is drawn
        as part of a string of text.</p>
      </td>
    </tr>
    <tr valign=top>
      <td>
        <tt>vertBearingX</tt>
      </td>
      <td>
        <p>For <em>vertical text layouts</em>, this is the horizontal
        distance from the current cursor position to the leftmost border of
        the glyph image's bounding box.</p>
      </td>
    </tr>
    <tr valign=top>
      <td>
        <tt>vertBearingY</tt>
      </td>
      <td>
        <p>For <em>vertical text layouts</em>, this is the vertical distance
        from the current cursor position (on the baseline) to the topmost
        border of the glyph image's bounding box.</p>
      </td>
    </tr>
    <tr valign=top>
      <td>
        <tt>vertAdvance</tt>
      </td>
      <td>
        <p>For <em>vertical text layouts</em>, this is the vertical distance
        used to increment the pen position when the glyph is drawn as part
        of a string of text.</p>
      </td>
    </tr>
    </table>
    </center>

    <p><font color="red">NOTE: As not all fonts do contain vertical
    metrics, the values of <tt>vertBearingX</tt>, <tt>vertBearingY</tt> and
    <tt>vertAdvance</tt> should not be considered reliable when
    <tt>FT_HAS_VERTICAL</tt> is false.</font></p>

    <p>The following graphics illustrate the metrics more clearly.  First,
    for horizontal metrics, where the baseline is the horizontal axis:</p>

    <center>
      <img src="metrics.png" alt="horizontal layout" width=388 height=253>
    </center>

    <p>For vertical text layouts, the baseline is vertical, identical to the
    vertical axis:</p>

    <center>
      <img src="metrics2.png" alt="vertical layout" width=294 height=278>
    </center>

    <p>The metrics found in <tt>face-&gt;glyph-&gt;metrics</tt> are normally
    expressed in 26.6 pixel format (i.e., 1/64th of pixels), unless you use
    the <tt>FT_LOAD_NO_SCALE</tt> flag when calling <tt>FT_Load_Glyph</tt>
    or <tt>FT_Load_Char</tt>.  In this case, the metrics will be expressed
    in original font units.</p>

    <p>The glyph slot object has also a few other interesting fields that
    will ease a developer's work.  You can access them through
    <tt>face-&gt;glyph-&gt;xxx</tt>, where <tt>xxx</tt> is one of the
    following fields:</p>

    <center><table width="90%" cellpadding=5>
    <tr valign=top>
      <td>
        <tt>advance</tt>
      </td>
      <td>
        <p>This field is a <tt>FT_Vector</tt> which holds the transformed
        advance for the glyph.  That is useful when you are using a transform
        through <tt>FT_Set_Transform</tt>, as shown in the rotated text
        example of section&nbsp;I.  Other than that, its value is
        by default (metrics.horiAdvance,0), unless you specify
        <tt>FT_LOAD_VERTICAL</tt> when loading the glyph image;
        it will then be (0,metrics.vertAdvance)</p>
      </td>
    </tr>
    <tr valign=top>
      <td>
        <tt>linearHoriAdvance</tt>
      </td>
      <td>
        <p>This field contains the linearly scaled value of the glyph's
        horizontal advance width.  Indeed, the value of
        <tt>metrics.horiAdvance</tt> that is returned in the glyph slot is
        normally rounded to integer pixel coordinates (i.e., it will be a
        multiple of&nbsp;64) by the font driver used to load the glyph
        image.  <tt>linearHoriAdvance</tt> is a 16.16 fixed-point number
        that gives the value of the original glyph advance width in
        1/65536th of pixels.  It can be use to perform pseudo
        device-independent text layouts.</p>
      </td>
    </tr>
    <tr valign=top>
      <td>
        <tt>linearVertAdvance</tt>
      </td>
      <td>
        <p>This is the similar to <tt>linearHoriAdvance</tt> but for the
        glyph's vertical advance height.  Its value is only reliable if the
        font face contains vertical metrics.</p>
      </td>
    </tr>
    </table>
    </center>


    <hr>

    <h3>
      2.&nbsp;Managing glyph images
    </h3>

    <p>The glyph image that is loaded in a glyph slot can be converted into
    a bitmap, either by using <tt>FT_LOAD_RENDER</tt> when loading it, or by
    calling <tt>FT_Render_Glyph</tt>.  Each time you load a new glyph image,
    the previous one is erased from the glyph slot.</p>

    <p>There are situations, however, where you may need to extract this
    image from the glyph slot in order to cache it within your application,
    and even perform additional transformations and measures on it before
    converting it to a bitmap.</p>

    <p>The FreeType&nbsp;2 API has a specific extension which is capable of
    dealing with glyph images in a flexible and generic way.  To use it, you
    first need to include the <a
    href="../reference/ft2-header_file_macros.html#FT_GLYPH_H">
    <tt>FT_GLYPH_H</tt></a> header file, as in:</p>
d778 4
a781 3
    <div class="pre">
  #include FT_GLYPH_H
    </div>
a782 2
    <p>We will now explain how to use the functions defined in this
    file:</p>
d784 2
a785 3
      <h4>
        a.&nbsp;Extracting the glyph image:
      </h4>
d787 2
a788 2
      <p>You can extract a single glyph image very easily.  Here some code
      that shows how to do it:</p>
d790 4
a793 2
      <div class="pre">
  FT_Glyph  glyph; <span class="comment">/* a handle to the glyph image */</span>
d795 88
d884 4
a887 3
  ...
  error = FT_Load_Glyph( face, glyph_index, FT_LOAD_NORMAL );
  if ( error ) { ... }
a888 3
  error = FT_Get_Glyph( face-&gt;glyph, &amp;glyph );
  if ( error ) { ... }
      </div>
d890 2
a891 1
      <p>As you see, we have:</p>
d893 2
a894 83
      <ul>
        <li>
          <p>Created a variable, named <tt>glyph</tt>, of type <a
          href="../reference/ft2-glyph_management.html#FT_Glyph">
          <tt>FT_Glyph</tt></a>.  This is a handle (pointer) to an
          individual glyph image.</p>
        </li>

        <li>
          <p>Loaded the glyph image normally in the face's glyph slot.  We
          did not use <tt>FT_LOAD_RENDER</tt> because we want to grab a
          scalable glyph image, in order to later transform it.</p>
        </li>

        <li>
          <p>Copy the glyph image from the slot into a new <tt>FT_Glyph</tt>
          object, by calling <a
          href="../reference/ft2-glyph_management.html#FT_Get_Glyph">
          <tt>FT_Get_Glyph</tt></a>.  This function returns an error code
          and sets <tt>glyph</tt>.</p>
        </li>
      </ul>

      <p>It is important to note that the extracted glyph is in the same
      format as the original one that is still in the slot.  For example,
      if we are loading a glyph from a TrueType font file, the glyph image
      will really be a scalable vector outline.</p>

      <p>You can access the field <tt>glyph-&gt;format</tt> if you want to
      know exactly how the glyph is modeled and stored.  A new glyph object
      can be destroyed with a call to <a
      href="../reference/ft2-glyph_management.html#FT_Done_Glyph">
      <tt>FT_Done_Glyph</tt></a>.</p>

      <p>The glyph object contains exactly one glyph image and a 2D vector
      representing the glyph's advance in 16.16 fixed-point coordinates.
      The latter can be accessed directly as <tt>glyph-&gt;advance</tt></p>

      <p><font color="red">Note that unlike other FreeType objects, the
      library doesn't keep a list of all allocated glyph objects.  This
      means you have to destroy them yourself instead of relying on
      <tt>FT_Done_FreeType</tt> doing all the clean-up.</font></p>

      <h4>
        b.&nbsp;Transforming &amp; copying the glyph image
      </h4>

      <p>If the glyph image is scalable (i.e., if <tt>glyph-&gt;format</tt>
      is not equal to <tt>FT_GLYPH_FORMAT_BITMAP</tt>), it is possible to
      transform the image anytime by a call to <a
      href="../reference/ft2-glyph_management.html#FT_Glyph_Transform">
      <tt>FT_Glyph_Transform</tt></a>.</p>

      <p>You can also copy a single glyph image with <a
      href="../reference/ft2-glyph_management.html#FT_Glyph_Copy">
      <tt>FT_Glyph_Copy</tt></a>.  Here is some example code:</p>

      <div class="pre">
  FT_Glyph   glyph, glyph2;
  FT_Matrix  matrix;
  FT_Vector  delta;


  ... load glyph image in `glyph' ...

  <span class="comment">/* copy glyph to glyph2 */</span>

  error = FT_Glyph_Copy( glyph, &amp;glyph2 );
  if ( error ) { ... could not copy (out of memory) ... }

  <span class="comment">/* translate `glyph' */</span>

  delta.x = -100 * 64; <span class="comment">/* coordinates are in 26.6 pixel format */</span>
  delta.y =   50 * 64;

  FT_Glyph_Transform( glyph, 0, &amp;delta );

  <span class="comment">/* transform glyph2 (horizontal shear) */</span>

  matrix.xx = 0x10000L;
  matrix.xy = 0.12 * 0x10000L;
  matrix.yx = 0;
  matrix.yy = 0x10000L;
d896 3
a898 2
  FT_Glyph_Transform( glyph2, &amp;matrix, 0 );
      </div>
d900 4
a903 15
      <p>Note that the 2&times;2 transform matrix is always applied to the
      16.16 advance vector in the glyph; you thus don't need to recompute
      it.</p>

      <h4>
        c.&nbsp;Measuring the glyph image
      </h4>

      <p>You can also retrieve the control (bounding) box of any glyph image
      (scalable or not) through the <a
      href="../reference/ft2-glyph_management.html#FT_Glyph_Get_CBox">
      <tt>FT_Glyph_Get_CBox</tt></a> function, as in:</p>

      <div class="pre">
  FT_BBox  bbox;
d905 4
d910 2
a911 23
  ...
  FT_Glyph_Get_CBox( glyph, <em>bbox_mode</em>, &amp;bbox );
      </div>

      <p>Coordinates are relative to the glyph origin (0,0), using the
      y&nbsp;upwards convention.  This function takes a special argument,
      the <em>bbox mode</em>, to indicate how box coordinates are
      expressed.</p>

      <p>If the glyph has been loaded with <tt>FT_LOAD_NO_SCALE</tt>,
      <tt>bbox_mode</tt> must be set to <tt>FT_GLYPH_BBOX_UNSCALED</tt> to
      get unscaled font units in 26.6 pixel format.  The value
      <tt>FT_GLYPH_BBOX_SUBPIXELS</tt> is another name for this
      constant.</p>

      <p>Note that the box's maximum coordinates are exclusive, which means
      that you can always compute the width and height of the glyph image,
      be in in integer or 26.6 pixels, with:</p>

      <div class="pre">
  width  = bbox.xMax - bbox.xMin;
  height = bbox.yMax - bbox.yMin;
      </div>
d913 2
a914 10
      <p>Note also that for 26.6 coordinates, if
      <tt>FT_GLYPH_BBOX_GRIDFIT</tt> is used as the bbox mode, the
      coordinates will also be grid-fitted, which corresponds to</p>

      <div class="pre">
  bbox.xMin = FLOOR( bbox.xMin )
  bbox.yMin = FLOOR( bbox.yMin )
  bbox.xMax = CEILING( bbox.xMax )
  bbox.yMax = CEILING( bbox.yMax )
      </div>
d916 3
a918 2
      <p>To get the bbox in <em>integer</em> pixel coordinates, set
      <tt>bbox_mode</tt> to <tt>FT_GLYPH_BBOX_TRUNCATE</tt>.</p>
d920 3
a922 2
      <p>Finally, to get the bounding box in grid-fitted pixel coordinates,
      set <tt>bbox_mode</tt> to <tt>FT_GLYPH_BBOX_PIXELS</tt>.
d924 3
a926 3
      <h4>
        d.&nbsp;Converting the glyph image to a bitmap
      </h4>
d928 5
a932 5
      <p>You may need to convert the glyph object to a bitmap once you have
      conveniently cached or transformed it.  This can be done easily with
      the <a href="../reference/ft2-glyph_management.html">
      <tt>FT_Glyph_To_Bitmap</tt></a> function.  It is in charge of
      converting any glyph object into a bitmap, as in:</p>
a933 2
      <div class="pre">
  FT_Vector  origin;
d935 3
d939 3
a941 438
  origin.x = 32; <span class="comment">/* 1/2 pixel in 26.6 format */</span>
  origin.y = 0;

  error = FT_Glyph_To_Bitmap(
            &amp;glyph,
            <em>render_mode</em>,
            &amp;origin,
            1 );          <span class="comment">/* destroy original image == true */</span>
      </div>

      <p>Some notes:</p>

      <ul>
        <li>
          <p>The first parameter is the address of the source glyph's
          handle.  When the function is called, it reads its to access the
          source glyph object.  After the call, the handle will point to a
          <em>new</em> glyph object that contains the rendered bitmap.</p>
        </li>

        <li>
          <p>The second parameter is a standard render mode, that is used to
          specify what kind of bitmap we want.  It can be
          <tt>FT_RENDER_MODE_DEFAULT</tt> for an 8-bit anti-aliased pixmap,
          or <tt>FT_RENDER_MODE_MONO</tt> for a 1-bit monochrome bitmap.</p>
        </li>

        <li>
          <p>The third parameter is a pointer to a two-dimensional vector
          that is used to translate the source glyph image before the
          conversion.  Note that the source image will be translated back to
          its original position (and will thus be left unchanged) after the
          call.  If you do not need to translate the source glyph before
          rendering, set this pointer to&nbsp;0.</p>
        </li>

        <li>
          <p>The last parameter is a boolean that indicates whether the
          source glyph object should be destroyed by the function.  If
          false, the original glyph object is never destroyed, even if its
          handle is lost (it is up to client applications to keep it).</p>
        </li>
      </ul>

      <p>The new glyph object always contains a bitmap (if no error is
      returned), and you must <em>typecast</em> its handle to the
      <tt>FT_BitmapGlyph</tt> type in order to access its content.  This
      type is a sort of &lsquo;subclass&rsquo; of <tt>FT_Glyph</tt> that
      contains additional fields (see <a
      href="../reference/ft2-glyph_management.html#FT_BitmapGlyphRec">
      <tt>FT_BitmapGlyphRec</tt></a>):</p>

      <center>
      <table width="80%" cellpadding=5>
      <tr valign=top>
        <td>
          <tt>left</tt>
        </td>
        <td>
          <p>Just like the <tt>bitmap_left</tt> field of a glyph slot, this
          is the horizontal distance from the glyph origin (0,0) to the
          leftmost pixel of the glyph bitmap.  It is expressed in integer
          pixels.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>top</tt>
        </td>
        <td>
          <p>Just like the <tt>bitmap_top</tt> field of a glyph slot, this
          is the vertical distance from the glyph origin (0,0) to the
          topmost pixel of the glyph bitmap (more precise, to the pixel just
          above the bitmap).  This distance is expressed in integer pixels,
          and is positive for upwards&nbsp;y.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>bitmap</tt>
        </td>
        <td>
          <p>This is a bitmap descriptor for the glyph object, just like the
          <tt>bitmap</tt> field in a glyph slot.</p>
        </td>
      </tr>
      </table>
      </center>

    <hr>

    <h3>
      3.&nbsp;Global glyph metrics
    </h3>

    <p>Unlike glyph metrics, global metrics are used to describe distances
    and features of a whole font face.  They can be expressed either in 26.6
    pixel format or in design &lsquo;font units&rsquo; for scalable
    formats.</p>

      <h4>
        a.&nbsp;Design global metrics
      </h4>

      <p>For scalable formats, all global metrics are expressed in font
      units in order to be later scaled to the device space, according to
      the rules described in the last chapter of this section of the
      tutorial.  You can access them directly as simple fields of a
      <tt>FT_Face</tt> handle.</p>

      <p>However, you need to check that the font face's format is scalable
      before using them.  One can do it by using the macro
      <tt>FT_IS_SCALABLE</tt> which returns true when appropriate.</p>

      <p>In this case, you can access the global design metrics as:</p>

      <center>
      <table width="90%" cellpadding=5>
      <tr valign=top>
        <td>
          <tt>units_per_EM</tt>
        </td>
        <td>
          <p>This is the size of the EM square for the font face.  It is
          used by scalable formats to scale design coordinates to device
          pixels, as described in the last chapter of this section.  Its
          value usually is 2048 (for TrueType) or 1000 (for Type&nbsp;1),
          but others are possible too.  It is set to&nbsp;1 for fixed-size
          formats like FNT/FON/PCF/BDF.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>bbox</tt>
        </td>
        <td>
          <p>The global bounding box is defined as the largest rectangle
          that can enclose all the glyphs in a font face.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>ascender</tt>
        </td>
        <td>
          <p>The ascender is the vertical distance from the horizontal
          baseline to the highest &lsquo;character&rsquo; coordinate in a
          font face.  Unfortunately, font formats define the ascender
          differently.  For some, it represents the ascent of all capital
          latin characters (without accents), for others it is the ascent of
          the highest accented character, and finally, other formats define
          it as being equal to <tt>bbox.yMax</tt>.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>descender</tt>
        </td>
        <td>
          <p>The descender is the vertical distance from the horizontal
          baseline to the lowest &lsquo;character&rsquo; coordinate in a
          font face.  Unfortunately, font formats define the descender
          differently.  For some, it represents the descent of all capital
          latin characters (without accents), for others it is the ascent of
          the lowest accented character, and finally, other formats define
          it as being equal to <tt>bbox.yMin</tt>.  This field is
          negative for values below the baseline.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>height</tt>
        </td>
        <td>
          <p>This field is simply used to compute a <i>default</i> line
          spacing (i.e., the baseline-to-baseline distance) when writing
          text with this font.  Note that it usually is larger than the sum
          of the ascender and descender taken as absolute values.  There is
          also no guarantee that no glyphs extend above or below subsequent
          baselines when using this distance.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>max_advance_width</tt>
        </td>
        <td>
          <p>This field gives the maximum horizontal cursor advance for all
          glyphs in the font.  It can be used to quickly compute the maximum
          advance width of a string of text.  <em>It doesn't correspond to
          the maximum glyph image width!</em></p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>max_advance_height</tt>
        </td>
        <td>
          <p>Same as <tt>max_advance_width</tt> but for vertical text
          layout.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>underline_position</tt>
        </td>
        <td>
          <p>When displaying or rendering underlined text, this value
          corresponds to the vertical position, relative to the baseline, of
          the underline bar's center.  It is negative if it is below the
          baseline.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>underline_thickness</tt>
        </td>
        <td>
          <p>When displaying or rendering underlined text, this value
          corresponds to the vertical thickness of the underline.</p>
        </td>
      </tr>
      </table>
      </center>

      <p>Notice how, unfortunately, the values of the ascender and the
      descender are not reliable (due to various discrepancies in font
      formats).</p>

      <h4>
        b.&nbsp;Scaled global metrics
      </h4>

      <p>Each size object also contains a scaled versions of some of the
      global metrics described above.  They can be accessed directly through
      the <tt>face-&gt;size-&gt;metrics</tt> structure.</p>

      <p>Note that these values correspond to scaled versions of the design
      global metrics, <em>with no rounding or grid-fitting performed</em>.
      They are also completely independent of any hinting process.  In other
      words, don't rely on them to get exact metrics at the pixel level.
      They are expressed in 26.6 pixel format.</p>

      <center>
      <table width="80%" cellpadding=5>
      <tr valign=top>
        <td>
         <tt>ascender</tt>
        </td>
        <td>
          <p>The scaled version of the original design ascender.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>descender</tt>
        </td>
        <td>
          <p>The scaled version of the original design descender.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>height</tt>
        </td>
        <td>
          <p>The scaled version of the original design text height (the
          vertical distance from one baseline to the next).  This is
          probably the only field you should really use in this
          structure.</p>

          <p>Be careful not to confuse it with the &lsquo;height&rsquo;
          field in the <a
          href="../reference/ft2-base_interface.html#FT_Glyph_Metrics">
          <tt>FT_Glyph_Metrics</tt></a> structure.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>max_advance</tt>
        </td>
        <td>
          <p>The scaled version of the original design max advance.</p>
        </td>
      </tr>
      </table>
      </center>

      <p>Note that the <tt>face-&gt;size-&gt;metrics</tt> structure contains
      other fields that are used to scale design coordinates to device
      space.  They are described in the last chapter.</p>

      <h4>
        c.&nbsp;Kerning
      </h4>

      <p>Kerning is the process of adjusting the position of two subsequent
      glyph images in a string of text in order to improve the general
      appearance of text.  Basically, it means that when the glyph for an
      &lsquo;A&rsquo; is followed by the glyph for a &lsquo;V&rsquo;, the
      space between them can be slightly reduced to avoid extra
      &lsquo;diagonal whitespace&rsquo;.</p>

      <p>Note that in theory kerning can happen both in the horizontal and
      vertical direction between two glyphs; however, it only happens in the
      horizontal direction in nearly all cases except really extreme
      ones.</p>

      <p>Not all font formats contain kerning information, and not all
      kerning formats are supported by FreeType; in particular, for TrueType
      fonts, the API can only access kerning via the &lsquo;kern&rsquo;
      table; <b>OpenType kerning via the &lsquo;GPOS&rsquo; table is not
      supported.</b> You need a higher-level library like <a
      href="http://www.pango.org">Pango</a> or <a
      href="http://www.icu-project.org">ICU</a> to handle that.</p>

      <p>Sometimes, the font file is associated with an additional file that
      contains various glyph metrics, including kerning, but no glyph
      images.  A good example is the Type&nbsp;1 format where glyph images
      are stored in a file with extension <tt>.pfa</tt> or <tt>.pfb</tt>,
      and where kerning metrics can be found in a file with extension
      <tt>.afm</tt> or <tt>.pfm</tt>.</p>

      <p>FreeType&nbsp;2 allows you to deal with this, by providing the <a
      href="../reference/ft2-base_interface.html#FT_Attach_File">
      <tt>FT_Attach_File</tt></a> and <a
      href="../reference/ft2-base_interface.html#FT_Attach_Stream">
      <tt>FT_Attach_Stream</tt></A> APIs.  Both functions are used to load
      additional metrics into a face object by reading them from an
      additional format-specific file.  For example, you could open a
      Type&nbsp;1 font by doing the following:</p>

      <div class="pre">
  error = FT_New_Face( library, "/usr/shared/fonts/cour.pfb",
                       0, &amp;face );
  if ( error ) { ... }

  error = FT_Attach_File( face, "/usr/shared/fonts/cour.afm" );
  if ( error )
  { ... could not read kerning and additional metrics ... }
      </div>

      <p>Note that <tt>FT_Attach_Stream</tt> is similar to
      <tt>FT_Attach_File</tt> except that it doesn't take a C&nbsp;string to
      name the extra file but a <tt>FT_Stream</tt> handle.  Also,
      <em>reading a metrics file is in no way mandatory</em>.</p>

      <p>Finally, the file attachment APIs are very generic and can be used
      to load any kind of extra information for a given face.  The nature of
      the additional content is entirely font format specific.</p>

      <p>FreeType&nbsp;2 allows you to retrieve the kerning information for
      two glyphs through the <tt>FT_Get_Kerning</tt> function, whose
      interface looks like:</p>

      <div class="pre">
  FT_Vector  kerning;


  ...
  error = FT_Get_Kerning( face,          <span class="comment">/* handle to face object */</span>
                          left,          <span class="comment">/* left glyph index      */</span>
                          right,         <span class="comment">/* right glyph index     */</span>
                          <em>kerning_mode</em>,  <span class="comment">/* kerning mode          */</span>
                          &amp;kerning );    <span class="comment">/* target vector         */</span>
      </div>

      <p>As you see, the function takes a handle to a face object, the
      indices of the left and right glyph for which the kerning value is
      desired, as well as an integer, called the <em>kerning mode</em>, and
      a pointer to a destination vector that receives the corresponding
      distances.</p>

      <p>The kerning mode is very similar to the <em>bbox mode</em>
      described in a previous chapter.  It is a enumeration that indicates
      how the kerning distances are expressed in the target vector.</p>

      <p>The default value is <tt>FT_KERNING_DEFAULT</tt> which has
      value&nbsp;0.  It corresponds to kerning distances expressed in 26.6
      grid-fitted pixels (which means that the values are multiples of 64).
      For scalable formats, this means that the design kerning distance is
      scaled, then rounded.</p>

      <p>The value <tt>FT_KERNING_UNFITTED</tt> corresponds to kerning
      distances expressed in 26.6 unfitted pixels (i.e., that do not
      correspond to integer coordinates).  It is the design kerning distance
      that is scaled without rounding.</p>

      <p>Finally, the value <tt>FT_KERNING_UNSCALED</tt> is used to return
      the design kerning distance, expressed in font units.  You can later
      scale it to the device space using the computations explained in the
      last chapter of this section.</p>

      <p>Note that the &lsquo;left&rsquo; and &lsquo;right&rsquo; positions
      correspond to the <em>visual order</em> of the glyphs in the string of
      text.  This is important for bidirectional text, or simply when
      writing right-to-left text.</p>

    <hr>

    <h3>
      4.&nbsp;Simple text rendering: kerning + centering
    </h3>

    <p>In order to show off what we just learned, we will now demonstrate
    how to modify the example code that was provided in section&nbsp;I to
    render a string of text, and enhance it to support kerning and delayed
    rendering.</p>

      <h4>
       a.&nbsp;Kerning support
      </h4>

      <p>Adding support for kerning to our code is trivial, as long as we
      consider that we are still dealing with a left-to-right script like
      Latin.  We simply need to retrieve the kerning distance between two
      glyphs in order to alter the pen position appropriately.  The code
      looks like:</p>

      <div class="pre">
  FT_GlyphSlot  slot = face-&gt;glyph;  <span class="comment">/* a small shortcut */</span>
  FT_UInt       glyph_index;
  FT_Bool       use_kerning;
  FT_UInt       previous;
  int           pen_x, pen_y, n;


  ... initialize library ...
  ... create face object ...
  ... set character size ...

  pen_x = 300;
  pen_y = 200;

  use_kerning = FT_HAS_KERNING( face );
  previous    = 0;

  for ( n = 0; n &lt; num_chars; n++ )
d943 2
a944 7
    <span class="comment">/* convert character code to glyph index */</span>
    glyph_index = FT_Get_Char_Index( face, text[n] );

    <span class="comment">/* retrieve kerning distance and move pen position */</span>
    if ( use_kerning &amp;&amp; previous &amp;&amp; glyph_index )
    {
      FT_Vector  delta;
d946 4
d951 2
a952 2
      FT_Get_Kerning( face, previous, glyph_index,
                      FT_KERNING_DEFAULT, &amp;delta );
d954 2
a955 2
      pen_x += delta.x &gt;&gt; 6;
    }
d957 2
a958 4
    <span class="comment">/* load glyph image into the slot (erase previous one) */</span>
    error = FT_Load_Glyph( face, glyph_index, FT_LOAD_RENDER );
    if ( error )
      continue;  <span class="comment">/* ignore errors */</span>
d960 2
a961 10
    <span class="comment">/* now draw to our target surface */</span>
    my_draw_bitmap( &amp;slot-&gt;bitmap,
                    pen_x + slot-&gt;bitmap_left,
                    pen_y - slot-&gt;bitmap_top );

    <span class="comment">/* increment pen position */</span>
    pen_x += slot->advance.x &gt;&gt; 6;

    <span class="comment">/* record current glyph index */</span>
    previous = glyph_index;
a962 1
      </div>
d964 2
a965 80
      <p>We are done.  Some notes:</p>

      <ul>
        <li>

          <p>As kerning is determined from glyph indices, we need to
          explicitly convert our character codes into glyph indices, then
          later call <tt>FT_Load_Glyph</tt> instead of
          <tt>FT_Load_Char</tt>.</p>
        </li>

        <li>
          <p>We use a boolean named <tt>use_kerning</tt> which is set with
          the result of the macro <tt>FT_HAS_KERNING</tt>.  It is certainly
          faster not to call <tt>FT_Get_Kerning</tt> when we know that the
          font face does not contain kerning information.</p>
        </li>

       <li>
          <p>We move the position of the pen <em>before</em> a new glyph is
          drawn.</p>
        </li>

       <li>
          <p>We initialize the variable <tt>previous</tt> with the
          value&nbsp;0, which always corresponds to the &lsquo;missing
          glyph&rsquo; (also called <tt>.notdef</tt> in the Postscript
          world).  There is never any kerning distance associated with this
          glyph.</p>
        </li>

        <li>
          <p>We do not check the error code returned by
          <tt>FT_Get_Kerning</tt>.  This is because the function always sets
          the content of <tt>delta</tt> to (0,0) when an error occurs.</p>
        </li>
      </ul>

      <h4>
        b.&nbsp;Centering
      </h4>

      <p>Our code begins to become interesting but it is still a bit too
      simple for normal use.  For example, the position of the pen is
      determined before we do the rendering; normally, you would rather
      layout the text and measure it before computing its final position
      (centering, etc.) or perform things like word-wrapping.</p>

      <p>Let us now decompose our text rendering function into two distinct
      but successive parts: The first one will position individual glyph
      images on the baseline, while the second one will render the glyphs.
      As we will see, this has many advantages.</p>

      <p>We will thus start by storing individual glyph images, as well as
      their position on the baseline.  This can be done with code like:</p>

      <div class="pre">
  FT_GlyphSlot  slot = face-&gt;glyph;   <span class="comment">/* a small shortcut */</span>
  FT_UInt       glyph_index;
  FT_Bool       use_kerning;
  FT_UInt       previous;
  int           pen_x, pen_y, n;

  FT_Glyph      glyphs[MAX_GLYPHS];   <span class="comment">/* glyph image    */</span>
  FT_Vector     pos   [MAX_GLYPHS];   <span class="comment">/* glyph position */</span>
  FT_UInt       num_glyphs;


  ... initialize library ...
  ... create face object ...
  ... set character size ...

  pen_x = 0;   <span class="comment">/* start at (0,0) */</span>
  pen_y = 0;

  num_glyphs  = 0;
  use_kerning = FT_HAS_KERNING( face );
  previous    = 0;

  for ( n = 0; n &lt; num_chars; n++ )
d967 5
a971 2
    <span class="comment">/* convert character code to glyph index */</span>
    glyph_index = FT_Get_Char_Index( face, text[n] );
d973 27
a999 4
    <span class="comment">/* retrieve kerning distance and move pen position */</span>
    if ( use_kerning &amp;&amp; previous &amp;&amp; glyph_index )
    {
      FT_Vector  delta;
d1001 4
a1005 2
      FT_Get_Kerning( face, previous, glyph_index,
                      FT_KERNING_DEFAULT, &amp;delta );
d1007 1
a1007 2
      pen_x += delta.x &gt;&gt; 6;
    }
d1009 2
a1010 3
    <span class="comment">/* store current pen position */</span>
    pos[num_glyphs].x = pen_x;
    pos[num_glyphs].y = pen_y;
d1012 5
a1016 4
    <span class="comment">/* load glyph image into the slot without rendering */</span>
    error = FT_Load_Glyph( face, glyph_index, FT_LOAD_DEFAULT );
    if ( error )
      continue;  <span class="comment">/* ignore errors, jump to next glyph */</span>
a1017 4
    <span class="comment">/* extract glyph image and store it in our table */</span>
    error = FT_Get_Glyph( face-&gt;glyph, &amp;glyphs[num_glyphs] );
    if ( error )
      continue;  <span class="comment">/* ignore errors, jump to next glyph */</span>
d1019 3
a1021 2
    <span class="comment">/* increment pen position */</span>
    pen_x += slot->advance.x &gt;&gt; 6;
d1023 3
a1025 2
    <span class="comment">/* record current glyph index */</span>
    previous = glyph_index;
d1027 1
a1027 4
    <span class="comment">/* increment number of glyphs */</span>
    num_glyphs++;
  }
      </div>
d1029 82
a1110 7
      <p>This is a very slight variation of our previous code where we
      extract each glyph image from the slot, and store it, along with the
      corresponding position, in our tables.</p>

      <p>Note also that <tt>pen_x</tt> contains the total advance for the
      string of text.  We can now compute the bounding box of the text
      string with a simple function like:</p>
d1112 1
a1112 2
      <div class="pre">
  void  compute_string_bbox( FT_BBox  *abbox )
d1114 1
a1114 2
    FT_BBox  bbox;
    FT_BBox  glyph_bbox;
d1117 2
a1118 37
    <span class="comment">/* initialize string bbox to "empty" values */</span>
    bbox.xMin = bbox.yMin =  32000;
    bbox.xMax = bbox.yMax = -32000;

    <span class="comment">/* for each glyph image, compute its bounding box, */</span>
    <span class="comment">/* translate it, and grow the string bbox          */</span>
    for ( n = 0; n &lt; num_glyphs; n++ )
    {
      FT_Glyph_Get_CBox( glyphs[n], ft_glyph_bbox_pixels,
                         &amp;glyph_bbox );

      glyph_bbox.xMin += pos[n].x;
      glyph_bbox.xMax += pos[n].x;
      glyph_bbox.yMin += pos[n].y;
      glyph_bbox.yMax += pos[n].y;

      if ( glyph_bbox.xMin &lt; bbox.xMin )
        bbox.xMin = glyph_bbox.xMin;

      if ( glyph_bbox.yMin &lt; bbox.yMin )
        bbox.yMin = glyph_bbox.yMin;

      if ( glyph_bbox.xMax &gt; bbox.xMax )
        bbox.xMax = glyph_bbox.xMax;

      if ( glyph_bbox.yMax &gt; bbox.yMax )
        bbox.yMax = glyph_bbox.yMax;
    }

    <span class="comment">/* check that we really grew the string bbox */</span>
    if ( bbox.xMin &gt; bbox.xMax )
    {
      bbox.xMin = 0;
      bbox.yMin = 0;
      bbox.xMax = 0;
      bbox.yMax = 0;
    }
d1120 1
a1120 2
    <span class="comment">/* return string bbox */</span>
    *abbox = bbox;
a1121 1
      </div>
d1123 3
a1125 12
      <p>The resulting bounding box dimensions are expressed in integer
      pixels and can then be used to compute the final pen position before
      rendering the string as in:</p>

      <div class="pre">
  <span class="comment">/* compute string dimensions in integer pixels */</span>
  string_width  = string_bbox.xMax - string_bbox.xMin;
  string_height = string_bbox.yMax - string_bbox.yMin;

  <span class="comment">/* compute start pen position in 26.6 cartesian pixels */</span>
  start_x = ( ( my_target_width  - string_width  ) / 2 ) * 64;
  start_y = ( ( my_target_height - string_height ) / 2 ) * 64;
d1127 2
a1128 4
  for ( n = 0; n &lt; num_glyphs; n++ )
  {
    FT_Glyph   image;
    FT_Vector  pen;
d1130 2
d1133 2
a1134 1
    image = glyphs[n];
d1136 2
a1137 2
    pen.x = start_x + pos[n].x;
    pen.y = start_y + pos[n].y;
d1139 3
a1141 5
    error = FT_Glyph_To_Bitmap( &amp;image, FT_RENDER_MODE_NORMAL,
                                &amp;pen, 0 );
    if ( !error )
    {
      FT_BitmapGlyph  bit = (FT_BitmapGlyph)image;
d1143 2
d1146 3
a1148 3
      my_draw_bitmap( bit-&gt;bitmap,
                      bit-&gt;left,
                      my_target_height - bit-&gt;top );
d1150 4
a1153 4
      FT_Done_Glyph( image );
    }
  }
      </div>
a1154 1
      <p>Some remarks:</p>
d1156 2
a1157 51
      <ul>
        <li>
          <p>The pen position is expressed in the cartesian space (i.e.,
          y&nbsp;upwards).</p>
        </li>

        <li>
          <p>We call <tt>FT_Glyph_To_Bitmap</tt> with the <tt>destroy</tt>
          parameter set to&nbsp;0 (false), in order to avoid destroying the
          original glyph image.  The new glyph bitmap is accessed through
          <tt>image</tt> after the call and is typecast to
          <tt>FT_BitmapGlyph</tt>.</p>
        </li>

        <li>
          <p>We use translation when calling <tt>FT_Glyph_To_Bitmap</tt>.
          This ensures that the <tt>left</tt> and <tt>top</tt> fields of the
          bitmap glyph object are already set to the correct pixel
          coordinates in the cartesian space.</p>
        </li>

        <li>
          <p>Of course, we still need to convert pixel coordinates from
          cartesian to device space before rendering, hence the
          <tt>my_target_height - bitmap->top</tt> in the call to
          <tt>my_draw_bitmap</tt>.</p>
        </li>
      </ul>

      <p>The same loop can be used to render the string anywhere on our
      display surface, without the need to reload our glyph images each
      time.  We could also decide to implement word wrapping, and only
      draw</p>

    <hr>

    <h3>
      5.&nbsp;Advanced text rendering: transformation + centering + kerning
    </h3>

    <p>We are now going to modify our code in order to be able to easily
    transform the rendered string, for example to rotate it.  We will start
    by performing a few minor improvements:</p>

      <h4>
        a.&nbsp;packing &amp; translating glyphs
      </h4>

      <p>We start by packing the information related to a single glyph image
      into a single structure instead of parallel arrays.  We thus define
      the following structure type:</p>
d1159 1
a1159 2
      <div class="pre">
  typedef struct  TGlyph_
d1161 1
a1161 42
    FT_UInt    index;  <span class="comment">/* glyph index                  */</span>
    FT_Vector  pos;    <span class="comment">/* glyph origin on the baseline */</span>
    FT_Glyph   image;  <span class="comment">/* glyph image                  */</span>

  } TGlyph, *PGlyph;
      </div>

      <p>We also translate each glyph image directly after it is loaded to
      its position on the baseline at load time.  As we will see, this has
      several advantages.  Our glyph sequence loader thus becomes:</p>

      <div class="pre">
  FT_GlyphSlot  slot = face-&gt;glyph;  <span class="comment">/* a small shortcut */</span>
  FT_UInt       glyph_index;
  FT_Bool       use_kerning;
  FT_UInt       previous;
  int           pen_x, pen_y, n;

  TGlyph        glyphs[MAX_GLYPHS];  <span class="comment">/* glyphs table */</span>
  PGlyph        glyph;               <span class="comment">/* current glyph in table */</span>
  FT_UInt       num_glyphs;


  ... initialize library ...
  ... create face object ...
  ... set character size ...

  pen_x = 0;   <span class="comment">/* start at (0,0) */</span>
  pen_y = 0;

  num_glyphs  = 0;
  use_kerning = FT_HAS_KERNING( face );
  previous    = 0;

  glyph = glyphs;
  for ( n = 0; n &lt; num_chars; n++ )
  {
    glyph-&gt;index = FT_Get_Char_Index( face, text[n] );

    if ( use_kerning &amp;&amp; previous &amp;&amp; glyph->index )
    {
      FT_Vector  delta;
d1164 2
a1165 2
      FT_Get_Kerning( face, previous, glyph-&gt;index,
                      FT_KERNING_MODE_DEFAULT, &amp;delta );
d1167 2
a1168 2
      pen_x += delta.x &gt;&gt; 6;
    }
d1170 2
a1171 3
    <span class="comment">/* store current pen position */</span>
    glyph->pos.x = pen_x;
    glyph->pos.y = pen_y;
d1173 2
a1174 2
    error = FT_Load_Glyph( face, glyph_index, FT_LOAD_DEFAULT );
    if ( error ) continue;
d1176 2
a1177 11
    error = FT_Get_Glyph( face-&gt;glyph, &amp;glyph-&gt;image );
    if ( error ) continue;

    <span class="comment">/* translate the glyph image now */</span>
    FT_Glyph_Transform( glyph-&gt;image, 0, &amp;glyph-&gt;pos );

    pen_x   += slot->advance.x &gt;&gt; 6;
    previous = glyph->index;

    <span class="comment">/* increment number of glyphs */</span>
    glyph++;
d1180 1
a1180 10
  <span class="comment">/* count number of glyphs loaded */</span>
  num_glyphs = glyph - glyphs;
      </div>

      <p>Note that translating glyphs now has several advantages.  The first
      one is that we don't need to translate the glyph bbox when we compute
      the string's bounding box.  The code becomes:</p>

      <div class="pre">
  void  compute_string_bbox( FT_BBox  *abbox )
d1182 5
a1186 5
    FT_BBox  bbox;


    bbox.xMin = bbox.yMin =  32000;
    bbox.xMax = bbox.yMax = -32000;
d1188 2
a1189 3
    for ( n = 0; n &lt; num_glyphs; n++ )
    {
      FT_BBox  glyph_bbox;
d1191 4
d1196 4
a1199 2
      FT_Glyph_Get_CBox( glyphs[n], ft_glyph_bbox_pixels,
                         &amp;glyph_bbox );
a1200 2
      if (glyph_bbox.xMin &lt; bbox.xMin)
        bbox.xMin = glyph_bbox.xMin;
d1202 2
a1203 2
      if (glyph_bbox.yMin &lt; bbox.yMin)
        bbox.yMin = glyph_bbox.yMin;
d1205 3
a1207 2
      if (glyph_bbox.xMax &gt; bbox.xMax)
        bbox.xMax = glyph_bbox.xMax;
d1209 2
a1210 3
      if (glyph_bbox.yMax &gt; bbox.yMax)
        bbox.yMax = glyph_bbox.yMax;
    }
d1212 1
a1212 7
    if ( bbox.xMin > bbox.xMax )
    {
      bbox.xMin = 0;
      bbox.yMin = 0;
      bbox.xMax = 0;
      bbox.yMax = 0;
    }
d1214 5
a1218 3
    *abbox = bbox;
  }
      </div>
d1220 3
a1222 3
      <p>Now take a closer look: The <tt>compute_string_bbox</tt> function
      can now compute the bounding box of a transformed glyph string.  For
      example, we can do something like:</p>
d1224 3
a1226 4
      <div class="pre">
  FT_BBox    bbox;
  FT_Matrix  matrix;
  FT_Vector  delta;
d1229 2
a1230 2
  ... load glyph sequence ...
  ... set up "matrix" and "delta" ...
d1232 3
a1234 3
  <span class="comment">/* transform glyphs */</span>
  for ( n = 0; n &lt; num_glyphs; n++ )
    FT_Glyph_Transform( glyphs[n].image, &amp;matrix, &amp;delta );
d1236 3
a1238 3
  <span class="comment">/* compute bounding box of transformed glyphs */</span>
  compute_string_bbox( &amp;bbox );
      </div>
d1240 5
a1244 13
      <h4>
        b.&nbsp;Rendering a transformed glyph sequence
      </h4>

      <p>However, directly transforming the glyphs in our sequence is not a
      good idea if we want to reuse them in order to draw the text string
      with various angles or transformations.  It is better to perform the
      affine transformation just before the glyph is rendered, as in the
      following code:</p>

      <div class="pre">
  FT_Vector  start;
  FT_Matrix  matrix;
d1246 1
a1246 3
  FT_Glyph   image;
  FT_Vector  pen;
  FT_BBox    bbox;
d1248 5
d1254 3
a1256 2
  <span class="comment">/* get bbox of original glyph sequence */</span>
  compute_string_bbox( &amp;string_bbox );
d1258 6
a1263 3
  <span class="comment">/* compute string dimensions in integer pixels */</span>
  string_width  = (string_bbox.xMax - string_bbox.xMin) / 64;
  string_height = (string_bbox.yMax - string_bbox.yMin) / 64;
d1265 9
a1273 3
  <span class="comment">/* set up start position in 26.6 cartesian space */</span>
  start.x = ( ( my_target_width  - string_width  ) / 2 ) * 64;
  start.y = ( ( my_target_height - string_height ) / 2 ) * 64;
a1274 5
  <span class="comment">/* set up transform (a rotation here) */</span>
  matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );
  matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );
  matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );
  matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );
d1276 3
a1278 1
  pen = start;
d1280 6
a1285 38
  for ( n = 0; n &lt; num_glyphs; n++ )
  {
    <span class="comment">/* create a copy of the original glyph */</span>
    error = FT_Glyph_Copy( glyphs[n].image, &amp;image );
    if ( error ) continue;

    <span class="comment">/* transform copy (this will also translate it to the */</span>
    <span class="comment">/* correct position                                   */</span>
    FT_Glyph_Transform( image, &amp;matrix, &amp;pen );

    <span class="comment">/* check bounding box; if the transformed glyph image      */</span>
    <span class="comment">/* is not in our target surface, we can avoid rendering it */</span>
    FT_Glyph_Get_CBox( image, ft_glyph_bbox_pixels, &amp;bbox );
    if ( bbox.xMax &lt;= 0 || bbox.xMin &gt;= my_target_width  ||
         bbox.yMax &lt;= 0 || bbox.yMin &gt;= my_target_height )
      continue;

    <span class="comment">/* convert glyph image to bitmap (destroy the glyph copy!) */</span>
    error = FT_Glyph_To_Bitmap(
              &amp;image,
              FT_RENDER_MODE_NORMAL,
              0,                  <span class="comment">/* no additional translation */</span>
              1 );                <span class="comment">/* destroy copy in "image"   */</span>
    if ( !error )
    {
      FT_BitmapGlyph  bit = (FT_BitmapGlyph)image;


      my_draw_bitmap( bit-&gt;bitmap,
                      bit-&gt;left,
                      my_target_height - bit-&gt;top );

      <span class="comment">/* increment pen position --                       */</span>
      <span class="comment">/* we don't have access to a slot structure,       */</span>
      <span class="comment">/* so we have to use advances from glyph structure */</span>
      <span class="comment">/* (which are in 16.16 fixed float format)         */</span>
      pen.x += image.advance.x >> 10;
      pen.y += image.advance.y >> 10;
d1287 1
a1287 2
      FT_Done_Glyph( image );
    }
d1289 1
a1289 1
      </div>
d1291 2
a1292 2
      <p>There are a few changes compared to the original version of this
      code:</p>
d1294 82
a1375 79
      <ul>
        <li>
          <p>We keep the original glyph images untouched; instead, we
          transform a copy.</p>
        </li>

        <li>
          <p>We perform clipping computations in order to avoid rendering
          &amp; drawing glyphs that are not within our target surface</p>
        </li>

        <li>
          <p>We always destroy the copy when calling
          <tt>FT_Glyph_To_Bitmap</tt> in order to get rid of the transformed
          scalable image.  Note that the image is not destroyed if the
          function returns an error code (which is why
          <tt>FT_Done_Glyph</tt> is only called within the compound
          statement.</p>
        </li>

        <li>
          <p>The translation of the glyph sequence to the start pen position
          is integrated in the call to <tt>FT_Glyph_Transform</tt> instead
          of <tt>FT_Glyph_To_Bitmap</tt>.</p>
        </li>
      </ul>

      <p>It is possible to call this function several times to render the
      string width different angles, or even change the way <tt>start</tt>
      is computed in order to move it to different place.</p>

      <p>This code is the basis of the FreeType&nbsp;2 demonstration program
      named <tt>ftstring.c</tt>.  It could be easily extended to perform
      advanced text layout or word-wrapping in the first part, without
      changing the second one.</p>

      <p>Note, however, that a normal implementation would use a glyph cache
      in order to reduce memory needs.  For example, let us assume that our
      text string is &lsquo;FreeType&rsquo'.  We would store three identical
      glyph images in our table for the letter &lsquo;e&rsquo;, which isn't
      optimal (especially when you consider longer lines of text, or even
      whole pages).</p>

    <hr>

    <h3>
      6.&nbsp;Accessing metrics in design font units, and scaling them
    </h3>

    <p>Scalable font formats usually store a single vectorial image, called
    an <em>outline</em>, for each glyph in a face.  Each outline is defined
    in an abstract grid called the <em>design space</em>, with coordinates
    expressed in nominal <em>font units</em>.  When a glyph image is loaded,
    the font driver usually scales the outline to device space according to
    the current character pixel size found in a <tt>FT_Size</tt> object.
    The driver may also modify the scaled outline in order to significantly
    improve its appearance on a pixel-based surface (a process known as
    <em>hinting</em> or <em>grid-fitting</em>).</p>

    <p>This chapter describes how design coordinates are scaled to the
    device space, and how to read glyph outlines and metrics in font units.
    This is important for a number of things:</p>

    <ul>
      <li>
        <p>&lsquo;true&rsquo; WYSIWYG text layout</p>
      </li>
      <li>
        <p>accessing font content for conversion or analysis purposes</p>
      </li>
    </ul>

      <h4>
        a.&nbsp;Scaling distances to device space
      </h4>

      <p>Design coordinates are scaled to the device space using a simple
      scaling transformation whose coefficients are computed with the help
      of the <em>character pixel size</em>:</p>
d1377 1
a1377 1
      <div class="example">
d1382 124
a1505 1
  y_scale  = pixel_size_y / EM_size
d1507 9
a1516 81
      <p>Here, the value <tt>EM_size</tt> is font-specific and corresponds
      to the size of an abstract square of the design space (called the
      <em>EM</em>), which is used by font designers to create glyph images.
      It is thus expressed in font units.  It is also accessible directly
      for scalable font formats as <tt>face-&gt;units_per_EM</tt>.  You
      should check that a font face contains scalable glyph images by using
      the <tt>FT_IS_SCALABLE</tt> macro, which returns true when
      appropriate.</p>

      <p>When you call the function <tt>FT_Set_Pixel_Sizes</tt>, you are
      specifying the value of <tt>pixel_size_x</tt> and
      <tt>pixel_size_y</tt> FreeType shall use.  The library will
      immediately compute the values of <tt>x_scale</tt> and
      <tt>y_scale</tt>.</p>

      <p>When you call the function <tt>FT_Set_Char_Size</tt>, you are
      specifying the character size in physical <em>points</em>, which is
      used, along with the device's resolutions, to compute the character
      pixel size and the corresponding scaling factors.</p>

      <p>Note that after calling any of these two functions, you can access
      the values of the character pixel size and scaling factors as fields
      of the <tt>face-&gt;size-&gt;metrics</tt> structure.  These fields
      are:</p>

      <center>
      <table width="80%" cellpadding="5">
      <tr valign=top>
        <td>
          <tt>x_ppem</tt>
        </td>
        <td>
          <p>The field name stands for &lsquo;x&nbsp;pixels per EM&rsquo;;
          this is the horizontal size in integer pixels of the EM square,
          which also is the <em>horizontal character pixel size</em>, called
          <tt>pixel_size_x</tt> in the above example.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>y_ppem</tt>
        </td>
        <td>
          <p>The field name stands for &lsquo;y&nbsp;pixels per EM&rsquo;;
          this is the vertical size in integer pixels of the EM square,
          which also is the <em>vertical character pixel size</em>, called
          <tt>pixel_size_y</tt> in the above example.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>x_scale</tt>
        </td>
        <td>
          <p>This is a 16.16 fixed-point scale that is used to directly
          scale horizontal distances from design space to 1/64th of device
          pixels.</p>
        </td>
      </tr>
      <tr valign=top>
        <td>
          <tt>y_scale</tt>
        </td>
        <td>
          <p>This is a 16.16 fixed-point scale that is used to directly
          scale vertical distances from design space to 1/64th of device
          pixels.</p>
        </td>
      </tr>
      </table>
      </center>

      <p>You can scale a distance expressed in font units to 26.6 pixel
      format directly with the help of the <tt>FT_MulFix</tt> function, as
      in:</p>

      <div class="pre">
  <span class="comment">/* convert design distances to 1/64th of pixels */</span>
  pixels_x = FT_MulFix( design_x, face-&gt;size-&gt;metrics.x_scale );
  pixels_y = FT_MulFix( design_y, face-&gt;size-&gt;metrics.y_scale );
      </div>
d1518 1
a1518 2
      <p>However, you can also scale the value directly with more accuracy
      by using doubles:</p>
d1520 58
a1577 15
      <div class="pre">
  FT_Size_Metrics*  metrics = &amp;face-&gt;size-&gt;metrics; <span class="comment">/* shortcut */</span>
  double            pixels_x, pixels_y;
  double            em_size, x_scale, y_scale;


  <span class="comment">/* compute floating point scale factors */</span>
  em_size = 1.0 * face-&gt;units_per_EM;
  x_scale = metrics-&gt;x_ppem / em_size;
  y_scale = metrics-&gt;y_ppem / em_size;

  <span class="comment">/* convert design distances to floating point pixels */</span>
  pixels_x = design_x * x_scale;
  pixels_y = design_y * y_scale;
      </div>
d1579 1
a1579 48
      <h4>
        b.&nbsp;Accessing design metrics (glyph &amp; global)
      </h4>

      <p>You can access glyph metrics in font units simply by specifying the
      <tt>FT_LOAD_NO_SCALE</tt> bit flag in <tt>FT_Load_Glyph</tt> or
      <tt>FT_Load_Char</tt>.  The metrics returned in
      <tt>face-&gt;glyph-&gt;metrics</tt> will all be in font units.</p>

      <p>You can access unscaled kerning data using the
      <tt>FT_KERNING_MODE_UNSCALED</tt> mode.</p>

      <p>Finally, a few global metrics are available directly in font units
      as fields of the <tt>FT_Face</tt> handle, as described in
      chapter&nbsp;3 of this section.</p>

    <hr>

    <h3>
      Conclusion
    </h3>

    <p>This is the end of the second section of the FreeType&nbsp;2
    tutorial.  You are now able to access glyph metrics, manage glyph
    images, and render text much more intelligently (kerning, measuring,
    transforming &amp; caching).</p>

    <p>You have now sufficient knowledge to build a pretty decent text
    service on top of FreeType&nbsp;2, and you could possibly stop here if
    you want.</p>

    <p>The demo programs in the &lsquo;ft2demos&rsquo; bundle (especially
    &lsquo;ftview&rsquo;) are a kind of reference implementation, and are a
    good resource to turn to for answers.  They also show how to use
    additional features, such as the glyph stroker and cache.</p>

    <p>The next section will deal with FreeType&nbsp;2 internals (like
    modules, vector outlines, font drivers, renderers), as well as a few
    font format specific issues (mainly, how to access certain TrueType or
    Type&nbsp;1 tables).</p>

</td></tr>
</table>
</center>

<h3 align=center>
  <a href="step3.html">FreeType&nbsp;2 Tutorial Step&nbsp;3</a>
</h3>
d1581 2
a1582 1
<p><font size=-3>Last update: 10-Apr-2013</font></p>
@


1.3
log
@Update to freetpe 2.3.12. Tested against ports by naddy@@.
@
text
@d246 1
a246 1
        image.  <tt>linearHoriAdvance</tt> is a 16.16 fixed float number
d351 1
a351 1
      representing the glyph's advance in 16.16 fixed float coordinates.
d1080 1
a1090 3
      FT_BBox  glyph_bbox;


d1122 1
a1122 1
        *abbox = bbox;
d1315 2
a1316 1
      FT_Glyph_Get_CBox( glyphs[n], &amp;glyph_bbox );
d1376 5
a1380 1
  FT_Matrix  transform;
d1400 2
a1403 4
    FT_Glyph  image;
    FT_Vector pen;
    FT_BBox   bbox;

d1410 1
a1410 1
    FT_Glyph_Transform( image, &amp;matrix, &amp;start );
d1430 10
a1439 3
      my_draw_bitmap( bitmap-&gt;bitmap,
                      bitmap-&gt;left,
                      my_target_height - bitmap-&gt;top );
d1463 1
a1463 1
          scalable image.  Note that the image is destroyed even when the
d1591 1
a1591 1
          <p>This is a 16.16 fixed float scale that is used to directly
d1601 1
a1601 1
          <p>This is a 16.16 fixed float scale that is used to directly
d1687 1
a1687 1
<p><font size=-3>Last update: 19-Nov-2009</font></p>
@


1.2
log
@update to freetype-docs 2.3.9
@
text
@d783 14
a796 7
      <p>Not all font formats contain kerning information.  Instead, they
      sometimes rely on an additional file that contains various glyph
      metrics, including kerning, but no glyph images.  A good example is
      the Type&nbsp;1 format where glyph images are stored in a file with
      extension <tt>.pfa</tt> or <tt>.pfb</tt>, and where kerning metrics
      can be found in an additional file with extension <tt>.afm</tt> or
      <tt>.pfm</tt>.</p>
d924 1
a924 1
                      ft_kerning_mode_default, &amp;delta );
d953 1
a953 1
          explicitly convert our character codes into a glyph indices, then
d1180 1
a1180 1
          <tt>image</tt> after the call and is typecasted to
d1233 1
a1233 1
      its position on the baseline at load time.  As we will see, this as
d1661 5
d1679 1
a1679 1
<p><font size=-3>Last update: 07-Mar-2009</font></p>
@


1.1
log
@Initial revision
@
text
@d50 1
a50 1
  &copy; 2003, 2006, 2007 David Turner
d52 1
a52 1
  &copy; 2003, 2006, 2007 The FreeType Development Team
d66 2
a67 2
  <p>This is the second section of the FreeType 2 tutorial. It describes
  how to</p>
d102 1
a102 1
[A    href="../reference/ft2-base_interface.html#FT_Glyph_Metrics">
d282 1
a282 1
    <p>The FreeType 2 API has a specific extension which is capable of
d468 1
a468 1
      <tt>FT_Glyph_To_Bitmap</tt></a> function. It is in charge of
d608 1
a608 1
          <tt>global_bbox</tt>
d612 1
a612 2
          that can enclose all the glyphs in a font face.  It is defined for
          horizontal layouts only.</p>
d626 1
a626 1
          it as being equal to <tt>global_bbox.yMax</tt>.</p>
d640 1
a640 1
          it as being equal to <tt>global_bbox.yMin</tt>.  This field is
d646 1
a646 1
          <tt>text_height</tt>
d649 5
a653 5
          <p>This field is simply used to compute a default line spacing
          (i.e., the baseline-to-baseline distance) when writing text with
          this font.  Note that it usually is larger than the sum of the
          ascender and descender taken as absolute values.  There is also no
          guarantee that no glyphs extend above or below subsequent
d674 1
a674 2
          layout.  It is only available in fonts providing vertical glyph
          metrics.</p>
d684 1
a684 1
          the underline bar.  It is negative if it is below the
d713 1
a713 1
      global metrics, <em>with no rounding/grid-fitting performed</em>.
d1348 1
a1348 1
  ... setup "matrix" and "delta" ...
d1657 1
a1657 1
    Type&nbsp;1 tables).  [This section has not been written yet.]</p>
d1664 1
a1664 1
  <a href="step1.html">FreeType&nbsp;2 Tutorial Step&nbsp;1</a>
d1667 1
a1667 1
<p><font size=-3>Last update: 06-Feb-2007</font></p>
@


1.1.1.1
log
@import freetype 2.3.5
@
text
@@
