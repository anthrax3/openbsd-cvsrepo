head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.14
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.12
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.10
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.8
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.6
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_1_3:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@.\" @;


1.8
date	2013.05.31.15.15.08;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.12.17.17.39.20;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.07.02.21.21.11;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.02.21.14.37;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.11.11.10.49.22;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.09.04.10.17.03;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.18.19.28.54;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.17.23.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.17.23.04;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.16.45.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to libXi 1.6.3rc1
@
text
@'\" t
.\"     Title: xallowdeviceevents
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.77.1 <http://docbook.sf.net/>
.\"      Date: 03/09/2013
.\"    Manual: \ \&
.\"    Source: \ \&
.\"  Language: English
.\"
.TH "XALLOWDEVICEEVENTS" "libmansuffix" "03/09/2013" "\ \&" "\ \&"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
XAllowDeviceEvents \- release queued events
.SH "SYNOPSIS"
.sp
.nf
#include <X11/extensions/XInput\&.h>
.fi
.sp
.nf
int XAllowDeviceEvents( Display *display,
                        XDevice *device,
                        int event_mode,
                        Time time);
display
       Specifies the connection to the X server\&.
.fi
.sp
.nf
device
       Specifies the device from which events are to be
       allowed\&.
.fi
.sp
.nf
event_mode
       Specifies the event mode\&.You can pass AsyncThisDevice,
       SyncThisDevice, ReplayThisDevice, AsyncOtherDevices,
       SyncAll,or AsyncAll\&.
.fi
.sp
.nf
time
       Specifies the time\&.You can pass either a timestamp or
       CurrentTime\&.
.fi
.SH "DESCRIPTION"
.sp
The XAllowDeviceEvents function releases some queued events if the client has caused a device to freeze\&. It has no effect if the specified time is earlier than the last\-grab time of the most recent active grab for the client and device, or if the specified time is later than the current X server time\&.
.sp
The following describes the processing that occurs depending on what constant you pass to the event_mode argument\&.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
AsyncThisDevice \- If the specified device is frozen by the client, event processing for that device continues as usual\&. If the device is frozen multiple times by the client on behalf of multiple separate grabs, AsyncThisDevice thaws for all\&.AsyncThisDevice has no effect if the specified device is not frozen by the client, but the device need not be grabbed by the client\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
SyncThisDevice \- If the specified device is frozen and actively grabbed by the client, event processing for that device continues normally until the next key or button event is reported to the client\&. At this time, the specified device again appears to freeze\&. However, if the reported event causes the grab to be released, the specified device does not freeze\&. SyncThisDevice has no effect if the specified device is not frozen by the client or is not grabbed by the client\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ReplayThisDevice \- If the specified device is actively grabbed by the client and is frozen as the result of an event having been sent to the client (either from the activation of a GrabDeviceButton or from a previous AllowDeviceEvents with mode SyncThisDevice, but not from a GrabDevice), the grab is released and that event is completely reprocessed\&. This time, however, the request ignores any passive grabs at or above (toward the root) that the grab\-window of the grab just released\&. The request has no effect if the specified device is not grabbed by the client or if it is not frozen as the result of an event\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
AsyncOtherDevices \- If the remaining devices are frozen by the client, event processing for them continues as usual\&. If the other devices are frozen multiple times by the client on behalf of multiple grabs, AsyncOtherDevices "thaws" for all\&. AsyncOtherDevices has no effect if the devices are not frozen by the client\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
SyncAll \- If all devices are frozen by the client, event processing (for all devices) continues normally until the next button or key event is reported to the client for a grabbed device, at which time all devices again appear to freeze\&. However, if the reported event causes the grab to be released, then the devices do not freeze\&. If any device is still grabbed, then a subsequent event for it will still cause all devices to freeze\&. SyncAll has no effect unless all devices are frozen by the client\&. If any device is frozen twice by the client on behalf of two separate grabs, SyncAll thaws for both\&. A subsequent freeze for SyncAll will only freeze each device once\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
AsyncAll \- If all devices are frozen by the client, event processing for all devices continues normally\&. If any device is frozen multiple times by the client on behalf of multiple separate grabs, AsyncAll thaws for all\&. AsyncAll has no effect unless all devices are frozen by the client\&.
.RE
.sp
AsyncThisDevice, SyncThisDevice, and ReplayThisDevice have no effect on the processing of events from the remaining devices\&.AsyncOtherDevices has no effect on the processing of events from the specified device\&. When the event_mode is SyncAll or AsyncAll, the device parameter is ignored\&.
.sp
It is possible for several grabs of different devices by the same or different clients to be active simultaneously\&. If a device is frozen on behalf of any grab, no event processing is performed for the device\&. It is possible for a single device to be frozen because of several grabs\&. In this case, the freeze must be released on behalf of each grab before events can again be processed\&.
.sp
XAllowDeviceEvents can generate a BadDevice or BadValue error\&.
.SH "DIAGNOSTICS"
.sp
.if n \{\
.RS 4
.\}
.nf
BadDevice
       An invalid device was specified\&. The specified device
       does not exist or has not been opened by this client via
       XOpenInputDevice\&. This error may also occur if the
       specified device is the X keyboard or X pointer device\&.
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
BadValue
       An invalid mode was specified on the request\&.
.fi
.if n \{\
.RE
.\}
.SH "SEE ALSO"
.sp
.if n \{\
.RS 4
.\}
.nf
XGrabDevice(libmansuffix)
.fi
.if n \{\
.RE
.\}
@


1.7
log
@Update to libXi 1.4.4.
@
text
@d4 4
a7 4
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 09/23/2011
.\"    Manual: [FIXME: manual]
.\"    Source: [FIXME: source]
d10 1
a10 1
.TH "XALLOWDEVICEEVENTS" "libmansuffix" "09/23/2011" "[FIXME: source]" "[FIXME: manual]"
@


1.6
log
@Update to libXi 1.4.3.
This contains more doc fixes and a few more bug fixes.
@
text
@d5 1
a5 1
.\"      Date: 06/02/2011
d10 1
a10 1
.TH "XALLOWDEVICEEVENTS" "libmansuffix" "06/02/2011" "[FIXME: source]" "[FIXME: manual]"
@


1.5
log
@Update to libXi 1.4.2.
Tested by ajacoutot@@, jasper@@, krw@@, shadchin@@.
I believe that the bugs spotted by krw@@ are fixed in an upcoming
inputproto update.
@
text
@d5 3
a7 3
.\"      Date: 03/18/2011
.\"    Manual: \ \&
.\"    Source: \ \&
d10 1
a10 1
.TH "XALLOWDEVICEEVENTS" "libmansuffix" "03/18/2011" "\ \&" "\ \&"
@


1.4
log
@Update to libXi 1.4.0. small bug fixes plus doc/spec/autotools churn.
@
text
@d4 4
a7 4
.\" Generator: DocBook XSL Stylesheets v1.75.2 <http://docbook.sf.net/>
.\"      Date: 10/20/2010
.\"    Manual: [FIXME: manual]
.\"    Source: [FIXME: source]
d10 10
a19 1
.TH "XALLOWDEVICEEVENTS" "libmansuffix" "10/20/2010" "[FIXME: source]" "[FIXME: manual]"
@


1.3
log
@Update to libXi 1.3.2
@
text
@d5 1
a5 1
.\"      Date: 08/04/2010
d10 1
a10 1
.TH "XALLOWDEVICEEVENTS" "libmansuffix" "08/04/2010" "[FIXME: source]" "[FIXME: manual]"
d58 4
a61 1
.if n \{\
d63 2
d66 5
a70 8
.nf
The XAllowDeviceEvents function releases some queued events if
the client has caused a device to freeze\&. It has no effect if
the specified time is earlier than the last\-grab time of the
most recent active grab for the client and device, or if the
specified time is later than the current X server time\&.
.fi
.if n \{\
a71 1
.\}
a72 1
.if n \{\
d74 6
d81 1
a81 5
.nf
The following describes the processing that occurs depending on
what constant you pass to the event_mode argument\&.
.fi
.if n \{\
a82 1
.\}
a83 1
.if n \{\
d85 6
d92 1
a92 10
.nf
AsyncThisDevice If the specified device is frozen by the
client, event processing for that device continues as usual\&. If
the device is frozen multiple times by the client on behalf of
multiple separate grabs, AsyncThisDevice thaws for
all\&.AsyncThisDevice has no effect if the specified device is
not frozen by the client, but the device need not be grabbed by
the client\&.
.fi
.if n \{\
a93 1
.\}
a94 1
.if n \{\
d96 2
d99 5
a103 11
.nf
SyncThisDevice If the specified device is frozen and actively
grabbed by the client, event processing for that device
continues normally until the next key or button event is
reported to the client\&. At this time, the specified device
again appears to freeze\&. However, if the reported event causes
the grab to be released, the specified device does not freeze\&.
SyncThisDevice has no effect if the specified device is not
frozen by the client or is not grabbed by the client\&.
.fi
.if n \{\
a104 1
.\}
a105 1
.if n \{\
d107 2
d110 3
a112 15
.nf
ReplayThisDevice If the specified device is actively grabbed by
the client and is frozen as the result of an event having been
sent to the client (either from the activation of a
GrabDeviceButton or from a previous AllowDeviceEvents with mode
SyncThisDevice, but not from a GrabDevice), the grab is
released and that event is completely reprocessed\&. This time,
however, the request ignores any passive grabs at or above
(toward the root) that the grab\-window of the grab just
released\&. The request has no effect if the specified device is
not grabbed by the client or if it is not frozen as the result
of an event\&.
.fi
.if n \{\
.RE
d114 1
a114 13
.sp
.if n \{\
.RS 4
.\}
.nf
AsyncOtherDevices If the remaining devices are frozen by the
client, event processing for them continues as usual\&. If the
other devices are frozen multiple times by the client on behalf
of multiple grabs, AsyncOtherDevices "thaws" for all\&.
AsyncOtherDevices has no effect if the devices are not frozen
by the client\&.
.fi
.if n \{\
a115 1
.\}
a116 1
.if n \{\
d118 2
d121 3
a123 16
.nf
SyncAll If all devices are frozen by the client, event
processing (for all devices) continues normally until the next
button or key event is reported to the client for a grabbed
device, at which time all devices again appear to freeze\&.
However, if the reported event causes the grab to be released,
then the devices do not freeze\&. If any device is still grabbed,
then a subsequent event for it will still cause all devices to
freeze\&. SyncAll has no effect unless all devices are frozen by
the client\&. If any device is frozen twice by the client on
behalf of two separate grabs, SyncAll thaws for both\&. A
subsequent freeze for SyncAll will only freeze each device
once\&.
.fi
.if n \{\
.RE
d125 1
a125 12
.sp
.if n \{\
.RS 4
.\}
.nf
AsyncAll If all devices are frozen by the client, event
processing for all devices continues normally\&. If any device is
frozen multiple times by the client on behalf of multiple
separate grabs, AsyncAll thaws for all\&. AsyncAll has no effect
unless all devices are frozen by the client\&.
.fi
.if n \{\
a126 1
.\}
d128 1
a128 13
.if n \{\
.RS 4
.\}
.nf
AsyncThisDevice, SyncThisDevice, and ReplayThisDevice have no
effect on the processing of events from the remaining
devices\&.AsyncOtherDevices has no effect on the processing of
events from the specified device\&. When the event_mode is
SyncAll or AsyncAll, the device parameter is ignored\&.
.fi
.if n \{\
.RE
.\}
d130 1
a130 15
.if n \{\
.RS 4
.\}
.nf
It is possible for several grabs of different devices by the
same or different clients to be active simultaneously\&. If a
device is frozen on behalf of any grab, no event processing is
performed for the device\&. It is possible for a single device to
be frozen because of several grabs\&. In this case, the freeze
must be released on behalf of each grab before events can again
be processed\&.
.fi
.if n \{\
.RE
.\}
a131 4
.if n \{\
.RS 4
.\}
.nf
a132 4
.fi
.if n \{\
.RE
.\}
@


1.2
log
@Update to libXi 1.3. Tested on a bulk ports build by naddy@@.
@
text
@d4 2
a5 2
.\" Generator: DocBook XSL Stylesheets v1.74.3 <http://docbook.sf.net/>
.\"      Date: 10/02/2009
d10 1
a10 1
.TH "XALLOWDEVICEEVENTS" "libmansuffix" "10/02/2009" "[FIXME: source]" "[FIXME: manual]"
@


1.1
log
@Initial revision
@
text
@d1 8
d10 12
a21 16
.\" $XFree86: xc/doc/man/Xi/XAllDvEv.man,v 1.2 2001/01/27 18:20:20 dawes Exp $
.\"
.\"
.\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
.\" 
.\" Permission to use, copy, modify, distribute, and sell this documentation 
.\" for any purpose and without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\" Ardent, and Hewlett-Packard make no representations about the 
.\" suitability for any purpose of the information in this document.  It is 
.\" provided \`\`as is'' without express or implied warranty.
.\" 
.\" $Xorg: XAllDvEv.man,v 1.3 2000/08/17 19:41:55 cpqbld Exp $
.ds xL Programming With Xlib
.TH XAllowDeviceEvents 3X11 __xorgversion__ "X FUNCTIONS"
.SH NAME
d23 228
a250 124
.SH SYNTAX
.HP
int XAllowDeviceEvents\^(\^Display *\fIdisplay\fP\^, XDevice *\fIdevice\fP\^,
int \fIevent_mode\fP\^, Time \fItime\fP\^); 
.SH ARGUMENTS
.TP 12
.I display
Specifies the connection to the X server.
.TP 12
.I device
Specifies the device from which events are to be allowed.
.TP 12
.I event_mode
Specifies the event mode.
You can pass 
\fIAsyncThisDevice\fP, 
\fISyncThisDevice\fP, 
\fIReplayThisDevice\fP, 
\fIAsyncOtherDevices\fP, 
\fISyncAll\fP,
or
\fIAsyncAll\fP.
.TP 12
.I time
Specifies the time.
You can pass either a timestamp or
\fICurrentTime\fP.
.SH DESCRIPTION
The
\fIXAllowDeviceEvents\fP
function releases some queued events if the client has caused a device 
to freeze.
It has no effect if the specified time is earlier than the last-grab
time of the most recent active grab for the client and device, 
or if the specified time is later than the current X server time.
.LP
The following describes the processing that occurs depending on what
constant you pass to the event_mode argument.
.TP 12
\fIAsyncThisDevice\fP
If the specified device is frozen by the client, event processing for that
device continues as usual.  If the device is frozen multiple times by the client
on behalf of multiple separate grabs, \fIAsyncThisDevice\fP thaws for all.
\fIAsyncThisDevice\fP has no effect if the specified device is not frozen by
the client, but the device need not be grabbed by the client.
.TP 12
\fISyncThisDevice\fP
If the specified device is frozen and actively grabbed by the client, event
processing for that device continues normally until the next key or button
event is reported to the client.  At this time, the specified device
again appears to freeze.  However, if the reported event causes the grab
to be released, the specified device does not freeze.  \fISyncThisDevice\fP
has no effect if the specified device is not frozen by the client or is not
grabbed by the client.
.TP 12
\fIReplayThisDevice\fP
If the specified device is actively grabbed by the client and is frozen as
the result of an event having been sent to the client (either from the
activation of a GrabDeviceButton or from a previous AllowDeviceEvents with
mode SyncThisDevice, but not from a GrabDevice), the grab is released and that
event is completely reprocessed.  This time, however, the request ignores
any passive grabs at or above (toward the root) that the grab-window of the
grab just released.  The request has no effect if the specified device is
not grabbed by the client or if it is not frozen as the result of an event.
.TP 12
\fIAsyncOtherDevices\fP
If the remaining devices are frozen by the client, event processing for them
continues as usual.  If the other devices are frozen multiple times by the
client on behalf of multiple grabs, \fIAsyncOtherDevices\fP "thaws" for
all.  \fIAsyncOtherDevices\fP has no effect if the devices are not frozen
by the client.
.TP 12
\fISyncAll\fP
If all devices are frozen by the client, event processing (for all devices)
continues normally until the next button or key event is reported to the
client for a grabbed device, at which time all devices again appear to freeze.
However, if the reported event causes the grab to be released, then the devices
do not freeze.  If any device is still grabbed, then a subsequent event for it
will still cause all devices to freeze.  \fISyncAll\fP has no
effect unless all devices are frozen by the client.  If any device is 
frozen twice by the client on behalf of two separate grabs, \fISyncAll\fP thaws
for both.  A subsequent freeze for \fISyncAll\fP will only
freeze each device once.
.TP 12
\fIAsyncAll\fP
If all devices are frozen by the client, event processing for all devices
continues normally.  If any device is frozen multiple times by the client
on behalf of multiple separate grabs, \fIAsyncAll\fP thaws for
all.  \fIAsyncAll\fP has no effect unless all devices are frozen by
the client.
.LP
\fIAsyncThisDevice\fP,
\fISyncThisDevice\fP,
and
\fIReplayThisDevice\fP
have no effect on the processing of events from the remaining devices.
\fIAsyncOtherDevices\fP
has no effect on the processing of events from the specified device.  When
the event_mode is
\fISyncAll\fP
or
\fIAsyncAll\fP,
the device parameter is ignored.
.LP
It is possible for several grabs of different devices by the same or
different clients to be active simultaneously.  If a device is frozen on
behalf of any grab, no event processing is performed for the device.
It is possible for a single device to be frozen because of several grabs.
In this case, the freeze must be released on behalf of each grab before
events can again be processed.
.LP
\fIXAllowDeviceEvents\fP
can generate a \fIBadDevice\fP or
\fIBadValue\fP 
error.
.SH DIAGNOSTICS
.TP 12
\fIBadDevice\fP
An invalid device was specified.  The specified device does not exist or has 
not been opened by this client via \fIXOpenInputDevice\fP.  This error may
also occur if the specified device is the X keyboard or X pointer device.
.TP 12
\fIBadValue\fP
An invalid mode was specified on the request.
d252 10
a261 3
XGrabDevice(3X11)
.br
\fI\*(xL\fP
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@libXi 1.1.3
@
text
@d16 1
a16 1
.TH XAllowDeviceEvents __LIB_MAN_SUFFIX__ __xorgversion__ "X FUNCTIONS"
d144 1
a144 1
XGrabDevice(3)
@

