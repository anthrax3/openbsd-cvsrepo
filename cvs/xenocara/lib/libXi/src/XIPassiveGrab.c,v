head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.6
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.4
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.09.28.17.22.58;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	z9e5iyEEqbHgjQHI;

1.6
date	2014.05.09.19.55.33;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2013.05.23.22.42.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.11.19.24.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.02.21.21.11;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2011.07.02.21.14.37;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.18.19.28.54;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to libXi 1.7.4
@
text
@/*
 * Copyright Â© 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdint.h>
#include <X11/Xlibint.h>
#include <X11/extensions/XI2proto.h>
#include <X11/extensions/XInput2.h>
#include <X11/extensions/extutil.h>
#include <limits.h>
#include "XIint.h"

static int
_XIPassiveGrabDevice(Display* dpy, int deviceid, int grabtype, int detail,
                     Window grab_window, Cursor cursor,
                     int grab_mode, int paired_device_mode,
                     Bool owner_events, XIEventMask *mask,
                     int num_modifiers, XIGrabModifiers *modifiers_inout)
{
    xXIPassiveGrabDeviceReq *req;
    xXIPassiveGrabDeviceReply reply;
    xXIGrabModifierInfo *failed_mods;
    int len = 0, i;
    int ret = -1;
    char *buff;

    XExtDisplayInfo *extinfo = XInput_find_display(dpy);

    LockDisplay(dpy);
    if (_XiCheckExtInit(dpy, XInput_2_0, extinfo) == -1)
	return -1;

    if (mask->mask_len > INT_MAX - 3 ||
        (mask->mask_len + 3)/4 >= 0xffff)
        goto out;

    buff = calloc(4, (mask->mask_len + 3)/4);
    if (!buff)
        goto out;

    GetReq(XIPassiveGrabDevice, req);
    req->reqType = extinfo->codes->major_opcode;
    req->ReqType = X_XIPassiveGrabDevice;
    req->deviceid = deviceid;
    req->grab_mode = grab_mode;
    req->paired_device_mode = paired_device_mode;
    req->owner_events = owner_events;
    req->grab_window = grab_window;
    req->cursor = cursor;
    req->detail = detail;
    req->num_modifiers = num_modifiers;
    req->mask_len = (mask->mask_len + 3)/4;
    req->grab_type = grabtype;

    len = req->mask_len + num_modifiers;
    SetReqLen(req, len, len);

    memcpy(buff, mask->mask, mask->mask_len);
    Data(dpy, buff, req->mask_len * 4);
    for (i = 0; i < num_modifiers; i++)
        Data(dpy, (char*)&modifiers_inout[i].modifiers, 4);

    free(buff);

    if (!_XReply(dpy, (xReply *)&reply, 0, xFalse))
        goto out;

    failed_mods = calloc(reply.num_modifiers, sizeof(xXIGrabModifierInfo));
    if (!failed_mods)
        goto out;
    _XRead(dpy, (char*)failed_mods, reply.num_modifiers * sizeof(xXIGrabModifierInfo));

    for (i = 0; i < reply.num_modifiers && i < num_modifiers; i++)
    {
        modifiers_inout[i].status = failed_mods[i].status;
        modifiers_inout[i].modifiers = failed_mods[i].modifiers;
    }
    free(failed_mods);

    ret = reply.num_modifiers;

 out:
    UnlockDisplay(dpy);
    SyncHandle();
    return ret;
}

int
XIGrabButton(Display* dpy, int deviceid, int button,
             Window grab_window, Cursor cursor,
             int grab_mode, int paired_device_mode,
             Bool owner_events, XIEventMask *mask,
             int num_modifiers, XIGrabModifiers *modifiers_inout)
{
    return _XIPassiveGrabDevice(dpy, deviceid, XIGrabtypeButton, button,
                                grab_window, cursor, grab_mode,
                                paired_device_mode, owner_events, mask,
                                num_modifiers, modifiers_inout);
}

int
XIGrabKeycode(Display* dpy, int deviceid, int keycode,
             Window grab_window, int grab_mode, int paired_device_mode,
             Bool owner_events, XIEventMask *mask,
             int num_modifiers, XIGrabModifiers *modifiers_inout)
{
    return _XIPassiveGrabDevice(dpy, deviceid, XIGrabtypeKeycode, keycode,
                                grab_window, None, grab_mode, paired_device_mode,
                                owner_events, mask, num_modifiers,
                                modifiers_inout);
}

int
XIGrabEnter(Display *dpy, int deviceid, Window grab_window, Cursor cursor,
            int grab_mode, int paired_device_mode, Bool owner_events,
            XIEventMask *mask, int num_modifiers,
            XIGrabModifiers *modifiers_inout)
{
    return _XIPassiveGrabDevice(dpy, deviceid, XIGrabtypeEnter, 0,
                                grab_window, cursor, grab_mode, paired_device_mode,
                                owner_events, mask, num_modifiers,
                                modifiers_inout);
}

int
XIGrabFocusIn(Display *dpy, int deviceid, Window grab_window, int grab_mode,
            int paired_device_mode, Bool owner_events, XIEventMask *mask,
            int num_modifiers, XIGrabModifiers *modifiers_inout)
{
    return _XIPassiveGrabDevice(dpy, deviceid, XIGrabtypeFocusIn, 0,
                                grab_window, None, grab_mode, paired_device_mode,
                                owner_events, mask, num_modifiers,
                                modifiers_inout);
}

int
XIGrabTouchBegin(Display *dpy, int deviceid, Window grab_window,
                 Bool owner_events, XIEventMask *mask,
                 int num_modifiers, XIGrabModifiers *modifiers_inout)
{
    XExtDisplayInfo *extinfo = XInput_find_display(dpy);

    LockDisplay(dpy);
    if (_XiCheckExtInit(dpy, XInput_2_2, extinfo) == -1)
	return -1;
    UnlockDisplay(dpy);

    /* FIXME: allow selection of GrabMode for paired devices? */
    return _XIPassiveGrabDevice(dpy, deviceid, XIGrabtypeTouchBegin, 0,
                                grab_window, None, XIGrabModeTouch,
                                GrabModeAsync, owner_events, mask,
                                num_modifiers, modifiers_inout);
}


static int
_XIPassiveUngrabDevice(Display* dpy, int deviceid, int grabtype, int detail,
                       Window grab_window, int num_modifiers, XIGrabModifiers *modifiers)
{
    xXIPassiveUngrabDeviceReq *req;
    int i;

    XExtDisplayInfo *extinfo = XInput_find_display(dpy);

    LockDisplay(dpy);
    if (_XiCheckExtInit(dpy, XInput_2_0, extinfo) == -1)
	return -1;

    GetReq(XIPassiveUngrabDevice, req);
    req->reqType = extinfo->codes->major_opcode;
    req->ReqType = X_XIPassiveUngrabDevice;
    req->deviceid = deviceid;
    req->grab_window = grab_window;
    req->detail = detail;
    req->num_modifiers = num_modifiers;
    req->grab_type = grabtype;

    SetReqLen(req, num_modifiers, num_modifiers);
    for (i = 0; i < num_modifiers; i++)
        Data32(dpy, &modifiers[i].modifiers, 4);

    UnlockDisplay(dpy);
    SyncHandle();
    return Success;
}

int
XIUngrabButton(Display* display, int deviceid, int button,Window grab_window,
               int num_modifiers, XIGrabModifiers *modifiers)
{
    return _XIPassiveUngrabDevice(display, deviceid, XIGrabtypeButton, button,
                                  grab_window, num_modifiers, modifiers);
}

int
XIUngrabKeycode(Display* display, int deviceid, int keycode, Window grab_window,
               int num_modifiers, XIGrabModifiers *modifiers)
{
    return _XIPassiveUngrabDevice(display, deviceid, XIGrabtypeKeycode, keycode,
                                  grab_window, num_modifiers, modifiers);
}


int
XIUngrabEnter(Display* display, int deviceid, Window grab_window,
               int num_modifiers, XIGrabModifiers *modifiers)
{
    return _XIPassiveUngrabDevice(display, deviceid, XIGrabtypeEnter, 0,
                                  grab_window, num_modifiers, modifiers);
}

int
XIUngrabFocusIn(Display* display, int deviceid, Window grab_window,
               int num_modifiers, XIGrabModifiers *modifiers)
{
    return _XIPassiveUngrabDevice(display, deviceid, XIGrabtypeFocusIn, 0,
                                  grab_window, num_modifiers, modifiers);
}

int
XIUngrabTouchBegin(Display* display, int deviceid, Window grab_window,
                   int num_modifiers, XIGrabModifiers *modifiers)
{
    XExtDisplayInfo *extinfo = XInput_find_display(display);

    LockDisplay(display);
    if (_XiCheckExtInit(display, XInput_2_2, extinfo) == -1)
	return -1;
    UnlockDisplay(display);

    return _XIPassiveUngrabDevice(display, deviceid, XIGrabtypeTouchBegin, 0,
                                  grab_window, num_modifiers, modifiers);
}
@


1.6
log
@Update to libXi 1.7.2.

Tested by ajacoutot@@ against gnome.
@
text
@d47 1
d58 1
a58 1
        return -1;
d62 1
a62 1
        return -1;
d89 1
a89 5
    {
	UnlockDisplay(dpy);
	SyncHandle();
	return -1;
    }
d93 1
a93 1
        return -1;
d103 3
d108 1
a108 1
    return reply.num_modifiers;
d169 1
d252 1
@


1.5
log
@Merge upstream fixes for several X libs vulnerabilities
discovered by Ilja van Sprundel.

CVE-2013-1981 X.org libX11 1.5.99.901 (1.6 RC1) integer overflows
CVE-2013-1982 X.org libXext 1.3.1 integer overflows
CVE-2013-1983 X.org libXfixes 5.0 integer overflows
CVE-2013-1984 X.org libXi 1.7.1 integer overflows
CVE-2013-1985 X.org libXinerama 1.1.2 integer overflows
CVE-2013-1986 X.org libXrandr 1.4.0 integer overflows
CVE-2013-1987 X.org libXrender 0.9.7 integer overflows
CVE-2013-1988 X.org libXRes 1.0.6 integer overflows
CVE-2013-1989 X.org libXv 1.0.7 integer overflows
CVE-2013-1990 X.org libXvMC 1.0.7 integer overflows
CVE-2013-1991 X.org libXxf86dga 1.1.3 integer overflows
CVE-2013-1992 X.org libdmx 1.1.2 integer overflows
CVE-2013-1994 X.org libchromeXvMC & libchromeXvMCPro in openChrome
0.3.2 integer overflows
CVE-2013-1995 X.org libXi 1.7.1 sign extension issues
CVE-2013-1996 X.org libFS 1.0.4 sign extension issues
CVE-2013-1997 X.org libX11 1.5.99.901 (1.6 RC1) buffer overflows
CVE-2013-1998 X.org libXi 1.7.1 buffer overflows
CVE-2013-1999 X.org libXvMC 1.0.7 buffer overflows
CVE-2013-2000 X.org libXxf86dga 1.1.3 buffer overflows
CVE-2013-2001 X.org libXxf86vm 1.1.2 buffer overflows
CVE-2013-2002 X.org libXt 1.1.3 buffer overflows
CVE-2013-2003 X.org libXcursor 1.1.13 integer overflows
CVE-2013-2004 X.org libX11 1.5.99.901 (1.6 RC1) unbounded recursion
CVE-2013-2005 X.org libXt 1.1.3 memory corruption
CVE-2013-2066 X.org libXv 1.0.7 buffer overflows
@
text
@d33 1
d55 8
a79 1
    buff = calloc(4, req->mask_len);
@


1.4
log
@Update to libXi 1.6.1
@
text
@d91 1
a91 1
    for (i = 0; i < reply.num_modifiers; i++)
@


1.3
log
@Update to libXi 1.4.3.
This contains more doc fixes and a few more bug fixes.
@
text
@d24 3
d151 19
d231 14
@


1.2
log
@Update to libXi 1.4.2.
Tested by ajacoutot@@, jasper@@, krw@@, shadchin@@.
I believe that the bugs spotted by krw@@ are fixed in an upcoming
inputproto update.
@
text
@d70 1
a70 1
    Data32(dpy, buff, req->mask_len * 4);
d72 1
a72 1
        Data32(dpy, &modifiers_inout[i].modifiers, 4);
@


1.1
log
@Update to libXi 1.3. Tested on a bulk ports build by naddy@@.
@
text
@d48 1
a48 1
    if (_XiCheckExtInit(dpy, Dont_Check, extinfo) == -1)
d76 1
a76 1
    if (_XReply(dpy, (xReply *)&reply, 0, xTrue))
d158 1
a158 1
    if (_XiCheckExtInit(dpy, Dont_Check, extinfo) == -1)
@

