head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.14
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.12
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.10
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.8
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_0_2:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_1:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.05.31.15.47.21;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.05.23.22.42.12;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.03.10.23.31.33;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.03.10.17.07.14;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.31.16.35.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.04.27.20.00.54;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.07.01;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.07.01;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to libXxf86dga 1.1.4
@
text
@/*

Copyright (c) 1995  Jon Tombs
Copyright (c) 1995,1996  The XFree86 Project, Inc

*/

/* THIS IS NOT AN X CONSORTIUM STANDARD */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef __UNIXOS2__ /* needed here to override certain constants in X headers */
#define INCL_DOS
#define INCL_DOSIOCTL
#define I_NEED_OS2_H
#include <os2.h>
#endif

#include <X11/Xlibint.h>
#include <X11/extensions/Xxf86dga.h>
#include <X11/extensions/xf86dgaproto.h>
#include <X11/extensions/Xext.h>
#include <X11/extensions/extutil.h>
#include <stdio.h>

#include <stdint.h>
#include <limits.h>

#ifndef HAVE__XEATDATAWORDS
static inline void _XEatDataWords(Display *dpy, unsigned long n)
{
# ifndef LONG64
    if (n >= (ULONG_MAX >> 2))
        _XIOError(dpy);
# endif
    _XEatData (dpy, n << 2);
}
#endif

/* If you change this, change the Bases[] array below as well */
#define MAX_HEADS 16

const char *xdga_extension_name = XF86DGANAME;

static XExtensionInfo _xdga_info_data;
static XExtensionInfo *xdga_info = &_xdga_info_data;


Bool XDGAMapFramebuffer(int, char *, unsigned char*, CARD32, CARD32, CARD32);
void XDGAUnmapFramebuffer(int);
unsigned char* XDGAGetMappedMemory(int);

#define XDGACheckExtension(dpy,i,val) \
  XextCheckExtension (dpy, i, xdga_extension_name, val)

/*****************************************************************************
 *                                                                           *
 *			   private utility routines                          *
 *                                                                           *
 *****************************************************************************/

static int xdga_close_display(Display *dpy, XExtCodes *codes);
static Bool xdga_wire_to_event(Display *dpy, XEvent *event, xEvent *wire_ev);
static Status xdga_event_to_wire(Display *dpy, XEvent *event, xEvent *wire_ev);

static XExtensionHooks xdga_extension_hooks = {
    NULL,				/* create_gc */
    NULL,				/* copy_gc */
    NULL,				/* flush_gc */
    NULL,				/* free_gc */
    NULL,				/* create_font */
    NULL,				/* free_font */
    xdga_close_display,			/* close_display */
    xdga_wire_to_event,			/* wire_to_event */
    xdga_event_to_wire,			/* event_to_wire */
    NULL,				/* error */
    NULL,				/* error_string */
};

static XEXT_GENERATE_CLOSE_DISPLAY (xdga_close_display, xdga_info)


XExtDisplayInfo* xdga_find_display(Display*);
XEXT_GENERATE_FIND_DISPLAY (xdga_find_display, xdga_info,
				   "XFree86-DGA",
				   &xdga_extension_hooks,
				   0, NULL)


static Status
xdga_event_to_wire(
  Display *dpy,
  XEvent *event,
  xEvent *wire_ev
){
    return True;
}

static Bool
xdga_wire_to_event(
  Display *dpy,
  XEvent *event,
  xEvent *wire_ev
){
  dgaEvent *wire = (dgaEvent *) wire_ev;
  XDGAButtonEvent *bevent;
  XDGAKeyEvent *kevent;
  XDGAMotionEvent *mevent;
  XExtDisplayInfo *info = xdga_find_display (dpy);

  XDGACheckExtension (dpy, info, False);

  switch((wire->u.u.type & 0x7f) - info->codes->first_event) {
  case MotionNotify:
	mevent = (XDGAMotionEvent*)event;
	mevent->type = wire->u.u.type & 0x7F;
	mevent->serial = _XSetLastRequestRead(dpy, (xGenericReply *)wire);
	mevent->display = dpy;
	mevent->screen = wire->u.event.screen;
	mevent->time = wire->u.event.time;
	mevent->state = wire->u.event.state;
	mevent->dx = wire->u.event.dx;
	mevent->dy = wire->u.event.dy;
	return True;
  case ButtonPress:
  case ButtonRelease:
	bevent = (XDGAButtonEvent*)event;
	bevent->type = wire->u.u.type & 0x7F;
	bevent->serial = _XSetLastRequestRead(dpy, (xGenericReply *)wire);
	bevent->display = dpy;
	bevent->screen = wire->u.event.screen;
	bevent->time = wire->u.event.time;
	bevent->state = wire->u.event.state;
	bevent->button = wire->u.u.detail;
	return True;
  case KeyPress:
  case KeyRelease:
	kevent = (XDGAKeyEvent*)event;
	kevent->type = wire->u.u.type & 0x7F;
	kevent->serial = _XSetLastRequestRead(dpy, (xGenericReply *)wire);
	kevent->display = dpy;
	kevent->screen = wire->u.event.screen;
	kevent->time = wire->u.event.time;
	kevent->state = wire->u.event.state;
	kevent->keycode = wire->u.u.detail;
	return True;
  }

  return False;
}


Bool XDGAQueryExtension (
    Display *dpy,
    int *event_basep,
    int *error_basep
){
    XExtDisplayInfo *info = xdga_find_display (dpy);

    if (XextHasExtension(info)) {
	*event_basep = info->codes->first_event;
	*error_basep = info->codes->first_error;
	return True;
    } else {
	return False;
    }
}


Bool XDGAQueryVersion(
    Display *dpy,
    int *majorVersion,
    int *minorVersion
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGAQueryVersionReply rep;
    xXDGAQueryVersionReq *req;

    XDGACheckExtension (dpy, info, False);

    LockDisplay(dpy);
    GetReq(XDGAQueryVersion, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGAQueryVersion;
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	UnlockDisplay(dpy);
	SyncHandle();
	return False;
    }
    *majorVersion = rep.majorVersion;
    *minorVersion = rep.minorVersion;
    UnlockDisplay(dpy);
    SyncHandle();
    if (*majorVersion >= 2)
    {
	int i, j;

	for (i = 0, j = info->codes->first_event;
	     i < XF86DGANumberEvents;
	     i++, j++)
	{
	    XESetWireToEvent (dpy, j, xdga_wire_to_event);
	    XESetEventToWire (dpy, j, xdga_event_to_wire);
	}
	XDGASetClientVersion(dpy);
    }
    return True;
}

Bool XDGASetClientVersion(
    Display	*dpy
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGASetClientVersionReq *req;

    XDGACheckExtension (dpy, info, False);

    LockDisplay(dpy);
    GetReq(XDGASetClientVersion, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGASetClientVersion;
    req->major = XDGA_MAJOR_VERSION;
    req->minor = XDGA_MINOR_VERSION;
    UnlockDisplay(dpy);
    SyncHandle();
    return True;
}

Bool XDGAOpenFramebuffer(
    Display	*dpy,
    int 	screen
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGAOpenFramebufferReply rep;
    xXDGAOpenFramebufferReq *req;
    char *deviceName = NULL;
    Bool ret;

    XDGACheckExtension (dpy, info, False);

    LockDisplay(dpy);
    GetReq(XDGAOpenFramebuffer, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGAOpenFramebuffer;
    req->screen = screen;
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	UnlockDisplay(dpy);
	SyncHandle();
	return False;
    }

    if (rep.length) {
	if (rep.length < (INT_MAX >> 2)) {
	    unsigned long size = rep.length << 2;
	    deviceName = Xmalloc(size);
	    _XRead(dpy, deviceName, size);
	    deviceName[size - 1] = '\0';
	} else
	    _XEatDataWords(dpy, rep.length);
    }

    ret = XDGAMapFramebuffer(screen, deviceName,
				(unsigned char*)(long)rep.mem1,
				rep.size, rep.offset, rep.extra);

    if(deviceName)
	Xfree(deviceName);

    UnlockDisplay(dpy);
    SyncHandle();
    return ret;
}

void XDGACloseFramebuffer(
    Display	*dpy,
    int		screen
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGACloseFramebufferReq *req;

    XextSimpleCheckExtension (dpy, info, xdga_extension_name);

    XDGAUnmapFramebuffer(screen);

    LockDisplay(dpy);
    GetReq(XDGACloseFramebuffer, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGACloseFramebuffer;
    req->screen = screen;
    UnlockDisplay(dpy);
    SyncHandle();
}



XDGAMode* XDGAQueryModes(
    Display *dpy,
    int screen,
    int *num
){
    XExtDisplayInfo *dinfo = xdga_find_display (dpy);
    xXDGAQueryModesReply rep;
    xXDGAQueryModesReq *req;
    XDGAMode *modes = NULL;

    *num = 0;

    XDGACheckExtension (dpy, dinfo, NULL);

    LockDisplay(dpy);
    GetReq(XDGAQueryModes, req);
    req->reqType = dinfo->codes->major_opcode;
    req->dgaReqType = X_XDGAQueryModes;
    req->screen = screen;

    if (_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	if(rep.length) {
	   xXDGAModeInfo info;
	   unsigned long size = 0;
	   char *offset;

	   if ((rep.length < (INT_MAX >> 2)) &&
	       (rep.number < (INT_MAX / sizeof(XDGAMode)))) {
	       size = rep.length << 2;
	       if (size > (rep.number * sz_xXDGAModeInfo)) {
		   size -= rep.number * sz_xXDGAModeInfo; /* find text size */
		   modes = Xmalloc((rep.number * sizeof(XDGAMode)) + size);
		   offset = (char*)(&modes[rep.number]);  /* start of text */
	       }
	   }

	   if (modes != NULL) {
	      unsigned int i;
	      for(i = 0; i < rep.number; i++) {
		_XRead(dpy, (char*)(&info), sz_xXDGAModeInfo);

		modes[i].num = info.num;
		modes[i].verticalRefresh =
			(float)info.vsync_num / (float)info.vsync_den;
		modes[i].flags = info.flags;
		modes[i].imageWidth = info.image_width;
		modes[i].imageHeight = info.image_height;
		modes[i].pixmapWidth = info.pixmap_width;
		modes[i].pixmapHeight = info.pixmap_height;
		modes[i].bytesPerScanline = info.bytes_per_scanline;
		modes[i].byteOrder = info.byte_order;
		modes[i].depth = info.depth;
		modes[i].bitsPerPixel = info.bpp;
		modes[i].redMask = info.red_mask;
		modes[i].greenMask = info.green_mask;
		modes[i].blueMask = info.blue_mask;
		modes[i].visualClass = info.visual_class;
		modes[i].viewportWidth = info.viewport_width;
		modes[i].viewportHeight = info.viewport_height;
		modes[i].xViewportStep = info.viewport_xstep;
		modes[i].yViewportStep = info.viewport_ystep;
		modes[i].maxViewportX = info.viewport_xmax;
		modes[i].maxViewportY = info.viewport_ymax;
		modes[i].viewportFlags = info.viewport_flags;
		modes[i].reserved1 = info.reserved1;
		modes[i].reserved2 = info.reserved2;

		if (info.name_size > 0 && info.name_size <= size) {
		    _XRead(dpy, offset, info.name_size);
		    modes[i].name = offset;
		    modes[i].name[info.name_size - 1] = '\0';
		    offset += info.name_size;
		    size -= info.name_size;
		} else {
		    _XEatData(dpy, info.name_size);
		    modes[i].name = NULL;
		}
	      }
	      *num = rep.number;
	   } else
		_XEatDataWords(dpy, rep.length);
	}
    }

    UnlockDisplay(dpy);
    SyncHandle();

    return modes;
}


XDGADevice *
XDGASetMode(
    Display	*dpy,
    int		screen,
    int		mode
){
    XExtDisplayInfo *dinfo = xdga_find_display (dpy);
    xXDGASetModeReply rep;
    xXDGASetModeReq *req;
    XDGADevice *dev = NULL;
    Pixmap pid;

    XDGACheckExtension (dpy, dinfo, NULL);

    LockDisplay(dpy);
    GetReq(XDGASetMode, req);
    req->reqType = dinfo->codes->major_opcode;
    req->dgaReqType = X_XDGASetMode;
    req->screen = screen;
    req->mode = mode;
    req->pid = pid = XAllocID(dpy);

    if (_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
	if(rep.length) {
	   xXDGAModeInfo info;
	   unsigned long size;

	   if ((rep.length < (INT_MAX >> 2)) &&
	       (rep.length > (sz_xXDGAModeInfo >> 2))) {
	       size = rep.length << 2;
	       size -= sz_xXDGAModeInfo; /* get text size */

	       dev = Xmalloc(sizeof(XDGADevice) + size);
	   }

	   if(dev) {
		_XRead(dpy, (char*)(&info), sz_xXDGAModeInfo);

		dev->mode.num = info.num;
		dev->mode.verticalRefresh =
				(float)info.vsync_num / (float)info.vsync_den;
		dev->mode.flags = info.flags;
		dev->mode.imageWidth = info.image_width;
		dev->mode.imageHeight = info.image_height;
		dev->mode.pixmapWidth = info.pixmap_width;
		dev->mode.pixmapHeight = info.pixmap_height;
		dev->mode.bytesPerScanline = info.bytes_per_scanline;
		dev->mode.byteOrder = info.byte_order;
		dev->mode.depth = info.depth;
		dev->mode.bitsPerPixel = info.bpp;
		dev->mode.redMask = info.red_mask;
		dev->mode.greenMask = info.green_mask;
		dev->mode.blueMask = info.blue_mask;
		dev->mode.visualClass = info.visual_class;
		dev->mode.viewportWidth = info.viewport_width;
		dev->mode.viewportHeight = info.viewport_height;
		dev->mode.xViewportStep = info.viewport_xstep;
		dev->mode.yViewportStep = info.viewport_ystep;
		dev->mode.maxViewportX = info.viewport_xmax;
		dev->mode.maxViewportY = info.viewport_ymax;
		dev->mode.viewportFlags = info.viewport_flags;
		dev->mode.reserved1 = info.reserved1;
		dev->mode.reserved2 = info.reserved2;

		if (info.name_size > 0 && info.name_size <= size) {
		    dev->mode.name = (char*)(&dev[1]);
		    _XRead(dpy, dev->mode.name, info.name_size);
		    dev->mode.name[info.name_size - 1] = '\0';
		} else {
		    dev->mode.name = NULL;
		    _XEatDataWords(dpy, rep.length);
		}

		dev->pixmap = (rep.flags & XDGAPixmap) ? pid : 0;
		dev->data = XDGAGetMappedMemory(screen);

		if(dev->data)
		    dev->data += rep.offset;
	   }
	   /* not sure what to do if the allocation fails */
	   else
	       _XEatDataWords(dpy, rep.length);
	}
    }

    UnlockDisplay(dpy);
    SyncHandle();

    return dev;
}


void XDGASetViewport(
    Display	*dpy,
    int		screen,
    int		x,
    int		y,
    int		flags
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGASetViewportReq *req;

    XextSimpleCheckExtension (dpy, info, xdga_extension_name);

    LockDisplay(dpy);
    GetReq(XDGASetViewport, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGASetViewport;
    req->screen = screen;
    req->x = x;
    req->y = y;
    req->flags = flags;
    UnlockDisplay(dpy);
    SyncHandle();
}


void XDGAInstallColormap(
    Display	*dpy,
    int		screen,
    Colormap	cmap
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGAInstallColormapReq *req;

    XextSimpleCheckExtension (dpy, info, xdga_extension_name);

    LockDisplay(dpy);
    GetReq(XDGAInstallColormap, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGAInstallColormap;
    req->screen = screen;
    req->cmap = cmap;
    UnlockDisplay(dpy);
    SyncHandle();
}

void XDGASelectInput(
    Display	*dpy,
    int		screen,
    long	mask
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGASelectInputReq *req;

    XextSimpleCheckExtension (dpy, info, xdga_extension_name);

    LockDisplay(dpy);
    GetReq(XDGASelectInput, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGASelectInput;
    req->screen = screen;
    req->mask = mask;
    UnlockDisplay(dpy);
    SyncHandle();
}

void XDGAFillRectangle(
    Display	*dpy,
    int		screen,
    int		x,
    int		y,
    unsigned int	width,
    unsigned int	height,
    unsigned long	color
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGAFillRectangleReq *req;

    XextSimpleCheckExtension (dpy, info, xdga_extension_name);

    LockDisplay(dpy);
    GetReq(XDGAFillRectangle, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGAFillRectangle;
    req->screen = screen;
    req->x = x;
    req->y = y;
    req->width = width;
    req->height = height;
    req->color = color;
    UnlockDisplay(dpy);
    SyncHandle();
}

void XDGACopyArea(
    Display	*dpy,
    int		screen,
    int		srcx,
    int		srcy,
    unsigned int	width,
    unsigned int	height,
    int		dstx,
    int		dsty
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGACopyAreaReq *req;

    XextSimpleCheckExtension (dpy, info, xdga_extension_name);

    LockDisplay(dpy);
    GetReq(XDGACopyArea, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGACopyArea;
    req->screen = screen;
    req->srcx = srcx;
    req->srcy = srcy;
    req->width = width;
    req->height = height;
    req->dstx = dstx;
    req->dsty = dsty;
    UnlockDisplay(dpy);
    SyncHandle();
}

void XDGACopyTransparentArea(
    Display	*dpy,
    int		screen,
    int		srcx,
    int		srcy,
    unsigned int	width,
    unsigned int	height,
    int		dstx,
    int		dsty,
    unsigned long key
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGACopyTransparentAreaReq *req;

    XextSimpleCheckExtension (dpy, info, xdga_extension_name);

    LockDisplay(dpy);
    GetReq(XDGACopyTransparentArea, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGACopyTransparentArea;
    req->screen = screen;
    req->srcx = srcx;
    req->srcy = srcy;
    req->width = width;
    req->height = height;
    req->dstx = dstx;
    req->dsty = dsty;
    req->key = key;
    UnlockDisplay(dpy);
    SyncHandle();
}


int XDGAGetViewportStatus(
    Display *dpy,
    int screen
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGAGetViewportStatusReply rep;
    xXDGAGetViewportStatusReq *req;
    int status = 0;

    XDGACheckExtension (dpy, info, 0);

    LockDisplay(dpy);
    GetReq(XDGAGetViewportStatus, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGAGetViewportStatus;
    req->screen = screen;
    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse))
	status = rep.status;
    UnlockDisplay(dpy);
    SyncHandle();
    return status;
}

void XDGASync(
    Display *dpy,
    int screen
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGASyncReply rep;
    xXDGASyncReq *req;

    XextSimpleCheckExtension (dpy, info, xdga_extension_name);

    LockDisplay(dpy);
    GetReq(XDGASync, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGASync;
    req->screen = screen;
    _XReply(dpy, (xReply *)&rep, 0, xFalse);
    UnlockDisplay(dpy);
    SyncHandle();
}


void XDGAChangePixmapMode(
    Display *dpy,
    int screen,
    int *x,
    int *y,
    int mode
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGAChangePixmapModeReq *req;
    xXDGAChangePixmapModeReply rep;

    XextSimpleCheckExtension (dpy, info, xdga_extension_name);

    LockDisplay(dpy);
    GetReq(XDGAChangePixmapMode, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGAChangePixmapMode;
    req->screen = screen;
    req->x = *x;
    req->y = *y;
    req->flags = mode;
    _XReply(dpy, (xReply *)&rep, 0, xFalse);
    *x = rep.x;
    *y = rep.y;
    UnlockDisplay(dpy);
    SyncHandle();
}

Colormap XDGACreateColormap(
    Display *dpy,
    int screen,
    XDGADevice *dev,
    int	alloc
){
    XExtDisplayInfo *info = xdga_find_display (dpy);
    xXDGACreateColormapReq *req;
    Colormap cid;

    XDGACheckExtension (dpy, info, -1);

    LockDisplay(dpy);
    GetReq(XDGACreateColormap, req);
    req->reqType = info->codes->major_opcode;
    req->dgaReqType = X_XDGACreateColormap;
    req->screen = screen;
    req->mode = dev->mode.num;
    req->alloc = alloc;
    cid = req->id = XAllocID(dpy);
    UnlockDisplay(dpy);
    SyncHandle();

    return cid;
}


void XDGAKeyEventToXKeyEvent(
    XDGAKeyEvent* dk,
    XKeyEvent* xk
){
    xk->type = dk->type;
    xk->serial = dk->serial;
    xk->send_event = False;
    xk->display = dk->display;
    xk->window = RootWindow(dk->display, dk->screen);
    xk->root = xk->window;
    xk->subwindow = None;
    xk->time = dk->time;
    xk->x = xk->y = xk->x_root = xk->y_root = 0;
    xk->state = dk->state;
    xk->keycode = dk->keycode;
    xk->same_screen = True;
}

#include <X11/Xmd.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#if defined(ISC)
# define HAS_SVR3_MMAP
# include <sys/types.h>
# include <errno.h>

# include <sys/at_ansi.h>
# include <sys/kd.h>

# include <sys/sysmacros.h>
# include <sys/immu.h>
# include <sys/region.h>

# include <sys/mmap.h>
#else
# if defined(Lynx) && defined(NO_MMAP)
#  include <sys/types.h>
#  include <errno.h>
#  include <smem.h>
# else
#  if !defined(__UNIXOS2__)
#   include <sys/mman.h>
#  endif
# endif
#endif
#include <sys/wait.h>
#include <signal.h>
#include <unistd.h>

#if defined(SVR4) && !defined(sun)
#define DEV_MEM "/dev/pmem"
#elif defined(SVR4) && defined(sun)
#define DEV_MEM "/dev/xsvc"
#elif defined(HAS_APERTURE_DRV)
#define DEV_MEM "/dev/xf86"
#else
#define DEV_MEM "/dev/mem"
#endif



typedef struct _DGAMapRec{
  unsigned char *physical;
  unsigned char *virtual;
  CARD32 size;
  int fd;
  int screen;
  struct _DGAMapRec *next;
} DGAMapRec, *DGAMapPtr;

static Bool
DGAMapPhysical(int, const char*, unsigned char*, CARD32, CARD32, CARD32, DGAMapPtr);
static void DGAUnmapPhysical(DGAMapPtr);

static DGAMapPtr _Maps = NULL;


unsigned char*
XDGAGetMappedMemory(int screen)
{
    DGAMapPtr pMap = _Maps;
    unsigned char *pntr = NULL;

    while(pMap != NULL) {
	if(pMap->screen == screen) {
	    pntr = pMap->virtual;
	    break;
	}
	pMap = pMap->next;
    }

    return pntr;
}

Bool
XDGAMapFramebuffer(
   int screen,
   char *name,			/* optional device name */
   unsigned char* base,		/* physical memory */
   CARD32 size,			/* size */
   CARD32 offset,		/* optional offset */
   CARD32 extra			/* optional extra data */
){
   DGAMapPtr pMap = _Maps;
   Bool result;

   /* is it already mapped ? */
   while(pMap != NULL) {
     if(pMap->screen == screen)
	return True;
     pMap = pMap->next;
   }

   if(extra & XDGANeedRoot) {
    /* we should probably check if we have root permissions and
       return False here */

   }

   pMap = (DGAMapPtr)Xmalloc(sizeof(DGAMapRec));

   result = DGAMapPhysical(screen, name, base, size, offset, extra, pMap);

   if(result) {
      pMap->next = _Maps;
      _Maps = pMap;
   } else
      Xfree(pMap);

   return result;
}

void
XDGAUnmapFramebuffer(int screen)
{
   DGAMapPtr pMap = _Maps;
   DGAMapPtr pPrev = NULL;

   /* is it already mapped */
    while(pMap != NULL) {
	if(pMap->screen == screen)
	    break;
	pPrev = pMap;
	pMap = pMap->next;
    }

    if(!pMap)
	return;

    DGAUnmapPhysical(pMap);

    if(!pPrev)
	_Maps = pMap->next;
    else
	pPrev->next = pMap->next;

    Xfree(pMap);
}


static Bool
DGAMapPhysical(
   int screen,
   const char *name,		/* optional device name */
   unsigned char* base,		/* physical memory */
   CARD32 size,			/* size */
   CARD32 offset,		/* optional offset */
   CARD32 extra,		/* optional extra data */
   DGAMapPtr pMap
) {
#if defined(ISC) && defined(HAS_SVR3_MMAP)
    struct kd_memloc mloc;
#elif defined(__UNIXOS2__)
    APIRET rc;
    ULONG action;
    HFILE hfd;
#endif

    base += offset;

    pMap->screen = screen;
    pMap->physical = base;
    pMap->size = size;

#if defined(ISC) && defined(HAS_SVR3_MMAP)
    if ((pMap->fd = open("/dev/mmap", O_RDWR)) < 0)
	return False;
    mloc.vaddr = (char *)0;
    mloc.physaddr = (char *)base;
    mloc.length = size;
    mloc.ioflg=1;

    if ((pMap->virtual = (void *)ioctl(pMap->fd, MAP, &mloc)) == (void *)-1)
	return False;
#elif defined (__UNIXOS2__)
    /*
     * Dragon warning here! /dev/pmap$ is never closed, except on progam exit.
     * Consecutive calling of this routine will make PMAP$ driver run out
     * of memory handles. Some umap/close mechanism should be provided
     */

    rc = DosOpen("/dev/pmap$", &hfd, &action, 0, FILE_NORMAL, FILE_OPEN,
		 OPEN_ACCESS_READWRITE | OPEN_SHARE_DENYNONE, (PEAOP2)NULL);
    if (rc != 0)
	return False;
    {
	struct map_ioctl {
		union {
			ULONG phys;
			void* user;
		} a;
		ULONG size;
	} pmap,dmap;
	ULONG plen,dlen;
#define XFREE86_PMAP	0x76
#define PMAP_MAP	0x44

	pmap.a.phys = base;
	pmap.size = size;
	rc = DosDevIOCtl(hfd, XFREE86_PMAP, PMAP_MAP,
			 (PULONG)&pmap, sizeof(pmap), &plen,
			 (PULONG)&dmap, sizeof(dmap), &dlen);
	if (rc == 0) {
		pMap->virtual = dmap.a.user;
	}
   }
   if (rc != 0)
	return False;
#elif defined (Lynx) && defined(NO_MMAP)
    pMap->virtual = smem_create("XF86DGA", (char*)base, size, SM_READ|SM_WRITE);
#else
#ifndef MAP_FILE
#define MAP_FILE 0
#endif
    if (!name)
	    name = DEV_MEM;
    if ((pMap->fd = open(name, O_RDWR)) < 0)
	return False;
    pMap->virtual = mmap(NULL, size, PROT_READ | PROT_WRITE,
			MAP_FILE | MAP_SHARED, pMap->fd, (off_t)(uintptr_t)base);
    if (pMap->virtual == (void *)-1)
	return False;
    mprotect(pMap->virtual, size, PROT_READ | PROT_WRITE);
#endif

    return True;
}



static void
DGAUnmapPhysical(DGAMapPtr pMap)
{
#if defined(ISC) && defined(HAS_SVR3_MMAP)
    /* XXX Add unmapping code here. */
#elif defined (__UNIXOS2__)
    /* XXX Add unmapping code here. */
#elif defined(Lynx) && defined(NO_MMAP)
	/* XXX this doesn't allow enable after disable */
    smem_create(NULL, pMap->virtual, pMap->size, SM_DETACH);
    smem_remove("XF86DGA");
#else
    if (pMap->virtual && pMap->virtual != (void *)-1) {
	mprotect(pMap->virtual,pMap->size, PROT_READ);
	munmap(pMap->virtual, pMap->size);
	pMap->virtual = 0;
    }
    if (pMap->fd >= 0) {
	close(pMap->fd);
	pMap->fd = -1;
    }
#endif
}
@


1.6
log
@Merge upstream fixes for several X libs vulnerabilities
discovered by Ilja van Sprundel.

CVE-2013-1981 X.org libX11 1.5.99.901 (1.6 RC1) integer overflows
CVE-2013-1982 X.org libXext 1.3.1 integer overflows
CVE-2013-1983 X.org libXfixes 5.0 integer overflows
CVE-2013-1984 X.org libXi 1.7.1 integer overflows
CVE-2013-1985 X.org libXinerama 1.1.2 integer overflows
CVE-2013-1986 X.org libXrandr 1.4.0 integer overflows
CVE-2013-1987 X.org libXrender 0.9.7 integer overflows
CVE-2013-1988 X.org libXRes 1.0.6 integer overflows
CVE-2013-1989 X.org libXv 1.0.7 integer overflows
CVE-2013-1990 X.org libXvMC 1.0.7 integer overflows
CVE-2013-1991 X.org libXxf86dga 1.1.3 integer overflows
CVE-2013-1992 X.org libdmx 1.1.2 integer overflows
CVE-2013-1994 X.org libchromeXvMC & libchromeXvMCPro in openChrome
0.3.2 integer overflows
CVE-2013-1995 X.org libXi 1.7.1 sign extension issues
CVE-2013-1996 X.org libFS 1.0.4 sign extension issues
CVE-2013-1997 X.org libX11 1.5.99.901 (1.6 RC1) buffer overflows
CVE-2013-1998 X.org libXi 1.7.1 buffer overflows
CVE-2013-1999 X.org libXvMC 1.0.7 buffer overflows
CVE-2013-2000 X.org libXxf86dga 1.1.3 buffer overflows
CVE-2013-2001 X.org libXxf86vm 1.1.2 buffer overflows
CVE-2013-2002 X.org libXt 1.1.3 buffer overflows
CVE-2013-2003 X.org libXcursor 1.1.13 integer overflows
CVE-2013-2004 X.org libX11 1.5.99.901 (1.6 RC1) unbounded recursion
CVE-2013-2005 X.org libXt 1.1.3 memory corruption
CVE-2013-2066 X.org libXv 1.0.7 buffer overflows
@
text
@d26 1
a40 1

d975 1
a975 1
	MAP_FILE | MAP_SHARED, pMap->fd, (off_t)(uintptr_t)base);
@


1.5
log
@Fix build on 32 bit architectures. Problem noticed by naddy@@.
@
text
@d9 3
d27 12
d253 8
a260 3
    if(rep.length) {
	deviceName = Xmalloc(rep.length << 2);
	_XRead(dpy, deviceName, rep.length << 2);
d320 1
a320 1
	   int i, size;
d323 9
a331 5
	   size = rep.length << 2;
	   size -= rep.number * sz_xXDGAModeInfo; /* find text size */
	   modes = (XDGAMode*)Xmalloc((rep.number * sizeof(XDGAMode)) + size);
	   offset = (char*)(&modes[rep.number]); /* start of text */

d333 2
a334 1
	   if(modes) {
d364 10
a373 3
		_XRead(dpy, offset, info.name_size);
		modes[i].name = offset;
		offset += info.name_size;
d377 1
a377 1
		_XEatData(dpy, rep.length << 2);
d413 1
a413 1
	   int size;
d415 4
a418 2
	   size = rep.length << 2;
	   size -= sz_xXDGAModeInfo; /* get text size */
d420 2
a421 1
	   dev = (XDGADevice*)Xmalloc(sizeof(XDGADevice) + size);
d452 8
a459 2
		dev->mode.name = (char*)(&dev[1]);
		_XRead(dpy, dev->mode.name, info.name_size);
d468 2
@


1.4
log
@Upate to libXxf86dga 1.1.3
@
text
@d23 1
d932 1
a932 1
			MAP_FILE | MAP_SHARED, pMap->fd, (off_t)base);
@


1.3
log
@Update to libXxf86dga 1.1.2. No functional change.
@
text
@d28 1
a28 1
char *xdga_extension_name = XF86DGANAME;
d33 1
a33 1
 
d69 3
a71 3
XEXT_GENERATE_FIND_DISPLAY (xdga_find_display, xdga_info, 
				   "XFree86-DGA", 
				   &xdga_extension_hooks, 
d157 1
a157 1
    int *majorVersion, 
d185 1
a185 1
	     i++, j++) 
d243 1
a243 1
				(unsigned char*)(long)rep.mem1, 
d247 1
a247 1
	Xfree(deviceName);	
d308 1
a308 1
	   if(modes) {	
d313 1
a313 1
		modes[i].verticalRefresh = 
d336 1
a336 1
		modes[i].reserved2 = info.reserved2;	
d355 1
a355 1
XDGADevice * 
d376 1
a376 1
    
d386 1
a386 1
	    
d391 1
a391 1
		dev->mode.verticalRefresh = 
d416 1
a416 1
		dev->mode.name = (char*)(&dev[1]);	
d424 1
a424 1
	   } 
d594 1
a594 1
    int screen 
d617 1
a617 1
    int screen 
d641 1
a641 1
    int mode 
d692 1
a692 1
    XDGAKeyEvent* dk, 
d713 1
a713 1
#if defined(ISC) 
d763 1
a763 1
DGAMapPhysical(int, char*, unsigned char*, CARD32, CARD32, CARD32, DGAMapPtr); 
d797 1
a797 1
   
d818 1
a818 1
   } else 
d820 1
a820 1
   
d855 1
a855 1
   char *name,			/* optional device name */
d869 1
a869 1
  
d930 1
a930 1
    pMap->virtual = mmap(NULL, size, PROT_READ | PROT_WRITE, 
@


1.2
log
@update to libXxf86dga 1.1.1
@
text
@a0 1
/* $XFree86: xc/lib/Xxf86dga/XF86DGA2.c,v 1.23 2003/05/05 20:42:30 tsi Exp $ */
a16 2
#define NEED_EVENTS
#define NEED_REPLIES
@


1.1
log
@Initial revision
@
text
@d21 2
a22 2
#include <X11/extensions/xf86dga.h>
#include <X11/extensions/xf86dgastr.h>
a712 1
#include <X11/extensions/xf86dga.h>
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
