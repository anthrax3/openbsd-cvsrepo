head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.4
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.2
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.4.0.14
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.12
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.10
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.8
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.10
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.8
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.8
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.6
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_2_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2016.10.04.15.02.31;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	NCLOmmyYBlSjSh3b;

1.4
date	2013.03.09.16.34.37;	author matthieu;	state Exp;
branches
	1.4.12.1
	1.4.14.1;
next	1.3;

1.3
date	2010.10.31.15.52.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.02.15.20.43;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.16.39.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.16.39.04;	author matthieu;	state Exp;
branches;
next	;

1.4.12.1
date	2016.10.04.18.55.14;	author matthieu;	state Exp;
branches;
next	;
commitid	PNaHexTGDQbxwlMB;

1.4.14.1
date	2016.10.04.18.54.01;	author matthieu;	state Exp;
branches;
next	;
commitid	b1RDOJn7dNqLwuaq;


desc
@@


1.5
log
@Avoid out of boundary accesses on illegal responses

The responses of the connected X server have to be properly checked
to avoid out of boundary accesses that could otherwise be triggered
by a malicious server.

From Tobias Stoeckmann / X.Org security advisory Oct 4, 2016
@
text
@/*
 * Copyright © 2000 Compaq Computer Corporation, Inc.
 * Copyright © 2002 Hewlett Packard Company, Inc.
 * Copyright © 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 *
 * Author:  Jim Gettys, HP Labs, HP.
 * Author:  Keith Packard, Intel Corporation
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <limits.h>
#include <stdio.h>
#include <X11/Xlib.h>
/* we need to be able to manipulate the Display structure on events */
#include <X11/Xlibint.h>
#include <X11/extensions/render.h>
#include <X11/extensions/Xrender.h>
#include "Xrandrint.h"

static XRRScreenConfiguration *_XRRGetScreenInfo (Display *dpy,
						  XExtDisplayInfo *info,
						  Window window);

Rotation XRRConfigRotations(XRRScreenConfiguration *config, Rotation *current_rotation)
{
  *current_rotation = config->current_rotation;
  return config->rotations;
}

XRRScreenSize *XRRConfigSizes(XRRScreenConfiguration *config, int *nsizes)
{
   *nsizes = config->nsizes;
  return config->sizes;
}

short *XRRConfigRates (XRRScreenConfiguration *config, int sizeID, int *nrates)
{
    short   *r = config->rates;
    int	    nents = config->nrates;

    /* Skip over the intervening rate lists */
    while (sizeID > 0 && nents > 0)
    {
	int i = (*r + 1);
	r += i;
	nents -= i;
	sizeID--;
    }
    if (!nents)
    {
	*nrates = 0;
	return NULL;
    }
    *nrates = (int) *r;
    return r + 1;
}

Time XRRConfigTimes (XRRScreenConfiguration *config, Time *config_timestamp)
{
    *config_timestamp = config->config_timestamp;
    return config->timestamp;
}


SizeID XRRConfigCurrentConfiguration (XRRScreenConfiguration *config,
			      Rotation *rotation)
{
    *rotation = (Rotation) config->current_rotation;
    return (SizeID) config->current_size;
}

short XRRConfigCurrentRate (XRRScreenConfiguration *config)
{
    return config->current_rate;
}

/*
 * Go get the screen configuration data and salt it away for future use;
 * returns NULL if extension not supported
 */
static XRRScreenConfiguration *_XRRValidateCache (Display *dpy,
						  XExtDisplayInfo *info,
						  int screen)
{
    XRRScreenConfiguration **configs;
    XRandRInfo *xrri;

    if ((screen >= 0) && (screen < ScreenCount(dpy)) && XextHasExtension(info)) {
	xrri = (XRandRInfo *) info->data;
	configs = xrri->config;

	if (configs[screen] == NULL)
	    configs[screen] = _XRRGetScreenInfo (dpy, info, RootWindow(dpy, screen));
	return configs[screen];
    } else {
	return NULL;
    }
}

/* given a screen, return the information from the (possibly) cached data */
Rotation XRRRotations(Display *dpy, int screen, Rotation *current_rotation)
{
  XRRScreenConfiguration *config;
  XExtDisplayInfo *info = XRRFindDisplay(dpy);
  Rotation cr;
  LockDisplay(dpy);
  if ((config = _XRRValidateCache(dpy, info, screen))) {
    *current_rotation = config->current_rotation;
    cr = config->rotations;
    UnlockDisplay(dpy);
    return cr;
  }
  else {
    UnlockDisplay(dpy);
    *current_rotation = RR_Rotate_0;
    return 0;	/* no rotations supported */
  }
}

/* given a screen, return the information from the (possibly) cached data */
XRRScreenSize *XRRSizes(Display *dpy, int screen, int *nsizes)
{
  XRRScreenConfiguration *config;
  XExtDisplayInfo *info = XRRFindDisplay(dpy);
  XRRScreenSize *sizes;

  LockDisplay(dpy);
  if ((config = _XRRValidateCache(dpy, info, screen))) {
    *nsizes = config->nsizes;
    sizes = config->sizes;
    UnlockDisplay(dpy);
    return sizes;
    }
  else {
    UnlockDisplay(dpy);
    *nsizes = 0;
    return NULL;
  }
}

short *XRRRates (Display *dpy, int screen, int sizeID, int *nrates)
{
  XRRScreenConfiguration *config;
  XExtDisplayInfo *info = XRRFindDisplay(dpy);
  short *rates;

  LockDisplay(dpy);
  if ((config = _XRRValidateCache(dpy, info, screen))) {
    rates = XRRConfigRates (config, sizeID, nrates);
    UnlockDisplay(dpy);
    return rates;
    }
  else {
    UnlockDisplay(dpy);
    *nrates = 0;
    return NULL;
  }
}

/* given a screen, return the information from the (possibly) cached data */
Time XRRTimes (Display *dpy, int screen, Time *config_timestamp)
{
  XRRScreenConfiguration *config;
  XExtDisplayInfo *info = XRRFindDisplay(dpy);
  Time ts;

  LockDisplay(dpy);
  if ((config = _XRRValidateCache(dpy, info, screen))) {
      *config_timestamp = config->config_timestamp;
      ts = config->timestamp;
      UnlockDisplay(dpy);
      return ts;
    } else {
      UnlockDisplay(dpy);
	return CurrentTime;
    }
}

/* need a version that does not hold the display lock */
static XRRScreenConfiguration *_XRRGetScreenInfo (Display *dpy,
						  XExtDisplayInfo *info,
						  Window window)
{
    xRRGetScreenInfoReply   rep;
    xRRGetScreenInfoReq	    *req;
    _XAsyncHandler 	    async;
    _XRRVersionState	    async_state;
    int			    nbytes, nbytesRead, rbytes;
    int			    i;
    xScreenSizes	    size;
    struct _XRRScreenConfiguration  *scp;
    XRRScreenSize	    *ssp;
    short    		    *rates;
    xRRQueryVersionReq      *vreq;
    XRandRInfo		    *xrri;
    Bool		    getting_version = False;

    xrri = (XRandRInfo *) info->data;
    if (!xrri)
	return NULL;

    if (xrri->major_version == -1)
    {
	/* hide a version query in the request */
	GetReq (RRQueryVersion, vreq);
	vreq->reqType = info->codes->major_opcode;
	vreq->randrReqType = X_RRQueryVersion;
	vreq->majorVersion = RANDR_MAJOR;
	vreq->minorVersion = RANDR_MINOR;

	async_state.version_seq = dpy->request;
	async_state.error = False;
	async.next = dpy->async_handlers;
	async.handler = _XRRVersionHandler;
	async.data = (XPointer) &async_state;
	dpy->async_handlers = &async;

	getting_version = True;
    }

    GetReq (RRGetScreenInfo, req);
    req->reqType = info->codes->major_opcode;
    req->randrReqType = X_RRGetScreenInfo;
    req->window = window;

    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))
    {
	if (getting_version)
	    DeqAsyncHandler (dpy, &async);
	SyncHandle ();
	return NULL;
    }
    if (getting_version)
    {
	DeqAsyncHandler (dpy, &async);
	if (async_state.error)
	{
	    UnlockDisplay (dpy);
	    SyncHandle();
	    LockDisplay (dpy);
	}
	xrri->major_version = async_state.major_version;
	xrri->minor_version = async_state.minor_version;
	xrri->has_rates = _XRRHasRates (xrri->minor_version, xrri->major_version);
    }

    /*
     * Make the reply compatible with v1.1
     */
    if (!xrri->has_rates)
    {
	rep.rate = 0;
	rep.nrateEnts = 0;
    }
    if (rep.length < INT_MAX >> 2) {
	nbytes = (long) rep.length << 2;

	nbytesRead = (long) (rep.nSizes * SIZEOF (xScreenSizes) +
			    ((rep.nrateEnts + 1)& ~1) * 2 /* SIZEOF(CARD16) */);

	/*
	 * first we must compute how much space to allocate for
	 * randr library's use; we'll allocate the structures in a single
	 * allocation, on cleanlyness grounds.
	 */

	rbytes = sizeof (XRRScreenConfiguration) +
	  (rep.nSizes * sizeof (XRRScreenSize) +
	   rep.nrateEnts * sizeof (int));

	scp = (struct _XRRScreenConfiguration *) Xmalloc(rbytes);
    } else {
	nbytes = 0;
	nbytesRead = 0;
	rbytes = 0;
	scp = NULL;
    }

    if (scp == NULL) {
	_XEatData (dpy, (unsigned long) nbytes);
	return NULL;
    }


    ssp = (XRRScreenSize *)(scp + 1);
    rates = (short *) (ssp + rep.nSizes);

    /* set up the screen configuration structure */
    scp->screen =
      ScreenOfDisplay (dpy, XRRRootToScreen(dpy, rep.root));

    scp->sizes = ssp;
    scp->rates = rates;
    scp->rotations = rep.setOfRotations;
    scp->current_size = rep.sizeID;
    scp->current_rate = rep.rate;
    scp->current_rotation = rep.rotation;
    scp->timestamp = rep.timestamp;
    scp->config_timestamp = rep.configTimestamp;
    scp->nsizes = rep.nSizes;
    scp->nrates = rep.nrateEnts;

    /*
     * Time to unpack the data from the server.
     */

    /*
     * First the size information
     */
    for (i = 0; i < rep.nSizes; i++)  {
	_XReadPad (dpy, (char *) &size, SIZEOF (xScreenSizes));

        ssp[i].width = size.widthInPixels;
	ssp[i].height = size.heightInPixels;
	ssp[i].mwidth = size.widthInMillimeters;
	ssp[i].mheight = size.heightInMillimeters;
    }
    /*
     * And the rates
     */
    _XRead16Pad (dpy, rates, 2 /* SIZEOF (CARD16) */ * rep.nrateEnts);

    /*
     * Skip any extra data
     */
    if (nbytes > nbytesRead)
	_XEatData (dpy, (unsigned long) (nbytes - nbytesRead));

    return (XRRScreenConfiguration *)(scp);
}

XRRScreenConfiguration *XRRGetScreenInfo (Display *dpy, Window window)
{
    XRRScreenConfiguration *config;
    XExtDisplayInfo *info = XRRFindDisplay(dpy);
    XRRFindDisplay(dpy);
    LockDisplay (dpy);
    config = _XRRGetScreenInfo(dpy, info, window);
    UnlockDisplay (dpy);
    SyncHandle ();
    return config;
}


void XRRFreeScreenConfigInfo (XRRScreenConfiguration *config)
{
    Xfree (config);
}

Status XRRSetScreenConfigAndRate (Display *dpy,
				  XRRScreenConfiguration *config,
				  Drawable draw,
				  int size_index,
				  Rotation rotation,
				  short rate,
				  Time timestamp)
{
    XExtDisplayInfo *info = XRRFindDisplay (dpy);
    xRRSetScreenConfigReply rep;
    XRandRInfo *xrri;
    int major, minor;

    RRCheckExtension (dpy, info, 0);

    /* Make sure has_rates is set */
    if (!XRRQueryVersion (dpy, &major, &minor))
	return 0;

    LockDisplay (dpy);
    xrri = (XRandRInfo *) info->data;
    if (xrri->has_rates)
    {
	xRRSetScreenConfigReq  *req;
	GetReq (RRSetScreenConfig, req);
	req->reqType = info->codes->major_opcode;
	req->randrReqType = X_RRSetScreenConfig;
	req->drawable = draw;
	req->sizeID = size_index;
	req->rotation = rotation;
	req->timestamp = timestamp;
	req->configTimestamp = config->config_timestamp;
	req->rate = rate;
    }
    else
    {
	xRR1_0SetScreenConfigReq  *req;
	GetReq (RR1_0SetScreenConfig, req);
	req->reqType = info->codes->major_opcode;
	req->randrReqType = X_RRSetScreenConfig;
	req->drawable = draw;
	req->sizeID = size_index;
	req->rotation = rotation;
	req->timestamp = timestamp;
	req->configTimestamp = config->config_timestamp;
    }

    (void) _XReply (dpy, (xReply *) &rep, 0, xTrue);

    /* actually .errorCode in struct xError */
    if (rep.status == RRSetConfigSuccess) {
      /* if we succeed, set our view of reality to what we set it to */
      config->config_timestamp = rep.newConfigTimestamp;
      config->timestamp = rep.newTimestamp;
      config->screen = ScreenOfDisplay (dpy, XRRRootToScreen(dpy, rep.root));
      config->current_size = size_index;
      config->current_rotation = rotation;
    }
    UnlockDisplay (dpy);
    SyncHandle ();
    return(rep.status);
}

Status XRRSetScreenConfig (Display *dpy,
			   XRRScreenConfiguration *config,
			   Drawable draw,
			   int size_index,
			   Rotation rotation, Time timestamp)
{
    return XRRSetScreenConfigAndRate (dpy, config, draw, size_index,
				      rotation, 0, timestamp);
}
@


1.4
log
@Update to libXrandr 1.4.0
@
text
@d32 1
d276 2
d279 2
a280 1
    nbytes = (long) rep.length << 2;
d282 9
a290 2
    nbytesRead = (long) (rep.nSizes * SIZEOF (xScreenSizes) +
			 ((rep.nrateEnts + 1)& ~1) * 2 /* SIZEOF (CARD16) */);
d292 7
a298 9
    /*
     * first we must compute how much space to allocate for
     * randr library's use; we'll allocate the structures in a single
     * allocation, on cleanlyness grounds.
     */

    rbytes = sizeof (XRRScreenConfiguration) +
      (rep.nSizes * sizeof (XRRScreenSize) +
       rep.nrateEnts * sizeof (int));
a299 1
    scp = (struct _XRRScreenConfiguration *) Xmalloc(rbytes);
@


1.4.12.1
log
@Protocol handling issues in X Window System client libraries
X.Org security advisory: October 4, 2016

Fix a number of issues in the way various X client libraries handle
server responses.

Checked by tj@@
@
text
@a31 1
#include <limits.h>
a274 2
    if (rep.length < INT_MAX >> 2) {
	nbytes = (long) rep.length << 2;
d276 1
a276 2
	nbytesRead = (long) (rep.nSizes * SIZEOF (xScreenSizes) +
			    ((rep.nrateEnts + 1)& ~1) * 2 /* SIZEOF(CARD16) */);
d278 2
a279 9
	/*
	 * first we must compute how much space to allocate for
	 * randr library's use; we'll allocate the structures in a single
	 * allocation, on cleanlyness grounds.
	 */

	rbytes = sizeof (XRRScreenConfiguration) +
	  (rep.nSizes * sizeof (XRRScreenSize) +
	   rep.nrateEnts * sizeof (int));
d281 9
a289 7
	scp = (struct _XRRScreenConfiguration *) Xmalloc(rbytes);
    } else {
	nbytes = 0;
	nbytesRead = 0;
	rbytes = 0;
	scp = NULL;
    }
d291 1
@


1.4.14.1
log
@Protocol handling issues in X Window System client libraries
X.Org security advisory: October 4, 2016

Fix a number of issues in the way various X client libraries handle
server responses.

Checked by tj@@
@
text
@a31 1
#include <limits.h>
a274 2
    if (rep.length < INT_MAX >> 2) {
	nbytes = (long) rep.length << 2;
d276 1
a276 2
	nbytesRead = (long) (rep.nSizes * SIZEOF (xScreenSizes) +
			    ((rep.nrateEnts + 1)& ~1) * 2 /* SIZEOF(CARD16) */);
d278 2
a279 9
	/*
	 * first we must compute how much space to allocate for
	 * randr library's use; we'll allocate the structures in a single
	 * allocation, on cleanlyness grounds.
	 */

	rbytes = sizeof (XRRScreenConfiguration) +
	  (rep.nSizes * sizeof (XRRScreenSize) +
	   rep.nrateEnts * sizeof (int));
d281 9
a289 7
	scp = (struct _XRRScreenConfiguration *) Xmalloc(rbytes);
    } else {
	nbytes = 0;
	nbytesRead = 0;
	rbytes = 0;
	scp = NULL;
    }
d291 1
@


1.3
log
@Update to libXrandr 1.3.1. No functional change, except for a small bug fix.
@
text
@d85 1
a85 1
SizeID XRRConfigCurrentConfiguration (XRRScreenConfiguration *config, 
d97 2
a98 2
/* 
 * Go get the screen configuration data and salt it away for future use; 
d101 1
a101 1
static XRRScreenConfiguration *_XRRValidateCache (Display *dpy, 
d143 1
a143 1
  XRRScreenConfiguration *config; 
d158 1
a158 1
  }  
d163 1
a163 1
  XRRScreenConfiguration *config; 
d177 1
a177 1
  }  
d183 1
a183 1
  XRRScreenConfiguration *config; 
d230 1
a230 1
    
d275 1
a275 1
    
d280 3
a282 3
    
    /* 
     * first we must compute how much space to allocate for 
d302 1
a302 1
    scp->screen = 
d325 1
a325 1
	
d335 1
a335 1
    
d341 1
a341 1
    
d357 1
a357 1
    
d367 1
a367 1
				  Rotation rotation, 
d381 1
a381 1
    
d409 1
a409 1
    
@


1.2
log
@update to libXrandr 1.3.0
@
text
@d108 1
a108 1
    if (XextHasExtension(info)) {
d412 1
@


1.1
log
@Initial revision
@
text
@d72 1
a72 1
	return 0;
@


1.1.1.1
log
@libXrandr 1.2.2
@
text
@@
