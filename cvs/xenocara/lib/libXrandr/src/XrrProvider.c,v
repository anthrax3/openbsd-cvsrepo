head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.2
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.4.0.2
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.3.0.10
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.8
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.6
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2016.10.04.15.02.31;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	NCLOmmyYBlSjSh3b;

1.4
date	2016.03.06.13.37.21;	author matthieu;	state Exp;
branches
	1.4.2.1;
next	1.3;
commitid	lveYUhu3JlpVTSbB;

1.3
date	2013.09.28.17.47.02;	author matthieu;	state Exp;
branches
	1.3.10.1;
next	1.2;

1.2
date	2013.05.23.22.42.10;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.09.16.34.37;	author matthieu;	state Exp;
branches;
next	;

1.3.10.1
date	2016.10.04.18.55.14;	author matthieu;	state Exp;
branches;
next	;
commitid	PNaHexTGDQbxwlMB;

1.4.2.1
date	2016.10.04.18.54.01;	author matthieu;	state Exp;
branches;
next	;
commitid	b1RDOJn7dNqLwuaq;


desc
@@


1.5
log
@Avoid out of boundary accesses on illegal responses

The responses of the connected X server have to be properly checked
to avoid out of boundary accesses that could otherwise be triggered
by a malicious server.

From Tobias Stoeckmann / X.Org security advisory Oct 4, 2016
@
text
@/*
 * Copyright Â© 2011 Dave Airlie
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */


#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <limits.h>
#include <stdio.h>
#include <X11/Xlib.h>
/* we need to be able to manipulate the Display structure on events */
#include <X11/Xlibint.h>
#include <X11/extensions/render.h>
#include <X11/extensions/Xrender.h>
#include "Xrandrint.h"

XRRProviderResources *
XRRGetProviderResources(Display *dpy, Window window)
{
    XExtDisplayInfo		*info = XRRFindDisplay(dpy);
    xRRGetProvidersReply rep;
    xRRGetProvidersReq *req;
    XRRProviderResources *xrpr;
    long nbytes, nbytesRead;
    int rbytes;

    RRCheckExtension (dpy, info, NULL);

    LockDisplay (dpy);

    GetReq(RRGetProviders, req);
    req->reqType = info->codes->major_opcode;
    req->randrReqType = X_RRGetProviders;
    req->window = window;
    
    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))
    {
      UnlockDisplay (dpy);
      SyncHandle ();
      return NULL;
    }

    if (rep.length < INT_MAX >> 2) {
	nbytes = (long) rep.length << 2;

	nbytesRead = (long) (rep.nProviders * 4);

	rbytes = (sizeof(XRRProviderResources) + rep.nProviders *
		  sizeof(RRProvider));
	xrpr = (XRRProviderResources *) Xmalloc(rbytes);
    } else {
	nbytes = 0;
	nbytesRead = 0;
	rbytes = 0;
	xrpr = NULL;
    }

    if (xrpr == NULL) {
       _XEatDataWords (dpy, rep.length);
       UnlockDisplay (dpy);
       SyncHandle ();
       return NULL;
    }

    xrpr->timestamp = rep.timestamp;
    xrpr->nproviders = rep.nProviders;
    xrpr->providers = (RRProvider *)(xrpr + 1);

    _XRead32(dpy, (long *) xrpr->providers, rep.nProviders << 2);

    if (nbytes > nbytesRead)
      _XEatData (dpy, (unsigned long) (nbytes - nbytesRead));


    UnlockDisplay (dpy);
    SyncHandle();

    return (XRRProviderResources *) xrpr;
}

void
XRRFreeProviderResources(XRRProviderResources *provider_resources)
{
    free(provider_resources);
}

#define ProviderInfoExtra	(SIZEOF(xRRGetProviderInfoReply) - 32)  
XRRProviderInfo *
XRRGetProviderInfo(Display *dpy, XRRScreenResources *resources, RRProvider provider)
{
    XExtDisplayInfo	    *info = XRRFindDisplay(dpy);
    xRRGetProviderInfoReply rep;
    xRRGetProviderInfoReq *req;
    int nbytes, nbytesRead, rbytes;
    XRRProviderInfo *xpi;

    RRCheckExtension (dpy, info, NULL);

    LockDisplay (dpy);
    GetReq (RRGetProviderInfo, req);
    req->reqType = info->codes->major_opcode;
    req->randrReqType = X_RRGetProviderInfo;
    req->provider = provider;
    req->configTimestamp = resources->configTimestamp;

    if (!_XReply (dpy, (xReply *) &rep, ProviderInfoExtra >> 2, xFalse))
    {
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }

    if (rep.length > INT_MAX >> 2 || rep.length < ProviderInfoExtra >> 2)
    {
	if (rep.length < ProviderInfoExtra >> 2)
	    _XEatDataWords (dpy, rep.length);
	else
	    _XEatDataWords (dpy, rep.length - (ProviderInfoExtra >> 2));
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }

    nbytes = ((long) rep.length << 2) - ProviderInfoExtra;

    nbytesRead = (long)(rep.nCrtcs * 4 +
			rep.nOutputs * 4 +
			rep.nAssociatedProviders * 8 +
			((rep.nameLength + 3) & ~3));

    rbytes = (sizeof(XRRProviderInfo) +
	      rep.nCrtcs * sizeof(RRCrtc) +
	      rep.nOutputs * sizeof(RROutput) +
	      rep.nAssociatedProviders * (sizeof(RRProvider) + sizeof(unsigned int))+
	      rep.nameLength + 1);

    xpi = (XRRProviderInfo *)Xmalloc(rbytes);
    if (xpi == NULL) {
	_XEatDataWords (dpy, rep.length - (ProviderInfoExtra >> 2));
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }

    xpi->capabilities = rep.capabilities;
    xpi->ncrtcs = rep.nCrtcs;
    xpi->noutputs = rep.nOutputs;
    xpi->nassociatedproviders = rep.nAssociatedProviders;
    xpi->crtcs = (RRCrtc *)(xpi + 1);
    xpi->outputs = (RROutput *)(xpi->crtcs + rep.nCrtcs);
    xpi->associated_providers = (RRProvider *)(xpi->outputs + rep.nOutputs);
    xpi->associated_capability = (unsigned int *)(xpi->associated_providers + rep.nAssociatedProviders);
    xpi->name = (char *)(xpi->associated_capability + rep.nAssociatedProviders);

    _XRead32(dpy, (long *) xpi->crtcs, rep.nCrtcs << 2);
    _XRead32(dpy, (long *) xpi->outputs, rep.nOutputs << 2);

    _XRead32(dpy, (long *) xpi->associated_providers, rep.nAssociatedProviders << 2);

    /*
     * _XRead32 reads a series of 32-bit values from the protocol and writes
     * them out as a series of "long int" values, but associated_capability
     * is defined as unsigned int *, so that won't work for this array.
     * Instead we assume for now that "unsigned int" is also 32-bits, so
     * the values can be read without any conversion.
     */
    _XRead(dpy, (char *) xpi->associated_capability,
           rep.nAssociatedProviders << 2);

    _XReadPad(dpy, xpi->name, rep.nameLength);
    xpi->name[rep.nameLength] = '\0';

    /*
     * Skip any extra data
     */
    if (nbytes > nbytesRead)
	_XEatData (dpy, (unsigned long) (nbytes - nbytesRead));

    UnlockDisplay (dpy);
    SyncHandle ();
    return (XRRProviderInfo *) xpi;
}

void
XRRFreeProviderInfo(XRRProviderInfo *provider)
{
    free(provider);
}

int
XRRSetProviderOutputSource(Display *dpy, XID provider,
			   XID source_provider)
{
    XExtDisplayInfo	    *info = XRRFindDisplay(dpy);
    xRRSetProviderOutputSourceReq *req;

    RRCheckExtension (dpy, info, 0);
    LockDisplay (dpy);
    GetReq (RRSetProviderOutputSource, req);
    req->reqType = info->codes->major_opcode;
    req->randrReqType = X_RRSetProviderOutputSource;
    req->provider = provider;
    req->source_provider = source_provider;
    UnlockDisplay (dpy);
    SyncHandle ();
    return 0;
}

int
XRRSetProviderOffloadSink(Display *dpy, XID provider,
			  XID sink_provider)
{
    XExtDisplayInfo	    *info = XRRFindDisplay(dpy);
    xRRSetProviderOffloadSinkReq *req;

    RRCheckExtension (dpy, info, 0);
    LockDisplay (dpy);
    GetReq (RRSetProviderOffloadSink, req);
    req->reqType = info->codes->major_opcode;
    req->randrReqType = X_RRSetProviderOffloadSink;
    req->provider = provider;
    req->sink_provider = sink_provider;
    UnlockDisplay (dpy);
    SyncHandle ();
    return 0;
}
@


1.4
log
@Update to libXrandr 1.5.0
@
text
@d28 1
d63 2
a64 1
    nbytes = (long) rep.length << 2;
d66 1
a66 1
    nbytesRead = (long) (rep.nProviders * 4);
d68 9
a76 2
    rbytes = (sizeof(XRRProviderResources) + rep.nProviders * sizeof(RRProvider));
    xrpr = (XRRProviderResources *) Xmalloc(rbytes);
d128 11
@


1.4.2.1
log
@Protocol handling issues in X Window System client libraries
X.Org security advisory: October 4, 2016

Fix a number of issues in the way various X client libraries handle
server responses.

Checked by tj@@
@
text
@a27 1
#include <limits.h>
d62 1
a62 2
    if (rep.length < INT_MAX >> 2) {
	nbytes = (long) rep.length << 2;
d64 1
a64 1
	nbytesRead = (long) (rep.nProviders * 4);
d66 2
a67 9
	rbytes = (sizeof(XRRProviderResources) + rep.nProviders *
		  sizeof(RRProvider));
	xrpr = (XRRProviderResources *) Xmalloc(rbytes);
    } else {
	nbytes = 0;
	nbytesRead = 0;
	rbytes = 0;
	xrpr = NULL;
    }
a118 11
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }

    if (rep.length > INT_MAX >> 2 || rep.length < ProviderInfoExtra >> 2)
    {
	if (rep.length < ProviderInfoExtra >> 2)
	    _XEatDataWords (dpy, rep.length);
	else
	    _XEatDataWords (dpy, rep.length - (ProviderInfoExtra >> 2));
@


1.3
log
@Update to libXrandr 1.4.2
@
text
@d80 1
a80 1
    _XRead32(dpy, xrpr->providers, rep.nProviders << 2);
d155 2
a156 2
    _XRead32(dpy, xpi->crtcs, rep.nCrtcs << 2);
    _XRead32(dpy, xpi->outputs, rep.nOutputs << 2);
d158 1
a158 1
    _XRead32(dpy, xpi->associated_providers, rep.nAssociatedProviders << 2);
@


1.3.10.1
log
@Protocol handling issues in X Window System client libraries
X.Org security advisory: October 4, 2016

Fix a number of issues in the way various X client libraries handle
server responses.

Checked by tj@@
@
text
@a27 1
#include <limits.h>
d62 1
a62 2
    if (rep.length < INT_MAX >> 2) {
	nbytes = (long) rep.length << 2;
d64 1
a64 1
	nbytesRead = (long) (rep.nProviders * 4);
d66 2
a67 9
	rbytes = (sizeof(XRRProviderResources) + rep.nProviders *
		  sizeof(RRProvider));
	xrpr = (XRRProviderResources *) Xmalloc(rbytes);
    } else {
	nbytes = 0;
	nbytesRead = 0;
	rbytes = 0;
	xrpr = NULL;
    }
a118 11
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }

    if (rep.length > INT_MAX >> 2 || rep.length < ProviderInfoExtra >> 2)
    {
	if (rep.length < ProviderInfoExtra >> 2)
	    _XEatDataWords (dpy, rep.length);
	else
	    _XEatDataWords (dpy, rep.length - (ProviderInfoExtra >> 2));
@


1.2
log
@Merge upstream fixes for several X libs vulnerabilities
discovered by Ilja van Sprundel.

CVE-2013-1981 X.org libX11 1.5.99.901 (1.6 RC1) integer overflows
CVE-2013-1982 X.org libXext 1.3.1 integer overflows
CVE-2013-1983 X.org libXfixes 5.0 integer overflows
CVE-2013-1984 X.org libXi 1.7.1 integer overflows
CVE-2013-1985 X.org libXinerama 1.1.2 integer overflows
CVE-2013-1986 X.org libXrandr 1.4.0 integer overflows
CVE-2013-1987 X.org libXrender 0.9.7 integer overflows
CVE-2013-1988 X.org libXRes 1.0.6 integer overflows
CVE-2013-1989 X.org libXv 1.0.7 integer overflows
CVE-2013-1990 X.org libXvMC 1.0.7 integer overflows
CVE-2013-1991 X.org libXxf86dga 1.1.3 integer overflows
CVE-2013-1992 X.org libdmx 1.1.2 integer overflows
CVE-2013-1994 X.org libchromeXvMC & libchromeXvMCPro in openChrome
0.3.2 integer overflows
CVE-2013-1995 X.org libXi 1.7.1 sign extension issues
CVE-2013-1996 X.org libFS 1.0.4 sign extension issues
CVE-2013-1997 X.org libX11 1.5.99.901 (1.6 RC1) buffer overflows
CVE-2013-1998 X.org libXi 1.7.1 buffer overflows
CVE-2013-1999 X.org libXvMC 1.0.7 buffer overflows
CVE-2013-2000 X.org libXxf86dga 1.1.3 buffer overflows
CVE-2013-2001 X.org libXxf86vm 1.1.2 buffer overflows
CVE-2013-2002 X.org libXt 1.1.3 buffer overflows
CVE-2013-2003 X.org libXcursor 1.1.13 integer overflows
CVE-2013-2004 X.org libX11 1.5.99.901 (1.6 RC1) unbounded recursion
CVE-2013-2005 X.org libXt 1.1.3 memory corruption
CVE-2013-2066 X.org libXv 1.0.7 buffer overflows
@
text
@d159 10
a168 1
    _XRead32(dpy, xpi->associated_capability, rep.nAssociatedProviders << 2);
@


1.1
log
@Update to libXrandr 1.4.0
@
text
@d70 1
a70 1
       _XEatData (dpy, (unsigned long) nbytes);
d139 1
a139 1
	_XEatData (dpy, (unsigned long) nbytes);
@

