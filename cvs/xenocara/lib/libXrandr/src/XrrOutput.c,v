head	1.6;
access;
symbols
	OPENBSD_6_0:1.5.0.2
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.4.0.12
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.10
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.8
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.2.0.16
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.14
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.12
	OPENBSD_5_0:1.2.0.10
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.6
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.8
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.6
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_2_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2016.10.04.15.02.31;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	NCLOmmyYBlSjSh3b;

1.5
date	2016.03.06.13.37.21;	author matthieu;	state Exp;
branches
	1.5.2.1;
next	1.4;
commitid	lveYUhu3JlpVTSbB;

1.4
date	2013.05.23.22.42.10;	author matthieu;	state Exp;
branches
	1.4.12.1;
next	1.3;

1.3
date	2013.03.09.16.34.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.02.15.20.43;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.16.39.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.16.39.04;	author matthieu;	state Exp;
branches;
next	;

1.4.12.1
date	2016.10.04.18.55.14;	author matthieu;	state Exp;
branches;
next	;
commitid	PNaHexTGDQbxwlMB;

1.5.2.1
date	2016.10.04.18.54.01;	author matthieu;	state Exp;
branches;
next	;
commitid	b1RDOJn7dNqLwuaq;


desc
@@


1.6
log
@Avoid out of boundary accesses on illegal responses

The responses of the connected X server have to be properly checked
to avoid out of boundary accesses that could otherwise be triggered
by a malicious server.

From Tobias Stoeckmann / X.Org security advisory Oct 4, 2016
@
text
@/*
 * Copyright © 2006 Keith Packard
 * Copyright © 2008 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <limits.h>
#include <stdio.h>
#include <X11/Xlib.h>
/* we need to be able to manipulate the Display structure on events */
#include <X11/Xlibint.h>
#include <X11/extensions/render.h>
#include <X11/extensions/Xrender.h>
#include "Xrandrint.h"

#define OutputInfoExtra	(SIZEOF(xRRGetOutputInfoReply) - 32)

XRROutputInfo *
XRRGetOutputInfo (Display *dpy, XRRScreenResources *resources, RROutput output)
{
    XExtDisplayInfo		*info = XRRFindDisplay(dpy);
    xRRGetOutputInfoReply	rep;
    xRRGetOutputInfoReq		*req;
    int				nbytes, nbytesRead, rbytes;
    XRROutputInfo		*xoi;

    RRCheckExtension (dpy, info, NULL);

    LockDisplay (dpy);
    GetReq (RRGetOutputInfo, req);
    req->reqType = info->codes->major_opcode;
    req->randrReqType = X_RRGetOutputInfo;
    req->output = output;
    req->configTimestamp = resources->configTimestamp;

    if (!_XReply (dpy, (xReply *) &rep, OutputInfoExtra >> 2, xFalse))
    {
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }

    if (rep.length > INT_MAX >> 2 || rep.length < (OutputInfoExtra >> 2))
    {
        if (rep.length > (OutputInfoExtra >> 2))
	    _XEatDataWords (dpy, rep.length - (OutputInfoExtra >> 2));
	else
	    _XEatDataWords (dpy, rep.length);
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }
    nbytes = ((long) (rep.length) << 2) - OutputInfoExtra;

    nbytesRead = (long) (rep.nCrtcs * 4 +
			 rep.nModes * 4 +
			 rep.nClones * 4 +
			 ((rep.nameLength + 3) & ~3));

    /*
     * first we must compute how much space to allocate for
     * randr library's use; we'll allocate the structures in a single
     * allocation, on cleanlyness grounds.
     */

    rbytes = (sizeof (XRROutputInfo) +
	      rep.nCrtcs * sizeof (RRCrtc) +
	      rep.nModes * sizeof (RRMode) +
	      rep.nClones * sizeof (RROutput) +
	      rep.nameLength + 1);	    /* '\0' terminate name */

    xoi = (XRROutputInfo *) Xmalloc(rbytes);
    if (xoi == NULL) {
	_XEatDataWords (dpy, rep.length - (OutputInfoExtra >> 2));
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }

    xoi->timestamp = rep.timestamp;
    xoi->crtc = rep.crtc;
    xoi->mm_width = rep.mmWidth;
    xoi->mm_height = rep.mmHeight;
    xoi->connection = rep.connection;
    xoi->subpixel_order = rep.subpixelOrder;
    xoi->ncrtc = rep.nCrtcs;
    xoi->crtcs = (RRCrtc *) (xoi + 1);
    xoi->nmode = rep.nModes;
    xoi->npreferred = rep.nPreferred;
    xoi->modes = (RRMode *) (xoi->crtcs + rep.nCrtcs);
    xoi->nclone = rep.nClones;
    xoi->clones = (RROutput *) (xoi->modes + rep.nModes);
    xoi->name = (char *) (xoi->clones + rep.nClones);

    _XRead32 (dpy, (long *) xoi->crtcs, rep.nCrtcs << 2);
    _XRead32 (dpy, (long *) xoi->modes, rep.nModes << 2);
    _XRead32 (dpy, (long *) xoi->clones, rep.nClones << 2);

    /*
     * Read name and '\0' terminate
     */
    _XReadPad (dpy, xoi->name, rep.nameLength);
    xoi->name[rep.nameLength] = '\0';
    xoi->nameLen = rep.nameLength;

    /*
     * Skip any extra data
     */
    if (nbytes > nbytesRead)
	_XEatData (dpy, (unsigned long) (nbytes - nbytesRead));

    UnlockDisplay (dpy);
    SyncHandle ();
    return (XRROutputInfo *) xoi;
}

void
XRRFreeOutputInfo (XRROutputInfo *outputInfo)
{
    Xfree (outputInfo);
}

static Bool
_XRRHasOutputPrimary (int major, int minor)
{
    return major > 1 || (major == 1 && minor >= 3);
}

void
XRRSetOutputPrimary(Display *dpy, Window window, RROutput output)
{
    XExtDisplayInfo	    *info = XRRFindDisplay(dpy);
    xRRSetOutputPrimaryReq  *req;
    int			    major_version, minor_version;

    RRSimpleCheckExtension (dpy, info);

    if (!XRRQueryVersion (dpy, &major_version, &minor_version) ||
	!_XRRHasOutputPrimary (major_version, minor_version))
	return;

    LockDisplay(dpy);
    GetReq (RRSetOutputPrimary, req);
    req->reqType       = info->codes->major_opcode;
    req->randrReqType  = X_RRSetOutputPrimary;
    req->window        = window;
    req->output	       = output;

    UnlockDisplay (dpy);
    SyncHandle ();
}

RROutput
XRRGetOutputPrimary(Display *dpy, Window window)
{
    XExtDisplayInfo	    *info = XRRFindDisplay(dpy);
    xRRGetOutputPrimaryReq  *req;
    xRRGetOutputPrimaryReply rep;
    int			    major_version, minor_version;

    RRCheckExtension (dpy, info, 0);

    if (!XRRQueryVersion (dpy, &major_version, &minor_version) ||
	!_XRRHasOutputPrimary (major_version, minor_version))
	return None;

    LockDisplay(dpy);
    GetReq (RRGetOutputPrimary, req);
    req->reqType	= info->codes->major_opcode;
    req->randrReqType	= X_RRGetOutputPrimary;
    req->window		= window;

    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))
	rep.output = None;

    UnlockDisplay(dpy);
    SyncHandle();

    return rep.output;
}
@


1.5
log
@Update to libXrandr 1.5.0
@
text
@d28 1
d64 10
@


1.5.2.1
log
@Protocol handling issues in X Window System client libraries
X.Org security advisory: October 4, 2016

Fix a number of issues in the way various X client libraries handle
server responses.

Checked by tj@@
@
text
@a27 1
#include <limits.h>
a62 10
    if (rep.length > INT_MAX >> 2 || rep.length < (OutputInfoExtra >> 2))
    {
        if (rep.length > (OutputInfoExtra >> 2))
	    _XEatDataWords (dpy, rep.length - (OutputInfoExtra >> 2));
	else
	    _XEatDataWords (dpy, rep.length);
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }
@


1.4
log
@Merge upstream fixes for several X libs vulnerabilities
discovered by Ilja van Sprundel.

CVE-2013-1981 X.org libX11 1.5.99.901 (1.6 RC1) integer overflows
CVE-2013-1982 X.org libXext 1.3.1 integer overflows
CVE-2013-1983 X.org libXfixes 5.0 integer overflows
CVE-2013-1984 X.org libXi 1.7.1 integer overflows
CVE-2013-1985 X.org libXinerama 1.1.2 integer overflows
CVE-2013-1986 X.org libXrandr 1.4.0 integer overflows
CVE-2013-1987 X.org libXrender 0.9.7 integer overflows
CVE-2013-1988 X.org libXRes 1.0.6 integer overflows
CVE-2013-1989 X.org libXv 1.0.7 integer overflows
CVE-2013-1990 X.org libXvMC 1.0.7 integer overflows
CVE-2013-1991 X.org libXxf86dga 1.1.3 integer overflows
CVE-2013-1992 X.org libdmx 1.1.2 integer overflows
CVE-2013-1994 X.org libchromeXvMC & libchromeXvMCPro in openChrome
0.3.2 integer overflows
CVE-2013-1995 X.org libXi 1.7.1 sign extension issues
CVE-2013-1996 X.org libFS 1.0.4 sign extension issues
CVE-2013-1997 X.org libX11 1.5.99.901 (1.6 RC1) buffer overflows
CVE-2013-1998 X.org libXi 1.7.1 buffer overflows
CVE-2013-1999 X.org libXvMC 1.0.7 buffer overflows
CVE-2013-2000 X.org libXxf86dga 1.1.3 buffer overflows
CVE-2013-2001 X.org libXxf86vm 1.1.2 buffer overflows
CVE-2013-2002 X.org libXt 1.1.3 buffer overflows
CVE-2013-2003 X.org libXcursor 1.1.13 integer overflows
CVE-2013-2004 X.org libX11 1.5.99.901 (1.6 RC1) unbounded recursion
CVE-2013-2005 X.org libXt 1.1.3 memory corruption
CVE-2013-2066 X.org libXv 1.0.7 buffer overflows
@
text
@d105 3
a107 3
    _XRead32 (dpy, xoi->crtcs, rep.nCrtcs << 2);
    _XRead32 (dpy, xoi->modes, rep.nModes << 2);
    _XRead32 (dpy, xoi->clones, rep.nClones << 2);
@


1.4.12.1
log
@Protocol handling issues in X Window System client libraries
X.Org security advisory: October 4, 2016

Fix a number of issues in the way various X client libraries handle
server responses.

Checked by tj@@
@
text
@a27 1
#include <limits.h>
a62 10
    if (rep.length > INT_MAX >> 2 || rep.length < (OutputInfoExtra >> 2))
    {
        if (rep.length > (OutputInfoExtra >> 2))
	    _XEatDataWords (dpy, rep.length - (OutputInfoExtra >> 2));
	else
	    _XEatDataWords (dpy, rep.length);
	UnlockDisplay (dpy);
	SyncHandle ();
	return NULL;
    }
@


1.3
log
@Update to libXrandr 1.4.0
@
text
@d84 1
a84 1
	_XEatData (dpy, (unsigned long) nbytes);
@


1.2
log
@update to libXrandr 1.3.0
@
text
@d37 1
a37 1
				
d70 2
a71 2
    /* 
     * first we must compute how much space to allocate for 
d108 1
a108 1
    
d114 2
a115 1
    
d121 1
a121 1
    
d148 1
a148 1
    if (!XRRQueryVersion (dpy, &major_version, &minor_version) || 
d173 1
a173 1
    if (!XRRQueryVersion (dpy, &major_version, &minor_version) || 
d185 1
a185 1
	
@


1.1
log
@Initial revision
@
text
@d3 1
a44 2
    int				i;
    xRRQueryVersionReq		*vreq;
d47 1
a47 1
    RRCheckExtension (dpy, info, 0);
d130 59
@


1.1.1.1
log
@libXrandr 1.2.2
@
text
@@
