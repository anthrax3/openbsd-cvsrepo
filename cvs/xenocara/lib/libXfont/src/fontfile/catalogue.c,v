head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.6
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.10
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_3_1:1.1.1.2
	v1_3_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.09.27.17.42.14;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	i8vICzmreDEZmlS0;

1.6
date	2014.05.18.12.13.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2013.08.18.10.36.25;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.03.04.18.13.47;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.31.17.57.12;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.24.13.29.07;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.08.16.14.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.09.08.16.14.06;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.14.32.15;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to libXfont 1.5.0

Tested together with xserver 1.16.1 by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright © 2007 Red Hat, Inc
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author:
 *   Kristian Høgsberg <krh@@redhat.com>
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef HAVE_READLINK
#include <X11/fonts/fntfilst.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>

static const char CataloguePrefix[] = "catalogue:";

static int CatalogueFreeFPE (FontPathElementPtr fpe);

static int
CatalogueNameCheck (const char *name)
{
    return strncmp(name, CataloguePrefix, sizeof(CataloguePrefix) - 1) == 0;
}

typedef struct _CatalogueRec {
    time_t mtime;
    int fpeCount, fpeAlloc;
    FontPathElementPtr *fpeList;
} CatalogueRec, *CataloguePtr;

static int
CatalogueAddFPE (CataloguePtr cat, FontPathElementPtr fpe)
{
    FontPathElementPtr *new;

    if (cat->fpeCount >= cat->fpeAlloc)
    {
	if (cat->fpeAlloc == 0)
	    cat->fpeAlloc = 16;
	else
	    cat->fpeAlloc *= 2;

	new = realloc(cat->fpeList, cat->fpeAlloc * sizeof(FontPathElementPtr));
	if (new == NULL)
	    return AllocError;

	cat->fpeList = new;
    }

    cat->fpeList[cat->fpeCount++] = fpe;

    return Successful;
}

static const char PriorityAttribute[] = "pri=";

static int
ComparePriority(const void *p1, const void *p2)
{
    FontDirectoryPtr dir1 = (*(FontPathElementPtr*) p1)->private;
    FontDirectoryPtr dir2 = (*(FontPathElementPtr*) p2)->private;
    const char *pri1 = NULL;
    const char *pri2 = NULL;

    if (dir1->attributes != NULL)
	pri1 = strstr(dir1->attributes, PriorityAttribute);
    if (dir2->attributes != NULL)
	pri2 = strstr(dir2->attributes, PriorityAttribute);

    if (pri1 == NULL && pri2 == NULL)
	return 0;
    else if (pri1 == NULL)
	return 1;
    else if (pri2 == NULL)
	return -1;
    else
	return
	    atoi(pri1 + strlen(PriorityAttribute)) -
	    atoi(pri2 + strlen(PriorityAttribute));
}

static void
CatalogueUnrefFPEs (FontPathElementPtr fpe)
{
    CataloguePtr	cat = fpe->private;
    FontPathElementPtr	subfpe;
    int			i;

    for (i = 0; i < cat->fpeCount; i++)
    {
	subfpe = cat->fpeList[i];
	subfpe->refcount--;
	if (subfpe->refcount == 0)
	{
	    FontFileFreeFPE (subfpe);
	    free((void *) subfpe->name);
	    free(subfpe);
	}
    }

    cat->fpeCount = 0;
}

/* Rescan catalogue directory if modified timestamp has changed or
 * the forceScan argument says to do it anyway (like on first load). */
static int
CatalogueRescan (FontPathElementPtr fpe, Bool forceScan)
{
    CataloguePtr	cat = fpe->private;
    char		link[MAXFONTFILENAMELEN];
    char		dest[MAXFONTFILENAMELEN];
    char		*attrib;
    FontPathElementPtr	subfpe;
    struct stat		statbuf;
    const char		*path;
    DIR			*dir;
    struct dirent	*entry;
    int			len;
    int			pathlen;

    path = fpe->name + strlen(CataloguePrefix);
    if (stat(path, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))
	return BadFontPath;

    if ((forceScan == FALSE) && (statbuf.st_mtime <= cat->mtime))
	return Successful;

    dir = opendir(path);
    if (dir == NULL)
    {
	free(cat);
	return BadFontPath;
    }

    CatalogueUnrefFPEs (fpe);
    while (entry = readdir(dir), entry != NULL)
    {
        char *name;
	snprintf(link, sizeof link, "%s/%s", path, entry->d_name);
	len = readlink(link, dest, sizeof dest - 1);
	if (len < 0)
	    continue;

	dest[len] = '\0';

	if (dest[0] != '/')
	{
	   pathlen = strlen(path);
	   memmove(dest + pathlen + 1, dest, sizeof dest - pathlen - 1);
	   memcpy(dest, path, pathlen);
	   memcpy(dest + pathlen, "/", 1);
	   len += pathlen + 1;
	}

	attrib = strchr(link, ':');
	if (attrib && len + strlen(attrib) < sizeof dest)
	{
	    memcpy(dest + len, attrib, strlen(attrib));
	    len += strlen(attrib);
	}

	subfpe = malloc(sizeof *subfpe);
	if (subfpe == NULL)
	    continue;

	/* The fonts returned by OpenFont will point back to the
	 * subfpe they come from.  So set the type of the subfpe to
	 * what the catalogue fpe was assigned, so calls to CloseFont
	 * (which uses font->fpe->type) goes to CatalogueCloseFont. */
	subfpe->type = fpe->type;
	subfpe->name_length = len;
	name = malloc (len + 1);
	if (name == NULL)
	{
	    free(subfpe);
	    continue;
	}

	memcpy(name, dest, len);
	name[len] = '\0';
        subfpe->name = name;

	/* The X server will manipulate the subfpe ref counts
	 * associated with the font in OpenFont and CloseFont, so we
	 * have to make sure it's valid. */
	subfpe->refcount = 1;

	if (FontFileInitFPE (subfpe) != Successful)
	{
	    free((void *) subfpe->name);
	    free(subfpe);
	    continue;
	}

	if (CatalogueAddFPE(cat, subfpe) != Successful)
	{
	    FontFileFreeFPE (subfpe);
	    free(subfpe);
	    continue;
	}
    }

    closedir(dir);

    qsort(cat->fpeList,
	  cat->fpeCount, sizeof cat->fpeList[0], ComparePriority);

    cat->mtime = statbuf.st_mtime;

    return Successful;
}

static int
CatalogueInitFPE (FontPathElementPtr fpe)
{
    CataloguePtr	cat;

    cat = malloc(sizeof *cat);
    if (cat == NULL)
	return AllocError;

    fpe->private = (pointer) cat;
    cat->fpeCount = 0;
    cat->fpeAlloc = 0;
    cat->fpeList = NULL;
    cat->mtime = 0;

    return CatalogueRescan (fpe, TRUE);
}

static int
CatalogueResetFPE (FontPathElementPtr fpe)
{
    /* Always just tell the caller to close and re-open */
    return FPEResetFailed;
}

static int
CatalogueFreeFPE (FontPathElementPtr fpe)
{
    CataloguePtr	cat = fpe->private;

    /* If the catalogue is modified while the xserver has fonts open
     * from the previous subfpes, we'll unref the old subfpes when we
     * reload the catalogue, and the xserver will the call FreeFPE on
     * them once it drops its last reference. Thus, the FreeFPE call
     * for the subfpe ends up here and we just forward it to
     * FontFileFreeFPE. */

    if (!CatalogueNameCheck (fpe->name))
	return FontFileFreeFPE (fpe);

    CatalogueUnrefFPEs (fpe);
    free(cat->fpeList);
    free(cat);

    return Successful;
}

static int
CatalogueOpenFont (pointer client, FontPathElementPtr fpe, Mask flags,
		   const char *name, int namelen,
		   fsBitmapFormat format, fsBitmapFormatMask fmask,
		   XID id, FontPtr *pFont, char **aliasName,
		   FontPtr non_cachable_font)
{
    CataloguePtr cat = fpe->private;
    FontPathElementPtr subfpe;
    int i, status;

    CatalogueRescan (fpe, FALSE);

    for (i = 0; i < cat->fpeCount; i++)
    {
	subfpe = cat->fpeList[i];
	status = FontFileOpenFont(client, subfpe, flags,
				  name, namelen, format, fmask, id,
				  pFont, aliasName, non_cachable_font);
	if (status == Successful || status == FontNameAlias)
	    return status;
    }

    return BadFontName;
}

static void
CatalogueCloseFont (FontPathElementPtr fpe, FontPtr pFont)
{
    /* Note: this gets called with the actual subfpe where we found
     * the font, not the catalogue fpe. */

    FontFileCloseFont(fpe, pFont);
}

static int
CatalogueListFonts (pointer client, FontPathElementPtr fpe, const char *pat,
		    int len, int max, FontNamesPtr names)
{
    CataloguePtr cat = fpe->private;
    FontPathElementPtr subfpe;
    int i;

    CatalogueRescan (fpe, FALSE);

    for (i = 0; i < cat->fpeCount; i++)
    {
	subfpe = cat->fpeList[i];
	FontFileListFonts(client, subfpe, pat, len, max, names);
    }

    return Successful;
}

typedef struct _LFWIData {
    pointer		*privates;
    int			current;
} LFWIDataRec, *LFWIDataPtr;

static int
CatalogueStartListFonts(pointer client, FontPathElementPtr fpe,
			const char *pat, int len, int max, pointer *privatep,
			int mark_aliases)
{
    CataloguePtr	cat = fpe->private;
    LFWIDataPtr		data;
    int			ret, i, j;

    CatalogueRescan (fpe, FALSE);

    data = malloc (sizeof *data + sizeof data->privates[0] * cat->fpeCount);
    if (!data)
	return AllocError;
    data->privates = (pointer *) (data + 1);

    for (i = 0; i < cat->fpeCount; i++)
    {
	ret = FontFileStartListFonts(client, cat->fpeList[i], pat, len,
				     max, &data->privates[i], mark_aliases);
	if (ret != Successful)
	    goto bail;
    }

    data->current = 0;
    *privatep = (pointer) data;
    return Successful;

 bail:
    for (j = 0; j < i; j++)
	/* FIXME: we have no way to free the per-fpe privates. */;
    free (data);

    return AllocError;
}

static int
CatalogueStartListFontsWithInfo(pointer client, FontPathElementPtr fpe,
				const char *pat, int len, int max,
				pointer *privatep)
{
    return CatalogueStartListFonts(client, fpe, pat, len, max, privatep, 0);
}

static int
CatalogueListNextFontWithInfo(pointer client, FontPathElementPtr fpe,
			      char **namep, int *namelenp,
			      FontInfoPtr *pFontInfo,
			      int *numFonts, pointer private)
{
    LFWIDataPtr		data = private;
    CataloguePtr	cat = fpe->private;
    int			ret;

    if (data->current == cat->fpeCount)
    {
	free(data);
	return BadFontName;
    }

    ret = FontFileListNextFontWithInfo(client, cat->fpeList[data->current],
				       namep, namelenp,
				       pFontInfo, numFonts,
				       data->privates[data->current]);
    if (ret == BadFontName)
    {
	data->current++;
	return CatalogueListNextFontWithInfo(client, fpe, namep, namelenp,
					     pFontInfo, numFonts, private);
    }

    return ret;
}

static int
CatalogueStartListFontsAndAliases(pointer client, FontPathElementPtr fpe,
				  const char *pat, int len, int max,
				  pointer *privatep)
{
    return CatalogueStartListFonts(client, fpe, pat, len, max, privatep, 1);
}

static int
CatalogueListNextFontOrAlias(pointer client, FontPathElementPtr fpe,
			     char **namep, int *namelenp, char **resolvedp,
			     int *resolvedlenp, pointer private)
{
    LFWIDataPtr		data = private;
    CataloguePtr	cat = fpe->private;
    int			ret;

    if (data->current == cat->fpeCount)
    {
	free(data);
	return BadFontName;
    }

    ret = FontFileListNextFontOrAlias(client, cat->fpeList[data->current],
				      namep, namelenp,
				      resolvedp, resolvedlenp,
				      data->privates[data->current]);
    if (ret == BadFontName)
    {
	data->current++;
	return CatalogueListNextFontOrAlias(client, fpe, namep, namelenp,
					    resolvedp, resolvedlenp, private);
    }

    return ret;
}

void
CatalogueRegisterLocalFpeFunctions (void)
{
    RegisterFPEFunctions(CatalogueNameCheck,
			 CatalogueInitFPE,
			 CatalogueFreeFPE,
			 CatalogueResetFPE,
			 CatalogueOpenFont,
			 CatalogueCloseFont,
			 CatalogueListFonts,
			 CatalogueStartListFontsWithInfo,
			 CatalogueListNextFontWithInfo,
			 NULL,
			 NULL,
			 NULL,
			 CatalogueStartListFontsAndAliases,
			 CatalogueListNextFontOrAlias,
			 FontFileEmptyBitmapSource);
}

#endif /* HAVE_READLINK */
@


1.6
log
@Update to libXfont 1.4.8
@
text
@d43 1
a43 1
CatalogueNameCheck (char *name)
d119 1
a119 1
	    free(subfpe->name);
d161 1
d195 2
a196 2
	subfpe->name = malloc (len + 1);
	if (subfpe->name == NULL)
d202 3
a204 2
	memcpy(subfpe->name, dest, len);
	subfpe->name[len] = '\0';
d213 1
a213 1
	    free(subfpe->name);
d285 1
a285 1
		   char *name, int namelen,
d319 1
a319 1
CatalogueListFonts (pointer client, FontPathElementPtr fpe, char *pat,
d344 1
a344 1
			char *pat, int len, int max, pointer *privatep,
d380 1
a380 1
				char *pat, int len, int max,
d418 1
a418 1
				  char *pat, int len, int max,
@


1.5
log
@Update to libXfont 1.4.6.
@
text
@a289 1
    FontDirectoryPtr dir;
a296 1
	dir = subfpe->private;
a321 1
    FontDirectoryPtr dir;
a328 1
	dir = subfpe->private;
a333 5

int
FontFileStartListFonts(pointer client, FontPathElementPtr fpe,
		       char *pat, int len, int max,
		       pointer *privatep, int mark_aliases);
@


1.4
log
@Update to libXfont 1.4.5
@
text
@d30 2
d195 1
a195 1
	if (subfpe == NULL)
d479 2
@


1.3
log
@Update to libXfont 1.4.1
@
text
@d63 1
a63 1
	
d254 1
a254 1
    return FPEResetFailed;	
d280 2
a281 2
CatalogueOpenFont (pointer client, FontPathElementPtr fpe, Mask flags, 
		   char *name, int namelen, 
d283 1
a283 1
		   XID id, FontPtr *pFont, char **aliasName, 
d303 1
a303 1
	    
d317 1
a317 1
CatalogueListFonts (pointer client, FontPathElementPtr fpe, char *pat, 
d338 2
a339 2
FontFileStartListFonts(pointer client, FontPathElementPtr fpe, 
		       char *pat, int len, int max, 
d348 1
a348 1
CatalogueStartListFonts(pointer client, FontPathElementPtr fpe, 
d384 2
a385 2
CatalogueStartListFontsWithInfo(pointer client, FontPathElementPtr fpe, 
				char *pat, int len, int max, 
d392 2
a393 2
CatalogueListNextFontWithInfo(pointer client, FontPathElementPtr fpe, 
			      char **namep, int *namelenp, 
d422 2
a423 2
CatalogueStartListFontsAndAliases(pointer client, FontPathElementPtr fpe, 
				  char *pat, int len, int max, 
d430 1
a430 1
CatalogueListNextFontOrAlias(pointer client, FontPathElementPtr fpe, 
@


1.2
log
@merge libXfont 1.3.2. bump major since some symbols were removed.
@
text
@d64 1
a64 2
	new = xrealloc(cat->fpeList,
		       cat->fpeAlloc * sizeof(FontPathElementPtr));
d117 2
a118 2
	    xfree(subfpe->name);
	    xfree(subfpe);
d125 2
d128 1
a128 1
CatalogueRescan (FontPathElementPtr fpe)
d146 1
a146 1
    if (statbuf.st_mtime <= cat->mtime)
d152 1
a152 1
	xfree(cat);
d182 1
a182 1
	subfpe = xalloc(sizeof *subfpe);
d192 1
a192 1
	subfpe->name = xalloc (len + 1);
d195 1
a195 1
	    xfree(subfpe);
d209 2
a210 2
	    xfree(subfpe->name);
	    xfree(subfpe);
d217 1
a217 1
	    xfree(subfpe);
d237 1
a237 1
    cat = (CataloguePtr) xalloc(sizeof *cat);
d247 1
a247 1
    return CatalogueRescan (fpe);
d273 2
a274 2
    xfree(cat->fpeList);
    xfree(cat);
d291 1
a291 1
    CatalogueRescan (fpe);
d325 1
a325 1
    CatalogueRescan (fpe);
d356 1
a356 1
    CatalogueRescan (fpe);
d358 1
a358 2
    data = (LFWIDataPtr) xalloc (sizeof *data +
				 sizeof data->privates[0] * cat->fpeCount);
d378 1
a378 1
    xfree (data);
d403 1
a403 1
	xfree(data);
d440 1
a440 1
	xfree(data);
@


1.1
log
@Initial revision
@
text
@d139 1
d159 1
a159 1
	len = readlink(link, dest, sizeof dest);
d163 11
d220 2
@


1.1.1.1
log
@import libXfont 1.3.0
@
text
@@


1.1.1.2
log
@libXfont 1.3.1
@
text
@a138 1
    int			pathlen;
a161 11
	dest[len] = '\0';

	if (dest[0] != '/')
	{
	   pathlen = strlen(path);
	   memmove(dest + pathlen + 1, dest, sizeof dest - pathlen - 1);
	   memcpy(dest, path, pathlen);
	   memcpy(dest + pathlen, "/", 1);
	   len += pathlen + 1;
	}

a207 2

    closedir(dir);
@

