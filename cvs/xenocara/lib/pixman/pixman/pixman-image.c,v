head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.16
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.14
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.12
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.10
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.8
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.6
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.2
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v0_9_6:1.1.1.2
	xorg:1.1.1
	v0_9_5:1.1.1.1
	pixman:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2013.12.01.20.34.20;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.07.17.18.01;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.02.28.20.36.12;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.22.08.32.55;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.14.13.42.49;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.05.20.14.28;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.23.19.11.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.08.19.00.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.03.20.48.59;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.10.03.20.48.59;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.12.10.21.10.27;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to pixman 0.32.4. Tested by naddy@@ and ajacoutot@@
@
text
@/*
 * Copyright © 2000 SuSE, Inc.
 * Copyright © 2007 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "pixman-private.h"

static const pixman_color_t transparent_black = { 0, 0, 0, 0 };

static void
gradient_property_changed (pixman_image_t *image)
{
    gradient_t *gradient = &image->gradient;
    int n = gradient->n_stops;
    pixman_gradient_stop_t *stops = gradient->stops;
    pixman_gradient_stop_t *begin = &(gradient->stops[-1]);
    pixman_gradient_stop_t *end = &(gradient->stops[n]);

    switch (gradient->common.repeat)
    {
    default:
    case PIXMAN_REPEAT_NONE:
	begin->x = INT32_MIN;
	begin->color = transparent_black;
	end->x = INT32_MAX;
	end->color = transparent_black;
	break;

    case PIXMAN_REPEAT_NORMAL:
	begin->x = stops[n - 1].x - pixman_fixed_1;
	begin->color = stops[n - 1].color;
	end->x = stops[0].x + pixman_fixed_1;
	end->color = stops[0].color;
	break;

    case PIXMAN_REPEAT_REFLECT:
	begin->x = - stops[0].x;
	begin->color = stops[0].color;
	end->x = pixman_int_to_fixed (2) - stops[n - 1].x;
	end->color = stops[n - 1].color;
	break;

    case PIXMAN_REPEAT_PAD:
	begin->x = INT32_MIN;
	begin->color = stops[0].color;
	end->x = INT32_MAX;
	end->color = stops[n - 1].color;
	break;
    }
}

pixman_bool_t
_pixman_init_gradient (gradient_t *                  gradient,
                       const pixman_gradient_stop_t *stops,
                       int                           n_stops)
{
    return_val_if_fail (n_stops > 0, FALSE);

    /* We allocate two extra stops, one before the beginning of the stop list,
     * and one after the end. These stops are initialized to whatever color
     * would be used for positions outside the range of the stop list.
     *
     * This saves a bit of computation in the gradient walker.
     *
     * The pointer we store in the gradient_t struct still points to the
     * first user-supplied struct, so when freeing, we will have to
     * subtract one.
     */
    gradient->stops =
	pixman_malloc_ab (n_stops + 2, sizeof (pixman_gradient_stop_t));
    if (!gradient->stops)
	return FALSE;

    gradient->stops += 1;
    memcpy (gradient->stops, stops, n_stops * sizeof (pixman_gradient_stop_t));
    gradient->n_stops = n_stops;

    gradient->common.property_changed = gradient_property_changed;

    return TRUE;
}

void
_pixman_image_init (pixman_image_t *image)
{
    image_common_t *common = &image->common;

    pixman_region32_init (&common->clip_region);

    common->alpha_count = 0;
    common->have_clip_region = FALSE;
    common->clip_sources = FALSE;
    common->transform = NULL;
    common->repeat = PIXMAN_REPEAT_NONE;
    common->filter = PIXMAN_FILTER_NEAREST;
    common->filter_params = NULL;
    common->n_filter_params = 0;
    common->alpha_map = NULL;
    common->component_alpha = FALSE;
    common->ref_count = 1;
    common->property_changed = NULL;
    common->client_clip = FALSE;
    common->destroy_func = NULL;
    common->destroy_data = NULL;
    common->dirty = TRUE;
}

pixman_bool_t
_pixman_image_fini (pixman_image_t *image)
{
    image_common_t *common = (image_common_t *)image;

    common->ref_count--;

    if (common->ref_count == 0)
    {
	if (image->common.destroy_func)
	    image->common.destroy_func (image, image->common.destroy_data);

	pixman_region32_fini (&common->clip_region);

	free (common->transform);
	free (common->filter_params);

	if (common->alpha_map)
	    pixman_image_unref ((pixman_image_t *)common->alpha_map);

	if (image->type == LINEAR ||
	    image->type == RADIAL ||
	    image->type == CONICAL)
	{
	    if (image->gradient.stops)
	    {
		/* See _pixman_init_gradient() for an explanation of the - 1 */
		free (image->gradient.stops - 1);
	    }

	    /* This will trigger if someone adds a property_changed
	     * method to the linear/radial/conical gradient overwriting
	     * the general one.
	     */
	    assert (
		image->common.property_changed == gradient_property_changed);
	}

	if (image->type == BITS && image->bits.free_me)
	    free (image->bits.free_me);

	return TRUE;
    }

    return FALSE;
}

pixman_image_t *
_pixman_image_allocate (void)
{
    pixman_image_t *image = malloc (sizeof (pixman_image_t));

    if (image)
	_pixman_image_init (image);

    return image;
}

static void
image_property_changed (pixman_image_t *image)
{
    image->common.dirty = TRUE;
}

/* Ref Counting */
PIXMAN_EXPORT pixman_image_t *
pixman_image_ref (pixman_image_t *image)
{
    image->common.ref_count++;

    return image;
}

/* returns TRUE when the image is freed */
PIXMAN_EXPORT pixman_bool_t
pixman_image_unref (pixman_image_t *image)
{
    if (_pixman_image_fini (image))
    {
	free (image);
	return TRUE;
    }

    return FALSE;
}

PIXMAN_EXPORT void
pixman_image_set_destroy_function (pixman_image_t *            image,
                                   pixman_image_destroy_func_t func,
                                   void *                      data)
{
    image->common.destroy_func = func;
    image->common.destroy_data = data;
}

PIXMAN_EXPORT void *
pixman_image_get_destroy_data (pixman_image_t *image)
{
  return image->common.destroy_data;
}

void
_pixman_image_reset_clip_region (pixman_image_t *image)
{
    image->common.have_clip_region = FALSE;
}

/* Executive Summary: This function is a no-op that only exists
 * for historical reasons.
 *
 * There used to be a bug in the X server where it would rely on
 * out-of-bounds accesses when it was asked to composite with a
 * window as the source. It would create a pixman image pointing
 * to some bogus position in memory, but then set a clip region
 * to the position where the actual bits were.
 *
 * Due to a bug in old versions of pixman, where it would not clip
 * against the image bounds when a clip region was set, this would
 * actually work. So when the pixman bug was fixed, a workaround was
 * added to allow certain out-of-bound accesses. This function disabled
 * those workarounds.
 *
 * Since 0.21.2, pixman doesn't do these workarounds anymore, so now
 * this function is a no-op.
 */
PIXMAN_EXPORT void
pixman_disable_out_of_bounds_workaround (void)
{
}

static void
compute_image_info (pixman_image_t *image)
{
    pixman_format_code_t code;
    uint32_t flags = 0;

    /* Transform */
    if (!image->common.transform)
    {
	flags |= (FAST_PATH_ID_TRANSFORM	|
		  FAST_PATH_X_UNIT_POSITIVE	|
		  FAST_PATH_Y_UNIT_ZERO		|
		  FAST_PATH_AFFINE_TRANSFORM);
    }
    else
    {
	flags |= FAST_PATH_HAS_TRANSFORM;

	if (image->common.transform->matrix[2][0] == 0			&&
	    image->common.transform->matrix[2][1] == 0			&&
	    image->common.transform->matrix[2][2] == pixman_fixed_1)
	{
	    flags |= FAST_PATH_AFFINE_TRANSFORM;

	    if (image->common.transform->matrix[0][1] == 0 &&
		image->common.transform->matrix[1][0] == 0)
	    {
		if (image->common.transform->matrix[0][0] == -pixman_fixed_1 &&
		    image->common.transform->matrix[1][1] == -pixman_fixed_1)
		{
		    flags |= FAST_PATH_ROTATE_180_TRANSFORM;
		}
		flags |= FAST_PATH_SCALE_TRANSFORM;
	    }
	    else if (image->common.transform->matrix[0][0] == 0 &&
	             image->common.transform->matrix[1][1] == 0)
	    {
		pixman_fixed_t m01 = image->common.transform->matrix[0][1];
		pixman_fixed_t m10 = image->common.transform->matrix[1][0];

		if (m01 == -pixman_fixed_1 && m10 == pixman_fixed_1)
		    flags |= FAST_PATH_ROTATE_90_TRANSFORM;
		else if (m01 == pixman_fixed_1 && m10 == -pixman_fixed_1)
		    flags |= FAST_PATH_ROTATE_270_TRANSFORM;
	    }
	}

	if (image->common.transform->matrix[0][0] > 0)
	    flags |= FAST_PATH_X_UNIT_POSITIVE;

	if (image->common.transform->matrix[1][0] == 0)
	    flags |= FAST_PATH_Y_UNIT_ZERO;
    }

    /* Filter */
    switch (image->common.filter)
    {
    case PIXMAN_FILTER_NEAREST:
    case PIXMAN_FILTER_FAST:
	flags |= (FAST_PATH_NEAREST_FILTER | FAST_PATH_NO_CONVOLUTION_FILTER);
	break;

    case PIXMAN_FILTER_BILINEAR:
    case PIXMAN_FILTER_GOOD:
    case PIXMAN_FILTER_BEST:
	flags |= (FAST_PATH_BILINEAR_FILTER | FAST_PATH_NO_CONVOLUTION_FILTER);

	/* Here we have a chance to optimize BILINEAR filter to NEAREST if
	 * they are equivalent for the currently used transformation matrix.
	 */
	if (flags & FAST_PATH_ID_TRANSFORM)
	{
	    flags |= FAST_PATH_NEAREST_FILTER;
	}
	else if (
	    /* affine and integer translation components in matrix ... */
	    ((flags & FAST_PATH_AFFINE_TRANSFORM) &&
	     !pixman_fixed_frac (image->common.transform->matrix[0][2] |
				 image->common.transform->matrix[1][2])) &&
	    (
		/* ... combined with a simple rotation */
		(flags & (FAST_PATH_ROTATE_90_TRANSFORM |
			  FAST_PATH_ROTATE_180_TRANSFORM |
			  FAST_PATH_ROTATE_270_TRANSFORM)) ||
		/* ... or combined with a simple non-rotated translation */
		(image->common.transform->matrix[0][0] == pixman_fixed_1 &&
		 image->common.transform->matrix[1][1] == pixman_fixed_1 &&
		 image->common.transform->matrix[0][1] == 0 &&
		 image->common.transform->matrix[1][0] == 0)
		)
	    )
	{
	    /* FIXME: there are some affine-test failures, showing that
	     * handling of BILINEAR and NEAREST filter is not quite
	     * equivalent when getting close to 32K for the translation
	     * components of the matrix. That's likely some bug, but for
	     * now just skip BILINEAR->NEAREST optimization in this case.
	     */
	    pixman_fixed_t magic_limit = pixman_int_to_fixed (30000);
	    if (image->common.transform->matrix[0][2] <= magic_limit  &&
	        image->common.transform->matrix[1][2] <= magic_limit  &&
	        image->common.transform->matrix[0][2] >= -magic_limit &&
	        image->common.transform->matrix[1][2] >= -magic_limit)
	    {
		flags |= FAST_PATH_NEAREST_FILTER;
	    }
	}
	break;

    case PIXMAN_FILTER_CONVOLUTION:
	break;

    case PIXMAN_FILTER_SEPARABLE_CONVOLUTION:
	flags |= FAST_PATH_SEPARABLE_CONVOLUTION_FILTER;
	break;

    default:
	flags |= FAST_PATH_NO_CONVOLUTION_FILTER;
	break;
    }

    /* Repeat mode */
    switch (image->common.repeat)
    {
    case PIXMAN_REPEAT_NONE:
	flags |=
	    FAST_PATH_NO_REFLECT_REPEAT		|
	    FAST_PATH_NO_PAD_REPEAT		|
	    FAST_PATH_NO_NORMAL_REPEAT;
	break;

    case PIXMAN_REPEAT_REFLECT:
	flags |=
	    FAST_PATH_NO_PAD_REPEAT		|
	    FAST_PATH_NO_NONE_REPEAT		|
	    FAST_PATH_NO_NORMAL_REPEAT;
	break;

    case PIXMAN_REPEAT_PAD:
	flags |=
	    FAST_PATH_NO_REFLECT_REPEAT		|
	    FAST_PATH_NO_NONE_REPEAT		|
	    FAST_PATH_NO_NORMAL_REPEAT;
	break;

    default:
	flags |=
	    FAST_PATH_NO_REFLECT_REPEAT		|
	    FAST_PATH_NO_PAD_REPEAT		|
	    FAST_PATH_NO_NONE_REPEAT;
	break;
    }

    /* Component alpha */
    if (image->common.component_alpha)
	flags |= FAST_PATH_COMPONENT_ALPHA;
    else
	flags |= FAST_PATH_UNIFIED_ALPHA;

    flags |= (FAST_PATH_NO_ACCESSORS | FAST_PATH_NARROW_FORMAT);

    /* Type specific checks */
    switch (image->type)
    {
    case SOLID:
	code = PIXMAN_solid;

	if (image->solid.color.alpha == 0xffff)
	    flags |= FAST_PATH_IS_OPAQUE;
	break;

    case BITS:
	if (image->bits.width == 1	&&
	    image->bits.height == 1	&&
	    image->common.repeat != PIXMAN_REPEAT_NONE)
	{
	    code = PIXMAN_solid;
	}
	else
	{
	    code = image->bits.format;
	    flags |= FAST_PATH_BITS_IMAGE;
	}

	if (!PIXMAN_FORMAT_A (image->bits.format)				&&
	    PIXMAN_FORMAT_TYPE (image->bits.format) != PIXMAN_TYPE_GRAY		&&
	    PIXMAN_FORMAT_TYPE (image->bits.format) != PIXMAN_TYPE_COLOR)
	{
	    flags |= FAST_PATH_SAMPLES_OPAQUE;

	    if (image->common.repeat != PIXMAN_REPEAT_NONE)
		flags |= FAST_PATH_IS_OPAQUE;
	}

	if (image->bits.read_func || image->bits.write_func)
	    flags &= ~FAST_PATH_NO_ACCESSORS;

	if (PIXMAN_FORMAT_IS_WIDE (image->bits.format))
	    flags &= ~FAST_PATH_NARROW_FORMAT;
	break;

    case RADIAL:
	code = PIXMAN_unknown;

	/*
	 * As explained in pixman-radial-gradient.c, every point of
	 * the plane has a valid associated radius (and thus will be
	 * colored) if and only if a is negative (i.e. one of the two
	 * circles contains the other one).
	 */

        if (image->radial.a >= 0)
	    break;

	/* Fall through */

    case CONICAL:
    case LINEAR:
	code = PIXMAN_unknown;

	if (image->common.repeat != PIXMAN_REPEAT_NONE)
	{
	    int i;

	    flags |= FAST_PATH_IS_OPAQUE;
	    for (i = 0; i < image->gradient.n_stops; ++i)
	    {
		if (image->gradient.stops[i].color.alpha != 0xffff)
		{
		    flags &= ~FAST_PATH_IS_OPAQUE;
		    break;
		}
	    }
	}
	break;

    default:
	code = PIXMAN_unknown;
	break;
    }

    /* Alpha maps are only supported for BITS images, so it's always
     * safe to ignore their presense for non-BITS images
     */
    if (!image->common.alpha_map || image->type != BITS)
    {
	flags |= FAST_PATH_NO_ALPHA_MAP;
    }
    else
    {
	if (PIXMAN_FORMAT_IS_WIDE (image->common.alpha_map->format))
	    flags &= ~FAST_PATH_NARROW_FORMAT;
    }

    /* Both alpha maps and convolution filters can introduce
     * non-opaqueness in otherwise opaque images. Also
     * an image with component alpha turned on is only opaque
     * if all channels are opaque, so we simply turn it off
     * unconditionally for those images.
     */
    if (image->common.alpha_map						||
	image->common.filter == PIXMAN_FILTER_CONVOLUTION		||
        image->common.filter == PIXMAN_FILTER_SEPARABLE_CONVOLUTION     ||
	image->common.component_alpha)
    {
	flags &= ~(FAST_PATH_IS_OPAQUE | FAST_PATH_SAMPLES_OPAQUE);
    }

    image->common.flags = flags;
    image->common.extended_format_code = code;
}

void
_pixman_image_validate (pixman_image_t *image)
{
    if (image->common.dirty)
    {
	compute_image_info (image);

	/* It is important that property_changed is
	 * called *after* compute_image_info() because
	 * property_changed() can make use of the flags
	 * to set up accessors etc.
	 */
	if (image->common.property_changed)
	    image->common.property_changed (image);

	image->common.dirty = FALSE;
    }

    if (image->common.alpha_map)
	_pixman_image_validate ((pixman_image_t *)image->common.alpha_map);
}

PIXMAN_EXPORT pixman_bool_t
pixman_image_set_clip_region32 (pixman_image_t *   image,
                                pixman_region32_t *region)
{
    image_common_t *common = (image_common_t *)image;
    pixman_bool_t result;

    if (region)
    {
	if ((result = pixman_region32_copy (&common->clip_region, region)))
	    image->common.have_clip_region = TRUE;
    }
    else
    {
	_pixman_image_reset_clip_region (image);

	result = TRUE;
    }

    image_property_changed (image);

    return result;
}

PIXMAN_EXPORT pixman_bool_t
pixman_image_set_clip_region (pixman_image_t *   image,
                              pixman_region16_t *region)
{
    image_common_t *common = (image_common_t *)image;
    pixman_bool_t result;

    if (region)
    {
	if ((result = pixman_region32_copy_from_region16 (&common->clip_region, region)))
	    image->common.have_clip_region = TRUE;
    }
    else
    {
	_pixman_image_reset_clip_region (image);

	result = TRUE;
    }

    image_property_changed (image);

    return result;
}

PIXMAN_EXPORT void
pixman_image_set_has_client_clip (pixman_image_t *image,
                                  pixman_bool_t   client_clip)
{
    image->common.client_clip = client_clip;
}

PIXMAN_EXPORT pixman_bool_t
pixman_image_set_transform (pixman_image_t *          image,
                            const pixman_transform_t *transform)
{
    static const pixman_transform_t id =
    {
	{ { pixman_fixed_1, 0, 0 },
	  { 0, pixman_fixed_1, 0 },
	  { 0, 0, pixman_fixed_1 } }
    };

    image_common_t *common = (image_common_t *)image;
    pixman_bool_t result;

    if (common->transform == transform)
	return TRUE;

    if (!transform || memcmp (&id, transform, sizeof (pixman_transform_t)) == 0)
    {
	free (common->transform);
	common->transform = NULL;
	result = TRUE;

	goto out;
    }

    if (common->transform &&
	memcmp (common->transform, transform, sizeof (pixman_transform_t)) == 0)
    {
	return TRUE;
    }

    if (common->transform == NULL)
	common->transform = malloc (sizeof (pixman_transform_t));

    if (common->transform == NULL)
    {
	result = FALSE;

	goto out;
    }

    memcpy (common->transform, transform, sizeof(pixman_transform_t));

    result = TRUE;

out:
    image_property_changed (image);

    return result;
}

PIXMAN_EXPORT void
pixman_image_set_repeat (pixman_image_t *image,
                         pixman_repeat_t repeat)
{
    if (image->common.repeat == repeat)
	return;

    image->common.repeat = repeat;

    image_property_changed (image);
}

PIXMAN_EXPORT pixman_bool_t
pixman_image_set_filter (pixman_image_t *      image,
                         pixman_filter_t       filter,
                         const pixman_fixed_t *params,
                         int                   n_params)
{
    image_common_t *common = (image_common_t *)image;
    pixman_fixed_t *new_params;

    if (params == common->filter_params && filter == common->filter)
	return TRUE;

    if (filter == PIXMAN_FILTER_SEPARABLE_CONVOLUTION)
    {
	int width = pixman_fixed_to_int (params[0]);
	int height = pixman_fixed_to_int (params[1]);
	int x_phase_bits = pixman_fixed_to_int (params[2]);
	int y_phase_bits = pixman_fixed_to_int (params[3]);
	int n_x_phases = (1 << x_phase_bits);
	int n_y_phases = (1 << y_phase_bits);

	return_val_if_fail (
	    n_params == 4 + n_x_phases * width + n_y_phases * height, FALSE);
    }
    
    new_params = NULL;
    if (params)
    {
	new_params = pixman_malloc_ab (n_params, sizeof (pixman_fixed_t));
	if (!new_params)
	    return FALSE;

	memcpy (new_params,
	        params, n_params * sizeof (pixman_fixed_t));
    }

    common->filter = filter;

    if (common->filter_params)
	free (common->filter_params);

    common->filter_params = new_params;
    common->n_filter_params = n_params;

    image_property_changed (image);
    return TRUE;
}

PIXMAN_EXPORT void
pixman_image_set_source_clipping (pixman_image_t *image,
                                  pixman_bool_t   clip_sources)
{
    if (image->common.clip_sources == clip_sources)
	return;

    image->common.clip_sources = clip_sources;

    image_property_changed (image);
}

/* Unlike all the other property setters, this function does not
 * copy the content of indexed. Doing this copying is simply
 * way, way too expensive.
 */
PIXMAN_EXPORT void
pixman_image_set_indexed (pixman_image_t *        image,
                          const pixman_indexed_t *indexed)
{
    bits_image_t *bits = (bits_image_t *)image;

    if (bits->indexed == indexed)
	return;

    bits->indexed = indexed;

    image_property_changed (image);
}

PIXMAN_EXPORT void
pixman_image_set_alpha_map (pixman_image_t *image,
                            pixman_image_t *alpha_map,
                            int16_t         x,
                            int16_t         y)
{
    image_common_t *common = (image_common_t *)image;

    return_if_fail (!alpha_map || alpha_map->type == BITS);

    if (alpha_map && common->alpha_count > 0)
    {
	/* If this image is being used as an alpha map itself,
	 * then you can't give it an alpha map of its own.
	 */
	return;
    }

    if (alpha_map && alpha_map->common.alpha_map)
    {
	/* If the image has an alpha map of its own,
	 * then it can't be used as an alpha map itself
	 */
	return;
    }

    if (common->alpha_map != (bits_image_t *)alpha_map)
    {
	if (common->alpha_map)
	{
	    common->alpha_map->common.alpha_count--;

	    pixman_image_unref ((pixman_image_t *)common->alpha_map);
	}

	if (alpha_map)
	{
	    common->alpha_map = (bits_image_t *)pixman_image_ref (alpha_map);

	    common->alpha_map->common.alpha_count++;
	}
	else
	{
	    common->alpha_map = NULL;
	}
    }

    common->alpha_origin_x = x;
    common->alpha_origin_y = y;

    image_property_changed (image);
}

PIXMAN_EXPORT void
pixman_image_set_component_alpha   (pixman_image_t *image,
                                    pixman_bool_t   component_alpha)
{
    if (image->common.component_alpha == component_alpha)
	return;

    image->common.component_alpha = component_alpha;

    image_property_changed (image);
}

PIXMAN_EXPORT pixman_bool_t
pixman_image_get_component_alpha   (pixman_image_t       *image)
{
    return image->common.component_alpha;
}

PIXMAN_EXPORT void
pixman_image_set_accessors (pixman_image_t *           image,
                            pixman_read_memory_func_t  read_func,
                            pixman_write_memory_func_t write_func)
{
    return_if_fail (image != NULL);

    if (image->type == BITS)
    {
	image->bits.read_func = read_func;
	image->bits.write_func = write_func;

	image_property_changed (image);
    }
}

PIXMAN_EXPORT uint32_t *
pixman_image_get_data (pixman_image_t *image)
{
    if (image->type == BITS)
	return image->bits.bits;

    return NULL;
}

PIXMAN_EXPORT int
pixman_image_get_width (pixman_image_t *image)
{
    if (image->type == BITS)
	return image->bits.width;

    return 0;
}

PIXMAN_EXPORT int
pixman_image_get_height (pixman_image_t *image)
{
    if (image->type == BITS)
	return image->bits.height;

    return 0;
}

PIXMAN_EXPORT int
pixman_image_get_stride (pixman_image_t *image)
{
    if (image->type == BITS)
	return image->bits.rowstride * (int) sizeof (uint32_t);

    return 0;
}

PIXMAN_EXPORT int
pixman_image_get_depth (pixman_image_t *image)
{
    if (image->type == BITS)
	return PIXMAN_FORMAT_DEPTH (image->bits.format);

    return 0;
}

PIXMAN_EXPORT pixman_format_code_t
pixman_image_get_format (pixman_image_t *image)
{
    if (image->type == BITS)
	return image->bits.format;

    return PIXMAN_null;
}

uint32_t
_pixman_image_get_solid (pixman_implementation_t *imp,
			 pixman_image_t *         image,
                         pixman_format_code_t     format)
{
    uint32_t result;

    if (image->type == SOLID)
    {
	result = image->solid.color_32;
    }
    else if (image->type == BITS)
    {
	if (image->bits.format == PIXMAN_a8r8g8b8)
	    result = image->bits.bits[0];
	else if (image->bits.format == PIXMAN_x8r8g8b8)
	    result = image->bits.bits[0] | 0xff000000;
	else if (image->bits.format == PIXMAN_a8)
	    result = (*(uint8_t *)image->bits.bits) << 24;
	else
	    goto otherwise;
    }
    else
    {
	pixman_iter_t iter;

    otherwise:
	_pixman_implementation_iter_init (
	    imp, &iter, image, 0, 0, 1, 1,
	    (uint8_t *)&result,
	    ITER_NARROW | ITER_SRC, image->common.flags);
	
	result = *iter.get_scanline (&iter, NULL);

	if (iter.fini)
	    iter.fini (&iter);
    }

    /* If necessary, convert RGB <--> BGR. */
    if (PIXMAN_FORMAT_TYPE (format) != PIXMAN_TYPE_ARGB
	&& PIXMAN_FORMAT_TYPE (format) != PIXMAN_TYPE_ARGB_SRGB)
    {
	result = (((result & 0xff000000) >>  0) |
	          ((result & 0x00ff0000) >> 16) |
	          ((result & 0x0000ff00) >>  0) |
	          ((result & 0x000000ff) << 16));
    }

    return result;
}
@


1.13
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@d505 4
a508 2
    /* Alpha map */
    if (!image->common.alpha_map)
d923 1
a923 1
	_pixman_implementation_src_iter_init (
d926 1
a926 1
	    ITER_NARROW, image->common.flags);
d929 3
@


1.12
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@d376 4
d522 3
a524 2
    if (image->common.alpha_map					||
	image->common.filter == PIXMAN_FILTER_CONVOLUTION	||
d687 13
d891 1
a891 1
    return 0;
@


1.11
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@d304 1
a304 1
		if (m01 == -1 && m10 == 1)
d306 1
a306 1
		else if (m01 == 1 && m10 == -1)
a881 1
    pixman_iter_t iter;
d883 18
a900 3
    _pixman_implementation_src_iter_init (
	imp, &iter, image, 0, 0, 1, 1,
	(uint8_t *)&result, ITER_NARROW);
d902 8
a909 1
    result = *iter.get_scanline (&iter, NULL);
d912 2
a913 1
    if (PIXMAN_FORMAT_TYPE (format) != PIXMAN_TYPE_ARGB)
@


1.10
log
@Update to pixman 0.22.4. Tested by shadchin@@, krw@@.
@
text
@d148 2
a149 5
	if (common->transform)
	    free (common->transform);

	if (common->filter_params)
	    free (common->filter_params);
d302 6
a307 7
		if (m01 == -image->common.transform->matrix[1][0])
		{
			if (m01 == -pixman_fixed_1)
			    flags |= FAST_PATH_ROTATE_90_TRANSFORM;
			else if (m01 == pixman_fixed_1)
			    flags |= FAST_PATH_ROTATE_270_TRANSFORM;
		}
@


1.9
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d34 44
d85 12
a96 1
    gradient->stops = pixman_malloc_ab (n_stops, sizeof (pixman_gradient_stop_t));
d100 1
d102 1
d104 1
a104 1
    gradient->n_stops = n_stops;
d109 2
a110 2
pixman_image_t *
_pixman_image_allocate (void)
d112 1
a112 5
    pixman_image_t *image = malloc (sizeof (pixman_image_t));

    if (image)
    {
	image_common_t *common = &image->common;
d114 1
a114 19
	pixman_region32_init (&common->clip_region);

	common->alpha_count = 0;
	common->have_clip_region = FALSE;
	common->clip_sources = FALSE;
	common->transform = NULL;
	common->repeat = PIXMAN_REPEAT_NONE;
	common->filter = PIXMAN_FILTER_NEAREST;
	common->filter_params = NULL;
	common->n_filter_params = 0;
	common->alpha_map = NULL;
	common->component_alpha = FALSE;
	common->ref_count = 1;
	common->property_changed = NULL;
	common->client_clip = FALSE;
	common->destroy_func = NULL;
	common->destroy_data = NULL;
	common->dirty = TRUE;
    }
d116 16
a131 1
    return image;
d134 2
a135 18
static void
image_property_changed (pixman_image_t *image)
{
    image->common.dirty = TRUE;
}

/* Ref Counting */
PIXMAN_EXPORT pixman_image_t *
pixman_image_ref (pixman_image_t *image)
{
    image->common.ref_count++;

    return image;
}

/* returns TRUE when the image is freed */
PIXMAN_EXPORT pixman_bool_t
pixman_image_unref (pixman_image_t *image)
d162 11
a172 1
		free (image->gradient.stops);
d178 38
a216 1

d334 41
d445 1
d637 1
a637 1
	memcmp (common->transform, transform, sizeof (pixman_transform_t) == 0))
@


1.8
log
@Bug-fix upgrade to pixman 0.20.2. No API/ABI change.
tested by shadchin@@, ajacoutot@@, krw@@, ok miod@@
@
text
@a32 1
#include "pixman-combine32.h"
a48 2
    gradient->stop_range = 0xffff;

a51 37
/*
 * By default, just evaluate the image at 32bpp and expand.  Individual image
 * types can plug in a better scanline getter if they want to. For example
 * we  could produce smoother gradients by evaluating them at higher color
 * depth, but that's a project for the future.
 */
void
_pixman_image_get_scanline_generic_64 (pixman_image_t * image,
                                       int              x,
                                       int              y,
                                       int              width,
                                       uint32_t *       buffer,
                                       const uint32_t * mask)
{
    uint32_t *mask8 = NULL;

    /* Contract the mask image, if one exists, so that the 32-bit fetch
     * function can use it.
     */
    if (mask)
    {
	mask8 = pixman_malloc_ab (width, sizeof(uint32_t));
	if (!mask8)
	    return;

	pixman_contract (mask8, (uint64_t *)mask, width);
    }

    /* Fetch the source image into the first half of buffer. */
    _pixman_image_get_scanline_32 (image, x, y, width, (uint32_t*)buffer, mask8);

    /* Expand from 32bpp to 64bpp in place. */
    pixman_expand ((uint64_t *)buffer, buffer, PIXMAN_a8r8g8b8, width);

    free (mask8);
}

d74 1
a74 1
	common->classify = NULL;
a83 38
source_image_class_t
_pixman_image_classify (pixman_image_t *image,
                        int             x,
                        int             y,
                        int             width,
                        int             height)
{
    if (image->common.classify)
	return image->common.classify (image, x, y, width, height);
    else
	return SOURCE_IMAGE_CLASS_UNKNOWN;
}

void
_pixman_image_get_scanline_32 (pixman_image_t *image,
                               int             x,
                               int             y,
                               int             width,
                               uint32_t *      buffer,
                               const uint32_t *mask)
{
    image->common.get_scanline_32 (image, x, y, width, buffer, mask);
}

/* Even thought the type of buffer is uint32_t *, the function actually expects
 * a uint64_t *buffer.
 */
void
_pixman_image_get_scanline_64 (pixman_image_t *image,
                               int             x,
                               int             y,
                               int             width,
                               uint32_t *      buffer,
                               const uint32_t *unused)
{
    image->common.get_scanline_64 (image, x, y, width, buffer, unused);
}

d163 8
a170 6
static pixman_bool_t out_of_bounds_workaround = TRUE;

/* Old X servers rely on out-of-bounds accesses when they are asked
 * to composite with a window as the source. They create a pixman image
 * pointing to some bogus position in memory, but then they set a clip
 * region to the position where the actual bits are.
d174 3
a176 2
 * actually work. So by default we allow certain out-of-bound access
 * to happen unless explicitly disabled.
d178 2
a179 1
 * Fixed X servers should call this function to disable the workaround.
a183 31
    out_of_bounds_workaround = FALSE;
}

static pixman_bool_t
source_image_needs_out_of_bounds_workaround (bits_image_t *image)
{
    if (image->common.clip_sources                      &&
        image->common.repeat == PIXMAN_REPEAT_NONE      &&
	image->common.have_clip_region			&&
        out_of_bounds_workaround)
    {
	if (!image->common.client_clip)
	{
	    /* There is no client clip, so if the clip region extends beyond the
	     * drawable geometry, it must be because the X server generated the
	     * bogus clip region.
	     */
	    const pixman_box32_t *extents =
		pixman_region32_extents (&image->common.clip_region);

	    if (extents->x1 >= 0 && extents->x2 <= image->width &&
		extents->y1 >= 0 && extents->y2 <= image->height)
	    {
		return FALSE;
	    }
	}

	return TRUE;
    }

    return FALSE;
d213 5
d220 12
a334 3
	if (source_image_needs_out_of_bounds_workaround (&image->bits))
	    flags |= FAST_PATH_NEEDS_WORKAROUND;

d357 1
d422 2
a423 1
	image->common.property_changed (image);
d504 1
a504 1
    if (memcmp (&id, transform, sizeof (pixman_transform_t)) == 0)
d513 6
d543 3
d590 3
d608 3
d673 3
d758 3
a760 2
_pixman_image_get_solid (pixman_image_t *     image,
                         pixman_format_code_t format)
d763 5
d769 1
a769 1
    _pixman_image_get_scanline_32 (image, 0, 0, 1, &result, NULL);
@


1.7
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@d433 15
a448 1
    case RADIAL:
@


1.6
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@a50 1
    gradient->common.class = SOURCE_IMAGE_CLASS_UNKNOWN;
d67 1
a67 2
                                       const uint32_t * mask,
                                       uint32_t         mask_bits)
d84 1
a84 2
    _pixman_image_get_scanline_32 (image, x, y, width, (uint32_t*)buffer, mask8,
                                   mask_bits);
d103 1
d143 1
a143 2
                               const uint32_t *mask,
                               uint32_t        mask_bits)
d145 1
a145 1
    image->common.get_scanline_32 (image, x, y, width, buffer, mask, mask_bits);
d157 1
a157 2
                               const uint32_t *unused,
                               uint32_t        unused2)
d159 1
a159 1
    image->common.get_scanline_64 (image, x, y, width, buffer, unused, unused2);
d300 4
a303 1
	flags |= (FAST_PATH_ID_TRANSFORM | FAST_PATH_X_UNIT_POSITIVE);
d307 4
a310 4
	if (image->common.transform->matrix[0][1] == 0 &&
	    image->common.transform->matrix[1][0] == 0 &&
	    image->common.transform->matrix[2][0] == 0 &&
	    image->common.transform->matrix[2][1] == 0 &&
d313 7
a319 1
	    flags |= FAST_PATH_SCALE_TRANSFORM;
d324 3
a328 4
    /* Alpha map */
    if (!image->common.alpha_map)
	flags |= FAST_PATH_NO_ALPHA_MAP;

d337 6
d355 4
a358 1
	flags |= FAST_PATH_NO_REFLECT_REPEAT | FAST_PATH_NO_PAD_REPEAT;
d362 4
a365 1
	flags |= FAST_PATH_NO_PAD_REPEAT | FAST_PATH_NO_NONE_REPEAT;
d369 4
a372 1
	flags |= FAST_PATH_NO_REFLECT_REPEAT | FAST_PATH_NO_NONE_REPEAT;
d376 4
a379 1
	flags |= FAST_PATH_NO_REFLECT_REPEAT | FAST_PATH_NO_PAD_REPEAT | FAST_PATH_NO_NONE_REPEAT;
d389 1
a389 1
    flags |= (FAST_PATH_NO_ACCESSORS | FAST_PATH_NO_WIDE_FORMAT);
a410 6

	    if (!image->common.transform &&
		image->common.repeat == PIXMAN_REPEAT_NORMAL)
	    {
		flags |= FAST_PATH_SIMPLE_REPEAT;
	    }
d413 1
a413 2
	if (image->common.repeat != PIXMAN_REPEAT_NONE				&&
	    !PIXMAN_FORMAT_A (image->bits.format)				&&
d417 4
a420 1
	    flags |= FAST_PATH_IS_OPAQUE;
d430 1
a430 1
	    flags &= ~FAST_PATH_NO_WIDE_FORMAT;
d458 11
d479 1
a479 1
	flags &= ~FAST_PATH_IS_OPAQUE;
d686 16
d705 3
d709 1
d712 1
d714 3
d718 1
d720 1
d738 6
d805 9
d820 1
a820 1
    _pixman_image_get_scanline_32 (image, 0, 0, 1, &result, NULL, 0);
@


1.5
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@a50 2
    gradient->color_table = NULL;
    gradient->color_table_size = 0;
a119 1
	common->need_workaround = FALSE;
d233 6
d245 212
d462 7
d470 1
d475 1
a475 1
	_pixman_image_validate (image->common.alpha_map);
a743 19
pixman_bool_t
_pixman_image_is_solid (pixman_image_t *image)
{
    if (image->type == SOLID)
	return TRUE;

    if (image->type != BITS     ||
        image->bits.width != 1  ||
        image->bits.height != 1)
    {
	return FALSE;
    }

    if (image->common.repeat == PIXMAN_REPEAT_NONE)
	return FALSE;

    return TRUE;
}

a762 51

pixman_bool_t
_pixman_image_is_opaque (pixman_image_t *image)
{
    int i;

    if (image->common.alpha_map)
	return FALSE;

    switch (image->type)
    {
    case BITS:
	if (image->common.repeat == PIXMAN_REPEAT_NONE)
	    return FALSE;

	if (PIXMAN_FORMAT_A (image->bits.format))
	    return FALSE;
	break;

    case LINEAR:
    case RADIAL:
	if (image->common.repeat == PIXMAN_REPEAT_NONE)
	    return FALSE;

	for (i = 0; i < image->gradient.n_stops; ++i)
	{
	    if (image->gradient.stops[i].color.alpha != 0xffff)
		return FALSE;
	}
	break;

    case CONICAL:
	/* Conical gradients always have a transparent border */
	return FALSE;
	break;

    case SOLID:
	if (ALPHA_8 (image->solid.color) != 0xff)
	    return FALSE;
	break;
    }

    /* Convolution filters can introduce translucency if the sum of the
     * weights is lower than 1.
     */
    if (image->common.filter == PIXMAN_FILTER_CONVOLUTION)
	return FALSE;

    return TRUE;
}

@


1.4
log
@Update to pixman 0.15.8.
@
text
@d33 1
a33 2

#define Alpha(x) ((x) >> 24)
d36 3
a38 3
_pixman_init_gradient (gradient_t     *gradient,
		       const pixman_gradient_stop_t *stops,
		       int	       n_stops)
d61 2
a62 2
 * we  could produce smoother gradients by evaluating them at higher color depth, but
 * that's a project for the future.
d65 7
a71 2
_pixman_image_get_scanline_64_generic (pixman_image_t * pict, int x, int y, int width,
				       uint64_t *buffer, uint64_t *mask, uint32_t maskBits)
d75 6
a80 4
    // Contract the mask image, if one exists, so that the 32-bit fetch function
    // can use it.
    if (mask) {
        mask8 = pixman_malloc_ab(width, sizeof(uint32_t));
d83 2
a84 2
	
        pixman_contract(mask8, mask, width);
d87 3
a89 3
    // Fetch the source image into the first half of buffer.
    _pixman_image_get_scanline_32 (pict, x, y, width, (uint32_t*)buffer, mask8,
				   maskBits);
d91 2
a92 2
    // Expand from 32bpp to 64bpp in place.
    pixman_expand(buffer, (uint32_t*)buffer, PIXMAN_a8r8g8b8, width);
d94 1
a94 1
    free(mask8);
a105 1
	pixman_region32_init (&common->full_region);
d107 3
a109 2
	common->src_clip = &common->full_region;
	common->has_client_clip = FALSE;
a117 2
	common->read_func = NULL;
	common->write_func = NULL;
d119 5
d129 1
a129 1
source_pict_class_t
d131 4
a134 4
			int             x,
			int             y,
			int             width,
			int             height)
d143 7
a149 2
_pixman_image_get_scanline_32 (pixman_image_t *image, int x, int y, int width,
			       uint32_t *buffer, uint32_t *mask, uint32_t mask_bits)
d154 3
d158 7
a164 2
_pixman_image_get_scanline_64 (pixman_image_t *image, int x, int y, int width,
			       uint32_t *buffer, uint32_t *unused, uint32_t unused2)
a168 19
/* Even thought the type of buffer is uint32_t *, the function actually expects
 * a uint64_t *buffer.
 */

scanFetchProc
_pixman_image_get_fetcher (pixman_image_t *image,
			   int             wide)
{
    assert (image->common.get_scanline_64);
    assert (image->common.get_scanline_32);
    
    if (wide)
	return image->common.get_scanline_64;
    else
	return image->common.get_scanline_32;
}

#define WRITE_ACCESS(f) ((image->common.write_func)? f##_accessors : f)

d172 1
a172 3
    
    
    image->common.property_changed (image);
d194 3
a197 1
	pixman_region32_fini (&common->full_region);
d208 3
a210 9
#if 0
	if (image->type == BITS && image->bits.indexed)
	    free (image->bits.indexed);
#endif

#if 0
	memset (image, 0xaa, sizeof (pixman_image_t));
#endif
	if (image->type == LINEAR || image->type == RADIAL || image->type == CONICAL)
a215 1

d227 8
a234 1
/* Constructors */
d239 2
a240 1
    pixman_region32_fini (&image->common.clip_region);
d242 4
a245 1
    if (image->type == BITS)
d247 2
a248 6
	pixman_region32_init_rect (&image->common.clip_region, 0, 0,
				   image->bits.width, image->bits.height);
    }
    else
    {
	pixman_region32_init (&image->common.clip_region);
d250 3
d256 2
a257 2
pixman_image_set_clip_region32 (pixman_image_t *image,
				pixman_region32_t *region)
d264 2
a265 1
	result = pixman_region32_copy (&common->clip_region, region);
a278 1

d280 2
a281 2
pixman_image_set_clip_region (pixman_image_t    *image,
			      pixman_region16_t *region)
d288 2
a289 1
	result = pixman_region32_copy_from_region16 (&common->clip_region, region);
a302 2
/* Sets whether the clip region includes a clip region set by the client
 */
d305 1
a305 1
				  pixman_bool_t	  client_clip)
d307 1
a307 3
    image->common.has_client_clip = client_clip;

    image_property_changed (image);
d311 2
a312 2
pixman_image_set_transform (pixman_image_t           *image,
			    const pixman_transform_t *transform)
d318 1
a318 2
	  { 0, 0, pixman_fixed_1 }
	}
d329 1
a329 1
	free(common->transform);
d332 1
d342 1
d346 3
a348 1
    memcpy(common->transform, transform, sizeof(pixman_transform_t));
d352 2
a353 2
    
    return TRUE;
d357 2
a358 2
pixman_image_set_repeat (pixman_image_t  *image,
			 pixman_repeat_t  repeat)
d366 4
a369 4
pixman_image_set_filter (pixman_image_t       *image,
			 pixman_filter_t       filter,
			 const pixman_fixed_t *params,
			 int		       n_params)
d385 1
a385 1
		params, n_params * sizeof (pixman_fixed_t));
d401 2
a402 2
pixman_image_set_source_clipping (pixman_image_t  *image,
				  pixman_bool_t    source_clipping)
d404 1
a404 6
    image_common_t *common = &image->common;

    if (source_clipping)
	common->src_clip = &common->clip_region;
    else
	common->src_clip = &common->full_region;
d414 2
a415 2
pixman_image_set_indexed (pixman_image_t	 *image,
			  const pixman_indexed_t *indexed)
d426 3
a428 3
			    pixman_image_t *alpha_map,
			    int16_t         x,
			    int16_t         y)
d445 2
a446 2
    common->alpha_origin.x = x;
    common->alpha_origin.y = y;
d452 2
a453 2
pixman_image_set_component_alpha   (pixman_image_t       *image,
				    pixman_bool_t         component_alpha)
a459 1

d461 3
a463 3
pixman_image_set_accessors (pixman_image_t             *image,
			    pixman_read_memory_func_t	read_func,
			    pixman_write_memory_func_t	write_func)
d467 4
a470 2
    image->common.read_func = read_func;
    image->common.write_func = write_func;
d472 2
a473 1
    image_property_changed (image);
d521 2
a522 2
static uint32_t
color_to_uint32 (const pixman_color_t *color)
d524 6
a529 23
    return
	(color->alpha >> 8 << 24) |
	(color->red >> 8 << 16) |
        (color->green & 0xff00) |
	(color->blue >> 8);
}

static pixman_bool_t
color_to_pixel (pixman_color_t *color,
		uint32_t       *pixel,
		pixman_format_code_t format)
{
    uint32_t c = color_to_uint32 (color);

    if (!(format == PIXMAN_a8r8g8b8	||
	  format == PIXMAN_x8r8g8b8	||
	  format == PIXMAN_a8b8g8r8	||
	  format == PIXMAN_x8b8g8r8	||
	  format == PIXMAN_b8g8r8a8	||
	  format == PIXMAN_b8g8r8x8	||
	  format == PIXMAN_r5g6b5	||
	  format == PIXMAN_b5g6r5	||
	  format == PIXMAN_a8))
d534 2
a535 25
    if (PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_ABGR)
    {
	c = ((c & 0xff000000) >>  0) |
	    ((c & 0x00ff0000) >> 16) |
	    ((c & 0x0000ff00) >>  0) |
	    ((c & 0x000000ff) << 16);
    }
    if (PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_BGRA)
    {
	c = ((c & 0xff000000) >> 24) |
	    ((c & 0x00ff0000) >>  8) |
	    ((c & 0x0000ff00) <<  8) |
	    ((c & 0x000000ff) << 24);
    }

    if (format == PIXMAN_a8)
	c = c >> 24;
    else if (format == PIXMAN_r5g6b5 ||
	     format == PIXMAN_b5g6r5)
	c = cvt8888to0565 (c);

#if 0
    printf ("color: %x %x %x %x\n", color->alpha, color->red, color->green, color->blue);
    printf ("pixel: %x\n", c);
#endif
a536 1
    *pixel = c;
d540 3
a542 6
PIXMAN_EXPORT pixman_bool_t
pixman_image_fill_rectangles (pixman_op_t		    op,
			      pixman_image_t		   *dest,
			      pixman_color_t		   *color,
			      int			    n_rects,
			      const pixman_rectangle16_t   *rects)
d544 1
a544 3
    pixman_image_t *solid;
    pixman_color_t c;
    int i;
d546 1
a546 5
    if (color->alpha == 0xffff)
    {
	if (op == PIXMAN_OP_OVER)
	    op = PIXMAN_OP_SRC;
    }
d548 2
a549 1
    if (op == PIXMAN_OP_CLEAR)
d551 4
a554 8
	c.red = 0;
	c.green = 0;
	c.blue = 0;
	c.alpha = 0;

	color = &c;

	op = PIXMAN_OP_SRC;
d557 1
a557 51
    if (op == PIXMAN_OP_SRC)
    {
	uint32_t pixel;

	if (color_to_pixel (color, &pixel, dest->bits.format))
	{
	    for (i = 0; i < n_rects; ++i)
	    {
		pixman_region32_t fill_region;
		int n_boxes, j;
		pixman_box32_t *boxes;

		pixman_region32_init_rect (&fill_region, rects[i].x, rects[i].y, rects[i].width, rects[i].height);
		if (!pixman_region32_intersect (&fill_region,
						&fill_region,
						&dest->common.clip_region))
		    return FALSE;


		boxes = pixman_region32_rectangles (&fill_region, &n_boxes);
		for (j = 0; j < n_boxes; ++j)
		{
		    const pixman_box32_t *box = &(boxes[j]);
		    pixman_fill (dest->bits.bits, dest->bits.rowstride, PIXMAN_FORMAT_BPP (dest->bits.format),
				 box->x1, box->y1, box->x2 - box->x1, box->y2 - box->y1,
				 pixel);
		}

		pixman_region32_fini (&fill_region);
	    }
	    return TRUE;
	}
    }

    solid = pixman_image_create_solid_fill (color);
    if (!solid)
	return FALSE;

    for (i = 0; i < n_rects; ++i)
    {
	const pixman_rectangle16_t *rect = &(rects[i]);

	pixman_image_composite (op, solid, NULL, dest,
				0, 0, 0, 0,
				rect->x, rect->y,
				rect->width, rect->height);
    }

    pixman_image_unref (solid);

    return TRUE;
d561 1
a561 1
pixman_image_can_get_solid (pixman_image_t *image)
d563 1
a563 2
    if (image->type == SOLID)
	return TRUE;
d565 1
a565 4
    if (image->type != BITS	||
	image->bits.width != 1	||
	image->bits.height != 1)
    {
a566 1
    }
d568 1
a568 4
    if (image->common.repeat != PIXMAN_REPEAT_NORMAL)
	return FALSE;

    switch (image->bits.format)
d570 3
a572 15
    case PIXMAN_a8r8g8b8:
    case PIXMAN_x8r8g8b8:
    case PIXMAN_a8b8g8r8:
    case PIXMAN_x8b8g8r8:
    case PIXMAN_b8g8r8a8:
    case PIXMAN_b8g8r8x8:
    case PIXMAN_r8g8b8:
    case PIXMAN_b8g8r8:
    case PIXMAN_r5g6b5:
    case PIXMAN_b5g6r5:
	return TRUE;
    default:
	return FALSE;
    }
}
d574 3
a576 5
pixman_bool_t
pixman_image_is_opaque(pixman_image_t *image)
{
    int i = 0;
    int gradientNumberOfColors = 0;
d578 4
a581 2
    if(image->common.alpha_map)
        return FALSE;
d583 6
a588 6
    switch(image->type)
    {
    case BITS:
        if(PIXMAN_FORMAT_A(image->bits.format))
            return FALSE;
        break;
a589 1
    case LINEAR:
d591 3
a593 10
    case RADIAL:
        gradientNumberOfColors = image->gradient.n_stops;
        i=0;
        while(i<gradientNumberOfColors)
        {
            if(image->gradient.stops[i].color.alpha != 0xffff)
                return FALSE;
            i++;
        }
        break;
d596 3
a598 3
         if(Alpha(image->solid.color) != 0xff)
            return FALSE;
        break;
d601 3
a603 2
    /* Convolution filters can introduce translucency if the sum of the weights
       is lower than 1. */
d605 1
a605 1
         return FALSE;
d607 2
a608 4
    if (image->common.repeat == PIXMAN_REPEAT_NONE)
    {
        if (image->common.filter != PIXMAN_FILTER_NEAREST)
            return FALSE;
a609 10
        if (image->common.transform)
            return FALSE;

	/* Gradients do not necessarily cover the entire compositing area */
	if (image->type == LINEAR || image->type == CONICAL || image->type == RADIAL)
	    return FALSE;
    }

     return TRUE;
}
@


1.3
log
@pixman 0.12.0. Tested on a full ports build by naddy@@.
@
text
@d30 1
d36 4
a39 10
static void
init_source_image (source_image_t *image)
{
    image->class = SOURCE_IMAGE_CLASS_UNKNOWN;
}

static pixman_bool_t
init_gradient (gradient_t     *gradient,
	       const pixman_gradient_stop_t *stops,
	       int	       n_stops)
a42 2
    init_source_image (&gradient->common);

d54 1
d59 9
a67 2
static uint32_t
color_to_uint32 (const pixman_color_t *color)
d69 20
a88 5
    return
	(color->alpha >> 8 << 24) |
	(color->red >> 8 << 16) |
        (color->green & 0xff00) |
	(color->blue >> 8);
d91 2
a92 2
static pixman_image_t *
allocate_image (void)
d114 1
d120 54
a231 32
PIXMAN_EXPORT pixman_image_t *
pixman_image_create_solid_fill (pixman_color_t *color)
{
    pixman_image_t *img = allocate_image();
    if (!img)
	return NULL;

    init_source_image (&img->solid.common);

    img->type = SOLID;
    img->solid.color = color_to_uint32 (color);

    return img;
}

PIXMAN_EXPORT pixman_image_t *
pixman_image_create_linear_gradient (pixman_point_fixed_t         *p1,
				     pixman_point_fixed_t         *p2,
				     const pixman_gradient_stop_t *stops,
				     int                           n_stops)
{
    pixman_image_t *image;
    linear_gradient_t *linear;

    return_val_if_fail (n_stops >= 2, NULL);

    image = allocate_image();

    if (!image)
	return NULL;

    linear = &image->linear;
d233 2
a234 131
    if (!init_gradient (&linear->common, stops, n_stops))
    {
	free (image);
	return NULL;
    }

    linear->p1 = *p1;
    linear->p2 = *p2;

    image->type = LINEAR;

    return image;
}


PIXMAN_EXPORT pixman_image_t *
pixman_image_create_radial_gradient (pixman_point_fixed_t         *inner,
				     pixman_point_fixed_t         *outer,
				     pixman_fixed_t                inner_radius,
				     pixman_fixed_t                outer_radius,
				     const pixman_gradient_stop_t *stops,
				     int                           n_stops)
{
    pixman_image_t *image;
    radial_gradient_t *radial;

    return_val_if_fail (n_stops >= 2, NULL);

    image = allocate_image();

    if (!image)
	return NULL;

    radial = &image->radial;

    if (!init_gradient (&radial->common, stops, n_stops))
    {
	free (image);
	return NULL;
    }

    image->type = RADIAL;

    radial->c1.x = inner->x;
    radial->c1.y = inner->y;
    radial->c1.radius = inner_radius;
    radial->c2.x = outer->x;
    radial->c2.y = outer->y;
    radial->c2.radius = outer_radius;
    radial->cdx = pixman_fixed_to_double (radial->c2.x - radial->c1.x);
    radial->cdy = pixman_fixed_to_double (radial->c2.y - radial->c1.y);
    radial->dr = pixman_fixed_to_double (radial->c2.radius - radial->c1.radius);
    radial->A = (radial->cdx * radial->cdx
		 + radial->cdy * radial->cdy
		 - radial->dr  * radial->dr);

    return image;
}

PIXMAN_EXPORT pixman_image_t *
pixman_image_create_conical_gradient (pixman_point_fixed_t *center,
				      pixman_fixed_t angle,
				      const pixman_gradient_stop_t *stops,
				      int n_stops)
{
    pixman_image_t *image = allocate_image();
    conical_gradient_t *conical;

    if (!image)
	return NULL;

    conical = &image->conical;

    if (!init_gradient (&conical->common, stops, n_stops))
    {
	free (image);
	return NULL;
    }

    image->type = CONICAL;
    conical->center = *center;
    conical->angle = angle;

    return image;
}

static uint32_t *
create_bits (pixman_format_code_t format,
	     int		  width,
	     int		  height,
	     int		 *rowstride_bytes)
{
    int stride;
    int buf_size;
    int bpp;

    /* what follows is a long-winded way, avoiding any possibility of integer
     * overflows, of saying:
     * stride = ((width * bpp + FB_MASK) >> FB_SHIFT) * sizeof (uint32_t);
     */

    bpp = PIXMAN_FORMAT_BPP (format);
    if (pixman_multiply_overflows_int (width, bpp))
	return NULL;

    stride = width * bpp;
    if (pixman_addition_overflows_int (stride, FB_MASK))
	return NULL;

    stride += FB_MASK;
    stride >>= FB_SHIFT;

#if FB_SHIFT < 2
    if (pixman_multiply_overflows_int (stride, sizeof (uint32_t)))
	return NULL;
#endif
    stride *= sizeof (uint32_t);

    if (pixman_multiply_overflows_int (height, stride))
	return NULL;

    buf_size = height * stride;

    if (rowstride_bytes)
	*rowstride_bytes = stride;

    return calloc (buf_size, 1);
}

static void
reset_clip_region (pixman_image_t *image)
a248 50
PIXMAN_EXPORT pixman_image_t *
pixman_image_create_bits (pixman_format_code_t  format,
			  int                   width,
			  int                   height,
			  uint32_t	       *bits,
			  int			rowstride_bytes)
{
    pixman_image_t *image;
    uint32_t *free_me = NULL;

    /* must be a whole number of uint32_t's
     */
    return_val_if_fail (bits == NULL ||
			(rowstride_bytes % sizeof (uint32_t)) == 0, NULL);

    if (!bits && width && height)
    {
	free_me = bits = create_bits (format, width, height, &rowstride_bytes);
	if (!bits)
	    return NULL;
    }

    image = allocate_image();

    if (!image) {
	if (free_me)
	    free (free_me);
	return NULL;
    }
    
    image->type = BITS;
    image->bits.format = format;
    image->bits.width = width;
    image->bits.height = height;
    image->bits.bits = bits;
    image->bits.free_me = free_me;

    image->bits.rowstride = rowstride_bytes / (int) sizeof (uint32_t); /* we store it in number
								  * of uint32_t's
								  */
    image->bits.indexed = NULL;

    pixman_region32_fini (&image->common.full_region);
    pixman_region32_init_rect (&image->common.full_region, 0, 0,
			       image->bits.width, image->bits.height);

    reset_clip_region (image);
    return image;
}

d254 1
d258 1
a258 1
	return pixman_region32_copy (&common->clip_region, region);
d262 1
a262 1
	reset_clip_region (image);
d264 1
a264 1
	return TRUE;
d266 4
d278 1
d282 1
a282 1
	return pixman_region32_copy_from_region16 (&common->clip_region, region);
d286 1
a286 1
	reset_clip_region (image);
d288 1
a288 1
	return TRUE;
d290 4
d303 2
d320 1
d329 2
a330 1
	return TRUE;
d335 1
d337 4
a340 1
	return FALSE;
d344 3
d355 2
d389 2
d404 2
d419 2
d446 2
d455 2
d469 2
d518 10
d539 2
d555 7
d620 5
a624 1
		pixman_region32_intersect (&fill_region, &fill_region, &dest->common.clip_region);
d682 2
@


1.2
log
@Update to pixman 0.10, with one small fix to the sse2 test in configure.ac.
@
text
@d33 2
d84 2
a85 2
	pixman_region_init (&common->full_region);
	pixman_region_init (&common->clip_region);
d104 1
a104 1
pixman_image_t *
d113 1
a113 1
pixman_bool_t
d122 2
a123 2
	pixman_region_fini (&common->clip_region);
	pixman_region_fini (&common->full_region);
d161 1
a161 1
pixman_image_t *
d176 1
a176 1
pixman_image_t *
d209 1
a209 1
pixman_image_t *
d253 1
a253 1
pixman_image_t *
d326 1
a326 1
    pixman_region_fini (&image->common.clip_region);
d330 2
a331 2
	pixman_region_init_rect (&image->common.clip_region, 0, 0,
				 image->bits.width, image->bits.height);
d335 1
a335 1
	pixman_region_init (&image->common.clip_region);
d339 1
a339 1
pixman_image_t *
d381 3
a383 3
    pixman_region_fini (&image->common.full_region);
    pixman_region_init_rect (&image->common.full_region, 0, 0,
			     image->bits.width, image->bits.height);
d389 20
a408 1
pixman_bool_t
d416 1
a416 1
	return pixman_region_copy (&common->clip_region, region);
d428 1
a428 1
void
d435 1
a435 1
pixman_bool_t
d469 1
a469 1
void
d476 1
a476 1
pixman_bool_t
d509 1
a509 1
void
d525 1
a525 1
void
d534 1
a534 1
void
d559 1
a559 1
void
d567 1
a567 1
void
d578 1
a578 1
uint32_t *
d587 1
a587 1
int
d596 1
a596 1
int
d605 1
a605 1
int
d614 1
a614 1
int
d623 1
a623 1
pixman_bool_t
d664 1
a664 1
pixman_bool_t
d701 1
a701 1
		pixman_region16_t fill_region;
d703 1
a703 1
		pixman_box16_t *boxes;
d705 2
a706 2
		pixman_region_init_rect (&fill_region, rects[i].x, rects[i].y, rects[i].width, rects[i].height);
		pixman_region_intersect (&fill_region, &fill_region, &dest->common.clip_region);
d708 1
a708 1
		boxes = pixman_region_rectangles (&fill_region, &n_boxes);
d711 1
a711 1
		    const pixman_box16_t *box = &(boxes[j]);
d717 1
a717 1
		pixman_region_fini (&fill_region);
d740 88
@


1.1
log
@Initial revision
@
text
@d23 1
d25 1
a30 1
#include "pixman.h"
d53 1
a53 1
    
d77 1
a77 1
    
d136 1
a136 1
	
d146 1
a146 1
	
d149 1
a149 1
	
d165 1
a165 1
    
d167 1
a167 1
    
d184 1
a184 1
    
d186 1
a186 1
    
d191 1
a191 1
    
d219 1
a219 1
    
d234 1
a234 1
    
d247 1
a247 1
    
d264 1
a264 1
    
d287 6
a292 1
    
d294 19
a312 1
    stride = ((width * bpp + FB_MASK) >> FB_SHIFT) * sizeof (uint32_t);
d325 1
a325 1
    
d329 1
a329 1
				 image->bits.width, image->bits.height);	
d347 1
a347 1
    /* must be a whole number of uint32_t's 
d350 1
a350 1
			(rowstride_bytes % sizeof (uint32_t)) == 0, NULL); 
d352 1
a352 1
    if (!bits)
d358 1
a358 1
    
d361 3
a363 1
    if (!image)
d365 1
d373 2
a374 2
    
    image->bits.rowstride = rowstride_bytes / sizeof (uint32_t); /* we store it in number
d400 1
a400 1
	
d425 1
a425 1
    
d437 1
a437 1
    
d455 1
a455 1
pixman_bool_t 
d479 1
a479 1
	
d520 1
a520 1
    
d588 1
a588 1
	return image->bits.rowstride * sizeof (uint32_t);
d619 1
a619 1
    
d638 1
a638 1
    
d653 1
a653 1
    
d668 1
a668 1
	
d675 1
a675 1
	
d683 1
a683 1
		
d701 1
a701 1
    
d709 1
a709 1
	
d715 1
a715 1
    
@


1.1.1.1
log
@import pixman 0.9.5
@
text
@@


1.1.1.2
log
@pixman 0.9.6
@
text
@a22 1
#ifdef HAVE_CONFIG_H
a23 1
#endif
d286 1
a286 6

    /* what follows is a long-winded way, avoiding any possibility of integer
     * overflows, of saying:
     * stride = ((width * bpp + FB_MASK) >> FB_SHIFT) * sizeof (uint32_t);
     */

d288 1
a288 19
    if (pixman_multiply_overflows_int (width, bpp))
	return NULL;

    stride = width * bpp;
    if (pixman_addition_overflows_int (stride, FB_MASK))
	return NULL;

    stride += FB_MASK;
    stride >>= FB_SHIFT;

#if FB_SHIFT < 2
    if (pixman_multiply_overflows_int (stride, sizeof (uint32_t)))
	return NULL;
#endif
    stride *= sizeof (uint32_t);

    if (pixman_multiply_overflows_int (height, stride))
	return NULL;

d328 1
a328 1
    if (!bits && width && height)
d337 1
a337 3
    if (!image) {
	if (free_me)
	    free (free_me);
a338 1
    }
@

