head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.4
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.2
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.12
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.10
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.6
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.10.01.10.17.44;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	FGr8CFhVerRlpSoE;

1.9
date	2013.12.01.20.34.20;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.18.01;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.02.28.20.36.12;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.05.20.14.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to pixman 0.34.0.
@
text
@/*
 * Copyright Â© 2009 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Red Hat not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  Red Hat makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdlib.h>
#include "pixman-private.h"

pixman_implementation_t *
_pixman_implementation_create (pixman_implementation_t *fallback,
			       const pixman_fast_path_t *fast_paths)
{
    pixman_implementation_t *imp;

    assert (fast_paths);

    if ((imp = malloc (sizeof (pixman_implementation_t))))
    {
	pixman_implementation_t *d;

	memset (imp, 0, sizeof *imp);

	imp->fallback = fallback;
	imp->fast_paths = fast_paths;
	
	/* Make sure the whole fallback chain has the right toplevel */
	for (d = imp; d != NULL; d = d->fallback)
	    d->toplevel = imp;
    }

    return imp;
}

#define N_CACHED_FAST_PATHS 8

typedef struct
{
    struct
    {
	pixman_implementation_t *	imp;
	pixman_fast_path_t		fast_path;
    } cache [N_CACHED_FAST_PATHS];
} cache_t;

PIXMAN_DEFINE_THREAD_LOCAL (cache_t, fast_path_cache);

static void
dummy_composite_rect (pixman_implementation_t *imp,
		      pixman_composite_info_t *info)
{
}

void
_pixman_implementation_lookup_composite (pixman_implementation_t  *toplevel,
					 pixman_op_t               op,
					 pixman_format_code_t      src_format,
					 uint32_t                  src_flags,
					 pixman_format_code_t      mask_format,
					 uint32_t                  mask_flags,
					 pixman_format_code_t      dest_format,
					 uint32_t                  dest_flags,
					 pixman_implementation_t **out_imp,
					 pixman_composite_func_t  *out_func)
{
    pixman_implementation_t *imp;
    cache_t *cache;
    int i;

    /* Check cache for fast paths */
    cache = PIXMAN_GET_THREAD_LOCAL (fast_path_cache);

    for (i = 0; i < N_CACHED_FAST_PATHS; ++i)
    {
	const pixman_fast_path_t *info = &(cache->cache[i].fast_path);

	/* Note that we check for equality here, not whether
	 * the cached fast path matches. This is to prevent
	 * us from selecting an overly general fast path
	 * when a more specific one would work.
	 */
	if (info->op == op			&&
	    info->src_format == src_format	&&
	    info->mask_format == mask_format	&&
	    info->dest_format == dest_format	&&
	    info->src_flags == src_flags	&&
	    info->mask_flags == mask_flags	&&
	    info->dest_flags == dest_flags	&&
	    info->func)
	{
	    *out_imp = cache->cache[i].imp;
	    *out_func = cache->cache[i].fast_path.func;

	    goto update_cache;
	}
    }

    for (imp = toplevel; imp != NULL; imp = imp->fallback)
    {
	const pixman_fast_path_t *info = imp->fast_paths;

	while (info->op != PIXMAN_OP_NONE)
	{
	    if ((info->op == op || info->op == PIXMAN_OP_any)		&&
		/* Formats */
		((info->src_format == src_format) ||
		 (info->src_format == PIXMAN_any))			&&
		((info->mask_format == mask_format) ||
		 (info->mask_format == PIXMAN_any))			&&
		((info->dest_format == dest_format) ||
		 (info->dest_format == PIXMAN_any))			&&
		/* Flags */
		(info->src_flags & src_flags) == info->src_flags	&&
		(info->mask_flags & mask_flags) == info->mask_flags	&&
		(info->dest_flags & dest_flags) == info->dest_flags)
	    {
		*out_imp = imp;
		*out_func = info->func;

		/* Set i to the last spot in the cache so that the
		 * move-to-front code below will work
		 */
		i = N_CACHED_FAST_PATHS - 1;

		goto update_cache;
	    }

	    ++info;
	}
    }

    /* We should never reach this point */
    _pixman_log_error (
        FUNC,
        "No composite function found\n"
        "\n"
        "The most likely cause of this is that this system has issues with\n"
        "thread local storage\n");

    *out_imp = NULL;
    *out_func = dummy_composite_rect;
    return;

update_cache:
    if (i)
    {
	while (i--)
	    cache->cache[i + 1] = cache->cache[i];

	cache->cache[0].imp = *out_imp;
	cache->cache[0].fast_path.op = op;
	cache->cache[0].fast_path.src_format = src_format;
	cache->cache[0].fast_path.src_flags = src_flags;
	cache->cache[0].fast_path.mask_format = mask_format;
	cache->cache[0].fast_path.mask_flags = mask_flags;
	cache->cache[0].fast_path.dest_format = dest_format;
	cache->cache[0].fast_path.dest_flags = dest_flags;
	cache->cache[0].fast_path.func = *out_func;
    }
}

static void
dummy_combine (pixman_implementation_t *imp,
	       pixman_op_t              op,
	       uint32_t *               pd,
	       const uint32_t *         ps,
	       const uint32_t *         pm,
	       int                      w)
{
}

pixman_combine_32_func_t
_pixman_implementation_lookup_combiner (pixman_implementation_t *imp,
					pixman_op_t		 op,
					pixman_bool_t		 component_alpha,
					pixman_bool_t		 narrow)
{
    while (imp)
    {
	pixman_combine_32_func_t f = NULL;

	switch ((narrow << 1) | component_alpha)
	{
	case 0: /* not narrow, not component alpha */
	    f = (pixman_combine_32_func_t)imp->combine_float[op];
	    break;
	    
	case 1: /* not narrow, component_alpha */
	    f = (pixman_combine_32_func_t)imp->combine_float_ca[op];
	    break;

	case 2: /* narrow, not component alpha */
	    f = imp->combine_32[op];
	    break;

	case 3: /* narrow, component_alpha */
	    f = imp->combine_32_ca[op];
	    break;
	}

	if (f)
	    return f;

	imp = imp->fallback;
    }

    /* We should never reach this point */
    _pixman_log_error (FUNC, "No known combine function\n");
    return dummy_combine;
}

pixman_bool_t
_pixman_implementation_blt (pixman_implementation_t * imp,
                            uint32_t *                src_bits,
                            uint32_t *                dst_bits,
                            int                       src_stride,
                            int                       dst_stride,
                            int                       src_bpp,
                            int                       dst_bpp,
                            int                       src_x,
                            int                       src_y,
                            int                       dest_x,
                            int                       dest_y,
                            int                       width,
                            int                       height)
{
    while (imp)
    {
	if (imp->blt &&
	    (*imp->blt) (imp, src_bits, dst_bits, src_stride, dst_stride,
			 src_bpp, dst_bpp, src_x, src_y, dest_x, dest_y,
			 width, height))
	{
	    return TRUE;
	}

	imp = imp->fallback;
    }

    return FALSE;
}

pixman_bool_t
_pixman_implementation_fill (pixman_implementation_t *imp,
                             uint32_t *               bits,
                             int                      stride,
                             int                      bpp,
                             int                      x,
                             int                      y,
                             int                      width,
                             int                      height,
                             uint32_t                 filler)
{
    while (imp)
    {
	if (imp->fill &&
	    ((*imp->fill) (imp, bits, stride, bpp, x, y, width, height, filler)))
	{
	    return TRUE;
	}

	imp = imp->fallback;
    }

    return FALSE;
}

static uint32_t *
get_scanline_null (pixman_iter_t *iter, const uint32_t *mask)
{
    return NULL;
}

void
_pixman_implementation_iter_init (pixman_implementation_t *imp,
                                  pixman_iter_t           *iter,
                                  pixman_image_t          *image,
                                  int                      x,
                                  int                      y,
                                  int                      width,
                                  int                      height,
                                  uint8_t                 *buffer,
                                  iter_flags_t             iter_flags,
                                  uint32_t                 image_flags)
{
    pixman_format_code_t format;

    iter->image = image;
    iter->buffer = (uint32_t *)buffer;
    iter->x = x;
    iter->y = y;
    iter->width = width;
    iter->height = height;
    iter->iter_flags = iter_flags;
    iter->image_flags = image_flags;
    iter->fini = NULL;

    if (!iter->image)
    {
	iter->get_scanline = get_scanline_null;
	return;
    }

    format = iter->image->common.extended_format_code;

    while (imp)
    {
        if (imp->iter_info)
        {
            const pixman_iter_info_t *info;

            for (info = imp->iter_info; info->format != PIXMAN_null; ++info)
            {
                if ((info->format == PIXMAN_any || info->format == format) &&
                    (info->image_flags & image_flags) == info->image_flags &&
                    (info->iter_flags & iter_flags) == info->iter_flags)
                {
                    iter->get_scanline = info->get_scanline;
                    iter->write_back = info->write_back;

                    if (info->initializer)
                        info->initializer (iter, info);
                    return;
                }
            }
        }

        imp = imp->fallback;
    }
}

pixman_bool_t
_pixman_disabled (const char *name)
{
    const char *env;

    if ((env = getenv ("PIXMAN_DISABLE")))
    {
	do
	{
	    const char *end;
	    int len;

	    if ((end = strchr (env, ' ')))
		len = end - env;
	    else
		len = strlen (env);

	    if (strlen (name) == len && strncmp (name, env, len) == 0)
	    {
		printf ("pixman: Disabled %s implementation\n", name);
		return TRUE;
	    }

	    env += len;
	}
	while (*env++);
    }

    return FALSE;
}

static const pixman_fast_path_t empty_fast_path[] =
{
    { PIXMAN_OP_NONE }
};

pixman_implementation_t *
_pixman_choose_implementation (void)
{
    pixman_implementation_t *imp;

    imp = _pixman_implementation_create_general();

    if (!_pixman_disabled ("fast"))
	imp = _pixman_implementation_create_fast_path (imp);

    imp = _pixman_x86_get_implementations (imp);
    imp = _pixman_arm_get_implementations (imp);
    imp = _pixman_ppc_get_implementations (imp);
    imp = _pixman_mips_get_implementations (imp);

    imp = _pixman_implementation_create_noop (imp);

    if (_pixman_disabled ("wholeops"))
    {
        pixman_implementation_t *cur;

        /* Disable all whole-operation paths except the general one,
         * so that optimized iterators are used as much as possible.
         */
        for (cur = imp; cur->fallback; cur = cur->fallback)
            cur->fast_paths = empty_fast_path;
    }

    return imp;
}
@


1.9
log
@Update to pixman 0.32.4. Tested by naddy@@ and ajacoutot@@
@
text
@d383 5
d404 11
@


1.8
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@d288 2
a289 11
pixman_bool_t
_pixman_implementation_src_iter_init (pixman_implementation_t	*imp,
				      pixman_iter_t             *iter,
				      pixman_image_t		*image,
				      int			 x,
				      int			 y,
				      int			 width,
				      int			 height,
				      uint8_t			*buffer,
				      iter_flags_t		 iter_flags,
				      uint32_t                   image_flags)
d291 17
d316 1
d318 1
a318 1
    while (imp)
d320 2
a321 4
	if (imp->src_iter_init && (*imp->src_iter_init) (imp, iter))
	    return TRUE;

	imp = imp->fallback;
d324 1
a324 23
    return FALSE;
}

pixman_bool_t
_pixman_implementation_dest_iter_init (pixman_implementation_t	*imp,
				       pixman_iter_t            *iter,
				       pixman_image_t		*image,
				       int			 x,
				       int			 y,
				       int			 width,
				       int			 height,
				       uint8_t			*buffer,
				       iter_flags_t		 iter_flags,
				       uint32_t                  image_flags)
{
    iter->image = image;
    iter->buffer = (uint32_t *)buffer;
    iter->x = x;
    iter->y = y;
    iter->width = width;
    iter->height = height;
    iter->iter_flags = iter_flags;
    iter->image_flags = image_flags;
d328 19
a346 2
	if (imp->dest_iter_init && (*imp->dest_iter_init) (imp, iter))
	    return TRUE;
d348 1
a348 1
	imp = imp->fallback;
a349 2

    return FALSE;
@


1.7
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@d68 7
a74 1
pixman_bool_t
d151 12
a162 1
    return FALSE;
d180 1
d182 8
a189 1
    return TRUE;
d227 3
a229 1
    return NULL;
d272 1
a272 1
                             uint32_t                 xor)
d277 1
a277 1
	    ((*imp->fill) (imp, bits, stride, bpp, x, y, width, height, xor)))
@


1.6
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@d30 3
a32 46
static pixman_bool_t
delegate_blt (pixman_implementation_t * imp,
              uint32_t *                src_bits,
              uint32_t *                dst_bits,
              int                       src_stride,
              int                       dst_stride,
              int                       src_bpp,
              int                       dst_bpp,
              int                       src_x,
              int                       src_y,
              int                       dest_x,
              int                       dest_y,
              int                       width,
              int                       height)
{
    return _pixman_implementation_blt (
	imp->delegate, src_bits, dst_bits, src_stride, dst_stride,
	src_bpp, dst_bpp, src_x, src_y, dest_x, dest_y,
	width, height);
}

static pixman_bool_t
delegate_fill (pixman_implementation_t *imp,
               uint32_t *               bits,
               int                      stride,
               int                      bpp,
               int                      x,
               int                      y,
               int                      width,
               int                      height,
               uint32_t                 xor)
{
    return _pixman_implementation_fill (
	imp->delegate, bits, stride, bpp, x, y, width, height, xor);
}

static void
delegate_src_iter_init (pixman_implementation_t *imp,
			pixman_iter_t *	         iter)
{
    imp->delegate->src_iter_init (imp->delegate, iter);
}

static void
delegate_dest_iter_init (pixman_implementation_t *imp,
			 pixman_iter_t *	  iter)
d34 19
a52 1
    imp->delegate->dest_iter_init (imp->delegate, iter);
d55 24
a78 3
pixman_implementation_t *
_pixman_implementation_create (pixman_implementation_t *delegate,
			       const pixman_fast_path_t *fast_paths)
d80 2
a81 2
    pixman_implementation_t *imp = malloc (sizeof (pixman_implementation_t));
    pixman_implementation_t *d;
d84 2
a85 2
    if (!imp)
	return NULL;
d87 65
a151 1
    assert (fast_paths);
d153 9
a161 20
    /* Make sure the whole delegate chain has the right toplevel */
    imp->delegate = delegate;
    for (d = imp; d != NULL; d = d->delegate)
	d->toplevel = imp;

    /* Fill out function pointers with ones that just delegate
     */
    imp->blt = delegate_blt;
    imp->fill = delegate_fill;
    imp->src_iter_init = delegate_src_iter_init;
    imp->dest_iter_init = delegate_dest_iter_init;

    imp->fast_paths = fast_paths;

    for (i = 0; i < PIXMAN_N_OPERATORS; ++i)
    {
	imp->combine_32[i] = NULL;
	imp->combine_64[i] = NULL;
	imp->combine_32_ca[i] = NULL;
	imp->combine_64_ca[i] = NULL;
d164 1
a164 1
    return imp;
d173 3
a175 1
    pixman_combine_32_func_t f;
d177 1
a177 3
    do
    {
	pixman_combine_32_func_t (*combiners[]) =
d179 16
a194 5
	    (pixman_combine_32_func_t *)imp->combine_64,
	    (pixman_combine_32_func_t *)imp->combine_64_ca,
	    imp->combine_32,
	    imp->combine_32_ca,
	};
d196 2
a197 1
	f = combiners[component_alpha | (narrow << 1)][op];
d199 1
a199 1
	imp = imp->delegate;
a200 1
    while (!f);
d202 1
a202 1
    return f;
d220 14
a233 3
    return (*imp->blt) (imp, src_bits, dst_bits, src_stride, dst_stride,
			src_bpp, dst_bpp, src_x, src_y, dest_x, dest_y,
			width, height);
d247 12
a258 1
    return (*imp->fill) (imp, bits, stride, bpp, x, y, width, height, xor);
d261 1
a261 1
void
d270 2
a271 1
				      iter_flags_t		 flags)
d279 2
a280 1
    iter->flags = flags;
d282 9
a290 1
    (*imp->src_iter_init) (imp, iter);
d293 1
a293 1
void
d302 2
a303 1
				       iter_flags_t		 flags)
d311 25
a335 1
    iter->flags = flags;
d337 37
a373 1
    (*imp->dest_iter_init) (imp, iter);
@


1.5
log
@Update to pixman 0.22.4. Tested by shadchin@@, krw@@.
@
text
@a29 48
static void
delegate_combine_32 (pixman_implementation_t * imp,
                     pixman_op_t               op,
                     uint32_t *                dest,
                     const uint32_t *          src,
                     const uint32_t *          mask,
                     int                       width)
{
    _pixman_implementation_combine_32 (imp->delegate,
                                       op, dest, src, mask, width);
}

static void
delegate_combine_64 (pixman_implementation_t * imp,
                     pixman_op_t               op,
                     uint64_t *                dest,
                     const uint64_t *          src,
                     const uint64_t *          mask,
                     int                       width)
{
    _pixman_implementation_combine_64 (imp->delegate,
                                       op, dest, src, mask, width);
}

static void
delegate_combine_32_ca (pixman_implementation_t * imp,
                        pixman_op_t               op,
                        uint32_t *                dest,
                        const uint32_t *          src,
                        const uint32_t *          mask,
                        int                       width)
{
    _pixman_implementation_combine_32_ca (imp->delegate,
                                          op, dest, src, mask, width);
}

static void
delegate_combine_64_ca (pixman_implementation_t * imp,
                        pixman_op_t               op,
                        uint64_t *                dest,
                        const uint64_t *          src,
                        const uint64_t *          mask,
                        int                       width)
{
    _pixman_implementation_combine_64_ca (imp->delegate,
                                          op, dest, src, mask, width);
}

d105 2
d109 4
a112 4
	imp->combine_32[i] = delegate_combine_32;
	imp->combine_64[i] = delegate_combine_64;
	imp->combine_32_ca[i] = delegate_combine_32_ca;
	imp->combine_64_ca[i] = delegate_combine_64_ca;
a114 2
    imp->fast_paths = fast_paths;

d118 5
a122 7
void
_pixman_implementation_combine_32 (pixman_implementation_t * imp,
                                   pixman_op_t               op,
                                   uint32_t *                dest,
                                   const uint32_t *          src,
                                   const uint32_t *          mask,
                                   int                       width)
d124 11
a134 2
    (*imp->combine_32[op]) (imp, op, dest, src, mask, width);
}
d136 1
a136 10
void
_pixman_implementation_combine_64 (pixman_implementation_t * imp,
                                   pixman_op_t               op,
                                   uint64_t *                dest,
                                   const uint64_t *          src,
                                   const uint64_t *          mask,
                                   int                       width)
{
    (*imp->combine_64[op]) (imp, op, dest, src, mask, width);
}
d138 3
a140 10
void
_pixman_implementation_combine_32_ca (pixman_implementation_t * imp,
                                      pixman_op_t               op,
                                      uint32_t *                dest,
                                      const uint32_t *          src,
                                      const uint32_t *          mask,
                                      int                       width)
{
    (*imp->combine_32_ca[op]) (imp, op, dest, src, mask, width);
}
d142 1
a142 9
void
_pixman_implementation_combine_64_ca (pixman_implementation_t * imp,
                                      pixman_op_t               op,
                                      uint64_t *                dest,
                                      const uint64_t *          src,
                                      const uint64_t *          mask,
                                      int                       width)
{
    (*imp->combine_64_ca[op]) (imp, op, dest, src, mask, width);
@


1.4
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d88 2
a89 2
              int                       dst_x,
              int                       dst_y,
d95 1
a95 1
	src_bpp, dst_bpp, src_x, src_y, dst_x, dst_y,
d220 2
a221 2
                            int                       dst_x,
                            int                       dst_y,
d226 1
a226 1
			src_bpp, dst_bpp, src_x, src_y, dst_x, dst_y,
a243 6
static uint32_t *
get_scanline_null (pixman_iter_t *iter, const uint32_t *mask)
{
    return NULL;
}

d263 1
a263 13
    if (!image)
    {
	iter->get_scanline = get_scanline_null;
    }
    else if ((flags & (ITER_IGNORE_ALPHA | ITER_IGNORE_RGB)) ==
	     (ITER_IGNORE_ALPHA | ITER_IGNORE_RGB))
    {
	iter->get_scanline = _pixman_iter_get_scanline_noop;
    }
    else
    {
	(*imp->src_iter_init) (imp, iter);
    }
@


1.3
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d114 14
d150 2
d162 1
a162 1
    
d244 61
@


1.2
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@a30 24
delegate_composite (pixman_implementation_t * imp,
                    pixman_op_t               op,
                    pixman_image_t *          src,
                    pixman_image_t *          mask,
                    pixman_image_t *          dest,
                    int32_t                   src_x,
                    int32_t                   src_y,
                    int32_t                   mask_x,
                    int32_t                   mask_y,
                    int32_t                   dest_x,
                    int32_t                   dest_y,
                    int32_t                   width,
                    int32_t                   height)
{
    _pixman_implementation_composite (imp->delegate,
                                      op,
                                      src, mask, dest,
                                      src_x, src_y,
                                      mask_x, mask_y,
                                      dest_x, dest_y,
                                      width, height);
}

static void
d115 2
a116 1
_pixman_implementation_create (pixman_implementation_t *delegate)
d125 2
a133 1
    imp->composite = delegate_composite;
d137 1
a137 1
    for (i = 0; i < PIXMAN_OP_LAST; ++i)
d145 2
a191 21
}

void
_pixman_implementation_composite (pixman_implementation_t * imp,
                                  pixman_op_t               op,
                                  pixman_image_t *          src,
                                  pixman_image_t *          mask,
                                  pixman_image_t *          dest,
                                  int32_t                   src_x,
                                  int32_t                   src_y,
                                  int32_t                   mask_x,
                                  int32_t                   mask_y,
                                  int32_t                   dest_x,
                                  int32_t                   dest_y,
                                  int32_t                   width,
                                  int32_t                   height)
{
    (*imp->composite) (imp, op,
		       src, mask, dest,
		       src_x, src_y, mask_x, mask_y, dest_x, dest_y,
		       width, height);
@


1.1
log
@Update to pixman 0.15.8.
@
text
@d24 1
d26 1
d31 13
a43 13
delegate_composite (pixman_implementation_t *	imp,
		    pixman_op_t			op,
		    pixman_image_t *		src,
		    pixman_image_t *		mask,
		    pixman_image_t *		dest,
		    int32_t			src_x,
		    int32_t			src_y,
		    int32_t			mask_x,
		    int32_t			mask_y,
		    int32_t			dest_x,
		    int32_t			dest_y,
		    int32_t			width,
		    int32_t			height)
d46 6
a51 6
				      op,
				      src, mask, dest,
				      src_x, src_y,
				      mask_x, mask_y,
				      dest_x, dest_y,
				      width, height);
d55 6
a60 6
delegate_combine_32 (pixman_implementation_t *	imp,
		     pixman_op_t		op,
		     uint32_t *			dest,
		     const uint32_t *		src,
		     const uint32_t *		mask,
		     int			width)
d63 1
a63 1
				       op, dest, src, mask, width);
d67 6
a72 6
delegate_combine_64 (pixman_implementation_t *	imp,
		     pixman_op_t		op,
		     uint64_t *			dest,
		     const uint64_t *		src,
		     const uint64_t *		mask,
		     int			width)
d75 1
a75 1
				       op, dest, src, mask, width);
d79 6
a84 6
delegate_combine_32_ca (pixman_implementation_t *	imp,
			pixman_op_t			op,
			uint32_t *			dest,
			const uint32_t *		src,
			const uint32_t *		mask,
			int				width)
d87 1
a87 1
					  op, dest, src, mask, width);
d91 6
a96 6
delegate_combine_64_ca (pixman_implementation_t *	imp,
			pixman_op_t			op,
			uint64_t *			dest,
			const uint64_t *		src,
			const uint64_t *		mask,
			int				width)
d99 1
a99 1
					  op, dest, src, mask, width);
d103 18
a120 17
delegate_blt (pixman_implementation_t *	imp,
	      uint32_t *		src_bits,
	      uint32_t *		dst_bits,
	      int			src_stride,
	      int			dst_stride,
	      int			src_bpp,
	      int			dst_bpp,
	      int			src_x,
	      int			src_y,
	      int			dst_x,
	      int			dst_y,
	      int			width,
	      int			height)
{
    return _pixman_implementation_blt (imp->delegate, src_bits, dst_bits, src_stride, dst_stride,
				       src_bpp, dst_bpp, src_x, src_y, dst_x, dst_y,
				       width, height);
d125 8
a132 8
	       uint32_t *bits,
	       int stride,
	       int bpp,
	       int x,
	       int y,
	       int width,
	       int height,
	       uint32_t xor)
d134 2
a135 1
    return _pixman_implementation_fill (imp->delegate, bits, stride, bpp, x, y, width, height, xor);
d139 1
a139 2
_pixman_implementation_create (pixman_implementation_t *toplevel,
			       pixman_implementation_t *delegate)
d142 1
d144 1
a144 1
    
d147 2
a148 9
    
    if (toplevel)
	imp->toplevel = toplevel;
    else
	imp->toplevel = imp;
    
    if (delegate)
	delegate->toplevel = imp->toplevel;
    
d150 3
a152 1
    
d158 1
a158 1
    
d166 1
a166 1
    
d171 6
a176 6
_pixman_implementation_combine_32 (pixman_implementation_t *	imp,
				   pixman_op_t			op,
				   uint32_t *			dest,
				   const uint32_t *		src,
				   const uint32_t *		mask,
				   int				width)
d178 1
a178 1
    (* imp->combine_32[op]) (imp, op, dest, src, mask, width);
d182 6
a187 6
_pixman_implementation_combine_64 (pixman_implementation_t *	imp,
				   pixman_op_t			op,
				   uint64_t *			dest,
				   const uint64_t *		src,
				   const uint64_t *		mask,
				   int				width)
d189 1
a189 1
    (* imp->combine_64[op]) (imp, op, dest, src, mask, width);
d193 6
a198 6
_pixman_implementation_combine_32_ca (pixman_implementation_t *	imp,
				      pixman_op_t		op,
				      uint32_t *		dest,
				      const uint32_t *		src,
				      const uint32_t *		mask,
				      int			width)
d200 1
a200 1
    (* imp->combine_32_ca[op]) (imp, op, dest, src, mask, width);
d204 6
a209 6
_pixman_implementation_combine_64_ca (pixman_implementation_t *	imp,
				      pixman_op_t		op,
				      uint64_t *		dest,
				      const uint64_t *		src,
				      const uint64_t *		mask,
				      int			width)
d211 1
a211 1
    (* imp->combine_64_ca[op]) (imp, op, dest, src, mask, width);
d215 18
a232 18
_pixman_implementation_composite (pixman_implementation_t *	imp,
				  pixman_op_t			op,
				  pixman_image_t *		src,
				  pixman_image_t *		mask,
				  pixman_image_t *		dest,
				  int32_t			src_x,
				  int32_t			src_y,
				  int32_t			mask_x,
				  int32_t			mask_y,
				  int32_t			dest_x,
				  int32_t			dest_y,
				  int32_t			width,
				  int32_t			height)
{
    (* imp->composite) (imp, op,
			src, mask, dest,
			src_x, src_y, mask_x, mask_y, dest_x, dest_y,
			width, height);
d236 17
a252 17
_pixman_implementation_blt (pixman_implementation_t *	imp,
			    uint32_t *			src_bits,
			    uint32_t *			dst_bits,
			    int				src_stride,
			    int				dst_stride,
			    int				src_bpp,
			    int				dst_bpp,
			    int				src_x,
			    int				src_y,
			    int				dst_x,
			    int				dst_y,
			    int				width,
			    int				height)
{
    return (* imp->blt) (imp, src_bits, dst_bits, src_stride, dst_stride,
			 src_bpp, dst_bpp, src_x, src_y, dst_x, dst_y,
			 width, height);
d257 8
a264 8
			     uint32_t *bits,
			     int stride,
			     int bpp,
			     int x,
			     int y,
			     int width,
			     int height,
			     uint32_t xor)
d266 1
a266 1
    return (* imp->fill) (imp, bits, stride, bpp, x, y, width, height, xor);
d268 1
@

