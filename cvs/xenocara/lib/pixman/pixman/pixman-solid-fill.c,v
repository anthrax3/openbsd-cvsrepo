head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.18
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.16
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.14
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.12
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.10
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.8
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.06.07.17.18.01;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.11.14.13.42.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.05.20.14.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@/*
 * Copyright © 2000 SuSE, Inc.
 * Copyright © 2007, 2009 Red Hat, Inc.
 * Copyright © 2009 Soren Sandmann
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "pixman-private.h"

static uint32_t
color_to_uint32 (const pixman_color_t *color)
{
    return
        (color->alpha >> 8 << 24) |
        (color->red >> 8 << 16) |
        (color->green & 0xff00) |
        (color->blue >> 8);
}

static argb_t
color_to_float (const pixman_color_t *color)
{
    argb_t result;

    result.a = pixman_unorm_to_float (color->alpha, 16);
    result.r = pixman_unorm_to_float (color->red, 16);
    result.g = pixman_unorm_to_float (color->green, 16);
    result.b = pixman_unorm_to_float (color->blue, 16);

    return result;
}

PIXMAN_EXPORT pixman_image_t *
pixman_image_create_solid_fill (const pixman_color_t *color)
{
    pixman_image_t *img = _pixman_image_allocate ();

    if (!img)
	return NULL;

    img->type = SOLID;
    img->solid.color = *color;
    img->solid.color_32 = color_to_uint32 (color);
    img->solid.color_float = color_to_float (color);

    return img;
}

@


1.6
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@a28 25
void
_pixman_solid_fill_iter_init (pixman_image_t *image, pixman_iter_t  *iter)
{
    if (iter->iter_flags & ITER_NARROW)
    {
	uint32_t *b = (uint32_t *)iter->buffer;
	uint32_t *e = b + iter->width;
	uint32_t color = iter->image->solid.color_32;

	while (b < e)
	    *(b++) = color;
    }
    else
    {
	argb_t *b = (argb_t *)iter->buffer;
	argb_t *e = b + iter->width;
	argb_t color = image->solid.color_float;

	while (b < e)
	    *(b++) = color;
    }

    iter->get_scanline = _pixman_iter_get_scanline_noop;
}

@


1.5
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d32 1
a32 1
    if (iter->flags & ITER_NARROW)
d43 3
a45 3
	uint64_t *b = (uint64_t *)iter->buffer;
	uint64_t *e = b + iter->width;
	uint64_t color = image->solid.color_64;
d64 2
a65 2
static uint64_t
color_to_uint64 (const pixman_color_t *color)
d67 8
a74 5
    return
        ((uint64_t)color->alpha << 48) |
        ((uint64_t)color->red << 32) |
        ((uint64_t)color->green << 16) |
        ((uint64_t)color->blue);
d78 1
a78 1
pixman_image_create_solid_fill (pixman_color_t *color)
d88 1
a88 1
    img->solid.color_64 = color_to_uint64 (color);
@


1.4
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@d29 2
a30 7
static void
solid_fill_get_scanline_32 (pixman_image_t *image,
                            int             x,
                            int             y,
                            int             width,
                            uint32_t *      buffer,
                            const uint32_t *mask)
d32 18
a49 2
    uint32_t *end = buffer + width;
    uint32_t color = image->solid.color_32;
d51 1
a51 37
    while (buffer < end)
	*(buffer++) = color;

    return;
}

static void
solid_fill_get_scanline_64 (pixman_image_t *image,
			    int             x,
			    int             y,
			    int             width,
			    uint32_t *      buffer,
			    const uint32_t *mask)
{
    uint64_t *b = (uint64_t *)buffer;
    uint64_t *e = b + width;
    uint64_t color = image->solid.color_64;

    while (b < e)
	*(b++) = color;
}

static source_image_class_t
solid_fill_classify (pixman_image_t *image,
                     int             x,
                     int             y,
                     int             width,
                     int             height)
{
    return SOURCE_IMAGE_CLASS_HORIZONTAL;
}

static void
solid_fill_property_changed (pixman_image_t *image)
{
    image->common.get_scanline_32 = solid_fill_get_scanline_32;
    image->common.get_scanline_64 = solid_fill_get_scanline_64;
a85 3

    img->common.classify = solid_fill_classify;
    img->common.property_changed = solid_fill_property_changed;
@


1.3
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d35 1
a35 2
                            const uint32_t *mask,
                            uint32_t        mask_bits)
d52 1
a52 2
			    const uint32_t *mask,
			    uint32_t        mask_bits)
d69 1
a69 1
    return (image->source.class = SOURCE_IMAGE_CLASS_HORIZONTAL);
a111 1
    img->source.class = SOURCE_IMAGE_CLASS_UNKNOWN;
@


1.2
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@d39 1
a39 1
    register uint32_t color = ((solid_fill_t *)image)->color;
d47 17
d78 1
a78 1
    image->common.get_scanline_64 = _pixman_image_get_scanline_generic_64;
d91 10
d110 3
a112 1
    img->solid.color = color_to_uint32 (color);
@


1.1
log
@Update to pixman 0.15.8.
@
text
@d24 1
d26 1
d30 7
a36 2
solid_fill_get_scanline_32 (pixman_image_t *image, int x, int y, int width,
			    uint32_t *buffer, uint32_t *mask, uint32_t maskBits)
d40 1
a40 1
    
d43 1
a43 1
    
d47 1
a47 1
static source_pict_class_t
d49 4
a52 4
		     int	     x,
		     int	     y,
		     int	     width,
		     int	     height)
d60 2
a61 2
    image->common.get_scanline_32 = (scanFetchProc)solid_fill_get_scanline_32;
    image->common.get_scanline_64 = (scanFetchProc)_pixman_image_get_scanline_64_generic;
d68 2
a69 2
	(color->alpha >> 8 << 24) |
	(color->red >> 8 << 16) |
d71 1
a71 1
	(color->blue >> 8);
d77 2
a78 2
    pixman_image_t *img = _pixman_image_allocate();
    
a88 2
    solid_fill_property_changed (img);
    
d91 1
@

