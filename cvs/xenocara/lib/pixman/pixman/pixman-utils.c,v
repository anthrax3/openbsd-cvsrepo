head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.16
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.14
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.12
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.10
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.6
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v0_9_6:1.1.1.2
	xorg:1.1.1
	v0_9_5:1.1.1.1
	pixman:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2013.12.01.20.34.20;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.07.17.18.01;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.02.28.20.36.12;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.05.20.14.28;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.23.19.11.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.08.19.00.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.03.20.48.59;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.10.03.20.48.59;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.12.10.21.10.27;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to pixman 0.32.4. Tested by naddy@@ and ajacoutot@@
@
text
@/*
 * Copyright © 2000 SuSE, Inc.
 * Copyright © 1999 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdio.h>
#include <stdlib.h>

#include "pixman-private.h"

pixman_bool_t
_pixman_multiply_overflows_size (size_t a, size_t b)
{
    return a >= SIZE_MAX / b;
}

pixman_bool_t
_pixman_multiply_overflows_int (unsigned int a, unsigned int b)
{
    return a >= INT32_MAX / b;
}

pixman_bool_t
_pixman_addition_overflows_int (unsigned int a, unsigned int b)
{
    return a > INT32_MAX - b;
}

void *
pixman_malloc_ab_plus_c (unsigned int a, unsigned int b, unsigned int c)
{
    if (!b || a >= INT32_MAX / b || (a * b) > INT32_MAX - c)
	return NULL;

    return malloc (a * b + c);
}

void *
pixman_malloc_ab (unsigned int a,
                  unsigned int b)
{
    if (a >= INT32_MAX / b)
	return NULL;

    return malloc (a * b);
}

void *
pixman_malloc_abc (unsigned int a,
                   unsigned int b,
                   unsigned int c)
{
    if (a >= INT32_MAX / b)
	return NULL;
    else if (a * b >= INT32_MAX / c)
	return NULL;
    else
	return malloc (a * b * c);
}

static force_inline uint16_t
float_to_unorm (float f, int n_bits)
{
    uint32_t u;

    if (f > 1.0)
	f = 1.0;
    if (f < 0.0)
	f = 0.0;

    u = f * (1 << n_bits);
    u -= (u >> n_bits);

    return u;
}

static force_inline float
unorm_to_float (uint16_t u, int n_bits)
{
    uint32_t m = ((1 << n_bits) - 1);

    return (u & m) * (1.f / (float)m);
}

/*
 * This function expands images from a8r8g8b8 to argb_t.  To preserve
 * precision, it needs to know from which source format the a8r8g8b8 pixels
 * originally came.
 *
 * For example, if the source was PIXMAN_x1r5g5b5 and the red component
 * contained bits 12345, then the 8-bit value is 12345123.  To correctly
 * expand this to floating point, it should be 12345 / 31.0 and not
 * 12345123 / 255.0.
 */
void
pixman_expand_to_float (argb_t               *dst,
			const uint32_t       *src,
			pixman_format_code_t  format,
			int                   width)
{
    static const float multipliers[16] = {
	0.0f,
	1.0f / ((1 <<  1) - 1),
	1.0f / ((1 <<  2) - 1),
	1.0f / ((1 <<  3) - 1),
	1.0f / ((1 <<  4) - 1),
	1.0f / ((1 <<  5) - 1),
	1.0f / ((1 <<  6) - 1),
	1.0f / ((1 <<  7) - 1),
	1.0f / ((1 <<  8) - 1),
	1.0f / ((1 <<  9) - 1),
	1.0f / ((1 << 10) - 1),
	1.0f / ((1 << 11) - 1),
	1.0f / ((1 << 12) - 1),
	1.0f / ((1 << 13) - 1),
	1.0f / ((1 << 14) - 1),
	1.0f / ((1 << 15) - 1),
    };
    int a_size, r_size, g_size, b_size;
    int a_shift, r_shift, g_shift, b_shift;
    float a_mul, r_mul, g_mul, b_mul;
    uint32_t a_mask, r_mask, g_mask, b_mask;
    int i;

    if (!PIXMAN_FORMAT_VIS (format))
	format = PIXMAN_a8r8g8b8;

    /*
     * Determine the sizes of each component and the masks and shifts
     * required to extract them from the source pixel.
     */
    a_size = PIXMAN_FORMAT_A (format);
    r_size = PIXMAN_FORMAT_R (format);
    g_size = PIXMAN_FORMAT_G (format);
    b_size = PIXMAN_FORMAT_B (format);

    a_shift = 32 - a_size;
    r_shift = 24 - r_size;
    g_shift = 16 - g_size;
    b_shift =  8 - b_size;

    a_mask = ((1 << a_size) - 1);
    r_mask = ((1 << r_size) - 1);
    g_mask = ((1 << g_size) - 1);
    b_mask = ((1 << b_size) - 1);

    a_mul = multipliers[a_size];
    r_mul = multipliers[r_size];
    g_mul = multipliers[g_size];
    b_mul = multipliers[b_size];

    /* Start at the end so that we can do the expansion in place
     * when src == dst
     */
    for (i = width - 1; i >= 0; i--)
    {
	const uint32_t pixel = src[i];

	dst[i].a = a_mask? ((pixel >> a_shift) & a_mask) * a_mul : 1.0f;
	dst[i].r = ((pixel >> r_shift) & r_mask) * r_mul;
	dst[i].g = ((pixel >> g_shift) & g_mask) * g_mul;
	dst[i].b = ((pixel >> b_shift) & b_mask) * b_mul;
    }
}

uint16_t
pixman_float_to_unorm (float f, int n_bits)
{
    return float_to_unorm (f, n_bits);
}

float
pixman_unorm_to_float (uint16_t u, int n_bits)
{
    return unorm_to_float (u, n_bits);
}

void
pixman_contract_from_float (uint32_t     *dst,
			    const argb_t *src,
			    int           width)
{
    int i;

    for (i = 0; i < width; ++i)
    {
	uint8_t a, r, g, b;

	a = float_to_unorm (src[i].a, 8);
	r = float_to_unorm (src[i].r, 8);
	g = float_to_unorm (src[i].g, 8);
	b = float_to_unorm (src[i].b, 8);

	dst[i] = (a << 24) | (r << 16) | (g << 8) | (b << 0);
    }
}

uint32_t *
_pixman_iter_get_scanline_noop (pixman_iter_t *iter, const uint32_t *mask)
{
    return iter->buffer;
}

void
_pixman_iter_init_bits_stride (pixman_iter_t *iter, const pixman_iter_info_t *info)
{
    pixman_image_t *image = iter->image;
    uint8_t *b = (uint8_t *)image->bits.bits;
    int s = image->bits.rowstride * 4;

    iter->bits = b + s * iter->y + iter->x * PIXMAN_FORMAT_BPP (info->format) / 8;
    iter->stride = s;
}

#define N_TMP_BOXES (16)

pixman_bool_t
pixman_region16_copy_from_region32 (pixman_region16_t *dst,
                                    pixman_region32_t *src)
{
    int n_boxes, i;
    pixman_box32_t *boxes32;
    pixman_box16_t *boxes16;
    pixman_bool_t retval;

    boxes32 = pixman_region32_rectangles (src, &n_boxes);

    boxes16 = pixman_malloc_ab (n_boxes, sizeof (pixman_box16_t));

    if (!boxes16)
	return FALSE;

    for (i = 0; i < n_boxes; ++i)
    {
	boxes16[i].x1 = boxes32[i].x1;
	boxes16[i].y1 = boxes32[i].y1;
	boxes16[i].x2 = boxes32[i].x2;
	boxes16[i].y2 = boxes32[i].y2;
    }

    pixman_region_fini (dst);
    retval = pixman_region_init_rects (dst, boxes16, n_boxes);
    free (boxes16);
    return retval;
}

pixman_bool_t
pixman_region32_copy_from_region16 (pixman_region32_t *dst,
                                    pixman_region16_t *src)
{
    int n_boxes, i;
    pixman_box16_t *boxes16;
    pixman_box32_t *boxes32;
    pixman_box32_t tmp_boxes[N_TMP_BOXES];
    pixman_bool_t retval;

    boxes16 = pixman_region_rectangles (src, &n_boxes);

    if (n_boxes > N_TMP_BOXES)
	boxes32 = pixman_malloc_ab (n_boxes, sizeof (pixman_box32_t));
    else
	boxes32 = tmp_boxes;

    if (!boxes32)
	return FALSE;

    for (i = 0; i < n_boxes; ++i)
    {
	boxes32[i].x1 = boxes16[i].x1;
	boxes32[i].y1 = boxes16[i].y1;
	boxes32[i].x2 = boxes16[i].x2;
	boxes32[i].y2 = boxes16[i].y2;
    }

    pixman_region32_fini (dst);
    retval = pixman_region32_init_rects (dst, boxes32, n_boxes);

    if (boxes32 != tmp_boxes)
	free (boxes32);

    return retval;
}

/* This function is exported for the sake of the test suite and not part
 * of the ABI.
 */
PIXMAN_EXPORT pixman_implementation_t *
_pixman_internal_only_get_implementation (void)
{
    return get_implementation ();
}

void
_pixman_log_error (const char *function, const char *message)
{
    static int n_messages = 0;

    if (n_messages < 10)
    {
	fprintf (stderr,
		 "*** BUG ***\n"
		 "In %s: %s\n"
		 "Set a breakpoint on '_pixman_log_error' to debug\n\n",
                 function, message);

	n_messages++;
    }
}
@


1.11
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@d52 9
d224 11
@


1.10
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@a294 2
#ifdef DEBUG

a310 2

#endif
@


1.9
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@a32 112
#define N_CACHED_FAST_PATHS 8

typedef struct
{
    struct
    {
	pixman_implementation_t *	imp;
	pixman_fast_path_t		fast_path;
    } cache [N_CACHED_FAST_PATHS];
} cache_t;

PIXMAN_DEFINE_THREAD_LOCAL (cache_t, fast_path_cache);

pixman_bool_t
_pixman_lookup_composite_function (pixman_implementation_t     *toplevel,
				   pixman_op_t			op,
				   pixman_format_code_t		src_format,
				   uint32_t			src_flags,
				   pixman_format_code_t		mask_format,
				   uint32_t			mask_flags,
				   pixman_format_code_t		dest_format,
				   uint32_t			dest_flags,
				   pixman_implementation_t    **out_imp,
				   pixman_composite_func_t     *out_func)
{
    pixman_implementation_t *imp;
    cache_t *cache;
    int i;

    /* Check cache for fast paths */
    cache = PIXMAN_GET_THREAD_LOCAL (fast_path_cache);

    for (i = 0; i < N_CACHED_FAST_PATHS; ++i)
    {
	const pixman_fast_path_t *info = &(cache->cache[i].fast_path);

	/* Note that we check for equality here, not whether
	 * the cached fast path matches. This is to prevent
	 * us from selecting an overly general fast path
	 * when a more specific one would work.
	 */
	if (info->op == op			&&
	    info->src_format == src_format	&&
	    info->mask_format == mask_format	&&
	    info->dest_format == dest_format	&&
	    info->src_flags == src_flags	&&
	    info->mask_flags == mask_flags	&&
	    info->dest_flags == dest_flags	&&
	    info->func)
	{
	    *out_imp = cache->cache[i].imp;
	    *out_func = cache->cache[i].fast_path.func;

	    goto update_cache;
	}
    }

    for (imp = toplevel; imp != NULL; imp = imp->delegate)
    {
	const pixman_fast_path_t *info = imp->fast_paths;

	while (info->op != PIXMAN_OP_NONE)
	{
	    if ((info->op == op || info->op == PIXMAN_OP_any)		&&
		/* Formats */
		((info->src_format == src_format) ||
		 (info->src_format == PIXMAN_any))			&&
		((info->mask_format == mask_format) ||
		 (info->mask_format == PIXMAN_any))			&&
		((info->dest_format == dest_format) ||
		 (info->dest_format == PIXMAN_any))			&&
		/* Flags */
		(info->src_flags & src_flags) == info->src_flags	&&
		(info->mask_flags & mask_flags) == info->mask_flags	&&
		(info->dest_flags & dest_flags) == info->dest_flags)
	    {
		*out_imp = imp;
		*out_func = info->func;

		/* Set i to the last spot in the cache so that the
		 * move-to-front code below will work
		 */
		i = N_CACHED_FAST_PATHS - 1;

		goto update_cache;
	    }

	    ++info;
	}
    }
    return FALSE;

update_cache:
    if (i)
    {
	while (i--)
	    cache->cache[i + 1] = cache->cache[i];

	cache->cache[0].imp = *out_imp;
	cache->cache[0].fast_path.op = op;
	cache->cache[0].fast_path.src_format = src_format;
	cache->cache[0].fast_path.src_flags = src_flags;
	cache->cache[0].fast_path.mask_format = mask_format;
	cache->cache[0].fast_path.mask_flags = mask_flags;
	cache->cache[0].fast_path.dest_format = dest_format;
	cache->cache[0].fast_path.dest_flags = dest_flags;
	cache->cache[0].fast_path.func = *out_func;
    }

    return TRUE;
}

d74 24
d99 8
a106 5
 * This function expands images from ARGB8 format to ARGB16.  To preserve
 * precision, it needs to know the original source format.  For example, if the
 * source was PIXMAN_x1r5g5b5 and the red component contained bits 12345, then
 * the expanded value is 12345123.  To correctly expand this to 16 bits, it
 * should be 1234512345123451 and not 1234512312345123.
d109 32
a140 5
pixman_expand (uint64_t *           dst,
               const uint32_t *     src,
               pixman_format_code_t format,
               int                  width)
{
d145 19
a163 13
    const int a_size = PIXMAN_FORMAT_A (format),
              r_size = PIXMAN_FORMAT_R (format),
              g_size = PIXMAN_FORMAT_G (format),
              b_size = PIXMAN_FORMAT_B (format);
    const int a_shift = 32 - a_size,
              r_shift = 24 - r_size,
              g_shift = 16 - g_size,
              b_shift =  8 - b_size;
    const uint8_t a_mask = ~(~0 << a_size),
                  r_mask = ~(~0 << r_size),
                  g_mask = ~(~0 << g_size),
                  b_mask = ~(~0 << b_size);
    int i;
a170 2
	uint8_t a, r, g, b;
	uint64_t a16, r16, g16, b16;
d172 4
a175 25
	if (a_size)
	{
	    a = (pixel >> a_shift) & a_mask;
	    a16 = unorm_to_unorm (a, a_size, 16);
	}
	else
	{
	    a16 = 0xffff;
	}

	if (r_size)
	{
	    r = (pixel >> r_shift) & r_mask;
	    g = (pixel >> g_shift) & g_mask;
	    b = (pixel >> b_shift) & b_mask;
	    r16 = unorm_to_unorm (r, r_size, 16);
	    g16 = unorm_to_unorm (g, g_size, 16);
	    b16 = unorm_to_unorm (b, b_size, 16);
	}
	else
	{
	    r16 = g16 = b16 = 0;
	}
	
	dst[i] = a16 << 48 | r16 << 32 | g16 << 16 | b16;
d179 12
a190 4
/*
 * Contracting is easier than expanding.  We just need to truncate the
 * components.
 */
d192 3
a194 3
pixman_contract (uint32_t *      dst,
                 const uint64_t *src,
                 int             width)
d198 1
a198 4
    /* Start at the beginning so that we can do the contraction in
     * place when src == dst
     */
    for (i = 0; i < width; i++)
d200 1
a200 4
	const uint8_t a = src[i] >> 56,
	              r = src[i] >> 40,
	              g = src[i] >> 24,
	              b = src[i] >> 8;
d202 6
a207 1
	dst[i] = a << 24 | r << 16 | g << 8 | b;
d284 9
@


1.8
log
@Update to pixman 0.22.4. Tested by shadchin@@, krw@@.
@
text
@d223 20
a242 8
	const uint8_t a = (pixel >> a_shift) & a_mask,
	              r = (pixel >> r_shift) & r_mask,
	              g = (pixel >> g_shift) & g_mask,
	              b = (pixel >> b_shift) & b_mask;
	const uint64_t
	    a16 = a_size ? unorm_to_unorm (a, a_size, 16) : 0xffff,
	    r16 = unorm_to_unorm (r, r_size, 16),
	    g16 = unorm_to_unorm (g, g_size, 16),
d244 6
a249 1

@


1.7
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d33 112
d146 7
a152 2
pixman_multiply_overflows_int (unsigned int a,
                               unsigned int b)
d158 1
a158 2
pixman_addition_overflows_int (unsigned int a,
                               unsigned int b)
a186 25
 * Helper routine to expand a color component from 0 < n <= 8 bits to 16
 * bits by replication.
 */
static inline uint64_t
expand16 (const uint8_t val, int nbits)
{
    /* Start out with the high bit of val in the high bit of result. */
    uint16_t result = (uint16_t)val << (16 - nbits);

    if (nbits == 0)
	return 0;

    /* Copy the bits in result, doubling the number of bits each time, until
     * we fill all 16 bits.
     */
    while (nbits < 16)
    {
	result |= result >> nbits;
	nbits *= 2;
    }

    return result;
}

/*
d227 5
a231 4
	const uint64_t a16 = a_size ? expand16 (a, a_size) : 0xffff,
	               r16 = expand16 (r, r_size),
	               g16 = expand16 (g, g_size),
	               b16 = expand16 (b, b_size);
@


1.6
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d170 6
@


1.5
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@a32 205
/*
 * Computing composite region
 */
#define BOUND(v)        (int16_t) ((v) < INT16_MIN ? INT16_MIN : (v) > INT16_MAX ? INT16_MAX : (v))

static inline pixman_bool_t
clip_general_image (pixman_region32_t * region,
                    pixman_region32_t * clip,
                    int                 dx,
                    int                 dy)
{
    if (pixman_region32_n_rects (region) == 1 &&
        pixman_region32_n_rects (clip) == 1)
    {
	pixman_box32_t *  rbox = pixman_region32_rectangles (region, NULL);
	pixman_box32_t *  cbox = pixman_region32_rectangles (clip, NULL);
	int v;

	if (rbox->x1 < (v = cbox->x1 + dx))
	    rbox->x1 = BOUND (v);
	if (rbox->x2 > (v = cbox->x2 + dx))
	    rbox->x2 = BOUND (v);
	if (rbox->y1 < (v = cbox->y1 + dy))
	    rbox->y1 = BOUND (v);
	if (rbox->y2 > (v = cbox->y2 + dy))
	    rbox->y2 = BOUND (v);
	if (rbox->x1 >= rbox->x2 ||
	    rbox->y1 >= rbox->y2)
	{
	    pixman_region32_init (region);
	}
    }
    else if (!pixman_region32_not_empty (clip))
    {
	return FALSE;
    }
    else
    {
	if (dx || dy)
	    pixman_region32_translate (region, -dx, -dy);
	if (!pixman_region32_intersect (region, region, clip))
	    return FALSE;
	if (dx || dy)
	    pixman_region32_translate (region, dx, dy);
    }
    return pixman_region32_not_empty (region);
}

static inline pixman_bool_t
clip_source_image (pixman_region32_t * region,
                   pixman_image_t *    image,
                   int                 dx,
                   int                 dy)
{
    /* Source clips are ignored, unless they are explicitly turned on
     * and the clip in question was set by an X client. (Because if
     * the clip was not set by a client, then it is a hierarchy
     * clip and those should always be ignored for sources).
     */
    if (!image->common.clip_sources || !image->common.client_clip)
	return TRUE;

    return clip_general_image (region,
                               &image->common.clip_region,
                               dx, dy);
}

/*
 * returns FALSE if the final region is empty.  Indistinguishable from
 * an allocation failure, but rendering ignores those anyways.
 */
static pixman_bool_t
pixman_compute_composite_region32 (pixman_region32_t * region,
                                   pixman_image_t *    src_image,
                                   pixman_image_t *    mask_image,
                                   pixman_image_t *    dst_image,
                                   int16_t             src_x,
                                   int16_t             src_y,
                                   int16_t             mask_x,
                                   int16_t             mask_y,
                                   int16_t             dest_x,
                                   int16_t             dest_y,
                                   uint16_t            width,
                                   uint16_t            height)
{
    int v;

    region->extents.x1 = dest_x;
    v = dest_x + width;
    region->extents.x2 = BOUND (v);
    region->extents.y1 = dest_y;
    v = dest_y + height;
    region->extents.y2 = BOUND (v);

    region->extents.x1 = MAX (region->extents.x1, 0);
    region->extents.y1 = MAX (region->extents.y1, 0);
    region->extents.x2 = MIN (region->extents.x2, dst_image->bits.width);
    region->extents.y2 = MIN (region->extents.y2, dst_image->bits.height);

    region->data = 0;

    /* Check for empty operation */
    if (region->extents.x1 >= region->extents.x2 ||
        region->extents.y1 >= region->extents.y2)
    {
	pixman_region32_init (region);
	return FALSE;
    }

    if (dst_image->common.have_clip_region)
    {
	if (!clip_general_image (region, &dst_image->common.clip_region, 0, 0))
	{
	    pixman_region32_fini (region);
	    return FALSE;
	}
    }

    if (dst_image->common.alpha_map && dst_image->common.alpha_map->common.have_clip_region)
    {
	if (!clip_general_image (region, &dst_image->common.alpha_map->common.clip_region,
	                         -dst_image->common.alpha_origin_x,
	                         -dst_image->common.alpha_origin_y))
	{
	    pixman_region32_fini (region);
	    return FALSE;
	}
    }

    /* clip against src */
    if (src_image->common.have_clip_region)
    {
	if (!clip_source_image (region, src_image, dest_x - src_x, dest_y - src_y))
	{
	    pixman_region32_fini (region);
	    return FALSE;
	}
    }
    if (src_image->common.alpha_map && src_image->common.alpha_map->common.have_clip_region)
    {
	if (!clip_source_image (region, (pixman_image_t *)src_image->common.alpha_map,
	                        dest_x - (src_x - src_image->common.alpha_origin_x),
	                        dest_y - (src_y - src_image->common.alpha_origin_y)))
	{
	    pixman_region32_fini (region);
	    return FALSE;
	}
    }
    /* clip against mask */
    if (mask_image && mask_image->common.have_clip_region)
    {
	if (!clip_source_image (region, mask_image, dest_x - mask_x, dest_y - mask_y))
	{
	    pixman_region32_fini (region);
	    return FALSE;
	}
	if (mask_image->common.alpha_map && mask_image->common.alpha_map->common.have_clip_region)
	{
	    if (!clip_source_image (region, (pixman_image_t *)mask_image->common.alpha_map,
	                            dest_x - (mask_x - mask_image->common.alpha_origin_x),
	                            dest_y - (mask_y - mask_image->common.alpha_origin_y)))
	    {
		pixman_region32_fini (region);
		return FALSE;
	    }
	}
    }

    return TRUE;
}

PIXMAN_EXPORT pixman_bool_t
pixman_compute_composite_region (pixman_region16_t * region,
                                 pixman_image_t *    src_image,
                                 pixman_image_t *    mask_image,
                                 pixman_image_t *    dst_image,
                                 int16_t             src_x,
                                 int16_t             src_y,
                                 int16_t             mask_x,
                                 int16_t             mask_y,
                                 int16_t             dest_x,
                                 int16_t             dest_y,
                                 uint16_t            width,
                                 uint16_t            height)
{
    pixman_region32_t r32;
    pixman_bool_t retval;

    pixman_region32_init (&r32);

    retval = pixman_compute_composite_region32 (
	&r32, src_image, mask_image, dst_image,
	src_x, src_y, mask_x, mask_y, dest_x, dest_y,
	width, height);

    if (retval)
    {
	if (!pixman_region16_copy_from_region32 (region, &r32))
	    retval = FALSE;
    }

    pixman_region32_fini (&r32);
    return retval;
}

a169 395
static void
walk_region_internal (pixman_implementation_t *imp,
                      pixman_op_t              op,
                      pixman_image_t *         src_image,
                      pixman_image_t *         mask_image,
                      pixman_image_t *         dst_image,
                      int16_t                  src_x,
                      int16_t                  src_y,
                      int16_t                  mask_x,
                      int16_t                  mask_y,
                      int16_t                  dest_x,
                      int16_t                  dest_y,
                      uint16_t                 width,
                      uint16_t                 height,
                      pixman_bool_t            src_repeat,
                      pixman_bool_t            mask_repeat,
                      pixman_region32_t *      region,
                      pixman_composite_func_t  composite_rect)
{
    int n;
    const pixman_box32_t *pbox;
    int w, h, w_this, h_this;
    int x_msk, y_msk, x_src, y_src, x_dst, y_dst;

    pbox = pixman_region32_rectangles (region, &n);
    while (n--)
    {
	h = pbox->y2 - pbox->y1;
	y_src = pbox->y1 - dest_y + src_y;
	y_msk = pbox->y1 - dest_y + mask_y;
	y_dst = pbox->y1;

	while (h)
	{
	    h_this = h;
	    w = pbox->x2 - pbox->x1;
	    x_src = pbox->x1 - dest_x + src_x;
	    x_msk = pbox->x1 - dest_x + mask_x;
	    x_dst = pbox->x1;

	    if (mask_repeat)
	    {
		y_msk = MOD (y_msk, mask_image->bits.height);
		if (h_this > mask_image->bits.height - y_msk)
		    h_this = mask_image->bits.height - y_msk;
	    }

	    if (src_repeat)
	    {
		y_src = MOD (y_src, src_image->bits.height);
		if (h_this > src_image->bits.height - y_src)
		    h_this = src_image->bits.height - y_src;
	    }

	    while (w)
	    {
		w_this = w;

		if (mask_repeat)
		{
		    x_msk = MOD (x_msk, mask_image->bits.width);
		    if (w_this > mask_image->bits.width - x_msk)
			w_this = mask_image->bits.width - x_msk;
		}

		if (src_repeat)
		{
		    x_src = MOD (x_src, src_image->bits.width);
		    if (w_this > src_image->bits.width - x_src)
			w_this = src_image->bits.width - x_src;
		}

		(*composite_rect) (imp, op,
				   src_image, mask_image, dst_image,
				   x_src, y_src, x_msk, y_msk, x_dst, y_dst,
				   w_this, h_this);
		w -= w_this;

		x_src += w_this;
		x_msk += w_this;
		x_dst += w_this;
	    }

	    h -= h_this;
	    y_src += h_this;
	    y_msk += h_this;
	    y_dst += h_this;
	}

	pbox++;
    }
}

void
_pixman_walk_composite_region (pixman_implementation_t *imp,
                               pixman_op_t              op,
                               pixman_image_t *         src_image,
                               pixman_image_t *         mask_image,
                               pixman_image_t *         dst_image,
                               int16_t                  src_x,
                               int16_t                  src_y,
                               int16_t                  mask_x,
                               int16_t                  mask_y,
                               int16_t                  dest_x,
                               int16_t                  dest_y,
                               uint16_t                 width,
                               uint16_t                 height,
                               pixman_composite_func_t  composite_rect)
{
    pixman_region32_t region;

    pixman_region32_init (&region);

    if (pixman_compute_composite_region32 (
            &region, src_image, mask_image, dst_image,
            src_x, src_y, mask_x, mask_y, dest_x, dest_y,
            width, height))
    {
	walk_region_internal (imp, op,
	                      src_image, mask_image, dst_image,
	                      src_x, src_y, mask_x, mask_y, dest_x, dest_y,
	                      width, height, FALSE, FALSE,
	                      &region,
	                      composite_rect);

	pixman_region32_fini (&region);
    }
}

static pixman_bool_t
mask_is_solid (pixman_image_t *mask)
{
    if (mask->type == SOLID)
	return TRUE;

    if (mask->type == BITS &&
        mask->common.repeat == PIXMAN_REPEAT_NORMAL &&
        mask->bits.width == 1 &&
        mask->bits.height == 1)
    {
	return TRUE;
    }

    return FALSE;
}

static const pixman_fast_path_t *
get_fast_path (const pixman_fast_path_t *fast_paths,
               pixman_op_t               op,
               pixman_image_t *          src_image,
               pixman_image_t *          mask_image,
               pixman_image_t *          dst_image,
               pixman_bool_t             is_pixbuf)
{
    const pixman_fast_path_t *info;

    for (info = fast_paths; info->op != PIXMAN_OP_NONE; info++)
    {
	pixman_bool_t valid_src = FALSE;
	pixman_bool_t valid_mask = FALSE;

	if (info->op != op)
	    continue;

	if ((info->src_format == PIXMAN_solid &&
	     _pixman_image_is_solid (src_image)) ||
	    (src_image->type == BITS &&
	     info->src_format == src_image->bits.format))
	{
	    valid_src = TRUE;
	}

	if (!valid_src)
	    continue;

	if ((info->mask_format == PIXMAN_null && !mask_image) ||
	    (mask_image && mask_image->type == BITS &&
	     info->mask_format == mask_image->bits.format))
	{
	    valid_mask = TRUE;

	    if (info->flags & NEED_SOLID_MASK)
	    {
		if (!mask_image || !mask_is_solid (mask_image))
		    valid_mask = FALSE;
	    }

	    if (info->flags & NEED_COMPONENT_ALPHA)
	    {
		if (!mask_image || !mask_image->common.component_alpha)
		    valid_mask = FALSE;
	    }
	}

	if (!valid_mask)
	    continue;

	if (info->dest_format != dst_image->bits.format)
	    continue;

	if ((info->flags & NEED_PIXBUF) && !is_pixbuf)
	    continue;

	return info;
    }

    return NULL;
}

static force_inline pixman_bool_t
image_covers (pixman_image_t *image,
              pixman_box32_t *extents,
              int             x,
              int             y)
{
    if (image->common.type == BITS &&
	image->common.repeat == PIXMAN_REPEAT_NONE)
    {
	if (x > extents->x1 || y > extents->y1 ||
	    x + image->bits.width < extents->x2 ||
	    y + image->bits.height < extents->y2)
	{
	    return FALSE;
	}
    }

    return TRUE;
}

static force_inline pixman_bool_t
sources_cover (pixman_image_t *src,
	       pixman_image_t *mask,
	       pixman_box32_t *extents,
	       int             src_x,
	       int             src_y,
	       int             mask_x,
	       int             mask_y,
	       int             dest_x,
	       int             dest_y)
{
    if (!image_covers (src, extents, dest_x - src_x, dest_y - src_y))
	return FALSE;

    if (!mask)
	return TRUE;
    
    if (!image_covers (mask, extents, dest_x - mask_x, dest_y - mask_y))
	return FALSE;

    return TRUE;
}

pixman_bool_t
_pixman_run_fast_path (const pixman_fast_path_t *paths,
                       pixman_implementation_t * imp,
                       pixman_op_t               op,
                       pixman_image_t *          src,
                       pixman_image_t *          mask,
                       pixman_image_t *          dest,
                       int32_t                   src_x,
                       int32_t                   src_y,
                       int32_t                   mask_x,
                       int32_t                   mask_y,
                       int32_t                   dest_x,
                       int32_t                   dest_y,
                       int32_t                   width,
                       int32_t                   height)
{
    pixman_composite_func_t func = NULL;
    pixman_bool_t src_repeat =
	src->common.repeat == PIXMAN_REPEAT_NORMAL;
    pixman_bool_t mask_repeat =
	mask && mask->common.repeat == PIXMAN_REPEAT_NORMAL;
    pixman_bool_t result;
    pixman_bool_t has_fast_path;

    has_fast_path = !dest->common.alpha_map &&
		    !dest->bits.read_func &&
		    !dest->bits.write_func;

    if (has_fast_path)
    {
	has_fast_path = (src->type == BITS || _pixman_image_is_solid (src)) &&
	                !src->common.transform &&
	                !src->common.alpha_map &&
			src->common.filter != PIXMAN_FILTER_CONVOLUTION &&
			src->common.repeat != PIXMAN_REPEAT_PAD &&
			src->common.repeat != PIXMAN_REPEAT_REFLECT;
	if (has_fast_path && src->type == BITS)
	{
	    has_fast_path = !src->bits.read_func &&
	                    !src->bits.write_func &&
		            !PIXMAN_FORMAT_IS_WIDE (src->bits.format);
	}
    }

    if (mask && has_fast_path)
    {
	has_fast_path =
	    mask->type == BITS &&
	    !mask->common.transform &&
	    !mask->common.alpha_map &&
	    !mask->bits.read_func &&
	    !mask->bits.write_func &&
	    mask->common.filter != PIXMAN_FILTER_CONVOLUTION &&
	    mask->common.repeat != PIXMAN_REPEAT_PAD &&
	    mask->common.repeat != PIXMAN_REPEAT_REFLECT &&
	    !PIXMAN_FORMAT_IS_WIDE (mask->bits.format);
    }

    if (has_fast_path)
    {
	const pixman_fast_path_t *info;
	pixman_bool_t pixbuf;

	pixbuf =
	    src && src->type == BITS            &&
	    mask && mask->type == BITS          &&
	    src->bits.bits == mask->bits.bits   &&
	    src_x == mask_x                     &&
	    src_y == mask_y                     &&
	    !mask->common.component_alpha       &&
	    !mask_repeat;

	info = get_fast_path (paths, op, src, mask, dest, pixbuf);

	if (info)
	{
	    func = info->func;

	    if (info->src_format == PIXMAN_solid)
		src_repeat = FALSE;

	    if (info->mask_format == PIXMAN_solid ||
		info->flags & NEED_SOLID_MASK)
	    {
		mask_repeat = FALSE;
	    }

	    if ((src_repeat                     &&
	         src->bits.width == 1           &&
	         src->bits.height == 1) ||
	        (mask_repeat                    &&
	         mask->bits.width == 1          &&
	         mask->bits.height == 1))
	    {
		/* If src or mask are repeating 1x1 images and src_repeat or
		 * mask_repeat are still TRUE, it means the fast path we
		 * selected does not actually handle repeating images.
		 *
		 * So rather than call the "fast path" with a zillion
		 * 1x1 requests, we just fall back to the general code (which
		 * does do something sensible with 1x1 repeating images).
		 */
		func = NULL;
	    }
	}
    }

    result = FALSE;

    if (func)
    {
	pixman_region32_t region;
	pixman_region32_init (&region);

	if (pixman_compute_composite_region32 (
	        &region, src, mask, dest,
	        src_x, src_y, mask_x, mask_y, dest_x, dest_y, width, height))
	{
	    pixman_box32_t *extents = pixman_region32_extents (&region);

	    if (sources_cover (
		    src, mask, extents,
		    src_x, src_y, mask_x, mask_y, dest_x, dest_y))
	    {
		walk_region_internal (imp, op,
		                      src, mask, dest,
		                      src_x, src_y, mask_x, mask_y,
		                      dest_x, dest_y,
		                      width, height,
		                      src_repeat, mask_repeat,
		                      &region,
		                      func);

		result = TRUE;
	    }

	    pixman_region32_fini (&region);
	}
    }

    return result;
}

d238 21
@


1.4
log
@Update to pixman 0.15.8.
@
text
@d3 1
d28 1
a28 1

d34 1
a34 2
 * Compute the smallest value no less than y which is on a
 * grid row
d36 1
d38 23
a60 10
PIXMAN_EXPORT pixman_fixed_t
pixman_sample_ceil_y (pixman_fixed_t y, int n)
{
    pixman_fixed_t   f = pixman_fixed_frac(y);
    pixman_fixed_t   i = pixman_fixed_floor(y);

    f = ((f + Y_FRAC_FIRST(n)) / STEP_Y_SMALL(n)) * STEP_Y_SMALL(n) + Y_FRAC_FIRST(n);
    if (f > Y_FRAC_LAST(n))
    {
	if (pixman_fixed_to_int(i) == 0x7fff)
d62 1
a62 4
	    f = 0xffff; /* saturate */
	} else {
	    f = Y_FRAC_FIRST(n);
	    i += pixman_fixed_1;
d65 33
a97 1
    return (i | f);
a99 2
#define _div(a,b)    ((a) >= 0 ? (a) / (b) : -((-(a) + (b) - 1) / (b)))

d101 2
a102 2
 * Compute the largest value no greater than y which is on a
 * grid row
d104 37
a140 5
PIXMAN_EXPORT pixman_fixed_t
pixman_sample_floor_y (pixman_fixed_t y, int n)
{
    pixman_fixed_t   f = pixman_fixed_frac(y);
    pixman_fixed_t   i = pixman_fixed_floor (y);
d142 1
a142 2
    f = _div(f - Y_FRAC_FIRST(n), STEP_Y_SMALL(n)) * STEP_Y_SMALL(n) + Y_FRAC_FIRST(n);
    if (f < Y_FRAC_FIRST(n))
d144 1
a144 1
	if (pixman_fixed_to_int(i) == 0x8000)
d146 2
a147 4
	    f = 0; /* saturate */
	} else {
	    f = Y_FRAC_LAST(n);
	    i -= pixman_fixed_1;
a149 2
    return (i | f);
}
d151 10
a160 9
/*
 * Step an edge by any amount (including negative values)
 */
PIXMAN_EXPORT void
pixman_edge_step (pixman_edge_t *e, int n)
{
    pixman_fixed_48_16_t	ne;

    e->x += n * e->stepx;
d162 2
a163 3
    ne = e->e + n * (pixman_fixed_48_16_t) e->dx;

    if (n >= 0)
d165 1
a165 1
	if (ne > 0)
d167 2
a168 3
	    int nx = (ne + e->dy - 1) / e->dy;
	    e->e = ne - nx * (pixman_fixed_48_16_t) e->dy;
	    e->x += nx * e->signdx;
d171 1
a171 1
    else
d173 3
a175 1
	if (ne <= -e->dy)
d177 2
a178 3
	    int nx = (-ne) / e->dy;
	    e->e = ne + nx * (pixman_fixed_48_16_t) e->dy;
	    e->x -= nx * e->signdx;
d181 2
a182 15
}

/*
 * A private routine to initialize the multi-step
 * elements of an edge structure
 */
static void
_pixman_edge_multi_init (pixman_edge_t *e, int n, pixman_fixed_t *stepx_p, pixman_fixed_t *dx_p)
{
    pixman_fixed_t	stepx;
    pixman_fixed_48_16_t	ne;

    ne = n * (pixman_fixed_48_16_t) e->dx;
    stepx = n * e->stepx;
    if (ne > 0)
d184 15
a198 3
	int nx = ne / e->dy;
	ne -= nx * e->dy;
	stepx += nx * e->signdx;
a199 3
    *dx_p = ne;
    *stepx_p = stepx;
}
d201 1
a201 42
/*
 * Initialize one edge structure given the line endpoints and a
 * starting y value
 */
PIXMAN_EXPORT void
pixman_edge_init (pixman_edge_t	*e,
		  int		n,
		  pixman_fixed_t		y_start,
		  pixman_fixed_t		x_top,
		  pixman_fixed_t		y_top,
		  pixman_fixed_t		x_bot,
		  pixman_fixed_t		y_bot)
{
    pixman_fixed_t	dx, dy;

    e->x = x_top;
    e->e = 0;
    dx = x_bot - x_top;
    dy = y_bot - y_top;
    e->dy = dy;
    e->dx = 0;
    if (dy)
    {
	if (dx >= 0)
	{
	    e->signdx = 1;
	    e->stepx = dx / dy;
	    e->dx = dx % dy;
	    e->e = -dy;
	}
	else
	{
	    e->signdx = -1;
	    e->stepx = -(-dx / dy);
	    e->dx = -dx % dy;
	    e->e = 0;
	}

	_pixman_edge_multi_init (e, STEP_Y_SMALL(n), &e->stepx_small, &e->dx_small);
	_pixman_edge_multi_init (e, STEP_Y_BIG(n), &e->stepx_big, &e->dx_big);
    }
    pixman_edge_step (e, y_start - y_top);
d204 23
a226 15
/*
 * Initialize one edge structure given a line, starting y value
 * and a pixel offset for the line
 */
PIXMAN_EXPORT void
pixman_line_fixed_edge_init (pixman_edge_t *e,
			     int	    n,
			     pixman_fixed_t	    y,
			     const pixman_line_fixed_t *line,
			     int	    x_off,
			     int	    y_off)
{
    pixman_fixed_t	x_off_fixed = pixman_int_to_fixed(x_off);
    pixman_fixed_t	y_off_fixed = pixman_int_to_fixed(y_off);
    const pixman_point_fixed_t *top, *bot;
d228 1
a228 1
    if (line->p1.y <= line->p2.y)
d230 2
a231 2
	top = &line->p1;
	bot = &line->p2;
d233 3
a235 10
    else
    {
	top = &line->p2;
	bot = &line->p1;
    }
    pixman_edge_init (e, n, y,
		    top->x + x_off_fixed,
		    top->y + y_off_fixed,
		    bot->x + x_off_fixed,
		    bot->y + y_off_fixed);
d240 1
a240 1
		               unsigned int b)
d247 1
a247 1
		               unsigned int b)
d253 2
a254 2
pixman_malloc_ab(unsigned int a,
		 unsigned int b)
d264 2
a265 2
		   unsigned int b,
		   unsigned int c)
d275 6
a280 22

/**
 * pixman_version:
 *
 * Returns the version of the pixman library encoded in a single
 * integer as per %PIXMAN_VERSION_ENCODE. The encoding ensures that
 * later versions compare greater than earlier versions.
 *
 * A run-time comparison to check that pixman's version is greater than
 * or equal to version X.Y.Z could be performed as follows:
 *
 * <informalexample><programlisting>
 * if (pixman_version() >= PIXMAN_VERSION_ENCODE(X,Y,Z)) {...}
 * </programlisting></informalexample>
 *
 * See also pixman_version_string() as well as the compile-time
 * equivalents %PIXMAN_VERSION and %PIXMAN_VERSION_STRING.
 *
 * Return value: the encoded version.
 **/
PIXMAN_EXPORT int
pixman_version (void)
d282 2
a283 2
    return PIXMAN_VERSION;
}
d285 2
a286 16
/**
 * pixman_version_string:
 *
 * Returns the version of the pixman library as a human-readable string
 * of the form "X.Y.Z".
 *
 * See also pixman_version() as well as the compile-time equivalents
 * %PIXMAN_VERSION_STRING and %PIXMAN_VERSION.
 *
 * Return value: a string containing the version.
 **/
PIXMAN_EXPORT const char*
pixman_version_string (void)
{
    return PIXMAN_VERSION_STRING;
}
d288 7
a294 70
/**
 * pixman_format_supported_destination:
 * @@format: A pixman_format_code_t format
 * 
 * Return value: whether the provided format code is a supported
 * format for a pixman surface used as a destination in
 * rendering.
 *
 * Currently, all pixman_format_code_t values are supported
 * except for the YUV formats.
 **/
PIXMAN_EXPORT pixman_bool_t
pixman_format_supported_destination (pixman_format_code_t format)
{
    switch (format) {
    /* 32 bpp formats */
    case PIXMAN_a2b10g10r10:
    case PIXMAN_x2b10g10r10:
    case PIXMAN_a8r8g8b8:
    case PIXMAN_x8r8g8b8:
    case PIXMAN_a8b8g8r8:
    case PIXMAN_x8b8g8r8:
    case PIXMAN_b8g8r8a8:
    case PIXMAN_b8g8r8x8:
    case PIXMAN_r8g8b8:
    case PIXMAN_b8g8r8:
    case PIXMAN_r5g6b5:
    case PIXMAN_b5g6r5:
    /* 16 bpp formats */
    case PIXMAN_a1r5g5b5:
    case PIXMAN_x1r5g5b5:
    case PIXMAN_a1b5g5r5:
    case PIXMAN_x1b5g5r5:
    case PIXMAN_a4r4g4b4:
    case PIXMAN_x4r4g4b4:
    case PIXMAN_a4b4g4r4:
    case PIXMAN_x4b4g4r4:
    /* 8bpp formats */
    case PIXMAN_a8:
    case PIXMAN_r3g3b2:
    case PIXMAN_b2g3r3:
    case PIXMAN_a2r2g2b2:
    case PIXMAN_a2b2g2r2:
    case PIXMAN_c8:
    case PIXMAN_g8:
    case PIXMAN_x4a4:
    /* Collides with PIXMAN_c8
    case PIXMAN_x4c4:
    */
    /* Collides with PIXMAN_g8
    case PIXMAN_x4g4:
    */
    /* 4bpp formats */
    case PIXMAN_a4:
    case PIXMAN_r1g2b1:
    case PIXMAN_b1g2r1:
    case PIXMAN_a1r1g1b1:
    case PIXMAN_a1b1g1r1:
    case PIXMAN_c4:
    case PIXMAN_g4:
    /* 1bpp formats */
    case PIXMAN_a1:
    case PIXMAN_g1:
	return TRUE;
	
    /* YUV formats */
    case PIXMAN_yuy2:
    case PIXMAN_yv12:
    default:
	return FALSE;
d296 2
d300 45
a344 66
/**
 * pixman_format_supported_source:
 * @@format: A pixman_format_code_t format
 * 
 * Return value: whether the provided format code is a supported
 * format for a pixman surface used as a source in
 * rendering.
 *
 * Currently, all pixman_format_code_t values are supported.
 **/
PIXMAN_EXPORT pixman_bool_t
pixman_format_supported_source (pixman_format_code_t format)
{
    switch (format) {
    /* 32 bpp formats */
    case PIXMAN_a2b10g10r10:
    case PIXMAN_x2b10g10r10:
    case PIXMAN_a8r8g8b8:
    case PIXMAN_x8r8g8b8:
    case PIXMAN_a8b8g8r8:
    case PIXMAN_x8b8g8r8:
    case PIXMAN_b8g8r8a8:
    case PIXMAN_b8g8r8x8:
    case PIXMAN_r8g8b8:
    case PIXMAN_b8g8r8:
    case PIXMAN_r5g6b5:
    case PIXMAN_b5g6r5:
    /* 16 bpp formats */
    case PIXMAN_a1r5g5b5:
    case PIXMAN_x1r5g5b5:
    case PIXMAN_a1b5g5r5:
    case PIXMAN_x1b5g5r5:
    case PIXMAN_a4r4g4b4:
    case PIXMAN_x4r4g4b4:
    case PIXMAN_a4b4g4r4:
    case PIXMAN_x4b4g4r4:
    /* 8bpp formats */
    case PIXMAN_a8:
    case PIXMAN_r3g3b2:
    case PIXMAN_b2g3r3:
    case PIXMAN_a2r2g2b2:
    case PIXMAN_a2b2g2r2:
    case PIXMAN_c8:
    case PIXMAN_g8:
    case PIXMAN_x4a4:
    /* Collides with PIXMAN_c8
    case PIXMAN_x4c4:
    */
    /* Collides with PIXMAN_g8
    case PIXMAN_x4g4:
    */
    /* 4bpp formats */
    case PIXMAN_a4:
    case PIXMAN_r1g2b1:
    case PIXMAN_b1g2r1:
    case PIXMAN_a1r1g1b1:
    case PIXMAN_a1b1g1r1:
    case PIXMAN_c4:
    case PIXMAN_g4:
    /* 1bpp formats */
    case PIXMAN_a1:
    case PIXMAN_g1:
    /* YUV formats */
    case PIXMAN_yuy2:
    case PIXMAN_yv12:
	return TRUE;
d346 1
a346 2
    default:
	return FALSE;
d350 4
d355 15
a369 23
_pixman_walk_composite_region (pixman_implementation_t *imp,
			      pixman_op_t op,
			      pixman_image_t * pSrc,
			      pixman_image_t * pMask,
			      pixman_image_t * pDst,
			      int16_t xSrc,
			      int16_t ySrc,
			      int16_t xMask,
			      int16_t yMask,
			      int16_t xDst,
			      int16_t yDst,
			      uint16_t width,
			      uint16_t height,
			      pixman_bool_t srcRepeat,
			      pixman_bool_t maskRepeat,
			      pixman_composite_func_t compositeRect)
{
    int		    n;
    const pixman_box32_t *pbox;
    int		    w, h, w_this, h_this;
    int		    x_msk, y_msk, x_src, y_src, x_dst, y_dst;
    pixman_region32_t reg;
    pixman_region32_t *region;
d371 1
a371 5
    pixman_region32_init (&reg);
    if (!pixman_compute_composite_region32 (&reg, pSrc, pMask, pDst,
					    xSrc, ySrc, xMask, yMask, xDst, yDst, width, height))
    {
	return;
d373 1
d375 23
a397 1
    region = &reg;
d403 2
a404 2
	y_src = pbox->y1 - yDst + ySrc;
	y_msk = pbox->y1 - yDst + yMask;
d406 1
d411 2
a412 2
	    x_src = pbox->x1 - xDst + xSrc;
	    x_msk = pbox->x1 - xDst + xMask;
d414 2
a415 1
	    if (maskRepeat)
d417 3
a419 3
		y_msk = MOD (y_msk, pMask->bits.height);
		if (h_this > pMask->bits.height - y_msk)
		    h_this = pMask->bits.height - y_msk;
d421 2
a422 1
	    if (srcRepeat)
d424 3
a426 3
		y_src = MOD (y_src, pSrc->bits.height);
		if (h_this > pSrc->bits.height - y_src)
		    h_this = pSrc->bits.height - y_src;
d428 1
d432 2
a433 1
		if (maskRepeat)
d435 3
a437 3
		    x_msk = MOD (x_msk, pMask->bits.width);
		    if (w_this > pMask->bits.width - x_msk)
			w_this = pMask->bits.width - x_msk;
d439 2
a440 1
		if (srcRepeat)
d442 3
a444 3
		    x_src = MOD (x_src, pSrc->bits.width);
		    if (w_this > pSrc->bits.width - x_src)
			w_this = pSrc->bits.width - x_src;
d446 5
a450 4
		(*compositeRect) (imp,
				  op, pSrc, pMask, pDst,
				  x_src, y_src, x_msk, y_msk, x_dst, y_dst,
				  w_this, h_this);
d452 1
d457 1
d463 1
d466 36
a501 1
    pixman_region32_fini (&reg);
d511 3
a513 3
	mask->common.repeat == PIXMAN_REPEAT_NORMAL &&
	mask->bits.width == 1 &&
	mask->bits.height == 1)
d521 7
a527 7
static const FastPathInfo *
get_fast_path (const FastPathInfo *fast_paths,
	       pixman_op_t         op,
	       pixman_image_t     *pSrc,
	       pixman_image_t     *pMask,
	       pixman_image_t     *pDst,
	       pixman_bool_t       is_pixbuf)
d529 1
a529 1
    const FastPathInfo *info;
d533 2
a534 2
	pixman_bool_t valid_src		= FALSE;
	pixman_bool_t valid_mask	= FALSE;
d539 4
a542 2
	if ((info->src_format == PIXMAN_solid && pixman_image_can_get_solid (pSrc))		||
	    (pSrc->type == BITS && info->src_format == pSrc->bits.format))
d550 3
a552 2
	if ((info->mask_format == PIXMAN_null && !pMask)			||
	    (pMask && pMask->type == BITS && info->mask_format == pMask->bits.format))
d558 1
a558 1
		if (!pMask || !mask_is_solid (pMask))
d564 1
a564 1
		if (!pMask || !pMask->common.component_alpha)
d571 2
a572 2
	
	if (info->dest_format != pDst->bits.format)
d584 43
d628 14
a641 14
_pixman_run_fast_path (const FastPathInfo *paths,
		       pixman_implementation_t *imp,
		       pixman_op_t op,
		       pixman_image_t *src,
		       pixman_image_t *mask,
		       pixman_image_t *dest,
		       int32_t src_x,
		       int32_t src_y,
		       int32_t mask_x,
		       int32_t mask_y,
		       int32_t dest_x,
		       int32_t dest_y,
		       int32_t width,
		       int32_t height)
d644 42
a685 18
    pixman_bool_t src_repeat = src->common.repeat == PIXMAN_REPEAT_NORMAL;
    pixman_bool_t mask_repeat = mask && mask->common.repeat == PIXMAN_REPEAT_NORMAL;
    
    if ((src->type == BITS || pixman_image_can_get_solid (src)) &&
	(!mask || mask->type == BITS)
        && !src->common.transform && !(mask && mask->common.transform)
        && !(mask && mask->common.alpha_map) && !src->common.alpha_map && !dest->common.alpha_map
        && (src->common.filter != PIXMAN_FILTER_CONVOLUTION)
        && (src->common.repeat != PIXMAN_REPEAT_PAD)
        && (src->common.repeat != PIXMAN_REPEAT_REFLECT)
        && (!mask || (mask->common.filter != PIXMAN_FILTER_CONVOLUTION &&
		      mask->common.repeat != PIXMAN_REPEAT_PAD &&
		      mask->common.repeat != PIXMAN_REPEAT_REFLECT))
	&& !src->common.read_func && !src->common.write_func
	&& !(mask && mask->common.read_func)
	&& !(mask && mask->common.write_func)
	&& !dest->common.read_func
	&& !dest->common.write_func)
d687 1
a687 1
	const FastPathInfo *info;	
d691 6
a696 6
	    src && src->type == BITS		&&
	    mask && mask->type == BITS		&&
	    src->bits.bits == mask->bits.bits	&&
	    src_x == mask_x			&&
	    src_y == mask_y			&&
	    !mask->common.component_alpha	&&
d698 1
a698 1
	
d704 1
a704 1
		
d708 3
a710 1
	    if (info->mask_format == PIXMAN_solid || info->flags & NEED_SOLID_MASK)
d712 1
d714 6
a719 6
	    if ((src_repeat			&&
		 src->bits.width == 1		&&
		 src->bits.height == 1)	||
		(mask_repeat			&&
		 mask->bits.width == 1		&&
		 mask->bits.height == 1))
d734 2
d738 90
a827 8
	_pixman_walk_composite_region (imp, op,
				       src, mask, dest,
				       src_x, src_y, mask_x, mask_y,
				       dest_x, dest_y,
				       width, height,
				       src_repeat, mask_repeat,
				       func);
	return TRUE;
d829 8
a836 2
    
    return FALSE;
@


1.3
log
@pixman 0.12.0. Tested on a full ports build by naddy@@.
@
text
@a30 170
#include "pixman-mmx.h"

PIXMAN_EXPORT pixman_bool_t
pixman_transform_point_3d (pixman_transform_t *transform,
			   pixman_vector_t *vector)
{
    pixman_vector_t		result;
    int				i, j;
    pixman_fixed_32_32_t	partial;
    pixman_fixed_48_16_t	v;

    for (j = 0; j < 3; j++)
    {
	v = 0;
	for (i = 0; i < 3; i++)
	{
	    partial = ((pixman_fixed_48_16_t) transform->matrix[j][i] *
		       (pixman_fixed_48_16_t) vector->vector[i]);
	    v += partial >> 16;
	}

	if (v > pixman_max_fixed_48_16 || v < pixman_min_fixed_48_16)
	    return FALSE;

	result.vector[j] = (pixman_fixed_48_16_t) v;
    }

    if (!result.vector[2])
	return FALSE;

    *vector = result;
    return TRUE;
}

PIXMAN_EXPORT pixman_bool_t
pixman_blt (uint32_t *src_bits,
	    uint32_t *dst_bits,
	    int src_stride,
	    int dst_stride,
	    int src_bpp,
	    int dst_bpp,
	    int src_x, int src_y,
	    int dst_x, int dst_y,
	    int width, int height)
{
#ifdef USE_MMX
    if (pixman_have_mmx())
    {
	return pixman_blt_mmx (src_bits, dst_bits, src_stride, dst_stride, src_bpp, dst_bpp,
			       src_x, src_y, dst_x, dst_y, width, height);
    }
    else
#endif
	return FALSE;
}

static void
pixman_fill8 (uint32_t  *bits,
	      int	stride,
	      int	x,
	      int	y,
	      int	width,
	      int	height,
	      uint32_t  xor)
{
    int byte_stride = stride * (int) sizeof (uint32_t);
    uint8_t *dst = (uint8_t *) bits;
    uint8_t v = xor & 0xff;
    int i;

    dst = dst + y * byte_stride + x;

    while (height--)
    {
	for (i = 0; i < width; ++i)
	    dst[i] = v;

	dst += byte_stride;
    }
}

static void
pixman_fill16 (uint32_t *bits,
	       int       stride,
	       int       x,
	       int       y,
	       int       width,
	       int       height,
	       uint32_t  xor)
{
    int short_stride = (stride * (int) sizeof (uint32_t)) / (int) sizeof (uint16_t);
    uint16_t *dst = (uint16_t *)bits;
    uint16_t v = xor & 0xffff;
    int i;

    dst = dst + y * short_stride + x;

    while (height--)
    {
	for (i = 0; i < width; ++i)
	    dst[i] = v;

	dst += short_stride;
    }
}

static void
pixman_fill32 (uint32_t *bits,
	       int       stride,
	       int       x,
	       int       y,
	       int       width,
	       int       height,
	       uint32_t  xor)
{
    int i;

    bits = bits + y * stride + x;

    while (height--)
    {
	for (i = 0; i < width; ++i)
	    bits[i] = xor;

	bits += stride;
    }
}

PIXMAN_EXPORT pixman_bool_t
pixman_fill (uint32_t *bits,
	     int stride,
	     int bpp,
	     int x,
	     int y,
	     int width,
	     int height,
	     uint32_t xor)
{
#if 0
    printf ("filling: %d %d %d %d (stride: %d, bpp: %d)   pixel: %x\n",
	    x, y, width, height, stride, bpp, xor);
#endif

#ifdef USE_MMX
    if (!pixman_have_mmx() || !pixman_fill_mmx (bits, stride, bpp, x, y, width, height, xor))
#endif
    {
	switch (bpp)
	{
	case 8:
	    pixman_fill8 (bits, stride, x, y, width, height, xor);
	    break;

	case 16:
	    pixman_fill16 (bits, stride, x, y, width, height, xor);
	    break;

	case 32:
	    pixman_fill32 (bits, stride, x, y, width, height, xor);
	    break;

	default:
	    return FALSE;
	    break;
	}
    }

    return TRUE;
}

d46 7
a52 2
	f = Y_FRAC_FIRST(n);
	i += pixman_fixed_1;
d72 7
a78 2
	f = Y_FRAC_LAST(n);
	i -= pixman_fixed_1;
d120 1
a120 1
_pixman_edge_tMultiInit (pixman_edge_t *e, int n, pixman_fixed_t *stepx_p, pixman_fixed_t *dx_p)
d175 2
a176 2
	_pixman_edge_tMultiInit (e, STEP_Y_SMALL(n), &e->stepx_small, &e->dx_small);
	_pixman_edge_tMultiInit (e, STEP_Y_BIG(n), &e->stepx_big, &e->dx_big);
d316 2
d388 2
d437 266
@


1.2
log
@Update to pixman 0.10, with one small fix to the sse2 test in configure.ac.
@
text
@d33 1
a33 1
pixman_bool_t
d65 1
a65 1
pixman_bool_t
d159 1
a159 1
pixman_bool_t
d207 1
a207 1
pixman_fixed_t
d228 1
a228 1
pixman_fixed_t
d246 1
a246 1
void
d301 1
a301 1
void
d345 1
a345 1
void
d431 1
a431 1
int
d448 1
a448 1
const char*
d465 1
a465 1
pixman_bool_t
d470 2
d535 1
a535 1
pixman_bool_t
d540 2
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
d24 1
d26 2
d29 1
a29 1
#include "pixman.h"
d57 1
a57 1
    
d60 1
a60 1
    
d96 1
a96 1
    int byte_stride = stride * sizeof (uint32_t);
d121 1
a121 1
    int short_stride = (stride * sizeof (uint32_t)) / sizeof (uint16_t);
d147 1
a147 1
    
d149 1
a149 1
    
d173 1
a173 1
    
d183 1
a183 1
	    
d187 1
a187 1
	    
d197 1
a197 1
	
d200 1
a200 1
	    
d212 1
a212 1
    
d233 1
a233 1
    
d252 1
a252 1
    
d254 1
a254 1
    
d284 1
a284 1
    
d334 1
a334 1
    
d374 14
d409 180
@


1.1.1.1
log
@import pixman 0.9.5
@
text
@@


1.1.1.2
log
@pixman 0.9.6
@
text
@a23 1
#ifdef HAVE_CONFIG_H
a24 2
#endif

a368 14
}

pixman_bool_t
pixman_multiply_overflows_int (unsigned int a,
		               unsigned int b)
{
    return a >= INT32_MAX / b;
}

pixman_bool_t
pixman_addition_overflows_int (unsigned int a,
		               unsigned int b)
{
    return a > INT32_MAX - b;
@

