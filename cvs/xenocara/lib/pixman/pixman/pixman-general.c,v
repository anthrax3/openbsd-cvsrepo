head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.6
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2016.10.01.10.17.44;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	FGr8CFhVerRlpSoE;

1.13
date	2015.10.01.06.21.38;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	a56IHRa9z4nbjjS9;

1.12
date	2013.12.01.20.34.20;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.07.17.18.01;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.02.28.20.36.12;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.22.08.32.55;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.11.14.13.42.49;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.11.16.32.52;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.05.20.14.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to pixman 0.34.0.
@
text
@/*
 * Copyright © 2009 Red Hat, Inc.
 * Copyright © 2000 SuSE, Inc.
 * Copyright © 2007 Red Hat, Inc.
 * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
 *             2005 Lars Knoll & Zack Rusin, Trolltech
 *             2008 Aaron Plattner, NVIDIA Corporation
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Red Hat not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  Red Hat makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "pixman-private.h"

static void
general_iter_init (pixman_iter_t *iter, const pixman_iter_info_t *info)
{
    pixman_image_t *image = iter->image;

    switch (image->type)
    {
    case BITS:
        if ((iter->iter_flags & ITER_SRC) == ITER_SRC)
            _pixman_bits_image_src_iter_init (image, iter);
        else
            _pixman_bits_image_dest_iter_init (image, iter);
        break;

    case LINEAR:
        _pixman_linear_gradient_iter_init (image, iter);
        break;

    case RADIAL:
	_pixman_radial_gradient_iter_init (image, iter);
        break;

    case CONICAL:
	_pixman_conical_gradient_iter_init (image, iter);
        break;

    case SOLID:
        _pixman_log_error (FUNC, "Solid image not handled by noop");
        break;

    default:
	_pixman_log_error (FUNC, "Pixman bug: unknown image type\n");
        break;
    }
}

static const pixman_iter_info_t general_iters[] =
{
    { PIXMAN_any, 0, 0, general_iter_init, NULL, NULL },
    { PIXMAN_null },
};

typedef struct op_info_t op_info_t;
struct op_info_t
{
    uint8_t src, dst;
};

#define ITER_IGNORE_BOTH						\
    (ITER_IGNORE_ALPHA | ITER_IGNORE_RGB | ITER_LOCALIZED_ALPHA)

static const op_info_t op_flags[PIXMAN_N_OPERATORS] =
{
    /* Src                   Dst                   */
    { ITER_IGNORE_BOTH,      ITER_IGNORE_BOTH      }, /* CLEAR */
    { ITER_LOCALIZED_ALPHA,  ITER_IGNORE_BOTH      }, /* SRC */
    { ITER_IGNORE_BOTH,      ITER_LOCALIZED_ALPHA  }, /* DST */
    { 0,                     ITER_LOCALIZED_ALPHA  }, /* OVER */
    { ITER_LOCALIZED_ALPHA,  0                     }, /* OVER_REVERSE */
    { ITER_LOCALIZED_ALPHA,  ITER_IGNORE_RGB       }, /* IN */
    { ITER_IGNORE_RGB,       ITER_LOCALIZED_ALPHA  }, /* IN_REVERSE */
    { ITER_LOCALIZED_ALPHA,  ITER_IGNORE_RGB       }, /* OUT */
    { ITER_IGNORE_RGB,       ITER_LOCALIZED_ALPHA  }, /* OUT_REVERSE */
    { 0,                     0                     }, /* ATOP */
    { 0,                     0                     }, /* ATOP_REVERSE */
    { 0,                     0                     }, /* XOR */
    { ITER_LOCALIZED_ALPHA,  ITER_LOCALIZED_ALPHA  }, /* ADD */
    { 0,                     0                     }, /* SATURATE */
};

#define SCANLINE_BUFFER_LENGTH 8192

static pixman_bool_t
operator_needs_division (pixman_op_t op)
{
    static const uint8_t needs_division[] =
    {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, /* SATURATE */
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, /* DISJOINT */
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, /* CONJOINT */
	0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, /* blend ops */
    };

    return needs_division[op];
}

static void
general_composite_rect  (pixman_implementation_t *imp,
                         pixman_composite_info_t *info)
{
    PIXMAN_COMPOSITE_ARGS (info);
    uint8_t stack_scanline_buffer[3 * SCANLINE_BUFFER_LENGTH];
    uint8_t *scanline_buffer = (uint8_t *) stack_scanline_buffer;
    uint8_t *src_buffer, *mask_buffer, *dest_buffer;
    pixman_iter_t src_iter, mask_iter, dest_iter;
    pixman_combine_32_func_t compose;
    pixman_bool_t component_alpha;
    iter_flags_t width_flag, src_iter_flags;
    int Bpp;
    int i;

    if ((src_image->common.flags & FAST_PATH_NARROW_FORMAT)		     &&
	(!mask_image || mask_image->common.flags & FAST_PATH_NARROW_FORMAT)  &&
	(dest_image->common.flags & FAST_PATH_NARROW_FORMAT)		     &&
	!(operator_needs_division (op)))
    {
	width_flag = ITER_NARROW;
	Bpp = 4;
    }
    else
    {
	width_flag = ITER_WIDE;
	Bpp = 16;
    }

#define ALIGN(addr)							\
    ((uint8_t *)((((uintptr_t)(addr)) + 15) & (~15)))

    if (width <= 0 || _pixman_multiply_overflows_int (width, Bpp * 3))
	return;

    if (width * Bpp * 3 > sizeof (stack_scanline_buffer) - 15 * 3)
    {
	scanline_buffer = pixman_malloc_ab_plus_c (width, Bpp * 3, 15 * 3);

	if (!scanline_buffer)
	    return;
    }

    src_buffer = ALIGN (scanline_buffer);
    mask_buffer = ALIGN (src_buffer + width * Bpp);
    dest_buffer = ALIGN (mask_buffer + width * Bpp);

    if (width_flag == ITER_WIDE)
    {
	/* To make sure there aren't any NANs in the buffers */
	memset (src_buffer, 0, width * Bpp);
	memset (mask_buffer, 0, width * Bpp);
	memset (dest_buffer, 0, width * Bpp);
    }
    
    /* src iter */
    src_iter_flags = width_flag | op_flags[op].src | ITER_SRC;

    _pixman_implementation_iter_init (imp->toplevel, &src_iter, src_image,
                                      src_x, src_y, width, height,
                                      src_buffer, src_iter_flags,
                                      info->src_flags);

    /* mask iter */
    if ((src_iter_flags & (ITER_IGNORE_ALPHA | ITER_IGNORE_RGB)) ==
	(ITER_IGNORE_ALPHA | ITER_IGNORE_RGB))
    {
	/* If it doesn't matter what the source is, then it doesn't matter
	 * what the mask is
	 */
	mask_image = NULL;
    }

    component_alpha = mask_image && mask_image->common.component_alpha;

    _pixman_implementation_iter_init (
	imp->toplevel, &mask_iter,
	mask_image, mask_x, mask_y, width, height, mask_buffer,
	ITER_SRC | width_flag | (component_alpha? 0 : ITER_IGNORE_RGB),
	info->mask_flags);

    /* dest iter */
    _pixman_implementation_iter_init (
	imp->toplevel, &dest_iter, dest_image, dest_x, dest_y, width, height,
	dest_buffer, ITER_DEST | width_flag | op_flags[op].dst, info->dest_flags);

    compose = _pixman_implementation_lookup_combiner (
	imp->toplevel, op, component_alpha, width_flag != ITER_WIDE);

    for (i = 0; i < height; ++i)
    {
	uint32_t *s, *m, *d;

	m = mask_iter.get_scanline (&mask_iter, NULL);
	s = src_iter.get_scanline (&src_iter, m);
	d = dest_iter.get_scanline (&dest_iter, NULL);

	compose (imp->toplevel, op, d, s, m, width);

	dest_iter.write_back (&dest_iter);
    }

    if (src_iter.fini)
	src_iter.fini (&src_iter);
    if (mask_iter.fini)
	mask_iter.fini (&mask_iter);
    if (dest_iter.fini)
	dest_iter.fini (&dest_iter);
    
    if (scanline_buffer != (uint8_t *) stack_scanline_buffer)
	free (scanline_buffer);
}

static const pixman_fast_path_t general_fast_path[] =
{
    { PIXMAN_OP_any, PIXMAN_any, 0, PIXMAN_any,	0, PIXMAN_any, 0, general_composite_rect },
    { PIXMAN_OP_NONE }
};

pixman_implementation_t *
_pixman_implementation_create_general (void)
{
    pixman_implementation_t *imp = _pixman_implementation_create (NULL, general_fast_path);

    _pixman_setup_combiner_functions_32 (imp);
    _pixman_setup_combiner_functions_float (imp);

    imp->iter_info = general_iters;

    return imp;
}

@


1.13
log
@Update to pixman 0.32.8.
@
text
@d112 14
d141 4
a144 3
    if ((src_image->common.flags & FAST_PATH_NARROW_FORMAT)		    &&
	(!mask_image || mask_image->common.flags & FAST_PATH_NARROW_FORMAT) &&
	(dest_image->common.flags & FAST_PATH_NARROW_FORMAT))
d161 1
a161 1
    if (width * Bpp * 3 > sizeof (stack_scanline_buffer) - 32 * 3)
d163 1
a163 1
	scanline_buffer = pixman_malloc_ab_plus_c (width, Bpp * 3, 32 * 3);
d199 1
a199 5
    component_alpha =
        mask_image			      &&
        mask_image->common.type == BITS       &&
        mask_image->common.component_alpha    &&
        PIXMAN_FORMAT_RGB (mask_image->bits.format);
@


1.12
log
@Update to pixman 0.32.4. Tested by naddy@@ and ajacoutot@@
@
text
@d143 2
a144 3
    src_buffer = ALIGN (scanline_buffer);
    mask_buffer = ALIGN (src_buffer + width * Bpp);
    dest_buffer = ALIGN (mask_buffer + width * Bpp);
d146 1
a146 2
    if (ALIGN (dest_buffer + width * Bpp) >
	    scanline_buffer + sizeof (stack_scanline_buffer))
d152 1
d154 3
a156 4
	src_buffer = ALIGN (scanline_buffer);
	mask_buffer = ALIGN (src_buffer + width * Bpp);
	dest_buffer = ALIGN (mask_buffer + width * Bpp);
    }
@


1.11
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@d40 2
a41 2
static pixman_bool_t
general_src_iter_init (pixman_implementation_t *imp, pixman_iter_t *iter)
d45 14
a58 3
    if (image->type == LINEAR)
	_pixman_linear_gradient_iter_init (image, iter);
    else if (image->type == RADIAL)
d60 3
a62 1
    else if (image->type == CONICAL)
d64 3
a66 3
    else if (image->type == BITS)
	_pixman_bits_image_src_iter_init (image, iter);
    else if (image->type == SOLID)
d68 3
a70 1
    else         
d72 2
a73 2

    return TRUE;
d76 1
a76 2
static pixman_bool_t
general_dest_iter_init (pixman_implementation_t *imp, pixman_iter_t *iter)
d78 3
a80 13
    if (iter->image->type == BITS)
    {
	_pixman_bits_image_dest_iter_init (iter->image, iter);

	return TRUE;
    }
    else
    {
	_pixman_log_error (FUNC, "Trying to write to a non-writable image");

	return FALSE;
    }
}
d117 1
a117 1
    uint64_t stack_scanline_buffer[(SCANLINE_BUFFER_LENGTH * 3 + 7) / 8];
d123 1
a123 1
    iter_flags_t narrow, src_iter_flags;
d131 1
a131 1
	narrow = ITER_NARROW;
d136 1
a136 1
	narrow = 0;
d140 9
a148 1
    if (width * Bpp > SCANLINE_BUFFER_LENGTH)
d150 1
a150 1
	scanline_buffer = pixman_malloc_abc (width, 3, Bpp);
d154 4
d160 1
a160 5
    src_buffer = scanline_buffer;
    mask_buffer = src_buffer + width * Bpp;
    dest_buffer = mask_buffer + width * Bpp;

    if (!narrow)
d169 1
a169 1
    src_iter_flags = narrow | op_flags[op].src;
d171 4
a174 3
    _pixman_implementation_src_iter_init (imp->toplevel, &src_iter, src_image,
					  src_x, src_y, width, height,
					  src_buffer, src_iter_flags, info->src_flags);
d192 5
a196 3
    _pixman_implementation_src_iter_init (
	imp->toplevel, &mask_iter, mask_image, mask_x, mask_y, width, height,
	mask_buffer, narrow | (component_alpha? 0 : ITER_IGNORE_RGB), info->mask_flags);
d199 1
a199 1
    _pixman_implementation_dest_iter_init (
d201 1
a201 1
	dest_buffer, narrow | op_flags[op].dst, info->dest_flags);
d204 1
a204 1
	imp->toplevel, op, component_alpha, narrow);
d219 7
d244 1
a244 2
    imp->src_iter_init = general_src_iter_init;
    imp->dest_iter_init = general_dest_iter_init;
@


1.10
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@d45 1
a45 3
    if (image->type == SOLID)
	_pixman_solid_fill_iter_init (image, iter);
    else if (image->type == LINEAR)
d53 3
a55 1
    else
a189 3

    if (!compose)
	return;
@


1.9
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@d40 1
a40 1
static void
d57 2
d61 1
a61 1
static void
d67 2
d73 2
d119 1
a119 1
    iter_flags_t narrow, src_flags;
d133 1
a133 1
	Bpp = 8;
d148 8
d157 1
a157 1
    src_flags = narrow | op_flags[op].src;
d161 1
a161 1
					  src_buffer, src_flags);
d164 1
a164 1
    if ((src_flags & (ITER_IGNORE_ALPHA | ITER_IGNORE_RGB)) ==
d181 1
a181 1
	mask_buffer, narrow | (component_alpha? 0 : ITER_IGNORE_RGB));
d186 1
a186 1
	dest_buffer, narrow | op_flags[op].dst);
a216 34
static pixman_bool_t
general_blt (pixman_implementation_t *imp,
             uint32_t *               src_bits,
             uint32_t *               dst_bits,
             int                      src_stride,
             int                      dst_stride,
             int                      src_bpp,
             int                      dst_bpp,
             int                      src_x,
             int                      src_y,
             int                      dest_x,
             int                      dest_y,
             int                      width,
             int                      height)
{
    /* We can't blit unless we have sse2 or mmx */

    return FALSE;
}

static pixman_bool_t
general_fill (pixman_implementation_t *imp,
              uint32_t *               bits,
              int                      stride,
              int                      bpp,
              int                      x,
              int                      y,
              int                      width,
              int                      height,
              uint32_t xor)
{
    return FALSE;
}

d223 1
a223 1
    _pixman_setup_combiner_functions_64 (imp);
a224 2
    imp->blt = general_blt;
    imp->fill = general_fill;
@


1.8
log
@Update to pixman 0.22.4. Tested by shadchin@@, krw@@.
@
text
@d174 2
a175 14
    if (narrow)
    {
	if (component_alpha)
	    compose = _pixman_implementation_combine_32_ca;
	else
	    compose = _pixman_implementation_combine_32;
    }
    else
    {
	if (component_alpha)
	    compose = (pixman_combine_32_func_t)_pixman_implementation_combine_64_ca;
	else
	    compose = (pixman_combine_32_func_t)_pixman_implementation_combine_64;
    }
@


1.7
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d104 1
a104 12
                         pixman_op_t              op,
                         pixman_image_t *         src,
                         pixman_image_t *         mask,
                         pixman_image_t *         dest,
                         int32_t                  src_x,
                         int32_t                  src_y,
                         int32_t                  mask_x,
                         int32_t                  mask_y,
                         int32_t                  dest_x,
                         int32_t                  dest_y,
                         int32_t                  width,
                         int32_t                  height)
d106 1
d117 3
a119 3
    if ((src->common.flags & FAST_PATH_NARROW_FORMAT)		&&
	(!mask || mask->common.flags & FAST_PATH_NARROW_FORMAT)	&&
	(dest->common.flags & FAST_PATH_NARROW_FORMAT))
d145 1
a145 1
    _pixman_implementation_src_iter_init (imp->toplevel, &src_iter, src,
d156 1
a156 1
	mask = NULL;
d160 4
a163 4
        mask                            &&
        mask->common.type == BITS       &&
        mask->common.component_alpha    &&
        PIXMAN_FORMAT_RGB (mask->bits.format);
d166 1
a166 1
	imp->toplevel, &mask_iter, mask, mask_x, mask_y, width, height,
d170 3
a172 4
    _pixman_implementation_dest_iter_init (imp->toplevel, &dest_iter, dest,
					   dest_x, dest_y, width, height,
					   dest_buffer,
					   narrow | op_flags[op].dst);
d225 2
a226 2
             int                      dst_x,
             int                      dst_y,
@


1.6
log
@Bug-fix upgrade to pixman 0.20.2. No API/ABI change.
tested by shadchin@@, ajacoutot@@, krw@@, ok miod@@
@
text
@d39 60
a98 2
#include "pixman-combine32.h"
#include "pixman-private.h"
d120 1
a120 1
    fetch_scanline_t fetch_src = NULL, fetch_mask = NULL, fetch_dest = NULL;
a121 2
    store_scanline_t store;
    source_image_class_t src_class, mask_class;
d123 2
a124 3
    uint32_t *bits;
    int32_t stride;
    int narrow, Bpp;
d127 1
a127 2
    narrow =
	(src->common.flags & FAST_PATH_NARROW_FORMAT)		&&
d129 10
a138 2
	(dest->common.flags & FAST_PATH_NARROW_FORMAT);
    Bpp = narrow ? 4 : 8;
d152 2
a153 3
    src_class = _pixman_image_classify (src,
                                        src_x, src_y,
                                        width, height);
d155 12
a166 70
    mask_class = SOURCE_IMAGE_CLASS_UNKNOWN;

    if (mask)
    {
	mask_class = _pixman_image_classify (mask,
	                                     src_x, src_y,
	                                     width, height);
    }

    if (op == PIXMAN_OP_CLEAR)
	fetch_src = NULL;
    else if (narrow)
	fetch_src = _pixman_image_get_scanline_32;
    else
	fetch_src = _pixman_image_get_scanline_64;

    if (!mask || op == PIXMAN_OP_CLEAR)
	fetch_mask = NULL;
    else if (narrow)
	fetch_mask = _pixman_image_get_scanline_32;
    else
	fetch_mask = _pixman_image_get_scanline_64;

    if (op == PIXMAN_OP_CLEAR || op == PIXMAN_OP_SRC)
	fetch_dest = NULL;
    else if (narrow)
	fetch_dest = _pixman_image_get_scanline_32;
    else
	fetch_dest = _pixman_image_get_scanline_64;

    if (narrow)
	store = _pixman_image_store_scanline_32;
    else
	store = _pixman_image_store_scanline_64;

    /* Skip the store step and composite directly into the
     * destination if the output format of the compose func matches
     * the destination format.
     *
     * If the destination format is a8r8g8b8 then we can always do
     * this. If it is x8r8g8b8, then we can only do it if the
     * operator doesn't make use of destination alpha.
     */
    if ((dest->bits.format == PIXMAN_a8r8g8b8)	||
	(dest->bits.format == PIXMAN_x8r8g8b8	&&
	 (op == PIXMAN_OP_OVER		||
	  op == PIXMAN_OP_ADD		||
	  op == PIXMAN_OP_SRC		||
	  op == PIXMAN_OP_CLEAR		||
	  op == PIXMAN_OP_IN_REVERSE	||
	  op == PIXMAN_OP_OUT_REVERSE	||
	  op == PIXMAN_OP_DST)))
    {
	if (narrow &&
	    !dest->common.alpha_map &&
	    !dest->bits.write_func)
	{
	    store = NULL;
	}
    }

    if (!store)
    {
	bits = dest->bits.bits;
	stride = dest->bits.rowstride;
    }
    else
    {
	bits = NULL;
	stride = 0;
a169 2
        fetch_src                       &&
        fetch_mask                      &&
d175 10
a202 3
    if (!fetch_mask)
	mask_buffer = NULL;

d205 9
a213 59
	/* fill first half of scanline with source */
	if (fetch_src)
	{
	    if (fetch_mask)
	    {
		/* fetch mask before source so that fetching of
		   source can be optimized */
		fetch_mask (mask, mask_x, mask_y + i,
		            width, (void *)mask_buffer, 0);

		if (mask_class == SOURCE_IMAGE_CLASS_HORIZONTAL)
		    fetch_mask = NULL;
	    }

	    if (src_class == SOURCE_IMAGE_CLASS_HORIZONTAL)
	    {
		fetch_src (src, src_x, src_y + i,
		           width, (void *)src_buffer, 0);
		fetch_src = NULL;
	    }
	    else
	    {
		fetch_src (src, src_x, src_y + i,
		           width, (void *)src_buffer, (void *)mask_buffer);
	    }
	}
	else if (fetch_mask)
	{
	    fetch_mask (mask, mask_x, mask_y + i,
	                width, (void *)mask_buffer, 0);
	}

	if (store)
	{
	    /* fill dest into second half of scanline */
	    if (fetch_dest)
	    {
		fetch_dest (dest, dest_x, dest_y + i,
		            width, (void *)dest_buffer, 0);
	    }

	    /* blend */
	    compose (imp->toplevel, op,
		     (void *)dest_buffer,
		     (void *)src_buffer,
		     (void *)mask_buffer,
		     width);

	    /* write back */
	    store (&(dest->bits), dest_x, dest_y + i, width,
	           (void *)dest_buffer);
	}
	else
	{
	    /* blend */
	    compose (imp->toplevel, op,
		     bits + (dest_y + i) * stride + dest_x,
	             (void *)src_buffer, (void *)mask_buffer, width);
	}
d270 2
@


1.5
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@d59 2
a60 2
    uint8_t stack_scanline_buffer[SCANLINE_BUFFER_LENGTH * 3];
    uint8_t *scanline_buffer = stack_scanline_buffer;
d258 1
a258 1
    if (scanline_buffer != stack_scanline_buffer)
@


1.4
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@a59 11
    const pixman_format_code_t src_format =
	src->type == BITS ? src->bits.format : 0;
    const pixman_format_code_t mask_format =
	mask && mask->type == BITS ? mask->bits.format : 0;
    const pixman_format_code_t dest_format =
	dest->type == BITS ? dest->bits.format : 0;
    const int src_wide = PIXMAN_FORMAT_IS_WIDE (src_format);
    const int mask_wide = mask && PIXMAN_FORMAT_IS_WIDE (mask_format);
    const int dest_wide = PIXMAN_FORMAT_IS_WIDE (dest_format);
    const int wide = src_wide || mask_wide || dest_wide;
    const int Bpp = wide ? 8 : 4;
d69 1
d72 6
d105 3
a107 1
    else if (wide)
a108 2
    else
	fetch_src = _pixman_image_get_scanline_32;
d112 3
a114 1
    else if (wide)
a115 2
    else
	fetch_mask = _pixman_image_get_scanline_32;
d119 3
a121 1
    else if (wide)
d123 3
a126 3
	fetch_dest = _pixman_image_get_scanline_32;

    if (wide)
a127 2
    else
	store = _pixman_image_store_scanline_32;
d147 1
a147 1
	if (!wide &&
d174 1
a174 1
    if (wide)
d177 1
a177 1
	    compose = (pixman_combine_32_func_t)_pixman_implementation_combine_64_ca;
d179 1
a179 1
	    compose = (pixman_combine_32_func_t)_pixman_implementation_combine_64;
d184 1
a184 1
	    compose = _pixman_implementation_combine_32_ca;
d186 1
a186 1
	    compose = _pixman_implementation_combine_32;
d205 1
a205 1
		            width, (void *)mask_buffer, 0, 0);
d214 1
a214 1
		           width, (void *)src_buffer, 0, 0);
d220 1
a220 2
		           width, (void *)src_buffer, (void *)mask_buffer,
		           0xffffffff);
d226 1
a226 1
	                width, (void *)mask_buffer, 0, 0);
d235 1
a235 1
		            width, (void *)dest_buffer, 0, 0);
@


1.3
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@d136 4
d141 16
a156 8
    if (!wide &&
        !dest->common.alpha_map &&
        !dest->bits.write_func &&
        (op == PIXMAN_OP_ADD || op == PIXMAN_OP_OVER) &&
        (dest->bits.format == PIXMAN_a8r8g8b8 ||
         dest->bits.format == PIXMAN_x8r8g8b8))
    {
	store = NULL;
d267 1
a267 14
static void
general_composite (pixman_implementation_t * imp,
                   pixman_op_t               op,
                   pixman_image_t *          src,
                   pixman_image_t *          mask,
                   pixman_image_t *          dest,
                   int32_t                   src_x,
                   int32_t                   src_y,
                   int32_t                   mask_x,
                   int32_t                   mask_y,
                   int32_t                   dest_x,
                   int32_t                   dest_y,
                   int32_t                   width,
                   int32_t                   height)
d269 3
a271 5
    _pixman_walk_composite_region (imp, op, src, mask, dest, src_x, src_y,
                                   mask_x, mask_y, dest_x, dest_y,
				   width, height,
                                   general_composite_rect);
}
d310 1
a310 1
    pixman_implementation_t *imp = _pixman_implementation_create (NULL);
a314 1
    imp->composite = general_composite;
@


1.2
log
@fix gcc2ism, collaboration with matthieu
@
text
@d28 1
d30 1
a33 1
#include <assert.h>
d46 12
a57 12
			 pixman_op_t              op,
			 pixman_image_t          *src,
			 pixman_image_t          *mask,
			 pixman_image_t          *dest,
			 int32_t                  src_x,
			 int32_t                  src_y,
			 int32_t                  mask_x,
			 int32_t                  mask_y,
			 int32_t                  dest_x,
			 int32_t                  dest_y,
			 int32_t                  width,
			 int32_t                  height)
a58 3
    return_if_fail (src != NULL);
    return_if_fail (dest != NULL);
    {
d60 10
a69 7
    const pixman_format_code_t srcFormat = src->type == BITS ? src->bits.format : 0;
    const pixman_format_code_t maskFormat = mask && mask->type == BITS ? mask->bits.format : 0;
    const pixman_format_code_t destFormat = dest->type == BITS ? dest->bits.format : 0;
    const int srcWide = PIXMAN_FORMAT_16BPC(srcFormat);
    const int maskWide = mask && PIXMAN_FORMAT_16BPC(maskFormat);
    const int destWide = PIXMAN_FORMAT_16BPC(destFormat);
    const int wide = srcWide || maskWide || destWide;
d73 1
a73 1
    scanFetchProc fetchSrc = NULL, fetchMask = NULL, fetchDest = NULL;
d75 2
a76 2
    scanStoreProc store;
    source_pict_class_t srcClass, maskClass;
d81 1
a81 1
    
d85 1
a85 1
	
d89 1
a89 1
    
d93 7
a99 6
    
    srcClass = _pixman_image_classify (src,
				       src_x, src_y,
				       width, height);
    
    maskClass = SOURCE_IMAGE_CLASS_UNKNOWN;
d102 3
a104 3
	maskClass = _pixman_image_classify (mask,
					    src_x, src_y,
					    width, height);
d106 1
a106 1
    
d108 1
a108 1
        fetchSrc = NULL;
d110 1
a110 1
	fetchSrc = _pixman_image_get_scanline_64;
d112 2
a113 2
	fetchSrc = _pixman_image_get_scanline_32;
    
d115 1
a115 1
	fetchMask = NULL;
d117 1
a117 1
	fetchMask = _pixman_image_get_scanline_64;
d119 2
a120 2
	fetchMask = _pixman_image_get_scanline_32;
    
d122 1
a122 1
	fetchDest = NULL;
d124 1
a124 1
	fetchDest = _pixman_image_get_scanline_64;
d126 1
a126 1
	fetchDest = _pixman_image_get_scanline_32;
d138 5
a142 5
	!dest->common.alpha_map &&
	!dest->common.write_func && 
	(op == PIXMAN_OP_ADD || op == PIXMAN_OP_OVER) &&
	(dest->bits.format == PIXMAN_a8r8g8b8 ||
	 dest->bits.format == PIXMAN_x8r8g8b8))
d146 1
a146 1
    
d157 1
a157 1
    
d159 7
a165 7
	fetchSrc			&&
	fetchMask			&&
	mask				&&
	mask->common.type == BITS	&&
	mask->common.component_alpha	&&
	PIXMAN_FORMAT_RGB (mask->bits.format);
    
d180 1
a180 1
    
d183 2
a184 2
    
    if (!fetchMask)
d186 1
a186 1
    
d190 1
a190 1
	if (fetchSrc)
d192 1
a192 1
	    if (fetchMask)
d196 5
a200 5
		fetchMask (mask, mask_x, mask_y + i,
			   width, (void *)mask_buffer, 0, 0);
		
		if (maskClass == SOURCE_IMAGE_CLASS_HORIZONTAL)
		    fetchMask = NULL;
d202 2
a203 2
	    
	    if (srcClass == SOURCE_IMAGE_CLASS_HORIZONTAL)
d205 3
a207 3
		fetchSrc (src, src_x, src_y + i,
			  width, (void *)src_buffer, 0, 0);
		fetchSrc = NULL;
d211 3
a213 3
		fetchSrc (src, src_x, src_y + i,
			  width, (void *)src_buffer, (void *)mask_buffer,
			  0xffffffff);
d216 1
a216 1
	else if (fetchMask)
d218 2
a219 2
	    fetchMask (mask, mask_x, mask_y + i,
		       width, (void *)mask_buffer, 0, 0);
d221 1
a221 1
	
d225 6
a230 4
	    if (fetchDest)
		fetchDest (dest, dest_x, dest_y + i,
			   width, (void *)dest_buffer, 0, 0);
	    
d232 6
a237 2
	    compose (imp->toplevel, op, (void *)dest_buffer, (void *)src_buffer, (void *)mask_buffer, width);
	    
d240 1
a240 1
		   (void *)dest_buffer);
d245 3
a247 3
	    compose (imp->toplevel, op, bits + (dest_y + i) * stride +
		     dest_x,
		     (void *)src_buffer, (void *)mask_buffer, width);
d250 1
a250 1
    
a252 1
    }
d256 13
a268 13
general_composite (pixman_implementation_t *	imp,
		   pixman_op_t			op,
		   pixman_image_t *		src,
		   pixman_image_t *		mask,
		   pixman_image_t *		dest,
		   int32_t			src_x,
		   int32_t			src_y,
		   int32_t			mask_x,
		   int32_t			mask_y,
		   int32_t			dest_x,
		   int32_t			dest_y,
		   int32_t			width,
		   int32_t			height)
a269 48
    pixman_bool_t srcRepeat = src->type == BITS && src->common.repeat == PIXMAN_REPEAT_NORMAL;
    pixman_bool_t maskRepeat = FALSE;
    pixman_bool_t srcTransform = src->common.transform != NULL;
    pixman_bool_t maskTransform = FALSE;
    
    if (srcRepeat && srcTransform &&
	src->bits.width == 1 &&
	src->bits.height == 1)
    {
	srcTransform = FALSE;
    }
    
    if (mask && mask->type == BITS)
    {
	maskRepeat = mask->common.repeat == PIXMAN_REPEAT_NORMAL;
	
	maskTransform = mask->common.transform != 0;
	if (mask->common.filter == PIXMAN_FILTER_CONVOLUTION)
	    maskTransform = TRUE;
	
	if (maskRepeat && maskTransform &&
	    mask->bits.width == 1 &&
	    mask->bits.height == 1)
	{
	    maskTransform = FALSE;
	}
    }
    
    /* CompositeGeneral optimizes 1x1 repeating images itself */
    if (src->type == BITS &&
	src->bits.width == 1 && src->bits.height == 1)
    {
	srcRepeat = FALSE;
    }
    
    if (mask && mask->type == BITS &&
	mask->bits.width == 1 && mask->bits.height == 1)
    {
	maskRepeat = FALSE;
    }
    
    /* if we are transforming, repeats are handled in fbFetchTransformed */
    if (srcTransform)
	srcRepeat = FALSE;
    
    if (maskTransform)
	maskRepeat = FALSE;
    
d271 3
a273 2
				   mask_x, mask_y, dest_x, dest_y, width, height,
				   srcRepeat, maskRepeat, general_composite_rect);
d278 12
a289 9
	     uint32_t *src_bits,
	     uint32_t *dst_bits,
	     int src_stride,
	     int dst_stride,
	     int src_bpp,
	     int dst_bpp,
	     int src_x, int src_y,
	     int dst_x, int dst_y,
	     int width, int height)
d292 1
a292 1
    
d298 8
a305 8
	      uint32_t *bits,
	      int stride,
	      int bpp,
	      int x,
	      int y,
	      int width,
	      int height,
	      uint32_t xor)
d311 1
a311 1
_pixman_implementation_create_general (pixman_implementation_t *toplevel)
d313 1
a313 1
    pixman_implementation_t *imp = _pixman_implementation_create (toplevel, NULL);
d317 1
a317 1
    
d321 1
a321 1
    
d324 1
@


1.1
log
@Update to pixman 0.15.8.
@
text
@d60 1
a60 1
    
d245 1
@

