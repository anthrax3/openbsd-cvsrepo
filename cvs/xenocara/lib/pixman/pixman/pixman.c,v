head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.4
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.2
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.12
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.10
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.6
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.10.01.10.17.44;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	FGr8CFhVerRlpSoE;

1.8
date	2013.12.01.20.34.20;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.18.01;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.02.28.20.36.12;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.14.13.42.50;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to pixman 0.34.0.
@
text
@/* -*- Mode: c; c-basic-offset: 4; tab-width: 8; indent-tabs-mode: t; -*- */
/*
 * Copyright © 2000 SuSE, Inc.
 * Copyright © 2007 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "pixman-private.h"

#include <stdlib.h>

pixman_implementation_t *global_implementation;

#ifdef TOOLCHAIN_SUPPORTS_ATTRIBUTE_CONSTRUCTOR
static void __attribute__((constructor))
pixman_constructor (void)
{
    global_implementation = _pixman_choose_implementation ();
}
#endif

typedef struct operator_info_t operator_info_t;

struct operator_info_t
{
    uint8_t	opaque_info[4];
};

#define PACK(neither, src, dest, both)			\
    {{	    (uint8_t)PIXMAN_OP_ ## neither,		\
	    (uint8_t)PIXMAN_OP_ ## src,			\
	    (uint8_t)PIXMAN_OP_ ## dest,		\
	    (uint8_t)PIXMAN_OP_ ## both		}}

static const operator_info_t operator_table[] =
{
    /*    Neither Opaque         Src Opaque             Dst Opaque             Both Opaque */
    PACK (CLEAR,                 CLEAR,                 CLEAR,                 CLEAR),
    PACK (SRC,                   SRC,                   SRC,                   SRC),
    PACK (DST,                   DST,                   DST,                   DST),
    PACK (OVER,                  SRC,                   OVER,                  SRC),
    PACK (OVER_REVERSE,          OVER_REVERSE,          DST,                   DST),
    PACK (IN,                    IN,                    SRC,                   SRC),
    PACK (IN_REVERSE,            DST,                   IN_REVERSE,            DST),
    PACK (OUT,                   OUT,                   CLEAR,                 CLEAR),
    PACK (OUT_REVERSE,           CLEAR,                 OUT_REVERSE,           CLEAR),
    PACK (ATOP,                  IN,                    OVER,                  SRC),
    PACK (ATOP_REVERSE,          OVER_REVERSE,          IN_REVERSE,            DST),
    PACK (XOR,                   OUT,                   OUT_REVERSE,           CLEAR),
    PACK (ADD,                   ADD,                   ADD,                   ADD),
    PACK (SATURATE,              OVER_REVERSE,          DST,                   DST),

    {{ 0 /* 0x0e */ }},
    {{ 0 /* 0x0f */ }},

    PACK (CLEAR,                 CLEAR,                 CLEAR,                 CLEAR),
    PACK (SRC,                   SRC,                   SRC,                   SRC),
    PACK (DST,                   DST,                   DST,                   DST),
    PACK (DISJOINT_OVER,         DISJOINT_OVER,         DISJOINT_OVER,         DISJOINT_OVER),
    PACK (DISJOINT_OVER_REVERSE, DISJOINT_OVER_REVERSE, DISJOINT_OVER_REVERSE, DISJOINT_OVER_REVERSE),
    PACK (DISJOINT_IN,           DISJOINT_IN,           DISJOINT_IN,           DISJOINT_IN),
    PACK (DISJOINT_IN_REVERSE,   DISJOINT_IN_REVERSE,   DISJOINT_IN_REVERSE,   DISJOINT_IN_REVERSE),
    PACK (DISJOINT_OUT,          DISJOINT_OUT,          DISJOINT_OUT,          DISJOINT_OUT),
    PACK (DISJOINT_OUT_REVERSE,  DISJOINT_OUT_REVERSE,  DISJOINT_OUT_REVERSE,  DISJOINT_OUT_REVERSE),
    PACK (DISJOINT_ATOP,         DISJOINT_ATOP,         DISJOINT_ATOP,         DISJOINT_ATOP),
    PACK (DISJOINT_ATOP_REVERSE, DISJOINT_ATOP_REVERSE, DISJOINT_ATOP_REVERSE, DISJOINT_ATOP_REVERSE),
    PACK (DISJOINT_XOR,          DISJOINT_XOR,          DISJOINT_XOR,          DISJOINT_XOR),

    {{ 0 /* 0x1c */ }},
    {{ 0 /* 0x1d */ }},
    {{ 0 /* 0x1e */ }},
    {{ 0 /* 0x1f */ }},

    PACK (CLEAR,                 CLEAR,                 CLEAR,                 CLEAR),
    PACK (SRC,                   SRC,                   SRC,                   SRC),
    PACK (DST,                   DST,                   DST,                   DST),
    PACK (CONJOINT_OVER,         CONJOINT_OVER,         CONJOINT_OVER,         CONJOINT_OVER),
    PACK (CONJOINT_OVER_REVERSE, CONJOINT_OVER_REVERSE, CONJOINT_OVER_REVERSE, CONJOINT_OVER_REVERSE),
    PACK (CONJOINT_IN,           CONJOINT_IN,           CONJOINT_IN,           CONJOINT_IN),
    PACK (CONJOINT_IN_REVERSE,   CONJOINT_IN_REVERSE,   CONJOINT_IN_REVERSE,   CONJOINT_IN_REVERSE),
    PACK (CONJOINT_OUT,          CONJOINT_OUT,          CONJOINT_OUT,          CONJOINT_OUT),
    PACK (CONJOINT_OUT_REVERSE,  CONJOINT_OUT_REVERSE,  CONJOINT_OUT_REVERSE,  CONJOINT_OUT_REVERSE),
    PACK (CONJOINT_ATOP,         CONJOINT_ATOP,         CONJOINT_ATOP,         CONJOINT_ATOP),
    PACK (CONJOINT_ATOP_REVERSE, CONJOINT_ATOP_REVERSE, CONJOINT_ATOP_REVERSE, CONJOINT_ATOP_REVERSE),
    PACK (CONJOINT_XOR,          CONJOINT_XOR,          CONJOINT_XOR,          CONJOINT_XOR),

    {{ 0 /* 0x2c */ }},
    {{ 0 /* 0x2d */ }},
    {{ 0 /* 0x2e */ }},
    {{ 0 /* 0x2f */ }},

    PACK (MULTIPLY,              MULTIPLY,              MULTIPLY,              MULTIPLY),
    PACK (SCREEN,                SCREEN,                SCREEN,                SCREEN),
    PACK (OVERLAY,               OVERLAY,               OVERLAY,               OVERLAY),
    PACK (DARKEN,                DARKEN,                DARKEN,                DARKEN),
    PACK (LIGHTEN,               LIGHTEN,               LIGHTEN,               LIGHTEN),
    PACK (COLOR_DODGE,           COLOR_DODGE,           COLOR_DODGE,           COLOR_DODGE),
    PACK (COLOR_BURN,            COLOR_BURN,            COLOR_BURN,            COLOR_BURN),
    PACK (HARD_LIGHT,            HARD_LIGHT,            HARD_LIGHT,            HARD_LIGHT),
    PACK (SOFT_LIGHT,            SOFT_LIGHT,            SOFT_LIGHT,            SOFT_LIGHT),
    PACK (DIFFERENCE,            DIFFERENCE,            DIFFERENCE,            DIFFERENCE),
    PACK (EXCLUSION,             EXCLUSION,             EXCLUSION,             EXCLUSION),
    PACK (HSL_HUE,               HSL_HUE,               HSL_HUE,               HSL_HUE),
    PACK (HSL_SATURATION,        HSL_SATURATION,        HSL_SATURATION,        HSL_SATURATION),
    PACK (HSL_COLOR,             HSL_COLOR,             HSL_COLOR,             HSL_COLOR),
    PACK (HSL_LUMINOSITY,        HSL_LUMINOSITY,        HSL_LUMINOSITY,        HSL_LUMINOSITY),
};

/*
 * Optimize the current operator based on opacity of source or destination
 * The output operator should be mathematically equivalent to the source.
 */
static pixman_op_t
optimize_operator (pixman_op_t     op,
		   uint32_t        src_flags,
		   uint32_t        mask_flags,
		   uint32_t        dst_flags)
{
    pixman_bool_t is_source_opaque, is_dest_opaque;

#define OPAQUE_SHIFT 13
    
    COMPILE_TIME_ASSERT (FAST_PATH_IS_OPAQUE == (1 << OPAQUE_SHIFT));
    
    is_dest_opaque = (dst_flags & FAST_PATH_IS_OPAQUE);
    is_source_opaque = ((src_flags & mask_flags) & FAST_PATH_IS_OPAQUE);

    is_dest_opaque >>= OPAQUE_SHIFT - 1;
    is_source_opaque >>= OPAQUE_SHIFT;

    return operator_table[op].opaque_info[is_dest_opaque | is_source_opaque];
}

/*
 * Computing composite region
 */
static inline pixman_bool_t
clip_general_image (pixman_region32_t * region,
                    pixman_region32_t * clip,
                    int                 dx,
                    int                 dy)
{
    if (pixman_region32_n_rects (region) == 1 &&
        pixman_region32_n_rects (clip) == 1)
    {
	pixman_box32_t *  rbox = pixman_region32_rectangles (region, NULL);
	pixman_box32_t *  cbox = pixman_region32_rectangles (clip, NULL);
	int v;

	if (rbox->x1 < (v = cbox->x1 + dx))
	    rbox->x1 = v;
	if (rbox->x2 > (v = cbox->x2 + dx))
	    rbox->x2 = v;
	if (rbox->y1 < (v = cbox->y1 + dy))
	    rbox->y1 = v;
	if (rbox->y2 > (v = cbox->y2 + dy))
	    rbox->y2 = v;
	if (rbox->x1 >= rbox->x2 || rbox->y1 >= rbox->y2)
	{
	    pixman_region32_init (region);
	    return FALSE;
	}
    }
    else if (!pixman_region32_not_empty (clip))
    {
	return FALSE;
    }
    else
    {
	if (dx || dy)
	    pixman_region32_translate (region, -dx, -dy);

	if (!pixman_region32_intersect (region, region, clip))
	    return FALSE;

	if (dx || dy)
	    pixman_region32_translate (region, dx, dy);
    }

    return pixman_region32_not_empty (region);
}

static inline pixman_bool_t
clip_source_image (pixman_region32_t * region,
                   pixman_image_t *    image,
                   int                 dx,
                   int                 dy)
{
    /* Source clips are ignored, unless they are explicitly turned on
     * and the clip in question was set by an X client. (Because if
     * the clip was not set by a client, then it is a hierarchy
     * clip and those should always be ignored for sources).
     */
    if (!image->common.clip_sources || !image->common.client_clip)
	return TRUE;

    return clip_general_image (region,
                               &image->common.clip_region,
                               dx, dy);
}

/*
 * returns FALSE if the final region is empty.  Indistinguishable from
 * an allocation failure, but rendering ignores those anyways.
 */
pixman_bool_t
_pixman_compute_composite_region32 (pixman_region32_t * region,
				    pixman_image_t *    src_image,
				    pixman_image_t *    mask_image,
				    pixman_image_t *    dest_image,
				    int32_t             src_x,
				    int32_t             src_y,
				    int32_t             mask_x,
				    int32_t             mask_y,
				    int32_t             dest_x,
				    int32_t             dest_y,
				    int32_t             width,
				    int32_t             height)
{
    region->extents.x1 = dest_x;
    region->extents.x2 = dest_x + width;
    region->extents.y1 = dest_y;
    region->extents.y2 = dest_y + height;

    region->extents.x1 = MAX (region->extents.x1, 0);
    region->extents.y1 = MAX (region->extents.y1, 0);
    region->extents.x2 = MIN (region->extents.x2, dest_image->bits.width);
    region->extents.y2 = MIN (region->extents.y2, dest_image->bits.height);

    region->data = 0;

    /* Check for empty operation */
    if (region->extents.x1 >= region->extents.x2 ||
        region->extents.y1 >= region->extents.y2)
    {
	region->extents.x1 = 0;
	region->extents.x2 = 0;
	region->extents.y1 = 0;
	region->extents.y2 = 0;
	return FALSE;
    }

    if (dest_image->common.have_clip_region)
    {
	if (!clip_general_image (region, &dest_image->common.clip_region, 0, 0))
	    return FALSE;
    }

    if (dest_image->common.alpha_map)
    {
	if (!pixman_region32_intersect_rect (region, region,
					     dest_image->common.alpha_origin_x,
					     dest_image->common.alpha_origin_y,
					     dest_image->common.alpha_map->width,
					     dest_image->common.alpha_map->height))
	{
	    return FALSE;
	}
	if (!pixman_region32_not_empty (region))
	    return FALSE;
	if (dest_image->common.alpha_map->common.have_clip_region)
	{
	    if (!clip_general_image (region, &dest_image->common.alpha_map->common.clip_region,
				     -dest_image->common.alpha_origin_x,
				     -dest_image->common.alpha_origin_y))
	    {
		return FALSE;
	    }
	}
    }

    /* clip against src */
    if (src_image->common.have_clip_region)
    {
	if (!clip_source_image (region, src_image, dest_x - src_x, dest_y - src_y))
	    return FALSE;
    }
    if (src_image->common.alpha_map && src_image->common.alpha_map->common.have_clip_region)
    {
	if (!clip_source_image (region, (pixman_image_t *)src_image->common.alpha_map,
	                        dest_x - (src_x - src_image->common.alpha_origin_x),
	                        dest_y - (src_y - src_image->common.alpha_origin_y)))
	{
	    return FALSE;
	}
    }
    /* clip against mask */
    if (mask_image && mask_image->common.have_clip_region)
    {
	if (!clip_source_image (region, mask_image, dest_x - mask_x, dest_y - mask_y))
	    return FALSE;

	if (mask_image->common.alpha_map && mask_image->common.alpha_map->common.have_clip_region)
	{
	    if (!clip_source_image (region, (pixman_image_t *)mask_image->common.alpha_map,
	                            dest_x - (mask_x - mask_image->common.alpha_origin_x),
	                            dest_y - (mask_y - mask_image->common.alpha_origin_y)))
	    {
		return FALSE;
	    }
	}
    }

    return TRUE;
}

typedef struct box_48_16 box_48_16_t;

struct box_48_16
{
    pixman_fixed_48_16_t        x1;
    pixman_fixed_48_16_t        y1;
    pixman_fixed_48_16_t        x2;
    pixman_fixed_48_16_t        y2;
};

static pixman_bool_t
compute_transformed_extents (pixman_transform_t   *transform,
			     const pixman_box32_t *extents,
			     box_48_16_t          *transformed)
{
    pixman_fixed_48_16_t tx1, ty1, tx2, ty2;
    pixman_fixed_t x1, y1, x2, y2;
    int i;

    x1 = pixman_int_to_fixed (extents->x1) + pixman_fixed_1 / 2;
    y1 = pixman_int_to_fixed (extents->y1) + pixman_fixed_1 / 2;
    x2 = pixman_int_to_fixed (extents->x2) - pixman_fixed_1 / 2;
    y2 = pixman_int_to_fixed (extents->y2) - pixman_fixed_1 / 2;

    if (!transform)
    {
	transformed->x1 = x1;
	transformed->y1 = y1;
	transformed->x2 = x2;
	transformed->y2 = y2;

	return TRUE;
    }

    tx1 = ty1 = INT64_MAX;
    tx2 = ty2 = INT64_MIN;

    for (i = 0; i < 4; ++i)
    {
	pixman_fixed_48_16_t tx, ty;
	pixman_vector_t v;

	v.vector[0] = (i & 0x01)? x1 : x2;
	v.vector[1] = (i & 0x02)? y1 : y2;
	v.vector[2] = pixman_fixed_1;

	if (!pixman_transform_point (transform, &v))
	    return FALSE;

	tx = (pixman_fixed_48_16_t)v.vector[0];
	ty = (pixman_fixed_48_16_t)v.vector[1];

	if (tx < tx1)
	    tx1 = tx;
	if (ty < ty1)
	    ty1 = ty;
	if (tx > tx2)
	    tx2 = tx;
	if (ty > ty2)
	    ty2 = ty;
    }

    transformed->x1 = tx1;
    transformed->y1 = ty1;
    transformed->x2 = tx2;
    transformed->y2 = ty2;

    return TRUE;
}

#define IS_16BIT(x) (((x) >= INT16_MIN) && ((x) <= INT16_MAX))
#define ABS(f)      (((f) < 0)?  (-(f)) : (f))
#define IS_16_16(f) (((f) >= pixman_min_fixed_48_16 && ((f) <= pixman_max_fixed_48_16)))

static pixman_bool_t
analyze_extent (pixman_image_t       *image,
		const pixman_box32_t *extents,
		uint32_t             *flags)
{
    pixman_transform_t *transform;
    pixman_fixed_t x_off, y_off;
    pixman_fixed_t width, height;
    pixman_fixed_t *params;
    box_48_16_t transformed;
    pixman_box32_t exp_extents;

    if (!image)
	return TRUE;

    /* Some compositing functions walk one step
     * outside the destination rectangle, so we
     * check here that the expanded-by-one source
     * extents in destination space fits in 16 bits
     */
    if (!IS_16BIT (extents->x1 - 1)		||
	!IS_16BIT (extents->y1 - 1)		||
	!IS_16BIT (extents->x2 + 1)		||
	!IS_16BIT (extents->y2 + 1))
    {
	return FALSE;
    }

    transform = image->common.transform;
    if (image->common.type == BITS)
    {
	/* During repeat mode calculations we might convert the
	 * width/height of an image to fixed 16.16, so we need
	 * them to be smaller than 16 bits.
	 */
	if (image->bits.width >= 0x7fff	|| image->bits.height >= 0x7fff)
	    return FALSE;

	if ((image->common.flags & FAST_PATH_ID_TRANSFORM) == FAST_PATH_ID_TRANSFORM &&
	    extents->x1 >= 0 &&
	    extents->y1 >= 0 &&
	    extents->x2 <= image->bits.width &&
	    extents->y2 <= image->bits.height)
	{
	    *flags |= FAST_PATH_SAMPLES_COVER_CLIP_NEAREST;
	    return TRUE;
	}

	switch (image->common.filter)
	{
	case PIXMAN_FILTER_CONVOLUTION:
	    params = image->common.filter_params;
	    x_off = - pixman_fixed_e - ((params[0] - pixman_fixed_1) >> 1);
	    y_off = - pixman_fixed_e - ((params[1] - pixman_fixed_1) >> 1);
	    width = params[0];
	    height = params[1];
	    break;

	case PIXMAN_FILTER_SEPARABLE_CONVOLUTION:
	    params = image->common.filter_params;
	    x_off = - pixman_fixed_e - ((params[0] - pixman_fixed_1) >> 1);
	    y_off = - pixman_fixed_e - ((params[1] - pixman_fixed_1) >> 1);
	    width = params[0];
	    height = params[1];
	    break;
	    
	case PIXMAN_FILTER_GOOD:
	case PIXMAN_FILTER_BEST:
	case PIXMAN_FILTER_BILINEAR:
	    x_off = - pixman_fixed_1 / 2;
	    y_off = - pixman_fixed_1 / 2;
	    width = pixman_fixed_1;
	    height = pixman_fixed_1;
	    break;

	case PIXMAN_FILTER_FAST:
	case PIXMAN_FILTER_NEAREST:
	    x_off = - pixman_fixed_e;
	    y_off = - pixman_fixed_e;
	    width = 0;
	    height = 0;
	    break;

	default:
	    return FALSE;
	}
    }
    else
    {
	x_off = 0;
	y_off = 0;
	width = 0;
	height = 0;
    }

    if (!compute_transformed_extents (transform, extents, &transformed))
	return FALSE;

    if (image->common.type == BITS)
    {
	if (pixman_fixed_to_int (transformed.x1 - pixman_fixed_e) >= 0                &&
	    pixman_fixed_to_int (transformed.y1 - pixman_fixed_e) >= 0                &&
	    pixman_fixed_to_int (transformed.x2 - pixman_fixed_e) < image->bits.width &&
	    pixman_fixed_to_int (transformed.y2 - pixman_fixed_e) < image->bits.height)
	{
	    *flags |= FAST_PATH_SAMPLES_COVER_CLIP_NEAREST;
	}

	if (pixman_fixed_to_int (transformed.x1 - pixman_fixed_1 / 2) >= 0		  &&
	    pixman_fixed_to_int (transformed.y1 - pixman_fixed_1 / 2) >= 0		  &&
	    pixman_fixed_to_int (transformed.x2 + pixman_fixed_1 / 2) < image->bits.width &&
	    pixman_fixed_to_int (transformed.y2 + pixman_fixed_1 / 2) < image->bits.height)
	{
	    *flags |= FAST_PATH_SAMPLES_COVER_CLIP_BILINEAR;
	}
    }

    /* Check we don't overflow when the destination extents are expanded by one.
     * This ensures that compositing functions can simply walk the source space
     * using 16.16 variables without worrying about overflow.
     */
    exp_extents = *extents;
    exp_extents.x1 -= 1;
    exp_extents.y1 -= 1;
    exp_extents.x2 += 1;
    exp_extents.y2 += 1;

    if (!compute_transformed_extents (transform, &exp_extents, &transformed))
	return FALSE;
    
    if (!IS_16_16 (transformed.x1 + x_off - 8 * pixman_fixed_e)	||
	!IS_16_16 (transformed.y1 + y_off - 8 * pixman_fixed_e)	||
	!IS_16_16 (transformed.x2 + x_off + 8 * pixman_fixed_e + width)	||
	!IS_16_16 (transformed.y2 + y_off + 8 * pixman_fixed_e + height))
    {
	return FALSE;
    }

    return TRUE;
}

/*
 * Work around GCC bug causing crashes in Mozilla with SSE2
 *
 * When using -msse, gcc generates movdqa instructions assuming that
 * the stack is 16 byte aligned. Unfortunately some applications, such
 * as Mozilla and Mono, end up aligning the stack to 4 bytes, which
 * causes the movdqa instructions to fail.
 *
 * The __force_align_arg_pointer__ makes gcc generate a prologue that
 * realigns the stack pointer to 16 bytes.
 *
 * On x86-64 this is not necessary because the standard ABI already
 * calls for a 16 byte aligned stack.
 *
 * See https://bugs.freedesktop.org/show_bug.cgi?id=15693
 */
#if defined (USE_SSE2) && defined(__GNUC__) && !defined(__x86_64__) && !defined(__amd64__)
__attribute__((__force_align_arg_pointer__))
#endif
PIXMAN_EXPORT void
pixman_image_composite32 (pixman_op_t      op,
                          pixman_image_t * src,
                          pixman_image_t * mask,
                          pixman_image_t * dest,
                          int32_t          src_x,
                          int32_t          src_y,
                          int32_t          mask_x,
                          int32_t          mask_y,
                          int32_t          dest_x,
                          int32_t          dest_y,
                          int32_t          width,
                          int32_t          height)
{
    pixman_format_code_t src_format, mask_format, dest_format;
    pixman_region32_t region;
    pixman_box32_t extents;
    pixman_implementation_t *imp;
    pixman_composite_func_t func;
    pixman_composite_info_t info;
    const pixman_box32_t *pbox;
    int n;

    _pixman_image_validate (src);
    if (mask)
	_pixman_image_validate (mask);
    _pixman_image_validate (dest);

    src_format = src->common.extended_format_code;
    info.src_flags = src->common.flags;

    if (mask && !(mask->common.flags & FAST_PATH_IS_OPAQUE))
    {
	mask_format = mask->common.extended_format_code;
	info.mask_flags = mask->common.flags;
    }
    else
    {
	mask_format = PIXMAN_null;
	info.mask_flags = FAST_PATH_IS_OPAQUE | FAST_PATH_NO_ALPHA_MAP;
    }

    dest_format = dest->common.extended_format_code;
    info.dest_flags = dest->common.flags;

    /* Check for pixbufs */
    if ((mask_format == PIXMAN_a8r8g8b8 || mask_format == PIXMAN_a8b8g8r8) &&
	(src->type == BITS && src->bits.bits == mask->bits.bits)	   &&
	(src->common.repeat == mask->common.repeat)			   &&
	(info.src_flags & info.mask_flags & FAST_PATH_ID_TRANSFORM)	   &&
	(src_x == mask_x && src_y == mask_y))
    {
	if (src_format == PIXMAN_x8b8g8r8)
	    src_format = mask_format = PIXMAN_pixbuf;
	else if (src_format == PIXMAN_x8r8g8b8)
	    src_format = mask_format = PIXMAN_rpixbuf;
    }

    pixman_region32_init (&region);

    if (!_pixman_compute_composite_region32 (
	    &region, src, mask, dest,
	    src_x, src_y, mask_x, mask_y, dest_x, dest_y, width, height))
    {
	goto out;
    }

    extents = *pixman_region32_extents (&region);

    extents.x1 -= dest_x - src_x;
    extents.y1 -= dest_y - src_y;
    extents.x2 -= dest_x - src_x;
    extents.y2 -= dest_y - src_y;

    if (!analyze_extent (src, &extents, &info.src_flags))
	goto out;

    extents.x1 -= src_x - mask_x;
    extents.y1 -= src_y - mask_y;
    extents.x2 -= src_x - mask_x;
    extents.y2 -= src_y - mask_y;

    if (!analyze_extent (mask, &extents, &info.mask_flags))
	goto out;

    /* If the clip is within the source samples, and the samples are
     * opaque, then the source is effectively opaque.
     */
#define NEAREST_OPAQUE	(FAST_PATH_SAMPLES_OPAQUE |			\
			 FAST_PATH_NEAREST_FILTER |			\
			 FAST_PATH_SAMPLES_COVER_CLIP_NEAREST)
#define BILINEAR_OPAQUE	(FAST_PATH_SAMPLES_OPAQUE |			\
			 FAST_PATH_BILINEAR_FILTER |			\
			 FAST_PATH_SAMPLES_COVER_CLIP_BILINEAR)

    if ((info.src_flags & NEAREST_OPAQUE) == NEAREST_OPAQUE ||
	(info.src_flags & BILINEAR_OPAQUE) == BILINEAR_OPAQUE)
    {
	info.src_flags |= FAST_PATH_IS_OPAQUE;
    }

    if ((info.mask_flags & NEAREST_OPAQUE) == NEAREST_OPAQUE ||
	(info.mask_flags & BILINEAR_OPAQUE) == BILINEAR_OPAQUE)
    {
	info.mask_flags |= FAST_PATH_IS_OPAQUE;
    }

    /*
     * Check if we can replace our operator by a simpler one
     * if the src or dest are opaque. The output operator should be
     * mathematically equivalent to the source.
     */
    info.op = optimize_operator (op, info.src_flags, info.mask_flags, info.dest_flags);

    _pixman_implementation_lookup_composite (
	get_implementation (), info.op,
	src_format, info.src_flags,
	mask_format, info.mask_flags,
	dest_format, info.dest_flags,
	&imp, &func);

    info.src_image = src;
    info.mask_image = mask;
    info.dest_image = dest;

    pbox = pixman_region32_rectangles (&region, &n);

    while (n--)
    {
	info.src_x = pbox->x1 + src_x - dest_x;
	info.src_y = pbox->y1 + src_y - dest_y;
	info.mask_x = pbox->x1 + mask_x - dest_x;
	info.mask_y = pbox->y1 + mask_y - dest_y;
	info.dest_x = pbox->x1;
	info.dest_y = pbox->y1;
	info.width = pbox->x2 - pbox->x1;
	info.height = pbox->y2 - pbox->y1;

	func (imp, &info);

	pbox++;
    }

out:
    pixman_region32_fini (&region);
}

PIXMAN_EXPORT void
pixman_image_composite (pixman_op_t      op,
                        pixman_image_t * src,
                        pixman_image_t * mask,
                        pixman_image_t * dest,
                        int16_t          src_x,
                        int16_t          src_y,
                        int16_t          mask_x,
                        int16_t          mask_y,
                        int16_t          dest_x,
                        int16_t          dest_y,
                        uint16_t         width,
                        uint16_t         height)
{
    pixman_image_composite32 (op, src, mask, dest, src_x, src_y, 
                              mask_x, mask_y, dest_x, dest_y, width, height);
}

PIXMAN_EXPORT pixman_bool_t
pixman_blt (uint32_t *src_bits,
            uint32_t *dst_bits,
            int       src_stride,
            int       dst_stride,
            int       src_bpp,
            int       dst_bpp,
            int       src_x,
            int       src_y,
            int       dest_x,
            int       dest_y,
            int       width,
            int       height)
{
    return _pixman_implementation_blt (get_implementation(),
				       src_bits, dst_bits, src_stride, dst_stride,
                                       src_bpp, dst_bpp,
                                       src_x, src_y,
                                       dest_x, dest_y,
                                       width, height);
}

PIXMAN_EXPORT pixman_bool_t
pixman_fill (uint32_t *bits,
             int       stride,
             int       bpp,
             int       x,
             int       y,
             int       width,
             int       height,
             uint32_t  filler)
{
    return _pixman_implementation_fill (
	get_implementation(), bits, stride, bpp, x, y, width, height, filler);
}

static uint32_t
color_to_uint32 (const pixman_color_t *color)
{
    return
        (color->alpha >> 8 << 24) |
        (color->red >> 8 << 16) |
        (color->green & 0xff00) |
        (color->blue >> 8);
}

static pixman_bool_t
color_to_pixel (const pixman_color_t *color,
                uint32_t *            pixel,
                pixman_format_code_t  format)
{
    uint32_t c = color_to_uint32 (color);

    if (!(format == PIXMAN_a8r8g8b8     ||
          format == PIXMAN_x8r8g8b8     ||
          format == PIXMAN_a8b8g8r8     ||
          format == PIXMAN_x8b8g8r8     ||
          format == PIXMAN_b8g8r8a8     ||
          format == PIXMAN_b8g8r8x8     ||
          format == PIXMAN_r8g8b8a8     ||
          format == PIXMAN_r8g8b8x8     ||
          format == PIXMAN_r5g6b5       ||
          format == PIXMAN_b5g6r5       ||
          format == PIXMAN_a8           ||
          format == PIXMAN_a1))
    {
	return FALSE;
    }

    if (PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_ABGR)
    {
	c = ((c & 0xff000000) >>  0) |
	    ((c & 0x00ff0000) >> 16) |
	    ((c & 0x0000ff00) >>  0) |
	    ((c & 0x000000ff) << 16);
    }
    if (PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_BGRA)
    {
	c = ((c & 0xff000000) >> 24) |
	    ((c & 0x00ff0000) >>  8) |
	    ((c & 0x0000ff00) <<  8) |
	    ((c & 0x000000ff) << 24);
    }
    if (PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_RGBA)
	c = ((c & 0xff000000) >> 24) | (c << 8);

    if (format == PIXMAN_a1)
	c = c >> 31;
    else if (format == PIXMAN_a8)
	c = c >> 24;
    else if (format == PIXMAN_r5g6b5 ||
             format == PIXMAN_b5g6r5)
	c = convert_8888_to_0565 (c);

#if 0
    printf ("color: %x %x %x %x\n", color->alpha, color->red, color->green, color->blue);
    printf ("pixel: %x\n", c);
#endif

    *pixel = c;
    return TRUE;
}

PIXMAN_EXPORT pixman_bool_t
pixman_image_fill_rectangles (pixman_op_t                 op,
                              pixman_image_t *            dest,
			      const pixman_color_t *      color,
                              int                         n_rects,
                              const pixman_rectangle16_t *rects)
{
    pixman_box32_t stack_boxes[6];
    pixman_box32_t *boxes;
    pixman_bool_t result;
    int i;

    if (n_rects > 6)
    {
        boxes = pixman_malloc_ab (sizeof (pixman_box32_t), n_rects);
        if (boxes == NULL)
            return FALSE;
    }
    else
    {
        boxes = stack_boxes;
    }

    for (i = 0; i < n_rects; ++i)
    {
        boxes[i].x1 = rects[i].x;
        boxes[i].y1 = rects[i].y;
        boxes[i].x2 = boxes[i].x1 + rects[i].width;
        boxes[i].y2 = boxes[i].y1 + rects[i].height;
    }

    result = pixman_image_fill_boxes (op, dest, color, n_rects, boxes);

    if (boxes != stack_boxes)
        free (boxes);
    
    return result;
}

PIXMAN_EXPORT pixman_bool_t
pixman_image_fill_boxes (pixman_op_t           op,
                         pixman_image_t *      dest,
                         const pixman_color_t *color,
                         int                   n_boxes,
                         const pixman_box32_t *boxes)
{
    pixman_image_t *solid;
    pixman_color_t c;
    int i;

    _pixman_image_validate (dest);
    
    if (color->alpha == 0xffff)
    {
        if (op == PIXMAN_OP_OVER)
            op = PIXMAN_OP_SRC;
    }

    if (op == PIXMAN_OP_CLEAR)
    {
        c.red = 0;
        c.green = 0;
        c.blue = 0;
        c.alpha = 0;

        color = &c;

        op = PIXMAN_OP_SRC;
    }

    if (op == PIXMAN_OP_SRC)
    {
        uint32_t pixel;

        if (color_to_pixel (color, &pixel, dest->bits.format))
        {
            pixman_region32_t fill_region;
            int n_rects, j;
            pixman_box32_t *rects;

            if (!pixman_region32_init_rects (&fill_region, boxes, n_boxes))
                return FALSE;

            if (dest->common.have_clip_region)
            {
                if (!pixman_region32_intersect (&fill_region,
                                                &fill_region,
                                                &dest->common.clip_region))
                    return FALSE;
            }

            rects = pixman_region32_rectangles (&fill_region, &n_rects);
            for (j = 0; j < n_rects; ++j)
            {
                const pixman_box32_t *rect = &(rects[j]);
                pixman_fill (dest->bits.bits, dest->bits.rowstride, PIXMAN_FORMAT_BPP (dest->bits.format),
                             rect->x1, rect->y1, rect->x2 - rect->x1, rect->y2 - rect->y1,
                             pixel);
            }

            pixman_region32_fini (&fill_region);
            return TRUE;
        }
    }

    solid = pixman_image_create_solid_fill (color);
    if (!solid)
        return FALSE;

    for (i = 0; i < n_boxes; ++i)
    {
        const pixman_box32_t *box = &(boxes[i]);

        pixman_image_composite32 (op, solid, NULL, dest,
                                  0, 0, 0, 0,
                                  box->x1, box->y1,
                                  box->x2 - box->x1, box->y2 - box->y1);
    }

    pixman_image_unref (solid);

    return TRUE;
}

/**
 * pixman_version:
 *
 * Returns the version of the pixman library encoded in a single
 * integer as per %PIXMAN_VERSION_ENCODE. The encoding ensures that
 * later versions compare greater than earlier versions.
 *
 * A run-time comparison to check that pixman's version is greater than
 * or equal to version X.Y.Z could be performed as follows:
 *
 * <informalexample><programlisting>
 * if (pixman_version() >= PIXMAN_VERSION_ENCODE(X,Y,Z)) {...}
 * </programlisting></informalexample>
 *
 * See also pixman_version_string() as well as the compile-time
 * equivalents %PIXMAN_VERSION and %PIXMAN_VERSION_STRING.
 *
 * Return value: the encoded version.
 **/
PIXMAN_EXPORT int
pixman_version (void)
{
    return PIXMAN_VERSION;
}

/**
 * pixman_version_string:
 *
 * Returns the version of the pixman library as a human-readable string
 * of the form "X.Y.Z".
 *
 * See also pixman_version() as well as the compile-time equivalents
 * %PIXMAN_VERSION_STRING and %PIXMAN_VERSION.
 *
 * Return value: a string containing the version.
 **/
PIXMAN_EXPORT const char*
pixman_version_string (void)
{
    return PIXMAN_VERSION_STRING;
}

/**
 * pixman_format_supported_source:
 * @@format: A pixman_format_code_t format
 *
 * Return value: whether the provided format code is a supported
 * format for a pixman surface used as a source in
 * rendering.
 *
 * Currently, all pixman_format_code_t values are supported.
 **/
PIXMAN_EXPORT pixman_bool_t
pixman_format_supported_source (pixman_format_code_t format)
{
    switch (format)
    {
    /* 32 bpp formats */
    case PIXMAN_a2b10g10r10:
    case PIXMAN_x2b10g10r10:
    case PIXMAN_a2r10g10b10:
    case PIXMAN_x2r10g10b10:
    case PIXMAN_a8r8g8b8:
    case PIXMAN_a8r8g8b8_sRGB:
    case PIXMAN_x8r8g8b8:
    case PIXMAN_a8b8g8r8:
    case PIXMAN_x8b8g8r8:
    case PIXMAN_b8g8r8a8:
    case PIXMAN_b8g8r8x8:
    case PIXMAN_r8g8b8a8:
    case PIXMAN_r8g8b8x8:
    case PIXMAN_r8g8b8:
    case PIXMAN_b8g8r8:
    case PIXMAN_r5g6b5:
    case PIXMAN_b5g6r5:
    case PIXMAN_x14r6g6b6:
    /* 16 bpp formats */
    case PIXMAN_a1r5g5b5:
    case PIXMAN_x1r5g5b5:
    case PIXMAN_a1b5g5r5:
    case PIXMAN_x1b5g5r5:
    case PIXMAN_a4r4g4b4:
    case PIXMAN_x4r4g4b4:
    case PIXMAN_a4b4g4r4:
    case PIXMAN_x4b4g4r4:
    /* 8bpp formats */
    case PIXMAN_a8:
    case PIXMAN_r3g3b2:
    case PIXMAN_b2g3r3:
    case PIXMAN_a2r2g2b2:
    case PIXMAN_a2b2g2r2:
    case PIXMAN_c8:
    case PIXMAN_g8:
    case PIXMAN_x4a4:
    /* Collides with PIXMAN_c8
       case PIXMAN_x4c4:
     */
    /* Collides with PIXMAN_g8
       case PIXMAN_x4g4:
     */
    /* 4bpp formats */
    case PIXMAN_a4:
    case PIXMAN_r1g2b1:
    case PIXMAN_b1g2r1:
    case PIXMAN_a1r1g1b1:
    case PIXMAN_a1b1g1r1:
    case PIXMAN_c4:
    case PIXMAN_g4:
    /* 1bpp formats */
    case PIXMAN_a1:
    case PIXMAN_g1:
    /* YUV formats */
    case PIXMAN_yuy2:
    case PIXMAN_yv12:
	return TRUE;

    default:
	return FALSE;
    }
}

/**
 * pixman_format_supported_destination:
 * @@format: A pixman_format_code_t format
 *
 * Return value: whether the provided format code is a supported
 * format for a pixman surface used as a destination in
 * rendering.
 *
 * Currently, all pixman_format_code_t values are supported
 * except for the YUV formats.
 **/
PIXMAN_EXPORT pixman_bool_t
pixman_format_supported_destination (pixman_format_code_t format)
{
    /* YUV formats cannot be written to at the moment */
    if (format == PIXMAN_yuy2 || format == PIXMAN_yv12)
	return FALSE;

    return pixman_format_supported_source (format);
}

PIXMAN_EXPORT pixman_bool_t
pixman_compute_composite_region (pixman_region16_t * region,
                                 pixman_image_t *    src_image,
                                 pixman_image_t *    mask_image,
                                 pixman_image_t *    dest_image,
                                 int16_t             src_x,
                                 int16_t             src_y,
                                 int16_t             mask_x,
                                 int16_t             mask_y,
                                 int16_t             dest_x,
                                 int16_t             dest_y,
                                 uint16_t            width,
                                 uint16_t            height)
{
    pixman_region32_t r32;
    pixman_bool_t retval;

    pixman_region32_init (&r32);

    retval = _pixman_compute_composite_region32 (
	&r32, src_image, mask_image, dest_image,
	src_x, src_y, mask_x, mask_y, dest_x, dest_y,
	width, height);

    if (retval)
    {
	if (!pixman_region16_copy_from_region32 (region, &r32))
	    retval = FALSE;
    }

    pixman_region32_fini (&r32);
    return retval;
}
@


1.8
log
@Update to pixman 0.32.4. Tested by naddy@@ and ajacoutot@@
@
text
@d328 3
a330 1
typedef struct
d332 5
a336 5
    pixman_fixed_48_16_t	x1;
    pixman_fixed_48_16_t	y1;
    pixman_fixed_48_16_t	x2;
    pixman_fixed_48_16_t	y2;
} box_48_16_t;
d339 1
a339 1
compute_transformed_extents (pixman_transform_t *transform,
d341 1
a341 1
			     box_48_16_t *transformed)
a499 9
    /* Expand the source area by a tiny bit so account of different rounding that
     * may happen during sampling. Note that (8 * pixman_fixed_e) is very far from
     * 0.5 so this won't cause the area computed to be overly pessimistic.
     */
    transformed.x1 -= 8 * pixman_fixed_e;
    transformed.y1 -= 8 * pixman_fixed_e;
    transformed.x2 += 8 * pixman_fixed_e;
    transformed.y2 += 8 * pixman_fixed_e;

d502 4
a505 4
	if (pixman_fixed_to_int (transformed.x1) >= 0			&&
	    pixman_fixed_to_int (transformed.y1) >= 0			&&
	    pixman_fixed_to_int (transformed.x2) < image->bits.width	&&
	    pixman_fixed_to_int (transformed.y2) < image->bits.height)
@


1.7
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@d608 1
a608 1
	info.mask_flags = FAST_PATH_IS_OPAQUE;
@


1.6
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@d458 8
a583 1
    uint32_t src_flags, mask_flags, dest_flags;
d588 3
d598 1
a598 1
    src_flags = src->common.flags;
d600 1
a600 1
    if (mask)
d603 1
a603 1
	mask_flags = mask->common.flags;
d608 1
a608 1
	mask_flags = FAST_PATH_IS_OPAQUE;
d612 1
a612 1
    dest_flags = dest->common.flags;
d618 1
a618 1
	(src_flags & mask_flags & FAST_PATH_ID_TRANSFORM)		   &&
d643 1
a643 1
    if (!analyze_extent (src, &extents, &src_flags))
d651 1
a651 1
    if (!analyze_extent (mask, &extents, &mask_flags))
d664 2
a665 2
    if ((src_flags & NEAREST_OPAQUE) == NEAREST_OPAQUE ||
	(src_flags & BILINEAR_OPAQUE) == BILINEAR_OPAQUE)
d667 1
a667 1
	src_flags |= FAST_PATH_IS_OPAQUE;
d670 2
a671 2
    if ((mask_flags & NEAREST_OPAQUE) == NEAREST_OPAQUE ||
	(mask_flags & BILINEAR_OPAQUE) == BILINEAR_OPAQUE)
d673 1
a673 1
	mask_flags |= FAST_PATH_IS_OPAQUE;
d681 1
a681 18
    op = optimize_operator (op, src_flags, mask_flags, dest_flags);

    if (_pixman_implementation_lookup_composite (
	    get_implementation (), op,
	    src_format, src_flags, mask_format, mask_flags, dest_format, dest_flags,
	    &imp, &func))
    {
	pixman_composite_info_t info;
	const pixman_box32_t *pbox;
	int n;

	info.op = op;
	info.src_image = src;
	info.mask_image = mask;
	info.dest_image = dest;
	info.src_flags = src_flags;
	info.mask_flags = mask_flags;
	info.dest_flags = dest_flags;
d683 23
a705 1
	pbox = pixman_region32_rectangles (&region, &n);
d707 1
a707 12
	while (n--)
	{
	    info.src_x = pbox->x1 + src_x - dest_x;
	    info.src_y = pbox->y1 + src_y - dest_y;
	    info.mask_x = pbox->x1 + mask_x - dest_x;
	    info.mask_y = pbox->y1 + mask_y - dest_y;
	    info.dest_x = pbox->x1;
	    info.dest_y = pbox->y1;
	    info.width = pbox->x2 - pbox->x1;
	    info.height = pbox->y2 - pbox->y1;

	    func (imp, &info);
d709 1
a709 2
	    pbox++;
	}
d764 1
a764 1
             uint32_t xor)
d767 1
a767 1
	get_implementation(), bits, stride, bpp, x, y, width, height, xor);
d826 1
a826 1
	c = CONVERT_8888_TO_0565 (c);
@


1.5
log
@Update to pixman 0.22.4. Tested by shadchin@@, krw@@.
@
text
@d33 1
a33 1
static pixman_implementation_t *global_implementation;
a42 10
static force_inline pixman_implementation_t *
get_implementation (void)
{
#ifndef TOOLCHAIN_SUPPORTS_ATTRIBUTE_CONSTRUCTOR
    if (!global_implementation)
	global_implementation = _pixman_choose_implementation ();
#endif
    return global_implementation;
}

d227 13
a239 13
static pixman_bool_t
pixman_compute_composite_region32 (pixman_region32_t * region,
                                   pixman_image_t *    src_image,
                                   pixman_image_t *    mask_image,
                                   pixman_image_t *    dest_image,
                                   int32_t             src_x,
                                   int32_t             src_y,
                                   int32_t             mask_x,
                                   int32_t             mask_y,
                                   int32_t             dest_x,
                                   int32_t             dest_y,
                                   int32_t             width,
                                   int32_t             height)
d608 1
d619 1
a619 1
    if (!pixman_compute_composite_region32 (
d673 1
a673 1
    if (_pixman_lookup_composite_function (
d778 3
a780 3
color_to_pixel (pixman_color_t *     color,
                uint32_t *           pixel,
                pixman_format_code_t format)
d837 1
a837 1
                              pixman_color_t *            color,
d876 1
a876 1
                         pixman_color_t *      color,
d1021 1
d1119 1
a1119 1
    retval = pixman_compute_composite_region32 (
@


1.4
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d241 1
a241 1
                                   pixman_image_t *    dst_image,
d258 2
a259 2
    region->extents.x2 = MIN (region->extents.x2, dst_image->bits.width);
    region->extents.y2 = MIN (region->extents.y2, dst_image->bits.height);
d274 1
a274 1
    if (dst_image->common.have_clip_region)
d276 1
a276 1
	if (!clip_general_image (region, &dst_image->common.clip_region, 0, 0))
d280 1
a280 1
    if (dst_image->common.alpha_map)
d283 4
a286 4
					     dst_image->common.alpha_origin_x,
					     dst_image->common.alpha_origin_y,
					     dst_image->common.alpha_map->width,
					     dst_image->common.alpha_map->height))
d292 1
a292 1
	if (dst_image->common.alpha_map->common.have_clip_region)
d294 3
a296 3
	    if (!clip_general_image (region, &dst_image->common.alpha_map->common.clip_region,
				     -dst_image->common.alpha_origin_x,
				     -dst_image->common.alpha_origin_y))
a337 2
#define N_CACHED_FAST_PATHS 8

d340 5
a344 106
    struct
    {
	pixman_implementation_t *	imp;
	pixman_fast_path_t		fast_path;
    } cache [N_CACHED_FAST_PATHS];
} cache_t;

PIXMAN_DEFINE_THREAD_LOCAL (cache_t, fast_path_cache);

static force_inline pixman_bool_t
lookup_composite_function (pixman_op_t			op,
			   pixman_format_code_t		src_format,
			   uint32_t			src_flags,
			   pixman_format_code_t		mask_format,
			   uint32_t			mask_flags,
			   pixman_format_code_t		dest_format,
			   uint32_t			dest_flags,
			   pixman_implementation_t    **out_imp,
			   pixman_composite_func_t     *out_func)
{
    pixman_implementation_t *imp;
    cache_t *cache;
    int i;

    /* Check cache for fast paths */
    cache = PIXMAN_GET_THREAD_LOCAL (fast_path_cache);

    for (i = 0; i < N_CACHED_FAST_PATHS; ++i)
    {
	const pixman_fast_path_t *info = &(cache->cache[i].fast_path);

	/* Note that we check for equality here, not whether
	 * the cached fast path matches. This is to prevent
	 * us from selecting an overly general fast path
	 * when a more specific one would work.
	 */
	if (info->op == op			&&
	    info->src_format == src_format	&&
	    info->mask_format == mask_format	&&
	    info->dest_format == dest_format	&&
	    info->src_flags == src_flags	&&
	    info->mask_flags == mask_flags	&&
	    info->dest_flags == dest_flags	&&
	    info->func)
	{
	    *out_imp = cache->cache[i].imp;
	    *out_func = cache->cache[i].fast_path.func;

	    goto update_cache;
	}
    }

    for (imp = get_implementation (); imp != NULL; imp = imp->delegate)
    {
	const pixman_fast_path_t *info = imp->fast_paths;

	while (info->op != PIXMAN_OP_NONE)
	{
	    if ((info->op == op || info->op == PIXMAN_OP_any)		&&
		/* Formats */
		((info->src_format == src_format) ||
		 (info->src_format == PIXMAN_any))			&&
		((info->mask_format == mask_format) ||
		 (info->mask_format == PIXMAN_any))			&&
		((info->dest_format == dest_format) ||
		 (info->dest_format == PIXMAN_any))			&&
		/* Flags */
		(info->src_flags & src_flags) == info->src_flags	&&
		(info->mask_flags & mask_flags) == info->mask_flags	&&
		(info->dest_flags & dest_flags) == info->dest_flags)
	    {
		*out_imp = imp;
		*out_func = info->func;

		/* Set i to the last spot in the cache so that the
		 * move-to-front code below will work
		 */
		i = N_CACHED_FAST_PATHS - 1;

		goto update_cache;
	    }

	    ++info;
	}
    }
    return FALSE;

update_cache:
    if (i)
    {
	while (i--)
	    cache->cache[i + 1] = cache->cache[i];

	cache->cache[0].imp = *out_imp;
	cache->cache[0].fast_path.op = op;
	cache->cache[0].fast_path.src_format = src_format;
	cache->cache[0].fast_path.src_flags = src_flags;
	cache->cache[0].fast_path.mask_format = mask_format;
	cache->cache[0].fast_path.mask_flags = mask_flags;
	cache->cache[0].fast_path.dest_format = dest_format;
	cache->cache[0].fast_path.dest_flags = dest_flags;
	cache->cache[0].fast_path.func = *out_func;
    }

    return TRUE;
}
d347 3
a349 4
compute_sample_extents (pixman_transform_t *transform,
			pixman_box32_t *extents, int x, int y, 
			pixman_fixed_t x_off, pixman_fixed_t y_off,
			pixman_fixed_t width, pixman_fixed_t height)
d351 1
d353 1
a353 1
    pixman_fixed_48_16_t tx1, ty1, tx2, ty2;
d355 4
a358 5
    /* We have checked earlier that (extents->x1 - x) etc. fit in a pixman_fixed_t */
    x1 = (pixman_fixed_48_16_t)pixman_int_to_fixed (extents->x1 - x) + pixman_fixed_1 / 2;
    y1 = (pixman_fixed_48_16_t)pixman_int_to_fixed (extents->y1 - y) + pixman_fixed_1 / 2;
    x2 = (pixman_fixed_48_16_t)pixman_int_to_fixed (extents->x2 - x) - pixman_fixed_1 / 2;
    y2 = (pixman_fixed_48_16_t)pixman_int_to_fixed (extents->y2 - y) - pixman_fixed_1 / 2;
d362 6
a367 4
	tx1 = (pixman_fixed_48_16_t)x1;
	ty1 = (pixman_fixed_48_16_t)y1;
	tx2 = (pixman_fixed_48_16_t)x2;
	ty2 = (pixman_fixed_48_16_t)y2;
a368 3
    else
    {
	int i;
d370 2
a371 7
	/* Silence GCC */
	tx1 = ty1 = tx2 = ty2 = 0;
    
	for (i = 0; i < 4; ++i)
	{
	    pixman_fixed_48_16_t tx, ty;
	    pixman_vector_t v;
d373 4
a376 3
	    v.vector[0] = (i & 0x01)? x1 : x2;
	    v.vector[1] = (i & 0x02)? y1 : y2;
	    v.vector[2] = pixman_fixed_1;
d378 3
a380 2
	    if (!pixman_transform_point (transform, &v))
		return FALSE;
d382 2
a383 2
	    tx = (pixman_fixed_48_16_t)v.vector[0];
	    ty = (pixman_fixed_48_16_t)v.vector[1];
d385 2
a386 20
	    if (i == 0)
	    {
		tx1 = tx;
		ty1 = ty;
		tx2 = tx;
		ty2 = ty;
	    }
	    else
	    {
		if (tx < tx1)
		    tx1 = tx;
		if (ty < ty1)
		    ty1 = ty;
		if (tx > tx2)
		    tx2 = tx;
		if (ty > ty2)
		    ty2 = ty;
	    }
	}
    }
d388 14
a401 22
    /* Expand the source area by a tiny bit so account of different rounding that
     * may happen during sampling. Note that (8 * pixman_fixed_e) is very far from
     * 0.5 so this won't cause the area computed to be overly pessimistic.
     */
    tx1 += x_off - 8 * pixman_fixed_e;
    ty1 += y_off - 8 * pixman_fixed_e;
    tx2 += x_off + width + 8 * pixman_fixed_e;
    ty2 += y_off + height + 8 * pixman_fixed_e;

    if (tx1 < pixman_min_fixed_48_16 || tx1 > pixman_max_fixed_48_16 ||
	ty1 < pixman_min_fixed_48_16 || ty1 > pixman_max_fixed_48_16 ||
	tx2 < pixman_min_fixed_48_16 || tx2 > pixman_max_fixed_48_16 ||
	ty2 < pixman_min_fixed_48_16 || ty2 > pixman_max_fixed_48_16)
    {
	return FALSE;
    }
    else
    {
	extents->x1 = pixman_fixed_to_int (tx1);
	extents->y1 = pixman_fixed_to_int (ty1);
	extents->x2 = pixman_fixed_to_int (tx2) + 1;
	extents->y2 = pixman_fixed_to_int (ty2) + 1;
d403 1
a403 2
	return TRUE;
    }
d407 2
d411 3
a413 2
analyze_extent (pixman_image_t *image, int x, int y,
		const pixman_box32_t *extents, uint32_t *flags)
a415 1
    pixman_fixed_t *params;
d418 3
a420 1
    pixman_box32_t ex;
d430 4
a433 4
    if (!IS_16BIT (extents->x1 - x - 1)		||
	!IS_16BIT (extents->y1 - y - 1)		||
	!IS_16BIT (extents->x2 - x + 1)		||
	!IS_16BIT (extents->y2 - y + 1))
d448 5
a452 7
#define ID_AND_NEAREST (FAST_PATH_ID_TRANSFORM | FAST_PATH_NEAREST_FILTER)
	
	if ((image->common.flags & ID_AND_NEAREST) == ID_AND_NEAREST &&
	    extents->x1 - x >= 0 &&
	    extents->y1 - y >= 0 &&
	    extents->x2 - x <= image->bits.width &&
	    extents->y2 - y <= image->bits.height)
d454 1
a454 1
	    *flags |= FAST_PATH_SAMPLES_COVER_CLIP;
d457 1
a457 1
    
a487 11

	/* Check whether the non-expanded, transformed extent is entirely within
	 * the source image, and set the FAST_PATH_SAMPLES_COVER_CLIP if it is.
	 */
	ex = *extents;
	if (compute_sample_extents (transform, &ex, x, y, x_off, y_off, width, height) &&
	    ex.x1 >= 0 && ex.y1 >= 0 &&
	    ex.x2 <= image->bits.width && ex.y2 <= image->bits.height)
	{
	    *flags |= FAST_PATH_SAMPLES_COVER_CLIP;
	}
d497 34
a530 3
    /* Check that the extents expanded by one don't overflow. This ensures that
     * compositing functions can simply walk the source space using 16.16
     * variables without worrying about overflow.
d532 5
a536 4
    ex.x1 = extents->x1 - 1;
    ex.y1 = extents->y1 - 1;
    ex.x2 = extents->x2 + 1;
    ex.y2 = extents->y2 + 1;
d538 1
a538 1
    if (!compute_sample_extents (transform, &ex, x, y, x_off, y_off, width, height))
d540 8
d588 1
a588 1
    pixman_box32_t *extents;
d635 6
a640 1
    extents = pixman_region32_extents (&region);
d642 1
a642 1
    if (!analyze_extent (src, dest_x - src_x, dest_y - src_y, extents, &src_flags))
d645 6
a650 1
    if (!analyze_extent (mask, dest_x - mask_x, dest_y - mask_y, extents, &mask_flags))
d653 2
a654 2
    /* If the clip is within the source samples, and the samples are opaque,
     * then the source is effectively opaque.
d656 6
a661 1
#define BOTH (FAST_PATH_SAMPLES_OPAQUE | FAST_PATH_SAMPLES_COVER_CLIP)
d663 3
a665 1
    if ((src_flags & BOTH) == BOTH)
d667 5
a671 2
    
    if ((mask_flags & BOTH) == BOTH)
d673 2
a674 1
    
a680 2
    if (op == PIXMAN_OP_DST)
	goto out;
d682 4
a685 5
    if (lookup_composite_function (op,
				   src_format, src_flags,
				   mask_format, mask_flags,
				   dest_format, dest_flags,
				   &imp, &func))
d687 1
d691 8
d700 1
a700 1
	
d703 11
a713 11
	    func (imp, op,
		  src, mask, dest,
		  pbox->x1 + src_x - dest_x,
		  pbox->y1 + src_y - dest_y,
		  pbox->x1 + mask_x - dest_x,
		  pbox->y1 + mask_y - dest_y,
		  pbox->x1,
		  pbox->y1,
		  pbox->x2 - pbox->x1,
		  pbox->y2 - pbox->y1);
	    
d749 2
a750 2
            int       dst_x,
            int       dst_y,
d758 1
a758 1
                                       dst_x, dst_y,
d1112 1
a1112 1
                                 pixman_image_t *    dst_image,
d1128 1
a1128 1
	&r32, src_image, mask_image, dst_image,
@


1.3
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@d33 10
d46 1
a46 2
    static pixman_implementation_t *global_implementation;

d49 1
a49 1

a164 51
static void
apply_workaround (pixman_image_t *image,
		  int32_t *       x,
		  int32_t *       y,
		  uint32_t **     save_bits,
		  int *           save_dx,
		  int *           save_dy)
{
    if (image && (image->common.flags & FAST_PATH_NEEDS_WORKAROUND))
    {
	/* Some X servers generate images that point to the
	 * wrong place in memory, but then set the clip region
	 * to point to the right place. Because of an old bug
	 * in pixman, this would actually work.
	 *
	 * Here we try and undo the damage
	 */
	int bpp = PIXMAN_FORMAT_BPP (image->bits.format) / 8;
	pixman_box32_t *extents;
	uint8_t *t;
	int dx, dy;
	
	extents = pixman_region32_extents (&(image->common.clip_region));
	dx = extents->x1;
	dy = extents->y1;
	
	*save_bits = image->bits.bits;
	
	*x -= dx;
	*y -= dy;
	pixman_region32_translate (&(image->common.clip_region), -dx, -dy);
	
	t = (uint8_t *)image->bits.bits;
	t += dy * image->bits.rowstride * 4 + dx * bpp;
	image->bits.bits = (uint32_t *)t;
	
	*save_dx = dx;
	*save_dy = dy;
    }
}

static void
unapply_workaround (pixman_image_t *image, uint32_t *bits, int dx, int dy)
{
    if (image && (image->common.flags & FAST_PATH_NEEDS_WORKAROUND))
    {
	image->bits.bits = bits;
	pixman_region32_translate (&image->common.clip_region, dx, dy);
    }
}

a692 7
    uint32_t *src_bits;
    int src_dx, src_dy;
    uint32_t *mask_bits;
    int mask_dx, mask_dy;
    uint32_t *dest_bits;
    int dest_dx, dest_dy;
    pixman_bool_t need_workaround;
a729 10
    /* Check for workaround */
    need_workaround = (src_flags | mask_flags | dest_flags) & FAST_PATH_NEEDS_WORKAROUND;

    if (need_workaround)
    {
	apply_workaround (src, &src_x, &src_y, &src_bits, &src_dx, &src_dy);
	apply_workaround (mask, &mask_x, &mask_y, &mask_bits, &mask_dx, &mask_dy);
	apply_workaround (dest, &dest_x, &dest_y, &dest_bits, &dest_dx, &dest_dy);
    }

a795 7
    if (need_workaround)
    {
	unapply_workaround (src, src_bits, src_dx, src_dy);
	unapply_workaround (mask, mask_bits, mask_dx, mask_dy);
	unapply_workaround (dest, dest_bits, dest_dx, dest_dy);
    }

d876 2
d880 2
a881 1
          format == PIXMAN_a8))
d900 2
d903 3
a905 1
    if (format == PIXMAN_a8)
d1112 2
@


1.2
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d33 10
a42 1
static pixman_implementation_t *imp;
a141 1
    int opaqueness;
d143 6
a148 2
    is_source_opaque = ((src_flags & mask_flags) & FAST_PATH_IS_OPAQUE) != 0;
    is_dest_opaque = (dst_flags & FAST_PATH_IS_OPAQUE) != 0;
d150 2
a151 1
    opaqueness = ((is_dest_opaque << 1) | is_source_opaque);
d153 1
a153 1
    return operator_table[op].opaque_info[opaqueness];
d309 4
a312 1
	pixman_region32_init (region);
a318 2
	{
	    pixman_region32_fini (region);
a319 1
	}
d322 1
a322 1
    if (dst_image->common.alpha_map && dst_image->common.alpha_map->common.have_clip_region)
d324 5
a328 3
	if (!clip_general_image (region, &dst_image->common.alpha_map->common.clip_region,
	                         -dst_image->common.alpha_origin_x,
	                         -dst_image->common.alpha_origin_y))
a329 1
	    pixman_region32_fini (region);
d332 11
a348 2
	{
	    pixman_region32_fini (region);
a349 1
	}
a356 1
	    pixman_region32_fini (region);
a363 2
	{
	    pixman_region32_fini (region);
d365 1
a365 1
	}
a371 1
		pixman_region32_fini (region);
d380 51
a430 48
static void
walk_region_internal (pixman_implementation_t *imp,
                      pixman_op_t              op,
                      pixman_image_t *         src_image,
                      pixman_image_t *         mask_image,
                      pixman_image_t *         dst_image,
                      int32_t                  src_x,
                      int32_t                  src_y,
                      int32_t                  mask_x,
                      int32_t                  mask_y,
                      int32_t                  dest_x,
                      int32_t                  dest_y,
                      int32_t                  width,
                      int32_t                  height,
                      pixman_bool_t            src_repeat,
                      pixman_bool_t            mask_repeat,
                      pixman_region32_t *      region,
                      pixman_composite_func_t  composite_rect)
{
    int w, h, w_this, h_this;
    int x_msk, y_msk, x_src, y_src, x_dst, y_dst;
    int src_dy = src_y - dest_y;
    int src_dx = src_x - dest_x;
    int mask_dy = mask_y - dest_y;
    int mask_dx = mask_x - dest_x;
    const pixman_box32_t *pbox;
    int n;

    pbox = pixman_region32_rectangles (region, &n);

    /* Fast path for non-repeating sources */
    if (!src_repeat && !mask_repeat)
    {
       while (n--)
       {
           (*composite_rect) (imp, op,
                              src_image, mask_image, dst_image,
                              pbox->x1 + src_dx,
                              pbox->y1 + src_dy,
                              pbox->x1 + mask_dx,
                              pbox->y1 + mask_dy,
                              pbox->x1,
                              pbox->y1,
                              pbox->x2 - pbox->x1,
                              pbox->y2 - pbox->y1);
           
           pbox++;
       }
d432 2
a433 1
       return;
d435 2
a436 2
    
    while (n--)
d438 1
a438 4
	h = pbox->y2 - pbox->y1;
	y_src = pbox->y1 + src_dy;
	y_msk = pbox->y1 + mask_dy;
	y_dst = pbox->y1;
d440 1
a440 1
	while (h)
d442 15
a456 5
	    h_this = h;
	    w = pbox->x2 - pbox->x1;
	    x_src = pbox->x1 + src_dx;
	    x_msk = pbox->x1 + mask_dx;
	    x_dst = pbox->x1;
d458 6
a463 5
	    if (mask_repeat)
	    {
		y_msk = MOD (y_msk, mask_image->bits.height);
		if (h_this > mask_image->bits.height - y_msk)
		    h_this = mask_image->bits.height - y_msk;
d466 70
a535 1
	    if (src_repeat)
d537 4
a540 3
		y_src = MOD (y_src, src_image->bits.height);
		if (h_this > src_image->bits.height - y_src)
		    h_this = src_image->bits.height - y_src;
d542 1
a542 2

	    while (w)
d544 8
a551 25
		w_this = w;

		if (mask_repeat)
		{
		    x_msk = MOD (x_msk, mask_image->bits.width);
		    if (w_this > mask_image->bits.width - x_msk)
			w_this = mask_image->bits.width - x_msk;
		}

		if (src_repeat)
		{
		    x_src = MOD (x_src, src_image->bits.width);
		    if (w_this > src_image->bits.width - x_src)
			w_this = src_image->bits.width - x_src;
		}

		(*composite_rect) (imp, op,
				   src_image, mask_image, dst_image,
				   x_src, y_src, x_msk, y_msk, x_dst, y_dst,
				   w_this, h_this);
		w -= w_this;

		x_src += w_this;
		x_msk += w_this;
		x_dst += w_this;
d553 2
d556 22
a577 5
	    h -= h_this;
	    y_src += h_this;
	    y_msk += h_this;
	    y_dst += h_this;
	}
d579 1
a579 1
	pbox++;
d585 3
a587 5
static force_inline uint32_t
compute_src_extents_flags (pixman_image_t *image,
			   pixman_box32_t *extents,
			   int             x,
			   int             y)
d589 5
a593 2
    pixman_box16_t extents16;
    uint32_t flags;
d595 2
a596 1
    flags = FAST_PATH_COVERS_CLIP;
d598 9
a606 7
    if (image->common.type != BITS)
	return flags;

    if (image->common.repeat == PIXMAN_REPEAT_NONE &&
	(x > extents->x1 || y > extents->y1 ||
	 x + image->bits.width < extents->x2 ||
	 y + image->bits.height < extents->y2))
d608 1
a608 1
	flags &= ~FAST_PATH_COVERS_CLIP;
d611 2
a612 4
    if (IS_16BIT (extents->x1 - x) &&
	IS_16BIT (extents->y1 - y) &&
	IS_16BIT (extents->x2 - x) &&
	IS_16BIT (extents->y2 - y))
d614 6
a619 4
	extents16.x1 = extents->x1 - x;
	extents16.y1 = extents->y1 - y;
	extents16.x2 = extents->x2 - x;
	extents16.y2 = extents->y2 - y;
d621 7
a627 2
	if (!image->common.transform ||
	    pixman_transform_bounds (image->common.transform, &extents16))
d629 33
a661 6
	    if (extents16.x1 >= 0  && extents16.y1 >= 0 &&
		extents16.x2 <= image->bits.width &&
		extents16.y2 <= image->bits.height)
	    {
		flags |= FAST_PATH_SAMPLES_COVER_CLIP;
	    }
a662 1
    }
d664 7
a670 16
    if (IS_16BIT (extents->x1 - x - 1) &&
	IS_16BIT (extents->y1 - y - 1) &&
	IS_16BIT (extents->x2 - x + 1) &&
	IS_16BIT (extents->y2 - y + 1))
    {
	extents16.x1 = extents->x1 - x - 1;
	extents16.y1 = extents->y1 - y - 1;
	extents16.x2 = extents->x2 - x + 1;
	extents16.y2 = extents->y2 - y + 1;

	if (/* src space expanded by one in dest space fits in 16 bit */
	    (!image->common.transform ||
	     pixman_transform_bounds (image->common.transform, &extents16)) &&
	    /* And src image size can be used as 16.16 fixed point */
	    image->bits.width < 0x7fff &&
	    image->bits.height < 0x7fff)
d672 1
a672 2
	    /* Then we're "16bit safe" */
	    flags |= FAST_PATH_16BIT_SAFE;
d675 7
d683 8
a690 2
    return flags;
}
d692 2
a693 1
#define N_CACHED_FAST_PATHS 8
d695 2
a696 4
typedef struct
{
    pixman_fast_path_t cache [N_CACHED_FAST_PATHS];
} cache_t;
d698 32
a729 16
PIXMAN_DEFINE_THREAD_LOCAL (cache_t, fast_path_cache);

static void
do_composite (pixman_implementation_t *imp,
	      pixman_op_t	       op,
	      pixman_image_t	      *src,
	      pixman_image_t	      *mask,
	      pixman_image_t	      *dest,
	      int		       src_x,
	      int		       src_y,
	      int		       mask_x,
	      int		       mask_y,
	      int		       dest_x,
	      int		       dest_y,
	      int		       width,
	      int		       height)
d742 7
a748 3
    const pixman_fast_path_t *info;
    cache_t *cache;
    int i;
d790 1
a790 1
    
d797 1
a797 1
    
a798 2
    
    src_flags |= compute_src_extents_flags (src, extents, dest_x - src_x, dest_y - src_y);
d800 10
a809 2
    if (mask)
	mask_flags |= compute_src_extents_flags (mask, extents, dest_x - mask_x, dest_y - mask_y);
d811 6
d826 5
a830 4
    /* Check cache for fast paths */
    cache = PIXMAN_GET_THREAD_LOCAL (fast_path_cache);

    for (i = 0; i < N_CACHED_FAST_PATHS; ++i)
d832 2
a833 1
	info = &(cache->cache[i]);
d835 3
a837 13
	/* Note that we check for equality here, not whether
	 * the cached fast path matches. This is to prevent
	 * us from selecting an overly general fast path
	 * when a more specific one would work.
	 */
	if (info->op == op			&&
	    info->src_format == src_format	&&
	    info->mask_format == mask_format	&&
	    info->dest_format == dest_format	&&
	    info->src_flags == src_flags	&&
	    info->mask_flags == mask_flags	&&
	    info->dest_flags == dest_flags	&&
	    info->func)
d839 12
a850 1
	    goto found;
a853 68
    while (imp)
    {
	info = imp->fast_paths;

	while (info->op != PIXMAN_OP_NONE)
	{
	    if ((info->op == op || info->op == PIXMAN_OP_any)		&&
		/* Formats */
		((info->src_format == src_format) ||
		 (info->src_format == PIXMAN_any))			&&
		((info->mask_format == mask_format) ||
		 (info->mask_format == PIXMAN_any))			&&
		((info->dest_format == dest_format) ||
		 (info->dest_format == PIXMAN_any))			&&
		/* Flags */
		(info->src_flags & src_flags) == info->src_flags	&&
		(info->mask_flags & mask_flags) == info->mask_flags	&&
		(info->dest_flags & dest_flags) == info->dest_flags)
	    {
		/* Set i to the last spot in the cache so that the
		 * move-to-front code below will work
		 */
		i = N_CACHED_FAST_PATHS - 1;

		goto found;
	    }

	    ++info;
	}

	imp = imp->delegate;
    }

    /* We didn't find a compositing routine. This should not happen, but if
     * it somehow does, just exit rather than crash.
     */
    goto out;

found:
    walk_region_internal (imp, op,
			  src, mask, dest,
			  src_x, src_y, mask_x, mask_y,
			  dest_x, dest_y,
			  width, height,
			  (src_flags & FAST_PATH_SIMPLE_REPEAT),
			  (mask_flags & FAST_PATH_SIMPLE_REPEAT),
			  &region, info->func);

    if (i)
    {
	/* Make a copy of info->func, because info->func may change when
	 * we update the cache.
	 */
	pixman_composite_func_t func = info->func;
	
	while (i--)
	    cache->cache[i + 1] = cache->cache[i];

	cache->cache[0].op = op;
	cache->cache[0].src_format = src_format;
	cache->cache[0].src_flags = src_flags;
	cache->cache[0].mask_format = mask_format;
	cache->cache[0].mask_flags = mask_flags;
	cache->cache[0].dest_format = dest_format;
	cache->cache[0].dest_flags = dest_flags;
	cache->cache[0].func = func;
    }

a882 49
/*
 * Work around GCC bug causing crashes in Mozilla with SSE2
 *
 * When using -msse, gcc generates movdqa instructions assuming that
 * the stack is 16 byte aligned. Unfortunately some applications, such
 * as Mozilla and Mono, end up aligning the stack to 4 bytes, which
 * causes the movdqa instructions to fail.
 *
 * The __force_align_arg_pointer__ makes gcc generate a prologue that
 * realigns the stack pointer to 16 bytes.
 *
 * On x86-64 this is not necessary because the standard ABI already
 * calls for a 16 byte aligned stack.
 *
 * See https://bugs.freedesktop.org/show_bug.cgi?id=15693
 */
#if defined (USE_SSE2) && defined(__GNUC__) && !defined(__x86_64__) && !defined(__amd64__)
__attribute__((__force_align_arg_pointer__))
#endif
PIXMAN_EXPORT void
pixman_image_composite32 (pixman_op_t      op,
                          pixman_image_t * src,
                          pixman_image_t * mask,
                          pixman_image_t * dest,
                          int32_t          src_x,
                          int32_t          src_y,
                          int32_t          mask_x,
                          int32_t          mask_y,
                          int32_t          dest_x,
                          int32_t          dest_y,
                          int32_t          width,
                          int32_t          height)
{
    _pixman_image_validate (src);
    if (mask)
	_pixman_image_validate (mask);
    _pixman_image_validate (dest);

    if (!imp)
	imp = _pixman_choose_implementation ();

    do_composite (imp, op,
		  src, mask, dest,
		  src_x, src_y,
		  mask_x, mask_y,
		  dest_x, dest_y,
		  width, height);
}

d897 2
a898 4
    if (!imp)
	imp = _pixman_choose_implementation ();

    return _pixman_implementation_blt (imp, src_bits, dst_bits, src_stride, dst_stride,
d915 2
a916 4
    if (!imp)
	imp = _pixman_choose_implementation ();

    return _pixman_implementation_fill (imp, bits, stride, bpp, x, y, width, height, xor);
d1175 1
@


1.1
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@d31 7
a37 4
/*
 * Operator optimizations based on source or destination opacity
 */
typedef struct
d39 1
a39 20
    pixman_op_t op;
    pixman_op_t op_src_dst_opaque;
    pixman_op_t op_src_opaque;
    pixman_op_t op_dst_opaque;
} optimized_operator_info_t;

static const optimized_operator_info_t optimized_operators[] =
{
    /* Input Operator           SRC&DST Opaque          SRC Opaque              DST Opaque      */
    { PIXMAN_OP_OVER,           PIXMAN_OP_SRC,          PIXMAN_OP_SRC,          PIXMAN_OP_OVER },
    { PIXMAN_OP_OVER_REVERSE,   PIXMAN_OP_DST,          PIXMAN_OP_OVER_REVERSE, PIXMAN_OP_DST },
    { PIXMAN_OP_IN,             PIXMAN_OP_SRC,          PIXMAN_OP_IN,           PIXMAN_OP_SRC },
    { PIXMAN_OP_IN_REVERSE,     PIXMAN_OP_DST,          PIXMAN_OP_DST,          PIXMAN_OP_IN_REVERSE },
    { PIXMAN_OP_OUT,            PIXMAN_OP_CLEAR,        PIXMAN_OP_OUT,          PIXMAN_OP_CLEAR },
    { PIXMAN_OP_OUT_REVERSE,    PIXMAN_OP_CLEAR,        PIXMAN_OP_CLEAR,        PIXMAN_OP_OUT_REVERSE },
    { PIXMAN_OP_ATOP,           PIXMAN_OP_SRC,          PIXMAN_OP_IN,           PIXMAN_OP_OVER },
    { PIXMAN_OP_ATOP_REVERSE,   PIXMAN_OP_DST,          PIXMAN_OP_OVER_REVERSE, PIXMAN_OP_IN_REVERSE },
    { PIXMAN_OP_XOR,            PIXMAN_OP_CLEAR,        PIXMAN_OP_OUT,          PIXMAN_OP_OUT_REVERSE },
    { PIXMAN_OP_SATURATE,       PIXMAN_OP_DST,          PIXMAN_OP_OVER_REVERSE, PIXMAN_OP_DST },
    { PIXMAN_OP_NONE }
d42 5
a46 1
static pixman_implementation_t *imp;
d48 1
a48 5
/*
 * Check if the current operator could be optimized
 */
static const optimized_operator_info_t*
pixman_operator_can_be_optimized (pixman_op_t op)
d50 71
a120 9
    const optimized_operator_info_t *info;

    for (info = optimized_operators; info->op != PIXMAN_OP_NONE; info++)
    {
	if (info->op == op)
	    return info;
    }
    return NULL;
}
d127 7
a133 24
pixman_optimize_operator (pixman_op_t     op,
                          pixman_image_t *src_image,
                          pixman_image_t *mask_image,
                          pixman_image_t *dst_image)
{
    pixman_bool_t is_source_opaque;
    pixman_bool_t is_dest_opaque;
    const optimized_operator_info_t *info = pixman_operator_can_be_optimized (op);

    if (!info || mask_image)
	return op;

    is_source_opaque = _pixman_image_is_opaque (src_image);
    is_dest_opaque = _pixman_image_is_opaque (dst_image);

    if (is_source_opaque == FALSE && is_dest_opaque == FALSE)
	return op;

    if (is_source_opaque && is_dest_opaque)
	return info->op_src_dst_opaque;
    else if (is_source_opaque)
	return info->op_src_opaque;
    else if (is_dest_opaque)
	return info->op_dst_opaque;
d135 2
a136 1
    return op;
d138 3
d145 2
a146 2
		  int16_t *       x,
		  int16_t *       y,
d151 102
a252 6
    /* Some X servers generate images that point to the
     * wrong place in memory, but then set the clip region
     * to point to the right place. Because of an old bug
     * in pixman, this would actually work.
     *
     * Here we try and undo the damage
d254 2
a255 4
    int bpp = PIXMAN_FORMAT_BPP (image->bits.format) / 8;
    pixman_box32_t *extents;
    uint8_t *t;
    int dx, dy;
d257 4
a260 3
    extents = pixman_region32_extents (&(image->common.clip_region));
    dx = extents->x1;
    dy = extents->y1;
d262 37
a298 1
    *save_bits = image->bits.bits;
d300 8
a307 3
    *x -= dx;
    *y -= dy;
    pixman_region32_translate (&(image->common.clip_region), -dx, -dy);
d309 10
a318 3
    t = (uint8_t *)image->bits.bits;
    t += dy * image->bits.rowstride * 4 + dx * bpp;
    image->bits.bits = (uint32_t *)t;
d320 40
a359 2
    *save_dx = dx;
    *save_dy = dy;
d363 126
a488 1
unapply_workaround (pixman_image_t *image, uint32_t *bits, int dx, int dy)
d490 61
a550 2
    image->bits.bits = bits;
    pixman_region32_translate (&image->common.clip_region, dx, dy);
d553 23
a575 13
PIXMAN_EXPORT void
pixman_image_composite (pixman_op_t      op,
                        pixman_image_t * src,
                        pixman_image_t * mask,
                        pixman_image_t * dest,
                        int16_t          src_x,
                        int16_t          src_y,
                        int16_t          mask_x,
                        int16_t          mask_y,
                        int16_t          dest_x,
                        int16_t          dest_y,
                        uint16_t         width,
                        uint16_t         height)
d577 4
d587 7
a594 1
    _pixman_image_validate (src);
d596 45
a640 2
	_pixman_image_validate (mask);
    _pixman_image_validate (dest);
d642 5
d652 8
a659 4
    op = pixman_optimize_operator(op, src, mask, dest);
    if (op == PIXMAN_OP_DST		||
	op == PIXMAN_OP_CONJOINT_DST	||
	op == PIXMAN_OP_DISJOINT_DST)
d661 18
a678 1
        return;
d681 32
a712 2
    if (!imp)
	imp = _pixman_choose_implementation ();
d714 4
a717 6
    if (src->common.need_workaround)
	apply_workaround (src, &src_x, &src_y, &src_bits, &src_dx, &src_dy);
    if (mask && mask->common.need_workaround)
	apply_workaround (mask, &mask_x, &mask_y, &mask_bits, &mask_dx, &mask_dy);
    if (dest->common.need_workaround)
	apply_workaround (dest, &dest_x, &dest_y, &dest_bits, &dest_dx, &dest_dy);
d719 9
a727 6
    _pixman_implementation_composite (imp, op,
                                      src, mask, dest,
                                      src_x, src_y,
                                      mask_x, mask_y,
                                      dest_x, dest_y,
                                      width, height);
d729 23
a751 1
    if (src->common.need_workaround)
a752 1
    if (mask && mask->common.need_workaround)
a753 1
    if (dest->common.need_workaround)
d755 70
d934 39
d981 2
a982 2
	if (op == PIXMAN_OP_OVER)
	    op = PIXMAN_OP_SRC;
d987 4
a990 4
	c.red = 0;
	c.green = 0;
	c.blue = 0;
	c.alpha = 0;
d992 1
a992 1
	color = &c;
d994 1
a994 1
	op = PIXMAN_OP_SRC;
d999 1
a999 1
	uint32_t pixel;
d1001 29
a1029 31
	if (color_to_pixel (color, &pixel, dest->bits.format))
	{
	    for (i = 0; i < n_rects; ++i)
	    {
		pixman_region32_t fill_region;
		int n_boxes, j;
		pixman_box32_t *boxes;

		pixman_region32_init_rect (&fill_region, rects[i].x, rects[i].y, rects[i].width, rects[i].height);

		if (dest->common.have_clip_region)
		{
		    if (!pixman_region32_intersect (&fill_region,
		                                    &fill_region,
		                                    &dest->common.clip_region))
			return FALSE;
		}

		boxes = pixman_region32_rectangles (&fill_region, &n_boxes);
		for (j = 0; j < n_boxes; ++j)
		{
		    const pixman_box32_t *box = &(boxes[j]);
		    pixman_fill (dest->bits.bits, dest->bits.rowstride, PIXMAN_FORMAT_BPP (dest->bits.format),
		                 box->x1, box->y1, box->x2 - box->x1, box->y2 - box->y1,
		                 pixel);
		}

		pixman_region32_fini (&fill_region);
	    }
	    return TRUE;
	}
d1034 1
a1034 1
	return FALSE;
d1036 1
a1036 1
    for (i = 0; i < n_rects; ++i)
d1038 1
a1038 1
	const pixman_rectangle16_t *rect = &(rects[i]);
d1040 4
a1043 4
	pixman_image_composite (op, solid, NULL, dest,
	                        0, 0, 0, 0,
	                        rect->x, rect->y,
	                        rect->width, rect->height);
d1189 33
@

