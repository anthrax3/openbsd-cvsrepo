head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.2
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.12
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.10
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.6
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.2
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v0_9_6:1.1.1.2
	xorg:1.1.1
	v0_9_5:1.1.1.1
	pixman:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.10.01.10.17.44;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	FGr8CFhVerRlpSoE;

1.13
date	2013.12.01.20.34.20;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.07.17.18.01;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.02.28.20.36.12;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.14.13.42.49;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.05.20.14.28;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.23.19.11.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.08.19.00.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.03.20.48.53;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.10.03.20.48.53;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.12.10.21.10.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to pixman 0.34.0.
@
text
@#include <float.h>

#ifndef PIXMAN_PRIVATE_H
#define PIXMAN_PRIVATE_H

/*
 * The defines which are shared between C and assembly code
 */

/* bilinear interpolation precision (must be < 8) */
#define BILINEAR_INTERPOLATION_BITS 7
#define BILINEAR_INTERPOLATION_RANGE (1 << BILINEAR_INTERPOLATION_BITS)

/*
 * C specific part
 */

#ifndef __ASSEMBLER__

#ifndef PACKAGE
#  error config.h must be included before pixman-private.h
#endif

#define PIXMAN_DISABLE_DEPRECATED
#define PIXMAN_USE_INTERNAL_API

#include "pixman.h"
#include <time.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

#include "pixman-compiler.h"

/*
 * Images
 */
typedef struct image_common image_common_t;
typedef struct solid_fill solid_fill_t;
typedef struct gradient gradient_t;
typedef struct linear_gradient linear_gradient_t;
typedef struct horizontal_gradient horizontal_gradient_t;
typedef struct vertical_gradient vertical_gradient_t;
typedef struct conical_gradient conical_gradient_t;
typedef struct radial_gradient radial_gradient_t;
typedef struct bits_image bits_image_t;
typedef struct circle circle_t;

typedef struct argb_t argb_t;

struct argb_t
{
    float a;
    float r;
    float g;
    float b;
};

typedef void (*fetch_scanline_t) (bits_image_t   *image,
				  int             x,
				  int             y,
				  int             width,
				  uint32_t       *buffer,
				  const uint32_t *mask);

typedef uint32_t (*fetch_pixel_32_t) (bits_image_t *image,
				      int           x,
				      int           y);

typedef argb_t (*fetch_pixel_float_t) (bits_image_t *image,
				       int           x,
				       int           y);

typedef void (*store_scanline_t) (bits_image_t *  image,
				  int             x,
				  int             y,
				  int             width,
				  const uint32_t *values);

typedef enum
{
    BITS,
    LINEAR,
    CONICAL,
    RADIAL,
    SOLID
} image_type_t;

typedef void (*property_changed_func_t) (pixman_image_t *image);

struct image_common
{
    image_type_t                type;
    int32_t                     ref_count;
    pixman_region32_t           clip_region;
    int32_t			alpha_count;	    /* How many times this image is being used as an alpha map */
    pixman_bool_t               have_clip_region;   /* FALSE if there is no clip */
    pixman_bool_t               client_clip;        /* Whether the source clip was
						       set by a client */
    pixman_bool_t               clip_sources;       /* Whether the clip applies when
						     * the image is used as a source
						     */
    pixman_bool_t		dirty;
    pixman_transform_t *        transform;
    pixman_repeat_t             repeat;
    pixman_filter_t             filter;
    pixman_fixed_t *            filter_params;
    int                         n_filter_params;
    bits_image_t *              alpha_map;
    int                         alpha_origin_x;
    int                         alpha_origin_y;
    pixman_bool_t               component_alpha;
    property_changed_func_t     property_changed;

    pixman_image_destroy_func_t destroy_func;
    void *                      destroy_data;

    uint32_t			flags;
    pixman_format_code_t	extended_format_code;
};

struct solid_fill
{
    image_common_t common;
    pixman_color_t color;

    uint32_t	   color_32;
    argb_t	   color_float;
};

struct gradient
{
    image_common_t	    common;
    int                     n_stops;
    pixman_gradient_stop_t *stops;
};

struct linear_gradient
{
    gradient_t           common;
    pixman_point_fixed_t p1;
    pixman_point_fixed_t p2;
};

struct circle
{
    pixman_fixed_t x;
    pixman_fixed_t y;
    pixman_fixed_t radius;
};

struct radial_gradient
{
    gradient_t common;

    circle_t   c1;
    circle_t   c2;

    circle_t   delta;
    double     a;
    double     inva;
    double     mindr;
};

struct conical_gradient
{
    gradient_t           common;
    pixman_point_fixed_t center;
    double		 angle;
};

struct bits_image
{
    image_common_t             common;
    pixman_format_code_t       format;
    const pixman_indexed_t *   indexed;
    int                        width;
    int                        height;
    uint32_t *                 bits;
    uint32_t *                 free_me;
    int                        rowstride;  /* in number of uint32_t's */

    fetch_scanline_t           fetch_scanline_32;
    fetch_pixel_32_t	       fetch_pixel_32;
    store_scanline_t           store_scanline_32;

    fetch_scanline_t	       fetch_scanline_float;
    fetch_pixel_float_t	       fetch_pixel_float;
    store_scanline_t           store_scanline_float;

    /* Used for indirect access to the bits */
    pixman_read_memory_func_t  read_func;
    pixman_write_memory_func_t write_func;
};

union pixman_image
{
    image_type_t       type;
    image_common_t     common;
    bits_image_t       bits;
    gradient_t         gradient;
    linear_gradient_t  linear;
    conical_gradient_t conical;
    radial_gradient_t  radial;
    solid_fill_t       solid;
};

typedef struct pixman_iter_t pixman_iter_t;
typedef uint32_t *(* pixman_iter_get_scanline_t) (pixman_iter_t *iter, const uint32_t *mask);
typedef void      (* pixman_iter_write_back_t)   (pixman_iter_t *iter);
typedef void	  (* pixman_iter_fini_t)	 (pixman_iter_t *iter);

typedef enum
{
    ITER_NARROW =               (1 << 0),
    ITER_WIDE =                 (1 << 1),

    /* "Localized alpha" is when the alpha channel is used only to compute
     * the alpha value of the destination. This means that the computation
     * of the RGB values of the result is independent of the alpha value.
     *
     * For example, the OVER operator has localized alpha for the
     * destination, because the RGB values of the result can be computed
     * without knowing the destination alpha. Similarly, ADD has localized
     * alpha for both source and destination because the RGB values of the
     * result can be computed without knowing the alpha value of source or
     * destination.
     *
     * When he destination is xRGB, this is useful knowledge, because then
     * we can treat it as if it were ARGB, which means in some cases we can
     * avoid copying it to a temporary buffer.
     */
    ITER_LOCALIZED_ALPHA =	(1 << 2),
    ITER_IGNORE_ALPHA =		(1 << 3),
    ITER_IGNORE_RGB =		(1 << 4),

    /* These indicate whether the iterator is for a source
     * or a destination image
     */
    ITER_SRC =			(1 << 5),
    ITER_DEST =			(1 << 6)
} iter_flags_t;

struct pixman_iter_t
{
    /* These are initialized by _pixman_implementation_{src,dest}_init */
    pixman_image_t *		image;
    uint32_t *			buffer;
    int				x, y;
    int				width;
    int				height;
    iter_flags_t		iter_flags;
    uint32_t			image_flags;

    /* These function pointers are initialized by the implementation */
    pixman_iter_get_scanline_t	get_scanline;
    pixman_iter_write_back_t	write_back;
    pixman_iter_fini_t          fini;

    /* These fields are scratch data that implementations can use */
    void *			data;
    uint8_t *			bits;
    int				stride;
};

typedef struct pixman_iter_info_t pixman_iter_info_t;
typedef void (* pixman_iter_initializer_t) (pixman_iter_t *iter,
                                            const pixman_iter_info_t *info);
struct pixman_iter_info_t
{
    pixman_format_code_t	format;
    uint32_t			image_flags;
    iter_flags_t		iter_flags;
    pixman_iter_initializer_t	initializer;
    pixman_iter_get_scanline_t	get_scanline;
    pixman_iter_write_back_t	write_back;
};

void
_pixman_bits_image_setup_accessors (bits_image_t *image);

void
_pixman_bits_image_src_iter_init (pixman_image_t *image, pixman_iter_t *iter);

void
_pixman_bits_image_dest_iter_init (pixman_image_t *image, pixman_iter_t *iter);

void
_pixman_linear_gradient_iter_init (pixman_image_t *image, pixman_iter_t  *iter);

void
_pixman_radial_gradient_iter_init (pixman_image_t *image, pixman_iter_t *iter);

void
_pixman_conical_gradient_iter_init (pixman_image_t *image, pixman_iter_t *iter);

void
_pixman_image_init (pixman_image_t *image);

pixman_bool_t
_pixman_bits_image_init (pixman_image_t *     image,
                         pixman_format_code_t format,
                         int                  width,
                         int                  height,
                         uint32_t *           bits,
                         int                  rowstride,
			 pixman_bool_t	      clear);
pixman_bool_t
_pixman_image_fini (pixman_image_t *image);

pixman_image_t *
_pixman_image_allocate (void);

pixman_bool_t
_pixman_init_gradient (gradient_t *                  gradient,
                       const pixman_gradient_stop_t *stops,
                       int                           n_stops);
void
_pixman_image_reset_clip_region (pixman_image_t *image);

void
_pixman_image_validate (pixman_image_t *image);

#define PIXMAN_IMAGE_GET_LINE(image, x, y, type, out_stride, line, mul)	\
    do									\
    {									\
	uint32_t *__bits__;						\
	int       __stride__;						\
        								\
	__bits__ = image->bits.bits;					\
	__stride__ = image->bits.rowstride;				\
	(out_stride) =							\
	    __stride__ * (int) sizeof (uint32_t) / (int) sizeof (type);	\
	(line) =							\
	    ((type *) __bits__) + (out_stride) * (y) + (mul) * (x);	\
    } while (0)

/*
 * Gradient walker
 */
typedef struct
{
    float		    a_s, a_b;
    float		    r_s, r_b;
    float		    g_s, g_b;
    float		    b_s, b_b;
    pixman_fixed_48_16_t    left_x;
    pixman_fixed_48_16_t    right_x;

    pixman_gradient_stop_t *stops;
    int                     num_stops;
    pixman_repeat_t	    repeat;

    pixman_bool_t           need_reset;
} pixman_gradient_walker_t;

void
_pixman_gradient_walker_init (pixman_gradient_walker_t *walker,
                              gradient_t *              gradient,
			      pixman_repeat_t           repeat);

void
_pixman_gradient_walker_reset (pixman_gradient_walker_t *walker,
                               pixman_fixed_48_16_t      pos);

uint32_t
_pixman_gradient_walker_pixel (pixman_gradient_walker_t *walker,
                               pixman_fixed_48_16_t      x);

/*
 * Edges
 */

#define MAX_ALPHA(n)    ((1 << (n)) - 1)
#define N_Y_FRAC(n)     ((n) == 1 ? 1 : (1 << ((n) / 2)) - 1)
#define N_X_FRAC(n)     ((n) == 1 ? 1 : (1 << ((n) / 2)) + 1)

#define STEP_Y_SMALL(n) (pixman_fixed_1 / N_Y_FRAC (n))
#define STEP_Y_BIG(n)   (pixman_fixed_1 - (N_Y_FRAC (n) - 1) * STEP_Y_SMALL (n))

#define Y_FRAC_FIRST(n) (STEP_Y_BIG (n) / 2)
#define Y_FRAC_LAST(n)  (Y_FRAC_FIRST (n) + (N_Y_FRAC (n) - 1) * STEP_Y_SMALL (n))

#define STEP_X_SMALL(n) (pixman_fixed_1 / N_X_FRAC (n))
#define STEP_X_BIG(n)   (pixman_fixed_1 - (N_X_FRAC (n) - 1) * STEP_X_SMALL (n))

#define X_FRAC_FIRST(n) (STEP_X_BIG (n) / 2)
#define X_FRAC_LAST(n)  (X_FRAC_FIRST (n) + (N_X_FRAC (n) - 1) * STEP_X_SMALL (n))

#define RENDER_SAMPLES_X(x, n)						\
    ((n) == 1? 0 : (pixman_fixed_frac (x) +				\
		    X_FRAC_FIRST (n)) / STEP_X_SMALL (n))

void
pixman_rasterize_edges_accessors (pixman_image_t *image,
                                  pixman_edge_t * l,
                                  pixman_edge_t * r,
                                  pixman_fixed_t  t,
                                  pixman_fixed_t  b);

/*
 * Implementations
 */
typedef struct pixman_implementation_t pixman_implementation_t;

typedef struct
{
    pixman_op_t              op;
    pixman_image_t *         src_image;
    pixman_image_t *         mask_image;
    pixman_image_t *         dest_image;
    int32_t                  src_x;
    int32_t                  src_y;
    int32_t                  mask_x;
    int32_t                  mask_y;
    int32_t                  dest_x;
    int32_t                  dest_y;
    int32_t                  width;
    int32_t                  height;

    uint32_t                 src_flags;
    uint32_t                 mask_flags;
    uint32_t                 dest_flags;
} pixman_composite_info_t;

#define PIXMAN_COMPOSITE_ARGS(info)					\
    MAYBE_UNUSED pixman_op_t        op = info->op;			\
    MAYBE_UNUSED pixman_image_t *   src_image = info->src_image;	\
    MAYBE_UNUSED pixman_image_t *   mask_image = info->mask_image;	\
    MAYBE_UNUSED pixman_image_t *   dest_image = info->dest_image;	\
    MAYBE_UNUSED int32_t            src_x = info->src_x;		\
    MAYBE_UNUSED int32_t            src_y = info->src_y;		\
    MAYBE_UNUSED int32_t            mask_x = info->mask_x;		\
    MAYBE_UNUSED int32_t            mask_y = info->mask_y;		\
    MAYBE_UNUSED int32_t            dest_x = info->dest_x;		\
    MAYBE_UNUSED int32_t            dest_y = info->dest_y;		\
    MAYBE_UNUSED int32_t            width = info->width;		\
    MAYBE_UNUSED int32_t            height = info->height

typedef void (*pixman_combine_32_func_t) (pixman_implementation_t *imp,
					  pixman_op_t              op,
					  uint32_t *               dest,
					  const uint32_t *         src,
					  const uint32_t *         mask,
					  int                      width);

typedef void (*pixman_combine_float_func_t) (pixman_implementation_t *imp,
					     pixman_op_t	      op,
					     float *		      dest,
					     const float *	      src,
					     const float *	      mask,
					     int		      n_pixels);

typedef void (*pixman_composite_func_t) (pixman_implementation_t *imp,
					 pixman_composite_info_t *info);
typedef pixman_bool_t (*pixman_blt_func_t) (pixman_implementation_t *imp,
					    uint32_t *               src_bits,
					    uint32_t *               dst_bits,
					    int                      src_stride,
					    int                      dst_stride,
					    int                      src_bpp,
					    int                      dst_bpp,
					    int                      src_x,
					    int                      src_y,
					    int                      dest_x,
					    int                      dest_y,
					    int                      width,
					    int                      height);
typedef pixman_bool_t (*pixman_fill_func_t) (pixman_implementation_t *imp,
					     uint32_t *               bits,
					     int                      stride,
					     int                      bpp,
					     int                      x,
					     int                      y,
					     int                      width,
					     int                      height,
					     uint32_t                 filler);

void _pixman_setup_combiner_functions_32 (pixman_implementation_t *imp);
void _pixman_setup_combiner_functions_float (pixman_implementation_t *imp);

typedef struct
{
    pixman_op_t             op;
    pixman_format_code_t    src_format;
    uint32_t		    src_flags;
    pixman_format_code_t    mask_format;
    uint32_t		    mask_flags;
    pixman_format_code_t    dest_format;
    uint32_t		    dest_flags;
    pixman_composite_func_t func;
} pixman_fast_path_t;

struct pixman_implementation_t
{
    pixman_implementation_t *	toplevel;
    pixman_implementation_t *	fallback;
    const pixman_fast_path_t *	fast_paths;
    const pixman_iter_info_t *  iter_info;

    pixman_blt_func_t		blt;
    pixman_fill_func_t		fill;

    pixman_combine_32_func_t	combine_32[PIXMAN_N_OPERATORS];
    pixman_combine_32_func_t	combine_32_ca[PIXMAN_N_OPERATORS];
    pixman_combine_float_func_t	combine_float[PIXMAN_N_OPERATORS];
    pixman_combine_float_func_t	combine_float_ca[PIXMAN_N_OPERATORS];
};

uint32_t
_pixman_image_get_solid (pixman_implementation_t *imp,
			 pixman_image_t *         image,
                         pixman_format_code_t     format);

pixman_implementation_t *
_pixman_implementation_create (pixman_implementation_t *fallback,
			       const pixman_fast_path_t *fast_paths);

void
_pixman_implementation_lookup_composite (pixman_implementation_t  *toplevel,
					 pixman_op_t               op,
					 pixman_format_code_t      src_format,
					 uint32_t                  src_flags,
					 pixman_format_code_t      mask_format,
					 uint32_t                  mask_flags,
					 pixman_format_code_t      dest_format,
					 uint32_t                  dest_flags,
					 pixman_implementation_t **out_imp,
					 pixman_composite_func_t  *out_func);

pixman_combine_32_func_t
_pixman_implementation_lookup_combiner (pixman_implementation_t *imp,
					pixman_op_t		 op,
					pixman_bool_t		 component_alpha,
					pixman_bool_t		 wide);

pixman_bool_t
_pixman_implementation_blt (pixman_implementation_t *imp,
                            uint32_t *               src_bits,
                            uint32_t *               dst_bits,
                            int                      src_stride,
                            int                      dst_stride,
                            int                      src_bpp,
                            int                      dst_bpp,
                            int                      src_x,
                            int                      src_y,
                            int                      dest_x,
                            int                      dest_y,
                            int                      width,
                            int                      height);

pixman_bool_t
_pixman_implementation_fill (pixman_implementation_t *imp,
                             uint32_t *               bits,
                             int                      stride,
                             int                      bpp,
                             int                      x,
                             int                      y,
                             int                      width,
                             int                      height,
                             uint32_t                 filler);

void
_pixman_implementation_iter_init (pixman_implementation_t       *imp,
                                  pixman_iter_t                 *iter,
                                  pixman_image_t                *image,
                                  int                            x,
                                  int                            y,
                                  int                            width,
                                  int                            height,
                                  uint8_t                       *buffer,
                                  iter_flags_t                   flags,
                                  uint32_t                       image_flags);

/* Specific implementations */
pixman_implementation_t *
_pixman_implementation_create_general (void);

pixman_implementation_t *
_pixman_implementation_create_fast_path (pixman_implementation_t *fallback);

pixman_implementation_t *
_pixman_implementation_create_noop (pixman_implementation_t *fallback);

#if defined USE_X86_MMX || defined USE_ARM_IWMMXT || defined USE_LOONGSON_MMI
pixman_implementation_t *
_pixman_implementation_create_mmx (pixman_implementation_t *fallback);
#endif

#ifdef USE_SSE2
pixman_implementation_t *
_pixman_implementation_create_sse2 (pixman_implementation_t *fallback);
#endif

#ifdef USE_SSSE3
pixman_implementation_t *
_pixman_implementation_create_ssse3 (pixman_implementation_t *fallback);
#endif

#ifdef USE_ARM_SIMD
pixman_implementation_t *
_pixman_implementation_create_arm_simd (pixman_implementation_t *fallback);
#endif

#ifdef USE_ARM_NEON
pixman_implementation_t *
_pixman_implementation_create_arm_neon (pixman_implementation_t *fallback);
#endif

#ifdef USE_MIPS_DSPR2
pixman_implementation_t *
_pixman_implementation_create_mips_dspr2 (pixman_implementation_t *fallback);
#endif

#ifdef USE_VMX
pixman_implementation_t *
_pixman_implementation_create_vmx (pixman_implementation_t *fallback);
#endif

pixman_bool_t
_pixman_implementation_disabled (const char *name);

pixman_implementation_t *
_pixman_x86_get_implementations (pixman_implementation_t *imp);

pixman_implementation_t *
_pixman_arm_get_implementations (pixman_implementation_t *imp);

pixman_implementation_t *
_pixman_ppc_get_implementations (pixman_implementation_t *imp);

pixman_implementation_t *
_pixman_mips_get_implementations (pixman_implementation_t *imp);

pixman_implementation_t *
_pixman_choose_implementation (void);

pixman_bool_t
_pixman_disabled (const char *name);


/*
 * Utilities
 */
pixman_bool_t
_pixman_compute_composite_region32 (pixman_region32_t * region,
				    pixman_image_t *    src_image,
				    pixman_image_t *    mask_image,
				    pixman_image_t *    dest_image,
				    int32_t             src_x,
				    int32_t             src_y,
				    int32_t             mask_x,
				    int32_t             mask_y,
				    int32_t             dest_x,
				    int32_t             dest_y,
				    int32_t             width,
				    int32_t             height);
uint32_t *
_pixman_iter_get_scanline_noop (pixman_iter_t *iter, const uint32_t *mask);

void
_pixman_iter_init_bits_stride (pixman_iter_t *iter, const pixman_iter_info_t *info);

/* These "formats" all have depth 0, so they
 * will never clash with any real ones
 */
#define PIXMAN_null             PIXMAN_FORMAT (0, 0, 0, 0, 0, 0)
#define PIXMAN_solid            PIXMAN_FORMAT (0, 1, 0, 0, 0, 0)
#define PIXMAN_pixbuf		PIXMAN_FORMAT (0, 2, 0, 0, 0, 0)
#define PIXMAN_rpixbuf		PIXMAN_FORMAT (0, 3, 0, 0, 0, 0)
#define PIXMAN_unknown		PIXMAN_FORMAT (0, 4, 0, 0, 0, 0)
#define PIXMAN_any		PIXMAN_FORMAT (0, 5, 0, 0, 0, 0)

#define PIXMAN_OP_any		(PIXMAN_N_OPERATORS + 1)

#define FAST_PATH_ID_TRANSFORM			(1 <<  0)
#define FAST_PATH_NO_ALPHA_MAP			(1 <<  1)
#define FAST_PATH_NO_CONVOLUTION_FILTER		(1 <<  2)
#define FAST_PATH_NO_PAD_REPEAT			(1 <<  3)
#define FAST_PATH_NO_REFLECT_REPEAT		(1 <<  4)
#define FAST_PATH_NO_ACCESSORS			(1 <<  5)
#define FAST_PATH_NARROW_FORMAT			(1 <<  6)
#define FAST_PATH_COMPONENT_ALPHA		(1 <<  8)
#define FAST_PATH_SAMPLES_OPAQUE		(1 <<  7)
#define FAST_PATH_UNIFIED_ALPHA			(1 <<  9)
#define FAST_PATH_SCALE_TRANSFORM		(1 << 10)
#define FAST_PATH_NEAREST_FILTER		(1 << 11)
#define FAST_PATH_HAS_TRANSFORM			(1 << 12)
#define FAST_PATH_IS_OPAQUE			(1 << 13)
#define FAST_PATH_NO_NORMAL_REPEAT		(1 << 14)
#define FAST_PATH_NO_NONE_REPEAT		(1 << 15)
#define FAST_PATH_X_UNIT_POSITIVE		(1 << 16)
#define FAST_PATH_AFFINE_TRANSFORM		(1 << 17)
#define FAST_PATH_Y_UNIT_ZERO			(1 << 18)
#define FAST_PATH_BILINEAR_FILTER		(1 << 19)
#define FAST_PATH_ROTATE_90_TRANSFORM		(1 << 20)
#define FAST_PATH_ROTATE_180_TRANSFORM		(1 << 21)
#define FAST_PATH_ROTATE_270_TRANSFORM		(1 << 22)
#define FAST_PATH_SAMPLES_COVER_CLIP_NEAREST	(1 << 23)
#define FAST_PATH_SAMPLES_COVER_CLIP_BILINEAR	(1 << 24)
#define FAST_PATH_BITS_IMAGE			(1 << 25)
#define FAST_PATH_SEPARABLE_CONVOLUTION_FILTER  (1 << 26)

#define FAST_PATH_PAD_REPEAT						\
    (FAST_PATH_NO_NONE_REPEAT		|				\
     FAST_PATH_NO_NORMAL_REPEAT		|				\
     FAST_PATH_NO_REFLECT_REPEAT)

#define FAST_PATH_NORMAL_REPEAT						\
    (FAST_PATH_NO_NONE_REPEAT		|				\
     FAST_PATH_NO_PAD_REPEAT		|				\
     FAST_PATH_NO_REFLECT_REPEAT)

#define FAST_PATH_NONE_REPEAT						\
    (FAST_PATH_NO_NORMAL_REPEAT		|				\
     FAST_PATH_NO_PAD_REPEAT		|				\
     FAST_PATH_NO_REFLECT_REPEAT)

#define FAST_PATH_REFLECT_REPEAT					\
    (FAST_PATH_NO_NONE_REPEAT		|				\
     FAST_PATH_NO_NORMAL_REPEAT		|				\
     FAST_PATH_NO_PAD_REPEAT)

#define FAST_PATH_STANDARD_FLAGS					\
    (FAST_PATH_NO_CONVOLUTION_FILTER	|				\
     FAST_PATH_NO_ACCESSORS		|				\
     FAST_PATH_NO_ALPHA_MAP		|				\
     FAST_PATH_NARROW_FORMAT)

#define FAST_PATH_STD_DEST_FLAGS					\
    (FAST_PATH_NO_ACCESSORS		|				\
     FAST_PATH_NO_ALPHA_MAP		|				\
     FAST_PATH_NARROW_FORMAT)

#define SOURCE_FLAGS(format)						\
    (FAST_PATH_STANDARD_FLAGS |						\
     ((PIXMAN_ ## format == PIXMAN_solid) ?				\
      0 : (FAST_PATH_SAMPLES_COVER_CLIP_NEAREST | FAST_PATH_NEAREST_FILTER | FAST_PATH_ID_TRANSFORM)))

#define MASK_FLAGS(format, extra)					\
    ((PIXMAN_ ## format == PIXMAN_null) ? 0 : (SOURCE_FLAGS (format) | extra))

#define FAST_PATH(op, src, src_flags, mask, mask_flags, dest, dest_flags, func) \
    PIXMAN_OP_ ## op,							\
    PIXMAN_ ## src,							\
    src_flags,							        \
    PIXMAN_ ## mask,						        \
    mask_flags,							        \
    PIXMAN_ ## dest,	                                                \
    dest_flags,							        \
    func

#define PIXMAN_STD_FAST_PATH(op, src, mask, dest, func)			\
    { FAST_PATH (							\
	    op,								\
	    src,  SOURCE_FLAGS (src),					\
	    mask, MASK_FLAGS (mask, FAST_PATH_UNIFIED_ALPHA),		\
	    dest, FAST_PATH_STD_DEST_FLAGS,				\
	    func) }

#define PIXMAN_STD_FAST_PATH_CA(op, src, mask, dest, func)		\
    { FAST_PATH (							\
	    op,								\
	    src,  SOURCE_FLAGS (src),					\
	    mask, MASK_FLAGS (mask, FAST_PATH_COMPONENT_ALPHA),		\
	    dest, FAST_PATH_STD_DEST_FLAGS,				\
	    func) }

extern pixman_implementation_t *global_implementation;

static force_inline pixman_implementation_t *
get_implementation (void)
{
#ifndef TOOLCHAIN_SUPPORTS_ATTRIBUTE_CONSTRUCTOR
    if (!global_implementation)
	global_implementation = _pixman_choose_implementation ();
#endif
    return global_implementation;
}

/* This function is exported for the sake of the test suite and not part
 * of the ABI.
 */
PIXMAN_EXPORT pixman_implementation_t *
_pixman_internal_only_get_implementation (void);

/* Memory allocation helpers */
void *
pixman_malloc_ab (unsigned int n, unsigned int b);

void *
pixman_malloc_abc (unsigned int a, unsigned int b, unsigned int c);

void *
pixman_malloc_ab_plus_c (unsigned int a, unsigned int b, unsigned int c);

pixman_bool_t
_pixman_multiply_overflows_size (size_t a, size_t b);

pixman_bool_t
_pixman_multiply_overflows_int (unsigned int a, unsigned int b);

pixman_bool_t
_pixman_addition_overflows_int (unsigned int a, unsigned int b);

/* Compositing utilities */
void
pixman_expand_to_float (argb_t               *dst,
			const uint32_t       *src,
			pixman_format_code_t  format,
			int                   width);

void
pixman_contract_from_float (uint32_t     *dst,
			    const argb_t *src,
			    int           width);

/* Region Helpers */
pixman_bool_t
pixman_region32_copy_from_region16 (pixman_region32_t *dst,
                                    pixman_region16_t *src);

pixman_bool_t
pixman_region16_copy_from_region32 (pixman_region16_t *dst,
                                    pixman_region32_t *src);

/* Doubly linked lists */
typedef struct pixman_link_t pixman_link_t;
struct pixman_link_t
{
    pixman_link_t *next;
    pixman_link_t *prev;
};

typedef struct pixman_list_t pixman_list_t;
struct pixman_list_t
{
    pixman_link_t *head;
    pixman_link_t *tail;
};

static force_inline void
pixman_list_init (pixman_list_t *list)
{
    list->head = (pixman_link_t *)list;
    list->tail = (pixman_link_t *)list;
}

static force_inline void
pixman_list_prepend (pixman_list_t *list, pixman_link_t *link)
{
    link->next = list->head;
    link->prev = (pixman_link_t *)list;
    list->head->prev = link;
    list->head = link;
}

static force_inline void
pixman_list_unlink (pixman_link_t *link)
{
    link->prev->next = link->next;
    link->next->prev = link->prev;
}

static force_inline void
pixman_list_move_to_front (pixman_list_t *list, pixman_link_t *link)
{
    pixman_list_unlink (link);
    pixman_list_prepend (list, link);
}

/* Misc macros */

#ifndef FALSE
#   define FALSE 0
#endif

#ifndef TRUE
#   define TRUE 1
#endif

#ifndef MIN
#  define MIN(a, b) ((a < b) ? a : b)
#endif

#ifndef MAX
#  define MAX(a, b) ((a > b) ? a : b)
#endif

/* Integer division that rounds towards -infinity */
#define DIV(a, b)					   \
    ((((a) < 0) == ((b) < 0)) ? (a) / (b) :                \
     ((a) - (b) + 1 - (((b) < 0) << 1)) / (b))

/* Modulus that produces the remainder wrt. DIV */
#define MOD(a, b) ((a) < 0 ? ((b) - ((-(a) - 1) % (b))) - 1 : (a) % (b))

#define CLIP(v, low, high) ((v) < (low) ? (low) : ((v) > (high) ? (high) : (v)))

#define FLOAT_IS_ZERO(f)     (-FLT_MIN < (f) && (f) < FLT_MIN)

/* Conversion between 8888 and 0565 */

static force_inline uint16_t
convert_8888_to_0565 (uint32_t s)
{
    /* The following code can be compiled into just 4 instructions on ARM */
    uint32_t a, b;
    a = (s >> 3) & 0x1F001F;
    b = s & 0xFC00;
    a |= a >> 5;
    a |= b >> 5;
    return (uint16_t)a;
}

static force_inline uint32_t
convert_0565_to_0888 (uint16_t s)
{
    return (((((s) << 3) & 0xf8) | (((s) >> 2) & 0x7)) |
            ((((s) << 5) & 0xfc00) | (((s) >> 1) & 0x300)) |
            ((((s) << 8) & 0xf80000) | (((s) << 3) & 0x70000)));
}

static force_inline uint32_t
convert_0565_to_8888 (uint16_t s)
{
    return convert_0565_to_0888 (s) | 0xff000000;
}

/* Trivial versions that are useful in macros */

static force_inline uint32_t
convert_8888_to_8888 (uint32_t s)
{
    return s;
}

static force_inline uint32_t
convert_x888_to_8888 (uint32_t s)
{
    return s | 0xff000000;
}

static force_inline uint16_t
convert_0565_to_0565 (uint16_t s)
{
    return s;
}

#define PIXMAN_FORMAT_IS_WIDE(f)					\
    (PIXMAN_FORMAT_A (f) > 8 ||						\
     PIXMAN_FORMAT_R (f) > 8 ||						\
     PIXMAN_FORMAT_G (f) > 8 ||						\
     PIXMAN_FORMAT_B (f) > 8 ||						\
     PIXMAN_FORMAT_TYPE (f) == PIXMAN_TYPE_ARGB_SRGB)

#ifdef WORDS_BIGENDIAN
#   define SCREEN_SHIFT_LEFT(x,n)	((x) << (n))
#   define SCREEN_SHIFT_RIGHT(x,n)	((x) >> (n))
#else
#   define SCREEN_SHIFT_LEFT(x,n)	((x) >> (n))
#   define SCREEN_SHIFT_RIGHT(x,n)	((x) << (n))
#endif

static force_inline uint32_t
unorm_to_unorm (uint32_t val, int from_bits, int to_bits)
{
    uint32_t result;

    if (from_bits == 0)
	return 0;

    /* Delete any extra bits */
    val &= ((1 << from_bits) - 1);

    if (from_bits >= to_bits)
	return val >> (from_bits - to_bits);

    /* Start out with the high bit of val in the high bit of result. */
    result = val << (to_bits - from_bits);

    /* Copy the bits in result, doubling the number of bits each time, until
     * we fill all to_bits. Unrolled manually because from_bits and to_bits
     * are usually known statically, so the compiler can turn all of this
     * into a few shifts.
     */
#define REPLICATE()							\
    do									\
    {									\
	if (from_bits < to_bits)					\
	{								\
	    result |= result >> from_bits;				\
									\
	    from_bits *= 2;						\
	}								\
    }									\
    while (0)

    REPLICATE();
    REPLICATE();
    REPLICATE();
    REPLICATE();
    REPLICATE();

    return result;
}

uint16_t pixman_float_to_unorm (float f, int n_bits);
float pixman_unorm_to_float (uint16_t u, int n_bits);

/*
 * Various debugging code
 */

#undef DEBUG

#define COMPILE_TIME_ASSERT(x)						\
    do { typedef int compile_time_assertion [(x)?1:-1]; } while (0)

/* Turn on debugging depending on what type of release this is
 */
#if (((PIXMAN_VERSION_MICRO % 2) == 0) && ((PIXMAN_VERSION_MINOR % 2) == 1))

/* Debugging gets turned on for development releases because these
 * are the things that end up in bleeding edge distributions such
 * as Rawhide etc.
 *
 * For performance reasons we don't turn it on for stable releases or
 * random git checkouts. (Random git checkouts are often used for
 * performance work).
 */

#    define DEBUG

#endif

void
_pixman_log_error (const char *function, const char *message);

#define return_if_fail(expr)                                            \
    do                                                                  \
    {                                                                   \
	if (unlikely (!(expr)))                                         \
	{								\
	    _pixman_log_error (FUNC, "The expression " # expr " was false"); \
	    return;							\
	}								\
    }                                                                   \
    while (0)

#define return_val_if_fail(expr, retval)                                \
    do                                                                  \
    {                                                                   \
	if (unlikely (!(expr)))                                         \
	{								\
	    _pixman_log_error (FUNC, "The expression " # expr " was false"); \
	    return (retval);						\
	}								\
    }                                                                   \
    while (0)

#define critical_if_fail(expr)						\
    do									\
    {									\
	if (unlikely (!(expr)))                                         \
	    _pixman_log_error (FUNC, "The expression " # expr " was false"); \
    }									\
    while (0)

/*
 * Matrix
 */

typedef struct { pixman_fixed_48_16_t v[3]; } pixman_vector_48_16_t;

pixman_bool_t
pixman_transform_point_31_16 (const pixman_transform_t    *t,
                              const pixman_vector_48_16_t *v,
                              pixman_vector_48_16_t       *result);

void
pixman_transform_point_31_16_3d (const pixman_transform_t    *t,
                                 const pixman_vector_48_16_t *v,
                                 pixman_vector_48_16_t       *result);

void
pixman_transform_point_31_16_affine (const pixman_transform_t    *t,
                                     const pixman_vector_48_16_t *v,
                                     pixman_vector_48_16_t       *result);

/*
 * Timers
 */

#ifdef PIXMAN_TIMERS

static inline uint64_t
oil_profile_stamp_rdtsc (void)
{
    uint32_t hi, lo;

    __asm__ __volatile__ ("rdtsc\n" : "=a" (lo), "=d" (hi));

    return lo | (((uint64_t)hi) << 32);
}

#define OIL_STAMP oil_profile_stamp_rdtsc

typedef struct pixman_timer_t pixman_timer_t;

struct pixman_timer_t
{
    int             initialized;
    const char *    name;
    uint64_t        n_times;
    uint64_t        total;
    pixman_timer_t *next;
};

extern int timer_defined;

void pixman_timer_register (pixman_timer_t *timer);

#define TIMER_BEGIN(tname)                                              \
    {                                                                   \
	static pixman_timer_t timer ## tname;                           \
	uint64_t              begin ## tname;                           \
        								\
	if (!timer ## tname.initialized)				\
	{                                                               \
	    timer ## tname.initialized = 1;				\
	    timer ## tname.name = # tname;				\
	    pixman_timer_register (&timer ## tname);			\
	}                                                               \
									\
	timer ## tname.n_times++;					\
	begin ## tname = OIL_STAMP ();

#define TIMER_END(tname)                                                \
    timer ## tname.total += OIL_STAMP () - begin ## tname;		\
    }

#else

#define TIMER_BEGIN(tname)
#define TIMER_END(tname)

#endif /* PIXMAN_TIMERS */

#endif /* __ASSEMBLER__ */

#endif /* PIXMAN_PRIVATE_H */
@


1.13
log
@Update to pixman 0.32.4. Tested by naddy@@ and ajacoutot@@
@
text
@d10 1
a10 1
/* bilinear interpolation precision (must be <= 8) */
d348 2
a349 2
    pixman_fixed_t	    left_x;
    pixman_fixed_t          right_x;
@


1.12
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@d60 1
a60 1
typedef void (*fetch_scanline_t) (pixman_image_t *image,
d212 1
d216 2
a217 1
    ITER_NARROW =		(1 << 0),
d234 9
a242 3
    ITER_LOCALIZED_ALPHA =	(1 << 1),
    ITER_IGNORE_ALPHA =		(1 << 2),
    ITER_IGNORE_RGB =		(1 << 3)
d259 1
d267 13
a478 2
typedef pixman_bool_t (*pixman_iter_init_func_t) (pixman_implementation_t *imp,
						  pixman_iter_t           *iter);
d500 1
a503 2
    pixman_iter_init_func_t     src_iter_init;
    pixman_iter_init_func_t     dest_iter_init;
d564 11
a574 23
pixman_bool_t
_pixman_implementation_src_iter_init (pixman_implementation_t       *imp,
				      pixman_iter_t                 *iter,
				      pixman_image_t                *image,
				      int                            x,
				      int                            y,
				      int                            width,
				      int                            height,
				      uint8_t                       *buffer,
				      iter_flags_t                   flags,
				      uint32_t                       image_flags);

pixman_bool_t
_pixman_implementation_dest_iter_init (pixman_implementation_t       *imp,
				       pixman_iter_t                 *iter,
				       pixman_image_t                *image,
				       int                            x,
				       int                            y,
				       int                            width,
				       int                            height,
				       uint8_t                       *buffer,
				       iter_flags_t                   flags,
				       uint32_t                       image_flags);
d596 5
d662 3
d794 3
@


1.11
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@d1 2
a267 3
_pixman_solid_fill_iter_init (pixman_image_t *image, pixman_iter_t  *iter);

void
d322 4
a325 4
    uint32_t                left_ag;
    uint32_t                left_rb;
    uint32_t                right_ag;
    uint32_t                right_rb;
a327 1
    pixman_fixed_t          stepper;
d456 1
a456 1
					     uint32_t                 xor);
d501 1
a501 1
pixman_bool_t
d543 1
a543 1
                             uint32_t                 xor);
d688 1
d883 2
d887 19
a905 9
#define CONVERT_8888_TO_0565(s)						\
    ((((s) >> 3) & 0x001f) |						\
     (((s) >> 5) & 0x07e0) |						\
     (((s) >> 8) & 0xf800))

#define CONVERT_0565_TO_0888(s)						\
    (((((s) << 3) & 0xf8) | (((s) >> 2) & 0x7)) |			\
     ((((s) << 5) & 0xfc00) | (((s) >> 1) & 0x300)) |			\
     ((((s) << 8) & 0xf80000) | (((s) << 3) & 0x70000)))
d907 5
a911 1
#define CONVERT_0565_TO_8888(s) (CONVERT_0565_TO_0888(s) | 0xff000000)
d914 18
a931 3
#define CONVERT_8888_TO_8888(s) (s)
#define CONVERT_x888_TO_8888(s) ((s) | 0xff000000)
#define CONVERT_0565_TO_0565(s) (s)
a1019 2
#ifdef DEBUG

d1026 1
a1026 1
	if (!(expr))							\
d1037 1
a1037 1
	if (!(expr))                                                    \
d1048 1
a1048 1
	if (!(expr))							\
d1053 3
d1057 1
a1057 1
#else
d1059 4
a1062 1
#define _pixman_log_error(f,m) do { } while (0)				\
d1064 4
a1067 7
#define return_if_fail(expr)						\
    do                                                                  \
    {                                                                   \
	if (!(expr))							\
	    return;							\
    }                                                                   \
    while (0)
d1069 4
a1072 14
#define return_val_if_fail(expr, retval)                                \
    do                                                                  \
    {                                                                   \
	if (!(expr))							\
	    return (retval);						\
    }                                                                   \
    while (0)

#define critical_if_fail(expr)						\
    do									\
    {									\
    }									\
    while (0)
#endif
@


1.10
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@d1 17
a21 3
#ifndef PIXMAN_PRIVATE_H
#define PIXMAN_PRIVATE_H

d30 1
d48 10
d69 3
a71 3
typedef uint64_t (*fetch_pixel_64_t) (bits_image_t *image,
				      int           x,
				      int           y);
d125 1
a125 1
    
d127 1
a127 1
    uint64_t	   color_64;
a181 3
    fetch_scanline_t           get_scanline_32;
    fetch_scanline_t           get_scanline_64;

d186 3
a188 3
    fetch_scanline_t           fetch_scanline_64;
    fetch_pixel_64_t	       fetch_pixel_64;
    store_scanline_t           store_scanline_64;
d243 2
a244 1
    iter_flags_t		flags;
d251 1
d286 2
a287 1
                         int                  rowstride);
d428 6
a433 6
typedef void (*pixman_combine_64_func_t) (pixman_implementation_t *imp,
					  pixman_op_t              op,
					  uint64_t *               dest,
					  const uint64_t *         src,
					  const uint64_t *         mask,
					  int                      width);
d459 2
a460 2
typedef void (*pixman_iter_init_func_t) (pixman_implementation_t *imp,
                                         pixman_iter_t           *iter);
d463 1
a463 1
void _pixman_setup_combiner_functions_64 (pixman_implementation_t *imp);
d480 1
a480 1
    pixman_implementation_t *	delegate;
d490 2
a491 2
    pixman_combine_64_func_t	combine_64[PIXMAN_N_OPERATORS];
    pixman_combine_64_func_t	combine_64_ca[PIXMAN_N_OPERATORS];
d500 1
a500 1
_pixman_implementation_create (pixman_implementation_t *delegate,
d503 12
d547 1
a547 1
void
d556 2
a557 1
				      iter_flags_t                   flags);
d559 1
a559 1
void
d568 2
a569 1
				       iter_flags_t                   flags);
d611 15
d629 2
d636 13
d756 18
d792 9
a800 21
pixman_expand (uint64_t *           dst,
               const uint32_t *     src,
               pixman_format_code_t format,
               int                  width);

void
pixman_contract (uint32_t *      dst,
                 const uint64_t *src,
                 int             width);

pixman_bool_t
_pixman_lookup_composite_function (pixman_implementation_t     *toplevel,
				   pixman_op_t			op,
				   pixman_format_code_t		src_format,
				   uint32_t			src_flags,
				   pixman_format_code_t		mask_format,
				   uint32_t			mask_flags,
				   pixman_format_code_t		dest_format,
				   uint32_t			dest_flags,
				   pixman_implementation_t    **out_imp,
				   pixman_composite_func_t     *out_func);
d811 44
d907 2
a908 1
     PIXMAN_FORMAT_B (f) > 8)
d961 3
d1105 5
d1111 2
@


1.9
log
@Update to pixman 0.22.4. Tested by shadchin@@, krw@@.
@
text
@d478 5
a482 28
void
_pixman_implementation_combine_32 (pixman_implementation_t *imp,
                                   pixman_op_t              op,
                                   uint32_t *               dest,
                                   const uint32_t *         src,
                                   const uint32_t *         mask,
                                   int                      width);
void
_pixman_implementation_combine_64 (pixman_implementation_t *imp,
                                   pixman_op_t              op,
                                   uint64_t *               dest,
                                   const uint64_t *         src,
                                   const uint64_t *         mask,
                                   int                      width);
void
_pixman_implementation_combine_32_ca (pixman_implementation_t *imp,
                                      pixman_op_t              op,
                                      uint32_t *               dest,
                                      const uint32_t *         src,
                                      const uint32_t *         mask,
                                      int                      width);
void
_pixman_implementation_combine_64_ca (pixman_implementation_t *imp,
                                      pixman_op_t              op,
                                      uint64_t *               dest,
                                      const uint64_t *         src,
                                      const uint64_t *         mask,
                                      int                      width);
d542 1
a542 1
#if defined USE_X86_MMX || defined USE_ARM_IWMMXT
d562 5
d939 3
a941 1
    uint64_t ts;
d943 1
a943 2
    __asm__ __volatile__ ("rdtsc\n" : "=A" (ts));
    return ts;
@


1.8
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d253 13
d302 3
a304 3
    int32_t                 left_x;
    int32_t                 right_x;
    int32_t                 stepper;
d308 1
a308 1
    unsigned int            spread;
d310 1
a310 1
    int                     need_reset;
d316 1
a316 1
                              unsigned int              spread);
d320 1
a320 1
                               pixman_fixed_32_32_t      pos);
d324 1
a324 1
                               pixman_fixed_32_32_t      x);
d362 34
d411 1
a411 12
					 pixman_op_t              op,
					 pixman_image_t *         src,
					 pixman_image_t *         mask,
					 pixman_image_t *         dest,
					 int32_t                  src_x,
					 int32_t                  src_y,
					 int32_t                  mask_x,
					 int32_t                  mask_y,
					 int32_t                  dest_x,
					 int32_t                  dest_y,
					 int32_t                  width,
					 int32_t                  height);
d421 2
a422 2
					    int                      dst_x,
					    int                      dst_y,
d517 2
a518 2
                            int                      dst_x,
                            int                      dst_y,
d562 4
a565 1
#ifdef USE_MMX
d629 10
a638 8
#define FAST_PATH_SAMPLES_COVER_CLIP		(1 << 16)
#define FAST_PATH_X_UNIT_POSITIVE		(1 << 17)
#define FAST_PATH_AFFINE_TRANSFORM		(1 << 18)
#define FAST_PATH_Y_UNIT_ZERO			(1 << 19)
#define FAST_PATH_BILINEAR_FILTER		(1 << 20)
#define FAST_PATH_ROTATE_90_TRANSFORM		(1 << 21)
#define FAST_PATH_ROTATE_180_TRANSFORM		(1 << 22)
#define FAST_PATH_ROTATE_270_TRANSFORM		(1 << 23)
d674 1
a674 1
      0 : (FAST_PATH_SAMPLES_COVER_CLIP | FAST_PATH_ID_TRANSFORM)))
d713 1
a713 1
pixman_multiply_overflows_int (unsigned int a, unsigned int b);
d716 4
a719 1
pixman_addition_overflows_int (unsigned int a, unsigned int b);
d733 11
d799 1
d815 43
@


1.7
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@a22 1
typedef struct source_image source_image_t;
a62 11
typedef enum
{
    SOURCE_IMAGE_CLASS_UNKNOWN,
    SOURCE_IMAGE_CLASS_HORIZONTAL,
} source_image_class_t;

typedef source_image_class_t (*classify_func_t) (pixman_image_t *image,
						int             x,
						int             y,
						int             width,
						int             height);
a86 1
    classify_func_t             classify;
a87 2
    fetch_scanline_t            get_scanline_32;
    fetch_scanline_t            get_scanline_64;
d96 1
a96 1
struct source_image
a98 5
};

struct solid_fill
{
    source_image_t common;
d107 1
a107 1
    source_image_t          common;
a109 1
    int                     stop_range;
d157 3
a177 1
    source_image_t     source;
d185 47
d236 10
a245 21
_pixman_image_get_scanline_generic_64  (pixman_image_t *image,
                                        int             x,
                                        int             y,
                                        int             width,
                                        uint32_t *      buffer,
                                        const uint32_t *mask);

source_image_class_t
_pixman_image_classify (pixman_image_t *image,
                        int             x,
                        int             y,
                        int             width,
                        int             height);

void
_pixman_image_get_scanline_32 (pixman_image_t *image,
                               int             x,
                               int             y,
                               int             width,
                               uint32_t *      buffer,
                               const uint32_t *mask);
a246 3
/* Even thought the type of buffer is uint32_t *, the function actually expects
 * a uint64_t *buffer.
 */
d248 1
a248 13
_pixman_image_get_scanline_64 (pixman_image_t *image,
                               int             x,
                               int             y,
                               int             width,
                               uint32_t *      buffer,
                               const uint32_t *unused);

void
_pixman_image_store_scanline_32 (bits_image_t *  image,
                                 int             x,
                                 int             y,
                                 int             width,
                                 const uint32_t *buffer);
a249 3
/* Even though the type of buffer is uint32_t *, the function
 * actually expects a uint64_t *buffer.
 */
d251 1
a251 5
_pixman_image_store_scanline_64 (bits_image_t *  image,
                                 int             x,
                                 int             y,
                                 int             width,
                                 const uint32_t *buffer);
a265 4
uint32_t
_pixman_image_get_solid (pixman_image_t *     image,
                         pixman_format_code_t format);

d398 2
d421 1
a421 1
    
d424 2
d433 5
d497 22
d524 1
a524 1
_pixman_implementation_create_fast_path (void);
d528 1
a528 1
_pixman_implementation_create_mmx (void);
d533 1
a533 1
_pixman_implementation_create_sse2 (void);
d538 1
a538 1
_pixman_implementation_create_arm_simd (void);
d543 1
a543 1
_pixman_implementation_create_arm_neon (void);
d548 1
a548 1
_pixman_implementation_create_vmx (void);
d559 2
d588 1
a588 1
#define FAST_PATH_NEEDS_WORKAROUND		(1 << 14)
d595 3
a597 1
#define FAST_PATH_NO_NORMAL_REPEAT		(1 << 21)
@


1.6
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d39 1
a39 2
				  const uint32_t *mask,
				  uint32_t        mask_bits);
a67 1
    SOURCE_IMAGE_CLASS_VERTICAL,
d82 1
a113 1
    source_image_class_t class;
d153 5
a157 4
    double     cdx;
    double     cdy;
    double     dr;
    double     A;
d164 1
a164 1
    pixman_fixed_t       angle;
d178 3
a180 3
    /* Fetch a pixel, disregarding alpha maps, transformations etc. */
    fetch_pixel_32_t	       fetch_pixel_raw_32;
    fetch_pixel_64_t	       fetch_pixel_raw_64;
d182 1
a182 2
    /* Fetch a pixel, taking alpha maps into account */
    fetch_pixel_32_t	       fetch_pixel_32;
a183 11

    /* Fetch raw scanlines, with no regard for transformations, alpha maps etc. */
    fetch_scanline_t           fetch_scanline_raw_32;
    fetch_scanline_t           fetch_scanline_raw_64;

    /* Store scanlines with no regard for alpha maps */
    store_scanline_t           store_scanline_raw_32;
    store_scanline_t           store_scanline_raw_64;

    /* Store a scanline, taking alpha maps into account */
    store_scanline_t           store_scanline_32;
a203 1

d205 1
a205 1
_pixman_bits_image_setup_raw_accessors (bits_image_t *image);
d213 1
a213 2
                                        const uint32_t *mask,
                                        uint32_t        mask_bits);
d228 1
a228 2
                               const uint32_t *mask,
                               uint32_t        mask_bits);
d239 1
a239 2
                               const uint32_t *unused,
                               uint32_t        unused2);
d556 1
a556 2
#define FAST_PATH_NO_WIDE_FORMAT		(1 <<  6)
#define FAST_PATH_COVERS_CLIP			(1 <<  7)
d558 1
d562 1
a562 1
#define FAST_PATH_SIMPLE_REPEAT			(1 << 12)
d567 15
a581 2
#define FAST_PATH_16BIT_SAFE			(1 << 17)
#define FAST_PATH_X_UNIT_POSITIVE		(1 << 18)
d583 2
a584 4
#define _FAST_PATH_STANDARD_FLAGS					\
    (FAST_PATH_ID_TRANSFORM		|				\
     FAST_PATH_NO_ALPHA_MAP		|				\
     FAST_PATH_NO_CONVOLUTION_FILTER	|				\
d586 9
a594 1
     FAST_PATH_NO_REFLECT_REPEAT	|				\
d596 2
a597 2
     FAST_PATH_NO_WIDE_FORMAT		|				\
     FAST_PATH_COVERS_CLIP)
a598 8
#define FAST_PATH_STD_SRC_FLAGS						\
    _FAST_PATH_STANDARD_FLAGS
#define FAST_PATH_STD_MASK_U_FLAGS					\
    (_FAST_PATH_STANDARD_FLAGS		|				\
     FAST_PATH_UNIFIED_ALPHA)
#define FAST_PATH_STD_MASK_CA_FLAGS					\
    (_FAST_PATH_STANDARD_FLAGS		|				\
     FAST_PATH_COMPONENT_ALPHA)
d601 10
a610 1
     FAST_PATH_NO_WIDE_FORMAT)
d624 5
a628 5
	  op,								\
	  src, FAST_PATH_STD_SRC_FLAGS,					\
	  mask, (PIXMAN_ ## mask) ? FAST_PATH_STD_MASK_U_FLAGS : 0,	\
	  dest, FAST_PATH_STD_DEST_FLAGS,				\
	  func) }
d632 5
a636 5
	  op,								\
	  src, FAST_PATH_STD_SRC_FLAGS,					\
	  mask, FAST_PATH_STD_MASK_CA_FLAGS,				\
	  dest, FAST_PATH_STD_DEST_FLAGS,				\
	  func) }
d739 3
@


1.5
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@d8 3
d14 2
a90 1
    pixman_bool_t               need_workaround;
d107 3
d121 4
a124 1
    uint32_t       color;    /* FIXME: shouldn't this be a pixman_color_t? */
a132 2
    uint32_t *              color_table;
    int                     color_table_size;
a263 4
void
_pixman_image_fetch_pixels (bits_image_t *image,
                            uint32_t *    buffer,
                            int           n_pixels);
a287 6
pixman_bool_t
_pixman_image_is_opaque (pixman_image_t *image);

pixman_bool_t
_pixman_image_is_solid (pixman_image_t *image);

d350 1
a350 1
#define Y_FRAC_FIRST(n) (STEP_Y_SMALL (n) / 2)
d356 1
a356 1
#define X_FRAC_FIRST(n) (STEP_X_SMALL (n) / 2)
a372 1

d428 12
d442 11
a452 11
    pixman_implementation_t *toplevel;
    pixman_implementation_t *delegate;

    pixman_composite_func_t  composite;
    pixman_blt_func_t        blt;
    pixman_fill_func_t       fill;

    pixman_combine_32_func_t combine_32[PIXMAN_OP_LAST];
    pixman_combine_32_func_t combine_32_ca[PIXMAN_OP_LAST];
    pixman_combine_64_func_t combine_64[PIXMAN_OP_LAST];
    pixman_combine_64_func_t combine_64_ca[PIXMAN_OP_LAST];
d456 2
a457 1
_pixman_implementation_create (pixman_implementation_t *delegate);
a486 14
void
_pixman_implementation_composite (pixman_implementation_t *imp,
                                  pixman_op_t              op,
                                  pixman_image_t *         src,
                                  pixman_image_t *         mask,
                                  pixman_image_t *         dest,
                                  int32_t                  src_x,
                                  int32_t                  src_y,
                                  int32_t                  mask_x,
                                  int32_t                  mask_y,
                                  int32_t                  dest_x,
                                  int32_t                  dest_y,
                                  int32_t                  width,
                                  int32_t                  height);
d555 1
a555 1
/* These "formats" both have depth 0, so they
d560 74
a633 14

#define NEED_COMPONENT_ALPHA            (1 << 0)
#define NEED_PIXBUF                     (1 << 1)
#define NEED_SOLID_MASK                 (1 << 2)

typedef struct
{
    pixman_op_t             op;
    pixman_format_code_t    src_format;
    pixman_format_code_t    mask_format;
    pixman_format_code_t    dest_format;
    pixman_composite_func_t func;
    uint32_t                flags;
} pixman_fast_path_t;
a648 32
pixman_bool_t
_pixman_run_fast_path (const pixman_fast_path_t *paths,
                       pixman_implementation_t * imp,
                       pixman_op_t               op,
                       pixman_image_t *          src,
                       pixman_image_t *          mask,
                       pixman_image_t *          dest,
                       int32_t                   src_x,
                       int32_t                   src_y,
                       int32_t                   mask_x,
                       int32_t                   mask_y,
                       int32_t                   dest_x,
                       int32_t                   dest_y,
                       int32_t                   width,
                       int32_t                   height);

void
_pixman_walk_composite_region (pixman_implementation_t *imp,
                               pixman_op_t              op,
                               pixman_image_t *         src_image,
                               pixman_image_t *         mask_image,
                               pixman_image_t *         dst_image,
                               int16_t                  src_x,
                               int16_t                  src_y,
                               int16_t                  mask_x,
                               int16_t                  mask_y,
                               int16_t                  dest_x,
                               int16_t                  dest_y,
                               uint16_t                 width,
                               uint16_t                 height,
                               pixman_composite_func_t  composite_rect);

d711 6
d723 8
a735 1
#define DEBUG 0
d737 21
a757 1
#if DEBUG
d762 5
a766 5
	if (!(expr))                                                    \
	{                                                               \
	    fprintf (stderr, "In %s: %s failed\n", FUNC, # expr);	\
	    return;                                                     \
	}                                                               \
d774 4
a777 4
	{                                                               \
	    fprintf (stderr, "In %s: %s failed\n", FUNC, # expr);	\
	    return (retval);                                            \
	}                                                               \
d781 9
d792 3
a794 1
#define return_if_fail(expr)                                            \
d810 5
@


1.4
log
@Update to pixman 0.15.8.
@
text
@d12 1
a12 126
#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE 1
#endif

#define MSBFirst 0
#define LSBFirst 1

#ifdef WORDS_BIGENDIAN
#  define IMAGE_BYTE_ORDER MSBFirst
#  define BITMAP_BIT_ORDER MSBFirst
#else
#  define IMAGE_BYTE_ORDER LSBFirst
#  define BITMAP_BIT_ORDER LSBFirst
#endif

#undef DEBUG
#define DEBUG 0

#if defined (__GNUC__)
#  define FUNC     ((const char*) (__PRETTY_FUNCTION__))
#elif defined (__sun) || (defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L)
#  define FUNC     ((const char*) (__func__))
#else
#  define FUNC     ((const char*) ("???"))
#endif

#ifndef INT16_MIN
# define INT16_MIN              (-32767-1)
#endif

#ifndef INT16_MAX
# define INT16_MAX              (32767)
#endif

#ifndef INT32_MIN
# define INT32_MIN              (-2147483647-1)
#endif

#ifndef INT32_MAX
# define INT32_MAX              (2147483647)
#endif

#ifndef UINT32_MIN
# define UINT32_MIN             (0)
#endif

#ifndef UINT32_MAX
# define UINT32_MAX             (4294967295U)
#endif

#ifndef M_PI
# define M_PI			3.14159265358979323846
#endif

#ifdef _MSC_VER
/* 'inline' is available only in C++ in MSVC */
#   define inline __inline
#   define force_inline __forceinline
#elif defined __GNUC__ || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
#   define inline __inline__
#   define force_inline __inline__ __attribute__ ((__always_inline__))
#else
# ifndef force_inline
#  define force_inline inline
# endif
#endif

#define FB_SHIFT    5
#define FB_UNIT     (1 << FB_SHIFT)
#define FB_HALFUNIT (1 << (FB_SHIFT-1))
#define FB_MASK     (FB_UNIT - 1)
#define FB_ALLONES  ((uint32_t) -1)

/* Memory allocation helpers */
void *pixman_malloc_ab (unsigned int n, unsigned int b);
void *pixman_malloc_abc (unsigned int a, unsigned int b, unsigned int c);
pixman_bool_t pixman_multiply_overflows_int (unsigned int a, unsigned int b);
pixman_bool_t pixman_addition_overflows_int (unsigned int a, unsigned int b);

#if DEBUG

#define return_if_fail(expr)						\
    do									\
    {									\
	if (!(expr))							\
	{								\
	    fprintf(stderr, "In %s: %s failed\n", FUNC, #expr);		\
	    return;							\
	}								\
    }									\
    while (0)

#define return_val_if_fail(expr, retval) 				\
    do									\
    {									\
	if (!(expr))							\
	{								\
	    fprintf(stderr, "In %s: %s failed\n", FUNC, #expr);		\
	    return (retval);						\
	}								\
    }									\
    while (0)

#else

#define return_if_fail(expr)						\
    do									\
    {									\
	if (!(expr))							\
	    return;							\
    }									\
    while (0)

#define return_val_if_fail(expr, retval)				\
    do									\
    {									\
	if (!(expr))							\
	    return (retval);						\
    }									\
    while (0)

#endif
d14 3
a27 1
typedef struct point point_t;
d29 21
a49 78
/* FIXME - the types and structures below should be give proper names
 */

#define FASTCALL
typedef FASTCALL void (*CombineFunc32) (uint32_t *dest, const uint32_t *src, const uint32_t *mask, int width);
typedef FASTCALL void (*fetchProc32)(bits_image_t *pict, int x, int y, int width,
                                     uint32_t *buffer);
typedef FASTCALL uint32_t (*fetchPixelProc32)(bits_image_t *pict, int offset, int line);
typedef FASTCALL void (*storeProc32)(pixman_image_t *, uint32_t *bits,
                                     const uint32_t *values, int x, int width,
                                     const pixman_indexed_t *);

typedef FASTCALL void (*CombineFunc64) (uint64_t *dest, const uint64_t *src, const uint64_t *mask, int width);
typedef FASTCALL void (*fetchProc64)(bits_image_t *pict, int x, int y, int width,
                                     uint64_t *buffer);
typedef FASTCALL uint64_t (*fetchPixelProc64)(bits_image_t *pict, int offset, int line);
typedef FASTCALL void (*storeProc64)(pixman_image_t *, uint32_t *bits,
                                     const uint64_t *values, int x, int width,
                                     const pixman_indexed_t *);

typedef struct _FbComposeData {
    uint8_t	 op;
    pixman_image_t	*src;
    pixman_image_t	*mask;
    pixman_image_t	*dest;
    int16_t	 xSrc;
    int16_t	 ySrc;
    int16_t	 xMask;
    int16_t	 yMask;
    int16_t	 xDest;
    int16_t	 yDest;
    uint16_t	 width;
    uint16_t	 height;
} FbComposeData;

void pixman_composite_rect_general_accessors (const FbComposeData *data,
                                              void *src_buffer,
                                              void *mask_buffer,
                                              void *dest_buffer,
                                              const int wide);
void pixman_composite_rect_general (const FbComposeData *data);

fetchProc32 pixman_fetchProcForPicture32 (bits_image_t *);
fetchPixelProc32 pixman_fetchPixelProcForPicture32 (bits_image_t *);
storeProc32 pixman_storeProcForPicture32 (bits_image_t *);
fetchProc32 pixman_fetchProcForPicture32_accessors (bits_image_t *);
fetchPixelProc32 pixman_fetchPixelProcForPicture32_accessors (bits_image_t *);
storeProc32 pixman_storeProcForPicture32_accessors (bits_image_t *);

fetchProc64 pixman_fetchProcForPicture64 (bits_image_t *);
fetchPixelProc64 pixman_fetchPixelProcForPicture64 (bits_image_t *);
storeProc64 pixman_storeProcForPicture64 (bits_image_t *);
fetchProc64 pixman_fetchProcForPicture64_accessors (bits_image_t *);
fetchPixelProc64 pixman_fetchPixelProcForPicture64_accessors (bits_image_t *);
storeProc64 pixman_storeProcForPicture64_accessors (bits_image_t *);

void pixman_expand(uint64_t *dst, const uint32_t *src, pixman_format_code_t, int width);
void pixman_contract(uint32_t *dst, const uint64_t *src, int width);

void pixmanFetchGradient (gradient_t *, int x, int y, int width,
                           uint32_t *buffer, uint32_t *mask, uint32_t maskBits);
void _pixman_image_get_scanline_64_generic (pixman_image_t * pict, int x, int y, int width,
					    uint64_t *buffer, uint64_t *mask, uint32_t maskBits);
void fbFetchTransformed(bits_image_t *, int x, int y, int width,
                        uint32_t *buffer, uint32_t *mask, uint32_t maskBits);
void fbFetchExternalAlpha(bits_image_t *, int x, int y, int width,
                          uint32_t *buffer, uint32_t *mask, uint32_t maskBits);

void fbFetchTransformed_accessors(bits_image_t *, int x, int y, int width,
                                  uint32_t *buffer, uint32_t *mask,
                                  uint32_t maskBits);
void fbStoreExternalAlpha_accessors(bits_image_t *, int x, int y, int width,
                                    uint32_t *buffer);
void fbFetchExternalAlpha_accessors(bits_image_t *, int x, int y, int width,
                                    uint32_t *buffer, uint32_t *mask,
                                    uint32_t maskBits);

/* end */
a59 2
#define IS_SOURCE_IMAGE(img)     (((image_common_t *)img)->type > BITS)

d65 1
a65 1
} source_pict_class_t;
d67 6
a72 9
typedef void (*scanStoreProc)(bits_image_t *img, int x, int y, int width, uint32_t *buffer);
typedef void (*scanFetchProc)(pixman_image_t *, int, int, int, uint32_t *,
			      uint32_t *, uint32_t);

source_pict_class_t _pixman_image_classify (pixman_image_t *image,
					    int             x,
					    int             y,
					    int             width,
					    int             height);
d74 1
a74 32
void
_pixman_image_get_scanline_32 (pixman_image_t *image, int x, int y, int width,
			       uint32_t *buffer, uint32_t *mask, uint32_t mask_bits);

/* Even thought the type of buffer is uint32_t *, the function actually expects
 * a uint64_t *buffer.
 */
void
_pixman_image_get_scanline_64 (pixman_image_t *image, int x, int y, int width,
			       uint32_t *buffer, uint32_t *unused, uint32_t unused2);

void
_pixman_image_store_scanline_32 (bits_image_t *image, int x, int y, int width,
				 uint32_t *buffer);
/* Even thought the type of buffer is uint32_t *, the function actually expects
 * a uint64_t *buffer.
 */
void
_pixman_image_store_scanline_64 (bits_image_t *image, int x, int y, int width,
				 uint32_t *buffer);

pixman_image_t *
_pixman_image_allocate (void);

pixman_bool_t
_pixman_init_gradient (gradient_t     *gradient,
		       const pixman_gradient_stop_t *stops,
		       int	       n_stops);
void
_pixman_image_reset_clip_region (pixman_image_t *image);

struct point
d76 24
a99 2
    int16_t x, y;
};
d101 2
a102 29
typedef source_pict_class_t (* classify_func_t) (pixman_image_t *image,
						 int             x,
						 int             y,
						 int             width,
						 int             height);
typedef void (* property_changed_func_t)        (pixman_image_t *image);

struct image_common
{
    image_type_t		type;
    int32_t			ref_count;
    pixman_region32_t		full_region;
    pixman_region32_t		clip_region;
    pixman_region32_t	       *src_clip;
    pixman_bool_t               has_client_clip;
    pixman_transform_t	       *transform;
    pixman_repeat_t		repeat;
    pixman_filter_t		filter;
    pixman_fixed_t	       *filter_params;
    int				n_filter_params;
    bits_image_t	       *alpha_map;
    point_t			alpha_origin;
    pixman_bool_t		component_alpha;
    pixman_read_memory_func_t	read_func;
    pixman_write_memory_func_t	write_func;
    classify_func_t		classify;
    property_changed_func_t	property_changed;
    scanFetchProc		get_scanline_32;
    scanFetchProc		get_scanline_64;
d107 2
a108 2
    image_common_t	common;
    source_pict_class_t class;
d113 2
a114 2
    source_image_t	common;
    uint32_t		color;		/* FIXME: shouldn't this be a pixman_color_t? */
d119 6
a124 6
    source_image_t		common;
    int				n_stops;
    pixman_gradient_stop_t *	stops;
    int				stop_range;
    uint32_t *			color_table;
    int				color_table_size;
d129 3
a131 3
    gradient_t			common;
    pixman_point_fixed_t	p1;
    pixman_point_fixed_t	p2;
d143 1
a143 1
    gradient_t	common;
d145 6
a150 6
    circle_t	c1;
    circle_t	c2;
    double	cdx;
    double	cdy;
    double	dr;
    double	A;
d155 3
a157 3
    gradient_t			common;
    pixman_point_fixed_t	center;
    pixman_fixed_t		angle;
d162 32
a193 11
    image_common_t		common;
    pixman_format_code_t	format;
    const pixman_indexed_t     *indexed;
    int				width;
    int				height;
    uint32_t *			bits;
    uint32_t *			free_me;
    int				rowstride; /* in number of uint32_t's */

    scanStoreProc		store_scanline_32;
    scanStoreProc		store_scanline_64;
d198 9
a206 9
    image_type_t		type;
    image_common_t		common;
    bits_image_t		bits;
    source_image_t		source;
    gradient_t			gradient;
    linear_gradient_t		linear;
    conical_gradient_t		conical;
    radial_gradient_t		radial;
    solid_fill_t		solid;
d209 54
a262 1
/* Gradient walker
d264 6
a269 13
typedef struct
{
    uint32_t        left_ag;
    uint32_t        left_rb;
    uint32_t        right_ag;
    uint32_t        right_rb;
    int32_t       left_x;
    int32_t       right_x;
    int32_t       stepper;

    pixman_gradient_stop_t	*stops;
    int                      num_stops;
    unsigned int             spread;
d271 2
a272 2
    int		  need_reset;
} GradientWalker;
d274 4
d279 1
a279 3
_pixman_gradient_walker_init (GradientWalker  *walker,
			      gradient_t      *gradient,
			      unsigned int     spread);
d282 7
a288 2
_pixman_gradient_walker_reset (GradientWalker       *walker,
			       pixman_fixed_32_32_t  pos);
d291 2
a292 2
_pixman_gradient_walker_pixel (GradientWalker       *walker,
			       pixman_fixed_32_32_t  x);
d294 13
d308 12
d321 3
a323 5
#define LOG2_BITMAP_PAD 5
#define FB_STIP_SHIFT	LOG2_BITMAP_PAD
#define FB_STIP_UNIT	(1 << FB_STIP_SHIFT)
#define FB_STIP_MASK	(FB_STIP_UNIT - 1)
#define FB_STIP_ALLONES	((uint32_t) -1)
d325 2
a326 9
#if BITMAP_BIT_ORDER == LSBFirst
#define FbScrLeft(x,n)	((x) >> (n))
#define FbScrRight(x,n)	((x) << (n))
#define FbLeftStipBits(x,n) ((x) & ((((uint32_t) 1) << (n)) - 1))
#else
#define FbScrLeft(x,n)	((x) << (n))
#define FbScrRight(x,n)	((x) >> (n))
#define FbLeftStipBits(x,n) ((x) >> (FB_STIP_UNIT - (n)))
#endif
d328 4
a331 24
#define FbStipLeft(x,n)	FbScrLeft(x,n)
#define FbStipRight(x,n) FbScrRight(x,n)
#define FbStipMask(x,w)	(FbStipRight(FB_STIP_ALLONES,(x) & FB_STIP_MASK) & \
			 FbStipLeft(FB_STIP_ALLONES,(FB_STIP_UNIT - ((x)+(w))) & FB_STIP_MASK))

#define FbLeftMask(x)       ( ((x) & FB_MASK) ? \
			      FbScrRight(FB_ALLONES,(x) & FB_MASK) : 0)
#define FbRightMask(x)      ( ((FB_UNIT - (x)) & FB_MASK) ? \
			      FbScrLeft(FB_ALLONES,(FB_UNIT - (x)) & FB_MASK) : 0)

#define FbMaskBits(x,w,l,n,r) {						\
	n = (w); \
	r = FbRightMask((x)+n); \
	l = FbLeftMask(x); \
	if (l) { \
	    n -= FB_UNIT - ((x) & FB_MASK); \
	    if (n < 0) { \
		n = 0; \
		l &= r; \
		r = 0; \
	    } \
	} \
	n >>= FB_SHIFT; \
    }
d333 3
a335 19
#if IMAGE_BYTE_ORDER == MSBFirst
#define Fetch24(img, a)  ((unsigned long) (a) & 1 ?	      \
    ((READ(img, a) << 16) | READ(img, (uint16_t *) ((a)+1))) : \
    ((READ(img, (uint16_t *) (a)) << 8) | READ(img, (a)+2)))
#define Store24(img,a,v) ((unsigned long) (a) & 1 ? \
    (WRITE(img, a, (uint8_t) ((v) >> 16)),		  \
     WRITE(img, (uint16_t *) ((a)+1), (uint16_t) (v))) :  \
    (WRITE(img, (uint16_t *) (a), (uint16_t) ((v) >> 8)), \
     WRITE(img, (a)+2, (uint8_t) (v))))
#else
#define Fetch24(img,a)  ((unsigned long) (a) & 1 ?			     \
    (READ(img, a) | (READ(img, (uint16_t *) ((a)+1)) << 8)) : \
    (READ(img, (uint16_t *) (a)) | (READ(img, (a)+2) << 16)))
#define Store24(img,a,v) ((unsigned long) (a) & 1 ? \
    (WRITE(img, a, (uint8_t) (v)),				\
     WRITE(img, (uint16_t *) ((a)+1), (uint16_t) ((v) >> 8))) : \
    (WRITE(img, (uint16_t *) (a), (uint16_t) (v)),		\
     WRITE(img, (a)+2, (uint8_t) ((v) >> 16))))
#endif
d337 3
a339 24
#define CvtR8G8B8toY15(s)       (((((s) >> 16) & 0xff) * 153 + \
                                  (((s) >>  8) & 0xff) * 301 +		\
                                  (((s)      ) & 0xff) * 58) >> 2)
#define miCvtR8G8B8to15(s) ((((s) >> 3) & 0x001f) |  \
			    (((s) >> 6) & 0x03e0) |  \
			    (((s) >> 9) & 0x7c00))
#define miIndexToEnt15(mif,rgb15) ((mif)->ent[rgb15])
#define miIndexToEnt24(mif,rgb24) miIndexToEnt15(mif,miCvtR8G8B8to15(rgb24))

#define miIndexToEntY24(mif,rgb24) ((mif)->ent[CvtR8G8B8toY15(rgb24)])


#define FbIntMult(a,b,t) ( (t) = (a) * (b) + 0x80, ( ( ( (t)>>8 ) + (t) )>>8 ) )
#define FbIntDiv(a,b)	 (((uint16_t) (a) * 255) / (b))

#define FbGet8(v,i)   ((uint16_t) (uint8_t) ((v) >> i))


#define cvt8888to0565(s)    ((((s) >> 3) & 0x001f) | \
			     (((s) >> 5) & 0x07e0) | \
			     (((s) >> 8) & 0xf800))
#define cvt0565to0888(s)    (((((s) << 3) & 0xf8) | (((s) >> 2) & 0x7)) | \
			     ((((s) << 5) & 0xfc00) | (((s) >> 1) & 0x300)) | \
			     ((((s) << 8) & 0xf80000) | (((s) << 3) & 0x70000)))
d342 1
a342 5
 * There are two ways of handling alpha -- either as a single unified value or
 * a separate value for each component, hence each macro must have two
 * versions.  The unified alpha version has a 'U' at the end of the name,
 * the component version has a 'C'.  Similarly, functions which deal with
 * this difference will have two versions using the same convention.
d345 3
a347 2
#define FbOverU(x,y,i,a,t) ((t) = FbIntMult(FbGet8(y,i),(a),(t)) + FbGet8(x,i),	\
			    (uint32_t) ((uint8_t) ((t) | (0 - ((t) >> 8)))) << (i))
d349 2
a350 2
#define FbOverC(x,y,i,a,t) ((t) = FbIntMult(FbGet8(y,i),FbGet8(a,i),(t)) + FbGet8(x,i),	\
			    (uint32_t) ((uint8_t) ((t) | (0 - ((t) >> 8)))) << (i))
d352 2
a353 1
#define FbInU(x,i,a,t) ((uint32_t) FbIntMult(FbGet8(x,i),(a),(t)) << (i))
d355 2
a356 1
#define FbInC(x,i,a,t) ((uint32_t) FbIntMult(FbGet8(x,i),FbGet8(a,i),(t)) << (i))
d358 2
a359 2
#define FbAdd(x,y,i,t)	((t) = FbGet8(x,i) + FbGet8(y,i),		\
			 (uint32_t) ((uint8_t) ((t) | (0 - ((t) >> 8)))) << (i))
d361 3
a363 2
#define div_255(x) (((x) + 0x80 + (((x) + 0x80) >> 8)) >> 8)
#define div_65535(x) (((x) + 0x8000 + (((x) + 0x8000) >> 16)) >> 16)
d365 65
a429 1
#define MOD(a,b) ((a) < 0 ? ((b) - ((-(a) - 1) % (b))) - 1 : (a) % (b))
d431 4
a434 2
#define DIV(a,b) ((((a) < 0) == ((b) < 0)) ? (a) / (b) :		\
		  ((a) - (b) + 1 - (((b) < 0) << 1)) / (b))
d436 9
a444 1
#define CLIP(a,b,c) ((a) < (b) ? (b) : ((a) > (c) ? (c) : (a)))
d446 2
a447 4
#if 0
/* FIXME: the MOD macro above is equivalent, but faster I think */
#define mod(a,b) ((b) == 1 ? 0 : (a) >= 0 ? (a) % (b) : (b) - (-a) % (b))
#endif
d449 42
a490 4
/* FIXME: the (void)__read_func hides lots of warnings (which is what they
 * are supposed to do), but some of them are real. For example the one
 * where Fetch4 doesn't have a READ
 */
d492 14
a505 33
#if 0
/* Framebuffer access support macros */
#define ACCESS_MEM(code)						\
    do {								\
	const image_common_t *const com__ =				\
	    (image_common_t *)image;					\
									\
	if (!com__->read_func && !com__->write_func)			\
	{								\
	    const int do_access__ = 0;					\
	    const pixman_read_memory_func_t read_func__ = NULL;		\
	    const pixman_write_memory_func_t write_func__ = NULL;	\
	    (void)read_func__;						\
	    (void)write_func__;						\
	    (void)do_access__;						\
									\
	    {code}							\
	}								\
	else								\
	{								\
	    const int do_access__ = 1;					\
	    const pixman_read_memory_func_t read_func__ =		\
		com__->read_func;					\
	    const pixman_write_memory_func_t write_func__ =		\
		com__->write_func;					\
	    (void)read_func__;						\
	    (void)write_func__;						\
	    (void)do_access__;						\
	    								\
	    {code}							\
	}								\
    } while (0)
#endif
d507 10
a516 1
#ifdef PIXMAN_FB_ACCESSORS
d518 3
a520 1
#define ACCESS(sym) sym##_accessors
d522 2
a523 13
#define READ(img, ptr)							\
    ((img)->common.read_func ((ptr), sizeof(*(ptr))))
#define WRITE(img, ptr,val)						\
    ((img)->common.write_func ((ptr), (val), sizeof (*(ptr))))

#define MEMCPY_WRAPPED(img, dst, src, size)				\
    do {								\
	size_t _i;							\
	uint8_t *_dst = (uint8_t*)(dst), *_src = (uint8_t*)(src);	\
	for(_i = 0; _i < size; _i++) {					\
	    WRITE((img), _dst +_i, READ((img), _src + _i));		\
	}								\
    } while (0)
d525 4
a528 8
#define MEMSET_WRAPPED(img, dst, val, size)				\
    do {								\
	size_t _i;							\
	uint8_t *_dst = (uint8_t*)(dst);				\
	for(_i = 0; _i < (size_t) size; _i++) {				\
	    WRITE((img), _dst +_i, (val));				\
	}								\
    } while (0)
d530 4
a533 1
#else
d535 4
a538 1
#define ACCESS(sym) sym
d540 4
a543 6
#define READ(img, ptr)		(*(ptr))
#define WRITE(img, ptr, val)	(*(ptr) = (val))
#define MEMCPY_WRAPPED(img, dst, src, size)				\
    memcpy(dst, src, size)
#define MEMSET_WRAPPED(img, dst, val, size)				\
    memset(dst, val, size)
d545 3
d550 2
a551 52
#define fbComposeGetSolid(img, res, fmt)				\
    do									\
    {									\
	pixman_format_code_t format__;					\
	if (img->type == SOLID)						\
	{								\
	    format__ = PIXMAN_a8r8g8b8;					\
	    (res) = img->solid.color;					\
	}								\
	else								\
	{								\
	    uint32_t	       *bits__   = (img)->bits.bits;		\
	    format__ = (img)->bits.format;				\
		  							\
	    switch (PIXMAN_FORMAT_BPP((img)->bits.format))		\
	    {								\
	    case 32:							\
		(res) = READ(img, (uint32_t *)bits__);			\
		break;							\
	    case 24:							\
		(res) = Fetch24(img, (uint8_t *) bits__);		\
		break;							\
	    case 16:							\
		(res) = READ(img, (uint16_t *) bits__);			\
		(res) = cvt0565to0888(res);				\
		break;							\
	    case 8:							\
		(res) = READ(img, (uint8_t *) bits__);			\
		(res) = (res) << 24;					\
		break;							\
	    case 1:							\
		(res) = READ(img, (uint32_t *) bits__);			\
		(res) = FbLeftStipBits((res),1) ? 0xff000000 : 0x00000000; \
		break;							\
	    default:							\
		return;							\
	    }								\
	    /* manage missing src alpha */				\
	    if (!PIXMAN_FORMAT_A((img)->bits.format))			\
		(res) |= 0xff000000;					\
	}								\
									\
	/* If necessary, convert RGB <--> BGR. */			\
	if (PIXMAN_FORMAT_TYPE (format__) != PIXMAN_FORMAT_TYPE(fmt))	\
	{								\
	    (res) = ((((res) & 0xff000000) >>  0) |			\
		     (((res) & 0x00ff0000) >> 16) |			\
		     (((res) & 0x0000ff00) >>  0) |			\
		     (((res) & 0x000000ff) << 16));			\
	}								\
    }									\
    while (0)
a552 12
#define fbComposeGetStart(pict,x,y,type,out_stride,line,mul) do {	\
	uint32_t	*__bits__;					\
	int		__stride__;					\
	int		__bpp__;					\
									\
	__bits__ = pict->bits.bits;					\
	__stride__ = pict->bits.rowstride;				\
	__bpp__ = PIXMAN_FORMAT_BPP(pict->bits.format);			\
	(out_stride) = __stride__ * (int) sizeof (uint32_t) / (int) sizeof (type);	\
	(line) = ((type *) __bits__) +					\
	    (out_stride) * (y) + (mul) * (x);				\
    } while (0)
a554 4
#define PIXMAN_FORMAT_16BPC(f)	(PIXMAN_FORMAT_A(f) > 8 || \
				 PIXMAN_FORMAT_R(f) > 8 || \
				 PIXMAN_FORMAT_G(f) > 8 || \
				 PIXMAN_FORMAT_B(f) > 8)
d556 1
a556 1
 * Edges
d559 5
a563 3
#define MAX_ALPHA(n)	((1 << (n)) - 1)
#define N_Y_FRAC(n)	((n) == 1 ? 1 : (1 << ((n)/2)) - 1)
#define N_X_FRAC(n)	((n) == 1 ? 1 : (1 << ((n)/2)) + 1)
d565 3
a567 2
#define STEP_Y_SMALL(n)	(pixman_fixed_1 / N_Y_FRAC(n))
#define STEP_Y_BIG(n)	(pixman_fixed_1 - (N_Y_FRAC(n) - 1) * STEP_Y_SMALL(n))
d569 9
a577 2
#define Y_FRAC_FIRST(n)	(STEP_Y_SMALL(n) / 2)
#define Y_FRAC_LAST(n)	(Y_FRAC_FIRST(n) + (N_Y_FRAC(n) - 1) * STEP_Y_SMALL(n))
d579 3
a581 2
#define STEP_X_SMALL(n)	(pixman_fixed_1 / N_X_FRAC(n))
#define STEP_X_BIG(n)	(pixman_fixed_1 - (N_X_FRAC(n) - 1) * STEP_X_SMALL(n))
d583 2
a584 2
#define X_FRAC_FIRST(n)	(STEP_X_SMALL(n) / 2)
#define X_FRAC_LAST(n)	(X_FRAC_FIRST(n) + (N_X_FRAC(n) - 1) * STEP_X_SMALL(n))
d586 2
a587 1
#define RenderSamplesX(x,n)	((n) == 1 ? 0 : (pixman_fixed_frac (x) + X_FRAC_FIRST(n)) / STEP_X_SMALL(n))
d589 2
a590 12
/*
 * Step across a small sample grid gap
 */
#define RenderEdgeStepSmall(edge) { \
    edge->x += edge->stepx_small;   \
    edge->e += edge->dx_small;	    \
    if (edge->e > 0)		    \
    {				    \
	edge->e -= edge->dy;	    \
	edge->x += edge->signdx;    \
    }				    \
}
d592 16
a607 12
/*
 * Step across a large sample grid gap
 */
#define RenderEdgeStepBig(edge) {   \
    edge->x += edge->stepx_big;	    \
    edge->e += edge->dx_big;	    \
    if (edge->e > 0)		    \
    {				    \
	edge->e -= edge->dy;	    \
	edge->x += edge->signdx;    \
    }				    \
}
d610 26
a635 5
pixman_rasterize_edges_accessors (pixman_image_t *image,
				  pixman_edge_t	*l,
				  pixman_edge_t	*r,
				  pixman_fixed_t	t,
				  pixman_fixed_t	b);
d637 1
d639 2
a640 1
pixman_image_is_opaque(pixman_image_t *image);
d643 17
a659 1
pixman_image_can_get_solid (pixman_image_t *image);
d661 2
a662 22
pixman_bool_t
pixman_compute_composite_region32 (pixman_region32_t *	pRegion,
				   pixman_image_t *	pSrc,
				   pixman_image_t *	pMask,
				   pixman_image_t *	pDst,
				   int16_t		xSrc,
				   int16_t		ySrc,
				   int16_t		xMask,
				   int16_t		yMask,
				   int16_t		xDst,
				   int16_t		yDst,
				   uint16_t		width,
				   uint16_t		height);

/* GCC visibility */
#if defined(__GNUC__) && __GNUC__ >= 4
#define PIXMAN_EXPORT __attribute__ ((visibility("default")))
/* Sun Studio 8 visibility */
#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
#define PIXMAN_EXPORT __global
#else
#define PIXMAN_EXPORT
d665 11
a675 8
/* Region Helpers */
pixman_bool_t pixman_region32_copy_from_region16 (pixman_region32_t *dst,
						  pixman_region16_t *src);
pixman_bool_t pixman_region16_copy_from_region32 (pixman_region16_t *dst,
						  pixman_region32_t *src);
void pixman_region_internal_set_static_pointers (pixman_box16_t *empty_box,
						 pixman_region16_data_t *empty_data,
						 pixman_region16_data_t *broken_data);
d677 4
a680 1
#ifdef PIXMAN_TIMING
d682 4
a685 9
/* Timing */
static inline uint64_t
oil_profile_stamp_rdtsc (void)
{
    uint64_t ts;
    __asm__ __volatile__("rdtsc\n" : "=A" (ts));
    return ts;
}
#define OIL_STAMP oil_profile_stamp_rdtsc
d687 5
a691 1
typedef struct PixmanTimer PixmanTimer;
d693 3
a695 8
struct PixmanTimer
{
    int initialized;
    const char *name;
    uint64_t n_times;
    uint64_t total;
    PixmanTimer *next;
};
d697 2
a698 2
extern int timer_defined;
void pixman_timer_register (PixmanTimer *timer);
d700 1
a700 14
#define TIMER_BEGIN(tname)						\
    {									\
	static PixmanTimer	timer##tname;				\
	uint64_t		begin##tname;				\
									\
	if (!timer##tname.initialized)					\
	{								\
	    timer##tname.initialized = 1;				\
	    timer##tname.name = #tname;					\
	    pixman_timer_register (&timer##tname);			\
	}								\
									\
	timer##tname.n_times++;						\
	begin##tname = OIL_STAMP();
d702 10
a711 3
#define TIMER_END(tname)						\
        timer##tname.total += OIL_STAMP() - begin##tname;		\
    }
d713 10
a722 1
#endif /* PIXMAN_TIMING */
d724 1
a724 1
typedef struct pixman_implementation_t pixman_implementation_t;
d726 7
a732 49
typedef void (* pixman_combine_32_func_t) (pixman_implementation_t *	imp,
					   pixman_op_t			op,
					   uint32_t *			dest,
					   const uint32_t *		src,
					   const uint32_t *		mask,
					   int				width);

typedef void (* pixman_combine_64_func_t) (pixman_implementation_t *	imp,
					   pixman_op_t			op,
					   uint64_t *			dest,
					   const uint64_t *		src,
					   const uint64_t *		mask,
					   int				width);

typedef void (* pixman_composite_func_t)  (pixman_implementation_t *	imp,
					   pixman_op_t			op,
					   pixman_image_t *		src,
					   pixman_image_t *		mask,
					   pixman_image_t *		dest,
					   int32_t			src_x,
					   int32_t			src_y,
					   int32_t			mask_x,
					   int32_t			mask_y,
					   int32_t			dest_x,
					   int32_t			dest_y,
					   int32_t			width,
					   int32_t			height);
typedef pixman_bool_t (* pixman_blt_func_t) (pixman_implementation_t *	imp,
					     uint32_t *			src_bits,
					     uint32_t *			dst_bits,
					     int			src_stride,
					     int			dst_stride,
					     int			src_bpp,
					     int			dst_bpp,
					     int			src_x,
					     int			src_y,
					     int			dst_x,
					     int			dst_y,
					     int			width,
					     int			height);
typedef pixman_bool_t (* pixman_fill_func_t) (pixman_implementation_t *imp,
					      uint32_t *bits,
					      int stride,
					      int bpp,
					      int x,
					      int y,
					      int width,
					      int height,
					      uint32_t xor);
d734 7
a740 17
void
_pixman_walk_composite_region (pixman_implementation_t *imp,
			      pixman_op_t op,
			      pixman_image_t * pSrc,
			      pixman_image_t * pMask,
			      pixman_image_t * pDst,
			      int16_t xSrc,
			      int16_t ySrc,
			      int16_t xMask,
			      int16_t yMask,
			      int16_t xDst,
			      int16_t yDst,
			      uint16_t width,
			      uint16_t height,
			      pixman_bool_t srcRepeat,
			      pixman_bool_t maskRepeat,
			       pixman_composite_func_t compositeRect);
d742 1
a742 2
void _pixman_setup_combiner_functions_32 (pixman_implementation_t *imp);
void _pixman_setup_combiner_functions_64 (pixman_implementation_t *imp);
d744 2
a745 2
/* These "formats" both have depth 0, so they
 * will never clash with any real ones
a746 2
#define PIXMAN_null		PIXMAN_FORMAT(0,0,0,0,0,0)
#define PIXMAN_solid		PIXMAN_FORMAT(0,1,0,0,0,0)
d748 1
a748 3
#define NEED_COMPONENT_ALPHA		(1 << 0)
#define NEED_PIXBUF			(1 << 1)
#define NEED_SOLID_MASK		        (1 << 2)
d750 2
a751 1
typedef struct
d753 1
a753 7
    pixman_op_t			op;
    pixman_format_code_t	src_format;
    pixman_format_code_t	mask_format;
    pixman_format_code_t	dest_format;
    pixman_composite_func_t	func;
    uint32_t			flags;
} FastPathInfo;
d755 9
a763 1
struct pixman_implementation_t
d765 6
a770 2
    pixman_implementation_t *	toplevel;
    pixman_implementation_t *	delegate;
d772 1
a772 9
    pixman_composite_func_t	composite;
    pixman_blt_func_t		blt;
    pixman_fill_func_t		fill;
    
    pixman_combine_32_func_t	combine_32[PIXMAN_OP_LAST];
    pixman_combine_32_func_t	combine_32_ca[PIXMAN_OP_LAST];
    pixman_combine_64_func_t	combine_64[PIXMAN_OP_LAST];
    pixman_combine_64_func_t	combine_64_ca[PIXMAN_OP_LAST];
};
d774 1
a774 3
pixman_implementation_t *
_pixman_implementation_create (pixman_implementation_t *toplevel,
			       pixman_implementation_t *delegate);
d776 14
a789 42
void
_pixman_implementation_combine_32 (pixman_implementation_t *	imp,
				   pixman_op_t			op,
				   uint32_t *			dest,
				   const uint32_t *		src,
				   const uint32_t *		mask,
				   int				width);
void
_pixman_implementation_combine_64 (pixman_implementation_t *	imp,
				   pixman_op_t			op,
				   uint64_t *			dest,
				   const uint64_t *		src,
				   const uint64_t *		mask,
				   int				width);
void
_pixman_implementation_combine_32_ca (pixman_implementation_t *	imp,
				      pixman_op_t		op,
				      uint32_t *		dest,
				      const uint32_t *		src,
				      const uint32_t *		mask,
				      int			width);
void
_pixman_implementation_combine_64_ca (pixman_implementation_t *	imp,
				      pixman_op_t		op,
				      uint64_t *		dest,
				      const uint64_t *		src,
				      const uint64_t *		mask,
				      int			width);
void
_pixman_implementation_composite (pixman_implementation_t *	imp,
				  pixman_op_t			op,
				  pixman_image_t *		src,
				  pixman_image_t *		mask,
				  pixman_image_t *		dest,
				  int32_t			src_x,
				  int32_t			src_y,
				  int32_t			mask_x,
				  int32_t			mask_y,
				  int32_t			dest_x,
				  int32_t			dest_y,
				  int32_t			width,
				  int32_t			height);
d791 3
a793 50
pixman_bool_t
_pixman_implementation_blt (pixman_implementation_t *	imp,
			    uint32_t *			src_bits,
			    uint32_t *			dst_bits,
			    int				src_stride,
			    int				dst_stride,
			    int				src_bpp,
			    int				dst_bpp,
			    int				src_x,
			    int				src_y,
			    int				dst_x,
			    int				dst_y,
			    int				width,
			    int				height);
pixman_bool_t
_pixman_implementation_fill (pixman_implementation_t *   imp,
			     uint32_t *bits,
			     int stride,
			     int bpp,
			     int x,
			     int y,
			     int width,
			     int height,
			     uint32_t xor);
    
/* Specific implementations */
pixman_implementation_t *
_pixman_implementation_create_general (pixman_implementation_t *toplevel);
pixman_implementation_t *
_pixman_implementation_create_fast_path (pixman_implementation_t *toplevel);
#ifdef USE_MMX
pixman_implementation_t *
_pixman_implementation_create_mmx (pixman_implementation_t *toplevel);
#endif
#ifdef USE_SSE2
pixman_implementation_t *
_pixman_implementation_create_sse2 (pixman_implementation_t *toplevel);
#endif
#ifdef USE_ARM_SIMD
pixman_implementation_t *
_pixman_implementation_create_arm_simd (pixman_implementation_t *toplevel);
#endif
#ifdef USE_ARM_NEON
pixman_implementation_t *
_pixman_implementation_create_arm_neon (pixman_implementation_t *toplevel);
#endif
#ifdef USE_VMX
pixman_implementation_t *
_pixman_implementation_create_vmx (pixman_implementation_t *toplevel);
#endif
d795 1
a795 18
pixman_bool_t
_pixman_run_fast_path (const FastPathInfo *paths,
		       pixman_implementation_t *imp,
		       pixman_op_t op,
		       pixman_image_t *src,
		       pixman_image_t *mask,
		       pixman_image_t *dest,
		       int32_t src_x,
		       int32_t src_y,
		       int32_t mask_x,
		       int32_t mask_y,
		       int32_t dest_x,
		       int32_t dest_y,
		       int32_t width,
		       int32_t height);
    
pixman_implementation_t *
_pixman_choose_implementation (void);
@


1.3
log
@pixman 0.12.0. Tested on a full ports build by naddy@@.
@
text
@d10 1
d71 10
a80 1
#define inline __inline
d156 1
a156 3
typedef FASTCALL void (*CombineMaskU32) (uint32_t *src, const uint32_t *mask, int width);
typedef FASTCALL void (*CombineFuncU32) (uint32_t *dest, const uint32_t *src, int width);
typedef FASTCALL void (*CombineFuncC32) (uint32_t *dest, uint32_t *src, uint32_t *mask, int width);
d164 1
a164 3
typedef FASTCALL void (*CombineMaskU64) (uint64_t *src, const uint64_t *mask, int width);
typedef FASTCALL void (*CombineFuncU64) (uint64_t *dest, const uint64_t *src, int width);
typedef FASTCALL void (*CombineFuncC64) (uint64_t *dest, uint64_t *src, uint64_t *mask, int width);
a186 15
typedef struct _FbComposeFunctions32 {
    CombineFuncU32 *combineU;
    CombineFuncC32 *combineC;
    CombineMaskU32 combineMaskU;
} FbComposeFunctions32;

typedef struct _FbComposeFunctions64 {
    CombineFuncU64 *combineU;
    CombineFuncC64 *combineC;
    CombineMaskU64 combineMaskU;
} FbComposeFunctions64;

extern FbComposeFunctions32 pixman_composeFunctions;
extern FbComposeFunctions64 pixman_composeFunctions64;

d211 1
a211 1
void pixmanFetchSourcePict(source_image_t *, int x, int y, int width,
d213 2
a214 3
void pixmanFetchSourcePict64(source_image_t *, int x, int y, int width,
                             uint64_t *buffer, uint64_t *mask, uint32_t maskBits);

a216 2
void fbStoreExternalAlpha(bits_image_t *, int x, int y, int width,
                          uint32_t *buffer);
a228 16
void fbFetchTransformed64(bits_image_t *, int x, int y, int width,
                          uint64_t *buffer, uint64_t *mask, uint32_t maskBits);
void fbStoreExternalAlpha64(bits_image_t *, int x, int y, int width,
                            uint64_t *buffer);
void fbFetchExternalAlpha64(bits_image_t *, int x, int y, int width,
                            uint64_t *buffer, uint64_t *mask, uint32_t maskBits);

void fbFetchTransformed64_accessors(bits_image_t *, int x, int y, int width,
                                    uint64_t *buffer, uint64_t *mask,
                                    uint32_t maskBits);
void fbStoreExternalAlpha64_accessors(bits_image_t *, int x, int y, int width,
                                      uint64_t *buffer);
void fbFetchExternalAlpha64_accessors(bits_image_t *, int x, int y, int width,
                                      uint64_t *buffer, uint64_t *mask,
                                      uint32_t maskBits);

d246 1
a246 1
    SOURCE_IMAGE_CLASS_VERTICAL
d249 41
d295 7
d320 4
d391 3
d401 1
d409 33
d637 1
a637 1
#define MEMCPY_WRAPPED(img, dst, src, size)					\
d639 1
a639 1
#define MEMSET_WRAPPED(img, dst, val, size)					\
d664 1
a664 1
		(res) = Fetch24(img, (uint8_t *) bits__);			\
d855 225
@


1.2
log
@Update to pixman 0.10, with one small fix to the sse2 test in configure.ac.
@
text
@d146 19
a164 9
typedef FASTCALL void (*CombineMaskU) (uint32_t *src, const uint32_t *mask, int width);
typedef FASTCALL void (*CombineFuncU) (uint32_t *dest, const uint32_t *src, int width);
typedef FASTCALL void (*CombineFuncC) (uint32_t *dest, uint32_t *src, uint32_t *mask, int width);
typedef FASTCALL void (*fetchProc)(bits_image_t *pict, int x, int y, int width,
                                   uint32_t *buffer);
typedef FASTCALL uint32_t (*fetchPixelProc)(bits_image_t *pict, int offset, int line);
typedef FASTCALL void (*storeProc)(pixman_image_t *, uint32_t *bits,
                                   const uint32_t *values, int x, int width,
                                   const pixman_indexed_t *);
d181 11
a191 5
typedef struct _FbComposeFunctions {
    CombineFuncU *combineU;
    CombineFuncC *combineC;
    CombineMaskU combineMaskU;
} FbComposeFunctions;
d193 2
a194 1
extern FbComposeFunctions pixman_composeFunctions;
d197 22
a218 10
					      uint32_t *scanline_buffer);
void pixman_composite_rect_general (const FbComposeData *data,
				    uint32_t *scanline_buffer);

fetchProc pixman_fetchProcForPicture (bits_image_t *);
fetchPixelProc pixman_fetchPixelProcForPicture (bits_image_t *);
storeProc pixman_storeProcForPicture (bits_image_t *);
fetchProc pixman_fetchProcForPicture_accessors (bits_image_t *);
fetchPixelProc pixman_fetchPixelProcForPicture_accessors (bits_image_t *);
storeProc pixman_storeProcForPicture_accessors (bits_image_t *);
d222 2
d241 16
d286 3
a288 3
    pixman_region16_t		full_region;
    pixman_region16_t		clip_region;
    pixman_region16_t	       *src_clip;
a381 4
extern CombineFuncU pixman_fbCombineFuncU[];
extern CombineFuncC pixman_fbCombineFuncC[];
FASTCALL void pixman_fbCombineMaskU (uint32_t *src, const uint32_t *mask, int width);

a442 5
#define Alpha(x) ((x) >> 24)
#define Red(x) (((x) >> 16) & 0xff)
#define Green(x) (((x) >> 8) & 0xff)
#define Blue(x) ((x) & 0xff)

a485 5
#define FbGen(x,y,i,ax,ay,t,u,v) ((t) = (FbIntMult(FbGet8(y,i),ay,(u)) + \
					 FbIntMult(FbGet8(x,i),ax,(v))), \
				  (uint32_t) ((uint8_t) ((t) |		\
							 (0 - ((t) >> 8)))) << (i))

a488 177

/*
  The methods below use some tricks to be able to do two color
  components at the same time.
*/

/*
  x_c = (x_c * a) / 255
*/
#define FbByteMul(x, a) do {					    \
        uint32_t t = ((x & 0xff00ff) * a) + 0x800080;               \
        t = (t + ((t >> 8) & 0xff00ff)) >> 8;			    \
        t &= 0xff00ff;						    \
								    \
        x = (((x >> 8) & 0xff00ff) * a) + 0x800080;		    \
        x = (x + ((x >> 8) & 0xff00ff));			    \
        x &= 0xff00ff00;					    \
        x += t;							    \
    } while (0)

/*
  x_c = (x_c * a) / 255 + y
*/
#define FbByteMulAdd(x, a, y) do {				    \
        uint32_t t = ((x & 0xff00ff) * a) + 0x800080;               \
        t = (t + ((t >> 8) & 0xff00ff)) >> 8;			    \
        t &= 0xff00ff;						    \
        t += y & 0xff00ff;					    \
        t |= 0x1000100 - ((t >> 8) & 0xff00ff);			    \
        t &= 0xff00ff;						    \
								    \
        x = (((x >> 8) & 0xff00ff) * a) + 0x800080;                 \
        x = (x + ((x >> 8) & 0xff00ff)) >> 8;                       \
        x &= 0xff00ff;                                              \
        x += (y >> 8) & 0xff00ff;                                   \
        x |= 0x1000100 - ((x >> 8) & 0xff00ff);                     \
        x &= 0xff00ff;                                              \
        x <<= 8;                                                    \
        x += t;                                                     \
    } while (0)

/*
  x_c = (x_c * a + y_c * b) / 255
*/
#define FbByteAddMul(x, a, y, b) do {                                   \
        uint32_t t;							\
        uint32_t r = (x >> 24) * a + (y >> 24) * b + 0x80;		\
        r += (r >> 8);                                                  \
        r >>= 8;                                                        \
									\
        t = (x & 0xff00) * a + (y & 0xff00) * b;                        \
        t += (t >> 8) + 0x8000;                                         \
        t >>= 16;                                                       \
									\
        t |= r << 16;                                                   \
        t |= 0x1000100 - ((t >> 8) & 0xff00ff);                         \
        t &= 0xff00ff;                                                  \
        t <<= 8;                                                        \
									\
        r = ((x >> 16) & 0xff) * a + ((y >> 16) & 0xff) * b + 0x80;     \
        r += (r >> 8);                                                  \
        r >>= 8;                                                        \
									\
        x = (x & 0xff) * a + (y & 0xff) * b + 0x80;                     \
        x += (x >> 8);                                                  \
        x >>= 8;                                                        \
        x |= r << 16;                                                   \
        x |= 0x1000100 - ((x >> 8) & 0xff00ff);                         \
        x &= 0xff00ff;                                                  \
        x |= t;                                                         \
    } while (0)

/*
  x_c = (x_c * a + y_c *b) / 256
*/
#define FbByteAddMul_256(x, a, y, b) do {                               \
        uint32_t t = (x & 0xff00ff) * a + (y & 0xff00ff) * b;		\
        t >>= 8;                                                        \
        t &= 0xff00ff;                                                  \
									\
        x = ((x >> 8) & 0xff00ff) * a + ((y >> 8) & 0xff00ff) * b;      \
        x &= 0xff00ff00;                                                \
        x += t;                                                         \
    } while (0)

/*
  x_c = (x_c * a_c) / 255
*/
#define FbByteMulC(x, a) do {				  \
        uint32_t t;                                       \
        uint32_t r = (x & 0xff) * (a & 0xff);             \
        r |= (x & 0xff0000) * ((a >> 16) & 0xff);	  \
	r += 0x800080;					  \
        r = (r + ((r >> 8) & 0xff00ff)) >> 8;		  \
        r &= 0xff00ff;					  \
							  \
        x >>= 8;					  \
        t = (x & 0xff) * ((a >> 8) & 0xff);		  \
        t |= (x & 0xff0000) * (a >> 24);		  \
        t += 0x800080;					  \
        t = t + ((t >> 8) & 0xff00ff);			  \
        x = r | (t & 0xff00ff00);			  \
							  \
    } while (0)

/*
  x_c = (x_c * a) / 255 + y
*/
#define FbByteMulAddC(x, a, y) do {				      \
        uint32_t t;                                                   \
        uint32_t r = (x & 0xff) * (a & 0xff);                         \
        r |= (x & 0xff0000) * ((a >> 16) & 0xff);		      \
	r += 0x800080;						      \
	r = (r + ((r >> 8) & 0xff00ff)) >> 8;			      \
        r &= 0xff00ff;						      \
        r += y & 0xff00ff;					      \
        r |= 0x1000100 - ((r >> 8) & 0xff00ff);			      \
        r &= 0xff00ff;						      \
								      \
        x >>= 8;                                                       \
        t = (x & 0xff) * ((a >> 8) & 0xff);                            \
        t |= (x & 0xff0000) * (a >> 24);                               \
	t += 0x800080;                                                 \
        t = (t + ((t >> 8) & 0xff00ff)) >> 8;			       \
        t &= 0xff00ff;                                                 \
        t += (y >> 8) & 0xff00ff;                                      \
        t |= 0x1000100 - ((t >> 8) & 0xff00ff);                        \
        t &= 0xff00ff;                                                 \
        x = r | (t << 8);                                              \
    } while (0)

/*
  x_c = (x_c * a_c + y_c * b) / 255
*/
#define FbByteAddMulC(x, a, y, b) do {                                  \
        uint32_t t;							\
        uint32_t r = (x >> 24) * (a >> 24) + (y >> 24) * b;		\
        r += (r >> 8) + 0x80;                                           \
        r >>= 8;                                                        \
									\
        t = (x & 0xff00) * ((a >> 8) & 0xff) + (y & 0xff00) * b;        \
        t += (t >> 8) + 0x8000;                                         \
        t >>= 16;                                                       \
									\
        t |= r << 16;                                                   \
        t |= 0x1000100 - ((t >> 8) & 0xff00ff);                         \
        t &= 0xff00ff;                                                  \
        t <<= 8;                                                        \
									\
        r = ((x >> 16) & 0xff) * ((a >> 16) & 0xff) + ((y >> 16) & 0xff) * b + 0x80; \
        r += (r >> 8);                                                  \
        r >>= 8;                                                        \
									\
        x = (x & 0xff) * (a & 0xff) + (y & 0xff) * b + 0x80;            \
        x += (x >> 8);                                                  \
        x >>= 8;                                                        \
        x |= r << 16;                                                   \
        x |= 0x1000100 - ((x >> 8) & 0xff00ff);                         \
        x &= 0xff00ff;                                                  \
        x |= t;                                                         \
    } while (0)

/*
  x_c = min(x_c + y_c, 255)
*/
#define FbByteAdd(x, y) do {                                            \
        uint32_t t;							\
        uint32_t r = (x & 0xff00ff) + (y & 0xff00ff);			\
        r |= 0x1000100 - ((r >> 8) & 0xff00ff);                         \
        r &= 0xff00ff;                                                  \
									\
        t = ((x >> 8) & 0xff00ff) + ((y >> 8) & 0xff00ff);              \
        t |= 0x1000100 - ((t >> 8) & 0xff00ff);                         \
        r |= (t & 0xff00ff) << 8;                                       \
        x = r;                                                          \
    } while (0)

d490 1
d545 2
d572 2
d650 4
d709 38
@


1.1
log
@Initial revision
@
text
@d30 1
d41 31
d78 1
a78 1
    
d82 2
d149 6
d184 26
d266 1
a266 1
    
d308 1
a308 1
}; 
d334 5
d381 8
a388 8
#define Fetch24(a)  ((unsigned long) (a) & 1 ?			      \
		     ((READ(a) << 16) | READ((uint16_t *) ((a)+1))) : \
		     ((READ((uint16_t *) (a)) << 8) | READ((a)+2)))
#define Store24(a,v) ((unsigned long) (a) & 1 ?		\
		      (WRITE(a, (uint8_t) ((v) >> 16)),		      \
		       WRITE((uint16_t *) ((a)+1), (uint16_t) (v))) :  \
		      (WRITE((uint16_t *) (a), (uint16_t) ((v) >> 8)), \
		       WRITE((a)+2, (uint8_t) (v))))
d390 8
a397 8
#define Fetch24(a)  ((unsigned long) (a) & 1 ?			     \
		     (READ(a) | (READ((uint16_t *) ((a)+1)) << 8)) : \
		     (READ((uint16_t *) (a)) | (READ((a)+2) << 16)))
#define Store24(a,v) ((unsigned long) (a) & 1 ? \
		      (WRITE(a, (uint8_t) (v)),				\
		       WRITE((uint16_t *) ((a)+1), (uint16_t) ((v) >> 8))) : \
		      (WRITE((uint16_t *) (a), (uint16_t) (v)),		\
		       WRITE((a)+2, (uint8_t) ((v) >> 16))))
d640 2
d688 4
a691 4
#define READ(ptr)							\
    (image->common.read_func ((ptr), sizeof(*(ptr))))
#define WRITE(ptr,val)							\
    (image->common.write_func ((ptr), (val), sizeof (*(ptr))))
d693 1
a693 1
#define MEMCPY_WRAPPED(dst, src, size)					\
d698 1
a698 1
	    WRITE(_dst +_i, READ(_src + _i));				\
d701 2
a702 2
	
#define MEMSET_WRAPPED(dst, val, size)					\
d706 2
a707 2
	for(_i = 0; _i < (size_t) size; _i++) {                          \
	    WRITE(_dst +_i, (val));					\
a710 4
/* FIXME */
#define fbPrepareAccess(x)
#define fbFinishAccess(x)

d713 3
a715 3
#define READ(ptr)		(*(ptr))
#define WRITE(ptr, val)		(*(ptr) = (val))
#define MEMCPY_WRAPPED(dst, src, size)					\
d717 1
a717 1
#define MEMSET_WRAPPED(dst, val, size)					\
d719 1
a719 2
#define fbPrepareAccess(x)
#define fbFinishAccess(x)
d739 1
a739 1
		(res) = READ((uint32_t *)bits__);			\
d742 1
a742 1
		(res) = Fetch24 ((uint8_t *) bits__);			\
d745 1
a745 1
		(res) = READ((uint16_t *) bits__);			\
d749 1
a749 1
		(res) = READ((uint8_t *) bits__);			\
d753 1
a753 1
		(res) = READ((uint32_t *) bits__);			\
d783 1
a783 1
	(out_stride) = __stride__ * sizeof (uint32_t) / sizeof (type);	\
d795 1
a795 1
#define N_X_FRAC(n)	((1 << ((n)/2)) + 1)
d845 2
d885 1
a885 1
	
d890 1
@


1.1.1.1
log
@import pixman 0.9.5
@
text
@@


1.1.1.2
log
@pixman 0.9.6
@
text
@a39 22
#ifndef INT16_MIN
# define INT16_MIN              (-32767-1)
# define INT16_MAX              (32767)
#endif

#ifndef INT32_MIN
# define INT32_MIN              (-2147483647-1)
# define INT32_MAX              (2147483647)
#endif

#ifndef UINT32_MIN
# define UINT32_MIN             (0)
# define UINT32_MAX             (4294967295U)
#endif

#ifndef M_PI
# define M_PI			3.14159265358979323846
#endif

#ifdef _MSC_VER
#define inline __inline
#endif
a49 2
pixman_bool_t pixman_multiply_overflows_int (unsigned int a, unsigned int b);
pixman_bool_t pixman_addition_overflows_int (unsigned int a, unsigned int b);
a776 2
#ifdef PIXMAN_TIMING

a819 1
#endif /* PIXMAN_TIMING */
@

