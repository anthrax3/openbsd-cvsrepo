head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.16
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.14
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.12
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.10
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.8
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.6
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.2
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2013.12.01.20.34.20;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.02.28.20.36.12;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.11.14.13.42.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.05.20.14.27;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.09.23.19.11.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.08.19.06.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to pixman 0.32.4. Tested by naddy@@ and ajacoutot@@
@
text
@/*
 *
 * Copyright Â© 2000 Keith Packard, member of The XFree86 Project, Inc.
 *             2005 Lars Knoll & Zack Rusin, Trolltech
 *             2008 Aaron Plattner, NVIDIA Corporation
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <math.h>

#include "pixman-accessor.h"
#include "pixman-private.h"

#define CONVERT_RGB24_TO_Y15(s)						\
    (((((s) >> 16) & 0xff) * 153 +					\
      (((s) >>  8) & 0xff) * 301 +					\
      (((s)      ) & 0xff) * 58) >> 2)

#define CONVERT_RGB24_TO_RGB15(s)                                       \
    ((((s) >> 3) & 0x001f) |                                            \
     (((s) >> 6) & 0x03e0) |                                            \
     (((s) >> 9) & 0x7c00))

/* Fetch macros */

#ifdef WORDS_BIGENDIAN
#define FETCH_1(img,l,o)						\
    (((READ ((img), ((uint32_t *)(l)) + ((o) >> 5))) >> (0x1f - ((o) & 0x1f))) & 0x1)
#else
#define FETCH_1(img,l,o)						\
    ((((READ ((img), ((uint32_t *)(l)) + ((o) >> 5))) >> ((o) & 0x1f))) & 0x1)
#endif

#define FETCH_8(img,l,o)    (READ (img, (((uint8_t *)(l)) + ((o) >> 3))))

#ifdef WORDS_BIGENDIAN
#define FETCH_4(img,l,o)						\
    (((4 * (o)) & 4) ? (FETCH_8 (img,l, 4 * (o)) & 0xf) : (FETCH_8 (img,l,(4 * (o))) >> 4))
#else
#define FETCH_4(img,l,o)						\
    (((4 * (o)) & 4) ? (FETCH_8 (img, l, 4 * (o)) >> 4) : (FETCH_8 (img, l, (4 * (o))) & 0xf))
#endif

#ifdef WORDS_BIGENDIAN
#define FETCH_24(img,l,o)                                              \
    ((READ (img, (((uint8_t *)(l)) + ((o) * 3) + 0)) << 16)    |       \
     (READ (img, (((uint8_t *)(l)) + ((o) * 3) + 1)) << 8)     |       \
     (READ (img, (((uint8_t *)(l)) + ((o) * 3) + 2)) << 0))
#else
#define FETCH_24(img,l,o)						\
    ((READ (img, (((uint8_t *)(l)) + ((o) * 3) + 0)) << 0)	|	\
     (READ (img, (((uint8_t *)(l)) + ((o) * 3) + 1)) << 8)	|	\
     (READ (img, (((uint8_t *)(l)) + ((o) * 3) + 2)) << 16))
#endif

/* Store macros */

#ifdef WORDS_BIGENDIAN
#define STORE_1(img,l,o,v)						\
    do									\
    {									\
	uint32_t  *__d = ((uint32_t *)(l)) + ((o) >> 5);		\
	uint32_t __m, __v;						\
									\
	__m = 1 << (0x1f - ((o) & 0x1f));				\
	__v = (v)? __m : 0;						\
									\
	WRITE((img), __d, (READ((img), __d) & ~__m) | __v);		\
    }									\
    while (0)
#else
#define STORE_1(img,l,o,v)						\
    do									\
    {									\
	uint32_t  *__d = ((uint32_t *)(l)) + ((o) >> 5);		\
	uint32_t __m, __v;						\
									\
	__m = 1 << ((o) & 0x1f);					\
	__v = (v)? __m : 0;						\
									\
	WRITE((img), __d, (READ((img), __d) & ~__m) | __v);		\
    }									\
    while (0)
#endif

#define STORE_8(img,l,o,v)  (WRITE (img, (uint8_t *)(l) + ((o) >> 3), (v)))

#ifdef WORDS_BIGENDIAN
#define STORE_4(img,l,o,v)						\
    do									\
    {									\
	int bo = 4 * (o);						\
	int v4 = (v) & 0x0f;						\
									\
	STORE_8 (img, l, bo, (						\
		     bo & 4 ?						\
		     (FETCH_8 (img, l, bo) & 0xf0) | (v4) :		\
		     (FETCH_8 (img, l, bo) & 0x0f) | (v4 << 4)));	\
    } while (0)
#else
#define STORE_4(img,l,o,v)						\
    do									\
    {									\
	int bo = 4 * (o);						\
	int v4 = (v) & 0x0f;						\
									\
	STORE_8 (img, l, bo, (						\
		     bo & 4 ?						\
		     (FETCH_8 (img, l, bo) & 0x0f) | (v4 << 4) :	\
		     (FETCH_8 (img, l, bo) & 0xf0) | (v4)));		\
    } while (0)
#endif

#ifdef WORDS_BIGENDIAN
#define STORE_24(img,l,o,v)                                            \
    do                                                                 \
    {                                                                  \
	uint8_t *__tmp = (l) + 3 * (o);				       \
        							       \
	WRITE ((img), __tmp++, ((v) & 0x00ff0000) >> 16);	       \
	WRITE ((img), __tmp++, ((v) & 0x0000ff00) >>  8);	       \
	WRITE ((img), __tmp++, ((v) & 0x000000ff) >>  0);	       \
    }                                                                  \
    while (0)
#else
#define STORE_24(img,l,o,v)                                            \
    do                                                                 \
    {                                                                  \
	uint8_t *__tmp = (l) + 3 * (o);				       \
        							       \
	WRITE ((img), __tmp++, ((v) & 0x000000ff) >>  0);	       \
	WRITE ((img), __tmp++, ((v) & 0x0000ff00) >>  8);	       \
	WRITE ((img), __tmp++, ((v) & 0x00ff0000) >> 16);	       \
    }								       \
    while (0)
#endif

/*
 * YV12 setup and access macros
 */

#define YV12_SETUP(image)                                               \
    bits_image_t *__bits_image = (bits_image_t *)image;                 \
    uint32_t *bits = __bits_image->bits;                                \
    int stride = __bits_image->rowstride;                               \
    int offset0 = stride < 0 ?                                          \
    ((-stride) >> 1) * ((__bits_image->height - 1) >> 1) - stride :	\
    stride * __bits_image->height;					\
    int offset1 = stride < 0 ?                                          \
    offset0 + ((-stride) >> 1) * ((__bits_image->height) >> 1) :	\
	offset0 + (offset0 >> 2)

/* Note no trailing semicolon on the above macro; if it's there, then
 * the typical usage of YV12_SETUP(image); will have an extra trailing ;
 * that some compilers will interpret as a statement -- and then any further
 * variable declarations will cause an error.
 */

#define YV12_Y(line)                                                    \
    ((uint8_t *) ((bits) + (stride) * (line)))

#define YV12_U(line)                                                    \
    ((uint8_t *) ((bits) + offset1 +                                    \
                  ((stride) >> 1) * ((line) >> 1)))

#define YV12_V(line)                                                    \
    ((uint8_t *) ((bits) + offset0 +                                    \
                  ((stride) >> 1) * ((line) >> 1)))

/* Misc. helpers */

static force_inline void
get_shifts (pixman_format_code_t  format,
	    int			 *a,
	    int			 *r,
	    int                  *g,
	    int                  *b)
{
    switch (PIXMAN_FORMAT_TYPE (format))
    {
    case PIXMAN_TYPE_A:
	*b = 0;
	*g = 0;
	*r = 0;
	*a = 0;
	break;

    case PIXMAN_TYPE_ARGB:
    case PIXMAN_TYPE_ARGB_SRGB:
	*b = 0;
	*g = *b + PIXMAN_FORMAT_B (format);
	*r = *g + PIXMAN_FORMAT_G (format);
	*a = *r + PIXMAN_FORMAT_R (format);
	break;

    case PIXMAN_TYPE_ABGR:
	*r = 0;
	*g = *r + PIXMAN_FORMAT_R (format);
	*b = *g + PIXMAN_FORMAT_G (format);
	*a = *b + PIXMAN_FORMAT_B (format);
	break;

    case PIXMAN_TYPE_BGRA:
	/* With BGRA formats we start counting at the high end of the pixel */
	*b = PIXMAN_FORMAT_BPP (format) - PIXMAN_FORMAT_B (format);
	*g = *b - PIXMAN_FORMAT_B (format);
	*r = *g - PIXMAN_FORMAT_G (format);
	*a = *r - PIXMAN_FORMAT_R (format);
	break;

    case PIXMAN_TYPE_RGBA:
	/* With BGRA formats we start counting at the high end of the pixel */
	*r = PIXMAN_FORMAT_BPP (format) - PIXMAN_FORMAT_R (format);
	*g = *r - PIXMAN_FORMAT_R (format);
	*b = *g - PIXMAN_FORMAT_G (format);
	*a = *b - PIXMAN_FORMAT_B (format);
	break;

    default:
	assert (0);
	break;
    }
}

static force_inline uint32_t
convert_channel (uint32_t pixel, uint32_t def_value,
		 int n_from_bits, int from_shift,
		 int n_to_bits, int to_shift)
{
    uint32_t v;

    if (n_from_bits && n_to_bits)
	v  = unorm_to_unorm (pixel >> from_shift, n_from_bits, n_to_bits);
    else if (n_to_bits)
	v = def_value;
    else
	v = 0;

    return (v & ((1 << n_to_bits) - 1)) << to_shift;
}

static force_inline uint32_t
convert_pixel (pixman_format_code_t from, pixman_format_code_t to, uint32_t pixel)
{
    int a_from_shift, r_from_shift, g_from_shift, b_from_shift;
    int a_to_shift, r_to_shift, g_to_shift, b_to_shift;
    uint32_t a, r, g, b;

    get_shifts (from, &a_from_shift, &r_from_shift, &g_from_shift, &b_from_shift);
    get_shifts (to, &a_to_shift, &r_to_shift, &g_to_shift, &b_to_shift);

    a = convert_channel (pixel, ~0,
			 PIXMAN_FORMAT_A (from), a_from_shift,
			 PIXMAN_FORMAT_A (to), a_to_shift);

    r = convert_channel (pixel, 0,
			 PIXMAN_FORMAT_R (from), r_from_shift,
			 PIXMAN_FORMAT_R (to), r_to_shift);

    g = convert_channel (pixel, 0,
			 PIXMAN_FORMAT_G (from), g_from_shift,
			 PIXMAN_FORMAT_G (to), g_to_shift);

    b = convert_channel (pixel, 0,
			 PIXMAN_FORMAT_B (from), b_from_shift,
			 PIXMAN_FORMAT_B (to), b_to_shift);

    return a | r | g | b;
}

static force_inline uint32_t
convert_pixel_to_a8r8g8b8 (bits_image_t *image,
			   pixman_format_code_t format,
			   uint32_t pixel)
{
    if (PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_GRAY		||
	PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_COLOR)
    {
	return image->indexed->rgba[pixel];
    }
    else
    {
	return convert_pixel (format, PIXMAN_a8r8g8b8, pixel);
    }
}

static force_inline uint32_t
convert_pixel_from_a8r8g8b8 (pixman_image_t *image,
			     pixman_format_code_t format, uint32_t pixel)
{
    if (PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_GRAY)
    {
	pixel = CONVERT_RGB24_TO_Y15 (pixel);

	return image->bits.indexed->ent[pixel & 0x7fff];
    }
    else if (PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_COLOR)
    {
	pixel = convert_pixel (PIXMAN_a8r8g8b8, PIXMAN_x1r5g5b5, pixel);

	return image->bits.indexed->ent[pixel & 0x7fff];
    }
    else
    {
	return convert_pixel (PIXMAN_a8r8g8b8, format, pixel);
    }
}

static force_inline uint32_t
fetch_and_convert_pixel (bits_image_t *		image,
			 const uint8_t *	bits,
			 int			offset,
			 pixman_format_code_t	format)
{
    uint32_t pixel;

    switch (PIXMAN_FORMAT_BPP (format))
    {
    case 1:
	pixel = FETCH_1 (image, bits, offset);
	break;

    case 4:
	pixel = FETCH_4 (image, bits, offset);
	break;

    case 8:
	pixel = READ (image, bits + offset);
	break;

    case 16:
	pixel = READ (image, ((uint16_t *)bits + offset));
	break;

    case 24:
	pixel = FETCH_24 (image, bits, offset);
	break;

    case 32:
	pixel = READ (image, ((uint32_t *)bits + offset));
	break;

    default:
	pixel = 0xffff00ff; /* As ugly as possible to detect the bug */
	break;
    }

    return convert_pixel_to_a8r8g8b8 (image, format, pixel);
}

static force_inline void
convert_and_store_pixel (bits_image_t *		image,
			 uint8_t *		dest,
			 int                    offset,
			 pixman_format_code_t	format,
			 uint32_t		pixel)
{
    uint32_t converted = convert_pixel_from_a8r8g8b8 (
	(pixman_image_t *)image, format, pixel);

    switch (PIXMAN_FORMAT_BPP (format))
    {
    case 1:
	STORE_1 (image, dest, offset, converted & 0x01);
	break;

    case 4:
	STORE_4 (image, dest, offset, converted & 0xf);
	break;

    case 8:
	WRITE (image, (dest + offset), converted & 0xff);
	break;

    case 16:
	WRITE (image, ((uint16_t *)dest + offset), converted & 0xffff);
	break;

    case 24:
	STORE_24 (image, dest, offset, converted);
	break;

    case 32:
	WRITE (image, ((uint32_t *)dest + offset), converted);
	break;

    default:
	*dest = 0x0;
	break;
    }
}

#define MAKE_ACCESSORS(format)						\
    static void								\
    fetch_scanline_ ## format (bits_image_t *image,			\
			       int	       x,			\
			       int             y,			\
			       int             width,			\
			       uint32_t *      buffer,			\
			       const uint32_t *mask)			\
    {									\
	uint8_t *bits =							\
	    (uint8_t *)(image->bits + y * image->rowstride);		\
	int i;								\
									\
	for (i = 0; i < width; ++i)					\
	{								\
	    *buffer++ =							\
		fetch_and_convert_pixel (image, bits, x + i, PIXMAN_ ## format); \
	}								\
    }									\
									\
    static void								\
    store_scanline_ ## format (bits_image_t *  image,			\
			       int             x,			\
			       int             y,			\
			       int             width,			\
			       const uint32_t *values)			\
    {									\
	uint8_t *dest =							\
	    (uint8_t *)(image->bits + y * image->rowstride);		\
	int i;								\
									\
	for (i = 0; i < width; ++i)					\
	{								\
	    convert_and_store_pixel (					\
		image, dest, i + x, PIXMAN_ ## format, values[i]);	\
	}								\
    }									\
									\
    static uint32_t							\
    fetch_pixel_ ## format (bits_image_t *image,			\
			    int		offset,				\
			    int		line)				\
    {									\
	uint8_t *bits =							\
	    (uint8_t *)(image->bits + line * image->rowstride);		\
									\
	return fetch_and_convert_pixel (				\
	    image, bits, offset, PIXMAN_ ## format);			\
    }									\
									\
    static const void *const __dummy__ ## format

MAKE_ACCESSORS(a8r8g8b8);
MAKE_ACCESSORS(x8r8g8b8);
MAKE_ACCESSORS(a8b8g8r8);
MAKE_ACCESSORS(x8b8g8r8);
MAKE_ACCESSORS(x14r6g6b6);
MAKE_ACCESSORS(b8g8r8a8);
MAKE_ACCESSORS(b8g8r8x8);
MAKE_ACCESSORS(r8g8b8x8);
MAKE_ACCESSORS(r8g8b8a8);
MAKE_ACCESSORS(r8g8b8);
MAKE_ACCESSORS(b8g8r8);
MAKE_ACCESSORS(r5g6b5);
MAKE_ACCESSORS(b5g6r5);
MAKE_ACCESSORS(a1r5g5b5);
MAKE_ACCESSORS(x1r5g5b5);
MAKE_ACCESSORS(a1b5g5r5);
MAKE_ACCESSORS(x1b5g5r5);
MAKE_ACCESSORS(a4r4g4b4);
MAKE_ACCESSORS(x4r4g4b4);
MAKE_ACCESSORS(a4b4g4r4);
MAKE_ACCESSORS(x4b4g4r4);
MAKE_ACCESSORS(a8);
MAKE_ACCESSORS(c8);
MAKE_ACCESSORS(g8);
MAKE_ACCESSORS(r3g3b2);
MAKE_ACCESSORS(b2g3r3);
MAKE_ACCESSORS(a2r2g2b2);
MAKE_ACCESSORS(a2b2g2r2);
MAKE_ACCESSORS(x4a4);
MAKE_ACCESSORS(a4);
MAKE_ACCESSORS(g4);
MAKE_ACCESSORS(c4);
MAKE_ACCESSORS(r1g2b1);
MAKE_ACCESSORS(b1g2r1);
MAKE_ACCESSORS(a1r1g1b1);
MAKE_ACCESSORS(a1b1g1r1);
MAKE_ACCESSORS(a1);
MAKE_ACCESSORS(g1);

/********************************** Fetch ************************************/
/* Table mapping sRGB-encoded 8 bit numbers to linearly encoded
 * floating point numbers. We assume that single precision
 * floating point follows the IEEE 754 format.
 */
static const uint32_t to_linear_u[256] =
{
    0x00000000, 0x399f22b4, 0x3a1f22b4, 0x3a6eb40e, 0x3a9f22b4, 0x3ac6eb61,
    0x3aeeb40e, 0x3b0b3e5d, 0x3b1f22b4, 0x3b33070b, 0x3b46eb61, 0x3b5b518a,
    0x3b70f18a, 0x3b83e1c5, 0x3b8fe614, 0x3b9c87fb, 0x3ba9c9b5, 0x3bb7ad6d,
    0x3bc63547, 0x3bd5635f, 0x3be539bd, 0x3bf5ba70, 0x3c0373b5, 0x3c0c6152,
    0x3c15a703, 0x3c1f45bc, 0x3c293e68, 0x3c3391f4, 0x3c3e4149, 0x3c494d43,
    0x3c54b6c7, 0x3c607eb1, 0x3c6ca5df, 0x3c792d22, 0x3c830aa8, 0x3c89af9e,
    0x3c9085db, 0x3c978dc5, 0x3c9ec7c0, 0x3ca63432, 0x3cadd37d, 0x3cb5a601,
    0x3cbdac20, 0x3cc5e639, 0x3cce54ab, 0x3cd6f7d2, 0x3cdfd00e, 0x3ce8ddb9,
    0x3cf2212c, 0x3cfb9ac1, 0x3d02a569, 0x3d0798dc, 0x3d0ca7e4, 0x3d11d2ae,
    0x3d171963, 0x3d1c7c2e, 0x3d21fb3a, 0x3d2796af, 0x3d2d4ebb, 0x3d332380,
    0x3d39152b, 0x3d3f23e3, 0x3d454fd0, 0x3d4b991c, 0x3d51ffeb, 0x3d588466,
    0x3d5f26b7, 0x3d65e6fe, 0x3d6cc564, 0x3d73c210, 0x3d7add25, 0x3d810b65,
    0x3d84b793, 0x3d88732e, 0x3d8c3e48, 0x3d9018f4, 0x3d940343, 0x3d97fd48,
    0x3d9c0714, 0x3da020b9, 0x3da44a48, 0x3da883d6, 0x3daccd70, 0x3db12728,
    0x3db59110, 0x3dba0b38, 0x3dbe95b2, 0x3dc3308f, 0x3dc7dbe0, 0x3dcc97b4,
    0x3dd1641c, 0x3dd6412a, 0x3ddb2eec, 0x3de02d75, 0x3de53cd3, 0x3dea5d16,
    0x3def8e52, 0x3df4d091, 0x3dfa23e5, 0x3dff885e, 0x3e027f06, 0x3e05427f,
    0x3e080ea2, 0x3e0ae376, 0x3e0dc104, 0x3e10a752, 0x3e139669, 0x3e168e50,
    0x3e198f0e, 0x3e1c98ab, 0x3e1fab2e, 0x3e22c6a0, 0x3e25eb08, 0x3e29186a,
    0x3e2c4ed0, 0x3e2f8e42, 0x3e32d6c4, 0x3e362861, 0x3e39831e, 0x3e3ce702,
    0x3e405416, 0x3e43ca5e, 0x3e4749e4, 0x3e4ad2ae, 0x3e4e64c2, 0x3e520027,
    0x3e55a4e6, 0x3e595303, 0x3e5d0a8a, 0x3e60cb7c, 0x3e6495e0, 0x3e6869bf,
    0x3e6c4720, 0x3e702e08, 0x3e741e7f, 0x3e78188c, 0x3e7c1c34, 0x3e8014c0,
    0x3e822039, 0x3e84308b, 0x3e8645b8, 0x3e885fc3, 0x3e8a7eb0, 0x3e8ca281,
    0x3e8ecb3a, 0x3e90f8df, 0x3e932b72, 0x3e9562f6, 0x3e979f6f, 0x3e99e0e0,
    0x3e9c274e, 0x3e9e72b8, 0x3ea0c322, 0x3ea31892, 0x3ea57308, 0x3ea7d28a,
    0x3eaa3718, 0x3eaca0b7, 0x3eaf0f69, 0x3eb18332, 0x3eb3fc16, 0x3eb67a15,
    0x3eb8fd34, 0x3ebb8576, 0x3ebe12de, 0x3ec0a56e, 0x3ec33d2a, 0x3ec5da14,
    0x3ec87c30, 0x3ecb2380, 0x3ecdd008, 0x3ed081ca, 0x3ed338c9, 0x3ed5f508,
    0x3ed8b68a, 0x3edb7d52, 0x3ede4962, 0x3ee11abe, 0x3ee3f168, 0x3ee6cd64,
    0x3ee9aeb6, 0x3eec955d, 0x3eef815d, 0x3ef272ba, 0x3ef56976, 0x3ef86594,
    0x3efb6717, 0x3efe6e02, 0x3f00bd2b, 0x3f02460c, 0x3f03d1a5, 0x3f055ff8,
    0x3f06f105, 0x3f0884ce, 0x3f0a1b54, 0x3f0bb499, 0x3f0d509f, 0x3f0eef65,
    0x3f1090ef, 0x3f12353c, 0x3f13dc50, 0x3f15862a, 0x3f1732cc, 0x3f18e237,
    0x3f1a946d, 0x3f1c4970, 0x3f1e013f, 0x3f1fbbde, 0x3f21794c, 0x3f23398c,
    0x3f24fca0, 0x3f26c286, 0x3f288b42, 0x3f2a56d3, 0x3f2c253d, 0x3f2df680,
    0x3f2fca9d, 0x3f31a195, 0x3f337b6a, 0x3f35581e, 0x3f3737b1, 0x3f391a24,
    0x3f3aff7a, 0x3f3ce7b2, 0x3f3ed2d0, 0x3f40c0d2, 0x3f42b1bc, 0x3f44a58e,
    0x3f469c49, 0x3f4895ee, 0x3f4a9280, 0x3f4c91ff, 0x3f4e946c, 0x3f5099c8,
    0x3f52a216, 0x3f54ad55, 0x3f56bb88, 0x3f58ccae, 0x3f5ae0cb, 0x3f5cf7de,
    0x3f5f11ec, 0x3f612ef0, 0x3f634eef, 0x3f6571ea, 0x3f6797e1, 0x3f69c0d6,
    0x3f6beccb, 0x3f6e1bc0, 0x3f704db6, 0x3f7282af, 0x3f74baac, 0x3f76f5ae,
    0x3f7933b6, 0x3f7b74c6, 0x3f7db8de, 0x3f800000
};

static const float * const to_linear = (const float *)to_linear_u;

static uint8_t
to_srgb (float f)
{
    uint8_t low = 0;
    uint8_t high = 255;

    while (high - low > 1)
    {
	uint8_t mid = (low + high) / 2;

	if (to_linear[mid] > f)
	    high = mid;
	else
	    low = mid;
    }

    if (to_linear[high] - f < f - to_linear[low])
	return high;
    else
	return low;
}

static void
fetch_scanline_a8r8g8b8_sRGB_float (bits_image_t *  image,
				    int             x,
				    int             y,
				    int             width,
				    uint32_t *      b,
				    const uint32_t *mask)
{
    const uint32_t *bits = image->bits + y * image->rowstride;
    const uint32_t *pixel = bits + x;
    const uint32_t *end = pixel + width;
    argb_t *buffer = (argb_t *)b;

    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	argb_t *argb = buffer;

	argb->a = pixman_unorm_to_float ((p >> 24) & 0xff, 8);

	argb->r = to_linear [(p >> 16) & 0xff];
	argb->g = to_linear [(p >>  8) & 0xff];
	argb->b = to_linear [(p >>  0) & 0xff];

	buffer++;
    }
}

/* Expects a float buffer */
static void
fetch_scanline_a2r10g10b10_float (bits_image_t *  image,
				  int             x,
				  int             y,
				  int             width,
				  uint32_t *      b,
				  const uint32_t *mask)
{
    const uint32_t *bits = image->bits + y * image->rowstride;
    const uint32_t *pixel = bits + x;
    const uint32_t *end = pixel + width;
    argb_t *buffer = (argb_t *)b;

    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint64_t a = p >> 30;
	uint64_t r = (p >> 20) & 0x3ff;
	uint64_t g = (p >> 10) & 0x3ff;
	uint64_t b = p & 0x3ff;

	buffer->a = pixman_unorm_to_float (a, 2);
	buffer->r = pixman_unorm_to_float (r, 10);
	buffer->g = pixman_unorm_to_float (g, 10);
	buffer->b = pixman_unorm_to_float (b, 10);

	buffer++;
    }
}

/* Expects a float buffer */
static void
fetch_scanline_x2r10g10b10_float (bits_image_t   *image,
				  int             x,
				  int             y,
				  int             width,
				  uint32_t *      b,
				  const uint32_t *mask)
{
    const uint32_t *bits = image->bits + y * image->rowstride;
    const uint32_t *pixel = (uint32_t *)bits + x;
    const uint32_t *end = pixel + width;
    argb_t *buffer = (argb_t *)b;

    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint64_t r = (p >> 20) & 0x3ff;
	uint64_t g = (p >> 10) & 0x3ff;
	uint64_t b = p & 0x3ff;

	buffer->a = 1.0;
	buffer->r = pixman_unorm_to_float (r, 10);
	buffer->g = pixman_unorm_to_float (g, 10);
	buffer->b = pixman_unorm_to_float (b, 10);

	buffer++;
    }
}

/* Expects a float buffer */
static void
fetch_scanline_a2b10g10r10_float (bits_image_t   *image,
				  int             x,
				  int             y,
				  int             width,
				  uint32_t *      b,
				  const uint32_t *mask)
{
    const uint32_t *bits = image->bits + y * image->rowstride;
    const uint32_t *pixel = bits + x;
    const uint32_t *end = pixel + width;
    argb_t *buffer = (argb_t *)b;

    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint64_t a = p >> 30;
	uint64_t b = (p >> 20) & 0x3ff;
	uint64_t g = (p >> 10) & 0x3ff;
	uint64_t r = p & 0x3ff;

	buffer->a = pixman_unorm_to_float (a, 2);
	buffer->r = pixman_unorm_to_float (r, 10);
	buffer->g = pixman_unorm_to_float (g, 10);
	buffer->b = pixman_unorm_to_float (b, 10);

	buffer++;
    }
}

/* Expects a float buffer */
static void
fetch_scanline_x2b10g10r10_float (bits_image_t   *image,
				  int             x,
				  int             y,
				  int             width,
				  uint32_t *      b,
				  const uint32_t *mask)
{
    const uint32_t *bits = image->bits + y * image->rowstride;
    const uint32_t *pixel = (uint32_t *)bits + x;
    const uint32_t *end = pixel + width;
    argb_t *buffer = (argb_t *)b;

    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint64_t b = (p >> 20) & 0x3ff;
	uint64_t g = (p >> 10) & 0x3ff;
	uint64_t r = p & 0x3ff;

	buffer->a = 1.0;
	buffer->r = pixman_unorm_to_float (r, 10);
	buffer->g = pixman_unorm_to_float (g, 10);
	buffer->b = pixman_unorm_to_float (b, 10);

	buffer++;
    }
}

static void
fetch_scanline_yuy2 (bits_image_t   *image,
                     int             x,
                     int             line,
                     int             width,
                     uint32_t *      buffer,
                     const uint32_t *mask)
{
    const uint32_t *bits = image->bits + image->rowstride * line;
    int i;
    
    for (i = 0; i < width; i++)
    {
	int16_t y, u, v;
	int32_t r, g, b;
	
	y = ((uint8_t *) bits)[(x + i) << 1] - 16;
	u = ((uint8_t *) bits)[(((x + i) << 1) & - 4) + 1] - 128;
	v = ((uint8_t *) bits)[(((x + i) << 1) & - 4) + 3] - 128;
	
	/* R = 1.164(Y - 16) + 1.596(V - 128) */
	r = 0x012b27 * y + 0x019a2e * v;
	/* G = 1.164(Y - 16) - 0.813(V - 128) - 0.391(U - 128) */
	g = 0x012b27 * y - 0x00d0f2 * v - 0x00647e * u;
	/* B = 1.164(Y - 16) + 2.018(U - 128) */
	b = 0x012b27 * y + 0x0206a2 * u;
	
	*buffer++ = 0xff000000 |
	    (r >= 0 ? r < 0x1000000 ? r         & 0xff0000 : 0xff0000 : 0) |
	    (g >= 0 ? g < 0x1000000 ? (g >> 8)  & 0x00ff00 : 0x00ff00 : 0) |
	    (b >= 0 ? b < 0x1000000 ? (b >> 16) & 0x0000ff : 0x0000ff : 0);
    }
}

static void
fetch_scanline_yv12 (bits_image_t   *image,
                     int             x,
                     int             line,
                     int             width,
                     uint32_t *      buffer,
                     const uint32_t *mask)
{
    YV12_SETUP (image);
    uint8_t *y_line = YV12_Y (line);
    uint8_t *u_line = YV12_U (line);
    uint8_t *v_line = YV12_V (line);
    int i;
    
    for (i = 0; i < width; i++)
    {
	int16_t y, u, v;
	int32_t r, g, b;

	y = y_line[x + i] - 16;
	u = u_line[(x + i) >> 1] - 128;
	v = v_line[(x + i) >> 1] - 128;

	/* R = 1.164(Y - 16) + 1.596(V - 128) */
	r = 0x012b27 * y + 0x019a2e * v;
	/* G = 1.164(Y - 16) - 0.813(V - 128) - 0.391(U - 128) */
	g = 0x012b27 * y - 0x00d0f2 * v - 0x00647e * u;
	/* B = 1.164(Y - 16) + 2.018(U - 128) */
	b = 0x012b27 * y + 0x0206a2 * u;

	*buffer++ = 0xff000000 |
	    (r >= 0 ? r < 0x1000000 ? r         & 0xff0000 : 0xff0000 : 0) |
	    (g >= 0 ? g < 0x1000000 ? (g >> 8)  & 0x00ff00 : 0x00ff00 : 0) |
	    (b >= 0 ? b < 0x1000000 ? (b >> 16) & 0x0000ff : 0x0000ff : 0);
    }
}

/**************************** Pixel wise fetching *****************************/

static argb_t
fetch_pixel_x2r10g10b10_float (bits_image_t *image,
			       int	   offset,
			       int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t p = READ (image, bits + offset);
    uint64_t r = (p >> 20) & 0x3ff;
    uint64_t g = (p >> 10) & 0x3ff;
    uint64_t b = p & 0x3ff;
    argb_t argb;

    argb.a = 1.0;
    argb.r = pixman_unorm_to_float (r, 10);
    argb.g = pixman_unorm_to_float (g, 10);
    argb.b = pixman_unorm_to_float (b, 10);

    return argb;
}

static argb_t
fetch_pixel_a2r10g10b10_float (bits_image_t *image,
			       int	     offset,
			       int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t p = READ (image, bits + offset);
    uint64_t a = p >> 30;
    uint64_t r = (p >> 20) & 0x3ff;
    uint64_t g = (p >> 10) & 0x3ff;
    uint64_t b = p & 0x3ff;
    argb_t argb;

    argb.a = pixman_unorm_to_float (a, 2);
    argb.r = pixman_unorm_to_float (r, 10);
    argb.g = pixman_unorm_to_float (g, 10);
    argb.b = pixman_unorm_to_float (b, 10);

    return argb;
}

static argb_t
fetch_pixel_a2b10g10r10_float (bits_image_t *image,
			       int           offset,
			       int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t p = READ (image, bits + offset);
    uint64_t a = p >> 30;
    uint64_t b = (p >> 20) & 0x3ff;
    uint64_t g = (p >> 10) & 0x3ff;
    uint64_t r = p & 0x3ff;
    argb_t argb;

    argb.a = pixman_unorm_to_float (a, 2);
    argb.r = pixman_unorm_to_float (r, 10);
    argb.g = pixman_unorm_to_float (g, 10);
    argb.b = pixman_unorm_to_float (b, 10);

    return argb;
}

static argb_t
fetch_pixel_x2b10g10r10_float (bits_image_t *image,
			       int           offset,
			       int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t p = READ (image, bits + offset);
    uint64_t b = (p >> 20) & 0x3ff;
    uint64_t g = (p >> 10) & 0x3ff;
    uint64_t r = p & 0x3ff;
    argb_t argb;

    argb.a = 1.0;
    argb.r = pixman_unorm_to_float (r, 10);
    argb.g = pixman_unorm_to_float (g, 10);
    argb.b = pixman_unorm_to_float (b, 10);

    return argb;
}

static argb_t
fetch_pixel_a8r8g8b8_sRGB_float (bits_image_t *image,
				 int	       offset,
				 int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t p = READ (image, bits + offset);
    argb_t argb;

    argb.a = pixman_unorm_to_float ((p >> 24) & 0xff, 8);

    argb.r = to_linear [(p >> 16) & 0xff];
    argb.g = to_linear [(p >>  8) & 0xff];
    argb.b = to_linear [(p >>  0) & 0xff];

    return argb;
}

static uint32_t
fetch_pixel_yuy2 (bits_image_t *image,
		  int           offset,
		  int           line)
{
    const uint32_t *bits = image->bits + image->rowstride * line;
    
    int16_t y, u, v;
    int32_t r, g, b;
    
    y = ((uint8_t *) bits)[offset << 1] - 16;
    u = ((uint8_t *) bits)[((offset << 1) & - 4) + 1] - 128;
    v = ((uint8_t *) bits)[((offset << 1) & - 4) + 3] - 128;
    
    /* R = 1.164(Y - 16) + 1.596(V - 128) */
    r = 0x012b27 * y + 0x019a2e * v;
    
    /* G = 1.164(Y - 16) - 0.813(V - 128) - 0.391(U - 128) */
    g = 0x012b27 * y - 0x00d0f2 * v - 0x00647e * u;
    
    /* B = 1.164(Y - 16) + 2.018(U - 128) */
    b = 0x012b27 * y + 0x0206a2 * u;
    
    return 0xff000000 |
	(r >= 0 ? r < 0x1000000 ? r         & 0xff0000 : 0xff0000 : 0) |
	(g >= 0 ? g < 0x1000000 ? (g >> 8)  & 0x00ff00 : 0x00ff00 : 0) |
	(b >= 0 ? b < 0x1000000 ? (b >> 16) & 0x0000ff : 0x0000ff : 0);
}

static uint32_t
fetch_pixel_yv12 (bits_image_t *image,
		  int           offset,
		  int           line)
{
    YV12_SETUP (image);
    int16_t y = YV12_Y (line)[offset] - 16;
    int16_t u = YV12_U (line)[offset >> 1] - 128;
    int16_t v = YV12_V (line)[offset >> 1] - 128;
    int32_t r, g, b;
    
    /* R = 1.164(Y - 16) + 1.596(V - 128) */
    r = 0x012b27 * y + 0x019a2e * v;
    
    /* G = 1.164(Y - 16) - 0.813(V - 128) - 0.391(U - 128) */
    g = 0x012b27 * y - 0x00d0f2 * v - 0x00647e * u;
    
    /* B = 1.164(Y - 16) + 2.018(U - 128) */
    b = 0x012b27 * y + 0x0206a2 * u;
    
    return 0xff000000 |
	(r >= 0 ? r < 0x1000000 ? r         & 0xff0000 : 0xff0000 : 0) |
	(g >= 0 ? g < 0x1000000 ? (g >> 8)  & 0x00ff00 : 0x00ff00 : 0) |
	(b >= 0 ? b < 0x1000000 ? (b >> 16) & 0x0000ff : 0x0000ff : 0);
}

/*********************************** Store ************************************/

static void
store_scanline_a2r10g10b10_float (bits_image_t *  image,
				  int             x,
				  int             y,
				  int             width,
				  const uint32_t *v)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = bits + x;
    argb_t *values = (argb_t *)v;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint16_t a, r, g, b;

	a = pixman_float_to_unorm (values[i].a, 2);
	r = pixman_float_to_unorm (values[i].r, 10);
	g = pixman_float_to_unorm (values[i].g, 10);
	b = pixman_float_to_unorm (values[i].b, 10);

	WRITE (image, pixel++,
	       (a << 30) | (r << 20) | (g << 10) | b);
    }
}

static void
store_scanline_x2r10g10b10_float (bits_image_t *  image,
				  int             x,
				  int             y,
				  int             width,
				  const uint32_t *v)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = bits + x;
    argb_t *values = (argb_t *)v;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint16_t r, g, b;

	r = pixman_float_to_unorm (values[i].r, 10);
	g = pixman_float_to_unorm (values[i].g, 10);
	b = pixman_float_to_unorm (values[i].b, 10);

	WRITE (image, pixel++,
	       (r << 20) | (g << 10) | b);
    }
}

static void
store_scanline_a2b10g10r10_float (bits_image_t *  image,
				  int             x,
				  int             y,
				  int             width,
				  const uint32_t *v)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = bits + x;
    argb_t *values = (argb_t *)v;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint16_t a, r, g, b;

	a = pixman_float_to_unorm (values[i].a, 2);
	r = pixman_float_to_unorm (values[i].r, 10);
	g = pixman_float_to_unorm (values[i].g, 10);
	b = pixman_float_to_unorm (values[i].b, 10);

	WRITE (image, pixel++,
	       (a << 30) | (b << 20) | (g << 10) | r);
    }
}

static void
store_scanline_x2b10g10r10_float (bits_image_t *  image,
				  int             x,
				  int             y,
				  int             width,
				  const uint32_t *v)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = bits + x;
    argb_t *values = (argb_t *)v;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint16_t r, g, b;

	r = pixman_float_to_unorm (values[i].r, 10);
	g = pixman_float_to_unorm (values[i].g, 10);
	b = pixman_float_to_unorm (values[i].b, 10);

	WRITE (image, pixel++,
	       (b << 20) | (g << 10) | r);
    }
}

static void
store_scanline_a8r8g8b8_sRGB_float (bits_image_t *  image,
				    int             x,
				    int             y,
				    int             width,
				    const uint32_t *v)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = bits + x;
    argb_t *values = (argb_t *)v;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint8_t a, r, g, b;

	a = pixman_float_to_unorm (values[i].a, 8);
	r = to_srgb (values[i].r);
	g = to_srgb (values[i].g);
	b = to_srgb (values[i].b);

	WRITE (image, pixel++,
	       (a << 24) | (r << 16) | (g << 8) | b);
    }
}

/*
 * Contracts a floating point image to 32bpp and then stores it using a
 * regular 32-bit store proc. Despite the type, this function expects an
 * argb_t buffer.
 */
static void
store_scanline_generic_float (bits_image_t *  image,
			      int             x,
			      int             y,
			      int             width,
			      const uint32_t *values)
{
    uint32_t *argb8_pixels;

    assert (image->common.type == BITS);

    argb8_pixels = pixman_malloc_ab (width, sizeof(uint32_t));
    if (!argb8_pixels)
	return;

    /* Contract the scanline.  We could do this in place if values weren't
     * const.
     */
    pixman_contract_from_float (argb8_pixels, (argb_t *)values, width);

    image->store_scanline_32 (image, x, y, width, argb8_pixels);

    free (argb8_pixels);
}

static void
fetch_scanline_generic_float (bits_image_t *  image,
			      int	      x,
			      int	      y,
			      int	      width,
			      uint32_t *      buffer,
			      const uint32_t *mask)
{
    image->fetch_scanline_32 (image, x, y, width, buffer, NULL);

    pixman_expand_to_float ((argb_t *)buffer, buffer, image->format, width);
}

/* The 32_sRGB paths should be deleted after narrow processing
 * is no longer invoked for formats that are considered wide.
 * (Also see fetch_pixel_generic_lossy_32) */
static void
fetch_scanline_a8r8g8b8_32_sRGB (bits_image_t   *image,
                                 int             x,
                                 int             y,
                                 int             width,
                                 uint32_t       *buffer,
                                 const uint32_t *mask)
{
    const uint32_t *bits = image->bits + y * image->rowstride;
    const uint32_t *pixel = (uint32_t *)bits + x;
    const uint32_t *end = pixel + width;
    uint32_t tmp;
    
    while (pixel < end)
    {
	uint8_t a, r, g, b;

	tmp = READ (image, pixel++);

	a = (tmp >> 24) & 0xff;
	r = (tmp >> 16) & 0xff;
	g = (tmp >> 8) & 0xff;
	b = (tmp >> 0) & 0xff;

	r = to_linear[r] * 255.0f + 0.5f;
	g = to_linear[g] * 255.0f + 0.5f;
	b = to_linear[b] * 255.0f + 0.5f;

	*buffer++ = (a << 24) | (r << 16) | (g << 8) | (b << 0);
    }
}

static uint32_t
fetch_pixel_a8r8g8b8_32_sRGB (bits_image_t *image,
			      int           offset,
			      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t tmp = READ (image, bits + offset);
    uint8_t a, r, g, b;

    a = (tmp >> 24) & 0xff;
    r = (tmp >> 16) & 0xff;
    g = (tmp >> 8) & 0xff;
    b = (tmp >> 0) & 0xff;

    r = to_linear[r] * 255.0f + 0.5f;
    g = to_linear[g] * 255.0f + 0.5f;
    b = to_linear[b] * 255.0f + 0.5f;

    return (a << 24) | (r << 16) | (g << 8) | (b << 0);
}

static void
store_scanline_a8r8g8b8_32_sRGB (bits_image_t   *image,
                                 int             x,
                                 int             y,
                                 int             width,
                                 const uint32_t *v)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint64_t *values = (uint64_t *)v;
    uint32_t *pixel = bits + x;
    uint64_t tmp;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	uint8_t a, r, g, b;

	tmp = values[i];

	a = (tmp >> 24) & 0xff;
	r = (tmp >> 16) & 0xff;
	g = (tmp >> 8) & 0xff;
	b = (tmp >> 0) & 0xff;

	r = to_srgb (r * (1/255.0f));
	g = to_srgb (g * (1/255.0f));
	b = to_srgb (b * (1/255.0f));
	
	WRITE (image, pixel++, a | (r << 16) | (g << 8) | (b << 0));
    }
}

static argb_t
fetch_pixel_generic_float (bits_image_t *image,
			   int		 offset,
			   int           line)
{
    uint32_t pixel32 = image->fetch_pixel_32 (image, offset, line);
    argb_t f;

    pixman_expand_to_float (&f, &pixel32, image->format, 1);

    return f;
}

/*
 * XXX: The transformed fetch path only works at 32-bpp so far.  When all
 * paths have wide versions, this can be removed.
 *
 * WARNING: This function loses precision!
 */
static uint32_t
fetch_pixel_generic_lossy_32 (bits_image_t *image,
			      int           offset,
			      int           line)
{
    argb_t pixel64 = image->fetch_pixel_float (image, offset, line);
    uint32_t result;

    pixman_contract_from_float (&result, &pixel64, 1);

    return result;
}

typedef struct
{
    pixman_format_code_t	format;
    fetch_scanline_t		fetch_scanline_32;
    fetch_scanline_t		fetch_scanline_float;
    fetch_pixel_32_t		fetch_pixel_32;
    fetch_pixel_float_t		fetch_pixel_float;
    store_scanline_t		store_scanline_32;
    store_scanline_t		store_scanline_float;
} format_info_t;

#define FORMAT_INFO(format) 						\
    {									\
	PIXMAN_ ## format,						\
	    fetch_scanline_ ## format,					\
	    fetch_scanline_generic_float,				\
	    fetch_pixel_ ## format,					\
	    fetch_pixel_generic_float,					\
	    store_scanline_ ## format,					\
	    store_scanline_generic_float				\
    }

static const format_info_t accessors[] =
{
/* 32 bpp formats */
    FORMAT_INFO (a8r8g8b8),
    FORMAT_INFO (x8r8g8b8),
    FORMAT_INFO (a8b8g8r8),
    FORMAT_INFO (x8b8g8r8),
    FORMAT_INFO (b8g8r8a8),
    FORMAT_INFO (b8g8r8x8),
    FORMAT_INFO (r8g8b8a8),
    FORMAT_INFO (r8g8b8x8),
    FORMAT_INFO (x14r6g6b6),

/* sRGB formats */
  { PIXMAN_a8r8g8b8_sRGB,
    fetch_scanline_a8r8g8b8_32_sRGB, fetch_scanline_a8r8g8b8_sRGB_float,
    fetch_pixel_a8r8g8b8_32_sRGB, fetch_pixel_a8r8g8b8_sRGB_float,
    store_scanline_a8r8g8b8_32_sRGB, store_scanline_a8r8g8b8_sRGB_float,
  },

/* 24bpp formats */
    FORMAT_INFO (r8g8b8),
    FORMAT_INFO (b8g8r8),
    
/* 16bpp formats */
    FORMAT_INFO (r5g6b5),
    FORMAT_INFO (b5g6r5),
    
    FORMAT_INFO (a1r5g5b5),
    FORMAT_INFO (x1r5g5b5),
    FORMAT_INFO (a1b5g5r5),
    FORMAT_INFO (x1b5g5r5),
    FORMAT_INFO (a4r4g4b4),
    FORMAT_INFO (x4r4g4b4),
    FORMAT_INFO (a4b4g4r4),
    FORMAT_INFO (x4b4g4r4),
    
/* 8bpp formats */
    FORMAT_INFO (a8),
    FORMAT_INFO (r3g3b2),
    FORMAT_INFO (b2g3r3),
    FORMAT_INFO (a2r2g2b2),
    FORMAT_INFO (a2b2g2r2),
    
    FORMAT_INFO (c8),
    
    FORMAT_INFO (g8),
    
#define fetch_scanline_x4c4 fetch_scanline_c8
#define fetch_pixel_x4c4 fetch_pixel_c8
#define store_scanline_x4c4 store_scanline_c8
    FORMAT_INFO (x4c4),
    
#define fetch_scanline_x4g4 fetch_scanline_g8
#define fetch_pixel_x4g4 fetch_pixel_g8
#define store_scanline_x4g4 store_scanline_g8
    FORMAT_INFO (x4g4),
    
    FORMAT_INFO (x4a4),
    
/* 4bpp formats */
    FORMAT_INFO (a4),
    FORMAT_INFO (r1g2b1),
    FORMAT_INFO (b1g2r1),
    FORMAT_INFO (a1r1g1b1),
    FORMAT_INFO (a1b1g1r1),
    
    FORMAT_INFO (c4),
    
    FORMAT_INFO (g4),
    
/* 1bpp formats */
    FORMAT_INFO (a1),
    FORMAT_INFO (g1),
    
/* Wide formats */
    
    { PIXMAN_a2r10g10b10,
      NULL, fetch_scanline_a2r10g10b10_float,
      fetch_pixel_generic_lossy_32, fetch_pixel_a2r10g10b10_float,
      NULL, store_scanline_a2r10g10b10_float },

    { PIXMAN_x2r10g10b10,
      NULL, fetch_scanline_x2r10g10b10_float,
      fetch_pixel_generic_lossy_32, fetch_pixel_x2r10g10b10_float,
      NULL, store_scanline_x2r10g10b10_float },

    { PIXMAN_a2b10g10r10,
      NULL, fetch_scanline_a2b10g10r10_float,
      fetch_pixel_generic_lossy_32, fetch_pixel_a2b10g10r10_float,
      NULL, store_scanline_a2b10g10r10_float },

    { PIXMAN_x2b10g10r10,
      NULL, fetch_scanline_x2b10g10r10_float,
      fetch_pixel_generic_lossy_32, fetch_pixel_x2b10g10r10_float,
      NULL, store_scanline_x2b10g10r10_float },

/* YUV formats */
    { PIXMAN_yuy2,
      fetch_scanline_yuy2, fetch_scanline_generic_float,
      fetch_pixel_yuy2, fetch_pixel_generic_float,
      NULL, NULL },

    { PIXMAN_yv12,
      fetch_scanline_yv12, fetch_scanline_generic_float,
      fetch_pixel_yv12, fetch_pixel_generic_float,
      NULL, NULL },
    
    { PIXMAN_null },
};

static void
setup_accessors (bits_image_t *image)
{
    const format_info_t *info = accessors;
    
    while (info->format != PIXMAN_null)
    {
	if (info->format == image->format)
	{
	    image->fetch_scanline_32 = info->fetch_scanline_32;
	    image->fetch_scanline_float = info->fetch_scanline_float;
	    image->fetch_pixel_32 = info->fetch_pixel_32;
	    image->fetch_pixel_float = info->fetch_pixel_float;
	    image->store_scanline_32 = info->store_scanline_32;
	    image->store_scanline_float = info->store_scanline_float;
	    
	    return;
	}
	
	info++;
    }
}

#ifndef PIXMAN_FB_ACCESSORS
void
_pixman_bits_image_setup_accessors_accessors (bits_image_t *image);

void
_pixman_bits_image_setup_accessors (bits_image_t *image)
{
    if (image->read_func || image->write_func)
	_pixman_bits_image_setup_accessors_accessors (image);
    else
	setup_accessors (image);
}

#else

void
_pixman_bits_image_setup_accessors_accessors (bits_image_t *image)
{
    setup_accessors (image);
}

#endif
@


1.10
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@d297 1
a297 1
convert_pixel_to_a8r8g8b8 (pixman_image_t *image,
d304 1
a304 1
	return image->bits.indexed->rgba[pixel];
d335 1
a335 1
fetch_and_convert_pixel (pixman_image_t	*	image,
d420 1
a420 1
    fetch_scanline_ ## format (pixman_image_t *image,			\
d428 1
a428 1
	    (uint8_t *)(image->bits.bits + y * image->bits.rowstride);	\
d464 2
a465 2
	return fetch_and_convert_pixel ((pixman_image_t *)image,	\
					bits, offset, PIXMAN_ ## format); \
d586 1
a586 1
fetch_scanline_a8r8g8b8_sRGB_float (pixman_image_t *image,
d593 1
a593 1
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
d615 1
a615 1
fetch_scanline_a2r10g10b10_float (pixman_image_t *image,
d622 1
a622 1
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
d646 1
a646 1
fetch_scanline_x2r10g10b10_float (pixman_image_t *image,
d653 1
a653 1
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
d676 1
a676 1
fetch_scanline_a2b10g10r10_float (pixman_image_t *image,
d683 1
a683 1
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
d707 1
a707 1
fetch_scanline_x2b10g10r10_float (pixman_image_t *image,
d714 1
a714 1
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
d736 1
a736 1
fetch_scanline_yuy2 (pixman_image_t *image,
d743 1
a743 1
    const uint32_t *bits = image->bits.bits + image->bits.rowstride * line;
d770 1
a770 1
fetch_scanline_yv12 (pixman_image_t *image,
d1124 1
a1124 1
fetch_scanline_generic_float (pixman_image_t *image,
d1131 1
a1131 1
    image->bits.fetch_scanline_32 (image, x, y, width, buffer, NULL);
d1133 1
a1133 1
    pixman_expand_to_float ((argb_t *)buffer, buffer, image->bits.format, width);
d1140 1
a1140 1
fetch_scanline_a8r8g8b8_32_sRGB (pixman_image_t *image,
d1147 1
a1147 1
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
@


1.9
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@d34 1
d36 1
a37 1
#include "pixman-accessor.h"
d214 1
d510 87
d598 16
a613 1
/* Expects a uint64_t buffer */
d615 6
a620 6
fetch_scanline_a2r10g10b10 (pixman_image_t *image,
                            int             x,
                            int             y,
                            int             width,
                            uint32_t *      b,
                            const uint32_t *mask)
d625 1
a625 1
    uint64_t *buffer = (uint64_t *)b;
d635 4
a638 3
	r = r << 6 | r >> 4;
	g = g << 6 | g >> 4;
	b = b << 6 | b >> 4;
d640 1
a640 6
	a <<= 14;
	a |= a >> 2;
	a |= a >> 4;
	a |= a >> 8;

	*buffer++ = a << 48 | r << 32 | g << 16 | b;
d644 1
a644 1
/* Expects a uint64_t buffer */
d646 6
a651 6
fetch_scanline_x2r10g10b10 (pixman_image_t *image,
                            int             x,
                            int             y,
                            int             width,
                            uint32_t *      b,
                            const uint32_t *mask)
d656 2
a657 2
    uint64_t *buffer = (uint64_t *)b;
    
d664 7
a670 6
	
	r = r << 6 | r >> 4;
	g = g << 6 | g >> 4;
	b = b << 6 | b >> 4;
	
	*buffer++ = 0xffffULL << 48 | r << 32 | g << 16 | b;
d674 1
a674 1
/* Expects a uint64_t buffer */
d676 6
a681 6
fetch_scanline_a2b10g10r10 (pixman_image_t *image,
                            int             x,
                            int             y,
                            int             width,
                            uint32_t *      b,
                            const uint32_t *mask)
d686 2
a687 2
    uint64_t *buffer = (uint64_t *)b;
    
a694 9
	
	r = r << 6 | r >> 4;
	g = g << 6 | g >> 4;
	b = b << 6 | b >> 4;
	
	a <<= 14;
	a |= a >> 2;
	a |= a >> 4;
	a |= a >> 8;
d696 6
a701 1
	*buffer++ = a << 48 | r << 32 | g << 16 | b;
d705 1
a705 1
/* Expects a uint64_t buffer */
d707 6
a712 6
fetch_scanline_x2b10g10r10 (pixman_image_t *image,
                            int             x,
                            int             y,
                            int             width,
                            uint32_t *      b,
                            const uint32_t *mask)
d717 2
a718 2
    uint64_t *buffer = (uint64_t *)b;
    
d725 7
a731 6
	
	r = r << 6 | r >> 4;
	g = g << 6 | g >> 4;
	b = b << 6 | b >> 4;
	
	*buffer++ = 0xffffULL << 48 | r << 32 | g << 16 | b;
d808 4
a811 5
/* Despite the type, expects a uint64_t buffer */
static uint64_t
fetch_pixel_a2r10g10b10 (bits_image_t *image,
			 int		  offset,
			 int           line)
a814 1
    uint64_t a = p >> 30;
d818 6
d825 7
a831 17
    r = r << 6 | r >> 4;
    g = g << 6 | g >> 4;
    b = b << 6 | b >> 4;

    a <<= 14;
    a |= a >> 2;
    a |= a >> 4;
    a |= a >> 8;

    return a << 48 | r << 32 | g << 16 | b;
}

/* Despite the type, this function expects a uint64_t buffer */
static uint64_t
fetch_pixel_x2r10g10b10 (bits_image_t *image,
			 int	   offset,
			 int           line)
d835 1
d839 8
a846 6
    
    r = r << 6 | r >> 4;
    g = g << 6 | g >> 4;
    b = b << 6 | b >> 4;
    
    return 0xffffULL << 48 | r << 32 | g << 16 | b;
d849 4
a852 5
/* Despite the type, expects a uint64_t buffer */
static uint64_t
fetch_pixel_a2b10g10r10 (bits_image_t *image,
			 int           offset,
			 int           line)
d860 14
a873 18
    
    r = r << 6 | r >> 4;
    g = g << 6 | g >> 4;
    b = b << 6 | b >> 4;
    
    a <<= 14;
    a |= a >> 2;
    a |= a >> 4;
    a |= a >> 8;
    
    return a << 48 | r << 32 | g << 16 | b;
}

/* Despite the type, this function expects a uint64_t buffer */
static uint64_t
fetch_pixel_x2b10g10r10 (bits_image_t *image,
			 int           offset,
			 int           line)
d880 26
a905 6
    
    r = r << 6 | r >> 4;
    g = g << 6 | g >> 4;
    b = b << 6 | b >> 4;
    
    return 0xffffULL << 48 | r << 32 | g << 16 | b;
d966 5
a970 5
store_scanline_a2r10g10b10 (bits_image_t *  image,
                            int             x,
                            int             y,
                            int             width,
                            const uint32_t *v)
d974 27
a1000 1
    uint64_t *values = (uint64_t *)v;
d1002 1
a1002 1
    
d1005 6
d1012 1
a1012 4
	       ((values[i] >> 32) & 0xc0000000) |
	       ((values[i] >> 18) & 0x3ff00000) |
	       ((values[i] >> 12) & 0xffc00) | 
	       ((values[i] >> 6) & 0x3ff));    
d1017 5
a1021 5
store_scanline_x2r10g10b10 (bits_image_t *  image,
                            int             x,
                            int             y,
                            int             width,
                            const uint32_t *v)
a1023 1
    uint64_t *values = (uint64_t *)v;
d1025 1
d1027 1
a1027 1
    
d1030 7
d1038 1
a1038 3
	       ((values[i] >> 18) & 0x3ff00000) | 
	       ((values[i] >> 12) & 0xffc00) |
	       ((values[i] >> 6) & 0x3ff));
d1043 5
a1047 5
store_scanline_a2b10g10r10 (bits_image_t *  image,
                            int             x,
                            int             y,
                            int             width,
                            const uint32_t *v)
d1051 1
a1051 1
    uint64_t *values = (uint64_t *)v;
d1053 1
a1053 1
    
d1056 6
d1063 1
a1063 4
	       ((values[i] >> 32) & 0xc0000000) |
	       ((values[i] >> 38) & 0x3ff) |
	       ((values[i] >> 12) & 0xffc00) |
	       ((values[i] << 14) & 0x3ff00000));
d1068 5
a1072 5
store_scanline_x2b10g10r10 (bits_image_t *  image,
                            int             x,
                            int             y,
                            int             width,
                            const uint32_t *v)
a1074 1
    uint64_t *values = (uint64_t *)v;
d1076 1
d1078 1
a1078 1
    
d1081 7
d1089 1
a1089 3
	       ((values[i] >> 38) & 0x3ff) |
	       ((values[i] >> 12) & 0xffc00) |
	       ((values[i] << 14) & 0x3ff00000));
d1094 3
a1096 2
 * Contracts a 64bpp image to 32bpp and then stores it using a regular 32-bit
 * store proc. Despite the type, this function expects a uint64_t buffer.
d1099 5
a1103 5
store_scanline_generic_64 (bits_image_t *  image,
                           int             x,
                           int             y,
                           int             width,
                           const uint32_t *values)
d1106 1
a1106 1
    
d1108 1
a1108 1
    
d1112 1
a1112 1
    
d1116 2
a1117 2
    pixman_contract (argb8_pixels, (uint64_t *)values, width);
    
d1119 1
a1119 1
    
a1122 3
/* Despite the type, this function expects both buffer
 * and mask to be uint64_t
 */
d1124 6
a1129 6
fetch_scanline_generic_64 (pixman_image_t *image,
                           int             x,
                           int             y,
                           int             width,
                           uint32_t *      buffer,
                           const uint32_t *mask)
d1131 1
a1131 1
    pixman_format_code_t format;
d1133 2
a1134 4
    /* Fetch the pixels into the first half of buffer and then expand them in
     * place.
     */
    image->bits.fetch_scanline_32 (image, x, y, width, buffer, NULL);
d1136 17
a1152 3
    format = image->bits.format;
    if (PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_COLOR	||
	PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_GRAY)
d1154 12
a1165 4
	/* Indexed formats are mapped to a8r8g8b8 with full
	 * precision, so when expanding we shouldn't correct
	 * for the width of the channels
	 */
d1167 1
a1167 1
	format = PIXMAN_a8r8g8b8;
d1169 1
d1171 19
a1189 1
    pixman_expand ((uint64_t *)buffer, buffer, format, width);
d1192 6
a1197 5
/* Despite the type, this function expects a uint64_t *buffer */
static uint64_t
fetch_pixel_generic_64 (bits_image_t *image,
			int	      offset,
			int           line)
d1199 9
a1207 3
    uint32_t pixel32 = image->fetch_pixel_32 (image, offset, line);
    uint64_t result;
    pixman_format_code_t format;
d1209 1
a1209 8
    format = image->format;
    if (PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_COLOR	||
	PIXMAN_FORMAT_TYPE (format) == PIXMAN_TYPE_GRAY)
    {
	/* Indexed formats are mapped to a8r8g8b8 with full
	 * precision, so when expanding we shouldn't correct
	 * for the width of the channels
	 */
d1211 10
a1220 1
	format = PIXMAN_a8r8g8b8;
d1222 1
d1224 9
a1232 1
    pixman_expand ((uint64_t *)&result, &pixel32, format, 1);
d1234 1
a1234 1
    return result;
d1248 1
a1248 1
    uint64_t pixel64 = image->fetch_pixel_64 (image, offset, line);
d1251 1
a1251 1
    pixman_contract (&result, &pixel64, 1);
d1260 1
a1260 1
    fetch_scanline_t		fetch_scanline_64;
d1262 1
a1262 1
    fetch_pixel_64_t		fetch_pixel_64;
d1264 1
a1264 1
    store_scanline_t		store_scanline_64;
d1271 5
a1275 3
	    fetch_scanline_generic_64,					\
	    fetch_pixel_ ## format, fetch_pixel_generic_64,		\
	    store_scanline_ ## format, store_scanline_generic_64	\
d1291 7
d1356 4
a1359 4
      NULL, fetch_scanline_a2r10g10b10,
      fetch_pixel_generic_lossy_32, fetch_pixel_a2r10g10b10,
      NULL, store_scanline_a2r10g10b10 },
    
d1361 4
a1364 4
      NULL, fetch_scanline_x2r10g10b10,
      fetch_pixel_generic_lossy_32, fetch_pixel_x2r10g10b10,
      NULL, store_scanline_x2r10g10b10 },
    
d1366 4
a1369 4
      NULL, fetch_scanline_a2b10g10r10,
      fetch_pixel_generic_lossy_32, fetch_pixel_a2b10g10r10,
      NULL, store_scanline_a2b10g10r10 },
    
d1371 4
a1374 4
      NULL, fetch_scanline_x2b10g10r10,
      fetch_pixel_generic_lossy_32, fetch_pixel_x2b10g10r10,
      NULL, store_scanline_x2b10g10r10 },
    
d1377 2
a1378 2
      fetch_scanline_yuy2, fetch_scanline_generic_64,
      fetch_pixel_yuy2, fetch_pixel_generic_64,
d1380 1
a1380 1
    
d1382 2
a1383 2
      fetch_scanline_yv12, fetch_scanline_generic_64,
      fetch_pixel_yv12, fetch_pixel_generic_64,
d1399 1
a1399 1
	    image->fetch_scanline_64 = info->fetch_scanline_64;
d1401 1
a1401 1
	    image->fetch_pixel_64 = info->fetch_pixel_64;
d1403 1
a1403 1
	    image->store_scanline_64 = info->store_scanline_64;
@


1.8
log
@Update to pixman 0.22.4. Tested by shadchin@@, krw@@.
@
text
@a47 9
#define RGB15_TO_ENTRY(mif,rgb15)					\
    ((mif)->ent[rgb15])

#define RGB24_TO_ENTRY(mif,rgb24)					\
    RGB15_TO_ENTRY (mif,CONVERT_RGB24_TO_RGB15 (rgb24))

#define RGB24_TO_ENTRY_Y(mif,rgb24)					\
    ((mif)->ent[CONVERT_RGB24_TO_Y15 (rgb24)])

@


1.7
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d57 114
d203 67
a269 1
/********************************** Fetch ************************************/
d271 1
a271 13
static void
fetch_scanline_a8r8g8b8 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    
    MEMCPY_WRAPPED (image,
                    buffer, (const uint32_t *)bits + x,
                    width * sizeof(uint32_t));
d274 2
a275 7
static void
fetch_scanline_x8r8g8b8 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
d277 24
a300 6
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint32_t *pixel = (const uint32_t *)bits + x;
    const uint32_t *end = pixel + width;
    
    while (pixel < end)
	*buffer++ = READ (image, pixel++) | 0xff000000;
d303 4
a306 7
static void
fetch_scanline_a8b8g8r8 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
d308 2
a309 5
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint32_t *pixel = (uint32_t *)bits + x;
    const uint32_t *end = pixel + width;
    
    while (pixel < end)
d311 1
a311 5
	uint32_t p = READ (image, pixel++);
	
	*buffer++ = (p & 0xff00ff00)	|
	    ((p >> 16) & 0xff)		|
	    ((p & 0xff) << 16);
d313 1
a313 15
}

static void
fetch_scanline_x8b8g8r8 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint32_t *pixel = (uint32_t *)bits + x;
    const uint32_t *end = pixel + width;
    
    while (pixel < end)
d315 1
a315 6
	uint32_t p = READ (image, pixel++);
	
	*buffer++ = 0xff000000		|
	    (p & 0x0000ff00)		|
	    ((p >> 16) & 0xff)		|
	    ((p & 0xff) << 16);
d319 3
a321 7
static void
fetch_scanline_b8g8r8a8 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
d323 3
a325 3
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint32_t *pixel = (uint32_t *)bits + x;
    const uint32_t *end = pixel + width;
d327 3
a329 1
    while (pixel < end)
d331 1
a331 1
	uint32_t p = READ (image, pixel++);
d333 1
a333 4
	*buffer++ = (((p & 0xff000000) >> 24)	|
	             ((p & 0x00ff0000) >> 8)	|
	             ((p & 0x0000ff00) << 8)	|
	             ((p & 0x000000ff) << 24));
d335 1
a335 15
}

static void
fetch_scanline_b8g8r8x8 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint32_t *pixel = (uint32_t *)bits + x;
    const uint32_t *end = pixel + width;
    
    while (pixel < end)
d337 1
a337 6
	uint32_t p = READ (image, pixel++);
	
	*buffer++ = (0xff000000 |
	             ((p & 0xff000000) >> 24)	|
	             ((p & 0x00ff0000) >> 8)	|
	             ((p & 0x0000ff00) << 8));
d341 5
a345 7
static void
fetch_scanline_r8g8b8a8 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
d347 1
a347 3
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint32_t *pixel = (uint32_t *)bits + x;
    const uint32_t *end = pixel + width;
d349 1
a349 1
    while (pixel < end)
d351 23
a373 1
	uint32_t p = READ (image, pixel++);
d375 3
a377 1
	*buffer++ = (((p & 0x000000ff) << 24) | (p >> 8));
d379 2
d383 6
a388 7
static void
fetch_scanline_r8g8b8x8 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
d390 4
a393 5
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint32_t *pixel = (uint32_t *)bits + x;
    const uint32_t *end = pixel + width;
    
    while (pixel < end)
d395 11
a405 5
	uint32_t p = READ (image, pixel++);
	
	*buffer++ = (0xff000000 | (p >> 8));
    }
}
d407 3
a409 11
static void
fetch_scanline_x14r6g6b6 (pixman_image_t *image,
                          int             x,
                          int             y,
                          int             width,
                          uint32_t *      buffer,
                          const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint32_t *pixel = (const uint32_t *)bits + x;
    const uint32_t *end = pixel + width;
d411 3
a413 4
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t r, g, b;
d415 3
a417 3
	r = ((p & 0x3f000) << 6) | ((p & 0x30000));
	g = ((p & 0x00fc0) << 4) | ((p & 0x00c00) >> 2);
	b = ((p & 0x0003f) << 2) | ((p & 0x00030) >> 4);
d419 3
a421 1
	*buffer++ = 0xff000000 | r | g | b;
d425 93
d647 6
a652 6
fetch_scanline_r8g8b8 (pixman_image_t *image,
                       int             x,
                       int             y,
                       int             width,
                       uint32_t *      buffer,
                       const uint32_t *mask)
d654 2
a655 3
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint8_t *pixel = (const uint8_t *)bits + 3 * x;
    const uint8_t *end = pixel + 3 * width;
d657 1
a657 1
    while (pixel < end)
d659 2
a660 1
	uint32_t b = 0xff000000;
d662 10
a671 9
#ifdef WORDS_BIGENDIAN
	b |= (READ (image, pixel++) << 16);
	b |= (READ (image, pixel++) << 8);
	b |= (READ (image, pixel++));
#else
	b |= (READ (image, pixel++));
	b |= (READ (image, pixel++) << 8);
	b |= (READ (image, pixel++) << 16);
#endif
d673 4
a676 1
	*buffer++ = b;
d681 6
a686 6
fetch_scanline_b8g8r8 (pixman_image_t *image,
                       int             x,
                       int             y,
                       int             width,
                       uint32_t *      buffer,
                       const uint32_t *mask)
d688 5
a692 3
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint8_t *pixel = (const uint8_t *)bits + 3 * x;
    const uint8_t *end = pixel + 3 * width;
d694 1
a694 1
    while (pixel < end)
d696 13
a708 13
	uint32_t b = 0xff000000;
#ifdef WORDS_BIGENDIAN
	b |= (READ (image, pixel++));
	b |= (READ (image, pixel++) << 8);
	b |= (READ (image, pixel++) << 16);
#else
	b |= (READ (image, pixel++) << 16);
	b |= (READ (image, pixel++) << 8);
	b |= (READ (image, pixel++));
#endif
	*buffer++ = b;
    }
}
d710 4
a713 23
static void
fetch_scanline_r5g6b5 (pixman_image_t *image,
                       int             x,
                       int             y,
                       int             width,
                       uint32_t *      buffer,
                       const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint16_t *pixel = (const uint16_t *)bits + x;
    const uint16_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t r = (((p) << 3) & 0xf8) |
	    (((p) << 5) & 0xfc00) |
	    (((p) << 8) & 0xf80000);
	
	r |= (r >> 5) & 0x70007;
	r |= (r >> 6) & 0x300;
	
	*buffer++ = 0xff000000 | r;
d717 1
a717 24
static void
fetch_scanline_b5g6r5 (pixman_image_t *image,
                       int             x,
                       int             y,
                       int             width,
                       uint32_t *      buffer,
                       const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint16_t *pixel = (const uint16_t *)bits + x;
    const uint16_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t r, g, b;
	
	b = ((p & 0xf800) | ((p & 0xe000) >> 5)) >> 8;
	g = ((p & 0x07e0) | ((p & 0x0600) >> 6)) << 5;
	r = ((p & 0x001c) | ((p & 0x001f) << 5)) << 14;
	
	*buffer++ = 0xff000000 | r | g | b;
    }
}
d719 5
a723 1198
static void
fetch_scanline_a1r5g5b5 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint16_t *pixel = (const uint16_t *)bits + x;
    const uint16_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t r, g, b, a;
	
	a = (uint32_t) ((uint8_t) (0 - ((p & 0x8000) >> 15))) << 24;
	r = ((p & 0x7c00) | ((p & 0x7000) >> 5)) << 9;
	g = ((p & 0x03e0) | ((p & 0x0380) >> 5)) << 6;
	b = ((p & 0x001c) | ((p & 0x001f) << 5)) >> 2;
	
	*buffer++ = a | r | g | b;
    }
}

static void
fetch_scanline_x1r5g5b5 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint16_t *pixel = (const uint16_t *)bits + x;
    const uint16_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t r, g, b;
	
	r = ((p & 0x7c00) | ((p & 0x7000) >> 5)) << 9;
	g = ((p & 0x03e0) | ((p & 0x0380) >> 5)) << 6;
	b = ((p & 0x001c) | ((p & 0x001f) << 5)) >> 2;
	
	*buffer++ = 0xff000000 | r | g | b;
    }
}

static void
fetch_scanline_a1b5g5r5 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint16_t *pixel = (const uint16_t *)bits + x;
    const uint16_t *end = pixel + width;
    uint32_t r, g, b, a;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	
	a = (uint32_t) ((uint8_t) (0 - ((p & 0x8000) >> 15))) << 24;
	b = ((p & 0x7c00) | ((p & 0x7000) >> 5)) >> 7;
	g = ((p & 0x03e0) | ((p & 0x0380) >> 5)) << 6;
	r = ((p & 0x001c) | ((p & 0x001f) << 5)) << 14;
	
	*buffer++ = a | r | g | b;
    }
}

static void
fetch_scanline_x1b5g5r5 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint16_t *pixel = (const uint16_t *)bits + x;
    const uint16_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t r, g, b;
	
	b = ((p & 0x7c00) | ((p & 0x7000) >> 5)) >> 7;
	g = ((p & 0x03e0) | ((p & 0x0380) >> 5)) << 6;
	r = ((p & 0x001c) | ((p & 0x001f) << 5)) << 14;
	
	*buffer++ = 0xff000000 | r | g | b;
    }
}

static void
fetch_scanline_a4r4g4b4 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint16_t *pixel = (const uint16_t *)bits + x;
    const uint16_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t r, g, b, a;
	
	a = ((p & 0xf000) | ((p & 0xf000) >> 4)) << 16;
	r = ((p & 0x0f00) | ((p & 0x0f00) >> 4)) << 12;
	g = ((p & 0x00f0) | ((p & 0x00f0) >> 4)) << 8;
	b = ((p & 0x000f) | ((p & 0x000f) << 4));
	
	*buffer++ = a | r | g | b;
    }
}

static void
fetch_scanline_x4r4g4b4 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint16_t *pixel = (const uint16_t *)bits + x;
    const uint16_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t r, g, b;
	
	r = ((p & 0x0f00) | ((p & 0x0f00) >> 4)) << 12;
	g = ((p & 0x00f0) | ((p & 0x00f0) >> 4)) << 8;
	b = ((p & 0x000f) | ((p & 0x000f) << 4));
	
	*buffer++ = 0xff000000 | r | g | b;
    }
}

static void
fetch_scanline_a4b4g4r4 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint16_t *pixel = (const uint16_t *)bits + x;
    const uint16_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t r, g, b, a;
	
	a = ((p & 0xf000) | ((p & 0xf000) >> 4)) << 16;
	b = ((p & 0x0f00) | ((p & 0x0f00) >> 4)) >> 4;
	g = ((p & 0x00f0) | ((p & 0x00f0) >> 4)) << 8;
	r = ((p & 0x000f) | ((p & 0x000f) << 4)) << 16;
	
	*buffer++ = a | r | g | b;
    }
}

static void
fetch_scanline_x4b4g4r4 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint16_t *pixel = (const uint16_t *)bits + x;
    const uint16_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t r, g, b;
	
	b = ((p & 0x0f00) | ((p & 0x0f00) >> 4)) >> 4;
	g = ((p & 0x00f0) | ((p & 0x00f0) >> 4)) << 8;
	r = ((p & 0x000f) | ((p & 0x000f) << 4)) << 16;
	
	*buffer++ = 0xff000000 | r | g | b;
    }
}

static void
fetch_scanline_a8 (pixman_image_t *image,
                   int             x,
                   int             y,
                   int             width,
                   uint32_t *      buffer,
                   const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint8_t *pixel = (const uint8_t *)bits + x;
    const uint8_t *end = pixel + width;
    
    while (pixel < end)
	*buffer++ = READ (image, pixel++) << 24;
}

static void
fetch_scanline_r3g3b2 (pixman_image_t *image,
                       int             x,
                       int             y,
                       int             width,
                       uint32_t *      buffer,
                       const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint8_t *pixel = (const uint8_t *)bits + x;
    const uint8_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t r, g, b;
	
	r = ((p & 0xe0) | ((p & 0xe0) >> 3) | ((p & 0xc0) >> 6)) << 16;
	g = ((p & 0x1c) | ((p & 0x18) >> 3) | ((p & 0x1c) << 3)) << 8;
	b = (((p & 0x03)     ) |
	     ((p & 0x03) << 2) |
	     ((p & 0x03) << 4) |
	     ((p & 0x03) << 6));
	
	*buffer++ = 0xff000000 | r | g | b;
    }
}

static void
fetch_scanline_b2g3r3 (pixman_image_t *image,
                       int             x,
                       int             y,
                       int             width,
                       uint32_t *      buffer,
                       const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint8_t *pixel = (const uint8_t *)bits + x;
    const uint8_t *end = pixel + width;

    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t r, g, b;

	b  = p & 0xc0;
	b |= b >> 2;
	b |= b >> 4;
	b &= 0xff;

	g  = (p & 0x38) << 10;
	g |= g >> 3;
	g |= g >> 6;
	g &= 0xff00;

	r  = (p & 0x7) << 21;
	r |= r >> 3;
	r |= r >> 6;
	r &= 0xff0000;

	*buffer++ = 0xff000000 | r | g | b;
    }
}

static void
fetch_scanline_a2r2g2b2 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint8_t *pixel = (const uint8_t *)bits + x;
    const uint8_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t a, r, g, b;
	
	a = ((p & 0xc0) * 0x55) << 18;
	r = ((p & 0x30) * 0x55) << 12;
	g = ((p & 0x0c) * 0x55) << 6;
	b = ((p & 0x03) * 0x55);
	
	*buffer++ = a | r | g | b;
    }
}

static void
fetch_scanline_a2b2g2r2 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint8_t *pixel = (const uint8_t *)bits + x;
    const uint8_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	uint32_t a, r, g, b;
	
	a = ((p & 0xc0) * 0x55) << 18;
	b = ((p & 0x30) * 0x55) >> 4;
	g = ((p & 0x0c) * 0x55) << 6;
	r = ((p & 0x03) * 0x55) << 16;
	
	*buffer++ = a | r | g | b;
    }
}

static void
fetch_scanline_c8 (pixman_image_t *image,
                   int             x,
                   int             y,
                   int             width,
                   uint32_t *      buffer,
                   const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const pixman_indexed_t * indexed = image->bits.indexed;
    const uint8_t *pixel = (const uint8_t *)bits + x;
    const uint8_t *end = pixel + width;
    
    while (pixel < end)
    {
	uint32_t p = READ (image, pixel++);
	
	*buffer++ = indexed->rgba[p];
    }
}

static void
fetch_scanline_x4a4 (pixman_image_t *image,
                     int             x,
                     int             y,
                     int             width,
                     uint32_t *      buffer,
                     const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const uint8_t *pixel = (const uint8_t *)bits + x;
    const uint8_t *end = pixel + width;
   
    while (pixel < end)
    {
	uint8_t p = READ (image, pixel++) & 0xf;

	*buffer++ = (p | (p << 4)) << 24;
    }
}

#define FETCH_8(img,l,o)    (READ (img, (((uint8_t *)(l)) + ((o) >> 3))))
#ifdef WORDS_BIGENDIAN
#define FETCH_4(img,l,o)						\
    (((4 * (o)) & 4) ? (FETCH_8 (img,l, 4 * (o)) & 0xf) : (FETCH_8 (img,l,(4 * (o))) >> 4))
#else
#define FETCH_4(img,l,o)						\
    (((4 * (o)) & 4) ? (FETCH_8 (img, l, 4 * (o)) >> 4) : (FETCH_8 (img, l, (4 * (o))) & 0xf))
#endif

static void
fetch_scanline_a4 (pixman_image_t *image,
                   int             x,
                   int             y,
                   int             width,
                   uint32_t *      buffer,
                   const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint32_t p = FETCH_4 (image, bits, i + x);

	p |= p << 4;

	*buffer++ = p << 24;
    }
}

static void
fetch_scanline_r1g2b1 (pixman_image_t *image,
                       int             x,
                       int             y,
                       int             width,
                       uint32_t *      buffer,
                       const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	uint32_t p = FETCH_4 (image, bits, i + x);
	uint32_t r, g, b;
	
	r = ((p & 0x8) * 0xff) << 13;
	g = ((p & 0x6) * 0x55) << 7;
	b = ((p & 0x1) * 0xff);
	
	*buffer++ = 0xff000000 | r | g | b;
    }
}

static void
fetch_scanline_b1g2r1 (pixman_image_t *image,
                       int             x,
                       int             y,
                       int             width,
                       uint32_t *      buffer,
                       const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	uint32_t p = FETCH_4 (image, bits, i + x);
	uint32_t r, g, b;
	
	b = ((p & 0x8) * 0xff) >> 3;
	g = ((p & 0x6) * 0x55) << 7;
	r = ((p & 0x1) * 0xff) << 16;

	*buffer++ = 0xff000000 | r | g | b;
    }
}

static void
fetch_scanline_a1r1g1b1 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    uint32_t a, r, g, b;
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint32_t p = FETCH_4 (image, bits, i + x);

	a = ((p & 0x8) * 0xff) << 21;
	r = ((p & 0x4) * 0xff) << 14;
	g = ((p & 0x2) * 0xff) << 7;
	b = ((p & 0x1) * 0xff);

	*buffer++ = a | r | g | b;
    }
}

static void
fetch_scanline_a1b1g1r1 (pixman_image_t *image,
                         int             x,
                         int             y,
                         int             width,
                         uint32_t *      buffer,
                         const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint32_t p = FETCH_4 (image, bits, i + x);
	uint32_t a, r, g, b;

	a = ((p & 0x8) * 0xff) << 21;
	b = ((p & 0x4) * 0xff) >> 2;
	g = ((p & 0x2) * 0xff) << 7;
	r = ((p & 0x1) * 0xff) << 16;

	*buffer++ = a | r | g | b;
    }
}

static void
fetch_scanline_c4 (pixman_image_t *image,
                   int             x,
                   int             y,
                   int             width,
                   uint32_t *      buffer,
                   const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const pixman_indexed_t * indexed = image->bits.indexed;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	uint32_t p = FETCH_4 (image, bits, i + x);
	
	*buffer++ = indexed->rgba[p];
    }
}

static void
fetch_scanline_a1 (pixman_image_t *image,
                   int             x,
                   int             y,
                   int             width,
                   uint32_t *      buffer,
                   const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	uint32_t p = READ (image, bits + ((i + x) >> 5));
	uint32_t a;
	
#ifdef WORDS_BIGENDIAN
	a = p >> (0x1f - ((i + x) & 0x1f));
#else
	a = p >> ((i + x) & 0x1f);
#endif
	a = a & 1;
	a |= a << 1;
	a |= a << 2;
	a |= a << 4;
	
	*buffer++ = a << 24;
    }
}

static void
fetch_scanline_g1 (pixman_image_t *image,
                   int             x,
                   int             y,
                   int             width,
                   uint32_t *      buffer,
                   const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + y * image->bits.rowstride;
    const pixman_indexed_t * indexed = image->bits.indexed;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	uint32_t p = READ (image, bits + ((i + x) >> 5));
	uint32_t a;
	
#ifdef WORDS_BIGENDIAN
	a = p >> (0x1f - ((i + x) & 0x1f));
#else
	a = p >> ((i + x) & 0x1f);
#endif
	a = a & 1;
	
	*buffer++ = indexed->rgba[a];
    }
}

static void
fetch_scanline_yuy2 (pixman_image_t *image,
                     int             x,
                     int             line,
                     int             width,
                     uint32_t *      buffer,
                     const uint32_t *mask)
{
    const uint32_t *bits = image->bits.bits + image->bits.rowstride * line;
    int i;
    
    for (i = 0; i < width; i++)
    {
	int16_t y, u, v;
	int32_t r, g, b;
	
	y = ((uint8_t *) bits)[(x + i) << 1] - 16;
	u = ((uint8_t *) bits)[(((x + i) << 1) & - 4) + 1] - 128;
	v = ((uint8_t *) bits)[(((x + i) << 1) & - 4) + 3] - 128;
	
	/* R = 1.164(Y - 16) + 1.596(V - 128) */
	r = 0x012b27 * y + 0x019a2e * v;
	/* G = 1.164(Y - 16) - 0.813(V - 128) - 0.391(U - 128) */
	g = 0x012b27 * y - 0x00d0f2 * v - 0x00647e * u;
	/* B = 1.164(Y - 16) + 2.018(U - 128) */
	b = 0x012b27 * y + 0x0206a2 * u;
	
	*buffer++ = 0xff000000 |
	    (r >= 0 ? r < 0x1000000 ? r         & 0xff0000 : 0xff0000 : 0) |
	    (g >= 0 ? g < 0x1000000 ? (g >> 8)  & 0x00ff00 : 0x00ff00 : 0) |
	    (b >= 0 ? b < 0x1000000 ? (b >> 16) & 0x0000ff : 0x0000ff : 0);
    }
}

static void
fetch_scanline_yv12 (pixman_image_t *image,
                     int             x,
                     int             line,
                     int             width,
                     uint32_t *      buffer,
                     const uint32_t *mask)
{
    YV12_SETUP (image);
    uint8_t *y_line = YV12_Y (line);
    uint8_t *u_line = YV12_U (line);
    uint8_t *v_line = YV12_V (line);
    int i;
    
    for (i = 0; i < width; i++)
    {
	int16_t y, u, v;
	int32_t r, g, b;

	y = y_line[x + i] - 16;
	u = u_line[(x + i) >> 1] - 128;
	v = v_line[(x + i) >> 1] - 128;

	/* R = 1.164(Y - 16) + 1.596(V - 128) */
	r = 0x012b27 * y + 0x019a2e * v;
	/* G = 1.164(Y - 16) - 0.813(V - 128) - 0.391(U - 128) */
	g = 0x012b27 * y - 0x00d0f2 * v - 0x00647e * u;
	/* B = 1.164(Y - 16) + 2.018(U - 128) */
	b = 0x012b27 * y + 0x0206a2 * u;

	*buffer++ = 0xff000000 |
	    (r >= 0 ? r < 0x1000000 ? r         & 0xff0000 : 0xff0000 : 0) |
	    (g >= 0 ? g < 0x1000000 ? (g >> 8)  & 0x00ff00 : 0x00ff00 : 0) |
	    (b >= 0 ? b < 0x1000000 ? (b >> 16) & 0x0000ff : 0x0000ff : 0);
    }
}

/**************************** Pixel wise fetching *****************************/

/* Despite the type, expects a uint64_t buffer */
static uint64_t
fetch_pixel_a2r10g10b10 (bits_image_t *image,
			 int		  offset,
			 int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t p = READ (image, bits + offset);
    uint64_t a = p >> 30;
    uint64_t r = (p >> 20) & 0x3ff;
    uint64_t g = (p >> 10) & 0x3ff;
    uint64_t b = p & 0x3ff;

    r = r << 6 | r >> 4;
    g = g << 6 | g >> 4;
    b = b << 6 | b >> 4;

    a <<= 14;
    a |= a >> 2;
    a |= a >> 4;
    a |= a >> 8;

    return a << 48 | r << 32 | g << 16 | b;
}

/* Despite the type, this function expects a uint64_t buffer */
static uint64_t
fetch_pixel_x2r10g10b10 (bits_image_t *image,
			 int	   offset,
			 int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t p = READ (image, bits + offset);
    uint64_t r = (p >> 20) & 0x3ff;
    uint64_t g = (p >> 10) & 0x3ff;
    uint64_t b = p & 0x3ff;
    
    r = r << 6 | r >> 4;
    g = g << 6 | g >> 4;
    b = b << 6 | b >> 4;
    
    return 0xffffULL << 48 | r << 32 | g << 16 | b;
}

/* Despite the type, expects a uint64_t buffer */
static uint64_t
fetch_pixel_a2b10g10r10 (bits_image_t *image,
			 int           offset,
			 int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t p = READ (image, bits + offset);
    uint64_t a = p >> 30;
    uint64_t b = (p >> 20) & 0x3ff;
    uint64_t g = (p >> 10) & 0x3ff;
    uint64_t r = p & 0x3ff;
    
    r = r << 6 | r >> 4;
    g = g << 6 | g >> 4;
    b = b << 6 | b >> 4;
    
    a <<= 14;
    a |= a >> 2;
    a |= a >> 4;
    a |= a >> 8;
    
    return a << 48 | r << 32 | g << 16 | b;
}

/* Despite the type, this function expects a uint64_t buffer */
static uint64_t
fetch_pixel_x2b10g10r10 (bits_image_t *image,
			 int           offset,
			 int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t p = READ (image, bits + offset);
    uint64_t b = (p >> 20) & 0x3ff;
    uint64_t g = (p >> 10) & 0x3ff;
    uint64_t r = p & 0x3ff;
    
    r = r << 6 | r >> 4;
    g = g << 6 | g >> 4;
    b = b << 6 | b >> 4;
    
    return 0xffffULL << 48 | r << 32 | g << 16 | b;
}

static uint32_t
fetch_pixel_a8r8g8b8 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    return READ (image, (uint32_t *)bits + offset);
}

static uint32_t
fetch_pixel_x8r8g8b8 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;

    return READ (image, (uint32_t *)bits + offset) | 0xff000000;
}

static uint32_t
fetch_pixel_a8b8g8r8 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint32_t *)bits + offset);
    
    return ((pixel & 0xff000000) |
	    ((pixel >> 16) & 0xff) |
	    (pixel & 0x0000ff00) |
	    ((pixel & 0xff) << 16));
}

static uint32_t
fetch_pixel_x8b8g8r8 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint32_t *)bits + offset);
    
    return ((0xff000000) |
	    ((pixel >> 16) & 0xff) |
	    (pixel & 0x0000ff00) |
	    ((pixel & 0xff) << 16));
}

static uint32_t
fetch_pixel_b8g8r8a8 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint32_t *)bits + offset);
    
    return ((pixel & 0xff000000) >> 24 |
	    (pixel & 0x00ff0000) >> 8 |
	    (pixel & 0x0000ff00) << 8 |
	    (pixel & 0x000000ff) << 24);
}

static uint32_t
fetch_pixel_b8g8r8x8 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint32_t *)bits + offset);
    
    return ((0xff000000) |
	    (pixel & 0xff000000) >> 24 |
	    (pixel & 0x00ff0000) >> 8 |
	    (pixel & 0x0000ff00) << 8);
}

static uint32_t
fetch_pixel_r8g8b8a8 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint32_t *)bits + offset);
    
    return (((pixel & 0x000000ff) << 24) | (pixel >> 8));
}

static uint32_t
fetch_pixel_r8g8b8x8 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint32_t *)bits + offset);
    
    return (0xff000000 | (pixel >> 8));
}

static uint32_t
fetch_pixel_x14r6g6b6 (bits_image_t *image,
                       int           offset,
                       int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint32_t *) bits + offset);
    uint32_t r, g, b;

    r = ((pixel & 0x3f000) << 6) | ((pixel & 0x30000));
    g = ((pixel & 0x00fc0) << 4) | ((pixel & 0x00c00) >> 2);
    b = ((pixel & 0x0003f) << 2) | ((pixel & 0x00030) >> 4);

    return 0xff000000 | r | g | b;
}

static uint32_t
fetch_pixel_r8g8b8 (bits_image_t *image,
		    int           offset,
		    int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint8_t   *pixel = ((uint8_t *) bits) + (offset * 3);
    
#ifdef WORDS_BIGENDIAN
    return (0xff000000 |
	    (READ (image, pixel + 0) << 16) |
	    (READ (image, pixel + 1) << 8) |
	    (READ (image, pixel + 2)));
#else
    return (0xff000000 |
	    (READ (image, pixel + 2) << 16) |
	    (READ (image, pixel + 1) << 8) |
	    (READ (image, pixel + 0)));
#endif
}

static uint32_t
fetch_pixel_b8g8r8 (bits_image_t *image,
		    int           offset,
		    int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint8_t   *pixel = ((uint8_t *) bits) + (offset * 3);
#ifdef WORDS_BIGENDIAN
    return (0xff000000 |
	    (READ (image, pixel + 2) << 16) |
	    (READ (image, pixel + 1) << 8) |
	    (READ (image, pixel + 0)));
#else
    return (0xff000000 |
	    (READ (image, pixel + 0) << 16) |
	    (READ (image, pixel + 1) << 8) |
	    (READ (image, pixel + 2)));
#endif
}

static uint32_t
fetch_pixel_r5g6b5 (bits_image_t *image,
		    int           offset,
		    int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint16_t *) bits + offset);
    uint32_t r, g, b;
    
    r = ((pixel & 0xf800) | ((pixel & 0xe000) >> 5)) << 8;
    g = ((pixel & 0x07e0) | ((pixel & 0x0600) >> 6)) << 5;
    b = ((pixel & 0x001c) | ((pixel & 0x001f) << 5)) >> 2;
    
    return (0xff000000 | r | g | b);
}

static uint32_t
fetch_pixel_b5g6r5 (bits_image_t *image,
		    int           offset,
		    int           line)
{
    uint32_t r, g, b;
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint16_t *) bits + offset);
    
    b = ((pixel & 0xf800) | ((pixel & 0xe000) >> 5)) >> 8;
    g = ((pixel & 0x07e0) | ((pixel & 0x0600) >> 6)) << 5;
    r = ((pixel & 0x001c) | ((pixel & 0x001f) << 5)) << 14;
    
    return (0xff000000 | r | g | b);
}

static uint32_t
fetch_pixel_a1r5g5b5 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint16_t *) bits + offset);
    uint32_t a, r, g, b;
    
    a = (uint32_t) ((uint8_t) (0 - ((pixel & 0x8000) >> 15))) << 24;
    r = ((pixel & 0x7c00) | ((pixel & 0x7000) >> 5)) << 9;
    g = ((pixel & 0x03e0) | ((pixel & 0x0380) >> 5)) << 6;
    b = ((pixel & 0x001c) | ((pixel & 0x001f) << 5)) >> 2;
    
    return (a | r | g | b);
}

static uint32_t
fetch_pixel_x1r5g5b5 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint16_t *) bits + offset);
    uint32_t r, g, b;
    
    r = ((pixel & 0x7c00) | ((pixel & 0x7000) >> 5)) << 9;
    g = ((pixel & 0x03e0) | ((pixel & 0x0380) >> 5)) << 6;
    b = ((pixel & 0x001c) | ((pixel & 0x001f) << 5)) >> 2;
    
    return (0xff000000 | r | g | b);
}

static uint32_t
fetch_pixel_a1b5g5r5 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint16_t *) bits + offset);
    uint32_t a, r, g, b;
    
    a = (uint32_t) ((uint8_t) (0 - ((pixel & 0x8000) >> 15))) << 24;
    b = ((pixel & 0x7c00) | ((pixel & 0x7000) >> 5)) >> 7;
    g = ((pixel & 0x03e0) | ((pixel & 0x0380) >> 5)) << 6;
    r = ((pixel & 0x001c) | ((pixel & 0x001f) << 5)) << 14;
    
    return (a | r | g | b);
}

static uint32_t
fetch_pixel_x1b5g5r5 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint16_t *) bits + offset);
    uint32_t r, g, b;
    
    b = ((pixel & 0x7c00) | ((pixel & 0x7000) >> 5)) >> 7;
    g = ((pixel & 0x03e0) | ((pixel & 0x0380) >> 5)) << 6;
    r = ((pixel & 0x001c) | ((pixel & 0x001f) << 5)) << 14;
    
    return (0xff000000 | r | g | b);
}

static uint32_t
fetch_pixel_a4r4g4b4 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint16_t *) bits + offset);
    uint32_t a, r, g, b;
    
    a = ((pixel & 0xf000) | ((pixel & 0xf000) >> 4)) << 16;
    r = ((pixel & 0x0f00) | ((pixel & 0x0f00) >> 4)) << 12;
    g = ((pixel & 0x00f0) | ((pixel & 0x00f0) >> 4)) << 8;
    b = ((pixel & 0x000f) | ((pixel & 0x000f) << 4));
    
    return (a | r | g | b);
}

static uint32_t
fetch_pixel_x4r4g4b4 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint16_t *) bits + offset);
    uint32_t r, g, b;
    
    r = ((pixel & 0x0f00) | ((pixel & 0x0f00) >> 4)) << 12;
    g = ((pixel & 0x00f0) | ((pixel & 0x00f0) >> 4)) << 8;
    b = ((pixel & 0x000f) | ((pixel & 0x000f) << 4));
    
    return (0xff000000 | r | g | b);
}

static uint32_t
fetch_pixel_a4b4g4r4 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint16_t *) bits + offset);
    uint32_t a, r, g, b;
    
    a = ((pixel & 0xf000) | ((pixel & 0xf000) >> 4)) << 16;
    b = ((pixel & 0x0f00) | ((pixel & 0x0f00) >> 4)) >> 4;
    g = ((pixel & 0x00f0) | ((pixel & 0x00f0) >> 4)) << 8;
    r = ((pixel & 0x000f) | ((pixel & 0x000f) << 4)) << 16;
    
    return (a | r | g | b);
}

static uint32_t
fetch_pixel_x4b4g4r4 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint16_t *) bits + offset);
    uint32_t r, g, b;
    
    b = ((pixel & 0x0f00) | ((pixel & 0x0f00) >> 4)) >> 4;
    g = ((pixel & 0x00f0) | ((pixel & 0x00f0) >> 4)) << 8;
    r = ((pixel & 0x000f) | ((pixel & 0x000f) << 4)) << 16;
    
    return (0xff000000 | r | g | b);
}

static uint32_t
fetch_pixel_a8 (bits_image_t *image,
		int           offset,
		int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint8_t *) bits + offset);
    
    return pixel << 24;
}

static uint32_t
fetch_pixel_r3g3b2 (bits_image_t *image,
		    int           offset,
		    int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint8_t *) bits + offset);
    uint32_t r, g, b;
    
    r = ((pixel & 0xe0) |
	 ((pixel & 0xe0) >> 3) |
	 ((pixel & 0xc0) >> 6)) << 16;
    
    g = ((pixel & 0x1c) |
	 ((pixel & 0x18) >> 3) |
	 ((pixel & 0x1c) << 3)) << 8;
    
    b = (((pixel & 0x03)     ) |
	 ((pixel & 0x03) << 2) |
	 ((pixel & 0x03) << 4) |
	 ((pixel & 0x03) << 6));
    
    return (0xff000000 | r | g | b);
}

static uint32_t
fetch_pixel_b2g3r3 (bits_image_t *image,
		    int           offset,
		    int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t p = READ (image, (uint8_t *) bits + offset);
    uint32_t r, g, b;

    b  = p & 0xc0;
    b |= b >> 2;
    b |= b >> 4;
    b &= 0xff;

    g  = (p & 0x38) << 10;
    g |= g >> 3;
    g |= g >> 6;
    g &= 0xff00;

    r  = (p & 0x7) << 21;
    r |= r >> 3;
    r |= r >> 6;
    r &= 0xff0000;

    return 0xff000000 | r | g | b;
}

static uint32_t
fetch_pixel_a2r2g2b2 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint8_t *) bits + offset);
    uint32_t a, r, g, b;
    
    a = ((pixel & 0xc0) * 0x55) << 18;
    r = ((pixel & 0x30) * 0x55) << 12;
    g = ((pixel & 0x0c) * 0x55) << 6;
    b = ((pixel & 0x03) * 0x55);
    
    return a | r | g | b;
}

static uint32_t
fetch_pixel_a2b2g2r2 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint8_t *) bits + offset);
    uint32_t a, r, g, b;
    
    a = ((pixel & 0xc0) * 0x55) << 18;
    b = ((pixel & 0x30) * 0x55) >> 4;
    g = ((pixel & 0x0c) * 0x55) << 6;
    r = ((pixel & 0x03) * 0x55) << 16;
    
    return a | r | g | b;
}

static uint32_t
fetch_pixel_c8 (bits_image_t *image,
		int           offset,
		int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint8_t *) bits + offset);
    const pixman_indexed_t * indexed = image->indexed;
    
    return indexed->rgba[pixel];
}

static uint32_t
fetch_pixel_x4a4 (bits_image_t *image,
		  int           offset,
		  int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, (uint8_t *) bits + offset);
    
    return ((pixel & 0xf) | ((pixel & 0xf) << 4)) << 24;
}

static uint32_t
fetch_pixel_a4 (bits_image_t *image,
		int           offset,
		int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = FETCH_4 (image, bits, offset);
    
    pixel |= pixel << 4;
    return pixel << 24;
}

static uint32_t
fetch_pixel_r1g2b1 (bits_image_t *image,
		    int           offset,
		    int           line)
d726 5
a730 376
    uint32_t pixel = FETCH_4 (image, bits, offset);
    uint32_t r, g, b;
    
    r = ((pixel & 0x8) * 0xff) << 13;
    g = ((pixel & 0x6) * 0x55) << 7;
    b = ((pixel & 0x1) * 0xff);
    
    return 0xff000000 | r | g | b;
}

static uint32_t
fetch_pixel_b1g2r1 (bits_image_t *image,
		    int           offset,
		    int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = FETCH_4 (image, bits, offset);
    uint32_t r, g, b;
    
    b = ((pixel & 0x8) * 0xff) >> 3;
    g = ((pixel & 0x6) * 0x55) << 7;
    r = ((pixel & 0x1) * 0xff) << 16;
    
    return 0xff000000 | r | g | b;
}

static uint32_t
fetch_pixel_a1r1g1b1 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = FETCH_4 (image, bits, offset);
    uint32_t a, r, g, b;

    a = ((pixel & 0x8) * 0xff) << 21;
    r = ((pixel & 0x4) * 0xff) << 14;
    g = ((pixel & 0x2) * 0xff) << 7;
    b = ((pixel & 0x1) * 0xff);

    return a | r | g | b;
}

static uint32_t
fetch_pixel_a1b1g1r1 (bits_image_t *image,
		      int           offset,
		      int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = FETCH_4 (image, bits, offset);
    uint32_t a, r, g, b;

    a = ((pixel & 0x8) * 0xff) << 21;
    b = ((pixel & 0x4) * 0xff) >> 2;
    g = ((pixel & 0x2) * 0xff) << 7;
    r = ((pixel & 0x1) * 0xff) << 16;

    return a | r | g | b;
}

static uint32_t
fetch_pixel_c4 (bits_image_t *image,
		int           offset,
		int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = FETCH_4 (image, bits, offset);
    const pixman_indexed_t * indexed = image->indexed;

    return indexed->rgba[pixel];
}

static uint32_t
fetch_pixel_a1 (bits_image_t *image,
		int           offset,
		int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, bits + (offset >> 5));
    uint32_t a;
    
#ifdef WORDS_BIGENDIAN
    a = pixel >> (0x1f - (offset & 0x1f));
#else
    a = pixel >> (offset & 0x1f);
#endif
    a = a & 1;
    a |= a << 1;
    a |= a << 2;
    a |= a << 4;
    
    return a << 24;
}

static uint32_t
fetch_pixel_g1 (bits_image_t *image,
		int           offset,
		int           line)
{
    uint32_t *bits = image->bits + line * image->rowstride;
    uint32_t pixel = READ (image, bits + (offset >> 5));
    const pixman_indexed_t * indexed = image->indexed;
    uint32_t a;
    
#ifdef WORDS_BIGENDIAN
    a = pixel >> (0x1f - (offset & 0x1f));
#else
    a = pixel >> (offset & 0x1f);
#endif
    a = a & 1;
    
    return indexed->rgba[a];
}

static uint32_t
fetch_pixel_yuy2 (bits_image_t *image,
		  int           offset,
		  int           line)
{
    const uint32_t *bits = image->bits + image->rowstride * line;
    
    int16_t y, u, v;
    int32_t r, g, b;
    
    y = ((uint8_t *) bits)[offset << 1] - 16;
    u = ((uint8_t *) bits)[((offset << 1) & - 4) + 1] - 128;
    v = ((uint8_t *) bits)[((offset << 1) & - 4) + 3] - 128;
    
    /* R = 1.164(Y - 16) + 1.596(V - 128) */
    r = 0x012b27 * y + 0x019a2e * v;
    
    /* G = 1.164(Y - 16) - 0.813(V - 128) - 0.391(U - 128) */
    g = 0x012b27 * y - 0x00d0f2 * v - 0x00647e * u;
    
    /* B = 1.164(Y - 16) + 2.018(U - 128) */
    b = 0x012b27 * y + 0x0206a2 * u;
    
    return 0xff000000 |
	(r >= 0 ? r < 0x1000000 ? r         & 0xff0000 : 0xff0000 : 0) |
	(g >= 0 ? g < 0x1000000 ? (g >> 8)  & 0x00ff00 : 0x00ff00 : 0) |
	(b >= 0 ? b < 0x1000000 ? (b >> 16) & 0x0000ff : 0x0000ff : 0);
}

static uint32_t
fetch_pixel_yv12 (bits_image_t *image,
		  int           offset,
		  int           line)
{
    YV12_SETUP (image);
    int16_t y = YV12_Y (line)[offset] - 16;
    int16_t u = YV12_U (line)[offset >> 1] - 128;
    int16_t v = YV12_V (line)[offset >> 1] - 128;
    int32_t r, g, b;
    
    /* R = 1.164(Y - 16) + 1.596(V - 128) */
    r = 0x012b27 * y + 0x019a2e * v;
    
    /* G = 1.164(Y - 16) - 0.813(V - 128) - 0.391(U - 128) */
    g = 0x012b27 * y - 0x00d0f2 * v - 0x00647e * u;
    
    /* B = 1.164(Y - 16) + 2.018(U - 128) */
    b = 0x012b27 * y + 0x0206a2 * u;
    
    return 0xff000000 |
	(r >= 0 ? r < 0x1000000 ? r         & 0xff0000 : 0xff0000 : 0) |
	(g >= 0 ? g < 0x1000000 ? (g >> 8)  & 0x00ff00 : 0x00ff00 : 0) |
	(b >= 0 ? b < 0x1000000 ? (b >> 16) & 0x0000ff : 0x0000ff : 0);
}

/*********************************** Store ************************************/

#define SPLIT_A(v)              \
    uint32_t a = ((v) >> 24),   \
	r = ((v) >> 16) & 0xff, \
	g = ((v) >> 8) & 0xff,  \
	b = (v) & 0xff

#define SPLIT(v)                     \
    uint32_t r = ((v) >> 16) & 0xff, \
	g = ((v) >> 8) & 0xff,       \
	b = (v) & 0xff

static void
store_scanline_a2r10g10b10 (bits_image_t *  image,
                            int             x,
                            int             y,
                            int             width,
                            const uint32_t *v)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = bits + x;
    uint64_t *values = (uint64_t *)v;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	WRITE (image, pixel++,
	       ((values[i] >> 32) & 0xc0000000) |
	       ((values[i] >> 18) & 0x3ff00000) |
	       ((values[i] >> 12) & 0xffc00) | 
	       ((values[i] >> 6) & 0x3ff));    
    }
}

static void
store_scanline_x2r10g10b10 (bits_image_t *  image,
                            int             x,
                            int             y,
                            int             width,
                            const uint32_t *v)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint64_t *values = (uint64_t *)v;
    uint32_t *pixel = bits + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	WRITE (image, pixel++,
	       ((values[i] >> 18) & 0x3ff00000) | 
	       ((values[i] >> 12) & 0xffc00) |
	       ((values[i] >> 6) & 0x3ff));
    }
}

static void
store_scanline_a2b10g10r10 (bits_image_t *  image,
                            int             x,
                            int             y,
                            int             width,
                            const uint32_t *v)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = bits + x;
    uint64_t *values = (uint64_t *)v;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	WRITE (image, pixel++,
	       ((values[i] >> 32) & 0xc0000000) |
	       ((values[i] >> 38) & 0x3ff) |
	       ((values[i] >> 12) & 0xffc00) |
	       ((values[i] << 14) & 0x3ff00000));
    }
}

static void
store_scanline_x2b10g10r10 (bits_image_t *  image,
                            int             x,
                            int             y,
                            int             width,
                            const uint32_t *v)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint64_t *values = (uint64_t *)v;
    uint32_t *pixel = bits + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	WRITE (image, pixel++,
	       ((values[i] >> 38) & 0x3ff) |
	       ((values[i] >> 12) & 0xffc00) |
	       ((values[i] << 14) & 0x3ff00000));
    }
}

static void
store_scanline_a8r8g8b8 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    
    MEMCPY_WRAPPED (image, ((uint32_t *)bits) + x, values,
                    width * sizeof(uint32_t));
}

static void
store_scanline_x8r8g8b8 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = (uint32_t *)bits + x;
    int i;
    
    for (i = 0; i < width; ++i)
	WRITE (image, pixel++, values[i] & 0xffffff);
}

static void
store_scanline_a8b8g8r8 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = (uint32_t *)bits + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	WRITE (image, pixel++,
	       (values[i] & 0xff00ff00)         |
	       ((values[i] >> 16) & 0xff)       |
	       ((values[i] & 0xff) << 16));
    }
}

static void
store_scanline_x8b8g8r8 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = (uint32_t *)bits + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	WRITE (image, pixel++,
	       (values[i] & 0x0000ff00)         |
	       ((values[i] >> 16) & 0xff)       |
	       ((values[i] & 0xff) << 16));
    }
}

static void
store_scanline_b8g8r8a8 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = (uint32_t *)bits + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	WRITE (image, pixel++,
	       ((values[i] >> 24) & 0x000000ff) |
	       ((values[i] >>  8) & 0x0000ff00) |
	       ((values[i] <<  8) & 0x00ff0000) |
	       ((values[i] << 24) & 0xff000000));
    }
}

static void
store_scanline_b8g8r8x8 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = (uint32_t *)bits + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	WRITE (image, pixel++,
	       ((values[i] >>  8) & 0x0000ff00) |
	       ((values[i] <<  8) & 0x00ff0000) |
	       ((values[i] << 24) & 0xff000000));
    }
}
d732 3
a734 17
static void
store_scanline_r8g8b8a8 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = (uint32_t *)bits + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	WRITE (image, pixel++,
	       ((values[i] >> 24) & 0x000000ff) | (values[i] << 8));
    }
}
d736 4
a739 448
static void
store_scanline_r8g8b8x8 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = (uint32_t *)bits + x;
    int i;
    
    for (i = 0; i < width; ++i)
	WRITE (image, pixel++, (values[i] << 8));
}

static void
store_scanline_x14r6g6b6 (bits_image_t *  image,
                          int             x,
                          int             y,
                          int             width,
                          const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint32_t *pixel = ((uint32_t *) bits) + x;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint32_t s = values[i];
	uint32_t r, g, b;

	r = (s & 0xfc0000) >> 6;
	g = (s & 0x00fc00) >> 4;
	b = (s & 0x0000fc) >> 2;

	WRITE (image, pixel++, r | g | b);
    }
}

static void
store_scanline_r8g8b8 (bits_image_t *  image,
                       int             x,
                       int             y,
                       int             width,
                       const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint8_t *pixel = ((uint8_t *) bits) + 3 * x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	uint32_t val = values[i];
	
#ifdef WORDS_BIGENDIAN
	WRITE (image, pixel++, (val & 0x00ff0000) >> 16);
	WRITE (image, pixel++, (val & 0x0000ff00) >>  8);
	WRITE (image, pixel++, (val & 0x000000ff) >>  0);
#else
	WRITE (image, pixel++, (val & 0x000000ff) >>  0);
	WRITE (image, pixel++, (val & 0x0000ff00) >>  8);
	WRITE (image, pixel++, (val & 0x00ff0000) >> 16);
#endif
    }
}

static void
store_scanline_b8g8r8 (bits_image_t *  image,
                       int             x,
                       int             y,
                       int             width,
                       const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint8_t *pixel = ((uint8_t *) bits) + 3 * x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	uint32_t val = values[i];
	
#ifdef WORDS_BIGENDIAN
	WRITE (image, pixel++, (val & 0x000000ff) >>  0);
	WRITE (image, pixel++, (val & 0x0000ff00) >>  8);
	WRITE (image, pixel++, (val & 0x00ff0000) >> 16);
#else
	WRITE (image, pixel++, (val & 0x00ff0000) >> 16);
	WRITE (image, pixel++, (val & 0x0000ff00) >>  8);
	WRITE (image, pixel++, (val & 0x000000ff) >>  0);
#endif
    }
}

static void
store_scanline_r5g6b5 (bits_image_t *  image,
                       int             x,
                       int             y,
                       int             width,
                       const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint16_t *pixel = ((uint16_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	uint32_t s = values[i];
	
	WRITE (image, pixel++,
	       ((s >> 3) & 0x001f) |
	       ((s >> 5) & 0x07e0) |
	       ((s >> 8) & 0xf800));
    }
}

static void
store_scanline_b5g6r5 (bits_image_t *  image,
                       int             x,
                       int             y,
                       int             width,
                       const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT (values[i]);
	
	WRITE (image, pixel++,
	       ((b << 8) & 0xf800) |
	       ((g << 3) & 0x07e0) |
	       ((r >> 3)         ));
    }
}

static void
store_scanline_a1r5g5b5 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT_A (values[i]);
	
	WRITE (image, pixel++,
	       ((a << 8) & 0x8000) |
	       ((r << 7) & 0x7c00) |
	       ((g << 2) & 0x03e0) |
	       ((b >> 3)         ));
    }
}

static void
store_scanline_x1r5g5b5 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT (values[i]);
	
	WRITE (image, pixel++,
	       ((r << 7) & 0x7c00) |
	       ((g << 2) & 0x03e0) |
	       ((b >> 3)         ));
    }
}

static void
store_scanline_a1b5g5r5 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT_A (values[i]);
	
	WRITE (image, pixel++,
	       ((a << 8) & 0x8000) |
	       ((b << 7) & 0x7c00) |
	       ((g << 2) & 0x03e0) |
	       ((r >> 3)         ));
    }
}

static void
store_scanline_x1b5g5r5 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT (values[i]);
	
	WRITE (image, pixel++, ((b << 7) & 0x7c00) |
	       ((g << 2) & 0x03e0) |
	       ((r >> 3)         ));
    }
}

static void
store_scanline_a4r4g4b4 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT_A (values[i]);
	
	WRITE (image, pixel++,
	       ((a << 8) & 0xf000) |
	       ((r << 4) & 0x0f00) |
	       ((g     ) & 0x00f0) |
	       ((b >> 4)         ));
    }
}

static void
store_scanline_x4r4g4b4 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT (values[i]);
	
	WRITE (image, pixel++,
	       ((r << 4) & 0x0f00) |
	       ((g     ) & 0x00f0) |
	       ((b >> 4)         ));
    }
}

static void
store_scanline_a4b4g4r4 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT_A (values[i]);
	WRITE (image, pixel++, ((a << 8) & 0xf000) |
	       ((b << 4) & 0x0f00) |
	       ((g     ) & 0x00f0) |
	       ((r >> 4)         ));
    }
}

static void
store_scanline_x4b4g4r4 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT (values[i]);
	
	WRITE (image, pixel++,
	       ((b << 4) & 0x0f00) |
	       ((g     ) & 0x00f0) |
	       ((r >> 4)         ));
    }
}

static void
store_scanline_a8 (bits_image_t *  image,
                   int             x,
                   int             y,
                   int             width,
                   const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint8_t   *pixel = ((uint8_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	WRITE (image, pixel++, values[i] >> 24);
    }
}

static void
store_scanline_r3g3b2 (bits_image_t *  image,
                       int             x,
                       int             y,
                       int             width,
                       const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint8_t   *pixel = ((uint8_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT (values[i]);
	
	WRITE (image, pixel++,
	       ((r     ) & 0xe0) |
	       ((g >> 3) & 0x1c) |
	       ((b >> 6)       ));
    }
}

static void
store_scanline_b2g3r3 (bits_image_t *  image,
                       int             x,
                       int             y,
                       int             width,
                       const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint8_t   *pixel = ((uint8_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT (values[i]);
	
	WRITE (image, pixel++,
	       ((b     ) & 0xc0) |
	       ((g >> 2) & 0x38) |
	       ((r >> 5)       ));
    }
}

static void
store_scanline_a2r2g2b2 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint8_t   *pixel = ((uint8_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT_A (values[i]);
	
	WRITE (image, pixel++,
	       ((a     ) & 0xc0) |
	       ((r >> 2) & 0x30) |
	       ((g >> 4) & 0x0c) |
	       ((b >> 6)       ));
    }
}

static void
store_scanline_a2b2g2r2 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint8_t   *pixel = ((uint8_t *) bits) + x;
    int i;
    
    for (i = 0; i < width; ++i)
    {
	SPLIT_A (values[i]);
	
	WRITE (image, pixel++,
	       ((a     ) & 0xc0) |
	       ((b >> 2) & 0x30) |
	       ((g >> 4) & 0x0c) |
	       ((r >> 6)       ));
    }
}

static void
store_scanline_c8 (bits_image_t *  image,
                   int             x,
                   int             y,
                   int             width,
                   const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint8_t *pixel = ((uint8_t *) bits) + x;
    const pixman_indexed_t *indexed = image->indexed;
    int i;
    
    for (i = 0; i < width; ++i)
	WRITE (image, pixel++, RGB24_TO_ENTRY (indexed,values[i]));
}

static void
store_scanline_g8 (bits_image_t *  image,
                   int             x,
                   int             y,
                   int             width,
                   const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    uint8_t *pixel = ((uint8_t *) bits) + x;
    const pixman_indexed_t *indexed = image->indexed;
    int i;
d741 1
a741 2
    for (i = 0; i < width; ++i)
	WRITE (image, pixel++, RGB24_TO_ENTRY_Y (indexed,values[i]));
d744 5
a748 6
static void
store_scanline_x4a4 (bits_image_t *  image,
                     int             x,
                     int             y,
                     int             width,
                     const uint32_t *values)
d750 11
a760 6
    uint32_t *bits = image->bits + image->rowstride * y;
    uint8_t   *pixel = ((uint8_t *) bits) + x;
    int i;

    for (i = 0; i < width; ++i)
	WRITE (image, pixel++, values[i] >> 28);
d763 5
a767 35
#define STORE_8(img,l,o,v)  (WRITE (img, (uint8_t *)(l) + ((o) >> 3), (v)))
#ifdef WORDS_BIGENDIAN

#define STORE_4(img,l,o,v)						\
    do									\
    {									\
	int bo = 4 * (o);						\
	int v4 = (v) & 0x0f;						\
									\
	STORE_8 (img, l, bo, (						\
		     bo & 4 ?						\
		     (FETCH_8 (img, l, bo) & 0xf0) | (v4) :		\
		     (FETCH_8 (img, l, bo) & 0x0f) | (v4 << 4)));	\
    } while (0)
#else

#define STORE_4(img,l,o,v)						\
    do									\
    {									\
	int bo = 4 * (o);						\
	int v4 = (v) & 0x0f;						\
									\
	STORE_8 (img, l, bo, (						\
		     bo & 4 ?						\
		     (FETCH_8 (img, l, bo) & 0x0f) | (v4 << 4) :	\
		     (FETCH_8 (img, l, bo) & 0xf0) | (v4)));		\
    } while (0)
#endif

static void
store_scanline_a4 (bits_image_t *  image,
                   int             x,
                   int             y,
                   int             width,
                   const uint32_t *values)
d769 17
a785 5
    uint32_t *bits = image->bits + image->rowstride * y;
    int i;

    for (i = 0; i < width; ++i)
	STORE_4 (image, bits, i + x, values[i] >> 28);
d788 5
a792 6
static void
store_scanline_r1g2b1 (bits_image_t *  image,
                       int             x,
                       int             y,
                       int             width,
                       const uint32_t *values)
d794 11
a804 13
    uint32_t *bits = image->bits + image->rowstride * y;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint32_t pixel;

	SPLIT (values[i]);
	pixel = (((r >> 4) & 0x8) |
	         ((g >> 5) & 0x6) |
	         ((b >> 7)      ));
	STORE_4 (image, bits, i + x, pixel);
    }
d807 4
a810 6
static void
store_scanline_b1g2r1 (bits_image_t *  image,
                       int             x,
                       int             y,
                       int             width,
                       const uint32_t *values)
d812 22
a833 13
    uint32_t *bits = image->bits + image->rowstride * y;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint32_t pixel;

	SPLIT (values[i]);
	pixel = (((b >> 4) & 0x8) |
	         ((g >> 5) & 0x6) |
	         ((r >> 7)      ));
	STORE_4 (image, bits, i + x, pixel);
    }
d836 4
a839 6
static void
store_scanline_a1r1g1b1 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
d841 19
a859 15
    uint32_t *bits = image->bits + image->rowstride * y;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint32_t pixel;

	SPLIT_A (values[i]);
	pixel = (((a >> 4) & 0x8) |
	         ((r >> 5) & 0x4) |
	         ((g >> 6) & 0x2) |
	         ((b >> 7)      ));

	STORE_4 (image, bits, i + x, pixel);
    }
d862 1
a862 23
static void
store_scanline_a1b1g1r1 (bits_image_t *  image,
                         int             x,
                         int             y,
                         int             width,
                         const uint32_t *values)
{
    uint32_t *bits = image->bits + image->rowstride * y;
    int i;

    for (i = 0; i < width; ++i)
    {
	uint32_t pixel;

	SPLIT_A (values[i]);
	pixel = (((a >> 4) & 0x8) |
	         ((b >> 5) & 0x4) |
	         ((g >> 6) & 0x2) |
	         ((r >> 7)      ));

	STORE_4 (image, bits, i + x, pixel);
    }
}
d865 5
a869 5
store_scanline_c4 (bits_image_t *  image,
                   int             x,
                   int             y,
                   int             width,
                   const uint32_t *values)
d872 2
a873 1
    const pixman_indexed_t *indexed = image->indexed;
d878 5
a882 4
	uint32_t pixel;
	
	pixel = RGB24_TO_ENTRY (indexed, values[i]);
	STORE_4 (image, bits, i + x, pixel);
d887 5
a891 5
store_scanline_g4 (bits_image_t *  image,
                   int             x,
                   int             y,
                   int             width,
                   const uint32_t *values)
d894 2
a895 1
    const pixman_indexed_t *indexed = image->indexed;
d900 4
a903 4
	uint32_t pixel;
	
	pixel = RGB24_TO_ENTRY_Y (indexed, values[i]);
	STORE_4 (image, bits, i + x, pixel);
d908 5
a912 5
store_scanline_a1 (bits_image_t *  image,
                   int             x,
                   int             y,
                   int             width,
                   const uint32_t *values)
d915 2
d921 5
a925 11
	uint32_t  *pixel = ((uint32_t *) bits) + ((i + x) >> 5);
	uint32_t mask, v;
	
#ifdef WORDS_BIGENDIAN
	mask = 1 << (0x1f - ((i + x) & 0x1f));
#else
	mask = 1 << ((i + x) & 0x1f);
#endif
	v = values[i] & 0x80000000 ? mask : 0;
	
	WRITE (image, pixel, (READ (image, pixel) & ~mask) | v);
d930 5
a934 5
store_scanline_g1 (bits_image_t *  image,
                   int             x,
                   int             y,
                   int             width,
                   const uint32_t *values)
d937 2
a938 1
    const pixman_indexed_t *indexed = image->indexed;
d943 4
a946 11
	uint32_t  *pixel = ((uint32_t *) bits) + ((i + x) >> 5);
	uint32_t mask, v;
	
#ifdef WORDS_BIGENDIAN
	mask = 1 << (0x1f - ((i + x) & 0x1f));
#else
	mask = 1 << ((i + x) & 0x1f);
#endif
	v = RGB24_TO_ENTRY_Y (indexed, values[i]) & 0x1 ? mask : 0;
	
	WRITE (image, pixel, (READ (image, pixel) & ~mask) | v);
d991 1
a991 1
    
d1005 1
a1005 1
	
d1008 1
a1008 1
    
d1030 1
a1030 1
	
d1033 1
a1033 1
    
d1052 1
a1052 1
    
a1116 2
#define fetch_scanline_g8 fetch_scanline_c8
#define fetch_pixel_g8 fetch_pixel_c8
d1124 2
a1125 2
#define fetch_scanline_x4g4 fetch_scanline_c8
#define fetch_pixel_x4g4 fetch_pixel_c8
a1139 2
#define fetch_scanline_g4 fetch_scanline_c4
#define fetch_pixel_g4 fetch_pixel_c4
@


1.6
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@d214 40
d1335 22
d2093 33
d2943 2
@


1.5
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d97 1
a97 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d112 1
a112 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d128 1
a128 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d150 1
a150 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d173 1
a173 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d196 1
a196 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d213 25
d245 1
a245 2
                            const uint32_t *mask,
                            uint32_t        mask_bits)
d280 1
a280 2
                            const uint32_t *mask,
                            uint32_t        mask_bits)
d309 1
a309 2
                            const uint32_t *mask,
                            uint32_t        mask_bits)
d344 1
a344 2
                            const uint32_t *mask,
                            uint32_t        mask_bits)
d372 1
a372 2
                       const uint32_t *mask,
                       uint32_t        mask_bits)
d402 1
a402 2
                       const uint32_t *mask,
                       uint32_t        mask_bits)
d430 1
a430 2
                       const uint32_t *mask,
                       uint32_t        mask_bits)
d456 1
a456 2
                       const uint32_t *mask,
                       uint32_t        mask_bits)
d481 1
a481 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d507 1
a507 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d532 1
a532 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d558 1
a558 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d583 1
a583 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d609 1
a609 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d634 1
a634 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d660 1
a660 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d685 1
a685 2
                   const uint32_t *mask,
                   uint32_t        mask_bits)
d701 1
a701 2
                       const uint32_t *mask,
                       uint32_t        mask_bits)
d729 1
a729 2
                       const uint32_t *mask,
                       uint32_t        mask_bits)
d765 1
a765 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d791 1
a791 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d817 1
a817 2
                   const uint32_t *mask,
                   uint32_t        mask_bits)
d838 1
a838 2
                     const uint32_t *mask,
                     uint32_t        mask_bits)
d867 1
a867 2
                   const uint32_t *mask,
                   uint32_t        mask_bits)
d888 1
a888 2
                       const uint32_t *mask,
                       uint32_t        mask_bits)
d912 1
a912 2
                       const uint32_t *mask,
                       uint32_t        mask_bits)
d936 1
a936 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d961 1
a961 2
                         const uint32_t *mask,
                         uint32_t        mask_bits)
d986 1
a986 2
                   const uint32_t *mask,
                   uint32_t        mask_bits)
d1006 1
a1006 2
                   const uint32_t *mask,
                   uint32_t        mask_bits)
d1036 1
a1036 2
                   const uint32_t *mask,
                   uint32_t        mask_bits)
d1064 1
a1064 2
                     const uint32_t *mask,
                     uint32_t        mask_bits)
d1098 1
a1098 2
                     const uint32_t *mask,
                     uint32_t        mask_bits)
d1295 16
d2031 24
d2428 5
a2432 5
	*(pixel++) =
	    ((a     ) & 0xc0) |
	    ((b >> 2) & 0x30) |
	    ((g >> 4) & 0x0c) |
	    ((r >> 6)       );
d2453 16
d2639 20
d2735 1
a2735 1
    image->store_scanline_raw_32 (image, x, y, width, argb8_pixels);
d2749 1
a2749 2
                           const uint32_t *mask,
                           uint32_t        mask_bits)
d2751 2
d2756 13
a2768 1
    image->bits.fetch_scanline_raw_32 (image, x, y, width, buffer, NULL, 0);
d2770 1
a2770 1
    pixman_expand ((uint64_t *)buffer, buffer, image->bits.format, width);
d2779 1
a2779 1
    uint32_t pixel32 = image->fetch_pixel_raw_32 (image, offset, line);
d2781 13
d2795 1
a2795 1
    pixman_expand ((uint64_t *)&result, &pixel32, image->format, 1);
d2811 1
a2811 1
    uint64_t pixel64 = image->fetch_pixel_raw_64 (image, offset, line);
d2822 6
a2827 6
    fetch_scanline_t		fetch_scanline_raw_32;
    fetch_scanline_t		fetch_scanline_raw_64;
    fetch_pixel_32_t		fetch_pixel_raw_32;
    fetch_pixel_64_t		fetch_pixel_raw_64;
    store_scanline_t		store_scanline_raw_32;
    store_scanline_t		store_scanline_raw_64;
d2848 2
a2849 1
    
a2877 1
#define store_scanline_g8 store_scanline_c8
d2887 1
a2887 1
#define store_scanline_x4g4 store_scanline_c8
a2902 1
#define store_scanline_g4 store_scanline_c4
d2954 6
a2959 6
	    image->fetch_scanline_raw_32 = info->fetch_scanline_raw_32;
	    image->fetch_scanline_raw_64 = info->fetch_scanline_raw_64;
	    image->fetch_pixel_raw_32 = info->fetch_pixel_raw_32;
	    image->fetch_pixel_raw_64 = info->fetch_pixel_raw_64;
	    image->store_scanline_raw_32 = info->store_scanline_raw_32;
	    image->store_scanline_raw_64 = info->store_scanline_raw_64;
d2970 1
a2970 1
_pixman_bits_image_setup_raw_accessors_accessors (bits_image_t *image);
d2973 1
a2973 1
_pixman_bits_image_setup_raw_accessors (bits_image_t *image)
d2976 1
a2976 1
	_pixman_bits_image_setup_raw_accessors_accessors (image);
d2984 1
a2984 1
_pixman_bits_image_setup_raw_accessors_accessors (bits_image_t *image)
@


1.4
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@d183 1
a183 1
    
d187 1
a187 1
	
d734 1
a734 1
    
d739 16
a754 12
	
	b = (((p & 0xc0)     ) |
	     ((p & 0xc0) >> 2) |
	     ((p & 0xc0) >> 4) |
	     ((p & 0xc0) >> 6));
	
	g = ((p & 0x38) | ((p & 0x38) >> 3) | ((p & 0x30) << 2)) << 8;
	
	r = (((p & 0x07)     ) |
	     ((p & 0x07) << 3) |
	     ((p & 0x06) << 6)) << 16;
	
d805 1
a805 1
	b = ((p & 0x30) * 0x55) >> 6;
d847 1
a847 1
    
d851 1
a851 1
	
d856 1
a856 1
#define FETCH_8(img,l,o)    (READ (img, (uint8_t *)(l) + ((o) >> 2)))
d858 2
a859 1
#define FETCH_4(img,l,o)    ((o) & 2 ? FETCH_8 (img,l,o) & 0xf : FETCH_8 (img,l,o) >> 4)
d861 2
a862 1
#define FETCH_4(img,l,o)    ((o) & 2 ? FETCH_8 (img,l,o) >> 4 : FETCH_8 (img,l,o) & 0xf)
d876 1
a876 1
    
d880 1
a880 1
	
d882 1
a882 1
	
d932 1
a932 1
	
d949 1
a949 1
    
d953 1
a953 1
	
d958 1
a958 1
	
d974 1
a974 1
    
d979 1
a979 1
	
d981 1
a981 1
	r = ((p & 0x4) * 0xff) >> 3;
d983 2
a984 2
	b = ((p & 0x1) * 0xff) << 16;
	
d1555 1
a1555 1
    uint32_t pixel = READ (image, (uint8_t *) bits + offset);
d1557 17
a1573 15
    
    b = ((pixel & 0xc0)         |
	 ((pixel & 0xc0) >> 2)  |
	 ((pixel & 0xc0) >> 4)  |
	 ((pixel & 0xc0) >> 6));
    
    g = ((pixel & 0x38)         |
	 ((pixel & 0x38) >> 3)  |
	 ((pixel & 0x30) << 2)) << 8;
    
    r = ((pixel & 0x07)         |
	 ((pixel & 0x07) << 3)  |
	 ((pixel & 0x06) << 6)) << 16;
    
    return (0xff000000 | r | g | b);
d1603 1
a1603 1
    b = ((pixel & 0x30) * 0x55) >> 6;
d1685 1
a1685 1
    
d1690 1
a1690 1
    
d1702 1
a1702 1
    
d1704 1
a1704 1
    r = ((pixel & 0x4) * 0xff) >> 3;
d1706 2
a1707 2
    b = ((pixel & 0x1) * 0xff) << 16;
    
d1719 1
a1719 1
    
d2436 1
a2436 1
    
d2443 12
a2454 4
#define STORE_4(img,l,o,v)					    \
    STORE_8 (img,l,o,((o) & 4 ?					    \
                      (FETCH_8 (img,l,o) & 0xf0) | (v) :            \
                      (FETCH_8 (img,l,o) & 0x0f) | ((v) << 4)))
d2456 12
a2467 4
#define STORE_4(img,l,o,v)					\
    STORE_8 (img,l,o,((o) & 4 ?					\
                      (FETCH_8 (img,l,o) & 0x0f) | ((v) << 4) : \
                      (FETCH_8 (img,l,o) & 0xf0) | (v)))
d2479 1
a2479 1
    
d2493 1
a2493 1
    
d2497 1
a2497 1
	
d2515 1
a2515 1
    
d2519 1
a2519 1
	
d2537 1
a2537 1
    
d2541 1
a2541 1
	
d2547 1
d2561 1
a2561 1
    
d2565 1
a2565 1
	
d2571 1
d2643 1
a2643 1
	v = RGB24_TO_ENTRY_Y (indexed, values[i]) ? mask : 0;
@


1.3
log
@Update to pixman 0.15.8.
@
text
@d36 1
d38 18
a55 3
#define Red(x) (((x) >> 16) & 0xff)
#define Green(x) (((x) >> 8) & 0xff)
#define Blue(x) ((x) & 0xff)
d61 11
a71 9
#define YV12_SETUP(pict) \
	uint32_t *bits = pict->bits; \
	int stride = pict->rowstride; \
	int offset0 = stride < 0 ? \
		((-stride) >> 1) * ((pict->height - 1) >> 1) - stride : \
		stride * pict->height; \
	int offset1 = stride < 0 ? \
		offset0 + ((-stride) >> 1) * ((pict->height) >> 1) : \
		offset0 + (offset0 >> 2)
d73 1
a73 1
 * the typical usage of YV12_SETUP(pict); will have an extra trailing ;
d78 1
a78 1
#define YV12_Y(line)		\
d81 34
a114 12
#define YV12_U(line)	      \
    ((uint8_t *) ((bits) + offset1 + \
		((stride) >> 1) * ((line) >> 1)))

#define YV12_V(line)	      \
    ((uint8_t *) ((bits) + offset0 + \
		((stride) >> 1) * ((line) >> 1)))

/*********************************** Fetch ************************************/

static FASTCALL void
fbFetch_a8r8g8b8 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d116 1
a116 10
    const uint32_t *bits = pict->bits + y*pict->rowstride;
    MEMCPY_WRAPPED(pict,
                   buffer, (const uint32_t *)bits + x,
		   width*sizeof(uint32_t));
}

static FASTCALL void
fbFetch_x8r8g8b8 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
{
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d119 3
a121 3
    while (pixel < end) {
	*buffer++ = READ(pict, pixel++) | 0xff000000;
    }
d124 8
a131 2
static FASTCALL void
fbFetch_a8b8g8r8 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d133 1
a133 1
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d136 7
a142 4
    while (pixel < end) {
	uint32_t p = READ(pict, pixel++);
	*buffer++ = (p & 0xff00ff00) |
	            ((p >> 16) & 0xff) |
d147 8
a154 2
static FASTCALL void
fbFetch_x8b8g8r8 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d156 1
a156 1
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d159 8
a166 5
    while (pixel < end) {
	uint32_t p = READ(pict, pixel++);
	*buffer++ = 0xff000000 |
	    (p & 0x0000ff00) |
	    ((p >> 16) & 0xff) |
d171 8
a178 2
static FASTCALL void
fbFetch_b8g8r8a8 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d180 1
a180 1
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d183 9
a191 6
    while (pixel < end) {
	uint32_t p = READ(pict, pixel++);
	*buffer++ = ((p & 0xff000000) >> 24) |
	    ((p & 0x00ff0000) >> 8) |
	    ((p & 0x0000ff00) << 8) |
	    ((p & 0x000000ff) << 24);
d195 8
a202 2
static FASTCALL void
fbFetch_b8g8r8x8 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d204 1
a204 1
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d207 9
a215 6
    while (pixel < end) {
	uint32_t p = READ(pict, pixel++);
	*buffer++ = 0xff000000 |
	    ((p & 0xff000000) >> 24) |
	    ((p & 0x00ff0000) >> 8) |
	    ((p & 0x0000ff00) << 8);
d219 9
a227 2
static FASTCALL void
fbFetch_a2b10g10r10 (bits_image_t *pict, int x, int y, int width, uint64_t *buffer)
d229 1
a229 1
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d232 1
a232 6
    while (pixel < end) {
        uint32_t p = READ(pict, pixel++);
        uint64_t a = p >> 30;
        uint64_t b = (p >> 20) & 0x3ff;
        uint64_t g = (p >> 10) & 0x3ff;
        uint64_t r = p & 0x3ff;
d234 20
a253 3
        r = r << 6 | r >> 4;
        g = g << 6 | g >> 4;
        b = b << 6 | b >> 4;
d255 29
a283 4
        a <<= 62;
        a |= a >> 2;
        a |= a >> 4;
        a |= a >> 8;
d285 33
a317 1
        *buffer++ = a << 48 | r << 32 | g << 16 | b;
d321 9
a329 2
static FASTCALL void
fbFetch_x2b10g10r10 (bits_image_t *pict, int x, int y, int width, uint64_t *buffer)
d331 1
a331 1
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d334 14
a347 11
    while (pixel < end) {
        uint32_t p = READ(pict, pixel++);
        uint64_t b = (p >> 20) & 0x3ff;
        uint64_t g = (p >> 10) & 0x3ff;
        uint64_t r = p & 0x3ff;

        r = r << 6 | r >> 4;
        g = g << 6 | g >> 4;
        b = b << 6 | b >> 4;

        *buffer++ = 0xffffULL << 48 | r << 32 | g << 16 | b;
d351 27
a377 9
static FASTCALL void
fbFetch_r8g8b8 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
{
    const uint32_t *bits = pict->bits + y*pict->rowstride;
    const uint8_t *pixel = (const uint8_t *)bits + 3*x;
    const uint8_t *end = pixel + 3*width;
    while (pixel < end) {
	uint32_t b = Fetch24(pict, pixel) | 0xff000000;
	pixel += 3;
d382 15
a396 7
static FASTCALL void
fbFetch_b8g8r8 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
{
    const uint32_t *bits = pict->bits + y*pict->rowstride;
    const uint8_t *pixel = (const uint8_t *)bits + 3*x;
    const uint8_t *end = pixel + 3*width;
    while (pixel < end) {
d398 4
a401 4
#if IMAGE_BYTE_ORDER == MSBFirst
	b |= (READ(pict, pixel++));
	b |= (READ(pict, pixel++) << 8);
	b |= (READ(pict, pixel++) << 16);
d403 3
a405 3
	b |= (READ(pict, pixel++) << 16);
	b |= (READ(pict, pixel++) << 8);
	b |= (READ(pict, pixel++));
d411 8
a418 2
static FASTCALL void
fbFetch_r5g6b5 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d420 1
a420 1
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d423 4
a426 2
    while (pixel < end) {
	uint32_t p = READ(pict, pixel++);
d430 1
d433 1
d438 8
a445 2
static FASTCALL void
fbFetch_b5g6r5 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d447 1
a447 2
    uint32_t  r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d450 6
a455 2
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);
d459 1
d464 8
a471 2
static FASTCALL void
fbFetch_a1r5g5b5 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d473 1
a473 2
    uint32_t  r,g,b, a;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d476 6
a481 3
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);

d486 1
d491 8
a498 2
static FASTCALL void
fbFetch_x1r5g5b5 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d500 1
a500 2
    uint32_t  r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d503 6
a508 3
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);

d512 1
d517 8
a524 2
static FASTCALL void
fbFetch_a1b5g5r5 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d526 1
a526 2
    uint32_t  r,g,b, a;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d529 6
a534 3
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);

d539 1
d544 8
a551 2
static FASTCALL void
fbFetch_x1b5g5r5 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d553 1
a553 2
    uint32_t  r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d556 6
a561 3
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);

d565 1
d570 8
a577 2
static FASTCALL void
fbFetch_a4r4g4b4 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d579 1
a579 2
    uint32_t  r,g,b, a;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d582 6
a587 3
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);

d592 1
d597 8
a604 2
static FASTCALL void
fbFetch_x4r4g4b4 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d606 1
a606 2
    uint32_t  r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d609 6
a614 3
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);

d618 1
d623 8
a630 2
static FASTCALL void
fbFetch_a4b4g4r4 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d632 1
a632 2
    uint32_t  r,g,b, a;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d635 6
a640 3
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);

d645 1
d650 8
a657 2
static FASTCALL void
fbFetch_x4b4g4r4 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d659 1
a659 2
    uint32_t  r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d662 6
a667 3
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);

d671 1
d676 8
a683 2
static FASTCALL void
fbFetch_a8 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d685 1
a685 1
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d688 3
a690 3
    while (pixel < end) {
	*buffer++ = READ(pict, pixel++) << 24;
    }
d693 8
a700 2
static FASTCALL void
fbFetch_r3g3b2 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d702 1
a702 2
    uint32_t  r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d705 6
a710 3
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);

d717 1
d722 8
a729 2
static FASTCALL void
fbFetch_b2g3r3 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d731 1
a731 2
    uint32_t  r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d734 6
a739 3
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);

d744 1
d746 1
d750 1
d755 8
a762 2
static FASTCALL void
fbFetch_a2r2g2b2 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d764 1
a764 2
    uint32_t   a,r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d767 6
a772 3
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);

d777 2
a778 1
	*buffer++ = a|r|g|b;
d782 8
a789 2
static FASTCALL void
fbFetch_a2b2g2r2 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d791 1
a791 2
    uint32_t   a,r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d794 6
a799 3
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);

d804 2
a805 1
	*buffer++ = a|r|g|b;
d809 8
a816 2
static FASTCALL void
fbFetch_c8 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d818 2
a819 2
    const uint32_t *bits = pict->bits + y*pict->rowstride;
    const pixman_indexed_t * indexed = pict->indexed;
d822 5
a826 2
    while (pixel < end) {
	uint32_t  p = READ(pict, pixel++);
d831 8
a838 2
static FASTCALL void
fbFetch_x4a4 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d840 1
a840 1
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d843 5
a847 2
    while (pixel < end) {
	uint8_t p = READ(pict, pixel++) & 0xf;
d852 3
a854 3
#define Fetch8(img,l,o)    (READ(img, (uint8_t *)(l) + ((o) >> 2)))
#if IMAGE_BYTE_ORDER == MSBFirst
#define Fetch4(img,l,o)    ((o) & 2 ? Fetch8(img,l,o) & 0xf : Fetch8(img,l,o) >> 4)
d856 1
a856 1
#define Fetch4(img,l,o)    ((o) & 2 ? Fetch8(img,l,o) >> 4 : Fetch8(img,l,o) & 0xf)
d859 8
a866 2
static FASTCALL void
fbFetch_a4 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d868 1
a868 1
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d870 5
a874 3
    for (i = 0; i < width; ++i) {
	uint32_t  p = Fetch4(pict, bits, i + x);

d876 1
d881 8
a888 2
static FASTCALL void
fbFetch_r1g2b1 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d890 1
a890 2
    uint32_t  r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d892 6
a897 3
    for (i = 0; i < width; ++i) {
	uint32_t  p = Fetch4(pict, bits, i + x);

d901 2
a902 1
	*buffer++ = 0xff000000|r|g|b;
d906 8
a913 2
static FASTCALL void
fbFetch_b1g2r1 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d915 1
a915 2
    uint32_t  r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d917 6
a922 3
    for (i = 0; i < width; ++i) {
	uint32_t  p = Fetch4(pict, bits, i + x);

d926 2
a927 1
	*buffer++ = 0xff000000|r|g|b;
d931 8
a938 2
static FASTCALL void
fbFetch_a1r1g1b1 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d940 2
a941 2
    uint32_t  a,r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d943 5
a947 3
    for (i = 0; i < width; ++i) {
	uint32_t  p = Fetch4(pict, bits, i + x);

d952 2
a953 1
	*buffer++ = a|r|g|b;
d957 8
a964 2
static FASTCALL void
fbFetch_a1b1g1r1 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d966 1
a966 2
    uint32_t  a,r,g,b;
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d968 6
a973 3
    for (i = 0; i < width; ++i) {
	uint32_t  p = Fetch4(pict, bits, i + x);

d978 2
a979 1
	*buffer++ = a|r|g|b;
d983 8
a990 2
static FASTCALL void
fbFetch_c4 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d992 2
a993 2
    const uint32_t *bits = pict->bits + y*pict->rowstride;
    const pixman_indexed_t * indexed = pict->indexed;
d995 5
a999 3
    for (i = 0; i < width; ++i) {
	uint32_t  p = Fetch4(pict, bits, i + x);

d1004 8
a1011 3

static FASTCALL void
fbFetch_a1 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d1013 1
a1013 1
    const uint32_t *bits = pict->bits + y*pict->rowstride;
d1015 8
a1022 5
    for (i = 0; i < width; ++i) {
	uint32_t  p = READ(pict, bits + ((i + x) >> 5));
	uint32_t  a;
#if BITMAP_BIT_ORDER == MSBFirst
	a = p >> (0x1f - ((i+x) & 0x1f));
d1024 1
a1024 1
	a = p >> ((i+x) & 0x1f);
d1030 1
d1035 8
a1042 2
static FASTCALL void
fbFetch_g1 (bits_image_t *pict, int x, int y, int width, uint32_t *buffer)
d1044 2
a1045 2
    const uint32_t *bits = pict->bits + y*pict->rowstride;
    const pixman_indexed_t * indexed = pict->indexed;
d1047 4
a1050 2
    for (i = 0; i < width; ++i) {
	uint32_t p = READ(pict, bits + ((i+x) >> 5));
d1052 3
a1054 2
#if BITMAP_BIT_ORDER == MSBFirst
	a = p >> (0x1f - ((i+x) & 0x1f));
d1056 1
a1056 1
	a = p >> ((i+x) & 0x1f);
d1059 1
d1064 8
a1071 2
static FASTCALL void
fbFetch_yuy2 (bits_image_t *pict, int x, int line, int width, uint32_t *buffer)
d1073 3
a1075 6
    int16_t y, u, v;
    int32_t r, g, b;
    int   i;

    const uint32_t *bits = pict->bits + pict->rowstride * line;

d1078 3
d1082 3
a1084 3
	u = ((uint8_t *) bits)[(((x + i) << 1) & -4) + 1] - 128;
	v = ((uint8_t *) bits)[(((x + i) << 1) & -4) + 3] - 128;

d1091 5
a1095 5

	WRITE(pict, buffer++, 0xff000000 |
	      (r >= 0 ? r < 0x1000000 ? r         & 0xff0000 : 0xff0000 : 0) |
	      (g >= 0 ? g < 0x1000000 ? (g >> 8)  & 0x00ff00 : 0x00ff00 : 0) |
	      (b >= 0 ? b < 0x1000000 ? (b >> 16) & 0x0000ff : 0x0000ff : 0));
d1099 8
a1106 2
static FASTCALL void
fbFetch_yv12 (bits_image_t *pict, int x, int line, int width, uint32_t *buffer)
d1108 6
a1113 8
    YV12_SETUP(pict);
    uint8_t *pY = YV12_Y (line);
    uint8_t *pU = YV12_U (line);
    uint8_t *pV = YV12_V (line);
    int16_t y, u, v;
    int32_t r, g, b;
    int   i;

d1116 6
a1121 3
	y = pY[x + i] - 16;
	u = pU[(x + i) >> 1] - 128;
	v = pV[(x + i) >> 1] - 128;
d1130 1
a1130 1
	WRITE(pict, buffer++, 0xff000000 |
d1133 1
a1133 1
	    (b >= 0 ? b < 0x1000000 ? (b >> 16) & 0x0000ff : 0x0000ff : 0));
d1137 7
a1143 1
fetchProc32 ACCESS(pixman_fetchProcForPicture32) (bits_image_t * pict)
d1145 17
a1161 77
    switch(pict->format) {
    case PIXMAN_a8r8g8b8: return fbFetch_a8r8g8b8;
    case PIXMAN_x8r8g8b8: return fbFetch_x8r8g8b8;
    case PIXMAN_a8b8g8r8: return fbFetch_a8b8g8r8;
    case PIXMAN_x8b8g8r8: return fbFetch_x8b8g8r8;
    case PIXMAN_b8g8r8a8: return fbFetch_b8g8r8a8;
    case PIXMAN_b8g8r8x8: return fbFetch_b8g8r8x8;
    /* These two require wide compositing */
    case PIXMAN_a2b10g10r10: return NULL;
    case PIXMAN_x2b10g10r10: return NULL;

        /* 24bpp formats */
    case PIXMAN_r8g8b8: return fbFetch_r8g8b8;
    case PIXMAN_b8g8r8: return fbFetch_b8g8r8;

        /* 16bpp formats */
    case PIXMAN_r5g6b5: return fbFetch_r5g6b5;
    case PIXMAN_b5g6r5: return fbFetch_b5g6r5;

    case PIXMAN_a1r5g5b5: return fbFetch_a1r5g5b5;
    case PIXMAN_x1r5g5b5: return fbFetch_x1r5g5b5;
    case PIXMAN_a1b5g5r5: return fbFetch_a1b5g5r5;
    case PIXMAN_x1b5g5r5: return fbFetch_x1b5g5r5;
    case PIXMAN_a4r4g4b4: return fbFetch_a4r4g4b4;
    case PIXMAN_x4r4g4b4: return fbFetch_x4r4g4b4;
    case PIXMAN_a4b4g4r4: return fbFetch_a4b4g4r4;
    case PIXMAN_x4b4g4r4: return fbFetch_x4b4g4r4;

        /* 8bpp formats */
    case PIXMAN_a8: return  fbFetch_a8;
    case PIXMAN_r3g3b2: return fbFetch_r3g3b2;
    case PIXMAN_b2g3r3: return fbFetch_b2g3r3;
    case PIXMAN_a2r2g2b2: return fbFetch_a2r2g2b2;
    case PIXMAN_a2b2g2r2: return fbFetch_a2b2g2r2;
    case PIXMAN_c8: return  fbFetch_c8;
    case PIXMAN_g8: return  fbFetch_c8;
    case PIXMAN_x4a4: return fbFetch_x4a4;

        /* 4bpp formats */
    case PIXMAN_a4: return  fbFetch_a4;
    case PIXMAN_r1g2b1: return fbFetch_r1g2b1;
    case PIXMAN_b1g2r1: return fbFetch_b1g2r1;
    case PIXMAN_a1r1g1b1: return fbFetch_a1r1g1b1;
    case PIXMAN_a1b1g1r1: return fbFetch_a1b1g1r1;
    case PIXMAN_c4: return  fbFetch_c4;
    case PIXMAN_g4: return  fbFetch_c4;

        /* 1bpp formats */
    case PIXMAN_a1: return  fbFetch_a1;
    case PIXMAN_g1: return  fbFetch_g1;

        /* YUV formats */
    case PIXMAN_yuy2: return fbFetch_yuy2;
    case PIXMAN_yv12: return fbFetch_yv12;
    }

    return NULL;
}

static FASTCALL void
fbFetch64_generic (bits_image_t *pict, int x, int y, int width, uint64_t *buffer)
{
    fetchProc32 fetch32 = ACCESS(pixman_fetchProcForPicture32) (pict);

    // Fetch the pixels into the first half of buffer and then expand them in
    // place.
    fetch32(pict, x, y, width, (uint32_t*)buffer);
    pixman_expand(buffer, (uint32_t*)buffer, pict->format, width);
}

fetchProc64 ACCESS(pixman_fetchProcForPicture64) (bits_image_t * pict)
{
    switch(pict->format) {
    case PIXMAN_a2b10g10r10: return fbFetch_a2b10g10r10;
    case PIXMAN_x2b10g10r10: return fbFetch_x2b10g10r10;
    default: return fbFetch64_generic;
    }
d1164 18
a1181 1
/**************************** Pixel wise fetching *****************************/
d1183 5
a1187 2
static FASTCALL uint64_t
fbFetchPixel_a2b10g10r10 (bits_image_t *pict, int offset, int line)
d1189 2
a1190 2
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t p = READ(pict, bits + offset);
d1195 1
a1195 1

d1199 2
a1200 2

    a <<= 62;
d1204 1
a1204 1

d1208 5
a1212 2
static FASTCALL uint64_t
fbFetchPixel_x2b10g10r10 (bits_image_t *pict, int offset, int line)
d1214 2
a1215 2
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t p = READ(pict, bits + offset);
d1219 1
a1219 1

d1223 1
a1223 1

d1227 4
a1230 2
static FASTCALL uint32_t
fbFetchPixel_a8r8g8b8 (bits_image_t *pict, int offset, int line)
d1232 2
a1233 2
    uint32_t *bits = pict->bits + line*pict->rowstride;
    return READ(pict, (uint32_t *)bits + offset);
d1236 4
a1239 2
static FASTCALL uint32_t
fbFetchPixel_x8r8g8b8 (bits_image_t *pict, int offset, int line)
d1241 3
a1243 2
    uint32_t *bits = pict->bits + line*pict->rowstride;
    return READ(pict, (uint32_t *)bits + offset) | 0xff000000;
d1246 4
a1249 2
static FASTCALL uint32_t
fbFetchPixel_a8b8g8r8 (bits_image_t *pict, int offset, int line)
d1251 3
a1253 3
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint32_t *)bits + offset);

d1260 8
a1267 6
static FASTCALL uint32_t
fbFetchPixel_x8b8g8r8 (bits_image_t *pict, int offset, int line)
{
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint32_t *)bits + offset);

d1274 8
a1281 6
static FASTCALL uint32_t
fbFetchPixel_b8g8r8a8 (bits_image_t *pict, int offset, int line)
{
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint32_t *)bits + offset);

d1288 8
a1295 6
static FASTCALL uint32_t
fbFetchPixel_b8g8r8x8 (bits_image_t *pict, int offset, int line)
{
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint32_t *)bits + offset);

d1302 9
a1310 6
static FASTCALL uint32_t
fbFetchPixel_r8g8b8 (bits_image_t *pict, int offset, int line)
{
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint8_t   *pixel = ((uint8_t *) bits) + (offset*3);
#if IMAGE_BYTE_ORDER == MSBFirst
d1312 3
a1314 3
	    (READ(pict, pixel + 0) << 16) |
	    (READ(pict, pixel + 1) << 8) |
	    (READ(pict, pixel + 2)));
d1317 3
a1319 3
	    (READ(pict, pixel + 2) << 16) |
	    (READ(pict, pixel + 1) << 8) |
	    (READ(pict, pixel + 0)));
d1323 8
a1330 6
static FASTCALL uint32_t
fbFetchPixel_b8g8r8 (bits_image_t *pict, int offset, int line)
{
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint8_t   *pixel = ((uint8_t *) bits) + (offset*3);
#if IMAGE_BYTE_ORDER == MSBFirst
d1332 3
a1334 3
	    (READ(pict, pixel + 2) << 16) |
	    (READ(pict, pixel + 1) << 8) |
	    (READ(pict, pixel + 0)));
d1337 3
a1339 3
	    (READ(pict, pixel + 0) << 16) |
	    (READ(pict, pixel + 1) << 8) |
	    (READ(pict, pixel + 2)));
d1343 9
a1351 7
static FASTCALL uint32_t
fbFetchPixel_r5g6b5 (bits_image_t *pict, int offset, int line)
{
    uint32_t  r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint16_t *) bits + offset);

d1355 1
d1359 9
a1367 7
static FASTCALL uint32_t
fbFetchPixel_b5g6r5 (bits_image_t *pict, int offset, int line)
{
    uint32_t  r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint16_t *) bits + offset);

d1371 1
d1375 9
a1383 7
static FASTCALL uint32_t
fbFetchPixel_a1r5g5b5 (bits_image_t *pict, int offset, int line)
{
    uint32_t  a,r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint16_t *) bits + offset);

d1388 1
d1392 9
a1400 7
static FASTCALL uint32_t
fbFetchPixel_x1r5g5b5 (bits_image_t *pict, int offset, int line)
{
    uint32_t  r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint16_t *) bits + offset);

d1404 1
d1408 9
a1416 7
static FASTCALL uint32_t
fbFetchPixel_a1b5g5r5 (bits_image_t *pict, int offset, int line)
{
    uint32_t  a,r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint16_t *) bits + offset);

d1421 1
d1425 9
a1433 7
static FASTCALL uint32_t
fbFetchPixel_x1b5g5r5 (bits_image_t *pict, int offset, int line)
{
    uint32_t  r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint16_t *) bits + offset);

d1437 1
d1441 9
a1449 7
static FASTCALL uint32_t
fbFetchPixel_a4r4g4b4 (bits_image_t *pict, int offset, int line)
{
    uint32_t  a,r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint16_t *) bits + offset);

d1454 1
d1458 9
a1466 7
static FASTCALL uint32_t
fbFetchPixel_x4r4g4b4 (bits_image_t *pict, int offset, int line)
{
    uint32_t  r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint16_t *) bits + offset);

d1470 1
d1474 9
a1482 7
static FASTCALL uint32_t
fbFetchPixel_a4b4g4r4 (bits_image_t *pict, int offset, int line)
{
    uint32_t  a,r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint16_t *) bits + offset);

d1487 1
d1491 9
a1499 7
static FASTCALL uint32_t
fbFetchPixel_x4b4g4r4 (bits_image_t *pict, int offset, int line)
{
    uint32_t  r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, (uint16_t *) bits + offset);

d1503 1
d1507 8
a1514 6
static FASTCALL uint32_t
fbFetchPixel_a8 (bits_image_t *pict, int offset, int line)
{
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t   pixel = READ(pict, (uint8_t *) bits + offset);

d1518 17
a1534 9
static FASTCALL uint32_t
fbFetchPixel_r3g3b2 (bits_image_t *pict, int offset, int line)
{
    uint32_t  r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t   pixel = READ(pict, (uint8_t *) bits + offset);

    r = ((pixel & 0xe0) | ((pixel & 0xe0) >> 3) | ((pixel & 0xc0) >> 6)) << 16;
    g = ((pixel & 0x1c) | ((pixel & 0x18) >> 3) | ((pixel & 0x1c) << 3)) << 8;
d1539 1
d1543 12
a1554 10
static FASTCALL uint32_t
fbFetchPixel_b2g3r3 (bits_image_t *pict, int offset, int line)
{
    uint32_t  r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t   pixel = READ(pict, (uint8_t *) bits + offset);

    b = (((pixel & 0xc0)     ) |
	 ((pixel & 0xc0) >> 2) |
	 ((pixel & 0xc0) >> 4) |
d1556 7
a1562 3
    g = ((pixel & 0x38) | ((pixel & 0x38) >> 3) | ((pixel & 0x30) << 2)) << 8;
    r = (((pixel & 0x07)     ) |
	 ((pixel & 0x07) << 3) |
d1564 1
d1568 9
a1576 7
static FASTCALL uint32_t
fbFetchPixel_a2r2g2b2 (bits_image_t *pict, int offset, int line)
{
    uint32_t   a,r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t   pixel = READ(pict, (uint8_t *) bits + offset);

d1581 2
a1582 1
    return a|r|g|b;
d1585 9
a1593 7
static FASTCALL uint32_t
fbFetchPixel_a2b2g2r2 (bits_image_t *pict, int offset, int line)
{
    uint32_t   a,r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t   pixel = READ(pict, (uint8_t *) bits + offset);

d1598 2
a1599 1
    return a|r|g|b;
d1602 9
a1610 6
static FASTCALL uint32_t
fbFetchPixel_c8 (bits_image_t *pict, int offset, int line)
{
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t   pixel = READ(pict, (uint8_t *) bits + offset);
    const pixman_indexed_t * indexed = pict->indexed;
d1614 8
a1621 6
static FASTCALL uint32_t
fbFetchPixel_x4a4 (bits_image_t *pict, int offset, int line)
{
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t   pixel = READ(pict, (uint8_t *) bits + offset);

d1625 8
a1632 6
static FASTCALL uint32_t
fbFetchPixel_a4 (bits_image_t *pict, int offset, int line)
{
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = Fetch4(pict, bits, offset);

d1637 9
a1645 7
static FASTCALL uint32_t
fbFetchPixel_r1g2b1 (bits_image_t *pict, int offset, int line)
{
    uint32_t  r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = Fetch4(pict, bits, offset);

d1649 2
a1650 1
    return 0xff000000|r|g|b;
d1653 9
a1661 7
static FASTCALL uint32_t
fbFetchPixel_b1g2r1 (bits_image_t *pict, int offset, int line)
{
    uint32_t  r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = Fetch4(pict, bits, offset);

d1665 2
a1666 1
    return 0xff000000|r|g|b;
d1669 9
a1677 7
static FASTCALL uint32_t
fbFetchPixel_a1r1g1b1 (bits_image_t *pict, int offset, int line)
{
    uint32_t  a,r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = Fetch4(pict, bits, offset);

d1682 2
a1683 1
    return a|r|g|b;
d1686 9
a1694 7
static FASTCALL uint32_t
fbFetchPixel_a1b1g1r1 (bits_image_t *pict, int offset, int line)
{
    uint32_t  a,r,g,b;
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = Fetch4(pict, bits, offset);

d1699 2
a1700 1
    return a|r|g|b;
d1703 9
a1711 7
static FASTCALL uint32_t
fbFetchPixel_c4 (bits_image_t *pict, int offset, int line)
{
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = Fetch4(pict, bits, offset);
    const pixman_indexed_t * indexed = pict->indexed;

d1715 4
a1718 3

static FASTCALL uint32_t
fbFetchPixel_a1 (bits_image_t *pict, int offset, int line)
d1720 5
a1724 4
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t  pixel = READ(pict, bits + (offset >> 5));
    uint32_t  a;
#if BITMAP_BIT_ORDER == MSBFirst
d1733 1
d1737 8
a1744 6
static FASTCALL uint32_t
fbFetchPixel_g1 (bits_image_t *pict, int offset, int line)
{
    uint32_t *bits = pict->bits + line*pict->rowstride;
    uint32_t pixel = READ(pict, bits + (offset >> 5));
    const pixman_indexed_t * indexed = pict->indexed;
d1746 2
a1747 1
#if BITMAP_BIT_ORDER == MSBFirst
d1753 1
d1757 4
a1760 2
static FASTCALL uint32_t
fbFetchPixel_yuy2 (bits_image_t *pict, int offset, int line)
d1762 2
d1766 1
a1766 3

    const uint32_t *bits = pict->bits + pict->rowstride * line;

d1768 3
a1770 3
    u = ((uint8_t *) bits)[((offset << 1) & -4) + 1] - 128;
    v = ((uint8_t *) bits)[((offset << 1) & -4) + 3] - 128;

d1773 1
d1776 1
d1779 1
a1779 1

d1786 4
a1789 2
static FASTCALL uint32_t
fbFetchPixel_yv12 (bits_image_t *pict, int offset, int line)
d1791 1
a1791 1
    YV12_SETUP(pict);
d1796 1
a1796 1

d1799 1
d1802 1
d1805 1
a1805 1

d1812 1
a1812 14
/*
 * XXX: The transformed fetch path only works at 32-bpp so far.  When all paths
 * have wide versions, this can be removed.
 *
 * WARNING: This function loses precision!
 */
static FASTCALL uint32_t
fbFetchPixel32_generic_lossy (bits_image_t *pict, int offset, int line)
{
    fetchPixelProc64 fetchPixel64 = ACCESS(pixman_fetchPixelProcForPicture64) (pict);
    const uint64_t argb16Pixel = fetchPixel64(pict, offset, line);
    uint32_t argb8Pixel;

    pixman_contract(&argb8Pixel, &argb16Pixel, 1);
d1814 17
a1830 4
    return argb8Pixel;
}

fetchPixelProc32 ACCESS(pixman_fetchPixelProcForPicture32) (bits_image_t * pict)
d1832 12
a1843 54
    switch(pict->format) {
    case PIXMAN_a8r8g8b8: return fbFetchPixel_a8r8g8b8;
    case PIXMAN_x8r8g8b8: return fbFetchPixel_x8r8g8b8;
    case PIXMAN_a8b8g8r8: return fbFetchPixel_a8b8g8r8;
    case PIXMAN_x8b8g8r8: return fbFetchPixel_x8b8g8r8;
    case PIXMAN_b8g8r8a8: return fbFetchPixel_b8g8r8a8;
    case PIXMAN_b8g8r8x8: return fbFetchPixel_b8g8r8x8;
    /* These two require wide compositing */
    case PIXMAN_a2b10g10r10: return fbFetchPixel32_generic_lossy;
    case PIXMAN_x2b10g10r10: return fbFetchPixel32_generic_lossy;

        /* 24bpp formats */
    case PIXMAN_r8g8b8: return fbFetchPixel_r8g8b8;
    case PIXMAN_b8g8r8: return fbFetchPixel_b8g8r8;

        /* 16bpp formats */
    case PIXMAN_r5g6b5: return fbFetchPixel_r5g6b5;
    case PIXMAN_b5g6r5: return fbFetchPixel_b5g6r5;

    case PIXMAN_a1r5g5b5: return fbFetchPixel_a1r5g5b5;
    case PIXMAN_x1r5g5b5: return fbFetchPixel_x1r5g5b5;
    case PIXMAN_a1b5g5r5: return fbFetchPixel_a1b5g5r5;
    case PIXMAN_x1b5g5r5: return fbFetchPixel_x1b5g5r5;
    case PIXMAN_a4r4g4b4: return fbFetchPixel_a4r4g4b4;
    case PIXMAN_x4r4g4b4: return fbFetchPixel_x4r4g4b4;
    case PIXMAN_a4b4g4r4: return fbFetchPixel_a4b4g4r4;
    case PIXMAN_x4b4g4r4: return fbFetchPixel_x4b4g4r4;

        /* 8bpp formats */
    case PIXMAN_a8: return  fbFetchPixel_a8;
    case PIXMAN_r3g3b2: return fbFetchPixel_r3g3b2;
    case PIXMAN_b2g3r3: return fbFetchPixel_b2g3r3;
    case PIXMAN_a2r2g2b2: return fbFetchPixel_a2r2g2b2;
    case PIXMAN_a2b2g2r2: return fbFetchPixel_a2b2g2r2;
    case PIXMAN_c8: return  fbFetchPixel_c8;
    case PIXMAN_g8: return  fbFetchPixel_c8;
    case PIXMAN_x4a4: return fbFetchPixel_x4a4;

        /* 4bpp formats */
    case PIXMAN_a4: return  fbFetchPixel_a4;
    case PIXMAN_r1g2b1: return fbFetchPixel_r1g2b1;
    case PIXMAN_b1g2r1: return fbFetchPixel_b1g2r1;
    case PIXMAN_a1r1g1b1: return fbFetchPixel_a1r1g1b1;
    case PIXMAN_a1b1g1r1: return fbFetchPixel_a1b1g1r1;
    case PIXMAN_c4: return  fbFetchPixel_c4;
    case PIXMAN_g4: return  fbFetchPixel_c4;

        /* 1bpp formats */
    case PIXMAN_a1: return  fbFetchPixel_a1;
    case PIXMAN_g1: return  fbFetchPixel_g1;

        /* YUV formats */
    case PIXMAN_yuy2: return fbFetchPixel_yuy2;
    case PIXMAN_yv12: return fbFetchPixel_yv12;
a1844 2

    return NULL;
d1847 6
a1852 2
static FASTCALL uint64_t
fbFetchPixel64_generic (bits_image_t *pict, int offset, int line)
d1854 11
a1864 15
    fetchPixelProc32 fetchPixel32 = ACCESS(pixman_fetchPixelProcForPicture32) (pict);
    uint32_t argb8Pixel = fetchPixel32(pict, offset, line);
    uint64_t argb16Pixel;

    pixman_expand(&argb16Pixel, &argb8Pixel, pict->format, 1);

    return argb16Pixel;
}

fetchPixelProc64 ACCESS(pixman_fetchPixelProcForPicture64) (bits_image_t * pict)
{
    switch(pict->format) {
    case PIXMAN_a2b10g10r10: return fbFetchPixel_a2b10g10r10;
    case PIXMAN_x2b10g10r10: return fbFetchPixel_x2b10g10r10;
    default: return fbFetchPixel64_generic;
d1868 6
a1873 8
/*********************************** Store ************************************/

#define Splita(v)	uint32_t	a = ((v) >> 24), r = ((v) >> 16) & 0xff, g = ((v) >> 8) & 0xff, b = (v) & 0xff
#define Split(v)	uint32_t	r = ((v) >> 16) & 0xff, g = ((v) >> 8) & 0xff, b = (v) & 0xff

static FASTCALL void
fbStore_a2b10g10r10 (pixman_image_t *image,
		     uint32_t *bits, const uint64_t *values, int x, int width, const pixman_indexed_t * indexed)
d1875 3
d1879 8
a1886 7
    uint32_t *pixel = bits + x;
    for (i = 0; i < width; ++i) {
        WRITE(image, pixel++,
            ((values[i] >> 32) & 0xc0000000) | // A
            ((values[i] >> 38) & 0x3ff) |      // R
            ((values[i] >> 12) & 0xffc00) |    // G
            ((values[i] << 14) & 0x3ff00000)); // B
d1890 6
a1895 3
static FASTCALL void
fbStore_x2b10g10r10 (pixman_image_t *image,
		     uint32_t *bits, const uint64_t *values, int x, int width, const pixman_indexed_t * indexed)
d1897 3
d1901 7
a1907 6
    uint32_t *pixel = bits + x;
    for (i = 0; i < width; ++i) {
        WRITE(image, pixel++,
            ((values[i] >> 38) & 0x3ff) |      // R
            ((values[i] >> 12) & 0xffc00) |    // G
            ((values[i] << 14) & 0x3ff00000)); // B
d1911 19
a1929 10
static FASTCALL void
fbStore_a8r8g8b8 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
{
    MEMCPY_WRAPPED(image, ((uint32_t *)bits) + x, values, width*sizeof(uint32_t));
}

static FASTCALL void
fbStore_x8r8g8b8 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d1931 2
d1934 1
a1934 1
    uint32_t *pixel = (uint32_t *)bits + x;
d1936 1
a1936 1
	WRITE(image, pixel++, values[i] & 0xffffff);
d1939 6
a1944 3
static FASTCALL void
fbStore_a8b8g8r8 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d1946 2
d1949 1
a1949 1
    uint32_t *pixel = (uint32_t *)bits + x;
d1951 6
a1956 1
	WRITE(image, pixel++, (values[i] & 0xff00ff00) | ((values[i] >> 16) & 0xff) | ((values[i] & 0xff) << 16));
d1959 6
a1964 3
static FASTCALL void
fbStore_x8b8g8r8 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d1966 2
d1969 1
a1969 1
    uint32_t *pixel = (uint32_t *)bits + x;
d1971 6
a1976 1
	WRITE(image, pixel++, (values[i] & 0x0000ff00) | ((values[i] >> 16) & 0xff) | ((values[i] & 0xff) << 16));
d1979 6
a1984 3
static FASTCALL void
fbStore_b8g8r8a8 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d1986 2
d1989 1
a1989 1
    uint32_t *pixel = (uint32_t *)bits + x;
d1991 7
a1997 5
	WRITE(image, pixel++,
	    ((values[i] >> 24) & 0x000000ff) |
	    ((values[i] >>  8) & 0x0000ff00) |
	    ((values[i] <<  8) & 0x00ff0000) |
	    ((values[i] << 24) & 0xff000000));
d2000 6
a2005 3
static FASTCALL void
fbStore_b8g8r8x8 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2007 2
d2010 1
a2010 1
    uint32_t *pixel = (uint32_t *)bits + x;
d2012 6
a2017 4
	WRITE(image, pixel++,
	    ((values[i] >>  8) & 0x0000ff00) |
	    ((values[i] <<  8) & 0x00ff0000) |
	    ((values[i] << 24) & 0xff000000));
d2020 6
a2025 4
static FASTCALL void
fbStore_r8g8b8 (pixman_image_t *image,
		uint32_t *bits, const uint32_t *values, int x, int width,
		const pixman_indexed_t * indexed)
d2027 2
d2030 14
a2043 4
    uint8_t *pixel = ((uint8_t *) bits) + 3*x;
    for (i = 0; i < width; ++i) {
	Store24(image, pixel, values[i]);
	pixel += 3;
d2047 6
a2052 3
static FASTCALL void
fbStore_b8g8r8 (pixman_image_t *image,
		uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2054 2
d2057 3
a2059 2
    uint8_t *pixel = ((uint8_t *) bits) + 3*x;
    for (i = 0; i < width; ++i) {
d2061 5
a2065 4
#if IMAGE_BYTE_ORDER == MSBFirst
	WRITE(image, pixel++, Blue(val));
	WRITE(image, pixel++, Green(val));
	WRITE(image, pixel++, Red(val));
d2067 3
a2069 3
	WRITE(image, pixel++, Red(val));
	WRITE(image, pixel++, Green(val));
	WRITE(image, pixel++, Blue(val));
d2074 6
a2079 3
static FASTCALL void
fbStore_r5g6b5 (pixman_image_t *image,
		uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2081 2
d2084 3
a2086 2
    uint16_t *pixel = ((uint16_t *) bits) + x;
    for (i = 0; i < width; ++i) {
d2088 5
a2092 3
	WRITE(image, pixel++, ((s >> 3) & 0x001f) |
	      ((s >> 5) & 0x07e0) |
	      ((s >> 8) & 0xf800));
d2096 6
a2101 3
static FASTCALL void
fbStore_b5g6r5 (pixman_image_t *image,
		uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2103 2
d2106 9
a2114 6
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	Split(values[i]);
	WRITE(image, pixel++, ((b << 8) & 0xf800) |
	      ((g << 3) & 0x07e0) |
	      ((r >> 3)         ));
d2118 6
a2123 3
static FASTCALL void
fbStore_a1r5g5b5 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2125 2
d2128 10
a2137 7
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	Splita(values[i]);
	WRITE(image, pixel++, ((a << 8) & 0x8000) |
	      ((r << 7) & 0x7c00) |
	      ((g << 2) & 0x03e0) |
	      ((b >> 3)         ));
d2141 6
a2146 3
static FASTCALL void
fbStore_x1r5g5b5 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2148 2
d2151 9
a2159 6
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	Split(values[i]);
	WRITE(image, pixel++, ((r << 7) & 0x7c00) |
	      ((g << 2) & 0x03e0) |
	      ((b >> 3)         ));
d2163 6
a2168 3
static FASTCALL void
fbStore_a1b5g5r5 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2170 2
d2173 10
a2182 7
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	Splita(values[i]);
	WRITE(image, pixel++, ((a << 8) & 0x8000) |
	      ((b << 7) & 0x7c00) |
	      ((g << 2) & 0x03e0) |
	      ((r >> 3)         ));
d2186 6
a2191 3
static FASTCALL void
fbStore_x1b5g5r5 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2193 2
d2196 8
a2203 6
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	Split(values[i]);
	WRITE(image, pixel++, ((b << 7) & 0x7c00) |
	      ((g << 2) & 0x03e0) |
	      ((r >> 3)         ));
d2207 6
a2212 3
static FASTCALL void
fbStore_a4r4g4b4 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2214 2
d2217 10
a2226 7
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	Splita(values[i]);
	WRITE(image, pixel++, ((a << 8) & 0xf000) |
	      ((r << 4) & 0x0f00) |
	      ((g     ) & 0x00f0) |
	      ((b >> 4)         ));
d2230 6
a2235 3
static FASTCALL void
fbStore_x4r4g4b4 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2237 2
d2240 9
a2248 6
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	Split(values[i]);
	WRITE(image, pixel++, ((r << 4) & 0x0f00) |
	      ((g     ) & 0x00f0) |
	      ((b >> 4)         ));
d2252 6
a2257 3
static FASTCALL void
fbStore_a4b4g4r4 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2259 2
d2262 8
a2269 7
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	Splita(values[i]);
	WRITE(image, pixel++, ((a << 8) & 0xf000) |
	      ((b << 4) & 0x0f00) |
	      ((g     ) & 0x00f0) |
	      ((r >> 4)         ));
d2273 6
a2278 3
static FASTCALL void
fbStore_x4b4g4r4 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2280 2
d2283 9
a2291 6
    uint16_t  *pixel = ((uint16_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	Split(values[i]);
	WRITE(image, pixel++, ((b << 4) & 0x0f00) |
	      ((g     ) & 0x00f0) |
	      ((r >> 4)         ));
d2295 6
a2300 3
static FASTCALL void
fbStore_a8 (pixman_image_t *image,
	    uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2302 2
d2305 4
a2308 3
    uint8_t   *pixel = ((uint8_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	WRITE(image, pixel++, values[i] >> 24);
d2312 6
a2317 3
static FASTCALL void
fbStore_r3g3b2 (pixman_image_t *image,
		uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2319 2
d2322 9
a2330 7
    uint8_t   *pixel = ((uint8_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	Split(values[i]);
	WRITE(image, pixel++,
	      ((r     ) & 0xe0) |
	      ((g >> 3) & 0x1c) |
	      ((b >> 6)       ));
d2334 6
a2339 3
static FASTCALL void
fbStore_b2g3r3 (pixman_image_t *image,
		uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2341 2
d2344 9
a2352 7
    uint8_t   *pixel = ((uint8_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	Split(values[i]);
	WRITE(image, pixel++,
	      ((b     ) & 0xc0) |
	      ((g >> 2) & 0x38) |
	      ((r >> 5)       ));
d2356 6
a2361 3
static FASTCALL void
fbStore_a2r2g2b2 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2363 2
d2366 10
a2375 7
    uint8_t   *pixel = ((uint8_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	Splita(values[i]);
	WRITE(image, pixel++, ((a     ) & 0xc0) |
	      ((r >> 2) & 0x30) |
	      ((g >> 4) & 0x0c) |
	      ((b >> 6)       ));
d2379 6
a2384 3
static FASTCALL void
fbStore_c8 (pixman_image_t *image,
	    uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2386 2
d2389 10
a2398 3
    uint8_t   *pixel = ((uint8_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	WRITE(image, pixel++, miIndexToEnt24(indexed,values[i]));
d2402 22
a2423 3
static FASTCALL void
fbStore_x4a4 (pixman_image_t *image,
	      uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2425 2
d2428 3
a2430 4
    uint8_t   *pixel = ((uint8_t *) bits) + x;
    for (i = 0; i < width; ++i) {
	WRITE(image, pixel++, values[i] >> 28);
    }
d2433 6
a2438 5
#define Store8(img,l,o,v)  (WRITE(img, (uint8_t *)(l) + ((o) >> 3), (v)))
#if IMAGE_BYTE_ORDER == MSBFirst
#define Store4(img,l,o,v)  Store8(img,l,o,((o) & 4 ?				\
				   (Fetch8(img,l,o) & 0xf0) | (v) :		\
				   (Fetch8(img,l,o) & 0x0f) | ((v) << 4)))
d2440 4
a2443 3
#define Store4(img,l,o,v)  Store8(img,l,o,((o) & 4 ?			       \
				   (Fetch8(img,l,o) & 0x0f) | ((v) << 4) : \
				   (Fetch8(img,l,o) & 0xf0) | (v)))
d2446 6
a2451 3
static FASTCALL void
fbStore_a4 (pixman_image_t *image,
	    uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2453 1
d2455 3
a2457 3
    for (i = 0; i < width; ++i) {
	Store4(image, bits, i + x, values[i]>>28);
    }
d2460 6
a2465 3
static FASTCALL void
fbStore_r1g2b1 (pixman_image_t *image,
		uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2467 1
d2469 6
a2474 4
    for (i = 0; i < width; ++i) {
	uint32_t  pixel;

	Split(values[i]);
d2476 3
a2478 3
		 ((g >> 5) & 0x6) |
		 ((b >> 7)      ));
	Store4(image, bits, i + x, pixel);
d2482 6
a2487 3
static FASTCALL void
fbStore_b1g2r1 (pixman_image_t *image,
		uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2489 1
d2491 6
a2496 4
    for (i = 0; i < width; ++i) {
	uint32_t  pixel;

	Split(values[i]);
d2498 3
a2500 3
		 ((g >> 5) & 0x6) |
		 ((r >> 7)      ));
	Store4(image, bits, i + x, pixel);
d2504 6
a2509 3
static FASTCALL void
fbStore_a1r1g1b1 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2511 1
d2513 6
a2518 3
    for (i = 0; i < width; ++i) {
	uint32_t  pixel;
	Splita(values[i]);
d2520 4
a2523 4
		 ((r >> 5) & 0x4) |
		 ((g >> 6) & 0x2) |
		 ((b >> 7)      ));
	Store4(image, bits, i + x, pixel);
d2527 6
a2532 3
static FASTCALL void
fbStore_a1b1g1r1 (pixman_image_t *image,
		  uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2534 1
d2536 6
a2541 3
    for (i = 0; i < width; ++i) {
	uint32_t  pixel;
	Splita(values[i]);
d2543 4
a2546 4
		 ((b >> 5) & 0x4) |
		 ((g >> 6) & 0x2) |
		 ((r >> 7)      ));
	Store4(image, bits, i + x, pixel);
d2550 6
a2555 3
static FASTCALL void
fbStore_c4 (pixman_image_t *image,
	    uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2557 2
d2560 7
a2566 5
    for (i = 0; i < width; ++i) {
	uint32_t  pixel;

	pixel = miIndexToEnt24(indexed, values[i]);
	Store4(image, bits, i + x, pixel);
d2570 6
a2575 3
static FASTCALL void
fbStore_a1 (pixman_image_t *image,
	    uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2577 1
d2579 14
a2592 6
    for (i = 0; i < width; ++i) {
	uint32_t  *pixel = ((uint32_t *) bits) + ((i+x) >> 5);
	uint32_t  mask = FbStipMask((i+x) & 0x1f, 1);

	uint32_t v = values[i] & 0x80000000 ? mask : 0;
	WRITE(image, pixel, (READ(image, pixel) & ~mask) | v);
d2596 6
a2601 3
static FASTCALL void
fbStore_g1 (pixman_image_t *image,
	    uint32_t *bits, const uint32_t *values, int x, int width, const pixman_indexed_t * indexed)
d2603 2
d2606 14
a2619 6
    for (i = 0; i < width; ++i) {
	uint32_t  *pixel = ((uint32_t *) bits) + ((i+x) >> 5);
	uint32_t  mask = FbStipMask((i+x) & 0x1f, 1);

	uint32_t v = miIndexToEntY24(indexed,values[i]) ? mask : 0;
	WRITE(image, pixel, (READ(image, pixel) & ~mask) | v);
d2623 28
d2652 11
a2662 1
storeProc32 ACCESS(pixman_storeProcForPicture32) (bits_image_t * pict)
d2664 7
a2670 7
    switch(pict->format) {
    case PIXMAN_a8r8g8b8: return fbStore_a8r8g8b8;
    case PIXMAN_x8r8g8b8: return fbStore_x8r8g8b8;
    case PIXMAN_a8b8g8r8: return fbStore_a8b8g8r8;
    case PIXMAN_x8b8g8r8: return fbStore_x8b8g8r8;
    case PIXMAN_b8g8r8a8: return fbStore_b8g8r8a8;
    case PIXMAN_b8g8r8x8: return fbStore_b8g8r8x8;
d2672 10
a2681 3
        /* 24bpp formats */
    case PIXMAN_r8g8b8: return fbStore_r8g8b8;
    case PIXMAN_b8g8r8: return fbStore_b8g8r8;
d2683 1
a2683 37
        /* 16bpp formats */
    case PIXMAN_r5g6b5: return fbStore_r5g6b5;
    case PIXMAN_b5g6r5: return fbStore_b5g6r5;

    case PIXMAN_a1r5g5b5: return fbStore_a1r5g5b5;
    case PIXMAN_x1r5g5b5: return fbStore_x1r5g5b5;
    case PIXMAN_a1b5g5r5: return fbStore_a1b5g5r5;
    case PIXMAN_x1b5g5r5: return fbStore_x1b5g5r5;
    case PIXMAN_a4r4g4b4: return fbStore_a4r4g4b4;
    case PIXMAN_x4r4g4b4: return fbStore_x4r4g4b4;
    case PIXMAN_a4b4g4r4: return fbStore_a4b4g4r4;
    case PIXMAN_x4b4g4r4: return fbStore_x4b4g4r4;

        /* 8bpp formats */
    case PIXMAN_a8: return  fbStore_a8;
    case PIXMAN_r3g3b2: return fbStore_r3g3b2;
    case PIXMAN_b2g3r3: return fbStore_b2g3r3;
    case PIXMAN_a2r2g2b2: return fbStore_a2r2g2b2;
    case PIXMAN_c8: return  fbStore_c8;
    case PIXMAN_g8: return  fbStore_c8;
    case PIXMAN_x4a4: return fbStore_x4a4;

        /* 4bpp formats */
    case PIXMAN_a4: return  fbStore_a4;
    case PIXMAN_r1g2b1: return fbStore_r1g2b1;
    case PIXMAN_b1g2r1: return fbStore_b1g2r1;
    case PIXMAN_a1r1g1b1: return fbStore_a1r1g1b1;
    case PIXMAN_a1b1g1r1: return fbStore_a1b1g1r1;
    case PIXMAN_c4: return  fbStore_c4;
    case PIXMAN_g4: return  fbStore_c4;

        /* 1bpp formats */
    case PIXMAN_a1: return  fbStore_a1;
    case PIXMAN_g1: return  fbStore_g1;
    default:
        return NULL;
    }
d2687 4
a2690 2
 * Contracts a 64bpp image to 32bpp and then stores it using a regular 32-bit
 * store proc.
d2692 9
a2700 7
static FASTCALL void
fbStore64_generic (pixman_image_t *image,
		   uint32_t *bits, const uint64_t *values, int x, int width, const pixman_indexed_t * indexed)
{
    bits_image_t *pict = (bits_image_t*)image;
    storeProc32 store32 = ACCESS(pixman_storeProcForPicture32) (pict);
    uint32_t *argb8Pixels;
d2702 1
a2702 12
    assert(image->common.type == BITS);
    assert(store32);

    argb8Pixels = pixman_malloc_ab (width, sizeof(uint32_t));
    if (!argb8Pixels) return;

    // Contract the scanline.  We could do this in place if values weren't
    // const.
    pixman_contract(argb8Pixels, values, width);
    store32(image, bits, argb8Pixels, x, width, indexed);

    free(argb8Pixels);
d2705 1
a2705 1
storeProc64 ACCESS(pixman_storeProcForPicture64) (bits_image_t * pict)
d2707 145
a2851 4
    switch(pict->format) {
    case PIXMAN_a2b10g10r10: return fbStore_a2b10g10r10;
    case PIXMAN_x2b10g10r10: return fbStore_x2b10g10r10;
    default: return fbStore64_generic;
d2856 5
a2860 5
/*
 * Helper routine to expand a color component from 0 < n <= 8 bits to 16 bits by
 * replication.
 */
static inline uint64_t expand16(const uint8_t val, int nbits)
d2862 5
a2866 2
    // Start out with the high bit of val in the high bit of result.
    uint16_t result = (uint16_t)val << (16 - nbits);
d2868 1
a2868 9
    if (nbits == 0)
        return 0;

    // Copy the bits in result, doubling the number of bits each time, until we
    // fill all 16 bits.
    while (nbits < 16) {
        result |= result >> nbits;
        nbits *= 2;
    }
d2870 2
a2871 12
    return result;
}

/*
 * This function expands images from ARGB8 format to ARGB16.  To preserve
 * precision, it needs to know the original source format.  For example, if the
 * source was PIXMAN_x1r5g5b5 and the red component contained bits 12345, then
 * the expanded value is 12345123.  To correctly expand this to 16 bits, it
 * should be 1234512345123451 and not 1234512312345123.
 */
void pixman_expand(uint64_t *dst, const uint32_t *src,
                   pixman_format_code_t format, int width)
d2873 1
a2873 34
    /*
     * Determine the sizes of each component and the masks and shifts required
     * to extract them from the source pixel.
     */
    const int a_size = PIXMAN_FORMAT_A(format),
              r_size = PIXMAN_FORMAT_R(format),
              g_size = PIXMAN_FORMAT_G(format),
              b_size = PIXMAN_FORMAT_B(format);
    const int a_shift = 32 - a_size,
              r_shift = 24 - r_size,
              g_shift = 16 - g_size,
              b_shift =  8 - b_size;
    const uint8_t a_mask = ~(~0 << a_size),
                  r_mask = ~(~0 << r_size),
                  g_mask = ~(~0 << g_size),
                  b_mask = ~(~0 << b_size);
    int i;

    /* Start at the end so that we can do the expansion in place when src == dst */
    for (i = width - 1; i >= 0; i--)
    {
        const uint32_t pixel = src[i];
        // Extract the components.
        const uint8_t a = (pixel >> a_shift) & a_mask,
                      r = (pixel >> r_shift) & r_mask,
                      g = (pixel >> g_shift) & g_mask,
                      b = (pixel >> b_shift) & b_mask;
        const uint64_t a16 = a_size ? expand16(a, a_size) : 0xffff,
                       r16 = expand16(r, r_size),
                       g16 = expand16(g, g_size),
                       b16 = expand16(b, b_size);

        dst[i] = a16 << 48 | r16 << 32 | g16 << 16 | b16;
    }
d2876 1
a2876 20
/*
 * Contracting is easier than expanding.  We just need to truncate the
 * components.
 */
void pixman_contract(uint32_t *dst, const uint64_t *src, int width)
{
    int i;

    /* Start at the beginning so that we can do the contraction in place when
     * src == dst */
    for (i = 0; i < width; i++)
    {
        const uint8_t a = src[i] >> 56,
                      r = src[i] >> 40,
                      g = src[i] >> 24,
                      b = src[i] >> 8;
        dst[i] = a << 24 | r << 16 | g << 8 | b;
    }
}
#endif // PIXMAN_FB_ACCESSORS
@


1.2
log
@pixman 0.12.0. Tested on a full ports build by naddy@@.
@
text
@d54 1
a54 1
/* Note n trailing semicolon on the above macro; if it's there, then
d123 30
d681 4
a684 4
    WRITE(pict, buffer++, 0xff000000 |
	(r >= 0 ? r < 0x1000000 ? r         & 0xff0000 : 0xff0000 : 0) |
	(g >= 0 ? g < 0x1000000 ? (g >> 8)  & 0x00ff00 : 0x00ff00 : 0) |
	(b >= 0 ? b < 0x1000000 ? (b >> 16) & 0x0000ff : 0x0000ff : 0));
d726 2
d879 24
d1342 2
d1489 27
d1904 2
@


1.1
log
@Update to pixman 0.10, with one small fix to the sse2 test in configure.ac.
@
text
@d5 1
d31 1
d33 1
d37 3
a39 9
#ifdef PIXMAN_FB_ACCESSORS
#define FETCH_PROC_FOR_PICTURE pixman_fetchProcForPicture_accessors
#define FETCH_PIXEL_PROC_FOR_PICTURE pixman_fetchPixelProcForPicture_accessors
#define STORE_PROC_FOR_PICTURE pixman_storeProcForPicture_accessors
#else
#define FETCH_PROC_FOR_PICTURE pixman_fetchProcForPicture
#define FETCH_PIXEL_PROC_FOR_PICTURE pixman_fetchPixelProcForPicture
#define STORE_PROC_FOR_PICTURE pixman_storeProcForPicture
#endif
d123 46
d689 1
a689 1
fetchProc FETCH_PROC_FOR_PICTURE (bits_image_t * pict)
d696 3
d748 20
d770 38
d1261 19
a1279 1
fetchPixelProc FETCH_PIXEL_PROC_FOR_PICTURE (bits_image_t * pict)
d1286 3
d1338 21
d1365 29
d1643 1
a1643 1
	      ((g >> 2) & 0x1c) |
d1812 1
a1812 1
storeProc STORE_PROC_FOR_PICTURE (bits_image_t * pict)
d1862 125
@

