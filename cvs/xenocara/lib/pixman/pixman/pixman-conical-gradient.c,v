head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.16
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.14
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.12
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.10
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.8
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.11.14.13.42.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.05.20.14.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@/*
 * Copyright © 2000 SuSE, Inc.
 * Copyright © 2007 Red Hat, Inc.
 * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
 *             2005 Lars Knoll & Zack Rusin, Trolltech
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdlib.h>
#include <math.h>
#include "pixman-private.h"

static force_inline double
coordinates_to_parameter (double x, double y, double angle)
{
    double t;

    t = atan2 (y, x) + angle;

    while (t < 0)
	t += 2 * M_PI;

    while (t >= 2 * M_PI)
	t -= 2 * M_PI;

    return 1 - t * (1 / (2 * M_PI)); /* Scale t to [0, 1] and
				      * make rotation CCW
				      */
}

static uint32_t *
conical_get_scanline_narrow (pixman_iter_t *iter, const uint32_t *mask)
{
    pixman_image_t *image = iter->image;
    int x = iter->x;
    int y = iter->y;
    int width = iter->width;
    uint32_t *buffer = iter->buffer;

    gradient_t *gradient = (gradient_t *)image;
    conical_gradient_t *conical = (conical_gradient_t *)image;
    uint32_t       *end = buffer + width;
    pixman_gradient_walker_t walker;
    pixman_bool_t affine = TRUE;
    double cx = 1.;
    double cy = 0.;
    double cz = 0.;
    double rx = x + 0.5;
    double ry = y + 0.5;
    double rz = 1.;

    _pixman_gradient_walker_init (&walker, gradient, image->common.repeat);

    if (image->common.transform)
    {
	pixman_vector_t v;

	/* reference point is the center of the pixel */
	v.vector[0] = pixman_int_to_fixed (x) + pixman_fixed_1 / 2;
	v.vector[1] = pixman_int_to_fixed (y) + pixman_fixed_1 / 2;
	v.vector[2] = pixman_fixed_1;

	if (!pixman_transform_point_3d (image->common.transform, &v))
	    return iter->buffer;

	cx = image->common.transform->matrix[0][0] / 65536.;
	cy = image->common.transform->matrix[1][0] / 65536.;
	cz = image->common.transform->matrix[2][0] / 65536.;

	rx = v.vector[0] / 65536.;
	ry = v.vector[1] / 65536.;
	rz = v.vector[2] / 65536.;

	affine =
	    image->common.transform->matrix[2][0] == 0 &&
	    v.vector[2] == pixman_fixed_1;
    }

    if (affine)
    {
	rx -= conical->center.x / 65536.;
	ry -= conical->center.y / 65536.;

	while (buffer < end)
	{
	    if (!mask || *mask++)
	    {
		double t = coordinates_to_parameter (rx, ry, conical->angle);

		*buffer = _pixman_gradient_walker_pixel (
		    &walker, (pixman_fixed_48_16_t)pixman_double_to_fixed (t));
	    }

	    ++buffer;

	    rx += cx;
	    ry += cy;
	}
    }
    else
    {
	while (buffer < end)
	{
	    double x, y;

	    if (!mask || *mask++)
	    {
		double t;

		if (rz != 0)
		{
		    x = rx / rz;
		    y = ry / rz;
		}
		else
		{
		    x = y = 0.;
		}

		x -= conical->center.x / 65536.;
		y -= conical->center.y / 65536.;

		t = coordinates_to_parameter (x, y, conical->angle);

		*buffer = _pixman_gradient_walker_pixel (
		    &walker, (pixman_fixed_48_16_t)pixman_double_to_fixed (t));
	    }

	    ++buffer;

	    rx += cx;
	    ry += cy;
	    rz += cz;
	}
    }

    iter->y++;
    return iter->buffer;
}

static uint32_t *
conical_get_scanline_wide (pixman_iter_t *iter, const uint32_t *mask)
{
    uint32_t *buffer = conical_get_scanline_narrow (iter, NULL);

    pixman_expand_to_float (
	(argb_t *)buffer, buffer, PIXMAN_a8r8g8b8, iter->width);

    return buffer;
}

void
_pixman_conical_gradient_iter_init (pixman_image_t *image, pixman_iter_t *iter)
{
    if (iter->iter_flags & ITER_NARROW)
	iter->get_scanline = conical_get_scanline_narrow;
    else
	iter->get_scanline = conical_get_scanline_wide;
}

PIXMAN_EXPORT pixman_image_t *
pixman_image_create_conical_gradient (const pixman_point_fixed_t *  center,
                                      pixman_fixed_t                angle,
                                      const pixman_gradient_stop_t *stops,
                                      int                           n_stops)
{
    pixman_image_t *image = _pixman_image_allocate ();
    conical_gradient_t *conical;

    if (!image)
	return NULL;

    conical = &image->conical;

    if (!_pixman_init_gradient (&conical->common, stops, n_stops))
    {
	free (image);
	return NULL;
    }

    angle = MOD (angle, pixman_int_to_fixed (360));

    image->type = CONICAL;

    conical->center = *center;
    conical->angle = (pixman_fixed_to_double (angle) / 180.0) * M_PI;

    return image;
}

@


1.5
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d168 2
a169 1
    pixman_expand ((uint64_t *)buffer, buffer, PIXMAN_a8r8g8b8, iter->width);
d177 1
a177 1
    if (iter->flags & ITER_NARROW)
d184 1
a184 1
pixman_image_create_conical_gradient (pixman_point_fixed_t *        center,
@


1.4
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@d53 2
a54 7
static void
conical_gradient_get_scanline_32 (pixman_image_t *image,
                                  int             x,
                                  int             y,
                                  int             width,
                                  uint32_t *      buffer,
                                  const uint32_t *mask)
d56 7
a62 2
    source_image_t *source = (source_image_t *)image;
    gradient_t *gradient = (gradient_t *)source;
d74 1
a74 1
    _pixman_gradient_walker_init (&walker, gradient, source->common.repeat);
d76 1
a76 1
    if (source->common.transform)
d85 2
a86 2
	if (!pixman_transform_point_3d (source->common.transform, &v))
	    return;
d88 3
a90 3
	cx = source->common.transform->matrix[0][0] / 65536.;
	cy = source->common.transform->matrix[1][0] / 65536.;
	cz = source->common.transform->matrix[2][0] / 65536.;
d97 1
a97 1
	    source->common.transform->matrix[2][0] == 0 &&
d158 3
d163 2
a164 2
static void
conical_gradient_property_changed (pixman_image_t *image)
d166 14
a179 2
    image->common.get_scanline_32 = conical_gradient_get_scanline_32;
    image->common.get_scanline_64 = _pixman_image_get_scanline_generic_64;
a207 2

    image->common.property_changed = conical_gradient_property_changed;
@


1.3
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d35 18
d59 1
a59 2
                                  const uint32_t *mask,
                                  uint32_t        mask_bits)
a72 1
    double a = (conical->angle * M_PI) / (180. * 65536);
d91 1
a91 1
	
d95 1
a95 1
	
d108 1
a108 3
	    double angle;

	    if (!mask || *mask++ & mask_bits)
d110 1
a110 1
		pixman_fixed_48_16_t t;
d112 2
a113 4
		angle = atan2 (ry, rx) + a;
		t     = (pixman_fixed_48_16_t) (angle * (65536. / (2 * M_PI)));

		*buffer = _pixman_gradient_walker_pixel (&walker, t);
d117 1
a117 1
	    
a126 1
	    double angle;
d128 1
a128 1
	    if (!mask || *mask++ & mask_bits)
d130 1
a130 1
		pixman_fixed_48_16_t t;
a143 3
		
		angle = atan2 (y, x) + a;
		t     = (pixman_fixed_48_16_t) (angle * (65536. / (2 * M_PI)));
d145 4
a148 1
		*buffer = _pixman_gradient_walker_pixel (&walker, t);
d152 1
a152 1
	    
d187 2
d190 1
d192 1
a192 1
    conical->angle = angle;
@


1.2
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@d26 2
d29 2
d56 1
a56 1
    double a = conical->angle / (180. * 65536);
@


1.1
log
@Update to pixman 0.15.8.
@
text
@d32 7
a38 2
conical_gradient_get_scanline_32 (pixman_image_t *image, int x, int y, int width,
				  uint32_t *buffer, uint32_t *mask, uint32_t maskBits)
d44 1
a44 1
    GradientWalker  walker;
d52 1
a52 1
    double a = conical->angle/(180.*65536);
d55 3
a57 2
    
    if (source->common.transform) {
d59 1
d61 2
a62 2
	v.vector[0] = pixman_int_to_fixed(x) + pixman_fixed_1/2;
	v.vector[1] = pixman_int_to_fixed(y) + pixman_fixed_1/2;
d64 1
d67 4
d72 7
a78 7
	cx = source->common.transform->matrix[0][0]/65536.;
	cy = source->common.transform->matrix[1][0]/65536.;
	cz = source->common.transform->matrix[2][0]/65536.;
	rx = v.vector[0]/65536.;
	ry = v.vector[1]/65536.;
	rz = v.vector[2]/65536.;
	affine = source->common.transform->matrix[2][0] == 0 && v.vector[2] == pixman_fixed_1;
d80 8
a87 6
    
    if (affine) {
	rx -= conical->center.x/65536.;
	ry -= conical->center.y/65536.;
	
	while (buffer < end) {
d89 2
a90 2
	    
	    if (!mask || *mask++ & maskBits)
d92 6
a97 6
		pixman_fixed_48_16_t   t;
		
		angle = atan2(ry, rx) + a;
		t     = (pixman_fixed_48_16_t) (angle * (65536. / (2*M_PI)));
		
		*(buffer) = _pixman_gradient_walker_pixel (&walker, t);
d99 2
a101 1
	    ++buffer;
d105 5
a109 2
    } else {
	while (buffer < end) {
d112 2
a113 2
	    
	    if (!mask || *mask++ & maskBits)
d115 9
a123 6
		pixman_fixed_48_16_t  t;
		
		if (rz != 0) {
		    x = rx/rz;
		    y = ry/rz;
		} else {
d126 3
a128 4
		x -= conical->center.x/65536.;
		y -= conical->center.y/65536.;
		angle = atan2(y, x) + a;
		t     = (pixman_fixed_48_16_t) (angle * (65536. / (2*M_PI)));
d130 4
a133 1
		*(buffer) = _pixman_gradient_walker_pixel (&walker, t);
d135 2
a137 1
	    ++buffer;
d148 2
a149 2
    image->common.get_scanline_32 = (scanFetchProc)conical_gradient_get_scanline_32;
    image->common.get_scanline_64 = (scanFetchProc)_pixman_image_get_scanline_64_generic;
d153 4
a156 4
pixman_image_create_conical_gradient (pixman_point_fixed_t         *center,
				      pixman_fixed_t                angle,
				      const pixman_gradient_stop_t *stops,
				      int                           n_stops)
d158 1
a158 1
    pixman_image_t *image = _pixman_image_allocate();
d160 1
a160 1
    
d163 1
a163 1
    
d165 1
a165 1
    
d171 1
a171 1
    
d175 1
a175 1
    
d177 1
a177 3
    
    conical_gradient_property_changed (image);
    
d180 1
@

