head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.16
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.14
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.12
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.10
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.8
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.14.13.42.49;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.05.20.14.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@/* -*- Mode: c; c-basic-offset: 4; tab-width: 8; indent-tabs-mode: t; -*- */
/*
 * Copyright © 2000 SuSE, Inc.
 * Copyright © 2007 Red Hat, Inc.
 * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
 *             2005 Lars Knoll & Zack Rusin, Trolltech
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdlib.h>
#include "pixman-private.h"

static pixman_bool_t
linear_gradient_is_horizontal (pixman_image_t *image,
			       int             x,
			       int             y,
			       int             width,
			       int             height)
{
    linear_gradient_t *linear = (linear_gradient_t *)image;
    pixman_vector_t v;
    pixman_fixed_32_32_t l;
    pixman_fixed_48_16_t dx, dy;
    double inc;

    if (image->common.transform)
    {
	/* projective transformation */
	if (image->common.transform->matrix[2][0] != 0 ||
	    image->common.transform->matrix[2][1] != 0 ||
	    image->common.transform->matrix[2][2] == 0)
	{
	    return FALSE;
	}

	v.vector[0] = image->common.transform->matrix[0][1];
	v.vector[1] = image->common.transform->matrix[1][1];
	v.vector[2] = image->common.transform->matrix[2][2];
    }
    else
    {
	v.vector[0] = 0;
	v.vector[1] = pixman_fixed_1;
	v.vector[2] = pixman_fixed_1;
    }

    dx = linear->p2.x - linear->p1.x;
    dy = linear->p2.y - linear->p1.y;

    l = dx * dx + dy * dy;

    if (l == 0)
	return FALSE;

    /*
     * compute how much the input of the gradient walked changes
     * when moving vertically through the whole image
     */
    inc = height * (double) pixman_fixed_1 * pixman_fixed_1 *
	(dx * v.vector[0] + dy * v.vector[1]) /
	(v.vector[2] * (double) l);

    /* check that casting to integer would result in 0 */
    if (-1 < inc && inc < 1)
	return TRUE;

    return FALSE;
}

static uint32_t *
linear_get_scanline_narrow (pixman_iter_t  *iter,
			    const uint32_t *mask)
{
    pixman_image_t *image  = iter->image;
    int             x      = iter->x;
    int             y      = iter->y;
    int             width  = iter->width;
    uint32_t *      buffer = iter->buffer;

    pixman_vector_t v, unit;
    pixman_fixed_32_32_t l;
    pixman_fixed_48_16_t dx, dy;
    gradient_t *gradient = (gradient_t *)image;
    linear_gradient_t *linear = (linear_gradient_t *)image;
    uint32_t *end = buffer + width;
    pixman_gradient_walker_t walker;

    _pixman_gradient_walker_init (&walker, gradient, image->common.repeat);

    /* reference point is the center of the pixel */
    v.vector[0] = pixman_int_to_fixed (x) + pixman_fixed_1 / 2;
    v.vector[1] = pixman_int_to_fixed (y) + pixman_fixed_1 / 2;
    v.vector[2] = pixman_fixed_1;

    if (image->common.transform)
    {
	if (!pixman_transform_point_3d (image->common.transform, &v))
	    return iter->buffer;

	unit.vector[0] = image->common.transform->matrix[0][0];
	unit.vector[1] = image->common.transform->matrix[1][0];
	unit.vector[2] = image->common.transform->matrix[2][0];
    }
    else
    {
	unit.vector[0] = pixman_fixed_1;
	unit.vector[1] = 0;
	unit.vector[2] = 0;
    }

    dx = linear->p2.x - linear->p1.x;
    dy = linear->p2.y - linear->p1.y;

    l = dx * dx + dy * dy;

    if (l == 0 || unit.vector[2] == 0)
    {
	/* affine transformation only */
        pixman_fixed_32_32_t t, next_inc;
	double inc;

	if (l == 0 || v.vector[2] == 0)
	{
	    t = 0;
	    inc = 0;
	}
	else
	{
	    double invden, v2;

	    invden = pixman_fixed_1 * (double) pixman_fixed_1 /
		(l * (double) v.vector[2]);
	    v2 = v.vector[2] * (1. / pixman_fixed_1);
	    t = ((dx * v.vector[0] + dy * v.vector[1]) - 
		 (dx * linear->p1.x + dy * linear->p1.y) * v2) * invden;
	    inc = (dx * unit.vector[0] + dy * unit.vector[1]) * invden;
	}
	next_inc = 0;

	if (((pixman_fixed_32_32_t )(inc * width)) == 0)
	{
	    register uint32_t color;

	    color = _pixman_gradient_walker_pixel (&walker, t);
	    while (buffer < end)
		*buffer++ = color;
	}
	else
	{
	    int i;

	    i = 0;
	    while (buffer < end)
	    {
		if (!mask || *mask++)
		{
		    *buffer = _pixman_gradient_walker_pixel (&walker,
							     t + next_inc);
		}
		i++;
		next_inc = inc * i;
		buffer++;
	    }
	}
    }
    else
    {
	/* projective transformation */
        double t;

	t = 0;

	while (buffer < end)
	{
	    if (!mask || *mask++)
	    {
	        if (v.vector[2] != 0)
		{
		    double invden, v2;

		    invden = pixman_fixed_1 * (double) pixman_fixed_1 /
			(l * (double) v.vector[2]);
		    v2 = v.vector[2] * (1. / pixman_fixed_1);
		    t = ((dx * v.vector[0] + dy * v.vector[1]) - 
			 (dx * linear->p1.x + dy * linear->p1.y) * v2) * invden;
		}

		*buffer = _pixman_gradient_walker_pixel (&walker, t);
	    }

	    ++buffer;

	    v.vector[0] += unit.vector[0];
	    v.vector[1] += unit.vector[1];
	    v.vector[2] += unit.vector[2];
	}
    }

    iter->y++;

    return iter->buffer;
}

static uint32_t *
linear_get_scanline_wide (pixman_iter_t *iter, const uint32_t *mask)
{
    uint32_t *buffer = linear_get_scanline_narrow (iter, NULL);

    pixman_expand_to_float (
	(argb_t *)buffer, buffer, PIXMAN_a8r8g8b8, iter->width);

    return buffer;
}

void
_pixman_linear_gradient_iter_init (pixman_image_t *image, pixman_iter_t  *iter)
{
    if (linear_gradient_is_horizontal (
	    iter->image, iter->x, iter->y, iter->width, iter->height))
    {
	if (iter->iter_flags & ITER_NARROW)
	    linear_get_scanline_narrow (iter, NULL);
	else
	    linear_get_scanline_wide (iter, NULL);

	iter->get_scanline = _pixman_iter_get_scanline_noop;
    }
    else
    {
	if (iter->iter_flags & ITER_NARROW)
	    iter->get_scanline = linear_get_scanline_narrow;
	else
	    iter->get_scanline = linear_get_scanline_wide;
    }
}

PIXMAN_EXPORT pixman_image_t *
pixman_image_create_linear_gradient (const pixman_point_fixed_t *  p1,
                                     const pixman_point_fixed_t *  p2,
                                     const pixman_gradient_stop_t *stops,
                                     int                           n_stops)
{
    pixman_image_t *image;
    linear_gradient_t *linear;

    image = _pixman_image_allocate ();

    if (!image)
	return NULL;

    linear = &image->linear;

    if (!_pixman_init_gradient (&linear->common, stops, n_stops))
    {
	free (image);
	return NULL;
    }

    linear->p1 = *p1;
    linear->p2 = *p2;

    image->type = LINEAR;

    return image;
}

@


1.4
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d230 2
a231 1
    pixman_expand ((uint64_t *)buffer, buffer, PIXMAN_a8r8g8b8, iter->width);
d242 1
a242 1
	if (iter->flags & ITER_NARROW)
d251 1
a251 1
	if (iter->flags & ITER_NARROW)
d259 2
a260 2
pixman_image_create_linear_gradient (pixman_point_fixed_t *        p1,
                                     pixman_point_fixed_t *        p2,
@


1.3
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@d34 6
a39 6
static source_image_class_t
linear_gradient_classify (pixman_image_t *image,
                          int             x,
                          int             y,
                          int             width,
                          int             height)
a40 1
    source_image_t *source = (source_image_t *)image;
a45 1
    source_image_class_t class;
d47 1
a47 3
    class = SOURCE_IMAGE_CLASS_UNKNOWN;

    if (source->common.transform)
d50 3
a52 3
	if (source->common.transform->matrix[2][0] != 0 ||
	    source->common.transform->matrix[2][1] != 0 ||
	    source->common.transform->matrix[2][2] == 0)
d54 1
a54 1
	    return class;
d57 3
a59 3
	v.vector[0] = source->common.transform->matrix[0][1];
	v.vector[1] = source->common.transform->matrix[1][1];
	v.vector[2] = source->common.transform->matrix[2][2];
d74 1
a74 1
	return class;	
d86 1
a86 1
	class = SOURCE_IMAGE_CLASS_HORIZONTAL;
d88 1
a88 1
    return class;
d91 3
a93 7
static void
linear_gradient_get_scanline_32 (pixman_image_t *image,
                                 int             x,
                                 int             y,
                                 int             width,
                                 uint32_t *      buffer,
                                 const uint32_t *mask)
d95 6
a104 1
    source_image_t *source = (source_image_t *)image;
d109 1
a109 1
    _pixman_gradient_walker_init (&walker, gradient, source->common.repeat);
d116 1
a116 1
    if (source->common.transform)
d118 6
a123 6
	if (!pixman_transform_point_3d (source->common.transform, &v))
	    return;
	
	unit.vector[0] = source->common.transform->matrix[0][0];
	unit.vector[1] = source->common.transform->matrix[1][0];
	unit.vector[2] = source->common.transform->matrix[2][0];
d219 14
d235 2
a236 2
static void
linear_gradient_property_changed (pixman_image_t *image)
d238 17
a254 2
    image->common.get_scanline_32 = linear_gradient_get_scanline_32;
    image->common.get_scanline_64 = _pixman_image_get_scanline_generic_64;
a282 2
    image->common.classify = linear_gradient_classify;
    image->common.property_changed = linear_gradient_property_changed;
@


1.2
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@d1 1
d41 1
d45 3
a47 3
    pixman_fixed_48_16_t dx, dy, a, b, off;
    pixman_fixed_48_16_t factors[4];
    int i;
d49 1
a49 1
    image->source.class = SOURCE_IMAGE_CLASS_UNKNOWN;
d51 9
a59 4
    dx = linear->p2.x - linear->p1.x;
    dy = linear->p2.y - linear->p1.y;

    l = dx * dx + dy * dy;
d61 3
a63 4
    if (l)
    {
	a = (dx << 32) / l;
	b = (dy << 32) / l;
d67 3
a69 1
	a = b = 0;
d72 2
a73 2
    off = (-a * linear->p1.x
           -b * linear->p1.y) >> 16;
d75 1
a75 15
    for (i = 0; i < 3; i++)
    {
	v.vector[0] = pixman_int_to_fixed ((i % 2) * (width  - 1) + x);
	v.vector[1] = pixman_int_to_fixed ((i / 2) * (height - 1) + y);
	v.vector[2] = pixman_fixed_1;

	if (image->common.transform)
	{
	    if (!pixman_transform_point_3d (image->common.transform, &v))
	    {
		image->source.class = SOURCE_IMAGE_CLASS_UNKNOWN;

		return image->source.class;
	    }
	}
d77 2
a78 2
	factors[i] = ((a * v.vector[0] + b * v.vector[1]) >> 16) + off;
    }
d80 11
a90 4
    if (factors[2] == factors[0])
	image->source.class = SOURCE_IMAGE_CLASS_HORIZONTAL;
    else if (factors[1] == factors[0])
	image->source.class = SOURCE_IMAGE_CLASS_VERTICAL;
d92 1
a92 1
    return image->source.class;
d101 1
a101 2
                                 const uint32_t *mask,
                                 uint32_t        mask_bits)
d105 1
a105 1
    pixman_fixed_48_16_t dx, dy, a, b, off;
d140 1
a140 1
    if (l != 0)
d142 3
a144 9
	a = (dx << 32) / l;
	b = (dy << 32) / l;
	off = (-a * linear->p1.x
	       -b * linear->p1.y) >> 16;
    }

    if (l == 0 || (unit.vector[2] == 0 && v.vector[2] == pixman_fixed_1))
    {
	pixman_fixed_48_16_t inc, t;
d146 1
a146 2
	/* affine transformation only */
	if (l == 0)
d153 8
a160 2
	    t = ((a * v.vector[0] + b * v.vector[1]) >> 16) + off;
	    inc = (a * unit.vector[0] + b * unit.vector[1]) >> 16;
d162 1
d164 1
a164 1
	if (source->class == SOURCE_IMAGE_CLASS_VERTICAL)
d174 4
a177 10
	    if (!mask)
	    {
		while (buffer < end)
		{
		    *buffer++ = _pixman_gradient_walker_pixel (&walker, t);
		    
		    t += inc;
		}
	    }
	    else
d179 1
a179 1
		while (buffer < end)
d181 2
a182 5
		    if (*mask++ & mask_bits)
			*buffer = _pixman_gradient_walker_pixel (&walker, t);

		    buffer++;
		    t += inc;
d184 3
d193 1
a193 13
	pixman_fixed_48_16_t t;

	if (source->class == SOURCE_IMAGE_CLASS_VERTICAL)
	{
	    register uint32_t color;

	    if (v.vector[2] == 0)
	    {
		t = 0;
	    }
	    else
	    {
		pixman_fixed_48_16_t x, y;
d195 1
a195 4
		x = ((pixman_fixed_48_16_t) v.vector[0] << 16) / v.vector[2];
		y = ((pixman_fixed_48_16_t) v.vector[1] << 16) / v.vector[2];
		t = ((a * x + b * y) >> 16) + off;
	    }
d197 1
a197 5
	    color = _pixman_gradient_walker_pixel (&walker, t);
	    while (buffer < end)
		*buffer++ = color;
	}
	else
d199 1
a199 1
	    while (buffer < end)
d201 1
a201 1
		if (!mask || *mask++ & mask_bits)
d203 7
a209 13
		    if (v.vector[2] == 0)
		    {
			t = 0;
		    }
		    else
		    {
			pixman_fixed_48_16_t x, y;
			x = ((pixman_fixed_48_16_t)v.vector[0] << 16) / v.vector[2];
			y = ((pixman_fixed_48_16_t)v.vector[1] << 16) / v.vector[2];
			t = ((a * x + b * y) >> 16) + off;
		    }
		    
		    *buffer = _pixman_gradient_walker_pixel (&walker, t);
d211 2
a212 6
		
		++buffer;
		
		v.vector[0] += unit.vector[0];
		v.vector[1] += unit.vector[1];
		v.vector[2] += unit.vector[2];
d214 6
a239 2
    return_val_if_fail (n_stops >= 2, NULL);

a256 1
    image->source.class = SOURCE_IMAGE_CLASS_UNKNOWN;
@


1.1
log
@Update to pixman 0.15.8.
@
text
@d27 1
d29 1
d33 1
a33 1
static source_pict_class_t
d35 4
a38 4
			  int	          x,
			  int	          y,
			  int	          width,
			  int	          height)
d41 1
a41 1
    pixman_vector_t   v;
d45 2
a46 2
    int	     i;
    
d48 1
a48 1
    
d51 1
d53 1
d63 1
a63 1
    
d65 2
a66 2
	   -b * linear->p1.y) >> 16;
    
d72 1
a72 1
	
d78 1
a78 1
		
d82 1
a82 1
	
d85 1
a85 1
    
d90 1
a90 1
    
d95 7
a101 2
linear_gradient_get_scanline_32 (pixman_image_t *image, int x, int y, int width,
				 uint32_t *buffer, uint32_t *mask, uint32_t maskBits)
d109 3
a111 3
    uint32_t       *end = buffer + width;
    GradientWalker  walker;
    
d113 1
a113 1
    
d115 2
a116 2
    v.vector[0] = pixman_int_to_fixed(x) + pixman_fixed_1/2;
    v.vector[1] = pixman_int_to_fixed(y) + pixman_fixed_1/2;
d118 3
a120 1
    if (source->common.transform) {
d123 1
d127 3
a129 1
    } else {
d134 1
a134 1
    
d137 5
a141 2
    l = dx*dx + dy*dy;
    if (l != 0) {
d144 2
a145 1
	off = (-a*linear->p1.x - b*linear->p1.y)>>16;
d147 3
a149 1
    if (l == 0  || (unit.vector[2] == 0 && v.vector[2] == pixman_fixed_1)) {
d151 1
d153 2
a154 1
	if (l == 0) {
d157 4
a160 2
	} else {
	    t = ((a*v.vector[0] + b*v.vector[1]) >> 16) + off;
d163 1
a163 1
	
d167 2
a168 2
	    
	    color = _pixman_gradient_walker_pixel( &walker, t );
d170 1
a170 1
		*(buffer++) = color;
d174 2
a175 1
	    if (!mask) {
d178 3
a180 3
		    *(buffer) = _pixman_gradient_walker_pixel (&walker, t);
		    buffer += 1;
		    t      += inc;
d182 10
a191 8
	    } else {
		while (buffer < end) {
		    if (*mask++ & maskBits)
		    {
			*(buffer) = _pixman_gradient_walker_pixel (&walker, t);
		    }
		    buffer += 1;
		    t      += inc;
d196 1
a196 1
    else /* projective transformation */
d198 1
d200 1
a200 1
	
d204 1
a204 1
	    
d212 1
a212 1
		
d217 2
a218 2
	    
	    color = _pixman_gradient_walker_pixel( &walker, t );
d220 1
a220 1
		*(buffer++) = color;
d226 1
a226 1
		if (!mask || *mask++ & maskBits)
d228 2
a229 1
		    if (v.vector[2] == 0) {
d231 3
a233 1
		    } else {
d237 1
a237 1
			t = ((a*x + b*y) >> 16) + off;
d239 2
a240 1
		    *(buffer) = _pixman_gradient_walker_pixel (&walker, t);
d242 1
d244 1
d256 2
a257 2
    image->common.get_scanline_32 = (scanFetchProc)linear_gradient_get_scanline_32;
    image->common.get_scanline_64 = (scanFetchProc)_pixman_image_get_scanline_64_generic;
d261 4
a264 4
pixman_image_create_linear_gradient (pixman_point_fixed_t         *p1,
				     pixman_point_fixed_t         *p2,
				     const pixman_gradient_stop_t *stops,
				     int                           n_stops)
d268 1
a268 1
    
d270 3
a272 3
    
    image = _pixman_image_allocate();
    
d275 1
a275 1
    
d277 1
a277 1
    
d283 1
a283 1
    
d286 1
a286 1
    
d291 1
a291 3
    
    linear_gradient_property_changed (image);
    
d294 1
@

