head	1.1;
access;
symbols
	OPENBSD_6_2:1.1.0.20
	OPENBSD_6_2_BASE:1.1
	OPENBSD_6_1:1.1.0.18
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.16
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.14
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.12
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.10
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.8
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.6
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.1
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@#include <math.h>
#include "pixman.h"
#include "gtk-utils.h"

#define F(x)								\
    pixman_double_to_fixed (x)

#define WIDTH 600
#define HEIGHT 300

static uint16_t
convert_to_srgb (uint16_t in)
{
    double d = in * (1/65535.0);
    double a = 0.055;

    if (d < 0.0031308)
	d = 12.92 * d;
    else
	d = (1 + a) * pow (d, 1 / 2.4) - a;

    return (d * 65535.0) + 0.5;
}

static void
convert_color (pixman_color_t *dest_srgb, pixman_color_t *linear)
{
    dest_srgb->alpha = convert_to_srgb (linear->alpha);
    dest_srgb->red = convert_to_srgb (linear->red);
    dest_srgb->green = convert_to_srgb (linear->green);
    dest_srgb->blue = convert_to_srgb (linear->blue);
}

int
main (int argc, char **argv)
{
    static const pixman_trapezoid_t traps[] =
    {
	{ F(10.10), F(280.0),
	  { { F(20.0), F(10.10) },
	    { F(5.3), F(280.0) } },
	  { { F(20.3), F(10.10) },
	    { F(5.6), F(280.0) } }
	},
	{ F(10.10), F(280.0),
	  { { F(40.0), F(10.10) },
	    { F(15.3), F(280.0) } },
	  { { F(41.0), F(10.10) },
	    { F(16.3), F(280.0) } }
	},
	{ F(10.10), F(280.0),
	  { { F(120.0), F(10.10) },
	    { F(5.3), F(280.0) } },
	  { { F(128.3), F(10.10) },
	    { F(6.6), F(280.0) } }
	},
	{ F(10.10), F(280.0),
	  { { F(60.0), F(10.10) },
	    { F(25.3), F(280.0) } },
	  { { F(61.0), F(10.10) },
	    { F(26.3), F(280.0) } }
	},
	{ F(10.10), F(280.0),
	  { { F(90.0), F(10.10) },
	    { F(55.3), F(280.0) } },
	  { { F(93.0), F(10.10) },
	    { F(58.3), F(280.0) } }
	},
	{ F(130.10), F(150.0),
	  { { F(100.0), F(130.10) },
	    { F(250.3), F(150.0) } },
	  { { F(110.0), F(130.10) },
	    { F(260.3), F(150.0) } }
	},
	{ F(170.10), F(240.0),
	  { { F(100.0), F(170.10) },
	    { F(120.3), F(240.0) } },
	  { { F(250.0), F(170.10) },
	    { F(250.3), F(240.0) } }
	},
    };

    pixman_image_t *src, *dest_srgb, *dest_linear;
    pixman_color_t bg = { 0x0000, 0x0000, 0x0000, 0xffff };
    pixman_color_t fg = { 0xffff, 0xffff, 0xffff, 0xffff };
    pixman_color_t fg_srgb;
    uint32_t *d;

    d = malloc (WIDTH * HEIGHT * 4);
    
    dest_srgb = pixman_image_create_bits (
	PIXMAN_a8r8g8b8_sRGB, WIDTH, HEIGHT, d, WIDTH * 4);
    dest_linear = pixman_image_create_bits (
	PIXMAN_a8r8g8b8, WIDTH, HEIGHT, d, WIDTH * 4);
    
    src = pixman_image_create_solid_fill (&bg);
    pixman_image_composite32 (PIXMAN_OP_SRC,
			      src, NULL, dest_srgb,
			      0, 0, 0, 0, 0, 0, WIDTH, HEIGHT);
    
    src = pixman_image_create_solid_fill (&fg);
    
    pixman_composite_trapezoids (PIXMAN_OP_OVER,
				 src, dest_srgb, PIXMAN_a8,
				 0, 0, 10, 10, G_N_ELEMENTS (traps), traps);

    convert_color (&fg_srgb, &fg);
    src = pixman_image_create_solid_fill (&fg_srgb);
    
    pixman_composite_trapezoids (PIXMAN_OP_OVER,
				 src, dest_linear, PIXMAN_a8,
				 0, 0, 310, 10, G_N_ELEMENTS (traps), traps);

    show_image (dest_linear);
    pixman_image_unref(dest_linear);
    free(d);
    
    return 0;
}
@
