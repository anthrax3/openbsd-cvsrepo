head	1.1;
access;
symbols
	OPENBSD_6_2:1.1.0.20
	OPENBSD_6_2_BASE:1.1
	OPENBSD_6_1:1.1.0.18
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.16
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.14
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.12
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.10
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.8
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.6
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.1
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@#include <math.h>

#include "pixman.h"
#include "gtk-utils.h"

static uint32_t
linear_argb_to_premult_argb (float a,
			     float r,
			     float g,
			     float b)
{
    r *= a;
    g *= a;
    b *= a;
    return (uint32_t) (a * 255.0f + 0.5f) << 24
	 | (uint32_t) (r * 255.0f + 0.5f) << 16
	 | (uint32_t) (g * 255.0f + 0.5f) <<  8
	 | (uint32_t) (b * 255.0f + 0.5f) <<  0;
}

static float
lin2srgb (float linear)
{
    if (linear < 0.0031308f)
	return linear * 12.92f;
    else
	return 1.055f * powf (linear, 1.0f/2.4f) - 0.055f;
}

static uint32_t
linear_argb_to_premult_srgb_argb (float a,
				  float r,
				  float g,
				  float b)
{
    r = lin2srgb (r * a);
    g = lin2srgb (g * a);
    b = lin2srgb (b * a);
    return (uint32_t) (a * 255.0f + 0.5f) << 24
	 | (uint32_t) (r * 255.0f + 0.5f) << 16
	 | (uint32_t) (g * 255.0f + 0.5f) <<  8
	 | (uint32_t) (b * 255.0f + 0.5f) <<  0;
}

int
main (int argc, char **argv)
{
#define WIDTH 400
#define HEIGHT 200
    int y, x, p;
    float alpha;
 
    uint32_t *dest = malloc (WIDTH * HEIGHT * 4);
    uint32_t *src1 = malloc (WIDTH * HEIGHT * 4);
    pixman_image_t *dest_img, *src1_img;
   
    dest_img = pixman_image_create_bits (PIXMAN_a8r8g8b8_sRGB,
					 WIDTH, HEIGHT,
					 dest,
					 WIDTH * 4);
    src1_img = pixman_image_create_bits (PIXMAN_a8r8g8b8,
					 WIDTH, HEIGHT,
					 src1,
					 WIDTH * 4);

    for (y = 0; y < HEIGHT; y ++)
    {
	p = WIDTH * y;
	for (x = 0; x < WIDTH; x ++)
	{
	     alpha = (float) x / WIDTH;
	     src1[p + x] = linear_argb_to_premult_argb (alpha, 1, 0, 1);
	     dest[p + x] = linear_argb_to_premult_srgb_argb (1-alpha, 0, 1, 0);
	}
    }
    
    pixman_image_composite (PIXMAN_OP_ADD, src1_img, NULL, dest_img,
			    0, 0, 0, 0, 0, 0, WIDTH, HEIGHT);
    pixman_image_unref (src1_img);
    free (src1);

    show_image (dest_img);
    pixman_image_unref (dest_img);
    free (dest);
    
    return 0;
}
@
