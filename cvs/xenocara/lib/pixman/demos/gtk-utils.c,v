head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.18
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.16
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.14
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.12
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.10
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.8
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.1.0.6
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.06.07.17.18.00;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@#include <gtk/gtk.h>
#include <config.h>
#include "../test/utils.h"
#include "gtk-utils.h"

pixman_image_t *
pixman_image_from_file (const char *filename, pixman_format_code_t format)
{
    GdkPixbuf *pixbuf;
    pixman_image_t *image;
    int width, height;
    uint32_t *data, *d;
    uint8_t *gdk_data;
    int n_channels;
    int j, i;
    int stride;

    if (!(pixbuf = gdk_pixbuf_new_from_file (filename, NULL)))
	return NULL;

    image = NULL;

    width = gdk_pixbuf_get_width (pixbuf);
    height = gdk_pixbuf_get_height (pixbuf);
    n_channels = gdk_pixbuf_get_n_channels (pixbuf);
    gdk_data = gdk_pixbuf_get_pixels (pixbuf);
    stride = gdk_pixbuf_get_rowstride (pixbuf);

    if (!(data = malloc (width * height * sizeof (uint32_t))))
	goto out;

    d = data;
    for (j = 0; j < height; ++j)
    {
	uint8_t *gdk_line = gdk_data;

	for (i = 0; i < width; ++i)
	{
	    int r, g, b, a;
	    uint32_t pixel;

	    r = gdk_line[0];
	    g = gdk_line[1];
	    b = gdk_line[2];

	    if (n_channels == 4)
		a = gdk_line[3];
	    else
		a = 0xff;

	    r = (r * a + 127) / 255;
	    g = (g * a + 127) / 255;
	    b = (b * a + 127) / 255;

	    pixel = (a << 24) | (r << 16) | (g << 8) | b;

	    *d++ = pixel;
	    gdk_line += n_channels;
	}

	gdk_data += stride;
    }

    image = pixman_image_create_bits (
	format, width, height, data, width * 4);

out:
    g_object_unref (pixbuf);
    return image;
}

GdkPixbuf *
pixbuf_from_argb32 (uint32_t *bits,
		    int width,
		    int height,
		    int stride)
{
    GdkPixbuf *pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE,
					8, width, height);
    int p_stride = gdk_pixbuf_get_rowstride (pixbuf);
    guint32 *p_bits = (guint32 *)gdk_pixbuf_get_pixels (pixbuf);
    int i;

    for (i = 0; i < height; ++i)
    {
	uint32_t *src_row = &bits[i * (stride / 4)];
	uint32_t *dst_row = p_bits + i * (p_stride / 4);

	a8r8g8b8_to_rgba_np (dst_row, src_row, width);
    }

    return pixbuf;
}

static gboolean
on_expose (GtkWidget *widget, GdkEventExpose *expose, gpointer data)
{
    pixman_image_t *pimage = data;
    int width = pixman_image_get_width (pimage);
    int height = pixman_image_get_height (pimage);
    int stride = pixman_image_get_stride (pimage);
    cairo_surface_t *cimage;
    cairo_format_t format;
    cairo_t *cr;

    if (pixman_image_get_format (pimage) == PIXMAN_x8r8g8b8)
	format = CAIRO_FORMAT_RGB24;
    else
	format = CAIRO_FORMAT_ARGB32;

    cimage = cairo_image_surface_create_for_data (
	(uint8_t *)pixman_image_get_data (pimage),
	format, width, height, stride);
    
    cr = gdk_cairo_create (widget->window);

    cairo_rectangle (cr, 0, 0, width, height);
    cairo_set_source_surface (cr, cimage, 0, 0);
    cairo_fill (cr);

    cairo_destroy (cr);
    cairo_surface_destroy (cimage);
    
    return TRUE;
}

void
show_image (pixman_image_t *image)
{
    GtkWidget *window;
    int width, height;
    int argc;
    char **argv;
    char *arg0 = g_strdup ("pixman-test-program");
    pixman_format_code_t format;
    pixman_image_t *copy;

    argc = 1;
    argv = (char **)&arg0;

    gtk_init (&argc, &argv);
    
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    width = pixman_image_get_width (image);
    height = pixman_image_get_height (image);

    gtk_window_set_default_size (GTK_WINDOW (window), width, height);

    format = pixman_image_get_format (image);

    /* We always display the image as if it contains sRGB data. That
     * means that no conversion should take place when the image
     * has the a8r8g8b8_sRGB format.
     */
    switch (format)
    {
    case PIXMAN_a8r8g8b8_sRGB:
    case PIXMAN_a8r8g8b8:
    case PIXMAN_x8r8g8b8:
	copy = pixman_image_ref (image);
	break;

    default:
	copy = pixman_image_create_bits (PIXMAN_a8r8g8b8,
					 width, height, NULL, -1);
	pixman_image_composite32 (PIXMAN_OP_SRC,
				  image, NULL, copy,
				  0, 0, 0, 0, 0, 0,
				  width, height);
	break;
    }

    g_signal_connect (window, "expose_event", G_CALLBACK (on_expose), copy);
    g_signal_connect (window, "delete_event", G_CALLBACK (gtk_main_quit), NULL);
    
    gtk_widget_show (window);
    
    gtk_main ();
}
@


1.3
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@d6 66
d98 16
a113 1
    GdkPixbuf *pixbuf = data;
d115 8
a122 6
    gdk_draw_pixbuf (widget->window, NULL,
		     pixbuf, 0, 0, 0, 0,
		     gdk_pixbuf_get_width (pixbuf),
		     gdk_pixbuf_get_height (pixbuf),
		     GDK_RGB_DITHER_NONE,
		     0, 0);
a130 1
    GdkPixbuf *pixbuf;
d151 3
a153 11
    /* Three cases:
     *
     *  - image is a8r8g8b8_sRGB: we will display without modification
     *    under the assumption that the monitor is sRGB
     *
     *  - image is a8r8g8b8: we will display without modification
     *    under the assumption that whoever created the image
     *    probably did it wrong by using sRGB inputs
     *
     *  - other: we will convert to a8r8g8b8 under the assumption that
     *    whoever created the image probably did it wrong.
d159 1
d173 1
a173 5
    pixbuf = pixbuf_from_argb32 (pixman_image_get_data (copy),
				 width, height,
				 pixman_image_get_stride (copy));
    
    g_signal_connect (window, "expose_event", G_CALLBACK (on_expose), pixbuf);
@


1.2
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@a7 1
		    gboolean has_alpha,
d49 1
a49 1
    int width, height, stride;
a52 1
    gboolean has_alpha;
d54 1
a63 1
    stride = pixman_image_get_stride (image);
d66 1
a66 1
    
d68 33
a100 10
    
    if (format == PIXMAN_a8r8g8b8)
	has_alpha = TRUE;
    else if (format == PIXMAN_x8r8g8b8)
	has_alpha = FALSE;
    else
	g_error ("Can't deal with this format: %x\n", format);
    
    pixbuf = pixbuf_from_argb32 (pixman_image_get_data (image), has_alpha,
				 width, height, stride);
@


1.1
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d3 1
a3 3
#include "pixman-private.h"	/* For image->bits.format
				 * FIXME: there should probably be public API for this
				 */
d17 3
a19 3
    int w, h;
    
    for (h = 0; h < height; ++h)
d21 4
a24 29
	for (w = 0; w < width; ++w)
	{
	    uint32_t argb = bits[h * (stride / 4) + w];
	    guint r, g, b, a;
	    char *pb = (char *)p_bits;

	    pb += h * p_stride + w * 4;

	    r = (argb & 0x00ff0000) >> 16;
	    g = (argb & 0x0000ff00) >> 8;
	    b = (argb & 0x000000ff) >> 0;
	    a = has_alpha? (argb & 0xff000000) >> 24 : 0xff;

	    if (a)
	    {
		r = (r * 255) / a;
		g = (g * 255) / a;
		b = (b * 255) / a;
	    }

	    if (r > 255) r = 255;
	    if (g > 255) g = 255;
	    if (b > 255) b = 255;
	    
	    pb[0] = r;
	    pb[1] = g;
	    pb[2] = b;
	    pb[3] = a;
	}
d26 1
a26 1
    
a29 1

d69 1
a69 1
    format = image->bits.format;
@

