head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.20
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.18
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.16
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.14
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.12
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.10
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.8
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.1.0.6
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@#include <gtk/gtk.h>
#include <stdlib.h>
#include <stdio.h>
#include "pixman.h"
#include "gtk-utils.h"
#include "parrot.c"

#define WIDTH	80
#define HEIGHT	80

typedef struct {
    const char *name;
    pixman_op_t op;
} operator_t;

static const operator_t operators[] = {
    { "CLEAR",		PIXMAN_OP_CLEAR },
    { "SRC",		PIXMAN_OP_SRC },
    { "DST",		PIXMAN_OP_DST },
    { "OVER",		PIXMAN_OP_OVER },
    { "OVER_REVERSE",	PIXMAN_OP_OVER_REVERSE },
    { "IN",		PIXMAN_OP_IN },
    { "IN_REVERSE",	PIXMAN_OP_IN_REVERSE },
    { "OUT",		PIXMAN_OP_OUT },
    { "OUT_REVERSE",	PIXMAN_OP_OUT_REVERSE },
    { "ATOP",		PIXMAN_OP_ATOP },
    { "ATOP_REVERSE",	PIXMAN_OP_ATOP_REVERSE },
    { "XOR",		PIXMAN_OP_XOR },
    { "ADD",		PIXMAN_OP_ADD },
    { "SATURATE",	PIXMAN_OP_SATURATE },

    { "MULTIPLY",	PIXMAN_OP_MULTIPLY },
    { "SCREEN",		PIXMAN_OP_SCREEN },
    { "OVERLAY",	PIXMAN_OP_OVERLAY },
    { "DARKEN",		PIXMAN_OP_DARKEN },
    { "LIGHTEN",	PIXMAN_OP_LIGHTEN },
    { "COLOR_DODGE",	PIXMAN_OP_COLOR_DODGE },
    { "COLOR_BURN",	PIXMAN_OP_COLOR_BURN },
    { "HARD_LIGHT",	PIXMAN_OP_HARD_LIGHT },
    { "SOFT_LIGHT",	PIXMAN_OP_SOFT_LIGHT },
    { "DIFFERENCE",	PIXMAN_OP_DIFFERENCE },
    { "EXCLUSION",	PIXMAN_OP_EXCLUSION },
    { "HSL_HUE",	PIXMAN_OP_HSL_HUE },
    { "HSL_SATURATION",	PIXMAN_OP_HSL_SATURATION },
    { "HSL_COLOR",	PIXMAN_OP_HSL_COLOR },
    { "HSL_LUMINOSITY",	PIXMAN_OP_HSL_LUMINOSITY },
};

static uint32_t
reader (const void *src, int size)
{
    switch (size)
    {
    case 1:
	return *(uint8_t *)src;
    case 2:
	return *(uint16_t *)src;
    case 4:
	return *(uint32_t *)src;
    default:
	g_assert_not_reached();
    }
}

static void
writer (void *src, uint32_t value, int size)
{
    switch (size)
    {
    case 1:
	*(uint8_t *)src = value;
	break;

    case 2:
	*(uint16_t *)src = value;
	break;

    case 4:
	*(uint32_t *)src = value;
	break;

    default:
        break;
    }
}

int
main (int argc, char **argv)
{
#define d2f pixman_double_to_fixed

    GtkWidget *window, *swindow;
    GtkWidget *table;
    uint32_t *dest = malloc (WIDTH * HEIGHT * 4);
    uint32_t *src = malloc (WIDTH * HEIGHT * 4);
    pixman_image_t *gradient, *parrot;
    pixman_image_t *dest_img;
    pixman_point_fixed_t p1 = { -10 << 16, 10 << 16 };
    pixman_point_fixed_t p2 = { (WIDTH + 10) << 16, (HEIGHT - 10) << 16 };
    uint16_t alpha = 0xdddd;
    pixman_gradient_stop_t stops[6] =
    {
	{ d2f (0.0), { 0xf2f2, 0x8787, 0x7d7d, alpha } },
	{ d2f (0.22), { 0xf3f3, 0xeaea, 0x8383, alpha } },
	{ d2f (0.42), { 0x6b6b, 0xc0c0, 0x7777, alpha } },
	{ d2f (0.57), { 0x4b4b, 0xc9c9, 0xf5f5, alpha } },
	{ d2f (0.75), { 0x6a6a, 0x7f7f, 0xbebe, alpha } },
	{ d2f (1.0), { 0xeded, 0x8282, 0xb0b0, alpha } },
    };

    int i;

    gtk_init (&argc, &argv);

    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

    gtk_window_set_default_size (GTK_WINDOW (window), 800, 600);

    g_signal_connect (window, "delete-event",
		      G_CALLBACK (gtk_main_quit),
		      NULL);
    table = gtk_table_new (G_N_ELEMENTS (operators) / 6, 6, TRUE);

    gradient = pixman_image_create_linear_gradient (&p1, &p2, stops, G_N_ELEMENTS (stops));
    parrot = pixman_image_create_bits (PIXMAN_a8r8g8b8, WIDTH, HEIGHT, (uint32_t *)parrot_bits, WIDTH * 4);

    pixman_image_set_repeat (gradient, PIXMAN_REPEAT_PAD);

    dest_img = pixman_image_create_bits (PIXMAN_a8r8g8b8,
					 WIDTH, HEIGHT,
					 NULL,
					 WIDTH * 4);
    pixman_image_set_accessors (dest_img, reader, writer);

    for (i = 0; i < G_N_ELEMENTS (operators); ++i)
    {
	GtkWidget *image;
	GdkPixbuf *pixbuf;
	GtkWidget *vbox;
	GtkWidget *label;

	vbox = gtk_vbox_new (FALSE, 0);

	label = gtk_label_new (operators[i].name);
	gtk_box_pack_start (GTK_BOX (vbox), label, FALSE, FALSE, 6);
	gtk_widget_show (label);

	pixman_image_composite (PIXMAN_OP_SRC, gradient, NULL, dest_img,
				0, 0, 0, 0, 0, 0, WIDTH, HEIGHT);
	pixman_image_composite (operators[i].op, parrot, NULL, dest_img,
				0, 0, 0, 0, 0, 0, WIDTH, HEIGHT);
	pixbuf = pixbuf_from_argb32 (pixman_image_get_data (dest_img),
				     WIDTH, HEIGHT, WIDTH * 4);
	image = gtk_image_new_from_pixbuf (pixbuf);
	gtk_box_pack_start (GTK_BOX (vbox), image, FALSE, FALSE, 0);
	gtk_widget_show (image);

	gtk_table_attach_defaults (GTK_TABLE (table), vbox,
				   i % 6, (i % 6) + 1, i / 6, (i / 6) + 1);
	gtk_widget_show (vbox);

	g_object_unref (pixbuf);
    }

    pixman_image_unref (gradient);
    free (src);
    pixman_image_unref (dest_img);
    free (dest);

    swindow = gtk_scrolled_window_new (NULL, NULL);
    gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (swindow),
				    GTK_POLICY_AUTOMATIC,
				    GTK_POLICY_AUTOMATIC);

    gtk_scrolled_window_add_with_viewport (GTK_SCROLLED_WINDOW (swindow), table);
    gtk_widget_show (table);

    gtk_container_add (GTK_CONTAINER (window), swindow);
    gtk_widget_show (swindow);

    gtk_widget_show (window);

    gtk_main ();

    return 0;
}
@


1.2
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@d152 1
a152 1
	pixbuf = pixbuf_from_argb32 (pixman_image_get_data (dest_img), TRUE,
@


1.1
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d6 1
d8 2
a9 2
#define WIDTH	60
#define HEIGHT	60
d91 1
a91 1
    
d96 1
a96 1
    pixman_image_t *src_img;
d98 3
a100 5
    pixman_point_fixed_t p1 = { -10 << 0, 0 };
    pixman_point_fixed_t p2 = { WIDTH << 16, (HEIGHT - 10) << 16 };
    uint16_t full = 0xcfff;
    uint16_t low  = 0x5000;
    uint16_t alpha = 0xffff;
d103 6
a108 6
	{ d2f (0.0), { full, low, low, alpha } },
	{ d2f (0.25), { full, full, low, alpha } },
	{ d2f (0.4), { low, full, low, alpha } },
	{ d2f (0.6), { low, full, full, alpha } },
	{ d2f (0.8), { low, low, full, alpha } },
	{ d2f (1.0), { full, low, full, alpha } },
d118 1
a118 1
    
d124 4
a127 2
    src_img = pixman_image_create_linear_gradient (&p1, &p2, stops,
						   sizeof (stops) / sizeof (stops[0]));
a128 2
    pixman_image_set_repeat (src_img, PIXMAN_REPEAT_PAD);
    
d131 1
a131 1
					 dest,
a140 1
	int j, k;
d148 3
a150 6
	for (j = 0; j < HEIGHT; ++j)
	{
	    for (k = 0; k < WIDTH; ++k)
		dest[j * WIDTH + k] = 0x7f6f6f00;
	}
	pixman_image_composite (operators[i].op, src_img, NULL, dest_img,
d165 1
a165 1
    pixman_image_unref (src_img);
d174 1
a174 1
    
@

