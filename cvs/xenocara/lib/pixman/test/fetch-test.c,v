head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.16
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.14
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.12
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.10
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.8
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.02.28.20.36.12;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.20.14.28;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.08.19.06.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include "utils.h"

#define SIZE 1024

static pixman_indexed_t mono_palette =
{
    0, { 0x00000000, 0x00ffffff },
};


typedef struct {
    pixman_format_code_t format;
    int width, height;
    int stride;
    uint32_t src[SIZE];
    uint32_t dst[SIZE];
    pixman_indexed_t *indexed;
} testcase_t;

static testcase_t testcases[] =
{
    {
	PIXMAN_a8r8g8b8,
	2, 2,
	8,
	{ 0x00112233, 0x44556677,
	  0x8899aabb, 0xccddeeff },
	{ 0x00112233, 0x44556677,
	  0x8899aabb, 0xccddeeff },
	NULL,
    },
    {
	PIXMAN_r8g8b8a8,
	2, 2,
	8,
	{ 0x11223300, 0x55667744,
	  0x99aabb88, 0xddeeffcc },
	{ 0x00112233, 0x44556677,
	  0x8899aabb, 0xccddeeff },
	NULL,
    },
    {
	PIXMAN_g1,
	8, 2,
	4,
#ifdef WORDS_BIGENDIAN
	{
	    0xaa000000,
	    0x55000000
	},
#else
	{
	    0x00000055,
	    0x000000aa
	},
#endif
	{
	    0x00ffffff, 0x00000000, 0x00ffffff, 0x00000000, 0x00ffffff, 0x00000000, 0x00ffffff, 0x00000000,
	    0x00000000, 0x00ffffff, 0x00000000, 0x00ffffff, 0x00000000, 0x00ffffff, 0x00000000, 0x00ffffff
	},
	&mono_palette,
    },
#if 0
    {
	PIXMAN_g8,
	4, 2,
	4,
	{ 0x01234567,
	  0x89abcdef },
	{ 0x00010101, 0x00232323, 0x00454545, 0x00676767,
	  0x00898989, 0x00ababab, 0x00cdcdcd, 0x00efefef, },
    },
#endif
    /* FIXME: make this work on big endian */
    {
	PIXMAN_yv12,
	8, 2,
	8,
#ifdef WORDS_BIGENDIAN
	{
	    0x00ff00ff, 0x00ff00ff,
	    0xff00ff00, 0xff00ff00,
	    0x80ff8000,
	    0x800080ff
	},
#else
	{
	    0xff00ff00, 0xff00ff00,
	    0x00ff00ff, 0x00ff00ff,
	    0x0080ff80,
	    0xff800080
	},
#endif
	{
	    0xff000000, 0xffffffff, 0xffb80000, 0xffffe113,
	    0xff000000, 0xffffffff, 0xff0023ee, 0xff4affff,
	    0xffffffff, 0xff000000, 0xffffe113, 0xffb80000,
	    0xffffffff, 0xff000000, 0xff4affff, 0xff0023ee,
	},
    },
};

int n_test_cases = ARRAY_LENGTH (testcases);


static uint32_t
reader (const void *src, int size)
{
    switch (size)
    {
    case 1:
	return *(uint8_t *)src;
    case 2:
	return *(uint16_t *)src;
    case 4:
	return *(uint32_t *)src;
    default:
	assert(0);
	return 0; /* silence MSVC */
    }
}


static void
writer (void *src, uint32_t value, int size)
{
    switch (size)
    {
    case 1:
	*(uint8_t *)src = value;
	break;
    case 2:
	*(uint16_t *)src = value;
	break;
    case 4:
	*(uint32_t *)src = value;
	break;
    default:
	assert(0);
    }
}


int
main (int argc, char **argv)
{
    uint32_t dst[SIZE];
    pixman_image_t *src_img;
    pixman_image_t *dst_img;
    int i, j, x, y;
    int ret = 0;

    for (i = 0; i < n_test_cases; ++i)
    {
	for (j = 0; j < 2; ++j)
	{
	    src_img = pixman_image_create_bits (testcases[i].format,
						testcases[i].width,
						testcases[i].height,
						testcases[i].src,
						testcases[i].stride);
	    pixman_image_set_indexed(src_img, testcases[i].indexed);

	    dst_img = pixman_image_create_bits (PIXMAN_a8r8g8b8,
						testcases[i].width,
						testcases[i].height,
						dst,
						testcases[i].width*4);

	    if (j)
	    {
		pixman_image_set_accessors (src_img, reader, writer);
		pixman_image_set_accessors (dst_img, reader, writer);
	    }

	    pixman_image_composite (PIXMAN_OP_SRC, src_img, NULL, dst_img,
				    0, 0, 0, 0, 0, 0, testcases[i].width, testcases[i].height);

	    pixman_image_unref (src_img);
	    pixman_image_unref (dst_img);

	    for (y = 0; y < testcases[i].height; ++y)
	    {
		for (x = 0; x < testcases[i].width; ++x)
		{
		    int offset = y * testcases[i].width + x;

		    if (dst[offset] != testcases[i].dst[offset])
		    {
			printf ("test %i%c: pixel mismatch at (x=%d,y=%d): %08x expected, %08x obtained\n",
			        i + 1, 'a' + j,
			        x, y,
			        testcases[i].dst[offset], dst[offset]);
			ret = 1;
		    }
		}
	    }
	}
    }

    return ret;
}
@


1.6
log
@Update to pixman 0.22.4. Tested by shadchin@@, krw@@.
@
text
@a0 4
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

d4 1
a4 1
#include "pixman.h"
d106 1
a106 1
int n_test_cases = sizeof(testcases)/sizeof(testcases[0]);
@


1.5
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d1 4
a8 1
#include <config.h>
@


1.4
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d11 1
a11 1
    .rgba = { 0x00000000, 0x00ffffff },
d27 8
a34 8
	.format = PIXMAN_a8r8g8b8,
	.width = 2, .height = 2,
	.stride = 8,
	.src = { 0x00112233, 0x44556677,
	         0x8899aabb, 0xccddeeff },
	.dst = { 0x00112233, 0x44556677,
	         0x8899aabb, 0xccddeeff },
	.indexed = NULL,
d37 13
a49 3
	.format = PIXMAN_g1,
	.width = 8, .height = 2,
	.stride = 4,
a50 1
	.src =
a55 1
	.src =
a60 1
	.dst =
d65 1
a65 1
	.indexed = &mono_palette,
d69 7
a75 7
	.format = PIXMAN_g8,
	.width = 4, .height = 2,
	.stride = 4,
	.src = { 0x01234567,
	         0x89abcdef },
	.dst = { 0x00010101, 0x00232323, 0x00454545, 0x00676767,
	         0x00898989, 0x00ababab, 0x00cdcdcd, 0x00efefef, },
d80 3
a82 3
	.format = PIXMAN_yv12,
	.width = 8, .height = 2,
	.stride = 8,
a83 1
	.src =
a90 1
	.src =
a97 1
	.dst =
d123 1
@


1.3
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@d9 2
a10 1
pixman_indexed_t mono_pallete = {
d24 2
a25 1
testcase_t testcases[] = {
d30 1
a30 1
	.src = { 0x00112233, 0x44556677, 
d32 1
a32 1
	.dst = { 0x00112233, 0x44556677, 
d41 5
a45 2
	.src = { 0xaa000000,
		 0x55000000 },
d47 5
a51 2
	.src = { 0x00000055, 
	         0x000000aa },
d53 6
a58 3
	.dst = { 0x00ffffff, 0x00000000, 0x00ffffff, 0x00000000, 0x00ffffff, 0x00000000, 0x00ffffff, 0x00000000,
	         0x00000000, 0x00ffffff, 0x00000000, 0x00ffffff, 0x00000000, 0x00ffffff, 0x00000000, 0x00ffffff },
	.indexed = &mono_pallete,
d65 1
a65 1
	.src = { 0x01234567, 
d67 1
a67 1
	.dst = { 0x00010101, 0x00232323, 0x00454545, 0x00676767, 
d77 6
a82 4
	.src = { 0x00ff00ff, 0x00ff00ff, 
	         0xff00ff00, 0xff00ff00, 
	         0x80ff8000, 
		 0x800080ff
d85 7
a91 5
	.src = { 0xff00ff00, 0xff00ff00, 
	         0x00ff00ff, 0x00ff00ff, 
	         0x0080ff80, 
		 0xff800080
	 },
d93 6
a98 5
	.dst = { 
		0xff000000, 0xffffffff, 0xffb80000, 0xffffe113,
		0xff000000, 0xffffffff, 0xff0023ee, 0xff4affff,
		0xffffffff, 0xff000000, 0xffffe113, 0xffb80000,
		0xffffffff, 0xff000000, 0xff4affff, 0xff0023ee,
d103 1
a103 1
const int ntestcases = sizeof(testcases)/sizeof(testcases[0]);
d152 4
a155 2
    for (i = 0; i < ntestcases; ++i) {
	for (j = 0; j < 2; ++j) {
d157 1
a157 1
						testcases[i].width, 
d164 1
a164 1
						testcases[i].width, 
d169 2
a170 1
	    if (j) {
d174 1
a174 1
	    
d182 7
a188 3
		for (x = 0; x < testcases[i].width; ++x) {
		    int offset = y*testcases[i].width + x;
		    if (dst[offset] != testcases[i].dst[offset]) {
d191 1
a191 1
			        x, y, 
d196 1
d199 1
a199 1
    
@


1.2
log
@Update to pixman 0.15.8.
@
text
@d5 1
d38 4
d44 1
d60 1
d65 7
d75 3
a77 1
		 0xff800080},
@


1.1
log
@Update to pixman 0.10, with one small fix to the sse2 test in configure.ac.
@
text
@a5 1

a6 1

@

