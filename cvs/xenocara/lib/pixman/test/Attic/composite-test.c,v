head	1.6;
access;
symbols
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.6
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v0_9_6:1.1.1.1
	xorg:1.1.1
	v0_9_5:1.1.1.1
	pixman:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2011.07.24.13.05.47;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2010.11.14.13.42.50;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.20.14.28;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.03.20.49.00;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.10.03.20.49.00;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@#include <gtk/gtk.h>
#include <stdlib.h>
#include <stdio.h>
#include "pixman.h"
#include "gtk-utils.h"

#define WIDTH	60
#define HEIGHT	60

typedef struct {
    const char *name;
    pixman_op_t op;
} operator_t;

static const operator_t operators[] = {
    { "CLEAR",		PIXMAN_OP_CLEAR },
    { "SRC",		PIXMAN_OP_SRC },
    { "DST",		PIXMAN_OP_DST },
    { "OVER",		PIXMAN_OP_OVER },
    { "OVER_REVERSE",	PIXMAN_OP_OVER_REVERSE },
    { "IN",		PIXMAN_OP_IN },
    { "IN_REVERSE",	PIXMAN_OP_IN_REVERSE },
    { "OUT",		PIXMAN_OP_OUT },
    { "OUT_REVERSE",	PIXMAN_OP_OUT_REVERSE },
    { "ATOP",		PIXMAN_OP_ATOP },
    { "ATOP_REVERSE",	PIXMAN_OP_ATOP_REVERSE },
    { "XOR",		PIXMAN_OP_XOR },
    { "ADD",		PIXMAN_OP_ADD },
    { "SATURATE",	PIXMAN_OP_SATURATE },

    { "MULTIPLY",	PIXMAN_OP_MULTIPLY },
    { "SCREEN",		PIXMAN_OP_SCREEN },
    { "OVERLAY",	PIXMAN_OP_OVERLAY },
    { "DARKEN",		PIXMAN_OP_DARKEN },
    { "LIGHTEN",	PIXMAN_OP_LIGHTEN },
    { "COLOR_DODGE",	PIXMAN_OP_COLOR_DODGE },
    { "COLOR_BURN",	PIXMAN_OP_COLOR_BURN },
    { "HARD_LIGHT",	PIXMAN_OP_HARD_LIGHT },
    { "SOFT_LIGHT",	PIXMAN_OP_SOFT_LIGHT },
    { "DIFFERENCE",	PIXMAN_OP_DIFFERENCE },
    { "EXCLUSION",	PIXMAN_OP_EXCLUSION },
    { "HSL_HUE",	PIXMAN_OP_HSL_HUE },
    { "HSL_SATURATION",	PIXMAN_OP_HSL_SATURATION },
    { "HSL_COLOR",	PIXMAN_OP_HSL_COLOR },
    { "HSL_LUMINOSITY",	PIXMAN_OP_HSL_LUMINOSITY },
};

static uint32_t
reader (const void *src, int size)
{
    switch (size)
    {
    case 1:
	return *(uint8_t *)src;
    case 2:
	return *(uint16_t *)src;
    case 4:
	return *(uint32_t *)src;
    default:
	g_assert_not_reached();
    }
}

static void
writer (void *src, uint32_t value, int size)
{
    switch (size)
    {
    case 1:
	*(uint8_t *)src = value;
	break;

    case 2:
	*(uint16_t *)src = value;
	break;

    case 4:
	*(uint32_t *)src = value;
	break;

    default:
        break;
    }
}

int
main (int argc, char **argv)
{
#define d2f pixman_double_to_fixed
    
    GtkWidget *window, *swindow;
    GtkWidget *table;
    uint32_t *dest = malloc (WIDTH * HEIGHT * 4);
    uint32_t *src = malloc (WIDTH * HEIGHT * 4);
    pixman_image_t *src_img;
    pixman_image_t *dest_img;
    pixman_point_fixed_t p1 = { -10 << 0, 0 };
    pixman_point_fixed_t p2 = { WIDTH << 16, (HEIGHT - 10) << 16 };
    uint16_t full = 0xcfff;
    uint16_t low  = 0x5000;
    uint16_t alpha = 0xffff;
    pixman_gradient_stop_t stops[6] =
    {
	{ d2f (0.0), { full, low, low, alpha } },
	{ d2f (0.25), { full, full, low, alpha } },
	{ d2f (0.4), { low, full, low, alpha } },
	{ d2f (0.6), { low, full, full, alpha } },
	{ d2f (0.8), { low, low, full, alpha } },
	{ d2f (1.0), { full, low, full, alpha } },
    };

    int i;

    gtk_init (&argc, &argv);

    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

    gtk_window_set_default_size (GTK_WINDOW (window), 800, 600);
    
    g_signal_connect (window, "delete-event",
		      G_CALLBACK (gtk_main_quit),
		      NULL);
    table = gtk_table_new (G_N_ELEMENTS (operators) / 6, 6, TRUE);

    src_img = pixman_image_create_linear_gradient (&p1, &p2, stops,
						   sizeof (stops) / sizeof (stops[0]));

    pixman_image_set_repeat (src_img, PIXMAN_REPEAT_PAD);
    
    dest_img = pixman_image_create_bits (PIXMAN_a8r8g8b8,
					 WIDTH, HEIGHT,
					 dest,
					 WIDTH * 4);
    pixman_image_set_accessors (dest_img, reader, writer);

    for (i = 0; i < G_N_ELEMENTS (operators); ++i)
    {
	GtkWidget *image;
	GdkPixbuf *pixbuf;
	GtkWidget *vbox;
	GtkWidget *label;
	int j, k;

	vbox = gtk_vbox_new (FALSE, 0);

	label = gtk_label_new (operators[i].name);
	gtk_box_pack_start (GTK_BOX (vbox), label, FALSE, FALSE, 6);
	gtk_widget_show (label);

	for (j = 0; j < HEIGHT; ++j)
	{
	    for (k = 0; k < WIDTH; ++k)
		dest[j * WIDTH + k] = 0x7f6f6f00;
	}
	pixman_image_composite (operators[i].op, src_img, NULL, dest_img,
				0, 0, 0, 0, 0, 0, WIDTH, HEIGHT);
	pixbuf = pixbuf_from_argb32 (pixman_image_get_data (dest_img), TRUE,
				     WIDTH, HEIGHT, WIDTH * 4);
	image = gtk_image_new_from_pixbuf (pixbuf);
	gtk_box_pack_start (GTK_BOX (vbox), image, FALSE, FALSE, 0);
	gtk_widget_show (image);

	gtk_table_attach_defaults (GTK_TABLE (table), vbox,
				   i % 6, (i % 6) + 1, i / 6, (i / 6) + 1);
	gtk_widget_show (vbox);

	g_object_unref (pixbuf);
    }

    pixman_image_unref (src_img);
    free (src);
    pixman_image_unref (dest_img);
    free (dest);

    swindow = gtk_scrolled_window_new (NULL, NULL);
    gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (swindow),
				    GTK_POLICY_AUTOMATIC,
				    GTK_POLICY_AUTOMATIC);
    
    gtk_scrolled_window_add_with_viewport (GTK_SCROLLED_WINDOW (swindow), table);
    gtk_widget_show (table);

    gtk_container_add (GTK_CONTAINER (window), swindow);
    gtk_widget_show (swindow);

    gtk_widget_show (window);

    gtk_main ();

    return 0;
}
@


1.5
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@@


1.4
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d107 1
a107 1
	{ d2f (0.5), { low, full, full, alpha } },
d111 1
a111 2
	
	    
@


1.3
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@d5 1
a5 1
#include "utils.h"
d80 3
d119 1
a119 1
    gtk_window_set_default_size (window, 800, 600);
@


1.2
log
@Update to pixman 0.15.8.
@
text
@d1 1
d7 40
a46 2
#define WIDTH	100
#define HEIGHT	100
d86 5
a91 1
    uint32_t *dest = malloc (WIDTH * HEIGHT * 4);
d94 16
d112 3
a114 2
    for (i = 0; i < WIDTH * HEIGHT; ++i)
	src[i] = 0x7f7f0000; /* red */
d116 1
a116 2
    for (i = 0; i < WIDTH * HEIGHT; ++i)
	dest[i] = 0x7f00007f; /* blue */
d118 4
a121 4
    src_img = pixman_image_create_bits (PIXMAN_a8r8g8b8,
					WIDTH, HEIGHT,
					src,
					WIDTH * 4);
d123 5
d132 32
d165 2
a166 5
    pixman_image_set_accessors (src_img, reader, writer);
    pixman_image_set_accessors (dest_img, reader, writer);
    
    pixman_image_composite (PIXMAN_OP_OVER, src_img, NULL, dest_img,
			    0, 0, 0, 0, 0, 0, WIDTH, HEIGHT);
a167 2
    show_image (dest_img);
    
d169 1
a170 1
    free (src);
d172 5
d178 10
@


1.1
log
@Initial revision
@
text
@d4 1
a4 61

#include <gtk/gtk.h>

static GdkPixbuf *
pixbuf_from_argb32 (uint32_t *bits,
		    int width,
		    int height,
		    int stride)
{
    GdkPixbuf *pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE,
					8, width, height);
    int p_stride = gdk_pixbuf_get_rowstride (pixbuf);
    guint32 *p_bits = (guint32 *)gdk_pixbuf_get_pixels (pixbuf);
    int w, h;

    for (h = 0; h < height; ++h)
    {
	for (w = 0; w < width; ++w)
	{
	    uint32_t argb = bits[h * stride + w];
	    guint32 rgba;

	    rgba = (argb << 8) | (argb >> 24);

	    p_bits[h * (p_stride / 4) + w] = rgba;
	}
    }

    return pixbuf;
}

static gboolean
on_expose (GtkWidget *widget, GdkEventExpose *expose, gpointer data)
{
    GdkPixbuf *pixbuf = data;
    
    gdk_draw_pixbuf (widget->window, NULL,
		     pixbuf, 0, 0, 0, 0,
		     gdk_pixbuf_get_width (pixbuf),
		     gdk_pixbuf_get_height (pixbuf),
		     GDK_RGB_DITHER_NONE,
		     0, 0);

    return TRUE;
}

static void
show_window (uint32_t *bits, int w, int h, int stride)
{
    GdkPixbuf *pixbuf;

    GtkWidget *window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

    pixbuf = pixbuf_from_argb32 (bits, w, h, stride);

    g_signal_connect (window, "expose_event", G_CALLBACK (on_expose), pixbuf);
    
    gtk_widget_show (window);

    gtk_main ();
}
d51 1
a51 2
    int i, j;
    gtk_init (&argc, &argv);
d57 1
a57 1
	dest[i] = 0x7f0000ff; /* blue */
d75 1
a75 10
#if 0
    for (i = 0; i < WIDTH; ++i)
    {
	for (j = 0; j < HEIGHT; ++j)
	    g_print ("%x, ", dest[i * WIDTH + j]);
	g_print ("\n");
    }
#endif
    
    show_window (dest, WIDTH, HEIGHT, WIDTH);
a80 2


@


1.1.1.1
log
@import pixman 0.9.5
@
text
@@
