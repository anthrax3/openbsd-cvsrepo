head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.18
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.16
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.14
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.12
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.10
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.8
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.0.8
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.6
	OPENBSD_5_0:1.1.0.4
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.2
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.11.14.13.42.50;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@#include <assert.h>
#include "utils.h"

/* Pixman had a bug where 32bit regions where clipped to 16bit sizes when
 * pixman_region32_translate() was called. This test exercises that bug.
 */

#define LARGE 32000

int
main (int argc, char **argv)
{
  pixman_box32_t rect = { -LARGE, -LARGE, LARGE, LARGE };
  pixman_region32_t r1, r2;

  pixman_region32_init_rects (&r1, &rect, 1);
  pixman_region32_init_rect (&r2, rect.x1, rect.y1, rect.x2 - rect.x1, rect.y2 - rect.y1);

  assert (pixman_region32_equal (&r1,  &r2));

  pixman_region32_translate (&r1, -LARGE, LARGE);
  pixman_region32_translate (&r1, LARGE, -LARGE);

  assert (pixman_region32_equal (&r1,  &r2));

  pixman_region32_fini (&r1);
  pixman_region32_fini (&r2);

  return 0;
}
@


1.1
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@a0 1
#include <pixman.h>
d2 1
@

