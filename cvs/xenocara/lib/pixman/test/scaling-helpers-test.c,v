head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.18
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.16
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.14
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.12
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.10
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.8
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.6
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2013.06.07.17.18.01;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2012.02.28.20.36.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include "utils.h"
#include "pixman-inlines.h"

/* A trivial reference implementation for
 * 'bilinear_pad_repeat_get_scanline_bounds'
 */
static void
bilinear_pad_repeat_get_scanline_bounds_ref (int32_t        source_image_width,
					     pixman_fixed_t vx_,
					     pixman_fixed_t unit_x,
					     int32_t *      left_pad,
					     int32_t *      left_tz,
					     int32_t *      width,
					     int32_t *      right_tz,
					     int32_t *      right_pad)
{
    int w = *width;
    int64_t vx = vx_;
    *left_pad = 0;
    *left_tz = 0;
    *width = 0;
    *right_tz = 0;
    *right_pad = 0;
    while (--w >= 0)
    {
	if (vx < 0)
	{
	    if (vx + pixman_fixed_1 < 0)
		*left_pad += 1;
	    else
		*left_tz += 1;
	}
	else if (vx + pixman_fixed_1 >= pixman_int_to_fixed (source_image_width))
	{
	    if (vx >= pixman_int_to_fixed (source_image_width))
		*right_pad += 1;
	    else
		*right_tz += 1;
	}
	else
	{
	    *width += 1;
	}
	vx += unit_x;
    }
}

int
main (void)
{
    int i;
    prng_srand (0);
    for (i = 0; i < 10000; i++)
    {
	int32_t left_pad1, left_tz1, width1, right_tz1, right_pad1;
	int32_t left_pad2, left_tz2, width2, right_tz2, right_pad2;
	pixman_fixed_t vx = prng_rand_n(10000 << 16) - (3000 << 16);
	int32_t width = prng_rand_n(10000);
	int32_t source_image_width = prng_rand_n(10000) + 1;
	pixman_fixed_t unit_x = prng_rand_n(10 << 16) + 1;
	width1 = width2 = width;

	bilinear_pad_repeat_get_scanline_bounds_ref (source_image_width,
						     vx,
						     unit_x,
						     &left_pad1,
						     &left_tz1,
						     &width1,
						     &right_tz1,
						     &right_pad1);

	bilinear_pad_repeat_get_scanline_bounds (source_image_width,
						 vx,
						 unit_x,
						 &left_pad2,
						 &left_tz2,
						 &width2,
						 &right_tz2,
						 &right_pad2);

	assert (left_pad1 == left_pad2);
	assert (left_tz1 == left_tz2);
	assert (width1 == width2);
	assert (right_tz1 == right_tz2);
	assert (right_pad1 == right_pad2);
    }

    return 0;
}
@


1.2
log
@Update to pixman 0.22.4. Tested by shadchin@@, krw@@.
@
text
@d55 1
d60 4
a63 4
	pixman_fixed_t vx = lcg_rand_N(10000 << 16) - (3000 << 16);
	int32_t width = lcg_rand_N(10000);
	int32_t source_image_width = lcg_rand_N(10000) + 1;
	pixman_fixed_t unit_x = lcg_rand_N(10 << 16) + 1;
@


1.1
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@a0 2
#include <config.h>
#include <stdint.h>
d5 1
a5 1
#include "pixman-fast-path.h"
@

