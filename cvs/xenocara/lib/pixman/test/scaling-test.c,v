head	1.10;
access;
symbols
	OPENBSD_6_0:1.9.0.12
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.10
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.6
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.10.01.10.17.44;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	FGr8CFhVerRlpSoE;

1.9
date	2013.12.01.20.34.20;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.18.01;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.23.20.44.09;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.11.14.13.42.50;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.05.20.14.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to pixman 0.34.0.
@
text
@/*
 * Test program, which can detect some problems with nearest neighbour
 * and bilinear scaling in pixman. Testing is done by running lots
 * of random SRC and OVER compositing operations a8r8g8b8, x8a8r8g8b8
 * and r5g6b5 color formats.
 *
 * Script 'fuzzer-find-diff.pl' can be used to narrow down the problem in
 * the case of test failure.
 */
#include <stdlib.h>
#include <stdio.h>
#include "utils.h"

#define MAX_SRC_WIDTH  48
#define MAX_SRC_HEIGHT 8
#define MAX_DST_WIDTH  48
#define MAX_DST_HEIGHT 8
#define MAX_STRIDE     4

/*
 * Composite operation with pseudorandom images
 */

static pixman_format_code_t
get_format (int bpp)
{
    if (bpp == 4)
    {
	switch (prng_rand_n (4))
	{
	default:
	case 0:
	    return PIXMAN_a8r8g8b8;
	case 1:
	    return PIXMAN_x8r8g8b8;
	case 2:
	    return PIXMAN_a8b8g8r8;
	case 3:
	    return PIXMAN_x8b8g8r8;
	}
    }
    else
    {
	return PIXMAN_r5g6b5;
    }
}

uint32_t
test_composite (int      testnum,
		int      verbose)
{
    int                i;
    pixman_image_t *   src_img;
    pixman_image_t *   mask_img;
    pixman_image_t *   dst_img;
    pixman_transform_t transform;
    pixman_region16_t  clip;
    int                src_width, src_height;
    int                mask_width, mask_height;
    int                dst_width, dst_height;
    int                src_stride, mask_stride, dst_stride;
    int                src_x, src_y;
    int                mask_x, mask_y;
    int                dst_x, dst_y;
    int                src_bpp;
    int                mask_bpp = 1;
    int                dst_bpp;
    int                w, h;
    pixman_fixed_t     scale_x = 65536, scale_y = 65536;
    pixman_fixed_t     translate_x = 0, translate_y = 0;
    pixman_fixed_t     mask_scale_x = 65536, mask_scale_y = 65536;
    pixman_fixed_t     mask_translate_x = 0, mask_translate_y = 0;
    pixman_op_t        op;
    pixman_repeat_t    repeat = PIXMAN_REPEAT_NONE;
    pixman_repeat_t    mask_repeat = PIXMAN_REPEAT_NONE;
    pixman_format_code_t src_fmt, mask_fmt, dst_fmt;
    uint32_t *         srcbuf;
    uint32_t *         dstbuf;
    uint32_t *         maskbuf;
    uint32_t           crc32;
    FLOAT_REGS_CORRUPTION_DETECTOR_START ();

    prng_srand (testnum);

    src_bpp = (prng_rand_n (2) == 0) ? 2 : 4;
    dst_bpp = (prng_rand_n (2) == 0) ? 2 : 4;
    switch (prng_rand_n (3))
    {
    case 0:
	op = PIXMAN_OP_SRC;
	break;
    case 1:
	op = PIXMAN_OP_OVER;
	break;
    default:
	op = PIXMAN_OP_ADD;
	break;
    }

    src_width = prng_rand_n (MAX_SRC_WIDTH) + 1;
    src_height = prng_rand_n (MAX_SRC_HEIGHT) + 1;

    if (prng_rand_n (2))
    {
	mask_width = prng_rand_n (MAX_SRC_WIDTH) + 1;
	mask_height = prng_rand_n (MAX_SRC_HEIGHT) + 1;
    }
    else
    {
	mask_width = mask_height = 1;
    }

    dst_width = prng_rand_n (MAX_DST_WIDTH) + 1;
    dst_height = prng_rand_n (MAX_DST_HEIGHT) + 1;
    src_stride = src_width * src_bpp + prng_rand_n (MAX_STRIDE) * src_bpp;
    mask_stride = mask_width * mask_bpp + prng_rand_n (MAX_STRIDE) * mask_bpp;
    dst_stride = dst_width * dst_bpp + prng_rand_n (MAX_STRIDE) * dst_bpp;

    if (src_stride & 3)
	src_stride += 2;

    if (mask_stride & 1)
	mask_stride += 1;
    if (mask_stride & 2)
	mask_stride += 2;

    if (dst_stride & 3)
	dst_stride += 2;

    src_x = -(src_width / 4) + prng_rand_n (src_width * 3 / 2);
    src_y = -(src_height / 4) + prng_rand_n (src_height * 3 / 2);
    mask_x = -(mask_width / 4) + prng_rand_n (mask_width * 3 / 2);
    mask_y = -(mask_height / 4) + prng_rand_n (mask_height * 3 / 2);
    dst_x = -(dst_width / 4) + prng_rand_n (dst_width * 3 / 2);
    dst_y = -(dst_height / 4) + prng_rand_n (dst_height * 3 / 2);
    w = prng_rand_n (dst_width * 3 / 2 - dst_x);
    h = prng_rand_n (dst_height * 3 / 2 - dst_y);

    srcbuf = (uint32_t *)malloc (src_stride * src_height);
    maskbuf = (uint32_t *)malloc (mask_stride * mask_height);
    dstbuf = (uint32_t *)malloc (dst_stride * dst_height);

    prng_randmemset (srcbuf, src_stride * src_height, 0);
    prng_randmemset (maskbuf, mask_stride * mask_height, 0);
    prng_randmemset (dstbuf, dst_stride * dst_height, 0);

    src_fmt = get_format (src_bpp);
    mask_fmt = PIXMAN_a8;
    dst_fmt = get_format (dst_bpp);

    if (prng_rand_n (2))
    {
	srcbuf += (src_stride / 4) * (src_height - 1);
	src_stride = - src_stride;
    }

    if (prng_rand_n (2))
    {
	maskbuf += (mask_stride / 4) * (mask_height - 1);
	mask_stride = - mask_stride;
    }

    if (prng_rand_n (2))
    {
	dstbuf += (dst_stride / 4) * (dst_height - 1);
	dst_stride = - dst_stride;
    }

    src_img = pixman_image_create_bits (
        src_fmt, src_width, src_height, srcbuf, src_stride);

    mask_img = pixman_image_create_bits (
        mask_fmt, mask_width, mask_height, maskbuf, mask_stride);

    dst_img = pixman_image_create_bits (
        dst_fmt, dst_width, dst_height, dstbuf, dst_stride);

    image_endian_swap (src_img);
    image_endian_swap (dst_img);

    if (prng_rand_n (4) > 0)
    {
	scale_x = -32768 * 3 + prng_rand_n (65536 * 5);
	scale_y = -32768 * 3 + prng_rand_n (65536 * 5);
	translate_x = prng_rand_n (65536);
	translate_y = prng_rand_n (65536);
	pixman_transform_init_scale (&transform, scale_x, scale_y);
	pixman_transform_translate (&transform, NULL, translate_x, translate_y);
	pixman_image_set_transform (src_img, &transform);
    }

    if (prng_rand_n (2) > 0)
    {
	mask_scale_x = -32768 * 3 + prng_rand_n (65536 * 5);
	mask_scale_y = -32768 * 3 + prng_rand_n (65536 * 5);
	mask_translate_x = prng_rand_n (65536);
	mask_translate_y = prng_rand_n (65536);
	pixman_transform_init_scale (&transform, mask_scale_x, mask_scale_y);
	pixman_transform_translate (&transform, NULL, mask_translate_x, mask_translate_y);
	pixman_image_set_transform (mask_img, &transform);
    }

    switch (prng_rand_n (4))
    {
    case 0:
	mask_repeat = PIXMAN_REPEAT_NONE;
	break;

    case 1:
	mask_repeat = PIXMAN_REPEAT_NORMAL;
	break;

    case 2:
	mask_repeat = PIXMAN_REPEAT_PAD;
	break;

    case 3:
	mask_repeat = PIXMAN_REPEAT_REFLECT;
	break;

    default:
        break;
    }
    pixman_image_set_repeat (mask_img, mask_repeat);

    switch (prng_rand_n (4))
    {
    case 0:
	repeat = PIXMAN_REPEAT_NONE;
	break;

    case 1:
	repeat = PIXMAN_REPEAT_NORMAL;
	break;

    case 2:
	repeat = PIXMAN_REPEAT_PAD;
	break;

    case 3:
	repeat = PIXMAN_REPEAT_REFLECT;
	break;

    default:
        break;
    }
    pixman_image_set_repeat (src_img, repeat);

    if (prng_rand_n (2))
	pixman_image_set_filter (src_img, PIXMAN_FILTER_NEAREST, NULL, 0);
    else
	pixman_image_set_filter (src_img, PIXMAN_FILTER_BILINEAR, NULL, 0);

    if (prng_rand_n (2))
	pixman_image_set_filter (mask_img, PIXMAN_FILTER_NEAREST, NULL, 0);
    else
	pixman_image_set_filter (mask_img, PIXMAN_FILTER_BILINEAR, NULL, 0);

    if (prng_rand_n (8) == 0)
    {
	pixman_box16_t clip_boxes[2];
	int            n = prng_rand_n (2) + 1;

	for (i = 0; i < n; i++)
	{
	    clip_boxes[i].x1 = prng_rand_n (src_width);
	    clip_boxes[i].y1 = prng_rand_n (src_height);
	    clip_boxes[i].x2 =
		clip_boxes[i].x1 + prng_rand_n (src_width - clip_boxes[i].x1);
	    clip_boxes[i].y2 =
		clip_boxes[i].y1 + prng_rand_n (src_height - clip_boxes[i].y1);

	    if (verbose)
	    {
		printf ("source clip box: [%d,%d-%d,%d]\n",
		        clip_boxes[i].x1, clip_boxes[i].y1,
		        clip_boxes[i].x2, clip_boxes[i].y2);
	    }
	}

	pixman_region_init_rects (&clip, clip_boxes, n);
	pixman_image_set_clip_region (src_img, &clip);
	pixman_image_set_source_clipping (src_img, 1);
	pixman_region_fini (&clip);
    }

    if (prng_rand_n (8) == 0)
    {
	pixman_box16_t clip_boxes[2];
	int            n = prng_rand_n (2) + 1;

	for (i = 0; i < n; i++)
	{
	    clip_boxes[i].x1 = prng_rand_n (mask_width);
	    clip_boxes[i].y1 = prng_rand_n (mask_height);
	    clip_boxes[i].x2 =
		clip_boxes[i].x1 + prng_rand_n (mask_width - clip_boxes[i].x1);
	    clip_boxes[i].y2 =
		clip_boxes[i].y1 + prng_rand_n (mask_height - clip_boxes[i].y1);

	    if (verbose)
	    {
		printf ("mask clip box: [%d,%d-%d,%d]\n",
		        clip_boxes[i].x1, clip_boxes[i].y1,
		        clip_boxes[i].x2, clip_boxes[i].y2);
	    }
	}

	pixman_region_init_rects (&clip, clip_boxes, n);
	pixman_image_set_clip_region (mask_img, &clip);
	pixman_image_set_source_clipping (mask_img, 1);
	pixman_region_fini (&clip);
    }

    if (prng_rand_n (8) == 0)
    {
	pixman_box16_t clip_boxes[2];
	int            n = prng_rand_n (2) + 1;
	for (i = 0; i < n; i++)
	{
	    clip_boxes[i].x1 = prng_rand_n (dst_width);
	    clip_boxes[i].y1 = prng_rand_n (dst_height);
	    clip_boxes[i].x2 =
		clip_boxes[i].x1 + prng_rand_n (dst_width - clip_boxes[i].x1);
	    clip_boxes[i].y2 =
		clip_boxes[i].y1 + prng_rand_n (dst_height - clip_boxes[i].y1);

	    if (verbose)
	    {
		printf ("destination clip box: [%d,%d-%d,%d]\n",
		        clip_boxes[i].x1, clip_boxes[i].y1,
		        clip_boxes[i].x2, clip_boxes[i].y2);
	    }
	}
	pixman_region_init_rects (&clip, clip_boxes, n);
	pixman_image_set_clip_region (dst_img, &clip);
	pixman_region_fini (&clip);
    }

    if (prng_rand_n (2) == 0)
    {
	mask_fmt = PIXMAN_null;
	pixman_image_unref (mask_img);
	mask_img = NULL;
	mask_x = 0;
	mask_y = 0;
    }

    if (verbose)
    {
	printf ("op=%s, src_fmt=%s, mask_fmt=%s, dst_fmt=%s\n",
	        operator_name (op), format_name (src_fmt),
	        format_name (mask_fmt), format_name (dst_fmt));
	printf ("scale_x=%d, scale_y=%d, repeat=%d, filter=%d\n",
	        scale_x, scale_y, repeat, src_img->common.filter);
	printf ("translate_x=%d, translate_y=%d\n",
	        translate_x, translate_y);
	if (mask_fmt != PIXMAN_null)
	{
	    printf ("mask_scale_x=%d, mask_scale_y=%d, "
	            "mask_repeat=%d, mask_filter=%d\n",
	            mask_scale_x, mask_scale_y, mask_repeat,
	            mask_img->common.filter);
	    printf ("mask_translate_x=%d, mask_translate_y=%d\n",
	            mask_translate_x, mask_translate_y);
	}
	printf ("src_width=%d, src_height=%d, src_x=%d, src_y=%d\n",
	        src_width, src_height, src_x, src_y);
	if (mask_fmt != PIXMAN_null)
	{
	    printf ("mask_width=%d, mask_height=%d, mask_x=%d, mask_y=%d\n",
	            mask_width, mask_height, mask_x, mask_y);
	}
	printf ("dst_width=%d, dst_height=%d, dst_x=%d, dst_y=%d\n",
	        dst_width, dst_height, dst_x, dst_y);
	printf ("w=%d, h=%d\n", w, h);
    }

    pixman_image_composite (op, src_img, mask_img, dst_img,
                            src_x, src_y, mask_x, mask_y, dst_x, dst_y, w, h);

    crc32 = compute_crc32_for_image (0, dst_img);
    
    if (verbose)
	print_image (dst_img);

    pixman_image_unref (src_img);
    if (mask_img != NULL)
	pixman_image_unref (mask_img);
    pixman_image_unref (dst_img);

    if (src_stride < 0)
	srcbuf += (src_stride / 4) * (src_height - 1);

    if (mask_stride < 0)
	maskbuf += (mask_stride / 4) * (mask_height - 1);

    if (dst_stride < 0)
	dstbuf += (dst_stride / 4) * (dst_height - 1);

    free (srcbuf);
    free (maskbuf);
    free (dstbuf);

    FLOAT_REGS_CORRUPTION_DETECTOR_FINISH ();
    return crc32;
}

#if BILINEAR_INTERPOLATION_BITS == 7
#define CHECKSUM 0x92E0F068
#elif BILINEAR_INTERPOLATION_BITS == 4
#define CHECKSUM 0x8EFFA1E5
#else
#define CHECKSUM 0x00000000
#endif

int
main (int argc, const char *argv[])
{
    pixman_disable_out_of_bounds_workaround ();

    return fuzzer_test_main("scaling", 8000000, CHECKSUM,
			    test_composite, argc, argv);
}
@


1.9
log
@Update to pixman 0.32.4. Tested by naddy@@ and ajacoutot@@
@
text
@d76 1
a76 1
    pixman_format_code_t src_fmt, dst_fmt;
d148 1
d173 1
a173 1
        PIXMAN_a8, mask_width, mask_height, maskbuf, mask_stride);
a258 15
    if (verbose)
    {
	printf ("src_fmt=%s, dst_fmt=%s\n", 
		format_name (src_fmt), format_name (dst_fmt));
	printf ("op=%s, scale_x=%d, scale_y=%d, repeat=%d\n",
	        operator_name (op), scale_x, scale_y, repeat);
	printf ("translate_x=%d, translate_y=%d\n",
	        translate_x, translate_y);
	printf ("src_width=%d, src_height=%d, dst_width=%d, dst_height=%d\n",
	        src_width, src_height, dst_width, dst_height);
	printf ("src_x=%d, src_y=%d, dst_x=%d, dst_y=%d\n",
	        src_x, src_y, dst_x, dst_y);
	printf ("w=%d, h=%d\n", w, h);
    }

d341 39
a379 4
	pixman_image_composite (op, src_img, NULL, dst_img,
                            src_x, src_y, 0, 0, dst_x, dst_y, w, h);
    else
	pixman_image_composite (op, src_img, mask_img, dst_img,
d388 2
a389 1
    pixman_image_unref (mask_img);
@


1.8
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@d150 18
d361 2
a362 9
    if (dst_fmt == PIXMAN_x8r8g8b8 || dst_fmt == PIXMAN_x8b8g8r8)
    {
	/* ignore unused part */
	for (i = 0; i < dst_stride * dst_height / 4; i++)
	    dstbuf[i] &= 0xFFFFFF;
    }

    image_endian_swap (dst_img);

d364 1
a364 11
    {
	int j;
	
	for (i = 0; i < dst_height; i++)
	{
	    for (j = 0; j < dst_stride; j++)
		printf ("%02X ", *((uint8_t *)dstbuf + i * dst_stride + j));

	    printf ("\n");
	}
    }
d370 9
a378 1
    crc32 = compute_crc32 (0, dstbuf, dst_stride * dst_height);
d387 2
a388 4
#if BILINEAR_INTERPOLATION_BITS == 8
#define CHECKSUM 0x9096E6B6
#elif BILINEAR_INTERPOLATION_BITS == 7
#define CHECKSUM 0xCE8EC6BA
d390 1
a390 1
#define CHECKSUM 0xAB1D39BE
@


1.7
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@d29 1
a29 1
	switch (lcg_rand_n (4))
d83 1
a83 1
    lcg_srand (testnum);
d85 3
a87 3
    src_bpp = (lcg_rand_n (2) == 0) ? 2 : 4;
    dst_bpp = (lcg_rand_n (2) == 0) ? 2 : 4;
    switch (lcg_rand_n (3))
d100 2
a101 2
    src_width = lcg_rand_n (MAX_SRC_WIDTH) + 1;
    src_height = lcg_rand_n (MAX_SRC_HEIGHT) + 1;
d103 1
a103 1
    if (lcg_rand_n (2))
d105 2
a106 2
	mask_width = lcg_rand_n (MAX_SRC_WIDTH) + 1;
	mask_height = lcg_rand_n (MAX_SRC_HEIGHT) + 1;
d113 5
a117 5
    dst_width = lcg_rand_n (MAX_DST_WIDTH) + 1;
    dst_height = lcg_rand_n (MAX_DST_HEIGHT) + 1;
    src_stride = src_width * src_bpp + lcg_rand_n (MAX_STRIDE) * src_bpp;
    mask_stride = mask_width * mask_bpp + lcg_rand_n (MAX_STRIDE) * mask_bpp;
    dst_stride = dst_width * dst_bpp + lcg_rand_n (MAX_STRIDE) * dst_bpp;
d130 8
a137 8
    src_x = -(src_width / 4) + lcg_rand_n (src_width * 3 / 2);
    src_y = -(src_height / 4) + lcg_rand_n (src_height * 3 / 2);
    mask_x = -(mask_width / 4) + lcg_rand_n (mask_width * 3 / 2);
    mask_y = -(mask_height / 4) + lcg_rand_n (mask_height * 3 / 2);
    dst_x = -(dst_width / 4) + lcg_rand_n (dst_width * 3 / 2);
    dst_y = -(dst_height / 4) + lcg_rand_n (dst_height * 3 / 2);
    w = lcg_rand_n (dst_width * 3 / 2 - dst_x);
    h = lcg_rand_n (dst_height * 3 / 2 - dst_y);
d143 3
a145 8
    for (i = 0; i < src_stride * src_height; i++)
	*((uint8_t *)srcbuf + i) = lcg_rand_n (256);

    for (i = 0; i < mask_stride * mask_height; i++)
	*((uint8_t *)maskbuf + i) = lcg_rand_n (256);

    for (i = 0; i < dst_stride * dst_height; i++)
	*((uint8_t *)dstbuf + i) = lcg_rand_n (256);
d162 1
a162 1
    if (lcg_rand_n (4) > 0)
d164 4
a167 4
	scale_x = -32768 * 3 + lcg_rand_N (65536 * 5);
	scale_y = -32768 * 3 + lcg_rand_N (65536 * 5);
	translate_x = lcg_rand_N (65536);
	translate_y = lcg_rand_N (65536);
d173 1
a173 1
    if (lcg_rand_n (2) > 0)
d175 4
a178 4
	mask_scale_x = -32768 * 3 + lcg_rand_N (65536 * 5);
	mask_scale_y = -32768 * 3 + lcg_rand_N (65536 * 5);
	mask_translate_x = lcg_rand_N (65536);
	mask_translate_y = lcg_rand_N (65536);
d184 1
a184 1
    switch (lcg_rand_n (4))
d207 1
a207 1
    switch (lcg_rand_n (4))
d230 1
a230 1
    if (lcg_rand_n (2))
d235 1
a235 1
    if (lcg_rand_n (2))
d242 4
a245 3
	printf ("src_fmt=%08X, dst_fmt=%08X\n", src_fmt, dst_fmt);
	printf ("op=%d, scale_x=%d, scale_y=%d, repeat=%d\n",
	        op, scale_x, scale_y, repeat);
d255 1
a255 1
    if (lcg_rand_n (8) == 0)
d258 1
a258 1
	int            n = lcg_rand_n (2) + 1;
d262 2
a263 2
	    clip_boxes[i].x1 = lcg_rand_n (src_width);
	    clip_boxes[i].y1 = lcg_rand_n (src_height);
d265 1
a265 1
		clip_boxes[i].x1 + lcg_rand_n (src_width - clip_boxes[i].x1);
d267 1
a267 1
		clip_boxes[i].y1 + lcg_rand_n (src_height - clip_boxes[i].y1);
d283 1
a283 1
    if (lcg_rand_n (8) == 0)
d286 1
a286 1
	int            n = lcg_rand_n (2) + 1;
d290 2
a291 2
	    clip_boxes[i].x1 = lcg_rand_n (mask_width);
	    clip_boxes[i].y1 = lcg_rand_n (mask_height);
d293 1
a293 1
		clip_boxes[i].x1 + lcg_rand_n (mask_width - clip_boxes[i].x1);
d295 1
a295 1
		clip_boxes[i].y1 + lcg_rand_n (mask_height - clip_boxes[i].y1);
d311 1
a311 1
    if (lcg_rand_n (8) == 0)
d314 1
a314 1
	int            n = lcg_rand_n (2) + 1;
d317 2
a318 2
	    clip_boxes[i].x1 = lcg_rand_n (dst_width);
	    clip_boxes[i].y1 = lcg_rand_n (dst_height);
d320 1
a320 1
		clip_boxes[i].x1 + lcg_rand_n (dst_width - clip_boxes[i].x1);
d322 1
a322 1
		clip_boxes[i].y1 + lcg_rand_n (dst_height - clip_boxes[i].y1);
d336 1
a336 1
    if (lcg_rand_n (2) == 0)
d379 1
a379 1
#define CHECKSUM 0x8D3A7539
d381 1
a381 1
#define CHECKSUM 0x03A23E0C
d383 1
a383 1
#define CHECKSUM 0xE96D1A5E
@


1.6
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@d23 25
d152 2
a153 5
    src_fmt = src_bpp == 4 ? (lcg_rand_n (2) == 0 ?
                              PIXMAN_a8r8g8b8 : PIXMAN_x8r8g8b8) : PIXMAN_r5g6b5;

    dst_fmt = dst_bpp == 4 ? (lcg_rand_n (2) == 0 ?
                              PIXMAN_a8r8g8b8 : PIXMAN_x8r8g8b8) : PIXMAN_r5g6b5;
d347 1
a347 1
    if (dst_fmt == PIXMAN_x8r8g8b8)
d382 10
d397 1
a397 1
    return fuzzer_test_main("scaling", 8000000, 0x80DF1CB2,
@


1.5
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@a9 1
#include <assert.h>
@


1.4
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@d15 4
a18 4
#define MAX_SRC_WIDTH  16
#define MAX_SRC_HEIGHT 16
#define MAX_DST_WIDTH  16
#define MAX_DST_HEIGHT 16
d30 1
d35 1
d37 1
a37 1
    int                src_stride, dst_stride;
d39 1
d42 1
d47 6
a52 3
    int                op;
    int                repeat = 0;
    int                src_fmt, dst_fmt;
d55 1
d63 12
a74 1
    op = (lcg_rand_n (2) == 0) ? PIXMAN_OP_SRC : PIXMAN_OP_OVER;
d78 11
d92 1
d98 5
d108 2
d116 1
d122 3
d137 3
d143 2
a144 2
    image_endian_swap (src_img, src_bpp * 8);
    image_endian_swap (dst_img, dst_bpp * 8);
d146 1
a146 1
    if (lcg_rand_n (8) > 0)
d157 34
d219 5
d270 28
d319 2
a320 1
    pixman_image_composite (op, src_img, NULL, dst_img,
d322 3
d333 1
a333 1
    image_endian_swap (dst_img, dst_bpp * 8);
d349 1
d354 1
d366 1
a366 1
    return fuzzer_test_main("scaling", 8000000, 0x7F1AB59F,
@


1.3
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d2 4
a5 3
 * Test program, which can detect problems with nearest neighbout scaling
 * implementation. Also SRC and OVER opetations tested for 16bpp and 32bpp
 * images.
d7 2
a8 16
 * Just run it without any command line arguments, and it will report either
 *   "scaling test passed" - everything is ok
 *   "scaling test failed!" - there is some problem
 *
 * In the case of failure, finding the problem involves the following steps:
 * 1. Get the reference 'scaling-test' binary. It makes sense to disable all
 *    the cpu specific optimizations in pixman and also configure it with
 *    '--disable-shared' option. Those who are paranoid can also tweak the
 *    sources to disable all fastpath functions. The resulting binary
 *    can be renamed to something like 'scaling-test.ref'.
 * 2. Compile the buggy binary (also with the '--disable-shared' option).
 * 3. Run 'ruby scaling-test-bisect.rb ./scaling-test.ref ./scaling-test'
 * 4. Look at the information about failed case (destination buffer content
 *    will be shown) and try to figure out what is wrong. It is possible
 *    to use debugging print to stderr in pixman to get more information,
 *    this does not interfere with the testing script.
d15 4
a18 4
#define MAX_SRC_WIDTH  10
#define MAX_SRC_HEIGHT 10
#define MAX_DST_WIDTH  10
#define MAX_DST_HEIGHT 10
d25 1
a25 2
test_composite (uint32_t initcrc,
		int      testnum,
d41 2
a42 1
    int                scale_x = 32768, scale_y = 32768;
d49 1
d103 4
a106 2
	scale_x = 32768 + lcg_rand_n (65536);
	scale_y = 32768 + lcg_rand_n (65536);
d108 1
d145 2
d235 1
a235 1
    crc32 = compute_crc32 (initcrc, dstbuf, dst_stride * dst_height);
d238 2
d244 1
a244 1
main (int   argc, char *argv[])
a245 3
    int      i, n = 0;
    uint32_t crc = 0;

d248 2
a249 35
    if (argc >= 2)
	n = atoi (argv[1]);

    if (n == 0) n = 3000000;

    if (n < 0)
    {
	crc = test_composite (0, -n, 1);
	printf ("crc32=%08X\n", crc);
    }
    else
    {
	for (i = 1; i <= n; i++)
	    crc = test_composite (crc, i, 0);

	printf ("crc32=%08X\n", crc);

	if (n == 3000000)
	{
	    /* predefined value for running with all the fastpath functions disabled  */
	    /* it needs to be updated every time changes are introduced to this program! */

	    if (crc == 0x2168ACD1)
	    {
		printf ("scaling test passed\n");
	    }
	    else
	    {
		printf ("scaling test failed!\n");
		return 1;
	    }
	}
    }

    return 0;
@


1.2
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@d26 1
a26 192
#include "pixman.h"

/* A primitive pseudorandom number generator, taken from POSIX.1-2001 example */

static uint32_t lcg_seed;

uint32_t
lcg_rand (void)
{
    lcg_seed = lcg_seed * 1103515245 + 12345;
    return ((uint32_t)(lcg_seed / 65536) % 32768);
}

void
lcg_srand (uint32_t seed)
{
    lcg_seed = seed;
}

uint32_t
lcg_rand_n (int max)
{
    return lcg_rand () % max;
}

/*----------------------------------------------------------------------------*\
*  CRC-32 version 2.0.0 by Craig Bruce, 2006-04-29.
*
*  This program generates the CRC-32 values for the files named in the
*  command-line arguments.  These are the same CRC-32 values used by GZIP,
*  PKZIP, and ZMODEM.  The compute_crc32() can also be detached and
*  used independently.
*
*  THIS PROGRAM IS PUBLIC-DOMAIN SOFTWARE.
*
*  Based on the byte-oriented implementation "File Verification Using CRC"
*  by Mark R. Nelson in Dr. Dobb's Journal, May 1992, pp. 64-67.
*
*  v1.0.0: original release.
*  v1.0.1: fixed printf formats.
*  v1.0.2: fixed something else.
*  v1.0.3: replaced CRC constant table by generator function.
*  v1.0.4: reformatted code, made ANSI C.  1994-12-05.
*  v2.0.0: rewrote to use memory buffer & static table, 2006-04-29.
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
*  NAME:
*     compute_crc32() - computes the CRC-32 value of a memory buffer
*  DESCRIPTION:
*     Computes or accumulates the CRC-32 value for a memory buffer.
*     The 'in_crc32' gives a previously accumulated CRC-32 value to allow
*     a CRC to be generated for multiple sequential buffer-fuls of data.
*     The 'in_crc32' for the first buffer must be zero.
*  ARGUMENTS:
*     in_crc32 - accumulated CRC-32 value, must be 0 on first call
*     buf     - buffer to compute CRC-32 value for
*     buf_len  - number of bytes in buffer
*  RETURNS:
*     crc32 - computed CRC-32 value
*  ERRORS:
*     (no errors are possible)
\*----------------------------------------------------------------------------*/

static uint32_t
compute_crc32 (uint32_t    in_crc32,
		  const void *buf,
		  size_t      buf_len)
{
    static const uint32_t crc_table[256] = {
	0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
	0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
	0x09B64C2B, 0x7EB17CBD,	0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
	0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
	0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,	0x14015C4F, 0x63066CD9,
	0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
	0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
	0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
	0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
	0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
	0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
	0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
	0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
	0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
	0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
	0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
	0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
	0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
	0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
	0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
	0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
	0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
	0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
	0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
	0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
	0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
	0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
	0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
	0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
	0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
	0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
	0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
	0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
	0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
	0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
	0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
	0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
	0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
	0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
	0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
	0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
	0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
	0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
    };
    
    uint32_t              crc32;
    unsigned char *       byte_buf;
    size_t                i;

    /** accumulate crc32 for buffer **/
    crc32 = in_crc32 ^ 0xFFFFFFFF;
    byte_buf = (unsigned char*) buf;

    for (i = 0; i < buf_len; i++)
	crc32 = (crc32 >> 8) ^ crc_table[(crc32 ^ byte_buf[i]) & 0xFF];
    
    return (crc32 ^ 0xFFFFFFFF);
}

/* perform endian conversion of pixel data */
static void
image_endian_swap (pixman_image_t *img,
		   int             bpp)
{
    int       stride = pixman_image_get_stride (img);
    uint32_t *data = pixman_image_get_data (img);
    int       height = pixman_image_get_height (img);
    int i, j;

    /* swap bytes only on big endian systems */
    volatile uint16_t endian_check_var = 0x1234;
    if (*(volatile uint8_t *)&endian_check_var != 0x12)
	return;

    for (i = 0; i < height; i++)
    {
	char *line_data = (char *)data + stride * i;
	
	/* swap bytes only for 16, 24 and 32 bpp for now */
	switch (bpp)
	{
	case 16:
	    for (j = 0; j + 2 <= stride; j += 2)
	    {
		char t1 = line_data[j + 0];
		char t2 = line_data[j + 1];
		line_data[j + 1] = t1;
		line_data[j + 0] = t2;
	    }
	    break;

	case 24:
	    for (j = 0; j + 3 <= stride; j += 3)
	    {
		char t1 = line_data[j + 0];
		char t2 = line_data[j + 1];
		char t3 = line_data[j + 2];
		line_data[j + 2] = t1;
		line_data[j + 1] = t2;
		line_data[j + 0] = t3;
	    }
	    break;

	case 32:
	    for (j = 0; j + 4 <= stride; j += 4)
	    {
		char t1 = line_data[j + 0];
		char t2 = line_data[j + 1];
		char t3 = line_data[j + 2];
		char t4 = line_data[j + 3];
		line_data[j + 3] = t1;
		line_data[j + 2] = t2;
		line_data[j + 1] = t3;
		line_data[j + 0] = t4;
	    }
	    break;

	default:
	    break;
	}
    }
}
d78 1
a78 1
    
d138 3
d144 5
d182 1
a182 1
	
d278 1
a278 1
	    if (crc == 0x0B633CF4)
@


1.1
log
@Update to pixman 0.15.8.
@
text
@d32 2
a33 1
uint32_t lcg_rand(void)
d39 2
a40 1
void lcg_srand(uint32_t seed)
d45 2
a46 1
uint32_t lcg_rand_n(int max)
d48 1
a48 1
    return lcg_rand() % max;
d52 18
a69 18
 *  CRC-32 version 2.0.0 by Craig Bruce, 2006-04-29.
 *
 *  This program generates the CRC-32 values for the files named in the
 *  command-line arguments.  These are the same CRC-32 values used by GZIP,
 *  PKZIP, and ZMODEM.  The Crc32_ComputeBuf() can also be detached and
 *  used independently.
 *
 *  THIS PROGRAM IS PUBLIC-DOMAIN SOFTWARE.
 *
 *  Based on the byte-oriented implementation "File Verification Using CRC"
 *  by Mark R. Nelson in Dr. Dobb's Journal, May 1992, pp. 64-67.
 *
 *  v1.0.0: original release.
 *  v1.0.1: fixed printf formats.
 *  v1.0.2: fixed something else.
 *  v1.0.3: replaced CRC constant table by generator function.
 *  v1.0.4: reformatted code, made ANSI C.  1994-12-05.
 *  v2.0.0: rewrote to use memory buffer & static table, 2006-04-29.
d73 15
a87 15
 *  NAME:
 *     Crc32_ComputeBuf() - computes the CRC-32 value of a memory buffer
 *  DESCRIPTION:
 *     Computes or accumulates the CRC-32 value for a memory buffer.
 *     The 'inCrc32' gives a previously accumulated CRC-32 value to allow
 *     a CRC to be generated for multiple sequential buffer-fuls of data.
 *     The 'inCrc32' for the first buffer must be zero.
 *  ARGUMENTS:
 *     inCrc32 - accumulated CRC-32 value, must be 0 on first call
 *     buf     - buffer to compute CRC-32 value for
 *     bufLen  - number of bytes in buffer
 *  RETURNS:
 *     crc32 - computed CRC-32 value
 *  ERRORS:
 *     (no errors are possible)
d90 4
a93 2
static uint32_t Crc32_ComputeBuf( uint32_t inCrc32, const void *buf,
                                       size_t bufLen )
d95 49
a143 41
    static const uint32_t crcTable[256] = {
   0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,
   0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,
   0xE7B82D07,0x90BF1D91,0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,
   0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,
   0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,0x3B6E20C8,0x4C69105E,0xD56041E4,
   0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,
   0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,0x26D930AC,
   0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,
   0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,
   0xB6662D3D,0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,
   0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,
   0x086D3D2D,0x91646C97,0xE6635C01,0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,
   0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA,
   0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,0x4DB26158,0x3AB551CE,
   0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A,
   0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
   0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,
   0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,
   0xB7BD5C3B,0xC0BA6CAD,0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,
   0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,
   0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,0xF00F9344,0x8708A3D2,0x1E01F268,
   0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,
   0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,0xD6D6A3E8,
   0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,
   0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,
   0x4669BE79,0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,
   0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,
   0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,
   0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,
   0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,0x86D3D2D4,0xF1D4E242,
   0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6,
   0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
   0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,
   0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,
   0x47B2CF7F,0x30B5FFE9,0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,
   0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,
   0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D };
    uint32_t crc32;
    unsigned char *byteBuf;
    size_t i;
d146 70
a215 4
    crc32 = inCrc32 ^ 0xFFFFFFFF;
    byteBuf = (unsigned char*) buf;
    for (i=0; i < bufLen; i++) {
        crc32 = (crc32 >> 8) ^ crcTable[ (crc32 ^ byteBuf[i]) & 0xFF ];
a216 1
    return( crc32 ^ 0xFFFFFFFF );
a218 1

d228 4
a231 1
uint32_t test_composite(uint32_t initcrc, int testnum, int verbose)
d233 3
a235 3
    int i;
    pixman_image_t *src_img;
    pixman_image_t *dst_img;
d237 45
a281 38
    pixman_region16_t clip;
    int src_width, src_height;
    int dst_width, dst_height;
    int src_stride, dst_stride;
    int src_x, src_y;
    int dst_x, dst_y;
    int src_bpp;
    int dst_bpp;
    int w, h;
    int scale_x = 32768, scale_y = 32768;
    int op;
    int repeat = 0;
    int src_fmt, dst_fmt;
    uint32_t *srcbuf;
    uint32_t *dstbuf;
    uint32_t crc32;

    lcg_srand(testnum);

    src_bpp = (lcg_rand_n(2) == 0) ? 2 : 4;
    dst_bpp = (lcg_rand_n(2) == 0) ? 2 : 4;
    op = (lcg_rand_n(2) == 0) ? PIXMAN_OP_SRC : PIXMAN_OP_OVER;

    src_width = lcg_rand_n(MAX_SRC_WIDTH) + 1;
    src_height = lcg_rand_n(MAX_SRC_HEIGHT) + 1;
    dst_width = lcg_rand_n(MAX_DST_WIDTH) + 1;
    dst_height = lcg_rand_n(MAX_DST_HEIGHT) + 1;
    src_stride = src_width * src_bpp + lcg_rand_n(MAX_STRIDE) * src_bpp;
    dst_stride = dst_width * dst_bpp + lcg_rand_n(MAX_STRIDE) * dst_bpp;
    if (src_stride & 3) src_stride += 2;
    if (dst_stride & 3) dst_stride += 2;

    src_x = -(src_width / 4) + lcg_rand_n(src_width * 3 / 2);
    src_y = -(src_height / 4) + lcg_rand_n(src_height * 3 / 2);
    dst_x = -(dst_width / 4) + lcg_rand_n(dst_width * 3 / 2);
    dst_y = -(dst_height / 4) + lcg_rand_n(dst_height * 3 / 2);
    w = lcg_rand_n(dst_width * 3 / 2 - dst_x);
    h = lcg_rand_n(dst_height * 3 / 2 - dst_y);
a282 2
    srcbuf = (uint32_t *)malloc(src_stride * src_height);
    dstbuf = (uint32_t *)malloc(dst_stride * dst_height);
d284 2
a285 1
        *((uint8_t *)srcbuf + i) = lcg_rand_n(256);
d287 1
a287 1
        *((uint8_t *)dstbuf + i) = lcg_rand_n(256);
d289 2
a290 2
    src_fmt = src_bpp == 4 ? (lcg_rand_n(2) == 0 ?
        PIXMAN_a8r8g8b8 : PIXMAN_x8r8g8b8) : PIXMAN_r5g6b5;
d292 2
a293 2
    dst_fmt = dst_bpp == 4 ? (lcg_rand_n(2) == 0 ?
        PIXMAN_a8r8g8b8 : PIXMAN_x8r8g8b8) : PIXMAN_r5g6b5;
d295 1
a295 1
    src_img = pixman_image_create_bits(
d298 1
a298 1
    dst_img = pixman_image_create_bits(
d301 9
a309 5
    if (lcg_rand_n(8) > 0) {
        scale_x = 32768 + lcg_rand_n(65536);
        scale_y = 32768 + lcg_rand_n(65536);
        pixman_transform_init_scale(&transform, scale_x, scale_y);
        pixman_image_set_transform(src_img, &transform);
d312 17
a328 5
    switch (lcg_rand_n(4)) {
        case 0: repeat = PIXMAN_REPEAT_NONE; break;
        case 1: repeat = PIXMAN_REPEAT_NORMAL; break;
        case 2: repeat = PIXMAN_REPEAT_PAD; break;
        case 3: repeat = PIXMAN_REPEAT_REFLECT; break;
d330 1
a330 1
    pixman_image_set_repeat(src_img, repeat);
d332 10
a341 9
    if (verbose) {
        printf("src_fmt=%08X, dst_fmt=%08X\n", src_fmt, dst_fmt);
        printf("op=%d, scale_x=%d, scale_y=%d, repeat=%d\n",
            op, scale_x, scale_y, repeat);
        printf("src_width=%d, src_height=%d, dst_width=%d, dst_height=%d\n",
            src_width, src_height, dst_width, dst_height);
        printf("src_x=%d, src_y=%d, dst_x=%d, dst_y=%d\n",
            src_x, src_y, dst_x, dst_y);
        printf("w=%d, h=%d\n", w, h);
d344 26
a369 18
    if (lcg_rand_n(8) == 0) {
        pixman_box16_t clip_boxes[2];
        int n = lcg_rand_n(2) + 1;
        for (i = 0; i < n; i++) {
            clip_boxes[i].x1 = lcg_rand_n(src_width);
            clip_boxes[i].y1 = lcg_rand_n(src_height);
            clip_boxes[i].x2 = clip_boxes[i].x1 + lcg_rand_n(src_width - clip_boxes[i].x1);
            clip_boxes[i].y2 = clip_boxes[i].y1 + lcg_rand_n(src_height - clip_boxes[i].y1);
            if (verbose) {
                printf("source clip box: [%d,%d-%d,%d]\n",
                    clip_boxes[i].x1, clip_boxes[i].y1,
                    clip_boxes[i].x2, clip_boxes[i].y2);
            }
        }
        pixman_region_init_rects(&clip, clip_boxes, n);
        pixman_image_set_clip_region(src_img, &clip);
        pixman_image_set_source_clipping(src_img, 1);
        pixman_region_fini(&clip);
d372 23
a394 17
    if (lcg_rand_n(8) == 0) {
        pixman_box16_t clip_boxes[2];
        int n = lcg_rand_n(2) + 1;
        for (i = 0; i < n; i++) {
            clip_boxes[i].x1 = lcg_rand_n(dst_width);
            clip_boxes[i].y1 = lcg_rand_n(dst_height);
            clip_boxes[i].x2 = clip_boxes[i].x1 + lcg_rand_n(dst_width - clip_boxes[i].x1);
            clip_boxes[i].y2 = clip_boxes[i].y1 + lcg_rand_n(dst_height - clip_boxes[i].y1);
            if (verbose) {
                printf("destination clip box: [%d,%d-%d,%d]\n",
                    clip_boxes[i].x1, clip_boxes[i].y1,
                    clip_boxes[i].x2, clip_boxes[i].y2);
            }
        }
        pixman_region_init_rects(&clip, clip_boxes, n);
        pixman_image_set_clip_region(dst_img, &clip);
        pixman_region_fini(&clip);
d400 5
a404 4
    if (dst_fmt == PIXMAN_x8r8g8b8) {
        /* ignore unused part */
        for (i = 0; i < dst_stride * dst_height / 4; i++)
            dstbuf[i] &= 0xFFFFFF;
d407 13
a419 8
    if (verbose) {
        int j;
        for (i = 0; i < dst_height; i++) {
            for (j = 0; j < dst_stride; j++) {
                printf("%02X ", *((uint8_t *)dstbuf + i * dst_stride + j));
            }
            printf("\n");
        }
d425 3
a427 3
    crc32 = Crc32_ComputeBuf(initcrc, dstbuf, dst_stride * dst_height);
    free(srcbuf);
    free(dstbuf);
d431 2
a432 1
int main(int argc, char *argv[])
d434 1
a434 1
    int i, n = 0;
d437 2
d440 1
a440 1
        n = atoi(argv[1]);
d444 4
a447 3
    if (n < 0) {
        crc = test_composite(0, -n, 1);
        printf("crc32=%08X\n", crc);
d449 22
a470 17
    else {
        for (i = 1; i <= n; i++)
        {
            crc = test_composite(crc, i, 0);
        }
        printf("crc32=%08X\n", crc);
#ifdef LITTLE_ENDIAN
        if (n == 3000000) {
            /* predefined value for running with all the fastpath functions disabled  */
            /* it needs to be updated every time changes are introduced to this program! */
            if (crc == 0xC950E5BB) {
                printf("scaling test passed\n");
            } else {
                printf("scaling test failed!\n");
            }
        }
#endif
d472 1
@

