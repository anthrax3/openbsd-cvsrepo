head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.18
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.16
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.14
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.12
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.10
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.8
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.6
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.4
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2013.06.07.17.18.01;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.11.14.13.42.50;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@#include <stdio.h>
#include <stdlib.h>
#include "utils.h"

#define WIDTH 48
#define HEIGHT 48

static const pixman_format_code_t formats[] =
{
    PIXMAN_a8r8g8b8,
    PIXMAN_a2r10g10b10,
    PIXMAN_a4r4g4b4,
    PIXMAN_a8
};

static const pixman_format_code_t alpha_formats[] =
{
    PIXMAN_null,
    PIXMAN_a8,
    PIXMAN_a2r10g10b10,
    PIXMAN_a4r4g4b4
};

static const int origins[] =
{
    0, 10, -100
};

static void
on_destroy (pixman_image_t *image, void *data)
{
    uint32_t *bits = pixman_image_get_data (image);

    fence_free (bits);
}

static pixman_image_t *
make_image (pixman_format_code_t format)
{
    uint32_t *bits;
    uint8_t bpp = PIXMAN_FORMAT_BPP (format) / 8;
    pixman_image_t *image;

    bits = (uint32_t *)make_random_bytes (WIDTH * HEIGHT * bpp);

    image = pixman_image_create_bits (format, WIDTH, HEIGHT, bits, WIDTH * bpp);

    if (image && bits)
	pixman_image_set_destroy_function (image, on_destroy, NULL);

    return image;
}

static uint8_t
get_alpha (pixman_image_t *image, int x, int y, int orig_x, int orig_y)
{
    uint8_t *bits;
    uint8_t r;

    if (image->common.alpha_map)
    {
	if (x - orig_x >= 0 && x - orig_x < WIDTH &&
	    y - orig_y >= 0 && y - orig_y < HEIGHT)
	{
	    image = (pixman_image_t *)image->common.alpha_map;

	    x -= orig_x;
	    y -= orig_y;
	}
	else
	{
	    return 0;
	}
    }

    bits = (uint8_t *)image->bits.bits;

    if (image->bits.format == PIXMAN_a8)
    {
	r = bits[y * WIDTH + x];
    }
    else if (image->bits.format == PIXMAN_a2r10g10b10)
    {
	r = ((uint32_t *)bits)[y * WIDTH + x] >> 30;
	r |= r << 2;
	r |= r << 4;
    }
    else if (image->bits.format == PIXMAN_a8r8g8b8)
    {
	r = ((uint32_t *)bits)[y * WIDTH + x] >> 24;
    }
    else if (image->bits.format == PIXMAN_a4r4g4b4)
    {
	r = ((uint16_t *)bits)[y * WIDTH + x] >> 12;
	r |= r << 4;
    }
    else
    {
	assert (0);
    }

    return r;
}

static uint16_t
get_red (pixman_image_t *image, int x, int y, int orig_x, int orig_y)
{
    uint8_t *bits;
    uint16_t r;

    bits = (uint8_t *)image->bits.bits;

    if (image->bits.format == PIXMAN_a8)
    {
	r = 0x00;
    }
    else if (image->bits.format == PIXMAN_a2r10g10b10)
    {
	r = ((uint32_t *)bits)[y * WIDTH + x] >> 14;
	r &= 0xffc0;
	r |= (r >> 10);
    }
    else if (image->bits.format == PIXMAN_a8r8g8b8)
    {
	r = ((uint32_t *)bits)[y * WIDTH + x] >> 16;
	r &= 0xff;
	r |= r << 8;
    }
    else if (image->bits.format == PIXMAN_a4r4g4b4)
    {
	r = ((uint16_t *)bits)[y * WIDTH + x] >> 8;
	r &= 0xf;
	r |= r << 4;
	r |= r << 8;
    }
    else
    {
	assert (0);
    }

    return r;
}

static int
run_test (int s, int d, int sa, int da, int soff, int doff)
{
    pixman_format_code_t sf = formats[s];
    pixman_format_code_t df = formats[d];
    pixman_format_code_t saf = alpha_formats[sa];
    pixman_format_code_t daf = alpha_formats[da];
    pixman_image_t *src, *dst, *orig_dst, *alpha, *orig_alpha;
    pixman_transform_t t1;
    int j, k;
    int n_alpha_bits, n_red_bits;

    soff = origins[soff];
    doff = origins[doff];

    n_alpha_bits = PIXMAN_FORMAT_A (df);
    if (daf != PIXMAN_null)
	n_alpha_bits = PIXMAN_FORMAT_A (daf);

    n_red_bits = PIXMAN_FORMAT_R (df);

    /* Source */
    src = make_image (sf);
    if (saf != PIXMAN_null)
    {
	alpha = make_image (saf);
	pixman_image_set_alpha_map (src, alpha, soff, soff);
	pixman_image_unref (alpha);
    }

    /* Destination */
    orig_dst = make_image (df);
    dst = make_image (df);
    pixman_image_composite (PIXMAN_OP_SRC, orig_dst, NULL, dst,
			    0, 0, 0, 0, 0, 0, WIDTH, HEIGHT);

    if (daf != PIXMAN_null)
    {
	orig_alpha = make_image (daf);
	alpha = make_image (daf);

	pixman_image_composite (PIXMAN_OP_SRC, orig_alpha, NULL, alpha,
				0, 0, 0, 0, 0, 0, WIDTH, HEIGHT);

	pixman_image_set_alpha_map (orig_dst, orig_alpha, doff, doff);
	pixman_image_set_alpha_map (dst, alpha, doff, doff);

	pixman_image_unref (orig_alpha);
	pixman_image_unref (alpha);
    }

    /* Transformations, repeats and filters on destinations should be ignored,
     * so just set some random ones.
     */
    pixman_transform_init_identity (&t1);
    pixman_transform_scale (&t1, NULL, pixman_int_to_fixed (100), pixman_int_to_fixed (11));
    pixman_transform_rotate (&t1, NULL, pixman_double_to_fixed (0.5), pixman_double_to_fixed (0.11));
    pixman_transform_translate (&t1, NULL, pixman_int_to_fixed (11), pixman_int_to_fixed (17));

    pixman_image_set_transform (dst, &t1);
    pixman_image_set_filter (dst, PIXMAN_FILTER_BILINEAR, NULL, 0);
    pixman_image_set_repeat (dst, PIXMAN_REPEAT_REFLECT);

    pixman_image_composite (PIXMAN_OP_ADD, src, NULL, dst,
			    0, 0, 0, 0, 0, 0, WIDTH, HEIGHT);

    for (j = MAX (doff, 0); j < MIN (HEIGHT, HEIGHT + doff); ++j)
    {
	for (k = MAX (doff, 0); k < MIN (WIDTH, WIDTH + doff); ++k)
	{
	    uint8_t sa, da, oda, refa;
	    uint16_t sr, dr, odr, refr;

	    sa = get_alpha (src, k, j, soff, soff);
	    da = get_alpha (dst, k, j, doff, doff);
	    oda = get_alpha (orig_dst, k, j, doff, doff);

	    if (sa + oda > 255)
		refa = 255;
	    else
		refa = sa + oda;

	    if (da >> (8 - n_alpha_bits) != refa >> (8 - n_alpha_bits))
	    {
		printf ("\nWrong alpha value at (%d, %d). Should be 0x%x; got 0x%x. Source was 0x%x, original dest was 0x%x\n",
			k, j, refa, da, sa, oda);

		printf ("src: %s, alpha: %s, origin %d %d\ndst: %s, alpha: %s, origin: %d %d\n\n",
			format_name (sf),
			format_name (saf),
			soff, soff,
			format_name (df),
			format_name (daf),
			doff, doff);
		return 1;
	    }

	    /* There are cases where we go through the 8 bit compositing
	     * path even with 10bpc formats. This results in incorrect
	     * results here, so only do the red check for narrow formats
	     */
	    if (n_red_bits <= 8)
	    {
		sr = get_red (src, k, j, soff, soff);
		dr = get_red (dst, k, j, doff, doff);
		odr = get_red (orig_dst, k, j, doff, doff);

		if (sr + odr > 0xffff)
		    refr = 0xffff;
		else
		    refr = sr + odr;

		if (abs ((dr >> (16 - n_red_bits)) - (refr >> (16 - n_red_bits))) > 1)
		{
		    printf ("%d red bits\n", n_red_bits);
		    printf ("\nWrong red value at (%d, %d). Should be 0x%x; got 0x%x. Source was 0x%x, original dest was 0x%x\n",
			    k, j, refr, dr, sr, odr);

		    printf ("src: %s, alpha: %s, origin %d %d\ndst: %s, alpha: %s, origin: %d %d\n\n",
			    format_name (sf),
			    format_name (saf),
			    soff, soff,
			    format_name (df),
			    format_name (daf),
			    doff, doff);
		    return 1;
		}
	    }
	}
    }

    pixman_image_set_alpha_map (src, NULL, 0, 0);
    pixman_image_set_alpha_map (dst, NULL, 0, 0);
    pixman_image_set_alpha_map (orig_dst, NULL, 0, 0);

    pixman_image_unref (src);
    pixman_image_unref (dst);
    pixman_image_unref (orig_dst);

    return 0;
}

int
main (int argc, char **argv)
{
    int i, j, a, b, x, y;

    prng_srand (0);

    for (i = 0; i < ARRAY_LENGTH (formats); ++i)
    {
	for (j = 0; j < ARRAY_LENGTH (formats); ++j)
	{
	    for (a = 0; a < ARRAY_LENGTH (alpha_formats); ++a)
	    {
		for (b = 0; b < ARRAY_LENGTH (alpha_formats); ++b)
		{
		    for (x = 0; x < ARRAY_LENGTH (origins); ++x)
		    {
			for (y = 0; y < ARRAY_LENGTH (origins); ++y)
			{
			    if (run_test (i, j, a, b, x, y) != 0)
				return 1;
			}
		    }
		}
	    }
	}
    }

    return 0;
}
@


1.4
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@a28 19
static const char *
format_name (pixman_format_code_t format)
{
    if (format == PIXMAN_a8)
	return "a8";
    else if (format == PIXMAN_a2r10g10b10)
	return "a2r10g10b10";
    else if (format == PIXMAN_a8r8g8b8)
	return "a8r8g8b8";
    else if (format == PIXMAN_a4r4g4b4)
	return "a4r4g4b4";
    else if (format == PIXMAN_null)
	return "none";
    else
	assert (0);

    return "<unknown - bug in alphamap.c>";
}

d290 2
@


1.3
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d5 2
a6 2
#define WIDTH 100
#define HEIGHT 100
a72 18
static pixman_image_t *
create_image (pixman_format_code_t format, pixman_format_code_t alpha_format,
	      int alpha_origin_x, int alpha_origin_y)
{
    pixman_image_t *image = make_image (format);

    if (alpha_format != PIXMAN_null)
    {
	pixman_image_t *alpha = make_image (alpha_format);

	pixman_image_set_alpha_map (image, alpha,
				    alpha_origin_x, alpha_origin_y);
	pixman_image_unref (alpha);
    }

    return image;
}

d124 38
a161 1
#define ARRAY_LENGTH(A) ((int) (sizeof (A) / sizeof ((A) [0])))
d170 1
a170 1
    pixman_image_t *src, *dst, *orig_dst;
d173 1
a173 1
    int n_alpha_bits;
d182 1
d184 29
a212 3
    src = create_image (sf, saf, soff, soff);
    orig_dst = create_image (df, daf, doff, doff);
    dst = create_image (df, daf, doff, doff);
a225 3
    pixman_image_composite (PIXMAN_OP_SRC, orig_dst, NULL, dst,
			    0, 0, 0, 0, 0, 0, WIDTH, HEIGHT);

d233 2
a234 1
	    uint8_t sa, da, oda, ref;
d241 1
a241 1
		ref = 255;
d243 1
a243 1
		ref = sa + oda;
d245 1
a245 1
	    if (da >> (8 - n_alpha_bits) != ref >> (8 - n_alpha_bits))
d248 1
a248 1
			k, j, ref, da, sa, oda);
d258 32
@


1.2
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@d168 2
a169 2
    /* Transformations on destinations should be ignored, so just set some
     * random one.
a175 4
#if 0
    /* Unfortunately, this is actually broken at the moment, so we can't
     * actually turn it on
     */
d177 2
a178 1
#endif
@


1.1
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d5 2
a6 2
#define WIDTH 400
#define HEIGHT 200
d8 50
a57 2
int
main (int argc, char **argv)
d59 5
a63 4
    uint8_t *alpha = make_random_bytes (WIDTH * HEIGHT);
    uint32_t *src = (uint32_t *)make_random_bytes (WIDTH * HEIGHT * 4);
    uint32_t *dest = (uint32_t *)make_random_bytes (WIDTH * HEIGHT * 4);
    int i;
d65 1
a65 2
    pixman_image_t *a = pixman_image_create_bits (PIXMAN_a8, WIDTH, HEIGHT, (uint32_t *)alpha, WIDTH);
    pixman_image_t *d = pixman_image_create_bits (PIXMAN_a8r8g8b8, WIDTH, HEIGHT, dest, WIDTH * 4);
d67 13
a79 1
    for (i = 0; i < 2; ++i)
d81 1
a81 3
	pixman_format_code_t sformat = (i == 0)? PIXMAN_a8r8g8b8 : PIXMAN_a2r10g10b10;
	pixman_image_t *s = pixman_image_create_bits (sformat, WIDTH, HEIGHT, src, WIDTH * 4);
	int j, k;
d83 13
a95 1
	pixman_image_set_alpha_map (s, a, 0, 0);
d97 6
a102 1
	pixman_image_composite (PIXMAN_OP_SRC, s, NULL, d, 0, 0, 0, 0, 0, 0, WIDTH, HEIGHT);
d104 4
a107 1
	for (j = 0; j < HEIGHT; ++j)
d109 96
a204 1
	    for (k = 0; k < WIDTH; ++k)
d206 30
a235 3
		uint8_t ap = ((uint8_t *)alpha)[j * WIDTH + k];
		uint32_t dap = (dest[j * WIDTH + k] >> 24);
		uint32_t sap = (src[j * WIDTH + k] >> 24);
d237 7
a243 1
		if (ap != dap)
d245 8
a252 2
		    printf ("Wrong alpha value at (%d, %d). Should be %d; got %d (src was %d)\n", k, j, ap, dap, sap);
		    return 1;
a255 2

	pixman_image_unref (s);
@

