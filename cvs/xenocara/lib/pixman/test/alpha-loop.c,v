head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.16
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.14
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.12
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.10
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.8
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.6
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.0.10
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.8
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.6
	OPENBSD_5_0:1.1.0.4
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2013.08.25.17.42.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.07.17.18.01;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.11.14.13.42.50;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to pixman 0.30.2. No functional change.
@
text
@#include <stdio.h>
#include <stdlib.h>
#include "utils.h"

#define WIDTH 400
#define HEIGHT 200

int
main (int argc, char **argv)
{
    pixman_image_t *a, *d, *s;
    uint8_t *alpha;
    uint32_t *src, *dest;

    prng_srand (0);

    alpha = make_random_bytes (WIDTH * HEIGHT);
    src = (uint32_t *)make_random_bytes (WIDTH * HEIGHT * 4);
    dest = (uint32_t *)make_random_bytes (WIDTH * HEIGHT * 4);

    a = pixman_image_create_bits (PIXMAN_a8, WIDTH, HEIGHT, (uint32_t *)alpha, WIDTH);
    d = pixman_image_create_bits (PIXMAN_a8r8g8b8, WIDTH, HEIGHT, dest, WIDTH * 4);
    s = pixman_image_create_bits (PIXMAN_a2r10g10b10, WIDTH, HEIGHT, src, WIDTH * 4);

    fail_after (5, "Infinite loop detected: 5 seconds without progress\n");

    pixman_image_set_alpha_map (s, a, 0, 0);
    pixman_image_set_alpha_map (a, s, 0, 0);

    pixman_image_composite (PIXMAN_OP_SRC, s, NULL, d, 0, 0, 0, 0, 0, 0, WIDTH, HEIGHT);

    pixman_image_unref (s);

    return 0;
}
@


1.2
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@d11 1
d21 3
a23 3
    pixman_image_t *a = pixman_image_create_bits (PIXMAN_a8, WIDTH, HEIGHT, (uint32_t *)alpha, WIDTH);
    pixman_image_t *d = pixman_image_create_bits (PIXMAN_a8r8g8b8, WIDTH, HEIGHT, dest, WIDTH * 4);
    pixman_image_t *s = pixman_image_create_bits (PIXMAN_a2r10g10b10, WIDTH, HEIGHT, src, WIDTH * 4);
@


1.1
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@d11 8
a18 3
    uint8_t *alpha = make_random_bytes (WIDTH * HEIGHT);
    uint32_t *src = (uint32_t *)make_random_bytes (WIDTH * HEIGHT * 4);
    uint32_t *dest = (uint32_t *)make_random_bytes (WIDTH * HEIGHT * 4);
@

