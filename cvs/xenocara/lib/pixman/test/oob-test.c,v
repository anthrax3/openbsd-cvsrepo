head	1.2;
access;
symbols
	OPENBSD_6_0:1.2.0.16
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.14
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.12
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.10
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.8
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.0.10
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.8
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.2
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@#include <stdio.h>
#include <stdlib.h>
#include "utils.h"

typedef struct
{
    int				width;
    int				height;
    int				stride;
    pixman_format_code_t	format;
    
} image_info_t;

typedef struct
{
    pixman_op_t		op;
    
    image_info_t	src;
    image_info_t	dest;

    int			src_x;
    int			src_y;
    int			dest_x;
    int			dest_y;
    int			width;
    int			height;
} composite_info_t;

const composite_info_t info[] =
{
    {
	PIXMAN_OP_SRC,
	{  3, 6, 16, PIXMAN_a8r8g8b8 },
	{  5, 7, 20, PIXMAN_x8r8g8b8 },
	1, 8,
	1, -1,
	1, 8
    },
    {
	PIXMAN_OP_SRC,
	{ 7, 5, 36, PIXMAN_a8r8g8b8 },
	{ 6, 5, 28, PIXMAN_x8r8g8b8 },
	8, 5,
	5, 3,
	1, 2
    },
    {
	PIXMAN_OP_OVER,
	{ 10, 10, 40, PIXMAN_a2b10g10r10 },
	{ 10, 10, 40, PIXMAN_a2b10g10r10 },
	0, 0,
	0, 0,
	10, 10
    },
    {
	PIXMAN_OP_OVER,
	{ 10, 10, 40, PIXMAN_x2b10g10r10 },
	{ 10, 10, 40, PIXMAN_x2b10g10r10 },
	0, 0,
	0, 0,
	10, 10
    },
};

static pixman_image_t *
make_image (const image_info_t *info)
{
    char *data = malloc (info->stride * info->height);
    int i;

    for (i = 0; i < info->height * info->stride; ++i)
	data[i] = (i % 255) ^ (((i % 16) << 4) | (i & 0xf0));

    return pixman_image_create_bits (info->format, info->width, info->height, (uint32_t *)data, info->stride);
}
    
static void
test_composite (const composite_info_t *info)
{
    pixman_image_t *src = make_image (&info->src);
    pixman_image_t *dest = make_image (&info->dest);

    pixman_image_composite (PIXMAN_OP_SRC, src, NULL, dest,
			    info->src_x, info->src_y,
			    0, 0,
			    info->dest_x, info->dest_y,
			    info->width, info->height);
}



int
main (int argc, char **argv)
{
    int i;

    for (i = 0; i < ARRAY_LENGTH (info); ++i)
	test_composite (&info[i]);
    
    return 0;
}
@


1.1
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@d3 1
a3 1
#include "pixman.h"
d97 1
a97 1
    for (i = 0; i < sizeof (info) / sizeof (info[0]); ++i)
@

