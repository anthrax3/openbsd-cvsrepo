head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.4
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.2
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.4
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.2
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.2
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.2
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v0_9_6:1.1.1.2
	xorg:1.1.1
	v0_9_5:1.1.1.1
	pixman:1.1.1;
locks; strict;
comment	@# @;


1.24
date	2016.10.11.21.54.35;	author matthieu;	state Exp;
branches;
next	1.23;
commitid	MO7auWz2xMy1hMXO;

1.23
date	2016.10.01.10.17.44;	author matthieu;	state Exp;
branches;
next	1.22;
commitid	FGr8CFhVerRlpSoE;

1.22
date	2015.10.01.06.21.38;	author matthieu;	state Exp;
branches;
next	1.21;
commitid	a56IHRa9z4nbjjS9;

1.21
date	2014.07.20.19.22.20;	author matthieu;	state Exp;
branches;
next	1.20;
commitid	lHuC72cz4nQROZUb;

1.20
date	2013.12.01.20.34.20;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2013.08.25.17.42.39;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.08.15.38.51;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2013.06.07.17.18.00;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2012.11.23.20.44.08;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2012.08.17.16.15.20;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2012.02.28.20.36.12;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.24.15.29.08;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.24.13.05.47;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.22.08.32.55;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.11.14.13.42.49;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.03.18.30.04;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.25.21.58.52;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.28.19.01.29;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.05.20.14.27;	author matthieu;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2008.09.23.19.11.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.08.19.00.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.10.21.30.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.20.20.30.06;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.03.20.48.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.10.03.20.48.50;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.12.10.21.10.18;	author matthieu;	state Exp;
branches;
next	;

1.6.2.1
date	2009.07.28.19.38.08;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Force AM_MAINTAINER_MODE in all Xenocara packages built by autotools

This prevents autotools to try to rebuild themselve automagically
if configure.ac, Makefile.am or a few other have more recent time
stamps than the generated files.

It will allows to get rid of the NO_REORDER mechanism that touches
files in the source tree to ensure nothing gets rebuilt.
@
text
@dnl  Copyright 2005 Red Hat, Inc.
dnl 
dnl  Permission to use, copy, modify, distribute, and sell this software and its
dnl  documentation for any purpose is hereby granted without fee, provided that
dnl  the above copyright notice appear in all copies and that both that
dnl  copyright notice and this permission notice appear in supporting
dnl  documentation, and that the name of Red Hat not be used in
dnl  advertising or publicity pertaining to distribution of the software without
dnl  specific, written prior permission.  Red Hat makes no
dnl  representations about the suitability of this software for any purpose.  It
dnl  is provided "as is" without express or implied warranty.
dnl 
dnl  RED HAT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
dnl  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
dnl  EVENT SHALL RED HAT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
dnl  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
dnl  DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
dnl  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
dnl  PERFORMANCE OF THIS SOFTWARE.
dnl
dnl Process this file with autoconf to create configure.

AC_PREREQ([2.57])

#   Pixman versioning scheme
#
#   - The version in git has an odd MICRO version number
#
#   - Released versions, both development and stable, have an
#     even MICRO version number
#
#   - Released development versions have an odd MINOR number
#
#   - Released stable versions have an even MINOR number
#
#   - Versions that break ABI must have a new MAJOR number
#
#   - If you break the ABI, then at least this must be done:
#
#        - increment MAJOR
#
#        - In the first development release where you break ABI, find
#          all instances of "pixman-n" and change them to pixman-(n+1)
#
#          This needs to be done at least in 
#                    configure.ac
#                    all Makefile.am's
#                    pixman-n.pc.in
#
#      This ensures that binary incompatible versions can be installed
#      in parallel.  See http://www106.pair.com/rhp/parallel.html for
#      more information
#

m4_define([pixman_major], 0)
m4_define([pixman_minor], 34)
m4_define([pixman_micro], 0)

m4_define([pixman_version],[pixman_major.pixman_minor.pixman_micro])

AC_INIT(pixman, pixman_version, [pixman@@lists.freedesktop.org], pixman)
AM_INIT_AUTOMAKE([foreign dist-bzip2])

AM_MAINTAINER_MODE

# Suppress verbose compile lines
m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])

AC_CONFIG_HEADERS(config.h)

AC_CANONICAL_HOST

test_CFLAGS=${CFLAGS+set} # We may override autoconf default CFLAGS.

AC_PROG_CC
AM_PROG_AS
AC_PROG_LIBTOOL
AC_CHECK_FUNCS([getisax])
AC_C_BIGENDIAN
AC_C_INLINE

dnl PIXMAN_LINK_WITH_ENV(env-setup, program, true-action, false-action)
dnl
dnl Compiles and links the given program in the environment setup by env-setup
dnl and executes true-action on success and false-action on failure.
AC_DEFUN([PIXMAN_LINK_WITH_ENV],[dnl
	save_CFLAGS="$CFLAGS"
	save_LDFLAGS="$LDFLAGS"
	save_LIBS="$LIBS"
	CFLAGS=""
	LDFLAGS=""
	LIBS=""
	$1
	CFLAGS="$save_CFLAGS $CFLAGS"
	LDFLAGS="$save_LDFLAGS $LDFLAGS"
	LIBS="$save_LIBS $LIBS"
	AC_LINK_IFELSE(
		[AC_LANG_SOURCE([$2])],
		[pixman_cc_stderr=`test -f conftest.err && cat conftest.err`
		 pixman_cc_flag=yes],
		[pixman_cc_stderr=`test -f conftest.err && cat conftest.err`
		 pixman_cc_flag=no])

	if test "x$pixman_cc_stderr" != "x"; then
		pixman_cc_flag=no
	fi

	if test "x$pixman_cc_flag" = "xyes"; then
		ifelse([$3], , :, [$3])
	else
		ifelse([$4], , :, [$4])
	fi
	CFLAGS="$save_CFLAGS"
	LDFLAGS="$save_LDFLAGS"
	LIBS="$save_LIBS"
])

dnl Find a -Werror for catching warnings.
WERROR=
for w in -Werror -errwarn; do
    if test "z$WERROR" = "z"; then
        AC_MSG_CHECKING([whether the compiler supports $w])
        PIXMAN_LINK_WITH_ENV(
		[CFLAGS=$w],
		[int main(int c, char **v) { (void)c; (void)v; return 0; }],
		[WERROR=$w; yesno=yes], [yesno=no])
	AC_MSG_RESULT($yesno)
    fi
done

dnl PIXMAN_CHECK_CFLAG(flag, [program])
dnl  Adds flag to CFLAGS if the given program links without warnings or errors.
AC_DEFUN([PIXMAN_CHECK_CFLAG], [dnl
	AC_MSG_CHECKING([whether the compiler supports $1])
	PIXMAN_LINK_WITH_ENV(
		[CFLAGS="$WERROR $1"],
		[$2
		 int main(int c, char **v) { (void)c; (void)v; return 0; }
		],
		[_yesno=yes],
		[_yesno=no])
	if test "x$_yesno" = xyes; then
	   CFLAGS="$CFLAGS $1"
	fi
	AC_MSG_RESULT($_yesno)
])

AC_CHECK_SIZEOF(long)

# Checks for Sun Studio compilers
AC_CHECK_DECL([__SUNPRO_C], [SUNCC="yes"], [SUNCC="no"])
AC_CHECK_DECL([__amd64], [AMD64_ABI="yes"], [AMD64_ABI="no"])

# Default CFLAGS to -O -g rather than just the -g from AC_PROG_CC
# if we're using Sun Studio and neither the user nor a config.site
# has set CFLAGS.
if test $SUNCC = yes &&			\
   test "x$test_CFLAGS" = "x" &&	\
   test "$CFLAGS" = "-g"
then
  CFLAGS="-O -g"
fi

# 
# We ignore pixman_major in the version here because the major version should
# always be encoded in the actual library name. Ie., the soname is:
#
#      pixman-$(pixman_major).0.minor.micro
#
m4_define([lt_current], [pixman_minor])
m4_define([lt_revision], [pixman_micro])
m4_define([lt_age], [pixman_minor])

LT_VERSION_INFO="lt_current:lt_revision:lt_age"

PIXMAN_VERSION_MAJOR=pixman_major()
AC_SUBST(PIXMAN_VERSION_MAJOR)
PIXMAN_VERSION_MINOR=pixman_minor()
AC_SUBST(PIXMAN_VERSION_MINOR)
PIXMAN_VERSION_MICRO=pixman_micro()
AC_SUBST(PIXMAN_VERSION_MICRO)

AC_SUBST(LT_VERSION_INFO)

# Check for dependencies

PIXMAN_CHECK_CFLAG([-Wall])
PIXMAN_CHECK_CFLAG([-Wdeclaration-after-statement])
PIXMAN_CHECK_CFLAG([-Wno-unused-local-typedefs])
PIXMAN_CHECK_CFLAG([-fno-strict-aliasing])

dnl =========================================================================
dnl OpenMP for the test suite?
dnl

# Check for OpenMP support only when autoconf support that (require autoconf >=2.62)
OPENMP_CFLAGS=
m4_ifdef([AC_OPENMP], [AC_OPENMP])

if test "x$enable_openmp" = "xyes" && test "x$ac_cv_prog_c_openmp" = "xunsupported" ; then
  AC_MSG_WARN([OpenMP support requested but found unsupported])
fi

dnl May not fail to link without -Wall -Werror added
dnl So try to link only when openmp is supported
dnl ac_cv_prog_c_openmp is not defined when --disable-openmp is used
if test "x$ac_cv_prog_c_openmp" != "xunsupported" && test "x$ac_cv_prog_c_openmp" != "x"; then
  m4_define([openmp_test_program],[dnl
  #include <stdio.h>

  extern unsigned int lcg_seed;
  #pragma omp threadprivate(lcg_seed)
  unsigned int lcg_seed;

  unsigned function(unsigned a, unsigned b)
  {
	lcg_seed ^= b;
	return ((a + b) ^ a ) + lcg_seed;
  }

  int main(int argc, char **argv)
  {
	int i;
	int n1 = 0, n2 = argc;
	unsigned checksum = 0;
	int verbose = argv != NULL;
	unsigned (*test_function)(unsigned, unsigned);
	test_function = function;
	#pragma omp parallel for reduction(+:checksum) default(none) \
					shared(n1, n2, test_function, verbose)
	for (i = n1; i < n2; i++)
	{
		unsigned crc = test_function (i, 0);
		if (verbose)
			printf ("%d: %08X\n", i, crc);
		checksum += crc;
	}
	printf("%u\n", checksum);
	return 0;
  }
  ])

  PIXMAN_LINK_WITH_ENV(
	[CFLAGS="$OPENMP_CFLAGS" LDFLAGS="$OPENMP_CFLAGS"],
	[openmp_test_program],
	[have_openmp=yes],
	[have_openmp=no])
  if test "x$have_openmp" = "xyes" ; then
    AC_DEFINE(USE_OPENMP, 1, [use OpenMP in the test suite])
  fi
fi
AC_SUBST(OPENMP_CFLAGS)

dnl =========================================================================
dnl -fvisibility stuff

PIXMAN_CHECK_CFLAG([-fvisibility=hidden], [dnl
#if defined(__GNUC__) && (__GNUC__ >= 4)
#ifdef _WIN32
#error Have -fvisibility but it is ignored and generates a warning
#endif
#else
#error Need GCC 4.0 for visibility
#endif
])

PIXMAN_CHECK_CFLAG([-xldscope=hidden], [dnl
#if defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
#else
#error Need Sun Studio 8 for visibility
#endif
])

dnl ===========================================================================
dnl Check for Loongson Multimedia Instructions

if test "x$LS_CFLAGS" = "x" ; then
    LS_CFLAGS="-march=loongson2f"
fi

have_loongson_mmi=no
AC_MSG_CHECKING(whether to use Loongson MMI assembler)

xserver_save_CFLAGS=$CFLAGS
CFLAGS=" $LS_CFLAGS $CFLAGS -I$srcdir"
AC_LINK_IFELSE([AC_LANG_SOURCE([[
#ifndef __mips_loongson_vector_rev
#error "Loongson Multimedia Instructions are only available on Loongson"
#endif
#if defined(__GNUC__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 4))
#error "Need GCC >= 4.4 for Loongson MMI compilation"
#endif
#include "pixman/loongson-mmintrin.h"
int main () {
    union {
        __m64 v;
        char c[8];
    } a = { .c = {1, 2, 3, 4, 5, 6, 7, 8} };
    int b = 4;
    __m64 c = _mm_srli_pi16 (a.v, b);
    return 0;
}]])], have_loongson_mmi=yes)
CFLAGS=$xserver_save_CFLAGS

AC_ARG_ENABLE(loongson-mmi,
   [AC_HELP_STRING([--disable-loongson-mmi],
                   [disable Loongson MMI fast paths])],
   [enable_loongson_mmi=$enableval], [enable_loongson_mmi=auto])

if test $enable_loongson_mmi = no ; then
   have_loongson_mmi=disabled
fi

if test $have_loongson_mmi = yes ; then
   AC_DEFINE(USE_LOONGSON_MMI, 1, [use Loongson Multimedia Instructions])
else
   LS_CFLAGS=
fi

AC_MSG_RESULT($have_loongson_mmi)
if test $enable_loongson_mmi = yes && test $have_loongson_mmi = no ; then
   AC_MSG_ERROR([Loongson MMI not detected])
fi

AM_CONDITIONAL(USE_LOONGSON_MMI, test $have_loongson_mmi = yes)

dnl ===========================================================================
dnl Check for MMX

if test "x$MMX_CFLAGS" = "x" ; then
   if test "x$SUNCC" = "xyes"; then
      # Sun Studio doesn't have an -xarch=mmx flag, so we have to use sse
      # but if we're building 64-bit, mmx & sse support is on by default and
      # -xarch=sse throws an error instead
      if test "$AMD64_ABI" = "no" ; then
         MMX_CFLAGS="-xarch=sse"
      fi
   else
      MMX_CFLAGS="-mmmx -Winline"
   fi
fi

have_mmx_intrinsics=no
AC_MSG_CHECKING(whether to use MMX intrinsics)
xserver_save_CFLAGS=$CFLAGS
CFLAGS="$MMX_CFLAGS $CFLAGS"
AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
#if defined(__GNUC__) && (__GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 4))
#error "Need GCC >= 3.4 for MMX intrinsics"
#endif
#include <mmintrin.h>
#include <stdint.h>

/* Check support for block expressions */
#define _mm_shuffle_pi16(A, N)						\
    ({									\
	__m64 ret;							\
									\
	/* Some versions of clang will choke on K */ 			\
	asm ("pshufw %2, %1, %0\n\t"					\
	     : "=y" (ret)						\
	     : "y" (A), "K" ((const int8_t)N)				\
	);								\
									\
	ret;								\
    })

int main () {
    __m64 v = _mm_cvtsi32_si64 (1);
    __m64 w;

    w = _mm_shuffle_pi16(v, 5);

    /* Some versions of clang will choke on this */
    asm ("pmulhuw %1, %0\n\t"
	: "+y" (w)
	: "y" (v)
    );

    return _mm_cvtsi64_si32 (v);
}]])], have_mmx_intrinsics=yes)
CFLAGS=$xserver_save_CFLAGS

AC_ARG_ENABLE(mmx,
   [AC_HELP_STRING([--disable-mmx],
                   [disable x86 MMX fast paths])],
   [enable_mmx=$enableval], [enable_mmx=auto])

if test $enable_mmx = no ; then
   have_mmx_intrinsics=disabled
fi

if test $have_mmx_intrinsics = yes ; then
   AC_DEFINE(USE_X86_MMX, 1, [use x86 MMX compiler intrinsics])
else
   MMX_CFLAGS=
fi

AC_MSG_RESULT($have_mmx_intrinsics)
if test $enable_mmx = yes && test $have_mmx_intrinsics = no ; then
   AC_MSG_ERROR([x86 MMX intrinsics not detected])
fi

AM_CONDITIONAL(USE_X86_MMX, test $have_mmx_intrinsics = yes)

dnl ===========================================================================
dnl Check for SSE2

if test "x$SSE2_CFLAGS" = "x" ; then
   if test "x$SUNCC" = "xyes"; then
      # SSE2 is enabled by default in the Sun Studio 64-bit environment
      if test "$AMD64_ABI" = "no" ; then
         SSE2_CFLAGS="-xarch=sse2"
      fi
   else
      SSE2_CFLAGS="-msse2 -Winline"
   fi
fi

have_sse2_intrinsics=no
AC_MSG_CHECKING(whether to use SSE2 intrinsics)
xserver_save_CFLAGS=$CFLAGS
CFLAGS="$SSE2_CFLAGS $CFLAGS"

AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
#if defined(__GNUC__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 2))
#   if !defined(__amd64__) && !defined(__x86_64__)
#      error "Need GCC >= 4.2 for SSE2 intrinsics on x86"
#   endif
#endif
#include <mmintrin.h>
#include <xmmintrin.h>
#include <emmintrin.h>
int param;
int main () {
    __m128i a = _mm_set1_epi32 (param), b = _mm_set1_epi32 (param + 1), c;
	c = _mm_xor_si128 (a, b);
    return _mm_cvtsi128_si32(c);
}]])], have_sse2_intrinsics=yes)
CFLAGS=$xserver_save_CFLAGS

AC_ARG_ENABLE(sse2,
   [AC_HELP_STRING([--disable-sse2],
                   [disable SSE2 fast paths])],
   [enable_sse2=$enableval], [enable_sse2=auto])

if test $enable_sse2 = no ; then
   have_sse2_intrinsics=disabled
fi

if test $have_sse2_intrinsics = yes ; then
   AC_DEFINE(USE_SSE2, 1, [use SSE2 compiler intrinsics])
fi

AC_MSG_RESULT($have_sse2_intrinsics)
if test $enable_sse2 = yes && test $have_sse2_intrinsics = no ; then
   AC_MSG_ERROR([SSE2 intrinsics not detected])
fi

AM_CONDITIONAL(USE_SSE2, test $have_sse2_intrinsics = yes)

dnl ===========================================================================
dnl Check for SSSE3

if test "x$SSSE3_CFLAGS" = "x" ; then
    SSSE3_CFLAGS="-mssse3 -Winline"
fi

have_ssse3_intrinsics=no
AC_MSG_CHECKING(whether to use SSSE3 intrinsics)
xserver_save_CFLAGS=$CFLAGS
CFLAGS="$SSSE3_CFLAGS $CFLAGS"

AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
#include <mmintrin.h>
#include <xmmintrin.h>
#include <emmintrin.h>
#include <tmmintrin.h>
int param;
int main () {
    __m128i a = _mm_set1_epi32 (param), b = _mm_set1_epi32 (param + 1), c;
    c = _mm_maddubs_epi16 (a, b);
    return _mm_cvtsi128_si32(c);
}]])], have_ssse3_intrinsics=yes)
CFLAGS=$xserver_save_CFLAGS

AC_ARG_ENABLE(ssse3,
   [AC_HELP_STRING([--disable-ssse3],
                   [disable SSSE3 fast paths])],
   [enable_ssse3=$enableval], [enable_ssse3=auto])

if test $enable_ssse3 = no ; then
   have_ssse3_intrinsics=disabled
fi

if test $have_ssse3_intrinsics = yes ; then
   AC_DEFINE(USE_SSSE3, 1, [use SSSE3 compiler intrinsics])
fi

AC_MSG_RESULT($have_ssse3_intrinsics)
if test $enable_ssse3 = yes && test $have_ssse3_intrinsics = no ; then
   AC_MSG_ERROR([SSSE3 intrinsics not detected])
fi

AM_CONDITIONAL(USE_SSSE3, test $have_ssse3_intrinsics = yes)

dnl ===========================================================================
dnl Other special flags needed when building code using MMX or SSE instructions
case $host_os in
   solaris*)
      # When building 32-bit binaries, apply a mapfile to ensure that the
      # binaries aren't flagged as only able to run on MMX+SSE capable CPUs
      # since they check at runtime before using those instructions.
      # Not all linkers grok the mapfile format so we check for that first.
      if test "$AMD64_ABI" = "no" ; then
	 use_hwcap_mapfile=no
	 AC_MSG_CHECKING(whether to use a hardware capability map file)
	 hwcap_save_LDFLAGS="$LDFLAGS"
	 HWCAP_LDFLAGS='-Wl,-M,$(srcdir)/solaris-hwcap.mapfile'
	 LDFLAGS="$LDFLAGS -Wl,-M,pixman/solaris-hwcap.mapfile"
	 AC_LINK_IFELSE([AC_LANG_SOURCE([[int main() { return 0; }]])],
			use_hwcap_mapfile=yes,
			HWCAP_LDFLAGS="")
	 LDFLAGS="$hwcap_save_LDFLAGS"
	 AC_MSG_RESULT($use_hwcap_mapfile)
      fi
      if test "x$MMX_LDFLAGS" = "x" ; then
         MMX_LDFLAGS="$HWCAP_LDFLAGS"
      fi
      if test "x$SSE2_LDFLAGS" = "x" ; then
	 SSE2_LDFLAGS="$HWCAP_LDFLAGS"
      fi
      ;;
esac

AC_SUBST(LS_CFLAGS)
AC_SUBST(IWMMXT_CFLAGS)
AC_SUBST(MMX_CFLAGS)
AC_SUBST(MMX_LDFLAGS)
AC_SUBST(SSE2_CFLAGS)
AC_SUBST(SSE2_LDFLAGS)
AC_SUBST(SSSE3_CFLAGS)

dnl ===========================================================================
dnl Check for VMX/Altivec
if test -n "`$CC -v 2>&1 | grep version | grep Apple`"; then
    VMX_CFLAGS="-faltivec"
else
    VMX_CFLAGS="-maltivec -mabi=altivec"
fi

have_vmx_intrinsics=no
AC_MSG_CHECKING(whether to use VMX/Altivec intrinsics)
xserver_save_CFLAGS=$CFLAGS
CFLAGS="$VMX_CFLAGS $CFLAGS"
AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
#if defined(__GNUC__) && (__GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 4))
#error "Need GCC >= 3.4 for sane altivec support"
#endif
#include <altivec.h>
int main () {
    vector unsigned int v = vec_splat_u32 (1);
    v = vec_sub (v, v);
    return 0;
}]])], have_vmx_intrinsics=yes)
CFLAGS=$xserver_save_CFLAGS

AC_ARG_ENABLE(vmx,
   [AC_HELP_STRING([--disable-vmx],
                   [disable VMX fast paths])],
   [enable_vmx=$enableval], [enable_vmx=auto])

if test $enable_vmx = no ; then
   have_vmx_intrinsics=disabled
fi

if test $have_vmx_intrinsics = yes ; then
   AC_DEFINE(USE_VMX, 1, [use VMX compiler intrinsics])
else
   VMX_CFLAGS=
fi

AC_MSG_RESULT($have_vmx_intrinsics)
if test $enable_vmx = yes && test $have_vmx_intrinsics = no ; then
   AC_MSG_ERROR([VMX intrinsics not detected])
fi

AC_SUBST(VMX_CFLAGS)

AM_CONDITIONAL(USE_VMX, test $have_vmx_intrinsics = yes)

dnl ==========================================================================
dnl Check if assembler is gas compatible and supports ARM SIMD instructions
have_arm_simd=no
AC_MSG_CHECKING(whether to use ARM SIMD assembler)
xserver_save_CFLAGS=$CFLAGS
CFLAGS="-x assembler-with-cpp $CFLAGS"
AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
.text
.arch armv6
.object_arch armv4
.arm
.altmacro
#ifndef __ARM_EABI__
#error EABI is required (to be sure that calling conventions are compatible)
#endif
pld [r0]
uqadd8 r0, r0, r0]])], have_arm_simd=yes)
CFLAGS=$xserver_save_CFLAGS

AC_ARG_ENABLE(arm-simd,
   [AC_HELP_STRING([--disable-arm-simd],
                   [disable ARM SIMD fast paths])],
   [enable_arm_simd=$enableval], [enable_arm_simd=auto])

if test $enable_arm_simd = no ; then
   have_arm_simd=disabled
fi

if test $have_arm_simd = yes ; then
   AC_DEFINE(USE_ARM_SIMD, 1, [use ARM SIMD assembly optimizations])
fi

AM_CONDITIONAL(USE_ARM_SIMD, test $have_arm_simd = yes)

AC_MSG_RESULT($have_arm_simd)
if test $enable_arm_simd = yes && test $have_arm_simd = no ; then
   AC_MSG_ERROR([ARM SIMD intrinsics not detected])
fi

dnl ==========================================================================
dnl Check if assembler is gas compatible and supports NEON instructions
have_arm_neon=no
AC_MSG_CHECKING(whether to use ARM NEON assembler)
xserver_save_CFLAGS=$CFLAGS
CFLAGS="-x assembler-with-cpp $CFLAGS"
AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
.text
.fpu neon
.arch armv7a
.object_arch armv4
.eabi_attribute 10, 0
.arm
.altmacro
#ifndef __ARM_EABI__
#error EABI is required (to be sure that calling conventions are compatible)
#endif
pld [r0]
vmovn.u16 d0, q0]])], have_arm_neon=yes)
CFLAGS=$xserver_save_CFLAGS

AC_ARG_ENABLE(arm-neon,
   [AC_HELP_STRING([--disable-arm-neon],
                   [disable ARM NEON fast paths])],
   [enable_arm_neon=$enableval], [enable_arm_neon=auto])

if test $enable_arm_neon = no ; then
   have_arm_neon=disabled
fi

if test $have_arm_neon = yes ; then
   AC_DEFINE(USE_ARM_NEON, 1, [use ARM NEON assembly optimizations])
fi

AM_CONDITIONAL(USE_ARM_NEON, test $have_arm_neon = yes)

AC_MSG_RESULT($have_arm_neon)
if test $enable_arm_neon = yes && test $have_arm_neon = no ; then
   AC_MSG_ERROR([ARM NEON intrinsics not detected])
fi

dnl ===========================================================================
dnl Check for IWMMXT

AC_ARG_ENABLE(arm-iwmmxt,
   [AC_HELP_STRING([--disable-arm-iwmmxt],
                   [disable ARM IWMMXT fast paths])],
   [enable_iwmmxt=$enableval], [enable_iwmmxt=auto])

AC_ARG_ENABLE(arm-iwmmxt2,
   [AC_HELP_STRING([--disable-arm-iwmmxt2],
                   [build ARM IWMMXT fast paths with -march=iwmmxt instead of -march=iwmmxt2])],
   [enable_iwmmxt2=$enableval], [enable_iwmmxt2=auto])

if test "x$IWMMXT_CFLAGS" = "x" ; then
   IWMMXT_CFLAGS="-flax-vector-conversions -Winline -march=iwmmxt"
   if test $enable_iwmmxt2 != no ; then
      IWMMXT_CFLAGS="${IWMMXT_CFLAGS}2"
   fi
fi

have_iwmmxt_intrinsics=no
AC_MSG_CHECKING(whether to use ARM IWMMXT intrinsics)
xserver_save_CFLAGS=$CFLAGS
CFLAGS="$CFLAGS $IWMMXT_CFLAGS"
AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
#ifndef __arm__
#error "IWMMXT is only available on ARM"
#endif
#ifndef __IWMMXT__
#error "IWMMXT not enabled (with -march=iwmmxt)"
#endif
#if defined(__GNUC__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8))
#error "Need GCC >= 4.8 for IWMMXT intrinsics"
#endif
#include <mmintrin.h>
int main () {
	union {
		__m64 v;
		char c[8];
	} a = { .c = {1, 2, 3, 4, 5, 6, 7, 8} };
	int b = 4;
	__m64 c = _mm_srli_si64 (a.v, b);
}]])], have_iwmmxt_intrinsics=yes)
CFLAGS=$xserver_save_CFLAGS

if test $enable_iwmmxt = no ; then
   have_iwmmxt_intrinsics=disabled
fi

if test $have_iwmmxt_intrinsics = yes ; then
   AC_DEFINE(USE_ARM_IWMMXT, 1, [use ARM IWMMXT compiler intrinsics])
else
   IWMMXT_CFLAGS=
fi

AC_MSG_RESULT($have_iwmmxt_intrinsics)
if test $enable_iwmmxt = yes && test $have_iwmmxt_intrinsics = no ; then
   AC_MSG_ERROR([IWMMXT intrinsics not detected])
fi

AM_CONDITIONAL(USE_ARM_IWMMXT, test $have_iwmmxt_intrinsics = yes)

dnl ==========================================================================
dnl Check if assembler is gas compatible and supports MIPS DSPr2 instructions

have_mips_dspr2=no
AC_MSG_CHECKING(whether to use MIPS DSPr2 assembler)
xserver_save_CFLAGS=$CFLAGS
CFLAGS="-mdspr2 $CFLAGS"

AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
#if !(defined(__mips__) &&  __mips_isa_rev >= 2)
#error MIPS DSPr2 is currently only available on MIPS32r2 platforms.
#endif
int
main ()
{
    int c = 0, a = 0, b = 0;
    __asm__ __volatile__ (
        "precr.qb.ph %[c], %[a], %[b]          \n\t"
        : [c] "=r" (c)
        : [a] "r" (a), [b] "r" (b)
    );
    return c;
}]])], have_mips_dspr2=yes)
CFLAGS=$xserver_save_CFLAGS

AC_ARG_ENABLE(mips-dspr2,
   [AC_HELP_STRING([--disable-mips-dspr2],
                   [disable MIPS DSPr2 fast paths])],
   [enable_mips_dspr2=$enableval], [enable_mips_dspr2=auto])

if test $enable_mips_dspr2 = no ; then
   have_mips_dspr2=disabled
fi

if test $have_mips_dspr2 = yes ; then
   AC_DEFINE(USE_MIPS_DSPR2, 1, [use MIPS DSPr2 assembly optimizations])
fi

AM_CONDITIONAL(USE_MIPS_DSPR2, test $have_mips_dspr2 = yes)

AC_MSG_RESULT($have_mips_dspr2)
if test $enable_mips_dspr2 = yes && test $have_mips_dspr2 = no ; then
   AC_MSG_ERROR([MIPS DSPr2 instructions not detected])
fi

dnl =========================================================================================
dnl Check for GNU-style inline assembly support

have_gcc_inline_asm=no
AC_MSG_CHECKING(whether to use GNU-style inline assembler)
AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
int main () {
    /* Most modern architectures have a NOP instruction, so this is a fairly generic test. */
	asm volatile ( "\tnop\n" : : : "cc", "memory" );
    return 0;
}]])], have_gcc_inline_asm=yes)

AC_ARG_ENABLE(gcc-inline-asm,
   [AC_HELP_STRING([--disable-gcc-inline-asm],
                   [disable GNU-style inline assembler])],
   [enable_gcc_inline_asm=$enableval], [enable_gcc_inline_asm=auto])

if test $enable_gcc_inline_asm = no ; then
   have_gcc_inline_asm=disabled
fi

if test $have_gcc_inline_asm = yes ; then
   AC_DEFINE(USE_GCC_INLINE_ASM, 1, [use GNU-style inline assembler])
fi

AC_MSG_RESULT($have_gcc_inline_asm)
if test $enable_gcc_inline_asm = yes && test $have_gcc_inline_asm = no ; then
   AC_MSG_ERROR([GNU-style inline assembler not detected])
fi

AM_CONDITIONAL(USE_GCC_INLINE_ASM, test $have_gcc_inline_asm = yes)

dnl ==============================================
dnl Static test programs

AC_ARG_ENABLE(static-testprogs,
   [AC_HELP_STRING([--enable-static-testprogs],
		   [build test programs as static binaries [default=no]])],
   [enable_static_testprogs=$enableval], [enable_static_testprogs=no])

TESTPROGS_EXTRA_LDFLAGS=
if test "x$enable_static_testprogs" = "xyes" ; then
   TESTPROGS_EXTRA_LDFLAGS="-all-static"
fi
AC_SUBST(TESTPROGS_EXTRA_LDFLAGS)

dnl ==============================================
dnl Timers

AC_ARG_ENABLE(timers,
   [AC_HELP_STRING([--enable-timers],
		   [enable TIMER_BEGIN and TIMER_END macros [default=no]])],
   [enable_timers=$enableval], [enable_timers=no])

if test $enable_timers = yes ; then 
   AC_DEFINE(PIXMAN_TIMERS, 1, [enable TIMER_BEGIN/TIMER_END macros])
fi
AC_SUBST(PIXMAN_TIMERS)

dnl ===================================
dnl GTK+

AC_ARG_ENABLE(gtk,
   [AC_HELP_STRING([--enable-gtk],
                   [enable tests using GTK+ [default=auto]])],
   [enable_gtk=$enableval], [enable_gtk=auto])

PKG_PROG_PKG_CONFIG

if test $enable_gtk = yes ; then
   AC_CHECK_LIB([pixman-1], [pixman_version_string])
   PKG_CHECK_MODULES(GTK, [gtk+-2.0 >= 2.16 pixman-1])
fi

if test $enable_gtk = auto ; then
   AC_CHECK_LIB([pixman-1], [pixman_version_string], [enable_gtk=auto], [enable_gtk=no])
fi

if test $enable_gtk = auto ; then
   PKG_CHECK_MODULES(GTK, [gtk+-2.0 >= 2.16 pixman-1], [enable_gtk=yes], [enable_gtk=no])
fi

AM_CONDITIONAL(HAVE_GTK, [test "x$enable_gtk" = xyes])

AC_SUBST(GTK_CFLAGS)
AC_SUBST(GTK_LIBS)

dnl =====================================
dnl posix_memalign, sigaction, alarm, gettimeofday

AC_CHECK_FUNC(posix_memalign, have_posix_memalign=yes, have_posix_memalign=no)
if test x$have_posix_memalign = xyes; then
   AC_DEFINE(HAVE_POSIX_MEMALIGN, 1, [Whether we have posix_memalign()])
fi

AC_CHECK_FUNC(sigaction, have_sigaction=yes, have_sigaction=no)
if test x$have_sigaction = xyes; then
   AC_DEFINE(HAVE_SIGACTION, 1, [Whether we have sigaction()])
fi

AC_CHECK_FUNC(alarm, have_alarm=yes, have_alarm=no)
if test x$have_alarm = xyes; then
   AC_DEFINE(HAVE_ALARM, 1, [Whether we have alarm()])
fi

AC_CHECK_HEADER([sys/mman.h],
   [AC_DEFINE(HAVE_SYS_MMAN_H, [1], [Define to 1 if we have <sys/mman.h>])])

AC_CHECK_FUNC(mmap, have_mmap=yes, have_mmap=no)
if test x$have_mmap = xyes; then
   AC_DEFINE(HAVE_MMAP, 1, [Whether we have mmap()])
fi

AC_CHECK_FUNC(mprotect, have_mprotect=yes, have_mprotect=no)
if test x$have_mprotect = xyes; then
   AC_DEFINE(HAVE_MPROTECT, 1, [Whether we have mprotect()])
fi

AC_CHECK_FUNC(getpagesize, have_getpagesize=yes, have_getpagesize=no)
if test x$have_getpagesize = xyes; then
   AC_DEFINE(HAVE_GETPAGESIZE, 1, [Whether we have getpagesize()])
fi

AC_CHECK_HEADER([fenv.h],
   [AC_DEFINE(HAVE_FENV_H, [1], [Define to 1 if we have <fenv.h>])])

AC_CHECK_LIB(m, feenableexcept, have_feenableexcept=yes, have_feenableexcept=no)
if test x$have_feenableexcept = xyes; then
   AC_DEFINE(HAVE_FEENABLEEXCEPT, 1, [Whether we have feenableexcept()])
fi

AC_CHECK_DECL([FE_DIVBYZERO],
	[AC_DEFINE(HAVE_FEDIVBYZERO, 1, [Whether we have FE_DIVBYZERO])],
	[],
	[[#include <fenv.h>]])

AC_CHECK_FUNC(gettimeofday, have_gettimeofday=yes, have_gettimeofday=no)
AC_CHECK_HEADER(sys/time.h, have_sys_time_h=yes, have_sys_time_h=no)
if test x$have_gettimeofday = xyes && test x$have_sys_time_h = xyes; then
   AC_DEFINE(HAVE_GETTIMEOFDAY, 1, [Whether we have gettimeofday()])
fi

dnl =====================================
dnl Check for missing sqrtf() as, e.g., for Solaris 9

AC_SEARCH_LIBS([sqrtf], [m], [],
               [AC_DEFINE([sqrtf], [sqrt],
                          [Define to sqrt if you do not have the `sqrtf' function.])])

dnl =====================================
dnl Thread local storage

AC_MSG_CHECKING(for thread local storage (TLS) support)
AC_CACHE_VAL(ac_cv_tls, [
    ac_cv_tls=none
    keywords="__thread __declspec(thread)"
    for kw in $keywords ; do
        AC_TRY_COMPILE([
#if defined(__MINGW32__) && !(__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
#error This MinGW version has broken __thread support
#endif
#ifdef __OpenBSD__
#error OpenBSD has broken __thread support
#endif

int $kw test;], [], [ac_cv_tls=$kw; break])
    done
])
AC_MSG_RESULT($ac_cv_tls)

if test "$ac_cv_tls" != "none"; then
    AC_DEFINE_UNQUOTED([TLS], $ac_cv_tls, [The compiler supported TLS storage class])
fi

dnl
dnl posix tls
dnl

m4_define([pthread_test_program],AC_LANG_SOURCE([[dnl
#include <stdlib.h>
#include <pthread.h>

static pthread_once_t once_control = PTHREAD_ONCE_INIT;
static pthread_key_t key;

static void
make_key (void)
{
    pthread_key_create (&key, NULL);
}

int
main ()
{
    void *value = NULL;

    if (pthread_once (&once_control, make_key) != 0)
    {
	value = NULL;
    }
    else
    {
	value = pthread_getspecific (key);
	if (!value)
	{
	    value = malloc (100);
	    pthread_setspecific (key, value);
	}
    }
    return 0;
}
]]))

AC_DEFUN([PIXMAN_CHECK_PTHREAD],[dnl
    if test "z$support_for_pthreads" != "zyes"; then
	PIXMAN_LINK_WITH_ENV(
		[$1], [pthread_test_program],
		[PTHREAD_CFLAGS="$CFLAGS"
		 PTHREAD_LIBS="$LIBS"
		 PTHREAD_LDFLAGS="$LDFLAGS"
		 support_for_pthreads=yes])
    fi
])

support_for_pthreads=no

AC_MSG_CHECKING(for pthreads)

PIXMAN_CHECK_PTHREAD([CFLAGS=""; LIBS="-L/usr/X11R6/lib -lpthread-stubs"])
PIXMAN_CHECK_PTHREAD([CFLAGS="-pthread"; LDFLAGS="-pthread"])
PIXMAN_CHECK_PTHREAD([CFLAGS="-D_REENTRANT"; LIBS="-lpthread"])
PIXMAN_CHECK_PTHREAD([CFLAGS="-D_REENTRANT"; LDFLAGS="-lroot"])
    
if test $support_for_pthreads = yes; then
    AC_DEFINE([HAVE_PTHREADS], [], [Whether pthreads is supported])
    if test $ac_cv_tls = none ; then
        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
    fi
fi

AC_MSG_RESULT($support_for_pthreads)

AC_SUBST(TOOLCHAIN_SUPPORTS__THREAD)
AC_SUBST(HAVE_PTHREADS)
AC_SUBST(PTHREAD_LDFLAGS)
AC_SUBST(PTHREAD_LIBS)
AC_SUBST(PTHREAD_CFLAGS)

dnl =====================================
dnl __attribute__((constructor))

support_for_attribute_constructor=no

AC_MSG_CHECKING(for __attribute__((constructor)))
AC_LINK_IFELSE([AC_LANG_SOURCE([[
#if defined(__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7))
/* attribute 'constructor' is supported since gcc 2.7, but some compilers
 * may only pretend to be gcc, so let's try to actually use it
 */
static int x = 1;
static void __attribute__((constructor)) constructor_function () { x = 0; }
int main (void) { return x; }
#else
#error not gcc or gcc version is older than 2.7
#endif
]])], support_for_attribute_constructor=yes)

if test x$support_for_attribute_constructor = xyes; then
   AC_DEFINE([TOOLCHAIN_SUPPORTS_ATTRIBUTE_CONSTRUCTOR],
             [],[Whether the tool chain supports __attribute__((constructor))])
fi

AC_MSG_RESULT($support_for_attribute_constructor)
AC_SUBST(TOOLCHAIN_SUPPORTS_ATTRIBUTE_CONSTRUCTOR)

dnl =====================================
dnl __float128

support_for_float128=no

AC_MSG_CHECKING(for __float128)
AC_LINK_IFELSE([AC_LANG_SOURCE([[
__float128 a = 1.0Q, b = 2.0Q; int main (void) { return a + b; }
]])], support_for_float128=yes)

if test x$support_for_float128 = xyes; then
   AC_DEFINE([HAVE_FLOAT128], [], [Whether the tool chain supports __float128])
fi

AC_MSG_RESULT($support_for_float128)

dnl =====================================
dnl __builtin_clz

support_for_builtin_clz=no

AC_MSG_CHECKING(for __builtin_clz)
AC_LINK_IFELSE([AC_LANG_SOURCE([[
unsigned int x = 11; int main (void) { return __builtin_clz(x); }
]])], support_for_builtin_clz=yes)

if test x$support_for_builtin_clz = xyes; then
   AC_DEFINE([HAVE_BUILTIN_CLZ], [], [Whether the compiler supports __builtin_clz])
fi

AC_MSG_RESULT($support_for_builtin_clz)

dnl =====================================
dnl GCC vector extensions

support_for_gcc_vector_extensions=no

AC_MSG_CHECKING(for GCC vector extensions)
AC_LINK_IFELSE([AC_LANG_SOURCE([[
unsigned int __attribute__ ((vector_size(16))) e, a, b;
int main (void) { e = a - ((b << 27) + (b >> (32 - 27))) + 1; return e[0]; }
]])], support_for_gcc_vector_extensions=yes)

if test x$support_for_gcc_vector_extensions = xyes; then
   AC_DEFINE([HAVE_GCC_VECTOR_EXTENSIONS], [],
             [Whether the compiler supports GCC vector extensions])
fi

AC_MSG_RESULT($support_for_gcc_vector_extensions)

dnl ==================
dnl libpng

AC_ARG_ENABLE(libpng, AS_HELP_STRING([--enable-libpng], [Build support for libpng (default: auto)]),
                      [have_libpng=$enableval], [have_libpng=auto])

case x$have_libpng in
	xyes) PKG_CHECK_MODULES(PNG, [libpng]) ;;
	xno) ;;
	*) PKG_CHECK_MODULES(PNG, [libpng], have_libpng=yes, have_libpng=no) ;;
esac

if test x$have_libpng = xyes; then
    AC_DEFINE([HAVE_LIBPNG], [1], [Whether we have libpng])
fi

AC_SUBST(HAVE_LIBPNG)

AC_OUTPUT([pixman-1.pc
           pixman-1-uninstalled.pc
           Makefile
	   pixman/Makefile
	   pixman/pixman-version.h
	   demos/Makefile
	   test/Makefile])

m4_if(m4_eval(pixman_minor % 2), [1], [
   echo
   echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
   echo
   echo "      Thanks for testing this development snapshot of pixman. Please"
   echo "      report any problems you find, either by sending email to "
   echo
   echo "          pixman@@lists.freedesktop.org"
   echo
   echo "      or by filing a bug at "
   echo
   echo "          https://bugs.freedesktop.org/enter_bug.cgi?product=pixman "
   echo
   echo "      If you are looking for a stable release of pixman, please note "
   echo "      that stable releases have _even_ minor version numbers. Ie., "
   echo "      pixman-0.]m4_eval(pixman_minor & ~1)[.x are stable releases, whereas pixman-$PIXMAN_VERSION_MAJOR.$PIXMAN_VERSION_MINOR.$PIXMAN_VERSION_MICRO is a "
   echo "      development snapshot that may contain bugs and experimental "
   echo "      features. "
   echo 
   echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
   echo
])
@


1.23
log
@Update to pixman 0.34.0.
@
text
@d64 2
@


1.22
log
@Update to pixman 0.32.8.
@
text
@d56 2
a57 2
m4_define([pixman_minor], 32)
m4_define([pixman_micro], 8)
d187 1
d350 16
d370 1
a370 5
    /* Some versions of clang will choke on K */
    asm ("pshufw %2, %1, %0\n\t"
        : "=y" (w)
        : "y" (v), "K" (5)
    );
d432 1
d434 1
a434 1
    __m128i a = _mm_set1_epi32 (0), b = _mm_set1_epi32 (0), c;
d436 1
a436 1
    return 0;
d477 1
d479 1
a479 1
    __m128i a = _mm_set1_epi32 (0), b = _mm_set1_epi32 (0), c;
d481 1
a481 1
    return 0;
d907 5
@


1.21
log
@Update to pixman 0.32.6
@
text
@d57 1
a57 1
m4_define([pixman_micro], 6)
@


1.20
log
@Update to pixman 0.32.4. Tested by naddy@@ and ajacoutot@@
@
text
@d57 1
a57 1
m4_define([pixman_micro], 4)
d1063 18
@


1.19
log
@Update to pixman 0.30.2. No functional change.
@
text
@d56 2
a57 2
m4_define([pixman_minor], 30)
m4_define([pixman_micro], 2)
d186 1
d359 6
d447 44
d525 1
d686 2
a687 2
#if defined(__GNUC__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 5))
#error "Need GCC >= 4.5 for IWMMXT intrinsics"
d971 1
a971 1
    if test "z$support_for_pthread_setspecific" != "zyes"; then
d977 1
a977 1
		 support_for_pthread_setspecific=yes])
d981 1
a981 2
if test $ac_cv_tls = none ; then
    support_for_pthread_setspecific=no
d983 1
a983 1
    AC_MSG_CHECKING(for pthread_setspecific)
d985 4
a988 4
    PIXMAN_CHECK_PTHREAD([CFLAGS=""; LIBS="-L/usr/X11R6/lib -lpthread-stubs"])
    PIXMAN_CHECK_PTHREAD([CFLAGS="-pthread"; LDFLAGS="-pthread"])
    PIXMAN_CHECK_PTHREAD([CFLAGS="-D_REENTRANT"; LIBS="-lpthread"])
    PIXMAN_CHECK_PTHREAD([CFLAGS="-D_REENTRANT"; LDFLAGS="-lroot"])
d990 4
a993 3
    if test $support_for_pthread_setspecific = yes; then
	CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
	AC_DEFINE([HAVE_PTHREAD_SETSPECIFIC], [], [Whether pthread_setspecific() is supported])
d995 1
d997 1
a997 2
    AC_MSG_RESULT($support_for_pthread_setspecific);
fi
d1000 1
a1000 1
AC_SUBST(HAVE_PTHREAD_SETSPECIFIC)
d1003 1
d1047 16
@


1.18
log
@Get rid of a bash-ism
@
text
@d57 1
a57 1
m4_define([pixman_micro], 0)
d282 1
a282 1
AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
d781 1
a781 1
   PKG_CHECK_MODULES(GTK, [gtk+-2.0 pixman-1])
d789 1
a789 1
   PKG_CHECK_MODULES(GTK, [gtk+-2.0 pixman-1], [enable_gtk=yes], [enable_gtk=no])
@


1.17
log
@Update to pixman 0.30.0. Tested by several people during t2k13. Thanks.
@
text
@d619 1
a619 1
      IWMMXT_CFLAGS+="2"
@


1.16
log
@Update to pixman 0.28.0. Tested by ajacoutot@@, mpi@@ and naddy@@ in a full
ports build. Tweaks from mpi@@ for macppc.
@
text
@d56 1
a56 1
m4_define([pixman_minor], 28)
d67 1
a67 1
AM_CONFIG_HEADER(config.h)
d848 7
d870 1
a870 1
int $kw test;], [], ac_cv_tls=$kw)
d978 16
@


1.15
log
@Update to pixman 0.26.2. tested at least by ajacoutot@@, mpi@@, shadchin@@.
@
text
@d56 2
a57 2
m4_define([pixman_minor], 26)
m4_define([pixman_micro], 2)
d92 3
a187 6
AC_PATH_PROG(PERL, perl, no)
if test "x$PERL" = xno; then
    AC_MSG_ERROR([Perl is required to build pixman.])
fi
AC_SUBST(PERL)

a350 1
    signed char x = 0;
d355 1
a355 1
        : "y" (v), "K" (x)
a795 2
AC_SUBST(DEP_CFLAGS)
AC_SUBST(DEP_LIBS)
d928 1
a929 1
    PIXMAN_CHECK_PTHREAD([CFLAGS="-pthread"; LDFLAGS="-pthread"])
@


1.14
log
@Update to pixman 0.22.4. Tested by shadchin@@, krw@@.
@
text
@d56 2
a57 2
m4_define([pixman_minor], 24)
m4_define([pixman_micro], 4)
d262 1
a262 1
error Need GCC 4.0 for visibility
d269 1
a269 1
error Need Sun Studio 8 for visibility
d274 53
d348 1
a348 1
error "Need GCC >= 3.4 for MMX intrinsics"
d353 9
d472 2
d493 1
a493 1
error "Need GCC >= 3.4 for sane altivec support"
d610 10
d621 4
a624 1
   IWMMXT_CFLAGS="-march=iwmmxt -flax-vector-conversions -Winline"
d630 2
a631 2
CFLAGS="$IWMMXT_CFLAGS $CFLAGS"
AC_COMPILE_IFELSE([
d635 5
a639 2
#if defined(__GNUC__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 6))
#error "Need GCC >= 4.6 for IWMMXT intrinsics"
d645 1
a645 1
		[char c[8];]
d649 1
a649 1
}], have_iwmmxt_intrinsics=yes)
a651 5
AC_ARG_ENABLE(arm-iwmmxt,
   [AC_HELP_STRING([--disable-arm-iwmmxt],
                   [disable ARM IWMMXT fast paths])],
   [enable_iwmmxt=$enableval], [enable_iwmmxt=auto])

d669 45
d856 6
a861 4
support_for__thread=no

AC_MSG_CHECKING(for __thread)
AC_LINK_IFELSE([AC_LANG_SOURCE([[
a867 3
static __thread int x ;
int main () { x = 123; return x; }
]])], support_for__thread=yes)
d869 7
a875 2
if test $support_for__thread = yes; then 
   AC_DEFINE([TOOLCHAIN_SUPPORTS__THREAD],[],[Whether the tool chain supports __thread])
d878 1
a878 2
AC_MSG_RESULT($support_for__thread)

d880 1
d882 1
a882 17
if test $support_for__thread = no; then

support_for_pthread_stubs_setspecific=no
   
AC_MSG_CHECKING(for pthread_setspecific in libpthread_stubs)

save_LDFLAGS=$LDFLAGS
save_CFLAGS=$CFLAGS

PKG_CHECK_MODULES(STUBS, pthread-stubs)

CFLAGS="${STUBS_CFLAGS}"
LDFLAGS="${STUBS_LIBS}"

AC_LINK_IFELSE([
#include <pthread.h>

d913 1
d915 1
a915 1
], support_for_pthread_stubs_setspecific=yes);
d917 10
a926 2
CFLAGS=$save_CFLAGS
LDFLAGS=$save_LDFLAGS
d928 2
a929 26
if test $support_for_pthread_stubs_setspecific = yes; then
   PTHREAD_LDFLAGS="${STUBS_LIBS}"
   PTHREAD_CFLAGS="${STUBS_CFLAGS}"
   AC_DEFINE([HAVE_PTHREAD_SETSPECIFIC], [], [Whether pthread_setspecific() is supported])
fi

AC_MSG_RESULT($support_for_pthread_stubs_setspecific);

fi

if test $support_for_pthread_stubs_setspecific = no; then

AC_MSG_CHECKING(for pthread_setspecific)

save_LDFLAGS=$LDFLAGS

LDFLAGS="-pthread"

AC_LINK_IFELSE([
#include <pthread.h>

#include <stdlib.h>
#include <pthread.h>

static pthread_once_t once_control = PTHREAD_ONCE_INIT;
static pthread_key_t key;
d931 1
a931 5
static void
make_key (void)
{
    pthread_key_create (&key, NULL);
}
d933 4
a936 4
int
main ()
{
    void *value = NULL;
d938 4
a941 17
    if (pthread_once (&once_control, make_key) != 0)
    {
	value = NULL;
    }
    else
    {
	value = pthread_getspecific (key);
	if (!value)
	{
	    value = malloc (100);
	    pthread_setspecific (key, value);
	}
    }
    return 0;
}
])
fi 
d943 2
d981 8
a988 1
PKG_CHECK_MODULES(PNG, [libpng], have_libpng=yes, have_libpng=no)
@


1.13
log
@remove -mmmx from SSE2_FLAGS It's implied by -msse2 and is not in
upstreams distrib. This was a silly attempt to fix the amd64 issues
on my side.
@
text
@d29 2
a30 2
#   - Released versions both development and stable have an even MICRO 
#     version number
d56 2
a57 2
m4_define([pixman_minor], 22)
m4_define([pixman_micro], 2)
d93 1
a93 1
		[$2],
d153 1
a153 1
   test "$test_CFLAGS" == "" &&		\
d293 1
a293 1
AC_COMPILE_IFELSE([
d301 1
a301 1
}], have_mmx_intrinsics=yes)
d306 1
a306 1
                   [disable MMX fast paths])],
d314 1
a314 1
   AC_DEFINE(USE_MMX, 1, [use MMX compiler intrinsics])
d321 1
a321 1
   AC_MSG_ERROR([MMX intrinsics not detected])
d324 1
a324 1
AM_CONDITIONAL(USE_MMX, test $have_mmx_intrinsics = yes)
d345 1
a345 1
AC_COMPILE_IFELSE([
d358 1
a358 1
}], have_sse2_intrinsics=yes)
d395 1
a395 1
	 AC_LINK_IFELSE([int main() { return 0; }],
d427 1
a427 1
AC_COMPILE_IFELSE([
d436 1
a436 1
}], have_vmx_intrinsics=yes)
d469 1
a469 1
AC_COMPILE_IFELSE([[
d479 1
a479 1
uqadd8 r0, r0, r0]], have_arm_simd=yes)
d508 1
a508 1
AC_COMPILE_IFELSE([[
d520 1
a520 1
vmovn.u16 d0, q0]], have_arm_neon=yes)
d543 51
d599 1
a599 1
AC_COMPILE_IFELSE([
d604 1
a604 1
}], have_gcc_inline_asm=yes)
d739 1
a739 1
AC_LINK_IFELSE([
d748 1
a748 1
], support_for__thread=yes)
d879 1
a879 1
AC_LINK_IFELSE([
d890 1
a890 1
], support_for_attribute_constructor=yes)
d899 11
@


1.12
log
@Update to pixman 0.22.2.
0.22.0 was tested by many. 0.22.2 only add a few bug fixes.
Note that on amd64 a recent ld.so is needed to avoid random bus errors.
@
text
@d336 1
a336 1
      SSE2_CFLAGS="-mmmx -msse2 -Winline"
@


1.11
log
@Bug-fix upgrade to pixman 0.20.2. No API/ABI change.
tested by shadchin@@, ajacoutot@@, krw@@, ok miod@@
@
text
@d56 1
a56 1
m4_define([pixman_minor], 20)
d61 1
a61 1
AC_INIT(pixman, pixman_version, "pixman@@lists.freedesktop.org", pixman)
d122 1
a122 1
	AC_MSG_RESULT($_yesno)
d195 1
a195 1
# Check for OpenMP support (only supported by autoconf >=2.62)
d199 3
a201 2
m4_define([openmp_test_program],[dnl
#include <stdio.h>
d203 10
a212 3
extern unsigned int lcg_seed;
#pragma omp threadprivate(lcg_seed)
unsigned int lcg_seed;
d214 2
a215 2
unsigned function(unsigned a, unsigned b)
{
d218 1
a218 1
}
d220 2
a221 2
int main(int argc, char **argv)
{
d228 1
a228 1
    #pragma omp parallel for reduction(+:checksum) default(none) \
d231 1
a231 1
    	{
d239 2
a240 2
}
])
d242 1
a242 1
PIXMAN_LINK_WITH_ENV(
d247 3
a249 4
if test "x$have_openmp" = "xyes"; then
   AC_DEFINE(USE_OPENMP, 1, [use OpenMP in the test suite])
else
   OPENMP_CFLAGS=""
d576 14
d653 5
d668 8
d822 27
d854 1
d856 23
@


1.10
log
@Update to pixman 0.20.0.
tested by ajacoutot@@, krw@@ and on a bulk ports build by landry@@.
@
text
@d57 1
a57 1
m4_define([pixman_micro], 0)
d655 1
a655 1
#ifdef defined __MINGW32__ && !(__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
a656 1
#endif
@


1.9
log
@Update to pixman 0.18.4.

Tweak build to use libpthread-stubs for TLS emulation instead of forcing
every application using pixman to use -pthread.

Tested by jasper@@ and landry@@ on a bulk ports build.
@
text
@d56 2
a57 2
m4_define([pixman_minor], 18)
m4_define([pixman_micro], 4)
d80 63
a180 4
#PKG_CHECK_MODULES(DEP, x11)

changequote(,)dnl
if test "x$GCC" = "xyes"; then
d182 2
a183 11
  case " $CFLAGS " in
  *[\ \	]-Wall[\ \	]*) ;;
  *) CFLAGS="$CFLAGS -Wall" ;;
  esac 

  case " $CFLAGS " in
  *[\ \	]-fno-strict-aliasing[\ \	]*) ;;
  *) CFLAGS="$CFLAGS -fno-strict-aliasing" ;;
  esac

fi changequote([,])dnl
d192 55
d249 1
a249 3
have_gcc4=no
AC_MSG_CHECKING(for -fvisibility)
AC_COMPILE_IFELSE([
d251 3
d257 1
a257 7
int main () { return 0; } 
], have_gcc4=yes)

if test "x$have_gcc4" = "xyes"; then
   CFLAGS="$CFLAGS -fvisibility=hidden"
fi
AC_MSG_RESULT($have_gcc4)
d259 1
a259 3
have_sunstudio8=no
AC_MSG_CHECKING([for -xldscope (Sun compilers)])
AC_COMPILE_IFELSE([
d264 1
a264 7
int main () { return 0; } 
], have_sunstudio8=yes)

if test "x$have_sunstudio8" = "xyes"; then
   CFLAGS="$CFLAGS -xldscope=hidden"
fi
AC_MSG_RESULT($have_sunstudio8)
d590 6
d597 1
a597 1
   PKG_CHECK_EXISTS([gtk+-2.0], [enable_gtk=yes], [enable_gtk=no])
d599 3
a601 2
if test $enable_gtk = yes ; then
   PKG_CHECK_MODULES(GTK, [gtk+-2.0])
d612 1
a612 1
dnl posix_memalign 
d619 29
d654 7
a660 3
AC_COMPILE_IFELSE([
#ifdef __MINGW32__
#error MinGW has broken __thread support
d662 2
a663 2
__thread int x ;
int main () { return 0; }
d707 1
a707 1
    
d778 1
d780 2
a781 1
], support_for_pthread_setspecific=yes);
a782 10
LDFLAGS=$save_LDFLAGS

if test $support_for_pthread_setspecific = yes; then
   PTHREAD_LDFLAGS="-pthread"
   AC_DEFINE([HAVE_PTHREAD_SETSPECIFIC], [], [Whether pthread_setspecific() is supported])
fi

AC_MSG_RESULT($support_for_pthread_setspecific);

fi
d787 1
@


1.8
log
@Update to pixman 0.16.6. Tested on a full ports build by naddy@@.
@
text
@d56 2
a57 2
m4_define([pixman_minor], 16)
m4_define([pixman_micro], 6)
d61 5
a65 2
AC_INIT(pixman, pixman_version, "sandmann@@daimi.au.dk", pixman)
AM_INIT_AUTOMAKE([dist-bzip2])
d74 1
d80 2
d195 2
a196 2
#if defined(__GNUC__) && (__GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 3))
error "Need GCC >= 3.3 for MMX intrinsics"
d256 1
a256 1
    __m128i a, b, c;
d364 2
a365 4
dnl ===========================================================================
dnl Check for ARM SIMD instructions
ARM_SIMD_CFLAGS="-mcpu=arm1136j-s"

d369 12
a380 6
CFLAGS="$ARM_SIMD_CFLAGS $CFLAGS"
AC_COMPILE_IFELSE([
int main () {
    asm("uqadd8 r1, r1, r2");
    return 0;
}], have_arm_simd=yes)
d393 1
a393 3
   AC_DEFINE(USE_ARM_SIMD, 1, [use ARM SIMD compiler intrinsics])
else
   ARM_SIMD_CFLAGS=
d396 2
a402 4
AC_SUBST(ARM_SIMD_CFLAGS)

AM_CONDITIONAL(USE_ARM_SIMD, test $have_arm_simd = yes)

d404 1
a404 3
dnl Check for ARM NEON instructions
ARM_NEON_CFLAGS="-mfpu=neon -mcpu=cortex-a8"

d406 1
a406 1
AC_MSG_CHECKING(whether to use ARM NEON)
d408 14
a421 7
CFLAGS="$ARM_NEON_CFLAGS $CFLAGS"
AC_COMPILE_IFELSE([
#include <arm_neon.h>
int main () {
    uint8x8_t neon_test=vmov_n_u8(0);
    return 0;
}], have_arm_neon=yes)
d434 1
a434 3
   AC_DEFINE(USE_ARM_NEON, 1, [use ARM NEON compiler intrinsics])
else
   ARM_NEON_CFLAGS=
a436 2
AC_SUBST(ARM_NEON_CFLAGS)

d519 144
@


1.7
log
@OpenBSD's gcc 3.3 is capable of handling the MMX code of pixman.
Change the configure test so that it gets enabled.

Tested by marco@@ ajacoutot@@ ckuethe@@ and others.
@
text
@d34 1
a34 1
#   - Released stable versions have an event MINOR number
d56 2
a57 2
m4_define([pixman_minor], 15)
m4_define([pixman_micro], 8)
d68 2
d80 10
d116 1
d120 8
a127 1
  esac fi changequote([,])dnl
d282 2
a283 1
      # since they check at runtime before using those instructions
d285 10
a294 1
         HWCAP_LDFLAGS='-Wl,-M,$(srcdir)/solaris-hwcap.mapfile'
d321 1
a321 1
CFLAGS="$CFLAGS $VMX_CFLAGS"
d358 1
d360 1
a360 1
ARM_SIMD_CFLAGS=""
d365 1
a365 1
CFLAGS="$CFLAGS $ARM_SIMD_CFLAGS"
d393 5
d399 1
a399 1
ARM_NEON_CFLAGS="-mfpu=neon -mfloat-abi=softfp"
d404 1
a404 1
CFLAGS="$CFLAGS $ARM_NEON_CFLAGS"
d428 4
d437 1
d467 1
d469 2
a470 2
AC_SUBST(ARM_SIMD_CFLAGS)
AC_SUBST(ARM_NEON_CFLAGS)
d472 4
a475 3
AM_CONDITIONAL(USE_ARM_SIMD, test $have_arm_simd = yes)
AM_CONDITIONAL(USE_ARM_NEON, test $have_arm_neon = yes)
AM_CONDITIONAL(USE_GCC_INLINE_ASM, test $have_gcc_inline_asm = yes)
d477 4
d482 2
d504 9
a512 1
		  
@


1.6
log
@Update to pixman 0.15.8.
@
text
@d169 2
a170 2
#if defined(__GNUC__) && (__GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 4))
error "Need GCC >= 3.4 for MMX intrinsics"
@


1.6.2.1
log
@MFC: OpenBSD's gcc 3.3 is capable of handling the MMX code of pixman.
Change the configure test so that it gets enabled.

Tested by marco@@ ajacoutot@@ ckuethe@@ and others.
@
text
@d169 2
a170 2
#if defined(__GNUC__) && (__GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 3))
error "Need GCC >= 3.3 for MMX intrinsics"
@


1.5
log
@pixman 0.12.0. Tested on a full ports build by naddy@@.
@
text
@d56 2
a57 2
m4_define([pixman_minor], 12)
m4_define([pixman_micro], 0)
d66 2
d73 5
d151 12
a162 1
MMX_CFLAGS="-mmmx -Winline"
d167 1
a167 1
CFLAGS="$CFLAGS $MMX_CFLAGS"
d204 10
a213 1
SSE2_CFLAGS="-mmmx -msse2 -Winline"
d218 1
a218 1
CFLAGS="$CFLAGS -msse2 $SSE2_CFLAGS"
d256 19
a274 1
dnl ========================================================
d276 1
d278 1
d280 1
d327 108
@


1.4
log
@Update to pixman 0.10, with one small fix to the sse2 test in configure.ac.
@
text
@d27 1
a27 2
#   - The git version must at all times have an odd MICRO version
#     number.
d29 2
a30 2
#   - If you add API, increment the MICRO version to the next largest
#     odd number.
d32 1
a32 2
#   - If you release a version that contains new API, then increment
#     MINOR and set MICRO to 0. 
d34 1
a34 2
#   - If you release a new version that does not contain new API, then
#     increment MICRO to the next even number.
d36 1
a36 2
#   - After doing a release, increment MICRO again to make the version 
#     number in git odd.
d38 1
a38 1
#   - If you break the ABI, then
d53 1
d56 1
a56 1
m4_define([pixman_minor], 10)
d70 1
a70 1

d102 6
d116 1
a116 1
#error Need GCC 4.0 for visibility
d126 15
d144 1
a144 1
MMX_CFLAGS="-mmmx -Winline --param inline-unit-growth=10000 --param large-function-growth=10000"
d152 1
a152 1
#error "Need GCC >= 3.4 for MMX intrinsics"
d160 9
a168 1
AC_MSG_RESULT($have_mmx_intrinsics)
d176 5
d183 2
a184 1
dnl =======================================================
d186 1
a186 6
dnl GCC 4.2 when compiling with -msse will generate SSE instructions
dnl on its own.  This means anything compiled with -mss can only be
dnl run after a runtime check for SSE.  Unfortunately, since we still
dnl need to support MMX-but-not-SSE (such as the OLPC), this means we
dnl can only use SSE when compiling for x86-64 (where SSE is always
dnl supported).
d188 2
a189 2
have_sse_intrinsics=no
AC_MSG_CHECKING(whether to use SSE intrinsics)
d191 1
a191 1
CFLAGS="$CFLAGS -msse $MMX_CFLAGS"
d194 4
a197 2
#if !defined(__amd64__) && !defined(__x86_64__)
#error "Need x86-64 for SSE"
d201 1
d203 4
a206 4
    __m64 v = _mm_cvtsi32_si64 (1);
    v = _mm_shuffle_pi16 (v, _MM_SHUFFLE(3, 3, 3, 3));
    return _mm_cvtsi64_si32 (v);
}], have_sse_intrinsics=yes)
a207 1
AC_MSG_RESULT($have_sse_intrinsics)
d209 7
a215 3
if test $have_sse_intrinsics = yes ; then
   AC_DEFINE(USE_SSE, 1, [use SSE compiler intrinsics])
   MMX_CFLAGS="-msse $MMX_CFLAGS"
d218 3
a220 1
AM_CONDITIONAL(USE_SSE, test $have_sse_intrinsics = yes)
d222 4
d227 5
a231 2
dnl ===========================================================================
dnl Check for SSE2
d233 6
a238 1
SSE_CFLAGS="-mmmx -msse2 -Winline --param inline-unit-growth=10000 --param large-function-growth=10000"
d240 2
a241 2
have_sse2_intrinsics=no
AC_MSG_CHECKING(whether to use SSE2 intrinsics)
d243 1
a243 2
CFLAGS="$CFLAGS -msse2 $SSE_CFLAGS"

d245 4
a248 2
#include <mmintrin.h>
#include <xmmintrin.h>
d250 2
a251 2
    __m128i a, b, c;
	c = _mm_xor_si128 (a, b);
d253 1
a253 1
}], have_sse2_intrinsics=yes)
a254 1
AC_MSG_RESULT($have_sse2_intrinsics)
d256 18
a273 2
if test $have_sse2_intrinsics = yes ; then
   AC_DEFINE(USE_SSE2, 1, [use SSE compiler intrinsics])
d276 3
a278 1
AM_CONDITIONAL(USE_SSE2, test $have_sse2_intrinsics = yes)
d280 12
a291 3
dnl ========================================================
AC_SUBST(MMX_CFLAGS)
AC_SUBST(SSE_CFLAGS)
d293 1
a293 2
PKG_CHECK_MODULES(GTK, [gtk+-2.0], [HAVE_GTK=yes], [HAVE_GTK=no])
AM_CONDITIONAL(HAVE_GTK, [test "x$HAVE_GTK" = xyes])
d301 1
@


1.3
log
@Merge pixman 0.9.6. Valery Masiutsin and other report that it fixes some
X crashes on amd64. Bump major since one function was removed.
@
text
@d27 2
a28 2
#   - If the changes don't affect API or ABI, then increment pixman_micro
#   - If API is added, then increment PIXMAN_MINOR, and set MICRO to 0
d30 18
a47 3
#   - If you break ABI, then
#        - In the first development release where you break ABI, find all instances of
#          "pixman-n" and change it to pixman-(n+1)
d54 3
a56 3
#      This ensures that binary incompatible versions can be installed in parallel.
#      See http://www106.pair.com/rhp/parallel.html for more information
#
d59 2
a60 2
m4_define([pixman_minor], 9)
m4_define([pixman_micro], 6)
d86 6
a91 2
PIXMAN_MAJOR=pixman_major
AC_SUBST(PIXMAN_MAJOR)
d105 18
d187 28
d217 1
d219 1
a219 2
#PKG_CHECK_MODULES(GTK, [gtk+-2.0], [HAVE_GTK=yes], [HAVE_GTK=no])
HAVE_GTK=no
d230 1
@


1.2
log
@force HAVE_GTK=no.
@
text
@d45 1
a45 1
m4_define([pixman_micro], 5)
d89 1
a89 1
MMX_CFLAGS="-mmmx -msse -Winline --param inline-unit-growth=10000 --param large-function-growth=10000"
d92 1
a92 1
AC_MSG_CHECKING(For MMX/SSE intrinsics in the compiler)
a99 1
#include <xmmintrin.h>
a101 1
    v = _mm_shuffle_pi16 (v, _MM_SHUFFLE(3, 3, 3, 3));
a111 1
AC_SUBST(MMX_CFLAGS)
d115 35
d151 1
@


1.1
log
@Initial revision
@
text
@d120 2
a121 1
PKG_CHECK_MODULES(GTK, [gtk+-2.0], [HAVE_GTK=yes], [HAVE_GTK=no])
@


1.1.1.1
log
@import pixman 0.9.5
@
text
@@


1.1.1.2
log
@pixman 0.9.6
@
text
@d45 1
a45 1
m4_define([pixman_micro], 6)
d89 1
a89 1
MMX_CFLAGS="-mmmx -Winline --param inline-unit-growth=10000 --param large-function-growth=10000"
d92 1
a92 1
AC_MSG_CHECKING(whether to use MMX intrinsics)
d100 1
d103 1
d114 1
a117 35
dnl =======================================================

dnl GCC 4.2 when compiling with -msse will generate SSE instructions
dnl on its own.  This means anything compiled with -mss can only be
dnl run after a runtime check for SSE.  Unfortunately, since we still
dnl need to support MMX-but-not-SSE (such as the OLPC), this means we
dnl can only use SSE when compiling for x86-64 (where SSE is always
dnl supported).

have_sse_intrinsics=no
AC_MSG_CHECKING(whether to use SSE intrinsics)
xserver_save_CFLAGS=$CFLAGS
CFLAGS="$CFLAGS -msse $MMX_CFLAGS"

AC_COMPILE_IFELSE([
#if !defined(__amd64__) && !defined(__x86_64__)
#error "Need x86-64 for SSE"
#endif
#include <mmintrin.h>
#include <xmmintrin.h>
int main () {
    __m64 v = _mm_cvtsi32_si64 (1);
    v = _mm_shuffle_pi16 (v, _MM_SHUFFLE(3, 3, 3, 3));
    return _mm_cvtsi64_si32 (v);
}], have_sse_intrinsics=yes)
CFLAGS=$xserver_save_CFLAGS
AC_MSG_RESULT($have_sse_intrinsics)

if test $have_sse_intrinsics = yes ; then
   AC_DEFINE(USE_SSE, 1, [use SSE compiler intrinsics])
   MMX_CFLAGS="-msse $MMX_CFLAGS"
fi

AM_CONDITIONAL(USE_SSE, test $have_sse_intrinsics = yes)

a118 1
AC_SUBST(MMX_CFLAGS)
@

