head	1.27;
access;
symbols
	OPENBSD_6_1_BASE:1.27
	libdrm_2_4_75:1.1.1.6
	libdrm_2_4_73:1.1.1.5
	libdrm_2_4_71:1.1.1.4
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	libdrm_2_4_67:1.1.1.3
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	libdrm_2_4_65:1.1.1.2
	libdrm_2_4_64:1.1.1.1
	libdrm:1.1.1
	OPENBSD_5_8:1.15.0.2
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.5.0.8
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.27
date	2017.02.05.05.46.41;	author jsg;	state Exp;
branches;
next	1.26;
commitid	7u73SYrl7j8vU8XM;

1.26
date	2016.12.02.05.41.52;	author jsg;	state Exp;
branches;
next	1.25;
commitid	n34HkPAbJibrhoa4;

1.25
date	2016.11.25.23.58.13;	author jsg;	state Exp;
branches;
next	1.24;
commitid	VV72oLAxixwS3cIN;

1.24
date	2016.11.25.23.52.06;	author jsg;	state Exp;
branches;
next	1.23;
commitid	rjU6ohjdfJfQSE5D;

1.23
date	2016.11.25.23.48.50;	author jsg;	state Exp;
branches;
next	1.22;
commitid	R8aZZwVc3xeeMMnK;

1.22
date	2016.11.25.23.44.40;	author jsg;	state Exp;
branches;
next	1.21;
commitid	aT7cbYOoY407DcHf;

1.21
date	2016.11.25.23.41.29;	author jsg;	state Exp;
branches;
next	1.20;
commitid	DuQDjyX2KhFHWyv2;

1.20
date	2016.11.19.05.45.01;	author jsg;	state Exp;
branches;
next	1.19;
commitid	tIcH9u4yWHjj9FVh;

1.19
date	2016.10.16.06.11.11;	author jsg;	state Exp;
branches;
next	1.18;
commitid	nvLf7SydSyxGShbn;

1.18
date	2016.03.20.10.41.29;	author jsg;	state Exp;
branches;
next	1.17;
commitid	mbp2aNpFrhnQxfR8;

1.17
date	2015.12.27.09.16.53;	author jsg;	state Exp;
branches;
next	1.16;
commitid	3T6ygenFOApe7XWL;

1.16
date	2015.08.22.00.30.35;	author jsg;	state Exp;
branches;
next	1.15;
commitid	qzdJ3g11hqB96r2U;

1.15
date	2015.07.15.23.19.17;	author jsg;	state Exp;
branches;
next	1.14;
commitid	NCd5WpEjxT48SV2b;

1.14
date	2015.03.26.06.00.06;	author jsg;	state Exp;
branches;
next	1.13;
commitid	xcCFtgqKNdwnnIdt;

1.13
date	2015.02.07.01.34.35;	author jsg;	state Exp;
branches;
next	1.12;
commitid	ttKh4qveShZNixll;

1.12
date	2014.08.14.04.00.28;	author jsg;	state Exp;
branches;
next	1.11;
commitid	PKCNcdqL8h8htsms;

1.11
date	2014.05.13.05.44.06;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2013.11.21.13.30.07;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.20.09.55.30;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.25.02.32.20;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2013.01.09.10.47.08;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.27.14.37.08;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.22.21.34.51;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.03.31.06.31.45;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.09.16.57.37;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.26.23.14.37;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2009.01.10.16.29.27;	author oga;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2015.08.21.23.55.37;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	IINH94ZNafdY3NZg;

1.1.1.2
date	2015.12.27.08.57.56;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	1d5D4vlIz2Mv01RY;

1.1.1.3
date	2016.03.20.10.19.44;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	66ApiJCJocBDCoju;

1.1.1.4
date	2016.10.16.06.01.18;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	UDYjDzwIWWXeKnu7;

1.1.1.5
date	2016.11.19.05.36.19;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	J3nLYkpAOBFQLy9J;

1.1.1.6
date	2017.02.05.05.38.00;	author jsg;	state Exp;
branches;
next	;
commitid	GTUS6FM9u0BarnEJ;


desc
@@


1.27
log
@Merge libdrm 2.4.75
@
text
@/**
 * \file xf86drm.c
 * User-level interface to DRM device
 *
 * \author Rickard E. (Rik) Faith <faith@@valinux.com>
 * \author Kevin E. Martin <martin@@valinux.com>
 */

/*
 * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
 * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <ctype.h>
#include <dirent.h>
#include <stddef.h>
#include <fcntl.h>
#include <errno.h>
#include <limits.h>
#include <signal.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#define stat_t struct stat
#include <sys/ioctl.h>
#include <sys/time.h>
#include <stdarg.h>
#ifdef MAJOR_IN_MKDEV
#include <sys/mkdev.h>
#endif
#ifdef MAJOR_IN_SYSMACROS
#include <sys/sysmacros.h>
#endif
#include <math.h>

/* Not all systems have MAP_FAILED defined */
#ifndef MAP_FAILED
#define MAP_FAILED ((void *)-1)
#endif

#include "xf86drm.h"
#include "libdrm_macros.h"

#include "util_math.h"

#ifdef __OpenBSD__
#define DRM_PRIMARY_MINOR_NAME  "drm"
#define DRM_CONTROL_MINOR_NAME  "drmC"
#define DRM_RENDER_MINOR_NAME   "drmR"
#else
#define DRM_PRIMARY_MINOR_NAME  "card"
#define DRM_CONTROL_MINOR_NAME  "controlD"
#define DRM_RENDER_MINOR_NAME   "renderD"
#endif

#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
#define DRM_MAJOR 145
#endif

#ifdef __NetBSD__
#define DRM_MAJOR 34
#endif

#ifdef __OpenBSD__
#ifdef __i386__
#define DRM_MAJOR 88
#else
#define DRM_MAJOR 87
#endif
#endif /* __OpenBSD__ */

#ifndef DRM_MAJOR
#define DRM_MAJOR 226 /* Linux */
#endif

#ifdef __OpenBSD__
#define X_PRIVSEP

struct drm_pciinfo {
	uint16_t	domain;
	uint8_t		bus;
	uint8_t		dev;
	uint8_t		func;
	uint16_t	vendor_id;
	uint16_t	device_id;
	uint16_t	subvendor_id;
	uint16_t	subdevice_id;
	uint8_t		revision_id;
};

#define DRM_IOCTL_GET_PCIINFO	DRM_IOR(0x15, struct drm_pciinfo)
#endif

#define DRM_MSG_VERBOSITY 3

#define memclear(s) memset(&s, 0, sizeof(s))

static drmServerInfoPtr drm_server_info;

void drmSetServerInfo(drmServerInfoPtr info)
{
    drm_server_info = info;
}

/**
 * Output a message to stderr.
 *
 * \param format printf() like format string.
 *
 * \internal
 * This function is a wrapper around vfprintf().
 */

static int DRM_PRINTFLIKE(1, 0)
drmDebugPrint(const char *format, va_list ap)
{
    return vfprintf(stderr, format, ap);
}

void
drmMsg(const char *format, ...)
{
    va_list ap;
    const char *env;
    if (((env = getenv("LIBGL_DEBUG")) && strstr(env, "verbose")) ||
        (drm_server_info && drm_server_info->debug_print))
    {
        va_start(ap, format);
        if (drm_server_info) {
            drm_server_info->debug_print(format,ap);
        } else {
            drmDebugPrint(format, ap);
        }
        va_end(ap);
    }
}

static void *drmHashTable = NULL; /* Context switch callbacks */

void *drmGetHashTable(void)
{
    return drmHashTable;
}

void *drmMalloc(int size)
{
    return calloc(1, size);
}

void drmFree(void *pt)
{
    free(pt);
}

/**
 * Call ioctl, restarting if it is interupted
 */
int
drmIoctl(int fd, unsigned long request, void *arg)
{
    int ret;

    do {
        ret = ioctl(fd, request, arg);
    } while (ret == -1 && (errno == EINTR || errno == EAGAIN));
    return ret;
}

static unsigned long drmGetKeyFromFd(int fd)
{
    stat_t     st;

    st.st_rdev = 0;
    fstat(fd, &st);
    return st.st_rdev;
}

drmHashEntry *drmGetEntry(int fd)
{
    unsigned long key = drmGetKeyFromFd(fd);
    void          *value;
    drmHashEntry  *entry;

    if (!drmHashTable)
        drmHashTable = drmHashCreate();

    if (drmHashLookup(drmHashTable, key, &value)) {
        entry           = drmMalloc(sizeof(*entry));
        entry->fd       = fd;
        entry->f        = NULL;
        entry->tagTable = drmHashCreate();
        drmHashInsert(drmHashTable, key, entry);
    } else {
        entry = value;
    }
    return entry;
}

/**
 * Compare two busid strings
 *
 * \param first
 * \param second
 *
 * \return 1 if matched.
 *
 * \internal
 * This function compares two bus ID strings.  It understands the older
 * PCI:b:d:f format and the newer pci:oooo:bb:dd.f format.  In the format, o is
 * domain, b is bus, d is device, f is function.
 */
static int drmMatchBusID(const char *id1, const char *id2, int pci_domain_ok)
{
    /* First, check if the IDs are exactly the same */
    if (strcasecmp(id1, id2) == 0)
        return 1;

    /* Try to match old/new-style PCI bus IDs. */
    if (strncasecmp(id1, "pci", 3) == 0) {
        unsigned int o1, b1, d1, f1;
        unsigned int o2, b2, d2, f2;
        int ret;

        ret = sscanf(id1, "pci:%04x:%02x:%02x.%u", &o1, &b1, &d1, &f1);
        if (ret != 4) {
            o1 = 0;
            ret = sscanf(id1, "PCI:%u:%u:%u", &b1, &d1, &f1);
            if (ret != 3)
                return 0;
        }

        ret = sscanf(id2, "pci:%04x:%02x:%02x.%u", &o2, &b2, &d2, &f2);
        if (ret != 4) {
            o2 = 0;
            ret = sscanf(id2, "PCI:%u:%u:%u", &b2, &d2, &f2);
            if (ret != 3)
                return 0;
        }

        /* If domains aren't properly supported by the kernel interface,
         * just ignore them, which sucks less than picking a totally random
         * card with "open by name"
         */
        if (!pci_domain_ok)
            o1 = o2 = 0;

        if ((o1 != o2) || (b1 != b2) || (d1 != d2) || (f1 != f2))
            return 0;
        else
            return 1;
    }
    return 0;
}

/**
 * Handles error checking for chown call.
 *
 * \param path to file.
 * \param id of the new owner.
 * \param id of the new group.
 *
 * \return zero if success or -1 if failure.
 *
 * \internal
 * Checks for failure. If failure was caused by signal call chown again.
 * If any other failure happened then it will output error mesage using
 * drmMsg() call.
 */
#if !defined(UDEV)
static int chown_check_return(const char *path, uid_t owner, gid_t group)
{
        int rv;

        do {
            rv = chown(path, owner, group);
        } while (rv != 0 && errno == EINTR);

        if (rv == 0)
            return 0;

        drmMsg("Failed to change owner or group for file %s! %d: %s\n",
               path, errno, strerror(errno));
        return -1;
}
#endif

#ifdef X_PRIVSEP
static int
_priv_open_device(const char *path)
{
	drmMsg("_priv_open_device\n");
	return open(path, O_RDWR, 0);
}

int priv_open_device(const char *)
	__attribute__((weak, alias ("_priv_open_device")));
#endif

/**
 * Open the DRM device, creating it if necessary.
 *
 * \param dev major and minor numbers of the device.
 * \param minor minor number of the device.
 *
 * \return a file descriptor on success, or a negative value on error.
 *
 * \internal
 * Assembles the device name from \p minor and opens it, creating the device
 * special file node with the major and minor numbers specified by \p dev and
 * parent directory if necessary and was called by root.
 */
static int drmOpenDevice(dev_t dev, int minor, int type)
{
    stat_t          st;
    const char      *dev_name;
    char            buf[64];
    int             fd;
    mode_t          devmode = DRM_DEV_MODE, serv_mode;
    gid_t           serv_group;
#if !defined(UDEV)
    int             isroot  = !geteuid();
    uid_t           user    = DRM_DEV_UID;
    gid_t           group   = DRM_DEV_GID;
#endif

    switch (type) {
    case DRM_NODE_PRIMARY:
        dev_name = DRM_DEV_NAME;
        break;
    case DRM_NODE_CONTROL:
        dev_name = DRM_CONTROL_DEV_NAME;
        break;
    case DRM_NODE_RENDER:
        dev_name = DRM_RENDER_DEV_NAME;
        break;
    default:
        return -EINVAL;
    };

    sprintf(buf, dev_name, DRM_DIR_NAME, minor);
    drmMsg("drmOpenDevice: node name is %s\n", buf);

    if (drm_server_info && drm_server_info->get_perms) {
        drm_server_info->get_perms(&serv_group, &serv_mode);
        devmode  = serv_mode ? serv_mode : DRM_DEV_MODE;
        devmode &= ~(S_IXUSR|S_IXGRP|S_IXOTH);
    }

#ifndef __OpenBSD__
#if !defined(UDEV)
    if (stat(DRM_DIR_NAME, &st)) {
        if (!isroot)
            return DRM_ERR_NOT_ROOT;
        mkdir(DRM_DIR_NAME, DRM_DEV_DIRMODE);
        chown_check_return(DRM_DIR_NAME, 0, 0); /* root:root */
        chmod(DRM_DIR_NAME, DRM_DEV_DIRMODE);
    }

    /* Check if the device node exists and create it if necessary. */
    if (stat(buf, &st)) {
        if (!isroot)
            return DRM_ERR_NOT_ROOT;
        remove(buf);
        mknod(buf, S_IFCHR | devmode, dev);
    }

    if (drm_server_info && drm_server_info->get_perms) {
        group = ((int)serv_group >= 0) ? serv_group : DRM_DEV_GID;
        chown_check_return(buf, user, group);
        chmod(buf, devmode);
    }
#else
    /* if we modprobed then wait for udev */
    {
        int udev_count = 0;
wait_for_udev:
        if (stat(DRM_DIR_NAME, &st)) {
            usleep(20);
            udev_count++;

            if (udev_count == 50)
                return -1;
            goto wait_for_udev;
        }

        if (stat(buf, &st)) {
            usleep(20);
            udev_count++;

            if (udev_count == 50)
                return -1;
            goto wait_for_udev;
        }
    }
#endif
#endif /* __OpenBSD__ */

#ifndef X_PRIVSEP
    fd = open(buf, O_RDWR, 0);
#else
    fd = priv_open_device(buf);
#endif
    drmMsg("drmOpenDevice: open result is %d, (%s)\n",
           fd, fd < 0 ? strerror(errno) : "OK");
    if (fd >= 0)
        return fd;

#if !defined(UDEV) && !defined(__OpenBSD__)
    /* Check if the device node is not what we expect it to be, and recreate it
     * and try again if so.
     */
    if (st.st_rdev != dev) {
        if (!isroot)
            return DRM_ERR_NOT_ROOT;
        remove(buf);
        mknod(buf, S_IFCHR | devmode, dev);
        if (drm_server_info && drm_server_info->get_perms) {
            chown_check_return(buf, user, group);
            chmod(buf, devmode);
        }
    }
    fd = open(buf, O_RDWR, 0);
    drmMsg("drmOpenDevice: open result is %d, (%s)\n",
           fd, fd < 0 ? strerror(errno) : "OK");
    if (fd >= 0)
        return fd;

    drmMsg("drmOpenDevice: Open failed\n");
    remove(buf);
#endif
    return -errno;
}


/**
 * Open the DRM device
 *
 * \param minor device minor number.
 * \param create allow to create the device if set.
 *
 * \return a file descriptor on success, or a negative value on error.
 *
 * \internal
 * Calls drmOpenDevice() if \p create is set, otherwise assembles the device
 * name from \p minor and opens it.
 */
static int drmOpenMinor(int minor, int create, int type)
{
    int  fd;
    char buf[64];
    const char *dev_name;

    if (create)
        return drmOpenDevice(makedev(DRM_MAJOR, minor), minor, type);

    switch (type) {
    case DRM_NODE_PRIMARY:
        dev_name = DRM_DEV_NAME;
        break;
    case DRM_NODE_CONTROL:
        dev_name = DRM_CONTROL_DEV_NAME;
        break;
    case DRM_NODE_RENDER:
        dev_name = DRM_RENDER_DEV_NAME;
        break;
    default:
        return -EINVAL;
    };

    sprintf(buf, dev_name, DRM_DIR_NAME, minor);
#ifndef X_PRIVSEP
    fd = open(buf, O_RDWR, 0);
#else
    fd = priv_open_device(buf);
#endif
    if (fd >= 0)
	return fd;
    return -errno;
}


/**
 * Determine whether the DRM kernel driver has been loaded.
 *
 * \return 1 if the DRM driver is loaded, 0 otherwise.
 *
 * \internal
 * Determine the presence of the kernel driver by attempting to open the 0
 * minor and get version information.  For backward compatibility with older
 * Linux implementations, /proc/dri is also checked.
 */
int drmAvailable(void)
{
    drmVersionPtr version;
    int           retval = 0;
    int           fd;

    if ((fd = drmOpenMinor(0, 1, DRM_NODE_PRIMARY)) < 0) {
#ifdef __linux__
        /* Try proc for backward Linux compatibility */
        if (!access("/proc/dri/0", R_OK))
            return 1;
#endif
        return 0;
    }

    if ((version = drmGetVersion(fd))) {
        retval = 1;
        drmFreeVersion(version);
    }
    close(fd);

    return retval;
}

static int drmGetMinorBase(int type)
{
    switch (type) {
    case DRM_NODE_PRIMARY:
        return 0;
    case DRM_NODE_CONTROL:
        return 64;
    case DRM_NODE_RENDER:
        return 128;
    default:
        return -1;
    };
}

static int drmGetMinorType(int minor)
{
    int type = minor >> 6;

    if (minor < 0)
        return -1;

    switch (type) {
    case DRM_NODE_PRIMARY:
    case DRM_NODE_CONTROL:
    case DRM_NODE_RENDER:
        return type;
    default:
        return -1;
    }
}

static const char *drmGetMinorName(int type)
{
    switch (type) {
    case DRM_NODE_PRIMARY:
        return DRM_PRIMARY_MINOR_NAME;
    case DRM_NODE_CONTROL:
        return DRM_CONTROL_MINOR_NAME;
    case DRM_NODE_RENDER:
        return DRM_RENDER_MINOR_NAME;
    default:
        return NULL;
    }
}

/**
 * Open the device by bus ID.
 *
 * \param busid bus ID.
 * \param type device node type.
 *
 * \return a file descriptor on success, or a negative value on error.
 *
 * \internal
 * This function attempts to open every possible minor (up to DRM_MAX_MINOR),
 * comparing the device bus ID with the one supplied.
 *
 * \sa drmOpenMinor() and drmGetBusid().
 */
static int drmOpenByBusid(const char *busid, int type)
{
    int        i, pci_domain_ok = 1;
    int        fd;
    const char *buf;
    drmSetVersion sv;
    int        base = drmGetMinorBase(type);

    if (base < 0)
        return -1;

    drmMsg("drmOpenByBusid: Searching for BusID %s\n", busid);
    for (i = base; i < base + DRM_MAX_MINOR; i++) {
        fd = drmOpenMinor(i, 1, type);
        drmMsg("drmOpenByBusid: drmOpenMinor returns %d\n", fd);
        if (fd >= 0) {
            /* We need to try for 1.4 first for proper PCI domain support
             * and if that fails, we know the kernel is busted
             */
            sv.drm_di_major = 1;
            sv.drm_di_minor = 4;
            sv.drm_dd_major = -1;        /* Don't care */
            sv.drm_dd_minor = -1;        /* Don't care */
            if (drmSetInterfaceVersion(fd, &sv)) {
#ifndef __alpha__
                pci_domain_ok = 0;
#endif
                sv.drm_di_major = 1;
                sv.drm_di_minor = 1;
                sv.drm_dd_major = -1;       /* Don't care */
                sv.drm_dd_minor = -1;       /* Don't care */
                drmMsg("drmOpenByBusid: Interface 1.4 failed, trying 1.1\n");
                drmSetInterfaceVersion(fd, &sv);
            }
            buf = drmGetBusid(fd);
            drmMsg("drmOpenByBusid: drmGetBusid reports %s\n", buf);
            if (buf && drmMatchBusID(buf, busid, pci_domain_ok)) {
                drmFreeBusid(buf);
                return fd;
            }
            if (buf)
                drmFreeBusid(buf);
            close(fd);
        }
    }
    return -1;
}


/**
 * Open the device by name.
 *
 * \param name driver name.
 * \param type the device node type.
 *
 * \return a file descriptor on success, or a negative value on error.
 *
 * \internal
 * This function opens the first minor number that matches the driver name and
 * isn't already in use.  If it's in use it then it will already have a bus ID
 * assigned.
 *
 * \sa drmOpenMinor(), drmGetVersion() and drmGetBusid().
 */
static int drmOpenByName(const char *name, int type)
{
    int           i;
    int           fd;
    drmVersionPtr version;
    char *        id;
    int           base = drmGetMinorBase(type);

    if (base < 0)
        return -1;

    /*
     * Open the first minor number that matches the driver name and isn't
     * already in use.  If it's in use it will have a busid assigned already.
     */
    for (i = base; i < base + DRM_MAX_MINOR; i++) {
        if ((fd = drmOpenMinor(i, 1, type)) >= 0) {
            if ((version = drmGetVersion(fd))) {
                if (!strcmp(version->name, name)) {
                    drmFreeVersion(version);
                    id = drmGetBusid(fd);
                    drmMsg("drmGetBusid returned '%s'\n", id ? id : "NULL");
                    if (!id || !*id) {
                        if (id)
                            drmFreeBusid(id);
                        return fd;
                    } else {
                        drmFreeBusid(id);
                    }
                } else {
                    drmFreeVersion(version);
                }
            }
            close(fd);
        }
    }

#ifdef __linux__
    /* Backward-compatibility /proc support */
    for (i = 0; i < 8; i++) {
        char proc_name[64], buf[512];
        char *driver, *pt, *devstring;
        int  retcode;

        sprintf(proc_name, "/proc/dri/%d/name", i);
        if ((fd = open(proc_name, 0, 0)) >= 0) {
            retcode = read(fd, buf, sizeof(buf)-1);
            close(fd);
            if (retcode) {
                buf[retcode-1] = '\0';
                for (driver = pt = buf; *pt && *pt != ' '; ++pt)
                    ;
                if (*pt) { /* Device is next */
                    *pt = '\0';
                    if (!strcmp(driver, name)) { /* Match */
                        for (devstring = ++pt; *pt && *pt != ' '; ++pt)
                            ;
                        if (*pt) { /* Found busid */
                            return drmOpenByBusid(++pt, type);
                        } else { /* No busid */
                            return drmOpenDevice(strtol(devstring, NULL, 0),i, type);
                        }
                    }
                }
            }
        }
    }
#endif

    return -1;
}


/**
 * Open the DRM device.
 *
 * Looks up the specified name and bus ID, and opens the device found.  The
 * entry in /dev/dri is created if necessary and if called by root.
 *
 * \param name driver name. Not referenced if bus ID is supplied.
 * \param busid bus ID. Zero if not known.
 *
 * \return a file descriptor on success, or a negative value on error.
 *
 * \internal
 * It calls drmOpenByBusid() if \p busid is specified or drmOpenByName()
 * otherwise.
 */
int drmOpen(const char *name, const char *busid)
{
    return drmOpenWithType(name, busid, DRM_NODE_PRIMARY);
}

/**
 * Open the DRM device with specified type.
 *
 * Looks up the specified name and bus ID, and opens the device found.  The
 * entry in /dev/dri is created if necessary and if called by root.
 *
 * \param name driver name. Not referenced if bus ID is supplied.
 * \param busid bus ID. Zero if not known.
 * \param type the device node type to open, PRIMARY, CONTROL or RENDER
 *
 * \return a file descriptor on success, or a negative value on error.
 *
 * \internal
 * It calls drmOpenByBusid() if \p busid is specified or drmOpenByName()
 * otherwise.
 */
int drmOpenWithType(const char *name, const char *busid, int type)
{
    if (!drmAvailable() && name != NULL && drm_server_info &&
        drm_server_info->load_module) {
        /* try to load the kernel module */
        if (!drm_server_info->load_module(name)) {
            drmMsg("[drm] failed to load kernel module \"%s\"\n", name);
            return -1;
        }
    }

    if (busid) {
        int fd = drmOpenByBusid(busid, type);
        if (fd >= 0)
            return fd;
    }

    if (name)
        return drmOpenByName(name, type);

    return -1;
}

int drmOpenControl(int minor)
{
    return drmOpenMinor(minor, 0, DRM_NODE_CONTROL);
}

int drmOpenRender(int minor)
{
    return drmOpenMinor(minor, 0, DRM_NODE_RENDER);
}

/**
 * Free the version information returned by drmGetVersion().
 *
 * \param v pointer to the version information.
 *
 * \internal
 * It frees the memory pointed by \p %v as well as all the non-null strings
 * pointers in it.
 */
void drmFreeVersion(drmVersionPtr v)
{
    if (!v)
        return;
    drmFree(v->name);
    drmFree(v->date);
    drmFree(v->desc);
    drmFree(v);
}


/**
 * Free the non-public version information returned by the kernel.
 *
 * \param v pointer to the version information.
 *
 * \internal
 * Used by drmGetVersion() to free the memory pointed by \p %v as well as all
 * the non-null strings pointers in it.
 */
static void drmFreeKernelVersion(drm_version_t *v)
{
    if (!v)
        return;
    drmFree(v->name);
    drmFree(v->date);
    drmFree(v->desc);
    drmFree(v);
}


/**
 * Copy version information.
 *
 * \param d destination pointer.
 * \param s source pointer.
 *
 * \internal
 * Used by drmGetVersion() to translate the information returned by the ioctl
 * interface in a private structure into the public structure counterpart.
 */
static void drmCopyVersion(drmVersionPtr d, const drm_version_t *s)
{
    d->version_major      = s->version_major;
    d->version_minor      = s->version_minor;
    d->version_patchlevel = s->version_patchlevel;
    d->name_len           = s->name_len;
    d->name               = strdup(s->name);
    d->date_len           = s->date_len;
    d->date               = strdup(s->date);
    d->desc_len           = s->desc_len;
    d->desc               = strdup(s->desc);
}


/**
 * Query the driver version information.
 *
 * \param fd file descriptor.
 *
 * \return pointer to a drmVersion structure which should be freed with
 * drmFreeVersion().
 *
 * \note Similar information is available via /proc/dri.
 *
 * \internal
 * It gets the version information via successive DRM_IOCTL_VERSION ioctls,
 * first with zeros to get the string lengths, and then the actually strings.
 * It also null-terminates them since they might not be already.
 */
drmVersionPtr drmGetVersion(int fd)
{
    drmVersionPtr retval;
    drm_version_t *version = drmMalloc(sizeof(*version));

    memclear(*version);

    if (drmIoctl(fd, DRM_IOCTL_VERSION, version)) {
        drmFreeKernelVersion(version);
        return NULL;
    }

    if (version->name_len)
        version->name    = drmMalloc(version->name_len + 1);
    if (version->date_len)
        version->date    = drmMalloc(version->date_len + 1);
    if (version->desc_len)
        version->desc    = drmMalloc(version->desc_len + 1);

    if (drmIoctl(fd, DRM_IOCTL_VERSION, version)) {
        drmMsg("DRM_IOCTL_VERSION: %s\n", strerror(errno));
        drmFreeKernelVersion(version);
        return NULL;
    }

    /* The results might not be null-terminated strings, so terminate them. */
    if (version->name_len) version->name[version->name_len] = '\0';
    if (version->date_len) version->date[version->date_len] = '\0';
    if (version->desc_len) version->desc[version->desc_len] = '\0';

    retval = drmMalloc(sizeof(*retval));
    drmCopyVersion(retval, version);
    drmFreeKernelVersion(version);
    return retval;
}


/**
 * Get version information for the DRM user space library.
 *
 * This version number is driver independent.
 *
 * \param fd file descriptor.
 *
 * \return version information.
 *
 * \internal
 * This function allocates and fills a drm_version structure with a hard coded
 * version number.
 */
drmVersionPtr drmGetLibVersion(int fd)
{
    drm_version_t *version = drmMalloc(sizeof(*version));

    /* Version history:
     *   NOTE THIS MUST NOT GO ABOVE VERSION 1.X due to drivers needing it
     *   revision 1.0.x = original DRM interface with no drmGetLibVersion
     *                    entry point and many drm<Device> extensions
     *   revision 1.1.x = added drmCommand entry points for device extensions
     *                    added drmGetLibVersion to identify libdrm.a version
     *   revision 1.2.x = added drmSetInterfaceVersion
     *                    modified drmOpen to handle both busid and name
     *   revision 1.3.x = added server + memory manager
     */
    version->version_major      = 1;
    version->version_minor      = 3;
    version->version_patchlevel = 0;

    return (drmVersionPtr)version;
}

int drmGetCap(int fd, uint64_t capability, uint64_t *value)
{
    struct drm_get_cap cap;
    int ret;

    memclear(cap);
    cap.capability = capability;

    ret = drmIoctl(fd, DRM_IOCTL_GET_CAP, &cap);
    if (ret)
        return ret;

    *value = cap.value;
    return 0;
}

int drmSetClientCap(int fd, uint64_t capability, uint64_t value)
{
    struct drm_set_client_cap cap;

    memclear(cap);
    cap.capability = capability;
    cap.value = value;

    return drmIoctl(fd, DRM_IOCTL_SET_CLIENT_CAP, &cap);
}

/**
 * Free the bus ID information.
 *
 * \param busid bus ID information string as given by drmGetBusid().
 *
 * \internal
 * This function is just frees the memory pointed by \p busid.
 */
void drmFreeBusid(const char *busid)
{
    drmFree((void *)busid);
}


/**
 * Get the bus ID of the device.
 *
 * \param fd file descriptor.
 *
 * \return bus ID string.
 *
 * \internal
 * This function gets the bus ID via successive DRM_IOCTL_GET_UNIQUE ioctls to
 * get the string length and data, passing the arguments in a drm_unique
 * structure.
 */
char *drmGetBusid(int fd)
{
    drm_unique_t u;

    memclear(u);

    if (drmIoctl(fd, DRM_IOCTL_GET_UNIQUE, &u))
        return NULL;
    u.unique = drmMalloc(u.unique_len + 1);
    if (drmIoctl(fd, DRM_IOCTL_GET_UNIQUE, &u))
        return NULL;
    u.unique[u.unique_len] = '\0';

    return u.unique;
}


/**
 * Set the bus ID of the device.
 *
 * \param fd file descriptor.
 * \param busid bus ID string.
 *
 * \return zero on success, negative on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_SET_UNIQUE ioctl, passing
 * the arguments in a drm_unique structure.
 */
int drmSetBusid(int fd, const char *busid)
{
    drm_unique_t u;

    memclear(u);
    u.unique     = (char *)busid;
    u.unique_len = strlen(busid);

    if (drmIoctl(fd, DRM_IOCTL_SET_UNIQUE, &u)) {
        return -errno;
    }
    return 0;
}

int drmGetMagic(int fd, drm_magic_t * magic)
{
    drm_auth_t auth;

    memclear(auth);

    *magic = 0;
    if (drmIoctl(fd, DRM_IOCTL_GET_MAGIC, &auth))
        return -errno;
    *magic = auth.magic;
    return 0;
}

int drmAuthMagic(int fd, drm_magic_t magic)
{
    drm_auth_t auth;

    memclear(auth);
    auth.magic = magic;
    if (drmIoctl(fd, DRM_IOCTL_AUTH_MAGIC, &auth))
        return -errno;
    return 0;
}

/**
 * Specifies a range of memory that is available for mapping by a
 * non-root process.
 *
 * \param fd file descriptor.
 * \param offset usually the physical address. The actual meaning depends of
 * the \p type parameter. See below.
 * \param size of the memory in bytes.
 * \param type type of the memory to be mapped.
 * \param flags combination of several flags to modify the function actions.
 * \param handle will be set to a value that may be used as the offset
 * parameter for mmap().
 *
 * \return zero on success or a negative value on error.
 *
 * \par Mapping the frame buffer
 * For the frame buffer
 * - \p offset will be the physical address of the start of the frame buffer,
 * - \p size will be the size of the frame buffer in bytes, and
 * - \p type will be DRM_FRAME_BUFFER.
 *
 * \par
 * The area mapped will be uncached. If MTRR support is available in the
 * kernel, the frame buffer area will be set to write combining.
 *
 * \par Mapping the MMIO register area
 * For the MMIO register area,
 * - \p offset will be the physical address of the start of the register area,
 * - \p size will be the size of the register area bytes, and
 * - \p type will be DRM_REGISTERS.
 * \par
 * The area mapped will be uncached.
 *
 * \par Mapping the SAREA
 * For the SAREA,
 * - \p offset will be ignored and should be set to zero,
 * - \p size will be the desired size of the SAREA in bytes,
 * - \p type will be DRM_SHM.
 *
 * \par
 * A shared memory area of the requested size will be created and locked in
 * kernel memory. This area may be mapped into client-space by using the handle
 * returned.
 *
 * \note May only be called by root.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_ADD_MAP ioctl, passing
 * the arguments in a drm_map structure.
 */
int drmAddMap(int fd, drm_handle_t offset, drmSize size, drmMapType type,
              drmMapFlags flags, drm_handle_t *handle)
{
    drm_map_t map;

    memclear(map);
    map.offset  = offset;
    map.size    = size;
    map.type    = type;
    map.flags   = flags;
    if (drmIoctl(fd, DRM_IOCTL_ADD_MAP, &map))
        return -errno;
    if (handle)
        *handle = (drm_handle_t)(uintptr_t)map.handle;
    return 0;
}

int drmRmMap(int fd, drm_handle_t handle)
{
    drm_map_t map;

    memclear(map);
    map.handle = (void *)(uintptr_t)handle;

    if(drmIoctl(fd, DRM_IOCTL_RM_MAP, &map))
        return -errno;
    return 0;
}

/**
 * Make buffers available for DMA transfers.
 *
 * \param fd file descriptor.
 * \param count number of buffers.
 * \param size size of each buffer.
 * \param flags buffer allocation flags.
 * \param agp_offset offset in the AGP aperture
 *
 * \return number of buffers allocated, negative on error.
 *
 * \internal
 * This function is a wrapper around DRM_IOCTL_ADD_BUFS ioctl.
 *
 * \sa drm_buf_desc.
 */
int drmAddBufs(int fd, int count, int size, drmBufDescFlags flags,
               int agp_offset)
{
    drm_buf_desc_t request;

    memclear(request);
    request.count     = count;
    request.size      = size;
    request.flags     = flags;
    request.agp_start = agp_offset;

    if (drmIoctl(fd, DRM_IOCTL_ADD_BUFS, &request))
        return -errno;
    return request.count;
}

int drmMarkBufs(int fd, double low, double high)
{
    drm_buf_info_t info;
    int            i;

    memclear(info);

    if (drmIoctl(fd, DRM_IOCTL_INFO_BUFS, &info))
        return -EINVAL;

    if (!info.count)
        return -EINVAL;

    if (!(info.list = drmMalloc(info.count * sizeof(*info.list))))
        return -ENOMEM;

    if (drmIoctl(fd, DRM_IOCTL_INFO_BUFS, &info)) {
        int retval = -errno;
        drmFree(info.list);
        return retval;
    }

    for (i = 0; i < info.count; i++) {
        info.list[i].low_mark  = low  * info.list[i].count;
        info.list[i].high_mark = high * info.list[i].count;
        if (drmIoctl(fd, DRM_IOCTL_MARK_BUFS, &info.list[i])) {
            int retval = -errno;
            drmFree(info.list);
            return retval;
        }
    }
    drmFree(info.list);

    return 0;
}

/**
 * Free buffers.
 *
 * \param fd file descriptor.
 * \param count number of buffers to free.
 * \param list list of buffers to be freed.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \note This function is primarily used for debugging.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_FREE_BUFS ioctl, passing
 * the arguments in a drm_buf_free structure.
 */
int drmFreeBufs(int fd, int count, int *list)
{
    drm_buf_free_t request;

    memclear(request);
    request.count = count;
    request.list  = list;
    if (drmIoctl(fd, DRM_IOCTL_FREE_BUFS, &request))
        return -errno;
    return 0;
}


/**
 * Close the device.
 *
 * \param fd file descriptor.
 *
 * \internal
 * This function closes the file descriptor.
 */
int drmClose(int fd)
{
    unsigned long key    = drmGetKeyFromFd(fd);
    drmHashEntry  *entry = drmGetEntry(fd);

    drmHashDestroy(entry->tagTable);
    entry->fd       = 0;
    entry->f        = NULL;
    entry->tagTable = NULL;

    drmHashDelete(drmHashTable, key);
    drmFree(entry);

    return close(fd);
}


/**
 * Map a region of memory.
 *
 * \param fd file descriptor.
 * \param handle handle returned by drmAddMap().
 * \param size size in bytes. Must match the size used by drmAddMap().
 * \param address will contain the user-space virtual address where the mapping
 * begins.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper for mmap().
 */
int drmMap(int fd, drm_handle_t handle, drmSize size, drmAddressPtr address)
{
    static unsigned long pagesize_mask = 0;

    if (fd < 0)
        return -EINVAL;

    if (!pagesize_mask)
        pagesize_mask = getpagesize() - 1;

    size = (size + pagesize_mask) & ~pagesize_mask;

    *address = drm_mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, handle);
    if (*address == MAP_FAILED)
        return -errno;
    return 0;
}


/**
 * Unmap mappings obtained with drmMap().
 *
 * \param address address as given by drmMap().
 * \param size size in bytes. Must match the size used by drmMap().
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper for munmap().
 */
int drmUnmap(drmAddress address, drmSize size)
{
    return drm_munmap(address, size);
}

drmBufInfoPtr drmGetBufInfo(int fd)
{
    drm_buf_info_t info;
    drmBufInfoPtr  retval;
    int            i;

    memclear(info);

    if (drmIoctl(fd, DRM_IOCTL_INFO_BUFS, &info))
        return NULL;

    if (info.count) {
        if (!(info.list = drmMalloc(info.count * sizeof(*info.list))))
            return NULL;

        if (drmIoctl(fd, DRM_IOCTL_INFO_BUFS, &info)) {
            drmFree(info.list);
            return NULL;
        }

        retval = drmMalloc(sizeof(*retval));
        retval->count = info.count;
        retval->list  = drmMalloc(info.count * sizeof(*retval->list));
        for (i = 0; i < info.count; i++) {
            retval->list[i].count     = info.list[i].count;
            retval->list[i].size      = info.list[i].size;
            retval->list[i].low_mark  = info.list[i].low_mark;
            retval->list[i].high_mark = info.list[i].high_mark;
        }
        drmFree(info.list);
        return retval;
    }
    return NULL;
}

/**
 * Map all DMA buffers into client-virtual space.
 *
 * \param fd file descriptor.
 *
 * \return a pointer to a ::drmBufMap structure.
 *
 * \note The client may not use these buffers until obtaining buffer indices
 * with drmDMA().
 *
 * \internal
 * This function calls the DRM_IOCTL_MAP_BUFS ioctl and copies the returned
 * information about the buffers in a drm_buf_map structure into the
 * client-visible data structures.
 */
drmBufMapPtr drmMapBufs(int fd)
{
    drm_buf_map_t bufs;
    drmBufMapPtr  retval;
    int           i;

    memclear(bufs);
    if (drmIoctl(fd, DRM_IOCTL_MAP_BUFS, &bufs))
        return NULL;

    if (!bufs.count)
        return NULL;

    if (!(bufs.list = drmMalloc(bufs.count * sizeof(*bufs.list))))
        return NULL;

    if (drmIoctl(fd, DRM_IOCTL_MAP_BUFS, &bufs)) {
        drmFree(bufs.list);
        return NULL;
    }

    retval = drmMalloc(sizeof(*retval));
    retval->count = bufs.count;
    retval->list  = drmMalloc(bufs.count * sizeof(*retval->list));
    for (i = 0; i < bufs.count; i++) {
        retval->list[i].idx     = bufs.list[i].idx;
        retval->list[i].total   = bufs.list[i].total;
        retval->list[i].used    = 0;
        retval->list[i].address = bufs.list[i].address;
    }

    drmFree(bufs.list);
    return retval;
}


/**
 * Unmap buffers allocated with drmMapBufs().
 *
 * \return zero on success, or negative value on failure.
 *
 * \internal
 * Calls munmap() for every buffer stored in \p bufs and frees the
 * memory allocated by drmMapBufs().
 */
int drmUnmapBufs(drmBufMapPtr bufs)
{
    int i;

    for (i = 0; i < bufs->count; i++) {
        drm_munmap(bufs->list[i].address, bufs->list[i].total);
    }

    drmFree(bufs->list);
    drmFree(bufs);
    return 0;
}


#define DRM_DMA_RETRY  16

/**
 * Reserve DMA buffers.
 *
 * \param fd file descriptor.
 * \param request
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * Assemble the arguments into a drm_dma structure and keeps issuing the
 * DRM_IOCTL_DMA ioctl until success or until maximum number of retries.
 */
int drmDMA(int fd, drmDMAReqPtr request)
{
    drm_dma_t dma;
    int ret, i = 0;

    dma.context         = request->context;
    dma.send_count      = request->send_count;
    dma.send_indices    = request->send_list;
    dma.send_sizes      = request->send_sizes;
    dma.flags           = request->flags;
    dma.request_count   = request->request_count;
    dma.request_size    = request->request_size;
    dma.request_indices = request->request_list;
    dma.request_sizes   = request->request_sizes;
    dma.granted_count   = 0;

    do {
        ret = ioctl( fd, DRM_IOCTL_DMA, &dma );
    } while ( ret && errno == EAGAIN && i++ < DRM_DMA_RETRY );

    if ( ret == 0 ) {
        request->granted_count = dma.granted_count;
        return 0;
    } else {
        return -errno;
    }
}


/**
 * Obtain heavyweight hardware lock.
 *
 * \param fd file descriptor.
 * \param context context.
 * \param flags flags that determine the sate of the hardware when the function
 * returns.
 *
 * \return always zero.
 *
 * \internal
 * This function translates the arguments into a drm_lock structure and issue
 * the DRM_IOCTL_LOCK ioctl until the lock is successfully acquired.
 */
int drmGetLock(int fd, drm_context_t context, drmLockFlags flags)
{
    drm_lock_t lock;

    memclear(lock);
    lock.context = context;
    lock.flags   = 0;
    if (flags & DRM_LOCK_READY)      lock.flags |= _DRM_LOCK_READY;
    if (flags & DRM_LOCK_QUIESCENT)  lock.flags |= _DRM_LOCK_QUIESCENT;
    if (flags & DRM_LOCK_FLUSH)      lock.flags |= _DRM_LOCK_FLUSH;
    if (flags & DRM_LOCK_FLUSH_ALL)  lock.flags |= _DRM_LOCK_FLUSH_ALL;
    if (flags & DRM_HALT_ALL_QUEUES) lock.flags |= _DRM_HALT_ALL_QUEUES;
    if (flags & DRM_HALT_CUR_QUEUES) lock.flags |= _DRM_HALT_CUR_QUEUES;

    while (drmIoctl(fd, DRM_IOCTL_LOCK, &lock))
        ;
    return 0;
}

/**
 * Release the hardware lock.
 *
 * \param fd file descriptor.
 * \param context context.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_UNLOCK ioctl, passing the
 * argument in a drm_lock structure.
 */
int drmUnlock(int fd, drm_context_t context)
{
    drm_lock_t lock;

    memclear(lock);
    lock.context = context;
    return drmIoctl(fd, DRM_IOCTL_UNLOCK, &lock);
}

drm_context_t *drmGetReservedContextList(int fd, int *count)
{
    drm_ctx_res_t res;
    drm_ctx_t     *list;
    drm_context_t * retval;
    int           i;

    memclear(res);
    if (drmIoctl(fd, DRM_IOCTL_RES_CTX, &res))
        return NULL;

    if (!res.count)
        return NULL;

    if (!(list   = drmMalloc(res.count * sizeof(*list))))
        return NULL;
    if (!(retval = drmMalloc(res.count * sizeof(*retval)))) {
        drmFree(list);
        return NULL;
    }

    res.contexts = list;
    if (drmIoctl(fd, DRM_IOCTL_RES_CTX, &res))
        return NULL;

    for (i = 0; i < res.count; i++)
        retval[i] = list[i].handle;
    drmFree(list);

    *count = res.count;
    return retval;
}

void drmFreeReservedContextList(drm_context_t *pt)
{
    drmFree(pt);
}

/**
 * Create context.
 *
 * Used by the X server during GLXContext initialization. This causes
 * per-context kernel-level resources to be allocated.
 *
 * \param fd file descriptor.
 * \param handle is set on success. To be used by the client when requesting DMA
 * dispatch with drmDMA().
 *
 * \return zero on success, or a negative value on failure.
 *
 * \note May only be called by root.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_ADD_CTX ioctl, passing the
 * argument in a drm_ctx structure.
 */
int drmCreateContext(int fd, drm_context_t *handle)
{
    drm_ctx_t ctx;

    memclear(ctx);
    if (drmIoctl(fd, DRM_IOCTL_ADD_CTX, &ctx))
        return -errno;
    *handle = ctx.handle;
    return 0;
}

int drmSwitchToContext(int fd, drm_context_t context)
{
    drm_ctx_t ctx;

    memclear(ctx);
    ctx.handle = context;
    if (drmIoctl(fd, DRM_IOCTL_SWITCH_CTX, &ctx))
        return -errno;
    return 0;
}

int drmSetContextFlags(int fd, drm_context_t context, drm_context_tFlags flags)
{
    drm_ctx_t ctx;

    /*
     * Context preserving means that no context switches are done between DMA
     * buffers from one context and the next.  This is suitable for use in the
     * X server (which promises to maintain hardware context), or in the
     * client-side library when buffers are swapped on behalf of two threads.
     */
    memclear(ctx);
    ctx.handle = context;
    if (flags & DRM_CONTEXT_PRESERVED)
        ctx.flags |= _DRM_CONTEXT_PRESERVED;
    if (flags & DRM_CONTEXT_2DONLY)
        ctx.flags |= _DRM_CONTEXT_2DONLY;
    if (drmIoctl(fd, DRM_IOCTL_MOD_CTX, &ctx))
        return -errno;
    return 0;
}

int drmGetContextFlags(int fd, drm_context_t context,
                       drm_context_tFlagsPtr flags)
{
    drm_ctx_t ctx;

    memclear(ctx);
    ctx.handle = context;
    if (drmIoctl(fd, DRM_IOCTL_GET_CTX, &ctx))
        return -errno;
    *flags = 0;
    if (ctx.flags & _DRM_CONTEXT_PRESERVED)
        *flags |= DRM_CONTEXT_PRESERVED;
    if (ctx.flags & _DRM_CONTEXT_2DONLY)
        *flags |= DRM_CONTEXT_2DONLY;
    return 0;
}

/**
 * Destroy context.
 *
 * Free any kernel-level resources allocated with drmCreateContext() associated
 * with the context.
 *
 * \param fd file descriptor.
 * \param handle handle given by drmCreateContext().
 *
 * \return zero on success, or a negative value on failure.
 *
 * \note May only be called by root.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_RM_CTX ioctl, passing the
 * argument in a drm_ctx structure.
 */
int drmDestroyContext(int fd, drm_context_t handle)
{
    drm_ctx_t ctx;

    memclear(ctx);
    ctx.handle = handle;
    if (drmIoctl(fd, DRM_IOCTL_RM_CTX, &ctx))
        return -errno;
    return 0;
}

int drmCreateDrawable(int fd, drm_drawable_t *handle)
{
    drm_draw_t draw;

    memclear(draw);
    if (drmIoctl(fd, DRM_IOCTL_ADD_DRAW, &draw))
        return -errno;
    *handle = draw.handle;
    return 0;
}

int drmDestroyDrawable(int fd, drm_drawable_t handle)
{
    drm_draw_t draw;

    memclear(draw);
    draw.handle = handle;
    if (drmIoctl(fd, DRM_IOCTL_RM_DRAW, &draw))
        return -errno;
    return 0;
}

int drmUpdateDrawableInfo(int fd, drm_drawable_t handle,
                          drm_drawable_info_type_t type, unsigned int num,
                          void *data)
{
    drm_update_draw_t update;

    memclear(update);
    update.handle = handle;
    update.type = type;
    update.num = num;
    update.data = (unsigned long long)(unsigned long)data;

    if (drmIoctl(fd, DRM_IOCTL_UPDATE_DRAW, &update))
        return -errno;

    return 0;
}

/**
 * Acquire the AGP device.
 *
 * Must be called before any of the other AGP related calls.
 *
 * \param fd file descriptor.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_ACQUIRE ioctl.
 */
int drmAgpAcquire(int fd)
{
    if (drmIoctl(fd, DRM_IOCTL_AGP_ACQUIRE, NULL))
        return -errno;
    return 0;
}


/**
 * Release the AGP device.
 *
 * \param fd file descriptor.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_RELEASE ioctl.
 */
int drmAgpRelease(int fd)
{
    if (drmIoctl(fd, DRM_IOCTL_AGP_RELEASE, NULL))
        return -errno;
    return 0;
}


/**
 * Set the AGP mode.
 *
 * \param fd file descriptor.
 * \param mode AGP mode.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_ENABLE ioctl, passing the
 * argument in a drm_agp_mode structure.
 */
int drmAgpEnable(int fd, unsigned long mode)
{
    drm_agp_mode_t m;

    memclear(m);
    m.mode = mode;
    if (drmIoctl(fd, DRM_IOCTL_AGP_ENABLE, &m))
        return -errno;
    return 0;
}


/**
 * Allocate a chunk of AGP memory.
 *
 * \param fd file descriptor.
 * \param size requested memory size in bytes. Will be rounded to page boundary.
 * \param type type of memory to allocate.
 * \param address if not zero, will be set to the physical address of the
 * allocated memory.
 * \param handle on success will be set to a handle of the allocated memory.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_ALLOC ioctl, passing the
 * arguments in a drm_agp_buffer structure.
 */
int drmAgpAlloc(int fd, unsigned long size, unsigned long type,
                unsigned long *address, drm_handle_t *handle)
{
    drm_agp_buffer_t b;

    memclear(b);
    *handle = DRM_AGP_NO_HANDLE;
    b.size   = size;
    b.type   = type;
    if (drmIoctl(fd, DRM_IOCTL_AGP_ALLOC, &b))
        return -errno;
    if (address != 0UL)
        *address = b.physical;
    *handle = b.handle;
    return 0;
}


/**
 * Free a chunk of AGP memory.
 *
 * \param fd file descriptor.
 * \param handle handle to the allocated memory, as given by drmAgpAllocate().
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_FREE ioctl, passing the
 * argument in a drm_agp_buffer structure.
 */
int drmAgpFree(int fd, drm_handle_t handle)
{
    drm_agp_buffer_t b;

    memclear(b);
    b.handle = handle;
    if (drmIoctl(fd, DRM_IOCTL_AGP_FREE, &b))
        return -errno;
    return 0;
}


/**
 * Bind a chunk of AGP memory.
 *
 * \param fd file descriptor.
 * \param handle handle to the allocated memory, as given by drmAgpAllocate().
 * \param offset offset in bytes. It will round to page boundary.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_BIND ioctl, passing the
 * argument in a drm_agp_binding structure.
 */
int drmAgpBind(int fd, drm_handle_t handle, unsigned long offset)
{
    drm_agp_binding_t b;

    memclear(b);
    b.handle = handle;
    b.offset = offset;
    if (drmIoctl(fd, DRM_IOCTL_AGP_BIND, &b))
        return -errno;
    return 0;
}


/**
 * Unbind a chunk of AGP memory.
 *
 * \param fd file descriptor.
 * \param handle handle to the allocated memory, as given by drmAgpAllocate().
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_UNBIND ioctl, passing
 * the argument in a drm_agp_binding structure.
 */
int drmAgpUnbind(int fd, drm_handle_t handle)
{
    drm_agp_binding_t b;

    memclear(b);
    b.handle = handle;
    if (drmIoctl(fd, DRM_IOCTL_AGP_UNBIND, &b))
        return -errno;
    return 0;
}


/**
 * Get AGP driver major version number.
 *
 * \param fd file descriptor.
 *
 * \return major version number on success, or a negative value on failure..
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_INFO ioctl, getting the
 * necessary information in a drm_agp_info structure.
 */
int drmAgpVersionMajor(int fd)
{
    drm_agp_info_t i;

    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
        return -errno;
    return i.agp_version_major;
}


/**
 * Get AGP driver minor version number.
 *
 * \param fd file descriptor.
 *
 * \return minor version number on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_INFO ioctl, getting the
 * necessary information in a drm_agp_info structure.
 */
int drmAgpVersionMinor(int fd)
{
    drm_agp_info_t i;

    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
        return -errno;
    return i.agp_version_minor;
}


/**
 * Get AGP mode.
 *
 * \param fd file descriptor.
 *
 * \return mode on success, or zero on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_INFO ioctl, getting the
 * necessary information in a drm_agp_info structure.
 */
unsigned long drmAgpGetMode(int fd)
{
    drm_agp_info_t i;

    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
        return 0;
    return i.mode;
}


/**
 * Get AGP aperture base.
 *
 * \param fd file descriptor.
 *
 * \return aperture base on success, zero on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_INFO ioctl, getting the
 * necessary information in a drm_agp_info structure.
 */
unsigned long drmAgpBase(int fd)
{
    drm_agp_info_t i;

    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
        return 0;
    return i.aperture_base;
}


/**
 * Get AGP aperture size.
 *
 * \param fd file descriptor.
 *
 * \return aperture size on success, zero on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_INFO ioctl, getting the
 * necessary information in a drm_agp_info structure.
 */
unsigned long drmAgpSize(int fd)
{
    drm_agp_info_t i;

    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
        return 0;
    return i.aperture_size;
}


/**
 * Get used AGP memory.
 *
 * \param fd file descriptor.
 *
 * \return memory used on success, or zero on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_INFO ioctl, getting the
 * necessary information in a drm_agp_info structure.
 */
unsigned long drmAgpMemoryUsed(int fd)
{
    drm_agp_info_t i;

    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
        return 0;
    return i.memory_used;
}


/**
 * Get available AGP memory.
 *
 * \param fd file descriptor.
 *
 * \return memory available on success, or zero on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_INFO ioctl, getting the
 * necessary information in a drm_agp_info structure.
 */
unsigned long drmAgpMemoryAvail(int fd)
{
    drm_agp_info_t i;

    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
        return 0;
    return i.memory_allowed;
}


/**
 * Get hardware vendor ID.
 *
 * \param fd file descriptor.
 *
 * \return vendor ID on success, or zero on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_INFO ioctl, getting the
 * necessary information in a drm_agp_info structure.
 */
unsigned int drmAgpVendorId(int fd)
{
    drm_agp_info_t i;

    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
        return 0;
    return i.id_vendor;
}


/**
 * Get hardware device ID.
 *
 * \param fd file descriptor.
 *
 * \return zero on success, or zero on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_AGP_INFO ioctl, getting the
 * necessary information in a drm_agp_info structure.
 */
unsigned int drmAgpDeviceId(int fd)
{
    drm_agp_info_t i;

    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
        return 0;
    return i.id_device;
}

int drmScatterGatherAlloc(int fd, unsigned long size, drm_handle_t *handle)
{
    drm_scatter_gather_t sg;

    memclear(sg);

    *handle = 0;
    sg.size   = size;
    if (drmIoctl(fd, DRM_IOCTL_SG_ALLOC, &sg))
        return -errno;
    *handle = sg.handle;
    return 0;
}

int drmScatterGatherFree(int fd, drm_handle_t handle)
{
    drm_scatter_gather_t sg;

    memclear(sg);
    sg.handle = handle;
    if (drmIoctl(fd, DRM_IOCTL_SG_FREE, &sg))
        return -errno;
    return 0;
}

/**
 * Wait for VBLANK.
 *
 * \param fd file descriptor.
 * \param vbl pointer to a drmVBlank structure.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_WAIT_VBLANK ioctl.
 */
int drmWaitVBlank(int fd, drmVBlankPtr vbl)
{
    struct timespec timeout, cur;
    int ret;

    ret = clock_gettime(CLOCK_MONOTONIC, &timeout);
    if (ret < 0) {
        fprintf(stderr, "clock_gettime failed: %s\n", strerror(errno));
        goto out;
    }
    timeout.tv_sec++;

    do {
       ret = ioctl(fd, DRM_IOCTL_WAIT_VBLANK, vbl);
       vbl->request.type &= ~DRM_VBLANK_RELATIVE;
       if (ret && errno == EINTR) {
           clock_gettime(CLOCK_MONOTONIC, &cur);
           /* Timeout after 1s */
           if (cur.tv_sec > timeout.tv_sec + 1 ||
               (cur.tv_sec == timeout.tv_sec && cur.tv_nsec >=
                timeout.tv_nsec)) {
                   errno = EBUSY;
                   ret = -1;
                   break;
           }
       }
    } while (ret && errno == EINTR);

out:
    return ret;
}

int drmError(int err, const char *label)
{
    switch (err) {
    case DRM_ERR_NO_DEVICE:
        fprintf(stderr, "%s: no device\n", label);
        break;
    case DRM_ERR_NO_ACCESS:
        fprintf(stderr, "%s: no access\n", label);
        break;
    case DRM_ERR_NOT_ROOT:
        fprintf(stderr, "%s: not root\n", label);
        break;
    case DRM_ERR_INVALID:
        fprintf(stderr, "%s: invalid args\n", label);
        break;
    default:
        if (err < 0)
            err = -err;
        fprintf( stderr, "%s: error %d (%s)\n", label, err, strerror(err) );
        break;
    }

    return 1;
}

/**
 * Install IRQ handler.
 *
 * \param fd file descriptor.
 * \param irq IRQ number.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_CONTROL ioctl, passing the
 * argument in a drm_control structure.
 */
int drmCtlInstHandler(int fd, int irq)
{
    drm_control_t ctl;

    memclear(ctl);
    ctl.func  = DRM_INST_HANDLER;
    ctl.irq   = irq;
    if (drmIoctl(fd, DRM_IOCTL_CONTROL, &ctl))
        return -errno;
    return 0;
}


/**
 * Uninstall IRQ handler.
 *
 * \param fd file descriptor.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_CONTROL ioctl, passing the
 * argument in a drm_control structure.
 */
int drmCtlUninstHandler(int fd)
{
    drm_control_t ctl;

    memclear(ctl);
    ctl.func  = DRM_UNINST_HANDLER;
    ctl.irq   = 0;
    if (drmIoctl(fd, DRM_IOCTL_CONTROL, &ctl))
        return -errno;
    return 0;
}

int drmFinish(int fd, int context, drmLockFlags flags)
{
    drm_lock_t lock;

    memclear(lock);
    lock.context = context;
    if (flags & DRM_LOCK_READY)      lock.flags |= _DRM_LOCK_READY;
    if (flags & DRM_LOCK_QUIESCENT)  lock.flags |= _DRM_LOCK_QUIESCENT;
    if (flags & DRM_LOCK_FLUSH)      lock.flags |= _DRM_LOCK_FLUSH;
    if (flags & DRM_LOCK_FLUSH_ALL)  lock.flags |= _DRM_LOCK_FLUSH_ALL;
    if (flags & DRM_HALT_ALL_QUEUES) lock.flags |= _DRM_HALT_ALL_QUEUES;
    if (flags & DRM_HALT_CUR_QUEUES) lock.flags |= _DRM_HALT_CUR_QUEUES;
    if (drmIoctl(fd, DRM_IOCTL_FINISH, &lock))
        return -errno;
    return 0;
}

/**
 * Get IRQ from bus ID.
 *
 * \param fd file descriptor.
 * \param busnum bus number.
 * \param devnum device number.
 * \param funcnum function number.
 *
 * \return IRQ number on success, or a negative value on failure.
 *
 * \internal
 * This function is a wrapper around the DRM_IOCTL_IRQ_BUSID ioctl, passing the
 * arguments in a drm_irq_busid structure.
 */
int drmGetInterruptFromBusID(int fd, int busnum, int devnum, int funcnum)
{
    drm_irq_busid_t p;

    memclear(p);
    p.busnum  = busnum;
    p.devnum  = devnum;
    p.funcnum = funcnum;
    if (drmIoctl(fd, DRM_IOCTL_IRQ_BUSID, &p))
        return -errno;
    return p.irq;
}

int drmAddContextTag(int fd, drm_context_t context, void *tag)
{
    drmHashEntry  *entry = drmGetEntry(fd);

    if (drmHashInsert(entry->tagTable, context, tag)) {
        drmHashDelete(entry->tagTable, context);
        drmHashInsert(entry->tagTable, context, tag);
    }
    return 0;
}

int drmDelContextTag(int fd, drm_context_t context)
{
    drmHashEntry  *entry = drmGetEntry(fd);

    return drmHashDelete(entry->tagTable, context);
}

void *drmGetContextTag(int fd, drm_context_t context)
{
    drmHashEntry  *entry = drmGetEntry(fd);
    void          *value;

    if (drmHashLookup(entry->tagTable, context, &value))
        return NULL;

    return value;
}

int drmAddContextPrivateMapping(int fd, drm_context_t ctx_id,
                                drm_handle_t handle)
{
    drm_ctx_priv_map_t map;

    memclear(map);
    map.ctx_id = ctx_id;
    map.handle = (void *)(uintptr_t)handle;

    if (drmIoctl(fd, DRM_IOCTL_SET_SAREA_CTX, &map))
        return -errno;
    return 0;
}

int drmGetContextPrivateMapping(int fd, drm_context_t ctx_id,
                                drm_handle_t *handle)
{
    drm_ctx_priv_map_t map;

    memclear(map);
    map.ctx_id = ctx_id;

    if (drmIoctl(fd, DRM_IOCTL_GET_SAREA_CTX, &map))
        return -errno;
    if (handle)
        *handle = (drm_handle_t)(uintptr_t)map.handle;

    return 0;
}

int drmGetMap(int fd, int idx, drm_handle_t *offset, drmSize *size,
              drmMapType *type, drmMapFlags *flags, drm_handle_t *handle,
              int *mtrr)
{
    drm_map_t map;

    memclear(map);
    map.offset = idx;
    if (drmIoctl(fd, DRM_IOCTL_GET_MAP, &map))
        return -errno;
    *offset = map.offset;
    *size   = map.size;
    *type   = map.type;
    *flags  = map.flags;
    *handle = (unsigned long)map.handle;
    *mtrr   = map.mtrr;
    return 0;
}

int drmGetClient(int fd, int idx, int *auth, int *pid, int *uid,
                 unsigned long *magic, unsigned long *iocs)
{
    drm_client_t client;

    memclear(client);
    client.idx = idx;
    if (drmIoctl(fd, DRM_IOCTL_GET_CLIENT, &client))
        return -errno;
    *auth      = client.auth;
    *pid       = client.pid;
    *uid       = client.uid;
    *magic     = client.magic;
    *iocs      = client.iocs;
    return 0;
}

int drmGetStats(int fd, drmStatsT *stats)
{
    drm_stats_t s;
    unsigned    i;

    memclear(s);
    if (drmIoctl(fd, DRM_IOCTL_GET_STATS, &s))
        return -errno;

    stats->count = 0;
    memset(stats, 0, sizeof(*stats));
    if (s.count > sizeof(stats->data)/sizeof(stats->data[0]))
        return -1;

#define SET_VALUE                              \
    stats->data[i].long_format = "%-20.20s";   \
    stats->data[i].rate_format = "%8.8s";      \
    stats->data[i].isvalue     = 1;            \
    stats->data[i].verbose     = 0

#define SET_COUNT                              \
    stats->data[i].long_format = "%-20.20s";   \
    stats->data[i].rate_format = "%5.5s";      \
    stats->data[i].isvalue     = 0;            \
    stats->data[i].mult_names  = "kgm";        \
    stats->data[i].mult        = 1000;         \
    stats->data[i].verbose     = 0

#define SET_BYTE                               \
    stats->data[i].long_format = "%-20.20s";   \
    stats->data[i].rate_format = "%5.5s";      \
    stats->data[i].isvalue     = 0;            \
    stats->data[i].mult_names  = "KGM";        \
    stats->data[i].mult        = 1024;         \
    stats->data[i].verbose     = 0


    stats->count = s.count;
    for (i = 0; i < s.count; i++) {
        stats->data[i].value = s.data[i].value;
        switch (s.data[i].type) {
        case _DRM_STAT_LOCK:
            stats->data[i].long_name = "Lock";
            stats->data[i].rate_name = "Lock";
            SET_VALUE;
            break;
        case _DRM_STAT_OPENS:
            stats->data[i].long_name = "Opens";
            stats->data[i].rate_name = "O";
            SET_COUNT;
            stats->data[i].verbose   = 1;
            break;
        case _DRM_STAT_CLOSES:
            stats->data[i].long_name = "Closes";
            stats->data[i].rate_name = "Lock";
            SET_COUNT;
            stats->data[i].verbose   = 1;
            break;
        case _DRM_STAT_IOCTLS:
            stats->data[i].long_name = "Ioctls";
            stats->data[i].rate_name = "Ioc/s";
            SET_COUNT;
            break;
        case _DRM_STAT_LOCKS:
            stats->data[i].long_name = "Locks";
            stats->data[i].rate_name = "Lck/s";
            SET_COUNT;
            break;
        case _DRM_STAT_UNLOCKS:
            stats->data[i].long_name = "Unlocks";
            stats->data[i].rate_name = "Unl/s";
            SET_COUNT;
            break;
        case _DRM_STAT_IRQ:
            stats->data[i].long_name = "IRQs";
            stats->data[i].rate_name = "IRQ/s";
            SET_COUNT;
            break;
        case _DRM_STAT_PRIMARY:
            stats->data[i].long_name = "Primary Bytes";
            stats->data[i].rate_name = "PB/s";
            SET_BYTE;
            break;
        case _DRM_STAT_SECONDARY:
            stats->data[i].long_name = "Secondary Bytes";
            stats->data[i].rate_name = "SB/s";
            SET_BYTE;
            break;
        case _DRM_STAT_DMA:
            stats->data[i].long_name = "DMA";
            stats->data[i].rate_name = "DMA/s";
            SET_COUNT;
            break;
        case _DRM_STAT_SPECIAL:
            stats->data[i].long_name = "Special DMA";
            stats->data[i].rate_name = "dma/s";
            SET_COUNT;
            break;
        case _DRM_STAT_MISSED:
            stats->data[i].long_name = "Miss";
            stats->data[i].rate_name = "Ms/s";
            SET_COUNT;
            break;
        case _DRM_STAT_VALUE:
            stats->data[i].long_name = "Value";
            stats->data[i].rate_name = "Value";
            SET_VALUE;
            break;
        case _DRM_STAT_BYTE:
            stats->data[i].long_name = "Bytes";
            stats->data[i].rate_name = "B/s";
            SET_BYTE;
            break;
        case _DRM_STAT_COUNT:
        default:
            stats->data[i].long_name = "Count";
            stats->data[i].rate_name = "Cnt/s";
            SET_COUNT;
            break;
        }
    }
    return 0;
}

/**
 * Issue a set-version ioctl.
 *
 * \param fd file descriptor.
 * \param drmCommandIndex command index
 * \param data source pointer of the data to be read and written.
 * \param size size of the data to be read and written.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * It issues a read-write ioctl given by
 * \code DRM_COMMAND_BASE + drmCommandIndex \endcode.
 */
int drmSetInterfaceVersion(int fd, drmSetVersion *version)
{
    int retcode = 0;
    drm_set_version_t sv;

    memclear(sv);
    sv.drm_di_major = version->drm_di_major;
    sv.drm_di_minor = version->drm_di_minor;
    sv.drm_dd_major = version->drm_dd_major;
    sv.drm_dd_minor = version->drm_dd_minor;

    if (drmIoctl(fd, DRM_IOCTL_SET_VERSION, &sv)) {
        retcode = -errno;
    }

    version->drm_di_major = sv.drm_di_major;
    version->drm_di_minor = sv.drm_di_minor;
    version->drm_dd_major = sv.drm_dd_major;
    version->drm_dd_minor = sv.drm_dd_minor;

    return retcode;
}

/**
 * Send a device-specific command.
 *
 * \param fd file descriptor.
 * \param drmCommandIndex command index
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * It issues a ioctl given by
 * \code DRM_COMMAND_BASE + drmCommandIndex \endcode.
 */
int drmCommandNone(int fd, unsigned long drmCommandIndex)
{
    unsigned long request;

    request = DRM_IO( DRM_COMMAND_BASE + drmCommandIndex);

    if (drmIoctl(fd, request, NULL)) {
        return -errno;
    }
    return 0;
}


/**
 * Send a device-specific read command.
 *
 * \param fd file descriptor.
 * \param drmCommandIndex command index
 * \param data destination pointer of the data to be read.
 * \param size size of the data to be read.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * It issues a read ioctl given by
 * \code DRM_COMMAND_BASE + drmCommandIndex \endcode.
 */
int drmCommandRead(int fd, unsigned long drmCommandIndex, void *data,
                   unsigned long size)
{
    unsigned long request;

    request = DRM_IOC( DRM_IOC_READ, DRM_IOCTL_BASE,
        DRM_COMMAND_BASE + drmCommandIndex, size);

    if (drmIoctl(fd, request, data)) {
        return -errno;
    }
    return 0;
}


/**
 * Send a device-specific write command.
 *
 * \param fd file descriptor.
 * \param drmCommandIndex command index
 * \param data source pointer of the data to be written.
 * \param size size of the data to be written.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * It issues a write ioctl given by
 * \code DRM_COMMAND_BASE + drmCommandIndex \endcode.
 */
int drmCommandWrite(int fd, unsigned long drmCommandIndex, void *data,
                    unsigned long size)
{
    unsigned long request;

    request = DRM_IOC( DRM_IOC_WRITE, DRM_IOCTL_BASE,
        DRM_COMMAND_BASE + drmCommandIndex, size);

    if (drmIoctl(fd, request, data)) {
        return -errno;
    }
    return 0;
}


/**
 * Send a device-specific read-write command.
 *
 * \param fd file descriptor.
 * \param drmCommandIndex command index
 * \param data source pointer of the data to be read and written.
 * \param size size of the data to be read and written.
 *
 * \return zero on success, or a negative value on failure.
 *
 * \internal
 * It issues a read-write ioctl given by
 * \code DRM_COMMAND_BASE + drmCommandIndex \endcode.
 */
int drmCommandWriteRead(int fd, unsigned long drmCommandIndex, void *data,
                        unsigned long size)
{
    unsigned long request;

    request = DRM_IOC( DRM_IOC_READ|DRM_IOC_WRITE, DRM_IOCTL_BASE,
        DRM_COMMAND_BASE + drmCommandIndex, size);

    if (drmIoctl(fd, request, data))
        return -errno;
    return 0;
}

#define DRM_MAX_FDS 16
static struct {
    char *BusID;
    int fd;
    int refcount;
    int type;
} connection[DRM_MAX_FDS];

static int nr_fds = 0;

int drmOpenOnce(void *unused,
                const char *BusID,
                int *newlyopened)
{
    return drmOpenOnceWithType(BusID, newlyopened, DRM_NODE_PRIMARY);
}

int drmOpenOnceWithType(const char *BusID, int *newlyopened, int type)
{
    int i;
    int fd;

    for (i = 0; i < nr_fds; i++)
        if ((strcmp(BusID, connection[i].BusID) == 0) &&
            (connection[i].type == type)) {
            connection[i].refcount++;
            *newlyopened = 0;
            return connection[i].fd;
        }

    fd = drmOpenWithType(NULL, BusID, type);
    if (fd < 0 || nr_fds == DRM_MAX_FDS)
        return fd;

    connection[nr_fds].BusID = strdup(BusID);
    connection[nr_fds].fd = fd;
    connection[nr_fds].refcount = 1;
    connection[nr_fds].type = type;
    *newlyopened = 1;

    if (0)
        fprintf(stderr, "saved connection %d for %s %d\n",
                nr_fds, connection[nr_fds].BusID,
                strcmp(BusID, connection[nr_fds].BusID));

    nr_fds++;

    return fd;
}

void drmCloseOnce(int fd)
{
    int i;

    for (i = 0; i < nr_fds; i++) {
        if (fd == connection[i].fd) {
            if (--connection[i].refcount == 0) {
                drmClose(connection[i].fd);
                free(connection[i].BusID);

                if (i < --nr_fds)
                    connection[i] = connection[nr_fds];

                return;
            }
        }
    }
}

int drmSetMaster(int fd)
{
        return drmIoctl(fd, DRM_IOCTL_SET_MASTER, NULL);
}

int drmDropMaster(int fd)
{
        return drmIoctl(fd, DRM_IOCTL_DROP_MASTER, NULL);
}

char *drmGetDeviceNameFromFd(int fd)
{
    char name[128];
    struct stat sbuf;
    dev_t d;
    int i;

    /* The whole drmOpen thing is a fiasco and we need to find a way
     * back to just using open(2).  For now, however, lets just make
     * things worse with even more ad hoc directory walking code to
     * discover the device file name. */

    fstat(fd, &sbuf);
    d = sbuf.st_rdev;

    for (i = 0; i < DRM_MAX_MINOR; i++) {
        snprintf(name, sizeof name, DRM_DEV_NAME, DRM_DIR_NAME, i);
        if (stat(name, &sbuf) == 0 && sbuf.st_rdev == d)
            break;
    }
    if (i == DRM_MAX_MINOR)
        return NULL;

    return strdup(name);
}

int drmGetNodeTypeFromFd(int fd)
{
    struct stat sbuf;
    int maj, min, type;

    if (fstat(fd, &sbuf))
        return -1;

    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);

    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode)) {
        errno = EINVAL;
        return -1;
    }

    type = drmGetMinorType(min);
    if (type == -1)
        errno = ENODEV;
    return type;
}

int drmPrimeHandleToFD(int fd, uint32_t handle, uint32_t flags, int *prime_fd)
{
    struct drm_prime_handle args;
    int ret;

    memclear(args);
    args.fd = -1;
    args.handle = handle;
    args.flags = flags;
    ret = drmIoctl(fd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &args);
    if (ret)
        return ret;

    *prime_fd = args.fd;
    return 0;
}

int drmPrimeFDToHandle(int fd, int prime_fd, uint32_t *handle)
{
    struct drm_prime_handle args;
    int ret;

    memclear(args);
    args.fd = prime_fd;
    ret = drmIoctl(fd, DRM_IOCTL_PRIME_FD_TO_HANDLE, &args);
    if (ret)
        return ret;

    *handle = args.handle;
    return 0;
}

static char *drmGetMinorNameForFD(int fd, int type)
{
#ifdef __linux__
    DIR *sysdir;
    struct dirent *pent, *ent;
    struct stat sbuf;
    const char *name = drmGetMinorName(type);
    int len;
    char dev_name[64], buf[64];
    long name_max;
    int maj, min;

    if (!name)
        return NULL;

    len = strlen(name);

    if (fstat(fd, &sbuf))
        return NULL;

    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);

    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
        return NULL;

    snprintf(buf, sizeof(buf), "/sys/dev/char/%d:%d/device/drm", maj, min);

    sysdir = opendir(buf);
    if (!sysdir)
        return NULL;

    name_max = fpathconf(dirfd(sysdir), _PC_NAME_MAX);
    if (name_max == -1)
        goto out_close_dir;

    pent = malloc(offsetof(struct dirent, d_name) + name_max + 1);
    if (pent == NULL)
         goto out_close_dir;

    while (readdir_r(sysdir, pent, &ent) == 0 && ent != NULL) {
        if (strncmp(ent->d_name, name, len) == 0) {
            snprintf(dev_name, sizeof(dev_name), DRM_DIR_NAME "/%s",
                 ent->d_name);

            free(pent);
            closedir(sysdir);

            return strdup(dev_name);
        }
    }

    free(pent);

out_close_dir:
    closedir(sysdir);
#else
    struct stat sbuf;
    char buf[PATH_MAX + 1];
    const char *dev_name;
    unsigned int maj, min;
    int n, base;

    if (fstat(fd, &sbuf))
        return NULL;

    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);

    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
        return NULL;

    switch (type) {
    case DRM_NODE_PRIMARY:
        dev_name = DRM_DEV_NAME;
        break;
    case DRM_NODE_CONTROL:
        dev_name = DRM_CONTROL_DEV_NAME;
        break;
    case DRM_NODE_RENDER:
        dev_name = DRM_RENDER_DEV_NAME;
        break;
    default:
        return NULL;
    };

    base = drmGetMinorBase(type);
    if (base < 0)
        return NULL;

    n = snprintf(buf, sizeof(buf), dev_name, DRM_DIR_NAME, min - base);
    if (n == -1 || n >= sizeof(buf))
        return NULL;

    return strdup(buf);
#endif
    return NULL;
}

char *drmGetPrimaryDeviceNameFromFd(int fd)
{
    return drmGetMinorNameForFD(fd, DRM_NODE_PRIMARY);
}

char *drmGetRenderDeviceNameFromFd(int fd)
{
    return drmGetMinorNameForFD(fd, DRM_NODE_RENDER);
}

#ifdef __linux__
static char * DRM_PRINTFLIKE(2, 3)
sysfs_uevent_get(const char *path, const char *fmt, ...)
{
    char filename[PATH_MAX + 1], *key, *line = NULL, *value = NULL;
    size_t size = 0, len;
    ssize_t num;
    va_list ap;
    FILE *fp;

    va_start(ap, fmt);
    num = vasprintf(&key, fmt, ap);
    va_end(ap);
    len = num;

    snprintf(filename, sizeof(filename), "%s/uevent", path);

    fp = fopen(filename, "r");
    if (!fp) {
        free(key);
        return NULL;
    }

    while ((num = getline(&line, &size, fp)) >= 0) {
        if ((strncmp(line, key, len) == 0) && (line[len] == '=')) {
            char *start = line + len + 1, *end = line + num - 1;

            if (*end != '\n')
                end++;

            value = strndup(start, end - start);
            break;
        }
    }

    free(line);
    fclose(fp);

    free(key);

    return value;
}
#endif

static int drmParseSubsystemType(int maj, int min)
{
#ifdef __linux__
    char path[PATH_MAX + 1];
    char link[PATH_MAX + 1] = "";
    char *name;

    snprintf(path, PATH_MAX, "/sys/dev/char/%d:%d/device/subsystem",
             maj, min);

    if (readlink(path, link, PATH_MAX) < 0)
        return -errno;

    name = strrchr(link, '/');
    if (!name)
        return -EINVAL;

    if (strncmp(name, "/pci", 4) == 0)
        return DRM_BUS_PCI;

    if (strncmp(name, "/usb", 4) == 0)
        return DRM_BUS_USB;

    if (strncmp(name, "/platform", 9) == 0)
        return DRM_BUS_PLATFORM;

    if (strncmp(name, "/host1x", 7) == 0)
        return DRM_BUS_HOST1X;

    return -EINVAL;
#elif defined(__OpenBSD__)
    return DRM_BUS_PCI;
#else
#warning "Missing implementation of drmParseSubsystemType"
    return -EINVAL;
#endif
}

static int drmParsePciBusInfo(int maj, int min, drmPciBusInfoPtr info)
{
#ifdef __linux__
    unsigned int domain, bus, dev, func;
    char path[PATH_MAX + 1], *value;
    int num;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    value = sysfs_uevent_get(path, "PCI_SLOT_NAME");
    if (!value)
        return -ENOENT;

    num = sscanf(value, "%04x:%02x:%02x.%1u", &domain, &bus, &dev, &func);
    free(value);

    if (num != 4)
        return -EINVAL;

    info->domain = domain;
    info->bus = bus;
    info->dev = dev;
    info->func = func;

    return 0;
#elif defined(__OpenBSD__)
    struct drm_pciinfo pinfo;
    int fd, type;

    type = drmGetMinorType(min);
    if (type == -1)
        return -ENODEV;

    fd = drmOpenMinor(min, 0, type);
    if (fd < 0)
        return -errno;

    if (drmIoctl(fd, DRM_IOCTL_GET_PCIINFO, &pinfo)) {
        close(fd);
        return -errno;
    }
    close(fd);

    info->domain = pinfo.domain;
    info->bus = pinfo.bus;
    info->dev = pinfo.dev;
    info->func = pinfo.func;

    return 0;
#else
#warning "Missing implementation of drmParsePciBusInfo"
    return -EINVAL;
#endif
}

static int drmCompareBusInfo(drmDevicePtr a, drmDevicePtr b)
{
    if (a == NULL || b == NULL)
        return -1;

    if (a->bustype != b->bustype)
        return -1;

    switch (a->bustype) {
    case DRM_BUS_PCI:
        return memcmp(a->businfo.pci, b->businfo.pci, sizeof(drmPciBusInfo));

    case DRM_BUS_USB:
        return memcmp(a->businfo.usb, b->businfo.usb, sizeof(drmUsbBusInfo));

    case DRM_BUS_PLATFORM:
        return memcmp(a->businfo.platform, b->businfo.platform, sizeof(drmPlatformBusInfo));

    case DRM_BUS_HOST1X:
        return memcmp(a->businfo.host1x, b->businfo.host1x, sizeof(drmHost1xBusInfo));

    default:
        break;
    }

    return -1;
}

static int drmGetNodeType(const char *name)
{
    if (strncmp(name, DRM_PRIMARY_MINOR_NAME,
        sizeof(DRM_PRIMARY_MINOR_NAME) - 1) == 0)
        return DRM_NODE_PRIMARY;

    if (strncmp(name, DRM_CONTROL_MINOR_NAME,
        sizeof(DRM_CONTROL_MINOR_NAME ) - 1) == 0)
        return DRM_NODE_CONTROL;

    if (strncmp(name, DRM_RENDER_MINOR_NAME,
        sizeof(DRM_RENDER_MINOR_NAME) - 1) == 0)
        return DRM_NODE_RENDER;

    return -EINVAL;
}

static int drmGetMaxNodeName(void)
{
    return sizeof(DRM_DIR_NAME) +
           MAX3(sizeof(DRM_PRIMARY_MINOR_NAME),
                sizeof(DRM_CONTROL_MINOR_NAME),
                sizeof(DRM_RENDER_MINOR_NAME)) +
           3 /* length of the node number */;
}

#ifdef __linux__
static int parse_separate_sysfs_files(int maj, int min,
                                      drmPciDeviceInfoPtr device,
                                      bool ignore_revision)
{
#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
    static const char *attrs[] = {
      "revision", /* Older kernels are missing the file, so check for it first */
      "vendor",
      "device",
      "subsystem_vendor",
      "subsystem_device",
    };
    char path[PATH_MAX + 1];
    unsigned int data[ARRAY_SIZE(attrs)];
    FILE *fp;
    int ret;

    for (unsigned i = ignore_revision ? 1 : 0; i < ARRAY_SIZE(attrs); i++) {
        snprintf(path, PATH_MAX, "/sys/dev/char/%d:%d/device/%s", maj, min,
                 attrs[i]);
        fp = fopen(path, "r");
        if (!fp)
            return -errno;

        ret = fscanf(fp, "%x", &data[i]);
        fclose(fp);
        if (ret != 1)
            return -errno;

    }

    device->revision_id = ignore_revision ? 0xff : data[0] & 0xff;
    device->vendor_id = data[1] & 0xffff;
    device->device_id = data[2] & 0xffff;
    device->subvendor_id = data[3] & 0xffff;
    device->subdevice_id = data[4] & 0xffff;

    return 0;
}

static int parse_config_sysfs_file(int maj, int min,
                                   drmPciDeviceInfoPtr device)
{
    char path[PATH_MAX + 1];
    unsigned char config[64];
    int fd, ret;

    snprintf(path, PATH_MAX, "/sys/dev/char/%d:%d/device/config", maj, min);
    fd = open(path, O_RDONLY);
    if (fd < 0)
        return -errno;

    ret = read(fd, config, sizeof(config));
    close(fd);
    if (ret < 0)
        return -errno;

    device->vendor_id = config[0] | (config[1] << 8);
    device->device_id = config[2] | (config[3] << 8);
    device->revision_id = config[8];
    device->subvendor_id = config[44] | (config[45] << 8);
    device->subdevice_id = config[46] | (config[47] << 8);

    return 0;
}
#endif

static int drmParsePciDeviceInfo(int maj, int min,
                                 drmPciDeviceInfoPtr device,
                                 uint32_t flags)
{
#ifdef __linux__
    if (!(flags & DRM_DEVICE_GET_PCI_REVISION))
        return parse_separate_sysfs_files(maj, min, device, true);

    if (parse_separate_sysfs_files(maj, min, device, false))
        return parse_config_sysfs_file(maj, min, device);

    return 0;
#elif defined(__OpenBSD__)
    struct drm_pciinfo pinfo;
    int fd, type;

    type = drmGetMinorType(min);
    if (type == -1)
        return -ENODEV;

    fd = drmOpenMinor(min, 0, type);
    if (fd < 0)
        return -errno;

    if (drmIoctl(fd, DRM_IOCTL_GET_PCIINFO, &pinfo)) {
        close(fd);
        return -errno;
    }
    close(fd);

    device->vendor_id = pinfo.vendor_id;
    device->device_id = pinfo.device_id;
    device->revision_id = pinfo.revision_id;
    device->subvendor_id = pinfo.subvendor_id;
    device->subdevice_id = pinfo.subdevice_id;

    return 0;
#else
#warning "Missing implementation of drmParsePciDeviceInfo"
    return -EINVAL;
#endif
}

static void drmFreePlatformDevice(drmDevicePtr device)
{
    if (device->deviceinfo.platform) {
        if (device->deviceinfo.platform->compatible) {
            char **compatible = device->deviceinfo.platform->compatible;

            while (*compatible) {
                free(*compatible);
                compatible++;
            }

            free(device->deviceinfo.platform->compatible);
        }
    }
}

static void drmFreeHost1xDevice(drmDevicePtr device)
{
    if (device->deviceinfo.host1x) {
        if (device->deviceinfo.host1x->compatible) {
            char **compatible = device->deviceinfo.host1x->compatible;

            while (*compatible) {
                free(*compatible);
                compatible++;
            }

            free(device->deviceinfo.host1x->compatible);
        }
    }
}

void drmFreeDevice(drmDevicePtr *device)
{
    if (device == NULL)
        return;

    if (*device) {
        switch ((*device)->bustype) {
        case DRM_BUS_PLATFORM:
            drmFreePlatformDevice(*device);
            break;

        case DRM_BUS_HOST1X:
            drmFreeHost1xDevice(*device);
            break;
        }
    }

    free(*device);
    *device = NULL;
}

void drmFreeDevices(drmDevicePtr devices[], int count)
{
    int i;

    if (devices == NULL)
        return;

    for (i = 0; i < count; i++)
        if (devices[i])
            drmFreeDevice(&devices[i]);
}

static drmDevicePtr drmDeviceAlloc(unsigned int type, const char *node,
                                   size_t bus_size, size_t device_size,
                                   char **ptrp)
{
    size_t max_node_length, extra, size;
    drmDevicePtr device;
    unsigned int i;
    char *ptr;

    max_node_length = ALIGN(drmGetMaxNodeName(), sizeof(void *));
    extra = DRM_NODE_MAX * (sizeof(void *) + max_node_length);

    size = sizeof(*device) + extra + bus_size + device_size;

    device = calloc(1, size);
    if (!device)
        return NULL;

    device->available_nodes = 1 << type;

    ptr = (char *)device + sizeof(*device);
    device->nodes = (char **)ptr;

    ptr += DRM_NODE_MAX * sizeof(void *);

    for (i = 0; i < DRM_NODE_MAX; i++) {
        device->nodes[i] = ptr;
        ptr += max_node_length;
    }

    memcpy(device->nodes[type], node, max_node_length);

    *ptrp = ptr;

    return device;
}

static int drmProcessPciDevice(drmDevicePtr *device,
                               const char *node, int node_type,
                               int maj, int min, bool fetch_deviceinfo,
                               uint32_t flags)
{
    drmDevicePtr dev;
    char *addr;
    int ret;

    dev = drmDeviceAlloc(node_type, node, sizeof(drmPciBusInfo),
                         sizeof(drmPciDeviceInfo), &addr);
    if (!dev)
        return -ENOMEM;

    dev->bustype = DRM_BUS_PCI;

    dev->businfo.pci = (drmPciBusInfoPtr)addr;

    ret = drmParsePciBusInfo(maj, min, dev->businfo.pci);
    if (ret)
        goto free_device;

    // Fetch the device info if the user has requested it
    if (fetch_deviceinfo) {
        addr += sizeof(drmPciBusInfo);
        dev->deviceinfo.pci = (drmPciDeviceInfoPtr)addr;

        ret = drmParsePciDeviceInfo(maj, min, dev->deviceinfo.pci, flags);
        if (ret)
            goto free_device;
    }

    *device = dev;

    return 0;

free_device:
    free(dev);
    return ret;
}

static int drmParseUsbBusInfo(int maj, int min, drmUsbBusInfoPtr info)
{
#ifdef __linux__
    char path[PATH_MAX + 1], *value;
    unsigned int bus, dev;
    int ret;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    value = sysfs_uevent_get(path, "BUSNUM");
    if (!value)
        return -ENOENT;

    ret = sscanf(value, "%03u", &bus);
    free(value);

    if (ret <= 0)
        return -errno;

    value = sysfs_uevent_get(path, "DEVNUM");
    if (!value)
        return -ENOENT;

    ret = sscanf(value, "%03u", &dev);
    free(value);

    if (ret <= 0)
        return -errno;

    info->bus = bus;
    info->dev = dev;

    return 0;
#else
#warning "Missing implementation of drmParseUsbBusInfo"
    return -EINVAL;
#endif
}

static int drmParseUsbDeviceInfo(int maj, int min, drmUsbDeviceInfoPtr info)
{
#ifdef __linux__
    char path[PATH_MAX + 1], *value;
    unsigned int vendor, product;
    int ret;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    value = sysfs_uevent_get(path, "PRODUCT");
    if (!value)
        return -ENOENT;

    ret = sscanf(value, "%x/%x", &vendor, &product);
    free(value);

    if (ret <= 0)
        return -errno;

    info->vendor = vendor;
    info->product = product;

    return 0;
#else
#warning "Missing implementation of drmParseUsbDeviceInfo"
    return -EINVAL;
#endif
}

static int drmProcessUsbDevice(drmDevicePtr *device, const char *node,
                               int node_type, int maj, int min,
                               bool fetch_deviceinfo, uint32_t flags)
{
    drmDevicePtr dev;
    char *ptr;
    int ret;

    dev = drmDeviceAlloc(node_type, node, sizeof(drmUsbBusInfo),
                         sizeof(drmUsbDeviceInfo), &ptr);
    if (!dev)
        return -ENOMEM;

    dev->bustype = DRM_BUS_USB;

    dev->businfo.usb = (drmUsbBusInfoPtr)ptr;

    ret = drmParseUsbBusInfo(maj, min, dev->businfo.usb);
    if (ret < 0)
        goto free_device;

    if (fetch_deviceinfo) {
        ptr += sizeof(drmUsbBusInfo);
        dev->deviceinfo.usb = (drmUsbDeviceInfoPtr)ptr;

        ret = drmParseUsbDeviceInfo(maj, min, dev->deviceinfo.usb);
        if (ret < 0)
            goto free_device;
    }

    *device = dev;

    return 0;

free_device:
    free(dev);
    return ret;
}

static int drmParsePlatformBusInfo(int maj, int min, drmPlatformBusInfoPtr info)
{
#ifdef __linux__
    char path[PATH_MAX + 1], *name;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    name = sysfs_uevent_get(path, "OF_FULLNAME");
    if (!name)
        return -ENOENT;

    strncpy(info->fullname, name, DRM_PLATFORM_DEVICE_NAME_LEN);
    info->fullname[DRM_PLATFORM_DEVICE_NAME_LEN - 1] = '\0';
    free(name);

    return 0;
#else
#warning "Missing implementation of drmParsePlatformBusInfo"
    return -EINVAL;
#endif
}

static int drmParsePlatformDeviceInfo(int maj, int min,
                                      drmPlatformDeviceInfoPtr info)
{
#ifdef __linux__
    char path[PATH_MAX + 1], *value;
    unsigned int count, i;
    int err;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    value = sysfs_uevent_get(path, "OF_COMPATIBLE_N");
    if (!value)
        return -ENOENT;

    sscanf(value, "%u", &count);
    free(value);

    info->compatible = calloc(count + 1, sizeof(*info->compatible));
    if (!info->compatible)
        return -ENOMEM;

    for (i = 0; i < count; i++) {
        value = sysfs_uevent_get(path, "OF_COMPATIBLE_%u", i);
        if (!value) {
            err = -ENOENT;
            goto free;
        }

        info->compatible[i] = value;
    }

    return 0;

free:
    while (i--)
        free(info->compatible[i]);

    free(info->compatible);
    return err;
#else
#warning "Missing implementation of drmParsePlatformDeviceInfo"
    return -EINVAL;
#endif
}

static int drmProcessPlatformDevice(drmDevicePtr *device,
                                    const char *node, int node_type,
                                    int maj, int min, bool fetch_deviceinfo,
                                    uint32_t flags)
{
    drmDevicePtr dev;
    char *ptr;
    int ret;

    dev = drmDeviceAlloc(node_type, node, sizeof(drmPlatformBusInfo),
                         sizeof(drmPlatformDeviceInfo), &ptr);
    if (!dev)
        return -ENOMEM;

    dev->bustype = DRM_BUS_PLATFORM;

    dev->businfo.platform = (drmPlatformBusInfoPtr)ptr;

    ret = drmParsePlatformBusInfo(maj, min, dev->businfo.platform);
    if (ret < 0)
        goto free_device;

    if (fetch_deviceinfo) {
        ptr += sizeof(drmPlatformBusInfo);
        dev->deviceinfo.platform = (drmPlatformDeviceInfoPtr)ptr;

        ret = drmParsePlatformDeviceInfo(maj, min, dev->deviceinfo.platform);
        if (ret < 0)
            goto free_device;
    }

    *device = dev;

    return 0;

free_device:
    free(dev);
    return ret;
}

static int drmParseHost1xBusInfo(int maj, int min, drmHost1xBusInfoPtr info)
{
#ifdef __linux__
    char path[PATH_MAX + 1], *name;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    name = sysfs_uevent_get(path, "OF_FULLNAME");
    if (!name)
        return -ENOENT;

    strncpy(info->fullname, name, DRM_HOST1X_DEVICE_NAME_LEN);
    info->fullname[DRM_HOST1X_DEVICE_NAME_LEN - 1] = '\0';
    free(name);

    return 0;
#else
#warning "Missing implementation of drmParseHost1xBusInfo"
    return -EINVAL;
#endif
}

static int drmParseHost1xDeviceInfo(int maj, int min,
                                    drmHost1xDeviceInfoPtr info)
{
#ifdef __linux__
    char path[PATH_MAX + 1], *value;
    unsigned int count, i;
    int err;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    value = sysfs_uevent_get(path, "OF_COMPATIBLE_N");
    if (!value)
        return -ENOENT;

    sscanf(value, "%u", &count);
    free(value);

    info->compatible = calloc(count + 1, sizeof(*info->compatible));
    if (!info->compatible)
        return -ENOMEM;

    for (i = 0; i < count; i++) {
        value = sysfs_uevent_get(path, "OF_COMPATIBLE_%u", i);
        if (!value) {
            err = -ENOENT;
            goto free;
        }

        info->compatible[i] = value;
    }

    return 0;

free:
    while (i--)
        free(info->compatible[i]);

    free(info->compatible);
    return err;
#else
#warning "Missing implementation of drmParseHost1xDeviceInfo"
    return -EINVAL;
#endif
}

static int drmProcessHost1xDevice(drmDevicePtr *device,
                                  const char *node, int node_type,
                                  int maj, int min, bool fetch_deviceinfo,
                                  uint32_t flags)
{
    drmDevicePtr dev;
    char *ptr;
    int ret;

    dev = drmDeviceAlloc(node_type, node, sizeof(drmHost1xBusInfo),
                         sizeof(drmHost1xDeviceInfo), &ptr);
    if (!dev)
        return -ENOMEM;

    dev->bustype = DRM_BUS_HOST1X;

    dev->businfo.host1x = (drmHost1xBusInfoPtr)ptr;

    ret = drmParseHost1xBusInfo(maj, min, dev->businfo.host1x);
    if (ret < 0)
        goto free_device;

    if (fetch_deviceinfo) {
        ptr += sizeof(drmHost1xBusInfo);
        dev->deviceinfo.host1x = (drmHost1xDeviceInfoPtr)ptr;

        ret = drmParseHost1xDeviceInfo(maj, min, dev->deviceinfo.host1x);
        if (ret < 0)
            goto free_device;
    }

    *device = dev;

    return 0;

free_device:
    free(dev);
    return ret;
}

/* Consider devices located on the same bus as duplicate and fold the respective
 * entries into a single one.
 *
 * Note: this leaves "gaps" in the array, while preserving the length.
 */
static void drmFoldDuplicatedDevices(drmDevicePtr local_devices[], int count)
{
    int node_type, i, j;

    for (i = 0; i < count; i++) {
        for (j = i + 1; j < count; j++) {
            if (drmCompareBusInfo(local_devices[i], local_devices[j]) == 0) {
                local_devices[i]->available_nodes |= local_devices[j]->available_nodes;
                node_type = log2(local_devices[j]->available_nodes);
                memcpy(local_devices[i]->nodes[node_type],
                       local_devices[j]->nodes[node_type], drmGetMaxNodeName());
                drmFreeDevice(&local_devices[j]);
            }
        }
    }
}

/* Check that the given flags are valid returning 0 on success */
static int
drm_device_validate_flags(uint32_t flags)
{
        return (flags & ~DRM_DEVICE_GET_PCI_REVISION);
}

/**
 * Get information about the opened drm device
 *
 * \param fd file descriptor of the drm device
 * \param flags feature/behaviour bitmask
 * \param device the address of a drmDevicePtr where the information
 *               will be allocated in stored
 *
 * \return zero on success, negative error code otherwise.
 *
 * \note Unlike drmGetDevice it does not retrieve the pci device revision field
 * unless the DRM_DEVICE_GET_PCI_REVISION \p flag is set.
 */
int drmGetDevice2(int fd, uint32_t flags, drmDevicePtr *device)
{
#ifdef __OpenBSD__
    /*
     * DRI device nodes on OpenBSD are not in their own directory, they reside
     * in /dev along with a large number of statically generated /dev nodes.
     * Avoid stat'ing all of /dev needlessly by implementing this custom path.
     */
    drmDevicePtr     d;
    struct stat      sbuf;
    char             node[PATH_MAX + 1];
    const char      *dev_name;
    int              node_type, subsystem_type;
    int              maj, min, n, ret, base;

    if (fd == -1 || device == NULL)
        return -EINVAL;

    if (fstat(fd, &sbuf))
        return -errno;

    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);

    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
        return -EINVAL;

    node_type = drmGetMinorType(min);
    if (node_type == -1)
        return -ENODEV;

    switch (node_type) {
    case DRM_NODE_PRIMARY:
        dev_name = DRM_DEV_NAME;
        break;
    case DRM_NODE_CONTROL:
        dev_name = DRM_CONTROL_DEV_NAME;
        break;
    case DRM_NODE_RENDER:
        dev_name = DRM_RENDER_DEV_NAME;
        break;
    default:
        return -EINVAL;
    };

    base = drmGetMinorBase(node_type);
    if (base < 0)
        return -EINVAL;

    n = snprintf(node, PATH_MAX, dev_name, DRM_DIR_NAME, min - base);
    if (n == -1 || n >= PATH_MAX)
      return -errno;
    if (stat(node, &sbuf))
        return -EINVAL;

    subsystem_type = drmParseSubsystemType(maj, min);
    if (subsystem_type != DRM_BUS_PCI)
        return -ENODEV;

    ret = drmProcessPciDevice(&d, node, node_type, maj, min, true, flags);
    if (ret)
        return ret;

    *device = d;

    return 0;
#else
    drmDevicePtr *local_devices;
    drmDevicePtr d;
    DIR *sysdir;
    struct dirent *dent;
    struct stat sbuf;
    char node[PATH_MAX + 1];
    int node_type, subsystem_type;
    int maj, min;
    int ret, i, node_count;
    int max_count = 16;
    dev_t find_rdev;

    if (drm_device_validate_flags(flags))
        return -EINVAL;

    if (fd == -1 || device == NULL)
        return -EINVAL;

    if (fstat(fd, &sbuf))
        return -errno;

    find_rdev = sbuf.st_rdev;
    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);

    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
        return -EINVAL;

    subsystem_type = drmParseSubsystemType(maj, min);

    local_devices = calloc(max_count, sizeof(drmDevicePtr));
    if (local_devices == NULL)
        return -ENOMEM;

    sysdir = opendir(DRM_DIR_NAME);
    if (!sysdir) {
        ret = -errno;
        goto free_locals;
    }

    i = 0;
    while ((dent = readdir(sysdir))) {
        node_type = drmGetNodeType(dent->d_name);
        if (node_type < 0)
            continue;

        snprintf(node, PATH_MAX, "%s/%s", DRM_DIR_NAME, dent->d_name);
        if (stat(node, &sbuf))
            continue;

        maj = major(sbuf.st_rdev);
        min = minor(sbuf.st_rdev);

        if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
            continue;

        if (drmParseSubsystemType(maj, min) != subsystem_type)
            continue;

        switch (subsystem_type) {
        case DRM_BUS_PCI:
            ret = drmProcessPciDevice(&d, node, node_type, maj, min, true, flags);
            if (ret)
                continue;

            break;

        case DRM_BUS_USB:
            ret = drmProcessUsbDevice(&d, node, node_type, maj, min, true, flags);
            if (ret)
                continue;

            break;

        case DRM_BUS_PLATFORM:
            ret = drmProcessPlatformDevice(&d, node, node_type, maj, min, true, flags);
            if (ret)
                continue;

            break;

        case DRM_BUS_HOST1X:
            ret = drmProcessHost1xDevice(&d, node, node_type, maj, min, true, flags);
            if (ret)
                continue;

            break;

        default:
            continue;
        }

        if (i >= max_count) {
            drmDevicePtr *temp;

            max_count += 16;
            temp = realloc(local_devices, max_count * sizeof(drmDevicePtr));
            if (!temp)
                goto free_devices;
            local_devices = temp;
        }

        /* store target at local_devices[0] for ease to use below */
        if (find_rdev == sbuf.st_rdev && i) {
            local_devices[i] = local_devices[0];
            local_devices[0] = d;
        }
        else
            local_devices[i] = d;
        i++;
    }
    node_count = i;

    drmFoldDuplicatedDevices(local_devices, node_count);

    *device = local_devices[0];
    drmFreeDevices(&local_devices[1], node_count - 1);

    closedir(sysdir);
    free(local_devices);
    if (*device == NULL)
        return -ENODEV;
    return 0;

free_devices:
    drmFreeDevices(local_devices, i);
    closedir(sysdir);

free_locals:
    free(local_devices);
    return ret;
#endif
}

/**
 * Get information about the opened drm device
 *
 * \param fd file descriptor of the drm device
 * \param device the address of a drmDevicePtr where the information
 *               will be allocated in stored
 *
 * \return zero on success, negative error code otherwise.
 */
int drmGetDevice(int fd, drmDevicePtr *device)
{
    return drmGetDevice2(fd, DRM_DEVICE_GET_PCI_REVISION, device);
}

/**
 * Get drm devices on the system
 *
 * \param flags feature/behaviour bitmask
 * \param devices the array of devices with drmDevicePtr elements
 *                can be NULL to get the device number first
 * \param max_devices the maximum number of devices for the array
 *
 * \return on error - negative error code,
 *         if devices is NULL - total number of devices available on the system,
 *         alternatively the number of devices stored in devices[], which is
 *         capped by the max_devices.
 *
 * \note Unlike drmGetDevices it does not retrieve the pci device revision field
 * unless the DRM_DEVICE_GET_PCI_REVISION \p flag is set.
 */
int drmGetDevices2(uint32_t flags, drmDevicePtr devices[], int max_devices)
{
    drmDevicePtr *local_devices;
    drmDevicePtr device;
    DIR *sysdir;
    struct dirent *dent;
    struct stat sbuf;
    char node[PATH_MAX + 1];
    int node_type, subsystem_type;
    int maj, min;
    int ret, i, node_count, device_count;
    int max_count = 16;

    if (drm_device_validate_flags(flags))
        return -EINVAL;

    local_devices = calloc(max_count, sizeof(drmDevicePtr));
    if (local_devices == NULL)
        return -ENOMEM;

    sysdir = opendir(DRM_DIR_NAME);
    if (!sysdir) {
        ret = -errno;
        goto free_locals;
    }

    i = 0;
    while ((dent = readdir(sysdir))) {
        node_type = drmGetNodeType(dent->d_name);
        if (node_type < 0)
            continue;

        snprintf(node, PATH_MAX, "%s/%s", DRM_DIR_NAME, dent->d_name);
        if (stat(node, &sbuf))
            continue;

        maj = major(sbuf.st_rdev);
        min = minor(sbuf.st_rdev);

        if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
            continue;

        subsystem_type = drmParseSubsystemType(maj, min);

        if (subsystem_type < 0)
            continue;

        switch (subsystem_type) {
        case DRM_BUS_PCI:
            ret = drmProcessPciDevice(&device, node, node_type,
                                      maj, min, devices != NULL, flags);
            if (ret)
                continue;

            break;

        case DRM_BUS_USB:
            ret = drmProcessUsbDevice(&device, node, node_type, maj, min,
                                      devices != NULL, flags);
            if (ret)
                goto free_devices;

            break;

        case DRM_BUS_PLATFORM:
            ret = drmProcessPlatformDevice(&device, node, node_type, maj, min,
                                           devices != NULL, flags);
            if (ret)
                goto free_devices;

            break;

        case DRM_BUS_HOST1X:
            ret = drmProcessHost1xDevice(&device, node, node_type, maj, min,
                                         devices != NULL, flags);
            if (ret)
                goto free_devices;

            break;

        default:
            continue;
        }

        if (i >= max_count) {
            drmDevicePtr *temp;

            max_count += 16;
            temp = realloc(local_devices, max_count * sizeof(drmDevicePtr));
            if (!temp)
                goto free_devices;
            local_devices = temp;
        }

        local_devices[i] = device;
        i++;
    }
    node_count = i;

    drmFoldDuplicatedDevices(local_devices, node_count);

    device_count = 0;
    for (i = 0; i < node_count; i++) {
        if (!local_devices[i])
            continue;

        if ((devices != NULL) && (device_count < max_devices))
            devices[device_count] = local_devices[i];
        else
            drmFreeDevice(&local_devices[i]);

        device_count++;
    }

    closedir(sysdir);
    free(local_devices);
    return device_count;

free_devices:
    drmFreeDevices(local_devices, i);
    closedir(sysdir);

free_locals:
    free(local_devices);
    return ret;
}

/**
 * Get drm devices on the system
 *
 * \param devices the array of devices with drmDevicePtr elements
 *                can be NULL to get the device number first
 * \param max_devices the maximum number of devices for the array
 *
 * \return on error - negative error code,
 *         if devices is NULL - total number of devices available on the system,
 *         alternatively the number of devices stored in devices[], which is
 *         capped by the max_devices.
 */
int drmGetDevices(drmDevicePtr devices[], int max_devices)
{
    return drmGetDevices2(DRM_DEVICE_GET_PCI_REVISION, devices, max_devices);
}

char *drmGetDeviceNameFromFd2(int fd)
{
#ifdef __linux__
    struct stat sbuf;
    char path[PATH_MAX + 1], *value;
    unsigned int maj, min;

    if (fstat(fd, &sbuf))
        return NULL;

    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);

    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
        return NULL;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d", maj, min);

    value = sysfs_uevent_get(path, "DEVNAME");
    if (!value)
        return NULL;

    snprintf(path, sizeof(path), "/dev/%s", value);
    free(value);

    return strdup(path);
#else
    struct stat      sbuf;
    char             node[PATH_MAX + 1];
    const char      *dev_name;
    int              node_type;
    int              maj, min, n, base;

    if (fstat(fd, &sbuf))
        return NULL;

    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);

    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
        return NULL;

    node_type = drmGetMinorType(min);
    if (node_type == -1)
        return NULL;

    switch (node_type) {
    case DRM_NODE_PRIMARY:
        dev_name = DRM_DEV_NAME;
        break;
    case DRM_NODE_CONTROL:
        dev_name = DRM_CONTROL_DEV_NAME;
        break;
    case DRM_NODE_RENDER:
        dev_name = DRM_RENDER_DEV_NAME;
        break;
    default:
        return NULL;
    };

    base = drmGetMinorBase(node_type);
    if (base < 0)
        return NULL;

    n = snprintf(node, PATH_MAX, dev_name, DRM_DIR_NAME, min - base);
    if (n == -1 || n >= PATH_MAX)
      return NULL;

    return strdup(node);
#endif
}
@


1.26
log
@Drop the local diff to avoid calling drm set/drop master ioctls,
the kernel implements these as noops now.
@
text
@a105 1

a120 1

d2863 2
d2866 1
a2866 2
    char buf[PATH_MAX + 1];
    int n;
d2877 19
a2895 1
    n = snprintf(buf, sizeof(buf), DRM_DEV_NAME, DRM_DIR_NAME, min);
d2914 44
d2978 9
d2989 1
a2989 1
	return DRM_BUS_PCI;
d2999 3
a3001 5
    char path[PATH_MAX + 1];
    char data[512 + 1];
    char *str;
    int domain, bus, dev, func;
    int fd, ret;
d3003 1
a3003 4
    snprintf(path, PATH_MAX, "/sys/dev/char/%d:%d/device/uevent", maj, min);
    fd = open(path, O_RDONLY);
    if (fd < 0)
        return -errno;
d3005 3
a3007 5
    ret = read(fd, data, sizeof(data));
    data[sizeof(data)-1] = '\0';
    close(fd);
    if (ret < 0)
        return -errno;
d3009 2
a3010 4
#define TAG "PCI_SLOT_NAME="
    str = strstr(data, TAG);
    if (str == NULL)
        return -EINVAL;
d3012 1
a3012 2
    if (sscanf(str, TAG "%04x:%02x:%02x.%1u",
               &domain, &bus, &dev, &func) != 4)
a3013 1
#undef TAG
d3023 5
a3027 1
    int fd;
d3029 1
a3029 1
    fd = drmOpenMinor(min, 0, DRM_NODE_PRIMARY);
d3062 10
d3105 43
a3147 2
static int drmParsePciDeviceInfo(const char *d_name,
                                 drmPciDeviceInfoPtr device)
a3148 1
#ifdef __linux__
d3153 1
a3153 1
    snprintf(path, PATH_MAX, "/sys/class/drm/%s/device/config", d_name);
d3170 15
d3187 1
a3187 2
    char buf[PATH_MAX + 1];
    int fd, n;
d3189 3
a3191 9
    n = snprintf(buf, sizeof(buf), "%s/%s", DRM_DIR_NAME, d_name);
    if (n == -1 || n >= sizeof(buf))
        return -errno;

#ifndef X_PRIVSEP
    fd = open(buf, O_RDWR, 0);
#else
    fd = priv_open_device(buf);
#endif
d3193 1
d3216 32
d3253 12
d3281 3
a3283 3
static int drmProcessPciDevice(drmDevicePtr *device, const char *d_name,
                               const char *node, int node_type,
                               int maj, int min, bool fetch_deviceinfo)
d3285 9
a3293 3
    const int max_node_str = ALIGN(drmGetMaxNodeName(), sizeof(void *));
    int ret, i;
    char *addr;
d3295 3
a3297 6
    *device = calloc(1, sizeof(drmDevice) +
                     (DRM_NODE_MAX * (sizeof(void *) + max_node_str)) +
                     sizeof(drmPciBusInfo) +
                     sizeof(drmPciDeviceInfo));
    if (!*device)
        return -ENOMEM;
d3299 1
a3299 1
    addr = (char*)*device;
d3301 2
a3302 2
    (*device)->bustype = DRM_BUS_PCI;
    (*device)->available_nodes = 1 << node_type;
d3304 1
a3304 2
    addr += sizeof(drmDevice);
    (*device)->nodes = (char**)addr;
a3305 1
    addr += DRM_NODE_MAX * sizeof(void *);
d3307 2
a3308 2
        (*device)->nodes[i] = addr;
        addr += max_node_str;
a3309 1
    memcpy((*device)->nodes[node_type], node, max_node_str);
d3311 1
a3311 1
    (*device)->businfo.pci = (drmPciBusInfoPtr)addr;
d3313 24
a3336 1
    ret = drmParsePciBusInfo(maj, min, (*device)->businfo.pci);
d3343 1
a3343 1
        (*device)->deviceinfo.pci = (drmPciDeviceInfoPtr)addr;
d3345 1
a3345 1
        ret = drmParsePciDeviceInfo(d_name, (*device)->deviceinfo.pci);
d3349 324
d3676 1
a3676 2
    free(*device);
    *device = NULL;
d3702 7
d3713 1
d3718 3
d3722 1
a3722 1
int drmGetDevice(int fd, drmDevicePtr *device)
d3725 11
a3735 7
    drmDevicePtr d;
    struct stat sbuf;
    char node[PATH_MAX + 1];
    char d_name[PATH_MAX + 1];
    int maj, min, n;
    int ret;
    int max_count = 1;
d3749 21
a3769 3
    n = snprintf(d_name, PATH_MAX, "drm%d", min);
    if (n == -1 || n >= PATH_MAX)
      return -errno;
d3771 1
a3771 1
    n = snprintf(node, PATH_MAX, DRM_DEV_NAME, DRM_DIR_NAME, min);
d3777 5
a3781 2
    ret = drmProcessPciDevice(&d, d_name, node, DRM_NODE_PRIMARY,
			      maj, min, true);
d3801 3
d3850 1
a3850 2
            ret = drmProcessPciDevice(&d, dent->d_name, node, node_type,
                                      maj, min, true);
d3852 22
a3873 1
                goto free_devices;
d3876 1
d3910 1
a3910 1
	return -ENODEV;
d3924 14
d3940 1
d3949 3
d3953 1
a3953 1
int drmGetDevices(drmDevicePtr devices[], int max_devices)
d3966 3
d4002 10
a4011 2
            ret = drmProcessPciDevice(&device, dent->d_name, node, node_type,
                                      maj, min, devices != NULL);
d4016 17
d4078 89
@


1.25
log
@Implement an OpenBSD specific codepath for drmGetDevice

The existing code walks all of /dev looking for different types of drm
nodes.  We just have primary nodes and can directly map the minor number
to a path.

ok kettenis@@
@
text
@a2718 1
#ifndef __OpenBSD__
a2719 2
#endif
	return 0;
a2723 1
#ifndef __OpenBSD__
a2724 2
#endif
	return 0;
@


1.24
log
@Implement drmParsePciBusInfo for OpenBSD by using the new
DRM_IOCTL_GET_PCIINFO ioctl.

ok kettenis@@
@
text
@d3207 40
d3354 1
@


1.23
log
@Implement drmParsePciDeviceInfo for OpenBSD by using the new
DRM_IOCTL_GET_PCIINFO ioctl.

ok kettenis@@
@
text
@d2968 20
@


1.22
log
@Implement drmParseSubsystemType for OpenBSD.

Always return DRM_BUS_PCI for now.  No non-pci drm drivers are in the
kernel and this is unlikely to change anytime soon as the existing ones
aren't permissively licensed.

ok kettenis@@
@
text
@d106 1
d108 15
d3041 31
@


1.21
log
@Implement drmGetMinorNameForFD for systems without sysfs by adapting
drm_get_device_name_for_fd() from the Mesa loader.

ok kettenis@@
@
text
@d2908 2
@


1.20
log
@Merge libdrm 2.4.73
@
text
@d2854 19
a2872 1
#warning "Missing implementation of drmGetMinorNameForFD"
@


1.19
log
@Merge libdrm 2.4.71
@
text
@d2900 1
a2900 1
    char data[128 + 1];
d2911 1
a2911 1
    data[128] = '\0';
a3184 1
            fprintf(stderr, "The subsystem type is not supported yet\n");
d3216 2
a3293 1
            fprintf(stderr, "The subsystem type is not supported yet\n");
@


1.18
log
@Merge libdrm 2.4.67
@
text
@d2 1
a2 1
 * \file xf86drm.c 
d57 5
a61 2
#ifdef HAVE_SYS_MKDEV_H
# include <sys/mkdev.h> /* defines major(), minor(), and makedev() on Solaris */
d76 3
a78 3
#define DRM_PRIMARY_MINOR_NAME	"drm"
#define DRM_CONTROL_MINOR_NAME	"drmC"
#define DRM_RENDER_MINOR_NAME	"drmR"
d80 3
a82 3
#define DRM_PRIMARY_MINOR_NAME	"card"
#define DRM_CONTROL_MINOR_NAME	"controlD"
#define DRM_RENDER_MINOR_NAME	"renderD"
d102 1
a102 1
#define DRM_MAJOR 226		/* Linux */
d138 1
a138 1
    va_list	ap;
d143 7
a149 7
	va_start(ap, format);
	if (drm_server_info) {
	  drm_server_info->debug_print(format,ap);
	} else {
	  drmDebugPrint(format, ap);
	}
	va_end(ap);
d176 1
a176 1
    int	ret;
d179 1
a179 1
	ret = ioctl(fd, request, arg);
d200 1
a200 1
	drmHashTable = drmHashCreate();
d203 5
a207 5
	entry           = drmMalloc(sizeof(*entry));
	entry->fd       = fd;
	entry->f        = NULL;
	entry->tagTable = drmHashCreate();
	drmHashInsert(drmHashTable, key, entry);
d209 1
a209 1
	entry = value;
d231 1
a231 1
	return 1;
d235 31
a265 31
	unsigned int o1, b1, d1, f1;
	unsigned int o2, b2, d2, f2;
	int ret;

	ret = sscanf(id1, "pci:%04x:%02x:%02x.%u", &o1, &b1, &d1, &f1);
	if (ret != 4) {
	    o1 = 0;
	    ret = sscanf(id1, "PCI:%u:%u:%u", &b1, &d1, &f1);
	    if (ret != 3)
		return 0;
	}

	ret = sscanf(id2, "pci:%04x:%02x:%02x.%u", &o2, &b2, &d2, &f2);
	if (ret != 4) {
	    o2 = 0;
	    ret = sscanf(id2, "PCI:%u:%u:%u", &b2, &d2, &f2);
	    if (ret != 3)
		return 0;
	}

	/* If domains aren't properly supported by the kernel interface,
	 * just ignore them, which sucks less than picking a totally random
	 * card with "open by name"
	 */
	if (!pci_domain_ok)
		o1 = o2 = 0;

	if ((o1 != o2) || (b1 != b2) || (d1 != d2) || (f1 != f2))
	    return 0;
	else
	    return 1;
d287 5
a291 1
	int rv;
d293 6
a298 10
	do {
		rv = chown(path, owner, group);
	} while (rv != 0 && errno == EINTR);

	if (rv == 0)
		return 0;

	drmMsg("Failed to change owner or group for file %s! %d: %s\n",
			path, errno, strerror(errno));
	return -1;
d319 1
a319 1
 * 
d343 2
a344 2
	    dev_name = DRM_DEV_NAME;
	    break;
d346 2
a347 2
	    dev_name = DRM_CONTROL_DEV_NAME;
	    break;
d349 2
a350 2
	    dev_name = DRM_RENDER_DEV_NAME;
	    break;
d352 1
a352 1
	    return -EINVAL;
d359 3
a361 3
	drm_server_info->get_perms(&serv_group, &serv_mode);
	devmode  = serv_mode ? serv_mode : DRM_DEV_MODE;
	devmode &= ~(S_IXUSR|S_IXGRP|S_IXOTH);
d367 5
a371 5
	if (!isroot)
	    return DRM_ERR_NOT_ROOT;
	mkdir(DRM_DIR_NAME, DRM_DEV_DIRMODE);
	chown_check_return(DRM_DIR_NAME, 0, 0); /* root:root */
	chmod(DRM_DIR_NAME, DRM_DEV_DIRMODE);
d376 4
a379 4
	if (!isroot)
	    return DRM_ERR_NOT_ROOT;
	remove(buf);
	mknod(buf, S_IFCHR | devmode, dev);
d383 3
a385 3
	group = ((int)serv_group >= 0) ? serv_group : DRM_DEV_GID;
	chown_check_return(buf, user, group);
	chmod(buf, devmode);
d390 1
a390 1
	int udev_count = 0;
d393 2
a394 2
		usleep(20);
		udev_count++;
d396 13
a408 13
		if (udev_count == 50)
			return -1;
		goto wait_for_udev;
	}

    	if (stat(buf, &st)) {
		usleep(20);
		udev_count++;

		if (udev_count == 50)
			return -1;
		goto wait_for_udev;
    	}
d419 1
a419 1
		fd, fd < 0 ? strerror(errno) : "OK");
d421 1
a421 1
	return fd;
d428 8
a435 8
	if (!isroot)
	    return DRM_ERR_NOT_ROOT;
	remove(buf);
	mknod(buf, S_IFCHR | devmode, dev);
	if (drm_server_info && drm_server_info->get_perms) {
	    chown_check_return(buf, user, group);
	    chmod(buf, devmode);
	}
d439 1
a439 1
		fd, fd < 0 ? strerror(errno) : "OK");
d441 1
a441 1
	return fd;
d457 1
a457 1
 * 
d467 1
a467 1
    
d469 2
a470 2
	return drmOpenDevice(makedev(DRM_MAJOR, minor), minor, type);
    
d473 2
a474 2
	    dev_name = DRM_DEV_NAME;
	    break;
d476 2
a477 2
	    dev_name = DRM_CONTROL_DEV_NAME;
	    break;
d479 2
a480 2
	    dev_name = DRM_RENDER_DEV_NAME;
	    break;
d482 1
a482 1
	    return -EINVAL;
d499 1
a499 1
 * 
d502 1
a502 1
 * \internal 
d515 3
a517 3
	/* Try proc for backward Linux compatibility */
	if (!access("/proc/dri/0", R_OK))
	    return 1;
d519 1
a519 1
	return 0;
d521 1
a521 1
    
d523 2
a524 2
	retval = 1;
	drmFreeVersion(version);
d603 11
a613 11
	fd = drmOpenMinor(i, 1, type);
	drmMsg("drmOpenByBusid: drmOpenMinor returns %d\n", fd);
	if (fd >= 0) {
	    /* We need to try for 1.4 first for proper PCI domain support
	     * and if that fails, we know the kernel is busted
	     */
	    sv.drm_di_major = 1;
	    sv.drm_di_minor = 4;
	    sv.drm_dd_major = -1;	/* Don't care */
	    sv.drm_dd_minor = -1;	/* Don't care */
	    if (drmSetInterfaceVersion(fd, &sv)) {
d615 1
a615 1
		pci_domain_ok = 0;
d617 17
a633 17
		sv.drm_di_major = 1;
		sv.drm_di_minor = 1;
		sv.drm_dd_major = -1;       /* Don't care */
		sv.drm_dd_minor = -1;       /* Don't care */
		drmMsg("drmOpenByBusid: Interface 1.4 failed, trying 1.1\n");
		drmSetInterfaceVersion(fd, &sv);
	    }
	    buf = drmGetBusid(fd);
	    drmMsg("drmOpenByBusid: drmGetBusid reports %s\n", buf);
	    if (buf && drmMatchBusID(buf, busid, pci_domain_ok)) {
		drmFreeBusid(buf);
		return fd;
	    }
	    if (buf)
		drmFreeBusid(buf);
	    close(fd);
	}
d644 1
a644 1
 * 
d646 1
a646 1
 * 
d651 1
a651 1
 * 
d670 19
a688 19
	if ((fd = drmOpenMinor(i, 1, type)) >= 0) {
	    if ((version = drmGetVersion(fd))) {
		if (!strcmp(version->name, name)) {
		    drmFreeVersion(version);
		    id = drmGetBusid(fd);
		    drmMsg("drmGetBusid returned '%s'\n", id ? id : "NULL");
		    if (!id || !*id) {
			if (id)
			    drmFreeBusid(id);
			return fd;
		    } else {
			drmFreeBusid(id);
		    }
		} else {
		    drmFreeVersion(version);
		}
	    }
	    close(fd);
	}
d694 26
a719 26
	char proc_name[64], buf[512];
	char *driver, *pt, *devstring;
	int  retcode;
	
	sprintf(proc_name, "/proc/dri/%d/name", i);
	if ((fd = open(proc_name, 0, 0)) >= 0) {
	    retcode = read(fd, buf, sizeof(buf)-1);
	    close(fd);
	    if (retcode) {
		buf[retcode-1] = '\0';
		for (driver = pt = buf; *pt && *pt != ' '; ++pt)
		    ;
		if (*pt) { /* Device is next */
		    *pt = '\0';
		    if (!strcmp(driver, name)) { /* Match */
			for (devstring = ++pt; *pt && *pt != ' '; ++pt)
			    ;
			if (*pt) { /* Found busid */
			    return drmOpenByBusid(++pt, type);
			} else { /* No busid */
			    return drmOpenDevice(strtol(devstring, NULL, 0),i, type);
			}
		    }
		}
	    }
	}
d735 1
a735 1
 * 
d737 1
a737 1
 * 
d767 5
a771 5
	/* try to load the kernel module */
	if (!drm_server_info->load_module(name)) {
	    drmMsg("[drm] failed to load kernel module \"%s\"\n", name);
	    return -1;
	}
d775 3
a777 3
	int fd = drmOpenByBusid(busid, type);
	if (fd >= 0)
	    return fd;
d779 1
a779 1
    
d781 1
a781 1
	return drmOpenByName(name, type);
d808 1
a808 1
	return;
d828 1
a828 1
	return;
d838 1
a838 1
 * 
d841 1
a841 1
 * 
d864 1
a864 1
 * 
d867 1
a867 1
 * 
d869 1
a869 1
 * 
d883 2
a884 2
	drmFreeKernelVersion(version);
	return NULL;
d888 1
a888 1
	version->name    = drmMalloc(version->name_len + 1);
d890 1
a890 1
	version->date    = drmMalloc(version->date_len + 1);
d892 1
a892 1
	version->desc    = drmMalloc(version->desc_len + 1);
d895 3
a897 3
	drmMsg("DRM_IOCTL_VERSION: %s\n", strerror(errno));
	drmFreeKernelVersion(version);
	return NULL;
d914 1
a914 1
 * 
d916 1
a916 1
 * 
d920 1
a920 1
 * 
d948 2
a949 2
	struct drm_get_cap cap;
	int ret;
d951 2
a952 2
	memclear(cap);
	cap.capability = capability;
d954 3
a956 3
	ret = drmIoctl(fd, DRM_IOCTL_GET_CAP, &cap);
	if (ret)
		return ret;
d958 2
a959 2
	*value = cap.value;
	return 0;
d964 1
a964 1
	struct drm_set_client_cap cap;
d966 3
a968 3
	memclear(cap);
	cap.capability = capability;
	cap.value = value;
d970 1
a970 1
	return drmIoctl(fd, DRM_IOCTL_SET_CLIENT_CAP, &cap);
d1006 1
a1006 1
	return NULL;
d1009 1
a1009 1
	return NULL;
d1037 1
a1037 1
	return -errno;
d1050 1
a1050 1
	return -errno;
d1062 1
a1062 1
	return -errno;
d1078 1
a1078 1
 * 
d1089 1
a1089 1
 * kernel, the frame buffer area will be set to write combining. 
d1097 2
a1098 2
 * The area mapped will be uncached. 
 * 
d1104 1
a1104 1
 * 
d1108 2
a1109 2
 * returned. 
 * 
d1117 1
a1117 1
	      drmMapFlags flags, drm_handle_t *handle)
d1127 1
a1127 1
	return -errno;
d1129 1
a1129 1
	*handle = (drm_handle_t)(uintptr_t)map.handle;
d1141 1
a1141 1
	return -errno;
d1147 1
a1147 1
 * 
d1152 1
a1152 1
 * \param agp_offset offset in the AGP aperture 
d1162 1
a1162 1
	       int agp_offset)
d1173 1
a1173 1
	return -errno;
d1185 1
a1185 1
	return -EINVAL;
d1188 1
a1188 1
	return -EINVAL;
d1191 1
a1191 1
	return -ENOMEM;
d1194 3
a1196 3
	int retval = -errno;
	drmFree(info.list);
	return retval;
d1200 7
a1206 7
	info.list[i].low_mark  = low  * info.list[i].count;
	info.list[i].high_mark = high * info.list[i].count;
	if (drmIoctl(fd, DRM_IOCTL_MARK_BUFS, &info.list[i])) {
	    int retval = -errno;
	    drmFree(info.list);
	    return retval;
	}
d1221 1
a1221 1
 * 
d1223 1
a1223 1
 * 
d1236 1
a1236 1
	return -errno;
d1276 1
a1276 1
 * 
d1285 1
a1285 1
	return -EINVAL;
d1288 1
a1288 1
	pagesize_mask = getpagesize() - 1;
d1294 1
a1294 1
	return -errno;
d1304 1
a1304 1
 * 
d1324 1
a1324 1
	return NULL;
d1327 2
a1328 2
	if (!(info.list = drmMalloc(info.count * sizeof(*info.list))))
	    return NULL;
d1330 16
a1345 16
	if (drmIoctl(fd, DRM_IOCTL_INFO_BUFS, &info)) {
	    drmFree(info.list);
	    return NULL;
	}

	retval = drmMalloc(sizeof(*retval));
	retval->count = info.count;
	retval->list  = drmMalloc(info.count * sizeof(*retval->list));
	for (i = 0; i < info.count; i++) {
	    retval->list[i].count     = info.list[i].count;
	    retval->list[i].size      = info.list[i].size;
	    retval->list[i].low_mark  = info.list[i].low_mark;
	    retval->list[i].high_mark = info.list[i].high_mark;
	}
	drmFree(info.list);
	return retval;
d1359 1
a1359 1
 * 
d1364 1
a1364 1
 */ 
d1373 1
a1373 1
	return NULL;
d1376 1
a1376 1
	return NULL;
d1378 17
a1394 2
	if (!(bufs.list = drmMalloc(bufs.count * sizeof(*bufs.list))))
	    return NULL;
d1396 2
a1397 18
	if (drmIoctl(fd, DRM_IOCTL_MAP_BUFS, &bufs)) {
	    drmFree(bufs.list);
	    return NULL;
	}

	retval = drmMalloc(sizeof(*retval));
	retval->count = bufs.count;
	retval->list  = drmMalloc(bufs.count * sizeof(*retval->list));
	for (i = 0; i < bufs.count; i++) {
	    retval->list[i].idx     = bufs.list[i].idx;
	    retval->list[i].total   = bufs.list[i].total;
	    retval->list[i].used    = 0;
	    retval->list[i].address = bufs.list[i].address;
	}

	drmFree(bufs.list);
	
	return retval;
d1415 1
a1415 1
	drm_munmap(bufs->list[i].address, bufs->list[i].total);
a1419 1
	
d1424 1
a1424 1
#define DRM_DMA_RETRY		16
d1430 2
a1431 2
 * \param request 
 * 
d1455 1
a1455 1
	ret = ioctl( fd, DRM_IOCTL_DMA, &dma );
d1459 2
a1460 2
	request->granted_count = dma.granted_count;
	return 0;
d1462 1
a1462 1
	return -errno;
d1474 1
a1474 1
 * 
d1476 1
a1476 1
 * 
d1496 1
a1496 1
	;
d1505 1
a1505 1
 * 
d1507 1
a1507 1
 * 
d1530 1
a1530 1
	return NULL;
d1533 1
a1533 1
	return NULL;
d1536 1
a1536 1
	return NULL;
d1538 2
a1539 2
	drmFree(list);
	return NULL;
d1544 1
a1544 1
	return NULL;
d1547 1
a1547 1
	retval[i] = list[i].handle;
d1568 1
a1568 1
 * 
d1570 1
a1570 1
 * 
d1572 1
a1572 1
 * 
d1583 1
a1583 1
	return -errno;
d1595 1
a1595 1
	return -errno;
d1612 1
a1612 1
	ctx.flags |= _DRM_CONTEXT_PRESERVED;
d1614 1
a1614 1
	ctx.flags |= _DRM_CONTEXT_2DONLY;
d1616 1
a1616 1
	return -errno;
d1628 1
a1628 1
	return -errno;
d1631 1
a1631 1
	*flags |= DRM_CONTEXT_PRESERVED;
d1633 1
a1633 1
	*flags |= DRM_CONTEXT_2DONLY;
d1642 1
a1642 1
 * 
d1645 1
a1645 1
 * 
d1647 1
a1647 1
 * 
d1649 1
a1649 1
 * 
d1661 1
a1661 1
	return -errno;
d1671 1
a1671 1
	return -errno;
d1683 1
a1683 1
	return -errno;
d1688 2
a1689 2
			   drm_drawable_info_type_t type, unsigned int num,
			   void *data)
d1700 1
a1700 1
	return -errno;
d1711 1
a1711 1
 * 
d1713 1
a1713 1
 * 
d1720 1
a1720 1
	return -errno;
d1729 1
a1729 1
 * 
d1731 1
a1731 1
 * 
d1738 1
a1738 1
	return -errno;
d1748 1
a1748 1
 * 
d1750 1
a1750 1
 * 
d1762 1
a1762 1
	return -errno;
d1776 1
a1776 1
 * 
d1778 1
a1778 1
 * 
d1784 1
a1784 1
		unsigned long *address, drm_handle_t *handle)
d1793 1
a1793 1
	return -errno;
d1795 1
a1795 1
	*address = b.physical;
d1806 1
a1806 1
 * 
d1808 1
a1808 1
 * 
d1820 1
a1820 1
	return -errno;
d1831 1
a1831 1
 * 
d1833 1
a1833 1
 * 
d1846 1
a1846 1
	return -errno;
d1856 1
a1856 1
 * 
d1858 1
a1858 1
 * 
d1870 1
a1870 1
	return -errno;
d1879 1
a1879 1
 * 
d1881 1
a1881 1
 * 
d1893 1
a1893 1
	return -errno;
d1902 1
a1902 1
 * 
d1904 1
a1904 1
 * 
d1916 1
a1916 1
	return -errno;
d1925 1
a1925 1
 * 
d1927 1
a1927 1
 * 
d1939 1
a1939 1
	return 0;
d1948 1
a1948 1
 * 
d1950 1
a1950 1
 * 
d1962 1
a1962 1
	return 0;
d1971 1
a1971 1
 * 
d1973 1
a1973 1
 * 
d1985 1
a1985 1
	return 0;
d1994 1
a1994 1
 * 
d1996 1
a1996 1
 * 
d2008 1
a2008 1
	return 0;
d2017 1
a2017 1
 * 
d2019 1
a2019 1
 * 
d2031 1
a2031 1
	return 0;
d2040 1
a2040 1
 * 
d2042 1
a2042 1
 * 
d2054 1
a2054 1
	return 0;
d2063 1
a2063 1
 * 
d2065 1
a2065 1
 * 
d2077 1
a2077 1
	return 0;
d2090 1
a2090 1
	return -errno;
d2102 1
a2102 1
	return -errno;
d2111 1
a2111 1
 * 
d2113 1
a2113 1
 * 
d2124 2
a2125 2
	fprintf(stderr, "clock_gettime failed: %s\n", strerror(errno));
	goto out;
d2133 9
a2141 9
	       clock_gettime(CLOCK_MONOTONIC, &cur);
	       /* Timeout after 1s */
	       if (cur.tv_sec > timeout.tv_sec + 1 ||
		   (cur.tv_sec == timeout.tv_sec && cur.tv_nsec >=
		    timeout.tv_nsec)) {
		       errno = EBUSY;
		       ret = -1;
		       break;
	       }
d2153 2
a2154 2
	fprintf(stderr, "%s: no device\n", label);
	break;
d2156 2
a2157 2
	fprintf(stderr, "%s: no access\n", label);
	break;
d2159 2
a2160 2
	fprintf(stderr, "%s: not root\n", label);
	break;
d2162 2
a2163 2
	fprintf(stderr, "%s: invalid args\n", label);
	break;
d2165 4
a2168 4
	if (err < 0)
	    err = -err;
	fprintf( stderr, "%s: error %d (%s)\n", label, err, strerror(err) );
	break;
d2179 1
a2179 1
 * 
d2181 1
a2181 1
 * 
d2194 1
a2194 1
	return -errno;
d2203 1
a2203 1
 * 
d2205 1
a2205 1
 * 
d2218 1
a2218 1
	return -errno;
d2235 1
a2235 1
	return -errno;
d2246 1
a2246 1
 * 
d2248 1
a2248 1
 * 
d2262 1
a2262 1
	return -errno;
d2271 2
a2272 2
	drmHashDelete(entry->tagTable, context);
	drmHashInsert(entry->tagTable, context, tag);
d2290 1
a2290 1
	return NULL;
d2305 1
a2305 1
	return -errno;
d2318 1
a2318 1
	return -errno;
d2320 1
a2320 1
	*handle = (drm_handle_t)(uintptr_t)map.handle;
d2326 2
a2327 2
	      drmMapType *type, drmMapFlags *flags, drm_handle_t *handle,
	      int *mtrr)
d2334 1
a2334 1
	return -errno;
d2345 1
a2345 1
		 unsigned long *magic, unsigned long *iocs)
d2352 1
a2352 1
	return -errno;
d2368 1
a2368 1
	return -errno;
d2373 1
a2373 1
	return -1;
d2400 81
a2480 81
	stats->data[i].value = s.data[i].value;
	switch (s.data[i].type) {
	case _DRM_STAT_LOCK:
	    stats->data[i].long_name = "Lock";
	    stats->data[i].rate_name = "Lock";
	    SET_VALUE;
	    break;
	case _DRM_STAT_OPENS:
	    stats->data[i].long_name = "Opens";
	    stats->data[i].rate_name = "O";
	    SET_COUNT;
	    stats->data[i].verbose   = 1;
	    break;
	case _DRM_STAT_CLOSES:
	    stats->data[i].long_name = "Closes";
	    stats->data[i].rate_name = "Lock";
	    SET_COUNT;
	    stats->data[i].verbose   = 1;
	    break;
	case _DRM_STAT_IOCTLS:
	    stats->data[i].long_name = "Ioctls";
	    stats->data[i].rate_name = "Ioc/s";
	    SET_COUNT;
	    break;
	case _DRM_STAT_LOCKS:
	    stats->data[i].long_name = "Locks";
	    stats->data[i].rate_name = "Lck/s";
	    SET_COUNT;
	    break;
	case _DRM_STAT_UNLOCKS:
	    stats->data[i].long_name = "Unlocks";
	    stats->data[i].rate_name = "Unl/s";
	    SET_COUNT;
	    break;
	case _DRM_STAT_IRQ:
	    stats->data[i].long_name = "IRQs";
	    stats->data[i].rate_name = "IRQ/s";
	    SET_COUNT;
	    break;
	case _DRM_STAT_PRIMARY:
	    stats->data[i].long_name = "Primary Bytes";
	    stats->data[i].rate_name = "PB/s";
	    SET_BYTE;
	    break;
	case _DRM_STAT_SECONDARY:
	    stats->data[i].long_name = "Secondary Bytes";
	    stats->data[i].rate_name = "SB/s";
	    SET_BYTE;
	    break;
	case _DRM_STAT_DMA:
	    stats->data[i].long_name = "DMA";
	    stats->data[i].rate_name = "DMA/s";
	    SET_COUNT;
	    break;
	case _DRM_STAT_SPECIAL:
	    stats->data[i].long_name = "Special DMA";
	    stats->data[i].rate_name = "dma/s";
	    SET_COUNT;
	    break;
	case _DRM_STAT_MISSED:
	    stats->data[i].long_name = "Miss";
	    stats->data[i].rate_name = "Ms/s";
	    SET_COUNT;
	    break;
	case _DRM_STAT_VALUE:
	    stats->data[i].long_name = "Value";
	    stats->data[i].rate_name = "Value";
	    SET_VALUE;
	    break;
	case _DRM_STAT_BYTE:
	    stats->data[i].long_name = "Bytes";
	    stats->data[i].rate_name = "B/s";
	    SET_BYTE;
	    break;
	case _DRM_STAT_COUNT:
	default:
	    stats->data[i].long_name = "Count";
	    stats->data[i].rate_name = "Cnt/s";
	    SET_COUNT;
	    break;
	}
d2489 1
a2489 1
 * \param drmCommandIndex command index 
d2492 1
a2492 1
 * 
d2494 1
a2494 1
 * 
d2496 1
a2496 1
 * It issues a read-write ioctl given by 
d2511 1
a2511 1
	retcode = -errno;
d2526 2
a2527 2
 * \param drmCommandIndex command index 
 * 
d2529 1
a2529 1
 * 
d2531 1
a2531 1
 * It issues a ioctl given by 
d2541 1
a2541 1
	return -errno;
d2551 1
a2551 1
 * \param drmCommandIndex command index 
d2554 1
a2554 1
 * 
d2558 1
a2558 1
 * It issues a read ioctl given by 
d2566 2
a2567 2
    request = DRM_IOC( DRM_IOC_READ, DRM_IOCTL_BASE, 
	DRM_COMMAND_BASE + drmCommandIndex, size);
d2570 1
a2570 1
	return -errno;
d2580 1
a2580 1
 * \param drmCommandIndex command index 
d2583 1
a2583 1
 * 
d2585 1
a2585 1
 * 
d2587 1
a2587 1
 * It issues a write ioctl given by 
d2595 2
a2596 2
    request = DRM_IOC( DRM_IOC_WRITE, DRM_IOCTL_BASE, 
	DRM_COMMAND_BASE + drmCommandIndex, size);
d2599 1
a2599 1
	return -errno;
d2609 1
a2609 1
 * \param drmCommandIndex command index 
d2612 1
a2612 1
 * 
d2614 1
a2614 1
 * 
d2616 1
a2616 1
 * It issues a read-write ioctl given by 
d2624 2
a2625 2
    request = DRM_IOC( DRM_IOC_READ|DRM_IOC_WRITE, DRM_IOCTL_BASE, 
	DRM_COMMAND_BASE + drmCommandIndex, size);
d2628 1
a2628 1
	return -errno;
d2642 3
a2644 3
int drmOpenOnce(void *unused, 
		const char *BusID,
		int *newlyopened)
d2653 1
a2653 1
   
d2655 6
a2660 6
	if ((strcmp(BusID, connection[i].BusID) == 0) &&
	    (connection[i].type == type)) {
	    connection[i].refcount++;
	    *newlyopened = 0;
	    return connection[i].fd;
	}
d2664 2
a2665 2
	return fd;
   
d2673 3
a2675 3
	fprintf(stderr, "saved connection %d for %s %d\n", 
		nr_fds, connection[nr_fds].BusID, 
		strcmp(BusID, connection[nr_fds].BusID));
d2687 11
a2697 11
	if (fd == connection[i].fd) {
	    if (--connection[i].refcount == 0) {
		drmClose(connection[i].fd);
		free(connection[i].BusID);
	    
		if (i < --nr_fds) 
		    connection[i] = connection[nr_fds];

		return;
	    }
	}
d2704 1
a2704 1
	return drmIoctl(fd, DRM_IOCTL_SET_MASTER, NULL);
d2712 1
a2712 1
	return drmIoctl(fd, DRM_IOCTL_DROP_MASTER, NULL);
d2719 4
a2722 20
	char name[128];
	struct stat sbuf;
	dev_t d;
	int i;

	/* The whole drmOpen thing is a fiasco and we need to find a way
	 * back to just using open(2).  For now, however, lets just make
	 * things worse with even more ad hoc directory walking code to
	 * discover the device file name. */

	fstat(fd, &sbuf);
	d = sbuf.st_rdev;

	for (i = 0; i < DRM_MAX_MINOR; i++) {
		snprintf(name, sizeof name, DRM_DEV_NAME, DRM_DIR_NAME, i);
		if (stat(name, &sbuf) == 0 && sbuf.st_rdev == d)
			break;
	}
	if (i == DRM_MAX_MINOR)
		return NULL;
d2724 17
a2740 1
	return strdup(name);
d2745 5
a2749 2
	struct stat sbuf;
	int maj, min, type;
d2751 2
a2752 2
	if (fstat(fd, &sbuf))
		return -1;
d2754 4
a2757 2
	maj = major(sbuf.st_rdev);
	min = minor(sbuf.st_rdev);
d2759 4
a2762 9
	if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode)) {
		errno = EINVAL;
		return -1;
	}

	type = drmGetMinorType(min);
	if (type == -1)
		errno = ENODEV;
	return type;
d2767 2
a2768 2
	struct drm_prime_handle args;
	int ret;
d2770 7
a2776 7
	memclear(args);
	args.fd = -1;
	args.handle = handle;
	args.flags = flags;
	ret = drmIoctl(fd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &args);
	if (ret)
		return ret;
d2778 2
a2779 2
	*prime_fd = args.fd;
	return 0;
d2784 2
a2785 2
	struct drm_prime_handle args;
	int ret;
d2787 5
a2791 5
	memclear(args);
	args.fd = prime_fd;
	ret = drmIoctl(fd, DRM_IOCTL_PRIME_FD_TO_HANDLE, &args);
	if (ret)
		return ret;
d2793 2
a2794 2
	*handle = args.handle;
	return 0;
d2800 8
a2807 8
	DIR *sysdir;
	struct dirent *pent, *ent;
	struct stat sbuf;
	const char *name = drmGetMinorName(type);
	int len;
	char dev_name[64], buf[64];
	long name_max;
	int maj, min;
d2809 2
a2810 2
	if (!name)
		return NULL;
d2812 1
a2812 1
	len = strlen(name);
d2814 2
a2815 2
	if (fstat(fd, &sbuf))
		return NULL;
d2817 2
a2818 2
	maj = major(sbuf.st_rdev);
	min = minor(sbuf.st_rdev);
d2820 2
a2821 2
	if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
		return NULL;
d2823 1
a2823 1
	snprintf(buf, sizeof(buf), "/sys/dev/char/%d:%d/device/drm", maj, min);
d2825 3
a2827 3
	sysdir = opendir(buf);
	if (!sysdir)
		return NULL;
d2829 12
a2840 3
	name_max = fpathconf(dirfd(sysdir), _PC_NAME_MAX);
	if (name_max == -1)
		goto out_close_dir;
d2842 2
a2843 3
	pent = malloc(offsetof(struct dirent, d_name) + name_max + 1);
	if (pent == NULL)
		 goto out_close_dir;
d2845 3
a2847 7
	while (readdir_r(sysdir, pent, &ent) == 0 && ent != NULL) {
		if (strncmp(ent->d_name, name, len) == 0) {
			snprintf(dev_name, sizeof(dev_name), DRM_DIR_NAME "/%s",
				 ent->d_name);

			free(pent);
			closedir(sysdir);
d2849 1
a2849 5
			return strdup(dev_name);
		}
	}

	free(pent);
d2852 1
a2852 1
	closedir(sysdir);
d2856 1
a2856 1
	return NULL;
d2861 1
a2861 1
	return drmGetMinorNameForFD(fd, DRM_NODE_PRIMARY);
d2866 1
a2866 1
	return drmGetMinorNameForFD(fd, DRM_NODE_RENDER);
d2979 1
a2979 1
           3 /* lenght of the node number */;
d3029 3
a3031 2
    for (i = 0; i < count && devices[i] != NULL; i++)
        drmFreeDevice(&devices[i]);
d3038 1
a3038 1
    const int max_node_str = drmGetMaxNodeName();
d3043 3
a3045 3
		     (DRM_NODE_MAX * (sizeof(void *) + max_node_str)) +
		     sizeof(drmPciBusInfo) +
		     sizeof(drmPciDeviceInfo));
d3050 1
a3050 1
  
d3087 5
d3130 1
d3138 1
d3199 7
a3205 1
        local_devices[i] = d;
a3209 1
    /* Fold nodes into a single device if they share the same bus info */
d3213 1
a3213 2
    for (i = 1; i < node_count && local_devices[i]; i++)
            drmFreeDevice(&local_devices[i]);
a3311 1
    /* Fold nodes into a single device if they share the same bus info */
d3315 4
a3318 1
    for (i = 0; i < node_count && local_devices[i]; i++) {
@


1.17
log
@Merge libdrm 2.4.65
@
text
@d39 1
d48 1
d70 2
a105 8
/*
 * This definition needs to be changed on some systems if dev_t is a structure.
 * If there is a header file we can get it from, there would be best.
 */
#ifndef makedev
#define makedev(x,y)    ((dev_t)(((x) << 8) | (y)))
#endif

d2852 2
d2868 2
d2871 1
a2871 2
static int drmParseSubsystemType(const char *str)
{
d2875 5
a2879 2
    if (readlink(str, link, PATH_MAX) < 0)
        return -EINVAL;
d2885 1
a2885 3
    name++;

    if (strncmp(name, "pci", 3) == 0)
d2889 4
d2895 1
a2895 1
static int drmParsePciBusInfo(const char *str, drmPciBusInfoPtr info)
d2897 4
d2902 1
a2902 1
    char *value;
d2904 13
d2920 1
a2920 7
    value = strstr(str, "PCI_SLOT_NAME=");
    if (value == NULL)
        return -EINVAL;

    value += strlen("PCI_SLOT_NAME=");

    if (sscanf(value, "%04x:%02x:%02x.%1u",
d2923 1
d2931 4
d2937 1
a2937 1
static int drmSameDevice(drmDevicePtr a, drmDevicePtr b)
d2939 3
d2943 1
a2943 1
        return 0;
d2947 1
a2947 2
        if (memcmp(a->businfo.pci, b->businfo.pci, sizeof(drmPciBusInfo)) == 0)
            return 1;
d2952 1
a2952 1
    return 0;
d2972 10
a2981 1
static int drmParsePciDeviceInfo(const unsigned char *config,
d2984 14
a2997 2
    if (config == NULL)
        return -EINVAL;
d3006 4
d3012 1
a3012 1
static void drmFreeDevice(drmDevicePtr device)
a3013 2
    int i;

d3017 2
a3018 7
    if (device->nodes != NULL)
        for (i = 0; i < DRM_NODE_MAX; i++)
            free(device->nodes[i]);

    free(device->nodes);
    free(device->businfo.pci);
    free(device->deviceinfo.pci);
d3028 61
d3090 56
a3145 3
        drmFreeDevice(devices[i]);
        free(devices[i]);
        devices[i] = NULL;
d3147 66
d3229 6
a3234 10
    drmDevicePtr devs = NULL;
    drmPciBusInfoPtr pcibus = NULL;
    drmPciDeviceInfoPtr pcidevice = NULL;
    DIR *sysdir = NULL;
    struct dirent *dent = NULL;
    struct stat sbuf = {0};
    char node[PATH_MAX + 1] = "";
    char path[PATH_MAX + 1] = "";
    char data[128] = "";
    unsigned char config[64] = "";
d3237 1
a3237 2
    int fd;
    int ret, i = 0, j, node_count, device_count = 0;
a3238 1
    int *duplicated = NULL;
d3240 2
a3241 2
    devs = calloc(max_count, sizeof(*devs));
    if (devs == NULL)
d3250 1
d3266 1
a3266 3
        snprintf(path, PATH_MAX, "/sys/dev/char/%d:%d/device/subsystem",
                 maj, min);
        subsystem_type = drmParseSubsystemType(path);
d3273 2
a3274 22
            pcibus = calloc(1, sizeof(*pcibus));
            if (pcibus == NULL) {
                ret = -ENOMEM;
                goto free_locals;
            }

            snprintf(path, PATH_MAX, "/sys/dev/char/%d:%d/device/uevent",
                     maj, min);
            fd = open(path, O_RDONLY);
            if (fd < 0) {
                ret = -errno;
                goto free_locals;
            }
            ret = read(fd, data, sizeof(data));
            if (ret < 0) {
                ret = -errno;
                close(fd);
                goto free_locals;
            }

            ret = drmParsePciBusInfo(data, pcibus);
            close(fd);
d3276 1
a3276 45
                goto free_locals;

            if (i >= max_count) {
                max_count += 16;
                devs = realloc(devs, max_count * sizeof(*devs));
            }

            devs[i].businfo.pci = pcibus;
            devs[i].bustype = subsystem_type;
            devs[i].nodes = calloc(DRM_NODE_MAX, sizeof(char *));
            if (devs[i].nodes == NULL) {
                ret = -ENOMEM;
                goto free_locals;
            }
            devs[i].nodes[node_type] = strdup(node);
            if (devs[i].nodes[node_type] == NULL) {
                ret = -ENOMEM;
                goto free_locals;
            }
            devs[i].available_nodes = 1 << node_type;

            if (devices != NULL) {
                snprintf(path, PATH_MAX, "/sys/class/drm/%s/device/config",
                         dent->d_name);
                fd = open(path, O_RDONLY);
                if (fd < 0) {
                     ret = -errno;
                     goto free_locals;
                }
                ret = read(fd, config, 64);
                if (ret < 0) {
                    ret = -errno;
                    close(fd);
                    goto free_locals;
                }

                pcidevice = calloc(1, sizeof(*pcidevice));
                if (pcidevice == NULL) {
                    ret = -ENOMEM;
                    goto free_locals;
                }

                ret = drmParsePciDeviceInfo(config, pcidevice);
                if (ret)
                    goto free_locals;
a3277 3
                devs[i].deviceinfo.pci = pcidevice;
                close(fd);
            }
d3281 11
a3291 1
            break;
d3293 2
a3296 1

d3299 2
a3300 6
    /* merge duplicated devices with same domain/bus/device/func IDs */
    duplicated = calloc(node_count, sizeof(*duplicated));
    if (duplicated == NULL) {
        ret = -ENOMEM;
        goto free_locals;
    }
d3302 6
a3307 15
    for (i = 0; i < node_count; i++) {
        for (j = i+1; j < node_count; j++) {
            if (duplicated[i] || duplicated[j])
                continue;
            if (drmSameDevice(&devs[i], &devs[j])) {
                duplicated[j] = 1;
                devs[i].available_nodes |= devs[j].available_nodes;
                node_type = log2(devs[j].available_nodes);
                devs[i].nodes[node_type] = devs[j].nodes[node_type];
                free(devs[j].nodes);
                free(devs[j].businfo.pci);
                free(devs[j].deviceinfo.pci);
            }
        }
    }
d3309 1
a3309 13
    for (i = 0; i < node_count; i++) {
        if(duplicated[i] == 0) {
            if ((devices != NULL) && (device_count < max_devices)) {
                devices[device_count] = calloc(1, sizeof(drmDevice));
                if (devices[device_count] == NULL) {
                    ret = -ENOMEM;
                    break;
                }
                memcpy(devices[device_count], &devs[i], sizeof(drmDevice));
            } else
                drmFreeDevice(&devs[i]);
            device_count++;
        }
d3312 3
a3314 7
    if (i < node_count) {
        drmFreeDevices(devices, device_count);
        for ( ; i < node_count; i++)
            if(duplicated[i] == 0)
                drmFreeDevice(&devs[i]);
    } else
        ret = device_count;
d3316 2
a3317 2
    free(duplicated);
    free(devs);
a3318 1
    return ret;
d3321 1
a3321 6
    for (j = 0; j < i; j++)
        drmFreeDevice(&devs[j]);
    free(pcidevice);
    free(pcibus);
    free(devs);
    closedir(sysdir);
a3323 17
#else
void drmFreeDevices(drmDevicePtr devices[], int count)
{
    (void)devices;
    (void)count;
}

int drmGetDevices(drmDevicePtr devices[], int max_devices)
{
    (void)devices;
    (void)max_devices;
    return -EINVAL;
}

#warning "Missing implementation of drmGetDevices/drmFreeDevices"

#endif
@


1.16
log
@Merge libdrm 2.4.64.  This changes the build to using the upstream
auto* build system and installing/using a libdrm specific set of drm
headers.  Thanks to Emil Velikov for removing the GNU makeisms
upstream.
@
text
@d58 1
d141 2
a142 1
    if (((env = getenv("LIBGL_DEBUG")) && strstr(env, "verbose")) || drm_server_info)
d359 1
a359 1
    if (drm_server_info) {
d383 1
a383 1
    if (drm_server_info) {
d433 1
a433 1
	if (drm_server_info) {
d766 2
a767 1
    if (!drmAvailable() && name != NULL && drm_server_info) {
d2842 3
a2847 2
			snprintf(dev_name, sizeof(dev_name), DRM_DIR_NAME "/%s",
				 ent->d_name);
d2869 350
@


1.15
log
@update to libdrm 2.4.62
@
text
@d67 10
d85 8
d97 4
d301 12
d565 1
a565 1
        return "drm";
d567 1
a567 1
        return "drmC";
d569 1
a569 1
        return "drmR";
d2663 1
a2663 1
    if (fd <= 0 || nr_fds == DRM_MAX_FDS)
a2741 12

#ifdef X_PRIVSEP
static int
_priv_open_device(const char *path)
{
	drmMsg("_priv_open_device\n");
	return open(path, O_RDWR, 0);
}

int priv_open_device(const char *)
	__attribute__((weak, alias ("_priv_open_device")));
#endif
@


1.14
log
@update to libdrm 2.4.60
@
text
@d65 1
a65 1
#include "libdrm.h"
a112 5
typedef int DRM_PRINTFLIKE(1, 0) (*debug_msg_func_t)(const char *format,
						     va_list ap);

static debug_msg_func_t drm_debug_print = drmDebugPrint;

d124 1
a124 1
	  drm_debug_print(format, ap);
a129 6
void
drmSetDebugMsgFunction(debug_msg_func_t debug_msg_ptr)
{
    drm_debug_print = debug_msg_ptr;
}

d139 1
a139 4
    void *pt;
    if ((pt = malloc(size)))
	memset(pt, 0, size);
    return pt;
d144 1
a144 2
    if (pt)
	free(pt);
d261 1
d277 1
d348 1
a348 1
	group = (serv_group >= 0) ? serv_group : DRM_DEV_GID;
d1725 1
a1725 1
    memclear(mode);
d2748 2
d2765 1
a2766 1
	args.flags = 0;
@


1.13
log
@update to libdrm 2.4.59
@
text
@d43 2
d55 3
d89 1
a89 2
#define DRM_NODE_CONTROL 0
#define DRM_NODE_RENDER 1
d305 1
a305 1
static int drmOpenDevice(long dev, int minor, int type)
d308 1
d312 2
d316 18
a333 3
    gid_t           group   = DRM_DEV_GID, serv_group;
    
    sprintf(buf, type ? DRM_DEV_NAME : DRM_CONTROL_DEV_NAME, DRM_DIR_NAME, minor);
a339 1
	group = (serv_group >= 0) ? serv_group : DRM_DEV_GID;
d361 1
d444 1
d449 15
a463 1
    sprintf(buf, type ? DRM_DEV_NAME : DRM_CONTROL_DEV_NAME, DRM_DIR_NAME, minor);
d491 1
a491 1
    if ((fd = drmOpenMinor(0, 1, DRM_NODE_RENDER)) < 0) {
d509 44
d558 1
d568 1
a568 1
static int drmOpenByBusid(const char *busid)
d574 4
d580 2
a581 2
    for (i = 0; i < DRM_MAX_MINOR; i++) {
	fd = drmOpenMinor(i, 1, DRM_NODE_RENDER);
d621 1
d632 1
a632 1
static int drmOpenByName(const char *name)
d638 4
d647 2
a648 2
    for (i = 0; i < DRM_MAX_MINOR; i++) {
	if ((fd = drmOpenMinor(i, 1, DRM_NODE_RENDER)) >= 0) {
d690 1
a690 1
			    return drmOpenByBusid(++pt);
d692 1
a692 1
			    return drmOpenDevice(strtol(devstring, NULL, 0),i, DRM_NODE_RENDER);
d722 21
d744 1
a744 1
	/* try to load the kernel */
d752 1
a752 1
	int fd = drmOpenByBusid(busid);
d758 1
a758 1
	return drmOpenByName(name);
d768 5
d857 1
a857 6
    version->name_len    = 0;
    version->name        = NULL;
    version->date_len    = 0;
    version->date        = NULL;
    version->desc_len    = 0;
    version->desc        = NULL;
d925 1
a925 1
	struct drm_get_cap cap = { capability, 0 };
d928 3
d941 5
a945 1
	struct drm_set_client_cap cap  = { capability, value };
d980 1
a980 2
    u.unique_len = 0;
    u.unique     = NULL;
d1009 1
d1023 2
d1036 1
d1098 1
a1100 1
    map.handle  = 0;
d1114 1
d1143 1
a1145 2
    request.low_mark  = 0;
    request.high_mark = 0;
d1159 1
a1159 2
    info.count = 0;
    info.list  = NULL;
d1209 1
d1298 1
a1298 2
    info.count = 0;
    info.list  = NULL;
d1348 1
a1348 3
    bufs.count = 0;
    bufs.list  = NULL;
    bufs.virtual = NULL;
d1464 1
d1495 1
a1496 1
    lock.flags   = 0;
d1507 1
a1507 2
    res.count    = 0;
    res.contexts = NULL;
d1560 1
a1560 1
    ctx.flags = 0;	/* Modified with functions below */
d1571 1
d1588 1
a1589 1
    ctx.flags  = 0;
d1604 1
d1636 2
d1647 2
d1658 2
d1672 1
d1738 1
d1767 1
a1769 1
    b.handle = 0;
d1796 1
a1796 1
    b.size   = 0;
d1821 1
d1846 1
a1847 1
    b.offset = 0;
d1869 2
d1892 2
d1915 2
d1938 2
d1961 2
d1984 2
d2007 2
d2030 2
d2053 2
d2064 2
a2067 1
    sg.handle = 0;
d2078 1
a2078 1
    sg.size   = 0;
d2169 1
d2193 1
d2205 1
a2206 1
    lock.flags   = 0;
d2236 1
d2279 1
d2293 1
d2310 1
d2328 1
d2343 1
a2343 1
    int         i;
d2345 1
d2483 1
a2514 1
    void *data = NULL; /* dummy */
d2519 1
a2519 1
    if (drmIoctl(fd, request, data)) {
d2616 1
d2625 5
d2634 2
a2635 1
	if (strcmp(BusID, connection[i].BusID) == 0) {
d2641 1
a2641 1
    fd = drmOpen(unused, BusID);
d2648 1
d2683 1
a2683 1
	return ioctl(fd, DRM_IOCTL_SET_MASTER, 0);
d2691 1
a2691 1
	return ioctl(fd, DRM_IOCTL_DROP_MASTER, 0);
d2734 22
d2786 68
@


1.12
log
@update to libdrm 2.4.56
@
text
@a50 1
#include <sys/mman.h>
d60 1
d1147 1
a1147 1
    *address = mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, handle);
d1167 1
a1167 1
    return munmap(address, size);
d1274 1
a1274 1
	munmap(bufs->list[i].address, bufs->list[i].total);
@


1.11
log
@update to libdrm 2.4.54
ok matthieu@@
@
text
@a550 13
    
    if (!drmAvailable()) {
	if (!drm_server_info) {
	    return -1;
	}
	else {
	    /* try to load the kernel module now */
	    if (!drm_server_info->load_module(name)) {
		drmMsg("[drm] failed to load kernel module \"%s\"\n", name);
		return -1;
	    }
	}
    }
@


1.10
log
@update to libdrm 2.4.47
ok mpi@@, jsg@@
@
text
@d103 2
a104 1
static int drmDebugPrint(const char *format, va_list ap)
d109 4
a112 1
static int (*drm_debug_print)(const char *format, va_list ap) = drmDebugPrint;
d132 1
a132 1
drmSetDebugMsgFunction(int (*debug_msg_ptr)(const char *format, va_list ap))
d513 1
a513 1
		drmMsg("drmOpenByBusid: Interface 1.4 failed, trying 1.1\n",fd);
@


1.9
log
@update to libdrm 2.4.45
ok kettenis@@ mpi@@, tested by ajacoutot@@
@
text
@d833 7
@


1.8
log
@update to libdrm 2.4.42

tested by matthieu@@ krw@@ mpi@@ shadchin@@ and ajacoutot@@
ok mpi@@
@
text
@d1956 1
a1956 1
	fprintf(stderr, "clock_gettime failed: %s\n", strerror(ret));
@


1.7
log
@Enable more libdrm functions.  Determine if modesetting is supported
based on a modesetting ioctl that checks the DRIVER_MODESET flag on
the kernel side instead of the sysfs approach linux takes.

ok mpi@@
@
text
@d2570 31
@


1.6
log
@Update to libdrm 2.4.31 and add the non-yet-linked libkms, prodded by jsg@@

Tested by jsg@@, ajacoutot@@, shadchin@@ and matthieu@@, ok matthieu@@
@
text
@a821 1
#ifndef __OpenBSD__
a829 1
#endif
@


1.5
log
@Do not remove(3) the device entry if open fails. ok oga@@
@
text
@d34 3
d41 1
d62 10
a71 2
#ifndef DRM_MAX_MINOR
#define DRM_MAX_MINOR 16
a153 17
/* drmStrdup can't use strdup(3), since it doesn't call _DRM_MALLOC... */
static char *drmStrdup(const char *s)
{
    char *retval;

    if (!s)
        return NULL;

    retval = malloc(strlen(s)+1);
    if (!retval)
        return NULL;

    strcpy(retval, s);

    return retval;
}

d211 1
a211 1
static int drmMatchBusID(const char *id1, const char *id2)
d239 7
d255 30
d317 48
d375 20
d396 2
a397 1
    
d484 1
a484 1
    int        i;
d494 3
d498 1
a498 1
	    sv.drm_di_minor = 1;
d501 11
a511 1
	    drmSetInterfaceVersion(fd, &sv);
d514 1
a514 1
	    if (buf && drmMatchBusID(buf, busid)) {
d721 1
a721 1
    d->name               = drmStrdup(s->name);
d723 1
a723 1
    d->date               = drmStrdup(s->date);
d725 1
a725 1
    d->desc               = drmStrdup(s->desc);
d820 14
d988 1
a988 1
	*handle = (drm_handle_t)map.handle;
d996 1
a996 1
    map.handle = (void *)handle;
d2132 1
a2132 1
    map.handle = (void *)handle;
d2149 1
a2149 1
	*handle = (drm_handle_t)map.handle;
d2521 2
a2522 6
#ifdef NOTYET
	int ret;

	fprintf(stderr,"Setting master \n");
	ret = ioctl(fd, DRM_IOCTL_SET_MASTER, 0);
	return ret;
d2529 2
a2530 5
#ifdef NOTYET
	int ret;
	fprintf(stderr,"Dropping master \n");
	ret = ioctl(fd, DRM_IOCTL_DROP_MASTER, 0);
	return ret;
d2558 1
a2558 1
	return drmStrdup(name);
@


1.4
log
@update libdrm to 2.4.15.

This diff seems larger than it is since upstream reindented some
sources.  This updates libdrm_intel to -current (which only affect the
GEM code) and libdrm to 2.4.15.  bumping both minor versions.

Discussed with matthieu@@
@
text
@d296 1
a296 1
    remove(buf);
@


1.3
log
@typo in the !privsep path, from David Coppa (dcoppa at mail dot com);
thanks.

ok matthieu@@
@
text
@d224 2
a225 2
	int o1, b1, d1, f1;
	int o2, b2, d2, f2;
d228 1
a228 1
	ret = sscanf(id1, "pci:%04x:%02x:%02x.%d", &o1, &b1, &d1, &f1);
d231 1
a231 1
	    ret = sscanf(id1, "PCI:%d:%d:%d", &b1, &d1, &f1);
d236 1
a236 1
	ret = sscanf(id2, "pci:%04x:%02x:%02x.%d", &o2, &b2, &d2, &f2);
d239 1
a239 1
	    ret = sscanf(id2, "PCI:%d:%d:%d", &b2, &d2, &f2);
a2390 1
#ifdef NOTYET
d2393 1
d2399 2
d2405 1
d2410 28
a2438 1
#endif
@


1.2
log
@Update libdrm to 2.4.3

This is needed for us to be able to update Mesa and xf86-video-intel.
Includes a few fixes, as well as the intel bufmgr interface and the
modesetting interface (which currently errors when you check if it's
enabled).

ok matthieu@@
@
text
@d286 1
a286 1
    fb = open(buf, O_RDWR, 0);
@


1.1
log
@De-autoconf libdrm.

Now that xenocara has been made clean with respect to using kernel headers
instead of those provided with libdrm, remove the copy of the headers included
here. Since it is now very simple, move it over to using standard bsd makefiles
instead of autoconf.

ok matthieu@@
@
text
@d42 1
a57 12
#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
#define DRM_MAJOR 145
#endif

#ifdef __NetBSD__
#define DRM_MAJOR 34
#endif

#ifndef DRM_MAJOR
#define DRM_MAJOR 226		/* Linux */
#endif

d72 3
d98 1
a98 1
static void
d159 13
d265 1
a265 1
static int drmOpenDevice(long dev, int minor)
d275 1
a275 1
    sprintf(buf, DRM_DEV_NAME, DRM_DIR_NAME, minor);
d278 7
d286 1
a286 1
    fd = open(buf, O_RDWR, 0);
d288 1
a288 1
	fd = priv_open_device(buf);
d313 1
a313 1
static int drmOpenMinor(int minor, int create)
d319 1
a319 1
	return drmOpenDevice(makedev(DRM_MAJOR, minor), minor);
d321 1
a321 1
    sprintf(buf, DRM_DEV_NAME, DRM_DIR_NAME, minor);
d328 1
a328 1
    	return fd;
d349 1
a349 1
    if ((fd = drmOpenMinor(0, 1)) < 0) {
d390 1
a390 1
	fd = drmOpenMinor(i, 1);
d452 1
a452 1
	if ((fd = drmOpenMinor(i, 1)) >= 0) {
d496 1
a496 1
			    return drmOpenDevice(strtol(devstring, NULL, 0),i);
d546 4
d642 1
a642 1
    if (ioctl(fd, DRM_IOCTL_VERSION, version)) {
d654 1
a654 1
    if (ioctl(fd, DRM_IOCTL_VERSION, version)) {
d740 1
a740 1
    if (ioctl(fd, DRM_IOCTL_GET_UNIQUE, &u))
d743 1
a743 1
    if (ioctl(fd, DRM_IOCTL_GET_UNIQUE, &u))
d770 1
a770 1
    if (ioctl(fd, DRM_IOCTL_SET_UNIQUE, &u)) {
d781 1
a781 1
    if (ioctl(fd, DRM_IOCTL_GET_MAGIC, &auth))
d792 1
a792 1
    if (ioctl(fd, DRM_IOCTL_AUTH_MAGIC, &auth))
d857 1
a857 1
    if (ioctl(fd, DRM_IOCTL_ADD_MAP, &map))
d870 1
a870 1
    if(ioctl(fd, DRM_IOCTL_RM_MAP, &map))
d903 1
a903 1
    if (ioctl(fd, DRM_IOCTL_ADD_BUFS, &request))
d916 1
a916 1
    if (ioctl(fd, DRM_IOCTL_INFO_BUFS, &info))
d925 1
a925 1
    if (ioctl(fd, DRM_IOCTL_INFO_BUFS, &info)) {
d934 1
a934 1
	if (ioctl(fd, DRM_IOCTL_MARK_BUFS, &info.list[i])) {
d966 1
a966 1
    if (ioctl(fd, DRM_IOCTL_FREE_BUFS, &request))
d1055 1
a1055 1
    if (ioctl(fd, DRM_IOCTL_INFO_BUFS, &info))
d1062 1
a1062 1
	if (ioctl(fd, DRM_IOCTL_INFO_BUFS, &info)) {
d1106 1
a1106 1
    if (ioctl(fd, DRM_IOCTL_MAP_BUFS, &bufs))
d1115 1
a1115 1
	if (ioctl(fd, DRM_IOCTL_MAP_BUFS, &bufs)) {
d1230 1
a1230 1
    while (ioctl(fd, DRM_IOCTL_LOCK, &lock))
d1253 1
a1253 1
    return ioctl(fd, DRM_IOCTL_UNLOCK, &lock);
d1265 1
a1265 1
    if (ioctl(fd, DRM_IOCTL_RES_CTX, &res))
d1279 1
a1279 1
    if (ioctl(fd, DRM_IOCTL_RES_CTX, &res))
d1318 1
a1318 1
    if (ioctl(fd, DRM_IOCTL_ADD_CTX, &ctx))
d1329 1
a1329 1
    if (ioctl(fd, DRM_IOCTL_SWITCH_CTX, &ctx))
d1350 1
a1350 1
    if (ioctl(fd, DRM_IOCTL_MOD_CTX, &ctx))
d1361 1
a1361 1
    if (ioctl(fd, DRM_IOCTL_GET_CTX, &ctx))
d1392 1
a1392 1
    if (ioctl(fd, DRM_IOCTL_RM_CTX, &ctx))
d1400 1
a1400 1
    if (ioctl(fd, DRM_IOCTL_ADD_DRAW, &draw))
d1410 1
a1410 1
    if (ioctl(fd, DRM_IOCTL_RM_DRAW, &draw))
d1426 1
a1426 1
    if (ioctl(fd, DRM_IOCTL_UPDATE_DRAW, &update))
d1446 1
a1446 1
    if (ioctl(fd, DRM_IOCTL_AGP_ACQUIRE, NULL))
d1464 1
a1464 1
    if (ioctl(fd, DRM_IOCTL_AGP_RELEASE, NULL))
d1487 1
a1487 1
    if (ioctl(fd, DRM_IOCTL_AGP_ENABLE, &m))
d1518 1
a1518 1
    if (ioctl(fd, DRM_IOCTL_AGP_ALLOC, &b))
d1545 1
a1545 1
    if (ioctl(fd, DRM_IOCTL_AGP_FREE, &b))
d1570 1
a1570 1
    if (ioctl(fd, DRM_IOCTL_AGP_BIND, &b))
d1594 1
a1594 1
    if (ioctl(fd, DRM_IOCTL_AGP_UNBIND, &b))
d1615 1
a1615 1
    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1636 1
a1636 1
    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1657 1
a1657 1
    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1678 1
a1678 1
    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1699 1
a1699 1
    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1720 1
a1720 1
    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1741 1
a1741 1
    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1762 1
a1762 1
    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1783 1
a1783 1
    if (ioctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1795 1
a1795 1
    if (ioctl(fd, DRM_IOCTL_SG_ALLOC, &sg))
d1807 1
a1807 1
    if (ioctl(fd, DRM_IOCTL_SG_FREE, &sg))
d1825 1
d1828 7
d1838 11
d1851 1
d1898 1
a1898 1
    if (ioctl(fd, DRM_IOCTL_CONTROL, &ctl))
d1921 1
a1921 1
    if (ioctl(fd, DRM_IOCTL_CONTROL, &ctl))
d1938 1
a1938 1
    if (ioctl(fd, DRM_IOCTL_FINISH, &lock))
d1964 1
a1964 1
    if (ioctl(fd, DRM_IOCTL_IRQ_BUSID, &p))
d2006 1
a2006 1
    if (ioctl(fd, DRM_IOCTL_SET_SAREA_CTX, &map))
d2018 1
a2018 1
    if (ioctl(fd, DRM_IOCTL_GET_SAREA_CTX, &map))
d2033 1
a2033 1
    if (ioctl(fd, DRM_IOCTL_GET_MAP, &map))
d2050 1
a2050 1
    if (ioctl(fd, DRM_IOCTL_GET_CLIENT, &client))
d2065 1
a2065 1
    if (ioctl(fd, DRM_IOCTL_GET_STATS, &s))
d2207 1
a2207 1
    if (ioctl(fd, DRM_IOCTL_SET_VERSION, &sv)) {
d2238 1
a2238 1
    if (ioctl(fd, request, data)) {
d2267 1
a2267 1
    if (ioctl(fd, request, data)) {
d2296 1
a2296 1
    if (ioctl(fd, request, data)) {
d2325 1
a2325 1
    if (ioctl(fd, request, data)) {
a2326 1
    }
d2391 19
d2418 1
a2418 1
int priv_open_device(const char *) 
@


1.1.1.1
log
@Import libdrm 2.4.64
@
text
@a33 3
#ifdef HAVE_CONFIG_H
# include <config.h>
#endif
a37 1
#include <strings.h>
a38 2
#include <dirent.h>
#include <stddef.h>
a41 1
#include <time.h>
d46 1
a48 3
#ifdef HAVE_SYS_MKDEV_H
# include <sys/mkdev.h> /* defines major(), minor(), and makedev() on Solaris */
#endif
a55 11
#include "libdrm_macros.h"

#ifdef __OpenBSD__
#define DRM_PRIMARY_MINOR_NAME	"drm"
#define DRM_CONTROL_MINOR_NAME	"drmC"
#define DRM_RENDER_MINOR_NAME	"drmR"
#else
#define DRM_PRIMARY_MINOR_NAME	"card"
#define DRM_CONTROL_MINOR_NAME	"controlD"
#define DRM_RENDER_MINOR_NAME	"renderD"
#endif
d65 2
a66 5
#ifdef __OpenBSD__
#ifdef __i386__
#define DRM_MAJOR 88
#else
#define DRM_MAJOR 87
a67 1
#endif /* __OpenBSD__ */
d69 2
a70 2
#ifndef DRM_MAJOR
#define DRM_MAJOR 226		/* Linux */
a82 2
#define memclear(s) memset(&s, 0, sizeof(s))

d99 1
a99 2
static int DRM_PRINTFLIKE(1, 0)
drmDebugPrint(const char *format, va_list ap)
d104 3
a106 1
void
d117 1
a117 1
	  drmDebugPrint(format, ap);
d123 6
d138 4
a141 1
    return calloc(1, size);
d146 2
a147 1
    free(pt);
d150 2
a151 5
/**
 * Call ioctl, restarting if it is interupted
 */
int
drmIoctl(int fd, unsigned long request, void *arg)
d153 4
a156 1
    int	ret;
d158 7
a164 4
    do {
	ret = ioctl(fd, request, arg);
    } while (ret == -1 && (errno == EINTR || errno == EAGAIN));
    return ret;
d167 1
d211 1
a211 1
static int drmMatchBusID(const char *id1, const char *id2, int pci_domain_ok)
d219 2
a220 2
	unsigned int o1, b1, d1, f1;
	unsigned int o2, b2, d2, f2;
d223 1
a223 1
	ret = sscanf(id1, "pci:%04x:%02x:%02x.%u", &o1, &b1, &d1, &f1);
d226 1
a226 1
	    ret = sscanf(id1, "PCI:%u:%u:%u", &b1, &d1, &f1);
d231 1
a231 1
	ret = sscanf(id2, "pci:%04x:%02x:%02x.%u", &o2, &b2, &d2, &f2);
d234 1
a234 1
	    ret = sscanf(id2, "PCI:%u:%u:%u", &b2, &d2, &f2);
a238 7
	/* If domains aren't properly supported by the kernel interface,
	 * just ignore them, which sucks less than picking a totally random
	 * card with "open by name"
	 */
	if (!pci_domain_ok)
		o1 = o2 = 0;

a247 32
 * Handles error checking for chown call.
 *
 * \param path to file.
 * \param id of the new owner.
 * \param id of the new group.
 *
 * \return zero if success or -1 if failure.
 *
 * \internal
 * Checks for failure. If failure was caused by signal call chown again.
 * If any other failure happened then it will output error mesage using
 * drmMsg() call.
 */
#if !defined(UDEV)
static int chown_check_return(const char *path, uid_t owner, gid_t group)
{
	int rv;

	do {
		rv = chown(path, owner, group);
	} while (rv != 0 && errno == EINTR);

	if (rv == 0)
		return 0;

	drmMsg("Failed to change owner or group for file %s! %d: %s\n",
			path, errno, strerror(errno));
	return -1;
}
#endif

/**
d260 1
a260 1
static int drmOpenDevice(dev_t dev, int minor, int type)
a262 1
    const char      *dev_name;
a265 2
    gid_t           serv_group;
#if !defined(UDEV)
d268 3
a270 18
    gid_t           group   = DRM_DEV_GID;
#endif

    switch (type) {
    case DRM_NODE_PRIMARY:
	    dev_name = DRM_DEV_NAME;
	    break;
    case DRM_NODE_CONTROL:
	    dev_name = DRM_CONTROL_DEV_NAME;
	    break;
    case DRM_NODE_RENDER:
	    dev_name = DRM_RENDER_DEV_NAME;
	    break;
    default:
	    return -EINVAL;
    };

    sprintf(buf, dev_name, DRM_DIR_NAME, minor);
d273 2
a274 28
    if (drm_server_info) {
	drm_server_info->get_perms(&serv_group, &serv_mode);
	devmode  = serv_mode ? serv_mode : DRM_DEV_MODE;
	devmode &= ~(S_IXUSR|S_IXGRP|S_IXOTH);
    }

#if !defined(UDEV)
    if (stat(DRM_DIR_NAME, &st)) {
	if (!isroot)
	    return DRM_ERR_NOT_ROOT;
	mkdir(DRM_DIR_NAME, DRM_DEV_DIRMODE);
	chown_check_return(DRM_DIR_NAME, 0, 0); /* root:root */
	chmod(DRM_DIR_NAME, DRM_DEV_DIRMODE);
    }

    /* Check if the device node exists and create it if necessary. */
    if (stat(buf, &st)) {
	if (!isroot)
	    return DRM_ERR_NOT_ROOT;
	remove(buf);
	mknod(buf, S_IFCHR | devmode, dev);
    }

    if (drm_server_info) {
	group = ((int)serv_group >= 0) ? serv_group : DRM_DEV_GID;
	chown_check_return(buf, user, group);
	chmod(buf, devmode);
    }
d276 1
a276 22
    /* if we modprobed then wait for udev */
    {
	int udev_count = 0;
wait_for_udev:
        if (stat(DRM_DIR_NAME, &st)) {
		usleep(20);
		udev_count++;

		if (udev_count == 50)
			return -1;
		goto wait_for_udev;
	}

    	if (stat(buf, &st)) {
		usleep(20);
		udev_count++;

		if (udev_count == 50)
			return -1;
		goto wait_for_udev;
    	}
    }
a277 22

    fd = open(buf, O_RDWR, 0);
    drmMsg("drmOpenDevice: open result is %d, (%s)\n",
		fd, fd < 0 ? strerror(errno) : "OK");
    if (fd >= 0)
	return fd;

#if !defined(UDEV)
    /* Check if the device node is not what we expect it to be, and recreate it
     * and try again if so.
     */
    if (st.st_rdev != dev) {
	if (!isroot)
	    return DRM_ERR_NOT_ROOT;
	remove(buf);
	mknod(buf, S_IFCHR | devmode, dev);
	if (drm_server_info) {
	    chown_check_return(buf, user, group);
	    chmod(buf, devmode);
	}
    }
    fd = open(buf, O_RDWR, 0);
a284 1
#endif
d301 1
a301 1
static int drmOpenMinor(int minor, int create, int type)
a304 1
    const char *dev_name;
d307 1
a307 1
	return drmOpenDevice(makedev(DRM_MAJOR, minor), minor, type);
d309 8
a316 17
    switch (type) {
    case DRM_NODE_PRIMARY:
	    dev_name = DRM_DEV_NAME;
	    break;
    case DRM_NODE_CONTROL:
	    dev_name = DRM_CONTROL_DEV_NAME;
	    break;
    case DRM_NODE_RENDER:
	    dev_name = DRM_RENDER_DEV_NAME;
	    break;
    default:
	    return -EINVAL;
    };

    sprintf(buf, dev_name, DRM_DIR_NAME, minor);
    if ((fd = open(buf, O_RDWR, 0)) >= 0)
	return fd;
d337 1
a337 1
    if ((fd = drmOpenMinor(0, 1, DRM_NODE_PRIMARY)) < 0) {
a354 44
static int drmGetMinorBase(int type)
{
    switch (type) {
    case DRM_NODE_PRIMARY:
        return 0;
    case DRM_NODE_CONTROL:
        return 64;
    case DRM_NODE_RENDER:
        return 128;
    default:
        return -1;
    };
}

static int drmGetMinorType(int minor)
{
    int type = minor >> 6;

    if (minor < 0)
        return -1;

    switch (type) {
    case DRM_NODE_PRIMARY:
    case DRM_NODE_CONTROL:
    case DRM_NODE_RENDER:
        return type;
    default:
        return -1;
    }
}

static const char *drmGetMinorName(int type)
{
    switch (type) {
    case DRM_NODE_PRIMARY:
        return DRM_PRIMARY_MINOR_NAME;
    case DRM_NODE_CONTROL:
        return DRM_CONTROL_MINOR_NAME;
    case DRM_NODE_RENDER:
        return DRM_RENDER_MINOR_NAME;
    default:
        return NULL;
    }
}
a359 1
 * \param type device node type.
d369 1
a369 1
static int drmOpenByBusid(const char *busid, int type)
d371 1
a371 1
    int        i, pci_domain_ok = 1;
a374 4
    int        base = drmGetMinorBase(type);

    if (base < 0)
        return -1;
d377 2
a378 2
    for (i = base; i < base + DRM_MAX_MINOR; i++) {
	fd = drmOpenMinor(i, 1, type);
a380 3
	    /* We need to try for 1.4 first for proper PCI domain support
	     * and if that fails, we know the kernel is busted
	     */
d382 1
a382 1
	    sv.drm_di_minor = 4;
d385 1
a385 11
	    if (drmSetInterfaceVersion(fd, &sv)) {
#ifndef __alpha__
		pci_domain_ok = 0;
#endif
		sv.drm_di_major = 1;
		sv.drm_di_minor = 1;
		sv.drm_dd_major = -1;       /* Don't care */
		sv.drm_dd_minor = -1;       /* Don't care */
		drmMsg("drmOpenByBusid: Interface 1.4 failed, trying 1.1\n");
		drmSetInterfaceVersion(fd, &sv);
	    }
d388 1
a388 1
	    if (buf && drmMatchBusID(buf, busid, pci_domain_ok)) {
a404 1
 * \param type the device node type.
d415 1
a415 1
static int drmOpenByName(const char *name, int type)
d421 13
a433 4
    int           base = drmGetMinorBase(type);

    if (base < 0)
        return -1;
d439 2
a440 2
    for (i = base; i < base + DRM_MAX_MINOR; i++) {
	if ((fd = drmOpenMinor(i, 1, type)) >= 0) {
d482 1
a482 1
			    return drmOpenByBusid(++pt, type);
d484 1
a484 1
			    return drmOpenDevice(strtol(devstring, NULL, 0),i, type);
a513 21
    return drmOpenWithType(name, busid, DRM_NODE_PRIMARY);
}

/**
 * Open the DRM device with specified type.
 *
 * Looks up the specified name and bus ID, and opens the device found.  The
 * entry in /dev/dri is created if necessary and if called by root.
 *
 * \param name driver name. Not referenced if bus ID is supplied.
 * \param busid bus ID. Zero if not known.
 * \param type the device node type to open, PRIMARY, CONTROL or RENDER
 *
 * \return a file descriptor on success, or a negative value on error.
 *
 * \internal
 * It calls drmOpenByBusid() if \p busid is specified or drmOpenByName()
 * otherwise.
 */
int drmOpenWithType(const char *name, const char *busid, int type)
{
d515 1
a515 1
	/* try to load the kernel module */
d523 1
a523 1
	int fd = drmOpenByBusid(busid, type);
d529 1
a529 1
	return drmOpenByName(name, type);
a533 9
int drmOpenControl(int minor)
{
    return drmOpenMinor(minor, 0, DRM_NODE_CONTROL);
}

int drmOpenRender(int minor)
{
    return drmOpenMinor(minor, 0, DRM_NODE_RENDER);
}
d591 1
a591 1
    d->name               = strdup(s->name);
d593 1
a593 1
    d->date               = strdup(s->date);
d595 1
a595 1
    d->desc               = strdup(s->desc);
d619 6
a624 1
    memclear(*version);
d626 1
a626 1
    if (drmIoctl(fd, DRM_IOCTL_VERSION, version)) {
d638 1
a638 1
    if (drmIoctl(fd, DRM_IOCTL_VERSION, version)) {
a689 26
int drmGetCap(int fd, uint64_t capability, uint64_t *value)
{
	struct drm_get_cap cap;
	int ret;

	memclear(cap);
	cap.capability = capability;

	ret = drmIoctl(fd, DRM_IOCTL_GET_CAP, &cap);
	if (ret)
		return ret;

	*value = cap.value;
	return 0;
}

int drmSetClientCap(int fd, uint64_t capability, uint64_t value)
{
	struct drm_set_client_cap cap;

	memclear(cap);
	cap.capability = capability;
	cap.value = value;

	return drmIoctl(fd, DRM_IOCTL_SET_CLIENT_CAP, &cap);
}
d721 2
a722 1
    memclear(u);
d724 1
a724 1
    if (drmIoctl(fd, DRM_IOCTL_GET_UNIQUE, &u))
d727 1
a727 1
    if (drmIoctl(fd, DRM_IOCTL_GET_UNIQUE, &u))
a750 1
    memclear(u);
d754 1
a754 1
    if (drmIoctl(fd, DRM_IOCTL_SET_UNIQUE, &u)) {
a763 2
    memclear(auth);

d765 1
a765 1
    if (drmIoctl(fd, DRM_IOCTL_GET_MAGIC, &auth))
a774 1
    memclear(auth);
d776 1
a776 1
    if (drmIoctl(fd, DRM_IOCTL_AUTH_MAGIC, &auth))
a835 1
    memclear(map);
d838 1
d841 1
a841 1
    if (drmIoctl(fd, DRM_IOCTL_ADD_MAP, &map))
d844 1
a844 1
	*handle = (drm_handle_t)(uintptr_t)map.handle;
d852 1
a852 2
    memclear(map);
    map.handle = (void *)(uintptr_t)handle;
d854 1
a854 1
    if(drmIoctl(fd, DRM_IOCTL_RM_MAP, &map))
a879 1
    memclear(request);
d882 2
d887 1
a887 1
    if (drmIoctl(fd, DRM_IOCTL_ADD_BUFS, &request))
d897 2
a898 1
    memclear(info);
d900 1
a900 1
    if (drmIoctl(fd, DRM_IOCTL_INFO_BUFS, &info))
d909 1
a909 1
    if (drmIoctl(fd, DRM_IOCTL_INFO_BUFS, &info)) {
d918 1
a918 1
	if (drmIoctl(fd, DRM_IOCTL_MARK_BUFS, &info.list[i])) {
a947 1
    memclear(request);
d950 1
a950 1
    if (drmIoctl(fd, DRM_IOCTL_FREE_BUFS, &request))
d1007 1
a1007 1
    *address = drm_mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, handle);
d1027 1
a1027 1
    return drm_munmap(address, size);
d1036 2
a1037 1
    memclear(info);
d1039 1
a1039 1
    if (drmIoctl(fd, DRM_IOCTL_INFO_BUFS, &info))
d1046 1
a1046 1
	if (drmIoctl(fd, DRM_IOCTL_INFO_BUFS, &info)) {
d1087 4
a1090 2
    memclear(bufs);
    if (drmIoctl(fd, DRM_IOCTL_MAP_BUFS, &bufs))
d1099 1
a1099 1
	if (drmIoctl(fd, DRM_IOCTL_MAP_BUFS, &bufs)) {
d1134 1
a1134 1
	drm_munmap(bufs->list[i].address, bufs->list[i].total);
a1204 1
    memclear(lock);
d1214 1
a1214 1
    while (drmIoctl(fd, DRM_IOCTL_LOCK, &lock))
a1234 1
    memclear(lock);
d1236 2
a1237 1
    return drmIoctl(fd, DRM_IOCTL_UNLOCK, &lock);
d1247 3
a1249 2
    memclear(res);
    if (drmIoctl(fd, DRM_IOCTL_RES_CTX, &res))
d1263 1
a1263 1
    if (drmIoctl(fd, DRM_IOCTL_RES_CTX, &res))
d1301 2
a1302 2
    memclear(ctx);
    if (drmIoctl(fd, DRM_IOCTL_ADD_CTX, &ctx))
a1311 1
    memclear(ctx);
d1313 1
a1313 1
    if (drmIoctl(fd, DRM_IOCTL_SWITCH_CTX, &ctx))
a1327 1
    memclear(ctx);
d1329 1
d1334 1
a1334 1
    if (drmIoctl(fd, DRM_IOCTL_MOD_CTX, &ctx))
a1343 1
    memclear(ctx);
d1345 1
a1345 1
    if (drmIoctl(fd, DRM_IOCTL_GET_CTX, &ctx))
a1374 2

    memclear(ctx);
d1376 1
a1376 1
    if (drmIoctl(fd, DRM_IOCTL_RM_CTX, &ctx))
d1384 1
a1384 3

    memclear(draw);
    if (drmIoctl(fd, DRM_IOCTL_ADD_DRAW, &draw))
a1392 2

    memclear(draw);
d1394 1
a1394 1
    if (drmIoctl(fd, DRM_IOCTL_RM_DRAW, &draw))
a1404 1
    memclear(update);
d1410 1
a1410 1
    if (drmIoctl(fd, DRM_IOCTL_UPDATE_DRAW, &update))
d1430 1
a1430 1
    if (drmIoctl(fd, DRM_IOCTL_AGP_ACQUIRE, NULL))
d1448 1
a1448 1
    if (drmIoctl(fd, DRM_IOCTL_AGP_RELEASE, NULL))
a1469 1
    memclear(m);
d1471 1
a1471 1
    if (drmIoctl(fd, DRM_IOCTL_AGP_ENABLE, &m))
a1497 1
    memclear(b);
d1500 1
d1502 1
a1502 1
    if (drmIoctl(fd, DRM_IOCTL_AGP_ALLOC, &b))
d1527 1
a1527 1
    memclear(b);
d1529 1
a1529 1
    if (drmIoctl(fd, DRM_IOCTL_AGP_FREE, &b))
a1551 1
    memclear(b);
d1554 1
a1554 1
    if (drmIoctl(fd, DRM_IOCTL_AGP_BIND, &b))
a1575 1
    memclear(b);
d1577 2
a1578 1
    if (drmIoctl(fd, DRM_IOCTL_AGP_UNBIND, &b))
d1599 1
a1599 3
    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1620 1
a1620 3
    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1641 1
a1641 3
    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1662 1
a1662 3
    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1683 1
a1683 3
    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1704 1
a1704 3
    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1725 1
a1725 3
    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1746 1
a1746 3
    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
d1767 1
a1767 3
    memclear(i);

    if (drmIoctl(fd, DRM_IOCTL_AGP_INFO, &i))
a1775 2
    memclear(sg);

d1778 2
a1779 1
    if (drmIoctl(fd, DRM_IOCTL_SG_ALLOC, &sg))
d1789 1
a1789 1
    memclear(sg);
d1791 1
a1791 1
    if (drmIoctl(fd, DRM_IOCTL_SG_FREE, &sg))
a1808 1
    struct timespec timeout, cur;
a1810 7
    ret = clock_gettime(CLOCK_MONOTONIC, &timeout);
    if (ret < 0) {
	fprintf(stderr, "clock_gettime failed: %s\n", strerror(errno));
	goto out;
    }
    timeout.tv_sec++;

a1813 11
       if (ret && errno == EINTR) {
	       clock_gettime(CLOCK_MONOTONIC, &cur);
	       /* Timeout after 1s */
	       if (cur.tv_sec > timeout.tv_sec + 1 ||
		   (cur.tv_sec == timeout.tv_sec && cur.tv_nsec >=
		    timeout.tv_nsec)) {
		       errno = EBUSY;
		       ret = -1;
		       break;
	       }
       }
a1815 1
out:
a1859 1
    memclear(ctl);
d1862 1
a1862 1
    if (drmIoctl(fd, DRM_IOCTL_CONTROL, &ctl))
a1882 1
    memclear(ctl);
d1885 1
a1885 1
    if (drmIoctl(fd, DRM_IOCTL_CONTROL, &ctl))
a1893 1
    memclear(lock);
d1895 1
d1902 1
a1902 1
    if (drmIoctl(fd, DRM_IOCTL_FINISH, &lock))
a1924 1
    memclear(p);
d1928 1
a1928 1
    if (drmIoctl(fd, DRM_IOCTL_IRQ_BUSID, &p))
a1966 1
    memclear(map);
d1968 1
a1968 1
    map.handle = (void *)(uintptr_t)handle;
d1970 1
a1970 1
    if (drmIoctl(fd, DRM_IOCTL_SET_SAREA_CTX, &map))
a1979 1
    memclear(map);
d1982 1
a1982 1
    if (drmIoctl(fd, DRM_IOCTL_GET_SAREA_CTX, &map))
d1985 1
a1985 1
	*handle = (drm_handle_t)(uintptr_t)map.handle;
a1995 1
    memclear(map);
d1997 1
a1997 1
    if (drmIoctl(fd, DRM_IOCTL_GET_MAP, &map))
a2012 1
    memclear(client);
d2014 1
a2014 1
    if (drmIoctl(fd, DRM_IOCTL_GET_CLIENT, &client))
d2027 1
a2027 1
    unsigned    i;
d2029 1
a2029 2
    memclear(s);
    if (drmIoctl(fd, DRM_IOCTL_GET_STATS, &s))
a2165 1
    memclear(sv);
d2171 1
a2171 1
    if (drmIoctl(fd, DRM_IOCTL_SET_VERSION, &sv)) {
d2197 1
d2202 1
a2202 1
    if (drmIoctl(fd, request, NULL)) {
d2231 1
a2231 1
    if (drmIoctl(fd, request, data)) {
d2260 1
a2260 1
    if (drmIoctl(fd, request, data)) {
d2289 1
a2289 1
    if (drmIoctl(fd, request, data))
d2291 1
a2299 1
    int type;
a2307 5
    return drmOpenOnceWithType(BusID, newlyopened, DRM_NODE_PRIMARY);
}

int drmOpenOnceWithType(const char *BusID, int *newlyopened, int type)
{
d2312 1
a2312 2
	if ((strcmp(BusID, connection[i].BusID) == 0) &&
	    (connection[i].type == type)) {
d2318 2
a2319 2
    fd = drmOpenWithType(NULL, BusID, type);
    if (fd < 0 || nr_fds == DRM_MAX_FDS)
a2324 1
    connection[nr_fds].type = type;
d2356 3
a2358 6
int drmSetMaster(int fd)
{
	return drmIoctl(fd, DRM_IOCTL_SET_MASTER, NULL);
}

int drmDropMaster(int fd)
d2360 2
a2361 1
	return drmIoctl(fd, DRM_IOCTL_DROP_MASTER, NULL);
d2364 2
a2365 135
char *drmGetDeviceNameFromFd(int fd)
{
	char name[128];
	struct stat sbuf;
	dev_t d;
	int i;

	/* The whole drmOpen thing is a fiasco and we need to find a way
	 * back to just using open(2).  For now, however, lets just make
	 * things worse with even more ad hoc directory walking code to
	 * discover the device file name. */

	fstat(fd, &sbuf);
	d = sbuf.st_rdev;

	for (i = 0; i < DRM_MAX_MINOR; i++) {
		snprintf(name, sizeof name, DRM_DEV_NAME, DRM_DIR_NAME, i);
		if (stat(name, &sbuf) == 0 && sbuf.st_rdev == d)
			break;
	}
	if (i == DRM_MAX_MINOR)
		return NULL;

	return strdup(name);
}

int drmGetNodeTypeFromFd(int fd)
{
	struct stat sbuf;
	int maj, min, type;

	if (fstat(fd, &sbuf))
		return -1;

	maj = major(sbuf.st_rdev);
	min = minor(sbuf.st_rdev);

	if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode)) {
		errno = EINVAL;
		return -1;
	}

	type = drmGetMinorType(min);
	if (type == -1)
		errno = ENODEV;
	return type;
}

int drmPrimeHandleToFD(int fd, uint32_t handle, uint32_t flags, int *prime_fd)
{
	struct drm_prime_handle args;
	int ret;

	memclear(args);
	args.fd = -1;
	args.handle = handle;
	args.flags = flags;
	ret = drmIoctl(fd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &args);
	if (ret)
		return ret;

	*prime_fd = args.fd;
	return 0;
}

int drmPrimeFDToHandle(int fd, int prime_fd, uint32_t *handle)
{
	struct drm_prime_handle args;
	int ret;

	memclear(args);
	args.fd = prime_fd;
	ret = drmIoctl(fd, DRM_IOCTL_PRIME_FD_TO_HANDLE, &args);
	if (ret)
		return ret;

	*handle = args.handle;
	return 0;
}

static char *drmGetMinorNameForFD(int fd, int type)
{
#ifdef __linux__
	DIR *sysdir;
	struct dirent *pent, *ent;
	struct stat sbuf;
	const char *name = drmGetMinorName(type);
	int len;
	char dev_name[64], buf[64];
	long name_max;
	int maj, min;

	if (!name)
		return NULL;

	len = strlen(name);

	if (fstat(fd, &sbuf))
		return NULL;

	maj = major(sbuf.st_rdev);
	min = minor(sbuf.st_rdev);

	if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
		return NULL;

	snprintf(buf, sizeof(buf), "/sys/dev/char/%d:%d/device/drm", maj, min);

	sysdir = opendir(buf);
	if (!sysdir)
		return NULL;

	name_max = fpathconf(dirfd(sysdir), _PC_NAME_MAX);
	if (name_max == -1)
		goto out_close_dir;

	pent = malloc(offsetof(struct dirent, d_name) + name_max + 1);
	if (pent == NULL)
		 goto out_close_dir;

	while (readdir_r(sysdir, pent, &ent) == 0 && ent != NULL) {
		if (strncmp(ent->d_name, name, len) == 0) {
			free(pent);
			closedir(sysdir);

			snprintf(dev_name, sizeof(dev_name), DRM_DIR_NAME "/%s",
				 ent->d_name);
			return strdup(dev_name);
		}
	}

	free(pent);

out_close_dir:
	closedir(sysdir);
a2366 12
	return NULL;
}

char *drmGetPrimaryDeviceNameFromFd(int fd)
{
	return drmGetMinorNameForFD(fd, DRM_NODE_PRIMARY);
}

char *drmGetRenderDeviceNameFromFd(int fd)
{
	return drmGetMinorNameForFD(fd, DRM_NODE_RENDER);
}
@


1.1.1.2
log
@Import libdrm 2.4.65
@
text
@a57 1
#include <math.h>
d136 1
a136 2
    if (((env = getenv("LIBGL_DEBUG")) && strstr(env, "verbose")) ||
        (drm_server_info && drm_server_info->debug_print))
d341 1
a341 1
    if (drm_server_info && drm_server_info->get_perms) {
d364 1
a364 1
    if (drm_server_info && drm_server_info->get_perms) {
d409 1
a409 1
	if (drm_server_info && drm_server_info->get_perms) {
d737 1
a737 2
    if (!drmAvailable() && name != NULL && drm_server_info &&
        drm_server_info->load_module) {
a2805 3
			snprintf(dev_name, sizeof(dev_name), DRM_DIR_NAME "/%s",
				 ent->d_name);

d2809 2
a2831 350

#ifdef __linux__
static int drmParseSubsystemType(const char *str)
{
    char link[PATH_MAX + 1] = "";
    char *name;

    if (readlink(str, link, PATH_MAX) < 0)
        return -EINVAL;

    name = strrchr(link, '/');
    if (!name)
        return -EINVAL;

    name++;

    if (strncmp(name, "pci", 3) == 0)
        return DRM_BUS_PCI;

    return -EINVAL;
}

static int drmParsePciBusInfo(const char *str, drmPciBusInfoPtr info)
{
    int domain, bus, dev, func;
    char *value;

    if (str == NULL)
        return -EINVAL;

    value = strstr(str, "PCI_SLOT_NAME=");
    if (value == NULL)
        return -EINVAL;

    value += strlen("PCI_SLOT_NAME=");

    if (sscanf(value, "%04x:%02x:%02x.%1u",
               &domain, &bus, &dev, &func) != 4)
        return -EINVAL;

    info->domain = domain;
    info->bus = bus;
    info->dev = dev;
    info->func = func;

    return 0;
}

static int drmSameDevice(drmDevicePtr a, drmDevicePtr b)
{
    if (a->bustype != b->bustype)
        return 0;

    switch (a->bustype) {
    case DRM_BUS_PCI:
        if (memcmp(a->businfo.pci, b->businfo.pci, sizeof(drmPciBusInfo)) == 0)
            return 1;
    default:
        break;
    }

    return 0;
}

static int drmGetNodeType(const char *name)
{
    if (strncmp(name, DRM_PRIMARY_MINOR_NAME,
        sizeof(DRM_PRIMARY_MINOR_NAME) - 1) == 0)
        return DRM_NODE_PRIMARY;

    if (strncmp(name, DRM_CONTROL_MINOR_NAME,
        sizeof(DRM_CONTROL_MINOR_NAME ) - 1) == 0)
        return DRM_NODE_CONTROL;

    if (strncmp(name, DRM_RENDER_MINOR_NAME,
        sizeof(DRM_RENDER_MINOR_NAME) - 1) == 0)
        return DRM_NODE_RENDER;

    return -EINVAL;
}

static int drmParsePciDeviceInfo(const unsigned char *config,
                                 drmPciDeviceInfoPtr device)
{
    if (config == NULL)
        return -EINVAL;

    device->vendor_id = config[0] | (config[1] << 8);
    device->device_id = config[2] | (config[3] << 8);
    device->revision_id = config[8];
    device->subvendor_id = config[44] | (config[45] << 8);
    device->subdevice_id = config[46] | (config[47] << 8);

    return 0;
}

static void drmFreeDevice(drmDevicePtr device)
{
    int i;

    if (device == NULL)
        return;

    if (device->nodes != NULL)
        for (i = 0; i < DRM_NODE_MAX; i++)
            free(device->nodes[i]);

    free(device->nodes);
    free(device->businfo.pci);
    free(device->deviceinfo.pci);
}

void drmFreeDevices(drmDevicePtr devices[], int count)
{
    int i;

    if (devices == NULL)
        return;

    for (i = 0; i < count; i++) {
        drmFreeDevice(devices[i]);
        free(devices[i]);
        devices[i] = NULL;
    }
}

/**
 * Get drm devices on the system
 *
 * \param devices the array of devices with drmDevicePtr elements
 *                can be NULL to get the device number first
 * \param max_devices the maximum number of devices for the array
 *
 * \return on error - negative error code,
 *         if devices is NULL - total number of devices available on the system,
 *         alternatively the number of devices stored in devices[], which is
 *         capped by the max_devices.
 */
int drmGetDevices(drmDevicePtr devices[], int max_devices)
{
    drmDevicePtr devs = NULL;
    drmPciBusInfoPtr pcibus = NULL;
    drmPciDeviceInfoPtr pcidevice = NULL;
    DIR *sysdir = NULL;
    struct dirent *dent = NULL;
    struct stat sbuf = {0};
    char node[PATH_MAX + 1] = "";
    char path[PATH_MAX + 1] = "";
    char data[128] = "";
    unsigned char config[64] = "";
    int node_type, subsystem_type;
    int maj, min;
    int fd;
    int ret, i = 0, j, node_count, device_count = 0;
    int max_count = 16;
    int *duplicated = NULL;

    devs = calloc(max_count, sizeof(*devs));
    if (devs == NULL)
        return -ENOMEM;

    sysdir = opendir(DRM_DIR_NAME);
    if (!sysdir) {
        ret = -errno;
        goto free_locals;
    }

    while ((dent = readdir(sysdir))) {
        node_type = drmGetNodeType(dent->d_name);
        if (node_type < 0)
            continue;

        snprintf(node, PATH_MAX, "%s/%s", DRM_DIR_NAME, dent->d_name);
        if (stat(node, &sbuf))
            continue;

        maj = major(sbuf.st_rdev);
        min = minor(sbuf.st_rdev);

        if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
            continue;

        snprintf(path, PATH_MAX, "/sys/dev/char/%d:%d/device/subsystem",
                 maj, min);
        subsystem_type = drmParseSubsystemType(path);

        if (subsystem_type < 0)
            continue;

        switch (subsystem_type) {
        case DRM_BUS_PCI:
            pcibus = calloc(1, sizeof(*pcibus));
            if (pcibus == NULL) {
                ret = -ENOMEM;
                goto free_locals;
            }

            snprintf(path, PATH_MAX, "/sys/dev/char/%d:%d/device/uevent",
                     maj, min);
            fd = open(path, O_RDONLY);
            if (fd < 0) {
                ret = -errno;
                goto free_locals;
            }
            ret = read(fd, data, sizeof(data));
            if (ret < 0) {
                ret = -errno;
                close(fd);
                goto free_locals;
            }

            ret = drmParsePciBusInfo(data, pcibus);
            close(fd);
            if (ret)
                goto free_locals;

            if (i >= max_count) {
                max_count += 16;
                devs = realloc(devs, max_count * sizeof(*devs));
            }

            devs[i].businfo.pci = pcibus;
            devs[i].bustype = subsystem_type;
            devs[i].nodes = calloc(DRM_NODE_MAX, sizeof(char *));
            if (devs[i].nodes == NULL) {
                ret = -ENOMEM;
                goto free_locals;
            }
            devs[i].nodes[node_type] = strdup(node);
            if (devs[i].nodes[node_type] == NULL) {
                ret = -ENOMEM;
                goto free_locals;
            }
            devs[i].available_nodes = 1 << node_type;

            if (devices != NULL) {
                snprintf(path, PATH_MAX, "/sys/class/drm/%s/device/config",
                         dent->d_name);
                fd = open(path, O_RDONLY);
                if (fd < 0) {
                     ret = -errno;
                     goto free_locals;
                }
                ret = read(fd, config, 64);
                if (ret < 0) {
                    ret = -errno;
                    close(fd);
                    goto free_locals;
                }

                pcidevice = calloc(1, sizeof(*pcidevice));
                if (pcidevice == NULL) {
                    ret = -ENOMEM;
                    goto free_locals;
                }

                ret = drmParsePciDeviceInfo(config, pcidevice);
                if (ret)
                    goto free_locals;

                devs[i].deviceinfo.pci = pcidevice;
                close(fd);
            }
            break;
        default:
            fprintf(stderr, "The subsystem type is not supported yet\n");
            break;
        }
        i++;
    }

    node_count = i;

    /* merge duplicated devices with same domain/bus/device/func IDs */
    duplicated = calloc(node_count, sizeof(*duplicated));
    if (duplicated == NULL) {
        ret = -ENOMEM;
        goto free_locals;
    }

    for (i = 0; i < node_count; i++) {
        for (j = i+1; j < node_count; j++) {
            if (duplicated[i] || duplicated[j])
                continue;
            if (drmSameDevice(&devs[i], &devs[j])) {
                duplicated[j] = 1;
                devs[i].available_nodes |= devs[j].available_nodes;
                node_type = log2(devs[j].available_nodes);
                devs[i].nodes[node_type] = devs[j].nodes[node_type];
                free(devs[j].nodes);
                free(devs[j].businfo.pci);
                free(devs[j].deviceinfo.pci);
            }
        }
    }

    for (i = 0; i < node_count; i++) {
        if(duplicated[i] == 0) {
            if ((devices != NULL) && (device_count < max_devices)) {
                devices[device_count] = calloc(1, sizeof(drmDevice));
                if (devices[device_count] == NULL) {
                    ret = -ENOMEM;
                    break;
                }
                memcpy(devices[device_count], &devs[i], sizeof(drmDevice));
            } else
                drmFreeDevice(&devs[i]);
            device_count++;
        }
    }

    if (i < node_count) {
        drmFreeDevices(devices, device_count);
        for ( ; i < node_count; i++)
            if(duplicated[i] == 0)
                drmFreeDevice(&devs[i]);
    } else
        ret = device_count;

    free(duplicated);
    free(devs);
    closedir(sysdir);
    return ret;

free_locals:
    for (j = 0; j < i; j++)
        drmFreeDevice(&devs[j]);
    free(pcidevice);
    free(pcibus);
    free(devs);
    closedir(sysdir);
    return ret;
}
#else
void drmFreeDevices(drmDevicePtr devices[], int count)
{
    (void)devices;
    (void)count;
}

int drmGetDevices(drmDevicePtr devices[], int max_devices)
{
    (void)devices;
    (void)max_devices;
    return -EINVAL;
}

#warning "Missing implementation of drmGetDevices/drmFreeDevices"

#endif
@


1.1.1.3
log
@Import libdrm 2.4.67
@
text
@a38 1
#include <stdbool.h>
a46 1
#include <limits.h>
a67 2
#include "util_math.h"

d98 8
a2822 2
#else
#warning "Missing implementation of drmGetMinorNameForFD"
d2837 2
a2838 1
static int drmParseSubsystemType(int maj, int min)
a2839 2
#ifdef __linux__
    char path[PATH_MAX + 1];
d2843 2
a2844 5
    snprintf(path, PATH_MAX, "/sys/dev/char/%d:%d/device/subsystem",
             maj, min);

    if (readlink(path, link, PATH_MAX) < 0)
        return -errno;
d2850 3
a2852 1
    if (strncmp(name, "/pci", 4) == 0)
a2855 4
#else
#warning "Missing implementation of drmParseSubsystemType"
    return -EINVAL;
#endif
d2858 1
a2858 1
static int drmParsePciBusInfo(int maj, int min, drmPciBusInfoPtr info)
a2859 4
#ifdef __linux__
    char path[PATH_MAX + 1];
    char data[128 + 1];
    char *str;
d2861 1
a2861 1
    int fd, ret;
d2863 2
a2864 4
    snprintf(path, PATH_MAX, "/sys/dev/char/%d:%d/device/uevent", maj, min);
    fd = open(path, O_RDONLY);
    if (fd < 0)
        return -errno;
d2866 3
a2868 5
    ret = read(fd, data, sizeof(data));
    data[128] = '\0';
    close(fd);
    if (ret < 0)
        return -errno;
d2870 1
a2870 4
#define TAG "PCI_SLOT_NAME="
    str = strstr(data, TAG);
    if (str == NULL)
        return -EINVAL;
d2872 1
a2872 1
    if (sscanf(str, TAG "%04x:%02x:%02x.%1u",
a2874 1
#undef TAG
a2881 4
#else
#warning "Missing implementation of drmParsePciBusInfo"
    return -EINVAL;
#endif
d2884 1
a2884 1
static int drmCompareBusInfo(drmDevicePtr a, drmDevicePtr b)
a2885 3
    if (a == NULL || b == NULL)
        return -1;

d2887 1
a2887 1
        return -1;
d2891 2
a2892 1
        return memcmp(a->businfo.pci, b->businfo.pci, sizeof(drmPciBusInfo));
d2897 1
a2897 1
    return -1;
d2917 1
a2917 10
static int drmGetMaxNodeName(void)
{
    return sizeof(DRM_DIR_NAME) +
           MAX3(sizeof(DRM_PRIMARY_MINOR_NAME),
                sizeof(DRM_CONTROL_MINOR_NAME),
                sizeof(DRM_RENDER_MINOR_NAME)) +
           3 /* lenght of the node number */;
}

static int drmParsePciDeviceInfo(const char *d_name,
d2920 2
a2921 14
#ifdef __linux__
    char path[PATH_MAX + 1];
    unsigned char config[64];
    int fd, ret;

    snprintf(path, PATH_MAX, "/sys/class/drm/%s/device/config", d_name);
    fd = open(path, O_RDONLY);
    if (fd < 0)
        return -errno;

    ret = read(fd, config, sizeof(config));
    close(fd);
    if (ret < 0)
        return -errno;
a2929 4
#else
#warning "Missing implementation of drmParsePciDeviceInfo"
    return -EINVAL;
#endif
d2932 1
a2932 1
void drmFreeDevice(drmDevicePtr *device)
d2934 2
d2939 7
a2945 2
    free(*device);
    *device = NULL;
a2954 61
    for (i = 0; i < count && devices[i] != NULL; i++)
        drmFreeDevice(&devices[i]);
}

static int drmProcessPciDevice(drmDevicePtr *device, const char *d_name,
                               const char *node, int node_type,
                               int maj, int min, bool fetch_deviceinfo)
{
    const int max_node_str = drmGetMaxNodeName();
    int ret, i;
    char *addr;

    *device = calloc(1, sizeof(drmDevice) +
		     (DRM_NODE_MAX * (sizeof(void *) + max_node_str)) +
		     sizeof(drmPciBusInfo) +
		     sizeof(drmPciDeviceInfo));
    if (!*device)
        return -ENOMEM;

    addr = (char*)*device;
  
    (*device)->bustype = DRM_BUS_PCI;
    (*device)->available_nodes = 1 << node_type;

    addr += sizeof(drmDevice);
    (*device)->nodes = (char**)addr;

    addr += DRM_NODE_MAX * sizeof(void *);
    for (i = 0; i < DRM_NODE_MAX; i++) {
        (*device)->nodes[i] = addr;
        addr += max_node_str;
    }
    memcpy((*device)->nodes[node_type], node, max_node_str);

    (*device)->businfo.pci = (drmPciBusInfoPtr)addr;

    ret = drmParsePciBusInfo(maj, min, (*device)->businfo.pci);
    if (ret)
        goto free_device;

    // Fetch the device info if the user has requested it
    if (fetch_deviceinfo) {
        addr += sizeof(drmPciBusInfo);
        (*device)->deviceinfo.pci = (drmPciDeviceInfoPtr)addr;

        ret = drmParsePciDeviceInfo(d_name, (*device)->deviceinfo.pci);
        if (ret)
            goto free_device;
    }
    return 0;

free_device:
    free(*device);
    *device = NULL;
    return ret;
}

static void drmFoldDuplicatedDevices(drmDevicePtr local_devices[], int count)
{
    int node_type, i, j;

d2956 3
a2958 56
        for (j = i + 1; j < count; j++) {
            if (drmCompareBusInfo(local_devices[i], local_devices[j]) == 0) {
                local_devices[i]->available_nodes |= local_devices[j]->available_nodes;
                node_type = log2(local_devices[j]->available_nodes);
                memcpy(local_devices[i]->nodes[node_type],
                       local_devices[j]->nodes[node_type], drmGetMaxNodeName());
                drmFreeDevice(&local_devices[j]);
            }
        }
    }
}

/**
 * Get information about the opened drm device
 *
 * \param fd file descriptor of the drm device
 * \param device the address of a drmDevicePtr where the information
 *               will be allocated in stored
 *
 * \return zero on success, negative error code otherwise.
 */
int drmGetDevice(int fd, drmDevicePtr *device)
{
    drmDevicePtr *local_devices;
    drmDevicePtr d;
    DIR *sysdir;
    struct dirent *dent;
    struct stat sbuf;
    char node[PATH_MAX + 1];
    int node_type, subsystem_type;
    int maj, min;
    int ret, i, node_count;
    int max_count = 16;

    if (fd == -1 || device == NULL)
        return -EINVAL;

    if (fstat(fd, &sbuf))
        return -errno;

    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);

    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
        return -EINVAL;

    subsystem_type = drmParseSubsystemType(maj, min);

    local_devices = calloc(max_count, sizeof(drmDevicePtr));
    if (local_devices == NULL)
        return -ENOMEM;

    sysdir = opendir(DRM_DIR_NAME);
    if (!sysdir) {
        ret = -errno;
        goto free_locals;
a2959 66

    i = 0;
    while ((dent = readdir(sysdir))) {
        node_type = drmGetNodeType(dent->d_name);
        if (node_type < 0)
            continue;

        snprintf(node, PATH_MAX, "%s/%s", DRM_DIR_NAME, dent->d_name);
        if (stat(node, &sbuf))
            continue;

        maj = major(sbuf.st_rdev);
        min = minor(sbuf.st_rdev);

        if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
            continue;

        if (drmParseSubsystemType(maj, min) != subsystem_type)
            continue;

        switch (subsystem_type) {
        case DRM_BUS_PCI:
            ret = drmProcessPciDevice(&d, dent->d_name, node, node_type,
                                      maj, min, true);
            if (ret)
                goto free_devices;

            break;
        default:
            fprintf(stderr, "The subsystem type is not supported yet\n");
            continue;
        }

        if (i >= max_count) {
            drmDevicePtr *temp;

            max_count += 16;
            temp = realloc(local_devices, max_count * sizeof(drmDevicePtr));
            if (!temp)
                goto free_devices;
            local_devices = temp;
        }

        local_devices[i] = d;
        i++;
    }
    node_count = i;

    /* Fold nodes into a single device if they share the same bus info */
    drmFoldDuplicatedDevices(local_devices, node_count);

    *device = local_devices[0];
    for (i = 1; i < node_count && local_devices[i]; i++)
            drmFreeDevice(&local_devices[i]);

    closedir(sysdir);
    free(local_devices);
    return 0;

free_devices:
    drmFreeDevices(local_devices, i);
    closedir(sysdir);

free_locals:
    free(local_devices);
    return ret;
d2976 10
a2985 6
    drmDevicePtr *local_devices;
    drmDevicePtr device;
    DIR *sysdir;
    struct dirent *dent;
    struct stat sbuf;
    char node[PATH_MAX + 1];
d2988 2
a2989 1
    int ret, i, node_count, device_count;
d2991 1
d2993 2
a2994 2
    local_devices = calloc(max_count, sizeof(drmDevicePtr));
    if (local_devices == NULL)
a3002 1
    i = 0;
d3018 3
a3020 1
        subsystem_type = drmParseSubsystemType(maj, min);
d3027 22
a3048 2
            ret = drmProcessPciDevice(&device, dent->d_name, node, node_type,
                                      maj, min, devices != NULL);
d3050 45
a3094 1
                goto free_devices;
d3096 3
d3102 1
a3102 1
            continue;
a3103 12

        if (i >= max_count) {
            drmDevicePtr *temp;

            max_count += 16;
            temp = realloc(local_devices, max_count * sizeof(drmDevicePtr));
            if (!temp)
                goto free_devices;
            local_devices = temp;
        }

        local_devices[i] = device;
d3106 1
d3109 6
a3114 2
    /* Fold nodes into a single device if they share the same bus info */
    drmFoldDuplicatedDevices(local_devices, node_count);
d3116 15
a3130 6
    device_count = 0;
    for (i = 0; i < node_count && local_devices[i]; i++) {
        if ((devices != NULL) && (device_count < max_devices))
            devices[device_count] = local_devices[i];
        else
            drmFreeDevice(&local_devices[i]);
d3132 13
a3144 1
        device_count++;
d3147 7
a3153 3
    closedir(sysdir);
    free(local_devices);
    return device_count;
d3155 2
a3156 2
free_devices:
    drmFreeDevices(local_devices, i);
d3158 1
d3161 6
a3166 1
    free(local_devices);
d3169 17
@


1.1.1.4
log
@Import libdrm 2.4.71
@
text
@d2 1
a2 1
 * \file xf86drm.c
d57 2
a58 5
#ifdef MAJOR_IN_MKDEV
#include <sys/mkdev.h>
#endif
#ifdef MAJOR_IN_SYSMACROS
#include <sys/sysmacros.h>
d73 3
a75 3
#define DRM_PRIMARY_MINOR_NAME  "drm"
#define DRM_CONTROL_MINOR_NAME  "drmC"
#define DRM_RENDER_MINOR_NAME   "drmR"
d77 3
a79 3
#define DRM_PRIMARY_MINOR_NAME  "card"
#define DRM_CONTROL_MINOR_NAME  "controlD"
#define DRM_RENDER_MINOR_NAME   "renderD"
d99 1
a99 1
#define DRM_MAJOR 226 /* Linux */
d131 1
a131 1
    va_list ap;
d136 7
a142 7
        va_start(ap, format);
        if (drm_server_info) {
            drm_server_info->debug_print(format,ap);
        } else {
            drmDebugPrint(format, ap);
        }
        va_end(ap);
d169 1
a169 1
    int ret;
d172 1
a172 1
        ret = ioctl(fd, request, arg);
d193 1
a193 1
        drmHashTable = drmHashCreate();
d196 5
a200 5
        entry           = drmMalloc(sizeof(*entry));
        entry->fd       = fd;
        entry->f        = NULL;
        entry->tagTable = drmHashCreate();
        drmHashInsert(drmHashTable, key, entry);
d202 1
a202 1
        entry = value;
d224 1
a224 1
        return 1;
d228 31
a258 31
        unsigned int o1, b1, d1, f1;
        unsigned int o2, b2, d2, f2;
        int ret;

        ret = sscanf(id1, "pci:%04x:%02x:%02x.%u", &o1, &b1, &d1, &f1);
        if (ret != 4) {
            o1 = 0;
            ret = sscanf(id1, "PCI:%u:%u:%u", &b1, &d1, &f1);
            if (ret != 3)
                return 0;
        }

        ret = sscanf(id2, "pci:%04x:%02x:%02x.%u", &o2, &b2, &d2, &f2);
        if (ret != 4) {
            o2 = 0;
            ret = sscanf(id2, "PCI:%u:%u:%u", &b2, &d2, &f2);
            if (ret != 3)
                return 0;
        }

        /* If domains aren't properly supported by the kernel interface,
         * just ignore them, which sucks less than picking a totally random
         * card with "open by name"
         */
        if (!pci_domain_ok)
            o1 = o2 = 0;

        if ((o1 != o2) || (b1 != b2) || (d1 != d2) || (f1 != f2))
            return 0;
        else
            return 1;
d280 1
a280 8
        int rv;

        do {
            rv = chown(path, owner, group);
        } while (rv != 0 && errno == EINTR);

        if (rv == 0)
            return 0;
d282 10
a291 3
        drmMsg("Failed to change owner or group for file %s! %d: %s\n",
               path, errno, strerror(errno));
        return -1;
d300 1
a300 1
 *
d324 2
a325 2
        dev_name = DRM_DEV_NAME;
        break;
d327 2
a328 2
        dev_name = DRM_CONTROL_DEV_NAME;
        break;
d330 2
a331 2
        dev_name = DRM_RENDER_DEV_NAME;
        break;
d333 1
a333 1
        return -EINVAL;
d340 3
a342 3
        drm_server_info->get_perms(&serv_group, &serv_mode);
        devmode  = serv_mode ? serv_mode : DRM_DEV_MODE;
        devmode &= ~(S_IXUSR|S_IXGRP|S_IXOTH);
d347 5
a351 5
        if (!isroot)
            return DRM_ERR_NOT_ROOT;
        mkdir(DRM_DIR_NAME, DRM_DEV_DIRMODE);
        chown_check_return(DRM_DIR_NAME, 0, 0); /* root:root */
        chmod(DRM_DIR_NAME, DRM_DEV_DIRMODE);
d356 4
a359 4
        if (!isroot)
            return DRM_ERR_NOT_ROOT;
        remove(buf);
        mknod(buf, S_IFCHR | devmode, dev);
d363 3
a365 3
        group = ((int)serv_group >= 0) ? serv_group : DRM_DEV_GID;
        chown_check_return(buf, user, group);
        chmod(buf, devmode);
d370 1
a370 1
        int udev_count = 0;
d373 2
a374 7
            usleep(20);
            udev_count++;

            if (udev_count == 50)
                return -1;
            goto wait_for_udev;
        }
d376 13
a388 8
        if (stat(buf, &st)) {
            usleep(20);
            udev_count++;

            if (udev_count == 50)
                return -1;
            goto wait_for_udev;
        }
d394 1
a394 1
           fd, fd < 0 ? strerror(errno) : "OK");
d396 1
a396 1
        return fd;
d403 8
a410 8
        if (!isroot)
            return DRM_ERR_NOT_ROOT;
        remove(buf);
        mknod(buf, S_IFCHR | devmode, dev);
        if (drm_server_info && drm_server_info->get_perms) {
            chown_check_return(buf, user, group);
            chmod(buf, devmode);
        }
d414 1
a414 1
           fd, fd < 0 ? strerror(errno) : "OK");
d416 1
a416 1
        return fd;
d432 1
a432 1
 *
d442 1
a442 1

d444 2
a445 2
        return drmOpenDevice(makedev(DRM_MAJOR, minor), minor, type);

d448 2
a449 2
        dev_name = DRM_DEV_NAME;
        break;
d451 2
a452 2
        dev_name = DRM_CONTROL_DEV_NAME;
        break;
d454 2
a455 2
        dev_name = DRM_RENDER_DEV_NAME;
        break;
d457 1
a457 1
        return -EINVAL;
d462 1
a462 1
        return fd;
d469 1
a469 1
 *
d472 1
a472 1
 * \internal
d485 3
a487 3
        /* Try proc for backward Linux compatibility */
        if (!access("/proc/dri/0", R_OK))
            return 1;
d489 1
a489 1
        return 0;
d491 1
a491 1

d493 2
a494 2
        retval = 1;
        drmFreeVersion(version);
d573 11
a583 11
        fd = drmOpenMinor(i, 1, type);
        drmMsg("drmOpenByBusid: drmOpenMinor returns %d\n", fd);
        if (fd >= 0) {
            /* We need to try for 1.4 first for proper PCI domain support
             * and if that fails, we know the kernel is busted
             */
            sv.drm_di_major = 1;
            sv.drm_di_minor = 4;
            sv.drm_dd_major = -1;        /* Don't care */
            sv.drm_dd_minor = -1;        /* Don't care */
            if (drmSetInterfaceVersion(fd, &sv)) {
d585 1
a585 1
                pci_domain_ok = 0;
d587 17
a603 17
                sv.drm_di_major = 1;
                sv.drm_di_minor = 1;
                sv.drm_dd_major = -1;       /* Don't care */
                sv.drm_dd_minor = -1;       /* Don't care */
                drmMsg("drmOpenByBusid: Interface 1.4 failed, trying 1.1\n");
                drmSetInterfaceVersion(fd, &sv);
            }
            buf = drmGetBusid(fd);
            drmMsg("drmOpenByBusid: drmGetBusid reports %s\n", buf);
            if (buf && drmMatchBusID(buf, busid, pci_domain_ok)) {
                drmFreeBusid(buf);
                return fd;
            }
            if (buf)
                drmFreeBusid(buf);
            close(fd);
        }
d614 1
a614 1
 *
d616 1
a616 1
 *
d621 1
a621 1
 *
d640 19
a658 19
        if ((fd = drmOpenMinor(i, 1, type)) >= 0) {
            if ((version = drmGetVersion(fd))) {
                if (!strcmp(version->name, name)) {
                    drmFreeVersion(version);
                    id = drmGetBusid(fd);
                    drmMsg("drmGetBusid returned '%s'\n", id ? id : "NULL");
                    if (!id || !*id) {
                        if (id)
                            drmFreeBusid(id);
                        return fd;
                    } else {
                        drmFreeBusid(id);
                    }
                } else {
                    drmFreeVersion(version);
                }
            }
            close(fd);
        }
d664 26
a689 26
        char proc_name[64], buf[512];
        char *driver, *pt, *devstring;
        int  retcode;

        sprintf(proc_name, "/proc/dri/%d/name", i);
        if ((fd = open(proc_name, 0, 0)) >= 0) {
            retcode = read(fd, buf, sizeof(buf)-1);
            close(fd);
            if (retcode) {
                buf[retcode-1] = '\0';
                for (driver = pt = buf; *pt && *pt != ' '; ++pt)
                    ;
                if (*pt) { /* Device is next */
                    *pt = '\0';
                    if (!strcmp(driver, name)) { /* Match */
                        for (devstring = ++pt; *pt && *pt != ' '; ++pt)
                            ;
                        if (*pt) { /* Found busid */
                            return drmOpenByBusid(++pt, type);
                        } else { /* No busid */
                            return drmOpenDevice(strtol(devstring, NULL, 0),i, type);
                        }
                    }
                }
            }
        }
d705 1
a705 1
 *
d707 1
a707 1
 *
d737 5
a741 5
        /* try to load the kernel module */
        if (!drm_server_info->load_module(name)) {
            drmMsg("[drm] failed to load kernel module \"%s\"\n", name);
            return -1;
        }
d745 3
a747 3
        int fd = drmOpenByBusid(busid, type);
        if (fd >= 0)
            return fd;
d749 1
a749 1

d751 1
a751 1
        return drmOpenByName(name, type);
d778 1
a778 1
        return;
d798 1
a798 1
        return;
d808 1
a808 1
 *
d811 1
a811 1
 *
d834 1
a834 1
 *
d837 1
a837 1
 *
d839 1
a839 1
 *
d853 2
a854 2
        drmFreeKernelVersion(version);
        return NULL;
d858 1
a858 1
        version->name    = drmMalloc(version->name_len + 1);
d860 1
a860 1
        version->date    = drmMalloc(version->date_len + 1);
d862 1
a862 1
        version->desc    = drmMalloc(version->desc_len + 1);
d865 3
a867 3
        drmMsg("DRM_IOCTL_VERSION: %s\n", strerror(errno));
        drmFreeKernelVersion(version);
        return NULL;
d884 1
a884 1
 *
d886 1
a886 1
 *
d890 1
a890 1
 *
d918 2
a919 2
    struct drm_get_cap cap;
    int ret;
d921 2
a922 2
    memclear(cap);
    cap.capability = capability;
d924 3
a926 3
    ret = drmIoctl(fd, DRM_IOCTL_GET_CAP, &cap);
    if (ret)
        return ret;
d928 2
a929 2
    *value = cap.value;
    return 0;
d934 1
a934 1
    struct drm_set_client_cap cap;
d936 3
a938 3
    memclear(cap);
    cap.capability = capability;
    cap.value = value;
d940 1
a940 1
    return drmIoctl(fd, DRM_IOCTL_SET_CLIENT_CAP, &cap);
d976 1
a976 1
        return NULL;
d979 1
a979 1
        return NULL;
d1007 1
a1007 1
        return -errno;
d1020 1
a1020 1
        return -errno;
d1032 1
a1032 1
        return -errno;
d1048 1
a1048 1
 *
d1059 1
a1059 1
 * kernel, the frame buffer area will be set to write combining.
d1067 2
a1068 2
 * The area mapped will be uncached.
 *
d1074 1
a1074 1
 *
d1078 2
a1079 2
 * returned.
 *
d1087 1
a1087 1
              drmMapFlags flags, drm_handle_t *handle)
d1097 1
a1097 1
        return -errno;
d1099 1
a1099 1
        *handle = (drm_handle_t)(uintptr_t)map.handle;
d1111 1
a1111 1
        return -errno;
d1117 1
a1117 1
 *
d1122 1
a1122 1
 * \param agp_offset offset in the AGP aperture
d1132 1
a1132 1
               int agp_offset)
d1143 1
a1143 1
        return -errno;
d1155 1
a1155 1
        return -EINVAL;
d1158 1
a1158 1
        return -EINVAL;
d1161 1
a1161 1
        return -ENOMEM;
d1164 3
a1166 3
        int retval = -errno;
        drmFree(info.list);
        return retval;
d1170 7
a1176 7
        info.list[i].low_mark  = low  * info.list[i].count;
        info.list[i].high_mark = high * info.list[i].count;
        if (drmIoctl(fd, DRM_IOCTL_MARK_BUFS, &info.list[i])) {
            int retval = -errno;
            drmFree(info.list);
            return retval;
        }
d1191 1
a1191 1
 *
d1193 1
a1193 1
 *
d1206 1
a1206 1
        return -errno;
d1246 1
a1246 1
 *
d1255 1
a1255 1
        return -EINVAL;
d1258 1
a1258 1
        pagesize_mask = getpagesize() - 1;
d1264 1
a1264 1
        return -errno;
d1274 1
a1274 1
 *
d1294 1
a1294 1
        return NULL;
d1297 2
a1298 2
        if (!(info.list = drmMalloc(info.count * sizeof(*info.list))))
            return NULL;
d1300 16
a1315 16
        if (drmIoctl(fd, DRM_IOCTL_INFO_BUFS, &info)) {
            drmFree(info.list);
            return NULL;
        }

        retval = drmMalloc(sizeof(*retval));
        retval->count = info.count;
        retval->list  = drmMalloc(info.count * sizeof(*retval->list));
        for (i = 0; i < info.count; i++) {
            retval->list[i].count     = info.list[i].count;
            retval->list[i].size      = info.list[i].size;
            retval->list[i].low_mark  = info.list[i].low_mark;
            retval->list[i].high_mark = info.list[i].high_mark;
        }
        drmFree(info.list);
        return retval;
d1329 1
a1329 1
 *
d1334 1
a1334 1
 */
d1343 1
a1343 1
        return NULL;
d1346 1
a1346 1
        return NULL;
d1348 2
a1349 17
    if (!(bufs.list = drmMalloc(bufs.count * sizeof(*bufs.list))))
        return NULL;

    if (drmIoctl(fd, DRM_IOCTL_MAP_BUFS, &bufs)) {
        drmFree(bufs.list);
        return NULL;
    }

    retval = drmMalloc(sizeof(*retval));
    retval->count = bufs.count;
    retval->list  = drmMalloc(bufs.count * sizeof(*retval->list));
    for (i = 0; i < bufs.count; i++) {
        retval->list[i].idx     = bufs.list[i].idx;
        retval->list[i].total   = bufs.list[i].total;
        retval->list[i].used    = 0;
        retval->list[i].address = bufs.list[i].address;
    }
d1351 18
a1368 2
    drmFree(bufs.list);
    return retval;
d1386 1
a1386 1
        drm_munmap(bufs->list[i].address, bufs->list[i].total);
d1391 1
d1396 1
a1396 1
#define DRM_DMA_RETRY  16
d1402 2
a1403 2
 * \param request
 *
d1427 1
a1427 1
        ret = ioctl( fd, DRM_IOCTL_DMA, &dma );
d1431 2
a1432 2
        request->granted_count = dma.granted_count;
        return 0;
d1434 1
a1434 1
        return -errno;
d1446 1
a1446 1
 *
d1448 1
a1448 1
 *
d1468 1
a1468 1
        ;
d1477 1
a1477 1
 *
d1479 1
a1479 1
 *
d1502 1
a1502 1
        return NULL;
d1505 1
a1505 1
        return NULL;
d1508 1
a1508 1
        return NULL;
d1510 2
a1511 2
        drmFree(list);
        return NULL;
d1516 1
a1516 1
        return NULL;
d1519 1
a1519 1
        retval[i] = list[i].handle;
d1540 1
a1540 1
 *
d1542 1
a1542 1
 *
d1544 1
a1544 1
 *
d1555 1
a1555 1
        return -errno;
d1567 1
a1567 1
        return -errno;
d1584 1
a1584 1
        ctx.flags |= _DRM_CONTEXT_PRESERVED;
d1586 1
a1586 1
        ctx.flags |= _DRM_CONTEXT_2DONLY;
d1588 1
a1588 1
        return -errno;
d1600 1
a1600 1
        return -errno;
d1603 1
a1603 1
        *flags |= DRM_CONTEXT_PRESERVED;
d1605 1
a1605 1
        *flags |= DRM_CONTEXT_2DONLY;
d1614 1
a1614 1
 *
d1617 1
a1617 1
 *
d1619 1
a1619 1
 *
d1621 1
a1621 1
 *
d1633 1
a1633 1
        return -errno;
d1643 1
a1643 1
        return -errno;
d1655 1
a1655 1
        return -errno;
d1660 2
a1661 2
                          drm_drawable_info_type_t type, unsigned int num,
                          void *data)
d1672 1
a1672 1
        return -errno;
d1683 1
a1683 1
 *
d1685 1
a1685 1
 *
d1692 1
a1692 1
        return -errno;
d1701 1
a1701 1
 *
d1703 1
a1703 1
 *
d1710 1
a1710 1
        return -errno;
d1720 1
a1720 1
 *
d1722 1
a1722 1
 *
d1734 1
a1734 1
        return -errno;
d1748 1
a1748 1
 *
d1750 1
a1750 1
 *
d1756 1
a1756 1
                unsigned long *address, drm_handle_t *handle)
d1765 1
a1765 1
        return -errno;
d1767 1
a1767 1
        *address = b.physical;
d1778 1
a1778 1
 *
d1780 1
a1780 1
 *
d1792 1
a1792 1
        return -errno;
d1803 1
a1803 1
 *
d1805 1
a1805 1
 *
d1818 1
a1818 1
        return -errno;
d1828 1
a1828 1
 *
d1830 1
a1830 1
 *
d1842 1
a1842 1
        return -errno;
d1851 1
a1851 1
 *
d1853 1
a1853 1
 *
d1865 1
a1865 1
        return -errno;
d1874 1
a1874 1
 *
d1876 1
a1876 1
 *
d1888 1
a1888 1
        return -errno;
d1897 1
a1897 1
 *
d1899 1
a1899 1
 *
d1911 1
a1911 1
        return 0;
d1920 1
a1920 1
 *
d1922 1
a1922 1
 *
d1934 1
a1934 1
        return 0;
d1943 1
a1943 1
 *
d1945 1
a1945 1
 *
d1957 1
a1957 1
        return 0;
d1966 1
a1966 1
 *
d1968 1
a1968 1
 *
d1980 1
a1980 1
        return 0;
d1989 1
a1989 1
 *
d1991 1
a1991 1
 *
d2003 1
a2003 1
        return 0;
d2012 1
a2012 1
 *
d2014 1
a2014 1
 *
d2026 1
a2026 1
        return 0;
d2035 1
a2035 1
 *
d2037 1
a2037 1
 *
d2049 1
a2049 1
        return 0;
d2062 1
a2062 1
        return -errno;
d2074 1
a2074 1
        return -errno;
d2083 1
a2083 1
 *
d2085 1
a2085 1
 *
d2096 2
a2097 2
        fprintf(stderr, "clock_gettime failed: %s\n", strerror(errno));
        goto out;
d2105 9
a2113 9
           clock_gettime(CLOCK_MONOTONIC, &cur);
           /* Timeout after 1s */
           if (cur.tv_sec > timeout.tv_sec + 1 ||
               (cur.tv_sec == timeout.tv_sec && cur.tv_nsec >=
                timeout.tv_nsec)) {
                   errno = EBUSY;
                   ret = -1;
                   break;
           }
d2125 2
a2126 2
        fprintf(stderr, "%s: no device\n", label);
        break;
d2128 2
a2129 2
        fprintf(stderr, "%s: no access\n", label);
        break;
d2131 2
a2132 2
        fprintf(stderr, "%s: not root\n", label);
        break;
d2134 2
a2135 2
        fprintf(stderr, "%s: invalid args\n", label);
        break;
d2137 4
a2140 4
        if (err < 0)
            err = -err;
        fprintf( stderr, "%s: error %d (%s)\n", label, err, strerror(err) );
        break;
d2151 1
a2151 1
 *
d2153 1
a2153 1
 *
d2166 1
a2166 1
        return -errno;
d2175 1
a2175 1
 *
d2177 1
a2177 1
 *
d2190 1
a2190 1
        return -errno;
d2207 1
a2207 1
        return -errno;
d2218 1
a2218 1
 *
d2220 1
a2220 1
 *
d2234 1
a2234 1
        return -errno;
d2243 2
a2244 2
        drmHashDelete(entry->tagTable, context);
        drmHashInsert(entry->tagTable, context, tag);
d2262 1
a2262 1
        return NULL;
d2277 1
a2277 1
        return -errno;
d2290 1
a2290 1
        return -errno;
d2292 1
a2292 1
        *handle = (drm_handle_t)(uintptr_t)map.handle;
d2298 2
a2299 2
              drmMapType *type, drmMapFlags *flags, drm_handle_t *handle,
              int *mtrr)
d2306 1
a2306 1
        return -errno;
d2317 1
a2317 1
                 unsigned long *magic, unsigned long *iocs)
d2324 1
a2324 1
        return -errno;
d2340 1
a2340 1
        return -errno;
d2345 1
a2345 1
        return -1;
d2372 81
a2452 81
        stats->data[i].value = s.data[i].value;
        switch (s.data[i].type) {
        case _DRM_STAT_LOCK:
            stats->data[i].long_name = "Lock";
            stats->data[i].rate_name = "Lock";
            SET_VALUE;
            break;
        case _DRM_STAT_OPENS:
            stats->data[i].long_name = "Opens";
            stats->data[i].rate_name = "O";
            SET_COUNT;
            stats->data[i].verbose   = 1;
            break;
        case _DRM_STAT_CLOSES:
            stats->data[i].long_name = "Closes";
            stats->data[i].rate_name = "Lock";
            SET_COUNT;
            stats->data[i].verbose   = 1;
            break;
        case _DRM_STAT_IOCTLS:
            stats->data[i].long_name = "Ioctls";
            stats->data[i].rate_name = "Ioc/s";
            SET_COUNT;
            break;
        case _DRM_STAT_LOCKS:
            stats->data[i].long_name = "Locks";
            stats->data[i].rate_name = "Lck/s";
            SET_COUNT;
            break;
        case _DRM_STAT_UNLOCKS:
            stats->data[i].long_name = "Unlocks";
            stats->data[i].rate_name = "Unl/s";
            SET_COUNT;
            break;
        case _DRM_STAT_IRQ:
            stats->data[i].long_name = "IRQs";
            stats->data[i].rate_name = "IRQ/s";
            SET_COUNT;
            break;
        case _DRM_STAT_PRIMARY:
            stats->data[i].long_name = "Primary Bytes";
            stats->data[i].rate_name = "PB/s";
            SET_BYTE;
            break;
        case _DRM_STAT_SECONDARY:
            stats->data[i].long_name = "Secondary Bytes";
            stats->data[i].rate_name = "SB/s";
            SET_BYTE;
            break;
        case _DRM_STAT_DMA:
            stats->data[i].long_name = "DMA";
            stats->data[i].rate_name = "DMA/s";
            SET_COUNT;
            break;
        case _DRM_STAT_SPECIAL:
            stats->data[i].long_name = "Special DMA";
            stats->data[i].rate_name = "dma/s";
            SET_COUNT;
            break;
        case _DRM_STAT_MISSED:
            stats->data[i].long_name = "Miss";
            stats->data[i].rate_name = "Ms/s";
            SET_COUNT;
            break;
        case _DRM_STAT_VALUE:
            stats->data[i].long_name = "Value";
            stats->data[i].rate_name = "Value";
            SET_VALUE;
            break;
        case _DRM_STAT_BYTE:
            stats->data[i].long_name = "Bytes";
            stats->data[i].rate_name = "B/s";
            SET_BYTE;
            break;
        case _DRM_STAT_COUNT:
        default:
            stats->data[i].long_name = "Count";
            stats->data[i].rate_name = "Cnt/s";
            SET_COUNT;
            break;
        }
d2461 1
a2461 1
 * \param drmCommandIndex command index
d2464 1
a2464 1
 *
d2466 1
a2466 1
 *
d2468 1
a2468 1
 * It issues a read-write ioctl given by
d2483 1
a2483 1
        retcode = -errno;
d2498 2
a2499 2
 * \param drmCommandIndex command index
 *
d2501 1
a2501 1
 *
d2503 1
a2503 1
 * It issues a ioctl given by
d2513 1
a2513 1
        return -errno;
d2523 1
a2523 1
 * \param drmCommandIndex command index
d2526 1
a2526 1
 *
d2530 1
a2530 1
 * It issues a read ioctl given by
d2538 2
a2539 2
    request = DRM_IOC( DRM_IOC_READ, DRM_IOCTL_BASE,
        DRM_COMMAND_BASE + drmCommandIndex, size);
d2542 1
a2542 1
        return -errno;
d2552 1
a2552 1
 * \param drmCommandIndex command index
d2555 1
a2555 1
 *
d2557 1
a2557 1
 *
d2559 1
a2559 1
 * It issues a write ioctl given by
d2567 2
a2568 2
    request = DRM_IOC( DRM_IOC_WRITE, DRM_IOCTL_BASE,
        DRM_COMMAND_BASE + drmCommandIndex, size);
d2571 1
a2571 1
        return -errno;
d2581 1
a2581 1
 * \param drmCommandIndex command index
d2584 1
a2584 1
 *
d2586 1
a2586 1
 *
d2588 1
a2588 1
 * It issues a read-write ioctl given by
d2596 2
a2597 2
    request = DRM_IOC( DRM_IOC_READ|DRM_IOC_WRITE, DRM_IOCTL_BASE,
        DRM_COMMAND_BASE + drmCommandIndex, size);
d2600 1
a2600 1
        return -errno;
d2614 3
a2616 3
int drmOpenOnce(void *unused,
                const char *BusID,
                int *newlyopened)
d2625 1
a2625 1

d2627 6
a2632 6
        if ((strcmp(BusID, connection[i].BusID) == 0) &&
            (connection[i].type == type)) {
            connection[i].refcount++;
            *newlyopened = 0;
            return connection[i].fd;
        }
d2636 2
a2637 2
        return fd;

d2645 3
a2647 3
        fprintf(stderr, "saved connection %d for %s %d\n",
                nr_fds, connection[nr_fds].BusID,
                strcmp(BusID, connection[nr_fds].BusID));
d2659 11
a2669 11
        if (fd == connection[i].fd) {
            if (--connection[i].refcount == 0) {
                drmClose(connection[i].fd);
                free(connection[i].BusID);

                if (i < --nr_fds)
                    connection[i] = connection[nr_fds];

                return;
            }
        }
d2675 1
a2675 1
        return drmIoctl(fd, DRM_IOCTL_SET_MASTER, NULL);
d2680 1
a2680 1
        return drmIoctl(fd, DRM_IOCTL_DROP_MASTER, NULL);
d2685 20
a2704 20
    char name[128];
    struct stat sbuf;
    dev_t d;
    int i;

    /* The whole drmOpen thing is a fiasco and we need to find a way
     * back to just using open(2).  For now, however, lets just make
     * things worse with even more ad hoc directory walking code to
     * discover the device file name. */

    fstat(fd, &sbuf);
    d = sbuf.st_rdev;

    for (i = 0; i < DRM_MAX_MINOR; i++) {
        snprintf(name, sizeof name, DRM_DEV_NAME, DRM_DIR_NAME, i);
        if (stat(name, &sbuf) == 0 && sbuf.st_rdev == d)
            break;
    }
    if (i == DRM_MAX_MINOR)
        return NULL;
d2706 1
a2706 1
    return strdup(name);
d2711 2
a2712 5
    struct stat sbuf;
    int maj, min, type;

    if (fstat(fd, &sbuf))
        return -1;
d2714 2
a2715 2
    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);
d2717 2
a2718 4
    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode)) {
        errno = EINVAL;
        return -1;
    }
d2720 9
a2728 4
    type = drmGetMinorType(min);
    if (type == -1)
        errno = ENODEV;
    return type;
d2733 2
a2734 2
    struct drm_prime_handle args;
    int ret;
d2736 7
a2742 7
    memclear(args);
    args.fd = -1;
    args.handle = handle;
    args.flags = flags;
    ret = drmIoctl(fd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &args);
    if (ret)
        return ret;
d2744 2
a2745 2
    *prime_fd = args.fd;
    return 0;
d2750 2
a2751 2
    struct drm_prime_handle args;
    int ret;
d2753 5
a2757 5
    memclear(args);
    args.fd = prime_fd;
    ret = drmIoctl(fd, DRM_IOCTL_PRIME_FD_TO_HANDLE, &args);
    if (ret)
        return ret;
d2759 2
a2760 2
    *handle = args.handle;
    return 0;
d2766 13
a2778 8
    DIR *sysdir;
    struct dirent *pent, *ent;
    struct stat sbuf;
    const char *name = drmGetMinorName(type);
    int len;
    char dev_name[64], buf[64];
    long name_max;
    int maj, min;
d2780 2
a2781 2
    if (!name)
        return NULL;
d2783 2
a2784 1
    len = strlen(name);
d2786 2
a2787 2
    if (fstat(fd, &sbuf))
        return NULL;
d2789 1
a2789 2
    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);
d2791 3
a2793 2
    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
        return NULL;
d2795 3
a2797 1
    snprintf(buf, sizeof(buf), "/sys/dev/char/%d:%d/device/drm", maj, min);
d2799 3
a2801 3
    sysdir = opendir(buf);
    if (!sysdir)
        return NULL;
d2803 4
a2806 12
    name_max = fpathconf(dirfd(sysdir), _PC_NAME_MAX);
    if (name_max == -1)
        goto out_close_dir;

    pent = malloc(offsetof(struct dirent, d_name) + name_max + 1);
    if (pent == NULL)
         goto out_close_dir;

    while (readdir_r(sysdir, pent, &ent) == 0 && ent != NULL) {
        if (strncmp(ent->d_name, name, len) == 0) {
            snprintf(dev_name, sizeof(dev_name), DRM_DIR_NAME "/%s",
                 ent->d_name);
d2808 2
a2809 2
            free(pent);
            closedir(sysdir);
d2811 3
a2813 3
            return strdup(dev_name);
        }
    }
d2815 1
a2815 1
    free(pent);
d2818 1
a2818 1
    closedir(sysdir);
d2822 1
a2822 1
    return NULL;
d2827 1
a2827 1
    return drmGetMinorNameForFD(fd, DRM_NODE_PRIMARY);
d2832 1
a2832 1
    return drmGetMinorNameForFD(fd, DRM_NODE_RENDER);
d2945 1
a2945 1
           3 /* length of the node number */;
d2995 2
a2996 3
    for (i = 0; i < count; i++)
        if (devices[i])
            drmFreeDevice(&devices[i]);
d3003 1
a3003 1
    const int max_node_str = ALIGN(drmGetMaxNodeName(), sizeof(void *));
d3008 3
a3010 3
                     (DRM_NODE_MAX * (sizeof(void *) + max_node_str)) +
                     sizeof(drmPciBusInfo) +
                     sizeof(drmPciDeviceInfo));
d3015 1
a3015 1

a3051 5
/* Consider devices located on the same bus as duplicate and fold the respective
 * entries into a single one.
 *
 * Note: this leaves "gaps" in the array, while preserving the length.
 */
a3089 1
    dev_t find_rdev;
a3096 1
    find_rdev = sbuf.st_rdev;
d3157 1
a3157 7
        /* store target at local_devices[0] for ease to use below */
        if (find_rdev == sbuf.st_rdev && i) {
            local_devices[i] = local_devices[0];
            local_devices[0] = d;
        }
        else
            local_devices[i] = d;
d3162 1
d3166 2
a3167 1
    drmFreeDevices(&local_devices[1], node_count - 1);
d3266 1
d3270 1
a3270 4
    for (i = 0; i < node_count; i++) {
        if (!local_devices[i])
            continue;

@


1.1.1.5
log
@Import libdrm 2.4.73
@
text
@d2867 1
a2867 1
    char data[512 + 1];
d2878 1
a2878 1
    data[sizeof(data)-1] = '\0';
d3152 1
a3183 2
    if (*device == NULL)
	return -ENODEV;
d3260 1
@


1.1.1.6
log
@Import libdrm 2.4.75
@
text
@a104 16
#ifdef __OpenBSD__
struct drm_pciinfo {
	uint16_t	domain;
	uint8_t		bus;
	uint8_t		dev;
	uint8_t		func;
	uint16_t	vendor_id;
	uint16_t	device_id;
	uint16_t	subvendor_id;
	uint16_t	subdevice_id;
	uint8_t		revision_id;
};

#define DRM_IOCTL_GET_PCIINFO	DRM_IOR(0x15, struct drm_pciinfo)
#endif

d2821 1
a2821 38
    struct stat sbuf;
    char buf[PATH_MAX + 1];
    const char *dev_name;
    unsigned int maj, min;
    int n, base;

    if (fstat(fd, &sbuf))
        return NULL;

    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);

    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
        return NULL;

    switch (type) {
    case DRM_NODE_PRIMARY:
        dev_name = DRM_DEV_NAME;
        break;
    case DRM_NODE_CONTROL:
        dev_name = DRM_CONTROL_DEV_NAME;
        break;
    case DRM_NODE_RENDER:
        dev_name = DRM_RENDER_DEV_NAME;
        break;
    default:
        return NULL;
    };

    base = drmGetMinorBase(type);
    if (base < 0)
        return NULL;

    n = snprintf(buf, sizeof(buf), dev_name, DRM_DIR_NAME, min - base);
    if (n == -1 || n >= sizeof(buf))
        return NULL;

    return strdup(buf);
a2835 44
#ifdef __linux__
static char * DRM_PRINTFLIKE(2, 3)
sysfs_uevent_get(const char *path, const char *fmt, ...)
{
    char filename[PATH_MAX + 1], *key, *line = NULL, *value = NULL;
    size_t size = 0, len;
    ssize_t num;
    va_list ap;
    FILE *fp;

    va_start(ap, fmt);
    num = vasprintf(&key, fmt, ap);
    va_end(ap);
    len = num;

    snprintf(filename, sizeof(filename), "%s/uevent", path);

    fp = fopen(filename, "r");
    if (!fp) {
        free(key);
        return NULL;
    }

    while ((num = getline(&line, &size, fp)) >= 0) {
        if ((strncmp(line, key, len) == 0) && (line[len] == '=')) {
            char *start = line + len + 1, *end = line + num - 1;

            if (*end != '\n')
                end++;

            value = strndup(start, end - start);
            break;
        }
    }

    free(line);
    fclose(fp);

    free(key);

    return value;
}
#endif

a2855 9
    if (strncmp(name, "/usb", 4) == 0)
        return DRM_BUS_USB;

    if (strncmp(name, "/platform", 9) == 0)
        return DRM_BUS_PLATFORM;

    if (strncmp(name, "/host1x", 7) == 0)
        return DRM_BUS_HOST1X;

a2856 2
#elif defined(__OpenBSD__)
    return DRM_BUS_PCI;
d2866 5
a2870 3
    unsigned int domain, bus, dev, func;
    char path[PATH_MAX + 1], *value;
    int num;
d2872 4
a2875 1
    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);
d2877 5
a2881 3
    value = sysfs_uevent_get(path, "PCI_SLOT_NAME");
    if (!value)
        return -ENOENT;
d2883 4
a2886 2
    num = sscanf(value, "%04x:%02x:%02x.%1u", &domain, &bus, &dev, &func);
    free(value);
d2888 2
a2889 1
    if (num != 4)
d2891 1
a2898 24
#elif defined(__OpenBSD__)
    struct drm_pciinfo pinfo;
    int fd, type;

    type = drmGetMinorType(min);
    if (type == -1)
        return -ENODEV;

    fd = drmOpenMinor(min, 0, type);
    if (fd < 0)
        return -errno;

    if (drmIoctl(fd, DRM_IOCTL_GET_PCIINFO, &pinfo)) {
        close(fd);
        return -errno;
    }
    close(fd);

    info->domain = pinfo.domain;
    info->bus = pinfo.bus;
    info->dev = pinfo.dev;
    info->func = pinfo.func;

    return 0;
a2915 10

    case DRM_BUS_USB:
        return memcmp(a->businfo.usb, b->businfo.usb, sizeof(drmUsbBusInfo));

    case DRM_BUS_PLATFORM:
        return memcmp(a->businfo.platform, b->businfo.platform, sizeof(drmPlatformBusInfo));

    case DRM_BUS_HOST1X:
        return memcmp(a->businfo.host1x, b->businfo.host1x, sizeof(drmHost1xBusInfo));

d2949 3
a2952 43
static int parse_separate_sysfs_files(int maj, int min,
                                      drmPciDeviceInfoPtr device,
                                      bool ignore_revision)
{
#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
    static const char *attrs[] = {
      "revision", /* Older kernels are missing the file, so check for it first */
      "vendor",
      "device",
      "subsystem_vendor",
      "subsystem_device",
    };
    char path[PATH_MAX + 1];
    unsigned int data[ARRAY_SIZE(attrs)];
    FILE *fp;
    int ret;

    for (unsigned i = ignore_revision ? 1 : 0; i < ARRAY_SIZE(attrs); i++) {
        snprintf(path, PATH_MAX, "/sys/dev/char/%d:%d/device/%s", maj, min,
                 attrs[i]);
        fp = fopen(path, "r");
        if (!fp)
            return -errno;

        ret = fscanf(fp, "%x", &data[i]);
        fclose(fp);
        if (ret != 1)
            return -errno;

    }

    device->revision_id = ignore_revision ? 0xff : data[0] & 0xff;
    device->vendor_id = data[1] & 0xffff;
    device->device_id = data[2] & 0xffff;
    device->subvendor_id = data[3] & 0xffff;
    device->subdevice_id = data[4] & 0xffff;

    return 0;
}

static int parse_config_sysfs_file(int maj, int min,
                                   drmPciDeviceInfoPtr device)
{
d2957 1
a2957 1
    snprintf(path, PATH_MAX, "/sys/dev/char/%d:%d/device/config", maj, min);
a2973 40
}
#endif

static int drmParsePciDeviceInfo(int maj, int min,
                                 drmPciDeviceInfoPtr device,
                                 uint32_t flags)
{
#ifdef __linux__
    if (!(flags & DRM_DEVICE_GET_PCI_REVISION))
        return parse_separate_sysfs_files(maj, min, device, true);

    if (parse_separate_sysfs_files(maj, min, device, false))
        return parse_config_sysfs_file(maj, min, device);

    return 0;
#elif defined(__OpenBSD__)
    struct drm_pciinfo pinfo;
    int fd, type;

    type = drmGetMinorType(min);
    if (type == -1)
        return -ENODEV;

    fd = drmOpenMinor(min, 0, type);
    if (fd < 0)
        return -errno;

    if (drmIoctl(fd, DRM_IOCTL_GET_PCIINFO, &pinfo)) {
        close(fd);
        return -errno;
    }
    close(fd);

    device->vendor_id = pinfo.vendor_id;
    device->device_id = pinfo.device_id;
    device->revision_id = pinfo.revision_id;
    device->subvendor_id = pinfo.subvendor_id;
    device->subdevice_id = pinfo.subdevice_id;

    return 0;
a2979 32
static void drmFreePlatformDevice(drmDevicePtr device)
{
    if (device->deviceinfo.platform) {
        if (device->deviceinfo.platform->compatible) {
            char **compatible = device->deviceinfo.platform->compatible;

            while (*compatible) {
                free(*compatible);
                compatible++;
            }

            free(device->deviceinfo.platform->compatible);
        }
    }
}

static void drmFreeHost1xDevice(drmDevicePtr device)
{
    if (device->deviceinfo.host1x) {
        if (device->deviceinfo.host1x->compatible) {
            char **compatible = device->deviceinfo.host1x->compatible;

            while (*compatible) {
                free(*compatible);
                compatible++;
            }

            free(device->deviceinfo.host1x->compatible);
        }
    }
}

a2984 12
    if (*device) {
        switch ((*device)->bustype) {
        case DRM_BUS_PLATFORM:
            drmFreePlatformDevice(*device);
            break;

        case DRM_BUS_HOST1X:
            drmFreeHost1xDevice(*device);
            break;
        }
    }

d3001 3
a3003 3
static drmDevicePtr drmDeviceAlloc(unsigned int type, const char *node,
                                   size_t bus_size, size_t device_size,
                                   char **ptrp)
d3005 3
a3007 4
    size_t max_node_length, extra, size;
    drmDevicePtr device;
    unsigned int i;
    char *ptr;
d3009 6
a3014 4
    max_node_length = ALIGN(drmGetMaxNodeName(), sizeof(void *));
    extra = DRM_NODE_MAX * (sizeof(void *) + max_node_length);

    size = sizeof(*device) + extra + bus_size + device_size;
d3016 1
a3016 5
    device = calloc(1, size);
    if (!device)
        return NULL;

    device->available_nodes = 1 << type;
d3018 2
a3019 2
    ptr = (char *)device + sizeof(*device);
    device->nodes = (char **)ptr;
d3021 2
a3022 1
    ptr += DRM_NODE_MAX * sizeof(void *);
d3024 1
d3026 2
a3027 2
        device->nodes[i] = ptr;
        ptr += max_node_length;
d3029 1
d3031 1
a3031 20
    memcpy(device->nodes[type], node, max_node_length);

    *ptrp = ptr;

    return device;
}

static int drmProcessPciDevice(drmDevicePtr *device,
                               const char *node, int node_type,
                               int maj, int min, bool fetch_deviceinfo,
                               uint32_t flags)
{
    drmDevicePtr dev;
    char *addr;
    int ret;

    dev = drmDeviceAlloc(node_type, node, sizeof(drmPciBusInfo),
                         sizeof(drmPciDeviceInfo), &addr);
    if (!dev)
        return -ENOMEM;
d3033 1
a3033 5
    dev->bustype = DRM_BUS_PCI;

    dev->businfo.pci = (drmPciBusInfoPtr)addr;

    ret = drmParsePciBusInfo(maj, min, dev->businfo.pci);
d3040 1
a3040 1
        dev->deviceinfo.pci = (drmPciDeviceInfoPtr)addr;
d3042 1
a3042 1
        ret = drmParsePciDeviceInfo(maj, min, dev->deviceinfo.pci, flags);
a3045 3

    *device = dev;

d3049 2
a3050 322
    free(dev);
    return ret;
}

static int drmParseUsbBusInfo(int maj, int min, drmUsbBusInfoPtr info)
{
#ifdef __linux__
    char path[PATH_MAX + 1], *value;
    unsigned int bus, dev;
    int ret;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    value = sysfs_uevent_get(path, "BUSNUM");
    if (!value)
        return -ENOENT;

    ret = sscanf(value, "%03u", &bus);
    free(value);

    if (ret <= 0)
        return -errno;

    value = sysfs_uevent_get(path, "DEVNUM");
    if (!value)
        return -ENOENT;

    ret = sscanf(value, "%03u", &dev);
    free(value);

    if (ret <= 0)
        return -errno;

    info->bus = bus;
    info->dev = dev;

    return 0;
#else
#warning "Missing implementation of drmParseUsbBusInfo"
    return -EINVAL;
#endif
}

static int drmParseUsbDeviceInfo(int maj, int min, drmUsbDeviceInfoPtr info)
{
#ifdef __linux__
    char path[PATH_MAX + 1], *value;
    unsigned int vendor, product;
    int ret;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    value = sysfs_uevent_get(path, "PRODUCT");
    if (!value)
        return -ENOENT;

    ret = sscanf(value, "%x/%x", &vendor, &product);
    free(value);

    if (ret <= 0)
        return -errno;

    info->vendor = vendor;
    info->product = product;

    return 0;
#else
#warning "Missing implementation of drmParseUsbDeviceInfo"
    return -EINVAL;
#endif
}

static int drmProcessUsbDevice(drmDevicePtr *device, const char *node,
                               int node_type, int maj, int min,
                               bool fetch_deviceinfo, uint32_t flags)
{
    drmDevicePtr dev;
    char *ptr;
    int ret;

    dev = drmDeviceAlloc(node_type, node, sizeof(drmUsbBusInfo),
                         sizeof(drmUsbDeviceInfo), &ptr);
    if (!dev)
        return -ENOMEM;

    dev->bustype = DRM_BUS_USB;

    dev->businfo.usb = (drmUsbBusInfoPtr)ptr;

    ret = drmParseUsbBusInfo(maj, min, dev->businfo.usb);
    if (ret < 0)
        goto free_device;

    if (fetch_deviceinfo) {
        ptr += sizeof(drmUsbBusInfo);
        dev->deviceinfo.usb = (drmUsbDeviceInfoPtr)ptr;

        ret = drmParseUsbDeviceInfo(maj, min, dev->deviceinfo.usb);
        if (ret < 0)
            goto free_device;
    }

    *device = dev;

    return 0;

free_device:
    free(dev);
    return ret;
}

static int drmParsePlatformBusInfo(int maj, int min, drmPlatformBusInfoPtr info)
{
#ifdef __linux__
    char path[PATH_MAX + 1], *name;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    name = sysfs_uevent_get(path, "OF_FULLNAME");
    if (!name)
        return -ENOENT;

    strncpy(info->fullname, name, DRM_PLATFORM_DEVICE_NAME_LEN);
    info->fullname[DRM_PLATFORM_DEVICE_NAME_LEN - 1] = '\0';
    free(name);

    return 0;
#else
#warning "Missing implementation of drmParsePlatformBusInfo"
    return -EINVAL;
#endif
}

static int drmParsePlatformDeviceInfo(int maj, int min,
                                      drmPlatformDeviceInfoPtr info)
{
#ifdef __linux__
    char path[PATH_MAX + 1], *value;
    unsigned int count, i;
    int err;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    value = sysfs_uevent_get(path, "OF_COMPATIBLE_N");
    if (!value)
        return -ENOENT;

    sscanf(value, "%u", &count);
    free(value);

    info->compatible = calloc(count + 1, sizeof(*info->compatible));
    if (!info->compatible)
        return -ENOMEM;

    for (i = 0; i < count; i++) {
        value = sysfs_uevent_get(path, "OF_COMPATIBLE_%u", i);
        if (!value) {
            err = -ENOENT;
            goto free;
        }

        info->compatible[i] = value;
    }

    return 0;

free:
    while (i--)
        free(info->compatible[i]);

    free(info->compatible);
    return err;
#else
#warning "Missing implementation of drmParsePlatformDeviceInfo"
    return -EINVAL;
#endif
}

static int drmProcessPlatformDevice(drmDevicePtr *device,
                                    const char *node, int node_type,
                                    int maj, int min, bool fetch_deviceinfo,
                                    uint32_t flags)
{
    drmDevicePtr dev;
    char *ptr;
    int ret;

    dev = drmDeviceAlloc(node_type, node, sizeof(drmPlatformBusInfo),
                         sizeof(drmPlatformDeviceInfo), &ptr);
    if (!dev)
        return -ENOMEM;

    dev->bustype = DRM_BUS_PLATFORM;

    dev->businfo.platform = (drmPlatformBusInfoPtr)ptr;

    ret = drmParsePlatformBusInfo(maj, min, dev->businfo.platform);
    if (ret < 0)
        goto free_device;

    if (fetch_deviceinfo) {
        ptr += sizeof(drmPlatformBusInfo);
        dev->deviceinfo.platform = (drmPlatformDeviceInfoPtr)ptr;

        ret = drmParsePlatformDeviceInfo(maj, min, dev->deviceinfo.platform);
        if (ret < 0)
            goto free_device;
    }

    *device = dev;

    return 0;

free_device:
    free(dev);
    return ret;
}

static int drmParseHost1xBusInfo(int maj, int min, drmHost1xBusInfoPtr info)
{
#ifdef __linux__
    char path[PATH_MAX + 1], *name;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    name = sysfs_uevent_get(path, "OF_FULLNAME");
    if (!name)
        return -ENOENT;

    strncpy(info->fullname, name, DRM_HOST1X_DEVICE_NAME_LEN);
    info->fullname[DRM_HOST1X_DEVICE_NAME_LEN - 1] = '\0';
    free(name);

    return 0;
#else
#warning "Missing implementation of drmParseHost1xBusInfo"
    return -EINVAL;
#endif
}

static int drmParseHost1xDeviceInfo(int maj, int min,
                                    drmHost1xDeviceInfoPtr info)
{
#ifdef __linux__
    char path[PATH_MAX + 1], *value;
    unsigned int count, i;
    int err;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d/device", maj, min);

    value = sysfs_uevent_get(path, "OF_COMPATIBLE_N");
    if (!value)
        return -ENOENT;

    sscanf(value, "%u", &count);
    free(value);

    info->compatible = calloc(count + 1, sizeof(*info->compatible));
    if (!info->compatible)
        return -ENOMEM;

    for (i = 0; i < count; i++) {
        value = sysfs_uevent_get(path, "OF_COMPATIBLE_%u", i);
        if (!value) {
            err = -ENOENT;
            goto free;
        }

        info->compatible[i] = value;
    }

    return 0;

free:
    while (i--)
        free(info->compatible[i]);

    free(info->compatible);
    return err;
#else
#warning "Missing implementation of drmParseHost1xDeviceInfo"
    return -EINVAL;
#endif
}

static int drmProcessHost1xDevice(drmDevicePtr *device,
                                  const char *node, int node_type,
                                  int maj, int min, bool fetch_deviceinfo,
                                  uint32_t flags)
{
    drmDevicePtr dev;
    char *ptr;
    int ret;

    dev = drmDeviceAlloc(node_type, node, sizeof(drmHost1xBusInfo),
                         sizeof(drmHost1xDeviceInfo), &ptr);
    if (!dev)
        return -ENOMEM;

    dev->bustype = DRM_BUS_HOST1X;

    dev->businfo.host1x = (drmHost1xBusInfoPtr)ptr;

    ret = drmParseHost1xBusInfo(maj, min, dev->businfo.host1x);
    if (ret < 0)
        goto free_device;

    if (fetch_deviceinfo) {
        ptr += sizeof(drmHost1xBusInfo);
        dev->deviceinfo.host1x = (drmHost1xDeviceInfoPtr)ptr;

        ret = drmParseHost1xDeviceInfo(maj, min, dev->deviceinfo.host1x);
        if (ret < 0)
            goto free_device;
    }

    *device = dev;

    return 0;

free_device:
    free(dev);
a3075 7
/* Check that the given flags are valid returning 0 on success */
static int
drm_device_validate_flags(uint32_t flags)
{
        return (flags & ~DRM_DEVICE_GET_PCI_REVISION);
}

a3079 1
 * \param flags feature/behaviour bitmask
a3083 3
 *
 * \note Unlike drmGetDevice it does not retrieve the pci device revision field
 * unless the DRM_DEVICE_GET_PCI_REVISION \p flag is set.
d3085 1
a3085 1
int drmGetDevice2(int fd, uint32_t flags, drmDevicePtr *device)
a3086 65
#ifdef __OpenBSD__
    /*
     * DRI device nodes on OpenBSD are not in their own directory, they reside
     * in /dev along with a large number of statically generated /dev nodes.
     * Avoid stat'ing all of /dev needlessly by implementing this custom path.
     */
    drmDevicePtr     d;
    struct stat      sbuf;
    char             node[PATH_MAX + 1];
    const char      *dev_name;
    int              node_type, subsystem_type;
    int              maj, min, n, ret, base;

    if (fd == -1 || device == NULL)
        return -EINVAL;

    if (fstat(fd, &sbuf))
        return -errno;

    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);

    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
        return -EINVAL;

    node_type = drmGetMinorType(min);
    if (node_type == -1)
        return -ENODEV;

    switch (node_type) {
    case DRM_NODE_PRIMARY:
        dev_name = DRM_DEV_NAME;
        break;
    case DRM_NODE_CONTROL:
        dev_name = DRM_CONTROL_DEV_NAME;
        break;
    case DRM_NODE_RENDER:
        dev_name = DRM_RENDER_DEV_NAME;
        break;
    default:
        return -EINVAL;
    };

    base = drmGetMinorBase(node_type);
    if (base < 0)
        return -EINVAL;

    n = snprintf(node, PATH_MAX, dev_name, DRM_DIR_NAME, min - base);
    if (n == -1 || n >= PATH_MAX)
      return -errno;
    if (stat(node, &sbuf))
        return -EINVAL;

    subsystem_type = drmParseSubsystemType(maj, min);
    if (subsystem_type != DRM_BUS_PCI)
        return -ENODEV;

    ret = drmProcessPciDevice(&d, node, node_type, maj, min, true, flags);
    if (ret)
        return ret;

    *device = d;

    return 0;
#else
a3098 3
    if (drm_device_validate_flags(flags))
        return -EINVAL;

d3145 2
a3146 1
            ret = drmProcessPciDevice(&d, node, node_type, maj, min, true, flags);
d3148 1
a3148 8
                continue;

            break;

        case DRM_BUS_USB:
            ret = drmProcessUsbDevice(&d, node, node_type, maj, min, true, flags);
            if (ret)
                continue;
a3150 15

        case DRM_BUS_PLATFORM:
            ret = drmProcessPlatformDevice(&d, node, node_type, maj, min, true, flags);
            if (ret)
                continue;

            break;

        case DRM_BUS_HOST1X:
            ret = drmProcessHost1xDevice(&d, node, node_type, maj, min, true, flags);
            if (ret)
                continue;

            break;

d3184 1
a3184 1
        return -ENODEV;
a3193 15
#endif
}

/**
 * Get information about the opened drm device
 *
 * \param fd file descriptor of the drm device
 * \param device the address of a drmDevicePtr where the information
 *               will be allocated in stored
 *
 * \return zero on success, negative error code otherwise.
 */
int drmGetDevice(int fd, drmDevicePtr *device)
{
    return drmGetDevice2(fd, DRM_DEVICE_GET_PCI_REVISION, device);
a3198 1
 * \param flags feature/behaviour bitmask
a3206 3
 *
 * \note Unlike drmGetDevices it does not retrieve the pci device revision field
 * unless the DRM_DEVICE_GET_PCI_REVISION \p flag is set.
d3208 1
a3208 1
int drmGetDevices2(uint32_t flags, drmDevicePtr devices[], int max_devices)
a3220 3
    if (drm_device_validate_flags(flags))
        return -EINVAL;

d3254 2
a3255 10
            ret = drmProcessPciDevice(&device, node, node_type,
                                      maj, min, devices != NULL, flags);
            if (ret)
                continue;

            break;

        case DRM_BUS_USB:
            ret = drmProcessUsbDevice(&device, node, node_type, maj, min,
                                      devices != NULL, flags);
a3259 17

        case DRM_BUS_PLATFORM:
            ret = drmProcessPlatformDevice(&device, node, node_type, maj, min,
                                           devices != NULL, flags);
            if (ret)
                goto free_devices;

            break;

        case DRM_BUS_HOST1X:
            ret = drmProcessHost1xDevice(&device, node, node_type, maj, min,
                                         devices != NULL, flags);
            if (ret)
                goto free_devices;

            break;

a3304 89
}

/**
 * Get drm devices on the system
 *
 * \param devices the array of devices with drmDevicePtr elements
 *                can be NULL to get the device number first
 * \param max_devices the maximum number of devices for the array
 *
 * \return on error - negative error code,
 *         if devices is NULL - total number of devices available on the system,
 *         alternatively the number of devices stored in devices[], which is
 *         capped by the max_devices.
 */
int drmGetDevices(drmDevicePtr devices[], int max_devices)
{
    return drmGetDevices2(DRM_DEVICE_GET_PCI_REVISION, devices, max_devices);
}

char *drmGetDeviceNameFromFd2(int fd)
{
#ifdef __linux__
    struct stat sbuf;
    char path[PATH_MAX + 1], *value;
    unsigned int maj, min;

    if (fstat(fd, &sbuf))
        return NULL;

    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);

    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
        return NULL;

    snprintf(path, sizeof(path), "/sys/dev/char/%d:%d", maj, min);

    value = sysfs_uevent_get(path, "DEVNAME");
    if (!value)
        return NULL;

    snprintf(path, sizeof(path), "/dev/%s", value);
    free(value);

    return strdup(path);
#else
    struct stat      sbuf;
    char             node[PATH_MAX + 1];
    const char      *dev_name;
    int              node_type;
    int              maj, min, n, base;

    if (fstat(fd, &sbuf))
        return NULL;

    maj = major(sbuf.st_rdev);
    min = minor(sbuf.st_rdev);

    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))
        return NULL;

    node_type = drmGetMinorType(min);
    if (node_type == -1)
        return NULL;

    switch (node_type) {
    case DRM_NODE_PRIMARY:
        dev_name = DRM_DEV_NAME;
        break;
    case DRM_NODE_CONTROL:
        dev_name = DRM_CONTROL_DEV_NAME;
        break;
    case DRM_NODE_RENDER:
        dev_name = DRM_RENDER_DEV_NAME;
        break;
    default:
        return NULL;
    };

    base = drmGetMinorBase(node_type);
    if (base < 0)
        return NULL;

    n = snprintf(node, PATH_MAX, dev_name, DRM_DIR_NAME, min - base);
    if (n == -1 || n >= PATH_MAX)
      return NULL;

    return strdup(node);
#endif
@


