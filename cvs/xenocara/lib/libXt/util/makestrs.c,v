head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.6
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.4
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.2
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.4.0.12
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_5:1.1.1.1
	v1_0_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.05.10.09.26.33;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	6TWFnavsUy316XnG;

1.4
date	2012.03.10.16.45.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.09.10.09.36.19;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.31.16.05.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.02.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.02.05;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to libXt 1.1.5
@
text
@/*

Copyright (c) 1991, 1998 The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/

/* Constructs string definitions */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

typedef struct _TableEnt {
    struct _TableEnt* next;
    char* left;
    char* right;
    int offset;
} TableEnt;

typedef struct _Table {
    struct _Table* next;
    TableEnt* tableent;
    TableEnt* tableentcurrent;
    TableEnt** tableenttail;
    char* name;
    int offset;
} Table;

typedef struct _File {
    struct _File* next;
    FILE* tmpl;
    char* name;
    Table* table;
    Table* tablecurrent;
    Table** tabletail;
} File;

static File* file = NULL;
static File* filecurrent = NULL;
static File** filetail = &file;
static char* conststr;
static char* prefixstr = NULL;
static char* featurestr = NULL;
static char* ctmplstr = NULL;
static char* fileprotstr;
static char* externrefstr;
static char* externdefstr;

#ifndef FALSE
# define FALSE 0
# define TRUE  !(FALSE)
#endif

static int   solaris_abi_names = FALSE;

#define X_DEFAULT_ABI	0
#define X_ARRAYPER_ABI	1
#define X_INTEL_ABI	2
#define X_INTEL_ABI_BC	3
#define X_SPARC_ABI	4
#define X_FUNCTION_ABI	5

#define X_MAGIC_STRING "<<<STRING_TABLE_GOES_HERE>>>"

/* Wrapper for fopen()
 * Prepend filename with an includedir which can be specified on the
 * commandline. Needed to separate source and build directories.
 */
static char* includedir = NULL;
static FILE *ifopen(const char *file, const char *mode)
{
#ifndef HAVE_ASPRINTF
    size_t len;
#endif
    char *buffer;
    FILE *ret;

    if (includedir == NULL)
        return fopen(file, mode);

#ifdef HAVE_ASPRINTF
    if (asprintf(&buffer, "%s/%s", includedir, file) == -1)
        return NULL;
#else
    len = strlen(file) + strlen(includedir) + 1;
    buffer = (char*)malloc(len + 1);
    if (buffer == NULL)
        return NULL;

    snprintf(buffer, len + 1, "%s/%s", includedir, file);
#endif

    ret = fopen(buffer, mode);

    free(buffer);
    return ret;
}

static void WriteHeaderProlog (FILE *f, File *phile)
{
    Table* t;
    TableEnt* te;

    (void) fprintf (f, "#ifdef %s\n", featurestr);
    for (t = phile->table; t; t = t->next)
	for (te = t->tableent; te; te = te->next) {
	    if (strcmp (te->left, "RAtom") == 0) {
		(void) fprintf (f,
			"#ifndef %s%s\n#define %s%s \"%s\"\n#endif\n",
			prefixstr, te->left, prefixstr, te->left, te->right);
	    } else {
		(void) fprintf (f,
			"#define %s%s \"%s\"\n",
			prefixstr, te->left, te->right);
	    }
	}
    (void) fprintf (f, "%s", "#else\n");
}

static void IntelABIWriteHeader (FILE *f, File *phile)
{
    Table* t;
    TableEnt* te;

    WriteHeaderProlog (f, phile);

    for (t = phile->table; t; t = t->next) {
      (void) fprintf (f, "%s %sConst char %s[];\n",
		      externrefstr, conststr ? conststr : fileprotstr, t->name);
	for (te = t->tableent; te; te = te->next)
	    (void) fprintf (f,
		"#ifndef %s%s\n#define %s%s ((char*)&%s[%d])\n#endif\n",
		prefixstr, te->left, prefixstr, te->left, t->name, te->offset);
    }

    (void) fprintf (f, "#endif /* %s */\n", featurestr);
}

static void SPARCABIWriteHeader (FILE *f, File *phile)
{
    Table* t;
    TableEnt* te;

    for (t = phile->table; t; t = t->next)
	for (te = t->tableent; te; te = te->next)
	    (void) fprintf (f, "#define %s%s \"%s\"\n",
			    prefixstr, te->left, te->right);
}

static void FunctionWriteHeader (FILE *f, File *phile)
{
    Table* t;
    TableEnt* te;

    WriteHeaderProlog (f, phile);

    (void) fprintf (f, "%s %sConst char* %s();\n",
		    externrefstr, conststr ? conststr : fileprotstr,
		    phile->table->name);

    for (t = phile->table; t; t = t->next)
	for (te = t->tableent; te; te = te->next)
	    (void) fprintf (f,
		"#ifndef %s%s\n#define %s%s (%s(%d))\n#endif\n",
		prefixstr, te->left, prefixstr, te->left, phile->table->name,
		te->offset);

    (void) fprintf (f, "#endif /* %s */\n", featurestr);
}

static void ArrayperWriteHeader (FILE *f, File *phile)
{
    Table* t;
    TableEnt* te;

    WriteHeaderProlog (f, phile);

    for (t = phile->table; t; t = t->next)
        for (te = t->tableent; te; te = te->next)
	    (void) fprintf (f,
			    "#ifndef %s%s\n%s %sConst char %s%s[];\n#endif\n",
			    prefixstr, te->left,
			    externrefstr, conststr ? conststr : fileprotstr,
			    prefixstr, te->left);

    (void) fprintf (f, "#endif /* %s */\n", featurestr);
}

static void DefaultWriteHeader (FILE *f, File *phile)
{
    Table* t;
    TableEnt* te;

    WriteHeaderProlog (f, phile);

    (void) fprintf (f, "%s %sConst char %s[];\n",
		    externrefstr, conststr ? conststr : fileprotstr,
		    phile->table->name);

    for (t = phile->table; t; t = t->next)
	for (te = t->tableent; te; te = te->next)
	    (void) fprintf (f,
		"#ifndef %s%s\n#define %s%s ((char*)&%s[%d])\n#endif\n",
		prefixstr, te->left, prefixstr, te->left, phile->table->name,
		te->offset);

    (void) fprintf (f, "#endif /* %s */\n", featurestr);
}

static void CopyTmplProlog (FILE *tmpl, FILE *f)
{
    char buf[1024];
    static const char* magic_string = X_MAGIC_STRING;
    int magic_string_len = strlen (magic_string);

    while (fgets (buf, sizeof buf, tmpl)) {
	if (strncmp (buf, magic_string, magic_string_len) == 0) {
	    return;
	}
	(void) fputs (buf, f);
    }
}

static void CopyTmplEpilog (FILE *tmpl, FILE *f)
{
    char buf[1024];

    while (fgets (buf, sizeof buf, tmpl))
	(void) fputs (buf, f);
}

static const char* abistring[] = {
    "Default", "Array per string", "Intel", "Intel BC", "SPARC", "Function" };

static void WriteHeader (char *tagline, File *phile, int abi)
{
    FILE* f;
    char* tmp;
    static void (*headerproc[])(FILE *f, File *phile) = {
	DefaultWriteHeader, ArrayperWriteHeader,
	IntelABIWriteHeader, IntelABIWriteHeader,
	SPARCABIWriteHeader, FunctionWriteHeader };

    if ((f = fopen (phile->name, "w+")) == NULL) exit (1);

    if (phile->tmpl) CopyTmplProlog (phile->tmpl, f);

    (void) fprintf (f,
	"%s\n%s\n/* %s ABI version -- Do not edit */\n",
	"/* $Xorg: makestrs.c,v 1.6 2001/02/09 02:03:17 xorgcvs Exp $ */",
	"/* This file is automatically generated. */",
	abistring[abi]);

    if (tagline) (void) fprintf (f, "/* %s */\n\n", tagline);

    /* do the right thing for Motif, i.e. avoid _XmXmStrDefs_h_ */
    if (strcmp (prefixstr, "Xm") == 0) {
#ifdef HAVE_ASPRINTF
	if (asprintf (&fileprotstr, "_%s_", phile->name) == -1)
	    exit (1);
#else
	if ((fileprotstr = malloc (strlen (phile->name) + 3)) == NULL)
	   exit (1);
	(void) sprintf (fileprotstr, "_%s_", phile->name);
#endif
    } else {
#ifdef HAVE_ASPRINTF
	if (asprintf (&fileprotstr, "_%s%s_", prefixstr, phile->name) == -1)
	    exit (1);
#else
	if ((fileprotstr = malloc (strlen (phile->name) + strlen (prefixstr) +  3)) == NULL)
	   exit (1);
	(void) sprintf (fileprotstr, "_%s%s_", prefixstr, phile->name);
#endif
    }

    for (tmp = fileprotstr; *tmp; tmp++) if (*tmp == '.') *tmp = '_';

    (*headerproc[abi])(f, phile);

    if (phile->tmpl) CopyTmplEpilog (phile->tmpl, f);

    (void) free (fileprotstr);
    (void) fclose (phile->tmpl);
    (void) fclose (f);
}

static void WriteSourceLine (TableEnt *te, int abi, int fudge)
{
    char* c;

    for (c = te->right; *c; c++) (void) printf ("'%c',", *c);
    (void) printf ("%c", '0');
    if (te->next || fudge) (void) printf ("%c", ',');
    (void) printf ("%s", "\n");
}

static const char* const_string = "%s %sConst char %s[] = {\n";

static void IntelABIWriteSource (int abi)
{
    File* phile;

    for (phile = file; phile; phile = phile->next) {
	Table* t;
	TableEnt* te;

	for (t = phile->table; t; t = t->next) {
	    (void) printf (const_string, externdefstr,
			   conststr ? conststr : "", t->name);
	    for (te = t->tableent; te; te = te->next)
		WriteSourceLine (te, abi, 0);
	    (void) printf ("%s\n\n", "};");
	}
    }
}

static void IntelABIBCWriteSource (int abi)
{
    File* phile;

    for (phile = file; phile; phile = phile->next) {
	Table* t;
	TableEnt* te;

	(void) printf (const_string, externdefstr,
		       conststr ? conststr : "", phile->table->name);

	for (t = phile->table; t; t = t->next)
	    for (te = t->tableent; te; te = te->next)
		WriteSourceLine (te, abi, t->next ? 1 : 0);
	(void) printf ("%s\n\n", "};");

	if (phile->table->next) {
	    (void) printf (const_string, externdefstr,
			   conststr ? conststr : "", phile->table->next->name);
	    for (t = phile->table->next; t; t = t->next)
		for (te = t->tableent; te; te = te->next)
		    WriteSourceLine (te, abi, 0);
	    (void) printf ("%s\n\n", "};");
	}
    }
}

static void FunctionWriteSource (int abi)
{
    File* phile;

    for (phile = file; phile; phile = phile->next) {
	Table* t;
	TableEnt* te;

	(void) printf ("static %sConst char _%s[] = {\n",
		       conststr ? conststr : "", phile->table->name);

	for (t = phile->table; t; t = t->next)
	    for (te = t->tableent; te; te = te->next)
		WriteSourceLine (te, abi, t->next ? 1 : 0);
	(void) printf ("%s\n\n", "};");

	(void) printf ("%sConst char* %s(index)\n    int index;\n{\n    return &_%s[index];\n}\n\n",
		       conststr ? conststr : "",
		       phile->table->name, phile->table->name);
    }
}

static void ArrayperWriteSource (int abi)
{
    File* phile;
    static int done_atom;

    for (phile = file; phile; phile = phile->next) {
	Table* t;
	TableEnt* te;

	for (t = phile->table; t; t = t->next)
	    for (te = t->tableent; te; te = te->next) {
		if (strcmp (te->left, "RAtom") == 0) {
		    if (done_atom) return;
		    done_atom = 1;
		}
		(void) printf ("%s %sConst char %s%s[] = \"%s\";\n",
			       externdefstr, conststr ? conststr : "",
			       prefixstr,
			       te->left, te->right);
	    }
    }
}

static void DefaultWriteSource (int abi)
{
    File* phile;

    for (phile = file; phile; phile = phile->next) {
	Table* t;
	TableEnt* te;

	(void) printf (const_string, externdefstr, conststr ? conststr : "",
		       phile->table->name);

	for (t = phile->table; t; t = t->next)
	    for (te = t->tableent; te; te = te->next)
		WriteSourceLine (te, abi, t->next ? 1 : 0);
	(void) printf ("%s\n\n", "};");
    }
}

static void WriteSource(char *tagline, int abi)
{
    static void (*sourceproc[])(int) = {
	DefaultWriteSource, ArrayperWriteSource,
	IntelABIWriteSource, IntelABIBCWriteSource,
	DefaultWriteSource, FunctionWriteSource };

    FILE* tmpl;

    if (ctmplstr) {
	tmpl = ifopen (ctmplstr, "r");

	if (tmpl) CopyTmplProlog (tmpl, stdout);
	else {
	    (void) fprintf (stderr, "Expected template %s, not found\n",
			    ctmplstr);
	    exit (1);
	}
    } else
	tmpl = NULL;


    (void) printf ("%s\n%s\n/* %s ABI version -- Do not edit */\n",
		   "/* $Xorg: makestrs.c,v 1.6 2001/02/09 02:03:17 xorgcvs Exp $ */",
		   "/* This file is automatically generated. */",
		   abistring[abi]);

    if (tagline) (void) printf ("/* %s */\n\n", tagline);

    (*sourceproc[abi])(abi);

    if (tmpl) CopyTmplEpilog (tmpl, stdout);
}

static void DoLine(char *buf)
{
#define X_NO_TOKEN 0
#define X_FILE_TOKEN 1
#define X_TABLE_TOKEN 2
#define X_PREFIX_TOKEN 3
#define X_FEATURE_TOKEN 4
#define X_EXTERNREF_TOKEN 5
#define X_EXTERNDEF_TOKEN 6
#define X_CTMPL_TOKEN 7
#define X_HTMPL_TOKEN 8
#define X_CONST_TOKEN 9

    int token;
    char lbuf[1024];
    static const char* file_str = "#file";
    static const char* table_str = "#table";
    static const char* prefix_str = "#prefix";
    static const char* feature_str = "#feature";
    static const char* externref_str = "#externref";
    static const char* externdef_str = "#externdef";
    static const char* ctmpl_str = "#ctmpl";
    static const char* htmpl_str = "#htmpl";
    static const char* const_str = "#const";

    if (strncmp (buf, file_str, strlen (file_str)) == 0)
	token = X_FILE_TOKEN;
    else if (strncmp (buf, table_str, strlen (table_str)) == 0)
	token = X_TABLE_TOKEN;
    else if (strncmp (buf, prefix_str, strlen (prefix_str)) == 0)
	token = X_PREFIX_TOKEN;
    else if (strncmp (buf, feature_str, strlen (feature_str)) == 0)
	token = X_FEATURE_TOKEN;
    else if (strncmp (buf, externref_str, strlen (externref_str)) == 0)
	token = X_EXTERNREF_TOKEN;
    else if (strncmp (buf, externdef_str, strlen (externdef_str)) == 0)
	token = X_EXTERNDEF_TOKEN;
    else if (strncmp (buf, ctmpl_str, strlen (ctmpl_str)) == 0)
	token = X_CTMPL_TOKEN;
    else if (strncmp (buf, htmpl_str, strlen (htmpl_str)) == 0)
	token = X_HTMPL_TOKEN;
    else if (strncmp (buf, const_str, strlen (const_str)) == 0)
	token = X_CONST_TOKEN;
    else
        token = X_NO_TOKEN;

    switch (token) {
    case X_FILE_TOKEN:
	{
	    File* phile;

	    if ((phile = (File*) malloc (sizeof(File))) == NULL)
		exit(1);
	    if ((phile->name = strdup (buf + strlen (file_str) + 1)) == NULL)
		exit(1);
	    phile->table = NULL;
	    phile->tablecurrent = NULL;
	    phile->tabletail = &phile->table;
	    phile->next = NULL;
	    phile->tmpl = NULL;

	    *filetail = phile;
	    filetail = &phile->next;
	    filecurrent = phile;
	}
	break;
    case X_TABLE_TOKEN:
	{
	    Table* table;
	    if ((table = (Table*) malloc (sizeof(Table))) == NULL)
		exit(1);
	    if ((table->name = strdup (buf + strlen (table_str) + 1)) == NULL)
		exit(1);
	    if (solaris_abi_names) {
		if (strcmp(table->name, "XtStringsR6") == 0) {
		    strcpy(table->name, "XtR6Strings");
		} else if (strcmp(table->name, "XtShellStringsR6") == 0) {
		    strcpy(table->name, "XtR6ShellStrings");
		}
	    }
	    table->tableent = NULL;
	    table->tableentcurrent = NULL;
	    table->tableenttail = &table->tableent;
	    table->next = NULL;
	    table->offset = 0;

	    *filecurrent->tabletail = table;
	    filecurrent->tabletail = &table->next;
	    filecurrent->tablecurrent = table;
	}
	break;
    case X_PREFIX_TOKEN:
	if ((prefixstr = strdup (buf + strlen (prefix_str) + 1)) == NULL)
	    exit(1);
	break;
    case X_FEATURE_TOKEN:
	if ((featurestr = strdup (buf + strlen (feature_str) + 1)) == NULL)
	    exit(1);
	break;
    case X_EXTERNREF_TOKEN:
	if ((externrefstr = strdup (buf + strlen (externref_str) + 1)) == NULL)
	    exit(1);
	break;
    case X_EXTERNDEF_TOKEN:
	if ((externdefstr = strdup (buf + strlen (externdef_str) + 1)) == NULL)
	    exit(1);
	break;
    case X_CTMPL_TOKEN:
	if ((ctmplstr = strdup (buf + strlen (ctmpl_str) + 1)) == NULL)
	    exit(1);
	break;
    case X_HTMPL_TOKEN:
	if ((filecurrent->tmpl = ifopen (buf + strlen (htmpl_str) + 1, "r")) == NULL) {
	    (void) fprintf (stderr,
			    "Expected template %s, not found\n", htmpl_str);
	    exit (1);
	}
	break;
    case X_CONST_TOKEN:
	if ((conststr = strdup (buf + strlen (const_str) + 1)) == NULL)
	    exit(1);
	break;
    default:
	{
	    char* right;
	    TableEnt* tableent;
	    int llen;
	    int rlen;
	    int len;

	    if ((right = strchr(buf, ' ')))
		*right++ = 0;
	    else
		right = buf + 1;
	    if (buf[0] == 'H') {
		snprintf (lbuf, sizeof(lbuf), "%s%s", prefixstr, right);
		right = lbuf;
	    }

	    llen = len = strlen(buf) + 1;
	    rlen = strlen(right) + 1;
	    if (right != buf + 1) len += rlen;
	    if ((tableent = (TableEnt*)malloc(sizeof(TableEnt) + len)) == NULL)
		exit(1);
	    tableent->left = (char *)(tableent + 1);
	    strcpy(tableent->left, buf);
	    if (llen != len) {
		tableent->right = tableent->left + llen;
		strcpy(tableent->right, right);
	    } else {
		tableent->right = tableent->left + 1;
	    }
	    tableent->next = NULL;

	    *filecurrent->tablecurrent->tableenttail = tableent;
	    filecurrent->tablecurrent->tableenttail = &tableent->next;
	    filecurrent->tablecurrent->tableentcurrent = tableent;
	}
	break;
    }
}

static void IntelABIIndexEntries (File *file)
{
    Table* t;
    TableEnt* te;

    for (t = file->table; t; t = t->next)
	for (te = t->tableent; te; te = te->next) {
	    te->offset = t->offset;
	    t->offset += strlen (te->right);
	    t->offset++;
    }
}

static void DefaultIndexEntries (File *file)
{
    Table* t;
    TableEnt* te;
    int offset = 0;

    for (t = file->table; t; t = t->next)
	for (te = t->tableent; te; te = te->next) {
	    te->offset = offset;
	    offset += strlen (te->right);
	    offset++;
    }
}

static void IndexEntries (File *file, int abi)
{
    switch (abi) {
    case X_SPARC_ABI:
	break;
    case X_INTEL_ABI:
    case X_INTEL_ABI_BC:
	IntelABIIndexEntries (file);
	break;
    default:
	DefaultIndexEntries (file);
	break;
    }
}

static char* DoComment (char *line)
{
    char* tag;
    char* eol;
    char* ret;
    int len;

    /* assume that the first line with two '$' in it is the RCS tag line */
    if ((tag = strchr (line, '$')) == NULL) return NULL;
    if ((eol = strchr (tag + 1, '$')) == NULL) return NULL;
    len = eol - tag;
    if ((ret = malloc (len)) == NULL)
	exit (1);
    (void) strncpy (ret, tag + 1, len - 1);
    ret[len - 2] = 0;
    return ret;
}

int main(int argc, char *argv[])
{
    int len, i;
    char* tagline = NULL;
    File* phile;
    FILE *f;
    char buf[1024];
    int abi =
#ifndef ARRAYPERSTR
	X_DEFAULT_ABI;
#else
	X_ARRAYPER_ABI;
#endif

    f = stdin;
    if (argc > 1) {
	for (i = 1; i < argc; i++) {
	    if (strcmp (argv[i], "-f") == 0) {
		if (++i < argc)
		    f = fopen (argv[i], "r");
		else
		    return 1;
	    }
	    if (strcmp (argv[i], "-i") == 0) {
		if (++i < argc)
		    includedir = argv[i];
		else
		    return 1;
	    }
	    if (strcmp (argv[i], "-sparcabi") == 0)
		abi = X_SPARC_ABI;
	    if (strcmp (argv[i], "-intelabi") == 0)
		abi = X_INTEL_ABI;
	    if (strcmp (argv[i], "-functionabi") == 0)
		abi = X_FUNCTION_ABI;
	    if (strcmp (argv[i], "-earlyR6bc") == 0 && abi == X_INTEL_ABI)
		abi = X_INTEL_ABI_BC;
	    if (strcmp (argv[i], "-arrayperabi") == 0)
		abi = X_ARRAYPER_ABI;
#ifdef ARRAYPERSTR
	    if (strcmp (argv[i], "-defaultabi") == 0)
		abi = X_DEFAULT_ABI;
#endif
	    if (strcmp (argv[i], "-solarisabinames") == 0)
		solaris_abi_names = TRUE;
	}
    }

    if (f == NULL) return 1;
    while (fgets(buf, sizeof buf, f)) {
	if (!buf[0] || buf[0] == '\n')
	    continue;
	if (buf[0] == '!') {
	    if (tagline) continue;
	    tagline = DoComment (buf);
	    continue;
	}
	if (buf[(len = strlen (buf) - 1)] == '\n') buf[len] = '\0';
	DoLine(buf);
    }
    for (phile = file; phile; phile = phile->next) {
	if (abi != X_ARRAYPER_ABI) IndexEntries (phile, abi);
	WriteHeader (tagline, phile, abi);
    }
    WriteSource(tagline, abi);
    return 0;
}

@


1.4
log
@Update to libXt 1.1.2
@
text
@d30 1
a30 1
#include <X11/Xos.h>
d93 1
d95 1
d102 4
d111 2
a112 3
    strcpy(buffer, includedir);
    strcat(buffer, "/");
    strcat(buffer, file);
d279 4
d286 1
d288 4
d295 1
d516 1
a516 1
	    if ((phile->name = malloc (strlen (buf + strlen (file_str)) + 1)) == NULL)
a517 1
	    (void) strcpy (phile->name, buf + strlen (file_str) + 1);
d534 1
a534 1
	    if ((table->name = malloc (strlen (buf + strlen (table_str)) + 1)) == NULL)
a535 1
	    (void) strcpy (table->name, buf + strlen (table_str) + 1);
d555 1
a555 1
	if ((prefixstr = malloc (strlen (buf + strlen (prefix_str)) + 1)) == NULL)
a556 1
	(void) strcpy (prefixstr, buf + strlen (prefix_str) + 1);
d559 1
a559 1
	if ((featurestr = malloc (strlen (buf + strlen (feature_str)) + 1)) == NULL)
a560 1
	(void) strcpy (featurestr, buf + strlen (feature_str) + 1);
d563 1
a563 1
	if ((externrefstr = malloc (strlen (buf + strlen (externref_str)) + 1)) == NULL)
a564 1
	(void) strcpy (externrefstr, buf + strlen (externref_str) + 1);
d567 1
a567 1
	if ((externdefstr = malloc (strlen (buf + strlen (externdef_str)) + 1)) == NULL)
a568 1
	(void) strcpy (externdefstr, buf + strlen (externdef_str) + 1);
d571 1
a571 1
	if ((ctmplstr = malloc (strlen (buf + strlen (ctmpl_str)) + 1)) == NULL)
a572 1
	(void) strcpy (ctmplstr, buf + strlen (ctmpl_str) + 1);
d582 1
a582 1
	if ((conststr = malloc (strlen (buf + strlen (const_str)) + 1)) == NULL)
a583 1
	(void) strcpy (conststr, buf + strlen (const_str) + 1);
d593 1
a593 1
	    if ((right = index(buf, ' ')))
d598 1
a598 2
		strcpy (lbuf, prefixstr);
		strcat (lbuf, right);
d675 2
a676 2
    if ((tag = index (line, '$')) == NULL) return NULL;
    if ((eol = index (tag + 1, '$')) == NULL) return NULL;
@


1.3
log
@Update to libXt 1.1.1
@
text
@d87 1
a87 1
 * Prepend filename with an includedir which can be specified on the 
d96 1
a96 1
    
d104 1
a104 1
            
d124 1
a124 1
		(void) fprintf (f, 
d128 1
a128 1
		(void) fprintf (f, 
d144 1
a144 1
      (void) fprintf (f, "%s %sConst char %s[];\n", 
d147 1
a147 1
	    (void) fprintf (f, 
d173 2
a174 2
    (void) fprintf (f, "%s %sConst char* %s();\n", 
		    externrefstr, conststr ? conststr : fileprotstr, 
d179 1
a179 1
	    (void) fprintf (f, 
d181 1
a181 1
		prefixstr, te->left, prefixstr, te->left, phile->table->name, 
d196 1
a196 1
	    (void) fprintf (f, 
d198 2
a199 2
			    prefixstr, te->left, 
			    externrefstr, conststr ? conststr : fileprotstr, 
d212 2
a213 2
    (void) fprintf (f, "%s %sConst char %s[];\n", 
		    externrefstr, conststr ? conststr : fileprotstr, 
d218 1
a218 1
	    (void) fprintf (f, 
d220 1
a220 1
		prefixstr, te->left, prefixstr, te->left, phile->table->name, 
d229 1
a229 1
    static char* magic_string = X_MAGIC_STRING;
d248 1
a248 1
static char* abistring[] = {
d255 1
a255 1
    static void (*headerproc[])(FILE *f, File *phile) = { 
d264 2
a265 2
    (void) fprintf (f, 
	"%s\n%s\n/* %s ABI version -- Do not edit */\n", 
d304 1
a304 1
static char* const_string = "%s %sConst char %s[] = {\n";
d315 1
a315 1
	    (void) printf (const_string, externdefstr, 
d332 1
a332 1
	(void) printf (const_string, externdefstr, 
d335 1
a335 1
	for (t = phile->table; t; t = t->next) 
d341 1
a341 1
	    (void) printf (const_string, externdefstr, 
d343 1
a343 1
	    for (t = phile->table->next; t; t = t->next) 
d359 1
a359 1
	(void) printf ("static %sConst char _%s[] = {\n", 
d362 1
a362 1
	for (t = phile->table; t; t = t->next) 
d368 1
a368 1
		       conststr ? conststr : "", 
d382 1
a382 1
	for (t = phile->table; t; t = t->next) 
d390 1
a390 1
			       prefixstr, 
d407 1
a407 1
	for (t = phile->table; t; t = t->next) 
d416 1
a416 1
    static void (*sourceproc[])(int) = { 
d436 1
a436 1
    (void) printf ("%s\n%s\n/* %s ABI version -- Do not edit */\n", 
d463 9
a471 9
    static char* file_str = "#file";
    static char* table_str = "#table";
    static char* prefix_str = "#prefix";
    static char* feature_str = "#feature";
    static char* externref_str = "#externref";
    static char* externdef_str = "#externdef";
    static char* ctmpl_str = "#ctmpl";
    static char* htmpl_str = "#htmpl";
    static char* const_str = "#const";
d473 1
a473 1
    if (strncmp (buf, file_str, strlen (file_str)) == 0) 
d475 1
a475 1
    else if (strncmp (buf, table_str, strlen (table_str)) == 0) 
d477 1
a477 1
    else if (strncmp (buf, prefix_str, strlen (prefix_str)) == 0) 
d479 1
a479 1
    else if (strncmp (buf, feature_str, strlen (feature_str)) == 0) 
d481 1
a481 1
    else if (strncmp (buf, externref_str, strlen (externref_str)) == 0) 
d483 1
a483 1
    else if (strncmp (buf, externdef_str, strlen (externdef_str)) == 0) 
d485 1
a485 1
    else if (strncmp (buf, ctmpl_str, strlen (ctmpl_str)) == 0) 
d487 1
a487 1
    else if (strncmp (buf, htmpl_str, strlen (htmpl_str)) == 0) 
d489 1
a489 1
    else if (strncmp (buf, const_str, strlen (const_str)) == 0) 
d499 1
a499 1
	    if ((phile = (File*) malloc (sizeof(File))) == NULL) 
d501 1
a501 1
	    if ((phile->name = malloc (strlen (buf + strlen (file_str)) + 1)) == NULL) 
d518 1
a518 1
	    if ((table = (Table*) malloc (sizeof(Table))) == NULL) 
d520 1
a520 1
	    if ((table->name = malloc (strlen (buf + strlen (table_str)) + 1)) == NULL) 
d542 1
a542 1
	if ((prefixstr = malloc (strlen (buf + strlen (prefix_str)) + 1)) == NULL) 
d547 1
a547 1
	if ((featurestr = malloc (strlen (buf + strlen (feature_str)) + 1)) == NULL) 
d552 1
a552 1
	if ((externrefstr = malloc (strlen (buf + strlen (externref_str)) + 1)) == NULL) 
d557 1
a557 1
	if ((externdefstr = malloc (strlen (buf + strlen (externdef_str)) + 1)) == NULL) 
d562 1
a562 1
	if ((ctmplstr = malloc (strlen (buf + strlen (ctmpl_str)) + 1)) == NULL) 
d568 1
a568 1
	    (void) fprintf (stderr, 
d686 1
a686 1
    int abi = 
d729 1
a729 1
	if (!buf[0] || buf[0] == '\n') 
@


1.2
log
@Update to libXt 1.0.9.  No functional change.
@
text
@a32 3
#if defined(macII) && !defined(__STDC__)  /* stdlib.h fails to define these */
char *malloc();
#endif /* macII */
@


1.1
log
@Initial revision
@
text
@a0 2
/* $XdotOrg: $ */

a25 1
/* $XFree86: xc/config/util/makestrs.c,v 3.6 2001/07/25 15:04:41 dawes Exp $ */
@


1.1.1.1
log
@import from X.Org 7.2RC2
@
text
@@
