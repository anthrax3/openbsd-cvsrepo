head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.8
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.6
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.4
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.2
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.4.0.12
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.05.10.09.32.36;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	7gFeKDQguFagRHxv;

1.4
date	2012.03.10.17.16.24;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.31.16.50.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.04.27.19.54.37;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.24.49;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.24.49;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@update to libxkbfile 1.0.9
@
text
@/************************************************************
 Copyright (c) 1996 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be
 used in advertising or publicity pertaining to distribution
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.

 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#elif defined(HAVE_CONFIG_H)
#include <config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#define X_INCLUDE_STRING_H
#define XOS_USE_NO_LOCKING
#include <X11/Xos_r.h>


#include <X11/Xproto.h>
#include <X11/Xlib.h>
#include <X11/Xos.h>
#include <X11/Xfuncs.h>
#include <X11/Xatom.h>
#include <X11/keysym.h>
#include <X11/XKBlib.h>
#include <X11/extensions/XKBgeom.h>
#include "XKMformat.h"
#include "XKBfileInt.h"
#include "XKBrules.h"


#ifdef DEBUG
#define PR_DEBUG(s)		fprintf(stderr,s)
#define PR_DEBUG1(s,a)		fprintf(stderr,s,a)
#define PR_DEBUG2(s,a,b)	fprintf(stderr,s,a,b)
#else
#define PR_DEBUG(s)
#define PR_DEBUG1(s,a)
#define PR_DEBUG2(s,a,b)
#endif

/***====================================================================***/

#define DFLT_LINE_SIZE	128

typedef struct {
    int         line_num;
    int         sz_line;
    int         num_line;
    char        buf[DFLT_LINE_SIZE];
    char *      line;
} InputLine;

static void
InitInputLine(InputLine *line)
{
    line->line_num = 1;
    line->num_line = 0;
    line->sz_line = DFLT_LINE_SIZE;
    line->line = line->buf;
    return;
}

static void
FreeInputLine(InputLine *line)
{
    if (line->line != line->buf)
        _XkbFree(line->line);
    line->line_num = 1;
    line->num_line = 0;
    line->sz_line = DFLT_LINE_SIZE;
    line->line = line->buf;
    return;
}

static int
InputLineAddChar(InputLine *line, int ch)
{
    if (line->num_line >= line->sz_line) {
        if (line->line == line->buf) {
            line->line = (char *) _XkbAlloc(line->sz_line * 2);
            memcpy(line->line, line->buf, line->sz_line);
        }
        else {
            line->line =
                (char *) _XkbRealloc((char *) line->line, line->sz_line * 2);
        }
        line->sz_line *= 2;
    }
    line->line[line->num_line++] = ch;
    return ch;
}

#define	ADD_CHAR(l,c)	((l)->num_line<(l)->sz_line?\
				(int)((l)->line[(l)->num_line++]= (c)):\
				InputLineAddChar(l,c))

#ifdef HAVE_UNLOCKED_STDIO
#undef getc
#define getc(x) getc_unlocked(x)
#else
#define flockfile(x) do {} while (0)
#define funlockfile(x) do {} while (0)
#endif

static Bool
GetInputLine(FILE *file, InputLine *line, Bool checkbang)
{
    int ch;
    Bool endOfFile, spacePending, slashPending, inComment;

    endOfFile = False;
    flockfile(file);
    while ((!endOfFile) && (line->num_line == 0)) {
        spacePending = slashPending = inComment = False;
        while (((ch = getc(file)) != '\n') && (ch != EOF)) {
            if (ch == '\\') {
                if ((ch = getc(file)) == EOF)
                    break;
                if (ch == '\n') {
                    inComment = False;
                    ch = ' ';
                    line->line_num++;
                }
            }
            if (inComment)
                continue;
            if (ch == '/') {
                if (slashPending) {
                    inComment = True;
                    slashPending = False;
                }
                else {
                    slashPending = True;
                }
                continue;
            }
            else if (slashPending) {
                if (spacePending) {
                    ADD_CHAR(line, ' ');
                    spacePending = False;
                }
                ADD_CHAR(line, '/');
                slashPending = False;
            }
            if (isspace(ch)) {
                while (isspace(ch) && (ch != '\n') && (ch != EOF)) {
                    ch = getc(file);
                }
                if (ch == EOF)
                    break;
                if ((ch != '\n') && (line->num_line > 0))
                    spacePending = True;
                ungetc(ch, file);
            }
            else {
                if (spacePending) {
                    ADD_CHAR(line, ' ');
                    spacePending = False;
                }
                if (checkbang && ch == '!') {
                    if (line->num_line != 0) {
                        PR_DEBUG("The '!' legal only at start of line\n");
                        PR_DEBUG("Line containing '!' ignored\n");
                        line->num_line = 0;
                        inComment = 0;
                        break;
                    }

                }
                ADD_CHAR(line, ch);
            }
        }
        if (ch == EOF)
            endOfFile = True;
/*	else line->num_line++;*/
    }
    funlockfile(file);
    if ((line->num_line == 0) && (endOfFile))
        return False;
    ADD_CHAR(line, '\0');
    return True;
}

/***====================================================================***/

#define	MODEL		0
#define	LAYOUT		1
#define	VARIANT		2
#define	OPTION		3
#define	KEYCODES	4
#define SYMBOLS		5
#define	TYPES		6
#define	COMPAT		7
#define	GEOMETRY	8
#define	KEYMAP		9
#define	MAX_WORDS	10

#define	PART_MASK	0x000F
#define	COMPONENT_MASK	0x03F0

static const char *cname[MAX_WORDS] = {
    "model", "layout", "variant", "option",
    "keycodes", "symbols", "types", "compat", "geometry", "keymap"
};

typedef struct _RemapSpec {
    int number;
    int num_remap;
    struct {
        int word;
        int index;
    } remap[MAX_WORDS];
} RemapSpec;

typedef struct _FileSpec {
    char *name[MAX_WORDS];
    struct _FileSpec *pending;
} FileSpec;

typedef struct {
    char *model;
    char *layout[XkbNumKbdGroups + 1];
    char *variant[XkbNumKbdGroups + 1];
    char *options;
} XkbRF_MultiDefsRec, *XkbRF_MultiDefsPtr;

#define NDX_BUFF_SIZE	4

/***====================================================================***/

static char *
get_index(char *str, int *ndx)
{
    char ndx_buf[NDX_BUFF_SIZE];

    char *end;

    if (*str != '[') {
        *ndx = 0;
        return str;
    }
    str++;
    end = strchr(str, ']');
    if (end == NULL) {
        *ndx = -1;
        return str - 1;
    }
    if ((end - str) >= NDX_BUFF_SIZE) {
        *ndx = -1;
        return end + 1;
    }
    strncpy(ndx_buf, str, end - str);
    ndx_buf[end - str] = '\0';
    *ndx = atoi(ndx_buf);
    return end + 1;
}

static void
SetUpRemap(InputLine *line, RemapSpec *remap)
{
    char *tok, *str;
    unsigned present, l_ndx_present, v_ndx_present;
    register int i;
    int len, ndx;
    _Xstrtokparams strtok_buf;

#ifdef DEBUG
    Bool found;
#endif

    l_ndx_present = v_ndx_present = present = 0;
    str = &line->line[1];
    len = remap->number;
    bzero((char *) remap, sizeof(RemapSpec));
    remap->number = len;
    while ((tok = _XStrtok(str, " ", strtok_buf)) != NULL) {
#ifdef DEBUG
        found = False;
#endif
        str = NULL;
        if (strcmp(tok, "=") == 0)
            continue;
        for (i = 0; i < MAX_WORDS; i++) {
            len = strlen(cname[i]);
            if (strncmp(cname[i], tok, len) == 0) {
                if (strlen(tok) > len) {
                    char *end = get_index(tok + len, &ndx);

                    if ((i != LAYOUT && i != VARIANT) ||
                        *end != '\0' || ndx == -1)
                        break;
                    if (ndx < 1 || ndx > XkbNumKbdGroups) {
                        PR_DEBUG2("Illegal %s index: %d\n", cname[i], ndx);
                        PR_DEBUG1("Index must be in range 1..%d\n",
                                  XkbNumKbdGroups);
                        break;
                    }
                }
                else {
                    ndx = 0;
                }
#ifdef DEBUG
                found = True;
#endif
                if (present & (1 << i)) {
                    if ((i == LAYOUT && l_ndx_present & (1 << ndx)) ||
                        (i == VARIANT && v_ndx_present & (1 << ndx))) {
                        PR_DEBUG1("Component \"%s\" listed twice\n", tok);
                        PR_DEBUG("Second definition ignored\n");
                        break;
                    }
                }
                present |= (1 << i);
                if (i == LAYOUT)
                    l_ndx_present |= 1 << ndx;
                if (i == VARIANT)
                    v_ndx_present |= 1 << ndx;
                remap->remap[remap->num_remap].word = i;
                remap->remap[remap->num_remap++].index = ndx;
                break;
            }
        }
#ifdef DEBUG
        if (!found) {
            fprintf(stderr, "Unknown component \"%s\" ignored\n", tok);
        }
#endif
    }
    if ((present & PART_MASK) == 0) {
#ifdef DEBUG
        unsigned mask = PART_MASK;

        fprintf(stderr, "Mapping needs at least one of ");
        for (i = 0; (i < MAX_WORDS); i++) {
            if ((1L << i) & mask) {
                mask &= ~(1L << i);
                if (mask)
                    fprintf(stderr, "\"%s,\" ", cname[i]);
                else
                    fprintf(stderr, "or \"%s\"\n", cname[i]);
            }
        }
        fprintf(stderr, "Illegal mapping ignored\n");
#endif
        remap->num_remap = 0;
        return;
    }
    if ((present & COMPONENT_MASK) == 0) {
        PR_DEBUG("Mapping needs at least one component\n");
        PR_DEBUG("Illegal mapping ignored\n");
        remap->num_remap = 0;
        return;
    }
    if (((present & COMPONENT_MASK) & (1 << KEYMAP)) &&
        ((present & COMPONENT_MASK) != (1 << KEYMAP))) {
        PR_DEBUG("Keymap cannot appear with other components\n");
        PR_DEBUG("Illegal mapping ignored\n");
        remap->num_remap = 0;
        return;
    }
    remap->number++;
    return;
}

static Bool
MatchOneOf(char *wanted, char *vals_defined)
{
    char *str, *next;
    int want_len = strlen(wanted);

    for (str = vals_defined, next = NULL; str != NULL; str = next) {
        int len;

        next = strchr(str, ',');
        if (next) {
            len = next - str;
            next++;
        }
        else {
            len = strlen(str);
        }
        if ((len == want_len) && (strncmp(wanted, str, len) == 0))
            return True;
    }
    return False;
}

/***====================================================================***/

static Bool
CheckLine(InputLine *    line,
          RemapSpec *    remap,
          XkbRF_RulePtr  rule,
          XkbRF_GroupPtr group)
{
    char *str, *tok;
    register int nread, i;
    FileSpec tmp;
    _Xstrtokparams strtok_buf;
    Bool append = False;

    if (line->line[0] == '!') {
        if (line->line[1] == '$' ||
            (line->line[1] == ' ' && line->line[2] == '$')) {
            char *gname = strchr(line->line, '$');
            char *words = strchr(gname, ' ');

            if (!words)
                return False;
            *words++ = '\0';
            for (; *words; words++) {
                if (*words != '=' && *words != ' ')
                    break;
            }
            if (*words == '\0')
                return False;
            group->name = _XkbDupString(gname);
            group->words = _XkbDupString(words);
            for (i = 1, words = group->words; *words; words++) {
                if (*words == ' ') {
                    *words++ = '\0';
                    i++;
                }
            }
            group->number = i;
            return True;
        }
        else {
            SetUpRemap(line, remap);
            return False;
        }
    }

    if (remap->num_remap == 0) {
        PR_DEBUG("Must have a mapping before first line of data\n");
        PR_DEBUG("Illegal line of data ignored\n");
        return False;
    }
    bzero((char *) &tmp, sizeof(FileSpec));
    str = line->line;
    for (nread = 0; (tok = _XStrtok(str, " ", strtok_buf)) != NULL; nread++) {
        str = NULL;
        if (strcmp(tok, "=") == 0) {
            nread--;
            continue;
        }
        if (nread > remap->num_remap) {
            PR_DEBUG("Too many words on a line\n");
            PR_DEBUG1("Extra word \"%s\" ignored\n", tok);
            continue;
        }
        tmp.name[remap->remap[nread].word] = tok;
        if (*tok == '+' || *tok == '|')
            append = True;
    }
    if (nread < remap->num_remap) {
        PR_DEBUG1("Too few words on a line: %s\n", line->line);
        PR_DEBUG("line ignored\n");
        return False;
    }

    rule->flags = 0;
    rule->number = remap->number;
    if (tmp.name[OPTION])
        rule->flags |= XkbRF_Option;
    else if (append)
        rule->flags |= XkbRF_Append;
    else
        rule->flags |= XkbRF_Normal;
    rule->model = _XkbDupString(tmp.name[MODEL]);
    rule->layout = _XkbDupString(tmp.name[LAYOUT]);
    rule->variant = _XkbDupString(tmp.name[VARIANT]);
    rule->option = _XkbDupString(tmp.name[OPTION]);

    rule->keycodes = _XkbDupString(tmp.name[KEYCODES]);
    rule->symbols = _XkbDupString(tmp.name[SYMBOLS]);
    rule->types = _XkbDupString(tmp.name[TYPES]);
    rule->compat = _XkbDupString(tmp.name[COMPAT]);
    rule->geometry = _XkbDupString(tmp.name[GEOMETRY]);
    rule->keymap = _XkbDupString(tmp.name[KEYMAP]);

    rule->layout_num = rule->variant_num = 0;
    for (i = 0; i < nread; i++) {
        if (remap->remap[i].index) {
            if (remap->remap[i].word == LAYOUT)
                rule->layout_num = remap->remap[i].index;
            if (remap->remap[i].word == VARIANT)
                rule->variant_num = remap->remap[i].index;
        }
    }
    return True;
}

static char *
_Concat(char *str1, char *str2)
{
    int len;

    if ((!str1) || (!str2))
        return str1;
    len = strlen(str1) + strlen(str2) + 1;
    str1 = _XkbTypedRealloc(str1, len, char);
    if (str1)
        strcat(str1, str2);
    return str1;
}

static void
squeeze_spaces(char *p1)
{
    char *p2;

    for (p2 = p1; *p2; p2++) {
        *p1 = *p2;
        if (*p1 != ' ')
            p1++;
    }
    *p1 = '\0';
}

static Bool
MakeMultiDefs(XkbRF_MultiDefsPtr mdefs, XkbRF_VarDefsPtr defs)
{

    bzero((char *) mdefs, sizeof(XkbRF_MultiDefsRec));
    mdefs->model = defs->model;
    mdefs->options = _XkbDupString(defs->options);
    if (mdefs->options)
        squeeze_spaces(mdefs->options);

    if (defs->layout) {
        if (!strchr(defs->layout, ',')) {
            mdefs->layout[0] = defs->layout;
        }
        else {
            char *p;

            int i;

            mdefs->layout[1] = _XkbDupString(defs->layout);
            if (mdefs->layout[1] == NULL)
                return False;
            squeeze_spaces(mdefs->layout[1]);
            p = mdefs->layout[1];
            for (i = 2; i <= XkbNumKbdGroups; i++) {
                if ((p = strchr(p, ','))) {
                    *p++ = '\0';
                    mdefs->layout[i] = p;
                }
                else {
                    break;
                }
            }
            if (p && (p = strchr(p, ',')))
                *p = '\0';
        }
    }

    if (defs->variant) {
        if (!strchr(defs->variant, ',')) {
            mdefs->variant[0] = defs->variant;
        }
        else {
            char *p;

            int i;

            mdefs->variant[1] = _XkbDupString(defs->variant);
            if (mdefs->variant[1] == NULL)
                return False;
            squeeze_spaces(mdefs->variant[1]);
            p = mdefs->variant[1];
            for (i = 2; i <= XkbNumKbdGroups; i++) {
                if ((p = strchr(p, ','))) {
                    *p++ = '\0';
                    mdefs->variant[i] = p;
                }
                else {
                    break;
                }
            }
            if (p && (p = strchr(p, ',')))
                *p = '\0';
        }
    }
    return True;
}

static void
FreeMultiDefs(XkbRF_MultiDefsPtr defs)
{
    if (defs->options)
        _XkbFree(defs->options);
    if (defs->layout[1])
        _XkbFree(defs->layout[1]);
    if (defs->variant[1])
        _XkbFree(defs->variant[1]);
}

static void
Apply(char *src, char **dst)
{
    if (src) {
        if (*src == '+' || *src == '!') {
            *dst = _Concat(*dst, src);
        }
        else {
            if (*dst == NULL)
                *dst = _XkbDupString(src);
        }
    }
}

static void
XkbRF_ApplyRule(XkbRF_RulePtr rule, XkbComponentNamesPtr names)
{
    rule->flags &= ~XkbRF_PendingMatch; /* clear the flag because it's applied */

    Apply(rule->keycodes, &names->keycodes);
    Apply(rule->symbols,  &names->symbols);
    Apply(rule->types,    &names->types);
    Apply(rule->compat,   &names->compat);
    Apply(rule->geometry, &names->geometry);
    Apply(rule->keymap,   &names->keymap);
}

static Bool
CheckGroup(XkbRF_RulesPtr rules, char *group_name, char *name)
{
    int i;
    char *p;
    XkbRF_GroupPtr group;

    for (i = 0, group = rules->groups; i < rules->num_groups; i++, group++) {
        if (!strcmp(group->name, group_name)) {
            break;
        }
    }
    if (i == rules->num_groups)
        return False;
    for (i = 0, p = group->words; i < group->number; i++, p += strlen(p) + 1) {
        if (!strcmp(p, name)) {
            return True;
        }
    }
    return False;
}

static int
XkbRF_CheckApplyRule(XkbRF_RulePtr        rule,
                     XkbRF_MultiDefsPtr   mdefs,
                     XkbComponentNamesPtr names,
                     XkbRF_RulesPtr       rules)
{
    Bool pending = False;

    if (rule->model != NULL) {
        if (mdefs->model == NULL)
            return 0;
        if (strcmp(rule->model, "*") == 0) {
            pending = True;
        }
        else {
            if (rule->model[0] == '$') {
                if (!CheckGroup(rules, rule->model, mdefs->model))
                    return 0;
            }
            else {
                if (strcmp(rule->model, mdefs->model) != 0)
                    return 0;
            }
        }
    }
    if (rule->option != NULL) {
        if (mdefs->options == NULL)
            return 0;
        if ((!MatchOneOf(rule->option, mdefs->options)))
            return 0;
    }

    if (rule->layout != NULL) {
        if (mdefs->layout[rule->layout_num] == NULL ||
            *mdefs->layout[rule->layout_num] == '\0')
            return 0;
        if (strcmp(rule->layout, "*") == 0) {
            pending = True;
        }
        else {
            if (rule->layout[0] == '$') {
                if (!CheckGroup(rules, rule->layout,
                                mdefs->layout[rule->layout_num]))
                    return 0;
            }
            else {
                if (strcmp(rule->layout, mdefs->layout[rule->layout_num]) != 0)
                    return 0;
            }
        }
    }
    if (rule->variant != NULL) {
        if (mdefs->variant[rule->variant_num] == NULL ||
            *mdefs->variant[rule->variant_num] == '\0')
            return 0;
        if (strcmp(rule->variant, "*") == 0) {
            pending = True;
        }
        else {
            if (rule->variant[0] == '$') {
                if (!CheckGroup(rules, rule->variant,
                                mdefs->variant[rule->variant_num]))
                    return 0;
            }
            else {
                if (strcmp(rule->variant,
                           mdefs->variant[rule->variant_num]) != 0)
                    return 0;
            }
        }
    }
    if (pending) {
        rule->flags |= XkbRF_PendingMatch;
        return rule->number;
    }
    /* exact match, apply it now */
    XkbRF_ApplyRule(rule, names);
    return rule->number;
}

static void
XkbRF_ClearPartialMatches(XkbRF_RulesPtr rules)
{
    register int i;
    XkbRF_RulePtr rule;

    for (i = 0, rule = rules->rules; i < rules->num_rules; i++, rule++) {
        rule->flags &= ~XkbRF_PendingMatch;
    }
}

static void
XkbRF_ApplyPartialMatches(XkbRF_RulesPtr rules, XkbComponentNamesPtr names)
{
    int i;
    XkbRF_RulePtr rule;

    for (rule = rules->rules, i = 0; i < rules->num_rules; i++, rule++) {
        if ((rule->flags & XkbRF_PendingMatch) == 0)
            continue;
        XkbRF_ApplyRule(rule, names);
    }
}

static void
XkbRF_CheckApplyRules(XkbRF_RulesPtr       rules,
                      XkbRF_MultiDefsPtr   mdefs,
                      XkbComponentNamesPtr names,
                      int                  flags)
{
    int i;
    XkbRF_RulePtr rule;
    int skip;

    for (rule = rules->rules, i = 0; i < rules->num_rules; rule++, i++) {
        if ((rule->flags & flags) != flags)
            continue;
        skip = XkbRF_CheckApplyRule(rule, mdefs, names, rules);
        if (skip && !(flags & XkbRF_Option)) {
            for (; (i < rules->num_rules) && (rule->number == skip);
                 rule++, i++);
            rule--;
            i--;
        }
    }
}

/***====================================================================***/

static char *
XkbRF_SubstituteVars(char *name, XkbRF_MultiDefsPtr mdefs)
{
    char *str, *outstr, *orig, *var;
    int len, ndx;

    orig = name;
    str = index(name, '%');
    if (str == NULL)
        return name;
    len = strlen(name);
    while (str != NULL) {
        char pfx = str[1];
        int extra_len = 0;

        if ((pfx == '+') || (pfx == '|') || (pfx == '_') || (pfx == '-')) {
            extra_len = 1;
            str++;
        }
        else if (pfx == '(') {
            extra_len = 2;
            str++;
        }
        var = str + 1;
        str = get_index(var + 1, &ndx);
        if (ndx == -1) {
            str = index(str, '%');
            continue;
        }
        if ((*var == 'l') && mdefs->layout[ndx] && *mdefs->layout[ndx])
            len += strlen(mdefs->layout[ndx]) + extra_len;
        else if ((*var == 'm') && mdefs->model)
            len += strlen(mdefs->model) + extra_len;
        else if ((*var == 'v') && mdefs->variant[ndx] && *mdefs->variant[ndx])
            len += strlen(mdefs->variant[ndx]) + extra_len;
        if ((pfx == '(') && (*str == ')')) {
            str++;
        }
        str = index(&str[0], '%');
    }
    name = (char *) _XkbAlloc(len + 1);
    str = orig;
    outstr = name;
    while (*str != '\0') {
        if (str[0] == '%') {
            char pfx, sfx;

            str++;
            pfx = str[0];
            sfx = '\0';
            if ((pfx == '+') || (pfx == '|') || (pfx == '_') || (pfx == '-')) {
                str++;
            }
            else if (pfx == '(') {
                sfx = ')';
                str++;
            }
            else
                pfx = '\0';

            var = str;
            str = get_index(var + 1, &ndx);
            if (ndx == -1) {
                continue;
            }
            if ((*var == 'l') && mdefs->layout[ndx] && *mdefs->layout[ndx]) {
                if (pfx)
                    *outstr++ = pfx;
                strcpy(outstr, mdefs->layout[ndx]);
                outstr += strlen(mdefs->layout[ndx]);
                if (sfx)
                    *outstr++ = sfx;
            }
            else if ((*var == 'm') && (mdefs->model)) {
                if (pfx)
                    *outstr++ = pfx;
                strcpy(outstr, mdefs->model);
                outstr += strlen(mdefs->model);
                if (sfx)
                    *outstr++ = sfx;
            }
            else if ((*var == 'v') && mdefs->variant[ndx] &&
                     *mdefs->variant[ndx]) {
                if (pfx)
                    *outstr++ = pfx;
                strcpy(outstr, mdefs->variant[ndx]);
                outstr += strlen(mdefs->variant[ndx]);
                if (sfx)
                    *outstr++ = sfx;
            }
            if ((pfx == '(') && (*str == ')'))
                str++;
        }
        else {
            *outstr++ = *str++;
        }
    }
    *outstr++ = '\0';
    if (orig != name)
        _XkbFree(orig);
    return name;
}

/***====================================================================***/

Bool
XkbRF_GetComponents(XkbRF_RulesPtr       rules,
                    XkbRF_VarDefsPtr     defs,
                    XkbComponentNamesPtr names)
{
    XkbRF_MultiDefsRec mdefs;

    MakeMultiDefs(&mdefs, defs);

    bzero((char *) names, sizeof(XkbComponentNamesRec));
    XkbRF_ClearPartialMatches(rules);
    XkbRF_CheckApplyRules(rules, &mdefs, names, XkbRF_Normal);
    XkbRF_ApplyPartialMatches(rules, names);
    XkbRF_CheckApplyRules(rules, &mdefs, names, XkbRF_Append);
    XkbRF_ApplyPartialMatches(rules, names);
    XkbRF_CheckApplyRules(rules, &mdefs, names, XkbRF_Option);
    XkbRF_ApplyPartialMatches(rules, names);

    if (names->keycodes)
        names->keycodes = XkbRF_SubstituteVars(names->keycodes, &mdefs);
    if (names->symbols)
        names->symbols  = XkbRF_SubstituteVars(names->symbols, &mdefs);
    if (names->types)
        names->types    = XkbRF_SubstituteVars(names->types, &mdefs);
    if (names->compat)
        names->compat   = XkbRF_SubstituteVars(names->compat, &mdefs);
    if (names->geometry)
        names->geometry = XkbRF_SubstituteVars(names->geometry, &mdefs);
    if (names->keymap)
        names->keymap   = XkbRF_SubstituteVars(names->keymap, &mdefs);

    FreeMultiDefs(&mdefs);
    return (names->keycodes && names->symbols && names->types &&
            names->compat && names->geometry) || names->keymap;
}

XkbRF_RulePtr
XkbRF_AddRule(XkbRF_RulesPtr rules)
{
    if (rules->sz_rules < 1) {
        rules->sz_rules = 16;
        rules->num_rules = 0;
        rules->rules = _XkbTypedCalloc(rules->sz_rules, XkbRF_RuleRec);
    }
    else if (rules->num_rules >= rules->sz_rules) {
        rules->sz_rules *= 2;
        rules->rules = _XkbTypedRealloc(rules->rules, rules->sz_rules,
                                        XkbRF_RuleRec);
    }
    if (!rules->rules) {
        rules->sz_rules = rules->num_rules = 0;
#ifdef DEBUG
        fprintf(stderr, "Allocation failure in XkbRF_AddRule\n");
#endif
        return NULL;
    }
    bzero((char *) &rules->rules[rules->num_rules], sizeof(XkbRF_RuleRec));
    return &rules->rules[rules->num_rules++];
}

XkbRF_GroupPtr
XkbRF_AddGroup(XkbRF_RulesPtr rules)
{
    if (rules->sz_groups < 1) {
        rules->sz_groups = 16;
        rules->num_groups = 0;
        rules->groups = _XkbTypedCalloc(rules->sz_groups, XkbRF_GroupRec);
    }
    else if (rules->num_groups >= rules->sz_groups) {
        rules->sz_groups *= 2;
        rules->groups = _XkbTypedRealloc(rules->groups, rules->sz_groups,
                                         XkbRF_GroupRec);
    }
    if (!rules->groups) {
        rules->sz_groups = rules->num_groups = 0;
        return NULL;
    }

    bzero((char *) &rules->groups[rules->num_groups], sizeof(XkbRF_GroupRec));
    return &rules->groups[rules->num_groups++];
}

Bool
XkbRF_LoadRules(FILE *file, XkbRF_RulesPtr rules)
{
    InputLine line;
    RemapSpec remap;
    XkbRF_RuleRec trule, *rule;
    XkbRF_GroupRec tgroup, *group;

    if (!(rules && file))
        return False;
    bzero((char *) &remap, sizeof(RemapSpec));
    bzero((char *) &tgroup, sizeof(XkbRF_GroupRec));
    InitInputLine(&line);
    while (GetInputLine(file, &line, True)) {
        if (CheckLine(&line, &remap, &trule, &tgroup)) {
            if (tgroup.number) {
                if ((group = XkbRF_AddGroup(rules)) != NULL) {
                    *group = tgroup;
                    bzero((char *) &tgroup, sizeof(XkbRF_GroupRec));
                }
            }
            else {
                if ((rule = XkbRF_AddRule(rules)) != NULL) {
                    *rule = trule;
                    bzero((char *) &trule, sizeof(XkbRF_RuleRec));
                }
            }
        }
        line.num_line = 0;
    }
    FreeInputLine(&line);
    return True;
}

Bool
XkbRF_LoadRulesByName(char *base, char *locale, XkbRF_RulesPtr rules)
{
    FILE *file;
    char buf[PATH_MAX];
    Bool ok;

    if ((!base) || (!rules))
        return False;
    if (locale) {
        if (strlen(base) + strlen(locale) + 2 > PATH_MAX)
            return False;
        snprintf(buf, sizeof(buf), "%s-%s", base, locale);
    }
    else {
        if (strlen(base) + 1 > PATH_MAX)
            return False;
        strcpy(buf, base);
    }

    file = fopen(buf, "r");
    if ((!file) && (locale)) {  /* fallback if locale was specified */
        strcpy(buf, base);
        file = fopen(buf, "r");
    }
    if (!file)
        return False;
    ok = XkbRF_LoadRules(file, rules);
    fclose(file);
    return ok;
}

/***====================================================================***/

#define HEAD_NONE	0
#define HEAD_MODEL	1
#define HEAD_LAYOUT	2
#define HEAD_VARIANT	3
#define HEAD_OPTION	4
#define	HEAD_EXTRA	5

XkbRF_VarDescPtr
XkbRF_AddVarDesc(XkbRF_DescribeVarsPtr vars)
{
    if (vars->sz_desc < 1) {
        vars->sz_desc = 16;
        vars->num_desc = 0;
        vars->desc = _XkbTypedCalloc(vars->sz_desc, XkbRF_VarDescRec);
    }
    else if (vars->num_desc >= vars->sz_desc) {
        vars->sz_desc *= 2;
        vars->desc =
            _XkbTypedRealloc(vars->desc, vars->sz_desc, XkbRF_VarDescRec);
    }
    if (!vars->desc) {
        vars->sz_desc = vars->num_desc = 0;
        PR_DEBUG("Allocation failure in XkbRF_AddVarDesc\n");
        return NULL;
    }
    vars->desc[vars->num_desc].name = NULL;
    vars->desc[vars->num_desc].desc = NULL;
    return &vars->desc[vars->num_desc++];
}

XkbRF_VarDescPtr
XkbRF_AddVarDescCopy(XkbRF_DescribeVarsPtr vars, XkbRF_VarDescPtr from)
{
    XkbRF_VarDescPtr nd;

    if ((nd = XkbRF_AddVarDesc(vars)) != NULL) {
        nd->name = _XkbDupString(from->name);
        nd->desc = _XkbDupString(from->desc);
    }
    return nd;
}

XkbRF_DescribeVarsPtr
XkbRF_AddVarToDescribe(XkbRF_RulesPtr rules, char *name)
{
    if (rules->sz_extra < 1) {
        rules->num_extra = 0;
        rules->sz_extra = 1;
        rules->extra_names = _XkbTypedCalloc(rules->sz_extra, char *);

        rules->extra = _XkbTypedCalloc(rules->sz_extra, XkbRF_DescribeVarsRec);
    }
    else if (rules->num_extra >= rules->sz_extra) {
        rules->sz_extra *= 2;
        rules->extra_names =
            _XkbTypedRealloc(rules->extra_names, rules->sz_extra, char *);
        rules->extra =
            _XkbTypedRealloc(rules->extra, rules->sz_extra,
                             XkbRF_DescribeVarsRec);
    }
    if ((!rules->extra_names) || (!rules->extra)) {
        PR_DEBUG("allocation error in extra parts\n");
        rules->sz_extra = rules->num_extra = 0;
        rules->extra_names = NULL;
        rules->extra = NULL;
        return NULL;
    }
    rules->extra_names[rules->num_extra] = _XkbDupString(name);
    bzero(&rules->extra[rules->num_extra], sizeof(XkbRF_DescribeVarsRec));
    return &rules->extra[rules->num_extra++];
}

Bool
XkbRF_LoadDescriptions(FILE *file, XkbRF_RulesPtr rules)
{
    InputLine line;
    XkbRF_VarDescRec tmp;
    char *tok;
    int len, headingtype, extra_ndx = 0;

    bzero((char *) &tmp, sizeof(XkbRF_VarDescRec));
    headingtype = HEAD_NONE;
    InitInputLine(&line);
    for (; GetInputLine(file, &line, False); line.num_line = 0) {
        if (line.line[0] == '!') {
            tok = strtok(&(line.line[1]), " \t");
            if (strcmp(tok, "model") == 0)
                headingtype = HEAD_MODEL;
            else if (_XkbStrCaseCmp(tok, "layout") == 0)
                headingtype = HEAD_LAYOUT;
            else if (_XkbStrCaseCmp(tok, "variant") == 0)
                headingtype = HEAD_VARIANT;
            else if (_XkbStrCaseCmp(tok, "option") == 0)
                headingtype = HEAD_OPTION;
            else {
                int i;

                headingtype = HEAD_EXTRA;
                extra_ndx = -1;
                for (i = 0; (i < rules->num_extra) && (extra_ndx < 0); i++) {
                    if (_XkbStrCaseCmp(tok, rules->extra_names[i]))
                        extra_ndx = i;
                }
                if (extra_ndx < 0) {
                    XkbRF_DescribeVarsPtr var;

                    PR_DEBUG1("Extra heading \"%s\" encountered\n", tok);
                    var = XkbRF_AddVarToDescribe(rules, tok);
                    if (var)
                        extra_ndx = var - rules->extra;
                    else
                        headingtype = HEAD_NONE;
                }
            }
            continue;
        }

        if (headingtype == HEAD_NONE) {
            PR_DEBUG("Must have a heading before first line of data\n");
            PR_DEBUG("Illegal line of data ignored\n");
            continue;
        }

        len = strlen(line.line);
        if ((tmp.name = strtok(line.line, " \t")) == NULL) {
            PR_DEBUG("Huh? No token on line\n");
            PR_DEBUG("Illegal line of data ignored\n");
            continue;
        }
        if (strlen(tmp.name) == len) {
            PR_DEBUG("No description found\n");
            PR_DEBUG("Illegal line of data ignored\n");
            continue;
        }

        tok = line.line + strlen(tmp.name) + 1;
        while ((*tok != '\n') && isspace(*tok))
            tok++;
        if (*tok == '\0') {
            PR_DEBUG("No description found\n");
            PR_DEBUG("Illegal line of data ignored\n");
            continue;
        }
        tmp.desc = tok;
        switch (headingtype) {
        case HEAD_MODEL:
            XkbRF_AddVarDescCopy(&rules->models, &tmp);
            break;
        case HEAD_LAYOUT:
            XkbRF_AddVarDescCopy(&rules->layouts, &tmp);
            break;
        case HEAD_VARIANT:
            XkbRF_AddVarDescCopy(&rules->variants, &tmp);
            break;
        case HEAD_OPTION:
            XkbRF_AddVarDescCopy(&rules->options, &tmp);
            break;
        case HEAD_EXTRA:
            XkbRF_AddVarDescCopy(&rules->extra[extra_ndx], &tmp);
            break;
        }
    }
    FreeInputLine(&line);
    if ((rules->models.num_desc == 0) && (rules->layouts.num_desc == 0) &&
        (rules->variants.num_desc == 0) && (rules->options.num_desc == 0) &&
        (rules->num_extra == 0)) {
        return False;
    }
    return True;
}

Bool
XkbRF_LoadDescriptionsByName(char *base, char *locale, XkbRF_RulesPtr rules)
{
    FILE *file;
    char buf[PATH_MAX];
    Bool ok;

    if ((!base) || (!rules))
        return False;
    if (locale) {
        if (strlen(base) + strlen(locale) + 6 > PATH_MAX)
            return False;
        snprintf(buf, sizeof(buf), "%s-%s.lst", base, locale);
    }
    else {
        if (strlen(base) + 5 > PATH_MAX)
            return False;
        snprintf(buf, sizeof(buf), "%s.lst", base);
    }

    file = fopen(buf, "r");
    if ((!file) && (locale)) {  /* fallback if locale was specified */
        snprintf(buf, sizeof(buf), "%s.lst", base);

        file = fopen(buf, "r");
    }
    if (!file)
        return False;
    ok = XkbRF_LoadDescriptions(file, rules);
    fclose(file);
    return ok;
}

/***====================================================================***/

XkbRF_RulesPtr
XkbRF_Load(char *base, char *locale, Bool wantDesc, Bool wantRules)
{
    XkbRF_RulesPtr rules;

    if ((!base) || ((!wantDesc) && (!wantRules)))
        return NULL;
    if ((rules = _XkbTypedCalloc(1, XkbRF_RulesRec)) == NULL)
        return NULL;
    if (wantDesc && (!XkbRF_LoadDescriptionsByName(base, locale, rules))) {
        XkbRF_Free(rules, True);
        return NULL;
    }
    if (wantRules && (!XkbRF_LoadRulesByName(base, locale, rules))) {
        XkbRF_Free(rules, True);
        return NULL;
    }
    return rules;
}

XkbRF_RulesPtr
XkbRF_Create(int szRules, int szExtra)
{
    XkbRF_RulesPtr rules;

    if ((rules = _XkbTypedCalloc(1, XkbRF_RulesRec)) == NULL)
        return NULL;
    if (szRules > 0) {
        rules->sz_rules = szRules;
        rules->rules = _XkbTypedCalloc(rules->sz_rules, XkbRF_RuleRec);
        if (!rules->rules) {
            _XkbFree(rules);
            return NULL;
        }
    }
    if (szExtra > 0) {
        rules->sz_extra = szExtra;
        rules->extra = _XkbTypedCalloc(rules->sz_extra, XkbRF_DescribeVarsRec);
        if (!rules->extra) {
            if (rules->rules)
                _XkbFree(rules->rules);
            _XkbFree(rules);
            return NULL;
        }
    }
    return rules;
}

/***====================================================================***/

static void
XkbRF_ClearVarDescriptions(XkbRF_DescribeVarsPtr var)
{
    register int i;

    for (i = 0; i < var->num_desc; i++) {
        if (var->desc[i].name)
            _XkbFree(var->desc[i].name);
        if (var->desc[i].desc)
            _XkbFree(var->desc[i].desc);
        var->desc[i].name = var->desc[i].desc = NULL;
    }
    if (var->desc)
        _XkbFree(var->desc);
    var->desc = NULL;
    return;
}

void
XkbRF_Free(XkbRF_RulesPtr rules, Bool freeRules)
{
    int i;
    XkbRF_RulePtr rule;
    XkbRF_GroupPtr group;

    if (!rules)
        return;
    XkbRF_ClearVarDescriptions(&rules->models);
    XkbRF_ClearVarDescriptions(&rules->layouts);
    XkbRF_ClearVarDescriptions(&rules->variants);
    XkbRF_ClearVarDescriptions(&rules->options);
    if (rules->extra) {
        for (i = 0; i < rules->num_extra; i++) {
            XkbRF_ClearVarDescriptions(&rules->extra[i]);
        }
        _XkbFree(rules->extra);
        rules->num_extra = rules->sz_extra = 0;
        rules->extra = NULL;
    }
    if (rules->rules) {
        for (i = 0, rule = rules->rules; i < rules->num_rules; i++, rule++) {
            if (rule->model)
                _XkbFree(rule->model);
            if (rule->layout)
                _XkbFree(rule->layout);
            if (rule->variant)
                _XkbFree(rule->variant);
            if (rule->option)
                _XkbFree(rule->option);
            if (rule->keycodes)
                _XkbFree(rule->keycodes);
            if (rule->symbols)
                _XkbFree(rule->symbols);
            if (rule->types)
                _XkbFree(rule->types);
            if (rule->compat)
                _XkbFree(rule->compat);
            if (rule->geometry)
                _XkbFree(rule->geometry);
            if (rule->keymap)
                _XkbFree(rule->keymap);
            bzero((char *) rule, sizeof(XkbRF_RuleRec));
        }
        _XkbFree(rules->rules);
        rules->num_rules = rules->sz_rules = 0;
        rules->rules = NULL;
    }

    if (rules->groups) {
        for (i = 0, group = rules->groups; i < rules->num_groups; i++, group++) {
            if (group->name)
                _XkbFree(group->name);
            if (group->words)
                _XkbFree(group->words);
        }
        _XkbFree(rules->groups);
        rules->num_groups = 0;
        rules->groups = NULL;
    }
    if (freeRules)
        _XkbFree(rules);
    return;
}


Bool
XkbRF_GetNamesProp(Display * dpy, char **rf_rtrn, XkbRF_VarDefsPtr vd_rtrn)
{
    Atom rules_atom, actual_type;
    int fmt;
    unsigned long nitems, bytes_after;
    unsigned char *data;
    char *out, *end;
    Status rtrn;

    rules_atom = XInternAtom(dpy, _XKB_RF_NAMES_PROP_ATOM, True);
    if (rules_atom == None)     /* property cannot exist */
        return False;
    rtrn = XGetWindowProperty(dpy, DefaultRootWindow(dpy), rules_atom,
                              0L, _XKB_RF_NAMES_PROP_MAXLEN, False,
                              XA_STRING, &actual_type,
                              &fmt, &nitems, &bytes_after,
                              (unsigned char **) &data);
    if (rtrn != Success)
        return False;
    if (rf_rtrn)
        *rf_rtrn = NULL;
    (void) bzero((char *) vd_rtrn, sizeof(XkbRF_VarDefsRec));
    if ((bytes_after > 0) || (actual_type != XA_STRING) || (fmt != 8)) {
        if (data)
            XFree(data);
        return (fmt == 0 ? True : False);
    }

    out = (char *) data;
    end = out + nitems;
    if (out && (*out) && rf_rtrn)
        *rf_rtrn = _XkbDupString(out);
    out += strlen(out) + 1;

    if (out < end) {
        if (*out)
            vd_rtrn->model = _XkbDupString(out);
        out += strlen(out) + 1;
    }

    if (out < end) {
        if (*out)
            vd_rtrn->layout = _XkbDupString(out);
        out += strlen(out) + 1;
    }

    if (out < end) {
        if (*out)
            vd_rtrn->variant = _XkbDupString(out);
        out += strlen(out) + 1;
    }

    if (out < end) {
        if (*out)
            vd_rtrn->options = _XkbDupString(out);
        out += strlen(out) + 1;
    }

    XFree(data);
    return True;
}

Bool
XkbRF_SetNamesProp(Display *dpy, char *rules_file, XkbRF_VarDefsPtr var_defs)
{
    int len, out;
    Atom name;
    char *pval;

    len = (rules_file ? strlen(rules_file) : 0);
    len += (var_defs->model ? strlen(var_defs->model) : 0);
    len += (var_defs->layout ? strlen(var_defs->layout) : 0);
    len += (var_defs->variant ? strlen(var_defs->variant) : 0);
    len += (var_defs->options ? strlen(var_defs->options) : 0);
    if (len < 1)
        return True;

    len += 5;                   /* trailing NULs */

    name = XInternAtom(dpy, _XKB_RF_NAMES_PROP_ATOM, False);
    if (name == None) {         /* should never happen */
        _XkbLibError(_XkbErrXReqFailure, "XkbRF_SetNamesProp", X_InternAtom);
        return False;
    }
    pval = (char *) _XkbAlloc(len);
    if (!pval) {
        _XkbLibError(_XkbErrBadAlloc, "XkbRF_SetNamesProp", len);
        return False;
    }
    out = 0;
    if (rules_file) {
        strcpy(&pval[out], rules_file);
        out += strlen(rules_file);
    }
    pval[out++] = '\0';
    if (var_defs->model) {
        strcpy(&pval[out], var_defs->model);
        out += strlen(var_defs->model);
    }
    pval[out++] = '\0';
    if (var_defs->layout) {
        strcpy(&pval[out], var_defs->layout);
        out += strlen(var_defs->layout);
    }
    pval[out++] = '\0';
    if (var_defs->variant) {
        strcpy(&pval[out], var_defs->variant);
        out += strlen(var_defs->variant);
    }
    pval[out++] = '\0';
    if (var_defs->options) {
        strcpy(&pval[out], var_defs->options);
        out += strlen(var_defs->options);
    }
    pval[out++] = '\0';
    if (out != len) {
        _XkbLibError(_XkbErrBadLength, "XkbRF_SetNamesProp", out);
        _XkbFree(pval);
        return False;
    }

    XChangeProperty(dpy, DefaultRootWindow(dpy), name, XA_STRING, 8,
                    PropModeReplace, (unsigned char *) pval, len);
    _XkbFree(pval);
    return True;
}

@


1.4
log
@Update to libxkbfile 1.0.8
@
text
@a40 1
#ifndef XKB_IN_SERVER
a53 16
#else

#include <X11/Xproto.h>
#include <X11/X.h>
#include <X11/Xos.h>
#include <X11/Xfuncs.h>
#include <X11/Xatom.h>
#include <X11/keysym.h>
#include "misc.h"
#include "inputstr.h"
#include "dix.h"
#include <X11/extensions/XKBstr.h>
#define XKBSRV_NEED_FILE_FUNCS
#include <X11/extensions/XKBsrv.h>

#endif
d70 5
a74 5
	int	line_num;
	int	sz_line;
	int	num_line;
	char	buf[DFLT_LINE_SIZE];
	char *	line;
d80 4
a83 4
    line->line_num= 1;
    line->num_line= 0;
    line->sz_line= DFLT_LINE_SIZE;
    line->line=	line->buf;
d90 6
a95 6
    if (line->line!=line->buf)
	_XkbFree(line->line);
    line->line_num= 1;
    line->num_line= 0;
    line->sz_line= DFLT_LINE_SIZE;
    line->line= line->buf;
d100 1
a100 1
InputLineAddChar(InputLine *line,int ch)
d102 10
a111 9
    if (line->num_line>=line->sz_line) {
	if (line->line==line->buf) {
	    line->line= (char *)_XkbAlloc(line->sz_line*2);
	    memcpy(line->line,line->buf,line->sz_line);
	}
	else {
	    line->line=(char *)_XkbRealloc((char *)line->line,line->sz_line*2);
	}
	line->sz_line*= 2;
d113 1
a113 1
    line->line[line->num_line++]= ch;
d130 1
a130 1
GetInputLine(FILE *file,InputLine *line,Bool checkbang)
d132 60
a191 2
int	ch;
Bool	endOfFile,spacePending,slashPending,inComment;
d193 6
a198 64
     endOfFile= False;
     flockfile(file);
     while ((!endOfFile)&&(line->num_line==0)) {
	spacePending= slashPending= inComment= False;
	while (((ch=getc(file))!='\n')&&(ch!=EOF)) {
	    if (ch=='\\') {
		if ((ch=getc(file))==EOF)
		    break;
		if (ch=='\n') {
		    inComment= False;
		    ch= ' ';
		    line->line_num++;
		}
	    }
	    if (inComment)
		continue;
	    if (ch=='/') {
		if (slashPending) {
		    inComment= True;
		    slashPending= False;
		}
		else {
		    slashPending= True;
		}
		continue;
	    }
	    else if (slashPending) {
		if (spacePending) {
		    ADD_CHAR(line,' ');
		    spacePending= False;
		}
		ADD_CHAR(line,'/');
		slashPending= False;
	    }
	    if (isspace(ch)) {
		while (isspace(ch)&&(ch!='\n')&&(ch!=EOF)) {
		    ch= getc(file);
		}
		if (ch==EOF)
		    break;
		if ((ch!='\n')&&(line->num_line>0))
		    spacePending= True;
		ungetc(ch,file);
	    }
	    else {
		if (spacePending) {
		    ADD_CHAR(line,' ');
		    spacePending= False;
		}
		if (checkbang && ch=='!') {
		    if (line->num_line!=0) {
			PR_DEBUG("The '!' legal only at start of line\n");
			PR_DEBUG("Line containing '!' ignored\n");
			line->num_line= 0;
			inComment= 0;
			break;
		    }

		}
		ADD_CHAR(line,ch);
	    }
	}
	if (ch==EOF)
	     endOfFile= True;
d200 6
a205 6
     }
     funlockfile(file);
     if ((line->num_line==0)&&(endOfFile))
	return False;
      ADD_CHAR(line,'\0');
      return True;
d225 3
a227 3
static	const char *	cname[MAX_WORDS] = {
	"model", "layout", "variant", "option",
	"keycodes", "symbols", "types", "compat", "geometry", "keymap"
d230 7
a236 7
typedef	struct _RemapSpec {
	int			number;
	int			num_remap;
	struct	{
		int	word;
		int	index;
                }		remap[MAX_WORDS];
d240 2
a241 2
	char *			name[MAX_WORDS];
	struct _FileSpec *	pending;
d245 4
a248 4
	char *			model;
	char *			layout[XkbNumKbdGroups+1];
	char *			variant[XkbNumKbdGroups+1];
	char *			options;
d255 1
a255 1
static char*
d258 3
a260 2
   char ndx_buf[NDX_BUFF_SIZE];
   char *end;
d262 18
a279 18
   if (*str != '[') {
       *ndx = 0;
       return str;
   }
   str++;
   end = strchr(str, ']');
   if (end == NULL) {
       *ndx = -1;
       return str - 1;
   }
   if ( (end - str) >= NDX_BUFF_SIZE) {
       *ndx = -1;
       return end + 1;
   }
   strncpy(ndx_buf, str, end - str);
   ndx_buf[end - str] = '\0';
   *ndx = atoi(ndx_buf);
   return end + 1;
d283 1
a283 1
SetUpRemap(InputLine *line,RemapSpec *remap)
d285 6
a290 5
char *		tok,*str;
unsigned	present, l_ndx_present, v_ndx_present;
register int	i;
int		len, ndx;
_Xstrtokparams	strtok_buf;
d292 1
a292 1
Bool		found;
d295 6
a300 7

   l_ndx_present = v_ndx_present = present= 0;
   str= &line->line[1];
   len = remap->number;
   bzero((char *)remap,sizeof(RemapSpec));
   remap->number = len;
   while ((tok=_XStrtok(str," ",strtok_buf))!=NULL) {
d302 1
a302 1
	found= False;
d304 4
a307 4
	str= NULL;
	if (strcmp(tok,"=")==0)
	    continue;
	for (i=0;i<MAX_WORDS;i++) {
d309 16
a324 14
	    if (strncmp(cname[i],tok,len)==0) {
		if(strlen(tok) > len) {
		    char *end = get_index(tok+len, &ndx);
		    if ((i != LAYOUT && i != VARIANT) ||
			*end != '\0' || ndx == -1)
		        break;
		     if (ndx < 1 || ndx > XkbNumKbdGroups) {
		        PR_DEBUG2("Illegal %s index: %d\n", cname[i], ndx);
		        PR_DEBUG1("Index must be in range 1..%d\n",
				   XkbNumKbdGroups);
			break;
		     }
                } else {
		    ndx = 0;
d327 1
a327 1
		found= True;
d329 9
a337 9
		if (present&(1<<i)) {
		    if ((i == LAYOUT && l_ndx_present&(1<<ndx)) ||
			(i == VARIANT && v_ndx_present&(1<<ndx)) ) {
		        PR_DEBUG1("Component \"%s\" listed twice\n",tok);
		        PR_DEBUG("Second definition ignored\n");
		        break;
		    }
		}
		present |= (1<<i);
d342 5
a346 5
		remap->remap[remap->num_remap].word= i;
		remap->remap[remap->num_remap++].index= ndx;
		break;
	    }
	}
d348 3
a350 3
	if (!found) {
	    fprintf(stderr,"Unknown component \"%s\" ignored\n",tok);
	}
d352 2
a353 2
   }
   if ((present&PART_MASK)==0) {
d355 13
a367 10
	unsigned mask= PART_MASK;
	fprintf(stderr,"Mapping needs at least one of ");
	for (i=0; (i<MAX_WORDS); i++) {
	    if ((1L<<i)&mask) {
		mask&= ~(1L<<i);
		if (mask)	fprintf(stderr,"\"%s,\" ",cname[i]);
		else		fprintf(stderr,"or \"%s\"\n",cname[i]);
	    }
	}
	fprintf(stderr,"Illegal mapping ignored\n");
d369 18
a386 18
	remap->num_remap= 0;
	return;
   }
   if ((present&COMPONENT_MASK)==0) {
	PR_DEBUG("Mapping needs at least one component\n");
	PR_DEBUG("Illegal mapping ignored\n");
	remap->num_remap= 0;
	return;
   }
   if (((present&COMPONENT_MASK)&(1<<KEYMAP))&&
				((present&COMPONENT_MASK)!=(1<<KEYMAP))) {
	PR_DEBUG("Keymap cannot appear with other components\n");
	PR_DEBUG("Illegal mapping ignored\n");
	remap->num_remap= 0;
	return;
   }
   remap->number++;
   return;
d390 1
a390 1
MatchOneOf(char *wanted,char *vals_defined)
d392 5
a396 2
char	*str,*next;
int	want_len= strlen(wanted);
d398 10
a407 12
    for (str=vals_defined,next=NULL;str!=NULL;str=next) {
	int len;
	next= strchr(str,',');
	if (next) {
	    len= next-str;
	    next++;
	}
	else {
	    len= strlen(str);
	}
	if ((len==want_len)&&(strncmp(wanted,str,len)==0))
	    return True;
d415 10
a424 10
CheckLine(	InputLine *		line,
		RemapSpec *		remap,
		XkbRF_RulePtr		rule,
		XkbRF_GroupPtr		group)
{
char *		str,*tok;
register int	nread, i;
FileSpec	tmp;
_Xstrtokparams	strtok_buf;
Bool 		append = False;
d426 1
a426 1
    if (line->line[0]=='!') {
d431 2
a432 1
            if(!words)
d444 4
a447 4
                 if ( *words == ' ') {
                     *words++ = '\0';
                     i++;
                 }
d451 4
a454 3
        } else {
	    SetUpRemap(line,remap);
	    return False;
d458 26
a483 26
    if (remap->num_remap==0) {
	PR_DEBUG("Must have a mapping before first line of data\n");
	PR_DEBUG("Illegal line of data ignored\n");
	return False;
    }
    bzero((char *)&tmp,sizeof(FileSpec));
    str= line->line;
    for (nread= 0;(tok=_XStrtok(str," ",strtok_buf))!=NULL;nread++) {
	str= NULL;
	if (strcmp(tok,"=")==0) {
	    nread--;
	    continue;
	}
	if (nread>remap->num_remap) {
	    PR_DEBUG("Too many words on a line\n");
	    PR_DEBUG1("Extra word \"%s\" ignored\n",tok);
	    continue;
	}
	tmp.name[remap->remap[nread].word]= tok;
	if (*tok == '+' || *tok == '|')
	    append = True;
    }
    if (nread<remap->num_remap) {
	PR_DEBUG1("Too few words on a line: %s\n", line->line);
	PR_DEBUG("line ignored\n");
	return False;
d486 1
a486 1
    rule->flags= 0;
d489 1
a489 1
	 rule->flags|= XkbRF_Option;
d491 1
a491 1
	 rule->flags|= XkbRF_Append;
d493 12
a504 12
	 rule->flags|= XkbRF_Normal;
    rule->model= _XkbDupString(tmp.name[MODEL]);
    rule->layout= _XkbDupString(tmp.name[LAYOUT]);
    rule->variant= _XkbDupString(tmp.name[VARIANT]);
    rule->option= _XkbDupString(tmp.name[OPTION]);

    rule->keycodes= _XkbDupString(tmp.name[KEYCODES]);
    rule->symbols= _XkbDupString(tmp.name[SYMBOLS]);
    rule->types= _XkbDupString(tmp.name[TYPES]);
    rule->compat= _XkbDupString(tmp.name[COMPAT]);
    rule->geometry= _XkbDupString(tmp.name[GEOMETRY]);
    rule->keymap= _XkbDupString(tmp.name[KEYMAP]);
d509 4
a512 4
	    if (remap->remap[i].word == LAYOUT)
	        rule->layout_num = remap->remap[i].index;
	    if (remap->remap[i].word == VARIANT)
	        rule->variant_num = remap->remap[i].index;
d519 1
a519 1
_Concat(char *str1,char *str2)
d521 1
a521 1
int len;
d523 4
a526 4
    if ((!str1)||(!str2))
	return str1;
    len= strlen(str1)+strlen(str2)+1;
    str1= _XkbTypedRealloc(str1,len,char);
d528 1
a528 1
	strcat(str1,str2);
d535 8
a542 6
   char *p2;
   for (p2 = p1; *p2; p2++) {
       *p1 = *p2;
       if (*p1 != ' ') p1++;
   }
   *p1 = '\0';
d549 62
a610 53
   bzero((char *)mdefs,sizeof(XkbRF_MultiDefsRec));
   mdefs->model = defs->model;
   mdefs->options = _XkbDupString(defs->options);
   if (mdefs->options) squeeze_spaces(mdefs->options);

   if (defs->layout) {
       if (!strchr(defs->layout, ',')) {
           mdefs->layout[0] = defs->layout;
       } else {
           char *p;
           int i;
           mdefs->layout[1] = _XkbDupString(defs->layout);
	   if (mdefs->layout[1] == NULL)
	      return False;
           squeeze_spaces(mdefs->layout[1]);
           p = mdefs->layout[1];
           for (i = 2; i <= XkbNumKbdGroups; i++) {
              if ((p = strchr(p, ','))) {
                 *p++ = '\0';
                 mdefs->layout[i] = p;
              } else {
                 break;
              }
           }
           if (p && (p = strchr(p, ',')))
              *p = '\0';
       }
   }

   if (defs->variant) {
       if (!strchr(defs->variant, ',')) {
           mdefs->variant[0] = defs->variant;
       } else {
           char *p;
           int i;
           mdefs->variant[1] = _XkbDupString(defs->variant);
	   if (mdefs->variant[1] == NULL)
	      return False;
           squeeze_spaces(mdefs->variant[1]);
           p = mdefs->variant[1];
           for (i = 2; i <= XkbNumKbdGroups; i++) {
              if ((p = strchr(p, ','))) {
                 *p++ = '\0';
                 mdefs->variant[i] = p;
              } else {
                 break;
              }
           }
           if (p && (p = strchr(p, ',')))
              *p = '\0';
       }
   }
   return True;
d616 6
a621 3
  if (defs->options) _XkbFree(defs->options);
  if (defs->layout[1])  _XkbFree(defs->layout[1]);
  if (defs->variant[1])  _XkbFree(defs->variant[1]);
d629 3
a631 2
	    *dst= _Concat(*dst, src);
        } else {
d633 1
a633 1
	        *dst= _XkbDupString(src);
d639 1
a639 2
XkbRF_ApplyRule(	XkbRF_RulePtr 		rule,
			XkbComponentNamesPtr	names)
d641 1
a641 1
    rule->flags&= ~XkbRF_PendingMatch; /* clear the flag because it's applied */
d652 19
a670 21
CheckGroup(	XkbRF_RulesPtr          rules,
		char * 			group_name,
		char * 			name)
{
   int i;
   char *p;
   XkbRF_GroupPtr group;

   for (i = 0, group = rules->groups; i < rules->num_groups; i++, group++) {
       if (! strcmp(group->name, group_name)) {
           break;
       }
   }
   if (i == rules->num_groups)
       return False;
   for (i = 0, p = group->words; i < group->number; i++, p += strlen(p)+1) {
       if (! strcmp(p, name)) {
           return True;
       }
   }
   return False;
d674 4
a677 4
XkbRF_CheckApplyRule(	XkbRF_RulePtr 		rule,
			XkbRF_MultiDefsPtr	mdefs,
			XkbComponentNamesPtr	names,
			XkbRF_RulesPtr          rules)
d682 1
a682 1
        if(mdefs->model == NULL)
d686 2
a687 1
        } else {
d689 8
a696 7
               if (!CheckGroup(rules, rule->model, mdefs->model))
                  return 0;
            } else {
	       if (strcmp(rule->model, mdefs->model) != 0)
	          return 0;
	    }
	}
d699 4
a702 4
	if (mdefs->options == NULL)
	    return 0;
	if ((!MatchOneOf(rule->option,mdefs->options)))
	    return 0;
d706 3
a708 3
	if(mdefs->layout[rule->layout_num] == NULL ||
	   *mdefs->layout[rule->layout_num] == '\0')
	    return 0;
d711 2
a712 1
        } else {
d714 9
a722 8
               if (!CheckGroup(rules, rule->layout,
                               mdefs->layout[rule->layout_num]))
                  return 0;
	    } else {
	       if (strcmp(rule->layout, mdefs->layout[rule->layout_num]) != 0)
	           return 0;
	    }
	}
d725 3
a727 3
	if (mdefs->variant[rule->variant_num] == NULL ||
	    *mdefs->variant[rule->variant_num] == '\0')
	    return 0;
d730 2
a731 1
        } else {
d733 10
a742 9
               if (!CheckGroup(rules, rule->variant,
                               mdefs->variant[rule->variant_num]))
                  return 0;
            } else {
	       if (strcmp(rule->variant,
                          mdefs->variant[rule->variant_num]) != 0)
	           return 0;
	    }
	}
d745 2
a746 2
        rule->flags|= XkbRF_PendingMatch;
	return rule->number;
d749 1
a749 1
    XkbRF_ApplyRule(rule,names);
d756 2
a757 2
register int 	i;
XkbRF_RulePtr	rule;
d759 2
a760 2
    for (i=0,rule=rules->rules;i<rules->num_rules;i++,rule++) {
	rule->flags&= ~XkbRF_PendingMatch;
d765 1
a765 1
XkbRF_ApplyPartialMatches(XkbRF_RulesPtr rules,XkbComponentNamesPtr names)
d767 2
a768 2
int		i;
XkbRF_RulePtr	rule;
d771 3
a773 3
	if ((rule->flags&XkbRF_PendingMatch)==0)
	    continue;
	XkbRF_ApplyRule(rule,names);
d778 19
a796 18
XkbRF_CheckApplyRules(	XkbRF_RulesPtr 		rules,
			XkbRF_MultiDefsPtr	mdefs,
			XkbComponentNamesPtr	names,
			int			flags)
{
int		i;
XkbRF_RulePtr	rule;
int		skip;

    for (rule = rules->rules, i=0; i < rules->num_rules; rule++, i++) {
	if ((rule->flags & flags) != flags)
	    continue;
	skip = XkbRF_CheckApplyRule(rule, mdefs, names, rules);
	if (skip && !(flags & XkbRF_Option)) {
	    for ( ;(i < rules->num_rules) && (rule->number == skip);
		  rule++, i++);
	    rule--; i--;
	}
d805 56
a860 2
char 	*str, *outstr, *orig, *var;
int	len, ndx;
d862 40
a901 84
    orig= name;
    str= index(name,'%');
    if (str==NULL)
	return name;
    len= strlen(name);
    while (str!=NULL) {
	char pfx= str[1];
	int   extra_len= 0;
	if ((pfx=='+')||(pfx=='|')||(pfx=='_')||(pfx=='-')) {
	    extra_len= 1;
	    str++;
	}
	else if (pfx=='(') {
	    extra_len= 2;
	    str++;
	}
	var = str + 1;
	str = get_index(var + 1, &ndx);
	if (ndx == -1) {
	    str = index(str,'%');
	    continue;
        }
	if ((*var=='l') && mdefs->layout[ndx] && *mdefs->layout[ndx])
	    len+= strlen(mdefs->layout[ndx])+extra_len;
	else if ((*var=='m')&&mdefs->model)
	    len+= strlen(mdefs->model)+extra_len;
	else if ((*var=='v') && mdefs->variant[ndx] && *mdefs->variant[ndx])
	    len+= strlen(mdefs->variant[ndx])+extra_len;
	if ((pfx=='(')&&(*str==')')) {
	    str++;
	}
	str= index(&str[0],'%');
    }
    name= (char *)_XkbAlloc(len+1);
    str= orig;
    outstr= name;
    while (*str!='\0') {
	if (str[0]=='%') {
	    char pfx,sfx;
	    str++;
	    pfx= str[0];
	    sfx= '\0';
	    if ((pfx=='+')||(pfx=='|')||(pfx=='_')||(pfx=='-')) {
		str++;
	    }
	    else if (pfx=='(') {
		sfx= ')';
		str++;
	    }
	    else pfx= '\0';

	    var = str;
	    str = get_index(var + 1, &ndx);
	    if (ndx == -1) {
	        continue;
            }
	    if ((*var=='l') && mdefs->layout[ndx] && *mdefs->layout[ndx]) {
		if (pfx) *outstr++= pfx;
		strcpy(outstr,mdefs->layout[ndx]);
		outstr+= strlen(mdefs->layout[ndx]);
		if (sfx) *outstr++= sfx;
	    }
	    else if ((*var=='m')&&(mdefs->model)) {
		if (pfx) *outstr++= pfx;
		strcpy(outstr,mdefs->model);
		outstr+= strlen(mdefs->model);
		if (sfx) *outstr++= sfx;
	    }
	    else if ((*var=='v') && mdefs->variant[ndx] && *mdefs->variant[ndx]) {
		if (pfx) *outstr++= pfx;
		strcpy(outstr,mdefs->variant[ndx]);
		outstr+= strlen(mdefs->variant[ndx]);
		if (sfx) *outstr++= sfx;
	    }
	    if ((pfx=='(')&&(*str==')'))
		str++;
	}
	else {
	    *outstr++= *str++;
	}
    }
    *outstr++= '\0';
    if (orig!=name)
	_XkbFree(orig);
d908 3
a910 3
XkbRF_GetComponents(	XkbRF_RulesPtr		rules,
			XkbRF_VarDefsPtr	defs,
			XkbComponentNamesPtr	names)
d916 1
a916 1
    bzero((char *)names,sizeof(XkbComponentNamesRec));
d926 1
a926 1
	names->keycodes= XkbRF_SubstituteVars(names->keycodes, &mdefs);
d928 1
a928 1
	names->symbols=	XkbRF_SubstituteVars(names->symbols, &mdefs);
d930 1
a930 1
	names->types= XkbRF_SubstituteVars(names->types, &mdefs);
d932 1
a932 1
	names->compat= XkbRF_SubstituteVars(names->compat, &mdefs);
d934 1
a934 1
	names->geometry= XkbRF_SubstituteVars(names->geometry, &mdefs);
d936 1
a936 1
	names->keymap= XkbRF_SubstituteVars(names->keymap, &mdefs);
d940 1
a940 1
		names->compat && names->geometry ) || names->keymap;
d944 1
a944 1
XkbRF_AddRule(XkbRF_RulesPtr	rules)
d946 9
a954 9
    if (rules->sz_rules<1) {
	rules->sz_rules= 16;
	rules->num_rules= 0;
	rules->rules= _XkbTypedCalloc(rules->sz_rules,XkbRF_RuleRec);
    }
    else if (rules->num_rules>=rules->sz_rules) {
	rules->sz_rules*= 2;
	rules->rules= _XkbTypedRealloc(rules->rules,rules->sz_rules,
							XkbRF_RuleRec);
d957 1
a957 1
	rules->sz_rules= rules->num_rules= 0;
d959 1
a959 1
	fprintf(stderr,"Allocation failure in XkbRF_AddRule\n");
d961 1
a961 1
	return NULL;
d963 1
a963 1
    bzero((char *)&rules->rules[rules->num_rules],sizeof(XkbRF_RuleRec));
d968 1
a968 1
XkbRF_AddGroup(XkbRF_RulesPtr	rules)
d970 4
a973 4
    if (rules->sz_groups<1) {
	rules->sz_groups= 16;
	rules->num_groups= 0;
	rules->groups= _XkbTypedCalloc(rules->sz_groups,XkbRF_GroupRec);
d976 3
a978 3
	rules->sz_groups *= 2;
	rules->groups= _XkbTypedRealloc(rules->groups,rules->sz_groups,
							XkbRF_GroupRec);
d981 2
a982 2
	rules->sz_groups= rules->num_groups= 0;
	return NULL;
d985 1
a985 1
    bzero((char *)&rules->groups[rules->num_groups],sizeof(XkbRF_GroupRec));
d992 4
a995 4
InputLine	line;
RemapSpec	remap;
XkbRF_RuleRec	trule,*rule;
XkbRF_GroupRec  tgroup,*group;
d998 3
a1000 3
	return False;
    bzero((char *)&remap,sizeof(RemapSpec));
    bzero((char *)&tgroup,sizeof(XkbRF_GroupRec));
d1002 2
a1003 2
    while (GetInputLine(file,&line,True)) {
	if (CheckLine(&line,&remap,&trule,&tgroup)) {
d1005 13
a1017 12
	        if ((group= XkbRF_AddGroup(rules))!=NULL) {
		    *group= tgroup;
		    bzero((char *)&tgroup,sizeof(XkbRF_GroupRec));
	        }
	    } else {
	        if ((rule= XkbRF_AddRule(rules))!=NULL) {
		    *rule= trule;
		    bzero((char *)&trule,sizeof(XkbRF_RuleRec));
	        }
	    }
	}
	line.num_line= 0;
d1024 1
a1024 1
XkbRF_LoadRulesByName(char *base,char *locale,XkbRF_RulesPtr rules)
d1026 3
a1028 3
FILE *		file;
char		buf[PATH_MAX];
Bool		ok;
d1030 2
a1031 2
    if ((!base)||(!rules))
	return False;
d1033 3
a1035 3
	if (strlen(base)+strlen(locale)+2 > PATH_MAX)
	    return False;
	sprintf(buf,"%s-%s", base, locale);
d1038 3
a1040 3
	if (strlen(base)+1 > PATH_MAX)
	    return False;
	strcpy(buf,base);
d1043 4
a1046 4
    file= fopen(buf, "r");
    if ((!file)&&(locale)) { /* fallback if locale was specified */
	strcpy(buf,base);
	file= fopen(buf, "r");
d1049 2
a1050 2
	return False;
    ok= XkbRF_LoadRules(file,rules);
d1065 1
a1065 1
XkbRF_AddVarDesc(XkbRF_DescribeVarsPtr	vars)
d1067 9
a1075 8
    if (vars->sz_desc<1) {
	vars->sz_desc= 16;
	vars->num_desc= 0;
	vars->desc= _XkbTypedCalloc(vars->sz_desc,XkbRF_VarDescRec);
    }
    else if (vars->num_desc>=vars->sz_desc) {
	vars->sz_desc*= 2;
	vars->desc= _XkbTypedRealloc(vars->desc,vars->sz_desc,XkbRF_VarDescRec);
d1078 3
a1080 3
	vars->sz_desc= vars->num_desc= 0;
	PR_DEBUG("Allocation failure in XkbRF_AddVarDesc\n");
	return NULL;
d1082 2
a1083 2
    vars->desc[vars->num_desc].name= NULL;
    vars->desc[vars->num_desc].desc= NULL;
d1088 1
a1088 1
XkbRF_AddVarDescCopy(XkbRF_DescribeVarsPtr vars,XkbRF_VarDescPtr from)
d1090 1
a1090 1
XkbRF_VarDescPtr	nd;
d1092 3
a1094 3
    if ((nd=XkbRF_AddVarDesc(vars))!=NULL) {
	nd->name= _XkbDupString(from->name);
	nd->desc= _XkbDupString(from->desc);
d1100 1
a1100 1
XkbRF_AddVarToDescribe(XkbRF_RulesPtr rules,char *name)
d1102 21
a1122 19
    if (rules->sz_extra<1) {
	rules->num_extra= 0;
	rules->sz_extra= 1;
	rules->extra_names= _XkbTypedCalloc(rules->sz_extra,char *);
	rules->extra= _XkbTypedCalloc(rules->sz_extra, XkbRF_DescribeVarsRec);
    }
    else if (rules->num_extra>=rules->sz_extra) {
	rules->sz_extra*= 2;
	rules->extra_names= _XkbTypedRealloc(rules->extra_names,rules->sz_extra,
								char *);
	rules->extra=_XkbTypedRealloc(rules->extra, rules->sz_extra,
							XkbRF_DescribeVarsRec);
    }
    if ((!rules->extra_names)||(!rules->extra)) {
	PR_DEBUG("allocation error in extra parts\n");
	rules->sz_extra= rules->num_extra= 0;
	rules->extra_names= NULL;
	rules->extra= NULL;
	return NULL;
d1124 2
a1125 2
    rules->extra_names[rules->num_extra]= _XkbDupString(name);
    bzero(&rules->extra[rules->num_extra],sizeof(XkbRF_DescribeVarsRec));
d1130 1
a1130 1
XkbRF_LoadDescriptions(FILE *file,XkbRF_RulesPtr rules)
d1132 4
a1135 4
InputLine		line;
XkbRF_VarDescRec	tmp;
char			*tok;
int			len,headingtype,extra_ndx = 0;
d1137 1
a1137 1
    bzero((char *)&tmp, sizeof(XkbRF_VarDescRec));
d1140 78
a1217 75
    for ( ; GetInputLine(file,&line,False); line.num_line= 0) {
	if (line.line[0]=='!') {
	    tok = strtok(&(line.line[1]), " \t");
	    if (strcmp(tok,"model") == 0)
		headingtype = HEAD_MODEL;
	    else if (_XkbStrCaseCmp(tok,"layout") == 0)
		headingtype = HEAD_LAYOUT;
	    else if (_XkbStrCaseCmp(tok,"variant") == 0)
		headingtype = HEAD_VARIANT;
	    else if (_XkbStrCaseCmp(tok,"option") == 0)
		headingtype = HEAD_OPTION;
	    else {
		int i;
		headingtype = HEAD_EXTRA;
		extra_ndx= -1;
		for (i=0;(i<rules->num_extra)&&(extra_ndx<0);i++) {
		    if (_XkbStrCaseCmp(tok,rules->extra_names[i]))
			extra_ndx= i;
		}
		if (extra_ndx<0) {
		    XkbRF_DescribeVarsPtr	var;
		    PR_DEBUG1("Extra heading \"%s\" encountered\n",tok);
		    var= XkbRF_AddVarToDescribe(rules,tok);
		    if (var)
			 extra_ndx= var-rules->extra;
		    else headingtype= HEAD_NONE;
		}
	    }
	    continue;
	}

	if (headingtype == HEAD_NONE) {
	    PR_DEBUG("Must have a heading before first line of data\n");
	    PR_DEBUG("Illegal line of data ignored\n");
	    continue;
	}

	len = strlen(line.line);
	if ((tmp.name= strtok(line.line, " \t")) == NULL) {
	    PR_DEBUG("Huh? No token on line\n");
	    PR_DEBUG("Illegal line of data ignored\n");
	    continue;
	}
	if (strlen(tmp.name) == len) {
	    PR_DEBUG("No description found\n");
	    PR_DEBUG("Illegal line of data ignored\n");
	    continue;
	}

	tok = line.line + strlen(tmp.name) + 1;
	while ((*tok!='\n')&&isspace(*tok))
		tok++;
	if (*tok == '\0') {
	    PR_DEBUG("No description found\n");
	    PR_DEBUG("Illegal line of data ignored\n");
	    continue;
	}
	tmp.desc= tok;
	switch (headingtype) {
	    case HEAD_MODEL:
		XkbRF_AddVarDescCopy(&rules->models,&tmp);
		break;
	    case HEAD_LAYOUT:
		XkbRF_AddVarDescCopy(&rules->layouts,&tmp);
		break;
	    case HEAD_VARIANT:
		XkbRF_AddVarDescCopy(&rules->variants,&tmp);
		break;
	    case HEAD_OPTION:
		XkbRF_AddVarDescCopy(&rules->options,&tmp);
		break;
	    case HEAD_EXTRA:
		XkbRF_AddVarDescCopy(&rules->extra[extra_ndx],&tmp);
		break;
	}
d1220 4
a1223 4
    if ((rules->models.num_desc==0) && (rules->layouts.num_desc==0) &&
	(rules->variants.num_desc==0) && (rules->options.num_desc==0) &&
	(rules->num_extra==0)) {
	return False;
d1229 1
a1229 1
XkbRF_LoadDescriptionsByName(char *base,char *locale,XkbRF_RulesPtr rules)
d1231 3
a1233 3
FILE *		file;
char		buf[PATH_MAX];
Bool		ok;
d1235 2
a1236 2
    if ((!base)||(!rules))
	return False;
d1238 3
a1240 3
	if (strlen(base)+strlen(locale)+6 > PATH_MAX)
	    return False;
	sprintf(buf,"%s-%s.lst", base, locale);
d1243 3
a1245 3
	if (strlen(base)+5 > PATH_MAX)
	    return False;
	sprintf(buf,"%s.lst", base);
d1248 3
a1250 3
    file= fopen(buf, "r");
    if ((!file)&&(locale)) { /* fallback if locale was specified */
	sprintf(buf,"%s.lst", base);
d1252 1
a1252 1
	file= fopen(buf, "r");
d1255 2
a1256 2
	return False;
    ok= XkbRF_LoadDescriptions(file,rules);
d1264 1
a1264 1
XkbRF_Load(char *base,char *locale,Bool wantDesc,Bool wantRules)
d1266 1
a1266 1
XkbRF_RulesPtr	rules;
d1268 11
a1278 11
    if ((!base)||((!wantDesc)&&(!wantRules)))
	return NULL;
    if ((rules=_XkbTypedCalloc(1,XkbRF_RulesRec))==NULL)
	return NULL;
    if (wantDesc&&(!XkbRF_LoadDescriptionsByName(base,locale,rules))) {
	XkbRF_Free(rules,True);
	return NULL;
    }
    if (wantRules&&(!XkbRF_LoadRulesByName(base,locale,rules))) {
	XkbRF_Free(rules,True);
	return NULL;
d1284 1
a1284 1
XkbRF_Create(int szRules,int szExtra)
d1286 1
a1286 1
XkbRF_RulesPtr rules;
d1288 19
a1306 19
    if ((rules=_XkbTypedCalloc(1,XkbRF_RulesRec))==NULL)
	return NULL;
    if (szRules>0) {
	rules->sz_rules= szRules;
	rules->rules= _XkbTypedCalloc(rules->sz_rules,XkbRF_RuleRec);
	if (!rules->rules) {
	    _XkbFree(rules);
	    return NULL;
	}
    }
    if (szExtra>0) {
	rules->sz_extra= szExtra;
	rules->extra= _XkbTypedCalloc(rules->sz_extra,XkbRF_DescribeVarsRec);
	if (!rules->extra) {
	    if (rules->rules)
		_XkbFree(rules->rules);
	    _XkbFree(rules);
	    return NULL;
	}
d1316 1
a1316 1
register int i;
d1318 6
a1323 6
    for (i=0;i<var->num_desc;i++) {
	if (var->desc[i].name)
	    _XkbFree(var->desc[i].name);
	if (var->desc[i].desc)
	    _XkbFree(var->desc[i].desc);
	var->desc[i].name= var->desc[i].desc= NULL;
d1326 2
a1327 2
	_XkbFree(var->desc);
    var->desc= NULL;
d1332 1
a1332 1
XkbRF_Free(XkbRF_RulesPtr rules,Bool freeRules)
d1334 3
a1336 3
int		i;
XkbRF_RulePtr	rule;
XkbRF_GroupPtr	group;
d1339 1
a1339 1
	return;
d1345 6
a1350 6
	for (i = 0; i < rules->num_extra; i++) {
	    XkbRF_ClearVarDescriptions(&rules->extra[i]);
	}
	_XkbFree(rules->extra);
	rules->num_extra= rules->sz_extra= 0;
	rules->extra= NULL;
d1353 26
a1378 16
	for (i=0,rule=rules->rules;i<rules->num_rules;i++,rule++) {
	    if (rule->model)	_XkbFree(rule->model);
	    if (rule->layout)	_XkbFree(rule->layout);
	    if (rule->variant)	_XkbFree(rule->variant);
	    if (rule->option)	_XkbFree(rule->option);
	    if (rule->keycodes)	_XkbFree(rule->keycodes);
	    if (rule->symbols)	_XkbFree(rule->symbols);
	    if (rule->types)	_XkbFree(rule->types);
	    if (rule->compat)	_XkbFree(rule->compat);
	    if (rule->geometry)	_XkbFree(rule->geometry);
	    if (rule->keymap)	_XkbFree(rule->keymap);
	    bzero((char *)rule,sizeof(XkbRF_RuleRec));
	}
	_XkbFree(rules->rules);
	rules->num_rules= rules->sz_rules= 0;
	rules->rules= NULL;
d1382 9
a1390 7
	for (i=0, group=rules->groups;i<rules->num_groups;i++,group++) {
	    if (group->name)	_XkbFree(group->name);
	    if (group->words)	_XkbFree(group->words);
	}
	_XkbFree(rules->groups);
	rules->num_groups= 0;
	rules->groups= NULL;
d1393 1
a1393 1
	_XkbFree(rules);
a1396 1
#ifndef XKB_IN_SERVER
d1399 1
a1399 1
XkbRF_GetNamesProp(Display *dpy,char **rf_rtrn,XkbRF_VarDefsPtr vd_rtrn)
d1401 17
a1417 17
Atom		rules_atom,actual_type;
int		fmt;
unsigned long	nitems,bytes_after;
unsigned char   *data;
char            *out, *end;
Status		rtrn;

    rules_atom= XInternAtom(dpy,_XKB_RF_NAMES_PROP_ATOM,True);
    if (rules_atom==None)	/* property cannot exist */
	return False;
    rtrn= XGetWindowProperty(dpy,DefaultRootWindow(dpy),rules_atom,
                                0L,_XKB_RF_NAMES_PROP_MAXLEN,False,
                                XA_STRING,&actual_type,
                                &fmt,&nitems,&bytes_after,
                                (unsigned char **)&data);
    if (rtrn!=Success)
	return False;
d1419 6
a1424 5
	*rf_rtrn= NULL;
    (void)bzero((char *)vd_rtrn,sizeof(XkbRF_VarDefsRec));
    if ((bytes_after>0)||(actual_type!=XA_STRING)||(fmt!=8)) {
	if (data) XFree(data);
	return (fmt==0?True:False);
d1427 2
a1428 2
    out=(char*)data;
    end=out+nitems;
d1430 2
a1431 2
	 *rf_rtrn= _XkbDupString(out);
    out+=strlen(out)+1;
d1433 4
a1436 4
    if (out<end) {
	if (*out)
	    vd_rtrn->model= _XkbDupString(out);
	out+=strlen(out)+1;
d1439 4
a1442 4
    if (out<end) {
	if (*out)
	    vd_rtrn->layout= _XkbDupString(out);
	out+=strlen(out)+1;
d1445 4
a1448 4
    if (out<end) {
	if (*out)
	    vd_rtrn->variant= _XkbDupString(out);
	out+=strlen(out)+1;
d1451 4
a1454 4
    if (out<end) {
	if (*out)
	    vd_rtrn->options= _XkbDupString(out);
	out+=strlen(out)+1;
d1462 1
a1462 1
XkbRF_SetNamesProp(Display *dpy,char *rules_file,XkbRF_VarDefsPtr var_defs)
d1464 10
a1473 10
int	len,out;
Atom	name;
char *	pval;

    len= (rules_file?strlen(rules_file):0);
    len+= (var_defs->model?strlen(var_defs->model):0);
    len+= (var_defs->layout?strlen(var_defs->layout):0);
    len+= (var_defs->variant?strlen(var_defs->variant):0);
    len+= (var_defs->options?strlen(var_defs->options):0);
    if (len<1)
d1476 1
a1476 1
    len+= 5; /* trailing NULs */
d1478 3
a1480 3
    name= XInternAtom(dpy,_XKB_RF_NAMES_PROP_ATOM,False);
    if (name==None)  { /* should never happen */
	_XkbLibError(_XkbErrXReqFailure,"XkbRF_SetNamesProp",X_InternAtom);
d1483 1
a1483 1
    pval= (char *)_XkbAlloc(len);
d1485 1
a1485 1
	_XkbLibError(_XkbErrBadAlloc,"XkbRF_SetNamesProp",len);
d1488 1
a1488 1
    out= 0;
d1490 2
a1491 2
        strcpy(&pval[out],rules_file);
        out+= strlen(rules_file);
d1493 1
a1493 1
    pval[out++]= '\0';
d1495 2
a1496 2
        strcpy(&pval[out],var_defs->model);
        out+= strlen(var_defs->model);
d1498 1
a1498 1
    pval[out++]= '\0';
d1500 2
a1501 2
        strcpy(&pval[out],var_defs->layout);
        out+= strlen(var_defs->layout);
d1503 1
a1503 1
    pval[out++]= '\0';
d1505 2
a1506 2
        strcpy(&pval[out],var_defs->variant);
        out+= strlen(var_defs->variant);
d1508 1
a1508 1
    pval[out++]= '\0';
d1510 2
a1511 2
        strcpy(&pval[out],var_defs->options);
        out+= strlen(var_defs->options);
d1513 5
a1517 5
    pval[out++]= '\0';
    if (out!=len) {
	_XkbLibError(_XkbErrBadLength,"XkbRF_SetNamesProp",out);
	_XkbFree(pval);
	return False;
d1520 2
a1521 2
    XChangeProperty(dpy,DefaultRootWindow(dpy),name,XA_STRING,8,PropModeReplace,
                                                (unsigned char *)pval,len);
a1525 1
#endif
@


1.3
log
@Update to libxkbfile 1.0.7. No functional change.
@
text
@d9 2
a10 2
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
d12 1
a12 1
 Silicon Graphics makes no representation about the suitability 
d15 3
a17 3
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d241 2
a242 2
static	char *	cname[MAX_WORDS] = {
	"model", "layout", "variant", "option", 
d557 1
a557 1
   if (mdefs->options) squeeze_spaces(mdefs->options); 
d905 1
a905 1
    if (names->symbols)	
d913 1
a913 1
    if (names->keymap)	
d1075 1
a1075 1
XkbRF_DescribeVarsPtr 
d1255 1
a1255 1
XkbRF_Create(int szRules,int szExtra) 
d1262 1
a1262 1
	rules->sz_rules= szRules; 
d1270 1
a1270 1
	rules->sz_extra= szExtra; 
d1288 1
a1288 1
    
d1358 1
a1358 1
Bool 
d1370 1
a1370 1
	return False; 
d1420 1
a1420 1
Bool 
@


1.2
log
@Update to libxkbfile 1.0.6.
@
text
@a0 1
/* $Xorg: maprules.c,v 1.4 2000/08/17 19:46:43 cpqbld Exp $ */
a25 1
/* $XFree86: xc/lib/xkbfile/maprules.c,v 3.17 2002/11/26 01:43:25 dawes Exp $ */
a56 1
#define NEED_EVENTS
@


1.1
log
@Initial revision
@
text
@d140 8
d155 1
d220 1
d904 1
@


1.1.1.1
log
@import from X.Org 7.2RC1
@
text
@@
