head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2015.12.23.05.17.22;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.50;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.14;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.50;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.13.59.01;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.00;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.22;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.52;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.15;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.51;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.51;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>llvmpipe</title>
  <link rel="stylesheet" type="text/css" href="mesa.css">
</head>
<body>

<div class="header">
  <h1>The Mesa 3D Graphics Library</h1>
</div>

<iframe src="contents.html"></iframe>
<div class="content">

<h1>Introduction</h1>

<p>
The Gallium llvmpipe driver is a software rasterizer that uses LLVM to
do runtime code generation.
Shaders, point/line/triangle rasterization and vertex processing are
implemented with LLVM IR which is translated to x86 or x86-64 machine
code.
Also, the driver is multithreaded to take advantage of multiple CPU cores
(up to 8 at this time).
It's the fastest software rasterizer for Mesa.
</p>


<h1>Requirements</h1>

<ul>
<li>
   <p>An x86 or amd64 processor; 64-bit mode recommended.</p>
   <p>
   Support for SSE2 is strongly encouraged.  Support for SSSE3 and SSE4.1 will
   yield the most efficient code.  The fewer features the CPU has the more
   likely is that you run into underperforming, buggy, or incomplete code.
   </p>
   <p>
   See /proc/cpuinfo to know what your CPU supports.
   </p>
</li>
<li>
   <p>LLVM: version 2.9 recommended; 2.6 or later required.</p>
   <p><b>NOTE</b>: LLVM 2.8 and earlier will not work on systems that support the
   Intel AVX extensions (e.g. Sandybridge).  LLVM's code generator will
   fail when trying to emit AVX instructions.  This was fixed in LLVM 2.9.
   </p>
   <p>
   For Linux, on a recent Debian based distribution do:
   </p>
<pre>
     aptitude install llvm-dev
</pre>
   <p>
   For a RPM-based distribution do:
   </p>
<pre>
     yum install llvm-devel
</pre>

   <p>
	 For Windows you will need to build LLVM from source with MSVC or MINGW
	 (either natively or through cross compilers) and CMake, and set the LLVM
	 environment variable to the directory you installed it to.

   LLVM will be statically linked, so when building on MSVC it needs to be
   built with a matching CRT as Mesa, and you'll need to pass
   -DLLVM_USE_CRT_RELEASE=MTd for debug and checked builds,
   -DLLVM_USE_CRT_RELEASE=MTd for profile and release builds.

   You can build only the x86 target by passing -DLLVM_TARGETS_TO_BUILD=X86
   to cmake.
   </p>
</li>

<li>
   <p>scons (optional)</p>
</li>
</ul>


<h1>Building</h1>

To build everything on Linux invoke scons as:

<pre>
  scons build=debug libgl-xlib
</pre>

Alternatively, you can build it with GNU make, if you prefer, by invoking it as

<pre>
  make linux-llvm
</pre>

but the rest of these instructions assume that scons is used.

For Windows the procedure is similar except the target:

<pre>
  scons build=debug libgl-gdi
</pre>


<h1>Using</h1>

On Linux, building will create a drop-in alternative for libGL.so into

<pre>
  build/foo/gallium/targets/libgl-xlib/libGL.so
</pre>
or
<pre>
  lib/gallium/libGL.so
</pre>

To use it set the LD_LIBRARY_PATH environment variable accordingly.

For performance evaluation pass debug=no to scons, and use the corresponding
lib directory without the "-debug" suffix.

On Windows, building will create a drop-in alternative for opengl32.dll. To use
it put it in the same directory as the application. It can also be used by
replacing the native ICD driver, but it's quite an advanced usage, so if you
need to ask, don't even try it.


<h1>Profiling</h1>

<p>
To profile llvmpipe you should build as
</p>
<pre>
  scons build=profile &lt;same-as-before&gt;
</pre>

<p>
This will ensure that frame pointers are used both in C and JIT functions, and
that no tail call optimizations are done by gcc.
</p>

<h2>Linux perf integration</h2>

<p>
On Linux, it is possible to have symbol resolution of JIT code with <a href="http://perf.wiki.kernel.org/">Linux perf</a>:
</p>

<pre>
	perf record -g /my/application
	perf report
</pre>

<p>
When run inside Linux perf, llvmpipe will create a /tmp/perf-XXXXX.map file with
symbol address table.  It also dumps assembly code to /tmp/perf-XXXXX.map.asm,
which can be used by the bin/perf-annotate-jit script to produce disassembly of
the generated code annotated with the samples.
</p>

<p>You can obtain a call graph via
<a href="http://code.google.com/p/jrfonseca/wiki/Gprof2Dot#linux_perf">Gprof2Dot</a>.</p>


<h1>Unit testing</h1>

<p>
Building will also create several unit tests in
build/linux-???-debug/gallium/drivers/llvmpipe:
</p>

<ul>
<li> lp_test_blend: blending
<li> lp_test_conv: SIMD vector conversion
<li> lp_test_format: pixel unpacking/packing
</ul>

<p>
Some of this tests can output results and benchmarks to a tab-separated-file
for posterior analysis, e.g.:
</p>
<pre>
  build/linux-x86_64-debug/gallium/drivers/llvmpipe/lp_test_blend -o blend.tsv
</pre>


<h1>Development Notes</h1>

<ul>
<li>
  When looking to this code by the first time start in lp_state_fs.c, and 
  then skim through the lp_bld_* functions called in there, and the comments
  at the top of the lp_bld_*.c functions.
</li>
<li>
  The driver-independent parts of the LLVM / Gallium code are found in
  src/gallium/auxiliary/gallivm/.  The filenames and function prefixes
  need to be renamed from "lp_bld_" to something else though.
</li>
<li>
  We use LLVM-C bindings for now. They are not documented, but follow the C++
  interfaces very closely, and appear to be complete enough for code
  generation. See 
  <a href="http://npcontemplation.blogspot.com/2008/06/secret-of-llvm-c-bindings.html">
  this stand-alone example</a>.  See the llvm-c/Core.h file for reference.
</li>
</ul>

<h1 id="recommended_reading">Recommended Reading</h1>

<ul>
  <li>
    <p>Rasterization</p>
    <ul>
      <li><a href="http://www.cs.unc.edu/~olano/papers/2dh-tri/">Triangle Scan Conversion using 2D Homogeneous Coordinates</a></li>
      <li><a href="http://www.drdobbs.com/parallel/rasterization-on-larrabee/217200602">Rasterization on Larrabee</a> (<a href="http://devmaster.net/posts/2887/rasterization-on-larrabee">DevMaster copy</a>)</li>
      <li><a href="http://devmaster.net/posts/6133/rasterization-using-half-space-functions">Rasterization using half-space functions</a></li>
      <li><a href="http://devmaster.net/posts/6145/advanced-rasterization">Advanced Rasterization</a></li>
      <li><a href="http://fgiesen.wordpress.com/2013/02/17/optimizing-sw-occlusion-culling-index/">Optimizing Software Occlusion Culling</a></li>
    </ul>
  </li>
  <li>
    <p>Texture sampling</p>
    <ul>
      <li><a href="http://chrishecker.com/Miscellaneous_Technical_Articles#Perspective_Texture_Mapping">Perspective Texture Mapping</a></li>
      <li><a href="http://www.flipcode.com/archives/Texturing_As_In_Unreal.shtml">Texturing As In Unreal</a></li>
      <li><a href="http://www.gamasutra.com/view/feature/3301/runtime_mipmap_filtering.php">Run-Time MIP-Map Filtering</a></li>
      <li><a href="http://alt.3dcenter.org/artikel/2003/10-26_a_english.php">Will "brilinear" filtering persist?</a></li>
      <li><a href="http://ixbtlabs.com/articles2/gffx/nv40-rx800-3.html">Trilinear filtering</a></li>
      <li><a href="http://devmaster.net/posts/12785/texture-swizzling">Texture Swizzling</a></li>
    </ul>
  </li>
  <li>
    <p>SIMD</p>
    <ul>
      <li><a href="http://www.cdl.uni-saarland.de/projects/wfv/#header4">Whole-Function Vectorization</a></li>
    </ul>
  </li>
  <li>
    <p>Optimization</p>
    <ul>
      <li><a href="http://www.drdobbs.com/optimizing-pixomatic-for-modern-x86-proc/184405807">Optimizing Pixomatic For Modern x86 Processors</a></li>
      <li><a href="http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html">Intel 64 and IA-32 Architectures Optimization Reference Manual</a></li>
      <li><a href="http://www.agner.org/optimize/">Software optimization resources</a></li>
      <li><a href="http://software.intel.com/en-us/articles/intel-intrinsics-guide">Intel Intrinsics Guide</a><li>
    </ul>
  </li>
  <li>
    <p>LLVM</p>
    <ul>
      <li><a href="http://llvm.org/docs/LangRef.html">LLVM Language Reference Manual</a></li>
      <li><a href="http://npcontemplation.blogspot.co.uk/2008/06/secret-of-llvm-c-bindings.html">The secret of LLVM C bindings</a></li>
    </ul>
  </li>
  <li>
    <p>General</p>
    <ul>
      <li><a href="http://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/">A trip through the Graphics Pipeline</a></li>
      <li><a href="http://msdn.microsoft.com/en-us/library/gg615082.aspx#architecture">WARP Architecture and Performance</a></li>
    </ul>
  </li>
</ul>

</div>
</body>
</html>
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d46 5
a50 1
   <p>LLVM: version 3.4 recommended; 3.3 or later required.</p>
d104 1
a104 1
  scons platform=windows build=debug libgl-gdi
d110 1
a110 3
<h2>Linux</h2>

<p>On Linux, building will create a drop-in alternative for libGL.so into</p>
d120 1
a120 5
<p>To use it set the LD_LIBRARY_PATH environment variable accordingly.</p>

<p>For performance evaluation pass build=release to scons, and use the corresponding
lib directory without the "-debug" suffix.</p>

d122 2
a123 1
<h2>Windows</h2>
d125 2
a126 5
<p>
On Windows, building will create
<code>build/windows-x86-debug/gallium/targets/libgl-gdi/opengl32.dll</code>
which is a drop-in alternative for system's <code>opengl32.dll</code>.  To use
it put it in the same directory as your application.  It can also be used by
a128 24
</p>

<p>
There is however an easy way to replace the OpenGL software renderer that comes
with Microsoft Windows 7 (or later) with llvmpipe (that is, on systems without
any OpenGL drivers):
</p>

<ul>
  <li><p>copy build/windows-x86-debug/gallium/targets/libgl-gdi/opengl32.dll to C:\Windows\SysWOW64\mesadrv.dll</p></li>
  <li><p>load this registry settings:</p>
  <pre>REGEDIT4

; http://technet.microsoft.com/en-us/library/cc749368.aspx
; http://www.msfn.org/board/topic/143241-portable-windows-7-build-from-winpe-30/page-5#entry942596
[HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\OpenGLDrivers\MSOGL]
"DLL"="mesadrv.dll"
"DriverVersion"=dword:00000001
"Flags"=dword:00000001
"Version"=dword:00000002
</pre>
  </li>
  <li>Ditto for 64 bits drivers if you need them.</li>
</ul>
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d46 1
a46 5
   <p>LLVM: version 2.9 recommended; 2.6 or later required.</p>
   <p><b>NOTE</b>: LLVM 2.8 and earlier will not work on systems that support the
   Intel AVX extensions (e.g. Sandybridge).  LLVM's code generator will
   fail when trying to emit AVX instructions.  This was fixed in LLVM 2.9.
   </p>
d100 1
a100 1
  scons build=debug libgl-gdi
d106 3
a108 1
On Linux, building will create a drop-in alternative for libGL.so into
d118 5
a122 1
To use it set the LD_LIBRARY_PATH environment variable accordingly.
d124 1
a124 2
For performance evaluation pass debug=no to scons, and use the corresponding
lib directory without the "-debug" suffix.
d126 5
a130 2
On Windows, building will create a drop-in alternative for opengl32.dll. To use
it put it in the same directory as the application. It can also be used by
d133 24
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d206 2
a207 2
  http://npcontemplation.blogspot.com/2008/06/secret-of-llvm-c-bindings.html
  for a stand-alone example.  See the llvm-c/Core.h file for reference.
d209 55
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d1 12
a12 1
<HTML>
d14 2
a15 1
<TITLE>llvmpipe</TITLE>
d17 1
a17 5
<link rel="stylesheet" type="text/css" href="mesa.css"></head>

<BODY>

<H1>Introduction</H1>
d35 1
a35 1
	 <p>An x86 or amd64 processor; 64-bit mode recommended.</p
d37 3
a39 3
   Support for SSE2 is strongly encouraged.  Support for SSSE3, and SSE4.1 will
   yield the most efficient code.  The less features the CPU has the more
   likely is that you ran into underperforming, buggy, or incomplete code.  
d46 2
a47 2
	 <p>LLVM: version 2.9 recommended; 2.6 or later required.</p>
   <b>NOTE</b>: LLVM 2.8 and earlier will not work on systems that support the
d57 1
a84 2


d133 3
a135 2
To profile llvmpipe you should pass the options

d137 1
a137 1
  scons build=profile <same-as-before>
d140 1
d143 1
d145 5
a149 1
To better profile JIT code you'll need to build LLVM with oprofile integration.
d152 2
a153 11
  ./configure \
      --prefix=$install_dir \
      --enable-optimized \
      --disable-profiling \
      --enable-targets=host-only \
      --with-oprofile

  make -C "$build_dir"
  make -C "$build_dir" install

  find "$install_dir/lib" -iname '*.a' -print0 | xargs -0 strip --strip-debug
d156 6
a161 1
The you should define
d163 2
a164 5
<pre>
  export LLVM=/path/to/llvm-2.6-profile
</pre>

and rebuild.
d174 1
a174 1
</ul>
d195 1
a195 1
  at the top of the lp_bld_*.c functions.  
d210 4
@


1.1
log
@Initial revision
@
text
@d25 3
a27 3
<dl>
<dt>An x86 or amd64 processor.  64-bit mode is preferred.</dt>
<dd>
d29 1
a29 1
   Support for sse2 is strongly encouraged.  Support for ssse3, and sse4.1 will
d36 3
a38 4
</dd>
<dt>LLVM. Version 2.8 recommended. 2.6 or later required.</dt>
<dd>
   <p>
d56 18
a73 17
   For Windows download pre-built MSVC 9.0 or MinGW binaries from
   http://people.freedesktop.org/~jrfonseca/llvm/ and set the LLVM environment
   variable to the extracted path.
   </p>

   <p>
   For MSVC there are two set of binaries: llvm-x.x-msvc32mt.7z and
   llvm-x.x-msvc32mtd.7z .
   </p>

   <p>
   You have to set the LLVM=/path/to/llvm-x.x-msvc32mtd env var when passing
   debug=yes to scons, and LLVM=/path/to/llvm-x.x-msvc32mt when building with
   debug=no. This is necessary as LLVM builds as static library so the chosen
   MS CRT must match.
   </p>
</dd>
a74 2
<dt>scons (optional)</dt>
</dl>
d94 1
a94 1
For windows is everything the except except the winsys:
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d1 1
a1 12
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>llvmpipe</title>
  <link rel="stylesheet" type="text/css" href="mesa.css">
</head>
<body>

<div class="header">
  <h1>The Mesa 3D Graphics Library</h1>
</div>
d3 1
a3 2
<iframe src="contents.html"></iframe>
<div class="content">
d5 5
a9 1
<h1>Introduction</h1>
d25 3
a27 3
<ul>
<li>
   <p>An x86 or amd64 processor; 64-bit mode recommended.</p>
d29 3
a31 3
   Support for SSE2 is strongly encouraged.  Support for SSSE3 and SSE4.1 will
   yield the most efficient code.  The fewer features the CPU has the more
   likely is that you run into underperforming, buggy, or incomplete code.
d36 5
a40 4
</li>
<li>
   <p>LLVM: version 2.9 recommended; 2.6 or later required.</p>
   <p><b>NOTE</b>: LLVM 2.8 and earlier will not work on systems that support the
a49 1
   <p>
d57 9
a65 8
	 For Windows you will need to build LLVM from source with MSVC or MINGW
	 (either natively or through cross compilers) and CMake, and set the LLVM
	 environment variable to the directory you installed it to.

   LLVM will be statically linked, so when building on MSVC it needs to be
   built with a matching CRT as Mesa, and you'll need to pass
   -DLLVM_USE_CRT_RELEASE=MTd for debug and checked builds,
   -DLLVM_USE_CRT_RELEASE=MTd for profile and release builds.
d67 5
a71 2
   You can build only the x86 target by passing -DLLVM_TARGETS_TO_BUILD=X86
   to cmake.
d73 4
a76 1
</li>
a77 4
<li>
   <p>scons (optional)</p>
</li>
</ul>
d96 1
a96 1
For Windows the procedure is similar except the target:
d128 2
a129 3
<p>
To profile llvmpipe you should build as
</p>
d131 1
a131 1
  scons build=profile &lt;same-as-before&gt;
a133 1
<p>
a135 1
</p>
d137 15
a151 1
<h2>Linux perf integration</h2>
d153 1
a153 3
<p>
On Linux, it is possible to have symbol resolution of JIT code with <a href="http://perf.wiki.kernel.org/">Linux perf</a>:
</p>
d156 1
a156 2
	perf record -g /my/application
	perf report
d159 1
a159 9
<p>
When run inside Linux perf, llvmpipe will create a /tmp/perf-XXXXX.map file with
symbol address table.  It also dumps assembly code to /tmp/perf-XXXXX.map.asm,
which can be used by the bin/perf-annotate-jit script to produce disassembly of
the generated code annotated with the samples.
</p>

<p>You can obtain a call graph via
<a href="http://code.google.com/p/jrfonseca/wiki/Gprof2Dot#linux_perf">Gprof2Dot</a>.</p>
d169 1
a169 1
<ul>
d190 1
a190 1
  at the top of the lp_bld_*.c functions.
a204 4

</div>
</body>
</html>
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d206 2
a207 2
  <a href="http://npcontemplation.blogspot.com/2008/06/secret-of-llvm-c-bindings.html">
  this stand-alone example</a>.  See the llvm-c/Core.h file for reference.
a208 55
</ul>

<h1 id="recommended_reading">Recommended Reading</h1>

<ul>
  <li>
    <p>Rasterization</p>
    <ul>
      <li><a href="http://www.cs.unc.edu/~olano/papers/2dh-tri/">Triangle Scan Conversion using 2D Homogeneous Coordinates</a></li>
      <li><a href="http://www.drdobbs.com/parallel/rasterization-on-larrabee/217200602">Rasterization on Larrabee</a> (<a href="http://devmaster.net/posts/2887/rasterization-on-larrabee">DevMaster copy</a>)</li>
      <li><a href="http://devmaster.net/posts/6133/rasterization-using-half-space-functions">Rasterization using half-space functions</a></li>
      <li><a href="http://devmaster.net/posts/6145/advanced-rasterization">Advanced Rasterization</a></li>
      <li><a href="http://fgiesen.wordpress.com/2013/02/17/optimizing-sw-occlusion-culling-index/">Optimizing Software Occlusion Culling</a></li>
    </ul>
  </li>
  <li>
    <p>Texture sampling</p>
    <ul>
      <li><a href="http://chrishecker.com/Miscellaneous_Technical_Articles#Perspective_Texture_Mapping">Perspective Texture Mapping</a></li>
      <li><a href="http://www.flipcode.com/archives/Texturing_As_In_Unreal.shtml">Texturing As In Unreal</a></li>
      <li><a href="http://www.gamasutra.com/view/feature/3301/runtime_mipmap_filtering.php">Run-Time MIP-Map Filtering</a></li>
      <li><a href="http://alt.3dcenter.org/artikel/2003/10-26_a_english.php">Will "brilinear" filtering persist?</a></li>
      <li><a href="http://ixbtlabs.com/articles2/gffx/nv40-rx800-3.html">Trilinear filtering</a></li>
      <li><a href="http://devmaster.net/posts/12785/texture-swizzling">Texture Swizzling</a></li>
    </ul>
  </li>
  <li>
    <p>SIMD</p>
    <ul>
      <li><a href="http://www.cdl.uni-saarland.de/projects/wfv/#header4">Whole-Function Vectorization</a></li>
    </ul>
  </li>
  <li>
    <p>Optimization</p>
    <ul>
      <li><a href="http://www.drdobbs.com/optimizing-pixomatic-for-modern-x86-proc/184405807">Optimizing Pixomatic For Modern x86 Processors</a></li>
      <li><a href="http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html">Intel 64 and IA-32 Architectures Optimization Reference Manual</a></li>
      <li><a href="http://www.agner.org/optimize/">Software optimization resources</a></li>
      <li><a href="http://software.intel.com/en-us/articles/intel-intrinsics-guide">Intel Intrinsics Guide</a><li>
    </ul>
  </li>
  <li>
    <p>LLVM</p>
    <ul>
      <li><a href="http://llvm.org/docs/LangRef.html">LLVM Language Reference Manual</a></li>
      <li><a href="http://npcontemplation.blogspot.co.uk/2008/06/secret-of-llvm-c-bindings.html">The secret of LLVM C bindings</a></li>
    </ul>
  </li>
  <li>
    <p>General</p>
    <ul>
      <li><a href="http://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/">A trip through the Graphics Pipeline</a></li>
      <li><a href="http://msdn.microsoft.com/en-us/library/gg615082.aspx#architecture">WARP Architecture and Performance</a></li>
    </ul>
  </li>
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d46 5
a50 1
   <p>LLVM: version 3.4 recommended; 3.3 or later required.</p>
d104 1
a104 1
  scons platform=windows build=debug libgl-gdi
d110 1
a110 3
<h2>Linux</h2>

<p>On Linux, building will create a drop-in alternative for libGL.so into</p>
d120 1
a120 5
<p>To use it set the LD_LIBRARY_PATH environment variable accordingly.</p>

<p>For performance evaluation pass build=release to scons, and use the corresponding
lib directory without the "-debug" suffix.</p>

d122 2
a123 1
<h2>Windows</h2>
d125 2
a126 5
<p>
On Windows, building will create
<code>build/windows-x86-debug/gallium/targets/libgl-gdi/opengl32.dll</code>
which is a drop-in alternative for system's <code>opengl32.dll</code>.  To use
it put it in the same directory as your application.  It can also be used by
a128 24
</p>

<p>
There is however an easy way to replace the OpenGL software renderer that comes
with Microsoft Windows 7 (or later) with llvmpipe (that is, on systems without
any OpenGL drivers):
</p>

<ul>
  <li><p>copy build/windows-x86-debug/gallium/targets/libgl-gdi/opengl32.dll to C:\Windows\SysWOW64\mesadrv.dll</p></li>
  <li><p>load this registry settings:</p>
  <pre>REGEDIT4

; http://technet.microsoft.com/en-us/library/cc749368.aspx
; http://www.msfn.org/board/topic/143241-portable-windows-7-build-from-winpe-30/page-5#entry942596
[HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\OpenGLDrivers\MSOGL]
"DLL"="mesadrv.dll"
"DriverVersion"=dword:00000001
"Flags"=dword:00000001
"Version"=dword:00000002
</pre>
  </li>
  <li>Ditto for 64 bits drivers if you need them.</li>
</ul>
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d46 1
a46 5
   <p>LLVM: version 2.9 recommended; 2.6 or later required.</p>
   <p><b>NOTE</b>: LLVM 2.8 and earlier will not work on systems that support the
   Intel AVX extensions (e.g. Sandybridge).  LLVM's code generator will
   fail when trying to emit AVX instructions.  This was fixed in LLVM 2.9.
   </p>
d100 1
a100 1
  scons build=debug libgl-gdi
d106 3
a108 1
On Linux, building will create a drop-in alternative for libGL.so into
d118 5
a122 1
To use it set the LD_LIBRARY_PATH environment variable accordingly.
d124 1
a124 2
For performance evaluation pass debug=no to scons, and use the corresponding
lib directory without the "-debug" suffix.
d126 5
a130 2
On Windows, building will create a drop-in alternative for opengl32.dll. To use
it put it in the same directory as the application. It can also be used by
d133 24
@


