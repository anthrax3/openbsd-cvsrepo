head	1.4;
access;
symbols
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2011.05.31.18.50.20;	author matthieu;	state dead;
branches;
next	1.3;

1.3
date	2010.05.22.20.05.54;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.37;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.57.02;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.57.02;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Remove MesaDemos contents. Not used by Xenocara builds anymore.
@
text
@/*
 * GL_ARB_occlusion_query demo
 *
 * Brian Paul
 * 12 June 2003
 *
 * Copyright (C) 2003  Brian Paul   All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <GL/glew.h>
#include <GL/glut.h>

#define NUM_OCC 10

static GLboolean Anim = GL_TRUE;
static GLfloat Xpos[NUM_OCC], Ypos[NUM_OCC];
static GLfloat Sign[NUM_OCC];
static GLuint OccQuery[NUM_OCC];
static GLint Win = 0;


static void
PrintString(const char *s)
{
   while (*s) {
      glutBitmapCharacter(GLUT_BITMAP_8_BY_13, (int) *s);
      s++;
   }
}



static void Idle(void)
{
   static int lastTime = 0;
   int time = glutGet(GLUT_ELAPSED_TIME);
   float step;
   int i;

   if (lastTime == 0)
      lastTime = time;
   else if (time - lastTime < 20)  /* 50Hz update */
      return;

   for (i = 0; i < NUM_OCC; i++) {

      step = (time - lastTime) / 1000.0 * Sign[i];

      Xpos[i] += step;

      if (Xpos[i] > 2.5) {
         Xpos[i] = 2.5;
         Sign[i] = -1;
      }
      else if (Xpos[i] < -2.5) {
         Xpos[i] = -2.5;
         Sign[i] = +1;
      }

   }

   lastTime = time;

   glutPostRedisplay();
}


static void Display( void )
{
   int i;

   glClearColor(0.25, 0.25, 0.25, 0.0);
   glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

   glMatrixMode( GL_PROJECTION );
   glLoadIdentity();
   glFrustum( -1.0, 1.0, -1.0, 1.0, 5.0, 25.0 );
   glMatrixMode( GL_MODELVIEW );
   glLoadIdentity();
   glTranslatef( 0.0, 0.0, -15.0 );

   /* draw the occluding polygons */
   glColor3f(0, 0.4, 0.6);
   glBegin(GL_QUADS);
   glVertex2f(-1.6, -2.5);
   glVertex2f(-0.4, -2.5);
   glVertex2f(-0.4,  2.5);
   glVertex2f(-1.6,  2.5);
   glVertex2f( 0.4, -2.5);
   glVertex2f( 1.6, -2.5);
   glVertex2f( 1.6,  2.5);
   glVertex2f( 0.4,  2.5);
   glEnd();


   glColorMask(0, 0, 0, 0);
   glDepthMask(GL_FALSE);

   /* draw the test polygons with occlusion testing */
   for (i = 0; i < NUM_OCC; i++) {
      glPushMatrix();
         glTranslatef(Xpos[i], Ypos[i], -0.5);
         glScalef(0.2, 0.2, 1.0);
         glRotatef(-90.0 * Xpos[i], 0, 0, 1);

         glBeginQueryARB(GL_SAMPLES_PASSED_ARB, OccQuery[i]);
         glBegin(GL_POLYGON);
         glVertex3f(-1, -1, 0);
         glVertex3f( 1, -1, 0);
         glVertex3f( 1,  1, 0);
         glVertex3f(-1,  1, 0);
         glEnd();
         glEndQueryARB(GL_SAMPLES_PASSED_ARB);

      glPopMatrix();
   }

   glColorMask(1, 1, 1, 1);
   glDepthMask(GL_TRUE);

   /* Draw the rectangles now.
    * Draw orange if result was ready
    * Draw red if result was not ready.
    */
   for (i = 0; i < NUM_OCC; i++) {
      GLuint passed;
      GLint ready;

      glGetQueryObjectivARB(OccQuery[i], GL_QUERY_RESULT_AVAILABLE_ARB, &ready);

      glGetQueryObjectuivARB(OccQuery[i], GL_QUERY_RESULT_ARB, &passed);

      if (!ready)
         glColor3f(1, 0, 0);
      else
         glColor3f(0.8, 0.5, 0);

      if (!ready || passed) {
         glPushMatrix();
            glTranslatef(Xpos[i], Ypos[i], -0.5);
            glScalef(0.2, 0.2, 1.0);
            glRotatef(-90.0 * Xpos[i], 0, 0, 1);

            glBegin(GL_POLYGON);
            glVertex3f(-1, -1, 0);
            glVertex3f( 1, -1, 0);
            glVertex3f( 1,  1, 0);
            glVertex3f(-1,  1, 0);
            glEnd();

         glPopMatrix();
      }

      {
         char s[10];
         glRasterPos3f(0.45, Ypos[i], 1.0);
         sprintf(s, "%4d", passed);
         PrintString(s);
      }
   }

   glutSwapBuffers();
}


static void Reshape( int width, int height )
{
   glViewport( 0, 0, width, height );
}


static void Key( unsigned char key, int x, int y )
{
   (void) x;
   (void) y;
   switch (key) {
      case 27:
         glutDestroyWindow(Win);
         exit(0);
         break;
      case ' ':
         Anim = !Anim;
         if (Anim)
            glutIdleFunc(Idle);
         else
            glutIdleFunc(NULL);
         break;
   }
   glutPostRedisplay();
}


static void SpecialKey( int key, int x, int y )
{
   const GLfloat step = 0.1;
   int i;
   (void) x;
   (void) y;
   switch (key) {
      case GLUT_KEY_LEFT:
         for (i = 0; i < NUM_OCC; i++)
            Xpos[i] -= step;
         break;
      case GLUT_KEY_RIGHT:
         for (i = 0; i < NUM_OCC; i++)
            Xpos[i] += step;
         break;
   }
   glutPostRedisplay();
}


static void Init( void )
{
   const char *ext = (const char *) glGetString(GL_EXTENSIONS);
   GLint bits;
   int i;

   if (!strstr(ext, "GL_ARB_occlusion_query")) {
      printf("Sorry, this demo requires the GL_ARB_occlusion_query extension\n");
      exit(-1);
   }

   glGetQueryivARB(GL_SAMPLES_PASSED_ARB, GL_QUERY_COUNTER_BITS_ARB, &bits);
   if (!bits) {
      printf("Hmmm, GL_QUERY_COUNTER_BITS_ARB is zero!\n");
      exit(-1);
   }

   glGetIntegerv(GL_DEPTH_BITS, &bits);
   printf("Depthbits: %d\n", bits);

   glGenQueriesARB(NUM_OCC, OccQuery);

   glEnable(GL_DEPTH_TEST);

   for (i = 0; i < NUM_OCC; i++) {
      float t = (float) i / (NUM_OCC - 1);
      Xpos[i] = 2.5 * t;
      Ypos[i] = 4.0 * (t - 0.5);
      Sign[i] = 1.0;
   }

}


int main( int argc, char *argv[] )
{
   glutInitWindowSize( 400, 400 );
   glutInit( &argc, argv );
   glutInitDisplayMode( GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH );
   Win = glutCreateWindow(argv[0]);
   glewInit();
   glutReshapeFunc( Reshape );
   glutKeyboardFunc( Key );
   glutSpecialFunc( SpecialKey );
   if (Anim)
      glutIdleFunc(Idle);
   else
      glutIdleFunc(NULL);
   glutDisplayFunc( Display );
   Init();
   glutMainLoop();
   return 0;
}
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d32 1
a32 1
#define GL_GLEXT_PROTOTYPES
d35 1
a35 1
#define TEST_DISPLAY_LISTS 0
d38 3
a40 2
static GLfloat Xpos = 0;
static GLuint OccQuery;
a57 1
   static int sign = +1;
d60 1
d67 5
a71 2
   step = (time - lastTime) / 1000.0 * sign;
   lastTime = time;
d73 8
a80 1
   Xpos += step;
a81 7
   if (Xpos > 2.5) {
      Xpos = 2.5;
      sign = -1;
   }
   else if (Xpos < -2.5) {
      Xpos = -2.5;
      sign = +1;
d83 3
d92 1
a92 3
   GLuint passed;
   GLint ready;
   char s[100];
d94 1
d105 1
a105 1
   glColor3f(0, 0.6, 0.8);
d107 8
a114 9
   glVertex2f(-1.6, -1.5);
   glVertex2f(-0.4, -1.5);
   glVertex2f(-0.4,  1.5);
   glVertex2f(-1.6,  1.5);

   glVertex2f( 0.4, -1.5);
   glVertex2f( 1.6, -1.5);
   glVertex2f( 1.6,  1.5);
   glVertex2f( 0.4,  1.5);
a116 15
   /* draw the test polygon with occlusion testing */
   glPushMatrix();
   glTranslatef(Xpos, 0, -0.5);
   glScalef(0.3, 0.3, 1.0);
   glRotatef(-90.0 * Xpos, 0, 0, 1);

#if defined(GL_ARB_occlusion_query)
#if TEST_DISPLAY_LISTS
   glNewList(10, GL_COMPILE);
   glBeginQueryARB(GL_SAMPLES_PASSED_ARB, OccQuery);
   glEndList();
   glCallList(10);
#else
   glBeginQueryARB(GL_SAMPLES_PASSED_ARB, OccQuery);
#endif
d121 15
a135 6
   glBegin(GL_POLYGON);
   glVertex3f(-1, -1, 0);
   glVertex3f( 1, -1, 0);
   glVertex3f( 1,  1, 0);
   glVertex3f(-1,  1, 0);
   glEnd();
d137 2
a138 14
#if TEST_DISPLAY_LISTS
   glNewList(11, GL_COMPILE);
   glEndQueryARB(GL_SAMPLES_PASSED_ARB);
   glEndList();
   glCallList(11);
#else
   glEndQueryARB(GL_SAMPLES_PASSED_ARB);
#endif

   do {
      /* do useful work here, if any */
      glGetQueryObjectivARB(OccQuery, GL_QUERY_RESULT_AVAILABLE_ARB, &ready);
   } while (!ready);
   glGetQueryObjectuivARB(OccQuery, GL_QUERY_RESULT_ARB, &passed);
a139 1
   /* turn off occlusion testing */
a141 12
#endif /* GL_ARB_occlusion_query */

   /* draw the orange rect, so we can see what's going on */
   glColor3f(0.8, 0.5, 0);
   glBegin(GL_POLYGON);
   glVertex3f(-1, -1, 0);
   glVertex3f( 1, -1, 0);
   glVertex3f( 1,  1, 0);
   glVertex3f(-1,  1, 0);
   glEnd();

   glPopMatrix();
d143 40
a182 21

   /* Print result message */
   glMatrixMode( GL_PROJECTION );
   glLoadIdentity();
   glOrtho( -1.0, 1.0, -1.0, 1.0, -1.0, 1.0 );
   glMatrixMode( GL_MODELVIEW );
   glLoadIdentity();

   glColor3f(1, 1, 1);
#if defined(GL_ARB_occlusion_query)
   sprintf(s, " %4d Fragments Visible", passed);
   glRasterPos3f(-0.50, -0.7, 0);
   PrintString(s);
   if (!passed) {
      glRasterPos3f(-0.25, -0.8, 0);
      PrintString("Fully Occluded");
   }
#else
   glRasterPos3f(-0.25, -0.8, 0);
   PrintString("GL_ARB_occlusion_query not available at compile time");
#endif /* GL_ARB_occlusion_query */
d218 1
d223 2
a224 1
         Xpos -= step;
d227 2
a228 1
         Xpos += step;
d239 1
a245 1
#if defined(GL_ARB_occlusion_query)
a250 1
#endif /* GL_ARB_occlusion_query */
d255 1
a255 4
#if defined(GL_ARB_occlusion_query)
   glGenQueriesARB(1, &OccQuery);
   assert(OccQuery > 0);
#endif /* GL_ARB_occlusion_query */
d258 8
d271 1
a272 2
   glutInitWindowPosition( 0, 0 );
   glutInitWindowSize( 400, 400 );
d275 1
d279 4
a282 1
   glutIdleFunc( Idle );
@


1.1
log
@Initial revision
@
text
@d40 1
a40 1

d207 1
d275 1
a275 1
   glutCreateWindow(argv[0]);
@


1.1.1.1
log
@Import MesaDemos 6.5.1
@
text
@@
