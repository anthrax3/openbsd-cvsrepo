head	1.3;
access;
symbols
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2011.05.31.18.50.20;	author matthieu;	state dead;
branches;
next	1.2;

1.2
date	2010.05.22.20.05.55;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.07;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove MesaDemos contents. Not used by Xenocara builds anymore.
@
text
@/*
 * Exercise EGL API functions
 */

#define EGL_EGLEXT_PROTOTYPES

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <EGL/egl.h>
#include <EGL/eglext.h>
#include <GLES/gl.h>

/*#define FRONTBUFFER*/

static void _subset_Rectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2,
                          GLfloat r, GLfloat g, GLfloat b)
{
   GLfloat v[4][2], c[4][4];
   int i;

   v[0][0] = x1;   v[0][1] = y1;
   v[1][0] = x2;   v[1][1] = y1;
   v[2][0] = x2;   v[2][1] = y2;
   v[3][0] = x1;   v[3][1] = y2;

   for (i = 0; i < 4; i++) {
      c[i][0] = r;
      c[i][1] = g;
      c[i][2] = b;
      c[i][3] = 1.0;
   }

   glVertexPointer(2, GL_FLOAT, 0, v);
   glColorPointer(4, GL_FLOAT, 0, v);
   glEnableClientState(GL_VERTEX_ARRAY);
   glEnableClientState(GL_COLOR_ARRAY);

   glDrawArrays(GL_TRIANGLE_FAN, 0, 4);

   glDisableClientState(GL_VERTEX_ARRAY);
   glDisableClientState(GL_COLOR_ARRAY);
}


static void redraw(EGLDisplay dpy, EGLSurface surf, int rot)
{
   GLfloat r, g, b;

   printf("Redraw event\n");

   glClearColor( rand()/(float)RAND_MAX, 
		 rand()/(float)RAND_MAX, 
		 rand()/(float)RAND_MAX,
		 1);

   glClear( GL_COLOR_BUFFER_BIT ); 

   r = rand()/(float)RAND_MAX;
   g = rand()/(float)RAND_MAX;
   b = rand()/(float)RAND_MAX;

   glPushMatrix();
   glRotatef(rot, 0, 0, 1);
   glScalef(.5, .5, .5);
   _subset_Rectf( -1, -1, 1, 1, r, g, b );
   glPopMatrix();

#ifdef FRONTBUFFER
   glFlush();
#else
   eglSwapBuffers( dpy, surf ); 
#endif
   glFinish();
}


/**
 * Test EGL_MESA_screen_surface functions
 */
static void
TestScreens(EGLDisplay dpy)
{
#define MAX 8
   EGLScreenMESA screens[MAX];
   EGLint numScreens;
   EGLint i;

   eglGetScreensMESA(dpy, screens, MAX, &numScreens);
   printf("Found %d screens\n", numScreens);
   for (i = 0; i < numScreens; i++) {
      printf(" Screen %d handle: %d\n", i, (int) screens[i]);
   }
}


int
main(int argc, char *argv[])
{
   int maj, min;
   EGLContext ctx;
   EGLSurface pbuffer, screen_surf;
   EGLConfig configs[10];
   EGLint numConfigs, i;
   EGLBoolean b;
   const EGLint pbufAttribs[] = {
      EGL_WIDTH, 500,
      EGL_HEIGHT, 500,
      EGL_NONE
   };
   EGLint screenAttribs[32];
   EGLModeMESA mode;
   EGLScreenMESA screen;
   EGLint count;

   EGLDisplay d = eglGetDisplay(EGL_DEFAULT_DISPLAY);
   assert(d);

   if (!eglInitialize(d, &maj, &min)) {
      printf("demo: eglInitialize failed\n");
      exit(1);
   }

   printf("EGL version = %d.%d\n", maj, min);
   printf("EGL_VENDOR = %s\n", eglQueryString(d, EGL_VENDOR));
   if (!strstr(eglQueryString(d, EGL_EXTENSIONS),
               "EGL_MESA_screen_surface")) {
      printf("EGL_MESA_screen_surface is not supported\n");
      exit(1);
   }

   eglGetConfigs(d, configs, 10, &numConfigs);
   printf("Got %d EGL configs:\n", numConfigs);
   for (i = 0; i < numConfigs; i++) {
      EGLint id, red, depth;
      eglGetConfigAttrib(d, configs[i], EGL_CONFIG_ID, &id);
      eglGetConfigAttrib(d, configs[i], EGL_RED_SIZE, &red);
      eglGetConfigAttrib(d, configs[i], EGL_DEPTH_SIZE, &depth);
      printf("%2d:  Red Size = %d  Depth Size = %d\n", id, red, depth);
   }
   
   eglGetScreensMESA(d, &screen, 1, &count);
   eglGetModesMESA(d, screen, &mode, 1, &count);

   eglBindAPI(EGL_OPENGL_API);
   ctx = eglCreateContext(d, configs[0], EGL_NO_CONTEXT, NULL);
   if (ctx == EGL_NO_CONTEXT) {
      printf("failed to create context\n");
      return 0;
   }

   pbuffer = eglCreatePbufferSurface(d, configs[0], pbufAttribs);
   if (pbuffer == EGL_NO_SURFACE) {
      printf("failed to create pbuffer\n");
      return 0;
   }

   b = eglMakeCurrent(d, pbuffer, pbuffer, ctx);
   if (!b) {
      printf("make current failed\n");
      return 0;
   }

   b = eglMakeCurrent(d, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);

   i = 0;
   screenAttribs[i++] = EGL_WIDTH;
   eglGetModeAttribMESA(d, mode, EGL_WIDTH, &screenAttribs[i++]);
   screenAttribs[i++] = EGL_HEIGHT;
   eglGetModeAttribMESA(d, mode, EGL_HEIGHT, &screenAttribs[i++]);
   screenAttribs[i] = EGL_NONE;

   screen_surf = eglCreateScreenSurfaceMESA(d, configs[0], screenAttribs);
   if (screen_surf == EGL_NO_SURFACE) {
      printf("failed to create screen surface\n");
      return 0;
   }
   
   eglShowScreenSurfaceMESA(d, screen, screen_surf, mode);

   b = eglMakeCurrent(d, screen_surf, screen_surf, ctx);
   if (!b) {
      printf("make current failed\n");
      return 0;
   }

   glViewport(0, 0, 1024, 768);

   glClearColor( 0, 
		 1.0, 
		 0,
		 1);

   glClear( GL_COLOR_BUFFER_BIT ); 
   
      
   TestScreens(d);

   glShadeModel( GL_FLAT );
   
   for (i = 0; i < 6; i++) {
      redraw(d, screen_surf, i*10 );

      printf("sleep(1)\n");   
      sleep(1);  
   }

   eglDestroySurface(d, pbuffer);
   eglDestroyContext(d, ctx);
   eglTerminate(d);

   return 0;
}
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d5 2
d10 1
d13 3
a15 1
#include <GLES/egl.h>
d19 2
a20 1
static void _subset_Rectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
d22 24
a45 6
   glBegin( GL_QUADS );
   glVertex2f( x1, y1 );
   glVertex2f( x2, y1 );
   glVertex2f( x2, y2 );
   glVertex2f( x1, y2 );
   glEnd();
d51 2
a54 6
#ifdef FRONTBUFFER
    glDrawBuffer( GL_FRONT ); 
#else
    glDrawBuffer( GL_BACK );
#endif

d62 4
a65 3
   glColor3f( rand()/(float)RAND_MAX, 
	      rand()/(float)RAND_MAX, 
	      rand()/(float)RAND_MAX );
d69 1
a69 1
   _subset_Rectf( -1, -1, 1, 1 );
d114 1
a114 5
   const EGLint screenAttribs[] = {
      EGL_WIDTH, 1024,
      EGL_HEIGHT, 768,
      EGL_NONE
   };
a118 1
   /*
a119 2
   */
   EGLDisplay d = eglGetDisplay("!fb_dri");
d129 5
d148 1
d169 7
a190 1
   glDrawBuffer( GL_FRONT ); 
@

