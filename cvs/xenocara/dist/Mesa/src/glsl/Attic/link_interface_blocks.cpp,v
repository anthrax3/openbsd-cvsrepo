head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.2
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.14.17;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.14.17;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.30;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.10.23;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.47.30;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2013 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * \file link_interface_blocks.cpp
 * Linker support for GLSL's interface blocks.
 */

#include "ir.h"
#include "glsl_symbol_table.h"
#include "linker.h"
#include "main/macros.h"

bool
validate_intrastage_interface_blocks(const gl_shader **shader_list,
                                     unsigned num_shaders)
{
   glsl_symbol_table interfaces;

   for (unsigned int i = 0; i < num_shaders; i++) {
      if (shader_list[i] == NULL)
         continue;

      foreach_list(node, shader_list[i]->ir) {
         ir_variable *var = ((ir_instruction *) node)->as_variable();
         if (!var)
            continue;

         const glsl_type *iface_type = var->interface_type;

         if (iface_type == NULL)
            continue;

         const glsl_type *old_iface_type =
            interfaces.get_interface(iface_type->name,
                                     (enum ir_variable_mode) var->mode);

         if (old_iface_type == NULL) {
            /* This is the first time we've seen the interface, so save
             * it into our symbol table.
             */
            interfaces.add_interface(iface_type->name, iface_type,
                                     (enum ir_variable_mode) var->mode);
         } else if (old_iface_type != iface_type) {
            return false;
         }
      }
   }

   return true;
}

bool
validate_interstage_interface_blocks(const gl_shader *producer,
                                     const gl_shader *consumer)
{
   glsl_symbol_table interfaces;

   /* Add non-output interfaces from the consumer to the symbol table. */
   foreach_list(node, consumer->ir) {
      ir_variable *var = ((ir_instruction *) node)->as_variable();
      if (!var || !var->interface_type || var->mode == ir_var_shader_out)
         continue;

      interfaces.add_interface(var->interface_type->name,
                               var->interface_type,
                               (enum ir_variable_mode) var->mode);
   }

   /* Verify that the producer's interfaces match. */
   foreach_list(node, producer->ir) {
      ir_variable *var = ((ir_instruction *) node)->as_variable();
      if (!var || !var->interface_type || var->mode == ir_var_shader_in)
         continue;

      enum ir_variable_mode consumer_mode =
         var->mode == ir_var_uniform ? ir_var_uniform : ir_var_shader_in;
      const glsl_type *expected_type =
         interfaces.get_interface(var->interface_type->name, consumer_mode);

      /* The consumer doesn't use this output block.  Ignore it. */
      if (expected_type == NULL)
         continue;

      if (var->interface_type != expected_type)
         return false;
   }

   return true;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@a32 1
#include "program/hash_table.h"
a33 113

namespace {

/**
 * Information about a single interface block definition that we need to keep
 * track of in order to check linkage rules.
 *
 * Note: this class is expected to be short lived, so it doesn't make copies
 * of the strings it references; it simply borrows the pointers from the
 * ir_variable class.
 */
struct interface_block_definition
{
   /**
    * Extract an interface block definition from an ir_variable that
    * represents either the interface instance (for named interfaces), or a
    * member of the interface (for unnamed interfaces).
    */
   explicit interface_block_definition(const ir_variable *var)
      : type(var->get_interface_type()),
        instance_name(NULL),
        array_size(-1)
   {
      if (var->is_interface_instance()) {
         instance_name = var->name;
         if (var->type->is_array())
            array_size = var->type->length;
      }
      explicitly_declared = (var->data.how_declared != ir_var_declared_implicitly);
   }

   /**
    * Interface block type
    */
   const glsl_type *type;

   /**
    * For a named interface block, the instance name.  Otherwise NULL.
    */
   const char *instance_name;

   /**
    * For an interface block array, the array size (or 0 if unsized).
    * Otherwise -1.
    */
   int array_size;

   /**
    * True if this interface block was explicitly declared in the shader;
    * false if it was an implicitly declared built-in interface block.
    */
   bool explicitly_declared;
};


/**
 * Check if two interfaces match, according to intrastage interface matching
 * rules.  If they do, and the first interface uses an unsized array, it will
 * be updated to reflect the array size declared in the second interface.
 */
bool
intrastage_match(interface_block_definition *a,
                 const interface_block_definition *b,
                 ir_variable_mode mode)
{
   /* Types must match. */
   if (a->type != b->type) {
      /* Exception: if both the interface blocks are implicitly declared,
       * don't force their types to match.  They might mismatch due to the two
       * shaders using different GLSL versions, and that's ok.
       */
      if (a->explicitly_declared || b->explicitly_declared)
         return false;
   }

   /* Presence/absence of interface names must match. */
   if ((a->instance_name == NULL) != (b->instance_name == NULL))
      return false;

   /* For uniforms, instance names need not match.  For shader ins/outs,
    * it's not clear from the spec whether they need to match, but
    * Mesa's implementation relies on them matching.
    */
   if (a->instance_name != NULL && mode != ir_var_uniform &&
       strcmp(a->instance_name, b->instance_name) != 0) {
      return false;
   }

   /* Array vs. nonarray must be consistent, and sizes must be
    * consistent, with the exception that unsized arrays match sized
    * arrays.
    */
   if ((a->array_size == -1) != (b->array_size == -1))
      return false;
   if (b->array_size != 0) {
      if (a->array_size == 0)
         a->array_size = b->array_size;
      else if (a->array_size != b->array_size)
         return false;
   }

   return true;
}


/**
 * Check if two interfaces match, according to interstage (in/out) interface
 * matching rules.
 *
 * If \c extra_array_level is true, then vertex-to-geometry shader matching
 * rules are enforced (i.e. a successful match requires the consumer interface
 * to be an array and the producer interface to be a non-array).
 */
d35 1
a35 103
interstage_match(const interface_block_definition *producer,
                 const interface_block_definition *consumer,
                 bool extra_array_level)
{
   /* Unsized arrays should not occur during interstage linking.  They
    * should have all been assigned a size by link_intrastage_shaders.
    */
   assert(consumer->array_size != 0);
   assert(producer->array_size != 0);

   /* Types must match. */
   if (consumer->type != producer->type) {
      /* Exception: if both the interface blocks are implicitly declared,
       * don't force their types to match.  They might mismatch due to the two
       * shaders using different GLSL versions, and that's ok.
       */
      if (consumer->explicitly_declared || producer->explicitly_declared)
         return false;
   }
   if (extra_array_level) {
      /* Consumer must be an array, and producer must not. */
      if (consumer->array_size == -1)
         return false;
      if (producer->array_size != -1)
         return false;
   } else {
      /* Array vs. nonarray must be consistent, and sizes must be consistent.
       * Since unsized arrays have been ruled out, we can check this by just
       * making sure the sizes are equal.
       */
      if (consumer->array_size != producer->array_size)
         return false;
   }
   return true;
}


/**
 * This class keeps track of a mapping from an interface block name to the
 * necessary information about that interface block to determine whether to
 * generate a link error.
 *
 * Note: this class is expected to be short lived, so it doesn't make copies
 * of the strings it references; it simply borrows the pointers from the
 * ir_variable class.
 */
class interface_block_definitions
{
public:
   interface_block_definitions()
      : mem_ctx(ralloc_context(NULL)),
        ht(hash_table_ctor(0, hash_table_string_hash,
                           hash_table_string_compare))
   {
   }

   ~interface_block_definitions()
   {
      hash_table_dtor(ht);
      ralloc_free(mem_ctx);
   }

   /**
    * Lookup the interface definition having the given block name.  Return
    * NULL if none is found.
    */
   interface_block_definition *lookup(const char *block_name)
   {
      return (interface_block_definition *) hash_table_find(ht, block_name);
   }

   /**
    * Add a new interface definition.
    */
   void store(const interface_block_definition &def)
   {
      interface_block_definition *hash_entry =
         rzalloc(mem_ctx, interface_block_definition);
      *hash_entry = def;
      hash_table_insert(ht, hash_entry, def.type->name);
   }

private:
   /**
    * Ralloc context for data structures allocated by this class.
    */
   void *mem_ctx;

   /**
    * Hash table mapping interface block name to an \c
    * interface_block_definition struct.  interface_block_definition structs
    * are allocated using \c mem_ctx.
    */
   hash_table *ht;
};


}; /* anonymous namespace */


void
validate_intrastage_interface_blocks(struct gl_shader_program *prog,
                                     const gl_shader **shader_list,
d38 1
a38 3
   interface_block_definitions in_interfaces;
   interface_block_definitions out_interfaces;
   interface_block_definitions uniform_interfaces;
d49 1
a49 1
         const glsl_type *iface_type = var->get_interface_type();
d54 3
a56 22
         interface_block_definitions *definitions;
         switch (var->data.mode) {
         case ir_var_shader_in:
            definitions = &in_interfaces;
            break;
         case ir_var_shader_out:
            definitions = &out_interfaces;
            break;
         case ir_var_uniform:
            definitions = &uniform_interfaces;
            break;
         default:
            /* Only in, out, and uniform interfaces are legal, so we should
             * never get here.
             */
            assert(!"illegal interface type");
            continue;
         }

         const interface_block_definition def(var);
         interface_block_definition *prev_def =
            definitions->lookup(iface_type->name);
d58 1
a58 1
         if (prev_def == NULL) {
d60 1
a60 1
             * it into the appropriate data structure.
d62 4
a65 6
            definitions->store(def);
         } else if (!intrastage_match(prev_def, &def,
                                      (ir_variable_mode) var->data.mode)) {
            linker_error(prog, "definitions of interface block `%s' do not"
                         " match\n", iface_type->name);
            return;
d69 2
d73 3
a75 4
void
validate_interstage_inout_blocks(struct gl_shader_program *prog,
                                 const gl_shader *producer,
                                 const gl_shader *consumer)
d77 1
a77 2
   interface_block_definitions definitions;
   const bool extra_array_level = consumer->Stage == MESA_SHADER_GEOMETRY;
d79 1
a79 1
   /* Add input interfaces from the consumer to the symbol table. */
d82 1
a82 1
      if (!var || !var->get_interface_type() || var->data.mode != ir_var_shader_in)
d85 3
a87 1
      definitions.store(interface_block_definition(var));
d90 1
a90 1
   /* Verify that the producer's output interfaces match. */
d93 1
a93 1
      if (!var || !var->get_interface_type() || var->data.mode != ir_var_shader_out)
d96 4
a99 2
      interface_block_definition *consumer_def =
         definitions.lookup(var->get_interface_type()->name);
d102 1
a102 1
      if (consumer_def == NULL)
d105 2
a106 7
      const interface_block_definition producer_def(var);

      if (!interstage_match(&producer_def, consumer_def, extra_array_level)) {
         linker_error(prog, "definitions of interface block `%s' do not "
                      "match\n", var->get_interface_type()->name);
         return;
      }
a107 1
}
d109 1
a109 35

void
validate_interstage_uniform_blocks(struct gl_shader_program *prog,
                                   gl_shader **stages, int num_stages)
{
   interface_block_definitions definitions;

   for (int i = 0; i < num_stages; i++) {
      if (stages[i] == NULL)
         continue;

      const gl_shader *stage = stages[i];
      foreach_list(node, stage->ir) {
         ir_variable *var = ((ir_instruction *) node)->as_variable();
         if (!var || !var->get_interface_type() || var->data.mode != ir_var_uniform)
            continue;

         interface_block_definition *old_def =
            definitions.lookup(var->get_interface_type()->name);
         const interface_block_definition new_def(var);
         if (old_def == NULL) {
            definitions.store(new_def);
         } else {
            /* Interstage uniform matching rules are the same as intrastage
             * uniform matchin rules (for uniforms, it is as though all
             * shaders are in the same shader stage).
             */
            if (!intrastage_match(old_def, &new_def, ir_var_uniform)) {
               linker_error(prog, "definitions of interface block `%s' do not "
                            "match\n", var->get_interface_type()->name);
               return;
            }
         }
      }
   }
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d262 2
a263 2
      foreach_in_list(ir_instruction, node, shader_list[i]->ir) {
         ir_variable *var = node->as_variable();
d319 2
a320 2
   foreach_in_list(ir_instruction, node, consumer->ir) {
      ir_variable *var = node->as_variable();
d328 2
a329 2
   foreach_in_list(ir_instruction, node, producer->ir) {
      ir_variable *var = node->as_variable();
d362 2
a363 2
      foreach_in_list(ir_instruction, node, stage->ir) {
         ir_variable *var = node->as_variable();
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d262 2
a263 2
      foreach_list(node, shader_list[i]->ir) {
         ir_variable *var = ((ir_instruction *) node)->as_variable();
d319 2
a320 2
   foreach_list(node, consumer->ir) {
      ir_variable *var = ((ir_instruction *) node)->as_variable();
d328 2
a329 2
   foreach_list(node, producer->ir) {
      ir_variable *var = ((ir_instruction *) node)->as_variable();
d362 2
a363 2
      foreach_list(node, stage->ir) {
         ir_variable *var = ((ir_instruction *) node)->as_variable();
@


