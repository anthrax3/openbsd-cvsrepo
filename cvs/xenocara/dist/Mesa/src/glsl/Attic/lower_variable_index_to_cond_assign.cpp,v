head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.44;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.28;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.21;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.31;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.28;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.34;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Luca Barbieri
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * \file lower_variable_index_to_cond_assign.cpp
 *
 * Turns non-constant indexing into array types to a series of
 * conditional moves of each element into a temporary.
 *
 * Pre-DX10 GPUs often don't have a native way to do this operation,
 * and this works around that.
 *
 * The lowering process proceeds as follows.  Each non-constant index
 * found in an r-value is converted to a canonical form \c array[i].  Each
 * element of the array is conditionally assigned to a temporary by comparing
 * \c i to a constant index.  This is done by cloning the canonical form and
 * replacing all occurances of \c i with a constant.  Each remaining occurance
 * of the canonical form in the IR is replaced with a dereference of the
 * temporary variable.
 *
 * L-values with non-constant indices are handled similarly.  In this case,
 * the RHS of the assignment is assigned to a temporary.  The non-constant
 * index is replace with the canonical form (just like for r-values).  The
 * temporary is conditionally assigned to each element of the canonical form
 * by comparing \c i with each index.  The same clone-and-replace scheme is
 * used.
 */

#include "ir.h"
#include "ir_rvalue_visitor.h"
#include "ir_optimization.h"
#include "glsl_types.h"
#include "main/macros.h"

/**
 * Generate a comparison value for a block of indices
 *
 * Lowering passes for non-constant indexing of arrays, matrices, or vectors
 * can use this to generate blocks of index comparison values.
 *
 * \param instructions  List where new instructions will be appended
 * \param index         \c ir_variable containing the desired index
 * \param base          Base value for this block of comparisons
 * \param components    Number of unique index values to compare.  This must
 *                      be on the range [1, 4].
 * \param mem_ctx       ralloc memory context to be used for all allocations.
 *
 * \returns
 * An \c ir_rvalue that \b must be cloned for each use in conditional
 * assignments, etc.
 */
ir_rvalue *
compare_index_block(exec_list *instructions, ir_variable *index,
		    unsigned base, unsigned components, void *mem_ctx)
{
   ir_rvalue *broadcast_index = new(mem_ctx) ir_dereference_variable(index);

   assert(index->type->is_scalar());
   assert(index->type->base_type == GLSL_TYPE_INT);
   assert(components >= 1 && components <= 4);

   if (components > 1) {
      const ir_swizzle_mask m = { 0, 0, 0, 0, components, false };
      broadcast_index = new(mem_ctx) ir_swizzle(broadcast_index, m);
   }

   /* Compare the desired index value with the next block of four indices.
    */
   ir_constant_data test_indices_data;
   memset(&test_indices_data, 0, sizeof(test_indices_data));
   test_indices_data.i[0] = base;
   test_indices_data.i[1] = base + 1;
   test_indices_data.i[2] = base + 2;
   test_indices_data.i[3] = base + 3;

   ir_constant *const test_indices =
      new(mem_ctx) ir_constant(broadcast_index->type,
			       &test_indices_data);

   ir_rvalue *const condition_val =
      new(mem_ctx) ir_expression(ir_binop_equal,
				 glsl_type::bvec(components),
				 broadcast_index,
				 test_indices);

   ir_variable *const condition =
      new(mem_ctx) ir_variable(condition_val->type,
			       "dereference_condition",
			       ir_var_temporary);
   instructions->push_tail(condition);

   ir_rvalue *const cond_deref =
      new(mem_ctx) ir_dereference_variable(condition);
   instructions->push_tail(new(mem_ctx) ir_assignment(cond_deref, condition_val, 0));

   return cond_deref;
}

static inline bool
is_array_or_matrix(const ir_rvalue *ir)
{
   return (ir->type->is_array() || ir->type->is_matrix());
}

namespace {
/**
 * Replace a dereference of a variable with a specified r-value
 *
 * Each time a dereference of the specified value is replaced, the r-value
 * tree is cloned.
 */
class deref_replacer : public ir_rvalue_visitor {
public:
   deref_replacer(const ir_variable *variable_to_replace, ir_rvalue *value)
      : variable_to_replace(variable_to_replace), value(value),
	progress(false)
   {
      assert(this->variable_to_replace != NULL);
      assert(this->value != NULL);
   }

   virtual void handle_rvalue(ir_rvalue **rvalue)
   {
      ir_dereference_variable *const dv = (*rvalue)->as_dereference_variable();

      if ((dv != NULL) && (dv->var == this->variable_to_replace)) {
	 this->progress = true;
	 *rvalue = this->value->clone(ralloc_parent(*rvalue), NULL);
      }
   }

   const ir_variable *variable_to_replace;
   ir_rvalue *value;
   bool progress;
};

/**
 * Find a variable index dereference of an array in an rvalue tree
 */
class find_variable_index : public ir_hierarchical_visitor {
public:
   find_variable_index()
      : deref(NULL)
   {
      /* empty */
   }

   virtual ir_visitor_status visit_enter(ir_dereference_array *ir)
   {
      if (is_array_or_matrix(ir->array)
	  && (ir->array_index->as_constant() == NULL)) {
	 this->deref = ir;
	 return visit_stop;
      }

      return visit_continue;
   }

   /**
    * First array dereference found in the tree that has a non-constant index.
    */
   ir_dereference_array *deref;
};

struct assignment_generator
{
   ir_instruction* base_ir;
   ir_dereference *rvalue;
   ir_variable *old_index;
   bool is_write;
   unsigned int write_mask;
   ir_variable* var;

   assignment_generator()
      : base_ir(NULL),
        rvalue(NULL),
        old_index(NULL),
        is_write(false),
        write_mask(0),
        var(NULL)
   {
   }

   void generate(unsigned i, ir_rvalue* condition, exec_list *list) const
   {
      /* Just clone the rest of the deref chain when trying to get at the
       * underlying variable.
       */
      void *mem_ctx = ralloc_parent(base_ir);

      /* Clone the old r-value in its entirety.  Then replace any occurances of
       * the old variable index with the new constant index.
       */
      ir_dereference *element = this->rvalue->clone(mem_ctx, NULL);
      ir_constant *const index = new(mem_ctx) ir_constant(i);
      deref_replacer r(this->old_index, index);
      element->accept(&r);
      assert(r.progress);

      /* Generate a conditional assignment to (or from) the constant indexed
       * array dereference.
       */
      ir_rvalue *variable = new(mem_ctx) ir_dereference_variable(this->var);
      ir_assignment *const assignment = (is_write)
	 ? new(mem_ctx) ir_assignment(element, variable, condition, write_mask)
	 : new(mem_ctx) ir_assignment(variable, element, condition);

      list->push_tail(assignment);
   }
};

struct switch_generator
{
   /* make TFunction a template parameter if you need to use other generators */
   typedef assignment_generator TFunction;
   const TFunction& generator;

   ir_variable* index;
   unsigned linear_sequence_max_length;
   unsigned condition_components;

   void *mem_ctx;

   switch_generator(const TFunction& generator, ir_variable *index,
		    unsigned linear_sequence_max_length,
		    unsigned condition_components)
      : generator(generator), index(index),
	linear_sequence_max_length(linear_sequence_max_length),
	condition_components(condition_components)
   {
      this->mem_ctx = ralloc_parent(index);
   }

   void linear_sequence(unsigned begin, unsigned end, exec_list *list)
   {
      if (begin == end)
         return;

      /* If the array access is a read, read the first element of this subregion
       * unconditionally.  The remaining tests will possibly overwrite this
       * value with one of the other array elements.
       *
       * This optimization cannot be done for writes because it will cause the
       * first element of the subregion to be written possibly *in addition* to
       * one of the other elements.
       */
      unsigned first;
      if (!this->generator.is_write) {
	 this->generator.generate(begin, 0, list);
	 first = begin + 1;
      } else {
	 first = begin;
      }

      for (unsigned i = first; i < end; i += 4) {
         const unsigned comps = MIN2(condition_components, end - i);

	 ir_rvalue *const cond_deref =
	    compare_index_block(list, index, i, comps, this->mem_ctx);

         if (comps == 1) {
            this->generator.generate(i, cond_deref->clone(this->mem_ctx, NULL),
				     list);
         } else {
            for (unsigned j = 0; j < comps; j++) {
	       ir_rvalue *const cond_swiz =
		  new(this->mem_ctx) ir_swizzle(cond_deref->clone(this->mem_ctx, NULL),
						j, 0, 0, 0, 1);

               this->generator.generate(i + j, cond_swiz, list);
            }
         }
      }
   }

   void bisect(unsigned begin, unsigned end, exec_list *list)
   {
      unsigned middle = (begin + end) >> 1;

      assert(index->type->is_integer());

      ir_constant *const middle_c = (index->type->base_type == GLSL_TYPE_UINT)
	 ? new(this->mem_ctx) ir_constant((unsigned)middle)
         : new(this->mem_ctx) ir_constant((int)middle);


      ir_dereference_variable *deref =
	 new(this->mem_ctx) ir_dereference_variable(this->index);

      ir_expression *less =
	 new(this->mem_ctx) ir_expression(ir_binop_less, glsl_type::bool_type,
					  deref, middle_c);

      ir_if *if_less = new(this->mem_ctx) ir_if(less);

      generate(begin, middle, &if_less->then_instructions);
      generate(middle, end, &if_less->else_instructions);

      list->push_tail(if_less);
   }

   void generate(unsigned begin, unsigned end, exec_list *list)
   {
      unsigned length = end - begin;
      if (length <= this->linear_sequence_max_length)
         return linear_sequence(begin, end, list);
      else
         return bisect(begin, end, list);
   }
};

/**
 * Visitor class for replacing expressions with ir_constant values.
 */

class variable_index_to_cond_assign_visitor : public ir_rvalue_visitor {
public:
   variable_index_to_cond_assign_visitor(bool lower_input,
					 bool lower_output,
					 bool lower_temp,
					 bool lower_uniform)
   {
      this->progress = false;
      this->lower_inputs = lower_input;
      this->lower_outputs = lower_output;
      this->lower_temps = lower_temp;
      this->lower_uniforms = lower_uniform;
   }

   bool progress;
   bool lower_inputs;
   bool lower_outputs;
   bool lower_temps;
   bool lower_uniforms;

   bool storage_type_needs_lowering(ir_dereference_array *deref) const
   {
      /* If a variable isn't eventually the target of this dereference, then
       * it must be a constant or some sort of anonymous temporary storage.
       *
       * FINISHME: Is this correct?  Most drivers treat arrays of constants as
       * FINISHME: uniforms.  It seems like this should do the same.
       */
      const ir_variable *const var = deref->array->variable_referenced();
      if (var == NULL)
	 return this->lower_temps;

      switch (var->data.mode) {
      case ir_var_auto:
      case ir_var_temporary:
	 return this->lower_temps;
      case ir_var_uniform:
	 return this->lower_uniforms;
      case ir_var_function_in:
      case ir_var_const_in:
         return this->lower_temps;
      case ir_var_shader_in:
         return this->lower_inputs;
      case ir_var_function_out:
         return this->lower_temps;
      case ir_var_shader_out:
         return this->lower_outputs;
      case ir_var_function_inout:
	 return this->lower_temps;
      }

      assert(!"Should not get here.");
      return false;
   }

   bool needs_lowering(ir_dereference_array *deref) const
   {
      if (deref == NULL || deref->array_index->as_constant()
	  || !is_array_or_matrix(deref->array))
	 return false;

      return this->storage_type_needs_lowering(deref);
   }

   ir_variable *convert_dereference_array(ir_dereference_array *orig_deref,
					  ir_assignment* orig_assign,
					  ir_dereference *orig_base)
   {
      assert(is_array_or_matrix(orig_deref->array));

      const unsigned length = (orig_deref->array->type->is_array())
         ? orig_deref->array->type->length
         : orig_deref->array->type->matrix_columns;

      void *const mem_ctx = ralloc_parent(base_ir);

      /* Temporary storage for either the result of the dereference of
       * the array, or the RHS that's being assigned into the
       * dereference of the array.
       */
      ir_variable *var;

      if (orig_assign) {
	 var = new(mem_ctx) ir_variable(orig_assign->rhs->type,
					"dereference_array_value",
					ir_var_temporary);
	 base_ir->insert_before(var);

	 ir_dereference *lhs = new(mem_ctx) ir_dereference_variable(var);
	 ir_assignment *assign = new(mem_ctx) ir_assignment(lhs,
							    orig_assign->rhs,
							    NULL);

         base_ir->insert_before(assign);
      } else {
	 var = new(mem_ctx) ir_variable(orig_deref->type,
					"dereference_array_value",
					ir_var_temporary);
	 base_ir->insert_before(var);
      }

      /* Store the index to a temporary to avoid reusing its tree. */
      ir_variable *index =
	 new(mem_ctx) ir_variable(orig_deref->array_index->type,
				  "dereference_array_index", ir_var_temporary);
      base_ir->insert_before(index);

      ir_dereference *lhs = new(mem_ctx) ir_dereference_variable(index);
      ir_assignment *assign =
	 new(mem_ctx) ir_assignment(lhs, orig_deref->array_index, NULL);
      base_ir->insert_before(assign);

      orig_deref->array_index = lhs->clone(mem_ctx, NULL);

      assignment_generator ag;
      ag.rvalue = orig_base;
      ag.base_ir = base_ir;
      ag.old_index = index;
      ag.var = var;
      if (orig_assign) {
	 ag.is_write = true;
	 ag.write_mask = orig_assign->write_mask;
      } else {
	 ag.is_write = false;
      }

      switch_generator sg(ag, index, 4, 4);

      /* If the original assignment has a condition, respect that original
       * condition!  This is acomplished by wrapping the new conditional
       * assignments in an if-statement that uses the original condition.
       */
      if ((orig_assign != NULL) && (orig_assign->condition != NULL)) {
	 /* No need to clone the condition because the IR that it hangs on is
	  * going to be removed from the instruction sequence.
	  */
	 ir_if *if_stmt = new(mem_ctx) ir_if(orig_assign->condition);

	 sg.generate(0, length, &if_stmt->then_instructions);
	 base_ir->insert_before(if_stmt);
      } else {
	 exec_list list;

	 sg.generate(0, length, &list);
	 base_ir->insert_before(&list);
      }

      return var;
   }

   virtual void handle_rvalue(ir_rvalue **pir)
   {
      if (this->in_assignee)
	 return;

      if (!*pir)
         return;

      ir_dereference_array* orig_deref = (*pir)->as_dereference_array();
      if (needs_lowering(orig_deref)) {
         ir_variable *var =
	    convert_dereference_array(orig_deref, NULL, orig_deref);
         assert(var);
         *pir = new(ralloc_parent(base_ir)) ir_dereference_variable(var);
         this->progress = true;
      }
   }

   ir_visitor_status
   visit_leave(ir_assignment *ir)
   {
      ir_rvalue_visitor::visit_leave(ir);

      find_variable_index f;
      ir->lhs->accept(&f);

      if ((f.deref != NULL) && storage_type_needs_lowering(f.deref)) {
         convert_dereference_array(f.deref, ir, ir->lhs);
         ir->remove();
         this->progress = true;
      }

      return visit_continue;
   }
};

} /* anonymous namespace */

bool
lower_variable_index_to_cond_assign(exec_list *instructions,
				    bool lower_input,
				    bool lower_output,
				    bool lower_temp,
				    bool lower_uniform)
{
   variable_index_to_cond_assign_visitor v(lower_input,
					   lower_output,
					   lower_temp,
					   lower_uniform);

   /* Continue lowering until no progress is made.  If there are multiple
    * levels of indirection (e.g., non-constant indexing of array elements and
    * matrix columns of an array of matrix), each pass will only lower one
    * level of indirection.
    */
   bool progress_ever = false;
   do {
      v.progress = false;
      visit_list_elements(&v, instructions);
      progress_ever = v.progress || progress_ever;
   } while (v.progress);

   return progress_ever;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d79 1
a79 1
   assert(index->type->base_type == GLSL_TYPE_INT || index->type->base_type == GLSL_TYPE_UINT);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d79 1
a79 1
   assert(index->type->base_type == GLSL_TYPE_INT);
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d125 1
d195 6
d368 1
a368 1
      switch (var->mode) {
d521 2
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d55 64
d120 1
a120 1
is_array_or_matrix(const ir_instruction *ir)
a270 32
         ir_rvalue *broadcast_index =
	    new(this->mem_ctx) ir_dereference_variable(index);

         if (comps) {
	    const ir_swizzle_mask m = { 0, 0, 0, 0, comps, false };
	    broadcast_index = new(this->mem_ctx) ir_swizzle(broadcast_index, m);
	 }

	 /* Compare the desired index value with the next block of four indices.
	  */
         ir_constant_data test_indices_data;
         memset(&test_indices_data, 0, sizeof(test_indices_data));
         test_indices_data.i[0] = i;
         test_indices_data.i[1] = i + 1;
         test_indices_data.i[2] = i + 2;
         test_indices_data.i[3] = i + 3;
         ir_constant *const test_indices =
	    new(this->mem_ctx) ir_constant(broadcast_index->type,
					   &test_indices_data);

         ir_rvalue *const condition_val =
	    new(this->mem_ctx) ir_expression(ir_binop_equal,
					     &glsl_type::bool_type[comps - 1],
					     broadcast_index,
					     test_indices);

         ir_variable *const condition =
	    new(this->mem_ctx) ir_variable(condition_val->type,
					   "dereference_array_condition",
					   ir_var_temporary);
         list->push_tail(condition);

d272 1
a272 3
	    new(this->mem_ctx) ir_dereference_variable(condition);
         list->push_tail(new(this->mem_ctx) ir_assignment(cond_deref,
							  condition_val, 0));
d275 2
a276 4
	    ir_rvalue *const cond_deref =
	       new(this->mem_ctx) ir_dereference_variable(condition);

            this->generator.generate(i, cond_deref, list);
a278 2
	       ir_rvalue *const cond_deref =
		  new(this->mem_ctx) ir_dereference_variable(condition);
d280 2
a281 1
		  new(this->mem_ctx) ir_swizzle(cond_deref, j, 0, 0, 0, 1);
d367 1
a367 1
      case ir_var_in:
d369 8
a376 4
	 return (var->location == -1) ? this->lower_temps : this->lower_inputs;
      case ir_var_out:
	 return (var->location == -1) ? this->lower_temps : this->lower_outputs;
      case ir_var_inout:
@


1.1
log
@Initial revision
@
text
@d32 15
d55 65
d123 2
a124 1
   ir_rvalue* array;
d139 13
a151 3
      ir_dereference *element =
	 new(mem_ctx) ir_dereference_array(this->array->clone(mem_ctx, NULL),
					   new(mem_ctx) ir_constant(i));
d153 3
a155 8

      ir_assignment *assignment;
      if (is_write) {
	 assignment = new(mem_ctx) ir_assignment(element, variable, condition,
						 write_mask);
      } else {
	 assignment = new(mem_ctx) ir_assignment(variable, element, condition);
      }
d322 1
a322 1
   bool is_array_or_matrix(const ir_instruction *ir) const
d324 8
a331 10
      return (ir->type->is_array() || ir->type->is_matrix());
   }

   bool needs_lowering(ir_dereference_array *deref) const
   {
      if (deref == NULL || deref->array_index->as_constant()
	  || !is_array_or_matrix(deref->array))
	 return false;

      if (deref->array->ir_type == ir_type_constant)
a333 1
      const ir_variable *const var = deref->array->variable_referenced();
d341 1
d353 9
d363 2
a364 1
					  ir_assignment* orig_assign)
d410 2
d413 1
a413 1
      ag.array = orig_deref->array;
d415 1
d426 18
a443 3
      exec_list list;
      sg.generate(0, length, &list);
      base_ir->insert_before(&list);
d450 3
d458 2
a459 1
         ir_variable* var = convert_dereference_array(orig_deref, 0);
d471 2
a472 1
      ir_dereference_array *orig_deref = ir->lhs->as_dereference_array();
d474 2
a475 2
      if (needs_lowering(orig_deref)) {
         convert_dereference_array(orig_deref, ir);
d496 11
a506 1
   visit_list_elements(&v, instructions);
d508 1
a508 1
   return v.progress;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a31 15
 *
 * The lowering process proceeds as follows.  Each non-constant index
 * found in an r-value is converted to a canonical form \c array[i].  Each
 * element of the array is conditionally assigned to a temporary by comparing
 * \c i to a constant index.  This is done by cloning the canonical form and
 * replacing all occurances of \c i with a constant.  Each remaining occurance
 * of the canonical form in the IR is replaced with a dereference of the
 * temporary variable.
 *
 * L-values with non-constant indices are handled similarly.  In this case,
 * the RHS of the assignment is assigned to a temporary.  The non-constant
 * index is replace with the canonical form (just like for r-values).  The
 * temporary is conditionally assigned to each element of the canonical form
 * by comparing \c i with each index.  The same clone-and-replace scheme is
 * used.
a39 129
/**
 * Generate a comparison value for a block of indices
 *
 * Lowering passes for non-constant indexing of arrays, matrices, or vectors
 * can use this to generate blocks of index comparison values.
 *
 * \param instructions  List where new instructions will be appended
 * \param index         \c ir_variable containing the desired index
 * \param base          Base value for this block of comparisons
 * \param components    Number of unique index values to compare.  This must
 *                      be on the range [1, 4].
 * \param mem_ctx       ralloc memory context to be used for all allocations.
 *
 * \returns
 * An \c ir_rvalue that \b must be cloned for each use in conditional
 * assignments, etc.
 */
ir_rvalue *
compare_index_block(exec_list *instructions, ir_variable *index,
		    unsigned base, unsigned components, void *mem_ctx)
{
   ir_rvalue *broadcast_index = new(mem_ctx) ir_dereference_variable(index);

   assert(index->type->is_scalar());
   assert(index->type->base_type == GLSL_TYPE_INT);
   assert(components >= 1 && components <= 4);

   if (components > 1) {
      const ir_swizzle_mask m = { 0, 0, 0, 0, components, false };
      broadcast_index = new(mem_ctx) ir_swizzle(broadcast_index, m);
   }

   /* Compare the desired index value with the next block of four indices.
    */
   ir_constant_data test_indices_data;
   memset(&test_indices_data, 0, sizeof(test_indices_data));
   test_indices_data.i[0] = base;
   test_indices_data.i[1] = base + 1;
   test_indices_data.i[2] = base + 2;
   test_indices_data.i[3] = base + 3;

   ir_constant *const test_indices =
      new(mem_ctx) ir_constant(broadcast_index->type,
			       &test_indices_data);

   ir_rvalue *const condition_val =
      new(mem_ctx) ir_expression(ir_binop_equal,
				 glsl_type::bvec(components),
				 broadcast_index,
				 test_indices);

   ir_variable *const condition =
      new(mem_ctx) ir_variable(condition_val->type,
			       "dereference_condition",
			       ir_var_temporary);
   instructions->push_tail(condition);

   ir_rvalue *const cond_deref =
      new(mem_ctx) ir_dereference_variable(condition);
   instructions->push_tail(new(mem_ctx) ir_assignment(cond_deref, condition_val, 0));

   return cond_deref;
}

static inline bool
is_array_or_matrix(const ir_rvalue *ir)
{
   return (ir->type->is_array() || ir->type->is_matrix());
}

/**
 * Replace a dereference of a variable with a specified r-value
 *
 * Each time a dereference of the specified value is replaced, the r-value
 * tree is cloned.
 */
class deref_replacer : public ir_rvalue_visitor {
public:
   deref_replacer(const ir_variable *variable_to_replace, ir_rvalue *value)
      : variable_to_replace(variable_to_replace), value(value),
	progress(false)
   {
      assert(this->variable_to_replace != NULL);
      assert(this->value != NULL);
   }

   virtual void handle_rvalue(ir_rvalue **rvalue)
   {
      ir_dereference_variable *const dv = (*rvalue)->as_dereference_variable();

      if ((dv != NULL) && (dv->var == this->variable_to_replace)) {
	 this->progress = true;
	 *rvalue = this->value->clone(ralloc_parent(*rvalue), NULL);
      }
   }

   const ir_variable *variable_to_replace;
   ir_rvalue *value;
   bool progress;
};

/**
 * Find a variable index dereference of an array in an rvalue tree
 */
class find_variable_index : public ir_hierarchical_visitor {
public:
   find_variable_index()
      : deref(NULL)
   {
      /* empty */
   }

   virtual ir_visitor_status visit_enter(ir_dereference_array *ir)
   {
      if (is_array_or_matrix(ir->array)
	  && (ir->array_index->as_constant() == NULL)) {
	 this->deref = ir;
	 return visit_stop;
      }

      return visit_continue;
   }

   /**
    * First array dereference found in the tree that has a non-constant index.
    */
   ir_dereference_array *deref;
};

d43 1
a43 2
   ir_dereference *rvalue;
   ir_variable *old_index;
d58 4
d63 7
a69 16
      /* Clone the old r-value in its entirety.  Then replace any occurances of
       * the old variable index with the new constant index.
       */
      ir_dereference *element = this->rvalue->clone(mem_ctx, NULL);
      ir_constant *const index = new(mem_ctx) ir_constant(i);
      deref_replacer r(this->old_index, index);
      element->accept(&r);
      assert(r.progress);

      /* Generate a conditional assignment to (or from) the constant indexed
       * array dereference.
       */
      ir_rvalue *variable = new(mem_ctx) ir_dereference_variable(this->var);
      ir_assignment *const assignment = (is_write)
	 ? new(mem_ctx) ir_assignment(element, variable, condition, write_mask)
	 : new(mem_ctx) ir_assignment(variable, element, condition);
d121 32
d154 3
a156 1
	    compare_index_block(list, index, i, comps, this->mem_ctx);
d159 4
a162 2
            this->generator.generate(i, cond_deref->clone(this->mem_ctx, NULL),
				     list);
d165 2
d168 1
a168 2
		  new(this->mem_ctx) ir_swizzle(cond_deref->clone(this->mem_ctx, NULL),
						j, 0, 0, 0, 1);
d236 1
a236 1
   bool storage_type_needs_lowering(ir_dereference_array *deref) const
d238 10
a247 8
      /* If a variable isn't eventually the target of this dereference, then
       * it must be a constant or some sort of anonymous temporary storage.
       *
       * FINISHME: Is this correct?  Most drivers treat arrays of constants as
       * FINISHME: uniforms.  It seems like this should do the same.
       */
      const ir_variable *const var = deref->array->variable_referenced();
      if (var == NULL)
d250 1
d257 5
a261 10
      case ir_var_function_in:
      case ir_var_const_in:
         return this->lower_temps;
      case ir_var_shader_in:
         return this->lower_inputs;
      case ir_var_function_out:
         return this->lower_temps;
      case ir_var_shader_out:
         return this->lower_outputs;
      case ir_var_function_inout:
a268 9
   bool needs_lowering(ir_dereference_array *deref) const
   {
      if (deref == NULL || deref->array_index->as_constant()
	  || !is_array_or_matrix(deref->array))
	 return false;

      return this->storage_type_needs_lowering(deref);
   }

d270 1
a270 2
					  ir_assignment* orig_assign,
					  ir_dereference *orig_base)
a315 2
      orig_deref->array_index = lhs->clone(mem_ctx, NULL);

d317 1
a317 1
      ag.rvalue = orig_base;
a318 1
      ag.old_index = index;
d329 3
a331 18
      /* If the original assignment has a condition, respect that original
       * condition!  This is acomplished by wrapping the new conditional
       * assignments in an if-statement that uses the original condition.
       */
      if ((orig_assign != NULL) && (orig_assign->condition != NULL)) {
	 /* No need to clone the condition because the IR that it hangs on is
	  * going to be removed from the instruction sequence.
	  */
	 ir_if *if_stmt = new(mem_ctx) ir_if(orig_assign->condition);

	 sg.generate(0, length, &if_stmt->then_instructions);
	 base_ir->insert_before(if_stmt);
      } else {
	 exec_list list;

	 sg.generate(0, length, &list);
	 base_ir->insert_before(&list);
      }
a337 3
      if (this->in_assignee)
	 return;

d343 1
a343 2
         ir_variable *var =
	    convert_dereference_array(orig_deref, NULL, orig_deref);
d355 1
a355 2
      find_variable_index f;
      ir->lhs->accept(&f);
d357 2
a358 2
      if ((f.deref != NULL) && storage_type_needs_lowering(f.deref)) {
         convert_dereference_array(f.deref, ir, ir->lhs);
d379 1
a379 11
   /* Continue lowering until no progress is made.  If there are multiple
    * levels of indirection (e.g., non-constant indexing of array elements and
    * matrix columns of an array of matrix), each pass will only lower one
    * level of indirection.
    */
   bool progress_ever = false;
   do {
      v.progress = false;
      visit_list_elements(&v, instructions);
      progress_ever = v.progress || progress_ever;
   } while (v.progress);
d381 1
a381 1
   return progress_ever;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a124 1
namespace {
a193 6
      : base_ir(NULL),
        rvalue(NULL),
        old_index(NULL),
        is_write(false),
        write_mask(0),
        var(NULL)
d361 1
a361 1
      switch (var->data.mode) {
a513 2

} /* anonymous namespace */
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d79 1
a79 1
   assert(index->type->base_type == GLSL_TYPE_INT || index->type->base_type == GLSL_TYPE_UINT);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d79 1
a79 1
   assert(index->type->base_type == GLSL_TYPE_INT);
@


