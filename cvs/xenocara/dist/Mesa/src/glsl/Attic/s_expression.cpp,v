head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.44;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.58;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.29;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.23;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.32;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.31;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.37;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/* -*- c++ -*- */
/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <assert.h>
#include <limits>
#include "s_expression.h"

s_symbol::s_symbol(const char *str, size_t n)
{
   /* Assume the given string is already nul-terminated and in memory that
    * will live as long as this node.
    */
   assert(str[n] == '\0');
   this->str = str;
}

s_list::s_list()
{
}

static void
skip_whitespace(const char *&src, char *&symbol_buffer)
{
   size_t n = strspn(src, " \v\t\r\n");
   src += n;
   symbol_buffer += n;
   /* Also skip Scheme-style comments: semi-colon 'til end of line */
   if (src[0] == ';') {
      n = strcspn(src, "\n");
      src += n;
      symbol_buffer += n;
      skip_whitespace(src, symbol_buffer);
   }
}

static s_expression *
read_atom(void *ctx, const char *&src, char *&symbol_buffer)
{
   s_expression *expr = NULL;

   skip_whitespace(src, symbol_buffer);

   size_t n = strcspn(src, "( \v\t\r\n);");
   if (n == 0)
      return NULL; // no atom

   // Check for the special symbol '+INF', which means +Infinity.  Note: C99
   // requires strtof to parse '+INF' as +Infinity, but we still support some
   // non-C99-compliant compilers (e.g. MSVC).
   if (n == 4 && strncmp(src, "+INF", 4) == 0) {
      expr = new(ctx) s_float(std::numeric_limits<float>::infinity());
   } else {
      // Check if the atom is a number.
      char *float_end = NULL;
      float f = glsl_strtof(src, &float_end);
      if (float_end != src) {
         char *int_end = NULL;
         int i = strtol(src, &int_end, 10);
         // If strtof matched more characters, it must have a decimal part
         if (float_end > int_end)
            expr = new(ctx) s_float(f);
         else
            expr = new(ctx) s_int(i);
      } else {
         // Not a number; return a symbol.
         symbol_buffer[n] = '\0';
         expr = new(ctx) s_symbol(symbol_buffer, n);
      }
   }

   src += n;
   symbol_buffer += n;

   return expr;
}

static s_expression *
__read_expression(void *ctx, const char *&src, char *&symbol_buffer)
{
   s_expression *atom = read_atom(ctx, src, symbol_buffer);
   if (atom != NULL)
      return atom;

   skip_whitespace(src, symbol_buffer);
   if (src[0] == '(') {
      ++src;
      ++symbol_buffer;

      s_list *list = new(ctx) s_list;
      s_expression *expr;

      while ((expr = __read_expression(ctx, src, symbol_buffer)) != NULL) {
	 list->subexpressions.push_tail(expr);
      }
      skip_whitespace(src, symbol_buffer);
      if (src[0] != ')') {
	 printf("Unclosed expression (check your parenthesis).\n");
	 return NULL;
      }
      ++src;
      ++symbol_buffer;
      return list;
   }
   return NULL;
}

s_expression *
s_expression::read_expression(void *ctx, const char *&src)
{
   assert(src != NULL);

   /* When we encounter a Symbol, we need to save a nul-terminated copy of
    * the string.  However, ralloc_strndup'ing every individual Symbol is
    * extremely expensive.  We could avoid this by simply overwriting the
    * next character (guaranteed to be whitespace, parens, or semicolon) with
    * a nul-byte.  But overwriting non-whitespace would mess up parsing.
    *
    * So, just copy the whole buffer ahead of time.  Walk both, leaving the
    * original source string unmodified, and altering the copy to contain the
    * necessary nul-bytes whenever we encounter a symbol.
    */
   char *symbol_buffer = ralloc_strdup(ctx, src);
   return __read_expression(ctx, src, symbol_buffer);
}

void s_int::print()
{
   printf("%d", this->val);
}

void s_float::print()
{
   printf("%f", this->val);
}

void s_symbol::print()
{
   printf("%s", this->str);
}

void s_list::print()
{
   printf("(");
   foreach_list(n, &this->subexpressions) {
      s_expression *expr = (s_expression *) n;
      expr->print();
      if (!expr->next->is_tail_sentinel())
	 printf(" ");
   }
   printf(")");
}

// --------------------------------------------------

bool
s_pattern::match(s_expression *expr)
{
   switch (type)
   {
   case EXPR:   *p_expr = expr; break;
   case LIST:   if (expr->is_list())   *p_list   = (s_list *)   expr; break;
   case SYMBOL: if (expr->is_symbol()) *p_symbol = (s_symbol *) expr; break;
   case NUMBER: if (expr->is_number()) *p_number = (s_number *) expr; break;
   case INT:    if (expr->is_int())    *p_int    = (s_int *)    expr; break;
   case STRING:
      s_symbol *sym = SX_AS_SYMBOL(expr);
      if (sym != NULL && strcmp(sym->value(), literal) == 0)
	 return true;
      return false;
   };

   return *p_expr == expr;
}

bool
s_match(s_expression *top, unsigned n, s_pattern *pattern, bool partial)
{
   s_list *list = SX_AS_LIST(top);
   if (list == NULL)
      return false;

   unsigned i = 0;
   foreach_list(node, &list->subexpressions) {
      if (i >= n)
	 return partial; /* More actual items than the pattern expected */

      s_expression *expr = (s_expression *) node;
      if (expr == NULL || !pattern[i].match(expr))
	 return false;

      i++;
   }

   if (i < n)
      return false; /* Less actual items than the pattern expected */

   return true;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d76 1
a76 1
      float f = _mesa_strtof(src, &float_end);
d165 2
a166 1
   foreach_in_list(s_expression, expr, &this->subexpressions) {
d204 1
a204 1
   foreach_in_list(s_expression, expr, &list->subexpressions) {
d208 1
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d76 1
a76 1
      float f = glsl_strtof(src, &float_end);
d165 1
a165 2
   foreach_list(n, &this->subexpressions) {
      s_expression *expr = (s_expression *) n;
d203 1
a203 1
   foreach_list(node, &list->subexpressions) {
a206 1
      s_expression *expr = (s_expression *) node;
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d165 2
a166 2
   foreach_iter(exec_list_iterator, it, this->subexpressions) {
      s_expression *expr = (s_expression*) it.get();
d204 1
a204 1
   foreach_iter(exec_list_iterator, it, list->subexpressions) {
d208 1
a208 1
      s_expression *expr = (s_expression *) it.get();
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d26 1
d68 5
a72 11
   // Check if the atom is a number.
   char *float_end = NULL;
   double f = glsl_strtod(src, &float_end);
   if (float_end != src) {
      char *int_end = NULL;
      int i = strtol(src, &int_end, 10);
      // If strtod matched more characters, it must have a decimal part
      if (float_end > int_end)
	 expr = new(ctx) s_float(f);
      else
	 expr = new(ctx) s_int(i);
d74 16
a89 3
      // Not a number; return a symbol.
      symbol_buffer[n] = '\0';
      expr = new(ctx) s_symbol(symbol_buffer, n);
@


1.1
log
@Initial revision
@
text
@a24 3
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
d28 1
a28 1
s_symbol::s_symbol(const char *tmp, size_t n)
d30 5
a34 2
   this->str = ralloc_strndup (this, tmp, n);
   assert(this->str != NULL);
d41 2
a42 2
unsigned
s_list::length() const
d44 9
a52 3
   unsigned i = 0;
   foreach_iter(exec_list_iterator, it, this->subexpressions) {
      i++;
a53 1
   return i;
d57 1
a57 1
read_atom(void *ctx, const char *& src)
d61 1
a61 2
   // Skip leading spaces.
   src += strspn(src, " \v\t\r\n");
d63 1
a63 1
   size_t n = strcspn(src, "( \v\t\r\n)");
d80 2
a81 1
      expr = new(ctx) s_symbol(src, n);
d85 1
d90 2
a91 2
s_expression *
s_expression::read_expression(void *ctx, const char *&src)
d93 1
a93 3
   assert(src != NULL);

   s_expression *atom = read_atom(ctx, src);
d97 1
a97 2
   // Skip leading spaces.
   src += strspn(src, " \v\t\r\n");
d100 1
d105 1
a105 1
      while ((expr = read_expression(ctx, src)) != NULL) {
d108 1
a108 1
      src += strspn(src, " \v\t\r\n");
d114 1
d120 19
d166 46
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d25 3
a28 1
#include <limits>
d31 1
a31 1
s_symbol::s_symbol(const char *str, size_t n)
d33 2
a34 5
   /* Assume the given string is already nul-terminated and in memory that
    * will live as long as this node.
    */
   assert(str[n] == '\0');
   this->str = str;
d41 2
a42 2
static void
skip_whitespace(const char *&src, char *&symbol_buffer)
d44 3
a46 9
   size_t n = strspn(src, " \v\t\r\n");
   src += n;
   symbol_buffer += n;
   /* Also skip Scheme-style comments: semi-colon 'til end of line */
   if (src[0] == ';') {
      n = strcspn(src, "\n");
      src += n;
      symbol_buffer += n;
      skip_whitespace(src, symbol_buffer);
d48 1
d52 1
a52 1
read_atom(void *ctx, const char *&src, char *&symbol_buffer)
d56 2
a57 1
   skip_whitespace(src, symbol_buffer);
d59 1
a59 1
   size_t n = strcspn(src, "( \v\t\r\n);");
d63 11
a73 5
   // Check for the special symbol '+INF', which means +Infinity.  Note: C99
   // requires strtof to parse '+INF' as +Infinity, but we still support some
   // non-C99-compliant compilers (e.g. MSVC).
   if (n == 4 && strncmp(src, "+INF", 4) == 0) {
      expr = new(ctx) s_float(std::numeric_limits<float>::infinity());
d75 2
a76 16
      // Check if the atom is a number.
      char *float_end = NULL;
      float f = glsl_strtof(src, &float_end);
      if (float_end != src) {
         char *int_end = NULL;
         int i = strtol(src, &int_end, 10);
         // If strtof matched more characters, it must have a decimal part
         if (float_end > int_end)
            expr = new(ctx) s_float(f);
         else
            expr = new(ctx) s_int(i);
      } else {
         // Not a number; return a symbol.
         symbol_buffer[n] = '\0';
         expr = new(ctx) s_symbol(symbol_buffer, n);
      }
a79 1
   symbol_buffer += n;
d84 2
a85 2
static s_expression *
__read_expression(void *ctx, const char *&src, char *&symbol_buffer)
d87 3
a89 1
   s_expression *atom = read_atom(ctx, src, symbol_buffer);
d93 2
a94 1
   skip_whitespace(src, symbol_buffer);
a96 1
      ++symbol_buffer;
d101 1
a101 1
      while ((expr = __read_expression(ctx, src, symbol_buffer)) != NULL) {
d104 1
a104 1
      skip_whitespace(src, symbol_buffer);
a109 1
      ++symbol_buffer;
a114 19
s_expression *
s_expression::read_expression(void *ctx, const char *&src)
{
   assert(src != NULL);

   /* When we encounter a Symbol, we need to save a nul-terminated copy of
    * the string.  However, ralloc_strndup'ing every individual Symbol is
    * extremely expensive.  We could avoid this by simply overwriting the
    * next character (guaranteed to be whitespace, parens, or semicolon) with
    * a nul-byte.  But overwriting non-whitespace would mess up parsing.
    *
    * So, just copy the whole buffer ahead of time.  Walk both, leaving the
    * original source string unmodified, and altering the copy to contain the
    * necessary nul-bytes whenever we encounter a symbol.
    */
   char *symbol_buffer = ralloc_strdup(ctx, src);
   return __read_expression(ctx, src, symbol_buffer);
}

a141 46
// --------------------------------------------------

bool
s_pattern::match(s_expression *expr)
{
   switch (type)
   {
   case EXPR:   *p_expr = expr; break;
   case LIST:   if (expr->is_list())   *p_list   = (s_list *)   expr; break;
   case SYMBOL: if (expr->is_symbol()) *p_symbol = (s_symbol *) expr; break;
   case NUMBER: if (expr->is_number()) *p_number = (s_number *) expr; break;
   case INT:    if (expr->is_int())    *p_int    = (s_int *)    expr; break;
   case STRING:
      s_symbol *sym = SX_AS_SYMBOL(expr);
      if (sym != NULL && strcmp(sym->value(), literal) == 0)
	 return true;
      return false;
   };

   return *p_expr == expr;
}

bool
s_match(s_expression *top, unsigned n, s_pattern *pattern, bool partial)
{
   s_list *list = SX_AS_LIST(top);
   if (list == NULL)
      return false;

   unsigned i = 0;
   foreach_iter(exec_list_iterator, it, list->subexpressions) {
      if (i >= n)
	 return partial; /* More actual items than the pattern expected */

      s_expression *expr = (s_expression *) it.get();
      if (expr == NULL || !pattern[i].match(expr))
	 return false;

      i++;
   }

   if (i < n)
      return false; /* Less actual items than the pattern expected */

   return true;
}
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d165 2
a166 2
   foreach_list(n, &this->subexpressions) {
      s_expression *expr = (s_expression *) n;
d204 1
a204 1
   foreach_list(node, &list->subexpressions) {
d208 1
a208 1
      s_expression *expr = (s_expression *) node;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d76 1
a76 1
      float f = _mesa_strtof(src, &float_end);
d165 2
a166 1
   foreach_in_list(s_expression, expr, &this->subexpressions) {
d204 1
a204 1
   foreach_in_list(s_expression, expr, &list->subexpressions) {
d208 1
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d76 1
a76 1
      float f = glsl_strtof(src, &float_end);
d165 1
a165 2
   foreach_list(n, &this->subexpressions) {
      s_expression *expr = (s_expression *) n;
d203 1
a203 1
   foreach_list(node, &list->subexpressions) {
a206 1
      s_expression *expr = (s_expression *) node;
@


