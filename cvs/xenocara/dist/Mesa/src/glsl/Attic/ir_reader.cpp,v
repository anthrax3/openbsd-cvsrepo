head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.27;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.16;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.29;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.22;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.29;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "ir_reader.h"
#include "glsl_parser_extras.h"
#include "glsl_types.h"
#include "s_expression.h"

const static bool debug = false;

namespace {

class ir_reader {
public:
   ir_reader(_mesa_glsl_parse_state *);

   void read(exec_list *instructions, const char *src, bool scan_for_protos);

private:
   void *mem_ctx;
   _mesa_glsl_parse_state *state;

   void ir_read_error(s_expression *, const char *fmt, ...);

   const glsl_type *read_type(s_expression *);

   void scan_for_prototypes(exec_list *, s_expression *);
   ir_function *read_function(s_expression *, bool skip_body);
   void read_function_sig(ir_function *, s_expression *, bool skip_body);

   void read_instructions(exec_list *, s_expression *, ir_loop *);
   ir_instruction *read_instruction(s_expression *, ir_loop *);
   ir_variable *read_declaration(s_expression *);
   ir_if *read_if(s_expression *, ir_loop *);
   ir_loop *read_loop(s_expression *);
   ir_call *read_call(s_expression *);
   ir_return *read_return(s_expression *);
   ir_rvalue *read_rvalue(s_expression *);
   ir_assignment *read_assignment(s_expression *);
   ir_expression *read_expression(s_expression *);
   ir_swizzle *read_swizzle(s_expression *);
   ir_constant *read_constant(s_expression *);
   ir_texture *read_texture(s_expression *);
   ir_emit_vertex *read_emit_vertex(s_expression *);
   ir_end_primitive *read_end_primitive(s_expression *);

   ir_dereference *read_dereference(s_expression *);
   ir_dereference_variable *read_var_ref(s_expression *);
};

} /* anonymous namespace */

ir_reader::ir_reader(_mesa_glsl_parse_state *state) : state(state)
{
   this->mem_ctx = state;
}

void
_mesa_glsl_read_ir(_mesa_glsl_parse_state *state, exec_list *instructions,
		   const char *src, bool scan_for_protos)
{
   ir_reader r(state);
   r.read(instructions, src, scan_for_protos);
}

void
ir_reader::read(exec_list *instructions, const char *src, bool scan_for_protos)
{
   void *sx_mem_ctx = ralloc_context(NULL);
   s_expression *expr = s_expression::read_expression(sx_mem_ctx, src);
   if (expr == NULL) {
      ir_read_error(NULL, "couldn't parse S-Expression.");
      return;
   }
   
   if (scan_for_protos) {
      scan_for_prototypes(instructions, expr);
      if (state->error)
	 return;
   }

   read_instructions(instructions, expr, NULL);
   ralloc_free(sx_mem_ctx);

   if (debug)
      validate_ir_tree(instructions);
}

void
ir_reader::ir_read_error(s_expression *expr, const char *fmt, ...)
{
   va_list ap;

   state->error = true;

   if (state->current_function != NULL)
      ralloc_asprintf_append(&state->info_log, "In function %s:\n",
			     state->current_function->function_name());
   ralloc_strcat(&state->info_log, "error: ");

   va_start(ap, fmt);
   ralloc_vasprintf_append(&state->info_log, fmt, ap);
   va_end(ap);
   ralloc_strcat(&state->info_log, "\n");

   if (expr != NULL) {
      ralloc_strcat(&state->info_log, "...in this context:\n   ");
      expr->print();
      ralloc_strcat(&state->info_log, "\n\n");
   }
}

const glsl_type *
ir_reader::read_type(s_expression *expr)
{
   s_expression *s_base_type;
   s_int *s_size;

   s_pattern pat[] = { "array", s_base_type, s_size };
   if (MATCH(expr, pat)) {
      const glsl_type *base_type = read_type(s_base_type);
      if (base_type == NULL) {
	 ir_read_error(NULL, "when reading base type of array type");
	 return NULL;
      }

      return glsl_type::get_array_instance(base_type, s_size->value());
   }
   
   s_symbol *type_sym = SX_AS_SYMBOL(expr);
   if (type_sym == NULL) {
      ir_read_error(expr, "expected <type>");
      return NULL;
   }

   const glsl_type *type = state->symbols->get_type(type_sym->value());
   if (type == NULL)
      ir_read_error(expr, "invalid type: %s", type_sym->value());

   return type;
}


void
ir_reader::scan_for_prototypes(exec_list *instructions, s_expression *expr)
{
   s_list *list = SX_AS_LIST(expr);
   if (list == NULL) {
      ir_read_error(expr, "Expected (<instruction> ...); found an atom.");
      return;
   }

   foreach_list(n, &list->subexpressions) {
      s_list *sub = SX_AS_LIST(n);
      if (sub == NULL)
	 continue; // not a (function ...); ignore it.

      s_symbol *tag = SX_AS_SYMBOL(sub->subexpressions.get_head());
      if (tag == NULL || strcmp(tag->value(), "function") != 0)
	 continue; // not a (function ...); ignore it.

      ir_function *f = read_function(sub, true);
      if (f == NULL)
	 return;
      instructions->push_tail(f);
   }
}

ir_function *
ir_reader::read_function(s_expression *expr, bool skip_body)
{
   bool added = false;
   s_symbol *name;

   s_pattern pat[] = { "function", name };
   if (!PARTIAL_MATCH(expr, pat)) {
      ir_read_error(expr, "Expected (function <name> (signature ...) ...)");
      return NULL;
   }

   ir_function *f = state->symbols->get_function(name->value());
   if (f == NULL) {
      f = new(mem_ctx) ir_function(name->value());
      added = state->symbols->add_function(f);
      assert(added);
   }

   /* Skip over "function" tag and function name (which are guaranteed to be
    * present by the above PARTIAL_MATCH call).
    */
   exec_node *node = ((s_list *) expr)->subexpressions.head->next->next;
   for (/* nothing */; !node->is_tail_sentinel(); node = node->next) {
      s_expression *s_sig = (s_expression *) node;
      read_function_sig(f, s_sig, skip_body);
   }
   return added ? f : NULL;
}

static bool
always_available(const _mesa_glsl_parse_state *)
{
   return true;
}

void
ir_reader::read_function_sig(ir_function *f, s_expression *expr, bool skip_body)
{
   s_expression *type_expr;
   s_list *paramlist;
   s_list *body_list;

   s_pattern pat[] = { "signature", type_expr, paramlist, body_list };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "Expected (signature <type> (parameters ...) "
			  "(<instruction> ...))");
      return;
   }

   const glsl_type *return_type = read_type(type_expr);
   if (return_type == NULL)
      return;

   s_symbol *paramtag = SX_AS_SYMBOL(paramlist->subexpressions.get_head());
   if (paramtag == NULL || strcmp(paramtag->value(), "parameters") != 0) {
      ir_read_error(paramlist, "Expected (parameters ...)");
      return;
   }

   // Read the parameters list into a temporary place.
   exec_list hir_parameters;
   state->symbols->push_scope();

   /* Skip over the "parameters" tag. */
   exec_node *node = paramlist->subexpressions.head->next;
   for (/* nothing */; !node->is_tail_sentinel(); node = node->next) {
      ir_variable *var = read_declaration((s_expression *) node);
      if (var == NULL)
	 return;

      hir_parameters.push_tail(var);
   }

   ir_function_signature *sig =
      f->exact_matching_signature(state, &hir_parameters);
   if (sig == NULL && skip_body) {
      /* If scanning for prototypes, generate a new signature. */
      /* ir_reader doesn't know what languages support a given built-in, so
       * just say that they're always available.  For now, other mechanisms
       * guarantee the right built-ins are available.
       */
      sig = new(mem_ctx) ir_function_signature(return_type, always_available);
      f->add_signature(sig);
   } else if (sig != NULL) {
      const char *badvar = sig->qualifiers_match(&hir_parameters);
      if (badvar != NULL) {
	 ir_read_error(expr, "function `%s' parameter `%s' qualifiers "
		       "don't match prototype", f->name, badvar);
	 return;
      }

      if (sig->return_type != return_type) {
	 ir_read_error(expr, "function `%s' return type doesn't "
		       "match prototype", f->name);
	 return;
      }
   } else {
      /* No prototype for this body exists - skip it. */
      state->symbols->pop_scope();
      return;
   }
   assert(sig != NULL);

   sig->replace_parameters(&hir_parameters);

   if (!skip_body && !body_list->subexpressions.is_empty()) {
      if (sig->is_defined) {
	 ir_read_error(expr, "function %s redefined", f->name);
	 return;
      }
      state->current_function = sig;
      read_instructions(&sig->body, body_list, NULL);
      state->current_function = NULL;
      sig->is_defined = true;
   }

   state->symbols->pop_scope();
}

void
ir_reader::read_instructions(exec_list *instructions, s_expression *expr,
			     ir_loop *loop_ctx)
{
   // Read in a list of instructions
   s_list *list = SX_AS_LIST(expr);
   if (list == NULL) {
      ir_read_error(expr, "Expected (<instruction> ...); found an atom.");
      return;
   }

   foreach_list(n, &list->subexpressions) {
      s_expression *sub = (s_expression *) n;
      ir_instruction *ir = read_instruction(sub, loop_ctx);
      if (ir != NULL) {
	 /* Global variable declarations should be moved to the top, before
	  * any functions that might use them.  Functions are added to the
	  * instruction stream when scanning for prototypes, so without this
	  * hack, they always appear before variable declarations.
	  */
	 if (state->current_function == NULL && ir->as_variable() != NULL)
	    instructions->push_head(ir);
	 else
	    instructions->push_tail(ir);
      }
   }
}


ir_instruction *
ir_reader::read_instruction(s_expression *expr, ir_loop *loop_ctx)
{
   s_symbol *symbol = SX_AS_SYMBOL(expr);
   if (symbol != NULL) {
      if (strcmp(symbol->value(), "break") == 0 && loop_ctx != NULL)
	 return new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break);
      if (strcmp(symbol->value(), "continue") == 0 && loop_ctx != NULL)
	 return new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_continue);
   }

   s_list *list = SX_AS_LIST(expr);
   if (list == NULL || list->subexpressions.is_empty()) {
      ir_read_error(expr, "Invalid instruction.\n");
      return NULL;
   }

   s_symbol *tag = SX_AS_SYMBOL(list->subexpressions.get_head());
   if (tag == NULL) {
      ir_read_error(expr, "expected instruction tag");
      return NULL;
   }

   ir_instruction *inst = NULL;
   if (strcmp(tag->value(), "declare") == 0) {
      inst = read_declaration(list);
   } else if (strcmp(tag->value(), "assign") == 0) {
      inst = read_assignment(list);
   } else if (strcmp(tag->value(), "if") == 0) {
      inst = read_if(list, loop_ctx);
   } else if (strcmp(tag->value(), "loop") == 0) {
      inst = read_loop(list);
   } else if (strcmp(tag->value(), "call") == 0) {
      inst = read_call(list);
   } else if (strcmp(tag->value(), "return") == 0) {
      inst = read_return(list);
   } else if (strcmp(tag->value(), "function") == 0) {
      inst = read_function(list, false);
   } else if (strcmp(tag->value(), "emit-vertex") == 0) {
      inst = read_emit_vertex(list);
   } else if (strcmp(tag->value(), "end-primitive") == 0) {
      inst = read_end_primitive(list);
   } else {
      inst = read_rvalue(list);
      if (inst == NULL)
	 ir_read_error(NULL, "when reading instruction");
   }
   return inst;
}

ir_variable *
ir_reader::read_declaration(s_expression *expr)
{
   s_list *s_quals;
   s_expression *s_type;
   s_symbol *s_name;

   s_pattern pat[] = { "declare", s_quals, s_type, s_name };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "expected (declare (<qualifiers>) <type> <name>)");
      return NULL;
   }

   const glsl_type *type = read_type(s_type);
   if (type == NULL)
      return NULL;

   ir_variable *var = new(mem_ctx) ir_variable(type, s_name->value(),
					       ir_var_auto);

   foreach_list(n, &s_quals->subexpressions) {
      s_symbol *qualifier = SX_AS_SYMBOL(n);
      if (qualifier == NULL) {
	 ir_read_error(expr, "qualifier list must contain only symbols");
	 return NULL;
      }

      // FINISHME: Check for duplicate/conflicting qualifiers.
      if (strcmp(qualifier->value(), "centroid") == 0) {
	 var->data.centroid = 1;
      } else if (strcmp(qualifier->value(), "sample") == 0) {
         var->data.sample = 1;
      } else if (strcmp(qualifier->value(), "invariant") == 0) {
	 var->data.invariant = 1;
      } else if (strcmp(qualifier->value(), "uniform") == 0) {
	 var->data.mode = ir_var_uniform;
      } else if (strcmp(qualifier->value(), "auto") == 0) {
	 var->data.mode = ir_var_auto;
      } else if (strcmp(qualifier->value(), "in") == 0) {
	 var->data.mode = ir_var_function_in;
      } else if (strcmp(qualifier->value(), "shader_in") == 0) {
         var->data.mode = ir_var_shader_in;
      } else if (strcmp(qualifier->value(), "const_in") == 0) {
	 var->data.mode = ir_var_const_in;
      } else if (strcmp(qualifier->value(), "out") == 0) {
	 var->data.mode = ir_var_function_out;
      } else if (strcmp(qualifier->value(), "shader_out") == 0) {
	 var->data.mode = ir_var_shader_out;
      } else if (strcmp(qualifier->value(), "inout") == 0) {
	 var->data.mode = ir_var_function_inout;
      } else if (strcmp(qualifier->value(), "temporary") == 0) {
	 var->data.mode = ir_var_temporary;
      } else if (strcmp(qualifier->value(), "smooth") == 0) {
	 var->data.interpolation = INTERP_QUALIFIER_SMOOTH;
      } else if (strcmp(qualifier->value(), "flat") == 0) {
	 var->data.interpolation = INTERP_QUALIFIER_FLAT;
      } else if (strcmp(qualifier->value(), "noperspective") == 0) {
	 var->data.interpolation = INTERP_QUALIFIER_NOPERSPECTIVE;
      } else {
	 ir_read_error(expr, "unknown qualifier: %s", qualifier->value());
	 return NULL;
      }
   }

   // Add the variable to the symbol table
   state->symbols->add_variable(var);

   return var;
}


ir_if *
ir_reader::read_if(s_expression *expr, ir_loop *loop_ctx)
{
   s_expression *s_cond;
   s_expression *s_then;
   s_expression *s_else;

   s_pattern pat[] = { "if", s_cond, s_then, s_else };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "expected (if <condition> (<then>...) (<else>...))");
      return NULL;
   }

   ir_rvalue *condition = read_rvalue(s_cond);
   if (condition == NULL) {
      ir_read_error(NULL, "when reading condition of (if ...)");
      return NULL;
   }

   ir_if *iff = new(mem_ctx) ir_if(condition);

   read_instructions(&iff->then_instructions, s_then, loop_ctx);
   read_instructions(&iff->else_instructions, s_else, loop_ctx);
   if (state->error) {
      delete iff;
      iff = NULL;
   }
   return iff;
}


ir_loop *
ir_reader::read_loop(s_expression *expr)
{
   s_expression *s_body;

   s_pattern loop_pat[] = { "loop", s_body };
   if (!MATCH(expr, loop_pat)) {
      ir_read_error(expr, "expected (loop <body>)");
      return NULL;
   }

   ir_loop *loop = new(mem_ctx) ir_loop;

   read_instructions(&loop->body_instructions, s_body, loop);
   if (state->error) {
      delete loop;
      loop = NULL;
   }
   return loop;
}


ir_return *
ir_reader::read_return(s_expression *expr)
{
   s_expression *s_retval;

   s_pattern return_value_pat[] = { "return", s_retval};
   s_pattern return_void_pat[] = { "return" };
   if (MATCH(expr, return_value_pat)) {
      ir_rvalue *retval = read_rvalue(s_retval);
      if (retval == NULL) {
         ir_read_error(NULL, "when reading return value");
         return NULL;
      }
      return new(mem_ctx) ir_return(retval);
   } else if (MATCH(expr, return_void_pat)) {
      return new(mem_ctx) ir_return;
   } else {
      ir_read_error(expr, "expected (return <rvalue>) or (return)");
      return NULL;
   }
}


ir_rvalue *
ir_reader::read_rvalue(s_expression *expr)
{
   s_list *list = SX_AS_LIST(expr);
   if (list == NULL || list->subexpressions.is_empty())
      return NULL;

   s_symbol *tag = SX_AS_SYMBOL(list->subexpressions.get_head());
   if (tag == NULL) {
      ir_read_error(expr, "expected rvalue tag");
      return NULL;
   }

   ir_rvalue *rvalue = read_dereference(list);
   if (rvalue != NULL || state->error)
      return rvalue;
   else if (strcmp(tag->value(), "swiz") == 0) {
      rvalue = read_swizzle(list);
   } else if (strcmp(tag->value(), "expression") == 0) {
      rvalue = read_expression(list);
   } else if (strcmp(tag->value(), "constant") == 0) {
      rvalue = read_constant(list);
   } else {
      rvalue = read_texture(list);
      if (rvalue == NULL && !state->error)
	 ir_read_error(expr, "unrecognized rvalue tag: %s", tag->value());
   }

   return rvalue;
}

ir_assignment *
ir_reader::read_assignment(s_expression *expr)
{
   s_expression *cond_expr = NULL;
   s_expression *lhs_expr, *rhs_expr;
   s_list       *mask_list;

   s_pattern pat4[] = { "assign",            mask_list, lhs_expr, rhs_expr };
   s_pattern pat5[] = { "assign", cond_expr, mask_list, lhs_expr, rhs_expr };
   if (!MATCH(expr, pat4) && !MATCH(expr, pat5)) {
      ir_read_error(expr, "expected (assign [<condition>] (<write mask>) "
			  "<lhs> <rhs>)");
      return NULL;
   }

   ir_rvalue *condition = NULL;
   if (cond_expr != NULL) {
      condition = read_rvalue(cond_expr);
      if (condition == NULL) {
	 ir_read_error(NULL, "when reading condition of assignment");
	 return NULL;
      }
   }

   unsigned mask = 0;

   s_symbol *mask_symbol;
   s_pattern mask_pat[] = { mask_symbol };
   if (MATCH(mask_list, mask_pat)) {
      const char *mask_str = mask_symbol->value();
      unsigned mask_length = strlen(mask_str);
      if (mask_length > 4) {
	 ir_read_error(expr, "invalid write mask: %s", mask_str);
	 return NULL;
      }

      const unsigned idx_map[] = { 3, 0, 1, 2 }; /* w=bit 3, x=0, y=1, z=2 */

      for (unsigned i = 0; i < mask_length; i++) {
	 if (mask_str[i] < 'w' || mask_str[i] > 'z') {
	    ir_read_error(expr, "write mask contains invalid character: %c",
			  mask_str[i]);
	    return NULL;
	 }
	 mask |= 1 << idx_map[mask_str[i] - 'w'];
      }
   } else if (!mask_list->subexpressions.is_empty()) {
      ir_read_error(mask_list, "expected () or (<write mask>)");
      return NULL;
   }

   ir_dereference *lhs = read_dereference(lhs_expr);
   if (lhs == NULL) {
      ir_read_error(NULL, "when reading left-hand side of assignment");
      return NULL;
   }

   ir_rvalue *rhs = read_rvalue(rhs_expr);
   if (rhs == NULL) {
      ir_read_error(NULL, "when reading right-hand side of assignment");
      return NULL;
   }

   if (mask == 0 && (lhs->type->is_vector() || lhs->type->is_scalar())) {
      ir_read_error(expr, "non-zero write mask required.");
      return NULL;
   }

   return new(mem_ctx) ir_assignment(lhs, rhs, condition, mask);
}

ir_call *
ir_reader::read_call(s_expression *expr)
{
   s_symbol *name;
   s_list *params;
   s_list *s_return = NULL;

   ir_dereference_variable *return_deref = NULL;

   s_pattern void_pat[] = { "call", name, params };
   s_pattern non_void_pat[] = { "call", name, s_return, params };
   if (MATCH(expr, non_void_pat)) {
      return_deref = read_var_ref(s_return);
      if (return_deref == NULL) {
	 ir_read_error(s_return, "when reading a call's return storage");
	 return NULL;
      }
   } else if (!MATCH(expr, void_pat)) {
      ir_read_error(expr, "expected (call <name> [<deref>] (<param> ...))");
      return NULL;
   }

   exec_list parameters;

   foreach_list(n, &params->subexpressions) {
      s_expression *expr = (s_expression *) n;
      ir_rvalue *param = read_rvalue(expr);
      if (param == NULL) {
	 ir_read_error(expr, "when reading parameter to function call");
	 return NULL;
      }
      parameters.push_tail(param);
   }

   ir_function *f = state->symbols->get_function(name->value());
   if (f == NULL) {
      ir_read_error(expr, "found call to undefined function %s",
		    name->value());
      return NULL;
   }

   ir_function_signature *callee = f->matching_signature(state, &parameters);
   if (callee == NULL) {
      ir_read_error(expr, "couldn't find matching signature for function "
                    "%s", name->value());
      return NULL;
   }

   if (callee->return_type == glsl_type::void_type && return_deref) {
      ir_read_error(expr, "call has return value storage but void type");
      return NULL;
   } else if (callee->return_type != glsl_type::void_type && !return_deref) {
      ir_read_error(expr, "call has non-void type but no return value storage");
      return NULL;
   }

   return new(mem_ctx) ir_call(callee, return_deref, &parameters);
}

ir_expression *
ir_reader::read_expression(s_expression *expr)
{
   s_expression *s_type;
   s_symbol *s_op;
   s_expression *s_arg[4] = {NULL};

   s_pattern pat[] = { "expression", s_type, s_op, s_arg[0] };
   if (!PARTIAL_MATCH(expr, pat)) {
      ir_read_error(expr, "expected (expression <type> <operator> "
			  "<operand> [<operand>] [<operand>] [<operand>])");
      return NULL;
   }
   s_arg[1] = (s_expression *) s_arg[0]->next; // may be tail sentinel
   s_arg[2] = (s_expression *) s_arg[1]->next; // may be tail sentinel or NULL
   if (s_arg[2])
      s_arg[3] = (s_expression *) s_arg[2]->next; // may be tail sentinel or NULL

   const glsl_type *type = read_type(s_type);
   if (type == NULL)
      return NULL;

   /* Read the operator */
   ir_expression_operation op = ir_expression::get_operator(s_op->value());
   if (op == (ir_expression_operation) -1) {
      ir_read_error(expr, "invalid operator: %s", s_op->value());
      return NULL;
   }
    
   int num_operands = -3; /* skip "expression" <type> <operation> */
   foreach_list(n, &((s_list *) expr)->subexpressions)
      ++num_operands;

   int expected_operands = ir_expression::get_num_operands(op);
   if (num_operands != expected_operands) {
      ir_read_error(expr, "found %d expression operands, expected %d",
                    num_operands, expected_operands);
      return NULL;
   }

   ir_rvalue *arg[4] = {NULL};
   for (int i = 0; i < num_operands; i++) {
      arg[i] = read_rvalue(s_arg[i]);
      if (arg[i] == NULL) {
         ir_read_error(NULL, "when reading operand #%d of %s", i, s_op->value());
         return NULL;
      }
   }

   return new(mem_ctx) ir_expression(op, type, arg[0], arg[1], arg[2], arg[3]);
}

ir_swizzle *
ir_reader::read_swizzle(s_expression *expr)
{
   s_symbol *swiz;
   s_expression *sub;

   s_pattern pat[] = { "swiz", swiz, sub };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "expected (swiz <swizzle> <rvalue>)");
      return NULL;
   }

   if (strlen(swiz->value()) > 4) {
      ir_read_error(expr, "expected a valid swizzle; found %s", swiz->value());
      return NULL;
   }

   ir_rvalue *rvalue = read_rvalue(sub);
   if (rvalue == NULL)
      return NULL;

   ir_swizzle *ir = ir_swizzle::create(rvalue, swiz->value(),
				       rvalue->type->vector_elements);
   if (ir == NULL)
      ir_read_error(expr, "invalid swizzle");

   return ir;
}

ir_constant *
ir_reader::read_constant(s_expression *expr)
{
   s_expression *type_expr;
   s_list *values;

   s_pattern pat[] = { "constant", type_expr, values };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "expected (constant <type> (...))");
      return NULL;
   }

   const glsl_type *type = read_type(type_expr);
   if (type == NULL)
      return NULL;

   if (values == NULL) {
      ir_read_error(expr, "expected (constant <type> (...))");
      return NULL;
   }

   if (type->is_array()) {
      unsigned elements_supplied = 0;
      exec_list elements;
      foreach_list(n, &values->subexpressions) {
	 s_expression *elt = (s_expression *) n;
	 ir_constant *ir_elt = read_constant(elt);
	 if (ir_elt == NULL)
	    return NULL;
	 elements.push_tail(ir_elt);
	 elements_supplied++;
      }

      if (elements_supplied != type->length) {
	 ir_read_error(values, "expected exactly %u array elements, "
		       "given %u", type->length, elements_supplied);
	 return NULL;
      }
      return new(mem_ctx) ir_constant(type, &elements);
   }

   ir_constant_data data = { { 0 } };

   // Read in list of values (at most 16).
   unsigned k = 0;
   foreach_list(n, &values->subexpressions) {
      if (k >= 16) {
	 ir_read_error(values, "expected at most 16 numbers");
	 return NULL;
      }

      s_expression *expr = (s_expression *) n;

      if (type->base_type == GLSL_TYPE_FLOAT) {
	 s_number *value = SX_AS_NUMBER(expr);
	 if (value == NULL) {
	    ir_read_error(values, "expected numbers");
	    return NULL;
	 }
	 data.f[k] = value->fvalue();
      } else {
	 s_int *value = SX_AS_INT(expr);
	 if (value == NULL) {
	    ir_read_error(values, "expected integers");
	    return NULL;
	 }

	 switch (type->base_type) {
	 case GLSL_TYPE_UINT: {
	    data.u[k] = value->value();
	    break;
	 }
	 case GLSL_TYPE_INT: {
	    data.i[k] = value->value();
	    break;
	 }
	 case GLSL_TYPE_BOOL: {
	    data.b[k] = value->value();
	    break;
	 }
	 default:
	    ir_read_error(values, "unsupported constant type");
	    return NULL;
	 }
      }
      ++k;
   }
   if (k != type->components()) {
      ir_read_error(values, "expected %u constant values, found %u",
		    type->components(), k);
      return NULL;
   }

   return new(mem_ctx) ir_constant(type, &data);
}

ir_dereference_variable *
ir_reader::read_var_ref(s_expression *expr)
{
   s_symbol *s_var;
   s_pattern var_pat[] = { "var_ref", s_var };

   if (MATCH(expr, var_pat)) {
      ir_variable *var = state->symbols->get_variable(s_var->value());
      if (var == NULL) {
	 ir_read_error(expr, "undeclared variable: %s", s_var->value());
	 return NULL;
      }
      return new(mem_ctx) ir_dereference_variable(var);
   }
   return NULL;
}

ir_dereference *
ir_reader::read_dereference(s_expression *expr)
{
   s_expression *s_subject;
   s_expression *s_index;
   s_symbol *s_field;

   s_pattern array_pat[] = { "array_ref", s_subject, s_index };
   s_pattern record_pat[] = { "record_ref", s_subject, s_field };

   ir_dereference_variable *var_ref = read_var_ref(expr);
   if (var_ref != NULL) {
      return var_ref;
   } else if (MATCH(expr, array_pat)) {
      ir_rvalue *subject = read_rvalue(s_subject);
      if (subject == NULL) {
	 ir_read_error(NULL, "when reading the subject of an array_ref");
	 return NULL;
      }

      ir_rvalue *idx = read_rvalue(s_index);
      if (idx == NULL) {
	 ir_read_error(NULL, "when reading the index of an array_ref");
	 return NULL;
      }
      return new(mem_ctx) ir_dereference_array(subject, idx);
   } else if (MATCH(expr, record_pat)) {
      ir_rvalue *subject = read_rvalue(s_subject);
      if (subject == NULL) {
	 ir_read_error(NULL, "when reading the subject of a record_ref");
	 return NULL;
      }
      return new(mem_ctx) ir_dereference_record(subject, s_field->value());
   }
   return NULL;
}

ir_texture *
ir_reader::read_texture(s_expression *expr)
{
   s_symbol *tag = NULL;
   s_expression *s_type = NULL;
   s_expression *s_sampler = NULL;
   s_expression *s_coord = NULL;
   s_expression *s_offset = NULL;
   s_expression *s_proj = NULL;
   s_list *s_shadow = NULL;
   s_expression *s_lod = NULL;
   s_expression *s_sample_index = NULL;
   s_expression *s_component = NULL;

   ir_texture_opcode op = ir_tex; /* silence warning */

   s_pattern tex_pattern[] =
      { "tex", s_type, s_sampler, s_coord, s_offset, s_proj, s_shadow };
   s_pattern lod_pattern[] =
      { "lod", s_type, s_sampler, s_coord };
   s_pattern txf_pattern[] =
      { "txf", s_type, s_sampler, s_coord, s_offset, s_lod };
   s_pattern txf_ms_pattern[] =
      { "txf_ms", s_type, s_sampler, s_coord, s_sample_index };
   s_pattern txs_pattern[] =
      { "txs", s_type, s_sampler, s_lod };
   s_pattern tg4_pattern[] =
      { "tg4", s_type, s_sampler, s_coord, s_offset, s_component };
   s_pattern query_levels_pattern[] =
      { "query_levels", s_type, s_sampler };
   s_pattern other_pattern[] =
      { tag, s_type, s_sampler, s_coord, s_offset, s_proj, s_shadow, s_lod };

   if (MATCH(expr, lod_pattern)) {
      op = ir_lod;
   } else if (MATCH(expr, tex_pattern)) {
      op = ir_tex;
   } else if (MATCH(expr, txf_pattern)) {
      op = ir_txf;
   } else if (MATCH(expr, txf_ms_pattern)) {
      op = ir_txf_ms;
   } else if (MATCH(expr, txs_pattern)) {
      op = ir_txs;
   } else if (MATCH(expr, tg4_pattern)) {
      op = ir_tg4;
   } else if (MATCH(expr, query_levels_pattern)) {
      op = ir_query_levels;
   } else if (MATCH(expr, other_pattern)) {
      op = ir_texture::get_opcode(tag->value());
      if (op == -1)
	 return NULL;
   } else {
      ir_read_error(NULL, "unexpected texture pattern %s", tag->value());
      return NULL;
   }

   ir_texture *tex = new(mem_ctx) ir_texture(op);

   // Read return type
   const glsl_type *type = read_type(s_type);
   if (type == NULL) {
      ir_read_error(NULL, "when reading type in (%s ...)",
		    tex->opcode_string());
      return NULL;
   }

   // Read sampler (must be a deref)
   ir_dereference *sampler = read_dereference(s_sampler);
   if (sampler == NULL) {
      ir_read_error(NULL, "when reading sampler in (%s ...)",
		    tex->opcode_string());
      return NULL;
   }
   tex->set_sampler(sampler, type);

   if (op != ir_txs) {
      // Read coordinate (any rvalue)
      tex->coordinate = read_rvalue(s_coord);
      if (tex->coordinate == NULL) {
	 ir_read_error(NULL, "when reading coordinate in (%s ...)",
		       tex->opcode_string());
	 return NULL;
      }

      if (op != ir_txf_ms && op != ir_lod) {
         // Read texel offset - either 0 or an rvalue.
         s_int *si_offset = SX_AS_INT(s_offset);
         if (si_offset == NULL || si_offset->value() != 0) {
            tex->offset = read_rvalue(s_offset);
            if (tex->offset == NULL) {
               ir_read_error(s_offset, "expected 0 or an expression");
               return NULL;
            }
         }
      }
   }

   if (op != ir_txf && op != ir_txf_ms &&
       op != ir_txs && op != ir_lod && op != ir_tg4 &&
       op != ir_query_levels) {
      s_int *proj_as_int = SX_AS_INT(s_proj);
      if (proj_as_int && proj_as_int->value() == 1) {
	 tex->projector = NULL;
      } else {
	 tex->projector = read_rvalue(s_proj);
	 if (tex->projector == NULL) {
	    ir_read_error(NULL, "when reading projective divide in (%s ..)",
	                  tex->opcode_string());
	    return NULL;
	 }
      }

      if (s_shadow->subexpressions.is_empty()) {
	 tex->shadow_comparitor = NULL;
      } else {
	 tex->shadow_comparitor = read_rvalue(s_shadow);
	 if (tex->shadow_comparitor == NULL) {
	    ir_read_error(NULL, "when reading shadow comparitor in (%s ..)",
			  tex->opcode_string());
	    return NULL;
	 }
      }
   }

   switch (op) {
   case ir_txb:
      tex->lod_info.bias = read_rvalue(s_lod);
      if (tex->lod_info.bias == NULL) {
	 ir_read_error(NULL, "when reading LOD bias in (txb ...)");
	 return NULL;
      }
      break;
   case ir_txl:
   case ir_txf:
   case ir_txs:
      tex->lod_info.lod = read_rvalue(s_lod);
      if (tex->lod_info.lod == NULL) {
	 ir_read_error(NULL, "when reading LOD in (%s ...)",
		       tex->opcode_string());
	 return NULL;
      }
      break;
   case ir_txf_ms:
      tex->lod_info.sample_index = read_rvalue(s_sample_index);
      if (tex->lod_info.sample_index == NULL) {
         ir_read_error(NULL, "when reading sample_index in (txf_ms ...)");
         return NULL;
      }
      break;
   case ir_txd: {
      s_expression *s_dx, *s_dy;
      s_pattern dxdy_pat[] = { s_dx, s_dy };
      if (!MATCH(s_lod, dxdy_pat)) {
	 ir_read_error(s_lod, "expected (dPdx dPdy) in (txd ...)");
	 return NULL;
      }
      tex->lod_info.grad.dPdx = read_rvalue(s_dx);
      if (tex->lod_info.grad.dPdx == NULL) {
	 ir_read_error(NULL, "when reading dPdx in (txd ...)");
	 return NULL;
      }
      tex->lod_info.grad.dPdy = read_rvalue(s_dy);
      if (tex->lod_info.grad.dPdy == NULL) {
	 ir_read_error(NULL, "when reading dPdy in (txd ...)");
	 return NULL;
      }
      break;
   }
   case ir_tg4:
      tex->lod_info.component = read_rvalue(s_component);
      if (tex->lod_info.component == NULL) {
         ir_read_error(NULL, "when reading component in (tg4 ...)");
         return NULL;
      }
      break;
   default:
      // tex and lod don't have any extra parameters.
      break;
   };
   return tex;
}

ir_emit_vertex *
ir_reader::read_emit_vertex(s_expression *expr)
{
   s_pattern pat[] = { "emit-vertex" };

   if (MATCH(expr, pat)) {
      return new(mem_ctx) ir_emit_vertex();
   }
   ir_read_error(NULL, "when reading emit-vertex");
   return NULL;
}

ir_end_primitive *
ir_reader::read_end_primitive(s_expression *expr)
{
   s_pattern pat[] = { "end-primitive" };

   if (MATCH(expr, pat)) {
      return new(mem_ctx) ir_end_primitive();
   }
   ir_read_error(NULL, "when reading end-primitive");
   return NULL;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d173 3
a175 2
   foreach_in_list(s_list, sub, &list->subexpressions) {
      if (!sub->is_list())
d320 2
a321 1
   foreach_in_list(s_expression, sub, &list->subexpressions) {
d408 3
a410 2
   foreach_in_list(s_symbol, qualifier, &s_quals->subexpressions) {
      if (!qualifier->is_symbol()) {
a439 6
      } else if (strcmp(qualifier->value(), "stream1") == 0) {
	 var->data.stream = 1;
      } else if (strcmp(qualifier->value(), "stream2") == 0) {
	 var->data.stream = 2;
      } else if (strcmp(qualifier->value(), "stream3") == 0) {
	 var->data.stream = 3;
d661 3
a663 2
   foreach_in_list(s_expression, e, &params->subexpressions) {
      ir_rvalue *param = read_rvalue(e);
d665 1
a665 1
	 ir_read_error(e, "when reading parameter to function call");
d678 1
a678 2
   ir_function_signature *callee =
      f->matching_signature(state, &parameters, true);
d724 4
a727 3

   /* Skip "expression" <type> <operation> by subtracting 3. */
   int num_operands = (int) ((s_list *) expr)->subexpressions.length() - 3;
d801 2
a802 1
      foreach_in_list(s_expression, elt, &values->subexpressions) {
d822 1
a822 1
   foreach_in_list(s_expression, expr, &values->subexpressions) {
d828 2
d1112 1
a1112 3
   s_expression *s_stream = NULL;

   s_pattern pat[] = { "emit-vertex", s_stream };
d1115 1
a1115 6
      ir_rvalue *stream = read_dereference(s_stream);
      if (stream == NULL) {
         ir_read_error(NULL, "when reading stream info in emit-vertex");
         return NULL;
      }
      return new(mem_ctx) ir_emit_vertex(stream);
d1124 1
a1124 3
   s_expression *s_stream = NULL;

   s_pattern pat[] = { "end-primitive", s_stream };
d1127 1
a1127 6
      ir_rvalue *stream = read_dereference(s_stream);
      if (stream == NULL) {
         ir_read_error(NULL, "when reading stream info in end-primitive");
         return NULL;
      }
      return new(mem_ctx) ir_end_primitive(stream);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d173 2
a174 3
   foreach_list(n, &list->subexpressions) {
      s_list *sub = SX_AS_LIST(n);
      if (sub == NULL)
d319 1
a319 2
   foreach_list(n, &list->subexpressions) {
      s_expression *sub = (s_expression *) n;
d406 2
a407 3
   foreach_list(n, &s_quals->subexpressions) {
      s_symbol *qualifier = SX_AS_SYMBOL(n);
      if (qualifier == NULL) {
d437 6
d664 2
a665 3
   foreach_list(n, &params->subexpressions) {
      s_expression *expr = (s_expression *) n;
      ir_rvalue *param = read_rvalue(expr);
d667 1
a667 1
	 ir_read_error(expr, "when reading parameter to function call");
d680 2
a681 1
   ir_function_signature *callee = f->matching_signature(state, &parameters);
d727 3
a729 4
    
   int num_operands = -3; /* skip "expression" <type> <operation> */
   foreach_list(n, &((s_list *) expr)->subexpressions)
      ++num_operands;
d803 1
a803 2
      foreach_list(n, &values->subexpressions) {
	 s_expression *elt = (s_expression *) n;
d823 1
a823 1
   foreach_list(n, &values->subexpressions) {
a828 2
      s_expression *expr = (s_expression *) n;

d1111 3
a1113 1
   s_pattern pat[] = { "emit-vertex" };
d1116 6
a1121 1
      return new(mem_ctx) ir_emit_vertex();
d1130 3
a1132 1
   s_pattern pat[] = { "end-primitive" };
d1135 6
a1140 1
      return new(mem_ctx) ir_end_primitive();
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d31 2
d64 2
d71 2
d173 2
a174 2
   foreach_iter(exec_list_iterator, it, list->subexpressions) {
      s_list *sub = SX_AS_LIST(it.get());
d208 6
a213 5
   exec_list_iterator it = ((s_list *) expr)->subexpressions.iterator();
   it.next(); // skip "function" tag
   it.next(); // skip function name
   for (/* nothing */; it.has_next(); it.next()) {
      s_expression *s_sig = (s_expression *) it.get();
d219 6
d253 4
a256 3
   exec_list_iterator it = paramlist->subexpressions.iterator();
   for (it.next() /* skip "parameters" */; it.has_next(); it.next()) {
      ir_variable *var = read_declaration((s_expression *) it.get());
d263 2
a264 1
   ir_function_signature *sig = f->exact_matching_signature(&hir_parameters);
d267 5
a271 2
      sig = new(mem_ctx) ir_function_signature(return_type);
      sig->is_builtin = true;
d320 2
a321 2
   foreach_iter(exec_list_iterator, it, list->subexpressions) {
      s_expression *sub = (s_expression*) it.get();
d376 4
d408 2
a409 2
   foreach_iter(exec_list_iterator, it, s_quals->subexpressions) {
      s_symbol *qualifier = SX_AS_SYMBOL(it.get());
d417 3
a419 1
	 var->centroid = 1;
d421 1
a421 1
	 var->invariant = 1;
d423 1
a423 1
	 var->mode = ir_var_uniform;
d425 1
a425 1
	 var->mode = ir_var_auto;
d427 1
a427 1
	 var->mode = ir_var_function_in;
d429 1
a429 1
         var->mode = ir_var_shader_in;
d431 1
a431 1
	 var->mode = ir_var_const_in;
d433 1
a433 1
	 var->mode = ir_var_function_out;
d435 1
a435 1
	 var->mode = ir_var_shader_out;
d437 1
a437 1
	 var->mode = ir_var_function_inout;
d439 1
a439 1
	 var->mode = ir_var_temporary;
d441 1
a441 1
	 var->interpolation = INTERP_QUALIFIER_SMOOTH;
d443 1
a443 1
	 var->interpolation = INTERP_QUALIFIER_FLAT;
d445 1
a445 1
	 var->interpolation = INTERP_QUALIFIER_NOPERSPECTIVE;
d493 1
a493 1
   s_expression *s_counter, *s_from, *s_to, *s_inc, *s_body;
d495 3
a497 4
   s_pattern pat[] = { "loop", s_counter, s_from, s_to, s_inc, s_body };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "expected (loop <counter> <from> <to> "
			  "<increment> <body>)");
d501 1
a501 1
   // FINISHME: actually read the count/from/to fields.
a502 1
   ir_loop *loop = new(mem_ctx) ir_loop;
d661 2
a662 2
   foreach_iter(exec_list_iterator, it, params->subexpressions) {
      s_expression *expr = (s_expression*) it.get();
d678 1
a678 1
   ir_function_signature *callee = f->matching_signature(&parameters);
d801 2
a802 2
      foreach_iter(exec_list_iterator, it, values->subexpressions) {
	 s_expression *elt = (s_expression *) it.get();
d822 1
a822 1
   foreach_iter(exec_list_iterator, it, values->subexpressions) {
d828 1
a828 1
      s_expression *expr = (s_expression*) it.get();
d939 1
d953 4
d970 4
d1024 3
a1026 1
   if (op != ir_txf && op != ir_txf_ms && op != ir_txs && op != ir_lod) {
d1095 7
d1107 24
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d54 1
a58 1
   ir_call *read_call(s_expression *);
d64 1
d83 2
a84 1
   s_expression *expr = s_expression::read_expression(mem_ctx, src);
d97 1
a97 1
   ralloc_free(expr);
d352 2
d403 3
a405 1
	 var->mode = ir_var_in;
d409 3
a411 1
	 var->mode = ir_var_out;
d413 3
a415 1
	 var->mode = ir_var_inout;
d417 1
a417 1
	 var->interpolation = ir_var_smooth;
d419 1
a419 1
	 var->interpolation = ir_var_flat;
d421 1
a421 1
	 var->interpolation = ir_var_noperspective;
d495 13
a507 9
   s_pattern pat[] = { "return", s_retval};
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "expected (return <rvalue>)");
      return NULL;
   }

   ir_rvalue *retval = read_rvalue(s_retval);
   if (retval == NULL) {
      ir_read_error(NULL, "when reading return value");
a509 2

   return new(mem_ctx) ir_return(retval);
a532 2
   } else if (strcmp(tag->value(), "call") == 0) {
      rvalue = read_call(list);
d620 1
d622 12
a633 3
   s_pattern pat[] = { "call", name, params };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "expected (call <name> (<param> ...))");
d663 9
a671 1
   return new(mem_ctx) ir_call(callee, &parameters);
d679 1
a679 1
   s_expression *s_arg1;
d681 1
a681 1
   s_pattern pat[] = { "expression", s_type, s_op, s_arg1 };
d684 1
a684 1
			  "<operand> [<operand>])");
d687 4
a690 1
   s_expression *s_arg2 = (s_expression *) s_arg1->next; // may be tail sentinel
d703 3
a705 6
   unsigned num_operands = ir_expression::get_num_operands(op);
   if (num_operands == 1 && !s_arg1->next->is_tail_sentinel()) {
      ir_read_error(expr, "expected (expression <type> %s <operand>)",
		    s_op->value());
      return NULL;
   }
d707 4
a710 4
   ir_rvalue *arg1 = read_rvalue(s_arg1);
   ir_rvalue *arg2 = NULL;
   if (arg1 == NULL) {
      ir_read_error(NULL, "when reading first operand of %s", s_op->value());
d714 6
a719 11
   if (num_operands == 2) {
      if (s_arg2->is_tail_sentinel() || !s_arg2->next->is_tail_sentinel()) {
	 ir_read_error(expr, "expected (expression <type> %s <operand> "
			     "<operand>)", s_op->value());
	 return NULL;
      }
      arg2 = read_rvalue(s_arg2);
      if (arg2 == NULL) {
	 ir_read_error(NULL, "when reading second operand of %s",
		       s_op->value());
	 return NULL;
d723 1
a723 1
   return new(mem_ctx) ir_expression(op, type, arg1, arg2);
a795 2
   const glsl_type *const base_type = type->get_base_type();

d799 1
a799 1
   int k = 0;
d808 1
a808 1
      if (base_type->base_type == GLSL_TYPE_FLOAT) {
d822 1
a822 1
	 switch (base_type->base_type) {
d842 5
d851 2
a852 2
ir_dereference *
ir_reader::read_dereference(s_expression *expr)
a854 4
   s_expression *s_subject;
   s_expression *s_index;
   s_symbol *s_field;

a855 2
   s_pattern array_pat[] = { "array_ref", s_subject, s_index };
   s_pattern record_pat[] = { "record_ref", s_subject, s_field };
d864 17
d889 1
a889 1
      if (subject == NULL) {
d916 1
d922 2
d926 4
d933 3
a935 1
   if (MATCH(expr, tex_pattern)) {
d939 4
d948 1
a948 1
      ir_read_error(NULL, "unexpected texture pattern");
d971 8
a978 7
   // Read coordinate (any rvalue)
   tex->coordinate = read_rvalue(s_coord);
   if (tex->coordinate == NULL) {
      ir_read_error(NULL, "when reading coordinate in (%s ...)",
		    tex->opcode_string());
      return NULL;
   }
d980 10
a989 7
   // Read texel offset - either 0 or an rvalue.
   s_int *si_offset = SX_AS_INT(s_offset);
   if (si_offset == NULL || si_offset->value() != 0) {
      tex->offset = read_rvalue(s_offset);
      if (tex->offset == NULL) {
	 ir_read_error(s_offset, "expected 0 or an expression");
	 return NULL;
d993 1
a993 1
   if (op != ir_txf) {
d1028 1
d1036 7
d1063 1
a1063 1
      // tex doesn't have any extra parameters.
@


1.1
log
@Initial revision
@
text
@a23 2
#include <stdarg.h>

d31 39
a69 36
static void ir_read_error(_mesa_glsl_parse_state *, s_expression *,
			  const char *fmt, ...);
static const glsl_type *read_type(_mesa_glsl_parse_state *, s_expression *);

static void scan_for_prototypes(_mesa_glsl_parse_state *, exec_list *,
			        s_expression *);
static ir_function *read_function(_mesa_glsl_parse_state *, s_list *,
				  bool skip_body);
static void read_function_sig(_mesa_glsl_parse_state *, ir_function *,
			      s_list *, bool skip_body);

static void read_instructions(_mesa_glsl_parse_state *, exec_list *,
			      s_expression *, ir_loop *);
static ir_instruction *read_instruction(_mesa_glsl_parse_state *,
				        s_expression *, ir_loop *);
static ir_variable *read_declaration(_mesa_glsl_parse_state *, s_list *);
static ir_if *read_if(_mesa_glsl_parse_state *, s_list *, ir_loop *);
static ir_loop *read_loop(_mesa_glsl_parse_state *st, s_list *list);
static ir_return *read_return(_mesa_glsl_parse_state *, s_list *);

static ir_rvalue *read_rvalue(_mesa_glsl_parse_state *, s_expression *);
static ir_assignment *read_assignment(_mesa_glsl_parse_state *, s_list *);
static ir_expression *read_expression(_mesa_glsl_parse_state *, s_list *);
static ir_call *read_call(_mesa_glsl_parse_state *, s_list *);
static ir_swizzle *read_swizzle(_mesa_glsl_parse_state *, s_list *);
static ir_constant *read_constant(_mesa_glsl_parse_state *, s_list *);
static ir_texture *read_texture(_mesa_glsl_parse_state *, s_list *);

static ir_dereference *read_dereference(_mesa_glsl_parse_state *,
				        s_expression *);
static ir_dereference_variable *
read_var_ref(_mesa_glsl_parse_state *, s_list *);
static ir_dereference_array *
read_array_ref(_mesa_glsl_parse_state *, s_list *);
static ir_dereference_record *
read_record_ref(_mesa_glsl_parse_state *, s_list *);
d75 8
a82 1
   s_expression *expr = s_expression::read_expression(state, src);
d84 1
a84 1
      ir_read_error(state, NULL, "couldn't parse S-Expression.");
d89 1
a89 1
      scan_for_prototypes(state, instructions, expr);
d94 1
a94 1
   read_instructions(state, instructions, expr, NULL);
d101 2
a102 3
static void
ir_read_error(_mesa_glsl_parse_state *state, s_expression *expr,
	      const char *fmt, ...)
d125 2
a126 2
static const glsl_type *
read_type(_mesa_glsl_parse_state *st, s_expression *expr)
d128 8
a135 5
   s_list *list = SX_AS_LIST(expr);
   if (list != NULL) {
      s_symbol *type_sym = SX_AS_SYMBOL(list->subexpressions.get_head());
      if (type_sym == NULL) {
	 ir_read_error(st, expr, "expected type (array ...) or (struct ...)");
a137 13
      if (strcmp(type_sym->value(), "array") == 0) {
	 if (list->length() != 3) {
	    ir_read_error(st, expr, "expected type (array <type> <int>)");
	    return NULL;
	 }

	 // Read base type
	 s_expression *base_expr = (s_expression*) type_sym->next;
	 const glsl_type *base_type = read_type(st, base_expr);
	 if (base_type == NULL) {
	    ir_read_error(st, NULL, "when reading base type of array");
	    return NULL;
	 }
d139 1
a139 15
	 // Read array size
	 s_int *size = SX_AS_INT(base_expr->next);
	 if (size == NULL) {
	    ir_read_error(st, expr, "found non-integer array size");
	    return NULL;
	 }

	 return glsl_type::get_array_instance(base_type, size->value());
      } else if (strcmp(type_sym->value(), "struct") == 0) {
	 assert(false); // FINISHME
      } else {
	 ir_read_error(st, expr, "expected (array ...) or (struct ...); "
				 "found (%s ...)", type_sym->value());
	 return NULL;
      }
d144 1
a144 1
      ir_read_error(st, expr, "expected <type> (symbol or list)");
d148 1
a148 1
   const glsl_type *type = st->symbols->get_type(type_sym->value());
d150 1
a150 1
      ir_read_error(st, expr, "invalid type: %s", type_sym->value());
d156 2
a157 3
static void
scan_for_prototypes(_mesa_glsl_parse_state *st, exec_list *instructions,
		    s_expression *expr)
d161 1
a161 1
      ir_read_error(st, expr, "Expected (<instruction> ...); found an atom.");
d174 1
a174 1
      ir_function *f = read_function(st, sub, true);
d181 2
a182 2
static ir_function *
read_function(_mesa_glsl_parse_state *st, s_list *list, bool skip_body)
a183 1
   void *ctx = st;
d185 1
a185 4
   if (list->length() < 3) {
      ir_read_error(st, list, "Expected (function <name> (signature ...) ...)");
      return NULL;
   }
d187 3
a189 3
   s_symbol *name = SX_AS_SYMBOL(list->subexpressions.head->next);
   if (name == NULL) {
      ir_read_error(st, list, "Expected (function <name> ...)");
d193 1
a193 1
   ir_function *f = st->symbols->get_function(name->value());
d195 2
a196 2
      f = new(ctx) ir_function(name->value());
      added = st->symbols->add_function(f);
d200 1
a200 1
   exec_list_iterator it = list->subexpressions.iterator();
d204 2
a205 13
      s_list *siglist = SX_AS_LIST(it.get());
      if (siglist == NULL) {
	 ir_read_error(st, list, "Expected (function (signature ...) ...)");
	 return NULL;
      }

      s_symbol *tag = SX_AS_SYMBOL(siglist->subexpressions.get_head());
      if (tag == NULL || strcmp(tag->value(), "signature") != 0) {
	 ir_read_error(st, siglist, "Expected (signature ...)");
	 return NULL;
      }

      read_function_sig(st, f, siglist, skip_body);
d210 11
a220 8
static void
read_function_sig(_mesa_glsl_parse_state *st, ir_function *f, s_list *list,
		  bool skip_body)
{
   void *ctx = st;
   if (list->length() != 4) {
      ir_read_error(st, list, "Expected (signature <type> (parameters ...) "
			      "(<instruction> ...))");
d224 1
a224 2
   s_expression *type_expr = (s_expression*) list->subexpressions.head->next;
   const glsl_type *return_type = read_type(st, type_expr);
a227 7
   s_list *paramlist = SX_AS_LIST(type_expr->next);
   s_list *body_list = SX_AS_LIST(type_expr->next->next);
   if (paramlist == NULL || body_list == NULL) {
      ir_read_error(st, list, "Expected (signature <type> (parameters ...) "
			      "(<instruction> ...))");
      return;
   }
d230 1
a230 1
      ir_read_error(st, paramlist, "Expected (parameters ...)");
d236 1
a236 1
   st->symbols->push_scope();
d240 1
a240 2
      s_list *decl = SX_AS_LIST(it.get());
      ir_variable *var = read_declaration(st, decl);
d250 1
a250 1
      sig = new(ctx) ir_function_signature(return_type);
d256 1
a256 1
	 ir_read_error(st, list, "function `%s' parameter `%s' qualifiers "
d262 1
a262 1
	 ir_read_error(st, list, "function `%s' return type doesn't "
d268 1
a268 1
      st->symbols->pop_scope();
d277 1
a277 1
	 ir_read_error(st, list, "function %s redefined", f->name);
d280 3
a282 3
      st->current_function = sig;
      read_instructions(st, &sig->body, body_list, NULL);
      st->current_function = NULL;
d286 1
a286 1
   st->symbols->pop_scope();
d289 3
a291 3
static void
read_instructions(_mesa_glsl_parse_state *st, exec_list *instructions,
		  s_expression *expr, ir_loop *loop_ctx)
d296 1
a296 1
      ir_read_error(st, expr, "Expected (<instruction> ...); found an atom.");
d302 1
a302 1
      ir_instruction *ir = read_instruction(st, sub, loop_ctx);
d309 1
a309 1
	 if (st->current_function == NULL && ir->as_variable() != NULL)
d318 2
a319 3
static ir_instruction *
read_instruction(_mesa_glsl_parse_state *st, s_expression *expr,
	         ir_loop *loop_ctx)
a320 1
   void *ctx = st;
d324 1
a324 1
	 return new(ctx) ir_loop_jump(ir_loop_jump::jump_break);
d326 1
a326 1
	 return new(ctx) ir_loop_jump(ir_loop_jump::jump_continue);
d331 1
a331 1
      ir_read_error(st, expr, "Invalid instruction.\n");
d337 1
a337 1
      ir_read_error(st, expr, "expected instruction tag");
d343 1
a343 1
      inst = read_declaration(st, list);
d345 1
a345 1
      inst = read_assignment(st, list);
d347 1
a347 1
      inst = read_if(st, list, loop_ctx);
d349 1
a349 1
      inst = read_loop(st, list);
d351 1
a351 1
      inst = read_return(st, list);
d353 1
a353 1
      inst = read_function(st, list, false);
d355 1
a355 1
      inst = read_rvalue(st, list);
d357 1
a357 1
	 ir_read_error(st, NULL, "when reading instruction");
d362 2
a363 3

static ir_variable *
read_declaration(_mesa_glsl_parse_state *st, s_list *list)
d365 3
a367 6
   void *ctx = st;
   if (list->length() != 4) {
      ir_read_error(st, list, "expected (declare (<qualifiers>) <type> "
			      "<name>)");
      return NULL;
   }
d369 3
a371 3
   s_list *quals = SX_AS_LIST(list->subexpressions.head->next);
   if (quals == NULL) {
      ir_read_error(st, list, "expected a list of variable qualifiers");
d375 1
a375 2
   s_expression *type_expr = (s_expression*) quals->next;
   const glsl_type *type = read_type(st, type_expr);
d379 2
a380 5
   s_symbol *var_name = SX_AS_SYMBOL(type_expr->next);
   if (var_name == NULL) {
      ir_read_error(st, list, "expected variable name, found non-symbol");
      return NULL;
   }
d382 1
a382 4
   ir_variable *var = new(ctx) ir_variable(type, var_name->value(),
					   ir_var_auto);

   foreach_iter(exec_list_iterator, it, quals->subexpressions) {
d385 1
a385 2
	 ir_read_error(st, list, "qualifier list must contain only symbols");
	 delete var;
d400 2
d413 1
a413 2
	 ir_read_error(st, list, "unknown qualifier: %s", qualifier->value());
	 delete var;
d419 1
a419 1
   st->symbols->add_variable(var);
d425 2
a426 2
static ir_if *
read_if(_mesa_glsl_parse_state *st, s_list *list, ir_loop *loop_ctx)
d428 7
a434 4
   void *ctx = st;
   if (list->length() != 4) {
      ir_read_error(st, list, "expected (if <condition> (<then> ...) "
                          "(<else> ...))");
d438 1
a438 2
   s_expression *cond_expr = (s_expression*) list->subexpressions.head->next;
   ir_rvalue *condition = read_rvalue(st, cond_expr);
d440 1
a440 1
      ir_read_error(st, NULL, "when reading condition of (if ...)");
d444 1
a444 2
   s_expression *then_expr = (s_expression*) cond_expr->next;
   s_expression *else_expr = (s_expression*) then_expr->next;
d446 3
a448 5
   ir_if *iff = new(ctx) ir_if(condition);

   read_instructions(st, &iff->then_instructions, then_expr, loop_ctx);
   read_instructions(st, &iff->else_instructions, else_expr, loop_ctx);
   if (st->error) {
d456 2
a457 2
static ir_loop *
read_loop(_mesa_glsl_parse_state *st, s_list *list)
d459 6
a464 4
   void *ctx = st;
   if (list->length() != 6) {
      ir_read_error(st, list, "expected (loop <counter> <from> <to> "
			      "<increment> <body>)");
a467 6
   s_expression *count_expr = (s_expression*) list->subexpressions.head->next;
   s_expression *from_expr  = (s_expression*) count_expr->next;
   s_expression *to_expr    = (s_expression*) from_expr->next;
   s_expression *inc_expr   = (s_expression*) to_expr->next;
   s_expression *body_expr  = (s_expression*) inc_expr->next;

d470 3
a472 3
   ir_loop *loop = new(ctx) ir_loop;
   read_instructions(st, &loop->body_instructions, body_expr, loop);
   if (st->error) {
d480 2
a481 2
static ir_return *
read_return(_mesa_glsl_parse_state *st, s_list *list)
d483 5
a487 3
   void *ctx = st;
   if (list->length() != 2) {
      ir_read_error(st, list, "expected (return <rvalue>)");
d491 1
a491 3
   s_expression *expr = (s_expression*) list->subexpressions.head->next;

   ir_rvalue *retval = read_rvalue(st, expr);
d493 1
a493 1
      ir_read_error(st, NULL, "when reading return value");
d497 1
a497 1
   return new(ctx) ir_return(retval);
d501 2
a502 2
static ir_rvalue *
read_rvalue(_mesa_glsl_parse_state *st, s_expression *expr)
d510 1
a510 1
      ir_read_error(st, expr, "expected rvalue tag");
d514 2
a515 2
   ir_rvalue *rvalue = read_dereference(st, list);
   if (rvalue != NULL || st->error)
d518 1
a518 1
      rvalue = read_swizzle(st, list);
d520 1
a520 1
      rvalue = read_expression(st, list);
d522 1
a522 1
      rvalue = read_call(st, list);
d524 1
a524 1
      rvalue = read_constant(st, list);
d526 3
a528 3
      rvalue = read_texture(st, list);
      if (rvalue == NULL && !st->error)
	 ir_read_error(st, expr, "unrecognized rvalue tag: %s", tag->value());
d534 2
a535 2
static ir_assignment *
read_assignment(_mesa_glsl_parse_state *st, s_list *list)
d537 9
a545 4
   void *ctx = st;
   if (list->length() != 5) {
      ir_read_error(st, list, "expected (assign <condition> (<write mask>) "
			      "<lhs> <rhs>)");
d549 7
a555 14
   s_expression *cond_expr = (s_expression*) list->subexpressions.head->next;
   s_list       *mask_list = SX_AS_LIST(cond_expr->next);
   s_expression *lhs_expr  = (s_expression*) cond_expr->next->next;
   s_expression *rhs_expr  = (s_expression*) lhs_expr->next;

   ir_rvalue *condition = read_rvalue(st, cond_expr);
   if (condition == NULL) {
      ir_read_error(st, NULL, "when reading condition of assignment");
      return NULL;
   }

   if (mask_list == NULL || mask_list->length() > 1) {
      ir_read_error(st, mask_list, "expected () or (<write mask>)");
      return NULL;
a558 6
   if (mask_list->length() == 1) {
      s_symbol *mask_symbol = SX_AS_SYMBOL(mask_list->subexpressions.head);
      if (mask_symbol == NULL) {
	 ir_read_error(st, list, "expected a write mask; found non-symbol");
	 return NULL;
      }
d560 3
d566 1
a566 1
	 ir_read_error(st, list, "invalid write mask: %s", mask_str);
d574 1
a574 1
	    ir_read_error(st, list, "write mask contains invalid character: %c",
d580 3
d585 1
a585 1
   ir_dereference *lhs = read_dereference(st, lhs_expr);
d587 1
a587 1
      ir_read_error(st, NULL, "when reading left-hand side of assignment");
d591 1
a591 1
   ir_rvalue *rhs = read_rvalue(st, rhs_expr);
d593 1
a593 1
      ir_read_error(st, NULL, "when reading right-hand side of assignment");
d598 1
a598 1
      ir_read_error(st, list, "non-zero write mask required.");
d602 1
a602 1
   return new(ctx) ir_assignment(lhs, rhs, condition, mask);
d605 2
a606 2
static ir_call *
read_call(_mesa_glsl_parse_state *st, s_list *list)
d608 2
a609 5
   void *ctx = st;
   if (list->length() != 3) {
      ir_read_error(st, list, "expected (call <name> (<param> ...))");
      return NULL;
   }
d611 3
a613 4
   s_symbol *name = SX_AS_SYMBOL(list->subexpressions.head->next);
   s_list *params = SX_AS_LIST(list->subexpressions.head->next->next);
   if (name == NULL || params == NULL) {
      ir_read_error(st, list, "expected (call <name> (<param> ...))");
d621 1
a621 1
      ir_rvalue *param = read_rvalue(st, expr);
d623 1
a623 1
	 ir_read_error(st, list, "when reading parameter to function call");
d629 1
a629 1
   ir_function *f = st->symbols->get_function(name->value());
d631 1
a631 1
      ir_read_error(st, list, "found call to undefined function %s",
d638 1
a638 1
      ir_read_error(st, list, "couldn't find matching signature for function "
d643 1
a643 1
   return new(ctx) ir_call(callee, &parameters);
d646 2
a647 2
static ir_expression *
read_expression(_mesa_glsl_parse_state *st, s_list *list)
d649 8
a656 5
   void *ctx = st;
   const unsigned list_length = list->length();
   if (list_length < 4) {
      ir_read_error(st, list, "expected (expression <type> <operator> "
			      "<operand> [<operand>])");
d659 1
d661 1
a661 2
   s_expression *type_expr = (s_expression*) list->subexpressions.head->next;
   const glsl_type *type = read_type(st, type_expr);
d666 1
a666 7
   s_symbol *op_sym = SX_AS_SYMBOL(type_expr->next);
   if (op_sym == NULL) {
      ir_read_error(st, list, "expected operator, found non-symbol");
      return NULL;
   }

   ir_expression_operation op = ir_expression::get_operator(op_sym->value());
d668 1
a668 1
      ir_read_error(st, list, "invalid operator: %s", op_sym->value());
d672 5
a676 13
   /* Now that we know the operator, check for the right number of operands */ 
   if (ir_expression::get_num_operands(op) == 2) {
      if (list_length != 5) {
	 ir_read_error(st, list, "expected (expression <type> %s <operand> "
				 " <operand>)", op_sym->value());
	 return NULL;
      }
   } else {
      if (list_length != 4) {
	 ir_read_error(st, list, "expected (expression <type> %s <operand>)",
		       op_sym->value());
	 return NULL;
      }
d679 2
a680 2
   s_expression *exp1 = (s_expression*) (op_sym->next);
   ir_rvalue *arg1 = read_rvalue(st, exp1);
d682 1
a682 2
      ir_read_error(st, NULL, "when reading first operand of %s",
		    op_sym->value());
d686 7
a692 4
   ir_rvalue *arg2 = NULL;
   if (ir_expression::get_num_operands(op) == 2) {
      s_expression *exp2 = (s_expression*) (exp1->next);
      arg2 = read_rvalue(st, exp2);
d694 2
a695 2
	 ir_read_error(st, NULL, "when reading second operand of %s",
		       op_sym->value());
d700 1
a700 1
   return new(ctx) ir_expression(op, type, arg1, arg2);
d703 2
a704 2
static ir_swizzle *
read_swizzle(_mesa_glsl_parse_state *st, s_list *list)
d706 2
a707 4
   if (list->length() != 3) {
      ir_read_error(st, list, "expected (swiz <swizzle> <rvalue>)");
      return NULL;
   }
d709 3
a711 3
   s_symbol *swiz = SX_AS_SYMBOL(list->subexpressions.head->next);
   if (swiz == NULL) {
      ir_read_error(st, list, "expected a valid swizzle; found non-symbol");
d716 1
a716 2
      ir_read_error(st, list, "expected a valid swizzle; found %s",
		    swiz->value());
d720 1
a720 2
   s_expression *sub = (s_expression*) swiz->next;
   ir_rvalue *rvalue = read_rvalue(st, sub);
d727 1
a727 1
      ir_read_error(st, list, "invalid swizzle");
d732 2
a733 2
static ir_constant *
read_constant(_mesa_glsl_parse_state *st, s_list *list)
d735 6
a740 3
   void *ctx = st;
   if (list->length() != 3) {
      ir_read_error(st, list, "expected (constant <type> (...))");
d744 1
a744 2
   s_expression *type_expr = (s_expression*) list->subexpressions.head->next;
   const glsl_type *type = read_type(st, type_expr);
a747 1
   s_list *values = SX_AS_LIST(type_expr->next);
d749 1
a749 1
      ir_read_error(st, list, "expected (constant <type> (...))");
d754 1
a754 7
      const unsigned elements_supplied = values->length();
      if (elements_supplied != type->length) {
	 ir_read_error(st, values, "expected exactly %u array elements, "
		       "given %u", type->length, elements_supplied);
	 return NULL;
      }

d757 2
a758 8
	 s_expression *expr = (s_expression *) it.get();
	 s_list *elt = SX_AS_LIST(expr);
	 if (elt == NULL) {
	    ir_read_error(st, expr, "expected (constant ...) array element");
	    return NULL;
	 }

	 ir_constant *ir_elt = read_constant(st, elt);
d762 1
d764 7
a770 1
      return new(ctx) ir_constant(type, &elements);
d781 1
a781 1
	 ir_read_error(st, values, "expected at most 16 numbers");
d790 1
a790 1
	    ir_read_error(st, values, "expected numbers");
d797 1
a797 1
	    ir_read_error(st, values, "expected integers");
d815 1
a815 1
	    ir_read_error(st, values, "unsupported constant type");
d822 1
a822 1
   return new(ctx) ir_constant(type, &data);
d825 2
a826 2
static ir_dereference *
read_dereference(_mesa_glsl_parse_state *st, s_expression *expr)
d828 4
a831 3
   s_list *list = SX_AS_LIST(expr);
   if (list == NULL || list->subexpressions.is_empty())
      return NULL;
d833 3
a835 2
   s_symbol *tag = SX_AS_SYMBOL(list->subexpressions.head);
   assert(tag != NULL);
d837 13
a849 8
   if (strcmp(tag->value(), "var_ref") == 0)
      return read_var_ref(st, list);
   if (strcmp(tag->value(), "array_ref") == 0)
      return read_array_ref(st, list);
   if (strcmp(tag->value(), "record_ref") == 0)
      return read_record_ref(st, list);
   return NULL;
}
d851 13
a863 7
static ir_dereference_variable *
read_var_ref(_mesa_glsl_parse_state *st, s_list *list)
{
   void *ctx = st;
   if (list->length() != 2) {
      ir_read_error(st, list, "expected (var_ref <variable name>)");
      return NULL;
d865 1
a865 13
   s_symbol *var_name = SX_AS_SYMBOL(list->subexpressions.head->next);
   if (var_name == NULL) {
      ir_read_error(st, list, "expected (var_ref <variable name>)");
      return NULL;
   }

   ir_variable *var = st->symbols->get_variable(var_name->value());
   if (var == NULL) {
      ir_read_error(st, list, "undeclared variable: %s", var_name->value());
      return NULL;
   }

   return new(ctx) ir_dereference_variable(var);
d868 2
a869 2
static ir_dereference_array *
read_array_ref(_mesa_glsl_parse_state *st, s_list *list)
d871 28
a898 37
   void *ctx = st;
   if (list->length() != 3) {
      ir_read_error(st, list, "expected (array_ref <rvalue> <index>)");
      return NULL;
   }

   s_expression *subj_expr = (s_expression*) list->subexpressions.head->next;
   ir_rvalue *subject = read_rvalue(st, subj_expr);
   if (subject == NULL) {
      ir_read_error(st, NULL, "when reading the subject of an array_ref");
      return NULL;
   }

   s_expression *idx_expr = (s_expression*) subj_expr->next;
   ir_rvalue *idx = read_rvalue(st, idx_expr);
   return new(ctx) ir_dereference_array(subject, idx);
}

static ir_dereference_record *
read_record_ref(_mesa_glsl_parse_state *st, s_list *list)
{
   void *ctx = st;
   if (list->length() != 3) {
      ir_read_error(st, list, "expected (record_ref <rvalue> <field>)");
      return NULL;
   }

   s_expression *subj_expr = (s_expression*) list->subexpressions.head->next;
   ir_rvalue *subject = read_rvalue(st, subj_expr);
   if (subject == NULL) {
      ir_read_error(st, NULL, "when reading the subject of a record_ref");
      return NULL;
   }

   s_symbol *field = SX_AS_SYMBOL(subj_expr->next);
   if (field == NULL) {
      ir_read_error(st, list, "expected (record_ref ... <field name>)");
a900 11
   return new(ctx) ir_dereference_record(subject, field->value());
}

static bool
valid_texture_list_length(ir_texture_opcode op, s_list *list)
{
   unsigned required_length = 7;
   if (op == ir_txf)
      required_length = 5;
   else if (op == ir_tex)
      required_length = 6;
d902 1
a902 2
   return list->length() == required_length;
}
d904 5
a908 13
static ir_texture *
read_texture(_mesa_glsl_parse_state *st, s_list *list)
{
   void *ctx = st;
   s_symbol *tag = SX_AS_SYMBOL(list->subexpressions.head);
   assert(tag != NULL);

   ir_texture_opcode op = ir_texture::get_opcode(tag->value());
   if (op == (ir_texture_opcode) -1)
      return NULL;

   if (!valid_texture_list_length(op, list)) {
      ir_read_error(st, NULL, "invalid list size in (%s ...)", tag->value());
a911 2
   ir_texture *tex = new(ctx) ir_texture(op);

d913 1
a913 2
   s_expression *sampler_expr = (s_expression *) tag->next;
   ir_dereference *sampler = read_dereference(st, sampler_expr);
d915 2
a916 1
      ir_read_error(st, NULL, "when reading sampler in (%s ...)", tag->value());
d919 1
a919 1
   tex->set_sampler(sampler);
d922 1
a922 2
   s_expression *coordinate_expr = (s_expression *) sampler_expr->next;
   tex->coordinate = read_rvalue(st, coordinate_expr);
d924 2
a925 2
      ir_read_error(st, NULL, "when reading coordinate in (%s ...)",
		    tag->value());
d929 8
a936 12
   // Read texel offset, i.e. (0 0 0)
   s_list *offset_list = SX_AS_LIST(coordinate_expr->next);
   if (offset_list == NULL || offset_list->length() != 3) {
      ir_read_error(st, offset_list, "expected (<int> <int> <int>)");
      return NULL;
   }
   s_int *offset_x = SX_AS_INT(offset_list->subexpressions.head);
   s_int *offset_y = SX_AS_INT(offset_list->subexpressions.head->next);
   s_int *offset_z = SX_AS_INT(offset_list->subexpressions.head->next->next);
   if (offset_x == NULL || offset_y == NULL || offset_z == NULL) {
      ir_read_error(st, offset_list, "expected (<int> <int> <int>)");
      return NULL;
a937 3
   tex->offsets[0] = offset_x->value();
   tex->offsets[1] = offset_y->value();
   tex->offsets[2] = offset_z->value();
d939 2
a940 10
   if (op == ir_txf) {
      s_expression *lod_expr = (s_expression *) offset_list->next;
      tex->lod_info.lod = read_rvalue(st, lod_expr);
      if (tex->lod_info.lod == NULL) {
	 ir_read_error(st, NULL, "when reading LOD in (txf ...)");
	 return NULL;
      }
   } else {
      s_expression *proj_expr = (s_expression *) offset_list->next;
      s_int *proj_as_int = SX_AS_INT(proj_expr);
d944 1
a944 1
	 tex->projector = read_rvalue(st, proj_expr);
d946 2
a947 2
	    ir_read_error(st, NULL, "when reading projective divide in (%s ..)",
	                  tag->value());
d952 2
a953 7
      s_list *shadow_list = SX_AS_LIST(proj_expr->next);
      if (shadow_list == NULL) {
	 ir_read_error(st, NULL, "shadow comparitor must be a list");
	 return NULL;
      }
      if (shadow_list->subexpressions.is_empty()) {
	 tex->shadow_comparitor= NULL;
d955 1
a955 1
	 tex->shadow_comparitor = read_rvalue(st, shadow_list);
d957 2
a958 2
	    ir_read_error(st, NULL, "when reading shadow comparitor in (%s ..)",
			  tag->value());
d962 1
a962 1
      s_expression *lod_expr = (s_expression *) shadow_list->next;
d964 33
a996 35
      switch (op) {
      case ir_txb:
	 tex->lod_info.bias = read_rvalue(st, lod_expr);
	 if (tex->lod_info.bias == NULL) {
	    ir_read_error(st, NULL, "when reading LOD bias in (txb ...)");
	    return NULL;
	 }
	 break;
      case ir_txl:
	 tex->lod_info.lod = read_rvalue(st, lod_expr);
	 if (tex->lod_info.lod == NULL) {
	    ir_read_error(st, NULL, "when reading LOD in (txl ...)");
	    return NULL;
	 }
	 break;
      case ir_txd: {
	 s_list *lod_list = SX_AS_LIST(lod_expr);
	 if (lod_list->length() != 2) {
	    ir_read_error(st, lod_expr, "expected (dPdx dPdy) in (txd ...)");
	    return NULL;
	 }
	 s_expression *dx_expr = (s_expression *) lod_list->subexpressions.head;
	 s_expression *dy_expr = (s_expression *) dx_expr->next;

	 tex->lod_info.grad.dPdx = read_rvalue(st, dx_expr);
	 if (tex->lod_info.grad.dPdx == NULL) {
	    ir_read_error(st, NULL, "when reading dPdx in (txd ...)");
	    return NULL;
	 }
	 tex->lod_info.grad.dPdy = read_rvalue(st, dy_expr);
	 if (tex->lod_info.grad.dPdy == NULL) {
	    ir_read_error(st, NULL, "when reading dPdy in (txd ...)");
	    return NULL;
	 }
	 break;
d998 1
a998 4
      default:
	 // tex doesn't have any extra parameters and txf was handled earlier.
	 break;
      };
d1000 4
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d24 2
d33 36
a68 40
class ir_reader {
public:
   ir_reader(_mesa_glsl_parse_state *);

   void read(exec_list *instructions, const char *src, bool scan_for_protos);

private:
   void *mem_ctx;
   _mesa_glsl_parse_state *state;

   void ir_read_error(s_expression *, const char *fmt, ...);

   const glsl_type *read_type(s_expression *);

   void scan_for_prototypes(exec_list *, s_expression *);
   ir_function *read_function(s_expression *, bool skip_body);
   void read_function_sig(ir_function *, s_expression *, bool skip_body);

   void read_instructions(exec_list *, s_expression *, ir_loop *);
   ir_instruction *read_instruction(s_expression *, ir_loop *);
   ir_variable *read_declaration(s_expression *);
   ir_if *read_if(s_expression *, ir_loop *);
   ir_loop *read_loop(s_expression *);
   ir_call *read_call(s_expression *);
   ir_return *read_return(s_expression *);
   ir_rvalue *read_rvalue(s_expression *);
   ir_assignment *read_assignment(s_expression *);
   ir_expression *read_expression(s_expression *);
   ir_swizzle *read_swizzle(s_expression *);
   ir_constant *read_constant(s_expression *);
   ir_texture *read_texture(s_expression *);

   ir_dereference *read_dereference(s_expression *);
   ir_dereference_variable *read_var_ref(s_expression *);
};

ir_reader::ir_reader(_mesa_glsl_parse_state *state) : state(state)
{
   this->mem_ctx = state;
}
d74 1
a74 9
   ir_reader r(state);
   r.read(instructions, src, scan_for_protos);
}

void
ir_reader::read(exec_list *instructions, const char *src, bool scan_for_protos)
{
   void *sx_mem_ctx = ralloc_context(NULL);
   s_expression *expr = s_expression::read_expression(sx_mem_ctx, src);
d76 1
a76 1
      ir_read_error(NULL, "couldn't parse S-Expression.");
d81 1
a81 1
      scan_for_prototypes(instructions, expr);
d86 2
a87 2
   read_instructions(instructions, expr, NULL);
   ralloc_free(sx_mem_ctx);
d93 3
a95 2
void
ir_reader::ir_read_error(s_expression *expr, const char *fmt, ...)
d118 2
a119 2
const glsl_type *
ir_reader::read_type(s_expression *expr)
d121 20
a140 2
   s_expression *s_base_type;
   s_int *s_size;
d142 13
a154 5
   s_pattern pat[] = { "array", s_base_type, s_size };
   if (MATCH(expr, pat)) {
      const glsl_type *base_type = read_type(s_base_type);
      if (base_type == NULL) {
	 ir_read_error(NULL, "when reading base type of array type");
a156 2

      return glsl_type::get_array_instance(base_type, s_size->value());
d161 1
a161 1
      ir_read_error(expr, "expected <type>");
d165 1
a165 1
   const glsl_type *type = state->symbols->get_type(type_sym->value());
d167 1
a167 1
      ir_read_error(expr, "invalid type: %s", type_sym->value());
d173 3
a175 2
void
ir_reader::scan_for_prototypes(exec_list *instructions, s_expression *expr)
d179 1
a179 1
      ir_read_error(expr, "Expected (<instruction> ...); found an atom.");
d192 1
a192 1
      ir_function *f = read_function(sub, true);
d199 2
a200 2
ir_function *
ir_reader::read_function(s_expression *expr, bool skip_body)
d202 1
d204 4
a207 1
   s_symbol *name;
d209 3
a211 3
   s_pattern pat[] = { "function", name };
   if (!PARTIAL_MATCH(expr, pat)) {
      ir_read_error(expr, "Expected (function <name> (signature ...) ...)");
d215 1
a215 1
   ir_function *f = state->symbols->get_function(name->value());
d217 2
a218 2
      f = new(mem_ctx) ir_function(name->value());
      added = state->symbols->add_function(f);
d222 1
a222 1
   exec_list_iterator it = ((s_list *) expr)->subexpressions.iterator();
d226 13
a238 2
      s_expression *s_sig = (s_expression *) it.get();
      read_function_sig(f, s_sig, skip_body);
d243 8
a250 11
void
ir_reader::read_function_sig(ir_function *f, s_expression *expr, bool skip_body)
{
   s_expression *type_expr;
   s_list *paramlist;
   s_list *body_list;

   s_pattern pat[] = { "signature", type_expr, paramlist, body_list };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "Expected (signature <type> (parameters ...) "
			  "(<instruction> ...))");
d254 2
a255 1
   const glsl_type *return_type = read_type(type_expr);
d259 7
d268 1
a268 1
      ir_read_error(paramlist, "Expected (parameters ...)");
d274 1
a274 1
   state->symbols->push_scope();
d278 2
a279 1
      ir_variable *var = read_declaration((s_expression *) it.get());
d289 1
a289 1
      sig = new(mem_ctx) ir_function_signature(return_type);
d295 1
a295 1
	 ir_read_error(expr, "function `%s' parameter `%s' qualifiers "
d301 1
a301 1
	 ir_read_error(expr, "function `%s' return type doesn't "
d307 1
a307 1
      state->symbols->pop_scope();
d316 1
a316 1
	 ir_read_error(expr, "function %s redefined", f->name);
d319 3
a321 3
      state->current_function = sig;
      read_instructions(&sig->body, body_list, NULL);
      state->current_function = NULL;
d325 1
a325 1
   state->symbols->pop_scope();
d328 3
a330 3
void
ir_reader::read_instructions(exec_list *instructions, s_expression *expr,
			     ir_loop *loop_ctx)
d335 1
a335 1
      ir_read_error(expr, "Expected (<instruction> ...); found an atom.");
d341 1
a341 1
      ir_instruction *ir = read_instruction(sub, loop_ctx);
d348 1
a348 1
	 if (state->current_function == NULL && ir->as_variable() != NULL)
d357 3
a359 2
ir_instruction *
ir_reader::read_instruction(s_expression *expr, ir_loop *loop_ctx)
d361 1
d365 1
a365 1
	 return new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break);
d367 1
a367 1
	 return new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_continue);
d372 1
a372 1
      ir_read_error(expr, "Invalid instruction.\n");
d378 1
a378 1
      ir_read_error(expr, "expected instruction tag");
d384 1
a384 1
      inst = read_declaration(list);
d386 1
a386 1
      inst = read_assignment(list);
d388 1
a388 1
      inst = read_if(list, loop_ctx);
d390 1
a390 3
      inst = read_loop(list);
   } else if (strcmp(tag->value(), "call") == 0) {
      inst = read_call(list);
d392 1
a392 1
      inst = read_return(list);
d394 1
a394 1
      inst = read_function(list, false);
d396 1
a396 1
      inst = read_rvalue(list);
d398 1
a398 1
	 ir_read_error(NULL, "when reading instruction");
d403 3
a405 2
ir_variable *
ir_reader::read_declaration(s_expression *expr)
d407 6
a412 3
   s_list *s_quals;
   s_expression *s_type;
   s_symbol *s_name;
d414 3
a416 3
   s_pattern pat[] = { "declare", s_quals, s_type, s_name };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "expected (declare (<qualifiers>) <type> <name>)");
d420 2
a421 1
   const glsl_type *type = read_type(s_type);
d425 8
a432 2
   ir_variable *var = new(mem_ctx) ir_variable(type, s_name->value(),
					       ir_var_auto);
d434 1
a434 1
   foreach_iter(exec_list_iterator, it, s_quals->subexpressions) {
d437 2
a438 1
	 ir_read_error(expr, "qualifier list must contain only symbols");
d452 1
a452 5
	 var->mode = ir_var_function_in;
      } else if (strcmp(qualifier->value(), "shader_in") == 0) {
         var->mode = ir_var_shader_in;
      } else if (strcmp(qualifier->value(), "const_in") == 0) {
	 var->mode = ir_var_const_in;
d454 1
a454 3
	 var->mode = ir_var_function_out;
      } else if (strcmp(qualifier->value(), "shader_out") == 0) {
	 var->mode = ir_var_shader_out;
d456 1
a456 3
	 var->mode = ir_var_function_inout;
      } else if (strcmp(qualifier->value(), "temporary") == 0) {
	 var->mode = ir_var_temporary;
d458 1
a458 1
	 var->interpolation = INTERP_QUALIFIER_SMOOTH;
d460 1
a460 1
	 var->interpolation = INTERP_QUALIFIER_FLAT;
d462 1
a462 1
	 var->interpolation = INTERP_QUALIFIER_NOPERSPECTIVE;
d464 2
a465 1
	 ir_read_error(expr, "unknown qualifier: %s", qualifier->value());
d471 1
a471 1
   state->symbols->add_variable(var);
d477 2
a478 2
ir_if *
ir_reader::read_if(s_expression *expr, ir_loop *loop_ctx)
d480 4
a483 7
   s_expression *s_cond;
   s_expression *s_then;
   s_expression *s_else;

   s_pattern pat[] = { "if", s_cond, s_then, s_else };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "expected (if <condition> (<then>...) (<else>...))");
d487 2
a488 1
   ir_rvalue *condition = read_rvalue(s_cond);
d490 1
a490 1
      ir_read_error(NULL, "when reading condition of (if ...)");
d494 2
a495 1
   ir_if *iff = new(mem_ctx) ir_if(condition);
d497 5
a501 3
   read_instructions(&iff->then_instructions, s_then, loop_ctx);
   read_instructions(&iff->else_instructions, s_else, loop_ctx);
   if (state->error) {
d509 2
a510 2
ir_loop *
ir_reader::read_loop(s_expression *expr)
d512 4
a515 6
   s_expression *s_counter, *s_from, *s_to, *s_inc, *s_body;

   s_pattern pat[] = { "loop", s_counter, s_from, s_to, s_inc, s_body };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "expected (loop <counter> <from> <to> "
			  "<increment> <body>)");
d519 6
d527 3
a529 3
   ir_loop *loop = new(mem_ctx) ir_loop;
   read_instructions(&loop->body_instructions, s_body, loop);
   if (state->error) {
d537 2
a538 2
ir_return *
ir_reader::read_return(s_expression *expr)
d540 5
a544 1
   s_expression *s_retval;
d546 5
a550 13
   s_pattern return_value_pat[] = { "return", s_retval};
   s_pattern return_void_pat[] = { "return" };
   if (MATCH(expr, return_value_pat)) {
      ir_rvalue *retval = read_rvalue(s_retval);
      if (retval == NULL) {
         ir_read_error(NULL, "when reading return value");
         return NULL;
      }
      return new(mem_ctx) ir_return(retval);
   } else if (MATCH(expr, return_void_pat)) {
      return new(mem_ctx) ir_return;
   } else {
      ir_read_error(expr, "expected (return <rvalue>) or (return)");
d553 2
d558 2
a559 2
ir_rvalue *
ir_reader::read_rvalue(s_expression *expr)
d567 1
a567 1
      ir_read_error(expr, "expected rvalue tag");
d571 2
a572 2
   ir_rvalue *rvalue = read_dereference(list);
   if (rvalue != NULL || state->error)
d575 1
a575 1
      rvalue = read_swizzle(list);
d577 3
a579 1
      rvalue = read_expression(list);
d581 1
a581 1
      rvalue = read_constant(list);
d583 3
a585 3
      rvalue = read_texture(list);
      if (rvalue == NULL && !state->error)
	 ir_read_error(expr, "unrecognized rvalue tag: %s", tag->value());
d591 2
a592 2
ir_assignment *
ir_reader::read_assignment(s_expression *expr)
d594 15
a608 9
   s_expression *cond_expr = NULL;
   s_expression *lhs_expr, *rhs_expr;
   s_list       *mask_list;

   s_pattern pat4[] = { "assign",            mask_list, lhs_expr, rhs_expr };
   s_pattern pat5[] = { "assign", cond_expr, mask_list, lhs_expr, rhs_expr };
   if (!MATCH(expr, pat4) && !MATCH(expr, pat5)) {
      ir_read_error(expr, "expected (assign [<condition>] (<write mask>) "
			  "<lhs> <rhs>)");
d612 3
a614 7
   ir_rvalue *condition = NULL;
   if (cond_expr != NULL) {
      condition = read_rvalue(cond_expr);
      if (condition == NULL) {
	 ir_read_error(NULL, "when reading condition of assignment");
	 return NULL;
      }
d618 6
a624 3
   s_symbol *mask_symbol;
   s_pattern mask_pat[] = { mask_symbol };
   if (MATCH(mask_list, mask_pat)) {
d628 1
a628 1
	 ir_read_error(expr, "invalid write mask: %s", mask_str);
d636 1
a636 1
	    ir_read_error(expr, "write mask contains invalid character: %c",
a641 3
   } else if (!mask_list->subexpressions.is_empty()) {
      ir_read_error(mask_list, "expected () or (<write mask>)");
      return NULL;
d644 1
a644 1
   ir_dereference *lhs = read_dereference(lhs_expr);
d646 1
a646 1
      ir_read_error(NULL, "when reading left-hand side of assignment");
d650 1
a650 1
   ir_rvalue *rhs = read_rvalue(rhs_expr);
d652 1
a652 1
      ir_read_error(NULL, "when reading right-hand side of assignment");
d657 1
a657 1
      ir_read_error(expr, "non-zero write mask required.");
d661 1
a661 1
   return new(mem_ctx) ir_assignment(lhs, rhs, condition, mask);
d664 2
a665 2
ir_call *
ir_reader::read_call(s_expression *expr)
d667 5
a671 5
   s_symbol *name;
   s_list *params;
   s_list *s_return = NULL;

   ir_dereference_variable *return_deref = NULL;
d673 4
a676 10
   s_pattern void_pat[] = { "call", name, params };
   s_pattern non_void_pat[] = { "call", name, s_return, params };
   if (MATCH(expr, non_void_pat)) {
      return_deref = read_var_ref(s_return);
      if (return_deref == NULL) {
	 ir_read_error(s_return, "when reading a call's return storage");
	 return NULL;
      }
   } else if (!MATCH(expr, void_pat)) {
      ir_read_error(expr, "expected (call <name> [<deref>] (<param> ...))");
d684 1
a684 1
      ir_rvalue *param = read_rvalue(expr);
d686 1
a686 1
	 ir_read_error(expr, "when reading parameter to function call");
d692 1
a692 1
   ir_function *f = state->symbols->get_function(name->value());
d694 1
a694 1
      ir_read_error(expr, "found call to undefined function %s",
d701 1
a701 1
      ir_read_error(expr, "couldn't find matching signature for function "
d706 1
a706 9
   if (callee->return_type == glsl_type::void_type && return_deref) {
      ir_read_error(expr, "call has return value storage but void type");
      return NULL;
   } else if (callee->return_type != glsl_type::void_type && !return_deref) {
      ir_read_error(expr, "call has non-void type but no return value storage");
      return NULL;
   }

   return new(mem_ctx) ir_call(callee, return_deref, &parameters);
d709 2
a710 2
ir_expression *
ir_reader::read_expression(s_expression *expr)
d712 5
a716 8
   s_expression *s_type;
   s_symbol *s_op;
   s_expression *s_arg[4] = {NULL};

   s_pattern pat[] = { "expression", s_type, s_op, s_arg[0] };
   if (!PARTIAL_MATCH(expr, pat)) {
      ir_read_error(expr, "expected (expression <type> <operator> "
			  "<operand> [<operand>] [<operand>] [<operand>])");
a718 4
   s_arg[1] = (s_expression *) s_arg[0]->next; // may be tail sentinel
   s_arg[2] = (s_expression *) s_arg[1]->next; // may be tail sentinel or NULL
   if (s_arg[2])
      s_arg[3] = (s_expression *) s_arg[2]->next; // may be tail sentinel or NULL
d720 2
a721 1
   const glsl_type *type = read_type(s_type);
d726 7
a732 1
   ir_expression_operation op = ir_expression::get_operator(s_op->value());
d734 1
a734 1
      ir_read_error(expr, "invalid operator: %s", s_op->value());
d738 14
a751 3
   int num_operands = -3; /* skip "expression" <type> <operation> */
   foreach_list(n, &((s_list *) expr)->subexpressions)
      ++num_operands;
d753 5
a757 4
   int expected_operands = ir_expression::get_num_operands(op);
   if (num_operands != expected_operands) {
      ir_read_error(expr, "found %d expression operands, expected %d",
                    num_operands, expected_operands);
d761 8
a768 6
   ir_rvalue *arg[4] = {NULL};
   for (int i = 0; i < num_operands; i++) {
      arg[i] = read_rvalue(s_arg[i]);
      if (arg[i] == NULL) {
         ir_read_error(NULL, "when reading operand #%d of %s", i, s_op->value());
         return NULL;
d772 1
a772 1
   return new(mem_ctx) ir_expression(op, type, arg[0], arg[1], arg[2], arg[3]);
d775 2
a776 2
ir_swizzle *
ir_reader::read_swizzle(s_expression *expr)
d778 4
a781 2
   s_symbol *swiz;
   s_expression *sub;
d783 3
a785 3
   s_pattern pat[] = { "swiz", swiz, sub };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "expected (swiz <swizzle> <rvalue>)");
d790 2
a791 1
      ir_read_error(expr, "expected a valid swizzle; found %s", swiz->value());
d795 2
a796 1
   ir_rvalue *rvalue = read_rvalue(sub);
d803 1
a803 1
      ir_read_error(expr, "invalid swizzle");
d808 2
a809 2
ir_constant *
ir_reader::read_constant(s_expression *expr)
d811 3
a813 6
   s_expression *type_expr;
   s_list *values;

   s_pattern pat[] = { "constant", type_expr, values };
   if (!MATCH(expr, pat)) {
      ir_read_error(expr, "expected (constant <type> (...))");
d817 2
a818 1
   const glsl_type *type = read_type(type_expr);
d822 1
d824 1
a824 1
      ir_read_error(expr, "expected (constant <type> (...))");
d829 7
a835 1
      unsigned elements_supplied = 0;
d838 8
a845 2
	 s_expression *elt = (s_expression *) it.get();
	 ir_constant *ir_elt = read_constant(elt);
a848 1
	 elements_supplied++;
d850 2
d853 1
a853 7
      if (elements_supplied != type->length) {
	 ir_read_error(values, "expected exactly %u array elements, "
		       "given %u", type->length, elements_supplied);
	 return NULL;
      }
      return new(mem_ctx) ir_constant(type, &elements);
   }
d858 1
a858 1
   unsigned k = 0;
d861 1
a861 1
	 ir_read_error(values, "expected at most 16 numbers");
d867 1
a867 1
      if (type->base_type == GLSL_TYPE_FLOAT) {
d870 1
a870 1
	    ir_read_error(values, "expected numbers");
d877 1
a877 1
	    ir_read_error(values, "expected integers");
d881 1
a881 1
	 switch (type->base_type) {
d895 1
a895 1
	    ir_read_error(values, "unsupported constant type");
d901 9
a909 3
   if (k != type->components()) {
      ir_read_error(values, "expected %u constant values, found %u",
		    type->components(), k);
a910 1
   }
d912 10
a921 1
   return new(mem_ctx) ir_constant(type, &data);
d924 2
a925 2
ir_dereference_variable *
ir_reader::read_var_ref(s_expression *expr)
d927 10
a936 2
   s_symbol *s_var;
   s_pattern var_pat[] = { "var_ref", s_var };
d938 4
a941 7
   if (MATCH(expr, var_pat)) {
      ir_variable *var = state->symbols->get_variable(s_var->value());
      if (var == NULL) {
	 ir_read_error(expr, "undeclared variable: %s", s_var->value());
	 return NULL;
      }
      return new(mem_ctx) ir_dereference_variable(var);
d943 2
a944 1
   return NULL;
d947 2
a948 2
ir_dereference *
ir_reader::read_dereference(s_expression *expr)
d950 5
a954 16
   s_expression *s_subject;
   s_expression *s_index;
   s_symbol *s_field;

   s_pattern array_pat[] = { "array_ref", s_subject, s_index };
   s_pattern record_pat[] = { "record_ref", s_subject, s_field };

   ir_dereference_variable *var_ref = read_var_ref(expr);
   if (var_ref != NULL) {
      return var_ref;
   } else if (MATCH(expr, array_pat)) {
      ir_rvalue *subject = read_rvalue(s_subject);
      if (subject == NULL) {
	 ir_read_error(NULL, "when reading the subject of an array_ref");
	 return NULL;
      }
d956 5
a960 13
      ir_rvalue *idx = read_rvalue(s_index);
      if (idx == NULL) {
	 ir_read_error(NULL, "when reading the index of an array_ref");
	 return NULL;
      }
      return new(mem_ctx) ir_dereference_array(subject, idx);
   } else if (MATCH(expr, record_pat)) {
      ir_rvalue *subject = read_rvalue(s_subject);
      if (subject == NULL) {
	 ir_read_error(NULL, "when reading the subject of a record_ref");
	 return NULL;
      }
      return new(mem_ctx) ir_dereference_record(subject, s_field->value());
d962 4
a965 1
   return NULL;
d968 2
a969 2
ir_texture *
ir_reader::read_texture(s_expression *expr)
d971 3
a973 41
   s_symbol *tag = NULL;
   s_expression *s_type = NULL;
   s_expression *s_sampler = NULL;
   s_expression *s_coord = NULL;
   s_expression *s_offset = NULL;
   s_expression *s_proj = NULL;
   s_list *s_shadow = NULL;
   s_expression *s_lod = NULL;
   s_expression *s_sample_index = NULL;

   ir_texture_opcode op = ir_tex; /* silence warning */

   s_pattern tex_pattern[] =
      { "tex", s_type, s_sampler, s_coord, s_offset, s_proj, s_shadow };
   s_pattern lod_pattern[] =
      { "lod", s_type, s_sampler, s_coord };
   s_pattern txf_pattern[] =
      { "txf", s_type, s_sampler, s_coord, s_offset, s_lod };
   s_pattern txf_ms_pattern[] =
      { "txf_ms", s_type, s_sampler, s_coord, s_sample_index };
   s_pattern txs_pattern[] =
      { "txs", s_type, s_sampler, s_lod };
   s_pattern other_pattern[] =
      { tag, s_type, s_sampler, s_coord, s_offset, s_proj, s_shadow, s_lod };

   if (MATCH(expr, lod_pattern)) {
      op = ir_lod;
   } else if (MATCH(expr, tex_pattern)) {
      op = ir_tex;
   } else if (MATCH(expr, txf_pattern)) {
      op = ir_txf;
   } else if (MATCH(expr, txf_ms_pattern)) {
      op = ir_txf_ms;
   } else if (MATCH(expr, txs_pattern)) {
      op = ir_txs;
   } else if (MATCH(expr, other_pattern)) {
      op = ir_texture::get_opcode(tag->value());
      if (op == -1)
	 return NULL;
   } else {
      ir_read_error(NULL, "unexpected texture pattern %s", tag->value());
d977 6
a982 1
   ir_texture *tex = new(mem_ctx) ir_texture(op);
d984 3
a986 5
   // Read return type
   const glsl_type *type = read_type(s_type);
   if (type == NULL) {
      ir_read_error(NULL, "when reading type in (%s ...)",
		    tex->opcode_string());
d989 32
d1023 2
a1024 1
   ir_dereference *sampler = read_dereference(s_sampler);
d1026 1
a1026 2
      ir_read_error(NULL, "when reading sampler in (%s ...)",
		    tex->opcode_string());
d1029 1
a1029 1
   tex->set_sampler(sampler, type);
d1031 8
a1038 8
   if (op != ir_txs) {
      // Read coordinate (any rvalue)
      tex->coordinate = read_rvalue(s_coord);
      if (tex->coordinate == NULL) {
	 ir_read_error(NULL, "when reading coordinate in (%s ...)",
		       tex->opcode_string());
	 return NULL;
      }
d1040 12
a1051 11
      if (op != ir_txf_ms && op != ir_lod) {
         // Read texel offset - either 0 or an rvalue.
         s_int *si_offset = SX_AS_INT(s_offset);
         if (si_offset == NULL || si_offset->value() != 0) {
            tex->offset = read_rvalue(s_offset);
            if (tex->offset == NULL) {
               ir_read_error(s_offset, "expected 0 or an expression");
               return NULL;
            }
         }
      }
d1053 3
d1057 10
a1066 2
   if (op != ir_txf && op != ir_txf_ms && op != ir_txs && op != ir_lod) {
      s_int *proj_as_int = SX_AS_INT(s_proj);
d1070 1
a1070 1
	 tex->projector = read_rvalue(s_proj);
d1072 2
a1073 2
	    ir_read_error(NULL, "when reading projective divide in (%s ..)",
	                  tex->opcode_string());
d1078 7
a1084 2
      if (s_shadow->subexpressions.is_empty()) {
	 tex->shadow_comparitor = NULL;
d1086 1
a1086 1
	 tex->shadow_comparitor = read_rvalue(s_shadow);
d1088 2
a1089 2
	    ir_read_error(NULL, "when reading shadow comparitor in (%s ..)",
			  tex->opcode_string());
d1093 25
a1117 1
   }
d1119 11
a1129 41
   switch (op) {
   case ir_txb:
      tex->lod_info.bias = read_rvalue(s_lod);
      if (tex->lod_info.bias == NULL) {
	 ir_read_error(NULL, "when reading LOD bias in (txb ...)");
	 return NULL;
      }
      break;
   case ir_txl:
   case ir_txf:
   case ir_txs:
      tex->lod_info.lod = read_rvalue(s_lod);
      if (tex->lod_info.lod == NULL) {
	 ir_read_error(NULL, "when reading LOD in (%s ...)",
		       tex->opcode_string());
	 return NULL;
      }
      break;
   case ir_txf_ms:
      tex->lod_info.sample_index = read_rvalue(s_sample_index);
      if (tex->lod_info.sample_index == NULL) {
         ir_read_error(NULL, "when reading sample_index in (txf_ms ...)");
         return NULL;
      }
      break;
   case ir_txd: {
      s_expression *s_dx, *s_dy;
      s_pattern dxdy_pat[] = { s_dx, s_dy };
      if (!MATCH(s_lod, dxdy_pat)) {
	 ir_read_error(s_lod, "expected (dPdx dPdy) in (txd ...)");
	 return NULL;
      }
      tex->lod_info.grad.dPdx = read_rvalue(s_dx);
      if (tex->lod_info.grad.dPdx == NULL) {
	 ir_read_error(NULL, "when reading dPdx in (txd ...)");
	 return NULL;
      }
      tex->lod_info.grad.dPdy = read_rvalue(s_dy);
      if (tex->lod_info.grad.dPdy == NULL) {
	 ir_read_error(NULL, "when reading dPdy in (txd ...)");
	 return NULL;
d1131 4
a1134 1
      break;
a1135 4
   default:
      // tex and lod don't have any extra parameters.
      break;
   };
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a30 2
namespace {

a61 2
   ir_emit_vertex *read_emit_vertex(s_expression *);
   ir_end_primitive *read_end_primitive(s_expression *);
a66 2
} /* anonymous namespace */

d167 2
a168 2
   foreach_list(n, &list->subexpressions) {
      s_list *sub = SX_AS_LIST(n);
d202 5
a206 6
   /* Skip over "function" tag and function name (which are guaranteed to be
    * present by the above PARTIAL_MATCH call).
    */
   exec_node *node = ((s_list *) expr)->subexpressions.head->next->next;
   for (/* nothing */; !node->is_tail_sentinel(); node = node->next) {
      s_expression *s_sig = (s_expression *) node;
a211 6
static bool
always_available(const _mesa_glsl_parse_state *)
{
   return true;
}

d240 3
a242 4
   /* Skip over the "parameters" tag. */
   exec_node *node = paramlist->subexpressions.head->next;
   for (/* nothing */; !node->is_tail_sentinel(); node = node->next) {
      ir_variable *var = read_declaration((s_expression *) node);
d249 1
a249 2
   ir_function_signature *sig =
      f->exact_matching_signature(state, &hir_parameters);
d252 2
a253 5
      /* ir_reader doesn't know what languages support a given built-in, so
       * just say that they're always available.  For now, other mechanisms
       * guarantee the right built-ins are available.
       */
      sig = new(mem_ctx) ir_function_signature(return_type, always_available);
d302 2
a303 2
   foreach_list(n, &list->subexpressions) {
      s_expression *sub = (s_expression *) n;
a357 4
   } else if (strcmp(tag->value(), "emit-vertex") == 0) {
      inst = read_emit_vertex(list);
   } else if (strcmp(tag->value(), "end-primitive") == 0) {
      inst = read_end_primitive(list);
d386 2
a387 2
   foreach_list(n, &s_quals->subexpressions) {
      s_symbol *qualifier = SX_AS_SYMBOL(n);
d395 1
a395 3
	 var->data.centroid = 1;
      } else if (strcmp(qualifier->value(), "sample") == 0) {
         var->data.sample = 1;
d397 1
a397 1
	 var->data.invariant = 1;
d399 1
a399 1
	 var->data.mode = ir_var_uniform;
d401 1
a401 1
	 var->data.mode = ir_var_auto;
d403 1
a403 1
	 var->data.mode = ir_var_function_in;
d405 1
a405 1
         var->data.mode = ir_var_shader_in;
d407 1
a407 1
	 var->data.mode = ir_var_const_in;
d409 1
a409 1
	 var->data.mode = ir_var_function_out;
d411 1
a411 1
	 var->data.mode = ir_var_shader_out;
d413 1
a413 1
	 var->data.mode = ir_var_function_inout;
d415 1
a415 1
	 var->data.mode = ir_var_temporary;
d417 1
a417 1
	 var->data.interpolation = INTERP_QUALIFIER_SMOOTH;
d419 1
a419 1
	 var->data.interpolation = INTERP_QUALIFIER_FLAT;
d421 1
a421 1
	 var->data.interpolation = INTERP_QUALIFIER_NOPERSPECTIVE;
d469 1
a469 1
   s_expression *s_body;
d471 4
a474 3
   s_pattern loop_pat[] = { "loop", s_body };
   if (!MATCH(expr, loop_pat)) {
      ir_read_error(expr, "expected (loop <body>)");
d478 2
a480 1

d639 2
a640 2
   foreach_list(n, &params->subexpressions) {
      s_expression *expr = (s_expression *) n;
d656 1
a656 1
   ir_function_signature *callee = f->matching_signature(state, &parameters);
d779 2
a780 2
      foreach_list(n, &values->subexpressions) {
	 s_expression *elt = (s_expression *) n;
d800 1
a800 1
   foreach_list(n, &values->subexpressions) {
d806 1
a806 1
      s_expression *expr = (s_expression *) n;
a916 1
   s_expression *s_component = NULL;
a929 4
   s_pattern tg4_pattern[] =
      { "tg4", s_type, s_sampler, s_coord, s_offset, s_component };
   s_pattern query_levels_pattern[] =
      { "query_levels", s_type, s_sampler };
a942 4
   } else if (MATCH(expr, tg4_pattern)) {
      op = ir_tg4;
   } else if (MATCH(expr, query_levels_pattern)) {
      op = ir_query_levels;
d993 1
a993 3
   if (op != ir_txf && op != ir_txf_ms &&
       op != ir_txs && op != ir_lod && op != ir_tg4 &&
       op != ir_query_levels) {
a1061 7
   case ir_tg4:
      tex->lod_info.component = read_rvalue(s_component);
      if (tex->lod_info.component == NULL) {
         ir_read_error(NULL, "when reading component in (tg4 ...)");
         return NULL;
      }
      break;
a1066 24
}

ir_emit_vertex *
ir_reader::read_emit_vertex(s_expression *expr)
{
   s_pattern pat[] = { "emit-vertex" };

   if (MATCH(expr, pat)) {
      return new(mem_ctx) ir_emit_vertex();
   }
   ir_read_error(NULL, "when reading emit-vertex");
   return NULL;
}

ir_end_primitive *
ir_reader::read_end_primitive(s_expression *expr)
{
   s_pattern pat[] = { "end-primitive" };

   if (MATCH(expr, pat)) {
      return new(mem_ctx) ir_end_primitive();
   }
   ir_read_error(NULL, "when reading end-primitive");
   return NULL;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d173 3
a175 2
   foreach_in_list(s_list, sub, &list->subexpressions) {
      if (!sub->is_list())
d320 2
a321 1
   foreach_in_list(s_expression, sub, &list->subexpressions) {
d408 3
a410 2
   foreach_in_list(s_symbol, qualifier, &s_quals->subexpressions) {
      if (!qualifier->is_symbol()) {
a439 6
      } else if (strcmp(qualifier->value(), "stream1") == 0) {
	 var->data.stream = 1;
      } else if (strcmp(qualifier->value(), "stream2") == 0) {
	 var->data.stream = 2;
      } else if (strcmp(qualifier->value(), "stream3") == 0) {
	 var->data.stream = 3;
d661 3
a663 2
   foreach_in_list(s_expression, e, &params->subexpressions) {
      ir_rvalue *param = read_rvalue(e);
d665 1
a665 1
	 ir_read_error(e, "when reading parameter to function call");
d678 1
a678 2
   ir_function_signature *callee =
      f->matching_signature(state, &parameters, true);
d724 4
a727 3

   /* Skip "expression" <type> <operation> by subtracting 3. */
   int num_operands = (int) ((s_list *) expr)->subexpressions.length() - 3;
d801 2
a802 1
      foreach_in_list(s_expression, elt, &values->subexpressions) {
d822 1
a822 1
   foreach_in_list(s_expression, expr, &values->subexpressions) {
d828 2
d1112 1
a1112 3
   s_expression *s_stream = NULL;

   s_pattern pat[] = { "emit-vertex", s_stream };
d1115 1
a1115 6
      ir_rvalue *stream = read_dereference(s_stream);
      if (stream == NULL) {
         ir_read_error(NULL, "when reading stream info in emit-vertex");
         return NULL;
      }
      return new(mem_ctx) ir_emit_vertex(stream);
d1124 1
a1124 3
   s_expression *s_stream = NULL;

   s_pattern pat[] = { "end-primitive", s_stream };
d1127 1
a1127 6
      ir_rvalue *stream = read_dereference(s_stream);
      if (stream == NULL) {
         ir_read_error(NULL, "when reading stream info in end-primitive");
         return NULL;
      }
      return new(mem_ctx) ir_end_primitive(stream);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d173 2
a174 3
   foreach_list(n, &list->subexpressions) {
      s_list *sub = SX_AS_LIST(n);
      if (sub == NULL)
d319 1
a319 2
   foreach_list(n, &list->subexpressions) {
      s_expression *sub = (s_expression *) n;
d406 2
a407 3
   foreach_list(n, &s_quals->subexpressions) {
      s_symbol *qualifier = SX_AS_SYMBOL(n);
      if (qualifier == NULL) {
d437 6
d664 2
a665 3
   foreach_list(n, &params->subexpressions) {
      s_expression *expr = (s_expression *) n;
      ir_rvalue *param = read_rvalue(expr);
d667 1
a667 1
	 ir_read_error(expr, "when reading parameter to function call");
d680 2
a681 1
   ir_function_signature *callee = f->matching_signature(state, &parameters);
d727 3
a729 4
    
   int num_operands = -3; /* skip "expression" <type> <operation> */
   foreach_list(n, &((s_list *) expr)->subexpressions)
      ++num_operands;
d803 1
a803 2
      foreach_list(n, &values->subexpressions) {
	 s_expression *elt = (s_expression *) n;
d823 1
a823 1
   foreach_list(n, &values->subexpressions) {
a828 2
      s_expression *expr = (s_expression *) n;

d1111 3
a1113 1
   s_pattern pat[] = { "emit-vertex" };
d1116 6
a1121 1
      return new(mem_ctx) ir_emit_vertex();
d1130 3
a1132 1
   s_pattern pat[] = { "end-primitive" };
d1135 6
a1140 1
      return new(mem_ctx) ir_end_primitive();
@


