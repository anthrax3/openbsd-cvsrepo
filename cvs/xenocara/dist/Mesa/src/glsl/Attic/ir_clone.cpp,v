head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.26;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.15;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.29;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.21;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.27;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <string.h>
#include "main/compiler.h"
#include "ir.h"
#include "glsl_types.h"
#include "program/hash_table.h"

ir_rvalue *
ir_rvalue::clone(void *mem_ctx, struct hash_table *) const
{
   /* The only possible instantiation is the generic error value. */
   return error_value(mem_ctx);
}

/**
 * Duplicate an IR variable
 */
ir_variable *
ir_variable::clone(void *mem_ctx, struct hash_table *ht) const
{
   ir_variable *var = new(mem_ctx) ir_variable(this->type, this->name,
					       (ir_variable_mode) this->data.mode);

   var->data.max_array_access = this->data.max_array_access;
   if (this->is_interface_instance()) {
      var->max_ifc_array_access =
         rzalloc_array(var, unsigned, this->interface_type->length);
      memcpy(var->max_ifc_array_access, this->max_ifc_array_access,
             this->interface_type->length * sizeof(unsigned));
   }

   memcpy(&var->data, &this->data, sizeof(var->data));

   var->warn_extension = this->warn_extension;

   var->num_state_slots = this->num_state_slots;
   if (this->state_slots) {
      /* FINISHME: This really wants to use something like talloc_reference, but
       * FINISHME: ralloc doesn't have any similar function.
       */
      var->state_slots = ralloc_array(var, ir_state_slot,
				      this->num_state_slots);
      memcpy(var->state_slots, this->state_slots,
	     sizeof(this->state_slots[0]) * var->num_state_slots);
   }

   if (this->constant_value)
      var->constant_value = this->constant_value->clone(mem_ctx, ht);

   if (this->constant_initializer)
      var->constant_initializer =
	 this->constant_initializer->clone(mem_ctx, ht);

   var->interface_type = this->interface_type;

   if (ht) {
      hash_table_insert(ht, var, (void *)const_cast<ir_variable *>(this));
   }

   return var;
}

ir_swizzle *
ir_swizzle::clone(void *mem_ctx, struct hash_table *ht) const
{
   return new(mem_ctx) ir_swizzle(this->val->clone(mem_ctx, ht), this->mask);
}

ir_return *
ir_return::clone(void *mem_ctx, struct hash_table *ht) const
{
   ir_rvalue *new_value = NULL;

   if (this->value)
      new_value = this->value->clone(mem_ctx, ht);

   return new(mem_ctx) ir_return(new_value);
}

ir_discard *
ir_discard::clone(void *mem_ctx, struct hash_table *ht) const
{
   ir_rvalue *new_condition = NULL;

   if (this->condition != NULL)
      new_condition = this->condition->clone(mem_ctx, ht);

   return new(mem_ctx) ir_discard(new_condition);
}

ir_loop_jump *
ir_loop_jump::clone(void *mem_ctx, struct hash_table *ht) const
{
   (void)ht;

   return new(mem_ctx) ir_loop_jump(this->mode);
}

ir_if *
ir_if::clone(void *mem_ctx, struct hash_table *ht) const
{
   ir_if *new_if = new(mem_ctx) ir_if(this->condition->clone(mem_ctx, ht));

   foreach_list(n, &this->then_instructions) {
      ir_instruction *ir = (ir_instruction *) n;
      new_if->then_instructions.push_tail(ir->clone(mem_ctx, ht));
   }

   foreach_list(n, &this->else_instructions) {
      ir_instruction *ir = (ir_instruction *) n;
      new_if->else_instructions.push_tail(ir->clone(mem_ctx, ht));
   }

   return new_if;
}

ir_loop *
ir_loop::clone(void *mem_ctx, struct hash_table *ht) const
{
   ir_loop *new_loop = new(mem_ctx) ir_loop();

   foreach_list(n, &this->body_instructions) {
      ir_instruction *ir = (ir_instruction *) n;
      new_loop->body_instructions.push_tail(ir->clone(mem_ctx, ht));
   }

   return new_loop;
}

ir_call *
ir_call::clone(void *mem_ctx, struct hash_table *ht) const
{
   ir_dereference_variable *new_return_ref = NULL;
   if (this->return_deref != NULL)
      new_return_ref = this->return_deref->clone(mem_ctx, ht);

   exec_list new_parameters;

   foreach_list(n, &this->actual_parameters) {
      ir_instruction *ir = (ir_instruction *) n;
      new_parameters.push_tail(ir->clone(mem_ctx, ht));
   }

   return new(mem_ctx) ir_call(this->callee, new_return_ref, &new_parameters);
}

ir_expression *
ir_expression::clone(void *mem_ctx, struct hash_table *ht) const
{
   ir_rvalue *op[Elements(this->operands)] = { NULL, };
   unsigned int i;

   for (i = 0; i < get_num_operands(); i++) {
      op[i] = this->operands[i]->clone(mem_ctx, ht);
   }

   return new(mem_ctx) ir_expression(this->operation, this->type,
				     op[0], op[1], op[2], op[3]);
}

ir_dereference_variable *
ir_dereference_variable::clone(void *mem_ctx, struct hash_table *ht) const
{
   ir_variable *new_var;

   if (ht) {
      new_var = (ir_variable *)hash_table_find(ht, this->var);
      if (!new_var)
	 new_var = this->var;
   } else {
      new_var = this->var;
   }

   return new(mem_ctx) ir_dereference_variable(new_var);
}

ir_dereference_array *
ir_dereference_array::clone(void *mem_ctx, struct hash_table *ht) const
{
   return new(mem_ctx) ir_dereference_array(this->array->clone(mem_ctx, ht),
					    this->array_index->clone(mem_ctx,
								     ht));
}

ir_dereference_record *
ir_dereference_record::clone(void *mem_ctx, struct hash_table *ht) const
{
   return new(mem_ctx) ir_dereference_record(this->record->clone(mem_ctx, ht),
					     this->field);
}

ir_texture *
ir_texture::clone(void *mem_ctx, struct hash_table *ht) const
{
   ir_texture *new_tex = new(mem_ctx) ir_texture(this->op);
   new_tex->type = this->type;

   new_tex->sampler = this->sampler->clone(mem_ctx, ht);
   if (this->coordinate)
      new_tex->coordinate = this->coordinate->clone(mem_ctx, ht);
   if (this->projector)
      new_tex->projector = this->projector->clone(mem_ctx, ht);
   if (this->shadow_comparitor) {
      new_tex->shadow_comparitor = this->shadow_comparitor->clone(mem_ctx, ht);
   }

   if (this->offset != NULL)
      new_tex->offset = this->offset->clone(mem_ctx, ht);

   switch (this->op) {
   case ir_tex:
   case ir_lod:
   case ir_query_levels:
      break;
   case ir_txb:
      new_tex->lod_info.bias = this->lod_info.bias->clone(mem_ctx, ht);
      break;
   case ir_txl:
   case ir_txf:
   case ir_txs:
      new_tex->lod_info.lod = this->lod_info.lod->clone(mem_ctx, ht);
      break;
   case ir_txf_ms:
      new_tex->lod_info.sample_index = this->lod_info.sample_index->clone(mem_ctx, ht);
      break;
   case ir_txd:
      new_tex->lod_info.grad.dPdx = this->lod_info.grad.dPdx->clone(mem_ctx, ht);
      new_tex->lod_info.grad.dPdy = this->lod_info.grad.dPdy->clone(mem_ctx, ht);
      break;
   case ir_tg4:
      new_tex->lod_info.component = this->lod_info.component->clone(mem_ctx, ht);
      break;
   }

   return new_tex;
}

ir_assignment *
ir_assignment::clone(void *mem_ctx, struct hash_table *ht) const
{
   ir_rvalue *new_condition = NULL;

   if (this->condition)
      new_condition = this->condition->clone(mem_ctx, ht);

   ir_assignment *cloned =
      new(mem_ctx) ir_assignment(this->lhs->clone(mem_ctx, ht),
                                 this->rhs->clone(mem_ctx, ht),
                                 new_condition);
   cloned->write_mask = this->write_mask;
   return cloned;
}

ir_function *
ir_function::clone(void *mem_ctx, struct hash_table *ht) const
{
   ir_function *copy = new(mem_ctx) ir_function(this->name);

   foreach_list_const(node, &this->signatures) {
      const ir_function_signature *const sig =
	 (const ir_function_signature *const) node;

      ir_function_signature *sig_copy = sig->clone(mem_ctx, ht);
      copy->add_signature(sig_copy);

      if (ht != NULL)
	 hash_table_insert(ht, sig_copy,
			   (void *)const_cast<ir_function_signature *>(sig));
   }

   return copy;
}

ir_function_signature *
ir_function_signature::clone(void *mem_ctx, struct hash_table *ht) const
{
   ir_function_signature *copy = this->clone_prototype(mem_ctx, ht);

   copy->is_defined = this->is_defined;

   /* Clone the instruction list.
    */
   foreach_list_const(node, &this->body) {
      const ir_instruction *const inst = (const ir_instruction *) node;

      ir_instruction *const inst_copy = inst->clone(mem_ctx, ht);
      copy->body.push_tail(inst_copy);
   }

   return copy;
}

ir_function_signature *
ir_function_signature::clone_prototype(void *mem_ctx, struct hash_table *ht) const
{
   ir_function_signature *copy =
      new(mem_ctx) ir_function_signature(this->return_type);

   copy->is_defined = false;
   copy->builtin_avail = this->builtin_avail;
   copy->origin = this;

   /* Clone the parameter list, but NOT the body.
    */
   foreach_list_const(node, &this->parameters) {
      const ir_variable *const param = (const ir_variable *) node;

      assert(const_cast<ir_variable *>(param)->as_variable() != NULL);

      ir_variable *const param_copy = param->clone(mem_ctx, ht);
      copy->parameters.push_tail(param_copy);
   }

   return copy;
}

ir_constant *
ir_constant::clone(void *mem_ctx, struct hash_table *ht) const
{
   (void)ht;

   switch (this->type->base_type) {
   case GLSL_TYPE_UINT:
   case GLSL_TYPE_INT:
   case GLSL_TYPE_FLOAT:
   case GLSL_TYPE_BOOL:
      return new(mem_ctx) ir_constant(this->type, &this->value);

   case GLSL_TYPE_STRUCT: {
      ir_constant *c = new(mem_ctx) ir_constant;

      c->type = this->type;
      for (exec_node *node = this->components.head
	      ; !node->is_tail_sentinel()
	      ; node = node->next) {
	 ir_constant *const orig = (ir_constant *) node;

	 c->components.push_tail(orig->clone(mem_ctx, NULL));
      }

      return c;
   }

   case GLSL_TYPE_ARRAY: {
      ir_constant *c = new(mem_ctx) ir_constant;

      c->type = this->type;
      c->array_elements = ralloc_array(c, ir_constant *, this->type->length);
      for (unsigned i = 0; i < this->type->length; i++) {
	 c->array_elements[i] = this->array_elements[i]->clone(mem_ctx, NULL);
      }
      return c;
   }

   case GLSL_TYPE_SAMPLER:
   case GLSL_TYPE_IMAGE:
   case GLSL_TYPE_ATOMIC_UINT:
   case GLSL_TYPE_VOID:
   case GLSL_TYPE_ERROR:
   case GLSL_TYPE_INTERFACE:
      assert(!"Should not get here.");
      break;
   }

   return NULL;
}


class fixup_ir_call_visitor : public ir_hierarchical_visitor {
public:
   fixup_ir_call_visitor(struct hash_table *ht)
   {
      this->ht = ht;
   }

   virtual ir_visitor_status visit_enter(ir_call *ir)
   {
      /* Try to find the function signature referenced by the ir_call in the
       * table.  If it is found, replace it with the value from the table.
       */
      ir_function_signature *sig =
	 (ir_function_signature *) hash_table_find(this->ht, ir->callee);
      if (sig != NULL)
	 ir->callee = sig;

      /* Since this may be used before function call parameters are flattened,
       * the children also need to be processed.
       */
      return visit_continue;
   }

private:
   struct hash_table *ht;
};


static void
fixup_function_calls(struct hash_table *ht, exec_list *instructions)
{
   fixup_ir_call_visitor v(ht);
   v.run(instructions);
}


void
clone_ir_list(void *mem_ctx, exec_list *out, const exec_list *in)
{
   struct hash_table *ht =
      hash_table_ctor(0, hash_table_pointer_hash, hash_table_pointer_compare);

   foreach_list_const(node, in) {
      const ir_instruction *const original = (ir_instruction *) node;
      ir_instruction *copy = original->clone(mem_ctx, ht);

      out->push_tail(copy);
   }

   /* Make a pass over the cloned tree to fix up ir_call nodes to point to the
    * cloned ir_function_signature nodes.  This cannot be done automatically
    * during cloning because the ir_call might be a forward reference (i.e.,
    * the function signature that it references may not have been cloned yet).
    */
   fixup_function_calls(ht, out);

   hash_table_dtor(ht);
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d48 1
a48 1
      var->u.max_ifc_array_access =
d50 1
a50 1
      memcpy(var->u.max_ifc_array_access, this->u.max_ifc_array_access,
d56 11
a66 4
   if (this->get_state_slots()) {
      ir_state_slot *s = var->allocate_state_slots(this->get_num_state_slots());
      memcpy(s, this->get_state_slots(),
             sizeof(s[0]) * var->get_num_state_slots());
d126 2
a127 1
   foreach_in_list(ir_instruction, ir, &this->then_instructions) {
d131 2
a132 1
   foreach_in_list(ir_instruction, ir, &this->else_instructions) {
d144 2
a145 1
   foreach_in_list(ir_instruction, ir, &this->body_instructions) {
d161 2
a162 1
   foreach_in_list(ir_instruction, ir, &this->actual_parameters) {
d281 4
a284 1
   foreach_in_list(const ir_function_signature, sig, &this->signatures) {
d305 3
a307 1
   foreach_in_list(const ir_instruction, inst, &this->body) {
d327 3
a329 1
   foreach_in_list(const ir_variable, param, &this->parameters) {
d433 2
a434 1
   foreach_in_list(const ir_instruction, original, in) {
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d48 1
a48 1
      var->max_ifc_array_access =
d50 1
a50 1
      memcpy(var->max_ifc_array_access, this->max_ifc_array_access,
d56 4
a59 11
   var->warn_extension = this->warn_extension;

   var->num_state_slots = this->num_state_slots;
   if (this->state_slots) {
      /* FINISHME: This really wants to use something like talloc_reference, but
       * FINISHME: ralloc doesn't have any similar function.
       */
      var->state_slots = ralloc_array(var, ir_state_slot,
				      this->num_state_slots);
      memcpy(var->state_slots, this->state_slots,
	     sizeof(this->state_slots[0]) * var->num_state_slots);
d119 1
a119 2
   foreach_list(n, &this->then_instructions) {
      ir_instruction *ir = (ir_instruction *) n;
d123 1
a123 2
   foreach_list(n, &this->else_instructions) {
      ir_instruction *ir = (ir_instruction *) n;
d135 1
a135 2
   foreach_list(n, &this->body_instructions) {
      ir_instruction *ir = (ir_instruction *) n;
d151 1
a151 2
   foreach_list(n, &this->actual_parameters) {
      ir_instruction *ir = (ir_instruction *) n;
d270 1
a270 4
   foreach_list_const(node, &this->signatures) {
      const ir_function_signature *const sig =
	 (const ir_function_signature *const) node;

d291 1
a291 3
   foreach_list_const(node, &this->body) {
      const ir_instruction *const inst = (const ir_instruction *) node;

d311 1
a311 3
   foreach_list_const(node, &this->parameters) {
      const ir_variable *const param = (const ir_variable *) node;

d415 1
a415 2
   foreach_list_const(node, in) {
      const ir_instruction *const original = (ir_instruction *) node;
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d31 1
a31 1
ir_rvalue::clone(void *mem_ctx, struct hash_table *ht) const
d44 11
a54 1
					       (ir_variable_mode) this->mode);
a55 8
   var->max_array_access = this->max_array_access;
   var->read_only = this->read_only;
   var->centroid = this->centroid;
   var->invariant = this->invariant;
   var->interpolation = this->interpolation;
   var->location = this->location;
   var->index = this->index;
   var->binding = this->binding;
a56 7
   var->origin_upper_left = this->origin_upper_left;
   var->pixel_center_integer = this->pixel_center_integer;
   var->explicit_location = this->explicit_location;
   var->explicit_index = this->explicit_index;
   var->explicit_binding = this->explicit_binding;
   var->has_initializer = this->has_initializer;
   var->depth_layout = this->depth_layout;
d126 2
a127 2
   foreach_iter(exec_list_iterator, iter, this->then_instructions) {
      ir_instruction *ir = (ir_instruction *)iter.get();
d131 2
a132 2
   foreach_iter(exec_list_iterator, iter, this->else_instructions) {
      ir_instruction *ir = (ir_instruction *)iter.get();
d144 2
a145 10
   if (this->from)
      new_loop->from = this->from->clone(mem_ctx, ht);
   if (this->to)
      new_loop->to = this->to->clone(mem_ctx, ht);
   if (this->increment)
      new_loop->increment = this->increment->clone(mem_ctx, ht);
   new_loop->counter = counter;

   foreach_iter(exec_list_iterator, iter, this->body_instructions) {
      ir_instruction *ir = (ir_instruction *)iter.get();
a148 1
   new_loop->cmp = this->cmp;
d161 2
a162 2
   foreach_iter(exec_list_iterator, iter, this->actual_parameters) {
      ir_instruction *ir = (ir_instruction *)iter.get();
d235 1
d252 3
d268 6
a273 4
   return new(mem_ctx) ir_assignment(this->lhs->clone(mem_ctx, ht),
				     this->rhs->clone(mem_ctx, ht),
				     new_condition,
				     this->write_mask);
d322 1
a322 1
   copy->is_builtin = this->is_builtin;
d378 2
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a27 1
extern "C" {
d29 6
a38 4
 *
 * \note
 * This will probably be made \c virtual and moved to the base class
 * eventually.
d52 2
d58 4
a73 3
   if (this->explicit_location)
      var->location = this->location;

d77 6
d169 3
a171 2
   if (this->type == glsl_type::error_type)
      return ir_call::get_error_instruction(mem_ctx);
d180 1
a180 1
   return new(mem_ctx) ir_call(this->callee, &new_parameters);
d235 2
a236 1
   new_tex->coordinate = this->coordinate->clone(mem_ctx, ht);
d248 1
d255 1
d258 3
d331 1
d385 4
a388 1
   default:
d390 1
a390 1
      return NULL;
d392 2
d410 1
a410 1
	 (ir_function_signature *) hash_table_find(this->ht, ir->get_callee());
d412 1
a412 1
	 ir->set_callee(sig);
@


1.1
log
@Initial revision
@
text
@a49 1
   var->array_lvalue = this->array_lvalue;
d55 12
d231 2
a232 2
   for (int i = 0; i < 3; i++)
      new_tex->offsets[i] = this->offsets[i];
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d28 1
a29 6

ir_rvalue *
ir_rvalue::clone(void *mem_ctx, struct hash_table *ht) const
{
   /* The only possible instantiation is the generic error value. */
   return error_value(mem_ctx);
d34 4
d50 1
a51 2
   var->index = this->index;
   var->binding = this->binding;
d56 2
a57 15
   var->explicit_index = this->explicit_index;
   var->explicit_binding = this->explicit_binding;
   var->has_initializer = this->has_initializer;
   var->depth_layout = this->depth_layout;

   var->num_state_slots = this->num_state_slots;
   if (this->state_slots) {
      /* FINISHME: This really wants to use something like talloc_reference, but
       * FINISHME: ralloc doesn't have any similar function.
       */
      var->state_slots = ralloc_array(var, ir_state_slot,
				      this->num_state_slots);
      memcpy(var->state_slots, this->state_slots,
	     sizeof(this->state_slots[0]) * var->num_state_slots);
   }
a61 6
   if (this->constant_initializer)
      var->constant_initializer =
	 this->constant_initializer->clone(mem_ctx, ht);

   var->interface_type = this->interface_type;

d148 2
a149 3
   ir_dereference_variable *new_return_ref = NULL;
   if (this->return_deref != NULL)
      new_return_ref = this->return_deref->clone(mem_ctx, ht);
d158 1
a158 1
   return new(mem_ctx) ir_call(this->callee, new_return_ref, &new_parameters);
d213 1
a213 2
   if (this->coordinate)
      new_tex->coordinate = this->coordinate->clone(mem_ctx, ht);
d220 2
a221 2
   if (this->offset != NULL)
      new_tex->offset = this->offset->clone(mem_ctx, ht);
a224 1
   case ir_lod:
a230 1
   case ir_txs:
a232 3
   case ir_txf_ms:
      new_tex->lod_info.sample_index = this->lod_info.sample_index->clone(mem_ctx, ht);
      break;
a302 1
   copy->origin = this;
d356 1
a356 4
   case GLSL_TYPE_SAMPLER:
   case GLSL_TYPE_VOID:
   case GLSL_TYPE_ERROR:
   case GLSL_TYPE_INTERFACE:
d358 1
a358 1
      break;
a359 2

   return NULL;
d376 1
a376 1
	 (ir_function_signature *) hash_table_find(this->ht, ir->callee);
d378 1
a378 1
	 ir->callee = sig;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d31 1
a31 1
ir_rvalue::clone(void *mem_ctx, struct hash_table *) const
d44 1
a44 11
					       (ir_variable_mode) this->data.mode);

   var->data.max_array_access = this->data.max_array_access;
   if (this->is_interface_instance()) {
      var->max_ifc_array_access =
         rzalloc_array(var, unsigned, this->interface_type->length);
      memcpy(var->max_ifc_array_access, this->max_ifc_array_access,
             this->interface_type->length * sizeof(unsigned));
   }

   memcpy(&var->data, &this->data, sizeof(var->data));
d46 8
d55 7
d131 2
a132 2
   foreach_list(n, &this->then_instructions) {
      ir_instruction *ir = (ir_instruction *) n;
d136 2
a137 2
   foreach_list(n, &this->else_instructions) {
      ir_instruction *ir = (ir_instruction *) n;
d149 10
a158 2
   foreach_list(n, &this->body_instructions) {
      ir_instruction *ir = (ir_instruction *) n;
d162 1
d175 2
a176 2
   foreach_list(n, &this->actual_parameters) {
      ir_instruction *ir = (ir_instruction *) n;
a248 1
   case ir_query_levels:
a264 3
   case ir_tg4:
      new_tex->lod_info.component = this->lod_info.component->clone(mem_ctx, ht);
      break;
d278 4
a281 6
   ir_assignment *cloned =
      new(mem_ctx) ir_assignment(this->lhs->clone(mem_ctx, ht),
                                 this->rhs->clone(mem_ctx, ht),
                                 new_condition);
   cloned->write_mask = this->write_mask;
   return cloned;
d330 1
a330 1
   copy->builtin_avail = this->builtin_avail;
a385 2
   case GLSL_TYPE_IMAGE:
   case GLSL_TYPE_ATOMIC_UINT:
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d48 1
a48 1
      var->u.max_ifc_array_access =
d50 1
a50 1
      memcpy(var->u.max_ifc_array_access, this->u.max_ifc_array_access,
d56 11
a66 4
   if (this->get_state_slots()) {
      ir_state_slot *s = var->allocate_state_slots(this->get_num_state_slots());
      memcpy(s, this->get_state_slots(),
             sizeof(s[0]) * var->get_num_state_slots());
d126 2
a127 1
   foreach_in_list(ir_instruction, ir, &this->then_instructions) {
d131 2
a132 1
   foreach_in_list(ir_instruction, ir, &this->else_instructions) {
d144 2
a145 1
   foreach_in_list(ir_instruction, ir, &this->body_instructions) {
d161 2
a162 1
   foreach_in_list(ir_instruction, ir, &this->actual_parameters) {
d281 4
a284 1
   foreach_in_list(const ir_function_signature, sig, &this->signatures) {
d305 3
a307 1
   foreach_in_list(const ir_instruction, inst, &this->body) {
d327 3
a329 1
   foreach_in_list(const ir_variable, param, &this->parameters) {
d433 2
a434 1
   foreach_in_list(const ir_instruction, original, in) {
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d48 1
a48 1
      var->max_ifc_array_access =
d50 1
a50 1
      memcpy(var->max_ifc_array_access, this->max_ifc_array_access,
d56 4
a59 11
   var->warn_extension = this->warn_extension;

   var->num_state_slots = this->num_state_slots;
   if (this->state_slots) {
      /* FINISHME: This really wants to use something like talloc_reference, but
       * FINISHME: ralloc doesn't have any similar function.
       */
      var->state_slots = ralloc_array(var, ir_state_slot,
				      this->num_state_slots);
      memcpy(var->state_slots, this->state_slots,
	     sizeof(this->state_slots[0]) * var->num_state_slots);
d119 1
a119 2
   foreach_list(n, &this->then_instructions) {
      ir_instruction *ir = (ir_instruction *) n;
d123 1
a123 2
   foreach_list(n, &this->else_instructions) {
      ir_instruction *ir = (ir_instruction *) n;
d135 1
a135 2
   foreach_list(n, &this->body_instructions) {
      ir_instruction *ir = (ir_instruction *) n;
d151 1
a151 2
   foreach_list(n, &this->actual_parameters) {
      ir_instruction *ir = (ir_instruction *) n;
d270 1
a270 4
   foreach_list_const(node, &this->signatures) {
      const ir_function_signature *const sig =
	 (const ir_function_signature *const) node;

d291 1
a291 3
   foreach_list_const(node, &this->body) {
      const ir_instruction *const inst = (const ir_instruction *) node;

d311 1
a311 3
   foreach_list_const(node, &this->parameters) {
      const ir_variable *const param = (const ir_variable *) node;

d415 1
a415 2
   foreach_list_const(node, in) {
      const ir_instruction *const original = (ir_instruction *) node;
@


