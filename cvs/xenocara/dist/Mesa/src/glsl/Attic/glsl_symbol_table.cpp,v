head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.25;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.13;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.27;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.18;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.25;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/* -*- c++ -*- */
/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "glsl_symbol_table.h"

class symbol_table_entry {
public:
   DECLARE_RALLOC_CXX_OPERATORS(symbol_table_entry);

   bool add_interface(const glsl_type *i, enum ir_variable_mode mode)
   {
      const glsl_type **dest;

      switch (mode) {
      case ir_var_uniform:
         dest = &ibu;
         break;
      case ir_var_shader_in:
         dest = &ibi;
         break;
      case ir_var_shader_out:
         dest = &ibo;
         break;
      default:
         assert(!"Unsupported interface variable mode!");
         return false;
      }

      if (*dest != NULL) {
         return false;
      } else {
         *dest = i;
         return true;
      }
   }

   const glsl_type *get_interface(enum ir_variable_mode mode)
   {
      switch (mode) {
      case ir_var_uniform:
         return ibu;
      case ir_var_shader_in:
         return ibi;
      case ir_var_shader_out:
         return ibo;
      default:
         assert(!"Unsupported interface variable mode!");
         return NULL;
      }
   }

   symbol_table_entry(ir_variable *v)               :
      v(v), f(0), t(0), ibu(0), ibi(0), ibo(0), a(0) {}
   symbol_table_entry(ir_function *f)               :
      v(0), f(f), t(0), ibu(0), ibi(0), ibo(0), a(0) {}
   symbol_table_entry(const glsl_type *t)           :
      v(0), f(0), t(t), ibu(0), ibi(0), ibo(0), a(0) {}
   symbol_table_entry(const glsl_type *t, enum ir_variable_mode mode) :
      v(0), f(0), t(0), ibu(0), ibi(0), ibo(0), a(0)
   {
      assert(t->is_interface());
      add_interface(t, mode);
   }
   symbol_table_entry(const class ast_type_specifier *a):
      v(0), f(0), t(0), ibu(0), ibi(0), ibo(0), a(a) {}

   ir_variable *v;
   ir_function *f;
   const glsl_type *t;
   const glsl_type *ibu;
   const glsl_type *ibi;
   const glsl_type *ibo;
   const class ast_type_specifier *a;
};

glsl_symbol_table::glsl_symbol_table()
{
   this->separate_function_namespace = false;
   this->table = _mesa_symbol_table_ctor();
   this->mem_ctx = ralloc_context(NULL);
}

glsl_symbol_table::~glsl_symbol_table()
{
   _mesa_symbol_table_dtor(table);
   ralloc_free(mem_ctx);
}

void glsl_symbol_table::push_scope()
{
   _mesa_symbol_table_push_scope(table);
}

void glsl_symbol_table::pop_scope()
{
   _mesa_symbol_table_pop_scope(table);
}

bool glsl_symbol_table::name_declared_this_scope(const char *name)
{
   return _mesa_symbol_table_symbol_scope(table, -1, name) == 0;
}

bool glsl_symbol_table::add_variable(ir_variable *v)
{
   if (this->separate_function_namespace) {
      /* In 1.10, functions and variables have separate namespaces. */
      symbol_table_entry *existing = get_entry(v->name);
      if (name_declared_this_scope(v->name)) {
	 /* If there's already an existing function (not a constructor!) in
	  * the current scope, just update the existing entry to include 'v'.
	  */
	 if (existing->v == NULL && existing->t == NULL) {
	    existing->v = v;
	    return true;
	 }
      } else {
	 /* If not declared at this scope, add a new entry.  But if an existing
	  * entry includes a function, propagate that to this block - otherwise
	  * the new variable declaration would shadow the function.
	  */
	 symbol_table_entry *entry = new(mem_ctx) symbol_table_entry(v);
	 if (existing != NULL)
	    entry->f = existing->f;
	 int added = _mesa_symbol_table_add_symbol(table, -1, v->name, entry);
	 assert(added == 0);
	 (void)added;
	 return true;
      }
      return false;
   }

   /* 1.20+ rules: */
   symbol_table_entry *entry = new(mem_ctx) symbol_table_entry(v);
   return _mesa_symbol_table_add_symbol(table, -1, v->name, entry) == 0;
}

bool glsl_symbol_table::add_type(const char *name, const glsl_type *t)
{
   symbol_table_entry *entry = new(mem_ctx) symbol_table_entry(t);
   return _mesa_symbol_table_add_symbol(table, -1, name, entry) == 0;
}

bool glsl_symbol_table::add_interface(const char *name, const glsl_type *i,
                                      enum ir_variable_mode mode)
{
   assert(i->is_interface());
   symbol_table_entry *entry = get_entry(name);
   if (entry == NULL) {
      symbol_table_entry *entry =
         new(mem_ctx) symbol_table_entry(i, mode);
      bool add_interface_symbol_result =
         _mesa_symbol_table_add_symbol(table, -1, name, entry) == 0;
      assert(add_interface_symbol_result);
      return add_interface_symbol_result;
   } else {
      return entry->add_interface(i, mode);
   }
}

bool glsl_symbol_table::add_function(ir_function *f)
{
   if (this->separate_function_namespace && name_declared_this_scope(f->name)) {
      /* In 1.10, functions and variables have separate namespaces. */
      symbol_table_entry *existing = get_entry(f->name);
      if ((existing->f == NULL) && (existing->t == NULL)) {
	 existing->f = f;
	 return true;
      }
   }
   symbol_table_entry *entry = new(mem_ctx) symbol_table_entry(f);
   return _mesa_symbol_table_add_symbol(table, -1, f->name, entry) == 0;
}

void glsl_symbol_table::add_global_function(ir_function *f)
{
   symbol_table_entry *entry = new(mem_ctx) symbol_table_entry(f);
   int added = _mesa_symbol_table_add_global_symbol(table, -1, f->name, entry);
   assert(added == 0);
   (void)added;
}

ir_variable *glsl_symbol_table::get_variable(const char *name)
{
   symbol_table_entry *entry = get_entry(name);
   return entry != NULL ? entry->v : NULL;
}

const glsl_type *glsl_symbol_table::get_type(const char *name)
{
   symbol_table_entry *entry = get_entry(name);
   return entry != NULL ? entry->t : NULL;
}

const glsl_type *glsl_symbol_table::get_interface(const char *name,
                                                  enum ir_variable_mode mode)
{
   symbol_table_entry *entry = get_entry(name);
   return entry != NULL ? entry->get_interface(mode) : NULL;
}

ir_function *glsl_symbol_table::get_function(const char *name)
{
   symbol_table_entry *entry = get_entry(name);
   return entry != NULL ? entry->f : NULL;
}

symbol_table_entry *glsl_symbol_table::get_entry(const char *name)
{
   return (symbol_table_entry *)
      _mesa_symbol_table_find_symbol(table, -1, name);
}

void
glsl_symbol_table::disable_variable(const char *name)
{
   /* Ideally we would remove the variable's entry from the symbol table, but
    * that would be difficult.  Fortunately, since this is only used for
    * built-in variables, it won't be possible for the shader to re-introduce
    * the variable later, so all we really need to do is to make sure that
    * further attempts to access it using get_variable() will return NULL.
    */
   symbol_table_entry *entry = get_entry(name);
   if (entry != NULL) {
      entry->v = NULL;
   }
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a126 2
   assert(v->data.mode != ir_var_temporary);

@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d127 2
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d29 1
a29 14
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
   {
      void *entry = ralloc_size(ctx, size);
      assert(entry != NULL);
      return entry;
   }

   /* If the user *does* call delete, that's OK, we will just ralloc_free. */
   static void operator delete(void *entry)
   {
      ralloc_free(entry);
   }
a164 17
static char *make_ast_name(const char *name)
{
   char *ast_name = new char[strlen("#ast.") + strlen(name) + 1];
   strcpy(ast_name, "#ast.");
   strcat(ast_name + strlen("#ast."), name);
   return ast_name;
}

bool glsl_symbol_table::add_type_ast(const char *name, const class ast_type_specifier *a)
{
   symbol_table_entry *entry = new(mem_ctx) symbol_table_entry(a);
   char *ast_name = make_ast_name(name);
   bool ret = _mesa_symbol_table_add_symbol(table, -1, ast_name, entry) == 0;
   delete [] ast_name;
   return ret;
}

a215 8
const class ast_type_specifier *glsl_symbol_table::get_type_ast(const char *name)
{
   char *ast_name = make_ast_name(name);
   symbol_table_entry *entry = get_entry(ast_name);
   delete [] ast_name;
   return entry != NULL ? entry->a : NULL;
}

d233 15
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d44 56
a99 3
   symbol_table_entry(ir_variable *v)                     : v(v), f(0), t(0) {}
   symbol_table_entry(ir_function *f)                     : v(0), f(f), t(0) {}
   symbol_table_entry(const glsl_type *t)                 : v(0), f(0), t(t) {}
d104 4
d112 1
a112 1
   this->language_version = 120;
d140 1
a140 1
   if (this->language_version == 110) {
d178 34
d214 1
a214 1
   if (this->language_version == 110 && name_declared_this_scope(f->name)) {
d244 15
@


1.1
log
@Initial revision
@
text
@d140 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d44 3
a46 56
   bool add_interface(const glsl_type *i, enum ir_variable_mode mode)
   {
      const glsl_type **dest;

      switch (mode) {
      case ir_var_uniform:
         dest = &ibu;
         break;
      case ir_var_shader_in:
         dest = &ibi;
         break;
      case ir_var_shader_out:
         dest = &ibo;
         break;
      default:
         assert(!"Unsupported interface variable mode!");
         return false;
      }

      if (*dest != NULL) {
         return false;
      } else {
         *dest = i;
         return true;
      }
   }

   const glsl_type *get_interface(enum ir_variable_mode mode)
   {
      switch (mode) {
      case ir_var_uniform:
         return ibu;
      case ir_var_shader_in:
         return ibi;
      case ir_var_shader_out:
         return ibo;
      default:
         assert(!"Unsupported interface variable mode!");
         return NULL;
      }
   }

   symbol_table_entry(ir_variable *v)               :
      v(v), f(0), t(0), ibu(0), ibi(0), ibo(0), a(0) {}
   symbol_table_entry(ir_function *f)               :
      v(0), f(f), t(0), ibu(0), ibi(0), ibo(0), a(0) {}
   symbol_table_entry(const glsl_type *t)           :
      v(0), f(0), t(t), ibu(0), ibi(0), ibo(0), a(0) {}
   symbol_table_entry(const glsl_type *t, enum ir_variable_mode mode) :
      v(0), f(0), t(0), ibu(0), ibi(0), ibo(0), a(0)
   {
      assert(t->is_interface());
      add_interface(t, mode);
   }
   symbol_table_entry(const class ast_type_specifier *a):
      v(0), f(0), t(0), ibu(0), ibi(0), ibo(0), a(a) {}
a50 4
   const glsl_type *ibu;
   const glsl_type *ibi;
   const glsl_type *ibo;
   const class ast_type_specifier *a;
d55 1
a55 1
   this->separate_function_namespace = false;
d83 1
a83 1
   if (this->separate_function_namespace) {
a120 34
static char *make_ast_name(const char *name)
{
   char *ast_name = new char[strlen("#ast.") + strlen(name) + 1];
   strcpy(ast_name, "#ast.");
   strcat(ast_name + strlen("#ast."), name);
   return ast_name;
}

bool glsl_symbol_table::add_type_ast(const char *name, const class ast_type_specifier *a)
{
   symbol_table_entry *entry = new(mem_ctx) symbol_table_entry(a);
   char *ast_name = make_ast_name(name);
   bool ret = _mesa_symbol_table_add_symbol(table, -1, ast_name, entry) == 0;
   delete [] ast_name;
   return ret;
}

bool glsl_symbol_table::add_interface(const char *name, const glsl_type *i,
                                      enum ir_variable_mode mode)
{
   assert(i->is_interface());
   symbol_table_entry *entry = get_entry(name);
   if (entry == NULL) {
      symbol_table_entry *entry =
         new(mem_ctx) symbol_table_entry(i, mode);
      bool add_interface_symbol_result =
         _mesa_symbol_table_add_symbol(table, -1, name, entry) == 0;
      assert(add_interface_symbol_result);
      return add_interface_symbol_result;
   } else {
      return entry->add_interface(i, mode);
   }
}

d123 1
a123 1
   if (this->separate_function_namespace && name_declared_this_scope(f->name)) {
a139 1
   (void)added;
a151 15
}

const class ast_type_specifier *glsl_symbol_table::get_type_ast(const char *name)
{
   char *ast_name = make_ast_name(name);
   symbol_table_entry *entry = get_entry(ast_name);
   delete [] ast_name;
   return entry != NULL ? entry->a : NULL;
}

const glsl_type *glsl_symbol_table::get_interface(const char *name,
                                                  enum ir_variable_mode mode)
{
   symbol_table_entry *entry = get_entry(name);
   return entry != NULL ? entry->get_interface(mode) : NULL;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d29 14
a42 1
   DECLARE_RALLOC_CXX_OPERATORS(symbol_table_entry);
d178 17
d246 8
a270 15
}

void
glsl_symbol_table::disable_variable(const char *name)
{
   /* Ideally we would remove the variable's entry from the symbol table, but
    * that would be difficult.  Fortunately, since this is only used for
    * built-in variables, it won't be possible for the shader to re-introduce
    * the variable later, so all we really need to do is to make sure that
    * further attempts to access it using get_variable() will return NULL.
    */
   symbol_table_entry *entry = get_entry(name);
   if (entry != NULL) {
      entry->v = NULL;
   }
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a126 2
   assert(v->data.mode != ir_var_temporary);

@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d127 2
@


