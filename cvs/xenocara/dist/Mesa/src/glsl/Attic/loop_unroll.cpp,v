head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.5.0.4
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.2
	OPENBSD_5_6_BASE:1.1.1.3
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.1.1.2.0.2
	OPENBSD_5_5_BASE:1.1.1.2
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.1.1.1.0.8
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.6
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.2
date	2015.12.23.05.17.44;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.19;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.30;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.26;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.32;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "glsl_types.h"
#include "loop_analysis.h"
#include "ir_hierarchical_visitor.h"

class loop_unroll_visitor : public ir_hierarchical_visitor {
public:
   loop_unroll_visitor(loop_state *state, unsigned max_iterations)
   {
      this->state = state;
      this->progress = false;
      this->max_iterations = max_iterations;
   }

   virtual ir_visitor_status visit_leave(ir_loop *ir);

   loop_state *state;

   bool progress;
   unsigned max_iterations;
};


static bool
is_break(ir_instruction *ir)
{
   return ir != NULL && ir->ir_type == ir_type_loop_jump
		     && ((ir_loop_jump *) ir)->is_break();
}


ir_visitor_status
loop_unroll_visitor::visit_leave(ir_loop *ir)
{
   loop_variable_state *const ls = this->state->get(ir);
   int iterations;

   /* If we've entered a loop that hasn't been analyzed, something really,
    * really bad has happened.
    */
   if (ls == NULL) {
      assert(ls != NULL);
      return visit_continue;
   }

   iterations = ls->max_iterations;

   /* Don't try to unroll loops where the number of iterations is not known
    * at compile-time.
    */
   if (iterations < 0)
      return visit_continue;

   /* Don't try to unroll loops that have zillions of iterations either.
    */
   if (iterations > (int) max_iterations)
      return visit_continue;

   if (ls->num_loop_jumps > 1)
      return visit_continue;
   else if (ls->num_loop_jumps) {
      ir_instruction *last_ir = (ir_instruction *) ir->body_instructions.get_tail();
      assert(last_ir != NULL);

      if (is_break(last_ir)) {
         /* If the only loop-jump is a break at the end of the loop, the loop
          * will execute exactly once.  Remove the break, set the iteration
          * count, and fall through to the normal unroller.
          */
         last_ir->remove();
         iterations = 1;

         this->progress = true;
      } else {
         ir_if *ir_if = NULL;
         ir_instruction *break_ir = NULL;
         bool continue_from_then_branch = false;

         foreach_list(node, &ir->body_instructions) {
            /* recognize loops in the form produced by ir_lower_jumps */
            ir_instruction *cur_ir = (ir_instruction *) node;

            ir_if = cur_ir->as_if();
            if (ir_if != NULL) {
	       /* Determine which if-statement branch, if any, ends with a
		* break.  The branch that did *not* have the break will get a
		* temporary continue inserted in each iteration of the loop
		* unroll.
		*
		* Note that since ls->num_loop_jumps is <= 1, it is impossible
		* for both branches to end with a break.
		*/
               ir_instruction *ir_if_last =
                  (ir_instruction *) ir_if->then_instructions.get_tail();

               if (is_break(ir_if_last)) {
                  continue_from_then_branch = false;
                  break_ir = ir_if_last;
                  break;
               } else {
                  ir_if_last =
		     (ir_instruction *) ir_if->else_instructions.get_tail();

                  if (is_break(ir_if_last)) {
                     break_ir = ir_if_last;
                     continue_from_then_branch = true;
                     break;
                  }
               }
            }
         }

         if (break_ir == NULL)
            return visit_continue;

         /* move instructions after then if in the continue branch */
         while (!ir_if->get_next()->is_tail_sentinel()) {
            ir_instruction *move_ir = (ir_instruction *) ir_if->get_next();

            move_ir->remove();
            if (continue_from_then_branch)
               ir_if->then_instructions.push_tail(move_ir);
            else
               ir_if->else_instructions.push_tail(move_ir);
         }

         /* Remove the break from the if-statement.
          */
         break_ir->remove();

         void *const mem_ctx = ralloc_parent(ir);
         ir_instruction *ir_to_replace = ir;

         for (int i = 0; i < iterations; i++) {
            exec_list copy_list;

            copy_list.make_empty();
            clone_ir_list(mem_ctx, &copy_list, &ir->body_instructions);

            ir_if = ((ir_instruction *) copy_list.get_tail())->as_if();
            assert(ir_if != NULL);

            ir_to_replace->insert_before(&copy_list);
            ir_to_replace->remove();

            /* placeholder that will be removed in the next iteration */
            ir_to_replace =
	       new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_continue);

            exec_list *const list = (continue_from_then_branch)
               ? &ir_if->then_instructions : &ir_if->else_instructions;

            list->push_tail(ir_to_replace);
         }

         ir_to_replace->remove();

         this->progress = true;
         return visit_continue;
      }
   }

   void *const mem_ctx = ralloc_parent(ir);

   for (int i = 0; i < iterations; i++) {
      exec_list copy_list;

      copy_list.make_empty();
      clone_ir_list(mem_ctx, &copy_list, &ir->body_instructions);

      ir->insert_before(&copy_list);
   }

   /* The loop has been replaced by the unrolled copies.  Remove the original
    * loop from the IR sequence.
    */
   ir->remove();

   this->progress = true;
   return visit_continue;
}


bool
unroll_loops(exec_list *instructions, loop_state *ls, unsigned max_iterations)
{
   loop_unroll_visitor v(ls, max_iterations);

   v.run(instructions);

   return v.progress;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a52 32
class loop_unroll_count : public ir_hierarchical_visitor {
public:
   int nodes;
   bool fail;

   loop_unroll_count(exec_list *list)
   {
      nodes = 0;
      fail = false;

      run(list);
   }

   virtual ir_visitor_status visit_enter(ir_assignment *ir)
   {
      nodes++;
      return visit_continue;
   }

   virtual ir_visitor_status visit_enter(ir_expression *ir)
   {
      nodes++;
      return visit_continue;
   }

   virtual ir_visitor_status visit_enter(ir_loop *ir)
   {
      fail = true;
      return visit_continue;
   }
};

a78 7
      return visit_continue;

   /* Don't try to unroll nested loops and loops with a huge body.
    */
   loop_unroll_count count(&ir->body_instructions);

   if (count.fail || count.nodes * iterations > (int)max_iterations * 5)
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a27 4
#include "main/mtypes.h"

namespace {

d30 1
a30 2
   loop_unroll_visitor(loop_state *state,
                       const struct gl_shader_compiler_options *options)
d34 1
a34 1
      this->options = options;
a37 4
   void simple_unroll(ir_loop *ir, int iterations);
   void complex_unroll(ir_loop *ir, int iterations,
                       bool continue_from_then_branch);
   void splice_post_if_instructions(ir_if *ir_if, exec_list *splice_dest);
d42 1
a42 1
   const struct gl_shader_compiler_options *options;
a44 1
} /* anonymous namespace */
d56 3
a58 7
   bool unsupported_variable_indexing;
   /* If there are nested loops, the node count will be inaccurate. */
   bool nested_loop;

   loop_unroll_count(exec_list *list, loop_variable_state *ls,
                     const struct gl_shader_compiler_options *options)
      : ls(ls), options(options)
d61 1
a61 2
      nested_loop = false;
      unsupported_variable_indexing = false;
d66 1
a66 1
   virtual ir_visitor_status visit_enter(ir_assignment *)
d72 1
a72 1
   virtual ir_visitor_status visit_enter(ir_expression *)
d78 1
a78 1
   virtual ir_visitor_status visit_enter(ir_loop *)
d80 1
a80 1
      nested_loop = true;
a82 48

   virtual ir_visitor_status visit_enter(ir_dereference_array *ir)
   {
      /* Check for arrays variably-indexed by a loop induction variable.
       * Unrolling the loop may convert that access into constant-indexing.
       *
       * Many drivers don't support particular kinds of variable indexing,
       * and have to resort to using lower_variable_index_to_cond_assign to
       * handle it.  This results in huge amounts of horrible code, so we'd
       * like to avoid that if possible.  Here, we just note that it will
       * happen.
       */
      if ((ir->array->type->is_array() || ir->array->type->is_matrix()) &&
          !ir->array_index->as_constant()) {
         ir_variable *array = ir->array->variable_referenced();
         loop_variable *lv = ls->get(ir->array_index->variable_referenced());
         if (array && lv && lv->is_induction_var()) {
            switch (array->data.mode) {
            case ir_var_auto:
            case ir_var_temporary:
            case ir_var_const_in:
            case ir_var_function_in:
            case ir_var_function_out:
            case ir_var_function_inout:
               if (options->EmitNoIndirectTemp)
                  unsupported_variable_indexing = true;
               break;
            case ir_var_uniform:
               if (options->EmitNoIndirectUniform)
                  unsupported_variable_indexing = true;
               break;
            case ir_var_shader_in:
               if (options->EmitNoIndirectInput)
                  unsupported_variable_indexing = true;
               break;
            case ir_var_shader_out:
               if (options->EmitNoIndirectOutput)
                  unsupported_variable_indexing = true;
               break;
            }
         }
      }
      return visit_continue;
   }

private:
   loop_variable_state *ls;
   const struct gl_shader_compiler_options *options;
a85 132
/**
 * Unroll a loop which does not contain any jumps.  For example, if the input
 * is:
 *
 *     (loop (...) ...instrs...)
 *
 * And the iteration count is 3, the output will be:
 *
 *     ...instrs... ...instrs... ...instrs...
 */
void
loop_unroll_visitor::simple_unroll(ir_loop *ir, int iterations)
{
   void *const mem_ctx = ralloc_parent(ir);

   for (int i = 0; i < iterations; i++) {
      exec_list copy_list;

      copy_list.make_empty();
      clone_ir_list(mem_ctx, &copy_list, &ir->body_instructions);

      ir->insert_before(&copy_list);
   }

   /* The loop has been replaced by the unrolled copies.  Remove the original
    * loop from the IR sequence.
    */
   ir->remove();

   this->progress = true;
}


/**
 * Unroll a loop whose last statement is an ir_if.  If \c
 * continue_from_then_branch is true, the loop is repeated only when the
 * "then" branch of the if is taken; otherwise it is repeated only when the
 * "else" branch of the if is taken.
 *
 * For example, if the input is:
 *
 *     (loop (...)
 *      ...body...
 *      (if (cond)
 *          (...then_instrs...)
 *        (...else_instrs...)))
 *
 * And the iteration count is 3, and \c continue_from_then_branch is true,
 * then the output will be:
 *
 *     ...body...
 *     (if (cond)
 *         (...then_instrs...
 *          ...body...
 *          (if (cond)
 *              (...then_instrs...
 *               ...body...
 *               (if (cond)
 *                   (...then_instrs...)
 *                 (...else_instrs...)))
 *            (...else_instrs...)))
 *       (...else_instrs))
 */
void
loop_unroll_visitor::complex_unroll(ir_loop *ir, int iterations,
                                    bool continue_from_then_branch)
{
   void *const mem_ctx = ralloc_parent(ir);
   ir_instruction *ir_to_replace = ir;

   for (int i = 0; i < iterations; i++) {
      exec_list copy_list;

      copy_list.make_empty();
      clone_ir_list(mem_ctx, &copy_list, &ir->body_instructions);

      ir_if *ir_if = ((ir_instruction *) copy_list.get_tail())->as_if();
      assert(ir_if != NULL);

      ir_to_replace->insert_before(&copy_list);
      ir_to_replace->remove();

      /* placeholder that will be removed in the next iteration */
      ir_to_replace =
         new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_continue);

      exec_list *const list = (continue_from_then_branch)
         ? &ir_if->then_instructions : &ir_if->else_instructions;

      list->push_tail(ir_to_replace);
   }

   ir_to_replace->remove();

   this->progress = true;
}


/**
 * Move all of the instructions which follow \c ir_if to the end of
 * \c splice_dest.
 *
 * For example, in the code snippet:
 *
 *     (if (cond)
 *         (...then_instructions...
 *          break)
 *       (...else_instructions...))
 *     ...post_if_instructions...
 *
 * If \c ir_if points to the "if" instruction, and \c splice_dest points to
 * (...else_instructions...), the code snippet is transformed into:
 *
 *     (if (cond)
 *         (...then_instructions...
 *          break)
 *       (...else_instructions...
 *        ...post_if_instructions...))
 */
void
loop_unroll_visitor::splice_post_if_instructions(ir_if *ir_if,
                                                 exec_list *splice_dest)
{
   while (!ir_if->get_next()->is_tail_sentinel()) {
      ir_instruction *move_ir = (ir_instruction *) ir_if->get_next();

      move_ir->remove();
      splice_dest->push_tail(move_ir);
   }
}


d100 2
d105 1
a105 1
   if (ls->limiting_terminator == NULL)
a107 4
   iterations = ls->limiting_terminator->iterations;

   const int max_iterations = options->MaxUnrollIterations;

d110 1
a110 1
   if (iterations > max_iterations)
d115 1
a115 1
   loop_unroll_count count(&ir->body_instructions, ls, options);
d117 2
a118 2
   bool loop_too_large =
      count.nested_loop || count.nodes * iterations > max_iterations * 5;
d120 1
a120 1
   if (loop_too_large && !count.unsupported_variable_indexing)
d122 3
d126 68
a193 5
   /* Note: the limiting terminator contributes 1 to ls->num_loop_jumps.
    * We'll be removing the limiting terminator before we unroll.
    */
   assert(ls->num_loop_jumps > 0);
   unsigned predicted_num_loop_jumps = ls->num_loop_jumps - 1;
d195 2
a196 2
   if (predicted_num_loop_jumps > 1)
      return visit_continue;
d198 2
a199 5
   if (predicted_num_loop_jumps == 0) {
      ls->limiting_terminator->ir->remove();
      simple_unroll(ir, iterations);
      return visit_continue;
   }
d201 2
a202 2
   ir_instruction *last_ir = (ir_instruction *) ir->body_instructions.get_tail();
   assert(last_ir != NULL);
d204 2
a205 6
   if (is_break(last_ir)) {
      /* If the only loop-jump is a break at the end of the loop, the loop
       * will execute exactly once.  Remove the break and use the simple
       * unroller with an iteration count of 1.
       */
      last_ir->remove();
d207 3
a209 4
      ls->limiting_terminator->ir->remove();
      simple_unroll(ir, 1);
      return visit_continue;
   }
d211 2
a212 22
   foreach_list(node, &ir->body_instructions) {
      /* recognize loops in the form produced by ir_lower_jumps */
      ir_instruction *cur_ir = (ir_instruction *) node;

      /* Skip the limiting terminator, since it will go away when we
       * unroll.
       */
      if (cur_ir == ls->limiting_terminator->ir)
         continue;

      ir_if *ir_if = cur_ir->as_if();
      if (ir_if != NULL) {
         /* Determine which if-statement branch, if any, ends with a
          * break.  The branch that did *not* have the break will get a
          * temporary continue inserted in each iteration of the loop
          * unroll.
          *
          * Note that since ls->num_loop_jumps is <= 1, it is impossible
          * for both branches to end with a break.
          */
         ir_instruction *ir_if_last =
            (ir_instruction *) ir_if->then_instructions.get_tail();
d214 1
a214 17
         if (is_break(ir_if_last)) {
            ls->limiting_terminator->ir->remove();
            splice_post_if_instructions(ir_if, &ir_if->else_instructions);
            ir_if_last->remove();
            complex_unroll(ir, iterations, false);
            return visit_continue;
         } else {
            ir_if_last =
               (ir_instruction *) ir_if->else_instructions.get_tail();

            if (is_break(ir_if_last)) {
               ls->limiting_terminator->ir->remove();
               splice_post_if_instructions(ir_if, &ir_if->then_instructions);
               ir_if_last->remove();
               complex_unroll(ir, iterations, true);
               return visit_continue;
            }
d216 5
d224 13
a236 2
   /* Did not find the break statement.  It must be in a complex if-nesting,
    * so don't try to unroll.
d238 3
d246 1
a246 2
unroll_loops(exec_list *instructions, loop_state *ls,
             const struct gl_shader_compiler_options *options)
d248 1
a248 1
   loop_unroll_visitor v(ls, options);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a66 1
   bool array_indexed_by_induction_var_with_exact_iterations;
a76 1
      array_indexed_by_induction_var_with_exact_iterations = false;
a114 8
            /* If an array is indexed by a loop induction variable, and the
             * array size is exactly the number of loop iterations, this is
             * probably a simple for-loop trying to access each element in
             * turn; the application may expect it to be unrolled.
             */
            if (int(array->type->length) == ls->limiting_terminator->iterations)
               array_indexed_by_induction_var_with_exact_iterations = true;

d317 1
a317 2
   if (loop_too_large && !count.unsupported_variable_indexing &&
       !count.array_indexed_by_induction_var_with_exact_iterations)
d350 4
a353 2
   /* recognize loops in the form produced by ir_lower_jumps */
   foreach_in_list(ir_instruction, cur_ir, &ir->body_instructions) {
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d67 1
d78 1
d117 8
d327 2
a328 1
   if (loop_too_large && !count.unsupported_variable_indexing)
d361 2
a362 4
   foreach_list(node, &ir->body_instructions) {
      /* recognize loops in the form produced by ir_lower_jumps */
      ir_instruction *cur_ir = (ir_instruction *) node;

@


