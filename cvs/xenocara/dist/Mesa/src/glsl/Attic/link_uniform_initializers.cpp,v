head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.2
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.14.17;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.14.17;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.30;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.10.23;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.47.30;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2012 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "main/core.h"
#include "ir.h"
#include "linker.h"
#include "ir_uniform.h"
#include "glsl_symbol_table.h"
#include "program/hash_table.h"

/* These functions are put in a "private" namespace instead of being marked
 * static so that the unit tests can access them.  See
 * http://code.google.com/p/googletest/wiki/AdvancedGuide#Testing_Private_Code
 */
namespace linker {

gl_uniform_storage *
get_storage(gl_uniform_storage *storage, unsigned num_storage,
	    const char *name)
{
   for (unsigned int i = 0; i < num_storage; i++) {
      if (strcmp(name, storage[i].name) == 0)
	 return &storage[i];
   }

   return NULL;
}

void
copy_constant_to_storage(union gl_constant_value *storage,
			 const ir_constant *val,
			 const enum glsl_base_type base_type,
			 const unsigned int elements)
{
   for (unsigned int i = 0; i < elements; i++) {
      switch (base_type) {
      case GLSL_TYPE_UINT:
	 storage[i].u = val->value.u[i];
	 break;
      case GLSL_TYPE_INT:
      case GLSL_TYPE_SAMPLER:
	 storage[i].i = val->value.i[i];
	 break;
      case GLSL_TYPE_FLOAT:
	 storage[i].f = val->value.f[i];
	 break;
      case GLSL_TYPE_BOOL:
	 storage[i].b = int(val->value.b[i]);
	 break;
      case GLSL_TYPE_ARRAY:
      case GLSL_TYPE_STRUCT:
      case GLSL_TYPE_INTERFACE:
      case GLSL_TYPE_VOID:
      case GLSL_TYPE_ERROR:
	 /* All other types should have already been filtered by other
	  * paths in the caller.
	  */
	 assert(!"Should not get here.");
	 break;
      }
   }
}

void
set_uniform_binding(void *mem_ctx, gl_shader_program *prog,
                    const char *name, const glsl_type *type, int binding)
{
   struct gl_uniform_storage *const storage =
      get_storage(prog->UniformStorage, prog->NumUserUniformStorage, name);

   if (storage == NULL) {
      assert(storage != NULL);
      return;
   }

   if (storage->type->is_sampler()) {
      unsigned elements = MAX2(storage->array_elements, 1);

      /* From section 4.4.4 of the GLSL 4.20 specification:
       * "If the binding identifier is used with an array, the first element
       *  of the array takes the specified unit and each subsequent element
       *  takes the next consecutive unit."
       */
      for (unsigned int i = 0; i < elements; i++) {
         storage->storage[i].i = binding + i;
      }

      for (int sh = 0; sh < MESA_SHADER_TYPES; sh++) {
         gl_shader *shader = prog->_LinkedShaders[sh];

         if (shader && storage->sampler[sh].active) {
            for (unsigned i = 0; i < elements; i++) {
               unsigned index = storage->sampler[sh].index + i;

               shader->SamplerUnits[index] = storage->storage[i].i;
            }
         }
      }
   } else if (storage->block_index != -1) {
      /* This is a field of a UBO.  val is the binding index. */
      for (int i = 0; i < MESA_SHADER_TYPES; i++) {
         int stage_index = prog->UniformBlockStageIndex[i][storage->block_index];

         if (stage_index != -1) {
            struct gl_shader *sh = prog->_LinkedShaders[i];
            sh->UniformBlocks[stage_index].Binding = binding;
         }
      }
   }

   storage->initialized = true;
}

void
set_uniform_initializer(void *mem_ctx, gl_shader_program *prog,
			const char *name, const glsl_type *type,
			ir_constant *val)
{
   if (type->is_record()) {
      ir_constant *field_constant;

      field_constant = (ir_constant *)val->components.get_head();

      for (unsigned int i = 0; i < type->length; i++) {
	 const glsl_type *field_type = type->fields.structure[i].type;
	 const char *field_name = ralloc_asprintf(mem_ctx, "%s.%s", name,
					    type->fields.structure[i].name);
	 set_uniform_initializer(mem_ctx, prog, field_name,
				 field_type, field_constant);
	 field_constant = (ir_constant *)field_constant->next;
      }
      return;
   } else if (type->is_array() && type->fields.array->is_record()) {
      const glsl_type *const element_type = type->fields.array;

      for (unsigned int i = 0; i < type->length; i++) {
	 const char *element_name = ralloc_asprintf(mem_ctx, "%s[%d]", name, i);

	 set_uniform_initializer(mem_ctx, prog, element_name,
				 element_type, val->array_elements[i]);
      }
      return;
   }

   struct gl_uniform_storage *const storage =
      get_storage(prog->UniformStorage,
		  prog->NumUserUniformStorage,
		  name);
   if (storage == NULL) {
      assert(storage != NULL);
      return;
   }

   if (val->type->is_array()) {
      const enum glsl_base_type base_type =
	 val->array_elements[0]->type->base_type;
      const unsigned int elements = val->array_elements[0]->type->components();
      unsigned int idx = 0;

      assert(val->type->length >= storage->array_elements);
      for (unsigned int i = 0; i < storage->array_elements; i++) {
	 copy_constant_to_storage(& storage->storage[idx],
				  val->array_elements[i],
				  base_type,
				  elements);

	 idx += elements;
      }
   } else {
      copy_constant_to_storage(storage->storage,
			       val,
			       val->type->base_type,
			       val->type->components());

      if (storage->type->is_sampler()) {
         for (int sh = 0; sh < MESA_SHADER_TYPES; sh++) {
            gl_shader *shader = prog->_LinkedShaders[sh];

            if (shader && storage->sampler[sh].active) {
               unsigned index = storage->sampler[sh].index;

               shader->SamplerUnits[index] = storage->storage[0].i;
            }
         }
      }
   }

   storage->initialized = true;
}
}

void
link_set_uniform_initializers(struct gl_shader_program *prog)
{
   void *mem_ctx = NULL;

   for (unsigned int i = 0; i < MESA_SHADER_TYPES; i++) {
      struct gl_shader *shader = prog->_LinkedShaders[i];

      if (shader == NULL)
	 continue;

      foreach_list(node, shader->ir) {
	 ir_variable *const var = ((ir_instruction *) node)->as_variable();

	 if (!var || var->mode != ir_var_uniform)
	    continue;

	 if (!mem_ctx)
	    mem_ctx = ralloc_context(NULL);

         if (var->explicit_binding) {
            linker::set_uniform_binding(mem_ctx, prog, var->name,
                                        var->type, var->binding);
         } else if (var->constant_value) {
            linker::set_uniform_initializer(mem_ctx, prog, var->name,
                                            var->type, var->constant_value);
         }
      }
   }

   ralloc_free(mem_ctx);
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@a48 12
static unsigned
get_uniform_block_index(const gl_shader_program *shProg,
                        const char *uniformBlockName)
{
   for (unsigned i = 0; i < shProg->NumUniformBlocks; i++) {
      if (!strcmp(shProg->UniformBlocks[i].Name, uniformBlockName))
	 return i;
   }

   return GL_INVALID_INDEX;
}

a71 2
      case GLSL_TYPE_IMAGE:
      case GLSL_TYPE_ATOMIC_UINT:
d85 2
a86 1
set_sampler_binding(gl_shader_program *prog, const char *name, int binding)
d96 2
a97 1
   const unsigned elements = MAX2(storage->array_elements, 1);
d99 15
a113 10
   /* Section 4.4.4 (Opaque-Uniform Layout Qualifiers) of the GLSL 4.20 spec
    * says:
    *
    *     "If the binding identifier is used with an array, the first element
    *     of the array takes the specified unit and each subsequent element
    *     takes the next consecutive unit."
    */
   for (unsigned int i = 0; i < elements; i++) {
      storage->storage[i].i = binding + i;
   }
d115 2
a116 8
   for (int sh = 0; sh < MESA_SHADER_STAGES; sh++) {
      gl_shader *shader = prog->_LinkedShaders[sh];

      if (shader && storage->sampler[sh].active) {
         for (unsigned i = 0; i < elements; i++) {
            unsigned index = storage->sampler[sh].index + i;

            shader->SamplerUnits[index] = storage->storage[i].i;
d119 1
a119 15
   }

   storage->initialized = true;
}

void
set_block_binding(gl_shader_program *prog, const char *block_name, int binding)
{
   const unsigned block_index = get_uniform_block_index(prog, block_name);

   if (block_index == GL_INVALID_INDEX) {
      assert(block_index != GL_INVALID_INDEX);
      return;
   }

d121 2
a122 2
      for (int i = 0; i < MESA_SHADER_STAGES; i++) {
         int stage_index = prog->UniformBlockStageIndex[i][block_index];
d129 3
d196 1
a196 1
         for (int sh = 0; sh < MESA_SHADER_STAGES; sh++) {
d217 1
a217 1
   for (unsigned int i = 0; i < MESA_SHADER_STAGES; i++) {
d226 1
a226 1
	 if (!var || var->data.mode != ir_var_uniform)
d232 3
a234 48
         if (var->data.explicit_binding) {
            const glsl_type *const type = var->type;

            if (type->is_sampler()
                || (type->is_array() && type->fields.array->is_sampler())) {
               linker::set_sampler_binding(prog, var->name, var->data.binding);
            } else if (var->is_in_uniform_block()) {
               const glsl_type *const iface_type = var->get_interface_type();

               /* If the variable is an array and it is an interface instance,
                * we need to set the binding for each array element.  Just
                * checking that the variable is an array is not sufficient.
                * The variable could be an array element of a uniform block
                * that lacks an instance name.  For example:
                *
                *     uniform U {
                *         float f[4];
                *     };
                *
                * In this case "f" would pass is_in_uniform_block (above) and
                * type->is_array(), but it will fail is_interface_instance().
                */
               if (var->is_interface_instance() && var->type->is_array()) {
                  for (unsigned i = 0; i < var->type->length; i++) {
                     const char *name =
                        ralloc_asprintf(mem_ctx, "%s[%u]", iface_type->name, i);

                     /* Section 4.4.3 (Uniform Block Layout Qualifiers) of the
                      * GLSL 4.20 spec says:
                      *
                      *     "If the binding identifier is used with a uniform
                      *     block instanced as an array then the first element
                      *     of the array takes the specified block binding and
                      *     each subsequent element takes the next consecutive
                      *     uniform block binding point."
                      */
                     linker::set_block_binding(prog, name,
                                               var->data.binding + i);
                  }
               } else {
                  linker::set_block_binding(prog, iface_type->name,
                                            var->data.binding);
               }
            } else if (type->contains_atomic()) {
               /* we don't actually need to do anything. */
            } else {
               assert(!"Explicit binding not on a sampler, UBO or atomic.");
            }
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d28 2
d65 1
a65 2
                         const unsigned int elements,
                         unsigned int boolean_true)
d80 1
a80 1
	 storage[i].b = val->value.b[i] ? boolean_true : 0;
d161 1
a161 1
                        ir_constant *val, unsigned int boolean_true)
d173 1
a173 1
                                 field_type, field_constant, boolean_true);
d184 1
a184 2
                                 element_type, val->array_elements[i],
                                 boolean_true);
d209 1
a209 2
                                  elements,
                                  boolean_true);
d217 1
a217 2
                               val->type->components(),
                               boolean_true);
d237 1
a237 2
link_set_uniform_initializers(struct gl_shader_program *prog,
                              unsigned int boolean_true)
d247 2
a248 2
      foreach_in_list(ir_instruction, node, shader->ir) {
	 ir_variable *const var = node->as_variable();
d259 2
a260 1
            if (type->without_array()->is_sampler()) {
d306 1
a306 2
                                            var->type, var->constant_value,
                                            boolean_true);
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@a27 2
#include "glsl_symbol_table.h"
#include "program/hash_table.h"
d63 2
a64 1
			 const unsigned int elements)
d79 1
a79 1
	 storage[i].b = int(val->value.b[i]);
d160 1
a160 1
			ir_constant *val)
d172 1
a172 1
				 field_type, field_constant);
d183 2
a184 1
				 element_type, val->array_elements[i]);
d209 2
a210 1
				  elements);
d218 2
a219 1
			       val->type->components());
d239 2
a240 1
link_set_uniform_initializers(struct gl_shader_program *prog)
d250 2
a251 2
      foreach_list(node, shader->ir) {
	 ir_variable *const var = ((ir_instruction *) node)->as_variable();
d262 1
a262 2
            if (type->is_sampler()
                || (type->is_array() && type->fields.array->is_sampler())) {
d308 2
a309 1
                                            var->type, var->constant_value);
@


