head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.26;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.15;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.29;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.21;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.28;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "glsl_types.h"
#include "ir.h"

typedef enum {
   PARAMETER_LIST_NO_MATCH,
   PARAMETER_LIST_EXACT_MATCH,
   PARAMETER_LIST_INEXACT_MATCH /*< Match requires implicit conversion. */
} parameter_list_match_t;

/**
 * \brief Check if two parameter lists match.
 *
 * \param list_a Parameters of the function definition.
 * \param list_b Actual parameters passed to the function.
 * \see matching_signature()
 */
static parameter_list_match_t
parameter_lists_match(const exec_list *list_a, const exec_list *list_b)
{
   const exec_node *node_a = list_a->head;
   const exec_node *node_b = list_b->head;

   /* This is set to true if there is an inexact match requiring an implicit
    * conversion. */
   bool inexact_match = false;

   for (/* empty */
	; !node_a->is_tail_sentinel()
	; node_a = node_a->next, node_b = node_b->next) {
      /* If all of the parameters from the other parameter list have been
       * exhausted, the lists have different length and, by definition,
       * do not match.
       */
      if (node_b->is_tail_sentinel())
	 return PARAMETER_LIST_NO_MATCH;


      const ir_variable *const param = (ir_variable *) node_a;
      const ir_rvalue *const actual = (ir_rvalue *) node_b;

      if (param->type == actual->type)
	 continue;

      /* Try to find an implicit conversion from actual to param. */
      inexact_match = true;
      switch ((enum ir_variable_mode)(param->data.mode)) {
      case ir_var_auto:
      case ir_var_uniform:
      case ir_var_temporary:
	 /* These are all error conditions.  It is invalid for a parameter to
	  * a function to be declared as auto (not in, out, or inout) or
	  * as uniform.
	  */
	 assert(0);
	 return PARAMETER_LIST_NO_MATCH;

      case ir_var_const_in:
      case ir_var_function_in:
	 if (!actual->type->can_implicitly_convert_to(param->type))
	    return PARAMETER_LIST_NO_MATCH;
	 break;

      case ir_var_function_out:
	 if (!param->type->can_implicitly_convert_to(actual->type))
	    return PARAMETER_LIST_NO_MATCH;
	 break;

      case ir_var_function_inout:
	 /* Since there are no bi-directional automatic conversions (e.g.,
	  * there is int -> float but no float -> int), inout parameters must
	  * be exact matches.
	  */
	 return PARAMETER_LIST_NO_MATCH;

      default:
	 assert(false);
	 return PARAMETER_LIST_NO_MATCH;
      }
   }

   /* If all of the parameters from the other parameter list have been
    * exhausted, the lists have different length and, by definition, do not
    * match.
    */
   if (!node_b->is_tail_sentinel())
      return PARAMETER_LIST_NO_MATCH;

   if (inexact_match)
      return PARAMETER_LIST_INEXACT_MATCH;
   else
      return PARAMETER_LIST_EXACT_MATCH;
}


ir_function_signature *
ir_function::matching_signature(_mesa_glsl_parse_state *state,
                                const exec_list *actual_parameters)
{
   bool is_exact;
   return matching_signature(state, actual_parameters, &is_exact);
}

ir_function_signature *
ir_function::matching_signature(_mesa_glsl_parse_state *state,
                                const exec_list *actual_parameters,
			        bool *is_exact)
{
   ir_function_signature *match = NULL;
   bool multiple_inexact_matches = false;

   /* From page 42 (page 49 of the PDF) of the GLSL 1.20 spec:
    *
    * "If an exact match is found, the other signatures are ignored, and
    *  the exact match is used.  Otherwise, if no exact match is found, then
    *  the implicit conversions in Section 4.1.10 "Implicit Conversions" will
    *  be applied to the calling arguments if this can make their types match
    *  a signature.  In this case, it is a semantic error if there are
    *  multiple ways to apply these conversions to the actual arguments of a
    *  call such that the call can be made to match multiple signatures."
    */
   foreach_list(n, &this->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;

      /* Skip over any built-ins that aren't available in this shader. */
      if (sig->is_builtin() && !sig->is_builtin_available(state))
         continue;

      switch (parameter_lists_match(& sig->parameters, actual_parameters)) {
      case PARAMETER_LIST_EXACT_MATCH:
	 *is_exact = true;
	 return sig;
      case PARAMETER_LIST_INEXACT_MATCH:
	 if (match == NULL)
	    match = sig;
	 else
	    multiple_inexact_matches = true;
	 continue;
      case PARAMETER_LIST_NO_MATCH:
	 continue;
      default:
	 assert(false);
	 return NULL;
      }
   }

   /* There is no exact match (we would have returned it by now).  If there
    * are multiple inexact matches, the call is ambiguous, which is an error.
    *
    * FINISHME: Report a decent error.  Returning NULL will likely result in
    * FINISHME: a "no matching signature" error; it should report that the
    * FINISHME: call is ambiguous.  But reporting errors from here is hard.
    */
   *is_exact = false;

   if (multiple_inexact_matches)
      return NULL;

   return match;
}


static bool
parameter_lists_match_exact(const exec_list *list_a, const exec_list *list_b)
{
   const exec_node *node_a = list_a->head;
   const exec_node *node_b = list_b->head;

   for (/* empty */
	; !node_a->is_tail_sentinel() && !node_b->is_tail_sentinel()
	; node_a = node_a->next, node_b = node_b->next) {
      ir_variable *a = (ir_variable *) node_a;
      ir_variable *b = (ir_variable *) node_b;

      /* If the types of the parameters do not match, the parameters lists
       * are different.
       */
      if (a->type != b->type)
         return false;
   }

   /* Unless both lists are exhausted, they differ in length and, by
    * definition, do not match.
    */
   return (node_a->is_tail_sentinel() == node_b->is_tail_sentinel());
}

ir_function_signature *
ir_function::exact_matching_signature(_mesa_glsl_parse_state *state,
                                      const exec_list *actual_parameters)
{
   foreach_list(n, &this->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;

      /* Skip over any built-ins that aren't available in this shader. */
      if (sig->is_builtin() && !sig->is_builtin_available(state))
         continue;

      if (parameter_lists_match_exact(&sig->parameters, actual_parameters))
	 return sig;
   }
   return NULL;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a25 2
#include "glsl_parser_extras.h"
#include "main/errors.h"
d41 1
a41 2
parameter_lists_match(_mesa_glsl_parse_state *state,
                      const exec_list *list_a, const exec_list *list_b)
d82 1
a82 1
	 if (!actual->type->can_implicitly_convert_to(param->type, state))
d87 1
a87 1
	 if (!param->type->can_implicitly_convert_to(actual->type, state))
a117 162
/* Classes of parameter match, sorted (mostly) best matches first.
 * See is_better_parameter_match() below for the exceptions.
 * */
typedef enum {
   PARAMETER_EXACT_MATCH,
   PARAMETER_FLOAT_TO_DOUBLE,
   PARAMETER_INT_TO_FLOAT,
   PARAMETER_INT_TO_DOUBLE,
   PARAMETER_OTHER_CONVERSION,
} parameter_match_t;


static parameter_match_t
get_parameter_match_type(const ir_variable *param,
                         const ir_rvalue *actual)
{
   const glsl_type *from_type;
   const glsl_type *to_type;

   if (param->data.mode == ir_var_function_out) {
      from_type = param->type;
      to_type = actual->type;
   } else {
      from_type = actual->type;
      to_type = param->type;
   }

   if (from_type == to_type)
      return PARAMETER_EXACT_MATCH;

   /* XXX: When ARB_gpu_shader_fp64 support is added, check for float->double,
    * and int/uint->double conversions
    */

   if (to_type->base_type == GLSL_TYPE_FLOAT)
      return PARAMETER_INT_TO_FLOAT;

   /* int -> uint and any other oddball conversions */
   return PARAMETER_OTHER_CONVERSION;
}


static bool
is_better_parameter_match(parameter_match_t a_match,
                          parameter_match_t b_match)
{
   /* From section 6.1 of the GLSL 4.00 spec (and the ARB_gpu_shader5 spec):
    *
    * 1. An exact match is better than a match involving any implicit
    * conversion.
    *
    * 2. A match involving an implicit conversion from float to double
    * is better than match involving any other implicit conversion.
    *
    * [XXX: Not in GLSL 4.0: Only in ARB_gpu_shader5:
    * 3. A match involving an implicit conversion from either int or uint
    * to float is better than a match involving an implicit conversion
    * from either int or uint to double.]
    *
    * If none of the rules above apply to a particular pair of conversions,
    * neither conversion is considered better than the other.
    *
    * --
    *
    * Notably, the int->uint conversion is *not* considered to be better
    * or worse than int/uint->float or int/uint->double.
    */

   if (a_match >= PARAMETER_INT_TO_FLOAT && b_match == PARAMETER_OTHER_CONVERSION)
      return false;

   return a_match < b_match;
}


static bool
is_best_inexact_overload(const exec_list *actual_parameters,
                         ir_function_signature **matches,
                         int num_matches,
                         ir_function_signature *sig)
{
   /* From section 6.1 of the GLSL 4.00 spec (and the ARB_gpu_shader5 spec):
    *
    * "A function definition A is considered a better
    * match than function definition B if:
    *
    *   * for at least one function argument, the conversion for that argument
    *     in A is better than the corresponding conversion in B; and
    *
    *   * there is no function argument for which the conversion in B is better
    *     than the corresponding conversion in A.
    *
    * If a single function definition is considered a better match than every
    * other matching function definition, it will be used.  Otherwise, a
    * semantic error occurs and the shader will fail to compile."
    */
   for (ir_function_signature **other = matches;
        other < matches + num_matches; other++) {
      if (*other == sig)
         continue;

      const exec_node *node_a = sig->parameters.head;
      const exec_node *node_b = (*other)->parameters.head;
      const exec_node *node_p = actual_parameters->head;

      bool better_for_some_parameter = false;

      for (/* empty */
           ; !node_a->is_tail_sentinel()
           ; node_a = node_a->next,
             node_b = node_b->next,
             node_p = node_p->next) {
         parameter_match_t a_match = get_parameter_match_type(
               (const ir_variable *)node_a,
               (const ir_rvalue *)node_p);
         parameter_match_t b_match = get_parameter_match_type(
               (const ir_variable *)node_b,
               (const ir_rvalue *)node_p);

         if (is_better_parameter_match(a_match, b_match))
               better_for_some_parameter = true;

         if (is_better_parameter_match(b_match, a_match))
               return false;     /* B is better for this parameter */
      }

      if (!better_for_some_parameter)
         return false;     /* A must be better than B for some parameter */

   }

   return true;
}


static ir_function_signature *
choose_best_inexact_overload(_mesa_glsl_parse_state *state,
                             const exec_list *actual_parameters,
                             ir_function_signature **matches,
                             int num_matches)
{
   if (num_matches == 0)
      return NULL;

   if (num_matches == 1)
      return *matches;

   /* Without GLSL 4.0 / ARB_gpu_shader5, there is no overload resolution
    * among multiple inexact matches. Note that state may be NULL here if
    * called from the linker; in that case we assume everything supported in
    * any GLSL version is available. */
   if (!state || state->is_version(400, 0) || state->ARB_gpu_shader5_enable) {
      for (ir_function_signature **sig = matches; sig < matches + num_matches; sig++) {
         if (is_best_inexact_overload(actual_parameters, matches, num_matches, *sig))
            return *sig;
      }
   }

   return NULL;   /* no best candidate */
}


d120 1
a120 2
                                const exec_list *actual_parameters,
                                bool allow_builtins)
d123 1
a123 2
   return matching_signature(state, actual_parameters, allow_builtins,
                             &is_exact);
d129 1
a129 2
                                bool allow_builtins,
                                bool *is_exact)
a130 2
   ir_function_signature **inexact_matches = NULL;
   ir_function_signature **inexact_matches_temp;
d132 1
a132 1
   int num_inexact_matches = 0;
d144 3
a146 1
   foreach_in_list(ir_function_signature, sig, &this->signatures) {
d148 1
a148 2
      if (sig->is_builtin() && (!allow_builtins ||
                                !sig->is_builtin_available(state)))
d151 1
a151 1
      switch (parameter_lists_match(state, & sig->parameters, actual_parameters)) {
d153 2
a154 3
         *is_exact = true;
         free(inexact_matches);
         return sig;
d156 5
a160 12
         inexact_matches_temp = (ir_function_signature **)
               realloc(inexact_matches,
                       sizeof(*inexact_matches) *
                       (num_inexact_matches + 1));
         if (inexact_matches_temp == NULL) {
            _mesa_error_no_memory(__func__);
            free(inexact_matches);
            return NULL;
         }
         inexact_matches = inexact_matches_temp;
         inexact_matches[num_inexact_matches++] = sig;
         continue;
d178 2
a179 2
   match = choose_best_inexact_overload(state, actual_parameters,
                                        inexact_matches, num_inexact_matches);
a180 1
   free(inexact_matches);
d214 3
a216 1
   foreach_in_list(ir_function_signature, sig, &this->signatures) {
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d26 2
d43 2
a44 1
parameter_lists_match(const exec_list *list_a, const exec_list *list_b)
d85 1
a85 1
	 if (!actual->type->can_implicitly_convert_to(param->type))
d90 1
a90 1
	 if (!param->type->can_implicitly_convert_to(actual->type))
d121 162
d285 2
a286 1
                                const exec_list *actual_parameters)
d289 2
a290 1
   return matching_signature(state, actual_parameters, &is_exact);
d296 2
a297 1
			        bool *is_exact)
d299 2
d302 1
a302 1
   bool multiple_inexact_matches = false;
d314 1
a314 3
   foreach_list(n, &this->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;

d316 2
a317 1
      if (sig->is_builtin() && !sig->is_builtin_available(state))
d320 1
a320 1
      switch (parameter_lists_match(& sig->parameters, actual_parameters)) {
d322 3
a324 2
	 *is_exact = true;
	 return sig;
d326 12
a337 5
	 if (match == NULL)
	    match = sig;
	 else
	    multiple_inexact_matches = true;
	 continue;
d355 2
a356 2
   if (multiple_inexact_matches)
      return NULL;
d358 1
d392 1
a392 3
   foreach_list(n, &this->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;

@


1.3
log
@Merge Mesa 9.2.0
@
text
@d69 1
a69 1
      switch ((enum ir_variable_mode)(param->mode)) {
d119 2
a120 1
ir_function::matching_signature(const exec_list *actual_parameters)
d123 1
a123 1
   return matching_signature(actual_parameters, &is_exact);
d127 2
a128 1
ir_function::matching_signature(const exec_list *actual_parameters,
d144 6
a149 3
   foreach_iter(exec_list_iterator, iter, signatures) {
      ir_function_signature *const sig =
	 (ir_function_signature *) iter.get();
d211 2
a212 1
ir_function::exact_matching_signature(const exec_list *actual_parameters)
d214 6
a219 3
   foreach_iter(exec_list_iterator, iter, signatures) {
      ir_function_signature *const sig =
	 (ir_function_signature *) iter.get();
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d27 6
a37 3
 * \return If an exact match, return 0.
 *         If an inexact match requiring implicit conversion, return 1.
 *         If not a match, return -1.
d40 1
a40 1
static int
d58 1
a58 1
	 return -1;
d62 1
a62 1
      const ir_instruction *const actual = (ir_instruction *) node_b;
d78 1
a78 1
	 return -1;
d81 1
a81 1
      case ir_var_in:
d83 1
a83 1
	    return -1;
d86 1
a86 1
      case ir_var_out:
d88 1
a88 1
	    return -1;
d91 1
a91 1
      case ir_var_inout:
d96 1
a96 1
	 return -1;
d100 1
a100 1
	 return -1;
d109 1
a109 1
      return -1;
d112 1
a112 1
      return 1;
d114 1
a114 1
      return 0;
d121 8
d146 3
a148 5
      const int score = parameter_lists_match(& sig->parameters,
					      actual_parameters);

      /* If we found an exact match, simply return it */
      if (score == 0)
d150 1
a150 2

      if (score > 0) {
d155 6
d171 2
@


1.1
log
@Initial revision
@
text
@d27 10
a36 61
int
type_compare(const glsl_type *a, const glsl_type *b)
{
   /* If the types are the same, they trivially match.
    */
   if (a == b)
      return 0;

   switch (a->base_type) {
   case GLSL_TYPE_UINT:
   case GLSL_TYPE_INT:
   case GLSL_TYPE_BOOL:
      /* There is no implicit conversion to or from integer types or bool.
       */
      if ((a->is_integer() != b->is_integer())
	  || (a->is_boolean() != b->is_boolean()))
	 return -1;

      /* FALLTHROUGH */

   case GLSL_TYPE_FLOAT:
      if ((a->vector_elements != b->vector_elements)
	  || (a->matrix_columns != b->matrix_columns))
	 return -1;

      return 1;

   case GLSL_TYPE_SAMPLER:
   case GLSL_TYPE_STRUCT:
      /* Samplers and structures must match exactly.
       */
      return -1;

   case GLSL_TYPE_ARRAY:
      if ((b->base_type != GLSL_TYPE_ARRAY)
	  || (a->length != b->length))
	 return -1;

      /* From GLSL 1.50 spec, page 27 (page 33 of the PDF):
       *    "There are no implicit array or structure conversions."
       *
       * If the comparison of the array element types detects that a conversion
       * would be required, the array types do not match.
       */
      return (type_compare(a->fields.array, b->fields.array) == 0) ? 0 : -1;

   case GLSL_TYPE_VOID:
   case GLSL_TYPE_ERROR:
   default:
      /* These are all error conditions.  It is invalid for a parameter to
       * a function to be declared as error, void, or a function.
       */
      return -1;
   }

   /* This point should be unreachable.
    */
   assert(0);
}


d42 4
a45 1
   int total_score = 0;
d61 5
a65 6
      /* Determine whether or not the types match.  If the types are an
       * exact match, the match score is zero.  If the types don't match
       * but the actual parameter can be coerced to the type of the declared
       * parameter, the match score is one.
       */
      int score;
d77 1
d79 2
a80 1
	 score = type_compare(param->type, actual->type);
d84 2
a85 1
	 score = type_compare(actual->type, param->type);
d93 1
a93 2
	 score = (type_compare(actual->type, param->type) == 0) ? 0 : -1;
	 break;
d97 1
a98 5

      if (score < 0)
	 return -1;

      total_score += score;
d108 4
a111 1
   return total_score;
d119 1
d121 10
d138 1
d143 4
a146 4
	 if (match != NULL)
	    return NULL;

	 match = sig;
d149 10
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d27 62
a88 14
typedef enum {
   PARAMETER_LIST_NO_MATCH,
   PARAMETER_LIST_EXACT_MATCH,
   PARAMETER_LIST_INEXACT_MATCH /*< Match requires implicit conversion. */
} parameter_list_match_t;

/**
 * \brief Check if two parameter lists match.
 *
 * \param list_a Parameters of the function definition.
 * \param list_b Actual parameters passed to the function.
 * \see matching_signature()
 */
static parameter_list_match_t
d93 1
a93 4

   /* This is set to true if there is an inexact match requiring an implicit
    * conversion. */
   bool inexact_match = false;
d103 1
a103 1
	 return PARAMETER_LIST_NO_MATCH;
d107 1
a107 1
      const ir_rvalue *const actual = (ir_rvalue *) node_b;
d109 6
a114 5
      if (param->type == actual->type)
	 continue;

      /* Try to find an implicit conversion from actual to param. */
      inexact_match = true;
d124 1
a124 1
	 return PARAMETER_LIST_NO_MATCH;
d126 2
a127 4
      case ir_var_const_in:
      case ir_var_function_in:
	 if (!actual->type->can_implicitly_convert_to(param->type))
	    return PARAMETER_LIST_NO_MATCH;
d130 2
a131 3
      case ir_var_function_out:
	 if (!param->type->can_implicitly_convert_to(actual->type))
	    return PARAMETER_LIST_NO_MATCH;
d134 1
a134 1
      case ir_var_function_inout:
d139 2
a140 1
	 return PARAMETER_LIST_NO_MATCH;
a143 1
	 return PARAMETER_LIST_NO_MATCH;
d145 5
d157 1
a157 1
      return PARAMETER_LIST_NO_MATCH;
d159 1
a159 4
   if (inexact_match)
      return PARAMETER_LIST_INEXACT_MATCH;
   else
      return PARAMETER_LIST_EXACT_MATCH;
a165 8
   bool is_exact;
   return matching_signature(actual_parameters, &is_exact);
}

ir_function_signature *
ir_function::matching_signature(const exec_list *actual_parameters,
			        bool *is_exact)
{
a166 1
   bool multiple_inexact_matches = false;
a167 10
   /* From page 42 (page 49 of the PDF) of the GLSL 1.20 spec:
    *
    * "If an exact match is found, the other signatures are ignored, and
    *  the exact match is used.  Otherwise, if no exact match is found, then
    *  the implicit conversions in Section 4.1.10 "Implicit Conversions" will
    *  be applied to the calling arguments if this can make their types match
    *  a signature.  In this case, it is a semantic error if there are
    *  multiple ways to apply these conversions to the actual arguments of a
    *  call such that the call can be made to match multiple signatures."
    */
d172 4
a175 3
      switch (parameter_lists_match(& sig->parameters, actual_parameters)) {
      case PARAMETER_LIST_EXACT_MATCH:
	 *is_exact = true;
d177 6
a182 11
      case PARAMETER_LIST_INEXACT_MATCH:
	 if (match == NULL)
	    match = sig;
	 else
	    multiple_inexact_matches = true;
	 continue;
      case PARAMETER_LIST_NO_MATCH:
	 continue;
      default:
	 assert(false);
	 return NULL;
a184 12

   /* There is no exact match (we would have returned it by now).  If there
    * are multiple inexact matches, the call is ambiguous, which is an error.
    *
    * FINISHME: Report a decent error.  Returning NULL will likely result in
    * FINISHME: a "no matching signature" error; it should report that the
    * FINISHME: call is ambiguous.  But reporting errors from here is hard.
    */
   *is_exact = false;

   if (multiple_inexact_matches)
      return NULL;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d69 1
a69 1
      switch ((enum ir_variable_mode)(param->data.mode)) {
d119 1
a119 2
ir_function::matching_signature(_mesa_glsl_parse_state *state,
                                const exec_list *actual_parameters)
d122 1
a122 1
   return matching_signature(state, actual_parameters, &is_exact);
d126 1
a126 2
ir_function::matching_signature(_mesa_glsl_parse_state *state,
                                const exec_list *actual_parameters,
d142 3
a144 6
   foreach_list(n, &this->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;

      /* Skip over any built-ins that aren't available in this shader. */
      if (sig->is_builtin() && !sig->is_builtin_available(state))
         continue;
d206 1
a206 2
ir_function::exact_matching_signature(_mesa_glsl_parse_state *state,
                                      const exec_list *actual_parameters)
d208 3
a210 6
   foreach_list(n, &this->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;

      /* Skip over any built-ins that aren't available in this shader. */
      if (sig->is_builtin() && !sig->is_builtin_available(state))
         continue;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a25 2
#include "glsl_parser_extras.h"
#include "main/errors.h"
d41 1
a41 2
parameter_lists_match(_mesa_glsl_parse_state *state,
                      const exec_list *list_a, const exec_list *list_b)
d82 1
a82 1
	 if (!actual->type->can_implicitly_convert_to(param->type, state))
d87 1
a87 1
	 if (!param->type->can_implicitly_convert_to(actual->type, state))
a117 162
/* Classes of parameter match, sorted (mostly) best matches first.
 * See is_better_parameter_match() below for the exceptions.
 * */
typedef enum {
   PARAMETER_EXACT_MATCH,
   PARAMETER_FLOAT_TO_DOUBLE,
   PARAMETER_INT_TO_FLOAT,
   PARAMETER_INT_TO_DOUBLE,
   PARAMETER_OTHER_CONVERSION,
} parameter_match_t;


static parameter_match_t
get_parameter_match_type(const ir_variable *param,
                         const ir_rvalue *actual)
{
   const glsl_type *from_type;
   const glsl_type *to_type;

   if (param->data.mode == ir_var_function_out) {
      from_type = param->type;
      to_type = actual->type;
   } else {
      from_type = actual->type;
      to_type = param->type;
   }

   if (from_type == to_type)
      return PARAMETER_EXACT_MATCH;

   /* XXX: When ARB_gpu_shader_fp64 support is added, check for float->double,
    * and int/uint->double conversions
    */

   if (to_type->base_type == GLSL_TYPE_FLOAT)
      return PARAMETER_INT_TO_FLOAT;

   /* int -> uint and any other oddball conversions */
   return PARAMETER_OTHER_CONVERSION;
}


static bool
is_better_parameter_match(parameter_match_t a_match,
                          parameter_match_t b_match)
{
   /* From section 6.1 of the GLSL 4.00 spec (and the ARB_gpu_shader5 spec):
    *
    * 1. An exact match is better than a match involving any implicit
    * conversion.
    *
    * 2. A match involving an implicit conversion from float to double
    * is better than match involving any other implicit conversion.
    *
    * [XXX: Not in GLSL 4.0: Only in ARB_gpu_shader5:
    * 3. A match involving an implicit conversion from either int or uint
    * to float is better than a match involving an implicit conversion
    * from either int or uint to double.]
    *
    * If none of the rules above apply to a particular pair of conversions,
    * neither conversion is considered better than the other.
    *
    * --
    *
    * Notably, the int->uint conversion is *not* considered to be better
    * or worse than int/uint->float or int/uint->double.
    */

   if (a_match >= PARAMETER_INT_TO_FLOAT && b_match == PARAMETER_OTHER_CONVERSION)
      return false;

   return a_match < b_match;
}


static bool
is_best_inexact_overload(const exec_list *actual_parameters,
                         ir_function_signature **matches,
                         int num_matches,
                         ir_function_signature *sig)
{
   /* From section 6.1 of the GLSL 4.00 spec (and the ARB_gpu_shader5 spec):
    *
    * "A function definition A is considered a better
    * match than function definition B if:
    *
    *   * for at least one function argument, the conversion for that argument
    *     in A is better than the corresponding conversion in B; and
    *
    *   * there is no function argument for which the conversion in B is better
    *     than the corresponding conversion in A.
    *
    * If a single function definition is considered a better match than every
    * other matching function definition, it will be used.  Otherwise, a
    * semantic error occurs and the shader will fail to compile."
    */
   for (ir_function_signature **other = matches;
        other < matches + num_matches; other++) {
      if (*other == sig)
         continue;

      const exec_node *node_a = sig->parameters.head;
      const exec_node *node_b = (*other)->parameters.head;
      const exec_node *node_p = actual_parameters->head;

      bool better_for_some_parameter = false;

      for (/* empty */
           ; !node_a->is_tail_sentinel()
           ; node_a = node_a->next,
             node_b = node_b->next,
             node_p = node_p->next) {
         parameter_match_t a_match = get_parameter_match_type(
               (const ir_variable *)node_a,
               (const ir_rvalue *)node_p);
         parameter_match_t b_match = get_parameter_match_type(
               (const ir_variable *)node_b,
               (const ir_rvalue *)node_p);

         if (is_better_parameter_match(a_match, b_match))
               better_for_some_parameter = true;

         if (is_better_parameter_match(b_match, a_match))
               return false;     /* B is better for this parameter */
      }

      if (!better_for_some_parameter)
         return false;     /* A must be better than B for some parameter */

   }

   return true;
}


static ir_function_signature *
choose_best_inexact_overload(_mesa_glsl_parse_state *state,
                             const exec_list *actual_parameters,
                             ir_function_signature **matches,
                             int num_matches)
{
   if (num_matches == 0)
      return NULL;

   if (num_matches == 1)
      return *matches;

   /* Without GLSL 4.0 / ARB_gpu_shader5, there is no overload resolution
    * among multiple inexact matches. Note that state may be NULL here if
    * called from the linker; in that case we assume everything supported in
    * any GLSL version is available. */
   if (!state || state->is_version(400, 0) || state->ARB_gpu_shader5_enable) {
      for (ir_function_signature **sig = matches; sig < matches + num_matches; sig++) {
         if (is_best_inexact_overload(actual_parameters, matches, num_matches, *sig))
            return *sig;
      }
   }

   return NULL;   /* no best candidate */
}


d120 1
a120 2
                                const exec_list *actual_parameters,
                                bool allow_builtins)
d123 1
a123 2
   return matching_signature(state, actual_parameters, allow_builtins,
                             &is_exact);
d129 1
a129 2
                                bool allow_builtins,
                                bool *is_exact)
a130 2
   ir_function_signature **inexact_matches = NULL;
   ir_function_signature **inexact_matches_temp;
d132 1
a132 1
   int num_inexact_matches = 0;
d144 3
a146 1
   foreach_in_list(ir_function_signature, sig, &this->signatures) {
d148 1
a148 2
      if (sig->is_builtin() && (!allow_builtins ||
                                !sig->is_builtin_available(state)))
d151 1
a151 1
      switch (parameter_lists_match(state, & sig->parameters, actual_parameters)) {
d153 2
a154 3
         *is_exact = true;
         free(inexact_matches);
         return sig;
d156 5
a160 12
         inexact_matches_temp = (ir_function_signature **)
               realloc(inexact_matches,
                       sizeof(*inexact_matches) *
                       (num_inexact_matches + 1));
         if (inexact_matches_temp == NULL) {
            _mesa_error_no_memory(__func__);
            free(inexact_matches);
            return NULL;
         }
         inexact_matches = inexact_matches_temp;
         inexact_matches[num_inexact_matches++] = sig;
         continue;
d178 2
a179 2
   match = choose_best_inexact_overload(state, actual_parameters,
                                        inexact_matches, num_inexact_matches);
a180 1
   free(inexact_matches);
d214 3
a216 1
   foreach_in_list(ir_function_signature, sig, &this->signatures) {
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d26 2
d43 2
a44 1
parameter_lists_match(const exec_list *list_a, const exec_list *list_b)
d85 1
a85 1
	 if (!actual->type->can_implicitly_convert_to(param->type))
d90 1
a90 1
	 if (!param->type->can_implicitly_convert_to(actual->type))
d121 162
d285 2
a286 1
                                const exec_list *actual_parameters)
d289 2
a290 1
   return matching_signature(state, actual_parameters, &is_exact);
d296 2
a297 1
			        bool *is_exact)
d299 2
d302 1
a302 1
   bool multiple_inexact_matches = false;
d314 1
a314 3
   foreach_list(n, &this->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;

d316 2
a317 1
      if (sig->is_builtin() && !sig->is_builtin_available(state))
d320 1
a320 1
      switch (parameter_lists_match(& sig->parameters, actual_parameters)) {
d322 3
a324 2
	 *is_exact = true;
	 return sig;
d326 12
a337 5
	 if (match == NULL)
	    match = sig;
	 else
	    multiple_inexact_matches = true;
	 continue;
d355 2
a356 2
   if (multiple_inexact_matches)
      return NULL;
d358 1
d392 1
a392 3
   foreach_list(n, &this->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;

@


