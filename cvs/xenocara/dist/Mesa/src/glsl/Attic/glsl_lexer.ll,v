head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.02.25;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.14.12;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.27;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.10.17;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.47.24;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@%{
/*
 * Copyright Â© 2008, 2009 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include <ctype.h>
#include <limits.h>
#include "strtod.h"
#include "ast.h"
#include "glsl_parser_extras.h"
#include "glsl_parser.h"

static int classify_identifier(struct _mesa_glsl_parse_state *, const char *);

#ifdef _MSC_VER
#define YY_NO_UNISTD_H
#endif

#define YY_USER_ACTION						\
   do {								\
      yylloc->source = 0;					\
      yylloc->first_column = yycolumn + 1;			\
      yylloc->first_line = yylloc->last_line = yylineno + 1;	\
      yycolumn += yyleng;					\
      yylloc->last_column = yycolumn + 1;			\
   } while(0);

#define YY_USER_INIT yylineno = 0; yycolumn = 0;

/* A macro for handling reserved words and keywords across language versions.
 *
 * Certain words start out as identifiers, become reserved words in
 * later language revisions, and finally become language keywords.
 * This may happen at different times in desktop GLSL and GLSL ES.
 *
 * For example, consider the following lexer rule:
 * samplerBuffer       KEYWORD(130, 0, 140, 0, SAMPLERBUFFER)
 *
 * This means that "samplerBuffer" will be treated as:
 * - a keyword (SAMPLERBUFFER token)         ...in GLSL >= 1.40
 * - a reserved word - error                 ...in GLSL >= 1.30
 * - an identifier                           ...in GLSL <  1.30 or GLSL ES
 */
#define KEYWORD(reserved_glsl, reserved_glsl_es,			\
                allowed_glsl, allowed_glsl_es, token)			\
   KEYWORD_WITH_ALT(reserved_glsl, reserved_glsl_es,			\
                    allowed_glsl, allowed_glsl_es, false, token)

/**
 * Like the KEYWORD macro, but the word is also treated as a keyword
 * if the given boolean expression is true.
 */
#define KEYWORD_WITH_ALT(reserved_glsl, reserved_glsl_es,		\
                         allowed_glsl, allowed_glsl_es,			\
                         alt_expr, token)				\
   do {									\
      if (yyextra->is_version(allowed_glsl, allowed_glsl_es)		\
          || (alt_expr)) {						\
	 return token;							\
      } else if (yyextra->is_version(reserved_glsl,			\
                                     reserved_glsl_es)) {		\
	 _mesa_glsl_error(yylloc, yyextra,				\
			  "illegal use of reserved word `%s'", yytext);	\
	 return ERROR_TOK;						\
      } else {								\
	 yylval->identifier = strdup(yytext);				\
	 return classify_identifier(yyextra, yytext);			\
      }									\
   } while (0)

/**
 * A macro for handling keywords that have been present in GLSL since
 * its origin, but were changed into reserved words in GLSL 3.00 ES.
 */
#define DEPRECATED_ES_KEYWORD(token)					\
   do {									\
      if (yyextra->is_version(0, 300)) {				\
	 _mesa_glsl_error(yylloc, yyextra,				\
			  "illegal use of reserved word `%s'", yytext);	\
	 return ERROR_TOK;						\
      } else {								\
         return token;							\
      }									\
   } while (0)

static int
literal_integer(char *text, int len, struct _mesa_glsl_parse_state *state,
		YYSTYPE *lval, YYLTYPE *lloc, int base)
{
   bool is_uint = (text[len - 1] == 'u' ||
		   text[len - 1] == 'U');
   const char *digits = text;

   /* Skip "0x" */
   if (base == 16)
      digits += 2;

#ifdef _MSC_VER
   unsigned __int64 value = _strtoui64(digits, NULL, base);
#else
   unsigned long long value = strtoull(digits, NULL, base);
#endif

   lval->n = (int)value;

   if (value > UINT_MAX) {
      /* Note that signed 0xffffffff is valid, not out of range! */
      if (state->is_version(130, 300)) {
	 _mesa_glsl_error(lloc, state,
			  "literal value `%s' out of range", text);
      } else {
	 _mesa_glsl_warning(lloc, state,
			    "literal value `%s' out of range", text);
      }
   } else if (base == 10 && !is_uint && (unsigned)value > (unsigned)INT_MAX + 1) {
      /* Tries to catch unintentionally providing a negative value.
       * Note that -2147483648 is parsed as -(2147483648), so we don't
       * want to warn for INT_MAX.
       */
      _mesa_glsl_warning(lloc, state,
			 "signed literal value `%s' is interpreted as %d",
			 text, lval->n);
   }
   return is_uint ? UINTCONSTANT : INTCONSTANT;
}

#define LITERAL_INTEGER(base) \
   literal_integer(yytext, yyleng, yyextra, yylval, yylloc, base)

%}

%option bison-bridge bison-locations reentrant noyywrap
%option nounput noyy_top_state
%option never-interactive
%option prefix="_mesa_glsl_lexer_"
%option extra-type="struct _mesa_glsl_parse_state *"

%x PP PRAGMA

DEC_INT		[1-9][0-9]*
HEX_INT		0[xX][0-9a-fA-F]+
OCT_INT		0[0-7]*
INT		({DEC_INT}|{HEX_INT}|{OCT_INT})
SPC		[ \t]*
SPCP		[ \t]+
HASH		^{SPC}#{SPC}
%%

[ \r\t]+		;

    /* Preprocessor tokens. */ 
^[ \t]*#[ \t]*$			;
^[ \t]*#[ \t]*version		{ BEGIN PP; return VERSION_TOK; }
^[ \t]*#[ \t]*extension		{ BEGIN PP; return EXTENSION; }
{HASH}line{SPCP}{INT}{SPCP}{INT}{SPC}$ {
				   /* Eat characters until the first digit is
				    * encountered
				    */
				   char *ptr = yytext;
				   while (!isdigit(*ptr))
				      ptr++;

				   /* Subtract one from the line number because
				    * yylineno is zero-based instead of
				    * one-based.
				    */
				   yylineno = strtol(ptr, &ptr, 0) - 1;
				   yylloc->source = strtol(ptr, NULL, 0);
				}
{HASH}line{SPCP}{INT}{SPC}$	{
				   /* Eat characters until the first digit is
				    * encountered
				    */
				   char *ptr = yytext;
				   while (!isdigit(*ptr))
				      ptr++;

				   /* Subtract one from the line number because
				    * yylineno is zero-based instead of
				    * one-based.
				    */
				   yylineno = strtol(ptr, &ptr, 0) - 1;
				}
^{SPC}#{SPC}pragma{SPCP}debug{SPC}\({SPC}on{SPC}\) {
				  BEGIN PP;
				  return PRAGMA_DEBUG_ON;
				}
^{SPC}#{SPC}pragma{SPCP}debug{SPC}\({SPC}off{SPC}\) {
				  BEGIN PP;
				  return PRAGMA_DEBUG_OFF;
				}
^{SPC}#{SPC}pragma{SPCP}optimize{SPC}\({SPC}on{SPC}\) {
				  BEGIN PP;
				  return PRAGMA_OPTIMIZE_ON;
				}
^{SPC}#{SPC}pragma{SPCP}optimize{SPC}\({SPC}off{SPC}\) {
				  BEGIN PP;
				  return PRAGMA_OPTIMIZE_OFF;
				}
^{SPC}#{SPC}pragma{SPCP}STDGL{SPCP}invariant{SPC}\({SPC}all{SPC}\) {
				  BEGIN PP;
				  return PRAGMA_INVARIANT_ALL;
				}
^{SPC}#{SPC}pragma{SPCP}	{ BEGIN PRAGMA; }

<PRAGMA>\n			{ BEGIN 0; yylineno++; yycolumn = 0; }
<PRAGMA>.			{ }

<PP>\/\/[^\n]*			{ }
<PP>[ \t\r]*			{ }
<PP>:				return COLON;
<PP>[_a-zA-Z][_a-zA-Z0-9]*	{
				   yylval->identifier = strdup(yytext);
				   return IDENTIFIER;
				}
<PP>[1-9][0-9]*			{
				    yylval->n = strtol(yytext, NULL, 10);
				    return INTCONSTANT;
				}
<PP>\n				{ BEGIN 0; yylineno++; yycolumn = 0; return EOL; }

\n		{ yylineno++; yycolumn = 0; }

attribute	DEPRECATED_ES_KEYWORD(ATTRIBUTE);
const		return CONST_TOK;
bool		return BOOL_TOK;
float		return FLOAT_TOK;
int		return INT_TOK;
uint		KEYWORD(130, 300, 130, 300, UINT_TOK);

break		return BREAK;
continue	return CONTINUE;
do		return DO;
while		return WHILE;
else		return ELSE;
for		return FOR;
if		return IF;
discard		return DISCARD;
return		return RETURN;

bvec2		return BVEC2;
bvec3		return BVEC3;
bvec4		return BVEC4;
ivec2		return IVEC2;
ivec3		return IVEC3;
ivec4		return IVEC4;
uvec2		KEYWORD(130, 300, 130, 300, UVEC2);
uvec3		KEYWORD(130, 300, 130, 300, UVEC3);
uvec4		KEYWORD(130, 300, 130, 300, UVEC4);
vec2		return VEC2;
vec3		return VEC3;
vec4		return VEC4;
mat2		return MAT2X2;
mat3		return MAT3X3;
mat4		return MAT4X4;
mat2x2		KEYWORD(120, 300, 120, 300, MAT2X2);
mat2x3		KEYWORD(120, 300, 120, 300, MAT2X3);
mat2x4		KEYWORD(120, 300, 120, 300, MAT2X4);
mat3x2		KEYWORD(120, 300, 120, 300, MAT3X2);
mat3x3		KEYWORD(120, 300, 120, 300, MAT3X3);
mat3x4		KEYWORD(120, 300, 120, 300, MAT3X4);
mat4x2		KEYWORD(120, 300, 120, 300, MAT4X2);
mat4x3		KEYWORD(120, 300, 120, 300, MAT4X3);
mat4x4		KEYWORD(120, 300, 120, 300, MAT4X4);

in		return IN_TOK;
out		return OUT_TOK;
inout		return INOUT_TOK;
uniform		return UNIFORM;
varying		DEPRECATED_ES_KEYWORD(VARYING);
centroid	KEYWORD(120, 300, 120, 300, CENTROID);
invariant	KEYWORD(120, 100, 120, 100, INVARIANT);
flat		KEYWORD(130, 100, 130, 300, FLAT);
smooth		KEYWORD(130, 300, 130, 300, SMOOTH);
noperspective	KEYWORD(130, 300, 130, 0, NOPERSPECTIVE);

sampler1D	DEPRECATED_ES_KEYWORD(SAMPLER1D);
sampler2D	return SAMPLER2D;
sampler3D	return SAMPLER3D;
samplerCube	return SAMPLERCUBE;
sampler1DArray	KEYWORD(130, 300, 130, 0, SAMPLER1DARRAY);
sampler2DArray	KEYWORD(130, 300, 130, 300, SAMPLER2DARRAY);
sampler1DShadow	DEPRECATED_ES_KEYWORD(SAMPLER1DSHADOW);
sampler2DShadow	return SAMPLER2DSHADOW;
samplerCubeShadow	KEYWORD(130, 300, 130, 300, SAMPLERCUBESHADOW);
sampler1DArrayShadow	KEYWORD(130, 300, 130, 0, SAMPLER1DARRAYSHADOW);
sampler2DArrayShadow	KEYWORD(130, 300, 130, 300, SAMPLER2DARRAYSHADOW);
isampler1D		KEYWORD(130, 300, 130, 0, ISAMPLER1D);
isampler2D		KEYWORD(130, 300, 130, 300, ISAMPLER2D);
isampler3D		KEYWORD(130, 300, 130, 300, ISAMPLER3D);
isamplerCube		KEYWORD(130, 300, 130, 300, ISAMPLERCUBE);
isampler1DArray		KEYWORD(130, 300, 130, 0, ISAMPLER1DARRAY);
isampler2DArray		KEYWORD(130, 300, 130, 300, ISAMPLER2DARRAY);
usampler1D		KEYWORD(130, 300, 130, 0, USAMPLER1D);
usampler2D		KEYWORD(130, 300, 130, 300, USAMPLER2D);
usampler3D		KEYWORD(130, 300, 130, 300, USAMPLER3D);
usamplerCube		KEYWORD(130, 300, 130, 300, USAMPLERCUBE);
usampler1DArray		KEYWORD(130, 300, 130, 0, USAMPLER1DARRAY);
usampler2DArray		KEYWORD(130, 300, 130, 300, USAMPLER2DARRAY);

   /* additional keywords in ARB_texture_multisample, included in GLSL 1.50 */
   /* these are reserved but not defined in GLSL 3.00 */
sampler2DMS        KEYWORD_WITH_ALT(150, 300, 150, 0, yyextra->ARB_texture_multisample_enable, SAMPLER2DMS);
isampler2DMS       KEYWORD_WITH_ALT(150, 300, 150, 0, yyextra->ARB_texture_multisample_enable, ISAMPLER2DMS);
usampler2DMS       KEYWORD_WITH_ALT(150, 300, 150, 0, yyextra->ARB_texture_multisample_enable, USAMPLER2DMS);
sampler2DMSArray   KEYWORD_WITH_ALT(150, 300, 150, 0, yyextra->ARB_texture_multisample_enable, SAMPLER2DMSARRAY);
isampler2DMSArray  KEYWORD_WITH_ALT(150, 300, 150, 0, yyextra->ARB_texture_multisample_enable, ISAMPLER2DMSARRAY);
usampler2DMSArray  KEYWORD_WITH_ALT(150, 300, 150, 0, yyextra->ARB_texture_multisample_enable, USAMPLER2DMSARRAY);

   /* keywords available with ARB_texture_cube_map_array_enable extension on desktop GLSL */
samplerCubeArray   KEYWORD_WITH_ALT(400, 0, 400, 0, yyextra->ARB_texture_cube_map_array_enable, SAMPLERCUBEARRAY);
isamplerCubeArray KEYWORD_WITH_ALT(400, 0, 400, 0, yyextra->ARB_texture_cube_map_array_enable, ISAMPLERCUBEARRAY);
usamplerCubeArray KEYWORD_WITH_ALT(400, 0, 400, 0, yyextra->ARB_texture_cube_map_array_enable, USAMPLERCUBEARRAY);
samplerCubeArrayShadow   KEYWORD_WITH_ALT(400, 0, 400, 0, yyextra->ARB_texture_cube_map_array_enable, SAMPLERCUBEARRAYSHADOW);

samplerExternalOES		{
			  if (yyextra->OES_EGL_image_external_enable)
			     return SAMPLEREXTERNALOES;
			  else
			     return IDENTIFIER;
		}

   /* keywords available with ARB_shader_image_load_store */
image1D         KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE1D);
image2D         KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE2D);
image3D         KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE3D);
image2DRect     KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE2DRECT);
imageCube       KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGECUBE);
imageBuffer     KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGEBUFFER);
image1DArray    KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE1DARRAY);
image2DArray    KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE2DARRAY);
imageCubeArray  KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGECUBEARRAY);
image2DMS       KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE2DMS);
image2DMSArray  KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE2DMSARRAY);
iimage1D        KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE1D);
iimage2D        KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE2D);
iimage3D        KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE3D);
iimage2DRect    KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE2DRECT);
iimageCube      KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGECUBE);
iimageBuffer    KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGEBUFFER);
iimage1DArray   KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE1DARRAY);
iimage2DArray   KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE2DARRAY);
iimageCubeArray KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGECUBEARRAY);
iimage2DMS      KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE2DMS);
iimage2DMSArray KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE2DMSARRAY);
uimage1D        KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE1D);
uimage2D        KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE2D);
uimage3D        KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE3D);
uimage2DRect    KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE2DRECT);
uimageCube      KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGECUBE);
uimageBuffer    KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGEBUFFER);
uimage1DArray   KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE1DARRAY);
uimage2DArray   KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE2DARRAY);
uimageCubeArray KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGECUBEARRAY);
uimage2DMS      KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE2DMS);
uimage2DMSArray KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE2DMSARRAY);
image1DShadow           KEYWORD(130, 300, 0, 0, IMAGE1DSHADOW);
image2DShadow           KEYWORD(130, 300, 0, 0, IMAGE2DSHADOW);
image1DArrayShadow      KEYWORD(130, 300, 0, 0, IMAGE1DARRAYSHADOW);
image2DArrayShadow      KEYWORD(130, 300, 0, 0, IMAGE2DARRAYSHADOW);

coherent	KEYWORD_WITH_ALT(420, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, COHERENT);
volatile	KEYWORD_WITH_ALT(110, 100, 420, 0, yyextra->ARB_shader_image_load_store_enable, VOLATILE);
restrict	KEYWORD_WITH_ALT(420, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, RESTRICT);
readonly	KEYWORD_WITH_ALT(420, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, READONLY);
writeonly	KEYWORD_WITH_ALT(420, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, WRITEONLY);

atomic_uint     KEYWORD_WITH_ALT(420, 300, 420, 0, yyextra->ARB_shader_atomic_counters_enable, ATOMIC_UINT);

struct		return STRUCT;
void		return VOID_TOK;

layout		{
		  if ((yyextra->is_version(140, 300))
		      || yyextra->AMD_conservative_depth_enable
		      || yyextra->ARB_conservative_depth_enable
		      || yyextra->ARB_explicit_attrib_location_enable
                      || yyextra->has_separate_shader_objects()
		      || yyextra->ARB_uniform_buffer_object_enable
		      || yyextra->ARB_fragment_coord_conventions_enable
                      || yyextra->ARB_shading_language_420pack_enable
                      || yyextra->ARB_compute_shader_enable) {
		      return LAYOUT_TOK;
		   } else {
		      yylval->identifier = strdup(yytext);
		      return classify_identifier(yyextra, yytext);
		   }
		}

\+\+		return INC_OP;
--		return DEC_OP;
\<=		return LE_OP;
>=		return GE_OP;
==		return EQ_OP;
!=		return NE_OP;
&&		return AND_OP;
\|\|		return OR_OP;
"^^"		return XOR_OP;
"<<"		return LEFT_OP;
">>"		return RIGHT_OP;

\*=		return MUL_ASSIGN;
\/=		return DIV_ASSIGN;
\+=		return ADD_ASSIGN;
\%=		return MOD_ASSIGN;
\<\<=		return LEFT_ASSIGN;
>>=		return RIGHT_ASSIGN;
&=		return AND_ASSIGN;
"^="		return XOR_ASSIGN;
\|=		return OR_ASSIGN;
-=		return SUB_ASSIGN;

[1-9][0-9]*[uU]?	{
			    return LITERAL_INTEGER(10);
			}
0[xX][0-9a-fA-F]+[uU]?	{
			    return LITERAL_INTEGER(16);
			}
0[0-7]*[uU]?		{
			    return LITERAL_INTEGER(8);
			}

[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?[fF]?	{
			    yylval->real = glsl_strtof(yytext, NULL);
			    return FLOATCONSTANT;
			}
\.[0-9]+([eE][+-]?[0-9]+)?[fF]?		{
			    yylval->real = glsl_strtof(yytext, NULL);
			    return FLOATCONSTANT;
			}
[0-9]+\.([eE][+-]?[0-9]+)?[fF]?		{
			    yylval->real = glsl_strtof(yytext, NULL);
			    return FLOATCONSTANT;
			}
[0-9]+[eE][+-]?[0-9]+[fF]?		{
			    yylval->real = glsl_strtof(yytext, NULL);
			    return FLOATCONSTANT;
			}
[0-9]+[fF]		{
			    yylval->real = glsl_strtof(yytext, NULL);
			    return FLOATCONSTANT;
			}

true			{
			    yylval->n = 1;
			    return BOOLCONSTANT;
			}
false			{
			    yylval->n = 0;
			    return BOOLCONSTANT;
			}


    /* Reserved words in GLSL 1.10. */
asm		KEYWORD(110, 100, 0, 0, ASM);
class		KEYWORD(110, 100, 0, 0, CLASS);
union		KEYWORD(110, 100, 0, 0, UNION);
enum		KEYWORD(110, 100, 0, 0, ENUM);
typedef		KEYWORD(110, 100, 0, 0, TYPEDEF);
template	KEYWORD(110, 100, 0, 0, TEMPLATE);
this		KEYWORD(110, 100, 0, 0, THIS);
packed		KEYWORD_WITH_ALT(110, 100, 140, 300, yyextra->ARB_uniform_buffer_object_enable, PACKED_TOK);
goto		KEYWORD(110, 100, 0, 0, GOTO);
switch		KEYWORD(110, 100, 130, 300, SWITCH);
default		KEYWORD(110, 100, 130, 300, DEFAULT);
inline		KEYWORD(110, 100, 0, 0, INLINE_TOK);
noinline	KEYWORD(110, 100, 0, 0, NOINLINE);
public		KEYWORD(110, 100, 0, 0, PUBLIC_TOK);
static		KEYWORD(110, 100, 0, 0, STATIC);
extern		KEYWORD(110, 100, 0, 0, EXTERN);
external	KEYWORD(110, 100, 0, 0, EXTERNAL);
interface	KEYWORD(110, 100, 0, 0, INTERFACE);
long		KEYWORD(110, 100, 0, 0, LONG_TOK);
short		KEYWORD(110, 100, 0, 0, SHORT_TOK);
double		KEYWORD(110, 100, 400, 0, DOUBLE_TOK);
half		KEYWORD(110, 100, 0, 0, HALF);
fixed		KEYWORD(110, 100, 0, 0, FIXED_TOK);
unsigned	KEYWORD(110, 100, 0, 0, UNSIGNED);
input		KEYWORD(110, 100, 0, 0, INPUT_TOK);
output		KEYWORD(110, 100, 0, 0, OUTPUT);
hvec2		KEYWORD(110, 100, 0, 0, HVEC2);
hvec3		KEYWORD(110, 100, 0, 0, HVEC3);
hvec4		KEYWORD(110, 100, 0, 0, HVEC4);
dvec2		KEYWORD(110, 100, 400, 0, DVEC2);
dvec3		KEYWORD(110, 100, 400, 0, DVEC3);
dvec4		KEYWORD(110, 100, 400, 0, DVEC4);
fvec2		KEYWORD(110, 100, 0, 0, FVEC2);
fvec3		KEYWORD(110, 100, 0, 0, FVEC3);
fvec4		KEYWORD(110, 100, 0, 0, FVEC4);
sampler2DRect		DEPRECATED_ES_KEYWORD(SAMPLER2DRECT);
sampler3DRect		KEYWORD(110, 100, 0, 0, SAMPLER3DRECT);
sampler2DRectShadow	DEPRECATED_ES_KEYWORD(SAMPLER2DRECTSHADOW);
sizeof		KEYWORD(110, 100, 0, 0, SIZEOF);
cast		KEYWORD(110, 100, 0, 0, CAST);
namespace	KEYWORD(110, 100, 0, 0, NAMESPACE);
using		KEYWORD(110, 100, 0, 0, USING);

    /* Additional reserved words in GLSL 1.20. */
lowp		KEYWORD(120, 100, 130, 100, LOWP);
mediump		KEYWORD(120, 100, 130, 100, MEDIUMP);
highp		KEYWORD(120, 100, 130, 100, HIGHP);
precision	KEYWORD(120, 100, 130, 100, PRECISION);

    /* Additional reserved words in GLSL 1.30. */
case		KEYWORD(130, 300, 130, 300, CASE);
common		KEYWORD(130, 300, 0, 0, COMMON);
partition	KEYWORD(130, 300, 0, 0, PARTITION);
active		KEYWORD(130, 300, 0, 0, ACTIVE);
superp		KEYWORD(130, 100, 0, 0, SUPERP);
samplerBuffer	KEYWORD(130, 300, 140, 0, SAMPLERBUFFER);
filter		KEYWORD(130, 300, 0, 0, FILTER);
row_major	KEYWORD_WITH_ALT(130, 0, 140, 0, yyextra->ARB_uniform_buffer_object_enable && !yyextra->es_shader, ROW_MAJOR);

    /* Additional reserved words in GLSL 1.40 */
isampler2DRect	KEYWORD(140, 300, 140, 0, ISAMPLER2DRECT);
usampler2DRect	KEYWORD(140, 300, 140, 0, USAMPLER2DRECT);
isamplerBuffer	KEYWORD(140, 300, 140, 0, ISAMPLERBUFFER);
usamplerBuffer	KEYWORD(140, 300, 140, 0, USAMPLERBUFFER);

    /* Additional reserved words in GLSL ES 3.00 */
resource	KEYWORD(0, 300, 0, 0, RESOURCE);
patch		KEYWORD(0, 300, 0, 0, PATCH);
sample		KEYWORD_WITH_ALT(400, 300, 400, 0, yyextra->ARB_gpu_shader5_enable, SAMPLE);
subroutine	KEYWORD(0, 300, 0, 0, SUBROUTINE);


[_a-zA-Z][_a-zA-Z0-9]*	{
			    struct _mesa_glsl_parse_state *state = yyextra;
			    void *ctx = state;	
			    yylval->identifier = ralloc_strdup(ctx, yytext);
			    return classify_identifier(state, yytext);
			}

.			{ return yytext[0]; }

%%

int
classify_identifier(struct _mesa_glsl_parse_state *state, const char *name)
{
   if (state->symbols->get_variable(name) || state->symbols->get_function(name))
      return IDENTIFIER;
   else if (state->symbols->get_type(name))
      return TYPE_IDENTIFIER;
   else
      return NEW_IDENTIFIER;
}

void
_mesa_glsl_lexer_ctor(struct _mesa_glsl_parse_state *state, const char *string)
{
   yylex_init_extra(state, & state->scanner);
   yy_scan_string(string, state->scanner);
}

void
_mesa_glsl_lexer_dtor(struct _mesa_glsl_parse_state *state)
{
   yylex_destroy(state->scanner);
}
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d26 1
a26 1
#include "util/strtod.h"
d84 1
a84 2
	 void *mem_ctx = yyextra;					\
	 yylval->identifier = ralloc_strdup(mem_ctx, yytext);		\
a154 1
%option warn nodefault
a155 3
	/* Note: When adding any start conditions to this list, you must also
	 * update the "Internal compiler error" catch-all rule near the end of
	 * this file. */
d231 1
a231 2
				   void *mem_ctx = yyextra;
				   yylval->identifier = ralloc_strdup(mem_ctx, yytext);
a238 1
<PP>.				{ return yytext[0]; }
a340 3
   /* keywords available with ARB_gpu_shader5 */
precise		KEYWORD_WITH_ALT(400, 0, 400, 0, yyextra->ARB_gpu_shader5_enable, PRECISE);

a395 1
		      || yyextra->ARB_explicit_uniform_location_enable
d403 1
a403 2
		      void *mem_ctx = yyextra;
		      yylval->identifier = ralloc_strdup(mem_ctx, yytext);
d442 1
a442 1
			    yylval->real = _mesa_strtof(yytext, NULL);
d446 1
a446 1
			    yylval->real = _mesa_strtof(yytext, NULL);
d450 1
a450 1
			    yylval->real = _mesa_strtof(yytext, NULL);
d454 1
a454 1
			    yylval->real = _mesa_strtof(yytext, NULL);
d458 1
a458 1
			    yylval->real = _mesa_strtof(yytext, NULL);
@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d26 1
a26 1
#include "strtod.h"
d84 2
a85 1
	 yylval->identifier = strdup(yytext);				\
d156 1
d158 3
d236 2
a237 1
				   yylval->identifier = strdup(yytext);
d245 1
d348 3
d406 1
d414 2
a415 1
		      yylval->identifier = strdup(yytext);
d454 1
a454 1
			    yylval->real = glsl_strtof(yytext, NULL);
d458 1
a458 1
			    yylval->real = glsl_strtof(yytext, NULL);
d462 1
a462 1
			    yylval->real = glsl_strtof(yytext, NULL);
d466 1
a466 1
			    yylval->real = glsl_strtof(yytext, NULL);
d470 1
a470 1
			    yylval->real = glsl_strtof(yytext, NULL);
@


1.2
log
@Merge Mesa 9.2.0
@
text
@d41 1
a41 1
      yylloc->first_line = yylineno + 1;			\
d43 1
d81 1
a81 1
			  "Illegal use of reserved word `%s'", yytext);	\
d97 1
a97 1
			  "Illegal use of reserved word `%s'", yytext);	\
d128 1
a128 1
			  "Literal value `%s' out of range", text);
d131 1
a131 1
			    "Literal value `%s' out of range", text);
d139 1
a139 1
			 "Signed literal value `%s' is interpreted as %d",
d341 46
d396 1
d399 2
a400 1
                      || yyextra->ARB_shading_language_420pack_enable) {
a485 1
volatile	KEYWORD(110, 100, 0, 0, VOLATILE);
a529 25
image1D		KEYWORD(130, 300, 0, 0, IMAGE1D);
image2D		KEYWORD(130, 300, 0, 0, IMAGE2D);
image3D		KEYWORD(130, 300, 0, 0, IMAGE3D);
imageCube	KEYWORD(130, 300, 0, 0, IMAGECUBE);
iimage1D	KEYWORD(130, 300, 0, 0, IIMAGE1D);
iimage2D	KEYWORD(130, 300, 0, 0, IIMAGE2D);
iimage3D	KEYWORD(130, 300, 0, 0, IIMAGE3D);
iimageCube	KEYWORD(130, 300, 0, 0, IIMAGECUBE);
uimage1D	KEYWORD(130, 300, 0, 0, UIMAGE1D);
uimage2D	KEYWORD(130, 300, 0, 0, UIMAGE2D);
uimage3D	KEYWORD(130, 300, 0, 0, UIMAGE3D);
uimageCube	KEYWORD(130, 300, 0, 0, UIMAGECUBE);
image1DArray	KEYWORD(130, 300, 0, 0, IMAGE1DARRAY);
image2DArray	KEYWORD(130, 300, 0, 0, IMAGE2DARRAY);
iimage1DArray	KEYWORD(130, 300, 0, 0, IIMAGE1DARRAY);
iimage2DArray	KEYWORD(130, 300, 0, 0, IIMAGE2DARRAY);
uimage1DArray	KEYWORD(130, 300, 0, 0, UIMAGE1DARRAY);
uimage2DArray	KEYWORD(130, 300, 0, 0, UIMAGE2DARRAY);
image1DShadow	KEYWORD(130, 300, 0, 0, IMAGE1DSHADOW);
image2DShadow	KEYWORD(130, 300, 0, 0, IMAGE2DSHADOW);
image1DArrayShadow KEYWORD(130, 300, 0, 0, IMAGE1DARRAYSHADOW);
image2DArrayShadow KEYWORD(130, 300, 0, 0, IMAGE2DARRAYSHADOW);
imageBuffer	KEYWORD(130, 300, 0, 0, IMAGEBUFFER);
iimageBuffer	KEYWORD(130, 300, 0, 0, IIMAGEBUFFER);
uimageBuffer	KEYWORD(130, 300, 0, 0, UIMAGEBUFFER);
a538 4
coherent	KEYWORD(0, 300, 0, 0, COHERENT);
restrict	KEYWORD(0, 300, 0, 0, RESTRICT);
readonly	KEYWORD(0, 300, 0, 0, READONLY);
writeonly	KEYWORD(0, 300, 0, 0, WRITEONLY);
a539 1
atomic_uint	KEYWORD(0, 300, 0, 0, ATOMIC_UINT);
d541 1
a541 1
sample		KEYWORD(0, 300, 0, 0, SAMPLE);
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d25 1
a46 2
#define IS_UINT (yytext[yyleng - 1] == 'u' || yytext[yyleng - 1] == 'U')

d51 1
d54 1
a54 1
 * samplerBuffer       KEYWORD(130, 140, SAMPLERBUFFER)
d59 10
a68 1
 * - an identifier                           ...in GLSL <  1.30
d70 3
a72 1
#define KEYWORD(reserved_version, allowed_version, token)		\
d74 2
a75 1
      if (yyextra->language_version >= allowed_version) {		\
d77 2
a78 1
      } else if (yyextra->language_version >= reserved_version) {	\
d88 3
a90 7
/* The ES macro can be used in KEYWORD checks:
 *
 *    word      KEYWORD(110 || ES, 400, TOKEN)
 * ...means the word is reserved in GLSL ES 1.00, while
 *
 *    word      KEYWORD(110, 130 || ES, TOKEN)
 * ...means the word is a legal keyword in GLSL ES 1.00.
d92 55
a146 1
#define ES yyextra->es_shader
d152 1
a152 1
%option prefix="_mesa_glsl_"
d170 1
a170 1
^[ \t]*#[ \t]*version		{ BEGIN PP; return VERSION; }
d241 1
a241 1
attribute	return ATTRIBUTE;
d246 1
a246 1
uint		KEYWORD(130, 130, UINT_TOK);
d264 3
a266 3
uvec2		KEYWORD(130, 130, UVEC2);
uvec3		KEYWORD(130, 130, UVEC3);
uvec4		KEYWORD(130, 130, UVEC4);
d273 9
a281 9
mat2x2		KEYWORD(120, 120, MAT2X2);
mat2x3		KEYWORD(120, 120, MAT2X3);
mat2x4		KEYWORD(120, 120, MAT2X4);
mat3x2		KEYWORD(120, 120, MAT3X2);
mat3x3		KEYWORD(120, 120, MAT3X3);
mat3x4		KEYWORD(120, 120, MAT3X4);
mat4x2		KEYWORD(120, 120, MAT4X2);
mat4x3		KEYWORD(120, 120, MAT4X3);
mat4x4		KEYWORD(120, 120, MAT4X4);
d287 6
a292 6
varying		return VARYING;
centroid	KEYWORD(120, 120, CENTROID);
invariant	KEYWORD(120 || ES, 120 || ES, INVARIANT);
flat		KEYWORD(130 || ES, 130, FLAT);
smooth		KEYWORD(130, 130, SMOOTH);
noperspective	KEYWORD(130, 130, NOPERSPECTIVE);
d294 1
a294 1
sampler1D	return SAMPLER1D;
d298 3
a300 3
sampler1DArray	KEYWORD(130, 130, SAMPLER1DARRAY);
sampler2DArray	KEYWORD(130, 130, SAMPLER2DARRAY);
sampler1DShadow	return SAMPLER1DSHADOW;
d302 37
a338 15
samplerCubeShadow	KEYWORD(130, 130, SAMPLERCUBESHADOW);
sampler1DArrayShadow	KEYWORD(130, 130, SAMPLER1DARRAYSHADOW);
sampler2DArrayShadow	KEYWORD(130, 130, SAMPLER2DARRAYSHADOW);
isampler1D		KEYWORD(130, 130, ISAMPLER1D);
isampler2D		KEYWORD(130, 130, ISAMPLER2D);
isampler3D		KEYWORD(130, 130, ISAMPLER3D);
isamplerCube		KEYWORD(130, 130, ISAMPLERCUBE);
isampler1DArray		KEYWORD(130, 130, ISAMPLER1DARRAY);
isampler2DArray		KEYWORD(130, 130, ISAMPLER2DARRAY);
usampler1D		KEYWORD(130, 130, USAMPLER1D);
usampler2D		KEYWORD(130, 130, USAMPLER2D);
usampler3D		KEYWORD(130, 130, USAMPLER3D);
usamplerCube		KEYWORD(130, 130, USAMPLERCUBE);
usampler1DArray		KEYWORD(130, 130, USAMPLER1DARRAY);
usampler2DArray		KEYWORD(130, 130, USAMPLER2DARRAY);
d345 1
a345 1
		  if ((yyextra->language_version >= 140)
d347 1
d349 3
a351 1
		      || yyextra->ARB_fragment_coord_conventions_enable) {
d355 1
a355 1
		      return IDENTIFIER;
d383 1
a383 2
			    yylval->n = strtol(yytext, NULL, 10);
			    return IS_UINT ? UINTCONSTANT : INTCONSTANT;
d386 1
a386 2
			    yylval->n = strtol(yytext + 2, NULL, 16);
			    return IS_UINT ? UINTCONSTANT : INTCONSTANT;
d389 1
a389 2
			    yylval->n = strtol(yytext, NULL, 8);
			    return IS_UINT ? UINTCONSTANT : INTCONSTANT;
d393 1
a393 1
			    yylval->real = glsl_strtod(yytext, NULL);
d397 1
a397 1
			    yylval->real = glsl_strtod(yytext, NULL);
d401 1
a401 1
			    yylval->real = glsl_strtod(yytext, NULL);
d405 1
a405 1
			    yylval->real = glsl_strtod(yytext, NULL);
d409 1
a409 1
			    yylval->real = glsl_strtod(yytext, NULL);
d424 43
a466 43
asm		KEYWORD(110 || ES, 999, ASM);
class		KEYWORD(110 || ES, 999, CLASS);
union		KEYWORD(110 || ES, 999, UNION);
enum		KEYWORD(110 || ES, 999, ENUM);
typedef		KEYWORD(110 || ES, 999, TYPEDEF);
template	KEYWORD(110 || ES, 999, TEMPLATE);
this		KEYWORD(110 || ES, 999, THIS);
packed		KEYWORD(110 || ES, 999, PACKED_TOK);
goto		KEYWORD(110 || ES, 999, GOTO);
switch		KEYWORD(110 || ES, 130, SWITCH);
default		KEYWORD(110 || ES, 130, DEFAULT);
inline		KEYWORD(110 || ES, 999, INLINE_TOK);
noinline	KEYWORD(110 || ES, 999, NOINLINE);
volatile	KEYWORD(110 || ES, 999, VOLATILE);
public		KEYWORD(110 || ES, 999, PUBLIC_TOK);
static		KEYWORD(110 || ES, 999, STATIC);
extern		KEYWORD(110 || ES, 999, EXTERN);
external	KEYWORD(110 || ES, 999, EXTERNAL);
interface	KEYWORD(110 || ES, 999, INTERFACE);
long		KEYWORD(110 || ES, 999, LONG_TOK);
short		KEYWORD(110 || ES, 999, SHORT_TOK);
double		KEYWORD(110 || ES, 400, DOUBLE_TOK);
half		KEYWORD(110 || ES, 999, HALF);
fixed		KEYWORD(110 || ES, 999, FIXED_TOK);
unsigned	KEYWORD(110 || ES, 999, UNSIGNED);
input		KEYWORD(110 || ES, 999, INPUT_TOK);
output		KEYWORD(110 || ES, 999, OUTPUT);
hvec2		KEYWORD(110 || ES, 999, HVEC2);
hvec3		KEYWORD(110 || ES, 999, HVEC3);
hvec4		KEYWORD(110 || ES, 999, HVEC4);
dvec2		KEYWORD(110 || ES, 400, DVEC2);
dvec3		KEYWORD(110 || ES, 400, DVEC3);
dvec4		KEYWORD(110 || ES, 400, DVEC4);
fvec2		KEYWORD(110 || ES, 999, FVEC2);
fvec3		KEYWORD(110 || ES, 999, FVEC3);
fvec4		KEYWORD(110 || ES, 999, FVEC4);
sampler2DRect		return SAMPLER2DRECT;
sampler3DRect		KEYWORD(110 || ES, 999, SAMPLER3DRECT);
sampler2DRectShadow	return SAMPLER2DRECTSHADOW;
sizeof		KEYWORD(110 || ES, 999, SIZEOF);
cast		KEYWORD(110 || ES, 999, CAST);
namespace	KEYWORD(110 || ES, 999, NAMESPACE);
using		KEYWORD(110 || ES, 999, USING);
d469 4
a472 4
lowp		KEYWORD(120, 130 || ES, LOWP);
mediump		KEYWORD(120, 130 || ES, MEDIUMP);
highp		KEYWORD(120, 130 || ES, HIGHP);
precision	KEYWORD(120, 130 || ES, PRECISION);
d475 51
a525 33
case		KEYWORD(130, 130, CASE);
common		KEYWORD(130, 999, COMMON);
partition	KEYWORD(130, 999, PARTITION);
active		KEYWORD(130, 999, ACTIVE);
superp		KEYWORD(130 || ES, 999, SUPERP);
samplerBuffer	KEYWORD(130, 140, SAMPLERBUFFER);
filter		KEYWORD(130, 999, FILTER);
image1D		KEYWORD(130, 999, IMAGE1D);
image2D		KEYWORD(130, 999, IMAGE2D);
image3D		KEYWORD(130, 999, IMAGE3D);
imageCube	KEYWORD(130, 999, IMAGECUBE);
iimage1D	KEYWORD(130, 999, IIMAGE1D);
iimage2D	KEYWORD(130, 999, IIMAGE2D);
iimage3D	KEYWORD(130, 999, IIMAGE3D);
iimageCube	KEYWORD(130, 999, IIMAGECUBE);
uimage1D	KEYWORD(130, 999, UIMAGE1D);
uimage2D	KEYWORD(130, 999, UIMAGE2D);
uimage3D	KEYWORD(130, 999, UIMAGE3D);
uimageCube	KEYWORD(130, 999, UIMAGECUBE);
image1DArray	KEYWORD(130, 999, IMAGE1DARRAY);
image2DArray	KEYWORD(130, 999, IMAGE2DARRAY);
iimage1DArray	KEYWORD(130, 999, IIMAGE1DARRAY);
iimage2DArray	KEYWORD(130, 999, IIMAGE2DARRAY);
uimage1DArray	KEYWORD(130, 999, UIMAGE1DARRAY);
uimage2DArray	KEYWORD(130, 999, UIMAGE2DARRAY);
image1DShadow	KEYWORD(130, 999, IMAGE1DSHADOW);
image2DShadow	KEYWORD(130, 999, IMAGE2DSHADOW);
image1DArrayShadow KEYWORD(130, 999, IMAGE1DARRAYSHADOW);
image2DArrayShadow KEYWORD(130, 999, IMAGE2DARRAYSHADOW);
imageBuffer	KEYWORD(130, 999, IMAGEBUFFER);
iimageBuffer	KEYWORD(130, 999, IIMAGEBUFFER);
uimageBuffer	KEYWORD(130, 999, UIMAGEBUFFER);
row_major	KEYWORD(130, 999, ROW_MAJOR);
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@a24 1
#include <limits.h>
d46 2
a51 1
 * This may happen at different times in desktop GLSL and GLSL ES.
d54 1
a54 1
 * samplerBuffer       KEYWORD(130, 0, 140, 0, SAMPLERBUFFER)
d59 1
a59 10
 * - an identifier                           ...in GLSL <  1.30 or GLSL ES
 */
#define KEYWORD(reserved_glsl, reserved_glsl_es,			\
                allowed_glsl, allowed_glsl_es, token)			\
   KEYWORD_WITH_ALT(reserved_glsl, reserved_glsl_es,			\
                    allowed_glsl, allowed_glsl_es, false, token)

/**
 * Like the KEYWORD macro, but the word is also treated as a keyword
 * if the given boolean expression is true.
d61 1
a61 3
#define KEYWORD_WITH_ALT(reserved_glsl, reserved_glsl_es,		\
                         allowed_glsl, allowed_glsl_es,			\
                         alt_expr, token)				\
d63 1
a63 2
      if (yyextra->is_version(allowed_glsl, allowed_glsl_es)		\
          || (alt_expr)) {						\
d65 1
a65 2
      } else if (yyextra->is_version(reserved_glsl,			\
                                     reserved_glsl_es)) {		\
d75 7
a81 3
/**
 * A macro for handling keywords that have been present in GLSL since
 * its origin, but were changed into reserved words in GLSL 3.00 ES.
d83 1
a83 55
#define DEPRECATED_ES_KEYWORD(token)					\
   do {									\
      if (yyextra->is_version(0, 300)) {				\
	 _mesa_glsl_error(yylloc, yyextra,				\
			  "Illegal use of reserved word `%s'", yytext);	\
	 return ERROR_TOK;						\
      } else {								\
         return token;							\
      }									\
   } while (0)

static int
literal_integer(char *text, int len, struct _mesa_glsl_parse_state *state,
		YYSTYPE *lval, YYLTYPE *lloc, int base)
{
   bool is_uint = (text[len - 1] == 'u' ||
		   text[len - 1] == 'U');
   const char *digits = text;

   /* Skip "0x" */
   if (base == 16)
      digits += 2;

#ifdef _MSC_VER
   unsigned __int64 value = _strtoui64(digits, NULL, base);
#else
   unsigned long long value = strtoull(digits, NULL, base);
#endif

   lval->n = (int)value;

   if (value > UINT_MAX) {
      /* Note that signed 0xffffffff is valid, not out of range! */
      if (state->is_version(130, 300)) {
	 _mesa_glsl_error(lloc, state,
			  "Literal value `%s' out of range", text);
      } else {
	 _mesa_glsl_warning(lloc, state,
			    "Literal value `%s' out of range", text);
      }
   } else if (base == 10 && !is_uint && (unsigned)value > (unsigned)INT_MAX + 1) {
      /* Tries to catch unintentionally providing a negative value.
       * Note that -2147483648 is parsed as -(2147483648), so we don't
       * want to warn for INT_MAX.
       */
      _mesa_glsl_warning(lloc, state,
			 "Signed literal value `%s' is interpreted as %d",
			 text, lval->n);
   }
   return is_uint ? UINTCONSTANT : INTCONSTANT;
}

#define LITERAL_INTEGER(base) \
   literal_integer(yytext, yyleng, yyextra, yylval, yylloc, base)

d89 1
a89 1
%option prefix="_mesa_glsl_lexer_"
d107 1
a107 1
^[ \t]*#[ \t]*version		{ BEGIN PP; return VERSION_TOK; }
d178 1
a178 1
attribute	DEPRECATED_ES_KEYWORD(ATTRIBUTE);
d183 1
a183 1
uint		KEYWORD(130, 300, 130, 300, UINT_TOK);
d201 3
a203 3
uvec2		KEYWORD(130, 300, 130, 300, UVEC2);
uvec3		KEYWORD(130, 300, 130, 300, UVEC3);
uvec4		KEYWORD(130, 300, 130, 300, UVEC4);
d210 9
a218 9
mat2x2		KEYWORD(120, 300, 120, 300, MAT2X2);
mat2x3		KEYWORD(120, 300, 120, 300, MAT2X3);
mat2x4		KEYWORD(120, 300, 120, 300, MAT2X4);
mat3x2		KEYWORD(120, 300, 120, 300, MAT3X2);
mat3x3		KEYWORD(120, 300, 120, 300, MAT3X3);
mat3x4		KEYWORD(120, 300, 120, 300, MAT3X4);
mat4x2		KEYWORD(120, 300, 120, 300, MAT4X2);
mat4x3		KEYWORD(120, 300, 120, 300, MAT4X3);
mat4x4		KEYWORD(120, 300, 120, 300, MAT4X4);
d224 6
a229 6
varying		DEPRECATED_ES_KEYWORD(VARYING);
centroid	KEYWORD(120, 300, 120, 300, CENTROID);
invariant	KEYWORD(120, 100, 120, 100, INVARIANT);
flat		KEYWORD(130, 100, 130, 300, FLAT);
smooth		KEYWORD(130, 300, 130, 300, SMOOTH);
noperspective	KEYWORD(130, 300, 130, 0, NOPERSPECTIVE);
d231 1
a231 1
sampler1D	DEPRECATED_ES_KEYWORD(SAMPLER1D);
d235 3
a237 3
sampler1DArray	KEYWORD(130, 300, 130, 0, SAMPLER1DARRAY);
sampler2DArray	KEYWORD(130, 300, 130, 300, SAMPLER2DARRAY);
sampler1DShadow	DEPRECATED_ES_KEYWORD(SAMPLER1DSHADOW);
d239 15
a253 37
samplerCubeShadow	KEYWORD(130, 300, 130, 300, SAMPLERCUBESHADOW);
sampler1DArrayShadow	KEYWORD(130, 300, 130, 0, SAMPLER1DARRAYSHADOW);
sampler2DArrayShadow	KEYWORD(130, 300, 130, 300, SAMPLER2DARRAYSHADOW);
isampler1D		KEYWORD(130, 300, 130, 0, ISAMPLER1D);
isampler2D		KEYWORD(130, 300, 130, 300, ISAMPLER2D);
isampler3D		KEYWORD(130, 300, 130, 300, ISAMPLER3D);
isamplerCube		KEYWORD(130, 300, 130, 300, ISAMPLERCUBE);
isampler1DArray		KEYWORD(130, 300, 130, 0, ISAMPLER1DARRAY);
isampler2DArray		KEYWORD(130, 300, 130, 300, ISAMPLER2DARRAY);
usampler1D		KEYWORD(130, 300, 130, 0, USAMPLER1D);
usampler2D		KEYWORD(130, 300, 130, 300, USAMPLER2D);
usampler3D		KEYWORD(130, 300, 130, 300, USAMPLER3D);
usamplerCube		KEYWORD(130, 300, 130, 300, USAMPLERCUBE);
usampler1DArray		KEYWORD(130, 300, 130, 0, USAMPLER1DARRAY);
usampler2DArray		KEYWORD(130, 300, 130, 300, USAMPLER2DARRAY);

   /* additional keywords in ARB_texture_multisample, included in GLSL 1.50 */
   /* these are reserved but not defined in GLSL 3.00 */
sampler2DMS        KEYWORD_WITH_ALT(150, 300, 150, 0, yyextra->ARB_texture_multisample_enable, SAMPLER2DMS);
isampler2DMS       KEYWORD_WITH_ALT(150, 300, 150, 0, yyextra->ARB_texture_multisample_enable, ISAMPLER2DMS);
usampler2DMS       KEYWORD_WITH_ALT(150, 300, 150, 0, yyextra->ARB_texture_multisample_enable, USAMPLER2DMS);
sampler2DMSArray   KEYWORD_WITH_ALT(150, 300, 150, 0, yyextra->ARB_texture_multisample_enable, SAMPLER2DMSARRAY);
isampler2DMSArray  KEYWORD_WITH_ALT(150, 300, 150, 0, yyextra->ARB_texture_multisample_enable, ISAMPLER2DMSARRAY);
usampler2DMSArray  KEYWORD_WITH_ALT(150, 300, 150, 0, yyextra->ARB_texture_multisample_enable, USAMPLER2DMSARRAY);

   /* keywords available with ARB_texture_cube_map_array_enable extension on desktop GLSL */
samplerCubeArray   KEYWORD_WITH_ALT(400, 0, 400, 0, yyextra->ARB_texture_cube_map_array_enable, SAMPLERCUBEARRAY);
isamplerCubeArray KEYWORD_WITH_ALT(400, 0, 400, 0, yyextra->ARB_texture_cube_map_array_enable, ISAMPLERCUBEARRAY);
usamplerCubeArray KEYWORD_WITH_ALT(400, 0, 400, 0, yyextra->ARB_texture_cube_map_array_enable, USAMPLERCUBEARRAY);
samplerCubeArrayShadow   KEYWORD_WITH_ALT(400, 0, 400, 0, yyextra->ARB_texture_cube_map_array_enable, SAMPLERCUBEARRAYSHADOW);

samplerExternalOES		{
			  if (yyextra->OES_EGL_image_external_enable)
			     return SAMPLEREXTERNALOES;
			  else
			     return IDENTIFIER;
		}
d260 1
a260 1
		  if ((yyextra->is_version(140, 300))
a261 1
		      || yyextra->ARB_conservative_depth_enable
d263 1
a263 3
		      || yyextra->ARB_uniform_buffer_object_enable
		      || yyextra->ARB_fragment_coord_conventions_enable
                      || yyextra->ARB_shading_language_420pack_enable) {
d267 1
a267 1
		      return classify_identifier(yyextra, yytext);
d295 2
a296 1
			    return LITERAL_INTEGER(10);
d299 2
a300 1
			    return LITERAL_INTEGER(16);
d303 2
a304 1
			    return LITERAL_INTEGER(8);
d308 1
a308 1
			    yylval->real = glsl_strtof(yytext, NULL);
d312 1
a312 1
			    yylval->real = glsl_strtof(yytext, NULL);
d316 1
a316 1
			    yylval->real = glsl_strtof(yytext, NULL);
d320 1
a320 1
			    yylval->real = glsl_strtof(yytext, NULL);
d324 1
a324 1
			    yylval->real = glsl_strtof(yytext, NULL);
d339 43
a381 43
asm		KEYWORD(110, 100, 0, 0, ASM);
class		KEYWORD(110, 100, 0, 0, CLASS);
union		KEYWORD(110, 100, 0, 0, UNION);
enum		KEYWORD(110, 100, 0, 0, ENUM);
typedef		KEYWORD(110, 100, 0, 0, TYPEDEF);
template	KEYWORD(110, 100, 0, 0, TEMPLATE);
this		KEYWORD(110, 100, 0, 0, THIS);
packed		KEYWORD_WITH_ALT(110, 100, 140, 300, yyextra->ARB_uniform_buffer_object_enable, PACKED_TOK);
goto		KEYWORD(110, 100, 0, 0, GOTO);
switch		KEYWORD(110, 100, 130, 300, SWITCH);
default		KEYWORD(110, 100, 130, 300, DEFAULT);
inline		KEYWORD(110, 100, 0, 0, INLINE_TOK);
noinline	KEYWORD(110, 100, 0, 0, NOINLINE);
volatile	KEYWORD(110, 100, 0, 0, VOLATILE);
public		KEYWORD(110, 100, 0, 0, PUBLIC_TOK);
static		KEYWORD(110, 100, 0, 0, STATIC);
extern		KEYWORD(110, 100, 0, 0, EXTERN);
external	KEYWORD(110, 100, 0, 0, EXTERNAL);
interface	KEYWORD(110, 100, 0, 0, INTERFACE);
long		KEYWORD(110, 100, 0, 0, LONG_TOK);
short		KEYWORD(110, 100, 0, 0, SHORT_TOK);
double		KEYWORD(110, 100, 400, 0, DOUBLE_TOK);
half		KEYWORD(110, 100, 0, 0, HALF);
fixed		KEYWORD(110, 100, 0, 0, FIXED_TOK);
unsigned	KEYWORD(110, 100, 0, 0, UNSIGNED);
input		KEYWORD(110, 100, 0, 0, INPUT_TOK);
output		KEYWORD(110, 100, 0, 0, OUTPUT);
hvec2		KEYWORD(110, 100, 0, 0, HVEC2);
hvec3		KEYWORD(110, 100, 0, 0, HVEC3);
hvec4		KEYWORD(110, 100, 0, 0, HVEC4);
dvec2		KEYWORD(110, 100, 400, 0, DVEC2);
dvec3		KEYWORD(110, 100, 400, 0, DVEC3);
dvec4		KEYWORD(110, 100, 400, 0, DVEC4);
fvec2		KEYWORD(110, 100, 0, 0, FVEC2);
fvec3		KEYWORD(110, 100, 0, 0, FVEC3);
fvec4		KEYWORD(110, 100, 0, 0, FVEC4);
sampler2DRect		DEPRECATED_ES_KEYWORD(SAMPLER2DRECT);
sampler3DRect		KEYWORD(110, 100, 0, 0, SAMPLER3DRECT);
sampler2DRectShadow	DEPRECATED_ES_KEYWORD(SAMPLER2DRECTSHADOW);
sizeof		KEYWORD(110, 100, 0, 0, SIZEOF);
cast		KEYWORD(110, 100, 0, 0, CAST);
namespace	KEYWORD(110, 100, 0, 0, NAMESPACE);
using		KEYWORD(110, 100, 0, 0, USING);
d384 4
a387 4
lowp		KEYWORD(120, 100, 130, 100, LOWP);
mediump		KEYWORD(120, 100, 130, 100, MEDIUMP);
highp		KEYWORD(120, 100, 130, 100, HIGHP);
precision	KEYWORD(120, 100, 130, 100, PRECISION);
d390 33
a422 51
case		KEYWORD(130, 300, 130, 300, CASE);
common		KEYWORD(130, 300, 0, 0, COMMON);
partition	KEYWORD(130, 300, 0, 0, PARTITION);
active		KEYWORD(130, 300, 0, 0, ACTIVE);
superp		KEYWORD(130, 100, 0, 0, SUPERP);
samplerBuffer	KEYWORD(130, 300, 140, 0, SAMPLERBUFFER);
filter		KEYWORD(130, 300, 0, 0, FILTER);
image1D		KEYWORD(130, 300, 0, 0, IMAGE1D);
image2D		KEYWORD(130, 300, 0, 0, IMAGE2D);
image3D		KEYWORD(130, 300, 0, 0, IMAGE3D);
imageCube	KEYWORD(130, 300, 0, 0, IMAGECUBE);
iimage1D	KEYWORD(130, 300, 0, 0, IIMAGE1D);
iimage2D	KEYWORD(130, 300, 0, 0, IIMAGE2D);
iimage3D	KEYWORD(130, 300, 0, 0, IIMAGE3D);
iimageCube	KEYWORD(130, 300, 0, 0, IIMAGECUBE);
uimage1D	KEYWORD(130, 300, 0, 0, UIMAGE1D);
uimage2D	KEYWORD(130, 300, 0, 0, UIMAGE2D);
uimage3D	KEYWORD(130, 300, 0, 0, UIMAGE3D);
uimageCube	KEYWORD(130, 300, 0, 0, UIMAGECUBE);
image1DArray	KEYWORD(130, 300, 0, 0, IMAGE1DARRAY);
image2DArray	KEYWORD(130, 300, 0, 0, IMAGE2DARRAY);
iimage1DArray	KEYWORD(130, 300, 0, 0, IIMAGE1DARRAY);
iimage2DArray	KEYWORD(130, 300, 0, 0, IIMAGE2DARRAY);
uimage1DArray	KEYWORD(130, 300, 0, 0, UIMAGE1DARRAY);
uimage2DArray	KEYWORD(130, 300, 0, 0, UIMAGE2DARRAY);
image1DShadow	KEYWORD(130, 300, 0, 0, IMAGE1DSHADOW);
image2DShadow	KEYWORD(130, 300, 0, 0, IMAGE2DSHADOW);
image1DArrayShadow KEYWORD(130, 300, 0, 0, IMAGE1DARRAYSHADOW);
image2DArrayShadow KEYWORD(130, 300, 0, 0, IMAGE2DARRAYSHADOW);
imageBuffer	KEYWORD(130, 300, 0, 0, IMAGEBUFFER);
iimageBuffer	KEYWORD(130, 300, 0, 0, IIMAGEBUFFER);
uimageBuffer	KEYWORD(130, 300, 0, 0, UIMAGEBUFFER);
row_major	KEYWORD_WITH_ALT(130, 0, 140, 0, yyextra->ARB_uniform_buffer_object_enable && !yyextra->es_shader, ROW_MAJOR);

    /* Additional reserved words in GLSL 1.40 */
isampler2DRect	KEYWORD(140, 300, 140, 0, ISAMPLER2DRECT);
usampler2DRect	KEYWORD(140, 300, 140, 0, USAMPLER2DRECT);
isamplerBuffer	KEYWORD(140, 300, 140, 0, ISAMPLERBUFFER);
usamplerBuffer	KEYWORD(140, 300, 140, 0, USAMPLERBUFFER);

    /* Additional reserved words in GLSL ES 3.00 */
coherent	KEYWORD(0, 300, 0, 0, COHERENT);
restrict	KEYWORD(0, 300, 0, 0, RESTRICT);
readonly	KEYWORD(0, 300, 0, 0, READONLY);
writeonly	KEYWORD(0, 300, 0, 0, WRITEONLY);
resource	KEYWORD(0, 300, 0, 0, RESOURCE);
atomic_uint	KEYWORD(0, 300, 0, 0, ATOMIC_UINT);
patch		KEYWORD(0, 300, 0, 0, PATCH);
sample		KEYWORD(0, 300, 0, 0, SAMPLE);
subroutine	KEYWORD(0, 300, 0, 0, SUBROUTINE);

@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d41 1
a41 1
      yylloc->first_line = yylloc->last_line = yylineno + 1;	\
a42 1
      yylloc->last_column = yycolumn + 1;			\
d80 1
a80 1
			  "illegal use of reserved word `%s'", yytext);	\
d96 1
a96 1
			  "illegal use of reserved word `%s'", yytext);	\
d127 1
a127 1
			  "literal value `%s' out of range", text);
d130 1
a130 1
			    "literal value `%s' out of range", text);
d138 1
a138 1
			 "signed literal value `%s' is interpreted as %d",
a339 46
   /* keywords available with ARB_shader_image_load_store */
image1D         KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE1D);
image2D         KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE2D);
image3D         KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE3D);
image2DRect     KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE2DRECT);
imageCube       KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGECUBE);
imageBuffer     KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGEBUFFER);
image1DArray    KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE1DARRAY);
image2DArray    KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE2DARRAY);
imageCubeArray  KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGECUBEARRAY);
image2DMS       KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE2DMS);
image2DMSArray  KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IMAGE2DMSARRAY);
iimage1D        KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE1D);
iimage2D        KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE2D);
iimage3D        KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE3D);
iimage2DRect    KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE2DRECT);
iimageCube      KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGECUBE);
iimageBuffer    KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGEBUFFER);
iimage1DArray   KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE1DARRAY);
iimage2DArray   KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE2DARRAY);
iimageCubeArray KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGECUBEARRAY);
iimage2DMS      KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE2DMS);
iimage2DMSArray KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, IIMAGE2DMSARRAY);
uimage1D        KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE1D);
uimage2D        KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE2D);
uimage3D        KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE3D);
uimage2DRect    KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE2DRECT);
uimageCube      KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGECUBE);
uimageBuffer    KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGEBUFFER);
uimage1DArray   KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE1DARRAY);
uimage2DArray   KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE2DARRAY);
uimageCubeArray KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGECUBEARRAY);
uimage2DMS      KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE2DMS);
uimage2DMSArray KEYWORD_WITH_ALT(130, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, UIMAGE2DMSARRAY);
image1DShadow           KEYWORD(130, 300, 0, 0, IMAGE1DSHADOW);
image2DShadow           KEYWORD(130, 300, 0, 0, IMAGE2DSHADOW);
image1DArrayShadow      KEYWORD(130, 300, 0, 0, IMAGE1DARRAYSHADOW);
image2DArrayShadow      KEYWORD(130, 300, 0, 0, IMAGE2DARRAYSHADOW);

coherent	KEYWORD_WITH_ALT(420, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, COHERENT);
volatile	KEYWORD_WITH_ALT(110, 100, 420, 0, yyextra->ARB_shader_image_load_store_enable, VOLATILE);
restrict	KEYWORD_WITH_ALT(420, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, RESTRICT);
readonly	KEYWORD_WITH_ALT(420, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, READONLY);
writeonly	KEYWORD_WITH_ALT(420, 300, 420, 0, yyextra->ARB_shader_image_load_store_enable, WRITEONLY);

atomic_uint     KEYWORD_WITH_ALT(420, 300, 420, 0, yyextra->ARB_shader_atomic_counters_enable, ATOMIC_UINT);
a348 1
                      || yyextra->has_separate_shader_objects()
d351 1
a351 2
                      || yyextra->ARB_shading_language_420pack_enable
                      || yyextra->ARB_compute_shader_enable) {
d437 1
d482 25
d516 4
d521 1
d523 1
a523 1
sample		KEYWORD_WITH_ALT(400, 300, 400, 0, yyextra->ARB_gpu_shader5_enable, SAMPLE);
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d26 1
a26 1
#include "util/strtod.h"
d84 1
a84 2
	 void *mem_ctx = yyextra;					\
	 yylval->identifier = ralloc_strdup(mem_ctx, yytext);		\
a154 1
%option warn nodefault
a155 3
	/* Note: When adding any start conditions to this list, you must also
	 * update the "Internal compiler error" catch-all rule near the end of
	 * this file. */
d231 1
a231 2
				   void *mem_ctx = yyextra;
				   yylval->identifier = ralloc_strdup(mem_ctx, yytext);
a238 1
<PP>.				{ return yytext[0]; }
a340 3
   /* keywords available with ARB_gpu_shader5 */
precise		KEYWORD_WITH_ALT(400, 0, 400, 0, yyextra->ARB_gpu_shader5_enable, PRECISE);

a395 1
		      || yyextra->ARB_explicit_uniform_location_enable
d403 1
a403 2
		      void *mem_ctx = yyextra;
		      yylval->identifier = ralloc_strdup(mem_ctx, yytext);
d442 1
a442 1
			    yylval->real = _mesa_strtof(yytext, NULL);
d446 1
a446 1
			    yylval->real = _mesa_strtof(yytext, NULL);
d450 1
a450 1
			    yylval->real = _mesa_strtof(yytext, NULL);
d454 1
a454 1
			    yylval->real = _mesa_strtof(yytext, NULL);
d458 1
a458 1
			    yylval->real = _mesa_strtof(yytext, NULL);
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d26 1
a26 1
#include "strtod.h"
d84 2
a85 1
	 yylval->identifier = strdup(yytext);				\
d156 1
d158 3
d236 2
a237 1
				   yylval->identifier = strdup(yytext);
d245 1
d348 3
d406 1
d414 2
a415 1
		      yylval->identifier = strdup(yytext);
d454 1
a454 1
			    yylval->real = glsl_strtof(yytext, NULL);
d458 1
a458 1
			    yylval->real = glsl_strtof(yytext, NULL);
d462 1
a462 1
			    yylval->real = glsl_strtof(yytext, NULL);
d466 1
a466 1
			    yylval->real = glsl_strtof(yytext, NULL);
d470 1
a470 1
			    yylval->real = glsl_strtof(yytext, NULL);
@


