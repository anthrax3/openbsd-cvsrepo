head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.14.17;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.14.17;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.30;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.10.22;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.47.29;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2011 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once
#ifndef IR_UNIFORM_H
#define IR_UNIFORM_H


/* stdbool.h is necessary because this file is included in both C and C++ code.
 */
#include <stdbool.h>

#include "program/prog_parameter.h"  /* For union gl_constant_value. */


#ifdef __cplusplus
extern "C" {
#endif

enum gl_uniform_driver_format {
   uniform_native = 0,          /**< Store data in the native format. */
   uniform_int_float,           /**< Store integer data as floats. */
   uniform_bool_float,          /**< Store boolean data as floats. */

   /**
    * Store boolean data as integer using 1 for \c true.
    */
   uniform_bool_int_0_1,

   /**
    * Store boolean data as integer using ~0 for \c true.
    */
   uniform_bool_int_0_not0
};

struct gl_uniform_driver_storage {
   /**
    * Number of bytes from one array element to the next.
    */
   uint8_t element_stride;

   /**
    * Number of bytes from one vector in a matrix to the next.
    */
   uint8_t vector_stride;

   /**
    * Base format of the stored data.
    *
    * This field must have a value from \c GLSL_TYPE_UINT through \c
    * GLSL_TYPE_SAMPLER.
    */
   uint8_t format;

   /**
    * Pointer to the base of the data.
    */
   void *data;
};

struct gl_uniform_storage {
   char *name;
   /** Type of this uniform data stored.
    *
    * In the case of an array, it's the type of a single array element.
    */
   const struct glsl_type *type;

   /**
    * The number of elements in this uniform.
    *
    * For non-arrays, this is always 0.  For arrays, the value is the size of
    * the array.
    */
   unsigned array_elements;

   /**
    * Has this uniform ever been set?
    */
   bool initialized;

   struct {
      /**
       * Base sampler index
       *
       * If \c ::base_type is \c GLSL_TYPE_SAMPLER, this represents the index
       * of this sampler.  If \c ::array_elements is not zero, the array will
       * use sampler indices \c ::sampler through \c ::sampler +
       * \c ::array_elements - 1, inclusive.
       *
       * Note that the index may be different in each shader stage.
       */
      uint8_t index;

      /**
       * Whether this sampler is used in this shader stage.
       */
      bool active;
   } sampler[MESA_SHADER_TYPES];

   /**
    * Storage used by the driver for the uniform
    */
   unsigned num_driver_storage;
   struct gl_uniform_driver_storage *driver_storage;

   /**
    * Storage used by Mesa for the uniform
    *
    * This form of the uniform is used by Mesa's implementation of \c
    * glGetUniform.  It can also be used by drivers to obtain the value of the
    * uniform if the \c ::driver_storage interface is not used.
    */
   union gl_constant_value *storage;

   /** Fields for GL_ARB_uniform_buffer_object
    * @@{
    */

   /**
    * GL_UNIFORM_BLOCK_INDEX: index of the uniform block containing
    * the uniform, or -1 for the default uniform block.  Note that the
    * index is into the linked program's UniformBlocks[] array, not
    * the linked shader's.
    */
   int block_index;

   /** GL_UNIFORM_OFFSET: byte offset within the uniform block, or -1. */
   int offset;

   /**
    * GL_UNIFORM_MATRIX_STRIDE: byte stride between columns or rows of
    * a matrix.  Set to 0 for non-matrices in UBOs, or -1 for uniforms
    * in the default uniform block.
    */
   int matrix_stride;

   /**
    * GL_UNIFORM_ARRAY_STRIDE: byte stride between elements of the
    * array.  Set to zero for non-arrays in UBOs, or -1 for uniforms
    * in the default uniform block.
    */
   int array_stride;

   /** GL_UNIFORM_ROW_MAJOR: true iff it's a row-major matrix in a UBO */
   bool row_major;

   /** @@} */
};

#ifdef __cplusplus
}
#endif

#endif /* IR_UNIFORM_H */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@a80 20
struct gl_opaque_uniform_index {
   /**
    * Base opaque uniform index
    *
    * If \c gl_uniform_storage::base_type is an opaque type, this
    * represents its uniform index.  If \c
    * gl_uniform_storage::array_elements is not zero, the array will
    * use opaque uniform indices \c index through \c index + \c
    * gl_uniform_storage::array_elements - 1, inclusive.
    *
    * Note that the index may be different in each shader stage.
    */
   uint8_t index;

   /**
    * Whether this opaque uniform is used in this shader stage.
    */
   bool active;
};

d102 18
a119 3
   struct gl_opaque_uniform_index sampler[MESA_SHADER_STAGES];

   struct gl_opaque_uniform_index image[MESA_SHADER_STAGES];
a168 13

   /**
    * Index within gl_shader_program::AtomicBuffers[] of the atomic
    * counter buffer this uniform is stored in, or -1 if this is not
    * an atomic counter.
    */
   int atomic_buffer_index;

   /**
    * The 'base location' for this uniform in the uniform remap table. For
    * arrays this is the first element in the array.
    */
   unsigned remap_location;
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@a34 5
/**
 * Used by GL_ARB_explicit_uniform_location extension code in the linker
 * and glUniform* functions to identify inactive explicit uniform locations.
 */
#define INACTIVE_UNIFORM_EXPLICIT_LOCATION ((gl_uniform_storage *) -1)
d40 1
a40 1
enum PACKED gl_uniform_driver_format {
d43 11
d69 3
d73 1
a73 1
   enum gl_uniform_driver_format format;
a186 6

   /**
    * This is a compiler-generated uniform that should not be advertised
    * via the API.
    */
   bool hidden;
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d35 5
d45 1
a45 1
enum gl_uniform_driver_format {
a47 11
   uniform_bool_float,          /**< Store boolean data as floats. */

   /**
    * Store boolean data as integer using 1 for \c true.
    */
   uniform_bool_int_0_1,

   /**
    * Store boolean data as integer using ~0 for \c true.
    */
   uniform_bool_int_0_not0
a62 3
    *
    * This field must have a value from \c GLSL_TYPE_UINT through \c
    * GLSL_TYPE_SAMPLER.
d64 1
a64 1
   uint8_t format;
d178 6
@


