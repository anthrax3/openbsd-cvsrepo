head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.26;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.14;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.28;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.19;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.26;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include <string.h>
#include "main/core.h" /* for MAX2 */
#include "ir.h"
#include "ir_visitor.h"
#include "glsl_types.h"

ir_rvalue::ir_rvalue()
{
   this->type = glsl_type::error_type;
}

bool ir_rvalue::is_zero() const
{
   return false;
}

bool ir_rvalue::is_one() const
{
   return false;
}

bool ir_rvalue::is_negative_one() const
{
   return false;
}

bool ir_rvalue::is_basis() const
{
   return false;
}

/**
 * Modify the swizzle make to move one component to another
 *
 * \param m    IR swizzle to be modified
 * \param from Component in the RHS that is to be swizzled
 * \param to   Desired swizzle location of \c from
 */
static void
update_rhs_swizzle(ir_swizzle_mask &m, unsigned from, unsigned to)
{
   switch (to) {
   case 0: m.x = from; break;
   case 1: m.y = from; break;
   case 2: m.z = from; break;
   case 3: m.w = from; break;
   default: assert(!"Should not get here.");
   }

   m.num_components = MAX2(m.num_components, (to + 1));
}

void
ir_assignment::set_lhs(ir_rvalue *lhs)
{
   void *mem_ctx = this;
   bool swizzled = false;

   while (lhs != NULL) {
      ir_swizzle *swiz = lhs->as_swizzle();

      if (swiz == NULL)
	 break;

      unsigned write_mask = 0;
      ir_swizzle_mask rhs_swiz = { 0, 0, 0, 0, 0, 0 };

      for (unsigned i = 0; i < swiz->mask.num_components; i++) {
	 unsigned c = 0;

	 switch (i) {
	 case 0: c = swiz->mask.x; break;
	 case 1: c = swiz->mask.y; break;
	 case 2: c = swiz->mask.z; break;
	 case 3: c = swiz->mask.w; break;
	 default: assert(!"Should not get here.");
	 }

	 write_mask |= (((this->write_mask >> i) & 1) << c);
	 update_rhs_swizzle(rhs_swiz, i, c);
      }

      this->write_mask = write_mask;
      lhs = swiz->val;

      this->rhs = new(mem_ctx) ir_swizzle(this->rhs, rhs_swiz);
      swizzled = true;
   }

   if (swizzled) {
      /* Now, RHS channels line up with the LHS writemask.  Collapse it
       * to just the channels that will be written.
       */
      ir_swizzle_mask rhs_swiz = { 0, 0, 0, 0, 0, 0 };
      int rhs_chan = 0;
      for (int i = 0; i < 4; i++) {
	 if (write_mask & (1 << i))
	    update_rhs_swizzle(rhs_swiz, i, rhs_chan++);
      }
      this->rhs = new(mem_ctx) ir_swizzle(this->rhs, rhs_swiz);
   }

   assert((lhs == NULL) || lhs->as_dereference());

   this->lhs = (ir_dereference *) lhs;
}

ir_variable *
ir_assignment::whole_variable_written()
{
   ir_variable *v = this->lhs->whole_variable_referenced();

   if (v == NULL)
      return NULL;

   if (v->type->is_scalar())
      return v;

   if (v->type->is_vector()) {
      const unsigned mask = (1U << v->type->vector_elements) - 1;

      if (mask != this->write_mask)
	 return NULL;
   }

   /* Either all the vector components are assigned or the variable is some
    * composite type (and the whole thing is assigned.
    */
   return v;
}

ir_assignment::ir_assignment(ir_dereference *lhs, ir_rvalue *rhs,
			     ir_rvalue *condition, unsigned write_mask)
{
   this->ir_type = ir_type_assignment;
   this->condition = condition;
   this->rhs = rhs;
   this->lhs = lhs;
   this->write_mask = write_mask;

   if (lhs->type->is_scalar() || lhs->type->is_vector()) {
      int lhs_components = 0;
      for (int i = 0; i < 4; i++) {
	 if (write_mask & (1 << i))
	    lhs_components++;
      }

      assert(lhs_components == this->rhs->type->vector_elements);
   }
}

ir_assignment::ir_assignment(ir_rvalue *lhs, ir_rvalue *rhs,
			     ir_rvalue *condition)
{
   this->ir_type = ir_type_assignment;
   this->condition = condition;
   this->rhs = rhs;

   /* If the RHS is a vector type, assume that all components of the vector
    * type are being written to the LHS.  The write mask comes from the RHS
    * because we can have a case where the LHS is a vec4 and the RHS is a
    * vec3.  In that case, the assignment is:
    *
    *     (assign (...) (xyz) (var_ref lhs) (var_ref rhs))
    */
   if (rhs->type->is_vector())
      this->write_mask = (1U << rhs->type->vector_elements) - 1;
   else if (rhs->type->is_scalar())
      this->write_mask = 1;
   else
      this->write_mask = 0;

   this->set_lhs(lhs);
}

ir_expression::ir_expression(int op, const struct glsl_type *type,
			     ir_rvalue *op0, ir_rvalue *op1,
			     ir_rvalue *op2, ir_rvalue *op3)
{
   this->ir_type = ir_type_expression;
   this->type = type;
   this->operation = ir_expression_operation(op);
   this->operands[0] = op0;
   this->operands[1] = op1;
   this->operands[2] = op2;
   this->operands[3] = op3;
#ifndef NDEBUG
   int num_operands = get_num_operands(this->operation);
   for (int i = num_operands; i < 4; i++) {
      assert(this->operands[i] == NULL);
   }
#endif
}

ir_expression::ir_expression(int op, ir_rvalue *op0)
{
   this->ir_type = ir_type_expression;

   this->operation = ir_expression_operation(op);
   this->operands[0] = op0;
   this->operands[1] = NULL;
   this->operands[2] = NULL;
   this->operands[3] = NULL;

   assert(op <= ir_last_unop);

   switch (this->operation) {
   case ir_unop_bit_not:
   case ir_unop_logic_not:
   case ir_unop_neg:
   case ir_unop_abs:
   case ir_unop_sign:
   case ir_unop_rcp:
   case ir_unop_rsq:
   case ir_unop_sqrt:
   case ir_unop_exp:
   case ir_unop_log:
   case ir_unop_exp2:
   case ir_unop_log2:
   case ir_unop_trunc:
   case ir_unop_ceil:
   case ir_unop_floor:
   case ir_unop_fract:
   case ir_unop_round_even:
   case ir_unop_sin:
   case ir_unop_cos:
   case ir_unop_sin_reduced:
   case ir_unop_cos_reduced:
   case ir_unop_dFdx:
   case ir_unop_dFdy:
   case ir_unop_bitfield_reverse:
      this->type = op0->type;
      break;

   case ir_unop_f2i:
   case ir_unop_b2i:
   case ir_unop_u2i:
   case ir_unop_bitcast_f2i:
   case ir_unop_bit_count:
   case ir_unop_find_msb:
   case ir_unop_find_lsb:
      this->type = glsl_type::get_instance(GLSL_TYPE_INT,
					   op0->type->vector_elements, 1);
      break;

   case ir_unop_b2f:
   case ir_unop_i2f:
   case ir_unop_u2f:
   case ir_unop_bitcast_i2f:
   case ir_unop_bitcast_u2f:
      this->type = glsl_type::get_instance(GLSL_TYPE_FLOAT,
					   op0->type->vector_elements, 1);
      break;

   case ir_unop_f2b:
   case ir_unop_i2b:
      this->type = glsl_type::get_instance(GLSL_TYPE_BOOL,
					   op0->type->vector_elements, 1);
      break;

   case ir_unop_i2u:
   case ir_unop_f2u:
   case ir_unop_bitcast_f2u:
      this->type = glsl_type::get_instance(GLSL_TYPE_UINT,
					   op0->type->vector_elements, 1);
      break;

   case ir_unop_noise:
   case ir_unop_unpack_half_2x16_split_x:
   case ir_unop_unpack_half_2x16_split_y:
      this->type = glsl_type::float_type;
      break;

   case ir_unop_any:
      this->type = glsl_type::bool_type;
      break;

   case ir_unop_pack_snorm_2x16:
   case ir_unop_pack_snorm_4x8:
   case ir_unop_pack_unorm_2x16:
   case ir_unop_pack_unorm_4x8:
   case ir_unop_pack_half_2x16:
      this->type = glsl_type::uint_type;
      break;

   case ir_unop_unpack_snorm_2x16:
   case ir_unop_unpack_unorm_2x16:
   case ir_unop_unpack_half_2x16:
      this->type = glsl_type::vec2_type;
      break;

   case ir_unop_unpack_snorm_4x8:
   case ir_unop_unpack_unorm_4x8:
      this->type = glsl_type::vec4_type;
      break;

   default:
      assert(!"not reached: missing automatic type setup for ir_expression");
      this->type = op0->type;
      break;
   }
}

ir_expression::ir_expression(int op, ir_rvalue *op0, ir_rvalue *op1)
{
   this->ir_type = ir_type_expression;

   this->operation = ir_expression_operation(op);
   this->operands[0] = op0;
   this->operands[1] = op1;
   this->operands[2] = NULL;
   this->operands[3] = NULL;

   assert(op > ir_last_unop);

   switch (this->operation) {
   case ir_binop_all_equal:
   case ir_binop_any_nequal:
      this->type = glsl_type::bool_type;
      break;

   case ir_binop_add:
   case ir_binop_sub:
   case ir_binop_min:
   case ir_binop_max:
   case ir_binop_pow:
   case ir_binop_mul:
   case ir_binop_div:
   case ir_binop_mod:
      if (op0->type->is_scalar()) {
	 this->type = op1->type;
      } else if (op1->type->is_scalar()) {
	 this->type = op0->type;
      } else {
	 /* FINISHME: matrix types */
	 assert(!op0->type->is_matrix() && !op1->type->is_matrix());
	 assert(op0->type == op1->type);
	 this->type = op0->type;
      }
      break;

   case ir_binop_logic_and:
   case ir_binop_logic_xor:
   case ir_binop_logic_or:
   case ir_binop_bit_and:
   case ir_binop_bit_xor:
   case ir_binop_bit_or:
       assert(!op0->type->is_matrix());
       assert(!op1->type->is_matrix());
      if (op0->type->is_scalar()) {
         this->type = op1->type;
      } else if (op1->type->is_scalar()) {
         this->type = op0->type;
      } else {
          assert(op0->type->vector_elements == op1->type->vector_elements);
          this->type = op0->type;
      }
      break;

   case ir_binop_equal:
   case ir_binop_nequal:
   case ir_binop_lequal:
   case ir_binop_gequal:
   case ir_binop_less:
   case ir_binop_greater:
      assert(op0->type == op1->type);
      this->type = glsl_type::get_instance(GLSL_TYPE_BOOL,
					   op0->type->vector_elements, 1);
      break;

   case ir_binop_dot:
      this->type = glsl_type::float_type;
      break;

   case ir_binop_pack_half_2x16_split:
      this->type = glsl_type::uint_type;
      break;

   case ir_binop_imul_high:
   case ir_binop_carry:
   case ir_binop_borrow:
   case ir_binop_lshift:
   case ir_binop_rshift:
   case ir_binop_bfm:
   case ir_binop_ldexp:
      this->type = op0->type;
      break;

   case ir_binop_vector_extract:
      this->type = op0->type->get_scalar_type();
      break;

   default:
      assert(!"not reached: missing automatic type setup for ir_expression");
      this->type = glsl_type::float_type;
   }
}

ir_expression::ir_expression(int op, ir_rvalue *op0, ir_rvalue *op1,
                             ir_rvalue *op2)
{
   this->ir_type = ir_type_expression;

   this->operation = ir_expression_operation(op);
   this->operands[0] = op0;
   this->operands[1] = op1;
   this->operands[2] = op2;
   this->operands[3] = NULL;

   assert(op > ir_last_binop && op <= ir_last_triop);

   switch (this->operation) {
   case ir_triop_fma:
   case ir_triop_lrp:
   case ir_triop_bitfield_extract:
   case ir_triop_vector_insert:
      this->type = op0->type;
      break;

   case ir_triop_bfi:
   case ir_triop_csel:
      this->type = op1->type;
      break;

   default:
      assert(!"not reached: missing automatic type setup for ir_expression");
      this->type = glsl_type::float_type;
   }
}

unsigned int
ir_expression::get_num_operands(ir_expression_operation op)
{
   assert(op <= ir_last_opcode);

   if (op <= ir_last_unop)
      return 1;

   if (op <= ir_last_binop)
      return 2;

   if (op <= ir_last_triop)
      return 3;

   if (op <= ir_last_quadop)
      return 4;

   assert(false);
   return 0;
}

static const char *const operator_strs[] = {
   "~",
   "!",
   "neg",
   "abs",
   "sign",
   "rcp",
   "rsq",
   "sqrt",
   "exp",
   "log",
   "exp2",
   "log2",
   "f2i",
   "f2u",
   "i2f",
   "f2b",
   "b2f",
   "i2b",
   "b2i",
   "u2f",
   "i2u",
   "u2i",
   "bitcast_i2f",
   "bitcast_f2i",
   "bitcast_u2f",
   "bitcast_f2u",
   "any",
   "trunc",
   "ceil",
   "floor",
   "fract",
   "round_even",
   "sin",
   "cos",
   "sin_reduced",
   "cos_reduced",
   "dFdx",
   "dFdy",
   "packSnorm2x16",
   "packSnorm4x8",
   "packUnorm2x16",
   "packUnorm4x8",
   "packHalf2x16",
   "unpackSnorm2x16",
   "unpackSnorm4x8",
   "unpackUnorm2x16",
   "unpackUnorm4x8",
   "unpackHalf2x16",
   "unpackHalf2x16_split_x",
   "unpackHalf2x16_split_y",
   "bitfield_reverse",
   "bit_count",
   "find_msb",
   "find_lsb",
   "noise",
   "+",
   "-",
   "*",
   "imul_high",
   "/",
   "carry",
   "borrow",
   "%",
   "<",
   ">",
   "<=",
   ">=",
   "==",
   "!=",
   "all_equal",
   "any_nequal",
   "<<",
   ">>",
   "&",
   "^",
   "|",
   "&&",
   "^^",
   "||",
   "dot",
   "min",
   "max",
   "pow",
   "packHalf2x16_split",
   "bfm",
   "ubo_load",
   "ldexp",
   "vector_extract",
   "fma",
   "lrp",
   "csel",
   "bfi",
   "bitfield_extract",
   "vector_insert",
   "bitfield_insert",
   "vector",
};

const char *ir_expression::operator_string(ir_expression_operation op)
{
   assert((unsigned int) op < Elements(operator_strs));
   assert(Elements(operator_strs) == (ir_quadop_vector + 1));
   return operator_strs[op];
}

const char *ir_expression::operator_string()
{
   return operator_string(this->operation);
}

const char*
depth_layout_string(ir_depth_layout layout)
{
   switch(layout) {
   case ir_depth_layout_none:      return "";
   case ir_depth_layout_any:       return "depth_any";
   case ir_depth_layout_greater:   return "depth_greater";
   case ir_depth_layout_less:      return "depth_less";
   case ir_depth_layout_unchanged: return "depth_unchanged";

   default:
      assert(0);
      return "";
   }
}

ir_expression_operation
ir_expression::get_operator(const char *str)
{
   const int operator_count = sizeof(operator_strs) / sizeof(operator_strs[0]);
   for (int op = 0; op < operator_count; op++) {
      if (strcmp(str, operator_strs[op]) == 0)
	 return (ir_expression_operation) op;
   }
   return (ir_expression_operation) -1;
}

ir_constant::ir_constant()
{
   this->ir_type = ir_type_constant;
}

ir_constant::ir_constant(const struct glsl_type *type,
			 const ir_constant_data *data)
{
   assert((type->base_type >= GLSL_TYPE_UINT)
	  && (type->base_type <= GLSL_TYPE_BOOL));

   this->ir_type = ir_type_constant;
   this->type = type;
   memcpy(& this->value, data, sizeof(this->value));
}

ir_constant::ir_constant(float f, unsigned vector_elements)
{
   assert(vector_elements <= 4);
   this->ir_type = ir_type_constant;
   this->type = glsl_type::get_instance(GLSL_TYPE_FLOAT, vector_elements, 1);
   for (unsigned i = 0; i < vector_elements; i++) {
      this->value.f[i] = f;
   }
   for (unsigned i = vector_elements; i < 16; i++)  {
      this->value.f[i] = 0;
   }
}

ir_constant::ir_constant(unsigned int u, unsigned vector_elements)
{
   assert(vector_elements <= 4);
   this->ir_type = ir_type_constant;
   this->type = glsl_type::get_instance(GLSL_TYPE_UINT, vector_elements, 1);
   for (unsigned i = 0; i < vector_elements; i++) {
      this->value.u[i] = u;
   }
   for (unsigned i = vector_elements; i < 16; i++) {
      this->value.u[i] = 0;
   }
}

ir_constant::ir_constant(int integer, unsigned vector_elements)
{
   assert(vector_elements <= 4);
   this->ir_type = ir_type_constant;
   this->type = glsl_type::get_instance(GLSL_TYPE_INT, vector_elements, 1);
   for (unsigned i = 0; i < vector_elements; i++) {
      this->value.i[i] = integer;
   }
   for (unsigned i = vector_elements; i < 16; i++) {
      this->value.i[i] = 0;
   }
}

ir_constant::ir_constant(bool b, unsigned vector_elements)
{
   assert(vector_elements <= 4);
   this->ir_type = ir_type_constant;
   this->type = glsl_type::get_instance(GLSL_TYPE_BOOL, vector_elements, 1);
   for (unsigned i = 0; i < vector_elements; i++) {
      this->value.b[i] = b;
   }
   for (unsigned i = vector_elements; i < 16; i++) {
      this->value.b[i] = false;
   }
}

ir_constant::ir_constant(const ir_constant *c, unsigned i)
{
   this->ir_type = ir_type_constant;
   this->type = c->type->get_base_type();

   switch (this->type->base_type) {
   case GLSL_TYPE_UINT:  this->value.u[0] = c->value.u[i]; break;
   case GLSL_TYPE_INT:   this->value.i[0] = c->value.i[i]; break;
   case GLSL_TYPE_FLOAT: this->value.f[0] = c->value.f[i]; break;
   case GLSL_TYPE_BOOL:  this->value.b[0] = c->value.b[i]; break;
   default:              assert(!"Should not get here."); break;
   }
}

ir_constant::ir_constant(const struct glsl_type *type, exec_list *value_list)
{
   this->ir_type = ir_type_constant;
   this->type = type;

   assert(type->is_scalar() || type->is_vector() || type->is_matrix()
	  || type->is_record() || type->is_array());

   if (type->is_array()) {
      this->array_elements = ralloc_array(this, ir_constant *, type->length);
      unsigned i = 0;
      foreach_list(node, value_list) {
	 ir_constant *value = (ir_constant *) node;
	 assert(value->as_constant() != NULL);

	 this->array_elements[i++] = value;
      }
      return;
   }

   /* If the constant is a record, the types of each of the entries in
    * value_list must be a 1-for-1 match with the structure components.  Each
    * entry must also be a constant.  Just move the nodes from the value_list
    * to the list in the ir_constant.
    */
   /* FINISHME: Should there be some type checking and / or assertions here? */
   /* FINISHME: Should the new constant take ownership of the nodes from
    * FINISHME: value_list, or should it make copies?
    */
   if (type->is_record()) {
      value_list->move_nodes_to(& this->components);
      return;
   }

   for (unsigned i = 0; i < 16; i++) {
      this->value.u[i] = 0;
   }

   ir_constant *value = (ir_constant *) (value_list->head);

   /* Constructors with exactly one scalar argument are special for vectors
    * and matrices.  For vectors, the scalar value is replicated to fill all
    * the components.  For matrices, the scalar fills the components of the
    * diagonal while the rest is filled with 0.
    */
   if (value->type->is_scalar() && value->next->is_tail_sentinel()) {
      if (type->is_matrix()) {
	 /* Matrix - fill diagonal (rest is already set to 0) */
	 assert(type->base_type == GLSL_TYPE_FLOAT);
	 for (unsigned i = 0; i < type->matrix_columns; i++)
	    this->value.f[i * type->vector_elements + i] = value->value.f[0];
      } else {
	 /* Vector or scalar - fill all components */
	 switch (type->base_type) {
	 case GLSL_TYPE_UINT:
	 case GLSL_TYPE_INT:
	    for (unsigned i = 0; i < type->components(); i++)
	       this->value.u[i] = value->value.u[0];
	    break;
	 case GLSL_TYPE_FLOAT:
	    for (unsigned i = 0; i < type->components(); i++)
	       this->value.f[i] = value->value.f[0];
	    break;
	 case GLSL_TYPE_BOOL:
	    for (unsigned i = 0; i < type->components(); i++)
	       this->value.b[i] = value->value.b[0];
	    break;
	 default:
	    assert(!"Should not get here.");
	    break;
	 }
      }
      return;
   }

   if (type->is_matrix() && value->type->is_matrix()) {
      assert(value->next->is_tail_sentinel());

      /* From section 5.4.2 of the GLSL 1.20 spec:
       * "If a matrix is constructed from a matrix, then each component
       *  (column i, row j) in the result that has a corresponding component
       *  (column i, row j) in the argument will be initialized from there."
       */
      unsigned cols = MIN2(type->matrix_columns, value->type->matrix_columns);
      unsigned rows = MIN2(type->vector_elements, value->type->vector_elements);
      for (unsigned i = 0; i < cols; i++) {
	 for (unsigned j = 0; j < rows; j++) {
	    const unsigned src = i * value->type->vector_elements + j;
	    const unsigned dst = i * type->vector_elements + j;
	    this->value.f[dst] = value->value.f[src];
	 }
      }

      /* "All other components will be initialized to the identity matrix." */
      for (unsigned i = cols; i < type->matrix_columns; i++)
	 this->value.f[i * type->vector_elements + i] = 1.0;

      return;
   }

   /* Use each component from each entry in the value_list to initialize one
    * component of the constant being constructed.
    */
   for (unsigned i = 0; i < type->components(); /* empty */) {
      assert(value->as_constant() != NULL);
      assert(!value->is_tail_sentinel());

      for (unsigned j = 0; j < value->type->components(); j++) {
	 switch (type->base_type) {
	 case GLSL_TYPE_UINT:
	    this->value.u[i] = value->get_uint_component(j);
	    break;
	 case GLSL_TYPE_INT:
	    this->value.i[i] = value->get_int_component(j);
	    break;
	 case GLSL_TYPE_FLOAT:
	    this->value.f[i] = value->get_float_component(j);
	    break;
	 case GLSL_TYPE_BOOL:
	    this->value.b[i] = value->get_bool_component(j);
	    break;
	 default:
	    /* FINISHME: What to do?  Exceptions are not the answer.
	     */
	    break;
	 }

	 i++;
	 if (i >= type->components())
	    break;
      }

      value = (ir_constant *) value->next;
   }
}

ir_constant *
ir_constant::zero(void *mem_ctx, const glsl_type *type)
{
   assert(type->is_scalar() || type->is_vector() || type->is_matrix()
	  || type->is_record() || type->is_array());

   ir_constant *c = new(mem_ctx) ir_constant;
   c->type = type;
   memset(&c->value, 0, sizeof(c->value));

   if (type->is_array()) {
      c->array_elements = ralloc_array(c, ir_constant *, type->length);

      for (unsigned i = 0; i < type->length; i++)
	 c->array_elements[i] = ir_constant::zero(c, type->element_type());
   }

   if (type->is_record()) {
      for (unsigned i = 0; i < type->length; i++) {
	 ir_constant *comp = ir_constant::zero(mem_ctx, type->fields.structure[i].type);
	 c->components.push_tail(comp);
      }
   }

   return c;
}

bool
ir_constant::get_bool_component(unsigned i) const
{
   switch (this->type->base_type) {
   case GLSL_TYPE_UINT:  return this->value.u[i] != 0;
   case GLSL_TYPE_INT:   return this->value.i[i] != 0;
   case GLSL_TYPE_FLOAT: return ((int)this->value.f[i]) != 0;
   case GLSL_TYPE_BOOL:  return this->value.b[i];
   default:              assert(!"Should not get here."); break;
   }

   /* Must return something to make the compiler happy.  This is clearly an
    * error case.
    */
   return false;
}

float
ir_constant::get_float_component(unsigned i) const
{
   switch (this->type->base_type) {
   case GLSL_TYPE_UINT:  return (float) this->value.u[i];
   case GLSL_TYPE_INT:   return (float) this->value.i[i];
   case GLSL_TYPE_FLOAT: return this->value.f[i];
   case GLSL_TYPE_BOOL:  return this->value.b[i] ? 1.0f : 0.0f;
   default:              assert(!"Should not get here."); break;
   }

   /* Must return something to make the compiler happy.  This is clearly an
    * error case.
    */
   return 0.0;
}

int
ir_constant::get_int_component(unsigned i) const
{
   switch (this->type->base_type) {
   case GLSL_TYPE_UINT:  return this->value.u[i];
   case GLSL_TYPE_INT:   return this->value.i[i];
   case GLSL_TYPE_FLOAT: return (int) this->value.f[i];
   case GLSL_TYPE_BOOL:  return this->value.b[i] ? 1 : 0;
   default:              assert(!"Should not get here."); break;
   }

   /* Must return something to make the compiler happy.  This is clearly an
    * error case.
    */
   return 0;
}

unsigned
ir_constant::get_uint_component(unsigned i) const
{
   switch (this->type->base_type) {
   case GLSL_TYPE_UINT:  return this->value.u[i];
   case GLSL_TYPE_INT:   return this->value.i[i];
   case GLSL_TYPE_FLOAT: return (unsigned) this->value.f[i];
   case GLSL_TYPE_BOOL:  return this->value.b[i] ? 1 : 0;
   default:              assert(!"Should not get here."); break;
   }

   /* Must return something to make the compiler happy.  This is clearly an
    * error case.
    */
   return 0;
}

ir_constant *
ir_constant::get_array_element(unsigned i) const
{
   assert(this->type->is_array());

   /* From page 35 (page 41 of the PDF) of the GLSL 1.20 spec:
    *
    *     "Behavior is undefined if a shader subscripts an array with an index
    *     less than 0 or greater than or equal to the size the array was
    *     declared with."
    *
    * Most out-of-bounds accesses are removed before things could get this far.
    * There are cases where non-constant array index values can get constant
    * folded.
    */
   if (int(i) < 0)
      i = 0;
   else if (i >= this->type->length)
      i = this->type->length - 1;

   return array_elements[i];
}

ir_constant *
ir_constant::get_record_field(const char *name)
{
   int idx = this->type->field_index(name);

   if (idx < 0)
      return NULL;

   if (this->components.is_empty())
      return NULL;

   exec_node *node = this->components.head;
   for (int i = 0; i < idx; i++) {
      node = node->next;

      /* If the end of the list is encountered before the element matching the
       * requested field is found, return NULL.
       */
      if (node->is_tail_sentinel())
	 return NULL;
   }

   return (ir_constant *) node;
}

void
ir_constant::copy_offset(ir_constant *src, int offset)
{
   switch (this->type->base_type) {
   case GLSL_TYPE_UINT:
   case GLSL_TYPE_INT:
   case GLSL_TYPE_FLOAT:
   case GLSL_TYPE_BOOL: {
      unsigned int size = src->type->components();
      assert (size <= this->type->components() - offset);
      for (unsigned int i=0; i<size; i++) {
	 switch (this->type->base_type) {
	 case GLSL_TYPE_UINT:
	    value.u[i+offset] = src->get_uint_component(i);
	    break;
	 case GLSL_TYPE_INT:
	    value.i[i+offset] = src->get_int_component(i);
	    break;
	 case GLSL_TYPE_FLOAT:
	    value.f[i+offset] = src->get_float_component(i);
	    break;
	 case GLSL_TYPE_BOOL:
	    value.b[i+offset] = src->get_bool_component(i);
	    break;
	 default: // Shut up the compiler
	    break;
	 }
      }
      break;
   }

   case GLSL_TYPE_STRUCT: {
      assert (src->type == this->type);
      this->components.make_empty();
      foreach_list(node, &src->components) {
	 ir_constant *const orig = (ir_constant *) node;

	 this->components.push_tail(orig->clone(this, NULL));
      }
      break;
   }

   case GLSL_TYPE_ARRAY: {
      assert (src->type == this->type);
      for (unsigned i = 0; i < this->type->length; i++) {
	 this->array_elements[i] = src->array_elements[i]->clone(this, NULL);
      }
      break;
   }

   default:
      assert(!"Should not get here.");
      break;
   }
}

void
ir_constant::copy_masked_offset(ir_constant *src, int offset, unsigned int mask)
{
   assert (!type->is_array() && !type->is_record());

   if (!type->is_vector() && !type->is_matrix()) {
      offset = 0;
      mask = 1;
   }

   int id = 0;
   for (int i=0; i<4; i++) {
      if (mask & (1 << i)) {
	 switch (this->type->base_type) {
	 case GLSL_TYPE_UINT:
	    value.u[i+offset] = src->get_uint_component(id++);
	    break;
	 case GLSL_TYPE_INT:
	    value.i[i+offset] = src->get_int_component(id++);
	    break;
	 case GLSL_TYPE_FLOAT:
	    value.f[i+offset] = src->get_float_component(id++);
	    break;
	 case GLSL_TYPE_BOOL:
	    value.b[i+offset] = src->get_bool_component(id++);
	    break;
	 default:
	    assert(!"Should not get here.");
	    return;
	 }
      }
   }
}

bool
ir_constant::has_value(const ir_constant *c) const
{
   if (this->type != c->type)
      return false;

   if (this->type->is_array()) {
      for (unsigned i = 0; i < this->type->length; i++) {
	 if (!this->array_elements[i]->has_value(c->array_elements[i]))
	    return false;
      }
      return true;
   }

   if (this->type->base_type == GLSL_TYPE_STRUCT) {
      const exec_node *a_node = this->components.head;
      const exec_node *b_node = c->components.head;

      while (!a_node->is_tail_sentinel()) {
	 assert(!b_node->is_tail_sentinel());

	 const ir_constant *const a_field = (ir_constant *) a_node;
	 const ir_constant *const b_field = (ir_constant *) b_node;

	 if (!a_field->has_value(b_field))
	    return false;

	 a_node = a_node->next;
	 b_node = b_node->next;
      }

      return true;
   }

   for (unsigned i = 0; i < this->type->components(); i++) {
      switch (this->type->base_type) {
      case GLSL_TYPE_UINT:
	 if (this->value.u[i] != c->value.u[i])
	    return false;
	 break;
      case GLSL_TYPE_INT:
	 if (this->value.i[i] != c->value.i[i])
	    return false;
	 break;
      case GLSL_TYPE_FLOAT:
	 if (this->value.f[i] != c->value.f[i])
	    return false;
	 break;
      case GLSL_TYPE_BOOL:
	 if (this->value.b[i] != c->value.b[i])
	    return false;
	 break;
      default:
	 assert(!"Should not get here.");
	 return false;
      }
   }

   return true;
}

bool
ir_constant::is_value(float f, int i) const
{
   if (!this->type->is_scalar() && !this->type->is_vector())
      return false;

   /* Only accept boolean values for 0/1. */
   if (int(bool(i)) != i && this->type->is_boolean())
      return false;

   for (unsigned c = 0; c < this->type->vector_elements; c++) {
      switch (this->type->base_type) {
      case GLSL_TYPE_FLOAT:
	 if (this->value.f[c] != f)
	    return false;
	 break;
      case GLSL_TYPE_INT:
	 if (this->value.i[c] != i)
	    return false;
	 break;
      case GLSL_TYPE_UINT:
	 if (this->value.u[c] != unsigned(i))
	    return false;
	 break;
      case GLSL_TYPE_BOOL:
	 if (this->value.b[c] != bool(i))
	    return false;
	 break;
      default:
	 /* The only other base types are structures, arrays, and samplers.
	  * Samplers cannot be constants, and the others should have been
	  * filtered out above.
	  */
	 assert(!"Should not get here.");
	 return false;
      }
   }

   return true;
}

bool
ir_constant::is_zero() const
{
   return is_value(0.0, 0);
}

bool
ir_constant::is_one() const
{
   return is_value(1.0, 1);
}

bool
ir_constant::is_negative_one() const
{
   return is_value(-1.0, -1);
}

bool
ir_constant::is_basis() const
{
   if (!this->type->is_scalar() && !this->type->is_vector())
      return false;

   if (this->type->is_boolean())
      return false;

   unsigned ones = 0;
   for (unsigned c = 0; c < this->type->vector_elements; c++) {
      switch (this->type->base_type) {
      case GLSL_TYPE_FLOAT:
	 if (this->value.f[c] == 1.0)
	    ones++;
	 else if (this->value.f[c] != 0.0)
	    return false;
	 break;
      case GLSL_TYPE_INT:
	 if (this->value.i[c] == 1)
	    ones++;
	 else if (this->value.i[c] != 0)
	    return false;
	 break;
      case GLSL_TYPE_UINT:
	 if (int(this->value.u[c]) == 1)
	    ones++;
	 else if (int(this->value.u[c]) != 0)
	    return false;
	 break;
      default:
	 /* The only other base types are structures, arrays, samplers, and
	  * booleans.  Samplers cannot be constants, and the others should
	  * have been filtered out above.
	  */
	 assert(!"Should not get here.");
	 return false;
      }
   }

   return ones == 1;
}

bool
ir_constant::is_uint16_constant() const
{
   if (!type->is_integer())
      return false;

   return value.u[0] < (1 << 16);
}

ir_loop::ir_loop()
{
   this->ir_type = ir_type_loop;
}


ir_dereference_variable::ir_dereference_variable(ir_variable *var)
{
   assert(var != NULL);

   this->ir_type = ir_type_dereference_variable;
   this->var = var;
   this->type = var->type;
}


ir_dereference_array::ir_dereference_array(ir_rvalue *value,
					   ir_rvalue *array_index)
{
   this->ir_type = ir_type_dereference_array;
   this->array_index = array_index;
   this->set_array(value);
}


ir_dereference_array::ir_dereference_array(ir_variable *var,
					   ir_rvalue *array_index)
{
   void *ctx = ralloc_parent(var);

   this->ir_type = ir_type_dereference_array;
   this->array_index = array_index;
   this->set_array(new(ctx) ir_dereference_variable(var));
}


void
ir_dereference_array::set_array(ir_rvalue *value)
{
   assert(value != NULL);

   this->array = value;

   const glsl_type *const vt = this->array->type;

   if (vt->is_array()) {
      type = vt->element_type();
   } else if (vt->is_matrix()) {
      type = vt->column_type();
   } else if (vt->is_vector()) {
      type = vt->get_base_type();
   }
}


ir_dereference_record::ir_dereference_record(ir_rvalue *value,
					     const char *field)
{
   assert(value != NULL);

   this->ir_type = ir_type_dereference_record;
   this->record = value;
   this->field = ralloc_strdup(this, field);
   this->type = this->record->type->field_type(field);
}


ir_dereference_record::ir_dereference_record(ir_variable *var,
					     const char *field)
{
   void *ctx = ralloc_parent(var);

   this->ir_type = ir_type_dereference_record;
   this->record = new(ctx) ir_dereference_variable(var);
   this->field = ralloc_strdup(this, field);
   this->type = this->record->type->field_type(field);
}

bool
ir_dereference::is_lvalue() const
{
   ir_variable *var = this->variable_referenced();

   /* Every l-value derference chain eventually ends in a variable.
    */
   if ((var == NULL) || var->data.read_only)
      return false;

   /* From section 4.1.7 of the GLSL 4.40 spec:
    *
    *   "Opaque variables cannot be treated as l-values; hence cannot
    *    be used as out or inout function parameters, nor can they be
    *    assigned into."
    */
   if (this->type->contains_opaque())
      return false;

   return true;
}


static const char * const tex_opcode_strs[] = { "tex", "txb", "txl", "txd", "txf", "txf_ms", "txs", "lod", "tg4", "query_levels" };

const char *ir_texture::opcode_string()
{
   assert((unsigned int) op <=
	  sizeof(tex_opcode_strs) / sizeof(tex_opcode_strs[0]));
   return tex_opcode_strs[op];
}

ir_texture_opcode
ir_texture::get_opcode(const char *str)
{
   const int count = sizeof(tex_opcode_strs) / sizeof(tex_opcode_strs[0]);
   for (int op = 0; op < count; op++) {
      if (strcmp(str, tex_opcode_strs[op]) == 0)
	 return (ir_texture_opcode) op;
   }
   return (ir_texture_opcode) -1;
}


void
ir_texture::set_sampler(ir_dereference *sampler, const glsl_type *type)
{
   assert(sampler != NULL);
   assert(type != NULL);
   this->sampler = sampler;
   this->type = type;

   if (this->op == ir_txs || this->op == ir_query_levels) {
      assert(type->base_type == GLSL_TYPE_INT);
   } else if (this->op == ir_lod) {
      assert(type->vector_elements == 2);
      assert(type->base_type == GLSL_TYPE_FLOAT);
   } else {
      assert(sampler->type->sampler_type == (int) type->base_type);
      if (sampler->type->sampler_shadow)
	 assert(type->vector_elements == 4 || type->vector_elements == 1);
      else
	 assert(type->vector_elements == 4);
   }
}


void
ir_swizzle::init_mask(const unsigned *comp, unsigned count)
{
   assert((count >= 1) && (count <= 4));

   memset(&this->mask, 0, sizeof(this->mask));
   this->mask.num_components = count;

   unsigned dup_mask = 0;
   switch (count) {
   case 4:
      assert(comp[3] <= 3);
      dup_mask |= (1U << comp[3])
	 & ((1U << comp[0]) | (1U << comp[1]) | (1U << comp[2]));
      this->mask.w = comp[3];

   case 3:
      assert(comp[2] <= 3);
      dup_mask |= (1U << comp[2])
	 & ((1U << comp[0]) | (1U << comp[1]));
      this->mask.z = comp[2];

   case 2:
      assert(comp[1] <= 3);
      dup_mask |= (1U << comp[1])
	 & ((1U << comp[0]));
      this->mask.y = comp[1];

   case 1:
      assert(comp[0] <= 3);
      this->mask.x = comp[0];
   }

   this->mask.has_duplicates = dup_mask != 0;

   /* Based on the number of elements in the swizzle and the base type
    * (i.e., float, int, unsigned, or bool) of the vector being swizzled,
    * generate the type of the resulting value.
    */
   type = glsl_type::get_instance(val->type->base_type, mask.num_components, 1);
}

ir_swizzle::ir_swizzle(ir_rvalue *val, unsigned x, unsigned y, unsigned z,
		       unsigned w, unsigned count)
   : val(val)
{
   const unsigned components[4] = { x, y, z, w };
   this->ir_type = ir_type_swizzle;
   this->init_mask(components, count);
}

ir_swizzle::ir_swizzle(ir_rvalue *val, const unsigned *comp,
		       unsigned count)
   : val(val)
{
   this->ir_type = ir_type_swizzle;
   this->init_mask(comp, count);
}

ir_swizzle::ir_swizzle(ir_rvalue *val, ir_swizzle_mask mask)
{
   this->ir_type = ir_type_swizzle;
   this->val = val;
   this->mask = mask;
   this->type = glsl_type::get_instance(val->type->base_type,
					mask.num_components, 1);
}

#define X 1
#define R 5
#define S 9
#define I 13

ir_swizzle *
ir_swizzle::create(ir_rvalue *val, const char *str, unsigned vector_length)
{
   void *ctx = ralloc_parent(val);

   /* For each possible swizzle character, this table encodes the value in
    * \c idx_map that represents the 0th element of the vector.  For invalid
    * swizzle characters (e.g., 'k'), a special value is used that will allow
    * detection of errors.
    */
   static const unsigned char base_idx[26] = {
   /* a  b  c  d  e  f  g  h  i  j  k  l  m */
      R, R, I, I, I, I, R, I, I, I, I, I, I,
   /* n  o  p  q  r  s  t  u  v  w  x  y  z */
      I, I, S, S, R, S, S, I, I, X, X, X, X
   };

   /* Each valid swizzle character has an entry in the previous table.  This
    * table encodes the base index encoded in the previous table plus the actual
    * index of the swizzle character.  When processing swizzles, the first
    * character in the string is indexed in the previous table.  Each character
    * in the string is indexed in this table, and the value found there has the
    * value form the first table subtracted.  The result must be on the range
    * [0,3].
    *
    * For example, the string "wzyx" will get X from the first table.  Each of
    * the charcaters will get X+3, X+2, X+1, and X+0 from this table.  After
    * subtraction, the swizzle values are { 3, 2, 1, 0 }.
    *
    * The string "wzrg" will get X from the first table.  Each of the characters
    * will get X+3, X+2, R+0, and R+1 from this table.  After subtraction, the
    * swizzle values are { 3, 2, 4, 5 }.  Since 4 and 5 are outside the range
    * [0,3], the error is detected.
    */
   static const unsigned char idx_map[26] = {
   /* a    b    c    d    e    f    g    h    i    j    k    l    m */
      R+3, R+2, 0,   0,   0,   0,   R+1, 0,   0,   0,   0,   0,   0,
   /* n    o    p    q    r    s    t    u    v    w    x    y    z */
      0,   0,   S+2, S+3, R+0, S+0, S+1, 0,   0,   X+3, X+0, X+1, X+2
   };

   int swiz_idx[4] = { 0, 0, 0, 0 };
   unsigned i;


   /* Validate the first character in the swizzle string and look up the base
    * index value as described above.
    */
   if ((str[0] < 'a') || (str[0] > 'z'))
      return NULL;

   const unsigned base = base_idx[str[0] - 'a'];


   for (i = 0; (i < 4) && (str[i] != '\0'); i++) {
      /* Validate the next character, and, as described above, convert it to a
       * swizzle index.
       */
      if ((str[i] < 'a') || (str[i] > 'z'))
	 return NULL;

      swiz_idx[i] = idx_map[str[i] - 'a'] - base;
      if ((swiz_idx[i] < 0) || (swiz_idx[i] >= (int) vector_length))
	 return NULL;
   }

   if (str[i] != '\0')
	 return NULL;

   return new(ctx) ir_swizzle(val, swiz_idx[0], swiz_idx[1], swiz_idx[2],
			      swiz_idx[3], i);
}

#undef X
#undef R
#undef S
#undef I

ir_variable *
ir_swizzle::variable_referenced() const
{
   return this->val->variable_referenced();
}


ir_variable::ir_variable(const struct glsl_type *type, const char *name,
			 ir_variable_mode mode)
   : max_ifc_array_access(NULL)
{
   this->ir_type = ir_type_variable;
   this->type = type;
   this->name = ralloc_strdup(this, name);
   this->data.explicit_location = false;
   this->data.has_initializer = false;
   this->data.location = -1;
   this->data.location_frac = 0;
   this->warn_extension = NULL;
   this->constant_value = NULL;
   this->constant_initializer = NULL;
   this->data.origin_upper_left = false;
   this->data.pixel_center_integer = false;
   this->data.depth_layout = ir_depth_layout_none;
   this->data.used = false;
   this->data.read_only = false;
   this->data.centroid = false;
   this->data.sample = false;
   this->data.invariant = false;
   this->data.how_declared = ir_var_declared_normally;
   this->data.mode = mode;
   this->data.interpolation = INTERP_QUALIFIER_NONE;
   this->data.max_array_access = 0;
   this->data.atomic.buffer_index = 0;
   this->data.atomic.offset = 0;
   this->data.image.read_only = false;
   this->data.image.write_only = false;
   this->data.image.coherent = false;
   this->data.image._volatile = false;
   this->data.image.restrict_flag = false;

   if (type != NULL) {
      if (type->base_type == GLSL_TYPE_SAMPLER)
         this->data.read_only = true;

      if (type->is_interface())
         this->init_interface_type(type);
      else if (type->is_array() && type->fields.array->is_interface())
         this->init_interface_type(type->fields.array);
   }
}


const char *
interpolation_string(unsigned interpolation)
{
   switch (interpolation) {
   case INTERP_QUALIFIER_NONE:          return "no";
   case INTERP_QUALIFIER_SMOOTH:        return "smooth";
   case INTERP_QUALIFIER_FLAT:          return "flat";
   case INTERP_QUALIFIER_NOPERSPECTIVE: return "noperspective";
   }

   assert(!"Should not get here.");
   return "";
}


glsl_interp_qualifier
ir_variable::determine_interpolation_mode(bool flat_shade)
{
   if (this->data.interpolation != INTERP_QUALIFIER_NONE)
      return (glsl_interp_qualifier) this->data.interpolation;
   int location = this->data.location;
   bool is_gl_Color =
      location == VARYING_SLOT_COL0 || location == VARYING_SLOT_COL1;
   if (flat_shade && is_gl_Color)
      return INTERP_QUALIFIER_FLAT;
   else
      return INTERP_QUALIFIER_SMOOTH;
}


ir_function_signature::ir_function_signature(const glsl_type *return_type,
                                             builtin_available_predicate b)
   : return_type(return_type), is_defined(false), is_intrinsic(false),
     builtin_avail(b), _function(NULL)
{
   this->ir_type = ir_type_function_signature;
   this->origin = NULL;
}


bool
ir_function_signature::is_builtin() const
{
   return builtin_avail != NULL;
}


bool
ir_function_signature::is_builtin_available(const _mesa_glsl_parse_state *state) const
{
   /* We can't call the predicate without a state pointer, so just say that
    * the signature is available.  At compile time, we need the filtering,
    * but also receive a valid state pointer.  At link time, we're resolving
    * imported built-in prototypes to their definitions, which will always
    * be an exact match.  So we can skip the filtering.
    */
   if (state == NULL)
      return true;

   assert(builtin_avail != NULL);
   return builtin_avail(state);
}


static bool
modes_match(unsigned a, unsigned b)
{
   if (a == b)
      return true;

   /* Accept "in" vs. "const in" */
   if ((a == ir_var_const_in && b == ir_var_function_in) ||
       (b == ir_var_const_in && a == ir_var_function_in))
      return true;

   return false;
}


const char *
ir_function_signature::qualifiers_match(exec_list *params)
{
   /* check that the qualifiers match. */
   foreach_two_lists(a_node, &this->parameters, b_node, params) {
      ir_variable *a = (ir_variable *) a_node;
      ir_variable *b = (ir_variable *) b_node;

      if (a->data.read_only != b->data.read_only ||
	  !modes_match(a->data.mode, b->data.mode) ||
	  a->data.interpolation != b->data.interpolation ||
	  a->data.centroid != b->data.centroid ||
          a->data.sample != b->data.sample ||
          a->data.image.read_only != b->data.image.read_only ||
          a->data.image.write_only != b->data.image.write_only ||
          a->data.image.coherent != b->data.image.coherent ||
          a->data.image._volatile != b->data.image._volatile ||
          a->data.image.restrict_flag != b->data.image.restrict_flag) {

	 /* parameter a's qualifiers don't match */
	 return a->name;
      }
   }
   return NULL;
}


void
ir_function_signature::replace_parameters(exec_list *new_params)
{
   /* Destroy all of the previous parameter information.  If the previous
    * parameter information comes from the function prototype, it may either
    * specify incorrect parameter names or not have names at all.
    */
   new_params->move_nodes_to(&parameters);
}


ir_function::ir_function(const char *name)
{
   this->ir_type = ir_type_function;
   this->name = ralloc_strdup(this, name);
}


bool
ir_function::has_user_signature()
{
   foreach_list(n, &this->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;
      if (!sig->is_builtin())
	 return true;
   }
   return false;
}


ir_rvalue *
ir_rvalue::error_value(void *mem_ctx)
{
   ir_rvalue *v = new(mem_ctx) ir_rvalue;

   v->type = glsl_type::error_type;
   return v;
}


void
visit_exec_list(exec_list *list, ir_visitor *visitor)
{
   foreach_list_safe(n, list) {
      ((ir_instruction *) n)->accept(visitor);
   }
}


static void
steal_memory(ir_instruction *ir, void *new_ctx)
{
   ir_variable *var = ir->as_variable();
   ir_constant *constant = ir->as_constant();
   if (var != NULL && var->constant_value != NULL)
      steal_memory(var->constant_value, ir);

   if (var != NULL && var->constant_initializer != NULL)
      steal_memory(var->constant_initializer, ir);

   /* The components of aggregate constants are not visited by the normal
    * visitor, so steal their values by hand.
    */
   if (constant != NULL) {
      if (constant->type->is_record()) {
	 foreach_list(n, &constant->components) {
	    ir_constant *field = (ir_constant *) n;
	    steal_memory(field, ir);
	 }
      } else if (constant->type->is_array()) {
	 for (unsigned int i = 0; i < constant->type->length; i++) {
	    steal_memory(constant->array_elements[i], ir);
	 }
      }
   }

   ralloc_steal(new_ctx, ir);
}


void
reparent_ir(exec_list *list, void *mem_ctx)
{
   foreach_list(node, list) {
      visit_tree((ir_instruction *) node, steal_memory, mem_ctx);
   }
}


static ir_rvalue *
try_min_one(ir_rvalue *ir)
{
   ir_expression *expr = ir->as_expression();

   if (!expr || expr->operation != ir_binop_min)
      return NULL;

   if (expr->operands[0]->is_one())
      return expr->operands[1];

   if (expr->operands[1]->is_one())
      return expr->operands[0];

   return NULL;
}

static ir_rvalue *
try_max_zero(ir_rvalue *ir)
{
   ir_expression *expr = ir->as_expression();

   if (!expr || expr->operation != ir_binop_max)
      return NULL;

   if (expr->operands[0]->is_zero())
      return expr->operands[1];

   if (expr->operands[1]->is_zero())
      return expr->operands[0];

   return NULL;
}

ir_rvalue *
ir_rvalue::as_rvalue_to_saturate()
{
   ir_expression *expr = this->as_expression();

   if (!expr)
      return NULL;

   ir_rvalue *max_zero = try_max_zero(expr);
   if (max_zero) {
      return try_min_one(max_zero);
   } else {
      ir_rvalue *min_one = try_min_one(expr);
      if (min_one) {
	 return try_max_zero(min_one);
      }
   }

   return NULL;
}


unsigned
vertices_per_prim(GLenum prim)
{
   switch (prim) {
   case GL_POINTS:
      return 1;
   case GL_LINES:
      return 2;
   case GL_TRIANGLES:
      return 3;
   case GL_LINES_ADJACENCY:
      return 4;
   case GL_TRIANGLES_ADJACENCY:
      return 6;
   default:
      assert(!"Bad primitive");
      return 3;
   }
}

/**
 * Generate a string describing the mode of a variable
 */
const char *
mode_string(const ir_variable *var)
{
   switch (var->data.mode) {
   case ir_var_auto:
      return (var->data.read_only) ? "global constant" : "global variable";

   case ir_var_uniform:
      return "uniform";

   case ir_var_shader_in:
      return "shader input";

   case ir_var_shader_out:
      return "shader output";

   case ir_var_function_in:
   case ir_var_const_in:
      return "function input";

   case ir_var_function_out:
      return "function output";

   case ir_var_function_inout:
      return "function inout";

   case ir_var_system_value:
      return "shader input";

   case ir_var_temporary:
      return "compiler temporary";

   case ir_var_mode_count:
      break;
   }

   assert(!"Should not get here.");
   return "invalid variable";
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d26 1
d29 1
a29 2
ir_rvalue::ir_rvalue(enum ir_node_type t)
   : ir_instruction(t)
d49 5
a155 1
   : ir_instruction(ir_type_assignment)
d157 1
a175 1
   : ir_instruction(ir_type_assignment)
d177 1
a200 1
   : ir_rvalue(ir_type_expression)
d202 1
a217 1
   : ir_rvalue(ir_type_expression)
d219 2
a251 2
   case ir_unop_dFdx_coarse:
   case ir_unop_dFdx_fine:
a252 2
   case ir_unop_dFdy_coarse:
   case ir_unop_dFdy_fine:
a253 2
   case ir_unop_interpolate_at_centroid:
   case ir_unop_saturate:
a326 1
   : ir_rvalue(ir_type_expression)
d328 2
a407 2
   case ir_binop_interpolate_at_offset:
   case ir_binop_interpolate_at_sample:
a422 1
   : ir_rvalue(ir_type_expression)
d424 2
a511 2
   "dFdxCoarse",
   "dFdxFine",
a512 2
   "dFdyCoarse",
   "dFdyFine",
a528 1
   "sat",
a529 1
   "interpolate_at_centroid",
a562 2
   "interpolate_at_offset",
   "interpolate_at_sample",
a612 1
   : ir_rvalue(ir_type_constant)
d614 1
a618 1
   : ir_rvalue(ir_type_constant)
d623 1
a628 1
   : ir_rvalue(ir_type_constant)
d631 1
a641 1
   : ir_rvalue(ir_type_constant)
d644 1
a654 1
   : ir_rvalue(ir_type_constant)
d657 1
a667 1
   : ir_rvalue(ir_type_constant)
d670 1
a680 1
   : ir_rvalue(ir_type_constant)
d682 1
a694 1
   : ir_rvalue(ir_type_constant)
d696 1
d705 2
a706 1
      foreach_in_list(ir_constant, value, value_list) {
d1007 3
a1009 1
      foreach_in_list(ir_constant, orig, &src->components) {
d1184 43
a1235 1
   : ir_instruction(ir_type_loop)
d1237 1
a1241 1
   : ir_dereference(ir_type_dereference_variable)
d1245 1
a1252 1
   : ir_dereference(ir_type_dereference_array)
d1254 1
a1261 1
   : ir_dereference(ir_type_dereference_array)
d1265 1
a1291 1
   : ir_dereference(ir_type_dereference_record)
d1295 1
a1303 1
   : ir_dereference(ir_type_dereference_record)
d1307 1
d1424 1
a1424 1
   : ir_rvalue(ir_type_swizzle), val(val)
d1427 1
d1433 1
a1433 1
   : ir_rvalue(ir_type_swizzle), val(val)
d1435 1
a1439 1
   : ir_rvalue(ir_type_swizzle)
d1441 1
a1537 4
bool ir_variable::temporaries_allocate_names = false;

const char ir_variable::tmp_name[] = "compiler_temp";

d1540 1
a1540 1
   : ir_instruction(ir_type_variable)
d1542 1
d1544 1
a1544 23

   if (mode == ir_var_temporary && !ir_variable::temporaries_allocate_names)
      name = NULL;

   /* The ir_variable clone method may call this constructor with name set to
    * tmp_name.
    */
   assert(name != NULL
          || mode == ir_var_temporary
          || mode == ir_var_function_in
          || mode == ir_var_function_out
          || mode == ir_var_function_inout);
   assert(name != ir_variable::tmp_name
          || mode == ir_var_temporary);
   if (mode == ir_var_temporary
       && (name == NULL || name == ir_variable::tmp_name)) {
      this->name = ir_variable::tmp_name;
   } else {
      this->name = ralloc_strdup(this, name);
   }

   this->u.max_ifc_array_access = NULL;

d1549 1
a1549 2
   this->data.binding = 0;
   this->data.warn_extension_index = 0;
d1564 1
d1566 5
a1570 5
   this->data.image_read_only = false;
   this->data.image_write_only = false;
   this->data.image_coherent = false;
   this->data.image_volatile = false;
   this->data.image_restrict = false;
a1612 26
const char *const ir_variable::warn_extension_table[] = {
   "",
   "GL_ARB_shader_stencil_export",
   "GL_AMD_shader_stencil_export",
};

void
ir_variable::enable_extension_warning(const char *extension)
{
   for (unsigned i = 0; i < Elements(warn_extension_table); i++) {
      if (strcmp(warn_extension_table[i], extension) == 0) {
         this->data.warn_extension_index = i;
         return;
      }
   }

   assert(!"Should not get here.");
   this->data.warn_extension_index = 0;
}

const char *
ir_variable::get_extension_warning() const
{
   return this->data.warn_extension_index == 0
      ? NULL : warn_extension_table[this->data.warn_extension_index];
}
d1616 1
a1616 2
   : ir_instruction(ir_type_function_signature),
     return_type(return_type), is_defined(false), is_intrinsic(false),
d1619 1
d1676 5
a1680 5
          a->data.image_read_only != b->data.image_read_only ||
          a->data.image_write_only != b->data.image_write_only ||
          a->data.image_coherent != b->data.image_coherent ||
          a->data.image_volatile != b->data.image_volatile ||
          a->data.image_restrict != b->data.image_restrict) {
a1701 1
   : ir_instruction(ir_type_function)
d1703 1
d1711 2
a1712 1
   foreach_in_list(ir_function_signature, sig, &this->signatures) {
d1723 1
a1723 1
   ir_rvalue *v = new(mem_ctx) ir_rvalue(ir_type_unset);
d1733 2
a1734 2
   foreach_in_list_safe(ir_instruction, node, list) {
      node->accept(visitor);
d1755 2
a1756 1
	 foreach_in_list(ir_constant, field, &constant->components) {
d1773 2
a1774 2
   foreach_in_list(ir_instruction, node, list) {
      visit_tree(node, steal_memory, mem_ctx);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a25 1
#include "ir_visitor.h"
d28 2
a29 1
ir_rvalue::ir_rvalue()
a48 5
bool ir_rvalue::is_basis() const
{
   return false;
}

d151 1
a152 1
   this->ir_type = ir_type_assignment;
d171 1
a172 1
   this->ir_type = ir_type_assignment;
d196 1
a197 1
   this->ir_type = ir_type_expression;
d213 1
a214 2
   this->ir_type = ir_type_expression;

d246 2
d249 2
d252 2
d327 1
a328 2
   this->ir_type = ir_type_expression;

d407 2
d424 1
a425 2
   this->ir_type = ir_type_expression;

d512 2
d515 2
d533 1
d535 1
d569 2
d621 1
a622 1
   this->ir_type = ir_type_constant;
d627 1
a631 1
   this->ir_type = ir_type_constant;
d637 1
a639 1
   this->ir_type = ir_type_constant;
d650 1
a652 1
   this->ir_type = ir_type_constant;
d663 1
a665 1
   this->ir_type = ir_type_constant;
d676 1
a678 1
   this->ir_type = ir_type_constant;
d689 1
a690 1
   this->ir_type = ir_type_constant;
d703 1
a704 1
   this->ir_type = ir_type_constant;
d713 1
a713 2
      foreach_list(node, value_list) {
	 ir_constant *value = (ir_constant *) node;
d1014 1
a1014 3
      foreach_list(node, &src->components) {
	 ir_constant *const orig = (ir_constant *) node;

a1188 43
ir_constant::is_basis() const
{
   if (!this->type->is_scalar() && !this->type->is_vector())
      return false;

   if (this->type->is_boolean())
      return false;

   unsigned ones = 0;
   for (unsigned c = 0; c < this->type->vector_elements; c++) {
      switch (this->type->base_type) {
      case GLSL_TYPE_FLOAT:
	 if (this->value.f[c] == 1.0)
	    ones++;
	 else if (this->value.f[c] != 0.0)
	    return false;
	 break;
      case GLSL_TYPE_INT:
	 if (this->value.i[c] == 1)
	    ones++;
	 else if (this->value.i[c] != 0)
	    return false;
	 break;
      case GLSL_TYPE_UINT:
	 if (int(this->value.u[c]) == 1)
	    ones++;
	 else if (int(this->value.u[c]) != 0)
	    return false;
	 break;
      default:
	 /* The only other base types are structures, arrays, samplers, and
	  * booleans.  Samplers cannot be constants, and the others should
	  * have been filtered out above.
	  */
	 assert(!"Should not get here.");
	 return false;
      }
   }

   return ones == 1;
}

bool
d1198 1
a1199 1
   this->ir_type = ir_type_loop;
d1204 1
a1207 1
   this->ir_type = ir_type_dereference_variable;
d1215 1
a1216 1
   this->ir_type = ir_type_dereference_array;
d1224 1
a1227 1
   this->ir_type = ir_type_dereference_array;
d1254 1
a1257 1
   this->ir_type = ir_type_dereference_record;
d1266 1
a1269 1
   this->ir_type = ir_type_dereference_record;
d1386 1
a1386 1
   : val(val)
a1388 1
   this->ir_type = ir_type_swizzle;
d1394 1
a1394 1
   : val(val)
a1395 1
   this->ir_type = ir_type_swizzle;
d1400 1
a1401 1
   this->ir_type = ir_type_swizzle;
d1498 4
d1504 1
a1504 1
   : max_ifc_array_access(NULL)
a1505 1
   this->ir_type = ir_type_variable;
d1507 23
a1529 1
   this->name = ralloc_strdup(this, name);
d1534 2
a1535 1
   this->warn_extension = NULL;
a1549 1
   this->data.atomic.buffer_index = 0;
d1551 5
a1555 5
   this->data.image.read_only = false;
   this->data.image.write_only = false;
   this->data.image.coherent = false;
   this->data.image._volatile = false;
   this->data.image.restrict_flag = false;
d1598 26
d1627 2
a1628 1
   : return_type(return_type), is_defined(false), is_intrinsic(false),
a1630 1
   this->ir_type = ir_type_function_signature;
d1687 5
a1691 5
          a->data.image.read_only != b->data.image.read_only ||
          a->data.image.write_only != b->data.image.write_only ||
          a->data.image.coherent != b->data.image.coherent ||
          a->data.image._volatile != b->data.image._volatile ||
          a->data.image.restrict_flag != b->data.image.restrict_flag) {
d1713 1
a1714 1
   this->ir_type = ir_type_function;
d1722 1
a1722 2
   foreach_list(n, &this->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;
d1733 1
a1733 1
   ir_rvalue *v = new(mem_ctx) ir_rvalue;
d1743 2
a1744 2
   foreach_list_safe(n, list) {
      ((ir_instruction *) n)->accept(visitor);
d1765 1
a1765 2
	 foreach_list(n, &constant->components) {
	    ir_constant *field = (ir_constant *) n;
d1782 2
a1783 2
   foreach_list(node, list) {
      visit_tree((ir_instruction *) node, steal_memory, mem_ctx);
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d253 1
d261 3
d401 3
d406 2
d421 32
d533 1
d535 2
d561 1
d563 1
d565 1
d628 1
a628 1
ir_constant::ir_constant(float f)
d630 1
d632 5
a636 3
   this->type = glsl_type::float_type;
   this->value.f[0] = f;
   for (int i = 1; i < 16; i++)  {
d641 1
a641 1
ir_constant::ir_constant(unsigned int u)
d643 1
d645 5
a649 3
   this->type = glsl_type::uint_type;
   this->value.u[0] = u;
   for (int i = 1; i < 16; i++) {
d654 1
a654 1
ir_constant::ir_constant(int i)
d656 1
d658 5
a662 3
   this->type = glsl_type::int_type;
   this->value.i[0] = i;
   for (int i = 1; i < 16; i++) {
d667 1
a667 1
ir_constant::ir_constant(bool b)
d669 1
d671 5
a675 3
   this->type = glsl_type::bool_type;
   this->value.b[0] = b;
   for (int i = 1; i < 16; i++) {
d1125 1
a1125 1
ir_constant::is_zero() const
d1130 4
d1137 1
a1137 1
	 if (this->value.f[c] != 0.0)
d1141 1
a1141 1
	 if (this->value.i[c] != 0)
d1145 1
a1145 1
	 if (this->value.u[c] != 0)
d1149 1
a1149 1
	 if (this->value.b[c] != false)
d1166 6
d1174 1
a1174 32
   if (!this->type->is_scalar() && !this->type->is_vector())
      return false;

   for (unsigned c = 0; c < this->type->vector_elements; c++) {
      switch (this->type->base_type) {
      case GLSL_TYPE_FLOAT:
	 if (this->value.f[c] != 1.0)
	    return false;
	 break;
      case GLSL_TYPE_INT:
	 if (this->value.i[c] != 1)
	    return false;
	 break;
      case GLSL_TYPE_UINT:
	 if (this->value.u[c] != 1)
	    return false;
	 break;
      case GLSL_TYPE_BOOL:
	 if (this->value.b[c] != true)
	    return false;
	 break;
      default:
	 /* The only other base types are structures, arrays, and samplers.
	  * Samplers cannot be constants, and the others should have been
	  * filtered out above.
	  */
	 assert(!"Should not get here.");
	 return false;
      }
   }

   return true;
d1180 1
a1180 31
   if (!this->type->is_scalar() && !this->type->is_vector())
      return false;

   if (this->type->is_boolean())
      return false;

   for (unsigned c = 0; c < this->type->vector_elements; c++) {
      switch (this->type->base_type) {
      case GLSL_TYPE_FLOAT:
	 if (this->value.f[c] != -1.0)
	    return false;
	 break;
      case GLSL_TYPE_INT:
	 if (this->value.i[c] != -1)
	    return false;
	 break;
      case GLSL_TYPE_UINT:
	 if (int(this->value.u[c]) != -1)
	    return false;
	 break;
      default:
	 /* The only other base types are structures, arrays, samplers, and
	  * booleans.  Samplers cannot be constants, and the others should
	  * have been filtered out above.
	  */
	 assert(!"Should not get here.");
	 return false;
      }
   }

   return true;
d1226 9
a1237 5
   this->cmp = ir_unop_neg;
   this->from = NULL;
   this->to = NULL;
   this->increment = NULL;
   this->counter = NULL;
d1320 1
a1320 1
   if ((var == NULL) || var->read_only)
d1323 1
a1323 1
   /* From page 17 (page 23 of the PDF) of the GLSL 1.20 spec:
d1325 3
a1327 3
    *    "Samplers cannot be treated as l-values; hence cannot be used
    *     as out or inout function parameters, nor can they be
    *     assigned into."
d1329 1
a1329 1
   if (this->type->contains_sampler())
d1336 1
a1336 1
static const char *tex_opcode_strs[] = { "tex", "txb", "txl", "txd", "txf", "txf_ms", "txs", "lod" };
d1365 1
a1365 1
   if (this->op == ir_txs) {
d1540 1
a1540 2
   : max_array_access(0), read_only(false), centroid(false), invariant(false),
     mode(mode), interpolation(INTERP_QUALIFIER_NONE)
d1545 4
a1548 4
   this->explicit_location = false;
   this->has_initializer = false;
   this->location = -1;
   this->location_frac = 0;
d1552 29
a1580 7
   this->origin_upper_left = false;
   this->pixel_center_integer = false;
   this->depth_layout = ir_depth_layout_none;
   this->used = false;

   if (type && type->base_type == GLSL_TYPE_SAMPLER)
      this->read_only = true;
d1585 1
a1585 1
ir_variable::interpolation_string() const
d1587 1
a1587 1
   switch (this->interpolation) {
d1602 3
a1604 3
   if (this->interpolation != INTERP_QUALIFIER_NONE)
      return (glsl_interp_qualifier) this->interpolation;
   int location = this->location;
d1614 4
a1617 2
ir_function_signature::ir_function_signature(const glsl_type *return_type)
   : return_type(return_type), is_defined(false), _function(NULL)
a1619 1
   this->is_builtin = false;
d1624 24
a1665 3
   exec_list_iterator iter_a = parameters.iterator();
   exec_list_iterator iter_b = params->iterator();

d1667 14
a1680 8
   while (iter_a.has_next()) {
      ir_variable *a = (ir_variable *)iter_a.get();
      ir_variable *b = (ir_variable *)iter_b.get();

      if (a->read_only != b->read_only ||
	  !modes_match(a->mode, b->mode) ||
	  a->interpolation != b->interpolation ||
	  a->centroid != b->centroid) {
a1684 3

      iter_a.next();
      iter_b.next();
a1696 6
   foreach_iter(exec_list_iterator, iter, parameters) {
      assert(((ir_instruction *) iter.get())->as_variable() != NULL);

      iter.remove();
   }

d1713 1
a1713 1
      if (!sig->is_builtin)
d1733 2
a1734 2
   foreach_iter(exec_list_iterator, iter, *list) {
      ((ir_instruction *)iter.get())->accept(visitor);
d1755 2
a1756 2
	 foreach_iter(exec_list_iterator, iter, constant->components) {
	    ir_constant *field = (ir_constant *)iter.get();
d1832 64
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d49 5
a197 28

ir_expression::ir_expression(int op, const struct glsl_type *type,
			     ir_rvalue *op0)
{
   assert(get_num_operands(ir_expression_operation(op)) == 1);
   this->ir_type = ir_type_expression;
   this->type = type;
   this->operation = ir_expression_operation(op);
   this->operands[0] = op0;
   this->operands[1] = NULL;
   this->operands[2] = NULL;
   this->operands[3] = NULL;
}

ir_expression::ir_expression(int op, const struct glsl_type *type,
			     ir_rvalue *op0, ir_rvalue *op1)
{
   assert(((op1 == NULL) && (get_num_operands(ir_expression_operation(op)) == 1))
	  || (get_num_operands(ir_expression_operation(op)) == 2));
   this->ir_type = ir_type_expression;
   this->type = type;
   this->operation = ir_expression_operation(op);
   this->operands[0] = op0;
   this->operands[1] = op1;
   this->operands[2] = NULL;
   this->operands[3] = NULL;
}

d209 6
d258 2
d267 2
d279 7
d287 2
d296 19
d366 2
d369 1
a369 1
	 this->type = op1->type;
d371 4
a374 1
	 this->type = op0->type;
d393 4
d402 4
d423 4
a426 1
   if (op == ir_quadop_vector)
d447 1
d454 6
d472 16
d514 9
d774 2
a775 1
   assert(type->is_numeric() || type->is_boolean());
d781 14
d822 1
a822 1
   case GLSL_TYPE_BOOL:  return this->value.b[i] ? 1.0 : 0.0;
d914 89
d1175 43
d1231 2
d1235 1
a1235 1
   this->type = (var != NULL) ? var->type : glsl_type::error_type;
d1262 2
a1264 1
   this->type = glsl_type::error_type;
d1266 1
a1266 2
   if (this->array != NULL) {
      const glsl_type *const vt = this->array->type;
d1268 6
a1273 7
      if (vt->is_array()) {
	 type = vt->element_type();
      } else if (vt->is_matrix()) {
	 type = vt->column_type();
      } else if (vt->is_vector()) {
	 type = vt->get_base_type();
      }
d1281 2
d1286 1
a1286 2
   this->type = (this->record != NULL)
      ? this->record->type->field_type(field) : glsl_type::error_type;
d1298 1
a1298 2
   this->type = (this->record != NULL)
      ? this->record->type->field_type(field) : glsl_type::error_type;
d1302 1
a1302 1
ir_dereference::is_lvalue()
d1324 1
a1324 1
const char *tex_opcode_strs[] = { "tex", "txb", "txl", "txd", "txf" };
d1353 12
a1364 5
   assert(sampler->type->sampler_type == (int) type->base_type);
   if (sampler->type->sampler_shadow)
      assert(type->vector_elements == 4 || type->vector_elements == 1);
   else
      assert(type->vector_elements == 4);
d1520 1
a1520 1
ir_swizzle::variable_referenced()
d1529 1
a1529 1
     mode(mode), interpolation(ir_var_smooth)
d1535 1
d1537 1
d1540 1
d1555 4
a1558 3
   case ir_var_smooth:        return "smooth";
   case ir_var_flat:          return "flat";
   case ir_var_noperspective: return "noperspective";
d1566 2
a1567 2
unsigned
ir_variable::component_slots() const
d1569 9
a1577 2
   /* FINISHME: Sparsely accessed arrays require fewer slots. */
   return this->type->component_slots();
d1586 1
d1597 2
a1598 2
   if ((a == ir_var_const_in && b == ir_var_in) ||
       (b == ir_var_const_in && a == ir_var_in))
d1668 2
a1669 2
ir_call *
ir_call::get_error_instruction(void *ctx)
d1671 1
a1671 1
   ir_call *call = new(ctx) ir_call;
d1673 2
a1674 2
   call->type = glsl_type::error_type;
   return call;
a1676 7
void
ir_call::set_callee(ir_function_signature *sig)
{
   assert((this->type == NULL) || (this->type == sig->return_type));

   this->callee = sig;
}
d1694 3
@


1.1
log
@Initial revision
@
text
@d264 1
d266 2
d273 23
d331 2
d346 1
d348 3
d358 11
d373 5
d475 16
a1099 3
   if (this->type->is_array() && !var->array_lvalue)
      return false;

d1135 1
a1135 1
ir_texture::set_sampler(ir_dereference *sampler)
d1138 1
d1140 1
d1142 5
a1146 11
   switch (sampler->type->sampler_type) {
   case GLSL_TYPE_FLOAT:
      this->type = glsl_type::vec4_type;
      break;
   case GLSL_TYPE_INT:
      this->type = glsl_type::ivec4_type;
      break;
   case GLSL_TYPE_UINT:
      this->type = glsl_type::uvec4_type;
      break;
   }
d1311 1
a1311 1
     mode(mode), interpolation(ir_var_smooth), array_lvalue(false)
d1322 1
d1360 15
d1387 1
a1387 1
	  a->mode != b->mode ||
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a48 5
bool ir_rvalue::is_basis() const
{
   return false;
}

d193 28
a231 6
#ifndef NDEBUG
   int num_operands = get_num_operands(this->operation);
   for (int i = num_operands; i < 4; i++) {
      assert(this->operands[i] == NULL);
   }
#endif
a263 1
   case ir_unop_sin:
a264 2
   case ir_unop_sin_reduced:
   case ir_unop_cos_reduced:
a269 36
   case ir_unop_f2i:
   case ir_unop_b2i:
   case ir_unop_u2i:
   case ir_unop_bitcast_f2i:
      this->type = glsl_type::get_instance(GLSL_TYPE_INT,
					   op0->type->vector_elements, 1);
      break;

   case ir_unop_b2f:
   case ir_unop_i2f:
   case ir_unop_u2f:
   case ir_unop_bitcast_i2f:
   case ir_unop_bitcast_u2f:
      this->type = glsl_type::get_instance(GLSL_TYPE_FLOAT,
					   op0->type->vector_elements, 1);
      break;

   case ir_unop_f2b:
   case ir_unop_i2b:
      this->type = glsl_type::get_instance(GLSL_TYPE_BOOL,
					   op0->type->vector_elements, 1);
      break;

   case ir_unop_i2u:
   case ir_unop_f2u:
   case ir_unop_bitcast_f2u:
      this->type = glsl_type::get_instance(GLSL_TYPE_UINT,
					   op0->type->vector_elements, 1);
      break;

   case ir_unop_noise:
   case ir_unop_unpack_half_2x16_split_x:
   case ir_unop_unpack_half_2x16_split_y:
      this->type = glsl_type::float_type;
      break;

a273 19
   case ir_unop_pack_snorm_2x16:
   case ir_unop_pack_snorm_4x8:
   case ir_unop_pack_unorm_2x16:
   case ir_unop_pack_unorm_4x8:
   case ir_unop_pack_half_2x16:
      this->type = glsl_type::uint_type;
      break;

   case ir_unop_unpack_snorm_2x16:
   case ir_unop_unpack_unorm_2x16:
   case ir_unop_unpack_half_2x16:
      this->type = glsl_type::vec2_type;
      break;

   case ir_unop_unpack_snorm_4x8:
   case ir_unop_unpack_unorm_4x8:
      this->type = glsl_type::vec4_type;
      break;

a304 2
   case ir_binop_div:
   case ir_binop_mod:
a317 1
   case ir_binop_logic_xor:
a318 5
   case ir_binop_bit_and:
   case ir_binop_bit_xor:
   case ir_binop_bit_or:
       assert(!op0->type->is_matrix());
       assert(!op1->type->is_matrix());
d320 1
a320 1
         this->type = op1->type;
d322 1
a322 4
         this->type = op0->type;
      } else {
          assert(op0->type->vector_elements == op1->type->vector_elements);
          this->type = op0->type;
a325 11
   case ir_binop_equal:
   case ir_binop_nequal:
   case ir_binop_lequal:
   case ir_binop_gequal:
   case ir_binop_less:
   case ir_binop_greater:
      assert(op0->type == op1->type);
      this->type = glsl_type::get_instance(GLSL_TYPE_BOOL,
					   op0->type->vector_elements, 1);
      break;

a329 13
   case ir_binop_pack_half_2x16_split:
      this->type = glsl_type::uint_type;
      break;

   case ir_binop_lshift:
   case ir_binop_rshift:
      this->type = op0->type;
      break;

   case ir_binop_vector_extract:
      this->type = op0->type->get_scalar_type();
      break;

d347 1
a347 4
   if (op <= ir_last_triop)
      return 3;

   if (op <= ir_last_quadop)
a367 1
   "f2u",
a373 6
   "i2u",
   "u2i",
   "bitcast_i2f",
   "bitcast_f2i",
   "bitcast_u2f",
   "bitcast_f2u",
a385 16
   "packSnorm2x16",
   "packSnorm4x8",
   "packUnorm2x16",
   "packUnorm4x8",
   "packHalf2x16",
   "unpackSnorm2x16",
   "unpackSnorm4x8",
   "unpackUnorm2x16",
   "unpackUnorm4x8",
   "unpackHalf2x16",
   "unpackHalf2x16_split_x",
   "unpackHalf2x16_split_y",
   "bitfield_reverse",
   "bit_count",
   "find_msb",
   "find_lsb",
a411 9
   "packHalf2x16_split",
   "bfm",
   "ubo_load",
   "vector_extract",
   "lrp",
   "bfi",
   "bitfield_extract",
   "vector_insert",
   "bitfield_insert",
a426 16
const char*
depth_layout_string(ir_depth_layout layout)
{
   switch(layout) {
   case ir_depth_layout_none:      return "";
   case ir_depth_layout_any:       return "depth_any";
   case ir_depth_layout_greater:   return "depth_greater";
   case ir_depth_layout_less:      return "depth_less";
   case ir_depth_layout_unchanged: return "depth_unchanged";

   default:
      assert(0);
      return "";
   }
}

d647 1
a647 2
   assert(type->is_scalar() || type->is_vector() || type->is_matrix()
	  || type->is_record() || type->is_array());
a652 14
   if (type->is_array()) {
      c->array_elements = ralloc_array(c, ir_constant *, type->length);

      for (unsigned i = 0; i < type->length; i++)
	 c->array_elements[i] = ir_constant::zero(c, type->element_type());
   }

   if (type->is_record()) {
      for (unsigned i = 0; i < type->length; i++) {
	 ir_constant *comp = ir_constant::zero(mem_ctx, type->fields.structure[i].type);
	 c->components.push_tail(comp);
      }
   }

d680 1
a680 1
   case GLSL_TYPE_BOOL:  return this->value.b[i] ? 1.0f : 0.0f;
a771 89
void
ir_constant::copy_offset(ir_constant *src, int offset)
{
   switch (this->type->base_type) {
   case GLSL_TYPE_UINT:
   case GLSL_TYPE_INT:
   case GLSL_TYPE_FLOAT:
   case GLSL_TYPE_BOOL: {
      unsigned int size = src->type->components();
      assert (size <= this->type->components() - offset);
      for (unsigned int i=0; i<size; i++) {
	 switch (this->type->base_type) {
	 case GLSL_TYPE_UINT:
	    value.u[i+offset] = src->get_uint_component(i);
	    break;
	 case GLSL_TYPE_INT:
	    value.i[i+offset] = src->get_int_component(i);
	    break;
	 case GLSL_TYPE_FLOAT:
	    value.f[i+offset] = src->get_float_component(i);
	    break;
	 case GLSL_TYPE_BOOL:
	    value.b[i+offset] = src->get_bool_component(i);
	    break;
	 default: // Shut up the compiler
	    break;
	 }
      }
      break;
   }

   case GLSL_TYPE_STRUCT: {
      assert (src->type == this->type);
      this->components.make_empty();
      foreach_list(node, &src->components) {
	 ir_constant *const orig = (ir_constant *) node;

	 this->components.push_tail(orig->clone(this, NULL));
      }
      break;
   }

   case GLSL_TYPE_ARRAY: {
      assert (src->type == this->type);
      for (unsigned i = 0; i < this->type->length; i++) {
	 this->array_elements[i] = src->array_elements[i]->clone(this, NULL);
      }
      break;
   }

   default:
      assert(!"Should not get here.");
      break;
   }
}

void
ir_constant::copy_masked_offset(ir_constant *src, int offset, unsigned int mask)
{
   assert (!type->is_array() && !type->is_record());

   if (!type->is_vector() && !type->is_matrix()) {
      offset = 0;
      mask = 1;
   }

   int id = 0;
   for (int i=0; i<4; i++) {
      if (mask & (1 << i)) {
	 switch (this->type->base_type) {
	 case GLSL_TYPE_UINT:
	    value.u[i+offset] = src->get_uint_component(id++);
	    break;
	 case GLSL_TYPE_INT:
	    value.i[i+offset] = src->get_int_component(id++);
	    break;
	 case GLSL_TYPE_FLOAT:
	    value.f[i+offset] = src->get_float_component(id++);
	    break;
	 case GLSL_TYPE_BOOL:
	    value.b[i+offset] = src->get_bool_component(id++);
	    break;
	 default:
	    assert(!"Should not get here.");
	    return;
	 }
      }
   }
}
a943 43
bool
ir_constant::is_basis() const
{
   if (!this->type->is_scalar() && !this->type->is_vector())
      return false;

   if (this->type->is_boolean())
      return false;

   unsigned ones = 0;
   for (unsigned c = 0; c < this->type->vector_elements; c++) {
      switch (this->type->base_type) {
      case GLSL_TYPE_FLOAT:
	 if (this->value.f[c] == 1.0)
	    ones++;
	 else if (this->value.f[c] != 0.0)
	    return false;
	 break;
      case GLSL_TYPE_INT:
	 if (this->value.i[c] == 1)
	    ones++;
	 else if (this->value.i[c] != 0)
	    return false;
	 break;
      case GLSL_TYPE_UINT:
	 if (int(this->value.u[c]) == 1)
	    ones++;
	 else if (int(this->value.u[c]) != 0)
	    return false;
	 break;
      default:
	 /* The only other base types are structures, arrays, samplers, and
	  * booleans.  Samplers cannot be constants, and the others should
	  * have been filtered out above.
	  */
	 assert(!"Should not get here.");
	 return false;
      }
   }

   return ones == 1;
}

a956 2
   assert(var != NULL);

d959 1
a959 1
   this->type = var->type;
a985 2
   assert(value != NULL);

d987 1
d989 2
a990 1
   const glsl_type *const vt = this->array->type;
d992 7
a998 6
   if (vt->is_array()) {
      type = vt->element_type();
   } else if (vt->is_matrix()) {
      type = vt->column_type();
   } else if (vt->is_vector()) {
      type = vt->get_base_type();
a1005 2
   assert(value != NULL);

d1009 2
a1010 1
   this->type = this->record->type->field_type(field);
d1022 2
a1023 1
   this->type = this->record->type->field_type(field);
d1027 1
a1027 1
ir_dereference::is_lvalue() const
d1036 3
d1052 1
a1052 1
static const char *tex_opcode_strs[] = { "tex", "txb", "txl", "txd", "txf", "txf_ms", "txs", "lod" };
d1074 1
a1074 1
ir_texture::set_sampler(ir_dereference *sampler, const glsl_type *type)
a1076 1
   assert(type != NULL);
a1077 1
   this->type = type;
d1079 10
a1088 11
   if (this->op == ir_txs) {
      assert(type->base_type == GLSL_TYPE_INT);
   } else if (this->op == ir_lod) {
      assert(type->vector_elements == 2);
      assert(type->base_type == GLSL_TYPE_FLOAT);
   } else {
      assert(sampler->type->sampler_type == (int) type->base_type);
      if (sampler->type->sampler_shadow)
	 assert(type->vector_elements == 4 || type->vector_elements == 1);
      else
	 assert(type->vector_elements == 4);
d1245 1
a1245 1
ir_swizzle::variable_referenced() const
d1254 1
a1254 1
     mode(mode), interpolation(INTERP_QUALIFIER_NONE)
a1259 1
   this->has_initializer = false;
a1260 1
   this->location_frac = 0;
a1262 1
   this->constant_initializer = NULL;
a1264 1
   this->depth_layout = ir_depth_layout_none;
d1276 3
a1278 4
   case INTERP_QUALIFIER_NONE:          return "no";
   case INTERP_QUALIFIER_SMOOTH:        return "smooth";
   case INTERP_QUALIFIER_FLAT:          return "flat";
   case INTERP_QUALIFIER_NOPERSPECTIVE: return "noperspective";
d1286 2
a1287 2
glsl_interp_qualifier
ir_variable::determine_interpolation_mode(bool flat_shade)
d1289 2
a1290 9
   if (this->interpolation != INTERP_QUALIFIER_NONE)
      return (glsl_interp_qualifier) this->interpolation;
   int location = this->location;
   bool is_gl_Color =
      location == VARYING_SLOT_COL0 || location == VARYING_SLOT_COL1;
   if (flat_shade && is_gl_Color)
      return INTERP_QUALIFIER_FLAT;
   else
      return INTERP_QUALIFIER_SMOOTH;
a1298 16
   this->origin = NULL;
}


static bool
modes_match(unsigned a, unsigned b)
{
   if (a == b)
      return true;

   /* Accept "in" vs. "const in" */
   if ((a == ir_var_const_in && b == ir_var_function_in) ||
       (b == ir_var_const_in && a == ir_var_function_in))
      return true;

   return false;
d1314 1
a1314 1
	  !modes_match(a->mode, b->mode) ||
d1365 2
a1366 2
ir_rvalue *
ir_rvalue::error_value(void *mem_ctx)
d1368 1
a1368 1
   ir_rvalue *v = new(mem_ctx) ir_rvalue;
d1370 2
a1371 2
   v->type = glsl_type::error_type;
   return v;
d1374 7
a1397 3

   if (var != NULL && var->constant_initializer != NULL)
      steal_memory(var->constant_initializer, ir);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a252 1
   case ir_unop_bitfield_reverse:
a259 3
   case ir_unop_bit_count:
   case ir_unop_find_msb:
   case ir_unop_find_lsb:
a396 3
   case ir_binop_imul_high:
   case ir_binop_carry:
   case ir_binop_borrow:
a398 2
   case ir_binop_bfm:
   case ir_binop_ldexp:
a411 32
ir_expression::ir_expression(int op, ir_rvalue *op0, ir_rvalue *op1,
                             ir_rvalue *op2)
{
   this->ir_type = ir_type_expression;

   this->operation = ir_expression_operation(op);
   this->operands[0] = op0;
   this->operands[1] = op1;
   this->operands[2] = op2;
   this->operands[3] = NULL;

   assert(op > ir_last_binop && op <= ir_last_triop);

   switch (this->operation) {
   case ir_triop_fma:
   case ir_triop_lrp:
   case ir_triop_bitfield_extract:
   case ir_triop_vector_insert:
      this->type = op0->type;
      break;

   case ir_triop_bfi:
   case ir_triop_csel:
      this->type = op1->type;
      break;

   default:
      assert(!"not reached: missing automatic type setup for ir_expression");
      this->type = glsl_type::float_type;
   }
}

a491 1
   "imul_high",
a492 2
   "carry",
   "borrow",
a516 1
   "ldexp",
a517 1
   "fma",
a518 1
   "csel",
d581 1
a581 1
ir_constant::ir_constant(float f, unsigned vector_elements)
a582 1
   assert(vector_elements <= 4);
d584 3
a586 5
   this->type = glsl_type::get_instance(GLSL_TYPE_FLOAT, vector_elements, 1);
   for (unsigned i = 0; i < vector_elements; i++) {
      this->value.f[i] = f;
   }
   for (unsigned i = vector_elements; i < 16; i++)  {
d591 1
a591 1
ir_constant::ir_constant(unsigned int u, unsigned vector_elements)
a592 1
   assert(vector_elements <= 4);
d594 3
a596 5
   this->type = glsl_type::get_instance(GLSL_TYPE_UINT, vector_elements, 1);
   for (unsigned i = 0; i < vector_elements; i++) {
      this->value.u[i] = u;
   }
   for (unsigned i = vector_elements; i < 16; i++) {
d601 1
a601 1
ir_constant::ir_constant(int integer, unsigned vector_elements)
a602 1
   assert(vector_elements <= 4);
d604 3
a606 5
   this->type = glsl_type::get_instance(GLSL_TYPE_INT, vector_elements, 1);
   for (unsigned i = 0; i < vector_elements; i++) {
      this->value.i[i] = integer;
   }
   for (unsigned i = vector_elements; i < 16; i++) {
d611 1
a611 1
ir_constant::ir_constant(bool b, unsigned vector_elements)
a612 1
   assert(vector_elements <= 4);
d614 3
a616 5
   this->type = glsl_type::get_instance(GLSL_TYPE_BOOL, vector_elements, 1);
   for (unsigned i = 0; i < vector_elements; i++) {
      this->value.b[i] = b;
   }
   for (unsigned i = vector_elements; i < 16; i++) {
d1066 1
a1066 1
ir_constant::is_value(float f, int i) const
a1070 4
   /* Only accept boolean values for 0/1. */
   if (int(bool(i)) != i && this->type->is_boolean())
      return false;

d1074 1
a1074 1
	 if (this->value.f[c] != f)
d1078 1
a1078 1
	 if (this->value.i[c] != i)
d1082 1
a1082 1
	 if (this->value.u[c] != unsigned(i))
d1086 1
a1086 1
	 if (this->value.b[c] != bool(i))
d1103 1
a1103 1
ir_constant::is_zero() const
d1105 30
a1134 2
   return is_value(0.0, 0);
}
d1136 1
a1136 4
bool
ir_constant::is_one() const
{
   return is_value(1.0, 1);
d1142 31
a1172 1
   return is_value(-1.0, -1);
a1217 9
bool
ir_constant::is_uint16_constant() const
{
   if (!type->is_integer())
      return false;

   return value.u[0] < (1 << 16);
}

d1221 5
d1308 1
a1308 1
   if ((var == NULL) || var->data.read_only)
d1311 1
a1311 1
   /* From section 4.1.7 of the GLSL 4.40 spec:
d1313 3
a1315 3
    *   "Opaque variables cannot be treated as l-values; hence cannot
    *    be used as out or inout function parameters, nor can they be
    *    assigned into."
d1317 1
a1317 1
   if (this->type->contains_opaque())
d1324 1
a1324 1
static const char * const tex_opcode_strs[] = { "tex", "txb", "txl", "txd", "txf", "txf_ms", "txs", "lod", "tg4", "query_levels" };
d1353 1
a1353 1
   if (this->op == ir_txs || this->op == ir_query_levels) {
d1528 2
a1529 1
   : max_ifc_array_access(NULL)
d1534 4
a1537 4
   this->data.explicit_location = false;
   this->data.has_initializer = false;
   this->data.location = -1;
   this->data.location_frac = 0;
d1541 7
a1547 29
   this->data.origin_upper_left = false;
   this->data.pixel_center_integer = false;
   this->data.depth_layout = ir_depth_layout_none;
   this->data.used = false;
   this->data.read_only = false;
   this->data.centroid = false;
   this->data.sample = false;
   this->data.invariant = false;
   this->data.how_declared = ir_var_declared_normally;
   this->data.mode = mode;
   this->data.interpolation = INTERP_QUALIFIER_NONE;
   this->data.max_array_access = 0;
   this->data.atomic.buffer_index = 0;
   this->data.atomic.offset = 0;
   this->data.image.read_only = false;
   this->data.image.write_only = false;
   this->data.image.coherent = false;
   this->data.image._volatile = false;
   this->data.image.restrict_flag = false;

   if (type != NULL) {
      if (type->base_type == GLSL_TYPE_SAMPLER)
         this->data.read_only = true;

      if (type->is_interface())
         this->init_interface_type(type);
      else if (type->is_array() && type->fields.array->is_interface())
         this->init_interface_type(type->fields.array);
   }
d1552 1
a1552 1
interpolation_string(unsigned interpolation)
d1554 1
a1554 1
   switch (interpolation) {
d1569 3
a1571 3
   if (this->data.interpolation != INTERP_QUALIFIER_NONE)
      return (glsl_interp_qualifier) this->data.interpolation;
   int location = this->data.location;
d1581 2
a1582 4
ir_function_signature::ir_function_signature(const glsl_type *return_type,
                                             builtin_available_predicate b)
   : return_type(return_type), is_defined(false), is_intrinsic(false),
     builtin_avail(b), _function(NULL)
d1585 1
a1589 24
bool
ir_function_signature::is_builtin() const
{
   return builtin_avail != NULL;
}


bool
ir_function_signature::is_builtin_available(const _mesa_glsl_parse_state *state) const
{
   /* We can't call the predicate without a state pointer, so just say that
    * the signature is available.  At compile time, we need the filtering,
    * but also receive a valid state pointer.  At link time, we're resolving
    * imported built-in prototypes to their definitions, which will always
    * be an exact match.  So we can skip the filtering.
    */
   if (state == NULL)
      return true;

   assert(builtin_avail != NULL);
   return builtin_avail(state);
}


d1608 3
d1612 8
a1619 14
   foreach_two_lists(a_node, &this->parameters, b_node, params) {
      ir_variable *a = (ir_variable *) a_node;
      ir_variable *b = (ir_variable *) b_node;

      if (a->data.read_only != b->data.read_only ||
	  !modes_match(a->data.mode, b->data.mode) ||
	  a->data.interpolation != b->data.interpolation ||
	  a->data.centroid != b->data.centroid ||
          a->data.sample != b->data.sample ||
          a->data.image.read_only != b->data.image.read_only ||
          a->data.image.write_only != b->data.image.write_only ||
          a->data.image.coherent != b->data.image.coherent ||
          a->data.image._volatile != b->data.image._volatile ||
          a->data.image.restrict_flag != b->data.image.restrict_flag) {
d1624 3
d1639 6
d1661 1
a1661 1
      if (!sig->is_builtin())
d1681 2
a1682 2
   foreach_list_safe(n, list) {
      ((ir_instruction *) n)->accept(visitor);
d1703 2
a1704 2
	 foreach_list(n, &constant->components) {
	    ir_constant *field = (ir_constant *) n;
a1779 64
}


unsigned
vertices_per_prim(GLenum prim)
{
   switch (prim) {
   case GL_POINTS:
      return 1;
   case GL_LINES:
      return 2;
   case GL_TRIANGLES:
      return 3;
   case GL_LINES_ADJACENCY:
      return 4;
   case GL_TRIANGLES_ADJACENCY:
      return 6;
   default:
      assert(!"Bad primitive");
      return 3;
   }
}

/**
 * Generate a string describing the mode of a variable
 */
const char *
mode_string(const ir_variable *var)
{
   switch (var->data.mode) {
   case ir_var_auto:
      return (var->data.read_only) ? "global constant" : "global variable";

   case ir_var_uniform:
      return "uniform";

   case ir_var_shader_in:
      return "shader input";

   case ir_var_shader_out:
      return "shader output";

   case ir_var_function_in:
   case ir_var_const_in:
      return "function input";

   case ir_var_function_out:
      return "function output";

   case ir_var_function_inout:
      return "function inout";

   case ir_var_system_value:
      return "shader input";

   case ir_var_temporary:
      return "compiler temporary";

   case ir_var_mode_count:
      break;
   }

   assert(!"Should not get here.");
   return "invalid variable";
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d26 1
d29 1
a29 2
ir_rvalue::ir_rvalue(enum ir_node_type t)
   : ir_instruction(t)
d49 5
a155 1
   : ir_instruction(ir_type_assignment)
d157 1
a175 1
   : ir_instruction(ir_type_assignment)
d177 1
a200 1
   : ir_rvalue(ir_type_expression)
d202 1
a217 1
   : ir_rvalue(ir_type_expression)
d219 2
a251 2
   case ir_unop_dFdx_coarse:
   case ir_unop_dFdx_fine:
a252 2
   case ir_unop_dFdy_coarse:
   case ir_unop_dFdy_fine:
a253 2
   case ir_unop_interpolate_at_centroid:
   case ir_unop_saturate:
a326 1
   : ir_rvalue(ir_type_expression)
d328 2
a407 2
   case ir_binop_interpolate_at_offset:
   case ir_binop_interpolate_at_sample:
a422 1
   : ir_rvalue(ir_type_expression)
d424 2
a511 2
   "dFdxCoarse",
   "dFdxFine",
a512 2
   "dFdyCoarse",
   "dFdyFine",
a528 1
   "sat",
a529 1
   "interpolate_at_centroid",
a562 2
   "interpolate_at_offset",
   "interpolate_at_sample",
a612 1
   : ir_rvalue(ir_type_constant)
d614 1
a618 1
   : ir_rvalue(ir_type_constant)
d623 1
a628 1
   : ir_rvalue(ir_type_constant)
d631 1
a641 1
   : ir_rvalue(ir_type_constant)
d644 1
a654 1
   : ir_rvalue(ir_type_constant)
d657 1
a667 1
   : ir_rvalue(ir_type_constant)
d670 1
a680 1
   : ir_rvalue(ir_type_constant)
d682 1
a694 1
   : ir_rvalue(ir_type_constant)
d696 1
d705 2
a706 1
      foreach_in_list(ir_constant, value, value_list) {
d1007 3
a1009 1
      foreach_in_list(ir_constant, orig, &src->components) {
d1184 43
a1235 1
   : ir_instruction(ir_type_loop)
d1237 1
a1241 1
   : ir_dereference(ir_type_dereference_variable)
d1245 1
a1252 1
   : ir_dereference(ir_type_dereference_array)
d1254 1
a1261 1
   : ir_dereference(ir_type_dereference_array)
d1265 1
a1291 1
   : ir_dereference(ir_type_dereference_record)
d1295 1
a1303 1
   : ir_dereference(ir_type_dereference_record)
d1307 1
d1424 1
a1424 1
   : ir_rvalue(ir_type_swizzle), val(val)
d1427 1
d1433 1
a1433 1
   : ir_rvalue(ir_type_swizzle), val(val)
d1435 1
a1439 1
   : ir_rvalue(ir_type_swizzle)
d1441 1
a1537 4
bool ir_variable::temporaries_allocate_names = false;

const char ir_variable::tmp_name[] = "compiler_temp";

d1540 1
a1540 1
   : ir_instruction(ir_type_variable)
d1542 1
d1544 1
a1544 23

   if (mode == ir_var_temporary && !ir_variable::temporaries_allocate_names)
      name = NULL;

   /* The ir_variable clone method may call this constructor with name set to
    * tmp_name.
    */
   assert(name != NULL
          || mode == ir_var_temporary
          || mode == ir_var_function_in
          || mode == ir_var_function_out
          || mode == ir_var_function_inout);
   assert(name != ir_variable::tmp_name
          || mode == ir_var_temporary);
   if (mode == ir_var_temporary
       && (name == NULL || name == ir_variable::tmp_name)) {
      this->name = ir_variable::tmp_name;
   } else {
      this->name = ralloc_strdup(this, name);
   }

   this->u.max_ifc_array_access = NULL;

d1549 1
a1549 2
   this->data.binding = 0;
   this->data.warn_extension_index = 0;
d1564 1
d1566 5
a1570 5
   this->data.image_read_only = false;
   this->data.image_write_only = false;
   this->data.image_coherent = false;
   this->data.image_volatile = false;
   this->data.image_restrict = false;
a1612 26
const char *const ir_variable::warn_extension_table[] = {
   "",
   "GL_ARB_shader_stencil_export",
   "GL_AMD_shader_stencil_export",
};

void
ir_variable::enable_extension_warning(const char *extension)
{
   for (unsigned i = 0; i < Elements(warn_extension_table); i++) {
      if (strcmp(warn_extension_table[i], extension) == 0) {
         this->data.warn_extension_index = i;
         return;
      }
   }

   assert(!"Should not get here.");
   this->data.warn_extension_index = 0;
}

const char *
ir_variable::get_extension_warning() const
{
   return this->data.warn_extension_index == 0
      ? NULL : warn_extension_table[this->data.warn_extension_index];
}
d1616 1
a1616 2
   : ir_instruction(ir_type_function_signature),
     return_type(return_type), is_defined(false), is_intrinsic(false),
d1619 1
d1676 5
a1680 5
          a->data.image_read_only != b->data.image_read_only ||
          a->data.image_write_only != b->data.image_write_only ||
          a->data.image_coherent != b->data.image_coherent ||
          a->data.image_volatile != b->data.image_volatile ||
          a->data.image_restrict != b->data.image_restrict) {
a1701 1
   : ir_instruction(ir_type_function)
d1703 1
d1711 2
a1712 1
   foreach_in_list(ir_function_signature, sig, &this->signatures) {
d1723 1
a1723 1
   ir_rvalue *v = new(mem_ctx) ir_rvalue(ir_type_unset);
d1733 2
a1734 2
   foreach_in_list_safe(ir_instruction, node, list) {
      node->accept(visitor);
d1755 2
a1756 1
	 foreach_in_list(ir_constant, field, &constant->components) {
d1773 2
a1774 2
   foreach_in_list(ir_instruction, node, list) {
      visit_tree(node, steal_memory, mem_ctx);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a25 1
#include "ir_visitor.h"
d28 2
a29 1
ir_rvalue::ir_rvalue()
a48 5
bool ir_rvalue::is_basis() const
{
   return false;
}

d151 1
a152 1
   this->ir_type = ir_type_assignment;
d171 1
a172 1
   this->ir_type = ir_type_assignment;
d196 1
a197 1
   this->ir_type = ir_type_expression;
d213 1
a214 2
   this->ir_type = ir_type_expression;

d246 2
d249 2
d252 2
d327 1
a328 2
   this->ir_type = ir_type_expression;

d407 2
d424 1
a425 2
   this->ir_type = ir_type_expression;

d512 2
d515 2
d533 1
d535 1
d569 2
d621 1
a622 1
   this->ir_type = ir_type_constant;
d627 1
a631 1
   this->ir_type = ir_type_constant;
d637 1
a639 1
   this->ir_type = ir_type_constant;
d650 1
a652 1
   this->ir_type = ir_type_constant;
d663 1
a665 1
   this->ir_type = ir_type_constant;
d676 1
a678 1
   this->ir_type = ir_type_constant;
d689 1
a690 1
   this->ir_type = ir_type_constant;
d703 1
a704 1
   this->ir_type = ir_type_constant;
d713 1
a713 2
      foreach_list(node, value_list) {
	 ir_constant *value = (ir_constant *) node;
d1014 1
a1014 3
      foreach_list(node, &src->components) {
	 ir_constant *const orig = (ir_constant *) node;

a1188 43
ir_constant::is_basis() const
{
   if (!this->type->is_scalar() && !this->type->is_vector())
      return false;

   if (this->type->is_boolean())
      return false;

   unsigned ones = 0;
   for (unsigned c = 0; c < this->type->vector_elements; c++) {
      switch (this->type->base_type) {
      case GLSL_TYPE_FLOAT:
	 if (this->value.f[c] == 1.0)
	    ones++;
	 else if (this->value.f[c] != 0.0)
	    return false;
	 break;
      case GLSL_TYPE_INT:
	 if (this->value.i[c] == 1)
	    ones++;
	 else if (this->value.i[c] != 0)
	    return false;
	 break;
      case GLSL_TYPE_UINT:
	 if (int(this->value.u[c]) == 1)
	    ones++;
	 else if (int(this->value.u[c]) != 0)
	    return false;
	 break;
      default:
	 /* The only other base types are structures, arrays, samplers, and
	  * booleans.  Samplers cannot be constants, and the others should
	  * have been filtered out above.
	  */
	 assert(!"Should not get here.");
	 return false;
      }
   }

   return ones == 1;
}

bool
d1198 1
a1199 1
   this->ir_type = ir_type_loop;
d1204 1
a1207 1
   this->ir_type = ir_type_dereference_variable;
d1215 1
a1216 1
   this->ir_type = ir_type_dereference_array;
d1224 1
a1227 1
   this->ir_type = ir_type_dereference_array;
d1254 1
a1257 1
   this->ir_type = ir_type_dereference_record;
d1266 1
a1269 1
   this->ir_type = ir_type_dereference_record;
d1386 1
a1386 1
   : val(val)
a1388 1
   this->ir_type = ir_type_swizzle;
d1394 1
a1394 1
   : val(val)
a1395 1
   this->ir_type = ir_type_swizzle;
d1400 1
a1401 1
   this->ir_type = ir_type_swizzle;
d1498 4
d1504 1
a1504 1
   : max_ifc_array_access(NULL)
a1505 1
   this->ir_type = ir_type_variable;
d1507 23
a1529 1
   this->name = ralloc_strdup(this, name);
d1534 2
a1535 1
   this->warn_extension = NULL;
a1549 1
   this->data.atomic.buffer_index = 0;
d1551 5
a1555 5
   this->data.image.read_only = false;
   this->data.image.write_only = false;
   this->data.image.coherent = false;
   this->data.image._volatile = false;
   this->data.image.restrict_flag = false;
d1598 26
d1627 2
a1628 1
   : return_type(return_type), is_defined(false), is_intrinsic(false),
a1630 1
   this->ir_type = ir_type_function_signature;
d1687 5
a1691 5
          a->data.image.read_only != b->data.image.read_only ||
          a->data.image.write_only != b->data.image.write_only ||
          a->data.image.coherent != b->data.image.coherent ||
          a->data.image._volatile != b->data.image._volatile ||
          a->data.image.restrict_flag != b->data.image.restrict_flag) {
d1713 1
a1714 1
   this->ir_type = ir_type_function;
d1722 1
a1722 2
   foreach_list(n, &this->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;
d1733 1
a1733 1
   ir_rvalue *v = new(mem_ctx) ir_rvalue;
d1743 2
a1744 2
   foreach_list_safe(n, list) {
      ((ir_instruction *) n)->accept(visitor);
d1765 1
a1765 2
	 foreach_list(n, &constant->components) {
	    ir_constant *field = (ir_constant *) n;
d1782 2
a1783 2
   foreach_list(node, list) {
      visit_tree((ir_instruction *) node, steal_memory, mem_ctx);
@


