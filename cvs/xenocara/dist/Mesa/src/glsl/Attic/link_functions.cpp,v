head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.8
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.10.05.09.53.56;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.09.05.14.02.27;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.17;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.10.05.09.24.00;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.30;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.10.23;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.47.29;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "main/core.h"
#include "glsl_symbol_table.h"
#include "glsl_parser_extras.h"
#include "ir.h"
#include "program.h"
#include "program/hash_table.h"
#include "linker.h"

static ir_function_signature *
find_matching_signature(const char *name, const exec_list *actual_parameters,
			gl_shader **shader_list, unsigned num_shaders,
			bool use_builtin);

namespace {

class call_link_visitor : public ir_hierarchical_visitor {
public:
   call_link_visitor(gl_shader_program *prog, gl_shader *linked,
		     gl_shader **shader_list, unsigned num_shaders)
   {
      this->prog = prog;
      this->shader_list = shader_list;
      this->num_shaders = num_shaders;
      this->success = true;
      this->linked = linked;

      this->locals = hash_table_ctor(0, hash_table_pointer_hash,
				     hash_table_pointer_compare);
   }

   ~call_link_visitor()
   {
      hash_table_dtor(this->locals);
   }

   virtual ir_visitor_status visit(ir_variable *ir)
   {
      hash_table_insert(locals, ir, ir);
      return visit_continue;
   }

   virtual ir_visitor_status visit_enter(ir_call *ir)
   {
      /* If ir is an ir_call from a function that was imported from another
       * shader callee will point to an ir_function_signature in the original
       * shader.  In this case the function signature MUST NOT BE MODIFIED.
       * Doing so will modify the original shader.  This may prevent that
       * shader from being linkable in other programs.
       */
      const ir_function_signature *const callee = ir->callee;
      assert(callee != NULL);
      const char *const name = callee->function_name();

      /* Determine if the requested function signature already exists in the
       * final linked shader.  If it does, use it as the target of the call.
       */
      ir_function_signature *sig =
	 find_matching_signature(name, &callee->parameters, &linked, 1,
				 ir->use_builtin);
      if (sig != NULL) {
	 ir->callee = sig;
	 return visit_continue;
      }

      /* Try to find the signature in one of the other shaders that is being
       * linked.  If it's not found there, return an error.
       */
      sig = find_matching_signature(name, &ir->actual_parameters, shader_list,
				    num_shaders, ir->use_builtin);
      if (sig == NULL) {
	 /* FINISHME: Log the full signature of unresolved function.
	  */
	 linker_error(this->prog, "unresolved reference to function `%s'\n",
		      name);
	 this->success = false;
	 return visit_stop;
      }

      /* Find the prototype information in the linked shader.  Generate any
       * details that may be missing.
       */
      ir_function *f = linked->symbols->get_function(name);
      if (f == NULL) {
	 f = new(linked) ir_function(name);

	 /* Add the new function to the linked IR.  Put it at the end
          * so that it comes after any global variable declarations
          * that it refers to.
	  */
	 linked->symbols->add_function(f);
	 linked->ir->push_tail(f);
      }

      ir_function_signature *linked_sig =
	 f->exact_matching_signature(NULL, &callee->parameters);
      if ((linked_sig == NULL)
	  || ((linked_sig != NULL)
	      && (linked_sig->is_builtin() != ir->use_builtin))) {
	 linked_sig = new(linked) ir_function_signature(callee->return_type);
	 f->add_signature(linked_sig);
      }

      /* At this point linked_sig and called may be the same.  If ir is an
       * ir_call from linked then linked_sig and callee will be
       * ir_function_signatures that have no definitions (is_defined is false).
       */
      assert(!linked_sig->is_defined);
      assert(linked_sig->body.is_empty());

      /* Create an in-place clone of the function definition.  This multistep
       * process introduces some complexity here, but it has some advantages.
       * The parameter list and the and function body are cloned separately.
       * The clone of the parameter list is used to prime the hashtable used
       * to replace variable references in the cloned body.
       *
       * The big advantage is that the ir_function_signature does not change.
       * This means that we don't have to process the rest of the IR tree to
       * patch ir_call nodes.  In addition, there is no way to remove or
       * replace signature stored in a function.  One could easily be added,
       * but this avoids the need.
       */
      struct hash_table *ht = hash_table_ctor(0, hash_table_pointer_hash,
					      hash_table_pointer_compare);
      exec_list formal_parameters;
      foreach_list_const(node, &sig->parameters) {
	 const ir_instruction *const original = (ir_instruction *) node;
	 assert(const_cast<ir_instruction *>(original)->as_variable());

	 ir_instruction *copy = original->clone(linked, ht);
	 formal_parameters.push_tail(copy);
      }

      linked_sig->replace_parameters(&formal_parameters);

      if (sig->is_defined) {
         foreach_list_const(node, &sig->body) {
            const ir_instruction *const original = (ir_instruction *) node;

            ir_instruction *copy = original->clone(linked, ht);
            linked_sig->body.push_tail(copy);
         }

         linked_sig->is_defined = true;
      }

      hash_table_dtor(ht);

      /* Patch references inside the function to things outside the function
       * (i.e., function calls and global variables).
       */
      linked_sig->accept(this);

      ir->callee = linked_sig;

      return visit_continue;
   }

   virtual ir_visitor_status visit_leave(ir_call *ir)
   {
      /* Traverse list of function parameters, and for array parameters
       * propagate max_array_access. Otherwise arrays that are only referenced
       * from inside functions via function parameters will be incorrectly
       * optimized. This will lead to incorrect code being generated (or worse).
       * Do it when leaving the node so the children would propagate their
       * array accesses first.
       */

      const exec_node *formal_param_node = ir->callee->parameters.get_head();
      if (formal_param_node) {
         const exec_node *actual_param_node = ir->actual_parameters.get_head();
         while (!actual_param_node->is_tail_sentinel()) {
            ir_variable *formal_param = (ir_variable *) formal_param_node;
            ir_rvalue *actual_param = (ir_rvalue *) actual_param_node;

            formal_param_node = formal_param_node->get_next();
            actual_param_node = actual_param_node->get_next();

            if (formal_param->type->is_array()) {
               ir_dereference_variable *deref = actual_param->as_dereference_variable();
               if (deref && deref->var && deref->var->type->is_array()) {
                  deref->var->data.max_array_access =
                     MAX2(formal_param->data.max_array_access,
                         deref->var->data.max_array_access);
               }
            }
         }
      }
      return visit_continue;
   }

   virtual ir_visitor_status visit(ir_dereference_variable *ir)
   {
      if (hash_table_find(locals, ir->var) == NULL) {
	 /* The non-function variable must be a global, so try to find the
	  * variable in the shader's symbol table.  If the variable is not
	  * found, then it's a global that *MUST* be defined in the original
	  * shader.
	  */
	 ir_variable *var = linked->symbols->get_variable(ir->var->name);
	 if (var == NULL) {
	    /* Clone the ir_variable that the dereference already has and add
	     * it to the linked shader.
	     */
	    var = ir->var->clone(linked, NULL);
	    linked->symbols->add_variable(var);
	    linked->ir->push_head(var);
	 } else {
            if (var->type->is_array()) {
               /* It is possible to have a global array declared in multiple
                * shaders without a size.  The array is implicitly sized by
                * the maximal access to it in *any* shader.  Because of this,
                * we need to track the maximal access to the array as linking
                * pulls more functions in that access the array.
                */
               var->data.max_array_access =
                  MAX2(var->data.max_array_access,
                       ir->var->data.max_array_access);

               if (var->type->length == 0 && ir->var->type->length != 0)
                  var->type = ir->var->type;
            }
            if (var->is_interface_instance()) {
               /* Similarly, we need implicit sizes of arrays within interface
                * blocks to be sized by the maximal access in *any* shader.
                */
               for (unsigned i = 0; i < var->get_interface_type()->length;
                    i++) {
                  var->max_ifc_array_access[i] =
                     MAX2(var->max_ifc_array_access[i],
                          ir->var->max_ifc_array_access[i]);
               }
            }
	 }

	 ir->var = var;
      }

      return visit_continue;
   }

   /** Was function linking successful? */
   bool success;

private:
   /**
    * Shader program being linked
    *
    * This is only used for logging error messages.
    */
   gl_shader_program *prog;

   /** List of shaders available for linking. */
   gl_shader **shader_list;

   /** Number of shaders available for linking. */
   unsigned num_shaders;

   /**
    * Final linked shader
    *
    * This is used two ways.  It is used to find global variables in the
    * linked shader that are accessed by the function.  It is also used to add
    * global variables from the shader where the function originated.
    */
   gl_shader *linked;

   /**
    * Table of variables local to the function.
    */
   hash_table *locals;
};

} /* anonymous namespace */

/**
 * Searches a list of shaders for a particular function definition
 */
ir_function_signature *
find_matching_signature(const char *name, const exec_list *actual_parameters,
			gl_shader **shader_list, unsigned num_shaders,
			bool use_builtin)
{
   for (unsigned i = 0; i < num_shaders; i++) {
      ir_function *const f = shader_list[i]->symbols->get_function(name);

      if (f == NULL)
	 continue;

      ir_function_signature *sig =
         f->matching_signature(NULL, actual_parameters);

      if ((sig == NULL) ||
          (!sig->is_defined && !sig->is_intrinsic))
	 continue;

      /* If this function expects to bind to a built-in function and the
       * signature that we found isn't a built-in, keep looking.  Also keep
       * looking if we expect a non-built-in but found a built-in.
       */
      if (use_builtin != sig->is_builtin())
	    continue;

      return sig;
   }

   return NULL;
}


bool
link_function_calls(gl_shader_program *prog, gl_shader *main,
		    gl_shader **shader_list, unsigned num_shaders)
{
   call_link_visitor v(prog, main, shader_list, num_shaders);

   v.run(main->ir);
   return v.success;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d148 2
a149 1
      foreach_in_list(const ir_instruction, original, &sig->parameters) {
d158 3
a160 1
      linked_sig->is_intrinsic = sig->is_intrinsic;
a161 2
      if (sig->is_defined) {
         foreach_in_list(const ir_instruction, original, &sig->body) {
a248 8
               unsigned *const linked_max_ifc_array_access =
                  var->get_max_ifc_array_access();
               unsigned *const ir_max_ifc_array_access =
                  ir->var->get_max_ifc_array_access();

               assert(linked_max_ifc_array_access != NULL);
               assert(ir_max_ifc_array_access != NULL);

d251 3
a253 3
                  linked_max_ifc_array_access[i] =
                     MAX2(linked_max_ifc_array_access[i],
                          ir_max_ifc_array_access[i]);
d313 1
a313 1
         f->matching_signature(NULL, actual_parameters, use_builtin);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d148 1
a148 2
      foreach_list_const(node, &sig->parameters) {
	 const ir_instruction *const original = (ir_instruction *) node;
d157 2
d160 1
a160 3
         foreach_list_const(node, &sig->body) {
            const ir_instruction *const original = (ir_instruction *) node;

d248 8
d258 3
a260 3
                  var->max_ifc_array_access[i] =
                     MAX2(var->max_ifc_array_access[i],
                          ir->var->max_ifc_array_access[i]);
d320 1
a320 1
         f->matching_signature(NULL, actual_parameters);
@


1.4
log
@Merge Mesa 9.2.1
@
text
@d37 2
d118 1
a118 1
	 f->exact_matching_signature(&callee->parameters);
d121 1
a121 1
	      && (linked_sig->is_builtin != ir->use_builtin))) {
d158 7
a164 2
      foreach_list_const(node, &sig->body) {
	 const ir_instruction *const original = (ir_instruction *) node;
d166 1
a166 2
	 ir_instruction *copy = original->clone(linked, ht);
	 linked_sig->body.push_tail(copy);
a168 1
      linked_sig->is_defined = true;
d204 3
a206 2
                  deref->var->max_array_access =
                     MAX2(formal_param->max_array_access, deref->var->max_array_access);
d230 11
a240 9
	 } else if (var->type->is_array()) {
	    /* It is possible to have a global array declared in multiple
	     * shaders without a size.  The array is implicitly sized by the
	     * maximal access to it in *any* shader.  Because of this, we
	     * need to track the maximal access to the array as linking pulls
	     * more functions in that access the array.
	     */
	    var->max_array_access =
	       MAX2(var->max_array_access, ir->var->max_array_access);
d242 14
a255 2
	    if (var->type->length == 0 && ir->var->type->length != 0)
	       var->type = ir->var->type;
d296 1
d312 2
a313 1
      ir_function_signature *sig = f->matching_signature(actual_parameters);
d315 2
a316 1
      if ((sig == NULL) || !sig->is_defined)
d323 1
a323 1
      if (use_builtin != sig->is_builtin)
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d176 32
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d71 1
a71 1
      const ir_function_signature *const callee = ir->get_callee();
d82 1
a82 1
	 ir->set_callee(sig);
d107 3
a109 1
	 /* Add the new function to the linked IR.
d112 1
a112 1
	 linked->ir->push_head(f);
d171 1
a171 1
      ir->set_callee(linked_sig);
@


1.1
log
@Initial revision
@
text
@a23 4
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

d94 2
a95 2
	 linker_error_printf(this->prog, "unresolved reference to function "
			     "`%s'\n", name);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d24 4
d75 1
a75 1
      const ir_function_signature *const callee = ir->callee;
d86 1
a86 1
	 ir->callee = sig;
d98 2
a99 2
	 linker_error(this->prog, "unresolved reference to function `%s'\n",
		      name);
d111 1
a111 3
	 /* Add the new function to the linked IR.  Put it at the end
          * so that it comes after any global variable declarations
          * that it refers to.
d114 1
a114 1
	 linked->ir->push_tail(f);
d173 1
a173 1
      ir->callee = linked_sig;
@


1.1.1.3
log
@Import Mesa 9.2.1
@
text
@a175 32
   virtual ir_visitor_status visit_leave(ir_call *ir)
   {
      /* Traverse list of function parameters, and for array parameters
       * propagate max_array_access. Otherwise arrays that are only referenced
       * from inside functions via function parameters will be incorrectly
       * optimized. This will lead to incorrect code being generated (or worse).
       * Do it when leaving the node so the children would propagate their
       * array accesses first.
       */

      const exec_node *formal_param_node = ir->callee->parameters.get_head();
      if (formal_param_node) {
         const exec_node *actual_param_node = ir->actual_parameters.get_head();
         while (!actual_param_node->is_tail_sentinel()) {
            ir_variable *formal_param = (ir_variable *) formal_param_node;
            ir_rvalue *actual_param = (ir_rvalue *) actual_param_node;

            formal_param_node = formal_param_node->get_next();
            actual_param_node = actual_param_node->get_next();

            if (formal_param->type->is_array()) {
               ir_dereference_variable *deref = actual_param->as_dereference_variable();
               if (deref && deref->var && deref->var->type->is_array()) {
                  deref->var->max_array_access =
                     MAX2(formal_param->max_array_access, deref->var->max_array_access);
               }
            }
         }
      }
      return visit_continue;
   }

@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@a36 2
namespace {

d116 1
a116 1
	 f->exact_matching_signature(NULL, &callee->parameters);
d119 1
a119 1
	      && (linked_sig->is_builtin() != ir->use_builtin))) {
d156 2
a157 3
      if (sig->is_defined) {
         foreach_list_const(node, &sig->body) {
            const ir_instruction *const original = (ir_instruction *) node;
d159 2
a160 5
            ir_instruction *copy = original->clone(linked, ht);
            linked_sig->body.push_tail(copy);
         }

         linked_sig->is_defined = true;
d163 1
d199 2
a200 3
                  deref->var->data.max_array_access =
                     MAX2(formal_param->data.max_array_access,
                         deref->var->data.max_array_access);
d224 9
a232 11
	 } else {
            if (var->type->is_array()) {
               /* It is possible to have a global array declared in multiple
                * shaders without a size.  The array is implicitly sized by
                * the maximal access to it in *any* shader.  Because of this,
                * we need to track the maximal access to the array as linking
                * pulls more functions in that access the array.
                */
               var->data.max_array_access =
                  MAX2(var->data.max_array_access,
                       ir->var->data.max_array_access);
d234 2
a235 14
               if (var->type->length == 0 && ir->var->type->length != 0)
                  var->type = ir->var->type;
            }
            if (var->is_interface_instance()) {
               /* Similarly, we need implicit sizes of arrays within interface
                * blocks to be sized by the maximal access in *any* shader.
                */
               for (unsigned i = 0; i < var->get_interface_type()->length;
                    i++) {
                  var->max_ifc_array_access[i] =
                     MAX2(var->max_ifc_array_access[i],
                          ir->var->max_ifc_array_access[i]);
               }
            }
a275 1
} /* anonymous namespace */
d291 1
a291 2
      ir_function_signature *sig =
         f->matching_signature(NULL, actual_parameters);
d293 1
a293 2
      if ((sig == NULL) ||
          (!sig->is_defined && !sig->is_intrinsic))
d300 1
a300 1
      if (use_builtin != sig->is_builtin())
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d148 2
a149 1
      foreach_in_list(const ir_instruction, original, &sig->parameters) {
d158 3
a160 1
      linked_sig->is_intrinsic = sig->is_intrinsic;
a161 2
      if (sig->is_defined) {
         foreach_in_list(const ir_instruction, original, &sig->body) {
a248 8
               unsigned *const linked_max_ifc_array_access =
                  var->get_max_ifc_array_access();
               unsigned *const ir_max_ifc_array_access =
                  ir->var->get_max_ifc_array_access();

               assert(linked_max_ifc_array_access != NULL);
               assert(ir_max_ifc_array_access != NULL);

d251 3
a253 3
                  linked_max_ifc_array_access[i] =
                     MAX2(linked_max_ifc_array_access[i],
                          ir_max_ifc_array_access[i]);
d313 1
a313 1
         f->matching_signature(NULL, actual_parameters, use_builtin);
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d148 1
a148 2
      foreach_list_const(node, &sig->parameters) {
	 const ir_instruction *const original = (ir_instruction *) node;
d157 2
d160 1
a160 3
         foreach_list_const(node, &sig->body) {
            const ir_instruction *const original = (ir_instruction *) node;

d248 8
d258 3
a260 3
                  var->max_ifc_array_access[i] =
                     MAX2(var->max_ifc_array_access[i],
                          ir->var->max_ifc_array_access[i]);
d320 1
a320 1
         f->matching_signature(NULL, actual_parameters);
@


