head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.26;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.16;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.29;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.22;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.29;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "ir_print_visitor.h"
#include "glsl_types.h"
#include "glsl_parser_extras.h"
#include "main/macros.h"
#include "program/hash_table.h"

static void print_type(FILE *f, const glsl_type *t);

void
ir_instruction::print(void) const
{
   this->fprint(stdout);
}

void
ir_instruction::fprint(FILE *f) const
{
   ir_instruction *deconsted = const_cast<ir_instruction *>(this);

   ir_print_visitor v(f);
   deconsted->accept(&v);
}

extern "C" {
void
_mesa_print_ir(FILE *f, exec_list *instructions,
	       struct _mesa_glsl_parse_state *state)
{
   if (state) {
      for (unsigned i = 0; i < state->num_user_structures; i++) {
	 const glsl_type *const s = state->user_structures[i];

	 fprintf(f, "(structure (%s) (%s@@%p) (%u) (\n",
                 s->name, s->name, (void *) s, s->length);

	 for (unsigned j = 0; j < s->length; j++) {
	    fprintf(f, "\t((");
	    print_type(f, s->fields.structure[j].type);
	    fprintf(f, ")(%s))\n", s->fields.structure[j].name);
	 }

	 fprintf(f, ")\n");
      }
   }

   fprintf(f, "(\n");
   foreach_list(n, instructions) {
      ir_instruction *ir = (ir_instruction *) n;
      ir->fprint(f);
      if (ir->ir_type != ir_type_function)
	 fprintf(f, "\n");
   }
   fprintf(f, "\n)");
}

} /* extern "C" */

ir_print_visitor::ir_print_visitor(FILE *f)
   : f(f)
{
   indentation = 0;
   printable_names =
      hash_table_ctor(32, hash_table_pointer_hash, hash_table_pointer_compare);
   symbols = _mesa_symbol_table_ctor();
   mem_ctx = ralloc_context(NULL);
}

ir_print_visitor::~ir_print_visitor()
{
   hash_table_dtor(printable_names);
   _mesa_symbol_table_dtor(symbols);
   ralloc_free(mem_ctx);
}

void ir_print_visitor::indent(void)
{
   for (int i = 0; i < indentation; i++)
      fprintf(f, "  ");
}

const char *
ir_print_visitor::unique_name(ir_variable *var)
{
   /* var->name can be NULL in function prototypes when a type is given for a
    * parameter but no name is given.  In that case, just return an empty
    * string.  Don't worry about tracking the generated name in the printable
    * names hash because this is the only scope where it can ever appear.
    */
   if (var->name == NULL) {
      static unsigned arg = 1;
      return ralloc_asprintf(this->mem_ctx, "parameter@@%u", arg++);
   }

   /* Do we already have a name for this variable? */
   const char *name = (const char *) hash_table_find(this->printable_names, var);
   if (name != NULL)
      return name;

   /* If there's no conflict, just use the original name */
   if (_mesa_symbol_table_find_symbol(this->symbols, -1, var->name) == NULL) {
      name = var->name;
   } else {
      static unsigned i = 1;
      name = ralloc_asprintf(this->mem_ctx, "%s@@%u", var->name, ++i);
   }
   hash_table_insert(this->printable_names, (void *) name, var);
   _mesa_symbol_table_add_symbol(this->symbols, -1, name, var);
   return name;
}

static void
print_type(FILE *f, const glsl_type *t)
{
   if (t->base_type == GLSL_TYPE_ARRAY) {
      fprintf(f, "(array ");
      print_type(f, t->fields.array);
      fprintf(f, " %u)", t->length);
   } else if ((t->base_type == GLSL_TYPE_STRUCT)
	      && (strncmp("gl_", t->name, 3) != 0)) {
      fprintf(f, "%s@@%p", t->name, (void *) t);
   } else {
      fprintf(f, "%s", t->name);
   }
}

void ir_print_visitor::visit(ir_rvalue *)
{
   fprintf(f, "error");
}

void ir_print_visitor::visit(ir_variable *ir)
{
   fprintf(f, "(declare ");

   const char *const cent = (ir->data.centroid) ? "centroid " : "";
   const char *const samp = (ir->data.sample) ? "sample " : "";
   const char *const inv = (ir->data.invariant) ? "invariant " : "";
   const char *const mode[] = { "", "uniform ", "shader_in ", "shader_out ",
                                "in ", "out ", "inout ",
			        "const_in ", "sys ", "temporary " };
   STATIC_ASSERT(ARRAY_SIZE(mode) == ir_var_mode_count);
   const char *const interp[] = { "", "smooth", "flat", "noperspective" };
   STATIC_ASSERT(ARRAY_SIZE(interp) == INTERP_QUALIFIER_COUNT);

   fprintf(f, "(%s%s%s%s%s) ",
	  cent, samp, inv, mode[ir->data.mode], interp[ir->data.interpolation]);

   print_type(f, ir->type);
   fprintf(f, " %s)", unique_name(ir));
}


void ir_print_visitor::visit(ir_function_signature *ir)
{
   _mesa_symbol_table_push_scope(symbols);
   fprintf(f, "(signature ");
   indentation++;

   print_type(f, ir->return_type);
   fprintf(f, "\n");
   indent();

   fprintf(f, "(parameters\n");
   indentation++;

   foreach_list(n, &ir->parameters) {
      ir_variable *const inst = (ir_variable *) n;

      indent();
      inst->accept(this);
      fprintf(f, "\n");
   }
   indentation--;

   indent();
   fprintf(f, ")\n");

   indent();

   fprintf(f, "(\n");
   indentation++;

   foreach_list(n, &ir->body) {
      ir_instruction *const inst = (ir_instruction *) n;

      indent();
      inst->accept(this);
      fprintf(f, "\n");
   }
   indentation--;
   indent();
   fprintf(f, "))\n");
   indentation--;
   _mesa_symbol_table_pop_scope(symbols);
}


void ir_print_visitor::visit(ir_function *ir)
{
   fprintf(f, "(function %s\n", ir->name);
   indentation++;
   foreach_list(n, &ir->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;
      indent();
      sig->accept(this);
      fprintf(f, "\n");
   }
   indentation--;
   indent();
   fprintf(f, ")\n\n");
}


void ir_print_visitor::visit(ir_expression *ir)
{
   fprintf(f, "(expression ");

   print_type(f, ir->type);

   fprintf(f, " %s ", ir->operator_string());

   for (unsigned i = 0; i < ir->get_num_operands(); i++) {
      ir->operands[i]->accept(this);
   }

   fprintf(f, ") ");
}


void ir_print_visitor::visit(ir_texture *ir)
{
   fprintf(f, "(%s ", ir->opcode_string());

   print_type(f, ir->type);
   fprintf(f, " ");

   ir->sampler->accept(this);
   fprintf(f, " ");

   if (ir->op != ir_txs && ir->op != ir_query_levels) {
      ir->coordinate->accept(this);

      fprintf(f, " ");

      if (ir->offset != NULL) {
	 ir->offset->accept(this);
      } else {
	 fprintf(f, "0");
      }

      fprintf(f, " ");
   }

   if (ir->op != ir_txf && ir->op != ir_txf_ms &&
       ir->op != ir_txs && ir->op != ir_tg4 &&
       ir->op != ir_query_levels) {
      if (ir->projector)
	 ir->projector->accept(this);
      else
	 fprintf(f, "1");

      if (ir->shadow_comparitor) {
	 fprintf(f, " ");
	 ir->shadow_comparitor->accept(this);
      } else {
	 fprintf(f, " ()");
      }
   }

   fprintf(f, " ");
   switch (ir->op)
   {
   case ir_tex:
   case ir_lod:
   case ir_query_levels:
      break;
   case ir_txb:
      ir->lod_info.bias->accept(this);
      break;
   case ir_txl:
   case ir_txf:
   case ir_txs:
      ir->lod_info.lod->accept(this);
      break;
   case ir_txf_ms:
      ir->lod_info.sample_index->accept(this);
      break;
   case ir_txd:
      fprintf(f, "(");
      ir->lod_info.grad.dPdx->accept(this);
      fprintf(f, " ");
      ir->lod_info.grad.dPdy->accept(this);
      fprintf(f, ")");
      break;
   case ir_tg4:
      ir->lod_info.component->accept(this);
      break;
   };
   fprintf(f, ")");
}


void ir_print_visitor::visit(ir_swizzle *ir)
{
   const unsigned swiz[4] = {
      ir->mask.x,
      ir->mask.y,
      ir->mask.z,
      ir->mask.w,
   };

   fprintf(f, "(swiz ");
   for (unsigned i = 0; i < ir->mask.num_components; i++) {
      fprintf(f, "%c", "xyzw"[swiz[i]]);
   }
   fprintf(f, " ");
   ir->val->accept(this);
   fprintf(f, ")");
}


void ir_print_visitor::visit(ir_dereference_variable *ir)
{
   ir_variable *var = ir->variable_referenced();
   fprintf(f, "(var_ref %s) ", unique_name(var));
}


void ir_print_visitor::visit(ir_dereference_array *ir)
{
   fprintf(f, "(array_ref ");
   ir->array->accept(this);
   ir->array_index->accept(this);
   fprintf(f, ") ");
}


void ir_print_visitor::visit(ir_dereference_record *ir)
{
   fprintf(f, "(record_ref ");
   ir->record->accept(this);
   fprintf(f, " %s) ", ir->field);
}


void ir_print_visitor::visit(ir_assignment *ir)
{
   fprintf(f, "(assign ");

   if (ir->condition)
      ir->condition->accept(this);

   char mask[5];
   unsigned j = 0;

   for (unsigned i = 0; i < 4; i++) {
      if ((ir->write_mask & (1 << i)) != 0) {
	 mask[j] = "xyzw"[i];
	 j++;
      }
   }
   mask[j] = '\0';

   fprintf(f, " (%s) ", mask);

   ir->lhs->accept(this);

   fprintf(f, " ");

   ir->rhs->accept(this);
   fprintf(f, ") ");
}


void ir_print_visitor::visit(ir_constant *ir)
{
   fprintf(f, "(constant ");
   print_type(f, ir->type);
   fprintf(f, " (");

   if (ir->type->is_array()) {
      for (unsigned i = 0; i < ir->type->length; i++)
	 ir->get_array_element(i)->accept(this);
   } else if (ir->type->is_record()) {
      ir_constant *value = (ir_constant *) ir->components.get_head();
      for (unsigned i = 0; i < ir->type->length; i++) {
	 fprintf(f, "(%s ", ir->type->fields.structure[i].name);
	 value->accept(this);
	 fprintf(f, ")");

	 value = (ir_constant *) value->next;
      }
   } else {
      for (unsigned i = 0; i < ir->type->components(); i++) {
	 if (i != 0)
	    fprintf(f, " ");
	 switch (ir->type->base_type) {
	 case GLSL_TYPE_UINT:  fprintf(f, "%u", ir->value.u[i]); break;
	 case GLSL_TYPE_INT:   fprintf(f, "%d", ir->value.i[i]); break;
	 case GLSL_TYPE_FLOAT:
            if (ir->value.f[i] == 0.0f)
               /* 0.0 == -0.0, so print with %f to get the proper sign. */
               fprintf(f, "%.1f", ir->value.f[i]);
            else if (fabs(ir->value.f[i]) < 0.000001f)
               fprintf(f, "%a", ir->value.f[i]);
            else if (fabs(ir->value.f[i]) > 1000000.0f)
               fprintf(f, "%e", ir->value.f[i]);
            else
               fprintf(f, "%f", ir->value.f[i]);
            break;
	 case GLSL_TYPE_BOOL:  fprintf(f, "%d", ir->value.b[i]); break;
	 default: assert(0);
	 }
      }
   }
   fprintf(f, ")) ");
}


void
ir_print_visitor::visit(ir_call *ir)
{
   fprintf(f, "(call %s ", ir->callee_name());
   if (ir->return_deref)
      ir->return_deref->accept(this);
   fprintf(f, " (");
   foreach_list(n, &ir->actual_parameters) {
      ir_rvalue *const param = (ir_rvalue *) n;

      param->accept(this);
   }
   fprintf(f, "))\n");
}


void
ir_print_visitor::visit(ir_return *ir)
{
   fprintf(f, "(return");

   ir_rvalue *const value = ir->get_value();
   if (value) {
      fprintf(f, " ");
      value->accept(this);
   }

   fprintf(f, ")");
}


void
ir_print_visitor::visit(ir_discard *ir)
{
   fprintf(f, "(discard ");

   if (ir->condition != NULL) {
      fprintf(f, " ");
      ir->condition->accept(this);
   }

   fprintf(f, ")");
}


void
ir_print_visitor::visit(ir_if *ir)
{
   fprintf(f, "(if ");
   ir->condition->accept(this);

   fprintf(f, "(\n");
   indentation++;

   foreach_list(n, &ir->then_instructions) {
      ir_instruction *const inst = (ir_instruction *) n;

      indent();
      inst->accept(this);
      fprintf(f, "\n");
   }

   indentation--;
   indent();
   fprintf(f, ")\n");

   indent();
   if (!ir->else_instructions.is_empty()) {
      fprintf(f, "(\n");
      indentation++;

      foreach_list(n, &ir->else_instructions) {
	 ir_instruction *const inst = (ir_instruction *) n;

	 indent();
	 inst->accept(this);
	 fprintf(f, "\n");
      }
      indentation--;
      indent();
      fprintf(f, "))\n");
   } else {
      fprintf(f, "())\n");
   }
}


void
ir_print_visitor::visit(ir_loop *ir)
{
   fprintf(f, "(loop (\n");
   indentation++;

   foreach_list(n, &ir->body_instructions) {
      ir_instruction *const inst = (ir_instruction *) n;

      indent();
      inst->accept(this);
      fprintf(f, "\n");
   }
   indentation--;
   indent();
   fprintf(f, "))\n");
}


void
ir_print_visitor::visit(ir_loop_jump *ir)
{
   fprintf(f, "%s", ir->is_break() ? "break" : "continue");
}

void
ir_print_visitor::visit(ir_emit_vertex *)
{
   fprintf(f, "(emit-vertex)");
}

void
ir_print_visitor::visit(ir_end_primitive *)
{
   fprintf(f, "(end-primitive)");
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d70 2
a71 1
   foreach_in_list(ir_instruction, ir, instructions) {
a78 7
void
fprint_ir(FILE *f, const void *instruction)
{
   const ir_instruction *ir = (const ir_instruction *)instruction;
   ir->fprint(f);
}

d142 1
a142 1
              && !is_gl_identifier(t->name)) {
a164 1
   const char *const stream [] = {"", "stream1 ", "stream2 ", "stream3 "};
d168 2
a169 4
   fprintf(f, "(%s%s%s%s%s%s) ",
           cent, samp, inv, mode[ir->data.mode],
           stream[ir->data.stream],
           interp[ir->data.interpolation]);
d189 3
a191 1
   foreach_in_list(ir_variable, inst, &ir->parameters) {
d206 3
a208 1
   foreach_in_list(ir_instruction, inst, &ir->body) {
d225 2
a226 1
   foreach_in_list(ir_function_signature, sig, &ir->signatures) {
d426 1
a426 1
               fprintf(f, "%f", ir->value.f[i]);
d450 3
a452 1
   foreach_in_list(ir_rvalue, param, &ir->actual_parameters) {
d497 3
a499 1
   foreach_in_list(ir_instruction, inst, &ir->then_instructions) {
d514 3
a516 1
      foreach_in_list(ir_instruction, inst, &ir->else_instructions) {
d536 3
a538 1
   foreach_in_list(ir_instruction, inst, &ir->body_instructions) {
d556 1
a556 1
ir_print_visitor::visit(ir_emit_vertex *ir)
d558 1
a558 3
   fprintf(f, "(emit-vertex ");
   ir->stream->accept(this);
   fprintf(f, ")\n");
d562 1
a562 1
ir_print_visitor::visit(ir_end_primitive *ir)
d564 1
a564 4
   fprintf(f, "(end-primitive ");
   ir->stream->accept(this);
   fprintf(f, ")\n");

@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d70 1
a70 2
   foreach_list(n, instructions) {
      ir_instruction *ir = (ir_instruction *) n;
d78 7
d148 1
a148 1
	      && (strncmp("gl_", t->name, 3) != 0)) {
d171 1
d175 4
a178 2
   fprintf(f, "(%s%s%s%s%s) ",
	  cent, samp, inv, mode[ir->data.mode], interp[ir->data.interpolation]);
d198 1
a198 3
   foreach_list(n, &ir->parameters) {
      ir_variable *const inst = (ir_variable *) n;

d213 1
a213 3
   foreach_list(n, &ir->body) {
      ir_instruction *const inst = (ir_instruction *) n;

d230 1
a230 2
   foreach_list(n, &ir->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;
d430 1
a430 1
               fprintf(f, "%.1f", ir->value.f[i]);
d454 1
a454 3
   foreach_list(n, &ir->actual_parameters) {
      ir_rvalue *const param = (ir_rvalue *) n;

d499 1
a499 3
   foreach_list(n, &ir->then_instructions) {
      ir_instruction *const inst = (ir_instruction *) n;

d514 1
a514 3
      foreach_list(n, &ir->else_instructions) {
	 ir_instruction *const inst = (ir_instruction *) n;

d534 1
a534 3
   foreach_list(n, &ir->body_instructions) {
      ir_instruction *const inst = (ir_instruction *) n;

d552 1
a552 1
ir_print_visitor::visit(ir_emit_vertex *)
d554 3
a556 1
   fprintf(f, "(emit-vertex)");
d560 1
a560 1
ir_print_visitor::visit(ir_end_primitive *)
d562 4
a565 1
   fprintf(f, "(end-primitive)");
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d30 1
a30 1
static void print_type(const glsl_type *t);
d35 6
d43 1
a43 1
   ir_print_visitor v;
d49 1
a49 1
_mesa_print_ir(exec_list *instructions,
d56 2
a57 2
	 printf("(structure (%s) (%s@@%p) (%u) (\n",
		s->name, s->name, (void *) s, s->length);
d60 3
a62 3
	    printf("\t((");
	    print_type(s->fields.structure[j].type);
	    printf(")(%s))\n", s->fields.structure[j].name);
d65 1
a65 1
	 printf(")\n");
d69 4
a72 4
   printf("(\n");
   foreach_iter(exec_list_iterator, iter, *instructions) {
      ir_instruction *ir = (ir_instruction *)iter.get();
      ir->print();
d74 1
a74 1
	 printf("\n");
d76 1
a76 1
   printf("\n)");
d81 2
a82 1
ir_print_visitor::ir_print_visitor()
d101 1
a101 1
      printf("  ");
d135 1
a135 1
print_type(const glsl_type *t)
d138 3
a140 3
      printf("(array ");
      print_type(t->fields.array);
      printf(" %u)", t->length);
d143 1
a143 1
      printf("%s@@%p", t->name, (void *) t);
d145 1
a145 1
      printf("%s", t->name);
d149 1
a149 1
void ir_print_visitor::visit(ir_rvalue *ir)
d151 1
a151 1
   printf("error");
d156 1
a156 1
   printf("(declare ");
d158 3
a160 2
   const char *const cent = (ir->centroid) ? "centroid " : "";
   const char *const inv = (ir->invariant) ? "invariant " : "";
d168 2
a169 2
   printf("(%s%s%s%s) ",
	  cent, inv, mode[ir->mode], interp[ir->interpolation]);
d171 2
a172 2
   print_type(ir->type);
   printf(" %s)", unique_name(ir));
d179 1
a179 1
   printf("(signature ");
d182 2
a183 2
   print_type(ir->return_type);
   printf("\n");
d186 1
a186 1
   printf("(parameters\n");
d189 2
a190 2
   foreach_iter(exec_list_iterator, iter, ir->parameters) {
      ir_variable *const inst = (ir_variable *) iter.get();
d194 1
a194 1
      printf("\n");
d199 1
a199 1
   printf(")\n");
d203 1
a203 1
   printf("(\n");
d206 2
a207 2
   foreach_iter(exec_list_iterator, iter, ir->body) {
      ir_instruction *const inst = (ir_instruction *) iter.get();
d211 1
a211 1
      printf("\n");
d215 1
a215 1
   printf("))\n");
d223 1
a223 1
   printf("(function %s\n", ir->name);
d225 2
a226 2
   foreach_iter(exec_list_iterator, iter, *ir) {
      ir_function_signature *const sig = (ir_function_signature *) iter.get();
d229 1
a229 1
      printf("\n");
d233 1
a233 1
   printf(")\n\n");
d239 1
a239 1
   printf("(expression ");
d241 1
a241 1
   print_type(ir->type);
d243 1
a243 1
   printf(" %s ", ir->operator_string());
d249 1
a249 1
   printf(") ");
d255 1
a255 1
   printf("(%s ", ir->opcode_string());
d257 2
a258 2
   print_type(ir->type);
   printf(" ");
d261 1
a261 1
   printf(" ");
d263 1
a263 1
   if (ir->op != ir_txs) {
d266 1
a266 1
      printf(" ");
d271 1
a271 1
	 printf("0");
d274 1
a274 1
      printf(" ");
d277 3
a279 1
   if (ir->op != ir_txf && ir->op != ir_txf_ms && ir->op != ir_txs) {
d283 1
a283 1
	 printf("1");
d286 1
a286 1
	 printf(" ");
d289 1
a289 1
	 printf(" ()");
d293 1
a293 1
   printf(" ");
d298 1
d312 1
a312 1
      printf("(");
d314 1
a314 1
      printf(" ");
d316 4
a319 1
      printf(")");
d322 1
a322 1
   printf(")");
d335 1
a335 1
   printf("(swiz ");
d337 1
a337 1
      printf("%c", "xyzw"[swiz[i]]);
d339 1
a339 1
   printf(" ");
d341 1
a341 1
   printf(")");
d348 1
a348 1
   printf("(var_ref %s) ", unique_name(var));
d354 1
a354 1
   printf("(array_ref ");
d357 1
a357 1
   printf(") ");
d363 1
a363 1
   printf("(record_ref ");
d365 1
a365 1
   printf(" %s) ", ir->field);
d371 1
a371 1
   printf("(assign ");
d387 1
a387 1
   printf(" (%s) ", mask);
d391 1
a391 1
   printf(" ");
d394 1
a394 1
   printf(") ");
d400 3
a402 3
   printf("(constant ");
   print_type(ir->type);
   printf(" (");
d410 1
a410 1
	 printf("(%s ", ir->type->fields.structure[i].name);
d412 1
a412 1
	 printf(")");
d419 1
a419 1
	    printf(" ");
d421 14
a434 4
	 case GLSL_TYPE_UINT:  printf("%u", ir->value.u[i]); break;
	 case GLSL_TYPE_INT:   printf("%d", ir->value.i[i]); break;
	 case GLSL_TYPE_FLOAT: printf("%f", ir->value.f[i]); break;
	 case GLSL_TYPE_BOOL:  printf("%d", ir->value.b[i]); break;
d439 1
a439 1
   printf(")) ");
d446 1
a446 1
   printf("(call %s ", ir->callee_name());
d449 3
a451 3
   printf(" (");
   foreach_iter(exec_list_iterator, iter, *ir) {
      ir_instruction *const inst = (ir_instruction *) iter.get();
d453 1
a453 1
      inst->accept(this);
d455 1
a455 1
   printf("))\n");
d462 1
a462 1
   printf("(return");
d466 1
a466 1
      printf(" ");
d470 1
a470 1
   printf(")");
d477 1
a477 1
   printf("(discard ");
d480 1
a480 1
      printf(" ");
d484 1
a484 1
   printf(")");
d491 1
a491 1
   printf("(if ");
d494 1
a494 1
   printf("(\n");
d497 2
a498 2
   foreach_iter(exec_list_iterator, iter, ir->then_instructions) {
      ir_instruction *const inst = (ir_instruction *) iter.get();
d502 1
a502 1
      printf("\n");
d507 1
a507 1
   printf(")\n");
d511 1
a511 1
      printf("(\n");
d514 2
a515 2
      foreach_iter(exec_list_iterator, iter, ir->else_instructions) {
	 ir_instruction *const inst = (ir_instruction *) iter.get();
d519 1
a519 1
	 printf("\n");
d523 1
a523 1
      printf("))\n");
d525 1
a525 1
      printf("())\n");
d533 1
a533 13
   printf("(loop (");
   if (ir->counter != NULL)
      ir->counter->accept(this);
   printf(") (");
   if (ir->from != NULL)
      ir->from->accept(this);
   printf(") (");
   if (ir->to != NULL)
      ir->to->accept(this);
   printf(") (");
   if (ir->increment != NULL)
      ir->increment->accept(this);
   printf(") (\n");
d536 2
a537 2
   foreach_iter(exec_list_iterator, iter, ir->body_instructions) {
      ir_instruction *const inst = (ir_instruction *) iter.get();
d541 1
a541 1
      printf("\n");
d545 1
a545 1
   printf("))\n");
d552 13
a564 1
   printf("%s", ir->is_break() ? "break" : "continue");
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d27 1
a27 2

extern "C" {
a28 1
}
d41 1
d73 2
d142 4
d153 2
a154 1
   const char *const mode[] = { "", "uniform ", "in ", "out ", "inout ",
d156 3
a158 1
   const char *const interp[] = { "", "flat", "noperspective" };
d255 2
a256 1
   ir->coordinate->accept(this);
d258 7
a264 1
   printf(" ");
d266 1
a266 4
   if (ir->offset != NULL) {
      ir->offset->accept(this);
   } else {
      printf("0");
d269 1
a269 3
   printf(" ");

   if (ir->op != ir_txf) {
d287 1
d294 1
d297 3
a385 2
   const glsl_type *const base_type = ir->type->get_base_type();

d406 1
a406 1
	 switch (base_type->base_type) {
d422 4
a425 1
   printf("(call %s (", ir->callee_name());
@


1.1
log
@Initial revision
@
text
@d28 4
d74 15
d96 30
d149 1
a149 1
			        "temporary " };
d156 1
a156 5
   if (ir->name == NULL) {
      static unsigned arg = 1;
      printf(" parameter@@%u)", arg++);
   } else
      printf(" %s@@%p)", ir->name, (void *) ir);
d162 1
d201 1
d241 3
d249 9
a257 1
   printf(" (%d %d %d) ", ir->offsets[0], ir->offsets[1], ir->offsets[2]);
d319 1
a319 1
   printf("(var_ref %s@@%p) ", var->name, (void *) var);
a345 3
   else
      printf("(constant bool (1))");

d383 1
a383 1
	 printf("(%s ", ir->type->fields.structure->name);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a26 2
#include "main/macros.h"
#include "program/hash_table.h"
a38 1
extern "C" {
a69 17
} /* extern "C" */

ir_print_visitor::ir_print_visitor()
{
   indentation = 0;
   printable_names =
      hash_table_ctor(32, hash_table_pointer_hash, hash_table_pointer_compare);
   symbols = _mesa_symbol_table_ctor();
   mem_ctx = ralloc_context(NULL);
}

ir_print_visitor::~ir_print_visitor()
{
   hash_table_dtor(printable_names);
   _mesa_symbol_table_dtor(symbols);
   ralloc_free(mem_ctx);
}
a76 30
const char *
ir_print_visitor::unique_name(ir_variable *var)
{
   /* var->name can be NULL in function prototypes when a type is given for a
    * parameter but no name is given.  In that case, just return an empty
    * string.  Don't worry about tracking the generated name in the printable
    * names hash because this is the only scope where it can ever appear.
    */
   if (var->name == NULL) {
      static unsigned arg = 1;
      return ralloc_asprintf(this->mem_ctx, "parameter@@%u", arg++);
   }

   /* Do we already have a name for this variable? */
   const char *name = (const char *) hash_table_find(this->printable_names, var);
   if (name != NULL)
      return name;

   /* If there's no conflict, just use the original name */
   if (_mesa_symbol_table_find_symbol(this->symbols, -1, var->name) == NULL) {
      name = var->name;
   } else {
      static unsigned i = 1;
      name = ralloc_asprintf(this->mem_ctx, "%s@@%u", var->name, ++i);
   }
   hash_table_insert(this->printable_names, (void *) name, var);
   _mesa_symbol_table_add_symbol(this->symbols, -1, name, var);
   return name;
}

a91 4
void ir_print_visitor::visit(ir_rvalue *ir)
{
   printf("error");
}
d99 3
a101 6
   const char *const mode[] = { "", "uniform ", "shader_in ", "shader_out ",
                                "in ", "out ", "inout ",
			        "const_in ", "sys ", "temporary " };
   STATIC_ASSERT(ARRAY_SIZE(mode) == ir_var_mode_count);
   const char *const interp[] = { "", "smooth", "flat", "noperspective" };
   STATIC_ASSERT(ARRAY_SIZE(interp) == INTERP_QUALIFIER_COUNT);
d107 5
a111 1
   printf(" %s)", unique_name(ir));
a116 1
   _mesa_symbol_table_push_scope(symbols);
a154 1
   _mesa_symbol_table_pop_scope(symbols);
a193 3
   print_type(ir->type);
   printf(" ");

d197 1
a197 10
   if (ir->op != ir_txs) {
      ir->coordinate->accept(this);

      printf(" ");

      if (ir->offset != NULL) {
	 ir->offset->accept(this);
      } else {
	 printf("0");
      }
d199 1
a199 2
      printf(" ");
   }
d201 1
a201 1
   if (ir->op != ir_txf && ir->op != ir_txf_ms && ir->op != ir_txs) {
a218 1
   case ir_lod:
a224 1
   case ir_txs:
a226 3
   case ir_txf_ms:
      ir->lod_info.sample_index->accept(this);
      break;
d261 1
a261 1
   printf("(var_ref %s) ", unique_name(var));
d288 3
d316 2
d328 1
a328 1
	 printf("(%s ", ir->type->fields.structure[i].name);
d338 1
a338 1
	 switch (ir->type->base_type) {
d354 1
a354 4
   printf("(call %s ", ir->callee_name());
   if (ir->return_deref)
      ir->return_deref->accept(this);
   printf(" (");
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d30 1
a30 1
static void print_type(FILE *f, const glsl_type *t);
a34 6
   this->fprint(stdout);
}

void
ir_instruction::fprint(FILE *f) const
{
d37 1
a37 1
   ir_print_visitor v(f);
d43 1
a43 1
_mesa_print_ir(FILE *f, exec_list *instructions,
d50 2
a51 2
	 fprintf(f, "(structure (%s) (%s@@%p) (%u) (\n",
                 s->name, s->name, (void *) s, s->length);
d54 3
a56 3
	    fprintf(f, "\t((");
	    print_type(f, s->fields.structure[j].type);
	    fprintf(f, ")(%s))\n", s->fields.structure[j].name);
d59 1
a59 1
	 fprintf(f, ")\n");
d63 4
a66 4
   fprintf(f, "(\n");
   foreach_list(n, instructions) {
      ir_instruction *ir = (ir_instruction *) n;
      ir->fprint(f);
d68 1
a68 1
	 fprintf(f, "\n");
d70 1
a70 1
   fprintf(f, "\n)");
d75 1
a75 2
ir_print_visitor::ir_print_visitor(FILE *f)
   : f(f)
d94 1
a94 1
      fprintf(f, "  ");
d128 1
a128 1
print_type(FILE *f, const glsl_type *t)
d131 3
a133 3
      fprintf(f, "(array ");
      print_type(f, t->fields.array);
      fprintf(f, " %u)", t->length);
d136 1
a136 1
      fprintf(f, "%s@@%p", t->name, (void *) t);
d138 1
a138 1
      fprintf(f, "%s", t->name);
d142 1
a142 1
void ir_print_visitor::visit(ir_rvalue *)
d144 1
a144 1
   fprintf(f, "error");
d149 1
a149 1
   fprintf(f, "(declare ");
d151 2
a152 3
   const char *const cent = (ir->data.centroid) ? "centroid " : "";
   const char *const samp = (ir->data.sample) ? "sample " : "";
   const char *const inv = (ir->data.invariant) ? "invariant " : "";
d160 2
a161 2
   fprintf(f, "(%s%s%s%s%s) ",
	  cent, samp, inv, mode[ir->data.mode], interp[ir->data.interpolation]);
d163 2
a164 2
   print_type(f, ir->type);
   fprintf(f, " %s)", unique_name(ir));
d171 1
a171 1
   fprintf(f, "(signature ");
d174 2
a175 2
   print_type(f, ir->return_type);
   fprintf(f, "\n");
d178 1
a178 1
   fprintf(f, "(parameters\n");
d181 2
a182 2
   foreach_list(n, &ir->parameters) {
      ir_variable *const inst = (ir_variable *) n;
d186 1
a186 1
      fprintf(f, "\n");
d191 1
a191 1
   fprintf(f, ")\n");
d195 1
a195 1
   fprintf(f, "(\n");
d198 2
a199 2
   foreach_list(n, &ir->body) {
      ir_instruction *const inst = (ir_instruction *) n;
d203 1
a203 1
      fprintf(f, "\n");
d207 1
a207 1
   fprintf(f, "))\n");
d215 1
a215 1
   fprintf(f, "(function %s\n", ir->name);
d217 2
a218 2
   foreach_list(n, &ir->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;
d221 1
a221 1
      fprintf(f, "\n");
d225 1
a225 1
   fprintf(f, ")\n\n");
d231 1
a231 1
   fprintf(f, "(expression ");
d233 1
a233 1
   print_type(f, ir->type);
d235 1
a235 1
   fprintf(f, " %s ", ir->operator_string());
d241 1
a241 1
   fprintf(f, ") ");
d247 1
a247 1
   fprintf(f, "(%s ", ir->opcode_string());
d249 2
a250 2
   print_type(f, ir->type);
   fprintf(f, " ");
d253 1
a253 1
   fprintf(f, " ");
d255 1
a255 1
   if (ir->op != ir_txs && ir->op != ir_query_levels) {
d258 1
a258 1
      fprintf(f, " ");
d263 1
a263 1
	 fprintf(f, "0");
d266 1
a266 1
      fprintf(f, " ");
d269 1
a269 3
   if (ir->op != ir_txf && ir->op != ir_txf_ms &&
       ir->op != ir_txs && ir->op != ir_tg4 &&
       ir->op != ir_query_levels) {
d273 1
a273 1
	 fprintf(f, "1");
d276 1
a276 1
	 fprintf(f, " ");
d279 1
a279 1
	 fprintf(f, " ()");
d283 1
a283 1
   fprintf(f, " ");
a287 1
   case ir_query_levels:
d301 1
a301 1
      fprintf(f, "(");
d303 1
a303 1
      fprintf(f, " ");
d305 1
a305 4
      fprintf(f, ")");
      break;
   case ir_tg4:
      ir->lod_info.component->accept(this);
d308 1
a308 1
   fprintf(f, ")");
d321 1
a321 1
   fprintf(f, "(swiz ");
d323 1
a323 1
      fprintf(f, "%c", "xyzw"[swiz[i]]);
d325 1
a325 1
   fprintf(f, " ");
d327 1
a327 1
   fprintf(f, ")");
d334 1
a334 1
   fprintf(f, "(var_ref %s) ", unique_name(var));
d340 1
a340 1
   fprintf(f, "(array_ref ");
d343 1
a343 1
   fprintf(f, ") ");
d349 1
a349 1
   fprintf(f, "(record_ref ");
d351 1
a351 1
   fprintf(f, " %s) ", ir->field);
d357 1
a357 1
   fprintf(f, "(assign ");
d373 1
a373 1
   fprintf(f, " (%s) ", mask);
d377 1
a377 1
   fprintf(f, " ");
d380 1
a380 1
   fprintf(f, ") ");
d386 3
a388 3
   fprintf(f, "(constant ");
   print_type(f, ir->type);
   fprintf(f, " (");
d396 1
a396 1
	 fprintf(f, "(%s ", ir->type->fields.structure[i].name);
d398 1
a398 1
	 fprintf(f, ")");
d405 1
a405 1
	    fprintf(f, " ");
d407 4
a410 14
	 case GLSL_TYPE_UINT:  fprintf(f, "%u", ir->value.u[i]); break;
	 case GLSL_TYPE_INT:   fprintf(f, "%d", ir->value.i[i]); break;
	 case GLSL_TYPE_FLOAT:
            if (ir->value.f[i] == 0.0f)
               /* 0.0 == -0.0, so print with %f to get the proper sign. */
               fprintf(f, "%.1f", ir->value.f[i]);
            else if (fabs(ir->value.f[i]) < 0.000001f)
               fprintf(f, "%a", ir->value.f[i]);
            else if (fabs(ir->value.f[i]) > 1000000.0f)
               fprintf(f, "%e", ir->value.f[i]);
            else
               fprintf(f, "%f", ir->value.f[i]);
            break;
	 case GLSL_TYPE_BOOL:  fprintf(f, "%d", ir->value.b[i]); break;
d415 1
a415 1
   fprintf(f, ")) ");
d422 1
a422 1
   fprintf(f, "(call %s ", ir->callee_name());
d425 3
a427 3
   fprintf(f, " (");
   foreach_list(n, &ir->actual_parameters) {
      ir_rvalue *const param = (ir_rvalue *) n;
d429 1
a429 1
      param->accept(this);
d431 1
a431 1
   fprintf(f, "))\n");
d438 1
a438 1
   fprintf(f, "(return");
d442 1
a442 1
      fprintf(f, " ");
d446 1
a446 1
   fprintf(f, ")");
d453 1
a453 1
   fprintf(f, "(discard ");
d456 1
a456 1
      fprintf(f, " ");
d460 1
a460 1
   fprintf(f, ")");
d467 1
a467 1
   fprintf(f, "(if ");
d470 1
a470 1
   fprintf(f, "(\n");
d473 2
a474 2
   foreach_list(n, &ir->then_instructions) {
      ir_instruction *const inst = (ir_instruction *) n;
d478 1
a478 1
      fprintf(f, "\n");
d483 1
a483 1
   fprintf(f, ")\n");
d487 1
a487 1
      fprintf(f, "(\n");
d490 2
a491 2
      foreach_list(n, &ir->else_instructions) {
	 ir_instruction *const inst = (ir_instruction *) n;
d495 1
a495 1
	 fprintf(f, "\n");
d499 1
a499 1
      fprintf(f, "))\n");
d501 1
a501 1
      fprintf(f, "())\n");
d509 13
a521 1
   fprintf(f, "(loop (\n");
d524 2
a525 2
   foreach_list(n, &ir->body_instructions) {
      ir_instruction *const inst = (ir_instruction *) n;
d529 1
a529 1
      fprintf(f, "\n");
d533 1
a533 1
   fprintf(f, "))\n");
d540 1
a540 13
   fprintf(f, "%s", ir->is_break() ? "break" : "continue");
}

void
ir_print_visitor::visit(ir_emit_vertex *)
{
   fprintf(f, "(emit-vertex)");
}

void
ir_print_visitor::visit(ir_end_primitive *)
{
   fprintf(f, "(end-primitive)");
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d70 2
a71 1
   foreach_in_list(ir_instruction, ir, instructions) {
a78 7
void
fprint_ir(FILE *f, const void *instruction)
{
   const ir_instruction *ir = (const ir_instruction *)instruction;
   ir->fprint(f);
}

d142 1
a142 1
              && !is_gl_identifier(t->name)) {
a164 1
   const char *const stream [] = {"", "stream1 ", "stream2 ", "stream3 "};
d168 2
a169 4
   fprintf(f, "(%s%s%s%s%s%s) ",
           cent, samp, inv, mode[ir->data.mode],
           stream[ir->data.stream],
           interp[ir->data.interpolation]);
d189 3
a191 1
   foreach_in_list(ir_variable, inst, &ir->parameters) {
d206 3
a208 1
   foreach_in_list(ir_instruction, inst, &ir->body) {
d225 2
a226 1
   foreach_in_list(ir_function_signature, sig, &ir->signatures) {
d426 1
a426 1
               fprintf(f, "%f", ir->value.f[i]);
d450 3
a452 1
   foreach_in_list(ir_rvalue, param, &ir->actual_parameters) {
d497 3
a499 1
   foreach_in_list(ir_instruction, inst, &ir->then_instructions) {
d514 3
a516 1
      foreach_in_list(ir_instruction, inst, &ir->else_instructions) {
d536 3
a538 1
   foreach_in_list(ir_instruction, inst, &ir->body_instructions) {
d556 1
a556 1
ir_print_visitor::visit(ir_emit_vertex *ir)
d558 1
a558 3
   fprintf(f, "(emit-vertex ");
   ir->stream->accept(this);
   fprintf(f, ")\n");
d562 1
a562 1
ir_print_visitor::visit(ir_end_primitive *ir)
d564 1
a564 4
   fprintf(f, "(end-primitive ");
   ir->stream->accept(this);
   fprintf(f, ")\n");

@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d70 1
a70 2
   foreach_list(n, instructions) {
      ir_instruction *ir = (ir_instruction *) n;
d78 7
d148 1
a148 1
	      && (strncmp("gl_", t->name, 3) != 0)) {
d171 1
d175 4
a178 2
   fprintf(f, "(%s%s%s%s%s) ",
	  cent, samp, inv, mode[ir->data.mode], interp[ir->data.interpolation]);
d198 1
a198 3
   foreach_list(n, &ir->parameters) {
      ir_variable *const inst = (ir_variable *) n;

d213 1
a213 3
   foreach_list(n, &ir->body) {
      ir_instruction *const inst = (ir_instruction *) n;

d230 1
a230 2
   foreach_list(n, &ir->signatures) {
      ir_function_signature *const sig = (ir_function_signature *) n;
d430 1
a430 1
               fprintf(f, "%.1f", ir->value.f[i]);
d454 1
a454 3
   foreach_list(n, &ir->actual_parameters) {
      ir_rvalue *const param = (ir_rvalue *) n;

d499 1
a499 3
   foreach_list(n, &ir->then_instructions) {
      ir_instruction *const inst = (ir_instruction *) n;

d514 1
a514 3
      foreach_list(n, &ir->else_instructions) {
	 ir_instruction *const inst = (ir_instruction *) n;

d534 1
a534 3
   foreach_list(n, &ir->body_instructions) {
      ir_instruction *const inst = (ir_instruction *) n;

d552 1
a552 1
ir_print_visitor::visit(ir_emit_vertex *)
d554 3
a556 1
   fprintf(f, "(emit-vertex)");
d560 1
a560 1
ir_print_visitor::visit(ir_end_primitive *)
d562 4
a565 1
   fprintf(f, "(end-primitive)");
@


