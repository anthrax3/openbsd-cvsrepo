head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.44;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.27;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.19;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.30;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.26;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.32;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "glsl_types.h"
#include "loop_analysis.h"
#include "ir_hierarchical_visitor.h"

static bool is_loop_terminator(ir_if *ir);

static bool all_expression_operands_are_loop_constant(ir_rvalue *,
						      hash_table *);

static ir_rvalue *get_basic_induction_increment(ir_assignment *, hash_table *);


/**
 * Record the fact that the given loop variable was referenced inside the loop.
 *
 * \arg in_assignee is true if the reference was on the LHS of an assignment.
 *
 * \arg in_conditional_code_or_nested_loop is true if the reference occurred
 * inside an if statement or a nested loop.
 *
 * \arg current_assignment is the ir_assignment node that the loop variable is
 * on the LHS of, if any (ignored if \c in_assignee is false).
 */
void
loop_variable::record_reference(bool in_assignee,
                                bool in_conditional_code_or_nested_loop,
                                ir_assignment *current_assignment)
{
   if (in_assignee) {
      assert(current_assignment != NULL);

      if (in_conditional_code_or_nested_loop ||
          current_assignment->condition != NULL) {
         this->conditional_or_nested_assignment = true;
      }

      if (this->first_assignment == NULL) {
         assert(this->num_assignments == 0);

         this->first_assignment = current_assignment;
      }

      this->num_assignments++;
   } else if (this->first_assignment == current_assignment) {
      /* This catches the case where the variable is used in the RHS of an
       * assignment where it is also in the LHS.
       */
      this->read_before_write = true;
   }
}


loop_state::loop_state()
{
   this->ht = hash_table_ctor(0, hash_table_pointer_hash,
			      hash_table_pointer_compare);
   this->mem_ctx = ralloc_context(NULL);
   this->loop_found = false;
}


loop_state::~loop_state()
{
   hash_table_dtor(this->ht);
   ralloc_free(this->mem_ctx);
}


loop_variable_state *
loop_state::insert(ir_loop *ir)
{
   loop_variable_state *ls = new(this->mem_ctx) loop_variable_state;

   hash_table_insert(this->ht, ls, ir);
   this->loop_found = true;

   return ls;
}


loop_variable_state *
loop_state::get(const ir_loop *ir)
{
   return (loop_variable_state *) hash_table_find(this->ht, ir);
}


loop_variable *
loop_variable_state::get(const ir_variable *ir)
{
   return (loop_variable *) hash_table_find(this->var_hash, ir);
}


loop_variable *
loop_variable_state::insert(ir_variable *var)
{
   void *mem_ctx = ralloc_parent(this);
   loop_variable *lv = rzalloc(mem_ctx, loop_variable);

   lv->var = var;

   hash_table_insert(this->var_hash, lv, lv->var);
   this->variables.push_tail(lv);

   return lv;
}


loop_terminator *
loop_variable_state::insert(ir_if *if_stmt)
{
   void *mem_ctx = ralloc_parent(this);
   loop_terminator *t = new(mem_ctx) loop_terminator();

   t->ir = if_stmt;
   this->terminators.push_tail(t);

   return t;
}


/**
 * If the given variable already is recorded in the state for this loop,
 * return the corresponding loop_variable object that records information
 * about it.
 *
 * Otherwise, create a new loop_variable object to record information about
 * the variable, and set its \c read_before_write field appropriately based on
 * \c in_assignee.
 *
 * \arg in_assignee is true if this variable was encountered on the LHS of an
 * assignment.
 */
loop_variable *
loop_variable_state::get_or_insert(ir_variable *var, bool in_assignee)
{
   loop_variable *lv = this->get(var);

   if (lv == NULL) {
      lv = this->insert(var);
      lv->read_before_write = !in_assignee;
   }

   return lv;
}


namespace {

class loop_analysis : public ir_hierarchical_visitor {
public:
   loop_analysis(loop_state *loops);

   virtual ir_visitor_status visit(ir_loop_jump *);
   virtual ir_visitor_status visit(ir_dereference_variable *);

   virtual ir_visitor_status visit_enter(ir_call *);

   virtual ir_visitor_status visit_enter(ir_loop *);
   virtual ir_visitor_status visit_leave(ir_loop *);
   virtual ir_visitor_status visit_enter(ir_assignment *);
   virtual ir_visitor_status visit_leave(ir_assignment *);
   virtual ir_visitor_status visit_enter(ir_if *);
   virtual ir_visitor_status visit_leave(ir_if *);

   loop_state *loops;

   int if_statement_depth;

   ir_assignment *current_assignment;

   exec_list state;
};

} /* anonymous namespace */

loop_analysis::loop_analysis(loop_state *loops)
   : loops(loops), if_statement_depth(0), current_assignment(NULL)
{
   /* empty */
}


ir_visitor_status
loop_analysis::visit(ir_loop_jump *ir)
{
   (void) ir;

   assert(!this->state.is_empty());

   loop_variable_state *const ls =
      (loop_variable_state *) this->state.get_head();

   ls->num_loop_jumps++;

   return visit_continue;
}


ir_visitor_status
loop_analysis::visit_enter(ir_call *)
{
   /* Mark every loop that we're currently analyzing as containing an ir_call
    * (even those at outer nesting levels).
    */
   foreach_list(node, &this->state) {
      loop_variable_state *const ls = (loop_variable_state *) node;
      ls->contains_calls = true;
   }

   return visit_continue_with_parent;
}


ir_visitor_status
loop_analysis::visit(ir_dereference_variable *ir)
{
   /* If we're not somewhere inside a loop, there's nothing to do.
    */
   if (this->state.is_empty())
      return visit_continue;

   bool nested = false;

   foreach_list(node, &this->state) {
      loop_variable_state *const ls = (loop_variable_state *) node;

      ir_variable *var = ir->variable_referenced();
      loop_variable *lv = ls->get_or_insert(var, this->in_assignee);

      lv->record_reference(this->in_assignee,
                           nested || this->if_statement_depth > 0,
                           this->current_assignment);
      nested = true;
   }

   return visit_continue;
}

ir_visitor_status
loop_analysis::visit_enter(ir_loop *ir)
{
   loop_variable_state *ls = this->loops->insert(ir);
   this->state.push_head(ls);

   return visit_continue;
}

ir_visitor_status
loop_analysis::visit_leave(ir_loop *ir)
{
   loop_variable_state *const ls =
      (loop_variable_state *) this->state.pop_head();

   /* Function calls may contain side effects.  These could alter any of our
    * variables in ways that cannot be known, and may even terminate shader
    * execution (say, calling discard in the fragment shader).  So we can't
    * rely on any of our analysis about assignments to variables.
    *
    * We could perform some conservative analysis (prove there's no statically
    * possible assignment, etc.) but it isn't worth it for now; function
    * inlining will allow us to unroll loops anyway.
    */
   if (ls->contains_calls)
      return visit_continue;

   foreach_list(node, &ir->body_instructions) {
      /* Skip over declarations at the start of a loop.
       */
      if (((ir_instruction *) node)->as_variable())
	 continue;

      ir_if *if_stmt = ((ir_instruction *) node)->as_if();

      if ((if_stmt != NULL) && is_loop_terminator(if_stmt))
	 ls->insert(if_stmt);
      else
	 break;
   }


   foreach_list_safe(node, &ls->variables) {
      loop_variable *lv = (loop_variable *) node;

      /* Move variables that are already marked as being loop constant to
       * a separate list.  These trivially don't need to be tested.
       */
      if (lv->is_loop_constant()) {
	 lv->remove();
	 ls->constants.push_tail(lv);
      }
   }

   /* Each variable assigned in the loop that isn't already marked as being loop
    * constant might still be loop constant.  The requirements at this point
    * are:
    *
    *    - Variable is written before it is read.
    *
    *    - Only one assignment to the variable.
    *
    *    - All operands on the RHS of the assignment are also loop constants.
    *
    * The last requirement is the reason for the progress loop.  A variable
    * marked as a loop constant on one pass may allow other variables to be
    * marked as loop constant on following passes.
    */
   bool progress;
   do {
      progress = false;

      foreach_list_safe(node, &ls->variables) {
	 loop_variable *lv = (loop_variable *) node;

	 if (lv->conditional_or_nested_assignment || (lv->num_assignments > 1))
	    continue;

	 /* Process the RHS of the assignment.  If all of the variables
	  * accessed there are loop constants, then add this
	  */
	 ir_rvalue *const rhs = lv->first_assignment->rhs;
	 if (all_expression_operands_are_loop_constant(rhs, ls->var_hash)) {
	    lv->rhs_clean = true;

	    if (lv->is_loop_constant()) {
	       progress = true;

	       lv->remove();
	       ls->constants.push_tail(lv);
	    }
	 }
      }
   } while (progress);

   /* The remaining variables that are not loop invariant might be loop
    * induction variables.
    */
   foreach_list_safe(node, &ls->variables) {
      loop_variable *lv = (loop_variable *) node;

      /* If there is more than one assignment to a variable, it cannot be a
       * loop induction variable.  This isn't strictly true, but this is a
       * very simple induction variable detector, and it can't handle more
       * complex cases.
       */
      if (lv->num_assignments > 1)
	 continue;

      /* All of the variables with zero assignments in the loop are loop
       * invariant, and they should have already been filtered out.
       */
      assert(lv->num_assignments == 1);
      assert(lv->first_assignment != NULL);

      /* The assignment to the variable in the loop must be unconditional and
       * not inside a nested loop.
       */
      if (lv->conditional_or_nested_assignment)
	 continue;

      /* Basic loop induction variables have a single assignment in the loop
       * that has the form 'VAR = VAR + i' or 'VAR = VAR - i' where i is a
       * loop invariant.
       */
      ir_rvalue *const inc =
	 get_basic_induction_increment(lv->first_assignment, ls->var_hash);
      if (inc != NULL) {
	 lv->increment = inc;

	 lv->remove();
	 ls->induction_variables.push_tail(lv);
      }
   }

   /* Search the loop terminating conditions for those of the form 'i < c'
    * where i is a loop induction variable, c is a constant, and < is any
    * relative operator.  From each of these we can infer an iteration count.
    * Also figure out which terminator (if any) produces the smallest
    * iteration count--this is the limiting terminator.
    */
   foreach_list(node, &ls->terminators) {
      loop_terminator *t = (loop_terminator *) node;
      ir_if *if_stmt = t->ir;

      /* If-statements can be either 'if (expr)' or 'if (deref)'.  We only care
       * about the former here.
       */
      ir_expression *cond = if_stmt->condition->as_expression();
      if (cond == NULL)
	 continue;

      switch (cond->operation) {
      case ir_binop_less:
      case ir_binop_greater:
      case ir_binop_lequal:
      case ir_binop_gequal: {
	 /* The expressions that we care about will either be of the form
	  * 'counter < limit' or 'limit < counter'.  Figure out which is
	  * which.
	  */
	 ir_rvalue *counter = cond->operands[0]->as_dereference_variable();
	 ir_constant *limit = cond->operands[1]->as_constant();
	 enum ir_expression_operation cmp = cond->operation;

	 if (limit == NULL) {
	    counter = cond->operands[1]->as_dereference_variable();
	    limit = cond->operands[0]->as_constant();

	    switch (cmp) {
	    case ir_binop_less:    cmp = ir_binop_greater; break;
	    case ir_binop_greater: cmp = ir_binop_less;    break;
	    case ir_binop_lequal:  cmp = ir_binop_gequal;  break;
	    case ir_binop_gequal:  cmp = ir_binop_lequal;  break;
	    default: assert(!"Should not get here.");
	    }
	 }

	 if ((counter == NULL) || (limit == NULL))
	    break;

	 ir_variable *var = counter->variable_referenced();

	 ir_rvalue *init = find_initial_value(ir, var);

         loop_variable *lv = ls->get(var);
         if (lv != NULL && lv->is_induction_var()) {
            t->iterations = calculate_iterations(init, limit, lv->increment,
                                                 cmp);

            if (t->iterations >= 0 &&
                (ls->limiting_terminator == NULL ||
                 t->iterations < ls->limiting_terminator->iterations)) {
               ls->limiting_terminator = t;
            }
         }
         break;
      }

      default:
         break;
      }
   }

   return visit_continue;
}

ir_visitor_status
loop_analysis::visit_enter(ir_if *ir)
{
   (void) ir;

   if (!this->state.is_empty())
      this->if_statement_depth++;

   return visit_continue;
}

ir_visitor_status
loop_analysis::visit_leave(ir_if *ir)
{
   (void) ir;

   if (!this->state.is_empty())
      this->if_statement_depth--;

   return visit_continue;
}

ir_visitor_status
loop_analysis::visit_enter(ir_assignment *ir)
{
   /* If we're not somewhere inside a loop, there's nothing to do.
    */
   if (this->state.is_empty())
      return visit_continue_with_parent;

   this->current_assignment = ir;

   return visit_continue;
}

ir_visitor_status
loop_analysis::visit_leave(ir_assignment *ir)
{
   /* Since the visit_enter exits with visit_continue_with_parent for this
    * case, the loop state stack should never be empty here.
    */
   assert(!this->state.is_empty());

   assert(this->current_assignment == ir);
   this->current_assignment = NULL;

   return visit_continue;
}


class examine_rhs : public ir_hierarchical_visitor {
public:
   examine_rhs(hash_table *loop_variables)
   {
      this->only_uses_loop_constants = true;
      this->loop_variables = loop_variables;
   }

   virtual ir_visitor_status visit(ir_dereference_variable *ir)
   {
      loop_variable *lv =
	 (loop_variable *) hash_table_find(this->loop_variables, ir->var);

      assert(lv != NULL);

      if (lv->is_loop_constant()) {
	 return visit_continue;
      } else {
	 this->only_uses_loop_constants = false;
	 return visit_stop;
      }
   }

   hash_table *loop_variables;
   bool only_uses_loop_constants;
};


bool
all_expression_operands_are_loop_constant(ir_rvalue *ir, hash_table *variables)
{
   examine_rhs v(variables);

   ir->accept(&v);

   return v.only_uses_loop_constants;
}


ir_rvalue *
get_basic_induction_increment(ir_assignment *ir, hash_table *var_hash)
{
   /* The RHS must be a binary expression.
    */
   ir_expression *const rhs = ir->rhs->as_expression();
   if ((rhs == NULL)
       || ((rhs->operation != ir_binop_add)
	   && (rhs->operation != ir_binop_sub)))
      return NULL;

   /* One of the of operands of the expression must be the variable assigned.
    * If the operation is subtraction, the variable in question must be the
    * "left" operand.
    */
   ir_variable *const var = ir->lhs->variable_referenced();

   ir_variable *const op0 = rhs->operands[0]->variable_referenced();
   ir_variable *const op1 = rhs->operands[1]->variable_referenced();

   if (((op0 != var) && (op1 != var))
       || ((op1 == var) && (rhs->operation == ir_binop_sub)))
      return NULL;

   ir_rvalue *inc = (op0 == var) ? rhs->operands[1] : rhs->operands[0];

   if (inc->as_constant() == NULL) {
      ir_variable *const inc_var = inc->variable_referenced();
      if (inc_var != NULL) {
	 loop_variable *lv =
	    (loop_variable *) hash_table_find(var_hash, inc_var);

	 if (!lv->is_loop_constant())
	    inc = NULL;
      } else
	 inc = NULL;
   }

   if ((inc != NULL) && (rhs->operation == ir_binop_sub)) {
      void *mem_ctx = ralloc_parent(ir);

      inc = new(mem_ctx) ir_expression(ir_unop_neg,
				       inc->type,
				       inc->clone(mem_ctx, NULL),
				       NULL);
   }

   return inc;
}


/**
 * Detect whether an if-statement is a loop terminating condition
 *
 * Detects if-statements of the form
 *
 *  (if (expression bool ...) (break))
 */
bool
is_loop_terminator(ir_if *ir)
{
   if (!ir->else_instructions.is_empty())
      return false;

   ir_instruction *const inst =
      (ir_instruction *) ir->then_instructions.get_head();
   if (inst == NULL)
      return false;

   if (inst->ir_type != ir_type_loop_jump)
      return false;

   ir_loop_jump *const jump = (ir_loop_jump *) inst;
   if (jump->mode != ir_loop_jump::jump_break)
      return false;

   return true;
}


loop_state *
analyze_loop_variables(exec_list *instructions)
{
   loop_state *loops = new loop_state;
   loop_analysis v(loops);

   v.run(instructions);
   return v.loops;
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d230 2
a231 1
   foreach_in_list(loop_variable_state, ls, &this->state) {
d249 3
a251 1
   foreach_in_list(loop_variable_state, ls, &this->state) {
d291 1
a291 1
   foreach_in_list(ir_instruction, node, &ir->body_instructions) {
d294 1
a294 1
      if (node->as_variable())
d306 3
a308 1
   foreach_in_list_safe(loop_variable, lv, &ls->variables) {
d336 3
a338 1
      foreach_in_list_safe(loop_variable, lv, &ls->variables) {
d362 3
a364 1
   foreach_in_list_safe(loop_variable, lv, &ls->variables) {
d405 2
a406 1
   foreach_in_list(loop_terminator, t, &ls->terminators) {
d592 2
a593 4
         if (lv == NULL || !lv->is_loop_constant()) {
            assert(lv != NULL);
            inc = NULL;
         }
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d230 1
a230 2
   foreach_list(node, &this->state) {
      loop_variable_state *const ls = (loop_variable_state *) node;
d248 1
a248 3
   foreach_list(node, &this->state) {
      loop_variable_state *const ls = (loop_variable_state *) node;

d288 1
a288 1
   foreach_list(node, &ir->body_instructions) {
d291 1
a291 1
      if (((ir_instruction *) node)->as_variable())
d303 1
a303 3
   foreach_list_safe(node, &ls->variables) {
      loop_variable *lv = (loop_variable *) node;

d331 1
a331 3
      foreach_list_safe(node, &ls->variables) {
	 loop_variable *lv = (loop_variable *) node;

d355 1
a355 3
   foreach_list_safe(node, &ls->variables) {
      loop_variable *lv = (loop_variable *) node;

d396 1
a396 2
   foreach_list(node, &ls->terminators) {
      loop_terminator *t = (loop_terminator *) node;
d582 4
a585 2
	 if (!lv->is_loop_constant())
	    inc = NULL;
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d36 40
d137 1
a137 1
   loop_terminator *t = rzalloc(mem_ctx, loop_terminator);
d146 28
d199 1
d225 1
a225 1
loop_analysis::visit_enter(ir_call *ir)
d227 7
a233 6
   /* If we're not somewhere inside a loop, there's nothing to do. */
   if (this->state.is_empty())
      return visit_continue;

   loop_variable_state *const ls =
      (loop_variable_state *) this->state.get_head();
a234 1
   ls->contains_calls = true;
d247 1
a247 10
   loop_variable_state *const ls =
      (loop_variable_state *) this->state.get_head();

   ir_variable *var = ir->variable_referenced();
   loop_variable *lv = ls->get(var);

   if (lv == NULL) {
      lv = ls->insert(var);
      lv->read_before_write = !this->in_assignee;
   }
d249 2
a250 2
   if (this->in_assignee) {
      assert(this->current_assignment != NULL);
d252 2
a253 2
      lv->conditional_assignment = (this->if_statement_depth > 0)
	 || (this->current_assignment->condition != NULL);
d255 4
a258 12
      if (lv->first_assignment == NULL) {
	 assert(lv->num_assignments == 0);

	 lv->first_assignment = this->current_assignment;
      }

      lv->num_assignments++;
   } else if (lv->first_assignment == this->current_assignment) {
      /* This catches the case where the variable is used in the RHS of an
       * assignment where it is also in the LHS.
       */
      lv->read_before_write = true;
d339 1
a339 1
	 if (lv->conditional_assignment || (lv->num_assignments > 1))
d379 2
a380 1
      /* The assignmnet to the variable in the loop must be unconditional.
d382 1
a382 1
      if (lv->conditional_assignment)
a391 2
	 lv->iv_scale = NULL;
	 lv->biv = lv->var;
d396 69
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d108 1
a108 1
   loop_analysis();
d113 2
d132 2
a133 1
loop_analysis::loop_analysis()
d135 1
a135 4
   this->loops = new loop_state;

   this->if_statement_depth = 0;
   this->current_assignment = NULL;
d156 15
d227 11
d506 2
a507 1
   assert(inst != NULL);
d523 2
a524 1
   loop_analysis v;
@


1.1
log
@Initial revision
@
text
@d41 1
d56 1
d58 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a40 1
   this->loop_found = false;
a54 1

a55 1
   this->loop_found = true;
d105 1
a105 1
   loop_analysis(loop_state *loops);
a109 2
   virtual ir_visitor_status visit_enter(ir_call *);

d127 1
a127 2
loop_analysis::loop_analysis(loop_state *loops)
   : loops(loops), if_statement_depth(0), current_assignment(NULL)
d129 4
a132 1
   /* empty */
a152 15
loop_analysis::visit_enter(ir_call *ir)
{
   /* If we're not somewhere inside a loop, there's nothing to do. */
   if (this->state.is_empty())
      return visit_continue;

   loop_variable_state *const ls =
      (loop_variable_state *) this->state.get_head();

   ls->contains_calls = true;
   return visit_continue_with_parent;
}


ir_visitor_status
a208 11
   /* Function calls may contain side effects.  These could alter any of our
    * variables in ways that cannot be known, and may even terminate shader
    * execution (say, calling discard in the fragment shader).  So we can't
    * rely on any of our analysis about assignments to variables.
    *
    * We could perform some conservative analysis (prove there's no statically
    * possible assignment, etc.) but it isn't worth it for now; function
    * inlining will allow us to unroll loops anyway.
    */
   if (ls->contains_calls)
      return visit_continue;
d477 1
a477 2
   if (inst == NULL)
      return false;
d493 1
a493 2
   loop_state *loops = new loop_state;
   loop_analysis v(loops);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a35 40
/**
 * Record the fact that the given loop variable was referenced inside the loop.
 *
 * \arg in_assignee is true if the reference was on the LHS of an assignment.
 *
 * \arg in_conditional_code_or_nested_loop is true if the reference occurred
 * inside an if statement or a nested loop.
 *
 * \arg current_assignment is the ir_assignment node that the loop variable is
 * on the LHS of, if any (ignored if \c in_assignee is false).
 */
void
loop_variable::record_reference(bool in_assignee,
                                bool in_conditional_code_or_nested_loop,
                                ir_assignment *current_assignment)
{
   if (in_assignee) {
      assert(current_assignment != NULL);

      if (in_conditional_code_or_nested_loop ||
          current_assignment->condition != NULL) {
         this->conditional_or_nested_assignment = true;
      }

      if (this->first_assignment == NULL) {
         assert(this->num_assignments == 0);

         this->first_assignment = current_assignment;
      }

      this->num_assignments++;
   } else if (this->first_assignment == current_assignment) {
      /* This catches the case where the variable is used in the RHS of an
       * assignment where it is also in the LHS.
       */
      this->read_before_write = true;
   }
}


d97 1
a97 1
   loop_terminator *t = new(mem_ctx) loop_terminator();
a105 28
/**
 * If the given variable already is recorded in the state for this loop,
 * return the corresponding loop_variable object that records information
 * about it.
 *
 * Otherwise, create a new loop_variable object to record information about
 * the variable, and set its \c read_before_write field appropriately based on
 * \c in_assignee.
 *
 * \arg in_assignee is true if this variable was encountered on the LHS of an
 * assignment.
 */
loop_variable *
loop_variable_state::get_or_insert(ir_variable *var, bool in_assignee)
{
   loop_variable *lv = this->get(var);

   if (lv == NULL) {
      lv = this->insert(var);
      lv->read_before_write = !in_assignee;
   }

   return lv;
}


namespace {

a130 1
} /* anonymous namespace */
d156 1
a156 1
loop_analysis::visit_enter(ir_call *)
d158 6
a163 7
   /* Mark every loop that we're currently analyzing as containing an ir_call
    * (even those at outer nesting levels).
    */
   foreach_list(node, &this->state) {
      loop_variable_state *const ls = (loop_variable_state *) node;
      ls->contains_calls = true;
   }
d165 1
d178 10
a187 1
   bool nested = false;
d189 2
a190 2
   foreach_list(node, &this->state) {
      loop_variable_state *const ls = (loop_variable_state *) node;
d192 2
a193 2
      ir_variable *var = ir->variable_referenced();
      loop_variable *lv = ls->get_or_insert(var, this->in_assignee);
d195 12
a206 4
      lv->record_reference(this->in_assignee,
                           nested || this->if_statement_depth > 0,
                           this->current_assignment);
      nested = true;
d287 1
a287 1
	 if (lv->conditional_or_nested_assignment || (lv->num_assignments > 1))
d327 1
a327 2
      /* The assignment to the variable in the loop must be unconditional and
       * not inside a nested loop.
d329 1
a329 1
      if (lv->conditional_or_nested_assignment)
d339 2
a344 69
      }
   }

   /* Search the loop terminating conditions for those of the form 'i < c'
    * where i is a loop induction variable, c is a constant, and < is any
    * relative operator.  From each of these we can infer an iteration count.
    * Also figure out which terminator (if any) produces the smallest
    * iteration count--this is the limiting terminator.
    */
   foreach_list(node, &ls->terminators) {
      loop_terminator *t = (loop_terminator *) node;
      ir_if *if_stmt = t->ir;

      /* If-statements can be either 'if (expr)' or 'if (deref)'.  We only care
       * about the former here.
       */
      ir_expression *cond = if_stmt->condition->as_expression();
      if (cond == NULL)
	 continue;

      switch (cond->operation) {
      case ir_binop_less:
      case ir_binop_greater:
      case ir_binop_lequal:
      case ir_binop_gequal: {
	 /* The expressions that we care about will either be of the form
	  * 'counter < limit' or 'limit < counter'.  Figure out which is
	  * which.
	  */
	 ir_rvalue *counter = cond->operands[0]->as_dereference_variable();
	 ir_constant *limit = cond->operands[1]->as_constant();
	 enum ir_expression_operation cmp = cond->operation;

	 if (limit == NULL) {
	    counter = cond->operands[1]->as_dereference_variable();
	    limit = cond->operands[0]->as_constant();

	    switch (cmp) {
	    case ir_binop_less:    cmp = ir_binop_greater; break;
	    case ir_binop_greater: cmp = ir_binop_less;    break;
	    case ir_binop_lequal:  cmp = ir_binop_gequal;  break;
	    case ir_binop_gequal:  cmp = ir_binop_lequal;  break;
	    default: assert(!"Should not get here.");
	    }
	 }

	 if ((counter == NULL) || (limit == NULL))
	    break;

	 ir_variable *var = counter->variable_referenced();

	 ir_rvalue *init = find_initial_value(ir, var);

         loop_variable *lv = ls->get(var);
         if (lv != NULL && lv->is_induction_var()) {
            t->iterations = calculate_iterations(init, limit, lv->increment,
                                                 cmp);

            if (t->iterations >= 0 &&
                (ls->limiting_terminator == NULL ||
                 t->iterations < ls->limiting_terminator->iterations)) {
               ls->limiting_terminator = t;
            }
         }
         break;
      }

      default:
         break;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d230 2
a231 1
   foreach_in_list(loop_variable_state, ls, &this->state) {
d249 3
a251 1
   foreach_in_list(loop_variable_state, ls, &this->state) {
d291 1
a291 1
   foreach_in_list(ir_instruction, node, &ir->body_instructions) {
d294 1
a294 1
      if (node->as_variable())
d306 3
a308 1
   foreach_in_list_safe(loop_variable, lv, &ls->variables) {
d336 3
a338 1
      foreach_in_list_safe(loop_variable, lv, &ls->variables) {
d362 3
a364 1
   foreach_in_list_safe(loop_variable, lv, &ls->variables) {
d405 2
a406 1
   foreach_in_list(loop_terminator, t, &ls->terminators) {
d592 2
a593 4
         if (lv == NULL || !lv->is_loop_constant()) {
            assert(lv != NULL);
            inc = NULL;
         }
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d230 1
a230 2
   foreach_list(node, &this->state) {
      loop_variable_state *const ls = (loop_variable_state *) node;
d248 1
a248 3
   foreach_list(node, &this->state) {
      loop_variable_state *const ls = (loop_variable_state *) node;

d288 1
a288 1
   foreach_list(node, &ir->body_instructions) {
d291 1
a291 1
      if (((ir_instruction *) node)->as_variable())
d303 1
a303 3
   foreach_list_safe(node, &ls->variables) {
      loop_variable *lv = (loop_variable *) node;

d331 1
a331 3
      foreach_list_safe(node, &ls->variables) {
	 loop_variable *lv = (loop_variable *) node;

d355 1
a355 3
   foreach_list_safe(node, &ls->variables) {
      loop_variable *lv = (loop_variable *) node;

d396 1
a396 2
   foreach_list(node, &ls->terminators) {
      loop_terminator *t = (loop_terminator *) node;
d582 4
a585 2
	 if (!lv->is_loop_constant())
	    inc = NULL;
@


