head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.27;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.17;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.30;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.22;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.29;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * \file ir_set_program_inouts.cpp
 *
 * Sets the InputsRead and OutputsWritten of Mesa programs.
 *
 * Additionally, for fragment shaders, sets the InterpQualifier array, the
 * IsCentroid and IsSample bitfields, and the UsesDFdy flag.
 *
 * Mesa programs (gl_program, not gl_shader_program) have a set of
 * flags indicating which varyings are read and written.  Computing
 * which are actually read from some sort of backend code can be
 * tricky when variable array indexing involved.  So this pass
 * provides support for setting InputsRead and OutputsWritten right
 * from the GLSL IR.
 */

#include "main/core.h" /* for struct gl_program */
#include "ir.h"
#include "ir_visitor.h"
#include "glsl_types.h"

namespace {

class ir_set_program_inouts_visitor : public ir_hierarchical_visitor {
public:
   ir_set_program_inouts_visitor(struct gl_program *prog,
                                 gl_shader_stage shader_stage)
   {
      this->prog = prog;
      this->shader_stage = shader_stage;
   }
   ~ir_set_program_inouts_visitor()
   {
   }

   virtual ir_visitor_status visit_enter(ir_dereference_array *);
   virtual ir_visitor_status visit_enter(ir_function_signature *);
   virtual ir_visitor_status visit_enter(ir_expression *);
   virtual ir_visitor_status visit_enter(ir_discard *);
   virtual ir_visitor_status visit_enter(ir_texture *);
   virtual ir_visitor_status visit(ir_dereference_variable *);

private:
   void mark_whole_variable(ir_variable *var);
   bool try_mark_partial_variable(ir_variable *var, ir_rvalue *index);

   struct gl_program *prog;
   gl_shader_stage shader_stage;
};

} /* anonymous namespace */

static inline bool
is_shader_inout(ir_variable *var)
{
   return var->data.mode == ir_var_shader_in ||
          var->data.mode == ir_var_shader_out ||
          var->data.mode == ir_var_system_value;
}

static void
mark(struct gl_program *prog, ir_variable *var, int offset, int len,
     bool is_fragment_shader)
{
   /* As of GLSL 1.20, varyings can only be floats, floating-point
    * vectors or matrices, or arrays of them.  For Mesa programs using
    * InputsRead/OutputsWritten, everything but matrices uses one
    * slot, while matrices use a slot per column.  Presumably
    * something doing a more clever packing would use something other
    * than InputsRead/OutputsWritten.
    */

   for (int i = 0; i < len; i++) {
      GLbitfield64 bitfield =
         BITFIELD64_BIT(var->data.location + var->data.index + offset + i);
      if (var->data.mode == ir_var_shader_in) {
	 prog->InputsRead |= bitfield;
         if (is_fragment_shader) {
            gl_fragment_program *fprog = (gl_fragment_program *) prog;
            fprog->InterpQualifier[var->data.location +
                                   var->data.index + offset + i] =
               (glsl_interp_qualifier) var->data.interpolation;
            if (var->data.centroid)
               fprog->IsCentroid |= bitfield;
            if (var->data.sample)
               fprog->IsSample |= bitfield;
         }
      } else if (var->data.mode == ir_var_system_value) {
         prog->SystemValuesRead |= bitfield;
      } else {
         assert(var->data.mode == ir_var_shader_out);
	 prog->OutputsWritten |= bitfield;
      }
   }
}

/**
 * Mark an entire variable as used.  Caller must ensure that the variable
 * represents a shader input or output.
 */
void
ir_set_program_inouts_visitor::mark_whole_variable(ir_variable *var)
{
   const glsl_type *type = var->type;
   if (this->shader_stage == MESA_SHADER_GEOMETRY &&
       var->data.mode == ir_var_shader_in && type->is_array()) {
      type = type->fields.array;
   }

   mark(this->prog, var, 0, type->count_attribute_slots(),
        this->shader_stage == MESA_SHADER_FRAGMENT);
}

/* Default handler: Mark all the locations in the variable as used. */
ir_visitor_status
ir_set_program_inouts_visitor::visit(ir_dereference_variable *ir)
{
   if (!is_shader_inout(ir->var))
      return visit_continue;

   mark_whole_variable(ir->var);

   return visit_continue;
}

/**
 * Try to mark a portion of the given variable as used.  Caller must ensure
 * that the variable represents a shader input or output which can be indexed
 * into in array fashion (an array or matrix).  For the purpose of geometry
 * shader inputs (which are always arrays*), this means that the array element
 * must be something that can be indexed into in array fashion.
 *
 * *Except gl_PrimitiveIDIn, as noted below.
 *
 * If the index can't be interpreted as a constant, or some other problem
 * occurs, then nothing will be marked and false will be returned.
 */
bool
ir_set_program_inouts_visitor::try_mark_partial_variable(ir_variable *var,
                                                         ir_rvalue *index)
{
   const glsl_type *type = var->type;

   if (this->shader_stage == MESA_SHADER_GEOMETRY &&
       var->data.mode == ir_var_shader_in) {
      /* The only geometry shader input that is not an array is
       * gl_PrimitiveIDIn, and in that case, this code will never be reached,
       * because gl_PrimitiveIDIn can't be indexed into in array fashion.
       */
      assert(type->is_array());
      type = type->fields.array;
   }

   /* The code below only handles:
    *
    * - Indexing into matrices
    * - Indexing into arrays of (matrices, vectors, or scalars)
    *
    * All other possibilities are either prohibited by GLSL (vertex inputs and
    * fragment outputs can't be structs) or should have been eliminated by
    * lowering passes (do_vec_index_to_swizzle() gets rid of indexing into
    * vectors, and lower_packed_varyings() gets rid of structs that occur in
    * varyings).
    */
   if (!(type->is_matrix() ||
        (type->is_array() &&
         (type->fields.array->is_numeric() ||
          type->fields.array->is_boolean())))) {
      assert(!"Unexpected indexing in ir_set_program_inouts");

      /* For safety in release builds, in case we ever encounter unexpected
       * indexing, give up and let the caller mark the whole variable as used.
       */
      return false;
   }

   ir_constant *index_as_constant = index->as_constant();
   if (!index_as_constant)
      return false;

   unsigned elem_width;
   unsigned num_elems;
   if (type->is_array()) {
      num_elems = type->length;
      if (type->fields.array->is_matrix())
         elem_width = type->fields.array->matrix_columns;
      else
         elem_width = 1;
   } else {
      num_elems = type->matrix_columns;
      elem_width = 1;
   }

   if (index_as_constant->value.u[0] >= num_elems) {
      /* Constant index outside the bounds of the matrix/array.  This could
       * arise as a result of constant folding of a legal GLSL program.
       *
       * Even though the spec says that indexing outside the bounds of a
       * matrix/array results in undefined behaviour, we don't want to pass
       * out-of-range values to mark() (since this could result in slots that
       * don't exist being marked as used), so just let the caller mark the
       * whole variable as used.
       */
      return false;
   }

   mark(this->prog, var, index_as_constant->value.u[0] * elem_width,
        elem_width, this->shader_stage == MESA_SHADER_FRAGMENT);
   return true;
}

ir_visitor_status
ir_set_program_inouts_visitor::visit_enter(ir_dereference_array *ir)
{
   /* Note: for geometry shader inputs, lower_named_interface_blocks may
    * create 2D arrays, so we need to be able to handle those.  2D arrays
    * shouldn't be able to crop up for any other reason.
    */
   if (ir_dereference_array * const inner_array =
       ir->array->as_dereference_array()) {
      /*          ir => foo[i][j]
       * inner_array => foo[i]
       */
      if (ir_dereference_variable * const deref_var =
          inner_array->array->as_dereference_variable()) {
         if (this->shader_stage == MESA_SHADER_GEOMETRY &&
             deref_var->var->data.mode == ir_var_shader_in) {
            /* foo is a geometry shader input, so i is the vertex, and j the
             * part of the input we're accessing.
             */
            if (try_mark_partial_variable(deref_var->var, ir->array_index))
            {
               /* We've now taken care of foo and j, but i might contain a
                * subexpression that accesses shader inputs.  So manually
                * visit i and then continue with the parent.
                */
               inner_array->array_index->accept(this);
               return visit_continue_with_parent;
            }
         }
      }
   } else if (ir_dereference_variable * const deref_var =
              ir->array->as_dereference_variable()) {
      /* ir => foo[i], where foo is a variable. */
      if (this->shader_stage == MESA_SHADER_GEOMETRY &&
          deref_var->var->data.mode == ir_var_shader_in) {
         /* foo is a geometry shader input, so i is the vertex, and we're
          * accessing the entire input.
          */
         mark_whole_variable(deref_var->var);
         /* We've now taken care of foo, but i might contain a subexpression
          * that accesses shader inputs.  So manually visit i and then
          * continue with the parent.
          */
         ir->array_index->accept(this);
         return visit_continue_with_parent;
      } else if (is_shader_inout(deref_var->var)) {
         /* foo is a shader input/output, but not a geometry shader input,
          * so i is the part of the input we're accessing.
          */
         if (try_mark_partial_variable(deref_var->var, ir->array_index))
            return visit_continue_with_parent;
      }
   }

   /* The expression is something we don't recognize.  Just visit its
    * subexpressions.
    */
   return visit_continue;
}

ir_visitor_status
ir_set_program_inouts_visitor::visit_enter(ir_function_signature *ir)
{
   /* We don't want to descend into the function parameters and
    * consider them as shader inputs or outputs.
    */
   visit_list_elements(this, &ir->body);
   return visit_continue_with_parent;
}

ir_visitor_status
ir_set_program_inouts_visitor::visit_enter(ir_expression *ir)
{
   if (this->shader_stage == MESA_SHADER_FRAGMENT &&
       ir->operation == ir_unop_dFdy) {
      gl_fragment_program *fprog = (gl_fragment_program *) prog;
      fprog->UsesDFdy = true;
   }
   return visit_continue;
}

ir_visitor_status
ir_set_program_inouts_visitor::visit_enter(ir_discard *)
{
   /* discards are only allowed in fragment shaders. */
   assert(this->shader_stage == MESA_SHADER_FRAGMENT);

   gl_fragment_program *fprog = (gl_fragment_program *) prog;
   fprog->UsesKill = true;

   return visit_continue;
}

ir_visitor_status
ir_set_program_inouts_visitor::visit_enter(ir_texture *ir)
{
   if (ir->op == ir_tg4)
      prog->UsesGather = true;
   return visit_continue;
}

void
do_set_program_inouts(exec_list *instructions, struct gl_program *prog,
                      gl_shader_stage shader_stage)
{
   ir_set_program_inouts_visitor v(prog, shader_stage);

   prog->InputsRead = 0;
   prog->OutputsWritten = 0;
   prog->SystemValuesRead = 0;
   if (shader_stage == MESA_SHADER_FRAGMENT) {
      gl_fragment_program *fprog = (gl_fragment_program *) prog;
      memset(fprog->InterpQualifier, 0, sizeof(fprog->InterpQualifier));
      fprog->IsCentroid = 0;
      fprog->IsSample = 0;
      fprog->UsesDFdy = false;
      fprog->UsesKill = false;
   }
   visit_list_elements(&v, instructions);
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d309 1
a309 3
       (ir->operation == ir_unop_dFdy ||
        ir->operation == ir_unop_dFdy_coarse ||
        ir->operation == ir_unop_dFdy_fine)) {
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d309 3
a311 1
       ir->operation == ir_unop_dFdy) {
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d30 1
a30 1
 * IsCentroid bitfield, and the UsesDFdy flag.
d45 2
d50 1
a50 1
                                 bool is_fragment_shader)
d53 1
a53 1
      this->is_fragment_shader = is_fragment_shader;
d63 1
d66 4
d71 1
a71 1
   bool is_fragment_shader;
d74 2
d79 3
a81 3
   return var->mode == ir_var_shader_in ||
          var->mode == ir_var_shader_out ||
          var->mode == ir_var_system_value;
d97 3
a99 2
      GLbitfield64 bitfield = BITFIELD64_BIT(var->location + var->index + offset + i);
      if (var->mode == ir_var_shader_in) {
d103 4
a106 3
            fprog->InterpQualifier[var->location + var->index + offset + i] =
               (glsl_interp_qualifier) var->interpolation;
            if (var->centroid)
d108 2
d111 1
a111 1
      } else if (var->mode == ir_var_system_value) {
d114 1
a114 1
         assert(var->mode == ir_var_shader_out);
d120 17
d144 68
a211 4
   if (ir->type->is_array()) {
      mark(this->prog, ir->var, 0,
	   ir->type->length * ir->type->fields.array->matrix_columns,
           this->is_fragment_shader);
d213 15
a227 2
      mark(this->prog, ir->var, 0, ir->type->matrix_columns,
           this->is_fragment_shader);
d230 3
a232 1
   return visit_continue;
d238 48
a285 15
   ir_dereference_variable *deref_var;
   ir_constant *index = ir->array_index->as_constant();
   deref_var = ir->array->as_dereference_variable();
   ir_variable *var = deref_var ? deref_var->var : NULL;

   /* Check that we're dereferencing a shader in or out */
   if (!var || !is_shader_inout(var))
      return visit_continue;

   if (index) {
      int width = 1;

      if (deref_var->type->is_array() &&
	  deref_var->type->fields.array->is_matrix()) {
	 width = deref_var->type->fields.array->matrix_columns;
a286 4

      mark(this->prog, var, index->value.i[0] * width, width,
           this->is_fragment_shader);
      return visit_continue_with_parent;
d289 3
d308 2
a309 1
   if (is_fragment_shader && ir->operation == ir_unop_dFdy) {
d320 1
a320 1
   assert(is_fragment_shader);
d328 8
d338 1
a338 1
                      bool is_fragment_shader)
d340 1
a340 1
   ir_set_program_inouts_visitor v(prog, is_fragment_shader);
d345 1
a345 1
   if (is_fragment_shader) {
d349 1
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d29 3
a39 1
extern "C" {
a40 2
#include "program/hash_table.h"
}
d47 2
a48 1
   ir_set_program_inouts_visitor(struct gl_program *prog)
d51 1
a51 3
      this->ht = hash_table_ctor(0,
				 hash_table_pointer_hash,
				 hash_table_pointer_compare);
a54 1
      hash_table_dtor(this->ht);
d59 2
a61 1
   virtual ir_visitor_status visit(ir_variable *);
d64 1
a64 1
   struct hash_table *ht;
d67 8
d76 2
a77 1
mark(struct gl_program *prog, ir_variable *var, int offset, int len)
d88 16
a103 6
      if (var->mode == ir_var_in)
	 prog->InputsRead |= BITFIELD64_BIT(var->location + offset + i);
      else if (var->mode == ir_var_system_value)
         prog->SystemValuesRead |= (1 << (var->location + offset + i));
      else
	 prog->OutputsWritten |= BITFIELD64_BIT(var->location + offset + i);
d111 1
a111 1
   if (hash_table_find(this->ht, ir->var) == NULL)
d115 3
a117 4
      for (unsigned int i = 0; i < ir->type->length; i++) {
	 mark(this->prog, ir->var, i,
	      ir->type->length * ir->type->fields.array->matrix_columns);
      }
d119 2
a120 1
      mark(this->prog, ir->var, 0, ir->type->matrix_columns);
d132 1
a132 1
   ir_variable *var = NULL;
d135 2
a136 2
   if (deref_var)
      var = (ir_variable *)hash_table_find(this->ht, deref_var->var);
d138 1
a138 1
   if (index && var) {
d146 2
a147 1
      mark(this->prog, var, index->value.i[0] * width, width);
d155 11
a165 1
ir_set_program_inouts_visitor::visit(ir_variable *ir)
d167 3
a169 4
   if (ir->mode == ir_var_in ||
       ir->mode == ir_var_out ||
       ir->mode == ir_var_system_value) {
      hash_table_insert(this->ht, ir, ir);
a170 1

d175 1
a175 1
ir_set_program_inouts_visitor::visit_enter(ir_function_signature *ir)
d177 7
a183 5
   /* We don't want to descend into the function parameters and
    * consider them as shader inputs or outputs.
    */
   visit_list_elements(this, &ir->body);
   return visit_continue_with_parent;
d187 2
a188 1
do_set_program_inouts(exec_list *instructions, struct gl_program *prog)
d190 1
a190 1
   ir_set_program_inouts_visitor v(prog);
d195 7
@


1.1
log
@Initial revision
@
text
@d82 2
d139 2
a140 1
       ir->mode == ir_var_out) {
d164 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a28 3
 * Additionally, for fragment shaders, sets the InterpQualifier array, the
 * IsCentroid bitfield, and the UsesDFdy flag.
 *
d37 1
d39 2
d47 1
a47 2
   ir_set_program_inouts_visitor(struct gl_program *prog,
                                 bool is_fragment_shader)
d50 3
a52 1
      this->is_fragment_shader = is_fragment_shader;
d56 1
a60 2
   virtual ir_visitor_status visit_enter(ir_expression *);
   virtual ir_visitor_status visit_enter(ir_discard *);
d62 1
d65 1
a65 1
   bool is_fragment_shader;
a67 8
static inline bool
is_shader_inout(ir_variable *var)
{
   return var->mode == ir_var_shader_in ||
          var->mode == ir_var_shader_out ||
          var->mode == ir_var_system_value;
}

d69 1
a69 2
mark(struct gl_program *prog, ir_variable *var, int offset, int len,
     bool is_fragment_shader)
d80 4
a83 16
      GLbitfield64 bitfield = BITFIELD64_BIT(var->location + var->index + offset + i);
      if (var->mode == ir_var_shader_in) {
	 prog->InputsRead |= bitfield;
         if (is_fragment_shader) {
            gl_fragment_program *fprog = (gl_fragment_program *) prog;
            fprog->InterpQualifier[var->location + var->index + offset + i] =
               (glsl_interp_qualifier) var->interpolation;
            if (var->centroid)
               fprog->IsCentroid |= bitfield;
         }
      } else if (var->mode == ir_var_system_value) {
         prog->SystemValuesRead |= bitfield;
      } else {
         assert(var->mode == ir_var_shader_out);
	 prog->OutputsWritten |= bitfield;
      }
d91 1
a91 1
   if (!is_shader_inout(ir->var))
d95 4
a98 3
      mark(this->prog, ir->var, 0,
	   ir->type->length * ir->type->fields.array->matrix_columns,
           this->is_fragment_shader);
d100 1
a100 2
      mark(this->prog, ir->var, 0, ir->type->matrix_columns,
           this->is_fragment_shader);
d112 1
a112 1
   ir_variable *var = deref_var ? deref_var->var : NULL;
d115 2
a116 2
   if (!var || !is_shader_inout(var))
      return visit_continue;
d118 1
a118 1
   if (index) {
d126 1
a126 2
      mark(this->prog, var, index->value.i[0] * width, width,
           this->is_fragment_shader);
d134 11
a153 22
ir_visitor_status
ir_set_program_inouts_visitor::visit_enter(ir_expression *ir)
{
   if (is_fragment_shader && ir->operation == ir_unop_dFdy) {
      gl_fragment_program *fprog = (gl_fragment_program *) prog;
      fprog->UsesDFdy = true;
   }
   return visit_continue;
}

ir_visitor_status
ir_set_program_inouts_visitor::visit_enter(ir_discard *)
{
   /* discards are only allowed in fragment shaders. */
   assert(is_fragment_shader);

   gl_fragment_program *fprog = (gl_fragment_program *) prog;
   fprog->UsesKill = true;

   return visit_continue;
}

d155 1
a155 2
do_set_program_inouts(exec_list *instructions, struct gl_program *prog,
                      bool is_fragment_shader)
d157 1
a157 1
   ir_set_program_inouts_visitor v(prog, is_fragment_shader);
a160 8
   prog->SystemValuesRead = 0;
   if (is_fragment_shader) {
      gl_fragment_program *fprog = (gl_fragment_program *) prog;
      memset(fprog->InterpQualifier, 0, sizeof(fprog->InterpQualifier));
      fprog->IsCentroid = 0;
      fprog->UsesDFdy = false;
      fprog->UsesKill = false;
   }
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d30 1
a30 1
 * IsCentroid and IsSample bitfields, and the UsesDFdy flag.
a44 2
namespace {

d48 1
a48 1
                                 gl_shader_stage shader_stage)
d51 1
a51 1
      this->shader_stage = shader_stage;
a60 1
   virtual ir_visitor_status visit_enter(ir_texture *);
a62 4
private:
   void mark_whole_variable(ir_variable *var);
   bool try_mark_partial_variable(ir_variable *var, ir_rvalue *index);

d64 1
a64 1
   gl_shader_stage shader_stage;
a66 2
} /* anonymous namespace */

d70 3
a72 3
   return var->data.mode == ir_var_shader_in ||
          var->data.mode == ir_var_shader_out ||
          var->data.mode == ir_var_system_value;
d88 2
a89 3
      GLbitfield64 bitfield =
         BITFIELD64_BIT(var->data.location + var->data.index + offset + i);
      if (var->data.mode == ir_var_shader_in) {
d93 3
a95 4
            fprog->InterpQualifier[var->data.location +
                                   var->data.index + offset + i] =
               (glsl_interp_qualifier) var->data.interpolation;
            if (var->data.centroid)
a96 2
            if (var->data.sample)
               fprog->IsSample |= bitfield;
d98 1
a98 1
      } else if (var->data.mode == ir_var_system_value) {
d101 1
a101 1
         assert(var->data.mode == ir_var_shader_out);
a106 17
/**
 * Mark an entire variable as used.  Caller must ensure that the variable
 * represents a shader input or output.
 */
void
ir_set_program_inouts_visitor::mark_whole_variable(ir_variable *var)
{
   const glsl_type *type = var->type;
   if (this->shader_stage == MESA_SHADER_GEOMETRY &&
       var->data.mode == ir_var_shader_in && type->is_array()) {
      type = type->fields.array;
   }

   mark(this->prog, var, 0, type->count_attribute_slots(),
        this->shader_stage == MESA_SHADER_FRAGMENT);
}

d114 8
a121 1
   mark_whole_variable(ir->var);
d126 2
a127 15
/**
 * Try to mark a portion of the given variable as used.  Caller must ensure
 * that the variable represents a shader input or output which can be indexed
 * into in array fashion (an array or matrix).  For the purpose of geometry
 * shader inputs (which are always arrays*), this means that the array element
 * must be something that can be indexed into in array fashion.
 *
 * *Except gl_PrimitiveIDIn, as noted below.
 *
 * If the index can't be interpreted as a constant, or some other problem
 * occurs, then nothing will be marked and false will be returned.
 */
bool
ir_set_program_inouts_visitor::try_mark_partial_variable(ir_variable *var,
                                                         ir_rvalue *index)
d129 4
a132 1
   const glsl_type *type = var->type;
d134 3
a136 9
   if (this->shader_stage == MESA_SHADER_GEOMETRY &&
       var->data.mode == ir_var_shader_in) {
      /* The only geometry shader input that is not an array is
       * gl_PrimitiveIDIn, and in that case, this code will never be reached,
       * because gl_PrimitiveIDIn can't be indexed into in array fashion.
       */
      assert(type->is_array());
      type = type->fields.array;
   }
d138 2
a139 22
   /* The code below only handles:
    *
    * - Indexing into matrices
    * - Indexing into arrays of (matrices, vectors, or scalars)
    *
    * All other possibilities are either prohibited by GLSL (vertex inputs and
    * fragment outputs can't be structs) or should have been eliminated by
    * lowering passes (do_vec_index_to_swizzle() gets rid of indexing into
    * vectors, and lower_packed_varyings() gets rid of structs that occur in
    * varyings).
    */
   if (!(type->is_matrix() ||
        (type->is_array() &&
         (type->fields.array->is_numeric() ||
          type->fields.array->is_boolean())))) {
      assert(!"Unexpected indexing in ir_set_program_inouts");

      /* For safety in release builds, in case we ever encounter unexpected
       * indexing, give up and let the caller mark the whole variable as used.
       */
      return false;
   }
d141 4
a144 29
   ir_constant *index_as_constant = index->as_constant();
   if (!index_as_constant)
      return false;

   unsigned elem_width;
   unsigned num_elems;
   if (type->is_array()) {
      num_elems = type->length;
      if (type->fields.array->is_matrix())
         elem_width = type->fields.array->matrix_columns;
      else
         elem_width = 1;
   } else {
      num_elems = type->matrix_columns;
      elem_width = 1;
   }

   if (index_as_constant->value.u[0] >= num_elems) {
      /* Constant index outside the bounds of the matrix/array.  This could
       * arise as a result of constant folding of a legal GLSL program.
       *
       * Even though the spec says that indexing outside the bounds of a
       * matrix/array results in undefined behaviour, we don't want to pass
       * out-of-range values to mark() (since this could result in slots that
       * don't exist being marked as used), so just let the caller mark the
       * whole variable as used.
       */
      return false;
   }
d146 3
a148 57
   mark(this->prog, var, index_as_constant->value.u[0] * elem_width,
        elem_width, this->shader_stage == MESA_SHADER_FRAGMENT);
   return true;
}

ir_visitor_status
ir_set_program_inouts_visitor::visit_enter(ir_dereference_array *ir)
{
   /* Note: for geometry shader inputs, lower_named_interface_blocks may
    * create 2D arrays, so we need to be able to handle those.  2D arrays
    * shouldn't be able to crop up for any other reason.
    */
   if (ir_dereference_array * const inner_array =
       ir->array->as_dereference_array()) {
      /*          ir => foo[i][j]
       * inner_array => foo[i]
       */
      if (ir_dereference_variable * const deref_var =
          inner_array->array->as_dereference_variable()) {
         if (this->shader_stage == MESA_SHADER_GEOMETRY &&
             deref_var->var->data.mode == ir_var_shader_in) {
            /* foo is a geometry shader input, so i is the vertex, and j the
             * part of the input we're accessing.
             */
            if (try_mark_partial_variable(deref_var->var, ir->array_index))
            {
               /* We've now taken care of foo and j, but i might contain a
                * subexpression that accesses shader inputs.  So manually
                * visit i and then continue with the parent.
                */
               inner_array->array_index->accept(this);
               return visit_continue_with_parent;
            }
         }
      }
   } else if (ir_dereference_variable * const deref_var =
              ir->array->as_dereference_variable()) {
      /* ir => foo[i], where foo is a variable. */
      if (this->shader_stage == MESA_SHADER_GEOMETRY &&
          deref_var->var->data.mode == ir_var_shader_in) {
         /* foo is a geometry shader input, so i is the vertex, and we're
          * accessing the entire input.
          */
         mark_whole_variable(deref_var->var);
         /* We've now taken care of foo, but i might contain a subexpression
          * that accesses shader inputs.  So manually visit i and then
          * continue with the parent.
          */
         ir->array_index->accept(this);
         return visit_continue_with_parent;
      } else if (is_shader_inout(deref_var->var)) {
         /* foo is a shader input/output, but not a geometry shader input,
          * so i is the part of the input we're accessing.
          */
         if (try_mark_partial_variable(deref_var->var, ir->array_index))
            return visit_continue_with_parent;
      }
a150 3
   /* The expression is something we don't recognize.  Just visit its
    * subexpressions.
    */
d167 1
a167 2
   if (this->shader_stage == MESA_SHADER_FRAGMENT &&
       ir->operation == ir_unop_dFdy) {
d178 1
a178 1
   assert(this->shader_stage == MESA_SHADER_FRAGMENT);
a185 8
ir_visitor_status
ir_set_program_inouts_visitor::visit_enter(ir_texture *ir)
{
   if (ir->op == ir_tg4)
      prog->UsesGather = true;
   return visit_continue;
}

d188 1
a188 1
                      gl_shader_stage shader_stage)
d190 1
a190 1
   ir_set_program_inouts_visitor v(prog, shader_stage);
d195 1
a195 1
   if (shader_stage == MESA_SHADER_FRAGMENT) {
a198 1
      fprog->IsSample = 0;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d309 1
a309 3
       (ir->operation == ir_unop_dFdy ||
        ir->operation == ir_unop_dFdy_coarse ||
        ir->operation == ir_unop_dFdy_fine)) {
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d309 3
a311 1
       ir->operation == ir_unop_dFdy) {
@


