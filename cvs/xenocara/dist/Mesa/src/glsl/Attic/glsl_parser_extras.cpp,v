head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.25;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.13;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.27;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.18;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.25;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2008, 2009 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <assert.h>

extern "C" {
#include "main/core.h" /* for struct gl_context */
#include "main/context.h"
#include "main/shaderobj.h"
}

#include "ralloc.h"
#include "ast.h"
#include "glsl_parser_extras.h"
#include "glsl_parser.h"
#include "ir_optimization.h"
#include "loop_analysis.h"

/**
 * Format a short human-readable description of the given GLSL version.
 */
const char *
glsl_compute_version_string(void *mem_ctx, bool is_es, unsigned version)
{
   return ralloc_asprintf(mem_ctx, "GLSL%s %d.%02d", is_es ? " ES" : "",
                          version / 100, version % 100);
}


static const unsigned known_desktop_glsl_versions[] =
   { 110, 120, 130, 140, 150, 330, 400, 410, 420, 430, 440 };


_mesa_glsl_parse_state::_mesa_glsl_parse_state(struct gl_context *_ctx,
					       gl_shader_stage stage,
                                               void *mem_ctx)
   : ctx(_ctx), cs_input_local_size_specified(false), cs_input_local_size(),
     switch_state()
{
   assert(stage < MESA_SHADER_STAGES);
   this->stage = stage;

   this->scanner = NULL;
   this->translation_unit.make_empty();
   this->symbols = new(mem_ctx) glsl_symbol_table;

   this->info_log = ralloc_strdup(mem_ctx, "");
   this->error = false;
   this->loop_nesting_ast = NULL;

   this->struct_specifier_depth = 0;

   this->uses_builtin_functions = false;

   /* Set default language version and extensions */
   this->language_version = ctx->Const.ForceGLSLVersion ?
                            ctx->Const.ForceGLSLVersion : 110;
   this->es_shader = false;
   this->ARB_texture_rectangle_enable = true;

   /* OpenGL ES 2.0 has different defaults from desktop GL. */
   if (ctx->API == API_OPENGLES2) {
      this->language_version = 100;
      this->es_shader = true;
      this->ARB_texture_rectangle_enable = false;
   }

   this->extensions = &ctx->Extensions;

   this->Const.MaxLights = ctx->Const.MaxLights;
   this->Const.MaxClipPlanes = ctx->Const.MaxClipPlanes;
   this->Const.MaxTextureUnits = ctx->Const.MaxTextureUnits;
   this->Const.MaxTextureCoords = ctx->Const.MaxTextureCoordUnits;
   this->Const.MaxVertexAttribs = ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs;
   this->Const.MaxVertexUniformComponents = ctx->Const.Program[MESA_SHADER_VERTEX].MaxUniformComponents;
   this->Const.MaxVertexTextureImageUnits = ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits;
   this->Const.MaxCombinedTextureImageUnits = ctx->Const.MaxCombinedTextureImageUnits;
   this->Const.MaxTextureImageUnits = ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits;
   this->Const.MaxFragmentUniformComponents = ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxUniformComponents;
   this->Const.MinProgramTexelOffset = ctx->Const.MinProgramTexelOffset;
   this->Const.MaxProgramTexelOffset = ctx->Const.MaxProgramTexelOffset;

   this->Const.MaxDrawBuffers = ctx->Const.MaxDrawBuffers;

   /* 1.50 constants */
   this->Const.MaxVertexOutputComponents = ctx->Const.Program[MESA_SHADER_VERTEX].MaxOutputComponents;
   this->Const.MaxGeometryInputComponents = ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxInputComponents;
   this->Const.MaxGeometryOutputComponents = ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxOutputComponents;
   this->Const.MaxFragmentInputComponents = ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxInputComponents;
   this->Const.MaxGeometryTextureImageUnits = ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits;
   this->Const.MaxGeometryOutputVertices = ctx->Const.MaxGeometryOutputVertices;
   this->Const.MaxGeometryTotalOutputComponents = ctx->Const.MaxGeometryTotalOutputComponents;
   this->Const.MaxGeometryUniformComponents = ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxUniformComponents;

   this->Const.MaxVertexAtomicCounters = ctx->Const.Program[MESA_SHADER_VERTEX].MaxAtomicCounters;
   this->Const.MaxGeometryAtomicCounters = ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxAtomicCounters;
   this->Const.MaxFragmentAtomicCounters = ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxAtomicCounters;
   this->Const.MaxCombinedAtomicCounters = ctx->Const.MaxCombinedAtomicCounters;
   this->Const.MaxAtomicBufferBindings = ctx->Const.MaxAtomicBufferBindings;

   /* Compute shader constants */
   for (unsigned i = 0; i < Elements(this->Const.MaxComputeWorkGroupCount); i++)
      this->Const.MaxComputeWorkGroupCount[i] = ctx->Const.MaxComputeWorkGroupCount[i];
   for (unsigned i = 0; i < Elements(this->Const.MaxComputeWorkGroupSize); i++)
      this->Const.MaxComputeWorkGroupSize[i] = ctx->Const.MaxComputeWorkGroupSize[i];

   this->Const.MaxImageUnits = ctx->Const.MaxImageUnits;
   this->Const.MaxCombinedImageUnitsAndFragmentOutputs = ctx->Const.MaxCombinedImageUnitsAndFragmentOutputs;
   this->Const.MaxImageSamples = ctx->Const.MaxImageSamples;
   this->Const.MaxVertexImageUniforms = ctx->Const.Program[MESA_SHADER_VERTEX].MaxImageUniforms;
   this->Const.MaxGeometryImageUniforms = ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxImageUniforms;
   this->Const.MaxFragmentImageUniforms = ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxImageUniforms;
   this->Const.MaxCombinedImageUniforms = ctx->Const.MaxCombinedImageUniforms;

   this->current_function = NULL;
   this->toplevel_ir = NULL;
   this->found_return = false;
   this->all_invariant = false;
   this->user_structures = NULL;
   this->num_user_structures = 0;

   /* Populate the list of supported GLSL versions */
   /* FINISHME: Once the OpenGL 3.0 'forward compatible' context or
    * the OpenGL 3.2 Core context is supported, this logic will need
    * change.  Older versions of GLSL are no longer supported
    * outside the compatibility contexts of 3.x.
    */
   this->num_supported_versions = 0;
   if (_mesa_is_desktop_gl(ctx)) {
      for (unsigned i = 0; i < ARRAY_SIZE(known_desktop_glsl_versions); i++) {
         if (known_desktop_glsl_versions[i] <= ctx->Const.GLSLVersion) {
            this->supported_versions[this->num_supported_versions].ver
               = known_desktop_glsl_versions[i];
            this->supported_versions[this->num_supported_versions].es = false;
            this->num_supported_versions++;
         }
      }
   }
   if (ctx->API == API_OPENGLES2 || ctx->Extensions.ARB_ES2_compatibility) {
      this->supported_versions[this->num_supported_versions].ver = 100;
      this->supported_versions[this->num_supported_versions].es = true;
      this->num_supported_versions++;
   }
   if (_mesa_is_gles3(ctx) || ctx->Extensions.ARB_ES3_compatibility) {
      this->supported_versions[this->num_supported_versions].ver = 300;
      this->supported_versions[this->num_supported_versions].es = true;
      this->num_supported_versions++;
   }
   assert(this->num_supported_versions
          <= ARRAY_SIZE(this->supported_versions));

   /* Create a string for use in error messages to tell the user which GLSL
    * versions are supported.
    */
   char *supported = ralloc_strdup(this, "");
   for (unsigned i = 0; i < this->num_supported_versions; i++) {
      unsigned ver = this->supported_versions[i].ver;
      const char *const prefix = (i == 0)
	 ? ""
	 : ((i == this->num_supported_versions - 1) ? ", and " : ", ");
      const char *const suffix = (this->supported_versions[i].es) ? " ES" : "";

      ralloc_asprintf_append(& supported, "%s%u.%02u%s",
			     prefix,
			     ver / 100, ver % 100,
			     suffix);
   }

   this->supported_version_string = supported;

   if (ctx->Const.ForceGLSLExtensionsWarn)
      _mesa_glsl_process_extension("all", NULL, "warn", NULL, this);

   this->default_uniform_qualifier = new(this) ast_type_qualifier();
   this->default_uniform_qualifier->flags.q.shared = 1;
   this->default_uniform_qualifier->flags.q.column_major = 1;

   this->fs_uses_gl_fragcoord = false;
   this->fs_redeclares_gl_fragcoord = false;
   this->fs_origin_upper_left = false;
   this->fs_pixel_center_integer = false;
   this->fs_redeclares_gl_fragcoord_with_no_layout_qualifiers = false;

   this->gs_input_prim_type_specified = false;
   this->gs_input_size = 0;
   this->in_qualifier = new(this) ast_type_qualifier();
   this->out_qualifier = new(this) ast_type_qualifier();
   this->early_fragment_tests = false;
   memset(this->atomic_counter_offsets, 0,
          sizeof(this->atomic_counter_offsets));
}

/**
 * Determine whether the current GLSL version is sufficiently high to support
 * a certain feature, and generate an error message if it isn't.
 *
 * \param required_glsl_version and \c required_glsl_es_version are
 * interpreted as they are in _mesa_glsl_parse_state::is_version().
 *
 * \param locp is the parser location where the error should be reported.
 *
 * \param fmt (and additional arguments) constitute a printf-style error
 * message to report if the version check fails.  Information about the
 * current and required GLSL versions will be appended.  So, for example, if
 * the GLSL version being compiled is 1.20, and check_version(130, 300, locp,
 * "foo unsupported") is called, the error message will be "foo unsupported in
 * GLSL 1.20 (GLSL 1.30 or GLSL 3.00 ES required)".
 */
bool
_mesa_glsl_parse_state::check_version(unsigned required_glsl_version,
                                      unsigned required_glsl_es_version,
                                      YYLTYPE *locp, const char *fmt, ...)
{
   if (this->is_version(required_glsl_version, required_glsl_es_version))
      return true;

   va_list args;
   va_start(args, fmt);
   char *problem = ralloc_vasprintf(this, fmt, args);
   va_end(args);
   const char *glsl_version_string
      = glsl_compute_version_string(this, false, required_glsl_version);
   const char *glsl_es_version_string
      = glsl_compute_version_string(this, true, required_glsl_es_version);
   const char *requirement_string = "";
   if (required_glsl_version && required_glsl_es_version) {
      requirement_string = ralloc_asprintf(this, " (%s or %s required)",
                                           glsl_version_string,
                                           glsl_es_version_string);
   } else if (required_glsl_version) {
      requirement_string = ralloc_asprintf(this, " (%s required)",
                                           glsl_version_string);
   } else if (required_glsl_es_version) {
      requirement_string = ralloc_asprintf(this, " (%s required)",
                                           glsl_es_version_string);
   }
   _mesa_glsl_error(locp, this, "%s in %s%s",
                    problem, this->get_version_string(),
                    requirement_string);

   return false;
}

/**
 * Process a GLSL #version directive.
 *
 * \param version is the integer that follows the #version token.
 *
 * \param ident is a string identifier that follows the integer, if any is
 * present.  Otherwise NULL.
 */
void
_mesa_glsl_parse_state::process_version_directive(YYLTYPE *locp, int version,
                                                  const char *ident)
{
   bool es_token_present = false;
   if (ident) {
      if (strcmp(ident, "es") == 0) {
         es_token_present = true;
      } else if (version >= 150) {
         if (strcmp(ident, "core") == 0) {
            /* Accept the token.  There's no need to record that this is
             * a core profile shader since that's the only profile we support.
             */
         } else if (strcmp(ident, "compatibility") == 0) {
            _mesa_glsl_error(locp, this,
                             "the compatibility profile is not supported");
         } else {
            _mesa_glsl_error(locp, this,
                             "\"%s\" is not a valid shading language profile; "
                             "if present, it must be \"core\"", ident);
         }
      } else {
         _mesa_glsl_error(locp, this,
                          "illegal text following version number");
      }
   }

   this->es_shader = es_token_present;
   if (version == 100) {
      if (es_token_present) {
         _mesa_glsl_error(locp, this,
                          "GLSL 1.00 ES should be selected using "
                          "`#version 100'");
      } else {
         this->es_shader = true;
      }
   }

   if (this->es_shader) {
      this->ARB_texture_rectangle_enable = false;
   }

   this->language_version = version;

   bool supported = false;
   for (unsigned i = 0; i < this->num_supported_versions; i++) {
      if (this->supported_versions[i].ver == (unsigned) version
          && this->supported_versions[i].es == this->es_shader) {
         supported = true;
         break;
      }
   }

   if (!supported) {
      _mesa_glsl_error(locp, this, "%s is not supported. "
                       "Supported versions are: %s",
                       this->get_version_string(),
                       this->supported_version_string);

      /* On exit, the language_version must be set to a valid value.
       * Later calls to _mesa_glsl_initialize_types will misbehave if
       * the version is invalid.
       */
      switch (this->ctx->API) {
      case API_OPENGL_COMPAT:
      case API_OPENGL_CORE:
	 this->language_version = this->ctx->Const.GLSLVersion;
	 break;

      case API_OPENGLES:
	 assert(!"Should not get here.");
	 /* FALLTHROUGH */

      case API_OPENGLES2:
	 this->language_version = 100;
	 break;
      }
   }
}


/**
 * Translate a gl_shader_stage to a short shader stage name for debug
 * printouts and error messages.
 */
const char *
_mesa_shader_stage_to_string(unsigned stage)
{
   switch (stage) {
   case MESA_SHADER_VERTEX:   return "vertex";
   case MESA_SHADER_FRAGMENT: return "fragment";
   case MESA_SHADER_GEOMETRY: return "geometry";
   }

   assert(!"Should not get here.");
   return "unknown";
}

/* This helper function will append the given message to the shader's
   info log and report it via GL_ARB_debug_output. Per that extension,
   'type' is one of the enum values classifying the message, and
   'id' is the implementation-defined ID of the given message. */
static void
_mesa_glsl_msg(const YYLTYPE *locp, _mesa_glsl_parse_state *state,
               GLenum type, const char *fmt, va_list ap)
{
   bool error = (type == MESA_DEBUG_TYPE_ERROR);
   GLuint msg_id = 0;

   assert(state->info_log != NULL);

   /* Get the offset that the new message will be written to. */
   int msg_offset = strlen(state->info_log);

   ralloc_asprintf_append(&state->info_log, "%u:%u(%u): %s: ",
					    locp->source,
					    locp->first_line,
					    locp->first_column,
					    error ? "error" : "warning");
   ralloc_vasprintf_append(&state->info_log, fmt, ap);

   const char *const msg = &state->info_log[msg_offset];
   struct gl_context *ctx = state->ctx;

   /* Report the error via GL_ARB_debug_output. */
   _mesa_shader_debug(ctx, type, &msg_id, msg, strlen(msg));

   ralloc_strcat(&state->info_log, "\n");
}

void
_mesa_glsl_error(YYLTYPE *locp, _mesa_glsl_parse_state *state,
		 const char *fmt, ...)
{
   va_list ap;

   state->error = true;

   va_start(ap, fmt);
   _mesa_glsl_msg(locp, state, MESA_DEBUG_TYPE_ERROR, fmt, ap);
   va_end(ap);
}


void
_mesa_glsl_warning(const YYLTYPE *locp, _mesa_glsl_parse_state *state,
		   const char *fmt, ...)
{
   va_list ap;

   va_start(ap, fmt);
   _mesa_glsl_msg(locp, state, MESA_DEBUG_TYPE_OTHER, fmt, ap);
   va_end(ap);
}


/**
 * Enum representing the possible behaviors that can be specified in
 * an #extension directive.
 */
enum ext_behavior {
   extension_disable,
   extension_enable,
   extension_require,
   extension_warn
};

/**
 * Element type for _mesa_glsl_supported_extensions
 */
struct _mesa_glsl_extension {
   /**
    * Name of the extension when referred to in a GLSL extension
    * statement
    */
   const char *name;

   /** True if this extension is available to desktop GL shaders */
   bool avail_in_GL;

   /** True if this extension is available to GLES shaders */
   bool avail_in_ES;

   /**
    * Flag in the gl_extensions struct indicating whether this
    * extension is supported by the driver, or
    * &gl_extensions::dummy_true if supported by all drivers.
    *
    * Note: the type (GLboolean gl_extensions::*) is a "pointer to
    * member" type, the type-safe alternative to the "offsetof" macro.
    * In a nutshell:
    *
    * - foo bar::* p declares p to be an "offset" to a field of type
    *   foo that exists within struct bar
    * - &bar::baz computes the "offset" of field baz within struct bar
    * - x.*p accesses the field of x that exists at "offset" p
    * - x->*p is equivalent to (*x).*p
    */
   const GLboolean gl_extensions::* supported_flag;

   /**
    * Flag in the _mesa_glsl_parse_state struct that should be set
    * when this extension is enabled.
    *
    * See note in _mesa_glsl_extension::supported_flag about "pointer
    * to member" types.
    */
   bool _mesa_glsl_parse_state::* enable_flag;

   /**
    * Flag in the _mesa_glsl_parse_state struct that should be set
    * when the shader requests "warn" behavior for this extension.
    *
    * See note in _mesa_glsl_extension::supported_flag about "pointer
    * to member" types.
    */
   bool _mesa_glsl_parse_state::* warn_flag;


   bool compatible_with_state(const _mesa_glsl_parse_state *state) const;
   void set_flags(_mesa_glsl_parse_state *state, ext_behavior behavior) const;
};

#define EXT(NAME, GL, ES, SUPPORTED_FLAG)                   \
   { "GL_" #NAME, GL, ES, &gl_extensions::SUPPORTED_FLAG,   \
         &_mesa_glsl_parse_state::NAME##_enable,            \
         &_mesa_glsl_parse_state::NAME##_warn }

/**
 * Table of extensions that can be enabled/disabled within a shader,
 * and the conditions under which they are supported.
 */
static const _mesa_glsl_extension _mesa_glsl_supported_extensions[] = {
   /*                                  API availability */
   /* name                             GL     ES         supported flag */

   /* ARB extensions go here, sorted alphabetically.
    */
   EXT(ARB_arrays_of_arrays,           true,  false,     ARB_arrays_of_arrays),
   EXT(ARB_compute_shader,             true,  false,     ARB_compute_shader),
   EXT(ARB_conservative_depth,         true,  false,     ARB_conservative_depth),
   EXT(ARB_draw_buffers,               true,  false,     dummy_true),
   EXT(ARB_draw_instanced,             true,  false,     ARB_draw_instanced),
   EXT(ARB_explicit_attrib_location,   true,  false,     ARB_explicit_attrib_location),
   EXT(ARB_fragment_coord_conventions, true,  false,     ARB_fragment_coord_conventions),
   EXT(ARB_gpu_shader5,                true,  false,     ARB_gpu_shader5),
   EXT(ARB_sample_shading,             true,  false,     ARB_sample_shading),
   EXT(ARB_separate_shader_objects,    true,  false,     dummy_true),
   EXT(ARB_shader_atomic_counters,     true,  false,     ARB_shader_atomic_counters),
   EXT(ARB_shader_bit_encoding,        true,  false,     ARB_shader_bit_encoding),
   EXT(ARB_shader_image_load_store,    true,  false,     ARB_shader_image_load_store),
   EXT(ARB_shader_stencil_export,      true,  false,     ARB_shader_stencil_export),
   EXT(ARB_shader_texture_lod,         true,  false,     ARB_shader_texture_lod),
   EXT(ARB_shading_language_420pack,   true,  false,     ARB_shading_language_420pack),
   EXT(ARB_shading_language_packing,   true,  false,     ARB_shading_language_packing),
   EXT(ARB_texture_cube_map_array,     true,  false,     ARB_texture_cube_map_array),
   EXT(ARB_texture_gather,             true,  false,     ARB_texture_gather),
   EXT(ARB_texture_multisample,        true,  false,     ARB_texture_multisample),
   EXT(ARB_texture_query_levels,       true,  false,     ARB_texture_query_levels),
   EXT(ARB_texture_query_lod,          true,  false,     ARB_texture_query_lod),
   EXT(ARB_texture_rectangle,          true,  false,     dummy_true),
   EXT(ARB_uniform_buffer_object,      true,  false,     ARB_uniform_buffer_object),
   EXT(ARB_viewport_array,             true,  false,     ARB_viewport_array),

   /* KHR extensions go here, sorted alphabetically.
    */

   /* OES extensions go here, sorted alphabetically.
    */
   EXT(OES_EGL_image_external,         false, true,      OES_EGL_image_external),
   EXT(OES_standard_derivatives,       false, true,      OES_standard_derivatives),
   EXT(OES_texture_3D,                 false, true,      EXT_texture3D),

   /* All other extensions go here, sorted alphabetically.
    */
   EXT(AMD_conservative_depth,         true,  false,     ARB_conservative_depth),
   EXT(AMD_shader_stencil_export,      true,  false,     ARB_shader_stencil_export),
   EXT(AMD_shader_trinary_minmax,      true,  false,     dummy_true),
   EXT(AMD_vertex_shader_layer,        true,  false,     AMD_vertex_shader_layer),
   EXT(EXT_separate_shader_objects,    false, true,      dummy_true),
   EXT(EXT_shader_integer_mix,         true,  true,      EXT_shader_integer_mix),
   EXT(EXT_texture_array,              true,  false,     EXT_texture_array),
};

#undef EXT


/**
 * Determine whether a given extension is compatible with the target,
 * API, and extension information in the current parser state.
 */
bool _mesa_glsl_extension::compatible_with_state(const _mesa_glsl_parse_state *
                                                 state) const
{
   /* Check that this extension matches whether we are compiling
    * for desktop GL or GLES.
    */
   if (state->es_shader) {
      if (!this->avail_in_ES) return false;
   } else {
      if (!this->avail_in_GL) return false;
   }

   /* Check that this extension is supported by the OpenGL
    * implementation.
    *
    * Note: the ->* operator indexes into state->extensions by the
    * offset this->supported_flag.  See
    * _mesa_glsl_extension::supported_flag for more info.
    */
   return state->extensions->*(this->supported_flag);
}

/**
 * Set the appropriate flags in the parser state to establish the
 * given behavior for this extension.
 */
void _mesa_glsl_extension::set_flags(_mesa_glsl_parse_state *state,
                                     ext_behavior behavior) const
{
   /* Note: the ->* operator indexes into state by the
    * offsets this->enable_flag and this->warn_flag.  See
    * _mesa_glsl_extension::supported_flag for more info.
    */
   state->*(this->enable_flag) = (behavior != extension_disable);
   state->*(this->warn_flag)   = (behavior == extension_warn);
}

/**
 * Find an extension by name in _mesa_glsl_supported_extensions.  If
 * the name is not found, return NULL.
 */
static const _mesa_glsl_extension *find_extension(const char *name)
{
   for (unsigned i = 0; i < Elements(_mesa_glsl_supported_extensions); ++i) {
      if (strcmp(name, _mesa_glsl_supported_extensions[i].name) == 0) {
         return &_mesa_glsl_supported_extensions[i];
      }
   }
   return NULL;
}


bool
_mesa_glsl_process_extension(const char *name, YYLTYPE *name_locp,
			     const char *behavior_string, YYLTYPE *behavior_locp,
			     _mesa_glsl_parse_state *state)
{
   ext_behavior behavior;
   if (strcmp(behavior_string, "warn") == 0) {
      behavior = extension_warn;
   } else if (strcmp(behavior_string, "require") == 0) {
      behavior = extension_require;
   } else if (strcmp(behavior_string, "enable") == 0) {
      behavior = extension_enable;
   } else if (strcmp(behavior_string, "disable") == 0) {
      behavior = extension_disable;
   } else {
      _mesa_glsl_error(behavior_locp, state,
		       "unknown extension behavior `%s'",
		       behavior_string);
      return false;
   }

   if (strcmp(name, "all") == 0) {
      if ((behavior == extension_enable) || (behavior == extension_require)) {
	 _mesa_glsl_error(name_locp, state, "cannot %s all extensions",
			  (behavior == extension_enable)
			  ? "enable" : "require");
	 return false;
      } else {
         for (unsigned i = 0;
              i < Elements(_mesa_glsl_supported_extensions); ++i) {
            const _mesa_glsl_extension *extension
               = &_mesa_glsl_supported_extensions[i];
            if (extension->compatible_with_state(state)) {
               _mesa_glsl_supported_extensions[i].set_flags(state, behavior);
            }
         }
      }
   } else {
      const _mesa_glsl_extension *extension = find_extension(name);
      if (extension && extension->compatible_with_state(state)) {
         extension->set_flags(state, behavior);
      } else {
         static const char fmt[] = "extension `%s' unsupported in %s shader";

         if (behavior == extension_require) {
            _mesa_glsl_error(name_locp, state, fmt,
                             name, _mesa_shader_stage_to_string(state->stage));
            return false;
         } else {
            _mesa_glsl_warning(name_locp, state, fmt,
                               name, _mesa_shader_stage_to_string(state->stage));
         }
      }
   }

   return true;
}


/**
 * Recurses through <type> and <expr> if <expr> is an aggregate initializer
 * and sets <expr>'s <constructor_type> field to <type>. Gives later functions
 * (process_array_constructor, et al) sufficient information to do type
 * checking.
 *
 * Operates on assignments involving an aggregate initializer. E.g.,
 *
 * vec4 pos = {1.0, -1.0, 0.0, 1.0};
 *
 * or more ridiculously,
 *
 * struct S {
 *     vec4 v[2];
 * };
 *
 * struct {
 *     S a[2], b;
 *     int c;
 * } aggregate = {
 *     {
 *         {
 *             {
 *                 {1.0, 2.0, 3.0, 4.0}, // a[0].v[0]
 *                 {5.0, 6.0, 7.0, 8.0}  // a[0].v[1]
 *             } // a[0].v
 *         }, // a[0]
 *         {
 *             {
 *                 {1.0, 2.0, 3.0, 4.0}, // a[1].v[0]
 *                 {5.0, 6.0, 7.0, 8.0}  // a[1].v[1]
 *             } // a[1].v
 *         } // a[1]
 *     }, // a
 *     {
 *         {
 *             {1.0, 2.0, 3.0, 4.0}, // b.v[0]
 *             {5.0, 6.0, 7.0, 8.0}  // b.v[1]
 *         } // b.v
 *     }, // b
 *     4 // c
 * };
 *
 * This pass is necessary because the right-hand side of <type> e = { ... }
 * doesn't contain sufficient information to determine if the types match.
 */
void
_mesa_ast_set_aggregate_type(const glsl_type *type,
                             ast_expression *expr)
{
   ast_aggregate_initializer *ai = (ast_aggregate_initializer *)expr;
   ai->constructor_type = type;

   /* If the aggregate is an array, recursively set its elements' types. */
   if (type->is_array()) {
      /* Each array element has the type type->element_type().
       *
       * E.g., if <type> if struct S[2] we want to set each element's type to
       * struct S.
       */
      for (exec_node *expr_node = ai->expressions.head;
           !expr_node->is_tail_sentinel();
           expr_node = expr_node->next) {
         ast_expression *expr = exec_node_data(ast_expression, expr_node,
                                               link);

         if (expr->oper == ast_aggregate)
            _mesa_ast_set_aggregate_type(type->element_type(), expr);
      }

   /* If the aggregate is a struct, recursively set its fields' types. */
   } else if (type->is_record()) {
      exec_node *expr_node = ai->expressions.head;

      /* Iterate through the struct's fields. */
      for (unsigned i = 0; !expr_node->is_tail_sentinel() && i < type->length;
           i++, expr_node = expr_node->next) {
         ast_expression *expr = exec_node_data(ast_expression, expr_node,
                                               link);

         if (expr->oper == ast_aggregate) {
            _mesa_ast_set_aggregate_type(type->fields.structure[i].type, expr);
         }
      }
   /* If the aggregate is a matrix, set its columns' types. */
   } else if (type->is_matrix()) {
      for (exec_node *expr_node = ai->expressions.head;
           !expr_node->is_tail_sentinel();
           expr_node = expr_node->next) {
         ast_expression *expr = exec_node_data(ast_expression, expr_node,
                                               link);

         if (expr->oper == ast_aggregate)
            _mesa_ast_set_aggregate_type(type->column_type(), expr);
      }
   }
}


void
_mesa_ast_type_qualifier_print(const struct ast_type_qualifier *q)
{
   if (q->flags.q.constant)
      printf("const ");

   if (q->flags.q.invariant)
      printf("invariant ");

   if (q->flags.q.attribute)
      printf("attribute ");

   if (q->flags.q.varying)
      printf("varying ");

   if (q->flags.q.in && q->flags.q.out)
      printf("inout ");
   else {
      if (q->flags.q.in)
	 printf("in ");

      if (q->flags.q.out)
	 printf("out ");
   }

   if (q->flags.q.centroid)
      printf("centroid ");
   if (q->flags.q.sample)
      printf("sample ");
   if (q->flags.q.uniform)
      printf("uniform ");
   if (q->flags.q.smooth)
      printf("smooth ");
   if (q->flags.q.flat)
      printf("flat ");
   if (q->flags.q.noperspective)
      printf("noperspective ");
}


void
ast_node::print(void) const
{
   printf("unhandled node ");
}


ast_node::ast_node(void)
{
   this->location.source = 0;
   this->location.first_line = 0;
   this->location.first_column = 0;
   this->location.last_line = 0;
   this->location.last_column = 0;
}


static void
ast_opt_array_dimensions_print(const ast_array_specifier *array_specifier)
{
   if (array_specifier)
      array_specifier->print();
}


void
ast_compound_statement::print(void) const
{
   printf("{\n");
   
   foreach_list_const(n, &this->statements) {
      ast_node *ast = exec_node_data(ast_node, n, link);
      ast->print();
   }

   printf("}\n");
}


ast_compound_statement::ast_compound_statement(int new_scope,
					       ast_node *statements)
{
   this->new_scope = new_scope;

   if (statements != NULL) {
      this->statements.push_degenerate_list_at_head(&statements->link);
   }
}


void
ast_expression::print(void) const
{
   switch (oper) {
   case ast_assign:
   case ast_mul_assign:
   case ast_div_assign:
   case ast_mod_assign:
   case ast_add_assign:
   case ast_sub_assign:
   case ast_ls_assign:
   case ast_rs_assign:
   case ast_and_assign:
   case ast_xor_assign:
   case ast_or_assign:
      subexpressions[0]->print();
      printf("%s ", operator_string(oper));
      subexpressions[1]->print();
      break;

   case ast_field_selection:
      subexpressions[0]->print();
      printf(". %s ", primary_expression.identifier);
      break;

   case ast_plus:
   case ast_neg:
   case ast_bit_not:
   case ast_logic_not:
   case ast_pre_inc:
   case ast_pre_dec:
      printf("%s ", operator_string(oper));
      subexpressions[0]->print();
      break;

   case ast_post_inc:
   case ast_post_dec:
      subexpressions[0]->print();
      printf("%s ", operator_string(oper));
      break;

   case ast_conditional:
      subexpressions[0]->print();
      printf("? ");
      subexpressions[1]->print();
      printf(": ");
      subexpressions[2]->print();
      break;

   case ast_array_index:
      subexpressions[0]->print();
      printf("[ ");
      subexpressions[1]->print();
      printf("] ");
      break;

   case ast_function_call: {
      subexpressions[0]->print();
      printf("( ");

      foreach_list_const (n, &this->expressions) {
	 if (n != this->expressions.get_head())
	    printf(", ");

	 ast_node *ast = exec_node_data(ast_node, n, link);
	 ast->print();
      }

      printf(") ");
      break;
   }

   case ast_identifier:
      printf("%s ", primary_expression.identifier);
      break;

   case ast_int_constant:
      printf("%d ", primary_expression.int_constant);
      break;

   case ast_uint_constant:
      printf("%u ", primary_expression.uint_constant);
      break;

   case ast_float_constant:
      printf("%f ", primary_expression.float_constant);
      break;

   case ast_bool_constant:
      printf("%s ",
	     primary_expression.bool_constant
	     ? "true" : "false");
      break;

   case ast_sequence: {
      printf("( ");
      foreach_list_const(n, & this->expressions) {
	 if (n != this->expressions.get_head())
	    printf(", ");

	 ast_node *ast = exec_node_data(ast_node, n, link);
	 ast->print();
      }
      printf(") ");
      break;
   }

   case ast_aggregate: {
      printf("{ ");
      foreach_list_const(n, & this->expressions) {
	 if (n != this->expressions.get_head())
	    printf(", ");

	 ast_node *ast = exec_node_data(ast_node, n, link);
	 ast->print();
      }
      printf("} ");
      break;
   }

   default:
      assert(0);
      break;
   }
}

ast_expression::ast_expression(int oper,
			       ast_expression *ex0,
			       ast_expression *ex1,
			       ast_expression *ex2) :
   primary_expression()
{
   this->oper = ast_operators(oper);
   this->subexpressions[0] = ex0;
   this->subexpressions[1] = ex1;
   this->subexpressions[2] = ex2;
   this->non_lvalue_description = NULL;
}


void
ast_expression_statement::print(void) const
{
   if (expression)
      expression->print();

   printf("; ");
}


ast_expression_statement::ast_expression_statement(ast_expression *ex) :
   expression(ex)
{
   /* empty */
}


void
ast_function::print(void) const
{
   return_type->print();
   printf(" %s (", identifier);

   foreach_list_const(n, & this->parameters) {
      ast_node *ast = exec_node_data(ast_node, n, link);
      ast->print();
   }

   printf(")");
}


ast_function::ast_function(void)
   : return_type(NULL), identifier(NULL), is_definition(false),
     signature(NULL)
{
   /* empty */
}


void
ast_fully_specified_type::print(void) const
{
   _mesa_ast_type_qualifier_print(& qualifier);
   specifier->print();
}


void
ast_parameter_declarator::print(void) const
{
   type->print();
   if (identifier)
      printf("%s ", identifier);
   ast_opt_array_dimensions_print(array_specifier);
}


void
ast_function_definition::print(void) const
{
   prototype->print();
   body->print();
}


void
ast_declaration::print(void) const
{
   printf("%s ", identifier);
   ast_opt_array_dimensions_print(array_specifier);

   if (initializer) {
      printf("= ");
      initializer->print();
   }
}


ast_declaration::ast_declaration(const char *identifier,
				 ast_array_specifier *array_specifier,
				 ast_expression *initializer)
{
   this->identifier = identifier;
   this->array_specifier = array_specifier;
   this->initializer = initializer;
}


void
ast_declarator_list::print(void) const
{
   assert(type || invariant);

   if (type)
      type->print();
   else
      printf("invariant ");

   foreach_list_const (ptr, & this->declarations) {
      if (ptr != this->declarations.get_head())
	 printf(", ");

      ast_node *ast = exec_node_data(ast_node, ptr, link);
      ast->print();
   }

   printf("; ");
}


ast_declarator_list::ast_declarator_list(ast_fully_specified_type *type)
{
   this->type = type;
   this->invariant = false;
}

void
ast_jump_statement::print(void) const
{
   switch (mode) {
   case ast_continue:
      printf("continue; ");
      break;
   case ast_break:
      printf("break; ");
      break;
   case ast_return:
      printf("return ");
      if (opt_return_value)
	 opt_return_value->print();

      printf("; ");
      break;
   case ast_discard:
      printf("discard; ");
      break;
   }
}


ast_jump_statement::ast_jump_statement(int mode, ast_expression *return_value)
   : opt_return_value(NULL)
{
   this->mode = ast_jump_modes(mode);

   if (mode == ast_return)
      opt_return_value = return_value;
}


void
ast_selection_statement::print(void) const
{
   printf("if ( ");
   condition->print();
   printf(") ");

   then_statement->print();

   if (else_statement) {
      printf("else ");
      else_statement->print();
   }
   
}


ast_selection_statement::ast_selection_statement(ast_expression *condition,
						 ast_node *then_statement,
						 ast_node *else_statement)
{
   this->condition = condition;
   this->then_statement = then_statement;
   this->else_statement = else_statement;
}


void
ast_switch_statement::print(void) const
{
   printf("switch ( ");
   test_expression->print();
   printf(") ");

   body->print();
}


ast_switch_statement::ast_switch_statement(ast_expression *test_expression,
					   ast_node *body)
{
   this->test_expression = test_expression;
   this->body = body;
}


void
ast_switch_body::print(void) const
{
   printf("{\n");
   if (stmts != NULL) {
      stmts->print();
   }
   printf("}\n");
}


ast_switch_body::ast_switch_body(ast_case_statement_list *stmts)
{
   this->stmts = stmts;
}


void ast_case_label::print(void) const
{
   if (test_value != NULL) {
      printf("case ");
      test_value->print();
      printf(": ");
   } else {
      printf("default: ");
   }
}


ast_case_label::ast_case_label(ast_expression *test_value)
{
   this->test_value = test_value;
}


void ast_case_label_list::print(void) const
{
   foreach_list_const(n, & this->labels) {
      ast_node *ast = exec_node_data(ast_node, n, link);
      ast->print();
   }
   printf("\n");
}


ast_case_label_list::ast_case_label_list(void)
{
}


void ast_case_statement::print(void) const
{
   labels->print();
   foreach_list_const(n, & this->stmts) {
      ast_node *ast = exec_node_data(ast_node, n, link);
      ast->print();
      printf("\n");
   }
}


ast_case_statement::ast_case_statement(ast_case_label_list *labels)
{
   this->labels = labels;
}


void ast_case_statement_list::print(void) const
{
   foreach_list_const(n, & this->cases) {
      ast_node *ast = exec_node_data(ast_node, n, link);
      ast->print();
   }
}


ast_case_statement_list::ast_case_statement_list(void)
{
}


void
ast_iteration_statement::print(void) const
{
   switch (mode) {
   case ast_for:
      printf("for( ");
      if (init_statement)
	 init_statement->print();
      printf("; ");

      if (condition)
	 condition->print();
      printf("; ");

      if (rest_expression)
	 rest_expression->print();
      printf(") ");

      body->print();
      break;

   case ast_while:
      printf("while ( ");
      if (condition)
	 condition->print();
      printf(") ");
      body->print();
      break;

   case ast_do_while:
      printf("do ");
      body->print();
      printf("while ( ");
      if (condition)
	 condition->print();
      printf("); ");
      break;
   }
}


ast_iteration_statement::ast_iteration_statement(int mode,
						 ast_node *init,
						 ast_node *condition,
						 ast_expression *rest_expression,
						 ast_node *body)
{
   this->mode = ast_iteration_modes(mode);
   this->init_statement = init;
   this->condition = condition;
   this->rest_expression = rest_expression;
   this->body = body;
}


void
ast_struct_specifier::print(void) const
{
   printf("struct %s { ", name);
   foreach_list_const(n, &this->declarations) {
      ast_node *ast = exec_node_data(ast_node, n, link);
      ast->print();
   }
   printf("} ");
}


ast_struct_specifier::ast_struct_specifier(const char *identifier,
					   ast_declarator_list *declarator_list)
{
   if (identifier == NULL) {
      static unsigned anon_count = 1;
      identifier = ralloc_asprintf(this, "#anon_struct_%04x", anon_count);
      anon_count++;
   }
   name = identifier;
   this->declarations.push_degenerate_list_at_head(&declarator_list->link);
   is_declaration = true;
}

static void
set_shader_inout_layout(struct gl_shader *shader,
		     struct _mesa_glsl_parse_state *state)
{
   if (shader->Stage != MESA_SHADER_GEOMETRY) {
      /* Should have been prevented by the parser. */
      assert(!state->in_qualifier->flags.i);
      assert(!state->out_qualifier->flags.i);
   }

   if (shader->Stage != MESA_SHADER_COMPUTE) {
      /* Should have been prevented by the parser. */
      assert(!state->cs_input_local_size_specified);
   }

   if (shader->Stage != MESA_SHADER_FRAGMENT) {
      /* Should have been prevented by the parser. */
      assert(!state->fs_uses_gl_fragcoord);
      assert(!state->fs_redeclares_gl_fragcoord);
      assert(!state->fs_pixel_center_integer);
      assert(!state->fs_origin_upper_left);
   }

   switch (shader->Stage) {
   case MESA_SHADER_GEOMETRY:
      shader->Geom.VerticesOut = 0;
      if (state->out_qualifier->flags.q.max_vertices)
         shader->Geom.VerticesOut = state->out_qualifier->max_vertices;

      if (state->gs_input_prim_type_specified) {
         shader->Geom.InputType = state->in_qualifier->prim_type;
      } else {
         shader->Geom.InputType = PRIM_UNKNOWN;
      }

      if (state->out_qualifier->flags.q.prim_type) {
         shader->Geom.OutputType = state->out_qualifier->prim_type;
      } else {
         shader->Geom.OutputType = PRIM_UNKNOWN;
      }

      shader->Geom.Invocations = 0;
      if (state->in_qualifier->flags.q.invocations)
         shader->Geom.Invocations = state->in_qualifier->invocations;
      break;

   case MESA_SHADER_COMPUTE:
      if (state->cs_input_local_size_specified) {
         for (int i = 0; i < 3; i++)
            shader->Comp.LocalSize[i] = state->cs_input_local_size[i];
      } else {
         for (int i = 0; i < 3; i++)
            shader->Comp.LocalSize[i] = 0;
      }
      break;

   case MESA_SHADER_FRAGMENT:
      shader->redeclares_gl_fragcoord = state->fs_redeclares_gl_fragcoord;
      shader->uses_gl_fragcoord = state->fs_uses_gl_fragcoord;
      shader->pixel_center_integer = state->fs_pixel_center_integer;
      shader->origin_upper_left = state->fs_origin_upper_left;
      shader->ARB_fragment_coord_conventions_enable =
         state->ARB_fragment_coord_conventions_enable;
      break;

   default:
      /* Nothing to do. */
      break;
   }
}

extern "C" {

void
_mesa_glsl_compile_shader(struct gl_context *ctx, struct gl_shader *shader,
                          bool dump_ast, bool dump_hir)
{
   struct _mesa_glsl_parse_state *state =
      new(shader) _mesa_glsl_parse_state(ctx, shader->Stage, shader);
   const char *source = shader->Source;

   state->error = glcpp_preprocess(state, &source, &state->info_log,
                             &ctx->Extensions, ctx);

   if (!state->error) {
     _mesa_glsl_lexer_ctor(state, source);
     _mesa_glsl_parse(state);
     _mesa_glsl_lexer_dtor(state);
   }

   if (dump_ast) {
      foreach_list_const(n, &state->translation_unit) {
         ast_node *ast = exec_node_data(ast_node, n, link);
         ast->print();
      }
      printf("\n\n");
   }

   ralloc_free(shader->ir);
   shader->ir = new(shader) exec_list;
   if (!state->error && !state->translation_unit.is_empty())
      _mesa_ast_to_hir(shader->ir, state);

   if (!state->error) {
      validate_ir_tree(shader->ir);

      /* Print out the unoptimized IR. */
      if (dump_hir) {
         _mesa_print_ir(stdout, shader->ir, state);
      }
   }


   if (!state->error && !shader->ir->is_empty()) {
      struct gl_shader_compiler_options *options =
         &ctx->ShaderCompilerOptions[shader->Stage];

      /* Do some optimization at compile time to reduce shader IR size
       * and reduce later work if the same shader is linked multiple times
       */
      while (do_common_optimization(shader->ir, false, false, options,
                                    ctx->Const.NativeIntegers))
         ;

      validate_ir_tree(shader->ir);
   }

   if (shader->InfoLog)
      ralloc_free(shader->InfoLog);

   shader->symbols = state->symbols;
   shader->CompileStatus = !state->error;
   shader->InfoLog = state->info_log;
   shader->Version = state->language_version;
   shader->IsES = state->es_shader;
   shader->uses_builtin_functions = state->uses_builtin_functions;

   if (!state->error)
      set_shader_inout_layout(shader, state);

   /* Retain any live IR, but trash the rest. */
   reparent_ir(shader->ir, shader->ir);

   ralloc_free(state);
}

} /* extern "C" */
/**
 * Do the set of common optimizations passes
 *
 * \param ir                          List of instructions to be optimized
 * \param linked                      Is the shader linked?  This enables
 *                                    optimizations passes that remove code at
 *                                    global scope and could cause linking to
 *                                    fail.
 * \param uniform_locations_assigned  Have locations already been assigned for
 *                                    uniforms?  This prevents the declarations
 *                                    of unused uniforms from being removed.
 *                                    The setting of this flag only matters if
 *                                    \c linked is \c true.
 * \param max_unroll_iterations       Maximum number of loop iterations to be
 *                                    unrolled.  Setting to 0 disables loop
 *                                    unrolling.
 * \param options                     The driver's preferred shader options.
 */
bool
do_common_optimization(exec_list *ir, bool linked,
		       bool uniform_locations_assigned,
                       const struct gl_shader_compiler_options *options,
                       bool native_integers)
{
   GLboolean progress = GL_FALSE;

   progress = lower_instructions(ir, SUB_TO_ADD_NEG) || progress;

   if (linked) {
      progress = do_function_inlining(ir) || progress;
      progress = do_dead_functions(ir) || progress;
      progress = do_structure_splitting(ir) || progress;
   }
   progress = do_if_simplification(ir) || progress;
   progress = opt_flatten_nested_if_blocks(ir) || progress;
   progress = do_copy_propagation(ir) || progress;
   progress = do_copy_propagation_elements(ir) || progress;

   if (options->OptimizeForAOS && !linked)
      progress = opt_flip_matrices(ir) || progress;

   if (linked && options->OptimizeForAOS) {
      progress = do_vectorize(ir) || progress;
   }

   if (linked)
      progress = do_dead_code(ir, uniform_locations_assigned) || progress;
   else
      progress = do_dead_code_unlinked(ir) || progress;
   progress = do_dead_code_local(ir) || progress;
   progress = do_tree_grafting(ir) || progress;
   progress = do_constant_propagation(ir) || progress;
   if (linked)
      progress = do_constant_variable(ir) || progress;
   else
      progress = do_constant_variable_unlinked(ir) || progress;
   progress = do_constant_folding(ir) || progress;
   progress = do_cse(ir) || progress;
   progress = do_algebraic(ir, native_integers) || progress;
   progress = do_lower_jumps(ir) || progress;
   progress = do_vec_index_to_swizzle(ir) || progress;
   progress = lower_vector_insert(ir, false) || progress;
   progress = do_swizzle_swizzle(ir) || progress;
   progress = do_noop_swizzle(ir) || progress;

   progress = optimize_split_arrays(ir, linked) || progress;
   progress = optimize_redundant_jumps(ir) || progress;

   loop_state *ls = analyze_loop_variables(ir);
   if (ls->loop_found) {
      progress = set_loop_controls(ir, ls) || progress;
      progress = unroll_loops(ir, ls, options) || progress;
   }
   delete ls;

   return progress;
}

extern "C" {

/**
 * To be called at GL teardown time, this frees compiler datastructures.
 *
 * After calling this, any previously compiled shaders and shader
 * programs would be invalid.  So this should happen at approximately
 * program exit.
 */
void
_mesa_destroy_shader_compiler(void)
{
   _mesa_destroy_shader_compiler_caches();

   _mesa_glsl_release_types();
}

/**
 * Releases compiler caches to trade off performance for memory.
 *
 * Intended to be used with glReleaseShaderCompiler().
 */
void
_mesa_destroy_shader_compiler_caches(void)
{
   _mesa_glsl_release_builtin_functions();
}

}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d34 1
a34 1
#include "util/ralloc.h"
a136 3
   /* ARB_viewport_array */
   this->Const.MaxViewports = ctx->Const.MaxViewports;

a212 2
   this->allow_extension_directive_midshader =
      ctx->Const.AllowGLSLExtensionDirectiveMidShader;
a514 1
   EXT(ARB_derivative_control,         true,  false,     ARB_derivative_control),
a517 1
   EXT(ARB_explicit_uniform_location,  true,  false,     ARB_explicit_uniform_location),
a518 1
   EXT(ARB_fragment_layer_viewport,    true,  false,     ARB_fragment_layer_viewport),
a552 1
   EXT(AMD_vertex_shader_viewport_index, true,  false,   AMD_vertex_shader_viewport_index),
d845 2
a846 1
   foreach_list_typed(ast_node, ast, link, &this->statements) {
d925 2
a926 2
      foreach_list_typed (ast_node, ast, link, &this->expressions) {
	 if (&ast->link != this->expressions.get_head())
d929 1
d961 2
a962 2
      foreach_list_typed (ast_node, ast, link, & this->expressions) {
	 if (&ast->link != this->expressions.get_head())
d965 1
d974 2
a975 2
      foreach_list_typed (ast_node, ast, link, & this->expressions) {
	 if (&ast->link != this->expressions.get_head())
d978 1
d1028 2
a1029 1
   foreach_list_typed(ast_node, ast, link, & this->parameters) {
d1101 1
a1101 1
   else if (invariant)
a1102 2
   else
      printf("precise ");
d1104 2
a1105 2
   foreach_list_typed (ast_node, ast, link, & this->declarations) {
      if (&ast->link != this->declarations.get_head())
d1108 1
a1119 1
   this->precise = false;
d1239 2
a1240 1
   foreach_list_typed(ast_node, ast, link, & this->labels) {
d1255 2
a1256 1
   foreach_list_typed(ast_node, ast, link, & this->stmts) {
d1271 2
a1272 1
   foreach_list_typed(ast_node, ast, link, & this->cases) {
d1342 2
a1343 1
   foreach_list_typed(ast_node, ast, link, &this->declarations) {
a1353 1
      static mtx_t mutex = _MTX_INITIALIZER_NP;
d1355 2
a1356 7
      unsigned count;

      mtx_lock(&mutex);
      count = anon_count++;
      mtx_unlock(&mutex);

      identifier = ralloc_asprintf(this, "#anon_struct_%04x", count);
a1443 3
   if (ctx->Const.GenerateTemporaryNames)
      ir_variable::temporaries_allocate_names = true;

d1454 2
a1455 1
      foreach_list_typed(ast_node, ast, link, &state->translation_unit) {
d1478 1
a1478 1
         &ctx->Const.ShaderCompilerOptions[shader->Stage];
a1487 20

      enum ir_variable_mode other;
      switch (shader->Stage) {
      case MESA_SHADER_VERTEX:
         other = ir_var_shader_in;
         break;
      case MESA_SHADER_FRAGMENT:
         other = ir_var_shader_out;
         break;
      default:
         /* Something invalid to ensure optimize_dead_builtin_uniforms
          * doesn't remove anything other than uniforms or constants.
          */
         other = ir_var_mode_count;
         break;
      }

      optimize_dead_builtin_variables(shader->ir, other);

      validate_ir_tree(shader->ir);
d1493 1
a1493 1
   shader->symbols = new(shader->ir) glsl_symbol_table;
a1505 28
   /* Destroy the symbol table.  Create a new symbol table that contains only
    * the variables and functions that still exist in the IR.  The symbol
    * table will be used later during linking.
    *
    * There must NOT be any freed objects still referenced by the symbol
    * table.  That could cause the linker to dereference freed memory.
    *
    * We don't have to worry about types or interface-types here because those
    * are fly-weights that are looked up by glsl_type.
    */
   foreach_in_list (ir_instruction, ir, shader->ir) {
      switch (ir->ir_type) {
      case ir_type_function:
         shader->symbols->add_function((ir_function *) ir);
         break;
      case ir_type_variable: {
         ir_variable *const var = (ir_variable *) ir;

         if (var->data.mode != ir_var_temporary)
            shader->symbols->add_variable(var);
         break;
      }
      default:
         break;
      }
   }

   delete state->symbols;
a1566 1
   progress = do_minmax_prune(ir) || progress;
d1568 1
a1568 2
   progress = do_rebalance_tree(ir) || progress;
   progress = do_algebraic(ir, native_integers, options) || progress;
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d34 1
a34 1
#include "ralloc.h"
d137 3
d216 2
d520 1
d524 1
d526 1
d561 1
d854 1
a854 2
   foreach_list_const(n, &this->statements) {
      ast_node *ast = exec_node_data(ast_node, n, link);
d933 2
a934 2
      foreach_list_const (n, &this->expressions) {
	 if (n != this->expressions.get_head())
a936 1
	 ast_node *ast = exec_node_data(ast_node, n, link);
d968 2
a969 2
      foreach_list_const(n, & this->expressions) {
	 if (n != this->expressions.get_head())
a971 1
	 ast_node *ast = exec_node_data(ast_node, n, link);
d980 2
a981 2
      foreach_list_const(n, & this->expressions) {
	 if (n != this->expressions.get_head())
a983 1
	 ast_node *ast = exec_node_data(ast_node, n, link);
d1033 1
a1033 2
   foreach_list_const(n, & this->parameters) {
      ast_node *ast = exec_node_data(ast_node, n, link);
d1105 2
d1108 1
a1108 1
      printf("invariant ");
d1110 2
a1111 2
   foreach_list_const (ptr, & this->declarations) {
      if (ptr != this->declarations.get_head())
a1113 1
      ast_node *ast = exec_node_data(ast_node, ptr, link);
d1125 1
d1245 1
a1245 2
   foreach_list_const(n, & this->labels) {
      ast_node *ast = exec_node_data(ast_node, n, link);
d1260 1
a1260 2
   foreach_list_const(n, & this->stmts) {
      ast_node *ast = exec_node_data(ast_node, n, link);
d1275 1
a1275 2
   foreach_list_const(n, & this->cases) {
      ast_node *ast = exec_node_data(ast_node, n, link);
d1345 1
a1345 2
   foreach_list_const(n, &this->declarations) {
      ast_node *ast = exec_node_data(ast_node, n, link);
d1356 1
d1358 7
a1364 2
      identifier = ralloc_asprintf(this, "#anon_struct_%04x", anon_count);
      anon_count++;
d1452 3
d1465 1
a1465 2
      foreach_list_const(n, &state->translation_unit) {
         ast_node *ast = exec_node_data(ast_node, n, link);
d1488 1
a1488 1
         &ctx->ShaderCompilerOptions[shader->Stage];
d1498 20
d1523 1
a1523 1
   shader->symbols = state->symbols;
d1536 28
d1625 1
d1627 2
a1628 1
   progress = do_algebraic(ir, native_integers) || progress;
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d52 2
a53 2
static unsigned known_desktop_glsl_versions[] =
   { 110, 120, 130, 140, 150, 330, 400, 410, 420, 430 };
d57 4
a60 2
					       GLenum target, void *mem_ctx)
 : ctx(_ctx)
d62 2
a63 5
   switch (target) {
   case GL_VERTEX_SHADER:   this->target = vertex_shader; break;
   case GL_FRAGMENT_SHADER: this->target = fragment_shader; break;
   case GL_GEOMETRY_SHADER: this->target = geometry_shader; break;
   }
d68 1
a71 1
   this->switch_state.switch_nesting_ast = NULL;
d74 2
a75 1
   this->num_builtins_to_link = 0;
d96 3
a98 4
   this->Const.MaxVertexAttribs = ctx->Const.VertexProgram.MaxAttribs;
   this->Const.MaxVertexUniformComponents = ctx->Const.VertexProgram.MaxUniformComponents;
   this->Const.MaxVaryingFloats = ctx->Const.MaxVarying * 4;
   this->Const.MaxVertexTextureImageUnits = ctx->Const.VertexProgram.MaxTextureImageUnits;
d100 2
a101 2
   this->Const.MaxTextureImageUnits = ctx->Const.FragmentProgram.MaxTextureImageUnits;
   this->Const.MaxFragmentUniformComponents = ctx->Const.FragmentProgram.MaxUniformComponents;
d107 37
d199 14
d259 1
a259 1
   _mesa_glsl_error(locp, this, "%s in %s%s.",
d289 1
a289 1
                             "The compatibility profile is not supported.\n");
d293 1
a293 1
                             "if present, it must be \"core\".\n", ident);
d297 1
a297 1
                          "Illegal text following version number\n");
d306 1
a306 1
                          "`#version 100'\n");
d312 4
d329 1
a329 1
                       "Supported versions are: %s\n",
a351 37

   if (this->language_version >= 140) {
      this->ARB_uniform_buffer_object_enable = true;
   }

   if (this->language_version == 300 && this->es_shader) {
      this->ARB_explicit_attrib_location_enable = true;
   }
}

extern "C" {

/**
 * The most common use of _mesa_glsl_shader_target_name(), which is
 * shared with C code in Mesa core to translate a GLenum to a short
 * shader stage name in debug printouts.
 *
 * It recognizes the PROGRAM variants of the names so it can be used
 * with a struct gl_program->Target, not just a struct
 * gl_shader->Type.
 */
const char *
_mesa_glsl_shader_target_name(GLenum type)
{
   switch (type) {
   case GL_VERTEX_SHADER:
   case GL_VERTEX_PROGRAM_ARB:
      return "vertex";
   case GL_FRAGMENT_SHADER:
   case GL_FRAGMENT_PROGRAM_ARB:
      return "fragment";
   case GL_GEOMETRY_SHADER:
      return "geometry";
   default:
      assert(!"Should not get here.");
      return "unknown";
   }
a353 1
} /* extern "C" */
d356 2
a357 2
 * Overloaded C++ variant usable within the compiler for translating
 * our internal enum into short stage names.
d360 1
a360 1
_mesa_glsl_shader_target_name(enum _mesa_glsl_parser_targets target)
d362 4
a365 4
   switch (target) {
   case vertex_shader:   return "vertex";
   case fragment_shader: return "fragment";
   case geometry_shader: return "geometry";
a450 9
   /** True if this extension is available to vertex shaders */
   bool avail_in_VS;

   /** True if this extension is available to geometry shaders */
   bool avail_in_GS;

   /** True if this extension is available to fragment shaders */
   bool avail_in_FS;

d497 3
a499 3
#define EXT(NAME, VS, GS, FS, GL, ES, SUPPORTED_FLAG)                   \
   { "GL_" #NAME, VS, GS, FS, GL, ES, &gl_extensions::SUPPORTED_FLAG,   \
         &_mesa_glsl_parse_state::NAME##_enable,                        \
d507 49
a555 25
   /*                                  target availability  API availability */
   /* name                             VS     GS     FS     GL     ES         supported flag */
   EXT(ARB_conservative_depth,         false, false, true,  true,  false,     ARB_conservative_depth),
   EXT(ARB_draw_buffers,               false, false, true,  true,  false,     dummy_true),
   EXT(ARB_draw_instanced,             true,  false, false, true,  false,     ARB_draw_instanced),
   EXT(ARB_explicit_attrib_location,   true,  false, true,  true,  false,     ARB_explicit_attrib_location),
   EXT(ARB_fragment_coord_conventions, true,  false, true,  true,  false,     ARB_fragment_coord_conventions),
   EXT(ARB_texture_rectangle,          true,  false, true,  true,  false,     dummy_true),
   EXT(EXT_texture_array,              true,  false, true,  true,  false,     EXT_texture_array),
   EXT(ARB_shader_texture_lod,         true,  false, true,  true,  false,     ARB_shader_texture_lod),
   EXT(ARB_shader_stencil_export,      false, false, true,  true,  false,     ARB_shader_stencil_export),
   EXT(AMD_conservative_depth,         false, false, true,  true,  false,     ARB_conservative_depth),
   EXT(AMD_shader_stencil_export,      false, false, true,  true,  false,     ARB_shader_stencil_export),
   EXT(OES_texture_3D,                 true,  false, true,  false, true,      EXT_texture3D),
   EXT(OES_EGL_image_external,         true,  false, true,  false, true,      OES_EGL_image_external),
   EXT(ARB_shader_bit_encoding,        true,  true,  true,  true,  false,     ARB_shader_bit_encoding),
   EXT(ARB_uniform_buffer_object,      true,  false, true,  true,  false,     ARB_uniform_buffer_object),
   EXT(OES_standard_derivatives,       false, false, true,  false,  true,     OES_standard_derivatives),
   EXT(ARB_texture_cube_map_array,     true,  false, true,  true,  false,     ARB_texture_cube_map_array),
   EXT(ARB_shading_language_packing,   true,  false, true,  true,  false,     ARB_shading_language_packing),
   EXT(ARB_shading_language_420pack,   true,  true,  true,  true,  false,     ARB_shading_language_420pack),
   EXT(ARB_texture_multisample,        true,  false, true,  true,  false,     ARB_texture_multisample),
   EXT(ARB_texture_query_lod,          false, false, true,  true,  false,     ARB_texture_query_lod),
   EXT(ARB_gpu_shader5,                true,  true,  true,  true,  false,     ARB_gpu_shader5),
   EXT(AMD_vertex_shader_layer,        true,  false, false, true,  false,     AMD_vertex_shader_layer),
a567 24
   /* Check that this extension matches the type of shader we are
    * compiling to.
    */
   switch (state->target) {
   case vertex_shader:
      if (!this->avail_in_VS) {
         return false;
      }
      break;
   case geometry_shader:
      if (!this->avail_in_GS) {
         return false;
      }
      break;
   case fragment_shader:
      if (!this->avail_in_FS) {
         return false;
      }
      break;
   default:
      assert (!"Unrecognized shader target");
      return false;
   }

d633 1
a633 1
		       "Unknown extension behavior `%s'",
d640 1
a640 1
	 _mesa_glsl_error(name_locp, state, "Cannot %s all extensions",
d659 1
a659 1
         static const char *const fmt = "extension `%s' unsupported in %s shader";
d663 1
a663 1
                             name, _mesa_glsl_shader_target_name(state->target));
d667 1
a667 1
                               name, _mesa_glsl_shader_target_name(state->target));
a676 19
 * Returns the name of the type of a column of a matrix. E.g.,
 *
 *    "mat3"   -> "vec3"
 *    "mat4x2" -> "vec2"
 */
static const char *
_mesa_ast_get_matrix_column_type_name(const char *matrix_type_name)
{
   static const char *vec_name[] = { "vec2", "vec3", "vec4" };

   /* The number of elements in a row of a matrix is specified by the last
    * character of the matrix type name.
    */
   long rows = strtol(matrix_type_name + strlen(matrix_type_name) - 1,
                      NULL, 10);
   return vec_name[rows - 2];
}

/**
d723 2
a724 3
_mesa_ast_set_aggregate_type(const ast_type_specifier *type,
                             ast_expression *expr,
                             _mesa_glsl_parse_state *state)
a725 1
   void *ctx = state;
d727 1
a727 11
   ai->constructor_type = (ast_type_specifier *)type;

   bool is_declaration = ai->constructor_type->structure != NULL;
   if (!is_declaration) {
      /* Look up <type> name in the symbol table to see if it's a struct. */
      const ast_type_specifier *struct_type =
         state->symbols->get_type_ast(type->type_name);
      ai->constructor_type->structure =
         struct_type ? new(ctx) ast_struct_specifier(*struct_type->structure)
                     : NULL;
   }
d730 2
a731 3
   if (type->is_array) {
      /* We want to set the element type which is not an array itself, so make
       * a copy of the array type and set its is_array field to false.
a734 2
       *
       * FINISHME: Update when ARB_array_of_arrays is supported.
a735 3
      const ast_type_specifier *non_array_type =
         new(ctx) ast_type_specifier(type, false, NULL);

d743 1
a743 1
            _mesa_ast_set_aggregate_type(non_array_type, expr, state);
d747 1
a747 2
   } else if (ai->constructor_type->structure) {
      ai->constructor_type->structure->is_declaration = is_declaration;
d750 5
a754 40
      /* Iterate through the struct's fields' declarations. E.g., iterate from
       * "float a, b" to "int c" in the struct below.
       *
       *     struct {
       *         float a, b;
       *         int c;
       *     } s;
       */
      for (exec_node *decl_list_node =
              ai->constructor_type->structure->declarations.head;
           !decl_list_node->is_tail_sentinel();
           decl_list_node = decl_list_node->next) {
         ast_declarator_list *decl_list = exec_node_data(ast_declarator_list,
                                                         decl_list_node, link);

         for (exec_node *decl_node = decl_list->declarations.head;
              !decl_node->is_tail_sentinel() && !expr_node->is_tail_sentinel();
              decl_node = decl_node->next, expr_node = expr_node->next) {
            ast_declaration *decl = exec_node_data(ast_declaration, decl_node,
                                                   link);
            ast_expression *expr = exec_node_data(ast_expression, expr_node,
                                                  link);

            bool is_array = decl_list->type->specifier->is_array;
            ast_expression *array_size = decl_list->type->specifier->array_size;

            /* Recognize variable declarations with the bracketed size attached
             * to the type rather than the variable name as arrays. E.g.,
             *
             *     float a[2];
             *     float[2] b;
             *
             * are both arrays, but <a>'s array_size is decl->array_size, while
             * <b>'s array_size is decl_list->type->specifier->array_size.
             */
            if (!is_array) {
               /* FINISHME: Update when ARB_array_of_arrays is supported. */
               is_array = decl->is_array;
               array_size = decl->array_size;
            }
d756 2
a757 7
            /* Declaration shadows the <type> parameter. */
            ast_type_specifier *type =
               new(ctx) ast_type_specifier(decl_list->type->specifier,
                                           is_array, array_size);

            if (expr->oper == ast_aggregate)
               _mesa_ast_set_aggregate_type(type, expr, state);
d760 7
a766 16
   } else {
      /* If the aggregate is a matrix, set its columns' types. */
      const char *name;
      const glsl_type *const constructor_type =
         ai->constructor_type->glsl_type(&name, state);

      if (constructor_type->is_matrix()) {
         for (exec_node *expr_node = ai->expressions.head;
              !expr_node->is_tail_sentinel();
              expr_node = expr_node->next) {
            ast_expression *expr = exec_node_data(ast_expression, expr_node,
                                                  link);

            /* Declaration shadows the <type> parameter. */
            ast_type_specifier *type = new(ctx)
               ast_type_specifier(_mesa_ast_get_matrix_column_type_name(name));
d768 2
a769 3
            if (expr->oper == ast_aggregate)
               _mesa_ast_set_aggregate_type(type, expr, state);
         }
d802 2
d825 4
a828 2
   this->location.line = 0;
   this->location.column = 0;
d833 1
a833 1
ast_opt_array_size_print(bool is_array, const ast_expression *array_size)
d835 2
a836 8
   if (is_array) {
      printf("[ ");

      if (array_size)
	 array_size->print();

      printf("] ");
   }
d994 2
a995 1
			       ast_expression *ex2)
d1038 2
a1039 1
   : is_definition(false), signature(NULL)
d1059 1
a1059 1
   ast_opt_array_size_print(is_array, array_size);
d1075 1
a1075 1
   ast_opt_array_size_print(is_array, array_size);
d1084 2
a1085 2
ast_declaration::ast_declaration(const char *identifier, bool is_array,
				 ast_expression *array_size,
d1089 1
a1089 2
   this->is_array = is_array;
   this->array_size = array_size;
d1363 71
d1441 1
a1441 1
      new(shader) _mesa_glsl_parse_state(ctx, shader->Type, shader);
d1471 1
a1471 1
         _mesa_print_ir(shader->ir, state);
d1478 1
a1478 1
         &ctx->ShaderCompilerOptions[_mesa_shader_type_to_index(shader->Type)];
d1483 2
a1484 1
      while (do_common_optimization(shader->ir, false, false, 32, options))
a1496 1
   shader->InfoLog = state->info_log;
d1498 1
d1500 2
a1501 9
   memcpy(shader->builtins_to_link, state->builtins_to_link,
          sizeof(shader->builtins_to_link[0]) * state->num_builtins_to_link);
   shader->num_builtins_to_link = state->num_builtins_to_link;

   if (shader->UniformBlocks)
      ralloc_free(shader->UniformBlocks);
   shader->NumUniformBlocks = state->num_uniform_blocks;
   shader->UniformBlocks = state->uniform_blocks;
   ralloc_steal(shader, shader->UniformBlocks);
d1531 2
a1532 2
		       unsigned max_unroll_iterations,
                       const struct gl_shader_compiler_options *options)
d1548 1
a1548 1
   if (options->PreferDP4 && !linked)
d1551 4
d1567 2
a1568 1
   progress = do_algebraic(ir) || progress;
d1581 1
a1581 1
      progress = unroll_loops(ir, ls, max_unroll_iterations) || progress;
d1613 1
a1613 1
   _mesa_glsl_release_functions();
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d30 2
d41 16
a56 1
_mesa_glsl_parse_state::_mesa_glsl_parse_state(struct gl_context *ctx,
d58 1
d71 5
a75 1
   this->loop_or_switch_nesting = NULL;
d78 2
a79 1
   this->language_version = 110;
d99 1
a99 1
   this->Const.MaxVertexTextureImageUnits = ctx->Const.MaxVertexTextureImageUnits;
d101 1
a101 1
   this->Const.MaxTextureImageUnits = ctx->Const.MaxTextureImageUnits;
d103 2
d108 33
a140 17
   /* Note: Once the OpenGL 3.0 'forward compatible' context or the OpenGL 3.2
    * Core context is supported, this logic will need change.  Older versions of
    * GLSL are no longer supported outside the compatibility contexts of 3.x.
    */
   this->Const.GLSL_100ES = (ctx->API == API_OPENGLES2)
      || ctx->Extensions.ARB_ES2_compatibility;
   this->Const.GLSL_110 = (ctx->API == API_OPENGL);
   this->Const.GLSL_120 = (ctx->API == API_OPENGL)
      && (ctx->Const.GLSLVersion >= 120);
   this->Const.GLSL_130 = (ctx->API == API_OPENGL)
      && (ctx->Const.GLSLVersion >= 130);

   const unsigned lowest_version =
      (ctx->API == API_OPENGLES2) || ctx->Extensions.ARB_ES2_compatibility
      ? 100 : 110;
   const unsigned highest_version =
      (ctx->API == API_OPENGL) ? ctx->Const.GLSLVersion : 100;
d142 3
a144 3

   for (unsigned ver = lowest_version; ver <= highest_version; ver += 10) {
      const char *const prefix = (ver == lowest_version)
d146 2
a147 1
	 : ((ver == highest_version) ? ", and " : ", ");
d149 1
a149 1
      ralloc_asprintf_append(& supported, "%s%d.%02d%s",
d152 1
a152 1
			     (ver == 100) ? " ES" : "");
d156 150
d308 35
d356 31
a395 5
   assert(state->info_log != NULL);
   ralloc_asprintf_append(&state->info_log, "%u:%u(%u): error: ",
					    locp->source,
					    locp->first_line,
					    locp->first_column);
d397 1
a397 1
   ralloc_vasprintf_append(&state->info_log, fmt, ap);
a398 1
   ralloc_strcat(&state->info_log, "\n");
a407 5
   assert(state->info_log != NULL);
   ralloc_asprintf_append(&state->info_log, "%u:%u(%u): warning: ",
					    locp->source,
					    locp->first_line,
					    locp->first_column);
d409 1
a409 1
   ralloc_vasprintf_append(&state->info_log, fmt, ap);
a410 1
   ralloc_strcat(&state->info_log, "\n");
d502 1
d511 1
a511 1
   EXT(AMD_conservative_depth,         true,  false, true,  true,  false,     AMD_conservative_depth),
d514 11
d668 188
d1055 13
d1083 1
d1165 1
a1165 1
ast_declaration::ast_declaration(char *identifier, int is_array,
d1229 1
d1266 100
d1432 2
a1433 2
ast_struct_specifier::ast_struct_specifier(char *identifier,
					   ast_node *declarator_list)
d1442 1
d1445 100
d1546 4
a1549 1
do_common_optimization(exec_list *ir, bool linked, unsigned max_unroll_iterations)
d1558 1
a1559 1
   progress = do_structure_splitting(ir) || progress;
d1561 1
a1561 1
   progress = do_discard_simplification(ir) || progress;
d1564 4
d1569 1
a1569 1
      progress = do_dead_code(ir) || progress;
d1583 1
d1587 1
@


1.1
log
@Initial revision
@
text
@d257 1
d262 1
d264 3
d548 1
a548 1
      subexpressions[1]->print();
d898 1
d920 4
a923 2
   progress = set_loop_controls(ir, ls) || progress;
   progress = unroll_loops(ir, ls, max_unroll_iterations) || progress;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a29 2
#include "main/context.h"
#include "main/shaderobj.h"
d39 1
a39 16
/**
 * Format a short human-readable description of the given GLSL version.
 */
const char *
glsl_compute_version_string(void *mem_ctx, bool is_es, unsigned version)
{
   return ralloc_asprintf(mem_ctx, "GLSL%s %d.%02d", is_es ? " ES" : "",
                          version / 100, version % 100);
}


static unsigned known_desktop_glsl_versions[] =
   { 110, 120, 130, 140, 150, 330, 400, 410, 420, 430 };


_mesa_glsl_parse_state::_mesa_glsl_parse_state(struct gl_context *_ctx,
a40 1
 : ctx(_ctx)
d53 1
a53 5
   this->loop_nesting_ast = NULL;
   this->switch_state.switch_nesting_ast = NULL;

   this->struct_specifier_depth = 0;
   this->num_builtins_to_link = 0;
d56 1
a56 2
   this->language_version = ctx->Const.ForceGLSLVersion ?
                            ctx->Const.ForceGLSLVersion : 110;
d76 1
a76 1
   this->Const.MaxVertexTextureImageUnits = ctx->Const.VertexProgram.MaxTextureImageUnits;
d78 1
a78 1
   this->Const.MaxTextureImageUnits = ctx->Const.FragmentProgram.MaxTextureImageUnits;
a79 2
   this->Const.MinProgramTexelOffset = ctx->Const.MinProgramTexelOffset;
   this->Const.MaxProgramTexelOffset = ctx->Const.MaxProgramTexelOffset;
d83 18
a100 29
   /* Populate the list of supported GLSL versions */
   /* FINISHME: Once the OpenGL 3.0 'forward compatible' context or
    * the OpenGL 3.2 Core context is supported, this logic will need
    * change.  Older versions of GLSL are no longer supported
    * outside the compatibility contexts of 3.x.
    */
   this->num_supported_versions = 0;
   if (_mesa_is_desktop_gl(ctx)) {
      for (unsigned i = 0; i < ARRAY_SIZE(known_desktop_glsl_versions); i++) {
         if (known_desktop_glsl_versions[i] <= ctx->Const.GLSLVersion) {
            this->supported_versions[this->num_supported_versions].ver
               = known_desktop_glsl_versions[i];
            this->supported_versions[this->num_supported_versions].es = false;
            this->num_supported_versions++;
         }
      }
   }
   if (ctx->API == API_OPENGLES2 || ctx->Extensions.ARB_ES2_compatibility) {
      this->supported_versions[this->num_supported_versions].ver = 100;
      this->supported_versions[this->num_supported_versions].es = true;
      this->num_supported_versions++;
   }
   if (_mesa_is_gles3(ctx) || ctx->Extensions.ARB_ES3_compatibility) {
      this->supported_versions[this->num_supported_versions].ver = 300;
      this->supported_versions[this->num_supported_versions].es = true;
      this->num_supported_versions++;
   }
   assert(this->num_supported_versions
          <= ARRAY_SIZE(this->supported_versions));
d102 2
a103 7
   /* Create a string for use in error messages to tell the user which GLSL
    * versions are supported.
    */
   char *supported = ralloc_strdup(this, "");
   for (unsigned i = 0; i < this->num_supported_versions; i++) {
      unsigned ver = this->supported_versions[i].ver;
      const char *const prefix = (i == 0)
d105 1
a105 2
	 : ((i == this->num_supported_versions - 1) ? ", and " : ", ");
      const char *const suffix = (this->supported_versions[i].es) ? " ES" : "";
d107 1
a107 1
      ralloc_asprintf_append(& supported, "%s%u.%02u%s",
d110 1
a110 1
			     suffix);
a113 179

   if (ctx->Const.ForceGLSLExtensionsWarn)
      _mesa_glsl_process_extension("all", NULL, "warn", NULL, this);

   this->default_uniform_qualifier = new(this) ast_type_qualifier();
   this->default_uniform_qualifier->flags.q.shared = 1;
   this->default_uniform_qualifier->flags.q.column_major = 1;
}

/**
 * Determine whether the current GLSL version is sufficiently high to support
 * a certain feature, and generate an error message if it isn't.
 *
 * \param required_glsl_version and \c required_glsl_es_version are
 * interpreted as they are in _mesa_glsl_parse_state::is_version().
 *
 * \param locp is the parser location where the error should be reported.
 *
 * \param fmt (and additional arguments) constitute a printf-style error
 * message to report if the version check fails.  Information about the
 * current and required GLSL versions will be appended.  So, for example, if
 * the GLSL version being compiled is 1.20, and check_version(130, 300, locp,
 * "foo unsupported") is called, the error message will be "foo unsupported in
 * GLSL 1.20 (GLSL 1.30 or GLSL 3.00 ES required)".
 */
bool
_mesa_glsl_parse_state::check_version(unsigned required_glsl_version,
                                      unsigned required_glsl_es_version,
                                      YYLTYPE *locp, const char *fmt, ...)
{
   if (this->is_version(required_glsl_version, required_glsl_es_version))
      return true;

   va_list args;
   va_start(args, fmt);
   char *problem = ralloc_vasprintf(this, fmt, args);
   va_end(args);
   const char *glsl_version_string
      = glsl_compute_version_string(this, false, required_glsl_version);
   const char *glsl_es_version_string
      = glsl_compute_version_string(this, true, required_glsl_es_version);
   const char *requirement_string = "";
   if (required_glsl_version && required_glsl_es_version) {
      requirement_string = ralloc_asprintf(this, " (%s or %s required)",
                                           glsl_version_string,
                                           glsl_es_version_string);
   } else if (required_glsl_version) {
      requirement_string = ralloc_asprintf(this, " (%s required)",
                                           glsl_version_string);
   } else if (required_glsl_es_version) {
      requirement_string = ralloc_asprintf(this, " (%s required)",
                                           glsl_es_version_string);
   }
   _mesa_glsl_error(locp, this, "%s in %s%s.",
                    problem, this->get_version_string(),
                    requirement_string);

   return false;
}

/**
 * Process a GLSL #version directive.
 *
 * \param version is the integer that follows the #version token.
 *
 * \param ident is a string identifier that follows the integer, if any is
 * present.  Otherwise NULL.
 */
void
_mesa_glsl_parse_state::process_version_directive(YYLTYPE *locp, int version,
                                                  const char *ident)
{
   bool es_token_present = false;
   if (ident) {
      if (strcmp(ident, "es") == 0) {
         es_token_present = true;
      } else if (version >= 150) {
         if (strcmp(ident, "core") == 0) {
            /* Accept the token.  There's no need to record that this is
             * a core profile shader since that's the only profile we support.
             */
         } else if (strcmp(ident, "compatibility") == 0) {
            _mesa_glsl_error(locp, this,
                             "The compatibility profile is not supported.\n");
         } else {
            _mesa_glsl_error(locp, this,
                             "\"%s\" is not a valid shading language profile; "
                             "if present, it must be \"core\".\n", ident);
         }
      } else {
         _mesa_glsl_error(locp, this,
                          "Illegal text following version number\n");
      }
   }

   this->es_shader = es_token_present;
   if (version == 100) {
      if (es_token_present) {
         _mesa_glsl_error(locp, this,
                          "GLSL 1.00 ES should be selected using "
                          "`#version 100'\n");
      } else {
         this->es_shader = true;
      }
   }

   this->language_version = version;

   bool supported = false;
   for (unsigned i = 0; i < this->num_supported_versions; i++) {
      if (this->supported_versions[i].ver == (unsigned) version
          && this->supported_versions[i].es == this->es_shader) {
         supported = true;
         break;
      }
   }

   if (!supported) {
      _mesa_glsl_error(locp, this, "%s is not supported. "
                       "Supported versions are: %s\n",
                       this->get_version_string(),
                       this->supported_version_string);

      /* On exit, the language_version must be set to a valid value.
       * Later calls to _mesa_glsl_initialize_types will misbehave if
       * the version is invalid.
       */
      switch (this->ctx->API) {
      case API_OPENGL_COMPAT:
      case API_OPENGL_CORE:
	 this->language_version = this->ctx->Const.GLSLVersion;
	 break;

      case API_OPENGLES:
	 assert(!"Should not get here.");
	 /* FALLTHROUGH */

      case API_OPENGLES2:
	 this->language_version = 100;
	 break;
      }
   }

   if (this->language_version >= 140) {
      this->ARB_uniform_buffer_object_enable = true;
   }

   if (this->language_version == 300 && this->es_shader) {
      this->ARB_explicit_attrib_location_enable = true;
   }
}

extern "C" {

/**
 * The most common use of _mesa_glsl_shader_target_name(), which is
 * shared with C code in Mesa core to translate a GLenum to a short
 * shader stage name in debug printouts.
 *
 * It recognizes the PROGRAM variants of the names so it can be used
 * with a struct gl_program->Target, not just a struct
 * gl_shader->Type.
 */
const char *
_mesa_glsl_shader_target_name(GLenum type)
{
   switch (type) {
   case GL_VERTEX_SHADER:
   case GL_VERTEX_PROGRAM_ARB:
      return "vertex";
   case GL_FRAGMENT_SHADER:
   case GL_FRAGMENT_PROGRAM_ARB:
      return "fragment";
   case GL_GEOMETRY_SHADER:
      return "geometry";
   default:
      assert(!"Should not get here.");
      return "unknown";
   }
a115 6
} /* extern "C" */

/**
 * Overloaded C++ variant usable within the compiler for translating
 * our internal enum into short stage names.
 */
a128 31
/* This helper function will append the given message to the shader's
   info log and report it via GL_ARB_debug_output. Per that extension,
   'type' is one of the enum values classifying the message, and
   'id' is the implementation-defined ID of the given message. */
static void
_mesa_glsl_msg(const YYLTYPE *locp, _mesa_glsl_parse_state *state,
               GLenum type, const char *fmt, va_list ap)
{
   bool error = (type == MESA_DEBUG_TYPE_ERROR);
   GLuint msg_id = 0;

   assert(state->info_log != NULL);

   /* Get the offset that the new message will be written to. */
   int msg_offset = strlen(state->info_log);

   ralloc_asprintf_append(&state->info_log, "%u:%u(%u): %s: ",
					    locp->source,
					    locp->first_line,
					    locp->first_column,
					    error ? "error" : "warning");
   ralloc_vasprintf_append(&state->info_log, fmt, ap);

   const char *const msg = &state->info_log[msg_offset];
   struct gl_context *ctx = state->ctx;

   /* Report the error via GL_ARB_debug_output. */
   _mesa_shader_debug(ctx, type, &msg_id, msg, strlen(msg));

   ralloc_strcat(&state->info_log, "\n");
}
d138 5
d144 1
a144 1
   _mesa_glsl_msg(locp, state, MESA_DEBUG_TYPE_ERROR, fmt, ap);
d146 1
d156 5
d162 1
a162 1
   _mesa_glsl_msg(locp, state, MESA_DEBUG_TYPE_OTHER, fmt, ap);
d164 1
a255 1
   EXT(ARB_conservative_depth,         false, false, true,  true,  false,     ARB_conservative_depth),
a256 1
   EXT(ARB_draw_instanced,             true,  false, false, true,  false,     ARB_draw_instanced),
a260 1
   EXT(ARB_shader_texture_lod,         true,  false, true,  true,  false,     ARB_shader_texture_lod),
a261 14
   EXT(AMD_conservative_depth,         false, false, true,  true,  false,     ARB_conservative_depth),
   EXT(AMD_shader_stencil_export,      false, false, true,  true,  false,     ARB_shader_stencil_export),
   EXT(OES_texture_3D,                 true,  false, true,  false, true,      EXT_texture3D),
   EXT(OES_EGL_image_external,         true,  false, true,  false, true,      OES_EGL_image_external),
   EXT(ARB_shader_bit_encoding,        true,  true,  true,  true,  false,     ARB_shader_bit_encoding),
   EXT(ARB_uniform_buffer_object,      true,  false, true,  true,  false,     ARB_uniform_buffer_object),
   EXT(OES_standard_derivatives,       false, false, true,  false,  true,     OES_standard_derivatives),
   EXT(ARB_texture_cube_map_array,     true,  false, true,  true,  false,     ARB_texture_cube_map_array),
   EXT(ARB_shading_language_packing,   true,  false, true,  true,  false,     ARB_shading_language_packing),
   EXT(ARB_shading_language_420pack,   true,  true,  true,  true,  false,     ARB_shading_language_420pack),
   EXT(ARB_texture_multisample,        true,  false, true,  true,  false,     ARB_texture_multisample),
   EXT(ARB_texture_query_lod,          false, false, true,  true,  false,     ARB_texture_query_lod),
   EXT(ARB_gpu_shader5,                true,  true,  true,  true,  false,     ARB_gpu_shader5),
   EXT(AMD_vertex_shader_layer,        true,  false, false, true,  false,     AMD_vertex_shader_layer),
a404 188

/**
 * Returns the name of the type of a column of a matrix. E.g.,
 *
 *    "mat3"   -> "vec3"
 *    "mat4x2" -> "vec2"
 */
static const char *
_mesa_ast_get_matrix_column_type_name(const char *matrix_type_name)
{
   static const char *vec_name[] = { "vec2", "vec3", "vec4" };

   /* The number of elements in a row of a matrix is specified by the last
    * character of the matrix type name.
    */
   long rows = strtol(matrix_type_name + strlen(matrix_type_name) - 1,
                      NULL, 10);
   return vec_name[rows - 2];
}

/**
 * Recurses through <type> and <expr> if <expr> is an aggregate initializer
 * and sets <expr>'s <constructor_type> field to <type>. Gives later functions
 * (process_array_constructor, et al) sufficient information to do type
 * checking.
 *
 * Operates on assignments involving an aggregate initializer. E.g.,
 *
 * vec4 pos = {1.0, -1.0, 0.0, 1.0};
 *
 * or more ridiculously,
 *
 * struct S {
 *     vec4 v[2];
 * };
 *
 * struct {
 *     S a[2], b;
 *     int c;
 * } aggregate = {
 *     {
 *         {
 *             {
 *                 {1.0, 2.0, 3.0, 4.0}, // a[0].v[0]
 *                 {5.0, 6.0, 7.0, 8.0}  // a[0].v[1]
 *             } // a[0].v
 *         }, // a[0]
 *         {
 *             {
 *                 {1.0, 2.0, 3.0, 4.0}, // a[1].v[0]
 *                 {5.0, 6.0, 7.0, 8.0}  // a[1].v[1]
 *             } // a[1].v
 *         } // a[1]
 *     }, // a
 *     {
 *         {
 *             {1.0, 2.0, 3.0, 4.0}, // b.v[0]
 *             {5.0, 6.0, 7.0, 8.0}  // b.v[1]
 *         } // b.v
 *     }, // b
 *     4 // c
 * };
 *
 * This pass is necessary because the right-hand side of <type> e = { ... }
 * doesn't contain sufficient information to determine if the types match.
 */
void
_mesa_ast_set_aggregate_type(const ast_type_specifier *type,
                             ast_expression *expr,
                             _mesa_glsl_parse_state *state)
{
   void *ctx = state;
   ast_aggregate_initializer *ai = (ast_aggregate_initializer *)expr;
   ai->constructor_type = (ast_type_specifier *)type;

   bool is_declaration = ai->constructor_type->structure != NULL;
   if (!is_declaration) {
      /* Look up <type> name in the symbol table to see if it's a struct. */
      const ast_type_specifier *struct_type =
         state->symbols->get_type_ast(type->type_name);
      ai->constructor_type->structure =
         struct_type ? new(ctx) ast_struct_specifier(*struct_type->structure)
                     : NULL;
   }

   /* If the aggregate is an array, recursively set its elements' types. */
   if (type->is_array) {
      /* We want to set the element type which is not an array itself, so make
       * a copy of the array type and set its is_array field to false.
       *
       * E.g., if <type> if struct S[2] we want to set each element's type to
       * struct S.
       *
       * FINISHME: Update when ARB_array_of_arrays is supported.
       */
      const ast_type_specifier *non_array_type =
         new(ctx) ast_type_specifier(type, false, NULL);

      for (exec_node *expr_node = ai->expressions.head;
           !expr_node->is_tail_sentinel();
           expr_node = expr_node->next) {
         ast_expression *expr = exec_node_data(ast_expression, expr_node,
                                               link);

         if (expr->oper == ast_aggregate)
            _mesa_ast_set_aggregate_type(non_array_type, expr, state);
      }

   /* If the aggregate is a struct, recursively set its fields' types. */
   } else if (ai->constructor_type->structure) {
      ai->constructor_type->structure->is_declaration = is_declaration;
      exec_node *expr_node = ai->expressions.head;

      /* Iterate through the struct's fields' declarations. E.g., iterate from
       * "float a, b" to "int c" in the struct below.
       *
       *     struct {
       *         float a, b;
       *         int c;
       *     } s;
       */
      for (exec_node *decl_list_node =
              ai->constructor_type->structure->declarations.head;
           !decl_list_node->is_tail_sentinel();
           decl_list_node = decl_list_node->next) {
         ast_declarator_list *decl_list = exec_node_data(ast_declarator_list,
                                                         decl_list_node, link);

         for (exec_node *decl_node = decl_list->declarations.head;
              !decl_node->is_tail_sentinel() && !expr_node->is_tail_sentinel();
              decl_node = decl_node->next, expr_node = expr_node->next) {
            ast_declaration *decl = exec_node_data(ast_declaration, decl_node,
                                                   link);
            ast_expression *expr = exec_node_data(ast_expression, expr_node,
                                                  link);

            bool is_array = decl_list->type->specifier->is_array;
            ast_expression *array_size = decl_list->type->specifier->array_size;

            /* Recognize variable declarations with the bracketed size attached
             * to the type rather than the variable name as arrays. E.g.,
             *
             *     float a[2];
             *     float[2] b;
             *
             * are both arrays, but <a>'s array_size is decl->array_size, while
             * <b>'s array_size is decl_list->type->specifier->array_size.
             */
            if (!is_array) {
               /* FINISHME: Update when ARB_array_of_arrays is supported. */
               is_array = decl->is_array;
               array_size = decl->array_size;
            }

            /* Declaration shadows the <type> parameter. */
            ast_type_specifier *type =
               new(ctx) ast_type_specifier(decl_list->type->specifier,
                                           is_array, array_size);

            if (expr->oper == ast_aggregate)
               _mesa_ast_set_aggregate_type(type, expr, state);
         }
      }
   } else {
      /* If the aggregate is a matrix, set its columns' types. */
      const char *name;
      const glsl_type *const constructor_type =
         ai->constructor_type->glsl_type(&name, state);

      if (constructor_type->is_matrix()) {
         for (exec_node *expr_node = ai->expressions.head;
              !expr_node->is_tail_sentinel();
              expr_node = expr_node->next) {
            ast_expression *expr = exec_node_data(ast_expression, expr_node,
                                                  link);

            /* Declaration shadows the <type> parameter. */
            ast_type_specifier *type = new(ctx)
               ast_type_specifier(_mesa_ast_get_matrix_column_type_name(name));

            if (expr->oper == ast_aggregate)
               _mesa_ast_set_aggregate_type(type, expr, state);
         }
      }
   }
}


d543 1
a543 1
      subexpressions[2]->print();
a603 13
   case ast_aggregate: {
      printf("{ ");
      foreach_list_const(n, & this->expressions) {
	 if (n != this->expressions.get_head())
	    printf(", ");

	 ast_node *ast = exec_node_data(ast_node, n, link);
	 ast->print();
      }
      printf("} ");
      break;
   }

a618 1
   this->non_lvalue_description = NULL;
d700 1
a700 1
ast_declaration::ast_declaration(const char *identifier, bool is_array,
a763 1
   : opt_return_value(NULL)
a799 100
ast_switch_statement::print(void) const
{
   printf("switch ( ");
   test_expression->print();
   printf(") ");

   body->print();
}


ast_switch_statement::ast_switch_statement(ast_expression *test_expression,
					   ast_node *body)
{
   this->test_expression = test_expression;
   this->body = body;
}


void
ast_switch_body::print(void) const
{
   printf("{\n");
   if (stmts != NULL) {
      stmts->print();
   }
   printf("}\n");
}


ast_switch_body::ast_switch_body(ast_case_statement_list *stmts)
{
   this->stmts = stmts;
}


void ast_case_label::print(void) const
{
   if (test_value != NULL) {
      printf("case ");
      test_value->print();
      printf(": ");
   } else {
      printf("default: ");
   }
}


ast_case_label::ast_case_label(ast_expression *test_value)
{
   this->test_value = test_value;
}


void ast_case_label_list::print(void) const
{
   foreach_list_const(n, & this->labels) {
      ast_node *ast = exec_node_data(ast_node, n, link);
      ast->print();
   }
   printf("\n");
}


ast_case_label_list::ast_case_label_list(void)
{
}


void ast_case_statement::print(void) const
{
   labels->print();
   foreach_list_const(n, & this->stmts) {
      ast_node *ast = exec_node_data(ast_node, n, link);
      ast->print();
      printf("\n");
   }
}


ast_case_statement::ast_case_statement(ast_case_label_list *labels)
{
   this->labels = labels;
}


void ast_case_statement_list::print(void) const
{
   foreach_list_const(n, & this->cases) {
      ast_node *ast = exec_node_data(ast_node, n, link);
      ast->print();
   }
}


ast_case_statement_list::ast_case_statement_list(void)
{
}


void
d866 2
a867 2
ast_struct_specifier::ast_struct_specifier(const char *identifier,
					   ast_declarator_list *declarator_list)
a875 1
   is_declaration = true;
a877 100
extern "C" {

void
_mesa_glsl_compile_shader(struct gl_context *ctx, struct gl_shader *shader,
                          bool dump_ast, bool dump_hir)
{
   struct _mesa_glsl_parse_state *state =
      new(shader) _mesa_glsl_parse_state(ctx, shader->Type, shader);
   const char *source = shader->Source;

   state->error = glcpp_preprocess(state, &source, &state->info_log,
                             &ctx->Extensions, ctx);

   if (!state->error) {
     _mesa_glsl_lexer_ctor(state, source);
     _mesa_glsl_parse(state);
     _mesa_glsl_lexer_dtor(state);
   }

   if (dump_ast) {
      foreach_list_const(n, &state->translation_unit) {
         ast_node *ast = exec_node_data(ast_node, n, link);
         ast->print();
      }
      printf("\n\n");
   }

   ralloc_free(shader->ir);
   shader->ir = new(shader) exec_list;
   if (!state->error && !state->translation_unit.is_empty())
      _mesa_ast_to_hir(shader->ir, state);

   if (!state->error) {
      validate_ir_tree(shader->ir);

      /* Print out the unoptimized IR. */
      if (dump_hir) {
         _mesa_print_ir(shader->ir, state);
      }
   }


   if (!state->error && !shader->ir->is_empty()) {
      struct gl_shader_compiler_options *options =
         &ctx->ShaderCompilerOptions[_mesa_shader_type_to_index(shader->Type)];

      /* Do some optimization at compile time to reduce shader IR size
       * and reduce later work if the same shader is linked multiple times
       */
      while (do_common_optimization(shader->ir, false, false, 32, options))
         ;

      validate_ir_tree(shader->ir);
   }

   if (shader->InfoLog)
      ralloc_free(shader->InfoLog);

   shader->symbols = state->symbols;
   shader->CompileStatus = !state->error;
   shader->InfoLog = state->info_log;
   shader->Version = state->language_version;
   shader->InfoLog = state->info_log;
   shader->IsES = state->es_shader;

   memcpy(shader->builtins_to_link, state->builtins_to_link,
          sizeof(shader->builtins_to_link[0]) * state->num_builtins_to_link);
   shader->num_builtins_to_link = state->num_builtins_to_link;

   if (shader->UniformBlocks)
      ralloc_free(shader->UniformBlocks);
   shader->NumUniformBlocks = state->num_uniform_blocks;
   shader->UniformBlocks = state->uniform_blocks;
   ralloc_steal(shader, shader->UniformBlocks);

   /* Retain any live IR, but trash the rest. */
   reparent_ir(shader->ir, shader->ir);

   ralloc_free(state);
}

} /* extern "C" */
/**
 * Do the set of common optimizations passes
 *
 * \param ir                          List of instructions to be optimized
 * \param linked                      Is the shader linked?  This enables
 *                                    optimizations passes that remove code at
 *                                    global scope and could cause linking to
 *                                    fail.
 * \param uniform_locations_assigned  Have locations already been assigned for
 *                                    uniforms?  This prevents the declarations
 *                                    of unused uniforms from being removed.
 *                                    The setting of this flag only matters if
 *                                    \c linked is \c true.
 * \param max_unroll_iterations       Maximum number of loop iterations to be
 *                                    unrolled.  Setting to 0 disables loop
 *                                    unrolling.
 * \param options                     The driver's preferred shader options.
 */
d879 1
a879 4
do_common_optimization(exec_list *ir, bool linked,
		       bool uniform_locations_assigned,
		       unsigned max_unroll_iterations,
                       const struct gl_shader_compiler_options *options)
a887 1
      progress = do_structure_splitting(ir) || progress;
d889 1
d891 1
a891 1
   progress = opt_flatten_nested_if_blocks(ir) || progress;
a892 5
   progress = do_copy_propagation_elements(ir) || progress;

   if (options->PreferDP4 && !linked)
      progress = opt_flip_matrices(ir) || progress;

d894 1
a894 1
      progress = do_dead_code(ir, uniform_locations_assigned) || progress;
a907 1
   progress = lower_vector_insert(ir, false) || progress;
a910 1
   progress = optimize_split_arrays(ir, linked) || progress;
d914 2
a915 4
   if (ls->loop_found) {
      progress = set_loop_controls(ir, ls) || progress;
      progress = unroll_loops(ir, ls, max_unroll_iterations) || progress;
   }
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d52 2
a53 2
static const unsigned known_desktop_glsl_versions[] =
   { 110, 120, 130, 140, 150, 330, 400, 410, 420, 430, 440 };
d57 2
a58 4
					       gl_shader_stage stage,
                                               void *mem_ctx)
   : ctx(_ctx), cs_input_local_size_specified(false), cs_input_local_size(),
     switch_state()
d60 5
a64 2
   assert(stage < MESA_SHADER_STAGES);
   this->stage = stage;
a68 1

d72 1
d75 1
a75 2

   this->uses_builtin_functions = false;
d96 4
a99 3
   this->Const.MaxVertexAttribs = ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs;
   this->Const.MaxVertexUniformComponents = ctx->Const.Program[MESA_SHADER_VERTEX].MaxUniformComponents;
   this->Const.MaxVertexTextureImageUnits = ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits;
d101 2
a102 2
   this->Const.MaxTextureImageUnits = ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits;
   this->Const.MaxFragmentUniformComponents = ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxUniformComponents;
a107 37
   /* 1.50 constants */
   this->Const.MaxVertexOutputComponents = ctx->Const.Program[MESA_SHADER_VERTEX].MaxOutputComponents;
   this->Const.MaxGeometryInputComponents = ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxInputComponents;
   this->Const.MaxGeometryOutputComponents = ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxOutputComponents;
   this->Const.MaxFragmentInputComponents = ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxInputComponents;
   this->Const.MaxGeometryTextureImageUnits = ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits;
   this->Const.MaxGeometryOutputVertices = ctx->Const.MaxGeometryOutputVertices;
   this->Const.MaxGeometryTotalOutputComponents = ctx->Const.MaxGeometryTotalOutputComponents;
   this->Const.MaxGeometryUniformComponents = ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxUniformComponents;

   this->Const.MaxVertexAtomicCounters = ctx->Const.Program[MESA_SHADER_VERTEX].MaxAtomicCounters;
   this->Const.MaxGeometryAtomicCounters = ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxAtomicCounters;
   this->Const.MaxFragmentAtomicCounters = ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxAtomicCounters;
   this->Const.MaxCombinedAtomicCounters = ctx->Const.MaxCombinedAtomicCounters;
   this->Const.MaxAtomicBufferBindings = ctx->Const.MaxAtomicBufferBindings;

   /* Compute shader constants */
   for (unsigned i = 0; i < Elements(this->Const.MaxComputeWorkGroupCount); i++)
      this->Const.MaxComputeWorkGroupCount[i] = ctx->Const.MaxComputeWorkGroupCount[i];
   for (unsigned i = 0; i < Elements(this->Const.MaxComputeWorkGroupSize); i++)
      this->Const.MaxComputeWorkGroupSize[i] = ctx->Const.MaxComputeWorkGroupSize[i];

   this->Const.MaxImageUnits = ctx->Const.MaxImageUnits;
   this->Const.MaxCombinedImageUnitsAndFragmentOutputs = ctx->Const.MaxCombinedImageUnitsAndFragmentOutputs;
   this->Const.MaxImageSamples = ctx->Const.MaxImageSamples;
   this->Const.MaxVertexImageUniforms = ctx->Const.Program[MESA_SHADER_VERTEX].MaxImageUniforms;
   this->Const.MaxGeometryImageUniforms = ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxImageUniforms;
   this->Const.MaxFragmentImageUniforms = ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxImageUniforms;
   this->Const.MaxCombinedImageUniforms = ctx->Const.MaxCombinedImageUniforms;

   this->current_function = NULL;
   this->toplevel_ir = NULL;
   this->found_return = false;
   this->all_invariant = false;
   this->user_structures = NULL;
   this->num_user_structures = 0;

a162 14

   this->fs_uses_gl_fragcoord = false;
   this->fs_redeclares_gl_fragcoord = false;
   this->fs_origin_upper_left = false;
   this->fs_pixel_center_integer = false;
   this->fs_redeclares_gl_fragcoord_with_no_layout_qualifiers = false;

   this->gs_input_prim_type_specified = false;
   this->gs_input_size = 0;
   this->in_qualifier = new(this) ast_type_qualifier();
   this->out_qualifier = new(this) ast_type_qualifier();
   this->early_fragment_tests = false;
   memset(this->atomic_counter_offsets, 0,
          sizeof(this->atomic_counter_offsets));
d209 1
a209 1
   _mesa_glsl_error(locp, this, "%s in %s%s",
d239 1
a239 1
                             "the compatibility profile is not supported");
d243 1
a243 1
                             "if present, it must be \"core\"", ident);
d247 1
a247 1
                          "illegal text following version number");
d256 1
a256 1
                          "`#version 100'");
a261 4
   if (this->es_shader) {
      this->ARB_texture_rectangle_enable = false;
   }

d275 1
a275 1
                       "Supported versions are: %s",
d298 37
d337 1
d340 2
a341 2
 * Translate a gl_shader_stage to a short shader stage name for debug
 * printouts and error messages.
d344 1
a344 1
_mesa_shader_stage_to_string(unsigned stage)
d346 4
a349 4
   switch (stage) {
   case MESA_SHADER_VERTEX:   return "vertex";
   case MESA_SHADER_FRAGMENT: return "fragment";
   case MESA_SHADER_GEOMETRY: return "geometry";
d435 9
d490 3
a492 3
#define EXT(NAME, GL, ES, SUPPORTED_FLAG)                   \
   { "GL_" #NAME, GL, ES, &gl_extensions::SUPPORTED_FLAG,   \
         &_mesa_glsl_parse_state::NAME##_enable,            \
d500 25
a524 49
   /*                                  API availability */
   /* name                             GL     ES         supported flag */

   /* ARB extensions go here, sorted alphabetically.
    */
   EXT(ARB_arrays_of_arrays,           true,  false,     ARB_arrays_of_arrays),
   EXT(ARB_compute_shader,             true,  false,     ARB_compute_shader),
   EXT(ARB_conservative_depth,         true,  false,     ARB_conservative_depth),
   EXT(ARB_draw_buffers,               true,  false,     dummy_true),
   EXT(ARB_draw_instanced,             true,  false,     ARB_draw_instanced),
   EXT(ARB_explicit_attrib_location,   true,  false,     ARB_explicit_attrib_location),
   EXT(ARB_fragment_coord_conventions, true,  false,     ARB_fragment_coord_conventions),
   EXT(ARB_gpu_shader5,                true,  false,     ARB_gpu_shader5),
   EXT(ARB_sample_shading,             true,  false,     ARB_sample_shading),
   EXT(ARB_separate_shader_objects,    true,  false,     dummy_true),
   EXT(ARB_shader_atomic_counters,     true,  false,     ARB_shader_atomic_counters),
   EXT(ARB_shader_bit_encoding,        true,  false,     ARB_shader_bit_encoding),
   EXT(ARB_shader_image_load_store,    true,  false,     ARB_shader_image_load_store),
   EXT(ARB_shader_stencil_export,      true,  false,     ARB_shader_stencil_export),
   EXT(ARB_shader_texture_lod,         true,  false,     ARB_shader_texture_lod),
   EXT(ARB_shading_language_420pack,   true,  false,     ARB_shading_language_420pack),
   EXT(ARB_shading_language_packing,   true,  false,     ARB_shading_language_packing),
   EXT(ARB_texture_cube_map_array,     true,  false,     ARB_texture_cube_map_array),
   EXT(ARB_texture_gather,             true,  false,     ARB_texture_gather),
   EXT(ARB_texture_multisample,        true,  false,     ARB_texture_multisample),
   EXT(ARB_texture_query_levels,       true,  false,     ARB_texture_query_levels),
   EXT(ARB_texture_query_lod,          true,  false,     ARB_texture_query_lod),
   EXT(ARB_texture_rectangle,          true,  false,     dummy_true),
   EXT(ARB_uniform_buffer_object,      true,  false,     ARB_uniform_buffer_object),
   EXT(ARB_viewport_array,             true,  false,     ARB_viewport_array),

   /* KHR extensions go here, sorted alphabetically.
    */

   /* OES extensions go here, sorted alphabetically.
    */
   EXT(OES_EGL_image_external,         false, true,      OES_EGL_image_external),
   EXT(OES_standard_derivatives,       false, true,      OES_standard_derivatives),
   EXT(OES_texture_3D,                 false, true,      EXT_texture3D),

   /* All other extensions go here, sorted alphabetically.
    */
   EXT(AMD_conservative_depth,         true,  false,     ARB_conservative_depth),
   EXT(AMD_shader_stencil_export,      true,  false,     ARB_shader_stencil_export),
   EXT(AMD_shader_trinary_minmax,      true,  false,     dummy_true),
   EXT(AMD_vertex_shader_layer,        true,  false,     AMD_vertex_shader_layer),
   EXT(EXT_separate_shader_objects,    false, true,      dummy_true),
   EXT(EXT_shader_integer_mix,         true,  true,      EXT_shader_integer_mix),
   EXT(EXT_texture_array,              true,  false,     EXT_texture_array),
d537 24
d626 1
a626 1
		       "unknown extension behavior `%s'",
d633 1
a633 1
	 _mesa_glsl_error(name_locp, state, "cannot %s all extensions",
d652 1
a652 1
         static const char fmt[] = "extension `%s' unsupported in %s shader";
d656 1
a656 1
                             name, _mesa_shader_stage_to_string(state->stage));
d660 1
a660 1
                               name, _mesa_shader_stage_to_string(state->stage));
d670 19
d735 3
a737 2
_mesa_ast_set_aggregate_type(const glsl_type *type,
                             ast_expression *expr)
d739 1
d741 11
a751 1
   ai->constructor_type = type;
d754 3
a756 2
   if (type->is_array()) {
      /* Each array element has the type type->element_type().
d760 2
d763 3
d773 1
a773 1
            _mesa_ast_set_aggregate_type(type->element_type(), expr);
d777 2
a778 1
   } else if (type->is_record()) {
d781 45
a825 5
      /* Iterate through the struct's fields. */
      for (unsigned i = 0; !expr_node->is_tail_sentinel() && i < type->length;
           i++, expr_node = expr_node->next) {
         ast_expression *expr = exec_node_data(ast_expression, expr_node,
                                               link);
d827 2
a828 2
         if (expr->oper == ast_aggregate) {
            _mesa_ast_set_aggregate_type(type->fields.structure[i].type, expr);
d831 16
a846 7
   /* If the aggregate is a matrix, set its columns' types. */
   } else if (type->is_matrix()) {
      for (exec_node *expr_node = ai->expressions.head;
           !expr_node->is_tail_sentinel();
           expr_node = expr_node->next) {
         ast_expression *expr = exec_node_data(ast_expression, expr_node,
                                               link);
d848 3
a850 2
         if (expr->oper == ast_aggregate)
            _mesa_ast_set_aggregate_type(type->column_type(), expr);
a882 2
   if (q->flags.q.sample)
      printf("sample ");
d904 2
a905 4
   this->location.first_line = 0;
   this->location.first_column = 0;
   this->location.last_line = 0;
   this->location.last_column = 0;
d910 1
a910 1
ast_opt_array_dimensions_print(const ast_array_specifier *array_specifier)
d912 8
a919 2
   if (array_specifier)
      array_specifier->print();
d1077 1
a1077 2
			       ast_expression *ex2) :
   primary_expression()
d1120 1
a1120 2
   : return_type(NULL), identifier(NULL), is_definition(false),
     signature(NULL)
d1140 1
a1140 1
   ast_opt_array_dimensions_print(array_specifier);
d1156 1
a1156 1
   ast_opt_array_dimensions_print(array_specifier);
d1165 2
a1166 2
ast_declaration::ast_declaration(const char *identifier,
				 ast_array_specifier *array_specifier,
d1170 2
a1171 1
   this->array_specifier = array_specifier;
a1444 71
static void
set_shader_inout_layout(struct gl_shader *shader,
		     struct _mesa_glsl_parse_state *state)
{
   if (shader->Stage != MESA_SHADER_GEOMETRY) {
      /* Should have been prevented by the parser. */
      assert(!state->in_qualifier->flags.i);
      assert(!state->out_qualifier->flags.i);
   }

   if (shader->Stage != MESA_SHADER_COMPUTE) {
      /* Should have been prevented by the parser. */
      assert(!state->cs_input_local_size_specified);
   }

   if (shader->Stage != MESA_SHADER_FRAGMENT) {
      /* Should have been prevented by the parser. */
      assert(!state->fs_uses_gl_fragcoord);
      assert(!state->fs_redeclares_gl_fragcoord);
      assert(!state->fs_pixel_center_integer);
      assert(!state->fs_origin_upper_left);
   }

   switch (shader->Stage) {
   case MESA_SHADER_GEOMETRY:
      shader->Geom.VerticesOut = 0;
      if (state->out_qualifier->flags.q.max_vertices)
         shader->Geom.VerticesOut = state->out_qualifier->max_vertices;

      if (state->gs_input_prim_type_specified) {
         shader->Geom.InputType = state->in_qualifier->prim_type;
      } else {
         shader->Geom.InputType = PRIM_UNKNOWN;
      }

      if (state->out_qualifier->flags.q.prim_type) {
         shader->Geom.OutputType = state->out_qualifier->prim_type;
      } else {
         shader->Geom.OutputType = PRIM_UNKNOWN;
      }

      shader->Geom.Invocations = 0;
      if (state->in_qualifier->flags.q.invocations)
         shader->Geom.Invocations = state->in_qualifier->invocations;
      break;

   case MESA_SHADER_COMPUTE:
      if (state->cs_input_local_size_specified) {
         for (int i = 0; i < 3; i++)
            shader->Comp.LocalSize[i] = state->cs_input_local_size[i];
      } else {
         for (int i = 0; i < 3; i++)
            shader->Comp.LocalSize[i] = 0;
      }
      break;

   case MESA_SHADER_FRAGMENT:
      shader->redeclares_gl_fragcoord = state->fs_redeclares_gl_fragcoord;
      shader->uses_gl_fragcoord = state->fs_uses_gl_fragcoord;
      shader->pixel_center_integer = state->fs_pixel_center_integer;
      shader->origin_upper_left = state->fs_origin_upper_left;
      shader->ARB_fragment_coord_conventions_enable =
         state->ARB_fragment_coord_conventions_enable;
      break;

   default:
      /* Nothing to do. */
      break;
   }
}

d1452 1
a1452 1
      new(shader) _mesa_glsl_parse_state(ctx, shader->Stage, shader);
d1482 1
a1482 1
         _mesa_print_ir(stdout, shader->ir, state);
d1489 1
a1489 1
         &ctx->ShaderCompilerOptions[shader->Stage];
d1494 1
a1494 2
      while (do_common_optimization(shader->ir, false, false, options,
                                    ctx->Const.NativeIntegers))
d1507 1
a1508 1
   shader->uses_builtin_functions = state->uses_builtin_functions;
d1510 9
a1518 2
   if (!state->error)
      set_shader_inout_layout(shader, state);
d1548 2
a1549 2
                       const struct gl_shader_compiler_options *options,
                       bool native_integers)
d1565 1
a1565 1
   if (options->OptimizeForAOS && !linked)
a1567 4
   if (linked && options->OptimizeForAOS) {
      progress = do_vectorize(ir) || progress;
   }

d1580 1
a1580 2
   progress = do_cse(ir) || progress;
   progress = do_algebraic(ir, native_integers) || progress;
d1593 1
a1593 1
      progress = unroll_loops(ir, ls, options) || progress;
d1625 1
a1625 1
   _mesa_glsl_release_builtin_functions();
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d34 1
a34 1
#include "util/ralloc.h"
a136 3
   /* ARB_viewport_array */
   this->Const.MaxViewports = ctx->Const.MaxViewports;

a212 2
   this->allow_extension_directive_midshader =
      ctx->Const.AllowGLSLExtensionDirectiveMidShader;
a514 1
   EXT(ARB_derivative_control,         true,  false,     ARB_derivative_control),
a517 1
   EXT(ARB_explicit_uniform_location,  true,  false,     ARB_explicit_uniform_location),
a518 1
   EXT(ARB_fragment_layer_viewport,    true,  false,     ARB_fragment_layer_viewport),
a552 1
   EXT(AMD_vertex_shader_viewport_index, true,  false,   AMD_vertex_shader_viewport_index),
d845 2
a846 1
   foreach_list_typed(ast_node, ast, link, &this->statements) {
d925 2
a926 2
      foreach_list_typed (ast_node, ast, link, &this->expressions) {
	 if (&ast->link != this->expressions.get_head())
d929 1
d961 2
a962 2
      foreach_list_typed (ast_node, ast, link, & this->expressions) {
	 if (&ast->link != this->expressions.get_head())
d965 1
d974 2
a975 2
      foreach_list_typed (ast_node, ast, link, & this->expressions) {
	 if (&ast->link != this->expressions.get_head())
d978 1
d1028 2
a1029 1
   foreach_list_typed(ast_node, ast, link, & this->parameters) {
d1101 1
a1101 1
   else if (invariant)
a1102 2
   else
      printf("precise ");
d1104 2
a1105 2
   foreach_list_typed (ast_node, ast, link, & this->declarations) {
      if (&ast->link != this->declarations.get_head())
d1108 1
a1119 1
   this->precise = false;
d1239 2
a1240 1
   foreach_list_typed(ast_node, ast, link, & this->labels) {
d1255 2
a1256 1
   foreach_list_typed(ast_node, ast, link, & this->stmts) {
d1271 2
a1272 1
   foreach_list_typed(ast_node, ast, link, & this->cases) {
d1342 2
a1343 1
   foreach_list_typed(ast_node, ast, link, &this->declarations) {
a1353 1
      static mtx_t mutex = _MTX_INITIALIZER_NP;
d1355 2
a1356 7
      unsigned count;

      mtx_lock(&mutex);
      count = anon_count++;
      mtx_unlock(&mutex);

      identifier = ralloc_asprintf(this, "#anon_struct_%04x", count);
a1443 3
   if (ctx->Const.GenerateTemporaryNames)
      ir_variable::temporaries_allocate_names = true;

d1454 2
a1455 1
      foreach_list_typed(ast_node, ast, link, &state->translation_unit) {
d1478 1
a1478 1
         &ctx->Const.ShaderCompilerOptions[shader->Stage];
a1487 20

      enum ir_variable_mode other;
      switch (shader->Stage) {
      case MESA_SHADER_VERTEX:
         other = ir_var_shader_in;
         break;
      case MESA_SHADER_FRAGMENT:
         other = ir_var_shader_out;
         break;
      default:
         /* Something invalid to ensure optimize_dead_builtin_uniforms
          * doesn't remove anything other than uniforms or constants.
          */
         other = ir_var_mode_count;
         break;
      }

      optimize_dead_builtin_variables(shader->ir, other);

      validate_ir_tree(shader->ir);
d1493 1
a1493 1
   shader->symbols = new(shader->ir) glsl_symbol_table;
a1505 28
   /* Destroy the symbol table.  Create a new symbol table that contains only
    * the variables and functions that still exist in the IR.  The symbol
    * table will be used later during linking.
    *
    * There must NOT be any freed objects still referenced by the symbol
    * table.  That could cause the linker to dereference freed memory.
    *
    * We don't have to worry about types or interface-types here because those
    * are fly-weights that are looked up by glsl_type.
    */
   foreach_in_list (ir_instruction, ir, shader->ir) {
      switch (ir->ir_type) {
      case ir_type_function:
         shader->symbols->add_function((ir_function *) ir);
         break;
      case ir_type_variable: {
         ir_variable *const var = (ir_variable *) ir;

         if (var->data.mode != ir_var_temporary)
            shader->symbols->add_variable(var);
         break;
      }
      default:
         break;
      }
   }

   delete state->symbols;
a1566 1
   progress = do_minmax_prune(ir) || progress;
d1568 1
a1568 2
   progress = do_rebalance_tree(ir) || progress;
   progress = do_algebraic(ir, native_integers, options) || progress;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d34 1
a34 1
#include "ralloc.h"
d137 3
d216 2
d520 1
d524 1
d526 1
d561 1
d854 1
a854 2
   foreach_list_const(n, &this->statements) {
      ast_node *ast = exec_node_data(ast_node, n, link);
d933 2
a934 2
      foreach_list_const (n, &this->expressions) {
	 if (n != this->expressions.get_head())
a936 1
	 ast_node *ast = exec_node_data(ast_node, n, link);
d968 2
a969 2
      foreach_list_const(n, & this->expressions) {
	 if (n != this->expressions.get_head())
a971 1
	 ast_node *ast = exec_node_data(ast_node, n, link);
d980 2
a981 2
      foreach_list_const(n, & this->expressions) {
	 if (n != this->expressions.get_head())
a983 1
	 ast_node *ast = exec_node_data(ast_node, n, link);
d1033 1
a1033 2
   foreach_list_const(n, & this->parameters) {
      ast_node *ast = exec_node_data(ast_node, n, link);
d1105 2
d1108 1
a1108 1
      printf("invariant ");
d1110 2
a1111 2
   foreach_list_const (ptr, & this->declarations) {
      if (ptr != this->declarations.get_head())
a1113 1
      ast_node *ast = exec_node_data(ast_node, ptr, link);
d1125 1
d1245 1
a1245 2
   foreach_list_const(n, & this->labels) {
      ast_node *ast = exec_node_data(ast_node, n, link);
d1260 1
a1260 2
   foreach_list_const(n, & this->stmts) {
      ast_node *ast = exec_node_data(ast_node, n, link);
d1275 1
a1275 2
   foreach_list_const(n, & this->cases) {
      ast_node *ast = exec_node_data(ast_node, n, link);
d1345 1
a1345 2
   foreach_list_const(n, &this->declarations) {
      ast_node *ast = exec_node_data(ast_node, n, link);
d1356 1
d1358 7
a1364 2
      identifier = ralloc_asprintf(this, "#anon_struct_%04x", anon_count);
      anon_count++;
d1452 3
d1465 1
a1465 2
      foreach_list_const(n, &state->translation_unit) {
         ast_node *ast = exec_node_data(ast_node, n, link);
d1488 1
a1488 1
         &ctx->ShaderCompilerOptions[shader->Stage];
d1498 20
d1523 1
a1523 1
   shader->symbols = state->symbols;
d1536 28
d1625 1
d1627 2
a1628 1
   progress = do_algebraic(ir, native_integers) || progress;
@


