head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.10
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.8
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.6
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2015.12.23.05.17.44;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.30;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.10.25;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.47.32;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2008, 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * \file list.h
 * \brief Doubly-linked list abstract container type.
 *
 * Each doubly-linked list has a sentinel head and tail node.  These nodes
 * contain no data.  The head sentinel can be identified by its \c prev
 * pointer being \c NULL.  The tail sentinel can be identified by its
 * \c next pointer being \c NULL.
 *
 * A list is empty if either the head sentinel's \c next pointer points to the
 * tail sentinel or the tail sentinel's \c prev poiner points to the head
 * sentinel.
 *
 * Instead of tracking two separate \c node structures and a \c list structure
 * that points to them, the sentinel nodes are in a single structure.  Noting
 * that each sentinel node always has one \c NULL pointer, the \c NULL
 * pointers occupy the same memory location.  In the \c list structure
 * contains a the following:
 *
 *   - A \c head pointer that represents the \c next pointer of the
 *     head sentinel node.
 *   - A \c tail pointer that represents the \c prev pointer of the head
 *     sentinel node and the \c next pointer of the tail sentinel node.  This
 *     pointer is \b always \c NULL.
 *   - A \c tail_prev pointer that represents the \c prev pointer of the
 *     tail sentinel node.
 *
 * Therefore, if \c head->next is \c NULL or \c tail_prev->prev is \c NULL,
 * the list is empty.
 *
 * To anyone familiar with "exec lists" on the Amiga, this structure should
 * be immediately recognizable.  See the following link for the original Amiga
 * operating system documentation on the subject.
 *
 * http://www.natami.net/dev/Libraries_Manual_guide/node02D7.html
 *
 * \author Ian Romanick <ian.d.romanick@@intel.com>
 */

#pragma once
#ifndef LIST_CONTAINER_H
#define LIST_CONTAINER_H

#ifndef __cplusplus
#include <stddef.h>
#endif
#include <assert.h>

#include "ralloc.h"

struct exec_node {
   struct exec_node *next;
   struct exec_node *prev;

#ifdef __cplusplus
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
   {
      void *node;

      node = ralloc_size(ctx, size);
      assert(node != NULL);

      return node;
   }

   /* If the user *does* call delete, that's OK, we will just
    * ralloc_free in that case. */
   static void operator delete(void *node)
   {
      ralloc_free(node);
   }

   exec_node() : next(NULL), prev(NULL)
   {
      /* empty */
   }

   const exec_node *get_next() const
   {
      return next;
   }

   exec_node *get_next()
   {
      return next;
   }

   const exec_node *get_prev() const
   {
      return prev;
   }

   exec_node *get_prev()
   {
      return prev;
   }

   void remove()
   {
      next->prev = prev;
      prev->next = next;
      next = NULL;
      prev = NULL;
   }

   /**
    * Link a node with itself
    *
    * This creates a sort of degenerate list that is occasionally useful.
    */
   void self_link()
   {
      next = this;
      prev = this;
   }

   /**
    * Insert a node in the list after the current node
    */
   void insert_after(exec_node *after)
   {
      after->next = this->next;
      after->prev = this;

      this->next->prev = after;
      this->next = after;
   }
   /**
    * Insert a node in the list before the current node
    */
   void insert_before(exec_node *before)
   {
      before->next = this;
      before->prev = this->prev;

      this->prev->next = before;
      this->prev = before;
   }

   /**
    * Insert another list in the list before the current node
    */
   void insert_before(struct exec_list *before);

   /**
    * Replace the current node with the given node.
    */
   void replace_with(exec_node *replacement)
   {
      replacement->prev = this->prev;
      replacement->next = this->next;

      this->prev->next = replacement;
      this->next->prev = replacement;
   }

   /**
    * Is this the sentinel at the tail of the list?
    */
   bool is_tail_sentinel() const
   {
      return this->next == NULL;
   }

   /**
    * Is this the sentinel at the head of the list?
    */
   bool is_head_sentinel() const
   {
      return this->prev == NULL;
   }
#endif
};


#ifdef __cplusplus
/* This macro will not work correctly if `t' uses virtual inheritance.  If you
 * are using virtual inheritance, you deserve a slow and painful death.  Enjoy!
 */
#define exec_list_offsetof(t, f, p) \
   (((char *) &((t *) p)->f) - ((char *) p))
#else
#define exec_list_offsetof(t, f, p) offsetof(t, f)
#endif

/**
 * Get a pointer to the structure containing an exec_node
 *
 * Given a pointer to an \c exec_node embedded in a structure, get a pointer to
 * the containing structure.
 *
 * \param type  Base type of the structure containing the node
 * \param node  Pointer to the \c exec_node
 * \param field Name of the field in \c type that is the embedded \c exec_node
 */
#define exec_node_data(type, node, field) \
   ((type *) (((char *) node) - exec_list_offsetof(type, field, node)))

#ifdef __cplusplus
struct exec_node;

class iterator {
public:
   void next()
   {
   }

   void *get()
   {
      return NULL;
   }

   bool has_next() const
   {
      return false;
   }
};

class exec_list_iterator : public iterator {
public:
   exec_list_iterator(exec_node *n) : node(n), _next(n->next)
   {
      /* empty */
   }

   void next()
   {
      node = _next;
      _next = node->next;
   }

   void remove()
   {
      node->remove();
   }

   exec_node *get()
   {
      return node;
   }

   bool has_next() const
   {
      return _next != NULL;
   }

private:
   exec_node *node;
   exec_node *_next;
};

#define foreach_iter(iter_type, iter, container) \
   for (iter_type iter = (container) . iterator(); iter.has_next(); iter.next())
#endif


struct exec_list {
   struct exec_node *head;
   struct exec_node *tail;
   struct exec_node *tail_pred;

#ifdef __cplusplus
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
   {
      void *node;

      node = ralloc_size(ctx, size);
      assert(node != NULL);

      return node;
   }

   /* If the user *does* call delete, that's OK, we will just
    * ralloc_free in that case. */
   static void operator delete(void *node)
   {
      ralloc_free(node);
   }

   exec_list()
   {
      make_empty();
   }

   void make_empty()
   {
      head = (exec_node *) & tail;
      tail = NULL;
      tail_pred = (exec_node *) & head;
   }

   bool is_empty() const
   {
      /* There are three ways to test whether a list is empty or not.
       *
       * - Check to see if the \c head points to the \c tail.
       * - Check to see if the \c tail_pred points to the \c head.
       * - Check to see if the \c head is the sentinel node by test whether its
       *   \c next pointer is \c NULL.
       *
       * The first two methods tend to generate better code on modern systems
       * because they save a pointer dereference.
       */
      return head == (exec_node *) &tail;
   }

   const exec_node *get_head() const
   {
      return !is_empty() ? head : NULL;
   }

   exec_node *get_head()
   {
      return !is_empty() ? head : NULL;
   }

   const exec_node *get_tail() const
   {
      return !is_empty() ? tail_pred : NULL;
   }

   exec_node *get_tail()
   {
      return !is_empty() ? tail_pred : NULL;
   }

   void push_head(exec_node *n)
   {
      n->next = head;
      n->prev = (exec_node *) &head;

      n->next->prev = n;
      head = n;
   }

   void push_tail(exec_node *n)
   {
      n->next = (exec_node *) &tail;
      n->prev = tail_pred;

      n->prev->next = n;
      tail_pred = n;
   }

   void push_degenerate_list_at_head(exec_node *n)
   {
      assert(n->prev->next == n);

      n->prev->next = head;
      head->prev = n->prev;
      n->prev = (exec_node *) &head;
      head = n;
   }

   /**
    * Remove the first node from a list and return it
    *
    * \return
    * The first node in the list or \c NULL if the list is empty.
    *
    * \sa exec_list::get_head
    */
   exec_node *pop_head()
   {
      exec_node *const n = this->get_head();
      if (n != NULL)
	 n->remove();

      return n;
   }

   /**
    * Move all of the nodes from this list to the target list
    */
   void move_nodes_to(exec_list *target)
   {
      if (is_empty()) {
	 target->make_empty();
      } else {
	 target->head = head;
	 target->tail = NULL;
	 target->tail_pred = tail_pred;

	 target->head->prev = (exec_node *) &target->head;
	 target->tail_pred->next = (exec_node *) &target->tail;

	 make_empty();
      }
   }

   /**
    * Append all nodes from the source list to the target list
    */
   void
   append_list(exec_list *source)
   {
      if (source->is_empty())
	 return;

      /* Link the first node of the source with the last node of the target list.
       */
      this->tail_pred->next = source->head;
      source->head->prev = this->tail_pred;

      /* Make the tail of the source list be the tail of the target list.
       */
      this->tail_pred = source->tail_pred;
      this->tail_pred->next = (exec_node *) &this->tail;

      /* Make the source list empty for good measure.
       */
      source->make_empty();
   }

   exec_list_iterator iterator()
   {
      return exec_list_iterator(head);
   }

   exec_list_iterator iterator() const
   {
      return exec_list_iterator((exec_node *) head);
   }
#endif
};


#ifdef __cplusplus
inline void exec_node::insert_before(exec_list *before)
{
   if (before->is_empty())
      return;

   before->tail_pred->next = this;
   before->head->prev = this->prev;

   this->prev->next = before->head;
   this->prev = before->tail_pred;

   before->make_empty();
}
#endif

/**
 * This version is safe even if the current node is removed.
 */ 
#define foreach_list_safe(__node, __list)			     \
   for (exec_node * __node = (__list)->head, * __next = __node->next \
	; __next != NULL					     \
	; __node = __next, __next = __next->next)

#define foreach_list(__node, __list)			\
   for (exec_node * __node = (__list)->head		\
	; (__node)->next != NULL 			\
	; (__node) = (__node)->next)

#define foreach_list_const(__node, __list)		\
   for (const exec_node * __node = (__list)->head	\
	; (__node)->next != NULL 			\
	; (__node) = (__node)->next)

#define foreach_list_typed(__type, __node, __field, __list)		\
   for (__type * __node =						\
	   exec_node_data(__type, (__list)->head, __field);		\
	(__node)->__field.next != NULL; 				\
	(__node) = exec_node_data(__type, (__node)->__field.next, __field))

#define foreach_list_typed_const(__type, __node, __field, __list)	\
   for (const __type * __node =						\
	   exec_node_data(__type, (__list)->head, __field);		\
	(__node)->__field.next != NULL; 				\
	(__node) = exec_node_data(__type, (__node)->__field.next, __field))

#endif /* LIST_CONTAINER_H */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d79 18
a96 1
   DECLARE_RALLOC_CXX_OPERATORS(exec_node)
d226 53
d281 1
d288 18
a305 1
   DECLARE_RALLOC_CXX_OPERATORS(exec_list)
d441 10
a482 16

/**
 * Iterate through two lists at once.  Stops at the end of the shorter list.
 *
 * This is safe against either current node being removed or replaced.
 */
#define foreach_two_lists(__node1, __list1, __node2, __list2) \
   for (exec_node * __node1 = (__list1)->head,                \
                  * __node2 = (__list2)->head,                \
                  * __next1 = __node1->next,                  \
                  * __next2 = __node2->next                   \
	; __next1 != NULL && __next2 != NULL                  \
	; __node1 = __next1,                                  \
          __node2 = __next2,                                  \
          __next1 = __next1->next,                            \
          __next2 = __next2->next)
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d72 1
a72 1
#include "util/ralloc.h"
d86 4
a89 2
   const exec_node *get_next() const;
   exec_node *get_next();
d91 4
a94 2
   const exec_node *get_prev() const;
   exec_node *get_prev();
d96 17
a112 1
   void remove();
d119 5
a123 1
   void self_link();
d128 8
a135 1
   void insert_after(exec_node *after);
d139 8
a146 1
   void insert_before(exec_node *before);
d156 8
a163 1
   void replace_with(exec_node *replacement);
d168 4
a171 1
   bool is_tail_sentinel() const;
d176 4
a179 1
   bool is_head_sentinel() const;
a182 145
static inline void
exec_node_init(struct exec_node *n)
{
   n->next = NULL;
   n->prev = NULL;
}

static inline const struct exec_node *
exec_node_get_next_const(const struct exec_node *n)
{
   return n->next;
}

static inline struct exec_node *
exec_node_get_next(struct exec_node *n)
{
   return n->next;
}

static inline const struct exec_node *
exec_node_get_prev_const(const struct exec_node *n)
{
   return n->prev;
}

static inline struct exec_node *
exec_node_get_prev(struct exec_node *n)
{
   return n->prev;
}

static inline void
exec_node_remove(struct exec_node *n)
{
   n->next->prev = n->prev;
   n->prev->next = n->next;
   n->next = NULL;
   n->prev = NULL;
}

static inline void
exec_node_self_link(struct exec_node *n)
{
   n->next = n;
   n->prev = n;
}

static inline void
exec_node_insert_after(struct exec_node *n, struct exec_node *after)
{
   after->next = n->next;
   after->prev = n;

   n->next->prev = after;
   n->next = after;
}

static inline void
exec_node_insert_node_before(struct exec_node *n, struct exec_node *before)
{
   before->next = n;
   before->prev = n->prev;

   n->prev->next = before;
   n->prev = before;
}

static inline void
exec_node_replace_with(struct exec_node *n, struct exec_node *replacement)
{
   replacement->prev = n->prev;
   replacement->next = n->next;

   n->prev->next = replacement;
   n->next->prev = replacement;
}

static inline bool
exec_node_is_tail_sentinel(const struct exec_node *n)
{
   return n->next == NULL;
}

static inline bool
exec_node_is_head_sentinel(const struct exec_node *n)
{
   return n->prev == NULL;
}

#ifdef __cplusplus
inline const exec_node *exec_node::get_next() const
{
   return exec_node_get_next_const(this);
}

inline exec_node *exec_node::get_next()
{
   return exec_node_get_next(this);
}

inline const exec_node *exec_node::get_prev() const
{
   return exec_node_get_prev_const(this);
}

inline exec_node *exec_node::get_prev()
{
   return exec_node_get_prev(this);
}

inline void exec_node::remove()
{
   exec_node_remove(this);
}

inline void exec_node::self_link()
{
   exec_node_self_link(this);
}

inline void exec_node::insert_after(exec_node *after)
{
   exec_node_insert_after(this, after);
}

inline void exec_node::insert_before(exec_node *before)
{
   exec_node_insert_node_before(this, before);
}

inline void exec_node::replace_with(exec_node *replacement)
{
   exec_node_replace_with(this, replacement);
}

inline bool exec_node::is_tail_sentinel() const
{
   return exec_node_is_tail_sentinel(this);
}

inline bool exec_node::is_head_sentinel() const
{
   return exec_node_is_head_sentinel(this);
}
#endif
d224 46
a269 1
   void make_empty();
d271 3
a273 1
   bool is_empty() const;
d275 4
a278 2
   const exec_node *get_head() const;
   exec_node *get_head();
d280 3
a282 2
   const exec_node *get_tail() const;
   exec_node *get_tail();
d284 3
a286 1
   unsigned length() const;
d288 5
a292 3
   void push_head(exec_node *n);
   void push_tail(exec_node *n);
   void push_degenerate_list_at_head(exec_node *n);
d302 8
a309 1
   exec_node *pop_head();
d314 15
a328 1
   void move_nodes_to(exec_list *target);
d331 1
a331 1
    * Append all nodes from the source list to the end of the target list
d333 5
a337 1
   void append_list(exec_list *source);
d339 14
a352 5
   /**
    * Prepend all nodes from the source list to the beginning of the target
    * list
    */
   void prepend_list(exec_list *source);
a355 23
static inline void
exec_list_make_empty(struct exec_list *list)
{
   list->head = (struct exec_node *) & list->tail;
   list->tail = NULL;
   list->tail_pred = (struct exec_node *) & list->head;
}

static inline bool
exec_list_is_empty(const struct exec_list *list)
{
   /* There are three ways to test whether a list is empty or not.
    *
    * - Check to see if the \c head points to the \c tail.
    * - Check to see if the \c tail_pred points to the \c head.
    * - Check to see if the \c head is the sentinel node by test whether its
    *   \c next pointer is \c NULL.
    *
    * The first two methods tend to generate better code on modern systems
    * because they save a pointer dereference.
    */
   return list->head == (struct exec_node *) &list->tail;
}
d357 2
a358 125
static inline const struct exec_node *
exec_list_get_head_const(const struct exec_list *list)
{
   return !exec_list_is_empty(list) ? list->head : NULL;
}

static inline struct exec_node *
exec_list_get_head(struct exec_list *list)
{
   return !exec_list_is_empty(list) ? list->head : NULL;
}

static inline const struct exec_node *
exec_list_get_tail_const(const struct exec_list *list)
{
   return !exec_list_is_empty(list) ? list->tail_pred : NULL;
}

static inline struct exec_node *
exec_list_get_tail(struct exec_list *list)
{
   return !exec_list_is_empty(list) ? list->tail_pred : NULL;
}

static inline unsigned
exec_list_length(const struct exec_list *list)
{
   unsigned size = 0;
   struct exec_node *node;

   for (node = list->head; node->next != NULL; node = node->next) {
      size++;
   }

   return size;
}

static inline void
exec_list_push_head(struct exec_list *list, struct exec_node *n)
{
   n->next = list->head;
   n->prev = (struct exec_node *) &list->head;

   n->next->prev = n;
   list->head = n;
}

static inline void
exec_list_push_tail(struct exec_list *list, struct exec_node *n)
{
   n->next = (struct exec_node *) &list->tail;
   n->prev = list->tail_pred;

   n->prev->next = n;
   list->tail_pred = n;
}

static inline void
exec_list_push_degenerate_list_at_head(struct exec_list *list, struct exec_node *n)
{
   assert(n->prev->next == n);

   n->prev->next = list->head;
   list->head->prev = n->prev;
   n->prev = (struct exec_node *) &list->head;
   list->head = n;
}

static inline struct exec_node *
exec_list_pop_head(struct exec_list *list)
{
   struct exec_node *const n = exec_list_get_head(list);
   if (n != NULL)
      exec_node_remove(n);

   return n;
}

static inline void
exec_list_move_nodes_to(struct exec_list *list, struct exec_list *target)
{
   if (exec_list_is_empty(list)) {
      exec_list_make_empty(target);
   } else {
      target->head = list->head;
      target->tail = NULL;
      target->tail_pred = list->tail_pred;

      target->head->prev = (struct exec_node *) &target->head;
      target->tail_pred->next = (struct exec_node *) &target->tail;

      exec_list_make_empty(list);
   }
}

static inline void
exec_list_append(struct exec_list *list, struct exec_list *source)
{
   if (exec_list_is_empty(source))
      return;

   /* Link the first node of the source with the last node of the target list.
    */
   list->tail_pred->next = source->head;
   source->head->prev = list->tail_pred;

   /* Make the tail of the source list be the tail of the target list.
    */
   list->tail_pred = source->tail_pred;
   list->tail_pred->next = (struct exec_node *) &list->tail;

   /* Make the source list empty for good measure.
    */
   exec_list_make_empty(source);
}

static inline void
exec_list_prepend(struct exec_list *list, struct exec_list *source)
{
   exec_list_append(source, list);
   exec_list_move_nodes_to(source, list);
}

static inline void
exec_node_insert_list_before(struct exec_node *n, struct exec_list *before)
d360 1
a360 1
   if (exec_list_is_empty(before))
d363 2
a364 95
   before->tail_pred->next = n;
   before->head->prev = n->prev;

   n->prev->next = before->head;
   n->prev = before->tail_pred;

   exec_list_make_empty(before);
}

static inline void
exec_list_validate(const struct exec_list *list)
{
   const struct exec_node *node;

   assert(list->head->prev == (const struct exec_node *) &list->head);
   assert(list->tail == NULL);
   assert(list->tail_pred->next == (const struct exec_node *) &list->tail);

   /* We could try to use one of the interators below for this but they all
    * either require C++ or assume the exec_node is embedded in a structure
    * which is not the case for this function.
    */
   for (node = exec_list_get_head_const(list);
        !exec_node_is_tail_sentinel(node);
        node = exec_node_get_next_const(node)) {
      assert(node->next->prev == node);
      assert(node->prev->next == node);
   }
}

#ifdef __cplusplus
inline void exec_list::make_empty()
{
   exec_list_make_empty(this);
}

inline bool exec_list::is_empty() const
{
   return exec_list_is_empty(this);
}

inline const exec_node *exec_list::get_head() const
{
   return exec_list_get_head_const(this);
}

inline exec_node *exec_list::get_head()
{
   return exec_list_get_head(this);
}

inline const exec_node *exec_list::get_tail() const
{
   return exec_list_get_tail_const(this);
}

inline exec_node *exec_list::get_tail()
{
   return exec_list_get_tail(this);
}

inline unsigned exec_list::length() const
{
   return exec_list_length(this);
}

inline void exec_list::push_head(exec_node *n)
{
   exec_list_push_head(this, n);
}

inline void exec_list::push_tail(exec_node *n)
{
   exec_list_push_tail(this, n);
}

inline void exec_list::push_degenerate_list_at_head(exec_node *n)
{
   exec_list_push_degenerate_list_at_head(this, n);
}

inline exec_node *exec_list::pop_head()
{
   return exec_list_pop_head(this);
}

inline void exec_list::move_nodes_to(exec_list *target)
{
   exec_list_move_nodes_to(this, target);
}

inline void exec_list::append_list(exec_list *source)
{
   exec_list_append(this, source);
}
d366 2
a367 4
inline void exec_list::prepend_list(exec_list *source)
{
   exec_list_prepend(this, source);
}
d369 1
a369 3
inline void exec_node::insert_before(exec_list *before)
{
   exec_node_insert_list_before(this, before);
a372 10
#define foreach_in_list(__type, __inst, __list)      \
   for (__type *(__inst) = (__type *)(__list)->head; \
        !(__inst)->is_tail_sentinel();               \
        (__inst) = (__type *)(__inst)->next)

#define foreach_in_list_reverse(__type, __inst, __list)   \
   for (__type *(__inst) = (__type *)(__list)->tail_pred; \
        !(__inst)->is_head_sentinel();                    \
        (__inst) = (__type *)(__inst)->prev)

d376 10
a385 11
#define foreach_in_list_safe(__type, __node, __list) \
   for (__type *__node = (__type *)(__list)->head,   \
               *__next = (__type *)__node->next;     \
        __next != NULL;                              \
        __node = __next, __next = (__type *)__next->next)

#define foreach_in_list_use_after(__type, __inst, __list) \
   __type *(__inst);                                      \
   for ((__inst) = (__type *)(__list)->head;              \
        !(__inst)->is_tail_sentinel();                    \
        (__inst) = (__type *)(__inst)->next)
d392 4
a395 4
   for (struct exec_node * __node1 = (__list1)->head,         \
                         * __node2 = (__list2)->head,         \
                         * __next1 = __node1->next,           \
                         * __next2 = __node2->next            \
d402 5
d413 5
a417 8
#define foreach_list_typed_safe(__type, __node, __field, __list)           \
   for (__type * __node =                                                  \
           exec_node_data(__type, (__list)->head, __field),                \
               * __next =                                                  \
           exec_node_data(__type, (__node)->__field.next, __field);        \
        __next != NULL;                                                    \
        __node = __next, __next =                                          \
           exec_node_data(__type, (__next)->__field.next, __field))
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d72 1
a72 1
#include "ralloc.h"
d86 2
a87 4
   const exec_node *get_next() const
   {
      return next;
   }
d89 2
a90 4
   exec_node *get_next()
   {
      return next;
   }
d92 1
a92 17
   const exec_node *get_prev() const
   {
      return prev;
   }

   exec_node *get_prev()
   {
      return prev;
   }

   void remove()
   {
      next->prev = prev;
      prev->next = next;
      next = NULL;
      prev = NULL;
   }
d99 1
a99 5
   void self_link()
   {
      next = this;
      prev = this;
   }
d104 1
a104 8
   void insert_after(exec_node *after)
   {
      after->next = this->next;
      after->prev = this;

      this->next->prev = after;
      this->next = after;
   }
d108 1
a108 8
   void insert_before(exec_node *before)
   {
      before->next = this;
      before->prev = this->prev;

      this->prev->next = before;
      this->prev = before;
   }
d118 1
a118 8
   void replace_with(exec_node *replacement)
   {
      replacement->prev = this->prev;
      replacement->next = this->next;

      this->prev->next = replacement;
      this->next->prev = replacement;
   }
d123 1
a123 4
   bool is_tail_sentinel() const
   {
      return this->next == NULL;
   }
d128 1
a128 4
   bool is_head_sentinel() const
   {
      return this->prev == NULL;
   }
d132 145
d318 1
a318 46
   void make_empty()
   {
      head = (exec_node *) & tail;
      tail = NULL;
      tail_pred = (exec_node *) & head;
   }

   bool is_empty() const
   {
      /* There are three ways to test whether a list is empty or not.
       *
       * - Check to see if the \c head points to the \c tail.
       * - Check to see if the \c tail_pred points to the \c head.
       * - Check to see if the \c head is the sentinel node by test whether its
       *   \c next pointer is \c NULL.
       *
       * The first two methods tend to generate better code on modern systems
       * because they save a pointer dereference.
       */
      return head == (exec_node *) &tail;
   }

   const exec_node *get_head() const
   {
      return !is_empty() ? head : NULL;
   }

   exec_node *get_head()
   {
      return !is_empty() ? head : NULL;
   }

   const exec_node *get_tail() const
   {
      return !is_empty() ? tail_pred : NULL;
   }

   exec_node *get_tail()
   {
      return !is_empty() ? tail_pred : NULL;
   }

   void push_head(exec_node *n)
   {
      n->next = head;
      n->prev = (exec_node *) &head;
d320 1
a320 3
      n->next->prev = n;
      head = n;
   }
d322 2
a323 4
   void push_tail(exec_node *n)
   {
      n->next = (exec_node *) &tail;
      n->prev = tail_pred;
d325 2
a326 3
      n->prev->next = n;
      tail_pred = n;
   }
d328 1
a328 3
   void push_degenerate_list_at_head(exec_node *n)
   {
      assert(n->prev->next == n);
d330 3
a332 5
      n->prev->next = head;
      head->prev = n->prev;
      n->prev = (exec_node *) &head;
      head = n;
   }
d342 6
a347 5
   exec_node *pop_head()
   {
      exec_node *const n = this->get_head();
      if (n != NULL)
	 n->remove();
d349 4
a352 2
      return n;
   }
d355 27
a381 1
    * Move all of the nodes from this list to the target list
d383 90
a472 8
   void move_nodes_to(exec_list *target)
   {
      if (is_empty()) {
	 target->make_empty();
      } else {
	 target->head = head;
	 target->tail = NULL;
	 target->tail_pred = tail_pred;
d474 2
a475 2
	 target->head->prev = (exec_node *) &target->head;
	 target->tail_pred->next = (exec_node *) &target->tail;
d477 1
a477 2
	 make_empty();
      }
d479 7
d487 11
a497 2
   /**
    * Append all nodes from the source list to the target list
d499 29
a527 5
   void
   append_list(exec_list *source)
   {
      if (source->is_empty())
	 return;
d529 13
a541 13
      /* Link the first node of the source with the last node of the target list.
       */
      this->tail_pred->next = source->head;
      source->head->prev = this->tail_pred;

      /* Make the tail of the source list be the tail of the target list.
       */
      this->tail_pred = source->tail_pred;
      this->tail_pred->next = (exec_node *) &this->tail;

      /* Make the source list empty for good measure.
       */
      source->make_empty();
d543 52
a594 2
#endif
};
d596 4
d601 1
a601 2
#ifdef __cplusplus
inline void exec_node::insert_before(exec_list *before)
d603 2
a604 2
   if (before->is_empty())
      return;
d606 4
a609 2
   before->tail_pred->next = this;
   before->head->prev = this->prev;
d611 4
a614 2
   this->prev->next = before->head;
   this->prev = before->tail_pred;
d616 3
a618 1
   before->make_empty();
d622 10
d635 11
a645 10
#define foreach_list_safe(__node, __list)			     \
   for (exec_node * __node = (__list)->head, * __next = __node->next \
	; __next != NULL					     \
	; __node = __next, __next = __next->next)

#define foreach_list(__node, __list)			\
   for (exec_node * __node = (__list)->head		\
	; (__node)->next != NULL 			\
	; (__node) = (__node)->next)

d652 4
a655 4
   for (exec_node * __node1 = (__list1)->head,                \
                  * __node2 = (__list2)->head,                \
                  * __next1 = __node1->next,                  \
                  * __next2 = __node2->next                   \
a661 5
#define foreach_list_const(__node, __list)		\
   for (const exec_node * __node = (__list)->head	\
	; (__node)->next != NULL 			\
	; (__node) = (__node)->next)

d668 8
a675 5
#define foreach_list_typed_const(__type, __node, __field, __list)	\
   for (const __type * __node =						\
	   exec_node_data(__type, (__list)->head, __field);		\
	(__node)->__field.next != NULL; 				\
	(__node) = exec_node_data(__type, (__node)->__field.next, __field))
@


