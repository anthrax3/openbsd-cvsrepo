head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@# @;


1.7
date	2015.12.23.05.17.43;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.57;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.10.05.09.53.55;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.05.14.02.25;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.10;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.14.12;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.10.05.09.23.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.27;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.18;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.25;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@%{
/*
 * Copyright Â© 2008, 2009 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "ast.h"
#include "glsl_parser_extras.h"
#include "glsl_types.h"
#include "main/context.h"

#undef yyerror

static void yyerror(YYLTYPE *loc, _mesa_glsl_parse_state *st, const char *msg)
{
   _mesa_glsl_error(loc, st, "%s", msg);
}

static int
_mesa_glsl_lex(YYSTYPE *val, YYLTYPE *loc, _mesa_glsl_parse_state *state)
{
   return _mesa_glsl_lexer_lex(val, loc, state->scanner);
}

static bool match_layout_qualifier(const char *s1, const char *s2,
                                   _mesa_glsl_parse_state *state)
{
   /* From the GLSL 1.50 spec, section 4.3.8 (Layout Qualifiers):
    *
    *     "The tokens in any layout-qualifier-id-list ... are not case
    *     sensitive, unless explicitly noted otherwise."
    *
    * The text "unless explicitly noted otherwise" appears to be
    * vacuous--no desktop GLSL spec (up through GLSL 4.40) notes
    * otherwise.
    *
    * However, the GLSL ES 3.00 spec says, in section 4.3.8 (Layout
    * Qualifiers):
    *
    *     "As for other identifiers, they are case sensitive."
    *
    * So we need to do a case-sensitive or a case-insensitive match,
    * depending on whether we are compiling for GLSL ES.
    */
   if (state->es_shader)
      return strcmp(s1, s2);
   else
      return strcasecmp(s1, s2);
}
%}

%expect 0

%pure-parser
%error-verbose

%locations
%initial-action {
   @@$.first_line = 1;
   @@$.first_column = 1;
   @@$.last_line = 1;
   @@$.last_column = 1;
   @@$.source = 0;
}

%lex-param   {struct _mesa_glsl_parse_state *state}
%parse-param {struct _mesa_glsl_parse_state *state}

%union {
   int n;
   float real;
   const char *identifier;

   struct ast_type_qualifier type_qualifier;

   ast_node *node;
   ast_type_specifier *type_specifier;
   ast_array_specifier *array_specifier;
   ast_fully_specified_type *fully_specified_type;
   ast_function *function;
   ast_parameter_declarator *parameter_declarator;
   ast_function_definition *function_definition;
   ast_compound_statement *compound_statement;
   ast_expression *expression;
   ast_declarator_list *declarator_list;
   ast_struct_specifier *struct_specifier;
   ast_declaration *declaration;
   ast_switch_body *switch_body;
   ast_case_label *case_label;
   ast_case_label_list *case_label_list;
   ast_case_statement *case_statement;
   ast_case_statement_list *case_statement_list;
   ast_interface_block *interface_block;

   struct {
      ast_node *cond;
      ast_expression *rest;
   } for_rest_statement;

   struct {
      ast_node *then_statement;
      ast_node *else_statement;
   } selection_rest_statement;
}

%token ATTRIBUTE CONST_TOK BOOL_TOK FLOAT_TOK INT_TOK UINT_TOK
%token BREAK CONTINUE DO ELSE FOR IF DISCARD RETURN SWITCH CASE DEFAULT
%token BVEC2 BVEC3 BVEC4 IVEC2 IVEC3 IVEC4 UVEC2 UVEC3 UVEC4 VEC2 VEC3 VEC4
%token CENTROID IN_TOK OUT_TOK INOUT_TOK UNIFORM VARYING
%token NOPERSPECTIVE FLAT SMOOTH
%token MAT2X2 MAT2X3 MAT2X4
%token MAT3X2 MAT3X3 MAT3X4
%token MAT4X2 MAT4X3 MAT4X4
%token SAMPLER1D SAMPLER2D SAMPLER3D SAMPLERCUBE SAMPLER1DSHADOW SAMPLER2DSHADOW
%token SAMPLERCUBESHADOW SAMPLER1DARRAY SAMPLER2DARRAY SAMPLER1DARRAYSHADOW
%token SAMPLER2DARRAYSHADOW SAMPLERCUBEARRAY SAMPLERCUBEARRAYSHADOW
%token ISAMPLER1D ISAMPLER2D ISAMPLER3D ISAMPLERCUBE
%token ISAMPLER1DARRAY ISAMPLER2DARRAY ISAMPLERCUBEARRAY
%token USAMPLER1D USAMPLER2D USAMPLER3D USAMPLERCUBE USAMPLER1DARRAY
%token USAMPLER2DARRAY USAMPLERCUBEARRAY
%token SAMPLER2DRECT ISAMPLER2DRECT USAMPLER2DRECT SAMPLER2DRECTSHADOW
%token SAMPLERBUFFER ISAMPLERBUFFER USAMPLERBUFFER
%token SAMPLER2DMS ISAMPLER2DMS USAMPLER2DMS
%token SAMPLER2DMSARRAY ISAMPLER2DMSARRAY USAMPLER2DMSARRAY
%token SAMPLEREXTERNALOES
%token IMAGE1D IMAGE2D IMAGE3D IMAGE2DRECT IMAGECUBE IMAGEBUFFER
%token IMAGE1DARRAY IMAGE2DARRAY IMAGECUBEARRAY IMAGE2DMS IMAGE2DMSARRAY
%token IIMAGE1D IIMAGE2D IIMAGE3D IIMAGE2DRECT IIMAGECUBE IIMAGEBUFFER
%token IIMAGE1DARRAY IIMAGE2DARRAY IIMAGECUBEARRAY IIMAGE2DMS IIMAGE2DMSARRAY
%token UIMAGE1D UIMAGE2D UIMAGE3D UIMAGE2DRECT UIMAGECUBE UIMAGEBUFFER
%token UIMAGE1DARRAY UIMAGE2DARRAY UIMAGECUBEARRAY UIMAGE2DMS UIMAGE2DMSARRAY
%token IMAGE1DSHADOW IMAGE2DSHADOW IMAGE1DARRAYSHADOW IMAGE2DARRAYSHADOW
%token COHERENT VOLATILE RESTRICT READONLY WRITEONLY
%token ATOMIC_UINT
%token STRUCT VOID_TOK WHILE
%token <identifier> IDENTIFIER TYPE_IDENTIFIER NEW_IDENTIFIER
%type <identifier> any_identifier
%type <interface_block> instance_name_opt
%token <real> FLOATCONSTANT
%token <n> INTCONSTANT UINTCONSTANT BOOLCONSTANT
%token <identifier> FIELD_SELECTION
%token LEFT_OP RIGHT_OP
%token INC_OP DEC_OP LE_OP GE_OP EQ_OP NE_OP
%token AND_OP OR_OP XOR_OP MUL_ASSIGN DIV_ASSIGN ADD_ASSIGN
%token MOD_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN XOR_ASSIGN OR_ASSIGN
%token SUB_ASSIGN
%token INVARIANT
%token LOWP MEDIUMP HIGHP SUPERP PRECISION

%token VERSION_TOK EXTENSION LINE COLON EOL INTERFACE OUTPUT
%token PRAGMA_DEBUG_ON PRAGMA_DEBUG_OFF
%token PRAGMA_OPTIMIZE_ON PRAGMA_OPTIMIZE_OFF
%token PRAGMA_INVARIANT_ALL
%token LAYOUT_TOK

   /* Reserved words that are not actually used in the grammar.
    */
%token ASM CLASS UNION ENUM TYPEDEF TEMPLATE THIS PACKED_TOK GOTO
%token INLINE_TOK NOINLINE PUBLIC_TOK STATIC EXTERN EXTERNAL
%token LONG_TOK SHORT_TOK DOUBLE_TOK HALF FIXED_TOK UNSIGNED INPUT_TOK OUPTUT
%token HVEC2 HVEC3 HVEC4 DVEC2 DVEC3 DVEC4 FVEC2 FVEC3 FVEC4
%token SAMPLER3DRECT
%token SIZEOF CAST NAMESPACE USING
%token RESOURCE PATCH SAMPLE
%token SUBROUTINE

%token ERROR_TOK

%token COMMON PARTITION ACTIVE FILTER ROW_MAJOR

%type <identifier> variable_identifier
%type <node> statement
%type <node> statement_list
%type <node> simple_statement
%type <n> precision_qualifier
%type <type_qualifier> type_qualifier
%type <type_qualifier> auxiliary_storage_qualifier
%type <type_qualifier> storage_qualifier
%type <type_qualifier> interpolation_qualifier
%type <type_qualifier> layout_qualifier
%type <type_qualifier> layout_qualifier_id_list layout_qualifier_id
%type <type_qualifier> interface_block_layout_qualifier
%type <type_qualifier> interface_qualifier
%type <type_specifier> type_specifier
%type <type_specifier> type_specifier_nonarray
%type <array_specifier> array_specifier
%type <identifier> basic_type_specifier_nonarray
%type <fully_specified_type> fully_specified_type
%type <function> function_prototype
%type <function> function_header
%type <function> function_header_with_parameters
%type <function> function_declarator
%type <parameter_declarator> parameter_declarator
%type <parameter_declarator> parameter_declaration
%type <type_qualifier> parameter_qualifier
%type <type_qualifier> parameter_direction_qualifier
%type <type_specifier> parameter_type_specifier
%type <function_definition> function_definition
%type <compound_statement> compound_statement_no_new_scope
%type <compound_statement> compound_statement
%type <node> statement_no_new_scope
%type <node> expression_statement
%type <expression> expression
%type <expression> primary_expression
%type <expression> assignment_expression
%type <expression> conditional_expression
%type <expression> logical_or_expression
%type <expression> logical_xor_expression
%type <expression> logical_and_expression
%type <expression> inclusive_or_expression
%type <expression> exclusive_or_expression
%type <expression> and_expression
%type <expression> equality_expression
%type <expression> relational_expression
%type <expression> shift_expression
%type <expression> additive_expression
%type <expression> multiplicative_expression
%type <expression> unary_expression
%type <expression> constant_expression
%type <expression> integer_expression
%type <expression> postfix_expression
%type <expression> function_call_header_with_parameters
%type <expression> function_call_header_no_parameters
%type <expression> function_call_header
%type <expression> function_call_generic
%type <expression> function_call_or_method
%type <expression> function_call
%type <expression> method_call_generic
%type <expression> method_call_header_with_parameters
%type <expression> method_call_header_no_parameters
%type <expression> method_call_header
%type <n> assignment_operator
%type <n> unary_operator
%type <expression> function_identifier
%type <node> external_declaration
%type <declarator_list> init_declarator_list
%type <declarator_list> single_declaration
%type <expression> initializer
%type <expression> initializer_list
%type <node> declaration
%type <node> declaration_statement
%type <node> jump_statement
%type <node> interface_block
%type <interface_block> basic_interface_block
%type <struct_specifier> struct_specifier
%type <declarator_list> struct_declaration_list
%type <declarator_list> struct_declaration
%type <declaration> struct_declarator
%type <declaration> struct_declarator_list
%type <declarator_list> member_list
%type <declarator_list> member_declaration
%type <node> selection_statement
%type <selection_rest_statement> selection_rest_statement
%type <node> switch_statement
%type <switch_body> switch_body
%type <case_label_list> case_label_list
%type <case_label> case_label
%type <case_statement> case_statement
%type <case_statement_list> case_statement_list
%type <node> iteration_statement
%type <node> condition
%type <node> conditionopt
%type <node> for_init_statement
%type <for_rest_statement> for_rest_statement
%type <n> integer_constant
%type <node> layout_defaults

%right THEN ELSE
%%

translation_unit:
   version_statement extension_statement_list
   {
      _mesa_glsl_initialize_types(state);
   }
   external_declaration_list
   {
      delete state->symbols;
      state->symbols = new(ralloc_parent(state)) glsl_symbol_table;
      _mesa_glsl_initialize_types(state);
   }
   ;

version_statement:
   /* blank - no #version specified: defaults are already set */
   | VERSION_TOK INTCONSTANT EOL
   {
      state->process_version_directive(&@@2, $2, NULL);
      if (state->error) {
         YYERROR;
      }
   }
   | VERSION_TOK INTCONSTANT any_identifier EOL
   {
      state->process_version_directive(&@@2, $2, $3);
      if (state->error) {
         YYERROR;
      }
   }
   ;

pragma_statement:
   PRAGMA_DEBUG_ON EOL
   | PRAGMA_DEBUG_OFF EOL
   | PRAGMA_OPTIMIZE_ON EOL
   | PRAGMA_OPTIMIZE_OFF EOL
   | PRAGMA_INVARIANT_ALL EOL
   {
      if (!state->is_version(120, 100)) {
         _mesa_glsl_warning(& @@1, state,
                            "pragma `invariant(all)' not supported in %s "
                            "(GLSL ES 1.00 or GLSL 1.20 required)",
                            state->get_version_string());
      } else {
         state->all_invariant = true;
      }
   }
   ;

extension_statement_list:

   | extension_statement_list extension_statement
   ;

any_identifier:
   IDENTIFIER
   | TYPE_IDENTIFIER
   | NEW_IDENTIFIER
   ;

extension_statement:
   EXTENSION any_identifier COLON any_identifier EOL
   {
      if (!_mesa_glsl_process_extension($2, & @@2, $4, & @@4, state)) {
         YYERROR;
      }
   }
   ;

external_declaration_list:
   external_declaration
   {
      /* FINISHME: The NULL test is required because pragmas are set to
       * FINISHME: NULL. (See production rule for external_declaration.)
       */
      if ($1 != NULL)
         state->translation_unit.push_tail(& $1->link);
   }
   | external_declaration_list external_declaration
   {
      /* FINISHME: The NULL test is required because pragmas are set to
       * FINISHME: NULL. (See production rule for external_declaration.)
       */
      if ($2 != NULL)
         state->translation_unit.push_tail(& $2->link);
   }
   ;

variable_identifier:
   IDENTIFIER
   | NEW_IDENTIFIER
   ;

primary_expression:
   variable_identifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_identifier, NULL, NULL, NULL);
      $$->set_location(@@1);
      $$->primary_expression.identifier = $1;
   }
   | INTCONSTANT
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_int_constant, NULL, NULL, NULL);
      $$->set_location(@@1);
      $$->primary_expression.int_constant = $1;
   }
   | UINTCONSTANT
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_uint_constant, NULL, NULL, NULL);
      $$->set_location(@@1);
      $$->primary_expression.uint_constant = $1;
   }
   | FLOATCONSTANT
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_float_constant, NULL, NULL, NULL);
      $$->set_location(@@1);
      $$->primary_expression.float_constant = $1;
   }
   | BOOLCONSTANT
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_bool_constant, NULL, NULL, NULL);
      $$->set_location(@@1);
      $$->primary_expression.bool_constant = $1;
   }
   | '(' expression ')'
   {
      $$ = $2;
   }
   ;

postfix_expression:
   primary_expression
   | postfix_expression '[' integer_expression ']'
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_array_index, $1, $3, NULL);
      $$->set_location_range(@@1, @@4);
   }
   | function_call
   {
      $$ = $1;
   }
   | postfix_expression '.' any_identifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_field_selection, $1, NULL, NULL);
      $$->set_location_range(@@1, @@3);
      $$->primary_expression.identifier = $3;
   }
   | postfix_expression INC_OP
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_post_inc, $1, NULL, NULL);
      $$->set_location_range(@@1, @@2);
   }
   | postfix_expression DEC_OP
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_post_dec, $1, NULL, NULL);
      $$->set_location_range(@@1, @@2);
   }
   ;

integer_expression:
   expression
   ;

function_call:
   function_call_or_method
   ;

function_call_or_method:
   function_call_generic
   | postfix_expression '.' method_call_generic
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_field_selection, $1, $3, NULL);
      $$->set_location_range(@@1, @@3);
   }
   ;

function_call_generic:
   function_call_header_with_parameters ')'
   | function_call_header_no_parameters ')'
   ;

function_call_header_no_parameters:
   function_call_header VOID_TOK
   | function_call_header
   ;

function_call_header_with_parameters:
   function_call_header assignment_expression
   {
      $$ = $1;
      $$->set_location(@@1);
      $$->expressions.push_tail(& $2->link);
   }
   | function_call_header_with_parameters ',' assignment_expression
   {
      $$ = $1;
      $$->set_location(@@1);
      $$->expressions.push_tail(& $3->link);
   }
   ;

   // Grammar Note: Constructors look like functions, but lexical
   // analysis recognized most of them as keywords. They are now
   // recognized through "type_specifier".
function_call_header:
   function_identifier '('
   ;

function_identifier:
   type_specifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_function_expression($1);
      $$->set_location(@@1);
      }
   | variable_identifier
   {
      void *ctx = state;
      ast_expression *callee = new(ctx) ast_expression($1);
      callee->set_location(@@1);
      $$ = new(ctx) ast_function_expression(callee);
      $$->set_location(@@1);
      }
   | FIELD_SELECTION
   {
      void *ctx = state;
      ast_expression *callee = new(ctx) ast_expression($1);
      callee->set_location(@@1);
      $$ = new(ctx) ast_function_expression(callee);
      $$->set_location(@@1);
      }
   ;

method_call_generic:
   method_call_header_with_parameters ')'
   | method_call_header_no_parameters ')'
   ;

method_call_header_no_parameters:
   method_call_header VOID_TOK
   | method_call_header
   ;

method_call_header_with_parameters:
   method_call_header assignment_expression
   {
      $$ = $1;
      $$->set_location(@@1);
      $$->expressions.push_tail(& $2->link);
   }
   | method_call_header_with_parameters ',' assignment_expression
   {
      $$ = $1;
      $$->set_location(@@1);
      $$->expressions.push_tail(& $3->link);
   }
   ;

   // Grammar Note: Constructors look like methods, but lexical
   // analysis recognized most of them as keywords. They are now
   // recognized through "type_specifier".
method_call_header:
   variable_identifier '('
   {
      void *ctx = state;
      ast_expression *callee = new(ctx) ast_expression($1);
      callee->set_location(@@1);
      $$ = new(ctx) ast_function_expression(callee);
      $$->set_location(@@1);
   }
   ;

   // Grammar Note: No traditional style type casts.
unary_expression:
   postfix_expression
   | INC_OP unary_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_pre_inc, $2, NULL, NULL);
      $$->set_location(@@1);
   }
   | DEC_OP unary_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_pre_dec, $2, NULL, NULL);
      $$->set_location(@@1);
   }
   | unary_operator unary_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression($1, $2, NULL, NULL);
      $$->set_location_range(@@1, @@2);
   }
   ;

   // Grammar Note: No '*' or '&' unary ops. Pointers are not supported.
unary_operator:
   '+'   { $$ = ast_plus; }
   | '-' { $$ = ast_neg; }
   | '!' { $$ = ast_logic_not; }
   | '~' { $$ = ast_bit_not; }
   ;

multiplicative_expression:
   unary_expression
   | multiplicative_expression '*' unary_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_mul, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   | multiplicative_expression '/' unary_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_div, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   | multiplicative_expression '%' unary_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_mod, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   ;

additive_expression:
   multiplicative_expression
   | additive_expression '+' multiplicative_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_add, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   | additive_expression '-' multiplicative_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_sub, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   ;

shift_expression:
   additive_expression
   | shift_expression LEFT_OP additive_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_lshift, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   | shift_expression RIGHT_OP additive_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_rshift, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   ;

relational_expression:
   shift_expression
   | relational_expression '<' shift_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_less, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   | relational_expression '>' shift_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_greater, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   | relational_expression LE_OP shift_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_lequal, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   | relational_expression GE_OP shift_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_gequal, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   ;

equality_expression:
   relational_expression
   | equality_expression EQ_OP relational_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_equal, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   | equality_expression NE_OP relational_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_nequal, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   ;

and_expression:
   equality_expression
   | and_expression '&' equality_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_bit_and, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   ;

exclusive_or_expression:
   and_expression
   | exclusive_or_expression '^' and_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_bit_xor, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   ;

inclusive_or_expression:
   exclusive_or_expression
   | inclusive_or_expression '|' exclusive_or_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_bit_or, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   ;

logical_and_expression:
   inclusive_or_expression
   | logical_and_expression AND_OP inclusive_or_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_logic_and, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   ;

logical_xor_expression:
   logical_and_expression
   | logical_xor_expression XOR_OP logical_and_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_logic_xor, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   ;

logical_or_expression:
   logical_xor_expression
   | logical_or_expression OR_OP logical_xor_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_logic_or, $1, $3);
      $$->set_location_range(@@1, @@3);
   }
   ;

conditional_expression:
   logical_or_expression
   | logical_or_expression '?' expression ':' assignment_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_conditional, $1, $3, $5);
      $$->set_location_range(@@1, @@5);
   }
   ;

assignment_expression:
   conditional_expression
   | unary_expression assignment_operator assignment_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression($2, $1, $3, NULL);
      $$->set_location_range(@@1, @@3);
   }
   ;

assignment_operator:
   '='                { $$ = ast_assign; }
   | MUL_ASSIGN       { $$ = ast_mul_assign; }
   | DIV_ASSIGN       { $$ = ast_div_assign; }
   | MOD_ASSIGN       { $$ = ast_mod_assign; }
   | ADD_ASSIGN       { $$ = ast_add_assign; }
   | SUB_ASSIGN       { $$ = ast_sub_assign; }
   | LEFT_ASSIGN      { $$ = ast_ls_assign; }
   | RIGHT_ASSIGN     { $$ = ast_rs_assign; }
   | AND_ASSIGN       { $$ = ast_and_assign; }
   | XOR_ASSIGN       { $$ = ast_xor_assign; }
   | OR_ASSIGN        { $$ = ast_or_assign; }
   ;

expression:
   assignment_expression
   {
      $$ = $1;
   }
   | expression ',' assignment_expression
   {
      void *ctx = state;
      if ($1->oper != ast_sequence) {
         $$ = new(ctx) ast_expression(ast_sequence, NULL, NULL, NULL);
         $$->set_location_range(@@1, @@3);
         $$->expressions.push_tail(& $1->link);
      } else {
         $$ = $1;
      }

      $$->expressions.push_tail(& $3->link);
   }
   ;

constant_expression:
   conditional_expression
   ;

declaration:
   function_prototype ';'
   {
      state->symbols->pop_scope();
      $$ = $1;
   }
   | init_declarator_list ';'
   {
      $$ = $1;
   }
   | PRECISION precision_qualifier type_specifier ';'
   {
      $3->default_precision = $2;
      $$ = $3;
   }
   | interface_block
   {
      $$ = $1;
   }
   ;

function_prototype:
   function_declarator ')'
   ;

function_declarator:
   function_header
   | function_header_with_parameters
   ;

function_header_with_parameters:
   function_header parameter_declaration
   {
      $$ = $1;
      $$->parameters.push_tail(& $2->link);
   }
   | function_header_with_parameters ',' parameter_declaration
   {
      $$ = $1;
      $$->parameters.push_tail(& $3->link);
   }
   ;

function_header:
   fully_specified_type variable_identifier '('
   {
      void *ctx = state;
      $$ = new(ctx) ast_function();
      $$->set_location(@@2);
      $$->return_type = $1;
      $$->identifier = $2;

      state->symbols->add_function(new(state) ir_function($2));
      state->symbols->push_scope();
   }
   ;

parameter_declarator:
   type_specifier any_identifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_parameter_declarator();
      $$->set_location_range(@@1, @@2);
      $$->type = new(ctx) ast_fully_specified_type();
      $$->type->set_location(@@1);
      $$->type->specifier = $1;
      $$->identifier = $2;
   }
   | type_specifier any_identifier array_specifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_parameter_declarator();
      $$->set_location_range(@@1, @@3);
      $$->type = new(ctx) ast_fully_specified_type();
      $$->type->set_location(@@1);
      $$->type->specifier = $1;
      $$->identifier = $2;
      $$->array_specifier = $3;
   }
   ;

parameter_declaration:
   parameter_qualifier parameter_declarator
   {
      $$ = $2;
      $$->type->qualifier = $1;
   }
   | parameter_qualifier parameter_type_specifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_parameter_declarator();
      $$->set_location(@@2);
      $$->type = new(ctx) ast_fully_specified_type();
      $$->type->set_location_range(@@1, @@2);
      $$->type->qualifier = $1;
      $$->type->specifier = $2;
   }
   ;

parameter_qualifier:
   /* empty */
   {
      memset(& $$, 0, sizeof($$));
   }
   | CONST_TOK parameter_qualifier
   {
      if ($2.flags.q.constant)
         _mesa_glsl_error(&@@1, state, "duplicate const qualifier");

      $$ = $2;
      $$.flags.q.constant = 1;
   }
   | parameter_direction_qualifier parameter_qualifier
   {
      if (($1.flags.q.in || $1.flags.q.out) && ($2.flags.q.in || $2.flags.q.out))
         _mesa_glsl_error(&@@1, state, "duplicate in/out/inout qualifier");

      if (!state->ARB_shading_language_420pack_enable && $2.flags.q.constant)
         _mesa_glsl_error(&@@1, state, "const must be specified before "
                          "in/out/inout");

      $$ = $1;
      $$.merge_qualifier(&@@1, state, $2);
   }
   | precision_qualifier parameter_qualifier
   {
      if ($2.precision != ast_precision_none)
         _mesa_glsl_error(&@@1, state, "duplicate precision qualifier");

      if (!state->ARB_shading_language_420pack_enable && $2.flags.i != 0)
         _mesa_glsl_error(&@@1, state, "precision qualifiers must come last");

      $$ = $2;
      $$.precision = $1;
   }

parameter_direction_qualifier:
   IN_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.in = 1;
   }
   | OUT_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.out = 1;
   }
   | INOUT_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.in = 1;
      $$.flags.q.out = 1;
   }
   ;

parameter_type_specifier:
   type_specifier
   ;

init_declarator_list:
   single_declaration
   | init_declarator_list ',' any_identifier
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($3, NULL, NULL);
      decl->set_location(@@3);

      $$ = $1;
      $$->declarations.push_tail(&decl->link);
      state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
   }
   | init_declarator_list ',' any_identifier array_specifier
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($3, $4, NULL);
      decl->set_location_range(@@3, @@4);

      $$ = $1;
      $$->declarations.push_tail(&decl->link);
      state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
   }
   | init_declarator_list ',' any_identifier array_specifier '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($3, $4, $6);
      decl->set_location_range(@@3, @@4);

      $$ = $1;
      $$->declarations.push_tail(&decl->link);
      state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
   }
   | init_declarator_list ',' any_identifier '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($3, NULL, $5);
      decl->set_location(@@3);

      $$ = $1;
      $$->declarations.push_tail(&decl->link);
      state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
   }
   ;

   // Grammar Note: No 'enum', or 'typedef'.
single_declaration:
   fully_specified_type
   {
      void *ctx = state;
      /* Empty declaration list is valid. */
      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location(@@1);
   }
   | fully_specified_type any_identifier
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, NULL, NULL);
      decl->set_location(@@2);

      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location_range(@@1, @@2);
      $$->declarations.push_tail(&decl->link);
   }
   | fully_specified_type any_identifier array_specifier
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, $3, NULL);
      decl->set_location_range(@@2, @@3);

      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location_range(@@1, @@3);
      $$->declarations.push_tail(&decl->link);
   }
   | fully_specified_type any_identifier array_specifier '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, $3, $5);
      decl->set_location_range(@@2, @@3);

      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location_range(@@1, @@3);
      $$->declarations.push_tail(&decl->link);
   }
   | fully_specified_type any_identifier '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, NULL, $4);
      decl->set_location(@@2);

      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location_range(@@1, @@2);
      $$->declarations.push_tail(&decl->link);
   }
   | INVARIANT variable_identifier // Vertex only.
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, NULL, NULL);
      decl->set_location(@@2);

      $$ = new(ctx) ast_declarator_list(NULL);
      $$->set_location_range(@@1, @@2);
      $$->invariant = true;

      $$->declarations.push_tail(&decl->link);
   }
   ;

fully_specified_type:
   type_specifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_fully_specified_type();
      $$->set_location(@@1);
      $$->specifier = $1;
   }
   | type_qualifier type_specifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_fully_specified_type();
      $$->set_location_range(@@1, @@2);
      $$->qualifier = $1;
      $$->specifier = $2;
   }
   ;

layout_qualifier:
   LAYOUT_TOK '(' layout_qualifier_id_list ')'
   {
      $$ = $3;
   }
   ;

layout_qualifier_id_list:
   layout_qualifier_id
   | layout_qualifier_id_list ',' layout_qualifier_id
   {
      $$ = $1;
      if (!$$.merge_qualifier(& @@3, state, $3)) {
         YYERROR;
      }
   }
   ;

integer_constant:
   INTCONSTANT { $$ = $1; }
   | UINTCONSTANT { $$ = $1; }
   ;

layout_qualifier_id:
   any_identifier
   {
      memset(& $$, 0, sizeof($$));

      /* Layout qualifiers for ARB_fragment_coord_conventions. */
      if (!$$.flags.i && (state->ARB_fragment_coord_conventions_enable ||
                          state->is_version(150, 0))) {
         if (match_layout_qualifier($1, "origin_upper_left", state) == 0) {
            $$.flags.q.origin_upper_left = 1;
         } else if (match_layout_qualifier($1, "pixel_center_integer",
                                           state) == 0) {
            $$.flags.q.pixel_center_integer = 1;
         }

         if ($$.flags.i && state->ARB_fragment_coord_conventions_warn) {
            _mesa_glsl_warning(& @@1, state,
                               "GL_ARB_fragment_coord_conventions layout "
                               "identifier `%s' used", $1);
         }
      }

      /* Layout qualifiers for AMD/ARB_conservative_depth. */
      if (!$$.flags.i &&
          (state->AMD_conservative_depth_enable ||
           state->ARB_conservative_depth_enable)) {
         if (match_layout_qualifier($1, "depth_any", state) == 0) {
            $$.flags.q.depth_any = 1;
         } else if (match_layout_qualifier($1, "depth_greater", state) == 0) {
            $$.flags.q.depth_greater = 1;
         } else if (match_layout_qualifier($1, "depth_less", state) == 0) {
            $$.flags.q.depth_less = 1;
         } else if (match_layout_qualifier($1, "depth_unchanged",
                                           state) == 0) {
            $$.flags.q.depth_unchanged = 1;
         }

         if ($$.flags.i && state->AMD_conservative_depth_warn) {
            _mesa_glsl_warning(& @@1, state,
                               "GL_AMD_conservative_depth "
                               "layout qualifier `%s' is used", $1);
         }
         if ($$.flags.i && state->ARB_conservative_depth_warn) {
            _mesa_glsl_warning(& @@1, state,
                               "GL_ARB_conservative_depth "
                               "layout qualifier `%s' is used", $1);
         }
      }

      /* See also interface_block_layout_qualifier. */
      if (!$$.flags.i && state->has_uniform_buffer_objects()) {
         if (match_layout_qualifier($1, "std140", state) == 0) {
            $$.flags.q.std140 = 1;
         } else if (match_layout_qualifier($1, "shared", state) == 0) {
            $$.flags.q.shared = 1;
         } else if (match_layout_qualifier($1, "column_major", state) == 0) {
            $$.flags.q.column_major = 1;
         /* "row_major" is a reserved word in GLSL 1.30+. Its token is parsed
          * below in the interface_block_layout_qualifier rule.
          *
          * It is not a reserved word in GLSL ES 3.00, so it's handled here as
          * an identifier.
          *
          * Also, this takes care of alternate capitalizations of
          * "row_major" (which is necessary because layout qualifiers
          * are case-insensitive in desktop GLSL).
          */
         } else if (match_layout_qualifier($1, "row_major", state) == 0) {
            $$.flags.q.row_major = 1;
         /* "packed" is a reserved word in GLSL, and its token is
          * parsed below in the interface_block_layout_qualifier rule.
          * However, we must take care of alternate capitalizations of
          * "packed", because layout qualifiers are case-insensitive
          * in desktop GLSL.
          */
         } else if (match_layout_qualifier($1, "packed", state) == 0) {
           $$.flags.q.packed = 1;
         }

         if ($$.flags.i && state->ARB_uniform_buffer_object_warn) {
            _mesa_glsl_warning(& @@1, state,
                               "#version 140 / GL_ARB_uniform_buffer_object "
                               "layout qualifier `%s' is used", $1);
         }
      }

      /* Layout qualifiers for GLSL 1.50 geometry shaders. */
      if (!$$.flags.i) {
         static const struct {
            const char *s;
            GLenum e;
         } map[] = {
                 { "points", GL_POINTS },
                 { "lines", GL_LINES },
                 { "lines_adjacency", GL_LINES_ADJACENCY },
                 { "line_strip", GL_LINE_STRIP },
                 { "triangles", GL_TRIANGLES },
                 { "triangles_adjacency", GL_TRIANGLES_ADJACENCY },
                 { "triangle_strip", GL_TRIANGLE_STRIP },
         };
         for (unsigned i = 0; i < Elements(map); i++) {
            if (match_layout_qualifier($1, map[i].s, state) == 0) {
               $$.flags.q.prim_type = 1;
               $$.prim_type = map[i].e;
               break;
            }
         }

         if ($$.flags.i && !state->is_version(150, 0)) {
            _mesa_glsl_error(& @@1, state, "#version 150 layout "
                             "qualifier `%s' used", $1);
         }
      }

      /* Layout qualifiers for ARB_shader_image_load_store. */
      if (state->ARB_shader_image_load_store_enable ||
          state->is_version(420, 0)) {
         if (!$$.flags.i) {
            static const struct {
               const char *name;
               GLenum format;
               glsl_base_type base_type;
            } map[] = {
               { "rgba32f", GL_RGBA32F, GLSL_TYPE_FLOAT },
               { "rgba16f", GL_RGBA16F, GLSL_TYPE_FLOAT },
               { "rg32f", GL_RG32F, GLSL_TYPE_FLOAT },
               { "rg16f", GL_RG16F, GLSL_TYPE_FLOAT },
               { "r11f_g11f_b10f", GL_R11F_G11F_B10F, GLSL_TYPE_FLOAT },
               { "r32f", GL_R32F, GLSL_TYPE_FLOAT },
               { "r16f", GL_R16F, GLSL_TYPE_FLOAT },
               { "rgba32ui", GL_RGBA32UI, GLSL_TYPE_UINT },
               { "rgba16ui", GL_RGBA16UI, GLSL_TYPE_UINT },
               { "rgb10_a2ui", GL_RGB10_A2UI, GLSL_TYPE_UINT },
               { "rgba8ui", GL_RGBA8UI, GLSL_TYPE_UINT },
               { "rg32ui", GL_RG32UI, GLSL_TYPE_UINT },
               { "rg16ui", GL_RG16UI, GLSL_TYPE_UINT },
               { "rg8ui", GL_RG8UI, GLSL_TYPE_UINT },
               { "r32ui", GL_R32UI, GLSL_TYPE_UINT },
               { "r16ui", GL_R16UI, GLSL_TYPE_UINT },
               { "r8ui", GL_R8UI, GLSL_TYPE_UINT },
               { "rgba32i", GL_RGBA32I, GLSL_TYPE_INT },
               { "rgba16i", GL_RGBA16I, GLSL_TYPE_INT },
               { "rgba8i", GL_RGBA8I, GLSL_TYPE_INT },
               { "rg32i", GL_RG32I, GLSL_TYPE_INT },
               { "rg16i", GL_RG16I, GLSL_TYPE_INT },
               { "rg8i", GL_RG8I, GLSL_TYPE_INT },
               { "r32i", GL_R32I, GLSL_TYPE_INT },
               { "r16i", GL_R16I, GLSL_TYPE_INT },
               { "r8i", GL_R8I, GLSL_TYPE_INT },
               { "rgba16", GL_RGBA16, GLSL_TYPE_FLOAT },
               { "rgb10_a2", GL_RGB10_A2, GLSL_TYPE_FLOAT },
               { "rgba8", GL_RGBA8, GLSL_TYPE_FLOAT },
               { "rg16", GL_RG16, GLSL_TYPE_FLOAT },
               { "rg8", GL_RG8, GLSL_TYPE_FLOAT },
               { "r16", GL_R16, GLSL_TYPE_FLOAT },
               { "r8", GL_R8, GLSL_TYPE_FLOAT },
               { "rgba16_snorm", GL_RGBA16_SNORM, GLSL_TYPE_FLOAT },
               { "rgba8_snorm", GL_RGBA8_SNORM, GLSL_TYPE_FLOAT },
               { "rg16_snorm", GL_RG16_SNORM, GLSL_TYPE_FLOAT },
               { "rg8_snorm", GL_RG8_SNORM, GLSL_TYPE_FLOAT },
               { "r16_snorm", GL_R16_SNORM, GLSL_TYPE_FLOAT },
               { "r8_snorm", GL_R8_SNORM, GLSL_TYPE_FLOAT }
            };

            for (unsigned i = 0; i < Elements(map); i++) {
               if (match_layout_qualifier($1, map[i].name, state) == 0) {
                  $$.flags.q.explicit_image_format = 1;
                  $$.image_format = map[i].format;
                  $$.image_base_type = map[i].base_type;
                  break;
               }
            }
         }

         if (!$$.flags.i &&
             match_layout_qualifier($1, "early_fragment_tests", state) == 0) {
            $$.flags.q.early_fragment_tests = 1;
         }
      }

      if (!$$.flags.i) {
         _mesa_glsl_error(& @@1, state, "unrecognized layout identifier "
                          "`%s'", $1);
         YYERROR;
      }
   }
   | any_identifier '=' integer_constant
   {
      memset(& $$, 0, sizeof($$));

      if (match_layout_qualifier("location", $1, state) == 0) {
         $$.flags.q.explicit_location = 1;

         if ($$.flags.q.attribute == 1 &&
             state->ARB_explicit_attrib_location_warn) {
            _mesa_glsl_warning(& @@1, state,
                               "GL_ARB_explicit_attrib_location layout "
                               "identifier `%s' used", $1);
         }

         if ($3 >= 0) {
            $$.location = $3;
         } else {
             _mesa_glsl_error(& @@3, state, "invalid location %d specified", $3);
             YYERROR;
         }
      }

      if (match_layout_qualifier("index", $1, state) == 0) {
         $$.flags.q.explicit_index = 1;

         if ($3 >= 0) {
            $$.index = $3;
         } else {
            _mesa_glsl_error(& @@3, state, "invalid index %d specified", $3);
            YYERROR;
         }
      }

      if ((state->ARB_shading_language_420pack_enable ||
           state->ARB_shader_atomic_counters_enable) &&
          match_layout_qualifier("binding", $1, state) == 0) {
         $$.flags.q.explicit_binding = 1;
         $$.binding = $3;
      }

      if (state->ARB_shader_atomic_counters_enable &&
          match_layout_qualifier("offset", $1, state) == 0) {
         $$.flags.q.explicit_offset = 1;
         $$.offset = $3;
      }

      if (match_layout_qualifier("max_vertices", $1, state) == 0) {
         $$.flags.q.max_vertices = 1;

         if ($3 < 0) {
            _mesa_glsl_error(& @@3, state,
                             "invalid max_vertices %d specified", $3);
            YYERROR;
         } else {
            $$.max_vertices = $3;
            if (!state->is_version(150, 0)) {
               _mesa_glsl_error(& @@3, state,
                                "#version 150 max_vertices qualifier "
                                "specified", $3);
            }
         }
      }

      static const char * const local_size_qualifiers[3] = {
         "local_size_x",
         "local_size_y",
         "local_size_z",
      };
      for (int i = 0; i < 3; i++) {
         if (match_layout_qualifier(local_size_qualifiers[i], $1,
                                    state) == 0) {
            if ($3 <= 0) {
               _mesa_glsl_error(& @@3, state,
                                "invalid %s of %d specified",
                                local_size_qualifiers[i], $3);
               YYERROR;
            } else if (!state->is_version(430, 0) &&
                       !state->ARB_compute_shader_enable) {
               _mesa_glsl_error(& @@3, state,
                                "%s qualifier requires GLSL 4.30 or "
                                "ARB_compute_shader",
                                local_size_qualifiers[i]);
               YYERROR;
            } else {
               $$.flags.q.local_size |= (1 << i);
               $$.local_size[i] = $3;
            }
            break;
         }
      }

      if (match_layout_qualifier("invocations", $1, state) == 0) {
         $$.flags.q.invocations = 1;

         if ($3 <= 0) {
            _mesa_glsl_error(& @@3, state,
                             "invalid invocations %d specified", $3);
            YYERROR;
         } else if ($3 > MAX_GEOMETRY_SHADER_INVOCATIONS) {
            _mesa_glsl_error(& @@3, state,
                             "invocations (%d) exceeds "
                             "GL_MAX_GEOMETRY_SHADER_INVOCATIONS", $3);
            YYERROR;
         } else {
            $$.invocations = $3;
            if (!state->is_version(400, 0) &&
                !state->ARB_gpu_shader5_enable) {
               _mesa_glsl_error(& @@3, state,
                                "GL_ARB_gpu_shader5 invocations "
                                "qualifier specified", $3);
            }
         }
      }

      /* If the identifier didn't match any known layout identifiers,
       * emit an error.
       */
      if (!$$.flags.i) {
         _mesa_glsl_error(& @@1, state, "unrecognized layout identifier "
                          "`%s'", $1);
         YYERROR;
      }
   }
   | interface_block_layout_qualifier
   {
      $$ = $1;
      /* Layout qualifiers for ARB_uniform_buffer_object. */
      if ($$.flags.q.uniform && !state->has_uniform_buffer_objects()) {
         _mesa_glsl_error(& @@1, state,
                          "#version 140 / GL_ARB_uniform_buffer_object "
                          "layout qualifier `%s' is used", $1);
      } else if ($$.flags.q.uniform && state->ARB_uniform_buffer_object_warn) {
         _mesa_glsl_warning(& @@1, state,
                            "#version 140 / GL_ARB_uniform_buffer_object "
                            "layout qualifier `%s' is used", $1);
      }
   }
   ;

/* This is a separate language rule because we parse these as tokens
 * (due to them being reserved keywords) instead of identifiers like
 * most qualifiers.  See the any_identifier path of
 * layout_qualifier_id for the others.
 *
 * Note that since layout qualifiers are case-insensitive in desktop
 * GLSL, all of these qualifiers need to be handled as identifiers as
 * well (by the any_identifier path of layout_qualifier_id).
 */
interface_block_layout_qualifier:
   ROW_MAJOR
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.row_major = 1;
   }
   | PACKED_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.packed = 1;
   }
   ;

interpolation_qualifier:
   SMOOTH
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.smooth = 1;
   }
   | FLAT
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.flat = 1;
   }
   | NOPERSPECTIVE
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.noperspective = 1;
   }
   ;

type_qualifier:
   /* Single qualifiers */
   INVARIANT
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.invariant = 1;
   }
   | auxiliary_storage_qualifier
   | storage_qualifier
   | interpolation_qualifier
   | layout_qualifier
   | precision_qualifier
   {
      memset(&$$, 0, sizeof($$));
      $$.precision = $1;
   }

   /* Multiple qualifiers:
    * In GLSL 4.20, these can be specified in any order.  In earlier versions,
    * they appear in this order (see GLSL 1.50 section 4.7 & comments below):
    *
    *    invariant interpolation auxiliary storage precision  ...or...
    *    layout storage precision
    *
    * Each qualifier's rule ensures that the accumulated qualifiers on the right
    * side don't contain any that must appear on the left hand side.
    * For example, when processing a storage qualifier, we check that there are
    * no auxiliary, interpolation, layout, or invariant qualifiers to the right.
    */
   | INVARIANT type_qualifier
   {
      if ($2.flags.q.invariant)
         _mesa_glsl_error(&@@1, state, "duplicate \"invariant\" qualifier");

      if ($2.has_layout()) {
         _mesa_glsl_error(&@@1, state,
                          "\"invariant\" cannot be used with layout(...)");
      }

      $$ = $2;
      $$.flags.q.invariant = 1;
   }
   | interpolation_qualifier type_qualifier
   {
      /* Section 4.3 of the GLSL 1.40 specification states:
       * "...qualified with one of these interpolation qualifiers"
       *
       * GLSL 1.30 claims to allow "one or more", but insists that:
       * "These interpolation qualifiers may only precede the qualifiers in,
       *  centroid in, out, or centroid out in a declaration."
       *
       * ...which means that e.g. smooth can't precede smooth, so there can be
       * only one after all, and the 1.40 text is a clarification, not a change.
       */
      if ($2.has_interpolation())
         _mesa_glsl_error(&@@1, state, "duplicate interpolation qualifier");

      if ($2.has_layout()) {
         _mesa_glsl_error(&@@1, state, "interpolation qualifiers cannot be used "
                          "with layout(...)");
      }

      if (!state->ARB_shading_language_420pack_enable && $2.flags.q.invariant) {
         _mesa_glsl_error(&@@1, state, "interpolation qualifiers must come "
                          "after \"invariant\"");
      }

      $$ = $1;
      $$.merge_qualifier(&@@1, state, $2);
   }
   | layout_qualifier type_qualifier
   {
      /* The GLSL 1.50 grammar indicates that a layout(...) declaration can be
       * used standalone or immediately before a storage qualifier.  It cannot
       * be used with interpolation qualifiers or invariant.  There does not
       * appear to be any text indicating that it must come before the storage
       * qualifier, but always seems to in examples.
       */
      if (!state->ARB_shading_language_420pack_enable && $2.has_layout())
         _mesa_glsl_error(&@@1, state, "duplicate layout(...) qualifiers");

      if ($2.flags.q.invariant)
         _mesa_glsl_error(&@@1, state, "layout(...) cannot be used with "
                          "the \"invariant\" qualifier");

      if ($2.has_interpolation()) {
         _mesa_glsl_error(&@@1, state, "layout(...) cannot be used with "
                          "interpolation qualifiers");
      }

      $$ = $1;
      $$.merge_qualifier(&@@1, state, $2);
   }
   | auxiliary_storage_qualifier type_qualifier
   {
      if ($2.has_auxiliary_storage()) {
         _mesa_glsl_error(&@@1, state,
                          "duplicate auxiliary storage qualifier (centroid or sample)");
      }

      if (!state->ARB_shading_language_420pack_enable &&
          ($2.flags.q.invariant || $2.has_interpolation() || $2.has_layout())) {
         _mesa_glsl_error(&@@1, state, "auxiliary storage qualifiers must come "
                          "just before storage qualifiers");
      }
      $$ = $1;
      $$.merge_qualifier(&@@1, state, $2);
   }
   | storage_qualifier type_qualifier
   {
      /* Section 4.3 of the GLSL 1.20 specification states:
       * "Variable declarations may have a storage qualifier specified..."
       *  1.30 clarifies this to "may have one storage qualifier".
       */
      if ($2.has_storage())
         _mesa_glsl_error(&@@1, state, "duplicate storage qualifier");

      if (!state->ARB_shading_language_420pack_enable &&
          ($2.flags.q.invariant || $2.has_interpolation() || $2.has_layout() ||
           $2.has_auxiliary_storage())) {
         _mesa_glsl_error(&@@1, state, "storage qualifiers must come after "
                          "invariant, interpolation, layout and auxiliary "
                          "storage qualifiers");
      }

      $$ = $1;
      $$.merge_qualifier(&@@1, state, $2);
   }
   | precision_qualifier type_qualifier
   {
      if ($2.precision != ast_precision_none)
         _mesa_glsl_error(&@@1, state, "duplicate precision qualifier");

      if (!state->ARB_shading_language_420pack_enable && $2.flags.i != 0)
         _mesa_glsl_error(&@@1, state, "precision qualifiers must come last");

      $$ = $2;
      $$.precision = $1;
   }
   ;

auxiliary_storage_qualifier:
   CENTROID
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.centroid = 1;
   }
   | SAMPLE
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.sample = 1;
   }
   /* TODO: "patch" also goes here someday. */

storage_qualifier:
   CONST_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.constant = 1;
   }
   | ATTRIBUTE
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.attribute = 1;
   }
   | VARYING
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.varying = 1;
   }
   | IN_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.in = 1;
   }
   | OUT_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.out = 1;
   }
   | UNIFORM
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.uniform = 1;
   }
   | COHERENT
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.coherent = 1;
   }
   | VOLATILE
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q._volatile = 1;
   }
   | RESTRICT
   {
      STATIC_ASSERT(sizeof($$.flags.q) <= sizeof($$.flags.i));
      memset(& $$, 0, sizeof($$));
      $$.flags.q.restrict_flag = 1;
   }
   | READONLY
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.read_only = 1;
   }
   | WRITEONLY
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.write_only = 1;
   }
   ;

array_specifier:
   '[' ']'
   {
      void *ctx = state;
      $$ = new(ctx) ast_array_specifier(@@1);
      $$->set_location_range(@@1, @@2);
   }
   | '[' constant_expression ']'
   {
      void *ctx = state;
      $$ = new(ctx) ast_array_specifier(@@1, $2);
      $$->set_location_range(@@1, @@3);
   }
   | array_specifier '[' ']'
   {
      $$ = $1;

      if (!state->ARB_arrays_of_arrays_enable) {
         _mesa_glsl_error(& @@1, state,
                          "GL_ARB_arrays_of_arrays "
                          "required for defining arrays of arrays");
      } else {
         _mesa_glsl_error(& @@1, state,
                          "only the outermost array dimension can "
                          "be unsized");
      }
   }
   | array_specifier '[' constant_expression ']'
   {
      $$ = $1;

      if (!state->ARB_arrays_of_arrays_enable) {
         _mesa_glsl_error(& @@1, state,
                          "GL_ARB_arrays_of_arrays "
                          "required for defining arrays of arrays");
      }

      $$->add_dimension($3);
   }
   ;

type_specifier:
   type_specifier_nonarray
   | type_specifier_nonarray array_specifier
   {
      $$ = $1;
      $$->array_specifier = $2;
   }
   ;

type_specifier_nonarray:
   basic_type_specifier_nonarray
   {
      void *ctx = state;
      $$ = new(ctx) ast_type_specifier($1);
      $$->set_location(@@1);
   }
   | struct_specifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_type_specifier($1);
      $$->set_location(@@1);
   }
   | TYPE_IDENTIFIER
   {
      void *ctx = state;
      $$ = new(ctx) ast_type_specifier($1);
      $$->set_location(@@1);
   }
   ;

basic_type_specifier_nonarray:
   VOID_TOK                 { $$ = "void"; }
   | FLOAT_TOK              { $$ = "float"; }
   | INT_TOK                { $$ = "int"; }
   | UINT_TOK               { $$ = "uint"; }
   | BOOL_TOK               { $$ = "bool"; }
   | VEC2                   { $$ = "vec2"; }
   | VEC3                   { $$ = "vec3"; }
   | VEC4                   { $$ = "vec4"; }
   | BVEC2                  { $$ = "bvec2"; }
   | BVEC3                  { $$ = "bvec3"; }
   | BVEC4                  { $$ = "bvec4"; }
   | IVEC2                  { $$ = "ivec2"; }
   | IVEC3                  { $$ = "ivec3"; }
   | IVEC4                  { $$ = "ivec4"; }
   | UVEC2                  { $$ = "uvec2"; }
   | UVEC3                  { $$ = "uvec3"; }
   | UVEC4                  { $$ = "uvec4"; }
   | MAT2X2                 { $$ = "mat2"; }
   | MAT2X3                 { $$ = "mat2x3"; }
   | MAT2X4                 { $$ = "mat2x4"; }
   | MAT3X2                 { $$ = "mat3x2"; }
   | MAT3X3                 { $$ = "mat3"; }
   | MAT3X4                 { $$ = "mat3x4"; }
   | MAT4X2                 { $$ = "mat4x2"; }
   | MAT4X3                 { $$ = "mat4x3"; }
   | MAT4X4                 { $$ = "mat4"; }
   | SAMPLER1D              { $$ = "sampler1D"; }
   | SAMPLER2D              { $$ = "sampler2D"; }
   | SAMPLER2DRECT          { $$ = "sampler2DRect"; }
   | SAMPLER3D              { $$ = "sampler3D"; }
   | SAMPLERCUBE            { $$ = "samplerCube"; }
   | SAMPLEREXTERNALOES     { $$ = "samplerExternalOES"; }
   | SAMPLER1DSHADOW        { $$ = "sampler1DShadow"; }
   | SAMPLER2DSHADOW        { $$ = "sampler2DShadow"; }
   | SAMPLER2DRECTSHADOW    { $$ = "sampler2DRectShadow"; }
   | SAMPLERCUBESHADOW      { $$ = "samplerCubeShadow"; }
   | SAMPLER1DARRAY         { $$ = "sampler1DArray"; }
   | SAMPLER2DARRAY         { $$ = "sampler2DArray"; }
   | SAMPLER1DARRAYSHADOW   { $$ = "sampler1DArrayShadow"; }
   | SAMPLER2DARRAYSHADOW   { $$ = "sampler2DArrayShadow"; }
   | SAMPLERBUFFER          { $$ = "samplerBuffer"; }
   | SAMPLERCUBEARRAY       { $$ = "samplerCubeArray"; }
   | SAMPLERCUBEARRAYSHADOW { $$ = "samplerCubeArrayShadow"; }
   | ISAMPLER1D             { $$ = "isampler1D"; }
   | ISAMPLER2D             { $$ = "isampler2D"; }
   | ISAMPLER2DRECT         { $$ = "isampler2DRect"; }
   | ISAMPLER3D             { $$ = "isampler3D"; }
   | ISAMPLERCUBE           { $$ = "isamplerCube"; }
   | ISAMPLER1DARRAY        { $$ = "isampler1DArray"; }
   | ISAMPLER2DARRAY        { $$ = "isampler2DArray"; }
   | ISAMPLERBUFFER         { $$ = "isamplerBuffer"; }
   | ISAMPLERCUBEARRAY      { $$ = "isamplerCubeArray"; }
   | USAMPLER1D             { $$ = "usampler1D"; }
   | USAMPLER2D             { $$ = "usampler2D"; }
   | USAMPLER2DRECT         { $$ = "usampler2DRect"; }
   | USAMPLER3D             { $$ = "usampler3D"; }
   | USAMPLERCUBE           { $$ = "usamplerCube"; }
   | USAMPLER1DARRAY        { $$ = "usampler1DArray"; }
   | USAMPLER2DARRAY        { $$ = "usampler2DArray"; }
   | USAMPLERBUFFER         { $$ = "usamplerBuffer"; }
   | USAMPLERCUBEARRAY      { $$ = "usamplerCubeArray"; }
   | SAMPLER2DMS            { $$ = "sampler2DMS"; }
   | ISAMPLER2DMS           { $$ = "isampler2DMS"; }
   | USAMPLER2DMS           { $$ = "usampler2DMS"; }
   | SAMPLER2DMSARRAY       { $$ = "sampler2DMSArray"; }
   | ISAMPLER2DMSARRAY      { $$ = "isampler2DMSArray"; }
   | USAMPLER2DMSARRAY      { $$ = "usampler2DMSArray"; }
   | IMAGE1D                { $$ = "image1D"; }
   | IMAGE2D                { $$ = "image2D"; }
   | IMAGE3D                { $$ = "image3D"; }
   | IMAGE2DRECT            { $$ = "image2DRect"; }
   | IMAGECUBE              { $$ = "imageCube"; }
   | IMAGEBUFFER            { $$ = "imageBuffer"; }
   | IMAGE1DARRAY           { $$ = "image1DArray"; }
   | IMAGE2DARRAY           { $$ = "image2DArray"; }
   | IMAGECUBEARRAY         { $$ = "imageCubeArray"; }
   | IMAGE2DMS              { $$ = "image2DMS"; }
   | IMAGE2DMSARRAY         { $$ = "image2DMSArray"; }
   | IIMAGE1D               { $$ = "iimage1D"; }
   | IIMAGE2D               { $$ = "iimage2D"; }
   | IIMAGE3D               { $$ = "iimage3D"; }
   | IIMAGE2DRECT           { $$ = "iimage2DRect"; }
   | IIMAGECUBE             { $$ = "iimageCube"; }
   | IIMAGEBUFFER           { $$ = "iimageBuffer"; }
   | IIMAGE1DARRAY          { $$ = "iimage1DArray"; }
   | IIMAGE2DARRAY          { $$ = "iimage2DArray"; }
   | IIMAGECUBEARRAY        { $$ = "iimageCubeArray"; }
   | IIMAGE2DMS             { $$ = "iimage2DMS"; }
   | IIMAGE2DMSARRAY        { $$ = "iimage2DMSArray"; }
   | UIMAGE1D               { $$ = "uimage1D"; }
   | UIMAGE2D               { $$ = "uimage2D"; }
   | UIMAGE3D               { $$ = "uimage3D"; }
   | UIMAGE2DRECT           { $$ = "uimage2DRect"; }
   | UIMAGECUBE             { $$ = "uimageCube"; }
   | UIMAGEBUFFER           { $$ = "uimageBuffer"; }
   | UIMAGE1DARRAY          { $$ = "uimage1DArray"; }
   | UIMAGE2DARRAY          { $$ = "uimage2DArray"; }
   | UIMAGECUBEARRAY        { $$ = "uimageCubeArray"; }
   | UIMAGE2DMS             { $$ = "uimage2DMS"; }
   | UIMAGE2DMSARRAY        { $$ = "uimage2DMSArray"; }
   | ATOMIC_UINT            { $$ = "atomic_uint"; }
   ;

precision_qualifier:
   HIGHP
   {
      state->check_precision_qualifiers_allowed(&@@1);
      $$ = ast_precision_high;
   }
   | MEDIUMP
   {
      state->check_precision_qualifiers_allowed(&@@1);
      $$ = ast_precision_medium;
   }
   | LOWP
   {
      state->check_precision_qualifiers_allowed(&@@1);
      $$ = ast_precision_low;
   }
   ;

struct_specifier:
   STRUCT any_identifier '{' struct_declaration_list '}'
   {
      void *ctx = state;
      $$ = new(ctx) ast_struct_specifier($2, $4);
      $$->set_location_range(@@2, @@5);
      state->symbols->add_type($2, glsl_type::void_type);
   }
   | STRUCT '{' struct_declaration_list '}'
   {
      void *ctx = state;
      $$ = new(ctx) ast_struct_specifier(NULL, $3);
      $$->set_location_range(@@2, @@4);
   }
   ;

struct_declaration_list:
   struct_declaration
   {
      $$ = $1;
      $1->link.self_link();
   }
   | struct_declaration_list struct_declaration
   {
      $$ = $1;
      $$->link.insert_before(& $2->link);
   }
   ;

struct_declaration:
   fully_specified_type struct_declarator_list ';'
   {
      void *ctx = state;
      ast_fully_specified_type *const type = $1;
      type->set_location(@@1);

      if (type->qualifier.flags.i != 0)
         _mesa_glsl_error(&@@1, state,
			  "only precision qualifiers may be applied to "
			  "structure members");

      $$ = new(ctx) ast_declarator_list(type);
      $$->set_location(@@2);

      $$->declarations.push_degenerate_list_at_head(& $2->link);
   }
   ;

struct_declarator_list:
   struct_declarator
   {
      $$ = $1;
      $1->link.self_link();
   }
   | struct_declarator_list ',' struct_declarator
   {
      $$ = $1;
      $$->link.insert_before(& $3->link);
   }
   ;

struct_declarator:
   any_identifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_declaration($1, NULL, NULL);
      $$->set_location(@@1);
   }
   | any_identifier array_specifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_declaration($1, $2, NULL);
      $$->set_location_range(@@1, @@2);
   }
   ;

initializer:
   assignment_expression
   | '{' initializer_list '}'
   {
      $$ = $2;
   }
   | '{' initializer_list ',' '}'
   {
      $$ = $2;
   }
   ;

initializer_list:
   initializer
   {
      void *ctx = state;
      $$ = new(ctx) ast_aggregate_initializer();
      $$->set_location(@@1);
      $$->expressions.push_tail(& $1->link);
   }
   | initializer_list ',' initializer
   {
      $1->expressions.push_tail(& $3->link);
   }
   ;

declaration_statement:
   declaration
   ;

   // Grammar Note: labeled statements for SWITCH only; 'goto' is not
   // supported.
statement:
   compound_statement        { $$ = (ast_node *) $1; }
   | simple_statement
   ;

simple_statement:
   declaration_statement
   | expression_statement
   | selection_statement
   | switch_statement
   | iteration_statement
   | jump_statement
   ;

compound_statement:
   '{' '}'
   {
      void *ctx = state;
      $$ = new(ctx) ast_compound_statement(true, NULL);
      $$->set_location_range(@@1, @@2);
   }
   | '{'
   {
      state->symbols->push_scope();
   }
   statement_list '}'
   {
      void *ctx = state;
      $$ = new(ctx) ast_compound_statement(true, $3);
      $$->set_location_range(@@1, @@4);
      state->symbols->pop_scope();
   }
   ;

statement_no_new_scope:
   compound_statement_no_new_scope { $$ = (ast_node *) $1; }
   | simple_statement
   ;

compound_statement_no_new_scope:
   '{' '}'
   {
      void *ctx = state;
      $$ = new(ctx) ast_compound_statement(false, NULL);
      $$->set_location_range(@@1, @@2);
   }
   | '{' statement_list '}'
   {
      void *ctx = state;
      $$ = new(ctx) ast_compound_statement(false, $2);
      $$->set_location_range(@@1, @@3);
   }
   ;

statement_list:
   statement
   {
      if ($1 == NULL) {
         _mesa_glsl_error(& @@1, state, "<nil> statement");
         assert($1 != NULL);
      }

      $$ = $1;
      $$->link.self_link();
   }
   | statement_list statement
   {
      if ($2 == NULL) {
         _mesa_glsl_error(& @@2, state, "<nil> statement");
         assert($2 != NULL);
      }
      $$ = $1;
      $$->link.insert_before(& $2->link);
   }
   ;

expression_statement:
   ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_statement(NULL);
      $$->set_location(@@1);
   }
   | expression ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_statement($1);
      $$->set_location(@@1);
   }
   ;

selection_statement:
   IF '(' expression ')' selection_rest_statement
   {
      $$ = new(state) ast_selection_statement($3, $5.then_statement,
                                              $5.else_statement);
      $$->set_location_range(@@1, @@5);
   }
   ;

selection_rest_statement:
   statement ELSE statement
   {
      $$.then_statement = $1;
      $$.else_statement = $3;
   }
   | statement %prec THEN
   {
      $$.then_statement = $1;
      $$.else_statement = NULL;
   }
   ;

condition:
   expression
   {
      $$ = (ast_node *) $1;
   }
   | fully_specified_type any_identifier '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, NULL, $4);
      ast_declarator_list *declarator = new(ctx) ast_declarator_list($1);
      decl->set_location_range(@@2, @@4);
      declarator->set_location(@@1);

      declarator->declarations.push_tail(&decl->link);
      $$ = declarator;
   }
   ;

/*
 * siwtch_statement grammar is based on the syntax described in the body
 * of the GLSL spec, not in it's appendix!!!
 */
switch_statement:
   SWITCH '(' expression ')' switch_body
   {
      $$ = new(state) ast_switch_statement($3, $5);
      $$->set_location_range(@@1, @@5);
   }
   ;

switch_body:
   '{' '}'
   {
      $$ = new(state) ast_switch_body(NULL);
      $$->set_location_range(@@1, @@2);
   }
   | '{' case_statement_list '}'
   {
      $$ = new(state) ast_switch_body($2);
      $$->set_location_range(@@1, @@3);
   }
   ;

case_label:
   CASE expression ':'
   {
      $$ = new(state) ast_case_label($2);
      $$->set_location(@@2);
   }
   | DEFAULT ':'
   {
      $$ = new(state) ast_case_label(NULL);
      $$->set_location(@@2);
   }
   ;

case_label_list:
   case_label
   {
      ast_case_label_list *labels = new(state) ast_case_label_list();

      labels->labels.push_tail(& $1->link);
      $$ = labels;
      $$->set_location(@@1);
   }
   | case_label_list case_label
   {
      $$ = $1;
      $$->labels.push_tail(& $2->link);
   }
   ;

case_statement:
   case_label_list statement
   {
      ast_case_statement *stmts = new(state) ast_case_statement($1);
      stmts->set_location(@@2);

      stmts->stmts.push_tail(& $2->link);
      $$ = stmts;
   }
   | case_statement statement
   {
      $$ = $1;
      $$->stmts.push_tail(& $2->link);
   }
   ;

case_statement_list:
   case_statement
   {
      ast_case_statement_list *cases= new(state) ast_case_statement_list();
      cases->set_location(@@1);

      cases->cases.push_tail(& $1->link);
      $$ = cases;
   }
   | case_statement_list case_statement
   {
      $$ = $1;
      $$->cases.push_tail(& $2->link);
   }
   ;

iteration_statement:
   WHILE '(' condition ')' statement_no_new_scope
   {
      void *ctx = state;
      $$ = new(ctx) ast_iteration_statement(ast_iteration_statement::ast_while,
                                            NULL, $3, NULL, $5);
      $$->set_location_range(@@1, @@4);
   }
   | DO statement WHILE '(' expression ')' ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_iteration_statement(ast_iteration_statement::ast_do_while,
                                            NULL, $5, NULL, $2);
      $$->set_location_range(@@1, @@6);
   }
   | FOR '(' for_init_statement for_rest_statement ')' statement_no_new_scope
   {
      void *ctx = state;
      $$ = new(ctx) ast_iteration_statement(ast_iteration_statement::ast_for,
                                            $3, $4.cond, $4.rest, $6);
      $$->set_location_range(@@1, @@6);
   }
   ;

for_init_statement:
   expression_statement
   | declaration_statement
   ;

conditionopt:
   condition
   | /* empty */
   {
      $$ = NULL;
   }
   ;

for_rest_statement:
   conditionopt ';'
   {
      $$.cond = $1;
      $$.rest = NULL;
   }
   | conditionopt ';' expression
   {
      $$.cond = $1;
      $$.rest = $3;
   }
   ;

   // Grammar Note: No 'goto'. Gotos are not supported.
jump_statement:
   CONTINUE ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_continue, NULL);
      $$->set_location(@@1);
   }
   | BREAK ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_break, NULL);
      $$->set_location(@@1);
   }
   | RETURN ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_return, NULL);
      $$->set_location(@@1);
   }
   | RETURN expression ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_return, $2);
      $$->set_location_range(@@1, @@2);
   }
   | DISCARD ';' // Fragment shader only.
   {
      void *ctx = state;
      $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_discard, NULL);
      $$->set_location(@@1);
   }
   ;

external_declaration:
   function_definition      { $$ = $1; }
   | declaration            { $$ = $1; }
   | pragma_statement       { $$ = NULL; }
   | layout_defaults        { $$ = $1; }
   ;

function_definition:
   function_prototype compound_statement_no_new_scope
   {
      void *ctx = state;
      $$ = new(ctx) ast_function_definition();
      $$->set_location_range(@@1, @@2);
      $$->prototype = $1;
      $$->body = $2;

      state->symbols->pop_scope();
   }
   ;

/* layout_qualifieropt is packed into this rule */
interface_block:
   basic_interface_block
   {
      $$ = $1;
   }
   | layout_qualifier basic_interface_block
   {
      ast_interface_block *block = $2;
      if (!block->layout.merge_qualifier(& @@1, state, $1)) {
         YYERROR;
      }
      $$ = block;
   }
   ;

basic_interface_block:
   interface_qualifier NEW_IDENTIFIER '{' member_list '}' instance_name_opt ';'
   {
      ast_interface_block *const block = $6;

      block->block_name = $2;
      block->declarations.push_degenerate_list_at_head(& $4->link);

      if ($1.flags.q.uniform) {
         if (!state->has_uniform_buffer_objects()) {
            _mesa_glsl_error(& @@1, state,
                             "#version 140 / GL_ARB_uniform_buffer_object "
                             "required for defining uniform blocks");
         } else if (state->ARB_uniform_buffer_object_warn) {
            _mesa_glsl_warning(& @@1, state,
                               "#version 140 / GL_ARB_uniform_buffer_object "
                               "required for defining uniform blocks");
         }
      } else {
         if (state->es_shader || state->language_version < 150) {
            _mesa_glsl_error(& @@1, state,
                             "#version 150 required for using "
                             "interface blocks");
         }
      }

      /* From the GLSL 1.50.11 spec, section 4.3.7 ("Interface Blocks"):
       * "It is illegal to have an input block in a vertex shader
       *  or an output block in a fragment shader"
       */
      if ((state->stage == MESA_SHADER_VERTEX) && $1.flags.q.in) {
         _mesa_glsl_error(& @@1, state,
                          "`in' interface block is not allowed for "
                          "a vertex shader");
      } else if ((state->stage == MESA_SHADER_FRAGMENT) && $1.flags.q.out) {
         _mesa_glsl_error(& @@1, state,
                          "`out' interface block is not allowed for "
                          "a fragment shader");
      }

      /* Since block arrays require names, and both features are added in
       * the same language versions, we don't have to explicitly
       * version-check both things.
       */
      if (block->instance_name != NULL) {
         state->check_version(150, 300, & @@1, "interface blocks with "
                               "an instance name are not allowed");
      }

      uint64_t interface_type_mask;
      struct ast_type_qualifier temp_type_qualifier;

      /* Get a bitmask containing only the in/out/uniform flags, allowing us
       * to ignore other irrelevant flags like interpolation qualifiers.
       */
      temp_type_qualifier.flags.i = 0;
      temp_type_qualifier.flags.q.uniform = true;
      temp_type_qualifier.flags.q.in = true;
      temp_type_qualifier.flags.q.out = true;
      interface_type_mask = temp_type_qualifier.flags.i;

      /* Get the block's interface qualifier.  The interface_qualifier
       * production rule guarantees that only one bit will be set (and
       * it will be in/out/uniform).
       */
      uint64_t block_interface_qualifier = $1.flags.i;

      block->layout.flags.i |= block_interface_qualifier;

      foreach_list_typed (ast_declarator_list, member, link, &block->declarations) {
         ast_type_qualifier& qualifier = member->type->qualifier;
         if ((qualifier.flags.i & interface_type_mask) == 0) {
            /* GLSLangSpec.1.50.11, 4.3.7 (Interface Blocks):
             * "If no optional qualifier is used in a member declaration, the
             *  qualifier of the variable is just in, out, or uniform as declared
             *  by interface-qualifier."
             */
            qualifier.flags.i |= block_interface_qualifier;
         } else if ((qualifier.flags.i & interface_type_mask) !=
                    block_interface_qualifier) {
            /* GLSLangSpec.1.50.11, 4.3.7 (Interface Blocks):
             * "If optional qualifiers are used, they can include interpolation
             *  and storage qualifiers and they must declare an input, output,
             *  or uniform variable consistent with the interface qualifier of
             *  the block."
             */
            _mesa_glsl_error(& @@1, state,
                             "uniform/in/out qualifier on "
                             "interface block member does not match "
                             "the interface block");
         }
      }

      $$ = block;
   }
   ;

interface_qualifier:
   IN_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.in = 1;
   }
   | OUT_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.out = 1;
   }
   | UNIFORM
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.uniform = 1;
   }
   ;

instance_name_opt:
   /* empty */
   {
      $$ = new(state) ast_interface_block(*state->default_uniform_qualifier,
                                          NULL, NULL);
   }
   | NEW_IDENTIFIER
   {
      $$ = new(state) ast_interface_block(*state->default_uniform_qualifier,
                                          $1, NULL);
      $$->set_location(@@1);
   }
   | NEW_IDENTIFIER array_specifier
   {
      $$ = new(state) ast_interface_block(*state->default_uniform_qualifier,
                                          $1, $2);
      $$->set_location_range(@@1, @@2);
   }
   ;

member_list:
   member_declaration
   {
      $$ = $1;
      $1->link.self_link();
   }
   | member_declaration member_list
   {
      $$ = $1;
      $2->link.insert_before(& $$->link);
   }
   ;

member_declaration:
   fully_specified_type struct_declarator_list ';'
   {
      void *ctx = state;
      ast_fully_specified_type *type = $1;
      type->set_location(@@1);

      if (type->qualifier.flags.q.attribute) {
         _mesa_glsl_error(& @@1, state,
                          "keyword 'attribute' cannot be used with "
                          "interface block member");
      } else if (type->qualifier.flags.q.varying) {
         _mesa_glsl_error(& @@1, state,
                          "keyword 'varying' cannot be used with "
                          "interface block member");
      }

      $$ = new(ctx) ast_declarator_list(type);
      $$->set_location(@@2);

      $$->declarations.push_degenerate_list_at_head(& $2->link);
   }
   ;

layout_defaults:
   layout_qualifier UNIFORM ';'
   {
      if (!state->default_uniform_qualifier->merge_qualifier(& @@1, state, $1)) {
         YYERROR;
      }
      $$ = NULL;
   }

   | layout_qualifier IN_TOK ';'
   {
      $$ = NULL;
      if (!state->in_qualifier->merge_in_qualifier(& @@1, state, $1, $$)) {
         YYERROR;
      }
   }

   | layout_qualifier OUT_TOK ';'
   {
      if (state->stage != MESA_SHADER_GEOMETRY) {
         _mesa_glsl_error(& @@1, state,
                          "out layout qualifiers only valid in "
                          "geometry shaders");
      } else {
         if ($1.flags.q.prim_type) {
            /* Make sure this is a valid output primitive type. */
            switch ($1.prim_type) {
            case GL_POINTS:
            case GL_LINE_STRIP:
            case GL_TRIANGLE_STRIP:
               break;
            default:
               _mesa_glsl_error(&@@1, state, "invalid geometry shader output "
                                "primitive type");
               break;
            }
         }
         if (!state->out_qualifier->merge_qualifier(& @@1, state, $1))
            YYERROR;
      }
      $$ = NULL;
   }
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a26 3
#ifndef _MSC_VER
#include <strings.h>
#endif
d131 1
a131 1
%token CENTROID IN_TOK OUT_TOK INOUT_TOK UNIFORM VARYING SAMPLE
d169 1
a169 1
%token INVARIANT PRECISE
d182 1
a182 1
%token LONG_TOK SHORT_TOK DOUBLE_TOK HALF FIXED_TOK UNSIGNED INPUT_TOK
d186 1
a186 1
%token RESOURCE PATCH
a378 8
   | external_declaration_list extension_statement {
      if (!state->allow_extension_directive_midshader) {
         _mesa_glsl_error(& @@2, state,
                          "#extension directive is not allowed "
                          "in the middle of a shader");
         YYERROR;
      }
   }
a933 8
   | PRECISE parameter_qualifier
   {
      if ($2.flags.q.precise)
         _mesa_glsl_error(&@@1, state, "duplicate precise qualifier");

      $$ = $2;
      $$.flags.q.precise = 1;
   }
d940 2
a941 2
         _mesa_glsl_error(&@@1, state, "in/out/inout must come after const "
                                      "or precise");
d1074 1
a1074 1
   | INVARIANT variable_identifier
a1085 12
   | PRECISE variable_identifier
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, NULL, NULL);
      decl->set_location(@@2);

      $$ = new(ctx) ast_declarator_list(NULL);
      $$->set_location_range(@@1, @@2);
      $$->precise = true;

      $$->declarations.push_tail(&decl->link);
   }
a1377 16
      if (state->stage == MESA_SHADER_GEOMETRY) {
         if (match_layout_qualifier("stream", $1, state) == 0 &&
             state->check_explicit_attrib_stream_allowed(& @@3)) {
            $$.flags.q.stream = 1;

            if ($3 < 0) {
               _mesa_glsl_error(& @@3, state,
                                "invalid stream %d specified", $3);
               YYERROR;
            } else {
               $$.flags.q.explicit_stream = 1;
               $$.stream = $3;
            }
         }
      }

a1500 5
   | PRECISE
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.precise = 1;
   }
d1521 1
a1521 1
    * no auxiliary, interpolation, layout, invariant, or precise qualifiers to the right.
a1522 8
   | PRECISE type_qualifier
   {
      if ($2.flags.q.precise)
         _mesa_glsl_error(&@@1, state, "duplicate \"precise\" qualifier");

      $$ = $2;
      $$.flags.q.precise = 1;
   }
d1528 1
a1528 1
      if (!state->ARB_shading_language_420pack_enable && $2.flags.q.precise)
d1530 2
a1531 1
                          "\"invariant\" must come after \"precise\"");
d1551 6
a1556 2
      if (!state->ARB_shading_language_420pack_enable &&
          ($2.flags.q.precise || $2.flags.q.invariant)) {
d1558 1
a1558 1
                          "after \"precise\" or \"invariant\"");
d1566 5
a1570 8
      /* In the absence of ARB_shading_language_420pack, layout qualifiers may
       * appear no later than auxiliary storage qualifiers. There is no
       * particularly clear spec language mandating this, but in all examples
       * the layout qualifier precedes the storage qualifier.
       *
       * We allow combinations of layout with interpolation, invariant or
       * precise qualifiers since these are useful in ARB_separate_shader_objects.
       * There is no clear spec guidance on this either.
d1575 9
d1595 1
a1595 2
          ($2.flags.q.precise || $2.flags.q.invariant ||
           $2.has_interpolation() || $2.has_layout())) {
d1612 2
a1613 2
          ($2.flags.q.precise || $2.flags.q.invariant || $2.has_interpolation() ||
           $2.has_layout() || $2.has_auxiliary_storage())) {
d1615 1
a1615 1
                          "precise, invariant, interpolation, layout and auxiliary "
a1672 14

      if (state->stage == MESA_SHADER_GEOMETRY &&
          state->has_explicit_attrib_stream()) {
         /* Section 4.3.8.2 (Output Layout Qualifiers) of the GLSL 4.00
          * spec says:
          *
          *     "If the block or variable is declared with the stream
          *     identifier, it is associated with the specified stream;
          *     otherwise, it is associated with the current default stream."
          */
          $$.flags.q.stream = 1;
          $$.flags.q.explicit_stream = 0;
          $$.stream = state->out_qualifier->stream;
      }
d2140 1
a2140 1
 * switch_statement grammar is based on the syntax described in the body
a2340 12

      foreach_list_typed (ast_declarator_list, member, link, &block->declarations) {
         ast_type_qualifier& qualifier = member->type->qualifier;
         if (qualifier.flags.q.stream && qualifier.stream != block->layout.stream) {
               _mesa_glsl_error(& @@1, state,
                             "stream layout qualifier on "
                             "interface block member does not match "
                             "the interface block (%d vs %d)",
                             qualifier.stream, block->layout.stream);
               YYERROR;
         }
      }
a2413 8
      if (state->stage == MESA_SHADER_GEOMETRY &&
          state->has_explicit_attrib_stream()) {
         /* Assign global layout's stream value. */
         block->layout.flags.q.stream = 1;
         block->layout.flags.q.explicit_stream = 0;
         block->layout.stream = state->out_qualifier->stream;
      }

a2555 3

         /* Allow future assigments of global out's stream id value */
         state->out_qualifier->flags.q.explicit_stream = 0;
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d27 3
d134 1
a134 1
%token CENTROID IN_TOK OUT_TOK INOUT_TOK UNIFORM VARYING
d172 1
a172 1
%token INVARIANT
d185 1
a185 1
%token LONG_TOK SHORT_TOK DOUBLE_TOK HALF FIXED_TOK UNSIGNED INPUT_TOK OUPTUT
d189 1
a189 1
%token RESOURCE PATCH SAMPLE
d382 8
d945 8
d959 2
a960 2
         _mesa_glsl_error(&@@1, state, "const must be specified before "
                          "in/out/inout");
d1093 1
a1093 1
   | INVARIANT variable_identifier // Vertex only.
d1105 12
d1409 16
d1548 5
d1573 1
a1573 1
    * no auxiliary, interpolation, layout, or invariant qualifiers to the right.
d1575 8
d1588 1
a1588 1
      if ($2.has_layout()) {
d1590 1
a1590 2
                          "\"invariant\" cannot be used with layout(...)");
      }
d1610 2
a1611 6
      if ($2.has_layout()) {
         _mesa_glsl_error(&@@1, state, "interpolation qualifiers cannot be used "
                          "with layout(...)");
      }

      if (!state->ARB_shading_language_420pack_enable && $2.flags.q.invariant) {
d1613 1
a1613 1
                          "after \"invariant\"");
d1621 8
a1628 5
      /* The GLSL 1.50 grammar indicates that a layout(...) declaration can be
       * used standalone or immediately before a storage qualifier.  It cannot
       * be used with interpolation qualifiers or invariant.  There does not
       * appear to be any text indicating that it must come before the storage
       * qualifier, but always seems to in examples.
a1632 9
      if ($2.flags.q.invariant)
         _mesa_glsl_error(&@@1, state, "layout(...) cannot be used with "
                          "the \"invariant\" qualifier");

      if ($2.has_interpolation()) {
         _mesa_glsl_error(&@@1, state, "layout(...) cannot be used with "
                          "interpolation qualifiers");
      }

d1644 2
a1645 1
          ($2.flags.q.invariant || $2.has_interpolation() || $2.has_layout())) {
d1662 2
a1663 2
          ($2.flags.q.invariant || $2.has_interpolation() || $2.has_layout() ||
           $2.has_auxiliary_storage())) {
d1665 1
a1665 1
                          "invariant, interpolation, layout and auxiliary "
d1723 14
d2204 1
a2204 1
 * siwtch_statement grammar is based on the syntax described in the body
d2405 12
d2490 8
d2640 3
@


1.3
log
@Merge Mesa 9.2.1
@
text
@d46 26
d100 1
d148 9
d181 1
a181 1
%token INLINE_TOK NOINLINE VOLATILE PUBLIC_TOK STATIC EXTERN EXTERNAL
d186 1
a186 1
%token COHERENT RESTRICT READONLY WRITEONLY RESOURCE ATOMIC_UINT PATCH SAMPLE
d191 1
a191 7
%token COMMON PARTITION ACTIVE FILTER
%token  IMAGE1D  IMAGE2D  IMAGE3D  IMAGECUBE  IMAGE1DARRAY  IMAGE2DARRAY
%token IIMAGE1D IIMAGE2D IIMAGE3D IIMAGECUBE IIMAGE1DARRAY IIMAGE2DARRAY
%token UIMAGE1D UIMAGE2D UIMAGE3D UIMAGECUBE UIMAGE1DARRAY UIMAGE2DARRAY
%token IMAGE1DSHADOW IMAGE2DSHADOW IMAGEBUFFER IIMAGEBUFFER UIMAGEBUFFER
%token IMAGE1DARRAYSHADOW IMAGE2DARRAYSHADOW
%token ROW_MAJOR
d208 1
d288 1
d334 1
a334 1
                            "(GLSL ES 1.00 or GLSL 1.20 required).",
d391 1
a391 1
      $$->set_location(yylloc);
d398 1
a398 1
      $$->set_location(yylloc);
d405 1
a405 1
      $$->set_location(yylloc);
d412 1
a412 1
      $$->set_location(yylloc);
d419 1
a419 1
      $$->set_location(yylloc);
d434 1
a434 1
      $$->set_location(yylloc);
d444 1
a444 1
      $$->set_location(yylloc);
d451 1
a451 1
      $$->set_location(yylloc);
d457 1
a457 1
      $$->set_location(yylloc);
d475 1
a475 1
      $$->set_location(yylloc);
d493 1
a493 1
      $$->set_location(yylloc);
d499 1
a499 1
      $$->set_location(yylloc);
d516 1
a516 1
      $$->set_location(yylloc);
d522 1
d524 1
a524 1
      $$->set_location(yylloc);
d530 1
d532 1
a532 1
      $$->set_location(yylloc);
d550 1
a550 1
      $$->set_location(yylloc);
d556 1
a556 1
      $$->set_location(yylloc);
d569 1
d571 1
a571 1
      $$->set_location(yylloc);
d582 1
a582 1
      $$->set_location(yylloc);
d588 1
a588 1
      $$->set_location(yylloc);
d594 1
a594 1
      $$->set_location(yylloc);
d612 1
a612 1
      $$->set_location(yylloc);
d618 1
a618 1
      $$->set_location(yylloc);
d624 1
a624 1
      $$->set_location(yylloc);
d634 1
a634 1
      $$->set_location(yylloc);
d640 1
a640 1
      $$->set_location(yylloc);
d650 1
a650 1
      $$->set_location(yylloc);
d656 1
a656 1
      $$->set_location(yylloc);
d666 1
a666 1
      $$->set_location(yylloc);
d672 1
a672 1
      $$->set_location(yylloc);
d678 1
a678 1
      $$->set_location(yylloc);
d684 1
a684 1
      $$->set_location(yylloc);
d694 1
a694 1
      $$->set_location(yylloc);
d700 1
a700 1
      $$->set_location(yylloc);
d710 1
a710 1
      $$->set_location(yylloc);
d720 1
a720 1
      $$->set_location(yylloc);
d730 1
a730 1
      $$->set_location(yylloc);
d740 1
a740 1
      $$->set_location(yylloc);
d750 1
a750 1
      $$->set_location(yylloc);
d760 1
a760 1
      $$->set_location(yylloc);
d770 1
a770 1
      $$->set_location(yylloc);
d780 1
a780 1
      $$->set_location(yylloc);
d808 1
a808 1
         $$->set_location(yylloc);
d870 1
a870 1
      $$->set_location(yylloc);
d884 1
a884 1
      $$->set_location(yylloc);
d886 1
a886 1
      $$->type->set_location(yylloc);
d890 1
a890 1
   | type_specifier any_identifier '[' constant_expression ']'
d894 1
a894 1
      $$->set_location(yylloc);
d896 1
a896 1
      $$->type->set_location(yylloc);
d899 1
a899 2
      $$->is_array = true;
      $$->array_size = $4;
d913 1
a913 1
      $$->set_location(yylloc);
d915 1
d929 1
a929 1
         _mesa_glsl_error(&@@1, state, "duplicate const qualifier.\n");
d937 1
a937 1
         _mesa_glsl_error(&@@1, state, "duplicate in/out/inout qualifier\n");
d941 1
a941 1
                          "in/out/inout.\n");
d949 1
a949 1
         _mesa_glsl_error(&@@1, state, "Duplicate precision qualifier.\n");
d952 1
a952 1
         _mesa_glsl_error(&@@1, state, "Precision qualifiers must come last.\n");
d986 2
a987 2
      ast_declaration *decl = new(ctx) ast_declaration($3, false, NULL, NULL);
      decl->set_location(yylloc);
d993 1
a993 1
   | init_declarator_list ',' any_identifier '[' ']'
d996 2
a997 2
      ast_declaration *decl = new(ctx) ast_declaration($3, true, NULL, NULL);
      decl->set_location(yylloc);
d1003 1
a1003 1
   | init_declarator_list ',' any_identifier '[' constant_expression ']'
d1006 2
a1007 2
      ast_declaration *decl = new(ctx) ast_declaration($3, true, $5, NULL);
      decl->set_location(yylloc);
a1012 30
   | init_declarator_list ',' any_identifier '[' ']' '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($3, true, NULL, $7);
      decl->set_location(yylloc);

      $$ = $1;
      $$->declarations.push_tail(&decl->link);
      state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
      if ($7->oper == ast_aggregate) {
         ast_aggregate_initializer *ai = (ast_aggregate_initializer *)$7;
         ast_type_specifier *type = new(ctx) ast_type_specifier($1->type->specifier, true, NULL);
         _mesa_ast_set_aggregate_type(type, ai, state);
      }
   }
   | init_declarator_list ',' any_identifier '[' constant_expression ']' '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($3, true, $5, $8);
      decl->set_location(yylloc);

      $$ = $1;
      $$->declarations.push_tail(&decl->link);
      state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
      if ($8->oper == ast_aggregate) {
         ast_aggregate_initializer *ai = (ast_aggregate_initializer *)$8;
         ast_type_specifier *type = new(ctx) ast_type_specifier($1->type->specifier, true, $5);
         _mesa_ast_set_aggregate_type(type, ai, state);
      }
   }
d1016 2
a1017 2
      ast_declaration *decl = new(ctx) ast_declaration($3, false, NULL, $5);
      decl->set_location(yylloc);
a1021 4
      if ($5->oper == ast_aggregate) {
         ast_aggregate_initializer *ai = (ast_aggregate_initializer *)$5;
         _mesa_ast_set_aggregate_type($1->type->specifier, ai, state);
      }
d1032 1
a1032 1
      $$->set_location(yylloc);
d1037 2
a1038 19
      ast_declaration *decl = new(ctx) ast_declaration($2, false, NULL, NULL);

      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location(yylloc);
      $$->declarations.push_tail(&decl->link);
   }
   | fully_specified_type any_identifier '[' ']'
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, true, NULL, NULL);

      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location(yylloc);
      $$->declarations.push_tail(&decl->link);
   }
   | fully_specified_type any_identifier '[' constant_expression ']'
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, true, $4, NULL);
d1041 1
a1041 1
      $$->set_location(yylloc);
d1044 1
a1044 1
   | fully_specified_type any_identifier '[' ']' '=' initializer
d1047 2
a1048 1
      ast_declaration *decl = new(ctx) ast_declaration($2, true, NULL, $6);
d1051 1
a1051 1
      $$->set_location(yylloc);
a1052 5
      if ($6->oper == ast_aggregate) {
         ast_aggregate_initializer *ai = (ast_aggregate_initializer *)$6;
         ast_type_specifier *type = new(ctx) ast_type_specifier($1->specifier, true, NULL);
         _mesa_ast_set_aggregate_type(type, ai, state);
      }
d1054 1
a1054 1
   | fully_specified_type any_identifier '[' constant_expression ']' '=' initializer
d1057 2
a1058 1
      ast_declaration *decl = new(ctx) ast_declaration($2, true, $4, $7);
d1061 1
a1061 1
      $$->set_location(yylloc);
a1062 5
      if ($7->oper == ast_aggregate) {
         ast_aggregate_initializer *ai = (ast_aggregate_initializer *)$7;
         ast_type_specifier *type = new(ctx) ast_type_specifier($1->specifier, true, $4);
         _mesa_ast_set_aggregate_type(type, ai, state);
      }
d1067 2
a1068 1
      ast_declaration *decl = new(ctx) ast_declaration($2, false, NULL, $4);
d1071 1
a1071 1
      $$->set_location(yylloc);
a1072 3
      if ($4->oper == ast_aggregate) {
         _mesa_ast_set_aggregate_type($1->specifier, $4, state);
      }
d1077 2
a1078 1
      ast_declaration *decl = new(ctx) ast_declaration($2, false, NULL, NULL);
d1081 1
a1081 1
      $$->set_location(yylloc);
d1093 1
a1093 1
      $$->set_location(yylloc);
d1100 1
a1100 1
      $$->set_location(yylloc);
d1135 3
a1137 2
      if (!$$.flags.i && state->ARB_fragment_coord_conventions_enable) {
         if (strcmp($1, "origin_upper_left") == 0) {
d1139 2
a1140 1
         } else if (strcmp($1, "pixel_center_integer") == 0) {
d1147 1
a1147 1
                               "identifier `%s' used\n", $1);
d1155 1
a1155 1
         if (strcmp($1, "depth_any") == 0) {
d1157 1
a1157 1
         } else if (strcmp($1, "depth_greater") == 0) {
d1159 1
a1159 1
         } else if (strcmp($1, "depth_less") == 0) {
d1161 2
a1162 1
         } else if (strcmp($1, "depth_unchanged") == 0) {
d1169 1
a1169 1
                               "layout qualifier `%s' is used\n", $1);
d1174 1
a1174 1
                               "layout qualifier `%s' is used\n", $1);
d1179 2
a1180 2
      if (!$$.flags.i && state->ARB_uniform_buffer_object_enable) {
         if (strcmp($1, "std140") == 0) {
d1182 1
a1182 1
         } else if (strcmp($1, "shared") == 0) {
d1184 1
a1184 1
         } else if (strcmp($1, "column_major") == 0) {
d1191 4
d1196 1
a1196 1
         } else if (strcmp($1, "row_major") == 0) {
d1198 8
d1211 95
a1305 1
                               "layout qualifier `%s' is used\n", $1);
d1311 1
a1311 1
                          "`%s'\n", $1);
d1319 2
a1320 3
      if (state->ARB_explicit_attrib_location_enable) {
         if (strcmp("location", $1) == 0) {
            $$.flags.q.explicit_location = 1;
d1322 49
a1370 3
            if ($3 >= 0) {
               $$.location = $3;
            } else {
d1372 2
a1373 2
                                "invalid location %d specified\n", $3);
               YYERROR;
d1376 1
d1378 15
a1392 6
         if (strcmp("index", $1) == 0) {
            $$.flags.q.explicit_index = 1;

            if ($3 >= 0) {
               $$.index = $3;
            } else {
d1394 3
a1396 1
                                "invalid index %d specified\n", $3);
d1398 3
d1402 1
d1406 21
a1426 4
      if (state->ARB_shading_language_420pack_enable &&
          strcmp("binding", $1) == 0) {
         $$.flags.q.explicit_binding = 1;
         $$.binding = $3;
d1434 1
a1434 1
                          "`%s'\n", $1);
a1435 4
      } else if (state->ARB_explicit_attrib_location_warn) {
         _mesa_glsl_warning(& @@1, state,
                            "GL_ARB_explicit_attrib_location layout "
                            "identifier `%s' used\n", $1);
d1442 1
a1442 1
      if ($$.flags.q.uniform && !state->ARB_uniform_buffer_object_enable) {
d1445 1
a1445 1
                          "layout qualifier `%s' is used\n", $1);
d1449 1
a1449 1
                            "layout qualifier `%s' is used\n", $1);
d1458 4
d1526 1
a1526 1
         _mesa_glsl_error(&@@1, state, "Duplicate \"invariant\" qualifier.\n");
d1530 1
a1530 1
                          "\"invariant\" cannot be used with layout(...).\n");
d1549 1
a1549 1
         _mesa_glsl_error(&@@1, state, "Duplicate interpolation qualifier.\n");
d1552 2
a1553 2
         _mesa_glsl_error(&@@1, state, "Interpolation qualifiers cannot be used "
                          "with layout(...).\n");
d1557 2
a1558 2
         _mesa_glsl_error(&@@1, state, "Interpolation qualifiers must come "
                          "after \"invariant\".\n");
d1573 1
a1573 1
         _mesa_glsl_error(&@@1, state, "Duplicate layout(...) qualifiers.\n");
d1577 1
a1577 1
                          "the \"invariant\" qualifier\n");
d1581 1
a1581 1
                          "interpolation qualifiers.\n");
d1591 1
a1591 1
                          "Duplicate auxiliary storage qualifier (centroid).\n");
d1596 2
a1597 2
         _mesa_glsl_error(&@@1, state, "Auxiliary storage qualifiers must come "
                          "just before storage qualifiers.\n");
d1600 1
a1600 1
      $$.flags.i |= $2.flags.i;
d1609 1
a1609 1
         _mesa_glsl_error(&@@1, state, "Duplicate storage qualifier.\n");
d1614 1
a1614 1
         _mesa_glsl_error(&@@1, state, "Storage qualifiers must come after "
d1616 1
a1616 1
                          "storage qualifiers.\n");
d1625 1
a1625 1
         _mesa_glsl_error(&@@1, state, "Duplicate precision qualifier.\n");
d1628 1
a1628 1
         _mesa_glsl_error(&@@1, state, "Precision qualifiers must come last.\n");
d1641 6
a1646 1
   /* TODO: "sample" and "patch" also go here someday. */
d1679 26
d1707 28
a1734 3
type_specifier:
   type_specifier_nonarray
   | type_specifier_nonarray '[' ']'
d1737 8
a1744 2
      $$->is_array = true;
      $$->array_size = NULL;
d1746 5
a1750 1
   | type_specifier_nonarray '[' constant_expression ']'
d1753 1
a1753 2
      $$->is_array = true;
      $$->array_size = $3;
d1762 1
a1762 1
      $$->set_location(yylloc);
d1768 1
a1768 1
      $$->set_location(yylloc);
d1774 1
a1774 1
      $$->set_location(yylloc);
d1846 34
d1905 1
a1905 1
      $$->set_location(yylloc);
a1906 1
      state->symbols->add_type_ast($2, new(ctx) ast_type_specifier($$));
d1912 1
a1912 1
      $$->set_location(yylloc);
d1934 1
a1934 1
      type->set_location(yylloc);
d1942 1
a1942 1
      $$->set_location(yylloc);
d1965 2
a1966 2
      $$ = new(ctx) ast_declaration($1, false, NULL, NULL);
      $$->set_location(yylloc);
d1968 1
a1968 1
   | any_identifier '[' constant_expression ']'
d1971 2
a1972 2
      $$ = new(ctx) ast_declaration($1, true, $3, NULL);
      $$->set_location(yylloc);
d1993 1
a1993 1
      $$->set_location(yylloc);
d2027 1
a2027 1
      $$->set_location(yylloc);
d2037 1
a2037 1
      $$->set_location(yylloc);
d2052 1
a2052 1
      $$->set_location(yylloc);
d2058 1
a2058 1
      $$->set_location(yylloc);
d2066 1
a2066 1
         _mesa_glsl_error(& @@1, state, "<nil> statement\n");
d2076 1
a2076 1
         _mesa_glsl_error(& @@2, state, "<nil> statement\n");
d2089 1
a2089 1
      $$->set_location(yylloc);
d2095 1
a2095 1
      $$->set_location(yylloc);
d2104 1
a2104 1
      $$->set_location(yylloc);
d2129 1
a2129 1
      ast_declaration *decl = new(ctx) ast_declaration($2, false, NULL, $4);
d2131 2
a2132 2
      decl->set_location(yylloc);
      declarator->set_location(yylloc);
d2147 1
a2147 1
      $$->set_location(yylloc);
d2155 1
a2155 1
      $$->set_location(yylloc);
d2160 1
a2160 1
      $$->set_location(yylloc);
d2168 1
a2168 1
      $$->set_location(yylloc);
d2173 1
a2173 1
      $$->set_location(yylloc);
d2184 1
a2184 1
      $$->set_location(yylloc);
d2197 1
a2197 1
      stmts->set_location(yylloc);
d2213 1
a2213 1
      cases->set_location(yylloc);
d2231 1
a2231 1
      $$->set_location(yylloc);
d2238 1
a2238 1
      $$->set_location(yylloc);
d2245 1
a2245 1
      $$->set_location(yylloc);
d2281 1
a2281 1
      $$->set_location(yylloc);
d2287 1
a2287 1
      $$->set_location(yylloc);
d2293 1
a2293 1
      $$->set_location(yylloc);
d2299 1
a2299 1
      $$->set_location(yylloc);
d2305 1
a2305 1
      $$->set_location(yylloc);
d2313 1
a2313 1
   | layout_defaults        { $$ = NULL; }
d2321 1
a2321 1
      $$->set_location(yylloc);
d2354 1
a2354 1
         if (!state->ARB_uniform_buffer_object_enable) {
d2357 1
a2357 1
                             "required for defining uniform blocks\n");
d2361 1
a2361 1
                               "required for defining uniform blocks\n");
d2367 1
a2367 1
                             "interface blocks.\n");
d2375 1
a2375 1
      if ((state->target == vertex_shader) && $1.flags.q.in) {
d2378 2
a2379 2
                          "a vertex shader\n");
      } else if ((state->target == fragment_shader) && $1.flags.q.out) {
d2382 1
a2382 1
                          "a fragment shader\n");
d2394 1
a2394 1
      unsigned interface_type_mask;
d2410 1
a2410 1
       unsigned block_interface_qualifier = $1.flags.i;
d2434 1
a2434 1
                             "the interface block\n");
d2470 1
d2472 1
a2472 1
   | NEW_IDENTIFIER '[' constant_expression ']'
d2475 2
a2476 9
                                          $1, $3);
   }
   | NEW_IDENTIFIER '[' ']'
   {
      _mesa_glsl_error(& @@1, state,
                       "instance block arrays must be explicitly sized\n");

      $$ = new(state) ast_interface_block(*state->default_uniform_qualifier,
                                          $1, NULL);
d2498 1
a2498 1
      type->set_location(yylloc);
d2503 1
a2503 1
                          "interface block member\n");
d2507 1
a2507 1
                          "interface block member\n");
d2511 1
a2511 1
      $$->set_location(yylloc);
d2523 35
@


1.2
log
@Merge Mesa 9.2.0
@
text
@d1670 1
a1670 1
   type_specifier struct_declarator_list ';'
d1673 1
a1673 1
      ast_fully_specified_type *type = new(ctx) ast_fully_specified_type();
d1676 5
a1680 1
      type->specifier = $1;
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d28 1
a28 1
    
d32 3
d36 4
a39 1
#define YYLEX_PARAM state->scanner
d41 5
d48 2
d62 1
a62 1
%lex-param   {void *scanner}
d68 1
a68 1
   char *identifier;
d83 6
d111 10
a120 3
%token SAMPLER2DARRAYSHADOW ISAMPLER1D ISAMPLER2D ISAMPLER3D ISAMPLERCUBE
%token ISAMPLER1DARRAY ISAMPLER2DARRAY USAMPLER1D USAMPLER2D USAMPLER3D
%token USAMPLERCUBE USAMPLER1DARRAY USAMPLER2DARRAY
d124 1
d136 1
a136 1
%token VERSION EXTENSION LINE COLON EOL INTERFACE OUTPUT
d148 1
a148 1
%token SAMPLER2DRECT SAMPLER3DRECT SAMPLER2DRECTSHADOW
d150 2
d155 1
a155 1
%token COMMON PARTITION ACTIVE SAMPLERBUFFER FILTER
d169 1
d174 2
a176 1
%type <type_specifier> type_specifier_no_prec
d178 1
a178 1
%type <n> basic_type_specifier_nonarray
d187 1
a187 1
%type <type_qualifier> parameter_type_qualifier
d230 1
d234 2
d237 1
a237 1
%type <node> struct_declaration_list
d241 2
d245 6
d256 3
d261 12
a272 12
translation_unit: 
	version_statement extension_statement_list
	{
	   _mesa_glsl_initialize_types(state);
	}
	external_declaration_list
	{
	   delete state->symbols;
	   state->symbols = new(ralloc_parent(state)) glsl_symbol_table;
	   _mesa_glsl_initialize_types(state);
	}
	;
d275 16
a290 39
	/* blank - no #version specified: defaults are already set */
	| VERSION INTCONSTANT EOL
	{
	   bool supported = false;

	   switch ($2) {
	   case 100:
	      state->es_shader = true;
	      supported = state->Const.GLSL_100ES;
	      break;
	   case 110:
	      supported = state->Const.GLSL_110;
	      break;
	   case 120:
	      supported = state->Const.GLSL_120;
	      break;
	   case 130:
	      supported = state->Const.GLSL_130;
	      break;
	   default:
	      supported = false;
	      break;
	   }

	   state->language_version = $2;
	   state->version_string =
	      ralloc_asprintf(state, "GLSL%s %d.%02d",
			      state->es_shader ? " ES" : "",
			      state->language_version / 100,
			      state->language_version % 100);

	   if (!supported) {
	      _mesa_glsl_error(& @@2, state, "%s is not supported. "
			       "Supported versions are: %s\n",
			       state->version_string,
			       state->supported_version_string);
	   }
	}
	;
d293 16
a308 15
	PRAGMA_DEBUG_ON EOL
	| PRAGMA_DEBUG_OFF EOL
	| PRAGMA_OPTIMIZE_ON EOL
	| PRAGMA_OPTIMIZE_OFF EOL
	| PRAGMA_INVARIANT_ALL EOL
	{
	   if (state->language_version < 120) {
	      _mesa_glsl_warning(& @@1, state,
				 "pragma `invariant(all)' not supported in %s",
				 state->version_string);
	   } else {
	      state->all_invariant = true;
	   }
	}
	;
d312 2
a313 2
	| extension_statement_list extension_statement
	;
d316 4
a319 4
	IDENTIFIER
	| TYPE_IDENTIFIER
	| NEW_IDENTIFIER
	;
d322 7
a328 7
	EXTENSION any_identifier COLON any_identifier EOL
	{
	   if (!_mesa_glsl_process_extension($2, & @@2, $4, & @@4, state)) {
	      YYERROR;
	   }
	}
	;
d331 17
a347 17
	external_declaration
	{
	   /* FINISHME: The NULL test is required because pragmas are set to
	    * FINISHME: NULL. (See production rule for external_declaration.)
	    */
	   if ($1 != NULL)
	      state->translation_unit.push_tail(& $1->link);
	}
	| external_declaration_list external_declaration
	{
	   /* FINISHME: The NULL test is required because pragmas are set to
	    * FINISHME: NULL. (See production rule for external_declaration.)
	    */
	   if ($2 != NULL)
	      state->translation_unit.push_tail(& $2->link);
	}
	;
d350 3
a352 3
	IDENTIFIER
	| NEW_IDENTIFIER
	;
d355 40
a394 40
	variable_identifier
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_identifier, NULL, NULL, NULL);
	   $$->set_location(yylloc);
	   $$->primary_expression.identifier = $1;
	}
	| INTCONSTANT
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_int_constant, NULL, NULL, NULL);
	   $$->set_location(yylloc);
	   $$->primary_expression.int_constant = $1;
	}
	| UINTCONSTANT
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_uint_constant, NULL, NULL, NULL);
	   $$->set_location(yylloc);
	   $$->primary_expression.uint_constant = $1;
	}
	| FLOATCONSTANT
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_float_constant, NULL, NULL, NULL);
	   $$->set_location(yylloc);
	   $$->primary_expression.float_constant = $1;
	}
	| BOOLCONSTANT
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_bool_constant, NULL, NULL, NULL);
	   $$->set_location(yylloc);
	   $$->primary_expression.bool_constant = $1;
	}
	| '(' expression ')'
	{
	   $$ = $2;
	}
	;
d397 31
a427 31
	primary_expression
	| postfix_expression '[' integer_expression ']'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_array_index, $1, $3, NULL);
	   $$->set_location(yylloc);
	}
	| function_call
	{
	   $$ = $1;
	}
	| postfix_expression '.' any_identifier
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_field_selection, $1, NULL, NULL);
	   $$->set_location(yylloc);
	   $$->primary_expression.identifier = $3;
	}
	| postfix_expression INC_OP
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_post_inc, $1, NULL, NULL);
	   $$->set_location(yylloc);
	}
	| postfix_expression DEC_OP
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_post_dec, $1, NULL, NULL);
	   $$->set_location(yylloc);
	}
	;
d430 2
a431 2
	expression
	;
d434 2
a435 2
	function_call_or_method
	;
d438 8
a445 8
	function_call_generic
	| postfix_expression '.' method_call_generic
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_field_selection, $1, $3, NULL);
	   $$->set_location(yylloc);
	}
	;
d448 3
a450 3
	function_call_header_with_parameters ')'
	| function_call_header_no_parameters ')'
	;
d453 3
a455 3
	function_call_header VOID_TOK
	| function_call_header
	;
d458 17
a474 17
	function_call_header assignment_expression
	{
	   $$ = $1;
	   $$->set_location(yylloc);
	   $$->expressions.push_tail(& $2->link);
	}
	| function_call_header_with_parameters ',' assignment_expression
	{
	   $$ = $1;
	   $$->set_location(yylloc);
	   $$->expressions.push_tail(& $3->link);
	}
	;

	// Grammar Note: Constructors look like functions, but lexical 
	// analysis recognized most of them as keywords. They are now
	// recognized through "type_specifier".
d476 2
a477 2
	function_identifier '('
	;
d480 21
a500 21
	type_specifier
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_function_expression($1);
	   $$->set_location(yylloc);
   	}
	| variable_identifier
	{
	   void *ctx = state;
	   ast_expression *callee = new(ctx) ast_expression($1);
	   $$ = new(ctx) ast_function_expression(callee);
	   $$->set_location(yylloc);
   	}
	| FIELD_SELECTION
	{
	   void *ctx = state;
	   ast_expression *callee = new(ctx) ast_expression($1);
	   $$ = new(ctx) ast_function_expression(callee);
	   $$->set_location(yylloc);
   	}
	;
d503 3
a505 3
	method_call_header_with_parameters ')'
	| method_call_header_no_parameters ')'
	;
d508 3
a510 3
	method_call_header VOID_TOK
	| method_call_header
	;
d513 17
a529 17
	method_call_header assignment_expression
	{
	   $$ = $1;
	   $$->set_location(yylloc);
	   $$->expressions.push_tail(& $2->link);
	}
	| method_call_header_with_parameters ',' assignment_expression
	{
	   $$ = $1;
	   $$->set_location(yylloc);
	   $$->expressions.push_tail(& $3->link);
	}
	;

	// Grammar Note: Constructors look like methods, but lexical 
	// analysis recognized most of them as keywords. They are now
	// recognized through "type_specifier".
d531 8
a538 8
	variable_identifier '('
	{
	   void *ctx = state;
	   ast_expression *callee = new(ctx) ast_expression($1);
	   $$ = new(ctx) ast_function_expression(callee);
	   $$->set_location(yylloc);
   	}
	;
d540 1
a540 1
	// Grammar Note: No traditional style type casts.
d542 20
a561 20
	postfix_expression
	| INC_OP unary_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_pre_inc, $2, NULL, NULL);
	   $$->set_location(yylloc);
	}
	| DEC_OP unary_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_pre_dec, $2, NULL, NULL);
	   $$->set_location(yylloc);
	}
	| unary_operator unary_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression($1, $2, NULL, NULL);
	   $$->set_location(yylloc);
	}
	;
d563 1
a563 1
	// Grammar Note: No '*' or '&' unary ops. Pointers are not supported.
d565 5
a569 5
	'+'	{ $$ = ast_plus; }
	| '-'	{ $$ = ast_neg; }
	| '!'	{ $$ = ast_logic_not; }
	| '~'	{ $$ = ast_bit_not; }
	;
d572 20
a591 20
	unary_expression
	| multiplicative_expression '*' unary_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_mul, $1, $3);
	   $$->set_location(yylloc);
	}
	| multiplicative_expression '/' unary_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_div, $1, $3);
	   $$->set_location(yylloc);
	}
	| multiplicative_expression '%' unary_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_mod, $1, $3);
	   $$->set_location(yylloc);
	}
	;
d594 14
a607 14
	multiplicative_expression
	| additive_expression '+' multiplicative_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_add, $1, $3);
	   $$->set_location(yylloc);
	}
	| additive_expression '-' multiplicative_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_sub, $1, $3);
	   $$->set_location(yylloc);
	}
	;
d610 14
a623 14
	additive_expression
	| shift_expression LEFT_OP additive_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_lshift, $1, $3);
	   $$->set_location(yylloc);
	}
	| shift_expression RIGHT_OP additive_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_rshift, $1, $3);
	   $$->set_location(yylloc);
	}
	;
d626 26
a651 26
	shift_expression
	| relational_expression '<' shift_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_less, $1, $3);
	   $$->set_location(yylloc);
	}
	| relational_expression '>' shift_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_greater, $1, $3);
	   $$->set_location(yylloc);
	}
	| relational_expression LE_OP shift_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_lequal, $1, $3);
	   $$->set_location(yylloc);
	}
	| relational_expression GE_OP shift_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_gequal, $1, $3);
	   $$->set_location(yylloc);
	}
	;
d654 14
a667 14
	relational_expression
	| equality_expression EQ_OP relational_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_equal, $1, $3);
	   $$->set_location(yylloc);
	}
	| equality_expression NE_OP relational_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_nequal, $1, $3);
	   $$->set_location(yylloc);
	}
	;
d670 8
a677 8
	equality_expression
	| and_expression '&' equality_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_bit_and, $1, $3);
	   $$->set_location(yylloc);
	}
	;
d680 8
a687 8
	and_expression
	| exclusive_or_expression '^' and_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_bit_xor, $1, $3);
	   $$->set_location(yylloc);
	}
	;
d690 8
a697 8
	exclusive_or_expression
	| inclusive_or_expression '|' exclusive_or_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_bit_or, $1, $3);
	   $$->set_location(yylloc);
	}
	;
d700 8
a707 8
	inclusive_or_expression
	| logical_and_expression AND_OP inclusive_or_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_logic_and, $1, $3);
	   $$->set_location(yylloc);
	}
	;
d710 8
a717 8
	logical_and_expression
	| logical_xor_expression XOR_OP logical_and_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_logic_xor, $1, $3);
	   $$->set_location(yylloc);
	}
	;
d720 8
a727 8
	logical_xor_expression
	| logical_or_expression OR_OP logical_xor_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_bin(ast_logic_or, $1, $3);
	   $$->set_location(yylloc);
	}
	;
d730 8
a737 8
	logical_or_expression
	| logical_or_expression '?' expression ':' assignment_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression(ast_conditional, $1, $3, $5);
	   $$->set_location(yylloc);
	}
	;
d740 8
a747 8
	conditional_expression
	| unary_expression assignment_operator assignment_expression
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression($2, $1, $3, NULL);
	   $$->set_location(yylloc);
	}
	;
d750 12
a761 12
	'='		{ $$ = ast_assign; }
	| MUL_ASSIGN	{ $$ = ast_mul_assign; }
	| DIV_ASSIGN	{ $$ = ast_div_assign; }
	| MOD_ASSIGN	{ $$ = ast_mod_assign; }
	| ADD_ASSIGN	{ $$ = ast_add_assign; }
	| SUB_ASSIGN	{ $$ = ast_sub_assign; }
	| LEFT_ASSIGN	{ $$ = ast_ls_assign; }
	| RIGHT_ASSIGN	{ $$ = ast_rs_assign; }
	| AND_ASSIGN	{ $$ = ast_and_assign; }
	| XOR_ASSIGN	{ $$ = ast_xor_assign; }
	| OR_ASSIGN	{ $$ = ast_or_assign; }
	;
d764 18
a781 18
	assignment_expression
	{
	   $$ = $1;
	}
	| expression ',' assignment_expression
	{
	   void *ctx = state;
	   if ($1->oper != ast_sequence) {
	      $$ = new(ctx) ast_expression(ast_sequence, NULL, NULL, NULL);
	      $$->set_location(yylloc);
	      $$->expressions.push_tail(& $1->link);
	   } else {
	      $$ = $1;
	   }

	   $$->expressions.push_tail(& $3->link);
	}
	;
d784 2
a785 2
	conditional_expression
	;
d788 19
a806 16
	function_prototype ';'
	{
	   state->symbols->pop_scope();
	   $$ = $1;
	}
	| init_declarator_list ';'
	{
	   $$ = $1;
	}
	| PRECISION precision_qualifier type_specifier_no_prec ';'
	{
	   $3->precision = $2;
	   $3->is_precision_statement = true;
	   $$ = $3;
	}
	;
d809 2
a810 2
	function_declarator ')'
	;
d813 3
a815 3
	function_header
	| function_header_with_parameters
	;
d818 11
a828 11
	function_header parameter_declaration
	{
	   $$ = $1;
	   $$->parameters.push_tail(& $2->link);
	}
	| function_header_with_parameters ',' parameter_declaration
	{
	   $$ = $1;
	   $$->parameters.push_tail(& $3->link);
	}
	;
d831 12
a842 12
	fully_specified_type variable_identifier '('
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_function();
	   $$->set_location(yylloc);
	   $$->return_type = $1;
	   $$->identifier = $2;

	   state->symbols->add_function(new(state) ir_function($2));
	   state->symbols->push_scope();
	}
	;
d845 23
a867 23
	type_specifier any_identifier
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_parameter_declarator();
	   $$->set_location(yylloc);
	   $$->type = new(ctx) ast_fully_specified_type();
	   $$->type->set_location(yylloc);
	   $$->type->specifier = $1;
	   $$->identifier = $2;
	}
	| type_specifier any_identifier '[' constant_expression ']'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_parameter_declarator();
	   $$->set_location(yylloc);
	   $$->type = new(ctx) ast_fully_specified_type();
	   $$->type->set_location(yylloc);
	   $$->type->specifier = $1;
	   $$->identifier = $2;
	   $$->is_array = true;
	   $$->array_size = $4;
	}
	;
d870 15
a884 33
	parameter_type_qualifier parameter_qualifier parameter_declarator
	{
	   $1.flags.i |= $2.flags.i;

	   $$ = $3;
	   $$->type->qualifier = $1;
	}
	| parameter_qualifier parameter_declarator
	{
	   $$ = $2;
	   $$->type->qualifier = $1;
	}
	| parameter_type_qualifier parameter_qualifier parameter_type_specifier
	{
	   void *ctx = state;
	   $1.flags.i |= $2.flags.i;

	   $$ = new(ctx) ast_parameter_declarator();
	   $$->set_location(yylloc);
	   $$->type = new(ctx) ast_fully_specified_type();
	   $$->type->qualifier = $1;
	   $$->type->specifier = $3;
	}
	| parameter_qualifier parameter_type_specifier
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_parameter_declarator();
	   $$->set_location(yylloc);
	   $$->type = new(ctx) ast_fully_specified_type();
	   $$->type->qualifier = $1;
	   $$->type->specifier = $2;
	}
	;
d887 54
a940 21
	/* empty */
	{
	   memset(& $$, 0, sizeof($$));
	}
	| IN_TOK
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.in = 1;
	}
	| OUT_TOK
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.out = 1;
	}
	| INOUT_TOK
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.in = 1;
	   $$.flags.q.out = 1;
	}
	;
d943 2
a944 2
	type_specifier
	;
d947 76
a1022 62
	single_declaration
	| init_declarator_list ',' any_identifier
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($3, false, NULL, NULL);
	   decl->set_location(yylloc);

	   $$ = $1;
	   $$->declarations.push_tail(&decl->link);
	   state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
	}
	| init_declarator_list ',' any_identifier '[' ']'
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($3, true, NULL, NULL);
	   decl->set_location(yylloc);

	   $$ = $1;
	   $$->declarations.push_tail(&decl->link);
	   state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
	}
	| init_declarator_list ',' any_identifier '[' constant_expression ']'
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($3, true, $5, NULL);
	   decl->set_location(yylloc);

	   $$ = $1;
	   $$->declarations.push_tail(&decl->link);
	   state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
	}
	| init_declarator_list ',' any_identifier '[' ']' '=' initializer
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($3, true, NULL, $7);
	   decl->set_location(yylloc);

	   $$ = $1;
	   $$->declarations.push_tail(&decl->link);
	   state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
	}
	| init_declarator_list ',' any_identifier '[' constant_expression ']' '=' initializer
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($3, true, $5, $8);
	   decl->set_location(yylloc);

	   $$ = $1;
	   $$->declarations.push_tail(&decl->link);
	   state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
	}
	| init_declarator_list ',' any_identifier '=' initializer
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($3, false, NULL, $5);
	   decl->set_location(yylloc);

	   $$ = $1;
	   $$->declarations.push_tail(&decl->link);
	   state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
	}
	;
d1024 1
a1024 1
	// Grammar Note: No 'enum', or 'typedef'.
d1026 86
a1111 73
	fully_specified_type
	{
	   void *ctx = state;
	   /* Empty declaration list is valid. */
	   $$ = new(ctx) ast_declarator_list($1);
	   $$->set_location(yylloc);
	}
	| fully_specified_type any_identifier
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($2, false, NULL, NULL);

	   $$ = new(ctx) ast_declarator_list($1);
	   $$->set_location(yylloc);
	   $$->declarations.push_tail(&decl->link);
	}
	| fully_specified_type any_identifier '[' ']'
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($2, true, NULL, NULL);

	   $$ = new(ctx) ast_declarator_list($1);
	   $$->set_location(yylloc);
	   $$->declarations.push_tail(&decl->link);
	}
	| fully_specified_type any_identifier '[' constant_expression ']'
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($2, true, $4, NULL);

	   $$ = new(ctx) ast_declarator_list($1);
	   $$->set_location(yylloc);
	   $$->declarations.push_tail(&decl->link);
	}
	| fully_specified_type any_identifier '[' ']' '=' initializer
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($2, true, NULL, $6);

	   $$ = new(ctx) ast_declarator_list($1);
	   $$->set_location(yylloc);
	   $$->declarations.push_tail(&decl->link);
	}
	| fully_specified_type any_identifier '[' constant_expression ']' '=' initializer
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($2, true, $4, $7);

	   $$ = new(ctx) ast_declarator_list($1);
	   $$->set_location(yylloc);
	   $$->declarations.push_tail(&decl->link);
	}
	| fully_specified_type any_identifier '=' initializer
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($2, false, NULL, $4);

	   $$ = new(ctx) ast_declarator_list($1);
	   $$->set_location(yylloc);
	   $$->declarations.push_tail(&decl->link);
	}
	| INVARIANT variable_identifier // Vertex only.
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($2, false, NULL, NULL);

	   $$ = new(ctx) ast_declarator_list(NULL);
	   $$->set_location(yylloc);
	   $$->invariant = true;

	   $$->declarations.push_tail(&decl->link);
	}
	;
d1114 16
a1129 16
	type_specifier
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_fully_specified_type();
	   $$->set_location(yylloc);
	   $$->specifier = $1;
	}
	| type_qualifier type_specifier
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_fully_specified_type();
	   $$->set_location(yylloc);
	   $$->qualifier = $1;
	   $$->specifier = $2;
	}
	;
d1132 5
a1136 5
	LAYOUT_TOK '(' layout_qualifier_id_list ')'
	{
	  $$ = $3;
	}
	;
d1139 14
a1152 18
	layout_qualifier_id
	| layout_qualifier_id_list ',' layout_qualifier_id
	{
	   if (($1.flags.i & $3.flags.i) != 0) {
	      _mesa_glsl_error(& @@3, state,
			       "duplicate layout qualifiers used\n");
	      YYERROR;
	   }

	   $$.flags.i = $1.flags.i | $3.flags.i;

	   if ($1.flags.q.explicit_location)
	      $$.location = $1.location;

	   if ($3.flags.q.explicit_location)
	      $$.location = $3.location;
	}
	;
d1155 158
a1312 91
	any_identifier
	{
	   bool got_one = false;

	   memset(& $$, 0, sizeof($$));

	   /* Layout qualifiers for ARB_fragment_coord_conventions. */
	   if (!got_one && state->ARB_fragment_coord_conventions_enable) {
	      if (strcmp($1, "origin_upper_left") == 0) {
		 got_one = true;
		 $$.flags.q.origin_upper_left = 1;
	      } else if (strcmp($1, "pixel_center_integer") == 0) {
		 got_one = true;
		 $$.flags.q.pixel_center_integer = 1;
	      }

	      if (got_one && state->ARB_fragment_coord_conventions_warn) {
		 _mesa_glsl_warning(& @@1, state,
				    "GL_ARB_fragment_coord_conventions layout "
				    "identifier `%s' used\n", $1);
	      }
	   }

	   /* Layout qualifiers for AMD_conservative_depth. */
	   if (!got_one && state->AMD_conservative_depth_enable) {
	      if (strcmp($1, "depth_any") == 0) {
	         got_one = true;
	         $$.flags.q.depth_any = 1;
	      } else if (strcmp($1, "depth_greater") == 0) {
	         got_one = true;
	         $$.flags.q.depth_greater = 1;
	      } else if (strcmp($1, "depth_less") == 0) {
	         got_one = true;
	         $$.flags.q.depth_less = 1;
	      } else if (strcmp($1, "depth_unchanged") == 0) {
	         got_one = true;
	         $$.flags.q.depth_unchanged = 1;
	      }
	
	      if (got_one && state->AMD_conservative_depth_warn) {
	         _mesa_glsl_warning(& @@1, state,
	                            "GL_AMD_conservative_depth "
	                            "layout qualifier `%s' is used\n", $1);
	      }
	   }

	   if (!got_one) {
	      _mesa_glsl_error(& @@1, state, "unrecognized layout identifier "
			       "`%s'\n", $1);
	      YYERROR;
	   }
	}
	| any_identifier '=' INTCONSTANT
	{
	   bool got_one = false;

	   memset(& $$, 0, sizeof($$));

	   if (state->ARB_explicit_attrib_location_enable) {
	      /* FINISHME: Handle 'index' once GL_ARB_blend_func_exteneded and
	       * FINISHME: GLSL 1.30 (or later) are supported.
	       */
	      if (strcmp("location", $1) == 0) {
		 got_one = true;

		 $$.flags.q.explicit_location = 1;

		 if ($3 >= 0) {
		    $$.location = $3;
		 } else {
		    _mesa_glsl_error(& @@3, state,
				     "invalid location %d specified\n", $3);
		    YYERROR;
		 }
	      }
	   }

	   /* If the identifier didn't match any known layout identifiers,
	    * emit an error.
	    */
	   if (!got_one) {
	      _mesa_glsl_error(& @@1, state, "unrecognized layout identifier "
			       "`%s'\n", $1);
	      YYERROR;
	   } else if (state->ARB_explicit_attrib_location_warn) {
	      _mesa_glsl_warning(& @@1, state,
				 "GL_ARB_explicit_attrib_location layout "
				 "identifier `%s' used\n", $1);
	   }
	}
	;
d1315 16
a1330 24
	SMOOTH
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.smooth = 1;
	}
	| FLAT
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.flat = 1;
	}
	| NOPERSPECTIVE
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.noperspective = 1;
	}
	;

parameter_type_qualifier:
	CONST_TOK
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.constant = 1;
	}
	;
d1333 147
a1479 30
	storage_qualifier
	| layout_qualifier
	| layout_qualifier storage_qualifier
	{
	   $$ = $1;
	   $$.flags.i |= $2.flags.i;
	}
	| interpolation_qualifier
	| interpolation_qualifier storage_qualifier
	{
	   $$ = $1;
	   $$.flags.i |= $2.flags.i;
	}
	| INVARIANT storage_qualifier
	{
	   $$ = $2;
	   $$.flags.q.invariant = 1;
	}
	| INVARIANT interpolation_qualifier storage_qualifier
	{
	   $$ = $2;
	   $$.flags.i |= $3.flags.i;
	   $$.flags.q.invariant = 1;
	}
	| INVARIANT
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.invariant = 1;
	}
	;
d1482 31
a1512 47
	CONST_TOK
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.constant = 1;
	}
	| ATTRIBUTE
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.attribute = 1;
	}
	| VARYING
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.varying = 1;
	}
	| CENTROID VARYING
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.centroid = 1;
	   $$.flags.q.varying = 1;
	}
	| IN_TOK
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.in = 1;
	}
	| OUT_TOK
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.out = 1;
	}
	| CENTROID IN_TOK
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.centroid = 1; $$.flags.q.in = 1;
	}
	| CENTROID OUT_TOK
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.centroid = 1; $$.flags.q.out = 1;
	}
	| UNIFORM
	{
	   memset(& $$, 0, sizeof($$));
	   $$.flags.q.uniform = 1;
	}
	;
d1515 14
a1528 26
	type_specifier_no_prec
	{
	   $$ = $1;
	}
	| precision_qualifier type_specifier_no_prec
	{
	   $$ = $2;
	   $$->precision = $1;
	}
	;

type_specifier_no_prec:
	type_specifier_nonarray
	| type_specifier_nonarray '[' ']'
	{
	   $$ = $1;
	   $$->is_array = true;
	   $$->array_size = NULL;
	}
	| type_specifier_nonarray '[' constant_expression ']'
	{
	   $$ = $1;
	   $$->is_array = true;
	   $$->array_size = $3;
	}
	;
d1531 19
a1549 19
	basic_type_specifier_nonarray
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_type_specifier($1);
	   $$->set_location(yylloc);
	}
	| struct_specifier
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_type_specifier($1);
	   $$->set_location(yylloc);
	}
	| TYPE_IDENTIFIER
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_type_specifier($1);
	   $$->set_location(yylloc);
	}
	;
d1552 68
a1619 52
	VOID_TOK		{ $$ = ast_void; }
	| FLOAT_TOK		{ $$ = ast_float; }
	| INT_TOK		{ $$ = ast_int; }
	| UINT_TOK		{ $$ = ast_uint; }
	| BOOL_TOK		{ $$ = ast_bool; }
	| VEC2			{ $$ = ast_vec2; }
	| VEC3			{ $$ = ast_vec3; }
	| VEC4			{ $$ = ast_vec4; }
	| BVEC2			{ $$ = ast_bvec2; }
	| BVEC3			{ $$ = ast_bvec3; }
	| BVEC4			{ $$ = ast_bvec4; }
	| IVEC2			{ $$ = ast_ivec2; }
	| IVEC3			{ $$ = ast_ivec3; }
	| IVEC4			{ $$ = ast_ivec4; }
	| UVEC2			{ $$ = ast_uvec2; }
	| UVEC3			{ $$ = ast_uvec3; }
	| UVEC4			{ $$ = ast_uvec4; }
	| MAT2X2		{ $$ = ast_mat2; }
	| MAT2X3		{ $$ = ast_mat2x3; }
	| MAT2X4		{ $$ = ast_mat2x4; }
	| MAT3X2		{ $$ = ast_mat3x2; }
	| MAT3X3		{ $$ = ast_mat3; }
	| MAT3X4		{ $$ = ast_mat3x4; }
	| MAT4X2		{ $$ = ast_mat4x2; }
	| MAT4X3		{ $$ = ast_mat4x3; }
	| MAT4X4		{ $$ = ast_mat4; }
	| SAMPLER1D		{ $$ = ast_sampler1d; }
	| SAMPLER2D		{ $$ = ast_sampler2d; }
	| SAMPLER2DRECT		{ $$ = ast_sampler2drect; }
	| SAMPLER3D		{ $$ = ast_sampler3d; }
	| SAMPLERCUBE		{ $$ = ast_samplercube; }
	| SAMPLER1DSHADOW	{ $$ = ast_sampler1dshadow; }
	| SAMPLER2DSHADOW	{ $$ = ast_sampler2dshadow; }
	| SAMPLER2DRECTSHADOW	{ $$ = ast_sampler2drectshadow; }
	| SAMPLERCUBESHADOW	{ $$ = ast_samplercubeshadow; }
	| SAMPLER1DARRAY	{ $$ = ast_sampler1darray; }
	| SAMPLER2DARRAY	{ $$ = ast_sampler2darray; }
	| SAMPLER1DARRAYSHADOW	{ $$ = ast_sampler1darrayshadow; }
	| SAMPLER2DARRAYSHADOW	{ $$ = ast_sampler2darrayshadow; }
	| ISAMPLER1D		{ $$ = ast_isampler1d; }
	| ISAMPLER2D		{ $$ = ast_isampler2d; }
	| ISAMPLER3D		{ $$ = ast_isampler3d; }
	| ISAMPLERCUBE		{ $$ = ast_isamplercube; }
	| ISAMPLER1DARRAY	{ $$ = ast_isampler1darray; }
	| ISAMPLER2DARRAY	{ $$ = ast_isampler2darray; }
	| USAMPLER1D		{ $$ = ast_usampler1d; }
	| USAMPLER2D		{ $$ = ast_usampler2d; }
	| USAMPLER3D		{ $$ = ast_usampler3d; }
	| USAMPLERCUBE		{ $$ = ast_usamplercube; }
	| USAMPLER1DARRAY	{ $$ = ast_usampler1darray; }
	| USAMPLER2DARRAY	{ $$ = ast_usampler2darray; }
	;
d1622 16
a1637 31
	HIGHP	  {
		     if (!state->es_shader && state->language_version < 130)
			_mesa_glsl_error(& @@1, state,
				         "precision qualifier forbidden "
					 "in %s (1.30 or later "
					 "required)\n",
					 state->version_string);

		     $$ = ast_precision_high;
		  }
	| MEDIUMP {
		     if (!state->es_shader && state->language_version < 130)
			_mesa_glsl_error(& @@1, state,
					 "precision qualifier forbidden "
					 "in %s (1.30 or later "
					 "required)\n",
					 state->version_string);

		     $$ = ast_precision_medium;
		  }
	| LOWP	  {
		     if (!state->es_shader && state->language_version < 130)
			_mesa_glsl_error(& @@1, state,
					 "precision qualifier forbidden "
					 "in %s (1.30 or later "
					 "required)\n",
					 state->version_string);

		     $$ = ast_precision_low;
		  }
	;
d1640 15
a1654 14
	STRUCT any_identifier '{' struct_declaration_list '}'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_struct_specifier($2, $4);
	   $$->set_location(yylloc);
	   state->symbols->add_type($2, glsl_type::void_type);
	}
	| STRUCT '{' struct_declaration_list '}'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_struct_specifier(NULL, $3);
	   $$->set_location(yylloc);
	}
	;
d1657 11
a1667 11
	struct_declaration
	{
	   $$ = (ast_node *) $1;
	   $1->link.self_link();
	}
	| struct_declaration_list struct_declaration
	{
	   $$ = (ast_node *) $1;
	   $$->link.insert_before(& $2->link);
	}
	;
d1670 13
a1682 13
	type_specifier struct_declarator_list ';'
	{
	   void *ctx = state;
	   ast_fully_specified_type *type = new(ctx) ast_fully_specified_type();
	   type->set_location(yylloc);

	   type->specifier = $1;
	   $$ = new(ctx) ast_declarator_list(type);
	   $$->set_location(yylloc);

	   $$->declarations.push_degenerate_list_at_head(& $2->link);
	}
	;
d1685 11
a1695 11
	struct_declarator
	{
	   $$ = $1;
	   $1->link.self_link();
	}
	| struct_declarator_list ',' struct_declarator
	{
	   $$ = $1;
	   $$->link.insert_before(& $3->link);
	}
	;
d1698 13
a1710 14
	any_identifier
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_declaration($1, false, NULL, NULL);
	   $$->set_location(yylloc);
	   state->symbols->add_variable(new(state) ir_variable(NULL, $1, ir_var_auto));
	}
	| any_identifier '[' constant_expression ']'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_declaration($1, true, $3, NULL);
	   $$->set_location(yylloc);
	}
	;
d1713 24
a1736 2
	assignment_expression
	;
d1739 2
a1740 2
	declaration
	;
d1742 2
a1743 2
	// Grammar Note: labeled statements for SWITCH only; 'goto' is not
	// supported.
d1745 3
a1747 3
	compound_statement	{ $$ = (ast_node *) $1; }
	| simple_statement
	;
d1750 7
a1756 8
	declaration_statement
	| expression_statement
	| selection_statement
	| switch_statement		{ $$ = NULL; }
	| case_label			{ $$ = NULL; }
	| iteration_statement
	| jump_statement
	;
d1759 18
a1776 18
	'{' '}'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_compound_statement(true, NULL);
	   $$->set_location(yylloc);
	}
	| '{'
	{
	   state->symbols->push_scope();
	}
	statement_list '}'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_compound_statement(true, $3);
	   $$->set_location(yylloc);
	   state->symbols->pop_scope();
	}
	;
d1779 3
a1781 3
	compound_statement_no_new_scope { $$ = (ast_node *) $1; }
	| simple_statement
	;
d1784 13
a1796 13
	'{' '}'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_compound_statement(false, NULL);
	   $$->set_location(yylloc);
	}
	| '{' statement_list '}'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_compound_statement(false, $2);
	   $$->set_location(yylloc);
	}
	;
d1799 20
a1818 20
	statement
	{
	   if ($1 == NULL) {
	      _mesa_glsl_error(& @@1, state, "<nil> statement\n");
	      assert($1 != NULL);
	   }

	   $$ = $1;
	   $$->link.self_link();
	}
	| statement_list statement
	{
	   if ($2 == NULL) {
	      _mesa_glsl_error(& @@2, state, "<nil> statement\n");
	      assert($2 != NULL);
	   }
	   $$ = $1;
	   $$->link.insert_before(& $2->link);
	}
	;
d1821 13
a1833 13
	';'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_statement(NULL);
	   $$->set_location(yylloc);
	}
	| expression ';'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_expression_statement($1);
	   $$->set_location(yylloc);
	}
	;
d1836 7
a1842 7
	IF '(' expression ')' selection_rest_statement
	{
	   $$ = new(state) ast_selection_statement($3, $5.then_statement,
						   $5.else_statement);
	   $$->set_location(yylloc);
	}
	;
d1845 11
a1855 11
	statement ELSE statement
	{
	   $$.then_statement = $1;
	   $$.else_statement = $3;
	}
	| statement
	{
	   $$.then_statement = $1;
	   $$.else_statement = NULL;
	}
	;
d1858 21
a1878 17
	expression
	{
	   $$ = (ast_node *) $1;
	}
	| fully_specified_type any_identifier '=' initializer
	{
	   void *ctx = state;
	   ast_declaration *decl = new(ctx) ast_declaration($2, false, NULL, $4);
	   ast_declarator_list *declarator = new(ctx) ast_declarator_list($1);
	   decl->set_location(yylloc);
	   declarator->set_location(yylloc);

	   declarator->declarations.push_tail(&decl->link);
	   $$ = declarator;
	}
	;

d1880 19
a1898 2
	SWITCH '(' expression ')' compound_statement
	;
d1901 59
a1959 3
	CASE expression ':'
	| DEFAULT ':'
	;
d1962 22
a1983 22
	WHILE '(' condition ')' statement_no_new_scope
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_iteration_statement(ast_iteration_statement::ast_while,
	   					    NULL, $3, NULL, $5);
	   $$->set_location(yylloc);
	}
	| DO statement WHILE '(' expression ')' ';'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_iteration_statement(ast_iteration_statement::ast_do_while,
						    NULL, $5, NULL, $2);
	   $$->set_location(yylloc);
	}
	| FOR '(' for_init_statement for_rest_statement ')' statement_no_new_scope
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_iteration_statement(ast_iteration_statement::ast_for,
						    $3, $4.cond, $4.rest, $6);
	   $$->set_location(yylloc);
	}
	;
d1986 3
a1988 3
	expression_statement
	| declaration_statement
	;
d1991 6
a1996 6
	condition
	| /* empty */
	{
	   $$ = NULL;
	}
	;
d1999 11
a2009 11
	conditionopt ';'
	{
	   $$.cond = $1;
	   $$.rest = NULL;
	}
	| conditionopt ';' expression
	{
	   $$.cond = $1;
	   $$.rest = $3;
	}
	;
d2011 1
a2011 1
	// Grammar Note: No 'goto'. Gotos are not supported.
d2013 31
a2043 31
	CONTINUE ';' 
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_continue, NULL);
	   $$->set_location(yylloc);
	}
	| BREAK ';'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_break, NULL);
	   $$->set_location(yylloc);
	}
	| RETURN ';'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_return, NULL);
	   $$->set_location(yylloc);
	}
	| RETURN expression ';'
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_return, $2);
	   $$->set_location(yylloc);
	}
	| DISCARD ';' // Fragment shader only.
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_discard, NULL);
	   $$->set_location(yylloc);
	}
	;
d2046 5
a2050 4
	function_definition	{ $$ = $1; }
	| declaration		{ $$ = $1; }
	| pragma_statement	{ $$ = NULL; }
	;
d2053 213
a2265 11
	function_prototype compound_statement_no_new_scope
	{
	   void *ctx = state;
	   $$ = new(ctx) ast_function_definition();
	   $$->set_location(yylloc);
	   $$->prototype = $1;
	   $$->body = $2;

	   state->symbols->pop_scope();
	}
	;
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d28 1
a28 1

a31 3
#include "main/context.h"

#undef yyerror
d33 1
a33 4
static void yyerror(YYLTYPE *loc, _mesa_glsl_parse_state *st, const char *msg)
{
   _mesa_glsl_error(loc, st, "%s", msg);
}
a34 5
static int
_mesa_glsl_lex(YYSTYPE *val, YYLTYPE *loc, _mesa_glsl_parse_state *state)
{
   return _mesa_glsl_lexer_lex(val, loc, state->scanner);
}
a36 2
%expect 0

d49 1
a49 1
%lex-param   {struct _mesa_glsl_parse_state *state}
d55 1
a55 1
   const char *identifier;
a69 6
   ast_switch_body *switch_body;
   ast_case_label *case_label;
   ast_case_label_list *case_label_list;
   ast_case_statement *case_statement;
   ast_case_statement_list *case_statement_list;
   ast_interface_block *interface_block;
d92 3
a94 10
%token SAMPLER2DARRAYSHADOW SAMPLERCUBEARRAY SAMPLERCUBEARRAYSHADOW
%token ISAMPLER1D ISAMPLER2D ISAMPLER3D ISAMPLERCUBE
%token ISAMPLER1DARRAY ISAMPLER2DARRAY ISAMPLERCUBEARRAY
%token USAMPLER1D USAMPLER2D USAMPLER3D USAMPLERCUBE USAMPLER1DARRAY
%token USAMPLER2DARRAY USAMPLERCUBEARRAY
%token SAMPLER2DRECT ISAMPLER2DRECT USAMPLER2DRECT SAMPLER2DRECTSHADOW
%token SAMPLERBUFFER ISAMPLERBUFFER USAMPLERBUFFER
%token SAMPLER2DMS ISAMPLER2DMS USAMPLER2DMS
%token SAMPLER2DMSARRAY ISAMPLER2DMSARRAY USAMPLER2DMSARRAY
%token SAMPLEREXTERNALOES
a97 1
%type <interface_block> instance_name_opt
d109 1
a109 1
%token VERSION_TOK EXTENSION LINE COLON EOL INTERFACE OUTPUT
d121 1
a121 1
%token SAMPLER3DRECT
a122 2
%token COHERENT RESTRICT READONLY WRITEONLY RESOURCE ATOMIC_UINT PATCH SAMPLE
%token SUBROUTINE
d126 1
a126 1
%token COMMON PARTITION ACTIVE FILTER
a139 1
%type <type_qualifier> auxiliary_storage_qualifier
a143 2
%type <type_qualifier> interface_block_layout_qualifier
%type <type_qualifier> interface_qualifier
d145 1
d147 1
a147 1
%type <identifier> basic_type_specifier_nonarray
d156 1
a156 1
%type <type_qualifier> parameter_direction_qualifier
a198 1
%type <expression> initializer_list
a201 2
%type <node> interface_block
%type <interface_block> basic_interface_block
d203 1
a203 1
%type <declarator_list> struct_declaration_list
a206 2
%type <declarator_list> member_list
%type <declarator_list> member_declaration
a208 6
%type <node> switch_statement
%type <switch_body> switch_body
%type <case_label_list> case_label_list
%type <case_label> case_label
%type <case_statement> case_statement
%type <case_statement_list> case_statement_list
a213 3
%type <n> integer_constant

%right THEN ELSE
d216 12
a227 12
translation_unit:
   version_statement extension_statement_list
   {
      _mesa_glsl_initialize_types(state);
   }
   external_declaration_list
   {
      delete state->symbols;
      state->symbols = new(ralloc_parent(state)) glsl_symbol_table;
      _mesa_glsl_initialize_types(state);
   }
   ;
d230 39
a268 16
   /* blank - no #version specified: defaults are already set */
   | VERSION_TOK INTCONSTANT EOL
   {
      state->process_version_directive(&@@2, $2, NULL);
      if (state->error) {
         YYERROR;
      }
   }
   | VERSION_TOK INTCONSTANT any_identifier EOL
   {
      state->process_version_directive(&@@2, $2, $3);
      if (state->error) {
         YYERROR;
      }
   }
   ;
d271 15
a285 16
   PRAGMA_DEBUG_ON EOL
   | PRAGMA_DEBUG_OFF EOL
   | PRAGMA_OPTIMIZE_ON EOL
   | PRAGMA_OPTIMIZE_OFF EOL
   | PRAGMA_INVARIANT_ALL EOL
   {
      if (!state->is_version(120, 100)) {
         _mesa_glsl_warning(& @@1, state,
                            "pragma `invariant(all)' not supported in %s "
                            "(GLSL ES 1.00 or GLSL 1.20 required).",
                            state->get_version_string());
      } else {
         state->all_invariant = true;
      }
   }
   ;
d289 2
a290 2
   | extension_statement_list extension_statement
   ;
d293 4
a296 4
   IDENTIFIER
   | TYPE_IDENTIFIER
   | NEW_IDENTIFIER
   ;
d299 7
a305 7
   EXTENSION any_identifier COLON any_identifier EOL
   {
      if (!_mesa_glsl_process_extension($2, & @@2, $4, & @@4, state)) {
         YYERROR;
      }
   }
   ;
d308 17
a324 17
   external_declaration
   {
      /* FINISHME: The NULL test is required because pragmas are set to
       * FINISHME: NULL. (See production rule for external_declaration.)
       */
      if ($1 != NULL)
         state->translation_unit.push_tail(& $1->link);
   }
   | external_declaration_list external_declaration
   {
      /* FINISHME: The NULL test is required because pragmas are set to
       * FINISHME: NULL. (See production rule for external_declaration.)
       */
      if ($2 != NULL)
         state->translation_unit.push_tail(& $2->link);
   }
   ;
d327 3
a329 3
   IDENTIFIER
   | NEW_IDENTIFIER
   ;
d332 40
a371 40
   variable_identifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_identifier, NULL, NULL, NULL);
      $$->set_location(yylloc);
      $$->primary_expression.identifier = $1;
   }
   | INTCONSTANT
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_int_constant, NULL, NULL, NULL);
      $$->set_location(yylloc);
      $$->primary_expression.int_constant = $1;
   }
   | UINTCONSTANT
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_uint_constant, NULL, NULL, NULL);
      $$->set_location(yylloc);
      $$->primary_expression.uint_constant = $1;
   }
   | FLOATCONSTANT
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_float_constant, NULL, NULL, NULL);
      $$->set_location(yylloc);
      $$->primary_expression.float_constant = $1;
   }
   | BOOLCONSTANT
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_bool_constant, NULL, NULL, NULL);
      $$->set_location(yylloc);
      $$->primary_expression.bool_constant = $1;
   }
   | '(' expression ')'
   {
      $$ = $2;
   }
   ;
d374 31
a404 31
   primary_expression
   | postfix_expression '[' integer_expression ']'
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_array_index, $1, $3, NULL);
      $$->set_location(yylloc);
   }
   | function_call
   {
      $$ = $1;
   }
   | postfix_expression '.' any_identifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_field_selection, $1, NULL, NULL);
      $$->set_location(yylloc);
      $$->primary_expression.identifier = $3;
   }
   | postfix_expression INC_OP
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_post_inc, $1, NULL, NULL);
      $$->set_location(yylloc);
   }
   | postfix_expression DEC_OP
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_post_dec, $1, NULL, NULL);
      $$->set_location(yylloc);
   }
   ;
d407 2
a408 2
   expression
   ;
d411 2
a412 2
   function_call_or_method
   ;
d415 8
a422 8
   function_call_generic
   | postfix_expression '.' method_call_generic
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_field_selection, $1, $3, NULL);
      $$->set_location(yylloc);
   }
   ;
d425 3
a427 3
   function_call_header_with_parameters ')'
   | function_call_header_no_parameters ')'
   ;
d430 3
a432 3
   function_call_header VOID_TOK
   | function_call_header
   ;
d435 17
a451 17
   function_call_header assignment_expression
   {
      $$ = $1;
      $$->set_location(yylloc);
      $$->expressions.push_tail(& $2->link);
   }
   | function_call_header_with_parameters ',' assignment_expression
   {
      $$ = $1;
      $$->set_location(yylloc);
      $$->expressions.push_tail(& $3->link);
   }
   ;

   // Grammar Note: Constructors look like functions, but lexical
   // analysis recognized most of them as keywords. They are now
   // recognized through "type_specifier".
d453 2
a454 2
   function_identifier '('
   ;
d457 21
a477 21
   type_specifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_function_expression($1);
      $$->set_location(yylloc);
      }
   | variable_identifier
   {
      void *ctx = state;
      ast_expression *callee = new(ctx) ast_expression($1);
      $$ = new(ctx) ast_function_expression(callee);
      $$->set_location(yylloc);
      }
   | FIELD_SELECTION
   {
      void *ctx = state;
      ast_expression *callee = new(ctx) ast_expression($1);
      $$ = new(ctx) ast_function_expression(callee);
      $$->set_location(yylloc);
      }
   ;
d480 3
a482 3
   method_call_header_with_parameters ')'
   | method_call_header_no_parameters ')'
   ;
d485 3
a487 3
   method_call_header VOID_TOK
   | method_call_header
   ;
d490 17
a506 17
   method_call_header assignment_expression
   {
      $$ = $1;
      $$->set_location(yylloc);
      $$->expressions.push_tail(& $2->link);
   }
   | method_call_header_with_parameters ',' assignment_expression
   {
      $$ = $1;
      $$->set_location(yylloc);
      $$->expressions.push_tail(& $3->link);
   }
   ;

   // Grammar Note: Constructors look like methods, but lexical
   // analysis recognized most of them as keywords. They are now
   // recognized through "type_specifier".
d508 8
a515 8
   variable_identifier '('
   {
      void *ctx = state;
      ast_expression *callee = new(ctx) ast_expression($1);
      $$ = new(ctx) ast_function_expression(callee);
      $$->set_location(yylloc);
   }
   ;
d517 1
a517 1
   // Grammar Note: No traditional style type casts.
d519 20
a538 20
   postfix_expression
   | INC_OP unary_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_pre_inc, $2, NULL, NULL);
      $$->set_location(yylloc);
   }
   | DEC_OP unary_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_pre_dec, $2, NULL, NULL);
      $$->set_location(yylloc);
   }
   | unary_operator unary_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression($1, $2, NULL, NULL);
      $$->set_location(yylloc);
   }
   ;
d540 1
a540 1
   // Grammar Note: No '*' or '&' unary ops. Pointers are not supported.
d542 5
a546 5
   '+'   { $$ = ast_plus; }
   | '-' { $$ = ast_neg; }
   | '!' { $$ = ast_logic_not; }
   | '~' { $$ = ast_bit_not; }
   ;
d549 20
a568 20
   unary_expression
   | multiplicative_expression '*' unary_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_mul, $1, $3);
      $$->set_location(yylloc);
   }
   | multiplicative_expression '/' unary_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_div, $1, $3);
      $$->set_location(yylloc);
   }
   | multiplicative_expression '%' unary_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_mod, $1, $3);
      $$->set_location(yylloc);
   }
   ;
d571 14
a584 14
   multiplicative_expression
   | additive_expression '+' multiplicative_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_add, $1, $3);
      $$->set_location(yylloc);
   }
   | additive_expression '-' multiplicative_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_sub, $1, $3);
      $$->set_location(yylloc);
   }
   ;
d587 14
a600 14
   additive_expression
   | shift_expression LEFT_OP additive_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_lshift, $1, $3);
      $$->set_location(yylloc);
   }
   | shift_expression RIGHT_OP additive_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_rshift, $1, $3);
      $$->set_location(yylloc);
   }
   ;
d603 26
a628 26
   shift_expression
   | relational_expression '<' shift_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_less, $1, $3);
      $$->set_location(yylloc);
   }
   | relational_expression '>' shift_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_greater, $1, $3);
      $$->set_location(yylloc);
   }
   | relational_expression LE_OP shift_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_lequal, $1, $3);
      $$->set_location(yylloc);
   }
   | relational_expression GE_OP shift_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_gequal, $1, $3);
      $$->set_location(yylloc);
   }
   ;
d631 14
a644 14
   relational_expression
   | equality_expression EQ_OP relational_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_equal, $1, $3);
      $$->set_location(yylloc);
   }
   | equality_expression NE_OP relational_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_nequal, $1, $3);
      $$->set_location(yylloc);
   }
   ;
d647 8
a654 8
   equality_expression
   | and_expression '&' equality_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_bit_and, $1, $3);
      $$->set_location(yylloc);
   }
   ;
d657 8
a664 8
   and_expression
   | exclusive_or_expression '^' and_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_bit_xor, $1, $3);
      $$->set_location(yylloc);
   }
   ;
d667 8
a674 8
   exclusive_or_expression
   | inclusive_or_expression '|' exclusive_or_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_bit_or, $1, $3);
      $$->set_location(yylloc);
   }
   ;
d677 8
a684 8
   inclusive_or_expression
   | logical_and_expression AND_OP inclusive_or_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_logic_and, $1, $3);
      $$->set_location(yylloc);
   }
   ;
d687 8
a694 8
   logical_and_expression
   | logical_xor_expression XOR_OP logical_and_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_logic_xor, $1, $3);
      $$->set_location(yylloc);
   }
   ;
d697 8
a704 8
   logical_xor_expression
   | logical_or_expression OR_OP logical_xor_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_bin(ast_logic_or, $1, $3);
      $$->set_location(yylloc);
   }
   ;
d707 8
a714 8
   logical_or_expression
   | logical_or_expression '?' expression ':' assignment_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression(ast_conditional, $1, $3, $5);
      $$->set_location(yylloc);
   }
   ;
d717 8
a724 8
   conditional_expression
   | unary_expression assignment_operator assignment_expression
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression($2, $1, $3, NULL);
      $$->set_location(yylloc);
   }
   ;
d727 12
a738 12
   '='                { $$ = ast_assign; }
   | MUL_ASSIGN       { $$ = ast_mul_assign; }
   | DIV_ASSIGN       { $$ = ast_div_assign; }
   | MOD_ASSIGN       { $$ = ast_mod_assign; }
   | ADD_ASSIGN       { $$ = ast_add_assign; }
   | SUB_ASSIGN       { $$ = ast_sub_assign; }
   | LEFT_ASSIGN      { $$ = ast_ls_assign; }
   | RIGHT_ASSIGN     { $$ = ast_rs_assign; }
   | AND_ASSIGN       { $$ = ast_and_assign; }
   | XOR_ASSIGN       { $$ = ast_xor_assign; }
   | OR_ASSIGN        { $$ = ast_or_assign; }
   ;
d741 18
a758 18
   assignment_expression
   {
      $$ = $1;
   }
   | expression ',' assignment_expression
   {
      void *ctx = state;
      if ($1->oper != ast_sequence) {
         $$ = new(ctx) ast_expression(ast_sequence, NULL, NULL, NULL);
         $$->set_location(yylloc);
         $$->expressions.push_tail(& $1->link);
      } else {
         $$ = $1;
      }

      $$->expressions.push_tail(& $3->link);
   }
   ;
d761 2
a762 2
   conditional_expression
   ;
d765 16
a780 19
   function_prototype ';'
   {
      state->symbols->pop_scope();
      $$ = $1;
   }
   | init_declarator_list ';'
   {
      $$ = $1;
   }
   | PRECISION precision_qualifier type_specifier ';'
   {
      $3->default_precision = $2;
      $$ = $3;
   }
   | interface_block
   {
      $$ = $1;
   }
   ;
d783 2
a784 2
   function_declarator ')'
   ;
d787 3
a789 3
   function_header
   | function_header_with_parameters
   ;
d792 11
a802 11
   function_header parameter_declaration
   {
      $$ = $1;
      $$->parameters.push_tail(& $2->link);
   }
   | function_header_with_parameters ',' parameter_declaration
   {
      $$ = $1;
      $$->parameters.push_tail(& $3->link);
   }
   ;
d805 12
a816 12
   fully_specified_type variable_identifier '('
   {
      void *ctx = state;
      $$ = new(ctx) ast_function();
      $$->set_location(yylloc);
      $$->return_type = $1;
      $$->identifier = $2;

      state->symbols->add_function(new(state) ir_function($2));
      state->symbols->push_scope();
   }
   ;
d819 23
a841 23
   type_specifier any_identifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_parameter_declarator();
      $$->set_location(yylloc);
      $$->type = new(ctx) ast_fully_specified_type();
      $$->type->set_location(yylloc);
      $$->type->specifier = $1;
      $$->identifier = $2;
   }
   | type_specifier any_identifier '[' constant_expression ']'
   {
      void *ctx = state;
      $$ = new(ctx) ast_parameter_declarator();
      $$->set_location(yylloc);
      $$->type = new(ctx) ast_fully_specified_type();
      $$->type->set_location(yylloc);
      $$->type->specifier = $1;
      $$->identifier = $2;
      $$->is_array = true;
      $$->array_size = $4;
   }
   ;
d844 33
a876 15
   parameter_qualifier parameter_declarator
   {
      $$ = $2;
      $$->type->qualifier = $1;
   }
   | parameter_qualifier parameter_type_specifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_parameter_declarator();
      $$->set_location(yylloc);
      $$->type = new(ctx) ast_fully_specified_type();
      $$->type->qualifier = $1;
      $$->type->specifier = $2;
   }
   ;
d879 21
a899 54
   /* empty */
   {
      memset(& $$, 0, sizeof($$));
   }
   | CONST_TOK parameter_qualifier
   {
      if ($2.flags.q.constant)
         _mesa_glsl_error(&@@1, state, "duplicate const qualifier.\n");

      $$ = $2;
      $$.flags.q.constant = 1;
   }
   | parameter_direction_qualifier parameter_qualifier
   {
      if (($1.flags.q.in || $1.flags.q.out) && ($2.flags.q.in || $2.flags.q.out))
         _mesa_glsl_error(&@@1, state, "duplicate in/out/inout qualifier\n");

      if (!state->ARB_shading_language_420pack_enable && $2.flags.q.constant)
         _mesa_glsl_error(&@@1, state, "const must be specified before "
                          "in/out/inout.\n");

      $$ = $1;
      $$.merge_qualifier(&@@1, state, $2);
   }
   | precision_qualifier parameter_qualifier
   {
      if ($2.precision != ast_precision_none)
         _mesa_glsl_error(&@@1, state, "Duplicate precision qualifier.\n");

      if (!state->ARB_shading_language_420pack_enable && $2.flags.i != 0)
         _mesa_glsl_error(&@@1, state, "Precision qualifiers must come last.\n");

      $$ = $2;
      $$.precision = $1;
   }

parameter_direction_qualifier:
   IN_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.in = 1;
   }
   | OUT_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.out = 1;
   }
   | INOUT_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.in = 1;
      $$.flags.q.out = 1;
   }
   ;
d902 2
a903 2
   type_specifier
   ;
d906 62
a967 76
   single_declaration
   | init_declarator_list ',' any_identifier
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($3, false, NULL, NULL);
      decl->set_location(yylloc);

      $$ = $1;
      $$->declarations.push_tail(&decl->link);
      state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
   }
   | init_declarator_list ',' any_identifier '[' ']'
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($3, true, NULL, NULL);
      decl->set_location(yylloc);

      $$ = $1;
      $$->declarations.push_tail(&decl->link);
      state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
   }
   | init_declarator_list ',' any_identifier '[' constant_expression ']'
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($3, true, $5, NULL);
      decl->set_location(yylloc);

      $$ = $1;
      $$->declarations.push_tail(&decl->link);
      state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
   }
   | init_declarator_list ',' any_identifier '[' ']' '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($3, true, NULL, $7);
      decl->set_location(yylloc);

      $$ = $1;
      $$->declarations.push_tail(&decl->link);
      state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
      if ($7->oper == ast_aggregate) {
         ast_aggregate_initializer *ai = (ast_aggregate_initializer *)$7;
         ast_type_specifier *type = new(ctx) ast_type_specifier($1->type->specifier, true, NULL);
         _mesa_ast_set_aggregate_type(type, ai, state);
      }
   }
   | init_declarator_list ',' any_identifier '[' constant_expression ']' '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($3, true, $5, $8);
      decl->set_location(yylloc);

      $$ = $1;
      $$->declarations.push_tail(&decl->link);
      state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
      if ($8->oper == ast_aggregate) {
         ast_aggregate_initializer *ai = (ast_aggregate_initializer *)$8;
         ast_type_specifier *type = new(ctx) ast_type_specifier($1->type->specifier, true, $5);
         _mesa_ast_set_aggregate_type(type, ai, state);
      }
   }
   | init_declarator_list ',' any_identifier '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($3, false, NULL, $5);
      decl->set_location(yylloc);

      $$ = $1;
      $$->declarations.push_tail(&decl->link);
      state->symbols->add_variable(new(state) ir_variable(NULL, $3, ir_var_auto));
      if ($5->oper == ast_aggregate) {
         ast_aggregate_initializer *ai = (ast_aggregate_initializer *)$5;
         _mesa_ast_set_aggregate_type($1->type->specifier, ai, state);
      }
   }
   ;
d969 1
a969 1
   // Grammar Note: No 'enum', or 'typedef'.
d971 73
a1043 86
   fully_specified_type
   {
      void *ctx = state;
      /* Empty declaration list is valid. */
      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location(yylloc);
   }
   | fully_specified_type any_identifier
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, false, NULL, NULL);

      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location(yylloc);
      $$->declarations.push_tail(&decl->link);
   }
   | fully_specified_type any_identifier '[' ']'
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, true, NULL, NULL);

      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location(yylloc);
      $$->declarations.push_tail(&decl->link);
   }
   | fully_specified_type any_identifier '[' constant_expression ']'
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, true, $4, NULL);

      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location(yylloc);
      $$->declarations.push_tail(&decl->link);
   }
   | fully_specified_type any_identifier '[' ']' '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, true, NULL, $6);

      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location(yylloc);
      $$->declarations.push_tail(&decl->link);
      if ($6->oper == ast_aggregate) {
         ast_aggregate_initializer *ai = (ast_aggregate_initializer *)$6;
         ast_type_specifier *type = new(ctx) ast_type_specifier($1->specifier, true, NULL);
         _mesa_ast_set_aggregate_type(type, ai, state);
      }
   }
   | fully_specified_type any_identifier '[' constant_expression ']' '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, true, $4, $7);

      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location(yylloc);
      $$->declarations.push_tail(&decl->link);
      if ($7->oper == ast_aggregate) {
         ast_aggregate_initializer *ai = (ast_aggregate_initializer *)$7;
         ast_type_specifier *type = new(ctx) ast_type_specifier($1->specifier, true, $4);
         _mesa_ast_set_aggregate_type(type, ai, state);
      }
   }
   | fully_specified_type any_identifier '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, false, NULL, $4);

      $$ = new(ctx) ast_declarator_list($1);
      $$->set_location(yylloc);
      $$->declarations.push_tail(&decl->link);
      if ($4->oper == ast_aggregate) {
         _mesa_ast_set_aggregate_type($1->specifier, $4, state);
      }
   }
   | INVARIANT variable_identifier // Vertex only.
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, false, NULL, NULL);

      $$ = new(ctx) ast_declarator_list(NULL);
      $$->set_location(yylloc);
      $$->invariant = true;

      $$->declarations.push_tail(&decl->link);
   }
   ;
d1046 16
a1061 16
   type_specifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_fully_specified_type();
      $$->set_location(yylloc);
      $$->specifier = $1;
   }
   | type_qualifier type_specifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_fully_specified_type();
      $$->set_location(yylloc);
      $$->qualifier = $1;
      $$->specifier = $2;
   }
   ;
d1064 5
a1068 5
   LAYOUT_TOK '(' layout_qualifier_id_list ')'
   {
      $$ = $3;
   }
   ;
d1071 18
a1088 14
   layout_qualifier_id
   | layout_qualifier_id_list ',' layout_qualifier_id
   {
      $$ = $1;
      if (!$$.merge_qualifier(& @@3, state, $3)) {
         YYERROR;
      }
   }
   ;

integer_constant:
   INTCONSTANT { $$ = $1; }
   | UINTCONSTANT { $$ = $1; }
   ;
d1091 91
a1181 158
   any_identifier
   {
      memset(& $$, 0, sizeof($$));

      /* Layout qualifiers for ARB_fragment_coord_conventions. */
      if (!$$.flags.i && state->ARB_fragment_coord_conventions_enable) {
         if (strcmp($1, "origin_upper_left") == 0) {
            $$.flags.q.origin_upper_left = 1;
         } else if (strcmp($1, "pixel_center_integer") == 0) {
            $$.flags.q.pixel_center_integer = 1;
         }

         if ($$.flags.i && state->ARB_fragment_coord_conventions_warn) {
            _mesa_glsl_warning(& @@1, state,
                               "GL_ARB_fragment_coord_conventions layout "
                               "identifier `%s' used\n", $1);
         }
      }

      /* Layout qualifiers for AMD/ARB_conservative_depth. */
      if (!$$.flags.i &&
          (state->AMD_conservative_depth_enable ||
           state->ARB_conservative_depth_enable)) {
         if (strcmp($1, "depth_any") == 0) {
            $$.flags.q.depth_any = 1;
         } else if (strcmp($1, "depth_greater") == 0) {
            $$.flags.q.depth_greater = 1;
         } else if (strcmp($1, "depth_less") == 0) {
            $$.flags.q.depth_less = 1;
         } else if (strcmp($1, "depth_unchanged") == 0) {
            $$.flags.q.depth_unchanged = 1;
         }

         if ($$.flags.i && state->AMD_conservative_depth_warn) {
            _mesa_glsl_warning(& @@1, state,
                               "GL_AMD_conservative_depth "
                               "layout qualifier `%s' is used\n", $1);
         }
         if ($$.flags.i && state->ARB_conservative_depth_warn) {
            _mesa_glsl_warning(& @@1, state,
                               "GL_ARB_conservative_depth "
                               "layout qualifier `%s' is used\n", $1);
         }
      }

      /* See also interface_block_layout_qualifier. */
      if (!$$.flags.i && state->ARB_uniform_buffer_object_enable) {
         if (strcmp($1, "std140") == 0) {
            $$.flags.q.std140 = 1;
         } else if (strcmp($1, "shared") == 0) {
            $$.flags.q.shared = 1;
         } else if (strcmp($1, "column_major") == 0) {
            $$.flags.q.column_major = 1;
         /* "row_major" is a reserved word in GLSL 1.30+. Its token is parsed
          * below in the interface_block_layout_qualifier rule.
          *
          * It is not a reserved word in GLSL ES 3.00, so it's handled here as
          * an identifier.
          */
         } else if (strcmp($1, "row_major") == 0) {
            $$.flags.q.row_major = 1;
         }

         if ($$.flags.i && state->ARB_uniform_buffer_object_warn) {
            _mesa_glsl_warning(& @@1, state,
                               "#version 140 / GL_ARB_uniform_buffer_object "
                               "layout qualifier `%s' is used\n", $1);
         }
      }

      if (!$$.flags.i) {
         _mesa_glsl_error(& @@1, state, "unrecognized layout identifier "
                          "`%s'\n", $1);
         YYERROR;
      }
   }
   | any_identifier '=' integer_constant
   {
      memset(& $$, 0, sizeof($$));

      if (state->ARB_explicit_attrib_location_enable) {
         if (strcmp("location", $1) == 0) {
            $$.flags.q.explicit_location = 1;

            if ($3 >= 0) {
               $$.location = $3;
            } else {
               _mesa_glsl_error(& @@3, state,
                                "invalid location %d specified\n", $3);
               YYERROR;
            }
         }

         if (strcmp("index", $1) == 0) {
            $$.flags.q.explicit_index = 1;

            if ($3 >= 0) {
               $$.index = $3;
            } else {
               _mesa_glsl_error(& @@3, state,
                                "invalid index %d specified\n", $3);
               YYERROR;
            }
         }
      }

      if (state->ARB_shading_language_420pack_enable &&
          strcmp("binding", $1) == 0) {
         $$.flags.q.explicit_binding = 1;
         $$.binding = $3;
      }

      /* If the identifier didn't match any known layout identifiers,
       * emit an error.
       */
      if (!$$.flags.i) {
         _mesa_glsl_error(& @@1, state, "unrecognized layout identifier "
                          "`%s'\n", $1);
         YYERROR;
      } else if (state->ARB_explicit_attrib_location_warn) {
         _mesa_glsl_warning(& @@1, state,
                            "GL_ARB_explicit_attrib_location layout "
                            "identifier `%s' used\n", $1);
      }
   }
   | interface_block_layout_qualifier
   {
      $$ = $1;
      /* Layout qualifiers for ARB_uniform_buffer_object. */
      if ($$.flags.q.uniform && !state->ARB_uniform_buffer_object_enable) {
         _mesa_glsl_error(& @@1, state,
                          "#version 140 / GL_ARB_uniform_buffer_object "
                          "layout qualifier `%s' is used\n", $1);
      } else if ($$.flags.q.uniform && state->ARB_uniform_buffer_object_warn) {
         _mesa_glsl_warning(& @@1, state,
                            "#version 140 / GL_ARB_uniform_buffer_object "
                            "layout qualifier `%s' is used\n", $1);
      }
   }
   ;

/* This is a separate language rule because we parse these as tokens
 * (due to them being reserved keywords) instead of identifiers like
 * most qualifiers.  See the any_identifier path of
 * layout_qualifier_id for the others.
 */
interface_block_layout_qualifier:
   ROW_MAJOR
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.row_major = 1;
   }
   | PACKED_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.packed = 1;
   }
   ;
d1184 24
a1207 16
   SMOOTH
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.smooth = 1;
   }
   | FLAT
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.flat = 1;
   }
   | NOPERSPECTIVE
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.noperspective = 1;
   }
   ;
d1210 30
a1239 147
   /* Single qualifiers */
   INVARIANT
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.invariant = 1;
   }
   | auxiliary_storage_qualifier
   | storage_qualifier
   | interpolation_qualifier
   | layout_qualifier
   | precision_qualifier
   {
      memset(&$$, 0, sizeof($$));
      $$.precision = $1;
   }

   /* Multiple qualifiers:
    * In GLSL 4.20, these can be specified in any order.  In earlier versions,
    * they appear in this order (see GLSL 1.50 section 4.7 & comments below):
    *
    *    invariant interpolation auxiliary storage precision  ...or...
    *    layout storage precision
    *
    * Each qualifier's rule ensures that the accumulated qualifiers on the right
    * side don't contain any that must appear on the left hand side.
    * For example, when processing a storage qualifier, we check that there are
    * no auxiliary, interpolation, layout, or invariant qualifiers to the right.
    */
   | INVARIANT type_qualifier
   {
      if ($2.flags.q.invariant)
         _mesa_glsl_error(&@@1, state, "Duplicate \"invariant\" qualifier.\n");

      if ($2.has_layout()) {
         _mesa_glsl_error(&@@1, state,
                          "\"invariant\" cannot be used with layout(...).\n");
      }

      $$ = $2;
      $$.flags.q.invariant = 1;
   }
   | interpolation_qualifier type_qualifier
   {
      /* Section 4.3 of the GLSL 1.40 specification states:
       * "...qualified with one of these interpolation qualifiers"
       *
       * GLSL 1.30 claims to allow "one or more", but insists that:
       * "These interpolation qualifiers may only precede the qualifiers in,
       *  centroid in, out, or centroid out in a declaration."
       *
       * ...which means that e.g. smooth can't precede smooth, so there can be
       * only one after all, and the 1.40 text is a clarification, not a change.
       */
      if ($2.has_interpolation())
         _mesa_glsl_error(&@@1, state, "Duplicate interpolation qualifier.\n");

      if ($2.has_layout()) {
         _mesa_glsl_error(&@@1, state, "Interpolation qualifiers cannot be used "
                          "with layout(...).\n");
      }

      if (!state->ARB_shading_language_420pack_enable && $2.flags.q.invariant) {
         _mesa_glsl_error(&@@1, state, "Interpolation qualifiers must come "
                          "after \"invariant\".\n");
      }

      $$ = $1;
      $$.merge_qualifier(&@@1, state, $2);
   }
   | layout_qualifier type_qualifier
   {
      /* The GLSL 1.50 grammar indicates that a layout(...) declaration can be
       * used standalone or immediately before a storage qualifier.  It cannot
       * be used with interpolation qualifiers or invariant.  There does not
       * appear to be any text indicating that it must come before the storage
       * qualifier, but always seems to in examples.
       */
      if (!state->ARB_shading_language_420pack_enable && $2.has_layout())
         _mesa_glsl_error(&@@1, state, "Duplicate layout(...) qualifiers.\n");

      if ($2.flags.q.invariant)
         _mesa_glsl_error(&@@1, state, "layout(...) cannot be used with "
                          "the \"invariant\" qualifier\n");

      if ($2.has_interpolation()) {
         _mesa_glsl_error(&@@1, state, "layout(...) cannot be used with "
                          "interpolation qualifiers.\n");
      }

      $$ = $1;
      $$.merge_qualifier(&@@1, state, $2);
   }
   | auxiliary_storage_qualifier type_qualifier
   {
      if ($2.has_auxiliary_storage()) {
         _mesa_glsl_error(&@@1, state,
                          "Duplicate auxiliary storage qualifier (centroid).\n");
      }

      if (!state->ARB_shading_language_420pack_enable &&
          ($2.flags.q.invariant || $2.has_interpolation() || $2.has_layout())) {
         _mesa_glsl_error(&@@1, state, "Auxiliary storage qualifiers must come "
                          "just before storage qualifiers.\n");
      }
      $$ = $1;
      $$.flags.i |= $2.flags.i;
   }
   | storage_qualifier type_qualifier
   {
      /* Section 4.3 of the GLSL 1.20 specification states:
       * "Variable declarations may have a storage qualifier specified..."
       *  1.30 clarifies this to "may have one storage qualifier".
       */
      if ($2.has_storage())
         _mesa_glsl_error(&@@1, state, "Duplicate storage qualifier.\n");

      if (!state->ARB_shading_language_420pack_enable &&
          ($2.flags.q.invariant || $2.has_interpolation() || $2.has_layout() ||
           $2.has_auxiliary_storage())) {
         _mesa_glsl_error(&@@1, state, "Storage qualifiers must come after "
                          "invariant, interpolation, layout and auxiliary "
                          "storage qualifiers.\n");
      }

      $$ = $1;
      $$.merge_qualifier(&@@1, state, $2);
   }
   | precision_qualifier type_qualifier
   {
      if ($2.precision != ast_precision_none)
         _mesa_glsl_error(&@@1, state, "Duplicate precision qualifier.\n");

      if (!state->ARB_shading_language_420pack_enable && $2.flags.i != 0)
         _mesa_glsl_error(&@@1, state, "Precision qualifiers must come last.\n");

      $$ = $2;
      $$.precision = $1;
   }
   ;

auxiliary_storage_qualifier:
   CENTROID
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.centroid = 1;
   }
   /* TODO: "sample" and "patch" also go here someday. */
d1242 47
a1288 31
   CONST_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.constant = 1;
   }
   | ATTRIBUTE
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.attribute = 1;
   }
   | VARYING
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.varying = 1;
   }
   | IN_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.in = 1;
   }
   | OUT_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.out = 1;
   }
   | UNIFORM
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.uniform = 1;
   }
   ;
d1291 26
a1316 14
   type_specifier_nonarray
   | type_specifier_nonarray '[' ']'
   {
      $$ = $1;
      $$->is_array = true;
      $$->array_size = NULL;
   }
   | type_specifier_nonarray '[' constant_expression ']'
   {
      $$ = $1;
      $$->is_array = true;
      $$->array_size = $3;
   }
   ;
d1319 19
a1337 19
   basic_type_specifier_nonarray
   {
      void *ctx = state;
      $$ = new(ctx) ast_type_specifier($1);
      $$->set_location(yylloc);
   }
   | struct_specifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_type_specifier($1);
      $$->set_location(yylloc);
   }
   | TYPE_IDENTIFIER
   {
      void *ctx = state;
      $$ = new(ctx) ast_type_specifier($1);
      $$->set_location(yylloc);
   }
   ;
d1340 52
a1391 68
   VOID_TOK                 { $$ = "void"; }
   | FLOAT_TOK              { $$ = "float"; }
   | INT_TOK                { $$ = "int"; }
   | UINT_TOK               { $$ = "uint"; }
   | BOOL_TOK               { $$ = "bool"; }
   | VEC2                   { $$ = "vec2"; }
   | VEC3                   { $$ = "vec3"; }
   | VEC4                   { $$ = "vec4"; }
   | BVEC2                  { $$ = "bvec2"; }
   | BVEC3                  { $$ = "bvec3"; }
   | BVEC4                  { $$ = "bvec4"; }
   | IVEC2                  { $$ = "ivec2"; }
   | IVEC3                  { $$ = "ivec3"; }
   | IVEC4                  { $$ = "ivec4"; }
   | UVEC2                  { $$ = "uvec2"; }
   | UVEC3                  { $$ = "uvec3"; }
   | UVEC4                  { $$ = "uvec4"; }
   | MAT2X2                 { $$ = "mat2"; }
   | MAT2X3                 { $$ = "mat2x3"; }
   | MAT2X4                 { $$ = "mat2x4"; }
   | MAT3X2                 { $$ = "mat3x2"; }
   | MAT3X3                 { $$ = "mat3"; }
   | MAT3X4                 { $$ = "mat3x4"; }
   | MAT4X2                 { $$ = "mat4x2"; }
   | MAT4X3                 { $$ = "mat4x3"; }
   | MAT4X4                 { $$ = "mat4"; }
   | SAMPLER1D              { $$ = "sampler1D"; }
   | SAMPLER2D              { $$ = "sampler2D"; }
   | SAMPLER2DRECT          { $$ = "sampler2DRect"; }
   | SAMPLER3D              { $$ = "sampler3D"; }
   | SAMPLERCUBE            { $$ = "samplerCube"; }
   | SAMPLEREXTERNALOES     { $$ = "samplerExternalOES"; }
   | SAMPLER1DSHADOW        { $$ = "sampler1DShadow"; }
   | SAMPLER2DSHADOW        { $$ = "sampler2DShadow"; }
   | SAMPLER2DRECTSHADOW    { $$ = "sampler2DRectShadow"; }
   | SAMPLERCUBESHADOW      { $$ = "samplerCubeShadow"; }
   | SAMPLER1DARRAY         { $$ = "sampler1DArray"; }
   | SAMPLER2DARRAY         { $$ = "sampler2DArray"; }
   | SAMPLER1DARRAYSHADOW   { $$ = "sampler1DArrayShadow"; }
   | SAMPLER2DARRAYSHADOW   { $$ = "sampler2DArrayShadow"; }
   | SAMPLERBUFFER          { $$ = "samplerBuffer"; }
   | SAMPLERCUBEARRAY       { $$ = "samplerCubeArray"; }
   | SAMPLERCUBEARRAYSHADOW { $$ = "samplerCubeArrayShadow"; }
   | ISAMPLER1D             { $$ = "isampler1D"; }
   | ISAMPLER2D             { $$ = "isampler2D"; }
   | ISAMPLER2DRECT         { $$ = "isampler2DRect"; }
   | ISAMPLER3D             { $$ = "isampler3D"; }
   | ISAMPLERCUBE           { $$ = "isamplerCube"; }
   | ISAMPLER1DARRAY        { $$ = "isampler1DArray"; }
   | ISAMPLER2DARRAY        { $$ = "isampler2DArray"; }
   | ISAMPLERBUFFER         { $$ = "isamplerBuffer"; }
   | ISAMPLERCUBEARRAY      { $$ = "isamplerCubeArray"; }
   | USAMPLER1D             { $$ = "usampler1D"; }
   | USAMPLER2D             { $$ = "usampler2D"; }
   | USAMPLER2DRECT         { $$ = "usampler2DRect"; }
   | USAMPLER3D             { $$ = "usampler3D"; }
   | USAMPLERCUBE           { $$ = "usamplerCube"; }
   | USAMPLER1DARRAY        { $$ = "usampler1DArray"; }
   | USAMPLER2DARRAY        { $$ = "usampler2DArray"; }
   | USAMPLERBUFFER         { $$ = "usamplerBuffer"; }
   | USAMPLERCUBEARRAY      { $$ = "usamplerCubeArray"; }
   | SAMPLER2DMS            { $$ = "sampler2DMS"; }
   | ISAMPLER2DMS           { $$ = "isampler2DMS"; }
   | USAMPLER2DMS           { $$ = "usampler2DMS"; }
   | SAMPLER2DMSARRAY       { $$ = "sampler2DMSArray"; }
   | ISAMPLER2DMSARRAY      { $$ = "isampler2DMSArray"; }
   | USAMPLER2DMSARRAY      { $$ = "usampler2DMSArray"; }
   ;
d1394 31
a1424 16
   HIGHP
   {
      state->check_precision_qualifiers_allowed(&@@1);
      $$ = ast_precision_high;
   }
   | MEDIUMP
   {
      state->check_precision_qualifiers_allowed(&@@1);
      $$ = ast_precision_medium;
   }
   | LOWP
   {
      state->check_precision_qualifiers_allowed(&@@1);
      $$ = ast_precision_low;
   }
   ;
d1427 14
a1440 15
   STRUCT any_identifier '{' struct_declaration_list '}'
   {
      void *ctx = state;
      $$ = new(ctx) ast_struct_specifier($2, $4);
      $$->set_location(yylloc);
      state->symbols->add_type($2, glsl_type::void_type);
      state->symbols->add_type_ast($2, new(ctx) ast_type_specifier($$));
   }
   | STRUCT '{' struct_declaration_list '}'
   {
      void *ctx = state;
      $$ = new(ctx) ast_struct_specifier(NULL, $3);
      $$->set_location(yylloc);
   }
   ;
d1443 11
a1453 11
   struct_declaration
   {
      $$ = $1;
      $1->link.self_link();
   }
   | struct_declaration_list struct_declaration
   {
      $$ = $1;
      $$->link.insert_before(& $2->link);
   }
   ;
d1456 13
a1468 13
   type_specifier struct_declarator_list ';'
   {
      void *ctx = state;
      ast_fully_specified_type *type = new(ctx) ast_fully_specified_type();
      type->set_location(yylloc);

      type->specifier = $1;
      $$ = new(ctx) ast_declarator_list(type);
      $$->set_location(yylloc);

      $$->declarations.push_degenerate_list_at_head(& $2->link);
   }
   ;
d1471 11
a1481 11
   struct_declarator
   {
      $$ = $1;
      $1->link.self_link();
   }
   | struct_declarator_list ',' struct_declarator
   {
      $$ = $1;
      $$->link.insert_before(& $3->link);
   }
   ;
d1484 14
a1497 13
   any_identifier
   {
      void *ctx = state;
      $$ = new(ctx) ast_declaration($1, false, NULL, NULL);
      $$->set_location(yylloc);
   }
   | any_identifier '[' constant_expression ']'
   {
      void *ctx = state;
      $$ = new(ctx) ast_declaration($1, true, $3, NULL);
      $$->set_location(yylloc);
   }
   ;
d1500 2
a1501 24
   assignment_expression
   | '{' initializer_list '}'
   {
      $$ = $2;
   }
   | '{' initializer_list ',' '}'
   {
      $$ = $2;
   }
   ;

initializer_list:
   initializer
   {
      void *ctx = state;
      $$ = new(ctx) ast_aggregate_initializer();
      $$->set_location(yylloc);
      $$->expressions.push_tail(& $1->link);
   }
   | initializer_list ',' initializer
   {
      $1->expressions.push_tail(& $3->link);
   }
   ;
d1504 2
a1505 2
   declaration
   ;
d1507 2
a1508 2
   // Grammar Note: labeled statements for SWITCH only; 'goto' is not
   // supported.
d1510 3
a1512 3
   compound_statement        { $$ = (ast_node *) $1; }
   | simple_statement
   ;
d1515 8
a1522 7
   declaration_statement
   | expression_statement
   | selection_statement
   | switch_statement
   | iteration_statement
   | jump_statement
   ;
d1525 18
a1542 18
   '{' '}'
   {
      void *ctx = state;
      $$ = new(ctx) ast_compound_statement(true, NULL);
      $$->set_location(yylloc);
   }
   | '{'
   {
      state->symbols->push_scope();
   }
   statement_list '}'
   {
      void *ctx = state;
      $$ = new(ctx) ast_compound_statement(true, $3);
      $$->set_location(yylloc);
      state->symbols->pop_scope();
   }
   ;
d1545 3
a1547 3
   compound_statement_no_new_scope { $$ = (ast_node *) $1; }
   | simple_statement
   ;
d1550 13
a1562 13
   '{' '}'
   {
      void *ctx = state;
      $$ = new(ctx) ast_compound_statement(false, NULL);
      $$->set_location(yylloc);
   }
   | '{' statement_list '}'
   {
      void *ctx = state;
      $$ = new(ctx) ast_compound_statement(false, $2);
      $$->set_location(yylloc);
   }
   ;
d1565 20
a1584 20
   statement
   {
      if ($1 == NULL) {
         _mesa_glsl_error(& @@1, state, "<nil> statement\n");
         assert($1 != NULL);
      }

      $$ = $1;
      $$->link.self_link();
   }
   | statement_list statement
   {
      if ($2 == NULL) {
         _mesa_glsl_error(& @@2, state, "<nil> statement\n");
         assert($2 != NULL);
      }
      $$ = $1;
      $$->link.insert_before(& $2->link);
   }
   ;
d1587 13
a1599 13
   ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_statement(NULL);
      $$->set_location(yylloc);
   }
   | expression ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_expression_statement($1);
      $$->set_location(yylloc);
   }
   ;
d1602 7
a1608 7
   IF '(' expression ')' selection_rest_statement
   {
      $$ = new(state) ast_selection_statement($3, $5.then_statement,
                                              $5.else_statement);
      $$->set_location(yylloc);
   }
   ;
d1611 11
a1621 11
   statement ELSE statement
   {
      $$.then_statement = $1;
      $$.else_statement = $3;
   }
   | statement %prec THEN
   {
      $$.then_statement = $1;
      $$.else_statement = NULL;
   }
   ;
d1624 17
a1640 21
   expression
   {
      $$ = (ast_node *) $1;
   }
   | fully_specified_type any_identifier '=' initializer
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, false, NULL, $4);
      ast_declarator_list *declarator = new(ctx) ast_declarator_list($1);
      decl->set_location(yylloc);
      declarator->set_location(yylloc);

      declarator->declarations.push_tail(&decl->link);
      $$ = declarator;
   }
   ;

/*
 * siwtch_statement grammar is based on the syntax described in the body
 * of the GLSL spec, not in it's appendix!!!
 */
d1642 2
a1643 19
   SWITCH '(' expression ')' switch_body
   {
      $$ = new(state) ast_switch_statement($3, $5);
      $$->set_location(yylloc);
   }
   ;

switch_body:
   '{' '}'
   {
      $$ = new(state) ast_switch_body(NULL);
      $$->set_location(yylloc);
   }
   | '{' case_statement_list '}'
   {
      $$ = new(state) ast_switch_body($2);
      $$->set_location(yylloc);
   }
   ;
d1646 3
a1648 59
   CASE expression ':'
   {
      $$ = new(state) ast_case_label($2);
      $$->set_location(yylloc);
   }
   | DEFAULT ':'
   {
      $$ = new(state) ast_case_label(NULL);
      $$->set_location(yylloc);
   }
   ;

case_label_list:
   case_label
   {
      ast_case_label_list *labels = new(state) ast_case_label_list();

      labels->labels.push_tail(& $1->link);
      $$ = labels;
      $$->set_location(yylloc);
   }
   | case_label_list case_label
   {
      $$ = $1;
      $$->labels.push_tail(& $2->link);
   }
   ;

case_statement:
   case_label_list statement
   {
      ast_case_statement *stmts = new(state) ast_case_statement($1);
      stmts->set_location(yylloc);

      stmts->stmts.push_tail(& $2->link);
      $$ = stmts;
   }
   | case_statement statement
   {
      $$ = $1;
      $$->stmts.push_tail(& $2->link);
   }
   ;

case_statement_list:
   case_statement
   {
      ast_case_statement_list *cases= new(state) ast_case_statement_list();
      cases->set_location(yylloc);

      cases->cases.push_tail(& $1->link);
      $$ = cases;
   }
   | case_statement_list case_statement
   {
      $$ = $1;
      $$->cases.push_tail(& $2->link);
   }
   ;
d1651 22
a1672 22
   WHILE '(' condition ')' statement_no_new_scope
   {
      void *ctx = state;
      $$ = new(ctx) ast_iteration_statement(ast_iteration_statement::ast_while,
                                            NULL, $3, NULL, $5);
      $$->set_location(yylloc);
   }
   | DO statement WHILE '(' expression ')' ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_iteration_statement(ast_iteration_statement::ast_do_while,
                                            NULL, $5, NULL, $2);
      $$->set_location(yylloc);
   }
   | FOR '(' for_init_statement for_rest_statement ')' statement_no_new_scope
   {
      void *ctx = state;
      $$ = new(ctx) ast_iteration_statement(ast_iteration_statement::ast_for,
                                            $3, $4.cond, $4.rest, $6);
      $$->set_location(yylloc);
   }
   ;
d1675 3
a1677 3
   expression_statement
   | declaration_statement
   ;
d1680 6
a1685 6
   condition
   | /* empty */
   {
      $$ = NULL;
   }
   ;
d1688 11
a1698 11
   conditionopt ';'
   {
      $$.cond = $1;
      $$.rest = NULL;
   }
   | conditionopt ';' expression
   {
      $$.cond = $1;
      $$.rest = $3;
   }
   ;
d1700 1
a1700 1
   // Grammar Note: No 'goto'. Gotos are not supported.
d1702 31
a1732 31
   CONTINUE ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_continue, NULL);
      $$->set_location(yylloc);
   }
   | BREAK ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_break, NULL);
      $$->set_location(yylloc);
   }
   | RETURN ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_return, NULL);
      $$->set_location(yylloc);
   }
   | RETURN expression ';'
   {
      void *ctx = state;
      $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_return, $2);
      $$->set_location(yylloc);
   }
   | DISCARD ';' // Fragment shader only.
   {
      void *ctx = state;
      $$ = new(ctx) ast_jump_statement(ast_jump_statement::ast_discard, NULL);
      $$->set_location(yylloc);
   }
   ;
d1735 4
a1738 5
   function_definition      { $$ = $1; }
   | declaration            { $$ = $1; }
   | pragma_statement       { $$ = NULL; }
   | layout_defaults        { $$ = NULL; }
   ;
d1741 11
a1751 213
   function_prototype compound_statement_no_new_scope
   {
      void *ctx = state;
      $$ = new(ctx) ast_function_definition();
      $$->set_location(yylloc);
      $$->prototype = $1;
      $$->body = $2;

      state->symbols->pop_scope();
   }
   ;

/* layout_qualifieropt is packed into this rule */
interface_block:
   basic_interface_block
   {
      $$ = $1;
   }
   | layout_qualifier basic_interface_block
   {
      ast_interface_block *block = $2;
      if (!block->layout.merge_qualifier(& @@1, state, $1)) {
         YYERROR;
      }
      $$ = block;
   }
   ;

basic_interface_block:
   interface_qualifier NEW_IDENTIFIER '{' member_list '}' instance_name_opt ';'
   {
      ast_interface_block *const block = $6;

      block->block_name = $2;
      block->declarations.push_degenerate_list_at_head(& $4->link);

      if ($1.flags.q.uniform) {
         if (!state->ARB_uniform_buffer_object_enable) {
            _mesa_glsl_error(& @@1, state,
                             "#version 140 / GL_ARB_uniform_buffer_object "
                             "required for defining uniform blocks\n");
         } else if (state->ARB_uniform_buffer_object_warn) {
            _mesa_glsl_warning(& @@1, state,
                               "#version 140 / GL_ARB_uniform_buffer_object "
                               "required for defining uniform blocks\n");
         }
      } else {
         if (state->es_shader || state->language_version < 150) {
            _mesa_glsl_error(& @@1, state,
                             "#version 150 required for using "
                             "interface blocks.\n");
         }
      }

      /* From the GLSL 1.50.11 spec, section 4.3.7 ("Interface Blocks"):
       * "It is illegal to have an input block in a vertex shader
       *  or an output block in a fragment shader"
       */
      if ((state->target == vertex_shader) && $1.flags.q.in) {
         _mesa_glsl_error(& @@1, state,
                          "`in' interface block is not allowed for "
                          "a vertex shader\n");
      } else if ((state->target == fragment_shader) && $1.flags.q.out) {
         _mesa_glsl_error(& @@1, state,
                          "`out' interface block is not allowed for "
                          "a fragment shader\n");
      }

      /* Since block arrays require names, and both features are added in
       * the same language versions, we don't have to explicitly
       * version-check both things.
       */
      if (block->instance_name != NULL) {
         state->check_version(150, 300, & @@1, "interface blocks with "
                               "an instance name are not allowed");
      }

      unsigned interface_type_mask;
      struct ast_type_qualifier temp_type_qualifier;

      /* Get a bitmask containing only the in/out/uniform flags, allowing us
       * to ignore other irrelevant flags like interpolation qualifiers.
       */
      temp_type_qualifier.flags.i = 0;
      temp_type_qualifier.flags.q.uniform = true;
      temp_type_qualifier.flags.q.in = true;
      temp_type_qualifier.flags.q.out = true;
      interface_type_mask = temp_type_qualifier.flags.i;

      /* Get the block's interface qualifier.  The interface_qualifier
       * production rule guarantees that only one bit will be set (and
       * it will be in/out/uniform).
       */
       unsigned block_interface_qualifier = $1.flags.i;

      block->layout.flags.i |= block_interface_qualifier;

      foreach_list_typed (ast_declarator_list, member, link, &block->declarations) {
         ast_type_qualifier& qualifier = member->type->qualifier;
         if ((qualifier.flags.i & interface_type_mask) == 0) {
            /* GLSLangSpec.1.50.11, 4.3.7 (Interface Blocks):
             * "If no optional qualifier is used in a member declaration, the
             *  qualifier of the variable is just in, out, or uniform as declared
             *  by interface-qualifier."
             */
            qualifier.flags.i |= block_interface_qualifier;
         } else if ((qualifier.flags.i & interface_type_mask) !=
                    block_interface_qualifier) {
            /* GLSLangSpec.1.50.11, 4.3.7 (Interface Blocks):
             * "If optional qualifiers are used, they can include interpolation
             *  and storage qualifiers and they must declare an input, output,
             *  or uniform variable consistent with the interface qualifier of
             *  the block."
             */
            _mesa_glsl_error(& @@1, state,
                             "uniform/in/out qualifier on "
                             "interface block member does not match "
                             "the interface block\n");
         }
      }

      $$ = block;
   }
   ;

interface_qualifier:
   IN_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.in = 1;
   }
   | OUT_TOK
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.out = 1;
   }
   | UNIFORM
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.uniform = 1;
   }
   ;

instance_name_opt:
   /* empty */
   {
      $$ = new(state) ast_interface_block(*state->default_uniform_qualifier,
                                          NULL, NULL);
   }
   | NEW_IDENTIFIER
   {
      $$ = new(state) ast_interface_block(*state->default_uniform_qualifier,
                                          $1, NULL);
   }
   | NEW_IDENTIFIER '[' constant_expression ']'
   {
      $$ = new(state) ast_interface_block(*state->default_uniform_qualifier,
                                          $1, $3);
   }
   | NEW_IDENTIFIER '[' ']'
   {
      _mesa_glsl_error(& @@1, state,
                       "instance block arrays must be explicitly sized\n");

      $$ = new(state) ast_interface_block(*state->default_uniform_qualifier,
                                          $1, NULL);
   }
   ;

member_list:
   member_declaration
   {
      $$ = $1;
      $1->link.self_link();
   }
   | member_declaration member_list
   {
      $$ = $1;
      $2->link.insert_before(& $$->link);
   }
   ;

member_declaration:
   fully_specified_type struct_declarator_list ';'
   {
      void *ctx = state;
      ast_fully_specified_type *type = $1;
      type->set_location(yylloc);

      if (type->qualifier.flags.q.attribute) {
         _mesa_glsl_error(& @@1, state,
                          "keyword 'attribute' cannot be used with "
                          "interface block member\n");
      } else if (type->qualifier.flags.q.varying) {
         _mesa_glsl_error(& @@1, state,
                          "keyword 'varying' cannot be used with "
                          "interface block member\n");
      }

      $$ = new(ctx) ast_declarator_list(type);
      $$->set_location(yylloc);

      $$->declarations.push_degenerate_list_at_head(& $2->link);
   }
   ;

layout_defaults:
   layout_qualifier UNIFORM ';'
   {
      if (!state->default_uniform_qualifier->merge_qualifier(& @@1, state, $1)) {
         YYERROR;
      }
   }
@


1.1.1.2
log
@Import Mesa 9.2.1
@
text
@d1670 1
a1670 1
   fully_specified_type struct_declarator_list ';'
d1673 1
a1673 1
      ast_fully_specified_type *const type = $1;
d1676 1
a1676 5
      if (type->qualifier.flags.i != 0)
         _mesa_glsl_error(&@@1, state,
			  "only precision qualifiers may be applied to "
			  "structure members");

@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a45 26

static bool match_layout_qualifier(const char *s1, const char *s2,
                                   _mesa_glsl_parse_state *state)
{
   /* From the GLSL 1.50 spec, section 4.3.8 (Layout Qualifiers):
    *
    *     "The tokens in any layout-qualifier-id-list ... are not case
    *     sensitive, unless explicitly noted otherwise."
    *
    * The text "unless explicitly noted otherwise" appears to be
    * vacuous--no desktop GLSL spec (up through GLSL 4.40) notes
    * otherwise.
    *
    * However, the GLSL ES 3.00 spec says, in section 4.3.8 (Layout
    * Qualifiers):
    *
    *     "As for other identifiers, they are case sensitive."
    *
    * So we need to do a case-sensitive or a case-insensitive match,
    * depending on whether we are compiling for GLSL ES.
    */
   if (state->es_shader)
      return strcmp(s1, s2);
   else
      return strcasecmp(s1, s2);
}
a73 1
   ast_array_specifier *array_specifier;
a120 9
%token IMAGE1D IMAGE2D IMAGE3D IMAGE2DRECT IMAGECUBE IMAGEBUFFER
%token IMAGE1DARRAY IMAGE2DARRAY IMAGECUBEARRAY IMAGE2DMS IMAGE2DMSARRAY
%token IIMAGE1D IIMAGE2D IIMAGE3D IIMAGE2DRECT IIMAGECUBE IIMAGEBUFFER
%token IIMAGE1DARRAY IIMAGE2DARRAY IIMAGECUBEARRAY IIMAGE2DMS IIMAGE2DMSARRAY
%token UIMAGE1D UIMAGE2D UIMAGE3D UIMAGE2DRECT UIMAGECUBE UIMAGEBUFFER
%token UIMAGE1DARRAY UIMAGE2DARRAY UIMAGECUBEARRAY UIMAGE2DMS UIMAGE2DMSARRAY
%token IMAGE1DSHADOW IMAGE2DSHADOW IMAGE1DARRAYSHADOW IMAGE2DARRAYSHADOW
%token COHERENT VOLATILE RESTRICT READONLY WRITEONLY
%token ATOMIC_UINT
d145 1
a145 1
%token INLINE_TOK NOINLINE PUBLIC_TOK STATIC EXTERN EXTERNAL
d150 1
a150 1
%token RESOURCE PATCH SAMPLE
d155 7
a161 1
%token COMMON PARTITION ACTIVE FILTER ROW_MAJOR
a177 1
%type <array_specifier> array_specifier
a256 1
%type <node> layout_defaults
d302 1
a302 1
                            "(GLSL ES 1.00 or GLSL 1.20 required)",
d359 1
a359 1
      $$->set_location(@@1);
d366 1
a366 1
      $$->set_location(@@1);
d373 1
a373 1
      $$->set_location(@@1);
d380 1
a380 1
      $$->set_location(@@1);
d387 1
a387 1
      $$->set_location(@@1);
d402 1
a402 1
      $$->set_location_range(@@1, @@4);
d412 1
a412 1
      $$->set_location_range(@@1, @@3);
d419 1
a419 1
      $$->set_location_range(@@1, @@2);
d425 1
a425 1
      $$->set_location_range(@@1, @@2);
d443 1
a443 1
      $$->set_location_range(@@1, @@3);
d461 1
a461 1
      $$->set_location(@@1);
d467 1
a467 1
      $$->set_location(@@1);
d484 1
a484 1
      $$->set_location(@@1);
a489 1
      callee->set_location(@@1);
d491 1
a491 1
      $$->set_location(@@1);
a496 1
      callee->set_location(@@1);
d498 1
a498 1
      $$->set_location(@@1);
d516 1
a516 1
      $$->set_location(@@1);
d522 1
a522 1
      $$->set_location(@@1);
a534 1
      callee->set_location(@@1);
d536 1
a536 1
      $$->set_location(@@1);
d547 1
a547 1
      $$->set_location(@@1);
d553 1
a553 1
      $$->set_location(@@1);
d559 1
a559 1
      $$->set_location_range(@@1, @@2);
d577 1
a577 1
      $$->set_location_range(@@1, @@3);
d583 1
a583 1
      $$->set_location_range(@@1, @@3);
d589 1
a589 1
      $$->set_location_range(@@1, @@3);
d599 1
a599 1
      $$->set_location_range(@@1, @@3);
d605 1
a605 1
      $$->set_location_range(@@1, @@3);
d615 1
a615 1
      $$->set_location_range(@@1, @@3);
d621 1
a621 1
      $$->set_location_range(@@1, @@3);
d631 1
a631 1
      $$->set_location_range(@@1, @@3);
d637 1
a637 1
      $$->set_location_range(@@1, @@3);
d643 1
a643 1
      $$->set_location_range(@@1, @@3);
d649 1
a649 1
      $$->set_location_range(@@1, @@3);
d659 1
a659 1
      $$->set_location_range(@@1, @@3);
d665 1
a665 1
      $$->set_location_range(@@1, @@3);
d675 1
a675 1
      $$->set_location_range(@@1, @@3);
d685 1
a685 1
      $$->set_location_range(@@1, @@3);
d695 1
a695 1
      $$->set_location_range(@@1, @@3);
d705 1
a705 1
      $$->set_location_range(@@1, @@3);
d715 1
a715 1
      $$->set_location_range(@@1, @@3);
d725 1
a725 1
      $$->set_location_range(@@1, @@3);
d735 1
a735 1
      $$->set_location_range(@@1, @@5);
d745 1
a745 1
      $$->set_location_range(@@1, @@3);
d773 1
a773 1
         $$->set_location_range(@@1, @@3);
d835 1
a835 1
      $$->set_location(@@2);
d849 1
a849 1
      $$->set_location_range(@@1, @@2);
d851 1
a851 1
      $$->type->set_location(@@1);
d855 1
a855 1
   | type_specifier any_identifier array_specifier
d859 1
a859 1
      $$->set_location_range(@@1, @@3);
d861 1
a861 1
      $$->type->set_location(@@1);
d864 2
a865 1
      $$->array_specifier = $3;
d879 1
a879 1
      $$->set_location(@@2);
a880 1
      $$->type->set_location_range(@@1, @@2);
d894 1
a894 1
         _mesa_glsl_error(&@@1, state, "duplicate const qualifier");
d902 1
a902 1
         _mesa_glsl_error(&@@1, state, "duplicate in/out/inout qualifier");
d906 1
a906 1
                          "in/out/inout");
d914 1
a914 1
         _mesa_glsl_error(&@@1, state, "duplicate precision qualifier");
d917 1
a917 1
         _mesa_glsl_error(&@@1, state, "precision qualifiers must come last");
d951 2
a952 2
      ast_declaration *decl = new(ctx) ast_declaration($3, NULL, NULL);
      decl->set_location(@@3);
d958 1
a958 1
   | init_declarator_list ',' any_identifier array_specifier
d961 2
a962 2
      ast_declaration *decl = new(ctx) ast_declaration($3, $4, NULL);
      decl->set_location_range(@@3, @@4);
d968 1
a968 1
   | init_declarator_list ',' any_identifier array_specifier '=' initializer
d971 2
a972 2
      ast_declaration *decl = new(ctx) ast_declaration($3, $4, $6);
      decl->set_location_range(@@3, @@4);
d978 30
d1011 2
a1012 2
      ast_declaration *decl = new(ctx) ast_declaration($3, NULL, $5);
      decl->set_location(@@3);
d1017 4
d1031 1
a1031 1
      $$->set_location(@@1);
d1036 19
a1054 2
      ast_declaration *decl = new(ctx) ast_declaration($2, NULL, NULL);
      decl->set_location(@@2);
d1057 1
a1057 1
      $$->set_location_range(@@1, @@2);
d1060 1
a1060 1
   | fully_specified_type any_identifier array_specifier
d1063 1
a1063 2
      ast_declaration *decl = new(ctx) ast_declaration($2, $3, NULL);
      decl->set_location_range(@@2, @@3);
d1066 1
a1066 1
      $$->set_location_range(@@1, @@3);
d1068 5
d1074 1
a1074 1
   | fully_specified_type any_identifier array_specifier '=' initializer
d1077 1
a1077 2
      ast_declaration *decl = new(ctx) ast_declaration($2, $3, $5);
      decl->set_location_range(@@2, @@3);
d1080 1
a1080 1
      $$->set_location_range(@@1, @@3);
d1082 5
d1091 1
a1091 2
      ast_declaration *decl = new(ctx) ast_declaration($2, NULL, $4);
      decl->set_location(@@2);
d1094 1
a1094 1
      $$->set_location_range(@@1, @@2);
d1096 3
d1103 1
a1103 2
      ast_declaration *decl = new(ctx) ast_declaration($2, NULL, NULL);
      decl->set_location(@@2);
d1106 1
a1106 1
      $$->set_location_range(@@1, @@2);
d1118 1
a1118 1
      $$->set_location(@@1);
d1125 1
a1125 1
      $$->set_location_range(@@1, @@2);
d1160 2
a1161 3
      if (!$$.flags.i && (state->ARB_fragment_coord_conventions_enable ||
                          state->is_version(150, 0))) {
         if (match_layout_qualifier($1, "origin_upper_left", state) == 0) {
d1163 1
a1163 2
         } else if (match_layout_qualifier($1, "pixel_center_integer",
                                           state) == 0) {
d1170 1
a1170 1
                               "identifier `%s' used", $1);
d1178 1
a1178 1
         if (match_layout_qualifier($1, "depth_any", state) == 0) {
d1180 1
a1180 1
         } else if (match_layout_qualifier($1, "depth_greater", state) == 0) {
d1182 1
a1182 1
         } else if (match_layout_qualifier($1, "depth_less", state) == 0) {
d1184 1
a1184 2
         } else if (match_layout_qualifier($1, "depth_unchanged",
                                           state) == 0) {
d1191 1
a1191 1
                               "layout qualifier `%s' is used", $1);
d1196 1
a1196 1
                               "layout qualifier `%s' is used", $1);
d1201 2
a1202 2
      if (!$$.flags.i && state->has_uniform_buffer_objects()) {
         if (match_layout_qualifier($1, "std140", state) == 0) {
d1204 1
a1204 1
         } else if (match_layout_qualifier($1, "shared", state) == 0) {
d1206 1
a1206 1
         } else if (match_layout_qualifier($1, "column_major", state) == 0) {
a1212 4
          *
          * Also, this takes care of alternate capitalizations of
          * "row_major" (which is necessary because layout qualifiers
          * are case-insensitive in desktop GLSL).
d1214 1
a1214 1
         } else if (match_layout_qualifier($1, "row_major", state) == 0) {
a1215 8
         /* "packed" is a reserved word in GLSL, and its token is
          * parsed below in the interface_block_layout_qualifier rule.
          * However, we must take care of alternate capitalizations of
          * "packed", because layout qualifiers are case-insensitive
          * in desktop GLSL.
          */
         } else if (match_layout_qualifier($1, "packed", state) == 0) {
           $$.flags.q.packed = 1;
d1221 1
a1221 95
                               "layout qualifier `%s' is used", $1);
         }
      }

      /* Layout qualifiers for GLSL 1.50 geometry shaders. */
      if (!$$.flags.i) {
         static const struct {
            const char *s;
            GLenum e;
         } map[] = {
                 { "points", GL_POINTS },
                 { "lines", GL_LINES },
                 { "lines_adjacency", GL_LINES_ADJACENCY },
                 { "line_strip", GL_LINE_STRIP },
                 { "triangles", GL_TRIANGLES },
                 { "triangles_adjacency", GL_TRIANGLES_ADJACENCY },
                 { "triangle_strip", GL_TRIANGLE_STRIP },
         };
         for (unsigned i = 0; i < Elements(map); i++) {
            if (match_layout_qualifier($1, map[i].s, state) == 0) {
               $$.flags.q.prim_type = 1;
               $$.prim_type = map[i].e;
               break;
            }
         }

         if ($$.flags.i && !state->is_version(150, 0)) {
            _mesa_glsl_error(& @@1, state, "#version 150 layout "
                             "qualifier `%s' used", $1);
         }
      }

      /* Layout qualifiers for ARB_shader_image_load_store. */
      if (state->ARB_shader_image_load_store_enable ||
          state->is_version(420, 0)) {
         if (!$$.flags.i) {
            static const struct {
               const char *name;
               GLenum format;
               glsl_base_type base_type;
            } map[] = {
               { "rgba32f", GL_RGBA32F, GLSL_TYPE_FLOAT },
               { "rgba16f", GL_RGBA16F, GLSL_TYPE_FLOAT },
               { "rg32f", GL_RG32F, GLSL_TYPE_FLOAT },
               { "rg16f", GL_RG16F, GLSL_TYPE_FLOAT },
               { "r11f_g11f_b10f", GL_R11F_G11F_B10F, GLSL_TYPE_FLOAT },
               { "r32f", GL_R32F, GLSL_TYPE_FLOAT },
               { "r16f", GL_R16F, GLSL_TYPE_FLOAT },
               { "rgba32ui", GL_RGBA32UI, GLSL_TYPE_UINT },
               { "rgba16ui", GL_RGBA16UI, GLSL_TYPE_UINT },
               { "rgb10_a2ui", GL_RGB10_A2UI, GLSL_TYPE_UINT },
               { "rgba8ui", GL_RGBA8UI, GLSL_TYPE_UINT },
               { "rg32ui", GL_RG32UI, GLSL_TYPE_UINT },
               { "rg16ui", GL_RG16UI, GLSL_TYPE_UINT },
               { "rg8ui", GL_RG8UI, GLSL_TYPE_UINT },
               { "r32ui", GL_R32UI, GLSL_TYPE_UINT },
               { "r16ui", GL_R16UI, GLSL_TYPE_UINT },
               { "r8ui", GL_R8UI, GLSL_TYPE_UINT },
               { "rgba32i", GL_RGBA32I, GLSL_TYPE_INT },
               { "rgba16i", GL_RGBA16I, GLSL_TYPE_INT },
               { "rgba8i", GL_RGBA8I, GLSL_TYPE_INT },
               { "rg32i", GL_RG32I, GLSL_TYPE_INT },
               { "rg16i", GL_RG16I, GLSL_TYPE_INT },
               { "rg8i", GL_RG8I, GLSL_TYPE_INT },
               { "r32i", GL_R32I, GLSL_TYPE_INT },
               { "r16i", GL_R16I, GLSL_TYPE_INT },
               { "r8i", GL_R8I, GLSL_TYPE_INT },
               { "rgba16", GL_RGBA16, GLSL_TYPE_FLOAT },
               { "rgb10_a2", GL_RGB10_A2, GLSL_TYPE_FLOAT },
               { "rgba8", GL_RGBA8, GLSL_TYPE_FLOAT },
               { "rg16", GL_RG16, GLSL_TYPE_FLOAT },
               { "rg8", GL_RG8, GLSL_TYPE_FLOAT },
               { "r16", GL_R16, GLSL_TYPE_FLOAT },
               { "r8", GL_R8, GLSL_TYPE_FLOAT },
               { "rgba16_snorm", GL_RGBA16_SNORM, GLSL_TYPE_FLOAT },
               { "rgba8_snorm", GL_RGBA8_SNORM, GLSL_TYPE_FLOAT },
               { "rg16_snorm", GL_RG16_SNORM, GLSL_TYPE_FLOAT },
               { "rg8_snorm", GL_RG8_SNORM, GLSL_TYPE_FLOAT },
               { "r16_snorm", GL_R16_SNORM, GLSL_TYPE_FLOAT },
               { "r8_snorm", GL_R8_SNORM, GLSL_TYPE_FLOAT }
            };

            for (unsigned i = 0; i < Elements(map); i++) {
               if (match_layout_qualifier($1, map[i].name, state) == 0) {
                  $$.flags.q.explicit_image_format = 1;
                  $$.image_format = map[i].format;
                  $$.image_base_type = map[i].base_type;
                  break;
               }
            }
         }

         if (!$$.flags.i &&
             match_layout_qualifier($1, "early_fragment_tests", state) == 0) {
            $$.flags.q.early_fragment_tests = 1;
d1227 1
a1227 1
                          "`%s'", $1);
d1235 3
a1237 2
      if (match_layout_qualifier("location", $1, state) == 0) {
         $$.flags.q.explicit_location = 1;
d1239 3
a1241 49
         if ($$.flags.q.attribute == 1 &&
             state->ARB_explicit_attrib_location_warn) {
            _mesa_glsl_warning(& @@1, state,
                               "GL_ARB_explicit_attrib_location layout "
                               "identifier `%s' used", $1);
         }

         if ($3 >= 0) {
            $$.location = $3;
         } else {
             _mesa_glsl_error(& @@3, state, "invalid location %d specified", $3);
             YYERROR;
         }
      }

      if (match_layout_qualifier("index", $1, state) == 0) {
         $$.flags.q.explicit_index = 1;

         if ($3 >= 0) {
            $$.index = $3;
         } else {
            _mesa_glsl_error(& @@3, state, "invalid index %d specified", $3);
            YYERROR;
         }
      }

      if ((state->ARB_shading_language_420pack_enable ||
           state->ARB_shader_atomic_counters_enable) &&
          match_layout_qualifier("binding", $1, state) == 0) {
         $$.flags.q.explicit_binding = 1;
         $$.binding = $3;
      }

      if (state->ARB_shader_atomic_counters_enable &&
          match_layout_qualifier("offset", $1, state) == 0) {
         $$.flags.q.explicit_offset = 1;
         $$.offset = $3;
      }

      if (match_layout_qualifier("max_vertices", $1, state) == 0) {
         $$.flags.q.max_vertices = 1;

         if ($3 < 0) {
            _mesa_glsl_error(& @@3, state,
                             "invalid max_vertices %d specified", $3);
            YYERROR;
         } else {
            $$.max_vertices = $3;
            if (!state->is_version(150, 0)) {
d1243 2
a1244 2
                                "#version 150 max_vertices qualifier "
                                "specified", $3);
a1246 1
      }
d1248 6
a1253 9
      static const char * const local_size_qualifiers[3] = {
         "local_size_x",
         "local_size_y",
         "local_size_z",
      };
      for (int i = 0; i < 3; i++) {
         if (match_layout_qualifier(local_size_qualifiers[i], $1,
                                    state) == 0) {
            if ($3 <= 0) {
d1255 1
a1255 2
                                "invalid %s of %d specified",
                                local_size_qualifiers[i], $3);
a1256 10
            } else if (!state->is_version(430, 0) &&
                       !state->ARB_compute_shader_enable) {
               _mesa_glsl_error(& @@3, state,
                                "%s qualifier requires GLSL 4.30 or "
                                "ARB_compute_shader",
                                local_size_qualifiers[i]);
               YYERROR;
            } else {
               $$.flags.q.local_size |= (1 << i);
               $$.local_size[i] = $3;
a1257 1
            break;
d1261 4
a1264 21
      if (match_layout_qualifier("invocations", $1, state) == 0) {
         $$.flags.q.invocations = 1;

         if ($3 <= 0) {
            _mesa_glsl_error(& @@3, state,
                             "invalid invocations %d specified", $3);
            YYERROR;
         } else if ($3 > MAX_GEOMETRY_SHADER_INVOCATIONS) {
            _mesa_glsl_error(& @@3, state,
                             "invocations (%d) exceeds "
                             "GL_MAX_GEOMETRY_SHADER_INVOCATIONS", $3);
            YYERROR;
         } else {
            $$.invocations = $3;
            if (!state->is_version(400, 0) &&
                !state->ARB_gpu_shader5_enable) {
               _mesa_glsl_error(& @@3, state,
                                "GL_ARB_gpu_shader5 invocations "
                                "qualifier specified", $3);
            }
         }
d1272 1
a1272 1
                          "`%s'", $1);
d1274 4
d1284 1
a1284 1
      if ($$.flags.q.uniform && !state->has_uniform_buffer_objects()) {
d1287 1
a1287 1
                          "layout qualifier `%s' is used", $1);
d1291 1
a1291 1
                            "layout qualifier `%s' is used", $1);
a1299 4
 *
 * Note that since layout qualifiers are case-insensitive in desktop
 * GLSL, all of these qualifiers need to be handled as identifiers as
 * well (by the any_identifier path of layout_qualifier_id).
d1364 1
a1364 1
         _mesa_glsl_error(&@@1, state, "duplicate \"invariant\" qualifier");
d1368 1
a1368 1
                          "\"invariant\" cannot be used with layout(...)");
d1387 1
a1387 1
         _mesa_glsl_error(&@@1, state, "duplicate interpolation qualifier");
d1390 2
a1391 2
         _mesa_glsl_error(&@@1, state, "interpolation qualifiers cannot be used "
                          "with layout(...)");
d1395 2
a1396 2
         _mesa_glsl_error(&@@1, state, "interpolation qualifiers must come "
                          "after \"invariant\"");
d1411 1
a1411 1
         _mesa_glsl_error(&@@1, state, "duplicate layout(...) qualifiers");
d1415 1
a1415 1
                          "the \"invariant\" qualifier");
d1419 1
a1419 1
                          "interpolation qualifiers");
d1429 1
a1429 1
                          "duplicate auxiliary storage qualifier (centroid or sample)");
d1434 2
a1435 2
         _mesa_glsl_error(&@@1, state, "auxiliary storage qualifiers must come "
                          "just before storage qualifiers");
d1438 1
a1438 1
      $$.merge_qualifier(&@@1, state, $2);
d1447 1
a1447 1
         _mesa_glsl_error(&@@1, state, "duplicate storage qualifier");
d1452 1
a1452 1
         _mesa_glsl_error(&@@1, state, "storage qualifiers must come after "
d1454 1
a1454 1
                          "storage qualifiers");
d1463 1
a1463 1
         _mesa_glsl_error(&@@1, state, "duplicate precision qualifier");
d1466 1
a1466 1
         _mesa_glsl_error(&@@1, state, "precision qualifiers must come last");
d1479 1
a1479 6
   | SAMPLE
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.sample = 1;
   }
   /* TODO: "patch" also goes here someday. */
a1511 26
   | COHERENT
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.coherent = 1;
   }
   | VOLATILE
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q._volatile = 1;
   }
   | RESTRICT
   {
      STATIC_ASSERT(sizeof($$.flags.q) <= sizeof($$.flags.i));
      memset(& $$, 0, sizeof($$));
      $$.flags.q.restrict_flag = 1;
   }
   | READONLY
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.read_only = 1;
   }
   | WRITEONLY
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.write_only = 1;
   }
d1514 3
a1516 14
array_specifier:
   '[' ']'
   {
      void *ctx = state;
      $$ = new(ctx) ast_array_specifier(@@1);
      $$->set_location_range(@@1, @@2);
   }
   | '[' constant_expression ']'
   {
      void *ctx = state;
      $$ = new(ctx) ast_array_specifier(@@1, $2);
      $$->set_location_range(@@1, @@3);
   }
   | array_specifier '[' ']'
d1519 2
a1520 10

      if (!state->ARB_arrays_of_arrays_enable) {
         _mesa_glsl_error(& @@1, state,
                          "GL_ARB_arrays_of_arrays "
                          "required for defining arrays of arrays");
      } else {
         _mesa_glsl_error(& @@1, state,
                          "only the outermost array dimension can "
                          "be unsized");
      }
d1522 1
a1522 1
   | array_specifier '[' constant_expression ']'
d1525 2
a1526 17

      if (!state->ARB_arrays_of_arrays_enable) {
         _mesa_glsl_error(& @@1, state,
                          "GL_ARB_arrays_of_arrays "
                          "required for defining arrays of arrays");
      }

      $$->add_dimension($3);
   }
   ;

type_specifier:
   type_specifier_nonarray
   | type_specifier_nonarray array_specifier
   {
      $$ = $1;
      $$->array_specifier = $2;
d1535 1
a1535 1
      $$->set_location(@@1);
d1541 1
a1541 1
      $$->set_location(@@1);
d1547 1
a1547 1
      $$->set_location(@@1);
a1618 34
   | IMAGE1D                { $$ = "image1D"; }
   | IMAGE2D                { $$ = "image2D"; }
   | IMAGE3D                { $$ = "image3D"; }
   | IMAGE2DRECT            { $$ = "image2DRect"; }
   | IMAGECUBE              { $$ = "imageCube"; }
   | IMAGEBUFFER            { $$ = "imageBuffer"; }
   | IMAGE1DARRAY           { $$ = "image1DArray"; }
   | IMAGE2DARRAY           { $$ = "image2DArray"; }
   | IMAGECUBEARRAY         { $$ = "imageCubeArray"; }
   | IMAGE2DMS              { $$ = "image2DMS"; }
   | IMAGE2DMSARRAY         { $$ = "image2DMSArray"; }
   | IIMAGE1D               { $$ = "iimage1D"; }
   | IIMAGE2D               { $$ = "iimage2D"; }
   | IIMAGE3D               { $$ = "iimage3D"; }
   | IIMAGE2DRECT           { $$ = "iimage2DRect"; }
   | IIMAGECUBE             { $$ = "iimageCube"; }
   | IIMAGEBUFFER           { $$ = "iimageBuffer"; }
   | IIMAGE1DARRAY          { $$ = "iimage1DArray"; }
   | IIMAGE2DARRAY          { $$ = "iimage2DArray"; }
   | IIMAGECUBEARRAY        { $$ = "iimageCubeArray"; }
   | IIMAGE2DMS             { $$ = "iimage2DMS"; }
   | IIMAGE2DMSARRAY        { $$ = "iimage2DMSArray"; }
   | UIMAGE1D               { $$ = "uimage1D"; }
   | UIMAGE2D               { $$ = "uimage2D"; }
   | UIMAGE3D               { $$ = "uimage3D"; }
   | UIMAGE2DRECT           { $$ = "uimage2DRect"; }
   | UIMAGECUBE             { $$ = "uimageCube"; }
   | UIMAGEBUFFER           { $$ = "uimageBuffer"; }
   | UIMAGE1DARRAY          { $$ = "uimage1DArray"; }
   | UIMAGE2DARRAY          { $$ = "uimage2DArray"; }
   | UIMAGECUBEARRAY        { $$ = "uimageCubeArray"; }
   | UIMAGE2DMS             { $$ = "uimage2DMS"; }
   | UIMAGE2DMSARRAY        { $$ = "uimage2DMSArray"; }
   | ATOMIC_UINT            { $$ = "atomic_uint"; }
d1644 1
a1644 1
      $$->set_location_range(@@2, @@5);
d1646 1
d1652 1
a1652 1
      $$->set_location_range(@@2, @@4);
d1674 1
a1674 1
      type->set_location(@@1);
d1682 1
a1682 1
      $$->set_location(@@2);
d1705 2
a1706 2
      $$ = new(ctx) ast_declaration($1, NULL, NULL);
      $$->set_location(@@1);
d1708 1
a1708 1
   | any_identifier array_specifier
d1711 2
a1712 2
      $$ = new(ctx) ast_declaration($1, $2, NULL);
      $$->set_location_range(@@1, @@2);
d1733 1
a1733 1
      $$->set_location(@@1);
d1767 1
a1767 1
      $$->set_location_range(@@1, @@2);
d1777 1
a1777 1
      $$->set_location_range(@@1, @@4);
d1792 1
a1792 1
      $$->set_location_range(@@1, @@2);
d1798 1
a1798 1
      $$->set_location_range(@@1, @@3);
d1806 1
a1806 1
         _mesa_glsl_error(& @@1, state, "<nil> statement");
d1816 1
a1816 1
         _mesa_glsl_error(& @@2, state, "<nil> statement");
d1829 1
a1829 1
      $$->set_location(@@1);
d1835 1
a1835 1
      $$->set_location(@@1);
d1844 1
a1844 1
      $$->set_location_range(@@1, @@5);
d1869 1
a1869 1
      ast_declaration *decl = new(ctx) ast_declaration($2, NULL, $4);
d1871 2
a1872 2
      decl->set_location_range(@@2, @@4);
      declarator->set_location(@@1);
d1887 1
a1887 1
      $$->set_location_range(@@1, @@5);
d1895 1
a1895 1
      $$->set_location_range(@@1, @@2);
d1900 1
a1900 1
      $$->set_location_range(@@1, @@3);
d1908 1
a1908 1
      $$->set_location(@@2);
d1913 1
a1913 1
      $$->set_location(@@2);
d1924 1
a1924 1
      $$->set_location(@@1);
d1937 1
a1937 1
      stmts->set_location(@@2);
d1953 1
a1953 1
      cases->set_location(@@1);
d1971 1
a1971 1
      $$->set_location_range(@@1, @@4);
d1978 1
a1978 1
      $$->set_location_range(@@1, @@6);
d1985 1
a1985 1
      $$->set_location_range(@@1, @@6);
d2021 1
a2021 1
      $$->set_location(@@1);
d2027 1
a2027 1
      $$->set_location(@@1);
d2033 1
a2033 1
      $$->set_location(@@1);
d2039 1
a2039 1
      $$->set_location_range(@@1, @@2);
d2045 1
a2045 1
      $$->set_location(@@1);
d2053 1
a2053 1
   | layout_defaults        { $$ = $1; }
d2061 1
a2061 1
      $$->set_location_range(@@1, @@2);
d2094 1
a2094 1
         if (!state->has_uniform_buffer_objects()) {
d2097 1
a2097 1
                             "required for defining uniform blocks");
d2101 1
a2101 1
                               "required for defining uniform blocks");
d2107 1
a2107 1
                             "interface blocks");
d2115 1
a2115 1
      if ((state->stage == MESA_SHADER_VERTEX) && $1.flags.q.in) {
d2118 2
a2119 2
                          "a vertex shader");
      } else if ((state->stage == MESA_SHADER_FRAGMENT) && $1.flags.q.out) {
d2122 1
a2122 1
                          "a fragment shader");
d2134 1
a2134 1
      uint64_t interface_type_mask;
d2150 1
a2150 1
      uint64_t block_interface_qualifier = $1.flags.i;
d2174 1
a2174 1
                             "the interface block");
a2209 1
      $$->set_location(@@1);
d2211 1
a2211 1
   | NEW_IDENTIFIER array_specifier
d2214 9
a2222 2
                                          $1, $2);
      $$->set_location_range(@@1, @@2);
d2244 1
a2244 1
      type->set_location(@@1);
d2249 1
a2249 1
                          "interface block member");
d2253 1
a2253 1
                          "interface block member");
d2257 1
a2257 1
      $$->set_location(@@2);
a2268 35
      $$ = NULL;
   }

   | layout_qualifier IN_TOK ';'
   {
      $$ = NULL;
      if (!state->in_qualifier->merge_in_qualifier(& @@1, state, $1, $$)) {
         YYERROR;
      }
   }

   | layout_qualifier OUT_TOK ';'
   {
      if (state->stage != MESA_SHADER_GEOMETRY) {
         _mesa_glsl_error(& @@1, state,
                          "out layout qualifiers only valid in "
                          "geometry shaders");
      } else {
         if ($1.flags.q.prim_type) {
            /* Make sure this is a valid output primitive type. */
            switch ($1.prim_type) {
            case GL_POINTS:
            case GL_LINE_STRIP:
            case GL_TRIANGLE_STRIP:
               break;
            default:
               _mesa_glsl_error(&@@1, state, "invalid geometry shader output "
                                "primitive type");
               break;
            }
         }
         if (!state->out_qualifier->merge_qualifier(& @@1, state, $1))
            YYERROR;
      }
      $$ = NULL;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a26 3
#ifndef _MSC_VER
#include <strings.h>
#endif
d131 1
a131 1
%token CENTROID IN_TOK OUT_TOK INOUT_TOK UNIFORM VARYING SAMPLE
d169 1
a169 1
%token INVARIANT PRECISE
d182 1
a182 1
%token LONG_TOK SHORT_TOK DOUBLE_TOK HALF FIXED_TOK UNSIGNED INPUT_TOK
d186 1
a186 1
%token RESOURCE PATCH
a378 8
   | external_declaration_list extension_statement {
      if (!state->allow_extension_directive_midshader) {
         _mesa_glsl_error(& @@2, state,
                          "#extension directive is not allowed "
                          "in the middle of a shader");
         YYERROR;
      }
   }
a933 8
   | PRECISE parameter_qualifier
   {
      if ($2.flags.q.precise)
         _mesa_glsl_error(&@@1, state, "duplicate precise qualifier");

      $$ = $2;
      $$.flags.q.precise = 1;
   }
d940 2
a941 2
         _mesa_glsl_error(&@@1, state, "in/out/inout must come after const "
                                      "or precise");
d1074 1
a1074 1
   | INVARIANT variable_identifier
a1085 12
   | PRECISE variable_identifier
   {
      void *ctx = state;
      ast_declaration *decl = new(ctx) ast_declaration($2, NULL, NULL);
      decl->set_location(@@2);

      $$ = new(ctx) ast_declarator_list(NULL);
      $$->set_location_range(@@1, @@2);
      $$->precise = true;

      $$->declarations.push_tail(&decl->link);
   }
a1377 16
      if (state->stage == MESA_SHADER_GEOMETRY) {
         if (match_layout_qualifier("stream", $1, state) == 0 &&
             state->check_explicit_attrib_stream_allowed(& @@3)) {
            $$.flags.q.stream = 1;

            if ($3 < 0) {
               _mesa_glsl_error(& @@3, state,
                                "invalid stream %d specified", $3);
               YYERROR;
            } else {
               $$.flags.q.explicit_stream = 1;
               $$.stream = $3;
            }
         }
      }

a1500 5
   | PRECISE
   {
      memset(& $$, 0, sizeof($$));
      $$.flags.q.precise = 1;
   }
d1521 1
a1521 1
    * no auxiliary, interpolation, layout, invariant, or precise qualifiers to the right.
a1522 8
   | PRECISE type_qualifier
   {
      if ($2.flags.q.precise)
         _mesa_glsl_error(&@@1, state, "duplicate \"precise\" qualifier");

      $$ = $2;
      $$.flags.q.precise = 1;
   }
d1528 1
a1528 1
      if (!state->ARB_shading_language_420pack_enable && $2.flags.q.precise)
d1530 2
a1531 1
                          "\"invariant\" must come after \"precise\"");
d1551 6
a1556 2
      if (!state->ARB_shading_language_420pack_enable &&
          ($2.flags.q.precise || $2.flags.q.invariant)) {
d1558 1
a1558 1
                          "after \"precise\" or \"invariant\"");
d1566 5
a1570 8
      /* In the absence of ARB_shading_language_420pack, layout qualifiers may
       * appear no later than auxiliary storage qualifiers. There is no
       * particularly clear spec language mandating this, but in all examples
       * the layout qualifier precedes the storage qualifier.
       *
       * We allow combinations of layout with interpolation, invariant or
       * precise qualifiers since these are useful in ARB_separate_shader_objects.
       * There is no clear spec guidance on this either.
d1575 9
d1595 1
a1595 2
          ($2.flags.q.precise || $2.flags.q.invariant ||
           $2.has_interpolation() || $2.has_layout())) {
d1612 2
a1613 2
          ($2.flags.q.precise || $2.flags.q.invariant || $2.has_interpolation() ||
           $2.has_layout() || $2.has_auxiliary_storage())) {
d1615 1
a1615 1
                          "precise, invariant, interpolation, layout and auxiliary "
a1672 14

      if (state->stage == MESA_SHADER_GEOMETRY &&
          state->has_explicit_attrib_stream()) {
         /* Section 4.3.8.2 (Output Layout Qualifiers) of the GLSL 4.00
          * spec says:
          *
          *     "If the block or variable is declared with the stream
          *     identifier, it is associated with the specified stream;
          *     otherwise, it is associated with the current default stream."
          */
          $$.flags.q.stream = 1;
          $$.flags.q.explicit_stream = 0;
          $$.stream = state->out_qualifier->stream;
      }
d2140 1
a2140 1
 * switch_statement grammar is based on the syntax described in the body
a2340 12

      foreach_list_typed (ast_declarator_list, member, link, &block->declarations) {
         ast_type_qualifier& qualifier = member->type->qualifier;
         if (qualifier.flags.q.stream && qualifier.stream != block->layout.stream) {
               _mesa_glsl_error(& @@1, state,
                             "stream layout qualifier on "
                             "interface block member does not match "
                             "the interface block (%d vs %d)",
                             qualifier.stream, block->layout.stream);
               YYERROR;
         }
      }
a2413 8
      if (state->stage == MESA_SHADER_GEOMETRY &&
          state->has_explicit_attrib_stream()) {
         /* Assign global layout's stream value. */
         block->layout.flags.q.stream = 1;
         block->layout.flags.q.explicit_stream = 0;
         block->layout.stream = state->out_qualifier->stream;
      }

a2555 3

         /* Allow future assigments of global out's stream id value */
         state->out_qualifier->flags.q.explicit_stream = 0;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d27 3
d134 1
a134 1
%token CENTROID IN_TOK OUT_TOK INOUT_TOK UNIFORM VARYING
d172 1
a172 1
%token INVARIANT
d185 1
a185 1
%token LONG_TOK SHORT_TOK DOUBLE_TOK HALF FIXED_TOK UNSIGNED INPUT_TOK OUPTUT
d189 1
a189 1
%token RESOURCE PATCH SAMPLE
d382 8
d945 8
d959 2
a960 2
         _mesa_glsl_error(&@@1, state, "const must be specified before "
                          "in/out/inout");
d1093 1
a1093 1
   | INVARIANT variable_identifier // Vertex only.
d1105 12
d1409 16
d1548 5
d1573 1
a1573 1
    * no auxiliary, interpolation, layout, or invariant qualifiers to the right.
d1575 8
d1588 1
a1588 1
      if ($2.has_layout()) {
d1590 1
a1590 2
                          "\"invariant\" cannot be used with layout(...)");
      }
d1610 2
a1611 6
      if ($2.has_layout()) {
         _mesa_glsl_error(&@@1, state, "interpolation qualifiers cannot be used "
                          "with layout(...)");
      }

      if (!state->ARB_shading_language_420pack_enable && $2.flags.q.invariant) {
d1613 1
a1613 1
                          "after \"invariant\"");
d1621 8
a1628 5
      /* The GLSL 1.50 grammar indicates that a layout(...) declaration can be
       * used standalone or immediately before a storage qualifier.  It cannot
       * be used with interpolation qualifiers or invariant.  There does not
       * appear to be any text indicating that it must come before the storage
       * qualifier, but always seems to in examples.
a1632 9
      if ($2.flags.q.invariant)
         _mesa_glsl_error(&@@1, state, "layout(...) cannot be used with "
                          "the \"invariant\" qualifier");

      if ($2.has_interpolation()) {
         _mesa_glsl_error(&@@1, state, "layout(...) cannot be used with "
                          "interpolation qualifiers");
      }

d1644 2
a1645 1
          ($2.flags.q.invariant || $2.has_interpolation() || $2.has_layout())) {
d1662 2
a1663 2
          ($2.flags.q.invariant || $2.has_interpolation() || $2.has_layout() ||
           $2.has_auxiliary_storage())) {
d1665 1
a1665 1
                          "invariant, interpolation, layout and auxiliary "
d1723 14
d2204 1
a2204 1
 * siwtch_statement grammar is based on the syntax described in the body
d2405 12
d2490 8
d2640 3
@


