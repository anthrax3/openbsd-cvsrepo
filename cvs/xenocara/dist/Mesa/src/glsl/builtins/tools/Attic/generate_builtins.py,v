head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2014.07.09.21.08.58;	author jsg;	state dead;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.42;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.11;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.34;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@#!/usr/bin/python
# -*- coding: utf-8 -*-

from __future__ import with_statement

import re
import sys
from glob import glob
from os import path
from subprocess import Popen, PIPE
from sys import argv

# Local module: generator for texture lookup builtins
from texture_builtins import generate_texture_functions

builtins_dir = path.join(path.dirname(path.abspath(__file__)), "..")

# Get the path to the standalone GLSL compiler
if len(argv) != 2:
    print "Usage:", argv[0], "<path to compiler>"
    sys.exit(1)

compiler = argv[1]

# Read the files in builtins/ir/*...add them to the supplied dictionary.
def read_ir_files(fs):
    for filename in glob(path.join(path.join(builtins_dir, 'ir'), '*.ir')):
        function_name = path.basename(filename).split('.')[0]
        with open(filename) as f:
            fs[function_name] = f.read()

def read_glsl_files(fs):
    for filename in glob(path.join(path.join(builtins_dir, 'glsl'), '*.glsl')):
        function_name = path.basename(filename).split('.')[0]
        (output, returncode) = run_compiler([filename])
        if (returncode):
            sys.stderr.write("Failed to compile builtin: " + filename + "\n")
            sys.stderr.write("Result:\n")
            sys.stderr.write(output)
        else:
            fs[function_name] = output;

# Return a dictionary containing all builtin definitions (even generated)
def get_builtin_definitions():
    fs = {}
    generate_texture_functions(fs)
    read_ir_files(fs)
    read_glsl_files(fs)
    return fs

def stringify(s):
    # Work around MSVC's 65535 byte limit by outputting an array of characters
    # rather than actual string literals.
    if len(s) >= 65535:
        #t = "/* Warning: length " + repr(len(s)) + " too large */\n"
        t = ""
        for c in re.sub('\s\s+', ' ', s):
            if c == '\n':
                t += '\n'
            else:
                t += "'" + c + "',"
        return '{' + t[:-1] + '}'

    t = s.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n"\n   "')
    return '   "' + t + '"\n'

def write_function_definitions():
    fs = get_builtin_definitions()
    for k, v in sorted(fs.iteritems()):
        print 'static const char builtin_' + k + '[] ='
        print stringify(v), ';'

def run_compiler(args):
    command = [compiler, '--dump-hir'] + args
    p = Popen(command, 1, stdout=PIPE, shell=False)
    output = p.communicate()[0]

    if (p.returncode):
        sys.stderr.write("Failed to compile builtins with command:\n")
        for arg in command:
            sys.stderr.write(arg + " ")
        sys.stderr.write("\n")
        sys.stderr.write("Result:\n")
        sys.stderr.write(output)

    # Clean up output a bit by killing whitespace before a closing paren.
    kill_paren_whitespace = re.compile(r'[ \n]*\)', re.MULTILINE)
    output = kill_paren_whitespace.sub(')', output)

    # Also toss any duplicate newlines
    output = output.replace('\n\n', '\n')

    # Kill any global variable declarations.  We don't want them.
    kill_globals = re.compile(r'^\(declare.*\n', re.MULTILINE)
    output = kill_globals.sub('', output)

    return (output, p.returncode)

def write_profile(filename, profile):
    (proto_ir, returncode) = run_compiler([filename])

    if returncode != 0:
        print '#error builtins profile', profile, 'failed to compile'
        return

    print 'static const char prototypes_for_' + profile + '[] ='
    print stringify(proto_ir), ';'

    # Print a table of all the functions (not signatures) referenced.
    # This is done so we can avoid bothering with a hash table in the C++ code.

    function_names = set()
    for func in re.finditer(r'\(function (.+)\n', proto_ir):
        function_names.add(func.group(1))

    print 'static const char *functions_for_' + profile + ' [] = {'
    for func in sorted(function_names):
        print '   builtin_' + func + ','
    print '};'

def write_profiles():
    profiles = get_profile_list()
    for (filename, profile) in profiles:
        write_profile(filename, profile)

def get_profile_list():
    profile_files = []
    for extension in ['glsl', 'frag', 'vert']:
        path_glob = path.join(
            path.join(builtins_dir, 'profiles'), '*.' + extension)
        profile_files.extend(glob(path_glob))
    profiles = []
    for pfile in sorted(profile_files):
        profiles.append((pfile, path.basename(pfile).replace('.', '_')))
    return profiles

if __name__ == "__main__":
    print """/* DO NOT MODIFY - automatically generated by generate_builtins.py */
/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdio.h>
#include "main/core.h" /* for struct gl_shader */
#include "glsl_parser_extras.h"
#include "ir_reader.h"
#include "program.h"
#include "ast.h"

extern "C" struct gl_shader *
_mesa_new_shader(struct gl_context *ctx, GLuint name, GLenum type);

gl_shader *
read_builtins(GLenum target, const char *protos, const char **functions, unsigned count)
{
   struct gl_context fakeCtx;
   fakeCtx.API = API_OPENGL_COMPAT;
   fakeCtx.Const.GLSLVersion = 150;
   fakeCtx.Extensions.ARB_ES2_compatibility = true;
   fakeCtx.Extensions.ARB_ES3_compatibility = true;
   fakeCtx.Const.ForceGLSLExtensionsWarn = false;
   gl_shader *sh = _mesa_new_shader(NULL, 0, target);
   struct _mesa_glsl_parse_state *st =
      new(sh) _mesa_glsl_parse_state(&fakeCtx, target, sh);

   st->language_version = 150;
   st->symbols->separate_function_namespace = false;
   st->ARB_texture_rectangle_enable = true;
   st->EXT_texture_array_enable = true;
   st->OES_EGL_image_external_enable = true;
   st->ARB_shader_bit_encoding_enable = true;
   st->ARB_texture_cube_map_array_enable = true;
   st->ARB_shading_language_packing_enable = true;
   st->ARB_texture_multisample_enable = true;
   st->ARB_texture_query_lod_enable = true;
   st->ARB_gpu_shader5_enable = true;
   _mesa_glsl_initialize_types(st);

   sh->ir = new(sh) exec_list;
   sh->symbols = st->symbols;

   /* Read the IR containing the prototypes */
   _mesa_glsl_read_ir(st, sh->ir, protos, true);

   /* Read ALL the function bodies, telling the IR reader not to scan for
    * prototypes (we've already created them).  The IR reader will skip any
    * signature that does not already exist as a prototype.
    */
   for (unsigned i = 0; i < count; i++) {
      _mesa_glsl_read_ir(st, sh->ir, functions[i], false);

      if (st->error) {
         printf("error reading builtin: %.35s ...\\n", functions[i]);
         printf("Info log:\\n%s\\n", st->info_log);
         ralloc_free(sh);
         return NULL;
      }
   }

   reparent_ir(sh->ir, sh);
   delete st;

   return sh;
}
"""

    write_function_definitions()
    write_profiles()

    profiles = get_profile_list()

    print 'static gl_shader *builtin_profiles[%d];' % len(profiles)

    print """
static void *builtin_mem_ctx = NULL;

void
_mesa_glsl_release_functions(void)
{
   ralloc_free(builtin_mem_ctx);
   builtin_mem_ctx = NULL;
   memset(builtin_profiles, 0, sizeof(builtin_profiles));
}

static void
_mesa_read_profile(struct _mesa_glsl_parse_state *state,
                   int profile_index,
		   const char *prototypes,
		   const char **functions,
                   int count)
{
   gl_shader *sh = builtin_profiles[profile_index];

   if (sh == NULL) {
      sh = read_builtins(GL_VERTEX_SHADER, prototypes, functions, count);
      ralloc_steal(builtin_mem_ctx, sh);
      builtin_profiles[profile_index] = sh;
   }

   state->builtins_to_link[state->num_builtins_to_link] = sh;
   state->num_builtins_to_link++;
}

void
_mesa_glsl_initialize_functions(struct _mesa_glsl_parse_state *state)
{
   /* If we've already initialized the built-ins, bail early. */
   if (state->num_builtins_to_link > 0)
      return;

   if (builtin_mem_ctx == NULL) {
      builtin_mem_ctx = ralloc_context(NULL); // "GLSL built-in functions"
      memset(&builtin_profiles, 0, sizeof(builtin_profiles));
   }
"""

    i = 0
    for (filename, profile) in profiles:
        if profile.endswith('_vert'):
            check = 'state->target == vertex_shader && '
        elif profile.endswith('_frag'):
            check = 'state->target == fragment_shader && '
        else:
            check = ''

        version = re.sub(r'_(glsl|vert|frag)$', '', profile)
        if version[0].isdigit():
            is_es = version.endswith('es')
            if is_es:
                version = version[:-2]
            check += 'state->language_version == ' + version
            check += ' && {0}state->es_shader'.format('' if is_es else '!')
        else: # an extension name
            check += 'state->' + version + '_enable'

        print '   if (' + check + ') {'
        print '      _mesa_read_profile(state, %d,' % i
        print '                         prototypes_for_' + profile + ','
        print '                         functions_for_' + profile + ','
        print '                         Elements(functions_for_' + profile + '));'
        print '   }'
        print
        i = i + 1
    print '}'

@


1.3
log
@Merge Mesa 9.2.0
@
text
@@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d27 2
a28 1
    for filename in glob(path.join(path.join(builtins_dir, 'ir'), '*')):
d30 12
a41 1
            fs[path.basename(filename)] = f.read()
d48 1
d74 1
a74 1
    command = [compiler, '--dump-lir'] + args
d78 8
d93 4
a105 4
    # Kill any global variable declarations.  We don't want them.
    kill_globals = re.compile(r'^\(declare.*\n', re.MULTILINE)
    proto_ir = kill_globals.sub('', proto_ir)

d127 5
d133 1
a133 1
    for pfile in sorted(glob(path.join(path.join(builtins_dir, 'profiles'), '*'))):
d176 2
a177 2
   fakeCtx.API = API_OPENGL;
   fakeCtx.Const.GLSLVersion = 130;
d179 2
d185 2
a186 2
   st->language_version = 130;
   st->symbols->language_version = 130;
d189 7
d234 1
a234 1
void *builtin_mem_ctx = NULL;
d266 4
a273 2

   state->num_builtins_to_link = 0;
d282 2
d285 5
a289 2
        version = re.sub(r'_(vert|frag)$', '', profile)
        if version.isdigit():
d291 1
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
d11 1
d18 7
d61 1
a61 2
    compiler_path = path.join(path.join(builtins_dir, '..'), 'glsl_compiler')
    command = [compiler_path, '--dump-lir'] + args
d66 2
a67 2
    kill_paren_whitespace = re.compile(r'[ \n]*\)', re.MULTILINE);
    output = kill_paren_whitespace.sub(')', output);
d82 1
a82 1
    kill_globals = re.compile(r'^\(declare.*\n', re.MULTILINE);
a84 4
    # Kill pointer addresses.  They're not necessary in prototypes and just
    # clutter the diff output.
    proto_ir = re.sub(r'@@0x[0-9a-f]+', '', proto_ir);

a210 1
		   exec_list *instructions,
d229 1
a229 2
_mesa_glsl_initialize_functions(exec_list *instructions,
                                struct _mesa_glsl_parse_state *state)
d239 1
a239 1
    i=0
d253 1
a253 1
        print '      _mesa_read_profile(state, instructions, %d,' % i
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a3 2
from __future__ import with_statement

a4 1
import sys
a7 1
from sys import argv
a13 7
# Get the path to the standalone GLSL compiler
if len(argv) != 2:
    print "Usage:", argv[0], "<path to compiler>"
    sys.exit(1)

compiler = argv[1]

d16 1
a16 2
    for filename in glob(path.join(path.join(builtins_dir, 'ir'), '*.ir')):
        function_name = path.basename(filename).split('.')[0]
d18 1
a18 12
            fs[function_name] = f.read()

def read_glsl_files(fs):
    for filename in glob(path.join(path.join(builtins_dir, 'glsl'), '*.glsl')):
        function_name = path.basename(filename).split('.')[0]
        (output, returncode) = run_compiler([filename])
        if (returncode):
            sys.stderr.write("Failed to compile builtin: " + filename + "\n")
            sys.stderr.write("Result:\n")
            sys.stderr.write(output)
        else:
            fs[function_name] = output;
a24 1
    read_glsl_files(fs)
d50 2
a51 1
    command = [compiler, '--dump-hir'] + args
a54 8
    if (p.returncode):
        sys.stderr.write("Failed to compile builtins with command:\n")
        for arg in command:
            sys.stderr.write(arg + " ")
        sys.stderr.write("\n")
        sys.stderr.write("Result:\n")
        sys.stderr.write(output)

d56 2
a57 2
    kill_paren_whitespace = re.compile(r'[ \n]*\)', re.MULTILINE)
    output = kill_paren_whitespace.sub(')', output)
a61 4
    # Kill any global variable declarations.  We don't want them.
    kill_globals = re.compile(r'^\(declare.*\n', re.MULTILINE)
    output = kill_globals.sub('', output)

d71 8
a99 5
    profile_files = []
    for extension in ['glsl', 'frag', 'vert']:
        path_glob = path.join(
            path.join(builtins_dir, 'profiles'), '*.' + extension)
        profile_files.extend(glob(path_glob))
d101 1
a101 1
    for pfile in sorted(profile_files):
d144 2
a145 2
   fakeCtx.API = API_OPENGL_COMPAT;
   fakeCtx.Const.GLSLVersion = 150;
a146 2
   fakeCtx.Extensions.ARB_ES3_compatibility = true;
   fakeCtx.Const.ForceGLSLExtensionsWarn = false;
d151 2
a152 2
   st->language_version = 150;
   st->symbols->separate_function_namespace = false;
a154 7
   st->OES_EGL_image_external_enable = true;
   st->ARB_shader_bit_encoding_enable = true;
   st->ARB_texture_cube_map_array_enable = true;
   st->ARB_shading_language_packing_enable = true;
   st->ARB_texture_multisample_enable = true;
   st->ARB_texture_query_lod_enable = true;
   st->ARB_gpu_shader5_enable = true;
d193 1
a193 1
static void *builtin_mem_ctx = NULL;
d205 1
d224 2
a225 1
_mesa_glsl_initialize_functions(struct _mesa_glsl_parse_state *state)
a226 4
   /* If we've already initialized the built-ins, bail early. */
   if (state->num_builtins_to_link > 0)
      return;

d231 2
d235 1
a235 1
    i = 0
a240 2
        else:
            check = ''
d242 2
a243 5
        version = re.sub(r'_(glsl|vert|frag)$', '', profile)
        if version[0].isdigit():
            is_es = version.endswith('es')
            if is_es:
                version = version[:-2]
a244 1
            check += ' && {0}state->es_shader'.format('' if is_es else '!')
d249 1
a249 1
        print '      _mesa_read_profile(state, %d,' % i
@

