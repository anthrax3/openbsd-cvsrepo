head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.44;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.58;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.43;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.11;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.30;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.32;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.34;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.40;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@%{
/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <inttypes.h>

#include "glcpp.h"
#include "main/core.h" /* for struct gl_extensions */
#include "main/mtypes.h" /* for gl_api enum */

static void
yyerror (YYLTYPE *locp, glcpp_parser_t *parser, const char *error);

static void
_define_object_macro (glcpp_parser_t *parser,
		      YYLTYPE *loc,
		      const char *macro,
		      token_list_t *replacements);

static void
_define_function_macro (glcpp_parser_t *parser,
			YYLTYPE *loc,
			const char *macro,
			string_list_t *parameters,
			token_list_t *replacements);

static string_list_t *
_string_list_create (void *ctx);

static void
_string_list_append_item (string_list_t *list, const char *str);

static int
_string_list_contains (string_list_t *list, const char *member, int *index);

static int
_string_list_length (string_list_t *list);

static int
_string_list_equal (string_list_t *a, string_list_t *b);

static argument_list_t *
_argument_list_create (void *ctx);

static void
_argument_list_append (argument_list_t *list, token_list_t *argument);

static int
_argument_list_length (argument_list_t *list);

static token_list_t *
_argument_list_member_at (argument_list_t *list, int index);

/* Note: This function ralloc_steal()s the str pointer. */
static token_t *
_token_create_str (void *ctx, int type, char *str);

static token_t *
_token_create_ival (void *ctx, int type, int ival);

static token_list_t *
_token_list_create (void *ctx);

static void
_token_list_append (token_list_t *list, token_t *token);

static void
_token_list_append_list (token_list_t *list, token_list_t *tail);

static int
_token_list_equal_ignoring_space (token_list_t *a, token_list_t *b);

static void
_parser_active_list_push (glcpp_parser_t *parser,
			  const char *identifier,
			  token_node_t *marker);

static void
_parser_active_list_pop (glcpp_parser_t *parser);

static int
_parser_active_list_contains (glcpp_parser_t *parser, const char *identifier);

/* Expand list, and begin lexing from the result (after first
 * prefixing a token of type 'head_token_type').
 */
static void
_glcpp_parser_expand_and_lex_from (glcpp_parser_t *parser,
				   int head_token_type,
				   token_list_t *list);

/* Perform macro expansion in-place on the given list. */
static void
_glcpp_parser_expand_token_list (glcpp_parser_t *parser,
				 token_list_t *list);

static void
_glcpp_parser_print_expanded_token_list (glcpp_parser_t *parser,
					 token_list_t *list);

static void
_glcpp_parser_skip_stack_push_if (glcpp_parser_t *parser, YYLTYPE *loc,
				  int condition);

static void
_glcpp_parser_skip_stack_change_if (glcpp_parser_t *parser, YYLTYPE *loc,
				    const char *type, int condition);

static void
_glcpp_parser_skip_stack_pop (glcpp_parser_t *parser, YYLTYPE *loc);

static void
_glcpp_parser_handle_version_declaration(glcpp_parser_t *parser, intmax_t version,
                                         const char *ident, bool explicitly_set);

static int
glcpp_parser_lex (YYSTYPE *yylval, YYLTYPE *yylloc, glcpp_parser_t *parser);

static void
glcpp_parser_lex_from (glcpp_parser_t *parser, token_list_t *list);

static void
add_builtin_define(glcpp_parser_t *parser, const char *name, int value);

%}

%pure-parser
%error-verbose

%locations
%initial-action {
	@@$.first_line = 1;
	@@$.first_column = 1;
	@@$.last_line = 1;
	@@$.last_column = 1;
	@@$.source = 0;
}

%parse-param {glcpp_parser_t *parser}
%lex-param {glcpp_parser_t *parser}

%expect 0
%token COMMA_FINAL DEFINED ELIF_EXPANDED HASH HASH_DEFINE FUNC_IDENTIFIER OBJ_IDENTIFIER HASH_ELIF HASH_ELSE HASH_ENDIF HASH_IF HASH_IFDEF HASH_IFNDEF HASH_LINE HASH_UNDEF HASH_VERSION IDENTIFIER IF_EXPANDED INTEGER INTEGER_STRING LINE_EXPANDED NEWLINE OTHER PLACEHOLDER SPACE
%token PASTE
%type <ival> expression INTEGER operator SPACE integer_constant
%type <str> IDENTIFIER FUNC_IDENTIFIER OBJ_IDENTIFIER INTEGER_STRING OTHER
%type <string_list> identifier_list
%type <token> preprocessing_token conditional_token
%type <token_list> pp_tokens replacement_list text_line conditional_tokens
%left OR
%left AND
%left '|'
%left '^'
%left '&'
%left EQUAL NOT_EQUAL
%left '<' '>' LESS_OR_EQUAL GREATER_OR_EQUAL
%left LEFT_SHIFT RIGHT_SHIFT
%left '+' '-'
%left '*' '/' '%'
%right UNARY

%%

input:
	/* empty */
|	input line
;

line:
	control_line {
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "\n");
	}
|	HASH_LINE {
		glcpp_parser_resolve_implicit_version(parser);
	} pp_tokens NEWLINE {

		if (parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			_glcpp_parser_expand_and_lex_from (parser,
							   LINE_EXPANDED, $3);
		}
	}
|	text_line {
		_glcpp_parser_print_expanded_token_list (parser, $1);
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "\n");
		ralloc_free ($1);
	}
|	expanded_line
|	HASH non_directive
;

expanded_line:
	IF_EXPANDED expression NEWLINE {
		_glcpp_parser_skip_stack_push_if (parser, & @@1, $2);
	}
|	ELIF_EXPANDED expression NEWLINE {
		_glcpp_parser_skip_stack_change_if (parser, & @@1, "elif", $2);
	}
|	LINE_EXPANDED integer_constant NEWLINE {
		parser->has_new_line_number = 1;
		parser->new_line_number = $2;
		ralloc_asprintf_rewrite_tail (&parser->output,
					      &parser->output_length,
					      "#line %" PRIiMAX "\n",
					      $2);
	}
|	LINE_EXPANDED integer_constant integer_constant NEWLINE {
		parser->has_new_line_number = 1;
		parser->new_line_number = $2;
		parser->has_new_source_number = 1;
		parser->new_source_number = $3;
		ralloc_asprintf_rewrite_tail (&parser->output,
					      &parser->output_length,
					      "#line %" PRIiMAX " %" PRIiMAX "\n",
					      $2, $3);
	}
;

define:
	OBJ_IDENTIFIER replacement_list NEWLINE {
		_define_object_macro (parser, & @@1, $1, $2);
	}
|	FUNC_IDENTIFIER '(' ')' replacement_list NEWLINE {
		_define_function_macro (parser, & @@1, $1, NULL, $4);
	}
|	FUNC_IDENTIFIER '(' identifier_list ')' replacement_list NEWLINE {
		_define_function_macro (parser, & @@1, $1, $3, $5);
	}
;

control_line:
	HASH_DEFINE {
		glcpp_parser_resolve_implicit_version(parser);
	} define
|	HASH_UNDEF {
		glcpp_parser_resolve_implicit_version(parser);
	} IDENTIFIER NEWLINE {
		macro_t *macro = hash_table_find (parser->defines, $3);
		if (macro) {
			hash_table_remove (parser->defines, $3);
			ralloc_free (macro);
		}
		ralloc_free ($3);
	}
|	HASH_IF {
		glcpp_parser_resolve_implicit_version(parser);
	} conditional_tokens NEWLINE {
		/* Be careful to only evaluate the 'if' expression if
		 * we are not skipping. When we are skipping, we
		 * simply push a new 0-valued 'if' onto the skip
		 * stack.
		 *
		 * This avoids generating diagnostics for invalid
		 * expressions that are being skipped. */
		if (parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			_glcpp_parser_expand_and_lex_from (parser,
							   IF_EXPANDED, $3);
		}	
		else
		{
			_glcpp_parser_skip_stack_push_if (parser, & @@1, 0);
			parser->skip_stack->type = SKIP_TO_ENDIF;
		}
	}
|	HASH_IF NEWLINE {
		/* #if without an expression is only an error if we
		 *  are not skipping */
		if (parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			glcpp_error(& @@1, parser, "#if with no expression");
		}	
		_glcpp_parser_skip_stack_push_if (parser, & @@1, 0);
	}
|	HASH_IFDEF {
		glcpp_parser_resolve_implicit_version(parser);
	} IDENTIFIER junk NEWLINE {
		macro_t *macro = hash_table_find (parser->defines, $3);
		ralloc_free ($3);
		_glcpp_parser_skip_stack_push_if (parser, & @@1, macro != NULL);
	}
|	HASH_IFNDEF {
		glcpp_parser_resolve_implicit_version(parser);
	} IDENTIFIER junk NEWLINE {
		macro_t *macro = hash_table_find (parser->defines, $3);
		ralloc_free ($3);
		_glcpp_parser_skip_stack_push_if (parser, & @@2, macro == NULL);
	}
|	HASH_ELIF conditional_tokens NEWLINE {
		/* Be careful to only evaluate the 'elif' expression
		 * if we are not skipping. When we are skipping, we
		 * simply change to a 0-valued 'elif' on the skip
		 * stack.
		 *
		 * This avoids generating diagnostics for invalid
		 * expressions that are being skipped. */
		if (parser->skip_stack &&
		    parser->skip_stack->type == SKIP_TO_ELSE)
		{
			_glcpp_parser_expand_and_lex_from (parser,
							   ELIF_EXPANDED, $2);
		}
		else if (parser->skip_stack &&
		    parser->skip_stack->has_else)
		{
			glcpp_error(& @@1, parser, "#elif after #else");
		}
		else
		{
			_glcpp_parser_skip_stack_change_if (parser, & @@1,
							    "elif", 0);
		}
	}
|	HASH_ELIF NEWLINE {
		/* #elif without an expression is an error unless we
		 * are skipping. */
		if (parser->skip_stack &&
		    parser->skip_stack->type == SKIP_TO_ELSE)
		{
			glcpp_error(& @@1, parser, "#elif with no expression");
		}
		else if (parser->skip_stack &&
		    parser->skip_stack->has_else)
		{
			glcpp_error(& @@1, parser, "#elif after #else");
		}
		else
		{
			_glcpp_parser_skip_stack_change_if (parser, & @@1,
							    "elif", 0);
			glcpp_warning(& @@1, parser, "ignoring illegal #elif without expression");
		}
	}
|	HASH_ELSE {
		if (parser->skip_stack &&
		    parser->skip_stack->has_else)
		{
			glcpp_error(& @@1, parser, "multiple #else");
		}
		else
		{
			_glcpp_parser_skip_stack_change_if (parser, & @@1, "else", 1);
			if (parser->skip_stack)
				parser->skip_stack->has_else = true;
		}
	} NEWLINE
|	HASH_ENDIF {
		_glcpp_parser_skip_stack_pop (parser, & @@1);
	} NEWLINE
|	HASH_VERSION integer_constant NEWLINE {
		if (parser->version_resolved) {
			glcpp_error(& @@1, parser, "#version must appear on the first line");
		}
		_glcpp_parser_handle_version_declaration(parser, $2, NULL, true);
	}
|	HASH_VERSION integer_constant IDENTIFIER NEWLINE {
		if (parser->version_resolved) {
			glcpp_error(& @@1, parser, "#version must appear on the first line");
		}
		_glcpp_parser_handle_version_declaration(parser, $2, $3, true);
	}
|	HASH NEWLINE {
		glcpp_parser_resolve_implicit_version(parser);
	}
;

integer_constant:
	INTEGER_STRING {
		if (strlen ($1) >= 3 && strncmp ($1, "0x", 2) == 0) {
			$$ = strtoll ($1 + 2, NULL, 16);
		} else if ($1[0] == '0') {
			$$ = strtoll ($1, NULL, 8);
		} else {
			$$ = strtoll ($1, NULL, 10);
		}
	}
|	INTEGER {
		$$ = $1;
	}

expression:
	integer_constant
|	IDENTIFIER {
		if (parser->is_gles)
			glcpp_error(& @@1, parser, "undefined macro %s in expression (illegal in GLES)", $1);
		$$ = 0;
	}
|	expression OR expression {
		$$ = $1 || $3;
	}
|	expression AND expression {
		$$ = $1 && $3;
	}
|	expression '|' expression {
		$$ = $1 | $3;
	}
|	expression '^' expression {
		$$ = $1 ^ $3;
	}
|	expression '&' expression {
		$$ = $1 & $3;
	}
|	expression NOT_EQUAL expression {
		$$ = $1 != $3;
	}
|	expression EQUAL expression {
		$$ = $1 == $3;
	}
|	expression GREATER_OR_EQUAL expression {
		$$ = $1 >= $3;
	}
|	expression LESS_OR_EQUAL expression {
		$$ = $1 <= $3;
	}
|	expression '>' expression {
		$$ = $1 > $3;
	}
|	expression '<' expression {
		$$ = $1 < $3;
	}
|	expression RIGHT_SHIFT expression {
		$$ = $1 >> $3;
	}
|	expression LEFT_SHIFT expression {
		$$ = $1 << $3;
	}
|	expression '-' expression {
		$$ = $1 - $3;
	}
|	expression '+' expression {
		$$ = $1 + $3;
	}
|	expression '%' expression {
		if ($3 == 0) {
			yyerror (& @@1, parser,
				 "zero modulus in preprocessor directive");
		} else {
			$$ = $1 % $3;
		}
	}
|	expression '/' expression {
		if ($3 == 0) {
			yyerror (& @@1, parser,
				 "division by 0 in preprocessor directive");
		} else {
			$$ = $1 / $3;
		}
	}
|	expression '*' expression {
		$$ = $1 * $3;
	}
|	'!' expression %prec UNARY {
		$$ = ! $2;
	}
|	'~' expression %prec UNARY {
		$$ = ~ $2;
	}
|	'-' expression %prec UNARY {
		$$ = - $2;
	}
|	'+' expression %prec UNARY {
		$$ = + $2;
	}
|	'(' expression ')' {
		$$ = $2;
	}
;

identifier_list:
	IDENTIFIER {
		$$ = _string_list_create (parser);
		_string_list_append_item ($$, $1);
		ralloc_steal ($$, $1);
	}
|	identifier_list ',' IDENTIFIER {
		$$ = $1;	
		_string_list_append_item ($$, $3);
		ralloc_steal ($$, $3);
	}
;

text_line:
	NEWLINE { $$ = NULL; }
|	pp_tokens NEWLINE
;

non_directive:
	pp_tokens NEWLINE {
		yyerror (& @@1, parser, "Invalid tokens after #");
	}
;

replacement_list:
	/* empty */ { $$ = NULL; }
|	pp_tokens
;

junk:
	/* empty */
|	pp_tokens {
		glcpp_warning(&@@1, parser, "extra tokens at end of directive");
	}
;

conditional_token:
	/* Handle "defined" operator */
	DEFINED IDENTIFIER {
		int v = hash_table_find (parser->defines, $2) ? 1 : 0;
		$$ = _token_create_ival (parser, INTEGER, v);
	}
|	DEFINED '(' IDENTIFIER ')' {
		int v = hash_table_find (parser->defines, $3) ? 1 : 0;
		$$ = _token_create_ival (parser, INTEGER, v);
	}
|	preprocessing_token
;

conditional_tokens:
	/* Exactly the same as pp_tokens, but using conditional_token */
	conditional_token {
		$$ = _token_list_create (parser);
		_token_list_append ($$, $1);
	}
|	conditional_tokens conditional_token {
		$$ = $1;
		_token_list_append ($$, $2);
	}
;

pp_tokens:
	preprocessing_token {
		parser->space_tokens = 1;
		$$ = _token_list_create (parser);
		_token_list_append ($$, $1);
	}
|	pp_tokens preprocessing_token {
		$$ = $1;
		_token_list_append ($$, $2);
	}
;

preprocessing_token:
	IDENTIFIER {
		$$ = _token_create_str (parser, IDENTIFIER, $1);
		$$->location = yylloc;
	}
|	INTEGER_STRING {
		$$ = _token_create_str (parser, INTEGER_STRING, $1);
		$$->location = yylloc;
	}
|	operator {
		$$ = _token_create_ival (parser, $1, $1);
		$$->location = yylloc;
	}
|	OTHER {
		$$ = _token_create_str (parser, OTHER, $1);
		$$->location = yylloc;
	}
|	SPACE {
		$$ = _token_create_ival (parser, SPACE, SPACE);
		$$->location = yylloc;
	}
;

operator:
	'['			{ $$ = '['; }
|	']'			{ $$ = ']'; }
|	'('			{ $$ = '('; }
|	')'			{ $$ = ')'; }
|	'{'			{ $$ = '{'; }
|	'}'			{ $$ = '}'; }
|	'.'			{ $$ = '.'; }
|	'&'			{ $$ = '&'; }
|	'*'			{ $$ = '*'; }
|	'+'			{ $$ = '+'; }
|	'-'			{ $$ = '-'; }
|	'~'			{ $$ = '~'; }
|	'!'			{ $$ = '!'; }
|	'/'			{ $$ = '/'; }
|	'%'			{ $$ = '%'; }
|	LEFT_SHIFT		{ $$ = LEFT_SHIFT; }
|	RIGHT_SHIFT		{ $$ = RIGHT_SHIFT; }
|	'<'			{ $$ = '<'; }
|	'>'			{ $$ = '>'; }
|	LESS_OR_EQUAL		{ $$ = LESS_OR_EQUAL; }
|	GREATER_OR_EQUAL	{ $$ = GREATER_OR_EQUAL; }
|	EQUAL			{ $$ = EQUAL; }
|	NOT_EQUAL		{ $$ = NOT_EQUAL; }
|	'^'			{ $$ = '^'; }
|	'|'			{ $$ = '|'; }
|	AND			{ $$ = AND; }
|	OR			{ $$ = OR; }
|	';'			{ $$ = ';'; }
|	','			{ $$ = ','; }
|	'='			{ $$ = '='; }
|	PASTE			{ $$ = PASTE; }
;

%%

string_list_t *
_string_list_create (void *ctx)
{
	string_list_t *list;

	list = ralloc (ctx, string_list_t);
	list->head = NULL;
	list->tail = NULL;

	return list;
}

void
_string_list_append_item (string_list_t *list, const char *str)
{
	string_node_t *node;

	node = ralloc (list, string_node_t);
	node->str = ralloc_strdup (node, str);

	node->next = NULL;

	if (list->head == NULL) {
		list->head = node;
	} else {
		list->tail->next = node;
	}

	list->tail = node;
}

int
_string_list_contains (string_list_t *list, const char *member, int *index)
{
	string_node_t *node;
	int i;

	if (list == NULL)
		return 0;

	for (i = 0, node = list->head; node; i++, node = node->next) {
		if (strcmp (node->str, member) == 0) {
			if (index)
				*index = i;
			return 1;
		}
	}

	return 0;
}

int
_string_list_length (string_list_t *list)
{
	int length = 0;
	string_node_t *node;

	if (list == NULL)
		return 0;

	for (node = list->head; node; node = node->next)
		length++;

	return length;
}

int
_string_list_equal (string_list_t *a, string_list_t *b)
{
	string_node_t *node_a, *node_b;

	if (a == NULL && b == NULL)
		return 1;

	if (a == NULL || b == NULL)
		return 0;

	for (node_a = a->head, node_b = b->head;
	     node_a && node_b;
	     node_a = node_a->next, node_b = node_b->next)
	{
		if (strcmp (node_a->str, node_b->str))
			return 0;
	}

	/* Catch the case of lists being different lengths, (which
	 * would cause the loop above to terminate after the shorter
	 * list). */
	return node_a == node_b;
}

argument_list_t *
_argument_list_create (void *ctx)
{
	argument_list_t *list;

	list = ralloc (ctx, argument_list_t);
	list->head = NULL;
	list->tail = NULL;

	return list;
}

void
_argument_list_append (argument_list_t *list, token_list_t *argument)
{
	argument_node_t *node;

	node = ralloc (list, argument_node_t);
	node->argument = argument;

	node->next = NULL;

	if (list->head == NULL) {
		list->head = node;
	} else {
		list->tail->next = node;
	}

	list->tail = node;
}

int
_argument_list_length (argument_list_t *list)
{
	int length = 0;
	argument_node_t *node;

	if (list == NULL)
		return 0;

	for (node = list->head; node; node = node->next)
		length++;

	return length;
}

token_list_t *
_argument_list_member_at (argument_list_t *list, int index)
{
	argument_node_t *node;
	int i;

	if (list == NULL)
		return NULL;

	node = list->head;
	for (i = 0; i < index; i++) {
		node = node->next;
		if (node == NULL)
			break;
	}

	if (node)
		return node->argument;

	return NULL;
}

/* Note: This function ralloc_steal()s the str pointer. */
token_t *
_token_create_str (void *ctx, int type, char *str)
{
	token_t *token;

	token = ralloc (ctx, token_t);
	token->type = type;
	token->value.str = str;

	ralloc_steal (token, str);

	return token;
}

token_t *
_token_create_ival (void *ctx, int type, int ival)
{
	token_t *token;

	token = ralloc (ctx, token_t);
	token->type = type;
	token->value.ival = ival;

	return token;
}

token_list_t *
_token_list_create (void *ctx)
{
	token_list_t *list;

	list = ralloc (ctx, token_list_t);
	list->head = NULL;
	list->tail = NULL;
	list->non_space_tail = NULL;

	return list;
}

void
_token_list_append (token_list_t *list, token_t *token)
{
	token_node_t *node;

	node = ralloc (list, token_node_t);
	node->token = token;
	node->next = NULL;

	if (list->head == NULL) {
		list->head = node;
	} else {
		list->tail->next = node;
	}

	list->tail = node;
	if (token->type != SPACE)
		list->non_space_tail = node;
}

void
_token_list_append_list (token_list_t *list, token_list_t *tail)
{
	if (tail == NULL || tail->head == NULL)
		return;

	if (list->head == NULL) {
		list->head = tail->head;
	} else {
		list->tail->next = tail->head;
	}

	list->tail = tail->tail;
	list->non_space_tail = tail->non_space_tail;
}

static token_list_t *
_token_list_copy (void *ctx, token_list_t *other)
{
	token_list_t *copy;
	token_node_t *node;

	if (other == NULL)
		return NULL;

	copy = _token_list_create (ctx);
	for (node = other->head; node; node = node->next) {
		token_t *new_token = ralloc (copy, token_t);
		*new_token = *node->token;
		_token_list_append (copy, new_token);
	}

	return copy;
}

static void
_token_list_trim_trailing_space (token_list_t *list)
{
	token_node_t *tail, *next;

	if (list->non_space_tail) {
		tail = list->non_space_tail->next;
		list->non_space_tail->next = NULL;
		list->tail = list->non_space_tail;

		while (tail) {
			next = tail->next;
			ralloc_free (tail);
			tail = next;
		}
	}
}

static int
_token_list_is_empty_ignoring_space (token_list_t *l)
{
	token_node_t *n;

	if (l == NULL)
		return 1;

	n = l->head;
	while (n != NULL && n->token->type == SPACE)
		n = n->next;

	return n == NULL;
}

int
_token_list_equal_ignoring_space (token_list_t *a, token_list_t *b)
{
	token_node_t *node_a, *node_b;

	if (a == NULL || b == NULL) {
		int a_empty = _token_list_is_empty_ignoring_space(a);
		int b_empty = _token_list_is_empty_ignoring_space(b);
		return a_empty == b_empty;
	}

	node_a = a->head;
	node_b = b->head;

	while (1)
	{
		if (node_a == NULL && node_b == NULL)
			break;

		if (node_a == NULL || node_b == NULL)
			return 0;

		if (node_a->token->type == SPACE) {
			node_a = node_a->next;
			continue;
		}

		if (node_b->token->type == SPACE) {
			node_b = node_b->next;
			continue;
		}

		if (node_a->token->type != node_b->token->type)
			return 0;

		switch (node_a->token->type) {
		case INTEGER:
			if (node_a->token->value.ival != 
			    node_b->token->value.ival)
			{
				return 0;
			}
			break;
		case IDENTIFIER:
		case INTEGER_STRING:
		case OTHER:
			if (strcmp (node_a->token->value.str,
				    node_b->token->value.str))
			{
				return 0;
			}
			break;
		}

		node_a = node_a->next;
		node_b = node_b->next;
	}

	return 1;
}

static void
_token_print (char **out, size_t *len, token_t *token)
{
	if (token->type < 256) {
		ralloc_asprintf_rewrite_tail (out, len, "%c", token->type);
		return;
	}

	switch (token->type) {
	case INTEGER:
		ralloc_asprintf_rewrite_tail (out, len, "%" PRIiMAX, token->value.ival);
		break;
	case IDENTIFIER:
	case INTEGER_STRING:
	case OTHER:
		ralloc_asprintf_rewrite_tail (out, len, "%s", token->value.str);
		break;
	case SPACE:
		ralloc_asprintf_rewrite_tail (out, len, " ");
		break;
	case LEFT_SHIFT:
		ralloc_asprintf_rewrite_tail (out, len, "<<");
		break;
	case RIGHT_SHIFT:
		ralloc_asprintf_rewrite_tail (out, len, ">>");
		break;
	case LESS_OR_EQUAL:
		ralloc_asprintf_rewrite_tail (out, len, "<=");
		break;
	case GREATER_OR_EQUAL:
		ralloc_asprintf_rewrite_tail (out, len, ">=");
		break;
	case EQUAL:
		ralloc_asprintf_rewrite_tail (out, len, "==");
		break;
	case NOT_EQUAL:
		ralloc_asprintf_rewrite_tail (out, len, "!=");
		break;
	case AND:
		ralloc_asprintf_rewrite_tail (out, len, "&&");
		break;
	case OR:
		ralloc_asprintf_rewrite_tail (out, len, "||");
		break;
	case PASTE:
		ralloc_asprintf_rewrite_tail (out, len, "##");
		break;
	case COMMA_FINAL:
		ralloc_asprintf_rewrite_tail (out, len, ",");
		break;
	case PLACEHOLDER:
		/* Nothing to print. */
		break;
	default:
		assert(!"Error: Don't know how to print token.");
		break;
	}
}

/* Return a new token (ralloc()ed off of 'token') formed by pasting
 * 'token' and 'other'. Note that this function may return 'token' or
 * 'other' directly rather than allocating anything new.
 *
 * Caution: Only very cursory error-checking is performed to see if
 * the final result is a valid single token. */
static token_t *
_token_paste (glcpp_parser_t *parser, token_t *token, token_t *other)
{
	token_t *combined = NULL;

	/* Pasting a placeholder onto anything makes no change. */
	if (other->type == PLACEHOLDER)
		return token;

	/* When 'token' is a placeholder, just return 'other'. */
	if (token->type == PLACEHOLDER)
		return other;

	/* A very few single-character punctuators can be combined
	 * with another to form a multi-character punctuator. */
	switch (token->type) {
	case '<':
		if (other->type == '<')
			combined = _token_create_ival (token, LEFT_SHIFT, LEFT_SHIFT);
		else if (other->type == '=')
			combined = _token_create_ival (token, LESS_OR_EQUAL, LESS_OR_EQUAL);
		break;
	case '>':
		if (other->type == '>')
			combined = _token_create_ival (token, RIGHT_SHIFT, RIGHT_SHIFT);
		else if (other->type == '=')
			combined = _token_create_ival (token, GREATER_OR_EQUAL, GREATER_OR_EQUAL);
		break;
	case '=':
		if (other->type == '=')
			combined = _token_create_ival (token, EQUAL, EQUAL);
		break;
	case '!':
		if (other->type == '=')
			combined = _token_create_ival (token, NOT_EQUAL, NOT_EQUAL);
		break;
	case '&':
		if (other->type == '&')
			combined = _token_create_ival (token, AND, AND);
		break;
	case '|':
		if (other->type == '|')
			combined = _token_create_ival (token, OR, OR);
		break;
	}

	if (combined != NULL) {
		/* Inherit the location from the first token */
		combined->location = token->location;
		return combined;
	}

	/* Two string-valued (or integer) tokens can usually just be
	 * mashed together. (We also handle a string followed by an
	 * integer here as well.)
	 *
	 * There are some exceptions here. Notably, if the first token
	 * is an integer (or a string representing an integer), then
	 * the second token must also be an integer or must be a
	 * string representing an integer that begins with a digit.
	 */
	if ((token->type == IDENTIFIER || token->type == OTHER || token->type == INTEGER_STRING || token->type == INTEGER) &&
	    (other->type == IDENTIFIER || other->type == OTHER || other->type == INTEGER_STRING || other->type == INTEGER))
	{
		char *str;
		int combined_type;

		/* Check that pasting onto an integer doesn't create a
		 * non-integer, (that is, only digits can be
		 * pasted. */
		if (token->type == INTEGER_STRING || token->type == INTEGER)
		{
			switch (other->type) {
			case INTEGER_STRING:
				if (other->value.str[0] < '0' ||
				    other->value.str[0] > '9')
					goto FAIL;
				break;
			case INTEGER:
				if (other->value.ival < 0)
					goto FAIL;
				break;
			default:
				goto FAIL;
			}
		}

		if (token->type == INTEGER)
			str = ralloc_asprintf (token, "%" PRIiMAX,
					       token->value.ival);
		else
			str = ralloc_strdup (token, token->value.str);
					       

		if (other->type == INTEGER)
			ralloc_asprintf_append (&str, "%" PRIiMAX,
						other->value.ival);
		else
			ralloc_strcat (&str, other->value.str);

		/* New token is same type as original token, unless we
		 * started with an integer, in which case we will be
		 * creating an integer-string. */
		combined_type = token->type;
		if (combined_type == INTEGER)
			combined_type = INTEGER_STRING;

		combined = _token_create_str (token, combined_type, str);
		combined->location = token->location;
		return combined;
	}

    FAIL:
	glcpp_error (&token->location, parser, "");
	ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "Pasting \"");
	_token_print (&parser->info_log, &parser->info_log_length, token);
	ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "\" and \"");
	_token_print (&parser->info_log, &parser->info_log_length, other);
	ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "\" does not give a valid preprocessing token.\n");

	return token;
}

static void
_token_list_print (glcpp_parser_t *parser, token_list_t *list)
{
	token_node_t *node;

	if (list == NULL)
		return;

	for (node = list->head; node; node = node->next)
		_token_print (&parser->output, &parser->output_length, node->token);
}

void
yyerror (YYLTYPE *locp, glcpp_parser_t *parser, const char *error)
{
	glcpp_error(locp, parser, "%s", error);
}

static void add_builtin_define(glcpp_parser_t *parser,
			       const char *name, int value)
{
   token_t *tok;
   token_list_t *list;

   tok = _token_create_ival (parser, INTEGER, value);

   list = _token_list_create(parser);
   _token_list_append(list, tok);
   _define_object_macro(parser, NULL, name, list);
}

glcpp_parser_t *
glcpp_parser_create (const struct gl_extensions *extensions, gl_api api)
{
	glcpp_parser_t *parser;

	parser = ralloc (NULL, glcpp_parser_t);

	glcpp_lex_init_extra (parser, &parser->scanner);
	parser->defines = hash_table_ctor (32, hash_table_string_hash,
					   hash_table_string_compare);
	parser->active = NULL;
	parser->lexing_if = 0;
	parser->space_tokens = 1;
	parser->newline_as_space = 0;
	parser->in_control_line = 0;
	parser->paren_count = 0;
        parser->commented_newlines = 0;

	parser->skip_stack = NULL;

	parser->lex_from_list = NULL;
	parser->lex_from_node = NULL;

	parser->output = ralloc_strdup(parser, "");
	parser->output_length = 0;
	parser->info_log = ralloc_strdup(parser, "");
	parser->info_log_length = 0;
	parser->error = 0;

        parser->extensions = extensions;
        parser->api = api;
        parser->version_resolved = false;

	parser->has_new_line_number = 0;
	parser->new_line_number = 1;
	parser->has_new_source_number = 0;
	parser->new_source_number = 0;

	return parser;
}

void
glcpp_parser_destroy (glcpp_parser_t *parser)
{
	glcpp_lex_destroy (parser->scanner);
	hash_table_dtor (parser->defines);
	ralloc_free (parser);
}

typedef enum function_status
{
	FUNCTION_STATUS_SUCCESS,
	FUNCTION_NOT_A_FUNCTION,
	FUNCTION_UNBALANCED_PARENTHESES
} function_status_t;

/* Find a set of function-like macro arguments by looking for a
 * balanced set of parentheses.
 *
 * When called, 'node' should be the opening-parenthesis token, (or
 * perhaps preceeding SPACE tokens). Upon successful return *last will
 * be the last consumed node, (corresponding to the closing right
 * parenthesis).
 *
 * Return values:
 *
 *   FUNCTION_STATUS_SUCCESS:
 *
 *	Successfully parsed a set of function arguments.	
 *
 *   FUNCTION_NOT_A_FUNCTION:
 *
 *	Macro name not followed by a '('. This is not an error, but
 *	simply that the macro name should be treated as a non-macro.
 *
 *   FUNCTION_UNBALANCED_PARENTHESES
 *
 *	Macro name is not followed by a balanced set of parentheses.
 */
static function_status_t
_arguments_parse (argument_list_t *arguments,
		  token_node_t *node,
		  token_node_t **last)
{
	token_list_t *argument;
	int paren_count;

	node = node->next;

	/* Ignore whitespace before first parenthesis. */
	while (node && node->token->type == SPACE)
		node = node->next;

	if (node == NULL || node->token->type != '(')
		return FUNCTION_NOT_A_FUNCTION;

	node = node->next;

	argument = _token_list_create (arguments);
	_argument_list_append (arguments, argument);

	for (paren_count = 1; node; node = node->next) {
		if (node->token->type == '(')
		{
			paren_count++;
		}
		else if (node->token->type == ')')
		{
			paren_count--;
			if (paren_count == 0)
				break;
		}

		if (node->token->type == ',' &&
			 paren_count == 1)
		{
			_token_list_trim_trailing_space (argument);
			argument = _token_list_create (arguments);
			_argument_list_append (arguments, argument);
		}
		else {
			if (argument->head == NULL) {
				/* Don't treat initial whitespace as
				 * part of the arguement. */
				if (node->token->type == SPACE)
					continue;
			}
			_token_list_append (argument, node->token);
		}
	}

	if (paren_count)
		return FUNCTION_UNBALANCED_PARENTHESES;

	*last = node;

	return FUNCTION_STATUS_SUCCESS;
}

static token_list_t *
_token_list_create_with_one_ival (void *ctx, int type, int ival)
{
	token_list_t *list;
	token_t *node;

	list = _token_list_create (ctx);
	node = _token_create_ival (list, type, ival);
	_token_list_append (list, node);

	return list;
}

static token_list_t *
_token_list_create_with_one_space (void *ctx)
{
	return _token_list_create_with_one_ival (ctx, SPACE, SPACE);
}

static token_list_t *
_token_list_create_with_one_integer (void *ctx, int ival)
{
	return _token_list_create_with_one_ival (ctx, INTEGER, ival);
}

/* Perform macro expansion on 'list', placing the resulting tokens
 * into a new list which is initialized with a first token of type
 * 'head_token_type'. Then begin lexing from the resulting list,
 * (return to the current lexing source when this list is exhausted).
 */
static void
_glcpp_parser_expand_and_lex_from (glcpp_parser_t *parser,
				   int head_token_type,
				   token_list_t *list)
{
	token_list_t *expanded;
	token_t *token;

	expanded = _token_list_create (parser);
	token = _token_create_ival (parser, head_token_type, head_token_type);
	_token_list_append (expanded, token);
	_glcpp_parser_expand_token_list (parser, list);
	_token_list_append_list (expanded, list);
	glcpp_parser_lex_from (parser, expanded);
}

static void
_glcpp_parser_apply_pastes (glcpp_parser_t *parser, token_list_t *list)
{
	token_node_t *node;

	node = list->head;
	while (node)
	{
		token_node_t *next_non_space;

		/* Look ahead for a PASTE token, skipping space. */
		next_non_space = node->next;
		while (next_non_space && next_non_space->token->type == SPACE)
			next_non_space = next_non_space->next;

		if (next_non_space == NULL)
			break;

		if (next_non_space->token->type != PASTE) {
			node = next_non_space;
			continue;
		}

		/* Now find the next non-space token after the PASTE. */
		next_non_space = next_non_space->next;
		while (next_non_space && next_non_space->token->type == SPACE)
			next_non_space = next_non_space->next;

		if (next_non_space == NULL) {
			yyerror (&node->token->location, parser, "'##' cannot appear at either end of a macro expansion\n");
			return;
		}

		node->token = _token_paste (parser, node->token, next_non_space->token);
		node->next = next_non_space->next;
		if (next_non_space == list->tail)
			list->tail = node;
	}

	list->non_space_tail = list->tail;
}

/* This is a helper function that's essentially part of the
 * implementation of _glcpp_parser_expand_node. It shouldn't be called
 * except for by that function.
 *
 * Returns NULL if node is a simple token with no expansion, (that is,
 * although 'node' corresponds to an identifier defined as a
 * function-like macro, it is not followed with a parenthesized
 * argument list).
 *
 * Compute the complete expansion of node (which is a function-like
 * macro) and subsequent nodes which are arguments.
 *
 * Returns the token list that results from the expansion and sets
 * *last to the last node in the list that was consumed by the
 * expansion. Specifically, *last will be set as follows: as the
 * token of the closing right parenthesis.
 */
static token_list_t *
_glcpp_parser_expand_function (glcpp_parser_t *parser,
			       token_node_t *node,
			       token_node_t **last)
			       
{
	macro_t *macro;
	const char *identifier;
	argument_list_t *arguments;
	function_status_t status;
	token_list_t *substituted;
	int parameter_index;

	identifier = node->token->value.str;

	macro = hash_table_find (parser->defines, identifier);

	assert (macro->is_function);

	arguments = _argument_list_create (parser);
	status = _arguments_parse (arguments, node, last);

	switch (status) {
	case FUNCTION_STATUS_SUCCESS:
		break;
	case FUNCTION_NOT_A_FUNCTION:
		return NULL;
	case FUNCTION_UNBALANCED_PARENTHESES:
		glcpp_error (&node->token->location, parser, "Macro %s call has unbalanced parentheses\n", identifier);
		return NULL;
	}

	/* Replace a macro defined as empty with a SPACE token. */
	if (macro->replacements == NULL) {
		ralloc_free (arguments);
		return _token_list_create_with_one_space (parser);
	}

	if (! ((_argument_list_length (arguments) == 
		_string_list_length (macro->parameters)) ||
	       (_string_list_length (macro->parameters) == 0 &&
		_argument_list_length (arguments) == 1 &&
		arguments->head->argument->head == NULL)))
	{
		glcpp_error (&node->token->location, parser,
			      "Error: macro %s invoked with %d arguments (expected %d)\n",
			      identifier,
			      _argument_list_length (arguments),
			      _string_list_length (macro->parameters));
		return NULL;
	}

	/* Perform argument substitution on the replacement list. */
	substituted = _token_list_create (arguments);

	for (node = macro->replacements->head; node; node = node->next)
	{
		if (node->token->type == IDENTIFIER &&
		    _string_list_contains (macro->parameters,
					   node->token->value.str,
					   &parameter_index))
		{
			token_list_t *argument;
			argument = _argument_list_member_at (arguments,
							     parameter_index);
			/* Before substituting, we expand the argument
			 * tokens, or append a placeholder token for
			 * an empty argument. */
			if (argument->head) {
				token_list_t *expanded_argument;
				expanded_argument = _token_list_copy (parser,
								      argument);
				_glcpp_parser_expand_token_list (parser,
								 expanded_argument);
				_token_list_append_list (substituted,
							 expanded_argument);
			} else {
				token_t *new_token;

				new_token = _token_create_ival (substituted,
								PLACEHOLDER,
								PLACEHOLDER);
				_token_list_append (substituted, new_token);
			}
		} else {
			_token_list_append (substituted, node->token);
		}
	}

	/* After argument substitution, and before further expansion
	 * below, implement token pasting. */

	_token_list_trim_trailing_space (substituted);

	_glcpp_parser_apply_pastes (parser, substituted);

	return substituted;
}

/* Compute the complete expansion of node, (and subsequent nodes after
 * 'node' in the case that 'node' is a function-like macro and
 * subsequent nodes are arguments).
 *
 * Returns NULL if node is a simple token with no expansion.
 *
 * Otherwise, returns the token list that results from the expansion
 * and sets *last to the last node in the list that was consumed by
 * the expansion. Specifically, *last will be set as follows:
 *
 *	As 'node' in the case of object-like macro expansion.
 *
 *	As the token of the closing right parenthesis in the case of
 *	function-like macro expansion.
 */
static token_list_t *
_glcpp_parser_expand_node (glcpp_parser_t *parser,
			   token_node_t *node,
			   token_node_t **last)
{
	token_t *token = node->token;
	const char *identifier;
	macro_t *macro;

	/* We only expand identifiers */
	if (token->type != IDENTIFIER) {
		/* We change any COMMA into a COMMA_FINAL to prevent
		 * it being mistaken for an argument separator
		 * later. */
		if (token->type == ',') {
			token->type = COMMA_FINAL;
			token->value.ival = COMMA_FINAL;
		}

		return NULL;
	}

	*last = node;
	identifier = token->value.str;

	/* Special handling for __LINE__ and __FILE__, (not through
	 * the hash table). */
	if (strcmp(identifier, "__LINE__") == 0)
		return _token_list_create_with_one_integer (parser, node->token->location.first_line);

	if (strcmp(identifier, "__FILE__") == 0)
		return _token_list_create_with_one_integer (parser, node->token->location.source);

	/* Look up this identifier in the hash table. */
	macro = hash_table_find (parser->defines, identifier);

	/* Not a macro, so no expansion needed. */
	if (macro == NULL)
		return NULL;

	/* Finally, don't expand this macro if we're already actively
	 * expanding it, (to avoid infinite recursion). */
	if (_parser_active_list_contains (parser, identifier)) {
		/* We change the token type here from IDENTIFIER to
		 * OTHER to prevent any future expansion of this
		 * unexpanded token. */
		char *str;
		token_list_t *expansion;
		token_t *final;

		str = ralloc_strdup (parser, token->value.str);
		final = _token_create_str (parser, OTHER, str);
		expansion = _token_list_create (parser);
		_token_list_append (expansion, final);
		return expansion;
	}

	if (! macro->is_function)
	{
		token_list_t *replacement;

		/* Replace a macro defined as empty with a SPACE token. */
		if (macro->replacements == NULL)
			return _token_list_create_with_one_space (parser);

		replacement = _token_list_copy (parser, macro->replacements);
		_glcpp_parser_apply_pastes (parser, replacement);
		return replacement;
	}

	return _glcpp_parser_expand_function (parser, node, last);
}

/* Push a new identifier onto the parser's active list.
 *
 * Here, 'marker' is the token node that appears in the list after the
 * expansion of 'identifier'. That is, when the list iterator begins
 * examining 'marker', then it is time to pop this node from the
 * active stack.
 */
static void
_parser_active_list_push (glcpp_parser_t *parser,
			  const char *identifier,
			  token_node_t *marker)
{
	active_list_t *node;

	node = ralloc (parser->active, active_list_t);
	node->identifier = ralloc_strdup (node, identifier);
	node->marker = marker;
	node->next = parser->active;

	parser->active = node;
}

static void
_parser_active_list_pop (glcpp_parser_t *parser)
{
	active_list_t *node = parser->active;

	if (node == NULL) {
		parser->active = NULL;
		return;
	}

	node = parser->active->next;
	ralloc_free (parser->active);

	parser->active = node;
}

static int
_parser_active_list_contains (glcpp_parser_t *parser, const char *identifier)
{
	active_list_t *node;

	if (parser->active == NULL)
		return 0;

	for (node = parser->active; node; node = node->next)
		if (strcmp (node->identifier, identifier) == 0)
			return 1;

	return 0;
}

/* Walk over the token list replacing nodes with their expansion.
 * Whenever nodes are expanded the walking will walk over the new
 * nodes, continuing to expand as necessary. The results are placed in
 * 'list' itself;
 */
static void
_glcpp_parser_expand_token_list (glcpp_parser_t *parser,
				 token_list_t *list)
{
	token_node_t *node_prev;
	token_node_t *node, *last = NULL;
	token_list_t *expansion;
	active_list_t *active_initial = parser->active;

	if (list == NULL)
		return;

	_token_list_trim_trailing_space (list);

	node_prev = NULL;
	node = list->head;

	while (node) {

		while (parser->active && parser->active->marker == node)
			_parser_active_list_pop (parser);

		expansion = _glcpp_parser_expand_node (parser, node, &last);
		if (expansion) {
			token_node_t *n;

			for (n = node; n != last->next; n = n->next)
				while (parser->active &&
				       parser->active->marker == n)
				{
					_parser_active_list_pop (parser);
				}

			_parser_active_list_push (parser,
						  node->token->value.str,
						  last->next);
			
			/* Splice expansion into list, supporting a
			 * simple deletion if the expansion is
			 * empty. */
			if (expansion->head) {
				if (node_prev)
					node_prev->next = expansion->head;
				else
					list->head = expansion->head;
				expansion->tail->next = last->next;
				if (last == list->tail)
					list->tail = expansion->tail;
			} else {
				if (node_prev)
					node_prev->next = last->next;
				else
					list->head = last->next;
				if (last == list->tail)
					list->tail = NULL;
			}
		} else {
			node_prev = node;
		}
		node = node_prev ? node_prev->next : list->head;
	}

	/* Remove any lingering effects of this invocation on the
	 * active list. That is, pop until the list looks like it did
	 * at the beginning of this function. */
	while (parser->active && parser->active != active_initial)
		_parser_active_list_pop (parser);

	list->non_space_tail = list->tail;
}

void
_glcpp_parser_print_expanded_token_list (glcpp_parser_t *parser,
					 token_list_t *list)
{
	if (list == NULL)
		return;

	_glcpp_parser_expand_token_list (parser, list);

	_token_list_trim_trailing_space (list);

	_token_list_print (parser, list);
}

static void
_check_for_reserved_macro_name (glcpp_parser_t *parser, YYLTYPE *loc,
				const char *identifier)
{
	/* Section 3.3 (Preprocessor) of the GLSL 1.30 spec (and later) and
	 * the GLSL ES spec (all versions) say:
	 *
	 *     "All macro names containing two consecutive underscores ( __ )
	 *     are reserved for future use as predefined macro names. All
	 *     macro names prefixed with "GL_" ("GL" followed by a single
	 *     underscore) are also reserved."
	 *
	 * The intention is that names containing __ are reserved for internal
	 * use by the implementation, and names prefixed with GL_ are reserved
	 * for use by Khronos.  Since every extension adds a name prefixed
	 * with GL_ (i.e., the name of the extension), that should be an
	 * error.  Names simply containing __ are dangerous to use, but should
	 * be allowed.
	 *
	 * A future version of the GLSL specification will clarify this.
	 */
	if (strstr(identifier, "__")) {
		glcpp_warning(loc, parser,
			      "Macro names containing \"__\" are reserved "
			      "for use by the implementation.\n");
	}
	if (strncmp(identifier, "GL_", 3) == 0) {
		glcpp_error (loc, parser, "Macro names starting with \"GL_\" are reserved.\n");
	}
}

static int
_macro_equal (macro_t *a, macro_t *b)
{
	if (a->is_function != b->is_function)
		return 0;

	if (a->is_function) {
		if (! _string_list_equal (a->parameters, b->parameters))
			return 0;
	}

	return _token_list_equal_ignoring_space (a->replacements,
						 b->replacements);
}

void
_define_object_macro (glcpp_parser_t *parser,
		      YYLTYPE *loc,
		      const char *identifier,
		      token_list_t *replacements)
{
	macro_t *macro, *previous;

	if (loc != NULL)
		_check_for_reserved_macro_name(parser, loc, identifier);

	macro = ralloc (parser, macro_t);

	macro->is_function = 0;
	macro->parameters = NULL;
	macro->identifier = ralloc_strdup (macro, identifier);
	macro->replacements = replacements;
	ralloc_steal (macro, replacements);

	previous = hash_table_find (parser->defines, identifier);
	if (previous) {
		if (_macro_equal (macro, previous)) {
			ralloc_free (macro);
			return;
		}
		glcpp_error (loc, parser, "Redefinition of macro %s\n",
			     identifier);
	}

	hash_table_insert (parser->defines, macro, identifier);
}

void
_define_function_macro (glcpp_parser_t *parser,
			YYLTYPE *loc,
			const char *identifier,
			string_list_t *parameters,
			token_list_t *replacements)
{
	macro_t *macro, *previous;

	_check_for_reserved_macro_name(parser, loc, identifier);

	macro = ralloc (parser, macro_t);
	ralloc_steal (macro, parameters);
	ralloc_steal (macro, replacements);

	macro->is_function = 1;
	macro->parameters = parameters;
	macro->identifier = ralloc_strdup (macro, identifier);
	macro->replacements = replacements;
	previous = hash_table_find (parser->defines, identifier);
	if (previous) {
		if (_macro_equal (macro, previous)) {
			ralloc_free (macro);
			return;
		}
		glcpp_error (loc, parser, "Redefinition of macro %s\n",
			     identifier);
	}

	hash_table_insert (parser->defines, macro, identifier);
}

static int
glcpp_parser_lex (YYSTYPE *yylval, YYLTYPE *yylloc, glcpp_parser_t *parser)
{
	token_node_t *node;
	int ret;

	if (parser->lex_from_list == NULL) {
		ret = glcpp_lex (yylval, yylloc, parser->scanner);

		/* XXX: This ugly block of code exists for the sole
		 * purpose of converting a NEWLINE token into a SPACE
		 * token, but only in the case where we have seen a
		 * function-like macro name, but have not yet seen its
		 * closing parenthesis.
		 *
		 * There's perhaps a more compact way to do this with
		 * mid-rule actions in the grammar.
		 *
		 * I'm definitely not pleased with the complexity of
		 * this code here.
		 */
		if (parser->newline_as_space)
		{
			if (ret == '(') {
				parser->paren_count++;
			} else if (ret == ')') {
				parser->paren_count--;
				if (parser->paren_count == 0)
					parser->newline_as_space = 0;
			} else if (ret == NEWLINE) {
				ret = SPACE;
			} else if (ret != SPACE) {
				if (parser->paren_count == 0)
					parser->newline_as_space = 0;
			}
		}
		else if (parser->in_control_line)
		{
			if (ret == NEWLINE)
				parser->in_control_line = 0;
		}
		else if (ret == HASH_DEFINE ||
			   ret == HASH_UNDEF || ret == HASH_IF ||
			   ret == HASH_IFDEF || ret == HASH_IFNDEF ||
			   ret == HASH_ELIF || ret == HASH_ELSE ||
			   ret == HASH_ENDIF || ret == HASH)
		{
			parser->in_control_line = 1;
		}
		else if (ret == IDENTIFIER)
		{
			macro_t *macro;
			macro = hash_table_find (parser->defines,
						 yylval->str);
			if (macro && macro->is_function) {
				parser->newline_as_space = 1;
				parser->paren_count = 0;
			}
		}

		return ret;
	}

	node = parser->lex_from_node;

	if (node == NULL) {
		ralloc_free (parser->lex_from_list);
		parser->lex_from_list = NULL;
		return NEWLINE;
	}

	*yylval = node->token->value;
	ret = node->token->type;

	parser->lex_from_node = node->next;

	return ret;
}

static void
glcpp_parser_lex_from (glcpp_parser_t *parser, token_list_t *list)
{
	token_node_t *node;

	assert (parser->lex_from_list == NULL);

	/* Copy list, eliminating any space tokens. */
	parser->lex_from_list = _token_list_create (parser);

	for (node = list->head; node; node = node->next) {
		if (node->token->type == SPACE)
			continue;
		_token_list_append (parser->lex_from_list, node->token);
	}

	ralloc_free (list);

	parser->lex_from_node = parser->lex_from_list->head;

	/* It's possible the list consisted of nothing but whitespace. */
	if (parser->lex_from_node == NULL) {
		ralloc_free (parser->lex_from_list);
		parser->lex_from_list = NULL;
	}
}

static void
_glcpp_parser_skip_stack_push_if (glcpp_parser_t *parser, YYLTYPE *loc,
				  int condition)
{
	skip_type_t current = SKIP_NO_SKIP;
	skip_node_t *node;

	if (parser->skip_stack)
		current = parser->skip_stack->type;

	node = ralloc (parser, skip_node_t);
	node->loc = *loc;

	if (current == SKIP_NO_SKIP) {
		if (condition)
			node->type = SKIP_NO_SKIP;
		else
			node->type = SKIP_TO_ELSE;
	} else {
		node->type = SKIP_TO_ENDIF;
	}

	node->has_else = false;
	node->next = parser->skip_stack;
	parser->skip_stack = node;
}

static void
_glcpp_parser_skip_stack_change_if (glcpp_parser_t *parser, YYLTYPE *loc,
				    const char *type, int condition)
{
	if (parser->skip_stack == NULL) {
		glcpp_error (loc, parser, "%s without #if\n", type);
		return;
	}

	if (parser->skip_stack->type == SKIP_TO_ELSE) {
		if (condition)
			parser->skip_stack->type = SKIP_NO_SKIP;
	} else {
		parser->skip_stack->type = SKIP_TO_ENDIF;
	}
}

static void
_glcpp_parser_skip_stack_pop (glcpp_parser_t *parser, YYLTYPE *loc)
{
	skip_node_t *node;

	if (parser->skip_stack == NULL) {
		glcpp_error (loc, parser, "#endif without #if\n");
		return;
	}

	node = parser->skip_stack;
	parser->skip_stack = node->next;
	ralloc_free (node);
}

static void
_glcpp_parser_handle_version_declaration(glcpp_parser_t *parser, intmax_t version,
                                         const char *es_identifier,
                                         bool explicitly_set)
{
	const struct gl_extensions *extensions = parser->extensions;

	if (parser->version_resolved)
		return;

	parser->version_resolved = true;

	add_builtin_define (parser, "__VERSION__", version);

	parser->is_gles = (version == 100) ||
			   (es_identifier &&
			    (strcmp(es_identifier, "es") == 0));

	/* Add pre-defined macros. */
	if (parser->is_gles) {
	   add_builtin_define(parser, "GL_ES", 1);
           add_builtin_define(parser, "GL_EXT_separate_shader_objects", 1);

	   if (extensions != NULL) {
	      if (extensions->OES_EGL_image_external)
	         add_builtin_define(parser, "GL_OES_EGL_image_external", 1);
	   }
	} else {
	   add_builtin_define(parser, "GL_ARB_draw_buffers", 1);
           add_builtin_define(parser, "GL_ARB_separate_shader_objects", 1);
	   add_builtin_define(parser, "GL_ARB_texture_rectangle", 1);
           add_builtin_define(parser, "GL_AMD_shader_trinary_minmax", 1);


	   if (extensions != NULL) {
	      if (extensions->EXT_texture_array)
	         add_builtin_define(parser, "GL_EXT_texture_array", 1);

	      if (extensions->ARB_arrays_of_arrays)
	          add_builtin_define(parser, "GL_ARB_arrays_of_arrays", 1);

	      if (extensions->ARB_fragment_coord_conventions)
	         add_builtin_define(parser, "GL_ARB_fragment_coord_conventions",
				    1);

	      if (extensions->ARB_explicit_attrib_location)
	         add_builtin_define(parser, "GL_ARB_explicit_attrib_location", 1);

	      if (extensions->ARB_shader_texture_lod)
	         add_builtin_define(parser, "GL_ARB_shader_texture_lod", 1);

	      if (extensions->ARB_draw_instanced)
	         add_builtin_define(parser, "GL_ARB_draw_instanced", 1);

	      if (extensions->ARB_conservative_depth) {
	         add_builtin_define(parser, "GL_AMD_conservative_depth", 1);
	         add_builtin_define(parser, "GL_ARB_conservative_depth", 1);
	      }

	      if (extensions->ARB_shader_bit_encoding)
	         add_builtin_define(parser, "GL_ARB_shader_bit_encoding", 1);

	      if (extensions->ARB_uniform_buffer_object)
	         add_builtin_define(parser, "GL_ARB_uniform_buffer_object", 1);

	      if (extensions->ARB_texture_cube_map_array)
	         add_builtin_define(parser, "GL_ARB_texture_cube_map_array", 1);

	      if (extensions->ARB_shading_language_packing)
	         add_builtin_define(parser, "GL_ARB_shading_language_packing", 1);

	      if (extensions->ARB_texture_multisample)
	         add_builtin_define(parser, "GL_ARB_texture_multisample", 1);

	      if (extensions->ARB_texture_query_levels)
	         add_builtin_define(parser, "GL_ARB_texture_query_levels", 1);

	      if (extensions->ARB_texture_query_lod)
	         add_builtin_define(parser, "GL_ARB_texture_query_lod", 1);

	      if (extensions->ARB_gpu_shader5)
	         add_builtin_define(parser, "GL_ARB_gpu_shader5", 1);

	      if (extensions->AMD_vertex_shader_layer)
	         add_builtin_define(parser, "GL_AMD_vertex_shader_layer", 1);

	      if (extensions->ARB_shading_language_420pack)
	         add_builtin_define(parser, "GL_ARB_shading_language_420pack", 1);

	      if (extensions->ARB_sample_shading)
	         add_builtin_define(parser, "GL_ARB_sample_shading", 1);

	      if (extensions->ARB_texture_gather)
	         add_builtin_define(parser, "GL_ARB_texture_gather", 1);

	      if (extensions->ARB_shader_atomic_counters)
	         add_builtin_define(parser, "GL_ARB_shader_atomic_counters", 1);

	      if (extensions->ARB_viewport_array)
	         add_builtin_define(parser, "GL_ARB_viewport_array", 1);

              if (extensions->ARB_compute_shader)
                 add_builtin_define(parser, "GL_ARB_compute_shader", 1);

	      if (extensions->ARB_shader_image_load_store)
	         add_builtin_define(parser, "GL_ARB_shader_image_load_store", 1);
	   }
	}

	if (extensions != NULL) {
	   if (extensions->EXT_shader_integer_mix)
	      add_builtin_define(parser, "GL_EXT_shader_integer_mix", 1);
	}

	if (version >= 150)
		add_builtin_define(parser, "GL_core_profile", 1);

	/* Currently, all ES2/ES3 implementations support highp in the
	 * fragment shader, so we always define this macro in ES2/ES3.
	 * If we ever get a driver that doesn't support highp, we'll
	 * need to add a flag to the gl_context and check that here.
	 */
	if (version >= 130 || parser->is_gles)
		add_builtin_define (parser, "GL_FRAGMENT_PRECISION_HIGH", 1);

	if (explicitly_set) {
	   ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length,
					 "#version %" PRIiMAX "%s%s", version,
					 es_identifier ? " " : "",
					 es_identifier ? es_identifier : "");
	}
}

/* GLSL version if no version is explicitly specified. */
#define IMPLICIT_GLSL_VERSION 110

/* GLSL ES version if no version is explicitly specified. */
#define IMPLICIT_GLSL_ES_VERSION 100

void
glcpp_parser_resolve_implicit_version(glcpp_parser_t *parser)
{
	int language_version = parser->api == API_OPENGLES2 ?
			       IMPLICIT_GLSL_ES_VERSION :
			       IMPLICIT_GLSL_VERSION;

	_glcpp_parser_handle_version_declaration(parser, language_version,
						 NULL, false);
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a59 3
static const char *
_string_list_has_duplicate (string_list_t *list);

a107 5
typedef enum {
	EXPANSION_MODE_IGNORE_DEFINED,
	EXPANSION_MODE_EVALUATE_DEFINED
} expansion_mode_t;

d114 1
a114 2
				   token_list_t *list,
				   expansion_mode_t mode);
d119 1
a119 2
				 token_list_t *list,
				 expansion_mode_t mode);
d167 1
a167 5

	/* We use HASH_TOKEN, DEFINE_TOKEN and VERSION_TOKEN (as opposed to
         * HASH, DEFINE, and VERSION) to avoid conflicts with other symbols,
         * (such as the <HASH> and <DEFINE> start conditions in the lexer). */
%token DEFINED ELIF_EXPANDED HASH_TOKEN DEFINE_TOKEN FUNC_IDENTIFIER OBJ_IDENTIFIER ELIF ELSE ENDIF ERROR_TOKEN IF IFDEF IFNDEF LINE PRAGMA UNDEF VERSION_TOKEN GARBAGE IDENTIFIER IF_EXPANDED INTEGER INTEGER_STRING LINE_EXPANDED NEWLINE OTHER PLACEHOLDER SPACE PLUS_PLUS MINUS_MINUS
d169 2
a170 3
%type <ival> INTEGER operator SPACE integer_constant
%type <expression_value> expression
%type <str> IDENTIFIER FUNC_IDENTIFIER OBJ_IDENTIFIER INTEGER_STRING OTHER ERROR_TOKEN PRAGMA
d172 2
a173 2
%type <token> preprocessing_token
%type <token_list> pp_tokens replacement_list text_line
a185 2
%debug

d194 14
a207 2
	control_line
|	SPACE control_line
d214 1
d219 1
a219 3
		if (parser->is_gles && $2.undefined_macro)
			glcpp_error(& @@1, parser, "undefined macro %s in expression (illegal in GLES)", $2.undefined_macro);
		_glcpp_parser_skip_stack_push_if (parser, & @@1, $2.value);
d222 1
a222 3
		if (parser->is_gles && $2.undefined_macro)
			glcpp_error(& @@1, parser, "undefined macro %s in expression (illegal in GLES)", $2.undefined_macro);
		_glcpp_parser_skip_stack_change_if (parser, & @@1, "elif", $2.value);
d257 1
a257 20
	control_line_success {
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "\n");
	}
|	control_line_error
|	HASH_TOKEN LINE {
		glcpp_parser_resolve_implicit_version(parser);
	} pp_tokens NEWLINE {

		if (parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			_glcpp_parser_expand_and_lex_from (parser,
							   LINE_EXPANDED, $4,
							   EXPANSION_MODE_IGNORE_DEFINED);
		}
	}
;

control_line_success:
	HASH_TOKEN DEFINE_TOKEN {
d260 1
a260 1
|	HASH_TOKEN UNDEF {
d263 1
a263 8
		macro_t *macro;
		if (strcmp("__LINE__", $4) == 0
		    || strcmp("__FILE__", $4) == 0
		    || strcmp("__VERSION__", $4) == 0)
			glcpp_error(& @@1, parser, "Built-in (pre-defined)"
				    " macro names can not be undefined.");

		macro = hash_table_find (parser->defines, $4);
d265 1
a265 1
			hash_table_remove (parser->defines, $4);
d268 1
a268 1
		ralloc_free ($4);
d270 1
a270 1
|	HASH_TOKEN IF {
d272 1
a272 1
	} pp_tokens NEWLINE {
d284 1
a284 2
							   IF_EXPANDED, $4,
							   EXPANSION_MODE_EVALUATE_DEFINED);
d292 1
a292 1
|	HASH_TOKEN IF NEWLINE {
d302 1
a302 1
|	HASH_TOKEN IFDEF {
d305 2
a306 2
		macro_t *macro = hash_table_find (parser->defines, $4);
		ralloc_free ($4);
d309 1
a309 1
|	HASH_TOKEN IFNDEF {
d312 3
a314 3
		macro_t *macro = hash_table_find (parser->defines, $4);
		ralloc_free ($4);
		_glcpp_parser_skip_stack_push_if (parser, & @@3, macro == NULL);
d316 1
a316 1
|	HASH_TOKEN ELIF pp_tokens NEWLINE {
d328 1
a328 2
							   ELIF_EXPANDED, $3,
							   EXPANSION_MODE_EVALUATE_DEFINED);
d341 1
a341 1
|	HASH_TOKEN ELIF NEWLINE {
d361 1
a361 1
|	HASH_TOKEN ELSE { parser->lexing_directive = 1; } NEWLINE {
d373 2
a374 2
	}
|	HASH_TOKEN ENDIF {
d377 1
a377 1
|	HASH_TOKEN VERSION_TOKEN integer_constant NEWLINE {
d381 1
a381 1
		_glcpp_parser_handle_version_declaration(parser, $3, NULL, true);
d383 1
a383 1
|	HASH_TOKEN VERSION_TOKEN integer_constant IDENTIFIER NEWLINE {
d387 1
a387 1
		_glcpp_parser_handle_version_declaration(parser, $3, $4, true);
d389 1
a389 1
|	HASH_TOKEN NEWLINE {
a391 15
|	HASH_TOKEN PRAGMA NEWLINE {
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "#%s", $2);
	}
;

control_line_error:
	HASH_TOKEN ERROR_TOKEN NEWLINE {
		glcpp_error(& @@1, parser, "#%s", $2);
	}
|	HASH_TOKEN DEFINE_TOKEN NEWLINE {
		glcpp_error (& @@1, parser, "#define without macro name");
	}
|	HASH_TOKEN GARBAGE pp_tokens NEWLINE  {
		glcpp_error (& @@1, parser, "Illegal non-directive after #");
	}
d409 1
a409 4
	integer_constant {
		$$.value = $1;
		$$.undefined_macro = NULL;
	}
a410 1
		$$.value = 0;
d412 2
a413 3
			$$.undefined_macro = ralloc_strdup (parser, $1);
		else
			$$.undefined_macro = NULL;
d416 1
a416 9
		$$.value = $1.value || $3.value;

		/* Short-circuit: Only flag undefined from right side
		 * if left side evaluates to false.
		 */
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else if (! $1.value)
			$$.undefined_macro = $3.undefined_macro;
d419 1
a419 9
		$$.value = $1.value && $3.value;

		/* Short-circuit: Only flag undefined from right-side
		 * if left side evaluates to true.
		 */
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else if ($1.value)
			$$.undefined_macro = $3.undefined_macro;
d422 1
a422 5
		$$.value = $1.value | $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d425 1
a425 5
		$$.value = $1.value ^ $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d428 1
a428 5
		$$.value = $1.value & $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d431 1
a431 5
		$$.value = $1.value != $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d434 1
a434 5
		$$.value = $1.value == $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d437 1
a437 5
		$$.value = $1.value >= $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d440 1
a440 5
		$$.value = $1.value <= $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d443 1
a443 5
		$$.value = $1.value > $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d446 1
a446 5
		$$.value = $1.value < $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d449 1
a449 5
		$$.value = $1.value >> $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d452 1
a452 5
		$$.value = $1.value << $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d455 1
a455 5
		$$.value = $1.value - $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d458 1
a458 5
		$$.value = $1.value + $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d461 1
a461 1
		if ($3.value == 0) {
d465 1
a465 1
			$$.value = $1.value % $3.value;
a466 4
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d469 1
a469 1
		if ($3.value == 0) {
d473 1
a473 1
			$$.value = $1.value / $3.value;
a474 4
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d477 1
a477 5
		$$.value = $1.value * $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d480 1
a480 2
		$$.value = ! $2.value;
		$$.undefined_macro = $2.undefined_macro;
d483 1
a483 2
		$$.value = ~ $2.value;
		$$.undefined_macro = $2.undefined_macro;
d486 1
a486 2
		$$.value = - $2.value;
		$$.undefined_macro = $2.undefined_macro;
d489 1
a489 2
		$$.value = + $2.value;
		$$.undefined_macro = $2.undefined_macro;
d514 6
d528 26
a553 1
		glcpp_error(&@@1, parser, "extra tokens at end of directive");
a581 4
|	DEFINED {
		$$ = _token_create_ival (parser, DEFINED, DEFINED);
		$$->location = yylloc;
	}
a623 2
|	PLUS_PLUS		{ $$ = PLUS_PLUS; }
|	MINUS_MINUS		{ $$ = MINUS_MINUS; }
a678 19
/* Return duplicate string in list (if any), NULL otherwise. */
const char *
_string_list_has_duplicate (string_list_t *list)
{
	string_node_t *node, *dup;

	if (list == NULL)
		return NULL;

	for (node = list->head; node; node = node->next) {
		for (dup = node->next; dup; dup = dup->next) {
			if (strcmp (node->str, dup->str) == 0)
				return node->str;
		}
	}

	return NULL;
}

d936 8
a943 10
		/* Make sure whitespace appears in the same places in both.
		 * It need not be exactly the same amount of whitespace,
		 * though.
		 */
		if (node_a->token->type == SPACE
		    && node_b->token->type == SPACE) {
			while (node_a->token->type == SPACE)
				node_a = node_a->next;
			while (node_b->token->type == SPACE)
				node_b = node_b->next;
d1023 2
a1024 8
        case PLUS_PLUS:
		ralloc_asprintf_rewrite_tail (out, len, "++");
		break;
        case MINUS_MINUS:
		ralloc_asprintf_rewrite_tail (out, len, "--");
		break;
	case DEFINED:
		ralloc_asprintf_rewrite_tail (out, len, "defined");
a1030 1

d1206 1
a1206 1
	parser->lexing_directive = 0;
a1207 3
	parser->last_token_was_newline = 0;
	parser->last_token_was_space = 0;
	parser->first_non_space_token_this_line = 1;
a1213 1
	parser->skipping = 0;
a1358 124
/* Evaluate a DEFINED token node (based on subsequent tokens in the list).
 *
 * Note: This function must only be called when "node" is a DEFINED token,
 * (and will abort with an assertion failure otherwise).
 *
 * If "node" is followed, (ignoring any SPACE tokens), by an IDENTIFIER token
 * (optionally preceded and followed by '(' and ')' tokens) then the following
 * occurs:
 *
 *	If the identifier is a defined macro, this function returns 1.
 *
 *	If the identifier is not a defined macro, this function returns 0.
 *
 *	In either case, *last will be updated to the last node in the list
 *	consumed by the evaluation, (either the token of the identifier or the
 *	token of the closing parenthesis).
 *
 * In all other cases, (such as "node is the final node of the list", or
 * "missing closing parenthesis", etc.), this function generates a
 * preprocessor error, returns -1 and *last will not be set.
 */
static int
_glcpp_parser_evaluate_defined (glcpp_parser_t *parser,
				token_node_t *node,
				token_node_t **last)
{
	token_node_t *argument, *defined = node;

	assert (node->token->type == DEFINED);

	node = node->next;

	/* Ignore whitespace after DEFINED token. */
	while (node && node->token->type == SPACE)
		node = node->next;

	if (node == NULL)
		goto FAIL;

	if (node->token->type == IDENTIFIER || node->token->type == OTHER) {
		argument = node;
	} else if (node->token->type == '(') {
		node = node->next;

		/* Ignore whitespace after '(' token. */
		while (node && node->token->type == SPACE)
			node = node->next;

		if (node == NULL || (node->token->type != IDENTIFIER &&
				     node->token->type != OTHER))
		{
			goto FAIL;
		}

		argument = node;

		node = node->next;

		/* Ignore whitespace after identifier, before ')' token. */
		while (node && node->token->type == SPACE)
			node = node->next;

		if (node == NULL || node->token->type != ')')
			goto FAIL;
	} else {
		goto FAIL;
	}

	*last = node;

	return hash_table_find (parser->defines,
				argument->token->value.str) ? 1 : 0;

FAIL:
	glcpp_error (&defined->token->location, parser,
		     "\"defined\" not followed by an identifier");
	return -1;
}

/* Evaluate all DEFINED nodes in a given list, modifying the list in place.
 */
static void
_glcpp_parser_evaluate_defined_in_list (glcpp_parser_t *parser,
					token_list_t *list)
{
	token_node_t *node, *node_prev, *replacement, *last = NULL;
	int value;

	if (list == NULL)
		return;

	node_prev = NULL;
	node = list->head;

	while (node) {

		if (node->token->type != DEFINED)
			goto NEXT;

		value = _glcpp_parser_evaluate_defined (parser, node, &last);
		if (value == -1)
			goto NEXT;

		replacement = ralloc (list, token_node_t);
		replacement->token = _token_create_ival (list, INTEGER, value);

		/* Splice replacement node into list, replacing from "node"
		 * through "last". */
		if (node_prev)
			node_prev->next = replacement;
		else
			list->head = replacement;
		replacement->next = last->next;
		if (last == list->tail)
			list->tail = replacement;

		node = replacement;

	NEXT:
		node_prev = node;
		node = node->next;
	}
}

a1362 3
 *
 * See the documentation of _glcpp_parser_expand_token_list for a description
 * of the "mode" parameter.
d1367 1
a1367 2
				   token_list_t *list,
				   expansion_mode_t mode)
d1375 1
a1375 1
	_glcpp_parser_expand_token_list (parser, list, mode);
a1437 3
 *
 * See the documentation of _glcpp_parser_expand_token_list for a description
 * of the "mode" parameter.
d1442 2
a1443 2
			       token_node_t **last,
			       expansion_mode_t mode)
d1512 1
a1512 2
								 expanded_argument,
								 mode);
a1551 3
 *
 * See the documentation of _glcpp_parser_expand_token_list for a description
 * of the "mode" parameter.
d1556 1
a1556 2
			   token_node_t **last,
			   expansion_mode_t mode)
d1564 8
d1623 1
a1623 1
	return _glcpp_parser_expand_function (parser, node, last, mode);
d1682 1
a1682 17
 * 'list' itself.
 *
 * The "mode" argument controls the handling of any DEFINED tokens that
 * result from expansion as follows:
 *
 *	EXPANSION_MODE_IGNORE_DEFINED: Any resulting DEFINED tokens will be
 *		left in the final list, unevaluated. This is the correct mode
 *		for expanding any list in any context other than a
 *		preprocessor conditional, (#if or #elif).
 *
 *	EXPANSION_MODE_EVALUATE_DEFINED: Any resulting DEFINED tokens will be
 *		evaluated to 0 or 1 tokens depending on whether the following
 *		token is the name of a defined macro. If the DEFINED token is
 *		not followed by an (optionally parenthesized) identifier, then
 *		an error will be generated. This the correct mode for
 *		expanding any list in the context of a preprocessor
 *		conditional, (#if or #elif).
d1686 1
a1686 2
				 token_list_t *list,
				 expansion_mode_t mode)
a1700 3
	if (mode == EXPANSION_MODE_EVALUATE_DEFINED)
		_glcpp_parser_evaluate_defined_in_list (parser, list);

d1706 1
a1706 1
		expansion = _glcpp_parser_expand_node (parser, node, &last, mode);
a1709 5
			if (mode == EXPANSION_MODE_EVALUATE_DEFINED) {
				_glcpp_parser_evaluate_defined_in_list (parser,
									expansion);
			}

d1762 1
a1762 1
	_glcpp_parser_expand_token_list (parser, list, EXPANSION_MODE_IGNORE_DEFINED);
a1822 4
	/* We define pre-defined macros before we've started parsing the
         * actual file. So if there's no location defined yet, that's what
         * were doing and we don't want to generate an error for using the
         * reserved names. */
a1854 1
	const char *dup;
a1857 6
        /* Check for any duplicate parameter names. */
	if ((dup = _string_list_has_duplicate (parameters)) != NULL) {
		glcpp_error (loc, parser, "Duplicate macro parameter \"%s\"",
			     dup);
	}

d1920 5
a1924 5
		else if (ret == DEFINE_TOKEN ||
			 ret == UNDEF || ret == IF ||
			 ret == IFDEF || ret == IFNDEF ||
			 ret == ELIF || ret == ELSE ||
			 ret == ENDIF || ret == HASH_TOKEN)
d2017 1
a2017 1
		glcpp_error (loc, parser, "#%s without #if\n", type);
a2069 2
              if (extensions->OES_standard_derivatives)
                 add_builtin_define(parser, "GL_OES_standard_derivatives", 1);
a2088 3
              if (extensions->ARB_fragment_layer_viewport)
                 add_builtin_define(parser, "GL_ARB_fragment_layer_viewport", 1);

a2091 3
	      if (extensions->ARB_explicit_uniform_location)
	         add_builtin_define(parser, "GL_ARB_explicit_uniform_location", 1);

a2129 3
	      if (extensions->AMD_vertex_shader_viewport_index)
	         add_builtin_define(parser, "GL_AMD_vertex_shader_viewport_index", 1);

a2149 3

              if (extensions->ARB_derivative_control)
                 add_builtin_define(parser, "GL_ARB_derivative_control", 1);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d60 3
d111 5
d122 2
a123 1
				   token_list_t *list);
d128 2
a129 1
				 token_list_t *list);
d177 5
a181 1
%token COMMA_FINAL DEFINED ELIF_EXPANDED HASH HASH_DEFINE FUNC_IDENTIFIER OBJ_IDENTIFIER HASH_ELIF HASH_ELSE HASH_ENDIF HASH_IF HASH_IFDEF HASH_IFNDEF HASH_LINE HASH_UNDEF HASH_VERSION IDENTIFIER IF_EXPANDED INTEGER INTEGER_STRING LINE_EXPANDED NEWLINE OTHER PLACEHOLDER SPACE
d183 3
a185 2
%type <ival> expression INTEGER operator SPACE integer_constant
%type <str> IDENTIFIER FUNC_IDENTIFIER OBJ_IDENTIFIER INTEGER_STRING OTHER
d187 2
a188 2
%type <token> preprocessing_token conditional_token
%type <token_list> pp_tokens replacement_list text_line conditional_tokens
d201 2
d211 2
a212 14
	control_line {
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "\n");
	}
|	HASH_LINE {
		glcpp_parser_resolve_implicit_version(parser);
	} pp_tokens NEWLINE {

		if (parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			_glcpp_parser_expand_and_lex_from (parser,
							   LINE_EXPANDED, $3);
		}
	}
a218 1
|	HASH non_directive
d223 3
a225 1
		_glcpp_parser_skip_stack_push_if (parser, & @@1, $2);
d228 3
a230 1
		_glcpp_parser_skip_stack_change_if (parser, & @@1, "elif", $2);
d265 20
a284 1
	HASH_DEFINE {
d287 1
a287 1
|	HASH_UNDEF {
d290 8
a297 1
		macro_t *macro = hash_table_find (parser->defines, $3);
d299 1
a299 1
			hash_table_remove (parser->defines, $3);
d302 1
a302 1
		ralloc_free ($3);
d304 1
a304 1
|	HASH_IF {
d306 1
a306 1
	} conditional_tokens NEWLINE {
d318 2
a319 1
							   IF_EXPANDED, $3);
d327 1
a327 1
|	HASH_IF NEWLINE {
d337 1
a337 1
|	HASH_IFDEF {
d340 2
a341 2
		macro_t *macro = hash_table_find (parser->defines, $3);
		ralloc_free ($3);
d344 1
a344 1
|	HASH_IFNDEF {
d347 3
a349 3
		macro_t *macro = hash_table_find (parser->defines, $3);
		ralloc_free ($3);
		_glcpp_parser_skip_stack_push_if (parser, & @@2, macro == NULL);
d351 1
a351 1
|	HASH_ELIF conditional_tokens NEWLINE {
d363 2
a364 1
							   ELIF_EXPANDED, $2);
d377 1
a377 1
|	HASH_ELIF NEWLINE {
d397 1
a397 1
|	HASH_ELSE {
d409 2
a410 2
	} NEWLINE
|	HASH_ENDIF {
d413 1
a413 1
|	HASH_VERSION integer_constant NEWLINE {
d417 1
a417 1
		_glcpp_parser_handle_version_declaration(parser, $2, NULL, true);
d419 1
a419 1
|	HASH_VERSION integer_constant IDENTIFIER NEWLINE {
d423 1
a423 1
		_glcpp_parser_handle_version_declaration(parser, $2, $3, true);
d425 1
a425 1
|	HASH NEWLINE {
d428 15
d460 4
a463 1
	integer_constant
d465 1
d467 3
a469 2
			glcpp_error(& @@1, parser, "undefined macro %s in expression (illegal in GLES)", $1);
		$$ = 0;
d472 9
a480 1
		$$ = $1 || $3;
d483 9
a491 1
		$$ = $1 && $3;
d494 5
a498 1
		$$ = $1 | $3;
d501 5
a505 1
		$$ = $1 ^ $3;
d508 5
a512 1
		$$ = $1 & $3;
d515 5
a519 1
		$$ = $1 != $3;
d522 5
a526 1
		$$ = $1 == $3;
d529 5
a533 1
		$$ = $1 >= $3;
d536 5
a540 1
		$$ = $1 <= $3;
d543 5
a547 1
		$$ = $1 > $3;
d550 5
a554 1
		$$ = $1 < $3;
d557 5
a561 1
		$$ = $1 >> $3;
d564 5
a568 1
		$$ = $1 << $3;
d571 5
a575 1
		$$ = $1 - $3;
d578 5
a582 1
		$$ = $1 + $3;
d585 1
a585 1
		if ($3 == 0) {
d589 1
a589 1
			$$ = $1 % $3;
d591 4
d597 1
a597 1
		if ($3 == 0) {
d601 1
a601 1
			$$ = $1 / $3;
d603 4
d609 5
a613 1
		$$ = $1 * $3;
d616 2
a617 1
		$$ = ! $2;
d620 2
a621 1
		$$ = ~ $2;
d624 2
a625 1
		$$ = - $2;
d628 2
a629 1
		$$ = + $2;
a653 6
non_directive:
	pp_tokens NEWLINE {
		yyerror (& @@1, parser, "Invalid tokens after #");
	}
;

d662 1
a662 26
		glcpp_warning(&@@1, parser, "extra tokens at end of directive");
	}
;

conditional_token:
	/* Handle "defined" operator */
	DEFINED IDENTIFIER {
		int v = hash_table_find (parser->defines, $2) ? 1 : 0;
		$$ = _token_create_ival (parser, INTEGER, v);
	}
|	DEFINED '(' IDENTIFIER ')' {
		int v = hash_table_find (parser->defines, $3) ? 1 : 0;
		$$ = _token_create_ival (parser, INTEGER, v);
	}
|	preprocessing_token
;

conditional_tokens:
	/* Exactly the same as pp_tokens, but using conditional_token */
	conditional_token {
		$$ = _token_list_create (parser);
		_token_list_append ($$, $1);
	}
|	conditional_tokens conditional_token {
		$$ = $1;
		_token_list_append ($$, $2);
d691 4
d737 2
d794 19
d1070 10
a1079 8

		if (node_a->token->type == SPACE) {
			node_a = node_a->next;
			continue;
		}

		if (node_b->token->type == SPACE) {
			node_b = node_b->next;
d1159 8
a1166 2
	case COMMA_FINAL:
		ralloc_asprintf_rewrite_tail (out, len, ",");
d1173 1
d1349 1
a1349 1
	parser->lexing_if = 0;
d1351 3
d1360 1
d1506 124
d1634 3
d1641 2
a1642 1
				   token_list_t *list)
d1650 1
a1650 1
	_glcpp_parser_expand_token_list (parser, list);
d1713 3
d1720 2
a1721 2
			       token_node_t **last)
			       
d1790 2
a1791 1
								 expanded_argument);
d1831 3
d1838 2
a1839 1
			   token_node_t **last)
a1846 8
		/* We change any COMMA into a COMMA_FINAL to prevent
		 * it being mistaken for an argument separator
		 * later. */
		if (token->type == ',') {
			token->type = COMMA_FINAL;
			token->value.ival = COMMA_FINAL;
		}

d1898 1
a1898 1
	return _glcpp_parser_expand_function (parser, node, last);
d1957 17
a1973 1
 * 'list' itself;
d1977 2
a1978 1
				 token_list_t *list)
d1993 3
d2001 1
a2001 1
		expansion = _glcpp_parser_expand_node (parser, node, &last);
d2005 5
d2062 1
a2062 1
	_glcpp_parser_expand_token_list (parser, list);
d2123 4
d2159 1
d2163 6
d2231 5
a2235 5
		else if (ret == HASH_DEFINE ||
			   ret == HASH_UNDEF || ret == HASH_IF ||
			   ret == HASH_IFDEF || ret == HASH_IFNDEF ||
			   ret == HASH_ELIF || ret == HASH_ELSE ||
			   ret == HASH_ENDIF || ret == HASH)
d2328 1
a2328 1
		glcpp_error (loc, parser, "%s without #if\n", type);
d2381 2
d2402 3
d2408 3
d2449 3
d2472 3
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d138 1
a138 1
                                         const char *ident);
d197 4
a200 1
|	HASH_LINE pp_tokens NEWLINE {
d205 1
a205 1
							   LINE_EXPANDED, $2);
d244 3
a246 3
control_line:
	HASH_DEFINE OBJ_IDENTIFIER replacement_list NEWLINE {
		_define_object_macro (parser, & @@2, $2, $3);
d248 2
a249 2
|	HASH_DEFINE FUNC_IDENTIFIER '(' ')' replacement_list NEWLINE {
		_define_function_macro (parser, & @@2, $2, NULL, $5);
d251 2
a252 2
|	HASH_DEFINE FUNC_IDENTIFIER '(' identifier_list ')' replacement_list NEWLINE {
		_define_function_macro (parser, & @@2, $2, $4, $6);
d254 10
a263 2
|	HASH_UNDEF IDENTIFIER NEWLINE {
		macro_t *macro = hash_table_find (parser->defines, $2);
d265 1
a265 1
			hash_table_remove (parser->defines, $2);
d268 1
a268 1
		ralloc_free ($2);
d270 3
a272 1
|	HASH_IF conditional_tokens NEWLINE {
d284 1
a284 1
							   IF_EXPANDED, $2);
d302 5
a306 3
|	HASH_IFDEF IDENTIFIER junk NEWLINE {
		macro_t *macro = hash_table_find (parser->defines, $2);
		ralloc_free ($2);
d309 6
a314 4
|	HASH_IFNDEF IDENTIFIER junk NEWLINE {
		macro_t *macro = hash_table_find (parser->defines, $2);
		ralloc_free ($2);
		_glcpp_parser_skip_stack_push_if (parser, & @@1, macro == NULL);
d330 5
d349 5
d362 11
a372 1
		_glcpp_parser_skip_stack_change_if (parser, & @@1, "else", 1);
d378 4
a381 1
		_glcpp_parser_handle_version_declaration(parser, $2, NULL);
d384 7
a390 1
		_glcpp_parser_handle_version_declaration(parser, $2, $3);
a391 1
|	HASH NEWLINE
d1196 1
a1196 1
glcpp_parser_create (const struct gl_extensions *extensions, int api)
a1198 1
	int language_version;
d1211 1
d1224 4
a1232 70
	parser->is_gles = false;

	/* Add pre-defined macros. */
	if (api == API_OPENGLES2) {
           parser->is_gles = true;
           add_builtin_define(parser, "GL_ES", 1);

           if (extensions != NULL) {
              if (extensions->OES_EGL_image_external)
                 add_builtin_define(parser, "GL_OES_EGL_image_external", 1);
           }
	} else {
	   add_builtin_define(parser, "GL_ARB_draw_buffers", 1);
	   add_builtin_define(parser, "GL_ARB_texture_rectangle", 1);

	   if (extensions != NULL) {
	      if (extensions->EXT_texture_array) {
	         add_builtin_define(parser, "GL_EXT_texture_array", 1);
	      }

	      if (extensions->ARB_fragment_coord_conventions)
	         add_builtin_define(parser, "GL_ARB_fragment_coord_conventions",
				    1);

	      if (extensions->ARB_explicit_attrib_location)
	         add_builtin_define(parser, "GL_ARB_explicit_attrib_location", 1);

	      if (extensions->ARB_shader_texture_lod)
	         add_builtin_define(parser, "GL_ARB_shader_texture_lod", 1);

	      if (extensions->ARB_draw_instanced)
	         add_builtin_define(parser, "GL_ARB_draw_instanced", 1);

	      if (extensions->ARB_conservative_depth) {
	         add_builtin_define(parser, "GL_AMD_conservative_depth", 1);
	         add_builtin_define(parser, "GL_ARB_conservative_depth", 1);
	      }

	      if (extensions->ARB_shader_bit_encoding)
	         add_builtin_define(parser, "GL_ARB_shader_bit_encoding", 1);

	      if (extensions->ARB_uniform_buffer_object)
	         add_builtin_define(parser, "GL_ARB_uniform_buffer_object", 1);

	      if (extensions->ARB_texture_cube_map_array)
	         add_builtin_define(parser, "GL_ARB_texture_cube_map_array", 1);

	      if (extensions->ARB_shading_language_packing)
	         add_builtin_define(parser, "GL_ARB_shading_language_packing", 1);

	      if (extensions->ARB_texture_multisample)
	         add_builtin_define(parser, "GL_ARB_texture_multisample", 1);

	      if (extensions->ARB_texture_query_lod)
	         add_builtin_define(parser, "GL_ARB_texture_query_lod", 1);

	      if (extensions->ARB_gpu_shader5)
	         add_builtin_define(parser, "GL_ARB_gpu_shader5", 1);

	      if (extensions->AMD_vertex_shader_layer)
	         add_builtin_define(parser, "GL_AMD_vertex_shader_layer", 1);

	      if (extensions->ARB_shading_language_420pack)
	         add_builtin_define(parser, "GL_ARB_shading_language_420pack", 1);
	   }
	}

	language_version = 110;
	add_builtin_define(parser, "__VERSION__", language_version);

d1773 16
a1788 2
	/* According to the GLSL specification, macro names starting with "__"
	 * or "GL_" are reserved for future use.  So, don't allow them.
d1791 3
a1793 1
		glcpp_error (loc, parser, "Macro names containing \"__\" are reserved.\n");
d2007 1
d2046 2
a2047 1
                                         const char *es_identifier)
d2049 102
a2150 4
	macro_t *macro = hash_table_find (parser->defines, "__VERSION__");
	if (macro) {
		hash_table_remove (parser->defines, "__VERSION__");
		ralloc_free (macro);
a2151 1
	add_builtin_define (parser, "__VERSION__", version);
d2153 3
a2155 9
	/* If we didn't have a GLES context to begin with, (indicated
	 * by parser->api), then the version declaration here might
	 * indicate GLES. */
	if (! parser->is_gles &&
	    (version == 100 ||
	     (es_identifier && (strcmp(es_identifier, "es") == 0))))
	{
		parser->is_gles = true;
		add_builtin_define (parser, "GL_ES", 1);
d2169 23
a2191 4
	ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length,
                                      "#version %" PRIiMAX "%s%s", version,
                                      es_identifier ? " " : "",
                                      es_identifier ? es_identifier : "");
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a87 1
/* Note: This function calls ralloc_steal on token. */
d108 3
d112 3
a114 1
_glcpp_parser_expand_if (glcpp_parser_t *parser, int type, token_list_t *list);
d116 1
d136 3
a138 1
#define yylex glcpp_parser_lex
d167 1
a167 1
%token COMMA_FINAL DEFINED ELIF_EXPANDED HASH HASH_DEFINE_FUNC HASH_DEFINE_OBJ HASH_ELIF HASH_ELSE HASH_ENDIF HASH_IF HASH_IFDEF HASH_IFNDEF HASH_UNDEF HASH_VERSION IDENTIFIER IF_EXPANDED INTEGER INTEGER_STRING NEWLINE OTHER PLACEHOLDER SPACE
d170 1
a170 1
%type <str> IDENTIFIER INTEGER_STRING OTHER
d195 9
a203 1
		ralloc_strcat (&parser->output, "\n");
d207 1
a207 1
		ralloc_strcat (&parser->output, "\n");
d221 18
d242 1
a242 1
	HASH_DEFINE_OBJ	IDENTIFIER replacement_list NEWLINE {
d245 1
a245 1
|	HASH_DEFINE_FUNC IDENTIFIER '(' ')' replacement_list NEWLINE {
d248 1
a248 1
|	HASH_DEFINE_FUNC IDENTIFIER '(' identifier_list ')' replacement_list NEWLINE {
d270 2
a271 1
			_glcpp_parser_expand_if (parser, IF_EXPANDED, $2);
d310 2
a311 1
			_glcpp_parser_expand_if (parser, ELIF_EXPANDED, $2);
d334 1
a334 1
|	HASH_ELSE NEWLINE {
d336 2
a337 2
	}
|	HASH_ENDIF NEWLINE {
d339 3
d343 2
a344 20
|	HASH_VERSION integer_constant NEWLINE {
		macro_t *macro = hash_table_find (parser->defines, "__VERSION__");
		if (macro) {
			hash_table_remove (parser->defines, "__VERSION__");
			ralloc_free (macro);
		}
		add_builtin_define (parser, "__VERSION__", $2);

		if ($2 == 100)
			add_builtin_define (parser, "GL_ES", 1);

		/* Currently, all ES2 implementations support highp in the
		 * fragment shader, so we always define this macro in ES2.
		 * If we ever get a driver that doesn't support highp, we'll
		 * need to add a flag to the gl_context and check that here.
		 */
		if ($2 >= 130 || $2 == 100)
			add_builtin_define (parser, "GL_FRAGMENT_PRECISION_HIGH", 1);

		ralloc_asprintf_append (&parser->output, "#version %" PRIiMAX, $2);
d365 5
a790 2
	ralloc_steal (list, token);

d932 1
a932 1
_token_print (char **out, token_t *token)
d935 1
a935 1
		ralloc_asprintf_append (out, "%c", token->type);
d941 1
a941 1
		ralloc_asprintf_append (out, "%" PRIiMAX, token->value.ival);
d946 1
a946 1
		ralloc_strcat (out, token->value.str);
d949 1
a949 1
		ralloc_strcat (out, " ");
d952 1
a952 1
		ralloc_strcat (out, "<<");
d955 1
a955 1
		ralloc_strcat (out, ">>");
d958 1
a958 1
		ralloc_strcat (out, "<=");
d961 1
a961 1
		ralloc_strcat (out, ">=");
d964 1
a964 1
		ralloc_strcat (out, "==");
d967 1
a967 1
		ralloc_strcat (out, "!=");
d970 1
a970 1
		ralloc_strcat (out, "&&");
d973 1
a973 1
		ralloc_strcat (out, "||");
d976 1
a976 1
		ralloc_strcat (out, "##");
d979 1
a979 1
		ralloc_strcat (out, ",");
d1048 3
a1050 2
	/* Two string-valued tokens can usually just be mashed
	 * together.
d1052 7
a1058 7
	 * XXX: This isn't actually legitimate. Several things here
	 * should result in a diagnostic since the result cannot be a
	 * valid, single pre-processing token. For example, pasting
	 * "123" and "abc" is not legal, but we don't catch that
	 * here. */
	if ((token->type == IDENTIFIER || token->type == OTHER || token->type == INTEGER_STRING) &&
	    (other->type == IDENTIFIER || other->type == OTHER || other->type == INTEGER_STRING))
d1061 21
d1083 21
a1103 3
		str = ralloc_asprintf (token, "%s%s", token->value.str,
				       other->value.str);
		combined = _token_create_str (token, token->type, str);
d1108 1
d1110 5
a1114 5
	ralloc_strcat (&parser->info_log, "Pasting \"");
	_token_print (&parser->info_log, token);
	ralloc_strcat (&parser->info_log, "\" and \"");
	_token_print (&parser->info_log, other);
	ralloc_strcat (&parser->info_log, "\" does not give a valid preprocessing token.\n");
d1128 1
a1128 1
		_token_print (&parser->output, node->token);
d1174 1
d1176 1
d1179 7
d1187 26
a1212 2
	add_builtin_define(parser, "GL_ARB_draw_buffers", 1);
	add_builtin_define(parser, "GL_ARB_texture_rectangle", 1);
d1214 2
a1215 2
	if (api == API_OPENGLES2)
		add_builtin_define(parser, "GL_ES", 1);
d1217 19
a1235 4
	if (extensions != NULL) {
	   if (extensions->EXT_texture_array) {
	      add_builtin_define(parser, "GL_EXT_texture_array", 1);
	   }
d1237 2
a1238 3
	   if (extensions->ARB_fragment_coord_conventions)
	      add_builtin_define(parser, "GL_ARB_fragment_coord_conventions",
				 1);
d1240 2
a1241 2
	   if (extensions->ARB_explicit_attrib_location)
	      add_builtin_define(parser, "GL_ARB_explicit_attrib_location", 1);
d1243 2
a1244 2
	   if (extensions->ARB_shader_texture_lod)
	      add_builtin_define(parser, "GL_ARB_shader_texture_lod", 1);
d1246 3
a1248 2
	   if (extensions->AMD_conservative_depth)
	      add_builtin_define(parser, "GL_AMD_conservative_depth", 1);
a1256 6
int
glcpp_parser_parse (glcpp_parser_t *parser)
{
	return yyparse (parser);
}

d1356 1
a1356 1
_token_list_create_with_one_space (void *ctx)
d1359 1
a1359 1
	token_t *space;
d1362 2
a1363 2
	space = _token_create_ival (list, SPACE, SPACE);
	_token_list_append (list, space);
d1368 17
d1386 3
a1388 1
_glcpp_parser_expand_if (glcpp_parser_t *parser, int type, token_list_t *list)
d1394 1
a1394 1
	token = _token_create_ival (parser, type, type);
d1596 11
a1607 1
	identifier = token->value.str;
a1627 1
		*last = node;
a1633 1
		*last = node;
d1925 1
a1925 1
		else if (ret == HASH_DEFINE_OBJ || ret == HASH_DEFINE_FUNC ||
d2046 39
@


1.1
log
@Initial revision
@
text
@d1131 6
d1276 42
d1429 1
a1429 37
	node = substituted->head;
	while (node)
	{
		token_node_t *next_non_space;

		/* Look ahead for a PASTE token, skipping space. */
		next_non_space = node->next;
		while (next_non_space && next_non_space->token->type == SPACE)
			next_non_space = next_non_space->next;

		if (next_non_space == NULL)
			break;

		if (next_non_space->token->type != PASTE) {
			node = next_non_space;
			continue;
		}

		/* Now find the next non-space token after the PASTE. */
		next_non_space = next_non_space->next;
		while (next_non_space && next_non_space->token->type == SPACE)
			next_non_space = next_non_space->next;

		if (next_non_space == NULL) {
			yyerror (&node->token->location, parser, "'##' cannot appear at either end of a macro expansion\n");
			return NULL;
		}

		node->token = _token_paste (parser, node->token, next_non_space->token);
		node->next = next_non_space->next;
		if (next_non_space == substituted->tail)
			substituted->tail = node;

		node = node->next;
	}

	substituted->non_space_tail = substituted->tail;
d1499 1
d1506 3
a1508 1
		return _token_list_copy (parser, macro->replacements);
d1664 2
a1665 2
	if (strncmp(identifier, "__", 2) == 0) {
		glcpp_error (loc, parser, "Macro names starting with \"__\" are reserved.\n");
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d88 1
a108 3
/* Expand list, and begin lexing from the result (after first
 * prefixing a token of type 'head_token_type').
 */
d110 1
a110 3
_glcpp_parser_expand_and_lex_from (glcpp_parser_t *parser,
				   int head_token_type,
				   token_list_t *list);
a111 1
/* Perform macro expansion in-place on the given list. */
d131 1
a131 3
static void
_glcpp_parser_handle_version_declaration(glcpp_parser_t *parser, intmax_t version,
                                         const char *ident);
d160 1
a160 1
%token COMMA_FINAL DEFINED ELIF_EXPANDED HASH HASH_DEFINE FUNC_IDENTIFIER OBJ_IDENTIFIER HASH_ELIF HASH_ELSE HASH_ENDIF HASH_IF HASH_IFDEF HASH_IFNDEF HASH_LINE HASH_UNDEF HASH_VERSION IDENTIFIER IF_EXPANDED INTEGER INTEGER_STRING LINE_EXPANDED NEWLINE OTHER PLACEHOLDER SPACE
d163 1
a163 1
%type <str> IDENTIFIER FUNC_IDENTIFIER OBJ_IDENTIFIER INTEGER_STRING OTHER
d188 1
a188 9
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "\n");
	}
|	HASH_LINE pp_tokens NEWLINE {
		if (parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			_glcpp_parser_expand_and_lex_from (parser,
							   LINE_EXPANDED, $2);
		}
d192 1
a192 1
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "\n");
a205 18
|	LINE_EXPANDED integer_constant NEWLINE {
		parser->has_new_line_number = 1;
		parser->new_line_number = $2;
		ralloc_asprintf_rewrite_tail (&parser->output,
					      &parser->output_length,
					      "#line %" PRIiMAX "\n",
					      $2);
	}
|	LINE_EXPANDED integer_constant integer_constant NEWLINE {
		parser->has_new_line_number = 1;
		parser->new_line_number = $2;
		parser->has_new_source_number = 1;
		parser->new_source_number = $3;
		ralloc_asprintf_rewrite_tail (&parser->output,
					      &parser->output_length,
					      "#line %" PRIiMAX " %" PRIiMAX "\n",
					      $2, $3);
	}
d209 1
a209 1
	HASH_DEFINE OBJ_IDENTIFIER replacement_list NEWLINE {
d212 1
a212 1
|	HASH_DEFINE FUNC_IDENTIFIER '(' ')' replacement_list NEWLINE {
d215 1
a215 1
|	HASH_DEFINE FUNC_IDENTIFIER '(' identifier_list ')' replacement_list NEWLINE {
d237 1
a237 2
			_glcpp_parser_expand_and_lex_from (parser,
							   IF_EXPANDED, $2);
d276 1
a276 2
			_glcpp_parser_expand_and_lex_from (parser,
							   ELIF_EXPANDED, $2);
d299 1
a299 1
|	HASH_ELSE {
d301 2
a302 2
	} NEWLINE
|	HASH_ENDIF {
d304 1
a304 1
	} NEWLINE
d306 19
a324 4
		_glcpp_parser_handle_version_declaration(parser, $2, NULL);
	}
|	HASH_VERSION integer_constant IDENTIFIER NEWLINE {
		_glcpp_parser_handle_version_declaration(parser, $2, $3);
a344 5
|	IDENTIFIER {
		if (parser->is_gles)
			glcpp_error(& @@1, parser, "undefined macro %s in expression (illegal in GLES)", $1);
		$$ = 0;
	}
d766 2
d909 1
a909 1
_token_print (char **out, size_t *len, token_t *token)
d912 1
a912 1
		ralloc_asprintf_rewrite_tail (out, len, "%c", token->type);
d918 1
a918 1
		ralloc_asprintf_rewrite_tail (out, len, "%" PRIiMAX, token->value.ival);
d923 1
a923 1
		ralloc_asprintf_rewrite_tail (out, len, "%s", token->value.str);
d926 1
a926 1
		ralloc_asprintf_rewrite_tail (out, len, " ");
d929 1
a929 1
		ralloc_asprintf_rewrite_tail (out, len, "<<");
d932 1
a932 1
		ralloc_asprintf_rewrite_tail (out, len, ">>");
d935 1
a935 1
		ralloc_asprintf_rewrite_tail (out, len, "<=");
d938 1
a938 1
		ralloc_asprintf_rewrite_tail (out, len, ">=");
d941 1
a941 1
		ralloc_asprintf_rewrite_tail (out, len, "==");
d944 1
a944 1
		ralloc_asprintf_rewrite_tail (out, len, "!=");
d947 1
a947 1
		ralloc_asprintf_rewrite_tail (out, len, "&&");
d950 1
a950 1
		ralloc_asprintf_rewrite_tail (out, len, "||");
d953 1
a953 1
		ralloc_asprintf_rewrite_tail (out, len, "##");
d956 1
a956 1
		ralloc_asprintf_rewrite_tail (out, len, ",");
d1025 2
a1026 3
	/* Two string-valued (or integer) tokens can usually just be
	 * mashed together. (We also handle a string followed by an
	 * integer here as well.)
d1028 7
a1034 7
	 * There are some exceptions here. Notably, if the first token
	 * is an integer (or a string representing an integer), then
	 * the second token must also be an integer or must be a
	 * string representing an integer that begins with a digit.
	 */
	if ((token->type == IDENTIFIER || token->type == OTHER || token->type == INTEGER_STRING || token->type == INTEGER) &&
	    (other->type == IDENTIFIER || other->type == OTHER || other->type == INTEGER_STRING || other->type == INTEGER))
a1036 28
		int combined_type;

		/* Check that pasting onto an integer doesn't create a
		 * non-integer, (that is, only digits can be
		 * pasted. */
		if (token->type == INTEGER_STRING || token->type == INTEGER)
		{
			switch (other->type) {
			case INTEGER_STRING:
				if (other->value.str[0] < '0' ||
				    other->value.str[0] > '9')
					goto FAIL;
				break;
			case INTEGER:
				if (other->value.ival < 0)
					goto FAIL;
				break;
			default:
				goto FAIL;
			}
		}

		if (token->type == INTEGER)
			str = ralloc_asprintf (token, "%" PRIiMAX,
					       token->value.ival);
		else
			str = ralloc_strdup (token, token->value.str);
					       
d1038 3
a1040 14
		if (other->type == INTEGER)
			ralloc_asprintf_append (&str, "%" PRIiMAX,
						other->value.ival);
		else
			ralloc_strcat (&str, other->value.str);

		/* New token is same type as original token, unless we
		 * started with an integer, in which case we will be
		 * creating an integer-string. */
		combined_type = token->type;
		if (combined_type == INTEGER)
			combined_type = INTEGER_STRING;

		combined = _token_create_str (token, combined_type, str);
a1044 1
    FAIL:
d1046 5
a1050 5
	ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "Pasting \"");
	_token_print (&parser->info_log, &parser->info_log_length, token);
	ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "\" and \"");
	_token_print (&parser->info_log, &parser->info_log_length, other);
	ralloc_asprintf_rewrite_tail (&parser->info_log, &parser->info_log_length, "\" does not give a valid preprocessing token.\n");
d1064 1
a1064 1
		_token_print (&parser->output, &parser->output_length, node->token);
a1109 1
	parser->output_length = 0;
a1110 1
	parser->info_log_length = 0;
a1112 7
	parser->has_new_line_number = 0;
	parser->new_line_number = 1;
	parser->has_new_source_number = 0;
	parser->new_source_number = 0;

	parser->is_gles = false;

d1114 2
a1115 11
	if (api == API_OPENGLES2) {
           parser->is_gles = true;
           add_builtin_define(parser, "GL_ES", 1);

           if (extensions != NULL) {
              if (extensions->OES_EGL_image_external)
                 add_builtin_define(parser, "GL_OES_EGL_image_external", 1);
           }
	} else {
	   add_builtin_define(parser, "GL_ARB_draw_buffers", 1);
	   add_builtin_define(parser, "GL_ARB_texture_rectangle", 1);
d1117 2
a1118 4
	   if (extensions != NULL) {
	      if (extensions->EXT_texture_array) {
	         add_builtin_define(parser, "GL_EXT_texture_array", 1);
	      }
d1120 4
a1123 9
	      if (extensions->ARB_fragment_coord_conventions)
	         add_builtin_define(parser, "GL_ARB_fragment_coord_conventions",
				    1);

	      if (extensions->ARB_explicit_attrib_location)
	         add_builtin_define(parser, "GL_ARB_explicit_attrib_location", 1);

	      if (extensions->ARB_shader_texture_lod)
	         add_builtin_define(parser, "GL_ARB_shader_texture_lod", 1);
d1125 3
a1127 2
	      if (extensions->ARB_draw_instanced)
	         add_builtin_define(parser, "GL_ARB_draw_instanced", 1);
d1129 2
a1130 32
	      if (extensions->ARB_conservative_depth) {
	         add_builtin_define(parser, "GL_AMD_conservative_depth", 1);
	         add_builtin_define(parser, "GL_ARB_conservative_depth", 1);
	      }

	      if (extensions->ARB_shader_bit_encoding)
	         add_builtin_define(parser, "GL_ARB_shader_bit_encoding", 1);

	      if (extensions->ARB_uniform_buffer_object)
	         add_builtin_define(parser, "GL_ARB_uniform_buffer_object", 1);

	      if (extensions->ARB_texture_cube_map_array)
	         add_builtin_define(parser, "GL_ARB_texture_cube_map_array", 1);

	      if (extensions->ARB_shading_language_packing)
	         add_builtin_define(parser, "GL_ARB_shading_language_packing", 1);

	      if (extensions->ARB_texture_multisample)
	         add_builtin_define(parser, "GL_ARB_texture_multisample", 1);

	      if (extensions->ARB_texture_query_lod)
	         add_builtin_define(parser, "GL_ARB_texture_query_lod", 1);

	      if (extensions->ARB_gpu_shader5)
	         add_builtin_define(parser, "GL_ARB_gpu_shader5", 1);

	      if (extensions->AMD_vertex_shader_layer)
	         add_builtin_define(parser, "GL_AMD_vertex_shader_layer", 1);

	      if (extensions->ARB_shading_language_420pack)
	         add_builtin_define(parser, "GL_ARB_shading_language_420pack", 1);
	   }
d1139 6
d1244 1
a1244 1
_token_list_create_with_one_ival (void *ctx, int type, int ival)
d1247 1
a1247 1
	token_t *node;
d1250 2
a1251 2
	node = _token_create_ival (list, type, ival);
	_token_list_append (list, node);
a1255 17
static token_list_t *
_token_list_create_with_one_space (void *ctx)
{
	return _token_list_create_with_one_ival (ctx, SPACE, SPACE);
}

static token_list_t *
_token_list_create_with_one_integer (void *ctx, int ival)
{
	return _token_list_create_with_one_ival (ctx, INTEGER, ival);
}

/* Perform macro expansion on 'list', placing the resulting tokens
 * into a new list which is initialized with a first token of type
 * 'head_token_type'. Then begin lexing from the resulting list,
 * (return to the current lexing source when this list is exhausted).
 */
d1257 1
a1257 3
_glcpp_parser_expand_and_lex_from (glcpp_parser_t *parser,
				   int head_token_type,
				   token_list_t *list)
d1263 1
a1263 1
	token = _token_create_ival (parser, head_token_type, head_token_type);
a1269 42
static void
_glcpp_parser_apply_pastes (glcpp_parser_t *parser, token_list_t *list)
{
	token_node_t *node;

	node = list->head;
	while (node)
	{
		token_node_t *next_non_space;

		/* Look ahead for a PASTE token, skipping space. */
		next_non_space = node->next;
		while (next_non_space && next_non_space->token->type == SPACE)
			next_non_space = next_non_space->next;

		if (next_non_space == NULL)
			break;

		if (next_non_space->token->type != PASTE) {
			node = next_non_space;
			continue;
		}

		/* Now find the next non-space token after the PASTE. */
		next_non_space = next_non_space->next;
		while (next_non_space && next_non_space->token->type == SPACE)
			next_non_space = next_non_space->next;

		if (next_non_space == NULL) {
			yyerror (&node->token->location, parser, "'##' cannot appear at either end of a macro expansion\n");
			return;
		}

		node->token = _token_paste (parser, node->token, next_non_space->token);
		node->next = next_non_space->next;
		if (next_non_space == list->tail)
			list->tail = node;
	}

	list->non_space_tail = list->tail;
}

d1381 37
a1417 1
	_glcpp_parser_apply_pastes (parser, substituted);
d1459 1
a1459 1
	*last = node;
a1460 10

	/* Special handling for __LINE__ and __FILE__, (not through
	 * the hash table). */
	if (strcmp(identifier, "__LINE__") == 0)
		return _token_list_create_with_one_integer (parser, node->token->location.first_line);

	if (strcmp(identifier, "__FILE__") == 0)
		return _token_list_create_with_one_integer (parser, node->token->location.source);

	/* Look up this identifier in the hash table. */
d1481 1
d1487 1
a1487 1
		token_list_t *replacement;
d1493 1
a1493 3
		replacement = _token_list_copy (parser, macro->replacements);
		_glcpp_parser_apply_pastes (parser, replacement);
		return replacement;
d1649 2
a1650 2
	if (strstr(identifier, "__")) {
		glcpp_error (loc, parser, "Macro names containing \"__\" are reserved.\n");
d1777 1
a1777 1
		else if (ret == HASH_DEFINE ||
a1897 39
}

static void
_glcpp_parser_handle_version_declaration(glcpp_parser_t *parser, intmax_t version,
                                         const char *es_identifier)
{
	macro_t *macro = hash_table_find (parser->defines, "__VERSION__");
	if (macro) {
		hash_table_remove (parser->defines, "__VERSION__");
		ralloc_free (macro);
	}
	add_builtin_define (parser, "__VERSION__", version);

	/* If we didn't have a GLES context to begin with, (indicated
	 * by parser->api), then the version declaration here might
	 * indicate GLES. */
	if (! parser->is_gles &&
	    (version == 100 ||
	     (es_identifier && (strcmp(es_identifier, "es") == 0))))
	{
		parser->is_gles = true;
		add_builtin_define (parser, "GL_ES", 1);
	}

	if (version >= 150)
		add_builtin_define(parser, "GL_core_profile", 1);

	/* Currently, all ES2/ES3 implementations support highp in the
	 * fragment shader, so we always define this macro in ES2/ES3.
	 * If we ever get a driver that doesn't support highp, we'll
	 * need to add a flag to the gl_context and check that here.
	 */
	if (version >= 130 || parser->is_gles)
		add_builtin_define (parser, "GL_FRAGMENT_PRECISION_HIGH", 1);

	ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length,
                                      "#version %" PRIiMAX "%s%s", version,
                                      es_identifier ? " " : "",
                                      es_identifier ? es_identifier : "");
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d138 1
a138 1
                                         const char *ident, bool explicitly_set);
d197 1
a197 4
|	HASH_LINE {
		glcpp_parser_resolve_implicit_version(parser);
	} pp_tokens NEWLINE {

d202 1
a202 1
							   LINE_EXPANDED, $3);
d241 3
a243 3
define:
	OBJ_IDENTIFIER replacement_list NEWLINE {
		_define_object_macro (parser, & @@1, $1, $2);
d245 2
a246 2
|	FUNC_IDENTIFIER '(' ')' replacement_list NEWLINE {
		_define_function_macro (parser, & @@1, $1, NULL, $4);
d248 2
a249 2
|	FUNC_IDENTIFIER '(' identifier_list ')' replacement_list NEWLINE {
		_define_function_macro (parser, & @@1, $1, $3, $5);
d251 2
a252 10
;

control_line:
	HASH_DEFINE {
		glcpp_parser_resolve_implicit_version(parser);
	} define
|	HASH_UNDEF {
		glcpp_parser_resolve_implicit_version(parser);
	} IDENTIFIER NEWLINE {
		macro_t *macro = hash_table_find (parser->defines, $3);
d254 1
a254 1
			hash_table_remove (parser->defines, $3);
d257 1
a257 1
		ralloc_free ($3);
d259 1
a259 3
|	HASH_IF {
		glcpp_parser_resolve_implicit_version(parser);
	} conditional_tokens NEWLINE {
d271 1
a271 1
							   IF_EXPANDED, $3);
d289 3
a291 5
|	HASH_IFDEF {
		glcpp_parser_resolve_implicit_version(parser);
	} IDENTIFIER junk NEWLINE {
		macro_t *macro = hash_table_find (parser->defines, $3);
		ralloc_free ($3);
d294 4
a297 6
|	HASH_IFNDEF {
		glcpp_parser_resolve_implicit_version(parser);
	} IDENTIFIER junk NEWLINE {
		macro_t *macro = hash_table_find (parser->defines, $3);
		ralloc_free ($3);
		_glcpp_parser_skip_stack_push_if (parser, & @@2, macro == NULL);
a312 5
		else if (parser->skip_stack &&
		    parser->skip_stack->has_else)
		{
			glcpp_error(& @@1, parser, "#elif after #else");
		}
a326 5
		else if (parser->skip_stack &&
		    parser->skip_stack->has_else)
		{
			glcpp_error(& @@1, parser, "#elif after #else");
		}
d335 1
a335 11
		if (parser->skip_stack &&
		    parser->skip_stack->has_else)
		{
			glcpp_error(& @@1, parser, "multiple #else");
		}
		else
		{
			_glcpp_parser_skip_stack_change_if (parser, & @@1, "else", 1);
			if (parser->skip_stack)
				parser->skip_stack->has_else = true;
		}
d341 1
a341 4
		if (parser->version_resolved) {
			glcpp_error(& @@1, parser, "#version must appear on the first line");
		}
		_glcpp_parser_handle_version_declaration(parser, $2, NULL, true);
d344 1
a344 7
		if (parser->version_resolved) {
			glcpp_error(& @@1, parser, "#version must appear on the first line");
		}
		_glcpp_parser_handle_version_declaration(parser, $2, $3, true);
	}
|	HASH NEWLINE {
		glcpp_parser_resolve_implicit_version(parser);
d346 1
d1151 1
a1151 1
glcpp_parser_create (const struct gl_extensions *extensions, gl_api api)
d1154 1
a1166 1
        parser->commented_newlines = 0;
a1178 4
        parser->extensions = extensions;
        parser->api = api;
        parser->version_resolved = false;

d1184 70
d1794 2
a1795 16
	/* Section 3.3 (Preprocessor) of the GLSL 1.30 spec (and later) and
	 * the GLSL ES spec (all versions) say:
	 *
	 *     "All macro names containing two consecutive underscores ( __ )
	 *     are reserved for future use as predefined macro names. All
	 *     macro names prefixed with "GL_" ("GL" followed by a single
	 *     underscore) are also reserved."
	 *
	 * The intention is that names containing __ are reserved for internal
	 * use by the implementation, and names prefixed with GL_ are reserved
	 * for use by Khronos.  Since every extension adds a name prefixed
	 * with GL_ (i.e., the name of the extension), that should be an
	 * error.  Names simply containing __ are dangerous to use, but should
	 * be allowed.
	 *
	 * A future version of the GLSL specification will clarify this.
d1798 1
a1798 3
		glcpp_warning(loc, parser,
			      "Macro names containing \"__\" are reserved "
			      "for use by the implementation.\n");
a2011 1
	node->has_else = false;
d2050 1
a2050 2
                                         const char *es_identifier,
                                         bool explicitly_set)
d2052 5
a2056 7
	const struct gl_extensions *extensions = parser->extensions;

	if (parser->version_resolved)
		return;

	parser->version_resolved = true;

d2059 9
a2067 98
	parser->is_gles = (version == 100) ||
			   (es_identifier &&
			    (strcmp(es_identifier, "es") == 0));

	/* Add pre-defined macros. */
	if (parser->is_gles) {
	   add_builtin_define(parser, "GL_ES", 1);
           add_builtin_define(parser, "GL_EXT_separate_shader_objects", 1);

	   if (extensions != NULL) {
	      if (extensions->OES_EGL_image_external)
	         add_builtin_define(parser, "GL_OES_EGL_image_external", 1);
	   }
	} else {
	   add_builtin_define(parser, "GL_ARB_draw_buffers", 1);
           add_builtin_define(parser, "GL_ARB_separate_shader_objects", 1);
	   add_builtin_define(parser, "GL_ARB_texture_rectangle", 1);
           add_builtin_define(parser, "GL_AMD_shader_trinary_minmax", 1);


	   if (extensions != NULL) {
	      if (extensions->EXT_texture_array)
	         add_builtin_define(parser, "GL_EXT_texture_array", 1);

	      if (extensions->ARB_arrays_of_arrays)
	          add_builtin_define(parser, "GL_ARB_arrays_of_arrays", 1);

	      if (extensions->ARB_fragment_coord_conventions)
	         add_builtin_define(parser, "GL_ARB_fragment_coord_conventions",
				    1);

	      if (extensions->ARB_explicit_attrib_location)
	         add_builtin_define(parser, "GL_ARB_explicit_attrib_location", 1);

	      if (extensions->ARB_shader_texture_lod)
	         add_builtin_define(parser, "GL_ARB_shader_texture_lod", 1);

	      if (extensions->ARB_draw_instanced)
	         add_builtin_define(parser, "GL_ARB_draw_instanced", 1);

	      if (extensions->ARB_conservative_depth) {
	         add_builtin_define(parser, "GL_AMD_conservative_depth", 1);
	         add_builtin_define(parser, "GL_ARB_conservative_depth", 1);
	      }

	      if (extensions->ARB_shader_bit_encoding)
	         add_builtin_define(parser, "GL_ARB_shader_bit_encoding", 1);

	      if (extensions->ARB_uniform_buffer_object)
	         add_builtin_define(parser, "GL_ARB_uniform_buffer_object", 1);

	      if (extensions->ARB_texture_cube_map_array)
	         add_builtin_define(parser, "GL_ARB_texture_cube_map_array", 1);

	      if (extensions->ARB_shading_language_packing)
	         add_builtin_define(parser, "GL_ARB_shading_language_packing", 1);

	      if (extensions->ARB_texture_multisample)
	         add_builtin_define(parser, "GL_ARB_texture_multisample", 1);

	      if (extensions->ARB_texture_query_levels)
	         add_builtin_define(parser, "GL_ARB_texture_query_levels", 1);

	      if (extensions->ARB_texture_query_lod)
	         add_builtin_define(parser, "GL_ARB_texture_query_lod", 1);

	      if (extensions->ARB_gpu_shader5)
	         add_builtin_define(parser, "GL_ARB_gpu_shader5", 1);

	      if (extensions->AMD_vertex_shader_layer)
	         add_builtin_define(parser, "GL_AMD_vertex_shader_layer", 1);

	      if (extensions->ARB_shading_language_420pack)
	         add_builtin_define(parser, "GL_ARB_shading_language_420pack", 1);

	      if (extensions->ARB_sample_shading)
	         add_builtin_define(parser, "GL_ARB_sample_shading", 1);

	      if (extensions->ARB_texture_gather)
	         add_builtin_define(parser, "GL_ARB_texture_gather", 1);

	      if (extensions->ARB_shader_atomic_counters)
	         add_builtin_define(parser, "GL_ARB_shader_atomic_counters", 1);

	      if (extensions->ARB_viewport_array)
	         add_builtin_define(parser, "GL_ARB_viewport_array", 1);

              if (extensions->ARB_compute_shader)
                 add_builtin_define(parser, "GL_ARB_compute_shader", 1);

	      if (extensions->ARB_shader_image_load_store)
	         add_builtin_define(parser, "GL_ARB_shader_image_load_store", 1);
	   }
	}

	if (extensions != NULL) {
	   if (extensions->EXT_shader_integer_mix)
	      add_builtin_define(parser, "GL_EXT_shader_integer_mix", 1);
d2081 4
a2084 23
	if (explicitly_set) {
	   ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length,
					 "#version %" PRIiMAX "%s%s", version,
					 es_identifier ? " " : "",
					 es_identifier ? es_identifier : "");
	}
}

/* GLSL version if no version is explicitly specified. */
#define IMPLICIT_GLSL_VERSION 110

/* GLSL ES version if no version is explicitly specified. */
#define IMPLICIT_GLSL_ES_VERSION 100

void
glcpp_parser_resolve_implicit_version(glcpp_parser_t *parser)
{
	int language_version = parser->api == API_OPENGLES2 ?
			       IMPLICIT_GLSL_ES_VERSION :
			       IMPLICIT_GLSL_VERSION;

	_glcpp_parser_handle_version_declaration(parser, language_version,
						 NULL, false);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a59 3
static const char *
_string_list_has_duplicate (string_list_t *list);

a107 5
typedef enum {
	EXPANSION_MODE_IGNORE_DEFINED,
	EXPANSION_MODE_EVALUATE_DEFINED
} expansion_mode_t;

d114 1
a114 2
				   token_list_t *list,
				   expansion_mode_t mode);
d119 1
a119 2
				 token_list_t *list,
				 expansion_mode_t mode);
d167 1
a167 5

	/* We use HASH_TOKEN, DEFINE_TOKEN and VERSION_TOKEN (as opposed to
         * HASH, DEFINE, and VERSION) to avoid conflicts with other symbols,
         * (such as the <HASH> and <DEFINE> start conditions in the lexer). */
%token DEFINED ELIF_EXPANDED HASH_TOKEN DEFINE_TOKEN FUNC_IDENTIFIER OBJ_IDENTIFIER ELIF ELSE ENDIF ERROR_TOKEN IF IFDEF IFNDEF LINE PRAGMA UNDEF VERSION_TOKEN GARBAGE IDENTIFIER IF_EXPANDED INTEGER INTEGER_STRING LINE_EXPANDED NEWLINE OTHER PLACEHOLDER SPACE PLUS_PLUS MINUS_MINUS
d169 2
a170 3
%type <ival> INTEGER operator SPACE integer_constant
%type <expression_value> expression
%type <str> IDENTIFIER FUNC_IDENTIFIER OBJ_IDENTIFIER INTEGER_STRING OTHER ERROR_TOKEN PRAGMA
d172 2
a173 2
%type <token> preprocessing_token
%type <token_list> pp_tokens replacement_list text_line
a185 2
%debug

d194 14
a207 2
	control_line
|	SPACE control_line
d214 1
d219 1
a219 3
		if (parser->is_gles && $2.undefined_macro)
			glcpp_error(& @@1, parser, "undefined macro %s in expression (illegal in GLES)", $2.undefined_macro);
		_glcpp_parser_skip_stack_push_if (parser, & @@1, $2.value);
d222 1
a222 3
		if (parser->is_gles && $2.undefined_macro)
			glcpp_error(& @@1, parser, "undefined macro %s in expression (illegal in GLES)", $2.undefined_macro);
		_glcpp_parser_skip_stack_change_if (parser, & @@1, "elif", $2.value);
d257 1
a257 20
	control_line_success {
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "\n");
	}
|	control_line_error
|	HASH_TOKEN LINE {
		glcpp_parser_resolve_implicit_version(parser);
	} pp_tokens NEWLINE {

		if (parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			_glcpp_parser_expand_and_lex_from (parser,
							   LINE_EXPANDED, $4,
							   EXPANSION_MODE_IGNORE_DEFINED);
		}
	}
;

control_line_success:
	HASH_TOKEN DEFINE_TOKEN {
d260 1
a260 1
|	HASH_TOKEN UNDEF {
d263 1
a263 8
		macro_t *macro;
		if (strcmp("__LINE__", $4) == 0
		    || strcmp("__FILE__", $4) == 0
		    || strcmp("__VERSION__", $4) == 0)
			glcpp_error(& @@1, parser, "Built-in (pre-defined)"
				    " macro names can not be undefined.");

		macro = hash_table_find (parser->defines, $4);
d265 1
a265 1
			hash_table_remove (parser->defines, $4);
d268 1
a268 1
		ralloc_free ($4);
d270 1
a270 1
|	HASH_TOKEN IF {
d272 1
a272 1
	} pp_tokens NEWLINE {
d284 1
a284 2
							   IF_EXPANDED, $4,
							   EXPANSION_MODE_EVALUATE_DEFINED);
d292 1
a292 1
|	HASH_TOKEN IF NEWLINE {
d302 1
a302 1
|	HASH_TOKEN IFDEF {
d305 2
a306 2
		macro_t *macro = hash_table_find (parser->defines, $4);
		ralloc_free ($4);
d309 1
a309 1
|	HASH_TOKEN IFNDEF {
d312 3
a314 3
		macro_t *macro = hash_table_find (parser->defines, $4);
		ralloc_free ($4);
		_glcpp_parser_skip_stack_push_if (parser, & @@3, macro == NULL);
d316 1
a316 1
|	HASH_TOKEN ELIF pp_tokens NEWLINE {
d328 1
a328 2
							   ELIF_EXPANDED, $3,
							   EXPANSION_MODE_EVALUATE_DEFINED);
d341 1
a341 1
|	HASH_TOKEN ELIF NEWLINE {
d361 1
a361 1
|	HASH_TOKEN ELSE { parser->lexing_directive = 1; } NEWLINE {
d373 2
a374 2
	}
|	HASH_TOKEN ENDIF {
d377 1
a377 1
|	HASH_TOKEN VERSION_TOKEN integer_constant NEWLINE {
d381 1
a381 1
		_glcpp_parser_handle_version_declaration(parser, $3, NULL, true);
d383 1
a383 1
|	HASH_TOKEN VERSION_TOKEN integer_constant IDENTIFIER NEWLINE {
d387 1
a387 1
		_glcpp_parser_handle_version_declaration(parser, $3, $4, true);
d389 1
a389 1
|	HASH_TOKEN NEWLINE {
a391 15
|	HASH_TOKEN PRAGMA NEWLINE {
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "#%s", $2);
	}
;

control_line_error:
	HASH_TOKEN ERROR_TOKEN NEWLINE {
		glcpp_error(& @@1, parser, "#%s", $2);
	}
|	HASH_TOKEN DEFINE_TOKEN NEWLINE {
		glcpp_error (& @@1, parser, "#define without macro name");
	}
|	HASH_TOKEN GARBAGE pp_tokens NEWLINE  {
		glcpp_error (& @@1, parser, "Illegal non-directive after #");
	}
d409 1
a409 4
	integer_constant {
		$$.value = $1;
		$$.undefined_macro = NULL;
	}
a410 1
		$$.value = 0;
d412 2
a413 3
			$$.undefined_macro = ralloc_strdup (parser, $1);
		else
			$$.undefined_macro = NULL;
d416 1
a416 9
		$$.value = $1.value || $3.value;

		/* Short-circuit: Only flag undefined from right side
		 * if left side evaluates to false.
		 */
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else if (! $1.value)
			$$.undefined_macro = $3.undefined_macro;
d419 1
a419 9
		$$.value = $1.value && $3.value;

		/* Short-circuit: Only flag undefined from right-side
		 * if left side evaluates to true.
		 */
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else if ($1.value)
			$$.undefined_macro = $3.undefined_macro;
d422 1
a422 5
		$$.value = $1.value | $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d425 1
a425 5
		$$.value = $1.value ^ $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d428 1
a428 5
		$$.value = $1.value & $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d431 1
a431 5
		$$.value = $1.value != $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d434 1
a434 5
		$$.value = $1.value == $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d437 1
a437 5
		$$.value = $1.value >= $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d440 1
a440 5
		$$.value = $1.value <= $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d443 1
a443 5
		$$.value = $1.value > $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d446 1
a446 5
		$$.value = $1.value < $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d449 1
a449 5
		$$.value = $1.value >> $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d452 1
a452 5
		$$.value = $1.value << $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d455 1
a455 5
		$$.value = $1.value - $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d458 1
a458 5
		$$.value = $1.value + $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d461 1
a461 1
		if ($3.value == 0) {
d465 1
a465 1
			$$.value = $1.value % $3.value;
a466 4
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d469 1
a469 1
		if ($3.value == 0) {
d473 1
a473 1
			$$.value = $1.value / $3.value;
a474 4
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d477 1
a477 5
		$$.value = $1.value * $3.value;
		if ($1.undefined_macro)
			$$.undefined_macro = $1.undefined_macro;
                else
			$$.undefined_macro = $3.undefined_macro;
d480 1
a480 2
		$$.value = ! $2.value;
		$$.undefined_macro = $2.undefined_macro;
d483 1
a483 2
		$$.value = ~ $2.value;
		$$.undefined_macro = $2.undefined_macro;
d486 1
a486 2
		$$.value = - $2.value;
		$$.undefined_macro = $2.undefined_macro;
d489 1
a489 2
		$$.value = + $2.value;
		$$.undefined_macro = $2.undefined_macro;
d514 6
d528 26
a553 1
		glcpp_error(&@@1, parser, "extra tokens at end of directive");
a581 4
|	DEFINED {
		$$ = _token_create_ival (parser, DEFINED, DEFINED);
		$$->location = yylloc;
	}
a623 2
|	PLUS_PLUS		{ $$ = PLUS_PLUS; }
|	MINUS_MINUS		{ $$ = MINUS_MINUS; }
a678 19
/* Return duplicate string in list (if any), NULL otherwise. */
const char *
_string_list_has_duplicate (string_list_t *list)
{
	string_node_t *node, *dup;

	if (list == NULL)
		return NULL;

	for (node = list->head; node; node = node->next) {
		for (dup = node->next; dup; dup = dup->next) {
			if (strcmp (node->str, dup->str) == 0)
				return node->str;
		}
	}

	return NULL;
}

d936 8
a943 10
		/* Make sure whitespace appears in the same places in both.
		 * It need not be exactly the same amount of whitespace,
		 * though.
		 */
		if (node_a->token->type == SPACE
		    && node_b->token->type == SPACE) {
			while (node_a->token->type == SPACE)
				node_a = node_a->next;
			while (node_b->token->type == SPACE)
				node_b = node_b->next;
d1023 2
a1024 8
        case PLUS_PLUS:
		ralloc_asprintf_rewrite_tail (out, len, "++");
		break;
        case MINUS_MINUS:
		ralloc_asprintf_rewrite_tail (out, len, "--");
		break;
	case DEFINED:
		ralloc_asprintf_rewrite_tail (out, len, "defined");
a1030 1

d1206 1
a1206 1
	parser->lexing_directive = 0;
a1207 3
	parser->last_token_was_newline = 0;
	parser->last_token_was_space = 0;
	parser->first_non_space_token_this_line = 1;
a1213 1
	parser->skipping = 0;
a1358 124
/* Evaluate a DEFINED token node (based on subsequent tokens in the list).
 *
 * Note: This function must only be called when "node" is a DEFINED token,
 * (and will abort with an assertion failure otherwise).
 *
 * If "node" is followed, (ignoring any SPACE tokens), by an IDENTIFIER token
 * (optionally preceded and followed by '(' and ')' tokens) then the following
 * occurs:
 *
 *	If the identifier is a defined macro, this function returns 1.
 *
 *	If the identifier is not a defined macro, this function returns 0.
 *
 *	In either case, *last will be updated to the last node in the list
 *	consumed by the evaluation, (either the token of the identifier or the
 *	token of the closing parenthesis).
 *
 * In all other cases, (such as "node is the final node of the list", or
 * "missing closing parenthesis", etc.), this function generates a
 * preprocessor error, returns -1 and *last will not be set.
 */
static int
_glcpp_parser_evaluate_defined (glcpp_parser_t *parser,
				token_node_t *node,
				token_node_t **last)
{
	token_node_t *argument, *defined = node;

	assert (node->token->type == DEFINED);

	node = node->next;

	/* Ignore whitespace after DEFINED token. */
	while (node && node->token->type == SPACE)
		node = node->next;

	if (node == NULL)
		goto FAIL;

	if (node->token->type == IDENTIFIER || node->token->type == OTHER) {
		argument = node;
	} else if (node->token->type == '(') {
		node = node->next;

		/* Ignore whitespace after '(' token. */
		while (node && node->token->type == SPACE)
			node = node->next;

		if (node == NULL || (node->token->type != IDENTIFIER &&
				     node->token->type != OTHER))
		{
			goto FAIL;
		}

		argument = node;

		node = node->next;

		/* Ignore whitespace after identifier, before ')' token. */
		while (node && node->token->type == SPACE)
			node = node->next;

		if (node == NULL || node->token->type != ')')
			goto FAIL;
	} else {
		goto FAIL;
	}

	*last = node;

	return hash_table_find (parser->defines,
				argument->token->value.str) ? 1 : 0;

FAIL:
	glcpp_error (&defined->token->location, parser,
		     "\"defined\" not followed by an identifier");
	return -1;
}

/* Evaluate all DEFINED nodes in a given list, modifying the list in place.
 */
static void
_glcpp_parser_evaluate_defined_in_list (glcpp_parser_t *parser,
					token_list_t *list)
{
	token_node_t *node, *node_prev, *replacement, *last = NULL;
	int value;

	if (list == NULL)
		return;

	node_prev = NULL;
	node = list->head;

	while (node) {

		if (node->token->type != DEFINED)
			goto NEXT;

		value = _glcpp_parser_evaluate_defined (parser, node, &last);
		if (value == -1)
			goto NEXT;

		replacement = ralloc (list, token_node_t);
		replacement->token = _token_create_ival (list, INTEGER, value);

		/* Splice replacement node into list, replacing from "node"
		 * through "last". */
		if (node_prev)
			node_prev->next = replacement;
		else
			list->head = replacement;
		replacement->next = last->next;
		if (last == list->tail)
			list->tail = replacement;

		node = replacement;

	NEXT:
		node_prev = node;
		node = node->next;
	}
}

a1362 3
 *
 * See the documentation of _glcpp_parser_expand_token_list for a description
 * of the "mode" parameter.
d1367 1
a1367 2
				   token_list_t *list,
				   expansion_mode_t mode)
d1375 1
a1375 1
	_glcpp_parser_expand_token_list (parser, list, mode);
a1437 3
 *
 * See the documentation of _glcpp_parser_expand_token_list for a description
 * of the "mode" parameter.
d1442 2
a1443 2
			       token_node_t **last,
			       expansion_mode_t mode)
d1512 1
a1512 2
								 expanded_argument,
								 mode);
a1551 3
 *
 * See the documentation of _glcpp_parser_expand_token_list for a description
 * of the "mode" parameter.
d1556 1
a1556 2
			   token_node_t **last,
			   expansion_mode_t mode)
d1564 8
d1623 1
a1623 1
	return _glcpp_parser_expand_function (parser, node, last, mode);
d1682 1
a1682 17
 * 'list' itself.
 *
 * The "mode" argument controls the handling of any DEFINED tokens that
 * result from expansion as follows:
 *
 *	EXPANSION_MODE_IGNORE_DEFINED: Any resulting DEFINED tokens will be
 *		left in the final list, unevaluated. This is the correct mode
 *		for expanding any list in any context other than a
 *		preprocessor conditional, (#if or #elif).
 *
 *	EXPANSION_MODE_EVALUATE_DEFINED: Any resulting DEFINED tokens will be
 *		evaluated to 0 or 1 tokens depending on whether the following
 *		token is the name of a defined macro. If the DEFINED token is
 *		not followed by an (optionally parenthesized) identifier, then
 *		an error will be generated. This the correct mode for
 *		expanding any list in the context of a preprocessor
 *		conditional, (#if or #elif).
d1686 1
a1686 2
				 token_list_t *list,
				 expansion_mode_t mode)
a1700 3
	if (mode == EXPANSION_MODE_EVALUATE_DEFINED)
		_glcpp_parser_evaluate_defined_in_list (parser, list);

d1706 1
a1706 1
		expansion = _glcpp_parser_expand_node (parser, node, &last, mode);
a1709 5
			if (mode == EXPANSION_MODE_EVALUATE_DEFINED) {
				_glcpp_parser_evaluate_defined_in_list (parser,
									expansion);
			}

d1762 1
a1762 1
	_glcpp_parser_expand_token_list (parser, list, EXPANSION_MODE_IGNORE_DEFINED);
a1822 4
	/* We define pre-defined macros before we've started parsing the
         * actual file. So if there's no location defined yet, that's what
         * were doing and we don't want to generate an error for using the
         * reserved names. */
a1854 1
	const char *dup;
a1857 6
        /* Check for any duplicate parameter names. */
	if ((dup = _string_list_has_duplicate (parameters)) != NULL) {
		glcpp_error (loc, parser, "Duplicate macro parameter \"%s\"",
			     dup);
	}

d1920 5
a1924 5
		else if (ret == DEFINE_TOKEN ||
			 ret == UNDEF || ret == IF ||
			 ret == IFDEF || ret == IFNDEF ||
			 ret == ELIF || ret == ELSE ||
			 ret == ENDIF || ret == HASH_TOKEN)
d2017 1
a2017 1
		glcpp_error (loc, parser, "#%s without #if\n", type);
a2069 2
              if (extensions->OES_standard_derivatives)
                 add_builtin_define(parser, "GL_OES_standard_derivatives", 1);
a2088 3
              if (extensions->ARB_fragment_layer_viewport)
                 add_builtin_define(parser, "GL_ARB_fragment_layer_viewport", 1);

a2091 3
	      if (extensions->ARB_explicit_uniform_location)
	         add_builtin_define(parser, "GL_ARB_explicit_uniform_location", 1);

a2129 3
	      if (extensions->AMD_vertex_shader_viewport_index)
	         add_builtin_define(parser, "GL_AMD_vertex_shader_viewport_index", 1);

a2149 3

              if (extensions->ARB_derivative_control)
                 add_builtin_define(parser, "GL_ARB_derivative_control", 1);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d60 3
d111 5
d122 2
a123 1
				   token_list_t *list);
d128 2
a129 1
				 token_list_t *list);
d177 5
a181 1
%token COMMA_FINAL DEFINED ELIF_EXPANDED HASH HASH_DEFINE FUNC_IDENTIFIER OBJ_IDENTIFIER HASH_ELIF HASH_ELSE HASH_ENDIF HASH_IF HASH_IFDEF HASH_IFNDEF HASH_LINE HASH_UNDEF HASH_VERSION IDENTIFIER IF_EXPANDED INTEGER INTEGER_STRING LINE_EXPANDED NEWLINE OTHER PLACEHOLDER SPACE
d183 3
a185 2
%type <ival> expression INTEGER operator SPACE integer_constant
%type <str> IDENTIFIER FUNC_IDENTIFIER OBJ_IDENTIFIER INTEGER_STRING OTHER
d187 2
a188 2
%type <token> preprocessing_token conditional_token
%type <token_list> pp_tokens replacement_list text_line conditional_tokens
d201 2
d211 2
a212 14
	control_line {
		ralloc_asprintf_rewrite_tail (&parser->output, &parser->output_length, "\n");
	}
|	HASH_LINE {
		glcpp_parser_resolve_implicit_version(parser);
	} pp_tokens NEWLINE {

		if (parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			_glcpp_parser_expand_and_lex_from (parser,
							   LINE_EXPANDED, $3);
		}
	}
a218 1
|	HASH non_directive
d223 3
a225 1
		_glcpp_parser_skip_stack_push_if (parser, & @@1, $2);
d228 3
a230 1
		_glcpp_parser_skip_stack_change_if (parser, & @@1, "elif", $2);
d265 20
a284 1
	HASH_DEFINE {
d287 1
a287 1
|	HASH_UNDEF {
d290 8
a297 1
		macro_t *macro = hash_table_find (parser->defines, $3);
d299 1
a299 1
			hash_table_remove (parser->defines, $3);
d302 1
a302 1
		ralloc_free ($3);
d304 1
a304 1
|	HASH_IF {
d306 1
a306 1
	} conditional_tokens NEWLINE {
d318 2
a319 1
							   IF_EXPANDED, $3);
d327 1
a327 1
|	HASH_IF NEWLINE {
d337 1
a337 1
|	HASH_IFDEF {
d340 2
a341 2
		macro_t *macro = hash_table_find (parser->defines, $3);
		ralloc_free ($3);
d344 1
a344 1
|	HASH_IFNDEF {
d347 3
a349 3
		macro_t *macro = hash_table_find (parser->defines, $3);
		ralloc_free ($3);
		_glcpp_parser_skip_stack_push_if (parser, & @@2, macro == NULL);
d351 1
a351 1
|	HASH_ELIF conditional_tokens NEWLINE {
d363 2
a364 1
							   ELIF_EXPANDED, $2);
d377 1
a377 1
|	HASH_ELIF NEWLINE {
d397 1
a397 1
|	HASH_ELSE {
d409 2
a410 2
	} NEWLINE
|	HASH_ENDIF {
d413 1
a413 1
|	HASH_VERSION integer_constant NEWLINE {
d417 1
a417 1
		_glcpp_parser_handle_version_declaration(parser, $2, NULL, true);
d419 1
a419 1
|	HASH_VERSION integer_constant IDENTIFIER NEWLINE {
d423 1
a423 1
		_glcpp_parser_handle_version_declaration(parser, $2, $3, true);
d425 1
a425 1
|	HASH NEWLINE {
d428 15
d460 4
a463 1
	integer_constant
d465 1
d467 3
a469 2
			glcpp_error(& @@1, parser, "undefined macro %s in expression (illegal in GLES)", $1);
		$$ = 0;
d472 9
a480 1
		$$ = $1 || $3;
d483 9
a491 1
		$$ = $1 && $3;
d494 5
a498 1
		$$ = $1 | $3;
d501 5
a505 1
		$$ = $1 ^ $3;
d508 5
a512 1
		$$ = $1 & $3;
d515 5
a519 1
		$$ = $1 != $3;
d522 5
a526 1
		$$ = $1 == $3;
d529 5
a533 1
		$$ = $1 >= $3;
d536 5
a540 1
		$$ = $1 <= $3;
d543 5
a547 1
		$$ = $1 > $3;
d550 5
a554 1
		$$ = $1 < $3;
d557 5
a561 1
		$$ = $1 >> $3;
d564 5
a568 1
		$$ = $1 << $3;
d571 5
a575 1
		$$ = $1 - $3;
d578 5
a582 1
		$$ = $1 + $3;
d585 1
a585 1
		if ($3 == 0) {
d589 1
a589 1
			$$ = $1 % $3;
d591 4
d597 1
a597 1
		if ($3 == 0) {
d601 1
a601 1
			$$ = $1 / $3;
d603 4
d609 5
a613 1
		$$ = $1 * $3;
d616 2
a617 1
		$$ = ! $2;
d620 2
a621 1
		$$ = ~ $2;
d624 2
a625 1
		$$ = - $2;
d628 2
a629 1
		$$ = + $2;
a653 6
non_directive:
	pp_tokens NEWLINE {
		yyerror (& @@1, parser, "Invalid tokens after #");
	}
;

d662 1
a662 26
		glcpp_warning(&@@1, parser, "extra tokens at end of directive");
	}
;

conditional_token:
	/* Handle "defined" operator */
	DEFINED IDENTIFIER {
		int v = hash_table_find (parser->defines, $2) ? 1 : 0;
		$$ = _token_create_ival (parser, INTEGER, v);
	}
|	DEFINED '(' IDENTIFIER ')' {
		int v = hash_table_find (parser->defines, $3) ? 1 : 0;
		$$ = _token_create_ival (parser, INTEGER, v);
	}
|	preprocessing_token
;

conditional_tokens:
	/* Exactly the same as pp_tokens, but using conditional_token */
	conditional_token {
		$$ = _token_list_create (parser);
		_token_list_append ($$, $1);
	}
|	conditional_tokens conditional_token {
		$$ = $1;
		_token_list_append ($$, $2);
d691 4
d737 2
d794 19
d1070 10
a1079 8

		if (node_a->token->type == SPACE) {
			node_a = node_a->next;
			continue;
		}

		if (node_b->token->type == SPACE) {
			node_b = node_b->next;
d1159 8
a1166 2
	case COMMA_FINAL:
		ralloc_asprintf_rewrite_tail (out, len, ",");
d1173 1
d1349 1
a1349 1
	parser->lexing_if = 0;
d1351 3
d1360 1
d1506 124
d1634 3
d1641 2
a1642 1
				   token_list_t *list)
d1650 1
a1650 1
	_glcpp_parser_expand_token_list (parser, list);
d1713 3
d1720 2
a1721 2
			       token_node_t **last)
			       
d1790 2
a1791 1
								 expanded_argument);
d1831 3
d1838 2
a1839 1
			   token_node_t **last)
a1846 8
		/* We change any COMMA into a COMMA_FINAL to prevent
		 * it being mistaken for an argument separator
		 * later. */
		if (token->type == ',') {
			token->type = COMMA_FINAL;
			token->value.ival = COMMA_FINAL;
		}

d1898 1
a1898 1
	return _glcpp_parser_expand_function (parser, node, last);
d1957 17
a1973 1
 * 'list' itself;
d1977 2
a1978 1
				 token_list_t *list)
d1993 3
d2001 1
a2001 1
		expansion = _glcpp_parser_expand_node (parser, node, &last);
d2005 5
d2062 1
a2062 1
	_glcpp_parser_expand_token_list (parser, list);
d2123 4
d2159 1
d2163 6
d2231 5
a2235 5
		else if (ret == HASH_DEFINE ||
			   ret == HASH_UNDEF || ret == HASH_IF ||
			   ret == HASH_IFDEF || ret == HASH_IFNDEF ||
			   ret == HASH_ELIF || ret == HASH_ELSE ||
			   ret == HASH_ENDIF || ret == HASH)
d2328 1
a2328 1
		glcpp_error (loc, parser, "%s without #if\n", type);
d2381 2
d2402 3
d2408 3
d2449 3
d2472 3
@


