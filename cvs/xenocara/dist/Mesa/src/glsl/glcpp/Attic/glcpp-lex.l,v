head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.44;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.19;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.58;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.02.42;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.11;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.29;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.32;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.33;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.39;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@%{
/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "glcpp.h"
#include "glcpp-parse.h"

/* Flex annoyingly generates some functions without making them
 * static. Let's declare them here. */
int glcpp_get_column  (yyscan_t yyscanner);
void glcpp_set_column (int  column_no , yyscan_t yyscanner);

#ifdef _MSC_VER
#define YY_NO_UNISTD_H
#endif

#define YY_NO_INPUT

#define YY_USER_ACTION							\
	do {								\
		if (parser->has_new_line_number)			\
			yylineno = parser->new_line_number;		\
		if (parser->has_new_source_number)			\
			yylloc->source = parser->new_source_number;	\
		yylloc->first_column = yycolumn + 1;			\
		yylloc->first_line = yylloc->last_line = yylineno;	\
		yycolumn += yyleng;					\
		yylloc->last_column = yycolumn + 1;			\
		parser->has_new_line_number = 0;			\
		parser->has_new_source_number = 0;			\
 } while(0);

#define YY_USER_INIT			\
	do {				\
		yylineno = 1;		\
		yycolumn = 1;		\
		yylloc->source = 0;	\
	} while(0)
%}

%option bison-bridge bison-locations reentrant noyywrap
%option extra-type="glcpp_parser_t *"
%option prefix="glcpp_"
%option stack
%option never-interactive

%x DONE COMMENT UNREACHABLE SKIP DEFINE NEWLINE_CATCHUP

SPACE		[[:space:]]
NONSPACE	[^[:space:]]
NEWLINE		[\n]
HSPACE		[ \t]
HASH		^{HSPACE}*#{HSPACE}*
IDENTIFIER	[_a-zA-Z][_a-zA-Z0-9]*
PUNCTUATION	[][(){}.&*~!/%<>^|;,=+-]

/* The OTHER class is simply a catch-all for things that the CPP
parser just doesn't care about. Since flex regular expressions that
match longer strings take priority over those matching shorter
strings, we have to be careful to avoid OTHER matching and hiding
something that CPP does care about. So we simply exclude all
characters that appear in any other expressions. */

OTHER		[^][_#[:space:]#a-zA-Z0-9(){}.&*~!/%<>^|;,=+-]

DIGITS			[0-9][0-9]*
DECIMAL_INTEGER		[1-9][0-9]*[uU]?
OCTAL_INTEGER		0[0-7]*[uU]?
HEXADECIMAL_INTEGER	0[xX][0-9a-fA-F]+[uU]?

%%

	glcpp_parser_t *parser = yyextra;

	/* When we lex a multi-line comment, we replace it (as
	 * specified) with a single space. But if the comment spanned
	 * multiple lines, then subsequent parsing stages will not
	 * count correct line numbers. To avoid this problem we keep
	 * track of all newlines that were commented out by a
	 * multi-line comment, and we emit a NEWLINE token for each at
	 * the next legal opportunity, (which is when the lexer would
	 * be emitting a NEWLINE token anyway).
	 */
	if (YY_START == NEWLINE_CATCHUP) {
		if (parser->commented_newlines)
			parser->commented_newlines--;
		if (parser->commented_newlines == 0)
			BEGIN INITIAL;
		return NEWLINE;
	}

	/* The handling of the SKIP vs INITIAL start states requires
	 * some special handling. Typically, a lexer would change
	 * start states with statements like "BEGIN SKIP" within the
	 * lexer rules. We can't get away with that here, since we
	 * need the parser to actually evaluate expressions for
	 * directives like "#if".
	 *
	 * So, here, in code that will be executed on every call to
	 * the lexer,and before any rules, we examine the skip_stack
	 * as set by the parser to know whether to change from INITIAL
	 * to SKIP or from SKIP back to INITIAL.
	 *
	 * Three cases cause us to switch out of the SKIP state and
	 * back to the INITIAL state:
	 *
	 *	1. The top of the skip_stack is of type SKIP_NO_SKIP
	 *	   This means we're still evaluating some #if
	 *	   hierarchy, but we're on a branch of it where
	 *	   content should not be skipped (such as "#if 1" or
	 *	   "#else" or so).
	 *
	 *	2. The skip_stack is NULL meaning that we've reached
	 *	   the last #endif.
	 *
	 *	3. The lexing_if bit is set. This indicates that we
	 *	   are lexing the expression following an "#if" of
	 *	   "#elif". Even inside an "#if 0" we need to lex this
	 *	   expression so the parser can correctly update the
	 *	   skip_stack state.
	 */
	if (YY_START == INITIAL || YY_START == SKIP) {
		if (parser->lexing_if ||
		    parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			BEGIN INITIAL;
		} else {
			BEGIN SKIP;
		}
	}

	/* Single-line comments */
"//"[^\n]* {
}

	/* Multi-line comments */
"/*"                    { yy_push_state(COMMENT, yyscanner); }
<COMMENT>[^*\n]*
<COMMENT>[^*\n]*\n      { yylineno++; yycolumn = 0; parser->commented_newlines++; }
<COMMENT>"*"+[^*/\n]*
<COMMENT>"*"+[^*/\n]*\n { yylineno++; yycolumn = 0; parser->commented_newlines++; }
<COMMENT>"*"+"/"        {
	yy_pop_state(yyscanner);
	if (yyextra->space_tokens)
		return SPACE;
}

{HASH}version{HSPACE}+ {
	yylval->str = ralloc_strdup (yyextra, yytext);
	yyextra->space_tokens = 0;
	return HASH_VERSION;
}

	/* glcpp doesn't handle #extension, #version, or #pragma directives.
	 * Simply pass them through to the main compiler's lexer/parser. */
{HASH}(extension|pragma)[^\n]+ {
	if (parser->commented_newlines)
		BEGIN NEWLINE_CATCHUP;
	yylval->str = ralloc_strdup (yyextra, yytext);
	yylineno++;
	yycolumn = 0;
	return OTHER;
}

{HASH}line{HSPACE}+ {
	return HASH_LINE;
}

<SKIP,INITIAL>{
{HASH}ifdef {
	yyextra->lexing_if = 1;
	yyextra->space_tokens = 0;
	return HASH_IFDEF;
}

{HASH}ifndef {
	yyextra->lexing_if = 1;
	yyextra->space_tokens = 0;
	return HASH_IFNDEF;
}

{HASH}if/[^_a-zA-Z0-9] {
	yyextra->lexing_if = 1;
	yyextra->space_tokens = 0;
	return HASH_IF;
}

{HASH}elif/[^_a-zA-Z0-9] {
	yyextra->lexing_if = 1;
	yyextra->space_tokens = 0;
	return HASH_ELIF;
}

{HASH}else {
	yyextra->space_tokens = 0;
	return HASH_ELSE;
}

{HASH}endif {
	yyextra->space_tokens = 0;
	return HASH_ENDIF;
}
}

<SKIP>[^\n] {
	if (parser->commented_newlines)
		BEGIN NEWLINE_CATCHUP;
}

{HASH}error.* {
	char *p;
	for (p = yytext; !isalpha(p[0]); p++); /* skip "  #   " */
	p += 5; /* skip "error" */
	glcpp_error(yylloc, yyextra, "#error%s", p);
}

{HASH}define{HSPACE}+ {
	yyextra->space_tokens = 0;
	yy_push_state(DEFINE, yyscanner);
	return HASH_DEFINE;
}

<DEFINE>{IDENTIFIER}/"(" {
	yy_pop_state(yyscanner);
	yylval->str = ralloc_strdup (yyextra, yytext);
	return FUNC_IDENTIFIER;
}

<DEFINE>{IDENTIFIER} {
	yy_pop_state(yyscanner);
	yylval->str = ralloc_strdup (yyextra, yytext);
	return OBJ_IDENTIFIER;
}

{HASH}undef {
	yyextra->space_tokens = 0;
	return HASH_UNDEF;
}

{HASH} {
	yyextra->space_tokens = 0;
	return HASH;
}

{DECIMAL_INTEGER} {
	yylval->str = ralloc_strdup (yyextra, yytext);
	return INTEGER_STRING;
}

{OCTAL_INTEGER} {
	yylval->str = ralloc_strdup (yyextra, yytext);
	return INTEGER_STRING;
}

{HEXADECIMAL_INTEGER} {
	yylval->str = ralloc_strdup (yyextra, yytext);
	return INTEGER_STRING;
}

"<<"  {
	return LEFT_SHIFT;
}

">>" {
	return RIGHT_SHIFT;
}

"<=" {
	return LESS_OR_EQUAL;
}

">=" {
	return GREATER_OR_EQUAL;
}

"==" {
	return EQUAL;
}

"!=" {
	return NOT_EQUAL;
}

"&&" {
	return AND;
}

"||" {
	return OR;
}

"##" {
	if (parser->is_gles)
		glcpp_error(yylloc, yyextra, "Token pasting (##) is illegal in GLES");
	return PASTE;
}

"defined" {
	return DEFINED;
}

{IDENTIFIER} {
	yylval->str = ralloc_strdup (yyextra, yytext);
	return IDENTIFIER;
}

{PUNCTUATION} {
	return yytext[0];
}

{OTHER}+ {
	yylval->str = ralloc_strdup (yyextra, yytext);
	return OTHER;
}

{HSPACE} {
	if (yyextra->space_tokens) {
		return SPACE;
	}
}

<SKIP,INITIAL>\n {
	if (parser->commented_newlines) {
		BEGIN NEWLINE_CATCHUP;
	}
	yyextra->lexing_if = 0;
	yylineno++;
	yycolumn = 0;
	return NEWLINE;
}

	/* Handle missing newline at EOF. */
<INITIAL><<EOF>> {
	BEGIN DONE; /* Don't keep matching this rule forever. */
	yyextra->lexing_if = 0;
	return NEWLINE;
}

	/* We don't actually use the UNREACHABLE start condition. We
	only have this action here so that we can pretend to call some
	generated functions, (to avoid "defined but not used"
	warnings. */
<UNREACHABLE>. {
	unput('.');
	yy_top_state(yyextra);
}

%%

void
glcpp_lex_set_source_string(glcpp_parser_t *parser, const char *shader)
{
	yy_scan_string(shader, parser->scanner);
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d55 1
a55 1
	} while(0);
d60 1
a60 1
		yycolumn = 0;		\
a62 93

/* It's ugly to have macros that have return statements inside of
 * them, but flex-based lexer generation is all built around the
 * return statement.
 *
 * To mitigate the ugliness, we defer as much of the logic as possible
 * to an actual function, not a macro (see
 * glcpplex_update_state_per_token) and we make the word RETURN
 * prominent in all of the macros which may return.
 *
 * The most-commonly-used macro is RETURN_TOKEN which will perform all
 * necessary state updates based on the provided token,, then
 * conditionally return the token. It will not return a token if the
 * parser is currently skipping tokens, (such as within #if
 * 0...#else).
 *
 * The RETURN_TOKEN_NEVER_SKIP macro is a lower-level variant that
 * makes the token returning unconditional. This is needed for things
 * like #if and the tokens of its condition, (since these must be
 * evaluated by the parser even when otherwise skipping).
 *
 * Finally, RETURN_STRING_TOKEN is a simple convenience wrapper on top
 * of RETURN_TOKEN that performs a string copy of yytext before the
 * return.
 */
#define RETURN_TOKEN_NEVER_SKIP(token)					\
	do {								\
		if (glcpp_lex_update_state_per_token (parser, token))	\
			return token;					\
	} while (0)

#define RETURN_TOKEN(token)						\
	do {								\
		if (! parser->skipping) {				\
			RETURN_TOKEN_NEVER_SKIP(token);			\
		}							\
	} while(0)

#define RETURN_STRING_TOKEN(token)					\
	do {								\
		if (! parser->skipping) {				\
			yylval->str = ralloc_strdup (yyextra, yytext);	\
			RETURN_TOKEN_NEVER_SKIP (token);		\
		}							\
	} while(0)


/* Update all state necessary for each token being returned.
 *
 * Here we'll be tracking newlines and spaces so that the lexer can
 * alter its behavior as necessary, (for example, '#' has special
 * significance if it is the first non-whitespace, non-comment token
 * in a line, but does not otherwise).
 *
 * NOTE: If this function returns FALSE, then no token should be
 * returned at all. This is used to suprress duplicate SPACE tokens.
 */
static int
glcpp_lex_update_state_per_token (glcpp_parser_t *parser, int token)
{
	/* After the first non-space token in a line, we won't
	 * allow any '#' to introduce a directive. */
	if (token == NEWLINE) {
		parser->first_non_space_token_this_line = 1;
	} else if (token != SPACE) {
		parser->first_non_space_token_this_line = 0;
	}

	/* Track newlines just to know whether a newline needs
	 * to be inserted if end-of-file comes early. */
	if (token == NEWLINE) {
		parser->last_token_was_newline = 1;
	} else {
		parser->last_token_was_newline = 0;
	}

	/* Track spaces to avoid emitting multiple SPACE
	 * tokens in a row. */
	if (token == SPACE) {
		if (! parser->last_token_was_space) {
			parser->last_token_was_space = 1;
			return 1;
		} else {
			parser->last_token_was_space = 1;
			return 0;
		}
	} else {
		parser->last_token_was_space = 0;
		return 1;
	}
}


a69 1
%option warn nodefault
d71 1
a71 5
	/* Note: When adding any start conditions to this list, you must also
	 * update the "Internal compiler error" catch-all rule near the end of
	 * this file. */

%x COMMENT DEFINE DONE HASH NEWLINE_CATCHUP UNREACHABLE
d75 1
d77 1
a77 2
HASH		#
NEWLINE		(\r\n|\n\r|\r|\n)
a78 1
PP_NUMBER	[.]?[0-9]([._a-zA-Z0-9]|[eEpP][-+])*
d113 1
a113 1
		RETURN_TOKEN_NEVER_SKIP (NEWLINE);
d116 29
a144 28
	/* Set up the parser->skipping bit here before doing any lexing.
	 *
	 * This bit controls whether tokens are skipped, (as implemented by
         * RETURN_TOKEN), such as between "#if 0" and "#endif".
	 *
	 * The parser maintains a skip_stack indicating whether we should be
         * skipping, (and nested levels of #if/#ifdef/#ifndef/#endif) will
         * push and pop items from the stack.
	 *
	 * Here are the rules for determining whether we are skipping:
	 *
	 *	1. If the skip stack is NULL, we are outside of all #if blocks
	 *         and we are not skipping.
	 *
	 *	2. If the skip stack is non-NULL, the type of the top node in
	 *	   the stack determines whether to skip. A type of
	 *	   SKIP_NO_SKIP is used for blocks wheere we are emitting
	 *	   tokens, (such as between #if 1 and #endif, or after the
	 *	   #else of an #if 0, etc.).
	 *
	 *	3. The lexing_directive bit overrides the skip stack. This bit
	 *	   is set when we are actively lexing the expression for a
	 *	   pre-processor condition, (such as #if, #elif, or #else). In
	 *	   this case, even if otherwise skipping, we need to emit the
	 *	   tokens for this condition so that the parser can evaluate
	 *	   the expression. (For, #else, there's no expression, but we
	 *	   emit tokens so the parser can generate a nice error message
	 *	   if there are any tokens here).
d146 9
a154 7
	if (parser->skip_stack &&
	    parser->skip_stack->type != SKIP_NO_SKIP &&
	    ! parser->lexing_directive)
	{
		parser->skipping = 1;
	} else {
		parser->skipping = 0;
d158 1
a158 1
<INITIAL,DEFINE,HASH>"//"[^\r\n]* {
d162 5
a166 5
<INITIAL,DEFINE,HASH>"/*"   { yy_push_state(COMMENT, yyscanner); }
<COMMENT>[^*\r\n]*
<COMMENT>[^*\r\n]*{NEWLINE} { yylineno++; yycolumn = 0; parser->commented_newlines++; }
<COMMENT>"*"+[^*/\r\n]*
<COMMENT>"*"+[^*/\r\n]*{NEWLINE} { yylineno++; yycolumn = 0; parser->commented_newlines++; }
d169 2
a170 3
	/* In the <HASH> start condition, we don't want any SPACE token. */
	if (yyextra->space_tokens && YY_START != HASH)
		RETURN_TOKEN (SPACE);
d173 2
a174 17
{HASH} {

	/* If the '#' is the first non-whitespace, non-comment token on this
	 * line, then it introduces a directive, switch to the <HASH> start
	 * condition.
	 *
	 * Otherwise, this is just punctuation, so return the HASH_TOKEN
         * token. */
	if (parser->first_non_space_token_this_line) {
		BEGIN HASH;
	}

	RETURN_TOKEN_NEVER_SKIP (HASH_TOKEN);
}

<HASH>version{HSPACE}+ {
	BEGIN INITIAL;
d176 1
a176 13
	RETURN_STRING_TOKEN (VERSION_TOKEN);
}

	/* Swallow empty #pragma directives, (to avoid confusing the
	 * downstream compiler).
	 *
	 * Note: We use a simple regular expression for the lookahead
	 * here. Specifically, we cannot use the complete {NEWLINE} expression
	 * since it uses alternation and we've found that there's a flex bug
	 * where using alternation in the lookahead portion of a pattern
	 * triggers a buffer overrun. */
<HASH>pragma{HSPACE}*/[\r\n] {
	BEGIN INITIAL;
d181 7
a187 3
<HASH>(extension|pragma)[^\r\n]* {
	BEGIN INITIAL;
	RETURN_STRING_TOKEN (PRAGMA);
d190 2
a191 3
<HASH>line{HSPACE}+ {
	BEGIN INITIAL;
	RETURN_TOKEN (LINE);
d194 5
a198 3
<HASH>{NEWLINE} {
	BEGIN INITIAL;
	RETURN_TOKEN_NEVER_SKIP (NEWLINE);
d201 2
a202 5
	/* For the pre-processor directives, we return these tokens
	 * even when we are otherwise skipping. */
<HASH>ifdef {
	BEGIN INITIAL;
	yyextra->lexing_directive = 1;
d204 1
a204 1
	RETURN_TOKEN_NEVER_SKIP (IFDEF);
d207 2
a208 3
<HASH>ifndef {
	BEGIN INITIAL;
	yyextra->lexing_directive = 1;
d210 1
a210 1
	RETURN_TOKEN_NEVER_SKIP (IFNDEF);
d213 2
a214 3
<HASH>if/[^_a-zA-Z0-9] {
	BEGIN INITIAL;
	yyextra->lexing_directive = 1;
d216 1
a216 1
	RETURN_TOKEN_NEVER_SKIP (IF);
d219 1
a219 3
<HASH>elif/[^_a-zA-Z0-9] {
	BEGIN INITIAL;
	yyextra->lexing_directive = 1;
d221 1
a221 1
	RETURN_TOKEN_NEVER_SKIP (ELIF);
d224 1
a224 2
<HASH>else {
	BEGIN INITIAL;
d226 1
a226 1
	RETURN_TOKEN_NEVER_SKIP (ELSE);
a227 5

<HASH>endif {
	BEGIN INITIAL;
	yyextra->space_tokens = 0;
	RETURN_TOKEN_NEVER_SKIP (ENDIF);
d230 3
a232 3
<HASH>error[^\r\n]* {
	BEGIN INITIAL;
	RETURN_STRING_TOKEN (ERROR_TOKEN);
d235 5
a239 24
	/* After we see a "#define" we enter the <DEFINE> start state
	 * for the lexer. Within <DEFINE> we are looking for the first
	 * identifier and specifically checking whether the identifier
	 * is followed by a '(' or not, (to lex either a
	 * FUNC_IDENTIFIER or an OBJ_IDENITIFIER token).
	 *
	 * While in the <DEFINE> state we also need to explicitly
	 * handle a few other things that may appear before the
	 * identifier:
	 * 
	 * 	* Comments, (handled above with the main support for
	 * 	  comments).
	 *
	 *	* Whitespace (simply ignored)
	 *
	 *	* Anything else, (not an identifier, not a comment,
	 *	  and not whitespace). This will generate an error.
	 */
<HASH>define{HSPACE}* {
	if (! parser->skipping) {
		BEGIN DEFINE;
		yyextra->space_tokens = 0;
		RETURN_TOKEN (DEFINE_TOKEN);
	}
d242 1
a242 2
<HASH>undef {
	BEGIN INITIAL;
d244 2
a245 13
	RETURN_TOKEN (UNDEF);
}

<HASH>{HSPACE}+ {
	/* Nothing to do here. Importantly, don't leave the <HASH>
	 * start condition, since it's legal to have space between the
	 * '#' and the directive.. */
}

	/* This will catch any non-directive garbage after a HASH */
<HASH>{NONSPACE} {
	BEGIN INITIAL;
	RETURN_TOKEN (GARBAGE);
a247 1
	/* An identifier immediately followed by '(' */
d249 3
a251 2
	BEGIN INITIAL;
	RETURN_STRING_TOKEN (FUNC_IDENTIFIER);
a253 1
	/* An identifier not immediately followed by '(' */
d255 3
a257 2
	BEGIN INITIAL;
	RETURN_STRING_TOKEN (OBJ_IDENTIFIER);
d260 3
a262 3
	/* Whitespace */
<DEFINE>{HSPACE}+ {
	/* Just ignore it. Nothing to do here. */
d265 3
a267 13
	/* '/' not followed by '*', so not a comment. This is an error. */
<DEFINE>[/][^*]{NONSPACE}* {
	BEGIN INITIAL;
	glcpp_error(yylloc, yyextra, "#define followed by a non-identifier: %s", yytext);
	RETURN_STRING_TOKEN (INTEGER_STRING);
}

	/* A character that can't start an identifier, comment, or
	 * space. This is an error. */
<DEFINE>[^_a-zA-Z/[:space:]]{NONSPACE}* {
	BEGIN INITIAL;
	glcpp_error(yylloc, yyextra, "#define followed by a non-identifier: %s", yytext);
	RETURN_STRING_TOKEN (INTEGER_STRING);
d271 2
a272 1
	RETURN_STRING_TOKEN (INTEGER_STRING);
d276 2
a277 1
	RETURN_STRING_TOKEN (INTEGER_STRING);
d281 2
a282 1
	RETURN_STRING_TOKEN (INTEGER_STRING);
d286 1
a286 1
	RETURN_TOKEN (LEFT_SHIFT);
d290 1
a290 1
	RETURN_TOKEN (RIGHT_SHIFT);
d294 1
a294 1
	RETURN_TOKEN (LESS_OR_EQUAL);
d298 1
a298 1
	RETURN_TOKEN (GREATER_OR_EQUAL);
d302 1
a302 1
	RETURN_TOKEN (EQUAL);
d306 1
a306 1
	RETURN_TOKEN (NOT_EQUAL);
d310 1
a310 1
	RETURN_TOKEN (AND);
d314 1
a314 9
	RETURN_TOKEN (OR);
}

"++" {
	RETURN_TOKEN (PLUS_PLUS);
}

"--" {
	RETURN_TOKEN (MINUS_MINUS);
d318 3
a320 5
	if (! parser->skipping) {
		if (parser->is_gles)
			glcpp_error(yylloc, yyextra, "Token pasting (##) is illegal in GLES");
		RETURN_TOKEN (PASTE);
	}
d324 1
a324 1
	RETURN_TOKEN (DEFINED);
d328 2
a329 5
	RETURN_STRING_TOKEN (IDENTIFIER);
}

{PP_NUMBER} {
	RETURN_STRING_TOKEN (OTHER);
d333 1
a333 1
	RETURN_TOKEN (yytext[0]);
d337 2
a338 1
	RETURN_STRING_TOKEN (OTHER);
d343 1
a343 1
		RETURN_TOKEN (SPACE);
d347 1
a347 3
	/* We preserve all newlines, even between #if 0..#endif, so no
	skipping.. */
<*>{NEWLINE} {
a349 2
	} else {
		BEGIN INITIAL;
d351 1
a351 2
	yyextra->space_tokens = 1;
	yyextra->lexing_directive = 0;
d354 1
a354 1
	RETURN_TOKEN_NEVER_SKIP (NEWLINE);
d357 2
a358 3
<INITIAL,COMMENT,DEFINE,HASH><<EOF>> {
	if (YY_START == COMMENT)
		glcpp_error(yylloc, yyextra, "Unterminated comment");
d360 2
a361 3
	yyextra->lexing_directive = 0;
	if (! parser->last_token_was_newline)
		RETURN_TOKEN (NEWLINE);
a363 8
	/* This is a catch-all to avoid the annoying default flex action which
	 * matches any character and prints it. If any input ever matches this
	 * rule, then we have made a mistake above and need to fix one or more
	 * of the preceding patterns to match that input. */

<*>. {
	glcpp_error(yylloc, yyextra, "Internal compiler error: Unexpected character: %s", yytext);

d365 1
a365 1
	only have this block here so that we can pretend to call some
d368 3
a370 4
        if (YY_START == UNREACHABLE) {
		unput('.');
		yy_top_state(yyextra);
	}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d55 1
a55 1
 } while(0);
d60 1
a60 1
		yycolumn = 1;		\
d63 93
d163 1
d165 5
a169 1
%x DONE COMMENT UNREACHABLE SKIP DEFINE NEWLINE_CATCHUP
a172 1
NEWLINE		[\n]
d174 2
a175 1
HASH		^{HSPACE}*#{HSPACE}*
d177 1
d212 1
a212 1
		return NEWLINE;
d215 28
a242 29
	/* The handling of the SKIP vs INITIAL start states requires
	 * some special handling. Typically, a lexer would change
	 * start states with statements like "BEGIN SKIP" within the
	 * lexer rules. We can't get away with that here, since we
	 * need the parser to actually evaluate expressions for
	 * directives like "#if".
	 *
	 * So, here, in code that will be executed on every call to
	 * the lexer,and before any rules, we examine the skip_stack
	 * as set by the parser to know whether to change from INITIAL
	 * to SKIP or from SKIP back to INITIAL.
	 *
	 * Three cases cause us to switch out of the SKIP state and
	 * back to the INITIAL state:
	 *
	 *	1. The top of the skip_stack is of type SKIP_NO_SKIP
	 *	   This means we're still evaluating some #if
	 *	   hierarchy, but we're on a branch of it where
	 *	   content should not be skipped (such as "#if 1" or
	 *	   "#else" or so).
	 *
	 *	2. The skip_stack is NULL meaning that we've reached
	 *	   the last #endif.
	 *
	 *	3. The lexing_if bit is set. This indicates that we
	 *	   are lexing the expression following an "#if" of
	 *	   "#elif". Even inside an "#if 0" we need to lex this
	 *	   expression so the parser can correctly update the
	 *	   skip_stack state.
d244 7
a250 9
	if (YY_START == INITIAL || YY_START == SKIP) {
		if (parser->lexing_if ||
		    parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			BEGIN INITIAL;
		} else {
			BEGIN SKIP;
		}
d254 1
a254 1
"//"[^\n]* {
d258 5
a262 5
"/*"                    { yy_push_state(COMMENT, yyscanner); }
<COMMENT>[^*\n]*
<COMMENT>[^*\n]*\n      { yylineno++; yycolumn = 0; parser->commented_newlines++; }
<COMMENT>"*"+[^*/\n]*
<COMMENT>"*"+[^*/\n]*\n { yylineno++; yycolumn = 0; parser->commented_newlines++; }
d265 3
a267 2
	if (yyextra->space_tokens)
		return SPACE;
d270 17
a286 2
{HASH}version{HSPACE}+ {
	yylval->str = ralloc_strdup (yyextra, yytext);
d288 13
a300 1
	return HASH_VERSION;
d305 8
a312 7
{HASH}(extension|pragma)[^\n]+ {
	if (parser->commented_newlines)
		BEGIN NEWLINE_CATCHUP;
	yylval->str = ralloc_strdup (yyextra, yytext);
	yylineno++;
	yycolumn = 0;
	return OTHER;
d315 3
a317 2
{HASH}line{HSPACE}+ {
	return HASH_LINE;
d320 5
a324 3
<SKIP,INITIAL>{
{HASH}ifdef {
	yyextra->lexing_if = 1;
d326 1
a326 1
	return HASH_IFDEF;
d329 3
a331 2
{HASH}ifndef {
	yyextra->lexing_if = 1;
d333 1
a333 1
	return HASH_IFNDEF;
d336 3
a338 2
{HASH}if/[^_a-zA-Z0-9] {
	yyextra->lexing_if = 1;
d340 1
a340 1
	return HASH_IF;
d343 3
a345 2
{HASH}elif/[^_a-zA-Z0-9] {
	yyextra->lexing_if = 1;
d347 1
a347 1
	return HASH_ELIF;
d350 2
a351 1
{HASH}else {
d353 1
a353 1
	return HASH_ELSE;
d356 2
a357 1
{HASH}endif {
d359 1
a359 1
	return HASH_ENDIF;
d361 4
d367 30
a396 3
<SKIP>[^\n] {
	if (parser->commented_newlines)
		BEGIN NEWLINE_CATCHUP;
d399 4
a402 5
{HASH}error.* {
	char *p;
	for (p = yytext; !isalpha(p[0]); p++); /* skip "  #   " */
	p += 5; /* skip "error" */
	glcpp_error(yylloc, yyextra, "#error%s", p);
d405 4
a408 4
{HASH}define{HSPACE}+ {
	yyextra->space_tokens = 0;
	yy_push_state(DEFINE, yyscanner);
	return HASH_DEFINE;
d411 1
d413 2
a414 3
	yy_pop_state(yyscanner);
	yylval->str = ralloc_strdup (yyextra, yytext);
	return FUNC_IDENTIFIER;
d417 1
d419 7
a425 3
	yy_pop_state(yyscanner);
	yylval->str = ralloc_strdup (yyextra, yytext);
	return OBJ_IDENTIFIER;
d428 5
a432 3
{HASH}undef {
	yyextra->space_tokens = 0;
	return HASH_UNDEF;
d435 6
a440 3
{HASH} {
	yyextra->space_tokens = 0;
	return HASH;
d444 1
a444 2
	yylval->str = ralloc_strdup (yyextra, yytext);
	return INTEGER_STRING;
d448 1
a448 2
	yylval->str = ralloc_strdup (yyextra, yytext);
	return INTEGER_STRING;
d452 1
a452 2
	yylval->str = ralloc_strdup (yyextra, yytext);
	return INTEGER_STRING;
d456 1
a456 1
	return LEFT_SHIFT;
d460 1
a460 1
	return RIGHT_SHIFT;
d464 1
a464 1
	return LESS_OR_EQUAL;
d468 1
a468 1
	return GREATER_OR_EQUAL;
d472 1
a472 1
	return EQUAL;
d476 1
a476 1
	return NOT_EQUAL;
d480 1
a480 1
	return AND;
d484 9
a492 1
	return OR;
d496 5
a500 3
	if (parser->is_gles)
		glcpp_error(yylloc, yyextra, "Token pasting (##) is illegal in GLES");
	return PASTE;
d504 1
a504 1
	return DEFINED;
d508 5
a512 2
	yylval->str = ralloc_strdup (yyextra, yytext);
	return IDENTIFIER;
d516 1
a516 1
	return yytext[0];
d520 1
a520 2
	yylval->str = ralloc_strdup (yyextra, yytext);
	return OTHER;
d525 1
a525 1
		return SPACE;
d529 3
a531 1
<SKIP,INITIAL>\n {
d534 2
d537 2
a538 1
	yyextra->lexing_if = 0;
d541 1
a541 1
	return NEWLINE;
d544 3
a546 2
	/* Handle missing newline at EOF. */
<INITIAL><<EOF>> {
d548 3
a550 2
	yyextra->lexing_if = 0;
	return NEWLINE;
d553 8
d562 1
a562 1
	only have this action here so that we can pretend to call some
d565 4
a568 3
<UNREACHABLE>. {
	unput('.');
	yy_top_state(yyextra);
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d50 1
a50 1
		yylloc->first_line = yylineno;				\
d52 1
d71 1
a71 1
%x DONE COMMENT UNREACHABLE SKIP DEFINE
d96 11
a106 2
	/* Implicitly switch between SKIP and INITIAL (non-skipping);
	 * don't switch if some other state was explicitly set.
d108 44
a151 4
	glcpp_parser_t *parser = yyextra;
	if (YY_START == 0 || YY_START == SKIP) {
		if (parser->lexing_if || parser->skip_stack == NULL || parser->skip_stack->type == SKIP_NO_SKIP) {
			BEGIN 0;
d164 1
a164 1
<COMMENT>[^*\n]*\n      { yylineno++; yycolumn = 0; return NEWLINE; }
d166 1
a166 1
<COMMENT>"*"+[^*/\n]*\n { yylineno++; yycolumn = 0; return NEWLINE; }
d182 2
d230 4
a233 1
<SKIP>[^\n] ;
d341 1
a341 1
{HSPACE}+ {
d348 3
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d43 12
a54 6
#define YY_USER_ACTION                                          \
   do {                                                         \
      yylloc->first_column = yycolumn + 1;                      \
      yylloc->first_line = yylineno;                            \
      yycolumn += yyleng;                                       \
   } while(0);
d70 1
a70 1
%x DONE COMMENT UNREACHABLE SKIP
d79 9
a87 1
OTHER		[^][(){}.&*~!/%<>^|;,=#[:space:]+-]+
d123 1
a123 1
{HASH}version {
d138 2
a139 29
{HASH}line{HSPACE}+{DIGITS}{HSPACE}+{DIGITS}{HSPACE}*$ {
	/* Eat characters until the first digit is
	 * encountered
	 */
	char *ptr = yytext;
	while (!isdigit(*ptr))
		ptr++;

	/* Subtract one from the line number because
	 * yylineno is zero-based instead of
	 * one-based.
	 */
	yylineno = strtol(ptr, &ptr, 0) - 1;
	yylloc->source = strtol(ptr, NULL, 0);
}

{HASH}line{HSPACE}+{DIGITS}{HSPACE}*$ {
	/* Eat characters until the first digit is
	 * encountered
	 */
	char *ptr = yytext;
	while (!isdigit(*ptr))
		ptr++;

	/* Subtract one from the line number because
	 * yylineno is zero-based instead of
	 * one-based.
	 */
	yylineno = strtol(ptr, &ptr, 0) - 1;
d161 1
a161 1
{HASH}elif {
d187 1
a187 1
{HASH}define{HSPACE}+/{IDENTIFIER}"(" {
d189 2
a190 1
	return HASH_DEFINE_FUNC;
d193 10
a202 3
{HASH}define {
	yyextra->space_tokens = 0;
	return HASH_DEFINE_OBJ;
d263 2
@


1.1
log
@Initial revision
@
text
@d37 4
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a36 4
#ifdef _MSC_VER
#define YY_NO_UNISTD_H
#endif

d39 6
a44 12
#define YY_USER_ACTION							\
	do {								\
		if (parser->has_new_line_number)			\
			yylineno = parser->new_line_number;		\
		if (parser->has_new_source_number)			\
			yylloc->source = parser->new_source_number;	\
		yylloc->first_column = yycolumn + 1;			\
		yylloc->first_line = yylineno;				\
		yycolumn += yyleng;					\
		parser->has_new_line_number = 0;			\
		parser->has_new_source_number = 0;			\
 } while(0);
d60 1
a60 1
%x DONE COMMENT UNREACHABLE SKIP DEFINE
d69 1
a69 9

/* The OTHER class is simply a catch-all for things that the CPP
parser just doesn't care about. Since flex regular expressions that
match longer strings take priority over those matching shorter
strings, we have to be careful to avoid OTHER matching and hiding
something that CPP does care about. So we simply exclude all
characters that appear in any other expressions. */

OTHER		[^][_#[:space:]#a-zA-Z0-9(){}.&*~!/%<>^|;,=+-]
d105 1
a105 1
{HASH}version{HSPACE}+ {
d120 29
a148 2
{HASH}line{HSPACE}+ {
	return HASH_LINE;
d170 1
a170 1
{HASH}elif/[^_a-zA-Z0-9] {
d196 1
a196 1
{HASH}define{HSPACE}+ {
d198 1
a198 2
	yy_push_state(DEFINE, yyscanner);
	return HASH_DEFINE;
d201 3
a203 10
<DEFINE>{IDENTIFIER}/"(" {
	yy_pop_state(yyscanner);
	yylval->str = ralloc_strdup (yyextra, yytext);
	return FUNC_IDENTIFIER;
}

<DEFINE>{IDENTIFIER} {
	yy_pop_state(yyscanner);
	yylval->str = ralloc_strdup (yyextra, yytext);
	return OBJ_IDENTIFIER;
a263 2
	if (parser->is_gles)
		glcpp_error(yylloc, yyextra, "Token pasting (##) is illegal in GLES");
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d50 1
a50 1
		yylloc->first_line = yylloc->last_line = yylineno;	\
a51 1
		yylloc->last_column = yycolumn + 1;			\
d70 1
a70 1
%x DONE COMMENT UNREACHABLE SKIP DEFINE NEWLINE_CATCHUP
d95 3
a97 1

d99 3
a101 54

	/* When we lex a multi-line comment, we replace it (as
	 * specified) with a single space. But if the comment spanned
	 * multiple lines, then subsequent parsing stages will not
	 * count correct line numbers. To avoid this problem we keep
	 * track of all newlines that were commented out by a
	 * multi-line comment, and we emit a NEWLINE token for each at
	 * the next legal opportunity, (which is when the lexer would
	 * be emitting a NEWLINE token anyway).
	 */
	if (YY_START == NEWLINE_CATCHUP) {
		if (parser->commented_newlines)
			parser->commented_newlines--;
		if (parser->commented_newlines == 0)
			BEGIN INITIAL;
		return NEWLINE;
	}

	/* The handling of the SKIP vs INITIAL start states requires
	 * some special handling. Typically, a lexer would change
	 * start states with statements like "BEGIN SKIP" within the
	 * lexer rules. We can't get away with that here, since we
	 * need the parser to actually evaluate expressions for
	 * directives like "#if".
	 *
	 * So, here, in code that will be executed on every call to
	 * the lexer,and before any rules, we examine the skip_stack
	 * as set by the parser to know whether to change from INITIAL
	 * to SKIP or from SKIP back to INITIAL.
	 *
	 * Three cases cause us to switch out of the SKIP state and
	 * back to the INITIAL state:
	 *
	 *	1. The top of the skip_stack is of type SKIP_NO_SKIP
	 *	   This means we're still evaluating some #if
	 *	   hierarchy, but we're on a branch of it where
	 *	   content should not be skipped (such as "#if 1" or
	 *	   "#else" or so).
	 *
	 *	2. The skip_stack is NULL meaning that we've reached
	 *	   the last #endif.
	 *
	 *	3. The lexing_if bit is set. This indicates that we
	 *	   are lexing the expression following an "#if" of
	 *	   "#elif". Even inside an "#if 0" we need to lex this
	 *	   expression so the parser can correctly update the
	 *	   skip_stack state.
	 */
	if (YY_START == INITIAL || YY_START == SKIP) {
		if (parser->lexing_if ||
		    parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			BEGIN INITIAL;
d114 1
a114 1
<COMMENT>[^*\n]*\n      { yylineno++; yycolumn = 0; parser->commented_newlines++; }
d116 1
a116 1
<COMMENT>"*"+[^*/\n]*\n { yylineno++; yycolumn = 0; parser->commented_newlines++; }
a131 2
	if (parser->commented_newlines)
		BEGIN NEWLINE_CATCHUP;
d178 1
a178 4
<SKIP>[^\n] {
	if (parser->commented_newlines)
		BEGIN NEWLINE_CATCHUP;
}
d286 1
a286 1
{HSPACE} {
a292 3
	if (parser->commented_newlines) {
		BEGIN NEWLINE_CATCHUP;
	}
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d55 1
a55 1
	} while(0);
d60 1
a60 1
		yycolumn = 0;		\
a62 93

/* It's ugly to have macros that have return statements inside of
 * them, but flex-based lexer generation is all built around the
 * return statement.
 *
 * To mitigate the ugliness, we defer as much of the logic as possible
 * to an actual function, not a macro (see
 * glcpplex_update_state_per_token) and we make the word RETURN
 * prominent in all of the macros which may return.
 *
 * The most-commonly-used macro is RETURN_TOKEN which will perform all
 * necessary state updates based on the provided token,, then
 * conditionally return the token. It will not return a token if the
 * parser is currently skipping tokens, (such as within #if
 * 0...#else).
 *
 * The RETURN_TOKEN_NEVER_SKIP macro is a lower-level variant that
 * makes the token returning unconditional. This is needed for things
 * like #if and the tokens of its condition, (since these must be
 * evaluated by the parser even when otherwise skipping).
 *
 * Finally, RETURN_STRING_TOKEN is a simple convenience wrapper on top
 * of RETURN_TOKEN that performs a string copy of yytext before the
 * return.
 */
#define RETURN_TOKEN_NEVER_SKIP(token)					\
	do {								\
		if (glcpp_lex_update_state_per_token (parser, token))	\
			return token;					\
	} while (0)

#define RETURN_TOKEN(token)						\
	do {								\
		if (! parser->skipping) {				\
			RETURN_TOKEN_NEVER_SKIP(token);			\
		}							\
	} while(0)

#define RETURN_STRING_TOKEN(token)					\
	do {								\
		if (! parser->skipping) {				\
			yylval->str = ralloc_strdup (yyextra, yytext);	\
			RETURN_TOKEN_NEVER_SKIP (token);		\
		}							\
	} while(0)


/* Update all state necessary for each token being returned.
 *
 * Here we'll be tracking newlines and spaces so that the lexer can
 * alter its behavior as necessary, (for example, '#' has special
 * significance if it is the first non-whitespace, non-comment token
 * in a line, but does not otherwise).
 *
 * NOTE: If this function returns FALSE, then no token should be
 * returned at all. This is used to suprress duplicate SPACE tokens.
 */
static int
glcpp_lex_update_state_per_token (glcpp_parser_t *parser, int token)
{
	/* After the first non-space token in a line, we won't
	 * allow any '#' to introduce a directive. */
	if (token == NEWLINE) {
		parser->first_non_space_token_this_line = 1;
	} else if (token != SPACE) {
		parser->first_non_space_token_this_line = 0;
	}

	/* Track newlines just to know whether a newline needs
	 * to be inserted if end-of-file comes early. */
	if (token == NEWLINE) {
		parser->last_token_was_newline = 1;
	} else {
		parser->last_token_was_newline = 0;
	}

	/* Track spaces to avoid emitting multiple SPACE
	 * tokens in a row. */
	if (token == SPACE) {
		if (! parser->last_token_was_space) {
			parser->last_token_was_space = 1;
			return 1;
		} else {
			parser->last_token_was_space = 1;
			return 0;
		}
	} else {
		parser->last_token_was_space = 0;
		return 1;
	}
}


a69 1
%option warn nodefault
d71 1
a71 5
	/* Note: When adding any start conditions to this list, you must also
	 * update the "Internal compiler error" catch-all rule near the end of
	 * this file. */

%x COMMENT DEFINE DONE HASH NEWLINE_CATCHUP UNREACHABLE
d75 1
d77 1
a77 2
HASH		#
NEWLINE		(\r\n|\n\r|\r|\n)
a78 1
PP_NUMBER	[.]?[0-9]([._a-zA-Z0-9]|[eEpP][-+])*
d113 1
a113 1
		RETURN_TOKEN_NEVER_SKIP (NEWLINE);
d116 29
a144 28
	/* Set up the parser->skipping bit here before doing any lexing.
	 *
	 * This bit controls whether tokens are skipped, (as implemented by
         * RETURN_TOKEN), such as between "#if 0" and "#endif".
	 *
	 * The parser maintains a skip_stack indicating whether we should be
         * skipping, (and nested levels of #if/#ifdef/#ifndef/#endif) will
         * push and pop items from the stack.
	 *
	 * Here are the rules for determining whether we are skipping:
	 *
	 *	1. If the skip stack is NULL, we are outside of all #if blocks
	 *         and we are not skipping.
	 *
	 *	2. If the skip stack is non-NULL, the type of the top node in
	 *	   the stack determines whether to skip. A type of
	 *	   SKIP_NO_SKIP is used for blocks wheere we are emitting
	 *	   tokens, (such as between #if 1 and #endif, or after the
	 *	   #else of an #if 0, etc.).
	 *
	 *	3. The lexing_directive bit overrides the skip stack. This bit
	 *	   is set when we are actively lexing the expression for a
	 *	   pre-processor condition, (such as #if, #elif, or #else). In
	 *	   this case, even if otherwise skipping, we need to emit the
	 *	   tokens for this condition so that the parser can evaluate
	 *	   the expression. (For, #else, there's no expression, but we
	 *	   emit tokens so the parser can generate a nice error message
	 *	   if there are any tokens here).
d146 9
a154 7
	if (parser->skip_stack &&
	    parser->skip_stack->type != SKIP_NO_SKIP &&
	    ! parser->lexing_directive)
	{
		parser->skipping = 1;
	} else {
		parser->skipping = 0;
d158 1
a158 1
<INITIAL,DEFINE,HASH>"//"[^\r\n]* {
d162 5
a166 5
<INITIAL,DEFINE,HASH>"/*"   { yy_push_state(COMMENT, yyscanner); }
<COMMENT>[^*\r\n]*
<COMMENT>[^*\r\n]*{NEWLINE} { yylineno++; yycolumn = 0; parser->commented_newlines++; }
<COMMENT>"*"+[^*/\r\n]*
<COMMENT>"*"+[^*/\r\n]*{NEWLINE} { yylineno++; yycolumn = 0; parser->commented_newlines++; }
d169 2
a170 3
	/* In the <HASH> start condition, we don't want any SPACE token. */
	if (yyextra->space_tokens && YY_START != HASH)
		RETURN_TOKEN (SPACE);
d173 2
a174 17
{HASH} {

	/* If the '#' is the first non-whitespace, non-comment token on this
	 * line, then it introduces a directive, switch to the <HASH> start
	 * condition.
	 *
	 * Otherwise, this is just punctuation, so return the HASH_TOKEN
         * token. */
	if (parser->first_non_space_token_this_line) {
		BEGIN HASH;
	}

	RETURN_TOKEN_NEVER_SKIP (HASH_TOKEN);
}

<HASH>version{HSPACE}+ {
	BEGIN INITIAL;
d176 1
a176 13
	RETURN_STRING_TOKEN (VERSION_TOKEN);
}

	/* Swallow empty #pragma directives, (to avoid confusing the
	 * downstream compiler).
	 *
	 * Note: We use a simple regular expression for the lookahead
	 * here. Specifically, we cannot use the complete {NEWLINE} expression
	 * since it uses alternation and we've found that there's a flex bug
	 * where using alternation in the lookahead portion of a pattern
	 * triggers a buffer overrun. */
<HASH>pragma{HSPACE}*/[\r\n] {
	BEGIN INITIAL;
d181 7
a187 3
<HASH>(extension|pragma)[^\r\n]* {
	BEGIN INITIAL;
	RETURN_STRING_TOKEN (PRAGMA);
d190 2
a191 3
<HASH>line{HSPACE}+ {
	BEGIN INITIAL;
	RETURN_TOKEN (LINE);
d194 5
a198 3
<HASH>{NEWLINE} {
	BEGIN INITIAL;
	RETURN_TOKEN_NEVER_SKIP (NEWLINE);
d201 2
a202 5
	/* For the pre-processor directives, we return these tokens
	 * even when we are otherwise skipping. */
<HASH>ifdef {
	BEGIN INITIAL;
	yyextra->lexing_directive = 1;
d204 1
a204 1
	RETURN_TOKEN_NEVER_SKIP (IFDEF);
d207 2
a208 3
<HASH>ifndef {
	BEGIN INITIAL;
	yyextra->lexing_directive = 1;
d210 1
a210 1
	RETURN_TOKEN_NEVER_SKIP (IFNDEF);
d213 2
a214 3
<HASH>if/[^_a-zA-Z0-9] {
	BEGIN INITIAL;
	yyextra->lexing_directive = 1;
d216 1
a216 1
	RETURN_TOKEN_NEVER_SKIP (IF);
d219 1
a219 3
<HASH>elif/[^_a-zA-Z0-9] {
	BEGIN INITIAL;
	yyextra->lexing_directive = 1;
d221 1
a221 1
	RETURN_TOKEN_NEVER_SKIP (ELIF);
d224 1
a224 2
<HASH>else {
	BEGIN INITIAL;
d226 1
a226 1
	RETURN_TOKEN_NEVER_SKIP (ELSE);
a227 5

<HASH>endif {
	BEGIN INITIAL;
	yyextra->space_tokens = 0;
	RETURN_TOKEN_NEVER_SKIP (ENDIF);
d230 3
a232 3
<HASH>error[^\r\n]* {
	BEGIN INITIAL;
	RETURN_STRING_TOKEN (ERROR_TOKEN);
d235 5
a239 24
	/* After we see a "#define" we enter the <DEFINE> start state
	 * for the lexer. Within <DEFINE> we are looking for the first
	 * identifier and specifically checking whether the identifier
	 * is followed by a '(' or not, (to lex either a
	 * FUNC_IDENTIFIER or an OBJ_IDENITIFIER token).
	 *
	 * While in the <DEFINE> state we also need to explicitly
	 * handle a few other things that may appear before the
	 * identifier:
	 * 
	 * 	* Comments, (handled above with the main support for
	 * 	  comments).
	 *
	 *	* Whitespace (simply ignored)
	 *
	 *	* Anything else, (not an identifier, not a comment,
	 *	  and not whitespace). This will generate an error.
	 */
<HASH>define{HSPACE}* {
	if (! parser->skipping) {
		BEGIN DEFINE;
		yyextra->space_tokens = 0;
		RETURN_TOKEN (DEFINE_TOKEN);
	}
d242 1
a242 2
<HASH>undef {
	BEGIN INITIAL;
d244 2
a245 13
	RETURN_TOKEN (UNDEF);
}

<HASH>{HSPACE}+ {
	/* Nothing to do here. Importantly, don't leave the <HASH>
	 * start condition, since it's legal to have space between the
	 * '#' and the directive.. */
}

	/* This will catch any non-directive garbage after a HASH */
<HASH>{NONSPACE} {
	BEGIN INITIAL;
	RETURN_TOKEN (GARBAGE);
a247 1
	/* An identifier immediately followed by '(' */
d249 3
a251 2
	BEGIN INITIAL;
	RETURN_STRING_TOKEN (FUNC_IDENTIFIER);
a253 1
	/* An identifier not immediately followed by '(' */
d255 3
a257 2
	BEGIN INITIAL;
	RETURN_STRING_TOKEN (OBJ_IDENTIFIER);
d260 3
a262 3
	/* Whitespace */
<DEFINE>{HSPACE}+ {
	/* Just ignore it. Nothing to do here. */
d265 3
a267 13
	/* '/' not followed by '*', so not a comment. This is an error. */
<DEFINE>[/][^*]{NONSPACE}* {
	BEGIN INITIAL;
	glcpp_error(yylloc, yyextra, "#define followed by a non-identifier: %s", yytext);
	RETURN_STRING_TOKEN (INTEGER_STRING);
}

	/* A character that can't start an identifier, comment, or
	 * space. This is an error. */
<DEFINE>[^_a-zA-Z/[:space:]]{NONSPACE}* {
	BEGIN INITIAL;
	glcpp_error(yylloc, yyextra, "#define followed by a non-identifier: %s", yytext);
	RETURN_STRING_TOKEN (INTEGER_STRING);
d271 2
a272 1
	RETURN_STRING_TOKEN (INTEGER_STRING);
d276 2
a277 1
	RETURN_STRING_TOKEN (INTEGER_STRING);
d281 2
a282 1
	RETURN_STRING_TOKEN (INTEGER_STRING);
d286 1
a286 1
	RETURN_TOKEN (LEFT_SHIFT);
d290 1
a290 1
	RETURN_TOKEN (RIGHT_SHIFT);
d294 1
a294 1
	RETURN_TOKEN (LESS_OR_EQUAL);
d298 1
a298 1
	RETURN_TOKEN (GREATER_OR_EQUAL);
d302 1
a302 1
	RETURN_TOKEN (EQUAL);
d306 1
a306 1
	RETURN_TOKEN (NOT_EQUAL);
d310 1
a310 1
	RETURN_TOKEN (AND);
d314 1
a314 9
	RETURN_TOKEN (OR);
}

"++" {
	RETURN_TOKEN (PLUS_PLUS);
}

"--" {
	RETURN_TOKEN (MINUS_MINUS);
d318 3
a320 5
	if (! parser->skipping) {
		if (parser->is_gles)
			glcpp_error(yylloc, yyextra, "Token pasting (##) is illegal in GLES");
		RETURN_TOKEN (PASTE);
	}
d324 1
a324 1
	RETURN_TOKEN (DEFINED);
d328 2
a329 5
	RETURN_STRING_TOKEN (IDENTIFIER);
}

{PP_NUMBER} {
	RETURN_STRING_TOKEN (OTHER);
d333 1
a333 1
	RETURN_TOKEN (yytext[0]);
d337 2
a338 1
	RETURN_STRING_TOKEN (OTHER);
d343 1
a343 1
		RETURN_TOKEN (SPACE);
d347 1
a347 3
	/* We preserve all newlines, even between #if 0..#endif, so no
	skipping.. */
<*>{NEWLINE} {
a349 2
	} else {
		BEGIN INITIAL;
d351 1
a351 2
	yyextra->space_tokens = 1;
	yyextra->lexing_directive = 0;
d354 1
a354 1
	RETURN_TOKEN_NEVER_SKIP (NEWLINE);
d357 2
a358 3
<INITIAL,COMMENT,DEFINE,HASH><<EOF>> {
	if (YY_START == COMMENT)
		glcpp_error(yylloc, yyextra, "Unterminated comment");
d360 2
a361 3
	yyextra->lexing_directive = 0;
	if (! parser->last_token_was_newline)
		RETURN_TOKEN (NEWLINE);
a363 8
	/* This is a catch-all to avoid the annoying default flex action which
	 * matches any character and prints it. If any input ever matches this
	 * rule, then we have made a mistake above and need to fix one or more
	 * of the preceding patterns to match that input. */

<*>. {
	glcpp_error(yylloc, yyextra, "Internal compiler error: Unexpected character: %s", yytext);

d365 1
a365 1
	only have this block here so that we can pretend to call some
d368 3
a370 4
        if (YY_START == UNREACHABLE) {
		unput('.');
		yy_top_state(yyextra);
	}
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d55 1
a55 1
 } while(0);
d60 1
a60 1
		yycolumn = 1;		\
d63 93
d163 1
d165 5
a169 1
%x DONE COMMENT UNREACHABLE SKIP DEFINE NEWLINE_CATCHUP
a172 1
NEWLINE		[\n]
d174 2
a175 1
HASH		^{HSPACE}*#{HSPACE}*
d177 1
d212 1
a212 1
		return NEWLINE;
d215 28
a242 29
	/* The handling of the SKIP vs INITIAL start states requires
	 * some special handling. Typically, a lexer would change
	 * start states with statements like "BEGIN SKIP" within the
	 * lexer rules. We can't get away with that here, since we
	 * need the parser to actually evaluate expressions for
	 * directives like "#if".
	 *
	 * So, here, in code that will be executed on every call to
	 * the lexer,and before any rules, we examine the skip_stack
	 * as set by the parser to know whether to change from INITIAL
	 * to SKIP or from SKIP back to INITIAL.
	 *
	 * Three cases cause us to switch out of the SKIP state and
	 * back to the INITIAL state:
	 *
	 *	1. The top of the skip_stack is of type SKIP_NO_SKIP
	 *	   This means we're still evaluating some #if
	 *	   hierarchy, but we're on a branch of it where
	 *	   content should not be skipped (such as "#if 1" or
	 *	   "#else" or so).
	 *
	 *	2. The skip_stack is NULL meaning that we've reached
	 *	   the last #endif.
	 *
	 *	3. The lexing_if bit is set. This indicates that we
	 *	   are lexing the expression following an "#if" of
	 *	   "#elif". Even inside an "#if 0" we need to lex this
	 *	   expression so the parser can correctly update the
	 *	   skip_stack state.
d244 7
a250 9
	if (YY_START == INITIAL || YY_START == SKIP) {
		if (parser->lexing_if ||
		    parser->skip_stack == NULL ||
		    parser->skip_stack->type == SKIP_NO_SKIP)
		{
			BEGIN INITIAL;
		} else {
			BEGIN SKIP;
		}
d254 1
a254 1
"//"[^\n]* {
d258 5
a262 5
"/*"                    { yy_push_state(COMMENT, yyscanner); }
<COMMENT>[^*\n]*
<COMMENT>[^*\n]*\n      { yylineno++; yycolumn = 0; parser->commented_newlines++; }
<COMMENT>"*"+[^*/\n]*
<COMMENT>"*"+[^*/\n]*\n { yylineno++; yycolumn = 0; parser->commented_newlines++; }
d265 3
a267 2
	if (yyextra->space_tokens)
		return SPACE;
d270 17
a286 2
{HASH}version{HSPACE}+ {
	yylval->str = ralloc_strdup (yyextra, yytext);
d288 13
a300 1
	return HASH_VERSION;
d305 8
a312 7
{HASH}(extension|pragma)[^\n]+ {
	if (parser->commented_newlines)
		BEGIN NEWLINE_CATCHUP;
	yylval->str = ralloc_strdup (yyextra, yytext);
	yylineno++;
	yycolumn = 0;
	return OTHER;
d315 3
a317 2
{HASH}line{HSPACE}+ {
	return HASH_LINE;
d320 5
a324 3
<SKIP,INITIAL>{
{HASH}ifdef {
	yyextra->lexing_if = 1;
d326 1
a326 1
	return HASH_IFDEF;
d329 3
a331 2
{HASH}ifndef {
	yyextra->lexing_if = 1;
d333 1
a333 1
	return HASH_IFNDEF;
d336 3
a338 2
{HASH}if/[^_a-zA-Z0-9] {
	yyextra->lexing_if = 1;
d340 1
a340 1
	return HASH_IF;
d343 3
a345 2
{HASH}elif/[^_a-zA-Z0-9] {
	yyextra->lexing_if = 1;
d347 1
a347 1
	return HASH_ELIF;
d350 2
a351 1
{HASH}else {
d353 1
a353 1
	return HASH_ELSE;
d356 2
a357 1
{HASH}endif {
d359 1
a359 1
	return HASH_ENDIF;
d361 4
d367 30
a396 3
<SKIP>[^\n] {
	if (parser->commented_newlines)
		BEGIN NEWLINE_CATCHUP;
d399 4
a402 5
{HASH}error.* {
	char *p;
	for (p = yytext; !isalpha(p[0]); p++); /* skip "  #   " */
	p += 5; /* skip "error" */
	glcpp_error(yylloc, yyextra, "#error%s", p);
d405 4
a408 4
{HASH}define{HSPACE}+ {
	yyextra->space_tokens = 0;
	yy_push_state(DEFINE, yyscanner);
	return HASH_DEFINE;
d411 1
d413 2
a414 3
	yy_pop_state(yyscanner);
	yylval->str = ralloc_strdup (yyextra, yytext);
	return FUNC_IDENTIFIER;
d417 1
d419 7
a425 3
	yy_pop_state(yyscanner);
	yylval->str = ralloc_strdup (yyextra, yytext);
	return OBJ_IDENTIFIER;
d428 5
a432 3
{HASH}undef {
	yyextra->space_tokens = 0;
	return HASH_UNDEF;
d435 6
a440 3
{HASH} {
	yyextra->space_tokens = 0;
	return HASH;
d444 1
a444 2
	yylval->str = ralloc_strdup (yyextra, yytext);
	return INTEGER_STRING;
d448 1
a448 2
	yylval->str = ralloc_strdup (yyextra, yytext);
	return INTEGER_STRING;
d452 1
a452 2
	yylval->str = ralloc_strdup (yyextra, yytext);
	return INTEGER_STRING;
d456 1
a456 1
	return LEFT_SHIFT;
d460 1
a460 1
	return RIGHT_SHIFT;
d464 1
a464 1
	return LESS_OR_EQUAL;
d468 1
a468 1
	return GREATER_OR_EQUAL;
d472 1
a472 1
	return EQUAL;
d476 1
a476 1
	return NOT_EQUAL;
d480 1
a480 1
	return AND;
d484 9
a492 1
	return OR;
d496 5
a500 3
	if (parser->is_gles)
		glcpp_error(yylloc, yyextra, "Token pasting (##) is illegal in GLES");
	return PASTE;
d504 1
a504 1
	return DEFINED;
d508 5
a512 2
	yylval->str = ralloc_strdup (yyextra, yytext);
	return IDENTIFIER;
d516 1
a516 1
	return yytext[0];
d520 1
a520 2
	yylval->str = ralloc_strdup (yyextra, yytext);
	return OTHER;
d525 1
a525 1
		return SPACE;
d529 3
a531 1
<SKIP,INITIAL>\n {
d534 2
d537 2
a538 1
	yyextra->lexing_if = 0;
d541 1
a541 1
	return NEWLINE;
d544 3
a546 2
	/* Handle missing newline at EOF. */
<INITIAL><<EOF>> {
d548 3
a550 2
	yyextra->lexing_if = 0;
	return NEWLINE;
d553 8
d562 1
a562 1
	only have this action here so that we can pretend to call some
d565 4
a568 3
<UNREACHABLE>. {
	unput('.');
	yy_top_state(yyextra);
@


