head	1.4;
access;
symbols
	OPENBSD_5_8:1.3.0.8
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.6
	OPENBSD_5_7_BASE:1.3
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2015.12.23.05.17.47;	author jsg;	state dead;
branches;
next	1.3;
commitid	TnlogFl9nOv2eaRf;

1.3
date	2013.09.05.14.03.53;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.35;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.35;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.09;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove the now unused Mesa 10.2.9 code
@
text
@#!/usr/bin/python2

# (C) Copyright IBM Corporation 2004
# All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# on the rights to use, copy, modify, merge, publish, distribute, sub
# license, and/or sell copies of the Software, and to permit persons to whom
# the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
# IBM AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
# Authors:
#    Ian Romanick <idr@@us.ibm.com>

import gl_XML
import license
import sys, getopt

class PrintGlTable(gl_XML.gl_print_base):
    def __init__(self, es=False):
        gl_XML.gl_print_base.__init__(self)

        self.es = es
        self.header_tag = '_GLAPI_TABLE_H_'
        self.name = "gl_table.py (from Mesa)"
        self.license = license.bsd_license_template % ( \
"""Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
(C) Copyright IBM Corporation 2004""", "BRIAN PAUL, IBM")
        self.ifdef_emitted = False;
        return


    def printBody(self, api):
        for f in api.functionIterateByOffset():
            if not f.is_abi() and not self.ifdef_emitted:
                print '#if !defined HAVE_SHARED_GLAPI'
                self.ifdef_emitted = True
            arg_string = f.get_parameter_string()
            print '   %s (GLAPIENTRYP %s)(%s); /* %d */' % (f.return_type, f.name, arg_string, f.offset)

        print '#endif /* !defined HAVE_SHARED_GLAPI */'


    def printRealHeader(self):
        print '#ifndef GLAPIENTRYP'
        print '# ifndef GLAPIENTRY'
        print '#  define GLAPIENTRY'
        print '# endif'
        print ''
        print '# define GLAPIENTRYP GLAPIENTRY *'
        print '#endif'
        print ''
        print ''
        print 'struct _glapi_table'
        print '{'
        return


    def printRealFooter(self):
        print '};'
        return


class PrintRemapTable(gl_XML.gl_print_base):
    def __init__(self, es=False):
        gl_XML.gl_print_base.__init__(self)

        self.es = es
        self.header_tag = '_DISPATCH_H_'
        self.name = "gl_table.py (from Mesa)"
        self.license = license.bsd_license_template % ("(C) Copyright IBM Corporation 2005", "IBM")
        return


    def printRealHeader(self):
        print """
/**
 * \\file main/dispatch.h
 * Macros for handling GL dispatch tables.
 *
 * For each known GL function, there are 3 macros in this file.  The first
 * macro is named CALL_FuncName and is used to call that GL function using
 * the specified dispatch table.  The other 2 macros, called GET_FuncName
 * can SET_FuncName, are used to get and set the dispatch pointer for the
 * named function in the specified dispatch table.
 */
"""
        return

    def printBody(self, api):
        print '#define CALL_by_offset(disp, cast, offset, parameters) \\'
        print '    (*(cast (GET_by_offset(disp, offset)))) parameters'
        print '#define GET_by_offset(disp, offset) \\'
        print '    (offset >= 0) ? (((_glapi_proc *)(disp))[offset]) : NULL'
        print '#define SET_by_offset(disp, offset, fn) \\'
        print '    do { \\'
        print '        if ( (offset) < 0 ) { \\'
        print '            /* fprintf( stderr, "[%s:%u] SET_by_offset(%p, %d, %s)!\\n", */ \\'
        print '            /*         __func__, __LINE__, disp, offset, # fn); */ \\'
        print '            /* abort(); */ \\'
        print '        } \\'
        print '        else { \\'
        print '            ( (_glapi_proc *) (disp) )[offset] = (_glapi_proc) fn; \\'
        print '        } \\'
        print '    } while(0)'
        print ''

        functions = []
        abi_functions = []
        alias_functions = []
        count = 0
        for f in api.functionIterateByOffset():
            if not f.is_abi():
                functions.append( [f, count] )
                count += 1
            else:
                abi_functions.append( [f, -1] )

            if self.es:
                # remember functions with aliases
                if len(f.entry_points) > 1:
                    alias_functions.append(f)

        print '/* total number of offsets below */'
        print '#define _gloffset_COUNT %d' % (len(abi_functions + functions))
        print ''

        for f, index in abi_functions:
            print '#define _gloffset_%s %d' % (f.name, f.offset)

        if self.es:
            remap_table = "esLocalRemapTable"

            print '#define %s_size %u' % (remap_table, count)
            print 'static int %s[ %s_size ];' % (remap_table, remap_table)
            print ''
        else:
            remap_table = "driDispatchRemapTable"

            print '#define %s_size %u' % (remap_table, count)
            print 'extern int %s[ %s_size ];' % (remap_table, remap_table)
            print ''

        for f, index in functions:
            print '#define %s_remap_index %u' % (f.name, index)

        print ''

        for f, index in functions:
            print '#define _gloffset_%s %s[%s_remap_index]' % (f.name, remap_table, f.name)

        print ''

        for f, index in abi_functions + functions:
            arg_string = gl_XML.create_parameter_string( f.parameters, 0 )

            print 'typedef %s (GLAPIENTRYP _glptr_%s)(%s);' % (f.return_type, f.name, arg_string)
            print '#define CALL_%s(disp, parameters) \\' % (f.name)
            print '    (* GET_%s(disp)) parameters' % (f.name)
            print 'static inline _glptr_%s GET_%s(struct _glapi_table *disp) {' % (f.name, f.name)
            print '   return (_glptr_%s) (GET_by_offset(disp, _gloffset_%s));' % (f.name, f.name)
            print '}'
            print
            print 'static inline void SET_%s(struct _glapi_table *disp, %s (GLAPIENTRYP fn)(%s)) {' % (f.name, f.return_type, arg_string)
            print '   SET_by_offset(disp, _gloffset_%s, fn);' % (f.name)
            print '}'
            print

        if alias_functions:
            print ''
            print '/* define aliases for compatibility */'
            for f in alias_functions:
                for name in f.entry_points:
                    if name != f.name:
                        print '#define CALL_%s(disp, parameters) CALL_%s(disp, parameters)' % (name, f.name)
                        print '#define GET_%s(disp) GET_%s(disp)' % (name, f.name)
                        print '#define SET_%s(disp, fn) SET_%s(disp, fn)' % (name, f.name)
            print ''

            for f in alias_functions:
                for name in f.entry_points:
                    if name != f.name:
                        print '#define %s_remap_index %s_remap_index' % (name, f.name)
            print ''

        return


def show_usage():
    print "Usage: %s [-f input_file_name] [-m mode] [-c ver]" % sys.argv[0]
    print "    -m mode   Mode can be 'table' or 'remap_table'."
    print "    -c ver    Version can be 'es1' or 'es2'."
    sys.exit(1)

if __name__ == '__main__':
    file_name = "gl_API.xml"

    try:
        (args, trail) = getopt.getopt(sys.argv[1:], "f:m:c:")
    except Exception,e:
        show_usage()

    mode = "table"
    es = None
    for (arg,val) in args:
        if arg == "-f":
            file_name = val
        elif arg == "-m":
            mode = val
        elif arg == "-c":
            es = val

    if mode == "table":
        printer = PrintGlTable(es)
    elif mode == "remap_table":
        printer = PrintRemapTable(es)
    else:
        show_usage()

    api = gl_XML.parse_GL_API( file_name )

    if es is not None:
        api.filter_functions_by_api(es)

    printer.Print( api )
@


1.3
log
@Merge Mesa 9.2.0
@
text
@@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d33 2
a34 2
	def __init__(self, es=False):
		gl_XML.gl_print_base.__init__(self)
d36 4
a39 4
		self.es = es
		self.header_tag = '_GLAPI_TABLE_H_'
		self.name = "gl_table.py (from Mesa)"
		self.license = license.bsd_license_template % ( \
d42 2
a43 1
		return
d46 29
a74 24
	def printBody(self, api):
		for f in api.functionIterateByOffset():
			arg_string = f.get_parameter_string()
			print '   %s (GLAPIENTRYP %s)(%s); /* %d */' % (f.return_type, f.name, arg_string, f.offset)


	def printRealHeader(self):
		print '#ifndef GLAPIENTRYP'
		print '# ifndef GLAPIENTRY'
		print '#  define GLAPIENTRY'
		print '# endif'
		print ''
		print '# define GLAPIENTRYP GLAPIENTRY *'
		print '#endif'
		print ''
		print ''
		print 'struct _glapi_table'
		print '{'
		return


	def printRealFooter(self):
		print '};'
		return
d78 2
a79 2
	def __init__(self, es=False):
		gl_XML.gl_print_base.__init__(self)
d81 5
a85 5
		self.es = es
		self.header_tag = '_DISPATCH_H_'
		self.name = "gl_table.py (from Mesa)"
		self.license = license.bsd_license_template % ("(C) Copyright IBM Corporation 2005", "IBM")
		return
d88 2
a89 2
	def printRealHeader(self):
		print """
a99 2

#include "main/mfeatures.h"
d101 1
a101 1
		return
d103 95
a197 110
	def printBody(self, api):
		print '#define CALL_by_offset(disp, cast, offset, parameters) \\'
		print '    (*(cast (GET_by_offset(disp, offset)))) parameters'
		print '#define GET_by_offset(disp, offset) \\'
		print '    (offset >= 0) ? (((_glapi_proc *)(disp))[offset]) : NULL'
		print '#define SET_by_offset(disp, offset, fn) \\'
		print '    do { \\'
		print '        if ( (offset) < 0 ) { \\'
		print '            /* fprintf( stderr, "[%s:%u] SET_by_offset(%p, %d, %s)!\\n", */ \\'
		print '            /*         __func__, __LINE__, disp, offset, # fn); */ \\'
		print '            /* abort(); */ \\'
		print '        } \\'
		print '        else { \\'
		print '            ( (_glapi_proc *) (disp) )[offset] = (_glapi_proc) fn; \\'
		print '        } \\'
		print '    } while(0)'
		print ''

		functions = []
		abi_functions = []
		alias_functions = []
		count = 0
		for f in api.functionIterateByOffset():
			if not f.is_abi():
				functions.append( [f, count] )
				count += 1
			else:
				abi_functions.append( [f, -1] )

			if self.es:
				# remember functions with aliases
				if len(f.entry_points) > 1:
					alias_functions.append(f)

		print '/* total number of offsets below */'
		print '#define _gloffset_COUNT %d' % (len(abi_functions + functions))
		print ''

		for f, index in abi_functions:
			print '#define _gloffset_%s %d' % (f.name, f.offset)

		print ''
		print '#if !FEATURE_remap_table'
		print ''

		for f, index in functions:
			print '#define _gloffset_%s %d' % (f.name, f.offset)

		print ''
		print '#else /* !FEATURE_remap_table */'
		print ''

		if self.es:
			remap_table = "esLocalRemapTable"

			print '#define %s_size %u' % (remap_table, count)
			print 'static int %s[ %s_size ];' % (remap_table, remap_table)
			print ''
		else:
			remap_table = "driDispatchRemapTable"

			print '#define %s_size %u' % (remap_table, count)
			print 'extern int %s[ %s_size ];' % (remap_table, remap_table)
			print ''

		for f, index in functions:
			print '#define %s_remap_index %u' % (f.name, index)

		print ''

		for f, index in functions:
			print '#define _gloffset_%s %s[%s_remap_index]' % (f.name, remap_table, f.name)

		print ''
		print '#endif /* !FEATURE_remap_table */'
		print ''

		for f, index in abi_functions + functions:
			arg_string = gl_XML.create_parameter_string( f.parameters, 0 )

			print 'typedef %s (GLAPIENTRYP _glptr_%s)(%s);' % (f.return_type, f.name, arg_string)
			print '#define CALL_%s(disp, parameters) \\' % (f.name)
			print '    (* GET_%s(disp)) parameters' % (f.name)
			print 'static INLINE _glptr_%s GET_%s(struct _glapi_table *disp) {' % (f.name, f.name)
			print '   return (_glptr_%s) (GET_by_offset(disp, _gloffset_%s));' % (f.name, f.name)
			print '}'
			print
			print 'static INLINE void SET_%s(struct _glapi_table *disp, %s (GLAPIENTRYP fn)(%s)) {' % (f.name, f.return_type, arg_string)
			print '   SET_by_offset(disp, _gloffset_%s, fn);' % (f.name)
			print '}'
			print

		if alias_functions:
			print ''
			print '/* define aliases for compatibility */'
			for f in alias_functions:
				for name in f.entry_points:
					if name != f.name:
						print '#define CALL_%s(disp, parameters) CALL_%s(disp, parameters)' % (name, f.name)
						print '#define GET_%s(disp) GET_%s(disp)' % (name, f.name)
						print '#define SET_%s(disp, fn) SET_%s(disp, fn)' % (name, f.name)
			print ''

			print '#if FEATURE_remap_table'
			for f in alias_functions:
				for name in f.entry_points:
					if name != f.name:
						print '#define %s_remap_index %s_remap_index' % (name, f.name)
			print '#endif /* FEATURE_remap_table */'
			print ''
d199 1
a199 1
		return
d203 4
a206 4
	print "Usage: %s [-f input_file_name] [-m mode] [-c]" % sys.argv[0]
	print "    -m mode   Mode can be 'table' or 'remap_table'."
	print "    -c        Enable compatibility with OpenGL ES."
	sys.exit(1)
d209 25
a233 23
	file_name = "gl_API.xml"
    
	try:
		(args, trail) = getopt.getopt(sys.argv[1:], "f:m:c")
	except Exception,e:
		show_usage()

	mode = "table"
	es = False
	for (arg,val) in args:
		if arg == "-f":
			file_name = val
		elif arg == "-m":
			mode = val
		elif arg == "-c":
			es = True

	if mode == "table":
		printer = PrintGlTable(es)
	elif mode == "remap_table":
		printer = PrintRemapTable(es)
	else:
		show_usage()
d235 2
a236 1
	api = gl_XML.parse_GL_API( file_name )
d238 1
a238 1
	printer.Print( api )
@


1.1
log
@Initial revision
@
text
@d76 1
a76 1
		self.header_tag = '_GLAPI_DISPATCH_H_'
a83 2
/* this file should not be included directly in mesa */

d85 1
a85 1
 * \\file glapidispatch.h
d94 2
a96 1
		
d141 1
a141 1
		print '#if !defined(_GLAPI_USE_REMAP_TABLE)'
d148 1
a148 1
		print '#else /* !_GLAPI_USE_REMAP_TABLE */'
d151 12
a162 3
		print '#define driDispatchRemapTable_size %u' % (count)
		print 'extern int driDispatchRemapTable[ driDispatchRemapTable_size ];'
		print ''
d170 1
a170 1
			print '#define _gloffset_%s driDispatchRemapTable[%s_remap_index]' % (f.name, f.name)
d173 1
a173 1
		print '#endif /* _GLAPI_USE_REMAP_TABLE */'
a177 1
			cast = '%s (GLAPIENTRYP)(%s)' % (f.return_type, arg_string)
d179 11
a189 3
			print '#define CALL_%s(disp, parameters) CALL_by_offset(disp, (%s), _gloffset_%s, parameters)' % (f.name, cast, f.name)
			print '#define GET_%s(disp) GET_by_offset(disp, _gloffset_%s)' % (f.name, f.name)
			print '#define SET_%s(disp, fn) SET_by_offset(disp, _gloffset_%s, fn)' % (f.name, f.name)
d202 1
a202 1
			print '#if defined(_GLAPI_USE_REMAP_TABLE)'
d207 1
a207 1
			print '#endif /* defined(_GLAPI_USE_REMAP_TABLE) */'
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d33 2
a34 2
    def __init__(self, es=False):
        gl_XML.gl_print_base.__init__(self)
d36 4
a39 4
        self.es = es
        self.header_tag = '_GLAPI_TABLE_H_'
        self.name = "gl_table.py (from Mesa)"
        self.license = license.bsd_license_template % ( \
d42 1
a42 2
        self.ifdef_emitted = False;
        return
d45 24
a68 29
    def printBody(self, api):
        for f in api.functionIterateByOffset():
            if not f.is_abi() and not self.ifdef_emitted:
                print '#if !defined HAVE_SHARED_GLAPI'
                self.ifdef_emitted = True
            arg_string = f.get_parameter_string()
            print '   %s (GLAPIENTRYP %s)(%s); /* %d */' % (f.return_type, f.name, arg_string, f.offset)

        print '#endif /* !defined HAVE_SHARED_GLAPI */'


    def printRealHeader(self):
        print '#ifndef GLAPIENTRYP'
        print '# ifndef GLAPIENTRY'
        print '#  define GLAPIENTRY'
        print '# endif'
        print ''
        print '# define GLAPIENTRYP GLAPIENTRY *'
        print '#endif'
        print ''
        print ''
        print 'struct _glapi_table'
        print '{'
        return


    def printRealFooter(self):
        print '};'
        return
d72 2
a73 2
    def __init__(self, es=False):
        gl_XML.gl_print_base.__init__(self)
d75 5
a79 5
        self.es = es
        self.header_tag = '_DISPATCH_H_'
        self.name = "gl_table.py (from Mesa)"
        self.license = license.bsd_license_template % ("(C) Copyright IBM Corporation 2005", "IBM")
        return
d82 4
a85 2
    def printRealHeader(self):
        print """
d87 1
a87 1
 * \\file main/dispatch.h
d97 2
a98 1
        return
d100 94
a193 95
    def printBody(self, api):
        print '#define CALL_by_offset(disp, cast, offset, parameters) \\'
        print '    (*(cast (GET_by_offset(disp, offset)))) parameters'
        print '#define GET_by_offset(disp, offset) \\'
        print '    (offset >= 0) ? (((_glapi_proc *)(disp))[offset]) : NULL'
        print '#define SET_by_offset(disp, offset, fn) \\'
        print '    do { \\'
        print '        if ( (offset) < 0 ) { \\'
        print '            /* fprintf( stderr, "[%s:%u] SET_by_offset(%p, %d, %s)!\\n", */ \\'
        print '            /*         __func__, __LINE__, disp, offset, # fn); */ \\'
        print '            /* abort(); */ \\'
        print '        } \\'
        print '        else { \\'
        print '            ( (_glapi_proc *) (disp) )[offset] = (_glapi_proc) fn; \\'
        print '        } \\'
        print '    } while(0)'
        print ''

        functions = []
        abi_functions = []
        alias_functions = []
        count = 0
        for f in api.functionIterateByOffset():
            if not f.is_abi():
                functions.append( [f, count] )
                count += 1
            else:
                abi_functions.append( [f, -1] )

            if self.es:
                # remember functions with aliases
                if len(f.entry_points) > 1:
                    alias_functions.append(f)

        print '/* total number of offsets below */'
        print '#define _gloffset_COUNT %d' % (len(abi_functions + functions))
        print ''

        for f, index in abi_functions:
            print '#define _gloffset_%s %d' % (f.name, f.offset)

        if self.es:
            remap_table = "esLocalRemapTable"

            print '#define %s_size %u' % (remap_table, count)
            print 'static int %s[ %s_size ];' % (remap_table, remap_table)
            print ''
        else:
            remap_table = "driDispatchRemapTable"

            print '#define %s_size %u' % (remap_table, count)
            print 'extern int %s[ %s_size ];' % (remap_table, remap_table)
            print ''

        for f, index in functions:
            print '#define %s_remap_index %u' % (f.name, index)

        print ''

        for f, index in functions:
            print '#define _gloffset_%s %s[%s_remap_index]' % (f.name, remap_table, f.name)

        print ''

        for f, index in abi_functions + functions:
            arg_string = gl_XML.create_parameter_string( f.parameters, 0 )

            print 'typedef %s (GLAPIENTRYP _glptr_%s)(%s);' % (f.return_type, f.name, arg_string)
            print '#define CALL_%s(disp, parameters) \\' % (f.name)
            print '    (* GET_%s(disp)) parameters' % (f.name)
            print 'static inline _glptr_%s GET_%s(struct _glapi_table *disp) {' % (f.name, f.name)
            print '   return (_glptr_%s) (GET_by_offset(disp, _gloffset_%s));' % (f.name, f.name)
            print '}'
            print
            print 'static inline void SET_%s(struct _glapi_table *disp, %s (GLAPIENTRYP fn)(%s)) {' % (f.name, f.return_type, arg_string)
            print '   SET_by_offset(disp, _gloffset_%s, fn);' % (f.name)
            print '}'
            print

        if alias_functions:
            print ''
            print '/* define aliases for compatibility */'
            for f in alias_functions:
                for name in f.entry_points:
                    if name != f.name:
                        print '#define CALL_%s(disp, parameters) CALL_%s(disp, parameters)' % (name, f.name)
                        print '#define GET_%s(disp) GET_%s(disp)' % (name, f.name)
                        print '#define SET_%s(disp, fn) SET_%s(disp, fn)' % (name, f.name)
            print ''

            for f in alias_functions:
                for name in f.entry_points:
                    if name != f.name:
                        print '#define %s_remap_index %s_remap_index' % (name, f.name)
            print ''
d195 1
a195 1
        return
d199 4
a202 4
    print "Usage: %s [-f input_file_name] [-m mode] [-c ver]" % sys.argv[0]
    print "    -m mode   Mode can be 'table' or 'remap_table'."
    print "    -c ver    Version can be 'es1' or 'es2'."
    sys.exit(1)
d205 23
a227 25
    file_name = "gl_API.xml"

    try:
        (args, trail) = getopt.getopt(sys.argv[1:], "f:m:c:")
    except Exception,e:
        show_usage()

    mode = "table"
    es = None
    for (arg,val) in args:
        if arg == "-f":
            file_name = val
        elif arg == "-m":
            mode = val
        elif arg == "-c":
            es = val

    if mode == "table":
        printer = PrintGlTable(es)
    elif mode == "remap_table":
        printer = PrintRemapTable(es)
    else:
        show_usage()

    api = gl_XML.parse_GL_API( file_name )
d229 1
a229 2
    if es is not None:
        api.filter_functions_by_api(es)
d231 1
a231 1
    printer.Print( api )
@

