head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.25;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.8;
commitid	4ry2gvZGMXkCUD2n;

1.8
date	2015.01.25.14.41.14;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2014.09.07.15.20.06;	author jsg;	state Exp;
branches;
next	1.6;
commitid	7kimTMT4YlQauAIU;

1.6
date	2014.07.09.21.08.51;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.11.24.06.19.52;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.09.05.13.59.22;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.02;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.23;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.15;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.11.24.05.52.42;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.33.40;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2014.09.07.15.00.25;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	dm8VnQHhowGHmemJ;

1.1.1.6
date	2015.01.25.14.05.57;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.43.05;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright © 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Kristian Høgsberg <krh@@bitplanet.net>
 */

#define WL_HIDE_DEPRECATED

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <limits.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
#ifdef HAVE_DRM_PLATFORM
#include <xf86drm.h>
#include <drm_fourcc.h>
#endif
#include <GL/gl.h>
#include <GL/internal/dri_interface.h>
#include <sys/types.h>
#include <sys/stat.h>

#ifdef HAVE_WAYLAND_PLATFORM
#include "wayland-drm.h"
#include "wayland-drm-client-protocol.h"
#endif

#include "egl_dri2.h"

const __DRIuseInvalidateExtension use_invalidate = {
   .base = { __DRI_USE_INVALIDATE, 1 }
};

EGLint dri2_to_egl_attribute_map[] = {
   0,
   EGL_BUFFER_SIZE,		/* __DRI_ATTRIB_BUFFER_SIZE */
   EGL_LEVEL,			/* __DRI_ATTRIB_LEVEL */
   EGL_RED_SIZE,		/* __DRI_ATTRIB_RED_SIZE */
   EGL_GREEN_SIZE,		/* __DRI_ATTRIB_GREEN_SIZE */
   EGL_BLUE_SIZE,		/* __DRI_ATTRIB_BLUE_SIZE */
   EGL_LUMINANCE_SIZE,		/* __DRI_ATTRIB_LUMINANCE_SIZE */
   EGL_ALPHA_SIZE,		/* __DRI_ATTRIB_ALPHA_SIZE */
   0,				/* __DRI_ATTRIB_ALPHA_MASK_SIZE */
   EGL_DEPTH_SIZE,		/* __DRI_ATTRIB_DEPTH_SIZE */
   EGL_STENCIL_SIZE,		/* __DRI_ATTRIB_STENCIL_SIZE */
   0,				/* __DRI_ATTRIB_ACCUM_RED_SIZE */
   0,				/* __DRI_ATTRIB_ACCUM_GREEN_SIZE */
   0,				/* __DRI_ATTRIB_ACCUM_BLUE_SIZE */
   0,				/* __DRI_ATTRIB_ACCUM_ALPHA_SIZE */
   EGL_SAMPLE_BUFFERS,		/* __DRI_ATTRIB_SAMPLE_BUFFERS */
   EGL_SAMPLES,			/* __DRI_ATTRIB_SAMPLES */
   0,				/* __DRI_ATTRIB_RENDER_TYPE, */
   0,				/* __DRI_ATTRIB_CONFIG_CAVEAT */
   0,				/* __DRI_ATTRIB_CONFORMANT */
   0,				/* __DRI_ATTRIB_DOUBLE_BUFFER */
   0,				/* __DRI_ATTRIB_STEREO */
   0,				/* __DRI_ATTRIB_AUX_BUFFERS */
   0,				/* __DRI_ATTRIB_TRANSPARENT_TYPE */
   0,				/* __DRI_ATTRIB_TRANSPARENT_INDEX_VALUE */
   0,				/* __DRI_ATTRIB_TRANSPARENT_RED_VALUE */
   0,				/* __DRI_ATTRIB_TRANSPARENT_GREEN_VALUE */
   0,				/* __DRI_ATTRIB_TRANSPARENT_BLUE_VALUE */
   0,				/* __DRI_ATTRIB_TRANSPARENT_ALPHA_VALUE */
   0,				/* __DRI_ATTRIB_FLOAT_MODE (deprecated) */
   0,				/* __DRI_ATTRIB_RED_MASK */
   0,				/* __DRI_ATTRIB_GREEN_MASK */
   0,				/* __DRI_ATTRIB_BLUE_MASK */
   0,				/* __DRI_ATTRIB_ALPHA_MASK */
   EGL_MAX_PBUFFER_WIDTH,	/* __DRI_ATTRIB_MAX_PBUFFER_WIDTH */
   EGL_MAX_PBUFFER_HEIGHT,	/* __DRI_ATTRIB_MAX_PBUFFER_HEIGHT */
   EGL_MAX_PBUFFER_PIXELS,	/* __DRI_ATTRIB_MAX_PBUFFER_PIXELS */
   0,				/* __DRI_ATTRIB_OPTIMAL_PBUFFER_WIDTH */
   0,				/* __DRI_ATTRIB_OPTIMAL_PBUFFER_HEIGHT */
   0,				/* __DRI_ATTRIB_VISUAL_SELECT_GROUP */
   0,				/* __DRI_ATTRIB_SWAP_METHOD */
   EGL_MAX_SWAP_INTERVAL,	/* __DRI_ATTRIB_MAX_SWAP_INTERVAL */
   EGL_MIN_SWAP_INTERVAL,	/* __DRI_ATTRIB_MIN_SWAP_INTERVAL */
   0,				/* __DRI_ATTRIB_BIND_TO_TEXTURE_RGB */
   0,				/* __DRI_ATTRIB_BIND_TO_TEXTURE_RGBA */
   0,				/* __DRI_ATTRIB_BIND_TO_MIPMAP_TEXTURE */
   0,				/* __DRI_ATTRIB_BIND_TO_TEXTURE_TARGETS */
   EGL_Y_INVERTED_NOK,		/* __DRI_ATTRIB_YINVERTED */
   0,				/* __DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE */
};

static EGLBoolean
dri2_match_config(const _EGLConfig *conf, const _EGLConfig *criteria)
{
   if (_eglCompareConfigs(conf, criteria, NULL, EGL_FALSE) != 0)
      return EGL_FALSE;

   if (!_eglMatchConfig(conf, criteria))
      return EGL_FALSE;

   return EGL_TRUE;
}

struct dri2_egl_config *
dri2_add_config(_EGLDisplay *disp, const __DRIconfig *dri_config, int id,
		EGLint surface_type, const EGLint *attr_list,
		const unsigned int *rgba_masks)
{
   struct dri2_egl_config *conf;
   struct dri2_egl_display *dri2_dpy;
   _EGLConfig base;
   unsigned int attrib, value, double_buffer;
   EGLint key, bind_to_texture_rgb, bind_to_texture_rgba;
   unsigned int dri_masks[4] = { 0, 0, 0, 0 };
   _EGLConfig *matching_config;
   EGLint num_configs = 0;
   EGLint config_id;
   int i;

   dri2_dpy = disp->DriverData;
   _eglInitConfig(&base, disp, id);
   
   i = 0;
   double_buffer = 0;
   bind_to_texture_rgb = 0;
   bind_to_texture_rgba = 0;

   while (dri2_dpy->core->indexConfigAttrib(dri_config, i++, &attrib, &value)) {
      switch (attrib) {
      case __DRI_ATTRIB_RENDER_TYPE:
	 if (value & __DRI_ATTRIB_RGBA_BIT)
	    value = EGL_RGB_BUFFER;
	 else if (value & __DRI_ATTRIB_LUMINANCE_BIT)
	    value = EGL_LUMINANCE_BUFFER;
	 else
	    return NULL;
	 _eglSetConfigKey(&base, EGL_COLOR_BUFFER_TYPE, value);
	 break;	 

      case __DRI_ATTRIB_CONFIG_CAVEAT:
         if (value & __DRI_ATTRIB_NON_CONFORMANT_CONFIG)
            value = EGL_NON_CONFORMANT_CONFIG;
         else if (value & __DRI_ATTRIB_SLOW_BIT)
            value = EGL_SLOW_CONFIG;
	 else
	    value = EGL_NONE;
	 _eglSetConfigKey(&base, EGL_CONFIG_CAVEAT, value);
         break;

      case __DRI_ATTRIB_BIND_TO_TEXTURE_RGB:
	 bind_to_texture_rgb = value;
	 break;

      case __DRI_ATTRIB_BIND_TO_TEXTURE_RGBA:
	 bind_to_texture_rgba = value;
	 break;

      case __DRI_ATTRIB_DOUBLE_BUFFER:
	 double_buffer = value;
	 break;

      case __DRI_ATTRIB_RED_MASK:
         dri_masks[0] = value;
         break;

      case __DRI_ATTRIB_GREEN_MASK:
         dri_masks[1] = value;
         break;

      case __DRI_ATTRIB_BLUE_MASK:
         dri_masks[2] = value;
         break;

      case __DRI_ATTRIB_ALPHA_MASK:
         dri_masks[3] = value;
         break;

      default:
	 key = dri2_to_egl_attribute_map[attrib];
	 if (key != 0)
	    _eglSetConfigKey(&base, key, value);
	 break;
      }
   }

   if (attr_list)
      for (i = 0; attr_list[i] != EGL_NONE; i += 2)
         _eglSetConfigKey(&base, attr_list[i], attr_list[i+1]);

   if (rgba_masks && memcmp(rgba_masks, dri_masks, sizeof(dri_masks)))
      return NULL;

   base.NativeRenderable = EGL_TRUE;

   base.SurfaceType = surface_type;
   if (surface_type & (EGL_PBUFFER_BIT |
       (disp->Extensions.NOK_texture_from_pixmap ? EGL_PIXMAP_BIT : 0))) {
      base.BindToTextureRGB = bind_to_texture_rgb;
      if (base.AlphaSize > 0)
         base.BindToTextureRGBA = bind_to_texture_rgba;
   }

   base.RenderableType = disp->ClientAPIs;
   base.Conformant = disp->ClientAPIs;

   base.MinSwapInterval = dri2_dpy->min_swap_interval;
   base.MaxSwapInterval = dri2_dpy->max_swap_interval;

   if (!_eglValidateConfig(&base, EGL_FALSE)) {
      _eglLog(_EGL_DEBUG, "DRI2: failed to validate config %d", id);
      return NULL;
   }

   config_id = base.ConfigID;
   base.ConfigID    = EGL_DONT_CARE;
   base.SurfaceType = EGL_DONT_CARE;
   num_configs = _eglFilterArray(disp->Configs, (void **) &matching_config, 1,
                                 (_EGLArrayForEach) dri2_match_config, &base);

   if (num_configs == 1) {
      conf = (struct dri2_egl_config *) matching_config;

      if (double_buffer && !conf->dri_double_config)
         conf->dri_double_config = dri_config;
      else if (!double_buffer && !conf->dri_single_config)
         conf->dri_single_config = dri_config;
      else
         /* a similar config type is already added (unlikely) => discard */
         return NULL;
   }
   else if (num_configs == 0) {
      conf = malloc(sizeof *conf);
      if (conf == NULL)
         return NULL;

      memcpy(&conf->base, &base, sizeof base);
      if (double_buffer) {
         conf->dri_double_config = dri_config;
         conf->dri_single_config = NULL;
      } else {
         conf->dri_single_config = dri_config;
         conf->dri_double_config = NULL;
      }
      conf->base.SurfaceType = 0;
      conf->base.ConfigID = config_id;

      _eglLinkConfig(&conf->base);
   }
   else {
      assert(0);
      return NULL;
   }

   if (double_buffer) {
      surface_type &= ~EGL_PIXMAP_BIT;
   }

   conf->base.SurfaceType |= surface_type;

   return conf;
}

__DRIimage *
dri2_lookup_egl_image(__DRIscreen *screen, void *image, void *data)
{
   _EGLDisplay *disp = data;
   struct dri2_egl_image *dri2_img;
   _EGLImage *img;

   (void) screen;

   img = _eglLookupImage(image, disp);
   if (img == NULL) {
      _eglError(EGL_BAD_PARAMETER, "dri2_lookup_egl_image");
      return NULL;
   }

   dri2_img = dri2_egl_image(image);

   return dri2_img->dri_image;
}

const __DRIimageLookupExtension image_lookup_extension = {
   .base = { __DRI_IMAGE_LOOKUP, 1 },

   .lookupEGLImage       = dri2_lookup_egl_image
};

static const char dri_driver_path[] = DEFAULT_DRIVER_DIR;

struct dri2_extension_match {
   const char *name;
   int version;
   int offset;
};

static struct dri2_extension_match dri2_driver_extensions[] = {
   { __DRI_CORE, 1, offsetof(struct dri2_egl_display, core) },
   { __DRI_DRI2, 2, offsetof(struct dri2_egl_display, dri2) },
   { NULL, 0, 0 }
};

static struct dri2_extension_match dri2_core_extensions[] = {
   { __DRI2_FLUSH, 1, offsetof(struct dri2_egl_display, flush) },
   { __DRI_TEX_BUFFER, 2, offsetof(struct dri2_egl_display, tex_buffer) },
   { __DRI_IMAGE, 1, offsetof(struct dri2_egl_display, image) },
   { NULL, 0, 0 }
};

static struct dri2_extension_match swrast_driver_extensions[] = {
   { __DRI_CORE, 1, offsetof(struct dri2_egl_display, core) },
   { __DRI_SWRAST, 2, offsetof(struct dri2_egl_display, swrast) },
   { NULL, 0, 0 }
};

static struct dri2_extension_match swrast_core_extensions[] = {
   { __DRI_TEX_BUFFER, 2, offsetof(struct dri2_egl_display, tex_buffer) },
   { NULL, 0, 0 }
};

static EGLBoolean
dri2_bind_extensions(struct dri2_egl_display *dri2_dpy,
		     struct dri2_extension_match *matches,
		     const __DRIextension **extensions)
{
   int i, j, ret = EGL_TRUE;
   void *field;

   for (i = 0; extensions[i]; i++) {
      _eglLog(_EGL_DEBUG, "DRI2: found extension `%s'", extensions[i]->name);
      for (j = 0; matches[j].name; j++) {
	 if (strcmp(extensions[i]->name, matches[j].name) == 0 &&
	     extensions[i]->version >= matches[j].version) {
	    field = ((char *) dri2_dpy + matches[j].offset);
	    *(const __DRIextension **) field = extensions[i];
	    _eglLog(_EGL_INFO, "DRI2: found extension %s version %d",
		    extensions[i]->name, extensions[i]->version);
	 }
      }
   }
   
   for (j = 0; matches[j].name; j++) {
      field = ((char *) dri2_dpy + matches[j].offset);
      if (*(const __DRIextension **) field == NULL) {
	 _eglLog(_EGL_FATAL, "DRI2: did not find extension %s version %d",
		 matches[j].name, matches[j].version);
	 ret = EGL_FALSE;
      }
   }

   return ret;
}

static const __DRIextension **
dri2_open_driver(_EGLDisplay *disp)
{
   struct dri2_egl_display *dri2_dpy = disp->DriverData;
   const __DRIextension **extensions = NULL;
   char path[PATH_MAX], *search_paths, *p, *next, *end;
   char *get_extensions_name;
   const __DRIextension **(*get_extensions)(void);

   search_paths = NULL;
   if (geteuid() == getuid()) {
      /* don't allow setuid apps to use LIBGL_DRIVERS_PATH */
      search_paths = getenv("LIBGL_DRIVERS_PATH");
   }
   if (search_paths == NULL)
      search_paths = DEFAULT_DRIVER_DIR;

   dri2_dpy->driver = NULL;
   end = search_paths + strlen(search_paths);
   for (p = search_paths; p < end && dri2_dpy->driver == NULL; p = next + 1) {
      int len;
      next = strchr(p, ':');
      if (next == NULL)
         next = end;

      len = next - p;
#if GLX_USE_TLS
      snprintf(path, sizeof path,
	       "%.*s/tls/%s_dri.so", len, p, dri2_dpy->driver_name);
      dri2_dpy->driver = dlopen(path, RTLD_NOW | RTLD_GLOBAL);
#endif
      if (dri2_dpy->driver == NULL) {
	 snprintf(path, sizeof path,
		  "%.*s/%s_dri.so", len, p, dri2_dpy->driver_name);
	 dri2_dpy->driver = dlopen(path, RTLD_NOW | RTLD_GLOBAL);
	 if (dri2_dpy->driver == NULL)
	    _eglLog(_EGL_DEBUG, "failed to open %s: %s\n", path, dlerror());
      }
      /* not need continue to loop all paths once the driver is found */
      if (dri2_dpy->driver != NULL)
         break;
   }

   if (dri2_dpy->driver == NULL) {
      _eglLog(_EGL_WARNING,
	      "DRI2: failed to open %s (search paths %s)",
	      dri2_dpy->driver_name, search_paths);
      return NULL;
   }

   _eglLog(_EGL_DEBUG, "DRI2: dlopen(%s)", path);

   if (asprintf(&get_extensions_name, "%s_%s",
                __DRI_DRIVER_GET_EXTENSIONS, dri2_dpy->driver_name) != -1) {
      get_extensions = dlsym(dri2_dpy->driver, get_extensions_name);
      if (get_extensions) {
         extensions = get_extensions();
      } else {
         _eglLog(_EGL_DEBUG, "driver does not expose %s(): %s\n",
                 get_extensions_name, dlerror());
      }
      free(get_extensions_name);
   }

   if (!extensions)
      extensions = dlsym(dri2_dpy->driver, __DRI_DRIVER_EXTENSIONS);
   if (extensions == NULL) {
      _eglLog(_EGL_WARNING,
	      "DRI2: driver exports no extensions (%s)", dlerror());
      dlclose(dri2_dpy->driver);
   }

   return extensions;
}

EGLBoolean
dri2_load_driver(_EGLDisplay *disp)
{
   struct dri2_egl_display *dri2_dpy = disp->DriverData;
   const __DRIextension **extensions;

   extensions = dri2_open_driver(disp);
   if (!extensions)
      return EGL_FALSE;

   if (!dri2_bind_extensions(dri2_dpy, dri2_driver_extensions, extensions)) {
      dlclose(dri2_dpy->driver);
      return EGL_FALSE;
   }
   dri2_dpy->driver_extensions = extensions;

   return EGL_TRUE;
}

EGLBoolean
dri2_load_driver_swrast(_EGLDisplay *disp)
{
   struct dri2_egl_display *dri2_dpy = disp->DriverData;
   const __DRIextension **extensions;

   dri2_dpy->driver_name = "swrast";
   extensions = dri2_open_driver(disp);

   if (!extensions)
      return EGL_FALSE;

   if (!dri2_bind_extensions(dri2_dpy, swrast_driver_extensions, extensions)) {
      dlclose(dri2_dpy->driver);
      return EGL_FALSE;
   }
   dri2_dpy->driver_extensions = extensions;

   return EGL_TRUE;
}

void
dri2_setup_screen(_EGLDisplay *disp)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   unsigned int api_mask;

   if (dri2_dpy->dri2) {
      api_mask = dri2_dpy->dri2->getAPIMask(dri2_dpy->dri_screen);
   } else {
      assert(dri2_dpy->swrast);
      api_mask = 1 << __DRI_API_OPENGL |
                 1 << __DRI_API_GLES |
                 1 << __DRI_API_GLES2 |
                 1 << __DRI_API_GLES3;
   }

   disp->ClientAPIs = 0;
   if (api_mask & (1 <<__DRI_API_OPENGL))
      disp->ClientAPIs |= EGL_OPENGL_BIT;
   if (api_mask & (1 <<__DRI_API_GLES))
      disp->ClientAPIs |= EGL_OPENGL_ES_BIT;
   if (api_mask & (1 << __DRI_API_GLES2))
      disp->ClientAPIs |= EGL_OPENGL_ES2_BIT;
   if (api_mask & (1 << __DRI_API_GLES3))
      disp->ClientAPIs |= EGL_OPENGL_ES3_BIT_KHR;

   assert(dri2_dpy->dri2 || dri2_dpy->swrast);
   disp->Extensions.KHR_surfaceless_context = EGL_TRUE;
   disp->Extensions.MESA_configless_context = EGL_TRUE;

   if (dri2_dpy->dri2 && dri2_dpy->dri2->base.version >= 3) {
      disp->Extensions.KHR_create_context = EGL_TRUE;

      if (dri2_dpy->robustness)
         disp->Extensions.EXT_create_context_robustness = EGL_TRUE;
   }

   if (dri2_dpy->image) {
      disp->Extensions.MESA_drm_image = EGL_TRUE;
      disp->Extensions.KHR_image_base = EGL_TRUE;
      disp->Extensions.KHR_gl_renderbuffer_image = EGL_TRUE;
      if (dri2_dpy->image->base.version >= 5 &&
          dri2_dpy->image->createImageFromTexture) {
         disp->Extensions.KHR_gl_texture_2D_image = EGL_TRUE;
         disp->Extensions.KHR_gl_texture_cubemap_image = EGL_TRUE;
      }
#ifdef HAVE_DRM_PLATFORM
      if (dri2_dpy->image->base.version >= 8 &&
          dri2_dpy->image->createImageFromDmaBufs) {
         disp->Extensions.EXT_image_dma_buf_import = EGL_TRUE;
      }
#endif
   }
}

EGLBoolean
dri2_create_screen(_EGLDisplay *disp)
{
   const __DRIextension **extensions;
   struct dri2_egl_display *dri2_dpy;

   dri2_dpy = disp->DriverData;

   if (dri2_dpy->dri2) {
      if (dri2_dpy->dri2->base.version >= 4) {
         dri2_dpy->dri_screen =
            dri2_dpy->dri2->createNewScreen2(0, dri2_dpy->fd,
                                             dri2_dpy->extensions,
                                             dri2_dpy->driver_extensions,
                                             &dri2_dpy->driver_configs, disp);
      } else {
         dri2_dpy->dri_screen =
            dri2_dpy->dri2->createNewScreen(0, dri2_dpy->fd,
                                            dri2_dpy->extensions,
                                            &dri2_dpy->driver_configs, disp);
      }
   } else {
      assert(dri2_dpy->swrast);
      if (dri2_dpy->swrast->base.version >= 4) {
         dri2_dpy->dri_screen =
            dri2_dpy->swrast->createNewScreen2(0, dri2_dpy->extensions,
                                               dri2_dpy->driver_extensions,
                                               &dri2_dpy->driver_configs, disp);
      } else {
         dri2_dpy->dri_screen =
            dri2_dpy->swrast->createNewScreen(0, dri2_dpy->extensions,
                                              &dri2_dpy->driver_configs, disp);
      }
   }

   if (dri2_dpy->dri_screen == NULL) {
      _eglLog(_EGL_WARNING, "DRI2: failed to create dri screen");
      return EGL_FALSE;
   }

   dri2_dpy->own_dri_screen = 1;

   extensions = dri2_dpy->core->getExtensions(dri2_dpy->dri_screen);
   
   if (dri2_dpy->dri2) {
      unsigned i;

      if (!dri2_bind_extensions(dri2_dpy, dri2_core_extensions, extensions))
         goto cleanup_dri_screen;

      for (i = 0; extensions[i]; i++) {
	 if (strcmp(extensions[i]->name, __DRI2_ROBUSTNESS) == 0) {
            dri2_dpy->robustness = (__DRIrobustnessExtension *) extensions[i];
	 }
	 if (strcmp(extensions[i]->name, __DRI2_CONFIG_QUERY) == 0) {
	    dri2_dpy->config = (__DRI2configQueryExtension *) extensions[i];
	 }
      }
   } else {
      assert(dri2_dpy->swrast);
      if (!dri2_bind_extensions(dri2_dpy, swrast_core_extensions, extensions))
         goto cleanup_dri_screen;
   }

   dri2_setup_screen(disp);

   return EGL_TRUE;

 cleanup_dri_screen:
   dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);

   return EGL_FALSE;
}

/**
 * Called via eglInitialize(), GLX_drv->API.Initialize().
 */
static EGLBoolean
dri2_initialize(_EGLDriver *drv, _EGLDisplay *disp)
{
   /* not until swrast_dri is supported */
   if (disp->Options.UseFallback)
      return EGL_FALSE;

   switch (disp->Platform) {
#ifdef HAVE_X11_PLATFORM
   case _EGL_PLATFORM_X11:
      if (disp->Options.TestOnly)
         return EGL_TRUE;
      return dri2_initialize_x11(drv, disp);
#endif

#ifdef HAVE_DRM_PLATFORM
   case _EGL_PLATFORM_DRM:
      if (disp->Options.TestOnly)
         return EGL_TRUE;
      return dri2_initialize_drm(drv, disp);
#endif
#ifdef HAVE_WAYLAND_PLATFORM
   case _EGL_PLATFORM_WAYLAND:
      if (disp->Options.TestOnly)
         return EGL_TRUE;
      return dri2_initialize_wayland(drv, disp);
#endif
#ifdef HAVE_ANDROID_PLATFORM
   case _EGL_PLATFORM_ANDROID:
      if (disp->Options.TestOnly)
         return EGL_TRUE;
      return dri2_initialize_android(drv, disp);
#endif

   default:
      return EGL_FALSE;
   }
}

/**
 * Called via eglTerminate(), drv->API.Terminate().
 */
static EGLBoolean
dri2_terminate(_EGLDriver *drv, _EGLDisplay *disp)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);

   _eglReleaseDisplayResources(drv, disp);
   _eglCleanupDisplay(disp);

   if (dri2_dpy->own_dri_screen)
      dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);
   if (dri2_dpy->fd)
      close(dri2_dpy->fd);
   if (dri2_dpy->driver)
      dlclose(dri2_dpy->driver);
   free(dri2_dpy->device_name);

   switch (disp->Platform) {
#ifdef HAVE_X11_PLATFORM
   case _EGL_PLATFORM_X11:
      if (dri2_dpy->own_device) {
         xcb_disconnect(dri2_dpy->conn);
      }
      break;
#endif
#ifdef HAVE_DRM_PLATFORM
   case _EGL_PLATFORM_DRM:
      if (dri2_dpy->own_device) {
         gbm_device_destroy(&dri2_dpy->gbm_dri->base.base);
      }
      break;
#endif
#ifdef HAVE_WAYLAND_PLATFORM
   case _EGL_PLATFORM_WAYLAND:
      wl_drm_destroy(dri2_dpy->wl_drm);
      if (dri2_dpy->own_device) {
         wl_display_disconnect(dri2_dpy->wl_dpy);
      }
      break;
#endif
   default:
      break;
   }

   free(dri2_dpy);
   disp->DriverData = NULL;

   return EGL_TRUE;
}

/**
 * Set the error code after a call to
 * dri2_egl_display::dri2::createContextAttribs.
 */
static void
dri2_create_context_attribs_error(int dri_error)
{
   EGLint egl_error;

   switch (dri_error) {
   case __DRI_CTX_ERROR_SUCCESS:
      return;

   case __DRI_CTX_ERROR_NO_MEMORY:
      egl_error = EGL_BAD_ALLOC;
      break;

  /* From the EGL_KHR_create_context spec, section "Errors":
   *
   *   * If <config> does not support a client API context compatible
   *     with the requested API major and minor version, [...] context flags,
   *     and context reset notification behavior (for client API types where
   *     these attributes are supported), then an EGL_BAD_MATCH error is
   *     generated.
   *
   *   * If an OpenGL ES context is requested and the values for
   *     attributes EGL_CONTEXT_MAJOR_VERSION_KHR and
   *     EGL_CONTEXT_MINOR_VERSION_KHR specify an OpenGL ES version that
   *     is not defined, than an EGL_BAD_MATCH error is generated.
   *
   *   * If an OpenGL context is requested, the requested version is
   *     greater than 3.2, and the value for attribute
   *     EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR has no bits set; has any
   *     bits set other than EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR and
   *     EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR; has more than
   *     one of these bits set; or if the implementation does not support
   *     the requested profile, then an EGL_BAD_MATCH error is generated.
   */
   case __DRI_CTX_ERROR_BAD_API:
   case __DRI_CTX_ERROR_BAD_VERSION:
   case __DRI_CTX_ERROR_BAD_FLAG:
      egl_error = EGL_BAD_MATCH;
      break;

  /* From the EGL_KHR_create_context spec, section "Errors":
   *
   *   * If an attribute name or attribute value in <attrib_list> is not
   *     recognized (including unrecognized bits in bitmask attributes),
   *     then an EGL_BAD_ATTRIBUTE error is generated."
   */
   case __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE:
   case __DRI_CTX_ERROR_UNKNOWN_FLAG:
      egl_error = EGL_BAD_ATTRIBUTE;
      break;

   default:
      assert(0);
      egl_error = EGL_BAD_MATCH;
      break;
   }

   _eglError(egl_error, "dri2_create_context");
}

/**
 * Called via eglCreateContext(), drv->API.CreateContext().
 */
static _EGLContext *
dri2_create_context(_EGLDriver *drv, _EGLDisplay *disp, _EGLConfig *conf,
		    _EGLContext *share_list, const EGLint *attrib_list)
{
   struct dri2_egl_context *dri2_ctx;
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_context *dri2_ctx_shared = dri2_egl_context(share_list);
   __DRIcontext *shared =
      dri2_ctx_shared ? dri2_ctx_shared->dri_context : NULL;
   struct dri2_egl_config *dri2_config = dri2_egl_config(conf);
   const __DRIconfig *dri_config;
   int api;

   (void) drv;

   dri2_ctx = malloc(sizeof *dri2_ctx);
   if (!dri2_ctx) {
      _eglError(EGL_BAD_ALLOC, "eglCreateContext");
      return NULL;
   }

   if (!_eglInitContext(&dri2_ctx->base, disp, conf, attrib_list))
      goto cleanup;

   switch (dri2_ctx->base.ClientAPI) {
   case EGL_OPENGL_ES_API:
      switch (dri2_ctx->base.ClientMajorVersion) {
      case 1:
         api = __DRI_API_GLES;
         break;
      case 2:
         api = __DRI_API_GLES2;
         break;
      case 3:
         api = __DRI_API_GLES3;
         break;
      default:
	 _eglError(EGL_BAD_PARAMETER, "eglCreateContext");
	 return NULL;
      }
      break;
   case EGL_OPENGL_API:
      if ((dri2_ctx->base.ClientMajorVersion >= 4
           || (dri2_ctx->base.ClientMajorVersion == 3
               && dri2_ctx->base.ClientMinorVersion >= 2))
          && dri2_ctx->base.Profile == EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR)
         api = __DRI_API_OPENGL_CORE;
      else
         api = __DRI_API_OPENGL;
      break;
   default:
      _eglError(EGL_BAD_PARAMETER, "eglCreateContext");
      free(dri2_ctx);
      return NULL;
   }

   if (conf != NULL) {
      /* The config chosen here isn't necessarily
       * used for surfaces later.
       * A pixmap surface will use the single config.
       * This opportunity depends on disabling the
       * doubleBufferMode check in
       * src/mesa/main/context.c:check_compatible()
       */
      if (dri2_config->dri_double_config)
         dri_config = dri2_config->dri_double_config;
      else
         dri_config = dri2_config->dri_single_config;

      /* EGL_WINDOW_BIT is set only when there is a dri_double_config.  This
       * makes sure the back buffer will always be used.
       */
      if (conf->SurfaceType & EGL_WINDOW_BIT)
         dri2_ctx->base.WindowRenderBuffer = EGL_BACK_BUFFER;
   }
   else
      dri_config = NULL;

   if (dri2_dpy->dri2) {
      if (dri2_dpy->dri2->base.version >= 3) {
         unsigned error;
         unsigned num_attribs = 0;
         uint32_t ctx_attribs[8];

         ctx_attribs[num_attribs++] = __DRI_CTX_ATTRIB_MAJOR_VERSION;
         ctx_attribs[num_attribs++] = dri2_ctx->base.ClientMajorVersion;
         ctx_attribs[num_attribs++] = __DRI_CTX_ATTRIB_MINOR_VERSION;
         ctx_attribs[num_attribs++] = dri2_ctx->base.ClientMinorVersion;

         if (dri2_ctx->base.Flags != 0) {
            /* If the implementation doesn't support the __DRI2_ROBUSTNESS
             * extension, don't even try to send it the robust-access flag.
             * It may explode.  Instead, generate the required EGL error here.
             */
            if ((dri2_ctx->base.Flags & EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR) != 0
                && !dri2_dpy->robustness) {
               _eglError(EGL_BAD_MATCH, "eglCreateContext");
               goto cleanup;
            }

            ctx_attribs[num_attribs++] = __DRI_CTX_ATTRIB_FLAGS;
            ctx_attribs[num_attribs++] = dri2_ctx->base.Flags;
         }

         if (dri2_ctx->base.ResetNotificationStrategy != EGL_NO_RESET_NOTIFICATION_KHR) {
            /* If the implementation doesn't support the __DRI2_ROBUSTNESS
             * extension, don't even try to send it a reset strategy.  It may
             * explode.  Instead, generate the required EGL error here.
             */
            if (!dri2_dpy->robustness) {
               _eglError(EGL_BAD_CONFIG, "eglCreateContext");
               goto cleanup;
            }

            ctx_attribs[num_attribs++] = __DRI_CTX_ATTRIB_RESET_STRATEGY;
            ctx_attribs[num_attribs++] = __DRI_CTX_RESET_LOSE_CONTEXT;
         }

         assert(num_attribs <= ARRAY_SIZE(ctx_attribs));

	 dri2_ctx->dri_context =
	    dri2_dpy->dri2->createContextAttribs(dri2_dpy->dri_screen,
                                                 api,
                                                 dri_config,
                                                 shared,
                                                 num_attribs / 2,
                                                 ctx_attribs,
                                                 & error,
                                                 dri2_ctx);
	 dri2_create_context_attribs_error(error);
      } else {
	 dri2_ctx->dri_context =
	    dri2_dpy->dri2->createNewContextForAPI(dri2_dpy->dri_screen,
						   api,
						   dri_config,
                                                   shared,
						   dri2_ctx);
      }
   } else {
      assert(dri2_dpy->swrast);
      dri2_ctx->dri_context =
         dri2_dpy->swrast->createNewContextForAPI(dri2_dpy->dri_screen,
                                                  api,
                                                  dri_config,
                                                  shared,
                                                  dri2_ctx);
   }

   if (!dri2_ctx->dri_context)
      goto cleanup;

   return &dri2_ctx->base;

 cleanup:
   free(dri2_ctx);
   return NULL;
}

/**
 * Called via eglDestroyContext(), drv->API.DestroyContext().
 */
static EGLBoolean
dri2_destroy_context(_EGLDriver *drv, _EGLDisplay *disp, _EGLContext *ctx)
{
   struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);

   if (_eglPutContext(ctx)) {
      dri2_dpy->core->destroyContext(dri2_ctx->dri_context);
      free(dri2_ctx);
   }

   return EGL_TRUE;
}

/**
 * Called via eglMakeCurrent(), drv->API.MakeCurrent().
 */
static EGLBoolean
dri2_make_current(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *dsurf,
		  _EGLSurface *rsurf, _EGLContext *ctx)
{
   struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_surface *dri2_dsurf = dri2_egl_surface(dsurf);
   struct dri2_egl_surface *dri2_rsurf = dri2_egl_surface(rsurf);
   struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
   _EGLContext *old_ctx;
   _EGLSurface *old_dsurf, *old_rsurf;
   __DRIdrawable *ddraw, *rdraw;
   __DRIcontext *cctx;

   /* make new bindings */
   if (!_eglBindContext(ctx, dsurf, rsurf, &old_ctx, &old_dsurf, &old_rsurf))
      return EGL_FALSE;

   /* flush before context switch */
   if (old_ctx && dri2_drv->glFlush)
      dri2_drv->glFlush();

   ddraw = (dri2_dsurf) ? dri2_dsurf->dri_drawable : NULL;
   rdraw = (dri2_rsurf) ? dri2_rsurf->dri_drawable : NULL;
   cctx = (dri2_ctx) ? dri2_ctx->dri_context : NULL;

   if (old_ctx) {
      __DRIcontext *old_cctx = dri2_egl_context(old_ctx)->dri_context;
      dri2_dpy->core->unbindContext(old_cctx);
   }

   if ((cctx == NULL && ddraw == NULL && rdraw == NULL) ||
       dri2_dpy->core->bindContext(cctx, ddraw, rdraw)) {
      if (old_dsurf)
         drv->API.DestroySurface(drv, disp, old_dsurf);
      if (old_rsurf)
         drv->API.DestroySurface(drv, disp, old_rsurf);
      if (old_ctx)
         drv->API.DestroyContext(drv, disp, old_ctx);

      return EGL_TRUE;
   } else {
      /* undo the previous _eglBindContext */
      _eglBindContext(old_ctx, old_dsurf, old_rsurf, &ctx, &dsurf, &rsurf);
      assert(&dri2_ctx->base == ctx &&
             &dri2_dsurf->base == dsurf &&
             &dri2_rsurf->base == rsurf);

      _eglPutSurface(dsurf);
      _eglPutSurface(rsurf);
      _eglPutContext(ctx);

      _eglPutSurface(old_dsurf);
      _eglPutSurface(old_rsurf);
      _eglPutContext(old_ctx);

      return EGL_FALSE;
   }
}

/*
 * Called from eglGetProcAddress() via drv->API.GetProcAddress().
 */
static _EGLProc
dri2_get_proc_address(_EGLDriver *drv, const char *procname)
{
   struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);

   return dri2_drv->get_proc_address(procname);
}

static _EGLSurface*
dri2_create_window_surface(_EGLDriver *drv, _EGLDisplay *dpy,
                           _EGLConfig *conf, void *native_window,
                           const EGLint *attrib_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->create_window_surface(drv, dpy, conf, native_window,
                                                attrib_list);
}

static _EGLSurface*
dri2_create_pixmap_surface(_EGLDriver *drv, _EGLDisplay *dpy,
                           _EGLConfig *conf, void *native_pixmap,
                           const EGLint *attrib_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->create_pixmap_surface(drv, dpy, conf, native_pixmap,
                                                attrib_list);
}

static _EGLSurface*
dri2_create_pbuffer_surface(_EGLDriver *drv, _EGLDisplay *dpy,
                           _EGLConfig *conf, const EGLint *attrib_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->create_pbuffer_surface(drv, dpy, conf, attrib_list);
}

static EGLBoolean
dri2_destroy_surface(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->destroy_surface(drv, dpy, surf);
}

static EGLBoolean
dri2_swap_interval(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf,
                   EGLint interval)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->swap_interval(drv, dpy, surf, interval);
}

static EGLBoolean
dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->swap_buffers(drv, dpy, surf);
}

static EGLBoolean
dri2_swap_buffers_with_damage(_EGLDriver *drv, _EGLDisplay *dpy,
                              _EGLSurface *surf,
                              const EGLint *rects, EGLint n_rects)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->swap_buffers_with_damage(drv, dpy, surf,
                                                   rects, n_rects);
}

static EGLBoolean
dri2_swap_buffers_region(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf,
                         EGLint numRects, const EGLint *rects)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->swap_buffers_region(drv, dpy, surf, numRects, rects);
}

static EGLBoolean
dri2_post_sub_buffer(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf,
                     EGLint x, EGLint y, EGLint width, EGLint height)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->post_sub_buffer(drv, dpy, surf, x, y, width, height);
}

static EGLBoolean
dri2_copy_buffers(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf,
                  void *native_pixmap_target)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->copy_buffers(drv, dpy, surf, native_pixmap_target);
}

static EGLint
dri2_query_buffer_age(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->query_buffer_age(drv, dpy, surf);
}

static EGLBoolean
dri2_wait_client(_EGLDriver *drv, _EGLDisplay *disp, _EGLContext *ctx)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(ctx->DrawSurface);

   (void) drv;

   /* FIXME: If EGL allows frontbuffer rendering for window surfaces,
    * we need to copy fake to real here.*/

   if (dri2_dpy->flush != NULL)
      dri2_dpy->flush->flush(dri2_surf->dri_drawable);

   return EGL_TRUE;
}

static EGLBoolean
dri2_wait_native(_EGLDriver *drv, _EGLDisplay *disp, EGLint engine)
{
   (void) drv;
   (void) disp;

   if (engine != EGL_CORE_NATIVE_ENGINE)
      return _eglError(EGL_BAD_PARAMETER, "eglWaitNative");
   /* glXWaitX(); */

   return EGL_TRUE;
}

static EGLBoolean
dri2_bind_tex_image(_EGLDriver *drv,
		    _EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surf);
   struct dri2_egl_context *dri2_ctx;
   _EGLContext *ctx;
   GLint format, target;

   ctx = _eglGetCurrentContext();
   dri2_ctx = dri2_egl_context(ctx);

   if (!_eglBindTexImage(drv, disp, surf, buffer))
      return EGL_FALSE;

   switch (dri2_surf->base.TextureFormat) {
   case EGL_TEXTURE_RGB:
      format = __DRI_TEXTURE_FORMAT_RGB;
      break;
   case EGL_TEXTURE_RGBA:
      format = __DRI_TEXTURE_FORMAT_RGBA;
      break;
   default:
      assert(0);
   }

   switch (dri2_surf->base.TextureTarget) {
   case EGL_TEXTURE_2D:
      target = GL_TEXTURE_2D;
      break;
   default:
      assert(0);
   }

   (*dri2_dpy->tex_buffer->setTexBuffer2)(dri2_ctx->dri_context,
					  target, format,
					  dri2_surf->dri_drawable);

   return EGL_TRUE;
}

static EGLBoolean
dri2_release_tex_image(_EGLDriver *drv,
		       _EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surf);
   struct dri2_egl_context *dri2_ctx;
   _EGLContext *ctx;
   GLint  target;

   ctx = _eglGetCurrentContext();
   dri2_ctx = dri2_egl_context(ctx);

   if (!_eglReleaseTexImage(drv, disp, surf, buffer))
      return EGL_FALSE;

   switch (dri2_surf->base.TextureTarget) {
   case EGL_TEXTURE_2D:
      target = GL_TEXTURE_2D;
      break;
   default:
      assert(0);
   }

   if (dri2_dpy->tex_buffer->base.version >= 3 &&
       dri2_dpy->tex_buffer->releaseTexBuffer != NULL) {
      (*dri2_dpy->tex_buffer->releaseTexBuffer)(dri2_ctx->dri_context,
                                                target,
                                                dri2_surf->dri_drawable);
   }

   return EGL_TRUE;
}

static _EGLImage*
dri2_create_image(_EGLDriver *drv, _EGLDisplay *dpy, _EGLContext *ctx,
                  EGLenum target, EGLClientBuffer buffer,
                  const EGLint *attr_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->create_image(drv, dpy, ctx, target, buffer,
                                       attr_list);
}

static _EGLImage *
dri2_create_image_from_dri(_EGLDisplay *disp, __DRIimage *dri_image)
{
   struct dri2_egl_image *dri2_img;

   if (dri_image == NULL) {
      _eglError(EGL_BAD_ALLOC, "dri2_create_image");
      return NULL;
   }

   dri2_img = malloc(sizeof *dri2_img);
   if (!dri2_img) {
      _eglError(EGL_BAD_ALLOC, "dri2_create_image");
      return NULL;
   }

   if (!_eglInitImage(&dri2_img->base, disp)) {
      free(dri2_img);
      return NULL;
   }

   dri2_img->dri_image = dri_image;

   return &dri2_img->base;
}

static _EGLImage *
dri2_create_image_khr_renderbuffer(_EGLDisplay *disp, _EGLContext *ctx,
				   EGLClientBuffer buffer,
				   const EGLint *attr_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
   GLuint renderbuffer = (GLuint) (uintptr_t) buffer;
   __DRIimage *dri_image;

   if (renderbuffer == 0) {
      _eglError(EGL_BAD_PARAMETER, "dri2_create_image_khr");
      return EGL_NO_IMAGE_KHR;
   }

   dri_image =
      dri2_dpy->image->createImageFromRenderbuffer(dri2_ctx->dri_context,
                                                   renderbuffer, NULL);

   return dri2_create_image_from_dri(disp, dri_image);
}

#ifdef HAVE_DRM_PLATFORM
static _EGLImage *
dri2_create_image_mesa_drm_buffer(_EGLDisplay *disp, _EGLContext *ctx,
				  EGLClientBuffer buffer, const EGLint *attr_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   EGLint format, name, pitch, err;
   _EGLImageAttribs attrs;
   __DRIimage *dri_image;

   name = (EGLint) (uintptr_t) buffer;

   err = _eglParseImageAttribList(&attrs, disp, attr_list);
   if (err != EGL_SUCCESS)
      return NULL;

   if (attrs.Width <= 0 || attrs.Height <= 0 ||
       attrs.DRMBufferStrideMESA <= 0) {
      _eglError(EGL_BAD_PARAMETER,
		"bad width, height or stride");
      return NULL;
   }

   switch (attrs.DRMBufferFormatMESA) {
   case EGL_DRM_BUFFER_FORMAT_ARGB32_MESA:
      format = __DRI_IMAGE_FORMAT_ARGB8888;
      pitch = attrs.DRMBufferStrideMESA;
      break;
   default:
      _eglError(EGL_BAD_PARAMETER,
		"dri2_create_image_khr: unsupported pixmap depth");
      return NULL;
   }

   dri_image =
      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen,
					   attrs.Width,
					   attrs.Height,
					   format,
					   name,
					   pitch,
					   NULL);

   return dri2_create_image_from_dri(disp, dri_image);
}
#endif

#ifdef HAVE_WAYLAND_PLATFORM

/* This structure describes how a wl_buffer maps to one or more
 * __DRIimages.  A wl_drm_buffer stores the wl_drm format code and the
 * offsets and strides of the planes in the buffer.  This table maps a
 * wl_drm format code to a description of the planes in the buffer
 * that lets us create a __DRIimage for each of the planes. */

static const struct wl_drm_components_descriptor {
   uint32_t dri_components;
   EGLint components;
   int nplanes;
} wl_drm_components[] = {
   { __DRI_IMAGE_COMPONENTS_RGB, EGL_TEXTURE_RGB, 1 },
   { __DRI_IMAGE_COMPONENTS_RGBA, EGL_TEXTURE_RGBA, 1 },
   { __DRI_IMAGE_COMPONENTS_Y_U_V, EGL_TEXTURE_Y_U_V_WL, 3 },
   { __DRI_IMAGE_COMPONENTS_Y_UV, EGL_TEXTURE_Y_UV_WL, 2 },
   { __DRI_IMAGE_COMPONENTS_Y_XUXV, EGL_TEXTURE_Y_XUXV_WL, 2 },
};

static _EGLImage *
dri2_create_image_wayland_wl_buffer(_EGLDisplay *disp, _EGLContext *ctx,
				    EGLClientBuffer _buffer,
				    const EGLint *attr_list)
{
   struct wl_drm_buffer *buffer;
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   const struct wl_drm_components_descriptor *f;
   __DRIimage *dri_image;
   _EGLImageAttribs attrs;
   EGLint err;
   int32_t plane;

   buffer = wayland_drm_buffer_get(dri2_dpy->wl_server_drm,
                                   (struct wl_resource *) _buffer);
   if (!buffer)
       return NULL;

   err = _eglParseImageAttribList(&attrs, disp, attr_list);
   plane = attrs.PlaneWL;
   if (err != EGL_SUCCESS) {
      _eglError(EGL_BAD_PARAMETER, "dri2_create_image_wayland_wl_buffer");
      return NULL;
   }

   f = buffer->driver_format;
   if (plane < 0 || plane >= f->nplanes) {
      _eglError(EGL_BAD_PARAMETER,
                "dri2_create_image_wayland_wl_buffer (plane out of bounds)");
      return NULL;
   }

   dri_image = dri2_dpy->image->fromPlanar(buffer->driver_buffer, plane, NULL);

   if (dri_image == NULL) {
      _eglError(EGL_BAD_PARAMETER, "dri2_create_image_wayland_wl_buffer");
      return NULL;
   }

   return dri2_create_image_from_dri(disp, dri_image);
}
#endif

/**
 * Set the error code after a call to
 * dri2_egl_image::dri_image::createImageFromTexture.
 */
static void
dri2_create_image_khr_texture_error(int dri_error)
{
   EGLint egl_error;

   switch (dri_error) {
   case __DRI_IMAGE_ERROR_SUCCESS:
      return;

   case __DRI_IMAGE_ERROR_BAD_ALLOC:
      egl_error = EGL_BAD_ALLOC;
      break;

   case __DRI_IMAGE_ERROR_BAD_MATCH:
      egl_error = EGL_BAD_MATCH;
      break;

   case __DRI_IMAGE_ERROR_BAD_PARAMETER:
      egl_error = EGL_BAD_PARAMETER;
      break;

   default:
      assert(0);
      egl_error = EGL_BAD_MATCH;
      break;
   }

   _eglError(egl_error, "dri2_create_image_khr_texture");
}

static _EGLImage *
dri2_create_image_khr_texture(_EGLDisplay *disp, _EGLContext *ctx,
				   EGLenum target,
				   EGLClientBuffer buffer,
				   const EGLint *attr_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
   struct dri2_egl_image *dri2_img;
   GLuint texture = (GLuint) (uintptr_t) buffer;
   _EGLImageAttribs attrs;
   GLuint depth;
   GLenum gl_target;
   unsigned error;

   if (texture == 0) {
      _eglError(EGL_BAD_PARAMETER, "dri2_create_image_khr");
      return EGL_NO_IMAGE_KHR;
   }

   if (_eglParseImageAttribList(&attrs, disp, attr_list) != EGL_SUCCESS)
      return EGL_NO_IMAGE_KHR;

   switch (target) {
   case EGL_GL_TEXTURE_2D_KHR:
      depth = 0;
      gl_target = GL_TEXTURE_2D;
      break;
   case EGL_GL_TEXTURE_3D_KHR:
      depth = attrs.GLTextureZOffset;
      gl_target = GL_TEXTURE_3D;
      break;
   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR:
      depth = target - EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR;
      gl_target = GL_TEXTURE_CUBE_MAP;
      break;
   default:
      _eglError(EGL_BAD_PARAMETER, "dri2_create_image_khr");
      return EGL_NO_IMAGE_KHR;
   }

   dri2_img = malloc(sizeof *dri2_img);
   if (!dri2_img) {
      _eglError(EGL_BAD_ALLOC, "dri2_create_image_khr");
      return EGL_NO_IMAGE_KHR;
   }

   if (!_eglInitImage(&dri2_img->base, disp)) {
      _eglError(EGL_BAD_ALLOC, "dri2_create_image_khr");
      free(dri2_img);
      return EGL_NO_IMAGE_KHR;
   }

   dri2_img->dri_image =
      dri2_dpy->image->createImageFromTexture(dri2_ctx->dri_context,
                                              gl_target,
                                              texture,
                                              depth,
                                              attrs.GLTextureLevel,
                                              &error,
                                              dri2_img);
   dri2_create_image_khr_texture_error(error);

   if (!dri2_img->dri_image) {
      free(dri2_img);
      return EGL_NO_IMAGE_KHR;
   }
   return &dri2_img->base;
}

static struct wl_buffer*
dri2_create_wayland_buffer_from_image(_EGLDriver *drv, _EGLDisplay *dpy,
                                      _EGLImage *img)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->create_wayland_buffer_from_image(drv, dpy, img);
}

#ifdef HAVE_DRM_PLATFORM
static EGLBoolean
dri2_check_dma_buf_attribs(const _EGLImageAttribs *attrs)
{
   unsigned i;

   /**
     * The spec says:
     *
     * "Required attributes and their values are as follows:
     *
     *  * EGL_WIDTH & EGL_HEIGHT: The logical dimensions of the buffer in pixels
     *
     *  * EGL_LINUX_DRM_FOURCC_EXT: The pixel format of the buffer, as specified
     *    by drm_fourcc.h and used as the pixel_format parameter of the
     *    drm_mode_fb_cmd2 ioctl."
     *
     * and
     *
     * "* If <target> is EGL_LINUX_DMA_BUF_EXT, and the list of attributes is
     *    incomplete, EGL_BAD_PARAMETER is generated."
     */
   if (attrs->Width <= 0 || attrs->Height <= 0 ||
       !attrs->DMABufFourCC.IsPresent) {
      _eglError(EGL_BAD_PARAMETER, "attribute(s) missing");
      return EGL_FALSE;
   }

   /**
    * Also:
    *
    * "If <target> is EGL_LINUX_DMA_BUF_EXT and one or more of the values
    *  specified for a plane's pitch or offset isn't supported by EGL,
    *  EGL_BAD_ACCESS is generated."
    */
   for (i = 0; i < ARRAY_SIZE(attrs->DMABufPlanePitches); ++i) {
      if (attrs->DMABufPlanePitches[i].IsPresent &&
          attrs->DMABufPlanePitches[i].Value <= 0) {
         _eglError(EGL_BAD_ACCESS, "invalid pitch");
         return EGL_FALSE;
      }
   }

   return EGL_TRUE;
}

/* Returns the total number of file descriptors. Zero indicates an error. */
static unsigned
dri2_check_dma_buf_format(const _EGLImageAttribs *attrs)
{
   unsigned i, plane_n;

   switch (attrs->DMABufFourCC.Value) {
   case DRM_FORMAT_RGB332:
   case DRM_FORMAT_BGR233:
   case DRM_FORMAT_XRGB4444:
   case DRM_FORMAT_XBGR4444:
   case DRM_FORMAT_RGBX4444:
   case DRM_FORMAT_BGRX4444:
   case DRM_FORMAT_ARGB4444:
   case DRM_FORMAT_ABGR4444:
   case DRM_FORMAT_RGBA4444:
   case DRM_FORMAT_BGRA4444:
   case DRM_FORMAT_XRGB1555:
   case DRM_FORMAT_XBGR1555:
   case DRM_FORMAT_RGBX5551:
   case DRM_FORMAT_BGRX5551:
   case DRM_FORMAT_ARGB1555:
   case DRM_FORMAT_ABGR1555:
   case DRM_FORMAT_RGBA5551:
   case DRM_FORMAT_BGRA5551:
   case DRM_FORMAT_RGB565:
   case DRM_FORMAT_BGR565:
   case DRM_FORMAT_RGB888:
   case DRM_FORMAT_BGR888:
   case DRM_FORMAT_XRGB8888:
   case DRM_FORMAT_XBGR8888:
   case DRM_FORMAT_RGBX8888:
   case DRM_FORMAT_BGRX8888:
   case DRM_FORMAT_ARGB8888:
   case DRM_FORMAT_ABGR8888:
   case DRM_FORMAT_RGBA8888:
   case DRM_FORMAT_BGRA8888:
   case DRM_FORMAT_XRGB2101010:
   case DRM_FORMAT_XBGR2101010:
   case DRM_FORMAT_RGBX1010102:
   case DRM_FORMAT_BGRX1010102:
   case DRM_FORMAT_ARGB2101010:
   case DRM_FORMAT_ABGR2101010:
   case DRM_FORMAT_RGBA1010102:
   case DRM_FORMAT_BGRA1010102:
   case DRM_FORMAT_YUYV:
   case DRM_FORMAT_YVYU:
   case DRM_FORMAT_UYVY:
   case DRM_FORMAT_VYUY:
      plane_n = 1;
      break;
   case DRM_FORMAT_NV12:
   case DRM_FORMAT_NV21:
   case DRM_FORMAT_NV16:
   case DRM_FORMAT_NV61:
      plane_n = 2;
      break;
   case DRM_FORMAT_YUV410:
   case DRM_FORMAT_YVU410:
   case DRM_FORMAT_YUV411:
   case DRM_FORMAT_YVU411:
   case DRM_FORMAT_YUV420:
   case DRM_FORMAT_YVU420:
   case DRM_FORMAT_YUV422:
   case DRM_FORMAT_YVU422:
   case DRM_FORMAT_YUV444:
   case DRM_FORMAT_YVU444:
      plane_n = 3;
      break;
   default:
      _eglError(EGL_BAD_ATTRIBUTE, "invalid format");
      return 0;
   }

   /**
     * The spec says:
     *
     * "* If <target> is EGL_LINUX_DMA_BUF_EXT, and the list of attributes is
     *    incomplete, EGL_BAD_PARAMETER is generated."
     */
   for (i = 0; i < plane_n; ++i) {
      if (!attrs->DMABufPlaneFds[i].IsPresent ||
          !attrs->DMABufPlaneOffsets[i].IsPresent ||
          !attrs->DMABufPlanePitches[i].IsPresent) {
         _eglError(EGL_BAD_PARAMETER, "plane attribute(s) missing");
         return 0;
      }
   }

   /**
    * The spec also says:
    *
    * "If <target> is EGL_LINUX_DMA_BUF_EXT, and the EGL_LINUX_DRM_FOURCC_EXT
    *  attribute indicates a single-plane format, EGL_BAD_ATTRIBUTE is
    *  generated if any of the EGL_DMA_BUF_PLANE1_* or EGL_DMA_BUF_PLANE2_*
    *  attributes are specified."
    */
   for (i = plane_n; i < 3; ++i) {
      if (attrs->DMABufPlaneFds[i].IsPresent ||
          attrs->DMABufPlaneOffsets[i].IsPresent ||
          attrs->DMABufPlanePitches[i].IsPresent) {
         _eglError(EGL_BAD_ATTRIBUTE, "too many plane attributes");
         return 0;
      }
   }

   return plane_n;
}

/**
 * The spec says:
 *
 * "If eglCreateImageKHR is successful for a EGL_LINUX_DMA_BUF_EXT target, the
 *  EGL will take a reference to the dma_buf(s) which it will release at any
 *  time while the EGLDisplay is initialized. It is the responsibility of the
 *  application to close the dma_buf file descriptors."
 *
 * Therefore we must never close or otherwise modify the file descriptors.
 */
static _EGLImage *
dri2_create_image_dma_buf(_EGLDisplay *disp, _EGLContext *ctx,
			  EGLClientBuffer buffer, const EGLint *attr_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   _EGLImage *res;
   EGLint err;
   _EGLImageAttribs attrs;
   __DRIimage *dri_image;
   unsigned num_fds;
   unsigned i;
   int fds[3];
   int pitches[3];
   int offsets[3];
   unsigned error;

   /**
    * The spec says:
    *
    * ""* If <target> is EGL_LINUX_DMA_BUF_EXT and <buffer> is not NULL, the
    *     error EGL_BAD_PARAMETER is generated."
    */
   if (buffer != NULL) {
      _eglError(EGL_BAD_PARAMETER, "buffer not NULL");
      return NULL;
   }

   err = _eglParseImageAttribList(&attrs, disp, attr_list);
   if (err != EGL_SUCCESS) {
      _eglError(err, "bad attribute");
      return NULL;
   }

   if (!dri2_check_dma_buf_attribs(&attrs))
      return NULL;

   num_fds = dri2_check_dma_buf_format(&attrs);
   if (!num_fds)
      return NULL;

   for (i = 0; i < num_fds; ++i) {
      fds[i] = attrs.DMABufPlaneFds[i].Value;
      pitches[i] = attrs.DMABufPlanePitches[i].Value;
      offsets[i] = attrs.DMABufPlaneOffsets[i].Value;
   }

   dri_image =
      dri2_dpy->image->createImageFromDmaBufs(dri2_dpy->dri_screen,
         attrs.Width, attrs.Height, attrs.DMABufFourCC.Value,
         fds, num_fds, pitches, offsets,
         attrs.DMABufYuvColorSpaceHint.Value,
         attrs.DMABufSampleRangeHint.Value,
         attrs.DMABufChromaHorizontalSiting.Value,
         attrs.DMABufChromaVerticalSiting.Value,
         &error,
         NULL);
   dri2_create_image_khr_texture_error(error);

   if (!dri_image)
      return EGL_NO_IMAGE_KHR;

   res = dri2_create_image_from_dri(disp, dri_image);

   return res;
}
#endif

_EGLImage *
dri2_create_image_khr(_EGLDriver *drv, _EGLDisplay *disp,
		      _EGLContext *ctx, EGLenum target,
		      EGLClientBuffer buffer, const EGLint *attr_list)
{
   (void) drv;

   switch (target) {
   case EGL_GL_TEXTURE_2D_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR:
      return dri2_create_image_khr_texture(disp, ctx, target, buffer, attr_list);
   case EGL_GL_RENDERBUFFER_KHR:
      return dri2_create_image_khr_renderbuffer(disp, ctx, buffer, attr_list);
#ifdef HAVE_DRM_PLATFORM
   case EGL_DRM_BUFFER_MESA:
      return dri2_create_image_mesa_drm_buffer(disp, ctx, buffer, attr_list);
#endif
#ifdef HAVE_WAYLAND_PLATFORM
   case EGL_WAYLAND_BUFFER_WL:
      return dri2_create_image_wayland_wl_buffer(disp, ctx, buffer, attr_list);
#endif
#ifdef HAVE_DRM_PLATFORM
   case EGL_LINUX_DMA_BUF_EXT:
      return dri2_create_image_dma_buf(disp, ctx, buffer, attr_list);
#endif
   default:
      _eglError(EGL_BAD_PARAMETER, "dri2_create_image_khr");
      return EGL_NO_IMAGE_KHR;
   }
}

static EGLBoolean
dri2_destroy_image_khr(_EGLDriver *drv, _EGLDisplay *disp, _EGLImage *image)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_image *dri2_img = dri2_egl_image(image);

   (void) drv;

   dri2_dpy->image->destroyImage(dri2_img->dri_image);
   free(dri2_img);

   return EGL_TRUE;
}

#ifdef HAVE_DRM_PLATFORM
static _EGLImage *
dri2_create_drm_image_mesa(_EGLDriver *drv, _EGLDisplay *disp,
			   const EGLint *attr_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_image *dri2_img;
   _EGLImageAttribs attrs;
   unsigned int dri_use, valid_mask;
   int format;
   EGLint err = EGL_SUCCESS;

   (void) drv;

   dri2_img = malloc(sizeof *dri2_img);
   if (!dri2_img) {
      _eglError(EGL_BAD_ALLOC, "dri2_create_image_khr");
      return EGL_NO_IMAGE_KHR;
   }

   if (!attr_list) {
      err = EGL_BAD_PARAMETER;
      goto cleanup_img;
   }

   if (!_eglInitImage(&dri2_img->base, disp)) {
      err = EGL_BAD_PARAMETER;
      goto cleanup_img;
   }

   err = _eglParseImageAttribList(&attrs, disp, attr_list);
   if (err != EGL_SUCCESS)
      goto cleanup_img;

   if (attrs.Width <= 0 || attrs.Height <= 0) {
      _eglLog(_EGL_WARNING, "bad width or height (%dx%d)",
            attrs.Width, attrs.Height);
      goto cleanup_img;
   }

   switch (attrs.DRMBufferFormatMESA) {
   case EGL_DRM_BUFFER_FORMAT_ARGB32_MESA:
      format = __DRI_IMAGE_FORMAT_ARGB8888;
      break;
   default:
      _eglLog(_EGL_WARNING, "bad image format value 0x%04x",
            attrs.DRMBufferFormatMESA);
      goto cleanup_img;
   }

   valid_mask =
      EGL_DRM_BUFFER_USE_SCANOUT_MESA |
      EGL_DRM_BUFFER_USE_SHARE_MESA |
      EGL_DRM_BUFFER_USE_CURSOR_MESA;
   if (attrs.DRMBufferUseMESA & ~valid_mask) {
      _eglLog(_EGL_WARNING, "bad image use bit 0x%04x",
            attrs.DRMBufferUseMESA & ~valid_mask);
      goto cleanup_img;
   }

   dri_use = 0;
   if (attrs.DRMBufferUseMESA & EGL_DRM_BUFFER_USE_SHARE_MESA)
      dri_use |= __DRI_IMAGE_USE_SHARE;
   if (attrs.DRMBufferUseMESA & EGL_DRM_BUFFER_USE_SCANOUT_MESA)
      dri_use |= __DRI_IMAGE_USE_SCANOUT;
   if (attrs.DRMBufferUseMESA & EGL_DRM_BUFFER_USE_CURSOR_MESA)
      dri_use |= __DRI_IMAGE_USE_CURSOR;

   dri2_img->dri_image = 
      dri2_dpy->image->createImage(dri2_dpy->dri_screen,
				   attrs.Width, attrs.Height,
                                   format, dri_use, dri2_img);
   if (dri2_img->dri_image == NULL) {
      err = EGL_BAD_ALLOC;
      goto cleanup_img;
   }

   return &dri2_img->base;

 cleanup_img:
   free(dri2_img);
   _eglError(err, "dri2_create_drm_image_mesa");

   return EGL_NO_IMAGE_KHR;
}

static EGLBoolean
dri2_export_drm_image_mesa(_EGLDriver *drv, _EGLDisplay *disp, _EGLImage *img,
			  EGLint *name, EGLint *handle, EGLint *stride)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_image *dri2_img = dri2_egl_image(img);

   (void) drv;

   if (name && !dri2_dpy->image->queryImage(dri2_img->dri_image,
					    __DRI_IMAGE_ATTRIB_NAME, name)) {
      _eglError(EGL_BAD_ALLOC, "dri2_export_drm_image_mesa");
      return EGL_FALSE;
   }

   if (handle)
      dri2_dpy->image->queryImage(dri2_img->dri_image,
				  __DRI_IMAGE_ATTRIB_HANDLE, handle);

   if (stride)
      dri2_dpy->image->queryImage(dri2_img->dri_image,
				  __DRI_IMAGE_ATTRIB_STRIDE, stride);

   return EGL_TRUE;
}
#endif

#ifdef HAVE_WAYLAND_PLATFORM

static void
dri2_wl_reference_buffer(void *user_data, uint32_t name, int fd,
                         struct wl_drm_buffer *buffer)
{
   _EGLDisplay *disp = user_data;
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   __DRIimage *img;
   int i, dri_components = 0;

   if (fd == -1)
      img = dri2_dpy->image->createImageFromNames(dri2_dpy->dri_screen,
                                                  buffer->width,
                                                  buffer->height,
                                                  buffer->format,
                                                  (int*)&name, 1,
                                                  buffer->stride,
                                                  buffer->offset,
                                                  NULL);
   else
      img = dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen,
                                                buffer->width,
                                                buffer->height,
                                                buffer->format,
                                                &fd, 1,
                                                buffer->stride,
                                                buffer->offset,
                                                NULL);

   if (img == NULL)
      return;

   dri2_dpy->image->queryImage(img, __DRI_IMAGE_ATTRIB_COMPONENTS, &dri_components);

   buffer->driver_format = NULL;
   for (i = 0; i < ARRAY_SIZE(wl_drm_components); i++)
      if (wl_drm_components[i].dri_components == dri_components)
         buffer->driver_format = &wl_drm_components[i];

   if (buffer->driver_format == NULL)
      dri2_dpy->image->destroyImage(img);
   else
      buffer->driver_buffer = img;
}

static void
dri2_wl_release_buffer(void *user_data, struct wl_drm_buffer *buffer)
{
   _EGLDisplay *disp = user_data;
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);

   dri2_dpy->image->destroyImage(buffer->driver_buffer);
}

static struct wayland_drm_callbacks wl_drm_callbacks = {
	.authenticate = NULL,
	.reference_buffer = dri2_wl_reference_buffer,
	.release_buffer = dri2_wl_release_buffer
};

static EGLBoolean
dri2_bind_wayland_display_wl(_EGLDriver *drv, _EGLDisplay *disp,
			     struct wl_display *wl_dpy)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   int ret, flags = 0;
   uint64_t cap;

   (void) drv;

   if (dri2_dpy->wl_server_drm)
	   return EGL_FALSE;

   wl_drm_callbacks.authenticate =
      (int(*)(void *, uint32_t)) dri2_dpy->vtbl->authenticate;

   ret = drmGetCap(dri2_dpy->fd, DRM_CAP_PRIME, &cap);
   if (ret == 0 && cap == (DRM_PRIME_CAP_IMPORT | DRM_PRIME_CAP_EXPORT) &&
       dri2_dpy->image->base.version >= 7 &&
       dri2_dpy->image->createImageFromFds != NULL)
      flags |= WAYLAND_DRM_PRIME;

   dri2_dpy->wl_server_drm =
	   wayland_drm_init(wl_dpy, dri2_dpy->device_name,
                            &wl_drm_callbacks, disp, flags);

   if (!dri2_dpy->wl_server_drm)
	   return EGL_FALSE;

#ifdef HAVE_DRM_PLATFORM
   /* We have to share the wl_drm instance with gbm, so gbm can convert
    * wl_buffers to gbm bos. */
   if (dri2_dpy->gbm_dri)
      dri2_dpy->gbm_dri->wl_drm = dri2_dpy->wl_server_drm;
#endif

   return EGL_TRUE;
}

static EGLBoolean
dri2_unbind_wayland_display_wl(_EGLDriver *drv, _EGLDisplay *disp,
			       struct wl_display *wl_dpy)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);

   (void) drv;

   if (!dri2_dpy->wl_server_drm)
	   return EGL_FALSE;

   wayland_drm_uninit(dri2_dpy->wl_server_drm);
   dri2_dpy->wl_server_drm = NULL;

   return EGL_TRUE;
}

static EGLBoolean
dri2_query_wayland_buffer_wl(_EGLDriver *drv, _EGLDisplay *disp,
                             struct wl_resource *buffer_resource,
                             EGLint attribute, EGLint *value)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct wl_drm_buffer *buffer;
   const struct wl_drm_components_descriptor *format;

   buffer = wayland_drm_buffer_get(dri2_dpy->wl_server_drm, buffer_resource);
   if (!buffer)
      return EGL_FALSE;

   format = buffer->driver_format;
   switch (attribute) {
   case EGL_TEXTURE_FORMAT:
      *value = format->components;
      return EGL_TRUE;
   case EGL_WIDTH:
      *value = buffer->width;
      return EGL_TRUE;
   case EGL_HEIGHT:
      *value = buffer->height;
      return EGL_TRUE;
   }

   return EGL_FALSE;
}
#endif

static void
dri2_unload(_EGLDriver *drv)
{
   struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);

   if (dri2_drv->handle)
      dlclose(dri2_drv->handle);
   free(dri2_drv);
}

static EGLBoolean
dri2_load(_EGLDriver *drv)
{
   struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);
#ifdef HAVE_SHARED_GLAPI
#ifdef HAVE_ANDROID_PLATFORM
   const char *libname = "libglapi.so";
#else
   const char *libname = "libglapi.so.0";
#endif
#else
   /*
    * Both libGL.so and libglapi.so are glapi providers.  There is no way to
    * tell which one to load.
    */
   const char *libname = NULL;
#endif
   void *handle;

   /* RTLD_GLOBAL to make sure glapi symbols are visible to DRI drivers */
   handle = dlopen(libname, RTLD_LAZY | RTLD_GLOBAL);
   if (handle) {
      dri2_drv->get_proc_address = (_EGLProc (*)(const char *))
         dlsym(handle, "_glapi_get_proc_address");
      if (!dri2_drv->get_proc_address || !libname) {
         /* no need to keep a reference */
         dlclose(handle);
         handle = NULL;
      }
   }

   /* if glapi is not available, loading DRI drivers will fail */
   if (!dri2_drv->get_proc_address) {
      _eglLog(_EGL_WARNING, "DRI2: failed to find _glapi_get_proc_address");
      return EGL_FALSE;
   }

   dri2_drv->glFlush = (void (*)(void))
      dri2_drv->get_proc_address("glFlush");

   dri2_drv->handle = handle;

   return EGL_TRUE;
}

/**
 * This is the main entrypoint into the driver, called by libEGL.
 * Create a new _EGLDriver object and init its dispatch table.
 */
_EGLDriver *
_eglBuiltInDriverDRI2(const char *args)
{
   struct dri2_egl_driver *dri2_drv;

   (void) args;

   dri2_drv = calloc(1, sizeof *dri2_drv);
   if (!dri2_drv)
      return NULL;

   if (!dri2_load(&dri2_drv->base)) {
      free(dri2_drv);
      return NULL;
   }

   _eglInitDriverFallbacks(&dri2_drv->base);
   dri2_drv->base.API.Initialize = dri2_initialize;
   dri2_drv->base.API.Terminate = dri2_terminate;
   dri2_drv->base.API.CreateContext = dri2_create_context;
   dri2_drv->base.API.DestroyContext = dri2_destroy_context;
   dri2_drv->base.API.MakeCurrent = dri2_make_current;
   dri2_drv->base.API.CreateWindowSurface = dri2_create_window_surface;
   dri2_drv->base.API.CreatePixmapSurface = dri2_create_pixmap_surface;
   dri2_drv->base.API.CreatePbufferSurface = dri2_create_pbuffer_surface;
   dri2_drv->base.API.DestroySurface = dri2_destroy_surface;
   dri2_drv->base.API.GetProcAddress = dri2_get_proc_address;
   dri2_drv->base.API.WaitClient = dri2_wait_client;
   dri2_drv->base.API.WaitNative = dri2_wait_native;
   dri2_drv->base.API.BindTexImage = dri2_bind_tex_image;
   dri2_drv->base.API.ReleaseTexImage = dri2_release_tex_image;
   dri2_drv->base.API.SwapInterval = dri2_swap_interval;
   dri2_drv->base.API.SwapBuffers = dri2_swap_buffers;
   dri2_drv->base.API.SwapBuffersWithDamageEXT = dri2_swap_buffers_with_damage;
   dri2_drv->base.API.SwapBuffersRegionNOK = dri2_swap_buffers_region;
   dri2_drv->base.API.PostSubBufferNV = dri2_post_sub_buffer;
   dri2_drv->base.API.CopyBuffers = dri2_copy_buffers,
   dri2_drv->base.API.QueryBufferAge = dri2_query_buffer_age;
   dri2_drv->base.API.CreateImageKHR = dri2_create_image;
   dri2_drv->base.API.DestroyImageKHR = dri2_destroy_image_khr;
   dri2_drv->base.API.CreateWaylandBufferFromImageWL = dri2_create_wayland_buffer_from_image;
#ifdef HAVE_DRM_PLATFORM
   dri2_drv->base.API.CreateDRMImageMESA = dri2_create_drm_image_mesa;
   dri2_drv->base.API.ExportDRMImageMESA = dri2_export_drm_image_mesa;
#endif
#ifdef HAVE_WAYLAND_PLATFORM
   dri2_drv->base.API.BindWaylandDisplayWL = dri2_bind_wayland_display_wl;
   dri2_drv->base.API.UnbindWaylandDisplayWL = dri2_unbind_wayland_display_wl;
   dri2_drv->base.API.QueryWaylandBufferWL = dri2_query_wayland_buffer_wl;
#endif

   dri2_drv->base.Name = "DRI2";
   dri2_drv->base.Unload = dri2_unload;

   return &dri2_drv->base;
}
@


1.9
log
@Merge Mesa 10.2.9
@
text
@@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d38 1
a38 1
#ifdef HAVE_LIBDRM
d307 2
d363 1
a363 1
	 _eglLog(_EGL_WARNING, "DRI2: did not find extension %s version %d",
d472 1
d474 1
d525 1
a525 9
      if (dri2_dpy->image->base.version >= 10 &&
          dri2_dpy->image->getCapabilities != NULL) {
         int capabilities;

         capabilities = dri2_dpy->image->getCapabilities(dri2_dpy->dri_screen);
         disp->Extensions.MESA_drm_image = (capabilities & __DRI_IMAGE_CAP_GLOBAL_NAMES) != 0;
      } else
         disp->Extensions.MESA_drm_image = EGL_TRUE;

a541 4
/* All platforms but DRM call this function to create the screen, query the
 * dri extensions, setup the vtables and populate the driver_configs.
 * DRM inherits all that information from its display - GBM.
 */
a664 1
   unsigned i;
a675 1
   free(dri2_dpy->driver_name);
a703 9
   /* The drm platform does not create the screen/driver_configs but reuses
    * the ones from the gbm device. As such the gbm itself is responsible
    * for the cleanup.
    */
   if (disp->Platform != _EGL_PLATFORM_DRM) {
      for (i = 0; dri2_dpy->driver_configs[i]; i++)
         free((__DRIconfig *) dri2_dpy->driver_configs[i]);
      free(dri2_dpy->driver_configs);
   }
d814 2
a815 3
         _eglError(EGL_BAD_PARAMETER, "eglCreateContext");
         free(dri2_ctx);
         return NULL;
a1390 9
static EGLBoolean
dri2_get_sync_values_chromium(_EGLDisplay *dpy, _EGLSurface *surf,
                              EGLuint64KHR *ust, EGLuint64KHR *msc,
                              EGLuint64KHR *sbc)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->get_sync_values(dpy, surf, ust, msc, sbc);
}

d1969 1
a1969 1
   int flags = 0;
d1980 2
a1981 3
#ifdef HAVE_LIBDRM
   if (drmGetCap(dri2_dpy->fd, DRM_CAP_PRIME, &cap) == 0 &&
       cap == (DRM_PRIME_CAP_IMPORT | DRM_PRIME_CAP_EXPORT) &&
a1984 1
#endif
a2158 1
   dri2_drv->base.API.GetSyncValuesCHROMIUM = dri2_get_sync_values_chromium;
@


1.7
log
@Merge Mesa 10.2.7
@
text
@d38 1
a38 1
#ifdef HAVE_DRM_PLATFORM
a306 2
static const char dri_driver_path[] = DEFAULT_DRIVER_DIR;

d361 1
a361 1
	 _eglLog(_EGL_FATAL, "DRI2: did not find extension %s version %d",
a469 1
   dri2_dpy->driver_name = "swrast";
a470 1

d521 9
a529 1
      disp->Extensions.MESA_drm_image = EGL_TRUE;
d546 4
d673 1
d685 1
d714 9
d833 3
a835 2
	 _eglError(EGL_BAD_PARAMETER, "eglCreateContext");
	 return NULL;
d1411 9
d1998 1
a1998 1
   int ret, flags = 0;
d2009 3
a2011 2
   ret = drmGetCap(dri2_dpy->fd, DRM_CAP_PRIME, &cap);
   if (ret == 0 && cap == (DRM_PRIME_CAP_IMPORT | DRM_PRIME_CAP_EXPORT) &&
d2015 1
d2190 1
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1666 6
a1671 4
 * "If eglCreateImageKHR is successful for a EGL_LINUX_DMA_BUF_EXT target,
 *  the EGL takes ownership of the file descriptor and is responsible for
 *  closing it, which it may do at any time while the EGLDisplay is
 *  initialized."
a1672 25
static void
dri2_take_dma_buf_ownership(const int *fds, unsigned num_fds)
{
   int already_closed[num_fds];
   unsigned num_closed = 0;
   unsigned i, j;

   for (i = 0; i < num_fds; ++i) {
      /**
       * The same file descriptor can be referenced multiple times in case more
       * than one plane is found in the same buffer, just with a different
       * offset.
       */
      for (j = 0; j < num_closed; ++j) {
         if (already_closed[j] == fds[i])
            break;
      }

      if (j == num_closed) {
         close(fds[i]);
         already_closed[num_closed++] = fds[i];
      }
   }
}

a1734 2
   if (res)
      dri2_take_dma_buf_ownership(fds, num_fds);
@


1.5
log
@Merge Mesa 9.2.3
ok mpi@@ kettenis@@
@
text
@d28 2
d38 1
d40 2
d47 5
d55 1
a55 1
   { __DRI_USE_INVALIDATE, 1 }
d124 1
a124 1
		int depth, EGLint surface_type, const EGLint *attr_list,
a207 10
   /* Allow a 24-bit RGB visual to match a 32-bit RGBA EGLConfig.  Otherwise
    * it will only match a 32-bit RGBA visual.  On a composited window manager
    * on X11, this will make all of the EGLConfigs with destination alpha get
    * blended by the compositor.  This is probably not what the application
    * wants... especially on drivers that only have 32-bit RGBA EGLConfigs!
    */
   if (depth > 0 && depth != base.BufferSize
       && !(depth == 24 && base.BufferSize == 32))
      return NULL;

d302 3
a304 2
   { __DRI_IMAGE_LOOKUP, 1 },
   dri2_lookup_egl_image
d376 1
a376 1
   const __DRIextension **extensions;
d378 2
d410 3
d423 15
a437 1
   extensions = dlsym(dri2_dpy->driver, __DRI_DRIVER_EXTENSIONS);
d461 1
d482 1
d515 1
d533 6
d551 12
a562 3
      dri2_dpy->dri_screen =
         dri2_dpy->dri2->createNewScreen(0, dri2_dpy->fd, dri2_dpy->extensions,
				         &dri2_dpy->driver_configs, disp);
d565 10
a574 3
      dri2_dpy->dri_screen =
         dri2_dpy->swrast->createNewScreen(0, dri2_dpy->extensions,
                                           &dri2_dpy->driver_configs, disp);
a633 1
#ifdef HAVE_LIBUDEV
a645 1
#endif
d677 1
a677 2
   if (disp->PlatformDisplay == NULL) {
      switch (disp->Platform) {
d679 2
a680 1
      case _EGL_PLATFORM_X11:
d682 2
a683 1
         break;
d686 5
a690 5
      case _EGL_PLATFORM_DRM:
         if (dri2_dpy->own_device) {
            gbm_device_destroy(&dri2_dpy->gbm_dri->base.base);
         }
         break;
d692 5
a696 2
      default:
         break;
d698 4
d1026 91
a1192 1
#if __DRI_TEX_BUFFER_VERSION >= 3
d1212 7
a1218 5
   if (dri2_dpy->tex_buffer->releaseTexBuffer!=NULL)
    (*dri2_dpy->tex_buffer->releaseTexBuffer)(dri2_ctx->dri_context,
                                             target,
                                             dri2_surf->dri_drawable);
#endif
d1223 10
d1234 1
a1234 1
dri2_create_image(_EGLDisplay *disp, __DRIimage *dri_image)
d1278 1
a1278 1
   return dri2_create_image(disp, dri_image);
d1281 1
d1324 1
a1324 1
   return dri2_create_image(disp, dri_image);
d1326 1
d1353 1
a1353 1
   struct wl_drm_buffer *buffer = (struct wl_drm_buffer *) _buffer;
d1361 3
a1363 1
   if (!wayland_buffer_is_drm(dri2_dpy->wl_server_drm, &buffer->buffer))
d1387 1
a1387 1
   return dri2_create_image(disp, dri_image);
d1500 265
d1783 1
d1786 1
d1791 4
d1815 1
d1926 1
d1941 2
a1942 2
                                                  buffer->buffer.width,
                                                  buffer->buffer.height,
d1950 2
a1951 2
                                                buffer->buffer.width,
                                                buffer->buffer.height,
d2003 1
a2003 1
      (int(*)(void *, uint32_t)) dri2_dpy->authenticate;
d2019 2
d2047 1
a2047 1
                             struct wl_buffer *_buffer,
a2049 1
   struct wl_drm_buffer *buffer = (struct wl_drm_buffer *) _buffer;
d2051 1
d2054 2
a2055 1
   if (!wayland_buffer_is_drm(dri2_dpy->wl_server_drm, &buffer->buffer))
d2064 1
a2064 1
      *value = buffer->buffer.width;
d2067 1
a2067 1
      *value = buffer->buffer.height;
d2156 4
d2165 8
a2172 1
   dri2_drv->base.API.CreateImageKHR = dri2_create_image_khr;
d2174 2
d2178 1
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d1206 1
a1206 1
   if (!wayland_buffer_is_drm(&buffer->buffer))
d1588 5
d1619 1
d1622 1
a1622 1
   if (!wayland_buffer_is_drm(&buffer->buffer))
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d78 1
a78 1
   0,				/* __DRI_ATTRIB_FLOAT_MODE */
d114 2
a115 1
		int depth, EGLint surface_type, const EGLint *attr_list)
d122 1
d144 1
a144 1
	    /* not valid */;
d170 16
d198 11
a208 1
   if (depth > 0 && depth != base.BufferSize)
d224 3
d272 5
a276 2
   conf->base.SurfaceType |= surface_type & (!double_buffer ? EGL_PIXMAP_BIT:
         (EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT));
d316 1
a316 1
   { __DRI_DRI2, 1, offsetof(struct dri2_egl_display, dri2) },
d330 1
a330 1
   { NULL }
d335 1
a335 1
   { NULL }
a452 5
   if (!extensions) {
      /* try again with swrastg */
      dri2_dpy->driver_name = "swrastg";
      extensions = dri2_open_driver(disp);
   }
d472 1
a472 4
      if (dri2_dpy->dri2->base.version >= 2)
         api_mask = dri2_dpy->dri2->getAPIMask(dri2_dpy->dri_screen);
      else
         api_mask = 1 << __DRI_API_OPENGL;
d475 4
a478 4
      if (dri2_dpy->swrast->base.version >= 2)
         api_mask = 1 << __DRI_API_OPENGL | 1 << __DRI_API_GLES | 1 << __DRI_API_GLES2;
      else
         api_mask = 1 << __DRI_API_OPENGL;
d488 2
d491 8
a498 13
   if (dri2_dpy->dri2) {
      if (dri2_dpy->dri2->base.version >= 2) {
         disp->Extensions.KHR_surfaceless_gles1 = EGL_TRUE;
         disp->Extensions.KHR_surfaceless_gles2 = EGL_TRUE;
         disp->Extensions.KHR_surfaceless_opengl = EGL_TRUE;
      }
   } else {
      assert(dri2_dpy->swrast);
      if (dri2_dpy->swrast->base.version >= 2) {
         disp->Extensions.KHR_surfaceless_gles1 = EGL_TRUE;
         disp->Extensions.KHR_surfaceless_gles2 = EGL_TRUE;
         disp->Extensions.KHR_surfaceless_opengl = EGL_TRUE;
      }
d505 5
d542 2
d546 9
d603 6
d632 1
d641 5
a645 3
#ifdef HAVE_WAYLAND_PLATFORM
      case _EGL_PLATFORM_WAYLAND:
         wl_display_destroy(dri2_dpy->wl_dpy);
d659 63
d733 2
d752 1
a752 1
      switch (dri2_ctx->base.ClientVersion) {
d759 3
d768 7
a774 1
      api = __DRI_API_OPENGL;
d778 1
d794 6
d805 52
a856 1
      if (dri2_dpy->dri2->base.version >= 2) {
d861 1
a861 2
						   dri2_ctx_shared ? 
						   dri2_ctx_shared->dri_context : NULL,
a862 9
      } else if (api == __DRI_API_OPENGL) {
	 dri2_ctx->dri_context =
	    dri2_dpy->dri2->createNewContext(dri2_dpy->dri_screen,
					     dri_config,
					     dri2_ctx_shared ? 
					     dri2_ctx_shared->dri_context : NULL,
					     dri2_ctx);
      } else {
	 /* fail */
d866 6
a871 18
      if (dri2_dpy->swrast->base.version >= 2) {
	 dri2_ctx->dri_context =
	    dri2_dpy->swrast->createNewContextForAPI(dri2_dpy->dri_screen,
						     api,
						     dri_config,
						     dri2_ctx_shared ? 
						     dri2_ctx_shared->dri_context : NULL,
						     dri2_ctx);
      } else if (api == __DRI_API_OPENGL) {
	 dri2_ctx->dri_context =
	    dri2_dpy->core->createNewContext(dri2_dpy->dri_screen,
					     dri_config,
					     dri2_ctx_shared ?
					     dri2_ctx_shared->dri_context : NULL,
					     dri2_ctx);
      } else {
	 /* fail */
      }
d885 17
a940 1
      /* no destroy? */
d942 1
a942 1
         _eglPutContext(old_ctx);
d986 2
a987 1
   (*dri2_dpy->flush->flush)(dri2_surf->dri_drawable);
d1081 26
a1112 1
   struct dri2_egl_image *dri2_img;
d1114 1
d1121 1
a1121 10
   dri2_img = malloc(sizeof *dri2_img);
   if (!dri2_img) {
      _eglError(EGL_BAD_ALLOC, "dri2_create_image_khr");
      return EGL_NO_IMAGE_KHR;
   }

   if (!_eglInitImage(&dri2_img->base, disp))
      return EGL_NO_IMAGE_KHR;

   dri2_img->dri_image = 
d1123 1
a1123 2
						   renderbuffer,
						   dri2_img);
d1125 1
a1125 1
   return &dri2_img->base;
a1132 1
   struct dri2_egl_image *dri2_img;
d1135 1
a1135 2

   (void) ctx;
d1161 1
a1161 12
   dri2_img = malloc(sizeof *dri2_img);
   if (!dri2_img) {
      _eglError(EGL_BAD_ALLOC, "dri2_create_image_mesa_drm");
      return NULL;
   }

   if (!_eglInitImage(&dri2_img->base, disp)) {
      free(dri2_img);
      return NULL;
   }

   dri2_img->dri_image =
d1168 1
a1168 6
					   dri2_img);
   if (dri2_img->dri_image == NULL) {
      free(dri2_img);
      _eglError(EGL_BAD_ALLOC, "dri2_create_image_mesa_drm");
      return NULL;
   }
d1170 1
a1170 1
   return &dri2_img->base;
a1173 16
static _EGLImage *
dri2_reference_drm_image(_EGLDisplay *disp, _EGLContext *ctx,
			 __DRIimage *dri_image, EGLint width, EGLint height)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   EGLint attr_list[] = {
		EGL_WIDTH,		0,
		EGL_HEIGHT,		0,
		EGL_DRM_BUFFER_STRIDE_MESA,	0,
		EGL_DRM_BUFFER_FORMAT_MESA,	EGL_DRM_BUFFER_FORMAT_ARGB32_MESA,
		EGL_NONE
   };
   EGLint name, stride;
   
   dri2_dpy->image->queryImage(dri_image, __DRI_IMAGE_ATTRIB_NAME, &name);
   dri2_dpy->image->queryImage(dri_image, __DRI_IMAGE_ATTRIB_STRIDE, &stride);
d1175 17
a1191 8
   attr_list[1] = width;
   attr_list[3] = height;
   attr_list[5] = stride / 4;

   return dri2_create_image_mesa_drm_buffer(disp, ctx,
					    (EGLClientBuffer)(intptr_t) name,
					    attr_list);
}
d1198 7
a1204 2
   struct wl_buffer *buffer = (struct wl_buffer *) _buffer;
   (void) attr_list;
d1206 1
a1206 1
   if (!wayland_buffer_is_drm(buffer))
d1209 22
a1230 4
   return dri2_reference_drm_image(disp, ctx,
                                   wayland_drm_buffer_get_buffer(buffer),
                                   buffer->width,
                                   buffer->height);
d1234 109
d1351 8
d1500 3
a1502 4
static void *
dri2_wl_reference_buffer(void *user_data, uint32_t name,
			 int32_t width, int32_t height,
			 uint32_t stride, struct wl_visual *visual)
d1506 2
a1507 1
   __DRIimage *image;
d1509 28
a1536 5
   image = dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen,
						width, height, 
						__DRI_IMAGE_FORMAT_ARGB8888,
						name, stride / 4,
						NULL);
d1538 4
a1541 1
   return image;
d1545 1
a1545 1
dri2_wl_release_buffer(void *user_data, void *buffer)
a1547 1
   __DRIimage *image = buffer;
d1550 1
a1550 1
   dri2_dpy->image->destroyImage(image);
d1564 2
d1575 6
d1583 1
a1583 1
                            &wl_drm_callbacks, disp);
d1607 27
d1651 3
d1655 1
d1696 1
a1696 1
_EGL_MAIN(const char *args)
d1702 1
a1702 1
   dri2_drv = malloc(sizeof *dri2_drv);
d1706 2
a1707 3
   memset(dri2_drv, 0, sizeof *dri2_drv);

   if (!dri2_load(&dri2_drv->base))
d1709 1
d1715 1
d1729 1
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a38 4
#include <xcb/xcb.h>
#include <xcb/dri2.h>
#include <xcb/xfixes.h>
#include <X11/Xlib-xcb.h>
d42 1
a42 50
#ifdef HAVE_LIBUDEV
#include <libudev.h>
#endif

#include <glapi/glapi.h>
#include "eglconfig.h"
#include "eglcontext.h"
#include "egldisplay.h"
#include "egldriver.h"
#include "eglcurrent.h"
#include "egllog.h"
#include "eglsurface.h"
#include "eglimage.h"

#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))

struct dri2_egl_driver
{
   _EGLDriver base;

   void (*glFlush)(void);
};

struct dri2_egl_display
{
   xcb_connection_t         *conn;
   int                       dri2_major;
   int                       dri2_minor;
   __DRIscreen              *dri_screen;
   const __DRIconfig       **driver_configs;
   void                     *driver;
   __DRIcoreExtension       *core;
   __DRIdri2Extension       *dri2;
   __DRI2flushExtension     *flush;
   __DRItexBufferExtension  *tex_buffer;
   __DRIimageExtension      *image;
   int                       fd;

   char                     *device_name;
   char                     *driver_name;

   __DRIdri2LoaderExtension  loader_extension;
   const __DRIextension     *extensions[3];
};

struct dri2_egl_context
{
   _EGLContext   base;
   __DRIcontext *dri_context;
};
d44 1
a44 29
struct dri2_egl_surface
{
   _EGLSurface          base;
   __DRIdrawable       *dri_drawable;
   xcb_drawable_t       drawable;
   __DRIbuffer          buffers[5];
   int                  buffer_count;
   xcb_xfixes_region_t  region;
   int                  have_fake_front;
   int                  swap_interval;
};

struct dri2_egl_config
{
   _EGLConfig         base;
   const __DRIconfig *dri_config;
};

struct dri2_egl_image
{
   _EGLImage   base;
   __DRIimage *dri_image;
};

/* standard typecasts */
_EGL_DRIVER_STANDARD_TYPECASTS(dri2_egl)
_EGL_DRIVER_TYPECAST(dri2_egl_image, _EGLImage, obj)

static const __DRIuseInvalidateExtension use_invalidate = {
d97 1
d100 13
a112 1
static struct dri2_egl_config *
d114 1
a114 1
		int depth, EGLint surface_type)
d121 3
d176 3
a178 9
   /* In EGL, double buffer or not isn't a config attribute.  Pixmaps
    * surfaces are always single buffered, pbuffer surfaces are always
    * back buffers and windows can be either, selected by passing an
    * attribute at window surface construction time.  To support this
    * we ignore all double buffer configs and manipulate the buffer we
    * return in the getBuffer callback to get the behaviour we want. */

   if (double_buffer)
      return NULL;
d186 2
a187 1
   if (surface_type & (EGL_PIXMAP_BIT | EGL_PBUFFER_BIT)) {
d193 2
a194 2
   base.RenderableType = disp->ClientAPIsMask;
   base.Conformant = disp->ClientAPIsMask;
d201 22
a222 2
   conf = malloc(sizeof *conf);
   if (conf != NULL) {
d224 10
a233 1
      conf->dri_config = dri_config;
d236 2
a237 72

   return conf;
}

/**
 * Process list of buffer received from the server
 *
 * Processes the list of buffers received in a reply from the server to either
 * \c DRI2GetBuffers or \c DRI2GetBuffersWithFormat.
 */
static void
dri2_process_buffers(struct dri2_egl_surface *dri2_surf,
		     xcb_dri2_dri2_buffer_t *buffers, unsigned count)
{
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);
   xcb_rectangle_t rectangle;
   unsigned i;

   dri2_surf->buffer_count = count;
   dri2_surf->have_fake_front = 0;

   /* This assumes the DRI2 buffer attachment tokens matches the
    * __DRIbuffer tokens. */
   for (i = 0; i < count; i++) {
      dri2_surf->buffers[i].attachment = buffers[i].attachment;
      dri2_surf->buffers[i].name = buffers[i].name;
      dri2_surf->buffers[i].pitch = buffers[i].pitch;
      dri2_surf->buffers[i].cpp = buffers[i].cpp;
      dri2_surf->buffers[i].flags = buffers[i].flags;

      /* We only use the DRI drivers single buffer configs.  This
       * means that if we try to render to a window, DRI2 will give us
       * the fake front buffer, which we'll use as a back buffer.
       * Note that EGL doesn't require that several clients rendering
       * to the same window must see the same aux buffers. */
      if (dri2_surf->buffers[i].attachment == __DRI_BUFFER_FAKE_FRONT_LEFT)
         dri2_surf->have_fake_front = 1;
   }

   if (dri2_surf->region != XCB_NONE)
      xcb_xfixes_destroy_region(dri2_dpy->conn, dri2_surf->region);

   rectangle.x = 0;
   rectangle.y = 0;
   rectangle.width = dri2_surf->base.Width;
   rectangle.height = dri2_surf->base.Height;
   dri2_surf->region = xcb_generate_id(dri2_dpy->conn);
   xcb_xfixes_create_region(dri2_dpy->conn, dri2_surf->region, 1, &rectangle);
}

static __DRIbuffer *
dri2_get_buffers(__DRIdrawable * driDrawable,
		int *width, int *height,
		unsigned int *attachments, int count,
		int *out_count, void *loaderPrivate)
{
   struct dri2_egl_surface *dri2_surf = loaderPrivate;
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);
   xcb_dri2_dri2_buffer_t *buffers;
   xcb_dri2_get_buffers_reply_t *reply;
   xcb_dri2_get_buffers_cookie_t cookie;

   (void) driDrawable;

   cookie = xcb_dri2_get_buffers_unchecked (dri2_dpy->conn,
					    dri2_surf->drawable,
					    count, count, attachments);
   reply = xcb_dri2_get_buffers_reply (dri2_dpy->conn, cookie, NULL);
   buffers = xcb_dri2_get_buffers_buffers (reply);
   if (buffers == NULL)
d239 1
d241 2
a242 4
   *out_count = reply->count;
   dri2_surf->base.Width = *width = reply->width;
   dri2_surf->base.Height = *height = reply->height;
   dri2_process_buffers(dri2_surf, buffers, *out_count);		       
d244 1
a244 19
   free(reply);

   return dri2_surf->buffers;
}

static void
dri2_flush_front_buffer(__DRIdrawable * driDrawable, void *loaderPrivate)
{
   (void) driDrawable;

   /* FIXME: Does EGL support front buffer rendering at all? */

#if 0
   struct dri2_egl_surface *dri2_surf = loaderPrivate;

   dri2WaitGL(dri2_surf);
#else
   (void) loaderPrivate;
#endif
d247 1
a247 1
static __DRIimage *
d267 1
a267 1
static const __DRIimageLookupExtension image_lookup_extension = {
a271 38
static __DRIbuffer *
dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
			     int *width, int *height,
			     unsigned int *attachments, int count,
			     int *out_count, void *loaderPrivate)
{
   struct dri2_egl_surface *dri2_surf = loaderPrivate;
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);
   xcb_dri2_dri2_buffer_t *buffers;
   xcb_dri2_get_buffers_with_format_reply_t *reply;
   xcb_dri2_get_buffers_with_format_cookie_t cookie;
   xcb_dri2_attach_format_t *format_attachments;

   (void) driDrawable;

   format_attachments = (xcb_dri2_attach_format_t *) attachments;
   cookie = xcb_dri2_get_buffers_with_format_unchecked (dri2_dpy->conn,
							dri2_surf->drawable,
							count, count,
							format_attachments);

   reply = xcb_dri2_get_buffers_with_format_reply (dri2_dpy->conn,
						   cookie, NULL);
   if (reply == NULL)
      return NULL;

   buffers = xcb_dri2_get_buffers_with_format_buffers (reply);
   dri2_surf->base.Width = *width = reply->width;
   dri2_surf->base.Height = *height = reply->height;
   *out_count = reply->count;
   dri2_process_buffers(dri2_surf, buffers, *out_count);		       

   free(reply);

   return dri2_surf->buffers;
}

d293 11
d337 2
a338 175
static char *
dri2_strndup(const char *s, int length)
{
   char *d;

   d = malloc(length + 1);
   if (d == NULL)
      return NULL;

   memcpy(d, s, length);
   d[length] = '\0';

   return d;
}

static EGLBoolean
dri2_connect(struct dri2_egl_display *dri2_dpy)
{
   xcb_xfixes_query_version_reply_t *xfixes_query;
   xcb_xfixes_query_version_cookie_t xfixes_query_cookie;
   xcb_dri2_query_version_reply_t *dri2_query;
   xcb_dri2_query_version_cookie_t dri2_query_cookie;
   xcb_dri2_connect_reply_t *connect;
   xcb_dri2_connect_cookie_t connect_cookie;
   xcb_generic_error_t *error;
   xcb_screen_iterator_t s;

   xcb_prefetch_extension_data (dri2_dpy->conn, &xcb_xfixes_id);
   xcb_prefetch_extension_data (dri2_dpy->conn, &xcb_dri2_id);

   xfixes_query_cookie = xcb_xfixes_query_version(dri2_dpy->conn,
						  XCB_XFIXES_MAJOR_VERSION,
						  XCB_XFIXES_MINOR_VERSION);
   
   dri2_query_cookie = xcb_dri2_query_version (dri2_dpy->conn,
					       XCB_DRI2_MAJOR_VERSION,
					       XCB_DRI2_MINOR_VERSION);

   s = xcb_setup_roots_iterator(xcb_get_setup(dri2_dpy->conn));
   connect_cookie = xcb_dri2_connect_unchecked (dri2_dpy->conn,
						s.data->root,
						XCB_DRI2_DRIVER_TYPE_DRI);
   
   xfixes_query =
      xcb_xfixes_query_version_reply (dri2_dpy->conn,
				      xfixes_query_cookie, &error);
   if (xfixes_query == NULL ||
       error != NULL || xfixes_query->major_version < 2) {
      _eglLog(_EGL_FATAL, "DRI2: failed to query xfixes version");
      free(error);
      return EGL_FALSE;
   }
   free(xfixes_query);

   dri2_query =
      xcb_dri2_query_version_reply (dri2_dpy->conn, dri2_query_cookie, &error);
   if (dri2_query == NULL || error != NULL) {
      _eglLog(_EGL_FATAL, "DRI2: failed to query version");
      free(error);
      return EGL_FALSE;
   }
   dri2_dpy->dri2_major = dri2_query->major_version;
   dri2_dpy->dri2_minor = dri2_query->minor_version;
   free(dri2_query);

   connect = xcb_dri2_connect_reply (dri2_dpy->conn, connect_cookie, NULL);
   if (connect == NULL ||
       connect->driver_name_length + connect->device_name_length == 0) {
      _eglLog(_EGL_FATAL, "DRI2: failed to authenticate");
      return EGL_FALSE;
   }

   dri2_dpy->device_name =
      dri2_strndup(xcb_dri2_connect_device_name (connect),
		   xcb_dri2_connect_device_name_length (connect));
		   
   dri2_dpy->driver_name =
      dri2_strndup(xcb_dri2_connect_driver_name (connect),
		   xcb_dri2_connect_driver_name_length (connect));

   if (dri2_dpy->device_name == NULL || dri2_dpy->driver_name == NULL) {
      free(dri2_dpy->device_name);
      free(dri2_dpy->driver_name);
      free(connect);
      return EGL_FALSE;
   }
   free(connect);

   return EGL_TRUE;
}

static EGLBoolean
dri2_authenticate(struct dri2_egl_display *dri2_dpy)
{
   xcb_dri2_authenticate_reply_t *authenticate;
   xcb_dri2_authenticate_cookie_t authenticate_cookie;
   xcb_screen_iterator_t s;
   drm_magic_t magic;

   if (drmGetMagic(dri2_dpy->fd, &magic)) {
      _eglLog(_EGL_FATAL, "DRI2: failed to get drm magic");
      return EGL_FALSE;
   }

   s = xcb_setup_roots_iterator(xcb_get_setup(dri2_dpy->conn));
   authenticate_cookie =
      xcb_dri2_authenticate_unchecked(dri2_dpy->conn, s.data->root, magic);
   authenticate =
      xcb_dri2_authenticate_reply(dri2_dpy->conn, authenticate_cookie, NULL);
   if (authenticate == NULL || !authenticate->authenticated) {
      _eglLog(_EGL_FATAL, "DRI2: failed to authenticate");
      free(authenticate);
      return EGL_FALSE;
   }

   free(authenticate);

   return EGL_TRUE;
}

static EGLBoolean
dri2_add_configs_for_visuals(struct dri2_egl_display *dri2_dpy,
			     _EGLDisplay *disp)
{
   xcb_screen_iterator_t s;
   xcb_depth_iterator_t d;
   xcb_visualtype_t *visuals;
   int i, j, id;
   struct dri2_egl_config *conf;
   EGLint surface_type;

   s = xcb_setup_roots_iterator(xcb_get_setup(dri2_dpy->conn));
   d = xcb_screen_allowed_depths_iterator(s.data);
   id = 1;

   surface_type =
      EGL_WINDOW_BIT |
      EGL_PIXMAP_BIT |
      EGL_PBUFFER_BIT |
      EGL_SWAP_BEHAVIOR_PRESERVED_BIT;

   while (d.rem > 0) {
      EGLBoolean class_added[6] = { 0, };

      visuals = xcb_depth_visuals(d.data);
      for (i = 0; i < xcb_depth_visuals_length(d.data); i++) {
	 if (class_added[visuals[i]._class])
	    continue;

	 class_added[visuals[i]._class] = EGL_TRUE;
	 for (j = 0; dri2_dpy->driver_configs[j]; j++) {
	    conf = dri2_add_config(disp, dri2_dpy->driver_configs[j],
				   id++, d.data->depth, surface_type);
	    if (conf == NULL)
	       continue;
	    _eglSetConfigKey(&conf->base,
			     EGL_NATIVE_VISUAL_ID, visuals[i].visual_id);
	    _eglSetConfigKey(&conf->base,
			     EGL_NATIVE_VISUAL_TYPE, visuals[i]._class);
	 }
      }

      xcb_depth_next(&d);      
   }

   if (!_eglGetArraySize(disp->Configs)) {
      _eglLog(_EGL_WARNING, "DRI2: failed to create any config");
      return EGL_FALSE;
   }

   return EGL_TRUE;
}

static EGLBoolean
dri2_load_driver(_EGLDisplay *disp)
d377 3
a379 3
	      "DRI2: failed to open any driver (search paths %s)",
	      search_paths);
      return EGL_FALSE;
d388 13
a401 1
   }
d411 2
a412 2
static EGLBoolean
dri2_create_screen(_EGLDisplay *disp)
d414 1
a415 2
   struct dri2_egl_display *dri2_dpy;
   unsigned int api_mask;
d417 10
a426 4
   dri2_dpy = disp->DriverData;
   dri2_dpy->dri_screen =
      dri2_dpy->dri2->createNewScreen(0, dri2_dpy->fd, dri2_dpy->extensions,
				      &dri2_dpy->driver_configs, disp);
d428 2
a429 2
   if (dri2_dpy->dri_screen == NULL) {
      _eglLog(_EGL_WARNING, "DRI2: failed to create dri screen");
d433 8
a440 3
   extensions = dri2_dpy->core->getExtensions(dri2_dpy->dri_screen);
   if (!dri2_bind_extensions(dri2_dpy, dri2_core_extensions, extensions))
      goto cleanup_dri_screen;
d442 12
a453 4
   if (dri2_dpy->dri2->base.version >= 2)
      api_mask = dri2_dpy->dri2->getAPIMask(dri2_dpy->dri_screen);
   else
      api_mask = 1 << __DRI_API_OPENGL;
d455 1
a455 1
   disp->ClientAPIsMask = 0;
d457 1
a457 1
      disp->ClientAPIsMask |= EGL_OPENGL_BIT;
d459 1
a459 1
      disp->ClientAPIsMask |= EGL_OPENGL_ES_BIT;
d461 1
a461 1
      disp->ClientAPIsMask |= EGL_OPENGL_ES2_BIT;
d463 13
a475 4
   if (dri2_dpy->dri2->base.version >= 2) {
      disp->Extensions.KHR_surfaceless_gles1 = EGL_TRUE;
      disp->Extensions.KHR_surfaceless_gles2 = EGL_TRUE;
      disp->Extensions.KHR_surfaceless_opengl = EGL_TRUE;
d478 5
a482 6
   return EGL_TRUE;

 cleanup_dri_screen:
   dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);

   return EGL_FALSE;
d485 2
a486 3
static EGLBoolean
dri2_initialize_x11(_EGLDriver *drv, _EGLDisplay *disp,
		    EGLint *major, EGLint *minor)
d488 1
d491 1
a491 1
   (void) drv;
d493 4
a496 7
   dri2_dpy = malloc(sizeof *dri2_dpy);
   if (!dri2_dpy)
      return _eglError(EGL_BAD_ALLOC, "eglInitialize");

   disp->DriverData = (void *) dri2_dpy;
   if (disp->PlatformDisplay == NULL) {
      dri2_dpy->conn = xcb_connect(0, 0);
d498 4
a501 1
      dri2_dpy->conn = XGetXCBConnection((Display *) disp->PlatformDisplay);
d504 3
a506 3
   if (xcb_connection_has_error(dri2_dpy->conn)) {
      _eglLog(_EGL_WARNING, "DRI2: xcb_connect failed");
      goto cleanup_dpy;
d509 1
a509 4
   if (dri2_dpy->conn) {
      if (!dri2_connect(dri2_dpy))
	 goto cleanup_conn;
   }
d511 5
a515 23
   if (!dri2_load_driver(disp))
      goto cleanup_conn;

   dri2_dpy->fd = open(dri2_dpy->device_name, O_RDWR);
   if (dri2_dpy->fd == -1) {
      _eglLog(_EGL_WARNING,
	      "DRI2: could not open %s (%s)", dri2_dpy->device_name,
              strerror(errno));
      goto cleanup_driver;
   }

   if (dri2_dpy->conn) {
      if (!dri2_authenticate(dri2_dpy))
	 goto cleanup_fd;
   }

   if (dri2_dpy->dri2_minor >= 1) {
      dri2_dpy->loader_extension.base.name = __DRI_DRI2_LOADER;
      dri2_dpy->loader_extension.base.version = 3;
      dri2_dpy->loader_extension.getBuffers = dri2_get_buffers;
      dri2_dpy->loader_extension.flushFrontBuffer = dri2_flush_front_buffer;
      dri2_dpy->loader_extension.getBuffersWithFormat =
	 dri2_get_buffers_with_format;
d517 3
a519 578
      dri2_dpy->loader_extension.base.name = __DRI_DRI2_LOADER;
      dri2_dpy->loader_extension.base.version = 2;
      dri2_dpy->loader_extension.getBuffers = dri2_get_buffers;
      dri2_dpy->loader_extension.flushFrontBuffer = dri2_flush_front_buffer;
      dri2_dpy->loader_extension.getBuffersWithFormat = NULL;
   }
      
   dri2_dpy->extensions[0] = &dri2_dpy->loader_extension.base;
   dri2_dpy->extensions[1] = &image_lookup_extension.base;
   dri2_dpy->extensions[2] = NULL;

   if (!dri2_create_screen(disp))
      goto cleanup_fd;

   if (dri2_dpy->conn) {
      if (!dri2_add_configs_for_visuals(dri2_dpy, disp))
	 goto cleanup_configs;
   }

   disp->Extensions.MESA_drm_image = EGL_TRUE;
   disp->Extensions.KHR_image_base = EGL_TRUE;
   disp->Extensions.KHR_image_pixmap = EGL_TRUE;
   disp->Extensions.KHR_gl_renderbuffer_image = EGL_TRUE;
   disp->Extensions.KHR_gl_texture_2D_image = EGL_TRUE;
   disp->Extensions.NOK_swap_region = EGL_TRUE;
   disp->Extensions.NOK_texture_from_pixmap = EGL_TRUE;

   /* we're supporting EGL 1.4 */
   *major = 1;
   *minor = 4;

   return EGL_TRUE;

 cleanup_configs:
   _eglCleanupDisplay(disp);
   dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);
 cleanup_fd:
   close(dri2_dpy->fd);
 cleanup_driver:
   dlclose(dri2_dpy->driver);
 cleanup_conn:
   if (disp->PlatformDisplay == NULL)
      xcb_disconnect(dri2_dpy->conn);
 cleanup_dpy:
   free(dri2_dpy);

   return EGL_FALSE;
}

#ifdef HAVE_LIBUDEV

struct dri2_driver_map {
   int vendor_id;
   const char *driver;
   const int *chip_ids;
   int num_chips_ids;
};

const int i915_chip_ids[] = {
   0x3577, /* PCI_CHIP_I830_M */
   0x2562, /* PCI_CHIP_845_G */
   0x3582, /* PCI_CHIP_I855_GM */
   0x2572, /* PCI_CHIP_I865_G */
   0x2582, /* PCI_CHIP_I915_G */
   0x258a, /* PCI_CHIP_E7221_G */
   0x2592, /* PCI_CHIP_I915_GM */
   0x2772, /* PCI_CHIP_I945_G */
   0x27a2, /* PCI_CHIP_I945_GM */
   0x27ae, /* PCI_CHIP_I945_GME */
   0x29b2, /* PCI_CHIP_Q35_G */
   0x29c2, /* PCI_CHIP_G33_G */
   0x29d2, /* PCI_CHIP_Q33_G */
   0xa001, /* PCI_CHIP_IGD_G */
   0xa011, /* Pineview */
};

const int i965_chip_ids[] = {
   0x0042, /* PCI_CHIP_ILD_G */
   0x0046, /* PCI_CHIP_ILM_G */
   0x0102, /* PCI_CHIP_SANDYBRIDGE_GT1 */
   0x0106, /* PCI_CHIP_SANDYBRIDGE_M_GT1 */
   0x010a, /* PCI_CHIP_SANDYBRIDGE_S */
   0x0112, /* PCI_CHIP_SANDYBRIDGE_GT2 */
   0x0116, /* PCI_CHIP_SANDYBRIDGE_M_GT2 */
   0x0122, /* PCI_CHIP_SANDYBRIDGE_GT2_PLUS */
   0x0126, /* PCI_CHIP_SANDYBRIDGE_M_GT2_PLUS */
   0x29a2, /* PCI_CHIP_I965_G */
   0x2992, /* PCI_CHIP_I965_Q */
   0x2982, /* PCI_CHIP_I965_G_1 */
   0x2972, /* PCI_CHIP_I946_GZ */
   0x2a02, /* PCI_CHIP_I965_GM */
   0x2a12, /* PCI_CHIP_I965_GME */
   0x2a42, /* PCI_CHIP_GM45_GM */
   0x2e02, /* PCI_CHIP_IGD_E_G */
   0x2e12, /* PCI_CHIP_Q45_G */
   0x2e22, /* PCI_CHIP_G45_G */
   0x2e32, /* PCI_CHIP_G41_G */
   0x2e42, /* PCI_CHIP_B43_G */
   0x2e92, /* PCI_CHIP_B43_G1 */
};

const int r100_chip_ids[] = {
   0x4C57, /* PCI_CHIP_RADEON_LW */
   0x4C58, /* PCI_CHIP_RADEON_LX */
   0x4C59, /* PCI_CHIP_RADEON_LY */
   0x4C5A, /* PCI_CHIP_RADEON_LZ */
   0x5144, /* PCI_CHIP_RADEON_QD */
   0x5145, /* PCI_CHIP_RADEON_QE */
   0x5146, /* PCI_CHIP_RADEON_QF */
   0x5147, /* PCI_CHIP_RADEON_QG */
   0x5159, /* PCI_CHIP_RADEON_QY */
   0x515A, /* PCI_CHIP_RADEON_QZ */
   0x5157, /* PCI_CHIP_RV200_QW */
   0x5158, /* PCI_CHIP_RV200_QX */
   0x515E, /* PCI_CHIP_RN50_515E */
   0x5969, /* PCI_CHIP_RN50_5969 */
   0x4136, /* PCI_CHIP_RS100_4136 */
   0x4336, /* PCI_CHIP_RS100_4336 */
   0x4137, /* PCI_CHIP_RS200_4137 */
   0x4337, /* PCI_CHIP_RS200_4337 */
   0x4237, /* PCI_CHIP_RS250_4237 */
   0x4437, /* PCI_CHIP_RS250_4437 */
};

const int r200_chip_ids[] = {
   0x5148, /* PCI_CHIP_R200_QH */
   0x514C, /* PCI_CHIP_R200_QL */
   0x514D, /* PCI_CHIP_R200_QM */
   0x4242, /* PCI_CHIP_R200_BB */
   0x4243, /* PCI_CHIP_R200_BC */
   0x4966, /* PCI_CHIP_RV250_If */
   0x4967, /* PCI_CHIP_RV250_Ig */
   0x4C64, /* PCI_CHIP_RV250_Ld */
   0x4C66, /* PCI_CHIP_RV250_Lf */
   0x4C67, /* PCI_CHIP_RV250_Lg */
   0x5960, /* PCI_CHIP_RV280_5960 */
   0x5961, /* PCI_CHIP_RV280_5961 */
   0x5962, /* PCI_CHIP_RV280_5962 */
   0x5964, /* PCI_CHIP_RV280_5964 */
   0x5965, /* PCI_CHIP_RV280_5965 */
   0x5C61, /* PCI_CHIP_RV280_5C61 */
   0x5C63, /* PCI_CHIP_RV280_5C63 */
   0x5834, /* PCI_CHIP_RS300_5834 */
   0x5835, /* PCI_CHIP_RS300_5835 */
   0x7834, /* PCI_CHIP_RS350_7834 */
   0x7835, /* PCI_CHIP_RS350_7835 */
};

const int r300_chip_ids[] = {
   0x4144, /* PCI_CHIP_R300_AD */
   0x4145, /* PCI_CHIP_R300_AE */
   0x4146, /* PCI_CHIP_R300_AF */
   0x4147, /* PCI_CHIP_R300_AG */
   0x4E44, /* PCI_CHIP_R300_ND */
   0x4E45, /* PCI_CHIP_R300_NE */
   0x4E46, /* PCI_CHIP_R300_NF */
   0x4E47, /* PCI_CHIP_R300_NG */
   0x4E48, /* PCI_CHIP_R350_NH */
   0x4E49, /* PCI_CHIP_R350_NI */
   0x4E4B, /* PCI_CHIP_R350_NK */
   0x4148, /* PCI_CHIP_R350_AH */
   0x4149, /* PCI_CHIP_R350_AI */
   0x414A, /* PCI_CHIP_R350_AJ */
   0x414B, /* PCI_CHIP_R350_AK */
   0x4E4A, /* PCI_CHIP_R360_NJ */
   0x4150, /* PCI_CHIP_RV350_AP */
   0x4151, /* PCI_CHIP_RV350_AQ */
   0x4152, /* PCI_CHIP_RV350_AR */
   0x4153, /* PCI_CHIP_RV350_AS */
   0x4154, /* PCI_CHIP_RV350_AT */
   0x4155, /* PCI_CHIP_RV350_AU */
   0x4156, /* PCI_CHIP_RV350_AV */
   0x4E50, /* PCI_CHIP_RV350_NP */
   0x4E51, /* PCI_CHIP_RV350_NQ */
   0x4E52, /* PCI_CHIP_RV350_NR */
   0x4E53, /* PCI_CHIP_RV350_NS */
   0x4E54, /* PCI_CHIP_RV350_NT */
   0x4E56, /* PCI_CHIP_RV350_NV */
   0x5460, /* PCI_CHIP_RV370_5460 */
   0x5462, /* PCI_CHIP_RV370_5462 */
   0x5464, /* PCI_CHIP_RV370_5464 */
   0x5B60, /* PCI_CHIP_RV370_5B60 */
   0x5B62, /* PCI_CHIP_RV370_5B62 */
   0x5B63, /* PCI_CHIP_RV370_5B63 */
   0x5B64, /* PCI_CHIP_RV370_5B64 */
   0x5B65, /* PCI_CHIP_RV370_5B65 */
   0x3150, /* PCI_CHIP_RV380_3150 */
   0x3152, /* PCI_CHIP_RV380_3152 */
   0x3154, /* PCI_CHIP_RV380_3154 */
   0x3155, /* PCI_CHIP_RV380_3155 */
   0x3E50, /* PCI_CHIP_RV380_3E50 */
   0x3E54, /* PCI_CHIP_RV380_3E54 */
   0x4A48, /* PCI_CHIP_R420_JH */
   0x4A49, /* PCI_CHIP_R420_JI */
   0x4A4A, /* PCI_CHIP_R420_JJ */
   0x4A4B, /* PCI_CHIP_R420_JK */
   0x4A4C, /* PCI_CHIP_R420_JL */
   0x4A4D, /* PCI_CHIP_R420_JM */
   0x4A4E, /* PCI_CHIP_R420_JN */
   0x4A4F, /* PCI_CHIP_R420_JO */
   0x4A50, /* PCI_CHIP_R420_JP */
   0x4A54, /* PCI_CHIP_R420_JT */
   0x5548, /* PCI_CHIP_R423_UH */
   0x5549, /* PCI_CHIP_R423_UI */
   0x554A, /* PCI_CHIP_R423_UJ */
   0x554B, /* PCI_CHIP_R423_UK */
   0x5550, /* PCI_CHIP_R423_5550 */
   0x5551, /* PCI_CHIP_R423_UQ */
   0x5552, /* PCI_CHIP_R423_UR */
   0x5554, /* PCI_CHIP_R423_UT */
   0x5D57, /* PCI_CHIP_R423_5D57 */
   0x554C, /* PCI_CHIP_R430_554C */
   0x554D, /* PCI_CHIP_R430_554D */
   0x554E, /* PCI_CHIP_R430_554E */
   0x554F, /* PCI_CHIP_R430_554F */
   0x5D48, /* PCI_CHIP_R430_5D48 */
   0x5D49, /* PCI_CHIP_R430_5D49 */
   0x5D4A, /* PCI_CHIP_R430_5D4A */
   0x5D4C, /* PCI_CHIP_R480_5D4C */
   0x5D4D, /* PCI_CHIP_R480_5D4D */
   0x5D4E, /* PCI_CHIP_R480_5D4E */
   0x5D4F, /* PCI_CHIP_R480_5D4F */
   0x5D50, /* PCI_CHIP_R480_5D50 */
   0x5D52, /* PCI_CHIP_R480_5D52 */
   0x4B49, /* PCI_CHIP_R481_4B49 */
   0x4B4A, /* PCI_CHIP_R481_4B4A */
   0x4B4B, /* PCI_CHIP_R481_4B4B */
   0x4B4C, /* PCI_CHIP_R481_4B4C */
   0x564A, /* PCI_CHIP_RV410_564A */
   0x564B, /* PCI_CHIP_RV410_564B */
   0x564F, /* PCI_CHIP_RV410_564F */
   0x5652, /* PCI_CHIP_RV410_5652 */
   0x5653, /* PCI_CHIP_RV410_5653 */
   0x5657, /* PCI_CHIP_RV410_5657 */
   0x5E48, /* PCI_CHIP_RV410_5E48 */
   0x5E4A, /* PCI_CHIP_RV410_5E4A */
   0x5E4B, /* PCI_CHIP_RV410_5E4B */
   0x5E4C, /* PCI_CHIP_RV410_5E4C */
   0x5E4D, /* PCI_CHIP_RV410_5E4D */
   0x5E4F, /* PCI_CHIP_RV410_5E4F */
   0x5A41, /* PCI_CHIP_RS400_5A41 */
   0x5A42, /* PCI_CHIP_RS400_5A42 */
   0x5A61, /* PCI_CHIP_RC410_5A61 */
   0x5A62, /* PCI_CHIP_RC410_5A62 */
   0x5954, /* PCI_CHIP_RS480_5954 */
   0x5955, /* PCI_CHIP_RS480_5955 */
   0x5974, /* PCI_CHIP_RS482_5974 */
   0x5975, /* PCI_CHIP_RS482_5975 */
   0x7100, /* PCI_CHIP_R520_7100 */
   0x7101, /* PCI_CHIP_R520_7101 */
   0x7102, /* PCI_CHIP_R520_7102 */
   0x7103, /* PCI_CHIP_R520_7103 */
   0x7104, /* PCI_CHIP_R520_7104 */
   0x7105, /* PCI_CHIP_R520_7105 */
   0x7106, /* PCI_CHIP_R520_7106 */
   0x7108, /* PCI_CHIP_R520_7108 */
   0x7109, /* PCI_CHIP_R520_7109 */
   0x710A, /* PCI_CHIP_R520_710A */
   0x710B, /* PCI_CHIP_R520_710B */
   0x710C, /* PCI_CHIP_R520_710C */
   0x710E, /* PCI_CHIP_R520_710E */
   0x710F, /* PCI_CHIP_R520_710F */
   0x7140, /* PCI_CHIP_RV515_7140 */
   0x7141, /* PCI_CHIP_RV515_7141 */
   0x7142, /* PCI_CHIP_RV515_7142 */
   0x7143, /* PCI_CHIP_RV515_7143 */
   0x7144, /* PCI_CHIP_RV515_7144 */
   0x7145, /* PCI_CHIP_RV515_7145 */
   0x7146, /* PCI_CHIP_RV515_7146 */
   0x7147, /* PCI_CHIP_RV515_7147 */
   0x7149, /* PCI_CHIP_RV515_7149 */
   0x714A, /* PCI_CHIP_RV515_714A */
   0x714B, /* PCI_CHIP_RV515_714B */
   0x714C, /* PCI_CHIP_RV515_714C */
   0x714D, /* PCI_CHIP_RV515_714D */
   0x714E, /* PCI_CHIP_RV515_714E */
   0x714F, /* PCI_CHIP_RV515_714F */
   0x7151, /* PCI_CHIP_RV515_7151 */
   0x7152, /* PCI_CHIP_RV515_7152 */
   0x7153, /* PCI_CHIP_RV515_7153 */
   0x715E, /* PCI_CHIP_RV515_715E */
   0x715F, /* PCI_CHIP_RV515_715F */
   0x7180, /* PCI_CHIP_RV515_7180 */
   0x7181, /* PCI_CHIP_RV515_7181 */
   0x7183, /* PCI_CHIP_RV515_7183 */
   0x7186, /* PCI_CHIP_RV515_7186 */
   0x7187, /* PCI_CHIP_RV515_7187 */
   0x7188, /* PCI_CHIP_RV515_7188 */
   0x718A, /* PCI_CHIP_RV515_718A */
   0x718B, /* PCI_CHIP_RV515_718B */
   0x718C, /* PCI_CHIP_RV515_718C */
   0x718D, /* PCI_CHIP_RV515_718D */
   0x718F, /* PCI_CHIP_RV515_718F */
   0x7193, /* PCI_CHIP_RV515_7193 */
   0x7196, /* PCI_CHIP_RV515_7196 */
   0x719B, /* PCI_CHIP_RV515_719B */
   0x719F, /* PCI_CHIP_RV515_719F */
   0x7200, /* PCI_CHIP_RV515_7200 */
   0x7210, /* PCI_CHIP_RV515_7210 */
   0x7211, /* PCI_CHIP_RV515_7211 */
   0x71C0, /* PCI_CHIP_RV530_71C0 */
   0x71C1, /* PCI_CHIP_RV530_71C1 */
   0x71C2, /* PCI_CHIP_RV530_71C2 */
   0x71C3, /* PCI_CHIP_RV530_71C3 */
   0x71C4, /* PCI_CHIP_RV530_71C4 */
   0x71C5, /* PCI_CHIP_RV530_71C5 */
   0x71C6, /* PCI_CHIP_RV530_71C6 */
   0x71C7, /* PCI_CHIP_RV530_71C7 */
   0x71CD, /* PCI_CHIP_RV530_71CD */
   0x71CE, /* PCI_CHIP_RV530_71CE */
   0x71D2, /* PCI_CHIP_RV530_71D2 */
   0x71D4, /* PCI_CHIP_RV530_71D4 */
   0x71D5, /* PCI_CHIP_RV530_71D5 */
   0x71D6, /* PCI_CHIP_RV530_71D6 */
   0x71DA, /* PCI_CHIP_RV530_71DA */
   0x71DE, /* PCI_CHIP_RV530_71DE */
   0x7281, /* PCI_CHIP_RV560_7281 */
   0x7283, /* PCI_CHIP_RV560_7283 */
   0x7287, /* PCI_CHIP_RV560_7287 */
   0x7290, /* PCI_CHIP_RV560_7290 */
   0x7291, /* PCI_CHIP_RV560_7291 */
   0x7293, /* PCI_CHIP_RV560_7293 */
   0x7297, /* PCI_CHIP_RV560_7297 */
   0x7280, /* PCI_CHIP_RV570_7280 */
   0x7288, /* PCI_CHIP_RV570_7288 */
   0x7289, /* PCI_CHIP_RV570_7289 */
   0x728B, /* PCI_CHIP_RV570_728B */
   0x728C, /* PCI_CHIP_RV570_728C */
   0x7240, /* PCI_CHIP_R580_7240 */
   0x7243, /* PCI_CHIP_R580_7243 */
   0x7244, /* PCI_CHIP_R580_7244 */
   0x7245, /* PCI_CHIP_R580_7245 */
   0x7246, /* PCI_CHIP_R580_7246 */
   0x7247, /* PCI_CHIP_R580_7247 */
   0x7248, /* PCI_CHIP_R580_7248 */
   0x7249, /* PCI_CHIP_R580_7249 */
   0x724A, /* PCI_CHIP_R580_724A */
   0x724B, /* PCI_CHIP_R580_724B */
   0x724C, /* PCI_CHIP_R580_724C */
   0x724D, /* PCI_CHIP_R580_724D */
   0x724E, /* PCI_CHIP_R580_724E */
   0x724F, /* PCI_CHIP_R580_724F */
   0x7284, /* PCI_CHIP_R580_7284 */
   0x793F, /* PCI_CHIP_RS600_793F */
   0x7941, /* PCI_CHIP_RS600_7941 */
   0x7942, /* PCI_CHIP_RS600_7942 */
   0x791E, /* PCI_CHIP_RS690_791E */
   0x791F, /* PCI_CHIP_RS690_791F */
   0x796C, /* PCI_CHIP_RS740_796C */
   0x796D, /* PCI_CHIP_RS740_796D */
   0x796E, /* PCI_CHIP_RS740_796E */
   0x796F, /* PCI_CHIP_RS740_796F */
};

const int r600_chip_ids[] = {
   0x9400, /* PCI_CHIP_R600_9400 */
   0x9401, /* PCI_CHIP_R600_9401 */
   0x9402, /* PCI_CHIP_R600_9402 */
   0x9403, /* PCI_CHIP_R600_9403 */
   0x9405, /* PCI_CHIP_R600_9405 */
   0x940A, /* PCI_CHIP_R600_940A */
   0x940B, /* PCI_CHIP_R600_940B */
   0x940F, /* PCI_CHIP_R600_940F */
   0x94C0, /* PCI_CHIP_RV610_94C0 */
   0x94C1, /* PCI_CHIP_RV610_94C1 */
   0x94C3, /* PCI_CHIP_RV610_94C3 */
   0x94C4, /* PCI_CHIP_RV610_94C4 */
   0x94C5, /* PCI_CHIP_RV610_94C5 */
   0x94C6, /* PCI_CHIP_RV610_94C6 */
   0x94C7, /* PCI_CHIP_RV610_94C7 */
   0x94C8, /* PCI_CHIP_RV610_94C8 */
   0x94C9, /* PCI_CHIP_RV610_94C9 */
   0x94CB, /* PCI_CHIP_RV610_94CB */
   0x94CC, /* PCI_CHIP_RV610_94CC */
   0x94CD, /* PCI_CHIP_RV610_94CD */
   0x9580, /* PCI_CHIP_RV630_9580 */
   0x9581, /* PCI_CHIP_RV630_9581 */
   0x9583, /* PCI_CHIP_RV630_9583 */
   0x9586, /* PCI_CHIP_RV630_9586 */
   0x9587, /* PCI_CHIP_RV630_9587 */
   0x9588, /* PCI_CHIP_RV630_9588 */
   0x9589, /* PCI_CHIP_RV630_9589 */
   0x958A, /* PCI_CHIP_RV630_958A */
   0x958B, /* PCI_CHIP_RV630_958B */
   0x958C, /* PCI_CHIP_RV630_958C */
   0x958D, /* PCI_CHIP_RV630_958D */
   0x958E, /* PCI_CHIP_RV630_958E */
   0x958F, /* PCI_CHIP_RV630_958F */
   0x9500, /* PCI_CHIP_RV670_9500 */
   0x9501, /* PCI_CHIP_RV670_9501 */
   0x9504, /* PCI_CHIP_RV670_9504 */
   0x9505, /* PCI_CHIP_RV670_9505 */
   0x9506, /* PCI_CHIP_RV670_9506 */
   0x9507, /* PCI_CHIP_RV670_9507 */
   0x9508, /* PCI_CHIP_RV670_9508 */
   0x9509, /* PCI_CHIP_RV670_9509 */
   0x950F, /* PCI_CHIP_RV670_950F */
   0x9511, /* PCI_CHIP_RV670_9511 */
   0x9515, /* PCI_CHIP_RV670_9515 */
   0x9517, /* PCI_CHIP_RV670_9517 */
   0x9519, /* PCI_CHIP_RV670_9519 */
   0x95C0, /* PCI_CHIP_RV620_95C0 */
   0x95C2, /* PCI_CHIP_RV620_95C2 */
   0x95C4, /* PCI_CHIP_RV620_95C4 */
   0x95C5, /* PCI_CHIP_RV620_95C5 */
   0x95C6, /* PCI_CHIP_RV620_95C6 */
   0x95C7, /* PCI_CHIP_RV620_95C7 */
   0x95C9, /* PCI_CHIP_RV620_95C9 */
   0x95CC, /* PCI_CHIP_RV620_95CC */
   0x95CD, /* PCI_CHIP_RV620_95CD */
   0x95CE, /* PCI_CHIP_RV620_95CE */
   0x95CF, /* PCI_CHIP_RV620_95CF */
   0x9590, /* PCI_CHIP_RV635_9590 */
   0x9591, /* PCI_CHIP_RV635_9591 */
   0x9593, /* PCI_CHIP_RV635_9593 */
   0x9595, /* PCI_CHIP_RV635_9595 */
   0x9596, /* PCI_CHIP_RV635_9596 */
   0x9597, /* PCI_CHIP_RV635_9597 */
   0x9598, /* PCI_CHIP_RV635_9598 */
   0x9599, /* PCI_CHIP_RV635_9599 */
   0x959B, /* PCI_CHIP_RV635_959B */
   0x9610, /* PCI_CHIP_RS780_9610 */
   0x9611, /* PCI_CHIP_RS780_9611 */
   0x9612, /* PCI_CHIP_RS780_9612 */
   0x9613, /* PCI_CHIP_RS780_9613 */
   0x9614, /* PCI_CHIP_RS780_9614 */
   0x9615, /* PCI_CHIP_RS780_9615 */
   0x9616, /* PCI_CHIP_RS780_9616 */
   0x9710, /* PCI_CHIP_RS880_9710 */
   0x9711, /* PCI_CHIP_RS880_9711 */
   0x9712, /* PCI_CHIP_RS880_9712 */
   0x9713, /* PCI_CHIP_RS880_9713 */
   0x9714, /* PCI_CHIP_RS880_9714 */
   0x9715, /* PCI_CHIP_RS880_9715 */
   0x9440, /* PCI_CHIP_RV770_9440 */
   0x9441, /* PCI_CHIP_RV770_9441 */
   0x9442, /* PCI_CHIP_RV770_9442 */
   0x9443, /* PCI_CHIP_RV770_9443 */
   0x9444, /* PCI_CHIP_RV770_9444 */
   0x9446, /* PCI_CHIP_RV770_9446 */
   0x944A, /* PCI_CHIP_RV770_944A */
   0x944B, /* PCI_CHIP_RV770_944B */
   0x944C, /* PCI_CHIP_RV770_944C */
   0x944E, /* PCI_CHIP_RV770_944E */
   0x9450, /* PCI_CHIP_RV770_9450 */
   0x9452, /* PCI_CHIP_RV770_9452 */
   0x9456, /* PCI_CHIP_RV770_9456 */
   0x945A, /* PCI_CHIP_RV770_945A */
   0x945B, /* PCI_CHIP_RV770_945B */
   0x945E, /* PCI_CHIP_RV770_945E */
   0x9460, /* PCI_CHIP_RV790_9460 */
   0x9462, /* PCI_CHIP_RV790_9462 */
   0x946A, /* PCI_CHIP_RV770_946A */
   0x946B, /* PCI_CHIP_RV770_946B */
   0x947A, /* PCI_CHIP_RV770_947A */
   0x947B, /* PCI_CHIP_RV770_947B */
   0x9480, /* PCI_CHIP_RV730_9480 */
   0x9487, /* PCI_CHIP_RV730_9487 */
   0x9488, /* PCI_CHIP_RV730_9488 */
   0x9489, /* PCI_CHIP_RV730_9489 */
   0x948A, /* PCI_CHIP_RV730_948A */
   0x948F, /* PCI_CHIP_RV730_948F */
   0x9490, /* PCI_CHIP_RV730_9490 */
   0x9491, /* PCI_CHIP_RV730_9491 */
   0x9495, /* PCI_CHIP_RV730_9495 */
   0x9498, /* PCI_CHIP_RV730_9498 */
   0x949C, /* PCI_CHIP_RV730_949C */
   0x949E, /* PCI_CHIP_RV730_949E */
   0x949F, /* PCI_CHIP_RV730_949F */
   0x9540, /* PCI_CHIP_RV710_9540 */
   0x9541, /* PCI_CHIP_RV710_9541 */
   0x9542, /* PCI_CHIP_RV710_9542 */
   0x954E, /* PCI_CHIP_RV710_954E */
   0x954F, /* PCI_CHIP_RV710_954F */
   0x9552, /* PCI_CHIP_RV710_9552 */
   0x9553, /* PCI_CHIP_RV710_9553 */
   0x9555, /* PCI_CHIP_RV710_9555 */
   0x9557, /* PCI_CHIP_RV710_9557 */
   0x955F, /* PCI_CHIP_RV710_955F */
   0x94A0, /* PCI_CHIP_RV740_94A0 */
   0x94A1, /* PCI_CHIP_RV740_94A1 */
   0x94A3, /* PCI_CHIP_RV740_94A3 */
   0x94B1, /* PCI_CHIP_RV740_94B1 */
   0x94B3, /* PCI_CHIP_RV740_94B3 */
   0x94B4, /* PCI_CHIP_RV740_94B4 */
   0x94B5, /* PCI_CHIP_RV740_94B5 */
   0x94B9, /* PCI_CHIP_RV740_94B9 */
   0x68E0, /* PCI_CHIP_CEDAR_68E0 */
   0x68E1, /* PCI_CHIP_CEDAR_68E1 */
   0x68E4, /* PCI_CHIP_CEDAR_68E4 */
   0x68E5, /* PCI_CHIP_CEDAR_68E5 */
   0x68E8, /* PCI_CHIP_CEDAR_68E8 */
   0x68E9, /* PCI_CHIP_CEDAR_68E9 */
   0x68F1, /* PCI_CHIP_CEDAR_68F1 */
   0x68F8, /* PCI_CHIP_CEDAR_68F8 */
   0x68F9, /* PCI_CHIP_CEDAR_68F9 */
   0x68FE, /* PCI_CHIP_CEDAR_68FE */
   0x68C0, /* PCI_CHIP_REDWOOD_68C0 */
   0x68C1, /* PCI_CHIP_REDWOOD_68C1 */
   0x68C8, /* PCI_CHIP_REDWOOD_68C8 */
   0x68C9, /* PCI_CHIP_REDWOOD_68C9 */
   0x68D8, /* PCI_CHIP_REDWOOD_68D8 */
   0x68D9, /* PCI_CHIP_REDWOOD_68D9 */
   0x68DA, /* PCI_CHIP_REDWOOD_68DA */
   0x68DE, /* PCI_CHIP_REDWOOD_68DE */
   0x68A0, /* PCI_CHIP_JUNIPER_68A0 */
   0x68A1, /* PCI_CHIP_JUNIPER_68A1 */
   0x68A8, /* PCI_CHIP_JUNIPER_68A8 */
   0x68A9, /* PCI_CHIP_JUNIPER_68A9 */
   0x68B0, /* PCI_CHIP_JUNIPER_68B0 */
   0x68B8, /* PCI_CHIP_JUNIPER_68B8 */
   0x68B9, /* PCI_CHIP_JUNIPER_68B9 */
   0x68BE, /* PCI_CHIP_JUNIPER_68BE */
   0x6880, /* PCI_CHIP_CYPRESS_6880 */
   0x6888, /* PCI_CHIP_CYPRESS_6888 */
   0x6889, /* PCI_CHIP_CYPRESS_6889 */
   0x688A, /* PCI_CHIP_CYPRESS_688A */
   0x6898, /* PCI_CHIP_CYPRESS_6898 */
   0x6899, /* PCI_CHIP_CYPRESS_6899 */
   0x689E, /* PCI_CHIP_CYPRESS_689E */
   0x689C, /* PCI_CHIP_HEMLOCK_689C */
   0x689D, /* PCI_CHIP_HEMLOCK_689D */
};

const struct dri2_driver_map driver_map[] = {
   { 0x8086, "i915", i915_chip_ids, ARRAY_SIZE(i915_chip_ids) },
   { 0x8086, "i965", i965_chip_ids, ARRAY_SIZE(i965_chip_ids) },
   { 0x1002, "radeon", r100_chip_ids, ARRAY_SIZE(r100_chip_ids) },
   { 0x1002, "r200", r200_chip_ids, ARRAY_SIZE(r200_chip_ids) },
   { 0x1002, "r300", r300_chip_ids, ARRAY_SIZE(r300_chip_ids) },
   { 0x1002, "r600", r600_chip_ids, ARRAY_SIZE(r600_chip_ids) },
};

static char *
dri2_get_driver_for_fd(int fd)
{
   struct udev *udev;
   struct udev_device *device, *parent;
   struct stat buf;
   const char *pci_id;
   char *driver = NULL;
   int vendor_id, chip_id, i, j;

   udev = udev_new();
   if (fstat(fd, &buf) < 0) {
      _eglLog(_EGL_WARNING, "EGL-DRI2: failed to stat fd %d", fd);
      goto out;
   }

   device = udev_device_new_from_devnum(udev, 'c', buf.st_rdev);
   if (device == NULL) {
      _eglLog(_EGL_WARNING,
	      "EGL-DRI2: could not create udev device for fd %d", fd);
      goto out;
   }

   parent = udev_device_get_parent(device);
   if (parent == NULL) {
      _eglLog(_EGL_WARNING, "DRI2: could not get parent device");
      goto out;
   }

   pci_id = udev_device_get_property_value(parent, "PCI_ID");
   if (pci_id == NULL || sscanf(pci_id, "%x:%x", &vendor_id, &chip_id) != 2) {
      _eglLog(_EGL_WARNING, "EGL-DRI2: malformed or no PCI ID");
      goto out;
   }

   for (i = 0; i < ARRAY_SIZE(driver_map); i++) {
      if (vendor_id != driver_map[i].vendor_id)
	 continue;
      for (j = 0; j < driver_map[i].num_chips_ids; j++)
	 if (driver_map[i].chip_ids[j] == chip_id) {
	    driver = strdup(driver_map[i].driver);
	    _eglLog(_EGL_DEBUG, "pci id for %d: %04x:%04x, driver %s",
		    fd, vendor_id, chip_id, driver);
	    goto out;
	 }
d522 1
a522 46
 out:
   udev_device_unref(device);
   udev_unref(udev);

   return driver;
}

static EGLBoolean
dri2_initialize_drm(_EGLDriver *drv, _EGLDisplay *disp,
		    EGLint *major, EGLint *minor)
{
   struct dri2_egl_display *dri2_dpy;
   int i;

   dri2_dpy = malloc(sizeof *dri2_dpy);
   if (!dri2_dpy)
      return _eglError(EGL_BAD_ALLOC, "eglInitialize");

   disp->DriverData = (void *) dri2_dpy;
   dri2_dpy->fd = (int) disp->PlatformDisplay;

   dri2_dpy->driver_name = dri2_get_driver_for_fd(dri2_dpy->fd);
   if (dri2_dpy->driver_name == NULL)
      return _eglError(EGL_BAD_ALLOC, "DRI2: failed to get driver name");

   if (!dri2_load_driver(disp))
      goto cleanup_driver_name;

   dri2_dpy->extensions[0] = &image_lookup_extension.base;
   dri2_dpy->extensions[1] = &use_invalidate.base;
   dri2_dpy->extensions[2] = NULL;

   if (!dri2_create_screen(disp))
      goto cleanup_driver;

   for (i = 0; dri2_dpy->driver_configs[i]; i++)
      dri2_add_config(disp, dri2_dpy->driver_configs[i], i + 1, 0, 0);

   disp->Extensions.MESA_drm_image = EGL_TRUE;
   disp->Extensions.KHR_image_base = EGL_TRUE;
   disp->Extensions.KHR_gl_renderbuffer_image = EGL_TRUE;
   disp->Extensions.KHR_gl_texture_2D_image = EGL_TRUE;

   /* we're supporting EGL 1.4 */
   *major = 1;
   *minor = 4;
d526 2
a527 4
 cleanup_driver:
   dlclose(dri2_dpy->driver);
 cleanup_driver_name:
   free(dri2_dpy->driver_name);
a531 2
#endif

d536 1
a536 2
dri2_initialize(_EGLDriver *drv, _EGLDisplay *disp,
		EGLint *major, EGLint *minor)
d538 4
d543 1
d545 4
a548 1
      return dri2_initialize_x11(drv, disp, major, minor);
d551 1
d553 10
a562 1
      return dri2_initialize_drm(drv, disp, major, minor);
d581 24
a604 5
   dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);
   close(dri2_dpy->fd);
   dlclose(dri2_dpy->driver);
   if (disp->PlatformDisplay == NULL)
      xcb_disconnect(dri2_dpy->conn);
d659 13
a671 2
   if (conf != NULL)
      dri_config = dri2_config->dri_config;
d675 19
a693 15
   if (dri2_dpy->dri2->base.version >= 2) {
      dri2_ctx->dri_context =
	 dri2_dpy->dri2->createNewContextForAPI(dri2_dpy->dri_screen,
						api,
						dri_config,
						dri2_ctx_shared ? 
						dri2_ctx_shared->dri_context : NULL,
						dri2_ctx);
   } else if (api == __DRI_API_OPENGL) {
      dri2_ctx->dri_context =
	 dri2_dpy->dri2->createNewContext(dri2_dpy->dri_screen,
					  dri2_config->dri_config,
					  dri2_ctx_shared ? 
					  dri2_ctx_shared->dri_context : NULL,
					  dri2_ctx);
d695 19
a713 1
      /* fail */
a725 23
static EGLBoolean
dri2_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surf);

   (void) drv;

   if (!_eglPutSurface(surf))
      return EGL_TRUE;

   (*dri2_dpy->core->destroyDrawable)(dri2_surf->dri_drawable);
   
   xcb_dri2_destroy_drawable (dri2_dpy->conn, dri2_surf->drawable);

   if (surf->Type == EGL_PBUFFER_BIT)
      xcb_free_pixmap (dri2_dpy->conn, dri2_surf->drawable);

   free(surf);

   return EGL_TRUE;
}

d755 5
d762 6
a767 9
      dri2_destroy_surface(drv, disp, old_dsurf);
      dri2_destroy_surface(drv, disp, old_rsurf);
      if (old_ctx) {
         /* unbind the old context only when there is no new context bound */
         if (!ctx) {
            __DRIcontext *old_cctx = dri2_egl_context(old_ctx)->dri_context;
            dri2_dpy->core->unbindContext(old_cctx);
         }
         /* no destroy? */
a768 1
      }
a789 184
/**
 * Called via eglCreateWindowSurface(), drv->API.CreateWindowSurface().
 */
static _EGLSurface *
dri2_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
		    _EGLConfig *conf, EGLNativeWindowType window,
		    const EGLint *attrib_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
   struct dri2_egl_surface *dri2_surf;
   xcb_get_geometry_cookie_t cookie;
   xcb_get_geometry_reply_t *reply;
   xcb_screen_iterator_t s;
   xcb_generic_error_t *error;

   (void) drv;

   dri2_surf = malloc(sizeof *dri2_surf);
   if (!dri2_surf) {
      _eglError(EGL_BAD_ALLOC, "dri2_create_surface");
      return NULL;
   }
   
   if (!_eglInitSurface(&dri2_surf->base, disp, type, conf, attrib_list))
      goto cleanup_surf;

   dri2_surf->region = XCB_NONE;
   if (type == EGL_PBUFFER_BIT) {
      dri2_surf->drawable = xcb_generate_id(dri2_dpy->conn);
      s = xcb_setup_roots_iterator(xcb_get_setup(dri2_dpy->conn));
      xcb_create_pixmap(dri2_dpy->conn, conf->BufferSize,
			dri2_surf->drawable, s.data->root,
			dri2_surf->base.Width, dri2_surf->base.Height);
   } else {
      dri2_surf->drawable = window;
   }

   dri2_surf->dri_drawable = 
      (*dri2_dpy->dri2->createNewDrawable) (dri2_dpy->dri_screen,
					    dri2_conf->dri_config, dri2_surf);
   if (dri2_surf->dri_drawable == NULL) {
      _eglError(EGL_BAD_ALLOC, "dri2->createNewDrawable");
      goto cleanup_pixmap;
   }

   xcb_dri2_create_drawable (dri2_dpy->conn, dri2_surf->drawable);

   if (type != EGL_PBUFFER_BIT) {
      cookie = xcb_get_geometry (dri2_dpy->conn, dri2_surf->drawable);
      reply = xcb_get_geometry_reply (dri2_dpy->conn, cookie, &error);
      if (reply == NULL || error != NULL) {
	 _eglError(EGL_BAD_ALLOC, "xcb_get_geometry");
	 free(error);
	 goto cleanup_dri_drawable;
      }

      dri2_surf->base.Width = reply->width;
      dri2_surf->base.Height = reply->height;
      free(reply);
   }

   return &dri2_surf->base;

 cleanup_dri_drawable:
   dri2_dpy->core->destroyDrawable(dri2_surf->dri_drawable);
 cleanup_pixmap:
   if (type == EGL_PBUFFER_BIT)
      xcb_free_pixmap(dri2_dpy->conn, dri2_surf->drawable);
 cleanup_surf:
   free(dri2_surf);

   return NULL;
}

/**
 * Called via eglCreateWindowSurface(), drv->API.CreateWindowSurface().
 */
static _EGLSurface *
dri2_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
			   _EGLConfig *conf, EGLNativeWindowType window,
			   const EGLint *attrib_list)
{
   return dri2_create_surface(drv, disp, EGL_WINDOW_BIT, conf,
			      window, attrib_list);
}

static _EGLSurface *
dri2_create_pixmap_surface(_EGLDriver *drv, _EGLDisplay *disp,
			   _EGLConfig *conf, EGLNativePixmapType pixmap,
			   const EGLint *attrib_list)
{
   return dri2_create_surface(drv, disp, EGL_PIXMAP_BIT, conf,
			      pixmap, attrib_list);
}

static _EGLSurface *
dri2_create_pbuffer_surface(_EGLDriver *drv, _EGLDisplay *disp,
			    _EGLConfig *conf, const EGLint *attrib_list)
{
   return dri2_create_surface(drv, disp, EGL_PBUFFER_BIT, conf,
			      XCB_WINDOW_NONE, attrib_list);
}

static EGLBoolean
dri2_copy_region(_EGLDriver *drv, _EGLDisplay *disp,
		 _EGLSurface *draw, xcb_xfixes_region_t region)
{
   struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);
   _EGLContext *ctx;
   xcb_dri2_copy_region_cookie_t cookie;

   if (dri2_drv->glFlush) {
      ctx = _eglGetCurrentContext();
      if (ctx && ctx->DrawSurface == &dri2_surf->base)
         dri2_drv->glFlush();
   }

   (*dri2_dpy->flush->flush)(dri2_surf->dri_drawable);

#if 0
   /* FIXME: Add support for dri swapbuffers, that'll give us swap
    * interval and page flipping (at least for fullscreen windows) as
    * well as the page flip event.  Unless surface->SwapBehavior is
    * EGL_BUFFER_PRESERVED. */
#if __DRI2_FLUSH_VERSION >= 2
   if (pdraw->psc->f)
      (*pdraw->psc->f->flushInvalidate)(pdraw->driDrawable);
#endif
#endif

   if (!dri2_surf->have_fake_front)
      return EGL_TRUE;

   cookie = xcb_dri2_copy_region_unchecked(dri2_dpy->conn,
					   dri2_surf->drawable,
					   region,
					   XCB_DRI2_ATTACHMENT_BUFFER_FRONT_LEFT,
					   XCB_DRI2_ATTACHMENT_BUFFER_FAKE_FRONT_LEFT);
   free(xcb_dri2_copy_region_reply(dri2_dpy->conn, cookie, NULL));

   return EGL_TRUE;
}

static EGLBoolean
dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
{
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);

   return dri2_copy_region(drv, disp, draw, dri2_surf->region);
}

static EGLBoolean
dri2_swap_buffers_region(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw,
			 EGLint numRects, const EGLint *rects)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);
   EGLBoolean ret;
   xcb_xfixes_region_t region;
   xcb_rectangle_t rectangles[16];
   int i;

   if (numRects > (int)ARRAY_SIZE(rectangles))
      return dri2_copy_region(drv, disp, draw, dri2_surf->region);

   /* FIXME: Invert y here? */
   for (i = 0; i < numRects; i++) {
      rectangles[i].x = rects[i * 4];
      rectangles[i].y = rects[i * 4 + 1];
      rectangles[i].width = rects[i * 4 + 2];
      rectangles[i].height = rects[i * 4 + 3];
   }

   region = xcb_generate_id(dri2_dpy->conn);
   xcb_xfixes_create_region(dri2_dpy->conn, region, numRects, rectangles);
   ret = dri2_copy_region(drv, disp, draw, region);
   xcb_xfixes_destroy_region(dri2_dpy->conn, region);

   return ret;
}

d796 1
a796 1
   (void) drv;
d798 1
a798 3
   /* FIXME: Do we need to support lookup of EGL symbols too? */

   return (_EGLProc) _glapi_get_proc_address(procname);
a829 34
static void
dri2_unload(_EGLDriver *drv)
{
   struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);
   free(dri2_drv);
}

static EGLBoolean
dri2_copy_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf,
		  EGLNativePixmapType target)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surf);
   xcb_gcontext_t gc;

   (void) drv;

   (*dri2_dpy->flush->flush)(dri2_surf->dri_drawable);

   gc = xcb_generate_id(dri2_dpy->conn);
   xcb_create_gc(dri2_dpy->conn, gc, target, 0, NULL);
   xcb_copy_area(dri2_dpy->conn,
		  dri2_surf->drawable,
		  target,
		  gc,
		  0, 0,
		  0, 0,
		  dri2_surf->base.Width,
		  dri2_surf->base.Height);
   xcb_free_gc(dri2_dpy->conn, gc);

   return EGL_TRUE;
}

d876 1
a876 12
   (void) drv;
   (void) disp;
   (void) surf;
   (void) buffer;

   return EGL_TRUE;
}

static _EGLImage *
dri2_create_image_khr_pixmap(_EGLDisplay *disp, _EGLContext *ctx,
			     EGLClientBuffer buffer, const EGLint *attr_list)
{
d878 4
a881 10
   struct dri2_egl_image *dri2_img;
   unsigned int attachments[1];
   xcb_drawable_t drawable;
   xcb_dri2_get_buffers_cookie_t buffers_cookie;
   xcb_dri2_get_buffers_reply_t *buffers_reply;
   xcb_dri2_dri2_buffer_t *buffers;
   xcb_get_geometry_cookie_t geometry_cookie;
   xcb_get_geometry_reply_t *geometry_reply;
   xcb_generic_error_t *error;
   int stride, format;
d883 2
a884 1
   (void) ctx;
d886 2
a887 13
   drawable = (xcb_drawable_t) buffer;
   xcb_dri2_create_drawable (dri2_dpy->conn, drawable);
   attachments[0] = XCB_DRI2_ATTACHMENT_BUFFER_FRONT_LEFT;
   buffers_cookie =
      xcb_dri2_get_buffers_unchecked (dri2_dpy->conn,
				      drawable, 1, 1, attachments);
   geometry_cookie = xcb_get_geometry (dri2_dpy->conn, drawable);
   buffers_reply = xcb_dri2_get_buffers_reply (dri2_dpy->conn,
					       buffers_cookie, NULL);
   buffers = xcb_dri2_get_buffers_buffers (buffers_reply);
   if (buffers == NULL) {
      return NULL;
   }
d889 3
a891 17
   geometry_reply = xcb_get_geometry_reply (dri2_dpy->conn,
					    geometry_cookie, &error);
   if (geometry_reply == NULL || error != NULL) {
      _eglError(EGL_BAD_ALLOC, "xcb_get_geometry");
      free(error);
      free(buffers_reply);
   }

   switch (geometry_reply->depth) {
   case 16:
      format = __DRI_IMAGE_FORMAT_RGB565;
      break;
   case 24:
      format = __DRI_IMAGE_FORMAT_XRGB8888;
      break;
   case 32:
      format = __DRI_IMAGE_FORMAT_ARGB8888;
d894 1
a894 5
      _eglError(EGL_BAD_PARAMETER,
		"dri2_create_image_khr: unsupported pixmap depth");
      free(buffers_reply);
      free(geometry_reply);
      return NULL;
d896 5
d902 1
a902 28
   dri2_img = malloc(sizeof *dri2_img);
   if (!dri2_img) {
      free(buffers_reply);
      free(geometry_reply);
      _eglError(EGL_BAD_ALLOC, "dri2_create_image_khr");
      return EGL_NO_IMAGE_KHR;
   }

   if (!_eglInitImage(&dri2_img->base, disp)) {
      free(buffers_reply);
      free(geometry_reply);
      return EGL_NO_IMAGE_KHR;
   }

   stride = buffers[0].pitch / buffers[0].cpp;
   dri2_img->dri_image =
      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen,
					   buffers_reply->width,
					   buffers_reply->height,
					   format,
					   buffers[0].name,
					   stride,
					   dri2_img);

   free(buffers_reply);
   free(geometry_reply);

   return &dri2_img->base;
d913 1
a913 1
   GLuint renderbuffer = (GLuint) buffer;
d948 1
a948 1
   name = (EGLint) buffer;
d1000 1
d1002 44
a1052 2
   case EGL_NATIVE_PIXMAP_KHR:
      return dri2_create_image_khr_pixmap(disp, ctx, buffer, attr_list);
d1057 4
d1132 2
a1133 1
      EGL_DRM_BUFFER_USE_SHARE_MESA; 
d1145 2
d1192 129
d1326 1
a1326 1
_eglMain(const char *args)
d1337 4
a1345 5
   dri2_drv->base.API.CreateWindowSurface = dri2_create_window_surface;
   dri2_drv->base.API.CreatePixmapSurface = dri2_create_pixmap_surface;
   dri2_drv->base.API.CreatePbufferSurface = dri2_create_pbuffer_surface;
   dri2_drv->base.API.DestroySurface = dri2_destroy_surface;
   dri2_drv->base.API.SwapBuffers = dri2_swap_buffers;
a1348 1
   dri2_drv->base.API.CopyBuffers = dri2_copy_buffers;
a1352 1
   dri2_drv->base.API.SwapBuffersRegionNOK = dri2_swap_buffers_region;
d1355 4
a1361 3

   dri2_drv->glFlush =
      (void (*)(void)) dri2_get_proc_address(&dri2_drv->base, "glFlush");
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d43 6
d60 2
d65 2
a87 1
   __DRIimageLookupExtension image_lookup_extension;
d125 4
d177 1
a177 1
   0,				/* __DRI_ATTRIB_YINVERTED */
d180 1
a180 1
static void
d182 1
a182 1
		int depth, xcb_visualtype_t *visual)
d195 4
d249 4
a252 1
      return;
d254 1
a254 7
   if (visual != NULL) {
      if (depth != _eglGetConfigKey(&base, EGL_BUFFER_SIZE))
	 return;

      _eglSetConfigKey(&base, EGL_SURFACE_TYPE,
		       EGL_WINDOW_BIT | EGL_PIXMAP_BIT | EGL_PBUFFER_BIT |
		       EGL_SWAP_BEHAVIOR_PRESERVED_BIT);
d256 5
a260 5
      _eglSetConfigKey(&base, EGL_NATIVE_VISUAL_ID, visual->visual_id);
      _eglSetConfigKey(&base, EGL_NATIVE_VISUAL_TYPE, visual->_class);
   } else {
      _eglSetConfigKey(&base, EGL_SURFACE_TYPE,
		       EGL_PIXMAP_BIT | EGL_PBUFFER_BIT);
d263 2
a264 9
   _eglSetConfigKey(&base, EGL_NATIVE_RENDERABLE, EGL_TRUE);
   _eglSetConfigKey(&base, EGL_BIND_TO_TEXTURE_RGB, bind_to_texture_rgb);
   if (_eglGetConfigKey(&base, EGL_ALPHA_SIZE) > 0)
      _eglSetConfigKey(&base,
		       EGL_BIND_TO_TEXTURE_RGBA, bind_to_texture_rgba);

   /* EGL_OPENGL_ES_BIT, EGL_OPENVG_BIT, EGL_OPENGL_ES2_BIT */
   _eglSetConfigKey(&base, EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT);
   _eglSetConfigKey(&base, EGL_CONFORMANT, EGL_OPENGL_BIT);
d268 1
a268 1
      return;
d275 1
a275 1
      _eglAddConfig(disp, &conf->base);
d277 2
d294 1
a294 1
   int i;
d341 2
d364 2
d372 2
d378 1
a378 1
dri2_lookup_egl_image(__DRIcontext *context, void *image, void *data)
d380 1
a380 2
   struct dri2_egl_context *dri2_ctx = data;
   _EGLDisplay *disp = dri2_ctx->base.Resource.Display;
d384 2
d397 5
d416 2
a439 6
#ifdef GLX_USE_TLS
static const char dri_driver_format[] = "%.*s/tls/%s_dri.so";
#else
static const char dri_driver_format[] = "%.*s/%s_dri.so";
#endif

d451 1
a451 1
   { NULL }
d458 1
a458 1
   { NULL }
d622 2
d628 7
d644 10
a653 3
	 for (j = 0; dri2_dpy->driver_configs[j]; j++)
	    dri2_add_config(disp, dri2_dpy->driver_configs[j],
			    id++, d.data->depth, &visuals[i]);
d659 1
a659 1
   if (!disp->NumConfigs) {
a666 3
/**
 * Called via eglInitialize(), GLX_drv->API.Initialize().
 */
d668 1
a668 2
dri2_initialize(_EGLDriver *drv, _EGLDisplay *disp,
		EGLint *major, EGLint *minor)
d670 1
a671 1
   struct dri2_egl_display *dri2_dpy;
a673 23
   dri2_dpy = malloc(sizeof *dri2_dpy);
   if (!dri2_dpy)
      return _eglError(EGL_BAD_ALLOC, "eglInitialize");

   disp->DriverData = (void *) dri2_dpy;
   if (disp->NativeDisplay == NULL) {
      dri2_dpy->conn = xcb_connect(0, 0);
      if (!dri2_dpy->conn) {
	 _eglLog(_EGL_WARNING, "DRI2: xcb_connect failed");
	 goto cleanup_dpy;
      }
   } else {
      dri2_dpy->conn = XGetXCBConnection(disp->NativeDisplay);
   }

   if (dri2_dpy->conn == NULL)
      goto cleanup_conn;

   if (dri2_dpy->conn) {
      if (!dri2_connect(dri2_dpy))
	 goto cleanup_conn;
   }

d685 1
d690 2
d693 1
a693 1
	       dri_driver_format, (int) (next - p), p, dri2_dpy->driver_name);
d695 8
d706 1
a706 1
      _eglLog(_EGL_FATAL,
d709 1
a709 1
      goto cleanup_conn;
d715 1
a715 1
      _eglLog(_EGL_FATAL,
d717 87
a803 1
      goto cleanup_driver;
d806 2
a807 2
   if (!dri2_bind_extensions(dri2_dpy, dri2_driver_extensions, extensions))
      goto cleanup_driver;
d811 1
a811 1
      _eglLog(_EGL_FATAL,
a836 4
   dri2_dpy->image_lookup_extension.base.name = __DRI_IMAGE_LOOKUP;
   dri2_dpy->image_lookup_extension.base.version = 1;
   dri2_dpy->image_lookup_extension.lookupEGLImage = dri2_lookup_egl_image;

d838 1
a838 1
   dri2_dpy->extensions[1] = &dri2_dpy->image_lookup_extension.base;
d841 1
a841 6
   dri2_dpy->dri_screen =
      dri2_dpy->dri2->createNewScreen(0, dri2_dpy->fd, dri2_dpy->extensions,
				      &dri2_dpy->driver_configs, dri2_dpy);

   if (dri2_dpy->dri_screen == NULL) {
      _eglLog(_EGL_FATAL, "DRI2: failed to create dri screen");
a842 5
   }

   extensions = dri2_dpy->core->getExtensions(dri2_dpy->dri_screen);
   if (!dri2_bind_extensions(dri2_dpy, dri2_core_extensions, extensions))
      goto cleanup_dri_screen;
d849 1
a849 1
   disp->ClientAPIsMask = EGL_OPENGL_BIT;
d853 3
a864 1
 cleanup_dri_screen:
d871 1
a871 1
   if (disp->NativeDisplay == NULL)
d879 611
d1504 1
a1504 1
   if (disp->NativeDisplay == NULL)
d1524 4
d1538 45
a1582 6
   dri2_ctx->dri_context =
      dri2_dpy->dri2->createNewContext(dri2_dpy->dri_screen,
				       dri2_config->dri_config,
				       dri2_ctx_shared ? 
				       dri2_ctx_shared->dri_context : NULL,
				       dri2_ctx);
d1600 3
a1602 1
   if (_eglIsSurfaceBound(surf))
d1624 1
d1629 2
d1634 2
a1635 2
   /* bind the new context and return the "orphaned" one */
   if (!_eglBindContext(&ctx, &dsurf, &rsurf))
d1638 4
d1648 11
a1658 6
      if (dsurf && !_eglIsSurfaceLinked(dsurf))
	 dri2_destroy_surface(drv, disp, dsurf);
      if (rsurf && rsurf != dsurf && !_eglIsSurfaceLinked(dsurf))
	 dri2_destroy_surface(drv, disp, rsurf);
      if (ctx != NULL && !_eglIsContextLinked(ctx))
	 dri2_dpy->core->unbindContext(dri2_egl_context(ctx)->dri_context);
d1662 13
a1674 1
      _eglBindContext(&ctx, &dsurf, &rsurf);
d1696 2
d1711 1
a1711 2
      xcb_create_pixmap(dri2_dpy->conn,
			_eglGetConfigKey(conf, EGL_BUFFER_SIZE),
d1785 2
a1786 1
dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
d1788 1
d1791 1
d1794 6
d1818 1
a1818 1
					   dri2_surf->region,
d1826 38
d1870 2
d1883 2
d1896 3
d1921 2
d1953 1
a1953 2
   if (buffer != EGL_BACK_BUFFER) {
      _eglError(EGL_BAD_PARAMETER, "eglBindTexImage");
a1954 10
   }

   /* We allow binding pixmaps too... Not conformat, but we can do it
    * for free and it's useful for X compositors.  Supposedly there's
    * a EGL_NOKIA_texture_from_pixmap extension that allows that, but
    * I couldn't find it at this time. */
   if ((dri2_surf->base.Type & (EGL_PBUFFER_BIT | EGL_PIXMAP_BIT)) == 0) {
      _eglError(EGL_BAD_SURFACE, "eglBindTexImage");
      return EGL_FALSE;
   }
d1964 1
a1964 2
      _eglError(EGL_BAD_MATCH, "eglBindTexImage");
      return EGL_FALSE;
d1972 1
a1972 2
      _eglError(EGL_BAD_PARAMETER, "eglBindTexImage");
      return EGL_FALSE;
d1979 1
a1979 1
   return dri2_surf->base.BoundToTexture = EGL_TRUE;
d1986 5
a1998 1
   struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
d2010 2
d2060 1
a2060 1
   if (!_eglInitImage(&dri2_img->base, disp, attr_list)) {
d2068 1
a2068 1
      dri2_dpy->image->createImageFromName(dri2_ctx->dri_context,
d2103 1
a2103 1
   if (!_eglInitImage(&dri2_img->base, disp, attr_list))
d2115 63
d2182 2
d2189 2
d2203 2
d2211 108
d2328 2
d2353 3
d2359 3
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a42 6
#include <sys/types.h>
#include <sys/stat.h>

#ifdef HAVE_LIBUDEV
#include <libudev.h>
#endif
a53 2
#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))

a56 2

   void (*glFlush)(void);
d78 1
a115 4
static const __DRIuseInvalidateExtension use_invalidate = {
   { __DRI_USE_INVALIDATE, 1 }
};

d164 1
a164 1
   EGL_Y_INVERTED_NOK,		/* __DRI_ATTRIB_YINVERTED */
d167 1
a167 1
static struct dri2_egl_config *
d169 1
a169 1
		int depth, EGLint surface_type)
a181 4
   double_buffer = 0;
   bind_to_texture_rgb = 0;
   bind_to_texture_rgba = 0;

d232 1
a232 1
      return NULL;
d234 7
a240 2
   if (depth > 0 && depth != base.BufferSize)
      return NULL;
d242 5
a246 7
   base.NativeRenderable = EGL_TRUE;

   base.SurfaceType = surface_type;
   if (surface_type & (EGL_PIXMAP_BIT | EGL_PBUFFER_BIT)) {
      base.BindToTextureRGB = bind_to_texture_rgb;
      if (base.AlphaSize > 0)
         base.BindToTextureRGBA = bind_to_texture_rgba;
d249 9
a257 2
   base.RenderableType = disp->ClientAPIsMask;
   base.Conformant = disp->ClientAPIsMask;
d261 1
a261 1
      return NULL;
d268 1
a268 1
      _eglLinkConfig(&conf->base);
a269 2

   return conf;
d285 1
a285 1
   unsigned i;
a331 2
   (void) driDrawable;

a352 2
   (void) driDrawable;

a358 2
#else
   (void) loaderPrivate;
d363 1
a363 1
dri2_lookup_egl_image(__DRIscreen *screen, void *image, void *data)
d365 2
a366 1
   _EGLDisplay *disp = data;
a369 2
   (void) screen;

a380 5
static const __DRIimageLookupExtension image_lookup_extension = {
   { __DRI_IMAGE_LOOKUP, 1 },
   dri2_lookup_egl_image
};

a394 2
   (void) driDrawable;

d417 6
d434 1
a434 1
   { NULL, 0, 0 }
d441 1
a441 1
   { NULL, 0, 0 }
a604 2
   struct dri2_egl_config *conf;
   EGLint surface_type;
a608 7

   surface_type =
      EGL_WINDOW_BIT |
      EGL_PIXMAP_BIT |
      EGL_PBUFFER_BIT |
      EGL_SWAP_BEHAVIOR_PRESERVED_BIT;

d618 3
a620 10
	 for (j = 0; dri2_dpy->driver_configs[j]; j++) {
	    conf = dri2_add_config(disp, dri2_dpy->driver_configs[j],
				   id++, d.data->depth, surface_type);
	    if (conf == NULL)
	       continue;
	    _eglSetConfigKey(&conf->base,
			     EGL_NATIVE_VISUAL_ID, visuals[i].visual_id);
	    _eglSetConfigKey(&conf->base,
			     EGL_NATIVE_VISUAL_TYPE, visuals[i]._class);
	 }
d626 1
a626 1
   if (!_eglGetArraySize(disp->Configs)) {
d634 3
d638 2
a639 1
dri2_load_driver(_EGLDisplay *disp)
a640 1
   struct dri2_egl_display *dri2_dpy = disp->DriverData;
d642 1
d645 23
a678 1
      int len;
a682 2
      len = next - p;
#if GLX_USE_TLS
d684 1
a684 1
	       "%.*s/tls/%s_dri.so", len, p, dri2_dpy->driver_name);
a685 8
#endif
      if (dri2_dpy->driver == NULL) {
	 snprintf(path, sizeof path,
		  "%.*s/%s_dri.so", len, p, dri2_dpy->driver_name);
	 dri2_dpy->driver = dlopen(path, RTLD_NOW | RTLD_GLOBAL);
	 if (dri2_dpy->driver == NULL)
	    _eglLog(_EGL_DEBUG, "failed to open %s: %s\n", path, dlerror());
      }
d689 1
a689 1
      _eglLog(_EGL_WARNING,
d692 1
a692 1
      return EGL_FALSE;
d698 1
a698 1
      _eglLog(_EGL_WARNING,
d700 1
a700 2
      dlclose(dri2_dpy->driver);
      return EGL_FALSE;
d703 2
a704 87
   if (!dri2_bind_extensions(dri2_dpy, dri2_driver_extensions, extensions)) {
      dlclose(dri2_dpy->driver);
      return EGL_FALSE;
   }

   return EGL_TRUE;
}

static EGLBoolean
dri2_create_screen(_EGLDisplay *disp)
{
   const __DRIextension **extensions;
   struct dri2_egl_display *dri2_dpy;
   unsigned int api_mask;

   dri2_dpy = disp->DriverData;
   dri2_dpy->dri_screen =
      dri2_dpy->dri2->createNewScreen(0, dri2_dpy->fd, dri2_dpy->extensions,
				      &dri2_dpy->driver_configs, disp);

   if (dri2_dpy->dri_screen == NULL) {
      _eglLog(_EGL_WARNING, "DRI2: failed to create dri screen");
      return EGL_FALSE;
   }

   extensions = dri2_dpy->core->getExtensions(dri2_dpy->dri_screen);
   if (!dri2_bind_extensions(dri2_dpy, dri2_core_extensions, extensions))
      goto cleanup_dri_screen;

   if (dri2_dpy->dri2->base.version >= 2)
      api_mask = dri2_dpy->dri2->getAPIMask(dri2_dpy->dri_screen);
   else
      api_mask = 1 << __DRI_API_OPENGL;

   disp->ClientAPIsMask = 0;
   if (api_mask & (1 <<__DRI_API_OPENGL))
      disp->ClientAPIsMask |= EGL_OPENGL_BIT;
   if (api_mask & (1 <<__DRI_API_GLES))
      disp->ClientAPIsMask |= EGL_OPENGL_ES_BIT;
   if (api_mask & (1 << __DRI_API_GLES2))
      disp->ClientAPIsMask |= EGL_OPENGL_ES2_BIT;

   if (dri2_dpy->dri2->base.version >= 2) {
      disp->Extensions.KHR_surfaceless_gles1 = EGL_TRUE;
      disp->Extensions.KHR_surfaceless_gles2 = EGL_TRUE;
      disp->Extensions.KHR_surfaceless_opengl = EGL_TRUE;
   }

   return EGL_TRUE;

 cleanup_dri_screen:
   dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);

   return EGL_FALSE;
}

static EGLBoolean
dri2_initialize_x11(_EGLDriver *drv, _EGLDisplay *disp,
		    EGLint *major, EGLint *minor)
{
   struct dri2_egl_display *dri2_dpy;

   (void) drv;

   dri2_dpy = malloc(sizeof *dri2_dpy);
   if (!dri2_dpy)
      return _eglError(EGL_BAD_ALLOC, "eglInitialize");

   disp->DriverData = (void *) dri2_dpy;
   if (disp->PlatformDisplay == NULL) {
      dri2_dpy->conn = xcb_connect(0, 0);
   } else {
      dri2_dpy->conn = XGetXCBConnection((Display *) disp->PlatformDisplay);
   }

   if (xcb_connection_has_error(dri2_dpy->conn)) {
      _eglLog(_EGL_WARNING, "DRI2: xcb_connect failed");
      goto cleanup_dpy;
   }

   if (dri2_dpy->conn) {
      if (!dri2_connect(dri2_dpy))
	 goto cleanup_conn;
   }

   if (!dri2_load_driver(disp))
      goto cleanup_conn;
d708 1
a708 1
      _eglLog(_EGL_WARNING,
d734 4
d739 1
a739 1
   dri2_dpy->extensions[1] = &image_lookup_extension.base;
d742 6
a747 1
   if (!dri2_create_screen(disp))
d749 5
d760 1
a760 1
   disp->Extensions.MESA_drm_image = EGL_TRUE;
a763 3
   disp->Extensions.KHR_gl_texture_2D_image = EGL_TRUE;
   disp->Extensions.NOK_swap_region = EGL_TRUE;
   disp->Extensions.NOK_texture_from_pixmap = EGL_TRUE;
d773 1
d780 1
a780 1
   if (disp->PlatformDisplay == NULL)
a787 611
#ifdef HAVE_LIBUDEV

struct dri2_driver_map {
   int vendor_id;
   const char *driver;
   const int *chip_ids;
   int num_chips_ids;
};

const int i915_chip_ids[] = {
   0x3577, /* PCI_CHIP_I830_M */
   0x2562, /* PCI_CHIP_845_G */
   0x3582, /* PCI_CHIP_I855_GM */
   0x2572, /* PCI_CHIP_I865_G */
   0x2582, /* PCI_CHIP_I915_G */
   0x258a, /* PCI_CHIP_E7221_G */
   0x2592, /* PCI_CHIP_I915_GM */
   0x2772, /* PCI_CHIP_I945_G */
   0x27a2, /* PCI_CHIP_I945_GM */
   0x27ae, /* PCI_CHIP_I945_GME */
   0x29b2, /* PCI_CHIP_Q35_G */
   0x29c2, /* PCI_CHIP_G33_G */
   0x29d2, /* PCI_CHIP_Q33_G */
   0xa001, /* PCI_CHIP_IGD_G */
   0xa011, /* Pineview */
};

const int i965_chip_ids[] = {
   0x0042, /* PCI_CHIP_ILD_G */
   0x0046, /* PCI_CHIP_ILM_G */
   0x0102, /* PCI_CHIP_SANDYBRIDGE_GT1 */
   0x0106, /* PCI_CHIP_SANDYBRIDGE_M_GT1 */
   0x010a, /* PCI_CHIP_SANDYBRIDGE_S */
   0x0112, /* PCI_CHIP_SANDYBRIDGE_GT2 */
   0x0116, /* PCI_CHIP_SANDYBRIDGE_M_GT2 */
   0x0122, /* PCI_CHIP_SANDYBRIDGE_GT2_PLUS */
   0x0126, /* PCI_CHIP_SANDYBRIDGE_M_GT2_PLUS */
   0x29a2, /* PCI_CHIP_I965_G */
   0x2992, /* PCI_CHIP_I965_Q */
   0x2982, /* PCI_CHIP_I965_G_1 */
   0x2972, /* PCI_CHIP_I946_GZ */
   0x2a02, /* PCI_CHIP_I965_GM */
   0x2a12, /* PCI_CHIP_I965_GME */
   0x2a42, /* PCI_CHIP_GM45_GM */
   0x2e02, /* PCI_CHIP_IGD_E_G */
   0x2e12, /* PCI_CHIP_Q45_G */
   0x2e22, /* PCI_CHIP_G45_G */
   0x2e32, /* PCI_CHIP_G41_G */
   0x2e42, /* PCI_CHIP_B43_G */
   0x2e92, /* PCI_CHIP_B43_G1 */
};

const int r100_chip_ids[] = {
   0x4C57, /* PCI_CHIP_RADEON_LW */
   0x4C58, /* PCI_CHIP_RADEON_LX */
   0x4C59, /* PCI_CHIP_RADEON_LY */
   0x4C5A, /* PCI_CHIP_RADEON_LZ */
   0x5144, /* PCI_CHIP_RADEON_QD */
   0x5145, /* PCI_CHIP_RADEON_QE */
   0x5146, /* PCI_CHIP_RADEON_QF */
   0x5147, /* PCI_CHIP_RADEON_QG */
   0x5159, /* PCI_CHIP_RADEON_QY */
   0x515A, /* PCI_CHIP_RADEON_QZ */
   0x5157, /* PCI_CHIP_RV200_QW */
   0x5158, /* PCI_CHIP_RV200_QX */
   0x515E, /* PCI_CHIP_RN50_515E */
   0x5969, /* PCI_CHIP_RN50_5969 */
   0x4136, /* PCI_CHIP_RS100_4136 */
   0x4336, /* PCI_CHIP_RS100_4336 */
   0x4137, /* PCI_CHIP_RS200_4137 */
   0x4337, /* PCI_CHIP_RS200_4337 */
   0x4237, /* PCI_CHIP_RS250_4237 */
   0x4437, /* PCI_CHIP_RS250_4437 */
};

const int r200_chip_ids[] = {
   0x5148, /* PCI_CHIP_R200_QH */
   0x514C, /* PCI_CHIP_R200_QL */
   0x514D, /* PCI_CHIP_R200_QM */
   0x4242, /* PCI_CHIP_R200_BB */
   0x4243, /* PCI_CHIP_R200_BC */
   0x4966, /* PCI_CHIP_RV250_If */
   0x4967, /* PCI_CHIP_RV250_Ig */
   0x4C64, /* PCI_CHIP_RV250_Ld */
   0x4C66, /* PCI_CHIP_RV250_Lf */
   0x4C67, /* PCI_CHIP_RV250_Lg */
   0x5960, /* PCI_CHIP_RV280_5960 */
   0x5961, /* PCI_CHIP_RV280_5961 */
   0x5962, /* PCI_CHIP_RV280_5962 */
   0x5964, /* PCI_CHIP_RV280_5964 */
   0x5965, /* PCI_CHIP_RV280_5965 */
   0x5C61, /* PCI_CHIP_RV280_5C61 */
   0x5C63, /* PCI_CHIP_RV280_5C63 */
   0x5834, /* PCI_CHIP_RS300_5834 */
   0x5835, /* PCI_CHIP_RS300_5835 */
   0x7834, /* PCI_CHIP_RS350_7834 */
   0x7835, /* PCI_CHIP_RS350_7835 */
};

const int r300_chip_ids[] = {
   0x4144, /* PCI_CHIP_R300_AD */
   0x4145, /* PCI_CHIP_R300_AE */
   0x4146, /* PCI_CHIP_R300_AF */
   0x4147, /* PCI_CHIP_R300_AG */
   0x4E44, /* PCI_CHIP_R300_ND */
   0x4E45, /* PCI_CHIP_R300_NE */
   0x4E46, /* PCI_CHIP_R300_NF */
   0x4E47, /* PCI_CHIP_R300_NG */
   0x4E48, /* PCI_CHIP_R350_NH */
   0x4E49, /* PCI_CHIP_R350_NI */
   0x4E4B, /* PCI_CHIP_R350_NK */
   0x4148, /* PCI_CHIP_R350_AH */
   0x4149, /* PCI_CHIP_R350_AI */
   0x414A, /* PCI_CHIP_R350_AJ */
   0x414B, /* PCI_CHIP_R350_AK */
   0x4E4A, /* PCI_CHIP_R360_NJ */
   0x4150, /* PCI_CHIP_RV350_AP */
   0x4151, /* PCI_CHIP_RV350_AQ */
   0x4152, /* PCI_CHIP_RV350_AR */
   0x4153, /* PCI_CHIP_RV350_AS */
   0x4154, /* PCI_CHIP_RV350_AT */
   0x4155, /* PCI_CHIP_RV350_AU */
   0x4156, /* PCI_CHIP_RV350_AV */
   0x4E50, /* PCI_CHIP_RV350_NP */
   0x4E51, /* PCI_CHIP_RV350_NQ */
   0x4E52, /* PCI_CHIP_RV350_NR */
   0x4E53, /* PCI_CHIP_RV350_NS */
   0x4E54, /* PCI_CHIP_RV350_NT */
   0x4E56, /* PCI_CHIP_RV350_NV */
   0x5460, /* PCI_CHIP_RV370_5460 */
   0x5462, /* PCI_CHIP_RV370_5462 */
   0x5464, /* PCI_CHIP_RV370_5464 */
   0x5B60, /* PCI_CHIP_RV370_5B60 */
   0x5B62, /* PCI_CHIP_RV370_5B62 */
   0x5B63, /* PCI_CHIP_RV370_5B63 */
   0x5B64, /* PCI_CHIP_RV370_5B64 */
   0x5B65, /* PCI_CHIP_RV370_5B65 */
   0x3150, /* PCI_CHIP_RV380_3150 */
   0x3152, /* PCI_CHIP_RV380_3152 */
   0x3154, /* PCI_CHIP_RV380_3154 */
   0x3155, /* PCI_CHIP_RV380_3155 */
   0x3E50, /* PCI_CHIP_RV380_3E50 */
   0x3E54, /* PCI_CHIP_RV380_3E54 */
   0x4A48, /* PCI_CHIP_R420_JH */
   0x4A49, /* PCI_CHIP_R420_JI */
   0x4A4A, /* PCI_CHIP_R420_JJ */
   0x4A4B, /* PCI_CHIP_R420_JK */
   0x4A4C, /* PCI_CHIP_R420_JL */
   0x4A4D, /* PCI_CHIP_R420_JM */
   0x4A4E, /* PCI_CHIP_R420_JN */
   0x4A4F, /* PCI_CHIP_R420_JO */
   0x4A50, /* PCI_CHIP_R420_JP */
   0x4A54, /* PCI_CHIP_R420_JT */
   0x5548, /* PCI_CHIP_R423_UH */
   0x5549, /* PCI_CHIP_R423_UI */
   0x554A, /* PCI_CHIP_R423_UJ */
   0x554B, /* PCI_CHIP_R423_UK */
   0x5550, /* PCI_CHIP_R423_5550 */
   0x5551, /* PCI_CHIP_R423_UQ */
   0x5552, /* PCI_CHIP_R423_UR */
   0x5554, /* PCI_CHIP_R423_UT */
   0x5D57, /* PCI_CHIP_R423_5D57 */
   0x554C, /* PCI_CHIP_R430_554C */
   0x554D, /* PCI_CHIP_R430_554D */
   0x554E, /* PCI_CHIP_R430_554E */
   0x554F, /* PCI_CHIP_R430_554F */
   0x5D48, /* PCI_CHIP_R430_5D48 */
   0x5D49, /* PCI_CHIP_R430_5D49 */
   0x5D4A, /* PCI_CHIP_R430_5D4A */
   0x5D4C, /* PCI_CHIP_R480_5D4C */
   0x5D4D, /* PCI_CHIP_R480_5D4D */
   0x5D4E, /* PCI_CHIP_R480_5D4E */
   0x5D4F, /* PCI_CHIP_R480_5D4F */
   0x5D50, /* PCI_CHIP_R480_5D50 */
   0x5D52, /* PCI_CHIP_R480_5D52 */
   0x4B49, /* PCI_CHIP_R481_4B49 */
   0x4B4A, /* PCI_CHIP_R481_4B4A */
   0x4B4B, /* PCI_CHIP_R481_4B4B */
   0x4B4C, /* PCI_CHIP_R481_4B4C */
   0x564A, /* PCI_CHIP_RV410_564A */
   0x564B, /* PCI_CHIP_RV410_564B */
   0x564F, /* PCI_CHIP_RV410_564F */
   0x5652, /* PCI_CHIP_RV410_5652 */
   0x5653, /* PCI_CHIP_RV410_5653 */
   0x5657, /* PCI_CHIP_RV410_5657 */
   0x5E48, /* PCI_CHIP_RV410_5E48 */
   0x5E4A, /* PCI_CHIP_RV410_5E4A */
   0x5E4B, /* PCI_CHIP_RV410_5E4B */
   0x5E4C, /* PCI_CHIP_RV410_5E4C */
   0x5E4D, /* PCI_CHIP_RV410_5E4D */
   0x5E4F, /* PCI_CHIP_RV410_5E4F */
   0x5A41, /* PCI_CHIP_RS400_5A41 */
   0x5A42, /* PCI_CHIP_RS400_5A42 */
   0x5A61, /* PCI_CHIP_RC410_5A61 */
   0x5A62, /* PCI_CHIP_RC410_5A62 */
   0x5954, /* PCI_CHIP_RS480_5954 */
   0x5955, /* PCI_CHIP_RS480_5955 */
   0x5974, /* PCI_CHIP_RS482_5974 */
   0x5975, /* PCI_CHIP_RS482_5975 */
   0x7100, /* PCI_CHIP_R520_7100 */
   0x7101, /* PCI_CHIP_R520_7101 */
   0x7102, /* PCI_CHIP_R520_7102 */
   0x7103, /* PCI_CHIP_R520_7103 */
   0x7104, /* PCI_CHIP_R520_7104 */
   0x7105, /* PCI_CHIP_R520_7105 */
   0x7106, /* PCI_CHIP_R520_7106 */
   0x7108, /* PCI_CHIP_R520_7108 */
   0x7109, /* PCI_CHIP_R520_7109 */
   0x710A, /* PCI_CHIP_R520_710A */
   0x710B, /* PCI_CHIP_R520_710B */
   0x710C, /* PCI_CHIP_R520_710C */
   0x710E, /* PCI_CHIP_R520_710E */
   0x710F, /* PCI_CHIP_R520_710F */
   0x7140, /* PCI_CHIP_RV515_7140 */
   0x7141, /* PCI_CHIP_RV515_7141 */
   0x7142, /* PCI_CHIP_RV515_7142 */
   0x7143, /* PCI_CHIP_RV515_7143 */
   0x7144, /* PCI_CHIP_RV515_7144 */
   0x7145, /* PCI_CHIP_RV515_7145 */
   0x7146, /* PCI_CHIP_RV515_7146 */
   0x7147, /* PCI_CHIP_RV515_7147 */
   0x7149, /* PCI_CHIP_RV515_7149 */
   0x714A, /* PCI_CHIP_RV515_714A */
   0x714B, /* PCI_CHIP_RV515_714B */
   0x714C, /* PCI_CHIP_RV515_714C */
   0x714D, /* PCI_CHIP_RV515_714D */
   0x714E, /* PCI_CHIP_RV515_714E */
   0x714F, /* PCI_CHIP_RV515_714F */
   0x7151, /* PCI_CHIP_RV515_7151 */
   0x7152, /* PCI_CHIP_RV515_7152 */
   0x7153, /* PCI_CHIP_RV515_7153 */
   0x715E, /* PCI_CHIP_RV515_715E */
   0x715F, /* PCI_CHIP_RV515_715F */
   0x7180, /* PCI_CHIP_RV515_7180 */
   0x7181, /* PCI_CHIP_RV515_7181 */
   0x7183, /* PCI_CHIP_RV515_7183 */
   0x7186, /* PCI_CHIP_RV515_7186 */
   0x7187, /* PCI_CHIP_RV515_7187 */
   0x7188, /* PCI_CHIP_RV515_7188 */
   0x718A, /* PCI_CHIP_RV515_718A */
   0x718B, /* PCI_CHIP_RV515_718B */
   0x718C, /* PCI_CHIP_RV515_718C */
   0x718D, /* PCI_CHIP_RV515_718D */
   0x718F, /* PCI_CHIP_RV515_718F */
   0x7193, /* PCI_CHIP_RV515_7193 */
   0x7196, /* PCI_CHIP_RV515_7196 */
   0x719B, /* PCI_CHIP_RV515_719B */
   0x719F, /* PCI_CHIP_RV515_719F */
   0x7200, /* PCI_CHIP_RV515_7200 */
   0x7210, /* PCI_CHIP_RV515_7210 */
   0x7211, /* PCI_CHIP_RV515_7211 */
   0x71C0, /* PCI_CHIP_RV530_71C0 */
   0x71C1, /* PCI_CHIP_RV530_71C1 */
   0x71C2, /* PCI_CHIP_RV530_71C2 */
   0x71C3, /* PCI_CHIP_RV530_71C3 */
   0x71C4, /* PCI_CHIP_RV530_71C4 */
   0x71C5, /* PCI_CHIP_RV530_71C5 */
   0x71C6, /* PCI_CHIP_RV530_71C6 */
   0x71C7, /* PCI_CHIP_RV530_71C7 */
   0x71CD, /* PCI_CHIP_RV530_71CD */
   0x71CE, /* PCI_CHIP_RV530_71CE */
   0x71D2, /* PCI_CHIP_RV530_71D2 */
   0x71D4, /* PCI_CHIP_RV530_71D4 */
   0x71D5, /* PCI_CHIP_RV530_71D5 */
   0x71D6, /* PCI_CHIP_RV530_71D6 */
   0x71DA, /* PCI_CHIP_RV530_71DA */
   0x71DE, /* PCI_CHIP_RV530_71DE */
   0x7281, /* PCI_CHIP_RV560_7281 */
   0x7283, /* PCI_CHIP_RV560_7283 */
   0x7287, /* PCI_CHIP_RV560_7287 */
   0x7290, /* PCI_CHIP_RV560_7290 */
   0x7291, /* PCI_CHIP_RV560_7291 */
   0x7293, /* PCI_CHIP_RV560_7293 */
   0x7297, /* PCI_CHIP_RV560_7297 */
   0x7280, /* PCI_CHIP_RV570_7280 */
   0x7288, /* PCI_CHIP_RV570_7288 */
   0x7289, /* PCI_CHIP_RV570_7289 */
   0x728B, /* PCI_CHIP_RV570_728B */
   0x728C, /* PCI_CHIP_RV570_728C */
   0x7240, /* PCI_CHIP_R580_7240 */
   0x7243, /* PCI_CHIP_R580_7243 */
   0x7244, /* PCI_CHIP_R580_7244 */
   0x7245, /* PCI_CHIP_R580_7245 */
   0x7246, /* PCI_CHIP_R580_7246 */
   0x7247, /* PCI_CHIP_R580_7247 */
   0x7248, /* PCI_CHIP_R580_7248 */
   0x7249, /* PCI_CHIP_R580_7249 */
   0x724A, /* PCI_CHIP_R580_724A */
   0x724B, /* PCI_CHIP_R580_724B */
   0x724C, /* PCI_CHIP_R580_724C */
   0x724D, /* PCI_CHIP_R580_724D */
   0x724E, /* PCI_CHIP_R580_724E */
   0x724F, /* PCI_CHIP_R580_724F */
   0x7284, /* PCI_CHIP_R580_7284 */
   0x793F, /* PCI_CHIP_RS600_793F */
   0x7941, /* PCI_CHIP_RS600_7941 */
   0x7942, /* PCI_CHIP_RS600_7942 */
   0x791E, /* PCI_CHIP_RS690_791E */
   0x791F, /* PCI_CHIP_RS690_791F */
   0x796C, /* PCI_CHIP_RS740_796C */
   0x796D, /* PCI_CHIP_RS740_796D */
   0x796E, /* PCI_CHIP_RS740_796E */
   0x796F, /* PCI_CHIP_RS740_796F */
};

const int r600_chip_ids[] = {
   0x9400, /* PCI_CHIP_R600_9400 */
   0x9401, /* PCI_CHIP_R600_9401 */
   0x9402, /* PCI_CHIP_R600_9402 */
   0x9403, /* PCI_CHIP_R600_9403 */
   0x9405, /* PCI_CHIP_R600_9405 */
   0x940A, /* PCI_CHIP_R600_940A */
   0x940B, /* PCI_CHIP_R600_940B */
   0x940F, /* PCI_CHIP_R600_940F */
   0x94C0, /* PCI_CHIP_RV610_94C0 */
   0x94C1, /* PCI_CHIP_RV610_94C1 */
   0x94C3, /* PCI_CHIP_RV610_94C3 */
   0x94C4, /* PCI_CHIP_RV610_94C4 */
   0x94C5, /* PCI_CHIP_RV610_94C5 */
   0x94C6, /* PCI_CHIP_RV610_94C6 */
   0x94C7, /* PCI_CHIP_RV610_94C7 */
   0x94C8, /* PCI_CHIP_RV610_94C8 */
   0x94C9, /* PCI_CHIP_RV610_94C9 */
   0x94CB, /* PCI_CHIP_RV610_94CB */
   0x94CC, /* PCI_CHIP_RV610_94CC */
   0x94CD, /* PCI_CHIP_RV610_94CD */
   0x9580, /* PCI_CHIP_RV630_9580 */
   0x9581, /* PCI_CHIP_RV630_9581 */
   0x9583, /* PCI_CHIP_RV630_9583 */
   0x9586, /* PCI_CHIP_RV630_9586 */
   0x9587, /* PCI_CHIP_RV630_9587 */
   0x9588, /* PCI_CHIP_RV630_9588 */
   0x9589, /* PCI_CHIP_RV630_9589 */
   0x958A, /* PCI_CHIP_RV630_958A */
   0x958B, /* PCI_CHIP_RV630_958B */
   0x958C, /* PCI_CHIP_RV630_958C */
   0x958D, /* PCI_CHIP_RV630_958D */
   0x958E, /* PCI_CHIP_RV630_958E */
   0x958F, /* PCI_CHIP_RV630_958F */
   0x9500, /* PCI_CHIP_RV670_9500 */
   0x9501, /* PCI_CHIP_RV670_9501 */
   0x9504, /* PCI_CHIP_RV670_9504 */
   0x9505, /* PCI_CHIP_RV670_9505 */
   0x9506, /* PCI_CHIP_RV670_9506 */
   0x9507, /* PCI_CHIP_RV670_9507 */
   0x9508, /* PCI_CHIP_RV670_9508 */
   0x9509, /* PCI_CHIP_RV670_9509 */
   0x950F, /* PCI_CHIP_RV670_950F */
   0x9511, /* PCI_CHIP_RV670_9511 */
   0x9515, /* PCI_CHIP_RV670_9515 */
   0x9517, /* PCI_CHIP_RV670_9517 */
   0x9519, /* PCI_CHIP_RV670_9519 */
   0x95C0, /* PCI_CHIP_RV620_95C0 */
   0x95C2, /* PCI_CHIP_RV620_95C2 */
   0x95C4, /* PCI_CHIP_RV620_95C4 */
   0x95C5, /* PCI_CHIP_RV620_95C5 */
   0x95C6, /* PCI_CHIP_RV620_95C6 */
   0x95C7, /* PCI_CHIP_RV620_95C7 */
   0x95C9, /* PCI_CHIP_RV620_95C9 */
   0x95CC, /* PCI_CHIP_RV620_95CC */
   0x95CD, /* PCI_CHIP_RV620_95CD */
   0x95CE, /* PCI_CHIP_RV620_95CE */
   0x95CF, /* PCI_CHIP_RV620_95CF */
   0x9590, /* PCI_CHIP_RV635_9590 */
   0x9591, /* PCI_CHIP_RV635_9591 */
   0x9593, /* PCI_CHIP_RV635_9593 */
   0x9595, /* PCI_CHIP_RV635_9595 */
   0x9596, /* PCI_CHIP_RV635_9596 */
   0x9597, /* PCI_CHIP_RV635_9597 */
   0x9598, /* PCI_CHIP_RV635_9598 */
   0x9599, /* PCI_CHIP_RV635_9599 */
   0x959B, /* PCI_CHIP_RV635_959B */
   0x9610, /* PCI_CHIP_RS780_9610 */
   0x9611, /* PCI_CHIP_RS780_9611 */
   0x9612, /* PCI_CHIP_RS780_9612 */
   0x9613, /* PCI_CHIP_RS780_9613 */
   0x9614, /* PCI_CHIP_RS780_9614 */
   0x9615, /* PCI_CHIP_RS780_9615 */
   0x9616, /* PCI_CHIP_RS780_9616 */
   0x9710, /* PCI_CHIP_RS880_9710 */
   0x9711, /* PCI_CHIP_RS880_9711 */
   0x9712, /* PCI_CHIP_RS880_9712 */
   0x9713, /* PCI_CHIP_RS880_9713 */
   0x9714, /* PCI_CHIP_RS880_9714 */
   0x9715, /* PCI_CHIP_RS880_9715 */
   0x9440, /* PCI_CHIP_RV770_9440 */
   0x9441, /* PCI_CHIP_RV770_9441 */
   0x9442, /* PCI_CHIP_RV770_9442 */
   0x9443, /* PCI_CHIP_RV770_9443 */
   0x9444, /* PCI_CHIP_RV770_9444 */
   0x9446, /* PCI_CHIP_RV770_9446 */
   0x944A, /* PCI_CHIP_RV770_944A */
   0x944B, /* PCI_CHIP_RV770_944B */
   0x944C, /* PCI_CHIP_RV770_944C */
   0x944E, /* PCI_CHIP_RV770_944E */
   0x9450, /* PCI_CHIP_RV770_9450 */
   0x9452, /* PCI_CHIP_RV770_9452 */
   0x9456, /* PCI_CHIP_RV770_9456 */
   0x945A, /* PCI_CHIP_RV770_945A */
   0x945B, /* PCI_CHIP_RV770_945B */
   0x945E, /* PCI_CHIP_RV770_945E */
   0x9460, /* PCI_CHIP_RV790_9460 */
   0x9462, /* PCI_CHIP_RV790_9462 */
   0x946A, /* PCI_CHIP_RV770_946A */
   0x946B, /* PCI_CHIP_RV770_946B */
   0x947A, /* PCI_CHIP_RV770_947A */
   0x947B, /* PCI_CHIP_RV770_947B */
   0x9480, /* PCI_CHIP_RV730_9480 */
   0x9487, /* PCI_CHIP_RV730_9487 */
   0x9488, /* PCI_CHIP_RV730_9488 */
   0x9489, /* PCI_CHIP_RV730_9489 */
   0x948A, /* PCI_CHIP_RV730_948A */
   0x948F, /* PCI_CHIP_RV730_948F */
   0x9490, /* PCI_CHIP_RV730_9490 */
   0x9491, /* PCI_CHIP_RV730_9491 */
   0x9495, /* PCI_CHIP_RV730_9495 */
   0x9498, /* PCI_CHIP_RV730_9498 */
   0x949C, /* PCI_CHIP_RV730_949C */
   0x949E, /* PCI_CHIP_RV730_949E */
   0x949F, /* PCI_CHIP_RV730_949F */
   0x9540, /* PCI_CHIP_RV710_9540 */
   0x9541, /* PCI_CHIP_RV710_9541 */
   0x9542, /* PCI_CHIP_RV710_9542 */
   0x954E, /* PCI_CHIP_RV710_954E */
   0x954F, /* PCI_CHIP_RV710_954F */
   0x9552, /* PCI_CHIP_RV710_9552 */
   0x9553, /* PCI_CHIP_RV710_9553 */
   0x9555, /* PCI_CHIP_RV710_9555 */
   0x9557, /* PCI_CHIP_RV710_9557 */
   0x955F, /* PCI_CHIP_RV710_955F */
   0x94A0, /* PCI_CHIP_RV740_94A0 */
   0x94A1, /* PCI_CHIP_RV740_94A1 */
   0x94A3, /* PCI_CHIP_RV740_94A3 */
   0x94B1, /* PCI_CHIP_RV740_94B1 */
   0x94B3, /* PCI_CHIP_RV740_94B3 */
   0x94B4, /* PCI_CHIP_RV740_94B4 */
   0x94B5, /* PCI_CHIP_RV740_94B5 */
   0x94B9, /* PCI_CHIP_RV740_94B9 */
   0x68E0, /* PCI_CHIP_CEDAR_68E0 */
   0x68E1, /* PCI_CHIP_CEDAR_68E1 */
   0x68E4, /* PCI_CHIP_CEDAR_68E4 */
   0x68E5, /* PCI_CHIP_CEDAR_68E5 */
   0x68E8, /* PCI_CHIP_CEDAR_68E8 */
   0x68E9, /* PCI_CHIP_CEDAR_68E9 */
   0x68F1, /* PCI_CHIP_CEDAR_68F1 */
   0x68F8, /* PCI_CHIP_CEDAR_68F8 */
   0x68F9, /* PCI_CHIP_CEDAR_68F9 */
   0x68FE, /* PCI_CHIP_CEDAR_68FE */
   0x68C0, /* PCI_CHIP_REDWOOD_68C0 */
   0x68C1, /* PCI_CHIP_REDWOOD_68C1 */
   0x68C8, /* PCI_CHIP_REDWOOD_68C8 */
   0x68C9, /* PCI_CHIP_REDWOOD_68C9 */
   0x68D8, /* PCI_CHIP_REDWOOD_68D8 */
   0x68D9, /* PCI_CHIP_REDWOOD_68D9 */
   0x68DA, /* PCI_CHIP_REDWOOD_68DA */
   0x68DE, /* PCI_CHIP_REDWOOD_68DE */
   0x68A0, /* PCI_CHIP_JUNIPER_68A0 */
   0x68A1, /* PCI_CHIP_JUNIPER_68A1 */
   0x68A8, /* PCI_CHIP_JUNIPER_68A8 */
   0x68A9, /* PCI_CHIP_JUNIPER_68A9 */
   0x68B0, /* PCI_CHIP_JUNIPER_68B0 */
   0x68B8, /* PCI_CHIP_JUNIPER_68B8 */
   0x68B9, /* PCI_CHIP_JUNIPER_68B9 */
   0x68BE, /* PCI_CHIP_JUNIPER_68BE */
   0x6880, /* PCI_CHIP_CYPRESS_6880 */
   0x6888, /* PCI_CHIP_CYPRESS_6888 */
   0x6889, /* PCI_CHIP_CYPRESS_6889 */
   0x688A, /* PCI_CHIP_CYPRESS_688A */
   0x6898, /* PCI_CHIP_CYPRESS_6898 */
   0x6899, /* PCI_CHIP_CYPRESS_6899 */
   0x689E, /* PCI_CHIP_CYPRESS_689E */
   0x689C, /* PCI_CHIP_HEMLOCK_689C */
   0x689D, /* PCI_CHIP_HEMLOCK_689D */
};

const struct dri2_driver_map driver_map[] = {
   { 0x8086, "i915", i915_chip_ids, ARRAY_SIZE(i915_chip_ids) },
   { 0x8086, "i965", i965_chip_ids, ARRAY_SIZE(i965_chip_ids) },
   { 0x1002, "radeon", r100_chip_ids, ARRAY_SIZE(r100_chip_ids) },
   { 0x1002, "r200", r200_chip_ids, ARRAY_SIZE(r200_chip_ids) },
   { 0x1002, "r300", r300_chip_ids, ARRAY_SIZE(r300_chip_ids) },
   { 0x1002, "r600", r600_chip_ids, ARRAY_SIZE(r600_chip_ids) },
};

static char *
dri2_get_driver_for_fd(int fd)
{
   struct udev *udev;
   struct udev_device *device, *parent;
   struct stat buf;
   const char *pci_id;
   char *driver = NULL;
   int vendor_id, chip_id, i, j;

   udev = udev_new();
   if (fstat(fd, &buf) < 0) {
      _eglLog(_EGL_WARNING, "EGL-DRI2: failed to stat fd %d", fd);
      goto out;
   }

   device = udev_device_new_from_devnum(udev, 'c', buf.st_rdev);
   if (device == NULL) {
      _eglLog(_EGL_WARNING,
	      "EGL-DRI2: could not create udev device for fd %d", fd);
      goto out;
   }

   parent = udev_device_get_parent(device);
   if (parent == NULL) {
      _eglLog(_EGL_WARNING, "DRI2: could not get parent device");
      goto out;
   }

   pci_id = udev_device_get_property_value(parent, "PCI_ID");
   if (pci_id == NULL || sscanf(pci_id, "%x:%x", &vendor_id, &chip_id) != 2) {
      _eglLog(_EGL_WARNING, "EGL-DRI2: malformed or no PCI ID");
      goto out;
   }

   for (i = 0; i < ARRAY_SIZE(driver_map); i++) {
      if (vendor_id != driver_map[i].vendor_id)
	 continue;
      for (j = 0; j < driver_map[i].num_chips_ids; j++)
	 if (driver_map[i].chip_ids[j] == chip_id) {
	    driver = strdup(driver_map[i].driver);
	    _eglLog(_EGL_DEBUG, "pci id for %d: %04x:%04x, driver %s",
		    fd, vendor_id, chip_id, driver);
	    goto out;
	 }
   }

 out:
   udev_device_unref(device);
   udev_unref(udev);

   return driver;
}

static EGLBoolean
dri2_initialize_drm(_EGLDriver *drv, _EGLDisplay *disp,
		    EGLint *major, EGLint *minor)
{
   struct dri2_egl_display *dri2_dpy;
   int i;

   dri2_dpy = malloc(sizeof *dri2_dpy);
   if (!dri2_dpy)
      return _eglError(EGL_BAD_ALLOC, "eglInitialize");

   disp->DriverData = (void *) dri2_dpy;
   dri2_dpy->fd = (int) disp->PlatformDisplay;

   dri2_dpy->driver_name = dri2_get_driver_for_fd(dri2_dpy->fd);
   if (dri2_dpy->driver_name == NULL)
      return _eglError(EGL_BAD_ALLOC, "DRI2: failed to get driver name");

   if (!dri2_load_driver(disp))
      goto cleanup_driver_name;

   dri2_dpy->extensions[0] = &image_lookup_extension.base;
   dri2_dpy->extensions[1] = &use_invalidate.base;
   dri2_dpy->extensions[2] = NULL;

   if (!dri2_create_screen(disp))
      goto cleanup_driver;

   for (i = 0; dri2_dpy->driver_configs[i]; i++)
      dri2_add_config(disp, dri2_dpy->driver_configs[i], i + 1, 0, 0);

   disp->Extensions.MESA_drm_image = EGL_TRUE;
   disp->Extensions.KHR_image_base = EGL_TRUE;
   disp->Extensions.KHR_gl_renderbuffer_image = EGL_TRUE;
   disp->Extensions.KHR_gl_texture_2D_image = EGL_TRUE;

   /* we're supporting EGL 1.4 */
   *major = 1;
   *minor = 4;

   return EGL_TRUE;

 cleanup_driver:
   dlclose(dri2_dpy->driver);
 cleanup_driver_name:
   free(dri2_dpy->driver_name);

   return EGL_FALSE;
}

#endif

/**
 * Called via eglInitialize(), GLX_drv->API.Initialize().
 */
static EGLBoolean
dri2_initialize(_EGLDriver *drv, _EGLDisplay *disp,
		EGLint *major, EGLint *minor)
{
   switch (disp->Platform) {
   case _EGL_PLATFORM_X11:
      return dri2_initialize_x11(drv, disp, major, minor);

#ifdef HAVE_LIBUDEV
   case _EGL_PLATFORM_DRM:
      return dri2_initialize_drm(drv, disp, major, minor);
#endif

   default:
      return EGL_FALSE;
   }
}

d802 1
a802 1
   if (disp->PlatformDisplay == NULL)
a821 4
   const __DRIconfig *dri_config;
   int api;

   (void) drv;
d832 6
a837 45
   switch (dri2_ctx->base.ClientAPI) {
   case EGL_OPENGL_ES_API:
      switch (dri2_ctx->base.ClientVersion) {
      case 1:
         api = __DRI_API_GLES;
         break;
      case 2:
         api = __DRI_API_GLES2;
         break;
      default:
	 _eglError(EGL_BAD_PARAMETER, "eglCreateContext");
	 return NULL;
      }
      break;
   case EGL_OPENGL_API:
      api = __DRI_API_OPENGL;
      break;
   default:
      _eglError(EGL_BAD_PARAMETER, "eglCreateContext");
      return NULL;
   }

   if (conf != NULL)
      dri_config = dri2_config->dri_config;
   else
      dri_config = NULL;

   if (dri2_dpy->dri2->base.version >= 2) {
      dri2_ctx->dri_context =
	 dri2_dpy->dri2->createNewContextForAPI(dri2_dpy->dri_screen,
						api,
						dri_config,
						dri2_ctx_shared ? 
						dri2_ctx_shared->dri_context : NULL,
						dri2_ctx);
   } else if (api == __DRI_API_OPENGL) {
      dri2_ctx->dri_context =
	 dri2_dpy->dri2->createNewContext(dri2_dpy->dri_screen,
					  dri2_config->dri_config,
					  dri2_ctx_shared ? 
					  dri2_ctx_shared->dri_context : NULL,
					  dri2_ctx);
   } else {
      /* fail */
   }
d855 1
a855 3
   (void) drv;

   if (!_eglPutSurface(surf))
a876 1
   struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);
a880 2
   _EGLContext *old_ctx;
   _EGLSurface *old_dsurf, *old_rsurf;
d884 2
a885 2
   /* make new bindings */
   if (!_eglBindContext(ctx, dsurf, rsurf, &old_ctx, &old_dsurf, &old_rsurf))
a887 4
   /* flush before context switch */
   if (old_ctx && dri2_drv->glFlush)
      dri2_drv->glFlush();

d894 6
a899 11
      dri2_destroy_surface(drv, disp, old_dsurf);
      dri2_destroy_surface(drv, disp, old_rsurf);
      if (old_ctx) {
         /* unbind the old context only when there is no new context bound */
         if (!ctx) {
            __DRIcontext *old_cctx = dri2_egl_context(old_ctx)->dri_context;
            dri2_dpy->core->unbindContext(old_cctx);
         }
         /* no destroy? */
         _eglPutContext(old_ctx);
      }
d903 1
a903 13
      /* undo the previous _eglBindContext */
      _eglBindContext(old_ctx, old_dsurf, old_rsurf, &ctx, &dsurf, &rsurf);
      assert(&dri2_ctx->base == ctx &&
             &dri2_dsurf->base == dsurf &&
             &dri2_rsurf->base == rsurf);

      _eglPutSurface(dsurf);
      _eglPutSurface(rsurf);
      _eglPutContext(ctx);

      _eglPutSurface(old_dsurf);
      _eglPutSurface(old_rsurf);
      _eglPutContext(old_ctx);
a924 2
   (void) drv;

d938 2
a939 1
      xcb_create_pixmap(dri2_dpy->conn, conf->BufferSize,
d1013 1
a1013 2
dri2_copy_region(_EGLDriver *drv, _EGLDisplay *disp,
		 _EGLSurface *draw, xcb_xfixes_region_t region)
a1014 1
   struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);
a1016 1
   _EGLContext *ctx;
a1018 6
   if (dri2_drv->glFlush) {
      ctx = _eglGetCurrentContext();
      if (ctx && ctx->DrawSurface == &dri2_surf->base)
         dri2_drv->glFlush();
   }

d1037 1
a1037 1
					   region,
a1044 38
static EGLBoolean
dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
{
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);

   return dri2_copy_region(drv, disp, draw, dri2_surf->region);
}

static EGLBoolean
dri2_swap_buffers_region(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw,
			 EGLint numRects, const EGLint *rects)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);
   EGLBoolean ret;
   xcb_xfixes_region_t region;
   xcb_rectangle_t rectangles[16];
   int i;

   if (numRects > (int)ARRAY_SIZE(rectangles))
      return dri2_copy_region(drv, disp, draw, dri2_surf->region);

   /* FIXME: Invert y here? */
   for (i = 0; i < numRects; i++) {
      rectangles[i].x = rects[i * 4];
      rectangles[i].y = rects[i * 4 + 1];
      rectangles[i].width = rects[i * 4 + 2];
      rectangles[i].height = rects[i * 4 + 3];
   }

   region = xcb_generate_id(dri2_dpy->conn);
   xcb_xfixes_create_region(dri2_dpy->conn, region, numRects, rectangles);
   ret = dri2_copy_region(drv, disp, draw, region);
   xcb_xfixes_destroy_region(dri2_dpy->conn, region);

   return ret;
}

a1050 2
   (void) drv;

a1061 2
   (void) drv;

a1072 3
   (void) drv;
   (void) disp;

a1094 2
   (void) drv;

d1125 2
a1126 1
   if (!_eglBindTexImage(drv, disp, surf, buffer))
d1128 10
d1147 2
a1148 1
      assert(0);
d1156 2
a1157 1
      assert(0);
d1164 1
a1164 1
   return EGL_TRUE;
a1170 5
   (void) drv;
   (void) disp;
   (void) surf;
   (void) buffer;

d1179 1
a1190 2
   (void) ctx;

d1239 1
a1239 1
   if (!_eglInitImage(&dri2_img->base, disp)) {
d1247 1
a1247 1
      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen,
d1282 1
a1282 1
   if (!_eglInitImage(&dri2_img->base, disp))
a1293 63
dri2_create_image_mesa_drm_buffer(_EGLDisplay *disp, _EGLContext *ctx,
				  EGLClientBuffer buffer, const EGLint *attr_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_image *dri2_img;
   EGLint format, name, pitch, err;
   _EGLImageAttribs attrs;

   (void) ctx;

   name = (EGLint) buffer;

   err = _eglParseImageAttribList(&attrs, disp, attr_list);
   if (err != EGL_SUCCESS)
      return NULL;

   if (attrs.Width <= 0 || attrs.Height <= 0 ||
       attrs.DRMBufferStrideMESA <= 0) {
      _eglError(EGL_BAD_PARAMETER,
		"bad width, height or stride");
      return NULL;
   }

   switch (attrs.DRMBufferFormatMESA) {
   case EGL_DRM_BUFFER_FORMAT_ARGB32_MESA:
      format = __DRI_IMAGE_FORMAT_ARGB8888;
      pitch = attrs.DRMBufferStrideMESA;
      break;
   default:
      _eglError(EGL_BAD_PARAMETER,
		"dri2_create_image_khr: unsupported pixmap depth");
      return NULL;
   }

   dri2_img = malloc(sizeof *dri2_img);
   if (!dri2_img) {
      _eglError(EGL_BAD_ALLOC, "dri2_create_image_mesa_drm");
      return NULL;
   }

   if (!_eglInitImage(&dri2_img->base, disp)) {
      free(dri2_img);
      return NULL;
   }

   dri2_img->dri_image =
      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen,
					   attrs.Width,
					   attrs.Height,
					   format,
					   name,
					   pitch,
					   dri2_img);
   if (dri2_img->dri_image == NULL) {
      free(dri2_img);
      _eglError(EGL_BAD_ALLOC, "dri2_create_image_mesa_drm");
      return NULL;
   }

   return &dri2_img->base;
}

static _EGLImage *
a1297 2
   (void) drv;

a1302 2
   case EGL_DRM_BUFFER_MESA:
      return dri2_create_image_mesa_drm_buffer(disp, ctx, buffer, attr_list);
a1314 2
   (void) drv;

a1320 108
static _EGLImage *
dri2_create_drm_image_mesa(_EGLDriver *drv, _EGLDisplay *disp,
			   const EGLint *attr_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_image *dri2_img;
   _EGLImageAttribs attrs;
   unsigned int dri_use, valid_mask;
   int format;
   EGLint err = EGL_SUCCESS;

   (void) drv;

   dri2_img = malloc(sizeof *dri2_img);
   if (!dri2_img) {
      _eglError(EGL_BAD_ALLOC, "dri2_create_image_khr");
      return EGL_NO_IMAGE_KHR;
   }

   if (!attr_list) {
      err = EGL_BAD_PARAMETER;
      goto cleanup_img;
   }

   if (!_eglInitImage(&dri2_img->base, disp)) {
      err = EGL_BAD_PARAMETER;
      goto cleanup_img;
   }

   err = _eglParseImageAttribList(&attrs, disp, attr_list);
   if (err != EGL_SUCCESS)
      goto cleanup_img;

   if (attrs.Width <= 0 || attrs.Height <= 0) {
      _eglLog(_EGL_WARNING, "bad width or height (%dx%d)",
            attrs.Width, attrs.Height);
      goto cleanup_img;
   }

   switch (attrs.DRMBufferFormatMESA) {
   case EGL_DRM_BUFFER_FORMAT_ARGB32_MESA:
      format = __DRI_IMAGE_FORMAT_ARGB8888;
      break;
   default:
      _eglLog(_EGL_WARNING, "bad image format value 0x%04x",
            attrs.DRMBufferFormatMESA);
      goto cleanup_img;
   }

   valid_mask =
      EGL_DRM_BUFFER_USE_SCANOUT_MESA |
      EGL_DRM_BUFFER_USE_SHARE_MESA; 
   if (attrs.DRMBufferUseMESA & ~valid_mask) {
      _eglLog(_EGL_WARNING, "bad image use bit 0x%04x",
            attrs.DRMBufferUseMESA & ~valid_mask);
      goto cleanup_img;
   }

   dri_use = 0;
   if (attrs.DRMBufferUseMESA & EGL_DRM_BUFFER_USE_SHARE_MESA)
      dri_use |= __DRI_IMAGE_USE_SHARE;
   if (attrs.DRMBufferUseMESA & EGL_DRM_BUFFER_USE_SCANOUT_MESA)
      dri_use |= __DRI_IMAGE_USE_SCANOUT;

   dri2_img->dri_image = 
      dri2_dpy->image->createImage(dri2_dpy->dri_screen,
				   attrs.Width, attrs.Height,
                                   format, dri_use, dri2_img);
   if (dri2_img->dri_image == NULL) {
      err = EGL_BAD_ALLOC;
      goto cleanup_img;
   }

   return &dri2_img->base;

 cleanup_img:
   free(dri2_img);
   _eglError(err, "dri2_create_drm_image_mesa");

   return EGL_NO_IMAGE_KHR;
}

static EGLBoolean
dri2_export_drm_image_mesa(_EGLDriver *drv, _EGLDisplay *disp, _EGLImage *img,
			  EGLint *name, EGLint *handle, EGLint *stride)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_image *dri2_img = dri2_egl_image(img);

   (void) drv;

   if (name && !dri2_dpy->image->queryImage(dri2_img->dri_image,
					    __DRI_IMAGE_ATTRIB_NAME, name)) {
      _eglError(EGL_BAD_ALLOC, "dri2_export_drm_image_mesa");
      return EGL_FALSE;
   }

   if (handle)
      dri2_dpy->image->queryImage(dri2_img->dri_image,
				  __DRI_IMAGE_ATTRIB_HANDLE, handle);

   if (stride)
      dri2_dpy->image->queryImage(dri2_img->dri_image,
				  __DRI_IMAGE_ATTRIB_STRIDE, stride);

   return EGL_TRUE;
}

a1329 2
   (void) args;

a1352 3
   dri2_drv->base.API.SwapBuffersRegionNOK = dri2_swap_buffers_region;
   dri2_drv->base.API.CreateDRMImageMESA = dri2_create_drm_image_mesa;
   dri2_drv->base.API.ExportDRMImageMESA = dri2_export_drm_image_mesa;
a1355 3

   dri2_drv->glFlush =
      (void (*)(void)) dri2_get_proc_address(&dri2_drv->base, "glFlush");
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d39 4
d46 50
a95 1
#include "egl_dri2.h"
d97 29
a125 1
const __DRIuseInvalidateExtension use_invalidate = {
d159 1
a159 1
   0,				/* __DRI_ATTRIB_FLOAT_MODE (deprecated) */
a177 1
   0,				/* __DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE */
d180 1
a180 13
static EGLBoolean
dri2_match_config(const _EGLConfig *conf, const _EGLConfig *criteria)
{
   if (_eglCompareConfigs(conf, criteria, NULL, EGL_FALSE) != 0)
      return EGL_FALSE;

   if (!_eglMatchConfig(conf, criteria))
      return EGL_FALSE;

   return EGL_TRUE;
}

struct dri2_egl_config *
d182 1
a182 2
		int depth, EGLint surface_type, const EGLint *attr_list,
		const unsigned int *rgba_masks)
a188 4
   unsigned int dri_masks[4] = { 0, 0, 0, 0 };
   _EGLConfig *matching_config;
   EGLint num_configs = 0;
   EGLint config_id;
d207 1
a207 1
	    return NULL;
a232 16
      case __DRI_ATTRIB_RED_MASK:
         dri_masks[0] = value;
         break;

      case __DRI_ATTRIB_GREEN_MASK:
         dri_masks[1] = value;
         break;

      case __DRI_ATTRIB_BLUE_MASK:
         dri_masks[2] = value;
         break;

      case __DRI_ATTRIB_ALPHA_MASK:
         dri_masks[3] = value;
         break;

d241 8
a248 12
   if (attr_list)
      for (i = 0; attr_list[i] != EGL_NONE; i += 2)
         _eglSetConfigKey(&base, attr_list[i], attr_list[i+1]);

   /* Allow a 24-bit RGB visual to match a 32-bit RGBA EGLConfig.  Otherwise
    * it will only match a 32-bit RGBA visual.  On a composited window manager
    * on X11, this will make all of the EGLConfigs with destination alpha get
    * blended by the compositor.  This is probably not what the application
    * wants... especially on drivers that only have 32-bit RGBA EGLConfigs!
    */
   if (depth > 0 && depth != base.BufferSize
       && !(depth == 24 && base.BufferSize == 32))
d251 1
a251 1
   if (rgba_masks && memcmp(rgba_masks, dri_masks, sizeof(dri_masks)))
d257 1
a257 2
   if (surface_type & (EGL_PBUFFER_BIT |
       (disp->Extensions.NOK_texture_from_pixmap ? EGL_PIXMAP_BIT : 0))) {
d263 2
a264 5
   base.RenderableType = disp->ClientAPIs;
   base.Conformant = disp->ClientAPIs;

   base.MinSwapInterval = dri2_dpy->min_swap_interval;
   base.MaxSwapInterval = dri2_dpy->max_swap_interval;
d271 2
a272 22
   config_id = base.ConfigID;
   base.ConfigID    = EGL_DONT_CARE;
   base.SurfaceType = EGL_DONT_CARE;
   num_configs = _eglFilterArray(disp->Configs, (void **) &matching_config, 1,
                                 (_EGLArrayForEach) dri2_match_config, &base);

   if (num_configs == 1) {
      conf = (struct dri2_egl_config *) matching_config;

      if (double_buffer && !conf->dri_double_config)
         conf->dri_double_config = dri_config;
      else if (!double_buffer && !conf->dri_single_config)
         conf->dri_single_config = dri_config;
      else
         /* a similar config type is already added (unlikely) => discard */
         return NULL;
   }
   else if (num_configs == 0) {
      conf = malloc(sizeof *conf);
      if (conf == NULL)
         return NULL;

d274 1
a274 10
      if (double_buffer) {
         conf->dri_double_config = dri_config;
         conf->dri_single_config = NULL;
      } else {
         conf->dri_single_config = dri_config;
         conf->dri_double_config = NULL;
      }
      conf->base.SurfaceType = 0;
      conf->base.ConfigID = config_id;

d277 72
a348 2
   else {
      assert(0);
a349 1
   }
d351 16
a366 3
   if (double_buffer) {
      surface_type &= ~EGL_PIXMAP_BIT;
   }
d368 2
a369 1
   conf->base.SurfaceType |= surface_type;
d371 4
a374 1
   return conf;
d377 1
a377 1
__DRIimage *
d397 1
a397 1
const __DRIimageLookupExtension image_lookup_extension = {
d402 38
d450 1
a450 1
   { __DRI_DRI2, 2, offsetof(struct dri2_egl_display, dri2) },
a460 11
static struct dri2_extension_match swrast_driver_extensions[] = {
   { __DRI_CORE, 1, offsetof(struct dri2_egl_display, core) },
   { __DRI_SWRAST, 2, offsetof(struct dri2_egl_display, swrast) },
   { NULL, 0, 0 }
};

static struct dri2_extension_match swrast_core_extensions[] = {
   { __DRI_TEX_BUFFER, 2, offsetof(struct dri2_egl_display, tex_buffer) },
   { NULL, 0, 0 }
};

d494 175
a668 2
static const __DRIextension **
dri2_open_driver(_EGLDisplay *disp)
d707 3
a709 3
	      "DRI2: failed to open %s (search paths %s)",
	      dri2_dpy->driver_name, search_paths);
      return NULL;
d718 1
a720 13
   return extensions;
}

EGLBoolean
dri2_load_driver(_EGLDisplay *disp)
{
   struct dri2_egl_display *dri2_dpy = disp->DriverData;
   const __DRIextension **extensions;

   extensions = dri2_open_driver(disp);
   if (!extensions)
      return EGL_FALSE;

d729 2
a730 2
EGLBoolean
dri2_load_driver_swrast(_EGLDisplay *disp)
a731 1
   struct dri2_egl_display *dri2_dpy = disp->DriverData;
d733 2
d736 4
a739 2
   dri2_dpy->driver_name = "swrast";
   extensions = dri2_open_driver(disp);
d741 2
a742 5
   if (!extensions)
      return EGL_FALSE;

   if (!dri2_bind_extensions(dri2_dpy, swrast_driver_extensions, extensions)) {
      dlclose(dri2_dpy->driver);
d746 3
a748 8
   return EGL_TRUE;
}

void
dri2_setup_screen(_EGLDisplay *disp)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   unsigned int api_mask;
d750 1
a750 1
   if (dri2_dpy->dri2) {
d752 2
a753 7
   } else {
      assert(dri2_dpy->swrast);
      api_mask = 1 << __DRI_API_OPENGL |
                 1 << __DRI_API_GLES |
                 1 << __DRI_API_GLES2 |
                 1 << __DRI_API_GLES3;
   }
d755 1
a755 1
   disp->ClientAPIs = 0;
d757 1
a757 1
      disp->ClientAPIs |= EGL_OPENGL_BIT;
d759 1
a759 1
      disp->ClientAPIs |= EGL_OPENGL_ES_BIT;
d761 6
a766 23
      disp->ClientAPIs |= EGL_OPENGL_ES2_BIT;
   if (api_mask & (1 << __DRI_API_GLES3))
      disp->ClientAPIs |= EGL_OPENGL_ES3_BIT_KHR;

   assert(dri2_dpy->dri2 || dri2_dpy->swrast);
   disp->Extensions.KHR_surfaceless_context = EGL_TRUE;

   if (dri2_dpy->dri2 && dri2_dpy->dri2->base.version >= 3) {
      disp->Extensions.KHR_create_context = EGL_TRUE;

      if (dri2_dpy->robustness)
         disp->Extensions.EXT_create_context_robustness = EGL_TRUE;
   }

   if (dri2_dpy->image) {
      disp->Extensions.MESA_drm_image = EGL_TRUE;
      disp->Extensions.KHR_image_base = EGL_TRUE;
      disp->Extensions.KHR_gl_renderbuffer_image = EGL_TRUE;
      if (dri2_dpy->image->base.version >= 5 &&
          dri2_dpy->image->createImageFromTexture) {
         disp->Extensions.KHR_gl_texture_2D_image = EGL_TRUE;
         disp->Extensions.KHR_gl_texture_cubemap_image = EGL_TRUE;
      }
d768 7
d777 3
a779 2
EGLBoolean
dri2_create_screen(_EGLDisplay *disp)
a780 1
   const __DRIextension **extensions;
d783 5
a787 1
   dri2_dpy = disp->DriverData;
d789 3
a791 4
   if (dri2_dpy->dri2) {
      dri2_dpy->dri_screen =
         dri2_dpy->dri2->createNewScreen(0, dri2_dpy->fd, dri2_dpy->extensions,
				         &dri2_dpy->driver_configs, disp);
d793 6
a798 4
      assert(dri2_dpy->swrast);
      dri2_dpy->dri_screen =
         dri2_dpy->swrast->createNewScreen(0, dri2_dpy->extensions,
                                           &dri2_dpy->driver_configs, disp);
d801 3
a803 3
   if (dri2_dpy->dri_screen == NULL) {
      _eglLog(_EGL_WARNING, "DRI2: failed to create dri screen");
      return EGL_FALSE;
d806 556
a1361 1
   dri2_dpy->own_dri_screen = 1;
d1363 15
a1377 4
   extensions = dri2_dpy->core->getExtensions(dri2_dpy->dri_screen);
   
   if (dri2_dpy->dri2) {
      unsigned i;
d1379 6
a1384 2
      if (!dri2_bind_extensions(dri2_dpy, dri2_core_extensions, extensions))
         goto cleanup_dri_screen;
d1386 21
a1406 6
      for (i = 0; extensions[i]; i++) {
	 if (strcmp(extensions[i]->name, __DRI2_ROBUSTNESS) == 0) {
            dri2_dpy->robustness = (__DRIrobustnessExtension *) extensions[i];
	 }
	 if (strcmp(extensions[i]->name, __DRI2_CONFIG_QUERY) == 0) {
	    dri2_dpy->config = (__DRI2configQueryExtension *) extensions[i];
a1407 5
      }
   } else {
      assert(dri2_dpy->swrast);
      if (!dri2_bind_extensions(dri2_dpy, swrast_core_extensions, extensions))
         goto cleanup_dri_screen;
d1410 46
a1455 1
   dri2_setup_screen(disp);
d1459 4
a1462 2
 cleanup_dri_screen:
   dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);
d1467 2
d1473 2
a1474 1
dri2_initialize(_EGLDriver *drv, _EGLDisplay *disp)
a1475 4
   /* not until swrast_dri is supported */
   if (disp->Options.UseFallback)
      return EGL_FALSE;

a1476 1
#ifdef HAVE_X11_PLATFORM
d1478 1
a1478 4
      if (disp->Options.TestOnly)
         return EGL_TRUE;
      return dri2_initialize_x11(drv, disp);
#endif
a1480 1
#ifdef HAVE_DRM_PLATFORM
d1482 1
a1482 16
      if (disp->Options.TestOnly)
         return EGL_TRUE;
      return dri2_initialize_drm(drv, disp);
#endif
#ifdef HAVE_WAYLAND_PLATFORM
   case _EGL_PLATFORM_WAYLAND:
      if (disp->Options.TestOnly)
         return EGL_TRUE;
      return dri2_initialize_wayland(drv, disp);
#endif
#endif
#ifdef HAVE_ANDROID_PLATFORM
   case _EGL_PLATFORM_ANDROID:
      if (disp->Options.TestOnly)
         return EGL_TRUE;
      return dri2_initialize_android(drv, disp);
d1501 7
a1507 29
   if (dri2_dpy->own_dri_screen)
      dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);
   if (dri2_dpy->fd)
      close(dri2_dpy->fd);
   if (dri2_dpy->driver)
      dlclose(dri2_dpy->driver);
   free(dri2_dpy->device_name);

   if (disp->PlatformDisplay == NULL) {
      switch (disp->Platform) {
#ifdef HAVE_X11_PLATFORM
      case _EGL_PLATFORM_X11:
         xcb_disconnect(dri2_dpy->conn);
         break;
#endif
#ifdef HAVE_DRM_PLATFORM
      case _EGL_PLATFORM_DRM:
         if (dri2_dpy->own_device) {
            gbm_device_destroy(&dri2_dpy->gbm_dri->base.base);
         }
         break;
#endif
      default:
         break;
      }
   }

   free(dri2_dpy);
   disp->DriverData = NULL;
a1511 63
/**
 * Set the error code after a call to
 * dri2_egl_display::dri2::createContextAttribs.
 */
static void
dri2_create_context_attribs_error(int dri_error)
{
   EGLint egl_error;

   switch (dri_error) {
   case __DRI_CTX_ERROR_SUCCESS:
      return;

   case __DRI_CTX_ERROR_NO_MEMORY:
      egl_error = EGL_BAD_ALLOC;
      break;

  /* From the EGL_KHR_create_context spec, section "Errors":
   *
   *   * If <config> does not support a client API context compatible
   *     with the requested API major and minor version, [...] context flags,
   *     and context reset notification behavior (for client API types where
   *     these attributes are supported), then an EGL_BAD_MATCH error is
   *     generated.
   *
   *   * If an OpenGL ES context is requested and the values for
   *     attributes EGL_CONTEXT_MAJOR_VERSION_KHR and
   *     EGL_CONTEXT_MINOR_VERSION_KHR specify an OpenGL ES version that
   *     is not defined, than an EGL_BAD_MATCH error is generated.
   *
   *   * If an OpenGL context is requested, the requested version is
   *     greater than 3.2, and the value for attribute
   *     EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR has no bits set; has any
   *     bits set other than EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR and
   *     EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR; has more than
   *     one of these bits set; or if the implementation does not support
   *     the requested profile, then an EGL_BAD_MATCH error is generated.
   */
   case __DRI_CTX_ERROR_BAD_API:
   case __DRI_CTX_ERROR_BAD_VERSION:
   case __DRI_CTX_ERROR_BAD_FLAG:
      egl_error = EGL_BAD_MATCH;
      break;

  /* From the EGL_KHR_create_context spec, section "Errors":
   *
   *   * If an attribute name or attribute value in <attrib_list> is not
   *     recognized (including unrecognized bits in bitmask attributes),
   *     then an EGL_BAD_ATTRIBUTE error is generated."
   */
   case __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE:
   case __DRI_CTX_ERROR_UNKNOWN_FLAG:
      egl_error = EGL_BAD_ATTRIBUTE;
      break;

   default:
      assert(0);
      egl_error = EGL_BAD_MATCH;
      break;
   }

   _eglError(egl_error, "dri2_create_context");
}
a1522 2
   __DRIcontext *shared =
      dri2_ctx_shared ? dri2_ctx_shared->dri_context : NULL;
d1540 1
a1540 1
      switch (dri2_ctx->base.ClientMajorVersion) {
a1546 3
      case 3:
         api = __DRI_API_GLES3;
         break;
d1553 1
a1553 7
      if ((dri2_ctx->base.ClientMajorVersion >= 4
           || (dri2_ctx->base.ClientMajorVersion == 3
               && dri2_ctx->base.ClientMinorVersion >= 2))
          && dri2_ctx->base.Profile == EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR)
         api = __DRI_API_OPENGL_CORE;
      else
         api = __DRI_API_OPENGL;
a1556 1
      free(dri2_ctx);
d1560 2
a1561 19
   if (conf != NULL) {
      /* The config chosen here isn't necessarily
       * used for surfaces later.
       * A pixmap surface will use the single config.
       * This opportunity depends on disabling the
       * doubleBufferMode check in
       * src/mesa/main/context.c:check_compatible()
       */
      if (dri2_config->dri_double_config)
         dri_config = dri2_config->dri_double_config;
      else
         dri_config = dri2_config->dri_single_config;

      /* EGL_WINDOW_BIT is set only when there is a dri_double_config.  This
       * makes sure the back buffer will always be used.
       */
      if (conf->SurfaceType & EGL_WINDOW_BIT)
         dri2_ctx->base.WindowRenderBuffer = EGL_BACK_BUFFER;
   }
d1565 15
a1579 60
   if (dri2_dpy->dri2) {
      if (dri2_dpy->dri2->base.version >= 3) {
         unsigned error;
         unsigned num_attribs = 0;
         uint32_t ctx_attribs[8];

         ctx_attribs[num_attribs++] = __DRI_CTX_ATTRIB_MAJOR_VERSION;
         ctx_attribs[num_attribs++] = dri2_ctx->base.ClientMajorVersion;
         ctx_attribs[num_attribs++] = __DRI_CTX_ATTRIB_MINOR_VERSION;
         ctx_attribs[num_attribs++] = dri2_ctx->base.ClientMinorVersion;

         if (dri2_ctx->base.Flags != 0) {
            /* If the implementation doesn't support the __DRI2_ROBUSTNESS
             * extension, don't even try to send it the robust-access flag.
             * It may explode.  Instead, generate the required EGL error here.
             */
            if ((dri2_ctx->base.Flags & EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR) != 0
                && !dri2_dpy->robustness) {
               _eglError(EGL_BAD_MATCH, "eglCreateContext");
               goto cleanup;
            }

            ctx_attribs[num_attribs++] = __DRI_CTX_ATTRIB_FLAGS;
            ctx_attribs[num_attribs++] = dri2_ctx->base.Flags;
         }

         if (dri2_ctx->base.ResetNotificationStrategy != EGL_NO_RESET_NOTIFICATION_KHR) {
            /* If the implementation doesn't support the __DRI2_ROBUSTNESS
             * extension, don't even try to send it a reset strategy.  It may
             * explode.  Instead, generate the required EGL error here.
             */
            if (!dri2_dpy->robustness) {
               _eglError(EGL_BAD_CONFIG, "eglCreateContext");
               goto cleanup;
            }

            ctx_attribs[num_attribs++] = __DRI_CTX_ATTRIB_RESET_STRATEGY;
            ctx_attribs[num_attribs++] = __DRI_CTX_RESET_LOSE_CONTEXT;
         }

         assert(num_attribs <= ARRAY_SIZE(ctx_attribs));

	 dri2_ctx->dri_context =
	    dri2_dpy->dri2->createContextAttribs(dri2_dpy->dri_screen,
                                                 api,
                                                 dri_config,
                                                 shared,
                                                 num_attribs / 2,
                                                 ctx_attribs,
                                                 & error,
                                                 dri2_ctx);
	 dri2_create_context_attribs_error(error);
      } else {
	 dri2_ctx->dri_context =
	    dri2_dpy->dri2->createNewContextForAPI(dri2_dpy->dri_screen,
						   api,
						   dri_config,
                                                   shared,
						   dri2_ctx);
      }
d1581 1
a1581 7
      assert(dri2_dpy->swrast);
      dri2_ctx->dri_context =
         dri2_dpy->swrast->createNewContextForAPI(dri2_dpy->dri_screen,
                                                  api,
                                                  dri_config,
                                                  shared,
                                                  dri2_ctx);
a1593 3
/**
 * Called via eglDestroyContext(), drv->API.DestroyContext().
 */
d1595 1
a1595 1
dri2_destroy_context(_EGLDriver *drv, _EGLDisplay *disp, _EGLContext *ctx)
a1596 1
   struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
d1598 10
d1609 4
a1612 4
   if (_eglPutContext(ctx)) {
      dri2_dpy->core->destroyContext(dri2_ctx->dri_context);
      free(dri2_ctx);
   }
a1645 5
   if (old_ctx) {
      __DRIcontext *old_cctx = dri2_egl_context(old_ctx)->dri_context;
      dri2_dpy->core->unbindContext(old_cctx);
   }

d1648 11
a1658 6
      if (old_dsurf)
         drv->API.DestroySurface(drv, disp, old_dsurf);
      if (old_rsurf)
         drv->API.DestroySurface(drv, disp, old_rsurf);
      if (old_ctx)
         drv->API.DestroyContext(drv, disp, old_ctx);
d1680 184
d1870 3
a1872 1
   struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);
d1874 1
a1874 1
   return dri2_drv->get_proc_address(procname);
d1888 1
a1888 2
   if (dri2_dpy->flush != NULL)
      dri2_dpy->flush->flush(dri2_surf->dri_drawable);
d1906 34
d1986 4
a1989 25
#if __DRI_TEX_BUFFER_VERSION >= 3
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surf);
   struct dri2_egl_context *dri2_ctx;
   _EGLContext *ctx;
   GLint  target;

   ctx = _eglGetCurrentContext();
   dri2_ctx = dri2_egl_context(ctx);

   if (!_eglReleaseTexImage(drv, disp, surf, buffer))
      return EGL_FALSE;

   switch (dri2_surf->base.TextureTarget) {
   case EGL_TEXTURE_2D:
      target = GL_TEXTURE_2D;
      break;
   default:
      assert(0);
   }
   if (dri2_dpy->tex_buffer->releaseTexBuffer!=NULL)
    (*dri2_dpy->tex_buffer->releaseTexBuffer)(dri2_ctx->dri_context,
                                             target,
                                             dri2_surf->dri_drawable);
#endif
d1995 2
a1996 1
dri2_create_image(_EGLDisplay *disp, __DRIimage *dri_image)
d1998 1
d2000 33
d2034 15
a2048 2
   if (dri_image == NULL) {
      _eglError(EGL_BAD_ALLOC, "dri2_create_image");
d2054 4
a2057 2
      _eglError(EGL_BAD_ALLOC, "dri2_create_image");
      return NULL;
d2061 3
a2063 2
      free(dri2_img);
      return NULL;
d2066 12
a2077 1
   dri2_img->dri_image = dri_image;
d2089 2
a2090 2
   GLuint renderbuffer = (GLuint) (uintptr_t) buffer;
   __DRIimage *dri_image;
d2097 10
a2106 1
   dri_image =
d2108 2
a2109 1
                                                   renderbuffer, NULL);
d2111 1
a2111 1
   return dri2_create_image(disp, dri_image);
d2119 1
a2121 1
   __DRIimage *dri_image;
d2123 3
a2125 1
   name = (EGLint) (uintptr_t) buffer;
a2148 153
   dri_image =
      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen,
					   attrs.Width,
					   attrs.Height,
					   format,
					   name,
					   pitch,
					   NULL);

   return dri2_create_image(disp, dri_image);
}

#ifdef HAVE_WAYLAND_PLATFORM

/* This structure describes how a wl_buffer maps to one or more
 * __DRIimages.  A wl_drm_buffer stores the wl_drm format code and the
 * offsets and strides of the planes in the buffer.  This table maps a
 * wl_drm format code to a description of the planes in the buffer
 * that lets us create a __DRIimage for each of the planes. */

static const struct wl_drm_components_descriptor {
   uint32_t dri_components;
   EGLint components;
   int nplanes;
} wl_drm_components[] = {
   { __DRI_IMAGE_COMPONENTS_RGB, EGL_TEXTURE_RGB, 1 },
   { __DRI_IMAGE_COMPONENTS_RGBA, EGL_TEXTURE_RGBA, 1 },
   { __DRI_IMAGE_COMPONENTS_Y_U_V, EGL_TEXTURE_Y_U_V_WL, 3 },
   { __DRI_IMAGE_COMPONENTS_Y_UV, EGL_TEXTURE_Y_UV_WL, 2 },
   { __DRI_IMAGE_COMPONENTS_Y_XUXV, EGL_TEXTURE_Y_XUXV_WL, 2 },
};

static _EGLImage *
dri2_create_image_wayland_wl_buffer(_EGLDisplay *disp, _EGLContext *ctx,
				    EGLClientBuffer _buffer,
				    const EGLint *attr_list)
{
   struct wl_drm_buffer *buffer = (struct wl_drm_buffer *) _buffer;
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   const struct wl_drm_components_descriptor *f;
   __DRIimage *dri_image;
   _EGLImageAttribs attrs;
   EGLint err;
   int32_t plane;

   if (!wayland_buffer_is_drm(&buffer->buffer))
       return NULL;

   err = _eglParseImageAttribList(&attrs, disp, attr_list);
   plane = attrs.PlaneWL;
   if (err != EGL_SUCCESS) {
      _eglError(EGL_BAD_PARAMETER, "dri2_create_image_wayland_wl_buffer");
      return NULL;
   }

   f = buffer->driver_format;
   if (plane < 0 || plane >= f->nplanes) {
      _eglError(EGL_BAD_PARAMETER,
                "dri2_create_image_wayland_wl_buffer (plane out of bounds)");
      return NULL;
   }

   dri_image = dri2_dpy->image->fromPlanar(buffer->driver_buffer, plane, NULL);

   if (dri_image == NULL) {
      _eglError(EGL_BAD_PARAMETER, "dri2_create_image_wayland_wl_buffer");
      return NULL;
   }

   return dri2_create_image(disp, dri_image);
}
#endif

/**
 * Set the error code after a call to
 * dri2_egl_image::dri_image::createImageFromTexture.
 */
static void
dri2_create_image_khr_texture_error(int dri_error)
{
   EGLint egl_error;

   switch (dri_error) {
   case __DRI_IMAGE_ERROR_SUCCESS:
      return;

   case __DRI_IMAGE_ERROR_BAD_ALLOC:
      egl_error = EGL_BAD_ALLOC;
      break;

   case __DRI_IMAGE_ERROR_BAD_MATCH:
      egl_error = EGL_BAD_MATCH;
      break;

   case __DRI_IMAGE_ERROR_BAD_PARAMETER:
      egl_error = EGL_BAD_PARAMETER;
      break;

   default:
      assert(0);
      egl_error = EGL_BAD_MATCH;
      break;
   }

   _eglError(egl_error, "dri2_create_image_khr_texture");
}

static _EGLImage *
dri2_create_image_khr_texture(_EGLDisplay *disp, _EGLContext *ctx,
				   EGLenum target,
				   EGLClientBuffer buffer,
				   const EGLint *attr_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
   struct dri2_egl_image *dri2_img;
   GLuint texture = (GLuint) (uintptr_t) buffer;
   _EGLImageAttribs attrs;
   GLuint depth;
   GLenum gl_target;
   unsigned error;

   if (texture == 0) {
      _eglError(EGL_BAD_PARAMETER, "dri2_create_image_khr");
      return EGL_NO_IMAGE_KHR;
   }

   if (_eglParseImageAttribList(&attrs, disp, attr_list) != EGL_SUCCESS)
      return EGL_NO_IMAGE_KHR;

   switch (target) {
   case EGL_GL_TEXTURE_2D_KHR:
      depth = 0;
      gl_target = GL_TEXTURE_2D;
      break;
   case EGL_GL_TEXTURE_3D_KHR:
      depth = attrs.GLTextureZOffset;
      gl_target = GL_TEXTURE_3D;
      break;
   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR:
      depth = target - EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR;
      gl_target = GL_TEXTURE_CUBE_MAP;
      break;
   default:
      _eglError(EGL_BAD_PARAMETER, "dri2_create_image_khr");
      return EGL_NO_IMAGE_KHR;
   }

d2151 2
a2152 2
      _eglError(EGL_BAD_ALLOC, "dri2_create_image_khr");
      return EGL_NO_IMAGE_KHR;
a2155 1
      _eglError(EGL_BAD_ALLOC, "dri2_create_image_khr");
d2157 1
a2157 1
      return EGL_NO_IMAGE_KHR;
d2161 8
a2168 10
      dri2_dpy->image->createImageFromTexture(dri2_ctx->dri_context,
                                              gl_target,
                                              texture,
                                              depth,
                                              attrs.GLTextureLevel,
                                              &error,
                                              dri2_img);
   dri2_create_image_khr_texture_error(error);

   if (!dri2_img->dri_image) {
d2170 2
a2171 1
      return EGL_NO_IMAGE_KHR;
d2173 1
d2177 1
a2177 1
_EGLImage *
d2185 2
a2186 8
   case EGL_GL_TEXTURE_2D_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_KHR:
   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR:
      return dri2_create_image_khr_texture(disp, ctx, target, buffer, attr_list);
a2190 4
#ifdef HAVE_WAYLAND_PLATFORM
   case EGL_WAYLAND_BUFFER_WL:
      return dri2_create_image_wayland_wl_buffer(disp, ctx, buffer, attr_list);
#endif
d2262 1
a2262 2
      EGL_DRM_BUFFER_USE_SHARE_MESA |
      EGL_DRM_BUFFER_USE_CURSOR_MESA;
a2273 2
   if (attrs.DRMBufferUseMESA & EGL_DRM_BUFFER_USE_CURSOR_MESA)
      dri_use |= __DRI_IMAGE_USE_CURSOR;
a2318 193
#ifdef HAVE_WAYLAND_PLATFORM

static void
dri2_wl_reference_buffer(void *user_data, uint32_t name, int fd,
                         struct wl_drm_buffer *buffer)
{
   _EGLDisplay *disp = user_data;
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   __DRIimage *img;
   int i, dri_components = 0;

   if (fd == -1)
      img = dri2_dpy->image->createImageFromNames(dri2_dpy->dri_screen,
                                                  buffer->buffer.width,
                                                  buffer->buffer.height,
                                                  buffer->format,
                                                  (int*)&name, 1,
                                                  buffer->stride,
                                                  buffer->offset,
                                                  NULL);
   else
      img = dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen,
                                                buffer->buffer.width,
                                                buffer->buffer.height,
                                                buffer->format,
                                                &fd, 1,
                                                buffer->stride,
                                                buffer->offset,
                                                NULL);

   if (img == NULL)
      return;

   dri2_dpy->image->queryImage(img, __DRI_IMAGE_ATTRIB_COMPONENTS, &dri_components);

   buffer->driver_format = NULL;
   for (i = 0; i < ARRAY_SIZE(wl_drm_components); i++)
      if (wl_drm_components[i].dri_components == dri_components)
         buffer->driver_format = &wl_drm_components[i];

   if (buffer->driver_format == NULL)
      dri2_dpy->image->destroyImage(img);
   else
      buffer->driver_buffer = img;
}

static void
dri2_wl_release_buffer(void *user_data, struct wl_drm_buffer *buffer)
{
   _EGLDisplay *disp = user_data;
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);

   dri2_dpy->image->destroyImage(buffer->driver_buffer);
}

static struct wayland_drm_callbacks wl_drm_callbacks = {
	.authenticate = NULL,
	.reference_buffer = dri2_wl_reference_buffer,
	.release_buffer = dri2_wl_release_buffer
};

static EGLBoolean
dri2_bind_wayland_display_wl(_EGLDriver *drv, _EGLDisplay *disp,
			     struct wl_display *wl_dpy)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   int ret, flags = 0;
   uint64_t cap;

   (void) drv;

   if (dri2_dpy->wl_server_drm)
	   return EGL_FALSE;

   wl_drm_callbacks.authenticate =
      (int(*)(void *, uint32_t)) dri2_dpy->authenticate;

   ret = drmGetCap(dri2_dpy->fd, DRM_CAP_PRIME, &cap);
   if (ret == 0 && cap == (DRM_PRIME_CAP_IMPORT | DRM_PRIME_CAP_EXPORT) &&
       dri2_dpy->image->base.version >= 7 &&
       dri2_dpy->image->createImageFromFds != NULL)
      flags |= WAYLAND_DRM_PRIME;

   dri2_dpy->wl_server_drm =
	   wayland_drm_init(wl_dpy, dri2_dpy->device_name,
                            &wl_drm_callbacks, disp, flags);

   if (!dri2_dpy->wl_server_drm)
	   return EGL_FALSE;

   return EGL_TRUE;
}

static EGLBoolean
dri2_unbind_wayland_display_wl(_EGLDriver *drv, _EGLDisplay *disp,
			       struct wl_display *wl_dpy)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);

   (void) drv;

   if (!dri2_dpy->wl_server_drm)
	   return EGL_FALSE;

   wayland_drm_uninit(dri2_dpy->wl_server_drm);
   dri2_dpy->wl_server_drm = NULL;

   return EGL_TRUE;
}

static EGLBoolean
dri2_query_wayland_buffer_wl(_EGLDriver *drv, _EGLDisplay *disp,
                             struct wl_buffer *_buffer,
                             EGLint attribute, EGLint *value)
{
   struct wl_drm_buffer *buffer = (struct wl_drm_buffer *) _buffer;
   const struct wl_drm_components_descriptor *format;

   if (!wayland_buffer_is_drm(&buffer->buffer))
      return EGL_FALSE;

   format = buffer->driver_format;
   switch (attribute) {
   case EGL_TEXTURE_FORMAT:
      *value = format->components;
      return EGL_TRUE;
   case EGL_WIDTH:
      *value = buffer->buffer.width;
      return EGL_TRUE;
   case EGL_HEIGHT:
      *value = buffer->buffer.height;
      return EGL_TRUE;
   }

   return EGL_FALSE;
}
#endif

static void
dri2_unload(_EGLDriver *drv)
{
   struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);

   if (dri2_drv->handle)
      dlclose(dri2_drv->handle);
   free(dri2_drv);
}

static EGLBoolean
dri2_load(_EGLDriver *drv)
{
   struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);
#ifdef HAVE_SHARED_GLAPI
#ifdef HAVE_ANDROID_PLATFORM
   const char *libname = "libglapi.so";
#else
   const char *libname = "libglapi.so.0";
#endif
#else
   /*
    * Both libGL.so and libglapi.so are glapi providers.  There is no way to
    * tell which one to load.
    */
   const char *libname = NULL;
#endif
   void *handle;

   /* RTLD_GLOBAL to make sure glapi symbols are visible to DRI drivers */
   handle = dlopen(libname, RTLD_LAZY | RTLD_GLOBAL);
   if (handle) {
      dri2_drv->get_proc_address = (_EGLProc (*)(const char *))
         dlsym(handle, "_glapi_get_proc_address");
      if (!dri2_drv->get_proc_address || !libname) {
         /* no need to keep a reference */
         dlclose(handle);
         handle = NULL;
      }
   }

   /* if glapi is not available, loading DRI drivers will fail */
   if (!dri2_drv->get_proc_address) {
      _eglLog(_EGL_WARNING, "DRI2: failed to find _glapi_get_proc_address");
      return EGL_FALSE;
   }

   dri2_drv->glFlush = (void (*)(void))
      dri2_drv->get_proc_address("glFlush");

   dri2_drv->handle = handle;

   return EGL_TRUE;
}

d2324 1
a2324 1
_eglBuiltInDriverDRI2(const char *args)
d2330 1
a2330 1
   dri2_drv = calloc(1, sizeof *dri2_drv);
d2334 1
a2334 5
   if (!dri2_load(&dri2_drv->base)) {
      free(dri2_drv);
      return NULL;
   }

a2338 1
   dri2_drv->base.API.DestroyContext = dri2_destroy_context;
d2340 5
d2348 1
d2353 1
a2355 5
#ifdef HAVE_WAYLAND_PLATFORM
   dri2_drv->base.API.BindWaylandDisplayWL = dri2_bind_wayland_display_wl;
   dri2_drv->base.API.UnbindWaylandDisplayWL = dri2_unbind_wayland_display_wl;
   dri2_drv->base.API.QueryWaylandBufferWL = dri2_query_wayland_buffer_wl;
#endif
d2359 3
@


1.1.1.3
log
@Import Mesa 9.2.3
@
text
@d1206 1
a1206 1
   if (!wayland_buffer_is_drm(dri2_dpy->wl_server_drm, &buffer->buffer))
a1587 5
#ifdef HAVE_DRM_PLATFORM
   if (dri2_dpy->gbm_dri)
      dri2_dpy->gbm_dri->wl_drm = dri2_dpy->wl_server_drm;
#endif

a1613 1
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
d1616 1
a1616 1
   if (!wayland_buffer_is_drm(dri2_dpy->wl_server_drm, &buffer->buffer))
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@a27 2
#define WL_HIDE_DEPRECATED

a35 1
#ifdef HAVE_DRM_PLATFORM
a36 2
#include <drm_fourcc.h>
#endif
a41 5
#ifdef HAVE_WAYLAND_PLATFORM
#include "wayland-drm.h"
#include "wayland-drm-client-protocol.h"
#endif

d45 1
a45 1
   .base = { __DRI_USE_INVALIDATE, 1 }
d114 1
a114 1
		EGLint surface_type, const EGLint *attr_list,
d198 10
d302 2
a303 3
   .base = { __DRI_IMAGE_LOOKUP, 1 },

   .lookupEGLImage       = dri2_lookup_egl_image
d375 1
a375 1
   const __DRIextension **extensions = NULL;
a376 2
   char *get_extensions_name;
   const __DRIextension **(*get_extensions)(void);
a406 3
      /* not need continue to loop all paths once the driver is found */
      if (dri2_dpy->driver != NULL)
         break;
d417 1
a417 15

   if (asprintf(&get_extensions_name, "%s_%s",
                __DRI_DRIVER_GET_EXTENSIONS, dri2_dpy->driver_name) != -1) {
      get_extensions = dlsym(dri2_dpy->driver, get_extensions_name);
      if (get_extensions) {
         extensions = get_extensions();
      } else {
         _eglLog(_EGL_DEBUG, "driver does not expose %s(): %s\n",
                 get_extensions_name, dlerror());
      }
      free(get_extensions_name);
   }

   if (!extensions)
      extensions = dlsym(dri2_dpy->driver, __DRI_DRIVER_EXTENSIONS);
a440 1
   dri2_dpy->driver_extensions = extensions;
a460 1
   dri2_dpy->driver_extensions = extensions;
a492 1
   disp->Extensions.MESA_configless_context = EGL_TRUE;
a509 6
#ifdef HAVE_DRM_PLATFORM
      if (dri2_dpy->image->base.version >= 8 &&
          dri2_dpy->image->createImageFromDmaBufs) {
         disp->Extensions.EXT_image_dma_buf_import = EGL_TRUE;
      }
#endif
d522 3
a524 12
      if (dri2_dpy->dri2->base.version >= 4) {
         dri2_dpy->dri_screen =
            dri2_dpy->dri2->createNewScreen2(0, dri2_dpy->fd,
                                             dri2_dpy->extensions,
                                             dri2_dpy->driver_extensions,
                                             &dri2_dpy->driver_configs, disp);
      } else {
         dri2_dpy->dri_screen =
            dri2_dpy->dri2->createNewScreen(0, dri2_dpy->fd,
                                            dri2_dpy->extensions,
                                            &dri2_dpy->driver_configs, disp);
      }
d527 3
a529 10
      if (dri2_dpy->swrast->base.version >= 4) {
         dri2_dpy->dri_screen =
            dri2_dpy->swrast->createNewScreen2(0, dri2_dpy->extensions,
                                               dri2_dpy->driver_extensions,
                                               &dri2_dpy->driver_configs, disp);
      } else {
         dri2_dpy->dri_screen =
            dri2_dpy->swrast->createNewScreen(0, dri2_dpy->extensions,
                                              &dri2_dpy->driver_configs, disp);
      }
d589 1
d602 1
d634 2
a635 1
   switch (disp->Platform) {
d637 1
a637 2
   case _EGL_PLATFORM_X11:
      if (dri2_dpy->own_device) {
d639 1
a639 2
      }
      break;
d642 5
a646 5
   case _EGL_PLATFORM_DRM:
      if (dri2_dpy->own_device) {
         gbm_device_destroy(&dri2_dpy->gbm_dri->base.base);
      }
      break;
d648 2
a649 5
#ifdef HAVE_WAYLAND_PLATFORM
   case _EGL_PLATFORM_WAYLAND:
      wl_drm_destroy(dri2_dpy->wl_drm);
      if (dri2_dpy->own_device) {
         wl_display_disconnect(dri2_dpy->wl_dpy);
a650 4
      break;
#endif
   default:
      break;
a974 91
static _EGLSurface*
dri2_create_window_surface(_EGLDriver *drv, _EGLDisplay *dpy,
                           _EGLConfig *conf, void *native_window,
                           const EGLint *attrib_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->create_window_surface(drv, dpy, conf, native_window,
                                                attrib_list);
}

static _EGLSurface*
dri2_create_pixmap_surface(_EGLDriver *drv, _EGLDisplay *dpy,
                           _EGLConfig *conf, void *native_pixmap,
                           const EGLint *attrib_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->create_pixmap_surface(drv, dpy, conf, native_pixmap,
                                                attrib_list);
}

static _EGLSurface*
dri2_create_pbuffer_surface(_EGLDriver *drv, _EGLDisplay *dpy,
                           _EGLConfig *conf, const EGLint *attrib_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->create_pbuffer_surface(drv, dpy, conf, attrib_list);
}

static EGLBoolean
dri2_destroy_surface(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->destroy_surface(drv, dpy, surf);
}

static EGLBoolean
dri2_swap_interval(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf,
                   EGLint interval)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->swap_interval(drv, dpy, surf, interval);
}

static EGLBoolean
dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->swap_buffers(drv, dpy, surf);
}

static EGLBoolean
dri2_swap_buffers_with_damage(_EGLDriver *drv, _EGLDisplay *dpy,
                              _EGLSurface *surf,
                              const EGLint *rects, EGLint n_rects)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->swap_buffers_with_damage(drv, dpy, surf,
                                                   rects, n_rects);
}

static EGLBoolean
dri2_swap_buffers_region(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf,
                         EGLint numRects, const EGLint *rects)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->swap_buffers_region(drv, dpy, surf, numRects, rects);
}

static EGLBoolean
dri2_post_sub_buffer(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf,
                     EGLint x, EGLint y, EGLint width, EGLint height)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->post_sub_buffer(drv, dpy, surf, x, y, width, height);
}

static EGLBoolean
dri2_copy_buffers(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf,
                  void *native_pixmap_target)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->copy_buffers(drv, dpy, surf, native_pixmap_target);
}

static EGLint
dri2_query_buffer_age(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->query_buffer_age(drv, dpy, surf);
}

d1051 1
d1071 5
a1075 7

   if (dri2_dpy->tex_buffer->base.version >= 3 &&
       dri2_dpy->tex_buffer->releaseTexBuffer != NULL) {
      (*dri2_dpy->tex_buffer->releaseTexBuffer)(dri2_ctx->dri_context,
                                                target,
                                                dri2_surf->dri_drawable);
   }
a1079 10
static _EGLImage*
dri2_create_image(_EGLDriver *drv, _EGLDisplay *dpy, _EGLContext *ctx,
                  EGLenum target, EGLClientBuffer buffer,
                  const EGLint *attr_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->create_image(drv, dpy, ctx, target, buffer,
                                       attr_list);
}

d1081 1
a1081 1
dri2_create_image_from_dri(_EGLDisplay *disp, __DRIimage *dri_image)
d1125 1
a1125 1
   return dri2_create_image_from_dri(disp, dri_image);
a1127 1
#ifdef HAVE_DRM_PLATFORM
d1170 1
a1170 1
   return dri2_create_image_from_dri(disp, dri_image);
a1171 1
#endif
d1198 1
a1198 1
   struct wl_drm_buffer *buffer;
d1206 1
a1206 3
   buffer = wayland_drm_buffer_get(dri2_dpy->wl_server_drm,
                                   (struct wl_resource *) _buffer);
   if (!buffer)
d1230 1
a1230 1
   return dri2_create_image_from_dri(disp, dri_image);
a1342 265
static struct wl_buffer*
dri2_create_wayland_buffer_from_image(_EGLDriver *drv, _EGLDisplay *dpy,
                                      _EGLImage *img)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->create_wayland_buffer_from_image(drv, dpy, img);
}

#ifdef HAVE_DRM_PLATFORM
static EGLBoolean
dri2_check_dma_buf_attribs(const _EGLImageAttribs *attrs)
{
   unsigned i;

   /**
     * The spec says:
     *
     * "Required attributes and their values are as follows:
     *
     *  * EGL_WIDTH & EGL_HEIGHT: The logical dimensions of the buffer in pixels
     *
     *  * EGL_LINUX_DRM_FOURCC_EXT: The pixel format of the buffer, as specified
     *    by drm_fourcc.h and used as the pixel_format parameter of the
     *    drm_mode_fb_cmd2 ioctl."
     *
     * and
     *
     * "* If <target> is EGL_LINUX_DMA_BUF_EXT, and the list of attributes is
     *    incomplete, EGL_BAD_PARAMETER is generated."
     */
   if (attrs->Width <= 0 || attrs->Height <= 0 ||
       !attrs->DMABufFourCC.IsPresent) {
      _eglError(EGL_BAD_PARAMETER, "attribute(s) missing");
      return EGL_FALSE;
   }

   /**
    * Also:
    *
    * "If <target> is EGL_LINUX_DMA_BUF_EXT and one or more of the values
    *  specified for a plane's pitch or offset isn't supported by EGL,
    *  EGL_BAD_ACCESS is generated."
    */
   for (i = 0; i < ARRAY_SIZE(attrs->DMABufPlanePitches); ++i) {
      if (attrs->DMABufPlanePitches[i].IsPresent &&
          attrs->DMABufPlanePitches[i].Value <= 0) {
         _eglError(EGL_BAD_ACCESS, "invalid pitch");
         return EGL_FALSE;
      }
   }

   return EGL_TRUE;
}

/* Returns the total number of file descriptors. Zero indicates an error. */
static unsigned
dri2_check_dma_buf_format(const _EGLImageAttribs *attrs)
{
   unsigned i, plane_n;

   switch (attrs->DMABufFourCC.Value) {
   case DRM_FORMAT_RGB332:
   case DRM_FORMAT_BGR233:
   case DRM_FORMAT_XRGB4444:
   case DRM_FORMAT_XBGR4444:
   case DRM_FORMAT_RGBX4444:
   case DRM_FORMAT_BGRX4444:
   case DRM_FORMAT_ARGB4444:
   case DRM_FORMAT_ABGR4444:
   case DRM_FORMAT_RGBA4444:
   case DRM_FORMAT_BGRA4444:
   case DRM_FORMAT_XRGB1555:
   case DRM_FORMAT_XBGR1555:
   case DRM_FORMAT_RGBX5551:
   case DRM_FORMAT_BGRX5551:
   case DRM_FORMAT_ARGB1555:
   case DRM_FORMAT_ABGR1555:
   case DRM_FORMAT_RGBA5551:
   case DRM_FORMAT_BGRA5551:
   case DRM_FORMAT_RGB565:
   case DRM_FORMAT_BGR565:
   case DRM_FORMAT_RGB888:
   case DRM_FORMAT_BGR888:
   case DRM_FORMAT_XRGB8888:
   case DRM_FORMAT_XBGR8888:
   case DRM_FORMAT_RGBX8888:
   case DRM_FORMAT_BGRX8888:
   case DRM_FORMAT_ARGB8888:
   case DRM_FORMAT_ABGR8888:
   case DRM_FORMAT_RGBA8888:
   case DRM_FORMAT_BGRA8888:
   case DRM_FORMAT_XRGB2101010:
   case DRM_FORMAT_XBGR2101010:
   case DRM_FORMAT_RGBX1010102:
   case DRM_FORMAT_BGRX1010102:
   case DRM_FORMAT_ARGB2101010:
   case DRM_FORMAT_ABGR2101010:
   case DRM_FORMAT_RGBA1010102:
   case DRM_FORMAT_BGRA1010102:
   case DRM_FORMAT_YUYV:
   case DRM_FORMAT_YVYU:
   case DRM_FORMAT_UYVY:
   case DRM_FORMAT_VYUY:
      plane_n = 1;
      break;
   case DRM_FORMAT_NV12:
   case DRM_FORMAT_NV21:
   case DRM_FORMAT_NV16:
   case DRM_FORMAT_NV61:
      plane_n = 2;
      break;
   case DRM_FORMAT_YUV410:
   case DRM_FORMAT_YVU410:
   case DRM_FORMAT_YUV411:
   case DRM_FORMAT_YVU411:
   case DRM_FORMAT_YUV420:
   case DRM_FORMAT_YVU420:
   case DRM_FORMAT_YUV422:
   case DRM_FORMAT_YVU422:
   case DRM_FORMAT_YUV444:
   case DRM_FORMAT_YVU444:
      plane_n = 3;
      break;
   default:
      _eglError(EGL_BAD_ATTRIBUTE, "invalid format");
      return 0;
   }

   /**
     * The spec says:
     *
     * "* If <target> is EGL_LINUX_DMA_BUF_EXT, and the list of attributes is
     *    incomplete, EGL_BAD_PARAMETER is generated."
     */
   for (i = 0; i < plane_n; ++i) {
      if (!attrs->DMABufPlaneFds[i].IsPresent ||
          !attrs->DMABufPlaneOffsets[i].IsPresent ||
          !attrs->DMABufPlanePitches[i].IsPresent) {
         _eglError(EGL_BAD_PARAMETER, "plane attribute(s) missing");
         return 0;
      }
   }

   /**
    * The spec also says:
    *
    * "If <target> is EGL_LINUX_DMA_BUF_EXT, and the EGL_LINUX_DRM_FOURCC_EXT
    *  attribute indicates a single-plane format, EGL_BAD_ATTRIBUTE is
    *  generated if any of the EGL_DMA_BUF_PLANE1_* or EGL_DMA_BUF_PLANE2_*
    *  attributes are specified."
    */
   for (i = plane_n; i < 3; ++i) {
      if (attrs->DMABufPlaneFds[i].IsPresent ||
          attrs->DMABufPlaneOffsets[i].IsPresent ||
          attrs->DMABufPlanePitches[i].IsPresent) {
         _eglError(EGL_BAD_ATTRIBUTE, "too many plane attributes");
         return 0;
      }
   }

   return plane_n;
}

/**
 * The spec says:
 *
 * "If eglCreateImageKHR is successful for a EGL_LINUX_DMA_BUF_EXT target,
 *  the EGL takes ownership of the file descriptor and is responsible for
 *  closing it, which it may do at any time while the EGLDisplay is
 *  initialized."
 */
static void
dri2_take_dma_buf_ownership(const int *fds, unsigned num_fds)
{
   int already_closed[num_fds];
   unsigned num_closed = 0;
   unsigned i, j;

   for (i = 0; i < num_fds; ++i) {
      /**
       * The same file descriptor can be referenced multiple times in case more
       * than one plane is found in the same buffer, just with a different
       * offset.
       */
      for (j = 0; j < num_closed; ++j) {
         if (already_closed[j] == fds[i])
            break;
      }

      if (j == num_closed) {
         close(fds[i]);
         already_closed[num_closed++] = fds[i];
      }
   }
}

static _EGLImage *
dri2_create_image_dma_buf(_EGLDisplay *disp, _EGLContext *ctx,
			  EGLClientBuffer buffer, const EGLint *attr_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   _EGLImage *res;
   EGLint err;
   _EGLImageAttribs attrs;
   __DRIimage *dri_image;
   unsigned num_fds;
   unsigned i;
   int fds[3];
   int pitches[3];
   int offsets[3];
   unsigned error;

   /**
    * The spec says:
    *
    * ""* If <target> is EGL_LINUX_DMA_BUF_EXT and <buffer> is not NULL, the
    *     error EGL_BAD_PARAMETER is generated."
    */
   if (buffer != NULL) {
      _eglError(EGL_BAD_PARAMETER, "buffer not NULL");
      return NULL;
   }

   err = _eglParseImageAttribList(&attrs, disp, attr_list);
   if (err != EGL_SUCCESS) {
      _eglError(err, "bad attribute");
      return NULL;
   }

   if (!dri2_check_dma_buf_attribs(&attrs))
      return NULL;

   num_fds = dri2_check_dma_buf_format(&attrs);
   if (!num_fds)
      return NULL;

   for (i = 0; i < num_fds; ++i) {
      fds[i] = attrs.DMABufPlaneFds[i].Value;
      pitches[i] = attrs.DMABufPlanePitches[i].Value;
      offsets[i] = attrs.DMABufPlaneOffsets[i].Value;
   }

   dri_image =
      dri2_dpy->image->createImageFromDmaBufs(dri2_dpy->dri_screen,
         attrs.Width, attrs.Height, attrs.DMABufFourCC.Value,
         fds, num_fds, pitches, offsets,
         attrs.DMABufYuvColorSpaceHint.Value,
         attrs.DMABufSampleRangeHint.Value,
         attrs.DMABufChromaHorizontalSiting.Value,
         attrs.DMABufChromaVerticalSiting.Value,
         &error,
         NULL);
   dri2_create_image_khr_texture_error(error);

   if (!dri_image)
      return EGL_NO_IMAGE_KHR;

   res = dri2_create_image_from_dri(disp, dri_image);
   if (res)
      dri2_take_dma_buf_ownership(fds, num_fds);

   return res;
}
#endif

a1360 1
#ifdef HAVE_DRM_PLATFORM
a1362 1
#endif
a1366 4
#ifdef HAVE_DRM_PLATFORM
   case EGL_LINUX_DMA_BUF_EXT:
      return dri2_create_image_dma_buf(disp, ctx, buffer, attr_list);
#endif
a1386 1
#ifdef HAVE_DRM_PLATFORM
a1496 1
#endif
d1511 2
a1512 2
                                                  buffer->width,
                                                  buffer->height,
d1520 2
a1521 2
                                                buffer->width,
                                                buffer->height,
d1573 1
a1573 1
      (int(*)(void *, uint32_t)) dri2_dpy->vtbl->authenticate;
a1588 2
   /* We have to share the wl_drm instance with gbm, so gbm can convert
    * wl_buffers to gbm bos. */
d1615 1
a1615 1
                             struct wl_resource *buffer_resource,
d1618 1
a1619 1
   struct wl_drm_buffer *buffer;
d1622 1
a1622 2
   buffer = wayland_drm_buffer_get(dri2_dpy->wl_server_drm, buffer_resource);
   if (!buffer)
d1631 1
a1631 1
      *value = buffer->width;
d1634 1
a1634 1
      *value = buffer->height;
a1722 4
   dri2_drv->base.API.CreateWindowSurface = dri2_create_window_surface;
   dri2_drv->base.API.CreatePixmapSurface = dri2_create_pixmap_surface;
   dri2_drv->base.API.CreatePbufferSurface = dri2_create_pbuffer_surface;
   dri2_drv->base.API.DestroySurface = dri2_destroy_surface;
d1728 1
a1728 8
   dri2_drv->base.API.SwapInterval = dri2_swap_interval;
   dri2_drv->base.API.SwapBuffers = dri2_swap_buffers;
   dri2_drv->base.API.SwapBuffersWithDamageEXT = dri2_swap_buffers_with_damage;
   dri2_drv->base.API.SwapBuffersRegionNOK = dri2_swap_buffers_region;
   dri2_drv->base.API.PostSubBufferNV = dri2_post_sub_buffer;
   dri2_drv->base.API.CopyBuffers = dri2_copy_buffers,
   dri2_drv->base.API.QueryBufferAge = dri2_query_buffer_age;
   dri2_drv->base.API.CreateImageKHR = dri2_create_image;
a1729 2
   dri2_drv->base.API.CreateWaylandBufferFromImageWL = dri2_create_wayland_buffer_from_image;
#ifdef HAVE_DRM_PLATFORM
a1731 1
#endif
@


1.1.1.5
log
@Import Mesa 10.2.7
@
text
@d1666 4
a1669 6
 * "If eglCreateImageKHR is successful for a EGL_LINUX_DMA_BUF_EXT target, the
 *  EGL will take a reference to the dma_buf(s) which it will release at any
 *  time while the EGLDisplay is initialized. It is the responsibility of the
 *  application to close the dma_buf file descriptors."
 *
 * Therefore we must never close or otherwise modify the file descriptors.
d1671 25
d1758 2
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d38 1
a38 1
#ifdef HAVE_LIBDRM
d307 2
d363 1
a363 1
	 _eglLog(_EGL_WARNING, "DRI2: did not find extension %s version %d",
d472 1
d474 1
d525 1
a525 9
      if (dri2_dpy->image->base.version >= 10 &&
          dri2_dpy->image->getCapabilities != NULL) {
         int capabilities;

         capabilities = dri2_dpy->image->getCapabilities(dri2_dpy->dri_screen);
         disp->Extensions.MESA_drm_image = (capabilities & __DRI_IMAGE_CAP_GLOBAL_NAMES) != 0;
      } else
         disp->Extensions.MESA_drm_image = EGL_TRUE;

a541 4
/* All platforms but DRM call this function to create the screen, query the
 * dri extensions, setup the vtables and populate the driver_configs.
 * DRM inherits all that information from its display - GBM.
 */
a664 1
   unsigned i;
a675 1
   free(dri2_dpy->driver_name);
a703 9
   /* The drm platform does not create the screen/driver_configs but reuses
    * the ones from the gbm device. As such the gbm itself is responsible
    * for the cleanup.
    */
   if (disp->Platform != _EGL_PLATFORM_DRM) {
      for (i = 0; dri2_dpy->driver_configs[i]; i++)
         free((__DRIconfig *) dri2_dpy->driver_configs[i]);
      free(dri2_dpy->driver_configs);
   }
d814 2
a815 3
         _eglError(EGL_BAD_PARAMETER, "eglCreateContext");
         free(dri2_ctx);
         return NULL;
a1390 9
static EGLBoolean
dri2_get_sync_values_chromium(_EGLDisplay *dpy, _EGLSurface *surf,
                              EGLuint64KHR *ust, EGLuint64KHR *msc,
                              EGLuint64KHR *sbc)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
   return dri2_dpy->vtbl->get_sync_values(dpy, surf, ust, msc, sbc);
}

d1969 1
a1969 1
   int flags = 0;
d1980 2
a1981 3
#ifdef HAVE_LIBDRM
   if (drmGetCap(dri2_dpy->fd, DRM_CAP_PRIME, &cap) == 0 &&
       cap == (DRM_PRIME_CAP_IMPORT | DRM_PRIME_CAP_EXPORT) &&
a1984 1
#endif
a2158 1
   dri2_drv->base.API.GetSyncValuesCHROMIUM = dri2_get_sync_values_chromium;
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d38 1
a38 1
#ifdef HAVE_DRM_PLATFORM
a306 2
static const char dri_driver_path[] = DEFAULT_DRIVER_DIR;

d361 1
a361 1
	 _eglLog(_EGL_FATAL, "DRI2: did not find extension %s version %d",
a469 1
   dri2_dpy->driver_name = "swrast";
a470 1

d521 9
a529 1
      disp->Extensions.MESA_drm_image = EGL_TRUE;
d546 4
d673 1
d685 1
d714 9
d833 3
a835 2
	 _eglError(EGL_BAD_PARAMETER, "eglCreateContext");
	 return NULL;
d1411 9
d1998 1
a1998 1
   int ret, flags = 0;
d2009 3
a2011 2
   ret = drmGetCap(dri2_dpy->fd, DRM_CAP_PRIME, &cap);
   if (ret == 0 && cap == (DRM_PRIME_CAP_IMPORT | DRM_PRIME_CAP_EXPORT) &&
d2015 1
d2190 1
@


