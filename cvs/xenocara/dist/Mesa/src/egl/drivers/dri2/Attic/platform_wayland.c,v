head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.25;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.14;	author jsg;	state Exp;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2014.07.09.21.08.51;	author jsg;	state Exp;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.13.59.23;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.02;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.09.16;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.33.40;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.05.58;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.43.06;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright © 2011-2012 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Kristian Høgsberg <krh@@bitplanet.net>
 *    Benjamin Franzke <benjaminfranzke@@googlemail.com>
 */

#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <dlfcn.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <xf86drm.h>

#include "egl_dri2.h"
#include "egl_dri2_fallbacks.h"
#include "loader.h"

#include <wayland-client.h>
#include "wayland-drm-client-protocol.h"

enum wl_drm_format_flags {
   HAS_ARGB8888 = 1,
   HAS_XRGB8888 = 2,
   HAS_RGB565 = 4,
};

static EGLBoolean
dri2_wl_swap_interval(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf,
                      EGLint interval);

static void
sync_callback(void *data, struct wl_callback *callback, uint32_t serial)
{
   int *done = data;

   *done = 1;
   wl_callback_destroy(callback);
}

static const struct wl_callback_listener sync_listener = {
   sync_callback
};

static int
roundtrip(struct dri2_egl_display *dri2_dpy)
{
   struct wl_callback *callback;
   int done = 0, ret = 0;

   callback = wl_display_sync(dri2_dpy->wl_dpy);
   wl_callback_add_listener(callback, &sync_listener, &done);
   wl_proxy_set_queue((struct wl_proxy *) callback, dri2_dpy->wl_queue);
   while (ret != -1 && !done)
      ret = wl_display_dispatch_queue(dri2_dpy->wl_dpy, dri2_dpy->wl_queue);

   if (!done)
      wl_callback_destroy(callback);

   return ret;
}

static void
wl_buffer_release(void *data, struct wl_buffer *buffer)
{
   struct dri2_egl_surface *dri2_surf = data;
   int i;

   for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); ++i)
      if (dri2_surf->color_buffers[i].wl_buffer == buffer)
         break;

   if (i == ARRAY_SIZE(dri2_surf->color_buffers)) {
      wl_buffer_destroy(buffer);
      return;
   }

   dri2_surf->color_buffers[i].locked = 0;
}

static struct wl_buffer_listener wl_buffer_listener = {
   wl_buffer_release
};

static void
resize_callback(struct wl_egl_window *wl_win, void *data)
{
   struct dri2_egl_surface *dri2_surf = data;
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);

   (*dri2_dpy->flush->invalidate)(dri2_surf->dri_drawable);
}

/**
 * Called via eglCreateWindowSurface(), drv->API.CreateWindowSurface().
 */
static _EGLSurface *
dri2_wl_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
                       _EGLConfig *conf, void *native_window,
                       const EGLint *attrib_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
   struct wl_egl_window *window = native_window;
   struct dri2_egl_surface *dri2_surf;

   (void) drv;

   dri2_surf = malloc(sizeof *dri2_surf);
   if (!dri2_surf) {
      _eglError(EGL_BAD_ALLOC, "dri2_create_surface");
      return NULL;
   }
   
   memset(dri2_surf, 0, sizeof *dri2_surf);
   if (!_eglInitSurface(&dri2_surf->base, disp, type, conf, attrib_list))
      goto cleanup_surf;

   if (conf->RedSize == 5)
      dri2_surf->format = WL_DRM_FORMAT_RGB565;
   else if (conf->AlphaSize == 0)
      dri2_surf->format = WL_DRM_FORMAT_XRGB8888;
   else
      dri2_surf->format = WL_DRM_FORMAT_ARGB8888;

   switch (type) {
   case EGL_WINDOW_BIT:
      dri2_surf->wl_win = window;

      dri2_surf->wl_win->private = dri2_surf;
      dri2_surf->wl_win->resize_callback = resize_callback;

      dri2_surf->base.Width =  -1;
      dri2_surf->base.Height = -1;
      break;
   default: 
      goto cleanup_surf;
   }

   dri2_surf->dri_drawable = 
      (*dri2_dpy->dri2->createNewDrawable) (dri2_dpy->dri_screen,
					    type == EGL_WINDOW_BIT ?
					    dri2_conf->dri_double_config : 
					    dri2_conf->dri_single_config,
					    dri2_surf);
   if (dri2_surf->dri_drawable == NULL) {
      _eglError(EGL_BAD_ALLOC, "dri2->createNewDrawable");
      goto cleanup_dri_drawable;
   }

   return &dri2_surf->base;

 cleanup_dri_drawable:
   dri2_dpy->core->destroyDrawable(dri2_surf->dri_drawable);
 cleanup_surf:
   free(dri2_surf);

   return NULL;
}

/**
 * Called via eglCreateWindowSurface(), drv->API.CreateWindowSurface().
 */
static _EGLSurface *
dri2_wl_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
                              _EGLConfig *conf, void *native_window,
                              const EGLint *attrib_list)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   _EGLSurface *surf;

   surf = dri2_wl_create_surface(drv, disp, EGL_WINDOW_BIT, conf,
                                 native_window, attrib_list);

   if (surf != NULL)
      dri2_wl_swap_interval(drv, disp, surf, dri2_dpy->default_swap_interval);

   return surf;
}

static _EGLSurface *
dri2_wl_create_pixmap_surface(_EGLDriver *drv, _EGLDisplay *disp,
                              _EGLConfig *conf, void *native_window,
                              const EGLint *attrib_list)
{
   /* From the EGL_EXT_platform_wayland spec, version 3:
    *
    *   It is not valid to call eglCreatePlatformPixmapSurfaceEXT with a <dpy>
    *   that belongs to Wayland. Any such call fails and generates
    *   EGL_BAD_PARAMETER.
    */
   _eglError(EGL_BAD_PARAMETER, "cannot create EGL pixmap surfaces on "
             "Wayland");
   return NULL;
}

/**
 * Called via eglDestroySurface(), drv->API.DestroySurface().
 */
static EGLBoolean
dri2_wl_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surf);
   int i;

   (void) drv;

   if (!_eglPutSurface(surf))
      return EGL_TRUE;

   (*dri2_dpy->core->destroyDrawable)(dri2_surf->dri_drawable);

   for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++) {
      if (dri2_surf->color_buffers[i].wl_buffer)
         wl_buffer_destroy(dri2_surf->color_buffers[i].wl_buffer);
      if (dri2_surf->color_buffers[i].dri_image)
         dri2_dpy->image->destroyImage(dri2_surf->color_buffers[i].dri_image);
   }

   for (i = 0; i < __DRI_BUFFER_COUNT; i++)
      if (dri2_surf->dri_buffers[i] &&
          dri2_surf->dri_buffers[i]->attachment != __DRI_BUFFER_BACK_LEFT)
         dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
                                       dri2_surf->dri_buffers[i]);

   if (dri2_surf->throttle_callback)
      wl_callback_destroy(dri2_surf->throttle_callback);

   if (dri2_surf->base.Type == EGL_WINDOW_BIT) {
      dri2_surf->wl_win->private = NULL;
      dri2_surf->wl_win->resize_callback = NULL;
   }

   free(surf);

   return EGL_TRUE;
}

static void
dri2_wl_release_buffers(struct dri2_egl_surface *dri2_surf)
{
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);
   int i;

   for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++) {
      if (dri2_surf->color_buffers[i].wl_buffer &&
          !dri2_surf->color_buffers[i].locked)
         wl_buffer_destroy(dri2_surf->color_buffers[i].wl_buffer);
      if (dri2_surf->color_buffers[i].dri_image)
         dri2_dpy->image->destroyImage(dri2_surf->color_buffers[i].dri_image);

      dri2_surf->color_buffers[i].wl_buffer = NULL;
      dri2_surf->color_buffers[i].dri_image = NULL;
      dri2_surf->color_buffers[i].locked = 0;
   }

   for (i = 0; i < __DRI_BUFFER_COUNT; i++)
      if (dri2_surf->dri_buffers[i] &&
          dri2_surf->dri_buffers[i]->attachment != __DRI_BUFFER_BACK_LEFT)
         dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
                                       dri2_surf->dri_buffers[i]);
}

static int
get_back_bo(struct dri2_egl_surface *dri2_surf)
{
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);
   int i;

   /* We always want to throttle to some event (either a frame callback or
    * a sync request) after the commit so that we can be sure the
    * compositor has had a chance to handle it and send us a release event
    * before we look for a free buffer */
   while (dri2_surf->throttle_callback != NULL)
      if (wl_display_dispatch_queue(dri2_dpy->wl_dpy,
                                    dri2_dpy->wl_queue) == -1)
         return -1;

   if (dri2_surf->back == NULL) {
      for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++) {
         /* Get an unlocked buffer, preferrably one with a dri_buffer
          * already allocated. */
         if (dri2_surf->color_buffers[i].locked)
            continue;
         if (dri2_surf->back == NULL)
            dri2_surf->back = &dri2_surf->color_buffers[i];
         else if (dri2_surf->back->dri_image == NULL)
            dri2_surf->back = &dri2_surf->color_buffers[i];
      }
   }

   if (dri2_surf->back == NULL)
      return -1;
   if (dri2_surf->back->dri_image == NULL) {
      dri2_surf->back->dri_image = 
         dri2_dpy->image->createImage(dri2_dpy->dri_screen,
                                      dri2_surf->base.Width,
                                      dri2_surf->base.Height,
                                      __DRI_IMAGE_FORMAT_ARGB8888,
                                      __DRI_IMAGE_USE_SHARE,
                                      NULL);
      dri2_surf->back->age = 0;
   }
   if (dri2_surf->back->dri_image == NULL)
      return -1;

   dri2_surf->back->locked = 1;

   return 0;
}


static void
back_bo_to_dri_buffer(struct dri2_egl_surface *dri2_surf, __DRIbuffer *buffer)
{
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);
   __DRIimage *image;
   int name, pitch;

   image = dri2_surf->back->dri_image;

   dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_NAME, &name);
   dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_STRIDE, &pitch);

   buffer->attachment = __DRI_BUFFER_BACK_LEFT;
   buffer->name = name;
   buffer->pitch = pitch;
   buffer->cpp = 4;
   buffer->flags = 0;
}

static int
get_aux_bo(struct dri2_egl_surface *dri2_surf,
	   unsigned int attachment, unsigned int format, __DRIbuffer *buffer)
{
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);
   __DRIbuffer *b = dri2_surf->dri_buffers[attachment];

   if (b == NULL) {
      b = dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen,
					 attachment, format,
					 dri2_surf->base.Width,
					 dri2_surf->base.Height);
      dri2_surf->dri_buffers[attachment] = b;
   }
   if (b == NULL)
      return -1;

   memcpy(buffer, b, sizeof *buffer);

   return 0;
}

static int
update_buffers(struct dri2_egl_surface *dri2_surf)
{
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);
   int i;

   if (dri2_surf->base.Type == EGL_WINDOW_BIT &&
       (dri2_surf->base.Width != dri2_surf->wl_win->width || 
        dri2_surf->base.Height != dri2_surf->wl_win->height)) {

      dri2_wl_release_buffers(dri2_surf);

      dri2_surf->base.Width  = dri2_surf->wl_win->width;
      dri2_surf->base.Height = dri2_surf->wl_win->height;
      dri2_surf->dx = dri2_surf->wl_win->dx;
      dri2_surf->dy = dri2_surf->wl_win->dy;
   }

   if (get_back_bo(dri2_surf) < 0) {
      _eglError(EGL_BAD_ALLOC, "failed to allocate color buffer");
      return -1;
   }

   /* If we have an extra unlocked buffer at this point, we had to do triple
    * buffering for a while, but now can go back to just double buffering.
    * That means we can free any unlocked buffer now. */
   for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++) {
      if (!dri2_surf->color_buffers[i].locked &&
          dri2_surf->color_buffers[i].wl_buffer) {
         wl_buffer_destroy(dri2_surf->color_buffers[i].wl_buffer);
         dri2_dpy->image->destroyImage(dri2_surf->color_buffers[i].dri_image);
         dri2_surf->color_buffers[i].wl_buffer = NULL;
         dri2_surf->color_buffers[i].dri_image = NULL;
      }
   }

   return 0;
}

static __DRIbuffer *
dri2_wl_get_buffers_with_format(__DRIdrawable * driDrawable,
                                int *width, int *height,
                                unsigned int *attachments, int count,
                                int *out_count, void *loaderPrivate)
{
   struct dri2_egl_surface *dri2_surf = loaderPrivate;
   int i, j;

   if (update_buffers(dri2_surf) < 0)
      return NULL;

   for (i = 0, j = 0; i < 2 * count; i += 2, j++) {
      switch (attachments[i]) {
      case __DRI_BUFFER_BACK_LEFT:
         back_bo_to_dri_buffer(dri2_surf, &dri2_surf->buffers[j]);
	 break;
      default:
	 if (get_aux_bo(dri2_surf, attachments[i], attachments[i + 1],
			&dri2_surf->buffers[j]) < 0) {
	    _eglError(EGL_BAD_ALLOC, "failed to allocate aux buffer");
	    return NULL;
	 }
	 break;
      }
   }

   *out_count = j;
   if (j == 0)
	   return NULL;

   *width = dri2_surf->base.Width;
   *height = dri2_surf->base.Height;

   return dri2_surf->buffers;
}

static __DRIbuffer *
dri2_wl_get_buffers(__DRIdrawable * driDrawable,
                    int *width, int *height,
                    unsigned int *attachments, int count,
                    int *out_count, void *loaderPrivate)
{
   unsigned int *attachments_with_format;
   __DRIbuffer *buffer;
   const unsigned int format = 32;
   int i;

   attachments_with_format = calloc(count * 2, sizeof(unsigned int));
   if (!attachments_with_format) {
      *out_count = 0;
      return NULL;
   }

   for (i = 0; i < count; ++i) {
      attachments_with_format[2*i] = attachments[i];
      attachments_with_format[2*i + 1] = format;
   }

   buffer =
      dri2_wl_get_buffers_with_format(driDrawable,
                                      width, height,
                                      attachments_with_format, count,
                                      out_count, loaderPrivate);

   free(attachments_with_format);

   return buffer;
}

static int
image_get_buffers(__DRIdrawable *driDrawable,
                  unsigned int format,
                  uint32_t *stamp,
                  void *loaderPrivate,
                  uint32_t buffer_mask,
                  struct __DRIimageList *buffers)
{
   struct dri2_egl_surface *dri2_surf = loaderPrivate;

   if (update_buffers(dri2_surf) < 0)
      return 0;

   buffers->image_mask = __DRI_IMAGE_BUFFER_BACK;
   buffers->back = dri2_surf->back->dri_image;

   return 1;
}

static void
dri2_wl_flush_front_buffer(__DRIdrawable * driDrawable, void *loaderPrivate)
{
   (void) driDrawable;
   (void) loaderPrivate;
}

static const __DRIimageLoaderExtension image_loader_extension = {
   .base = { __DRI_IMAGE_LOADER, 1 },

   .getBuffers          = image_get_buffers,
   .flushFrontBuffer    = dri2_wl_flush_front_buffer,
};

static void
wayland_throttle_callback(void *data,
                          struct wl_callback *callback,
                          uint32_t time)
{
   struct dri2_egl_surface *dri2_surf = data;

   dri2_surf->throttle_callback = NULL;
   wl_callback_destroy(callback);
}

static const struct wl_callback_listener throttle_listener = {
   wayland_throttle_callback
};

static void
create_wl_buffer(struct dri2_egl_surface *dri2_surf)
{
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);
   int fd, stride, name;

   if (dri2_surf->current->wl_buffer != NULL)
      return;

   if (dri2_dpy->capabilities & WL_DRM_CAPABILITY_PRIME) {
      dri2_dpy->image->queryImage(dri2_surf->current->dri_image,
                                  __DRI_IMAGE_ATTRIB_FD, &fd);
      dri2_dpy->image->queryImage(dri2_surf->current->dri_image,
                                  __DRI_IMAGE_ATTRIB_STRIDE, &stride);

      dri2_surf->current->wl_buffer =
         wl_drm_create_prime_buffer(dri2_dpy->wl_drm,
                                    fd,
                                    dri2_surf->base.Width,
                                    dri2_surf->base.Height,
                                    dri2_surf->format,
                                    0, stride,
                                    0, 0,
                                    0, 0);
      close(fd);
   } else {
      dri2_dpy->image->queryImage(dri2_surf->current->dri_image,
                                  __DRI_IMAGE_ATTRIB_NAME, &name);
      dri2_dpy->image->queryImage(dri2_surf->current->dri_image,
                                  __DRI_IMAGE_ATTRIB_STRIDE, &stride);

      dri2_surf->current->wl_buffer =
         wl_drm_create_buffer(dri2_dpy->wl_drm,
                              name,
                              dri2_surf->base.Width,
                              dri2_surf->base.Height,
                              stride,
                              dri2_surf->format);
   }

   wl_proxy_set_queue((struct wl_proxy *) dri2_surf->current->wl_buffer,
                      dri2_dpy->wl_queue);
   wl_buffer_add_listener(dri2_surf->current->wl_buffer,
                          &wl_buffer_listener, dri2_surf);
}

/**
 * Called via eglSwapBuffers(), drv->API.SwapBuffers().
 */
static EGLBoolean
dri2_wl_swap_buffers_with_damage(_EGLDriver *drv,
                                 _EGLDisplay *disp,
                                 _EGLSurface *draw,
                                 const EGLint *rects,
                                 EGLint n_rects)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);
   struct dri2_egl_context *dri2_ctx;
   _EGLContext *ctx;
   int i;

   for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++)
      if (dri2_surf->color_buffers[i].age > 0)
         dri2_surf->color_buffers[i].age++;

   /* Make sure we have a back buffer in case we're swapping without ever
    * rendering. */
   if (get_back_bo(dri2_surf) < 0) {
      _eglError(EGL_BAD_ALLOC, "dri2_swap_buffers");
      return EGL_FALSE;
   }

   if (draw->SwapInterval > 0) {
      dri2_surf->throttle_callback =
         wl_surface_frame(dri2_surf->wl_win->surface);
      wl_callback_add_listener(dri2_surf->throttle_callback,
                               &throttle_listener, dri2_surf);
      wl_proxy_set_queue((struct wl_proxy *) dri2_surf->throttle_callback,
                         dri2_dpy->wl_queue);
   }

   dri2_surf->back->age = 1;
   dri2_surf->current = dri2_surf->back;
   dri2_surf->back = NULL;

   create_wl_buffer(dri2_surf);

   wl_surface_attach(dri2_surf->wl_win->surface,
                     dri2_surf->current->wl_buffer,
                     dri2_surf->dx, dri2_surf->dy);

   dri2_surf->wl_win->attached_width  = dri2_surf->base.Width;
   dri2_surf->wl_win->attached_height = dri2_surf->base.Height;
   /* reset resize growing parameters */
   dri2_surf->dx = 0;
   dri2_surf->dy = 0;

   if (n_rects == 0) {
      wl_surface_damage(dri2_surf->wl_win->surface,
                        0, 0, INT32_MAX, INT32_MAX);
   } else {
      for (i = 0; i < n_rects; i++) {
         const int *rect = &rects[i * 4];
         wl_surface_damage(dri2_surf->wl_win->surface,
                           rect[0],
                           dri2_surf->base.Height - rect[1] - rect[3],
                           rect[2], rect[3]);
      }
   }

   if (dri2_dpy->flush->base.version >= 4) {
      ctx = _eglGetCurrentContext();
      dri2_ctx = dri2_egl_context(ctx);
      (*dri2_dpy->flush->flush_with_flags)(dri2_ctx->dri_context,
                                           dri2_surf->dri_drawable,
                                           __DRI2_FLUSH_DRAWABLE,
                                           __DRI2_THROTTLE_SWAPBUFFER);
   } else {
      (*dri2_dpy->flush->flush)(dri2_surf->dri_drawable);
   }

   (*dri2_dpy->flush->invalidate)(dri2_surf->dri_drawable);

   wl_surface_commit(dri2_surf->wl_win->surface);

   /* If we're not waiting for a frame callback then we'll at least throttle
    * to a sync callback so that we always give a chance for the compositor to
    * handle the commit and send a release event before checking for a free
    * buffer */
   if (dri2_surf->throttle_callback == NULL) {
      dri2_surf->throttle_callback = wl_display_sync(dri2_dpy->wl_dpy);
      wl_callback_add_listener(dri2_surf->throttle_callback,
                               &throttle_listener, dri2_surf);
      wl_proxy_set_queue((struct wl_proxy *) dri2_surf->throttle_callback,
                         dri2_dpy->wl_queue);
   }

   wl_display_flush(dri2_dpy->wl_dpy);

   return EGL_TRUE;
}

static EGLint
dri2_wl_query_buffer_age(_EGLDriver *drv,
                         _EGLDisplay *disp, _EGLSurface *surface)
{
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surface);

   if (get_back_bo(dri2_surf) < 0) {
      _eglError(EGL_BAD_ALLOC, "dri2_query_buffer_age");
      return 0;
   }

   return dri2_surf->back->age;
}

static EGLBoolean
dri2_wl_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
{
   return dri2_wl_swap_buffers_with_damage (drv, disp, draw, NULL, 0);
}

static struct wl_buffer *
dri2_wl_create_wayland_buffer_from_image(_EGLDriver *drv,
                                          _EGLDisplay *disp,
                                          _EGLImage *img)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_image *dri2_img = dri2_egl_image(img);
   __DRIimage *image = dri2_img->dri_image;
   struct wl_buffer *buffer;
   int width, height, format, pitch;
   enum wl_drm_format wl_format;

   dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_FORMAT, &format);

   switch (format) {
   case __DRI_IMAGE_FORMAT_ARGB8888:
      if (!(dri2_dpy->formats & HAS_ARGB8888))
         goto bad_format;
      wl_format = WL_DRM_FORMAT_ARGB8888;
      break;
   case __DRI_IMAGE_FORMAT_XRGB8888:
      if (!(dri2_dpy->formats & HAS_XRGB8888))
         goto bad_format;
      wl_format = WL_DRM_FORMAT_XRGB8888;
      break;
   default:
      goto bad_format;
   }

   dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_WIDTH, &width);
   dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_HEIGHT, &height);
   dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_STRIDE, &pitch);

   if (dri2_dpy->capabilities & WL_DRM_CAPABILITY_PRIME) {
      int fd;

      dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_FD, &fd);

      buffer =
         wl_drm_create_prime_buffer(dri2_dpy->wl_drm,
                                    fd,
                                    width, height,
                                    wl_format,
                                    0, pitch,
                                    0, 0,
                                    0, 0);

      close(fd);
   } else {
      int name;

      dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_NAME, &name);

      buffer =
         wl_drm_create_buffer(dri2_dpy->wl_drm,
                              name,
                              width, height,
                              pitch,
                              wl_format);
   }

   /* The buffer object will have been created with our internal event queue
    * because it is using the wl_drm object as a proxy factory. We want the
    * buffer to be used by the application so we'll reset it to the display's
    * default event queue */
   if (buffer)
      wl_proxy_set_queue((struct wl_proxy *) buffer, NULL);

   return buffer;

bad_format:
   _eglError(EGL_BAD_MATCH, "unsupported image format");
   return NULL;
}

static int
dri2_wl_authenticate(_EGLDisplay *disp, uint32_t id)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   int ret = 0;

   dri2_dpy->authenticated = 0;

   wl_drm_authenticate(dri2_dpy->wl_drm, id);
   if (roundtrip(dri2_dpy) < 0)
      ret = -1;

   if (!dri2_dpy->authenticated)
      ret = -1;

   /* reset authenticated */
   dri2_dpy->authenticated = 1;

   return ret;
}

static void
drm_handle_device(void *data, struct wl_drm *drm, const char *device)
{
   struct dri2_egl_display *dri2_dpy = data;
   drm_magic_t magic;

   dri2_dpy->device_name = strdup(device);
   if (!dri2_dpy->device_name)
      return;

#ifdef O_CLOEXEC
   dri2_dpy->fd = open(dri2_dpy->device_name, O_RDWR | O_CLOEXEC);
   if (dri2_dpy->fd == -1 && errno == EINVAL)
#endif
   {
      dri2_dpy->fd = open(dri2_dpy->device_name, O_RDWR);
      if (dri2_dpy->fd != -1)
         fcntl(dri2_dpy->fd, F_SETFD, fcntl(dri2_dpy->fd, F_GETFD) |
            FD_CLOEXEC);
   }
   if (dri2_dpy->fd == -1) {
      _eglLog(_EGL_WARNING, "wayland-egl: could not open %s (%s)",
	      dri2_dpy->device_name, strerror(errno));
      return;
   }

   drmGetMagic(dri2_dpy->fd, &magic);
   wl_drm_authenticate(dri2_dpy->wl_drm, magic);
}

static void
drm_handle_format(void *data, struct wl_drm *drm, uint32_t format)
{
   struct dri2_egl_display *dri2_dpy = data;

   switch (format) {
   case WL_DRM_FORMAT_ARGB8888:
      dri2_dpy->formats |= HAS_ARGB8888;
      break;
   case WL_DRM_FORMAT_XRGB8888:
      dri2_dpy->formats |= HAS_XRGB8888;
      break;
   case WL_DRM_FORMAT_RGB565:
      dri2_dpy->formats |= HAS_RGB565;
      break;
   }
}

static void
drm_handle_capabilities(void *data, struct wl_drm *drm, uint32_t value)
{
   struct dri2_egl_display *dri2_dpy = data;

   dri2_dpy->capabilities = value;
}

static void
drm_handle_authenticated(void *data, struct wl_drm *drm)
{
   struct dri2_egl_display *dri2_dpy = data;

   dri2_dpy->authenticated = 1;
}

static const struct wl_drm_listener drm_listener = {
	drm_handle_device,
	drm_handle_format,
	drm_handle_authenticated,
	drm_handle_capabilities
};

static void
registry_handle_global(void *data, struct wl_registry *registry, uint32_t name,
		       const char *interface, uint32_t version)
{
   struct dri2_egl_display *dri2_dpy = data;

   if (version > 1)
      version = 2;
   if (strcmp(interface, "wl_drm") == 0) {
      dri2_dpy->wl_drm =
         wl_registry_bind(registry, name, &wl_drm_interface, version);
      wl_drm_add_listener(dri2_dpy->wl_drm, &drm_listener, dri2_dpy);
   }
}

static void
registry_handle_global_remove(void *data, struct wl_registry *registry,
			      uint32_t name)
{
}

static const struct wl_registry_listener registry_listener = {
   registry_handle_global,
   registry_handle_global_remove
};

static EGLBoolean
dri2_wl_swap_interval(_EGLDriver *drv,
                   _EGLDisplay *disp,
                   _EGLSurface *surf,
                   EGLint interval)
{
   if (interval > surf->Config->MaxSwapInterval)
      interval = surf->Config->MaxSwapInterval;
   else if (interval < surf->Config->MinSwapInterval)
      interval = surf->Config->MinSwapInterval;

   surf->SwapInterval = interval;

   return EGL_TRUE;
}

static void
dri2_wl_setup_swap_interval(struct dri2_egl_display *dri2_dpy)
{
   GLint vblank_mode = DRI_CONF_VBLANK_DEF_INTERVAL_1;

   /* We can't use values greater than 1 on Wayland because we are using the
    * frame callback to synchronise the frame and the only way we be sure to
    * get a frame callback is to attach a new buffer. Therefore we can't just
    * sit drawing nothing to wait until the next ‘n’ frame callbacks */

   if (dri2_dpy->config)
      dri2_dpy->config->configQueryi(dri2_dpy->dri_screen,
                                     "vblank_mode", &vblank_mode);
   switch (vblank_mode) {
   case DRI_CONF_VBLANK_NEVER:
      dri2_dpy->min_swap_interval = 0;
      dri2_dpy->max_swap_interval = 0;
      dri2_dpy->default_swap_interval = 0;
      break;
   case DRI_CONF_VBLANK_ALWAYS_SYNC:
      dri2_dpy->min_swap_interval = 1;
      dri2_dpy->max_swap_interval = 1;
      dri2_dpy->default_swap_interval = 1;
      break;
   case DRI_CONF_VBLANK_DEF_INTERVAL_0:
      dri2_dpy->min_swap_interval = 0;
      dri2_dpy->max_swap_interval = 1;
      dri2_dpy->default_swap_interval = 0;
      break;
   default:
   case DRI_CONF_VBLANK_DEF_INTERVAL_1:
      dri2_dpy->min_swap_interval = 0;
      dri2_dpy->max_swap_interval = 1;
      dri2_dpy->default_swap_interval = 1;
      break;
   }
}

static struct dri2_egl_display_vtbl dri2_wl_display_vtbl = {
   .authenticate = dri2_wl_authenticate,
   .create_window_surface = dri2_wl_create_window_surface,
   .create_pixmap_surface = dri2_wl_create_pixmap_surface,
   .create_pbuffer_surface = dri2_fallback_create_pbuffer_surface,
   .destroy_surface = dri2_wl_destroy_surface,
   .create_image = dri2_create_image_khr,
   .swap_interval = dri2_wl_swap_interval,
   .swap_buffers = dri2_wl_swap_buffers,
   .swap_buffers_with_damage = dri2_wl_swap_buffers_with_damage,
   .swap_buffers_region = dri2_fallback_swap_buffers_region,
   .post_sub_buffer = dri2_fallback_post_sub_buffer,
   .copy_buffers = dri2_fallback_copy_buffers,
   .query_buffer_age = dri2_wl_query_buffer_age,
   .create_wayland_buffer_from_image = dri2_wl_create_wayland_buffer_from_image,
};

EGLBoolean
dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
{
   struct dri2_egl_display *dri2_dpy;
   const __DRIconfig *config;
   uint32_t types;
   int i;
   static const unsigned int argb_masks[4] =
      { 0xff0000, 0xff00, 0xff, 0xff000000 };
   static const unsigned int rgb_masks[4] = { 0xff0000, 0xff00, 0xff, 0 };
   static const unsigned int rgb565_masks[4] = { 0xf800, 0x07e0, 0x001f, 0 };

   loader_set_logger(_eglLog);

   dri2_dpy = calloc(1, sizeof *dri2_dpy);
   if (!dri2_dpy)
      return _eglError(EGL_BAD_ALLOC, "eglInitialize");

   disp->DriverData = (void *) dri2_dpy;
   if (disp->PlatformDisplay == NULL) {
      dri2_dpy->wl_dpy = wl_display_connect(NULL);
      if (dri2_dpy->wl_dpy == NULL)
         goto cleanup_dpy;
      dri2_dpy->own_device = 1;
   } else {
      dri2_dpy->wl_dpy = disp->PlatformDisplay;
   }

   dri2_dpy->wl_queue = wl_display_create_queue(dri2_dpy->wl_dpy);

   if (dri2_dpy->own_device)
      wl_display_dispatch_pending(dri2_dpy->wl_dpy);

   dri2_dpy->wl_registry = wl_display_get_registry(dri2_dpy->wl_dpy);
   wl_proxy_set_queue((struct wl_proxy *) dri2_dpy->wl_registry,
                      dri2_dpy->wl_queue);
   wl_registry_add_listener(dri2_dpy->wl_registry,
                            &registry_listener, dri2_dpy);
   if (roundtrip(dri2_dpy) < 0 || dri2_dpy->wl_drm == NULL)
      goto cleanup_dpy;

   if (roundtrip(dri2_dpy) < 0 || dri2_dpy->fd == -1)
      goto cleanup_drm;

   if (roundtrip(dri2_dpy) < 0 || !dri2_dpy->authenticated)
      goto cleanup_fd;

   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd, 0);
   if (dri2_dpy->driver_name == NULL) {
      _eglError(EGL_BAD_ALLOC, "DRI2: failed to get driver name");
      goto cleanup_fd;
   }

   if (!dri2_load_driver(disp))
      goto cleanup_driver_name;

   dri2_dpy->dri2_loader_extension.base.name = __DRI_DRI2_LOADER;
   dri2_dpy->dri2_loader_extension.base.version = 3;
   dri2_dpy->dri2_loader_extension.getBuffers = dri2_wl_get_buffers;
   dri2_dpy->dri2_loader_extension.flushFrontBuffer = dri2_wl_flush_front_buffer;
   dri2_dpy->dri2_loader_extension.getBuffersWithFormat =
      dri2_wl_get_buffers_with_format;

   dri2_dpy->extensions[0] = &dri2_dpy->dri2_loader_extension.base;
   dri2_dpy->extensions[1] = &image_loader_extension.base;
   dri2_dpy->extensions[2] = &image_lookup_extension.base;
   dri2_dpy->extensions[3] = &use_invalidate.base;
   dri2_dpy->extensions[4] = NULL;

   dri2_dpy->swap_available = EGL_TRUE;

   if (!dri2_create_screen(disp))
      goto cleanup_driver;

   dri2_wl_setup_swap_interval(dri2_dpy);

   /* The server shouldn't advertise WL_DRM_CAPABILITY_PRIME if the driver
    * doesn't have createImageFromFds, since we're using the same driver on
    * both sides.  We don't want crash if that happens anyway, so fall back to
    * gem names if we don't have prime support. */

   if (dri2_dpy->image->base.version < 7 ||
       dri2_dpy->image->createImageFromFds == NULL)
      dri2_dpy->capabilities &= ~WL_DRM_CAPABILITY_PRIME;

   types = EGL_WINDOW_BIT;
   for (i = 0; dri2_dpy->driver_configs[i]; i++) {
      config = dri2_dpy->driver_configs[i];
      if (dri2_dpy->formats & HAS_XRGB8888)
	 dri2_add_config(disp, config, i + 1, types, NULL, rgb_masks);
      if (dri2_dpy->formats & HAS_ARGB8888)
	 dri2_add_config(disp, config, i + 1, types, NULL, argb_masks);
      if (dri2_dpy->formats & HAS_RGB565)
        dri2_add_config(disp, config, i + 1, types, NULL, rgb565_masks);
   }

   disp->Extensions.WL_bind_wayland_display = EGL_TRUE;
   disp->Extensions.WL_create_wayland_buffer_from_image = EGL_TRUE;
   disp->Extensions.EXT_buffer_age = EGL_TRUE;

   disp->Extensions.EXT_swap_buffers_with_damage = EGL_TRUE;

   /* we're supporting EGL 1.4 */
   disp->VersionMajor = 1;
   disp->VersionMinor = 4;

   /* Fill vtbl last to prevent accidentally calling virtual function during
    * initialization.
    */
   dri2_dpy->vtbl = &dri2_wl_display_vtbl;

   return EGL_TRUE;

 cleanup_driver:
   dlclose(dri2_dpy->driver);
 cleanup_driver_name:
   free(dri2_dpy->driver_name);
 cleanup_fd:
   close(dri2_dpy->fd);
 cleanup_drm:
   free(dri2_dpy->device_name);
   wl_drm_destroy(dri2_dpy->wl_drm);
 cleanup_dpy:
   free(dri2_dpy);
   
   return EGL_FALSE;
}
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d471 1
a471 1
   attachments_with_format = calloc(count, 2 * sizeof(unsigned int));
a966 1
   .get_sync_values = dri2_fallback_get_sync_values,
@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d471 1
a471 1
   attachments_with_format = calloc(count * 2, sizeof(unsigned int));
d967 1
@


1.2
log
@Merge Mesa 9.2.0
@
text
@d39 2
d47 2
a48 1
   HAS_XRGB8888 = 2
d51 4
d122 3
a124 3
dri2_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
		    _EGLConfig *conf, EGLNativeWindowType window,
		    const EGLint *attrib_list)
d128 1
d143 3
a145 1
   if (conf->AlphaSize == 0)
d152 1
a152 1
      dri2_surf->wl_win = (struct wl_egl_window *) window;
d189 3
a191 3
dri2_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
			   _EGLConfig *conf, EGLNativeWindowType window,
			   const EGLint *attrib_list)
d193 26
a218 2
   return dri2_create_surface(drv, disp, EGL_WINDOW_BIT, conf,
			      window, attrib_list);
d225 1
a225 1
dri2_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
d251 2
a252 2
   if (dri2_surf->frame_callback)
      wl_callback_destroy(dri2_surf->frame_callback);
d265 1
a265 1
dri2_release_buffers(struct dri2_egl_surface *dri2_surf)
d291 1
a291 1
get_back_bo(struct dri2_egl_surface *dri2_surf, __DRIbuffer *buffer)
d295 1
a295 2
   __DRIimage *image;
   int i, name, pitch;
d297 8
a304 2
   /* There might be a buffer release already queued that wasn't processed */
   wl_display_dispatch_queue_pending(dri2_dpy->wl_dpy, dri2_dpy->wl_queue);
d308 3
a310 3
         /* Get an unlocked buffer, preferrably one with a dri_buffer already
          * allocated. */
	 if (dri2_surf->color_buffers[i].locked)
d313 1
a313 1
	    dri2_surf->back = &dri2_surf->color_buffers[i];
d315 1
a315 1
	    dri2_surf->back = &dri2_surf->color_buffers[i];
d334 14
a352 3
   dri2_surf->back->name = name;
   dri2_surf->back->pitch = pitch;

a357 4

   dri2_surf->back->locked = 1;

   return 0;
d383 2
a384 5
static __DRIbuffer *
dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
			     int *width, int *height,
			     unsigned int *attachments, int count,
			     int *out_count, void *loaderPrivate)
a385 1
   struct dri2_egl_surface *dri2_surf = loaderPrivate;
d388 1
a388 1
   int i, j;
d394 1
a394 1
      dri2_release_buffers(dri2_surf);
d402 3
a404 16
   for (i = 0, j = 0; i < 2 * count; i += 2, j++) {
      switch (attachments[i]) {
      case __DRI_BUFFER_BACK_LEFT:
	 if (get_back_bo(dri2_surf, &dri2_surf->buffers[j]) < 0) {
	    _eglError(EGL_BAD_ALLOC, "failed to allocate color buffer");
	    return NULL;
	 }
	 break;
      default:
	 if (get_aux_bo(dri2_surf, attachments[i], attachments[i + 1],
			&dri2_surf->buffers[j]) < 0) {
	    _eglError(EGL_BAD_ALLOC, "failed to allocate aux buffer");
	    return NULL;
	 }
	 break;
      }
d420 30
d461 4
a464 4
dri2_get_buffers(__DRIdrawable * driDrawable,
		 int *width, int *height,
		 unsigned int *attachments, int count,
		 int *out_count, void *loaderPrivate)
d483 4
a486 4
      dri2_get_buffers_with_format(driDrawable,
				   width, height,
				   attachments_with_format, count,
				   out_count, loaderPrivate);
d493 19
d513 1
a513 1
dri2_flush_front_buffer(__DRIdrawable * driDrawable, void *loaderPrivate)
d519 7
d527 3
a529 1
wayland_frame_callback(void *data, struct wl_callback *callback, uint32_t time)
d533 1
a533 1
   dri2_surf->frame_callback = NULL;
d537 2
a538 2
static const struct wl_callback_listener frame_listener = {
	wayland_frame_callback
d546 1
a546 1
   int fd;
d554 2
d563 1
a563 1
                                    0, dri2_surf->current->pitch,
d568 5
d575 1
a575 1
                              dri2_surf->current->name,
d578 1
a578 1
                              dri2_surf->current->pitch,
d592 5
a596 5
dri2_swap_buffers_with_damage(_EGLDriver *drv,
                              _EGLDisplay *disp,
                              _EGLSurface *draw,
                              const EGLint *rects,
                              EGLint n_rects)
d600 3
a602 13
   __DRIbuffer buffer;
   int i, ret = 0;

   while (dri2_surf->frame_callback && ret != -1)
      ret = wl_display_dispatch_queue(dri2_dpy->wl_dpy, dri2_dpy->wl_queue);
   if (ret < 0)
      return EGL_FALSE;

   dri2_surf->frame_callback = wl_surface_frame(dri2_surf->wl_win->surface);
   wl_callback_add_listener(dri2_surf->frame_callback,
                            &frame_listener, dri2_surf);
   wl_proxy_set_queue((struct wl_proxy *) dri2_surf->frame_callback,
                      dri2_dpy->wl_queue);
d610 1
a610 1
   if (get_back_bo(dri2_surf, &buffer) < 0) {
d615 9
d641 2
a642 2
      wl_surface_damage(dri2_surf->wl_win->surface, 0, 0,
                        dri2_surf->base.Width, dri2_surf->base.Height);
d653 13
d668 13
a680 2
   (*dri2_dpy->flush->flush)(dri2_surf->dri_drawable);
   (*dri2_dpy->flush->invalidate)(dri2_surf->dri_drawable);
d686 2
a687 2
dri2_query_buffer_age(_EGLDriver *drv,
                      _EGLDisplay *disp, _EGLSurface *surface)
a689 1
   __DRIbuffer buffer;
d691 1
a691 1
   if (get_back_bo(dri2_surf, &buffer) < 0) {
d700 9
a708 1
dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
d710 68
a777 1
   return dri2_swap_buffers_with_damage (drv, disp, draw, NULL, 0);
d781 1
a781 1
dri2_wayland_authenticate(_EGLDisplay *disp, uint32_t id)
a800 25
/**
 * Called via eglTerminate(), drv->API.Terminate().
 */
static EGLBoolean
dri2_terminate(_EGLDriver *drv, _EGLDisplay *disp)
{
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);

   _eglReleaseDisplayResources(drv, disp);
   _eglCleanupDisplay(disp);

   dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);
   close(dri2_dpy->fd);
   dlclose(dri2_dpy->driver);
   free(dri2_dpy->driver_name);
   free(dri2_dpy->device_name);
   wl_drm_destroy(dri2_dpy->wl_drm);
   if (dri2_dpy->own_device)
      wl_display_disconnect(dri2_dpy->wl_dpy);
   free(dri2_dpy);
   disp->DriverData = NULL;

   return EGL_TRUE;
}

d843 3
d898 71
d979 1
d981 1
a981 6
   drv->API.CreateWindowSurface = dri2_create_window_surface;
   drv->API.DestroySurface = dri2_destroy_surface;
   drv->API.SwapBuffers = dri2_swap_buffers;
   drv->API.SwapBuffersWithDamageEXT = dri2_swap_buffers_with_damage;
   drv->API.Terminate = dri2_terminate;
   drv->API.QueryBufferAge = dri2_query_buffer_age;
d1016 1
a1016 1
   dri2_dpy->driver_name = dri2_get_driver_for_fd(dri2_dpy->fd);
d1027 2
a1028 2
   dri2_dpy->dri2_loader_extension.getBuffers = dri2_get_buffers;
   dri2_dpy->dri2_loader_extension.flushFrontBuffer = dri2_flush_front_buffer;
d1030 2
a1031 2
      dri2_get_buffers_with_format;
      
d1033 6
a1038 3
   dri2_dpy->extensions[1] = &image_lookup_extension.base;
   dri2_dpy->extensions[2] = &use_invalidate.base;
   dri2_dpy->extensions[3] = NULL;
d1043 2
d1052 1
a1052 1
      dri2_dpy->capabilities &= WL_DRM_CAPABILITY_PRIME;
d1058 1
a1058 1
	 dri2_add_config(disp, config, i + 1, 0, types, NULL, rgb_masks);
d1060 3
a1062 1
	 dri2_add_config(disp, config, i + 1, 0, types, NULL, argb_masks);
d1066 1
a1067 1
   dri2_dpy->authenticate = dri2_wayland_authenticate;
d1074 5
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d2 1
a2 1
 * Copyright © 2011 Intel Corporation
d43 5
d49 1
a49 1
sync_callback(void *data)
d54 1
d57 6
a62 2
static void
force_roundtrip(struct wl_display *display)
d64 8
a71 1
   int done = 0;
d73 4
a76 4
   wl_display_sync_callback(display, sync_callback, &done);
   wl_display_iterate(display, WL_DISPLAY_WRITABLE);
   while (!done)
      wl_display_iterate(display, WL_DISPLAY_READABLE);
d85 2
a86 2
   for (i = 0; i < WL_BUFFER_COUNT; ++i)
      if (dri2_surf->wl_drm_buffer[i] == buffer)
d89 2
a90 4
   assert(i <= WL_BUFFER_COUNT);

   /* not found? */
   if (i == WL_BUFFER_COUNT)
d92 1
d94 1
a94 2
   dri2_surf->wl_buffer_lock[i] = 0;

d101 10
a121 2
   struct dri2_egl_buffer *dri2_buf;
   int i;
d131 1
d135 4
a138 11
   for (i = 0; i < WL_BUFFER_COUNT; ++i) {
      dri2_surf->wl_drm_buffer[i] = NULL;
      dri2_surf->wl_buffer_lock[i] = 0;
   }

   for (i = 0; i < __DRI_BUFFER_COUNT; ++i)
      dri2_surf->dri_buffers[i] = NULL;

   dri2_surf->pending_buffer = NULL;
   dri2_surf->third_buffer = NULL;
   dri2_surf->block_swap_buffers = EGL_FALSE;
d143 3
a145 1
      dri2_surf->type = DRI2_WINDOW_SURFACE;
a149 12
   case EGL_PIXMAP_BIT:
      dri2_surf->wl_pix = (struct wl_egl_pixmap *) window;
      dri2_surf->type = DRI2_PIXMAP_SURFACE;

      dri2_surf->base.Width  = dri2_surf->wl_pix->width;
      dri2_surf->base.Height = dri2_surf->wl_pix->height;

      if (dri2_surf->wl_pix->driver_private) {
         dri2_buf = dri2_surf->wl_pix->driver_private;
         dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT] = dri2_buf->dri_buffer;
      }
      break;
a186 9
static _EGLSurface *
dri2_create_pixmap_surface(_EGLDriver *drv, _EGLDisplay *disp,
			   _EGLConfig *conf, EGLNativePixmapType pixmap,
			   const EGLint *attrib_list)
{
   return dri2_create_surface(drv, disp, EGL_PIXMAP_BIT, conf,
			      pixmap, attrib_list);
}

d204 10
a213 7
   for (i = 0; i < WL_BUFFER_COUNT; ++i)
      if (dri2_surf->wl_drm_buffer[i])
         wl_buffer_destroy(dri2_surf->wl_drm_buffer[i]);

   for (i = 0; i < __DRI_BUFFER_COUNT; ++i)
      if (dri2_surf->dri_buffers[i] && !(i == __DRI_BUFFER_FRONT_LEFT &&
          dri2_surf->type == DRI2_PIXMAP_SURFACE))
d217 6
a222 3
   if (dri2_surf->third_buffer) {
      dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
                                    dri2_surf->third_buffer);
d231 1
a231 19
dri2_wl_egl_pixmap_destroy(struct wl_egl_pixmap *egl_pixmap)
{
   struct dri2_egl_buffer *dri2_buf = egl_pixmap->driver_private;

   assert(dri2_buf);

   dri2_buf->dri2_dpy->dri2->releaseBuffer(dri2_buf->dri2_dpy->dri_screen,
                                           dri2_buf->dri_buffer);

   free(dri2_buf);
   
   egl_pixmap->driver_private = NULL;
   egl_pixmap->destroy = NULL;
}

static struct wl_buffer *
wayland_create_buffer(struct dri2_egl_surface *dri2_surf,
                      __DRIbuffer *buffer,
                      struct wl_visual *visual)
d235 1
a235 1
   struct wl_buffer *buf;
d237 11
a247 4
   buf = wl_drm_create_buffer(dri2_dpy->wl_drm, buffer->name,
                              dri2_surf->base.Width, dri2_surf->base.Height,
                              buffer->pitch, visual);
   wl_buffer_add_listener(buf, &wl_buffer_listener, dri2_surf);
d249 5
a253 1
   return buf;
d256 2
a257 2
static void
dri2_process_back_buffer(struct dri2_egl_surface *dri2_surf, unsigned format)
d261 2
d264 2
a265 1
   (void) format;
d267 11
a277 12
   switch (dri2_surf->type) {
   case DRI2_WINDOW_SURFACE:
      /* allocate a front buffer for our double-buffered window*/
      if (dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT] != NULL)
         break;
      dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT] = 
         dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen,
               __DRI_BUFFER_FRONT_LEFT, format,
               dri2_surf->base.Width, dri2_surf->base.Height);
      break;
   default:
      break;
a278 1
}
d280 28
a307 6
static void
dri2_process_front_buffer(struct dri2_egl_surface *dri2_surf, unsigned format)
{
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);
   struct dri2_egl_buffer *dri2_buf;
d309 1
a309 5
   switch (dri2_surf->type) {
   case DRI2_PIXMAP_SURFACE:
      dri2_buf = malloc(sizeof *dri2_buf);
      if (!dri2_buf)
         return;
d311 1
a311 9
      dri2_buf->dri_buffer = dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT];
      dri2_buf->dri2_dpy   = dri2_dpy;

      dri2_surf->wl_pix->driver_private = dri2_buf;
      dri2_surf->wl_pix->destroy        = dri2_wl_egl_pixmap_destroy;
      break;
   default:
      break;
   }
d314 3
a316 18
static void
dri2_release_pending_buffer(void *data)
{
   struct dri2_egl_surface *dri2_surf = data;
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);

   /* FIXME: print internal error */
   if (!dri2_surf->pending_buffer)
      return;
   
   dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
                                 dri2_surf->pending_buffer);
   dri2_surf->pending_buffer = NULL;
}

static void
dri2_release_buffers(struct dri2_egl_surface *dri2_surf)
d320 1
a320 1
   int i;
d322 6
a327 23
   if (dri2_surf->third_buffer) {
      dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
                                    dri2_surf->third_buffer);
      dri2_surf->third_buffer = NULL;
   }

   for (i = 0; i < __DRI_BUFFER_COUNT; ++i) {
      if (dri2_surf->dri_buffers[i]) {
         switch (i) {
         case __DRI_BUFFER_FRONT_LEFT:
            if (dri2_surf->pending_buffer)
               force_roundtrip(dri2_dpy->wl_dpy);
            dri2_surf->pending_buffer = dri2_surf->dri_buffers[i];
            wl_display_sync_callback(dri2_dpy->wl_dpy,
                                     dri2_release_pending_buffer, dri2_surf);
            break;
         default:
            dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
                                          dri2_surf->dri_buffers[i]);
            break;
         }
         dri2_surf->dri_buffers[i] = NULL;
      }
d329 2
a330 48
}

static inline void
pointer_swap(const void **p1, const void **p2)
{
   const void *tmp = *p1;
   *p1 = *p2;
   *p2 = tmp;
}

static void
destroy_third_buffer(struct dri2_egl_surface *dri2_surf)
{
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);

   if (dri2_surf->third_buffer == NULL)
      return;

   dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
                                 dri2_surf->third_buffer);
   dri2_surf->third_buffer = NULL;

   if (dri2_surf->wl_drm_buffer[WL_BUFFER_THIRD])
      wl_buffer_destroy(dri2_surf->wl_drm_buffer[WL_BUFFER_THIRD]);
   dri2_surf->wl_drm_buffer[WL_BUFFER_THIRD] = NULL;
   dri2_surf->wl_buffer_lock[WL_BUFFER_THIRD] = 0;
}

static void
swap_wl_buffers(struct dri2_egl_surface *dri2_surf,
                enum wayland_buffer_type a, enum wayland_buffer_type b)
{
   int tmp;

   tmp = dri2_surf->wl_buffer_lock[a];
   dri2_surf->wl_buffer_lock[a] = dri2_surf->wl_buffer_lock[b];
   dri2_surf->wl_buffer_lock[b] = tmp;
      
   pointer_swap((const void **) &dri2_surf->wl_drm_buffer[a],
                (const void **) &dri2_surf->wl_drm_buffer[b]);
}

static void
swap_back_and_third(struct dri2_egl_surface *dri2_surf)
{
   if (dri2_surf->wl_buffer_lock[WL_BUFFER_THIRD])
      destroy_third_buffer(dri2_surf);
d332 1
a332 2
   pointer_swap((const void **) &dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT],
                (const void **) &dri2_surf->third_buffer);
d334 1
a334 18
   swap_wl_buffers(dri2_surf, WL_BUFFER_BACK, WL_BUFFER_THIRD);
}

static void
dri2_prior_buffer_creation(struct dri2_egl_surface *dri2_surf,
                           unsigned int type)
{
   switch (type) {
   case __DRI_BUFFER_BACK_LEFT:
         if (dri2_surf->wl_buffer_lock[WL_BUFFER_BACK])
            swap_back_and_third(dri2_surf);
         else if (dri2_surf->third_buffer)
            destroy_third_buffer(dri2_surf);
         break;
   default:
         break;

   }
d346 1
a346 1
   int i;
d348 1
a348 1
   if (dri2_surf->type == DRI2_WINDOW_SURFACE &&
d358 1
d360 15
a374 5
      for (i = 0; i < WL_BUFFER_COUNT; ++i) {
         if (dri2_surf->wl_drm_buffer[i])
            wl_buffer_destroy(dri2_surf->wl_drm_buffer[i]);
         dri2_surf->wl_drm_buffer[i]  = NULL;
         dri2_surf->wl_buffer_lock[i] = 0;
d378 10
a387 21
   dri2_surf->buffer_count = 0;
   for (i = 0; i < 2*count; i+=2) {
      assert(attachments[i] < __DRI_BUFFER_COUNT);
      assert(dri2_surf->buffer_count < 5);

      dri2_prior_buffer_creation(dri2_surf, attachments[i]);

      if (dri2_surf->dri_buffers[attachments[i]] == NULL) {

         dri2_surf->dri_buffers[attachments[i]] =
            dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen,
                  attachments[i], attachments[i+1],
                  dri2_surf->base.Width, dri2_surf->base.Height);

         if (!dri2_surf->dri_buffers[attachments[i]]) 
            continue;

         if (attachments[i] == __DRI_BUFFER_FRONT_LEFT)
            dri2_process_front_buffer(dri2_surf, attachments[i+1]);
         else if (attachments[i] == __DRI_BUFFER_BACK_LEFT)
            dri2_process_back_buffer(dri2_surf, attachments[i+1]);
a388 6

      memcpy(&dri2_surf->buffers[dri2_surf->buffer_count],
             dri2_surf->dri_buffers[attachments[i]],
             sizeof(__DRIbuffer));

      dri2_surf->buffer_count++;
d391 2
a392 11
   assert(dri2_surf->type == DRI2_PIXMAP_SURFACE ||
          dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]);

   if (dri2_surf->type == DRI2_PIXMAP_SURFACE && !dri2_surf->wl_pix->buffer)
      dri2_surf->wl_pix->buffer =
         wayland_create_buffer(dri2_surf,
			       dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT],
			       dri2_surf->wl_pix->visual);

   *out_count = dri2_surf->buffer_count;
   if (dri2_surf->buffer_count == 0)
a433 1

d438 2
d441 4
a444 1
   /* FIXME: Does EGL support front buffer rendering at all? */
d446 3
a448 2
#if 0
   struct dri2_egl_surface *dri2_surf = loaderPrivate;
d450 3
a452 5
   dri2WaitGL(dri2_surf);
#else
   (void) loaderPrivate;
#endif
}
d455 1
a455 1
wayland_frame_callback(struct wl_surface *surface, void *data, uint32_t time)
d457 30
a486 1
   struct dri2_egl_surface *dri2_surf = data;
d488 4
a491 1
   dri2_surf->block_swap_buffers = EGL_FALSE;
d498 5
a502 1
dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
d506 2
a507 1
   struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);
d509 37
a545 38
   while (dri2_surf->block_swap_buffers)
      wl_display_iterate(dri2_dpy->wl_dpy, WL_DISPLAY_READABLE);

   dri2_surf->block_swap_buffers = EGL_TRUE;
   wl_display_frame_callback(dri2_dpy->wl_dpy,
                             dri2_surf->wl_win->surface,
                             wayland_frame_callback, dri2_surf);

   if (dri2_surf->type == DRI2_WINDOW_SURFACE) {
      pointer_swap(
	    (const void **) &dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT],
	    (const void **) &dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]);

      dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT]->attachment = 
	 __DRI_BUFFER_FRONT_LEFT;
      dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]->attachment = 
	 __DRI_BUFFER_BACK_LEFT;

      swap_wl_buffers(dri2_surf, WL_BUFFER_FRONT, WL_BUFFER_BACK);

      if (!dri2_surf->wl_drm_buffer[WL_BUFFER_FRONT])
	 dri2_surf->wl_drm_buffer[WL_BUFFER_FRONT] =
	    wayland_create_buffer(dri2_surf,
		  dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT],
		  dri2_surf->wl_win->visual);

      wl_buffer_damage(dri2_surf->wl_drm_buffer[WL_BUFFER_FRONT], 0, 0,
		       dri2_surf->base.Width, dri2_surf->base.Height);
      wl_surface_attach(dri2_surf->wl_win->surface,
	    dri2_surf->wl_drm_buffer[WL_BUFFER_FRONT],
	    dri2_surf->dx, dri2_surf->dy);
      dri2_surf->wl_buffer_lock[WL_BUFFER_FRONT] = 1;

      dri2_surf->wl_win->attached_width  = dri2_surf->base.Width;
      dri2_surf->wl_win->attached_height = dri2_surf->base.Height;
      /* reset resize growing parameters */
      dri2_surf->dx = 0;
      dri2_surf->dy = 0;
d547 1
d549 9
a557 1
	    dri2_surf->base.Width, dri2_surf->base.Height);
d560 1
a560 6
   _EGLContext *ctx;
   if (dri2_drv->glFlush) {
      ctx = _eglGetCurrentContext();
      if (ctx && ctx->DrawSurface == &dri2_surf->base)
         dri2_drv->glFlush();
   }
d568 3
a570 6
/**
 * Called via eglCreateImageKHR(), drv->API.CreateImageKHR().
 */
static _EGLImage *
dri2_create_image_khr_pixmap(_EGLDisplay *disp, _EGLContext *ctx,
			     EGLClientBuffer buffer, const EGLint *attr_list)
d572 2
a573 47
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct wl_egl_pixmap *wl_egl_pixmap = (struct wl_egl_pixmap *) buffer;
   struct dri2_egl_buffer *dri2_buf;
   EGLint wl_attr_list[] = {
		EGL_WIDTH,		0,
		EGL_HEIGHT,		0,
		EGL_DRM_BUFFER_STRIDE_MESA,	0,
		EGL_DRM_BUFFER_FORMAT_MESA,	EGL_DRM_BUFFER_FORMAT_ARGB32_MESA,
		EGL_NONE
   };

   dri2_buf = malloc(sizeof *dri2_buf);
   if (!dri2_buf)
           return NULL;

   dri2_buf->dri2_dpy = dri2_dpy;
   dri2_buf->dri_buffer =
      dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen,
				     __DRI_BUFFER_FRONT_LEFT, 32,
				     wl_egl_pixmap->width,
				     wl_egl_pixmap->height);

   wl_egl_pixmap->destroy = dri2_wl_egl_pixmap_destroy;
   wl_egl_pixmap->driver_private = dri2_buf;

   wl_egl_pixmap->buffer =
      wl_drm_create_buffer(dri2_dpy->wl_drm,
			   dri2_buf->dri_buffer->name,
			   wl_egl_pixmap->width,
			   wl_egl_pixmap->height,
			   dri2_buf->dri_buffer->pitch,
			   wl_egl_pixmap->visual);

   wl_attr_list[1] = wl_egl_pixmap->width;
   wl_attr_list[3] = wl_egl_pixmap->height;
   wl_attr_list[5] = dri2_buf->dri_buffer->pitch / 4;

   return dri2_create_image_khr(disp->Driver, disp, ctx, EGL_DRM_BUFFER_MESA,
	(EGLClientBuffer)(intptr_t) dri2_buf->dri_buffer->name, wl_attr_list);
}

static _EGLImage *
dri2_wayland_create_image_khr(_EGLDriver *drv, _EGLDisplay *disp,
			      _EGLContext *ctx, EGLenum target,
			      EGLClientBuffer buffer, const EGLint *attr_list)
{
   (void) drv;
d575 3
a577 5
   switch (target) {
   case EGL_NATIVE_PIXMAP_KHR:
      return dri2_create_image_khr_pixmap(disp, ctx, buffer, attr_list);
   default:
      return dri2_create_image_khr(drv, disp, ctx, target, buffer, attr_list);
d579 8
d598 2
a599 1
   force_roundtrip(dri2_dpy->wl_dpy);
d625 4
d645 10
a654 1
   dri2_dpy->fd = open(dri2_dpy->device_name, O_RDWR);
d666 23
d698 29
a726 1
	drm_handle_authenticated
d733 2
a734 1
   uint32_t id;
d736 3
a740 1
   drv->API.CreatePixmapSurface = dri2_create_pixmap_surface;
d743 1
a743 1
   drv->API.CreateImageKHR = dri2_wayland_create_image_khr;
d745 1
d747 1
a747 1
   dri2_dpy = malloc(sizeof *dri2_dpy);
a750 2
   memset(dri2_dpy, 0, sizeof *dri2_dpy);

d756 1
d761 11
a771 5
   id = wl_display_get_global(dri2_dpy->wl_dpy, "wl_drm", 1);
   if (id == 0)
      force_roundtrip(dri2_dpy->wl_dpy);
   id = wl_display_get_global(dri2_dpy->wl_dpy, "wl_drm", 1);
   if (id == 0)
d773 2
a774 6
   dri2_dpy->wl_drm = wl_drm_create(dri2_dpy->wl_dpy, id, 1);
   if (!dri2_dpy->wl_drm)
      goto cleanup_dpy;
   wl_drm_add_listener(dri2_dpy->wl_drm, &drm_listener, dri2_dpy);
   force_roundtrip(dri2_dpy->wl_dpy);
   if (dri2_dpy->fd == -1)
d777 1
a777 2
   force_roundtrip(dri2_dpy->wl_dpy);
   if (!dri2_dpy->authenticated)
d804 17
a820 6
   for (i = 0; dri2_dpy->driver_configs[i]; i++)
      dri2_add_config(disp, dri2_dpy->driver_configs[i], i + 1, 0,
		      EGL_WINDOW_BIT | EGL_PIXMAP_BIT, NULL);


   disp->Extensions.KHR_image_pixmap = EGL_TRUE;
d823 1
d825 2
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d2 1
a2 1
 * Copyright © 2011-2012 Intel Corporation
a42 5
enum wl_drm_format_flags {
   HAS_ARGB8888 = 1,
   HAS_XRGB8888 = 2
};

d44 1
a44 1
sync_callback(void *data, struct wl_callback *callback, uint32_t serial)
a48 1
   wl_callback_destroy(callback);
d51 2
a52 6
static const struct wl_callback_listener sync_listener = {
   sync_callback
};

static int
roundtrip(struct dri2_egl_display *dri2_dpy)
d54 1
a54 8
   struct wl_callback *callback;
   int done = 0, ret = 0;

   callback = wl_display_sync(dri2_dpy->wl_dpy);
   wl_callback_add_listener(callback, &sync_listener, &done);
   wl_proxy_set_queue((struct wl_proxy *) callback, dri2_dpy->wl_queue);
   while (ret != -1 && !done)
      ret = wl_display_dispatch_queue(dri2_dpy->wl_dpy, dri2_dpy->wl_queue);
d56 4
a59 4
   if (!done)
      wl_callback_destroy(callback);

   return ret;
d68 2
a69 2
   for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); ++i)
      if (dri2_surf->color_buffers[i].wl_buffer == buffer)
d72 4
a75 2
   if (i == ARRAY_SIZE(dri2_surf->color_buffers)) {
      wl_buffer_destroy(buffer);
a76 1
   }
d78 2
a79 1
   dri2_surf->color_buffers[i].locked = 0;
a85 10
static void
resize_callback(struct wl_egl_window *wl_win, void *data)
{
   struct dri2_egl_surface *dri2_surf = data;
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);

   (*dri2_dpy->flush->invalidate)(dri2_surf->dri_drawable);
}

d97 2
a107 1
   memset(dri2_surf, 0, sizeof *dri2_surf);
d111 11
a121 4
   if (conf->AlphaSize == 0)
      dri2_surf->format = WL_DRM_FORMAT_XRGB8888;
   else
      dri2_surf->format = WL_DRM_FORMAT_ARGB8888;
d126 1
a126 3

      dri2_surf->wl_win->private = dri2_surf;
      dri2_surf->wl_win->resize_callback = resize_callback;
d131 12
d180 9
d206 7
a212 10
   for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++) {
      if (dri2_surf->color_buffers[i].wl_buffer)
         wl_buffer_destroy(dri2_surf->color_buffers[i].wl_buffer);
      if (dri2_surf->color_buffers[i].dri_image)
         dri2_dpy->image->destroyImage(dri2_surf->color_buffers[i].dri_image);
   }

   for (i = 0; i < __DRI_BUFFER_COUNT; i++)
      if (dri2_surf->dri_buffers[i] &&
          dri2_surf->dri_buffers[i]->attachment != __DRI_BUFFER_BACK_LEFT)
d216 3
a218 6
   if (dri2_surf->frame_callback)
      wl_callback_destroy(dri2_surf->frame_callback);

   if (dri2_surf->base.Type == EGL_WINDOW_BIT) {
      dri2_surf->wl_win->private = NULL;
      dri2_surf->wl_win->resize_callback = NULL;
d227 19
a245 1
dri2_release_buffers(struct dri2_egl_surface *dri2_surf)
d249 1
a249 1
   int i;
d251 4
a254 11
   for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++) {
      if (dri2_surf->color_buffers[i].wl_buffer &&
          !dri2_surf->color_buffers[i].locked)
         wl_buffer_destroy(dri2_surf->color_buffers[i].wl_buffer);
      if (dri2_surf->color_buffers[i].dri_image)
         dri2_dpy->image->destroyImage(dri2_surf->color_buffers[i].dri_image);

      dri2_surf->color_buffers[i].wl_buffer = NULL;
      dri2_surf->color_buffers[i].dri_image = NULL;
      dri2_surf->color_buffers[i].locked = 0;
   }
d256 1
a256 5
   for (i = 0; i < __DRI_BUFFER_COUNT; i++)
      if (dri2_surf->dri_buffers[i] &&
          dri2_surf->dri_buffers[i]->attachment != __DRI_BUFFER_BACK_LEFT)
         dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
                                       dri2_surf->dri_buffers[i]);
d259 2
a260 2
static int
get_back_bo(struct dri2_egl_surface *dri2_surf, __DRIbuffer *buffer)
a263 2
   __DRIimage *image;
   int i, name, pitch;
d265 1
a265 2
   /* There might be a buffer release already queued that wasn't processed */
   wl_display_dispatch_queue_pending(dri2_dpy->wl_dpy, dri2_dpy->wl_queue);
d267 12
a278 11
   if (dri2_surf->back == NULL) {
      for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++) {
         /* Get an unlocked buffer, preferrably one with a dri_buffer already
          * allocated. */
	 if (dri2_surf->color_buffers[i].locked)
            continue;
         if (dri2_surf->back == NULL)
	    dri2_surf->back = &dri2_surf->color_buffers[i];
         else if (dri2_surf->back->dri_image == NULL)
	    dri2_surf->back = &dri2_surf->color_buffers[i];
      }
d280 1
d282 6
a287 28
   if (dri2_surf->back == NULL)
      return -1;
   if (dri2_surf->back->dri_image == NULL) {
      dri2_surf->back->dri_image = 
         dri2_dpy->image->createImage(dri2_dpy->dri_screen,
                                      dri2_surf->base.Width,
                                      dri2_surf->base.Height,
                                      __DRI_IMAGE_FORMAT_ARGB8888,
                                      __DRI_IMAGE_USE_SHARE,
                                      NULL);
      dri2_surf->back->age = 0;
   }
   if (dri2_surf->back->dri_image == NULL)
      return -1;

   image = dri2_surf->back->dri_image;

   dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_NAME, &name);
   dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_STRIDE, &pitch);

   dri2_surf->back->name = name;
   dri2_surf->back->pitch = pitch;

   buffer->attachment = __DRI_BUFFER_BACK_LEFT;
   buffer->name = name;
   buffer->pitch = pitch;
   buffer->cpp = 4;
   buffer->flags = 0;
d289 5
a293 1
   dri2_surf->back->locked = 1;
d295 25
a319 1
   return 0;
d322 2
a323 3
static int
get_aux_bo(struct dri2_egl_surface *dri2_surf,
	   unsigned int attachment, unsigned int format, __DRIbuffer *buffer)
d327 1
a327 1
   __DRIbuffer *b = dri2_surf->dri_buffers[attachment];
d329 23
a351 6
   if (b == NULL) {
      b = dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen,
					 attachment, format,
					 dri2_surf->base.Width,
					 dri2_surf->base.Height);
      dri2_surf->dri_buffers[attachment] = b;
d353 48
a400 2
   if (b == NULL)
      return -1;
d402 2
a403 1
   memcpy(buffer, b, sizeof *buffer);
d405 18
a422 1
   return 0;
d434 1
a434 1
   int i, j;
d436 1
a436 1
   if (dri2_surf->base.Type == EGL_WINDOW_BIT &&
a445 1
   }
d447 5
a451 15
   for (i = 0, j = 0; i < 2 * count; i += 2, j++) {
      switch (attachments[i]) {
      case __DRI_BUFFER_BACK_LEFT:
	 if (get_back_bo(dri2_surf, &dri2_surf->buffers[j]) < 0) {
	    _eglError(EGL_BAD_ALLOC, "failed to allocate color buffer");
	    return NULL;
	 }
	 break;
      default:
	 if (get_aux_bo(dri2_surf, attachments[i], attachments[i + 1],
			&dri2_surf->buffers[j]) < 0) {
	    _eglError(EGL_BAD_ALLOC, "failed to allocate aux buffer");
	    return NULL;
	 }
	 break;
d455 21
a475 10
   /* If we have an extra unlocked buffer at this point, we had to do triple
    * buffering for a while, but now can go back to just double buffering.
    * That means we can free any unlocked buffer now. */
   for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++) {
      if (!dri2_surf->color_buffers[i].locked &&
          dri2_surf->color_buffers[i].wl_buffer) {
         wl_buffer_destroy(dri2_surf->color_buffers[i].wl_buffer);
         dri2_dpy->image->destroyImage(dri2_surf->color_buffers[i].dri_image);
         dri2_surf->color_buffers[i].wl_buffer = NULL;
         dri2_surf->color_buffers[i].dri_image = NULL;
d477 6
d485 11
a495 2
   *out_count = j;
   if (j == 0)
d537 1
d542 8
d551 1
d555 1
a555 1
wayland_frame_callback(void *data, struct wl_callback *callback, uint32_t time)
d559 1
a559 46
   dri2_surf->frame_callback = NULL;
   wl_callback_destroy(callback);
}

static const struct wl_callback_listener frame_listener = {
	wayland_frame_callback
};

static void
create_wl_buffer(struct dri2_egl_surface *dri2_surf)
{
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);
   int fd;

   if (dri2_surf->current->wl_buffer != NULL)
      return;

   if (dri2_dpy->capabilities & WL_DRM_CAPABILITY_PRIME) {
      dri2_dpy->image->queryImage(dri2_surf->current->dri_image,
                                  __DRI_IMAGE_ATTRIB_FD, &fd);

      dri2_surf->current->wl_buffer =
         wl_drm_create_prime_buffer(dri2_dpy->wl_drm,
                                    fd,
                                    dri2_surf->base.Width,
                                    dri2_surf->base.Height,
                                    dri2_surf->format,
                                    0, dri2_surf->current->pitch,
                                    0, 0,
                                    0, 0);
      close(fd);
   } else {
      dri2_surf->current->wl_buffer =
         wl_drm_create_buffer(dri2_dpy->wl_drm,
                              dri2_surf->current->name,
                              dri2_surf->base.Width,
                              dri2_surf->base.Height,
                              dri2_surf->current->pitch,
                              dri2_surf->format);
   }

   wl_proxy_set_queue((struct wl_proxy *) dri2_surf->current->wl_buffer,
                      dri2_dpy->wl_queue);
   wl_buffer_add_listener(dri2_surf->current->wl_buffer,
                          &wl_buffer_listener, dri2_surf);
d566 1
a566 5
dri2_swap_buffers_with_damage(_EGLDriver *drv,
                              _EGLDisplay *disp,
                              _EGLSurface *draw,
                              const EGLint *rects,
                              EGLint n_rects)
d570 1
a570 2
   __DRIbuffer buffer;
   int i, ret = 0;
d572 38
a609 37
   while (dri2_surf->frame_callback && ret != -1)
      ret = wl_display_dispatch_queue(dri2_dpy->wl_dpy, dri2_dpy->wl_queue);
   if (ret < 0)
      return EGL_FALSE;

   dri2_surf->frame_callback = wl_surface_frame(dri2_surf->wl_win->surface);
   wl_callback_add_listener(dri2_surf->frame_callback,
                            &frame_listener, dri2_surf);
   wl_proxy_set_queue((struct wl_proxy *) dri2_surf->frame_callback,
                      dri2_dpy->wl_queue);

   for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++)
      if (dri2_surf->color_buffers[i].age > 0)
         dri2_surf->color_buffers[i].age++;

   /* Make sure we have a back buffer in case we're swapping without ever
    * rendering. */
   if (get_back_bo(dri2_surf, &buffer) < 0) {
      _eglError(EGL_BAD_ALLOC, "dri2_swap_buffers");
      return EGL_FALSE;
   }

   dri2_surf->back->age = 1;
   dri2_surf->current = dri2_surf->back;
   dri2_surf->back = NULL;

   create_wl_buffer(dri2_surf);

   wl_surface_attach(dri2_surf->wl_win->surface,
                     dri2_surf->current->wl_buffer,
                     dri2_surf->dx, dri2_surf->dy);

   dri2_surf->wl_win->attached_width  = dri2_surf->base.Width;
   dri2_surf->wl_win->attached_height = dri2_surf->base.Height;
   /* reset resize growing parameters */
   dri2_surf->dx = 0;
   dri2_surf->dy = 0;
a610 1
   if (n_rects == 0) {
d612 1
a612 9
                        dri2_surf->base.Width, dri2_surf->base.Height);
   } else {
      for (i = 0; i < n_rects; i++) {
         const int *rect = &rects[i * 4];
         wl_surface_damage(dri2_surf->wl_win->surface,
                           rect[0],
                           dri2_surf->base.Height - rect[1] - rect[3],
                           rect[2], rect[3]);
      }
d615 6
a620 1
   wl_surface_commit(dri2_surf->wl_win->surface);
d628 6
a633 3
static EGLint
dri2_query_buffer_age(_EGLDriver *drv,
                      _EGLDisplay *disp, _EGLSurface *surface)
d635 47
a681 2
   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surface);
   __DRIbuffer buffer;
d683 5
a687 3
   if (get_back_bo(dri2_surf, &buffer) < 0) {
      _eglError(EGL_BAD_ALLOC, "dri2_query_buffer_age");
      return 0;
a688 8

   return dri2_surf->back->age;
}

static EGLBoolean
dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
{
   return dri2_swap_buffers_with_damage (drv, disp, draw, NULL, 0);
d700 1
a700 2
   if (roundtrip(dri2_dpy) < 0)
      ret = -1;
a725 4
   free(dri2_dpy->device_name);
   wl_drm_destroy(dri2_dpy->wl_drm);
   if (dri2_dpy->own_device)
      wl_display_disconnect(dri2_dpy->wl_dpy);
d742 1
a742 10
#ifdef O_CLOEXEC
   dri2_dpy->fd = open(dri2_dpy->device_name, O_RDWR | O_CLOEXEC);
   if (dri2_dpy->fd == -1 && errno == EINVAL)
#endif
   {
      dri2_dpy->fd = open(dri2_dpy->device_name, O_RDWR);
      if (dri2_dpy->fd != -1)
         fcntl(dri2_dpy->fd, F_SETFD, fcntl(dri2_dpy->fd, F_GETFD) |
            FD_CLOEXEC);
   }
a753 23
drm_handle_format(void *data, struct wl_drm *drm, uint32_t format)
{
   struct dri2_egl_display *dri2_dpy = data;

   switch (format) {
   case WL_DRM_FORMAT_ARGB8888:
      dri2_dpy->formats |= HAS_ARGB8888;
      break;
   case WL_DRM_FORMAT_XRGB8888:
      dri2_dpy->formats |= HAS_XRGB8888;
      break;
   }
}

static void
drm_handle_capabilities(void *data, struct wl_drm *drm, uint32_t value)
{
   struct dri2_egl_display *dri2_dpy = data;

   dri2_dpy->capabilities = value;
}

static void
d763 1
a763 29
	drm_handle_format,
	drm_handle_authenticated,
	drm_handle_capabilities
};

static void
registry_handle_global(void *data, struct wl_registry *registry, uint32_t name,
		       const char *interface, uint32_t version)
{
   struct dri2_egl_display *dri2_dpy = data;

   if (version > 1)
      version = 2;
   if (strcmp(interface, "wl_drm") == 0) {
      dri2_dpy->wl_drm =
         wl_registry_bind(registry, name, &wl_drm_interface, version);
      wl_drm_add_listener(dri2_dpy->wl_drm, &drm_listener, dri2_dpy);
   }
}

static void
registry_handle_global_remove(void *data, struct wl_registry *registry,
			      uint32_t name)
{
}

static const struct wl_registry_listener registry_listener = {
   registry_handle_global,
   registry_handle_global_remove
d770 1
a770 2
   const __DRIconfig *config;
   uint32_t types;
a771 3
   static const unsigned int argb_masks[4] =
      { 0xff0000, 0xff00, 0xff, 0xff000000 };
   static const unsigned int rgb_masks[4] = { 0xff0000, 0xff00, 0xff, 0 };
d774 1
d777 1
a777 1
   drv->API.SwapBuffersWithDamageEXT = dri2_swap_buffers_with_damage;
a778 1
   drv->API.QueryBufferAge = dri2_query_buffer_age;
d780 1
a780 1
   dri2_dpy = calloc(1, sizeof *dri2_dpy);
d784 2
a790 1
      dri2_dpy->own_device = 1;
d795 8
a802 11
   dri2_dpy->wl_queue = wl_display_create_queue(dri2_dpy->wl_dpy);

   if (dri2_dpy->own_device)
      wl_display_dispatch_pending(dri2_dpy->wl_dpy);

   dri2_dpy->wl_registry = wl_display_get_registry(dri2_dpy->wl_dpy);
   wl_proxy_set_queue((struct wl_proxy *) dri2_dpy->wl_registry,
                      dri2_dpy->wl_queue);
   wl_registry_add_listener(dri2_dpy->wl_registry,
                            &registry_listener, dri2_dpy);
   if (roundtrip(dri2_dpy) < 0 || dri2_dpy->wl_drm == NULL)
d804 3
a806 2

   if (roundtrip(dri2_dpy) < 0 || dri2_dpy->fd == -1)
d809 2
a810 1
   if (roundtrip(dri2_dpy) < 0 || !dri2_dpy->authenticated)
d837 6
a842 17
   /* The server shouldn't advertise WL_DRM_CAPABILITY_PRIME if the driver
    * doesn't have createImageFromFds, since we're using the same driver on
    * both sides.  We don't want crash if that happens anyway, so fall back to
    * gem names if we don't have prime support. */

   if (dri2_dpy->image->base.version < 7 ||
       dri2_dpy->image->createImageFromFds == NULL)
      dri2_dpy->capabilities &= WL_DRM_CAPABILITY_PRIME;

   types = EGL_WINDOW_BIT;
   for (i = 0; dri2_dpy->driver_configs[i]; i++) {
      config = dri2_dpy->driver_configs[i];
      if (dri2_dpy->formats & HAS_XRGB8888)
	 dri2_add_config(disp, config, i + 1, 0, types, NULL, rgb_masks);
      if (dri2_dpy->formats & HAS_ARGB8888)
	 dri2_add_config(disp, config, i + 1, 0, types, NULL, argb_masks);
   }
a844 1
   disp->Extensions.EXT_buffer_age = EGL_TRUE;
a845 2

   disp->Extensions.EXT_swap_buffers_with_damage = EGL_TRUE;
@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@a38 2
#include "egl_dri2_fallbacks.h"
#include "loader.h"
d45 1
a45 2
   HAS_XRGB8888 = 2,
   HAS_RGB565 = 4,
a47 4
static EGLBoolean
dri2_wl_swap_interval(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf,
                      EGLint interval);

d115 3
a117 3
dri2_wl_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
                       _EGLConfig *conf, void *native_window,
                       const EGLint *attrib_list)
a120 1
   struct wl_egl_window *window = native_window;
d135 1
a135 3
   if (conf->RedSize == 5)
      dri2_surf->format = WL_DRM_FORMAT_RGB565;
   else if (conf->AlphaSize == 0)
d142 1
a142 1
      dri2_surf->wl_win = window;
d179 3
a181 3
dri2_wl_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
                              _EGLConfig *conf, void *native_window,
                              const EGLint *attrib_list)
d183 2
a184 26
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   _EGLSurface *surf;

   surf = dri2_wl_create_surface(drv, disp, EGL_WINDOW_BIT, conf,
                                 native_window, attrib_list);

   if (surf != NULL)
      dri2_wl_swap_interval(drv, disp, surf, dri2_dpy->default_swap_interval);

   return surf;
}

static _EGLSurface *
dri2_wl_create_pixmap_surface(_EGLDriver *drv, _EGLDisplay *disp,
                              _EGLConfig *conf, void *native_window,
                              const EGLint *attrib_list)
{
   /* From the EGL_EXT_platform_wayland spec, version 3:
    *
    *   It is not valid to call eglCreatePlatformPixmapSurfaceEXT with a <dpy>
    *   that belongs to Wayland. Any such call fails and generates
    *   EGL_BAD_PARAMETER.
    */
   _eglError(EGL_BAD_PARAMETER, "cannot create EGL pixmap surfaces on "
             "Wayland");
   return NULL;
d191 1
a191 1
dri2_wl_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
d217 2
a218 2
   if (dri2_surf->throttle_callback)
      wl_callback_destroy(dri2_surf->throttle_callback);
d231 1
a231 1
dri2_wl_release_buffers(struct dri2_egl_surface *dri2_surf)
d257 1
a257 1
get_back_bo(struct dri2_egl_surface *dri2_surf)
d261 2
a262 1
   int i;
d264 2
a265 8
   /* We always want to throttle to some event (either a frame callback or
    * a sync request) after the commit so that we can be sure the
    * compositor has had a chance to handle it and send us a release event
    * before we look for a free buffer */
   while (dri2_surf->throttle_callback != NULL)
      if (wl_display_dispatch_queue(dri2_dpy->wl_dpy,
                                    dri2_dpy->wl_queue) == -1)
         return -1;
d269 3
a271 3
         /* Get an unlocked buffer, preferrably one with a dri_buffer
          * already allocated. */
         if (dri2_surf->color_buffers[i].locked)
d274 1
a274 1
            dri2_surf->back = &dri2_surf->color_buffers[i];
d276 1
a276 1
            dri2_surf->back = &dri2_surf->color_buffers[i];
a294 14
   dri2_surf->back->locked = 1;

   return 0;
}


static void
back_bo_to_dri_buffer(struct dri2_egl_surface *dri2_surf, __DRIbuffer *buffer)
{
   struct dri2_egl_display *dri2_dpy =
      dri2_egl_display(dri2_surf->base.Resource.Display);
   __DRIimage *image;
   int name, pitch;

d300 3
d308 4
d337 5
a341 2
static int
update_buffers(struct dri2_egl_surface *dri2_surf)
d343 1
d346 1
a346 1
   int i;
d352 1
a352 1
      dri2_wl_release_buffers(dri2_surf);
d360 16
a375 3
   if (get_back_bo(dri2_surf) < 0) {
      _eglError(EGL_BAD_ALLOC, "failed to allocate color buffer");
      return -1;
a390 30
   return 0;
}

static __DRIbuffer *
dri2_wl_get_buffers_with_format(__DRIdrawable * driDrawable,
                                int *width, int *height,
                                unsigned int *attachments, int count,
                                int *out_count, void *loaderPrivate)
{
   struct dri2_egl_surface *dri2_surf = loaderPrivate;
   int i, j;

   if (update_buffers(dri2_surf) < 0)
      return NULL;

   for (i = 0, j = 0; i < 2 * count; i += 2, j++) {
      switch (attachments[i]) {
      case __DRI_BUFFER_BACK_LEFT:
         back_bo_to_dri_buffer(dri2_surf, &dri2_surf->buffers[j]);
	 break;
      default:
	 if (get_aux_bo(dri2_surf, attachments[i], attachments[i + 1],
			&dri2_surf->buffers[j]) < 0) {
	    _eglError(EGL_BAD_ALLOC, "failed to allocate aux buffer");
	    return NULL;
	 }
	 break;
      }
   }

d402 4
a405 4
dri2_wl_get_buffers(__DRIdrawable * driDrawable,
                    int *width, int *height,
                    unsigned int *attachments, int count,
                    int *out_count, void *loaderPrivate)
d424 4
a427 4
      dri2_wl_get_buffers_with_format(driDrawable,
                                      width, height,
                                      attachments_with_format, count,
                                      out_count, loaderPrivate);
a433 19
static int
image_get_buffers(__DRIdrawable *driDrawable,
                  unsigned int format,
                  uint32_t *stamp,
                  void *loaderPrivate,
                  uint32_t buffer_mask,
                  struct __DRIimageList *buffers)
{
   struct dri2_egl_surface *dri2_surf = loaderPrivate;

   if (update_buffers(dri2_surf) < 0)
      return 0;

   buffers->image_mask = __DRI_IMAGE_BUFFER_BACK;
   buffers->back = dri2_surf->back->dri_image;

   return 1;
}

d435 1
a435 1
dri2_wl_flush_front_buffer(__DRIdrawable * driDrawable, void *loaderPrivate)
a440 7
static const __DRIimageLoaderExtension image_loader_extension = {
   .base = { __DRI_IMAGE_LOADER, 1 },

   .getBuffers          = image_get_buffers,
   .flushFrontBuffer    = dri2_wl_flush_front_buffer,
};

d442 1
a442 3
wayland_throttle_callback(void *data,
                          struct wl_callback *callback,
                          uint32_t time)
d446 1
a446 1
   dri2_surf->throttle_callback = NULL;
d450 2
a451 2
static const struct wl_callback_listener throttle_listener = {
   wayland_throttle_callback
d459 1
a459 1
   int fd, stride, name;
a466 2
      dri2_dpy->image->queryImage(dri2_surf->current->dri_image,
                                  __DRI_IMAGE_ATTRIB_STRIDE, &stride);
d474 1
a474 1
                                    0, stride,
a478 5
      dri2_dpy->image->queryImage(dri2_surf->current->dri_image,
                                  __DRI_IMAGE_ATTRIB_NAME, &name);
      dri2_dpy->image->queryImage(dri2_surf->current->dri_image,
                                  __DRI_IMAGE_ATTRIB_STRIDE, &stride);

d481 1
a481 1
                              name,
d484 1
a484 1
                              stride,
d498 5
a502 5
dri2_wl_swap_buffers_with_damage(_EGLDriver *drv,
                                 _EGLDisplay *disp,
                                 _EGLSurface *draw,
                                 const EGLint *rects,
                                 EGLint n_rects)
d506 13
a518 3
   struct dri2_egl_context *dri2_ctx;
   _EGLContext *ctx;
   int i;
d526 1
a526 1
   if (get_back_bo(dri2_surf) < 0) {
a530 9
   if (draw->SwapInterval > 0) {
      dri2_surf->throttle_callback =
         wl_surface_frame(dri2_surf->wl_win->surface);
      wl_callback_add_listener(dri2_surf->throttle_callback,
                               &throttle_listener, dri2_surf);
      wl_proxy_set_queue((struct wl_proxy *) dri2_surf->throttle_callback,
                         dri2_dpy->wl_queue);
   }

d548 2
a549 2
      wl_surface_damage(dri2_surf->wl_win->surface,
                        0, 0, INT32_MAX, INT32_MAX);
d560 1
a560 10
   if (dri2_dpy->flush->base.version >= 4) {
      ctx = _eglGetCurrentContext();
      dri2_ctx = dri2_egl_context(ctx);
      (*dri2_dpy->flush->flush_with_flags)(dri2_ctx->dri_context,
                                           dri2_surf->dri_drawable,
                                           __DRI2_FLUSH_DRAWABLE,
                                           __DRI2_THROTTLE_SWAPBUFFER);
   } else {
      (*dri2_dpy->flush->flush)(dri2_surf->dri_drawable);
   }
d562 1
a564 16
   wl_surface_commit(dri2_surf->wl_win->surface);

   /* If we're not waiting for a frame callback then we'll at least throttle
    * to a sync callback so that we always give a chance for the compositor to
    * handle the commit and send a release event before checking for a free
    * buffer */
   if (dri2_surf->throttle_callback == NULL) {
      dri2_surf->throttle_callback = wl_display_sync(dri2_dpy->wl_dpy);
      wl_callback_add_listener(dri2_surf->throttle_callback,
                               &throttle_listener, dri2_surf);
      wl_proxy_set_queue((struct wl_proxy *) dri2_surf->throttle_callback,
                         dri2_dpy->wl_queue);
   }

   wl_display_flush(dri2_dpy->wl_dpy);

d569 2
a570 2
dri2_wl_query_buffer_age(_EGLDriver *drv,
                         _EGLDisplay *disp, _EGLSurface *surface)
d573 1
d575 1
a575 1
   if (get_back_bo(dri2_surf) < 0) {
d584 1
a584 9
dri2_wl_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
{
   return dri2_wl_swap_buffers_with_damage (drv, disp, draw, NULL, 0);
}

static struct wl_buffer *
dri2_wl_create_wayland_buffer_from_image(_EGLDriver *drv,
                                          _EGLDisplay *disp,
                                          _EGLImage *img)
d586 1
a586 68
   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
   struct dri2_egl_image *dri2_img = dri2_egl_image(img);
   __DRIimage *image = dri2_img->dri_image;
   struct wl_buffer *buffer;
   int width, height, format, pitch;
   enum wl_drm_format wl_format;

   dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_FORMAT, &format);

   switch (format) {
   case __DRI_IMAGE_FORMAT_ARGB8888:
      if (!(dri2_dpy->formats & HAS_ARGB8888))
         goto bad_format;
      wl_format = WL_DRM_FORMAT_ARGB8888;
      break;
   case __DRI_IMAGE_FORMAT_XRGB8888:
      if (!(dri2_dpy->formats & HAS_XRGB8888))
         goto bad_format;
      wl_format = WL_DRM_FORMAT_XRGB8888;
      break;
   default:
      goto bad_format;
   }

   dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_WIDTH, &width);
   dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_HEIGHT, &height);
   dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_STRIDE, &pitch);

   if (dri2_dpy->capabilities & WL_DRM_CAPABILITY_PRIME) {
      int fd;

      dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_FD, &fd);

      buffer =
         wl_drm_create_prime_buffer(dri2_dpy->wl_drm,
                                    fd,
                                    width, height,
                                    wl_format,
                                    0, pitch,
                                    0, 0,
                                    0, 0);

      close(fd);
   } else {
      int name;

      dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_NAME, &name);

      buffer =
         wl_drm_create_buffer(dri2_dpy->wl_drm,
                              name,
                              width, height,
                              pitch,
                              wl_format);
   }

   /* The buffer object will have been created with our internal event queue
    * because it is using the wl_drm object as a proxy factory. We want the
    * buffer to be used by the application so we'll reset it to the display's
    * default event queue */
   if (buffer)
      wl_proxy_set_queue((struct wl_proxy *) buffer, NULL);

   return buffer;

bad_format:
   _eglError(EGL_BAD_MATCH, "unsupported image format");
   return NULL;
d590 1
a590 1
dri2_wl_authenticate(_EGLDisplay *disp, uint32_t id)
d610 25
a676 3
   case WL_DRM_FORMAT_RGB565:
      dri2_dpy->formats |= HAS_RGB565;
      break;
a728 71
static EGLBoolean
dri2_wl_swap_interval(_EGLDriver *drv,
                   _EGLDisplay *disp,
                   _EGLSurface *surf,
                   EGLint interval)
{
   if (interval > surf->Config->MaxSwapInterval)
      interval = surf->Config->MaxSwapInterval;
   else if (interval < surf->Config->MinSwapInterval)
      interval = surf->Config->MinSwapInterval;

   surf->SwapInterval = interval;

   return EGL_TRUE;
}

static void
dri2_wl_setup_swap_interval(struct dri2_egl_display *dri2_dpy)
{
   GLint vblank_mode = DRI_CONF_VBLANK_DEF_INTERVAL_1;

   /* We can't use values greater than 1 on Wayland because we are using the
    * frame callback to synchronise the frame and the only way we be sure to
    * get a frame callback is to attach a new buffer. Therefore we can't just
    * sit drawing nothing to wait until the next ‘n’ frame callbacks */

   if (dri2_dpy->config)
      dri2_dpy->config->configQueryi(dri2_dpy->dri_screen,
                                     "vblank_mode", &vblank_mode);
   switch (vblank_mode) {
   case DRI_CONF_VBLANK_NEVER:
      dri2_dpy->min_swap_interval = 0;
      dri2_dpy->max_swap_interval = 0;
      dri2_dpy->default_swap_interval = 0;
      break;
   case DRI_CONF_VBLANK_ALWAYS_SYNC:
      dri2_dpy->min_swap_interval = 1;
      dri2_dpy->max_swap_interval = 1;
      dri2_dpy->default_swap_interval = 1;
      break;
   case DRI_CONF_VBLANK_DEF_INTERVAL_0:
      dri2_dpy->min_swap_interval = 0;
      dri2_dpy->max_swap_interval = 1;
      dri2_dpy->default_swap_interval = 0;
      break;
   default:
   case DRI_CONF_VBLANK_DEF_INTERVAL_1:
      dri2_dpy->min_swap_interval = 0;
      dri2_dpy->max_swap_interval = 1;
      dri2_dpy->default_swap_interval = 1;
      break;
   }
}

static struct dri2_egl_display_vtbl dri2_wl_display_vtbl = {
   .authenticate = dri2_wl_authenticate,
   .create_window_surface = dri2_wl_create_window_surface,
   .create_pixmap_surface = dri2_wl_create_pixmap_surface,
   .create_pbuffer_surface = dri2_fallback_create_pbuffer_surface,
   .destroy_surface = dri2_wl_destroy_surface,
   .create_image = dri2_create_image_khr,
   .swap_interval = dri2_wl_swap_interval,
   .swap_buffers = dri2_wl_swap_buffers,
   .swap_buffers_with_damage = dri2_wl_swap_buffers_with_damage,
   .swap_buffers_region = dri2_fallback_swap_buffers_region,
   .post_sub_buffer = dri2_fallback_post_sub_buffer,
   .copy_buffers = dri2_fallback_copy_buffers,
   .query_buffer_age = dri2_wl_query_buffer_age,
   .create_wayland_buffer_from_image = dri2_wl_create_wayland_buffer_from_image,
};

a738 1
   static const unsigned int rgb565_masks[4] = { 0xf800, 0x07e0, 0x001f, 0 };
d740 6
a745 1
   loader_set_logger(_eglLog);
d780 1
a780 1
   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd, 0);
d791 2
a792 2
   dri2_dpy->dri2_loader_extension.getBuffers = dri2_wl_get_buffers;
   dri2_dpy->dri2_loader_extension.flushFrontBuffer = dri2_wl_flush_front_buffer;
d794 2
a795 2
      dri2_wl_get_buffers_with_format;

d797 3
a799 6
   dri2_dpy->extensions[1] = &image_loader_extension.base;
   dri2_dpy->extensions[2] = &image_lookup_extension.base;
   dri2_dpy->extensions[3] = &use_invalidate.base;
   dri2_dpy->extensions[4] = NULL;

   dri2_dpy->swap_available = EGL_TRUE;
a803 2
   dri2_wl_setup_swap_interval(dri2_dpy);

d811 1
a811 1
      dri2_dpy->capabilities &= ~WL_DRM_CAPABILITY_PRIME;
d817 1
a817 1
	 dri2_add_config(disp, config, i + 1, types, NULL, rgb_masks);
d819 1
a819 3
	 dri2_add_config(disp, config, i + 1, types, NULL, argb_masks);
      if (dri2_dpy->formats & HAS_RGB565)
        dri2_add_config(disp, config, i + 1, types, NULL, rgb565_masks);
a822 1
   disp->Extensions.WL_create_wayland_buffer_from_image = EGL_TRUE;
d824 1
a830 5

   /* Fill vtbl last to prevent accidentally calling virtual function during
    * initialization.
    */
   dri2_dpy->vtbl = &dri2_wl_display_vtbl;
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d471 1
a471 1
   attachments_with_format = calloc(count, 2 * sizeof(unsigned int));
a966 1
   .get_sync_values = dri2_fallback_get_sync_values,
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d471 1
a471 1
   attachments_with_format = calloc(count * 2, sizeof(unsigned int));
d967 1
@


