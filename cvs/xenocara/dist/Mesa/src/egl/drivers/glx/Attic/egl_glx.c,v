head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.07.09.21.08.51;	author jsg;	state dead;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.23;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.02;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.23;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.18;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/**************************************************************************
 *
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright 2010-2011 LunarG, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


/**
 * This is an EGL driver that wraps GLX. This gives the benefit of being
 * completely agnostic of the direct rendering implementation.
 *
 * Authors: Alan Hourihane <alanh@@tungstengraphics.com>
 */

#include <stdlib.h>
#include <string.h>
#include <X11/Xlib.h>
#include <dlfcn.h>
#include "GL/glx.h"

#include "eglconfig.h"
#include "eglcontext.h"
#include "egldefines.h"
#include "egldisplay.h"
#include "egldriver.h"
#include "eglcurrent.h"
#include "egllog.h"
#include "eglsurface.h"

#define CALLOC_STRUCT(T)   (struct T *) calloc(1, sizeof(struct T))

#ifndef GLX_VERSION_1_4
#error "GL/glx.h must be equal to or greater than GLX 1.4"
#endif

/* GLX 1.0 */
typedef GLXContext (*GLXCREATECONTEXTPROC)( Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct );
typedef void (*GLXDESTROYCONTEXTPROC)( Display *dpy, GLXContext ctx );
typedef Bool (*GLXMAKECURRENTPROC)( Display *dpy, GLXDrawable drawable, GLXContext ctx);
typedef void (*GLXSWAPBUFFERSPROC)( Display *dpy, GLXDrawable drawable );
typedef GLXPixmap (*GLXCREATEGLXPIXMAPPROC)( Display *dpy, XVisualInfo *visual, Pixmap pixmap );
typedef void (*GLXDESTROYGLXPIXMAPPROC)( Display *dpy, GLXPixmap pixmap );
typedef Bool (*GLXQUERYVERSIONPROC)( Display *dpy, int *maj, int *min );
typedef int (*GLXGETCONFIGPROC)( Display *dpy, XVisualInfo *visual, int attrib, int *value );
typedef void (*GLXWAITGLPROC)( void );
typedef void (*GLXWAITXPROC)( void );

/* GLX 1.1 */
typedef const char *(*GLXQUERYEXTENSIONSSTRINGPROC)( Display *dpy, int screen );
typedef const char *(*GLXQUERYSERVERSTRINGPROC)( Display *dpy, int screen, int name );
typedef const char *(*GLXGETCLIENTSTRINGPROC)( Display *dpy, int name );

/** subclass of _EGLDriver */
struct GLX_egl_driver
{
   _EGLDriver Base;   /**< base class */

   void *handle;

   /* GLX 1.0 */
   GLXCREATECONTEXTPROC glXCreateContext;
   GLXDESTROYCONTEXTPROC glXDestroyContext;
   GLXMAKECURRENTPROC glXMakeCurrent;
   GLXSWAPBUFFERSPROC glXSwapBuffers;
   GLXCREATEGLXPIXMAPPROC glXCreateGLXPixmap;
   GLXDESTROYGLXPIXMAPPROC glXDestroyGLXPixmap;
   GLXQUERYVERSIONPROC glXQueryVersion;
   GLXGETCONFIGPROC glXGetConfig;
   GLXWAITGLPROC glXWaitGL;
   GLXWAITXPROC glXWaitX;

   /* GLX 1.1 */
   GLXQUERYEXTENSIONSSTRINGPROC glXQueryExtensionsString;
   GLXQUERYSERVERSTRINGPROC glXQueryServerString;
   GLXGETCLIENTSTRINGPROC glXGetClientString;

   /* GLX 1.3 or (GLX_SGI_make_current_read and GLX_SGIX_fbconfig) */
   PFNGLXGETFBCONFIGSPROC glXGetFBConfigs;
   PFNGLXGETFBCONFIGATTRIBPROC glXGetFBConfigAttrib;
   PFNGLXGETVISUALFROMFBCONFIGPROC glXGetVisualFromFBConfig;
   PFNGLXCREATEWINDOWPROC glXCreateWindow;
   PFNGLXDESTROYWINDOWPROC glXDestroyWindow;
   PFNGLXCREATEPIXMAPPROC glXCreatePixmap;
   PFNGLXDESTROYPIXMAPPROC glXDestroyPixmap;
   PFNGLXCREATEPBUFFERPROC glXCreatePbuffer;
   PFNGLXDESTROYPBUFFERPROC glXDestroyPbuffer;
   PFNGLXCREATENEWCONTEXTPROC glXCreateNewContext;
   PFNGLXMAKECONTEXTCURRENTPROC glXMakeContextCurrent;

   /* GLX 1.4 or GLX_ARB_get_proc_address */
   PFNGLXGETPROCADDRESSPROC glXGetProcAddress;

   /* GLX_SGIX_pbuffer */
   PFNGLXCREATEGLXPBUFFERSGIXPROC glXCreateGLXPbufferSGIX;
   PFNGLXDESTROYGLXPBUFFERSGIXPROC glXDestroyGLXPbufferSGIX;
};


/** driver data of _EGLDisplay */
struct GLX_egl_display
{
   Display *dpy;
   XVisualInfo *visuals;
   GLXFBConfig *fbconfigs;

   int glx_maj, glx_min;

   const char *extensions;
   EGLBoolean have_1_3;
   EGLBoolean have_make_current_read;
   EGLBoolean have_fbconfig;
   EGLBoolean have_pbuffer;

   /* workaround quirks of different GLX implementations */
   EGLBoolean single_buffered_quirk;
   EGLBoolean glx_window_quirk;
};


/** subclass of _EGLContext */
struct GLX_egl_context
{
   _EGLContext Base;   /**< base class */

   GLXContext context;
};


/** subclass of _EGLSurface */
struct GLX_egl_surface
{
   _EGLSurface Base;   /**< base class */

   Drawable drawable;
   GLXDrawable glx_drawable;

   void (*destroy)(Display *, GLXDrawable);
};


/** subclass of _EGLConfig */
struct GLX_egl_config
{
   _EGLConfig Base;   /**< base class */
   EGLBoolean double_buffered;
   int index;
};

/* standard typecasts */
_EGL_DRIVER_STANDARD_TYPECASTS(GLX_egl)

static int
GLX_egl_config_index(_EGLConfig *conf)
{
   struct GLX_egl_config *GLX_conf = GLX_egl_config(conf);
   return GLX_conf->index;
}


static const struct {
   int attr;
   int egl_attr;
} fbconfig_attributes[] = {
   /* table 3.1 of GLX 1.4 */
   { GLX_FBCONFIG_ID,                  0 },
   { GLX_BUFFER_SIZE,                  EGL_BUFFER_SIZE },
   { GLX_LEVEL,                        EGL_LEVEL },
   { GLX_DOUBLEBUFFER,                 0 },
   { GLX_STEREO,                       0 },
   { GLX_AUX_BUFFERS,                  0 },
   { GLX_RED_SIZE,                     EGL_RED_SIZE },
   { GLX_GREEN_SIZE,                   EGL_GREEN_SIZE },
   { GLX_BLUE_SIZE,                    EGL_BLUE_SIZE },
   { GLX_ALPHA_SIZE,                   EGL_ALPHA_SIZE },
   { GLX_DEPTH_SIZE,                   EGL_DEPTH_SIZE },
   { GLX_STENCIL_SIZE,                 EGL_STENCIL_SIZE },
   { GLX_ACCUM_RED_SIZE,               0 },
   { GLX_ACCUM_GREEN_SIZE,             0 },
   { GLX_ACCUM_BLUE_SIZE,              0 },
   { GLX_ACCUM_ALPHA_SIZE,             0 },
   { GLX_SAMPLE_BUFFERS,               EGL_SAMPLE_BUFFERS },
   { GLX_SAMPLES,                      EGL_SAMPLES },
   { GLX_RENDER_TYPE,                  0 },
   { GLX_DRAWABLE_TYPE,                EGL_SURFACE_TYPE },
   { GLX_X_RENDERABLE,                 EGL_NATIVE_RENDERABLE },
   { GLX_X_VISUAL_TYPE,                EGL_NATIVE_VISUAL_TYPE },
   { GLX_CONFIG_CAVEAT,                EGL_CONFIG_CAVEAT },
   { GLX_TRANSPARENT_TYPE,             EGL_TRANSPARENT_TYPE },
   { GLX_TRANSPARENT_INDEX_VALUE,      0 },
   { GLX_TRANSPARENT_RED_VALUE,        EGL_TRANSPARENT_RED_VALUE },
   { GLX_TRANSPARENT_GREEN_VALUE,      EGL_TRANSPARENT_GREEN_VALUE },
   { GLX_TRANSPARENT_BLUE_VALUE,       EGL_TRANSPARENT_BLUE_VALUE },
   { GLX_MAX_PBUFFER_WIDTH,            EGL_MAX_PBUFFER_WIDTH },
   { GLX_MAX_PBUFFER_HEIGHT,           EGL_MAX_PBUFFER_HEIGHT },
   { GLX_MAX_PBUFFER_PIXELS,           EGL_MAX_PBUFFER_PIXELS },
   { GLX_VISUAL_ID,                    EGL_NATIVE_VISUAL_ID }
};


static EGLBoolean
convert_fbconfig(struct GLX_egl_driver *GLX_drv,
                 struct GLX_egl_display *GLX_dpy, GLXFBConfig fbconfig,
                 struct GLX_egl_config *GLX_conf)
{
   Display *dpy = GLX_dpy->dpy;
   int err, attr, val;
   unsigned i;

   /* must have rgba bit */
   err = GLX_drv->glXGetFBConfigAttrib(dpy, fbconfig, GLX_RENDER_TYPE, &val);
   if (err || !(val & GLX_RGBA_BIT))
      return EGL_FALSE;

   /* must know whether it is double-buffered */
   err = GLX_drv->glXGetFBConfigAttrib(dpy, fbconfig, GLX_DOUBLEBUFFER, &val);
   if (err)
      return EGL_FALSE;
   GLX_conf->double_buffered = val;

   GLX_conf->Base.RenderableType = EGL_OPENGL_BIT;
   GLX_conf->Base.Conformant = EGL_OPENGL_BIT;

   for (i = 0; i < ARRAY_SIZE(fbconfig_attributes); i++) {
      EGLint egl_attr, egl_val;

      attr = fbconfig_attributes[i].attr;
      egl_attr = fbconfig_attributes[i].egl_attr;
      if (!egl_attr)
         continue;

      err = GLX_drv->glXGetFBConfigAttrib(dpy, fbconfig, attr, &val);
      if (err) {
         if (err == GLX_BAD_ATTRIBUTE) {
            err = 0;
            continue;
         }
         break;
      }

      switch (egl_attr) {
      case EGL_SURFACE_TYPE:
         egl_val = 0;
         if (val & GLX_WINDOW_BIT)
            egl_val |= EGL_WINDOW_BIT;
         /* pixmap and pbuffer surfaces must be single-buffered in EGL */
         if (!GLX_conf->double_buffered) {
            if (val & GLX_PIXMAP_BIT)
               egl_val |= EGL_PIXMAP_BIT;
            if (val & GLX_PBUFFER_BIT)
               egl_val |= EGL_PBUFFER_BIT;
         }
         break;
      case EGL_NATIVE_VISUAL_TYPE:
         switch (val) {
         case GLX_TRUE_COLOR:
            egl_val = TrueColor;
            break;
         case GLX_DIRECT_COLOR:
            egl_val = DirectColor;
            break;
         case GLX_PSEUDO_COLOR:
            egl_val = PseudoColor;
            break;
         case GLX_STATIC_COLOR:
            egl_val = StaticColor;
            break;
         case GLX_GRAY_SCALE:
            egl_val = GrayScale;
            break;
         case GLX_STATIC_GRAY:
            egl_val = StaticGray;
            break;
         default:
            egl_val = EGL_NONE;
            break;
         }
         break;
      case EGL_CONFIG_CAVEAT:
         egl_val = EGL_NONE;
         if (val == GLX_SLOW_CONFIG) {
            egl_val = EGL_SLOW_CONFIG;
         }
         else if (val == GLX_NON_CONFORMANT_CONFIG) {
            GLX_conf->Base.Conformant &= ~EGL_OPENGL_BIT;
            egl_val = EGL_NONE;
         }
         break;
      case EGL_TRANSPARENT_TYPE:
         egl_val = (val == GLX_TRANSPARENT_RGB) ?
            EGL_TRANSPARENT_RGB : EGL_NONE;
         break;
      default:
         egl_val = val;
         break;
      }

      _eglSetConfigKey(&GLX_conf->Base, egl_attr, egl_val);
   }
   if (err)
      return EGL_FALSE;

   if (!GLX_conf->Base.SurfaceType)
      return EGL_FALSE;

   return EGL_TRUE;
}

static const struct {
   int attr;
   int egl_attr;
} visual_attributes[] = {
   /* table 3.7 of GLX 1.4 */
   { GLX_USE_GL,              0 },
   { GLX_BUFFER_SIZE,         EGL_BUFFER_SIZE },
   { GLX_LEVEL,               EGL_LEVEL },
   { GLX_RGBA,                0 },
   { GLX_DOUBLEBUFFER,        0 },
   { GLX_STEREO,              0 },
   { GLX_AUX_BUFFERS,         0 },
   { GLX_RED_SIZE,            EGL_RED_SIZE },
   { GLX_GREEN_SIZE,          EGL_GREEN_SIZE },
   { GLX_BLUE_SIZE,           EGL_BLUE_SIZE },
   { GLX_ALPHA_SIZE,          EGL_ALPHA_SIZE },
   { GLX_DEPTH_SIZE,          EGL_DEPTH_SIZE },
   { GLX_STENCIL_SIZE,        EGL_STENCIL_SIZE },
   { GLX_ACCUM_RED_SIZE,      0 },
   { GLX_ACCUM_GREEN_SIZE,    0 },
   { GLX_ACCUM_BLUE_SIZE,     0 },
   { GLX_ACCUM_ALPHA_SIZE,    0 },
   { GLX_SAMPLE_BUFFERS,      EGL_SAMPLE_BUFFERS },
   { GLX_SAMPLES,             EGL_SAMPLES },
   { GLX_FBCONFIG_ID,         0 },
   /* GLX_EXT_visual_rating */
   { GLX_VISUAL_CAVEAT_EXT,   EGL_CONFIG_CAVEAT }
};

static EGLBoolean
convert_visual(struct GLX_egl_driver *GLX_drv,
               struct GLX_egl_display *GLX_dpy, XVisualInfo *vinfo,
               struct GLX_egl_config *GLX_conf)
{
   Display *dpy = GLX_dpy->dpy;
   int err, attr, val;
   unsigned i;

   /* the visual must support OpenGL and RGBA buffer */
   err = GLX_drv->glXGetConfig(dpy, vinfo, GLX_USE_GL, &val);
   if (!err && val)
      err = GLX_drv->glXGetConfig(dpy, vinfo, GLX_RGBA, &val);
   if (err || !val)
      return EGL_FALSE;

   /* must know whether it is double-buffered */
   err = GLX_drv->glXGetConfig(dpy, vinfo, GLX_DOUBLEBUFFER, &val);
   if (err)
      return EGL_FALSE;
   GLX_conf->double_buffered = val;

   GLX_conf->Base.RenderableType = EGL_OPENGL_BIT;
   GLX_conf->Base.Conformant = EGL_OPENGL_BIT;
   GLX_conf->Base.SurfaceType = EGL_WINDOW_BIT;
   /* pixmap surfaces must be single-buffered in EGL */
   if (!GLX_conf->double_buffered)
      GLX_conf->Base.SurfaceType |= EGL_PIXMAP_BIT;

   GLX_conf->Base.NativeVisualID = vinfo->visualid;
   GLX_conf->Base.NativeVisualType = vinfo->class;
   GLX_conf->Base.NativeRenderable = EGL_TRUE;

   for (i = 0; i < ARRAY_SIZE(visual_attributes); i++) {
      EGLint egl_attr, egl_val;

      attr = visual_attributes[i].attr;
      egl_attr = visual_attributes[i].egl_attr;
      if (!egl_attr)
         continue;

      err = GLX_drv->glXGetConfig(dpy, vinfo, attr, &val);
      if (err) {
         if (err == GLX_BAD_ATTRIBUTE) {
            err = 0;
            continue;
         }
         break;
      }

      switch (egl_attr) {
      case EGL_CONFIG_CAVEAT:
         egl_val = EGL_NONE;
         if (val == GLX_SLOW_VISUAL_EXT) {
            egl_val = EGL_SLOW_CONFIG;
         }
         else if (val == GLX_NON_CONFORMANT_VISUAL_EXT) {
            GLX_conf->Base.Conformant &= ~EGL_OPENGL_BIT;
            egl_val = EGL_NONE;
         }
         break;
         break;
      default:
         egl_val = val;
         break;
      }
      _eglSetConfigKey(&GLX_conf->Base, egl_attr, egl_val);
   }

   return (err) ? EGL_FALSE : EGL_TRUE;
}


static void
fix_config(struct GLX_egl_display *GLX_dpy, struct GLX_egl_config *GLX_conf)
{
   _EGLConfig *conf = &GLX_conf->Base;

   if (!GLX_conf->double_buffered && GLX_dpy->single_buffered_quirk) {
      /* some GLX impls do not like single-buffered window surface */
      conf->SurfaceType &= ~EGL_WINDOW_BIT;
      /* pbuffer bit is usually not set */
      if (GLX_dpy->have_pbuffer)
         conf->SurfaceType |= EGL_PBUFFER_BIT;
   }

   /* no visual attribs unless window bit is set */
   if (!(conf->SurfaceType & EGL_WINDOW_BIT)) {
      conf->NativeVisualID = 0;
      conf->NativeVisualType = EGL_NONE;
   }

   if (conf->TransparentType != EGL_TRANSPARENT_RGB) {
      /* some impls set them to -1 (GLX_DONT_CARE) */
      conf->TransparentRedValue = 0;
      conf->TransparentGreenValue = 0;
      conf->TransparentBlueValue = 0;
   }

   /* make sure buffer size is set correctly */
   conf->BufferSize =
      conf->RedSize + conf->GreenSize + conf->BlueSize + conf->AlphaSize;
}


static EGLBoolean
create_configs(_EGLDriver *drv, _EGLDisplay *dpy, EGLint screen)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(dpy);
   EGLint num_configs = 0, i;
   EGLint id = 1;

   if (GLX_dpy->have_fbconfig) {
      GLX_dpy->fbconfigs =
         GLX_drv->glXGetFBConfigs(GLX_dpy->dpy, screen, &num_configs);
   }
   else {
      XVisualInfo vinfo_template;
      long mask;

      vinfo_template.screen = screen;
      mask = VisualScreenMask;
      GLX_dpy->visuals = XGetVisualInfo(GLX_dpy->dpy, mask, &vinfo_template,
                                        &num_configs);
   }

   if (!num_configs)
      return EGL_FALSE;

   for (i = 0; i < num_configs; i++) {
      struct GLX_egl_config *GLX_conf, template;
      EGLBoolean ok;

      memset(&template, 0, sizeof(template));
      _eglInitConfig(&template.Base, dpy, id);
      if (GLX_dpy->have_fbconfig) {
         ok = convert_fbconfig(GLX_drv, GLX_dpy,
               GLX_dpy->fbconfigs[i], &template);
      }
      else {
         ok = convert_visual(GLX_drv, GLX_dpy,
               &GLX_dpy->visuals[i], &template);
      }
      if (!ok)
        continue;

      fix_config(GLX_dpy, &template);
      if (!_eglValidateConfig(&template.Base, EGL_FALSE)) {
         _eglLog(_EGL_DEBUG, "GLX: failed to validate config %d", i);
         continue;
      }

      GLX_conf = CALLOC_STRUCT(GLX_egl_config);
      if (GLX_conf) {
         memcpy(GLX_conf, &template, sizeof(template));
         GLX_conf->index = i;

         _eglLinkConfig(&GLX_conf->Base);
         id++;
      }
   }

   return EGL_TRUE;
}


static void
check_extensions(struct GLX_egl_driver *GLX_drv,
                 struct GLX_egl_display *GLX_dpy, EGLint screen)
{
   GLX_dpy->extensions =
      GLX_drv->glXQueryExtensionsString(GLX_dpy->dpy, screen);
   if (GLX_dpy->extensions) {
      if (strstr(GLX_dpy->extensions, "GLX_SGI_make_current_read")) {
         /* GLX 1.3 entry points are used */
         GLX_dpy->have_make_current_read = EGL_TRUE;
      }

      if (strstr(GLX_dpy->extensions, "GLX_SGIX_fbconfig")) {
         /* GLX 1.3 entry points are used */
         GLX_dpy->have_fbconfig = EGL_TRUE;
      }

      if (strstr(GLX_dpy->extensions, "GLX_SGIX_pbuffer")) {
         if (GLX_drv->glXCreateGLXPbufferSGIX &&
             GLX_drv->glXDestroyGLXPbufferSGIX &&
             GLX_dpy->have_fbconfig)
            GLX_dpy->have_pbuffer = EGL_TRUE;
      }
   }

   if (GLX_dpy->glx_maj == 1 && GLX_dpy->glx_min >= 3) {
      GLX_dpy->have_1_3 = EGL_TRUE;
      GLX_dpy->have_make_current_read = EGL_TRUE;
      GLX_dpy->have_fbconfig = EGL_TRUE;
      GLX_dpy->have_pbuffer = EGL_TRUE;
   }
}


static void
check_quirks(struct GLX_egl_driver *GLX_drv,
             struct GLX_egl_display *GLX_dpy, EGLint screen)
{
   const char *vendor;

   GLX_dpy->single_buffered_quirk = EGL_TRUE;
   GLX_dpy->glx_window_quirk = EGL_TRUE;

   vendor = GLX_drv->glXGetClientString(GLX_dpy->dpy, GLX_VENDOR);
   if (vendor && strstr(vendor, "NVIDIA")) {
      vendor = GLX_drv->glXQueryServerString(GLX_dpy->dpy, screen, GLX_VENDOR);
      if (vendor && strstr(vendor, "NVIDIA")) {
         _eglLog(_EGL_DEBUG, "disable quirks");
         GLX_dpy->single_buffered_quirk = EGL_FALSE;
         GLX_dpy->glx_window_quirk = EGL_FALSE;
      }
   }
}


/**
 * Called via eglInitialize(), GLX_drv->API.Initialize().
 */
static EGLBoolean
GLX_eglInitialize(_EGLDriver *drv, _EGLDisplay *disp)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   struct GLX_egl_display *GLX_dpy;

   if (disp->Platform != _EGL_PLATFORM_X11)
      return EGL_FALSE;

   /* this is a fallback driver */
   if (!disp->Options.UseFallback)
      return EGL_FALSE;

   if (disp->Options.TestOnly)
      return EGL_TRUE;

   GLX_dpy = CALLOC_STRUCT(GLX_egl_display);
   if (!GLX_dpy)
      return _eglError(EGL_BAD_ALLOC, "eglInitialize");

   GLX_dpy->dpy = (Display *) disp->PlatformDisplay;
   if (!GLX_dpy->dpy) {
      GLX_dpy->dpy = XOpenDisplay(NULL);
      if (!GLX_dpy->dpy) {
         _eglLog(_EGL_WARNING, "GLX: XOpenDisplay failed");
         free(GLX_dpy);
         return EGL_FALSE;
      }
   }

   if (!GLX_drv->glXQueryVersion(GLX_dpy->dpy,
            &GLX_dpy->glx_maj, &GLX_dpy->glx_min)) {
      _eglLog(_EGL_WARNING, "GLX: glXQueryVersion failed");
      if (!disp->PlatformDisplay)
         XCloseDisplay(GLX_dpy->dpy);
      free(GLX_dpy);
      return EGL_FALSE;
   }

   disp->DriverData = (void *) GLX_dpy;
   disp->ClientAPIs = EGL_OPENGL_BIT;

   check_extensions(GLX_drv, GLX_dpy, DefaultScreen(GLX_dpy->dpy));
   check_quirks(GLX_drv, GLX_dpy, DefaultScreen(GLX_dpy->dpy));

   create_configs(drv, disp, DefaultScreen(GLX_dpy->dpy));
   if (!_eglGetArraySize(disp->Configs)) {
      _eglLog(_EGL_WARNING, "GLX: failed to create any config");
      if (!disp->PlatformDisplay)
         XCloseDisplay(GLX_dpy->dpy);
      free(GLX_dpy);
      return EGL_FALSE;
   }

   /* we're supporting EGL 1.4 */
   disp->VersionMajor = 1;
   disp->VersionMinor = 4;

   return EGL_TRUE;
}


/**
 * Called via eglTerminate(), drv->API.Terminate().
 */
static EGLBoolean
GLX_eglTerminate(_EGLDriver *drv, _EGLDisplay *disp)
{
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(disp);

   _eglReleaseDisplayResources(drv, disp);
   _eglCleanupDisplay(disp);

   free(GLX_dpy->visuals);
   free(GLX_dpy->fbconfigs);

   if (!disp->PlatformDisplay)
      XCloseDisplay(GLX_dpy->dpy);
   free(GLX_dpy);

   disp->DriverData = NULL;

   return EGL_TRUE;
}


/**
 * Called via eglCreateContext(), drv->API.CreateContext().
 */
static _EGLContext *
GLX_eglCreateContext(_EGLDriver *drv, _EGLDisplay *disp, _EGLConfig *conf,
                      _EGLContext *share_list, const EGLint *attrib_list)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   struct GLX_egl_context *GLX_ctx = CALLOC_STRUCT(GLX_egl_context);
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(disp);
   struct GLX_egl_context *GLX_ctx_shared = GLX_egl_context(share_list);

   if (!GLX_ctx) {
      _eglError(EGL_BAD_ALLOC, "eglCreateContext");
      return NULL;
   }

   if (!_eglInitContext(&GLX_ctx->Base, disp, conf, attrib_list)) {
      free(GLX_ctx);
      return NULL;
   }

   if (GLX_dpy->have_fbconfig) {
      GLX_ctx->context = GLX_drv->glXCreateNewContext(GLX_dpy->dpy,
            GLX_dpy->fbconfigs[GLX_egl_config_index(conf)],
            GLX_RGBA_TYPE,
            GLX_ctx_shared ? GLX_ctx_shared->context : NULL,
            GL_TRUE);
   }
   else {
      GLX_ctx->context = GLX_drv->glXCreateContext(GLX_dpy->dpy,
            &GLX_dpy->visuals[GLX_egl_config_index(conf)],
            GLX_ctx_shared ? GLX_ctx_shared->context : NULL,
            GL_TRUE);
   }
   if (!GLX_ctx->context) {
      free(GLX_ctx);
      return NULL;
   }

   return &GLX_ctx->Base;
}

/**
 * Called via eglDestroyContext(), drv->API.DestroyContext().
 */
static EGLBoolean
GLX_eglDestroyContext(_EGLDriver *drv, _EGLDisplay *disp, _EGLContext *ctx)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(disp);
   struct GLX_egl_context *GLX_ctx = GLX_egl_context(ctx);

   if (_eglPutContext(ctx)) {
      assert(GLX_ctx);
      GLX_drv->glXDestroyContext(GLX_dpy->dpy, GLX_ctx->context);

      free(GLX_ctx);
   }

   return EGL_TRUE;
}

/**
 * Destroy a surface.  The display is allowed to be uninitialized.
 */
static void
destroy_surface(_EGLDisplay *disp, _EGLSurface *surf)
{
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(disp);
   struct GLX_egl_surface *GLX_surf = GLX_egl_surface(surf);

   if (GLX_surf->destroy)
      GLX_surf->destroy(GLX_dpy->dpy, GLX_surf->glx_drawable);

   free(GLX_surf);
}


/**
 * Called via eglMakeCurrent(), drv->API.MakeCurrent().
 */
static EGLBoolean
GLX_eglMakeCurrent(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *dsurf,
                   _EGLSurface *rsurf, _EGLContext *ctx)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(disp);
   struct GLX_egl_surface *GLX_dsurf = GLX_egl_surface(dsurf);
   struct GLX_egl_surface *GLX_rsurf = GLX_egl_surface(rsurf);
   struct GLX_egl_context *GLX_ctx = GLX_egl_context(ctx);
   _EGLContext *old_ctx;
   _EGLSurface *old_dsurf, *old_rsurf;
   GLXDrawable ddraw, rdraw;
   GLXContext cctx;
   EGLBoolean ret = EGL_FALSE;

   /* make new bindings */
   if (!_eglBindContext(ctx, dsurf, rsurf, &old_ctx, &old_dsurf, &old_rsurf))
      return EGL_FALSE;

   ddraw = (GLX_dsurf) ? GLX_dsurf->glx_drawable : None;
   rdraw = (GLX_rsurf) ? GLX_rsurf->glx_drawable : None;
   cctx = (GLX_ctx) ? GLX_ctx->context : NULL;

   if (GLX_dpy->have_make_current_read)
      ret = GLX_drv->glXMakeContextCurrent(GLX_dpy->dpy, ddraw, rdraw, cctx);
   else if (ddraw == rdraw)
      ret = GLX_drv->glXMakeCurrent(GLX_dpy->dpy, ddraw, cctx);

   if (ret) {
      if (_eglPutSurface(old_dsurf))
         destroy_surface(disp, old_dsurf);
      if (_eglPutSurface(old_rsurf))
         destroy_surface(disp, old_rsurf);
      /* no destroy? */
      _eglPutContext(old_ctx);
   }
   else {
      /* undo the previous _eglBindContext */
      _eglBindContext(old_ctx, old_dsurf, old_rsurf, &ctx, &dsurf, &rsurf);
      assert(&GLX_ctx->Base == ctx &&
             &GLX_dsurf->Base == dsurf &&
             &GLX_rsurf->Base == rsurf);

      _eglPutSurface(dsurf);
      _eglPutSurface(rsurf);
      _eglPutContext(ctx);

      _eglPutSurface(old_dsurf);
      _eglPutSurface(old_rsurf);
      _eglPutContext(old_ctx);
   }

   return ret;
}

/** Get size of given window */
static Status
get_drawable_size(Display *dpy, Drawable d, unsigned *width, unsigned *height)
{
   Window root;
   Status stat;
   int xpos, ypos;
   unsigned int w, h, bw, depth;
   stat = XGetGeometry(dpy, d, &root, &xpos, &ypos, &w, &h, &bw, &depth);
   *width = w;
   *height = h;
   return stat;
}

/**
 * Called via eglCreateWindowSurface(), drv->API.CreateWindowSurface().
 */
static _EGLSurface *
GLX_eglCreateWindowSurface(_EGLDriver *drv, _EGLDisplay *disp,
                           _EGLConfig *conf, EGLNativeWindowType window,
                           const EGLint *attrib_list)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(disp);
   struct GLX_egl_surface *GLX_surf;
   unsigned width, height;

   GLX_surf = CALLOC_STRUCT(GLX_egl_surface);
   if (!GLX_surf) {
      _eglError(EGL_BAD_ALLOC, "eglCreateWindowSurface");
      return NULL;
   }

   if (!_eglInitSurface(&GLX_surf->Base, disp, EGL_WINDOW_BIT,
                        conf, attrib_list)) {
      free(GLX_surf);
      return NULL;
   }

   GLX_surf->drawable = window;

   if (GLX_dpy->have_1_3 && !GLX_dpy->glx_window_quirk) {
      GLX_surf->glx_drawable = GLX_drv->glXCreateWindow(GLX_dpy->dpy,
            GLX_dpy->fbconfigs[GLX_egl_config_index(conf)],
            GLX_surf->drawable, NULL);
   }
   else {
      GLX_surf->glx_drawable = GLX_surf->drawable;
   }

   if (!GLX_surf->glx_drawable) {
      free(GLX_surf);
      return NULL;
   }

   if (GLX_dpy->have_1_3 && !GLX_dpy->glx_window_quirk)
      GLX_surf->destroy = GLX_drv->glXDestroyWindow;

   get_drawable_size(GLX_dpy->dpy, window, &width, &height);
   GLX_surf->Base.Width = width;
   GLX_surf->Base.Height = height;

   return &GLX_surf->Base;
}

static _EGLSurface *
GLX_eglCreatePixmapSurface(_EGLDriver *drv, _EGLDisplay *disp,
                           _EGLConfig *conf, EGLNativePixmapType pixmap,
                           const EGLint *attrib_list)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(disp);
   struct GLX_egl_surface *GLX_surf;
   unsigned width, height;

   GLX_surf = CALLOC_STRUCT(GLX_egl_surface);
   if (!GLX_surf) {
      _eglError(EGL_BAD_ALLOC, "eglCreatePixmapSurface");
      return NULL;
   }

   if (!_eglInitSurface(&GLX_surf->Base, disp, EGL_PIXMAP_BIT,
                        conf, attrib_list)) {
      free(GLX_surf);
      return NULL;
   }

   GLX_surf->drawable = pixmap;

   if (GLX_dpy->have_1_3) {
      GLX_surf->glx_drawable = GLX_drv->glXCreatePixmap(GLX_dpy->dpy,
            GLX_dpy->fbconfigs[GLX_egl_config_index(conf)],
            GLX_surf->drawable, NULL);
   }
   else if (GLX_dpy->have_fbconfig) {
      GLXFBConfig fbconfig = GLX_dpy->fbconfigs[GLX_egl_config_index(conf)];
      XVisualInfo *vinfo;

      vinfo = GLX_drv->glXGetVisualFromFBConfig(GLX_dpy->dpy, fbconfig);
      if (vinfo) {
         GLX_surf->glx_drawable = GLX_drv->glXCreateGLXPixmap(GLX_dpy->dpy,
               vinfo, GLX_surf->drawable);
         free(vinfo);
      }
   }
   else {
      GLX_surf->glx_drawable = GLX_drv->glXCreateGLXPixmap(GLX_dpy->dpy,
            &GLX_dpy->visuals[GLX_egl_config_index(conf)],
            GLX_surf->drawable);
   }

   if (!GLX_surf->glx_drawable) {
      free(GLX_surf);
      return NULL;
   }

   GLX_surf->destroy = (GLX_dpy->have_1_3) ?
      GLX_drv->glXDestroyPixmap : GLX_drv->glXDestroyGLXPixmap;

   get_drawable_size(GLX_dpy->dpy, pixmap, &width, &height);
   GLX_surf->Base.Width = width;
   GLX_surf->Base.Height = height;

   return &GLX_surf->Base;
}

static _EGLSurface *
GLX_eglCreatePbufferSurface(_EGLDriver *drv, _EGLDisplay *disp,
                            _EGLConfig *conf, const EGLint *attrib_list)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(disp);
   struct GLX_egl_surface *GLX_surf;
   int attribs[5];
   int i;

   GLX_surf = CALLOC_STRUCT(GLX_egl_surface);
   if (!GLX_surf) {
      _eglError(EGL_BAD_ALLOC, "eglCreatePbufferSurface");
      return NULL;
   }

   if (!_eglInitSurface(&GLX_surf->Base, disp, EGL_PBUFFER_BIT,
                        conf, attrib_list)) {
      free(GLX_surf);
      return NULL;
   }

   i = 0;
   attribs[i] = None;

   GLX_surf->drawable = None;

   if (GLX_dpy->have_1_3) {
      /* put geometry in attribs */
      if (GLX_surf->Base.Width) {
         attribs[i++] = GLX_PBUFFER_WIDTH;
         attribs[i++] = GLX_surf->Base.Width;
      }
      if (GLX_surf->Base.Height) {
         attribs[i++] = GLX_PBUFFER_HEIGHT;
         attribs[i++] = GLX_surf->Base.Height;
      }
      attribs[i] = None;

      GLX_surf->glx_drawable = GLX_drv->glXCreatePbuffer(GLX_dpy->dpy,
            GLX_dpy->fbconfigs[GLX_egl_config_index(conf)], attribs);
   }
   else if (GLX_dpy->have_pbuffer) {
      GLX_surf->glx_drawable = GLX_drv->glXCreateGLXPbufferSGIX(GLX_dpy->dpy,
            GLX_dpy->fbconfigs[GLX_egl_config_index(conf)],
            GLX_surf->Base.Width,
            GLX_surf->Base.Height,
            attribs);
   }

   if (!GLX_surf->glx_drawable) {
      free(GLX_surf);
      return NULL;
   }

   GLX_surf->destroy = (GLX_dpy->have_1_3) ?
      GLX_drv->glXDestroyPbuffer : GLX_drv->glXDestroyGLXPbufferSGIX;

   return &GLX_surf->Base;
}


static EGLBoolean
GLX_eglDestroySurface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
{
   (void) drv;

   if (_eglPutSurface(surf))
      destroy_surface(disp, surf);

   return EGL_TRUE;
}


static EGLBoolean
GLX_eglSwapBuffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(disp);
   struct GLX_egl_surface *GLX_surf = GLX_egl_surface(draw);

   GLX_drv->glXSwapBuffers(GLX_dpy->dpy, GLX_surf->glx_drawable);

   return EGL_TRUE;
}

/*
 * Called from eglGetProcAddress() via drv->API.GetProcAddress().
 */
static _EGLProc
GLX_eglGetProcAddress(_EGLDriver *drv, const char *procname)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);

   return (_EGLProc) GLX_drv->glXGetProcAddress((const GLubyte *) procname);
}

static EGLBoolean
GLX_eglWaitClient(_EGLDriver *drv, _EGLDisplay *dpy, _EGLContext *ctx)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);

   (void) dpy;
   (void) ctx;

   GLX_drv->glXWaitGL();
   return EGL_TRUE;
}

static EGLBoolean
GLX_eglWaitNative(_EGLDriver *drv, _EGLDisplay *dpy, EGLint engine)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);

   (void) dpy;

   if (engine != EGL_CORE_NATIVE_ENGINE)
      return _eglError(EGL_BAD_PARAMETER, "eglWaitNative");
   GLX_drv->glXWaitX();
   return EGL_TRUE;
}

static void
GLX_Unload(_EGLDriver *drv)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);

   if (GLX_drv->handle)
      dlclose(GLX_drv->handle);
   free(GLX_drv);
}


static EGLBoolean
GLX_Load(_EGLDriver *drv)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   void *handle = NULL;

   GLX_drv->glXGetProcAddress = dlsym(RTLD_DEFAULT, "glXGetProcAddress");
   if (!GLX_drv->glXGetProcAddress)
      GLX_drv->glXGetProcAddress = dlsym(RTLD_DEFAULT, "glXGetProcAddressARB");
   if (!GLX_drv->glXGetProcAddress) {
      handle = dlopen("libGL.so", RTLD_LAZY | RTLD_LOCAL);
      if (!handle)
         goto fail;

      GLX_drv->glXGetProcAddress = dlsym(handle, "glXGetProcAddress");
      if (!GLX_drv->glXGetProcAddress)
         GLX_drv->glXGetProcAddress = dlsym(handle, "glXGetProcAddressARB");
      if (!GLX_drv->glXGetProcAddress)
         goto fail;
   }

#define GET_PROC(proc_type, proc_name, check)                        \
   do {                                                              \
      GLX_drv->proc_name = (proc_type)                               \
         GLX_drv->glXGetProcAddress((const GLubyte *) #proc_name);   \
      if (check && !GLX_drv->proc_name) goto fail;                   \
   } while (0)

   /* GLX 1.0 */
   GET_PROC(GLXCREATECONTEXTPROC, glXCreateContext, EGL_TRUE);
   GET_PROC(GLXDESTROYCONTEXTPROC, glXDestroyContext, EGL_TRUE);
   GET_PROC(GLXMAKECURRENTPROC, glXMakeCurrent, EGL_TRUE);
   GET_PROC(GLXSWAPBUFFERSPROC, glXSwapBuffers, EGL_TRUE);
   GET_PROC(GLXCREATEGLXPIXMAPPROC, glXCreateGLXPixmap, EGL_TRUE);
   GET_PROC(GLXDESTROYGLXPIXMAPPROC, glXDestroyGLXPixmap, EGL_TRUE);
   GET_PROC(GLXQUERYVERSIONPROC, glXQueryVersion, EGL_TRUE);
   GET_PROC(GLXGETCONFIGPROC, glXGetConfig, EGL_TRUE);
   GET_PROC(GLXWAITGLPROC, glXWaitGL, EGL_TRUE);
   GET_PROC(GLXWAITXPROC, glXWaitX, EGL_TRUE);

   /* GLX 1.1 */
   GET_PROC(GLXQUERYEXTENSIONSSTRINGPROC, glXQueryExtensionsString, EGL_TRUE);
   GET_PROC(GLXQUERYSERVERSTRINGPROC, glXQueryServerString, EGL_TRUE);
   GET_PROC(GLXGETCLIENTSTRINGPROC, glXGetClientString, EGL_TRUE);

   /* GLX 1.3 */
   GET_PROC(PFNGLXGETFBCONFIGSPROC, glXGetFBConfigs, EGL_FALSE);
   GET_PROC(PFNGLXGETFBCONFIGATTRIBPROC, glXGetFBConfigAttrib, EGL_FALSE);
   GET_PROC(PFNGLXGETVISUALFROMFBCONFIGPROC, glXGetVisualFromFBConfig, EGL_FALSE);
   GET_PROC(PFNGLXCREATEWINDOWPROC, glXCreateWindow, EGL_FALSE);
   GET_PROC(PFNGLXDESTROYWINDOWPROC, glXDestroyWindow, EGL_FALSE);
   GET_PROC(PFNGLXCREATEPIXMAPPROC, glXCreatePixmap, EGL_FALSE);
   GET_PROC(PFNGLXDESTROYPIXMAPPROC, glXDestroyPixmap, EGL_FALSE);
   GET_PROC(PFNGLXCREATEPBUFFERPROC, glXCreatePbuffer, EGL_FALSE);
   GET_PROC(PFNGLXDESTROYPBUFFERPROC, glXDestroyPbuffer, EGL_FALSE);
   GET_PROC(PFNGLXCREATENEWCONTEXTPROC, glXCreateNewContext, EGL_FALSE);
   GET_PROC(PFNGLXMAKECONTEXTCURRENTPROC, glXMakeContextCurrent, EGL_FALSE);

   /* GLX_SGIX_pbuffer */
   GET_PROC(PFNGLXCREATEGLXPBUFFERSGIXPROC,
         glXCreateGLXPbufferSGIX, EGL_FALSE);
   GET_PROC(PFNGLXDESTROYGLXPBUFFERSGIXPROC,
         glXDestroyGLXPbufferSGIX, EGL_FALSE);
#undef GET_PROC

   GLX_drv->handle = handle;

   return EGL_TRUE;

fail:
   if (handle)
      dlclose(handle);
   return EGL_FALSE;
}


/**
 * This is the main entrypoint into the driver, called by libEGL.
 * Create a new _EGLDriver object and init its dispatch table.
 */
_EGLDriver *
_eglBuiltInDriverGLX(const char *args)
{
   struct GLX_egl_driver *GLX_drv = CALLOC_STRUCT(GLX_egl_driver);

   (void) args;

   if (!GLX_drv)
      return NULL;

   if (!GLX_Load(&GLX_drv->Base)) {
      _eglLog(_EGL_WARNING, "GLX: failed to load GLX");
      free(GLX_drv);
      return NULL;
   }

   _eglInitDriverFallbacks(&GLX_drv->Base);
   GLX_drv->Base.API.Initialize = GLX_eglInitialize;
   GLX_drv->Base.API.Terminate = GLX_eglTerminate;
   GLX_drv->Base.API.CreateContext = GLX_eglCreateContext;
   GLX_drv->Base.API.DestroyContext = GLX_eglDestroyContext;
   GLX_drv->Base.API.MakeCurrent = GLX_eglMakeCurrent;
   GLX_drv->Base.API.CreateWindowSurface = GLX_eglCreateWindowSurface;
   GLX_drv->Base.API.CreatePixmapSurface = GLX_eglCreatePixmapSurface;
   GLX_drv->Base.API.CreatePbufferSurface = GLX_eglCreatePbufferSurface;
   GLX_drv->Base.API.DestroySurface = GLX_eglDestroySurface;
   GLX_drv->Base.API.SwapBuffers = GLX_eglSwapBuffers;
   GLX_drv->Base.API.GetProcAddress = GLX_eglGetProcAddress;
   GLX_drv->Base.API.WaitClient = GLX_eglWaitClient;
   GLX_drv->Base.API.WaitNative = GLX_eglWaitNative;

   GLX_drv->Base.Name = "GLX";
   GLX_drv->Base.Unload = GLX_Unload;

   return &GLX_drv->Base;
}
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d658 2
a659 4
   if (GLX_dpy->visuals)
      XFree(GLX_dpy->visuals);
   if (GLX_dpy->fbconfigs)
      XFree(GLX_dpy->fbconfigs);
d714 19
d810 1
a810 1
get_drawable_size(Display *dpy, Drawable d, uint *width, uint *height)
d833 1
a833 1
   uint width, height;
d881 1
a881 1
   uint width, height;
d910 1
a910 1
         XFree(vinfo);
d1071 1
a1071 5
   void *handle;

   handle = dlopen("libGL.so", RTLD_LAZY | RTLD_LOCAL);
   if (!handle)
      goto fail;
d1073 1
a1073 1
   GLX_drv->glXGetProcAddress = dlsym(handle, "glXGetProcAddress");
d1075 12
a1086 3
      GLX_drv->glXGetProcAddress = dlsym(handle, "glXGetProcAddressARB");
   if (!GLX_drv->glXGetProcAddress)
      goto fail;
d1148 1
a1148 1
_EGL_MAIN(const char *args)
d1167 1
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d2 1
a2 1
 * 
d4 2
d7 1
a7 1
 * 
d15 1
a15 1
 * 
d19 9
a27 9
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
d41 2
a42 2
#include <GL/glx.h>
#include <EGL/egl.h>
d59 17
d80 39
a136 4
   /* GLX_SGIX_pbuffer */
   PFNGLXCREATEGLXPBUFFERSGIXPROC glXCreateGLXPbufferSGIX;
   PFNGLXDESTROYGLXPBUFFERSGIXPROC glXDestroyGLXPbufferSGIX;

a139 1

d224 2
a225 1
convert_fbconfig(Display *dpy, GLXFBConfig fbconfig,
d228 1
d233 1
a233 1
   err = glXGetFBConfigAttrib(dpy, fbconfig, GLX_RENDER_TYPE, &val);
d238 1
a238 1
   err = glXGetFBConfigAttrib(dpy, fbconfig, GLX_DOUBLEBUFFER, &val);
d254 1
a254 1
      err = glXGetFBConfigAttrib(dpy, fbconfig, attr, &val);
d361 2
a362 1
convert_visual(Display *dpy, XVisualInfo *vinfo,
d365 1
d370 1
a370 1
   err = glXGetConfig(dpy, vinfo, GLX_USE_GL, &val);
d372 1
a372 1
      err = glXGetConfig(dpy, vinfo, GLX_RGBA, &val);
d377 1
a377 1
   err = glXGetConfig(dpy, vinfo, GLX_DOUBLEBUFFER, &val);
d401 1
a401 1
      err = glXGetConfig(dpy, vinfo, attr, &val);
d466 1
a466 2
create_configs(_EGLDisplay *dpy, struct GLX_egl_display *GLX_dpy,
               EGLint screen)
d468 2
d474 2
a475 1
      GLX_dpy->fbconfigs = glXGetFBConfigs(GLX_dpy->dpy, screen, &num_configs);
d496 8
a503 4
      if (GLX_dpy->have_fbconfig)
         ok = convert_fbconfig(GLX_dpy->dpy, GLX_dpy->fbconfigs[i], &template);
      else
         ok = convert_visual(GLX_dpy->dpy, &GLX_dpy->visuals[i], &template);
d528 2
a529 1
check_extensions(struct GLX_egl_display *GLX_dpy, EGLint screen)
d532 1
a532 1
      glXQueryExtensionsString(GLX_dpy->dpy, screen);
a533 2
      /* glXGetProcAddress is assumed */

d545 2
a546 7
         GLX_dpy->glXCreateGLXPbufferSGIX = (PFNGLXCREATEGLXPBUFFERSGIXPROC)
            glXGetProcAddress((const GLubyte *) "glXCreateGLXPbufferSGIX");
         GLX_dpy->glXDestroyGLXPbufferSGIX = (PFNGLXDESTROYGLXPBUFFERSGIXPROC)
            glXGetProcAddress((const GLubyte *) "glXDestroyGLXPbufferSGIX");

         if (GLX_dpy->glXCreateGLXPbufferSGIX &&
             GLX_dpy->glXDestroyGLXPbufferSGIX &&
d562 2
a563 1
check_quirks(struct GLX_egl_display *GLX_dpy, EGLint screen)
d570 1
a570 1
   vendor = glXGetClientString(GLX_dpy->dpy, GLX_VENDOR);
d572 1
a572 1
      vendor = glXQueryServerString(GLX_dpy->dpy, screen, GLX_VENDOR);
d586 1
a586 2
GLX_eglInitialize(_EGLDriver *drv, _EGLDisplay *disp,
                   EGLint *major, EGLint *minor)
d588 1
d591 2
a592 1
   (void) drv;
d594 2
a595 1
   if (disp->Platform != _EGL_PLATFORM_X11)
d598 3
d615 2
a616 1
   if (!glXQueryVersion(GLX_dpy->dpy, &GLX_dpy->glx_maj, &GLX_dpy->glx_min)) {
d624 5
a628 2
   check_extensions(GLX_dpy, DefaultScreen(GLX_dpy->dpy));
   check_quirks(GLX_dpy, DefaultScreen(GLX_dpy->dpy));
d630 1
a630 1
   create_configs(disp, GLX_dpy, DefaultScreen(GLX_dpy->dpy));
a638 3
   disp->DriverData = (void *) GLX_dpy;
   disp->ClientAPIsMask = EGL_OPENGL_BIT;

d640 2
a641 2
   *major = 1;
   *minor = 4;
d646 1
d680 1
a684 2
   (void) drv;

d695 13
a707 13
   if (GLX_dpy->have_fbconfig)
      GLX_ctx->context =
         glXCreateNewContext(GLX_dpy->dpy,
                             GLX_dpy->fbconfigs[GLX_egl_config_index(conf)],
                             GLX_RGBA_TYPE,
                             GLX_ctx_shared ? GLX_ctx_shared->context : NULL,
                             GL_TRUE);
   else
      GLX_ctx->context =
         glXCreateContext(GLX_dpy->dpy,
                          &GLX_dpy->visuals[GLX_egl_config_index(conf)],
                          GLX_ctx_shared ? GLX_ctx_shared->context : NULL,
                          GL_TRUE);
d740 1
a750 2
   (void) drv;

d760 1
a760 1
      ret = glXMakeContextCurrent(GLX_dpy->dpy, ddraw, rdraw, cctx);
d762 1
a762 1
      ret = glXMakeCurrent(GLX_dpy->dpy, ddraw, cctx);
d813 1
a817 2
   (void) drv;

d832 6
a837 6
   if (GLX_dpy->have_1_3 && !GLX_dpy->glx_window_quirk)
      GLX_surf->glx_drawable =
         glXCreateWindow(GLX_dpy->dpy,
                         GLX_dpy->fbconfigs[GLX_egl_config_index(conf)],
                         GLX_surf->drawable, NULL);
   else
d839 1
d847 1
a847 1
      GLX_surf->destroy = glXDestroyWindow;
d861 1
a865 2
   (void) drv;

d881 3
a883 4
      GLX_surf->glx_drawable =
         glXCreatePixmap(GLX_dpy->dpy,
                         GLX_dpy->fbconfigs[GLX_egl_config_index(conf)],
                         GLX_surf->drawable, NULL);
d887 3
a889 1
      XVisualInfo *vinfo = glXGetVisualFromFBConfig(GLX_dpy->dpy, fbconfig);
d891 2
a892 2
         GLX_surf->glx_drawable =
            glXCreateGLXPixmap(GLX_dpy->dpy, vinfo, GLX_surf->drawable);
d897 3
a899 4
      GLX_surf->glx_drawable =
         glXCreateGLXPixmap(GLX_dpy->dpy,
                            &GLX_dpy->visuals[GLX_egl_config_index(conf)],
                            GLX_surf->drawable);
d908 1
a908 1
      glXDestroyPixmap : glXDestroyGLXPixmap;
d921 1
a926 2
   (void) drv;

d956 2
a957 4
      GLX_surf->glx_drawable =
         glXCreatePbuffer(GLX_dpy->dpy,
                          GLX_dpy->fbconfigs[GLX_egl_config_index(conf)],
                          attribs);
d960 1
a960 2
      GLX_surf->glx_drawable = GLX_dpy->glXCreateGLXPbufferSGIX(
            GLX_dpy->dpy,
d973 1
a973 1
      glXDestroyPbuffer : GLX_dpy->glXDestroyGLXPbufferSGIX;
d994 1
d998 1
a998 3
   (void) drv;

   glXSwapBuffers(GLX_dpy->dpy, GLX_surf->glx_drawable);
d1009 1
a1009 1
   (void) drv;
d1011 1
a1011 1
   return (_EGLProc) glXGetProcAddress((const GLubyte *) procname);
d1017 2
a1018 1
   (void) drv;
d1022 1
a1022 1
   glXWaitGL();
d1029 2
a1030 1
   (void) drv;
d1035 1
a1035 1
   glXWaitX();
d1043 3
d1050 71
d1126 1
a1126 1
_eglMain(const char *args)
d1134 6
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d40 1
a41 1
#include "eglconfigutil.h"
d44 1
a51 1
#define ARRAY_SIZE(a)      (sizeof(a) / sizeof(a[0]))
a129 4
#define MAP_ATTRIB(attr, memb) \
   { attr, offsetof(__GLcontextModes, memb) }


d132 1
a132 1
   int offset;
d135 32
a166 33
   MAP_ATTRIB(GLX_FBCONFIG_ID,                  fbconfigID),
   MAP_ATTRIB(GLX_BUFFER_SIZE,                  rgbBits),
   MAP_ATTRIB(GLX_LEVEL,                        level),
   MAP_ATTRIB(GLX_DOUBLEBUFFER,                 doubleBufferMode),
   MAP_ATTRIB(GLX_STEREO,                       stereoMode),
   MAP_ATTRIB(GLX_AUX_BUFFERS,                  numAuxBuffers),
   MAP_ATTRIB(GLX_RED_SIZE,                     redBits),
   MAP_ATTRIB(GLX_GREEN_SIZE,                   greenBits),
   MAP_ATTRIB(GLX_BLUE_SIZE,                    blueBits),
   MAP_ATTRIB(GLX_ALPHA_SIZE,                   alphaBits),
   MAP_ATTRIB(GLX_DEPTH_SIZE,                   depthBits),
   MAP_ATTRIB(GLX_STENCIL_SIZE,                 stencilBits),
   MAP_ATTRIB(GLX_ACCUM_RED_SIZE,               accumRedBits),
   MAP_ATTRIB(GLX_ACCUM_GREEN_SIZE,             accumGreenBits),
   MAP_ATTRIB(GLX_ACCUM_BLUE_SIZE,              accumBlueBits),
   MAP_ATTRIB(GLX_ACCUM_ALPHA_SIZE,             accumAlphaBits),
   MAP_ATTRIB(GLX_SAMPLE_BUFFERS,               sampleBuffers),
   MAP_ATTRIB(GLX_SAMPLES,                      samples),
   MAP_ATTRIB(GLX_RENDER_TYPE,                  renderType),
   MAP_ATTRIB(GLX_DRAWABLE_TYPE,                drawableType),
   MAP_ATTRIB(GLX_X_RENDERABLE,                 xRenderable),
   MAP_ATTRIB(GLX_X_VISUAL_TYPE,                visualType),
   MAP_ATTRIB(GLX_CONFIG_CAVEAT,                visualRating),
   MAP_ATTRIB(GLX_TRANSPARENT_TYPE,             transparentPixel),
   MAP_ATTRIB(GLX_TRANSPARENT_INDEX_VALUE,      transparentIndex),
   MAP_ATTRIB(GLX_TRANSPARENT_RED_VALUE,        transparentRed),
   MAP_ATTRIB(GLX_TRANSPARENT_GREEN_VALUE,      transparentGreen),
   MAP_ATTRIB(GLX_TRANSPARENT_BLUE_VALUE,       transparentBlue),
   MAP_ATTRIB(GLX_TRANSPARENT_ALPHA_VALUE,      transparentAlpha),
   MAP_ATTRIB(GLX_MAX_PBUFFER_WIDTH,            maxPbufferWidth),
   MAP_ATTRIB(GLX_MAX_PBUFFER_HEIGHT,           maxPbufferHeight),
   MAP_ATTRIB(GLX_MAX_PBUFFER_PIXELS,           maxPbufferPixels),
   MAP_ATTRIB(GLX_VISUAL_ID,                    visualID),
d174 7
a180 2
   __GLcontextModes mode;
   int err = 0, attr, val, i;
d182 8
a189 1
   memset(&mode, 0, sizeof(mode));
d192 2
a193 1
      int offset = fbconfig_attributes[i].offset;
d195 4
d207 59
a265 1
      *((int *) ((char *) &mode + offset)) = val;
d270 1
a270 2
   /* must have rgba bit */
   if (!(mode.renderType & GLX_RGBA_BIT))
d273 1
a273 18
   /* pixmap and pbuffer surfaces must be single-buffered in EGL */
   if (mode.doubleBufferMode) {
      mode.drawableType &= ~(GLX_PIXMAP_BIT | GLX_PBUFFER_BIT);
      if (!mode.drawableType)
         return EGL_FALSE;
   }

   mode.rgbMode = GL_TRUE;
   mode.haveAccumBuffer = (mode.accumRedBits +
                           mode.accumGreenBits +
                           mode.accumBlueBits +
                           mode.accumAlphaBits > 0);
   mode.haveDepthBuffer = (mode.depthBits > 0);
   mode.haveStencilBuffer = (mode.stencilBits > 0);

   GLX_conf->double_buffered = (mode.doubleBufferMode != 0);
   return _eglConfigFromContextModesRec(&GLX_conf->Base, &mode,
                                        EGL_OPENGL_BIT, EGL_OPENGL_BIT);
a275 1

d278 1
a278 1
   int offset;
d281 20
a300 20
   /* no GLX_USE_GL */
   MAP_ATTRIB(GLX_BUFFER_SIZE,         rgbBits),
   MAP_ATTRIB(GLX_LEVEL,               level),
   MAP_ATTRIB(GLX_RGBA,                rgbMode),
   MAP_ATTRIB(GLX_DOUBLEBUFFER,        doubleBufferMode),
   MAP_ATTRIB(GLX_STEREO,              stereoMode),
   MAP_ATTRIB(GLX_AUX_BUFFERS,         numAuxBuffers),
   MAP_ATTRIB(GLX_RED_SIZE,            redBits),
   MAP_ATTRIB(GLX_GREEN_SIZE,          greenBits),
   MAP_ATTRIB(GLX_BLUE_SIZE,           blueBits),
   MAP_ATTRIB(GLX_ALPHA_SIZE,          alphaBits),
   MAP_ATTRIB(GLX_DEPTH_SIZE,          depthBits),
   MAP_ATTRIB(GLX_STENCIL_SIZE,        stencilBits),
   MAP_ATTRIB(GLX_ACCUM_RED_SIZE,      accumRedBits),
   MAP_ATTRIB(GLX_ACCUM_GREEN_SIZE,    accumGreenBits),
   MAP_ATTRIB(GLX_ACCUM_BLUE_SIZE,     accumBlueBits),
   MAP_ATTRIB(GLX_ACCUM_ALPHA_SIZE,    accumAlphaBits),
   MAP_ATTRIB(GLX_SAMPLE_BUFFERS,      sampleBuffers),
   MAP_ATTRIB(GLX_SAMPLES,             samples),
   MAP_ATTRIB(GLX_FBCONFIG_ID,         fbconfigID),
d302 1
a302 1
   MAP_ATTRIB(GLX_VISUAL_CAVEAT_EXT,   visualRating),
a304 31

static int
get_visual_type(const XVisualInfo *vis)
{
   int klass;

#if defined(__cplusplus) || defined(c_plusplus)
   klass = vis->c_class;
#else
   klass = vis->class;
#endif

   switch (klass) {
   case TrueColor:
      return GLX_TRUE_COLOR;
   case DirectColor:
      return GLX_DIRECT_COLOR;
   case PseudoColor:
      return GLX_PSEUDO_COLOR;
   case StaticColor:
      return GLX_STATIC_COLOR;
   case GrayScale:
      return GLX_GRAY_SCALE;
   case StaticGray:
      return GLX_STATIC_GRAY;
   default:
      return GLX_NONE;
   }
}


d309 2
a310 2
   __GLcontextModes mode;
   int err, attr, val, i;
d312 1
a312 1
   /* the visual must support OpenGL */
d314 2
d319 16
a334 1
   memset(&mode, 0, sizeof(mode));
d337 2
a338 1
      int offset = visual_attributes[i].offset;
d340 4
d352 18
a369 1
      *((int *) ((char *) &mode + offset)) = val;
a370 12
   if (err)
      return EGL_FALSE;

   /* must be RGB mode */
   if (!mode.rgbMode)
      return EGL_FALSE;

   mode.visualID = vinfo->visualid;
   mode.visualType = get_visual_type(vinfo);
   mode.redMask = vinfo->red_mask;
   mode.greenMask = vinfo->green_mask;
   mode.blueMask = vinfo->blue_mask;
d372 1
a372 17
   mode.drawableType = GLX_WINDOW_BIT;
   /* pixmap surfaces must be single-buffered in EGL */
   if (!mode.doubleBufferMode)
      mode.drawableType |= GLX_PIXMAP_BIT;

   mode.renderType = GLX_RGBA_BIT;
   mode.xRenderable = GL_TRUE;
   mode.haveAccumBuffer = (mode.accumRedBits +
                           mode.accumGreenBits +
                           mode.accumBlueBits +
                           mode.accumAlphaBits > 0);
   mode.haveDepthBuffer = (mode.depthBits > 0);
   mode.haveStencilBuffer = (mode.stencilBits > 0);

   GLX_conf->double_buffered = (mode.doubleBufferMode != 0);
   return _eglConfigFromContextModesRec(&GLX_conf->Base, &mode,
                                        EGL_OPENGL_BIT, EGL_OPENGL_BIT);
a379 1
   EGLint surface_type, r, g, b, a;
a380 1
   surface_type = GET_CONFIG_ATTRIB(conf, EGL_SURFACE_TYPE);
d383 1
a383 1
      surface_type &= ~EGL_WINDOW_BIT;
d386 1
a386 2
         surface_type |= EGL_PBUFFER_BIT;
      SET_CONFIG_ATTRIB(conf, EGL_SURFACE_TYPE, surface_type);
d390 10
a399 3
   if (!(surface_type & EGL_WINDOW_BIT)) {
      SET_CONFIG_ATTRIB(conf, EGL_NATIVE_VISUAL_ID, 0);
      SET_CONFIG_ATTRIB(conf, EGL_NATIVE_VISUAL_TYPE, EGL_NONE);
d403 2
a404 5
   r = GET_CONFIG_ATTRIB(conf, EGL_RED_SIZE);
   g = GET_CONFIG_ATTRIB(conf, EGL_GREEN_SIZE);
   b = GET_CONFIG_ATTRIB(conf, EGL_BLUE_SIZE);
   a = GET_CONFIG_ATTRIB(conf, EGL_ALPHA_SIZE);
   SET_CONFIG_ATTRIB(conf, EGL_BUFFER_SIZE, r + g + b + a);
d455 1
a455 1
         _eglAddConfig(dpy, &GLX_conf->Base);
d533 5
d542 1
a542 1
   GLX_dpy->dpy = (Display *) disp->NativeDisplay;
d554 1
a554 1
      if (!disp->NativeDisplay)
d564 1
a564 1
   if (!disp->NumConfigs) {
d566 1
a566 1
      if (!disp->NativeDisplay)
d598 1
a598 1
   if (!disp->NativeDisplay)
d619 2
d659 1
d663 1
a663 1
      GLX_surf->destroy(disp->NativeDisplay, GLX_surf->glx_drawable);
d680 2
d686 4
a689 2
   /* bind the new context and return the "orphaned" one */
   if (!_eglBindContext(&ctx, &dsurf, &rsurf))
d702 6
a707 4
      if (dsurf && !_eglIsSurfaceLinked(dsurf))
         destroy_surface(disp, dsurf);
      if (rsurf && rsurf != dsurf && !_eglIsSurfaceLinked(rsurf))
         destroy_surface(disp, rsurf);
d710 13
a722 1
      _eglBindContext(&ctx, &dsurf, &rsurf);
d754 2
d802 2
d864 2
d924 3
a926 1
   if (!_eglIsSurfaceBound(surf))
d939 2
d952 2
d960 4
d971 3
d996 2
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a39 1
#include <EGL/egl.h>
d41 1
a43 1
#include "egldefines.h"
d51 1
d130 4
d136 1
a136 1
   int egl_attr;
d139 33
a171 32
   { GLX_FBCONFIG_ID,                  0 },
   { GLX_BUFFER_SIZE,                  EGL_BUFFER_SIZE },
   { GLX_LEVEL,                        EGL_LEVEL },
   { GLX_DOUBLEBUFFER,                 0 },
   { GLX_STEREO,                       0 },
   { GLX_AUX_BUFFERS,                  0 },
   { GLX_RED_SIZE,                     EGL_RED_SIZE },
   { GLX_GREEN_SIZE,                   EGL_GREEN_SIZE },
   { GLX_BLUE_SIZE,                    EGL_BLUE_SIZE },
   { GLX_ALPHA_SIZE,                   EGL_ALPHA_SIZE },
   { GLX_DEPTH_SIZE,                   EGL_DEPTH_SIZE },
   { GLX_STENCIL_SIZE,                 EGL_STENCIL_SIZE },
   { GLX_ACCUM_RED_SIZE,               0 },
   { GLX_ACCUM_GREEN_SIZE,             0 },
   { GLX_ACCUM_BLUE_SIZE,              0 },
   { GLX_ACCUM_ALPHA_SIZE,             0 },
   { GLX_SAMPLE_BUFFERS,               EGL_SAMPLE_BUFFERS },
   { GLX_SAMPLES,                      EGL_SAMPLES },
   { GLX_RENDER_TYPE,                  0 },
   { GLX_DRAWABLE_TYPE,                EGL_SURFACE_TYPE },
   { GLX_X_RENDERABLE,                 EGL_NATIVE_RENDERABLE },
   { GLX_X_VISUAL_TYPE,                EGL_NATIVE_VISUAL_TYPE },
   { GLX_CONFIG_CAVEAT,                EGL_CONFIG_CAVEAT },
   { GLX_TRANSPARENT_TYPE,             EGL_TRANSPARENT_TYPE },
   { GLX_TRANSPARENT_INDEX_VALUE,      0 },
   { GLX_TRANSPARENT_RED_VALUE,        EGL_TRANSPARENT_RED_VALUE },
   { GLX_TRANSPARENT_GREEN_VALUE,      EGL_TRANSPARENT_GREEN_VALUE },
   { GLX_TRANSPARENT_BLUE_VALUE,       EGL_TRANSPARENT_BLUE_VALUE },
   { GLX_MAX_PBUFFER_WIDTH,            EGL_MAX_PBUFFER_WIDTH },
   { GLX_MAX_PBUFFER_HEIGHT,           EGL_MAX_PBUFFER_HEIGHT },
   { GLX_MAX_PBUFFER_PIXELS,           EGL_MAX_PBUFFER_PIXELS },
   { GLX_VISUAL_ID,                    EGL_NATIVE_VISUAL_ID }
d179 2
a180 7
   int err, attr, val;
   unsigned i;

   /* must have rgba bit */
   err = glXGetFBConfigAttrib(dpy, fbconfig, GLX_RENDER_TYPE, &val);
   if (err || !(val & GLX_RGBA_BIT))
      return EGL_FALSE;
d182 1
a182 8
   /* must know whether it is double-buffered */
   err = glXGetFBConfigAttrib(dpy, fbconfig, GLX_DOUBLEBUFFER, &val);
   if (err)
      return EGL_FALSE;
   GLX_conf->double_buffered = val;

   GLX_conf->Base.RenderableType = EGL_OPENGL_BIT;
   GLX_conf->Base.Conformant = EGL_OPENGL_BIT;
d185 1
a185 2
      EGLint egl_attr, egl_val;

a186 4
      egl_attr = fbconfig_attributes[i].egl_attr;
      if (!egl_attr)
         continue;

d195 1
a195 59

      switch (egl_attr) {
      case EGL_SURFACE_TYPE:
         egl_val = 0;
         if (val & GLX_WINDOW_BIT)
            egl_val |= EGL_WINDOW_BIT;
         /* pixmap and pbuffer surfaces must be single-buffered in EGL */
         if (!GLX_conf->double_buffered) {
            if (val & GLX_PIXMAP_BIT)
               egl_val |= EGL_PIXMAP_BIT;
            if (val & GLX_PBUFFER_BIT)
               egl_val |= EGL_PBUFFER_BIT;
         }
         break;
      case EGL_NATIVE_VISUAL_TYPE:
         switch (val) {
         case GLX_TRUE_COLOR:
            egl_val = TrueColor;
            break;
         case GLX_DIRECT_COLOR:
            egl_val = DirectColor;
            break;
         case GLX_PSEUDO_COLOR:
            egl_val = PseudoColor;
            break;
         case GLX_STATIC_COLOR:
            egl_val = StaticColor;
            break;
         case GLX_GRAY_SCALE:
            egl_val = GrayScale;
            break;
         case GLX_STATIC_GRAY:
            egl_val = StaticGray;
            break;
         default:
            egl_val = EGL_NONE;
            break;
         }
         break;
      case EGL_CONFIG_CAVEAT:
         egl_val = EGL_NONE;
         if (val == GLX_SLOW_CONFIG) {
            egl_val = EGL_SLOW_CONFIG;
         }
         else if (val == GLX_NON_CONFORMANT_CONFIG) {
            GLX_conf->Base.Conformant &= ~EGL_OPENGL_BIT;
            egl_val = EGL_NONE;
         }
         break;
      case EGL_TRANSPARENT_TYPE:
         egl_val = (val == GLX_TRANSPARENT_RGB) ?
            EGL_TRANSPARENT_RGB : EGL_NONE;
         break;
      default:
         egl_val = val;
         break;
      }

      _eglSetConfigKey(&GLX_conf->Base, egl_attr, egl_val);
d200 2
a201 1
   if (!GLX_conf->Base.SurfaceType)
d204 18
a221 1
   return EGL_TRUE;
d224 1
d227 1
a227 1
   int egl_attr;
d230 20
a249 20
   { GLX_USE_GL,              0 },
   { GLX_BUFFER_SIZE,         EGL_BUFFER_SIZE },
   { GLX_LEVEL,               EGL_LEVEL },
   { GLX_RGBA,                0 },
   { GLX_DOUBLEBUFFER,        0 },
   { GLX_STEREO,              0 },
   { GLX_AUX_BUFFERS,         0 },
   { GLX_RED_SIZE,            EGL_RED_SIZE },
   { GLX_GREEN_SIZE,          EGL_GREEN_SIZE },
   { GLX_BLUE_SIZE,           EGL_BLUE_SIZE },
   { GLX_ALPHA_SIZE,          EGL_ALPHA_SIZE },
   { GLX_DEPTH_SIZE,          EGL_DEPTH_SIZE },
   { GLX_STENCIL_SIZE,        EGL_STENCIL_SIZE },
   { GLX_ACCUM_RED_SIZE,      0 },
   { GLX_ACCUM_GREEN_SIZE,    0 },
   { GLX_ACCUM_BLUE_SIZE,     0 },
   { GLX_ACCUM_ALPHA_SIZE,    0 },
   { GLX_SAMPLE_BUFFERS,      EGL_SAMPLE_BUFFERS },
   { GLX_SAMPLES,             EGL_SAMPLES },
   { GLX_FBCONFIG_ID,         0 },
d251 1
a251 1
   { GLX_VISUAL_CAVEAT_EXT,   EGL_CONFIG_CAVEAT }
d254 31
d289 2
a290 2
   int err, attr, val;
   unsigned i;
d292 1
a292 1
   /* the visual must support OpenGL and RGBA buffer */
a293 2
   if (!err && val)
      err = glXGetConfig(dpy, vinfo, GLX_RGBA, &val);
d297 1
a297 16
   /* must know whether it is double-buffered */
   err = glXGetConfig(dpy, vinfo, GLX_DOUBLEBUFFER, &val);
   if (err)
      return EGL_FALSE;
   GLX_conf->double_buffered = val;

   GLX_conf->Base.RenderableType = EGL_OPENGL_BIT;
   GLX_conf->Base.Conformant = EGL_OPENGL_BIT;
   GLX_conf->Base.SurfaceType = EGL_WINDOW_BIT;
   /* pixmap surfaces must be single-buffered in EGL */
   if (!GLX_conf->double_buffered)
      GLX_conf->Base.SurfaceType |= EGL_PIXMAP_BIT;

   GLX_conf->Base.NativeVisualID = vinfo->visualid;
   GLX_conf->Base.NativeVisualType = vinfo->class;
   GLX_conf->Base.NativeRenderable = EGL_TRUE;
d300 1
a300 2
      EGLint egl_attr, egl_val;

a301 4
      egl_attr = visual_attributes[i].egl_attr;
      if (!egl_attr)
         continue;

d310 8
d319 10
a328 18
      switch (egl_attr) {
      case EGL_CONFIG_CAVEAT:
         egl_val = EGL_NONE;
         if (val == GLX_SLOW_VISUAL_EXT) {
            egl_val = EGL_SLOW_CONFIG;
         }
         else if (val == GLX_NON_CONFORMANT_VISUAL_EXT) {
            GLX_conf->Base.Conformant &= ~EGL_OPENGL_BIT;
            egl_val = EGL_NONE;
         }
         break;
         break;
      default:
         egl_val = val;
         break;
      }
      _eglSetConfigKey(&GLX_conf->Base, egl_attr, egl_val);
   }
d330 12
a341 1
   return (err) ? EGL_FALSE : EGL_TRUE;
d349 1
d351 1
d354 1
a354 1
      conf->SurfaceType &= ~EGL_WINDOW_BIT;
d357 2
a358 1
         conf->SurfaceType |= EGL_PBUFFER_BIT;
d362 3
a364 10
   if (!(conf->SurfaceType & EGL_WINDOW_BIT)) {
      conf->NativeVisualID = 0;
      conf->NativeVisualType = EGL_NONE;
   }

   if (conf->TransparentType != EGL_TRANSPARENT_RGB) {
      /* some impls set them to -1 (GLX_DONT_CARE) */
      conf->TransparentRedValue = 0;
      conf->TransparentGreenValue = 0;
      conf->TransparentBlueValue = 0;
d368 5
a372 2
   conf->BufferSize =
      conf->RedSize + conf->GreenSize + conf->BlueSize + conf->AlphaSize;
d423 1
a423 1
         _eglLinkConfig(&GLX_conf->Base);
a500 5
   (void) drv;

   if (disp->Platform != _EGL_PLATFORM_X11)
      return EGL_FALSE;

d505 1
a505 1
   GLX_dpy->dpy = (Display *) disp->PlatformDisplay;
d517 1
a517 1
      if (!disp->PlatformDisplay)
d527 1
a527 1
   if (!_eglGetArraySize(disp->Configs)) {
d529 1
a529 1
      if (!disp->PlatformDisplay)
d561 1
a561 1
   if (!disp->PlatformDisplay)
a581 2
   (void) drv;

a619 1
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(disp);
d623 1
a623 1
      GLX_surf->destroy(GLX_dpy->dpy, GLX_surf->glx_drawable);
a639 2
   _EGLContext *old_ctx;
   _EGLSurface *old_dsurf, *old_rsurf;
d644 2
a645 4
   (void) drv;

   /* make new bindings */
   if (!_eglBindContext(ctx, dsurf, rsurf, &old_ctx, &old_dsurf, &old_rsurf))
d658 4
a661 6
      if (_eglPutSurface(old_dsurf))
         destroy_surface(disp, old_dsurf);
      if (_eglPutSurface(old_rsurf))
         destroy_surface(disp, old_rsurf);
      /* no destroy? */
      _eglPutContext(old_ctx);
d664 1
a664 13
      /* undo the previous _eglBindContext */
      _eglBindContext(old_ctx, old_dsurf, old_rsurf, &ctx, &dsurf, &rsurf);
      assert(&GLX_ctx->Base == ctx &&
             &GLX_dsurf->Base == dsurf &&
             &GLX_rsurf->Base == rsurf);

      _eglPutSurface(dsurf);
      _eglPutSurface(rsurf);
      _eglPutContext(ctx);

      _eglPutSurface(old_dsurf);
      _eglPutSurface(old_rsurf);
      _eglPutContext(old_ctx);
a695 2
   (void) drv;

a741 2
   (void) drv;

a801 2
   (void) drv;

d860 1
a860 3
   (void) drv;

   if (_eglPutSurface(surf))
a872 2
   (void) drv;

a883 2
   (void) drv;

a889 4
   (void) drv;
   (void) dpy;
   (void) ctx;

a896 3
   (void) drv;
   (void) dpy;

a918 2

   (void) args;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d2 1
a2 1
 *
a3 2
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright 2010-2011 LunarG, Inc.
d5 1
a5 1
 *
d13 1
a13 1
 *
d17 9
a25 9
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
d39 2
a40 2
#include <dlfcn.h>
#include "GL/glx.h"
a56 17
/* GLX 1.0 */
typedef GLXContext (*GLXCREATECONTEXTPROC)( Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct );
typedef void (*GLXDESTROYCONTEXTPROC)( Display *dpy, GLXContext ctx );
typedef Bool (*GLXMAKECURRENTPROC)( Display *dpy, GLXDrawable drawable, GLXContext ctx);
typedef void (*GLXSWAPBUFFERSPROC)( Display *dpy, GLXDrawable drawable );
typedef GLXPixmap (*GLXCREATEGLXPIXMAPPROC)( Display *dpy, XVisualInfo *visual, Pixmap pixmap );
typedef void (*GLXDESTROYGLXPIXMAPPROC)( Display *dpy, GLXPixmap pixmap );
typedef Bool (*GLXQUERYVERSIONPROC)( Display *dpy, int *maj, int *min );
typedef int (*GLXGETCONFIGPROC)( Display *dpy, XVisualInfo *visual, int attrib, int *value );
typedef void (*GLXWAITGLPROC)( void );
typedef void (*GLXWAITXPROC)( void );

/* GLX 1.1 */
typedef const char *(*GLXQUERYEXTENSIONSSTRINGPROC)( Display *dpy, int screen );
typedef const char *(*GLXQUERYSERVERSTRINGPROC)( Display *dpy, int screen, int name );
typedef const char *(*GLXGETCLIENTSTRINGPROC)( Display *dpy, int name );

a60 39

   void *handle;

   /* GLX 1.0 */
   GLXCREATECONTEXTPROC glXCreateContext;
   GLXDESTROYCONTEXTPROC glXDestroyContext;
   GLXMAKECURRENTPROC glXMakeCurrent;
   GLXSWAPBUFFERSPROC glXSwapBuffers;
   GLXCREATEGLXPIXMAPPROC glXCreateGLXPixmap;
   GLXDESTROYGLXPIXMAPPROC glXDestroyGLXPixmap;
   GLXQUERYVERSIONPROC glXQueryVersion;
   GLXGETCONFIGPROC glXGetConfig;
   GLXWAITGLPROC glXWaitGL;
   GLXWAITXPROC glXWaitX;

   /* GLX 1.1 */
   GLXQUERYEXTENSIONSSTRINGPROC glXQueryExtensionsString;
   GLXQUERYSERVERSTRINGPROC glXQueryServerString;
   GLXGETCLIENTSTRINGPROC glXGetClientString;

   /* GLX 1.3 or (GLX_SGI_make_current_read and GLX_SGIX_fbconfig) */
   PFNGLXGETFBCONFIGSPROC glXGetFBConfigs;
   PFNGLXGETFBCONFIGATTRIBPROC glXGetFBConfigAttrib;
   PFNGLXGETVISUALFROMFBCONFIGPROC glXGetVisualFromFBConfig;
   PFNGLXCREATEWINDOWPROC glXCreateWindow;
   PFNGLXDESTROYWINDOWPROC glXDestroyWindow;
   PFNGLXCREATEPIXMAPPROC glXCreatePixmap;
   PFNGLXDESTROYPIXMAPPROC glXDestroyPixmap;
   PFNGLXCREATEPBUFFERPROC glXCreatePbuffer;
   PFNGLXDESTROYPBUFFERPROC glXDestroyPbuffer;
   PFNGLXCREATENEWCONTEXTPROC glXCreateNewContext;
   PFNGLXMAKECONTEXTCURRENTPROC glXMakeContextCurrent;

   /* GLX 1.4 or GLX_ARB_get_proc_address */
   PFNGLXGETPROCADDRESSPROC glXGetProcAddress;

   /* GLX_SGIX_pbuffer */
   PFNGLXCREATEGLXPBUFFERSGIXPROC glXCreateGLXPbufferSGIX;
   PFNGLXDESTROYGLXPBUFFERSGIXPROC glXDestroyGLXPbufferSGIX;
d79 4
d86 1
d171 1
a171 2
convert_fbconfig(struct GLX_egl_driver *GLX_drv,
                 struct GLX_egl_display *GLX_dpy, GLXFBConfig fbconfig,
a173 1
   Display *dpy = GLX_dpy->dpy;
d178 1
a178 1
   err = GLX_drv->glXGetFBConfigAttrib(dpy, fbconfig, GLX_RENDER_TYPE, &val);
d183 1
a183 1
   err = GLX_drv->glXGetFBConfigAttrib(dpy, fbconfig, GLX_DOUBLEBUFFER, &val);
d199 1
a199 1
      err = GLX_drv->glXGetFBConfigAttrib(dpy, fbconfig, attr, &val);
d306 1
a306 2
convert_visual(struct GLX_egl_driver *GLX_drv,
               struct GLX_egl_display *GLX_dpy, XVisualInfo *vinfo,
a308 1
   Display *dpy = GLX_dpy->dpy;
d313 1
a313 1
   err = GLX_drv->glXGetConfig(dpy, vinfo, GLX_USE_GL, &val);
d315 1
a315 1
      err = GLX_drv->glXGetConfig(dpy, vinfo, GLX_RGBA, &val);
d320 1
a320 1
   err = GLX_drv->glXGetConfig(dpy, vinfo, GLX_DOUBLEBUFFER, &val);
d344 1
a344 1
      err = GLX_drv->glXGetConfig(dpy, vinfo, attr, &val);
d409 2
a410 1
create_configs(_EGLDriver *drv, _EGLDisplay *dpy, EGLint screen)
a411 2
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(dpy);
d416 1
a416 2
      GLX_dpy->fbconfigs =
         GLX_drv->glXGetFBConfigs(GLX_dpy->dpy, screen, &num_configs);
d437 4
a440 8
      if (GLX_dpy->have_fbconfig) {
         ok = convert_fbconfig(GLX_drv, GLX_dpy,
               GLX_dpy->fbconfigs[i], &template);
      }
      else {
         ok = convert_visual(GLX_drv, GLX_dpy,
               &GLX_dpy->visuals[i], &template);
      }
d465 1
a465 2
check_extensions(struct GLX_egl_driver *GLX_drv,
                 struct GLX_egl_display *GLX_dpy, EGLint screen)
d468 1
a468 1
      GLX_drv->glXQueryExtensionsString(GLX_dpy->dpy, screen);
d470 2
d483 7
a489 2
         if (GLX_drv->glXCreateGLXPbufferSGIX &&
             GLX_drv->glXDestroyGLXPbufferSGIX &&
d505 1
a505 2
check_quirks(struct GLX_egl_driver *GLX_drv,
             struct GLX_egl_display *GLX_dpy, EGLint screen)
d512 1
a512 1
   vendor = GLX_drv->glXGetClientString(GLX_dpy->dpy, GLX_VENDOR);
d514 1
a514 1
      vendor = GLX_drv->glXQueryServerString(GLX_dpy->dpy, screen, GLX_VENDOR);
d528 2
a529 1
GLX_eglInitialize(_EGLDriver *drv, _EGLDisplay *disp)
a530 1
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
d533 2
a537 7
   /* this is a fallback driver */
   if (!disp->Options.UseFallback)
      return EGL_FALSE;

   if (disp->Options.TestOnly)
      return EGL_TRUE;

d552 1
a552 2
   if (!GLX_drv->glXQueryVersion(GLX_dpy->dpy,
            &GLX_dpy->glx_maj, &GLX_dpy->glx_min)) {
d560 2
a561 2
   disp->DriverData = (void *) GLX_dpy;
   disp->ClientAPIs = EGL_OPENGL_BIT;
d563 1
a563 4
   check_extensions(GLX_drv, GLX_dpy, DefaultScreen(GLX_dpy->dpy));
   check_quirks(GLX_drv, GLX_dpy, DefaultScreen(GLX_dpy->dpy));

   create_configs(drv, disp, DefaultScreen(GLX_dpy->dpy));
d572 3
d576 2
a577 2
   disp->VersionMajor = 1;
   disp->VersionMinor = 4;
a581 1

d593 4
a596 2
   free(GLX_dpy->visuals);
   free(GLX_dpy->fbconfigs);
a614 1
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
d619 2
d631 13
a643 13
   if (GLX_dpy->have_fbconfig) {
      GLX_ctx->context = GLX_drv->glXCreateNewContext(GLX_dpy->dpy,
            GLX_dpy->fbconfigs[GLX_egl_config_index(conf)],
            GLX_RGBA_TYPE,
            GLX_ctx_shared ? GLX_ctx_shared->context : NULL,
            GL_TRUE);
   }
   else {
      GLX_ctx->context = GLX_drv->glXCreateContext(GLX_dpy->dpy,
            &GLX_dpy->visuals[GLX_egl_config_index(conf)],
            GLX_ctx_shared ? GLX_ctx_shared->context : NULL,
            GL_TRUE);
   }
a651 19
/**
 * Called via eglDestroyContext(), drv->API.DestroyContext().
 */
static EGLBoolean
GLX_eglDestroyContext(_EGLDriver *drv, _EGLDisplay *disp, _EGLContext *ctx)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   struct GLX_egl_display *GLX_dpy = GLX_egl_display(disp);
   struct GLX_egl_context *GLX_ctx = GLX_egl_context(ctx);

   if (_eglPutContext(ctx)) {
      assert(GLX_ctx);
      GLX_drv->glXDestroyContext(GLX_dpy->dpy, GLX_ctx->context);

      free(GLX_ctx);
   }

   return EGL_TRUE;
}
a675 1
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
d686 2
d697 1
a697 1
      ret = GLX_drv->glXMakeContextCurrent(GLX_dpy->dpy, ddraw, rdraw, cctx);
d699 1
a699 1
      ret = GLX_drv->glXMakeCurrent(GLX_dpy->dpy, ddraw, cctx);
d730 1
a730 1
get_drawable_size(Display *dpy, Drawable d, unsigned *width, unsigned *height)
a749 1
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
d752 3
a754 1
   unsigned width, height;
d770 6
a775 6
   if (GLX_dpy->have_1_3 && !GLX_dpy->glx_window_quirk) {
      GLX_surf->glx_drawable = GLX_drv->glXCreateWindow(GLX_dpy->dpy,
            GLX_dpy->fbconfigs[GLX_egl_config_index(conf)],
            GLX_surf->drawable, NULL);
   }
   else {
a776 1
   }
d784 1
a784 1
      GLX_surf->destroy = GLX_drv->glXDestroyWindow;
a797 1
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
d800 3
a802 1
   unsigned width, height;
d819 4
a822 3
      GLX_surf->glx_drawable = GLX_drv->glXCreatePixmap(GLX_dpy->dpy,
            GLX_dpy->fbconfigs[GLX_egl_config_index(conf)],
            GLX_surf->drawable, NULL);
d826 1
a826 3
      XVisualInfo *vinfo;

      vinfo = GLX_drv->glXGetVisualFromFBConfig(GLX_dpy->dpy, fbconfig);
d828 3
a830 3
         GLX_surf->glx_drawable = GLX_drv->glXCreateGLXPixmap(GLX_dpy->dpy,
               vinfo, GLX_surf->drawable);
         free(vinfo);
d834 4
a837 3
      GLX_surf->glx_drawable = GLX_drv->glXCreateGLXPixmap(GLX_dpy->dpy,
            &GLX_dpy->visuals[GLX_egl_config_index(conf)],
            GLX_surf->drawable);
d846 1
a846 1
      GLX_drv->glXDestroyPixmap : GLX_drv->glXDestroyGLXPixmap;
a858 1
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
d864 2
d895 4
a898 2
      GLX_surf->glx_drawable = GLX_drv->glXCreatePbuffer(GLX_dpy->dpy,
            GLX_dpy->fbconfigs[GLX_egl_config_index(conf)], attribs);
d901 2
a902 1
      GLX_surf->glx_drawable = GLX_drv->glXCreateGLXPbufferSGIX(GLX_dpy->dpy,
d915 1
a915 1
      GLX_drv->glXDestroyPbuffer : GLX_drv->glXDestroyGLXPbufferSGIX;
a935 1
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
d939 3
a941 1
   GLX_drv->glXSwapBuffers(GLX_dpy->dpy, GLX_surf->glx_drawable);
d952 1
a952 1
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
d954 1
a954 1
   return (_EGLProc) GLX_drv->glXGetProcAddress((const GLubyte *) procname);
d960 1
a960 2
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);

d964 1
a964 1
   GLX_drv->glXWaitGL();
d971 1
a971 2
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);

d976 1
a976 1
   GLX_drv->glXWaitX();
a983 3

   if (GLX_drv->handle)
      dlclose(GLX_drv->handle);
a987 76
static EGLBoolean
GLX_Load(_EGLDriver *drv)
{
   struct GLX_egl_driver *GLX_drv = GLX_egl_driver(drv);
   void *handle = NULL;

   GLX_drv->glXGetProcAddress = dlsym(RTLD_DEFAULT, "glXGetProcAddress");
   if (!GLX_drv->glXGetProcAddress)
      GLX_drv->glXGetProcAddress = dlsym(RTLD_DEFAULT, "glXGetProcAddressARB");
   if (!GLX_drv->glXGetProcAddress) {
      handle = dlopen("libGL.so", RTLD_LAZY | RTLD_LOCAL);
      if (!handle)
         goto fail;

      GLX_drv->glXGetProcAddress = dlsym(handle, "glXGetProcAddress");
      if (!GLX_drv->glXGetProcAddress)
         GLX_drv->glXGetProcAddress = dlsym(handle, "glXGetProcAddressARB");
      if (!GLX_drv->glXGetProcAddress)
         goto fail;
   }

#define GET_PROC(proc_type, proc_name, check)                        \
   do {                                                              \
      GLX_drv->proc_name = (proc_type)                               \
         GLX_drv->glXGetProcAddress((const GLubyte *) #proc_name);   \
      if (check && !GLX_drv->proc_name) goto fail;                   \
   } while (0)

   /* GLX 1.0 */
   GET_PROC(GLXCREATECONTEXTPROC, glXCreateContext, EGL_TRUE);
   GET_PROC(GLXDESTROYCONTEXTPROC, glXDestroyContext, EGL_TRUE);
   GET_PROC(GLXMAKECURRENTPROC, glXMakeCurrent, EGL_TRUE);
   GET_PROC(GLXSWAPBUFFERSPROC, glXSwapBuffers, EGL_TRUE);
   GET_PROC(GLXCREATEGLXPIXMAPPROC, glXCreateGLXPixmap, EGL_TRUE);
   GET_PROC(GLXDESTROYGLXPIXMAPPROC, glXDestroyGLXPixmap, EGL_TRUE);
   GET_PROC(GLXQUERYVERSIONPROC, glXQueryVersion, EGL_TRUE);
   GET_PROC(GLXGETCONFIGPROC, glXGetConfig, EGL_TRUE);
   GET_PROC(GLXWAITGLPROC, glXWaitGL, EGL_TRUE);
   GET_PROC(GLXWAITXPROC, glXWaitX, EGL_TRUE);

   /* GLX 1.1 */
   GET_PROC(GLXQUERYEXTENSIONSSTRINGPROC, glXQueryExtensionsString, EGL_TRUE);
   GET_PROC(GLXQUERYSERVERSTRINGPROC, glXQueryServerString, EGL_TRUE);
   GET_PROC(GLXGETCLIENTSTRINGPROC, glXGetClientString, EGL_TRUE);

   /* GLX 1.3 */
   GET_PROC(PFNGLXGETFBCONFIGSPROC, glXGetFBConfigs, EGL_FALSE);
   GET_PROC(PFNGLXGETFBCONFIGATTRIBPROC, glXGetFBConfigAttrib, EGL_FALSE);
   GET_PROC(PFNGLXGETVISUALFROMFBCONFIGPROC, glXGetVisualFromFBConfig, EGL_FALSE);
   GET_PROC(PFNGLXCREATEWINDOWPROC, glXCreateWindow, EGL_FALSE);
   GET_PROC(PFNGLXDESTROYWINDOWPROC, glXDestroyWindow, EGL_FALSE);
   GET_PROC(PFNGLXCREATEPIXMAPPROC, glXCreatePixmap, EGL_FALSE);
   GET_PROC(PFNGLXDESTROYPIXMAPPROC, glXDestroyPixmap, EGL_FALSE);
   GET_PROC(PFNGLXCREATEPBUFFERPROC, glXCreatePbuffer, EGL_FALSE);
   GET_PROC(PFNGLXDESTROYPBUFFERPROC, glXDestroyPbuffer, EGL_FALSE);
   GET_PROC(PFNGLXCREATENEWCONTEXTPROC, glXCreateNewContext, EGL_FALSE);
   GET_PROC(PFNGLXMAKECONTEXTCURRENTPROC, glXMakeContextCurrent, EGL_FALSE);

   /* GLX_SGIX_pbuffer */
   GET_PROC(PFNGLXCREATEGLXPBUFFERSGIXPROC,
         glXCreateGLXPbufferSGIX, EGL_FALSE);
   GET_PROC(PFNGLXDESTROYGLXPBUFFERSGIXPROC,
         glXDestroyGLXPbufferSGIX, EGL_FALSE);
#undef GET_PROC

   GLX_drv->handle = handle;

   return EGL_TRUE;

fail:
   if (handle)
      dlclose(handle);
   return EGL_FALSE;
}


d993 1
a993 1
_eglBuiltInDriverGLX(const char *args)
a1001 6
   if (!GLX_Load(&GLX_drv->Base)) {
      _eglLog(_EGL_WARNING, "GLX: failed to load GLX");
      free(GLX_drv);
      return NULL;
   }

a1005 1
   GLX_drv->Base.API.DestroyContext = GLX_eglDestroyContext;
@


