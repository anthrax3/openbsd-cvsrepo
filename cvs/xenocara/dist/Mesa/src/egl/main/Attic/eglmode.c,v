head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.25;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2014.07.09.21.08.51;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.13.59.25;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.10;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.24;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.40;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008 VMware, Inc.
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright 2010 LunarG, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include "egldisplay.h"
#include "eglmode.h"
#include "eglcurrent.h"
#include "eglscreen.h"


#ifdef EGL_MESA_screen_surface


#define MIN2(A, B)  (((A) < (B)) ? (A) : (B))


/**
 * Given an EGLModeMESA handle, return the corresponding _EGLMode object
 * or null if non-existant.
 */
_EGLMode *
_eglLookupMode(EGLModeMESA mode, _EGLDisplay *disp)
{
   EGLint scrnum;

   if (!disp || !disp->Screens)
      return NULL;

   /* loop over all screens on the display */
   for (scrnum = 0; scrnum < disp->Screens->Size; scrnum++) {
      const _EGLScreen *scrn = disp->Screens->Elements[scrnum];
      EGLint idx;

      /*
       * the mode ids of a screen ranges from scrn->Handle to scrn->Handle +
       * scrn->NumModes
       */
      if (mode >= scrn->Handle &&
          mode < scrn->Handle + _EGL_SCREEN_MAX_MODES) {
         idx = mode - scrn->Handle;

         assert(idx < scrn->NumModes && scrn->Modes[idx].Handle == mode);

         return &scrn->Modes[idx];
      }
   }

   return NULL;
}


/**
 * Parse the attrib_list to fill in the fields of the given _eglMode
 * Return EGL_FALSE if any errors, EGL_TRUE otherwise.
 */
static EGLBoolean
_eglParseModeAttribs(_EGLMode *mode, const EGLint *attrib_list)
{
   EGLint i;

   /* init all attribs to EGL_DONT_CARE */
   mode->Handle = EGL_DONT_CARE;
   mode->Width = EGL_DONT_CARE;
   mode->Height = EGL_DONT_CARE;
   mode->RefreshRate = EGL_DONT_CARE;
   mode->Optimal = EGL_DONT_CARE;
   mode->Interlaced = EGL_DONT_CARE;
   mode->Name = NULL;

   for (i = 0; attrib_list && attrib_list[i] != EGL_NONE; i++) {
      switch (attrib_list[i]) {
      case EGL_MODE_ID_MESA:
         mode->Handle = attrib_list[++i];
         if (mode->Handle <= 0) {
            _eglError(EGL_BAD_PARAMETER, "eglChooseModeMESA(handle)");
            return EGL_FALSE;
         }
         break;
      case EGL_WIDTH:
         mode->Width = attrib_list[++i];
         if (mode->Width <= 0) {
            _eglError(EGL_BAD_PARAMETER, "eglChooseModeMESA(width)");
            return EGL_FALSE;
         }
         break;
      case EGL_HEIGHT:
         mode->Height = attrib_list[++i];
         if (mode->Height <= 0) {
            _eglError(EGL_BAD_PARAMETER, "eglChooseModeMESA(height)");
            return EGL_FALSE;
         }
         break;
      case EGL_REFRESH_RATE_MESA:
         mode->RefreshRate = attrib_list[++i];
         if (mode->RefreshRate <= 0) {
            _eglError(EGL_BAD_PARAMETER, "eglChooseModeMESA(refresh rate)");
            return EGL_FALSE;
         }
         break;
      case EGL_INTERLACED_MESA:
         mode->Interlaced = attrib_list[++i];
         if (mode->Interlaced != EGL_TRUE && mode->Interlaced != EGL_FALSE) {
            _eglError(EGL_BAD_PARAMETER, "eglChooseModeMESA(interlaced)");
            return EGL_FALSE;
         }
         break;
      case EGL_OPTIMAL_MESA:
         mode->Optimal = attrib_list[++i];
         if (mode->Optimal != EGL_TRUE && mode->Optimal != EGL_FALSE) {
            _eglError(EGL_BAD_PARAMETER, "eglChooseModeMESA(optimal)");
            return EGL_FALSE;
         }
         break;
      default:
         _eglError(EGL_BAD_ATTRIBUTE, "eglChooseModeMESA");
         return EGL_FALSE;
      }
   }
   return EGL_TRUE;
}


/**
 * Determine if the candidate mode's attributes are at least as good
 * as the minimal mode's.
 * \return EGL_TRUE if qualifies, EGL_FALSE otherwise
 */
static EGLBoolean
_eglModeQualifies(const _EGLMode *c, const _EGLMode *min)
{
   if (min->Handle != EGL_DONT_CARE && c->Handle != min->Handle)
      return EGL_FALSE;
   if (min->Width != EGL_DONT_CARE && c->Width < min->Width)
      return EGL_FALSE;
   if (min->Height != EGL_DONT_CARE && c->Height < min->Height)
      return EGL_FALSE;
   if (min->RefreshRate != EGL_DONT_CARE && c->RefreshRate < min->RefreshRate)
      return EGL_FALSE;
   if (min->Optimal != EGL_DONT_CARE && c->Optimal != min->Optimal)
      return EGL_FALSE;
   if (min->Interlaced != EGL_DONT_CARE && c->Interlaced != min->Interlaced)
      return EGL_FALSE;

   return EGL_TRUE;
}


/**
 * Return value of given mode attribute, or -1 if bad attrib.
 */
static EGLint
getModeAttrib(const _EGLMode *m, EGLint attrib)
{
   switch (attrib) {
   case EGL_MODE_ID_MESA:
      return m->Handle;
   case EGL_WIDTH:
      return m->Width;
   case EGL_HEIGHT:
      return m->Height;
   case EGL_REFRESH_RATE_MESA:
      return m->RefreshRate;
   case EGL_OPTIMAL_MESA:
      return m->Optimal;
   case EGL_INTERLACED_MESA:
      return m->Interlaced;
   default:
      return -1;
   }
}


#define SMALLER 1
#define LARGER  2

struct sort_info {
   EGLint Attrib;
   EGLint Order; /* SMALLER or LARGER */
};

/* the order of these entries is the priority */
static struct sort_info SortInfo[] = {
   { EGL_OPTIMAL_MESA, LARGER },
   { EGL_INTERLACED_MESA, SMALLER },
   { EGL_WIDTH, LARGER },
   { EGL_HEIGHT, LARGER },
   { EGL_REFRESH_RATE_MESA, LARGER },
   { EGL_MODE_ID_MESA, SMALLER },
   { 0, 0 }
};


/**
 * Compare modes 'a' and 'b' and return -1 if a belongs before b, or 1 if a
 * belongs after b, or 0 if they're equal.
 * Used by qsort().
 */
static int
_eglCompareModes(const void *a, const void *b)
{
   const _EGLMode *aMode = *((const _EGLMode **) a);
   const _EGLMode *bMode = *((const _EGLMode **) b);
   EGLint i;

   for (i = 0; SortInfo[i].Attrib; i++) {
      const EGLint aVal = getModeAttrib(aMode, SortInfo[i].Attrib);
      const EGLint bVal = getModeAttrib(bMode, SortInfo[i].Attrib);
      if (aVal == bVal) {
         /* a tie */
         continue;
      }
      else if (SortInfo[i].Order == SMALLER) {
         return (aVal < bVal) ? -1 : 1;
      }
      else if (SortInfo[i].Order == LARGER) {
         return (aVal > bVal) ? -1 : 1;
      }
   }

   /* all attributes identical */
   return 0;
}


/**
 * Search for EGLModes which match the given attribute list.
 * Called via eglChooseModeMESA API function.
 */
EGLBoolean
_eglChooseModeMESA(_EGLDriver *drv, _EGLDisplay *dpy, _EGLScreen *scrn,
                   const EGLint *attrib_list, EGLModeMESA *modes,
                   EGLint modes_size, EGLint *num_modes)
{
   _EGLMode **modeList, min;
   EGLint i, count;

   if (!_eglParseModeAttribs(&min, attrib_list)) {
      /* error code will have been recorded */
      return EGL_FALSE;
   }

   /* allocate array of mode pointers */
   modeList = malloc(modes_size * sizeof(_EGLMode *));
   if (!modeList) {
      _eglError(EGL_BAD_MODE_MESA, "eglChooseModeMESA(out of memory)");
      return EGL_FALSE;
   }

   /* make array of pointers to qualifying modes */
   for (i = count = 0; i < scrn->NumModes && count < modes_size; i++) {
      if (_eglModeQualifies(scrn->Modes + i, &min)) {
         modeList[count++] = scrn->Modes + i;
      }
   }

   /* sort array of pointers */
   qsort(modeList, count, sizeof(_EGLMode *), _eglCompareModes);

   /* copy mode handles to output array */
   for (i = 0; i < count; i++) {
      modes[i] = modeList[i]->Handle;
   }

   free(modeList);

   *num_modes = count;

   return EGL_TRUE;
}



/**
 * Return all possible modes for the given screen.  No sorting of results.
 * Called via eglGetModesMESA() API function.
 */
EGLBoolean
_eglGetModesMESA(_EGLDriver *drv, _EGLDisplay *dpy, _EGLScreen *scrn,
                 EGLModeMESA *modes, EGLint modes_size, EGLint *num_modes)
{
   if (modes) {
      EGLint i;
      *num_modes = MIN2(scrn->NumModes, modes_size);
      for (i = 0; i < *num_modes; i++) {
         modes[i] = scrn->Modes[i].Handle;
      }
   }
   else {
      /* just return total number of supported modes */
      *num_modes = scrn->NumModes;
   }

   return EGL_TRUE;
}


/**
 * Query an attribute of a mode.
 */
EGLBoolean
_eglGetModeAttribMESA(_EGLDriver *drv, _EGLDisplay *dpy,
                      _EGLMode *m, EGLint attribute, EGLint *value)
{
   EGLint v;

   v = getModeAttrib(m, attribute);
   if (v < 0) {
      _eglError(EGL_BAD_ATTRIBUTE, "eglGetModeAttribMESA");
      return EGL_FALSE;
   }
   *value = v;
   return EGL_TRUE;
}


/**
 * Return human-readable string for given mode.
 * This is the default function called by eglQueryModeStringMESA().
 */
const char *
_eglQueryModeStringMESA(_EGLDriver *drv, _EGLDisplay *dpy, _EGLMode *m)
{
   return m->Name;
}


#endif /* EGL_MESA_screen_surface */
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.5
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d273 1
a273 1
   modeList = (_EGLMode **) malloc(modes_size * sizeof(_EGLMode *));
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d1 30
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a5 1
#include "egldriver.h"
d9 3
a11 1
#include "eglstring.h"
d26 3
d30 15
a44 8
   for (scrnum = 0; scrnum < disp->NumScreens; scrnum++) {
      const _EGLScreen *scrn = disp->Screens[scrnum];
      EGLint i;
      /* search list of modes for handle */
      for (i = 0; i < scrn->NumModes; i++) {
         if (scrn->Modes[i].Handle == mode) {
            return scrn->Modes + i;
         }
a52 39
 * Add a new mode with the given attributes (width, height, depth, refreshRate)
 * to the given screen.
 * Assign a new mode ID/handle to the mode as well.
 * \return pointer to the new _EGLMode
 */
_EGLMode *
_eglAddNewMode(_EGLScreen *screen, EGLint width, EGLint height,
               EGLint refreshRate, const char *name)
{
   EGLint n;
   _EGLMode *newModes;

   assert(screen);
   assert(width > 0);
   assert(height > 0);
   assert(refreshRate > 0);

   n = screen->NumModes;
   newModes = (_EGLMode *) realloc(screen->Modes, (n+1) * sizeof(_EGLMode));
   if (newModes) {
      screen->Modes = newModes;
      screen->Modes[n].Handle = n + 1;
      screen->Modes[n].Width = width;
      screen->Modes[n].Height = height;
      screen->Modes[n].RefreshRate = refreshRate;
      screen->Modes[n].Optimal = EGL_FALSE;
      screen->Modes[n].Interlaced = EGL_FALSE;
      screen->Modes[n].Name = _eglstrdup(name);
      screen->NumModes++;
      return screen->Modes + n;
   }
   else {
      return NULL;
   }
}



/**
d325 3
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a0 1
#include <stdio.h>
d8 1
a8 1
#include "eglglobals.h"
d10 1
a15 16
static char *
my_strdup(const char *s)
{
   if (s) {
      int l = strlen(s);
      char *s2 = malloc(l + 1);
      if (s2)
         strcpy(s2, s);
      return s2;
   }
   else {
      return NULL;
   }
}


d21 1
a21 1
_eglLookupMode(EGLDisplay dpy, EGLModeMESA mode)
a22 1
   const _EGLDisplay *disp = _eglLookupDisplay(dpy);
d69 1
a69 1
      screen->Modes[n].Name = my_strdup(name);
d258 1
a258 1
_eglChooseModeMESA(_EGLDriver *drv, EGLDisplay dpy, EGLScreenMESA screen,
a261 1
   const _EGLScreen *scrn = _eglLookupScreen(dpy, screen);
a264 5
   if (!scrn) {
      _eglError(EGL_BAD_SCREEN_MESA, "eglChooseModeMESA");
      return EGL_FALSE;
   }

d306 1
a306 1
_eglGetModesMESA(_EGLDriver *drv, EGLDisplay dpy, EGLScreenMESA screen,
a308 7
   _EGLScreen *scrn = _eglLookupScreen(dpy, screen);

   if (!scrn) {
      _eglError(EGL_BAD_SCREEN_MESA, "eglGetModesMESA");
      return EGL_FALSE;
   }

d329 2
a330 2
_eglGetModeAttribMESA(_EGLDriver *drv, EGLDisplay dpy,
                      EGLModeMESA mode, EGLint attribute, EGLint *value)
a331 1
   _EGLMode *m = _eglLookupMode(dpy, mode);
a333 5
   if (!m) {
      _eglError(EGL_BAD_MODE_MESA, "eglGetModeAttribMESA");
      return EGL_FALSE;
   }

d349 1
a349 1
_eglQueryModeStringMESA(_EGLDriver *drv, EGLDisplay dpy, EGLModeMESA mode)
a350 5
   _EGLMode *m = _eglLookupMode(dpy, mode);
   if (!m) {
      _eglError(EGL_BAD_MODE_MESA, "eglQueryModeStringMESA");
      return NULL;
   }
a352 38


#if 0
static int
_eglRand(int max)
{
   return rand() % max;
}

void
_eglTestModeModule(void)
{
   EGLint count = 30;
   _EGLMode *modes = (_EGLMode *) malloc(count * sizeof(_EGLMode));
   _EGLMode **modeList = (_EGLMode **) malloc(count * sizeof(_EGLMode*));
   EGLint i;

   for (i = 0; i < count; i++) {
      modes[i].Handle = _eglRand(20);
      modes[i].Width = 512 + 256 * _eglRand(2);
      modes[i].Height = 512 + 256 * _eglRand(2);
      modes[i].RefreshRate = 50 + 5 * _eglRand(3);
      modes[i].Interlaced = _eglRand(2);
      modes[i].Optimal = _eglRand(4) == 0;
      modeList[i] = modes + i;
   }

   /* sort array of pointers */
   qsort(modeList, count, sizeof(_EGLMode *), compareModes);

   for (i = 0; i < count; i++) {
      _EGLMode *m = modeList[i];
      printf("%2d: %3d  %4d x %4d  @@ %3d  opt %d  int %d\n", i,
             m->Handle, m->Width, m->Height, m->RefreshRate,
             m->Optimal, m->Interlaced);
   }
}
#endif
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d1 1
d7 1
d9 1
a9 1
#include "eglcurrent.h"
d13 1
a13 1
#ifdef EGL_MESA_screen_surface
d16 14
a29 1
#define MIN2(A, B)  (((A) < (B)) ? (A) : (B))
d37 1
a37 1
_eglLookupMode(EGLModeMESA mode, _EGLDisplay *disp)
d39 1
a41 3
   if (!disp || !disp->Screens)
      return NULL;

d43 8
a50 15
   for (scrnum = 0; scrnum < disp->Screens->Size; scrnum++) {
      const _EGLScreen *scrn = disp->Screens->Elements[scrnum];
      EGLint idx;

      /*
       * the mode ids of a screen ranges from scrn->Handle to scrn->Handle +
       * scrn->NumModes
       */
      if (mode >= scrn->Handle &&
          mode < scrn->Handle + _EGL_SCREEN_MAX_MODES) {
         idx = mode - scrn->Handle;

         assert(idx < scrn->NumModes && scrn->Modes[idx].Handle == mode);

         return &scrn->Modes[idx];
d59 39
d275 1
a275 1
_eglChooseModeMESA(_EGLDriver *drv, _EGLDisplay *dpy, _EGLScreen *scrn,
d279 1
d283 5
d329 1
a329 1
_eglGetModesMESA(_EGLDriver *drv, _EGLDisplay *dpy, _EGLScreen *scrn,
d332 7
d359 2
a360 2
_eglGetModeAttribMESA(_EGLDriver *drv, _EGLDisplay *dpy,
                      _EGLMode *m, EGLint attribute, EGLint *value)
d362 1
d365 5
d385 1
a385 1
_eglQueryModeStringMESA(_EGLDriver *drv, _EGLDisplay *dpy, _EGLMode *m)
d387 5
d396 36
a431 1
#endif /* EGL_MESA_screen_surface */
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a0 30
/**************************************************************************
 *
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright 2010 LunarG, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


d243 1
a243 1
   modeList = malloc(modes_size * sizeof(_EGLMode *));
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
@


