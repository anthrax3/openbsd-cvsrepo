head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.25;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2014.07.09.21.08.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.13.59.24;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.02;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.37;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.10;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.23;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.21;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.40;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008 VMware, Inc.
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright 2010-2011 LunarG, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


/**
 * EGL Configuration (pixel format) functions.
 */


#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "eglconfig.h"
#include "egldisplay.h"
#include "eglcurrent.h"
#include "egllog.h"


#define MIN2(A, B)  (((A) < (B)) ? (A) : (B))


/**
 * Init the given _EGLconfig to default values.
 * \param id  the configuration's ID.
 *
 * Note that id must be positive for the config to be valid.
 * It is also recommended that when there are N configs, their
 * IDs are from 1 to N respectively.
 */
void
_eglInitConfig(_EGLConfig *conf, _EGLDisplay *dpy, EGLint id)
{
   memset(conf, 0, sizeof(*conf));

   conf->Display = dpy;

   /* some attributes take non-zero default values */
   conf->ConfigID = id;
   conf->ConfigCaveat = EGL_NONE;
   conf->TransparentType = EGL_NONE;
   conf->NativeVisualType = EGL_NONE;
   conf->ColorBufferType = EGL_RGB_BUFFER;
}


/**
 * Link a config to its display and return the handle of the link.
 * The handle can be passed to client directly.
 *
 * Note that we just save the ptr to the config (we don't copy the config).
 */
PUBLIC EGLConfig
_eglLinkConfig(_EGLConfig *conf)
{
   _EGLDisplay *dpy = conf->Display;

   /* sanity check */
   assert(dpy && conf->ConfigID > 0);

   if (!dpy->Configs) {
      dpy->Configs = _eglCreateArray("Config", 16);
      if (!dpy->Configs)
         return (EGLConfig) NULL;
   }

   _eglAppendArray(dpy->Configs, (void *) conf);

   return (EGLConfig) conf;
}


/**
 * Lookup a handle to find the linked config.
 * Return NULL if the handle has no corresponding linked config.
 */
_EGLConfig *
_eglLookupConfig(EGLConfig config, _EGLDisplay *dpy)
{
   _EGLConfig *conf;

   if (!dpy)
      return NULL;

   conf = (_EGLConfig *) _eglFindArray(dpy->Configs, (void *) config);
   if (conf)
      assert(conf->Display == dpy);

   return conf;
}


enum {
   /* types */
   ATTRIB_TYPE_INTEGER,
   ATTRIB_TYPE_BOOLEAN,
   ATTRIB_TYPE_BITMASK,
   ATTRIB_TYPE_ENUM,
   ATTRIB_TYPE_PSEUDO, /* non-queryable */
   ATTRIB_TYPE_PLATFORM, /* platform-dependent */
   /* criteria */
   ATTRIB_CRITERION_EXACT,
   ATTRIB_CRITERION_ATLEAST,
   ATTRIB_CRITERION_MASK,
   ATTRIB_CRITERION_SPECIAL,
   ATTRIB_CRITERION_IGNORE
};


/* EGL spec Table 3.1 and 3.4 */
static const struct {
   EGLint attr;
   EGLint type;
   EGLint criterion;
   EGLint default_value;
} _eglValidationTable[] =
{
   /* core */
   { EGL_BUFFER_SIZE,               ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_RED_SIZE,                  ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_GREEN_SIZE,                ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_BLUE_SIZE,                 ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_LUMINANCE_SIZE,            ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_ALPHA_SIZE,                ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_ALPHA_MASK_SIZE,           ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_BIND_TO_TEXTURE_RGB,       ATTRIB_TYPE_BOOLEAN,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_BIND_TO_TEXTURE_RGBA,      ATTRIB_TYPE_BOOLEAN,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_COLOR_BUFFER_TYPE,         ATTRIB_TYPE_ENUM,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_RGB_BUFFER },
   { EGL_CONFIG_CAVEAT,             ATTRIB_TYPE_ENUM,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_CONFIG_ID,                 ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_CONFORMANT,                ATTRIB_TYPE_BITMASK,
                                    ATTRIB_CRITERION_MASK,
                                    0 },
   { EGL_DEPTH_SIZE,                ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_LEVEL,                     ATTRIB_TYPE_PLATFORM,
                                    ATTRIB_CRITERION_EXACT,
                                    0 },
   { EGL_MAX_PBUFFER_WIDTH,         ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_IGNORE,
                                    0 },
   { EGL_MAX_PBUFFER_HEIGHT,        ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_IGNORE,
                                    0 },
   { EGL_MAX_PBUFFER_PIXELS,        ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_IGNORE,
                                    0 },
   { EGL_MAX_SWAP_INTERVAL,         ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_MIN_SWAP_INTERVAL,         ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_NATIVE_RENDERABLE,         ATTRIB_TYPE_BOOLEAN,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_NATIVE_VISUAL_ID,          ATTRIB_TYPE_PLATFORM,
                                    ATTRIB_CRITERION_IGNORE,
                                    0 },
   { EGL_NATIVE_VISUAL_TYPE,        ATTRIB_TYPE_PLATFORM,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_RENDERABLE_TYPE,           ATTRIB_TYPE_BITMASK,
                                    ATTRIB_CRITERION_MASK,
                                    EGL_OPENGL_ES_BIT },
   { EGL_SAMPLE_BUFFERS,            ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_SAMPLES,                   ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_STENCIL_SIZE,              ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_SURFACE_TYPE,              ATTRIB_TYPE_BITMASK,
                                    ATTRIB_CRITERION_MASK,
                                    EGL_WINDOW_BIT },
   { EGL_TRANSPARENT_TYPE,          ATTRIB_TYPE_ENUM,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_NONE },
   { EGL_TRANSPARENT_RED_VALUE,     ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_TRANSPARENT_GREEN_VALUE,   ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_TRANSPARENT_BLUE_VALUE,    ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_MATCH_NATIVE_PIXMAP,       ATTRIB_TYPE_PSEUDO,
                                    ATTRIB_CRITERION_SPECIAL,
                                    EGL_NONE },
   /* extensions */
   { EGL_Y_INVERTED_NOK,            ATTRIB_TYPE_BOOLEAN,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE }
};


/**
 * Return true if a config is valid.  When for_matching is true,
 * EGL_DONT_CARE is accepted as a valid attribute value, and checks
 * for conflicting attribute values are skipped.
 *
 * Note that some attributes are platform-dependent and are not
 * checked.
 */
EGLBoolean
_eglValidateConfig(const _EGLConfig *conf, EGLBoolean for_matching)
{
   EGLint i, attr, val;
   EGLBoolean valid = EGL_TRUE;

   /* check attributes by their types */
   for (i = 0; i < ARRAY_SIZE(_eglValidationTable); i++) {
      EGLint mask;

      attr = _eglValidationTable[i].attr;
      val = _eglGetConfigKey(conf, attr);

      switch (_eglValidationTable[i].type) {
      case ATTRIB_TYPE_INTEGER:
         switch (attr) {
         case EGL_CONFIG_ID:
            /* config id must be positive */
            if (val <= 0)
               valid = EGL_FALSE;
            break;
         case EGL_SAMPLE_BUFFERS:
            /* there can be at most 1 sample buffer */
            if (val > 1 || val < 0)
               valid = EGL_FALSE;
            break;
         default:
            if (val < 0)
               valid = EGL_FALSE;
            break;
         }
         break;
      case ATTRIB_TYPE_BOOLEAN:
         if (val != EGL_TRUE && val != EGL_FALSE)
            valid = EGL_FALSE;
         break;
      case ATTRIB_TYPE_ENUM:
         switch (attr) {
         case EGL_CONFIG_CAVEAT:
            if (val != EGL_NONE && val != EGL_SLOW_CONFIG &&
                val != EGL_NON_CONFORMANT_CONFIG)
               valid = EGL_FALSE;
            break;
         case EGL_TRANSPARENT_TYPE:
            if (val != EGL_NONE && val != EGL_TRANSPARENT_RGB)
               valid = EGL_FALSE;
            break;
         case EGL_COLOR_BUFFER_TYPE:
            if (val != EGL_RGB_BUFFER && val != EGL_LUMINANCE_BUFFER)
               valid = EGL_FALSE;
            break;
         default:
            assert(0);
            break;
         }
         break;
      case ATTRIB_TYPE_BITMASK:
         switch (attr) {
         case EGL_SURFACE_TYPE:
            mask = EGL_PBUFFER_BIT |
                   EGL_PIXMAP_BIT |
                   EGL_WINDOW_BIT |
                   EGL_VG_COLORSPACE_LINEAR_BIT |
                   EGL_VG_ALPHA_FORMAT_PRE_BIT |
                   EGL_MULTISAMPLE_RESOLVE_BOX_BIT |
                   EGL_SWAP_BEHAVIOR_PRESERVED_BIT;
#ifdef EGL_MESA_screen_surface
            if (conf->Display->Extensions.MESA_screen_surface)
               mask |= EGL_SCREEN_BIT_MESA;
#endif
            break;
         case EGL_RENDERABLE_TYPE:
         case EGL_CONFORMANT:
            mask = EGL_OPENGL_ES_BIT |
                   EGL_OPENVG_BIT |
                   EGL_OPENGL_ES2_BIT |
                   EGL_OPENGL_ES3_BIT_KHR |
                   EGL_OPENGL_BIT;
            break;
         default:
            assert(0);
            mask = 0;
            break;
         }
         if (val & ~mask)
            valid = EGL_FALSE;
         break;
      case ATTRIB_TYPE_PLATFORM:
         /* unable to check platform-dependent attributes here */
         break;
      case ATTRIB_TYPE_PSEUDO:
         /* pseudo attributes should not be set */
         if (val != 0)
            valid = EGL_FALSE;
         break;
      default:
         assert(0);
         break;
      }

      if (!valid && for_matching) {
         /* accept EGL_DONT_CARE as a valid value */
         if (val == EGL_DONT_CARE)
            valid = EGL_TRUE;
         if (_eglValidationTable[i].criterion == ATTRIB_CRITERION_SPECIAL)
            valid = EGL_TRUE;
      }
      if (!valid) {
         _eglLog(_EGL_DEBUG,
               "attribute 0x%04x has an invalid value 0x%x", attr, val);
         break;
      }
   }

   /* any invalid attribute value should have been catched */
   if (!valid || for_matching)
      return valid;

   /* now check for conflicting attribute values */

   switch (conf->ColorBufferType) {
   case EGL_RGB_BUFFER:
      if (conf->LuminanceSize)
         valid = EGL_FALSE;
      if (conf->RedSize + conf->GreenSize +
            conf->BlueSize + conf->AlphaSize != conf->BufferSize)
         valid = EGL_FALSE;
      break;
   case EGL_LUMINANCE_BUFFER:
      if (conf->RedSize || conf->GreenSize || conf->BlueSize)
         valid = EGL_FALSE;
      if (conf->LuminanceSize + conf->AlphaSize != conf->BufferSize)
         valid = EGL_FALSE;
      break;
   }
   if (!valid) {
      _eglLog(_EGL_DEBUG, "conflicting color buffer type and channel sizes");
      return EGL_FALSE;
   }

   if (!conf->SampleBuffers && conf->Samples)
      valid = EGL_FALSE;
   if (!valid) {
      _eglLog(_EGL_DEBUG, "conflicting samples and sample buffers");
      return EGL_FALSE;
   }

   if (!(conf->SurfaceType & EGL_WINDOW_BIT)) {
      if (conf->NativeVisualID != 0 || conf->NativeVisualType != EGL_NONE)
         valid = EGL_FALSE;
   }
   if (!(conf->SurfaceType & EGL_PBUFFER_BIT)) {
      if (conf->BindToTextureRGB || conf->BindToTextureRGBA)
         valid = EGL_FALSE;
   }
   if (!valid) {
      _eglLog(_EGL_DEBUG, "conflicting surface type and native visual/texture binding");
      return EGL_FALSE;
   }

   return valid;
}


/**
 * Return true if a config matches the criteria.  This and
 * _eglParseConfigAttribList together implement the algorithm
 * described in "Selection of EGLConfigs".
 *
 * Note that attributes that are special (currently, only
 * EGL_MATCH_NATIVE_PIXMAP) are ignored.
 */
EGLBoolean
_eglMatchConfig(const _EGLConfig *conf, const _EGLConfig *criteria)
{
   EGLint attr, val, i;
   EGLBoolean matched = EGL_TRUE;

   for (i = 0; i < ARRAY_SIZE(_eglValidationTable); i++) {
      EGLint cmp;
      if (_eglValidationTable[i].criterion == ATTRIB_CRITERION_IGNORE)
         continue;

      attr = _eglValidationTable[i].attr;
      cmp = _eglGetConfigKey(criteria, attr);
      if (cmp == EGL_DONT_CARE)
         continue;

      val = _eglGetConfigKey(conf, attr);
      switch (_eglValidationTable[i].criterion) {
      case ATTRIB_CRITERION_EXACT:
         if (val != cmp)
            matched = EGL_FALSE;
         break;
      case ATTRIB_CRITERION_ATLEAST:
         if (val < cmp)
            matched = EGL_FALSE;
         break;
      case ATTRIB_CRITERION_MASK:
         if ((val & cmp) != cmp)
            matched = EGL_FALSE;
         break;
      case ATTRIB_CRITERION_SPECIAL:
         /* ignored here */
         break;
      default:
         assert(0);
         break;
      }

      if (!matched) {
#ifndef DEBUG
         /* only print the common errors when DEBUG is not defined */
         if (attr != EGL_RENDERABLE_TYPE)
            break;
#endif
         _eglLog(_EGL_DEBUG,
               "the value (0x%x) of attribute 0x%04x did not meet the criteria (0x%x)",
               val, attr, cmp);
         break;
      }
   }

   return matched;
}

static INLINE EGLBoolean
_eglIsConfigAttribValid(_EGLConfig *conf, EGLint attr)
{
   if (_eglOffsetOfConfig(attr) < 0)
      return EGL_FALSE;

   switch (attr) {
   case EGL_Y_INVERTED_NOK:
      return conf->Display->Extensions.NOK_texture_from_pixmap;
   default:
      break;
   }

   return EGL_TRUE;
}

/**
 * Initialize a criteria config from the given attribute list.
 * Return EGL_FALSE if any of the attribute is invalid.
 */
EGLBoolean
_eglParseConfigAttribList(_EGLConfig *conf, _EGLDisplay *dpy,
                          const EGLint *attrib_list)
{
   EGLint attr, val, i;

   _eglInitConfig(conf, dpy, EGL_DONT_CARE);

   /* reset to default values */
   for (i = 0; i < ARRAY_SIZE(_eglValidationTable); i++) {
      attr = _eglValidationTable[i].attr;
      val = _eglValidationTable[i].default_value;
      _eglSetConfigKey(conf, attr, val);
   }

   /* parse the list */
   for (i = 0; attrib_list && attrib_list[i] != EGL_NONE; i += 2) {
      attr = attrib_list[i];
      val = attrib_list[i + 1];

      if (!_eglIsConfigAttribValid(conf, attr))
	 return EGL_FALSE;

      _eglSetConfigKey(conf, attr, val);
   }

   if (!_eglValidateConfig(conf, EGL_TRUE))
      return EGL_FALSE;

   /* EGL_LEVEL and EGL_MATCH_NATIVE_PIXMAP cannot be EGL_DONT_CARE */
   if (conf->Level == EGL_DONT_CARE ||
       conf->MatchNativePixmap == EGL_DONT_CARE)
      return EGL_FALSE;

   /* ignore other attributes when EGL_CONFIG_ID is given */
   if (conf->ConfigID != EGL_DONT_CARE) {
      for (i = 0; i < ARRAY_SIZE(_eglValidationTable); i++) {
         attr = _eglValidationTable[i].attr;
         if (attr != EGL_CONFIG_ID)
            _eglSetConfigKey(conf, attr, EGL_DONT_CARE);
      }
   }
   else {
      if (!(conf->SurfaceType & EGL_WINDOW_BIT))
         conf->NativeVisualType = EGL_DONT_CARE;

      if (conf->TransparentType == EGL_NONE) {
         conf->TransparentRedValue = EGL_DONT_CARE;
         conf->TransparentGreenValue = EGL_DONT_CARE;
         conf->TransparentBlueValue = EGL_DONT_CARE;
      }
   }

   return EGL_TRUE;
}


/**
 * Decide the ordering of conf1 and conf2, under the given criteria.
 * When compare_id is true, this implements the algorithm described
 * in "Sorting of EGLConfigs".  When compare_id is false,
 * EGL_CONFIG_ID is not compared.
 *
 * It returns a negative integer if conf1 is considered to come
 * before conf2;  a positive integer if conf2 is considered to come
 * before conf1;  zero if the ordering cannot be decided.
 *
 * Note that EGL_NATIVE_VISUAL_TYPE is platform-dependent and is
 * ignored here.
 */
EGLint
_eglCompareConfigs(const _EGLConfig *conf1, const _EGLConfig *conf2,
                   const _EGLConfig *criteria, EGLBoolean compare_id)
{
   const EGLint compare_attribs[] = {
      EGL_BUFFER_SIZE,
      EGL_SAMPLE_BUFFERS,
      EGL_SAMPLES,
      EGL_DEPTH_SIZE,
      EGL_STENCIL_SIZE,
      EGL_ALPHA_MASK_SIZE,
   };
   EGLint val1, val2;
   EGLint i;

   if (conf1 == conf2)
      return 0;

   /* the enum values have the desired ordering */
   assert(EGL_NONE < EGL_SLOW_CONFIG);
   assert(EGL_SLOW_CONFIG < EGL_NON_CONFORMANT_CONFIG);
   val1 = conf1->ConfigCaveat - conf2->ConfigCaveat;
   if (val1)
      return val1;

   /* the enum values have the desired ordering */
   assert(EGL_RGB_BUFFER < EGL_LUMINANCE_BUFFER);
   val1 = conf1->ColorBufferType - conf2->ColorBufferType;
   if (val1)
      return val1;

   if (criteria) {
      val1 = val2 = 0;
      if (conf1->ColorBufferType == EGL_RGB_BUFFER) {
         if (criteria->RedSize > 0) {
            val1 += conf1->RedSize;
            val2 += conf2->RedSize;
         }
         if (criteria->GreenSize > 0) {
            val1 += conf1->GreenSize;
            val2 += conf2->GreenSize;
         }
         if (criteria->BlueSize > 0) {
            val1 += conf1->BlueSize;
            val2 += conf2->BlueSize;
         }
      }
      else {
         if (criteria->LuminanceSize > 0) {
            val1 += conf1->LuminanceSize;
            val2 += conf2->LuminanceSize;
         }
      }
      if (criteria->AlphaSize > 0) {
         val1 += conf1->AlphaSize;
         val2 += conf2->AlphaSize;
      }
   }
   else {
      /* assume the default criteria, which gives no specific ordering */
      val1 = val2 = 0;
   }

   /* for color bits, larger one is preferred */
   if (val1 != val2)
      return (val2 - val1);

   for (i = 0; i < ARRAY_SIZE(compare_attribs); i++) {
      val1 = _eglGetConfigKey(conf1, compare_attribs[i]);
      val2 = _eglGetConfigKey(conf2, compare_attribs[i]);
      if (val1 != val2)
         return (val1 - val2);
   }

   /* EGL_NATIVE_VISUAL_TYPE cannot be compared here */

   return (compare_id) ? (conf1->ConfigID - conf2->ConfigID) : 0;
}


static INLINE
void _eglSwapConfigs(const _EGLConfig **conf1, const _EGLConfig **conf2)
{
   const _EGLConfig *tmp = *conf1;
   *conf1 = *conf2;
   *conf2 = tmp;
}


/**
 * Quick sort an array of configs.  This differs from the standard
 * qsort() in that the compare function accepts an additional
 * argument.
 */
static void
_eglSortConfigs(const _EGLConfig **configs, EGLint count,
                EGLint (*compare)(const _EGLConfig *, const _EGLConfig *,
                                  void *),
                void *priv_data)
{
   const EGLint pivot = 0;
   EGLint i, j;

   if (count <= 1)
      return;

   _eglSwapConfigs(&configs[pivot], &configs[count / 2]);
   i = 1;
   j = count - 1;
   do {
      while (i < count && compare(configs[i], configs[pivot], priv_data) < 0)
         i++;
      while (compare(configs[j], configs[pivot], priv_data) > 0)
         j--;
      if (i < j) {
         _eglSwapConfigs(&configs[i], &configs[j]);
         i++;
         j--;
      }
      else if (i == j) {
         i++;
         j--;
         break;
      }
   } while (i <= j);
   _eglSwapConfigs(&configs[pivot], &configs[j]);

   _eglSortConfigs(configs, j, compare, priv_data);
   _eglSortConfigs(configs + i, count - i, compare, priv_data);
}


/**
 * A helper function for implementing eglChooseConfig.  See _eglFilterArray and
 * _eglSortConfigs for the meanings of match and compare.
 */
EGLBoolean
_eglFilterConfigArray(_EGLArray *array, EGLConfig *configs,
                      EGLint config_size, EGLint *num_configs,
                      EGLBoolean (*match)(const _EGLConfig *, void *),
                      EGLint (*compare)(const _EGLConfig *, const _EGLConfig *,
                                        void *),
                      void *priv_data)
{
   _EGLConfig **configList;
   EGLint i, count;

   if (!num_configs)
      return _eglError(EGL_BAD_PARAMETER, "eglChooseConfigs");

   /* get the number of matched configs */
   count = _eglFilterArray(array, NULL, 0,
         (_EGLArrayForEach) match, priv_data);
   if (!count) {
      *num_configs = count;
      return EGL_TRUE;
   }

   configList = malloc(sizeof(*configList) * count);
   if (!configList)
      return _eglError(EGL_BAD_ALLOC, "eglChooseConfig(out of memory)");

   /* get the matched configs */
   _eglFilterArray(array, (void **) configList, count,
         (_EGLArrayForEach) match, priv_data);

   /* perform sorting of configs */
   if (configs && count) {
      _eglSortConfigs((const _EGLConfig **) configList, count,
                      compare, priv_data);
      count = MIN2(count, config_size);
      for (i = 0; i < count; i++)
         configs[i] = _eglGetConfigHandle(configList[i]);
   }

   free(configList);

   *num_configs = count;

   return EGL_TRUE;
}


static EGLBoolean
_eglFallbackMatch(const _EGLConfig *conf, void *priv_data)
{
   return _eglMatchConfig(conf, (const _EGLConfig *) priv_data);
}


static EGLint
_eglFallbackCompare(const _EGLConfig *conf1, const _EGLConfig *conf2,
                    void *priv_data)
{
   return _eglCompareConfigs(conf1, conf2,
         (const _EGLConfig *) priv_data, EGL_TRUE);
}


/**
 * Typical fallback routine for eglChooseConfig
 */
EGLBoolean
_eglChooseConfig(_EGLDriver *drv, _EGLDisplay *disp, const EGLint *attrib_list,
                 EGLConfig *configs, EGLint config_size, EGLint *num_configs)
{
   _EGLConfig criteria;

   if (!_eglParseConfigAttribList(&criteria, disp, attrib_list))
      return _eglError(EGL_BAD_ATTRIBUTE, "eglChooseConfig");

   return _eglFilterConfigArray(disp->Configs,
         configs, config_size, num_configs,
         _eglFallbackMatch, _eglFallbackCompare,
         (void *) &criteria);
}


/**
 * Fallback for eglGetConfigAttrib.
 */
EGLBoolean
_eglGetConfigAttrib(_EGLDriver *drv, _EGLDisplay *dpy, _EGLConfig *conf,
                    EGLint attribute, EGLint *value)
{
   if (!_eglIsConfigAttribValid(conf, attribute))
      return _eglError(EGL_BAD_ATTRIBUTE, "eglGetConfigAttrib");

   /* nonqueryable attributes */
   switch (attribute) {
   case EGL_MATCH_NATIVE_PIXMAP:
      return _eglError(EGL_BAD_ATTRIBUTE, "eglGetConfigAttrib");
      break;
   default:
      break;
   }

   if (!value)
      return _eglError(EGL_BAD_PARAMETER, "eglGetConfigAttrib");

   *value = _eglGetConfigKey(conf, attribute);
   return EGL_TRUE;
}


static EGLBoolean
_eglFlattenConfig(void *elem, void *buffer)
{
   _EGLConfig *conf = (_EGLConfig *) elem;
   EGLConfig *handle = (EGLConfig *) buffer;
   *handle = _eglGetConfigHandle(conf);
   return EGL_TRUE;
}

/**
 * Fallback for eglGetConfigs.
 */
EGLBoolean
_eglGetConfigs(_EGLDriver *drv, _EGLDisplay *disp, EGLConfig *configs,
               EGLint config_size, EGLint *num_config)
{
   if (!num_config)
      return _eglError(EGL_BAD_PARAMETER, "eglGetConfigs");

   *num_config = _eglFlattenArray(disp->Configs, (void *) configs,
         sizeof(configs[0]), config_size, _eglFlattenConfig);

   return EGL_TRUE;
}
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d334 1
d339 1
d533 3
a535 2
   /* the spec says that EGL_LEVEL cannot be EGL_DONT_CARE */
   if (conf->Level == EGL_DONT_CARE)
d668 1
a668 1
void
a705 9
static int
_eglFallbackCompare(const _EGLConfig *conf1, const _EGLConfig *conf2,
                   void *priv_data)
{
   const _EGLConfig *criteria = (const _EGLConfig *) priv_data;
   return _eglCompareConfigs(conf1, conf2, criteria, EGL_TRUE);
}


d707 2
a708 1
 * Typical fallback routine for eglChooseConfig
d711 6
a716 2
_eglChooseConfig(_EGLDriver *drv, _EGLDisplay *disp, const EGLint *attrib_list,
                 EGLConfig *configs, EGLint config_size, EGLint *num_configs)
d718 1
a718 1
   _EGLConfig **configList, criteria;
a723 3
   if (!_eglParseConfigAttribList(&criteria, disp, attrib_list))
      return _eglError(EGL_BAD_ATTRIBUTE, "eglChooseConfig");

d725 2
a726 2
   count = _eglFilterArray(disp->Configs, NULL, 0,
         (_EGLArrayForEach) _eglMatchConfig, (void *) &criteria);
d737 2
a738 2
   _eglFilterArray(disp->Configs, (void **) configList, count,
         (_EGLArrayForEach) _eglMatchConfig, (void *) &criteria);
d743 1
a743 1
                      _eglFallbackCompare, (void *) &criteria);
d754 35
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d1 30
a488 2
   case EGL_MATCH_NATIVE_PIXMAP:
      return EGL_FALSE;
d770 10
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a15 1
#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
d27 1
a27 1
_eglInitConfig(_EGLConfig *config, _EGLDisplay *dpy, EGLint id)
d29 1
a29 1
   memset(config, 0, sizeof(*config));
d31 1
a31 1
   config->Display = dpy;
d34 5
a38 7
   SET_CONFIG_ATTRIB(config, EGL_CONFIG_ID,               id);
   SET_CONFIG_ATTRIB(config, EGL_CONFIG_CAVEAT,           EGL_NONE);
   SET_CONFIG_ATTRIB(config, EGL_TRANSPARENT_TYPE,        EGL_NONE);
   SET_CONFIG_ATTRIB(config, EGL_NATIVE_VISUAL_TYPE,      EGL_NONE);
#ifdef EGL_VERSION_1_2
   SET_CONFIG_ATTRIB(config, EGL_COLOR_BUFFER_TYPE,       EGL_RGB_BUFFER);
#endif /* EGL_VERSION_1_2 */
d43 1
a43 1
 * Link a config to a display and return the handle of the link.
d48 2
a49 2
EGLConfig
_eglAddConfig(_EGLDisplay *dpy, _EGLConfig *conf)
d51 1
a51 1
   _EGLConfig **configs;
d54 1
a54 6
   assert(GET_CONFIG_ATTRIB(conf, EGL_CONFIG_ID) > 0);

   configs = dpy->Configs;
   if (dpy->NumConfigs >= dpy->MaxConfigs) {
      EGLint new_size = dpy->MaxConfigs + 16;
      assert(dpy->NumConfigs < new_size);
d56 3
a58 2
      configs = realloc(dpy->Configs, new_size * sizeof(dpy->Configs[0]));
      if (!configs)
a59 3

      dpy->Configs = configs;
      dpy->MaxConfigs = new_size;
d62 1
a62 2
   conf->Display = dpy;
   dpy->Configs[dpy->NumConfigs++] = conf;
d68 6
a73 2
EGLBoolean
_eglCheckConfigHandle(EGLConfig config, _EGLDisplay *dpy)
d75 8
a82 2
   EGLint num_configs = (dpy) ? dpy->NumConfigs : 0;
   EGLint i;
d84 1
a84 8
   for (i = 0; i < num_configs; i++) {
      _EGLConfig *conf = dpy->Configs[i];
      if (conf == (_EGLConfig *) config) {
         assert(conf->Display == dpy);
         break;
      }
   }
   return (i < num_configs);
d113 1
a209 1
   /* these are not real attributes */
d213 4
a216 7
   /* there is a gap before EGL_SAMPLES */
   { 0x3030,                        ATTRIB_TYPE_PSEUDO,
                                    ATTRIB_CRITERION_IGNORE,
                                    0 },
   { EGL_NONE,                      ATTRIB_TYPE_PSEUDO,
                                    ATTRIB_CRITERION_IGNORE,
                                    0 }
a232 5
   EGLint red_size = 0, green_size = 0, blue_size = 0, luminance_size = 0;
   EGLint alpha_size = 0, buffer_size = 0;

   /* all attributes should have been listed */
   assert(ARRAY_SIZE(_eglValidationTable) == _EGL_CONFIG_NUM_ATTRIBS);
d239 1
a239 1
      val = GET_CONFIG_ATTRIB(conf, attr);
d251 1
a251 1
            if (val > 1)
d254 3
a256 17
         case EGL_RED_SIZE:
            red_size = val;
            break;
         case EGL_GREEN_SIZE:
            green_size = val;
            break;
         case EGL_BLUE_SIZE:
            blue_size = val;
            break;
         case EGL_LUMINANCE_SIZE:
            luminance_size = val;
            break;
         case EGL_ALPHA_SIZE:
            alpha_size = val;
            break;
         case EGL_BUFFER_SIZE:
            buffer_size = val;
a258 2
         if (val < 0)
            valid = EGL_FALSE;
d294 1
d297 1
d346 1
a346 1
   switch (GET_CONFIG_ATTRIB(conf, EGL_COLOR_BUFFER_TYPE)) {
d348 1
a348 1
      if (luminance_size)
d350 2
a351 1
      if (red_size + green_size + blue_size + alpha_size != buffer_size)
d355 1
a355 1
      if (red_size || green_size || blue_size)
d357 1
a357 1
      if (luminance_size + alpha_size != buffer_size)
d366 1
a366 2
   val = GET_CONFIG_ATTRIB(conf, EGL_SAMPLE_BUFFERS);
   if (!val && GET_CONFIG_ATTRIB(conf, EGL_SAMPLES))
d373 2
a374 4
   val = GET_CONFIG_ATTRIB(conf, EGL_SURFACE_TYPE);
   if (!(val & EGL_WINDOW_BIT)) {
      if (GET_CONFIG_ATTRIB(conf, EGL_NATIVE_VISUAL_ID) != 0 ||
          GET_CONFIG_ATTRIB(conf, EGL_NATIVE_VISUAL_TYPE) != EGL_NONE)
d377 2
a378 3
   if (!(val & EGL_PBUFFER_BIT)) {
      if (GET_CONFIG_ATTRIB(conf, EGL_BIND_TO_TEXTURE_RGB) ||
          GET_CONFIG_ATTRIB(conf, EGL_BIND_TO_TEXTURE_RGBA))
d410 1
a410 1
      cmp = GET_CONFIG_ATTRIB(criteria, attr);
d414 1
a414 1
      val = GET_CONFIG_ATTRIB(conf, attr);
d437 5
a441 1
#ifdef DEBUG
a444 1
#endif
d452 17
d475 2
a476 1
_eglParseConfigAttribList(_EGLConfig *conf, const EGLint *attrib_list)
d479 2
a480 3
   EGLint config_id = 0, level = 0;
   EGLBoolean has_native_visual_type = EGL_FALSE;
   EGLBoolean has_transparent_color = EGL_FALSE;
d486 1
a486 1
      SET_CONFIG_ATTRIB(conf, attr, val);
a490 2
      EGLint idx;

d494 4
a497 24
      idx = _eglIndexConfig(conf, attr);
      if (idx < 0)
         return EGL_FALSE;
      conf->Storage[idx] = val;

      /* rememeber some attributes for post-processing */
      switch (attr) {
      case EGL_CONFIG_ID:
         config_id = val;
         break;
      case EGL_LEVEL:
         level = val;
         break;
      case EGL_NATIVE_VISUAL_TYPE:
         has_native_visual_type = EGL_TRUE;
         break;
      case EGL_TRANSPARENT_RED_VALUE:
      case EGL_TRANSPARENT_GREEN_VALUE:
      case EGL_TRANSPARENT_BLUE_VALUE:
         has_transparent_color = EGL_TRUE;
         break;
      default:
         break;
      }
d504 1
a504 1
   if (level == EGL_DONT_CARE)
d508 6
a513 3
   if (config_id > 0) {
      _eglResetConfigKeys(conf, EGL_DONT_CARE);
      SET_CONFIG_ATTRIB(conf, EGL_CONFIG_ID, config_id);
d516 2
a517 5
      if (has_native_visual_type) {
         val = GET_CONFIG_ATTRIB(conf, EGL_SURFACE_TYPE);
         if (!(val & EGL_WINDOW_BIT))
            SET_CONFIG_ATTRIB(conf, EGL_NATIVE_VISUAL_TYPE, EGL_DONT_CARE);
      }
d519 4
a522 10
      if (has_transparent_color) {
         val = GET_CONFIG_ATTRIB(conf, EGL_TRANSPARENT_TYPE);
         if (val == EGL_NONE) {
            SET_CONFIG_ATTRIB(conf, EGL_TRANSPARENT_RED_VALUE,
                              EGL_DONT_CARE);
            SET_CONFIG_ATTRIB(conf, EGL_TRANSPARENT_GREEN_VALUE,
                              EGL_DONT_CARE);
            SET_CONFIG_ATTRIB(conf, EGL_TRANSPARENT_BLUE_VALUE,
                              EGL_DONT_CARE);
         }
a555 1
   EGLBoolean rgb_buffer;
d564 3
a566 4
   val1 = GET_CONFIG_ATTRIB(conf1, EGL_CONFIG_CAVEAT);
   val2 = GET_CONFIG_ATTRIB(conf2, EGL_CONFIG_CAVEAT);
   if (val1 != val2)
      return (val1 - val2);
d570 3
a572 5
   val1 = GET_CONFIG_ATTRIB(conf1, EGL_COLOR_BUFFER_TYPE);
   val2 = GET_CONFIG_ATTRIB(conf2, EGL_COLOR_BUFFER_TYPE);
   if (val1 != val2)
      return (val1 - val2);
   rgb_buffer = (val1 == EGL_RGB_BUFFER);
d576 4
a579 4
      if (rgb_buffer) {
         if (GET_CONFIG_ATTRIB(criteria, EGL_RED_SIZE) > 0) {
            val1 += GET_CONFIG_ATTRIB(conf1, EGL_RED_SIZE);
            val2 += GET_CONFIG_ATTRIB(conf2, EGL_RED_SIZE);
d581 3
a583 3
         if (GET_CONFIG_ATTRIB(criteria, EGL_GREEN_SIZE) > 0) {
            val1 += GET_CONFIG_ATTRIB(conf1, EGL_GREEN_SIZE);
            val2 += GET_CONFIG_ATTRIB(conf2, EGL_GREEN_SIZE);
d585 3
a587 3
         if (GET_CONFIG_ATTRIB(criteria, EGL_BLUE_SIZE) > 0) {
            val1 += GET_CONFIG_ATTRIB(conf1, EGL_BLUE_SIZE);
            val2 += GET_CONFIG_ATTRIB(conf2, EGL_BLUE_SIZE);
d591 3
a593 3
         if (GET_CONFIG_ATTRIB(criteria, EGL_LUMINANCE_SIZE) > 0) {
            val1 += GET_CONFIG_ATTRIB(conf1, EGL_LUMINANCE_SIZE);
            val2 += GET_CONFIG_ATTRIB(conf2, EGL_LUMINANCE_SIZE);
d596 3
a598 3
      if (GET_CONFIG_ATTRIB(criteria, EGL_ALPHA_SIZE) > 0) {
         val1 += GET_CONFIG_ATTRIB(conf1, EGL_ALPHA_SIZE);
         val2 += GET_CONFIG_ATTRIB(conf2, EGL_ALPHA_SIZE);
d611 2
a612 2
      val1 = GET_CONFIG_ATTRIB(conf1, compare_attribs[i]);
      val2 = GET_CONFIG_ATTRIB(conf2, compare_attribs[i]);
d619 1
a619 10
   if (compare_id) {
      val1 = GET_CONFIG_ATTRIB(conf1, EGL_CONFIG_ID);
      val2 = GET_CONFIG_ATTRIB(conf2, EGL_CONFIG_ID);
      assert(val1 != val2);
   }
   else {
      val1 = val2 = 0;
   }

   return (val1 - val2);
d697 1
a697 2
   _eglInitConfig(&criteria, disp, 0);
   if (!_eglParseConfigAttribList(&criteria, attrib_list))
d700 9
a708 3
   /* allocate array of config pointers */
   configList = (_EGLConfig **)
      malloc(disp->NumConfigs * sizeof(_EGLConfig *));
d712 3
a714 6
   /* perform selection of configs */
   count = 0;
   for (i = 0; i < disp->NumConfigs; i++) {
      if (_eglMatchConfig(disp->Configs[i], &criteria))
         configList[count++] = disp->Configs[i];
   }
a732 22
static INLINE EGLBoolean
_eglIsConfigAttribValid(_EGLConfig *conf, EGLint attr)
{
   if (_eglIndexConfig(conf, attr) < 0)
      return EGL_FALSE;

   /* there are some holes in the range */
   switch (attr) {
   case 0x3030 /* a gap before EGL_SAMPLES */:
   case EGL_NONE:
#ifdef EGL_VERSION_1_4
   case EGL_MATCH_NATIVE_PIXMAP:
#endif
      return EGL_FALSE;
   default:
      break;
   }

   return EGL_TRUE;
}


d745 1
a745 1
   *value = GET_CONFIG_ATTRIB(conf, attribute);
d750 9
d769 2
a770 10
   if (configs) {
      EGLint i;
      *num_config = MIN2(disp->NumConfigs, config_size);
      for (i = 0; i < *num_config; i++)
         configs[i] = _eglGetConfigHandle(disp->Configs[i]);
   }
   else {
      /* just return total number of supported configs */
      *num_config = disp->NumConfigs;
   }
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a6 1
#include <stdio.h>
d11 1
a11 2
#include "egldriver.h"
#include "eglglobals.h"
d16 1
d20 6
a25 4
 * Convert an _EGLConfig to a __GLcontextModes object.
 * NOTE: This routine may be incomplete - we're only making sure that
 * the fields needed by Mesa (for _mesa_create_context/framebuffer) are
 * set correctly.
d28 1
a28 1
_eglConfigToContextModesRec(const _EGLConfig *config, __GLcontextModes *mode)
d30 1
a30 1
   memset(mode, 0, sizeof(*mode));
d32 1
a32 4
   mode->rgbMode = GL_TRUE; /* no color index */
   mode->colorIndexMode = GL_FALSE;
   mode->doubleBufferMode = GL_TRUE;  /* always DB for now */
   mode->stereoMode = GL_FALSE;
d34 9
a42 5
   mode->redBits = GET_CONFIG_ATTRIB(config, EGL_RED_SIZE);
   mode->greenBits = GET_CONFIG_ATTRIB(config, EGL_GREEN_SIZE);
   mode->blueBits = GET_CONFIG_ATTRIB(config, EGL_BLUE_SIZE);
   mode->alphaBits = GET_CONFIG_ATTRIB(config, EGL_ALPHA_SIZE);
   mode->rgbBits = GET_CONFIG_ATTRIB(config, EGL_BUFFER_SIZE);
a43 1
   /* no rgba masks - fix? */
d45 10
a54 2
   mode->depthBits = GET_CONFIG_ATTRIB(config, EGL_DEPTH_SIZE);
   mode->haveDepthBuffer = mode->depthBits > 0;
d56 2
a57 2
   mode->stencilBits = GET_CONFIG_ATTRIB(config, EGL_STENCIL_SIZE);
   mode->haveStencilBuffer = mode->stencilBits > 0;
d59 4
a62 1
   /* no accum */
d64 3
a66 3
   mode->level = GET_CONFIG_ATTRIB(config, EGL_LEVEL);
   mode->samples = GET_CONFIG_ATTRIB(config, EGL_SAMPLES);
   mode->sampleBuffers = GET_CONFIG_ATTRIB(config, EGL_SAMPLE_BUFFERS);
d68 8
a75 3
   /* surface type - not really needed */
   mode->visualType = GLX_TRUE_COLOR;
   mode->renderType = GLX_RGBA_BIT;
d79 2
a80 2
void
_eglSetConfigAttrib(_EGLConfig *config, EGLint attr, EGLint val)
d82 11
a92 3
   assert(attr >= FIRST_ATTRIB);
   assert(attr < FIRST_ATTRIB + MAX_ATTRIBS);
   config->Attrib[attr - FIRST_ATTRIB] = val;
d96 133
a228 29
/**
 * Init the given _EGLconfig to default values.
 * \param id  the configuration's ID.
 */
void
_eglInitConfig(_EGLConfig *config, EGLint id)
{
   memset(config, 0, sizeof(*config));
   config->Handle = id;
   _eglSetConfigAttrib(config, EGL_CONFIG_ID,               id);
   _eglSetConfigAttrib(config, EGL_BIND_TO_TEXTURE_RGB,     EGL_DONT_CARE);
   _eglSetConfigAttrib(config, EGL_BIND_TO_TEXTURE_RGBA,    EGL_DONT_CARE);
   _eglSetConfigAttrib(config, EGL_CONFIG_CAVEAT,           EGL_DONT_CARE);
   _eglSetConfigAttrib(config, EGL_NATIVE_RENDERABLE,       EGL_DONT_CARE);
   _eglSetConfigAttrib(config, EGL_NATIVE_VISUAL_TYPE,      EGL_DONT_CARE);
   _eglSetConfigAttrib(config, EGL_MIN_SWAP_INTERVAL,       EGL_DONT_CARE);
   _eglSetConfigAttrib(config, EGL_MAX_SWAP_INTERVAL,       EGL_DONT_CARE);
   _eglSetConfigAttrib(config, EGL_SURFACE_TYPE,            
                   EGL_SCREEN_BIT_MESA | EGL_PBUFFER_BIT |
                   EGL_PIXMAP_BIT | EGL_WINDOW_BIT);
   _eglSetConfigAttrib(config, EGL_TRANSPARENT_TYPE,        EGL_NONE);
   _eglSetConfigAttrib(config, EGL_TRANSPARENT_RED_VALUE,   EGL_DONT_CARE);
   _eglSetConfigAttrib(config, EGL_TRANSPARENT_GREEN_VALUE, EGL_DONT_CARE);
   _eglSetConfigAttrib(config, EGL_TRANSPARENT_BLUE_VALUE,  EGL_DONT_CARE);
#ifdef EGL_VERSION_1_2
   _eglSetConfigAttrib(config, EGL_COLOR_BUFFER_TYPE,       EGL_RGB_BUFFER);
   _eglSetConfigAttrib(config, EGL_RENDERABLE_TYPE,         EGL_OPENGL_ES_BIT);
#endif /* EGL_VERSION_1_2 */
}
d232 6
a237 1
 * Given an EGLConfig handle, return the corresponding _EGLConfig object.
d239 2
a240 2
_EGLConfig *
_eglLookupConfig(_EGLDriver *drv, EGLDisplay dpy, EGLConfig config)
d242 125
a366 5
   EGLint i;
   _EGLDisplay *disp = _eglLookupDisplay(dpy);
   for (i = 0; i < disp->NumConfigs; i++) {
      if (disp->Configs[i].Handle == config) {
          return disp->Configs + i;
d369 51
a419 1
   return NULL;
d424 6
a429 1
 * Add the given _EGLConfig to the given display.
d431 2
a432 2
_EGLConfig *
_eglAddConfig(_EGLDisplay *display, const _EGLConfig *config)
d434 2
a435 2
   _EGLConfig *newConfigs;
   EGLint n;
d437 41
a477 1
   n = display->NumConfigs;
d479 1
a479 12
   newConfigs = (_EGLConfig *) realloc(display->Configs,
                                       (n + 1) * sizeof(_EGLConfig));
   if (newConfigs) {
      display->Configs = newConfigs;
      display->Configs[n] = *config; /* copy struct */
      display->Configs[n].Handle = n;
      display->NumConfigs++;
      return display->Configs + n;
   }
   else {
      return NULL;
   }
d484 2
a485 2
 * Parse the attrib_list to fill in the fields of the given _eglConfig
 * Return EGL_FALSE if any errors, EGL_TRUE otherwise.
d488 1
a488 1
_eglParseConfigAttribs(_EGLConfig *config, const EGLint *attrib_list)
d490 4
a493 1
   EGLint i;
d495 5
a499 3
   /* set all config attribs to EGL_DONT_CARE */
   for (i = 0; i < MAX_ATTRIBS; i++) {
      config->Attrib[i] = EGL_DONT_CARE;
d502 9
a510 34
   for (i = 0; attrib_list && attrib_list[i] != EGL_NONE; i++) {
      const EGLint attr = attrib_list[i];
      if (attr >= EGL_BUFFER_SIZE &&
          attr <= EGL_MAX_SWAP_INTERVAL) {
         EGLint k = attr - FIRST_ATTRIB;
         assert(k >= 0);
         assert(k < MAX_ATTRIBS);
         config->Attrib[k] = attrib_list[++i];
      }
#ifdef EGL_VERSION_1_2
      else if (attr == EGL_COLOR_BUFFER_TYPE) {
         EGLint bufType = attrib_list[++i];
         if (bufType != EGL_RGB_BUFFER && bufType != EGL_LUMINANCE_BUFFER) {
            _eglError(EGL_BAD_ATTRIBUTE, "eglChooseConfig");
            return EGL_FALSE;
         }
         _eglSetConfigAttrib(config, EGL_COLOR_BUFFER_TYPE, bufType);
      }
      else if (attr == EGL_RENDERABLE_TYPE) {
         EGLint renType = attrib_list[++i];
         if (renType & ~(EGL_OPENGL_ES_BIT | EGL_OPENVG_BIT)) {
            _eglError(EGL_BAD_ATTRIBUTE, "eglChooseConfig");
            return EGL_FALSE;
         }
         _eglSetConfigAttrib(config, EGL_RENDERABLE_TYPE, renType);
      }
      else if (attr == EGL_ALPHA_MASK_SIZE ||
               attr == EGL_LUMINANCE_SIZE) {
         EGLint value = attrib_list[++i];
         _eglSetConfigAttrib(config, attr, value);
      }
#endif /* EGL_VERSION_1_2 */
      else {
         _eglError(EGL_BAD_ATTRIBUTE, "eglChooseConfig");
d512 20
a533 2
   return EGL_TRUE;
}
d535 2
d538 3
a540 12
#define EXACT 1
#define ATLEAST 2
#define MASK 3
#define SMALLER 4
#define SPECIAL 5
#define NONE 6

struct sort_info {
   EGLint Attribute;
   EGLint MatchCriteria;
   EGLint SortOrder;
};
d542 11
a552 31
/* This encodes the info from Table 3.5 of the EGL spec, ordered by
 * Sort Priority.
 *
 * XXX To do: EGL 1.2 attribs
 */
static struct sort_info SortInfo[] = {
   { EGL_CONFIG_CAVEAT,           EXACT,   SPECIAL },
   { EGL_RED_SIZE,                ATLEAST, SPECIAL },
   { EGL_GREEN_SIZE,              ATLEAST, SPECIAL },
   { EGL_BLUE_SIZE,               ATLEAST, SPECIAL },
   { EGL_ALPHA_SIZE,              ATLEAST, SPECIAL },
   { EGL_BUFFER_SIZE,             ATLEAST, SMALLER },
   { EGL_SAMPLE_BUFFERS,          ATLEAST, SMALLER },
   { EGL_SAMPLES,                 ATLEAST, SMALLER },
   { EGL_DEPTH_SIZE,              ATLEAST, SMALLER },
   { EGL_STENCIL_SIZE,            ATLEAST, SMALLER },
   { EGL_NATIVE_VISUAL_TYPE,      EXACT,   SPECIAL },
   { EGL_CONFIG_ID,               EXACT,   SMALLER },
   { EGL_BIND_TO_TEXTURE_RGB,     EXACT,   NONE    },
   { EGL_BIND_TO_TEXTURE_RGBA,    EXACT,   NONE    },
   { EGL_LEVEL,                   EXACT,   NONE    },
   { EGL_NATIVE_RENDERABLE,       EXACT,   NONE    },
   { EGL_MAX_SWAP_INTERVAL,       EXACT,   NONE    },
   { EGL_MIN_SWAP_INTERVAL,       EXACT,   NONE    },
   { EGL_SURFACE_TYPE,            MASK,    NONE    },
   { EGL_TRANSPARENT_TYPE,        EXACT,   NONE    },
   { EGL_TRANSPARENT_RED_VALUE,   EXACT,   NONE    },
   { EGL_TRANSPARENT_GREEN_VALUE, EXACT,   NONE    },
   { EGL_TRANSPARENT_BLUE_VALUE,  EXACT,   NONE    },
   { 0, 0, 0 }
};
d554 9
a562 28

/**
 * Return EGL_TRUE if the attributes of c meet or exceed the minimums
 * specified by min.
 */
static EGLBoolean
_eglConfigQualifies(const _EGLConfig *c, const _EGLConfig *min)
{
   EGLint i;
   for (i = 0; SortInfo[i].Attribute != 0; i++) {
      const EGLint mv = GET_CONFIG_ATTRIB(min, SortInfo[i].Attribute);
      if (mv != EGL_DONT_CARE) {
         const EGLint cv = GET_CONFIG_ATTRIB(c, SortInfo[i].Attribute);
         if (SortInfo[i].MatchCriteria == EXACT) {
            if (cv != mv) {
               return EGL_FALSE;
            }
         }
         else if (SortInfo[i].MatchCriteria == ATLEAST) {
            if (cv < mv) {
               return EGL_FALSE;
            }
         }
         else {
            assert(SortInfo[i].MatchCriteria == MASK);
            if ((mv & cv) != mv) {
               return EGL_FALSE;
            }
d566 1
d572 11
a582 3
 * Compare configs 'a' and 'b' and return -1 if a belongs before b,
 * 1 if a belongs after b, or 0 if they're equal.
 * Used by qsort().
d584 14
a597 5
static int
_eglCompareConfigs(const void *a, const void *b)
{
   const _EGLConfig *aConfig = (const _EGLConfig *) a;
   const _EGLConfig *bConfig = (const _EGLConfig *) b;
d600 25
a624 17
   for (i = 0; SortInfo[i].Attribute != 0; i++) {
      const EGLint aVal = GET_CONFIG_ATTRIB(aConfig, SortInfo[i].Attribute);
      const EGLint bVal = GET_CONFIG_ATTRIB(bConfig, SortInfo[i].Attribute);
      if (SortInfo[i].SortOrder == SMALLER) {
         if (aVal < bVal)
            return -1;
         else if (aVal > bVal)
            return 1;
         /* else, continue examining attribute values */
      }
      else if (SortInfo[i].SortOrder == SPECIAL) {
         if (SortInfo[i].Attribute == EGL_CONFIG_CAVEAT) {
            /* values are EGL_NONE, SLOW_CONFIG, or NON_CONFORMANT_CONFIG */
            if (aVal < bVal)
               return -1;
            else if (aVal > bVal)
               return 1;
d626 3
a628 8
         else if (SortInfo[i].Attribute == EGL_RED_SIZE ||
                  SortInfo[i].Attribute == EGL_GREEN_SIZE ||
                  SortInfo[i].Attribute == EGL_BLUE_SIZE ||
                  SortInfo[i].Attribute == EGL_ALPHA_SIZE) {
            if (aVal > bVal)
               return -1;
            else if (aVal < bVal)
               return 1;
d630 3
a632 6
         else {
            assert(SortInfo[i].Attribute == EGL_NATIVE_VISUAL_TYPE);
            if (aVal < bVal)
               return -1;
            else if (aVal > bVal)
               return 1;
d636 4
a639 2
         assert(SortInfo[i].SortOrder == NONE);
         /* continue examining attribute values */
d641 19
d662 73
a734 2
   /* all attributes identical */
   return 0;
d742 1
a742 1
_eglChooseConfig(_EGLDriver *drv, EGLDisplay dpy, const EGLint *attrib_list,
a744 1
   _EGLDisplay *disp = _eglLookupDisplay(dpy);
d748 6
a753 4
   /* parse the attrib_list to initialize criteria */
   if (!_eglParseConfigAttribs(&criteria, attrib_list)) {
      return EGL_FALSE;
   }
d756 4
a759 5
   configList = (_EGLConfig **) malloc(config_size * sizeof(_EGLConfig *));
   if (!configList) {
      _eglError(EGL_BAD_CONFIG, "eglChooseConfig(out of memory)");
      return EGL_FALSE;
   }
d761 5
a765 5
   /* make array of pointers to qualifying configs */
   for (i = count = 0; i < disp->NumConfigs && count < config_size; i++) {
      if (_eglConfigQualifies(disp->Configs + i, &criteria)) {
         configList[count++] = disp->Configs + i;
      }
d768 7
a774 6
   /* sort array of pointers */
   qsort(configList, count, sizeof(_EGLConfig *), _eglCompareConfigs);

   /* copy config handles to output array */
   for (i = 0; i < count; i++) {
      configs[i] = configList[i]->Handle;
d785 22
d811 1
a811 1
_eglGetConfigAttrib(_EGLDriver *drv, EGLDisplay dpy, EGLConfig config,
d814 7
a820 10
   const _EGLConfig *conf = _eglLookupConfig(drv, dpy, config);
   const EGLint k = attribute - FIRST_ATTRIB;
   if (k >= 0 && k < MAX_ATTRIBS) {
      *value = conf->Attrib[k];
      return EGL_TRUE;
   }
   else {
      _eglError(EGL_BAD_ATTRIBUTE, "eglGetConfigAttrib");
      return EGL_FALSE;
   }
d828 1
a828 1
_eglGetConfigs(_EGLDriver *drv, EGLDisplay dpy, EGLConfig *configs,
d831 2
a832 6
   _EGLDisplay *disp = _eglLookupDisplay(dpy);

   if (!drv->Initialized) {
      _eglError(EGL_NOT_INITIALIZED, "eglGetConfigs");
      return EGL_FALSE;
   }
d837 2
a838 3
      for (i = 0; i < *num_config; i++) {
         configs[i] = disp->Configs[i].Handle;
      }
a845 207
}


/**
 * Creates a set of \c __GLcontextModes that a driver will expose.
 * 
 * A set of \c __GLcontextModes will be created based on the supplied
 * parameters.  The number of modes processed will be 2 *
 * \c num_depth_stencil_bits * \c num_db_modes.
 * 
 * For the most part, data is just copied from \c depth_bits, \c stencil_bits,
 * \c db_modes, and \c visType into each \c __GLcontextModes element.
 * However, the meanings of \c fb_format and \c fb_type require further
 * explanation.  The \c fb_format specifies which color components are in
 * each pixel and what the default order is.  For example, \c GL_RGB specifies
 * that red, green, blue are available and red is in the "most significant"
 * position and blue is in the "least significant".  The \c fb_type specifies
 * the bit sizes of each component and the actual ordering.  For example, if
 * \c GL_UNSIGNED_SHORT_5_6_5_REV is specified with \c GL_RGB, bits [15:11]
 * are the blue value, bits [10:5] are the green value, and bits [4:0] are
 * the red value.
 * 
 * One sublte issue is the combination of \c GL_RGB  or \c GL_BGR and either
 * of the \c GL_UNSIGNED_INT_8_8_8_8 modes.  The resulting mask values in the
 * \c __GLcontextModes structure is \b identical to the \c GL_RGBA or
 * \c GL_BGRA case, except the \c alphaMask is zero.  This means that, as
 * far as this routine is concerned, \c GL_RGB with \c GL_UNSIGNED_INT_8_8_8_8
 * still uses 32-bits.
 *
 * If in doubt, look at the tables used in the function.
 * 
 * \param ptr_to_modes  Pointer to a pointer to a linked list of
 *                      \c __GLcontextModes.  Upon completion, a pointer to
 *                      the next element to be process will be stored here.
 *                      If the function fails and returns \c GL_FALSE, this
 *                      value will be unmodified, but some elements in the
 *                      linked list may be modified.
 * \param fb_format     Format of the framebuffer.  Currently only \c GL_RGB,
 *                      \c GL_RGBA, \c GL_BGR, and \c GL_BGRA are supported.
 * \param fb_type       Type of the pixels in the framebuffer.  Currently only
 *                      \c GL_UNSIGNED_SHORT_5_6_5, 
 *                      \c GL_UNSIGNED_SHORT_5_6_5_REV,
 *                      \c GL_UNSIGNED_INT_8_8_8_8, and
 *                      \c GL_UNSIGNED_INT_8_8_8_8_REV are supported.
 * \param depth_bits    Array of depth buffer sizes to be exposed.
 * \param stencil_bits  Array of stencil buffer sizes to be exposed.
 * \param num_depth_stencil_bits  Number of entries in both \c depth_bits and
 *                      \c stencil_bits.
 * \param db_modes      Array of buffer swap modes.  If an element has a
 *                      value of \c GLX_NONE, then it represents a
 *                      single-buffered mode.  Other valid values are
 *                      \c GLX_SWAP_EXCHANGE_OML, \c GLX_SWAP_COPY_OML, and
 *                      \c GLX_SWAP_UNDEFINED_OML.  See the
 *                      GLX_OML_swap_method extension spec for more details.
 * \param num_db_modes  Number of entries in \c db_modes.
 * \param visType       GLX visual type.  Usually either \c GLX_TRUE_COLOR or
 *                      \c GLX_DIRECT_COLOR.
 * 
 * \returns
 * \c GL_TRUE on success or \c GL_FALSE on failure.  Currently the only
 * cause of failure is a bad parameter (i.e., unsupported \c fb_format or
 * \c fb_type).
 * 
 * \todo
 * There is currently no way to support packed RGB modes (i.e., modes with
 * exactly 3 bytes per pixel) or floating-point modes.  This could probably
 * be done by creating some new, private enums with clever names likes
 * \c GL_UNSIGNED_3BYTE_8_8_8, \c GL_4FLOAT_32_32_32_32, 
 * \c GL_4HALF_16_16_16_16, etc.  We can cross that bridge when we come to it.
 */
GLboolean
_eglFillInConfigs(_EGLConfig * configs,
                  GLenum fb_format, GLenum fb_type,
                  const uint8_t * depth_bits, const uint8_t * stencil_bits,
                  unsigned num_depth_stencil_bits,
                  const GLenum * db_modes, unsigned num_db_modes,
                  int visType)
{
   static const uint8_t bits_table[3][4] = {
            /* R  G  B  A */
            { 5, 6, 5, 0 },  /* Any GL_UNSIGNED_SHORT_5_6_5 */
            { 8, 8, 8, 0 },  /* Any RGB with any GL_UNSIGNED_INT_8_8_8_8 */
            { 8, 8, 8, 8 }  /* Any RGBA with any GL_UNSIGNED_INT_8_8_8_8 */
         };

   /* The following arrays are all indexed by the fb_type masked with 0x07.
    * Given the four supported fb_type values, this results in valid array
    * indices of 3, 4, 5, and 7.
    */
   static const uint32_t masks_table_rgb[8][4] = {
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x0000F800, 0x000007E0, 0x0000001F, 0x00000000},  /* 5_6_5       */
            {0x0000001F, 0x000007E0, 0x0000F800, 0x00000000},  /* 5_6_5_REV   */
            {0xFF000000, 0x00FF0000, 0x0000FF00, 0x00000000},  /* 8_8_8_8     */
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x000000FF, 0x0000FF00, 0x00FF0000, 0x00000000}  /* 8_8_8_8_REV */
         };

   static const uint32_t masks_table_rgba[8][4] = {
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x0000F800, 0x000007E0, 0x0000001F, 0x00000000},  /* 5_6_5       */
            {0x0000001F, 0x000007E0, 0x0000F800, 0x00000000},  /* 5_6_5_REV   */
            {0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF},  /* 8_8_8_8     */
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000},  /* 8_8_8_8_REV */
         };

   static const uint32_t masks_table_bgr[8][4] = {
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x0000001F, 0x000007E0, 0x0000F800, 0x00000000},  /* 5_6_5       */
            {0x0000F800, 0x000007E0, 0x0000001F, 0x00000000},  /* 5_6_5_REV   */
            {0x0000FF00, 0x00FF0000, 0xFF000000, 0x00000000},  /* 8_8_8_8     */
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x00FF0000, 0x0000FF00, 0x000000FF, 0x00000000},  /* 8_8_8_8_REV */
         };

   static const uint32_t masks_table_bgra[8][4] = {
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x0000001F, 0x000007E0, 0x0000F800, 0x00000000},  /* 5_6_5       */
            {0x0000F800, 0x000007E0, 0x0000001F, 0x00000000},  /* 5_6_5_REV   */
            {0x0000FF00, 0x00FF0000, 0xFF000000, 0x000000FF},  /* 8_8_8_8     */
            {0x00000000, 0x00000000, 0x00000000, 0x00000000},
            {0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000},  /* 8_8_8_8_REV */
         };

   static const uint8_t bytes_per_pixel[8] = {
            0, 0, 0, 2, 2, 4, 0, 4
         };

   const uint8_t * bits;
   const uint32_t * masks;
   const int index = fb_type & 0x07;
   _EGLConfig *config;
   unsigned i;
   unsigned j;
   unsigned k;

   if ( bytes_per_pixel[index] == 0 ) {
      _eglLog(_EGL_INFO,
              "[%s:%u] Framebuffer type 0x%04x has 0 bytes per pixel.",
              __FUNCTION__, __LINE__, fb_type);
      return GL_FALSE;
   }

   /* Valid types are GL_UNSIGNED_SHORT_5_6_5 and GL_UNSIGNED_INT_8_8_8_8 and
    * the _REV versions.
    *
    * Valid formats are GL_RGBA, GL_RGB, and GL_BGRA.
    */
   switch ( fb_format ) {
   case GL_RGB:
      bits = (bytes_per_pixel[index] == 2) ? bits_table[0] : bits_table[1];
      masks = masks_table_rgb[index];
      break;

   case GL_RGBA:
      bits = (bytes_per_pixel[index] == 2) ? bits_table[0] : bits_table[2];
      masks = masks_table_rgba[index];
      break;

   case GL_BGR:
      bits = (bytes_per_pixel[index] == 2) ? bits_table[0] : bits_table[1];
      masks = masks_table_bgr[index];
      break;

   case GL_BGRA:
      bits = (bytes_per_pixel[index] == 2) ? bits_table[0] : bits_table[2];
      masks = masks_table_bgra[index];
      break;

   default:
      _eglLog(_EGL_WARNING,
              "[%s:%u] Framebuffer format 0x%04x is not GL_RGB, GL_RGBA, GL_BGR, or GL_BGRA.",
              __FUNCTION__, __LINE__, fb_format);
      return GL_FALSE;
   }

   config = configs;
   for (k = 0; k < num_depth_stencil_bits; k++) {
      for (i = 0; i < num_db_modes; i++)  {
         for (j = 0; j < 2; j++) {
            _eglSetConfigAttrib(config, EGL_RED_SIZE, bits[0]);
            _eglSetConfigAttrib(config, EGL_GREEN_SIZE, bits[1]);
            _eglSetConfigAttrib(config, EGL_BLUE_SIZE, bits[2]);
            _eglSetConfigAttrib(config, EGL_ALPHA_SIZE, bits[3]);
            _eglSetConfigAttrib(config, EGL_BUFFER_SIZE,
                                bits[0] + bits[1] + bits[2] + bits[3]);

            _eglSetConfigAttrib(config, EGL_STENCIL_SIZE, stencil_bits[k]);
            _eglSetConfigAttrib(config, EGL_DEPTH_SIZE, depth_bits[i]);

            _eglSetConfigAttrib(config, EGL_SURFACE_TYPE, EGL_SCREEN_BIT_MESA |
                         EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_WINDOW_BIT);

            config++;
         }
      }
   }
   return GL_TRUE;
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d504 1
a504 1
                  const u_int8_t * depth_bits, const u_int8_t * stencil_bits,
d509 1
a509 1
   static const u_int8_t bits_table[3][4] = {
d520 1
a520 1
   static const u_int32_t masks_table_rgb[8][4] = {
d531 1
a531 1
   static const u_int32_t masks_table_rgba[8][4] = {
d542 1
a542 1
   static const u_int32_t masks_table_bgr[8][4] = {
d553 1
a553 1
   static const u_int32_t masks_table_bgra[8][4] = {
d564 1
a564 1
   static const u_int8_t bytes_per_pixel[8] = {
d568 2
a569 2
   const u_int8_t * bits;
   const u_int32_t * masks;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d7 1
d12 2
a13 1
#include "eglcurrent.h"
d21 4
a24 6
 * Init the given _EGLconfig to default values.
 * \param id  the configuration's ID.
 *
 * Note that id must be positive for the config to be valid.
 * It is also recommended that when there are N configs, their
 * IDs are from 1 to N respectively.
d27 1
a27 1
_eglInitConfig(_EGLConfig *conf, _EGLDisplay *dpy, EGLint id)
d29 1
a29 1
   memset(conf, 0, sizeof(*conf));
d31 4
a34 1
   conf->Display = dpy;
d36 10
a45 7
   /* some attributes take non-zero default values */
   conf->ConfigID = id;
   conf->ConfigCaveat = EGL_NONE;
   conf->TransparentType = EGL_NONE;
   conf->NativeVisualType = EGL_NONE;
   conf->ColorBufferType = EGL_RGB_BUFFER;
}
d47 2
d50 1
a50 10
/**
 * Link a config to its display and return the handle of the link.
 * The handle can be passed to client directly.
 *
 * Note that we just save the ptr to the config (we don't copy the config).
 */
PUBLIC EGLConfig
_eglLinkConfig(_EGLConfig *conf)
{
   _EGLDisplay *dpy = conf->Display;
d52 3
a54 2
   /* sanity check */
   assert(dpy && conf->ConfigID > 0);
d56 4
a59 5
   if (!dpy->Configs) {
      dpy->Configs = _eglCreateArray("Config", 16);
      if (!dpy->Configs)
         return (EGLConfig) NULL;
   }
a60 1
   _eglAppendArray(dpy->Configs, (void *) conf);
d62 6
a67 1
   return (EGLConfig) conf;
d72 2
a73 2
 * Lookup a handle to find the linked config.
 * Return NULL if the handle has no corresponding linked config.
d75 2
a76 2
_EGLConfig *
_eglLookupConfig(EGLConfig config, _EGLDisplay *dpy)
d78 21
a98 10
   _EGLConfig *conf;

   if (!dpy)
      return NULL;

   conf = (_EGLConfig *) _eglFindArray(dpy->Configs, (void *) config);
   if (conf)
      assert(conf->Display == dpy);

   return conf;
a101 132
enum {
   /* types */
   ATTRIB_TYPE_INTEGER,
   ATTRIB_TYPE_BOOLEAN,
   ATTRIB_TYPE_BITMASK,
   ATTRIB_TYPE_ENUM,
   ATTRIB_TYPE_PSEUDO, /* non-queryable */
   ATTRIB_TYPE_PLATFORM, /* platform-dependent */
   /* criteria */
   ATTRIB_CRITERION_EXACT,
   ATTRIB_CRITERION_ATLEAST,
   ATTRIB_CRITERION_MASK,
   ATTRIB_CRITERION_SPECIAL,
   ATTRIB_CRITERION_IGNORE
};


/* EGL spec Table 3.1 and 3.4 */
static const struct {
   EGLint attr;
   EGLint type;
   EGLint criterion;
   EGLint default_value;
} _eglValidationTable[] =
{
   /* core */
   { EGL_BUFFER_SIZE,               ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_RED_SIZE,                  ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_GREEN_SIZE,                ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_BLUE_SIZE,                 ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_LUMINANCE_SIZE,            ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_ALPHA_SIZE,                ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_ALPHA_MASK_SIZE,           ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_BIND_TO_TEXTURE_RGB,       ATTRIB_TYPE_BOOLEAN,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_BIND_TO_TEXTURE_RGBA,      ATTRIB_TYPE_BOOLEAN,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_COLOR_BUFFER_TYPE,         ATTRIB_TYPE_ENUM,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_RGB_BUFFER },
   { EGL_CONFIG_CAVEAT,             ATTRIB_TYPE_ENUM,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_CONFIG_ID,                 ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_CONFORMANT,                ATTRIB_TYPE_BITMASK,
                                    ATTRIB_CRITERION_MASK,
                                    0 },
   { EGL_DEPTH_SIZE,                ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_LEVEL,                     ATTRIB_TYPE_PLATFORM,
                                    ATTRIB_CRITERION_EXACT,
                                    0 },
   { EGL_MAX_PBUFFER_WIDTH,         ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_IGNORE,
                                    0 },
   { EGL_MAX_PBUFFER_HEIGHT,        ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_IGNORE,
                                    0 },
   { EGL_MAX_PBUFFER_PIXELS,        ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_IGNORE,
                                    0 },
   { EGL_MAX_SWAP_INTERVAL,         ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_MIN_SWAP_INTERVAL,         ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_NATIVE_RENDERABLE,         ATTRIB_TYPE_BOOLEAN,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_NATIVE_VISUAL_ID,          ATTRIB_TYPE_PLATFORM,
                                    ATTRIB_CRITERION_IGNORE,
                                    0 },
   { EGL_NATIVE_VISUAL_TYPE,        ATTRIB_TYPE_PLATFORM,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_RENDERABLE_TYPE,           ATTRIB_TYPE_BITMASK,
                                    ATTRIB_CRITERION_MASK,
                                    EGL_OPENGL_ES_BIT },
   { EGL_SAMPLE_BUFFERS,            ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_SAMPLES,                   ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_STENCIL_SIZE,              ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_ATLEAST,
                                    0 },
   { EGL_SURFACE_TYPE,              ATTRIB_TYPE_BITMASK,
                                    ATTRIB_CRITERION_MASK,
                                    EGL_WINDOW_BIT },
   { EGL_TRANSPARENT_TYPE,          ATTRIB_TYPE_ENUM,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_NONE },
   { EGL_TRANSPARENT_RED_VALUE,     ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_TRANSPARENT_GREEN_VALUE,   ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_TRANSPARENT_BLUE_VALUE,    ATTRIB_TYPE_INTEGER,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE },
   { EGL_MATCH_NATIVE_PIXMAP,       ATTRIB_TYPE_PSEUDO,
                                    ATTRIB_CRITERION_SPECIAL,
                                    EGL_NONE },
   /* extensions */
   { EGL_Y_INVERTED_NOK,            ATTRIB_TYPE_BOOLEAN,
                                    ATTRIB_CRITERION_EXACT,
                                    EGL_DONT_CARE }
};


d103 1
a103 6
 * Return true if a config is valid.  When for_matching is true,
 * EGL_DONT_CARE is accepted as a valid attribute value, and checks
 * for conflicting attribute values are skipped.
 *
 * Note that some attributes are platform-dependent and are not
 * checked.
d105 2
a106 2
EGLBoolean
_eglValidateConfig(const _EGLConfig *conf, EGLBoolean for_matching)
d108 5
a112 106
   EGLint i, attr, val;
   EGLBoolean valid = EGL_TRUE;

   /* check attributes by their types */
   for (i = 0; i < ARRAY_SIZE(_eglValidationTable); i++) {
      EGLint mask;

      attr = _eglValidationTable[i].attr;
      val = _eglGetConfigKey(conf, attr);

      switch (_eglValidationTable[i].type) {
      case ATTRIB_TYPE_INTEGER:
         switch (attr) {
         case EGL_CONFIG_ID:
            /* config id must be positive */
            if (val <= 0)
               valid = EGL_FALSE;
            break;
         case EGL_SAMPLE_BUFFERS:
            /* there can be at most 1 sample buffer */
            if (val > 1 || val < 0)
               valid = EGL_FALSE;
            break;
         default:
            if (val < 0)
               valid = EGL_FALSE;
            break;
         }
         break;
      case ATTRIB_TYPE_BOOLEAN:
         if (val != EGL_TRUE && val != EGL_FALSE)
            valid = EGL_FALSE;
         break;
      case ATTRIB_TYPE_ENUM:
         switch (attr) {
         case EGL_CONFIG_CAVEAT:
            if (val != EGL_NONE && val != EGL_SLOW_CONFIG &&
                val != EGL_NON_CONFORMANT_CONFIG)
               valid = EGL_FALSE;
            break;
         case EGL_TRANSPARENT_TYPE:
            if (val != EGL_NONE && val != EGL_TRANSPARENT_RGB)
               valid = EGL_FALSE;
            break;
         case EGL_COLOR_BUFFER_TYPE:
            if (val != EGL_RGB_BUFFER && val != EGL_LUMINANCE_BUFFER)
               valid = EGL_FALSE;
            break;
         default:
            assert(0);
            break;
         }
         break;
      case ATTRIB_TYPE_BITMASK:
         switch (attr) {
         case EGL_SURFACE_TYPE:
            mask = EGL_PBUFFER_BIT |
                   EGL_PIXMAP_BIT |
                   EGL_WINDOW_BIT |
                   EGL_VG_COLORSPACE_LINEAR_BIT |
                   EGL_VG_ALPHA_FORMAT_PRE_BIT |
                   EGL_MULTISAMPLE_RESOLVE_BOX_BIT |
                   EGL_SWAP_BEHAVIOR_PRESERVED_BIT;
#ifdef EGL_MESA_screen_surface
            if (conf->Display->Extensions.MESA_screen_surface)
               mask |= EGL_SCREEN_BIT_MESA;
#endif
            break;
         case EGL_RENDERABLE_TYPE:
         case EGL_CONFORMANT:
            mask = EGL_OPENGL_ES_BIT |
                   EGL_OPENVG_BIT |
                   EGL_OPENGL_ES2_BIT |
                   EGL_OPENGL_BIT;
            break;
         default:
            assert(0);
            break;
         }
         if (val & ~mask)
            valid = EGL_FALSE;
         break;
      case ATTRIB_TYPE_PLATFORM:
         /* unable to check platform-dependent attributes here */
         break;
      case ATTRIB_TYPE_PSEUDO:
         /* pseudo attributes should not be set */
         if (val != 0)
            valid = EGL_FALSE;
         break;
      default:
         assert(0);
         break;
      }

      if (!valid && for_matching) {
         /* accept EGL_DONT_CARE as a valid value */
         if (val == EGL_DONT_CARE)
            valid = EGL_TRUE;
         if (_eglValidationTable[i].criterion == ATTRIB_CRITERION_SPECIAL)
            valid = EGL_TRUE;
      }
      if (!valid) {
         _eglLog(_EGL_DEBUG,
               "attribute 0x%04x has an invalid value 0x%x", attr, val);
         break;
d115 2
a117 25
   /* any invalid attribute value should have been catched */
   if (!valid || for_matching)
      return valid;

   /* now check for conflicting attribute values */

   switch (conf->ColorBufferType) {
   case EGL_RGB_BUFFER:
      if (conf->LuminanceSize)
         valid = EGL_FALSE;
      if (conf->RedSize + conf->GreenSize +
            conf->BlueSize + conf->AlphaSize != conf->BufferSize)
         valid = EGL_FALSE;
      break;
   case EGL_LUMINANCE_BUFFER:
      if (conf->RedSize || conf->GreenSize || conf->BlueSize)
         valid = EGL_FALSE;
      if (conf->LuminanceSize + conf->AlphaSize != conf->BufferSize)
         valid = EGL_FALSE;
      break;
   }
   if (!valid) {
      _eglLog(_EGL_DEBUG, "conflicting color buffer type and channel sizes");
      return EGL_FALSE;
   }
d119 10
a128 6
   if (!conf->SampleBuffers && conf->Samples)
      valid = EGL_FALSE;
   if (!valid) {
      _eglLog(_EGL_DEBUG, "conflicting samples and sample buffers");
      return EGL_FALSE;
   }
d130 8
a137 7
   if (!(conf->SurfaceType & EGL_WINDOW_BIT)) {
      if (conf->NativeVisualID != 0 || conf->NativeVisualType != EGL_NONE)
         valid = EGL_FALSE;
   }
   if (!(conf->SurfaceType & EGL_PBUFFER_BIT)) {
      if (conf->BindToTextureRGB || conf->BindToTextureRGBA)
         valid = EGL_FALSE;
d139 2
a140 3
   if (!valid) {
      _eglLog(_EGL_DEBUG, "conflicting surface type and native visual/texture binding");
      return EGL_FALSE;
a141 2

   return valid;
d146 2
a147 6
 * Return true if a config matches the criteria.  This and
 * _eglParseConfigAttribList together implement the algorithm
 * described in "Selection of EGLConfigs".
 *
 * Note that attributes that are special (currently, only
 * EGL_MATCH_NATIVE_PIXMAP) are ignored.
d150 1
a150 1
_eglMatchConfig(const _EGLConfig *conf, const _EGLConfig *criteria)
d152 1
a152 2
   EGLint attr, val, i;
   EGLBoolean matched = EGL_TRUE;
d154 40
a193 42
   for (i = 0; i < ARRAY_SIZE(_eglValidationTable); i++) {
      EGLint cmp;
      if (_eglValidationTable[i].criterion == ATTRIB_CRITERION_IGNORE)
         continue;

      attr = _eglValidationTable[i].attr;
      cmp = _eglGetConfigKey(criteria, attr);
      if (cmp == EGL_DONT_CARE)
         continue;

      val = _eglGetConfigKey(conf, attr);
      switch (_eglValidationTable[i].criterion) {
      case ATTRIB_CRITERION_EXACT:
         if (val != cmp)
            matched = EGL_FALSE;
         break;
      case ATTRIB_CRITERION_ATLEAST:
         if (val < cmp)
            matched = EGL_FALSE;
         break;
      case ATTRIB_CRITERION_MASK:
         if ((val & cmp) != cmp)
            matched = EGL_FALSE;
         break;
      case ATTRIB_CRITERION_SPECIAL:
         /* ignored here */
         break;
      default:
         assert(0);
         break;
      }

      if (!matched) {
#ifndef DEBUG
         /* only print the common errors when DEBUG is not defined */
         if (attr != EGL_RENDERABLE_TYPE)
            break;
#endif
         _eglLog(_EGL_DEBUG,
               "the value (0x%x) of attribute 0x%04x did not meet the criteria (0x%x)",
               val, attr, cmp);
         break;
d196 2
a198 2
   return matched;
}
d200 12
a211 5
static INLINE EGLBoolean
_eglIsConfigAttribValid(_EGLConfig *conf, EGLint attr)
{
   if (_eglOffsetOfConfig(attr) < 0)
      return EGL_FALSE;
d213 31
a243 8
   switch (attr) {
   case EGL_MATCH_NATIVE_PIXMAP:
      return EGL_FALSE;
   case EGL_Y_INVERTED_NOK:
      return conf->Display->Extensions.NOK_texture_from_pixmap;
   default:
      break;
   }
a244 2
   return EGL_TRUE;
}
d247 2
a248 2
 * Initialize a criteria config from the given attribute list.
 * Return EGL_FALSE if any of the attribute is invalid.
d250 2
a251 3
EGLBoolean
_eglParseConfigAttribList(_EGLConfig *conf, _EGLDisplay *dpy,
                          const EGLint *attrib_list)
d253 21
a273 35
   EGLint attr, val, i;

   _eglInitConfig(conf, dpy, EGL_DONT_CARE);

   /* reset to default values */
   for (i = 0; i < ARRAY_SIZE(_eglValidationTable); i++) {
      attr = _eglValidationTable[i].attr;
      val = _eglValidationTable[i].default_value;
      _eglSetConfigKey(conf, attr, val);
   }

   /* parse the list */
   for (i = 0; attrib_list && attrib_list[i] != EGL_NONE; i += 2) {
      attr = attrib_list[i];
      val = attrib_list[i + 1];

      if (!_eglIsConfigAttribValid(conf, attr))
	 return EGL_FALSE;

      _eglSetConfigKey(conf, attr, val);
   }

   if (!_eglValidateConfig(conf, EGL_TRUE))
      return EGL_FALSE;

   /* the spec says that EGL_LEVEL cannot be EGL_DONT_CARE */
   if (conf->Level == EGL_DONT_CARE)
      return EGL_FALSE;

   /* ignore other attributes when EGL_CONFIG_ID is given */
   if (conf->ConfigID != EGL_DONT_CARE) {
      for (i = 0; i < ARRAY_SIZE(_eglValidationTable); i++) {
         attr = _eglValidationTable[i].attr;
         if (attr != EGL_CONFIG_ID)
            _eglSetConfigKey(conf, attr, EGL_DONT_CARE);
a275 11
   else {
      if (!(conf->SurfaceType & EGL_WINDOW_BIT))
         conf->NativeVisualType = EGL_DONT_CARE;

      if (conf->TransparentType == EGL_NONE) {
         conf->TransparentRedValue = EGL_DONT_CARE;
         conf->TransparentGreenValue = EGL_DONT_CARE;
         conf->TransparentBlueValue = EGL_DONT_CARE;
      }
   }

d281 3
a283 11
 * Decide the ordering of conf1 and conf2, under the given criteria.
 * When compare_id is true, this implements the algorithm described
 * in "Sorting of EGLConfigs".  When compare_id is false,
 * EGL_CONFIG_ID is not compared.
 *
 * It returns a negative integer if conf1 is considered to come
 * before conf2;  a positive integer if conf2 is considered to come
 * before conf1;  zero if the ordering cannot be decided.
 *
 * Note that EGL_NATIVE_VISUAL_TYPE is platform-dependent and is
 * ignored here.
d285 5
a289 13
EGLint
_eglCompareConfigs(const _EGLConfig *conf1, const _EGLConfig *conf2,
                   const _EGLConfig *criteria, EGLBoolean compare_id)
{
   const EGLint compare_attribs[] = {
      EGL_BUFFER_SIZE,
      EGL_SAMPLE_BUFFERS,
      EGL_SAMPLES,
      EGL_DEPTH_SIZE,
      EGL_STENCIL_SIZE,
      EGL_ALPHA_MASK_SIZE,
   };
   EGLint val1, val2;
d292 17
a308 22
   if (conf1 == conf2)
      return 0;

   /* the enum values have the desired ordering */
   assert(EGL_NONE < EGL_SLOW_CONFIG);
   assert(EGL_SLOW_CONFIG < EGL_NON_CONFORMANT_CONFIG);
   val1 = conf1->ConfigCaveat - conf2->ConfigCaveat;
   if (val1)
      return val1;

   /* the enum values have the desired ordering */
   assert(EGL_RGB_BUFFER < EGL_LUMINANCE_BUFFER);
   val1 = conf1->ColorBufferType - conf2->ColorBufferType;
   if (val1)
      return val1;

   if (criteria) {
      val1 = val2 = 0;
      if (conf1->ColorBufferType == EGL_RGB_BUFFER) {
         if (criteria->RedSize > 0) {
            val1 += conf1->RedSize;
            val2 += conf2->RedSize;
d310 8
a317 3
         if (criteria->GreenSize > 0) {
            val1 += conf1->GreenSize;
            val2 += conf2->GreenSize;
d319 6
a324 3
         if (criteria->BlueSize > 0) {
            val1 += conf1->BlueSize;
            val2 += conf2->BlueSize;
d328 2
a329 4
         if (criteria->LuminanceSize > 0) {
            val1 += conf1->LuminanceSize;
            val2 += conf2->LuminanceSize;
         }
a330 19
      if (criteria->AlphaSize > 0) {
         val1 += conf1->AlphaSize;
         val2 += conf2->AlphaSize;
      }
   }
   else {
      /* assume the default criteria, which gives no specific ordering */
      val1 = val2 = 0;
   }

   /* for color bits, larger one is preferred */
   if (val1 != val2)
      return (val2 - val1);

   for (i = 0; i < ARRAY_SIZE(compare_attribs); i++) {
      val1 = _eglGetConfigKey(conf1, compare_attribs[i]);
      val2 = _eglGetConfigKey(conf2, compare_attribs[i]);
      if (val1 != val2)
         return (val1 - val2);
d333 2
a334 64
   /* EGL_NATIVE_VISUAL_TYPE cannot be compared here */

   return (compare_id) ? (conf1->ConfigID - conf2->ConfigID) : 0;
}


static INLINE
void _eglSwapConfigs(const _EGLConfig **conf1, const _EGLConfig **conf2)
{
   const _EGLConfig *tmp = *conf1;
   *conf1 = *conf2;
   *conf2 = tmp;
}


/**
 * Quick sort an array of configs.  This differs from the standard
 * qsort() in that the compare function accepts an additional
 * argument.
 */
void
_eglSortConfigs(const _EGLConfig **configs, EGLint count,
                EGLint (*compare)(const _EGLConfig *, const _EGLConfig *,
                                  void *),
                void *priv_data)
{
   const EGLint pivot = 0;
   EGLint i, j;

   if (count <= 1)
      return;

   _eglSwapConfigs(&configs[pivot], &configs[count / 2]);
   i = 1;
   j = count - 1;
   do {
      while (i < count && compare(configs[i], configs[pivot], priv_data) < 0)
         i++;
      while (compare(configs[j], configs[pivot], priv_data) > 0)
         j--;
      if (i < j) {
         _eglSwapConfigs(&configs[i], &configs[j]);
         i++;
         j--;
      }
      else if (i == j) {
         i++;
         j--;
         break;
      }
   } while (i <= j);
   _eglSwapConfigs(&configs[pivot], &configs[j]);

   _eglSortConfigs(configs, j, compare, priv_data);
   _eglSortConfigs(configs + i, count - i, compare, priv_data);
}


static int
_eglFallbackCompare(const _EGLConfig *conf1, const _EGLConfig *conf2,
                   void *priv_data)
{
   const _EGLConfig *criteria = (const _EGLConfig *) priv_data;
   return _eglCompareConfigs(conf1, conf2, criteria, EGL_TRUE);
d342 1
a342 1
_eglChooseConfig(_EGLDriver *drv, _EGLDisplay *disp, const EGLint *attrib_list,
d345 1
d349 4
a352 2
   if (!num_configs)
      return _eglError(EGL_BAD_PARAMETER, "eglChooseConfigs");
d354 6
a359 2
   if (!_eglParseConfigAttribList(&criteria, disp, attrib_list))
      return _eglError(EGL_BAD_ATTRIBUTE, "eglChooseConfig");
d361 5
a365 6
   /* get the number of matched configs */
   count = _eglFilterArray(disp->Configs, NULL, 0,
         (_EGLArrayForEach) _eglMatchConfig, (void *) &criteria);
   if (!count) {
      *num_configs = count;
      return EGL_TRUE;
d368 6
a373 15
   configList = malloc(sizeof(*configList) * count);
   if (!configList)
      return _eglError(EGL_BAD_ALLOC, "eglChooseConfig(out of memory)");

   /* get the matched configs */
   _eglFilterArray(disp->Configs, (void **) configList, count,
         (_EGLArrayForEach) _eglMatchConfig, (void *) &criteria);

   /* perform sorting of configs */
   if (configs && count) {
      _eglSortConfigs((const _EGLConfig **) configList, count,
                      _eglFallbackCompare, (void *) &criteria);
      count = MIN2(count, config_size);
      for (i = 0; i < count; i++)
         configs[i] = _eglGetConfigHandle(configList[i]);
d388 1
a388 1
_eglGetConfigAttrib(_EGLDriver *drv, _EGLDisplay *dpy, _EGLConfig *conf,
d391 10
a400 7
   if (!_eglIsConfigAttribValid(conf, attribute))
      return _eglError(EGL_BAD_ATTRIBUTE, "eglGetConfigAttrib");
   if (!value)
      return _eglError(EGL_BAD_PARAMETER, "eglGetConfigAttrib");

   *value = _eglGetConfigKey(conf, attribute);
   return EGL_TRUE;
a403 9
static EGLBoolean
_eglFlattenConfig(void *elem, void *buffer)
{
   _EGLConfig *conf = (_EGLConfig *) elem;
   EGLConfig *handle = (EGLConfig *) buffer;
   *handle = _eglGetConfigHandle(conf);
   return EGL_TRUE;
}

d408 1
a408 1
_eglGetConfigs(_EGLDriver *drv, _EGLDisplay *disp, EGLConfig *configs,
d411 1
a411 2
   if (!num_config)
      return _eglError(EGL_BAD_PARAMETER, "eglGetConfigs");
d413 16
a428 2
   *num_config = _eglFlattenArray(disp->Configs, (void *) configs,
         sizeof(configs[0]), config_size, _eglFlattenConfig);
d431 207
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a0 30
/**************************************************************************
 *
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright 2010-2011 LunarG, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


a303 1
                   EGL_OPENGL_ES3_BIT_KHR |
a307 1
            mask = 0;
d459 2
d503 2
a504 3
   /* EGL_LEVEL and EGL_MATCH_NATIVE_PIXMAP cannot be EGL_DONT_CARE */
   if (conf->Level == EGL_DONT_CARE ||
       conf->MatchNativePixmap == EGL_DONT_CARE)
d637 1
a637 1
static void
d675 9
d685 1
a685 2
 * A helper function for implementing eglChooseConfig.  See _eglFilterArray and
 * _eglSortConfigs for the meanings of match and compare.
d688 2
a689 6
_eglFilterConfigArray(_EGLArray *array, EGLConfig *configs,
                      EGLint config_size, EGLint *num_configs,
                      EGLBoolean (*match)(const _EGLConfig *, void *),
                      EGLint (*compare)(const _EGLConfig *, const _EGLConfig *,
                                        void *),
                      void *priv_data)
d691 1
a691 1
   _EGLConfig **configList;
d697 3
d701 2
a702 2
   count = _eglFilterArray(array, NULL, 0,
         (_EGLArrayForEach) match, priv_data);
d713 2
a714 2
   _eglFilterArray(array, (void **) configList, count,
         (_EGLArrayForEach) match, priv_data);
d719 1
a719 1
                      compare, priv_data);
a732 35
static EGLBoolean
_eglFallbackMatch(const _EGLConfig *conf, void *priv_data)
{
   return _eglMatchConfig(conf, (const _EGLConfig *) priv_data);
}


static EGLint
_eglFallbackCompare(const _EGLConfig *conf1, const _EGLConfig *conf2,
                    void *priv_data)
{
   return _eglCompareConfigs(conf1, conf2,
         (const _EGLConfig *) priv_data, EGL_TRUE);
}


/**
 * Typical fallback routine for eglChooseConfig
 */
EGLBoolean
_eglChooseConfig(_EGLDriver *drv, _EGLDisplay *disp, const EGLint *attrib_list,
                 EGLConfig *configs, EGLint config_size, EGLint *num_configs)
{
   _EGLConfig criteria;

   if (!_eglParseConfigAttribList(&criteria, disp, attrib_list))
      return _eglError(EGL_BAD_ATTRIBUTE, "eglChooseConfig");

   return _eglFilterConfigArray(disp->Configs,
         configs, config_size, num_configs,
         _eglFallbackMatch, _eglFallbackCompare,
         (void *) &criteria);
}


a741 10

   /* nonqueryable attributes */
   switch (attribute) {
   case EGL_MATCH_NATIVE_PIXMAP:
      return _eglError(EGL_BAD_ATTRIBUTE, "eglGetConfigAttrib");
      break;
   default:
      break;
   }

@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
@


