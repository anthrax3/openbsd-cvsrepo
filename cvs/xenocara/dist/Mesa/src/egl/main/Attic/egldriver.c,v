head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.6
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.25;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.51;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.14;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.51;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.10;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.23;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.40;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.06.01;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.43.08;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008 VMware, Inc.
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright 2010-2011 LunarG, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


/**
 * Functions for choosing and opening/loading device drivers.
 */


#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "eglstring.h"
#include "egldefines.h"
#include "egldisplay.h"
#include "egldriver.h"
#include "egllog.h"
#include "eglmutex.h"

#if defined(_EGL_OS_UNIX)
#include <dlfcn.h>
#include <sys/types.h>
#include <dirent.h>
#include <unistd.h>
#endif


typedef struct _egl_module {
   char *Path;
   _EGLMain_t BuiltIn;
   void *Handle;
   _EGLDriver *Driver;
} _EGLModule;

static _EGLMutex _eglModuleMutex = _EGL_MUTEX_INITIALIZER;
static _EGLArray *_eglModules;

const struct {
   const char *name;
   _EGLMain_t main;
} _eglBuiltInDrivers[] = {
#ifdef _EGL_BUILT_IN_DRIVER_GALLIUM
   { "egl_gallium", _eglBuiltInDriverGALLIUM },
#endif
#ifdef _EGL_BUILT_IN_DRIVER_DRI2
   { "egl_dri2", _eglBuiltInDriverDRI2 },
#endif
   { NULL, NULL }
};

/**
 * Wrappers for dlopen/dlclose()
 */
#if defined(_EGL_OS_WINDOWS)


typedef HMODULE lib_handle;

static HMODULE
open_library(const char *filename)
{
   return LoadLibrary(filename);
}

static void
close_library(HMODULE lib)
{
   FreeLibrary(lib);
}


static const char *
library_suffix(void)
{
   return ".dll";
}


#elif defined(_EGL_OS_UNIX)


typedef void * lib_handle;

static void *
open_library(const char *filename)
{
   return dlopen(filename, RTLD_LAZY);
}

static void
close_library(void *lib)
{
   dlclose(lib);
}


static const char *
library_suffix(void)
{
   return ".so";
}


#endif


/**
 * Open the named driver and find its bootstrap function: _eglMain().
 */
static _EGLMain_t
_eglOpenLibrary(const char *driverPath, lib_handle *handle)
{
   lib_handle lib;
   _EGLMain_t mainFunc = NULL;
   const char *error = "unknown error";

   assert(driverPath);

   _eglLog(_EGL_DEBUG, "dlopen(%s)", driverPath);
   lib = open_library(driverPath);

#if defined(_EGL_OS_WINDOWS)
   /* XXX untested */
   if (lib)
      mainFunc = (_EGLMain_t) GetProcAddress(lib, "_eglMain");
#elif defined(_EGL_OS_UNIX)
   if (lib) {
      union {
         _EGLMain_t func;
         void *ptr;
      } tmp = { NULL };
      /* direct cast gives a warning when compiled with -pedantic */
      tmp.ptr = dlsym(lib, "_eglMain");
      mainFunc = tmp.func;
      if (!mainFunc)
         error = dlerror();
   }
   else {
      error = dlerror();
   }
#endif

   if (!lib) {
      _eglLog(_EGL_WARNING, "Could not open driver %s (%s)",
              driverPath, error);
      return NULL;
   }

   if (!mainFunc) {
      _eglLog(_EGL_WARNING, "_eglMain not found in %s (%s)",
              driverPath, error);
      if (lib)
         close_library(lib);
      return NULL;
   }

   *handle = lib;
   return mainFunc;
}


/**
 * Load a module and create the driver object.
 */
static EGLBoolean
_eglLoadModule(_EGLModule *mod)
{
   _EGLMain_t mainFunc;
   lib_handle lib;
   _EGLDriver *drv;

   if (mod->Driver)
      return EGL_TRUE;

   if (mod->BuiltIn) {
      lib = (lib_handle) NULL;
      mainFunc = mod->BuiltIn;
   }
   else {
      mainFunc = _eglOpenLibrary(mod->Path, &lib);
      if (!mainFunc)
         return EGL_FALSE;
   }

   drv = mainFunc(NULL);
   if (!drv) {
      if (lib)
         close_library(lib);
      return EGL_FALSE;
   }

   if (!drv->Name) {
      _eglLog(_EGL_WARNING, "Driver loaded from %s has no name", mod->Path);
      drv->Name = "UNNAMED";
   }

   mod->Handle = (void *) lib;
   mod->Driver = drv;

   return EGL_TRUE;
}


/**
 * Unload a module.
 */
static void
_eglUnloadModule(_EGLModule *mod)
{
#if defined(_EGL_OS_UNIX)
   /* destroy the driver */
   if (mod->Driver && mod->Driver->Unload)
      mod->Driver->Unload(mod->Driver);

   /*
    * XXX At this point (atexit), the module might be the last reference to
    * libEGL.  Closing the module might unmap libEGL and give problems.
    */
#if 0
   if (mod->Handle)
      close_library(mod->Handle);
#endif
#elif defined(_EGL_OS_WINDOWS)
   /* XXX Windows unloads DLLs before atexit */
#endif

   mod->Driver = NULL;
   mod->Handle = NULL;
}


/**
 * Add a module to the module array.
 */
static _EGLModule *
_eglAddModule(const char *path)
{
   _EGLModule *mod;
   EGLint i;

   if (!_eglModules) {
      _eglModules = _eglCreateArray("Module", 8);
      if (!_eglModules)
         return NULL;
   }

   /* find duplicates */
   for (i = 0; i < _eglModules->Size; i++) {
      mod = _eglModules->Elements[i];
      if (strcmp(mod->Path, path) == 0)
         return mod;
   }

   /* allocate a new one */
   mod = calloc(1, sizeof(*mod));
   if (mod) {
      mod->Path = _eglstrdup(path);
      if (!mod->Path) {
         free(mod);
         mod = NULL;
      }
   }
   if (mod) {
      _eglAppendArray(_eglModules, (void *) mod);
      _eglLog(_EGL_DEBUG, "added %s to module array", mod->Path);
   }

   return mod;
}


/**
 * Free a module.
 */
static void
_eglFreeModule(void *module)
{
   _EGLModule *mod = (_EGLModule *) module;

   _eglUnloadModule(mod);
   free(mod->Path);
   free(mod);
}


/**
 * A loader function for use with _eglPreloadForEach.  The loader data is the
 * filename of the driver.   This function stops on the first valid driver.
 */
static EGLBoolean
_eglLoaderFile(const char *dir, size_t len, void *loader_data)
{
   char path[1024];
   const char *filename = (const char *) loader_data;
   size_t flen = strlen(filename);

   /* make a full path */
   if (len + flen + 2 > sizeof(path))
      return EGL_TRUE;
   if (len) {
      memcpy(path, dir, len);
      path[len++] = '/';
   }
   memcpy(path + len, filename, flen);
   len += flen;
   path[len] = '\0';

   if (library_suffix()) {
      const char *suffix = library_suffix();
      size_t slen = strlen(suffix);
      const char *p;
      EGLBoolean need_suffix;

      p = filename + flen - slen;
      need_suffix = (p < filename || strcmp(p, suffix) != 0);
      if (need_suffix) {
         /* overflow */
         if (len + slen + 1 > sizeof(path))
            return EGL_TRUE;
         strcpy(path + len, suffix);
      }
   }

#if defined(_EGL_OS_UNIX)
   /* check if the file exists */
   if (access(path, F_OK))
      return EGL_TRUE;
#endif

   _eglAddModule(path);

   return EGL_TRUE;
}


/**
 * Run the callback function on each driver directory.
 *
 * The process may end prematurely if the callback function returns false.
 */
static void
_eglPreloadForEach(const char *search_path,
                   EGLBoolean (*loader)(const char *, size_t, void *),
                   void *loader_data)
{
   const char *cur, *next;
   size_t len;

   cur = search_path;
   while (cur) {
      next = strchr(cur, ':');
      len = (next) ? next - cur : strlen(cur);

      if (!loader(cur, len, loader_data))
         break;

      cur = (next) ? next + 1 : NULL;
   }
}


/**
 * Return a list of colon-separated driver directories.
 */
static const char *
_eglGetSearchPath(void)
{
   static char search_path[1024];

#if defined(_EGL_OS_UNIX) || defined(_EGL_OS_WINDOWS)
   if (search_path[0] == '\0') {
      char *buf = search_path;
      size_t len = sizeof(search_path);
      EGLBoolean use_env;
      char dir_sep;
      int ret;

#if defined(_EGL_OS_UNIX)
      use_env = (geteuid() == getuid() && getegid() == getgid());
      dir_sep = '/';
#else
      use_env = EGL_TRUE;
      dir_sep = '\\';
#endif

      if (use_env) {
         char *p;

         /* extract the dirname from EGL_DRIVER */
         p = getenv("EGL_DRIVER");
         if (p && strchr(p, dir_sep)) {
            ret = _eglsnprintf(buf, len, "%s", p);
            if (ret > 0 && ret < len) {
               p = strrchr(buf, dir_sep);
               *p++ = ':';

               len -= p - buf;
               buf = p;
            }
         }

         /* append EGL_DRIVERS_PATH */
         p = getenv("EGL_DRIVERS_PATH");
         if (p) {
            ret = _eglsnprintf(buf, len, "%s:", p);
            if (ret > 0 && ret < len) {
               buf += ret;
               len -= ret;
            }
         }
      }
      else {
         _eglLog(_EGL_DEBUG,
               "ignore EGL_DRIVERS_PATH for setuid/setgid binaries");
      }

      ret = _eglsnprintf(buf, len, "%s", _EGL_DRIVER_SEARCH_DIR);
      if (ret < 0 || ret >= len)
         search_path[0] = '\0';

      _eglLog(_EGL_DEBUG, "EGL search path is %s", search_path);
   }
#endif /* defined(_EGL_OS_UNIX) || defined(_EGL_OS_WINDOWS) */

   return search_path;
}


/**
 * Add the user driver to the module array.
 *
 * The user driver is specified by EGL_DRIVER.
 */
static EGLBoolean
_eglAddUserDriver(void)
{
   const char *search_path = _eglGetSearchPath();
   char *env;
   size_t name_len = 0;

   env = getenv("EGL_DRIVER");
#if defined(_EGL_OS_UNIX)
   if (env && strchr(env, '/')) {
      search_path = "";
      if ((geteuid() != getuid() || getegid() != getgid())) {
         _eglLog(_EGL_DEBUG,
               "ignore EGL_DRIVER for setuid/setgid binaries");
         env = NULL;
      }
   }
   else if (env) {
      char *suffix = strchr(env, '.');
      name_len = (suffix) ? suffix - env : strlen(env);
   }
#else
   if (env)
      name_len = strlen(env);
#endif /* _EGL_OS_UNIX */

   /*
    * Try built-in drivers first if we know the driver name.  This makes sure
    * we do not load the outdated external driver that is still on the
    * filesystem.
    */
   if (name_len) {
      _EGLModule *mod;
      EGLint i;

      for (i = 0; _eglBuiltInDrivers[i].name; i++) {
         if (strlen(_eglBuiltInDrivers[i].name) == name_len &&
             !strncmp(_eglBuiltInDrivers[i].name, env, name_len)) {
            mod = _eglAddModule(env);
            if (mod)
               mod->BuiltIn = _eglBuiltInDrivers[i].main;

            return EGL_TRUE;
         }
      }
   }

   /* otherwise, treat env as a path */
   if (env) {
      _eglPreloadForEach(search_path, _eglLoaderFile, (void *) env);

      return EGL_TRUE;
   }

   return EGL_FALSE;
}


/**
 * Add egl_gallium to the module array.
 */
static void
_eglAddGalliumDriver(void)
{
#ifndef _EGL_BUILT_IN_DRIVER_GALLIUM
   void *external = (void *) "egl_gallium";
   _eglPreloadForEach(_eglGetSearchPath(), _eglLoaderFile, external);
#endif
}


/**
 * Add built-in drivers to the module array.
 */
static void
_eglAddBuiltInDrivers(void)
{
   _EGLModule *mod;
   EGLint i;

   for (i = 0; _eglBuiltInDrivers[i].name; i++) {
      mod = _eglAddModule(_eglBuiltInDrivers[i].name);
      if (mod)
         mod->BuiltIn = _eglBuiltInDrivers[i].main;
   }
}


/**
 * Add drivers to the module array.  Drivers will be loaded as they are matched
 * to displays.
 */
static EGLBoolean
_eglAddDrivers(void)
{
   if (_eglModules)
      return EGL_TRUE;

   if (!_eglAddUserDriver()) {
      /*
       * Add other drivers only when EGL_DRIVER is not set.  The order here
       * decides the priorities.
       */
      _eglAddGalliumDriver();
      _eglAddBuiltInDrivers();
   }

   return (_eglModules != NULL);
}


/**
 * A helper function for _eglMatchDriver.  It finds the first driver that can
 * initialize the display and return.
 */
static _EGLDriver *
_eglMatchAndInitialize(_EGLDisplay *dpy)
{
   _EGLDriver *drv = NULL;
   EGLint i = 0;

   if (!_eglAddDrivers()) {
      _eglLog(_EGL_WARNING, "failed to find any driver");
      return NULL;
   }

   if (dpy->Driver) {
      drv = dpy->Driver;
      /* no re-matching? */
      if (!drv->API.Initialize(drv, dpy))
         drv = NULL;
      return drv;
   }

   while (i < _eglModules->Size) {
      _EGLModule *mod = (_EGLModule *) _eglModules->Elements[i];

      if (!_eglLoadModule(mod)) {
         /* remove invalid modules */
         _eglEraseArray(_eglModules, i, _eglFreeModule);
         continue;
      }

      if (mod->Driver->API.Initialize(mod->Driver, dpy)) {
         drv = mod->Driver;
         break;
      }
      else {
         i++;
      }
   }

   return drv;
}


/**
 * Match a display to a driver.  The display is initialized unless test_only is
 * true.  The matching is done by finding the first driver that can initialize
 * the display.
 */
_EGLDriver *
_eglMatchDriver(_EGLDisplay *dpy, EGLBoolean test_only)
{
   _EGLDriver *best_drv;

   assert(!dpy->Initialized);

   _eglLockMutex(&_eglModuleMutex);

   /* set options */
   dpy->Options.TestOnly = test_only;
   dpy->Options.UseFallback = EGL_FALSE;

   best_drv = _eglMatchAndInitialize(dpy);
   if (!best_drv) {
      dpy->Options.UseFallback = EGL_TRUE;
      best_drv = _eglMatchAndInitialize(dpy);
   }

   _eglUnlockMutex(&_eglModuleMutex);

   if (best_drv) {
      _eglLog(_EGL_DEBUG, "the best driver is %s%s",
            best_drv->Name, (test_only) ? " (test only) " : "");
      if (!test_only) {
         dpy->Driver = best_drv;
         dpy->Initialized = EGL_TRUE;
      }
   }

   return best_drv;
}


__eglMustCastToProperFunctionPointerType
_eglGetDriverProc(const char *procname)
{
   EGLint i;
   _EGLProc proc = NULL;

   if (!_eglModules) {
      /* load the driver for the default display */
      EGLDisplay egldpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      _EGLDisplay *dpy = _eglLookupDisplay(egldpy);
      if (!dpy || !_eglMatchDriver(dpy, EGL_TRUE))
         return NULL;
   }

   for (i = 0; i < _eglModules->Size; i++) {
      _EGLModule *mod = (_EGLModule *) _eglModules->Elements[i];

      if (!mod->Driver)
         break;
      proc = mod->Driver->API.GetProcAddress(mod->Driver, procname);
      if (proc)
         break;
   }

   return proc;
}


/**
 * Unload all drivers.
 */
void
_eglUnloadDrivers(void)
{
   /* this is called at atexit time */
   if (_eglModules) {
      _eglDestroyArray(_eglModules, _eglFreeModule);
      _eglModules = NULL;
   }
}


/**
 * Invoke a callback function on each EGL search path.
 *
 * The first argument of the callback function is the name of the search path.
 * The second argument is the length of the name.
 */
void
_eglSearchPathForEach(EGLBoolean (*callback)(const char *, size_t, void *),
                      void *callback_data)
{
   const char *search_path = _eglGetSearchPath();
   _eglPreloadForEach(search_path, callback, callback_data);
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d521 13
d565 1
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a520 13
 * Add egl_gallium to the module array.
 */
static void
_eglAddGalliumDriver(void)
{
#ifndef _EGL_BUILT_IN_DRIVER_GALLIUM
   void *external = (void *) "egl_gallium";
   _eglPreloadForEach(_eglGetSearchPath(), _eglLoaderFile, external);
#endif
}


/**
a551 1
      _eglAddGalliumDriver();
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d63 1
a63 1
static _EGL_DECLARE_MUTEX(_eglModuleMutex);
a74 3
#endif
#ifdef _EGL_BUILT_IN_DRIVER_GLX
   { "egl_glx", _eglBuiltInDriverGLX },
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d1 30
d58 1
d66 15
a176 3
      if (!getenv("EGL_DRIVER"))
         _eglLog(_EGL_WARNING,
                 "The driver can be overridden by setting EGL_DRIVER");
d203 12
a214 3
   mainFunc = _eglOpenLibrary(mod->Path, &lib);
   if (!mainFunc)
      return EGL_FALSE;
d241 1
d245 6
d253 4
a367 62
 * A loader function for use with _eglPreloadForEach.  The loader data is the
 * pattern (prefix) of the files to look for.
 */
static EGLBoolean
_eglLoaderPattern(const char *dir, size_t len, void *loader_data)
{
#if defined(_EGL_OS_UNIX)
   const char *prefix, *suffix;
   size_t prefix_len, suffix_len;
   DIR *dirp;
   struct dirent *dirent;
   char path[1024];

   if (len + 2 > sizeof(path))
      return EGL_TRUE;
   if (len) {
      memcpy(path, dir, len);
      path[len++] = '/';
   }
   path[len] = '\0';

   dirp = opendir(path);
   if (!dirp)
      return EGL_TRUE;

   prefix = (const char *) loader_data;
   prefix_len = strlen(prefix);
   suffix = library_suffix();
   suffix_len = (suffix) ? strlen(suffix) : 0;

   while ((dirent = readdir(dirp))) {
      size_t dirent_len = strlen(dirent->d_name);
      const char *p;

      /* match the prefix */
      if (strncmp(dirent->d_name, prefix, prefix_len) != 0)
         continue;
      /* match the suffix */
      if (suffix) {
         p = dirent->d_name + dirent_len - suffix_len;
         if (p < dirent->d_name || strcmp(p, suffix) != 0)
            continue;
      }

      /* make a full path and add it to the module array */
      if (len + dirent_len + 1 <= sizeof(path)) {
         strcpy(path + len, dirent->d_name);
         _eglAddModule(path);
      }
   }

   closedir(dirp);

   return EGL_TRUE;
#else /* _EGL_OS_UNIX */
   /* stop immediately */
   return EGL_FALSE;
#endif
}


/**
d465 1
a465 1
static void
d470 1
d482 7
d490 24
a513 1
   if (env)
d515 18
d537 1
a537 1
 * Add default drivers to the module array.
d540 1
a540 1
_eglAddDefaultDrivers(void)
d542 1
a542 1
   const char *search_path = _eglGetSearchPath();
a543 11
#if defined(_EGL_OS_WINDOWS)
   const char *DefaultDriverNames[] = {
      "egl_gallium"
   };
#elif defined(_EGL_OS_UNIX)
   const char *DefaultDriverNames[] = {
      "egl_gallium",
      "egl_dri2",
      "egl_glx"
   };
#endif
d545 4
a548 3
   for (i = 0; i < ARRAY_SIZE(DefaultDriverNames); i++) {
      void *name = (void *) DefaultDriverNames[i];
      _eglPreloadForEach(search_path, _eglLoaderFile, name);
d563 8
a570 4
   /* the order here decides the priorities of the drivers */
   _eglAddUserDriver();
   _eglAddDefaultDrivers();
   _eglPreloadForEach(_eglGetSearchPath(), _eglLoaderPattern, (void *) "egl_");
d577 2
a578 5
 * Match a display to a driver.  The display is initialized unless use_probe is
 * true.
 *
 * The matching is done by finding the first driver that can initialize the
 * display, or when use_probe is true, the driver with highest score.
d580 2
a581 2
_EGLDriver *
_eglMatchDriver(_EGLDisplay *dpy, EGLBoolean use_probe)
d583 2
a584 4
   _EGLModule *mod;
   _EGLDriver *best_drv = NULL;
   EGLint best_score = 0;
   EGLint major, minor, i;
d586 4
a589 1
   _eglLockMutex(&_eglModuleMutex);
d591 6
a596 3
   if (!_eglAddDrivers()) {
      _eglUnlockMutex(&_eglModuleMutex);
      return EGL_FALSE;
d599 11
a609 4
   /* match the loaded modules */
   for (i = 0; i < _eglModules->Size; i++) {
      mod = (_EGLModule *) _eglModules->Elements[i];
      if (!mod->Driver)
a610 8

      if (use_probe) {
         EGLint score = (mod->Driver->Probe) ?
            mod->Driver->Probe(mod->Driver, dpy) : 1;
         if (score > best_score) {
            best_drv = mod->Driver;
            best_score = score;
         }
d613 1
a613 4
         if (mod->Driver->API.Initialize(mod->Driver, dpy, &major, &minor)) {
            best_drv = mod->Driver;
            best_score = 100;
         }
a614 3
      /* perfect match */
      if (best_score >= 100)
         break;
d617 15
a631 3
   /* load more modules */
   if (!best_drv) {
      EGLint first_unloaded = i;
d633 1
a633 9
      while (i < _eglModules->Size) {
         mod = (_EGLModule *) _eglModules->Elements[i];
         assert(!mod->Driver);

         if (!_eglLoadModule(mod)) {
            /* remove invalid modules */
            _eglEraseArray(_eglModules, i, _eglFreeModule);
            continue;
         }
d635 3
a637 8
         if (use_probe) {
            best_score = (mod->Driver->Probe) ?
               mod->Driver->Probe(mod->Driver, dpy) : 1;
         }
         else {
            if (mod->Driver->API.Initialize(mod->Driver, dpy, &major, &minor))
               best_score = 100;
         }
d639 4
a642 16
         if (best_score > 0) {
            best_drv = mod->Driver;
            /* loaded modules come before unloaded ones */
            if (first_unloaded != i) {
               void *tmp = _eglModules->Elements[i];
               _eglModules->Elements[i] =
                  _eglModules->Elements[first_unloaded];
               _eglModules->Elements[first_unloaded] = tmp;
            }
            break;
         }
         else {
            _eglUnloadModule(mod);
            i++;
         }
      }
d648 3
a650 3
      _eglLog(_EGL_DEBUG, "the best driver is %s (score %d)",
            best_drv->Name, best_score);
      if (!use_probe) {
a652 2
         dpy->APImajor = major;
         dpy->APIminor = minor;
a695 1
#if defined(_EGL_OS_UNIX)
a696 4
#elif defined(_EGL_OS_WINDOWS)
      /* XXX Windows unloads DLLs before atexit */
      _eglDestroyArray(_eglModules, NULL);
#endif
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d10 2
a11 2
#include "eglconfig.h"
#include "eglcontext.h"
a14 1
#include "eglglobals.h"
d16 1
a16 6
#include "eglmisc.h"
#include "eglmode.h"
#include "eglscreen.h"
#include "eglstring.h"
#include "eglsurface.h"
#include "eglimage.h"
d18 1
a18 1
#if defined(_EGL_PLATFORM_POSIX)
d26 10
d39 1
a39 1
#if defined(_EGL_PLATFORM_WINDOWS)
a41 3
/* XXX Need to decide how to do dynamic name lookup on Windows */
static const char DefaultDriverName[] = "TBD";

d64 1
a64 2
#elif defined(_EGL_PLATFORM_POSIX)

a65 1
static const char DefaultDriverName[] = "egl_glx";
a88 26
#else /* _EGL_PLATFORM_NO_OS */


static const char DefaultDriverName[] = "builtin";

typedef void *lib_handle;

static INLINE void *
open_library(const char *filename)
{
   return (void *) filename;
}

static INLINE void
close_library(void *lib)
{
}


static const char *
library_suffix(void)
{
   return NULL;
}


a91 7
#define NUM_PROBE_CACHE_SLOTS 8
static struct {
   EGLint keys[NUM_PROBE_CACHE_SLOTS];
   const void *values[NUM_PROBE_CACHE_SLOTS];
} _eglProbeCache;


d107 1
a107 1
#if defined(_EGL_PLATFORM_WINDOWS)
d111 1
a111 1
#elif defined(_EGL_PLATFORM_POSIX)
a125 6
#else /* _EGL_PLATFORM_NO_OS */
   /* must be the default driver name */
   if (strcmp(driverPath, DefaultDriverName) == 0)
      mainFunc = (_EGLMain_t) _eglMain;
   else
      error = "not builtin driver";
d151 1
a151 1
 * Load the named driver.
d153 2
a154 2
static _EGLDriver *
_eglLoadDriver(const char *path, const char *args)
d158 1
a158 1
   _EGLDriver *drv = NULL;
d160 1
a160 1
   mainFunc = _eglOpenLibrary(path, &lib);
d162 1
a162 1
      return NULL;
d164 1
a164 1
   drv = mainFunc(args);
d168 1
a168 1
      return NULL;
d172 1
a172 1
      _eglLog(_EGL_WARNING, "Driver loaded from %s has no name", path);
d176 6
a181 12
   drv->Path = _eglstrdup(path);
   drv->Args = (args) ? _eglstrdup(args) : NULL;
   if (!drv->Path || (args && !drv->Args)) {
      if (drv->Path)
         free((char *) drv->Path);
      if (drv->Args)
         free((char *) drv->Args);
      drv->Unload(drv);
      if (lib)
         close_library(lib);
      return NULL;
   }
d183 11
a193 1
   drv->LibHandle = lib;
d195 2
a196 1
   return drv;
d201 1
a201 3
 * Match a display to a preloaded driver.
 *
 * The matching is done by finding the driver with the highest score.
d203 2
a204 2
_EGLDriver *
_eglMatchDriver(_EGLDisplay *dpy)
d206 2
a207 2
   _EGLDriver *best_drv = NULL;
   EGLint best_score = -1, i;
d209 20
a228 20
   /*
    * this function is called after preloading and the drivers never change
    * after preloading.
    */
   for (i = 0; i < _eglGlobal.NumDrivers; i++) {
      _EGLDriver *drv = _eglGlobal.Drivers[i];
      EGLint score;

      score = (drv->Probe) ? drv->Probe(drv, dpy) : 0;
      if (score > best_score) {
         if (best_drv) {
            _eglLog(_EGL_DEBUG, "driver %s has higher score than %s",
                  drv->Name, best_drv->Name);
         }

         best_drv = drv;
         best_score = score;
         /* perfect match */
         if (score >= 100)
            break;
d231 7
d239 12
a250 1
   return best_drv;
a260 1
   _EGLDriver *drv;
d276 1
a276 3
   drv = _eglLoadDriver(path, NULL);
   /* fix the path and load again */
   if (!drv && library_suffix()) {
d284 4
a287 1
      if (need_suffix && len + slen + 1 <= sizeof(path)) {
a288 1
         drv = _eglLoadDriver(path, NULL);
d291 4
a294 1
   if (!drv)
d296 1
d298 3
a300 3
   /* remember the driver and stop */
   _eglGlobal.Drivers[_eglGlobal.NumDrivers++] = drv;
   return EGL_FALSE;
d311 1
a311 1
#if defined(_EGL_PLATFORM_POSIX)
a335 1
      _EGLDriver *drv;
d349 1
a349 1
      /* make a full path and load the driver */
d352 1
a352 3
         drv = _eglLoadDriver(path, NULL);
         if (drv)
            _eglGlobal.Drivers[_eglGlobal.NumDrivers++] = drv;
d359 1
a359 1
#else /* _EGL_PLATFORM_POSIX */
d367 1
a367 2
 * Run the preload function on each driver directory and return the number of
 * drivers loaded.
d371 1
a371 1
static EGLint
a377 1
   EGLint num_drivers = _eglGlobal.NumDrivers;
a388 2

   return (_eglGlobal.NumDrivers - num_drivers);
d398 1
a398 1
   static const char *search_path;
d400 6
a405 4
#if defined(_EGL_PLATFORM_POSIX) || defined(_EGL_PLATFORM_WINDOWS)
   if (!search_path) {
      static char buffer[1024];
      const char *p;
d408 35
a442 3
      p = getenv("EGL_DRIVERS_PATH");
#if defined(_EGL_PLATFORM_POSIX)
      if (p && (geteuid() != getuid() || getegid() != getgid())) {
a444 1
         p = NULL;
a445 1
#endif /* _EGL_PLATFORM_POSIX */
d447 5
a451 6
      if (p) {
         ret = snprintf(buffer, sizeof(buffer),
               "%s:%s", p, _EGL_DRIVER_SEARCH_DIR);
         if (ret > 0 && ret < sizeof(buffer))
            search_path = buffer;
      }
d453 1
a453 5
   if (!search_path)
      search_path = _EGL_DRIVER_SEARCH_DIR;
#else
   search_path = "";
#endif
d460 1
a460 1
 * Preload a user driver.
d462 1
a462 1
 * A user driver can be specified by EGL_DRIVER.
d464 2
a465 2
static EGLBoolean
_eglPreloadUserDriver(void)
d471 1
a471 1
#if defined(_EGL_PLATFORM_POSIX)
d480 3
a482 10
#endif /* _EGL_PLATFORM_POSIX */
   if (!env)
      return EGL_FALSE;

   if (!_eglPreloadForEach(search_path, _eglLoaderFile, (void *) env)) {
      _eglLog(_EGL_WARNING, "EGL_DRIVER is set to an invalid driver");
      return EGL_FALSE;
   }

   return EGL_TRUE;
d487 1
a487 7
 * Preload display drivers.
 *
 * Display drivers are a set of drivers that support a certain display system.
 * The display system may be specified by EGL_DISPLAY.
 *
 * FIXME This makes libEGL a memory hog if an user driver is not specified and
 * there are many display drivers.
d489 2
a490 2
static EGLBoolean
_eglPreloadDisplayDrivers(void)
d492 13
a504 9
   const char *dpy;
   char prefix[32];
   int ret;

   dpy = getenv("EGL_DISPLAY");
   if (!dpy || !dpy[0])
      dpy = _EGL_DEFAULT_DISPLAY;
   if (!dpy || !dpy[0])
      return EGL_FALSE;
d506 4
a509 6
   ret = snprintf(prefix, sizeof(prefix), "egl_%s_", dpy);
   if (ret < 0 || ret >= sizeof(prefix))
      return EGL_FALSE;

   return (_eglPreloadForEach(_eglGetSearchPath(),
            _eglLoaderPattern, (void *) prefix) > 0);
d514 2
a515 1
 * Preload the default driver.
d518 1
a518 1
_eglPreloadDefaultDriver(void)
d520 9
a528 2
   return (_eglPreloadForEach(_eglGetSearchPath(),
            _eglLoaderFile, (void *) DefaultDriverName) > 0);
d533 2
a534 1
 * Preload drivers.
d536 2
a537 2
 * This function loads the driver modules and creates the corresponding
 * _EGLDriver objects.
d539 2
a540 2
EGLBoolean
_eglPreloadDrivers(void)
d542 11
a552 1
   EGLBoolean loaded;
d554 24
a577 2
   /* protect the preloading process */
   _eglLockMutex(_eglGlobal.Mutex);
d579 39
a617 4
   /* already preloaded */
   if (_eglGlobal.NumDrivers) {
      _eglUnlockMutex(_eglGlobal.Mutex);
      return EGL_TRUE;
d620 1
a620 3
   loaded = (_eglPreloadUserDriver() ||
             _eglPreloadDisplayDrivers() ||
             _eglPreloadDefaultDriver());
d622 10
a631 1
   _eglUnlockMutex(_eglGlobal.Mutex);
d633 1
a633 1
   return loaded;
d637 2
a638 5
/**
 * Unload preloaded drivers.
 */
void
_eglUnloadDrivers(void)
d641 1
d643 7
a649 4
   /* this is called at atexit time */
   for (i = 0; i < _eglGlobal.NumDrivers; i++) {
      _EGLDriver *drv = _eglGlobal.Drivers[i];
      lib_handle handle = drv->LibHandle;
d651 2
a652 4
      if (drv->Path)
         free((char *) drv->Path);
      if (drv->Args)
         free((char *) drv->Args);
d654 5
a658 7
      /* destroy driver */
      if (drv->Unload)
         drv->Unload(drv);

      if (handle)
         close_library(handle);
      _eglGlobal.Drivers[i] = NULL;
d661 1
a661 1
   _eglGlobal.NumDrivers = 0;
d666 1
a666 2
 * Plug all the available fallback routines into the given driver's
 * dispatch table.
d669 1
a669 1
_eglInitDriverFallbacks(_EGLDriver *drv)
d671 10
a680 53
   /* If a pointer is set to NULL, then the device driver _really_ has
    * to implement it.
    */
   drv->API.Initialize = NULL;
   drv->API.Terminate = NULL;

   drv->API.GetConfigs = _eglGetConfigs;
   drv->API.ChooseConfig = _eglChooseConfig;
   drv->API.GetConfigAttrib = _eglGetConfigAttrib;

   drv->API.CreateContext = _eglCreateContext;
   drv->API.DestroyContext = _eglDestroyContext;
   drv->API.MakeCurrent = _eglMakeCurrent;
   drv->API.QueryContext = _eglQueryContext;

   drv->API.CreateWindowSurface = _eglCreateWindowSurface;
   drv->API.CreatePixmapSurface = _eglCreatePixmapSurface;
   drv->API.CreatePbufferSurface = _eglCreatePbufferSurface;
   drv->API.DestroySurface = _eglDestroySurface;
   drv->API.QuerySurface = _eglQuerySurface;
   drv->API.SurfaceAttrib = _eglSurfaceAttrib;
   drv->API.BindTexImage = _eglBindTexImage;
   drv->API.ReleaseTexImage = _eglReleaseTexImage;
   drv->API.SwapInterval = _eglSwapInterval;
   drv->API.SwapBuffers = _eglSwapBuffers;
   drv->API.CopyBuffers = _eglCopyBuffers;

   drv->API.QueryString = _eglQueryString;
   drv->API.WaitClient = _eglWaitClient;
   drv->API.WaitNative = _eglWaitNative;

#ifdef EGL_MESA_screen_surface
   drv->API.ChooseModeMESA = _eglChooseModeMESA; 
   drv->API.GetModesMESA = _eglGetModesMESA;
   drv->API.GetModeAttribMESA = _eglGetModeAttribMESA;
   drv->API.GetScreensMESA = _eglGetScreensMESA;
   drv->API.CreateScreenSurfaceMESA = _eglCreateScreenSurfaceMESA;
   drv->API.ShowScreenSurfaceMESA = _eglShowScreenSurfaceMESA;
   drv->API.ScreenPositionMESA = _eglScreenPositionMESA;
   drv->API.QueryScreenMESA = _eglQueryScreenMESA;
   drv->API.QueryScreenSurfaceMESA = _eglQueryScreenSurfaceMESA;
   drv->API.QueryScreenModeMESA = _eglQueryScreenModeMESA;
   drv->API.QueryModeStringMESA = _eglQueryModeStringMESA;
#endif /* EGL_MESA_screen_surface */

#ifdef EGL_VERSION_1_2
   drv->API.CreatePbufferFromClientBuffer = _eglCreatePbufferFromClientBuffer;
#endif /* EGL_VERSION_1_2 */

#ifdef EGL_KHR_image_base
   drv->API.CreateImageKHR = _eglCreateImageKHR;
   drv->API.DestroyImageKHR = _eglDestroyImageKHR;
#endif /* EGL_KHR_image_base */
d685 1
a685 1
 * Set the probe cache at the given key.
d687 2
a688 2
 * A key, instead of a _EGLDriver, is used to allow the probe cache to be share
 * by multiple drivers.
d691 2
a692 1
_eglSetProbeCache(EGLint key, const void *val)
d694 2
a695 29
   EGLint idx;

   for (idx = 0; idx < NUM_PROBE_CACHE_SLOTS; idx++) {
      if (!_eglProbeCache.keys[idx] || _eglProbeCache.keys[idx] == key)
         break;
   }
   assert(key > 0);
   assert(idx < NUM_PROBE_CACHE_SLOTS);

   _eglProbeCache.keys[idx] = key;
   _eglProbeCache.values[idx] = val;
}


/**
 * Return the probe cache at the given key.
 */
const void *
_eglGetProbeCache(EGLint key)
{
   EGLint idx;

   for (idx = 0; idx < NUM_PROBE_CACHE_SLOTS; idx++) {
      if (!_eglProbeCache.keys[idx] || _eglProbeCache.keys[idx] == key)
         break;
   }

   return (idx < NUM_PROBE_CACHE_SLOTS && _eglProbeCache.keys[idx] == key) ?
      _eglProbeCache.values[idx] : NULL;
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d1 5
d7 1
a7 1
#include <dlfcn.h>
d9 1
a9 1
#include <string.h>
d12 1
d17 1
d20 1
d22 1
d24 6
a29 2

const char *DefaultDriverName = "demodriver";
d33 1
a33 11
 * Choose and open/init the hardware driver for the given EGLDisplay.
 * Previously, the EGLDisplay was created with _eglNewDisplay() where
 * we recorded the user's NativeDisplayType parameter.
 *
 * Now we'll use the NativeDisplayType value.
 *
 * Currently, the native display value is treated as a string.
 * If the first character is ':' we interpret it as a screen or card index
 * number (i.e. ":0" or ":1", etc)
 * Else if the first character is '!' we interpret it as specific driver name
 * (i.e. "!r200" or "!i830".
d35 76
a110 2
_EGLDriver *
_eglChooseDriver(EGLDisplay display)
d112 12
a123 4
   _EGLDisplay *dpy = _eglLookupDisplay(display);
   _EGLDriver *drv;
   const char *driverName = DefaultDriverName;
   const char *name;
a124 1
   assert(dpy);
d126 30
a155 11
   name = dpy->Name;
   if (!name) {
      /* use default */
   }
   else if (name[0] == ':' && (name[1] >= '0' && name[1] <= '9') && !name[2]) {
      /* XXX probe hardware here to determine which driver to open */
      driverName = "libEGLdri";
   }
   else if (name[0] == '!') {
      /* use specified driver name */
      driverName = name + 1;
d158 1
a158 2
      /* Maybe display was returned by XOpenDisplay? */
      _eglLog(_EGL_FATAL, "eglChooseDriver() bad name");
d160 7
d168 8
a175 1
   _eglLog(_EGL_INFO, "eglChooseDriver() choosing %s", driverName);
d177 7
a183 2
   drv = _eglOpenDriver(dpy, driverName);
   dpy->Driver = drv;
d185 2
a186 1
   return drv;
d191 1
a191 2
 * Open/load the named driver and call its bootstrap function: _eglMain().
 * \return  new _EGLDriver object.
d193 2
a194 2
_EGLDriver *
_eglOpenDriver(_EGLDisplay *dpy, const char *driverName)
a195 1
   _EGLDriver *drv;
d197 2
a198 2
   void *lib;
   char driverFilename[1000];
d200 3
a202 2
   /* XXX also prepend a directory path??? */
   sprintf(driverFilename, "%s.so", driverName);
d204 4
a207 5
   _eglLog(_EGL_DEBUG, "dlopen(%s)", driverFilename);
   lib = dlopen(driverFilename, RTLD_NOW);
   if (!lib) {
      _eglLog(_EGL_WARNING, "Could not open %s (%s)",
              driverFilename, dlerror());
d211 3
a213 5
   mainFunc = (_EGLMain_t) dlsym(lib, "_eglMain");
   if (!mainFunc) {
      _eglLog(_EGL_WARNING, "_eglMain not found in %s", driverFilename);
      dlclose(lib);
      return NULL;
d216 10
a225 3
   drv = mainFunc(dpy);
   if (!drv) {
      dlclose(lib);
a227 5
   /* with a recurvise open you want the inner most handle */
   if (!drv->LibHandle)
      drv->LibHandle = lib;
   else
      dlclose(lib);
d229 2
a230 1
   drv->Display = dpy;
d235 302
d538 1
a538 1
_eglCloseDriver(_EGLDriver *drv, EGLDisplay dpy)
d540 10
a549 2
   void *handle = drv->LibHandle;
   EGLBoolean b;
d551 3
a553 1
   _eglLog(_EGL_INFO, "Closing driver");
d555 1
a555 3
   /*
    * XXX check for currently bound context/surfaces and delete them?
    */
d557 1
a557 3
   b = drv->API.Terminate(drv, dpy);
   dlclose(handle);
   return b;
d562 1
a562 1
 * Given a display handle, return the _EGLDriver for that display.
d564 2
a565 2
_EGLDriver *
_eglLookupDriver(EGLDisplay dpy)
d567 22
a588 5
   _EGLDisplay *d = _eglLookupDisplay(dpy);
   if (d)
      return d->Driver;
   else
      return NULL;
d627 1
a627 1
   drv->API.WaitGL = _eglWaitGL;
d647 5
d656 4
a659 2
 * Examine the individual extension enable/disable flags and recompute
 * the driver's Extensions string.
d661 2
a662 2
static void
_eglUpdateExtensionsString(_EGLDriver *drv)
d664 1
a664 8
   drv->Extensions.String[0] = 0;

   if (drv->Extensions.MESA_screen_surface)
      strcat(drv->Extensions.String, "EGL_MESA_screen_surface ");
   if (drv->Extensions.MESA_copy_context)
      strcat(drv->Extensions.String, "EGL_MESA_copy_context ");
   assert(strlen(drv->Extensions.String) < MAX_EXTENSIONS_LEN);
}
d666 6
d673 2
a674 23

const char *
_eglQueryString(_EGLDriver *drv, EGLDisplay dpy, EGLint name)
{
   (void) drv;
   (void) dpy;
   switch (name) {
   case EGL_VENDOR:
      return "Mesa Project";
   case EGL_VERSION:
      return "1.0";
   case EGL_EXTENSIONS:
      _eglUpdateExtensionsString(drv);
      return drv->Extensions.String;
#ifdef EGL_VERSION_1_2
   case EGL_CLIENT_APIS:
      /* XXX need to initialize somewhere */
      return drv->ClientAPIs;
#endif
   default:
      _eglError(EGL_BAD_PARAMETER, "eglQueryString");
      return NULL;
   }
d678 5
a682 2
EGLBoolean
_eglWaitGL(_EGLDriver *drv, EGLDisplay dpy)
d684 1
a684 6
   /* just a placeholder */
   (void) drv;
   (void) dpy;
   return EGL_TRUE;
}

d686 3
a688 12
EGLBoolean
_eglWaitNative(_EGLDriver *drv, EGLDisplay dpy, EGLint engine)
{
   /* just a placeholder */
   (void) drv;
   (void) dpy;
   switch (engine) {
   case EGL_CORE_NATIVE_ENGINE:
      break;
   default:
      _eglError(EGL_BAD_PARAMETER, "eglWaitNative(engine)");
      return EGL_FALSE;
d691 2
a692 1
   return EGL_TRUE;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a0 5
/**
 * Functions for choosing and opening/loading device drivers.
 */


d2 2
d5 2
a6 5
#include <stdio.h>
#include <stdlib.h>

#include "eglstring.h"
#include "egldefines.h"
d9 1
d11 3
a13 9
#include "eglmutex.h"

#if defined(_EGL_OS_UNIX)
#include <dlfcn.h>
#include <sys/types.h>
#include <dirent.h>
#include <unistd.h>
#endif

a14 5
typedef struct _egl_module {
   char *Path;
   void *Handle;
   _EGLDriver *Driver;
} _EGLModule;
d16 1
a16 2
static _EGL_DECLARE_MUTEX(_eglModuleMutex);
static _EGLArray *_eglModules;
d20 11
a30 1
 * Wrappers for dlopen/dlclose()
d32 2
a33 7
#if defined(_EGL_OS_WINDOWS)


typedef HMODULE lib_handle;

static HMODULE
open_library(const char *filename)
d35 4
a38 2
   return LoadLibrary(filename);
}
d40 1
a40 12
static void
close_library(HMODULE lib)
{
   FreeLibrary(lib);
}


static const char *
library_suffix(void)
{
   return ".dll";
}
d42 16
d59 1
a59 1
#elif defined(_EGL_OS_UNIX)
d61 2
d64 1
a64 12
typedef void * lib_handle;

static void *
open_library(const char *filename)
{
   return dlopen(filename, RTLD_LAZY);
}

static void
close_library(void *lib)
{
   dlclose(lib);
a67 10
static const char *
library_suffix(void)
{
   return ".so";
}


#endif


d69 2
a70 1
 * Open the named driver and find its bootstrap function: _eglMain().
d72 2
a73 2
static _EGLMain_t
_eglOpenLibrary(const char *driverPath, lib_handle *handle)
d75 7
a81 29
   lib_handle lib;
   _EGLMain_t mainFunc = NULL;
   const char *error = "unknown error";

   assert(driverPath);

   _eglLog(_EGL_DEBUG, "dlopen(%s)", driverPath);
   lib = open_library(driverPath);

#if defined(_EGL_OS_WINDOWS)
   /* XXX untested */
   if (lib)
      mainFunc = (_EGLMain_t) GetProcAddress(lib, "_eglMain");
#elif defined(_EGL_OS_UNIX)
   if (lib) {
      union {
         _EGLMain_t func;
         void *ptr;
      } tmp = { NULL };
      /* direct cast gives a warning when compiled with -pedantic */
      tmp.ptr = dlsym(lib, "_eglMain");
      mainFunc = tmp.func;
      if (!mainFunc)
         error = dlerror();
   }
   else {
      error = dlerror();
   }
#endif
d83 2
d86 2
a87 5
      _eglLog(_EGL_WARNING, "Could not open driver %s (%s)",
              driverPath, error);
      if (!getenv("EGL_DRIVER"))
         _eglLog(_EGL_WARNING,
                 "The driver can be overridden by setting EGL_DRIVER");
d91 1
d93 2
a94 4
      _eglLog(_EGL_WARNING, "_eglMain not found in %s (%s)",
              driverPath, error);
      if (lib)
         close_library(lib);
d98 1
a98 20
   *handle = lib;
   return mainFunc;
}


/**
 * Load a module and create the driver object.
 */
static EGLBoolean
_eglLoadModule(_EGLModule *mod)
{
   _EGLMain_t mainFunc;
   lib_handle lib;
   _EGLDriver *drv;

   mainFunc = _eglOpenLibrary(mod->Path, &lib);
   if (!mainFunc)
      return EGL_FALSE;

   drv = mainFunc(NULL);
d100 2
a101 3
      if (lib)
         close_library(lib);
      return EGL_FALSE;
d103 5
d109 2
a110 26
   if (!drv->Name) {
      _eglLog(_EGL_WARNING, "Driver loaded from %s has no name", mod->Path);
      drv->Name = "UNNAMED";
   }

   mod->Handle = (void *) lib;
   mod->Driver = drv;

   return EGL_TRUE;
}


/**
 * Unload a module.
 */
static void
_eglUnloadModule(_EGLModule *mod)
{
   /* destroy the driver */
   if (mod->Driver && mod->Driver->Unload)
      mod->Driver->Unload(mod->Driver);
   if (mod->Handle)
      close_library(mod->Handle);

   mod->Driver = NULL;
   mod->Handle = NULL;
d114 2
a115 5
/**
 * Add a module to the module array.
 */
static _EGLModule *
_eglAddModule(const char *path)
d117 2
a118 2
   _EGLModule *mod;
   EGLint i;
d120 1
a120 5
   if (!_eglModules) {
      _eglModules = _eglCreateArray("Module", 8);
      if (!_eglModules)
         return NULL;
   }
d122 3
a124 6
   /* find duplicates */
   for (i = 0; i < _eglModules->Size; i++) {
      mod = _eglModules->Elements[i];
      if (strcmp(mod->Path, path) == 0)
         return mod;
   }
d126 3
a128 15
   /* allocate a new one */
   mod = calloc(1, sizeof(*mod));
   if (mod) {
      mod->Path = _eglstrdup(path);
      if (!mod->Path) {
         free(mod);
         mod = NULL;
      }
   }
   if (mod) {
      _eglAppendArray(_eglModules, (void *) mod);
      _eglLog(_EGL_DEBUG, "added %s to module array", mod->Path);
   }

   return mod;
d133 1
a133 1
 * Free a module.
d135 2
a136 2
static void
_eglFreeModule(void *module)
d138 5
a142 5
   _EGLModule *mod = (_EGLModule *) module;

   _eglUnloadModule(mod);
   free(mod->Path);
   free(mod);
d147 2
a148 2
 * A loader function for use with _eglPreloadForEach.  The loader data is the
 * filename of the driver.   This function stops on the first valid driver.
d150 2
a151 52
static EGLBoolean
_eglLoaderFile(const char *dir, size_t len, void *loader_data)
{
   char path[1024];
   const char *filename = (const char *) loader_data;
   size_t flen = strlen(filename);

   /* make a full path */
   if (len + flen + 2 > sizeof(path))
      return EGL_TRUE;
   if (len) {
      memcpy(path, dir, len);
      path[len++] = '/';
   }
   memcpy(path + len, filename, flen);
   len += flen;
   path[len] = '\0';

   if (library_suffix()) {
      const char *suffix = library_suffix();
      size_t slen = strlen(suffix);
      const char *p;
      EGLBoolean need_suffix;

      p = filename + flen - slen;
      need_suffix = (p < filename || strcmp(p, suffix) != 0);
      if (need_suffix) {
         /* overflow */
         if (len + slen + 1 > sizeof(path))
            return EGL_TRUE;
         strcpy(path + len, suffix);
      }
   }

#if defined(_EGL_OS_UNIX)
   /* check if the file exists */
   if (access(path, F_OK))
      return EGL_TRUE;
#endif

   _eglAddModule(path);

   return EGL_TRUE;
}


/**
 * A loader function for use with _eglPreloadForEach.  The loader data is the
 * pattern (prefix) of the files to look for.
 */
static EGLBoolean
_eglLoaderPattern(const char *dir, size_t len, void *loader_data)
d153 48
a200 52
#if defined(_EGL_OS_UNIX)
   const char *prefix, *suffix;
   size_t prefix_len, suffix_len;
   DIR *dirp;
   struct dirent *dirent;
   char path[1024];

   if (len + 2 > sizeof(path))
      return EGL_TRUE;
   if (len) {
      memcpy(path, dir, len);
      path[len++] = '/';
   }
   path[len] = '\0';

   dirp = opendir(path);
   if (!dirp)
      return EGL_TRUE;

   prefix = (const char *) loader_data;
   prefix_len = strlen(prefix);
   suffix = library_suffix();
   suffix_len = (suffix) ? strlen(suffix) : 0;

   while ((dirent = readdir(dirp))) {
      size_t dirent_len = strlen(dirent->d_name);
      const char *p;

      /* match the prefix */
      if (strncmp(dirent->d_name, prefix, prefix_len) != 0)
         continue;
      /* match the suffix */
      if (suffix) {
         p = dirent->d_name + dirent_len - suffix_len;
         if (p < dirent->d_name || strcmp(p, suffix) != 0)
            continue;
      }

      /* make a full path and add it to the module array */
      if (len + dirent_len + 1 <= sizeof(path)) {
         strcpy(path + len, dirent->d_name);
         _eglAddModule(path);
      }
   }

   closedir(dirp);

   return EGL_TRUE;
#else /* _EGL_OS_UNIX */
   /* stop immediately */
   return EGL_FALSE;
#endif
d205 2
a206 3
 * Run the callback function on each driver directory.
 *
 * The process may end prematurely if the callback function returns false.
d209 1
a209 3
_eglPreloadForEach(const char *search_path,
                   EGLBoolean (*loader)(const char *, size_t, void *),
                   void *loader_data)
d211 1
a211 10
   const char *cur, *next;
   size_t len;

   cur = search_path;
   while (cur) {
      next = strchr(cur, ':');
      len = (next) ? next - cur : strlen(cur);

      if (!loader(cur, len, loader_data))
         break;
d213 5
a217 2
      cur = (next) ? next + 1 : NULL;
   }
a220 7
/**
 * Return a list of colon-separated driver directories.
 */
static const char *
_eglGetSearchPath(void)
{
   static char search_path[1024];
d222 17
a238 14
#if defined(_EGL_OS_UNIX) || defined(_EGL_OS_WINDOWS)
   if (search_path[0] == '\0') {
      char *buf = search_path;
      size_t len = sizeof(search_path);
      EGLBoolean use_env;
      char dir_sep;
      int ret;

#if defined(_EGL_OS_UNIX)
      use_env = (geteuid() == getuid() && getegid() == getgid());
      dir_sep = '/';
#else
      use_env = EGL_TRUE;
      dir_sep = '\\';
d240 3
a242 37

      if (use_env) {
         char *p;

         /* extract the dirname from EGL_DRIVER */
         p = getenv("EGL_DRIVER");
         if (p && strchr(p, dir_sep)) {
            ret = _eglsnprintf(buf, len, "%s", p);
            if (ret > 0 && ret < len) {
               p = strrchr(buf, dir_sep);
               *p++ = ':';

               len -= p - buf;
               buf = p;
            }
         }

         /* append EGL_DRIVERS_PATH */
         p = getenv("EGL_DRIVERS_PATH");
         if (p) {
            ret = _eglsnprintf(buf, len, "%s:", p);
            if (ret > 0 && ret < len) {
               buf += ret;
               len -= ret;
            }
         }
      }
      else {
         _eglLog(_EGL_DEBUG,
               "ignore EGL_DRIVERS_PATH for setuid/setgid binaries");
      }

      ret = _eglsnprintf(buf, len, "%s", _EGL_DRIVER_SEARCH_DIR);
      if (ret < 0 || ret >= len)
         search_path[0] = '\0';

      _eglLog(_EGL_DEBUG, "EGL search path is %s", search_path);
a243 3
#endif /* defined(_EGL_OS_UNIX) || defined(_EGL_OS_WINDOWS) */

   return search_path;
d247 2
a248 7
/**
 * Add the user driver to the module array.
 *
 * The user driver is specified by EGL_DRIVER.
 */
static void
_eglAddUserDriver(void)
d250 4
a253 16
   const char *search_path = _eglGetSearchPath();
   char *env;

   env = getenv("EGL_DRIVER");
#if defined(_EGL_OS_UNIX)
   if (env && strchr(env, '/')) {
      search_path = "";
      if ((geteuid() != getuid() || getegid() != getgid())) {
         _eglLog(_EGL_DEBUG,
               "ignore EGL_DRIVER for setuid/setgid binaries");
         env = NULL;
      }
   }
#endif /* _EGL_OS_UNIX */
   if (env)
      _eglPreloadForEach(search_path, _eglLoaderFile, (void *) env);
d257 2
a258 5
/**
 * Add default drivers to the module array.
 */
static void
_eglAddDefaultDrivers(void)
d260 8
a267 59
   const char *search_path = _eglGetSearchPath();
   EGLint i;
#if defined(_EGL_OS_WINDOWS)
   const char *DefaultDriverNames[] = {
      "egl_gallium"
   };
#elif defined(_EGL_OS_UNIX)
   const char *DefaultDriverNames[] = {
      "egl_gallium",
      "egl_dri2",
      "egl_glx"
   };
#endif

   for (i = 0; i < ARRAY_SIZE(DefaultDriverNames); i++) {
      void *name = (void *) DefaultDriverNames[i];
      _eglPreloadForEach(search_path, _eglLoaderFile, name);
   }
}


/**
 * Add drivers to the module array.  Drivers will be loaded as they are matched
 * to displays.
 */
static EGLBoolean
_eglAddDrivers(void)
{
   if (_eglModules)
      return EGL_TRUE;

   /* the order here decides the priorities of the drivers */
   _eglAddUserDriver();
   _eglAddDefaultDrivers();
   _eglPreloadForEach(_eglGetSearchPath(), _eglLoaderPattern, (void *) "egl_");

   return (_eglModules != NULL);
}


/**
 * Match a display to a driver.  The display is initialized unless use_probe is
 * true.
 *
 * The matching is done by finding the first driver that can initialize the
 * display, or when use_probe is true, the driver with highest score.
 */
_EGLDriver *
_eglMatchDriver(_EGLDisplay *dpy, EGLBoolean use_probe)
{
   _EGLModule *mod;
   _EGLDriver *best_drv = NULL;
   EGLint best_score = 0;
   EGLint major, minor, i;

   _eglLockMutex(&_eglModuleMutex);

   if (!_eglAddDrivers()) {
      _eglUnlockMutex(&_eglModuleMutex);
d271 1
a271 142
   /* match the loaded modules */
   for (i = 0; i < _eglModules->Size; i++) {
      mod = (_EGLModule *) _eglModules->Elements[i];
      if (!mod->Driver)
         break;

      if (use_probe) {
         EGLint score = (mod->Driver->Probe) ?
            mod->Driver->Probe(mod->Driver, dpy) : 1;
         if (score > best_score) {
            best_drv = mod->Driver;
            best_score = score;
         }
      }
      else {
         if (mod->Driver->API.Initialize(mod->Driver, dpy, &major, &minor)) {
            best_drv = mod->Driver;
            best_score = 100;
         }
      }
      /* perfect match */
      if (best_score >= 100)
         break;
   }

   /* load more modules */
   if (!best_drv) {
      EGLint first_unloaded = i;

      while (i < _eglModules->Size) {
         mod = (_EGLModule *) _eglModules->Elements[i];
         assert(!mod->Driver);

         if (!_eglLoadModule(mod)) {
            /* remove invalid modules */
            _eglEraseArray(_eglModules, i, _eglFreeModule);
            continue;
         }

         if (use_probe) {
            best_score = (mod->Driver->Probe) ?
               mod->Driver->Probe(mod->Driver, dpy) : 1;
         }
         else {
            if (mod->Driver->API.Initialize(mod->Driver, dpy, &major, &minor))
               best_score = 100;
         }

         if (best_score > 0) {
            best_drv = mod->Driver;
            /* loaded modules come before unloaded ones */
            if (first_unloaded != i) {
               void *tmp = _eglModules->Elements[i];
               _eglModules->Elements[i] =
                  _eglModules->Elements[first_unloaded];
               _eglModules->Elements[first_unloaded] = tmp;
            }
            break;
         }
         else {
            _eglUnloadModule(mod);
            i++;
         }
      }
   }

   _eglUnlockMutex(&_eglModuleMutex);

   if (best_drv) {
      _eglLog(_EGL_DEBUG, "the best driver is %s (score %d)",
            best_drv->Name, best_score);
      if (!use_probe) {
         dpy->Driver = best_drv;
         dpy->Initialized = EGL_TRUE;
         dpy->APImajor = major;
         dpy->APIminor = minor;
      }
   }

   return best_drv;
}


__eglMustCastToProperFunctionPointerType
_eglGetDriverProc(const char *procname)
{
   EGLint i;
   _EGLProc proc = NULL;

   if (!_eglModules) {
      /* load the driver for the default display */
      EGLDisplay egldpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      _EGLDisplay *dpy = _eglLookupDisplay(egldpy);
      if (!dpy || !_eglMatchDriver(dpy, EGL_TRUE))
         return NULL;
   }

   for (i = 0; i < _eglModules->Size; i++) {
      _EGLModule *mod = (_EGLModule *) _eglModules->Elements[i];

      if (!mod->Driver)
         break;
      proc = mod->Driver->API.GetProcAddress(mod->Driver, procname);
      if (proc)
         break;
   }

   return proc;
}


/**
 * Unload all drivers.
 */
void
_eglUnloadDrivers(void)
{
   /* this is called at atexit time */
   if (_eglModules) {
#if defined(_EGL_OS_UNIX)
      _eglDestroyArray(_eglModules, _eglFreeModule);
#elif defined(_EGL_OS_WINDOWS)
      /* XXX Windows unloads DLLs before atexit */
      _eglDestroyArray(_eglModules, NULL);
#endif
      _eglModules = NULL;
   }
}


/**
 * Invoke a callback function on each EGL search path.
 *
 * The first argument of the callback function is the name of the search path.
 * The second argument is the length of the name.
 */
void
_eglSearchPathForEach(EGLBoolean (*callback)(const char *, size_t, void *),
                      void *callback_data)
{
   const char *search_path = _eglGetSearchPath();
   _eglPreloadForEach(search_path, callback, callback_data);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a0 30
/**************************************************************************
 *
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright 2010-2011 LunarG, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


a27 1
   _EGLMain_t BuiltIn;
a34 15
const struct {
   const char *name;
   _EGLMain_t main;
} _eglBuiltInDrivers[] = {
#ifdef _EGL_BUILT_IN_DRIVER_GALLIUM
   { "egl_gallium", _eglBuiltInDriverGALLIUM },
#endif
#ifdef _EGL_BUILT_IN_DRIVER_DRI2
   { "egl_dri2", _eglBuiltInDriverDRI2 },
#endif
#ifdef _EGL_BUILT_IN_DRIVER_GLX
   { "egl_glx", _eglBuiltInDriverGLX },
#endif
   { NULL, NULL }
};
d131 3
d160 3
a162 12
   if (mod->Driver)
      return EGL_TRUE;

   if (mod->BuiltIn) {
      lib = (lib_handle) NULL;
      mainFunc = mod->BuiltIn;
   }
   else {
      mainFunc = _eglOpenLibrary(mod->Path, &lib);
      if (!mainFunc)
         return EGL_FALSE;
   }
a188 1
#if defined(_EGL_OS_UNIX)
a191 6

   /*
    * XXX At this point (atexit), the module might be the last reference to
    * libEGL.  Closing the module might unmap libEGL and give problems.
    */
#if 0
a193 4
#endif
#elif defined(_EGL_OS_WINDOWS)
   /* XXX Windows unloads DLLs before atexit */
#endif
d305 62
d464 1
a464 1
static EGLBoolean
a468 1
   size_t name_len = 0;
d480 1
a480 5
   else if (env) {
      char *suffix = strchr(env, '.');
      name_len = (suffix) ? suffix - env : strlen(env);
   }
#else
a481 26
      name_len = strlen(env);
#endif /* _EGL_OS_UNIX */

   /*
    * Try built-in drivers first if we know the driver name.  This makes sure
    * we do not load the outdated external driver that is still on the
    * filesystem.
    */
   if (name_len) {
      _EGLModule *mod;
      EGLint i;

      for (i = 0; _eglBuiltInDrivers[i].name; i++) {
         if (strlen(_eglBuiltInDrivers[i].name) == name_len &&
             !strncmp(_eglBuiltInDrivers[i].name, env, name_len)) {
            mod = _eglAddModule(env);
            if (mod)
               mod->BuiltIn = _eglBuiltInDrivers[i].main;

            return EGL_TRUE;
         }
      }
   }

   /* otherwise, treat env as a path */
   if (env) {
a482 5

      return EGL_TRUE;
   }

   return EGL_FALSE;
d487 1
a487 1
 * Add egl_gallium to the module array.
d490 1
a490 1
_eglAddGalliumDriver(void)
d492 12
a503 3
#ifndef _EGL_BUILT_IN_DRIVER_GALLIUM
   void *external = (void *) "egl_gallium";
   _eglPreloadForEach(_eglGetSearchPath(), _eglLoaderFile, external);
a504 11
}


/**
 * Add built-in drivers to the module array.
 */
static void
_eglAddBuiltInDrivers(void)
{
   _EGLModule *mod;
   EGLint i;
d506 3
a508 4
   for (i = 0; _eglBuiltInDrivers[i].name; i++) {
      mod = _eglAddModule(_eglBuiltInDrivers[i].name);
      if (mod)
         mod->BuiltIn = _eglBuiltInDrivers[i].main;
d523 4
a526 8
   if (!_eglAddUserDriver()) {
      /*
       * Add other drivers only when EGL_DRIVER is not set.  The order here
       * decides the priorities.
       */
      _eglAddGalliumDriver();
      _eglAddBuiltInDrivers();
   }
d533 5
a537 2
 * A helper function for _eglMatchDriver.  It finds the first driver that can
 * initialize the display and return.
d539 2
a540 2
static _EGLDriver *
_eglMatchAndInitialize(_EGLDisplay *dpy)
d542 6
a547 2
   _EGLDriver *drv = NULL;
   EGLint i = 0;
d550 2
a551 2
      _eglLog(_EGL_WARNING, "failed to find any driver");
      return NULL;
d554 5
a558 7
   if (dpy->Driver) {
      drv = dpy->Driver;
      /* no re-matching? */
      if (!drv->API.Initialize(drv, dpy))
         drv = NULL;
      return drv;
   }
d560 7
a566 12
   while (i < _eglModules->Size) {
      _EGLModule *mod = (_EGLModule *) _eglModules->Elements[i];

      if (!_eglLoadModule(mod)) {
         /* remove invalid modules */
         _eglEraseArray(_eglModules, i, _eglFreeModule);
         continue;
      }

      if (mod->Driver->API.Initialize(mod->Driver, dpy)) {
         drv = mod->Driver;
         break;
d569 4
a572 1
         i++;
d574 3
d579 3
a581 2
   return drv;
}
d583 9
d593 8
a600 9
/**
 * Match a display to a driver.  The display is initialized unless test_only is
 * true.  The matching is done by finding the first driver that can initialize
 * the display.
 */
_EGLDriver *
_eglMatchDriver(_EGLDisplay *dpy, EGLBoolean test_only)
{
   _EGLDriver *best_drv;
d602 16
a617 12
   assert(!dpy->Initialized);

   _eglLockMutex(&_eglModuleMutex);

   /* set options */
   dpy->Options.TestOnly = test_only;
   dpy->Options.UseFallback = EGL_FALSE;

   best_drv = _eglMatchAndInitialize(dpy);
   if (!best_drv) {
      dpy->Options.UseFallback = EGL_TRUE;
      best_drv = _eglMatchAndInitialize(dpy);
d623 3
a625 3
      _eglLog(_EGL_DEBUG, "the best driver is %s%s",
            best_drv->Name, (test_only) ? " (test only) " : "");
      if (!test_only) {
d628 2
d673 1
d675 4
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
d63 1
a63 1
static _EGLMutex _eglModuleMutex = _EGL_MUTEX_INITIALIZER;
d75 3
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d521 13
d565 1
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a520 13
 * Add egl_gallium to the module array.
 */
static void
_eglAddGalliumDriver(void)
{
#ifndef _EGL_BUILT_IN_DRIVER_GALLIUM
   void *external = (void *) "egl_gallium";
   _eglPreloadForEach(_eglGetSearchPath(), _eglLoaderFile, external);
#endif
}


/**
a551 1
      _eglAddGalliumDriver();
@


