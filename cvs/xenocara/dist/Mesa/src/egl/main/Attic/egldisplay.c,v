head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.25;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2014.07.09.21.08.51;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.13.59.24;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.10;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.22;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.40;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008 VMware, Inc.
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright 2010-2011 LunarG, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


/**
 * Functions related to EGLDisplay.
 */

#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "eglcontext.h"
#include "eglcurrent.h"
#include "eglsurface.h"
#include "egldisplay.h"
#include "egldriver.h"
#include "eglglobals.h"
#include "eglmutex.h"
#include "egllog.h"

/* Includes for _eglNativePlatformDetectNativeDisplay */
#ifdef HAVE_MINCORE
#include <unistd.h>
#include <sys/mman.h>
#endif
#ifdef HAVE_WAYLAND_PLATFORM
#include <wayland-client.h>
#endif
#ifdef HAVE_DRM_PLATFORM
#include <gbm.h>
#endif
#ifdef HAVE_FBDEV_PLATFORM
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#endif


/**
 * Map --with-egl-platforms names to platform types.
 */
static const struct {
   _EGLPlatformType platform;
   const char *name;
} egl_platforms[_EGL_NUM_PLATFORMS] = {
   { _EGL_PLATFORM_WINDOWS, "gdi" },
   { _EGL_PLATFORM_X11, "x11" },
   { _EGL_PLATFORM_WAYLAND, "wayland" },
   { _EGL_PLATFORM_DRM, "drm" },
   { _EGL_PLATFORM_FBDEV, "fbdev" },
   { _EGL_PLATFORM_NULL, "null" },
   { _EGL_PLATFORM_ANDROID, "android" }
};


/**
 * Return the native platform by parsing EGL_PLATFORM.
 */
static _EGLPlatformType
_eglGetNativePlatformFromEnv(void)
{
   _EGLPlatformType plat = _EGL_INVALID_PLATFORM;
   const char *plat_name;
   EGLint i;

   plat_name = getenv("EGL_PLATFORM");
   /* try deprecated env variable */
   if (!plat_name || !plat_name[0])
      plat_name = getenv("EGL_DISPLAY");
   if (!plat_name || !plat_name[0])
      return _EGL_INVALID_PLATFORM;

   for (i = 0; i < _EGL_NUM_PLATFORMS; i++) {
      if (strcmp(egl_platforms[i].name, plat_name) == 0) {
         plat = egl_platforms[i].platform;
         break;
      }
   }

   return plat;
}


/**
 * Perform validity checks on a generic pointer.
 */
static EGLBoolean
_eglPointerIsDereferencable(void *p)
{
#ifdef HAVE_MINCORE
   uintptr_t addr = (uintptr_t) p;
   unsigned char valid = 0;
   const long page_size = getpagesize();

   if (p == NULL)
      return EGL_FALSE;

   /* align addr to page_size */
   addr &= ~(page_size - 1);

   if (mincore((void *) addr, page_size, &valid) < 0) {
      _eglLog(_EGL_DEBUG, "mincore failed: %m");
      return EGL_FALSE;
   }

   return (valid & 0x01) == 0x01;
#else
   return p != NULL;
#endif
}


/**
 * Try detecting native platform with the help of native display characteristcs.
 */
static _EGLPlatformType
_eglNativePlatformDetectNativeDisplay(void *nativeDisplay)
{
#ifdef HAVE_FBDEV_PLATFORM
   struct stat buf;
#endif

   if (nativeDisplay == EGL_DEFAULT_DISPLAY)
      return _EGL_INVALID_PLATFORM;

#ifdef HAVE_FBDEV_PLATFORM
   /* fbdev is the only platform that can be a file descriptor. */
   if (fstat((intptr_t) nativeDisplay, &buf) == 0 && S_ISCHR(buf.st_mode))
      return _EGL_PLATFORM_FBDEV;
#endif

   if (_eglPointerIsDereferencable(nativeDisplay)) {
      void *first_pointer = *(void **) nativeDisplay;

      (void) first_pointer; /* silence unused var warning */

#ifdef HAVE_WAYLAND_PLATFORM
      /* wl_display is a wl_proxy, which is a wl_object.
       * wl_object's first element points to the interfacetype. */
      if (first_pointer == &wl_display_interface)
         return _EGL_PLATFORM_WAYLAND;
#endif

#ifdef HAVE_DRM_PLATFORM
      /* gbm has a pointer to its constructor as first element. */
      if (first_pointer == gbm_create_device)
         return _EGL_PLATFORM_DRM;
#endif

#ifdef HAVE_X11_PLATFORM
      /* If not matched to any other platform, fallback to x11. */
      return _EGL_PLATFORM_X11;
#endif
   }

   return _EGL_INVALID_PLATFORM;
}


/**
 * Return the native platform.  It is the platform of the EGL native types.
 */
_EGLPlatformType
_eglGetNativePlatform(void *nativeDisplay)
{
   static _EGLPlatformType native_platform = _EGL_INVALID_PLATFORM;
   char *detection_method = NULL;

   if (native_platform == _EGL_INVALID_PLATFORM) {
      native_platform = _eglGetNativePlatformFromEnv();
      detection_method = "environment overwrite";
      if (native_platform == _EGL_INVALID_PLATFORM) {
         native_platform = _eglNativePlatformDetectNativeDisplay(nativeDisplay);
         detection_method = "autodetected";
         if (native_platform == _EGL_INVALID_PLATFORM) {
            native_platform = _EGL_NATIVE_PLATFORM;
            detection_method = "build-time configuration";
         }
      }
   }

   if (detection_method != NULL)
      _eglLog(_EGL_DEBUG, "Native platform type: %s (%s)",
              egl_platforms[native_platform].name, detection_method);

   return native_platform;
}


/**
 * Finish display management.
 */
void
_eglFiniDisplay(void)
{
   _EGLDisplay *dpyList, *dpy;

   /* atexit function is called with global mutex locked */
   dpyList = _eglGlobal.DisplayList;
   while (dpyList) {
      EGLint i;

      /* pop list head */
      dpy = dpyList;
      dpyList = dpyList->Next;

      for (i = 0; i < _EGL_NUM_RESOURCES; i++) {
         if (dpy->ResourceLists[i]) {
            _eglLog(_EGL_DEBUG, "Display %p is destroyed with resources", dpy);
            break;
         }
      }

      free(dpy);
   }
   _eglGlobal.DisplayList = NULL;
}


/**
 * Find the display corresponding to the specified native display, or create a
 * new one.
 */
_EGLDisplay *
_eglFindDisplay(_EGLPlatformType plat, void *plat_dpy)
{
   _EGLDisplay *dpy;

   if (plat == _EGL_INVALID_PLATFORM)
      return NULL;

   _eglLockMutex(_eglGlobal.Mutex);

   /* search the display list first */
   dpy = _eglGlobal.DisplayList;
   while (dpy) {
      if (dpy->Platform == plat && dpy->PlatformDisplay == plat_dpy)
         break;
      dpy = dpy->Next;
   }

   /* create a new display */
   if (!dpy) {
      dpy = calloc(1, sizeof(_EGLDisplay));
      if (dpy) {
         _eglInitMutex(&dpy->Mutex);
         dpy->Platform = plat;
         dpy->PlatformDisplay = plat_dpy;

         /* add to the display list */ 
         dpy->Next = _eglGlobal.DisplayList;
         _eglGlobal.DisplayList = dpy;
      }
   }

   _eglUnlockMutex(_eglGlobal.Mutex);

   return dpy;
}


/**
 * Destroy the contexts and surfaces that are linked to the display.
 */
void
_eglReleaseDisplayResources(_EGLDriver *drv, _EGLDisplay *display)
{
   _EGLResource *list;

   list = display->ResourceLists[_EGL_RESOURCE_CONTEXT];
   while (list) {
      _EGLContext *ctx = (_EGLContext *) list;
      list = list->Next;

      _eglUnlinkContext(ctx);
      drv->API.DestroyContext(drv, display, ctx);
   }
   assert(!display->ResourceLists[_EGL_RESOURCE_CONTEXT]);

   list = display->ResourceLists[_EGL_RESOURCE_SURFACE];
   while (list) {
      _EGLSurface *surf = (_EGLSurface *) list;
      list = list->Next;

      _eglUnlinkSurface(surf);
      drv->API.DestroySurface(drv, display, surf);
   }
   assert(!display->ResourceLists[_EGL_RESOURCE_SURFACE]);
}


/**
 * Free all the data hanging of an _EGLDisplay object, but not
 * the object itself.
 */
void
_eglCleanupDisplay(_EGLDisplay *disp)
{
   if (disp->Configs) {
      _eglDestroyArray(disp->Configs, free);
      disp->Configs = NULL;
   }

   /* XXX incomplete */
}


/**
 * Return EGL_TRUE if the given handle is a valid handle to a display.
 */
EGLBoolean
_eglCheckDisplayHandle(EGLDisplay dpy)
{
   _EGLDisplay *cur;

   _eglLockMutex(_eglGlobal.Mutex);
   cur = _eglGlobal.DisplayList;
   while (cur) {
      if (cur == (_EGLDisplay *) dpy)
         break;
      cur = cur->Next;
   }
   _eglUnlockMutex(_eglGlobal.Mutex);
   return (cur != NULL);
}


/**
 * Return EGL_TRUE if the given resource is valid.  That is, the display does
 * own the resource.
 */
EGLBoolean
_eglCheckResource(void *res, _EGLResourceType type, _EGLDisplay *dpy)
{
   _EGLResource *list = dpy->ResourceLists[type];
   
   if (!res)
      return EGL_FALSE;

   while (list) {
      if (res == (void *) list) {
         assert(list->Display == dpy);
         break;
      }
      list = list->Next;
   }

   return (list != NULL);
}


/**
 * Initialize a display resource.  The size of the subclass object is
 * specified.
 *
 * This is supposed to be called from the initializers of subclasses, such as
 * _eglInitContext or _eglInitSurface.
 */
void
_eglInitResource(_EGLResource *res, EGLint size, _EGLDisplay *dpy)
{
   memset(res, 0, size);
   res->Display = dpy;
   res->RefCount = 1;
}


/**
 * Increment reference count for the resource.
 */
void
_eglGetResource(_EGLResource *res)
{
   assert(res && res->RefCount > 0);
   /* hopefully a resource is always manipulated with its display locked */
   res->RefCount++;
}


/**
 * Decrement reference count for the resource.
 */
EGLBoolean
_eglPutResource(_EGLResource *res)
{
   assert(res && res->RefCount > 0);
   res->RefCount--;
   return (!res->RefCount);
}


/**
 * Link a resource to its display.
 */
void
_eglLinkResource(_EGLResource *res, _EGLResourceType type)
{
   assert(res->Display);

   res->IsLinked = EGL_TRUE;
   res->Next = res->Display->ResourceLists[type];
   res->Display->ResourceLists[type] = res;
   _eglGetResource(res);
}


/**
 * Unlink a linked resource from its display.
 */
void
_eglUnlinkResource(_EGLResource *res, _EGLResourceType type)
{
   _EGLResource *prev;

   prev = res->Display->ResourceLists[type];
   if (prev != res) {
      while (prev) {
         if (prev->Next == res)
            break;
         prev = prev->Next;
      }
      assert(prev);
      prev->Next = res->Next;
   }
   else {
      res->Display->ResourceLists[type] = res->Next;
   }

   res->Next = NULL;
   res->IsLinked = EGL_FALSE;
   _eglPutResource(res);

   /* We always unlink before destroy.  The driver still owns a reference */
   assert(res->RefCount);
}

#ifdef HAVE_X11_PLATFORM
static EGLBoolean
_eglParseX11DisplayAttribList(const EGLint *attrib_list)
{
   int i;

   if (attrib_list == NULL) {
      return EGL_TRUE;
   }

   for (i = 0; attrib_list[i] != EGL_NONE; i += 2) {
      EGLint attrib = attrib_list[i];
      EGLint value = attrib_list[i + 1];

      /* EGL_EXT_platform_x11 recognizes exactly one attribute,
       * EGL_PLATFORM_X11_SCREEN_EXT, which is optional.
       * 
       * Mesa supports connecting to only the default screen, so we reject
       * screen != 0.
       */
      if (attrib != EGL_PLATFORM_X11_SCREEN_EXT || value != 0) {
         _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
         return EGL_FALSE;
      }
   }

   return EGL_TRUE;
}

_EGLDisplay*
_eglGetX11Display(Display *native_display,
                  const EGLint *attrib_list)
{
   if (!_eglParseX11DisplayAttribList(attrib_list)) {
      return NULL;
   }

   return _eglFindDisplay(_EGL_PLATFORM_X11, native_display);
}
#endif /* HAVE_X11_PLATFORM */

#ifdef HAVE_DRM_PLATFORM
_EGLDisplay*
_eglGetGbmDisplay(struct gbm_device *native_display,
                  const EGLint *attrib_list)
{
   /* EGL_MESA_platform_gbm recognizes no attributes. */
   if (attrib_list != NULL && attrib_list[0] != EGL_NONE) {
      _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
      return NULL;
   }

   return _eglFindDisplay(_EGL_PLATFORM_DRM, native_display);
}
#endif /* HAVE_DRM_PLATFORM */

#ifdef HAVE_WAYLAND_PLATFORM
_EGLDisplay*
_eglGetWaylandDisplay(struct wl_display *native_display,
                      const EGLint *attrib_list)
{
   /* EGL_EXT_platform_wayland recognizes no attributes. */
   if (attrib_list != NULL && attrib_list[0] != EGL_NONE) {
      _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
      return NULL;
   }

   return _eglFindDisplay(_EGL_PLATFORM_WAYLAND, native_display);
}
#endif /* HAVE_WAYLAND_PLATFORM */
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.5
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d39 1
d143 1
a143 1
_eglNativePlatformDetectNativeDisplay(EGLNativeDisplayType nativeDisplay)
d190 1
a190 1
_eglGetNativePlatform(EGLNativeDisplayType nativeDisplay)
d379 5
a383 1
 * Initialize a display resource.
d462 71
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d46 34
a86 11
   /* map --with-egl-platforms names to platform types */
   static const struct {
      _EGLPlatformType platform;
      const char *name;
   } egl_platforms[_EGL_NUM_PLATFORMS] = {
      { _EGL_PLATFORM_WINDOWS, "gdi" },
      { _EGL_PLATFORM_X11, "x11" },
      { _EGL_PLATFORM_WAYLAND, "wayland" },
      { _EGL_PLATFORM_DRM, "drm" },
      { _EGL_PLATFORM_FBDEV, "fbdev" }
   };
d110 76
d189 1
a189 1
_eglGetNativePlatform(void)
d192 1
d196 9
a204 2
      if (native_platform == _EGL_INVALID_PLATFORM)
         native_platform = _EGL_NATIVE_PLATFORM;
d207 4
d269 1
a269 1
      dpy = (_EGLDisplay *) calloc(1, sizeof(_EGLDisplay));
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d1 30
d60 1
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d18 56
d108 1
a108 1
_eglFindDisplay(EGLNativeDisplayType nativeDisplay)
d112 3
d120 1
a120 1
      if (dpy->NativeDisplay == nativeDisplay)
d130 2
a131 1
         dpy->NativeDisplay = nativeDisplay;
a181 2
   EGLint i;

d183 1
a183 3
      for (i = 0; i < disp->NumConfigs; i++)
         free(disp->Configs[i]);
      free(disp->Configs);
a184 2
      disp->NumConfigs = 0;
      disp->MaxConfigs = 0;
d236 1
a236 1
 * Link a resource to a display.
d239 1
a239 1
_eglLinkResource(_EGLResource *res, _EGLResourceType type, _EGLDisplay *dpy)
d241 37
a277 1
   assert(!res->Display || res->Display == dpy);
a278 1
   res->Display = dpy;
d280 3
a282 2
   res->Next = dpy->ResourceLists[type];
   dpy->ResourceLists[type] = res;
a308 1
   /* do not reset res->Display */
d310 4
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d1 5
d9 1
d11 1
d13 2
a14 1
#include "eglhash.h"
d17 5
a21 2
static char *
my_strdup(const char *s)
d23 21
a43 4
   int l = strlen(s);
   char *s2 = malloc(l + 1);
   strcpy(s2, s);
   return s2;
d48 2
a49 3
 * We're assuming that the NativeDisplayType parameter is actually
 * a string.
 * Return a new _EGLDisplay object for the given displayName
d52 1
a52 1
_eglNewDisplay(NativeDisplayType displayName)
d54 23
a76 9
   _EGLDisplay *dpy = (_EGLDisplay *) calloc(1, sizeof(_EGLDisplay));
   if (dpy) {
      dpy->Handle = _eglHashGenKey(_eglGlobal.Displays);
      _eglHashInsert(_eglGlobal.Displays, dpy->Handle, dpy);
      if (displayName)
         dpy->Name = my_strdup(displayName);
      else
         dpy->Name = NULL;
      dpy->Driver = NULL;  /* this gets set later */
d78 3
d86 74
a159 2
 * Return the _EGLDisplay object that corresponds to the given public/
 * opaque display handle.
d161 2
a162 2
_EGLDisplay *
_eglLookupDisplay(EGLDisplay dpy)
d164 14
a177 2
   _EGLDisplay *d = (_EGLDisplay *) _eglHashLookup(_eglGlobal.Displays, dpy);
   return d;
d181 5
a185 2
_EGLDisplay *
_eglGetCurrentDisplay(void)
d187 6
a192 5
   _EGLContext *ctx = _eglGetCurrentContext();
   if (ctx)
      return ctx->Display;
   else
      return NULL;
d196 3
d200 1
a200 1
_eglCleanupDisplay(_EGLDisplay *disp)
d202 19
a220 4
   /* XXX incomplete */
   free(disp->Configs);
   free(disp->Name);
   /* driver deletes _EGLDisplay */
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a0 5
/**
 * Functions related to EGLDisplay.
 */

#include <assert.h>
a3 1
#include "eglsurface.h"
a4 1
#include "egldriver.h"
d6 1
a6 2
#include "eglmutex.h"
#include "egllog.h"
d9 2
a10 5
/**
 * Return the native platform by parsing EGL_PLATFORM.
 */
static _EGLPlatformType
_eglGetNativePlatformFromEnv(void)
d12 4
a15 29
   /* map --with-egl-platforms names to platform types */
   static const struct {
      _EGLPlatformType platform;
      const char *name;
   } egl_platforms[_EGL_NUM_PLATFORMS] = {
      { _EGL_PLATFORM_WINDOWS, "gdi" },
      { _EGL_PLATFORM_X11, "x11" },
      { _EGL_PLATFORM_DRM, "drm" },
      { _EGL_PLATFORM_FBDEV, "fbdev" }
   };
   _EGLPlatformType plat = _EGL_INVALID_PLATFORM;
   const char *plat_name;
   EGLint i;

   plat_name = getenv("EGL_PLATFORM");
   /* try deprecated env variable */
   if (!plat_name || !plat_name[0])
      plat_name = getenv("EGL_DISPLAY");
   if (!plat_name || !plat_name[0])
      return _EGL_INVALID_PLATFORM;

   for (i = 0; i < _EGL_NUM_PLATFORMS; i++) {
      if (strcmp(egl_platforms[i].name, plat_name) == 0) {
         plat = egl_platforms[i].platform;
         break;
      }
   }

   return plat;
d20 3
a22 1
 * Return the native platform.  It is the platform of the EGL native types.
d24 2
a25 2
_EGLPlatformType
_eglGetNativePlatform(void)
d27 9
a35 6
   static _EGLPlatformType native_platform = _EGL_INVALID_PLATFORM;

   if (native_platform == _EGL_INVALID_PLATFORM) {
      native_platform = _eglGetNativePlatformFromEnv();
      if (native_platform == _EGL_INVALID_PLATFORM)
         native_platform = _EGL_NATIVE_PLATFORM;
d37 1
a37 2

   return native_platform;
d42 2
a43 1
 * Finish display management.
d45 2
a46 2
void
_eglFiniDisplay(void)
d48 2
a49 21
   _EGLDisplay *dpyList, *dpy;

   /* atexit function is called with global mutex locked */
   dpyList = _eglGlobal.DisplayList;
   while (dpyList) {
      EGLint i;

      /* pop list head */
      dpy = dpyList;
      dpyList = dpyList->Next;

      for (i = 0; i < _EGL_NUM_RESOURCES; i++) {
         if (dpy->ResourceLists[i]) {
            _eglLog(_EGL_DEBUG, "Display %p is destroyed with resources", dpy);
            break;
         }
      }

      free(dpy);
   }
   _eglGlobal.DisplayList = NULL;
a52 4
/**
 * Find the display corresponding to the specified native display, or create a
 * new one.
 */
d54 1
a54 1
_eglFindDisplay(_EGLPlatformType plat, void *plat_dpy)
d56 4
a59 3
   _EGLDisplay *dpy;

   if (plat == _EGL_INVALID_PLATFORM)
a60 58

   _eglLockMutex(_eglGlobal.Mutex);

   /* search the display list first */
   dpy = _eglGlobal.DisplayList;
   while (dpy) {
      if (dpy->Platform == plat && dpy->PlatformDisplay == plat_dpy)
         break;
      dpy = dpy->Next;
   }

   /* create a new display */
   if (!dpy) {
      dpy = (_EGLDisplay *) calloc(1, sizeof(_EGLDisplay));
      if (dpy) {
         _eglInitMutex(&dpy->Mutex);
         dpy->Platform = plat;
         dpy->PlatformDisplay = plat_dpy;

         /* add to the display list */ 
         dpy->Next = _eglGlobal.DisplayList;
         _eglGlobal.DisplayList = dpy;
      }
   }

   _eglUnlockMutex(_eglGlobal.Mutex);

   return dpy;
}


/**
 * Destroy the contexts and surfaces that are linked to the display.
 */
void
_eglReleaseDisplayResources(_EGLDriver *drv, _EGLDisplay *display)
{
   _EGLResource *list;

   list = display->ResourceLists[_EGL_RESOURCE_CONTEXT];
   while (list) {
      _EGLContext *ctx = (_EGLContext *) list;
      list = list->Next;

      _eglUnlinkContext(ctx);
      drv->API.DestroyContext(drv, display, ctx);
   }
   assert(!display->ResourceLists[_EGL_RESOURCE_CONTEXT]);

   list = display->ResourceLists[_EGL_RESOURCE_SURFACE];
   while (list) {
      _EGLSurface *surf = (_EGLSurface *) list;
      list = list->Next;

      _eglUnlinkSurface(surf);
      drv->API.DestroySurface(drv, display, surf);
   }
   assert(!display->ResourceLists[_EGL_RESOURCE_SURFACE]);
a63 4
/**
 * Free all the data hanging of an _EGLDisplay object, but not
 * the object itself.
 */
a66 5
   if (disp->Configs) {
      _eglDestroyArray(disp->Configs, free);
      disp->Configs = NULL;
   }

d68 3
a70 126
}


/**
 * Return EGL_TRUE if the given handle is a valid handle to a display.
 */
EGLBoolean
_eglCheckDisplayHandle(EGLDisplay dpy)
{
   _EGLDisplay *cur;

   _eglLockMutex(_eglGlobal.Mutex);
   cur = _eglGlobal.DisplayList;
   while (cur) {
      if (cur == (_EGLDisplay *) dpy)
         break;
      cur = cur->Next;
   }
   _eglUnlockMutex(_eglGlobal.Mutex);
   return (cur != NULL);
}


/**
 * Return EGL_TRUE if the given resource is valid.  That is, the display does
 * own the resource.
 */
EGLBoolean
_eglCheckResource(void *res, _EGLResourceType type, _EGLDisplay *dpy)
{
   _EGLResource *list = dpy->ResourceLists[type];
   
   if (!res)
      return EGL_FALSE;

   while (list) {
      if (res == (void *) list) {
         assert(list->Display == dpy);
         break;
      }
      list = list->Next;
   }

   return (list != NULL);
}


/**
 * Initialize a display resource.
 */
void
_eglInitResource(_EGLResource *res, EGLint size, _EGLDisplay *dpy)
{
   memset(res, 0, size);
   res->Display = dpy;
   res->RefCount = 1;
}


/**
 * Increment reference count for the resource.
 */
void
_eglGetResource(_EGLResource *res)
{
   assert(res && res->RefCount > 0);
   /* hopefully a resource is always manipulated with its display locked */
   res->RefCount++;
}


/**
 * Decrement reference count for the resource.
 */
EGLBoolean
_eglPutResource(_EGLResource *res)
{
   assert(res && res->RefCount > 0);
   res->RefCount--;
   return (!res->RefCount);
}


/**
 * Link a resource to its display.
 */
void
_eglLinkResource(_EGLResource *res, _EGLResourceType type)
{
   assert(res->Display);

   res->IsLinked = EGL_TRUE;
   res->Next = res->Display->ResourceLists[type];
   res->Display->ResourceLists[type] = res;
   _eglGetResource(res);
}


/**
 * Unlink a linked resource from its display.
 */
void
_eglUnlinkResource(_EGLResource *res, _EGLResourceType type)
{
   _EGLResource *prev;

   prev = res->Display->ResourceLists[type];
   if (prev != res) {
      while (prev) {
         if (prev->Next == res)
            break;
         prev = prev->Next;
      }
      assert(prev);
      prev->Next = res->Next;
   }
   else {
      res->Display->ResourceLists[type] = res->Next;
   }

   res->Next = NULL;
   res->IsLinked = EGL_FALSE;
   _eglPutResource(res);

   /* We always unlink before destroy.  The driver still owns a reference */
   assert(res->RefCount);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a0 30
/**************************************************************************
 *
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright 2010-2011 LunarG, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


a15 34
/* Includes for _eglNativePlatformDetectNativeDisplay */
#ifdef HAVE_MINCORE
#include <unistd.h>
#include <sys/mman.h>
#endif
#ifdef HAVE_WAYLAND_PLATFORM
#include <wayland-client.h>
#endif
#ifdef HAVE_DRM_PLATFORM
#include <gbm.h>
#endif
#ifdef HAVE_FBDEV_PLATFORM
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#endif


/**
 * Map --with-egl-platforms names to platform types.
 */
static const struct {
   _EGLPlatformType platform;
   const char *name;
} egl_platforms[_EGL_NUM_PLATFORMS] = {
   { _EGL_PLATFORM_WINDOWS, "gdi" },
   { _EGL_PLATFORM_X11, "x11" },
   { _EGL_PLATFORM_WAYLAND, "wayland" },
   { _EGL_PLATFORM_DRM, "drm" },
   { _EGL_PLATFORM_FBDEV, "fbdev" },
   { _EGL_PLATFORM_NULL, "null" },
   { _EGL_PLATFORM_ANDROID, "android" }
};

d23 10
a55 76
 * Perform validity checks on a generic pointer.
 */
static EGLBoolean
_eglPointerIsDereferencable(void *p)
{
#ifdef HAVE_MINCORE
   uintptr_t addr = (uintptr_t) p;
   unsigned char valid = 0;
   const long page_size = getpagesize();

   if (p == NULL)
      return EGL_FALSE;

   /* align addr to page_size */
   addr &= ~(page_size - 1);

   if (mincore((void *) addr, page_size, &valid) < 0) {
      _eglLog(_EGL_DEBUG, "mincore failed: %m");
      return EGL_FALSE;
   }

   return (valid & 0x01) == 0x01;
#else
   return p != NULL;
#endif
}


/**
 * Try detecting native platform with the help of native display characteristcs.
 */
static _EGLPlatformType
_eglNativePlatformDetectNativeDisplay(EGLNativeDisplayType nativeDisplay)
{
#ifdef HAVE_FBDEV_PLATFORM
   struct stat buf;
#endif

   if (nativeDisplay == EGL_DEFAULT_DISPLAY)
      return _EGL_INVALID_PLATFORM;

#ifdef HAVE_FBDEV_PLATFORM
   /* fbdev is the only platform that can be a file descriptor. */
   if (fstat((intptr_t) nativeDisplay, &buf) == 0 && S_ISCHR(buf.st_mode))
      return _EGL_PLATFORM_FBDEV;
#endif

   if (_eglPointerIsDereferencable(nativeDisplay)) {
      void *first_pointer = *(void **) nativeDisplay;

      (void) first_pointer; /* silence unused var warning */

#ifdef HAVE_WAYLAND_PLATFORM
      /* wl_display is a wl_proxy, which is a wl_object.
       * wl_object's first element points to the interfacetype. */
      if (first_pointer == &wl_display_interface)
         return _EGL_PLATFORM_WAYLAND;
#endif

#ifdef HAVE_DRM_PLATFORM
      /* gbm has a pointer to its constructor as first element. */
      if (first_pointer == gbm_create_device)
         return _EGL_PLATFORM_DRM;
#endif

#ifdef HAVE_X11_PLATFORM
      /* If not matched to any other platform, fallback to x11. */
      return _EGL_PLATFORM_X11;
#endif
   }

   return _EGL_INVALID_PLATFORM;
}


/**
d59 1
a59 1
_eglGetNativePlatform(EGLNativeDisplayType nativeDisplay)
a61 1
   char *detection_method = NULL;
d65 2
a66 9
      detection_method = "environment overwrite";
      if (native_platform == _EGL_INVALID_PLATFORM) {
         native_platform = _eglNativePlatformDetectNativeDisplay(nativeDisplay);
         detection_method = "autodetected";
         if (native_platform == _EGL_INVALID_PLATFORM) {
            native_platform = _EGL_NATIVE_PLATFORM;
            detection_method = "build-time configuration";
         }
      }
a68 4
   if (detection_method != NULL)
      _eglLog(_EGL_DEBUG, "Native platform type: %s (%s)",
              egl_platforms[native_platform].name, detection_method);

d127 1
a127 1
      dpy = calloc(1, sizeof(_EGLDisplay));
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
a38 1
#include "eglcurrent.h"
d142 1
a142 1
_eglNativePlatformDetectNativeDisplay(void *nativeDisplay)
d189 1
a189 1
_eglGetNativePlatform(void *nativeDisplay)
d378 1
a378 5
 * Initialize a display resource.  The size of the subclass object is
 * specified.
 *
 * This is supposed to be called from the initializers of subclasses, such as
 * _eglInitContext or _eglInitSurface.
a456 71

#ifdef HAVE_X11_PLATFORM
static EGLBoolean
_eglParseX11DisplayAttribList(const EGLint *attrib_list)
{
   int i;

   if (attrib_list == NULL) {
      return EGL_TRUE;
   }

   for (i = 0; attrib_list[i] != EGL_NONE; i += 2) {
      EGLint attrib = attrib_list[i];
      EGLint value = attrib_list[i + 1];

      /* EGL_EXT_platform_x11 recognizes exactly one attribute,
       * EGL_PLATFORM_X11_SCREEN_EXT, which is optional.
       * 
       * Mesa supports connecting to only the default screen, so we reject
       * screen != 0.
       */
      if (attrib != EGL_PLATFORM_X11_SCREEN_EXT || value != 0) {
         _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
         return EGL_FALSE;
      }
   }

   return EGL_TRUE;
}

_EGLDisplay*
_eglGetX11Display(Display *native_display,
                  const EGLint *attrib_list)
{
   if (!_eglParseX11DisplayAttribList(attrib_list)) {
      return NULL;
   }

   return _eglFindDisplay(_EGL_PLATFORM_X11, native_display);
}
#endif /* HAVE_X11_PLATFORM */

#ifdef HAVE_DRM_PLATFORM
_EGLDisplay*
_eglGetGbmDisplay(struct gbm_device *native_display,
                  const EGLint *attrib_list)
{
   /* EGL_MESA_platform_gbm recognizes no attributes. */
   if (attrib_list != NULL && attrib_list[0] != EGL_NONE) {
      _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
      return NULL;
   }

   return _eglFindDisplay(_EGL_PLATFORM_DRM, native_display);
}
#endif /* HAVE_DRM_PLATFORM */

#ifdef HAVE_WAYLAND_PLATFORM
_EGLDisplay*
_eglGetWaylandDisplay(struct wl_display *native_display,
                      const EGLint *attrib_list)
{
   /* EGL_EXT_platform_wayland recognizes no attributes. */
   if (attrib_list != NULL && attrib_list[0] != EGL_NONE) {
      _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
      return NULL;
   }

   return _eglFindDisplay(_EGL_PLATFORM_WAYLAND, native_display);
}
#endif /* HAVE_WAYLAND_PLATFORM */
@


