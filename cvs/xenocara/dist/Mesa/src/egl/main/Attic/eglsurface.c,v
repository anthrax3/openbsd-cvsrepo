head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.25;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2014.07.09.21.08.51;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.13.59.25;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.10;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.25;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.40;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008 VMware, Inc.
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright 2010 LunarG, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


/**
 * Surface-related functions.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "egldisplay.h"
#include "egldriver.h"
#include "eglcontext.h"
#include "eglconfig.h"
#include "eglcurrent.h"
#include "egllog.h"
#include "eglsurface.h"


static void
_eglClampSwapInterval(_EGLSurface *surf, EGLint interval)
{
   EGLint bound = surf->Config->MaxSwapInterval;
   if (interval >= bound) {
      interval = bound;
   }
   else {
      bound = surf->Config->MinSwapInterval;
      if (interval < bound)
         interval = bound;
   }
   surf->SwapInterval = interval;
}


#ifdef EGL_MESA_screen_surface
static EGLint
_eglParseScreenSurfaceAttribList(_EGLSurface *surf, const EGLint *attrib_list)
{
   EGLint i, err = EGL_SUCCESS;

   if (!attrib_list)
      return EGL_SUCCESS;

   for (i = 0; attrib_list[i] != EGL_NONE; i++) {
      EGLint attr = attrib_list[i++];
      EGLint val = attrib_list[i];

      switch (attr) {
      case EGL_WIDTH:
         if (val < 0) {
            err = EGL_BAD_PARAMETER;
            break;
         }
         surf->Width = val;
         break;
      case EGL_HEIGHT:
         if (val < 0) {
            err = EGL_BAD_PARAMETER;
            break;
         }
         surf->Height = val;
         break;
      default:
         err = EGL_BAD_ATTRIBUTE;
         break;
      }

      if (err != EGL_SUCCESS) {
         _eglLog(_EGL_WARNING, "bad surface attribute 0x%04x", attr);
         break;
      }
   }

   return err;
}
#endif /* EGL_MESA_screen_surface */


/**
 * Parse the list of surface attributes and return the proper error code.
 */
static EGLint
_eglParseSurfaceAttribList(_EGLSurface *surf, const EGLint *attrib_list)
{
   _EGLDisplay *dpy = surf->Resource.Display;
   EGLint type = surf->Type;
   EGLint texture_type = EGL_PBUFFER_BIT;
   EGLint i, err = EGL_SUCCESS;

   if (!attrib_list)
      return EGL_SUCCESS;

#ifdef EGL_MESA_screen_surface
   if (type == EGL_SCREEN_BIT_MESA)
      return _eglParseScreenSurfaceAttribList(surf, attrib_list);
#endif

   if (dpy->Extensions.NOK_texture_from_pixmap)
      texture_type |= EGL_PIXMAP_BIT;

   for (i = 0; attrib_list[i] != EGL_NONE; i++) {
      EGLint attr = attrib_list[i++];
      EGLint val = attrib_list[i];

      switch (attr) {
      /* common attributes */
      case EGL_VG_COLORSPACE:
         switch (val) {
         case EGL_VG_COLORSPACE_sRGB:
         case EGL_VG_COLORSPACE_LINEAR:
            break;
         default:
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (err != EGL_SUCCESS)
            break;
         surf->VGColorspace = val;
         break;
      case EGL_VG_ALPHA_FORMAT:
         switch (val) {
         case EGL_VG_ALPHA_FORMAT_NONPRE:
         case EGL_VG_ALPHA_FORMAT_PRE:
            break;
         default:
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (err != EGL_SUCCESS)
            break;
         surf->VGAlphaFormat = val;
         break;
      /* window surface attributes */
      case EGL_RENDER_BUFFER:
         if (type != EGL_WINDOW_BIT) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (val != EGL_BACK_BUFFER && val != EGL_SINGLE_BUFFER) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         surf->RenderBuffer = val;
         break;
      case EGL_POST_SUB_BUFFER_SUPPORTED_NV:
         if (!dpy->Extensions.NV_post_sub_buffer ||
             type != EGL_WINDOW_BIT) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (val != EGL_TRUE && val != EGL_FALSE) {
            err = EGL_BAD_PARAMETER;
            break;
         }
         surf->PostSubBufferSupportedNV = val;
         break;
      /* pbuffer surface attributes */
      case EGL_WIDTH:
         if (type != EGL_PBUFFER_BIT) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (val < 0) {
            err = EGL_BAD_PARAMETER;
            break;
         }
         surf->Width = val;
         break;
      case EGL_HEIGHT:
         if (type != EGL_PBUFFER_BIT) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (val < 0) {
            err = EGL_BAD_PARAMETER;
            break;
         }
         surf->Height = val;
         break;
      case EGL_LARGEST_PBUFFER:
         if (type != EGL_PBUFFER_BIT) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         surf->LargestPbuffer = !!val;
         break;
      /* for eglBindTexImage */
      case EGL_TEXTURE_FORMAT:
         if (!(type & texture_type)) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         switch (val) {
         case EGL_TEXTURE_RGB:
         case EGL_TEXTURE_RGBA:
         case EGL_NO_TEXTURE:
            break;
         default:
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (err != EGL_SUCCESS)
            break;
         surf->TextureFormat = val;
         break;
      case EGL_TEXTURE_TARGET:
         if (!(type & texture_type)) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         switch (val) {
         case EGL_TEXTURE_2D:
         case EGL_NO_TEXTURE:
            break;
         default:
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (err != EGL_SUCCESS)
            break;
         surf->TextureTarget = val;
         break;
      case EGL_MIPMAP_TEXTURE:
         if (!(type & texture_type)) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         surf->MipmapTexture = !!val;
         break;
      /* no pixmap surface specific attributes */
      default:
         err = EGL_BAD_ATTRIBUTE;
         break;
      }

      if (err != EGL_SUCCESS) {
         _eglLog(_EGL_WARNING, "bad surface attribute 0x%04x", attr);
         break;
      }
   }

   return err;
}


/**
 * Do error check on parameters and initialize the given _EGLSurface object.
 * \return EGL_TRUE if no errors, EGL_FALSE otherwise.
 */
EGLBoolean
_eglInitSurface(_EGLSurface *surf, _EGLDisplay *dpy, EGLint type,
                _EGLConfig *conf, const EGLint *attrib_list)
{
   const char *func;
   EGLint renderBuffer = EGL_BACK_BUFFER;
   EGLint swapBehavior = EGL_BUFFER_PRESERVED;
   EGLint err;

   switch (type) {
   case EGL_WINDOW_BIT:
      func = "eglCreateWindowSurface";
      swapBehavior = EGL_BUFFER_DESTROYED;
      break;
   case EGL_PIXMAP_BIT:
      func = "eglCreatePixmapSurface";
      renderBuffer = EGL_SINGLE_BUFFER;
      break;
   case EGL_PBUFFER_BIT:
      func = "eglCreatePBufferSurface";
      break;
#ifdef EGL_MESA_screen_surface
   case EGL_SCREEN_BIT_MESA:
      func = "eglCreateScreenSurface";
      renderBuffer = EGL_SINGLE_BUFFER; /* XXX correct? */
      break;
#endif
   default:
      _eglLog(_EGL_WARNING, "Bad type in _eglInitSurface");
      return EGL_FALSE;
   }

   if ((conf->SurfaceType & type) == 0) {
      /* The config can't be used to create a surface of this type */
      _eglError(EGL_BAD_CONFIG, func);
      return EGL_FALSE;
   }

   _eglInitResource(&surf->Resource, sizeof(*surf), dpy);
   surf->Type = type;
   surf->Config = conf;

   surf->Width = 0;
   surf->Height = 0;
   surf->TextureFormat = EGL_NO_TEXTURE;
   surf->TextureTarget = EGL_NO_TEXTURE;
   surf->MipmapTexture = EGL_FALSE;
   surf->LargestPbuffer = EGL_FALSE;
   surf->RenderBuffer = renderBuffer;
   surf->VGAlphaFormat = EGL_VG_ALPHA_FORMAT_NONPRE;
   surf->VGColorspace = EGL_VG_COLORSPACE_sRGB;

   surf->MipmapLevel = 0;
   surf->MultisampleResolve = EGL_MULTISAMPLE_RESOLVE_DEFAULT;
   surf->SwapBehavior = swapBehavior;

   surf->HorizontalResolution = EGL_UNKNOWN;
   surf->VerticalResolution = EGL_UNKNOWN;
   surf->AspectRatio = EGL_UNKNOWN;

   surf->PostSubBufferSupportedNV = EGL_FALSE;

   /* the default swap interval is 1 */
   _eglClampSwapInterval(surf, 1);

   err = _eglParseSurfaceAttribList(surf, attrib_list);
   if (err != EGL_SUCCESS)
      return _eglError(err, func);

   return EGL_TRUE;
}


EGLBoolean
_eglQuerySurface(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surface,
                 EGLint attribute, EGLint *value)
{
   switch (attribute) {
   case EGL_WIDTH:
      *value = surface->Width;
      break;
   case EGL_HEIGHT:
      *value = surface->Height;
      break;
   case EGL_CONFIG_ID:
      *value = surface->Config->ConfigID;
      break;
   case EGL_LARGEST_PBUFFER:
      *value = surface->LargestPbuffer;
      break;
   case EGL_TEXTURE_FORMAT:
      /* texture attributes: only for pbuffers, no error otherwise */
      if (surface->Type == EGL_PBUFFER_BIT)
         *value = surface->TextureFormat;
      break;
   case EGL_TEXTURE_TARGET:
      if (surface->Type == EGL_PBUFFER_BIT)
         *value = surface->TextureTarget;
      break;
   case EGL_MIPMAP_TEXTURE:
      if (surface->Type == EGL_PBUFFER_BIT)
         *value = surface->MipmapTexture;
      break;
   case EGL_MIPMAP_LEVEL:
      if (surface->Type == EGL_PBUFFER_BIT)
         *value = surface->MipmapLevel;
      break;
   case EGL_SWAP_BEHAVIOR:
      *value = surface->SwapBehavior;
      break;
   case EGL_RENDER_BUFFER:
      *value = surface->RenderBuffer;
      break;
   case EGL_PIXEL_ASPECT_RATIO:
      *value = surface->AspectRatio;
      break;
   case EGL_HORIZONTAL_RESOLUTION:
      *value = surface->HorizontalResolution;
      break;
   case EGL_VERTICAL_RESOLUTION:
      *value = surface->VerticalResolution;
      break;
   case EGL_MULTISAMPLE_RESOLVE:
      *value = surface->MultisampleResolve;
      break;
   case EGL_VG_ALPHA_FORMAT:
      *value = surface->VGAlphaFormat;
      break;
   case EGL_VG_COLORSPACE:
      *value = surface->VGColorspace;
      break;
   case EGL_POST_SUB_BUFFER_SUPPORTED_NV:
      *value = surface->PostSubBufferSupportedNV;
      break;
   case EGL_BUFFER_AGE_EXT:
      if (!dpy->Extensions.EXT_buffer_age) {
         _eglError(EGL_BAD_ATTRIBUTE, "eglQuerySurface");
         return EGL_FALSE;
      }
      *value = drv->API.QueryBufferAge(drv, dpy, surface);
      break;
   default:
      _eglError(EGL_BAD_ATTRIBUTE, "eglQuerySurface");
      return EGL_FALSE;
   }

   return EGL_TRUE;
}


/**
 * Default fallback routine - drivers might override this.
 */
EGLBoolean
_eglSurfaceAttrib(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surface,
                  EGLint attribute, EGLint value)
{
   EGLint confval;
   EGLint err = EGL_SUCCESS;
   EGLint all_es_bits = EGL_OPENGL_ES_BIT |
                        EGL_OPENGL_ES2_BIT |
                        EGL_OPENGL_ES3_BIT_KHR;

   switch (attribute) {
   case EGL_MIPMAP_LEVEL:
      confval = surface->Config->RenderableType;
      if (!(confval & all_es_bits)) {
         err = EGL_BAD_PARAMETER;
         break;
      }
      surface->MipmapLevel = value;
      break;
   case EGL_MULTISAMPLE_RESOLVE:
      switch (value) {
      case EGL_MULTISAMPLE_RESOLVE_DEFAULT:
         break;
      case EGL_MULTISAMPLE_RESOLVE_BOX:
         confval = surface->Config->SurfaceType;
         if (!(confval & EGL_MULTISAMPLE_RESOLVE_BOX_BIT))
            err = EGL_BAD_MATCH;
         break;
      default:
         err = EGL_BAD_ATTRIBUTE;
         break;
      }
      if (err != EGL_SUCCESS)
         break;
      surface->MultisampleResolve = value;
      break;
   case EGL_SWAP_BEHAVIOR:
      switch (value) {
      case EGL_BUFFER_DESTROYED:
         break;
      case EGL_BUFFER_PRESERVED:
         confval = surface->Config->SurfaceType;
         if (!(confval & EGL_SWAP_BEHAVIOR_PRESERVED_BIT))
            err = EGL_BAD_MATCH;
         break;
      default:
         err = EGL_BAD_ATTRIBUTE;
         break;
      }
      if (err != EGL_SUCCESS)
         break;
      surface->SwapBehavior = value;
      break;
   default:
      err = EGL_BAD_ATTRIBUTE;
      break;
   }

   if (err != EGL_SUCCESS)
      return _eglError(err, "eglSurfaceAttrib");
   return EGL_TRUE;
}


EGLBoolean
_eglBindTexImage(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surface,
                 EGLint buffer)
{
   EGLint texture_type = EGL_PBUFFER_BIT;

   /* Just do basic error checking and return success/fail.
    * Drivers must implement the real stuff.
    */

   if (dpy->Extensions.NOK_texture_from_pixmap)
      texture_type |= EGL_PIXMAP_BIT;

   if (!(surface->Type & texture_type)) {
      _eglError(EGL_BAD_SURFACE, "eglBindTexImage");
      return EGL_FALSE;
   }

   if (surface->TextureFormat == EGL_NO_TEXTURE) {
      _eglError(EGL_BAD_MATCH, "eglBindTexImage");
      return EGL_FALSE;
   }

   if (surface->TextureTarget == EGL_NO_TEXTURE) {
      _eglError(EGL_BAD_MATCH, "eglBindTexImage");
      return EGL_FALSE;
   }

   if (buffer != EGL_BACK_BUFFER) {
      _eglError(EGL_BAD_PARAMETER, "eglBindTexImage");
      return EGL_FALSE;
   }

   surface->BoundToTexture = EGL_TRUE;

   return EGL_TRUE;
}

EGLBoolean
_eglReleaseTexImage(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf,
                    EGLint buffer)
{
   /* TODO: do basic error checking and return success/fail.
    * Drivers must implement the real stuff.
    */

  return EGL_TRUE;
}


EGLBoolean
_eglSwapInterval(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf,
                 EGLint interval)
{
   _eglClampSwapInterval(surf, interval);
   return EGL_TRUE;
}
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.5
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d532 11
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d40 1
d174 12
d285 1
d291 1
d333 1
a333 1
   surf->SwapBehavior = EGL_BUFFER_DESTROYED;
d339 2
d410 10
d438 3
d445 1
a445 1
      if (!(confval & (EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT))) {
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d1 30
@


1.2
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d20 1
a20 1
   EGLint bound = GET_CONFIG_ATTRIB(surf->Config, EGL_MAX_SWAP_INTERVAL);
d25 1
a25 1
      bound = GET_CONFIG_ATTRIB(surf->Config, EGL_MIN_SWAP_INTERVAL);
d33 44
d83 1
d85 1
d91 8
d104 1
a104 1
      /* common (except for screen surfaces) attributes */
a105 4
         if (type == EGL_SCREEN_BIT_MESA) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
a118 4
         if (type == EGL_SCREEN_BIT_MESA) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
d145 1
a145 1
         if (type != EGL_PBUFFER_BIT && type != EGL_SCREEN_BIT_MESA) {
d156 1
a156 1
         if (type != EGL_PBUFFER_BIT && type != EGL_SCREEN_BIT_MESA) {
d173 1
d175 1
a175 1
         if (type != EGL_PBUFFER_BIT) {
d193 1
a193 1
         if (type != EGL_PBUFFER_BIT) {
d210 1
a210 1
         if (type != EGL_PBUFFER_BIT) {
d255 1
d260 1
d266 1
a266 1
   if ((GET_CONFIG_ATTRIB(conf, EGL_SURFACE_TYPE) & type) == 0) {
d272 1
a272 2
   memset(surf, 0, sizeof(_EGLSurface));
   surf->Resource.Display = dpy;
a305 18
_eglSwapBuffers(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf)
{
   /* Drivers have to do the actual buffer swap.  */
   return EGL_TRUE;
}


EGLBoolean
_eglCopyBuffers(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf,
                EGLNativePixmapType target)
{
   /* copy surface to native pixmap */
   /* All implementation burdon for this is in the device driver */
   return EGL_FALSE;
}


EGLBoolean
d317 1
a317 1
      *value = GET_CONFIG_ATTRIB(surface->Config, EGL_CONFIG_ID);
a372 45
 * Drivers should do a proper implementation.
 */
_EGLSurface *
_eglCreateWindowSurface(_EGLDriver *drv, _EGLDisplay *dpy, _EGLConfig *conf,
                        EGLNativeWindowType window, const EGLint *attrib_list)
{
   return NULL;
}


/**
 * Drivers should do a proper implementation.
 */
_EGLSurface *
_eglCreatePixmapSurface(_EGLDriver *drv, _EGLDisplay *dpy, _EGLConfig *conf,
                        EGLNativePixmapType pixmap, const EGLint *attrib_list)
{
   return NULL;
}


/**
 * Drivers should do a proper implementation.
 */
_EGLSurface *
_eglCreatePbufferSurface(_EGLDriver *drv, _EGLDisplay *dpy, _EGLConfig *conf,
                         const EGLint *attrib_list)
{
   return NULL;
}


/**
 * Default fallback routine - drivers should usually override this.
 */
EGLBoolean
_eglDestroySurface(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf)
{
   if (!_eglIsSurfaceBound(surf))
      free(surf);
   return EGL_TRUE;
}


/**
d384 1
a384 1
      confval = GET_CONFIG_ATTRIB(surface->Config, EGL_RENDERABLE_TYPE);
d396 1
a396 1
         confval = GET_CONFIG_ATTRIB(surface->Config, EGL_SURFACE_TYPE);
d413 1
a413 1
         confval = GET_CONFIG_ATTRIB(surface->Config, EGL_SURFACE_TYPE);
d440 2
d446 4
a449 1
   if (surface->Type != EGL_PBUFFER_BIT) {
d459 1
a459 25
   if (buffer != EGL_BACK_BUFFER) {
      _eglError(EGL_BAD_PARAMETER, "eglBindTexImage");
      return EGL_FALSE;
   }

   surface->BoundToTexture = EGL_TRUE;

   return EGL_TRUE;
}


EGLBoolean
_eglReleaseTexImage(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surface,
                    EGLint buffer)
{
   /* Just do basic error checking and return success/fail.
    * Drivers must implement the real stuff.
    */

   if (surface->Type != EGL_PBUFFER_BIT) {
      _eglError(EGL_BAD_SURFACE, "eglBindTexImage");
      return EGL_FALSE;
   }

   if (surface->TextureFormat == EGL_NO_TEXTURE) {
d465 1
a465 1
      _eglError(EGL_BAD_PARAMETER, "eglReleaseTexImage");
d469 1
a469 6
   if (!surface->BoundToTexture) {
      _eglError(EGL_BAD_SURFACE, "eglReleaseTexImage");
      return EGL_FALSE;
   }

   surface->BoundToTexture = EGL_FALSE;
a481 21


#ifdef EGL_VERSION_1_2

/**
 * Example function - drivers should do a proper implementation.
 */
_EGLSurface *
_eglCreatePbufferFromClientBuffer(_EGLDriver *drv, _EGLDisplay *dpy,
                                  EGLenum buftype, EGLClientBuffer buffer,
                                  _EGLConfig *conf, const EGLint *attrib_list)
{
   if (buftype != EGL_OPENVG_IMAGE) {
      _eglError(EGL_BAD_PARAMETER, "eglCreatePbufferFromClientBuffer");
      return NULL;
   }

   return NULL;
}

#endif /* EGL_VERSION_1_2 */
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d9 1
d12 1
a12 2
#include "eglglobals.h"
#include "eglhash.h"
d17 168
d190 2
a191 3
_eglInitSurface(_EGLDriver *drv, EGLDisplay dpy,
                _EGLSurface *surf, EGLint type, EGLConfig config,
                const EGLint *attrib_list)
a193 3
   _EGLConfig *conf;
   EGLint width = 0, height = 0, largest = 0;
   EGLint texFormat = 0, texTarget = 0, mipmapTex = 0;
d195 1
a195 5
#ifdef EGL_VERSION_1_2
   EGLint colorspace = EGL_COLORSPACE_sRGB;
   EGLint alphaFormat = EGL_ALPHA_FORMAT_NONPRE;
#endif
   EGLint i;
d217 2
a218 2
   conf = _eglLookupConfig(drv, dpy, config);
   if (!conf) {
a222 120
   /*
    * Parse attribute list.  Different kinds of surfaces support different
    * attributes.
    */
   for (i = 0; attrib_list && attrib_list[i] != EGL_NONE; i++) {
      switch (attrib_list[i]) {
      case EGL_WIDTH:
         if (type == EGL_PBUFFER_BIT || type == EGL_SCREEN_BIT_MESA) {
            width = attrib_list[++i];
         }
         else {
            _eglError(EGL_BAD_ATTRIBUTE, func);
            return EGL_FALSE;
         }
         break;
      case EGL_HEIGHT:
         if (type == EGL_PBUFFER_BIT || type == EGL_SCREEN_BIT_MESA) {
            height = attrib_list[++i];
         }
         else {
            _eglError(EGL_BAD_ATTRIBUTE, func);
            return EGL_FALSE;
         }
         break;
      case EGL_LARGEST_PBUFFER:
         if (type == EGL_PBUFFER_BIT) {
            largest = attrib_list[++i];
         }
         else {
            _eglError(EGL_BAD_ATTRIBUTE, func);
            return EGL_FALSE;
         }
         break;
      case EGL_TEXTURE_FORMAT:
         if (type == EGL_PBUFFER_BIT) {
            texFormat = attrib_list[++i];
         }
         else {
            _eglError(EGL_BAD_ATTRIBUTE, func);
            return EGL_FALSE;
         }
         break;
      case EGL_TEXTURE_TARGET:
         if (type == EGL_PBUFFER_BIT) {
            texTarget = attrib_list[++i];
         }
         else {
            _eglError(EGL_BAD_ATTRIBUTE, func);
            return EGL_FALSE;
         }
         break;
      case EGL_MIPMAP_TEXTURE:
         if (type == EGL_PBUFFER_BIT) {
            mipmapTex = attrib_list[++i];
         }
         else {
            _eglError(EGL_BAD_ATTRIBUTE, func);
            return EGL_FALSE;
         }
         break;
#ifdef EGL_VERSION_1_2
      case EGL_RENDER_BUFFER:
         if (type == EGL_WINDOW_BIT) {
            renderBuffer = attrib_list[++i];
            if (renderBuffer != EGL_BACK_BUFFER &&
                renderBuffer != EGL_SINGLE_BUFFER) {
               _eglError(EGL_BAD_ATTRIBUTE, func);
               return EGL_FALSE;
            }
         }
         else {
            _eglError(EGL_BAD_ATTRIBUTE, func);
            return EGL_FALSE;
         }
         break;
      case EGL_COLORSPACE:
         if (type == EGL_WINDOW_BIT ||
             type == EGL_PBUFFER_BIT ||
             type == EGL_PIXMAP_BIT) {
            colorspace = attrib_list[++i];
            if (colorspace != EGL_COLORSPACE_sRGB &&
                colorspace != EGL_COLORSPACE_LINEAR) {
               _eglError(EGL_BAD_ATTRIBUTE, func);
               return EGL_FALSE;
            }
         }
         else {
            _eglError(EGL_BAD_ATTRIBUTE, func);
            return EGL_FALSE;
         }
         break;
      case EGL_ALPHA_FORMAT:
         if (type == EGL_WINDOW_BIT ||
             type == EGL_PBUFFER_BIT ||
             type == EGL_PIXMAP_BIT) {
            alphaFormat = attrib_list[++i];
            if (alphaFormat != EGL_ALPHA_FORMAT_NONPRE &&
                alphaFormat != EGL_ALPHA_FORMAT_PRE) {
               _eglError(EGL_BAD_ATTRIBUTE, func);
               return EGL_FALSE;
            }
         }
         else {
            _eglError(EGL_BAD_ATTRIBUTE, func);
            return EGL_FALSE;
         }
         break;

#endif /* EGL_VERSION_1_2 */
      default:
         _eglError(EGL_BAD_ATTRIBUTE, func);
         return EGL_FALSE;
      }
   }

   if (width <= 0 || height <= 0) {
      _eglError(EGL_BAD_ATTRIBUTE, func);
      return EGL_FALSE;
   }

d224 2
d227 7
a233 13
   surf->Type = type;
   surf->Width = width;
   surf->Height = height;
   surf->TextureFormat = texFormat;
   surf->TextureTarget = texTarget;
   surf->MipmapTexture = mipmapTex;
   surf->MipmapLevel = 0;
   surf->SwapInterval = 0;
#ifdef EGL_VERSION_1_2
   surf->SwapBehavior = EGL_BUFFER_DESTROYED; /* XXX ok? */
   surf->HorizontalResolution = EGL_UNKNOWN; /* set by caller */
   surf->VerticalResolution = EGL_UNKNOWN; /* set by caller */
   surf->AspectRatio = EGL_UNKNOWN; /* set by caller */
d235 2
a236 3
   surf->AlphaFormat = alphaFormat;
   surf->Colorspace = colorspace;
#endif
d238 3
a240 2
   return EGL_TRUE;
}
d242 10
d253 1
a253 41
void
_eglSaveSurface(_EGLSurface *surf)
{
   assert(surf);
   assert(!surf->Handle);
   surf->Handle = _eglHashGenKey(_eglGlobal.Contexts);
   assert(surf->Handle);
   _eglHashInsert(_eglGlobal.Surfaces, surf->Handle, surf);
}


void
_eglRemoveSurface(_EGLSurface *surf)
{
   _eglHashRemove(_eglGlobal.Surfaces, surf->Handle);
}


_EGLSurface *
_eglLookupSurface(EGLSurface surf)
{
   _EGLSurface *c = (_EGLSurface *) _eglHashLookup(_eglGlobal.Surfaces, surf);
   return c;
}


_EGLSurface *
_eglGetCurrentSurface(EGLint readdraw)
{
   _EGLContext *ctx = _eglGetCurrentContext();
   if (ctx) {
      switch (readdraw) {
      case EGL_DRAW:
         return ctx->DrawSurface;
      case EGL_READ:
         return ctx->ReadSurface;
      default:
         return NULL;
      }
   }
   return NULL;
d258 1
a258 1
_eglSwapBuffers(_EGLDriver *drv, EGLDisplay dpy, EGLSurface draw)
d260 1
a260 13
   /* Basically just do error checking here.  Drivers have to do the
    * actual buffer swap.
    */
   _EGLContext *context = _eglGetCurrentContext();
   _EGLSurface *surface = _eglLookupSurface(draw);
   if (context && context->DrawSurface != surface) {
      _eglError(EGL_BAD_SURFACE, "eglSwapBuffers");
      return EGL_FALSE;
   }
   if (surface == NULL) {
      _eglError(EGL_BAD_SURFACE, "eglSwapBuffers");
      return EGL_FALSE;
   }
d266 2
a267 2
_eglCopyBuffers(_EGLDriver *drv, EGLDisplay dpy, EGLSurface surface,
                NativePixmapType target)
d276 1
a276 1
_eglQuerySurface(_EGLDriver *drv, EGLDisplay dpy, EGLSurface surf,
a278 5
   _EGLSurface *surface = _eglLookupSurface(surf);
   if (surface == NULL) {
      _eglError(EGL_BAD_SURFACE, "eglQuerySurface");
      return EGL_FALSE;
   }
d282 1
a282 1
      return EGL_TRUE;
d285 1
a285 1
      return EGL_TRUE;
d288 4
a291 6
      return EGL_TRUE;
   /*XXX case EGL_LARGEST_PBUFFER:*/
   case EGL_SURFACE_TYPE:
      *value = surface->Type;
      return EGL_TRUE;
#ifdef EGL_VERSION_1_1
d296 1
a296 1
      return EGL_TRUE;
d300 1
a300 1
      return EGL_TRUE;
d304 1
a304 1
      return EGL_TRUE;
d308 1
a308 3
      return EGL_TRUE;
#endif /* EGL_VERSION_1_1 */
#ifdef EGL_VERSION_1_2
d311 1
a311 1
      return EGL_TRUE;
d314 1
a314 1
      return EGL_TRUE;
d317 1
a317 1
      return EGL_TRUE;
d320 1
a320 1
      return EGL_TRUE;
d323 10
a332 8
      return EGL_TRUE;
   case EGL_ALPHA_FORMAT:
      *value = surface->AlphaFormat;
      return EGL_TRUE;
   case EGL_COLORSPACE:
      *value = surface->Colorspace;
      return EGL_TRUE;
#endif /* EGL_VERSION_1_2 */
d337 2
d343 1
a343 1
 * Example function - drivers should do a proper implementation.
d345 5
a349 21
EGLSurface
_eglCreateWindowSurface(_EGLDriver *drv, EGLDisplay dpy, EGLConfig config,
                        NativeWindowType window, const EGLint *attrib_list)
{
#if 0 /* THIS IS JUST EXAMPLE CODE */
   _EGLSurface *surf;

   surf = (_EGLSurface *) calloc(1, sizeof(_EGLSurface));
   if (!surf)
      return EGL_NO_SURFACE;

   if (!_eglInitSurface(drv, dpy, surf, EGL_WINDOW_BIT, config, attrib_list)) {
      free(surf);
      return EGL_NO_SURFACE;
   }

   _eglSaveSurface(surf);

   return surf->Handle;
#endif
   return EGL_NO_SURFACE;
d354 1
a354 1
 * Example function - drivers should do a proper implementation.
d356 5
a360 21
EGLSurface
_eglCreatePixmapSurface(_EGLDriver *drv, EGLDisplay dpy, EGLConfig config,
                        NativePixmapType pixmap, const EGLint *attrib_list)
{
#if 0 /* THIS IS JUST EXAMPLE CODE */
   _EGLSurface *surf;

   surf = (_EGLSurface *) calloc(1, sizeof(_EGLSurface));
   if (!surf)
      return EGL_NO_SURFACE;

   if (!_eglInitSurface(drv, dpy, surf, EGL_PIXMAP_BIT, config, attrib_list)) {
      free(surf);
      return EGL_NO_SURFACE;
   }

   _eglSaveSurface(surf);

   return surf->Handle;
#endif
   return EGL_NO_SURFACE;
d365 1
a365 1
 * Example function - drivers should do a proper implementation.
d367 2
a368 2
EGLSurface
_eglCreatePbufferSurface(_EGLDriver *drv, EGLDisplay dpy, EGLConfig config,
d371 1
a371 17
#if 0 /* THIS IS JUST EXAMPLE CODE */
   _EGLSurface *surf;

   surf = (_EGLSurface *) calloc(1, sizeof(_EGLSurface));
   if (!surf)
      return EGL_NO_SURFACE;

   if (!_eglInitSurface(drv, dpy, surf, EGL_PBUFFER_BIT, config, attrib_list)) {
      free(surf);
      return EGL_NO_SURFACE;
   }

   _eglSaveSurface(surf);

   return surf->Handle;
#endif
   return EGL_NO_SURFACE;
d379 1
a379 1
_eglDestroySurface(_EGLDriver *drv, EGLDisplay dpy, EGLSurface surface)
d381 3
a383 15
   _EGLSurface *surf = _eglLookupSurface(surface);
   if (surf) {
      _eglHashRemove(_eglGlobal.Surfaces, surface);
      if (surf->IsBound) {
         surf->DeletePending = EGL_TRUE;
      }
      else {
         free(surf);
      }
      return EGL_TRUE;
   }
   else {
      _eglError(EGL_BAD_SURFACE, "eglDestroySurface");
      return EGL_FALSE;
   }
d391 2
a392 1
_eglSurfaceAttrib(_EGLDriver *drv, EGLDisplay dpy, EGLSurface surf, EGLint attribute, EGLint value)
d394 2
a395 6
   _EGLSurface *surface = _eglLookupSurface(surf);

   if (surface == NULL) {
      _eglError(EGL_BAD_SURFACE, "eglSurfaceAttrib");
      return EGL_FALSE;
   }
d399 5
d406 34
d441 2
a442 2
      _eglError(EGL_BAD_ATTRIBUTE, "eglSurfaceAttrib");
      return EGL_FALSE;
d444 3
d452 2
a453 1
_eglBindTexImage(_EGLDriver *drv, EGLDisplay dpy, EGLSurface surface, EGLint buffer)
d455 22
a476 2
   /* XXX unfinished */
   return EGL_FALSE;
d481 2
a482 1
_eglReleaseTexImage(_EGLDriver *drv, EGLDisplay dpy, EGLSurface surface, EGLint buffer)
d484 27
a510 2
   /* XXX unfinished */
   return EGL_FALSE;
d515 2
a516 1
_eglSwapInterval(_EGLDriver *drv, EGLDisplay dpy, EGLint interval)
d518 1
a518 6
   _EGLSurface *surf = _eglGetCurrentSurface(EGL_DRAW);
   if (surf == NULL) {
      _eglError(EGL_BAD_SURFACE, "eglSwapInterval");
      return EGL_FALSE;
   }
   surf->SwapInterval = interval;
d528 2
a529 2
EGLSurface
_eglCreatePbufferFromClientBuffer(_EGLDriver *drv, EGLDisplay dpy,
d531 1
a531 1
                                  EGLConfig config, const EGLint *attrib_list)
d535 1
a535 1
      return EGL_NO_SURFACE;
d538 1
a538 1
   return EGL_NO_SURFACE;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a8 1
#include "egldisplay.h"
d11 2
a12 1
#include "eglcurrent.h"
a16 60
static void
_eglClampSwapInterval(_EGLSurface *surf, EGLint interval)
{
   EGLint bound = surf->Config->MaxSwapInterval;
   if (interval >= bound) {
      interval = bound;
   }
   else {
      bound = surf->Config->MinSwapInterval;
      if (interval < bound)
         interval = bound;
   }
   surf->SwapInterval = interval;
}


#ifdef EGL_MESA_screen_surface
static EGLint
_eglParseScreenSurfaceAttribList(_EGLSurface *surf, const EGLint *attrib_list)
{
   EGLint i, err = EGL_SUCCESS;

   if (!attrib_list)
      return EGL_SUCCESS;

   for (i = 0; attrib_list[i] != EGL_NONE; i++) {
      EGLint attr = attrib_list[i++];
      EGLint val = attrib_list[i];

      switch (attr) {
      case EGL_WIDTH:
         if (val < 0) {
            err = EGL_BAD_PARAMETER;
            break;
         }
         surf->Width = val;
         break;
      case EGL_HEIGHT:
         if (val < 0) {
            err = EGL_BAD_PARAMETER;
            break;
         }
         surf->Height = val;
         break;
      default:
         err = EGL_BAD_ATTRIBUTE;
         break;
      }

      if (err != EGL_SUCCESS) {
         _eglLog(_EGL_WARNING, "bad surface attribute 0x%04x", attr);
         break;
      }
   }

   return err;
}
#endif /* EGL_MESA_screen_surface */


d18 2
a19 1
 * Parse the list of surface attributes and return the proper error code.
d21 4
a24 2
static EGLint
_eglParseSurfaceAttribList(_EGLSurface *surf, const EGLint *attrib_list)
d26 8
a33 11
   _EGLDisplay *dpy = surf->Resource.Display;
   EGLint type = surf->Type;
   EGLint texture_type = EGL_PBUFFER_BIT;
   EGLint i, err = EGL_SUCCESS;

   if (!attrib_list)
      return EGL_SUCCESS;

#ifdef EGL_MESA_screen_surface
   if (type == EGL_SCREEN_BIT_MESA)
      return _eglParseScreenSurfaceAttribList(surf, attrib_list);
d35 21
d57 5
a61 2
   if (dpy->Extensions.NOK_texture_from_pixmap)
      texture_type |= EGL_PIXMAP_BIT;
d63 9
a71 41
   for (i = 0; attrib_list[i] != EGL_NONE; i++) {
      EGLint attr = attrib_list[i++];
      EGLint val = attrib_list[i];

      switch (attr) {
      /* common attributes */
      case EGL_VG_COLORSPACE:
         switch (val) {
         case EGL_VG_COLORSPACE_sRGB:
         case EGL_VG_COLORSPACE_LINEAR:
            break;
         default:
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (err != EGL_SUCCESS)
            break;
         surf->VGColorspace = val;
         break;
      case EGL_VG_ALPHA_FORMAT:
         switch (val) {
         case EGL_VG_ALPHA_FORMAT_NONPRE:
         case EGL_VG_ALPHA_FORMAT_PRE:
            break;
         default:
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (err != EGL_SUCCESS)
            break;
         surf->VGAlphaFormat = val;
         break;
      /* window surface attributes */
      case EGL_RENDER_BUFFER:
         if (type != EGL_WINDOW_BIT) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (val != EGL_BACK_BUFFER && val != EGL_SINGLE_BUFFER) {
            err = EGL_BAD_ATTRIBUTE;
            break;
d73 3
a75 11
         surf->RenderBuffer = val;
         break;
      /* pbuffer surface attributes */
      case EGL_WIDTH:
         if (type != EGL_PBUFFER_BIT) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (val < 0) {
            err = EGL_BAD_PARAMETER;
            break;
a76 1
         surf->Width = val;
d79 6
a84 7
         if (type != EGL_PBUFFER_BIT) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (val < 0) {
            err = EGL_BAD_PARAMETER;
            break;
a85 1
         surf->Height = val;
d88 6
a93 3
         if (type != EGL_PBUFFER_BIT) {
            err = EGL_BAD_ATTRIBUTE;
            break;
a94 1
         surf->LargestPbuffer = !!val;
a95 1
      /* for eglBindTexImage */
d97 7
a103 16
         if (!(type & texture_type)) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         switch (val) {
         case EGL_TEXTURE_RGB:
         case EGL_TEXTURE_RGBA:
         case EGL_NO_TEXTURE:
            break;
         default:
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (err != EGL_SUCCESS)
            break;
         surf->TextureFormat = val;
d106 7
a112 15
         if (!(type & texture_type)) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         switch (val) {
         case EGL_TEXTURE_2D:
         case EGL_NO_TEXTURE:
            break;
         default:
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (err != EGL_SUCCESS)
            break;
         surf->TextureTarget = val;
d115 53
a167 3
         if (!(type & texture_type)) {
            err = EGL_BAD_ATTRIBUTE;
            break;
a168 1
         surf->MipmapTexture = !!val;
d170 2
a171 1
      /* no pixmap surface specific attributes */
d173 2
a174 2
         err = EGL_BAD_ATTRIBUTE;
         break;
d176 1
d178 3
a180 4
      if (err != EGL_SUCCESS) {
         _eglLog(_EGL_WARNING, "bad surface attribute 0x%04x", attr);
         break;
      }
d183 21
a203 1
   return err;
d207 2
a208 7
/**
 * Do error check on parameters and initialize the given _EGLSurface object.
 * \return EGL_TRUE if no errors, EGL_FALSE otherwise.
 */
EGLBoolean
_eglInitSurface(_EGLSurface *surf, _EGLDisplay *dpy, EGLint type,
                _EGLConfig *conf, const EGLint *attrib_list)
d210 7
a216 3
   const char *func;
   EGLint renderBuffer = EGL_BACK_BUFFER;
   EGLint err;
d218 5
a222 21
   switch (type) {
   case EGL_WINDOW_BIT:
      func = "eglCreateWindowSurface";
      break;
   case EGL_PIXMAP_BIT:
      func = "eglCreatePixmapSurface";
      renderBuffer = EGL_SINGLE_BUFFER;
      break;
   case EGL_PBUFFER_BIT:
      func = "eglCreatePBufferSurface";
      break;
#ifdef EGL_MESA_screen_surface
   case EGL_SCREEN_BIT_MESA:
      func = "eglCreateScreenSurface";
      renderBuffer = EGL_SINGLE_BUFFER; /* XXX correct? */
      break;
#endif
   default:
      _eglLog(_EGL_WARNING, "Bad type in _eglInitSurface");
      return EGL_FALSE;
   }
a223 5
   if ((conf->SurfaceType & type) == 0) {
      /* The config can't be used to create a surface of this type */
      _eglError(EGL_BAD_CONFIG, func);
      return EGL_FALSE;
   }
d225 6
a230 3
   _eglInitResource(&surf->Resource, sizeof(*surf), dpy);
   surf->Type = type;
   surf->Config = conf;
a231 9
   surf->Width = 0;
   surf->Height = 0;
   surf->TextureFormat = EGL_NO_TEXTURE;
   surf->TextureTarget = EGL_NO_TEXTURE;
   surf->MipmapTexture = EGL_FALSE;
   surf->LargestPbuffer = EGL_FALSE;
   surf->RenderBuffer = renderBuffer;
   surf->VGAlphaFormat = EGL_VG_ALPHA_FORMAT_NONPRE;
   surf->VGColorspace = EGL_VG_COLORSPACE_sRGB;
d233 16
a248 3
   surf->MipmapLevel = 0;
   surf->MultisampleResolve = EGL_MULTISAMPLE_RESOLVE_DEFAULT;
   surf->SwapBehavior = EGL_BUFFER_DESTROYED;
a249 10
   surf->HorizontalResolution = EGL_UNKNOWN;
   surf->VerticalResolution = EGL_UNKNOWN;
   surf->AspectRatio = EGL_UNKNOWN;

   /* the default swap interval is 1 */
   _eglClampSwapInterval(surf, 1);

   err = _eglParseSurfaceAttribList(surf, attrib_list);
   if (err != EGL_SUCCESS)
      return _eglError(err, func);
d251 16
d272 11
a282 1
_eglQuerySurface(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surface,
d285 5
d293 1
a293 1
      break;
d296 1
a296 1
      break;
d298 7
a304 5
      *value = surface->Config->ConfigID;
      break;
   case EGL_LARGEST_PBUFFER:
      *value = surface->LargestPbuffer;
      break;
d309 1
a309 1
      break;
d313 1
a313 1
      break;
d317 1
a317 1
      break;
d321 3
a323 1
      break;
d326 1
a326 1
      break;
d329 1
a329 1
      break;
d332 1
a332 1
      break;
d335 1
a335 1
      break;
d338 8
a345 10
      break;
   case EGL_MULTISAMPLE_RESOLVE:
      *value = surface->MultisampleResolve;
      break;
   case EGL_VG_ALPHA_FORMAT:
      *value = surface->VGAlphaFormat;
      break;
   case EGL_VG_COLORSPACE:
      *value = surface->VGColorspace;
      break;
d350 23
d374 3
a376 1
   return EGL_TRUE;
d381 1
a381 1
 * Default fallback routine - drivers might override this.
d383 3
a385 3
EGLBoolean
_eglSurfaceAttrib(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surface,
                  EGLint attribute, EGLint value)
d387 2
a388 2
   EGLint confval;
   EGLint err = EGL_SUCCESS;
d390 7
a396 46
   switch (attribute) {
   case EGL_MIPMAP_LEVEL:
      confval = surface->Config->RenderableType;
      if (!(confval & (EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT))) {
         err = EGL_BAD_PARAMETER;
         break;
      }
      surface->MipmapLevel = value;
      break;
   case EGL_MULTISAMPLE_RESOLVE:
      switch (value) {
      case EGL_MULTISAMPLE_RESOLVE_DEFAULT:
         break;
      case EGL_MULTISAMPLE_RESOLVE_BOX:
         confval = surface->Config->SurfaceType;
         if (!(confval & EGL_MULTISAMPLE_RESOLVE_BOX_BIT))
            err = EGL_BAD_MATCH;
         break;
      default:
         err = EGL_BAD_ATTRIBUTE;
         break;
      }
      if (err != EGL_SUCCESS)
         break;
      surface->MultisampleResolve = value;
      break;
   case EGL_SWAP_BEHAVIOR:
      switch (value) {
      case EGL_BUFFER_DESTROYED:
         break;
      case EGL_BUFFER_PRESERVED:
         confval = surface->Config->SurfaceType;
         if (!(confval & EGL_SWAP_BEHAVIOR_PRESERVED_BIT))
            err = EGL_BAD_MATCH;
         break;
      default:
         err = EGL_BAD_ATTRIBUTE;
         break;
      }
      if (err != EGL_SUCCESS)
         break;
      surface->SwapBehavior = value;
      break;
   default:
      err = EGL_BAD_ATTRIBUTE;
      break;
d399 5
a403 3
   if (err != EGL_SUCCESS)
      return _eglError(err, "eglSurfaceAttrib");
   return EGL_TRUE;
d407 6
a412 3
EGLBoolean
_eglBindTexImage(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surface,
                 EGLint buffer)
d414 13
a426 1
   EGLint texture_type = EGL_PBUFFER_BIT;
d428 4
a431 3
   /* Just do basic error checking and return success/fail.
    * Drivers must implement the real stuff.
    */
a432 2
   if (dpy->Extensions.NOK_texture_from_pixmap)
      texture_type |= EGL_PIXMAP_BIT;
d434 19
a452 2
   if (!(surface->Type & texture_type)) {
      _eglError(EGL_BAD_SURFACE, "eglBindTexImage");
d455 10
d466 2
a467 2
   if (surface->TextureFormat == EGL_NO_TEXTURE) {
      _eglError(EGL_BAD_MATCH, "eglBindTexImage");
d471 6
a476 2
   if (surface->TextureTarget == EGL_NO_TEXTURE) {
      _eglError(EGL_BAD_MATCH, "eglBindTexImage");
d479 2
a481 4
   if (buffer != EGL_BACK_BUFFER) {
      _eglError(EGL_BAD_PARAMETER, "eglBindTexImage");
      return EGL_FALSE;
   }
d483 7
a489 1
   surface->BoundToTexture = EGL_TRUE;
d491 5
a495 1
   return EGL_TRUE;
d500 1
a500 2
_eglSwapInterval(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf,
                 EGLint interval)
d502 6
a507 1
   _eglClampSwapInterval(surf, interval);
d510 21
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a0 30
/**************************************************************************
 *
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * Copyright 2010 LunarG, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


a9 1
#include "egldriver.h"
a142 12
      case EGL_POST_SUB_BUFFER_SUPPORTED_NV:
         if (!dpy->Extensions.NV_post_sub_buffer ||
             type != EGL_WINDOW_BIT) {
            err = EGL_BAD_ATTRIBUTE;
            break;
         }
         if (val != EGL_TRUE && val != EGL_FALSE) {
            err = EGL_BAD_PARAMETER;
            break;
         }
         surf->PostSubBufferSupportedNV = val;
         break;
a241 1
   EGLint swapBehavior = EGL_BUFFER_PRESERVED;
a246 1
      swapBehavior = EGL_BUFFER_DESTROYED;
d288 1
a288 1
   surf->SwapBehavior = swapBehavior;
a293 2
   surf->PostSubBufferSupportedNV = EGL_FALSE;

a362 10
   case EGL_POST_SUB_BUFFER_SUPPORTED_NV:
      *value = surface->PostSubBufferSupportedNV;
      break;
   case EGL_BUFFER_AGE_EXT:
      if (!dpy->Extensions.EXT_buffer_age) {
         _eglError(EGL_BAD_ATTRIBUTE, "eglQuerySurface");
         return EGL_FALSE;
      }
      *value = drv->API.QueryBufferAge(drv, dpy, surface);
      break;
a380 3
   EGLint all_es_bits = EGL_OPENGL_ES_BIT |
                        EGL_OPENGL_ES2_BIT |
                        EGL_OPENGL_ES3_BIT_KHR;
d385 1
a385 1
      if (!(confval & all_es_bits)) {
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
a531 11
}

EGLBoolean
_eglReleaseTexImage(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf,
                    EGLint buffer)
{
   /* TODO: do basic error checking and return success/fail.
    * Drivers must implement the real stuff.
    */

  return EGL_TRUE;
@


