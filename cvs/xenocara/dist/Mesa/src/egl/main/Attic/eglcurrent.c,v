head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.25;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.51;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.13.59.24;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.03;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.09.22;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.33.40;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


#include <stdlib.h>
#include <string.h>
#include "egllog.h"
#include "eglmutex.h"
#include "eglcurrent.h"
#include "eglglobals.h"


/* This should be kept in sync with _eglInitThreadInfo() */
#define _EGL_THREAD_INFO_INITIALIZER \
   { EGL_SUCCESS, { NULL }, 0 }

/* a fallback thread info to guarantee that every thread always has one */
static _EGLThreadInfo dummy_thread = _EGL_THREAD_INFO_INITIALIZER;


#if HAVE_PTHREAD
#include <pthread.h>

static _EGLMutex _egl_TSDMutex = _EGL_MUTEX_INITIALIZER;
static EGLBoolean _egl_TSDInitialized;
static pthread_key_t _egl_TSD;
static void (*_egl_FreeTSD)(_EGLThreadInfo *);

#ifdef GLX_USE_TLS
static __thread const _EGLThreadInfo *_egl_TLS
   __attribute__ ((tls_model("initial-exec")));
#endif

static INLINE void _eglSetTSD(const _EGLThreadInfo *t)
{
   pthread_setspecific(_egl_TSD, (const void *) t);
#ifdef GLX_USE_TLS
   _egl_TLS = t;
#endif
}

static INLINE _EGLThreadInfo *_eglGetTSD(void)
{
#ifdef GLX_USE_TLS
   return (_EGLThreadInfo *) _egl_TLS;
#else
   return (_EGLThreadInfo *) pthread_getspecific(_egl_TSD);
#endif
}

static INLINE void _eglFiniTSD(void)
{
   _eglLockMutex(&_egl_TSDMutex);
   if (_egl_TSDInitialized) {
      _EGLThreadInfo *t = _eglGetTSD();

      _egl_TSDInitialized = EGL_FALSE;
      if (t && _egl_FreeTSD)
         _egl_FreeTSD((void *) t);
      pthread_key_delete(_egl_TSD);
   }
   _eglUnlockMutex(&_egl_TSDMutex);
}

static INLINE EGLBoolean _eglInitTSD(void (*dtor)(_EGLThreadInfo *))
{
   if (!_egl_TSDInitialized) {
      _eglLockMutex(&_egl_TSDMutex);

      /* check again after acquiring lock */
      if (!_egl_TSDInitialized) {
         if (pthread_key_create(&_egl_TSD, (void (*)(void *)) dtor) != 0) {
            _eglUnlockMutex(&_egl_TSDMutex);
            return EGL_FALSE;
         }
         _egl_FreeTSD = dtor;
         _eglAddAtExitCall(_eglFiniTSD);
         _egl_TSDInitialized = EGL_TRUE;
      }

      _eglUnlockMutex(&_egl_TSDMutex);
   }

   return EGL_TRUE;
}

#else /* HAVE_PTHREAD */
static const _EGLThreadInfo *_egl_TSD;
static void (*_egl_FreeTSD)(_EGLThreadInfo *);

static INLINE void _eglSetTSD(const _EGLThreadInfo *t)
{
   _egl_TSD = t;
}

static INLINE _EGLThreadInfo *_eglGetTSD(void)
{
   return (_EGLThreadInfo *) _egl_TSD;
}

static INLINE void _eglFiniTSD(void)
{
   if (_egl_FreeTSD && _egl_TSD)
      _egl_FreeTSD((_EGLThreadInfo *) _egl_TSD);
}

static INLINE EGLBoolean _eglInitTSD(void (*dtor)(_EGLThreadInfo *))
{
   if (!_egl_FreeTSD && dtor) {
      _egl_FreeTSD = dtor;
      _eglAddAtExitCall(_eglFiniTSD);
   }
   return EGL_TRUE;
}

#endif /* !HAVE_PTHREAD */


static void
_eglInitThreadInfo(_EGLThreadInfo *t)
{
   memset(t, 0, sizeof(*t));
   t->LastError = EGL_SUCCESS;
   /* default, per EGL spec */
   t->CurrentAPIIndex = _eglConvertApiToIndex(EGL_OPENGL_ES_API);
}


/**
 * Allocate and init a new _EGLThreadInfo object.
 */
static _EGLThreadInfo *
_eglCreateThreadInfo(void)
{
   _EGLThreadInfo *t = calloc(1, sizeof(_EGLThreadInfo));
   if (t)
      _eglInitThreadInfo(t);
   else
      t = &dummy_thread;
   return t;
}


/**
 * Delete/free a _EGLThreadInfo object.
 */
static void
_eglDestroyThreadInfo(_EGLThreadInfo *t)
{
   if (t != &dummy_thread)
      free(t);
}


/**
 * Make sure TSD is initialized and return current value.
 */
static INLINE _EGLThreadInfo *
_eglCheckedGetTSD(void)
{
   if (_eglInitTSD(&_eglDestroyThreadInfo) != EGL_TRUE) {
      _eglLog(_EGL_FATAL, "failed to initialize \"current\" system");
      return NULL;
   }

   return _eglGetTSD();
}


/**
 * Return the calling thread's thread info.
 * If the calling thread nevers calls this function before, or if its thread
 * info was destroyed, a new one is created.  This function never returns NULL.
 * In the case allocation fails, a dummy one is returned.  See also
 * _eglIsCurrentThreadDummy.
 */
_EGLThreadInfo *
_eglGetCurrentThread(void)
{
   _EGLThreadInfo *t = _eglCheckedGetTSD();
   if (!t) {
      t = _eglCreateThreadInfo();
      _eglSetTSD(t);
   }

   return t;
}


/**
 * Destroy the calling thread's thread info.
 */
void
_eglDestroyCurrentThread(void)
{
   _EGLThreadInfo *t = _eglCheckedGetTSD();
   if (t) {
      _eglDestroyThreadInfo(t);
      _eglSetTSD(NULL);
   }
}


/**
 * Return true if the calling thread's thread info is dummy.
 * A dummy thread info is shared by all threads and should not be modified.
 * Functions like eglBindAPI or eglMakeCurrent should check for dummy-ness
 * before updating the thread info.
 */
EGLBoolean
_eglIsCurrentThreadDummy(void)
{
   _EGLThreadInfo *t = _eglCheckedGetTSD();
   return (!t || t == &dummy_thread);
}


/**
 * Return the currently bound context of the given API, or NULL.
 */
PUBLIC _EGLContext *
_eglGetAPIContext(EGLenum api)
{
   _EGLThreadInfo *t = _eglGetCurrentThread();
   return t->CurrentContexts[_eglConvertApiToIndex(api)];
}


/**
 * Return the currently bound context of the current API, or NULL.
 */
_EGLContext *
_eglGetCurrentContext(void)
{
   _EGLThreadInfo *t = _eglGetCurrentThread();
   return t->CurrentContexts[t->CurrentAPIIndex];
}


/**
 * Record EGL error code and return EGL_FALSE.
 */
EGLBoolean
_eglError(EGLint errCode, const char *msg)
{
   _EGLThreadInfo *t = _eglGetCurrentThread();

   if (t == &dummy_thread)
      return EGL_FALSE;

   t->LastError = errCode;

   if (errCode != EGL_SUCCESS) {
      const char *s;

      switch (errCode) {
      case EGL_BAD_ACCESS:
         s = "EGL_BAD_ACCESS";
         break;
      case EGL_BAD_ALLOC:
         s = "EGL_BAD_ALLOC";
         break;
      case EGL_BAD_ATTRIBUTE:
         s = "EGL_BAD_ATTRIBUTE";
         break;
      case EGL_BAD_CONFIG:
         s = "EGL_BAD_CONFIG";
         break;
      case EGL_BAD_CONTEXT:
         s = "EGL_BAD_CONTEXT";
         break;
      case EGL_BAD_CURRENT_SURFACE:
         s = "EGL_BAD_CURRENT_SURFACE";
         break;
      case EGL_BAD_DISPLAY:
         s = "EGL_BAD_DISPLAY";
         break;
      case EGL_BAD_MATCH:
         s = "EGL_BAD_MATCH";
         break;
      case EGL_BAD_NATIVE_PIXMAP:
         s = "EGL_BAD_NATIVE_PIXMAP";
         break;
      case EGL_BAD_NATIVE_WINDOW:
         s = "EGL_BAD_NATIVE_WINDOW";
         break;
      case EGL_BAD_PARAMETER:
         s = "EGL_BAD_PARAMETER";
         break;
      case EGL_BAD_SURFACE:
         s = "EGL_BAD_SURFACE";
         break;
      case EGL_NOT_INITIALIZED:
         s = "EGL_NOT_INITIALIZED";
         break;
#ifdef EGL_MESA_screen_surface
      case EGL_BAD_SCREEN_MESA:
         s = "EGL_BAD_SCREEN_MESA";
         break;
      case EGL_BAD_MODE_MESA:
         s = "EGL_BAD_MODE_MESA";
         break;
#endif
      default:
         s = "other EGL error";
      }
      _eglLog(_EGL_DEBUG, "EGL user error 0x%x (%s) in %s\n", errCode, s, msg);
   }

   return EGL_FALSE;
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d48 1
a48 1
static _EGL_DECLARE_MUTEX(_egl_TSDMutex);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d45 1
a45 1
#if PTHREADS
d111 1
a111 1
#else /* PTHREADS */
d140 1
a140 1
#endif /* !PTHREADS */
d159 1
a159 1
   _EGLThreadInfo *t = (_EGLThreadInfo *) calloc(1, sizeof(_EGLThreadInfo));
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d1 28
d317 3
d329 1
a329 1
         s = "other";
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a2 1
#include "eglglobals.h"
d6 1
d17 1
a17 27
#ifdef GLX_USE_TLS
static __thread const _EGLThreadInfo *_egl_TSD
   __attribute__ ((tls_model("initial-exec")));

static INLINE void _eglSetTSD(const _EGLThreadInfo *t)
{
   _egl_TSD = t;
}

static INLINE _EGLThreadInfo *_eglGetTSD(void)
{
   return (_EGLThreadInfo *) _egl_TSD;
}

static INLINE void _eglFiniTSD(void)
{
}

static INLINE EGLBoolean _eglInitTSD(void (*dtor)(_EGLThreadInfo *))
{
   /* TODO destroy TSD */
   (void) dtor;
   (void) _eglFiniTSD;
   return EGL_TRUE;
}

#elif PTHREADS
d25 5
d33 3
d40 3
d44 1
d289 1
d296 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d3 1
a6 1
#include "eglglobals.h"
d17 27
a43 1
#if PTHREADS
a50 5
#ifdef GLX_USE_TLS
static __thread const _EGLThreadInfo *_egl_TLS
   __attribute__ ((tls_model("initial-exec")));
#endif

a53 3
#ifdef GLX_USE_TLS
   _egl_TLS = t;
#endif
a57 3
#ifdef GLX_USE_TLS
   return (_EGLThreadInfo *) _egl_TLS;
#else
a58 1
#endif
a302 1
#ifdef EGL_MESA_screen_surface
a308 1
#endif
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a0 28
/**************************************************************************
 *
 * Copyright 2009-2010 Chia-I Wu <olvaffe@@gmail.com>
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


d17 1
a17 1
#if HAVE_PTHREAD
d83 1
a83 1
#else /* HAVE_PTHREAD */
d112 1
a112 1
#endif /* !HAVE_PTHREAD */
d131 1
a131 1
   _EGLThreadInfo *t = calloc(1, sizeof(_EGLThreadInfo));
a288 3
      case EGL_NOT_INITIALIZED:
         s = "EGL_NOT_INITIALIZED";
         break;
d298 1
a298 1
         s = "other EGL error";
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d48 1
a48 1
static _EGLMutex _egl_TSDMutex = _EGL_MUTEX_INITIALIZER;
@


