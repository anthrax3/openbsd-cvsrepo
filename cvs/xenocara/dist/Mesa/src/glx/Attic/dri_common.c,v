head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.45;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.08.58;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.10.05.09.53.57;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.09.05.14.03.42;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.13;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.24.19.03.21;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.24.18.16.40;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.36;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.10.05.09.24.22;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.33;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.10.38;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.47.43;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
 * Copyright © 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Soft-
 * ware"), to deal in the Software without restriction, including without
 * limitation the rights to use, copy, modify, merge, publish, distribute,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, provided that the above copyright
 * notice(s) and this permission notice appear in all copies of the Soft-
 * ware and that both the above copyright notice(s) and this permission
 * notice appear in supporting documentation.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
 * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
 * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
 * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
 * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
 * MANCE OF THIS SOFTWARE.
 *
 * Except as contained in this notice, the name of a copyright holder shall
 * not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization of
 * the copyright holder.
 *
 * Authors:
 *   Kevin E. Martin <kevin@@precisioninsight.com>
 *   Brian Paul <brian@@precisioninsight.com>
 *   Kristian Høgsberg (krh@@redhat.com)
 */

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)

#include <unistd.h>
#include <dlfcn.h>
#include <stdarg.h>
#include "glxclient.h"
#include "dri_common.h"
#include "loader.h"

#ifndef RTLD_NOW
#define RTLD_NOW 0
#endif
#ifndef RTLD_GLOBAL
#define RTLD_GLOBAL 0
#endif

_X_HIDDEN void
dri_message(int level, const char *f, ...)
{
   va_list args;
   int threshold = _LOADER_WARNING;
   const char *libgl_debug;

   libgl_debug = getenv("LIBGL_DEBUG");
   if (libgl_debug) {
      if (strstr(libgl_debug, "quiet"))
         threshold = _LOADER_FATAL;
      else if (strstr(libgl_debug, "verbose"))
         threshold = _LOADER_DEBUG;
   }

   /* Note that the _LOADER_* levels are lower numbers for more severe. */
   if (level <= threshold) {
      fprintf(stderr, "libGL%s: ", level <= _LOADER_WARNING ? " error" : "");
      va_start(args, f);
      vfprintf(stderr, f, args);
      va_end(args);
   }
}

#ifndef DEFAULT_DRIVER_DIR
/* this is normally defined in Mesa/configs/default with DRI_DRIVER_SEARCH_PATH */
#define DEFAULT_DRIVER_DIR "/usr/local/lib/dri"
#endif

/**
 * Try to \c dlopen the named driver.
 *
 * This function adds the "_dri.so" suffix to the driver name and searches the
 * directories specified by the \c LIBGL_DRIVERS_PATH environment variable in
 * order to find the driver.
 *
 * \param driverName - a name like "i965", "radeon", "nouveau", etc.
 *
 * \returns
 * A handle from \c dlopen, or \c NULL if driver file not found.
 */
_X_HIDDEN void *
driOpenDriver(const char *driverName)
{
   void *glhandle, *handle;
   const char *libPaths, *p, *next;
   char realDriverName[200];
   int len;

   /* Attempt to make sure libGL symbols will be visible to the driver */
#ifdef __OpenBSD__
   glhandle = dlopen("libGL.so", RTLD_NOW | RTLD_GLOBAL);
#else
   glhandle = dlopen("libGL.so.1", RTLD_NOW | RTLD_GLOBAL);
#endif

   libPaths = NULL;
   if (geteuid() == getuid()) {
      /* don't allow setuid apps to use LIBGL_DRIVERS_PATH */
      libPaths = getenv("LIBGL_DRIVERS_PATH");
      if (!libPaths)
         libPaths = getenv("LIBGL_DRIVERS_DIR");        /* deprecated */
   }
   if (libPaths == NULL)
      libPaths = DEFAULT_DRIVER_DIR;

   handle = NULL;
   for (p = libPaths; *p; p = next) {
      next = strchr(p, ':');
      if (next == NULL) {
         len = strlen(p);
         next = p + len;
      }
      else {
         len = next - p;
         next++;
      }

#ifdef GLX_USE_TLS
      snprintf(realDriverName, sizeof realDriverName,
               "%.*s/tls/%s_dri.so", len, p, driverName);
      InfoMessageF("OpenDriver: trying %s\n", realDriverName);
      handle = dlopen(realDriverName, RTLD_NOW | RTLD_GLOBAL);
#endif

      if (handle == NULL) {
         snprintf(realDriverName, sizeof realDriverName,
                  "%.*s/%s_dri.so", len, p, driverName);
         InfoMessageF("OpenDriver: trying %s\n", realDriverName);
         handle = dlopen(realDriverName, RTLD_NOW | RTLD_GLOBAL);
      }

      if (handle != NULL)
         break;
      else
         ErrorMessageF("dlopen %s failed (%s)\n", realDriverName, dlerror());
   }

   if (!handle)
      ErrorMessageF("unable to load driver: %s_dri.so\n", driverName);

   if (glhandle)
      dlclose(glhandle);

   return handle;
}

_X_HIDDEN const __DRIextension **
driGetDriverExtensions(void *handle, const char *driver_name)
{
   const __DRIextension **extensions = NULL;
   const __DRIextension **(*get_extensions)(void);
   char *get_extensions_name;

   if (asprintf(&get_extensions_name, "%s_%s",
                __DRI_DRIVER_GET_EXTENSIONS, driver_name) != -1) {
      get_extensions = dlsym(handle, get_extensions_name);
      if (get_extensions) {
         free(get_extensions_name);
         return get_extensions();
      } else {
         InfoMessageF("driver does not expose %s(): %s\n",
                      get_extensions_name, dlerror());
         free(get_extensions_name);
      }
   }

   extensions = dlsym(handle, __DRI_DRIVER_EXTENSIONS);
   if (extensions == NULL) {
      ErrorMessageF("driver exports no extensions (%s)\n", dlerror());
      return NULL;
   }

   return extensions;
}

static GLboolean
__driGetMSCRate(__DRIdrawable *draw,
		int32_t * numerator, int32_t * denominator,
		void *loaderPrivate)
{
   __GLXDRIdrawable *glxDraw = loaderPrivate;

   return __glxGetMscRate(glxDraw->psc, numerator, denominator);
}

_X_HIDDEN const __DRIsystemTimeExtension systemTimeExtension = {
   .base = {__DRI_SYSTEM_TIME, 1 },

   .getUST              = __glXGetUST,
   .getMSCRate          = __driGetMSCRate
};

#define __ATTRIB(attrib, field) \
    { attrib, offsetof(struct glx_config, field) }

static const struct
{
   unsigned int attrib, offset;
} attribMap[] = {
   __ATTRIB(__DRI_ATTRIB_BUFFER_SIZE, rgbBits),
      __ATTRIB(__DRI_ATTRIB_LEVEL, level),
      __ATTRIB(__DRI_ATTRIB_RED_SIZE, redBits),
      __ATTRIB(__DRI_ATTRIB_GREEN_SIZE, greenBits),
      __ATTRIB(__DRI_ATTRIB_BLUE_SIZE, blueBits),
      __ATTRIB(__DRI_ATTRIB_ALPHA_SIZE, alphaBits),
      __ATTRIB(__DRI_ATTRIB_DEPTH_SIZE, depthBits),
      __ATTRIB(__DRI_ATTRIB_STENCIL_SIZE, stencilBits),
      __ATTRIB(__DRI_ATTRIB_ACCUM_RED_SIZE, accumRedBits),
      __ATTRIB(__DRI_ATTRIB_ACCUM_GREEN_SIZE, accumGreenBits),
      __ATTRIB(__DRI_ATTRIB_ACCUM_BLUE_SIZE, accumBlueBits),
      __ATTRIB(__DRI_ATTRIB_ACCUM_ALPHA_SIZE, accumAlphaBits),
      __ATTRIB(__DRI_ATTRIB_SAMPLE_BUFFERS, sampleBuffers),
      __ATTRIB(__DRI_ATTRIB_SAMPLES, samples),
      __ATTRIB(__DRI_ATTRIB_DOUBLE_BUFFER, doubleBufferMode),
      __ATTRIB(__DRI_ATTRIB_STEREO, stereoMode),
      __ATTRIB(__DRI_ATTRIB_AUX_BUFFERS, numAuxBuffers),
#if 0
      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_TYPE, transparentPixel),
      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_INDEX_VALUE, transparentIndex),
      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_RED_VALUE, transparentRed),
      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_GREEN_VALUE, transparentGreen),
      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_BLUE_VALUE, transparentBlue),
      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_ALPHA_VALUE, transparentAlpha),
      __ATTRIB(__DRI_ATTRIB_RED_MASK, redMask),
      __ATTRIB(__DRI_ATTRIB_GREEN_MASK, greenMask),
      __ATTRIB(__DRI_ATTRIB_BLUE_MASK, blueMask),
      __ATTRIB(__DRI_ATTRIB_ALPHA_MASK, alphaMask),
#endif
      __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_WIDTH, maxPbufferWidth),
      __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_HEIGHT, maxPbufferHeight),
      __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_PIXELS, maxPbufferPixels),
      __ATTRIB(__DRI_ATTRIB_OPTIMAL_PBUFFER_WIDTH, optimalPbufferWidth),
      __ATTRIB(__DRI_ATTRIB_OPTIMAL_PBUFFER_HEIGHT, optimalPbufferHeight),
#if 0
      __ATTRIB(__DRI_ATTRIB_SWAP_METHOD, swapMethod),
#endif
__ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_RGB, bindToTextureRgb),
      __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_RGBA, bindToTextureRgba),
      __ATTRIB(__DRI_ATTRIB_BIND_TO_MIPMAP_TEXTURE,
                     bindToMipmapTexture),
      __ATTRIB(__DRI_ATTRIB_YINVERTED, yInverted),
      __ATTRIB(__DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE, sRGBCapable)
};

static int
scalarEqual(struct glx_config *mode, unsigned int attrib, unsigned int value)
{
   unsigned int glxValue;
   int i;

   for (i = 0; i < ARRAY_SIZE(attribMap); i++)
      if (attribMap[i].attrib == attrib) {
         glxValue = *(unsigned int *) ((char *) mode + attribMap[i].offset);
         return glxValue == GLX_DONT_CARE || glxValue == value;
      }

   return GL_TRUE;              /* Is a non-existing attribute equal to value? */
}

static int
driConfigEqual(const __DRIcoreExtension *core,
               struct glx_config *config, const __DRIconfig *driConfig)
{
   unsigned int attrib, value, glxValue;
   int i;

   i = 0;
   while (core->indexConfigAttrib(driConfig, i++, &attrib, &value)) {
      switch (attrib) {
      case __DRI_ATTRIB_RENDER_TYPE:
         glxValue = 0;
         if (value & __DRI_ATTRIB_RGBA_BIT) {
            glxValue |= GLX_RGBA_BIT;
         }
         if (value & __DRI_ATTRIB_COLOR_INDEX_BIT) {
            glxValue |= GLX_COLOR_INDEX_BIT;
         }
         if (value & __DRI_ATTRIB_FLOAT_BIT) {
            glxValue |= GLX_RGBA_FLOAT_BIT_ARB;
         }
         if (value & __DRI_ATTRIB_UNSIGNED_FLOAT_BIT) {
            glxValue |= GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT;
         }
         if (glxValue != config->renderType)
            return GL_FALSE;
         break;

      case __DRI_ATTRIB_CONFIG_CAVEAT:
         if (value & __DRI_ATTRIB_NON_CONFORMANT_CONFIG)
            glxValue = GLX_NON_CONFORMANT_CONFIG;
         else if (value & __DRI_ATTRIB_SLOW_BIT)
            glxValue = GLX_SLOW_CONFIG;
         else
            glxValue = GLX_NONE;
         if (glxValue != config->visualRating)
            return GL_FALSE;
         break;

      case __DRI_ATTRIB_BIND_TO_TEXTURE_TARGETS:
         glxValue = 0;
         if (value & __DRI_ATTRIB_TEXTURE_1D_BIT)
            glxValue |= GLX_TEXTURE_1D_BIT_EXT;
         if (value & __DRI_ATTRIB_TEXTURE_2D_BIT)
            glxValue |= GLX_TEXTURE_2D_BIT_EXT;
         if (value & __DRI_ATTRIB_TEXTURE_RECTANGLE_BIT)
            glxValue |= GLX_TEXTURE_RECTANGLE_BIT_EXT;
         if (config->bindToTextureTargets != GLX_DONT_CARE &&
             glxValue != config->bindToTextureTargets)
            return GL_FALSE;
         break;

      default:
         if (!scalarEqual(config, attrib, value))
            return GL_FALSE;
      }
   }

   return GL_TRUE;
}

static struct glx_config *
createDriMode(const __DRIcoreExtension * core,
	      struct glx_config *config, const __DRIconfig **driConfigs)
{
   __GLXDRIconfigPrivate *driConfig;
   int i;

   for (i = 0; driConfigs[i]; i++) {
      if (driConfigEqual(core, config, driConfigs[i]))
         break;
   }

   if (driConfigs[i] == NULL)
      return NULL;

   driConfig = malloc(sizeof *driConfig);
   if (driConfig == NULL)
      return NULL;

   driConfig->base = *config;
   driConfig->driConfig = driConfigs[i];

   return &driConfig->base;
}

_X_HIDDEN struct glx_config *
driConvertConfigs(const __DRIcoreExtension * core,
                  struct glx_config *configs, const __DRIconfig **driConfigs)
{
   struct glx_config head, *tail, *m;

   tail = &head;
   head.next = NULL;
   for (m = configs; m; m = m->next) {
      tail->next = createDriMode(core, m, driConfigs);
      if (tail->next == NULL) {
         /* no matching dri config for m */
         continue;
      }


      tail = tail->next;
   }

   return head.next;
}

_X_HIDDEN void
driDestroyConfigs(const __DRIconfig **configs)
{
   int i;

   for (i = 0; configs[i]; i++)
      free((__DRIconfig *) configs[i]);
   free(configs);
}

_X_HIDDEN __GLXDRIdrawable *
driFetchDrawable(struct glx_context *gc, GLXDrawable glxDrawable)
{
   struct glx_display *const priv = __glXInitialize(gc->psc->dpy);
   __GLXDRIdrawable *pdraw;
   struct glx_screen *psc;

   if (priv == NULL)
      return NULL;

   if (glxDrawable == None)
      return NULL;

   psc = priv->screens[gc->screen];
   if (priv->drawHash == NULL)
      return NULL;

   if (__glxHashLookup(priv->drawHash, glxDrawable, (void *) &pdraw) == 0) {
      pdraw->refcount ++;
      return pdraw;
   }

   pdraw = psc->driScreen->createDrawable(psc, glxDrawable,
                                          glxDrawable, gc->config);

   if (pdraw == NULL) {
      ErrorMessageF("failed to create drawable\n");
      return NULL;
   }

   if (__glxHashInsert(priv->drawHash, glxDrawable, pdraw)) {
      (*pdraw->destroyDrawable) (pdraw);
      return NULL;
   }
   pdraw->refcount = 1;

   return pdraw;
}

_X_HIDDEN void
driReleaseDrawables(struct glx_context *gc)
{
   const struct glx_display *priv = gc->psc->display;
   __GLXDRIdrawable *pdraw;

   if (priv == NULL)
      return;

   if (__glxHashLookup(priv->drawHash,
		       gc->currentDrawable, (void *) &pdraw) == 0) {
      if (pdraw->drawable == pdraw->xDrawable) {
	 pdraw->refcount --;
	 if (pdraw->refcount == 0) {
	    (*pdraw->destroyDrawable)(pdraw);
	    __glxHashDelete(priv->drawHash, gc->currentDrawable);
	 }
      }
   }

   if (__glxHashLookup(priv->drawHash,
		       gc->currentReadable, (void *) &pdraw) == 0) {
      if (pdraw->drawable == pdraw->xDrawable) {
	 pdraw->refcount --;
	 if (pdraw->refcount == 0) {
	    (*pdraw->destroyDrawable)(pdraw);
	    __glxHashDelete(priv->drawHash, gc->currentReadable);
	 }
      }
   }

   gc->currentDrawable = None;
   gc->currentReadable = None;

}

_X_HIDDEN bool
dri2_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
                         unsigned *major_ver, unsigned *minor_ver,
                         uint32_t *render_type, uint32_t *flags, unsigned *api,
                         int *reset, unsigned *error)
{
   unsigned i;
   bool got_profile = false;
   uint32_t profile;

   *major_ver = 1;
   *minor_ver = 0;
   *render_type = GLX_RGBA_TYPE;
   *reset = __DRI_CTX_RESET_NO_NOTIFICATION;
   *flags = 0;
   *api = __DRI_API_OPENGL;

   if (num_attribs == 0) {
      return true;
   }

   /* This is actually an internal error, but what the heck.
    */
   if (attribs == NULL) {
      *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
      return false;
   }

   for (i = 0; i < num_attribs; i++) {
      switch (attribs[i * 2]) {
      case GLX_CONTEXT_MAJOR_VERSION_ARB:
	 *major_ver = attribs[i * 2 + 1];
	 break;
      case GLX_CONTEXT_MINOR_VERSION_ARB:
	 *minor_ver = attribs[i * 2 + 1];
	 break;
      case GLX_CONTEXT_FLAGS_ARB:
	 *flags = attribs[i * 2 + 1];
	 break;
      case GLX_CONTEXT_PROFILE_MASK_ARB:
	 profile = attribs[i * 2 + 1];
	 got_profile = true;
	 break;
      case GLX_RENDER_TYPE:
         *render_type = attribs[i * 2 + 1];
	 break;
      case GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB:
         switch (attribs[i * 2 + 1]) {
         case GLX_NO_RESET_NOTIFICATION_ARB:
            *reset = __DRI_CTX_RESET_NO_NOTIFICATION;
            break;
         case GLX_LOSE_CONTEXT_ON_RESET_ARB:
            *reset = __DRI_CTX_RESET_LOSE_CONTEXT;
            break;
         default:
            *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
            return false;
         }
         break;
      default:
	 /* If an unknown attribute is received, fail.
	  */
	 *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
	 return false;
      }
   }

   if (!got_profile) {
      if (*major_ver > 3 || (*major_ver == 3 && *minor_ver >= 2))
	 *api = __DRI_API_OPENGL_CORE;
   } else {
      switch (profile) {
      case GLX_CONTEXT_CORE_PROFILE_BIT_ARB:
	 /* There are no profiles before OpenGL 3.2.  The
	  * GLX_ARB_create_context_profile spec says:
	  *
	  *     "If the requested OpenGL version is less than 3.2,
	  *     GLX_CONTEXT_PROFILE_MASK_ARB is ignored and the functionality
	  *     of the context is determined solely by the requested version."
	  */
	 *api = (*major_ver > 3 || (*major_ver == 3 && *minor_ver >= 2))
	    ? __DRI_API_OPENGL_CORE : __DRI_API_OPENGL;
	 break;
      case GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB:
	 *api = __DRI_API_OPENGL;
	 break;
      case GLX_CONTEXT_ES2_PROFILE_BIT_EXT:
	 *api = __DRI_API_GLES2;
	 break;
      default:
	 *error = __DRI_CTX_ERROR_BAD_API;
	 return false;
      }
   }

   /* Unknown flag value.
    */
   if (*flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_FORWARD_COMPATIBLE
                  | __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS)) {
      *error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
      return false;
   }

   /* There are no forward-compatible contexts before OpenGL 3.0.  The
    * GLX_ARB_create_context spec says:
    *
    *     "Forward-compatible contexts are defined only for OpenGL versions
    *     3.0 and later."
    */
   if (*major_ver < 3 && (*flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0) {
      *error = __DRI_CTX_ERROR_BAD_FLAG;
      return false;
   }

   if (*major_ver >= 3 && *render_type == GLX_COLOR_INDEX_TYPE) {
      *error = __DRI_CTX_ERROR_BAD_FLAG;
      return false;
   }

   /* The GLX_EXT_create_context_es2_profile spec says:
    *
    *     "... If the version requested is 2.0, and the
    *     GLX_CONTEXT_ES2_PROFILE_BIT_EXT bit is set in the
    *     GLX_CONTEXT_PROFILE_MASK_ARB attribute (see below), then the context
    *     returned will implement OpenGL ES 2.0. This is the only way in which
    *     an implementation may request an OpenGL ES 2.0 context."
    */
   if (*api == __DRI_API_GLES2 && (*major_ver != 2 || *minor_ver != 0)) {
      *error = __DRI_CTX_ERROR_BAD_API;
      return false;
   }

   *error = __DRI_CTX_ERROR_SUCCESS;
   return true;
}

#endif /* GLX_DIRECT_RENDERING */
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d147 1
a147 1
         InfoMessageF("dlopen %s failed (%s)\n", realDriverName, dlerror());
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d147 1
a147 1
         ErrorMessageF("dlopen %s failed (%s)\n", realDriverName, dlerror());
@


1.7
log
@Merge Mesa 9.2.1
@
text
@d43 1
a51 4
/**
 * Print informational message to stderr if LIBGL_DEBUG is set to
 * "verbose".
 */
d53 1
a53 1
InfoMessageF(const char *f, ...)
d56 2
a57 1
   const char *env;
d59 6
a64 5
   if ((env = getenv("LIBGL_DEBUG")) && strstr(env, "verbose")) {
      fprintf(stderr, "libGL: ");
      va_start(args, f);
      vfprintf(stderr, f, args);
      va_end(args);
a65 32
}

/**
 * Print error message to stderr if LIBGL_DEBUG is set to anything but
 * "quiet", (do nothing if LIBGL_DEBUG is unset).
 */
_X_HIDDEN void
ErrorMessageF(const char *f, ...)
{
   va_list args;
   const char *env;

   if ((env = getenv("LIBGL_DEBUG")) && !strstr(env, "quiet")) {
      fprintf(stderr, "libGL error: ");
      va_start(args, f);
      vfprintf(stderr, f, args);
      va_end(args);
   }
}

/**
 * Print error message unless LIBGL_DEBUG is set to "quiet".
 *
 * The distinction between CriticalErrorMessageF and ErrorMessageF is
 * that critcial errors will be printed by default, (even when
 * LIBGL_DEBUG is unset).
 */
_X_HIDDEN void
CriticalErrorMessageF(const char *f, ...)
{
   va_list args;
   const char *env;
d67 3
a69 2
   if (!(env = getenv("LIBGL_DEBUG")) || !strstr(env, "quiet")) {
      fprintf(stderr, "libGL error: ");
a72 3

      if (!env || !strstr(env, "verbose"))
         fprintf(stderr, "libGL error: Try again with LIBGL_DEBUG=verbose for more details.\n");
d159 29
d195 1
a195 1
   return __glxGetMscRate(glxDraw, numerator, denominator);
d199 4
a202 3
   {__DRI_SYSTEM_TIME, __DRI_SYSTEM_TIME_VERSION},
   __glXGetUST,
   __driGetMSCRate
d398 3
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d477 7
a484 1
      *api = __DRI_API_OPENGL;
a494 5
   *major_ver = 1;
   *minor_ver = 0;
   *render_type = GLX_RGBA_TYPE;
   *reset = __DRI_CTX_RESET_NO_NOTIFICATION;

a533 1
   *api = __DRI_API_OPENGL;
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d51 4
d70 2
a71 1
 * Print error to stderr, unless LIBGL_DEBUG=="quiet".
d87 24
d123 1
a123 1
 * \param driverName - a name like "tdfx", "i810", "mga", etc.
d137 1
d139 3
d292 1
a292 1
         else if (value & __DRI_ATTRIB_COLOR_INDEX_BIT) {
d295 6
d353 1
a353 1
   driConfig = Xmalloc(sizeof *driConfig);
a381 2
   glx_config_destroy_list(configs);

d416 6
d465 136
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d225 3
a227 1
      __ATTRIB(__DRI_ATTRIB_YINVERTED, yInverted),};
d372 2
a373 1
   if (__glxHashLookup(priv->drawHash, glxDrawable, (void *) &pdraw) == 0)
d375 1
d383 1
d400 5
a404 2
	 (*pdraw->destroyDrawable)(pdraw);
	 __glxHashDelete(priv->drawHash, gc->currentDrawable);
d408 1
a408 2
   if (gc->currentDrawable != gc->currentReadable &&
       __glxHashLookup(priv->drawHash,
d411 5
a415 2
	 (*pdraw->destroyDrawable)(pdraw);
	 __glxHashDelete(priv->drawHash, gc->currentReadable);
d418 4
@


1.3
log
@Two patches cherry picked from mesa master just after 7.8 was branched
(but never made it into the 7.8 branch).

first:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:47:41 2010 -0700

    DRI2: add config query extension

    Add a new DRI2 configuration query extension.  Allows for DRI2
    client code to query for common DRI2 configuration options.

second:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:49:03 2010 -0700

    DRI2/GLX: check for vblank_mode in DRI2 GLX code

    Re-add support for the vblank_mode environment and configuration
    variable.  Useful for benchmarking and app control.

The final affect being that config and environment variables for
controlling swap mode work with dri2 now. which helps me a lot with
debugging.

ok matthieu@@.
@
text
@a41 1
#include "glcontextmodes.h"
d161 10
d174 1
a174 1
   __driGetMscRateOML
d178 1
a178 1
    { attrib, offsetof(__GLcontextModes, field) }
a226 2
#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))

d228 1
a228 1
scalarEqual(__GLcontextModes * mode, unsigned int attrib, unsigned int value)
d243 2
a244 2
driConfigEqual(const __DRIcoreExtension * core,
               __GLcontextModes * modes, const __DRIconfig * driConfig)
d260 1
a260 1
         if (glxValue != modes->renderType)
d271 1
a271 1
         if (glxValue != modes->visualRating)
d283 2
a284 2
         if (modes->bindToTextureTargets != GLX_DONT_CARE &&
             glxValue != modes->bindToTextureTargets)
d289 1
a289 1
         if (!scalarEqual(modes, attrib, value))
d297 1
a297 1
static __GLcontextModes *
d299 1
a299 1
              __GLcontextModes * modes, const __DRIconfig ** driConfigs)
d301 1
a301 1
   __GLXDRIconfigPrivate *config;
d305 1
a305 1
      if (driConfigEqual(core, modes, driConfigs[i]))
d312 2
a313 2
   config = Xmalloc(sizeof *config);
   if (config == NULL)
d316 2
a317 2
   config->modes = *modes;
   config->driConfig = driConfigs[i];
d319 1
a319 1
   return &config->modes;
d322 1
a322 1
_X_HIDDEN __GLcontextModes *
d324 1
a324 1
                  __GLcontextModes * modes, const __DRIconfig ** configs)
d326 1
a326 1
   __GLcontextModes head, *tail, *m;
d330 2
a331 2
   for (m = modes; m; m = m->next) {
      tail->next = createDriMode(core, m, configs);
d341 1
a341 1
   _gl_context_modes_destroy(modes);
a345 1
/* Bind DRI1 specific extensions */
d347 1
a347 1
driBindExtensions(__GLXscreenConfigs *psc)
a348 1
   const __DRIextension **extensions;
d351 3
a353 28
   extensions = psc->core->getExtensions(psc->__driScreen);

   for (i = 0; extensions[i]; i++) {
#ifdef __DRI_SWAP_CONTROL
      /* No DRI2 support for swap_control at the moment, since SwapBuffers
       * is done by the X server */
      if (strcmp(extensions[i]->name, __DRI_SWAP_CONTROL) == 0) {
	 psc->swapControl = (__DRIswapControlExtension *) extensions[i];
	 __glXEnableDirectExtension(psc, "GLX_SGI_swap_control");
	 __glXEnableDirectExtension(psc, "GLX_MESA_swap_control");
      }
#endif

#ifdef __DRI_MEDIA_STREAM_COUNTER
      if (strcmp(extensions[i]->name, __DRI_MEDIA_STREAM_COUNTER) == 0) {
         psc->msc = (__DRImediaStreamCounterExtension *) extensions[i];
         __glXEnableDirectExtension(psc, "GLX_SGI_video_sync");
      }
#endif

#ifdef __DRI_SWAP_BUFFER_COUNTER
      /* No driver supports this at this time and the extension is
       * not defined in dri_interface.h.  Will enable
       * GLX_OML_sync_control if implemented. */
#endif

      /* Ignore unknown extensions */
   }
d356 2
a357 3
/* Bind DRI2 specific extensions */
_X_HIDDEN void
dri2BindExtensions(__GLXscreenConfigs *psc)
d359 3
a361 2
   const __DRIextension **extensions;
   int i;
d363 2
a364 1
   extensions = psc->core->getExtensions(psc->__driScreen);
d366 3
a368 7
   for (i = 0; extensions[i]; i++) {
#ifdef __DRI_TEX_BUFFER
      if ((strcmp(extensions[i]->name, __DRI_TEX_BUFFER) == 0)) {
	 psc->texBuffer = (__DRItexBufferExtension *) extensions[i];
	 __glXEnableDirectExtension(psc, "GLX_EXT_texture_from_pixmap");
      }
#endif
d370 2
a371 13
      __glXEnableDirectExtension(psc, "GLX_SGI_video_sync");
      __glXEnableDirectExtension(psc, "GLX_SGI_swap_control");
      __glXEnableDirectExtension(psc, "GLX_MESA_swap_control");

      /* FIXME: if DRI2 version supports it... */
      __glXEnableDirectExtension(psc, "INTEL_swap_event");

#ifdef __DRI2_FLUSH
      if ((strcmp(extensions[i]->name, __DRI2_FLUSH) == 0)) {
	 psc->f = (__DRI2flushExtension *) extensions[i];
	 /* internal driver extension, no GL extension exposed */
      }
#endif
d373 5
a377 4
#ifdef __DRI2_CONFIG_QUERY
      if ((strcmp(extensions[i]->name, __DRI2_CONFIG_QUERY) == 0))
	 psc->config = (__DRI2configQueryExtension *) extensions[i];
#endif
d379 2
a382 1
/* Bind extensions common to DRI1 and DRI2 */
d384 1
a384 1
driBindCommonExtensions(__GLXscreenConfigs *psc)
d386 2
a387 2
   const __DRIextension **extensions;
   int i;
d389 2
a390 1
   extensions = psc->core->getExtensions(psc->__driScreen);
d392 5
a396 5
   for (i = 0; extensions[i]; i++) {
#ifdef __DRI_COPY_SUB_BUFFER
      if (strcmp(extensions[i]->name, __DRI_COPY_SUB_BUFFER) == 0) {
	 psc->driCopySubBuffer = (__DRIcopySubBufferExtension *) extensions[i];
	 __glXEnableDirectExtension(psc, "GLX_MESA_copy_sub_buffer");
d398 1
a398 1
#endif
d400 6
a405 4
#ifdef __DRI_ALLOCATE
      if (strcmp(extensions[i]->name, __DRI_ALLOCATE) == 0) {
	 psc->allocate = (__DRIallocateExtension *) extensions[i];
	 __glXEnableDirectExtension(psc, "GLX_MESA_allocate_memory");
a406 16
#endif

#ifdef __DRI_FRAME_TRACKING
      if (strcmp(extensions[i]->name, __DRI_FRAME_TRACKING) == 0) {
	 psc->frameTracking = (__DRIframeTrackingExtension *) extensions[i];
	 __glXEnableDirectExtension(psc, "GLX_MESA_swap_frame_usage");
      }
#endif

#ifdef __DRI_READ_DRAWABLE
      if (strcmp(extensions[i]->name, __DRI_READ_DRAWABLE) == 0) {
	 __glXEnableDirectExtension(psc, "GLX_SGI_make_current_read");
      }
#endif

      /* Ignore unknown extensions */
@


1.2
log
@When a dri driver dlopen()s libGL to try and get the correct symbols (in
case libGL itself was dlopen()ed), it was using "libGL.so.1" (linux
convention, doesn't work on OpenBSD). Change it to "libGL.so" so it has
a hope in hell of working.

I finally wrote this patch when trying to port perl's OpenGL modules
ages ago and i finally decided that hacking each instance of dlopening
libGL to use RTLD_GLOBAL was dumb.

ok matthieu@@
@
text
@d406 5
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d109 1
a109 1
   glhandle = dlopen("libGL.so.1", RTLD_NOW | RTLD_GLOBAL);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d42 1
d109 1
a109 1
   glhandle = dlopen("libGL.so", RTLD_NOW | RTLD_GLOBAL);
a161 10
static GLboolean
__driGetMSCRate(__DRIdrawable *draw,
		int32_t * numerator, int32_t * denominator,
		void *loaderPrivate)
{
   __GLXDRIdrawable *glxDraw = loaderPrivate;

   return __glxGetMscRate(glxDraw, numerator, denominator);
}

d165 1
a165 1
   __driGetMSCRate
d169 1
a169 1
    { attrib, offsetof(struct glx_config, field) }
d218 2
d221 1
a221 1
scalarEqual(struct glx_config *mode, unsigned int attrib, unsigned int value)
d236 2
a237 2
driConfigEqual(const __DRIcoreExtension *core,
               struct glx_config *config, const __DRIconfig *driConfig)
d253 1
a253 1
         if (glxValue != config->renderType)
d264 1
a264 1
         if (glxValue != config->visualRating)
d276 2
a277 2
         if (config->bindToTextureTargets != GLX_DONT_CARE &&
             glxValue != config->bindToTextureTargets)
d282 1
a282 1
         if (!scalarEqual(config, attrib, value))
d290 1
a290 1
static struct glx_config *
d292 1
a292 1
	      struct glx_config *config, const __DRIconfig **driConfigs)
d294 1
a294 1
   __GLXDRIconfigPrivate *driConfig;
d298 1
a298 1
      if (driConfigEqual(core, config, driConfigs[i]))
d305 2
a306 2
   driConfig = Xmalloc(sizeof *driConfig);
   if (driConfig == NULL)
d309 2
a310 2
   driConfig->base = *config;
   driConfig->driConfig = driConfigs[i];
d312 1
a312 1
   return &driConfig->base;
d315 1
a315 1
_X_HIDDEN struct glx_config *
d317 1
a317 1
                  struct glx_config *configs, const __DRIconfig **driConfigs)
d319 1
a319 1
   struct glx_config head, *tail, *m;
d323 2
a324 2
   for (m = configs; m; m = m->next) {
      tail->next = createDriMode(core, m, driConfigs);
d334 1
a334 1
   glx_config_destroy_list(configs);
d339 1
d341 1
a341 1
driDestroyConfigs(const __DRIconfig **configs)
d343 1
d346 28
a373 3
   for (i = 0; configs[i]; i++)
      free((__DRIconfig *) configs[i]);
   free(configs);
d376 3
a378 2
_X_HIDDEN __GLXDRIdrawable *
driFetchDrawable(struct glx_context *gc, GLXDrawable glxDrawable)
d380 2
a381 3
   struct glx_display *const priv = __glXInitialize(gc->psc->dpy);
   __GLXDRIdrawable *pdraw;
   struct glx_screen *psc;
d383 1
a383 2
   if (priv == NULL)
      return NULL;
d385 7
a391 3
   psc = priv->screens[gc->screen];
   if (priv->drawHash == NULL)
      return NULL;
d393 13
a405 8
   if (__glxHashLookup(priv->drawHash, glxDrawable, (void *) &pdraw) == 0)
      return pdraw;

   pdraw = psc->driScreen->createDrawable(psc, glxDrawable,
                                          glxDrawable, gc->config);
   if (__glxHashInsert(priv->drawHash, glxDrawable, pdraw)) {
      (*pdraw->destroyDrawable) (pdraw);
      return NULL;
a406 2

   return pdraw;
d409 1
d411 1
a411 1
driReleaseDrawables(struct glx_context *gc)
d413 4
a416 2
   const struct glx_display *priv = gc->psc->display;
   __GLXDRIdrawable *pdraw;
d418 14
a431 2
   if (priv == NULL)
      return;
d433 4
a436 5
   if (__glxHashLookup(priv->drawHash,
		       gc->currentDrawable, (void *) &pdraw) == 0) {
      if (pdraw->drawable == pdraw->xDrawable) {
	 (*pdraw->destroyDrawable)(pdraw);
	 __glxHashDelete(priv->drawHash, gc->currentDrawable);
d438 1
a438 1
   }
d440 3
a442 6
   if (gc->currentDrawable != gc->currentReadable &&
       __glxHashLookup(priv->drawHash,
		       gc->currentReadable, (void *) &pdraw) == 0) {
      if (pdraw->drawable == pdraw->xDrawable) {
	 (*pdraw->destroyDrawable)(pdraw);
	 __glxHashDelete(priv->drawHash, gc->currentReadable);
d444 3
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a50 4
/**
 * Print informational message to stderr if LIBGL_DEBUG is set to
 * "verbose".
 */
d66 1
a66 2
 * Print error message to stderr if LIBGL_DEBUG is set to anything but
 * "quiet", (do nothing if LIBGL_DEBUG is unset).
a81 24
/**
 * Print error message unless LIBGL_DEBUG is set to "quiet".
 *
 * The distinction between CriticalErrorMessageF and ErrorMessageF is
 * that critcial errors will be printed by default, (even when
 * LIBGL_DEBUG is unset).
 */
_X_HIDDEN void
CriticalErrorMessageF(const char *f, ...)
{
   va_list args;
   const char *env;

   if (!(env = getenv("LIBGL_DEBUG")) || !strstr(env, "quiet")) {
      fprintf(stderr, "libGL error: ");
      va_start(args, f);
      vfprintf(stderr, f, args);
      va_end(args);

      if (!env || !strstr(env, "verbose"))
         fprintf(stderr, "libGL error: Try again with LIBGL_DEBUG=verbose for more details.\n");
   }
}

d94 1
a94 1
 * \param driverName - a name like "i965", "radeon", "nouveau", etc.
d108 1
a108 1
   glhandle = dlopen("libGL.so.1", RTLD_NOW | RTLD_GLOBAL);
d225 1
a225 3
      __ATTRIB(__DRI_ATTRIB_YINVERTED, yInverted),
      __ATTRIB(__DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE, sRGBCapable)
};
d257 1
a257 1
         if (value & __DRI_ATTRIB_COLOR_INDEX_BIT) {
a259 6
         if (value & __DRI_ATTRIB_FLOAT_BIT) {
            glxValue |= GLX_RGBA_FLOAT_BIT_ARB;
         }
         if (value & __DRI_ATTRIB_UNSIGNED_FLOAT_BIT) {
            glxValue |= GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT;
         }
d312 1
a312 1
   driConfig = malloc(sizeof *driConfig);
d341 2
d370 1
a370 2
   if (__glxHashLookup(priv->drawHash, glxDrawable, (void *) &pdraw) == 0) {
      pdraw->refcount ++;
a371 1
   }
a374 6

   if (pdraw == NULL) {
      ErrorMessageF("failed to create drawable\n");
      return NULL;
   }

a378 1
   pdraw->refcount = 1;
d395 2
a396 5
	 pdraw->refcount --;
	 if (pdraw->refcount == 0) {
	    (*pdraw->destroyDrawable)(pdraw);
	    __glxHashDelete(priv->drawHash, gc->currentDrawable);
	 }
d400 2
a401 1
   if (__glxHashLookup(priv->drawHash,
d404 2
a405 76
	 pdraw->refcount --;
	 if (pdraw->refcount == 0) {
	    (*pdraw->destroyDrawable)(pdraw);
	    __glxHashDelete(priv->drawHash, gc->currentReadable);
	 }
      }
   }

   gc->currentDrawable = None;
   gc->currentReadable = None;

}

_X_HIDDEN bool
dri2_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
                         unsigned *major_ver, unsigned *minor_ver,
                         uint32_t *render_type, uint32_t *flags, unsigned *api,
                         int *reset, unsigned *error)
{
   unsigned i;
   bool got_profile = false;
   uint32_t profile;

   if (num_attribs == 0) {
      *api = __DRI_API_OPENGL;
      return true;
   }

   /* This is actually an internal error, but what the heck.
    */
   if (attribs == NULL) {
      *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
      return false;
   }

   *major_ver = 1;
   *minor_ver = 0;
   *render_type = GLX_RGBA_TYPE;
   *reset = __DRI_CTX_RESET_NO_NOTIFICATION;

   for (i = 0; i < num_attribs; i++) {
      switch (attribs[i * 2]) {
      case GLX_CONTEXT_MAJOR_VERSION_ARB:
	 *major_ver = attribs[i * 2 + 1];
	 break;
      case GLX_CONTEXT_MINOR_VERSION_ARB:
	 *minor_ver = attribs[i * 2 + 1];
	 break;
      case GLX_CONTEXT_FLAGS_ARB:
	 *flags = attribs[i * 2 + 1];
	 break;
      case GLX_CONTEXT_PROFILE_MASK_ARB:
	 profile = attribs[i * 2 + 1];
	 got_profile = true;
	 break;
      case GLX_RENDER_TYPE:
         *render_type = attribs[i * 2 + 1];
	 break;
      case GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB:
         switch (attribs[i * 2 + 1]) {
         case GLX_NO_RESET_NOTIFICATION_ARB:
            *reset = __DRI_CTX_RESET_NO_NOTIFICATION;
            break;
         case GLX_LOSE_CONTEXT_ON_RESET_ARB:
            *reset = __DRI_CTX_RESET_LOSE_CONTEXT;
            break;
         default:
            *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
            return false;
         }
         break;
      default:
	 /* If an unknown attribute is received, fail.
	  */
	 *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
	 return false;
a407 69

   *api = __DRI_API_OPENGL;
   if (!got_profile) {
      if (*major_ver > 3 || (*major_ver == 3 && *minor_ver >= 2))
	 *api = __DRI_API_OPENGL_CORE;
   } else {
      switch (profile) {
      case GLX_CONTEXT_CORE_PROFILE_BIT_ARB:
	 /* There are no profiles before OpenGL 3.2.  The
	  * GLX_ARB_create_context_profile spec says:
	  *
	  *     "If the requested OpenGL version is less than 3.2,
	  *     GLX_CONTEXT_PROFILE_MASK_ARB is ignored and the functionality
	  *     of the context is determined solely by the requested version."
	  */
	 *api = (*major_ver > 3 || (*major_ver == 3 && *minor_ver >= 2))
	    ? __DRI_API_OPENGL_CORE : __DRI_API_OPENGL;
	 break;
      case GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB:
	 *api = __DRI_API_OPENGL;
	 break;
      case GLX_CONTEXT_ES2_PROFILE_BIT_EXT:
	 *api = __DRI_API_GLES2;
	 break;
      default:
	 *error = __DRI_CTX_ERROR_BAD_API;
	 return false;
      }
   }

   /* Unknown flag value.
    */
   if (*flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_FORWARD_COMPATIBLE
                  | __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS)) {
      *error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
      return false;
   }

   /* There are no forward-compatible contexts before OpenGL 3.0.  The
    * GLX_ARB_create_context spec says:
    *
    *     "Forward-compatible contexts are defined only for OpenGL versions
    *     3.0 and later."
    */
   if (*major_ver < 3 && (*flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0) {
      *error = __DRI_CTX_ERROR_BAD_FLAG;
      return false;
   }

   if (*major_ver >= 3 && *render_type == GLX_COLOR_INDEX_TYPE) {
      *error = __DRI_CTX_ERROR_BAD_FLAG;
      return false;
   }

   /* The GLX_EXT_create_context_es2_profile spec says:
    *
    *     "... If the version requested is 2.0, and the
    *     GLX_CONTEXT_ES2_PROFILE_BIT_EXT bit is set in the
    *     GLX_CONTEXT_PROFILE_MASK_ARB attribute (see below), then the context
    *     returned will implement OpenGL ES 2.0. This is the only way in which
    *     an implementation may request an OpenGL ES 2.0 context."
    */
   if (*api == __DRI_API_GLES2 && (*major_ver != 2 || *minor_ver != 0)) {
      *error = __DRI_CTX_ERROR_BAD_API;
      return false;
   }

   *error = __DRI_CTX_ERROR_SUCCESS;
   return true;
@


1.1.1.3
log
@Import Mesa 9.2.1
@
text
@a472 7
   *major_ver = 1;
   *minor_ver = 0;
   *render_type = GLX_RGBA_TYPE;
   *reset = __DRI_CTX_RESET_NO_NOTIFICATION;
   *flags = 0;
   *api = __DRI_API_OPENGL;

d474 1
d485 5
d529 1
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@a42 1
#include "loader.h"
d51 4
d56 1
a56 1
dri_message(int level, const char *f, ...)
d59 1
a59 2
   int threshold = _LOADER_WARNING;
   const char *libgl_debug;
d61 5
a65 6
   libgl_debug = getenv("LIBGL_DEBUG");
   if (libgl_debug) {
      if (strstr(libgl_debug, "quiet"))
         threshold = _LOADER_FATAL;
      else if (strstr(libgl_debug, "verbose"))
         threshold = _LOADER_DEBUG;
d67 32
d100 2
a101 3
   /* Note that the _LOADER_* levels are lower numbers for more severe. */
   if (level <= threshold) {
      fprintf(stderr, "libGL%s: ", level <= _LOADER_WARNING ? " error" : "");
d105 3
a189 29
_X_HIDDEN const __DRIextension **
driGetDriverExtensions(void *handle, const char *driver_name)
{
   const __DRIextension **extensions = NULL;
   const __DRIextension **(*get_extensions)(void);
   char *get_extensions_name;

   if (asprintf(&get_extensions_name, "%s_%s",
                __DRI_DRIVER_GET_EXTENSIONS, driver_name) != -1) {
      get_extensions = dlsym(handle, get_extensions_name);
      if (get_extensions) {
         free(get_extensions_name);
         return get_extensions();
      } else {
         InfoMessageF("driver does not expose %s(): %s\n",
                      get_extensions_name, dlerror());
         free(get_extensions_name);
      }
   }

   extensions = dlsym(handle, __DRI_DRIVER_EXTENSIONS);
   if (extensions == NULL) {
      ErrorMessageF("driver exports no extensions (%s)\n", dlerror());
      return NULL;
   }

   return extensions;
}

d197 1
a197 1
   return __glxGetMscRate(glxDraw->psc, numerator, denominator);
d201 3
a203 4
   .base = {__DRI_SYSTEM_TIME, 1 },

   .getUST              = __glXGetUST,
   .getMSCRate          = __driGetMSCRate
a398 3
      return NULL;

   if (glxDrawable == None)
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d143 1
a143 1
         InfoMessageF("dlopen %s failed (%s)\n", realDriverName, dlerror());
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d143 1
a143 1
         ErrorMessageF("dlopen %s failed (%s)\n", realDriverName, dlerror());
@


