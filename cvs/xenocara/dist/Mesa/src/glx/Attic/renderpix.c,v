head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.46;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2013.09.05.14.03.45;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.13;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.38;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.41;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

/*
 * (C) Copyright IBM Corporation 2005
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * IBM,
 * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include "packrender.h"
#include "indirect.h"

/**
 * Send a large image to the server.  If necessary, a buffer is allocated
 * to hold the unpacked data that is copied from the clients memory.
 * 
 * \param gc        Current GLX context
 * \param compsize  Size, in bytes, of the image portion
 * \param dim       Number of dimensions of the image
 * \param width     Width of the image
 * \param height    Height of the image, must be 1 for 1D images
 * \param depth     Depth of the image, must be 1 for 1D or 2D images
 * \param format    Format of the image
 * \param type      Data type of the image
 * \param src       Pointer to the image data
 * \param pc        Pointer to end of the command header
 * \param modes     Pointer to the pixel unpack data
 *
 * \todo
 * Modify this function so that \c NULL images are sent using
 * \c __glXSendLargeChunk instead of __glXSendLargeCommand.  Doing this
 * will eliminate the need to allocate a buffer for that case.
 */
void
__glXSendLargeImage(struct glx_context * gc, GLint compsize, GLint dim,
                    GLint width, GLint height, GLint depth,
                    GLenum format, GLenum type, const GLvoid * src,
                    GLubyte * pc, GLubyte * modes)
{
    /* Allocate a temporary holding buffer */
    GLubyte *buf = malloc(compsize);
    if (!buf) {
	__glXSetError(gc, GL_OUT_OF_MEMORY);
	return;
    }

    /* Apply pixel store unpack modes to copy data into buf */
    if (src != NULL) {
	(*gc->fillImage) (gc, dim, width, height, depth, format, type,
			  src, buf, modes);
    }
    else {
	if (dim < 3) {
	    (void) memcpy(modes, __glXDefaultPixelStore + 4, 20);
	}
	else {
	    (void) memcpy(modes, __glXDefaultPixelStore + 0, 36);
	}
    }

    /* Send large command */
    __glXSendLargeCommand(gc, gc->pc, pc - gc->pc, buf, compsize);

    /* Free buffer */
    free((char *) buf);
}

/************************************************************************/

/**
 * Implement GLX protocol for \c glSeparableFilter2D.
 */
void
__indirect_glSeparableFilter2D(GLenum target, GLenum internalformat,
                               GLsizei width, GLsizei height, GLenum format,
                               GLenum type, const GLvoid * row,
                               const GLvoid * column)
{
   __GLX_DECLARE_VARIABLES();
   GLuint compsize2, hdrlen, totalhdrlen, image1len, image2len;

   __GLX_LOAD_VARIABLES();
   compsize = __glImageSize(width, 1, 1, format, type, 0);
   compsize2 = __glImageSize(height, 1, 1, format, type, 0);
   totalhdrlen = __GLX_PAD(__GLX_CONV_FILT_CMD_HDR_SIZE);
   hdrlen = __GLX_PAD(__GLX_CONV_FILT_HDR_SIZE);
   image1len = __GLX_PAD(compsize);
   image2len = __GLX_PAD(compsize2);
   cmdlen = totalhdrlen + image1len + image2len;
   if (!gc->currentDpy)
      return;

   if (cmdlen <= gc->maxSmallRenderCommandSize) {
      /* Use GLXRender protocol to send small command */
      __GLX_BEGIN_VARIABLE_WITH_PIXEL(X_GLrop_SeparableFilter2D, cmdlen);
      __GLX_PUT_LONG(0, target);
      __GLX_PUT_LONG(4, internalformat);
      __GLX_PUT_LONG(8, width);
      __GLX_PUT_LONG(12, height);
      __GLX_PUT_LONG(16, format);
      __GLX_PUT_LONG(20, type);
      pc += hdrlen;
      if (compsize > 0) {
         (*gc->fillImage) (gc, 1, width, 1, 1, format, type,
                           row, pc, pixelHeaderPC);
         pc += image1len;
      }
      if (compsize2 > 0) {
         (*gc->fillImage) (gc, 1, height, 1, 1, format, type,
                           column, pc, NULL);
         pc += image2len;
      }
      if ((compsize == 0) && (compsize2 == 0)) {
         /* Setup default store modes */
         (void) memcpy(pixelHeaderPC, __glXDefaultPixelStore + 4, 20);
      }
      __GLX_END(0);
   }
   else {
      GLubyte *buf;
      const GLint bufsize = image1len + image2len;

      /* Use GLXRenderLarge protocol to send command */
      __GLX_BEGIN_VARIABLE_LARGE_WITH_PIXEL(X_GLrop_SeparableFilter2D,
                                            cmdlen + 4);
      __GLX_PUT_LONG(0, target);
      __GLX_PUT_LONG(4, internalformat);
      __GLX_PUT_LONG(8, width);
      __GLX_PUT_LONG(12, height);
      __GLX_PUT_LONG(16, format);
      __GLX_PUT_LONG(20, type);
      pc += hdrlen;

      /* Allocate a temporary holding buffer */
      buf = malloc(bufsize);
      if (!buf) {
         __glXSetError(gc, GL_OUT_OF_MEMORY);
         return;
      }
      (*gc->fillImage) (gc, 1, width, 1, 1, format, type, row, buf,
                        pixelHeaderPC);

      (*gc->fillImage) (gc, 1, height, 1, 1, format, type, column,
                        buf + image1len, pixelHeaderPC);

      /* Send large command */
      __glXSendLargeCommand(gc, gc->pc, (GLint) (pc - gc->pc), buf,
                            bufsize);
      /* Free buffer */
      free((char *) buf);
   }
}
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d87 1
a87 1
    GLubyte *buf = (GLubyte *) Xmalloc(compsize);
d111 1
a111 1
    Xfree((char *) buf);
d181 1
a181 1
      buf = (GLubyte *) Xmalloc(bufsize);
d196 1
a196 1
      Xfree((char *) buf);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a78 4
 *
 * \bugs
 * The \c fastImageUnpack path, which is thankfully never used, is completely
 * broken.
d86 20
a105 21
   if (!gc->fastImageUnpack || (src == NULL)) {
      /* Allocate a temporary holding buffer */
      GLubyte *buf = (GLubyte *) Xmalloc(compsize);
      if (!buf) {
         __glXSetError(gc, GL_OUT_OF_MEMORY);
         return;
      }

      /* Apply pixel store unpack modes to copy data into buf */
      if (src != NULL) {
         (*gc->fillImage) (gc, dim, width, height, depth, format, type,
                           src, buf, modes);
      }
      else {
         if (dim < 3) {
            (void) memcpy(modes, __glXDefaultPixelStore + 4, 20);
         }
         else {
            (void) memcpy(modes, __glXDefaultPixelStore + 0, 36);
         }
      }
d107 2
a108 2
      /* Send large command */
      __glXSendLargeCommand(gc, gc->pc, pc - gc->pc, buf, compsize);
d110 2
a111 7
      /* Free buffer */
      Xfree((char *) buf);
   }
   else {
      /* Just send the data straight as is */
      __glXSendLargeCommand(gc, gc->pc, pc - gc->pc, pc, compsize);
   }
a117 4
 *
 * \bugs
 * The \c fastImageUnpack path, which is thankfully never used, is completely
 * broken.
d166 1
d180 5
a184 23
      if (!gc->fastImageUnpack) {
         /* Allocate a temporary holding buffer */
         GLubyte *buf = (GLubyte *) Xmalloc(bufsize);
         if (!buf) {
            __glXSetError(gc, GL_OUT_OF_MEMORY);
            return;
         }
         (*gc->fillImage) (gc, 1, width, 1, 1, format, type, row, buf,
                           pixelHeaderPC);

         (*gc->fillImage) (gc, 1, height, 1, 1, format, type, column,
                           buf + image1len, pixelHeaderPC);

         /* Send large command */
         __glXSendLargeCommand(gc, gc->pc, (GLint) (pc - gc->pc), buf,
                               bufsize);
         /* Free buffer */
         Xfree((char *) buf);
      }
      else {
         /* Just send the data straight as is */
         __glXSendLargeCommand(gc, gc->pc, (GLint) (pc - gc->pc), pc,
                               bufsize);
d186 11
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d85 1
a85 1
__glXSendLargeImage(__GLXcontext * gc, GLint compsize, GLint dim,
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d85 1
a85 1
__glXSendLargeImage(struct glx_context * gc, GLint compsize, GLint dim,
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d79 4
d90 7
a96 20
    /* Allocate a temporary holding buffer */
    GLubyte *buf = malloc(compsize);
    if (!buf) {
	__glXSetError(gc, GL_OUT_OF_MEMORY);
	return;
    }

    /* Apply pixel store unpack modes to copy data into buf */
    if (src != NULL) {
	(*gc->fillImage) (gc, dim, width, height, depth, format, type,
			  src, buf, modes);
    }
    else {
	if (dim < 3) {
	    (void) memcpy(modes, __glXDefaultPixelStore + 4, 20);
	}
	else {
	    (void) memcpy(modes, __glXDefaultPixelStore + 0, 36);
	}
    }
d98 16
a113 2
    /* Send large command */
    __glXSendLargeCommand(gc, gc->pc, pc - gc->pc, buf, compsize);
d115 7
a121 2
    /* Free buffer */
    free((char *) buf);
d128 4
a179 1
      GLubyte *buf;
d193 23
a215 5
      /* Allocate a temporary holding buffer */
      buf = malloc(bufsize);
      if (!buf) {
         __glXSetError(gc, GL_OUT_OF_MEMORY);
         return;
a216 11
      (*gc->fillImage) (gc, 1, width, 1, 1, format, type, row, buf,
                        pixelHeaderPC);

      (*gc->fillImage) (gc, 1, height, 1, 1, format, type, column,
                        buf + image1len, pixelHeaderPC);

      /* Send large command */
      __glXSendLargeCommand(gc, gc->pc, (GLint) (pc - gc->pc), buf,
                            bufsize);
      /* Free buffer */
      free((char *) buf);
@


