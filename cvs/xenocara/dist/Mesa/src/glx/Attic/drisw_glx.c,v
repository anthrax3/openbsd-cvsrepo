head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.45;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.22.09.30.34;	author jsg;	state Exp;
branches;
next	1.10;
commitid	yhStanAcs6cSYmBc;

1.10
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.08.58;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.10.05.09.53.57;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.09.05.14.03.43;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.11.11.12.18.31;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.13;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2012.07.07.12.03.53;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.38;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.37;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.10.05.09.24.22;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.33;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.10.38;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.47.44;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2008 George Sapountzis
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)

#include <X11/Xlib.h>
#include "glxclient.h"
#include <dlfcn.h>
#include "dri_common.h"
#include "drisw_priv.h"

static Bool
XCreateDrawable(struct drisw_drawable * pdp,
                Display * dpy, XID drawable, int visualid)
{
   XGCValues gcvalues;
   long visMask;
   XVisualInfo visTemp;
   int num_visuals;

   /* create GC's */
   pdp->gc = XCreateGC(dpy, drawable, 0, NULL);
   pdp->swapgc = XCreateGC(dpy, drawable, 0, NULL);

   gcvalues.function = GXcopy;
   gcvalues.graphics_exposures = False;
   XChangeGC(dpy, pdp->gc, GCFunction, &gcvalues);
   XChangeGC(dpy, pdp->swapgc, GCFunction, &gcvalues);
   XChangeGC(dpy, pdp->swapgc, GCGraphicsExposures, &gcvalues);

   /* visual */
   visTemp.visualid = visualid;
   visMask = VisualIDMask;
   pdp->visinfo = XGetVisualInfo(dpy, visMask, &visTemp, &num_visuals);

   if (!pdp->visinfo || num_visuals == 0)
      return False;

   /* create XImage */
   pdp->ximage = XCreateImage(dpy,
                              pdp->visinfo->visual,
                              pdp->visinfo->depth,
                              ZPixmap, 0,             /* format, offset */
                              NULL,                   /* data */
                              0, 0,                   /* width, height */
                              32,                     /* bitmap_pad */
                              0);                     /* bytes_per_line */

  /**
   * swrast does not handle 24-bit depth with 24 bpp, so let X do the
   * the conversion for us.
   */
  if (pdp->ximage->bits_per_pixel == 24)
     pdp->ximage->bits_per_pixel = 32;

   return True;
}

static void
XDestroyDrawable(struct drisw_drawable * pdp, Display * dpy, XID drawable)
{
   XDestroyImage(pdp->ximage);
   free(pdp->visinfo);

   XFreeGC(dpy, pdp->gc);
   XFreeGC(dpy, pdp->swapgc);
}

/**
 * swrast loader functions
 */

static void
swrastGetDrawableInfo(__DRIdrawable * draw,
                      int *x, int *y, int *w, int *h,
                      void *loaderPrivate)
{
   struct drisw_drawable *pdp = loaderPrivate;
   __GLXDRIdrawable *pdraw = &(pdp->base);
   Display *dpy = pdraw->psc->dpy;
   Drawable drawable;

   Window root;
   unsigned uw, uh, bw, depth;

   drawable = pdraw->xDrawable;

   XGetGeometry(dpy, drawable, &root, x, y, &uw, &uh, &bw, &depth);
   *w = uw;
   *h = uh;
}

/**
 * Align renderbuffer pitch.
 *
 * This should be chosen by the driver and the loader (libGL, xserver/glx)
 * should use the driver provided pitch.
 *
 * It seems that the xorg loader (that is the xserver loading swrast_dri for
 * indirect rendering, not client-side libGL) requires that the pitch is
 * exactly the image width padded to 32 bits. XXX
 *
 * The above restriction can probably be overcome by using ScratchPixmap and
 * CopyArea in the xserver, similar to ShmPutImage, and setting the width of
 * the scratch pixmap to 'pitch / cpp'.
 */
static inline int
bytes_per_line(unsigned pitch_bits, unsigned mul)
{
   unsigned mask = mul - 1;

   return ((pitch_bits + mask) & ~mask) / 8;
}

static void
swrastPutImage2(__DRIdrawable * draw, int op,
                int x, int y, int w, int h, int stride,
                char *data, void *loaderPrivate)
{
   struct drisw_drawable *pdp = loaderPrivate;
   __GLXDRIdrawable *pdraw = &(pdp->base);
   Display *dpy = pdraw->psc->dpy;
   Drawable drawable;
   XImage *ximage;
   GC gc;

   switch (op) {
   case __DRI_SWRAST_IMAGE_OP_DRAW:
      gc = pdp->gc;
      break;
   case __DRI_SWRAST_IMAGE_OP_SWAP:
      gc = pdp->swapgc;
      break;
   default:
      return;
   }

   drawable = pdraw->xDrawable;

   ximage = pdp->ximage;
   ximage->data = data;
   ximage->width = w;
   ximage->height = h;
   ximage->bytes_per_line = stride ? stride : bytes_per_line(w * ximage->bits_per_pixel, 32);

   XPutImage(dpy, drawable, gc, ximage, 0, 0, x, y, w, h);

   ximage->data = NULL;
}

static void
swrastPutImage(__DRIdrawable * draw, int op,
               int x, int y, int w, int h,
               char *data, void *loaderPrivate)
{
   swrastPutImage2(draw, op, x, y, w, h, 0, data, loaderPrivate);
}

static void
swrastGetImage(__DRIdrawable * read,
               int x, int y, int w, int h,
               char *data, void *loaderPrivate)
{
   struct drisw_drawable *prp = loaderPrivate;
   __GLXDRIdrawable *pread = &(prp->base);
   Display *dpy = pread->psc->dpy;
   Drawable readable;
   XImage *ximage;

   readable = pread->xDrawable;

   ximage = prp->ximage;
   ximage->data = data;
   ximage->width = w;
   ximage->height = h;
   ximage->bytes_per_line = bytes_per_line(w * ximage->bits_per_pixel, 32);

   XGetSubImage(dpy, readable, x, y, w, h, ~0L, ZPixmap, ximage, 0, 0);

   ximage->data = NULL;
}

static const __DRIswrastLoaderExtension swrastLoaderExtension = {
   .base = {__DRI_SWRAST_LOADER, 2 },

   .getDrawableInfo     = swrastGetDrawableInfo,
   .putImage            = swrastPutImage,
   .getImage            = swrastGetImage,
   .putImage2           = swrastPutImage2,
};

static const __DRIextension *loader_extensions[] = {
   &systemTimeExtension.base,
   &swrastLoaderExtension.base,
   NULL
};

/**
 * GLXDRI functions
 */

static void
drisw_destroy_context(struct glx_context *context)
{
   struct drisw_context *pcp = (struct drisw_context *) context;
   struct drisw_screen *psc = (struct drisw_screen *) context->psc;

   driReleaseDrawables(&pcp->base);

   free((char *) context->extensions);

   (*psc->core->destroyContext) (pcp->driContext);

   free(pcp);
}

static int
drisw_bind_context(struct glx_context *context, struct glx_context *old,
		   GLXDrawable draw, GLXDrawable read)
{
   struct drisw_context *pcp = (struct drisw_context *) context;
   struct drisw_screen *psc = (struct drisw_screen *) pcp->base.psc;
   struct drisw_drawable *pdraw, *pread;

   pdraw = (struct drisw_drawable *) driFetchDrawable(context, draw);
   pread = (struct drisw_drawable *) driFetchDrawable(context, read);

   driReleaseDrawables(&pcp->base);

   if (pdraw == NULL || pread == NULL)
      return GLXBadDrawable;

   if ((*psc->core->bindContext) (pcp->driContext,
				  pdraw->driDrawable, pread->driDrawable))
      return Success;

   return GLXBadContext;
}

static void
drisw_unbind_context(struct glx_context *context, struct glx_context *new)
{
   struct drisw_context *pcp = (struct drisw_context *) context;
   struct drisw_screen *psc = (struct drisw_screen *) pcp->base.psc;

   (*psc->core->unbindContext) (pcp->driContext);
}

static void
drisw_bind_tex_image(Display * dpy,
		    GLXDrawable drawable,
		    int buffer, const int *attrib_list)
{
   struct glx_context *gc = __glXGetCurrentContext();
   struct drisw_context *pcp = (struct drisw_context *) gc;
   __GLXDRIdrawable *base = GetGLXDRIDrawable(dpy, drawable);
   struct drisw_drawable *pdraw = (struct drisw_drawable *) base;
   struct drisw_screen *psc;

   __glXInitialize(dpy);

   if (pdraw != NULL) {
      psc = (struct drisw_screen *) base->psc;

      if (!psc->texBuffer)
         return;

      if (psc->texBuffer->base.version >= 2 &&
        psc->texBuffer->setTexBuffer2 != NULL) {
	      (*psc->texBuffer->setTexBuffer2) (pcp->driContext,
					   pdraw->base.textureTarget,
					   pdraw->base.textureFormat,
					   pdraw->driDrawable);
      }
      else {
	      (*psc->texBuffer->setTexBuffer) (pcp->driContext,
					  pdraw->base.textureTarget,
					  pdraw->driDrawable);
      }
   }
}

static void
drisw_release_tex_image(Display * dpy, GLXDrawable drawable, int buffer)
{
   struct glx_context *gc = __glXGetCurrentContext();
   struct drisw_context *pcp = (struct drisw_context *) gc;
   __GLXDRIdrawable *base = GetGLXDRIDrawable(dpy, drawable);
   struct glx_display *dpyPriv = __glXInitialize(dpy);
   struct drisw_drawable *pdraw = (struct drisw_drawable *) base;
   struct drisw_screen *psc;

   if (dpyPriv != NULL && pdraw != NULL) {
      psc = (struct drisw_screen *) base->psc;

      if (!psc->texBuffer)
         return;

      if (psc->texBuffer->base.version >= 3 &&
          psc->texBuffer->releaseTexBuffer != NULL) {
         (*psc->texBuffer->releaseTexBuffer) (pcp->driContext,
                                           pdraw->base.textureTarget,
                                           pdraw->driDrawable);
      }
   }
}

static const struct glx_context_vtable drisw_context_vtable = {
   .destroy             = drisw_destroy_context,
   .bind                = drisw_bind_context,
   .unbind              = drisw_unbind_context,
   .wait_gl             = NULL,
   .wait_x              = NULL,
   .use_x_font          = DRI_glXUseXFont,
   .bind_tex_image      = drisw_bind_tex_image,
   .release_tex_image   = drisw_release_tex_image,
   .get_proc_address    = NULL,
};

static struct glx_context *
drisw_create_context(struct glx_screen *base,
		     struct glx_config *config_base,
		     struct glx_context *shareList, int renderType)
{
   struct drisw_context *pcp, *pcp_shared;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
   struct drisw_screen *psc = (struct drisw_screen *) base;
   __DRIcontext *shared = NULL;

   if (!psc->base.driScreen)
      return NULL;

   /* Check the renderType value */
   if (!validate_renderType_against_config(config_base, renderType))
       return NULL;

   if (shareList) {
      /* If the shareList context is not a DRISW context, we cannot possibly
       * create a DRISW context that shares it.
       */
      if (shareList->vtable->destroy != drisw_destroy_context) {
	 return NULL;
      }

      pcp_shared = (struct drisw_context *) shareList;
      shared = pcp_shared->driContext;
   }

   pcp = calloc(1, sizeof *pcp);
   if (pcp == NULL)
      return NULL;

   if (!glx_context_init(&pcp->base, &psc->base, &config->base)) {
      free(pcp);
      return NULL;
   }

   pcp->base.renderType = renderType;

   pcp->driContext =
      (*psc->core->createNewContext) (psc->driScreen,
				      config->driConfig, shared, pcp);
   if (pcp->driContext == NULL) {
      free(pcp);
      return NULL;
   }

   pcp->base.vtable = &drisw_context_vtable;

   return &pcp->base;
}

static struct glx_context *
drisw_create_context_attribs(struct glx_screen *base,
			     struct glx_config *config_base,
			     struct glx_context *shareList,
			     unsigned num_attribs,
			     const uint32_t *attribs,
			     unsigned *error)
{
   struct drisw_context *pcp, *pcp_shared;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
   struct drisw_screen *psc = (struct drisw_screen *) base;
   __DRIcontext *shared = NULL;

   uint32_t minor_ver;
   uint32_t major_ver;
   uint32_t renderType;
   uint32_t flags;
   unsigned api;
   int reset;
   uint32_t ctx_attribs[2 * 4];
   unsigned num_ctx_attribs = 0;

   if (!psc->base.driScreen)
      return NULL;

   if (psc->swrast->base.version < 3)
      return NULL;

   /* Remap the GLX tokens to DRI2 tokens.
    */
   if (!dri2_convert_glx_attribs(num_attribs, attribs,
                                 &major_ver, &minor_ver, &renderType, &flags,
                                 &api, &reset, error))
      return NULL;

   /* Check the renderType value */
   if (!validate_renderType_against_config(config_base, renderType)) {
       return NULL;
   }

   if (reset != __DRI_CTX_RESET_NO_NOTIFICATION)
      return NULL;

   if (shareList) {
      pcp_shared = (struct drisw_context *) shareList;
      shared = pcp_shared->driContext;
   }

   pcp = calloc(1, sizeof *pcp);
   if (pcp == NULL)
      return NULL;

   if (!glx_context_init(&pcp->base, &psc->base, &config->base)) {
      free(pcp);
      return NULL;
   }

   ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_MAJOR_VERSION;
   ctx_attribs[num_ctx_attribs++] = major_ver;
   ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_MINOR_VERSION;
   ctx_attribs[num_ctx_attribs++] = minor_ver;

   if (flags != 0) {
      ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_FLAGS;

      /* The current __DRI_CTX_FLAG_* values are identical to the
       * GLX_CONTEXT_*_BIT values.
       */
      ctx_attribs[num_ctx_attribs++] = flags;
   }

   pcp->base.renderType = renderType;

   pcp->driContext =
      (*psc->swrast->createContextAttribs) (psc->driScreen,
					    api,
					    config->driConfig,
					    shared,
					    num_ctx_attribs / 2,
					    ctx_attribs,
					    error,
					    pcp);
   if (pcp->driContext == NULL) {
      free(pcp);
      return NULL;
   }

   pcp->base.vtable = &drisw_context_vtable;

   return &pcp->base;
}

static void
driswDestroyDrawable(__GLXDRIdrawable * pdraw)
{
   struct drisw_drawable *pdp = (struct drisw_drawable *) pdraw;
   struct drisw_screen *psc = (struct drisw_screen *) pdp->base.psc;

   (*psc->core->destroyDrawable) (pdp->driDrawable);

   XDestroyDrawable(pdp, pdraw->psc->dpy, pdraw->drawable);
   free(pdp);
}

static __GLXDRIdrawable *
driswCreateDrawable(struct glx_screen *base, XID xDrawable,
		    GLXDrawable drawable, struct glx_config *modes)
{
   struct drisw_drawable *pdp;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) modes;
   struct drisw_screen *psc = (struct drisw_screen *) base;
   Bool ret;
   const __DRIswrastExtension *swrast = psc->swrast;

   pdp = calloc(1, sizeof(*pdp));
   if (!pdp)
      return NULL;

   pdp->base.xDrawable = xDrawable;
   pdp->base.drawable = drawable;
   pdp->base.psc = &psc->base;

   ret = XCreateDrawable(pdp, psc->base.dpy, xDrawable, modes->visualID);
   if (!ret) {
      free(pdp);
      return NULL;
   }

   /* Create a new drawable */
   pdp->driDrawable =
      (*swrast->createNewDrawable) (psc->driScreen, config->driConfig, pdp);

   if (!pdp->driDrawable) {
      XDestroyDrawable(pdp, psc->base.dpy, xDrawable);
      free(pdp);
      return NULL;
   }

   pdp->base.destroyDrawable = driswDestroyDrawable;

   return &pdp->base;
}

static int64_t
driswSwapBuffers(__GLXDRIdrawable * pdraw,
                 int64_t target_msc, int64_t divisor, int64_t remainder,
                 Bool flush)
{
   struct drisw_drawable *pdp = (struct drisw_drawable *) pdraw;
   struct drisw_screen *psc = (struct drisw_screen *) pdp->base.psc;

   (void) target_msc;
   (void) divisor;
   (void) remainder;

   if (flush) {
      glFlush();
   }

   (*psc->core->swapBuffers) (pdp->driDrawable);

   return 0;
}

static void
driswCopySubBuffer(__GLXDRIdrawable * pdraw,
                   int x, int y, int width, int height, Bool flush)
{
   struct drisw_drawable *pdp = (struct drisw_drawable *) pdraw;
   struct drisw_screen *psc = (struct drisw_screen *) pdp->base.psc;

   if (flush) {
      glFlush();
   }

   (*psc->copySubBuffer->copySubBuffer) (pdp->driDrawable,
					    x, y, width, height);
}

static void
driswDestroyScreen(struct glx_screen *base)
{
   struct drisw_screen *psc = (struct drisw_screen *) base;

   /* Free the direct rendering per screen data */
   (*psc->core->destroyScreen) (psc->driScreen);
   driDestroyConfigs(psc->driver_configs);
   psc->driScreen = NULL;
   if (psc->driver)
      dlclose(psc->driver);
   free(psc);
}

#define SWRAST_DRIVER_NAME "swrast"

static void *
driOpenSwrast(void)
{
   void *driver = NULL;

   if (driver == NULL)
      driver = driOpenDriver(SWRAST_DRIVER_NAME);

   return driver;
}

static const struct glx_screen_vtable drisw_screen_vtable = {
   .create_context         = drisw_create_context,
   .create_context_attribs = drisw_create_context_attribs,
   .query_renderer_integer = drisw_query_renderer_integer,
   .query_renderer_string  = drisw_query_renderer_string,
};

static void
driswBindExtensions(struct drisw_screen *psc, const __DRIextension **extensions)
{
   int i;

   __glXEnableDirectExtension(&psc->base, "GLX_SGI_make_current_read");

   if (psc->swrast->base.version >= 3) {
      __glXEnableDirectExtension(&psc->base, "GLX_ARB_create_context");
      __glXEnableDirectExtension(&psc->base, "GLX_ARB_create_context_profile");

      /* DRISW version >= 2 implies support for OpenGL ES 2.0.
       */
      __glXEnableDirectExtension(&psc->base,
				 "GLX_EXT_create_context_es2_profile");
   }

   if (psc->copySubBuffer)
      __glXEnableDirectExtension(&psc->base, "GLX_MESA_copy_sub_buffer");      

   /* FIXME: Figure out what other extensions can be ported here from dri2. */
   for (i = 0; extensions[i]; i++) {
      if ((strcmp(extensions[i]->name, __DRI_TEX_BUFFER) == 0)) {
	 psc->texBuffer = (__DRItexBufferExtension *) extensions[i];
	 __glXEnableDirectExtension(&psc->base, "GLX_EXT_texture_from_pixmap");
      }
      /* DRISW version 3 is also required because GLX_MESA_query_renderer
       * requires GLX_ARB_create_context_profile.
       */
      if (psc->swrast->base.version >= 3
          && strcmp(extensions[i]->name, __DRI2_RENDERER_QUERY) == 0) {
         psc->rendererQuery = (__DRI2rendererQueryExtension *) extensions[i];
         __glXEnableDirectExtension(&psc->base, "GLX_MESA_query_renderer");
      }
   }
}

static struct glx_screen *
driswCreateScreen(int screen, struct glx_display *priv)
{
   __GLXDRIscreen *psp;
   const __DRIconfig **driver_configs;
   const __DRIextension **extensions;
   struct drisw_screen *psc;
   struct glx_config *configs = NULL, *visuals = NULL;
   int i;

   psc = calloc(1, sizeof *psc);
   if (psc == NULL)
      return NULL;

   if (!glx_screen_init(&psc->base, screen, priv)) {
      free(psc);
      return NULL;
   }

   psc->driver = driOpenSwrast();
   if (psc->driver == NULL)
      goto handle_error;

   extensions = driGetDriverExtensions(psc->driver, SWRAST_DRIVER_NAME);
   if (extensions == NULL)
      goto handle_error;

   for (i = 0; extensions[i]; i++) {
      if (strcmp(extensions[i]->name, __DRI_CORE) == 0)
	 psc->core = (__DRIcoreExtension *) extensions[i];
      if (strcmp(extensions[i]->name, __DRI_SWRAST) == 0)
	 psc->swrast = (__DRIswrastExtension *) extensions[i];
      if (strcmp(extensions[i]->name, __DRI_COPY_SUB_BUFFER) == 0)
	 psc->copySubBuffer = (__DRIcopySubBufferExtension *) extensions[i];
   }

   if (psc->core == NULL || psc->swrast == NULL) {
      ErrorMessageF("core dri extension not found\n");
      goto handle_error;
   }

   if (psc->swrast->base.version >= 4) {
      psc->driScreen =
         psc->swrast->createNewScreen2(screen, loader_extensions,
                                       extensions,
                                       &driver_configs, psc);
   } else {
      psc->driScreen =
         psc->swrast->createNewScreen(screen, loader_extensions,
                                      &driver_configs, psc);
   }
   if (psc->driScreen == NULL) {
      ErrorMessageF("failed to create dri screen\n");
      goto handle_error;
   }

   extensions = psc->core->getExtensions(psc->driScreen);
   driswBindExtensions(psc, extensions);

   configs = driConvertConfigs(psc->core, psc->base.configs, driver_configs);
   visuals = driConvertConfigs(psc->core, psc->base.visuals, driver_configs);

   if (!configs || !visuals)
       goto handle_error;

   glx_config_destroy_list(psc->base.configs);
   psc->base.configs = configs;
   glx_config_destroy_list(psc->base.visuals);
   psc->base.visuals = visuals;

   psc->driver_configs = driver_configs;

   psc->base.vtable = &drisw_screen_vtable;
   psp = &psc->vtable;
   psc->base.driScreen = psp;
   psp->destroyScreen = driswDestroyScreen;
   psp->createDrawable = driswCreateDrawable;
   psp->swapBuffers = driswSwapBuffers;

   if (psc->copySubBuffer)
      psp->copySubBuffer = driswCopySubBuffer;

   return &psc->base;

 handle_error:
   if (configs)
       glx_config_destroy_list(configs);
   if (visuals)
       glx_config_destroy_list(visuals);
   if (psc->driScreen)
       psc->core->destroyScreen(psc->driScreen);
   psc->driScreen = NULL;

   if (psc->driver)
      dlclose(psc->driver);
   glx_screen_cleanup(&psc->base);
   free(psc);

   CriticalErrorMessageF("failed to load driver: %s\n", SWRAST_DRIVER_NAME);

   return NULL;
}

/* Called from __glXFreeDisplayPrivate.
 */
static void
driswDestroyDisplay(__GLXDRIdisplay * dpy)
{
   free(dpy);
}

/*
 * Allocate, initialize and return a __DRIdisplayPrivate object.
 * This is called from __glXInitialize() when we are given a new
 * display pointer.
 */
_X_HIDDEN __GLXDRIdisplay *
driswCreateDisplay(Display * dpy)
{
   struct drisw_display *pdpyp;

   pdpyp = malloc(sizeof *pdpyp);
   if (pdpyp == NULL)
      return NULL;

   pdpyp->base.destroyDisplay = driswDestroyDisplay;
   pdpyp->base.createScreen = driswCreateScreen;

   return &pdpyp->base;
}

#endif /* GLX_DIRECT_RENDERING */
@


1.11
log
@Backport support for GLX_MESA_query_renderer for non Intel drivers.
This is desirable as the chromium port now uses this extension to
obtain pci vendor/device ids for use in feature/extension blacklists.

Prompted by a mail from byrnet@@, tested on r600g by krw@@

The newly added os_get_total_physical_memory() was passing the length of
a pointer rather than the type which made the sysctl call fail on
non 64 bit archs.  And it was passing the wrong pointer for the result.
Fixes for these problems have been submitted back upstream.
@
text
@@


1.10
log
@Merge Mesa 10.2.9
@
text
@d30 1
a30 40

struct drisw_display
{
   __GLXDRIdisplay base;
};

struct drisw_context
{
   struct glx_context base;
   __DRIcontext *driContext;

};

struct drisw_screen
{
   struct glx_screen base;

   __DRIscreen *driScreen;
   __GLXDRIscreen vtable;
   const __DRIcoreExtension *core;
   const __DRIswrastExtension *swrast;
   const __DRItexBufferExtension *texBuffer;
   const __DRIcopySubBufferExtension *copySubBuffer;

   const __DRIconfig **driver_configs;

   void *driver;
};

struct drisw_drawable
{
   __GLXDRIdrawable base;

   GC gc;
   GC swapgc;

   __DRIdrawable *driDrawable;
   XVisualInfo *visinfo;
   XImage *ximage;
};
d602 2
a603 2
   .query_renderer_integer = NULL,
   .query_renderer_string  = NULL,
d631 8
@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d30 40
a69 1
#include "drisw_priv.h"
d641 2
a642 2
   .query_renderer_integer = drisw_query_renderer_integer,
   .query_renderer_string  = drisw_query_renderer_string,
a670 8
      /* DRISW version 3 is also required because GLX_MESA_query_renderer
       * requires GLX_ARB_create_context_profile.
       */
      if (psc->swrast->base.version >= 3
          && strcmp(extensions[i]->name, __DRI2_RENDERER_QUERY) == 0) {
         psc->rendererQuery = (__DRI2rendererQueryExtension *) extensions[i];
         __glXEnableDirectExtension(&psc->base, "GLX_MESA_query_renderer");
      }
d736 1
a736 2
   if (!configs || !visuals) {
       ErrorMessageF("No matching fbConfigs or visuals found\n");
a737 1
   }
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d30 1
a30 40

struct drisw_display
{
   __GLXDRIdisplay base;
};

struct drisw_context
{
   struct glx_context base;
   __DRIcontext *driContext;

};

struct drisw_screen
{
   struct glx_screen base;

   __DRIscreen *driScreen;
   __GLXDRIscreen vtable;
   const __DRIcoreExtension *core;
   const __DRIswrastExtension *swrast;
   const __DRItexBufferExtension *texBuffer;
   const __DRIcopySubBufferExtension *copySubBuffer;

   const __DRIconfig **driver_configs;

   void *driver;
};

struct drisw_drawable
{
   __GLXDRIdrawable base;

   GC gc;
   GC swapgc;

   __DRIdrawable *driDrawable;
   XVisualInfo *visinfo;
   XImage *ximage;
};
d602 2
a603 2
   .query_renderer_integer = NULL,
   .query_renderer_string  = NULL,
d632 8
d705 2
a706 1
   if (!configs || !visuals)
d708 1
@


1.7
log
@Merge Mesa 9.2.1
@
text
@d52 1
d175 3
a177 3
swrastPutImage(__DRIdrawable * draw, int op,
               int x, int y, int w, int h,
               char *data, void *loaderPrivate)
d203 1
a203 1
   ximage->bytes_per_line = bytes_per_line(w * ximage->bits_per_pixel, 32);
d211 8
d243 6
a248 4
   {__DRI_SWRAST_LOADER, __DRI_SWRAST_LOADER_VERSION},
   swrastGetDrawableInfo,
   swrastPutImage,
   swrastGetImage
a344 1
#if __DRI_TEX_BUFFER_VERSION >= 3
d346 1
a346 1
   struct dri2_context *pcp = (struct dri2_context *) gc;
d349 2
a350 2
   struct dri2_drawable *pdraw = (struct dri2_drawable *) base;
   struct dri2_screen *psc;
d352 2
a353 2
   if (pdraw != NULL) {
      psc = (struct dri2_screen *) base->psc;
a364 1
#endif
d368 9
a376 9
   drisw_destroy_context,
   drisw_bind_context,
   drisw_unbind_context,
   NULL,
   NULL,
   DRI_glXUseXFont,
   drisw_bind_tex_image,
   drisw_release_tex_image,
   NULL, /* get_proc_address */
d597 15
d622 1
d639 4
a642 2
   drisw_create_context,
   drisw_create_context_attribs
d662 3
d697 2
a698 3
   extensions = dlsym(psc->driver, __DRI_DRIVER_EXTENSIONS);
   if (extensions == NULL) {
      ErrorMessageF("driver exports no extensions (%s)\n", dlerror());
a699 1
   }
d706 2
d715 10
a724 3
   psc->driScreen =
      psc->swrast->createNewScreen(screen, loader_extensions,
				   &driver_configs, psc);
d752 3
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d436 4
a439 4
   uint32_t minor_ver = 1;
   uint32_t major_ver = 0;
   uint32_t renderType = GLX_RGBA_TYPE;
   uint32_t flags = 0;
d441 1
a441 1
   int reset = __DRI_CTX_RESET_NO_NOTIFICATION;
@


1.5
log
@Try to load the gallium3d "swrastg" driver if available before falling back
to the default mesa "swrast" one for software rendering.

ok matthieu@@
@
text
@d51 2
a89 1
   visTemp.screen = DefaultScreen(dpy);
d91 1
a91 1
   visMask = (VisualScreenMask | VisualIDMask);
d94 3
d121 1
a121 1
   XFree(pdp->visinfo);
d258 1
a258 5
   if (context->xid)
      glx_send_destroy_context(psc->base.dpy, context->xid);

   if (context->extensions)
      XFree((char *) context->extensions);
d262 1
a262 1
   Xfree(pcp);
d297 61
d365 2
a366 2
   NULL,
   NULL,
d383 4
d388 7
d399 1
a399 1
   pcp = Xmalloc(sizeof *pcp);
a402 1
   memset(pcp, 0, sizeof *pcp);
d404 1
a404 1
      Xfree(pcp);
d408 2
d414 93
a506 1
      Xfree(pcp);
d524 1
a524 1
   Xfree(pdp);
d534 1
a534 1

d537 1
a537 1
   pdp = Xmalloc(sizeof(*pdp));
a540 1
   memset(pdp, 0, sizeof *pdp);
d545 5
a549 1
   XCreateDrawable(pdp, psc->base.dpy, xDrawable, modes->visualID);
d557 1
a557 1
      Xfree(pdp);
d568 2
a569 1
                 int64_t target_msc, int64_t divisor, int64_t remainder)
d578 4
d600 2
d608 1
a608 4
      driver = driOpenDriver("swrastg");

   if (driver == NULL)
      driver = driOpenDriver("swrast");
d614 2
a615 1
   drisw_create_context
d618 26
d651 1
d654 1
a654 1
   psc = Xcalloc(1, sizeof *psc);
a657 1
   memset(psc, 0, sizeof *psc);
d659 1
a659 1
      Xfree(psc);
d693 13
a705 4
   psc->base.configs =
      driConvertConfigs(psc->core, psc->base.configs, driver_configs);
   psc->base.visuals =
      driConvertConfigs(psc->core, psc->base.visuals, driver_configs);
d719 8
d730 1
a730 1
   Xfree(psc);
d732 1
a732 1
   ErrorMessageF("reverting to indirect rendering\n");
d742 1
a742 1
   Xfree(dpy);
d755 1
a755 1
   pdpyp = Xmalloc(sizeof *pdpyp);
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d433 1
a433 1
      driver = driOpenDriver("swrast");
d436 1
a436 1
      driver = driOpenDriver("swrastg");
@


1.3
log
@Unbreak GLX1.3 ctors with software dri, this makes clutter/cogl works with
software accleration.

Upstream commit d44f821213d7ed67fed18d6ea6c34b61a665c89e by Adam Jackson

ok ajacoutot@@, jasper@@, robert@@
@
text
@d103 7
a137 1
   Status stat;
d142 1
a142 2
   stat = XGetGeometry(dpy, drawable, &root,
                       x, y, &uw, &uh, &bw, &depth);
d252 2
d276 2
a294 2

   driReleaseDrawables(&pcp->base);
d306 1
d351 1
a351 1
driDestroyDrawable(__GLXDRIdrawable * pdraw)
d363 2
a364 2
driCreateDrawable(struct glx_screen *base, XID xDrawable,
		  GLXDrawable drawable, struct glx_config *modes)
d393 1
a393 1
   pdp->base.destroyDrawable = driDestroyDrawable;
d399 2
a400 2
driSwapBuffers(__GLXDRIdrawable * pdraw,
               int64_t target_msc, int64_t divisor, int64_t remainder)
d415 1
a415 1
driDestroyScreen(struct glx_screen *base)
d446 1
a446 1
driCreateScreen(int screen, struct glx_display *priv)
d459 4
a462 2
   if (!glx_screen_init(&psc->base, screen, priv))
       return NULL;
d504 3
a506 3
   psp->destroyScreen = driDestroyScreen;
   psp->createDrawable = driCreateDrawable;
   psp->swapBuffers = driSwapBuffers;
d513 1
d524 1
a524 1
driDestroyDisplay(__GLXDRIdisplay * dpy)
d543 2
a544 2
   pdpyp->base.destroyDisplay = driDestroyDisplay;
   pdpyp->base.createScreen = driCreateScreen;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a363 4
   /* Old dri can't handle GLX 1.3+ drawable constructors. */
   if (xDrawable != drawable)
      return NULL;

@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 1
a31 5
typedef struct __GLXDRIdisplayPrivateRec __GLXDRIdisplayPrivate;
typedef struct __GLXDRIcontextPrivateRec __GLXDRIcontextPrivate;
typedef struct __GLXDRIdrawablePrivateRec __GLXDRIdrawablePrivate;

struct __GLXDRIdisplayPrivateRec
d36 1
a36 1
struct __GLXDRIcontextPrivateRec
d38 1
a38 1
   __GLXDRIcontext base;
d40 1
a40 1
   __GLXscreenConfigs *psc;
d43 14
a56 1
struct __GLXDRIdrawablePrivateRec
d63 1
a65 1
   int bpp;
a67 4
/**
 * swrast loader functions
 */

d69 1
a69 1
XCreateDrawable(__GLXDRIdrawablePrivate * pdp,
d87 1
a87 1
   /* create XImage  */
d93 9
a101 8
   pdp->ximage = XCreateImage(dpy, pdp->visinfo->visual, pdp->visinfo->depth, ZPixmap, 0,       /* format, offset */
                              NULL,     /* data */
                              0, 0,     /* size */
                              32,       /* bitmap_pad */
                              0);       /* bytes_per_line */

   /* get the true number of bits per pixel */
   pdp->bpp = pdp->ximage->bits_per_pixel;
d107 1
a107 1
XDestroyDrawable(__GLXDRIdrawablePrivate * pdp, Display * dpy, XID drawable)
d116 4
d122 2
a123 1
                      int *x, int *y, int *w, int *h, void *loaderPrivate)
d125 1
a125 1
   __GLXDRIdrawablePrivate *pdp = loaderPrivate;
d132 1
a132 1
   unsigned int bw, depth;
d137 3
a139 2
                       x, y, (unsigned int *) w, (unsigned int *) h,
                       &bw, &depth);
d142 14
d157 1
a157 1
bytes_per_line(int w, int bpp, unsigned mul)
d161 1
a161 1
   return ((w * bpp + mask) & ~mask) / 8;
d166 2
a167 1
               int x, int y, int w, int h, char *data, void *loaderPrivate)
d169 1
a169 1
   __GLXDRIdrawablePrivate *pdp = loaderPrivate;
d193 1
a193 1
   ximage->bytes_per_line = bytes_per_line(w, pdp->bpp, 32);
d201 8
a208 7
swrastGetImage(__DRIdrawable * draw,
               int x, int y, int w, int h, char *data, void *loaderPrivate)
{
   __GLXDRIdrawablePrivate *pdp = loaderPrivate;
   __GLXDRIdrawable *pdraw = &(pdp->base);
   Display *dpy = pdraw->psc->dpy;
   Drawable drawable;
d211 1
a211 1
   drawable = pdraw->xDrawable;
d213 1
a213 1
   ximage = pdp->ximage;
d217 1
a217 1
   ximage->bytes_per_line = bytes_per_line(w, pdp->bpp, 32);
d219 1
a219 1
   XGetSubImage(dpy, drawable, x, y, w, h, ~0L, ZPixmap, ximage, 0, 0);
d242 1
a242 2
driDestroyContext(__GLXDRIcontext * context,
                  __GLXscreenConfigs * psc, Display * dpy)
d244 5
a248 2
   __GLXDRIcontextPrivate *pcp = (__GLXDRIcontextPrivate *) context;
   const __DRIcoreExtension *core = pcp->psc->core;
d250 4
a253 1
   (*core->destroyContext) (pcp->driContext);
d258 3
a260 3
static Bool
driBindContext(__GLXDRIcontext * context,
               __GLXDRIdrawable * draw, __GLXDRIdrawable * read)
d262 6
a267 2
   __GLXDRIcontextPrivate *pcp = (__GLXDRIcontextPrivate *) context;
   const __DRIcoreExtension *core = pcp->psc->core;
d269 8
a276 2
   return (*core->bindContext) (pcp->driContext,
                                draw->driDrawable, read->driDrawable);
d280 1
a280 1
driUnbindContext(__GLXDRIcontext * context)
d282 2
a283 2
   __GLXDRIcontextPrivate *pcp = (__GLXDRIcontextPrivate *) context;
   const __DRIcoreExtension *core = pcp->psc->core;
d285 3
a287 1
   (*core->unbindContext) (pcp->driContext);
d290 19
a308 8
static __GLXDRIcontext *
driCreateContext(__GLXscreenConfigs * psc,
                 const __GLcontextModes * mode,
                 GLXContext gc, GLXContext shareList, int renderType)
{
   __GLXDRIcontextPrivate *pcp, *pcp_shared;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) mode;
   const __DRIcoreExtension *core;
d311 1
a311 1
   if (!psc || !psc->driScreen)
a313 2
   core = psc->core;

d315 1
a315 1
      pcp_shared = (__GLXDRIcontextPrivate *) shareList->driContext;
d323 6
a328 1
   pcp->psc = psc;
d330 2
a331 2
      (*core->createNewContext) (psc->__driScreen,
                                 config->driConfig, shared, pcp);
d337 1
a337 3
   pcp->base.destroyContext = driDestroyContext;
   pcp->base.bindContext = driBindContext;
   pcp->base.unbindContext = driUnbindContext;
d345 2
a346 2
   __GLXDRIdrawablePrivate *pdp = (__GLXDRIdrawablePrivate *) pdraw;
   const __DRIcoreExtension *core = pdraw->psc->core;
d348 1
a348 1
   (*core->destroyDrawable) (pdraw->driDrawable);
d355 2
a356 3
driCreateDrawable(__GLXscreenConfigs * psc,
                  XID xDrawable,
                  GLXDrawable drawable, const __GLcontextModes * modes)
d358 1
a358 2
   __GLXDRIdrawable *pdraw;
   __GLXDRIdrawablePrivate *pdp;
d360 2
d372 4
a375 4
   pdraw = &(pdp->base);
   pdraw->xDrawable = xDrawable;
   pdraw->drawable = drawable;
   pdraw->psc = psc;
d377 1
a377 1
   XCreateDrawable(pdp, psc->dpy, xDrawable, modes->visualID);
d380 2
a381 2
   pdraw->driDrawable =
      (*swrast->createNewDrawable) (psc->__driScreen, config->driConfig, pdp);
d383 2
a384 2
   if (!pdraw->driDrawable) {
      XDestroyDrawable(pdp, psc->dpy, xDrawable);
d389 1
a389 1
   pdraw->destroyDrawable = driDestroyDrawable;
d391 1
a391 1
   return pdraw;
d394 3
a396 2
static void
driSwapBuffers(__GLXDRIdrawable * pdraw)
d398 10
a407 1
   (*pdraw->psc->core->swapBuffers) (pdraw->driDrawable);
d411 1
a411 1
driDestroyScreen(__GLXscreenConfigs * psc)
d413 2
d416 3
a418 2
   (*psc->core->destroyScreen) (psc->__driScreen);
   psc->__driScreen = NULL;
d423 20
a442 3
static __GLXDRIscreen *
driCreateScreen(__GLXscreenConfigs * psc, int screen,
                __GLXdisplayPrivate * priv)
d447 1
a447 1
   const char *driverName = "swrast";
d450 2
a451 2
   psp = Xcalloc(1, sizeof *psp);
   if (psp == NULL)
d454 5
a458 1
   psc->driver = driOpenDriver(driverName);
d470 1
a470 1
         psc->core = (__DRIcoreExtension *) extensions[i];
d472 1
a472 1
         psc->swrast = (__DRIswrastExtension *) extensions[i];
d480 4
a483 4
   psc->__driScreen =
      psc->swrast->createNewScreen(screen,
                                   loader_extensions, &driver_configs, psc);
   if (psc->__driScreen == NULL) {
d488 4
a491 5
   driBindExtensions(psc);
   driBindCommonExtensions(psc);

   psc->configs = driConvertConfigs(psc->core, psc->configs, driver_configs);
   psc->visuals = driConvertConfigs(psc->core, psc->visuals, driver_configs);
d495 3
a498 1
   psp->createContext = driCreateContext;
a500 2
   psp->waitX = NULL;
   psp->waitGL = NULL;
d502 1
a502 1
   return psp;
a504 2
   Xfree(psp);

d507 1
d530 1
a530 1
   __GLXDRIdisplayPrivate *pdpyp;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d31 5
a35 1
struct drisw_display
d40 1
a40 1
struct drisw_context
d42 1
a42 1
   struct glx_context base;
d44 1
a44 1

d47 1
a47 14
struct drisw_screen
{
   struct glx_screen base;

   __DRIscreen *driScreen;
   __GLXDRIscreen vtable;
   const __DRIcoreExtension *core;
   const __DRIswrastExtension *swrast;
   const __DRIconfig **driver_configs;

   void *driver;
};

struct drisw_drawable
a53 1
   __DRIdrawable *driDrawable;
d56 1
d59 4
d64 1
a64 1
XCreateDrawable(struct drisw_drawable * pdp,
d82 1
a82 1
   /* visual */
d88 8
a95 9
   /* create XImage */
   pdp->ximage = XCreateImage(dpy,
                              pdp->visinfo->visual,
                              pdp->visinfo->depth,
                              ZPixmap, 0,             /* format, offset */
                              NULL,                   /* data */
                              0, 0,                   /* width, height */
                              32,                     /* bitmap_pad */
                              0);                     /* bytes_per_line */
d101 1
a101 1
XDestroyDrawable(struct drisw_drawable * pdp, Display * dpy, XID drawable)
a109 4
/**
 * swrast loader functions
 */

d112 1
a112 2
                      int *x, int *y, int *w, int *h,
                      void *loaderPrivate)
d114 1
a114 1
   struct drisw_drawable *pdp = loaderPrivate;
d121 1
a121 1
   unsigned uw, uh, bw, depth;
d126 2
a127 3
                       x, y, &uw, &uh, &bw, &depth);
   *w = uw;
   *h = uh;
a129 14
/**
 * Align renderbuffer pitch.
 *
 * This should be chosen by the driver and the loader (libGL, xserver/glx)
 * should use the driver provided pitch.
 *
 * It seems that the xorg loader (that is the xserver loading swrast_dri for
 * indirect rendering, not client-side libGL) requires that the pitch is
 * exactly the image width padded to 32 bits. XXX
 *
 * The above restriction can probably be overcome by using ScratchPixmap and
 * CopyArea in the xserver, similar to ShmPutImage, and setting the width of
 * the scratch pixmap to 'pitch / cpp'.
 */
d131 1
a131 1
bytes_per_line(unsigned pitch_bits, unsigned mul)
d135 1
a135 1
   return ((pitch_bits + mask) & ~mask) / 8;
d140 1
a140 2
               int x, int y, int w, int h,
               char *data, void *loaderPrivate)
d142 1
a142 1
   struct drisw_drawable *pdp = loaderPrivate;
d166 1
a166 1
   ximage->bytes_per_line = bytes_per_line(w * ximage->bits_per_pixel, 32);
d174 7
a180 8
swrastGetImage(__DRIdrawable * read,
               int x, int y, int w, int h,
               char *data, void *loaderPrivate)
{
   struct drisw_drawable *prp = loaderPrivate;
   __GLXDRIdrawable *pread = &(prp->base);
   Display *dpy = pread->psc->dpy;
   Drawable readable;
d183 1
a183 1
   readable = pread->xDrawable;
d185 1
a185 1
   ximage = prp->ximage;
d189 1
a189 1
   ximage->bytes_per_line = bytes_per_line(w * ximage->bits_per_pixel, 32);
d191 1
a191 1
   XGetSubImage(dpy, readable, x, y, w, h, ~0L, ZPixmap, ximage, 0, 0);
d214 2
a215 1
drisw_destroy_context(struct glx_context *context)
d217 2
a218 5
   struct drisw_context *pcp = (struct drisw_context *) context;
   struct drisw_screen *psc = (struct drisw_screen *) context->psc;

   if (context->xid)
      glx_send_destroy_context(psc->base.dpy, context->xid);
d220 1
a220 4
   if (context->extensions)
      XFree((char *) context->extensions);

   (*psc->core->destroyContext) (pcp->driContext);
d225 3
a227 3
static int
drisw_bind_context(struct glx_context *context, struct glx_context *old,
		   GLXDrawable draw, GLXDrawable read)
d229 2
a230 6
   struct drisw_context *pcp = (struct drisw_context *) context;
   struct drisw_screen *psc = (struct drisw_screen *) pcp->base.psc;
   struct drisw_drawable *pdraw, *pread;

   pdraw = (struct drisw_drawable *) driFetchDrawable(context, draw);
   pread = (struct drisw_drawable *) driFetchDrawable(context, read);
d232 2
a233 8
   if (pdraw == NULL || pread == NULL)
      return GLXBadDrawable;

   if ((*psc->core->bindContext) (pcp->driContext,
				  pdraw->driDrawable, pread->driDrawable))
      return Success;

   return GLXBadContext;
d237 1
a237 1
drisw_unbind_context(struct glx_context *context, struct glx_context *new)
d239 2
a240 2
   struct drisw_context *pcp = (struct drisw_context *) context;
   struct drisw_screen *psc = (struct drisw_screen *) pcp->base.psc;
d242 1
a242 3
   (*psc->core->unbindContext) (pcp->driContext);

   driReleaseDrawables(&pcp->base);
d245 8
a252 19
static const struct glx_context_vtable drisw_context_vtable = {
   drisw_destroy_context,
   drisw_bind_context,
   drisw_unbind_context,
   NULL,
   NULL,
   DRI_glXUseXFont,
   NULL,
   NULL,
};

static struct glx_context *
drisw_create_context(struct glx_screen *base,
		     struct glx_config *config_base,
		     struct glx_context *shareList, int renderType)
{
   struct drisw_context *pcp, *pcp_shared;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
   struct drisw_screen *psc = (struct drisw_screen *) base;
d255 1
a255 1
   if (!psc->base.driScreen)
d258 2
d261 1
a261 1
      pcp_shared = (struct drisw_context *) shareList;
d269 1
a269 6
   memset(pcp, 0, sizeof *pcp);
   if (!glx_context_init(&pcp->base, &psc->base, &config->base)) {
      Xfree(pcp);
      return NULL;
   }

d271 2
a272 2
      (*psc->core->createNewContext) (psc->driScreen,
				      config->driConfig, shared, pcp);
d278 3
a280 1
   pcp->base.vtable = &drisw_context_vtable;
d288 2
a289 2
   struct drisw_drawable *pdp = (struct drisw_drawable *) pdraw;
   struct drisw_screen *psc = (struct drisw_screen *) pdp->base.psc;
d291 1
a291 1
   (*psc->core->destroyDrawable) (pdp->driDrawable);
d298 3
a300 2
driCreateDrawable(struct glx_screen *base, XID xDrawable,
		  GLXDrawable drawable, struct glx_config *modes)
d302 2
a303 1
   struct drisw_drawable *pdp;
a304 2
   struct drisw_screen *psc = (struct drisw_screen *) base;

d315 4
a318 4
   memset(pdp, 0, sizeof *pdp);
   pdp->base.xDrawable = xDrawable;
   pdp->base.drawable = drawable;
   pdp->base.psc = &psc->base;
d320 1
a320 1
   XCreateDrawable(pdp, psc->base.dpy, xDrawable, modes->visualID);
d323 2
a324 2
   pdp->driDrawable =
      (*swrast->createNewDrawable) (psc->driScreen, config->driConfig, pdp);
d326 2
a327 2
   if (!pdp->driDrawable) {
      XDestroyDrawable(pdp, psc->base.dpy, xDrawable);
d332 1
a332 1
   pdp->base.destroyDrawable = driDestroyDrawable;
d334 1
a334 1
   return &pdp->base;
d337 2
a338 3
static int64_t
driSwapBuffers(__GLXDRIdrawable * pdraw,
               int64_t target_msc, int64_t divisor, int64_t remainder)
d340 1
a340 10
   struct drisw_drawable *pdp = (struct drisw_drawable *) pdraw;
   struct drisw_screen *psc = (struct drisw_screen *) pdp->base.psc;

   (void) target_msc;
   (void) divisor;
   (void) remainder;

   (*psc->core->swapBuffers) (pdp->driDrawable);

   return 0;
d344 1
a344 1
driDestroyScreen(struct glx_screen *base)
a345 2
   struct drisw_screen *psc = (struct drisw_screen *) base;

d347 2
a348 3
   (*psc->core->destroyScreen) (psc->driScreen);
   driDestroyConfigs(psc->driver_configs);
   psc->driScreen = NULL;
d353 3
a355 20
static void *
driOpenSwrast(void)
{
   void *driver = NULL;

   if (driver == NULL)
      driver = driOpenDriver("swrast");

   if (driver == NULL)
      driver = driOpenDriver("swrastg");

   return driver;
}

static const struct glx_screen_vtable drisw_screen_vtable = {
   drisw_create_context
};

static struct glx_screen *
driCreateScreen(int screen, struct glx_display *priv)
d360 1
a360 1
   struct drisw_screen *psc;
d363 2
a364 2
   psc = Xcalloc(1, sizeof *psc);
   if (psc == NULL)
d367 1
a367 5
   memset(psc, 0, sizeof *psc);
   if (!glx_screen_init(&psc->base, screen, priv))
       return NULL;

   psc->driver = driOpenSwrast();
d379 1
a379 1
	 psc->core = (__DRIcoreExtension *) extensions[i];
d381 1
a381 1
	 psc->swrast = (__DRIswrastExtension *) extensions[i];
d389 4
a392 4
   psc->driScreen =
      psc->swrast->createNewScreen(screen, loader_extensions,
				   &driver_configs, psc);
   if (psc->driScreen == NULL) {
d397 5
a401 4
   psc->base.configs =
      driConvertConfigs(psc->core, psc->base.configs, driver_configs);
   psc->base.visuals =
      driConvertConfigs(psc->core, psc->base.visuals, driver_configs);
a404 3
   psc->base.vtable = &drisw_screen_vtable;
   psp = &psc->vtable;
   psc->base.driScreen = psp;
d406 1
d409 2
d412 1
a412 1
   return &psc->base;
d415 2
a418 1
   Xfree(psc);
d441 1
a441 1
   struct drisw_display *pdpyp;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a50 2
   const __DRItexBufferExtension *texBuffer;

d88 1
d90 1
a90 1
   visMask = VisualIDMask;
a92 3
   if (!pdp->visinfo || num_visuals == 0)
      return False;

a102 7
  /**
   * swrast does not handle 24-bit depth with 24 bpp, so let X do the
   * the conversion for us.
   */
  if (pdp->ximage->bits_per_pixel == 24)
     pdp->ximage->bits_per_pixel = 32;

d110 1
a110 1
   free(pdp->visinfo);
d131 1
d136 2
a137 1
   XGetGeometry(dpy, drawable, &root, x, y, &uw, &uh, &bw, &depth);
d247 2
a248 1
   driReleaseDrawables(&pcp->base);
d250 2
a251 1
   free((char *) context->extensions);
d255 1
a255 1
   free(pcp);
a268 2
   driReleaseDrawables(&pcp->base);

a285 1
}
d287 1
a287 59
static void
drisw_bind_tex_image(Display * dpy,
		    GLXDrawable drawable,
		    int buffer, const int *attrib_list)
{
   struct glx_context *gc = __glXGetCurrentContext();
   struct drisw_context *pcp = (struct drisw_context *) gc;
   __GLXDRIdrawable *base = GetGLXDRIDrawable(dpy, drawable);
   struct drisw_drawable *pdraw = (struct drisw_drawable *) base;
   struct drisw_screen *psc;

   __glXInitialize(dpy);

   if (pdraw != NULL) {
      psc = (struct drisw_screen *) base->psc;

      if (!psc->texBuffer)
         return;

      if (psc->texBuffer->base.version >= 2 &&
        psc->texBuffer->setTexBuffer2 != NULL) {
	      (*psc->texBuffer->setTexBuffer2) (pcp->driContext,
					   pdraw->base.textureTarget,
					   pdraw->base.textureFormat,
					   pdraw->driDrawable);
      }
      else {
	      (*psc->texBuffer->setTexBuffer) (pcp->driContext,
					  pdraw->base.textureTarget,
					  pdraw->driDrawable);
      }
   }
}

static void
drisw_release_tex_image(Display * dpy, GLXDrawable drawable, int buffer)
{
#if __DRI_TEX_BUFFER_VERSION >= 3
   struct glx_context *gc = __glXGetCurrentContext();
   struct dri2_context *pcp = (struct dri2_context *) gc;
   __GLXDRIdrawable *base = GetGLXDRIDrawable(dpy, drawable);
   struct glx_display *dpyPriv = __glXInitialize(dpy);
   struct dri2_drawable *pdraw = (struct dri2_drawable *) base;
   struct dri2_screen *psc;

   if (pdraw != NULL) {
      psc = (struct dri2_screen *) base->psc;

      if (!psc->texBuffer)
         return;

      if (psc->texBuffer->base.version >= 3 &&
          psc->texBuffer->releaseTexBuffer != NULL) {
         (*psc->texBuffer->releaseTexBuffer) (pcp->driContext,
                                           pdraw->base.textureTarget,
                                           pdraw->driDrawable);
      }
   }
#endif
d297 2
a298 3
   drisw_bind_tex_image,
   drisw_release_tex_image,
   NULL, /* get_proc_address */
a313 4
   /* Check the renderType value */
   if (!validate_renderType_against_config(config_base, renderType))
       return NULL;

a314 7
      /* If the shareList context is not a DRISW context, we cannot possibly
       * create a DRISW context that shares it.
       */
      if (shareList->vtable->destroy != drisw_destroy_context) {
	 return NULL;
      }

d319 1
a319 1
   pcp = calloc(1, sizeof *pcp);
d323 1
d325 1
a325 1
      free(pcp);
a328 2
   pcp->base.renderType = renderType;

d333 1
a333 93
      free(pcp);
      return NULL;
   }

   pcp->base.vtable = &drisw_context_vtable;

   return &pcp->base;
}

static struct glx_context *
drisw_create_context_attribs(struct glx_screen *base,
			     struct glx_config *config_base,
			     struct glx_context *shareList,
			     unsigned num_attribs,
			     const uint32_t *attribs,
			     unsigned *error)
{
   struct drisw_context *pcp, *pcp_shared;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
   struct drisw_screen *psc = (struct drisw_screen *) base;
   __DRIcontext *shared = NULL;

   uint32_t minor_ver = 1;
   uint32_t major_ver = 0;
   uint32_t renderType = GLX_RGBA_TYPE;
   uint32_t flags = 0;
   unsigned api;
   int reset = __DRI_CTX_RESET_NO_NOTIFICATION;
   uint32_t ctx_attribs[2 * 4];
   unsigned num_ctx_attribs = 0;

   if (!psc->base.driScreen)
      return NULL;

   if (psc->swrast->base.version < 3)
      return NULL;

   /* Remap the GLX tokens to DRI2 tokens.
    */
   if (!dri2_convert_glx_attribs(num_attribs, attribs,
                                 &major_ver, &minor_ver, &renderType, &flags,
                                 &api, &reset, error))
      return NULL;

   /* Check the renderType value */
   if (!validate_renderType_against_config(config_base, renderType)) {
       return NULL;
   }

   if (reset != __DRI_CTX_RESET_NO_NOTIFICATION)
      return NULL;

   if (shareList) {
      pcp_shared = (struct drisw_context *) shareList;
      shared = pcp_shared->driContext;
   }

   pcp = calloc(1, sizeof *pcp);
   if (pcp == NULL)
      return NULL;

   if (!glx_context_init(&pcp->base, &psc->base, &config->base)) {
      free(pcp);
      return NULL;
   }

   ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_MAJOR_VERSION;
   ctx_attribs[num_ctx_attribs++] = major_ver;
   ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_MINOR_VERSION;
   ctx_attribs[num_ctx_attribs++] = minor_ver;

   if (flags != 0) {
      ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_FLAGS;

      /* The current __DRI_CTX_FLAG_* values are identical to the
       * GLX_CONTEXT_*_BIT values.
       */
      ctx_attribs[num_ctx_attribs++] = flags;
   }

   pcp->base.renderType = renderType;

   pcp->driContext =
      (*psc->swrast->createContextAttribs) (psc->driScreen,
					    api,
					    config->driConfig,
					    shared,
					    num_ctx_attribs / 2,
					    ctx_attribs,
					    error,
					    pcp);
   if (pcp->driContext == NULL) {
      free(pcp);
d343 1
a343 1
driswDestroyDrawable(__GLXDRIdrawable * pdraw)
d351 1
a351 1
   free(pdp);
d355 2
a356 2
driswCreateDrawable(struct glx_screen *base, XID xDrawable,
		    GLXDrawable drawable, struct glx_config *modes)
d361 1
a361 1
   Bool ret;
d364 5
a368 1
   pdp = calloc(1, sizeof(*pdp));
d372 1
d377 1
a377 5
   ret = XCreateDrawable(pdp, psc->base.dpy, xDrawable, modes->visualID);
   if (!ret) {
      free(pdp);
      return NULL;
   }
d385 1
a385 1
      free(pdp);
d389 1
a389 1
   pdp->base.destroyDrawable = driswDestroyDrawable;
d395 2
a396 3
driswSwapBuffers(__GLXDRIdrawable * pdraw,
                 int64_t target_msc, int64_t divisor, int64_t remainder,
                 Bool flush)
a404 4
   if (flush) {
      glFlush();
   }

d411 1
a411 1
driswDestroyScreen(struct glx_screen *base)
a422 2
#define SWRAST_DRIVER_NAME "swrast"

d429 4
a432 1
      driver = driOpenDriver(SWRAST_DRIVER_NAME);
d438 1
a438 2
   drisw_create_context,
   drisw_create_context_attribs
a440 26
static void
driswBindExtensions(struct drisw_screen *psc, const __DRIextension **extensions)
{
   int i;

   __glXEnableDirectExtension(&psc->base, "GLX_SGI_make_current_read");

   if (psc->swrast->base.version >= 3) {
      __glXEnableDirectExtension(&psc->base, "GLX_ARB_create_context");
      __glXEnableDirectExtension(&psc->base, "GLX_ARB_create_context_profile");

      /* DRISW version >= 2 implies support for OpenGL ES 2.0.
       */
      __glXEnableDirectExtension(&psc->base,
				 "GLX_EXT_create_context_es2_profile");
   }

   /* FIXME: Figure out what other extensions can be ported here from dri2. */
   for (i = 0; extensions[i]; i++) {
      if ((strcmp(extensions[i]->name, __DRI_TEX_BUFFER) == 0)) {
	 psc->texBuffer = (__DRItexBufferExtension *) extensions[i];
	 __glXEnableDirectExtension(&psc->base, "GLX_EXT_texture_from_pixmap");
      }
   }
}

d442 1
a442 1
driswCreateScreen(int screen, struct glx_display *priv)
a447 1
   struct glx_config *configs = NULL, *visuals = NULL;
d450 1
a450 1
   psc = calloc(1, sizeof *psc);
d454 3
a456 4
   if (!glx_screen_init(&psc->base, screen, priv)) {
      free(psc);
      return NULL;
   }
d488 4
a491 13
   extensions = psc->core->getExtensions(psc->driScreen);
   driswBindExtensions(psc, extensions);

   configs = driConvertConfigs(psc->core, psc->base.configs, driver_configs);
   visuals = driConvertConfigs(psc->core, psc->base.visuals, driver_configs);

   if (!configs || !visuals)
       goto handle_error;

   glx_config_destroy_list(psc->base.configs);
   psc->base.configs = configs;
   glx_config_destroy_list(psc->base.visuals);
   psc->base.visuals = visuals;
d498 3
a500 3
   psp->destroyScreen = driswDestroyScreen;
   psp->createDrawable = driswCreateDrawable;
   psp->swapBuffers = driswSwapBuffers;
a504 8
   if (configs)
       glx_config_destroy_list(configs);
   if (visuals)
       glx_config_destroy_list(visuals);
   if (psc->driScreen)
       psc->core->destroyScreen(psc->driScreen);
   psc->driScreen = NULL;

d507 1
a507 2
   glx_screen_cleanup(&psc->base);
   free(psc);
d509 1
a509 1
   CriticalErrorMessageF("failed to load driver: %s\n", SWRAST_DRIVER_NAME);
d517 1
a517 1
driswDestroyDisplay(__GLXDRIdisplay * dpy)
d519 1
a519 1
   free(dpy);
d532 1
a532 1
   pdpyp = malloc(sizeof *pdpyp);
d536 2
a537 2
   pdpyp->base.destroyDisplay = driswDestroyDisplay;
   pdpyp->base.createScreen = driswCreateScreen;
@


1.1.1.3
log
@Import Mesa 9.2.1
@
text
@d436 4
a439 4
   uint32_t minor_ver;
   uint32_t major_ver;
   uint32_t renderType;
   uint32_t flags;
d441 1
a441 1
   int reset;
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@a51 1
   const __DRIcopySubBufferExtension *copySubBuffer;
d174 3
a176 3
swrastPutImage2(__DRIdrawable * draw, int op,
                int x, int y, int w, int h, int stride,
                char *data, void *loaderPrivate)
d202 1
a202 1
   ximage->bytes_per_line = stride ? stride : bytes_per_line(w * ximage->bits_per_pixel, 32);
a209 8
swrastPutImage(__DRIdrawable * draw, int op,
               int x, int y, int w, int h,
               char *data, void *loaderPrivate)
{
   swrastPutImage2(draw, op, x, y, w, h, 0, data, loaderPrivate);
}

static void
d234 4
a237 6
   .base = {__DRI_SWRAST_LOADER, 2 },

   .getDrawableInfo     = swrastGetDrawableInfo,
   .putImage            = swrastPutImage,
   .getImage            = swrastGetImage,
   .putImage2           = swrastPutImage2,
d334 1
d336 1
a336 1
   struct drisw_context *pcp = (struct drisw_context *) gc;
d339 2
a340 2
   struct drisw_drawable *pdraw = (struct drisw_drawable *) base;
   struct drisw_screen *psc;
d342 2
a343 2
   if (dpyPriv != NULL && pdraw != NULL) {
      psc = (struct drisw_screen *) base->psc;
d355 1
d359 9
a367 9
   .destroy             = drisw_destroy_context,
   .bind                = drisw_bind_context,
   .unbind              = drisw_unbind_context,
   .wait_gl             = NULL,
   .wait_x              = NULL,
   .use_x_font          = DRI_glXUseXFont,
   .bind_tex_image      = drisw_bind_tex_image,
   .release_tex_image   = drisw_release_tex_image,
   .get_proc_address    = NULL,
a587 15
driswCopySubBuffer(__GLXDRIdrawable * pdraw,
                   int x, int y, int width, int height, Bool flush)
{
   struct drisw_drawable *pdp = (struct drisw_drawable *) pdraw;
   struct drisw_screen *psc = (struct drisw_screen *) pdp->base.psc;

   if (flush) {
      glFlush();
   }

   (*psc->copySubBuffer->copySubBuffer) (pdp->driDrawable,
					    x, y, width, height);
}

static void
a597 1
   free(psc);
d614 2
a615 4
   .create_context         = drisw_create_context,
   .create_context_attribs = drisw_create_context_attribs,
   .query_renderer_integer = NULL,
   .query_renderer_string  = NULL,
a634 3
   if (psc->copySubBuffer)
      __glXEnableDirectExtension(&psc->base, "GLX_MESA_copy_sub_buffer");      

d667 3
a669 2
   extensions = driGetDriverExtensions(psc->driver, SWRAST_DRIVER_NAME);
   if (extensions == NULL)
d671 1
a677 2
      if (strcmp(extensions[i]->name, __DRI_COPY_SUB_BUFFER) == 0)
	 psc->copySubBuffer = (__DRIcopySubBufferExtension *) extensions[i];
d685 3
a687 10
   if (psc->swrast->base.version >= 4) {
      psc->driScreen =
         psc->swrast->createNewScreen2(screen, loader_extensions,
                                       extensions,
                                       &driver_configs, psc);
   } else {
      psc->driScreen =
         psc->swrast->createNewScreen(screen, loader_extensions,
                                      &driver_configs, psc);
   }
a714 3

   if (psc->copySubBuffer)
      psp->copySubBuffer = driswCopySubBuffer;
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d30 40
a69 1
#include "drisw_priv.h"
d641 2
a642 2
   .query_renderer_integer = drisw_query_renderer_integer,
   .query_renderer_string  = drisw_query_renderer_string,
a670 8
      /* DRISW version 3 is also required because GLX_MESA_query_renderer
       * requires GLX_ARB_create_context_profile.
       */
      if (psc->swrast->base.version >= 3
          && strcmp(extensions[i]->name, __DRI2_RENDERER_QUERY) == 0) {
         psc->rendererQuery = (__DRI2rendererQueryExtension *) extensions[i];
         __glXEnableDirectExtension(&psc->base, "GLX_MESA_query_renderer");
      }
d736 1
a736 2
   if (!configs || !visuals) {
       ErrorMessageF("No matching fbConfigs or visuals found\n");
a737 1
   }
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d30 1
a30 40

struct drisw_display
{
   __GLXDRIdisplay base;
};

struct drisw_context
{
   struct glx_context base;
   __DRIcontext *driContext;

};

struct drisw_screen
{
   struct glx_screen base;

   __DRIscreen *driScreen;
   __GLXDRIscreen vtable;
   const __DRIcoreExtension *core;
   const __DRIswrastExtension *swrast;
   const __DRItexBufferExtension *texBuffer;
   const __DRIcopySubBufferExtension *copySubBuffer;

   const __DRIconfig **driver_configs;

   void *driver;
};

struct drisw_drawable
{
   __GLXDRIdrawable base;

   GC gc;
   GC swapgc;

   __DRIdrawable *driDrawable;
   XVisualInfo *visinfo;
   XImage *ximage;
};
d602 2
a603 2
   .query_renderer_integer = NULL,
   .query_renderer_string  = NULL,
d632 8
d705 2
a706 1
   if (!configs || !visuals)
d708 1
@


