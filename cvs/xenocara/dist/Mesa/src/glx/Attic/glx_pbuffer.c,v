head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.45;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.58;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.03.43;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.13;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.38;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.37;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.33;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.39;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.44;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * (C) Copyright IBM Corporation 2004
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * IBM AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * \file glx_pbuffer.c
 * Implementation of pbuffer related functions.
 *
 * \author Ian Romanick <idr@@us.ibm.com>
 */

#include <inttypes.h>
#include "glxclient.h"
#include <X11/extensions/extutil.h>
#include <X11/extensions/Xext.h>
#include <assert.h>
#include <string.h>
#include "glxextensions.h"

#ifdef GLX_USE_APPLEGL
#include <pthread.h>
#include "apple_glx_drawable.h"
#endif

#include "glx_error.h"

#define WARN_ONCE_GLX_1_3(a, b) {		\
		static int warned=1;		\
		if(warned) {			\
			warn_GLX_1_3((a), b );	\
			warned=0;		\
		}				\
	}

/**
 * Emit a warning when clients use GLX 1.3 functions on pre-1.3 systems.
 */
static void
warn_GLX_1_3(Display * dpy, const char *function_name)
{
   struct glx_display *priv = __glXInitialize(dpy);

   if (priv && priv->minorVersion < 3) {
      fprintf(stderr,
              "WARNING: Application calling GLX 1.3 function \"%s\" "
              "when GLX 1.3 is not supported!  This is an application bug!\n",
              function_name);
   }
}

#ifndef GLX_USE_APPLEGL
/**
 * Change a drawable's attribute.
 *
 * This function is used to implement \c glXSelectEvent and
 * \c glXSelectEventSGIX.
 *
 * \note
 * This function dynamically determines whether to use the SGIX_pbuffer
 * version of the protocol or the GLX 1.3 version of the protocol.
 */
static void
ChangeDrawableAttribute(Display * dpy, GLXDrawable drawable,
                        const CARD32 * attribs, size_t num_attribs)
{
   struct glx_display *priv = __glXInitialize(dpy);
#ifdef GLX_DIRECT_RENDERING
   __GLXDRIdrawable *pdraw;
#endif
   CARD32 *output;
   CARD8 opcode;
   int i;

   if ((priv == NULL) || (dpy == NULL) || (drawable == 0)) {
      return;
   }

   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
      return;

   LockDisplay(dpy);

   if ((priv->majorVersion > 1) || (priv->minorVersion >= 3)) {
      xGLXChangeDrawableAttributesReq *req;

      GetReqExtra(GLXChangeDrawableAttributes, 8 * num_attribs, req);
      output = (CARD32 *) (req + 1);

      req->reqType = opcode;
      req->glxCode = X_GLXChangeDrawableAttributes;
      req->drawable = drawable;
      req->numAttribs = (CARD32) num_attribs;
   }
   else {
      xGLXVendorPrivateWithReplyReq *vpreq;

      GetReqExtra(GLXVendorPrivateWithReply, 8 + (8 * num_attribs), vpreq);
      output = (CARD32 *) (vpreq + 1);

      vpreq->reqType = opcode;
      vpreq->glxCode = X_GLXVendorPrivateWithReply;
      vpreq->vendorCode = X_GLXvop_ChangeDrawableAttributesSGIX;

      output[0] = (CARD32) drawable;
      output[1] = num_attribs;
      output += 2;
   }

   (void) memcpy(output, attribs, sizeof(CARD32) * 2 * num_attribs);

   UnlockDisplay(dpy);
   SyncHandle();

#ifdef GLX_DIRECT_RENDERING
   pdraw = GetGLXDRIDrawable(dpy, drawable);

   if (!pdraw)
      return;

   for (i = 0; i < num_attribs; i++) {
      switch(attribs[i * 2]) {
      case GLX_EVENT_MASK:
	 /* Keep a local copy for masking out DRI2 proto events as needed */
	 pdraw->eventMask = attribs[i * 2 + 1];
	 break;
      }
   }
#endif

   return;
}


#ifdef GLX_DIRECT_RENDERING
static GLenum
determineTextureTarget(const int *attribs, int numAttribs)
{
   GLenum target = 0;
   int i;

   for (i = 0; i < numAttribs; i++) {
      if (attribs[2 * i] == GLX_TEXTURE_TARGET_EXT) {
         switch (attribs[2 * i + 1]) {
         case GLX_TEXTURE_2D_EXT:
            target = GL_TEXTURE_2D;
            break;
         case GLX_TEXTURE_RECTANGLE_EXT:
            target = GL_TEXTURE_RECTANGLE_ARB;
            break;
         }
      }
   }

   return target;
}

static GLenum
determineTextureFormat(const int *attribs, int numAttribs)
{
   int i;

   for (i = 0; i < numAttribs; i++) {
      if (attribs[2 * i] == GLX_TEXTURE_FORMAT_EXT)
         return attribs[2 * i + 1];
   }

   return 0;
}

static GLboolean
CreateDRIDrawable(Display *dpy, struct glx_config *config,
		  XID drawable, XID glxdrawable,
		  const int *attrib_list, size_t num_attribs)
{
   struct glx_display *const priv = __glXInitialize(dpy);
   __GLXDRIdrawable *pdraw;
   struct glx_screen *psc;

   if (priv == NULL) {
      fprintf(stderr, "failed to create drawable\n");
      return GL_FALSE;
   }

   psc = priv->screens[config->screen];
   if (psc->driScreen == NULL)
      return GL_TRUE;

   pdraw = psc->driScreen->createDrawable(psc, drawable,
					  glxdrawable, config);
   if (pdraw == NULL) {
      fprintf(stderr, "failed to create drawable\n");
      return GL_FALSE;
   }

   if (__glxHashInsert(priv->drawHash, glxdrawable, pdraw)) {
      (*pdraw->destroyDrawable) (pdraw);
      return GL_FALSE;
   }

   pdraw->textureTarget = determineTextureTarget(attrib_list, num_attribs);
   pdraw->textureFormat = determineTextureFormat(attrib_list, num_attribs);

   return GL_TRUE;
}

static void
DestroyDRIDrawable(Display *dpy, GLXDrawable drawable, int destroy_xdrawable)
{
   struct glx_display *const priv = __glXInitialize(dpy);
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
   XID xid;

   if (priv != NULL && pdraw != NULL) {
      xid = pdraw->xDrawable;
      (*pdraw->destroyDrawable) (pdraw);
      __glxHashDelete(priv->drawHash, drawable);
      if (destroy_xdrawable)
         XFreePixmap(priv->dpy, xid);
   }
}

#else

static GLboolean
CreateDRIDrawable(Display *dpy, const struct glx_config * fbconfig,
		  XID drawable, XID glxdrawable,
		  const int *attrib_list, size_t num_attribs)
{
    return GL_TRUE;
}

static void
DestroyDRIDrawable(Display *dpy, GLXDrawable drawable, int destroy_xdrawable)
{
}

#endif

/**
 * Get a drawable's attribute.
 *
 * This function is used to implement \c glXGetSelectedEvent and
 * \c glXGetSelectedEventSGIX.
 *
 * \note
 * This function dynamically determines whether to use the SGIX_pbuffer
 * version of the protocol or the GLX 1.3 version of the protocol.
 *
 * \todo
 * The number of attributes returned is likely to be small, probably less than
 * 10.  Given that, this routine should try to use an array on the stack to
 * capture the reply rather than always calling Xmalloc.
 */
static int
GetDrawableAttribute(Display * dpy, GLXDrawable drawable,
                     int attribute, unsigned int *value)
{
   struct glx_display *priv;
   xGLXGetDrawableAttributesReply reply;
   CARD32 *data;
   CARD8 opcode;
   unsigned int length;
   unsigned int i;
   unsigned int num_attributes;
   GLboolean use_glx_1_3;

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   __GLXDRIdrawable *pdraw;
#endif

   if (dpy == NULL)
      return 0;

   /* Page 38 (page 52 of the PDF) of glxencode1.3.pdf says:
    *
    *     "If drawable is not a valid GLX drawable, a GLXBadDrawable error is
    *     generated."
    */
   if (drawable == 0) {
      __glXSendError(dpy, GLXBadDrawable, 0, X_GLXGetDrawableAttributes, false);
      return 0;
   }

   priv = __glXInitialize(dpy);
   if (priv == NULL)
      return 0;

   use_glx_1_3 = ((priv->majorVersion > 1) || (priv->minorVersion >= 3));

   *value = 0;


   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
      return 0;

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   pdraw = GetGLXDRIDrawable(dpy, drawable);

   if (attribute == GLX_BACK_BUFFER_AGE_EXT) {
      struct glx_screen *psc = pdraw->psc;
      struct glx_context *gc = __glXGetCurrentContext();

      /* The GLX_EXT_buffer_age spec says:
       *
       *   "If querying GLX_BACK_BUFFER_AGE_EXT and <draw> is not bound to
       *   the calling thread's current context a GLXBadDrawable error is
       *   generated."
       */
      if (gc == NULL || gc->currentDpy != dpy ||
         (gc->currentDrawable != drawable && gc->currentReadable != drawable)) {
         __glXSendError(dpy, GLXBadDrawable, drawable, X_GLXGetDrawableAttributes, false);
         return 0;
      }

      if (psc->driScreen->getBufferAge != NULL)
         *value = psc->driScreen->getBufferAge(pdraw);

      return 0;
   }
#endif

   LockDisplay(dpy);

   if (use_glx_1_3) {
      xGLXGetDrawableAttributesReq *req;

      GetReq(GLXGetDrawableAttributes, req);
      req->reqType = opcode;
      req->glxCode = X_GLXGetDrawableAttributes;
      req->drawable = drawable;
   }
   else {
      xGLXVendorPrivateWithReplyReq *vpreq;

      GetReqExtra(GLXVendorPrivateWithReply, 4, vpreq);
      data = (CARD32 *) (vpreq + 1);
      data[0] = (CARD32) drawable;

      vpreq->reqType = opcode;
      vpreq->glxCode = X_GLXVendorPrivateWithReply;
      vpreq->vendorCode = X_GLXvop_GetDrawableAttributesSGIX;
   }

   _XReply(dpy, (xReply *) & reply, 0, False);

   if (reply.type == X_Error) {
      UnlockDisplay(dpy);
      SyncHandle();
      return 0;
   }

   length = reply.length;
   if (length) {
      num_attributes = (use_glx_1_3) ? reply.numAttribs : length / 2;
      data = malloc(length * sizeof(CARD32));
      if (data == NULL) {
         /* Throw data on the floor */
         _XEatData(dpy, length);
      }
      else {
         _XRead(dpy, (char *) data, length * sizeof(CARD32));

         /* Search the set of returned attributes for the attribute requested by
          * the caller.
          */
         for (i = 0; i < num_attributes; i++) {
            if (data[i * 2] == attribute) {
               *value = data[(i * 2) + 1];
               break;
            }
         }

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
         if (pdraw != NULL) {
            if (!pdraw->textureTarget)
               pdraw->textureTarget =
                  determineTextureTarget((const int *) data, num_attributes);
            if (!pdraw->textureFormat)
               pdraw->textureFormat =
                  determineTextureFormat((const int *) data, num_attributes);
         }
#endif

         free(data);
      }
   }

   UnlockDisplay(dpy);
   SyncHandle();

   return 0;
}

static void
protocolDestroyDrawable(Display *dpy, GLXDrawable drawable, CARD32 glxCode)
{
   xGLXDestroyPbufferReq *req;
   CARD8 opcode;

   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
      return;

   LockDisplay(dpy);

   GetReq(GLXDestroyPbuffer, req);
   req->reqType = opcode;
   req->glxCode = glxCode;
   req->pbuffer = (GLXPbuffer) drawable;

   UnlockDisplay(dpy);
   SyncHandle();
}

/**
 * Create a non-pbuffer GLX drawable.
 */
static GLXDrawable
CreateDrawable(Display *dpy, struct glx_config *config,
               Drawable drawable, const int *attrib_list, CARD8 glxCode)
{
   xGLXCreateWindowReq *req;
   struct glx_drawable *glxDraw;
   CARD32 *data;
   unsigned int i;
   CARD8 opcode;
   GLXDrawable xid;

   i = 0;
   if (attrib_list) {
      while (attrib_list[i * 2] != None)
         i++;
   }

   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
      return None;

   glxDraw = malloc(sizeof(*glxDraw));
   if (!glxDraw)
      return None;

   LockDisplay(dpy);
   GetReqExtra(GLXCreateWindow, 8 * i, req);
   data = (CARD32 *) (req + 1);

   req->reqType = opcode;
   req->glxCode = glxCode;
   req->screen = config->screen;
   req->fbconfig = config->fbconfigID;
   req->window = drawable;
   req->glxwindow = xid = XAllocID(dpy);
   req->numAttribs = i;

   if (attrib_list)
      memcpy(data, attrib_list, 8 * i);

   UnlockDisplay(dpy);
   SyncHandle();

   if (InitGLXDrawable(dpy, glxDraw, drawable, xid)) {
      free(glxDraw);
      return None;
   }

   if (!CreateDRIDrawable(dpy, config, drawable, xid, attrib_list, i)) {
      if (glxCode == X_GLXCreatePixmap)
         glxCode = X_GLXDestroyPixmap;
      else
         glxCode = X_GLXDestroyWindow;
      protocolDestroyDrawable(dpy, xid, glxCode);
      xid = None;
   }

   return xid;
}


/**
 * Destroy a non-pbuffer GLX drawable.
 */
static void
DestroyDrawable(Display * dpy, GLXDrawable drawable, CARD32 glxCode)
{
   if ((dpy == NULL) || (drawable == 0)) {
      return;
   }

   protocolDestroyDrawable(dpy, drawable, glxCode);

   DestroyGLXDrawable(dpy, drawable);
   DestroyDRIDrawable(dpy, drawable, GL_FALSE);

   return;
}


/**
 * Create a pbuffer.
 *
 * This function is used to implement \c glXCreatePbuffer and
 * \c glXCreateGLXPbufferSGIX.
 *
 * \note
 * This function dynamically determines whether to use the SGIX_pbuffer
 * version of the protocol or the GLX 1.3 version of the protocol.
 */
static GLXDrawable
CreatePbuffer(Display * dpy, struct glx_config *config,
              unsigned int width, unsigned int height,
              const int *attrib_list, GLboolean size_in_attribs)
{
   struct glx_display *priv = __glXInitialize(dpy);
   GLXDrawable id = 0;
   CARD32 *data;
   CARD8 opcode;
   unsigned int i;
   Pixmap pixmap;
   GLboolean glx_1_3 = GL_FALSE;

   if (priv == NULL)
      return None;

   i = 0;
   if (attrib_list) {
      while (attrib_list[i * 2])
         i++;
   }

   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
      return None;

   LockDisplay(dpy);
   id = XAllocID(dpy);

   if ((priv->majorVersion > 1) || (priv->minorVersion >= 3)) {
      xGLXCreatePbufferReq *req;
      unsigned int extra = (size_in_attribs) ? 0 : 2;

      glx_1_3 = GL_TRUE;

      GetReqExtra(GLXCreatePbuffer, (8 * (i + extra)), req);
      data = (CARD32 *) (req + 1);

      req->reqType = opcode;
      req->glxCode = X_GLXCreatePbuffer;
      req->screen = config->screen;
      req->fbconfig = config->fbconfigID;
      req->pbuffer = id;
      req->numAttribs = i + extra;

      if (!size_in_attribs) {
         data[(2 * i) + 0] = GLX_PBUFFER_WIDTH;
         data[(2 * i) + 1] = width;
         data[(2 * i) + 2] = GLX_PBUFFER_HEIGHT;
         data[(2 * i) + 3] = height;
         data += 4;
      }
   }
   else {
      xGLXVendorPrivateReq *vpreq;

      GetReqExtra(GLXVendorPrivate, 20 + (8 * i), vpreq);
      data = (CARD32 *) (vpreq + 1);

      vpreq->reqType = opcode;
      vpreq->glxCode = X_GLXVendorPrivate;
      vpreq->vendorCode = X_GLXvop_CreateGLXPbufferSGIX;

      data[0] = config->screen;
      data[1] = config->fbconfigID;
      data[2] = id;
      data[3] = width;
      data[4] = height;
      data += 5;
   }

   (void) memcpy(data, attrib_list, sizeof(CARD32) * 2 * i);

   UnlockDisplay(dpy);
   SyncHandle();

   pixmap = XCreatePixmap(dpy, RootWindow(dpy, config->screen),
			  width, height, config->rgbBits);

   if (!CreateDRIDrawable(dpy, config, pixmap, id, attrib_list, i)) {
      CARD32 o = glx_1_3 ? X_GLXDestroyPbuffer : X_GLXvop_DestroyGLXPbufferSGIX;
      XFreePixmap(dpy, pixmap);
      protocolDestroyDrawable(dpy, id, o);
      id = None;
   }

   return id;
}

/**
 * Destroy a pbuffer.
 *
 * This function is used to implement \c glXDestroyPbuffer and
 * \c glXDestroyGLXPbufferSGIX.
 *
 * \note
 * This function dynamically determines whether to use the SGIX_pbuffer
 * version of the protocol or the GLX 1.3 version of the protocol.
 */
static void
DestroyPbuffer(Display * dpy, GLXDrawable drawable)
{
   struct glx_display *priv = __glXInitialize(dpy);
   CARD8 opcode;

   if ((priv == NULL) || (dpy == NULL) || (drawable == 0)) {
      return;
   }

   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
      return;

   LockDisplay(dpy);

   if ((priv->majorVersion > 1) || (priv->minorVersion >= 3)) {
      xGLXDestroyPbufferReq *req;

      GetReq(GLXDestroyPbuffer, req);
      req->reqType = opcode;
      req->glxCode = X_GLXDestroyPbuffer;
      req->pbuffer = (GLXPbuffer) drawable;
   }
   else {
      xGLXVendorPrivateWithReplyReq *vpreq;
      CARD32 *data;

      GetReqExtra(GLXVendorPrivateWithReply, 4, vpreq);
      data = (CARD32 *) (vpreq + 1);

      data[0] = (CARD32) drawable;

      vpreq->reqType = opcode;
      vpreq->glxCode = X_GLXVendorPrivateWithReply;
      vpreq->vendorCode = X_GLXvop_DestroyGLXPbufferSGIX;
   }

   UnlockDisplay(dpy);
   SyncHandle();

   DestroyDRIDrawable(dpy, drawable, GL_TRUE);

   return;
}

/**
 * Create a new pbuffer.
 */
_X_EXPORT GLXPbufferSGIX
glXCreateGLXPbufferSGIX(Display * dpy, GLXFBConfigSGIX config,
                        unsigned int width, unsigned int height,
                        int *attrib_list)
{
   return (GLXPbufferSGIX) CreatePbuffer(dpy, (struct glx_config *) config,
                                         width, height,
                                         attrib_list, GL_FALSE);
}

#endif /* GLX_USE_APPLEGL */

/**
 * Create a new pbuffer.
 */
_X_EXPORT GLXPbuffer
glXCreatePbuffer(Display * dpy, GLXFBConfig config, const int *attrib_list)
{
   int i, width, height;
#ifdef GLX_USE_APPLEGL
   GLXPbuffer result;
   int errorcode;
#endif

   width = 0;
   height = 0;

   WARN_ONCE_GLX_1_3(dpy, __func__);

#ifdef GLX_USE_APPLEGL
   for (i = 0; attrib_list[i]; ++i) {
      switch (attrib_list[i]) {
      case GLX_PBUFFER_WIDTH:
         width = attrib_list[i + 1];
         ++i;
         break;

      case GLX_PBUFFER_HEIGHT:
         height = attrib_list[i + 1];
         ++i;
         break;

      case GLX_LARGEST_PBUFFER:
         /* This is a hint we should probably handle, but how? */
         ++i;
         break;

      case GLX_PRESERVED_CONTENTS:
         /* The contents are always preserved with AppleSGLX with CGL. */
         ++i;
         break;

      default:
         return None;
      }
   }

   if (apple_glx_pbuffer_create(dpy, config, width, height, &errorcode,
                                &result)) {
      /* 
       * apple_glx_pbuffer_create only sets the errorcode to core X11
       * errors. 
       */
      __glXSendError(dpy, errorcode, 0, X_GLXCreatePbuffer, true);

      return None;
   }

   return result;
#else
   for (i = 0; attrib_list[i * 2]; i++) {
      switch (attrib_list[i * 2]) {
      case GLX_PBUFFER_WIDTH:
         width = attrib_list[i * 2 + 1];
         break;
      case GLX_PBUFFER_HEIGHT:
         height = attrib_list[i * 2 + 1];
         break;
      }
   }

   return (GLXPbuffer) CreatePbuffer(dpy, (struct glx_config *) config,
                                     width, height, attrib_list, GL_TRUE);
#endif
}


/**
 * Destroy an existing pbuffer.
 */
_X_EXPORT void
glXDestroyPbuffer(Display * dpy, GLXPbuffer pbuf)
{
#ifdef GLX_USE_APPLEGL
   if (apple_glx_pbuffer_destroy(dpy, pbuf)) {
      __glXSendError(dpy, GLXBadPbuffer, pbuf, X_GLXDestroyPbuffer, false);
   }
#else
   DestroyPbuffer(dpy, pbuf);
#endif
}


/**
 * Query an attribute of a drawable.
 */
_X_EXPORT void
glXQueryDrawable(Display * dpy, GLXDrawable drawable,
                 int attribute, unsigned int *value)
{
   WARN_ONCE_GLX_1_3(dpy, __func__);
#ifdef GLX_USE_APPLEGL
   Window root;
   int x, y;
   unsigned int width, height, bd, depth;

   if (apple_glx_pixmap_query(drawable, attribute, value))
      return;                   /*done */

   if (apple_glx_pbuffer_query(drawable, attribute, value))
      return;                   /*done */

   /*
    * The OpenGL spec states that we should report GLXBadDrawable if
    * the drawable is invalid, however doing so would require that we
    * use XSetErrorHandler(), which is known to not be thread safe.
    * If we use a round-trip call to validate the drawable, there could
    * be a race, so instead we just opt in favor of letting the
    * XGetGeometry request fail with a GetGeometry request X error 
    * rather than GLXBadDrawable, in what is hoped to be a rare
    * case of an invalid drawable.  In practice most and possibly all
    * X11 apps using GLX shouldn't notice a difference.
    */
   if (XGetGeometry
       (dpy, drawable, &root, &x, &y, &width, &height, &bd, &depth)) {
      switch (attribute) {
      case GLX_WIDTH:
         *value = width;
         break;

      case GLX_HEIGHT:
         *value = height;
         break;
      }
   }
#else
   GetDrawableAttribute(dpy, drawable, attribute, value);
#endif
}


#ifndef GLX_USE_APPLEGL
/**
 * Query an attribute of a pbuffer.
 */
_X_EXPORT int
glXQueryGLXPbufferSGIX(Display * dpy, GLXPbufferSGIX drawable,
                       int attribute, unsigned int *value)
{
   return GetDrawableAttribute(dpy, drawable, attribute, value);
}
#endif

/**
 * Select the event mask for a drawable.
 */
_X_EXPORT void
glXSelectEvent(Display * dpy, GLXDrawable drawable, unsigned long mask)
{
#ifdef GLX_USE_APPLEGL
   XWindowAttributes xwattr;

   if (apple_glx_pbuffer_set_event_mask(drawable, mask))
      return;                   /*done */

   /* 
    * The spec allows a window, but currently there are no valid
    * events for a window, so do nothing.
    */
   if (XGetWindowAttributes(dpy, drawable, &xwattr))
      return;                   /*done */
   /* The drawable seems to be invalid.  Report an error. */

   __glXSendError(dpy, GLXBadDrawable, drawable,
                  X_GLXChangeDrawableAttributes, false);
#else
   CARD32 attribs[2];

   attribs[0] = (CARD32) GLX_EVENT_MASK;
   attribs[1] = (CARD32) mask;

   ChangeDrawableAttribute(dpy, drawable, attribs, 1);
#endif
}


/**
 * Get the selected event mask for a drawable.
 */
_X_EXPORT void
glXGetSelectedEvent(Display * dpy, GLXDrawable drawable, unsigned long *mask)
{
#ifdef GLX_USE_APPLEGL
   XWindowAttributes xwattr;

   if (apple_glx_pbuffer_get_event_mask(drawable, mask))
      return;                   /*done */

   /* 
    * The spec allows a window, but currently there are no valid
    * events for a window, so do nothing, but set the mask to 0.
    */
   if (XGetWindowAttributes(dpy, drawable, &xwattr)) {
      /* The window is valid, so set the mask to 0. */
      *mask = 0;
      return;                   /*done */
   }
   /* The drawable seems to be invalid.  Report an error. */

   __glXSendError(dpy, GLXBadDrawable, drawable, X_GLXGetDrawableAttributes,
                  true);
#else
   unsigned int value;


   /* The non-sense with value is required because on LP64 platforms
    * sizeof(unsigned int) != sizeof(unsigned long).  On little-endian
    * we could just type-cast the pointer, but why?
    */

   GetDrawableAttribute(dpy, drawable, GLX_EVENT_MASK_SGIX, &value);
   *mask = value;
#endif
}


_X_EXPORT GLXPixmap
glXCreatePixmap(Display * dpy, GLXFBConfig config, Pixmap pixmap,
                const int *attrib_list)
{
   WARN_ONCE_GLX_1_3(dpy, __func__);

#ifdef GLX_USE_APPLEGL
   const struct glx_config *modes = (const struct glx_config *) config;

   if (apple_glx_pixmap_create(dpy, modes->screen, pixmap, modes))
      return None;

   return pixmap;
#else
   return CreateDrawable(dpy, (struct glx_config *) config,
                         (Drawable) pixmap, attrib_list, X_GLXCreatePixmap);
#endif
}


_X_EXPORT GLXWindow
glXCreateWindow(Display * dpy, GLXFBConfig config, Window win,
                const int *attrib_list)
{
   WARN_ONCE_GLX_1_3(dpy, __func__);
#ifdef GLX_USE_APPLEGL
   XWindowAttributes xwattr;
   XVisualInfo *visinfo;

   (void) attrib_list;          /*unused according to GLX 1.4 */

   XGetWindowAttributes(dpy, win, &xwattr);

   visinfo = glXGetVisualFromFBConfig(dpy, config);

   if (NULL == visinfo) {
      __glXSendError(dpy, GLXBadFBConfig, 0, X_GLXCreateWindow, false);
      return None;
   }

   if (visinfo->visualid != XVisualIDFromVisual(xwattr.visual)) {
      __glXSendError(dpy, BadMatch, 0, X_GLXCreateWindow, true);
      return None;
   }

   free(visinfo);

   return win;
#else
   return CreateDrawable(dpy, (struct glx_config *) config,
                         (Drawable) win, attrib_list, X_GLXCreateWindow);
#endif
}


_X_EXPORT void
glXDestroyPixmap(Display * dpy, GLXPixmap pixmap)
{
   WARN_ONCE_GLX_1_3(dpy, __func__);
#ifdef GLX_USE_APPLEGL
   if (apple_glx_pixmap_destroy(dpy, pixmap))
      __glXSendError(dpy, GLXBadPixmap, pixmap, X_GLXDestroyPixmap, false);
#else
   DestroyDrawable(dpy, (GLXDrawable) pixmap, X_GLXDestroyPixmap);
#endif
}


_X_EXPORT void
glXDestroyWindow(Display * dpy, GLXWindow win)
{
   WARN_ONCE_GLX_1_3(dpy, __func__);
#ifndef GLX_USE_APPLEGL
   DestroyDrawable(dpy, (GLXDrawable) win, X_GLXDestroyWindow);
#endif
}

#ifndef GLX_USE_APPLEGL
_X_EXPORT
GLX_ALIAS_VOID(glXDestroyGLXPbufferSGIX,
               (Display * dpy, GLXPbufferSGIX pbuf),
               (dpy, pbuf), glXDestroyPbuffer)

_X_EXPORT
GLX_ALIAS_VOID(glXSelectEventSGIX,
               (Display * dpy, GLXDrawable drawable,
                unsigned long mask), (dpy, drawable, mask), glXSelectEvent)

_X_EXPORT
GLX_ALIAS_VOID(glXGetSelectedEventSGIX,
               (Display * dpy, GLXDrawable drawable,
                unsigned long *mask), (dpy, drawable, mask),
               glXGetSelectedEvent)
#endif
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d42 1
a42 1
#include "apple/apple_glx_drawable.h"
d322 1
a323 1
      struct glx_screen *psc;
d331 3
a333 5
      if (pdraw == NULL || gc == NULL || gc->currentDpy != dpy ||
         (gc->currentDrawable != drawable &&
         gc->currentReadable != drawable)) {
         __glXSendError(dpy, GLXBadDrawable, drawable,
                        X_GLXGetDrawableAttributes, false);
a335 2

      psc = pdraw->psc;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d42 1
a42 1
#include "apple_glx_drawable.h"
a321 1
      struct glx_screen *psc = pdraw->psc;
d323 1
d331 5
a335 3
      if (gc == NULL || gc->currentDpy != dpy ||
         (gc->currentDrawable != drawable && gc->currentReadable != drawable)) {
         __glXSendError(dpy, GLXBadDrawable, drawable, X_GLXGetDrawableAttributes, false);
d338 2
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d63 1
a63 1
   if (priv->minorVersion < 3) {
d94 1
a94 1
   if ((dpy == NULL) || (drawable == 0)) {
d200 5
d234 1
a234 1
   if (pdraw != NULL) {
d288 4
d306 3
d318 26
d396 2
a397 4
         {
            __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);

            if (pdraw != NULL && !pdraw->textureTarget)
d400 1
a400 1
            if (pdraw != NULL && !pdraw->textureFormat)
d543 3
d635 1
a635 1
   if ((dpy == NULL) || (drawable == 0)) {
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d43 2
a45 1
#endif
d191 1
a191 1
static void
d202 1
a202 1
      return;
d208 1
a208 1
      return;
d213 1
a213 1
      return; /* FIXME: Check what we're supposed to do here... */
d218 2
d240 1
a240 1
static void
d245 1
d283 10
a292 1
   if ((dpy == NULL) || (drawable == 0)) {
d339 1
a339 1
      data = (CARD32 *) Xmalloc(length * sizeof(CARD32));
d370 1
a370 1
         Xfree(data);
d380 21
d409 1
d425 4
d447 13
a459 1
   CreateDRIDrawable(dpy, config, drawable, xid, attrib_list, i);
a470 3
   xGLXDestroyPbufferReq *req;
   CARD8 opcode;

d475 1
d477 1
a477 14
   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
      return;

   LockDisplay(dpy);

   GetReq(GLXDestroyPbuffer, req);
   req->reqType = opcode;
   req->glxCode = glxCode;
   req->pbuffer = (GLXPbuffer) drawable;

   UnlockDisplay(dpy);
   SyncHandle();

d505 1
d524 2
d570 6
a575 1
   CreateDRIDrawable(dpy, config, pixmap, id, attrib_list, i);
d920 1
a920 1
   XFree(visinfo);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a79 3
 *
 * \todo
 * This function needs to be modified to work with direct-rendering drivers.
d137 3
a264 3
 *
 * \todo
 * This function needs to be modified to work with direct-rendering drivers.
a368 3
 *
 * \todo
 * This function needs to be modified to work with direct-rendering drivers.
d378 1
d399 1
a399 1
   req->glxwindow = XAllocID(dpy);
d408 1
a408 1
   CreateDRIDrawable(dpy, config, drawable, req->glxwindow, attrib_list, i);
d410 1
a410 1
   return req->glxwindow;
a456 3
 *
 * \todo
 * This function needs to be modified to work with direct-rendering drivers.
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d60 1
a60 1
   __GLXdisplayPrivate *priv = __glXInitialize(dpy);
d88 4
a91 1
   __GLXdisplayPrivate *priv = __glXInitialize(dpy);
d94 1
d109 1
a109 1
      GetReqExtra(GLXChangeDrawableAttributes, 8 + (8 * num_attribs), req);
d120 1
a120 1
      GetReqExtra(GLXVendorPrivateWithReply, 4 + (8 * num_attribs), vpreq);
d128 2
a129 1
      output++;
d137 2
a138 2
   return;
}
d140 7
a146 22

/**
 * Destroy a pbuffer.
 *
 * This function is used to implement \c glXDestroyPbuffer and
 * \c glXDestroyGLXPbufferSGIX.
 *
 * \note
 * This function dynamically determines whether to use the SGIX_pbuffer
 * version of the protocol or the GLX 1.3 version of the protocol.
 *
 * \todo
 * This function needs to be modified to work with direct-rendering drivers.
 */
static void
DestroyPbuffer(Display * dpy, GLXDrawable drawable)
{
   __GLXdisplayPrivate *priv = __glXInitialize(dpy);
   CARD8 opcode;

   if ((dpy == NULL) || (drawable == 0)) {
      return;
d148 1
a148 31

   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
      return;

   LockDisplay(dpy);

   if ((priv->majorVersion > 1) || (priv->minorVersion >= 3)) {
      xGLXDestroyPbufferReq *req;

      GetReq(GLXDestroyPbuffer, req);
      req->reqType = opcode;
      req->glxCode = X_GLXDestroyPbuffer;
      req->pbuffer = (GLXPbuffer) drawable;
   }
   else {
      xGLXVendorPrivateWithReplyReq *vpreq;
      CARD32 *data;

      GetReqExtra(GLXVendorPrivateWithReply, 4, vpreq);
      data = (CARD32 *) (vpreq + 1);

      data[0] = (CARD32) drawable;

      vpreq->reqType = opcode;
      vpreq->glxCode = X_GLXVendorPrivateWithReply;
      vpreq->vendorCode = X_GLXvop_DestroyGLXPbufferSGIX;
   }

   UnlockDisplay(dpy);
   SyncHandle();
a176 1

d189 60
d273 1
a273 1
   __GLXdisplayPrivate *priv;
d301 1
a301 1
      GetReqExtra(GLXGetDrawableAttributes, 4, req);
d349 1
a349 1
            __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable, NULL);
d377 1
a377 1
CreateDrawable(Display * dpy, const __GLcontextModes * fbconfig,
d401 5
a405 5
   req->screen = (CARD32) fbconfig->screen;
   req->fbconfig = fbconfig->fbconfigID;
   req->window = (CARD32) drawable;
   req->glxwindow = (GLXWindow) XAllocID(dpy);
   req->numAttribs = (CARD32) i;
d413 1
a413 23
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   do {
      /* FIXME: Maybe delay __DRIdrawable creation until the drawable
       * is actually bound to a context... */

      __GLXdisplayPrivate *const priv = __glXInitialize(dpy);
      __GLXDRIdrawable *pdraw;
      __GLXscreenConfigs *psc;

      psc = &priv->screenConfigs[fbconfig->screen];
      if (psc->driScreen == NULL)
         break;
      pdraw = psc->driScreen->createDrawable(psc, drawable,
                                             req->glxwindow, fbconfig);
      if (pdraw == NULL) {
         fprintf(stderr, "failed to create drawable\n");
         break;
      }

      if (__glxHashInsert(psc->drawHash, req->glxwindow, pdraw)) {
         (*pdraw->destroyDrawable) (pdraw);
         return None;           /* FIXME: Check what we're supposed to do here... */
      }
d415 1
a415 6
      pdraw->textureTarget = determineTextureTarget(attrib_list, i);
      pdraw->textureFormat = determineTextureFormat(attrib_list, i);
   } while (0);
#endif

   return (GLXDrawable) req->glxwindow;
a420 3
 *
 * \todo
 * This function needs to be modified to work with direct-rendering drivers.
d439 1
a439 1
   GetReqExtra(GLXDestroyPbuffer, 4, req);
d447 1
a447 13
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   {
      int screen;
      __GLXdisplayPrivate *const priv = __glXInitialize(dpy);
      __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable, &screen);
      __GLXscreenConfigs *psc = &priv->screenConfigs[screen];

      if (pdraw != NULL) {
         (*pdraw->destroyDrawable) (pdraw);
         __glxHashDelete(psc->drawHash, drawable);
      }
   }
#endif
d467 1
a467 1
CreatePbuffer(Display * dpy, const __GLcontextModes * fbconfig,
d471 1
a471 1
   __GLXdisplayPrivate *priv = __glXInitialize(dpy);
d476 1
d500 4
a503 4
      req->screen = (CARD32) fbconfig->screen;
      req->fbconfig = fbconfig->fbconfigID;
      req->pbuffer = (GLXPbuffer) id;
      req->numAttribs = (CARD32) (i + extra);
d523 5
a527 5
      data[0] = (CARD32) fbconfig->screen;
      data[1] = (CARD32) fbconfig->fbconfigID;
      data[2] = (CARD32) id;
      data[3] = (CARD32) width;
      data[4] = (CARD32) height;
d536 5
d545 56
d603 1
a603 1
PUBLIC GLXPbufferSGIX
d608 1
a608 1
   return (GLXPbufferSGIX) CreatePbuffer(dpy, (__GLcontextModes *) config,
d618 1
a618 1
PUBLIC GLXPbuffer
d684 1
a684 1
   return (GLXPbuffer) CreatePbuffer(dpy, (__GLcontextModes *) config,
d693 1
a693 1
PUBLIC void
d709 1
a709 1
PUBLIC void
d758 1
a758 1
PUBLIC int
d769 1
a769 1
PUBLIC void
d802 1
a802 1
PUBLIC void
d839 1
a839 1
PUBLIC GLXPixmap
d846 1
a846 1
   const __GLcontextModes *modes = (const __GLcontextModes *) config;
d853 1
a853 1
   return CreateDrawable(dpy, (__GLcontextModes *) config,
d859 1
a859 1
PUBLIC GLXWindow
d888 1
a888 1
   return CreateDrawable(dpy, (__GLcontextModes *) config,
d894 1
a894 1
PUBLIC void
d907 1
a907 1
PUBLIC void
d917 1
a917 1
PUBLIC
d922 1
a922 1
PUBLIC
d927 1
a927 1
PUBLIC
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d60 1
a60 1
   struct glx_display *priv = __glXInitialize(dpy);
d88 1
a88 4
   struct glx_display *priv = __glXInitialize(dpy);
#ifdef GLX_DIRECT_RENDERING
   __GLXDRIdrawable *pdraw;
#endif
a90 1
   int i;
d105 1
a105 1
      GetReqExtra(GLXChangeDrawableAttributes, 8 * num_attribs, req);
d116 1
a116 1
      GetReqExtra(GLXVendorPrivateWithReply, 8 + (8 * num_attribs), vpreq);
d124 1
a124 2
      output[1] = num_attribs;
      output += 2;
d132 49
a180 2
#ifdef GLX_DIRECT_RENDERING
   pdraw = GetGLXDRIDrawable(dpy, drawable);
d182 3
a184 7
   for (i = 0; i < num_attribs; i++) {
      switch(attribs[i * 2]) {
      case GLX_EVENT_MASK:
	 /* Keep a local copy for masking out DRI2 proto events as needed */
	 pdraw->eventMask = attribs[i * 2 + 1];
	 break;
      }
d186 3
a188 1
#endif
d217 1
a229 60

static void
CreateDRIDrawable(Display *dpy, struct glx_config *config,
		  XID drawable, XID glxdrawable,
		  const int *attrib_list, size_t num_attribs)
{
   struct glx_display *const priv = __glXInitialize(dpy);
   __GLXDRIdrawable *pdraw;
   struct glx_screen *psc;

   psc = priv->screens[config->screen];
   if (psc->driScreen == NULL)
      return;

   pdraw = psc->driScreen->createDrawable(psc, drawable,
					  glxdrawable, config);
   if (pdraw == NULL) {
      fprintf(stderr, "failed to create drawable\n");
      return;
   }

   if (__glxHashInsert(priv->drawHash, glxdrawable, pdraw)) {
      (*pdraw->destroyDrawable) (pdraw);
      return; /* FIXME: Check what we're supposed to do here... */
   }

   pdraw->textureTarget = determineTextureTarget(attrib_list, num_attribs);
   pdraw->textureFormat = determineTextureFormat(attrib_list, num_attribs);
}

static void
DestroyDRIDrawable(Display *dpy, GLXDrawable drawable, int destroy_xdrawable)
{
   struct glx_display *const priv = __glXInitialize(dpy);
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
   XID xid;

   if (pdraw != NULL) {
      xid = pdraw->xDrawable;
      (*pdraw->destroyDrawable) (pdraw);
      __glxHashDelete(priv->drawHash, drawable);
      if (destroy_xdrawable)
         XFreePixmap(priv->dpy, xid);
   }
}

#else

static void
CreateDRIDrawable(Display *dpy, const struct glx_config * fbconfig,
		  XID drawable, XID glxdrawable,
		  const int *attrib_list, size_t num_attribs)
{
}

static void
DestroyDRIDrawable(Display *dpy, GLXDrawable drawable, int destroy_xdrawable)
{
}

d254 1
a254 1
   struct glx_display *priv;
d282 1
a282 1
      GetReq(GLXGetDrawableAttributes, req);
d330 1
a330 1
            __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
d358 1
a358 1
CreateDrawable(Display *dpy, struct glx_config *config,
d382 5
a386 5
   req->screen = config->screen;
   req->fbconfig = config->fbconfigID;
   req->window = drawable;
   req->glxwindow = XAllocID(dpy);
   req->numAttribs = i;
d394 23
a416 1
   CreateDRIDrawable(dpy, config, drawable, req->glxwindow, attrib_list, i);
d418 6
a423 1
   return req->glxwindow;
d429 3
d450 1
a450 1
   GetReq(GLXDestroyPbuffer, req);
d458 13
a470 1
   DestroyDRIDrawable(dpy, drawable, GL_FALSE);
d490 1
a490 1
CreatePbuffer(Display * dpy, struct glx_config *config,
d494 1
a494 1
   struct glx_display *priv = __glXInitialize(dpy);
a498 1
   Pixmap pixmap;
d522 4
a525 4
      req->screen = config->screen;
      req->fbconfig = config->fbconfigID;
      req->pbuffer = id;
      req->numAttribs = i + extra;
d545 5
a549 5
      data[0] = config->screen;
      data[1] = config->fbconfigID;
      data[2] = id;
      data[3] = width;
      data[4] = height;
a557 5
   pixmap = XCreatePixmap(dpy, RootWindow(dpy, config->screen),
			  width, height, config->rgbBits);

   CreateDRIDrawable(dpy, config, pixmap, id, attrib_list, i);

a561 56
 * Destroy a pbuffer.
 *
 * This function is used to implement \c glXDestroyPbuffer and
 * \c glXDestroyGLXPbufferSGIX.
 *
 * \note
 * This function dynamically determines whether to use the SGIX_pbuffer
 * version of the protocol or the GLX 1.3 version of the protocol.
 */
static void
DestroyPbuffer(Display * dpy, GLXDrawable drawable)
{
   struct glx_display *priv = __glXInitialize(dpy);
   CARD8 opcode;

   if ((dpy == NULL) || (drawable == 0)) {
      return;
   }

   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
      return;

   LockDisplay(dpy);

   if ((priv->majorVersion > 1) || (priv->minorVersion >= 3)) {
      xGLXDestroyPbufferReq *req;

      GetReq(GLXDestroyPbuffer, req);
      req->reqType = opcode;
      req->glxCode = X_GLXDestroyPbuffer;
      req->pbuffer = (GLXPbuffer) drawable;
   }
   else {
      xGLXVendorPrivateWithReplyReq *vpreq;
      CARD32 *data;

      GetReqExtra(GLXVendorPrivateWithReply, 4, vpreq);
      data = (CARD32 *) (vpreq + 1);

      data[0] = (CARD32) drawable;

      vpreq->reqType = opcode;
      vpreq->glxCode = X_GLXVendorPrivateWithReply;
      vpreq->vendorCode = X_GLXvop_DestroyGLXPbufferSGIX;
   }

   UnlockDisplay(dpy);
   SyncHandle();

   DestroyDRIDrawable(dpy, drawable, GL_TRUE);

   return;
}

/**
d564 1
a564 1
_X_EXPORT GLXPbufferSGIX
d569 1
a569 1
   return (GLXPbufferSGIX) CreatePbuffer(dpy, (struct glx_config *) config,
d579 1
a579 1
_X_EXPORT GLXPbuffer
d645 1
a645 1
   return (GLXPbuffer) CreatePbuffer(dpy, (struct glx_config *) config,
d654 1
a654 1
_X_EXPORT void
d670 1
a670 1
_X_EXPORT void
d719 1
a719 1
_X_EXPORT int
d730 1
a730 1
_X_EXPORT void
d763 1
a763 1
_X_EXPORT void
d800 1
a800 1
_X_EXPORT GLXPixmap
d807 1
a807 1
   const struct glx_config *modes = (const struct glx_config *) config;
d814 1
a814 1
   return CreateDrawable(dpy, (struct glx_config *) config,
d820 1
a820 1
_X_EXPORT GLXWindow
d849 1
a849 1
   return CreateDrawable(dpy, (struct glx_config *) config,
d855 1
a855 1
_X_EXPORT void
d868 1
a868 1
_X_EXPORT void
d878 1
a878 1
_X_EXPORT
d883 1
a883 1
_X_EXPORT
d888 1
a888 1
_X_EXPORT
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d43 1
a45 2
#include "glx_error.h"

d80 3
a139 3
   if (!pdraw)
      return;

d190 1
a190 1
static GLboolean
d201 1
a201 1
      return GL_TRUE;
d207 1
a207 1
      return GL_FALSE;
d212 1
a212 1
      return GL_FALSE;
a216 2

   return GL_TRUE;
d237 1
a237 1
static GLboolean
a241 1
    return GL_TRUE;
d265 3
d282 1
a282 10
   if (dpy == NULL)
      return 0;

   /* Page 38 (page 52 of the PDF) of glxencode1.3.pdf says:
    *
    *     "If drawable is not a valid GLX drawable, a GLXBadDrawable error is
    *     generated."
    */
   if (drawable == 0) {
      __glXSendError(dpy, GLXBadDrawable, 0, X_GLXGetDrawableAttributes, false);
d329 1
a329 1
      data = malloc(length * sizeof(CARD32));
d360 1
a360 1
         free(data);
a369 21
static void
protocolDestroyDrawable(Display *dpy, GLXDrawable drawable, CARD32 glxCode)
{
   xGLXDestroyPbufferReq *req;
   CARD8 opcode;

   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
      return;

   LockDisplay(dpy);

   GetReq(GLXDestroyPbuffer, req);
   req->reqType = opcode;
   req->glxCode = glxCode;
   req->pbuffer = (GLXPbuffer) drawable;

   UnlockDisplay(dpy);
   SyncHandle();
}

d372 3
a380 1
   struct glx_drawable *glxDraw;
a383 1
   GLXDrawable xid;
a394 4
   glxDraw = malloc(sizeof(*glxDraw));
   if (!glxDraw)
      return None;

d404 1
a404 1
   req->glxwindow = xid = XAllocID(dpy);
d413 1
a413 13
   if (InitGLXDrawable(dpy, glxDraw, drawable, xid)) {
      free(glxDraw);
      return None;
   }

   if (!CreateDRIDrawable(dpy, config, drawable, xid, attrib_list, i)) {
      if (glxCode == X_GLXCreatePixmap)
         glxCode = X_GLXDestroyPixmap;
      else
         glxCode = X_GLXDestroyWindow;
      protocolDestroyDrawable(dpy, xid, glxCode);
      xid = None;
   }
d415 1
a415 1
   return xid;
d425 3
a431 1
   protocolDestroyDrawable(dpy, drawable, glxCode);
d433 14
a446 1
   DestroyGLXDrawable(dpy, drawable);
d462 3
a476 1
   GLboolean glx_1_3 = GL_FALSE;
a494 2
      glx_1_3 = GL_TRUE;

d539 1
a539 6
   if (!CreateDRIDrawable(dpy, config, pixmap, id, attrib_list, i)) {
      CARD32 o = glx_1_3 ? X_GLXDestroyPbuffer : X_GLXvop_DestroyGLXPbufferSGIX;
      XFreePixmap(dpy, pixmap);
      protocolDestroyDrawable(dpy, id, o);
      id = None;
   }
d884 1
a884 1
   free(visinfo);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d63 1
a63 1
   if (priv && priv->minorVersion < 3) {
d94 1
a94 1
   if ((priv == NULL) || (dpy == NULL) || (drawable == 0)) {
a199 5
   if (priv == NULL) {
      fprintf(stderr, "failed to create drawable\n");
      return GL_FALSE;
   }

d229 1
a229 1
   if (priv != NULL && pdraw != NULL) {
a282 4
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   __GLXDRIdrawable *pdraw;
#endif

a296 3
   if (priv == NULL)
      return 0;

a305 26
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   pdraw = GetGLXDRIDrawable(dpy, drawable);

   if (attribute == GLX_BACK_BUFFER_AGE_EXT) {
      struct glx_screen *psc = pdraw->psc;
      struct glx_context *gc = __glXGetCurrentContext();

      /* The GLX_EXT_buffer_age spec says:
       *
       *   "If querying GLX_BACK_BUFFER_AGE_EXT and <draw> is not bound to
       *   the calling thread's current context a GLXBadDrawable error is
       *   generated."
       */
      if (gc == NULL || gc->currentDpy != dpy ||
         (gc->currentDrawable != drawable && gc->currentReadable != drawable)) {
         __glXSendError(dpy, GLXBadDrawable, drawable, X_GLXGetDrawableAttributes, false);
         return 0;
      }

      if (psc->driScreen->getBufferAge != NULL)
         *value = psc->driScreen->getBufferAge(pdraw);

      return 0;
   }
#endif

d358 4
a361 2
         if (pdraw != NULL) {
            if (!pdraw->textureTarget)
d364 1
a364 1
            if (!pdraw->textureFormat)
a506 3
   if (priv == NULL)
      return None;

d596 1
a596 1
   if ((priv == NULL) || (dpy == NULL) || (drawable == 0)) {
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d42 1
a42 1
#include "apple/apple_glx_drawable.h"
d322 1
a323 1
      struct glx_screen *psc;
d331 3
a333 5
      if (pdraw == NULL || gc == NULL || gc->currentDpy != dpy ||
         (gc->currentDrawable != drawable &&
         gc->currentReadable != drawable)) {
         __glXSendError(dpy, GLXBadDrawable, drawable,
                        X_GLXGetDrawableAttributes, false);
a335 2

      psc = pdraw->psc;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d42 1
a42 1
#include "apple_glx_drawable.h"
a321 1
      struct glx_screen *psc = pdraw->psc;
d323 1
d331 5
a335 3
      if (gc == NULL || gc->currentDpy != dpy ||
         (gc->currentDrawable != drawable && gc->currentReadable != drawable)) {
         __glXSendError(dpy, GLXBadDrawable, drawable, X_GLXGetDrawableAttributes, false);
d338 2
@


