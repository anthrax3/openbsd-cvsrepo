head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.45;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.8;
commitid	4ry2gvZGMXkCUD2n;

1.8
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2014.07.09.21.08.58;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.10.05.09.53.57;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2013.09.05.14.03.42;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.13;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.24.19.03.21;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.36;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.10.05.09.24.21;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.33;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.10.37;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.47.43;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright © 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Soft-
 * ware"), to deal in the Software without restriction, including without
 * limitation the rights to use, copy, modify, merge, publish, distribute,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, provided that the above copyright
 * notice(s) and this permission notice appear in all copies of the Soft-
 * ware and that both the above copyright notice(s) and this permission
 * notice appear in supporting documentation.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
 * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
 * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
 * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
 * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
 * MANCE OF THIS SOFTWARE.
 *
 * Except as contained in this notice, the name of a copyright holder shall
 * not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization of
 * the copyright holder.
 *
 * Authors:
 *   Kristian Høgsberg (krh@@redhat.com)
 */

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)

#include <X11/Xlib.h>
#include <X11/extensions/Xfixes.h>
#include <X11/Xlib-xcb.h>
#include <xcb/xcb.h>
#include <xcb/dri2.h>
#include "glxclient.h"
#include <X11/extensions/dri2proto.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/time.h>
#include "dri2.h"
#include "dri_common.h"
#include "dri2_priv.h"
#include "loader.h"

/* From xmlpool/options.h, user exposed so should be stable */
#define DRI_CONF_VBLANK_NEVER 0
#define DRI_CONF_VBLANK_DEF_INTERVAL_0 1
#define DRI_CONF_VBLANK_DEF_INTERVAL_1 2
#define DRI_CONF_VBLANK_ALWAYS_SYNC 3

#undef DRI2_MINOR
#define DRI2_MINOR 1

struct dri2_display
{
   __GLXDRIdisplay base;

   /*
    ** XFree86-DRI version information
    */
   int driMajor;
   int driMinor;
   int driPatch;
   int swapAvailable;
   int invalidateAvailable;

   __glxHashTable *dri2Hash;

   const __DRIextension *loader_extensions[4];
};

struct dri2_context
{
   struct glx_context base;
   __DRIcontext *driContext;
};

struct dri2_drawable
{
   __GLXDRIdrawable base;
   __DRIdrawable *driDrawable;
   __DRIbuffer buffers[5];
   int bufferCount;
   int width, height;
   int have_back;
   int have_fake_front;
   int swap_interval;

   uint64_t previous_time;
   unsigned frames;
};

static const struct glx_context_vtable dri2_context_vtable;

/* For XCB's handling of ust/msc/sbc counters, we have to hand it the high and
 * low halves separately.  This helps you split them.
 */
static void
split_counter(uint64_t counter, uint32_t *hi, uint32_t *lo)
{
   *hi = (counter >> 32);
   *lo = counter & 0xffffffff;
}

static uint64_t
merge_counter(uint32_t hi, uint32_t lo)
{
   return ((uint64_t)hi << 32) | lo;
}

static void
dri2_destroy_context(struct glx_context *context)
{
   struct dri2_context *pcp = (struct dri2_context *) context;
   struct dri2_screen *psc = (struct dri2_screen *) context->psc;

   driReleaseDrawables(&pcp->base);

   free((char *) context->extensions);

   (*psc->core->destroyContext) (pcp->driContext);

   free(pcp);
}

static Bool
dri2_bind_context(struct glx_context *context, struct glx_context *old,
		  GLXDrawable draw, GLXDrawable read)
{
   struct dri2_context *pcp = (struct dri2_context *) context;
   struct dri2_screen *psc = (struct dri2_screen *) pcp->base.psc;
   struct dri2_drawable *pdraw, *pread;
   __DRIdrawable *dri_draw = NULL, *dri_read = NULL;
   struct glx_display *dpyPriv = psc->base.display;
   struct dri2_display *pdp;

   pdraw = (struct dri2_drawable *) driFetchDrawable(context, draw);
   pread = (struct dri2_drawable *) driFetchDrawable(context, read);

   driReleaseDrawables(&pcp->base);

   if (pdraw)
      dri_draw = pdraw->driDrawable;
   else if (draw != None)
      return GLXBadDrawable;

   if (pread)
      dri_read = pread->driDrawable;
   else if (read != None)
      return GLXBadDrawable;

   if (!(*psc->core->bindContext) (pcp->driContext, dri_draw, dri_read))
      return GLXBadContext;

   /* If the server doesn't send invalidate events, we may miss a
    * resize before the rendering starts.  Invalidate the buffers now
    * so the driver will recheck before rendering starts. */
   pdp = (struct dri2_display *) dpyPriv->dri2Display;
   if (!pdp->invalidateAvailable && pdraw) {
      dri2InvalidateBuffers(psc->base.dpy, pdraw->base.xDrawable);
      if (pread != pdraw && pread)
	 dri2InvalidateBuffers(psc->base.dpy, pread->base.xDrawable);
   }

   return Success;
}

static void
dri2_unbind_context(struct glx_context *context, struct glx_context *new)
{
   struct dri2_context *pcp = (struct dri2_context *) context;
   struct dri2_screen *psc = (struct dri2_screen *) pcp->base.psc;

   (*psc->core->unbindContext) (pcp->driContext);
}

static struct glx_context *
dri2_create_context(struct glx_screen *base,
		    struct glx_config *config_base,
		    struct glx_context *shareList, int renderType)
{
   struct dri2_context *pcp, *pcp_shared;
   struct dri2_screen *psc = (struct dri2_screen *) base;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
   __DRIcontext *shared = NULL;

   /* Check the renderType value */
   if (!validate_renderType_against_config(config_base, renderType))
       return NULL;

   if (shareList) {
      /* If the shareList context is not a DRI2 context, we cannot possibly
       * create a DRI2 context that shares it.
       */
      if (shareList->vtable->destroy != dri2_destroy_context) {
	 return NULL;
      }

      pcp_shared = (struct dri2_context *) shareList;
      shared = pcp_shared->driContext;
   }

   pcp = calloc(1, sizeof *pcp);
   if (pcp == NULL)
      return NULL;

   if (!glx_context_init(&pcp->base, &psc->base, &config->base)) {
      free(pcp);
      return NULL;
   }

   pcp->base.renderType = renderType;

   pcp->driContext =
      (*psc->dri2->createNewContext) (psc->driScreen,
                                      config->driConfig, shared, pcp);

   if (pcp->driContext == NULL) {
      free(pcp);
      return NULL;
   }

   pcp->base.vtable = &dri2_context_vtable;

   return &pcp->base;
}

static struct glx_context *
dri2_create_context_attribs(struct glx_screen *base,
			    struct glx_config *config_base,
			    struct glx_context *shareList,
			    unsigned num_attribs,
			    const uint32_t *attribs,
			    unsigned *error)
{
   struct dri2_context *pcp = NULL;
   struct dri2_context *pcp_shared = NULL;
   struct dri2_screen *psc = (struct dri2_screen *) base;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
   __DRIcontext *shared = NULL;

   uint32_t minor_ver;
   uint32_t major_ver;
   uint32_t renderType;
   uint32_t flags;
   unsigned api;
   int reset;
   uint32_t ctx_attribs[2 * 5];
   unsigned num_ctx_attribs = 0;

   if (psc->dri2->base.version < 3) {
      *error = __DRI_CTX_ERROR_NO_MEMORY;
      goto error_exit;
   }

   /* Remap the GLX tokens to DRI2 tokens.
    */
   if (!dri2_convert_glx_attribs(num_attribs, attribs,
                                 &major_ver, &minor_ver, &renderType, &flags,
                                 &api, &reset, error))
      goto error_exit;

   /* Check the renderType value */
   if (!validate_renderType_against_config(config_base, renderType))
       goto error_exit;

   if (shareList) {
      pcp_shared = (struct dri2_context *) shareList;
      shared = pcp_shared->driContext;
   }

   pcp = calloc(1, sizeof *pcp);
   if (pcp == NULL) {
      *error = __DRI_CTX_ERROR_NO_MEMORY;
      goto error_exit;
   }

   if (!glx_context_init(&pcp->base, &psc->base, &config->base))
      goto error_exit;

   ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_MAJOR_VERSION;
   ctx_attribs[num_ctx_attribs++] = major_ver;
   ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_MINOR_VERSION;
   ctx_attribs[num_ctx_attribs++] = minor_ver;

   /* Only send a value when the non-default value is requested.  By doing
    * this we don't have to check the driver's DRI2 version before sending the
    * default value.
    */
   if (reset != __DRI_CTX_RESET_NO_NOTIFICATION) {
      ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_RESET_STRATEGY;
      ctx_attribs[num_ctx_attribs++] = reset;
   }

   if (flags != 0) {
      ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_FLAGS;

      /* The current __DRI_CTX_FLAG_* values are identical to the
       * GLX_CONTEXT_*_BIT values.
       */
      ctx_attribs[num_ctx_attribs++] = flags;
   }

   /* The renderType is retrieved from attribs, or set to default
    *  of GLX_RGBA_TYPE.
    */
   pcp->base.renderType = renderType;

   pcp->driContext =
      (*psc->dri2->createContextAttribs) (psc->driScreen,
					  api,
					  config->driConfig,
					  shared,
					  num_ctx_attribs / 2,
					  ctx_attribs,
					  error,
					  pcp);

   if (pcp->driContext == NULL)
      goto error_exit;

   pcp->base.vtable = &dri2_context_vtable;

   return &pcp->base;

error_exit:
   free(pcp);

   return NULL;
}

static void
dri2DestroyDrawable(__GLXDRIdrawable *base)
{
   struct dri2_screen *psc = (struct dri2_screen *) base->psc;
   struct dri2_drawable *pdraw = (struct dri2_drawable *) base;
   struct glx_display *dpyPriv = psc->base.display;
   struct dri2_display *pdp = (struct dri2_display *)dpyPriv->dri2Display;

   __glxHashDelete(pdp->dri2Hash, pdraw->base.xDrawable);
   (*psc->core->destroyDrawable) (pdraw->driDrawable);

   /* If it's a GLX 1.3 drawables, we can destroy the DRI2 drawable
    * now, as the application explicitly asked to destroy the GLX
    * drawable.  Otherwise, for legacy drawables, we let the DRI2
    * drawable linger on the server, since there's no good way of
    * knowing when the application is done with it.  The server will
    * destroy the DRI2 drawable when it destroys the X drawable or the
    * client exits anyway. */
   if (pdraw->base.xDrawable != pdraw->base.drawable)
      DRI2DestroyDrawable(psc->base.dpy, pdraw->base.xDrawable);

   free(pdraw);
}

static __GLXDRIdrawable *
dri2CreateDrawable(struct glx_screen *base, XID xDrawable,
		   GLXDrawable drawable, struct glx_config *config_base)
{
   struct dri2_drawable *pdraw;
   struct dri2_screen *psc = (struct dri2_screen *) base;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
   struct glx_display *dpyPriv;
   struct dri2_display *pdp;
   GLint vblank_mode = DRI_CONF_VBLANK_DEF_INTERVAL_1;

   dpyPriv = __glXInitialize(psc->base.dpy);
   if (dpyPriv == NULL)
      return NULL;

   pdraw = calloc(1, sizeof(*pdraw));
   if (!pdraw)
      return NULL;

   pdraw->base.destroyDrawable = dri2DestroyDrawable;
   pdraw->base.xDrawable = xDrawable;
   pdraw->base.drawable = drawable;
   pdraw->base.psc = &psc->base;
   pdraw->bufferCount = 0;
   pdraw->swap_interval = 1; /* default may be overridden below */
   pdraw->have_back = 0;

   if (psc->config)
      psc->config->configQueryi(psc->driScreen,
				"vblank_mode", &vblank_mode);

   switch (vblank_mode) {
   case DRI_CONF_VBLANK_NEVER:
   case DRI_CONF_VBLANK_DEF_INTERVAL_0:
      pdraw->swap_interval = 0;
      break;
   case DRI_CONF_VBLANK_DEF_INTERVAL_1:
   case DRI_CONF_VBLANK_ALWAYS_SYNC:
   default:
      pdraw->swap_interval = 1;
      break;
   }

   DRI2CreateDrawable(psc->base.dpy, xDrawable);
   pdp = (struct dri2_display *)dpyPriv->dri2Display;;
   /* Create a new drawable */
   pdraw->driDrawable =
      (*psc->dri2->createNewDrawable) (psc->driScreen,
                                       config->driConfig, pdraw);

   if (!pdraw->driDrawable) {
      DRI2DestroyDrawable(psc->base.dpy, xDrawable);
      free(pdraw);
      return NULL;
   }

   if (__glxHashInsert(pdp->dri2Hash, xDrawable, pdraw)) {
      (*psc->core->destroyDrawable) (pdraw->driDrawable);
      DRI2DestroyDrawable(psc->base.dpy, xDrawable);
      free(pdraw);
      return None;
   }

   /*
    * Make sure server has the same swap interval we do for the new
    * drawable.
    */
   if (psc->vtable.setSwapInterval)
      psc->vtable.setSwapInterval(&pdraw->base, pdraw->swap_interval);

   return &pdraw->base;
}

static int
dri2DrawableGetMSC(struct glx_screen *psc, __GLXDRIdrawable *pdraw,
		   int64_t *ust, int64_t *msc, int64_t *sbc)
{
   xcb_connection_t *c = XGetXCBConnection(pdraw->psc->dpy);
   xcb_dri2_get_msc_cookie_t get_msc_cookie;
   xcb_dri2_get_msc_reply_t *get_msc_reply;

   get_msc_cookie = xcb_dri2_get_msc_unchecked(c, pdraw->xDrawable);
   get_msc_reply = xcb_dri2_get_msc_reply(c, get_msc_cookie, NULL);

   if (!get_msc_reply)
      return 0;

   *ust = merge_counter(get_msc_reply->ust_hi, get_msc_reply->ust_lo);
   *msc = merge_counter(get_msc_reply->msc_hi, get_msc_reply->msc_lo);
   *sbc = merge_counter(get_msc_reply->sbc_hi, get_msc_reply->sbc_lo);
   free(get_msc_reply);

   return 1;
}

static int
dri2WaitForMSC(__GLXDRIdrawable *pdraw, int64_t target_msc, int64_t divisor,
	       int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc)
{
   xcb_connection_t *c = XGetXCBConnection(pdraw->psc->dpy);
   xcb_dri2_wait_msc_cookie_t wait_msc_cookie;
   xcb_dri2_wait_msc_reply_t *wait_msc_reply;
   uint32_t target_msc_hi, target_msc_lo;
   uint32_t divisor_hi, divisor_lo;
   uint32_t remainder_hi, remainder_lo;

   split_counter(target_msc, &target_msc_hi, &target_msc_lo);
   split_counter(divisor, &divisor_hi, &divisor_lo);
   split_counter(remainder, &remainder_hi, &remainder_lo);

   wait_msc_cookie = xcb_dri2_wait_msc_unchecked(c, pdraw->xDrawable,
                                                 target_msc_hi, target_msc_lo,
                                                 divisor_hi, divisor_lo,
                                                 remainder_hi, remainder_lo);
   wait_msc_reply = xcb_dri2_wait_msc_reply(c, wait_msc_cookie, NULL);

   if (!wait_msc_reply)
      return 0;

   *ust = merge_counter(wait_msc_reply->ust_hi, wait_msc_reply->ust_lo);
   *msc = merge_counter(wait_msc_reply->msc_hi, wait_msc_reply->msc_lo);
   *sbc = merge_counter(wait_msc_reply->sbc_hi, wait_msc_reply->sbc_lo);
   free(wait_msc_reply);

   return 1;
}

static int
dri2WaitForSBC(__GLXDRIdrawable *pdraw, int64_t target_sbc, int64_t *ust,
	       int64_t *msc, int64_t *sbc)
{
   xcb_connection_t *c = XGetXCBConnection(pdraw->psc->dpy);
   xcb_dri2_wait_sbc_cookie_t wait_sbc_cookie;
   xcb_dri2_wait_sbc_reply_t *wait_sbc_reply;
   uint32_t target_sbc_hi, target_sbc_lo;

   split_counter(target_sbc, &target_sbc_hi, &target_sbc_lo);

   wait_sbc_cookie = xcb_dri2_wait_sbc_unchecked(c, pdraw->xDrawable,
                                                 target_sbc_hi, target_sbc_lo);
   wait_sbc_reply = xcb_dri2_wait_sbc_reply(c, wait_sbc_cookie, NULL);

   if (!wait_sbc_reply)
      return 0;

   *ust = merge_counter(wait_sbc_reply->ust_hi, wait_sbc_reply->ust_lo);
   *msc = merge_counter(wait_sbc_reply->msc_hi, wait_sbc_reply->msc_lo);
   *sbc = merge_counter(wait_sbc_reply->sbc_hi, wait_sbc_reply->sbc_lo);
   free(wait_sbc_reply);

   return 1;
}

static __DRIcontext *
dri2GetCurrentContext()
{
   struct glx_context *gc = __glXGetCurrentContext();
   struct dri2_context *dri2Ctx = (struct dri2_context *)gc;

   return dri2Ctx ? dri2Ctx->driContext : NULL;
}

/**
 * dri2Throttle - Request driver throttling
 *
 * This function uses the DRI2 throttle extension to give the
 * driver the opportunity to throttle on flush front, copysubbuffer
 * and swapbuffers.
 */
static void
dri2Throttle(struct dri2_screen *psc,
	     struct dri2_drawable *draw,
	     enum __DRI2throttleReason reason)
{
   if (psc->throttle) {
      __DRIcontext *ctx = dri2GetCurrentContext();

      psc->throttle->throttle(ctx, draw->driDrawable, reason);
   }
}

/**
 * Asks the driver to flush any queued work necessary for serializing with the
 * X command stream, and optionally the slightly more strict requirement of
 * glFlush() equivalence (which would require flushing even if nothing had
 * been drawn to a window system framebuffer, for example).
 */
static void
dri2Flush(struct dri2_screen *psc,
          __DRIcontext *ctx,
          struct dri2_drawable *draw,
          unsigned flags,
          enum __DRI2throttleReason throttle_reason)
{
   if (ctx && psc->f && psc->f->base.version >= 4) {
      psc->f->flush_with_flags(ctx, draw->driDrawable, flags, throttle_reason);
   } else {
      if (flags & __DRI2_FLUSH_CONTEXT)
         glFlush();

      if (psc->f)
         psc->f->flush(draw->driDrawable);

      dri2Throttle(psc, draw, throttle_reason);
   }
}

static void
__dri2CopySubBuffer(__GLXDRIdrawable *pdraw, int x, int y,
		    int width, int height,
		    enum __DRI2throttleReason reason, Bool flush)
{
   struct dri2_drawable *priv = (struct dri2_drawable *) pdraw;
   struct dri2_screen *psc = (struct dri2_screen *) pdraw->psc;
   XRectangle xrect;
   XserverRegion region;
   __DRIcontext *ctx = dri2GetCurrentContext();
   unsigned flags;

   /* Check we have the right attachments */
   if (!priv->have_back)
      return;

   xrect.x = x;
   xrect.y = priv->height - y - height;
   xrect.width = width;
   xrect.height = height;

   flags = __DRI2_FLUSH_DRAWABLE;
   if (flush)
      flags |= __DRI2_FLUSH_CONTEXT;
   dri2Flush(psc, ctx, priv, flags, __DRI2_THROTTLE_SWAPBUFFER);

   region = XFixesCreateRegion(psc->base.dpy, &xrect, 1);
   DRI2CopyRegion(psc->base.dpy, pdraw->xDrawable, region,
                  DRI2BufferFrontLeft, DRI2BufferBackLeft);

   /* Refresh the fake front (if present) after we just damaged the real
    * front.
    */
   if (priv->have_fake_front)
      DRI2CopyRegion(psc->base.dpy, pdraw->xDrawable, region,
		     DRI2BufferFakeFrontLeft, DRI2BufferFrontLeft);

   XFixesDestroyRegion(psc->base.dpy, region);
}

static void
dri2CopySubBuffer(__GLXDRIdrawable *pdraw, int x, int y,
		  int width, int height, Bool flush)
{
   __dri2CopySubBuffer(pdraw, x, y, width, height,
		       __DRI2_THROTTLE_COPYSUBBUFFER, flush);
}


static void
dri2_copy_drawable(struct dri2_drawable *priv, int dest, int src)
{
   XRectangle xrect;
   XserverRegion region;
   struct dri2_screen *psc = (struct dri2_screen *) priv->base.psc;

   xrect.x = 0;
   xrect.y = 0;
   xrect.width = priv->width;
   xrect.height = priv->height;

   if (psc->f)
      (*psc->f->flush) (priv->driDrawable);

   region = XFixesCreateRegion(psc->base.dpy, &xrect, 1);
   DRI2CopyRegion(psc->base.dpy, priv->base.xDrawable, region, dest, src);
   XFixesDestroyRegion(psc->base.dpy, region);

}

static void
dri2_wait_x(struct glx_context *gc)
{
   struct dri2_drawable *priv = (struct dri2_drawable *)
      GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);

   if (priv == NULL || !priv->have_fake_front)
      return;

   dri2_copy_drawable(priv, DRI2BufferFakeFrontLeft, DRI2BufferFrontLeft);
}

static void
dri2_wait_gl(struct glx_context *gc)
{
   struct dri2_drawable *priv = (struct dri2_drawable *)
      GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);

   if (priv == NULL || !priv->have_fake_front)
      return;

   dri2_copy_drawable(priv, DRI2BufferFrontLeft, DRI2BufferFakeFrontLeft);
}

/**
 * Called by the driver when it needs to update the real front buffer with the
 * contents of its fake front buffer.
 */
static void
dri2FlushFrontBuffer(__DRIdrawable *driDrawable, void *loaderPrivate)
{
   struct glx_display *priv;
   struct dri2_display *pdp;
   struct glx_context *gc;
   struct dri2_drawable *pdraw = loaderPrivate;
   struct dri2_screen *psc;

   if (!pdraw)
      return;

   if (!pdraw->base.psc)
      return;

   psc = (struct dri2_screen *) pdraw->base.psc;

   priv = __glXInitialize(psc->base.dpy);

   if (priv == NULL)
       return;

   pdp = (struct dri2_display *) priv->dri2Display;
   gc = __glXGetCurrentContext();

   dri2Throttle(psc, pdraw, __DRI2_THROTTLE_FLUSHFRONT);

   /* Old servers don't send invalidate events */
   if (!pdp->invalidateAvailable)
       dri2InvalidateBuffers(priv->dpy, pdraw->base.xDrawable);

   dri2_wait_gl(gc);
}


static void
dri2DestroyScreen(struct glx_screen *base)
{
   struct dri2_screen *psc = (struct dri2_screen *) base;

   /* Free the direct rendering per screen data */
   (*psc->core->destroyScreen) (psc->driScreen);
   driDestroyConfigs(psc->driver_configs);
   close(psc->fd);
   free(psc);
}

/**
 * Process list of buffer received from the server
 *
 * Processes the list of buffers received in a reply from the server to either
 * \c DRI2GetBuffers or \c DRI2GetBuffersWithFormat.
 */
static void
process_buffers(struct dri2_drawable * pdraw, DRI2Buffer * buffers,
                unsigned count)
{
   int i;

   pdraw->bufferCount = count;
   pdraw->have_fake_front = 0;
   pdraw->have_back = 0;

   /* This assumes the DRI2 buffer attachment tokens matches the
    * __DRIbuffer tokens. */
   for (i = 0; i < count; i++) {
      pdraw->buffers[i].attachment = buffers[i].attachment;
      pdraw->buffers[i].name = buffers[i].name;
      pdraw->buffers[i].pitch = buffers[i].pitch;
      pdraw->buffers[i].cpp = buffers[i].cpp;
      pdraw->buffers[i].flags = buffers[i].flags;
      if (pdraw->buffers[i].attachment == __DRI_BUFFER_FAKE_FRONT_LEFT)
         pdraw->have_fake_front = 1;
      if (pdraw->buffers[i].attachment == __DRI_BUFFER_BACK_LEFT)
         pdraw->have_back = 1;
   }

}

unsigned dri2GetSwapEventType(Display* dpy, XID drawable)
{
      struct glx_display *glx_dpy = __glXInitialize(dpy);
      __GLXDRIdrawable *pdraw;
      pdraw = dri2GetGlxDrawableFromXDrawableId(dpy, drawable);
      if (!pdraw || !(pdraw->eventMask & GLX_BUFFER_SWAP_COMPLETE_INTEL_MASK))
         return 0;
      return glx_dpy->codes->first_event + GLX_BufferSwapComplete;
}

static void show_fps(struct dri2_drawable *draw)
{
   const int interval =
      ((struct dri2_screen *) draw->base.psc)->show_fps_interval;
   struct timeval tv;
   uint64_t current_time;

   gettimeofday(&tv, 0);
   current_time = (uint64_t)tv.tv_sec*1000000 + (uint64_t)tv.tv_usec;

   draw->frames++;

   if (draw->previous_time + interval * 1000000 <= current_time) {
      if (draw->previous_time) {
         fprintf(stderr, "libGL: FPS = %.1f\n",
                 ((uint64_t)draw->frames * 1000000) /
                 (double)(current_time - draw->previous_time));
      }
      draw->frames = 0;
      draw->previous_time = current_time;
   }
}

static int64_t
dri2XcbSwapBuffers(Display *dpy,
                  __GLXDRIdrawable *pdraw,
                  int64_t target_msc,
                  int64_t divisor,
                  int64_t remainder)
{
   xcb_dri2_swap_buffers_cookie_t swap_buffers_cookie;
   xcb_dri2_swap_buffers_reply_t *swap_buffers_reply;
   uint32_t target_msc_hi, target_msc_lo;
   uint32_t divisor_hi, divisor_lo;
   uint32_t remainder_hi, remainder_lo;
   int64_t ret = 0;
   xcb_connection_t *c = XGetXCBConnection(dpy);

   split_counter(target_msc, &target_msc_hi, &target_msc_lo);
   split_counter(divisor, &divisor_hi, &divisor_lo);
   split_counter(remainder, &remainder_hi, &remainder_lo);

   swap_buffers_cookie =
      xcb_dri2_swap_buffers_unchecked(c, pdraw->xDrawable,
                                      target_msc_hi, target_msc_lo,
                                      divisor_hi, divisor_lo,
                                      remainder_hi, remainder_lo);

   /* Immediately wait on the swapbuffers reply.  If we didn't, we'd have
    * to do so some time before reusing a (non-pageflipped) backbuffer.
    * Otherwise, the new rendering could get ahead of the X Server's
    * dispatch of the swapbuffer and you'd display garbage.
    *
    * We use XSync() first to reap the invalidate events through the event
    * filter, to ensure that the next drawing doesn't use an invalidated
    * buffer.
    */
   XSync(dpy, False);

   swap_buffers_reply =
      xcb_dri2_swap_buffers_reply(c, swap_buffers_cookie, NULL);
   if (swap_buffers_reply) {
      ret = merge_counter(swap_buffers_reply->swap_hi,
                          swap_buffers_reply->swap_lo);
      free(swap_buffers_reply);
   }
   return ret;
}

static int64_t
dri2SwapBuffers(__GLXDRIdrawable *pdraw, int64_t target_msc, int64_t divisor,
		int64_t remainder, Bool flush)
{
    struct dri2_drawable *priv = (struct dri2_drawable *) pdraw;
    struct glx_display *dpyPriv = __glXInitialize(priv->base.psc->dpy);
    struct dri2_screen *psc = (struct dri2_screen *) priv->base.psc;
    struct dri2_display *pdp =
	(struct dri2_display *)dpyPriv->dri2Display;
    int64_t ret = 0;

    /* Check we have the right attachments */
    if (!priv->have_back)
	return ret;

    /* Old servers can't handle swapbuffers */
    if (!pdp->swapAvailable) {
       __dri2CopySubBuffer(pdraw, 0, 0, priv->width, priv->height,
			   __DRI2_THROTTLE_SWAPBUFFER, flush);
    } else {
       __DRIcontext *ctx = dri2GetCurrentContext();
       unsigned flags = __DRI2_FLUSH_DRAWABLE;
       if (flush)
          flags |= __DRI2_FLUSH_CONTEXT;
       dri2Flush(psc, ctx, priv, flags, __DRI2_THROTTLE_SWAPBUFFER);

       ret = dri2XcbSwapBuffers(pdraw->psc->dpy, pdraw,
                                target_msc, divisor, remainder);
    }

    if (psc->show_fps_interval) {
       show_fps(priv);
    }

    /* Old servers don't send invalidate events */
    if (!pdp->invalidateAvailable)
       dri2InvalidateBuffers(dpyPriv->dpy, pdraw->xDrawable);

    return ret;
}

static __DRIbuffer *
dri2GetBuffers(__DRIdrawable * driDrawable,
               int *width, int *height,
               unsigned int *attachments, int count,
               int *out_count, void *loaderPrivate)
{
   struct dri2_drawable *pdraw = loaderPrivate;
   DRI2Buffer *buffers;

   buffers = DRI2GetBuffers(pdraw->base.psc->dpy, pdraw->base.xDrawable,
                            width, height, attachments, count, out_count);
   if (buffers == NULL)
      return NULL;

   pdraw->width = *width;
   pdraw->height = *height;
   process_buffers(pdraw, buffers, *out_count);

   free(buffers);

   return pdraw->buffers;
}

static __DRIbuffer *
dri2GetBuffersWithFormat(__DRIdrawable * driDrawable,
                         int *width, int *height,
                         unsigned int *attachments, int count,
                         int *out_count, void *loaderPrivate)
{
   struct dri2_drawable *pdraw = loaderPrivate;
   DRI2Buffer *buffers;

   buffers = DRI2GetBuffersWithFormat(pdraw->base.psc->dpy,
                                      pdraw->base.xDrawable,
                                      width, height, attachments,
                                      count, out_count);
   if (buffers == NULL)
      return NULL;

   pdraw->width = *width;
   pdraw->height = *height;
   process_buffers(pdraw, buffers, *out_count);

   free(buffers);

   return pdraw->buffers;
}

static int
dri2SetSwapInterval(__GLXDRIdrawable *pdraw, int interval)
{
   xcb_connection_t *c = XGetXCBConnection(pdraw->psc->dpy);
   struct dri2_drawable *priv =  (struct dri2_drawable *) pdraw;
   GLint vblank_mode = DRI_CONF_VBLANK_DEF_INTERVAL_1;
   struct dri2_screen *psc = (struct dri2_screen *) priv->base.psc;

   if (psc->config)
      psc->config->configQueryi(psc->driScreen,
				"vblank_mode", &vblank_mode);

   switch (vblank_mode) {
   case DRI_CONF_VBLANK_NEVER:
      if (interval != 0)
         return GLX_BAD_VALUE;
      break;
   case DRI_CONF_VBLANK_ALWAYS_SYNC:
      if (interval <= 0)
	 return GLX_BAD_VALUE;
      break;
   default:
      break;
   }

   xcb_dri2_swap_interval(c, priv->base.xDrawable, interval);
   priv->swap_interval = interval;

   return 0;
}

static int
dri2GetSwapInterval(__GLXDRIdrawable *pdraw)
{
   struct dri2_drawable *priv =  (struct dri2_drawable *) pdraw;

  return priv->swap_interval;
}

static const __DRIdri2LoaderExtension dri2LoaderExtension = {
   .base = { __DRI_DRI2_LOADER, 3 },

   .getBuffers              = dri2GetBuffers,
   .flushFrontBuffer        = dri2FlushFrontBuffer,
   .getBuffersWithFormat    = dri2GetBuffersWithFormat,
};

static const __DRIdri2LoaderExtension dri2LoaderExtension_old = {
   .base = { __DRI_DRI2_LOADER, 3 },

   .getBuffers              = dri2GetBuffers,
   .flushFrontBuffer        = dri2FlushFrontBuffer,
   .getBuffersWithFormat    = NULL,
};

static const __DRIuseInvalidateExtension dri2UseInvalidate = {
   .base = { __DRI_USE_INVALIDATE, 1 }
};

_X_HIDDEN void
dri2InvalidateBuffers(Display *dpy, XID drawable)
{
   __GLXDRIdrawable *pdraw =
      dri2GetGlxDrawableFromXDrawableId(dpy, drawable);
   struct dri2_screen *psc;
   struct dri2_drawable *pdp = (struct dri2_drawable *) pdraw;

   if (!pdraw)
      return;

   psc = (struct dri2_screen *) pdraw->psc;

   if (pdraw && psc->f && psc->f->base.version >= 3 && psc->f->invalidate)
       psc->f->invalidate(pdp->driDrawable);
}

static void
dri2_bind_tex_image(Display * dpy,
		    GLXDrawable drawable,
		    int buffer, const int *attrib_list)
{
   struct glx_context *gc = __glXGetCurrentContext();
   struct dri2_context *pcp = (struct dri2_context *) gc;
   __GLXDRIdrawable *base = GetGLXDRIDrawable(dpy, drawable);
   struct glx_display *dpyPriv = __glXInitialize(dpy);
   struct dri2_drawable *pdraw = (struct dri2_drawable *) base;
   struct dri2_display *pdp;
   struct dri2_screen *psc;

   if (dpyPriv == NULL)
       return;

   pdp = (struct dri2_display *) dpyPriv->dri2Display;

   if (pdraw != NULL) {
      psc = (struct dri2_screen *) base->psc;

      if (!pdp->invalidateAvailable && psc->f &&
           psc->f->base.version >= 3 && psc->f->invalidate)
	 psc->f->invalidate(pdraw->driDrawable);

      if (psc->texBuffer->base.version >= 2 &&
	  psc->texBuffer->setTexBuffer2 != NULL) {
	 (*psc->texBuffer->setTexBuffer2) (pcp->driContext,
					   pdraw->base.textureTarget,
					   pdraw->base.textureFormat,
					   pdraw->driDrawable);
      }
      else {
	 (*psc->texBuffer->setTexBuffer) (pcp->driContext,
					  pdraw->base.textureTarget,
					  pdraw->driDrawable);
      }
   }
}

static void
dri2_release_tex_image(Display * dpy, GLXDrawable drawable, int buffer)
{
   struct glx_context *gc = __glXGetCurrentContext();
   struct dri2_context *pcp = (struct dri2_context *) gc;
   __GLXDRIdrawable *base = GetGLXDRIDrawable(dpy, drawable);
   struct glx_display *dpyPriv = __glXInitialize(dpy);
   struct dri2_drawable *pdraw = (struct dri2_drawable *) base;
   struct dri2_screen *psc;

   if (dpyPriv != NULL && pdraw != NULL) {
      psc = (struct dri2_screen *) base->psc;

      if (psc->texBuffer->base.version >= 3 &&
          psc->texBuffer->releaseTexBuffer != NULL) {
         (*psc->texBuffer->releaseTexBuffer) (pcp->driContext,
                                           pdraw->base.textureTarget,
                                           pdraw->driDrawable);
      }
   }
}

static const struct glx_context_vtable dri2_context_vtable = {
   .destroy             = dri2_destroy_context,
   .bind                = dri2_bind_context,
   .unbind              = dri2_unbind_context,
   .wait_gl             = dri2_wait_gl,
   .wait_x              = dri2_wait_x,
   .use_x_font          = DRI_glXUseXFont,
   .bind_tex_image      = dri2_bind_tex_image,
   .release_tex_image   = dri2_release_tex_image,
   .get_proc_address    = NULL,
};

static void
dri2BindExtensions(struct dri2_screen *psc, struct glx_display * priv,
                   const char *driverName)
{
   const struct dri2_display *const pdp = (struct dri2_display *)
      priv->dri2Display;
   const __DRIextension **extensions;
   int i;

   extensions = psc->core->getExtensions(psc->driScreen);

   __glXEnableDirectExtension(&psc->base, "GLX_SGI_video_sync");
   __glXEnableDirectExtension(&psc->base, "GLX_SGI_swap_control");
   __glXEnableDirectExtension(&psc->base, "GLX_MESA_swap_control");
   __glXEnableDirectExtension(&psc->base, "GLX_SGI_make_current_read");

   /*
    * GLX_INTEL_swap_event is broken on the server side, where it's
    * currently unconditionally enabled. This completely breaks
    * systems running on drivers which don't support that extension.
    * There's no way to test for its presence on this side, so instead
    * of disabling it unconditionally, just disable it for drivers
    * which are known to not support it, or for DDX drivers supporting
    * only an older (pre-ScheduleSwap) version of DRI2.
    *
    * This is a hack which is required until:
    * http://lists.x.org/archives/xorg-devel/2013-February/035449.html
    * is merged and updated xserver makes it's way into distros:
    */
   if (pdp->swapAvailable && strcmp(driverName, "vmwgfx") != 0) {
      __glXEnableDirectExtension(&psc->base, "GLX_INTEL_swap_event");
   }

   if (psc->dri2->base.version >= 3) {
      const unsigned mask = psc->dri2->getAPIMask(psc->driScreen);

      __glXEnableDirectExtension(&psc->base, "GLX_ARB_create_context");
      __glXEnableDirectExtension(&psc->base, "GLX_ARB_create_context_profile");

      if ((mask & (1 << __DRI_API_GLES2)) != 0)
	 __glXEnableDirectExtension(&psc->base,
				    "GLX_EXT_create_context_es2_profile");
   }

   for (i = 0; extensions[i]; i++) {
      if ((strcmp(extensions[i]->name, __DRI_TEX_BUFFER) == 0)) {
	 psc->texBuffer = (__DRItexBufferExtension *) extensions[i];
	 __glXEnableDirectExtension(&psc->base, "GLX_EXT_texture_from_pixmap");
      }

      if ((strcmp(extensions[i]->name, __DRI2_FLUSH) == 0)) {
	 psc->f = (__DRI2flushExtension *) extensions[i];
	 /* internal driver extension, no GL extension exposed */
      }

      if ((strcmp(extensions[i]->name, __DRI2_CONFIG_QUERY) == 0))
	 psc->config = (__DRI2configQueryExtension *) extensions[i];

      if (((strcmp(extensions[i]->name, __DRI2_THROTTLE) == 0)))
	 psc->throttle = (__DRI2throttleExtension *) extensions[i];

      /* DRI2 version 3 is also required because
       * GLX_ARB_create_context_robustness requires GLX_ARB_create_context.
       */
      if (psc->dri2->base.version >= 3
          && strcmp(extensions[i]->name, __DRI2_ROBUSTNESS) == 0)
         __glXEnableDirectExtension(&psc->base,
                                    "GLX_ARB_create_context_robustness");

      /* DRI2 version 3 is also required because GLX_MESA_query_renderer
       * requires GLX_ARB_create_context_profile.
       */
      if (psc->dri2->base.version >= 3
          && strcmp(extensions[i]->name, __DRI2_RENDERER_QUERY) == 0) {
         psc->rendererQuery = (__DRI2rendererQueryExtension *) extensions[i];
         __glXEnableDirectExtension(&psc->base, "GLX_MESA_query_renderer");
      }
   }
}

static const struct glx_screen_vtable dri2_screen_vtable = {
   .create_context         = dri2_create_context,
   .create_context_attribs = dri2_create_context_attribs,
   .query_renderer_integer = dri2_query_renderer_integer,
   .query_renderer_string  = dri2_query_renderer_string,
};

static struct glx_screen *
dri2CreateScreen(int screen, struct glx_display * priv)
{
   const __DRIconfig **driver_configs;
   const __DRIextension **extensions;
   const struct dri2_display *const pdp = (struct dri2_display *)
      priv->dri2Display;
   struct dri2_screen *psc;
   __GLXDRIscreen *psp;
   struct glx_config *configs = NULL, *visuals = NULL;
   char *driverName = NULL, *loader_driverName, *deviceName, *tmp;
   drm_magic_t magic;
   int i;

   psc = calloc(1, sizeof *psc);
   if (psc == NULL)
      return NULL;

   psc->fd = -1;

   if (!glx_screen_init(&psc->base, screen, priv)) {
      free(psc);
      return NULL;
   }

   if (!DRI2Connect(priv->dpy, RootWindow(priv->dpy, screen),
		    &driverName, &deviceName)) {
      glx_screen_cleanup(&psc->base);
      free(psc);
      InfoMessageF("screen %d does not appear to be DRI2 capable\n", screen);
      return NULL;
   }

#ifdef O_CLOEXEC
   psc->fd = open(deviceName, O_RDWR | O_CLOEXEC);
   if (psc->fd == -1 && errno == EINVAL)
#endif
   {
      psc->fd = open(deviceName, O_RDWR);
      if (psc->fd != -1)
         fcntl(psc->fd, F_SETFD, fcntl(psc->fd, F_GETFD) | FD_CLOEXEC);
   }
   if (psc->fd < 0) {
      ErrorMessageF("failed to open drm device: %s\n", strerror(errno));
      goto handle_error;
   }

   if (drmGetMagic(psc->fd, &magic)) {
      ErrorMessageF("failed to get magic\n");
      goto handle_error;
   }

   if (!DRI2Authenticate(priv->dpy, RootWindow(priv->dpy, screen), magic)) {
      ErrorMessageF("failed to authenticate magic %d\n", magic);
      goto handle_error;
   }

   /* If Mesa knows about the appropriate driver for this fd, then trust it.
    * Otherwise, default to the server's value.
    */
   loader_driverName = loader_get_driver_for_fd(psc->fd, 0);
   if (loader_driverName) {
      free(driverName);
      driverName = loader_driverName;
   }

   psc->driver = driOpenDriver(driverName);
   if (psc->driver == NULL) {
      ErrorMessageF("driver pointer missing\n");
      goto handle_error;
   }

   extensions = driGetDriverExtensions(psc->driver, driverName);
   if (extensions == NULL)
      goto handle_error;

   for (i = 0; extensions[i]; i++) {
      if (strcmp(extensions[i]->name, __DRI_CORE) == 0)
	 psc->core = (__DRIcoreExtension *) extensions[i];
      if (strcmp(extensions[i]->name, __DRI_DRI2) == 0)
	 psc->dri2 = (__DRIdri2Extension *) extensions[i];
   }

   if (psc->core == NULL || psc->dri2 == NULL) {
      ErrorMessageF("core dri or dri2 extension not found\n");
      goto handle_error;
   }

   if (psc->dri2->base.version >= 4) {
      psc->driScreen =
         psc->dri2->createNewScreen2(screen, psc->fd,
                                     (const __DRIextension **)
                                     &pdp->loader_extensions[0],
                                     extensions,
                                     &driver_configs, psc);
   } else {
      psc->driScreen =
         psc->dri2->createNewScreen(screen, psc->fd,
                                    (const __DRIextension **)
                                    &pdp->loader_extensions[0],
                                    &driver_configs, psc);
   }

   if (psc->driScreen == NULL) {
      ErrorMessageF("failed to create dri screen\n");
      goto handle_error;
   }

   dri2BindExtensions(psc, priv, driverName);

   configs = driConvertConfigs(psc->core, psc->base.configs, driver_configs);
   visuals = driConvertConfigs(psc->core, psc->base.visuals, driver_configs);

   if (!configs || !visuals)
       goto handle_error;

   glx_config_destroy_list(psc->base.configs);
   psc->base.configs = configs;
   glx_config_destroy_list(psc->base.visuals);
   psc->base.visuals = visuals;

   psc->driver_configs = driver_configs;

   psc->base.vtable = &dri2_screen_vtable;
   psp = &psc->vtable;
   psc->base.driScreen = psp;
   psp->destroyScreen = dri2DestroyScreen;
   psp->createDrawable = dri2CreateDrawable;
   psp->swapBuffers = dri2SwapBuffers;
   psp->getDrawableMSC = NULL;
   psp->waitForMSC = NULL;
   psp->waitForSBC = NULL;
   psp->setSwapInterval = NULL;
   psp->getSwapInterval = NULL;
   psp->getBufferAge = NULL;

   if (pdp->driMinor >= 2) {
      psp->getDrawableMSC = dri2DrawableGetMSC;
      psp->waitForMSC = dri2WaitForMSC;
      psp->waitForSBC = dri2WaitForSBC;
      psp->setSwapInterval = dri2SetSwapInterval;
      psp->getSwapInterval = dri2GetSwapInterval;
      __glXEnableDirectExtension(&psc->base, "GLX_OML_sync_control");
   }

   /* DRI2 suports SubBuffer through DRI2CopyRegion, so it's always
    * available.*/
   psp->copySubBuffer = dri2CopySubBuffer;
   __glXEnableDirectExtension(&psc->base, "GLX_MESA_copy_sub_buffer");

   free(driverName);
   free(deviceName);

   tmp = getenv("LIBGL_SHOW_FPS");
   psc->show_fps_interval = (tmp) ? atoi(tmp) : 0;
   if (psc->show_fps_interval < 0)
      psc->show_fps_interval = 0;

   return &psc->base;

handle_error:
   CriticalErrorMessageF("failed to load driver: %s\n", driverName);

   if (configs)
       glx_config_destroy_list(configs);
   if (visuals)
       glx_config_destroy_list(visuals);
   if (psc->driScreen)
       psc->core->destroyScreen(psc->driScreen);
   psc->driScreen = NULL;
   if (psc->fd >= 0)
      close(psc->fd);
   if (psc->driver)
      dlclose(psc->driver);

   free(driverName);
   free(deviceName);
   glx_screen_cleanup(&psc->base);
   free(psc);

   return NULL;
}

/* Called from __glXFreeDisplayPrivate.
 */
static void
dri2DestroyDisplay(__GLXDRIdisplay * dpy)
{
   struct dri2_display *pdp = (struct dri2_display *) dpy;

   __glxHashDestroy(pdp->dri2Hash);
   free(dpy);
}

_X_HIDDEN __GLXDRIdrawable *
dri2GetGlxDrawableFromXDrawableId(Display *dpy, XID id)
{
   struct glx_display *d = __glXInitialize(dpy);
   struct dri2_display *pdp = (struct dri2_display *) d->dri2Display;
   __GLXDRIdrawable *pdraw;

   if (__glxHashLookup(pdp->dri2Hash, id, (void *) &pdraw) == 0)
      return pdraw;

   return NULL;
}

/*
 * Allocate, initialize and return a __DRIdisplayPrivate object.
 * This is called from __glXInitialize() when we are given a new
 * display pointer.
 */
_X_HIDDEN __GLXDRIdisplay *
dri2CreateDisplay(Display * dpy)
{
   struct dri2_display *pdp;
   int eventBase, errorBase, i;

   if (!DRI2QueryExtension(dpy, &eventBase, &errorBase))
      return NULL;

   pdp = malloc(sizeof *pdp);
   if (pdp == NULL)
      return NULL;

   if (!DRI2QueryVersion(dpy, &pdp->driMajor, &pdp->driMinor)) {
      free(pdp);
      return NULL;
   }

   pdp->driPatch = 0;
   pdp->swapAvailable = (pdp->driMinor >= 2);
   pdp->invalidateAvailable = (pdp->driMinor >= 3);

   pdp->base.destroyDisplay = dri2DestroyDisplay;
   pdp->base.createScreen = dri2CreateScreen;

   i = 0;
   if (pdp->driMinor < 1)
      pdp->loader_extensions[i++] = &dri2LoaderExtension_old.base;
   else
      pdp->loader_extensions[i++] = &dri2LoaderExtension.base;
   
   pdp->loader_extensions[i++] = &systemTimeExtension.base;

   pdp->loader_extensions[i++] = &dri2UseInvalidate.base;

   pdp->loader_extensions[i++] = NULL;

   pdp->dri2Hash = __glxHashCreate();
   if (pdp->dri2Hash == NULL) {
      free(pdp);
      return NULL;
   }

   return &pdp->base;
}

#endif /* GLX_DIRECT_RENDERING */
@


1.9
log
@Merge Mesa 10.2.9
@
text
@@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d1266 1
a1266 2
   if (!configs || !visuals) {
       ErrorMessageF("No matching fbConfigs or visuals found\n");
a1267 1
   }
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1266 2
a1267 1
   if (!configs || !visuals)
d1269 1
@


1.6
log
@Merge Mesa 9.2.1
@
text
@a39 1
#include "glapi.h"
a41 1
#include "xf86dri.h"
a47 1
#include "xf86drm.h"
d50 2
a79 20
struct dri2_screen {
   struct glx_screen base;

   __DRIscreen *driScreen;
   __GLXDRIscreen vtable;
   const __DRIdri2Extension *dri2;
   const __DRIcoreExtension *core;

   const __DRI2flushExtension *f;
   const __DRI2configQueryExtension *config;
   const __DRItexBufferExtension *texBuffer;
   const __DRI2throttleExtension *throttle;
   const __DRIconfig **driver_configs;

   void *driver;
   int fd;

   Bool show_fps;
};

d141 2
d150 8
a157 1
   if (pdraw == NULL || pread == NULL)
d160 1
a160 2
   if (!(*psc->core->bindContext) (pcp->driContext,
				   pdraw->driDrawable, pread->driDrawable))
d166 2
a167 2
   pdp = (struct dri2_display *) psc->base.display;
   if (!pdp->invalidateAvailable) {
d169 1
a169 1
      if (pread != pdraw)
d375 4
a407 2

   dpyPriv = __glXInitialize(psc->base.dpy);
d687 4
d760 2
d770 1
a770 1
   if (draw->previous_time + 1000000 <= current_time) {
d857 1
a857 1
    if (psc->show_fps) {
d956 5
a960 4
   {__DRI_DRI2_LOADER, __DRI_DRI2_LOADER_VERSION},
   dri2GetBuffers,
   dri2FlushFrontBuffer,
   dri2GetBuffersWithFormat,
d964 5
a968 4
   {__DRI_DRI2_LOADER, __DRI_DRI2_LOADER_VERSION},
   dri2GetBuffers,
   dri2FlushFrontBuffer,
   NULL,
d972 1
a972 1
   { __DRI_USE_INVALIDATE, __DRI_USE_INVALIDATE_VERSION }
d1002 1
a1002 2
   struct dri2_display *pdp =
      (struct dri2_display *) dpyPriv->dri2Display;
d1005 5
a1034 1
#if __DRI_TEX_BUFFER_VERSION >= 3
a1039 2
   struct dri2_display *pdp =
      (struct dri2_display *) dpyPriv->dri2Display;
d1042 1
a1042 1
   if (pdraw != NULL) {
a1051 1
#endif
d1055 9
a1063 9
   dri2_destroy_context,
   dri2_bind_context,
   dri2_unbind_context,
   dri2_wait_gl,
   dri2_wait_x,
   DRI_glXUseXFont,
   dri2_bind_tex_image,
   dri2_release_tex_image,
   NULL, /* get_proc_address */
d1134 9
d1147 4
a1150 2
   dri2_create_context,
   dri2_create_context_attribs
d1163 1
a1163 1
   char *driverName, *deviceName, *tmp;
a1185 24
   psc->driver = driOpenDriver(driverName);
   if (psc->driver == NULL) {
      ErrorMessageF("driver pointer missing\n");
      goto handle_error;
   }

   extensions = dlsym(psc->driver, __DRI_DRIVER_EXTENSIONS);
   if (extensions == NULL) {
      ErrorMessageF("driver exports no extensions (%s)\n", dlerror());
      goto handle_error;
   }

   for (i = 0; extensions[i]; i++) {
      if (strcmp(extensions[i]->name, __DRI_CORE) == 0)
	 psc->core = (__DRIcoreExtension *) extensions[i];
      if (strcmp(extensions[i]->name, __DRI_DRI2) == 0)
	 psc->dri2 = (__DRIdri2Extension *) extensions[i];
   }

   if (psc->core == NULL || psc->dri2 == NULL) {
      ErrorMessageF("core dri or dri2 extension not found\n");
      goto handle_error;
   }

d1210 2
a1211 3
   
   /* If the server does not support the protocol for
    * DRI2GetBuffersWithFormat, don't supply that interface to the driver.
d1213 42
a1254 5
   psc->driScreen =
      psc->dri2->createNewScreen(screen, psc->fd,
				 (const __DRIextension **)
				 &pdp->loader_extensions[0],
				 &driver_configs, psc);
d1287 1
d1307 3
a1309 1
   psc->show_fps = tmp && strcmp(tmp, "1") == 0;
@


1.5
log
@Merge Mesa 9.2.0
@
text
@d263 4
a266 4
   uint32_t minor_ver = 1;
   uint32_t major_ver = 2;
   uint32_t renderType = GLX_RGBA_TYPE;
   uint32_t flags = 0;
d268 1
a268 1
   int reset = __DRI_CTX_RESET_NO_NOTIFICATION;
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d37 3
a39 1
#include <X11/extensions/Xdamage.h>
d49 1
d92 1
d97 2
d117 3
d124 16
d148 1
a148 5
   if (context->xid)
      glx_send_destroy_context(psc->base.dpy, context->xid);

   if (context->extensions)
      XFree((char *) context->extensions);
d152 1
a152 1
   Xfree(pcp);
d208 4
d213 7
d224 1
a224 1
   pcp = Xmalloc(sizeof *pcp);
a227 1
   memset(pcp, 0, sizeof *pcp);
d229 1
a229 1
      Xfree(pcp);
d233 2
d240 1
a240 1
      Xfree(pcp);
d249 104
d374 1
a374 1
   Xfree(pdraw);
d388 1
a388 1
   pdraw = Xmalloc(sizeof(*pdraw));
a391 1
   memset(pdraw, 0, sizeof *pdraw);
d427 1
a427 1
      Xfree(pdraw);
d434 1
a434 1
      Xfree(pdraw);
a437 2

#ifdef X_DRI2SwapInterval
d442 2
a443 3
   if (pdp->swapAvailable)
      DRI2SwapInterval(psc->base.dpy, xDrawable, pdraw->swap_interval);
#endif
a447 2
#ifdef X_DRI2GetMSC

d452 14
a465 2
   CARD64 dri2_ust, dri2_msc, dri2_sbc;
   int ret;
d467 1
a467 7
   ret = DRI2GetMSC(psc->dpy, pdraw->xDrawable,
		    &dri2_ust, &dri2_msc, &dri2_sbc);
   *ust = dri2_ust;
   *msc = dri2_msc;
   *sbc = dri2_sbc;

   return ret;
a469 5
#endif


#ifdef X_DRI2WaitMSC

d474 24
a497 2
   CARD64 dri2_ust, dri2_msc, dri2_sbc;
   int ret;
d499 1
a499 7
   ret = DRI2WaitMSC(pdraw->psc->dpy, pdraw->xDrawable, target_msc, divisor,
		     remainder, &dri2_ust, &dri2_msc, &dri2_sbc);
   *ust = dri2_ust;
   *msc = dri2_msc;
   *sbc = dri2_sbc;

   return ret;
d506 13
a518 2
   CARD64 dri2_ust, dri2_msc, dri2_sbc;
   int ret;
d520 13
a532 5
   ret = DRI2WaitSBC(pdraw->psc->dpy, pdraw->xDrawable,
		     target_sbc, &dri2_ust, &dri2_msc, &dri2_sbc);
   *ust = dri2_ust;
   *msc = dri2_msc;
   *sbc = dri2_sbc;
d534 20
a553 1
   return ret;
d556 25
a580 1
#endif /* X_DRI2WaitMSC */
d583 3
a585 1
dri2CopySubBuffer(__GLXDRIdrawable *pdraw, int x, int y, int width, int height)
d591 2
d603 4
a606 4
#ifdef __DRI2_FLUSH
   if (psc->f)
      (*psc->f->flush) (priv->driDrawable);
#endif
d623 9
a642 1
#ifdef __DRI2_FLUSH
a644 1
#endif
d676 4
d683 3
d687 2
d695 7
a701 3
   struct glx_display *priv = __glXInitialize(pdraw->base.psc->dpy);
   struct dri2_display *pdp = (struct dri2_display *)priv->dri2Display;
   struct glx_context *gc = __glXGetCurrentContext();
d720 1
a720 1
   Xfree(psc);
d765 67
d834 1
a834 1
		int64_t remainder)
d841 1
a841 1
    CARD64 ret = 0;
d849 2
a850 1
       dri2CopySubBuffer(pdraw, 0, 0, priv->width, priv->height);
d852 8
a859 8
#ifdef X_DRI2SwapBuffers
#ifdef __DRI2_FLUSH
    if (psc->f) {
       struct glx_context *gc = __glXGetCurrentContext();

       if (gc) {
	  (*psc->f->flush)(priv->driDrawable);
       }
a860 1
#endif
d862 2
a863 3
       DRI2SwapBuffers(psc->base.dpy, pdraw->xDrawable,
		       target_msc, divisor, remainder, &ret);
#endif
d891 1
a891 1
   Xfree(buffers);
d916 1
a916 1
   Xfree(buffers);
a920 2
#ifdef X_DRI2SwapInterval

d924 1
d935 3
a937 1
      return GLX_BAD_VALUE;
d946 1
a946 1
   DRI2SwapInterval(priv->base.psc->dpy, priv->base.xDrawable, interval);
a959 2
#endif /* X_DRI2SwapInterval */

a973 1
#ifdef __DRI_USE_INVALIDATE
a976 1
#endif
a990 1
#if __DRI2_FLUSH_VERSION >= 3
a992 1
#endif
a1011 1
#if __DRI2_FLUSH_VERSION >= 3
a1014 1
#endif
d1070 2
a1071 1
dri2BindExtensions(struct dri2_screen *psc, const __DRIextension **extensions)
d1073 3
d1078 2
d1085 27
a1111 2
   /* FIXME: if DRI2 version supports it... */
   __glXEnableDirectExtension(&psc->base, "INTEL_swap_event");
d1126 11
d1141 2
a1142 1
   dri2_create_context
d1154 2
a1155 1
   char *driverName, *deviceName;
d1159 1
a1159 1
   psc = Xmalloc(sizeof *psc);
a1162 1
   memset(psc, 0, sizeof *psc);
d1166 1
a1166 1
      Xfree(psc);
d1173 2
a1174 1
      XFree(psc);
d1202 9
a1210 1
   psc->fd = open(deviceName, O_RDWR);
d1241 7
a1247 2
   extensions = psc->core->getExtensions(psc->driScreen);
   dri2BindExtensions(psc, extensions);
d1249 4
a1252 4
   psc->base.configs =
      driConvertConfigs(psc->core, psc->base.configs, driver_configs);
   psc->base.visuals =
      driConvertConfigs(psc->core, psc->base.visuals, driver_configs);
a1268 1
#ifdef X_DRI2GetMSC
a1269 2
#endif
#ifdef X_DRI2WaitMSC
a1271 2
#endif
#ifdef X_DRI2SwapInterval
a1273 2
#endif
#if defined(X_DRI2GetMSC) && defined(X_DRI2WaitMSC) && defined(X_DRI2SwapInterval)
a1274 1
#endif
d1282 5
a1286 2
   Xfree(driverName);
   Xfree(deviceName);
d1291 9
d1304 3
a1306 2
   Xfree(driverName);
   Xfree(deviceName);
d1308 1
a1308 1
   XFree(psc);
d1321 1
a1321 1
   Xfree(dpy);
d1351 1
a1351 1
   pdp = Xmalloc(sizeof *pdp);
d1356 1
a1356 1
      Xfree(pdp);
a1374 1
#ifdef __DRI_USE_INVALIDATE
d1376 1
a1376 1
#endif
d1381 1
a1381 1
      Xfree(pdp);
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d146 2
a174 3

   if (context == new)
      driReleaseDrawables(&pcp->base);
d459 6
d542 3
a544 8
#ifdef __DRI2_FLUSH
    if (psc->f)
    	(*psc->f->flush)(priv->driDrawable);
#endif

    /* Old servers don't send invalidate events */
    if (!pdp->invalidateAvailable)
       dri2InvalidateBuffers(dpyPriv->dpy, pdraw->xDrawable);
d549 9
a557 1
       return 0;
d559 1
d561 2
a562 3
#ifdef X_DRI2SwapBuffers
    DRI2SwapBuffers(psc->base.dpy, pdraw->xDrawable, target_msc, divisor,
		    remainder, &ret);
d564 5
d686 1
a686 1
   struct dri2_screen *psc = (struct dri2_screen *) pdraw->psc;
d689 5
d695 1
a695 1
   if (pdraw && psc->f)
d718 2
a719 1
      if (!pdp->invalidateAvailable && psc->f)
d741 21
d773 1
d827 6
a832 2
   if (!glx_screen_init(&psc->base, screen, priv))
       return NULL;
d836 1
d946 4
d952 1
a953 2

   /* FIXME: clean up here */
@


1.2
log
@Two patches cherry picked from mesa master just after 7.8 was branched
(but never made it into the 7.8 branch).

first:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:47:41 2010 -0700

    DRI2: add config query extension

    Add a new DRI2 configuration query extension.  Allows for DRI2
    client code to query for common DRI2 configuration options.

second:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:49:03 2010 -0700

    DRI2/GLX: check for vblank_mode in DRI2 GLX code

    Re-add support for the vblank_mode environment and configuration
    variable.  Useful for benchmarking and app control.

The final affect being that config and environment variables for
controlling swap mode work with dri2 now. which helps me a lot with
debugging.

ok matthieu@@.
@
text
@d60 1
a60 5
typedef struct __GLXDRIdisplayPrivateRec __GLXDRIdisplayPrivate;
typedef struct __GLXDRIcontextPrivateRec __GLXDRIcontextPrivate;
typedef struct __GLXDRIdrawablePrivateRec __GLXDRIdrawablePrivate;

struct __GLXDRIdisplayPrivateRec
d72 21
d95 1
a95 1
struct __GLXDRIcontextPrivateRec
d97 1
a97 1
   __GLXDRIcontext base;
a98 1
   __GLXscreenConfigs *psc;
d101 1
a101 1
struct __GLXDRIdrawablePrivateRec
d104 1
d113 1
a113 1
static void dri2WaitX(__GLXDRIdrawable * pdraw);
d116 1
a116 2
dri2DestroyContext(__GLXDRIcontext * context,
                   __GLXscreenConfigs * psc, Display * dpy)
d118 10
a127 2
   __GLXDRIcontextPrivate *pcp = (__GLXDRIcontextPrivate *) context;
   const __DRIcoreExtension *core = pcp->psc->core;
d129 1
a129 1
   (*core->destroyContext) (pcp->driContext);
d135 2
a136 2
dri2BindContext(__GLXDRIcontext * context,
                __GLXDRIdrawable * draw, __GLXDRIdrawable * read)
d138 14
a151 2
   __GLXDRIcontextPrivate *pcp = (__GLXDRIcontextPrivate *) context;
   const __DRIcoreExtension *core = pcp->psc->core;
d153 11
a163 2
   return (*core->bindContext) (pcp->driContext,
                                draw->driDrawable, read->driDrawable);
d167 1
a167 1
dri2UnbindContext(__GLXDRIcontext * context)
d169 2
a170 2
   __GLXDRIcontextPrivate *pcp = (__GLXDRIcontextPrivate *) context;
   const __DRIcoreExtension *core = pcp->psc->core;
d172 4
a175 1
   (*core->unbindContext) (pcp->driContext);
d178 4
a181 4
static __GLXDRIcontext *
dri2CreateContext(__GLXscreenConfigs * psc,
                  const __GLcontextModes * mode,
                  GLXContext gc, GLXContext shareList, int renderType)
d183 3
a185 2
   __GLXDRIcontextPrivate *pcp, *pcp_shared;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) mode;
d189 1
a189 1
      pcp_shared = (__GLXDRIcontextPrivate *) shareList->driContext;
d197 6
a202 1
   pcp->psc = psc;
d204 1
a204 1
      (*psc->dri2->createNewContext) (psc->__driScreen,
a205 1
   gc->__driContext = pcp->driContext;
d212 1
a212 3
   pcp->base.destroyContext = dri2DestroyContext;
   pcp->base.bindContext = dri2BindContext;
   pcp->base.unbindContext = dri2UnbindContext;
d218 1
a218 1
dri2DestroyDrawable(__GLXDRIdrawable * pdraw)
d220 17
a236 1
   const __DRIcoreExtension *core = pdraw->psc->core;
a237 2
   (*core->destroyDrawable) (pdraw->driDrawable);
   DRI2DestroyDrawable(pdraw->psc->dpy, pdraw->xDrawable);
d242 8
a249 8
dri2CreateDrawable(__GLXscreenConfigs * psc,
                   XID xDrawable,
                   GLXDrawable drawable, const __GLcontextModes * modes)
{
   __GLXDRIdrawablePrivate *pdraw;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) modes;
   __GLXdisplayPrivate *dpyPriv;
   __GLXDRIdisplayPrivate *pdp;
d256 1
d260 1
a260 1
   pdraw->base.psc = psc;
d266 2
a267 1
      psc->config->configQueryi(psc->__driScreen, "vblank_mode", &vblank_mode);
d281 1
a281 1
   DRI2CreateDrawable(psc->dpy, xDrawable);
d283 2
a284 2
   dpyPriv = __glXInitialize(psc->dpy);
   pdp = (__GLXDRIdisplayPrivate *)dpyPriv->dri2Display;;
d286 2
a287 2
   pdraw->base.driDrawable =
      (*psc->dri2->createNewDrawable) (psc->__driScreen,
d290 2
a291 2
   if (!pdraw->base.driDrawable) {
      DRI2DestroyDrawable(psc->dpy, xDrawable);
d296 8
d310 1
a310 1
      DRI2SwapInterval(psc->dpy, xDrawable, pdraw->swap_interval);
d319 1
a319 1
dri2DrawableGetMSC(__GLXscreenConfigs *psc, __GLXDRIdrawable *pdraw,
d322 10
a331 1
   return DRI2GetMSC(psc->dpy, pdraw->xDrawable, ust, msc, sbc);
d343 10
a352 2
   return DRI2WaitMSC(pdraw->psc->dpy, pdraw->xDrawable, target_msc, divisor,
		      remainder, ust, msc, sbc);
d359 10
a368 2
   return DRI2WaitSBC(pdraw->psc->dpy, pdraw->xDrawable, target_sbc, ust, msc,
		      sbc);
d376 2
a377 1
   __GLXDRIdrawablePrivate *priv = (__GLXDRIdrawablePrivate *) pdraw;
d391 2
a392 2
   if (pdraw->psc->f)
      (*pdraw->psc->f->flush) (pdraw->driDrawable);
d395 2
a396 3
   region = XFixesCreateRegion(pdraw->psc->dpy, &xrect, 1);
   /* should get a fence ID back from here at some point */
   DRI2CopyRegion(pdraw->psc->dpy, pdraw->xDrawable, region,
a397 1
   XFixesDestroyRegion(pdraw->psc->dpy, region);
d402 5
a406 1
   dri2WaitX(pdraw);
d410 1
a410 1
dri2WaitX(__GLXDRIdrawable *pdraw)
a411 1
   __GLXDRIdrawablePrivate *priv = (__GLXDRIdrawablePrivate *) pdraw;
d414 1
a414 4

   /* Check we have the right attachments */
   if (!priv->have_fake_front)
      return;
d422 2
a423 2
   if (pdraw->psc->f)
      (*pdraw->psc->f->flush) (pdraw->driDrawable);
d426 4
a429 4
   region = XFixesCreateRegion(pdraw->psc->dpy, &xrect, 1);
   DRI2CopyRegion(pdraw->psc->dpy, pdraw->xDrawable, region,
                  DRI2BufferFakeFrontLeft, DRI2BufferFrontLeft);
   XFixesDestroyRegion(pdraw->psc->dpy, region);
d433 1
a433 1
dri2WaitGL(__GLXDRIdrawable * pdraw)
d435 2
a436 3
   __GLXDRIdrawablePrivate *priv = (__GLXDRIdrawablePrivate *) pdraw;
   XRectangle xrect;
   XserverRegion region;
d438 1
a438 1
   if (!priv->have_fake_front)
d441 8
a448 4
   xrect.x = 0;
   xrect.y = 0;
   xrect.width = priv->width;
   xrect.height = priv->height;
d450 2
a451 4
#ifdef __DRI2_FLUSH
   if (pdraw->psc->f)
      (*pdraw->psc->f->flush) (pdraw->driDrawable);
#endif
d453 1
a453 4
   region = XFixesCreateRegion(pdraw->psc->dpy, &xrect, 1);
   DRI2CopyRegion(pdraw->psc->dpy, pdraw->xDrawable, region,
                  DRI2BufferFrontLeft, DRI2BufferFakeFrontLeft);
   XFixesDestroyRegion(pdraw->psc->dpy, region);
d459 4
a462 3
   __GLXDRIdrawablePrivate *pdraw = loaderPrivate;
   __GLXdisplayPrivate *priv = __glXInitialize(pdraw->base.psc->dpy);
   __GLXDRIdisplayPrivate *pdp = (__GLXDRIdisplayPrivate *)priv->dri2Display;
d466 1
a466 1
       dri2InvalidateBuffers(priv->dpy, pdraw->base.drawable);
d468 1
a468 1
   dri2WaitGL(loaderPrivate);
d473 1
a473 1
dri2DestroyScreen(__GLXscreenConfigs * psc)
d475 2
d478 2
a479 1
   (*psc->core->destroyScreen) (psc->__driScreen);
d481 1
a481 1
   psc->__driScreen = NULL;
d491 1
a491 1
process_buffers(__GLXDRIdrawablePrivate * pdraw, DRI2Buffer * buffers,
d516 10
d530 6
a535 5
    __GLXDRIdrawablePrivate *priv = (__GLXDRIdrawablePrivate *) pdraw;
    __GLXdisplayPrivate *dpyPriv = __glXInitialize(priv->base.psc->dpy);
    __GLXDRIdisplayPrivate *pdp =
	(__GLXDRIdisplayPrivate *)dpyPriv->dri2Display;
    int64_t ret;
d538 2
a539 2
    if (pdraw->psc->f)
    	(*pdraw->psc->f->flush)(pdraw->driDrawable);
d544 1
a544 1
       dri2InvalidateBuffers(dpyPriv->dpy, pdraw->drawable);
d553 1
a553 1
    DRI2SwapBuffers(pdraw->psc->dpy, pdraw->xDrawable, target_msc, divisor,
d566 1
a566 1
   __GLXDRIdrawablePrivate *pdraw = loaderPrivate;
d589 1
a589 1
   __GLXDRIdrawablePrivate *pdraw = loaderPrivate;
d610 1
a610 1
static void
d613 1
a613 2
   __GLXscreenConfigs *psc = pdraw->psc;
   __GLXDRIdrawablePrivate *priv =  (__GLXDRIdrawablePrivate *) pdraw;
d615 1
d618 2
a619 1
      psc->config->configQueryi(psc->__driScreen, "vblank_mode", &vblank_mode);
d623 1
a623 1
      return;
d626 1
a626 1
	 return;
d632 1
a632 1
   DRI2SwapInterval(priv->base.psc->dpy, pdraw->xDrawable, interval);
d634 2
d638 1
a638 1
static unsigned int
d641 1
a641 1
   __GLXDRIdrawablePrivate *priv =  (__GLXDRIdrawablePrivate *) pdraw;
d662 3
a664 10
static const __DRIextension *loader_extensions[] = {
   &dri2LoaderExtension.base,
   &systemTimeExtension.base,
   NULL
};

static const __DRIextension *loader_extensions_old[] = {
   &dri2LoaderExtension_old.base,
   &systemTimeExtension.base,
   NULL
d666 1
d671 4
a674 1
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable, NULL);
d677 2
a678 2
   if (pdraw && pdraw->psc->f)
       pdraw->psc->f->invalidate(pdraw->driDrawable);
d682 88
a769 3
static __GLXDRIscreen *
dri2CreateScreen(__GLXscreenConfigs * psc, int screen,
                 __GLXdisplayPrivate * priv)
d773 1
a773 1
   const __GLXDRIdisplayPrivate *const pdp = (__GLXDRIdisplayPrivate *)
d775 1
d781 2
a782 2
   psp = Xmalloc(sizeof *psp);
   if (psp == NULL)
d785 5
a789 1
   if (!DRI2Connect(psc->dpy, RootWindow(psc->dpy, screen),
d791 1
a791 1
      XFree(psp);
d830 1
a830 1
   if (!DRI2Authenticate(psc->dpy, RootWindow(psc->dpy, screen), magic)) {
d835 1
d839 4
a842 4
   psc->__driScreen =
      psc->dri2->createNewScreen(screen, psc->fd, ((pdp->driMinor < 1)
						   ? loader_extensions_old
						   : loader_extensions),
d845 1
a845 1
   if (psc->__driScreen == NULL) {
d850 2
a851 2
   driBindCommonExtensions(psc);
   dri2BindExtensions(psc);
d853 4
a856 2
   psc->configs = driConvertConfigs(psc->core, psc->configs, driver_configs);
   psc->visuals = driConvertConfigs(psc->core, psc->visuals, driver_configs);
d860 3
a863 1
   psp->createContext = dri2CreateContext;
a865 2
   psp->waitGL = dri2WaitGL;
   psp->waitX = dri2WaitX;
d885 1
a885 1
      __glXEnableDirectExtension(psc, "GLX_OML_sync_control");
d892 1
a892 1
   __glXEnableDirectExtension(psc, "GLX_MESA_copy_sub_buffer");
d897 1
a897 1
   return psp;
d902 1
a902 1
   XFree(psp);
d914 3
d920 13
d941 2
a942 2
   __GLXDRIdisplayPrivate *pdp;
   int eventBase, errorBase;
d962 19
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d50 6
a55 1
#include "../../mesa/drivers/dri/common/dri_util.h"
d185 1
d196 1
a196 1
   pdraw->swap_interval = 1;
d199 15
d501 1
d503 15
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d50 1
a50 6

/* From xmlpool/options.h, user exposed so should be stable */
#define DRI_CONF_VBLANK_NEVER 0
#define DRI_CONF_VBLANK_DEF_INTERVAL_0 1
#define DRI_CONF_VBLANK_DEF_INTERVAL_1 2
#define DRI_CONF_VBLANK_ALWAYS_SYNC 3
d55 5
a59 1
struct dri2_display
a70 21

   __glxHashTable *dri2Hash;

   const __DRIextension *loader_extensions[4];
};

struct dri2_screen {
   struct glx_screen base;

   __DRIscreen *driScreen;
   __GLXDRIscreen vtable;
   const __DRIdri2Extension *dri2;
   const __DRIcoreExtension *core;

   const __DRI2flushExtension *f;
   const __DRI2configQueryExtension *config;
   const __DRItexBufferExtension *texBuffer;
   const __DRIconfig **driver_configs;

   void *driver;
   int fd;
d73 1
a73 1
struct dri2_context
d75 1
a75 1
   struct glx_context base;
d77 1
d80 1
a80 1
struct dri2_drawable
a82 1
   __DRIdrawable *driDrawable;
d91 1
a91 1
static const struct glx_context_vtable dri2_context_vtable;
d94 2
a95 1
dri2_destroy_context(struct glx_context *context)
d97 2
a98 7
   struct dri2_context *pcp = (struct dri2_context *) context;
   struct dri2_screen *psc = (struct dri2_screen *) context->psc;

   driReleaseDrawables(&pcp->base);

   if (context->xid)
      glx_send_destroy_context(psc->base.dpy, context->xid);
d100 1
a100 4
   if (context->extensions)
      XFree((char *) context->extensions);

   (*psc->core->destroyContext) (pcp->driContext);
d106 2
a107 2
dri2_bind_context(struct glx_context *context, struct glx_context *old,
		  GLXDrawable draw, GLXDrawable read)
d109 2
a110 10
   struct dri2_context *pcp = (struct dri2_context *) context;
   struct dri2_screen *psc = (struct dri2_screen *) pcp->base.psc;
   struct dri2_drawable *pdraw, *pread;
   struct dri2_display *pdp;

   pdraw = (struct dri2_drawable *) driFetchDrawable(context, draw);
   pread = (struct dri2_drawable *) driFetchDrawable(context, read);

   if (pdraw == NULL || pread == NULL)
      return GLXBadDrawable;
d112 2
a113 15
   if (!(*psc->core->bindContext) (pcp->driContext,
				   pdraw->driDrawable, pread->driDrawable))
      return GLXBadContext;

   /* If the server doesn't send invalidate events, we may miss a
    * resize before the rendering starts.  Invalidate the buffers now
    * so the driver will recheck before rendering starts. */
   pdp = (struct dri2_display *) psc->base.display;
   if (!pdp->invalidateAvailable) {
      dri2InvalidateBuffers(psc->base.dpy, pdraw->base.xDrawable);
      if (pread != pdraw)
	 dri2InvalidateBuffers(psc->base.dpy, pread->base.xDrawable);
   }

   return Success;
d117 1
a117 1
dri2_unbind_context(struct glx_context *context, struct glx_context *new)
d119 2
a120 4
   struct dri2_context *pcp = (struct dri2_context *) context;
   struct dri2_screen *psc = (struct dri2_screen *) pcp->base.psc;

   (*psc->core->unbindContext) (pcp->driContext);
d122 1
a122 2
   if (context == new)
      driReleaseDrawables(&pcp->base);
d125 4
a128 4
static struct glx_context *
dri2_create_context(struct glx_screen *base,
		    struct glx_config *config_base,
		    struct glx_context *shareList, int renderType)
d130 2
a131 3
   struct dri2_context *pcp, *pcp_shared;
   struct dri2_screen *psc = (struct dri2_screen *) base;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
d135 1
a135 1
      pcp_shared = (struct dri2_context *) shareList;
d143 1
a143 6
   memset(pcp, 0, sizeof *pcp);
   if (!glx_context_init(&pcp->base, &psc->base, &config->base)) {
      Xfree(pcp);
      return NULL;
   }

d145 1
a145 1
      (*psc->dri2->createNewContext) (psc->driScreen,
d147 1
d154 3
a156 1
   pcp->base.vtable = &dri2_context_vtable;
d162 1
a162 1
dri2DestroyDrawable(__GLXDRIdrawable *base)
d164 1
a164 17
   struct dri2_screen *psc = (struct dri2_screen *) base->psc;
   struct dri2_drawable *pdraw = (struct dri2_drawable *) base;
   struct glx_display *dpyPriv = psc->base.display;
   struct dri2_display *pdp = (struct dri2_display *)dpyPriv->dri2Display;

   __glxHashDelete(pdp->dri2Hash, pdraw->base.xDrawable);
   (*psc->core->destroyDrawable) (pdraw->driDrawable);

   /* If it's a GLX 1.3 drawables, we can destroy the DRI2 drawable
    * now, as the application explicitly asked to destroy the GLX
    * drawable.  Otherwise, for legacy drawables, we let the DRI2
    * drawable linger on the server, since there's no good way of
    * knowing when the application is done with it.  The server will
    * destroy the DRI2 drawable when it destroys the X drawable or the
    * client exits anyway. */
   if (pdraw->base.xDrawable != pdraw->base.drawable)
      DRI2DestroyDrawable(psc->base.dpy, pdraw->base.xDrawable);
d166 2
d172 8
a179 9
dri2CreateDrawable(struct glx_screen *base, XID xDrawable,
		   GLXDrawable drawable, struct glx_config *config_base)
{
   struct dri2_drawable *pdraw;
   struct dri2_screen *psc = (struct dri2_screen *) base;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
   struct glx_display *dpyPriv;
   struct dri2_display *pdp;
   GLint vblank_mode = DRI_CONF_VBLANK_DEF_INTERVAL_1;
a184 1
   memset(pdraw, 0, sizeof *pdraw);
d188 1
a188 1
   pdraw->base.psc = &psc->base;
d190 1
a190 1
   pdraw->swap_interval = 1; /* default may be overridden below */
d193 1
a193 17
   if (psc->config)
      psc->config->configQueryi(psc->driScreen,
				"vblank_mode", &vblank_mode);

   switch (vblank_mode) {
   case DRI_CONF_VBLANK_NEVER:
   case DRI_CONF_VBLANK_DEF_INTERVAL_0:
      pdraw->swap_interval = 0;
      break;
   case DRI_CONF_VBLANK_DEF_INTERVAL_1:
   case DRI_CONF_VBLANK_ALWAYS_SYNC:
   default:
      pdraw->swap_interval = 1;
      break;
   }

   DRI2CreateDrawable(psc->base.dpy, xDrawable);
d195 2
a196 2
   dpyPriv = __glXInitialize(psc->base.dpy);
   pdp = (struct dri2_display *)dpyPriv->dri2Display;;
d198 2
a199 2
   pdraw->driDrawable =
      (*psc->dri2->createNewDrawable) (psc->driScreen,
d202 2
a203 2
   if (!pdraw->driDrawable) {
      DRI2DestroyDrawable(psc->base.dpy, xDrawable);
a207 8
   if (__glxHashInsert(pdp->dri2Hash, xDrawable, pdraw)) {
      (*psc->core->destroyDrawable) (pdraw->driDrawable);
      DRI2DestroyDrawable(psc->base.dpy, xDrawable);
      Xfree(pdraw);
      return None;
   }


d214 1
a214 1
      DRI2SwapInterval(psc->base.dpy, xDrawable, pdraw->swap_interval);
d223 1
a223 1
dri2DrawableGetMSC(struct glx_screen *psc, __GLXDRIdrawable *pdraw,
d226 1
a226 10
   CARD64 dri2_ust, dri2_msc, dri2_sbc;
   int ret;

   ret = DRI2GetMSC(psc->dpy, pdraw->xDrawable,
		    &dri2_ust, &dri2_msc, &dri2_sbc);
   *ust = dri2_ust;
   *msc = dri2_msc;
   *sbc = dri2_sbc;

   return ret;
d238 2
a239 10
   CARD64 dri2_ust, dri2_msc, dri2_sbc;
   int ret;

   ret = DRI2WaitMSC(pdraw->psc->dpy, pdraw->xDrawable, target_msc, divisor,
		     remainder, &dri2_ust, &dri2_msc, &dri2_sbc);
   *ust = dri2_ust;
   *msc = dri2_msc;
   *sbc = dri2_sbc;

   return ret;
d246 2
a247 10
   CARD64 dri2_ust, dri2_msc, dri2_sbc;
   int ret;

   ret = DRI2WaitSBC(pdraw->psc->dpy, pdraw->xDrawable,
		     target_sbc, &dri2_ust, &dri2_msc, &dri2_sbc);
   *ust = dri2_ust;
   *msc = dri2_msc;
   *sbc = dri2_sbc;

   return ret;
d255 1
a255 2
   struct dri2_drawable *priv = (struct dri2_drawable *) pdraw;
   struct dri2_screen *psc = (struct dri2_screen *) pdraw->psc;
d269 2
a270 2
   if (psc->f)
      (*psc->f->flush) (priv->driDrawable);
d273 3
a275 2
   region = XFixesCreateRegion(psc->base.dpy, &xrect, 1);
   DRI2CopyRegion(psc->base.dpy, pdraw->xDrawable, region,
d277 1
d282 1
a282 5
   if (priv->have_fake_front)
      DRI2CopyRegion(psc->base.dpy, pdraw->xDrawable, region,
		     DRI2BufferFakeFrontLeft, DRI2BufferFrontLeft);

   XFixesDestroyRegion(psc->base.dpy, region);
d286 1
a286 1
dri2_copy_drawable(struct dri2_drawable *priv, int dest, int src)
d288 1
d291 4
a294 1
   struct dri2_screen *psc = (struct dri2_screen *) priv->base.psc;
d302 2
a303 2
   if (psc->f)
      (*psc->f->flush) (priv->driDrawable);
d306 4
a309 4
   region = XFixesCreateRegion(psc->base.dpy, &xrect, 1);
   DRI2CopyRegion(psc->base.dpy, priv->base.xDrawable, region, dest, src);
   XFixesDestroyRegion(psc->base.dpy, region);

d313 1
a313 1
dri2_wait_x(struct glx_context *gc)
d315 3
a317 2
   struct dri2_drawable *priv = (struct dri2_drawable *)
      GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
d319 1
a319 1
   if (priv == NULL || !priv->have_fake_front)
d322 4
a325 2
   dri2_copy_drawable(priv, DRI2BufferFakeFrontLeft, DRI2BufferFrontLeft);
}
d327 4
a330 8
static void
dri2_wait_gl(struct glx_context *gc)
{
   struct dri2_drawable *priv = (struct dri2_drawable *)
      GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);

   if (priv == NULL || !priv->have_fake_front)
      return;
d332 4
a335 1
   dri2_copy_drawable(priv, DRI2BufferFrontLeft, DRI2BufferFakeFrontLeft);
d341 3
a343 4
   struct dri2_drawable *pdraw = loaderPrivate;
   struct glx_display *priv = __glXInitialize(pdraw->base.psc->dpy);
   struct dri2_display *pdp = (struct dri2_display *)priv->dri2Display;
   struct glx_context *gc = __glXGetCurrentContext();
d347 1
a347 1
       dri2InvalidateBuffers(priv->dpy, pdraw->base.xDrawable);
d349 1
a349 1
   dri2_wait_gl(gc);
d354 1
a354 1
dri2DestroyScreen(struct glx_screen *base)
a355 2
   struct dri2_screen *psc = (struct dri2_screen *) base;

d357 1
a357 2
   (*psc->core->destroyScreen) (psc->driScreen);
   driDestroyConfigs(psc->driver_configs);
d359 1
a359 1
   Xfree(psc);
d369 1
a369 1
process_buffers(struct dri2_drawable * pdraw, DRI2Buffer * buffers,
a393 10
unsigned dri2GetSwapEventType(Display* dpy, XID drawable)
{
      struct glx_display *glx_dpy = __glXInitialize(dpy);
      __GLXDRIdrawable *pdraw;
      pdraw = dri2GetGlxDrawableFromXDrawableId(dpy, drawable);
      if (!pdraw || !(pdraw->eventMask & GLX_BUFFER_SWAP_COMPLETE_INTEL_MASK))
         return 0;
      return glx_dpy->codes->first_event + GLX_BufferSwapComplete;
}

d398 5
a402 6
    struct dri2_drawable *priv = (struct dri2_drawable *) pdraw;
    struct glx_display *dpyPriv = __glXInitialize(priv->base.psc->dpy);
    struct dri2_screen *psc = (struct dri2_screen *) priv->base.psc;
    struct dri2_display *pdp =
	(struct dri2_display *)dpyPriv->dri2Display;
    CARD64 ret = 0;
d405 2
a406 2
    if (psc->f)
    	(*psc->f->flush)(priv->driDrawable);
d411 1
a411 1
       dri2InvalidateBuffers(dpyPriv->dpy, pdraw->xDrawable);
d420 1
a420 1
    DRI2SwapBuffers(psc->base.dpy, pdraw->xDrawable, target_msc, divisor,
d433 1
a433 1
   struct dri2_drawable *pdraw = loaderPrivate;
d456 1
a456 1
   struct dri2_drawable *pdraw = loaderPrivate;
d477 1
a477 1
static int
d480 1
a480 18
   struct dri2_drawable *priv =  (struct dri2_drawable *) pdraw;
   GLint vblank_mode = DRI_CONF_VBLANK_DEF_INTERVAL_1;
   struct dri2_screen *psc = (struct dri2_screen *) priv->base.psc;

   if (psc->config)
      psc->config->configQueryi(psc->driScreen,
				"vblank_mode", &vblank_mode);

   switch (vblank_mode) {
   case DRI_CONF_VBLANK_NEVER:
      return GLX_BAD_VALUE;
   case DRI_CONF_VBLANK_ALWAYS_SYNC:
      if (interval <= 0)
	 return GLX_BAD_VALUE;
      break;
   default:
      break;
   }
d482 1
a482 1
   DRI2SwapInterval(priv->base.psc->dpy, priv->base.xDrawable, interval);
a483 2

   return 0;
d486 1
a486 1
static int
d489 1
a489 1
   struct dri2_drawable *priv =  (struct dri2_drawable *) pdraw;
d510 10
a519 3
#ifdef __DRI_USE_INVALIDATE
static const __DRIuseInvalidateExtension dri2UseInvalidate = {
   { __DRI_USE_INVALIDATE, __DRI_USE_INVALIDATE_VERSION }
a520 1
#endif
d525 1
a525 27
   __GLXDRIdrawable *pdraw =
      dri2GetGlxDrawableFromXDrawableId(dpy, drawable);
   struct dri2_screen *psc = (struct dri2_screen *) pdraw->psc;
   struct dri2_drawable *pdp = (struct dri2_drawable *) pdraw;

#if __DRI2_FLUSH_VERSION >= 3
   if (pdraw && psc->f)
       psc->f->invalidate(pdp->driDrawable);
#endif
}

static void
dri2_bind_tex_image(Display * dpy,
		    GLXDrawable drawable,
		    int buffer, const int *attrib_list)
{
   struct glx_context *gc = __glXGetCurrentContext();
   struct dri2_context *pcp = (struct dri2_context *) gc;
   __GLXDRIdrawable *base = GetGLXDRIDrawable(dpy, drawable);
   struct glx_display *dpyPriv = __glXInitialize(dpy);
   struct dri2_drawable *pdraw = (struct dri2_drawable *) base;
   struct dri2_display *pdp =
      (struct dri2_display *) dpyPriv->dri2Display;
   struct dri2_screen *psc;

   if (pdraw != NULL) {
      psc = (struct dri2_screen *) base->psc;
d528 2
a529 2
      if (!pdp->invalidateAvailable && psc->f)
	 psc->f->invalidate(pdraw->driDrawable);
a530 19

      if (psc->texBuffer->base.version >= 2 &&
	  psc->texBuffer->setTexBuffer2 != NULL) {
	 (*psc->texBuffer->setTexBuffer2) (pcp->driContext,
					   pdraw->base.textureTarget,
					   pdraw->base.textureFormat,
					   pdraw->driDrawable);
      }
      else {
	 (*psc->texBuffer->setTexBuffer) (pcp->driContext,
					  pdraw->base.textureTarget,
					  pdraw->driDrawable);
      }
   }
}

static void
dri2_release_tex_image(Display * dpy, GLXDrawable drawable, int buffer)
{
d533 3
a535 46
static const struct glx_context_vtable dri2_context_vtable = {
   dri2_destroy_context,
   dri2_bind_context,
   dri2_unbind_context,
   dri2_wait_gl,
   dri2_wait_x,
   DRI_glXUseXFont,
   dri2_bind_tex_image,
   dri2_release_tex_image,
};

static void
dri2BindExtensions(struct dri2_screen *psc, const __DRIextension **extensions)
{
   int i;

   __glXEnableDirectExtension(&psc->base, "GLX_SGI_video_sync");
   __glXEnableDirectExtension(&psc->base, "GLX_SGI_swap_control");
   __glXEnableDirectExtension(&psc->base, "GLX_MESA_swap_control");
   __glXEnableDirectExtension(&psc->base, "GLX_SGI_make_current_read");

   /* FIXME: if DRI2 version supports it... */
   __glXEnableDirectExtension(&psc->base, "INTEL_swap_event");

   for (i = 0; extensions[i]; i++) {
      if ((strcmp(extensions[i]->name, __DRI_TEX_BUFFER) == 0)) {
	 psc->texBuffer = (__DRItexBufferExtension *) extensions[i];
	 __glXEnableDirectExtension(&psc->base, "GLX_EXT_texture_from_pixmap");
      }

      if ((strcmp(extensions[i]->name, __DRI2_FLUSH) == 0)) {
	 psc->f = (__DRI2flushExtension *) extensions[i];
	 /* internal driver extension, no GL extension exposed */
      }

      if ((strcmp(extensions[i]->name, __DRI2_CONFIG_QUERY) == 0))
	 psc->config = (__DRI2configQueryExtension *) extensions[i];
   }
}

static const struct glx_screen_vtable dri2_screen_vtable = {
   dri2_create_context
};

static struct glx_screen *
dri2CreateScreen(int screen, struct glx_display * priv)
d539 1
a539 1
   const struct dri2_display *const pdp = (struct dri2_display *)
a540 1
   struct dri2_screen *psc;
d546 2
a547 2
   psc = Xmalloc(sizeof *psc);
   if (psc == NULL)
d550 1
a550 5
   memset(psc, 0, sizeof *psc);
   if (!glx_screen_init(&psc->base, screen, priv))
       return NULL;

   if (!DRI2Connect(priv->dpy, RootWindow(priv->dpy, screen),
d552 1
a552 1
      XFree(psc);
d591 1
a591 1
   if (!DRI2Authenticate(priv->dpy, RootWindow(priv->dpy, screen), magic)) {
a595 1
   
d599 4
a602 4
   psc->driScreen =
      psc->dri2->createNewScreen(screen, psc->fd,
				 (const __DRIextension **)
				 &pdp->loader_extensions[0],
d605 1
a605 1
   if (psc->driScreen == NULL) {
d610 2
a611 2
   extensions = psc->core->getExtensions(psc->driScreen);
   dri2BindExtensions(psc, extensions);
d613 2
a614 4
   psc->base.configs =
      driConvertConfigs(psc->core, psc->base.configs, driver_configs);
   psc->base.visuals =
      driConvertConfigs(psc->core, psc->base.visuals, driver_configs);
a617 3
   psc->base.vtable = &dri2_screen_vtable;
   psp = &psc->vtable;
   psc->base.driScreen = psp;
d619 1
d622 2
d643 1
a643 1
      __glXEnableDirectExtension(&psc->base, "GLX_OML_sync_control");
d650 1
a650 1
   __glXEnableDirectExtension(&psc->base, "GLX_MESA_copy_sub_buffer");
d655 1
a655 1
   return &psc->base;
d660 1
a660 1
   XFree(psc);
a671 3
   struct dri2_display *pdp = (struct dri2_display *) dpy;

   __glxHashDestroy(pdp->dri2Hash);
a674 13
_X_HIDDEN __GLXDRIdrawable *
dri2GetGlxDrawableFromXDrawableId(Display *dpy, XID id)
{
   struct glx_display *d = __glXInitialize(dpy);
   struct dri2_display *pdp = (struct dri2_display *) d->dri2Display;
   __GLXDRIdrawable *pdraw;

   if (__glxHashLookup(pdp->dri2Hash, id, (void *) &pdraw) == 0)
      return pdraw;

   return NULL;
}

d683 2
a684 2
   struct dri2_display *pdp;
   int eventBase, errorBase, i;
a703 19

   i = 0;
   if (pdp->driMinor < 1)
      pdp->loader_extensions[i++] = &dri2LoaderExtension_old.base;
   else
      pdp->loader_extensions[i++] = &dri2LoaderExtension.base;
   
   pdp->loader_extensions[i++] = &systemTimeExtension.base;

#ifdef __DRI_USE_INVALIDATE
   pdp->loader_extensions[i++] = &dri2UseInvalidate.base;
#endif
   pdp->loader_extensions[i++] = NULL;

   pdp->dri2Hash = __glxHashCreate();
   if (pdp->dri2Hash == NULL) {
      Xfree(pdp);
      return NULL;
   }
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d37 1
a37 3
#include <X11/Xlib-xcb.h>
#include <xcb/xcb.h>
#include <xcb/dri2.h>
a46 1
#include <sys/time.h>
a88 1
   const __DRI2throttleExtension *throttle;
a92 2

   Bool show_fps;
a110 3

   uint64_t previous_time;
   unsigned frames;
a114 16
/* For XCB's handling of ust/msc/sbc counters, we have to hand it the high and
 * low halves separately.  This helps you split them.
 */
static void
split_counter(uint64_t counter, uint32_t *hi, uint32_t *lo)
{
   *hi = (counter >> 32);
   *lo = counter & 0xffffffff;
}

static uint64_t
merge_counter(uint32_t hi, uint32_t lo)
{
   return ((uint64_t)hi << 32) | lo;
}

d123 5
a127 1
   free((char *) context->extensions);
d131 1
a131 1
   free(pcp);
a145 2
   driReleaseDrawables(&pcp->base);

d173 3
a187 4
   /* Check the renderType value */
   if (!validate_renderType_against_config(config_base, renderType))
       return NULL;

a188 7
      /* If the shareList context is not a DRI2 context, we cannot possibly
       * create a DRI2 context that shares it.
       */
      if (shareList->vtable->destroy != dri2_destroy_context) {
	 return NULL;
      }

d193 1
a193 1
   pcp = calloc(1, sizeof *pcp);
d197 1
d199 1
a199 1
      free(pcp);
a202 2
   pcp->base.renderType = renderType;

d208 1
a208 1
      free(pcp);
a216 104
static struct glx_context *
dri2_create_context_attribs(struct glx_screen *base,
			    struct glx_config *config_base,
			    struct glx_context *shareList,
			    unsigned num_attribs,
			    const uint32_t *attribs,
			    unsigned *error)
{
   struct dri2_context *pcp = NULL;
   struct dri2_context *pcp_shared = NULL;
   struct dri2_screen *psc = (struct dri2_screen *) base;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
   __DRIcontext *shared = NULL;

   uint32_t minor_ver = 1;
   uint32_t major_ver = 2;
   uint32_t renderType = GLX_RGBA_TYPE;
   uint32_t flags = 0;
   unsigned api;
   int reset = __DRI_CTX_RESET_NO_NOTIFICATION;
   uint32_t ctx_attribs[2 * 5];
   unsigned num_ctx_attribs = 0;

   if (psc->dri2->base.version < 3) {
      *error = __DRI_CTX_ERROR_NO_MEMORY;
      goto error_exit;
   }

   /* Remap the GLX tokens to DRI2 tokens.
    */
   if (!dri2_convert_glx_attribs(num_attribs, attribs,
                                 &major_ver, &minor_ver, &renderType, &flags,
                                 &api, &reset, error))
      goto error_exit;

   /* Check the renderType value */
   if (!validate_renderType_against_config(config_base, renderType))
       goto error_exit;

   if (shareList) {
      pcp_shared = (struct dri2_context *) shareList;
      shared = pcp_shared->driContext;
   }

   pcp = calloc(1, sizeof *pcp);
   if (pcp == NULL) {
      *error = __DRI_CTX_ERROR_NO_MEMORY;
      goto error_exit;
   }

   if (!glx_context_init(&pcp->base, &psc->base, &config->base))
      goto error_exit;

   ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_MAJOR_VERSION;
   ctx_attribs[num_ctx_attribs++] = major_ver;
   ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_MINOR_VERSION;
   ctx_attribs[num_ctx_attribs++] = minor_ver;

   /* Only send a value when the non-default value is requested.  By doing
    * this we don't have to check the driver's DRI2 version before sending the
    * default value.
    */
   if (reset != __DRI_CTX_RESET_NO_NOTIFICATION) {
      ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_RESET_STRATEGY;
      ctx_attribs[num_ctx_attribs++] = reset;
   }

   if (flags != 0) {
      ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_FLAGS;

      /* The current __DRI_CTX_FLAG_* values are identical to the
       * GLX_CONTEXT_*_BIT values.
       */
      ctx_attribs[num_ctx_attribs++] = flags;
   }

   /* The renderType is retrieved from attribs, or set to default
    *  of GLX_RGBA_TYPE.
    */
   pcp->base.renderType = renderType;

   pcp->driContext =
      (*psc->dri2->createContextAttribs) (psc->driScreen,
					  api,
					  config->driConfig,
					  shared,
					  num_ctx_attribs / 2,
					  ctx_attribs,
					  error,
					  pcp);

   if (pcp->driContext == NULL)
      goto error_exit;

   pcp->base.vtable = &dri2_context_vtable;

   return &pcp->base;

error_exit:
   free(pcp);

   return NULL;
}

d238 1
a238 1
   free(pdraw);
d252 1
a252 1
   pdraw = calloc(1, sizeof(*pdraw));
d256 1
d292 1
a292 1
      free(pdraw);
d299 1
a299 1
      free(pdraw);
d303 2
d309 3
a311 2
   if (psc->vtable.setSwapInterval)
      psc->vtable.setSwapInterval(&pdraw->base, pdraw->swap_interval);
d316 2
d322 2
a323 14
   xcb_connection_t *c = XGetXCBConnection(pdraw->psc->dpy);
   xcb_dri2_get_msc_cookie_t get_msc_cookie;
   xcb_dri2_get_msc_reply_t *get_msc_reply;

   get_msc_cookie = xcb_dri2_get_msc_unchecked(c, pdraw->xDrawable);
   get_msc_reply = xcb_dri2_get_msc_reply(c, get_msc_cookie, NULL);

   if (!get_msc_reply)
      return 0;

   *ust = merge_counter(get_msc_reply->ust_hi, get_msc_reply->ust_lo);
   *msc = merge_counter(get_msc_reply->msc_hi, get_msc_reply->msc_lo);
   *sbc = merge_counter(get_msc_reply->sbc_hi, get_msc_reply->sbc_lo);
   free(get_msc_reply);
d325 7
a331 1
   return 1;
d334 5
d343 2
a344 24
   xcb_connection_t *c = XGetXCBConnection(pdraw->psc->dpy);
   xcb_dri2_wait_msc_cookie_t wait_msc_cookie;
   xcb_dri2_wait_msc_reply_t *wait_msc_reply;
   uint32_t target_msc_hi, target_msc_lo;
   uint32_t divisor_hi, divisor_lo;
   uint32_t remainder_hi, remainder_lo;

   split_counter(target_msc, &target_msc_hi, &target_msc_lo);
   split_counter(divisor, &divisor_hi, &divisor_lo);
   split_counter(remainder, &remainder_hi, &remainder_lo);

   wait_msc_cookie = xcb_dri2_wait_msc_unchecked(c, pdraw->xDrawable,
                                                 target_msc_hi, target_msc_lo,
                                                 divisor_hi, divisor_lo,
                                                 remainder_hi, remainder_lo);
   wait_msc_reply = xcb_dri2_wait_msc_reply(c, wait_msc_cookie, NULL);

   if (!wait_msc_reply)
      return 0;

   *ust = merge_counter(wait_msc_reply->ust_hi, wait_msc_reply->ust_lo);
   *msc = merge_counter(wait_msc_reply->msc_hi, wait_msc_reply->msc_lo);
   *sbc = merge_counter(wait_msc_reply->sbc_hi, wait_msc_reply->sbc_lo);
   free(wait_msc_reply);
d346 7
a352 1
   return 1;
d359 2
a360 4
   xcb_connection_t *c = XGetXCBConnection(pdraw->psc->dpy);
   xcb_dri2_wait_sbc_cookie_t wait_sbc_cookie;
   xcb_dri2_wait_sbc_reply_t *wait_sbc_reply;
   uint32_t target_sbc_hi, target_sbc_lo;
d362 5
a366 1
   split_counter(target_sbc, &target_sbc_hi, &target_sbc_lo);
d368 1
a368 13
   wait_sbc_cookie = xcb_dri2_wait_sbc_unchecked(c, pdraw->xDrawable,
                                                 target_sbc_hi, target_sbc_lo);
   wait_sbc_reply = xcb_dri2_wait_sbc_reply(c, wait_sbc_cookie, NULL);

   if (!wait_sbc_reply)
      return 0;

   *ust = merge_counter(wait_sbc_reply->ust_hi, wait_sbc_reply->ust_lo);
   *msc = merge_counter(wait_sbc_reply->msc_hi, wait_sbc_reply->msc_lo);
   *sbc = merge_counter(wait_sbc_reply->sbc_hi, wait_sbc_reply->sbc_lo);
   free(wait_sbc_reply);

   return 1;
d371 1
a371 53
static __DRIcontext *
dri2GetCurrentContext()
{
   struct glx_context *gc = __glXGetCurrentContext();
   struct dri2_context *dri2Ctx = (struct dri2_context *)gc;

   return dri2Ctx ? dri2Ctx->driContext : NULL;
}

/**
 * dri2Throttle - Request driver throttling
 *
 * This function uses the DRI2 throttle extension to give the
 * driver the opportunity to throttle on flush front, copysubbuffer
 * and swapbuffers.
 */
static void
dri2Throttle(struct dri2_screen *psc,
	     struct dri2_drawable *draw,
	     enum __DRI2throttleReason reason)
{
   if (psc->throttle) {
      __DRIcontext *ctx = dri2GetCurrentContext();

      psc->throttle->throttle(ctx, draw->driDrawable, reason);
   }
}

/**
 * Asks the driver to flush any queued work necessary for serializing with the
 * X command stream, and optionally the slightly more strict requirement of
 * glFlush() equivalence (which would require flushing even if nothing had
 * been drawn to a window system framebuffer, for example).
 */
static void
dri2Flush(struct dri2_screen *psc,
          __DRIcontext *ctx,
          struct dri2_drawable *draw,
          unsigned flags,
          enum __DRI2throttleReason throttle_reason)
{
   if (ctx && psc->f && psc->f->base.version >= 4) {
      psc->f->flush_with_flags(ctx, draw->driDrawable, flags, throttle_reason);
   } else {
      if (flags & __DRI2_FLUSH_CONTEXT)
         glFlush();

      if (psc->f)
         psc->f->flush(draw->driDrawable);

      dri2Throttle(psc, draw, throttle_reason);
   }
}
d374 1
a374 3
__dri2CopySubBuffer(__GLXDRIdrawable *pdraw, int x, int y,
		    int width, int height,
		    enum __DRI2throttleReason reason, Bool flush)
a379 2
   __DRIcontext *ctx = dri2GetCurrentContext();
   unsigned flags;
d390 4
a393 4
   flags = __DRI2_FLUSH_DRAWABLE;
   if (flush)
      flags |= __DRI2_FLUSH_CONTEXT;
   dri2Flush(psc, ctx, priv, flags, __DRI2_THROTTLE_SWAPBUFFER);
a409 9
dri2CopySubBuffer(__GLXDRIdrawable *pdraw, int x, int y,
		  int width, int height, Bool flush)
{
   __dri2CopySubBuffer(pdraw, x, y, width, height,
		       __DRI2_THROTTLE_COPYSUBBUFFER, flush);
}


static void
d421 1
d424 1
a455 4
/**
 * Called by the driver when it needs to update the real front buffer with the
 * contents of its fake front buffer.
 */
a458 3
   struct glx_display *priv;
   struct dri2_display *pdp;
   struct glx_context *gc;
d460 3
a462 15
   struct dri2_screen *psc;

   if (!pdraw)
      return;

   if (!pdraw->base.psc)
      return;

   psc = (struct dri2_screen *) pdraw->base.psc;

   priv = __glXInitialize(psc->base.dpy);
   pdp = (struct dri2_display *) priv->dri2Display;
   gc = __glXGetCurrentContext();

   dri2Throttle(psc, pdraw, __DRI2_THROTTLE_FLUSHFRONT);
d481 1
a481 1
   free(psc);
a525 67
static void show_fps(struct dri2_drawable *draw)
{
   struct timeval tv;
   uint64_t current_time;

   gettimeofday(&tv, 0);
   current_time = (uint64_t)tv.tv_sec*1000000 + (uint64_t)tv.tv_usec;

   draw->frames++;

   if (draw->previous_time + 1000000 <= current_time) {
      if (draw->previous_time) {
         fprintf(stderr, "libGL: FPS = %.1f\n",
                 ((uint64_t)draw->frames * 1000000) /
                 (double)(current_time - draw->previous_time));
      }
      draw->frames = 0;
      draw->previous_time = current_time;
   }
}

static int64_t
dri2XcbSwapBuffers(Display *dpy,
                  __GLXDRIdrawable *pdraw,
                  int64_t target_msc,
                  int64_t divisor,
                  int64_t remainder)
{
   xcb_dri2_swap_buffers_cookie_t swap_buffers_cookie;
   xcb_dri2_swap_buffers_reply_t *swap_buffers_reply;
   uint32_t target_msc_hi, target_msc_lo;
   uint32_t divisor_hi, divisor_lo;
   uint32_t remainder_hi, remainder_lo;
   int64_t ret = 0;
   xcb_connection_t *c = XGetXCBConnection(dpy);

   split_counter(target_msc, &target_msc_hi, &target_msc_lo);
   split_counter(divisor, &divisor_hi, &divisor_lo);
   split_counter(remainder, &remainder_hi, &remainder_lo);

   swap_buffers_cookie =
      xcb_dri2_swap_buffers_unchecked(c, pdraw->xDrawable,
                                      target_msc_hi, target_msc_lo,
                                      divisor_hi, divisor_lo,
                                      remainder_hi, remainder_lo);

   /* Immediately wait on the swapbuffers reply.  If we didn't, we'd have
    * to do so some time before reusing a (non-pageflipped) backbuffer.
    * Otherwise, the new rendering could get ahead of the X Server's
    * dispatch of the swapbuffer and you'd display garbage.
    *
    * We use XSync() first to reap the invalidate events through the event
    * filter, to ensure that the next drawing doesn't use an invalidated
    * buffer.
    */
   XSync(dpy, False);

   swap_buffers_reply =
      xcb_dri2_swap_buffers_reply(c, swap_buffers_cookie, NULL);
   if (swap_buffers_reply) {
      ret = merge_counter(swap_buffers_reply->swap_hi,
                          swap_buffers_reply->swap_lo);
      free(swap_buffers_reply);
   }
   return ret;
}

d528 1
a528 1
		int64_t remainder, Bool flush)
d535 1
a535 1
    int64_t ret = 0;
d537 8
a544 3
    /* Check we have the right attachments */
    if (!priv->have_back)
	return ret;
d548 2
a549 11
       __dri2CopySubBuffer(pdraw, 0, 0, priv->width, priv->height,
			   __DRI2_THROTTLE_SWAPBUFFER, flush);
    } else {
       __DRIcontext *ctx = dri2GetCurrentContext();
       unsigned flags = __DRI2_FLUSH_DRAWABLE;
       if (flush)
          flags |= __DRI2_FLUSH_CONTEXT;
       dri2Flush(psc, ctx, priv, flags, __DRI2_THROTTLE_SWAPBUFFER);

       ret = dri2XcbSwapBuffers(pdraw->psc->dpy, pdraw,
                                target_msc, divisor, remainder);
d552 4
a555 7
    if (psc->show_fps) {
       show_fps(priv);
    }

    /* Old servers don't send invalidate events */
    if (!pdp->invalidateAvailable)
       dri2InvalidateBuffers(dpyPriv->dpy, pdraw->xDrawable);
d578 1
a578 1
   free(buffers);
d603 1
a603 1
   free(buffers);
d608 2
a612 1
   xcb_connection_t *c = XGetXCBConnection(pdraw->psc->dpy);
d623 1
a623 3
      if (interval != 0)
         return GLX_BAD_VALUE;
      break;
d632 1
a632 1
   xcb_dri2_swap_interval(c, priv->base.xDrawable, interval);
d646 2
d662 1
d666 1
d673 1
a673 1
   struct dri2_screen *psc;
d676 2
a677 6
   if (!pdraw)
      return;

   psc = (struct dri2_screen *) pdraw->psc;

   if (pdraw && psc->f && psc->f->base.version >= 3 && psc->f->invalidate)
d679 1
d699 2
a700 2
      if (!pdp->invalidateAvailable && psc->f &&
           psc->f->base.version >= 3 && psc->f->invalidate)
d702 1
a721 21
#if __DRI_TEX_BUFFER_VERSION >= 3
   struct glx_context *gc = __glXGetCurrentContext();
   struct dri2_context *pcp = (struct dri2_context *) gc;
   __GLXDRIdrawable *base = GetGLXDRIDrawable(dpy, drawable);
   struct glx_display *dpyPriv = __glXInitialize(dpy);
   struct dri2_drawable *pdraw = (struct dri2_drawable *) base;
   struct dri2_display *pdp =
      (struct dri2_display *) dpyPriv->dri2Display;
   struct dri2_screen *psc;

   if (pdraw != NULL) {
      psc = (struct dri2_screen *) base->psc;

      if (psc->texBuffer->base.version >= 3 &&
          psc->texBuffer->releaseTexBuffer != NULL) {
         (*psc->texBuffer->releaseTexBuffer) (pcp->driContext,
                                           pdraw->base.textureTarget,
                                           pdraw->driDrawable);
      }
   }
#endif
a732 1
   NULL, /* get_proc_address */
d736 1
a736 2
dri2BindExtensions(struct dri2_screen *psc, struct glx_display * priv,
                   const char *driverName)
a737 3
   const struct dri2_display *const pdp = (struct dri2_display *)
      priv->dri2Display;
   const __DRIextension **extensions;
a739 2
   extensions = psc->core->getExtensions(psc->driScreen);

d745 2
a746 27
   /*
    * GLX_INTEL_swap_event is broken on the server side, where it's
    * currently unconditionally enabled. This completely breaks
    * systems running on drivers which don't support that extension.
    * There's no way to test for its presence on this side, so instead
    * of disabling it unconditionally, just disable it for drivers
    * which are known to not support it, or for DDX drivers supporting
    * only an older (pre-ScheduleSwap) version of DRI2.
    *
    * This is a hack which is required until:
    * http://lists.x.org/archives/xorg-devel/2013-February/035449.html
    * is merged and updated xserver makes it's way into distros:
    */
   if (pdp->swapAvailable && strcmp(driverName, "vmwgfx") != 0) {
      __glXEnableDirectExtension(&psc->base, "GLX_INTEL_swap_event");
   }

   if (psc->dri2->base.version >= 3) {
      const unsigned mask = psc->dri2->getAPIMask(psc->driScreen);

      __glXEnableDirectExtension(&psc->base, "GLX_ARB_create_context");
      __glXEnableDirectExtension(&psc->base, "GLX_ARB_create_context_profile");

      if ((mask & (1 << __DRI_API_GLES2)) != 0)
	 __glXEnableDirectExtension(&psc->base,
				    "GLX_EXT_create_context_es2_profile");
   }
a760 11

      if (((strcmp(extensions[i]->name, __DRI2_THROTTLE) == 0)))
	 psc->throttle = (__DRI2throttleExtension *) extensions[i];

      /* DRI2 version 3 is also required because
       * GLX_ARB_create_context_robustness requires GLX_ARB_create_context.
       */
      if (psc->dri2->base.version >= 3
          && strcmp(extensions[i]->name, __DRI2_ROBUSTNESS) == 0)
         __glXEnableDirectExtension(&psc->base,
                                    "GLX_ARB_create_context_robustness");
d765 1
a765 2
   dri2_create_context,
   dri2_create_context_attribs
d777 1
a777 2
   struct glx_config *configs = NULL, *visuals = NULL;
   char *driverName, *deviceName, *tmp;
d781 1
a781 1
   psc = calloc(1, sizeof *psc);
d785 3
a787 6
   psc->fd = -1;

   if (!glx_screen_init(&psc->base, screen, priv)) {
      free(psc);
      return NULL;
   }
d791 1
a791 3
      glx_screen_cleanup(&psc->base);
      free(psc);
      InfoMessageF("screen %d does not appear to be DRI2 capable\n", screen);
d819 1
a819 9
#ifdef O_CLOEXEC
   psc->fd = open(deviceName, O_RDWR | O_CLOEXEC);
   if (psc->fd == -1 && errno == EINVAL)
#endif
   {
      psc->fd = open(deviceName, O_RDWR);
      if (psc->fd != -1)
         fcntl(psc->fd, F_SETFD, fcntl(psc->fd, F_GETFD) | FD_CLOEXEC);
   }
d850 2
a851 1
   dri2BindExtensions(psc, priv, driverName);
d853 4
a856 10
   configs = driConvertConfigs(psc->core, psc->base.configs, driver_configs);
   visuals = driConvertConfigs(psc->core, psc->base.visuals, driver_configs);

   if (!configs || !visuals)
       goto handle_error;

   glx_config_destroy_list(psc->base.configs);
   psc->base.configs = configs;
   glx_config_destroy_list(psc->base.visuals);
   psc->base.visuals = visuals;
d873 1
d875 2
d879 2
d883 2
d886 1
d894 2
a895 5
   free(driverName);
   free(deviceName);

   tmp = getenv("LIBGL_SHOW_FPS");
   psc->show_fps = tmp && strcmp(tmp, "1") == 0;
d900 3
a902 1
   CriticalErrorMessageF("failed to load driver: %s\n", driverName);
d904 1
a904 16
   if (configs)
       glx_config_destroy_list(configs);
   if (visuals)
       glx_config_destroy_list(visuals);
   if (psc->driScreen)
       psc->core->destroyScreen(psc->driScreen);
   psc->driScreen = NULL;
   if (psc->fd >= 0)
      close(psc->fd);
   if (psc->driver)
      dlclose(psc->driver);

   free(driverName);
   free(deviceName);
   glx_screen_cleanup(&psc->base);
   free(psc);
d917 1
a917 1
   free(dpy);
d947 1
a947 1
   pdp = malloc(sizeof *pdp);
d952 1
a952 1
      free(pdp);
d971 1
d973 1
a973 1

d978 1
a978 1
      free(pdp);
@


1.1.1.3
log
@Import Mesa 9.2.1
@
text
@d263 4
a266 4
   uint32_t minor_ver;
   uint32_t major_ver;
   uint32_t renderType;
   uint32_t flags;
d268 1
a268 1
   int reset;
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d40 1
d43 1
d50 1
a52 2
#include "dri2_priv.h"
#include "loader.h"
d81 20
a161 2
   __DRIdrawable *dri_draw = NULL, *dri_read = NULL;
   struct glx_display *dpyPriv = psc->base.display;
d169 1
a169 8
   if (pdraw)
      dri_draw = pdraw->driDrawable;
   else if (draw != None)
      return GLXBadDrawable;

   if (pread)
      dri_read = pread->driDrawable;
   else if (read != None)
d172 2
a173 1
   if (!(*psc->core->bindContext) (pcp->driContext, dri_draw, dri_read))
d179 2
a180 2
   pdp = (struct dri2_display *) dpyPriv->dri2Display;
   if (!pdp->invalidateAvailable && pdraw) {
d182 1
a182 1
      if (pread != pdraw && pread)
a387 4
   dpyPriv = __glXInitialize(psc->base.dpy);
   if (dpyPriv == NULL)
      return NULL;

d417 2
a697 4

   if (priv == NULL)
       return;

a766 2
   const int interval =
      ((struct dri2_screen *) draw->base.psc)->show_fps_interval;
d775 1
a775 1
   if (draw->previous_time + interval * 1000000 <= current_time) {
d862 1
a862 1
    if (psc->show_fps_interval) {
d961 4
a964 5
   .base = { __DRI_DRI2_LOADER, 3 },

   .getBuffers              = dri2GetBuffers,
   .flushFrontBuffer        = dri2FlushFrontBuffer,
   .getBuffersWithFormat    = dri2GetBuffersWithFormat,
d968 4
a971 5
   .base = { __DRI_DRI2_LOADER, 3 },

   .getBuffers              = dri2GetBuffers,
   .flushFrontBuffer        = dri2FlushFrontBuffer,
   .getBuffersWithFormat    = NULL,
d975 1
a975 1
   .base = { __DRI_USE_INVALIDATE, 1 }
d1005 2
a1006 1
   struct dri2_display *pdp;
a1008 5
   if (dpyPriv == NULL)
       return;

   pdp = (struct dri2_display *) dpyPriv->dri2Display;

d1034 1
d1040 2
d1044 1
a1044 1
   if (dpyPriv != NULL && pdraw != NULL) {
d1054 1
d1058 9
a1066 9
   .destroy             = dri2_destroy_context,
   .bind                = dri2_bind_context,
   .unbind              = dri2_unbind_context,
   .wait_gl             = dri2_wait_gl,
   .wait_x              = dri2_wait_x,
   .use_x_font          = DRI_glXUseXFont,
   .bind_tex_image      = dri2_bind_tex_image,
   .release_tex_image   = dri2_release_tex_image,
   .get_proc_address    = NULL,
a1136 9

      /* DRI2 version 3 is also required because GLX_MESA_query_renderer
       * requires GLX_ARB_create_context_profile.
       */
      if (psc->dri2->base.version >= 3
          && strcmp(extensions[i]->name, __DRI2_RENDERER_QUERY) == 0) {
         psc->rendererQuery = (__DRI2rendererQueryExtension *) extensions[i];
         __glXEnableDirectExtension(&psc->base, "GLX_MESA_query_renderer");
      }
d1141 2
a1142 4
   .create_context         = dri2_create_context,
   .create_context_attribs = dri2_create_context_attribs,
   .query_renderer_integer = dri2_query_renderer_integer,
   .query_renderer_string  = dri2_query_renderer_string,
d1155 1
a1155 1
   char *driverName = NULL, *loader_driverName, *deviceName, *tmp;
d1178 24
d1226 3
a1228 2
   /* If Mesa knows about the appropriate driver for this fd, then trust it.
    * Otherwise, default to the server's value.
d1230 5
a1234 42
   loader_driverName = loader_get_driver_for_fd(psc->fd, 0);
   if (loader_driverName) {
      free(driverName);
      driverName = loader_driverName;
   }

   psc->driver = driOpenDriver(driverName);
   if (psc->driver == NULL) {
      ErrorMessageF("driver pointer missing\n");
      goto handle_error;
   }

   extensions = driGetDriverExtensions(psc->driver, driverName);
   if (extensions == NULL)
      goto handle_error;

   for (i = 0; extensions[i]; i++) {
      if (strcmp(extensions[i]->name, __DRI_CORE) == 0)
	 psc->core = (__DRIcoreExtension *) extensions[i];
      if (strcmp(extensions[i]->name, __DRI_DRI2) == 0)
	 psc->dri2 = (__DRIdri2Extension *) extensions[i];
   }

   if (psc->core == NULL || psc->dri2 == NULL) {
      ErrorMessageF("core dri or dri2 extension not found\n");
      goto handle_error;
   }

   if (psc->dri2->base.version >= 4) {
      psc->driScreen =
         psc->dri2->createNewScreen2(screen, psc->fd,
                                     (const __DRIextension **)
                                     &pdp->loader_extensions[0],
                                     extensions,
                                     &driver_configs, psc);
   } else {
      psc->driScreen =
         psc->dri2->createNewScreen(screen, psc->fd,
                                    (const __DRIextension **)
                                    &pdp->loader_extensions[0],
                                    &driver_configs, psc);
   }
a1266 1
   psp->getBufferAge = NULL;
d1286 1
a1286 3
   psc->show_fps_interval = (tmp) ? atoi(tmp) : 0;
   if (psc->show_fps_interval < 0)
      psc->show_fps_interval = 0;
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d1266 1
a1266 2
   if (!configs || !visuals) {
       ErrorMessageF("No matching fbConfigs or visuals found\n");
a1267 1
   }
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d1266 2
a1267 1
   if (!configs || !visuals)
d1269 1
@


