head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.45;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.58;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.03.42;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.13;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.38;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.36;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.33;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.38;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.44;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************

Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sub license, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Kevin E. Martin <kevin@@precisioninsight.com>
 *   Brian Paul <brian@@precisioninsight.com>
 *
 */

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)

#include <X11/Xlib.h>
#include <X11/extensions/Xfixes.h>
#include <X11/extensions/Xdamage.h>
#include "glxclient.h"
#include "xf86dri.h"
#include "dri2.h"
#include "sarea.h"
#include <dlfcn.h>
#include <sys/types.h>
#include <sys/mman.h>
#include "xf86drm.h"
#include "dri_common.h"

struct dri_display
{
   __GLXDRIdisplay base;

   /*
    ** XFree86-DRI version information
    */
   int driMajor;
   int driMinor;
   int driPatch;
};

struct dri_screen
{
   struct glx_screen base;

   __DRIscreen *driScreen;
   __GLXDRIscreen vtable;
   const __DRIlegacyExtension *legacy;
   const __DRIcoreExtension *core;
   const __DRIswapControlExtension *swapControl;
   const __DRImediaStreamCounterExtension *msc;
   const __DRIconfig **driver_configs;
   const __DRIcopySubBufferExtension *driCopySubBuffer;

   void *driver;
   int fd;
};

struct dri_context
{
   struct glx_context base;
   __DRIcontext *driContext;
   XID hwContextID;
};

struct dri_drawable
{
   __GLXDRIdrawable base;

   __DRIdrawable *driDrawable;
};

/*
 * Given a display pointer and screen number, determine the name of
 * the DRI driver for the screen (i.e., "i965", "radeon", "nouveau", etc).
 * Return True for success, False for failure.
 */
static Bool
driGetDriverName(Display * dpy, int scrNum, char **driverName)
{
   int directCapable;
   Bool b;
   int event, error;
   int driverMajor, driverMinor, driverPatch;

   *driverName = NULL;

   if (XF86DRIQueryExtension(dpy, &event, &error)) {    /* DRI1 */
      if (!XF86DRIQueryDirectRenderingCapable(dpy, scrNum, &directCapable)) {
         ErrorMessageF("XF86DRIQueryDirectRenderingCapable failed\n");
         return False;
      }
      if (!directCapable) {
         ErrorMessageF("XF86DRIQueryDirectRenderingCapable returned false\n");
         return False;
      }

      b = XF86DRIGetClientDriverName(dpy, scrNum, &driverMajor, &driverMinor,
                                     &driverPatch, driverName);
      if (!b) {
         ErrorMessageF("Cannot determine driver name for screen %d\n",
                       scrNum);
         return False;
      }

      InfoMessageF("XF86DRIGetClientDriverName: %d.%d.%d %s (screen %d)\n",
                   driverMajor, driverMinor, driverPatch, *driverName,
                   scrNum);

      return True;
   }
   else if (DRI2QueryExtension(dpy, &event, &error)) {  /* DRI2 */
      char *dev;
      Bool ret = DRI2Connect(dpy, RootWindow(dpy, scrNum), driverName, &dev);

      if (ret)
         free(dev);

      return ret;
   }

   return False;
}

/*
 * Exported function for querying the DRI driver for a given screen.
 *
 * The returned char pointer points to a static array that will be
 * overwritten by subsequent calls.
 */
_X_EXPORT const char *
glXGetScreenDriver(Display * dpy, int scrNum)
{
   static char ret[32];
   char *driverName;
   if (driGetDriverName(dpy, scrNum, &driverName)) {
      int len;
      if (!driverName)
         return NULL;
      len = strlen(driverName);
      if (len >= 31)
         return NULL;
      memcpy(ret, driverName, len + 1);
      free(driverName);
      return ret;
   }
   return NULL;
}

/*
 * Exported function for obtaining a driver's option list (UTF-8 encoded XML).
 *
 * The returned char pointer points directly into the driver. Therefore
 * it should be treated as a constant.
 *
 * If the driver was not found or does not support configuration NULL is
 * returned.
 *
 * Note: The driver remains opened after this function returns.
 */
_X_EXPORT const char *
glXGetDriverConfig(const char *driverName)
{
   void *handle = driOpenDriver(driverName);
   const __DRIextension **extensions;

   if (!handle)
      return NULL;

   extensions = driGetDriverExtensions(handle, driverName);
   if (extensions) {
      for (int i = 0; extensions[i]; i++) {
         if (strcmp(extensions[i]->name, __DRI_CONFIG_OPTIONS) == 0)
            return ((__DRIconfigOptionsExtension *)extensions[i])->xml;
      }
   }

   /* Fall back to the old method */
   return dlsym(handle, "__driConfigOptions");
}

#ifdef XDAMAGE_1_1_INTERFACE

static GLboolean
has_damage_post(Display * dpy)
{
   static GLboolean inited = GL_FALSE;
   static GLboolean has_damage;

   if (!inited) {
      int major, minor;

      if (XDamageQueryVersion(dpy, &major, &minor) &&
          major == 1 && minor >= 1) {
         has_damage = GL_TRUE;
      }
      else {
         has_damage = GL_FALSE;
      }
      inited = GL_TRUE;
   }

   return has_damage;
}

static void
__glXReportDamage(__DRIdrawable * driDraw,
                  int x, int y,
                  drm_clip_rect_t * rects, int num_rects,
                  GLboolean front_buffer, void *loaderPrivate)
{
   XRectangle *xrects;
   XserverRegion region;
   int i;
   int x_off, y_off;
   __GLXDRIdrawable *glxDraw = loaderPrivate;
   struct glx_screen *psc = glxDraw->psc;
   Display *dpy = psc->dpy;
   Drawable drawable;

   if (!has_damage_post(dpy))
      return;

   if (front_buffer) {
      x_off = x;
      y_off = y;
      drawable = RootWindow(dpy, psc->scr);
   }
   else {
      x_off = 0;
      y_off = 0;
      drawable = glxDraw->xDrawable;
   }

   xrects = malloc(sizeof(XRectangle) * num_rects);
   if (xrects == NULL)
      return;

   for (i = 0; i < num_rects; i++) {
      xrects[i].x = rects[i].x1 + x_off;
      xrects[i].y = rects[i].y1 + y_off;
      xrects[i].width = rects[i].x2 - rects[i].x1;
      xrects[i].height = rects[i].y2 - rects[i].y1;
   }
   region = XFixesCreateRegion(dpy, xrects, num_rects);
   free(xrects);
   XDamageAdd(dpy, drawable, region);
   XFixesDestroyRegion(dpy, region);
}

static const __DRIdamageExtension damageExtension = {
   .base = {__DRI_DAMAGE, 1 },

   .reportDamage        = __glXReportDamage,
};

#endif

static GLboolean
__glXDRIGetDrawableInfo(__DRIdrawable * drawable,
                        unsigned int *index, unsigned int *stamp,
                        int *X, int *Y, int *W, int *H,
                        int *numClipRects, drm_clip_rect_t ** pClipRects,
                        int *backX, int *backY,
                        int *numBackClipRects,
                        drm_clip_rect_t ** pBackClipRects,
                        void *loaderPrivate)
{
   __GLXDRIdrawable *glxDraw = loaderPrivate;
   struct glx_screen *psc = glxDraw->psc;
   Display *dpy = psc->dpy;

   return XF86DRIGetDrawableInfo(dpy, psc->scr, glxDraw->drawable,
                                 index, stamp, X, Y, W, H,
                                 numClipRects, pClipRects,
                                 backX, backY,
                                 numBackClipRects, pBackClipRects);
}

static const __DRIgetDrawableInfoExtension getDrawableInfoExtension = {
   .base = {__DRI_GET_DRAWABLE_INFO, 1 },

   .getDrawableInfo     = __glXDRIGetDrawableInfo
};

static const __DRIextension *loader_extensions[] = {
   &systemTimeExtension.base,
   &getDrawableInfoExtension.base,
#ifdef XDAMAGE_1_1_INTERFACE
   &damageExtension.base,
#endif
   NULL
};

/**
 * Perform the required libGL-side initialization and call the client-side
 * driver's \c __driCreateNewScreen function.
 * 
 * \param dpy    Display pointer.
 * \param scrn   Screen number on the display.
 * \param psc    DRI screen information.
 * \param driDpy DRI display information.
 * \param createNewScreen  Pointer to the client-side driver's
 *               \c __driCreateNewScreen function.
 * \returns A pointer to the \c __DRIscreen structure returned by
 *          the client-side driver on success, or \c NULL on failure.
 */
static void *
CallCreateNewScreen(Display *dpy, int scrn, struct dri_screen *psc,
                    struct dri_display * driDpy)
{
   void *psp = NULL;
   drm_handle_t hSAREA;
   drmAddress pSAREA = MAP_FAILED;
   char *BusID;
   __DRIversion ddx_version;
   __DRIversion dri_version;
   __DRIversion drm_version;
   __DRIframebuffer framebuffer;
   int fd = -1;
   int status;

   drm_magic_t magic;
   drmVersionPtr version;
   int newlyopened;
   char *driverName;
   drm_handle_t hFB;
   int junk;
   const __DRIconfig **driver_configs;
   struct glx_config *visual, *configs = NULL, *visuals = NULL;

   /* DRI protocol version. */
   dri_version.major = driDpy->driMajor;
   dri_version.minor = driDpy->driMinor;
   dri_version.patch = driDpy->driPatch;

   framebuffer.base = MAP_FAILED;
   framebuffer.dev_priv = NULL;
   framebuffer.size = 0;

   if (!XF86DRIOpenConnection(dpy, scrn, &hSAREA, &BusID)) {
      ErrorMessageF("XF86DRIOpenConnection failed\n");
      goto handle_error;
   }

   fd = drmOpenOnce(NULL, BusID, &newlyopened);

   free(BusID);                /* No longer needed */

   if (fd < 0) {
      ErrorMessageF("drmOpenOnce failed (%s)\n", strerror(-fd));
      goto handle_error;
   }

   if (drmGetMagic(fd, &magic)) {
      ErrorMessageF("drmGetMagic failed\n");
      goto handle_error;
   }

   version = drmGetVersion(fd);
   if (version) {
      drm_version.major = version->version_major;
      drm_version.minor = version->version_minor;
      drm_version.patch = version->version_patchlevel;
      drmFreeVersion(version);
   }
   else {
      drm_version.major = -1;
      drm_version.minor = -1;
      drm_version.patch = -1;
   }

   if (newlyopened && !XF86DRIAuthConnection(dpy, scrn, magic)) {
      ErrorMessageF("XF86DRIAuthConnection failed\n");
      goto handle_error;
   }

   /* Get device name (like "radeon") and the ddx version numbers.
    * We'll check the version in each DRI driver's "createNewScreen"
    * function. */
   if (!XF86DRIGetClientDriverName(dpy, scrn,
                                   &ddx_version.major,
                                   &ddx_version.minor,
                                   &ddx_version.patch, &driverName)) {
      ErrorMessageF("XF86DRIGetClientDriverName failed\n");
      goto handle_error;
   }

   free(driverName);           /* No longer needed. */

   /*
    * Get device-specific info.  pDevPriv will point to a struct
    * (such as DRIRADEONRec in xfree86/driver/ati/radeon_dri.h) that
    * has information about the screen size, depth, pitch, ancilliary
    * buffers, DRM mmap handles, etc.
    */
   if (!XF86DRIGetDeviceInfo(dpy, scrn, &hFB, &junk,
                             &framebuffer.size, &framebuffer.stride,
                             &framebuffer.dev_priv_size,
                             &framebuffer.dev_priv)) {
      ErrorMessageF("XF86DRIGetDeviceInfo failed\n");
      goto handle_error;
   }

   framebuffer.width = DisplayWidth(dpy, scrn);
   framebuffer.height = DisplayHeight(dpy, scrn);

   /* Map the framebuffer region. */
   status = drmMap(fd, hFB, framebuffer.size,
                   (drmAddressPtr) & framebuffer.base);
   if (status != 0) {
      ErrorMessageF("drmMap of framebuffer failed (%s)\n", strerror(-status));
      goto handle_error;
   }

   /* Map the SAREA region.  Further mmap regions may be setup in
    * each DRI driver's "createNewScreen" function.
    */
   status = drmMap(fd, hSAREA, SAREA_MAX, &pSAREA);
   if (status != 0) {
      ErrorMessageF("drmMap of SAREA failed (%s)\n", strerror(-status));
      goto handle_error;
   }

   psp = (*psc->legacy->createNewScreen) (scrn,
                                          &ddx_version,
                                          &dri_version,
                                          &drm_version,
                                          &framebuffer,
                                          pSAREA,
                                          fd,
                                          loader_extensions,
                                          &driver_configs, psc);

   if (psp == NULL) {
      ErrorMessageF("Calling driver entry point failed\n");
      goto handle_error;
   }

   configs = driConvertConfigs(psc->core, psc->base.configs, driver_configs);
   visuals = driConvertConfigs(psc->core, psc->base.visuals, driver_configs);

   if (!configs || !visuals)
       goto handle_error;

   glx_config_destroy_list(psc->base.configs);
   psc->base.configs = configs;
   glx_config_destroy_list(psc->base.visuals);
   psc->base.visuals = visuals;

   psc->driver_configs = driver_configs;

   /* Visuals with depth != screen depth are subject to automatic compositing
    * in the X server, so DRI1 can't render to them properly. Mark them as
    * non-conformant to prevent apps from picking them up accidentally.
    */
   for (visual = psc->base.visuals; visual; visual = visual->next) {
      XVisualInfo template;
      XVisualInfo *visuals;
      int num_visuals;
      long mask;

      template.visualid = visual->visualID;
      mask = VisualIDMask;
      visuals = XGetVisualInfo(dpy, mask, &template, &num_visuals);

      if (visuals) {
         if (num_visuals > 0 && visuals->depth != DefaultDepth(dpy, scrn))
            visual->visualRating = GLX_NON_CONFORMANT_CONFIG;

         free(visuals);
      }
   }

   return psp;

 handle_error:
   if (configs)
       glx_config_destroy_list(configs);
   if (visuals)
       glx_config_destroy_list(visuals);

   if (pSAREA != MAP_FAILED)
      drmUnmap(pSAREA, SAREA_MAX);

   if (framebuffer.base != MAP_FAILED)
      drmUnmap((drmAddress) framebuffer.base, framebuffer.size);

   free(framebuffer.dev_priv);

   if (fd >= 0)
      drmCloseOnce(fd);

   XF86DRICloseConnection(dpy, scrn);

   ErrorMessageF("reverting to software direct rendering\n");

   return NULL;
}

static void
dri_destroy_context(struct glx_context * context)
{
   struct dri_context *pcp = (struct dri_context *) context;
   struct dri_screen *psc = (struct dri_screen *) context->psc;

   driReleaseDrawables(&pcp->base);

   free((char *) context->extensions);

   (*psc->core->destroyContext) (pcp->driContext);

   XF86DRIDestroyContext(psc->base.dpy, psc->base.scr, pcp->hwContextID);
   free(pcp);
}

static int
dri_bind_context(struct glx_context *context, struct glx_context *old,
		 GLXDrawable draw, GLXDrawable read)
{
   struct dri_context *pcp = (struct dri_context *) context;
   struct dri_screen *psc = (struct dri_screen *) pcp->base.psc;
   struct dri_drawable *pdraw, *pread;

   pdraw = (struct dri_drawable *) driFetchDrawable(context, draw);
   pread = (struct dri_drawable *) driFetchDrawable(context, read);

   driReleaseDrawables(&pcp->base);

   if (pdraw == NULL || pread == NULL)
      return GLXBadDrawable;

   if ((*psc->core->bindContext) (pcp->driContext,
				  pdraw->driDrawable, pread->driDrawable))
      return Success;

   return GLXBadContext;
}

static void
dri_unbind_context(struct glx_context *context, struct glx_context *new)
{
   struct dri_context *pcp = (struct dri_context *) context;
   struct dri_screen *psc = (struct dri_screen *) pcp->base.psc;

   (*psc->core->unbindContext) (pcp->driContext);
}

static const struct glx_context_vtable dri_context_vtable = {
   .destroy             = dri_destroy_context,
   .bind                = dri_bind_context,
   .unbind              = dri_unbind_context,
   .wait_gl             = NULL,
   .wait_x              = NULL,
   .use_x_font          = DRI_glXUseXFont,
   .bind_tex_image      = NULL,
   .release_tex_image   = NULL,
   .get_proc_address    = NULL,
};

static struct glx_context *
dri_create_context(struct glx_screen *base,
		   struct glx_config *config_base,
		   struct glx_context *shareList, int renderType)
{
   struct dri_context *pcp, *pcp_shared;
   struct dri_screen *psc = (struct dri_screen *) base;
   drm_context_t hwContext;
   __DRIcontext *shared = NULL;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;

   if (!psc->base.driScreen)
      return NULL;

   /* Check the renderType value */
   if (!validate_renderType_against_config(config_base, renderType))
       return NULL;

   if (shareList) {
      /* If the shareList context is not a DRI context, we cannot possibly
       * create a DRI context that shares it.
       */
      if (shareList->vtable->destroy != dri_destroy_context) {
	 return NULL;
      }

      pcp_shared = (struct dri_context *) shareList;
      shared = pcp_shared->driContext;
   }

   pcp = calloc(1, sizeof *pcp);
   if (pcp == NULL)
      return NULL;

   if (!glx_context_init(&pcp->base, &psc->base, &config->base)) {
      free(pcp);
      return NULL;
   }

   pcp->base.renderType = renderType;

   if (!XF86DRICreateContextWithConfig(psc->base.dpy, psc->base.scr,
                                       config->base.visualID,
                                       &pcp->hwContextID, &hwContext)) {
      free(pcp);
      return NULL;
   }

   pcp->driContext =
      (*psc->legacy->createNewContext) (psc->driScreen,
                                        config->driConfig,
                                        renderType, shared, hwContext, pcp);
   if (pcp->driContext == NULL) {
      XF86DRIDestroyContext(psc->base.dpy, psc->base.scr, pcp->hwContextID);
      free(pcp);
      return NULL;
   }

   pcp->base.vtable = &dri_context_vtable;

   return &pcp->base;
}

static void
driDestroyDrawable(__GLXDRIdrawable * pdraw)
{
   struct dri_screen *psc = (struct dri_screen *) pdraw->psc;
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;

   (*psc->core->destroyDrawable) (pdp->driDrawable);
   XF86DRIDestroyDrawable(psc->base.dpy, psc->base.scr, pdraw->drawable);
   free(pdraw);
}

static __GLXDRIdrawable *
driCreateDrawable(struct glx_screen *base,
                  XID xDrawable,
                  GLXDrawable drawable, struct glx_config *config_base)
{
   drm_drawable_t hwDrawable;
   void *empty_attribute_list = NULL;
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
   struct dri_screen *psc = (struct dri_screen *) base;
   struct dri_drawable *pdp;

   /* Old dri can't handle GLX 1.3+ drawable constructors. */
   if (xDrawable != drawable)
      return NULL;

   pdp = calloc(1, sizeof *pdp);
   if (!pdp)
      return NULL;

   pdp->base.drawable = drawable;
   pdp->base.psc = &psc->base;

   if (!XF86DRICreateDrawable(psc->base.dpy, psc->base.scr,
			      drawable, &hwDrawable)) {
      free(pdp);
      return NULL;
   }

   /* Create a new drawable */
   pdp->driDrawable =
      (*psc->legacy->createNewDrawable) (psc->driScreen,
                                         config->driConfig,
                                         hwDrawable,
                                         GLX_WINDOW_BIT,
                                         empty_attribute_list, pdp);

   if (!pdp->driDrawable) {
      XF86DRIDestroyDrawable(psc->base.dpy, psc->base.scr, drawable);
      free(pdp);
      return NULL;
   }

   pdp->base.destroyDrawable = driDestroyDrawable;

   return &pdp->base;
}

static int64_t
driSwapBuffers(__GLXDRIdrawable * pdraw, int64_t unused1, int64_t unused2,
	       int64_t unused3, Bool flush)
{
   struct dri_screen *psc = (struct dri_screen *) pdraw->psc;
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;

   if (flush) {
      glFlush();
   }

   (*psc->core->swapBuffers) (pdp->driDrawable);
   return 0;
}

static void
driCopySubBuffer(__GLXDRIdrawable * pdraw,
                 int x, int y, int width, int height, Bool flush)
{
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;
   struct dri_screen *psc = (struct dri_screen *) pdp->base.psc;

   if (flush) {
      glFlush();
   }

   (*psc->driCopySubBuffer->copySubBuffer) (pdp->driDrawable,
					    x, y, width, height);
}

static void
driDestroyScreen(struct glx_screen *base)
{
   struct dri_screen *psc = (struct dri_screen *) base;

   /* Free the direct rendering per screen data */
   if (psc->driScreen)
      (*psc->core->destroyScreen) (psc->driScreen);
   driDestroyConfigs(psc->driver_configs);
   psc->driScreen = NULL;
   if (psc->driver)
      dlclose(psc->driver);
}

static int
driSetSwapInterval(__GLXDRIdrawable *pdraw, int interval)
{
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;

   if (pdraw != NULL) {
      struct dri_screen *psc = (struct dri_screen *) pdraw->psc;

      if (psc->swapControl != NULL) {
         psc->swapControl->setSwapInterval(pdp->driDrawable, interval);
         return 0;
      }
   }
   return GLX_BAD_CONTEXT;
}

static int
driGetSwapInterval(__GLXDRIdrawable *pdraw)
{
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;

   if (pdraw != NULL) {
      struct dri_screen *psc = (struct dri_screen *) pdraw->psc;

      if (psc->swapControl != NULL)
         return psc->swapControl->getSwapInterval(pdp->driDrawable);
   }
   return 0;
}

/* Bind DRI1 specific extensions */
static void
driBindExtensions(struct dri_screen *psc, const __DRIextension **extensions)
{
   int i;

   for (i = 0; extensions[i]; i++) {
      /* No DRI2 support for swap_control at the moment, since SwapBuffers
       * is done by the X server */
      if (strcmp(extensions[i]->name, __DRI_SWAP_CONTROL) == 0) {
	 psc->swapControl = (__DRIswapControlExtension *) extensions[i];
	 __glXEnableDirectExtension(&psc->base, "GLX_SGI_swap_control");
	 __glXEnableDirectExtension(&psc->base, "GLX_MESA_swap_control");
      }

      if (strcmp(extensions[i]->name, __DRI_MEDIA_STREAM_COUNTER) == 0) {
         psc->msc = (__DRImediaStreamCounterExtension *) extensions[i];
         __glXEnableDirectExtension(&psc->base, "GLX_SGI_video_sync");
      }

      if (strcmp(extensions[i]->name, __DRI_COPY_SUB_BUFFER) == 0) {
	 psc->driCopySubBuffer = (__DRIcopySubBufferExtension *) extensions[i];
	 __glXEnableDirectExtension(&psc->base, "GLX_MESA_copy_sub_buffer");
      }

      if (strcmp(extensions[i]->name, __DRI_READ_DRAWABLE) == 0) {
	 __glXEnableDirectExtension(&psc->base, "GLX_SGI_make_current_read");
      }
      /* Ignore unknown extensions */
   }
}

static const struct glx_screen_vtable dri_screen_vtable = {
   .create_context         = dri_create_context,
   .create_context_attribs = NULL,
   .query_renderer_integer = NULL,
   .query_renderer_string  = NULL,
};

static struct glx_screen *
driCreateScreen(int screen, struct glx_display *priv)
{
   struct dri_display *pdp;
   __GLXDRIscreen *psp;
   const __DRIextension **extensions;
   struct dri_screen *psc;
   char *driverName;
   int i;

   psc = calloc(1, sizeof *psc);
   if (psc == NULL)
      return NULL;

   if (!glx_screen_init(&psc->base, screen, priv)) {
      free(psc);
      return NULL;
   }

   if (!driGetDriverName(priv->dpy, screen, &driverName)) {
      goto cleanup;
   }

   psc->driver = driOpenDriver(driverName);
   if (psc->driver == NULL)
      goto cleanup;

   extensions = dlsym(psc->driver, __DRI_DRIVER_EXTENSIONS);
   if (extensions == NULL) {
      ErrorMessageF("driver exports no extensions (%s)\n", dlerror());
      goto cleanup;
   }

   for (i = 0; extensions[i]; i++) {
      if (strcmp(extensions[i]->name, __DRI_CORE) == 0)
	 psc->core = (__DRIcoreExtension *) extensions[i];
      if (strcmp(extensions[i]->name, __DRI_LEGACY) == 0)
	 psc->legacy = (__DRIlegacyExtension *) extensions[i];
   }

   if (psc->core == NULL || psc->legacy == NULL)
      goto cleanup;

   pdp = (struct dri_display *) priv->driDisplay;
   psc->driScreen =
      CallCreateNewScreen(psc->base.dpy, screen, psc, pdp);
   if (psc->driScreen == NULL)
      goto cleanup;

   extensions = psc->core->getExtensions(psc->driScreen);
   driBindExtensions(psc, extensions);

   psc->base.vtable = &dri_screen_vtable;
   psp = &psc->vtable;
   psc->base.driScreen = psp;
   if (psc->driCopySubBuffer)
      psp->copySubBuffer = driCopySubBuffer;

   psp->destroyScreen = driDestroyScreen;
   psp->createDrawable = driCreateDrawable;
   psp->swapBuffers = driSwapBuffers;

   psp->setSwapInterval = driSetSwapInterval;
   psp->getSwapInterval = driGetSwapInterval;

   free(driverName);

   return &psc->base;

cleanup:
   CriticalErrorMessageF("failed to load driver: %s\n", driverName);

   free(driverName);

   if (psc->driver)
      dlclose(psc->driver);
   glx_screen_cleanup(&psc->base);
   free(psc);

   return NULL;
}

/* Called from __glXFreeDisplayPrivate.
 */
static void
driDestroyDisplay(__GLXDRIdisplay * dpy)
{
   free(dpy);
}

/*
 * Allocate, initialize and return a __DRIdisplayPrivate object.
 * This is called from __glXInitialize() when we are given a new
 * display pointer.
 */
_X_HIDDEN __GLXDRIdisplay *
driCreateDisplay(Display * dpy)
{
   struct dri_display *pdpyp;
   int eventBase, errorBase;
   int major, minor, patch;

   if (!XF86DRIQueryExtension(dpy, &eventBase, &errorBase)) {
      return NULL;
   }

   if (!XF86DRIQueryVersion(dpy, &major, &minor, &patch)) {
      return NULL;
   }

   pdpyp = malloc(sizeof *pdpyp);
   if (!pdpyp) {
      return NULL;
   }

   pdpyp->driMajor = major;
   pdpyp->driMinor = minor;
   pdpyp->driPatch = patch;

   pdpyp->base.destroyDisplay = driDestroyDisplay;
   pdpyp->base.createScreen = driCreateScreen;

   return &pdpyp->base;
}

#endif /* GLX_DIRECT_RENDERING */
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d43 1
a43 1
#include "dri_sarea.h"
d463 1
a463 2
   if (!configs || !visuals) {
       ErrorMessageF("No matching fbConfigs or visuals found\n");
a464 1
   }
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d43 1
a43 1
#include "sarea.h"
d463 2
a464 1
   if (!configs || !visuals)
d466 1
@


1.4
log
@Merge Mesa 9.2.0
@
text
@a92 2
static const struct glx_context_vtable dri_context_vtable;

d185 3
a187 3
   if (handle)
      return dlsym(handle, "__driConfigOptions");
   else
d189 11
d272 3
a274 2
   {__DRI_DAMAGE, __DRI_DAMAGE_VERSION},
   __glXReportDamage,
d301 3
a303 2
   {__DRI_GET_DRAWABLE_INFO, __DRI_GET_DRAWABLE_INFO_VERSION},
   __glXDRIGetDrawableInfo
d421 1
a421 1
      ErrorMessageF("XF86DRIGetDeviceInfo failed");
d432 1
a432 1
      ErrorMessageF("drmMap of framebuffer failed (%s)", strerror(-status));
d441 1
a441 1
      ErrorMessageF("drmMap of SAREA failed (%s)", strerror(-status));
d456 1
a456 1
      ErrorMessageF("Calling driver entry point failed");
d570 9
a578 9
   dri_destroy_context,
   dri_bind_context,
   dri_unbind_context,
   NULL,
   NULL,
   DRI_glXUseXFont,
   NULL,
   NULL,
   NULL, /* get_proc_address */
a749 1
   struct dri_screen *psc = (struct dri_screen *) pdraw->psc;
d751 7
a757 3
   if (psc->swapControl != NULL && pdraw != NULL) {
      psc->swapControl->setSwapInterval(pdp->driDrawable, interval);
      return 0;
a758 1

a765 1
   struct dri_screen *psc = (struct dri_screen *) pdraw->psc;
d767 2
a768 2
   if (psc->swapControl != NULL && pdraw != NULL)
      return psc->swapControl->getSwapInterval(pdp->driDrawable);
d770 3
d809 4
a812 2
   dri_create_context,
   NULL
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d97 1
a97 1
 * the DRI driver for the screen. (I.e. "r128", "tdfx", etc).
d139 1
a139 1
         Xfree(dev);
d166 1
a166 1
      Xfree(driverName);
d339 1
a339 1
   struct glx_config *visual;
d357 1
a357 1
   Xfree(BusID);                /* No longer needed */
d387 1
a387 1
   /* Get device name (like "tdfx") and the ddx version numbers.
d398 1
a398 1
   Xfree(driverName);           /* No longer needed. */
d449 10
a458 4
   psc->base.configs =
      driConvertConfigs(psc->core, psc->base.configs, driver_configs);
   psc->base.visuals =
      driConvertConfigs(psc->core, psc->base.visuals, driver_configs);
d480 1
a480 1
         XFree(visuals);
d487 5
d498 1
a498 2
   if (framebuffer.dev_priv != NULL)
      Xfree(framebuffer.dev_priv);
d518 1
a518 5
   if (context->xid)
      glx_send_destroy_context(psc->base.dpy, context->xid);

   if (context->extensions)
      XFree((char *) context->extensions);
d523 1
a523 1
   Xfree(pcp);
d584 4
d589 7
d600 1
a600 1
   pcp = Xmalloc(sizeof *pcp);
a603 1
   memset(pcp, 0, sizeof *pcp);
d605 1
a605 1
      Xfree(pcp);
d609 2
d614 1
a614 1
      Xfree(pcp);
d624 1
a624 1
      Xfree(pcp);
d641 1
a641 1
   Xfree(pdraw);
d659 1
a659 1
   pdp = Xmalloc(sizeof *pdp);
a662 1
   memset(pdp, 0, sizeof *pdp);
d668 1
a668 1
      Xfree(pdp);
d682 1
a682 1
      Xfree(pdp);
d693 1
a693 1
	       int64_t unused3)
d698 4
d708 1
a708 1
                 int x, int y, int width, int height)
d713 4
a734 55
#ifdef __DRI_SWAP_BUFFER_COUNTER

static int
driDrawableGetMSC(struct glx_screen *base, __GLXDRIdrawable *pdraw,
		   int64_t *ust, int64_t *msc, int64_t *sbc)
{
   struct dri_screen *psc = (struct dri_screen *) base;
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;

   if (pdp && psc->sbc && psc->msc)
      return ( (*psc->msc->getMSC)(psc->driScreen, msc) == 0 &&
	       (*psc->sbc->getSBC)(pdp->driDrawable, sbc) == 0 && 
	       __glXGetUST(ust) == 0 );
}

static int
driWaitForMSC(__GLXDRIdrawable *pdraw, int64_t target_msc, int64_t divisor,
	       int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc)
{
   struct dri_screen *psc = (struct dri_screen *) pdraw->psc;
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;

   if (pdp != NULL && psc->msc != NULL) {
      ret = (*psc->msc->waitForMSC) (pdp->driDrawable, target_msc,
				     divisor, remainder, msc, sbc);

      /* __glXGetUST returns zero on success and non-zero on failure.
       * This function returns True on success and False on failure.
       */
      return ret == 0 && __glXGetUST(ust) == 0;
   }
}

static int
driWaitForSBC(__GLXDRIdrawable *pdraw, int64_t target_sbc, int64_t *ust,
	       int64_t *msc, int64_t *sbc)
{
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;

   if (pdp != NULL && psc->sbc != NULL) {
      ret =
         (*psc->sbc->waitForSBC) (pdp->driDrawable, target_sbc, msc, sbc);

      /* __glXGetUST returns zero on success and non-zero on failure.
       * This function returns True on success and False on failure.
       */
      return ((ret == 0) && (__glXGetUST(ust) == 0));
   }

   return DRI2WaitSBC(pdp->base.psc->dpy,
		      pdp->base.xDrawable, target_sbc, ust, msc, sbc);
}

#endif

d794 2
a795 1
   dri_create_context
d808 1
a808 1
   psc = Xcalloc(1, sizeof *psc);
a811 1
   memset(psc, 0, sizeof *psc);
d813 1
a813 1
      Xfree(psc);
a821 1
   Xfree(driverName);
a859 6
#ifdef __DRI_SWAP_BUFFER_COUNTER
   psp->getDrawableMSC = driDrawableGetMSC;
   psp->waitForMSC = driWaitForMSC;
   psp->waitForSBC = driWaitForSBC;
#endif

d863 2
d868 4
d875 1
a875 1
   Xfree(psc);
d885 1
a885 1
   Xfree(dpy);
d908 1
a908 1
   pdpyp = Xmalloc(sizeof *pdpyp);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d506 2
d531 2
a549 2

   driReleaseDrawables(&pcp->base);
d561 1
d842 4
a845 2
   if (!glx_screen_init(&psc->base, screen, priv))
       return NULL;
d848 1
a848 2
      Xfree(psc);
      return NULL;
d853 2
a854 4
   if (psc->driver == NULL) {
      Xfree(psc);
      return NULL;
   }
d859 1
a859 2
      Xfree(psc);
      return NULL;
d869 2
a870 4
   if (psc->core == NULL || psc->legacy == NULL) {
      Xfree(psc);
      return NULL;
   }
d875 2
a876 5
   if (psc->driScreen == NULL) {
      dlclose(psc->driver);
      Xfree(psc);
      return NULL;
   }
d901 8
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d50 1
a50 4
typedef struct __GLXDRIdisplayPrivateRec __GLXDRIdisplayPrivate;
typedef struct __GLXDRIcontextPrivateRec __GLXDRIcontextPrivate;

struct __GLXDRIdisplayPrivateRec
d62 1
a62 1
struct __GLXDRIcontextPrivateRec
d64 18
a81 1
   __GLXDRIcontext base;
a83 1
   __GLXscreenConfigs *psc;
d86 9
d153 1
a153 1
PUBLIC const char *
d183 1
a183 1
PUBLIC const char *
d228 1
a228 1
   __GLXscreenConfigs *psc = glxDraw->psc;
d280 1
a280 1
   __GLXscreenConfigs *psc = glxDraw->psc;
d318 2
a319 2
CallCreateNewScreen(Display * dpy, int scrn, __GLXscreenConfigs * psc,
                    __GLXDRIdisplayPrivate * driDpy)
d339 1
a339 1
   __GLcontextModes *visual;
d449 4
a452 2
   psc->configs = driConvertConfigs(psc->core, psc->configs, driver_configs);
   psc->visuals = driConvertConfigs(psc->core, psc->visuals, driver_configs);
d460 1
a460 1
   for (visual = psc->visuals; visual; visual = visual->next) {
d501 1
a501 2
driDestroyContext(__GLXDRIcontext * context,
                  __GLXscreenConfigs * psc, Display * dpy)
d503 8
a510 1
   __GLXDRIcontextPrivate *pcp = (__GLXDRIcontextPrivate *) context;
d514 1
a514 1
   XF86DRIDestroyContext(psc->dpy, psc->scr, pcp->hwContextID);
d518 3
a520 3
static Bool
driBindContext(__GLXDRIcontext * context,
               __GLXDRIdrawable * draw, __GLXDRIdrawable * read)
d522 6
a527 2
   __GLXDRIcontextPrivate *pcp = (__GLXDRIcontextPrivate *) context;
   const __DRIcoreExtension *core = pcp->psc->core;
d529 8
a536 2
   return (*core->bindContext) (pcp->driContext,
                                draw->driDrawable, read->driDrawable);
d540 1
a540 1
driUnbindContext(__GLXDRIcontext * context)
d542 4
a545 2
   __GLXDRIcontextPrivate *pcp = (__GLXDRIcontextPrivate *) context;
   const __DRIcoreExtension *core = pcp->psc->core;
d547 1
a547 1
   (*core->unbindContext) (pcp->driContext);
d550 15
a564 4
static __GLXDRIcontext *
driCreateContext(__GLXscreenConfigs * psc,
                 const __GLcontextModes * mode,
                 GLXContext gc, GLXContext shareList, int renderType)
d566 2
a567 1
   __GLXDRIcontextPrivate *pcp, *pcp_shared;
d570 1
a570 1
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) mode;
d572 1
a572 1
   if (!psc || !psc->driScreen)
d576 1
a576 1
      pcp_shared = (__GLXDRIcontextPrivate *) shareList->driContext;
d584 8
a591 3
   pcp->psc = psc;
   if (!XF86DRICreateContextWithConfig(psc->dpy, psc->scr,
                                       mode->visualID,
d598 1
a598 1
      (*psc->legacy->createNewContext) (psc->__driScreen,
d602 1
a602 1
      XF86DRIDestroyContext(psc->dpy, psc->scr, pcp->hwContextID);
d607 1
a607 3
   pcp->base.destroyContext = driDestroyContext;
   pcp->base.bindContext = driBindContext;
   pcp->base.unbindContext = driUnbindContext;
d615 2
a616 1
   __GLXscreenConfigs *psc = pdraw->psc;
d618 2
a619 2
   (*psc->core->destroyDrawable) (pdraw->driDrawable);
   XF86DRIDestroyDrawable(psc->dpy, psc->scr, pdraw->drawable);
d624 1
a624 1
driCreateDrawable(__GLXscreenConfigs * psc,
d626 1
a626 1
                  GLXDrawable drawable, const __GLcontextModes * modes)
a627 1
   __GLXDRIdrawable *pdraw;
d630 3
a632 1
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) modes;
d638 2
a639 2
   pdraw = Xmalloc(sizeof(*pdraw));
   if (!pdraw)
d642 3
a644 2
   pdraw->drawable = drawable;
   pdraw->psc = psc;
d646 3
a648 2
   if (!XF86DRICreateDrawable(psc->dpy, psc->scr, drawable, &hwDrawable)) {
      Xfree(pdraw);
d653 2
a654 2
   pdraw->driDrawable =
      (*psc->legacy->createNewDrawable) (psc->__driScreen,
d658 1
a658 1
                                         empty_attribute_list, pdraw);
d660 3
a662 3
   if (!pdraw->driDrawable) {
      XF86DRIDestroyDrawable(psc->dpy, psc->scr, drawable);
      Xfree(pdraw);
d666 1
a666 1
   pdraw->destroyDrawable = driDestroyDrawable;
d668 1
a668 1
   return pdraw;
d675 4
a678 1
   (*pdraw->psc->core->swapBuffers) (pdraw->driDrawable);
d686 5
a690 2
   (*pdraw->psc->driCopySubBuffer->copySubBuffer) (pdraw->driDrawable,
                                                   x, y, width, height);
d694 1
a694 1
driDestroyScreen(__GLXscreenConfigs * psc)
d696 2
d699 4
a702 3
   if (psc->__driScreen)
      (*psc->core->destroyScreen) (psc->__driScreen);
   psc->__driScreen = NULL;
d707 57
a763 3
static __GLXDRIscreen *
driCreateScreen(__GLXscreenConfigs * psc, int screen,
                __GLXdisplayPrivate * priv)
d765 63
a827 1
   __GLXDRIdisplayPrivate *pdp;
d830 1
d834 2
a835 2
   psp = Xcalloc(1, sizeof *psp);
   if (psp == NULL)
d838 4
d843 1
a843 1
      Xfree(psp);
d850 1
a850 1
      Xfree(psp);
d857 1
a857 1
      Xfree(psp);
d869 1
a869 1
      Xfree(psp);
d873 4
a876 3
   pdp = (__GLXDRIdisplayPrivate *) priv->driDisplay;
   psc->__driScreen = CallCreateNewScreen(psc->dpy, screen, psc, pdp);
   if (psc->__driScreen == NULL) {
d878 1
a878 1
      Xfree(psp);
d882 2
a883 2
   driBindExtensions(psc);
   driBindCommonExtensions(psc);
d885 3
a891 1
   psp->createContext = driCreateContext;
a893 2
   psp->waitX = NULL;
   psp->waitGL = NULL;
d895 10
a904 1
   return psp;
d923 1
a923 1
   __GLXDRIdisplayPrivate *pdpyp;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d50 4
a53 1
struct dri_display
d65 1
a65 1
struct dri_screen
d67 1
a67 18
   struct glx_screen base;

   __DRIscreen *driScreen;
   __GLXDRIscreen vtable;
   const __DRIlegacyExtension *legacy;
   const __DRIcoreExtension *core;
   const __DRIswapControlExtension *swapControl;
   const __DRImediaStreamCounterExtension *msc;
   const __DRIconfig **driver_configs;
   const __DRIcopySubBufferExtension *driCopySubBuffer;

   void *driver;
   int fd;
};

struct dri_context
{
   struct glx_context base;
d70 1
a72 9
struct dri_drawable
{
   __GLXDRIdrawable base;

   __DRIdrawable *driDrawable;
};

static const struct glx_context_vtable dri_context_vtable;

d131 1
a131 1
_X_EXPORT const char *
d161 1
a161 1
_X_EXPORT const char *
d206 1
a206 1
   struct glx_screen *psc = glxDraw->psc;
d258 1
a258 1
   struct glx_screen *psc = glxDraw->psc;
d296 2
a297 2
CallCreateNewScreen(Display *dpy, int scrn, struct dri_screen *psc,
                    struct dri_display * driDpy)
d317 1
a317 1
   struct glx_config *visual;
d427 2
a428 4
   psc->base.configs =
      driConvertConfigs(psc->core, psc->base.configs, driver_configs);
   psc->base.visuals =
      driConvertConfigs(psc->core, psc->base.visuals, driver_configs);
d436 1
a436 1
   for (visual = psc->base.visuals; visual; visual = visual->next) {
d477 2
a478 1
dri_destroy_context(struct glx_context * context)
d480 1
a480 8
   struct dri_context *pcp = (struct dri_context *) context;
   struct dri_screen *psc = (struct dri_screen *) context->psc;

   if (context->xid)
      glx_send_destroy_context(psc->base.dpy, context->xid);

   if (context->extensions)
      XFree((char *) context->extensions);
d484 1
a484 1
   XF86DRIDestroyContext(psc->base.dpy, psc->base.scr, pcp->hwContextID);
d488 3
a490 3
static int
dri_bind_context(struct glx_context *context, struct glx_context *old,
		 GLXDrawable draw, GLXDrawable read)
d492 2
a493 6
   struct dri_context *pcp = (struct dri_context *) context;
   struct dri_screen *psc = (struct dri_screen *) pcp->base.psc;
   struct dri_drawable *pdraw, *pread;

   pdraw = (struct dri_drawable *) driFetchDrawable(context, draw);
   pread = (struct dri_drawable *) driFetchDrawable(context, read);
d495 2
a496 8
   if (pdraw == NULL || pread == NULL)
      return GLXBadDrawable;

   if ((*psc->core->bindContext) (pcp->driContext,
				  pdraw->driDrawable, pread->driDrawable))
      return Success;

   return GLXBadContext;
d500 1
a500 1
dri_unbind_context(struct glx_context *context, struct glx_context *new)
d502 2
a503 4
   struct dri_context *pcp = (struct dri_context *) context;
   struct dri_screen *psc = (struct dri_screen *) pcp->base.psc;

   (*psc->core->unbindContext) (pcp->driContext);
d505 1
a505 1
   driReleaseDrawables(&pcp->base);
d508 4
a511 15
static const struct glx_context_vtable dri_context_vtable = {
   dri_destroy_context,
   dri_bind_context,
   dri_unbind_context,
   NULL,
   NULL,
   DRI_glXUseXFont,
   NULL,
   NULL,
};

static struct glx_context *
dri_create_context(struct glx_screen *base,
		   struct glx_config *config_base,
		   struct glx_context *shareList, int renderType)
d513 1
a513 2
   struct dri_context *pcp, *pcp_shared;
   struct dri_screen *psc = (struct dri_screen *) base;
d516 1
a516 1
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
d518 1
a518 1
   if (!psc->base.driScreen)
d522 1
a522 1
      pcp_shared = (struct dri_context *) shareList;
d530 3
a532 8
   memset(pcp, 0, sizeof *pcp);
   if (!glx_context_init(&pcp->base, &psc->base, &config->base)) {
      Xfree(pcp);
      return NULL;
   }

   if (!XF86DRICreateContextWithConfig(psc->base.dpy, psc->base.scr,
                                       config->base.visualID,
d539 1
a539 1
      (*psc->legacy->createNewContext) (psc->driScreen,
d543 1
a543 1
      XF86DRIDestroyContext(psc->base.dpy, psc->base.scr, pcp->hwContextID);
d548 3
a550 1
   pcp->base.vtable = &dri_context_vtable;
d558 1
a558 2
   struct dri_screen *psc = (struct dri_screen *) pdraw->psc;
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;
d560 2
a561 2
   (*psc->core->destroyDrawable) (pdp->driDrawable);
   XF86DRIDestroyDrawable(psc->base.dpy, psc->base.scr, pdraw->drawable);
d566 1
a566 1
driCreateDrawable(struct glx_screen *base,
d568 1
a568 1
                  GLXDrawable drawable, struct glx_config *config_base)
d570 1
d573 1
a573 3
   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
   struct dri_screen *psc = (struct dri_screen *) base;
   struct dri_drawable *pdp;
d579 2
a580 2
   pdp = Xmalloc(sizeof *pdp);
   if (!pdp)
d583 2
a584 3
   memset(pdp, 0, sizeof *pdp);
   pdp->base.drawable = drawable;
   pdp->base.psc = &psc->base;
d586 2
a587 3
   if (!XF86DRICreateDrawable(psc->base.dpy, psc->base.scr,
			      drawable, &hwDrawable)) {
      Xfree(pdp);
d592 2
a593 2
   pdp->driDrawable =
      (*psc->legacy->createNewDrawable) (psc->driScreen,
d597 1
a597 1
                                         empty_attribute_list, pdp);
d599 3
a601 3
   if (!pdp->driDrawable) {
      XF86DRIDestroyDrawable(psc->base.dpy, psc->base.scr, drawable);
      Xfree(pdp);
d605 1
a605 1
   pdp->base.destroyDrawable = driDestroyDrawable;
d607 1
a607 1
   return &pdp->base;
d614 1
a614 4
   struct dri_screen *psc = (struct dri_screen *) pdraw->psc;
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;

   (*psc->core->swapBuffers) (pdp->driDrawable);
d622 2
a623 5
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;
   struct dri_screen *psc = (struct dri_screen *) pdp->base.psc;

   (*psc->driCopySubBuffer->copySubBuffer) (pdp->driDrawable,
					    x, y, width, height);
d627 1
a627 1
driDestroyScreen(struct glx_screen *base)
a628 2
   struct dri_screen *psc = (struct dri_screen *) base;

d630 3
a632 4
   if (psc->driScreen)
      (*psc->core->destroyScreen) (psc->driScreen);
   driDestroyConfigs(psc->driver_configs);
   psc->driScreen = NULL;
d637 3
a639 57
#ifdef __DRI_SWAP_BUFFER_COUNTER

static int
driDrawableGetMSC(struct glx_screen *base, __GLXDRIdrawable *pdraw,
		   int64_t *ust, int64_t *msc, int64_t *sbc)
{
   struct dri_screen *psc = (struct dri_screen *) base;
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;

   if (pdp && psc->sbc && psc->msc)
      return ( (*psc->msc->getMSC)(psc->driScreen, msc) == 0 &&
	       (*psc->sbc->getSBC)(pdp->driDrawable, sbc) == 0 && 
	       __glXGetUST(ust) == 0 );
}

static int
driWaitForMSC(__GLXDRIdrawable *pdraw, int64_t target_msc, int64_t divisor,
	       int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc)
{
   struct dri_screen *psc = (struct dri_screen *) pdraw->psc;
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;

   if (pdp != NULL && psc->msc != NULL) {
      ret = (*psc->msc->waitForMSC) (pdp->driDrawable, target_msc,
				     divisor, remainder, msc, sbc);

      /* __glXGetUST returns zero on success and non-zero on failure.
       * This function returns True on success and False on failure.
       */
      return ret == 0 && __glXGetUST(ust) == 0;
   }
}

static int
driWaitForSBC(__GLXDRIdrawable *pdraw, int64_t target_sbc, int64_t *ust,
	       int64_t *msc, int64_t *sbc)
{
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;

   if (pdp != NULL && psc->sbc != NULL) {
      ret =
         (*psc->sbc->waitForSBC) (pdp->driDrawable, target_sbc, msc, sbc);

      /* __glXGetUST returns zero on success and non-zero on failure.
       * This function returns True on success and False on failure.
       */
      return ((ret == 0) && (__glXGetUST(ust) == 0));
   }

   return DRI2WaitSBC(pdp->base.psc->dpy,
		      pdp->base.xDrawable, target_sbc, ust, msc, sbc);
}

#endif

static int
driSetSwapInterval(__GLXDRIdrawable *pdraw, int interval)
d641 1
a641 63
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;
   struct dri_screen *psc = (struct dri_screen *) pdraw->psc;

   if (psc->swapControl != NULL && pdraw != NULL) {
      psc->swapControl->setSwapInterval(pdp->driDrawable, interval);
      return 0;
   }

   return GLX_BAD_CONTEXT;
}

static int
driGetSwapInterval(__GLXDRIdrawable *pdraw)
{
   struct dri_drawable *pdp = (struct dri_drawable *) pdraw;
   struct dri_screen *psc = (struct dri_screen *) pdraw->psc;

   if (psc->swapControl != NULL && pdraw != NULL)
      return psc->swapControl->getSwapInterval(pdp->driDrawable);

   return 0;
}

/* Bind DRI1 specific extensions */
static void
driBindExtensions(struct dri_screen *psc, const __DRIextension **extensions)
{
   int i;

   for (i = 0; extensions[i]; i++) {
      /* No DRI2 support for swap_control at the moment, since SwapBuffers
       * is done by the X server */
      if (strcmp(extensions[i]->name, __DRI_SWAP_CONTROL) == 0) {
	 psc->swapControl = (__DRIswapControlExtension *) extensions[i];
	 __glXEnableDirectExtension(&psc->base, "GLX_SGI_swap_control");
	 __glXEnableDirectExtension(&psc->base, "GLX_MESA_swap_control");
      }

      if (strcmp(extensions[i]->name, __DRI_MEDIA_STREAM_COUNTER) == 0) {
         psc->msc = (__DRImediaStreamCounterExtension *) extensions[i];
         __glXEnableDirectExtension(&psc->base, "GLX_SGI_video_sync");
      }

      if (strcmp(extensions[i]->name, __DRI_COPY_SUB_BUFFER) == 0) {
	 psc->driCopySubBuffer = (__DRIcopySubBufferExtension *) extensions[i];
	 __glXEnableDirectExtension(&psc->base, "GLX_MESA_copy_sub_buffer");
      }

      if (strcmp(extensions[i]->name, __DRI_READ_DRAWABLE) == 0) {
	 __glXEnableDirectExtension(&psc->base, "GLX_SGI_make_current_read");
      }
      /* Ignore unknown extensions */
   }
}

static const struct glx_screen_vtable dri_screen_vtable = {
   dri_create_context
};

static struct glx_screen *
driCreateScreen(int screen, struct glx_display *priv)
{
   struct dri_display *pdp;
a643 1
   struct dri_screen *psc;
d647 2
a648 2
   psc = Xcalloc(1, sizeof *psc);
   if (psc == NULL)
a650 4
   memset(psc, 0, sizeof *psc);
   if (!glx_screen_init(&psc->base, screen, priv))
       return NULL;

d652 1
a652 1
      Xfree(psc);
d659 1
a659 1
      Xfree(psc);
d666 1
a666 1
      Xfree(psc);
d678 1
a678 1
      Xfree(psc);
d682 3
a684 4
   pdp = (struct dri_display *) priv->driDisplay;
   psc->driScreen =
      CallCreateNewScreen(psc->base.dpy, screen, psc, pdp);
   if (psc->driScreen == NULL) {
d686 1
a686 1
      Xfree(psc);
d690 2
a691 2
   extensions = psc->core->getExtensions(psc->driScreen);
   driBindExtensions(psc, extensions);
a692 3
   psc->base.vtable = &dri_screen_vtable;
   psp = &psc->vtable;
   psc->base.driScreen = psp;
d697 1
d700 2
d703 1
a703 10
#ifdef __DRI_SWAP_BUFFER_COUNTER
   psp->getDrawableMSC = driDrawableGetMSC;
   psp->waitForMSC = driWaitForMSC;
   psp->waitForSBC = driWaitForSBC;
#endif

   psp->setSwapInterval = driSetSwapInterval;
   psp->getSwapInterval = driGetSwapInterval;

   return &psc->base;
d722 1
a722 1
   struct dri_display *pdpyp;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d97 1
a97 1
 * the DRI driver for the screen (i.e., "i965", "radeon", "nouveau", etc).
d139 1
a139 1
         free(dev);
d166 1
a166 1
      free(driverName);
d339 1
a339 1
   struct glx_config *visual, *configs = NULL, *visuals = NULL;
d357 1
a357 1
   free(BusID);                /* No longer needed */
d387 1
a387 1
   /* Get device name (like "radeon") and the ddx version numbers.
d398 1
a398 1
   free(driverName);           /* No longer needed. */
d449 4
a452 10
   configs = driConvertConfigs(psc->core, psc->base.configs, driver_configs);
   visuals = driConvertConfigs(psc->core, psc->base.visuals, driver_configs);

   if (!configs || !visuals)
       goto handle_error;

   glx_config_destroy_list(psc->base.configs);
   psc->base.configs = configs;
   glx_config_destroy_list(psc->base.visuals);
   psc->base.visuals = visuals;
d474 1
a474 1
         free(visuals);
a480 5
   if (configs)
       glx_config_destroy_list(configs);
   if (visuals)
       glx_config_destroy_list(visuals);

d487 2
a488 1
   free(framebuffer.dev_priv);
d506 2
a507 1
   driReleaseDrawables(&pcp->base);
d509 2
a510 1
   free((char *) context->extensions);
d515 1
a515 1
   free(pcp);
a528 2
   driReleaseDrawables(&pcp->base);

d546 2
a558 1
   NULL, /* get_proc_address */
a574 4
   /* Check the renderType value */
   if (!validate_renderType_against_config(config_base, renderType))
       return NULL;

a575 7
      /* If the shareList context is not a DRI context, we cannot possibly
       * create a DRI context that shares it.
       */
      if (shareList->vtable->destroy != dri_destroy_context) {
	 return NULL;
      }

d580 1
a580 1
   pcp = calloc(1, sizeof *pcp);
d584 1
d586 1
a586 1
      free(pcp);
a589 2
   pcp->base.renderType = renderType;

d593 1
a593 1
      free(pcp);
d603 1
a603 1
      free(pcp);
d620 1
a620 1
   free(pdraw);
d638 1
a638 1
   pdp = calloc(1, sizeof *pdp);
d642 1
d648 1
a648 1
      free(pdp);
d662 1
a662 1
      free(pdp);
d673 1
a673 1
	       int64_t unused3, Bool flush)
a677 4
   if (flush) {
      glFlush();
   }

d684 1
a684 1
                 int x, int y, int width, int height, Bool flush)
a688 4
   if (flush) {
      glFlush();
   }

d707 55
d821 1
a821 2
   dri_create_context,
   NULL
d834 1
a834 1
   psc = calloc(1, sizeof *psc);
d838 3
a840 4
   if (!glx_screen_init(&psc->base, screen, priv)) {
      free(psc);
      return NULL;
   }
d843 2
a844 1
      goto cleanup;
d848 5
a852 2
   if (psc->driver == NULL)
      goto cleanup;
d857 2
a858 1
      goto cleanup;
d868 4
a871 2
   if (psc->core == NULL || psc->legacy == NULL)
      goto cleanup;
d876 5
a880 2
   if (psc->driScreen == NULL)
      goto cleanup;
d895 6
a903 2
   free(driverName);

a904 12

cleanup:
   CriticalErrorMessageF("failed to load driver: %s\n", driverName);

   free(driverName);

   if (psc->driver)
      dlclose(psc->driver);
   glx_screen_cleanup(&psc->base);
   free(psc);

   return NULL;
d912 1
a912 1
   free(dpy);
d935 1
a935 1
   pdpyp = malloc(sizeof *pdpyp);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d93 2
d187 3
a189 3
   const __DRIextension **extensions;

   if (!handle)
a190 11

   extensions = driGetDriverExtensions(handle, driverName);
   if (extensions) {
      for (int i = 0; extensions[i]; i++) {
         if (strcmp(extensions[i]->name, __DRI_CONFIG_OPTIONS) == 0)
            return ((__DRIconfigOptionsExtension *)extensions[i])->xml;
      }
   }

   /* Fall back to the old method */
   return dlsym(handle, "__driConfigOptions");
d263 2
a264 3
   .base = {__DRI_DAMAGE, 1 },

   .reportDamage        = __glXReportDamage,
d291 2
a292 3
   .base = {__DRI_GET_DRAWABLE_INFO, 1 },

   .getDrawableInfo     = __glXDRIGetDrawableInfo
d410 1
a410 1
      ErrorMessageF("XF86DRIGetDeviceInfo failed\n");
d421 1
a421 1
      ErrorMessageF("drmMap of framebuffer failed (%s)\n", strerror(-status));
d430 1
a430 1
      ErrorMessageF("drmMap of SAREA failed (%s)\n", strerror(-status));
d445 1
a445 1
      ErrorMessageF("Calling driver entry point failed\n");
d559 9
a567 9
   .destroy             = dri_destroy_context,
   .bind                = dri_bind_context,
   .unbind              = dri_unbind_context,
   .wait_gl             = NULL,
   .wait_x              = NULL,
   .use_x_font          = DRI_glXUseXFont,
   .bind_tex_image      = NULL,
   .release_tex_image   = NULL,
   .get_proc_address    = NULL,
d739 1
d741 4
a744 2
   if (pdraw != NULL) {
      struct dri_screen *psc = (struct dri_screen *) pdraw->psc;
a745 5
      if (psc->swapControl != NULL) {
         psc->swapControl->setSwapInterval(pdp->driDrawable, interval);
         return 0;
      }
   }
d753 1
d755 2
a756 2
   if (pdraw != NULL) {
      struct dri_screen *psc = (struct dri_screen *) pdraw->psc;
a757 3
      if (psc->swapControl != NULL)
         return psc->swapControl->getSwapInterval(pdp->driDrawable);
   }
d794 2
a795 4
   .create_context         = dri_create_context,
   .create_context_attribs = NULL,
   .query_renderer_integer = NULL,
   .query_renderer_string  = NULL,
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d43 1
a43 1
#include "dri_sarea.h"
d463 1
a463 2
   if (!configs || !visuals) {
       ErrorMessageF("No matching fbConfigs or visuals found\n");
a464 1
   }
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d43 1
a43 1
#include "sarea.h"
d463 2
a464 1
   if (!configs || !visuals)
d466 1
@


