head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.45;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.07.09.21.08.58;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.14.03.43;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.13;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.22.20.04.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.39;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.34;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.10.40;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.47.46;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

/**
 * \file glxext.c
 * GLX protocol interface boot-strap code.
 *
 * Direct rendering support added by Precision Insight, Inc.
 *
 * \author Kevin E. Martin <kevin@@precisioninsight.com>
 */

#include <assert.h>
#include "glxclient.h"
#include <X11/extensions/Xext.h>
#include <X11/extensions/extutil.h>
#ifdef GLX_USE_APPLEGL
#include "apple_glx.h"
#include "apple_visual.h"
#endif
#include "glxextensions.h"

#include <X11/Xlib-xcb.h>
#include <xcb/xcb.h>
#include <xcb/glx.h>


#ifdef DEBUG
void __glXDumpDrawBuffer(struct glx_context * ctx);
#endif

/*
** You can set this cell to 1 to force the gl drawing stuff to be
** one command per packet
*/
_X_HIDDEN int __glXDebug = 0;

/* Extension required boiler plate */

static const char __glXExtensionName[] = GLX_EXTENSION_NAME;
  static struct glx_display *glx_displays;

static /* const */ char *error_list[] = {
   "GLXBadContext",
   "GLXBadContextState",
   "GLXBadDrawable",
   "GLXBadPixmap",
   "GLXBadContextTag",
   "GLXBadCurrentWindow",
   "GLXBadRenderRequest",
   "GLXBadLargeRequest",
   "GLXUnsupportedPrivateRequest",
   "GLXBadFBConfig",
   "GLXBadPbuffer",
   "GLXBadCurrentDrawable",
   "GLXBadWindow",
   "GLXBadProfileARB",
};

#ifdef GLX_USE_APPLEGL
static char *__glXErrorString(Display *dpy, int code, XExtCodes *codes, 
                              char *buf, int n);
#endif

static
XEXT_GENERATE_ERROR_STRING(__glXErrorString, __glXExtensionName,
                           __GLX_NUMBER_ERRORS, error_list)

/*
 * GLX events are a bit funky.  We don't stuff the X event code into
 * our user exposed (via XNextEvent) structure.  Instead we use the GLX
 * private event code namespace (and hope it doesn't conflict).  Clients
 * have to know that bit 15 in the event type field means they're getting
 * a GLX event, and then handle the various sub-event types there, rather
 * than simply checking the event code and handling it directly.
 */

static Bool
__glXWireToEvent(Display *dpy, XEvent *event, xEvent *wire)
{
     struct glx_display *glx_dpy = __glXInitialize(dpy);

   if (glx_dpy == NULL)
      return False;

   switch ((wire->u.u.type & 0x7f) - glx_dpy->codes->first_event) {
   case GLX_PbufferClobber:
   {
      GLXPbufferClobberEvent *aevent = (GLXPbufferClobberEvent *)event;
      xGLXPbufferClobberEvent *awire = (xGLXPbufferClobberEvent *)wire;
      aevent->event_type = awire->type;
      aevent->serial = awire->sequenceNumber;
      aevent->event_type = awire->event_type;
      aevent->draw_type = awire->draw_type;
      aevent->drawable = awire->drawable;
      aevent->buffer_mask = awire->buffer_mask;
      aevent->aux_buffer = awire->aux_buffer;
      aevent->x = awire->x;
      aevent->y = awire->y;
      aevent->width = awire->width;
      aevent->height = awire->height;
      aevent->count = awire->count;
      return True;
   }
   case GLX_BufferSwapComplete:
   {
      GLXBufferSwapComplete *aevent = (GLXBufferSwapComplete *)event;
      xGLXBufferSwapComplete2 *awire = (xGLXBufferSwapComplete2 *)wire;
      struct glx_drawable *glxDraw = GetGLXDrawable(dpy, awire->drawable);

      if (!glxDraw)
	 return False;

      aevent->event_type = awire->event_type;
      aevent->drawable = glxDraw->xDrawable;
      aevent->ust = ((CARD64)awire->ust_hi << 32) | awire->ust_lo;
      aevent->msc = ((CARD64)awire->msc_hi << 32) | awire->msc_lo;

      if (awire->sbc < glxDraw->lastEventSbc)
	 glxDraw->eventSbcWrap += 0x100000000;
      glxDraw->lastEventSbc = awire->sbc;
      aevent->sbc = awire->sbc + glxDraw->eventSbcWrap;
      return True;
   }
   default:
      /* client doesn't support server event */
      break;
   }

   return False;
}

/* We don't actually support this.  It doesn't make sense for clients to
 * send each other GLX events.
 */
static Status
__glXEventToWire(Display *dpy, XEvent *event, xEvent *wire)
{
     struct glx_display *glx_dpy = __glXInitialize(dpy);

   if (glx_dpy == NULL)
      return False;

   switch (event->type) {
   case GLX_DAMAGED:
      break;
   case GLX_SAVED:
      break;
   case GLX_EXCHANGE_COMPLETE_INTEL:
      break;
   case GLX_COPY_COMPLETE_INTEL:
      break;
   case GLX_FLIP_COMPLETE_INTEL:
      break;
   default:
      /* client doesn't support server event */
      break;
   }

   return Success;
}

/************************************************************************/
/*
** Free the per screen configs data as well as the array of
** __glXScreenConfigs.
*/
static void
FreeScreenConfigs(struct glx_display * priv)
{
   struct glx_screen *psc;
   GLint i, screens;

   /* Free screen configuration information */
   screens = ScreenCount(priv->dpy);
   for (i = 0; i < screens; i++) {
      psc = priv->screens[i];
      glx_screen_cleanup(psc);

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
      if (psc->driScreen) {
         psc->driScreen->destroyScreen(psc);
      } else {
	 free(psc);
      }
#else
      free(psc);
#endif
   }
   free((char *) priv->screens);
   priv->screens = NULL;
}

static void
glx_display_free(struct glx_display *priv)
{
   struct glx_context *gc;

   gc = __glXGetCurrentContext();
   if (priv->dpy == gc->currentDpy) {
      gc->vtable->destroy(gc);
      __glXSetCurrentContextNull();
   }

   FreeScreenConfigs(priv);
   free((char *) priv->serverGLXvendor);
   free((char *) priv->serverGLXversion);

   __glxHashDestroy(priv->glXDrawHash);

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   __glxHashDestroy(priv->drawHash);

   /* Free the direct rendering per display data */
   if (priv->driswDisplay)
      (*priv->driswDisplay->destroyDisplay) (priv->driswDisplay);
   priv->driswDisplay = NULL;

   if (priv->driDisplay)
      (*priv->driDisplay->destroyDisplay) (priv->driDisplay);
   priv->driDisplay = NULL;

   if (priv->dri2Display)
      (*priv->dri2Display->destroyDisplay) (priv->dri2Display);
   priv->dri2Display = NULL;

   if (priv->dri3Display)
      (*priv->dri3Display->destroyDisplay) (priv->dri3Display);
   priv->dri3Display = NULL;
#endif

   free((char *) priv);
}

static int
__glXCloseDisplay(Display * dpy, XExtCodes * codes)
{
   struct glx_display *priv, **prev;

   _XLockMutex(_Xglobal_lock);
   prev = &glx_displays;
   for (priv = glx_displays; priv; prev = &priv->next, priv = priv->next) {
      if (priv->dpy == dpy) {
         *prev = priv->next;
	 break;
      }
   }
   _XUnlockMutex(_Xglobal_lock);

   if (priv != NULL)
      glx_display_free(priv);

   return 1;
}

/*
** Query the version of the GLX extension.  This procedure works even if
** the client extension is not completely set up.
*/
static Bool
QueryVersion(Display * dpy, int opcode, int *major, int *minor)
{
   xcb_connection_t *c = XGetXCBConnection(dpy);
   xcb_glx_query_version_reply_t *reply = xcb_glx_query_version_reply(c,
                                                                      xcb_glx_query_version
                                                                      (c,
                                                                       GLX_MAJOR_VERSION,
                                                                       GLX_MINOR_VERSION),
                                                                      NULL);

   if (!reply)
     return GL_FALSE;

   if (reply->major_version != GLX_MAJOR_VERSION) {
      free(reply);
      return GL_FALSE;
   }
   *major = reply->major_version;
   *minor = min(reply->minor_version, GLX_MINOR_VERSION);
   free(reply);
   return GL_TRUE;
}

/* 
 * We don't want to enable this GLX_OML_swap_method in glxext.h, 
 * because we can't support it.  The X server writes it out though,
 * so we should handle it somehow, to avoid false warnings.
 */
enum {
    IGNORE_GLX_SWAP_METHOD_OML = 0x8060
};


static GLint
convert_from_x_visual_type(int visualType)
{
   static const int glx_visual_types[] = {
      GLX_STATIC_GRAY, GLX_GRAY_SCALE,
      GLX_STATIC_COLOR, GLX_PSEUDO_COLOR,
      GLX_TRUE_COLOR, GLX_DIRECT_COLOR
   };

   if (visualType < ARRAY_SIZE(glx_visual_types))
      return glx_visual_types[visualType];

   return GLX_NONE;
}

/*
 * getVisualConfigs uses the !tagged_only path.
 * getFBConfigs uses the tagged_only path.
 */
_X_HIDDEN void
__glXInitializeVisualConfigFromTags(struct glx_config * config, int count,
                                    const INT32 * bp, Bool tagged_only,
                                    Bool fbconfig_style_tags)
{
   int i;
   GLint renderType = 0;

   if (!tagged_only) {
      /* Copy in the first set of properties */
      config->visualID = *bp++;

      config->visualType = convert_from_x_visual_type(*bp++);

      config->rgbMode = *bp++;

      config->redBits = *bp++;
      config->greenBits = *bp++;
      config->blueBits = *bp++;
      config->alphaBits = *bp++;
      config->accumRedBits = *bp++;
      config->accumGreenBits = *bp++;
      config->accumBlueBits = *bp++;
      config->accumAlphaBits = *bp++;

      config->doubleBufferMode = *bp++;
      config->stereoMode = *bp++;

      config->rgbBits = *bp++;
      config->depthBits = *bp++;
      config->stencilBits = *bp++;
      config->numAuxBuffers = *bp++;
      config->level = *bp++;

#ifdef GLX_USE_APPLEGL
       /* AppleSGLX supports pixmap and pbuffers with all config. */
       config->drawableType = GLX_WINDOW_BIT | GLX_PIXMAP_BIT | GLX_PBUFFER_BIT;
       /* Unfortunately this can create an ABI compatibility problem. */
       count -= 18;
#else
      count -= __GLX_MIN_CONFIG_PROPS;
#endif
   }

   config->sRGBCapable = GL_FALSE;

   /*
    ** Additional properties may be in a list at the end
    ** of the reply.  They are in pairs of property type
    ** and property value.
    */

#define FETCH_OR_SET(tag) \
    config-> tag = ( fbconfig_style_tags ) ? *bp++ : 1

   for (i = 0; i < count; i += 2) {
      long int tag = *bp++;
      
      switch (tag) {
      case GLX_RGBA:
         FETCH_OR_SET(rgbMode);
         break;
      case GLX_BUFFER_SIZE:
         config->rgbBits = *bp++;
         break;
      case GLX_LEVEL:
         config->level = *bp++;
         break;
      case GLX_DOUBLEBUFFER:
         FETCH_OR_SET(doubleBufferMode);
         break;
      case GLX_STEREO:
         FETCH_OR_SET(stereoMode);
         break;
      case GLX_AUX_BUFFERS:
         config->numAuxBuffers = *bp++;
         break;
      case GLX_RED_SIZE:
         config->redBits = *bp++;
         break;
      case GLX_GREEN_SIZE:
         config->greenBits = *bp++;
         break;
      case GLX_BLUE_SIZE:
         config->blueBits = *bp++;
         break;
      case GLX_ALPHA_SIZE:
         config->alphaBits = *bp++;
         break;
      case GLX_DEPTH_SIZE:
         config->depthBits = *bp++;
         break;
      case GLX_STENCIL_SIZE:
         config->stencilBits = *bp++;
         break;
      case GLX_ACCUM_RED_SIZE:
         config->accumRedBits = *bp++;
         break;
      case GLX_ACCUM_GREEN_SIZE:
         config->accumGreenBits = *bp++;
         break;
      case GLX_ACCUM_BLUE_SIZE:
         config->accumBlueBits = *bp++;
         break;
      case GLX_ACCUM_ALPHA_SIZE:
         config->accumAlphaBits = *bp++;
         break;
      case GLX_VISUAL_CAVEAT_EXT:
         config->visualRating = *bp++;
         break;
      case GLX_X_VISUAL_TYPE:
         config->visualType = *bp++;
         break;
      case GLX_TRANSPARENT_TYPE:
         config->transparentPixel = *bp++;
         break;
      case GLX_TRANSPARENT_INDEX_VALUE:
         config->transparentIndex = *bp++;
         break;
      case GLX_TRANSPARENT_RED_VALUE:
         config->transparentRed = *bp++;
         break;
      case GLX_TRANSPARENT_GREEN_VALUE:
         config->transparentGreen = *bp++;
         break;
      case GLX_TRANSPARENT_BLUE_VALUE:
         config->transparentBlue = *bp++;
         break;
      case GLX_TRANSPARENT_ALPHA_VALUE:
         config->transparentAlpha = *bp++;
         break;
      case GLX_VISUAL_ID:
         config->visualID = *bp++;
         break;
      case GLX_DRAWABLE_TYPE:
         config->drawableType = *bp++;
#ifdef GLX_USE_APPLEGL
         /* AppleSGLX supports pixmap and pbuffers with all config. */
         config->drawableType |= GLX_WINDOW_BIT | GLX_PIXMAP_BIT | GLX_PBUFFER_BIT;              
#endif
         break;
      case GLX_RENDER_TYPE: /* fbconfig render type bits */
         renderType = *bp++;
         break;
      case GLX_X_RENDERABLE:
         config->xRenderable = *bp++;
         break;
      case GLX_FBCONFIG_ID:
         config->fbconfigID = *bp++;
         break;
      case GLX_MAX_PBUFFER_WIDTH:
         config->maxPbufferWidth = *bp++;
         break;
      case GLX_MAX_PBUFFER_HEIGHT:
         config->maxPbufferHeight = *bp++;
         break;
      case GLX_MAX_PBUFFER_PIXELS:
         config->maxPbufferPixels = *bp++;
         break;
#ifndef GLX_USE_APPLEGL
      case GLX_OPTIMAL_PBUFFER_WIDTH_SGIX:
         config->optimalPbufferWidth = *bp++;
         break;
      case GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX:
         config->optimalPbufferHeight = *bp++;
         break;
      case GLX_VISUAL_SELECT_GROUP_SGIX:
         config->visualSelectGroup = *bp++;
         break;
      case GLX_SWAP_METHOD_OML:
         config->swapMethod = *bp++;
         break;
#endif
      case GLX_SAMPLE_BUFFERS_SGIS:
         config->sampleBuffers = *bp++;
         break;
      case GLX_SAMPLES_SGIS:
         config->samples = *bp++;
         break;
#ifdef GLX_USE_APPLEGL
      case IGNORE_GLX_SWAP_METHOD_OML:
         /* We ignore this tag.  See the comment above this function. */
         ++bp;
         break;
#else
      case GLX_BIND_TO_TEXTURE_RGB_EXT:
         config->bindToTextureRgb = *bp++;
         break;
      case GLX_BIND_TO_TEXTURE_RGBA_EXT:
         config->bindToTextureRgba = *bp++;
         break;
      case GLX_BIND_TO_MIPMAP_TEXTURE_EXT:
         config->bindToMipmapTexture = *bp++;
         break;
      case GLX_BIND_TO_TEXTURE_TARGETS_EXT:
         config->bindToTextureTargets = *bp++;
         break;
      case GLX_Y_INVERTED_EXT:
         config->yInverted = *bp++;
         break;
#endif
      case GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT:
         config->sRGBCapable = *bp++;
         break;

      case GLX_USE_GL:
         if (fbconfig_style_tags)
            bp++;
         break;
      case None:
         i = count;
         break;
      default:
         if(getenv("LIBGL_DIAGNOSTIC")) {
             long int tagvalue = *bp++;
             fprintf(stderr, "WARNING: unknown GLX tag from server: "
                     "tag 0x%lx value 0x%lx\n", tag, tagvalue);
         } else {
             /* Ignore the unrecognized tag's value */
             bp++;
         }
         break;
      }
   }

   if (renderType != 0 && renderType != GLX_DONT_CARE) {
      config->renderType = renderType;
      config->floatMode = (renderType &
         (GLX_RGBA_FLOAT_BIT_ARB|GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT)) != 0;
   } else {
      /* If there wasn't GLX_RENDER_TYPE property, set it based on
       * config->rgbMode.  The only way to communicate that the config is
       * floating-point is via GLX_RENDER_TYPE, so this cannot be a float
       * config.
       */
      config->renderType =
         (config->rgbMode) ? GLX_RGBA_BIT : GLX_COLOR_INDEX_BIT;
   }

   /* The GLX_ARB_fbconfig_float spec says:
    *
    *     "Note that floating point rendering is only supported for
    *     GLXPbuffer drawables."
    */
   if (config->floatMode)
      config->drawableType &= ~(GLX_WINDOW_BIT|GLX_PIXMAP_BIT);
}

static struct glx_config *
createConfigsFromProperties(Display * dpy, int nvisuals, int nprops,
                            int screen, GLboolean tagged_only)
{
   INT32 buf[__GLX_TOTAL_CONFIG], *props;
   unsigned prop_size;
   struct glx_config *modes, *m;
   int i;

   if (nprops == 0)
      return NULL;

   /* FIXME: Is the __GLX_MIN_CONFIG_PROPS test correct for FBconfigs? */

   /* Check number of properties */
   if (nprops < __GLX_MIN_CONFIG_PROPS || nprops > __GLX_MAX_CONFIG_PROPS)
      return NULL;

   /* Allocate memory for our config structure */
   modes = glx_config_create_list(nvisuals);
   if (!modes)
      return NULL;

   prop_size = nprops * __GLX_SIZE_INT32;
   if (prop_size <= sizeof(buf))
      props = buf;
   else
      props = malloc(prop_size);

   /* Read each config structure and convert it into our format */
   m = modes;
   for (i = 0; i < nvisuals; i++) {
      _XRead(dpy, (char *) props, prop_size);
#ifdef GLX_USE_APPLEGL
       /* Older X servers don't send this so we default it here. */
      m->drawableType = GLX_WINDOW_BIT;
#else
      /* 
       * The XQuartz 2.3.2.1 X server doesn't set this properly, so
       * set the proper bits here.
       * AppleSGLX supports windows, pixmaps, and pbuffers with all config.
       */
      m->drawableType = GLX_WINDOW_BIT | GLX_PIXMAP_BIT | GLX_PBUFFER_BIT;
#endif
       __glXInitializeVisualConfigFromTags(m, nprops, props,
                                          tagged_only, GL_TRUE);
      m->screen = screen;
      m = m->next;
   }

   if (props != buf)
      free(props);

   return modes;
}

static GLboolean
getVisualConfigs(struct glx_screen *psc,
		  struct glx_display *priv, int screen)
{
   xGLXGetVisualConfigsReq *req;
   xGLXGetVisualConfigsReply reply;
   Display *dpy = priv->dpy;

   LockDisplay(dpy);

   psc->visuals = NULL;
   GetReq(GLXGetVisualConfigs, req);
   req->reqType = priv->majorOpcode;
   req->glxCode = X_GLXGetVisualConfigs;
   req->screen = screen;

   if (!_XReply(dpy, (xReply *) & reply, 0, False))
      goto out;

   psc->visuals = createConfigsFromProperties(dpy,
                                              reply.numVisuals,
                                              reply.numProps,
                                              screen, GL_FALSE);

 out:
   UnlockDisplay(dpy);
   return psc->visuals != NULL;
}

static GLboolean
 getFBConfigs(struct glx_screen *psc, struct glx_display *priv, int screen)
{
   xGLXGetFBConfigsReq *fb_req;
   xGLXGetFBConfigsSGIXReq *sgi_req;
   xGLXVendorPrivateWithReplyReq *vpreq;
   xGLXGetFBConfigsReply reply;
   Display *dpy = priv->dpy;

   psc->serverGLXexts =
      __glXQueryServerString(dpy, priv->majorOpcode, screen, GLX_EXTENSIONS);

   if (psc->serverGLXexts == NULL) {
      return GL_FALSE;
   }

   LockDisplay(dpy);

   psc->configs = NULL;
   if (atof(priv->serverGLXversion) >= 1.3) {
      GetReq(GLXGetFBConfigs, fb_req);
      fb_req->reqType = priv->majorOpcode;
      fb_req->glxCode = X_GLXGetFBConfigs;
      fb_req->screen = screen;
   }
   else if (strstr(psc->serverGLXexts, "GLX_SGIX_fbconfig") != NULL) {
      GetReqExtra(GLXVendorPrivateWithReply,
                  sz_xGLXGetFBConfigsSGIXReq -
                  sz_xGLXVendorPrivateWithReplyReq, vpreq);
      sgi_req = (xGLXGetFBConfigsSGIXReq *) vpreq;
      sgi_req->reqType = priv->majorOpcode;
      sgi_req->glxCode = X_GLXVendorPrivateWithReply;
      sgi_req->vendorCode = X_GLXvop_GetFBConfigsSGIX;
      sgi_req->screen = screen;
   }
   else
      goto out;

   if (!_XReply(dpy, (xReply *) & reply, 0, False))
      goto out;

   psc->configs = createConfigsFromProperties(dpy,
                                              reply.numFBConfigs,
                                              reply.numAttribs * 2,
                                              screen, GL_TRUE);

 out:
   UnlockDisplay(dpy);
   return psc->configs != NULL;
}

_X_HIDDEN Bool
glx_screen_init(struct glx_screen *psc,
		 int screen, struct glx_display * priv)
{
   /* Initialize per screen dynamic client GLX extensions */
   psc->ext_list_first_time = GL_TRUE;
   psc->scr = screen;
   psc->dpy = priv->dpy;
   psc->display = priv;

   getVisualConfigs(psc, priv, screen);
   getFBConfigs(psc, priv, screen);

   return GL_TRUE;
}

_X_HIDDEN void
glx_screen_cleanup(struct glx_screen *psc)
{
   if (psc->configs) {
      glx_config_destroy_list(psc->configs);
      free(psc->effectiveGLXexts);
      psc->configs = NULL;   /* NOTE: just for paranoia */
   }
   if (psc->visuals) {
      glx_config_destroy_list(psc->visuals);
      psc->visuals = NULL;   /* NOTE: just for paranoia */
   }
   free((char *) psc->serverGLXexts);
}

/*
** Allocate the memory for the per screen configs for each screen.
** If that works then fetch the per screen configs data.
*/
static Bool
AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv)
{
   struct glx_screen *psc;
   GLint i, screens;

   /*
    ** First allocate memory for the array of per screen configs.
    */
   screens = ScreenCount(dpy);
   priv->screens = malloc(screens * sizeof *priv->screens);
   if (!priv->screens)
      return GL_FALSE;

   priv->serverGLXversion =
      __glXQueryServerString(dpy, priv->majorOpcode, 0, GLX_VERSION);
   if (priv->serverGLXversion == NULL) {
      FreeScreenConfigs(priv);
      return GL_FALSE;
   }

   for (i = 0; i < screens; i++, psc++) {
      psc = NULL;
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
#if defined(HAVE_DRI3)
      if (priv->dri3Display)
         psc = (*priv->dri3Display->createScreen) (i, priv);
#endif
      if (psc == NULL && priv->dri2Display)
	 psc = (*priv->dri2Display->createScreen) (i, priv);
      if (psc == NULL && priv->driDisplay)
	 psc = (*priv->driDisplay->createScreen) (i, priv);
      if (psc == NULL && priv->driswDisplay)
	 psc = (*priv->driswDisplay->createScreen) (i, priv);
#endif
#if defined(GLX_USE_APPLEGL)
      if (psc == NULL)
         psc = applegl_create_screen(i, priv);
#else
      if (psc == NULL)
	 psc = indirect_create_screen(i, priv);
#endif
      priv->screens[i] = psc;
   }
   SyncHandle();
   return GL_TRUE;
}

/*
** Initialize the client side extension code.
*/
 _X_HIDDEN struct glx_display *
__glXInitialize(Display * dpy)
{
   struct glx_display *dpyPriv, *d;
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   Bool glx_direct, glx_accel;
#endif
   int i;

   _XLockMutex(_Xglobal_lock);

   for (dpyPriv = glx_displays; dpyPriv; dpyPriv = dpyPriv->next) {
      if (dpyPriv->dpy == dpy) {
	 _XUnlockMutex(_Xglobal_lock);
	 return dpyPriv;
      }
   }

   /* Drop the lock while we create the display private. */
   _XUnlockMutex(_Xglobal_lock);

   dpyPriv = calloc(1, sizeof *dpyPriv);
   if (!dpyPriv)
      return NULL;

   dpyPriv->codes = XInitExtension(dpy, __glXExtensionName);
   if (!dpyPriv->codes) {
      free(dpyPriv);
      return NULL;
   }

   dpyPriv->dpy = dpy;
   dpyPriv->majorOpcode = dpyPriv->codes->major_opcode;
   dpyPriv->serverGLXvendor = 0x0;
   dpyPriv->serverGLXversion = 0x0;

   /* See if the versions are compatible.  This GLX implementation does not
    * work with servers that only support GLX 1.0.
    */
   if (!QueryVersion(dpy, dpyPriv->majorOpcode,
		     &dpyPriv->majorVersion, &dpyPriv->minorVersion)
       || (dpyPriv->majorVersion == 1 && dpyPriv->minorVersion < 1)) {
      free(dpyPriv);
      return NULL;
   }

   for (i = 0; i < __GLX_NUMBER_EVENTS; i++) {
      XESetWireToEvent(dpy, dpyPriv->codes->first_event + i, __glXWireToEvent);
      XESetEventToWire(dpy, dpyPriv->codes->first_event + i, __glXEventToWire);
   }

   XESetCloseDisplay(dpy, dpyPriv->codes->extension, __glXCloseDisplay);
   XESetErrorString (dpy, dpyPriv->codes->extension,__glXErrorString);

   dpyPriv->glXDrawHash = __glxHashCreate();

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   glx_direct = (getenv("LIBGL_ALWAYS_INDIRECT") == NULL);
   glx_accel = (getenv("LIBGL_ALWAYS_SOFTWARE") == NULL);

   dpyPriv->drawHash = __glxHashCreate();

   /*
    ** Initialize the direct rendering per display data and functions.
    ** Note: This _must_ be done before calling any other DRI routines
    ** (e.g., those called in AllocAndFetchScreenConfigs).
    */
   if (glx_direct && glx_accel) {
#if defined(HAVE_DRI3)
      if (!getenv("LIBGL_DRI3_DISABLE"))
         dpyPriv->dri3Display = dri3_create_display(dpy);
#endif
      dpyPriv->dri2Display = dri2CreateDisplay(dpy);
      dpyPriv->driDisplay = driCreateDisplay(dpy);
   }
   if (glx_direct)
      dpyPriv->driswDisplay = driswCreateDisplay(dpy);
#endif

#ifdef GLX_USE_APPLEGL
   if (!applegl_create_display(dpyPriv)) {
      free(dpyPriv);
      return NULL;
   }
#endif
   if (!AllocAndFetchScreenConfigs(dpy, dpyPriv)) {
      free(dpyPriv);
      return NULL;
   }

   __glX_send_client_info(dpyPriv);

   /* Grab the lock again and add the dispay private, unless somebody
    * beat us to initializing on this display in the meantime. */
   _XLockMutex(_Xglobal_lock);

   for (d = glx_displays; d; d = d->next) {
      if (d->dpy == dpy) {
	 _XUnlockMutex(_Xglobal_lock);
	 glx_display_free(dpyPriv);
	 return d;
      }
   }

   dpyPriv->next = glx_displays;
   glx_displays = dpyPriv;

   _XUnlockMutex(_Xglobal_lock);

   return dpyPriv;
}

/*
** Setup for sending a GLX command on dpy.  Make sure the extension is
** initialized.  Try to avoid calling __glXInitialize as its kinda slow.
*/
_X_HIDDEN CARD8
__glXSetupForCommand(Display * dpy)
{
    struct glx_context *gc;
    struct glx_display *priv;

   /* If this thread has a current context, flush its rendering commands */
   gc = __glXGetCurrentContext();
   if (gc->currentDpy) {
      /* Flush rendering buffer of the current context, if any */
      (void) __glXFlushRenderBuffer(gc, gc->pc);

      if (gc->currentDpy == dpy) {
         /* Use opcode from gc because its right */
         return gc->majorOpcode;
      }
      else {
         /*
          ** Have to get info about argument dpy because it might be to
          ** a different server
          */
      }
   }

   /* Forced to lookup extension via the slow initialize route */
   priv = __glXInitialize(dpy);
   if (!priv) {
      return 0;
   }
   return priv->majorOpcode;
}

/**
 * Flush the drawing command transport buffer.
 *
 * \param ctx  Context whose transport buffer is to be flushed.
 * \param pc   Pointer to first unused buffer location.
 *
 * \todo
 * Modify this function to use \c ctx->pc instead of the explicit
 * \c pc parameter.
 */
_X_HIDDEN GLubyte *
__glXFlushRenderBuffer(struct glx_context * ctx, GLubyte * pc)
{
   Display *const dpy = ctx->currentDpy;
   xcb_connection_t *c = XGetXCBConnection(dpy);
   const GLint size = pc - ctx->buf;

   if ((dpy != NULL) && (size > 0)) {
      xcb_glx_render(c, ctx->currentContextTag, size,
                     (const uint8_t *) ctx->buf);
   }

   /* Reset pointer and return it */
   ctx->pc = ctx->buf;
   return ctx->pc;
}


/**
 * Send a portion of a GLXRenderLarge command to the server.  The advantage of
 * this function over \c __glXSendLargeCommand is that callers can use the
 * data buffer in the GLX context and may be able to avoid allocating an
 * extra buffer.  The disadvantage is the clients will have to do more
 * GLX protocol work (i.e., calculating \c totalRequests, etc.).
 *
 * \sa __glXSendLargeCommand
 *
 * \param gc             GLX context
 * \param requestNumber  Which part of the whole command is this?  The first
 *                       request is 1.
 * \param totalRequests  How many requests will there be?
 * \param data           Command data.
 * \param dataLen        Size, in bytes, of the command data.
 */
_X_HIDDEN void
__glXSendLargeChunk(struct glx_context * gc, GLint requestNumber,
                    GLint totalRequests, const GLvoid * data, GLint dataLen)
{
   Display *dpy = gc->currentDpy;
   xcb_connection_t *c = XGetXCBConnection(dpy);
   xcb_glx_render_large(c, gc->currentContextTag, requestNumber,
                        totalRequests, dataLen, data);
}


/**
 * Send a command that is too large for the GLXRender protocol request.
 *
 * Send a large command, one that is too large for some reason to
 * send using the GLXRender protocol request.  One reason to send
 * a large command is to avoid copying the data.
 *
 * \param ctx        GLX context
 * \param header     Header data.
 * \param headerLen  Size, in bytes, of the header data.  It is assumed that
 *                   the header data will always be small enough to fit in
 *                   a single X protocol packet.
 * \param data       Command data.
 * \param dataLen    Size, in bytes, of the command data.
 */
_X_HIDDEN void
__glXSendLargeCommand(struct glx_context * ctx,
                      const GLvoid * header, GLint headerLen,
                      const GLvoid * data, GLint dataLen)
{
   GLint maxSize;
   GLint totalRequests, requestNumber;

   /*
    ** Calculate the maximum amount of data can be stuffed into a single
    ** packet.  sz_xGLXRenderReq is added because bufSize is the maximum
    ** packet size minus sz_xGLXRenderReq.
    */
   maxSize = (ctx->bufSize + sz_xGLXRenderReq) - sz_xGLXRenderLargeReq;
   totalRequests = 1 + (dataLen / maxSize);
   if (dataLen % maxSize)
      totalRequests++;

   /*
    ** Send all of the command, except the large array, as one request.
    */
   assert(headerLen <= maxSize);
   __glXSendLargeChunk(ctx, 1, totalRequests, header, headerLen);

   /*
    ** Send enough requests until the whole array is sent.
    */
   for (requestNumber = 2; requestNumber <= (totalRequests - 1);
        requestNumber++) {
      __glXSendLargeChunk(ctx, requestNumber, totalRequests, data, maxSize);
      data = (const GLvoid *) (((const GLubyte *) data) + maxSize);
      dataLen -= maxSize;
      assert(dataLen > 0);
   }

   assert(dataLen <= maxSize);
   __glXSendLargeChunk(ctx, requestNumber, totalRequests, data, dataLen);
}

/************************************************************************/

#ifdef DEBUG
_X_HIDDEN void
__glXDumpDrawBuffer(struct glx_context * ctx)
{
   GLubyte *p = ctx->buf;
   GLubyte *end = ctx->pc;
   GLushort opcode, length;

   while (p < end) {
      /* Fetch opcode */
      opcode = *((GLushort *) p);
      length = *((GLushort *) (p + 2));
      printf("%2x: %5d: ", opcode, length);
      length -= 4;
      p += 4;
      while (length > 0) {
         printf("%08x ", *((unsigned *) p));
         p += 4;
         length -= 4;
      }
      printf("\n");
   }
}
#endif
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d45 2
a46 2
#include "apple/apple_glx.h"
#include "apple/apple_visual.h"
a245 1
#if defined (GLX_USE_DRM)
d257 1
a257 2
#endif /* GLX_USE_DRM */
#endif /* GLX_DIRECT_RENDERING && !GLX_USE_APPLEGL */
a782 1
#if defined(GLX_USE_DRM)
d786 1
a786 1
#endif /* HAVE_DRI3 */
a790 1
#endif /* GLX_USE_DRM */
d793 1
a793 2
#endif /* GLX_DIRECT_RENDERING && !GLX_USE_APPLEGL */

a876 1
#if defined(GLX_USE_DRM)
d881 1
a881 1
#endif /* HAVE_DRI3 */
a884 1
#endif /* GLX_USE_DRM */
d887 1
a887 1
#endif /* GLX_DIRECT_RENDERING && !GLX_USE_APPLEGL */
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d45 2
a46 2
#include "apple_glx.h"
#include "apple_visual.h"
d246 1
d258 2
a259 1
#endif
d785 1
d789 1
a789 1
#endif
d794 1
d797 2
a798 1
#endif
d882 1
d887 1
a887 1
#endif
d891 1
d894 1
a894 1
#endif
@


1.5
log
@Merge Mesa 9.2.0
@
text
@d137 4
d142 1
a142 1
      aevent->drawable = awire->drawable;
a145 3
      if (!glxDraw)
	 return False;

d253 4
d277 2
a278 1
   glx_display_free(priv);
d685 4
d783 5
a787 1
      if (priv->dri2Display)
a837 1
      _XUnlockMutex(_Xglobal_lock);
a852 1
      _XUnlockMutex(_Xglobal_lock);
d878 4
d917 1
a917 1
    _XUnlockMutex(_Xglobal_lock);
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a49 1
#ifdef USE_XCB
a52 1
#endif
d84 1
d135 2
a136 1
      xGLXBufferSwapComplete *awire = (xGLXBufferSwapComplete *)wire;
d141 8
a148 1
      aevent->sbc = ((CARD64)awire->sbc_hi << 32) | awire->sbc_lo;
d210 1
a210 1
	 Xfree(psc);
d213 1
a213 1
      Xfree(psc);
d216 1
a216 1
   XFree((char *) priv->screens);
d232 4
a235 4
   if (priv->serverGLXvendor)
      Xfree((char *) priv->serverGLXvendor);
   if (priv->serverGLXversion)
      Xfree((char *) priv->serverGLXversion);
d254 1
a254 1
   Xfree((char *) priv);
a283 1
#ifdef USE_XCB
d292 3
a302 26
#else
   xGLXQueryVersionReq *req;
   xGLXQueryVersionReply reply;

   /* Send the glXQueryVersion request */
   LockDisplay(dpy);
   GetReq(GLXQueryVersion, req);
   req->reqType = opcode;
   req->glxCode = X_GLXQueryVersion;
   req->majorVersion = GLX_MAJOR_VERSION;
   req->minorVersion = GLX_MINOR_VERSION;
   _XReply(dpy, (xReply *) & reply, 0, False);
   UnlockDisplay(dpy);
   SyncHandle();

   if (reply.majorVersion != GLX_MAJOR_VERSION) {
      /*
       ** The server does not support the same major release as this
       ** client.
       */
      return GL_FALSE;
   }
   *major = reply.majorVersion;
   *minor = min(reply.minorVersion, GLX_MINOR_VERSION);
   return GL_TRUE;
#endif /* USE_XCB */
d340 1
d378 2
d475 2
a476 2
      case GLX_RENDER_TYPE:
         config->renderType = *bp++;
d559 21
a579 2
   config->renderType =
      (config->rgbMode) ? GLX_RGBA_BIT : GLX_COLOR_INDEX_BIT;
d609 1
a609 1
      props = Xmalloc(prop_size);
d633 1
a633 1
      Xfree(props);
d735 1
a735 2
      if (psc->effectiveGLXexts)
          Xfree(psc->effectiveGLXexts);
d742 1
a742 1
   Xfree((char *) psc->serverGLXexts);
d759 1
a759 1
   priv->screens = Xmalloc(screens * sizeof *priv->screens);
d817 1
a817 1
   dpyPriv = Xcalloc(1, sizeof *dpyPriv);
d823 1
a823 1
      Xfree(dpyPriv);
d833 3
a835 1
   /* See if the versions are compatible */
d837 3
a839 2
		     &dpyPriv->majorVersion, &dpyPriv->minorVersion)) {
      Xfree(dpyPriv);
d852 2
d875 1
a875 1
      Xfree(dpyPriv);
d880 1
a880 1
      Xfree(dpyPriv);
d884 1
a884 2
   if (dpyPriv->majorVersion == 1 && dpyPriv->minorVersion >= 1)
      __glXClientInfo(dpy, dpyPriv->majorOpcode);
a955 1
#ifdef USE_XCB
a956 3
#else
   xGLXRenderReq *req;
#endif /* USE_XCB */
a959 1
#ifdef USE_XCB
a961 12
#else
      /* Send the entire buffer as an X request */
      LockDisplay(dpy);
      GetReq(GLXRender, req);
      req->reqType = ctx->majorOpcode;
      req->glxCode = X_GLXRender;
      req->contextTag = ctx->currentContextTag;
      req->length += (size + 3) >> 2;
      _XSend(dpy, (char *) ctx->buf, size);
      UnlockDisplay(dpy);
      SyncHandle();
#endif
a990 1
#ifdef USE_XCB
a993 22
#else
   xGLXRenderLargeReq *req;

   if (requestNumber == 1) {
      LockDisplay(dpy);
   }

   GetReq(GLXRenderLarge, req);
   req->reqType = gc->majorOpcode;
   req->glxCode = X_GLXRenderLarge;
   req->contextTag = gc->currentContextTag;
   req->length += (dataLen + 3) >> 2;
   req->requestNumber = requestNumber;
   req->requestTotal = totalRequests;
   req->dataBytes = dataLen;
   Data(dpy, data, dataLen);

   if (requestNumber == totalRequests) {
      UnlockDisplay(dpy);
      SyncHandle();
   }
#endif /* USE_XCB */
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d197 1
a197 11
      if (psc->configs) {
	 glx_config_destroy_list(psc->configs);
         if (psc->effectiveGLXexts)
            Xfree(psc->effectiveGLXexts);
         psc->configs = NULL;   /* NOTE: just for paranoia */
      }
      if (psc->visuals) {
	 glx_config_destroy_list(psc->visuals);
	 psc->visuals = NULL;   /* NOTE: just for paranoia */
      }
      Xfree((char *) psc->serverGLXexts);
d549 4
d723 16
@


1.2
log
@Update to Mesa 7.8.2. Tested by johan@@. Thanks.
@
text
@a43 1
#include <X11/extensions/dri2proto.h>
a48 1
#include "glcontextmodes.h"
d58 1
a58 1
void __glXDumpDrawBuffer(__GLXcontext * ctx);
d69 2
a70 7
static char *__glXExtensionName = GLX_EXTENSION_NAME;
#ifdef GLX_USE_APPLEGL
static XExtensionInfo __glXExtensionInfo_data;
XExtensionInfo *__glXExtensionInfo = &__glXExtensionInfo_data;
#else
XExtensionInfo *__glXExtensionInfo = NULL;
#endif
a87 15
static int
__glXCloseDisplay(Display * dpy, XExtCodes * codes)
{
   GLXContext gc;

   gc = __glXGetCurrentContext();
   if (dpy == gc->currentDpy) {
      __glXSetCurrentContextNull();
      __glXFreeContext(gc);
   }

   return XextRemoveDisplay(__glXExtensionInfo, dpy);
}


a95 22
static Bool
__glXWireToEvent(Display *dpy, XEvent *event, xEvent *wire);
static Status
__glXEventToWire(Display *dpy, XEvent *event, xEvent *wire);

static /* const */ XExtensionHooks __glXExtensionHooks = {
  NULL,                   /* create_gc */
  NULL,                   /* copy_gc */
  NULL,                   /* flush_gc */
  NULL,                   /* free_gc */
  NULL,                   /* create_font */
  NULL,                   /* free_font */
  __glXCloseDisplay,      /* close_display */
  __glXWireToEvent,       /* wire_to_event */
  __glXEventToWire,       /* event_to_wire */
  NULL,                   /* error */
  __glXErrorString,       /* error_string */
};

XEXT_GENERATE_FIND_DISPLAY(__glXFindDisplay, __glXExtensionInfo,
                           __glXExtensionName, &__glXExtensionHooks,
                           __GLX_NUMBER_EVENTS, NULL)
d109 1
a109 1
   XExtDisplayInfo *info = __glXFindDisplay(dpy);
d111 2
a112 1
   XextCheckExtension(dpy, info, __glXExtensionName, False);
d114 1
a114 1
   switch ((wire->u.u.type & 0x7f) - info->codes->first_event) {
a132 10
   /* No easy symbol to test for this, as GLX_BufferSwapComplete is
    * defined in the local glx.h header, but the
    * xGLXBufferSwapComplete typedef is only available in new versions
    * of the external glxproto.h header, which doesn't have any
    * testable versioning define.
    *
    * I'll use the related DRI2 define, in the hope that we won't
    * receive these events unless we know how to ask for them:
    */
#ifdef X_DRI2SwapBuffers
a143 1
#endif
d158 1
a158 1
   XExtDisplayInfo *info = __glXFindDisplay(dpy);
d160 2
a161 1
   XextCheckExtension(dpy, info, __glXExtensionName, False);
d188 1
a188 1
FreeScreenConfigs(__GLXdisplayPrivate * priv)
d190 1
a190 1
   __GLXscreenConfigs *psc;
a193 1
   psc = priv->screenConfigs;
d195 2
a196 1
   for (i = 0; i < screens; i++, psc++) {
d198 1
a198 1
         _gl_context_modes_destroy(psc->configs);
d204 2
a205 2
         _gl_context_modes_destroy(psc->visuals);
         psc->visuals = NULL;   /* NOTE: just for paranoia */
a209 7
      if (psc->driver_configs) {
         unsigned int j;
         for (j = 0; psc->driver_configs[j]; j++)
            free((__DRIconfig *) psc->driver_configs[j]);
         free(psc->driver_configs);
         psc->driver_configs = NULL;
      }
d212 2
a213 3
         __glxHashDestroy(psc->drawHash);
         XFree(psc->driScreen);
         psc->driScreen = NULL;
d215 2
d219 2
a220 2
   XFree((char *) priv->screenConfigs);
   priv->screenConfigs = NULL;
d223 2
a224 6
/*
** Release the private memory referred to in a display private
** structure.  The caller will free the extension structure.
*/
static int
__glXFreeDisplayPrivate(XExtData * extension)
d226 7
a232 1
   __GLXdisplayPrivate *priv;
a233 1
   priv = (__GLXdisplayPrivate *) extension->private_data;
d235 1
a235 1
   if (priv->serverGLXvendor) {
d237 1
a237 3
      priv->serverGLXvendor = 0x0;      /* to protect against double free's */
   }
   if (priv->serverGLXversion) {
a238 2
      priv->serverGLXversion = 0x0;     /* to protect against double free's */
   }
d241 2
a257 1
   return 0;
d260 19
a278 1
/************************************************************************/
d342 15
d362 1
a362 1
__glXInitializeVisualConfigFromTags(__GLcontextModes * config, int count,
d372 1
a372 1
      config->visualType = _gl_convert_from_x_visual_type(*bp++);
a573 1
             break;
d575 1
a575 1
              break;
a580 7

   config->haveAccumBuffer = ((config->accumRedBits +
                               config->accumGreenBits +
                               config->accumBlueBits +
                               config->accumAlphaBits) > 0);
   config->haveDepthBuffer = (config->depthBits > 0);
   config->haveStencilBuffer = (config->stencilBits > 0);
d583 1
a583 1
static __GLcontextModes *
d589 1
a589 1
   __GLcontextModes *modes, *m;
d602 1
a602 1
   modes = _gl_context_modes_create(nvisuals, sizeof(__GLcontextModes));
d640 2
a641 1
getVisualConfigs(Display * dpy, __GLXdisplayPrivate * priv, int screen)
a643 1
   __GLXscreenConfigs *psc;
d645 1
a648 1
   psc = priv->screenConfigs + screen;
d669 1
a669 1
getFBConfigs(Display * dpy, __GLXdisplayPrivate * priv, int screen)
d675 1
a675 1
   __GLXscreenConfigs *psc;
a676 1
   psc = priv->screenConfigs + screen;
d691 1
a691 1
                  sz_xGLXGetFBConfigsSGIXReq +
d715 16
d736 1
a736 1
AllocAndFetchScreenConfigs(Display * dpy, __GLXdisplayPrivate * priv)
d738 1
a738 1
   __GLXscreenConfigs *psc;
d745 2
a746 2
   psc = (__GLXscreenConfigs *) Xmalloc(screens * sizeof(__GLXscreenConfigs));
   if (!psc) {
a747 3
   }
   memset(psc, 0, screens * sizeof(__GLXscreenConfigs));
   priv->screenConfigs = psc;
d757 1
a757 3
      getVisualConfigs(dpy, priv, i);
      getFBConfigs(dpy, priv, i);

a758 9
      psc->scr = i;
      psc->dpy = dpy;
      psc->drawHash = __glxHashCreate();
      if (psc->drawHash == NULL)
         continue;

      /* Initialize per screen dynamic client GLX extensions */
      psc->ext_list_first_time = GL_TRUE;

d760 12
a771 12
         psc->driScreen = (*priv->dri2Display->createScreen) (psc, i, priv);

      if (psc->driScreen == NULL && priv->driDisplay)
         psc->driScreen = (*priv->driDisplay->createScreen) (psc, i, priv);

      if (psc->driScreen == NULL && priv->driswDisplay)
         psc->driScreen = (*priv->driswDisplay->createScreen) (psc, i, priv);

      if (psc->driScreen == NULL) {
         __glxHashDestroy(psc->drawHash);
         psc->drawHash = NULL;
      }
d773 1
d782 1
a782 1
_X_HIDDEN __GLXdisplayPrivate *
d785 1
a785 5
   XExtDisplayInfo *info = __glXFindDisplay(dpy);
   XExtData **privList, *private, *found;
   __GLXdisplayPrivate *dpyPriv;
   XEDataObject dataObj;
   int major, minor;
d789 1
d791 1
a791 2
   /* The one and only long long lock */
   __glXLock();
d793 5
a797 5
   if (!XextHasExtension(info)) {
      /* No GLX extension supported by this server. Oh well. */
      __glXUnlock();
      XMissingExtension(dpy, __glXExtensionName);
      return 0;
d800 12
a811 7
   /* See if a display private already exists.  If so, return it */
   dataObj.display = dpy;
   privList = XEHeadOfExtensionList(dataObj);
   found = XFindOnExtensionList(privList, info->codes->extension);
   if (found) {
      __glXUnlock();
      return (__GLXdisplayPrivate *) found->private_data;
d814 5
d820 5
a824 4
   if (!QueryVersion(dpy, info->codes->major_opcode, &major, &minor)) {
      /* The client and server do not agree on versions.  Punt. */
      __glXUnlock();
      return 0;
d827 3
a829 7
   /*
    ** Allocate memory for all the pieces needed for this buffer.
    */
   private = (XExtData *) Xmalloc(sizeof(XExtData));
   if (!private) {
      __glXUnlock();
      return 0;
a830 15
   dpyPriv = (__GLXdisplayPrivate *) Xcalloc(1, sizeof(__GLXdisplayPrivate));
   if (!dpyPriv) {
      __glXUnlock();
      Xfree((char *) private);
      return 0;
   }

   /*
    ** Init the display private and then read in the screen config
    ** structures from the server.
    */
   dpyPriv->majorOpcode = info->codes->major_opcode;
   dpyPriv->majorVersion = major;
   dpyPriv->minorVersion = minor;
   dpyPriv->dpy = dpy;
d832 2
a833 2
   dpyPriv->serverGLXvendor = 0x0;
   dpyPriv->serverGLXversion = 0x0;
d839 2
d853 1
d855 5
a859 2
   if (apple_init_glx(dpy) || !AllocAndFetchScreenConfigs(dpy, dpyPriv)) {
#else
d861 2
a862 5
#endif
      __glXUnlock();
      Xfree((char *) dpyPriv);
      Xfree((char *) private);
      return 0;
d865 2
a866 10
   /*
    ** Fill in the private structure.  This is the actual structure that
    ** hangs off of the Display structure.  Our private structure is
    ** referred to by this structure.  Got that?
    */
   private->number = info->codes->extension;
   private->next = 0;
   private->free_private = __glXFreeDisplayPrivate;
   private->private_data = (char *) dpyPriv;
   XAddToExtensionList(privList, private);
d868 10
a877 2
   if (dpyPriv->majorVersion == 1 && dpyPriv->minorVersion >= 1) {
      __glXClientInfo(dpy, dpyPriv->majorOpcode);
d879 5
a883 1
   __glXUnlock();
d895 2
a896 2
   GLXContext gc;
   __GLXdisplayPrivate *priv;
d935 1
a935 1
__glXFlushRenderBuffer(__GLXcontext * ctx, GLubyte * pc)
d986 1
a986 1
__glXSendLargeChunk(__GLXcontext * gc, GLint requestNumber,
d1035 1
a1035 1
__glXSendLargeCommand(__GLXcontext * ctx,
d1077 1
a1077 1
__glXDumpDrawBuffer(__GLXcontext * ctx)
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d587 4
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d44 1
d50 1
d60 1
a60 1
void __glXDumpDrawBuffer(struct glx_context * ctx);
d71 7
a77 2
static const char __glXExtensionName[] = GLX_EXTENSION_NAME;
  static struct glx_display *glx_displays;
d95 15
d118 22
d153 1
a153 1
     struct glx_display *glx_dpy = __glXInitialize(dpy);
d155 1
a155 2
   if (glx_dpy == NULL)
      return False;
d157 1
a157 1
   switch ((wire->u.u.type & 0x7f) - glx_dpy->codes->first_event) {
d176 10
d197 1
d212 1
a212 1
     struct glx_display *glx_dpy = __glXInitialize(dpy);
d214 1
a214 2
   if (glx_dpy == NULL)
      return False;
d241 1
a241 1
FreeScreenConfigs(struct glx_display * priv)
d243 1
a243 1
   struct glx_screen *psc;
d247 1
d249 1
a249 2
   for (i = 0; i < screens; i++) {
      psc = priv->screens[i];
d251 1
a251 1
	 glx_config_destroy_list(psc->configs);
d257 2
a258 2
	 glx_config_destroy_list(psc->visuals);
	 psc->visuals = NULL;   /* NOTE: just for paranoia */
d263 7
d272 3
a274 2
      } else {
	 Xfree(psc);
a275 2
#else
      Xfree(psc);
d278 2
a279 2
   XFree((char *) priv->screens);
   priv->screens = NULL;
d282 6
a287 2
static void
glx_display_free(struct glx_display *priv)
d289 1
a289 7
   struct glx_context *gc;

   gc = __glXGetCurrentContext();
   if (priv->dpy == gc->currentDpy) {
      gc->vtable->destroy(gc);
      __glXSetCurrentContextNull();
   }
d291 1
d293 1
a293 1
   if (priv->serverGLXvendor)
d295 3
a297 1
   if (priv->serverGLXversion)
d299 2
a302 2
   __glxHashDestroy(priv->drawHash);

d318 1
d321 1
a321 19
static int
__glXCloseDisplay(Display * dpy, XExtCodes * codes)
{
   struct glx_display *priv, **prev;

   _XLockMutex(_Xglobal_lock);
   prev = &glx_displays;
   for (priv = glx_displays; priv; prev = &priv->next, priv = priv->next) {
      if (priv->dpy == dpy) {
         *prev = priv->next;
	 break;
      }
   }
   _XUnlockMutex(_Xglobal_lock);

   glx_display_free(priv);

   return 1;
}
a384 15
static GLint
convert_from_x_visual_type(int visualType)
{
   static const int glx_visual_types[] = {
      GLX_STATIC_GRAY, GLX_GRAY_SCALE,
      GLX_STATIC_COLOR, GLX_PSEUDO_COLOR,
      GLX_TRUE_COLOR, GLX_DIRECT_COLOR
   };

   if (visualType < ARRAY_SIZE(glx_visual_types))
      return glx_visual_types[visualType];

   return GLX_NONE;
}

d390 1
a390 1
__glXInitializeVisualConfigFromTags(struct glx_config * config, int count,
d400 1
a400 1
      config->visualType = convert_from_x_visual_type(*bp++);
a586 4
      case GLX_USE_GL:
         if (fbconfig_style_tags)
            bp++;
         break;
d598 1
d600 1
a600 1
         break;
d606 7
d615 1
a615 1
static struct glx_config *
d621 1
a621 1
   struct glx_config *modes, *m;
d634 1
a634 1
   modes = glx_config_create_list(nvisuals);
d672 1
a672 2
getVisualConfigs(struct glx_screen *psc,
		  struct glx_display *priv, int screen)
d675 1
a676 1
   Display *dpy = priv->dpy;
d680 1
d701 1
a701 1
 getFBConfigs(struct glx_screen *psc, struct glx_display *priv, int screen)
d707 1
a707 1
   Display *dpy = priv->dpy;
d709 1
d724 1
a724 1
                  sz_xGLXGetFBConfigsSGIXReq -
a747 16
_X_HIDDEN Bool
glx_screen_init(struct glx_screen *psc,
		 int screen, struct glx_display * priv)
{
   /* Initialize per screen dynamic client GLX extensions */
   psc->ext_list_first_time = GL_TRUE;
   psc->scr = screen;
   psc->dpy = priv->dpy;
   psc->display = priv;

   getVisualConfigs(psc, priv, screen);
   getFBConfigs(psc, priv, screen);

   return GL_TRUE;
}

d753 1
a753 1
AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv)
d755 1
a755 1
   struct glx_screen *psc;
d762 2
a763 2
   priv->screens = Xmalloc(screens * sizeof *priv->screens);
   if (!priv->screens)
d765 3
d777 3
a779 1
      psc = NULL;
d781 9
d791 12
a802 12
	 psc = (*priv->dri2Display->createScreen) (i, priv);
      if (psc == NULL && priv->driDisplay)
	 psc = (*priv->driDisplay->createScreen) (i, priv);
      if (psc == NULL && priv->driswDisplay)
	 psc = (*priv->driswDisplay->createScreen) (i, priv);
#endif
#if defined(GLX_USE_APPLEGL)
      if (psc == NULL)
         psc = applegl_create_screen(i, priv);
#else
      if (psc == NULL)
	 psc = indirect_create_screen(i, priv);
a803 1
      priv->screens[i] = psc;
d812 1
a812 1
 _X_HIDDEN struct glx_display *
d815 5
a819 1
   struct glx_display *dpyPriv, *d;
a822 1
   int i;
d824 2
a825 1
   _XLockMutex(_Xglobal_lock);
d827 5
a831 5
   for (dpyPriv = glx_displays; dpyPriv; dpyPriv = dpyPriv->next) {
      if (dpyPriv->dpy == dpy) {
	 _XUnlockMutex(_Xglobal_lock);
	 return dpyPriv;
      }
d834 8
a841 2
   /* Drop the lock while we create the display private. */
   _XUnlockMutex(_Xglobal_lock);
d843 6
a848 3
   dpyPriv = Xcalloc(1, sizeof *dpyPriv);
   if (!dpyPriv)
      return NULL;
d850 13
a862 5
   dpyPriv->codes = XInitExtension(dpy, __glXExtensionName);
   if (!dpyPriv->codes) {
      Xfree(dpyPriv);
      _XUnlockMutex(_Xglobal_lock);
      return NULL;
d865 7
d873 1
a873 1
   dpyPriv->majorOpcode = dpyPriv->codes->major_opcode;
a876 16
   /* See if the versions are compatible */
   if (!QueryVersion(dpy, dpyPriv->majorOpcode,
		     &dpyPriv->majorVersion, &dpyPriv->minorVersion)) {
      Xfree(dpyPriv);
      _XUnlockMutex(_Xglobal_lock);
      return NULL;
   }

   for (i = 0; i < __GLX_NUMBER_EVENTS; i++) {
      XESetWireToEvent(dpy, dpyPriv->codes->first_event + i, __glXWireToEvent);
      XESetEventToWire(dpy, dpyPriv->codes->first_event + i, __glXEventToWire);
   }

   XESetCloseDisplay(dpy, dpyPriv->codes->extension, __glXCloseDisplay);
   XESetErrorString (dpy, dpyPriv->codes->extension,__glXErrorString);

a880 2
   dpyPriv->drawHash = __glxHashCreate();

a892 1

d894 3
a896 4
   if (!applegl_create_display(dpyPriv)) {
      Xfree(dpyPriv);
      return NULL;
   }
d898 4
a901 3
   if (!AllocAndFetchScreenConfigs(dpy, dpyPriv)) {
      Xfree(dpyPriv);
      return NULL;
d904 12
a915 1
   if (dpyPriv->majorVersion == 1 && dpyPriv->minorVersion >= 1)
a916 11

   /* Grab the lock again and add the dispay private, unless somebody
    * beat us to initializing on this display in the meantime. */
   _XLockMutex(_Xglobal_lock);

   for (d = glx_displays; d; d = d->next) {
      if (d->dpy == dpy) {
	 _XUnlockMutex(_Xglobal_lock);
	 glx_display_free(dpyPriv);
	 return d;
      }
d918 1
a918 5

   dpyPriv->next = glx_displays;
   glx_displays = dpyPriv;

    _XUnlockMutex(_Xglobal_lock);
d930 2
a931 2
    struct glx_context *gc;
    struct glx_display *priv;
d970 1
a970 1
__glXFlushRenderBuffer(struct glx_context * ctx, GLubyte * pc)
d1021 1
a1021 1
__glXSendLargeChunk(struct glx_context * gc, GLint requestNumber,
d1070 1
a1070 1
__glXSendLargeCommand(struct glx_context * ctx,
d1112 1
a1112 1
__glXDumpDrawBuffer(struct glx_context * ctx)
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d50 1
d54 1
a85 1
   "GLXBadProfileARB",
d136 1
a136 2
      xGLXBufferSwapComplete2 *awire = (xGLXBufferSwapComplete2 *)wire;
      struct glx_drawable *glxDraw = GetGLXDrawable(dpy, awire->drawable);
d141 1
a141 8

      if (!glxDraw)
	 return False;

      if (awire->sbc < glxDraw->lastEventSbc)
	 glxDraw->eventSbcWrap += 0x100000000;
      glxDraw->lastEventSbc = awire->sbc;
      aevent->sbc = awire->sbc + glxDraw->eventSbcWrap;
d197 11
a207 1
      glx_screen_cleanup(psc);
d213 1
a213 1
	 free(psc);
d216 1
a216 1
      free(psc);
d219 1
a219 1
   free((char *) priv->screens);
d235 4
a238 4
   free((char *) priv->serverGLXvendor);
   free((char *) priv->serverGLXversion);

   __glxHashDestroy(priv->glXDrawHash);
d257 1
a257 1
   free((char *) priv);
d287 1
a295 3
   if (!reply)
     return GL_FALSE;

d304 26
a366 1
   GLint renderType = 0;
a403 2
   config->sRGBCapable = GL_FALSE;

d499 2
a500 2
      case GLX_RENDER_TYPE: /* fbconfig render type bits */
         renderType = *bp++;
a558 4
      case GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT:
         config->sRGBCapable = *bp++;
         break;

d579 2
a580 21
   if (renderType != 0 && renderType != GLX_DONT_CARE) {
      config->renderType = renderType;
      config->floatMode = (renderType &
         (GLX_RGBA_FLOAT_BIT_ARB|GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT)) != 0;
   } else {
      /* If there wasn't GLX_RENDER_TYPE property, set it based on
       * config->rgbMode.  The only way to communicate that the config is
       * floating-point is via GLX_RENDER_TYPE, so this cannot be a float
       * config.
       */
      config->renderType =
         (config->rgbMode) ? GLX_RGBA_BIT : GLX_COLOR_INDEX_BIT;
   }

   /* The GLX_ARB_fbconfig_float spec says:
    *
    *     "Note that floating point rendering is only supported for
    *     GLXPbuffer drawables."
    */
   if (config->floatMode)
      config->drawableType &= ~(GLX_WINDOW_BIT|GLX_PIXMAP_BIT);
d610 1
a610 1
      props = malloc(prop_size);
d634 1
a634 1
      free(props);
a730 15
_X_HIDDEN void
glx_screen_cleanup(struct glx_screen *psc)
{
   if (psc->configs) {
      glx_config_destroy_list(psc->configs);
      free(psc->effectiveGLXexts);
      psc->configs = NULL;   /* NOTE: just for paranoia */
   }
   if (psc->visuals) {
      glx_config_destroy_list(psc->visuals);
      psc->visuals = NULL;   /* NOTE: just for paranoia */
   }
   free((char *) psc->serverGLXexts);
}

d745 1
a745 1
   priv->screens = malloc(screens * sizeof *priv->screens);
d803 1
a803 1
   dpyPriv = calloc(1, sizeof *dpyPriv);
d809 1
a809 1
      free(dpyPriv);
d819 1
a819 3
   /* See if the versions are compatible.  This GLX implementation does not
    * work with servers that only support GLX 1.0.
    */
d821 2
a822 3
		     &dpyPriv->majorVersion, &dpyPriv->minorVersion)
       || (dpyPriv->majorVersion == 1 && dpyPriv->minorVersion < 1)) {
      free(dpyPriv);
a834 2
   dpyPriv->glXDrawHash = __glxHashCreate();

d856 1
a856 1
      free(dpyPriv);
d861 1
a861 1
      free(dpyPriv);
d865 2
a866 1
   __glX_send_client_info(dpyPriv);
d938 1
d940 3
d946 1
d949 12
d990 1
d994 22
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d137 4
a144 5
      aevent->event_type = awire->event_type;
      aevent->drawable = glxDraw->xDrawable;
      aevent->ust = ((CARD64)awire->ust_hi << 32) | awire->ust_lo;
      aevent->msc = ((CARD64)awire->msc_hi << 32) | awire->msc_lo;

a251 4

   if (priv->dri3Display)
      (*priv->dri3Display->destroyDisplay) (priv->dri3Display);
   priv->dri3Display = NULL;
d272 1
a272 2
   if (priv != NULL)
      glx_display_free(priv);
a678 4
   if (psc->serverGLXexts == NULL) {
      return GL_FALSE;
   }

d773 1
a773 5
#if defined(HAVE_DRI3)
      if (priv->dri3Display)
         psc = (*priv->dri3Display->createScreen) (i, priv);
#endif
      if (psc == NULL && priv->dri2Display)
d824 1
d840 1
a865 4
#if defined(HAVE_DRI3)
      if (!getenv("LIBGL_DRI3_DISABLE"))
         dpyPriv->dri3Display = dri3_create_display(dpy);
#endif
d901 1
a901 1
   _XUnlockMutex(_Xglobal_lock);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d45 2
a46 2
#include "apple/apple_glx.h"
#include "apple/apple_visual.h"
a245 1
#if defined (GLX_USE_DRM)
d257 1
a257 2
#endif /* GLX_USE_DRM */
#endif /* GLX_DIRECT_RENDERING && !GLX_USE_APPLEGL */
a782 1
#if defined(GLX_USE_DRM)
d786 1
a786 1
#endif /* HAVE_DRI3 */
a790 1
#endif /* GLX_USE_DRM */
d793 1
a793 2
#endif /* GLX_DIRECT_RENDERING && !GLX_USE_APPLEGL */

a876 1
#if defined(GLX_USE_DRM)
d881 1
a881 1
#endif /* HAVE_DRI3 */
a884 1
#endif /* GLX_USE_DRM */
d887 1
a887 1
#endif /* GLX_DIRECT_RENDERING && !GLX_USE_APPLEGL */
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d45 2
a46 2
#include "apple_glx.h"
#include "apple_visual.h"
d246 1
d258 2
a259 1
#endif
d785 1
d789 1
a789 1
#endif
d794 1
d797 2
a798 1
#endif
d882 1
d887 1
a887 1
#endif
d891 1
d894 1
a894 1
#endif
@


