head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.45;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.57;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.07.09.21.08.58;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2014.01.19.03.13.15;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.09.05.14.03.43;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.13;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.38;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.14.38;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.01.19.03.04.13;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.34;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.10.40;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.47.45;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

/**
 * \file glxcmds.c
 * Client-side GLX interface.
 */

#include "glxclient.h"
#include "glapi.h"
#include "glxextensions.h"
#include "indirect.h"
#include "glx_error.h"

#ifdef GLX_DIRECT_RENDERING
#ifdef GLX_USE_APPLEGL
#include "apple_glx_context.h"
#include "apple_glx.h"
#else
#include <sys/time.h>
#ifdef XF86VIDMODE
#include <X11/extensions/xf86vmode.h>
#endif
#endif
#endif

#include <X11/Xlib-xcb.h>
#include <xcb/xcb.h>
#include <xcb/glx.h>

static const char __glXGLXClientVendorName[] = "Mesa Project and SGI";
static const char __glXGLXClientVersion[] = "1.4";

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)

/**
 * Get the __DRIdrawable for the drawable associated with a GLXContext
 *
 * \param dpy       The display associated with \c drawable.
 * \param drawable  GLXDrawable whose __DRIdrawable part is to be retrieved.
 * \param scrn_num  If non-NULL, the drawables screen is stored there
 * \returns  A pointer to the context's __DRIdrawable on success, or NULL if
 *           the drawable is not associated with a direct-rendering context.
 */
_X_HIDDEN __GLXDRIdrawable *
GetGLXDRIDrawable(Display * dpy, GLXDrawable drawable)
{
   struct glx_display *priv = __glXInitialize(dpy);
   __GLXDRIdrawable *pdraw;

   if (priv == NULL)
      return NULL;

   if (__glxHashLookup(priv->drawHash, drawable, (void *) &pdraw) == 0)
      return pdraw;

   return NULL;
}

#endif

_X_HIDDEN struct glx_drawable *
GetGLXDrawable(Display *dpy, GLXDrawable drawable)
{
   struct glx_display *priv = __glXInitialize(dpy);
   struct glx_drawable *glxDraw;

   if (priv == NULL)
      return NULL;

   if (__glxHashLookup(priv->glXDrawHash, drawable, (void *) &glxDraw) == 0)
      return glxDraw;

   return NULL;
}

_X_HIDDEN int
InitGLXDrawable(Display *dpy, struct glx_drawable *glxDraw, XID xDrawable,
		GLXDrawable drawable)
{
   struct glx_display *priv = __glXInitialize(dpy);

   if (!priv)
      return -1;

   glxDraw->xDrawable = xDrawable;
   glxDraw->drawable = drawable;
   glxDraw->lastEventSbc = 0;
   glxDraw->eventSbcWrap = 0;

   return __glxHashInsert(priv->glXDrawHash, drawable, glxDraw);
}

_X_HIDDEN void
DestroyGLXDrawable(Display *dpy, GLXDrawable drawable)
{
   struct glx_display *priv = __glXInitialize(dpy);
   struct glx_drawable *glxDraw;

   if (!priv)
      return;

   glxDraw = GetGLXDrawable(dpy, drawable);
   __glxHashDelete(priv->glXDrawHash, drawable);
   free(glxDraw);
}

/**
 * Get the GLX per-screen data structure associated with a GLX context.
 *
 * \param dpy   Display for which the GLX per-screen information is to be
 *              retrieved.
 * \param scrn  Screen on \c dpy for which the GLX per-screen information is
 *              to be retrieved.
 * \returns A pointer to the GLX per-screen data if \c dpy and \c scrn
 *          specify a valid GLX screen, or NULL otherwise.
 *
 * \todo Should this function validate that \c scrn is within the screen
 *       number range for \c dpy?
 */

_X_HIDDEN struct glx_screen *
GetGLXScreenConfigs(Display * dpy, int scrn)
{
   struct glx_display *const priv = __glXInitialize(dpy);

   return (priv
           && priv->screens !=
           NULL) ? priv->screens[scrn] : NULL;
}


static int
GetGLXPrivScreenConfig(Display * dpy, int scrn, struct glx_display ** ppriv,
                       struct glx_screen ** ppsc)
{
   /* Initialize the extension, if needed .  This has the added value
    * of initializing/allocating the display private
    */

   if (dpy == NULL) {
      return GLX_NO_EXTENSION;
   }

   *ppriv = __glXInitialize(dpy);
   if (*ppriv == NULL) {
      return GLX_NO_EXTENSION;
   }

   /* Check screen number to see if its valid */
   if ((scrn < 0) || (scrn >= ScreenCount(dpy))) {
      return GLX_BAD_SCREEN;
   }

   /* Check to see if the GL is supported on this screen */
   *ppsc = (*ppriv)->screens[scrn];
   if ((*ppsc)->configs == NULL && (*ppsc)->visuals == NULL) {
      /* No support for GL on this screen regardless of visual */
      return GLX_BAD_VISUAL;
   }

   return Success;
}


/**
 * Determine if a \c GLXFBConfig supplied by the application is valid.
 *
 * \param dpy     Application supplied \c Display pointer.
 * \param config  Application supplied \c GLXFBConfig.
 *
 * \returns If the \c GLXFBConfig is valid, the a pointer to the matching
 *          \c struct glx_config structure is returned.  Otherwise, \c NULL
 *          is returned.
 */
static struct glx_config *
ValidateGLXFBConfig(Display * dpy, GLXFBConfig fbconfig)
{
   struct glx_display *const priv = __glXInitialize(dpy);
   int num_screens = ScreenCount(dpy);
   unsigned i;
   struct glx_config *config;

   if (priv != NULL) {
      for (i = 0; i < num_screens; i++) {
	 for (config = priv->screens[i]->configs; config != NULL;
	      config = config->next) {
	    if (config == (struct glx_config *) fbconfig) {
	       return config;
	    }
	 }
      }
   }

   return NULL;
}

/**
 * Verifies context's GLX_RENDER_TYPE value with config.
 *
 * \param config GLX FBConfig which will support the returned renderType.
 * \param renderType The context render type to be verified.
 * \return True if the value of context renderType was approved, or 0 if no
 * valid value was found.
 */
Bool
validate_renderType_against_config(const struct glx_config *config,
                                   int renderType)
{
    switch (renderType) {
    case GLX_RGBA_TYPE:
        return (config->renderType & GLX_RGBA_BIT) != 0;
    case GLX_COLOR_INDEX_TYPE:
        return (config->renderType & GLX_COLOR_INDEX_BIT) != 0;
    case GLX_RGBA_FLOAT_TYPE_ARB:
        return (config->renderType & GLX_RGBA_FLOAT_BIT_ARB) != 0;
    case GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT:
        return (config->renderType & GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT) != 0;
    default:
        break;
    }
    return 0;
}

_X_HIDDEN Bool
glx_context_init(struct glx_context *gc,
		 struct glx_screen *psc, struct glx_config *config)
{
   gc->majorOpcode = __glXSetupForCommand(psc->display->dpy);
   if (!gc->majorOpcode)
      return False;

   gc->screen = psc->scr;
   gc->psc = psc;
   gc->config = config;
   gc->isDirect = GL_TRUE;
   gc->currentContextTag = -1;

   return True;
}


/**
 * Create a new context.
 *
 * \param renderType   For FBConfigs, what is the rendering type?
 */

static GLXContext
CreateContext(Display *dpy, int generic_id, struct glx_config *config,
              GLXContext shareList_user, Bool allowDirect,
	      unsigned code, int renderType, int screen)
{
   struct glx_context *gc;
   struct glx_screen *psc;
   struct glx_context *shareList = (struct glx_context *) shareList_user;
   if (dpy == NULL)
      return NULL;

   psc = GetGLXScreenConfigs(dpy, screen);
   if (psc == NULL)
      return NULL;

   if (generic_id == None)
      return NULL;

   gc = NULL;
#ifdef GLX_USE_APPLEGL
   gc = applegl_create_context(psc, config, shareList, renderType);
#else
   if (allowDirect && psc->vtable->create_context)
      gc = psc->vtable->create_context(psc, config, shareList, renderType);
   if (!gc)
      gc = indirect_create_context(psc, config, shareList, renderType);
#endif
   if (!gc)
      return NULL;

   LockDisplay(dpy);
   switch (code) {
   case X_GLXCreateContext: {
      xGLXCreateContextReq *req;

      /* Send the glXCreateContext request */
      GetReq(GLXCreateContext, req);
      req->reqType = gc->majorOpcode;
      req->glxCode = X_GLXCreateContext;
      req->context = gc->xid = XAllocID(dpy);
      req->visual = generic_id;
      req->screen = screen;
      req->shareList = shareList ? shareList->xid : None;
      req->isDirect = gc->isDirect;
      break;
   }

   case X_GLXCreateNewContext: {
      xGLXCreateNewContextReq *req;

      /* Send the glXCreateNewContext request */
      GetReq(GLXCreateNewContext, req);
      req->reqType = gc->majorOpcode;
      req->glxCode = X_GLXCreateNewContext;
      req->context = gc->xid = XAllocID(dpy);
      req->fbconfig = generic_id;
      req->screen = screen;
      req->renderType = renderType;
      req->shareList = shareList ? shareList->xid : None;
      req->isDirect = gc->isDirect;
      break;
   }

   case X_GLXvop_CreateContextWithConfigSGIX: {
      xGLXVendorPrivateWithReplyReq *vpreq;
      xGLXCreateContextWithConfigSGIXReq *req;

      /* Send the glXCreateNewContext request */
      GetReqExtra(GLXVendorPrivateWithReply,
		  sz_xGLXCreateContextWithConfigSGIXReq -
		  sz_xGLXVendorPrivateWithReplyReq, vpreq);
      req = (xGLXCreateContextWithConfigSGIXReq *) vpreq;
      req->reqType = gc->majorOpcode;
      req->glxCode = X_GLXVendorPrivateWithReply;
      req->vendorCode = X_GLXvop_CreateContextWithConfigSGIX;
      req->context = gc->xid = XAllocID(dpy);
      req->fbconfig = generic_id;
      req->screen = screen;
      req->renderType = renderType;
      req->shareList = shareList ? shareList->xid : None;
      req->isDirect = gc->isDirect;
      break;
   }

   default:
      /* What to do here?  This case is the sign of an internal error.  It
       * should never be reachable.
       */
      break;
   }

   UnlockDisplay(dpy);
   SyncHandle();

   gc->share_xid = shareList ? shareList->xid : None;
   gc->imported = GL_FALSE;

   return (GLXContext) gc;
}

_X_EXPORT GLXContext
glXCreateContext(Display * dpy, XVisualInfo * vis,
                 GLXContext shareList, Bool allowDirect)
{
   struct glx_config *config = NULL;
   int renderType = GLX_RGBA_TYPE;

#if defined(GLX_DIRECT_RENDERING) || defined(GLX_USE_APPLEGL)
   struct glx_screen *const psc = GetGLXScreenConfigs(dpy, vis->screen);

   if (psc)
      config = glx_config_find_visual(psc->visuals, vis->visualid);

   if (config == NULL) {
      xError error;

      error.errorCode = BadValue;
      error.resourceID = vis->visualid;
      error.sequenceNumber = dpy->request;
      error.type = X_Error;
      error.majorCode = __glXSetupForCommand(dpy);
      error.minorCode = X_GLXCreateContext;
      _XError(dpy, &error);
      return None;
   }

   /* Choose the context render type based on DRI config values.  It is
    * unusual to set this type from config, but we have no other choice, as
    * this old API does not provide renderType parameter.
    */
   if (config->renderType & GLX_RGBA_FLOAT_BIT_ARB) {
       renderType = GLX_RGBA_FLOAT_TYPE_ARB;
   } else if (config->renderType & GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT) {
       renderType = GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT;
   } else if (config->renderType & GLX_RGBA_BIT) {
       renderType = GLX_RGBA_TYPE;
   } else if (config->renderType & GLX_COLOR_INDEX_BIT) {
       renderType = GLX_COLOR_INDEX_TYPE;
   } else if (config->rgbMode) {
       /* If we're here, then renderType is not set correctly.  Let's use a
        * safeguard - any TrueColor or DirectColor mode is RGB mode.  Such
        * default value is needed by old DRI drivers, which didn't set
        * renderType correctly as the value was just ignored.
        */
       renderType = GLX_RGBA_TYPE;
   } else {
       /* Safeguard - only one option left, all non-RGB modes are indexed
        * modes.  Again, this allows drivers with invalid renderType to work
        * properly.
        */
       renderType = GLX_COLOR_INDEX_TYPE;
   }
#endif

   return CreateContext(dpy, vis->visualid, config, shareList, allowDirect,
                        X_GLXCreateContext, renderType, vis->screen);
}

static void
glx_send_destroy_context(Display *dpy, XID xid)
{
   CARD8 opcode = __glXSetupForCommand(dpy);
   xGLXDestroyContextReq *req;

   LockDisplay(dpy);
   GetReq(GLXDestroyContext, req);
   req->reqType = opcode;
   req->glxCode = X_GLXDestroyContext;
   req->context = xid;
   UnlockDisplay(dpy);
   SyncHandle();
}

/*
** Destroy the named context
*/

_X_EXPORT void
glXDestroyContext(Display * dpy, GLXContext ctx)
{
   struct glx_context *gc = (struct glx_context *) ctx;

   if (gc == NULL || gc->xid == None)
      return;

   __glXLock();
   if (!gc->imported)
      glx_send_destroy_context(dpy, gc->xid);

   if (gc->currentDpy) {
      /* This context is bound to some thread.  According to the man page,
       * we should not actually delete the context until it's unbound.
       * Note that we set gc->xid = None above.  In MakeContextCurrent()
       * we check for that and delete the context there.
       */
      gc->xid = None;
   } else {
      gc->vtable->destroy(gc);
   }
   __glXUnlock();
}

/*
** Return the major and minor version #s for the GLX extension
*/
_X_EXPORT Bool
glXQueryVersion(Display * dpy, int *major, int *minor)
{
   struct glx_display *priv;

   /* Init the extension.  This fetches the major and minor version. */
   priv = __glXInitialize(dpy);
   if (!priv)
      return False;

   if (major)
      *major = priv->majorVersion;
   if (minor)
      *minor = priv->minorVersion;
   return True;
}

/*
** Query the existance of the GLX extension
*/
_X_EXPORT Bool
glXQueryExtension(Display * dpy, int *errorBase, int *eventBase)
{
   int major_op, erb, evb;
   Bool rv;

   rv = XQueryExtension(dpy, GLX_EXTENSION_NAME, &major_op, &evb, &erb);
   if (rv) {
      if (errorBase)
         *errorBase = erb;
      if (eventBase)
         *eventBase = evb;
   }
   return rv;
}

/*
** Put a barrier in the token stream that forces the GL to finish its
** work before X can proceed.
*/
_X_EXPORT void
glXWaitGL(void)
{
   struct glx_context *gc = __glXGetCurrentContext();

   if (gc && gc->vtable->wait_gl)
      gc->vtable->wait_gl(gc);
}

/*
** Put a barrier in the token stream that forces X to finish its
** work before GL can proceed.
*/
_X_EXPORT void
glXWaitX(void)
{
   struct glx_context *gc = __glXGetCurrentContext();

   if (gc && gc->vtable->wait_x)
      gc->vtable->wait_x(gc);
}

_X_EXPORT void
glXUseXFont(Font font, int first, int count, int listBase)
{
   struct glx_context *gc = __glXGetCurrentContext();

   if (gc && gc->vtable->use_x_font)
      gc->vtable->use_x_font(gc, font, first, count, listBase);
}

/************************************************************************/

/*
** Copy the source context to the destination context using the
** attribute "mask".
*/
_X_EXPORT void
glXCopyContext(Display * dpy, GLXContext source_user,
	       GLXContext dest_user, unsigned long mask)
{
   struct glx_context *source = (struct glx_context *) source_user;
   struct glx_context *dest = (struct glx_context *) dest_user;
#ifdef GLX_USE_APPLEGL
   struct glx_context *gc = __glXGetCurrentContext();
   int errorcode;
   bool x11error;

   if(apple_glx_copy_context(gc->driContext, source->driContext, dest->driContext,
                             mask, &errorcode, &x11error)) {
      __glXSendError(dpy, errorcode, 0, X_GLXCopyContext, x11error);
   }
   
#else
   xGLXCopyContextReq *req;
   struct glx_context *gc = __glXGetCurrentContext();
   GLXContextTag tag;
   CARD8 opcode;

   opcode = __glXSetupForCommand(dpy);
   if (!opcode) {
      return;
   }

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   if (gc->isDirect) {
      /* NOT_DONE: This does not work yet */
   }
#endif

   /*
    ** If the source is the current context, send its tag so that the context
    ** can be flushed before the copy.
    */
   if (source == gc && dpy == gc->currentDpy) {
      tag = gc->currentContextTag;
   }
   else {
      tag = 0;
   }

   /* Send the glXCopyContext request */
   LockDisplay(dpy);
   GetReq(GLXCopyContext, req);
   req->reqType = opcode;
   req->glxCode = X_GLXCopyContext;
   req->source = source ? source->xid : None;
   req->dest = dest ? dest->xid : None;
   req->mask = mask;
   req->contextTag = tag;
   UnlockDisplay(dpy);
   SyncHandle();
#endif /* GLX_USE_APPLEGL */
}


/**
 * Determine if a context uses direct rendering.
 *
 * \param dpy        Display where the context was created.
 * \param contextID  ID of the context to be tested.
 *
 * \returns \c True if the context is direct rendering or not.
 */
static Bool
__glXIsDirect(Display * dpy, GLXContextID contextID)
{
   CARD8 opcode;
   xcb_connection_t *c;
   xcb_generic_error_t *err;
   xcb_glx_is_direct_reply_t *reply;
   Bool is_direct;

   opcode = __glXSetupForCommand(dpy);
   if (!opcode) {
      return False;
   }

   c = XGetXCBConnection(dpy);
   reply = xcb_glx_is_direct_reply(c, xcb_glx_is_direct(c, contextID), &err);
   is_direct = (reply != NULL && reply->is_direct) ? True : False;

   if (err != NULL) {
      __glXSendErrorForXcb(dpy, err);
      free(err);
   }

   free(reply);

   return is_direct;
}

/**
 * \todo
 * Shouldn't this function \b always return \c False when
 * \c GLX_DIRECT_RENDERING is not defined?  Do we really need to bother with
 * the GLX protocol here at all?
 */
_X_EXPORT Bool
glXIsDirect(Display * dpy, GLXContext gc_user)
{
   struct glx_context *gc = (struct glx_context *) gc_user;

   if (!gc) {
      return False;
   }
   else if (gc->isDirect) {
      return True;
   }
#ifdef GLX_USE_APPLEGL  /* TODO: indirect on darwin */
   return False;
#else
   return __glXIsDirect(dpy, gc->xid);
#endif
}

_X_EXPORT GLXPixmap
glXCreateGLXPixmap(Display * dpy, XVisualInfo * vis, Pixmap pixmap)
{
#ifdef GLX_USE_APPLEGL
   int screen = vis->screen;
   struct glx_screen *const psc = GetGLXScreenConfigs(dpy, screen);
   const struct glx_config *config;

   config = glx_config_find_visual(psc->visuals, vis->visualid);
   
   if(apple_glx_pixmap_create(dpy, vis->screen, pixmap, config))
      return None;
   
   return pixmap;
#else
   xGLXCreateGLXPixmapReq *req;
   struct glx_drawable *glxDraw;
   GLXPixmap xid;
   CARD8 opcode;

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   struct glx_display *const priv = __glXInitialize(dpy);

   if (priv == NULL)
      return None;
#endif

   opcode = __glXSetupForCommand(dpy);
   if (!opcode) {
      return None;
   }

   glxDraw = malloc(sizeof(*glxDraw));
   if (!glxDraw)
      return None;

   /* Send the glXCreateGLXPixmap request */
   LockDisplay(dpy);
   GetReq(GLXCreateGLXPixmap, req);
   req->reqType = opcode;
   req->glxCode = X_GLXCreateGLXPixmap;
   req->screen = vis->screen;
   req->visual = vis->visualid;
   req->pixmap = pixmap;
   req->glxpixmap = xid = XAllocID(dpy);
   UnlockDisplay(dpy);
   SyncHandle();

   if (InitGLXDrawable(dpy, glxDraw, pixmap, req->glxpixmap)) {
      free(glxDraw);
      return None;
   }

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   do {
      /* FIXME: Maybe delay __DRIdrawable creation until the drawable
       * is actually bound to a context... */

      __GLXDRIdrawable *pdraw;
      struct glx_screen *psc;
      struct glx_config *config;

      psc = priv->screens[vis->screen];
      if (psc->driScreen == NULL)
         return xid;

      config = glx_config_find_visual(psc->visuals, vis->visualid);
      pdraw = psc->driScreen->createDrawable(psc, pixmap, xid, config);
      if (pdraw == NULL) {
         fprintf(stderr, "failed to create pixmap\n");
         xid = None;
         break;
      }

      if (__glxHashInsert(priv->drawHash, xid, pdraw)) {
         (*pdraw->destroyDrawable) (pdraw);
         xid = None;
         break;
      }
   } while (0);

   if (xid == None) {
      xGLXDestroyGLXPixmapReq *dreq;
      LockDisplay(dpy);
      GetReq(GLXDestroyGLXPixmap, dreq);
      dreq->reqType = opcode;
      dreq->glxCode = X_GLXDestroyGLXPixmap;
      dreq->glxpixmap = xid;
      UnlockDisplay(dpy);
      SyncHandle();
   }
#endif

   return xid;
#endif
}

/*
** Destroy the named pixmap
*/
_X_EXPORT void
glXDestroyGLXPixmap(Display * dpy, GLXPixmap glxpixmap)
{
#ifdef GLX_USE_APPLEGL
   if(apple_glx_pixmap_destroy(dpy, glxpixmap))
      __glXSendError(dpy, GLXBadPixmap, glxpixmap, X_GLXDestroyPixmap, false);
#else
   xGLXDestroyGLXPixmapReq *req;
   CARD8 opcode;

   opcode = __glXSetupForCommand(dpy);
   if (!opcode) {
      return;
   }

   /* Send the glXDestroyGLXPixmap request */
   LockDisplay(dpy);
   GetReq(GLXDestroyGLXPixmap, req);
   req->reqType = opcode;
   req->glxCode = X_GLXDestroyGLXPixmap;
   req->glxpixmap = glxpixmap;
   UnlockDisplay(dpy);
   SyncHandle();

   DestroyGLXDrawable(dpy, glxpixmap);

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   {
      struct glx_display *const priv = __glXInitialize(dpy);
      __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, glxpixmap);

      if (priv != NULL && pdraw != NULL) {
         (*pdraw->destroyDrawable) (pdraw);
         __glxHashDelete(priv->drawHash, glxpixmap);
      }
   }
#endif
#endif /* GLX_USE_APPLEGL */
}

_X_EXPORT void
glXSwapBuffers(Display * dpy, GLXDrawable drawable)
{
#ifdef GLX_USE_APPLEGL
   struct glx_context * gc = __glXGetCurrentContext();
   if(gc && apple_glx_is_current_drawable(dpy, gc->driContext, drawable)) {
      apple_glx_swap_buffers(gc->driContext);
   } else {
      __glXSendError(dpy, GLXBadCurrentWindow, 0, X_GLXSwapBuffers, false);
   }
#else
   struct glx_context *gc;
   GLXContextTag tag;
   CARD8 opcode;
   xcb_connection_t *c;

   gc = __glXGetCurrentContext();

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   {
      __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);

      if (pdraw != NULL) {
         Bool flush = gc && drawable == gc->currentDrawable;

         (*pdraw->psc->driScreen->swapBuffers)(pdraw, 0, 0, 0, flush);
         return;
      }
   }
#endif

   opcode = __glXSetupForCommand(dpy);
   if (!opcode) {
      return;
   }

   /*
    ** The calling thread may or may not have a current context.  If it
    ** does, send the context tag so the server can do a flush.
    */
   if ((gc != NULL) && (dpy == gc->currentDpy) &&
       ((drawable == gc->currentDrawable)
        || (drawable == gc->currentReadable))) {
      tag = gc->currentContextTag;
   }
   else {
      tag = 0;
   }

   c = XGetXCBConnection(dpy);
   xcb_glx_swap_buffers(c, tag, drawable);
   xcb_flush(c);
#endif /* GLX_USE_APPLEGL */
}


/*
** Return configuration information for the given display, screen and
** visual combination.
*/
_X_EXPORT int
glXGetConfig(Display * dpy, XVisualInfo * vis, int attribute,
             int *value_return)
{
   struct glx_display *priv;
   struct glx_screen *psc;
   struct glx_config *config;
   int status;

   status = GetGLXPrivScreenConfig(dpy, vis->screen, &priv, &psc);
   if (status == Success) {
      config = glx_config_find_visual(psc->visuals, vis->visualid);

      /* Lookup attribute after first finding a match on the visual */
      if (config != NULL) {
	 return glx_config_get(config, attribute, value_return);
      }

      status = GLX_BAD_VISUAL;
   }

   /*
    ** If we can't find the config for this visual, this visual is not
    ** supported by the OpenGL implementation on the server.
    */
   if ((status == GLX_BAD_VISUAL) && (attribute == GLX_USE_GL)) {
      *value_return = False;
      status = Success;
   }

   return status;
}

/************************************************************************/

static void
init_fbconfig_for_chooser(struct glx_config * config,
                          GLboolean fbconfig_style_tags)
{
   memset(config, 0, sizeof(struct glx_config));
   config->visualID = (XID) GLX_DONT_CARE;
   config->visualType = GLX_DONT_CARE;

   /* glXChooseFBConfig specifies different defaults for these properties than
    * glXChooseVisual.
    */
   if (fbconfig_style_tags) {
      config->rgbMode = GL_TRUE;
      config->doubleBufferMode = GLX_DONT_CARE;
      config->renderType = GLX_RGBA_BIT;
   }

   config->drawableType = GLX_WINDOW_BIT;
   config->visualRating = GLX_DONT_CARE;
   config->transparentPixel = GLX_NONE;
   config->transparentRed = GLX_DONT_CARE;
   config->transparentGreen = GLX_DONT_CARE;
   config->transparentBlue = GLX_DONT_CARE;
   config->transparentAlpha = GLX_DONT_CARE;
   config->transparentIndex = GLX_DONT_CARE;

   config->xRenderable = GLX_DONT_CARE;
   config->fbconfigID = (GLXFBConfigID) (GLX_DONT_CARE);

   config->swapMethod = GLX_DONT_CARE;
}

#define MATCH_DONT_CARE( param )        \
  do {                                  \
    if ( ((int) a-> param != (int) GLX_DONT_CARE)   \
         && (a-> param != b-> param) ) {        \
      return False;                             \
    }                                           \
  } while ( 0 )

#define MATCH_MINIMUM( param )                  \
  do {                                          \
    if ( ((int) a-> param != (int) GLX_DONT_CARE)	\
         && (a-> param > b-> param) ) {         \
      return False;                             \
    }                                           \
  } while ( 0 )

#define MATCH_EXACT( param )                    \
  do {                                          \
    if ( a-> param != b-> param) {              \
      return False;                             \
    }                                           \
  } while ( 0 )

/* Test that all bits from a are contained in b */
#define MATCH_MASK(param)			\
  do {						\
    if ( ((int) a-> param != (int) GLX_DONT_CARE)	\
         && ((a->param & ~b->param) != 0) ) {   \
      return False;				\
    }                                           \
  } while (0);

/**
 * Determine if two GLXFBConfigs are compatible.
 *
 * \param a  Application specified config to test.
 * \param b  Server specified config to test against \c a.
 */
static Bool
fbconfigs_compatible(const struct glx_config * const a,
                     const struct glx_config * const b)
{
   MATCH_DONT_CARE(doubleBufferMode);
   MATCH_DONT_CARE(visualType);
   MATCH_DONT_CARE(visualRating);
   MATCH_DONT_CARE(xRenderable);
   MATCH_DONT_CARE(fbconfigID);
   MATCH_DONT_CARE(swapMethod);

   MATCH_MINIMUM(rgbBits);
   MATCH_MINIMUM(numAuxBuffers);
   MATCH_MINIMUM(redBits);
   MATCH_MINIMUM(greenBits);
   MATCH_MINIMUM(blueBits);
   MATCH_MINIMUM(alphaBits);
   MATCH_MINIMUM(depthBits);
   MATCH_MINIMUM(stencilBits);
   MATCH_MINIMUM(accumRedBits);
   MATCH_MINIMUM(accumGreenBits);
   MATCH_MINIMUM(accumBlueBits);
   MATCH_MINIMUM(accumAlphaBits);
   MATCH_MINIMUM(sampleBuffers);
   MATCH_MINIMUM(maxPbufferWidth);
   MATCH_MINIMUM(maxPbufferHeight);
   MATCH_MINIMUM(maxPbufferPixels);
   MATCH_MINIMUM(samples);

   MATCH_DONT_CARE(stereoMode);
   MATCH_EXACT(level);

   MATCH_MASK(drawableType);
   MATCH_MASK(renderType);

   /* There is a bug in a few of the XFree86 DDX drivers.  They contain
    * visuals with a "transparent type" of 0 when they really mean GLX_NONE.
    * Technically speaking, it is a bug in the DDX driver, but there is
    * enough of an installed base to work around the problem here.  In any
    * case, 0 is not a valid value of the transparent type, so we'll treat 0
    * from the app as GLX_DONT_CARE. We'll consider GLX_NONE from the app and
    * 0 from the server to be a match to maintain backward compatibility with
    * the (broken) drivers.
    */

   if (a->transparentPixel != (int) GLX_DONT_CARE && a->transparentPixel != 0) {
      if (a->transparentPixel == GLX_NONE) {
         if (b->transparentPixel != GLX_NONE && b->transparentPixel != 0)
            return False;
      }
      else {
         MATCH_EXACT(transparentPixel);
      }

      switch (a->transparentPixel) {
      case GLX_TRANSPARENT_RGB:
         MATCH_DONT_CARE(transparentRed);
         MATCH_DONT_CARE(transparentGreen);
         MATCH_DONT_CARE(transparentBlue);
         MATCH_DONT_CARE(transparentAlpha);
         break;

      case GLX_TRANSPARENT_INDEX:
         MATCH_DONT_CARE(transparentIndex);
         break;

      default:
         break;
      }
   }

   return True;
}


/* There's some trickly language in the GLX spec about how this is supposed
 * to work.  Basically, if a given component size is either not specified
 * or the requested size is zero, it is supposed to act like PERFER_SMALLER.
 * Well, that's really hard to do with the code as-is.  This behavior is
 * closer to correct, but still not technically right.
 */
#define PREFER_LARGER_OR_ZERO(comp)             \
  do {                                          \
    if ( ((*a)-> comp) != ((*b)-> comp) ) {     \
      if ( ((*a)-> comp) == 0 ) {               \
        return -1;                              \
      }                                         \
      else if ( ((*b)-> comp) == 0 ) {          \
        return 1;                               \
      }                                         \
      else {                                    \
        return ((*b)-> comp) - ((*a)-> comp) ;  \
      }                                         \
    }                                           \
  } while( 0 )

#define PREFER_LARGER(comp)                     \
  do {                                          \
    if ( ((*a)-> comp) != ((*b)-> comp) ) {     \
      return ((*b)-> comp) - ((*a)-> comp) ;    \
    }                                           \
  } while( 0 )

#define PREFER_SMALLER(comp)                    \
  do {                                          \
    if ( ((*a)-> comp) != ((*b)-> comp) ) {     \
      return ((*a)-> comp) - ((*b)-> comp) ;    \
    }                                           \
  } while( 0 )

/**
 * Compare two GLXFBConfigs.  This function is intended to be used as the
 * compare function passed in to qsort.
 *
 * \returns If \c a is a "better" config, according to the specification of
 *          SGIX_fbconfig, a number less than zero is returned.  If \c b is
 *          better, then a number greater than zero is return.  If both are
 *          equal, zero is returned.
 * \sa qsort, glXChooseVisual, glXChooseFBConfig, glXChooseFBConfigSGIX
 */
static int
fbconfig_compare(struct glx_config **a, struct glx_config **b)
{
   /* The order of these comparisons must NOT change.  It is defined by
    * the GLX 1.4 specification.
    */

   PREFER_SMALLER(visualSelectGroup);

   /* The sort order for the visualRating is GLX_NONE, GLX_SLOW, and
    * GLX_NON_CONFORMANT_CONFIG.  It just so happens that this is the
    * numerical sort order of the enums (0x8000, 0x8001, and 0x800D).
    */
   PREFER_SMALLER(visualRating);

   /* This isn't quite right.  It is supposed to compare the sum of the
    * components the user specifically set minimums for.
    */
   PREFER_LARGER_OR_ZERO(redBits);
   PREFER_LARGER_OR_ZERO(greenBits);
   PREFER_LARGER_OR_ZERO(blueBits);
   PREFER_LARGER_OR_ZERO(alphaBits);

   PREFER_SMALLER(rgbBits);

   if (((*a)->doubleBufferMode != (*b)->doubleBufferMode)) {
      /* Prefer single-buffer.
       */
      return (!(*a)->doubleBufferMode) ? -1 : 1;
   }

   PREFER_SMALLER(numAuxBuffers);

   PREFER_SMALLER(sampleBuffers);
   PREFER_SMALLER(samples);

   PREFER_LARGER_OR_ZERO(depthBits);
   PREFER_SMALLER(stencilBits);

   /* This isn't quite right.  It is supposed to compare the sum of the
    * components the user specifically set minimums for.
    */
   PREFER_LARGER_OR_ZERO(accumRedBits);
   PREFER_LARGER_OR_ZERO(accumGreenBits);
   PREFER_LARGER_OR_ZERO(accumBlueBits);
   PREFER_LARGER_OR_ZERO(accumAlphaBits);

   PREFER_SMALLER(visualType);

   /* None of the pbuffer or fbconfig specs say that this comparison needs
    * to happen at all, but it seems like it should.
    */
   PREFER_LARGER(maxPbufferWidth);
   PREFER_LARGER(maxPbufferHeight);
   PREFER_LARGER(maxPbufferPixels);

   return 0;
}


/**
 * Selects and sorts a subset of the supplied configs based on the attributes.
 * This function forms to basis of \c glXChooseVisual, \c glXChooseFBConfig,
 * and \c glXChooseFBConfigSGIX.
 *
 * \param configs   Array of pointers to possible configs.  The elements of
 *                  this array that do not meet the criteria will be set to
 *                  NULL.  The remaining elements will be sorted according to
 *                  the various visual / FBConfig selection rules.
 * \param num_configs  Number of elements in the \c configs array.
 * \param attribList   Attributes used select from \c configs.  This array is
 *                     terminated by a \c None tag.  The array can either take
 *                     the form expected by \c glXChooseVisual (where boolean
 *                     tags do not have a value) or by \c glXChooseFBConfig
 *                     (where every tag has a value).
 * \param fbconfig_style_tags  Selects whether \c attribList is in
 *                             \c glXChooseVisual style or
 *                             \c glXChooseFBConfig style.
 * \returns The number of valid elements left in \c configs.
 *
 * \sa glXChooseVisual, glXChooseFBConfig, glXChooseFBConfigSGIX
 */
static int
choose_visual(struct glx_config ** configs, int num_configs,
              const int *attribList, GLboolean fbconfig_style_tags)
{
   struct glx_config test_config;
   int base;
   int i;

   /* This is a fairly direct implementation of the selection method
    * described by GLX_SGIX_fbconfig.  Start by culling out all the
    * configs that are not compatible with the selected parameter
    * list.
    */

   init_fbconfig_for_chooser(&test_config, fbconfig_style_tags);
   __glXInitializeVisualConfigFromTags(&test_config, 512,
                                       (const INT32 *) attribList,
                                       GL_TRUE, fbconfig_style_tags);

   base = 0;
   for (i = 0; i < num_configs; i++) {
      if (fbconfigs_compatible(&test_config, configs[i])) {
         configs[base] = configs[i];
         base++;
      }
   }

   if (base == 0) {
      return 0;
   }

   if (base < num_configs) {
      (void) memset(&configs[base], 0, sizeof(void *) * (num_configs - base));
   }

   /* After the incompatible configs are removed, the resulting
    * list is sorted according to the rules set out in the various
    * specifications.
    */

   qsort(configs, base, sizeof(struct glx_config *),
         (int (*)(const void *, const void *)) fbconfig_compare);
   return base;
}




/*
** Return the visual that best matches the template.  Return None if no
** visual matches the template.
*/
_X_EXPORT XVisualInfo *
glXChooseVisual(Display * dpy, int screen, int *attribList)
{
   XVisualInfo *visualList = NULL;
   struct glx_display *priv;
   struct glx_screen *psc;
   struct glx_config test_config;
   struct glx_config *config;
   struct glx_config *best_config = NULL;

   /*
    ** Get a list of all visuals, return if list is empty
    */
   if (GetGLXPrivScreenConfig(dpy, screen, &priv, &psc) != Success) {
      return None;
   }


   /*
    ** Build a template from the defaults and the attribute list
    ** Free visual list and return if an unexpected token is encountered
    */
   init_fbconfig_for_chooser(&test_config, GL_FALSE);
   __glXInitializeVisualConfigFromTags(&test_config, 512,
                                       (const INT32 *) attribList,
                                       GL_TRUE, GL_FALSE);

   /*
    ** Eliminate visuals that don't meet minimum requirements
    ** Compute a score for those that do
    ** Remember which visual, if any, got the highest score
    ** If no visual is acceptable, return None
    ** Otherwise, create an XVisualInfo list with just the selected X visual
    ** and return this.
    */
   for (config = psc->visuals; config != NULL; config = config->next) {
      if (fbconfigs_compatible(&test_config, config)
          && ((best_config == NULL) ||
              (fbconfig_compare (&config, &best_config) < 0))) {
         XVisualInfo visualTemplate;
         XVisualInfo *newList;
         int i;

         visualTemplate.screen = screen;
         visualTemplate.visualid = config->visualID;
         newList = XGetVisualInfo(dpy, VisualScreenMask | VisualIDMask,
                                  &visualTemplate, &i);

         if (newList) {
            free(visualList);
            visualList = newList;
            best_config = config;
         }
      }
   }

#ifdef GLX_USE_APPLEGL
   if(visualList && getenv("LIBGL_DUMP_VISUALID")) {
      printf("visualid 0x%lx\n", visualList[0].visualid);
   }
#endif

   return visualList;
}


_X_EXPORT const char *
glXQueryExtensionsString(Display * dpy, int screen)
{
   struct glx_screen *psc;
   struct glx_display *priv;

   if (GetGLXPrivScreenConfig(dpy, screen, &priv, &psc) != Success) {
      return NULL;
   }

   if (!psc->effectiveGLXexts) {
      if (!psc->serverGLXexts) {
         psc->serverGLXexts =
            __glXQueryServerString(dpy, priv->majorOpcode, screen,
                                   GLX_EXTENSIONS);
      }

      __glXCalculateUsableExtensions(psc,
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
                                     (psc->driScreen != NULL),
#else
                                     GL_FALSE,
#endif
                                     priv->minorVersion);
   }

   return psc->effectiveGLXexts;
}

_X_EXPORT const char *
glXGetClientString(Display * dpy, int name)
{
   (void) dpy;

   switch (name) {
   case GLX_VENDOR:
      return (__glXGLXClientVendorName);
   case GLX_VERSION:
      return (__glXGLXClientVersion);
   case GLX_EXTENSIONS:
      return (__glXGetClientExtensions());
   default:
      return NULL;
   }
}

_X_EXPORT const char *
glXQueryServerString(Display * dpy, int screen, int name)
{
   struct glx_screen *psc;
   struct glx_display *priv;
   const char **str;


   if (GetGLXPrivScreenConfig(dpy, screen, &priv, &psc) != Success) {
      return NULL;
   }

   switch (name) {
   case GLX_VENDOR:
      str = &priv->serverGLXvendor;
      break;
   case GLX_VERSION:
      str = &priv->serverGLXversion;
      break;
   case GLX_EXTENSIONS:
      str = &psc->serverGLXexts;
      break;
   default:
      return NULL;
   }

   if (*str == NULL) {
      *str = __glXQueryServerString(dpy, priv->majorOpcode, screen, name);
   }

   return *str;
}


/*
** EXT_import_context
*/

_X_EXPORT Display *
glXGetCurrentDisplay(void)
{
   struct glx_context *gc = __glXGetCurrentContext();
   if (NULL == gc)
      return NULL;
   return gc->currentDpy;
}

_X_EXPORT
GLX_ALIAS(Display *, glXGetCurrentDisplayEXT, (void), (),
          glXGetCurrentDisplay)

#ifndef GLX_USE_APPLEGL
_X_EXPORT GLXContext
glXImportContextEXT(Display *dpy, GLXContextID contextID)
{
   struct glx_display *priv = __glXInitialize(dpy);
   struct glx_screen *psc = NULL;
   xGLXQueryContextReply reply;
   CARD8 opcode;
   struct glx_context *ctx;

   /* This GLX implementation knows about 5 different properties, so
    * allow the server to send us one of each.
    */
   int propList[5 * 2], *pProp, nPropListBytes;
   int numProps;
   int i, renderType;
   XID share;
   struct glx_config *mode;
   uint32_t fbconfigID = 0;
   uint32_t visualID = 0;
   uint32_t screen = 0;
   Bool got_screen = False;

   if (priv == NULL)
      return NULL;

   /* The GLX_EXT_import_context spec says:
    *
    *     "If <contextID> does not refer to a valid context, then a BadContext
    *     error is generated; if <contextID> refers to direct rendering
    *     context then no error is generated but glXImportContextEXT returns
    *     NULL."
    *
    * If contextID is None, generate BadContext on the client-side.  Other
    * sorts of invalid contexts will be detected by the server in the
    * __glXIsDirect call.
    */
   if (contextID == None) {
      __glXSendError(dpy, GLXBadContext, contextID, X_GLXIsDirect, false);
      return NULL;
   }

   if (__glXIsDirect(dpy, contextID))
      return NULL;

   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
      return 0;

   /* Send the glXQueryContextInfoEXT request */
   LockDisplay(dpy);

   if (priv->majorVersion > 1 || priv->minorVersion >= 3) {
      xGLXQueryContextReq *req;

      GetReq(GLXQueryContext, req);

      req->reqType = opcode;
      req->glxCode = X_GLXQueryContext;
      req->context = contextID;
   }
   else {
      xGLXVendorPrivateReq *vpreq;
      xGLXQueryContextInfoEXTReq *req;

      GetReqExtra(GLXVendorPrivate,
		  sz_xGLXQueryContextInfoEXTReq - sz_xGLXVendorPrivateReq,
		  vpreq);
      req = (xGLXQueryContextInfoEXTReq *) vpreq;
      req->reqType = opcode;
      req->glxCode = X_GLXVendorPrivateWithReply;
      req->vendorCode = X_GLXvop_QueryContextInfoEXT;
      req->context = contextID;
   }

   _XReply(dpy, (xReply *) & reply, 0, False);

   if (reply.n <= __GLX_MAX_CONTEXT_PROPS)
      nPropListBytes = reply.n * 2 * sizeof propList[0];
   else
      nPropListBytes = 0;
   _XRead(dpy, (char *) propList, nPropListBytes);
   UnlockDisplay(dpy);
   SyncHandle();

   numProps = nPropListBytes / (2 * sizeof(propList[0]));
   share = None;
   mode = NULL;
   renderType = GLX_RGBA_TYPE; /* By default, assume RGBA context */
   pProp = propList;

   for (i = 0, pProp = propList; i < numProps; i++, pProp += 2)
      switch (pProp[0]) {
      case GLX_SCREEN:
	 screen = pProp[1];
	 got_screen = True;
	 break;
      case GLX_SHARE_CONTEXT_EXT:
	 share = pProp[1];
	 break;
      case GLX_VISUAL_ID_EXT:
	 visualID = pProp[1];
	 break;
      case GLX_FBCONFIG_ID:
	 fbconfigID = pProp[1];
	 break;
      case GLX_RENDER_TYPE:
	 renderType = pProp[1];
	 break;
      }

   if (!got_screen)
      return NULL;

   psc = GetGLXScreenConfigs(dpy, screen);
   if (psc == NULL)
      return NULL;

   if (fbconfigID != 0) {
      mode = glx_config_find_fbconfig(psc->configs, fbconfigID);
   } else if (visualID != 0) {
      mode = glx_config_find_visual(psc->visuals, visualID);
   }

   if (mode == NULL)
      return NULL;

   ctx = indirect_create_context(psc, mode, NULL, renderType);
   if (ctx == NULL)
      return NULL;

   ctx->xid = contextID;
   ctx->imported = GL_TRUE;
   ctx->share_xid = share;

   return (GLXContext) ctx;
}

#endif

_X_EXPORT int
glXQueryContext(Display * dpy, GLXContext ctx_user, int attribute, int *value)
{
   struct glx_context *ctx = (struct glx_context *) ctx_user;

   switch (attribute) {
      case GLX_SHARE_CONTEXT_EXT:
      *value = ctx->share_xid;
      break;
   case GLX_VISUAL_ID_EXT:
      *value = ctx->config ? ctx->config->visualID : None;
      break;
   case GLX_SCREEN:
      *value = ctx->screen;
      break;
   case GLX_FBCONFIG_ID:
      *value = ctx->config ? ctx->config->fbconfigID : None;
      break;
   case GLX_RENDER_TYPE:
      *value = ctx->renderType;
      break;
   default:
      return GLX_BAD_ATTRIBUTE;
   }
   return Success;
}

_X_EXPORT
GLX_ALIAS(int, glXQueryContextInfoEXT,
          (Display * dpy, GLXContext ctx, int attribute, int *value),
          (dpy, ctx, attribute, value), glXQueryContext)

_X_EXPORT GLXContextID glXGetContextIDEXT(const GLXContext ctx_user)
{
   struct glx_context *ctx = (struct glx_context *) ctx_user;

   return (ctx == NULL) ? None : ctx->xid;
}

_X_EXPORT void
glXFreeContextEXT(Display *dpy, GLXContext ctx)
{
   struct glx_context *gc = (struct glx_context *) ctx;

   if (gc == NULL || gc->xid == None)
      return;

   /* The GLX_EXT_import_context spec says:
    *
    *     "glXFreeContext does not free the server-side context information or
    *     the XID associated with the server-side context."
    *
    * Don't send any protocol.  Just destroy the client-side tracking of the
    * context.  Also, only release the context structure if it's not current.
    */
   __glXLock();
   if (gc->currentDpy) {
      gc->xid = None;
   } else {
      gc->vtable->destroy(gc);
   }
   __glXUnlock();
}

_X_EXPORT GLXFBConfig *
glXChooseFBConfig(Display * dpy, int screen,
                  const int *attribList, int *nitems)
{
   struct glx_config **config_list;
   int list_size;


   config_list = (struct glx_config **)
      glXGetFBConfigs(dpy, screen, &list_size);

   if ((config_list != NULL) && (list_size > 0) && (attribList != NULL)) {
      list_size = choose_visual(config_list, list_size, attribList, GL_TRUE);
      if (list_size == 0) {
         free(config_list);
         config_list = NULL;
      }
   }

   *nitems = list_size;
   return (GLXFBConfig *) config_list;
}


_X_EXPORT GLXContext
glXCreateNewContext(Display * dpy, GLXFBConfig fbconfig,
                    int renderType, GLXContext shareList, Bool allowDirect)
{
   struct glx_config *config = (struct glx_config *) fbconfig;

   return CreateContext(dpy, config->fbconfigID, config, shareList,
			allowDirect, X_GLXCreateNewContext, renderType,
			config->screen);
}


_X_EXPORT GLXDrawable
glXGetCurrentReadDrawable(void)
{
   struct glx_context *gc = __glXGetCurrentContext();

   return gc->currentReadable;
}


_X_EXPORT GLXFBConfig *
glXGetFBConfigs(Display * dpy, int screen, int *nelements)
{
   struct glx_display *priv = __glXInitialize(dpy);
   struct glx_config **config_list = NULL;
   struct glx_config *config;
   unsigned num_configs = 0;
   int i;

   *nelements = 0;
   if (priv && (priv->screens != NULL)
       && (screen >= 0) && (screen <= ScreenCount(dpy))
       && (priv->screens[screen]->configs != NULL)
       && (priv->screens[screen]->configs->fbconfigID
	   != (int) GLX_DONT_CARE)) {

      for (config = priv->screens[screen]->configs; config != NULL;
           config = config->next) {
         if (config->fbconfigID != (int) GLX_DONT_CARE) {
            num_configs++;
         }
      }

      config_list = malloc(num_configs * sizeof *config_list);
      if (config_list != NULL) {
         *nelements = num_configs;
         i = 0;
         for (config = priv->screens[screen]->configs; config != NULL;
              config = config->next) {
            if (config->fbconfigID != (int) GLX_DONT_CARE) {
               config_list[i] = config;
               i++;
            }
         }
      }
   }

   return (GLXFBConfig *) config_list;
}


_X_EXPORT int
glXGetFBConfigAttrib(Display * dpy, GLXFBConfig fbconfig,
                     int attribute, int *value)
{
   struct glx_config *config = ValidateGLXFBConfig(dpy, fbconfig);

   if (config == NULL)
      return GLXBadFBConfig;

   return glx_config_get(config, attribute, value);
}


_X_EXPORT XVisualInfo *
glXGetVisualFromFBConfig(Display * dpy, GLXFBConfig fbconfig)
{
   XVisualInfo visualTemplate;
   struct glx_config *config = (struct glx_config *) fbconfig;
   int count;

   /*
    ** Get a list of all visuals, return if list is empty
    */
   visualTemplate.visualid = config->visualID;
   return XGetVisualInfo(dpy, VisualIDMask, &visualTemplate, &count);
}

#ifndef GLX_USE_APPLEGL
/*
** GLX_SGI_swap_control
*/
static int
__glXSwapIntervalSGI(int interval)
{
   xGLXVendorPrivateReq *req;
   struct glx_context *gc = __glXGetCurrentContext();
   struct glx_screen *psc;
   Display *dpy;
   CARD32 *interval_ptr;
   CARD8 opcode;

   if (gc == NULL) {
      return GLX_BAD_CONTEXT;
   }

   if (interval <= 0) {
      return GLX_BAD_VALUE;
   }

   psc = GetGLXScreenConfigs( gc->currentDpy, gc->screen);

#ifdef GLX_DIRECT_RENDERING
   if (gc->isDirect && psc && psc->driScreen &&
          psc->driScreen->setSwapInterval) {
      __GLXDRIdrawable *pdraw =
	 GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
      psc->driScreen->setSwapInterval(pdraw, interval);
      return 0;
   }
#endif

   dpy = gc->currentDpy;
   opcode = __glXSetupForCommand(dpy);
   if (!opcode) {
      return 0;
   }

   /* Send the glXSwapIntervalSGI request */
   LockDisplay(dpy);
   GetReqExtra(GLXVendorPrivate, sizeof(CARD32), req);
   req->reqType = opcode;
   req->glxCode = X_GLXVendorPrivate;
   req->vendorCode = X_GLXvop_SwapIntervalSGI;
   req->contextTag = gc->currentContextTag;

   interval_ptr = (CARD32 *) (req + 1);
   *interval_ptr = interval;

   UnlockDisplay(dpy);
   SyncHandle();
   XFlush(dpy);

   return 0;
}


/*
** GLX_MESA_swap_control
*/
static int
__glXSwapIntervalMESA(unsigned int interval)
{
#ifdef GLX_DIRECT_RENDERING
   struct glx_context *gc = __glXGetCurrentContext();

   if (gc != NULL && gc->isDirect) {
      struct glx_screen *psc;

      psc = GetGLXScreenConfigs( gc->currentDpy, gc->screen);
      if (psc && psc->driScreen && psc->driScreen->setSwapInterval) {
         __GLXDRIdrawable *pdraw =
	    GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
	 return psc->driScreen->setSwapInterval(pdraw, interval);
      }
   }
#endif

   return GLX_BAD_CONTEXT;
}


static int
__glXGetSwapIntervalMESA(void)
{
#ifdef GLX_DIRECT_RENDERING
   struct glx_context *gc = __glXGetCurrentContext();

   if (gc != NULL && gc->isDirect) {
      struct glx_screen *psc;

      psc = GetGLXScreenConfigs( gc->currentDpy, gc->screen);
      if (psc && psc->driScreen && psc->driScreen->getSwapInterval) {
         __GLXDRIdrawable *pdraw =
	    GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
	 return psc->driScreen->getSwapInterval(pdraw);
      }
   }
#endif

   return 0;
}


/*
** GLX_SGI_video_sync
*/
static int
__glXGetVideoSyncSGI(unsigned int *count)
{
   int64_t ust, msc, sbc;
   int ret;
   struct glx_context *gc = __glXGetCurrentContext();
   struct glx_screen *psc;
#ifdef GLX_DIRECT_RENDERING
   __GLXDRIdrawable *pdraw;
#endif

   if (!gc)
      return GLX_BAD_CONTEXT;

#ifdef GLX_DIRECT_RENDERING
   if (!gc->isDirect)
      return GLX_BAD_CONTEXT;
#endif

   psc = GetGLXScreenConfigs(gc->currentDpy, gc->screen);
#ifdef GLX_DIRECT_RENDERING
   pdraw = GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
#endif

   /* FIXME: Looking at the GLX_SGI_video_sync spec in the extension registry,
    * FIXME: there should be a GLX encoding for this call.  I can find no
    * FIXME: documentation for the GLX encoding.
    */
#ifdef GLX_DIRECT_RENDERING
   if (psc && psc->driScreen && psc->driScreen->getDrawableMSC) {
      ret = psc->driScreen->getDrawableMSC(psc, pdraw, &ust, &msc, &sbc);
      *count = (unsigned) msc;
      return (ret == True) ? 0 : GLX_BAD_CONTEXT;
   }
#endif

   return GLX_BAD_CONTEXT;
}

static int
__glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *count)
{
   struct glx_context *gc = __glXGetCurrentContext();
   struct glx_screen *psc;
#ifdef GLX_DIRECT_RENDERING
   __GLXDRIdrawable *pdraw;
#endif
   int64_t ust, msc, sbc;
   int ret;

   if (divisor <= 0 || remainder < 0)
      return GLX_BAD_VALUE;

   if (!gc)
      return GLX_BAD_CONTEXT;

#ifdef GLX_DIRECT_RENDERING
   if (!gc->isDirect)
      return GLX_BAD_CONTEXT;
#endif

   psc = GetGLXScreenConfigs( gc->currentDpy, gc->screen);
#ifdef GLX_DIRECT_RENDERING
   pdraw = GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
#endif

#ifdef GLX_DIRECT_RENDERING
   if (psc && psc->driScreen && psc->driScreen->waitForMSC) {
      ret = psc->driScreen->waitForMSC(pdraw, 0, divisor, remainder, &ust, &msc,
				       &sbc);
      *count = (unsigned) msc;
      return (ret == True) ? 0 : GLX_BAD_CONTEXT;
   }
#endif

   return GLX_BAD_CONTEXT;
}

#endif /* GLX_USE_APPLEGL */

/*
** GLX_SGIX_fbconfig
** Many of these functions are aliased to GLX 1.3 entry points in the 
** GLX_functions table.
*/

_X_EXPORT
GLX_ALIAS(int, glXGetFBConfigAttribSGIX,
          (Display * dpy, GLXFBConfigSGIX config, int attribute, int *value),
          (dpy, config, attribute, value), glXGetFBConfigAttrib)

_X_EXPORT GLX_ALIAS(GLXFBConfigSGIX *, glXChooseFBConfigSGIX,
                 (Display * dpy, int screen, int *attrib_list,
                  int *nelements), (dpy, screen, attrib_list, nelements),
                 glXChooseFBConfig)

_X_EXPORT GLX_ALIAS(XVisualInfo *, glXGetVisualFromFBConfigSGIX,
                 (Display * dpy, GLXFBConfigSGIX config),
                 (dpy, config), glXGetVisualFromFBConfig)

_X_EXPORT GLXPixmap
glXCreateGLXPixmapWithConfigSGIX(Display * dpy,
                                 GLXFBConfigSGIX fbconfig,
                                 Pixmap pixmap)
{
#ifndef GLX_USE_APPLEGL
   xGLXVendorPrivateWithReplyReq *vpreq;
   xGLXCreateGLXPixmapWithConfigSGIXReq *req;
   GLXPixmap xid = None;
   CARD8 opcode;
   struct glx_screen *psc;
#endif
   struct glx_config *config = (struct glx_config *) fbconfig;


   if ((dpy == NULL) || (config == NULL)) {
      return None;
   }
#ifdef GLX_USE_APPLEGL
   if(apple_glx_pixmap_create(dpy, config->screen, pixmap, config))
      return None;
   return pixmap;
#else

   psc = GetGLXScreenConfigs(dpy, config->screen);
   if ((psc != NULL)
       && __glXExtensionBitIsEnabled(psc, SGIX_fbconfig_bit)) {
      opcode = __glXSetupForCommand(dpy);
      if (!opcode) {
         return None;
      }

      /* Send the glXCreateGLXPixmapWithConfigSGIX request */
      LockDisplay(dpy);
      GetReqExtra(GLXVendorPrivateWithReply,
                  sz_xGLXCreateGLXPixmapWithConfigSGIXReq -
                  sz_xGLXVendorPrivateWithReplyReq, vpreq);
      req = (xGLXCreateGLXPixmapWithConfigSGIXReq *) vpreq;
      req->reqType = opcode;
      req->glxCode = X_GLXVendorPrivateWithReply;
      req->vendorCode = X_GLXvop_CreateGLXPixmapWithConfigSGIX;
      req->screen = config->screen;
      req->fbconfig = config->fbconfigID;
      req->pixmap = pixmap;
      req->glxpixmap = xid = XAllocID(dpy);
      UnlockDisplay(dpy);
      SyncHandle();
   }

   return xid;
#endif
}

_X_EXPORT GLXContext
glXCreateContextWithConfigSGIX(Display * dpy,
                               GLXFBConfigSGIX fbconfig, int renderType,
                               GLXContext shareList, Bool allowDirect)
{
   GLXContext gc = NULL;
   struct glx_config *config = (struct glx_config *) fbconfig;
   struct glx_screen *psc;


   if ((dpy == NULL) || (config == NULL)) {
      return None;
   }

   psc = GetGLXScreenConfigs(dpy, config->screen);
   if ((psc != NULL)
       && __glXExtensionBitIsEnabled(psc, SGIX_fbconfig_bit)) {
      gc = CreateContext(dpy, config->fbconfigID, config, shareList,
                         allowDirect,
			 X_GLXvop_CreateContextWithConfigSGIX, renderType,
			 config->screen);
   }

   return gc;
}


_X_EXPORT GLXFBConfigSGIX
glXGetFBConfigFromVisualSGIX(Display * dpy, XVisualInfo * vis)
{
   struct glx_display *priv;
   struct glx_screen *psc = NULL;

   if ((GetGLXPrivScreenConfig(dpy, vis->screen, &priv, &psc) == Success)
       && __glXExtensionBitIsEnabled(psc, SGIX_fbconfig_bit)
       && (psc->configs->fbconfigID != (int) GLX_DONT_CARE)) {
      return (GLXFBConfigSGIX) glx_config_find_visual(psc->configs,
						      vis->visualid);
   }

   return NULL;
}

#ifndef GLX_USE_APPLEGL
/*
** GLX_SGIX_swap_group
*/
static void
__glXJoinSwapGroupSGIX(Display * dpy, GLXDrawable drawable,
                       GLXDrawable member)
{
   (void) dpy;
   (void) drawable;
   (void) member;
}


/*
** GLX_SGIX_swap_barrier
*/
static void
__glXBindSwapBarrierSGIX(Display * dpy, GLXDrawable drawable, int barrier)
{
   (void) dpy;
   (void) drawable;
   (void) barrier;
}

static Bool
__glXQueryMaxSwapBarriersSGIX(Display * dpy, int screen, int *max)
{
   (void) dpy;
   (void) screen;
   (void) max;
   return False;
}


/*
** GLX_OML_sync_control
*/
static Bool
__glXGetSyncValuesOML(Display * dpy, GLXDrawable drawable,
                      int64_t * ust, int64_t * msc, int64_t * sbc)
{
   struct glx_display * const priv = __glXInitialize(dpy);
   int ret;
#ifdef GLX_DIRECT_RENDERING
   __GLXDRIdrawable *pdraw;
#endif
   struct glx_screen *psc;

   if (!priv)
      return False;

#ifdef GLX_DIRECT_RENDERING
   pdraw = GetGLXDRIDrawable(dpy, drawable);
   psc = pdraw ? pdraw->psc : NULL;
   if (pdraw && psc->driScreen->getDrawableMSC) {
      ret = psc->driScreen->getDrawableMSC(psc, pdraw, ust, msc, sbc);
      return ret;
   }
#endif

   return False;
}

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
_X_HIDDEN GLboolean
__glxGetMscRate(struct glx_screen *psc,
		int32_t * numerator, int32_t * denominator)
{
#ifdef XF86VIDMODE
   XF86VidModeModeLine mode_line;
   int dot_clock;
   int i;

   if (XF86VidModeQueryVersion(psc->dpy, &i, &i) &&
       XF86VidModeGetModeLine(psc->dpy, psc->scr, &dot_clock, &mode_line)) {
      unsigned n = dot_clock * 1000;
      unsigned d = mode_line.vtotal * mode_line.htotal;

# define V_INTERLACE 0x010
# define V_DBLSCAN   0x020

      if (mode_line.flags & V_INTERLACE)
         n *= 2;
      else if (mode_line.flags & V_DBLSCAN)
         d *= 2;

      /* The OML_sync_control spec requires that if the refresh rate is a
       * whole number, that the returned numerator be equal to the refresh
       * rate and the denominator be 1.
       */

      if (n % d == 0) {
         n /= d;
         d = 1;
      }
      else {
         static const unsigned f[] = { 13, 11, 7, 5, 3, 2, 0 };

         /* This is a poor man's way to reduce a fraction.  It's far from
          * perfect, but it will work well enough for this situation.
          */

         for (i = 0; f[i] != 0; i++) {
            while (n % f[i] == 0 && d % f[i] == 0) {
               d /= f[i];
               n /= f[i];
            }
         }
      }

      *numerator = n;
      *denominator = d;

      return True;
   }
   else
#endif

   return False;
}
#endif

/**
 * Determine the refresh rate of the specified drawable and display.
 *
 * \param dpy          Display whose refresh rate is to be determined.
 * \param drawable     Drawable whose refresh rate is to be determined.
 * \param numerator    Numerator of the refresh rate.
 * \param demoninator  Denominator of the refresh rate.
 * \return  If the refresh rate for the specified display and drawable could
 *          be calculated, True is returned.  Otherwise False is returned.
 *
 * \note This function is implemented entirely client-side.  A lot of other
 *       functionality is required to export GLX_OML_sync_control, so on
 *       XFree86 this function can be called for direct-rendering contexts
 *       when GLX_OML_sync_control appears in the client extension string.
 */

_X_HIDDEN GLboolean
__glXGetMscRateOML(Display * dpy, GLXDrawable drawable,
                   int32_t * numerator, int32_t * denominator)
{
#if defined( GLX_DIRECT_RENDERING ) && defined( XF86VIDMODE )
   __GLXDRIdrawable *draw = GetGLXDRIDrawable(dpy, drawable);

   if (draw == NULL)
      return False;

   return __glxGetMscRate(draw->psc, numerator, denominator);
#else
   (void) dpy;
   (void) drawable;
   (void) numerator;
   (void) denominator;
#endif
   return False;
}


static int64_t
__glXSwapBuffersMscOML(Display * dpy, GLXDrawable drawable,
                       int64_t target_msc, int64_t divisor, int64_t remainder)
{
   struct glx_context *gc = __glXGetCurrentContext();
#ifdef GLX_DIRECT_RENDERING
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
   struct glx_screen *psc = pdraw ? pdraw->psc : NULL;
#endif

   if (!gc) /* no GLX for this */
      return -1;

#ifdef GLX_DIRECT_RENDERING
   if (!pdraw || !gc->isDirect)
      return -1;
#endif

   /* The OML_sync_control spec says these should "generate a GLX_BAD_VALUE
    * error", but it also says "It [glXSwapBuffersMscOML] will return a value
    * of -1 if the function failed because of errors detected in the input
    * parameters"
    */
   if (divisor < 0 || remainder < 0 || target_msc < 0)
      return -1;
   if (divisor > 0 && remainder >= divisor)
      return -1;

   if (target_msc == 0 && divisor == 0 && remainder == 0)
      remainder = 1;

#ifdef GLX_DIRECT_RENDERING
   if (psc->driScreen && psc->driScreen->swapBuffers)
      return (*psc->driScreen->swapBuffers)(pdraw, target_msc, divisor,
					    remainder, False);
#endif

   return -1;
}


static Bool
__glXWaitForMscOML(Display * dpy, GLXDrawable drawable,
                   int64_t target_msc, int64_t divisor,
                   int64_t remainder, int64_t * ust,
                   int64_t * msc, int64_t * sbc)
{
#ifdef GLX_DIRECT_RENDERING
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
   struct glx_screen *psc = pdraw ? pdraw->psc : NULL;
   int ret;
#endif


   /* The OML_sync_control spec says these should "generate a GLX_BAD_VALUE
    * error", but the return type in the spec is Bool.
    */
   if (divisor < 0 || remainder < 0 || target_msc < 0)
      return False;
   if (divisor > 0 && remainder >= divisor)
      return False;

#ifdef GLX_DIRECT_RENDERING
   if (pdraw && psc->driScreen && psc->driScreen->waitForMSC) {
      ret = psc->driScreen->waitForMSC(pdraw, target_msc, divisor, remainder,
				       ust, msc, sbc);
      return ret;
   }
#endif

   return False;
}


static Bool
__glXWaitForSbcOML(Display * dpy, GLXDrawable drawable,
                   int64_t target_sbc, int64_t * ust,
                   int64_t * msc, int64_t * sbc)
{
#ifdef GLX_DIRECT_RENDERING
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
   struct glx_screen *psc = pdraw ? pdraw->psc : NULL;
   int ret;
#endif

   /* The OML_sync_control spec says this should "generate a GLX_BAD_VALUE
    * error", but the return type in the spec is Bool.
    */
   if (target_sbc < 0)
      return False;

#ifdef GLX_DIRECT_RENDERING
   if (pdraw && psc->driScreen && psc->driScreen->waitForSBC) {
      ret = psc->driScreen->waitForSBC(pdraw, target_sbc, ust, msc, sbc);
      return ret;
   }
#endif

   return False;
}

/*@@}*/


/**
 * Mesa extension stubs.  These will help reduce portability problems.
 */
/*@@{*/

/**
 * Release all buffers associated with the specified GLX drawable.
 *
 * \todo
 * This function was intended for stand-alone Mesa.  The issue there is that
 * the library doesn't get any notification when a window is closed.  In
 * DRI there is a similar but slightly different issue.  When GLX 1.3 is
 * supported, there are 3 different functions to destroy a drawable.  It
 * should be possible to create GLX protocol (or have it determine which
 * protocol to use based on the type of the drawable) to have one function
 * do the work of 3.  For the direct-rendering case, this function could
 * just call the driver's \c __DRIdrawableRec::destroyDrawable function.
 * This would reduce the frequency with which \c __driGarbageCollectDrawables
 * would need to be used.  This really should be done as part of the new DRI
 * interface work.
 *
 * \sa http://oss.sgi.com/projects/ogl-sample/registry/MESA/release_buffers.txt
 *     __driGarbageCollectDrawables
 *     glXDestroyGLXPixmap
 *     glXDestroyPbuffer glXDestroyPixmap glXDestroyWindow
 *     glXDestroyGLXPbufferSGIX glXDestroyGLXVideoSourceSGIX
 */
static Bool
__glXReleaseBuffersMESA(Display * dpy, GLXDrawable d)
{
   (void) dpy;
   (void) d;
   return False;
}


_X_EXPORT GLXPixmap
glXCreateGLXPixmapMESA(Display * dpy, XVisualInfo * visual,
                       Pixmap pixmap, Colormap cmap)
{
   (void) dpy;
   (void) visual;
   (void) pixmap;
   (void) cmap;
   return 0;
}

/*@@}*/


/**
 * GLX_MESA_copy_sub_buffer
 */
#define X_GLXvop_CopySubBufferMESA 5154 /* temporary */
static void
__glXCopySubBufferMESA(Display * dpy, GLXDrawable drawable,
                       int x, int y, int width, int height)
{
   xGLXVendorPrivateReq *req;
   struct glx_context *gc;
   GLXContextTag tag;
   CARD32 *drawable_ptr;
   INT32 *x_ptr, *y_ptr, *w_ptr, *h_ptr;
   CARD8 opcode;

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
   if (pdraw != NULL) {
      struct glx_screen *psc = pdraw->psc;
      if (psc->driScreen->copySubBuffer != NULL) {
         (*psc->driScreen->copySubBuffer) (pdraw, x, y, width, height, True);
      }

      return;
   }
#endif

   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
      return;

   /*
    ** The calling thread may or may not have a current context.  If it
    ** does, send the context tag so the server can do a flush.
    */
   gc = __glXGetCurrentContext();
   if ((gc != NULL) && (dpy == gc->currentDpy) &&
       ((drawable == gc->currentDrawable) ||
        (drawable == gc->currentReadable))) {
      tag = gc->currentContextTag;
   }
   else {
      tag = 0;
   }

   LockDisplay(dpy);
   GetReqExtra(GLXVendorPrivate, sizeof(CARD32) + sizeof(INT32) * 4, req);
   req->reqType = opcode;
   req->glxCode = X_GLXVendorPrivate;
   req->vendorCode = X_GLXvop_CopySubBufferMESA;
   req->contextTag = tag;

   drawable_ptr = (CARD32 *) (req + 1);
   x_ptr = (INT32 *) (drawable_ptr + 1);
   y_ptr = (INT32 *) (drawable_ptr + 2);
   w_ptr = (INT32 *) (drawable_ptr + 3);
   h_ptr = (INT32 *) (drawable_ptr + 4);

   *drawable_ptr = drawable;
   *x_ptr = x;
   *y_ptr = y;
   *w_ptr = width;
   *h_ptr = height;

   UnlockDisplay(dpy);
   SyncHandle();
}

/*@@{*/
static void
__glXBindTexImageEXT(Display * dpy,
                     GLXDrawable drawable, int buffer, const int *attrib_list)
{
   struct glx_context *gc = __glXGetCurrentContext();

   if (gc == NULL || gc->vtable->bind_tex_image == NULL)
      return;

   gc->vtable->bind_tex_image(dpy, drawable, buffer, attrib_list);
}

static void
__glXReleaseTexImageEXT(Display * dpy, GLXDrawable drawable, int buffer)
{
   struct glx_context *gc = __glXGetCurrentContext();

   if (gc == NULL || gc->vtable->release_tex_image == NULL)
      return;

   gc->vtable->release_tex_image(dpy, drawable, buffer);
}

/*@@}*/

#endif /* GLX_USE_APPLEGL */

/**
 * \c strdup is actually not a standard ANSI C or POSIX routine.
 * Irix will not define it if ANSI mode is in effect.
 *
 * \sa strdup
 */
_X_HIDDEN char *
__glXstrdup(const char *str)
{
   char *copy;
   copy = malloc(strlen(str) + 1);
   if (!copy)
      return NULL;
   strcpy(copy, str);
   return copy;
}

/*
** glXGetProcAddress support
*/

struct name_address_pair
{
   const char *Name;
   GLvoid *Address;
};

#define GLX_FUNCTION(f) { # f, (GLvoid *) f }
#define GLX_FUNCTION2(n,f) { # n, (GLvoid *) f }

static const struct name_address_pair GLX_functions[] = {
   /*** GLX_VERSION_1_0 ***/
   GLX_FUNCTION(glXChooseVisual),
   GLX_FUNCTION(glXCopyContext),
   GLX_FUNCTION(glXCreateContext),
   GLX_FUNCTION(glXCreateGLXPixmap),
   GLX_FUNCTION(glXDestroyContext),
   GLX_FUNCTION(glXDestroyGLXPixmap),
   GLX_FUNCTION(glXGetConfig),
   GLX_FUNCTION(glXGetCurrentContext),
   GLX_FUNCTION(glXGetCurrentDrawable),
   GLX_FUNCTION(glXIsDirect),
   GLX_FUNCTION(glXMakeCurrent),
   GLX_FUNCTION(glXQueryExtension),
   GLX_FUNCTION(glXQueryVersion),
   GLX_FUNCTION(glXSwapBuffers),
   GLX_FUNCTION(glXUseXFont),
   GLX_FUNCTION(glXWaitGL),
   GLX_FUNCTION(glXWaitX),

   /*** GLX_VERSION_1_1 ***/
   GLX_FUNCTION(glXGetClientString),
   GLX_FUNCTION(glXQueryExtensionsString),
   GLX_FUNCTION(glXQueryServerString),

   /*** GLX_VERSION_1_2 ***/
   GLX_FUNCTION(glXGetCurrentDisplay),

   /*** GLX_VERSION_1_3 ***/
   GLX_FUNCTION(glXChooseFBConfig),
   GLX_FUNCTION(glXCreateNewContext),
   GLX_FUNCTION(glXCreatePbuffer),
   GLX_FUNCTION(glXCreatePixmap),
   GLX_FUNCTION(glXCreateWindow),
   GLX_FUNCTION(glXDestroyPbuffer),
   GLX_FUNCTION(glXDestroyPixmap),
   GLX_FUNCTION(glXDestroyWindow),
   GLX_FUNCTION(glXGetCurrentReadDrawable),
   GLX_FUNCTION(glXGetFBConfigAttrib),
   GLX_FUNCTION(glXGetFBConfigs),
   GLX_FUNCTION(glXGetSelectedEvent),
   GLX_FUNCTION(glXGetVisualFromFBConfig),
   GLX_FUNCTION(glXMakeContextCurrent),
   GLX_FUNCTION(glXQueryContext),
   GLX_FUNCTION(glXQueryDrawable),
   GLX_FUNCTION(glXSelectEvent),

#ifndef GLX_USE_APPLEGL
   /*** GLX_SGI_swap_control ***/
   GLX_FUNCTION2(glXSwapIntervalSGI, __glXSwapIntervalSGI),

   /*** GLX_SGI_video_sync ***/
   GLX_FUNCTION2(glXGetVideoSyncSGI, __glXGetVideoSyncSGI),
   GLX_FUNCTION2(glXWaitVideoSyncSGI, __glXWaitVideoSyncSGI),

   /*** GLX_SGI_make_current_read ***/
   GLX_FUNCTION2(glXMakeCurrentReadSGI, glXMakeContextCurrent),
   GLX_FUNCTION2(glXGetCurrentReadDrawableSGI, glXGetCurrentReadDrawable),

   /*** GLX_EXT_import_context ***/
   GLX_FUNCTION(glXFreeContextEXT),
   GLX_FUNCTION(glXGetContextIDEXT),
   GLX_FUNCTION2(glXGetCurrentDisplayEXT, glXGetCurrentDisplay),
   GLX_FUNCTION(glXImportContextEXT),
   GLX_FUNCTION2(glXQueryContextInfoEXT, glXQueryContext),
#endif

   /*** GLX_SGIX_fbconfig ***/
   GLX_FUNCTION2(glXGetFBConfigAttribSGIX, glXGetFBConfigAttrib),
   GLX_FUNCTION2(glXChooseFBConfigSGIX, glXChooseFBConfig),
   GLX_FUNCTION(glXCreateGLXPixmapWithConfigSGIX),
   GLX_FUNCTION(glXCreateContextWithConfigSGIX),
   GLX_FUNCTION2(glXGetVisualFromFBConfigSGIX, glXGetVisualFromFBConfig),
   GLX_FUNCTION(glXGetFBConfigFromVisualSGIX),

#ifndef GLX_USE_APPLEGL
   /*** GLX_SGIX_pbuffer ***/
   GLX_FUNCTION(glXCreateGLXPbufferSGIX),
   GLX_FUNCTION(glXDestroyGLXPbufferSGIX),
   GLX_FUNCTION(glXQueryGLXPbufferSGIX),
   GLX_FUNCTION(glXSelectEventSGIX),
   GLX_FUNCTION(glXGetSelectedEventSGIX),

   /*** GLX_SGIX_swap_group ***/
   GLX_FUNCTION2(glXJoinSwapGroupSGIX, __glXJoinSwapGroupSGIX),

   /*** GLX_SGIX_swap_barrier ***/
   GLX_FUNCTION2(glXBindSwapBarrierSGIX, __glXBindSwapBarrierSGIX),
   GLX_FUNCTION2(glXQueryMaxSwapBarriersSGIX, __glXQueryMaxSwapBarriersSGIX),

   /*** GLX_MESA_copy_sub_buffer ***/
   GLX_FUNCTION2(glXCopySubBufferMESA, __glXCopySubBufferMESA),

   /*** GLX_MESA_pixmap_colormap ***/
   GLX_FUNCTION(glXCreateGLXPixmapMESA),

   /*** GLX_MESA_release_buffers ***/
   GLX_FUNCTION2(glXReleaseBuffersMESA, __glXReleaseBuffersMESA),

   /*** GLX_MESA_swap_control ***/
   GLX_FUNCTION2(glXSwapIntervalMESA, __glXSwapIntervalMESA),
   GLX_FUNCTION2(glXGetSwapIntervalMESA, __glXGetSwapIntervalMESA),
#endif

   /*** GLX_ARB_get_proc_address ***/
   GLX_FUNCTION(glXGetProcAddressARB),

   /*** GLX 1.4 ***/
   GLX_FUNCTION2(glXGetProcAddress, glXGetProcAddressARB),

#ifndef GLX_USE_APPLEGL
   /*** GLX_OML_sync_control ***/
   GLX_FUNCTION2(glXWaitForSbcOML, __glXWaitForSbcOML),
   GLX_FUNCTION2(glXWaitForMscOML, __glXWaitForMscOML),
   GLX_FUNCTION2(glXSwapBuffersMscOML, __glXSwapBuffersMscOML),
   GLX_FUNCTION2(glXGetMscRateOML, __glXGetMscRateOML),
   GLX_FUNCTION2(glXGetSyncValuesOML, __glXGetSyncValuesOML),

   /*** GLX_EXT_texture_from_pixmap ***/
   GLX_FUNCTION2(glXBindTexImageEXT, __glXBindTexImageEXT),
   GLX_FUNCTION2(glXReleaseTexImageEXT, __glXReleaseTexImageEXT),
#endif

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   /*** DRI configuration ***/
   GLX_FUNCTION(glXGetScreenDriver),
   GLX_FUNCTION(glXGetDriverConfig),
#endif

   /*** GLX_ARB_create_context and GLX_ARB_create_context_profile ***/
   GLX_FUNCTION(glXCreateContextAttribsARB),

   /*** GLX_MESA_query_renderer ***/
   GLX_FUNCTION(glXQueryRendererIntegerMESA),
   GLX_FUNCTION(glXQueryRendererStringMESA),
   GLX_FUNCTION(glXQueryCurrentRendererIntegerMESA),
   GLX_FUNCTION(glXQueryCurrentRendererStringMESA),

   {NULL, NULL}                 /* end of list */
};

static const GLvoid *
get_glx_proc_address(const char *funcName)
{
   GLuint i;

   /* try static functions */
   for (i = 0; GLX_functions[i].Name; i++) {
      if (strcmp(GLX_functions[i].Name, funcName) == 0)
         return GLX_functions[i].Address;
   }

   return NULL;
}

/**
 * Get the address of a named GL function.  This is the pre-GLX 1.4 name for
 * \c glXGetProcAddress.
 *
 * \param procName  Name of a GL or GLX function.
 * \returns         A pointer to the named function
 *
 * \sa glXGetProcAddress
 */
_X_EXPORT void (*glXGetProcAddressARB(const GLubyte * procName)) (void)
{
   typedef void (*gl_function) (void);
   gl_function f;


   /* Search the table of GLX and internal functions first.  If that
    * fails and the supplied name could be a valid core GL name, try
    * searching the core GL function table.  This check is done to prevent
    * DRI based drivers from searching the core GL function table for
    * internal API functions.
    */
   f = (gl_function) get_glx_proc_address((const char *) procName);
   if ((f == NULL) && (procName[0] == 'g') && (procName[1] == 'l')
       && (procName[2] != 'X')) {
#ifdef GLX_SHARED_GLAPI
      f = (gl_function) __indirect_get_proc_address((const char *) procName);
#endif
      if (!f)
         f = (gl_function) _glapi_get_proc_address((const char *) procName);
      if (!f) {
         struct glx_context *gc = __glXGetCurrentContext();
      
         if (gc != NULL && gc->vtable->get_proc_address != NULL)
            f = gc->vtable->get_proc_address((const char *) procName);
      }
   }
   return f;
}

/**
 * Get the address of a named GL function.  This is the GLX 1.4 name for
 * \c glXGetProcAddressARB.
 *
 * \param procName  Name of a GL or GLX function.
 * \returns         A pointer to the named function
 *
 * \sa glXGetProcAddressARB
 */
_X_EXPORT void (*glXGetProcAddress(const GLubyte * procName)) (void)
#if defined(__GNUC__) && !defined(GLX_ALIAS_UNSUPPORTED)
   __attribute__ ((alias("glXGetProcAddressARB")));
#else
{
   return glXGetProcAddressARB(procName);
}
#endif /* __GNUC__ */


#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
/**
 * Get the unadjusted system time (UST).  Currently, the UST is measured in
 * microseconds since Epoc.  The actual resolution of the UST may vary from
 * system to system, and the units may vary from release to release.
 * Drivers should not call this function directly.  They should instead use
 * \c glXGetProcAddress to obtain a pointer to the function.
 *
 * \param ust Location to store the 64-bit UST
 * \returns Zero on success or a negative errno value on failure.
 *
 * \sa glXGetProcAddress, PFNGLXGETUSTPROC
 *
 * \since Internal API version 20030317.
 */
_X_HIDDEN int
__glXGetUST(int64_t * ust)
{
   struct timeval tv;

   if (ust == NULL) {
      return -EFAULT;
   }

   if (gettimeofday(&tv, NULL) == 0) {
      ust[0] = (tv.tv_sec * 1000000) + tv.tv_usec;
      return 0;
   }
   else {
      return -errno;
   }
}
#endif /* GLX_DIRECT_RENDERING */
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d44 2
a45 2
#include "apple/apple_glx_context.h"
#include "apple/apple_glx.h"
d2584 1
a2584 1
#if defined(GLX_DIRECT_RENDERING) && defined(GLX_USE_DRM)
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d44 2
a45 2
#include "apple_glx_context.h"
#include "apple_glx.h"
d2584 1
a2584 1
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
@


1.5
log
@Merge Mesa 9.2.5
@
text
@a50 1
#include "xf86dri.h"
a51 1
#else
d386 3
a388 1
   config = glx_config_find_visual(psc->visuals, vis->visualid);
d697 7
a734 1
      struct glx_display *const priv = __glXInitialize(dpy);
d808 1
a808 1
      if (pdraw != NULL) {
d926 1
a926 5
      /* allow any kind of drawable, including those for off-screen buffers */
      config->drawableType = 0;
   } else {
       /* allow configs which support on-screen drawing */
       config->drawableType = GLX_WINDOW_BIT;
d929 1
a937 2
   /* Set GLX_RENDER_TYPE property to not expect any flags by default. */
   config->renderType = 0;
d1106 1
a1106 1
    * the GLX 1.3 spec and ARB_multisample.
d1135 3
a1150 6
   /* None of the multisample specs say where this comparison should happen,
    * so I put it near the end.
    */
   PREFER_SMALLER(sampleBuffers);
   PREFER_SMALLER(samples);

a1380 13
void
__glXClientInfo(Display * dpy, int opcode)
{
   char *ext_str = __glXGetClientGLExtensionString();
   int size = strlen(ext_str) + 1;

   xcb_connection_t *c = XGetXCBConnection(dpy);
   xcb_glx_client_info(c,
                       GLX_MAJOR_VERSION, GLX_MINOR_VERSION, size, ext_str);

   free(ext_str);
}

d1422 3
d1741 2
a1742 1
   if (gc->isDirect && psc->driScreen && psc->driScreen->setSwapInterval) {
d1788 1
a1788 1
      if (psc->driScreen && psc->driScreen->setSwapInterval) {
d1810 1
a1810 1
      if (psc->driScreen && psc->driScreen->getSwapInterval) {
d1854 1
a1854 1
   if (psc->driScreen && psc->driScreen->getDrawableMSC) {
d1892 1
a1892 1
   if (psc->driScreen && psc->driScreen->waitForMSC) {
d2087 1
a2087 1
__glxGetMscRate(__GLXDRIdrawable *glxDraw,
a2090 1
   struct glx_screen *psc;
a2094 1
   psc = glxDraw->psc;
d2170 1
a2170 1
   return __glxGetMscRate(draw, numerator, denominator);
d2592 6
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d186 1
a186 1
   if ((*ppsc)->configs == NULL) {
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d40 1
a45 1
#include "glx_error.h"
a55 1
#if defined(USE_XCB)
a58 1
#endif
d91 45
d151 1
a151 1
static struct glx_screen *
d227 27
d260 1
a260 1
      return GL_FALSE;
d268 1
a268 1
   return GL_TRUE;
d372 1
a373 1
   gc->renderType = renderType;
d383 1
a383 1
   int renderType = 0;
d402 26
a427 1
   renderType = config->rgbMode ? GLX_RGBA_TYPE : GLX_COLOR_INDEX_TYPE;
d434 1
a434 1
_X_HIDDEN void
d452 3
a454 2
static void
DestroyContext(Display * dpy, GLXContext ctx)
d458 1
a458 1
   if (!gc)
d462 3
a470 2
      if (!gc->imported)
	 glx_send_destroy_context(dpy, gc->xid);
d472 2
a473 2
      __glXUnlock();
      return;
a475 8

   gc->vtable->destroy(gc);
}

_X_EXPORT void
glXDestroyContext(Display * dpy, GLXContext gc)
{
   DestroyContext(dpy, gc);
d489 1
a489 1
      return GL_FALSE;
d495 1
a495 1
   return GL_TRUE;
d623 1
a623 1
 * \returns \c GL_TRUE if the context is direct rendering or not.
a627 4
#if !defined(USE_XCB)
   xGLXIsDirectReq *req;
   xGLXIsDirectReply reply;
#endif
d629 4
d636 1
a636 1
      return GL_FALSE;
d639 8
a646 6
#ifdef USE_XCB
   xcb_connection_t *c = XGetXCBConnection(dpy);
   xcb_glx_is_direct_reply_t *reply = xcb_glx_is_direct_reply(c,
                                                              xcb_glx_is_direct
                                                              (c, contextID),
                                                              NULL);
a647 1
   const Bool is_direct = reply->is_direct ? True : False;
a650 13
#else
   /* Send the glXIsDirect request */
   LockDisplay(dpy);
   GetReq(GLXIsDirect, req);
   req->reqType = opcode;
   req->glxCode = X_GLXIsDirect;
   req->context = contextID;
   _XReply(dpy, (xReply *) & reply, 0, False);
   UnlockDisplay(dpy);
   SyncHandle();

   return reply.isDirect;
#endif /* USE_XCB */
d655 1
a655 1
 * Shouldn't this function \b always return \c GL_FALSE when
d665 1
a665 1
      return GL_FALSE;
d668 1
a668 1
      return GL_TRUE;
d671 1
a671 1
      return GL_FALSE;
d693 1
d702 4
d718 5
d735 2
a736 1
         break;
d741 1
d747 2
a748 1
         return None;           /* FIXME: Check what we're supposed to do here... */
d751 11
d795 2
a824 1
#ifdef USE_XCB
a825 3
#else
   xGLXSwapBuffersReq *req;
#endif
d830 5
a834 1
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
d836 2
a837 3
   if (pdraw != NULL) {
      if (gc && drawable == gc->currentDrawable) {
	 glFlush();
a838 3

      (*pdraw->psc->driScreen->swapBuffers)(pdraw, 0, 0, 0);
      return;
a859 1
#ifdef USE_XCB
a862 12
#else
   /* Send the glXSwapBuffers request */
   LockDisplay(dpy);
   GetReq(GLXSwapBuffers, req);
   req->reqType = opcode;
   req->glxCode = X_GLXSwapBuffers;
   req->drawable = drawable;
   req->contextTag = tag;
   UnlockDisplay(dpy);
   SyncHandle();
   XFlush(dpy);
#endif /* USE_XCB */
d897 1
a897 1
      *value_return = GL_FALSE;
d914 1
a914 1
   /* glXChooseFBConfig specifies different defaults for these two than
d920 5
d935 2
a936 3
   config->drawableType = GLX_WINDOW_BIT;
   config->renderType =
      (config->rgbMode) ? GLX_RGBA_BIT : GLX_COLOR_INDEX_BIT;
d969 2
a970 1
    if ((a->param & ~b->param) != 0)		\
d972 1
d1287 1
a1287 1
            Xfree(visualList);
a1388 1
#ifdef USE_XCB
a1391 14
#else
   xGLXClientInfoReq *req;

   /* Send the glXClientInfo request */
   LockDisplay(dpy);
   GetReq(GLXClientInfo, req);
   req->reqType = opcode;
   req->glxCode = X_GLXClientInfo;
   req->major = GLX_MAJOR_VERSION;
   req->minor = GLX_MINOR_VERSION;

   req->length += (size + 3) >> 2;
   req->numbytes = size;
   Data(dpy, ext_str, size);
d1393 1
a1393 5
   UnlockDisplay(dpy);
   SyncHandle();
#endif /* USE_XCB */

   Xfree(ext_str);
d1419 1
a1419 1
   struct glx_screen *psc;
d1423 6
a1428 1
   int propList[__GLX_MAX_CONTEXT_PROPS * 2], *pProp, nPropListBytes;
d1432 20
d1453 1
a1453 1
   if (contextID == None || __glXIsDirect(dpy, contextID))
d1496 1
a1496 8
   /* Look up screen first so we can look up visuals/fbconfigs later */
   psc = NULL;
   for (i = 0, pProp = propList; i < reply.n; i++, pProp += 2)
      if (pProp[0] == GLX_SCREEN)
	 psc = GetGLXScreenConfigs(dpy, pProp[1]);
   if (psc == NULL)
      return NULL;

d1499 1
a1499 1
   renderType = 0;
d1502 1
a1502 1
   for (i = 0, pProp = propList; i < reply.n; i++, pProp += 2)
d1504 4
d1512 1
a1512 1
	 mode = glx_config_find_visual(psc->visuals, pProp[1]);
d1515 1
a1515 1
	 mode = glx_config_find_fbconfig(psc->configs, pProp[1]);
d1522 13
d1587 1
a1587 1
   return ctx->xid;
d1591 1
a1591 1
glXFreeContextEXT(Display * dpy, GLXContext ctx)
d1593 20
a1612 1
   DestroyContext(dpy, ctx);
a1614 1

d1629 1
a1629 1
         XFree(config_list);
d1683 1
a1683 1
      config_list = Xmalloc(num_configs * sizeof *config_list);
d2228 1
a2228 1
					    remainder);
d2368 1
a2368 2
         glFlush();
         (*psc->driScreen->copySubBuffer) (pdraw, x, y, width, height);
d2454 1
a2454 1
   copy = (char *) Xmalloc(strlen(str) + 1);
d2602 3
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d39 1
d203 1
a203 2
 * Create a new context.  Exactly one of \c vis and \c fbconfig should be
 * non-NULL.
a204 2
 * \param use_glx_1_3  For FBConfigs, should GLX 1.3 protocol or
 *                     SGIX_fbconfig protocol be used?
d209 2
a210 4
CreateContext(Display * dpy, int generic_id,
              struct glx_config *config,
              GLXContext shareList_user,
              Bool allowDirect,
d380 1
a380 2
   if (gc->vtable->destroy)
      gc->vtable->destroy(gc);
d650 1
a650 1
      pdraw = psc->driScreen->createDrawable(psc, pixmap, req->glxpixmap, config);
d656 1
a656 1
      if (__glxHashInsert(priv->drawHash, req->glxpixmap, pdraw)) {
d728 2
d734 4
a737 1
      glFlush();
a751 1
   gc = __glXGetCurrentContext();
d1896 1
a1896 1
   if ((GetGLXPrivScreenConfig(dpy, vis->screen, &priv, &psc) != Success)
a2480 1
#ifndef GLX_USE_APPLEGL
a2493 1
#endif
a2515 3
#ifdef GLX_USE_APPLEGL
   f = (gl_function) apple_glx_get_proc_address(procName);
#else
d2519 11
a2529 1
      f = (gl_function) _glapi_get_proc_address((const char *) procName);
a2530 1
#endif
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a38 1
#include "glcontextmodes.h"
a44 1
#define GC_IS_DIRECT(gc) ((gc)->isDirect)
d47 1
d49 1
a50 1
#define GC_IS_DIRECT(gc) ((gc)->driContext != NULL)
a52 1
#define GC_IS_DIRECT(gc) (0)
a63 3

/****************************************************************************/

a65 49
static Bool windowExistsFlag;
static int
windowExistsErrorHandler(Display * dpy, XErrorEvent * xerr)
{
   (void) dpy;

   if (xerr->error_code == BadWindow) {
      windowExistsFlag = GL_FALSE;
   }
   return 0;
}

/**
 * Find drawables in the local hash that have been destroyed on the
 * server.
 *
 * \param dpy    Display to destroy drawables for
 * \param screen Screen number to destroy drawables for
 */
static void
GarbageCollectDRIDrawables(Display * dpy, __GLXscreenConfigs * sc)
{
   XID draw;
   __GLXDRIdrawable *pdraw;
   XWindowAttributes xwa;
   int (*oldXErrorHandler) (Display *, XErrorEvent *);

   /* Set no-op error handler so Xlib doesn't bail out if the windows
    * has alreay been destroyed on the server. */
   XSync(dpy, GL_FALSE);
   oldXErrorHandler = XSetErrorHandler(windowExistsErrorHandler);

   if (__glxHashFirst(sc->drawHash, &draw, (void *) &pdraw) == 1) {
      do {
         windowExistsFlag = GL_TRUE;
         XGetWindowAttributes(dpy, draw, &xwa); /* dummy request */
         if (!windowExistsFlag) {
            /* Destroy the local drawable data, if the drawable no
               longer exists in the Xserver */
            (*pdraw->destroyDrawable) (pdraw);
            __glxHashDelete(sc->drawHash, draw);
         }
      } while (__glxHashNext(sc->drawHash, &draw, (void *) &pdraw) == 1);
   }

   XSync(dpy, GL_FALSE);
   XSetErrorHandler(oldXErrorHandler);
}

d76 1
a76 1
GetGLXDRIDrawable(Display * dpy, GLXDrawable drawable, int *const scrn_num)
d78 1
a78 1
   __GLXdisplayPrivate *priv = __glXInitialize(dpy);
a79 3
   const unsigned screen_count = ScreenCount(dpy);
   unsigned i;
   __GLXscreenConfigs *psc;
d84 2
a85 11
   for (i = 0; i < screen_count; i++) {
      psc = &priv->screenConfigs[i];
      if (psc->drawHash == NULL)
         continue;

      if (__glxHashLookup(psc->drawHash, drawable, (void *) &pdraw) == 0) {
         if (scrn_num != NULL)
            *scrn_num = i;
         return pdraw;
      }
   }
d107 1
a107 1
static __GLXscreenConfigs *
d110 1
a110 1
   __GLXdisplayPrivate *const priv = __glXInitialize(dpy);
d113 2
a114 2
           && priv->screenConfigs !=
           NULL) ? &priv->screenConfigs[scrn] : NULL;
d119 2
a120 2
GetGLXPrivScreenConfig(Display * dpy, int scrn, __GLXdisplayPrivate ** ppriv,
                       __GLXscreenConfigs ** ppsc)
d141 1
a141 1
   *ppsc = &((*ppriv)->screenConfigs[scrn]);
d158 1
a158 1
 *          \c __GLcontextModes structure is returned.  Otherwise, \c NULL
d161 2
a162 2
static __GLcontextModes *
ValidateGLXFBConfig(Display * dpy, GLXFBConfig config)
d164 2
a165 2
   __GLXdisplayPrivate *const priv = __glXInitialize(dpy);
   const unsigned num_screens = ScreenCount(dpy);
d167 1
a167 2
   const __GLcontextModes *modes;

d171 6
a176 6
         for (modes = priv->screenConfigs[i].configs; modes != NULL;
              modes = modes->next) {
            if (modes == (__GLcontextModes *) config) {
               return (__GLcontextModes *) config;
            }
         }
d183 3
a185 13

/**
 * \todo It should be possible to move the allocate of \c client_state_private
 * later in the function for direct-rendering contexts.  Direct-rendering
 * contexts don't need to track client state, so they don't need that memory
 * at all.
 *
 * \todo Eliminate \c __glXInitVertexArrayState.  Replace it with a new
 * function called \c __glXAllocateClientState that allocates the memory and
 * does all the initialization (including the pixel pack / unpack).
 */
static GLXContext
AllocateGLXContext(Display * dpy)
d187 3
a189 4
   GLXContext gc;
   int bufSize;
   CARD8 opcode;
   __GLXattribute *state;
d191 5
a195 2
   if (!dpy)
      return NULL;
d197 1
a197 89
   opcode = __glXSetupForCommand(dpy);
   if (!opcode) {
      return NULL;
   }

   /* Allocate our context record */
   gc = (GLXContext) Xmalloc(sizeof(struct __GLXcontextRec));
   if (!gc) {
      /* Out of memory */
      return NULL;
   }
   memset(gc, 0, sizeof(struct __GLXcontextRec));

   state = Xmalloc(sizeof(struct __GLXattributeRec));
   if (state == NULL) {
      /* Out of memory */
      Xfree(gc);
      return NULL;
   }
   gc->client_state_private = state;
   memset(gc->client_state_private, 0, sizeof(struct __GLXattributeRec));
   state->NoDrawArraysProtocol = (getenv("LIBGL_NO_DRAWARRAYS") != NULL);

   /*
    ** Create a temporary buffer to hold GLX rendering commands.  The size
    ** of the buffer is selected so that the maximum number of GLX rendering
    ** commands can fit in a single X packet and still have room in the X
    ** packet for the GLXRenderReq header.
    */

   bufSize = (XMaxRequestSize(dpy) * 4) - sz_xGLXRenderReq;
   gc->buf = (GLubyte *) Xmalloc(bufSize);
   if (!gc->buf) {
      Xfree(gc->client_state_private);
      Xfree(gc);
      return NULL;
   }
   gc->bufSize = bufSize;

   /* Fill in the new context */
   gc->renderMode = GL_RENDER;

   state->storePack.alignment = 4;
   state->storeUnpack.alignment = 4;

   gc->attributes.stackPointer = &gc->attributes.stack[0];

   /*
    ** PERFORMANCE NOTE: A mode dependent fill image can speed things up.
    ** Other code uses the fastImageUnpack bit, but it is never set
    ** to GL_TRUE.
    */
   gc->fastImageUnpack = GL_FALSE;
   gc->fillImage = __glFillImage;
   gc->pc = gc->buf;
   gc->bufEnd = gc->buf + bufSize;
   gc->isDirect = GL_FALSE;
   if (__glXDebug) {
      /*
       ** Set limit register so that there will be one command per packet
       */
      gc->limit = gc->buf;
   }
   else {
      gc->limit = gc->buf + bufSize - __GLX_BUFFER_LIMIT_SIZE;
   }
   gc->createDpy = dpy;
   gc->majorOpcode = opcode;

   /*
    ** Constrain the maximum drawing command size allowed to be
    ** transfered using the X_GLXRender protocol request.  First
    ** constrain by a software limit, then constrain by the protocl
    ** limit.
    */
   if (bufSize > __GLX_RENDER_CMD_SIZE_LIMIT) {
      bufSize = __GLX_RENDER_CMD_SIZE_LIMIT;
   }
   if (bufSize > __GLX_MAX_RENDER_CMD_SIZE) {
      bufSize = __GLX_MAX_RENDER_CMD_SIZE;
   }
   gc->maxSmallRenderCommandSize = bufSize;
   
#ifdef GLX_USE_APPLEGL
   gc->driContext = NULL;
   gc->do_destroy = False;   
#endif

   return gc;
d212 2
a213 2
              const __GLcontextModes * const fbconfig,
              GLXContext shareList,
d217 3
a219 10
   GLXContext gc;
#ifdef GLX_DIRECT_RENDERING
#ifdef GLX_USE_APPLEGL
   int errorcode;
   bool x11error;
#else
   __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, screen);
#endif
#endif
    
d223 4
d230 9
a238 1
   gc = AllocateGLXContext(dpy);
a241 14
#ifndef GLX_USE_APPLEGL  /* TODO: darwin indirect */
#ifdef GLX_DIRECT_RENDERING
   if (allowDirect && psc->driScreen) {
      gc->driContext = psc->driScreen->createContext(psc, fbconfig, gc,
						     shareList, renderType);
      if (gc->driContext != NULL) {
	 gc->screen = screen;
	 gc->psc = psc;
	 gc->mode = fbconfig;
	 gc->isDirect = GL_TRUE;
      }
   }
#endif

d255 1
a255 1
      req->isDirect = GC_IS_DIRECT(gc);
d271 1
a271 1
      req->isDirect = GC_IS_DIRECT(gc);
d292 1
a292 1
      req->isDirect = GC_IS_DIRECT(gc);
a304 1
#endif
d309 1
a309 16
   /* TODO: darwin: Integrate with above to do indirect */
#ifdef GLX_USE_APPLEGL
   if(apple_glx_create_context(&gc->driContext, dpy, screen, fbconfig, 
                               shareList ? shareList->driContext : NULL,
                               &errorcode, &x11error)) {
      __glXSendError(dpy, errorcode, 0, X_GLXCreateContext, x11error);
      __glXFreeContext(gc);
      return NULL;
   }
   
   gc->currentContextTag = -1;
   gc->mode = fbconfig;
   gc->isDirect = allowDirect;
#endif

   return gc;
d312 1
a312 1
PUBLIC GLXContext
d316 1
a316 1
   const __GLcontextModes *mode = NULL;
d320 1
a320 1
   __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, vis->screen);
d322 2
a323 2
   mode = _gl_context_modes_find_visual(psc->visuals, vis->visualid);
   if (mode == NULL) {
d336 1
a336 1
   renderType = mode->rgbMode ? GLX_RGBA_TYPE : GLX_COLOR_INDEX_TYPE;
d339 1
a339 1
   return CreateContext(dpy, vis->visualid, mode, shareList, allowDirect,
d344 1
a344 1
__glXFreeContext(__GLXcontext * gc)
d346 2
a347 12
   if (gc->vendor)
      XFree((char *) gc->vendor);
   if (gc->renderer)
      XFree((char *) gc->renderer);
   if (gc->version)
      XFree((char *) gc->version);
   if (gc->extensions)
      XFree((char *) gc->extensions);
   __glFreeAttributeState(gc);
   XFree((char *) gc->buf);
   Xfree((char *) gc->client_state_private);
   XFree((char *) gc);
d349 7
d362 1
a362 1
DestroyContext(Display * dpy, GLXContext gc)
d364 1
a364 5
#ifndef GLX_USE_APPLEGL /* TODO: darwin: indirect */
   xGLXDestroyContextReq *req;
   GLXContextID xid;
   CARD8 opcode;
   GLboolean imported;
d366 1
a366 2
   opcode = __glXSetupForCommand(dpy);
   if (!opcode || !gc) {
a367 1
   }
a369 4
   xid = gc->xid;
   imported = gc->imported;
   gc->xid = None;

d376 3
d382 1
d384 2
a385 49
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   /* Destroy the direct rendering context */
   if (gc->driContext) {
      (*gc->driContext->destroyContext) (gc->driContext, gc->psc, dpy);
      gc->driContext = NULL;
      GarbageCollectDRIDrawables(dpy, gc->psc);
   }
#endif

   __glXFreeVertexArrayState(gc);
#else
   __glXLock();
#endif /* GLX_USE_APPLEGL */   

   if (gc->currentDpy) {
#ifdef GLX_USE_APPLEGL
      /* 
       * Set the Bool that indicates that we should destroy this GLX context
       * when the context is no longer current.
       */
      gc->do_destroy = True;
#endif
      /* Have to free later cuz it's in use now */
      __glXUnlock();
   }
   else {
      /* Destroy the handle if not current to anybody */
      __glXUnlock();
#ifdef GLX_USE_APPLEGL
      if(gc->driContext)
         apple_glx_destroy_context(&gc->driContext, dpy);
#endif
      __glXFreeContext(gc);
   }
#ifndef GLX_USE_APPLEGL
   if (!imported) {
      /*
       ** This dpy also created the server side part of the context.
       ** Send the glXDestroyContext request.
       */
      LockDisplay(dpy);
      GetReq(GLXDestroyContext, req);
      req->reqType = opcode;
      req->glxCode = X_GLXDestroyContext;
      req->context = xid;
      UnlockDisplay(dpy);
      SyncHandle();
   }
#endif
d388 1
a388 1
PUBLIC void
d397 1
a397 1
PUBLIC Bool
d400 1
a400 1
   __GLXdisplayPrivate *priv;
d417 1
a417 1
PUBLIC Bool
d437 1
a437 1
PUBLIC void
d440 1
a440 8
#ifndef GLX_USE_APPLEGL
   xGLXWaitGLReq *req;
#endif
   GLXContext gc = __glXGetCurrentContext();
   Display *dpy = gc->currentDpy;

   if (!dpy)
      return;
d442 2
a443 30
   /* Flush any pending commands out */
   __glXFlushRenderBuffer(gc, gc->pc);
#ifdef GLX_USE_APPLEGL
   glFinish();
#else
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   if (gc->driContext) {
      int screen;
      __GLXDRIdrawable *pdraw =
         GetGLXDRIDrawable(dpy, gc->currentDrawable, &screen);

      if (pdraw != NULL) {
         __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, screen);
         glFlush();
         if (psc->driScreen->waitGL != NULL)
            (*psc->driScreen->waitGL) (pdraw);
      }
      return;
   }
#endif

   /* Send the glXWaitGL request */
   LockDisplay(dpy);
   GetReq(GLXWaitGL, req);
   req->reqType = gc->majorOpcode;
   req->glxCode = X_GLXWaitGL;
   req->contextTag = gc->currentContextTag;
   UnlockDisplay(dpy);
   SyncHandle();
#endif /* GLX_USE_APPLEGL */
d450 1
a450 1
PUBLIC void
d453 1
a453 8
#ifndef GLX_USE_APPLEGL
   xGLXWaitXReq *req;
#endif
   GLXContext gc = __glXGetCurrentContext();
   Display *dpy = gc->currentDpy;

   if (!dpy)
      return;
d455 2
a456 34
   /* Flush any pending commands out */
   __glXFlushRenderBuffer(gc, gc->pc);

#ifdef GLX_USE_APPLEGL
   apple_glx_waitx(dpy, gc->driContext);
#else
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   if (gc->driContext) {
      int screen;
      __GLXDRIdrawable *pdraw =
         GetGLXDRIDrawable(dpy, gc->currentDrawable, &screen);

      if (pdraw != NULL) {
         __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, screen);
         if (psc->driScreen->waitX != NULL)
            (*psc->driScreen->waitX) (pdraw);
      }
      else
         XSync(dpy, False);
      return;
   }
#endif

   /*
    ** Send the glXWaitX request.
    */
   LockDisplay(dpy);
   GetReq(GLXWaitX, req);
   req->reqType = gc->majorOpcode;
   req->glxCode = X_GLXWaitX;
   req->contextTag = gc->currentContextTag;
   UnlockDisplay(dpy);
   SyncHandle();
#endif /* GLX_USE_APPLEGL */
d459 1
a459 1
PUBLIC void
d462 1
a462 5
#ifndef GLX_USE_APPLEGL
   xGLXUseXFontReq *req;
#endif
   GLXContext gc = __glXGetCurrentContext();
   Display *dpy = gc->currentDpy;
d464 2
a465 28
   if (!dpy)
      return;

   /* Flush any pending commands out */
   (void) __glXFlushRenderBuffer(gc, gc->pc);
#ifdef GLX_USE_APPLEGL
   DRI_glXUseXFont(font, first, count, listBase); 
#else
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   if (gc->driContext) {
      DRI_glXUseXFont(font, first, count, listBase);
      return;
   }
#endif

   /* Send the glXUseFont request */
   LockDisplay(dpy);
   GetReq(GLXUseXFont, req);
   req->reqType = gc->majorOpcode;
   req->glxCode = X_GLXUseXFont;
   req->contextTag = gc->currentContextTag;
   req->font = font;
   req->first = first;
   req->count = count;
   req->listBase = listBase;
   UnlockDisplay(dpy);
   SyncHandle();
#endif /* GLX_USE_APPLEGL */
d474 3
a476 3
PUBLIC void
glXCopyContext(Display * dpy, GLXContext source,
               GLXContext dest, unsigned long mask)
d478 2
d481 1
a481 1
   GLXContext gc = __glXGetCurrentContext();
d492 1
a492 1
   GLXContext gc = __glXGetCurrentContext();
d502 1
a502 1
   if (gc->driContext) {
d587 2
a588 2
PUBLIC Bool
glXIsDirect(Display * dpy, GLXContext gc)
d590 2
d595 1
a595 1
   else if (GC_IS_DIRECT(gc)) {
d605 1
a605 1
PUBLIC GLXPixmap
d610 2
a611 2
   __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, screen);
   const __GLcontextModes *modes;
d613 1
a613 1
   modes = _gl_context_modes_find_visual(psc->visuals, vis->visualid);
d615 1
a615 1
   if(apple_glx_pixmap_create(dpy, vis->screen, pixmap, modes))
d646 1
a646 1
      __GLXdisplayPrivate *const priv = __glXInitialize(dpy);
d648 2
a649 2
      __GLXscreenConfigs *psc;
      __GLcontextModes *modes;
d651 1
a651 1
      psc = &priv->screenConfigs[vis->screen];
d654 2
a655 2
      modes = _gl_context_modes_find_visual(psc->visuals, vis->visualid);
      pdraw = psc->driScreen->createDrawable(psc, pixmap, req->glxpixmap, modes);
d661 1
a661 1
      if (__glxHashInsert(psc->drawHash, req->glxpixmap, pdraw)) {
d675 1
a675 1
PUBLIC void
d701 2
a702 4
      int screen;
      __GLXdisplayPrivate *const priv = __glXInitialize(dpy);
      __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, glxpixmap, &screen);
      __GLXscreenConfigs *psc = &priv->screenConfigs[screen];
d706 1
a706 1
         __glxHashDelete(psc->drawHash, glxpixmap);
d713 1
a713 1
PUBLIC void
d717 1
a717 1
   GLXContext gc = glXGetCurrentContext();
d724 1
a724 1
   GLXContext gc;
d734 1
a734 1
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable, NULL);
d786 1
a786 1
PUBLIC int
d790 3
a792 3
   __GLXdisplayPrivate *priv;
   __GLXscreenConfigs *psc;
   __GLcontextModes *modes;
d797 1
a797 1
      modes = _gl_context_modes_find_visual(psc->visuals, vis->visualid);
d800 2
a801 2
      if (modes != NULL) {
         return _gl_get_context_mode_data(modes, attribute, value_return);
d822 1
a822 1
init_fbconfig_for_chooser(__GLcontextModes * config,
d825 1
a825 1
   memset(config, 0, sizeof(__GLcontextModes));
d891 2
a892 2
fbconfigs_compatible(const __GLcontextModes * const a,
                     const __GLcontextModes * const b)
d1011 1
a1011 2
fbconfig_compare(const __GLcontextModes * const *const a,
                 const __GLcontextModes * const *const b)
d1096 1
a1096 1
choose_visual(__GLcontextModes ** configs, int num_configs,
d1099 1
a1099 1
   __GLcontextModes test_config;
d1135 1
a1135 1
   qsort(configs, base, sizeof(__GLcontextModes *),
d1147 1
a1147 1
PUBLIC XVisualInfo *
d1151 5
a1155 5
   __GLXdisplayPrivate *priv;
   __GLXscreenConfigs *psc;
   __GLcontextModes test_config;
   __GLcontextModes *modes;
   const __GLcontextModes *best_config = NULL;
d1182 4
a1185 7
   for (modes = psc->visuals; modes != NULL; modes = modes->next) {
      if (fbconfigs_compatible(&test_config, modes)
          && ((best_config == NULL)
              ||
              (fbconfig_compare
               ((const __GLcontextModes * const *const) &modes,
                &best_config) < 0))) {
d1191 1
a1191 1
         visualTemplate.visualid = modes->visualID;
d1198 1
a1198 1
            best_config = modes;
d1213 1
a1213 1
PUBLIC const char *
d1216 2
a1217 2
   __GLXscreenConfigs *psc;
   __GLXdisplayPrivate *priv;
d1242 1
a1242 1
PUBLIC const char *
d1259 1
a1259 1
PUBLIC const char *
d1262 2
a1263 2
   __GLXscreenConfigs *psc;
   __GLXdisplayPrivate *priv;
d1329 1
a1329 1
PUBLIC Display *
d1332 1
a1332 1
   GLXContext gc = __glXGetCurrentContext();
d1338 1
a1338 1
PUBLIC
d1343 2
a1344 15
/**
 * Used internally by libGL to send \c xGLXQueryContextinfoExtReq requests
 * to the X-server.
 *
 * \param dpy  Display where \c ctx was created.
 * \param ctx  Context to query.
 * \returns  \c Success on success.  \c GLX_BAD_CONTEXT if \c ctx is invalid,
 *           or zero if the request failed due to internal problems (i.e.,
 *           unable to allocate temporary memory, etc.)
 *
 * \note
 * This function dynamically determines whether to use the EXT_import_context
 * version of the protocol or the GLX 1.3 version of the protocol.
 */
static int __glXQueryContextInfo(Display * dpy, GLXContext ctx)
d1346 2
a1347 1
   __GLXdisplayPrivate *priv = __glXInitialize(dpy);
d1350 8
a1357 2
   GLuint numValues;
   int retval;
a1358 3
   if (ctx == NULL) {
      return GLX_BAD_CONTEXT;
   }
d1360 1
a1360 1
   if (!opcode) {
a1361 1
   }
d1366 1
a1366 1
   if ((priv->majorVersion > 1) || (priv->minorVersion >= 3)) {
d1373 1
a1373 1
      req->context = (unsigned int) (ctx->xid);
d1380 2
a1381 2
                  sz_xGLXQueryContextInfoEXTReq - sz_xGLXVendorPrivateReq,
                  vpreq);
d1386 1
a1386 1
      req->context = (unsigned int) (ctx->xid);
d1391 20
a1410 8
   numValues = reply.n;
   if (numValues == 0)
      retval = Success;
   else if (numValues > __GLX_MAX_CONTEXT_PROPS)
      retval = 0;
   else {
      int *propList, *pProp;
      int nPropListBytes;
d1412 14
a1425 4
      nPropListBytes = numValues << 3;
      propList = (int *) Xmalloc(nPropListBytes);
      if (NULL == propList) {
         retval = 0;
a1426 2
      else {
	 unsigned i;
d1428 10
a1437 1
         _XRead(dpy, (char *) propList, nPropListBytes);
d1439 1
a1439 39
	 /* Look up screen first so we can look up visuals/fbconfigs later */
         pProp = propList;
         for (i = 0; i < numValues; i++, pProp += 2)
	     if (pProp[0] == GLX_SCREEN) {
		 ctx->screen = pProp[1];
		 ctx->psc = GetGLXScreenConfigs(dpy, ctx->screen);
	     }

         pProp = propList;
         for (i = 0; i < numValues; i++) {
            switch (*pProp++) {
            case GLX_SHARE_CONTEXT_EXT:
               ctx->share_xid = *pProp++;
               break;
            case GLX_VISUAL_ID_EXT:
               ctx->mode =
                  _gl_context_modes_find_visual(ctx->psc->visuals, *pProp++);
               break;
            case GLX_FBCONFIG_ID:
               ctx->mode =
                  _gl_context_modes_find_fbconfig(ctx->psc->configs,
                                                  *pProp++);
               break;
            case GLX_RENDER_TYPE:
               ctx->renderType = *pProp++;
               break;
            case GLX_SCREEN:
            default:
               pProp++;
               continue;
            }
         }
         Xfree((char *) propList);
         retval = Success;
      }
   }
   UnlockDisplay(dpy);
   SyncHandle();
   return retval;
d1444 2
a1445 2
PUBLIC int
glXQueryContext(Display * dpy, GLXContext ctx, int attribute, int *value)
d1447 1
a1447 14
#ifndef GLX_USE_APPLEGL
   int retVal;

   /* get the information from the server if we don't have it already */
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   if (!ctx->driContext && (ctx->mode == NULL)) {
#else
   if (ctx->mode == NULL) {
#endif
      retVal = __glXQueryContextInfo(dpy, ctx);
      if (Success != retVal)
         return retVal;
   }
#endif
a1449 1
#ifndef GLX_USE_APPLEGL
d1451 1
a1451 1
      *value = (int) (ctx->share_xid);
d1454 1
a1454 1
      *value = ctx->mode ? ctx->mode->visualID : None;
a1455 1
#endif
d1457 1
a1457 1
      *value = (int) (ctx->screen);
d1460 1
a1460 1
      *value = ctx->mode ? ctx->mode->fbconfigID : None;
d1463 1
a1463 1
      *value = (int) (ctx->renderType);
d1471 1
a1471 1
PUBLIC
d1476 1
a1476 1
PUBLIC GLXContextID glXGetContextIDEXT(const GLXContext ctx)
d1478 2
d1483 1
a1483 30
PUBLIC GLXContext
glXImportContextEXT(Display * dpy, GLXContextID contextID)
{
#ifdef GLX_USE_APPLEGL
   return NULL;
#else
   GLXContext ctx;

   if (contextID == None) {
      return NULL;
   }
   if (__glXIsDirect(dpy, contextID)) {
      return NULL;
   }

   ctx = AllocateGLXContext(dpy);
   if (NULL != ctx) {
      ctx->xid = contextID;
      ctx->imported = GL_TRUE;

      if (Success != __glXQueryContextInfo(dpy, ctx)) {
	 __glXFreeContext(ctx);
	 ctx = NULL;
      }
   }
   return ctx;
#endif
}

PUBLIC void
d1490 1
a1490 6

/*
 * GLX 1.3 functions - these are just stubs for now!
 */

PUBLIC GLXFBConfig *
d1494 1
a1494 1
   __GLcontextModes **config_list;
d1498 1
a1498 1
   config_list = (__GLcontextModes **)
d1514 2
a1515 2
PUBLIC GLXContext
glXCreateNewContext(Display * dpy, GLXFBConfig config,
d1518 1
a1518 2
   const __GLcontextModes *const fbconfig =
      (const __GLcontextModes *const) config;
d1520 3
a1522 3
   return CreateContext(dpy, fbconfig->fbconfigID, fbconfig, shareList,
                        allowDirect, X_GLXCreateNewContext, renderType,
			fbconfig->screen);
d1526 1
a1526 1
PUBLIC GLXDrawable
d1529 2
a1530 1
   GLXContext gc = __glXGetCurrentContext();
d1535 1
a1535 1
PUBLIC GLXFBConfig *
d1538 4
a1541 2
   __GLXdisplayPrivate *priv = __glXInitialize(dpy);
   __GLcontextModes **config = NULL;
d1545 1
a1545 1
   if (priv && (priv->screenConfigs != NULL)
d1547 2
a1548 2
       && (priv->screenConfigs[screen].configs != NULL)
       && (priv->screenConfigs[screen].configs->fbconfigID
a1549 3
      unsigned num_configs = 0;
      __GLcontextModes *modes;

d1551 3
a1553 3
      for (modes = priv->screenConfigs[screen].configs; modes != NULL;
           modes = modes->next) {
         if (modes->fbconfigID != (int) GLX_DONT_CARE) {
d1558 2
a1559 3
      config = (__GLcontextModes **) Xmalloc(sizeof(__GLcontextModes *)
                                             * num_configs);
      if (config != NULL) {
d1562 4
a1565 4
         for (modes = priv->screenConfigs[screen].configs; modes != NULL;
              modes = modes->next) {
            if (modes->fbconfigID != (int) GLX_DONT_CARE) {
               config[i] = modes;
d1571 2
a1572 1
   return (GLXFBConfig *) config;
d1576 2
a1577 2
PUBLIC int
glXGetFBConfigAttrib(Display * dpy, GLXFBConfig config,
d1580 1
a1580 1
   __GLcontextModes *const modes = ValidateGLXFBConfig(dpy, config);
d1582 4
a1585 3
   return (modes != NULL)
      ? _gl_get_context_mode_data(modes, attribute, value)
      : GLXBadFBConfig;
d1589 2
a1590 2
PUBLIC XVisualInfo *
glXGetVisualFromFBConfig(Display * dpy, GLXFBConfig config)
d1593 1
a1593 1
   __GLcontextModes *fbconfig = (__GLcontextModes *) config;
d1599 1
a1599 1
   visualTemplate.visualid = fbconfig->visualID;
d1611 2
a1612 2
   GLXContext gc = __glXGetCurrentContext();
   __GLXscreenConfigs *psc;
a1624 16
#ifdef __DRI_SWAP_CONTROL
   if (gc->driContext) {
      __GLXscreenConfigs * const psc = GetGLXScreenConfigs( gc->currentDpy,
							    gc->screen );
      __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(gc->currentDpy,
						  gc->currentDrawable,
						  NULL);
      if (psc->swapControl != NULL && pdraw != NULL) {
	 psc->swapControl->setSwapInterval(pdraw->driDrawable, interval);
	 return 0;
      }
      else if (pdraw == NULL) {
	 return GLX_BAD_CONTEXT;
      }
   }
#endif
d1628 3
a1630 4
   if (gc->driContext && psc->driScreen && psc->driScreen->setSwapInterval) {
      __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(gc->currentDpy,
						  gc->currentDrawable,
						  NULL);
d1667 2
a1668 17
   GLXContext gc = __glXGetCurrentContext();

#ifdef __DRI_SWAP_CONTROL
   if (gc != NULL && gc->driContext) {
      __GLXscreenConfigs *const psc = GetGLXScreenConfigs(gc->currentDpy,
                                                          gc->screen);

      if ((psc != NULL) && (psc->driScreen != NULL)) {
         __GLXDRIdrawable *pdraw =
            GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable, NULL);
         if (psc->swapControl != NULL && pdraw != NULL) {
            psc->swapControl->setSwapInterval(pdraw->driDrawable, interval);
            return 0;
         }
      }
   }
#endif
d1670 2
a1671 3
#ifdef GLX_DIRECT_RENDERING
   if (gc != NULL && gc->driContext) {
      __GLXscreenConfigs *psc;
d1675 3
a1677 4
         __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(gc->currentDpy,
						     gc->currentDrawable, NULL);
	 psc->driScreen->setSwapInterval(pdraw, interval);
	 return 0;
d1689 2
a1690 16
#ifdef __DRI_SWAP_CONTROL
   GLXContext gc = __glXGetCurrentContext();

   if (gc != NULL && gc->driContext) {
      __GLXscreenConfigs *const psc = GetGLXScreenConfigs(gc->currentDpy,
                                                          gc->screen);

      if ((psc != NULL) && (psc->driScreen != NULL)) {
         __GLXDRIdrawable *pdraw =
            GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable, NULL);
         if (psc->swapControl != NULL && pdraw != NULL) {
            return psc->swapControl->getSwapInterval(pdraw->driDrawable);
         }
      }
   }
#endif
d1692 2
a1693 3
#ifdef GLX_DIRECT_RENDERING
   if (gc != NULL && gc->driContext) {
      __GLXscreenConfigs *psc;
d1697 2
a1698 2
         __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(gc->currentDpy,
						     gc->currentDrawable, NULL);
a1708 101
** GLX_MESA_swap_frame_usage
*/

static GLint
__glXBeginFrameTrackingMESA(Display * dpy, GLXDrawable drawable)
{
   int status = GLX_BAD_CONTEXT;
#ifdef __DRI_FRAME_TRACKING
   int screen = 0;
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable, &screen);
   __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, screen);

   if (pdraw != NULL && psc->frameTracking != NULL)
      status = psc->frameTracking->frameTracking(pdraw->driDrawable, GL_TRUE);
#else
   (void) dpy;
   (void) drawable;
#endif
   return status;
}


static GLint
__glXEndFrameTrackingMESA(Display * dpy, GLXDrawable drawable)
{
   int status = GLX_BAD_CONTEXT;
#ifdef __DRI_FRAME_TRACKING
   int screen = 0;
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable, &screen);
   __GLXscreenConfigs *psc = GetGLXScreenConfigs(dpy, screen);

   if (pdraw != NULL && psc->frameTracking != NULL)
      status = psc->frameTracking->frameTracking(pdraw->driDrawable,
                                                 GL_FALSE);
#else
   (void) dpy;
   (void) drawable;
#endif
   return status;
}


static GLint
__glXGetFrameUsageMESA(Display * dpy, GLXDrawable drawable, GLfloat * usage)
{
   int status = GLX_BAD_CONTEXT;
#ifdef __DRI_FRAME_TRACKING
   int screen = 0;
   __GLXDRIdrawable *const pdraw = GetGLXDRIDrawable(dpy, drawable, &screen);
   __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, screen);

   if (pdraw != NULL && psc->frameTracking != NULL) {
      int64_t sbc, missedFrames;
      float lastMissedUsage;

      status = psc->frameTracking->queryFrameTracking(pdraw->driDrawable,
                                                      &sbc,
                                                      &missedFrames,
                                                      &lastMissedUsage,
                                                      usage);
   }
#else
   (void) dpy;
   (void) drawable;
   (void) usage;
#endif
   return status;
}


static GLint
__glXQueryFrameTrackingMESA(Display * dpy, GLXDrawable drawable,
                            int64_t * sbc, int64_t * missedFrames,
                            GLfloat * lastMissedUsage)
{
   int status = GLX_BAD_CONTEXT;
#ifdef __DRI_FRAME_TRACKING
   int screen = 0;
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable, &screen);
   __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, screen);

   if (pdraw != NULL && psc->frameTracking != NULL) {
      float usage;

      status = psc->frameTracking->queryFrameTracking(pdraw->driDrawable,
                                                      sbc, missedFrames,
                                                      lastMissedUsage,
                                                      &usage);
   }
#else
   (void) dpy;
   (void) drawable;
   (void) sbc;
   (void) missedFrames;
   (void) lastMissedUsage;
#endif
   return status;
}


/*
d1716 2
a1717 2
   GLXContext gc = __glXGetCurrentContext();
   __GLXscreenConfigs *psc;
d1726 1
a1726 1
   if (!gc->driContext)
d1732 1
a1732 1
   pdraw = GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable, NULL);
a1738 10
#ifdef __DRI_MEDIA_STREAM_COUNTER
   if ( psc->msc && psc->driScreen ) {
      ret = (*psc->msc->getDrawableMSC)(psc->__driScreen,
					pdraw->driDrawable, &msc);
      *count = (unsigned) msc;

      return (ret == 0) ? 0 : GLX_BAD_CONTEXT;
   }
#endif

d1753 2
a1754 2
   GLXContext gc = __glXGetCurrentContext();
   __GLXscreenConfigs *psc;
d1768 1
a1768 1
   if (!gc->driContext)
d1774 1
a1774 10
   pdraw = GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable, NULL);
#endif

#ifdef __DRI_MEDIA_STREAM_COUNTER
   if (psc->msc != NULL && psc->driScreen ) {
      ret = (*psc->msc->waitForMSC)(pdraw->driDrawable, 0,
				    divisor, remainder, &msc, &sbc);
      *count = (unsigned) msc;
      return (ret == 0) ? 0 : GLX_BAD_CONTEXT;
   }
d1797 1
a1797 1
PUBLIC
d1802 1
a1802 1
PUBLIC GLX_ALIAS(GLXFBConfigSGIX *, glXChooseFBConfigSGIX,
d1807 1
a1807 1
PUBLIC GLX_ALIAS(XVisualInfo *, glXGetVisualFromFBConfigSGIX,
d1811 1
a1811 1
PUBLIC GLXPixmap
d1813 1
a1813 1
                                 GLXFBConfigSGIX config,
d1821 1
a1821 1
   __GLXscreenConfigs *psc;
d1823 1
a1823 1
   const __GLcontextModes *const fbconfig = (__GLcontextModes *) config;
d1830 1
a1830 1
   if(apple_glx_pixmap_create(dpy, fbconfig->screen, pixmap, fbconfig))
d1835 1
a1835 1
   psc = GetGLXScreenConfigs(dpy, fbconfig->screen);
d1852 2
a1853 2
      req->screen = fbconfig->screen;
      req->fbconfig = fbconfig->fbconfigID;
d1864 1
a1864 1
PUBLIC GLXContext
d1866 1
a1866 1
                               GLXFBConfigSGIX config, int renderType,
d1870 2
a1871 2
   const __GLcontextModes *const fbconfig = (__GLcontextModes *) config;
   __GLXscreenConfigs *psc;
d1878 1
a1878 1
   psc = GetGLXScreenConfigs(dpy, fbconfig->screen);
d1881 1
a1881 1
      gc = CreateContext(dpy, fbconfig->fbconfigID, fbconfig, shareList,
d1884 1
a1884 1
			 fbconfig->screen);
d1891 1
a1891 1
PUBLIC GLXFBConfigSGIX
d1894 2
a1895 2
   __GLXdisplayPrivate *priv;
   __GLXscreenConfigs *psc = NULL;
d1900 2
a1901 2
      return (GLXFBConfigSGIX) _gl_context_modes_find_visual(psc->configs,
                                                             vis->visualid);
d1949 2
a1950 2
   __GLXdisplayPrivate * const priv = __glXInitialize(dpy);
   int i, ret;
d1954 1
a1954 1
   __GLXscreenConfigs *psc;
d1960 3
a1962 14
   pdraw = GetGLXDRIDrawable(dpy, drawable, &i);
#endif
   psc = &priv->screenConfigs[i];

#if defined(__DRI_SWAP_BUFFER_COUNTER) && defined(__DRI_MEDIA_STREAM_COUNTER)
   if (pdraw && psc->sbc && psc->msc)
      return ( (pdraw && psc->sbc && psc->msc)
	       && ((*psc->msc->getMSC)(psc->driScreen, msc) == 0)
	       && ((*psc->sbc->getSBC)(pdraw->driDrawable, sbc) == 0)
	       && (__glXGetUST(ust) == 0) );
#endif

#ifdef GLX_DIRECT_RENDERING
   if (pdraw && psc && psc->driScreen && psc->driScreen->getDrawableMSC) {
d1973 2
a1974 2
__driGetMscRateOML(__DRIdrawable * draw,
                   int32_t * numerator, int32_t * denominator, void *private)
d1977 1
a1977 1
   __GLXscreenConfigs *psc;
a1980 3
   __GLXDRIdrawable *glxDraw = private;

   (void) draw;
d2026 1
a2026 6
      return False;
#else
   (void) draw;
   (void) numerator;
   (void) denominator;
   (void) private;
a2028 1
#endif
d2053 1
a2053 1
   __GLXDRIdrawable *draw = GetGLXDRIDrawable(dpy, drawable, NULL);
d2058 1
a2058 1
   return __driGetMscRateOML(draw->driDrawable, numerator, denominator, draw);
d2073 1
a2073 2
   GLXContext gc = __glXGetCurrentContext();
   int screen;
d2075 2
a2076 1
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable, &screen);
a2077 1
   __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, screen);
d2083 1
a2083 1
   if (!pdraw || !gc->driContext)
d2097 2
a2098 5
#ifdef __DRI_SWAP_BUFFER_COUNTER
   if (psc->counters != NULL)
      return (*psc->sbc->swapBuffersMSC)(pdraw->driDrawable, target_msc,
					 divisor, remainder);
#endif
a2115 1
   int screen;
d2117 3
a2119 1
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable, &screen);
a2120 2
   __GLXscreenConfigs * const psc = GetGLXScreenConfigs( dpy, screen );
   int ret;
a2130 12
#ifdef __DRI_MEDIA_STREAM_COUNTER
   if (pdraw != NULL && psc->msc != NULL) {
      ret = (*psc->msc->waitForMSC) (pdraw->driDrawable, target_msc,
                                     divisor, remainder, msc, sbc);

      /* __glXGetUST returns zero on success and non-zero on failure.
       * This function returns True on success and False on failure.
       */
      return ((ret == 0) && (__glXGetUST(ust) == 0));
   }
#endif

a2147 1
   int screen;
d2149 3
a2151 1
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable, &screen);
a2152 2
   __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, screen);
   int ret;
a2158 11
#ifdef __DRI_SWAP_BUFFER_COUNTER
   if (pdraw != NULL && psc->sbc != NULL) {
      ret =
         (*psc->sbc->waitForSBC) (pdraw->driDrawable, target_sbc, msc, sbc);

      /* __glXGetUST returns zero on success and non-zero on failure.
       * This function returns True on success and False on failure.
       */
      return ((ret == 0) && (__glXGetUST(ust) == 0));
   }
#endif
a2169 66

/**
 * GLX_MESA_allocate_memory
 */
/*@@{*/

PUBLIC void *
glXAllocateMemoryMESA(Display * dpy, int scrn,
                      size_t size, float readFreq,
                      float writeFreq, float priority)
{
#ifdef __DRI_ALLOCATE
   __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, scrn);

   if (psc && psc->allocate)
      return (*psc->allocate->allocateMemory) (psc->__driScreen, size,
                                               readFreq, writeFreq, priority);

#else
   (void) dpy;
   (void) scrn;
   (void) size;
   (void) readFreq;
   (void) writeFreq;
   (void) priority;
#endif /* __DRI_ALLOCATE */

   return NULL;
}


PUBLIC void
glXFreeMemoryMESA(Display * dpy, int scrn, void *pointer)
{
#ifdef __DRI_ALLOCATE
   __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, scrn);

   if (psc && psc->allocate)
      (*psc->allocate->freeMemory) (psc->__driScreen, pointer);

#else
   (void) dpy;
   (void) scrn;
   (void) pointer;
#endif /* __DRI_ALLOCATE */
}


PUBLIC GLuint
glXGetMemoryOffsetMESA(Display * dpy, int scrn, const void *pointer)
{
#ifdef __DRI_ALLOCATE
   __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, scrn);

   if (psc && psc->allocate)
      return (*psc->allocate->memoryOffset) (psc->__driScreen, pointer);

#else
   (void) dpy;
   (void) scrn;
   (void) pointer;
#endif /* GLX_DIRECT_RENDERING */

   return ~0L;
}

d2209 1
a2209 1
PUBLIC GLXPixmap
d2232 1
a2232 1
   GLXContext gc;
d2238 2
a2239 3
#ifdef __DRI_COPY_SUB_BUFFER
   int screen;
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable, &screen);
d2241 1
a2241 1
      __GLXscreenConfigs *const psc = GetGLXScreenConfigs(dpy, screen);
a2291 4

/**
 * GLX_EXT_texture_from_pixmap
 */
d2297 1
a2297 39
   xGLXVendorPrivateReq *req;
   GLXContext gc = __glXGetCurrentContext();
   CARD32 *drawable_ptr;
   INT32 *buffer_ptr;
   CARD32 *num_attrib_ptr;
   CARD32 *attrib_ptr;
   CARD8 opcode;
   unsigned int i;

   if (gc == NULL)
      return;

   i = 0;
   if (attrib_list) {
      while (attrib_list[i * 2] != None)
         i++;
   }

#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   if (gc->driContext) {
      __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable, NULL);

      if (pdraw != NULL) {
         if (pdraw->psc->texBuffer->base.version >= 2 &&
             pdraw->psc->texBuffer->setTexBuffer2 != NULL) {
            (*pdraw->psc->texBuffer->setTexBuffer2) (gc->__driContext,
                                                     pdraw->textureTarget,
                                                     pdraw->textureFormat,
                                                     pdraw->driDrawable);
         }
         else {
            (*pdraw->psc->texBuffer->setTexBuffer) (gc->__driContext,
                                                    pdraw->textureTarget,
                                                    pdraw->driDrawable);
         }
      }
      return;
   }
#endif
d2299 1
a2299 2
   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
d2302 1
a2302 27
   LockDisplay(dpy);
   GetReqExtra(GLXVendorPrivate, 12 + 8 * i, req);
   req->reqType = opcode;
   req->glxCode = X_GLXVendorPrivate;
   req->vendorCode = X_GLXvop_BindTexImageEXT;
   req->contextTag = gc->currentContextTag;

   drawable_ptr = (CARD32 *) (req + 1);
   buffer_ptr = (INT32 *) (drawable_ptr + 1);
   num_attrib_ptr = (CARD32 *) (buffer_ptr + 1);
   attrib_ptr = (CARD32 *) (num_attrib_ptr + 1);

   *drawable_ptr = drawable;
   *buffer_ptr = buffer;
   *num_attrib_ptr = (CARD32) i;

   i = 0;
   if (attrib_list) {
      while (attrib_list[i * 2] != None) {
         *attrib_ptr++ = (CARD32) attrib_list[i * 2 + 0];
         *attrib_ptr++ = (CARD32) attrib_list[i * 2 + 1];
         i++;
      }
   }

   UnlockDisplay(dpy);
   SyncHandle();
d2308 1
a2308 5
   xGLXVendorPrivateReq *req;
   GLXContext gc = __glXGetCurrentContext();
   CARD32 *drawable_ptr;
   INT32 *buffer_ptr;
   CARD8 opcode;
d2310 1
a2310 5
   if ((gc == NULL) || GC_IS_DIRECT(gc))
      return;

   opcode = __glXSetupForCommand(dpy);
   if (!opcode)
d2313 1
a2313 15
   LockDisplay(dpy);
   GetReqExtra(GLXVendorPrivate, sizeof(CARD32) + sizeof(INT32), req);
   req->reqType = opcode;
   req->glxCode = X_GLXVendorPrivate;
   req->vendorCode = X_GLXvop_ReleaseTexImageEXT;
   req->contextTag = gc->currentContextTag;

   drawable_ptr = (CARD32 *) (req + 1);
   buffer_ptr = (INT32 *) (drawable_ptr + 1);

   *drawable_ptr = drawable;
   *buffer_ptr = buffer;

   UnlockDisplay(dpy);
   SyncHandle();
a2439 5
   /*** GLX_MESA_allocate_memory ***/
   GLX_FUNCTION(glXAllocateMemoryMESA),
   GLX_FUNCTION(glXFreeMemoryMESA),
   GLX_FUNCTION(glXGetMemoryOffsetMESA),

a2451 6

   /*** GLX_MESA_swap_frame_usage ***/
   GLX_FUNCTION2(glXBeginFrameTrackingMESA, __glXBeginFrameTrackingMESA),
   GLX_FUNCTION2(glXEndFrameTrackingMESA, __glXEndFrameTrackingMESA),
   GLX_FUNCTION2(glXGetFrameUsageMESA, __glXGetFrameUsageMESA),
   GLX_FUNCTION2(glXQueryFrameTrackingMESA, __glXQueryFrameTrackingMESA),
d2507 1
a2507 1
PUBLIC void (*glXGetProcAddressARB(const GLubyte * procName)) (void)
d2540 1
a2540 1
PUBLIC void (*glXGetProcAddress(const GLubyte * procName)) (void)
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d39 1
d46 1
a48 1
#ifdef XF86VIDMODE
a49 1
#endif
d51 1
d54 1
d66 3
d71 49
d130 1
a130 1
GetGLXDRIDrawable(Display * dpy, GLXDrawable drawable)
d132 1
a132 1
   struct glx_display *priv = __glXInitialize(dpy);
d134 3
d141 11
a151 2
   if (__glxHashLookup(priv->drawHash, drawable, (void *) &pdraw) == 0)
      return pdraw;
d173 1
a173 1
static struct glx_screen *
d176 1
a176 1
   struct glx_display *const priv = __glXInitialize(dpy);
d179 2
a180 2
           && priv->screens !=
           NULL) ? priv->screens[scrn] : NULL;
d185 2
a186 2
GetGLXPrivScreenConfig(Display * dpy, int scrn, struct glx_display ** ppriv,
                       struct glx_screen ** ppsc)
d207 1
a207 1
   *ppsc = (*ppriv)->screens[scrn];
d224 1
a224 1
 *          \c struct glx_config structure is returned.  Otherwise, \c NULL
d227 2
a228 2
static struct glx_config *
ValidateGLXFBConfig(Display * dpy, GLXFBConfig fbconfig)
d230 2
a231 2
   struct glx_display *const priv = __glXInitialize(dpy);
   int num_screens = ScreenCount(dpy);
d233 2
a234 1
   struct glx_config *config;
d238 6
a243 6
	 for (config = priv->screens[i]->configs; config != NULL;
	      config = config->next) {
	    if (config == (struct glx_config *) fbconfig) {
	       return config;
	    }
	 }
d250 13
a262 3
_X_HIDDEN Bool
glx_context_init(struct glx_context *gc,
		 struct glx_screen *psc, struct glx_config *config)
d264 76
a339 3
   gc->majorOpcode = __glXSetupForCommand(psc->display->dpy);
   if (!gc->majorOpcode)
      return GL_FALSE;
d341 18
a358 5
   gc->screen = psc->scr;
   gc->psc = psc;
   gc->config = config;
   gc->isDirect = GL_TRUE;
   gc->currentContextTag = -1;
d360 1
a360 1
   return GL_TRUE;
d375 2
a376 2
              struct glx_config *config,
              GLXContext shareList_user,
d380 10
a389 3
   struct glx_context *gc;
   struct glx_screen *psc;
   struct glx_context *shareList = (struct glx_context *) shareList_user;
d393 1
a393 2
   psc = GetGLXScreenConfigs(dpy, screen);
   if (psc == NULL)
d396 2
a397 1
   if (generic_id == None)
d400 12
a411 8
   gc = NULL;
#ifdef GLX_USE_APPLEGL
   gc = applegl_create_context(psc, config, shareList, renderType);
#else
   if (allowDirect && psc->vtable->create_context)
      gc = psc->vtable->create_context(psc, config, shareList, renderType);
   if (!gc)
      gc = indirect_create_context(psc, config, shareList, renderType);
a412 2
   if (!gc)
      return NULL;
d427 1
a427 1
      req->isDirect = gc->isDirect;
d443 1
a443 1
      req->isDirect = gc->isDirect;
d464 1
a464 1
      req->isDirect = gc->isDirect;
d477 1
d482 16
a497 1
   return (GLXContext) gc;
d500 1
a500 1
_X_EXPORT GLXContext
d504 1
a504 1
   struct glx_config *config = NULL;
d508 1
a508 1
   struct glx_screen *const psc = GetGLXScreenConfigs(dpy, vis->screen);
d510 2
a511 2
   config = glx_config_find_visual(psc->visuals, vis->visualid);
   if (config == NULL) {
d524 1
a524 1
   renderType = config->rgbMode ? GLX_RGBA_TYPE : GLX_COLOR_INDEX_TYPE;
d527 1
a527 1
   return CreateContext(dpy, vis->visualid, config, shareList, allowDirect,
d532 1
a532 1
glx_send_destroy_context(Display *dpy, XID xid)
d534 12
a545 2
   CARD8 opcode = __glXSetupForCommand(dpy);
   xGLXDestroyContextReq *req;
a546 7
   LockDisplay(dpy);
   GetReq(GLXDestroyContext, req);
   req->reqType = opcode;
   req->glxCode = X_GLXDestroyContext;
   req->context = xid;
   UnlockDisplay(dpy);
   SyncHandle();
d553 1
a553 1
DestroyContext(Display * dpy, GLXContext ctx)
d555 5
a559 1
   struct glx_context *gc = (struct glx_context *) ctx;
d561 2
a562 1
   if (!gc)
d564 1
d567 4
a576 3
      if (!gc->imported)
	 glx_send_destroy_context(dpy, gc->xid);
      gc->xid = None;
a579 1
   __glXUnlock();
d581 49
a629 2
   if (gc->vtable->destroy)
      gc->vtable->destroy(gc);
d632 1
a632 1
_X_EXPORT void
d641 1
a641 1
_X_EXPORT Bool
d644 1
a644 1
   struct glx_display *priv;
d661 1
a661 1
_X_EXPORT Bool
d681 1
a681 1
_X_EXPORT void
d684 8
a691 1
   struct glx_context *gc = __glXGetCurrentContext();
d693 30
a722 2
   if (gc && gc->vtable->wait_gl)
      gc->vtable->wait_gl(gc);
d729 1
a729 1
_X_EXPORT void
d732 8
a739 1
   struct glx_context *gc = __glXGetCurrentContext();
d741 34
a774 2
   if (gc && gc->vtable->wait_x)
      gc->vtable->wait_x(gc);
d777 1
a777 1
_X_EXPORT void
d780 5
a784 1
   struct glx_context *gc = __glXGetCurrentContext();
d786 28
a813 2
   if (gc && gc->vtable->use_x_font)
      gc->vtable->use_x_font(gc, font, first, count, listBase);
d822 3
a824 3
_X_EXPORT void
glXCopyContext(Display * dpy, GLXContext source_user,
	       GLXContext dest_user, unsigned long mask)
a825 2
   struct glx_context *source = (struct glx_context *) source_user;
   struct glx_context *dest = (struct glx_context *) dest_user;
d827 1
a827 1
   struct glx_context *gc = __glXGetCurrentContext();
d838 1
a838 1
   struct glx_context *gc = __glXGetCurrentContext();
d848 1
a848 1
   if (gc->isDirect) {
d933 2
a934 2
_X_EXPORT Bool
glXIsDirect(Display * dpy, GLXContext gc_user)
a935 2
   struct glx_context *gc = (struct glx_context *) gc_user;

d939 1
a939 1
   else if (gc->isDirect) {
d949 1
a949 1
_X_EXPORT GLXPixmap
d954 2
a955 2
   struct glx_screen *const psc = GetGLXScreenConfigs(dpy, screen);
   const struct glx_config *config;
d957 1
a957 1
   config = glx_config_find_visual(psc->visuals, vis->visualid);
d959 1
a959 1
   if(apple_glx_pixmap_create(dpy, vis->screen, pixmap, config))
d990 1
a990 1
      struct glx_display *const priv = __glXInitialize(dpy);
d992 2
a993 2
      struct glx_screen *psc;
      struct glx_config *config;
d995 1
a995 1
      psc = priv->screens[vis->screen];
d998 2
a999 2
      config = glx_config_find_visual(psc->visuals, vis->visualid);
      pdraw = psc->driScreen->createDrawable(psc, pixmap, req->glxpixmap, config);
d1005 1
a1005 1
      if (__glxHashInsert(priv->drawHash, req->glxpixmap, pdraw)) {
d1019 1
a1019 1
_X_EXPORT void
d1045 4
a1048 2
      struct glx_display *const priv = __glXInitialize(dpy);
      __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, glxpixmap);
d1052 1
a1052 1
         __glxHashDelete(priv->drawHash, glxpixmap);
d1059 1
a1059 1
_X_EXPORT void
d1063 1
a1063 1
   struct glx_context * gc = __glXGetCurrentContext();
d1070 1
a1070 1
   struct glx_context *gc;
d1080 1
a1080 1
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
d1132 1
a1132 1
_X_EXPORT int
d1136 3
a1138 3
   struct glx_display *priv;
   struct glx_screen *psc;
   struct glx_config *config;
d1143 1
a1143 1
      config = glx_config_find_visual(psc->visuals, vis->visualid);
d1146 2
a1147 2
      if (config != NULL) {
	 return glx_config_get(config, attribute, value_return);
d1168 1
a1168 1
init_fbconfig_for_chooser(struct glx_config * config,
d1171 1
a1171 1
   memset(config, 0, sizeof(struct glx_config));
d1237 2
a1238 2
fbconfigs_compatible(const struct glx_config * const a,
                     const struct glx_config * const b)
d1357 2
a1358 1
fbconfig_compare(struct glx_config **a, struct glx_config **b)
d1443 1
a1443 1
choose_visual(struct glx_config ** configs, int num_configs,
d1446 1
a1446 1
   struct glx_config test_config;
d1482 1
a1482 1
   qsort(configs, base, sizeof(struct glx_config *),
d1494 1
a1494 1
_X_EXPORT XVisualInfo *
d1498 5
a1502 5
   struct glx_display *priv;
   struct glx_screen *psc;
   struct glx_config test_config;
   struct glx_config *config;
   struct glx_config *best_config = NULL;
d1529 7
a1535 4
   for (config = psc->visuals; config != NULL; config = config->next) {
      if (fbconfigs_compatible(&test_config, config)
          && ((best_config == NULL) ||
              (fbconfig_compare (&config, &best_config) < 0))) {
d1541 1
a1541 1
         visualTemplate.visualid = config->visualID;
d1548 1
a1548 1
            best_config = config;
d1563 1
a1563 1
_X_EXPORT const char *
d1566 2
a1567 2
   struct glx_screen *psc;
   struct glx_display *priv;
d1592 1
a1592 1
_X_EXPORT const char *
d1609 1
a1609 1
_X_EXPORT const char *
d1612 2
a1613 2
   struct glx_screen *psc;
   struct glx_display *priv;
d1679 1
a1679 1
_X_EXPORT Display *
d1682 1
a1682 1
   struct glx_context *gc = __glXGetCurrentContext();
d1688 1
a1688 1
_X_EXPORT
d1693 15
a1707 2
_X_EXPORT GLXContext
glXImportContextEXT(Display *dpy, GLXContextID contextID)
d1709 1
a1709 2
   struct glx_display *priv = __glXInitialize(dpy);
   struct glx_screen *psc;
d1712 2
a1713 8
   struct glx_context *ctx;
   int propList[__GLX_MAX_CONTEXT_PROPS * 2], *pProp, nPropListBytes;
   int i, renderType;
   XID share;
   struct glx_config *mode;

   if (contextID == None || __glXIsDirect(dpy, contextID))
      return NULL;
d1715 3
d1719 1
a1719 1
   if (!opcode)
d1721 1
d1726 1
a1726 1
   if (priv->majorVersion > 1 || priv->minorVersion >= 3) {
d1733 1
a1733 1
      req->context = contextID;
d1740 2
a1741 2
		  sz_xGLXQueryContextInfoEXTReq - sz_xGLXVendorPrivateReq,
		  vpreq);
d1746 1
a1746 1
      req->context = contextID;
d1751 8
a1758 7
   if (reply.n <= __GLX_MAX_CONTEXT_PROPS)
      nPropListBytes = reply.n * 2 * sizeof propList[0];
   else
      nPropListBytes = 0;
   _XRead(dpy, (char *) propList, nPropListBytes);
   UnlockDisplay(dpy);
   SyncHandle();
d1760 7
a1766 7
   /* Look up screen first so we can look up visuals/fbconfigs later */
   psc = NULL;
   for (i = 0, pProp = propList; i < reply.n; i++, pProp += 2)
      if (pProp[0] == GLX_SCREEN)
	 psc = GetGLXScreenConfigs(dpy, pProp[1]);
   if (psc == NULL)
      return NULL;
d1768 1
a1768 4
   share = None;
   mode = NULL;
   renderType = 0;
   pProp = propList;
d1770 34
a1803 14
   for (i = 0, pProp = propList; i < reply.n; i++, pProp += 2)
      switch (pProp[0]) {
      case GLX_SHARE_CONTEXT_EXT:
	 share = pProp[1];
	 break;
      case GLX_VISUAL_ID_EXT:
	 mode = glx_config_find_visual(psc->visuals, pProp[1]);
	 break;
      case GLX_FBCONFIG_ID:
	 mode = glx_config_find_fbconfig(psc->configs, pProp[1]);
	 break;
      case GLX_RENDER_TYPE:
	 renderType = pProp[1];
	 break;
d1805 4
a1808 13

   if (mode == NULL)
      return NULL;

   ctx = indirect_create_context(psc, mode, NULL, renderType);
   if (ctx == NULL)
      return NULL;

   ctx->xid = contextID;
   ctx->imported = GL_TRUE;
   ctx->share_xid = share;

   return (GLXContext) ctx;
d1813 2
a1814 2
_X_EXPORT int
glXQueryContext(Display * dpy, GLXContext ctx_user, int attribute, int *value)
d1816 14
a1829 1
   struct glx_context *ctx = (struct glx_context *) ctx_user;
d1832 1
d1834 1
a1834 1
      *value = ctx->share_xid;
d1837 1
a1837 1
      *value = ctx->config ? ctx->config->visualID : None;
d1839 1
d1841 1
a1841 1
      *value = ctx->screen;
d1844 1
a1844 1
      *value = ctx->config ? ctx->config->fbconfigID : None;
d1847 1
a1847 1
      *value = ctx->renderType;
d1855 1
a1855 1
_X_EXPORT
d1860 1
a1860 1
_X_EXPORT GLXContextID glXGetContextIDEXT(const GLXContext ctx_user)
d1862 2
a1863 1
   struct glx_context *ctx = (struct glx_context *) ctx_user;
d1865 27
a1891 1
   return ctx->xid;
d1894 1
a1894 1
_X_EXPORT void
d1901 6
a1906 1
_X_EXPORT GLXFBConfig *
d1910 1
a1910 1
   struct glx_config **config_list;
d1914 1
a1914 1
   config_list = (struct glx_config **)
d1930 2
a1931 2
_X_EXPORT GLXContext
glXCreateNewContext(Display * dpy, GLXFBConfig fbconfig,
d1934 2
a1935 1
   struct glx_config *config = (struct glx_config *) fbconfig;
d1937 3
a1939 3
   return CreateContext(dpy, config->fbconfigID, config, shareList,
			allowDirect, X_GLXCreateNewContext, renderType,
			config->screen);
d1943 1
a1943 1
_X_EXPORT GLXDrawable
d1946 1
a1946 2
   struct glx_context *gc = __glXGetCurrentContext();

d1951 1
a1951 1
_X_EXPORT GLXFBConfig *
d1954 2
a1955 4
   struct glx_display *priv = __glXInitialize(dpy);
   struct glx_config **config_list = NULL;
   struct glx_config *config;
   unsigned num_configs = 0;
d1959 1
a1959 1
   if (priv && (priv->screens != NULL)
d1961 2
a1962 2
       && (priv->screens[screen]->configs != NULL)
       && (priv->screens[screen]->configs->fbconfigID
d1964 3
d1968 3
a1970 3
      for (config = priv->screens[screen]->configs; config != NULL;
           config = config->next) {
         if (config->fbconfigID != (int) GLX_DONT_CARE) {
d1975 3
a1977 2
      config_list = Xmalloc(num_configs * sizeof *config_list);
      if (config_list != NULL) {
d1980 4
a1983 4
         for (config = priv->screens[screen]->configs; config != NULL;
              config = config->next) {
            if (config->fbconfigID != (int) GLX_DONT_CARE) {
               config_list[i] = config;
d1989 1
a1989 2

   return (GLXFBConfig *) config_list;
d1993 2
a1994 2
_X_EXPORT int
glXGetFBConfigAttrib(Display * dpy, GLXFBConfig fbconfig,
d1997 1
a1997 1
   struct glx_config *config = ValidateGLXFBConfig(dpy, fbconfig);
d1999 3
a2001 4
   if (config == NULL)
      return GLXBadFBConfig;

   return glx_config_get(config, attribute, value);
d2005 2
a2006 2
_X_EXPORT XVisualInfo *
glXGetVisualFromFBConfig(Display * dpy, GLXFBConfig fbconfig)
d2009 1
a2009 1
   struct glx_config *config = (struct glx_config *) fbconfig;
d2015 1
a2015 1
   visualTemplate.visualid = config->visualID;
d2027 2
a2028 2
   struct glx_context *gc = __glXGetCurrentContext();
   struct glx_screen *psc;
d2041 16
d2060 4
a2063 3
   if (gc->isDirect && psc->driScreen && psc->driScreen->setSwapInterval) {
      __GLXDRIdrawable *pdraw =
	 GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
d2100 18
d2119 2
a2120 4
   struct glx_context *gc = __glXGetCurrentContext();

   if (gc != NULL && gc->isDirect) {
      struct glx_screen *psc;
d2124 4
a2127 3
         __GLXDRIdrawable *pdraw =
	    GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
	 return psc->driScreen->setSwapInterval(pdraw, interval);
d2139 17
d2157 2
a2158 4
   struct glx_context *gc = __glXGetCurrentContext();

   if (gc != NULL && gc->isDirect) {
      struct glx_screen *psc;
d2162 2
a2163 2
         __GLXDRIdrawable *pdraw =
	    GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
d2174 101
d2282 2
a2283 2
   struct glx_context *gc = __glXGetCurrentContext();
   struct glx_screen *psc;
d2292 1
a2292 1
   if (!gc->isDirect)
d2298 1
a2298 1
   pdraw = GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
d2305 10
d2329 2
a2330 2
   struct glx_context *gc = __glXGetCurrentContext();
   struct glx_screen *psc;
d2344 1
a2344 1
   if (!gc->isDirect)
d2350 10
a2359 1
   pdraw = GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
d2382 1
a2382 1
_X_EXPORT
d2387 1
a2387 1
_X_EXPORT GLX_ALIAS(GLXFBConfigSGIX *, glXChooseFBConfigSGIX,
d2392 1
a2392 1
_X_EXPORT GLX_ALIAS(XVisualInfo *, glXGetVisualFromFBConfigSGIX,
d2396 1
a2396 1
_X_EXPORT GLXPixmap
d2398 1
a2398 1
                                 GLXFBConfigSGIX fbconfig,
d2406 1
a2406 1
   struct glx_screen *psc;
d2408 1
a2408 1
   struct glx_config *config = (struct glx_config *) fbconfig;
d2415 1
a2415 1
   if(apple_glx_pixmap_create(dpy, config->screen, pixmap, config))
d2420 1
a2420 1
   psc = GetGLXScreenConfigs(dpy, config->screen);
d2437 2
a2438 2
      req->screen = config->screen;
      req->fbconfig = config->fbconfigID;
d2449 1
a2449 1
_X_EXPORT GLXContext
d2451 1
a2451 1
                               GLXFBConfigSGIX fbconfig, int renderType,
d2455 2
a2456 2
   struct glx_config *config = (struct glx_config *) fbconfig;
   struct glx_screen *psc;
d2463 1
a2463 1
   psc = GetGLXScreenConfigs(dpy, config->screen);
d2466 1
a2466 1
      gc = CreateContext(dpy, config->fbconfigID, config, shareList,
d2469 1
a2469 1
			 config->screen);
d2476 1
a2476 1
_X_EXPORT GLXFBConfigSGIX
d2479 2
a2480 2
   struct glx_display *priv;
   struct glx_screen *psc = NULL;
d2485 2
a2486 2
      return (GLXFBConfigSGIX) glx_config_find_visual(psc->configs,
						      vis->visualid);
d2534 2
a2535 2
   struct glx_display * const priv = __glXInitialize(dpy);
   int ret;
d2539 1
a2539 1
   struct glx_screen *psc;
d2545 14
a2558 3
   pdraw = GetGLXDRIDrawable(dpy, drawable);
   psc = pdraw ? pdraw->psc : NULL;
   if (pdraw && psc->driScreen->getDrawableMSC) {
d2569 2
a2570 2
__glxGetMscRate(__GLXDRIdrawable *glxDraw,
		int32_t * numerator, int32_t * denominator)
d2573 1
a2573 1
   struct glx_screen *psc;
d2577 3
d2625 6
a2630 1
#endif
d2633 1
d2658 1
a2658 1
   __GLXDRIdrawable *draw = GetGLXDRIDrawable(dpy, drawable);
d2663 1
a2663 1
   return __glxGetMscRate(draw, numerator, denominator);
d2678 2
a2679 1
   struct glx_context *gc = __glXGetCurrentContext();
d2681 1
a2681 2
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
   struct glx_screen *psc = pdraw ? pdraw->psc : NULL;
d2683 1
d2689 1
a2689 1
   if (!pdraw || !gc->isDirect)
d2703 5
a2707 2
   if (target_msc == 0 && divisor == 0 && remainder == 0)
      remainder = 1;
d2725 1
d2727 3
a2729 2
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
   struct glx_screen *psc = pdraw ? pdraw->psc : NULL;
a2730 1
#endif
d2741 12
d2770 1
d2772 3
a2774 2
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
   struct glx_screen *psc = pdraw ? pdraw->psc : NULL;
a2775 1
#endif
d2782 11
d2804 66
d2909 1
a2909 1
_X_EXPORT GLXPixmap
d2932 1
a2932 1
   struct glx_context *gc;
d2938 3
a2940 2
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
d2942 1
a2942 1
      struct glx_screen *psc = pdraw->psc;
d2993 4
d3002 39
a3040 1
   struct glx_context *gc = __glXGetCurrentContext();
d3042 2
a3043 1
   if (gc == NULL || gc->vtable->bind_tex_image == NULL)
d3046 27
a3072 1
   gc->vtable->bind_tex_image(dpy, drawable, buffer, attrib_list);
d3078 5
a3082 1
   struct glx_context *gc = __glXGetCurrentContext();
d3084 5
a3088 1
   if (gc == NULL || gc->vtable->release_tex_image == NULL)
d3091 15
a3105 1
   gc->vtable->release_tex_image(dpy, drawable, buffer);
d3232 5
d3249 6
d3310 1
a3310 1
_X_EXPORT void (*glXGetProcAddressARB(const GLubyte * procName)) (void)
d3343 1
a3343 1
_X_EXPORT void (*glXGetProcAddress(const GLubyte * procName)) (void)
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a38 2
#include "indirect.h"
#include "glx_error.h"
d44 1
d55 1
d59 1
a91 45
_X_HIDDEN struct glx_drawable *
GetGLXDrawable(Display *dpy, GLXDrawable drawable)
{
   struct glx_display *priv = __glXInitialize(dpy);
   struct glx_drawable *glxDraw;

   if (priv == NULL)
      return NULL;

   if (__glxHashLookup(priv->glXDrawHash, drawable, (void *) &glxDraw) == 0)
      return glxDraw;

   return NULL;
}

_X_HIDDEN int
InitGLXDrawable(Display *dpy, struct glx_drawable *glxDraw, XID xDrawable,
		GLXDrawable drawable)
{
   struct glx_display *priv = __glXInitialize(dpy);

   if (!priv)
      return -1;

   glxDraw->xDrawable = xDrawable;
   glxDraw->drawable = drawable;
   glxDraw->lastEventSbc = 0;
   glxDraw->eventSbcWrap = 0;

   return __glxHashInsert(priv->glXDrawHash, drawable, glxDraw);
}

_X_HIDDEN void
DestroyGLXDrawable(Display *dpy, GLXDrawable drawable)
{
   struct glx_display *priv = __glXInitialize(dpy);
   struct glx_drawable *glxDraw;

   if (!priv)
      return;

   glxDraw = GetGLXDrawable(dpy, drawable);
   __glxHashDelete(priv->glXDrawHash, drawable);
   free(glxDraw);
}
d107 1
a107 1
_X_HIDDEN struct glx_screen *
a182 27
/**
 * Verifies context's GLX_RENDER_TYPE value with config.
 *
 * \param config GLX FBConfig which will support the returned renderType.
 * \param renderType The context render type to be verified.
 * \return True if the value of context renderType was approved, or 0 if no
 * valid value was found.
 */
Bool
validate_renderType_against_config(const struct glx_config *config,
                                   int renderType)
{
    switch (renderType) {
    case GLX_RGBA_TYPE:
        return (config->renderType & GLX_RGBA_BIT) != 0;
    case GLX_COLOR_INDEX_TYPE:
        return (config->renderType & GLX_COLOR_INDEX_BIT) != 0;
    case GLX_RGBA_FLOAT_TYPE_ARB:
        return (config->renderType & GLX_RGBA_FLOAT_BIT_ARB) != 0;
    case GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT:
        return (config->renderType & GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT) != 0;
    default:
        break;
    }
    return 0;
}

d189 1
a189 1
      return False;
d197 1
a197 1
   return True;
d202 2
a203 1
 * Create a new context.
d205 2
d211 4
a214 2
CreateContext(Display *dpy, int generic_id, struct glx_config *config,
              GLXContext shareList_user, Bool allowDirect,
a305 1
   gc->share_xid = shareList ? shareList->xid : None;
d307 1
d317 1
a317 1
   int renderType = GLX_RGBA_TYPE;
d336 1
a336 26
   /* Choose the context render type based on DRI config values.  It is
    * unusual to set this type from config, but we have no other choice, as
    * this old API does not provide renderType parameter.
    */
   if (config->renderType & GLX_RGBA_FLOAT_BIT_ARB) {
       renderType = GLX_RGBA_FLOAT_TYPE_ARB;
   } else if (config->renderType & GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT) {
       renderType = GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT;
   } else if (config->renderType & GLX_RGBA_BIT) {
       renderType = GLX_RGBA_TYPE;
   } else if (config->renderType & GLX_COLOR_INDEX_BIT) {
       renderType = GLX_COLOR_INDEX_TYPE;
   } else if (config->rgbMode) {
       /* If we're here, then renderType is not set correctly.  Let's use a
        * safeguard - any TrueColor or DirectColor mode is RGB mode.  Such
        * default value is needed by old DRI drivers, which didn't set
        * renderType correctly as the value was just ignored.
        */
       renderType = GLX_RGBA_TYPE;
   } else {
       /* Safeguard - only one option left, all non-RGB modes are indexed
        * modes.  Again, this allows drivers with invalid renderType to work
        * properly.
        */
       renderType = GLX_COLOR_INDEX_TYPE;
   }
d343 1
a343 1
static void
d361 2
a362 3

_X_EXPORT void
glXDestroyContext(Display * dpy, GLXContext ctx)
d366 1
a366 1
   if (gc == NULL || gc->xid == None)
a369 3
   if (!gc->imported)
      glx_send_destroy_context(dpy, gc->xid);

d376 2
d379 2
a380 2
   } else {
      gc->vtable->destroy(gc);
d383 9
d405 1
a405 1
      return False;
d411 1
a411 1
   return True;
d539 1
a539 1
 * \returns \c True if the context is direct rendering or not.
d544 4
a548 4
   xcb_connection_t *c;
   xcb_generic_error_t *err;
   xcb_glx_is_direct_reply_t *reply;
   Bool is_direct;
d552 1
a552 1
      return False;
d555 6
a560 8
   c = XGetXCBConnection(dpy);
   reply = xcb_glx_is_direct_reply(c, xcb_glx_is_direct(c, contextID), &err);
   is_direct = (reply != NULL && reply->is_direct) ? True : False;

   if (err != NULL) {
      __glXSendErrorForXcb(dpy, err);
      free(err);
   }
d562 1
d566 13
d583 1
a583 1
 * Shouldn't this function \b always return \c False when
d593 1
a593 1
      return False;
d596 1
a596 1
      return True;
d599 1
a599 1
   return False;
a620 1
   struct glx_drawable *glxDraw;
a628 4
   glxDraw = malloc(sizeof(*glxDraw));
   if (!glxDraw)
      return None;

a640 5
   if (InitGLXDrawable(dpy, glxDraw, pixmap, req->glxpixmap)) {
      free(glxDraw);
      return None;
   }

d653 1
a653 2
         return xid;

d655 1
a655 1
      pdraw = psc->driScreen->createDrawable(psc, pixmap, xid, config);
a657 1
         xid = None;
d661 1
a661 1
      if (__glxHashInsert(priv->drawHash, xid, pdraw)) {
d663 1
a663 2
         xid = None;
         break;
a665 11

   if (xid == None) {
      xGLXDestroyGLXPixmapReq *dreq;
      LockDisplay(dpy);
      GetReq(GLXDestroyGLXPixmap, dreq);
      dreq->reqType = opcode;
      dreq->glxCode = X_GLXDestroyGLXPixmap;
      dreq->glxpixmap = xid;
      UnlockDisplay(dpy);
      SyncHandle();
   }
a698 2
   DestroyGLXDrawable(dpy, glxpixmap);

d727 1
d729 3
a731 2

   gc = __glXGetCurrentContext();
d734 1
a734 2
   {
      __GLXDRIdrawable *pdraw = GetGLXDRIDrawable(dpy, drawable);
d736 4
a739 6
      if (pdraw != NULL) {
         Bool flush = gc && drawable == gc->currentDrawable;

         (*pdraw->psc->driScreen->swapBuffers)(pdraw, 0, 0, 0, flush);
         return;
      }
d752 1
d762 1
d766 12
d812 1
a812 1
      *value_return = False;
d829 1
a829 1
   /* glXChooseFBConfig specifies different defaults for these properties than
a834 5
      /* allow any kind of drawable, including those for off-screen buffers */
      config->drawableType = 0;
   } else {
       /* allow configs which support on-screen drawing */
       config->drawableType = GLX_WINDOW_BIT;
d845 3
a847 2
   /* Set GLX_RENDER_TYPE property to not expect any flags by default. */
   config->renderType = 0;
d880 1
a880 2
    if ( ((int) a-> param != (int) GLX_DONT_CARE)	\
         && ((a->param & ~b->param) != 0) ) {   \
a881 1
    }                                           \
d1196 1
a1196 1
            free(visualList);
d1298 1
d1302 14
d1317 5
a1321 1
   free(ext_str);
d1347 1
a1347 1
   struct glx_screen *psc = NULL;
d1351 1
a1351 6

   /* This GLX implementation knows about 5 different properties, so
    * allow the server to send us one of each.
    */
   int propList[5 * 2], *pProp, nPropListBytes;
   int numProps;
a1354 20
   uint32_t fbconfigID = 0;
   uint32_t visualID = 0;
   uint32_t screen = 0;
   Bool got_screen = False;

   /* The GLX_EXT_import_context spec says:
    *
    *     "If <contextID> does not refer to a valid context, then a BadContext
    *     error is generated; if <contextID> refers to direct rendering
    *     context then no error is generated but glXImportContextEXT returns
    *     NULL."
    *
    * If contextID is None, generate BadContext on the client-side.  Other
    * sorts of invalid contexts will be detected by the server in the
    * __glXIsDirect call.
    */
   if (contextID == None) {
      __glXSendError(dpy, GLXBadContext, contextID, X_GLXIsDirect, false);
      return NULL;
   }
d1356 1
a1356 1
   if (__glXIsDirect(dpy, contextID))
d1399 8
a1406 1
   numProps = nPropListBytes / (2 * sizeof(propList[0]));
d1409 1
a1409 1
   renderType = GLX_RGBA_TYPE; /* By default, assume RGBA context */
d1412 1
a1412 1
   for (i = 0, pProp = propList; i < numProps; i++, pProp += 2)
a1413 4
      case GLX_SCREEN:
	 screen = pProp[1];
	 got_screen = True;
	 break;
d1418 1
a1418 1
	 visualID = pProp[1];
d1421 1
a1421 1
	 fbconfigID = pProp[1];
a1427 13
   if (!got_screen)
      return NULL;

   psc = GetGLXScreenConfigs(dpy, screen);
   if (psc == NULL)
      return NULL;

   if (fbconfigID != 0) {
      mode = glx_config_find_fbconfig(psc->configs, fbconfigID);
   } else if (visualID != 0) {
      mode = glx_config_find_visual(psc->visuals, visualID);
   }

d1480 1
a1480 1
   return (ctx == NULL) ? None : ctx->xid;
d1484 1
a1484 1
glXFreeContextEXT(Display *dpy, GLXContext ctx)
d1486 2
a1487 1
   struct glx_context *gc = (struct glx_context *) ctx;
a1488 19
   if (gc == NULL || gc->xid == None)
      return;

   /* The GLX_EXT_import_context spec says:
    *
    *     "glXFreeContext does not free the server-side context information or
    *     the XID associated with the server-side context."
    *
    * Don't send any protocol.  Just destroy the client-side tracking of the
    * context.  Also, only release the context structure if it's not current.
    */
   __glXLock();
   if (gc->currentDpy) {
      gc->xid = None;
   } else {
      gc->vtable->destroy(gc);
   }
   __glXUnlock();
}
d1504 1
a1504 1
         free(config_list);
d1558 1
a1558 1
      config_list = malloc(num_configs * sizeof *config_list);
d1897 1
a1897 1
   if ((GetGLXPrivScreenConfig(dpy, vis->screen, &priv, &psc) == Success)
d2103 1
a2103 1
					    remainder, False);
d2243 2
a2244 1
         (*psc->driScreen->copySubBuffer) (pdraw, x, y, width, height, True);
d2330 1
a2330 1
   copy = malloc(strlen(str) + 1);
a2478 3
   /*** GLX_ARB_create_context and GLX_ARB_create_context_profile ***/
   GLX_FUNCTION(glXCreateContextAttribsARB),

d2482 1
d2496 1
d2519 3
d2525 2
a2526 2
#ifdef GLX_SHARED_GLAPI
      f = (gl_function) __indirect_get_proc_address((const char *) procName);
a2527 9
      if (!f)
         f = (gl_function) _glapi_get_proc_address((const char *) procName);
      if (!f) {
         struct glx_context *gc = __glXGetCurrentContext();
      
         if (gc != NULL && gc->vtable->get_proc_address != NULL)
            f = gc->vtable->get_proc_address((const char *) procName);
      }
   }
@


1.1.1.3
log
@Import Mesa 9.2.5
@
text
@d186 1
a186 1
   if ((*ppsc)->configs == NULL && (*ppsc)->visuals == NULL) {
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d51 1
d53 1
d388 1
a388 3
   if (psc)
      config = glx_config_find_visual(psc->visuals, vis->visualid);

a696 7
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
   struct glx_display *const priv = __glXInitialize(dpy);

   if (priv == NULL)
      return None;
#endif

d728 1
d802 1
a802 1
      if (priv != NULL && pdraw != NULL) {
d920 5
a924 1
      config->renderType = GLX_RGBA_BIT;
a926 1
   config->drawableType = GLX_WINDOW_BIT;
d935 2
d1105 1
a1105 1
    * the GLX 1.4 specification.
a1133 3
   PREFER_SMALLER(sampleBuffers);
   PREFER_SMALLER(samples);

d1147 6
d1383 13
a1436 3
   if (priv == NULL)
      return NULL;

d1753 1
a1753 2
   if (gc->isDirect && psc && psc->driScreen &&
          psc->driScreen->setSwapInterval) {
d1799 1
a1799 1
      if (psc && psc->driScreen && psc->driScreen->setSwapInterval) {
d1821 1
a1821 1
      if (psc && psc->driScreen && psc->driScreen->getSwapInterval) {
d1865 1
a1865 1
   if (psc && psc->driScreen && psc->driScreen->getDrawableMSC) {
d1903 1
a1903 1
   if (psc && psc->driScreen && psc->driScreen->waitForMSC) {
d2098 1
a2098 1
__glxGetMscRate(struct glx_screen *psc,
d2102 1
d2107 1
d2183 1
a2183 1
   return __glxGetMscRate(draw->psc, numerator, denominator);
a2604 6

   /*** GLX_MESA_query_renderer ***/
   GLX_FUNCTION(glXQueryRendererIntegerMESA),
   GLX_FUNCTION(glXQueryRendererStringMESA),
   GLX_FUNCTION(glXQueryCurrentRendererIntegerMESA),
   GLX_FUNCTION(glXQueryCurrentRendererStringMESA),
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d44 2
a45 2
#include "apple/apple_glx_context.h"
#include "apple/apple_glx.h"
d2584 1
a2584 1
#if defined(GLX_DIRECT_RENDERING) && defined(GLX_USE_DRM)
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d44 2
a45 2
#include "apple_glx_context.h"
#include "apple_glx.h"
d2584 1
a2584 1
#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
@


